<!DOCTYPE html><html><head><title>Help for package DGCA</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {DGCA}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#DGCA'><p>DGCA: An R package for Differential Gene Correlation Analysis</p></a></li>
<li><a href='#adjustPVals'><p>Adjusts a numeric vector of p-values.</p></a></li>
<li><a href='#ages_darmanis'><p>Brain sample ages vector.</p></a></li>
<li><a href='#bigEmpPVals'><p>Use speed-optimized sorting to calculate p-values observed and simulated null test statistic using a reference pool distribution.</p></a></li>
<li><a href='#corMats-class'><p>An S4 class to store correlation matrices and associated info.</p></a></li>
<li><a href='#darmanis'><p>Single-cell gene expression data from different brain cell types.</p></a></li>
<li><a href='#dCorAvg'><p>Get average empirical differential correlations.</p></a></li>
<li><a href='#dCorClass'><p>Classify differential correlations.</p></a></li>
<li><a href='#dCorMats'><p>Finds differential correlations between matrices.</p></a></li>
<li><a href='#dCorrs'><p>Differential correlation between two conditions.</p></a></li>
<li><a href='#dcPair-class'><p>S4 class for pairwise differential correlation matrices and associated info.</p></a></li>
<li><a href='#dcTopPairs'><p>Creates a data frame for the top differentially correlated gene pairs in your data set.</p></a></li>
<li><a href='#ddcorAll'><p>Calls the DGCA pairwise pipeline.</p></a></li>
<li><a href='#ddcorFindSignificant'><p>Find groups of differentially correlated gene symbols.</p></a></li>
<li><a href='#ddcorGO'><p>Gene ontology of differential correlation-classified genes.</p></a></li>
<li><a href='#ddMEGENA'><p>Integration function to use MEGENA to perform network analyses of DGCA results.</p></a></li>
<li><a href='#ddplot'><p>Create a heatmap showing the correlations in two conditions.</p></a></li>
<li><a href='#design_mat'><p>Design matrix of cell type specifications of the single-cell RNA-seq samples.</p></a></li>
<li><a href='#extractModuleGO'><p>Extract results from the module GO analysis</p></a></li>
<li><a href='#filterGenes'><p>Filter rows out of a matrix.</p></a></li>
<li><a href='#findGOTermEnrichment'><p>Find GO enrichment for a gene vector (using GOstats).</p></a></li>
<li><a href='#getCors'><p>Compute matrices necessary for differential correlation calculation.</p></a></li>
<li><a href='#getDCorPerm'><p>Get permuted groupwise correlations and pairwise differential correlations.</p></a></li>
<li><a href='#getDCors'><p>Get groupwise correlations and pairwise differential correlations.</p></a></li>
<li><a href='#getGroupsFromDesign'><p>Split input matrix(es) based on the design matrix.</p></a></li>
<li><a href='#makeDesign'><p>Create a design matrix from a character vector.</p></a></li>
<li><a href='#matCorr'><p>Calculate a correlation matrix.</p></a></li>
<li><a href='#matCorSig'><p>Calculate correlation matrix p-values.</p></a></li>
<li><a href='#matNSamp'><p>Find the number of non-missing values.</p></a></li>
<li><a href='#moduleDC'><p>Calculate modular differential connectivity (MDC)</p></a></li>
<li><a href='#moduleGO'><p>Perform module GO-trait correlation</p></a></li>
<li><a href='#pairwiseDCor'><p>Calculate pairwise differential correlations.</p></a></li>
<li><a href='#permQValue'><p>Calculate q-values from DGCA class objects based on permutation-based empirical null statistics.</p></a></li>
<li><a href='#plotCors'><p>Plot gene pair correlations in multiple conditions.</p></a></li>
<li><a href='#plotGOOneGroup'><p>Plot results from a hypergeometric enrichment test for one condition.</p></a></li>
<li><a href='#plotGOTwoGroups'><p>Plot results from a hypergeometric enrichment test to compare two conditions.</p></a></li>
<li><a href='#plotModuleGO'><p>Plot extracted results from module-based GO enrichment analysis using ggplot2.</p></a></li>
<li><a href='#plotVals'><p>Creates a dotplot of the overall values for an individual gene in multiple conditions.</p></a></li>
<li><a href='#switchGenesToHGCN'><p>Switches a gene vector to cleaned HGNC symbols.</p></a></li>
<li><a href='#topDCGenes'><p>Ranks genes by their total number of differentially correlated gene pairs.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Differential Gene Correlation Analysis</td>
</tr>
<tr>
<td>Description:</td>
<td>Performs differential correlation analysis on input
    matrices, with multiple conditions specified by a design matrix. Contains
    functions to filter, process, save, visualize, and interpret differential
    correlations of identifier-pairs across the entire identifier space, or with
    respect to a particular set of identifiers (e.g., one). Also contains several
    functions to perform differential correlation analysis on clusters (i.e., modules)
    or genes. Finally, it contains functions to generate empirical p-values for the
    hypothesis tests and adjust them for multiple comparisons. Although the package
    was built with gene expression data in mind, it is applicable to other types of
    genomics data as well, in addition to being potentially applicable to data from
    other fields entirely. It is described more fully in the manuscript
    introducing it, freely available at &lt;<a href="https://doi.org/10.1186%2Fs12918-016-0349-1">doi:10.1186/s12918-016-0349-1</a>&gt;.</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.3</td>
</tr>
<tr>
<td>Author:</td>
<td>Bin Zhang [aut],
    Andrew McKenzie [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Andrew McKenzie &lt;amckenz@gmail.com&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.2)</td>
</tr>
<tr>
<td>Imports:</td>
<td>WGCNA, matrixStats, methods</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, impute, gplots, fdrtool, testthat, ggplot2, plotrix,
GOstats, HGNChelper, org.Hs.eg.db, AnnotationDbi, abind,
MEGENA, Matrix, doMC, igraph, cowplot, stats, utils</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>5.0.1</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-03-15 17:48:06 UTC; andrewmckenzie</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-03-15 23:40:06 UTC</td>
</tr>
</table>
<hr>
<h2 id='DGCA'>DGCA: An R package for Differential Gene Correlation Analysis</h2><span id='topic+DGCA'></span><span id='topic+DGCA-package'></span>

<h3>Description</h3>

<p>The DGCA package provides three major classes of functions:
1) Functions to calculate correlations, correlation significances, and number of samples in each correlation calculation based on an input matrix and a design matrix.
2) Functions to calculate differential correlations between regions, which in the current package can only be pairwise (i.e., one condition vs another).
3) Functions to extract, sort information about the differential correlation calculations in a convenient format.
The first two functions comprise the discovery of differential correlation (ddcor) portion of the package, which is why the names of the functions and object names often begin with ddcor.
Note that DGCA makes use of the 	SAF = getOption(&quot;stringsAsFactors&quot;); on.exit(options(stringsAsFactors = SAF)); options(stringsAsFactors = FALSE) design pattern many times in order to avoid errors related to stringsAsFactors in porting code to new environments. This should not affect the stringsAsFactors options in your environment; however, you may want to be aware of this.
</p>

<hr>
<h2 id='adjustPVals'>Adjusts a numeric vector of p-values.</h2><span id='topic+adjustPVals'></span>

<h3>Description</h3>

<p>Wraps around the R base implementation of p.adjust, as well as the methods used in the fdr tool package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>adjustPVals(pVals, adjust = "none", plotFdr = FALSE, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="adjustPVals_+3A_pvals">pVals</code></td>
<td>
<p>Numeric vector of p-values to adjust.</p>
</td></tr>
<tr><td><code id="adjustPVals_+3A_adjust">adjust</code></td>
<td>
<p>Allows for resulting p-values to be corrected for multiple hypothesis tests. Optional and some non-default choices require the &quot;fdrtool&quot; package. Default = &quot;none&quot;, which means that no p-value adjustment is performed. Other options include methods in ?p.adjust (i.e., &quot;holm&quot;, &quot;hochberg&quot;, &quot;hommel&quot;, &quot;bonferroni&quot;, &quot;BH&quot;, &quot;BY&quot;, &quot;fdr&quot;), and methods in ?fdrtool (i.e., &quot;fndr&quot;, &quot;pct0&quot;, &quot;locfdr&quot;).</p>
</td></tr>
<tr><td><code id="adjustPVals_+3A_plotfdr">plotFdr</code></td>
<td>
<p>Allows for plotting of fdrtool p-value adjustment result, if this is chosen. Requires fdrtool package. Default = FALSE.</p>
</td></tr>
<tr><td><code id="adjustPVals_+3A_verbose">verbose</code></td>
<td>
<p>If TRUE, the function prints out the general method used for multiple correction analysis. Default = FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector of p-values that have been adjusted according to the specified method.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pvals = runif(100, 0, 1)
adj_pvals_bh = adjustPVals(pvals, adjust = "BH")
adj_pvals_hommel = adjustPVals(pvals, adjust = "hommel")
</code></pre>

<hr>
<h2 id='ages_darmanis'>Brain sample ages vector.</h2><span id='topic+ages_darmanis'></span>

<h3>Description</h3>

<p>A vector specifying the ages of the brain cell types from the single-cell RNA-seq study. The total data set can be downloaded by following the links in the original paper.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ages_darmanis
</code></pre>


<h3>Format</h3>

<p>An object of class <code>numeric</code> of length 158.</p>


<h3>References</h3>

<p>Darmanis S, Sloan SA, Zhang Y, et al. A survey of human brain transcriptome diversity at the single cell level. Proc Natl Acad Sci USA. 2015;112(23):7285-90.
</p>

<hr>
<h2 id='bigEmpPVals'>Use speed-optimized sorting to calculate p-values observed and simulated null test statistic using a reference pool distribution.</h2><span id='topic+bigEmpPVals'></span>

<h3>Description</h3>

<p>A reimplementation of qvalue::empPvals designed to work faster and require less memory in the average case. Unlike qvalue::empPvals, *requires* the use of a reference pool distribution rather than having this as an option. Another difference of this function that the original is that it handles ties for test statistics equal to 0, to handle cases where test statistics are thresholded and may be zero more commonly than expected by chance (i.e., very rarely).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bigEmpPVals(stat, stat0, increasing = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bigEmpPVals_+3A_stat">stat</code></td>
<td>
<p>The vector of test statistics for which p-values should be returned.</p>
</td></tr>
<tr><td><code id="bigEmpPVals_+3A_stat0">stat0</code></td>
<td>
<p>The vector or matrix of simulated null test statistics (if matrix, will be coerced to a vector).</p>
</td></tr>
<tr><td><code id="bigEmpPVals_+3A_increasing">increasing</code></td>
<td>
<p>Logical indicating whether the test statistics because more extreme as they increase in value from 0. Negative numbers are not allowed as inputs (i.e., the test statistic must be monotonic).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of p-values adjusted for the null statistics calculated, to be used as an input to the qvalue function.
</p>


<h3>Author(s)</h3>

<p>John Storey, Andrew McKenzie
</p>


<h3>References</h3>

<p>Please see ?qvalue::empPVals for more; from which this function was adapted.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>test_stat = rnorm(100, 1, 1)
test_stat0 = rnorm(1000, 0, 1)
emp_pvals = bigEmpPVals(test_stat, test_stat0)
</code></pre>

<hr>
<h2 id='corMats-class'>An S4 class to store correlation matrices and associated info.</h2><span id='topic+corMats-class'></span>

<h3>Description</h3>

<p>An S4 class to store correlation matrices and associated info.
</p>


<h3>Slots</h3>


<dl>
<dt><code>corMatList</code></dt><dd><p>List of correlation, number of sample, and correlation significance matrices in each condition.</p>
</dd>
<dt><code>design</code></dt><dd><p>Design matrix inputted into the function.</p>
</dd>
<dt><code>options</code></dt><dd><p>Character vector of options used in the function.</p>
</dd>
</dl>

<hr>
<h2 id='darmanis'>Single-cell gene expression data from different brain cell types.</h2><span id='topic+darmanis'></span>

<h3>Description</h3>

<p>This data set has been filtered to include the genes that are in the 95th percentile or above in both oligodendrocytes and neurons. The total data set can be downloaded by following the links in the original paper.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>darmanis
</code></pre>


<h3>Format</h3>

<p>An object of class <code>data.frame</code> with 572 rows and 158 columns.</p>


<h3>References</h3>

<p>Darmanis S, Sloan SA, Zhang Y, et al. A survey of human brain transcriptome diversity at the single cell level. Proc Natl Acad Sci USA. 2015;112(23):7285-90.
</p>

<hr>
<h2 id='dCorAvg'>Get average empirical differential correlations.</h2><span id='topic+dCorAvg'></span>

<h3>Description</h3>

<p>Finds the average (median or mean) of differential correlations for either one gene versus all others or for all gene pairs in the input matrix of differences in z-scores between conditions, with significance calculated via a comparison with the permutation samples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dCorAvg(zDiff, zDiffPerm, dCorAvgType, oneSidedPVal = FALSE,
  secondMat = FALSE, dCorAvgMethod = "median")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dCorAvg_+3A_zdiff">zDiff</code></td>
<td>
<p>Matrix containing the actual difference of z-scores for each gene-gene pair.</p>
</td></tr>
<tr><td><code id="dCorAvg_+3A_zdiffperm">zDiffPerm</code></td>
<td>
<p>Matrix containing the differences of z-scores for each gene-gene pair in simulated data.</p>
</td></tr>
<tr><td><code id="dCorAvg_+3A_dcoravgtype">dCorAvgType</code></td>
<td>
<p>Character vector specifying the type of average differential correlation calculation that should be performed. Types = c(&quot;gene_average&quot;, &quot;total_average&quot;). gene_average calculates whether each genes' differential correlation with all others is more than expected via permutation samples (and subsequent empirical FDR adjustment, in the case of &gt; 1 gene), while total_average calculates whether the total average differential correlation is higher than expected via permutation samples. If splitSet is specified, then only genes in the splitSet have their average gene differential correlation calculated if gene_average is chosen.</p>
</td></tr>
<tr><td><code id="dCorAvg_+3A_onesidedpval">oneSidedPVal</code></td>
<td>
<p>If the dCorAvgType test is total_average, this option specifies whether a one-sided p-value should be reported, as opposed to a two-sided p-value. That is, if the average difference of z-scores is greater than zero, test whether the permutation average difference of z-scores are less than that average to get the p-value, and vice versa for the case that the average difference of z-scores is less than 0. Otherwise, test whether the absolute value of the average difference in z-scores is greater than the absolute values of the permutation average difference in z-scores. Default = FALSE.</p>
</td></tr>
<tr><td><code id="dCorAvg_+3A_secondmat">secondMat</code></td>
<td>
<p>Logical indicator of whether there is a second matrix in the comparison or not.</p>
</td></tr>
<tr><td><code id="dCorAvg_+3A_dcoravgmethod">dCorAvgMethod</code></td>
<td>
<p>Character vector specifying the method for calculating the &quot;average&quot; differential correlation calculation that should be used. Options = &quot;median&quot;, &quot;mean&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the average difference(s) in z-score and the empirical p-value of that statistic calculated using the permutation samples.
</p>

<hr>
<h2 id='dCorClass'>Classify differential correlations.</h2><span id='topic+dCorClass'></span>

<h3>Description</h3>

<p>Classifies identifiers (e.g., genes) into one of the different categories pairwise-differential correlation classes. These categories are one of the Cartesian products of &quot;Up Correlation&quot;, &quot;No Correlation&quot;, and &quot;Down Correlation&quot; in each of the conditions, as well as a category for &quot;no significant differential correlation&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dCorClass(corsA, pvalsA, corsB, pvalsB, dCorPVals, sigThresh = 1,
  corSigThresh = 0.05, convertClasses = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dCorClass_+3A_corsa">corsA</code></td>
<td>
<p>Numeric vector of correlations between gene pairs in condition A.</p>
</td></tr>
<tr><td><code id="dCorClass_+3A_pvalsa">pvalsA</code></td>
<td>
<p>Numeric vector of the significance of correlation calls between gene pairs in condition A.</p>
</td></tr>
<tr><td><code id="dCorClass_+3A_corsb">corsB</code></td>
<td>
<p>Numeric vector of correlations between gene pairs in condition B.</p>
</td></tr>
<tr><td><code id="dCorClass_+3A_pvalsb">pvalsB</code></td>
<td>
<p>Numeric vector of the significance of correlation calls between gene pairs in condition B.</p>
</td></tr>
<tr><td><code id="dCorClass_+3A_dcorpvals">dCorPVals</code></td>
<td>
<p>Numeric vector of the differential correlation p-value calls.</p>
</td></tr>
<tr><td><code id="dCorClass_+3A_sigthresh">sigThresh</code></td>
<td>
<p>If classify = TRUE, this numeric value specifies the p-value threshold at which a differential correlation p-value is deemed significant for differential correlation class calculation. Default = 1, as investigators may use different cutoff thresholds; however, this can be lowered to establish significant classes as desired.</p>
</td></tr>
<tr><td><code id="dCorClass_+3A_corsigthresh">corSigThresh</code></td>
<td>
<p>Threshold at which the correlation p-values must be below in order to be called &quot;significant&quot;. Default = 0.05.</p>
</td></tr>
<tr><td><code id="dCorClass_+3A_convertclasses">convertClasses</code></td>
<td>
<p>Logical indicating whether the returned classes should be in numeric (factor) format or character format indicating the &quot;actual&quot; class.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector of classes derived from each of the input vectors.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rho1 = runif(100, -1, 1); rho2 = runif(100, -1, 1)
pvalsA = runif(100, 0, 1); pvalsB = runif(100, 0, 1); dcor_pvals = runif(100, 0, 1)
cor_classes = dCorClass(rho1, pvalsA, rho2, pvalsB, dcor_pvals)
cor_classes = dCorClass(rho1, pvalsA, rho2, pvalsB, dcor_pvals, convertClasses = TRUE)
</code></pre>

<hr>
<h2 id='dCorMats'>Finds differential correlations between matrices.</h2><span id='topic+dCorMats'></span>

<h3>Description</h3>

<p>Takes two corresponding correlation and nsamp matrices and returns matrices for the scaled difference in correlation as well as the p-value of that difference.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dCorMats(matA, nmatA, matB, nmatB, corr_cutoff = 0.99, corrType = "pearson",
  secondMat = FALSE, signType = "none")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dCorMats_+3A_mata">matA</code></td>
<td>
<p>Correlation matrix with numeric entries.</p>
</td></tr>
<tr><td><code id="dCorMats_+3A_nmata">nmatA</code></td>
<td>
<p>Number of samples (nsamp) matrix with numeric entries, corresponding to the number of samples used for each of the correlations calculated in matA.</p>
</td></tr>
<tr><td><code id="dCorMats_+3A_matb">matB</code></td>
<td>
<p>Correlation matrix with numeric entries.</p>
</td></tr>
<tr><td><code id="dCorMats_+3A_nmatb">nmatB</code></td>
<td>
<p>Number of samples (nsamp) matrix with numeric entries, corresponding to the number of samples used for each of the correlations calculated in matB.</p>
</td></tr>
<tr><td><code id="dCorMats_+3A_corr_cutoff">corr_cutoff</code></td>
<td>
<p>Cutoff specifying correlation values beyond which will be truncated to this value, to reduce the effect of outlier correlation values when using small sample sizes. Note that this does NOT affect the reported underlying correlation values, but does affect the z-score difference of correlation calculation.</p>
</td></tr>
<tr><td><code id="dCorMats_+3A_corrtype">corrType</code></td>
<td>
<p>The correlation type of the analysis, limited to &quot;pearson&quot; or &quot;spearman&quot;.</p>
</td></tr>
<tr><td><code id="dCorMats_+3A_secondmat">secondMat</code></td>
<td>
<p>Logical indicator of whether there is a second matrix in the comparison or not. If no, then computations will only be performed the upper triangle of the input matrices.</p>
</td></tr>
<tr><td><code id="dCorMats_+3A_signtype">signType</code></td>
<td>
<p>Coerce all correlation coefficients to be either positive (via &quot;positive&quot;), negative (via &quot;negative&quot;), or none (via &quot;none&quot;). This could be used if you think that going from a positive to a negative correlation is unlikely to occur biologically and is more likely to be due to noise, and you want to ignore these effects. Note that this does NOT affect the reported underlying correlation values, but does affect the z-score difference of correlation calculation. Default = &quot;none&quot;, for no coercing.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of two differential correlation matrices: one for the difference in z-scores and one for the corresponding p-values.
</p>

<hr>
<h2 id='dCorrs'>Differential correlation between two conditions.</h2><span id='topic+dCorrs'></span>

<h3>Description</h3>

<p>Z-transforms correlation coefficients (Pearson or Spearman) and then calculates the difference in z-scores between the two conditions divided by the square root of the standard errors (which is inversely proportion to the sample sizes used to calculate the correlations).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dCorrs(rho1, n1, rho2, n2, corrType = "pearson")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dCorrs_+3A_rho1">rho1</code></td>
<td>
<p>Numeric vector of correlation coefficients in condition 1.</p>
</td></tr>
<tr><td><code id="dCorrs_+3A_n1">n1</code></td>
<td>
<p>Numeric vector of the number of samples used in the correlation calculations in condition 1.</p>
</td></tr>
<tr><td><code id="dCorrs_+3A_rho2">rho2</code></td>
<td>
<p>Numeric vector of correlation coefficients in condition 2.</p>
</td></tr>
<tr><td><code id="dCorrs_+3A_n2">n2</code></td>
<td>
<p>Numeric vector of the number of samples used in the correlation calculations in condition 2.</p>
</td></tr>
<tr><td><code id="dCorrs_+3A_corrtype">corrType</code></td>
<td>
<p>The correlation type of the analysis, limited to &quot;pearson&quot; or &quot;spearman&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric vector with scaled difference in z-scores of correlations between the two conditions.
</p>


<h3>References</h3>

<p>Tests For Rank Correlation Coefficients, I. http://biomet.oxfordjournals.org/content/44/3-4/470.full.pdf+html
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rho1 = runif(100, -1, 1); rho2 = runif(100, -1, 1)
n1 = rep(100, 100); n2 = rep(110, 100)
dcorrs_res = dCorrs(rho1, n1, rho2, n2)
</code></pre>

<hr>
<h2 id='dcPair-class'>S4 class for pairwise differential correlation matrices and associated info.</h2><span id='topic+dcPair-class'></span>

<h3>Description</h3>

<p>S4 class for pairwise differential correlation matrices and associated info.
</p>


<h3>Slots</h3>


<dl>
<dt><code>corA</code></dt><dd><p>Correlation matrix for identifiers in condition A.</p>
</dd>
<dt><code>corPvalA</code></dt><dd><p>Matrix of correlation significances in condition A.</p>
</dd>
<dt><code>corB</code></dt><dd><p>Correlation matrix for identifiers in condition B.</p>
</dd>
<dt><code>corPvalB</code></dt><dd><p>Matrix of correlation significances in condition B.</p>
</dd>
<dt><code>ZDiff</code></dt><dd><p>Matrix of differences in z-values between conditions.</p>
</dd>
<dt><code>PValDiff</code></dt><dd><p>Matrix of p-values for differences in z-values between conditions.</p>
</dd>
<dt><code>options</code></dt><dd><p>Character vector of options used in the function.</p>
</dd>
</dl>

<hr>
<h2 id='dcTopPairs'>Creates a data frame for the top differentially correlated gene pairs in your data set.</h2><span id='topic+dcTopPairs'></span>

<h3>Description</h3>

<p>Reads in a dcPair object and outputs a table of all gene pairs (or just the top n pairs), sorted by their unadjusted differential correlation p-value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dcTopPairs(dcObject, nPairs, adjust = "none", plotFdr = FALSE,
  classify = TRUE, sigThresh = 1, corSigThresh = 0.05,
  zScorePerm = NULL, verbose = FALSE, compare = NULL, secondMat = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dcTopPairs_+3A_dcobject">dcObject</code></td>
<td>
<p>The dcPair class object which you'd like to convert into a table.</p>
</td></tr>
<tr><td><code id="dcTopPairs_+3A_npairs">nPairs</code></td>
<td>
<p>The number of gene pairs to display in the resulting table.</p>
</td></tr>
<tr><td><code id="dcTopPairs_+3A_adjust">adjust</code></td>
<td>
<p>Allows for resulting p-values to be corrected for multiple hypothesis tests, optional. Some non-default choices require the &quot;fdrtool&quot; package or the &quot;qvalue&quot;. Default = &quot;none&quot;, which means that no p-value adjustment is performed. Other options include &quot;perm&quot; to use permutation samples, methods in ?p.adjust (i.e., &quot;holm&quot;, &quot;hochberg&quot;, &quot;hommel&quot;, &quot;bonferroni&quot;, &quot;BH&quot;, &quot;BY&quot;, &quot;fdr&quot;), and methods in ?fdrtool (i.e., &quot;fndr&quot;, &quot;pct0&quot;, &quot;locfdr&quot;).</p>
</td></tr>
<tr><td><code id="dcTopPairs_+3A_plotfdr">plotFdr</code></td>
<td>
<p>Allows for plotting of p-value adjustment result, if this is chosen. Requires fdrtool or qvalue package. Default = FALSE.</p>
</td></tr>
<tr><td><code id="dcTopPairs_+3A_classify">classify</code></td>
<td>
<p>Binary value specifying whether the correlation values in each condition and differential correlation scores should be used to classifying the resulting identifiers into groups. Default = TRUE</p>
</td></tr>
<tr><td><code id="dcTopPairs_+3A_sigthresh">sigThresh</code></td>
<td>
<p>If classify = TRUE, this numeric value specifies the p-value threshold at which a differential correlation p-value is deemed significant for differential correlation class calculation. Default = 1, as investigators may use different cutoff thresholds; however, this can be lowered to establish significant classes as desired.</p>
</td></tr>
<tr><td><code id="dcTopPairs_+3A_corsigthresh">corSigThresh</code></td>
<td>
<p>If classify = TRUE, this numeric value specifies the p-value threshold at which a correlation p-value is deemed significant. Default = 0.05.</p>
</td></tr>
<tr><td><code id="dcTopPairs_+3A_zscoreperm">zScorePerm</code></td>
<td>
<p>A matrix of values with z-scores from permutation tests to be used to generate empirical p-values. Default = NULL.</p>
</td></tr>
<tr><td><code id="dcTopPairs_+3A_verbose">verbose</code></td>
<td>
<p>Whether summaries of the operations should be reported.</p>
</td></tr>
<tr><td><code id="dcTopPairs_+3A_compare">compare</code></td>
<td>
<p>Vector of two character strings, each corresponding to one group name in the design matrix, that should be compared.</p>
</td></tr>
<tr><td><code id="dcTopPairs_+3A_secondmat">secondMat</code></td>
<td>
<p>Logical indicator of whether there is a second matrix in the comparison or not.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A table containing columns for each name in the considered gene pair (the order of which is arbitrary), correlation values in each condition, differences in z-score of the correlation, and p-values for that z-score difference.
</p>

<hr>
<h2 id='ddcorAll'>Calls the DGCA pairwise pipeline.</h2><span id='topic+ddcorAll'></span>

<h3>Description</h3>

<p>Runs the full discovery of differential correlation (ddcor) section for comparing pairwise correlations across conditions in the Differential Gene Correlation Analysis (DGCA) package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ddcorAll(inputMat, design, compare, inputMatB = NULL, splitSet = NULL,
  impute = FALSE, corrType = "pearson", nPairs = "all",
  sortBy = "zScoreDiff", adjust = "perm", nPerms = 10, classify = TRUE,
  sigThresh = 1, corSigThresh = 0.05, heatmapPlot = FALSE,
  color_palette = NULL, verbose = FALSE, plotFdr = FALSE,
  corr_cutoff = 0.99, signType = "none", getDCorAvg = FALSE,
  dCorAvgType = "gene_average", dCorAvgMethod = "median",
  oneSidedPVal = FALSE, customize_heatmap = FALSE, heatmapClassic = FALSE,
  corPower = 2, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ddcorAll_+3A_inputmat">inputMat</code></td>
<td>
<p>The matrix (or data.frame) of values (e.g., gene expression values from an RNA-seq or microarray study) that you are interested in analyzing. The rownames of this matrix should correspond to the identifiers whose correlations and differential correlations you are interested in analyzing, while the columns should correspond to the rows of the design matrix and should be separable into your groups.</p>
</td></tr>
<tr><td><code id="ddcorAll_+3A_design">design</code></td>
<td>
<p>A standard model.matrix created design matrix. Rows correspond to samples and colnames refer to the names of the conditions that you are interested in analyzing. Only 0's or 1's are allowed in the design matrix. Please see vignettes for more information.</p>
</td></tr>
<tr><td><code id="ddcorAll_+3A_compare">compare</code></td>
<td>
<p>Vector of two character strings, each corresponding to one group name in the design matrix, that should be compared.</p>
</td></tr>
<tr><td><code id="ddcorAll_+3A_inputmatb">inputMatB</code></td>
<td>
<p>Optional, secondary input matrix that allows you to calculate correlation and differential correlation for the rows between inputMat and imputMatB. Default = NULL.</p>
</td></tr>
<tr><td><code id="ddcorAll_+3A_splitset">splitSet</code></td>
<td>
<p>Optional character vector that splits the first matrix into two matrices and calculates differential correlation across these matrices. Common use case is when you want the differential correlation of a small set of identifiers (e.g., one), compared with all of the other identifiers in the matrix in each condition. Cannot be used when a second matrix is inputted &ndash; setting both of arguments to non-NULL values will result in an error.</p>
</td></tr>
<tr><td><code id="ddcorAll_+3A_impute">impute</code></td>
<td>
<p>A binary variable specifying whether values should be imputed if there are missing values. Note that the imputation is performed in the full input matrix (i.e., prior to subsetting) and uses k-nearest neighbors.</p>
</td></tr>
<tr><td><code id="ddcorAll_+3A_corrtype">corrType</code></td>
<td>
<p>The correlation type of the analysis, limited to &quot;pearson&quot; or &quot;spearman&quot;. Default = &quot;pearson&quot;.</p>
</td></tr>
<tr><td><code id="ddcorAll_+3A_npairs">nPairs</code></td>
<td>
<p>Either a number, specifying the number of top differentially correlated identifier pairs to display in the resulting table, or a the string &quot;all&quot; specifying that all of the pairs should be returned. If splitSet is specified, this is reset to the number of non-splitSet identifiers in the input matrix, and therefore will not be evaluated.</p>
</td></tr>
<tr><td><code id="ddcorAll_+3A_sortby">sortBy</code></td>
<td>
<p>Character string specifying the way by which you'd like to sort the resulting table.</p>
</td></tr>
<tr><td><code id="ddcorAll_+3A_adjust">adjust</code></td>
<td>
<p>Allows for resulting p-values to be corrected for multiple hypothesis tests, optional. Some non-default choices require the &quot;fdrtool&quot; package or the &quot;qvalue&quot;. Default = &quot;none&quot;, which means that no p-value adjustment is performed. Other options include &quot;perm&quot; to use permutation samples, methods in ?p.adjust (i.e., &quot;holm&quot;, &quot;hochberg&quot;, &quot;hommel&quot;, &quot;bonferroni&quot;, &quot;BH&quot;, &quot;BY&quot;, &quot;fdr&quot;), and methods in ?fdrtool (i.e., &quot;fndr&quot;, &quot;pct0&quot;, &quot;locfdr&quot;).</p>
</td></tr>
<tr><td><code id="ddcorAll_+3A_nperms">nPerms</code></td>
<td>
<p>Number of permutations to generate. If NULL, permutation testing will not be performed. Default = &quot;10&quot;.</p>
</td></tr>
<tr><td><code id="ddcorAll_+3A_classify">classify</code></td>
<td>
<p>Binary value specifying whether the correlation values in each condition and differential correlation scores should be used to classifying the resulting identifiers into groups. Default = TRUE</p>
</td></tr>
<tr><td><code id="ddcorAll_+3A_sigthresh">sigThresh</code></td>
<td>
<p>If classify = TRUE, this numeric value specifies the p-value threshold at which a differential correlation p-value is deemed significant for differential correlation class calculation. Default = 1, as investigators may use different cutoff thresholds; however, this can be lowered to establish significant classes as desired.</p>
</td></tr>
<tr><td><code id="ddcorAll_+3A_corsigthresh">corSigThresh</code></td>
<td>
<p>If classify = TRUE, this numeric value specifies the p-value threshold at which a correlation p-value is deemed significant. Default = 0.05.</p>
</td></tr>
<tr><td><code id="ddcorAll_+3A_heatmapplot">heatmapPlot</code></td>
<td>
<p>Option indicating whether a heatmap of the differential correlations between the two conditions should be plotted. Default = TRUE.</p>
</td></tr>
<tr><td><code id="ddcorAll_+3A_color_palette">color_palette</code></td>
<td>
<p>Color palette for plotting the heatmap. If not specified, the heatmap defaults to a red-green color-blind palette with bluish green indicating negative correlations and vermillion indicating positive correlations. Default = NULL</p>
</td></tr>
<tr><td><code id="ddcorAll_+3A_verbose">verbose</code></td>
<td>
<p>Option indicating whether the program should give more frequent updates about its operations. Default = FALSE.</p>
</td></tr>
<tr><td><code id="ddcorAll_+3A_plotfdr">plotFdr</code></td>
<td>
<p>Allows for plotting of fdrtool p-value adjustment result OR empirical FDR q-value adjustment technique, if either of these are chosen. Requires fdrtool package OR qvalue package. Default = FALSE.</p>
</td></tr>
<tr><td><code id="ddcorAll_+3A_corr_cutoff">corr_cutoff</code></td>
<td>
<p>Cutoff specifying correlation values beyond which will be truncated to this value, to reduce the effect of outlier correlation values when using small sample sizes. Note that this does NOT affect the underlying correlation values, but does affect the z-score difference of correlation calculation in the dcTopPairs table. Default = 0.99</p>
</td></tr>
<tr><td><code id="ddcorAll_+3A_signtype">signType</code></td>
<td>
<p>Coerce all correlation coefficients to be either positive (via &quot;positive&quot;), negative (via &quot;negative&quot;), or none (via &quot;none&quot;) prior to calculating differential correlation. This could be used if, e.g., you think that going from a positive to a negative correlation is unlikely to occur biologically and is more likely to be due to noise, and you want to ignore these effects. Note that this does NOT affect the reported underlying correlation values, but does affect the z-score difference of correlation calculation. Default = &quot;none&quot;, for no coercing.</p>
</td></tr>
<tr><td><code id="ddcorAll_+3A_getdcoravg">getDCorAvg</code></td>
<td>
<p>Logical, specifying whether the average difference in correlation between groups should be calculated. Default = FALSE</p>
</td></tr>
<tr><td><code id="ddcorAll_+3A_dcoravgtype">dCorAvgType</code></td>
<td>
<p>Character vector specifying the type of average differential correlation calculation that should be performed. Only evaluated if dCorAge is TRUE. Types = c(&quot;gene_average&quot;, &quot;total_average&quot;, &quot;both&quot;). gene_average calculates whether each genes' differential correlation with all others is more than expected via permutation samples (and empirical FDR adjustment, in the case of &gt; 1 gene), while total_average calculates whether the total average differential correlation is higher than expected via permutation samples. &quot;both&quot; performs both of these. If splitSet is specified, then only genes in the splitSet have their average gene differential correlation calculated if gene_average is chosen.</p>
</td></tr>
<tr><td><code id="ddcorAll_+3A_dcoravgmethod">dCorAvgMethod</code></td>
<td>
<p>Character vector specifying the method for calculating the &quot;average&quot; differential correlation calculation that should be used. Options = &quot;median&quot;, &quot;mean&quot;.</p>
</td></tr>
<tr><td><code id="ddcorAll_+3A_onesidedpval">oneSidedPVal</code></td>
<td>
<p>If the dCorAvgType test is total_average, this option specifies whether a one-sided p-value should be reported, as opposed to a two-sided p-value. That is, if the average difference of z-scores is greater than zero, test whether the permutation average difference of z-scores are less than that average to get the p-value, and vice versa for the case that the average difference of z-scores is less than 0. Otherwise, test whether the absolute value of the average difference in z-scores is greater than the absolute values of the permutation average difference in z-scores. Default = FALSE.</p>
</td></tr>
<tr><td><code id="ddcorAll_+3A_customize_heatmap">customize_heatmap</code></td>
<td>
<p>Option to remove some default options in the heatmap plot, to allow users to add custom options.</p>
</td></tr>
<tr><td><code id="ddcorAll_+3A_heatmapclassic">heatmapClassic</code></td>
<td>
<p>Option to make the heatmap more granular (e.g., not showing the individual gene symbols) and more of a &quot;classic&quot; type of heatmap. Overrides most other heatmap options.</p>
</td></tr>
<tr><td><code id="ddcorAll_+3A_corpower">corPower</code></td>
<td>
<p>The power to raise the correlations to before plotting the classic heatmap. Larger correlation powers emphasize larger correlation values relatively more compared to smaller correlation values.</p>
</td></tr>
<tr><td><code id="ddcorAll_+3A_...">...</code></td>
<td>
<p>Additional plotting arguments if heatmapPlot = TRUE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Typically, the returned object is a data frame of the table of differential correlations between conditions. In the case that dCorAvg is calculated, the returned object is instead a list containing that table as well as the object summarizing the difference in average correlation for the specified portion of the data set.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(darmanis); data(design_mat); darmanis_subset = darmanis[1:30, ]
ddcor_res = ddcorAll(inputMat = darmanis_subset, design = design_mat,
	compare = c("oligodendrocyte", "neuron"))
</code></pre>

<hr>
<h2 id='ddcorFindSignificant'>Find groups of differentially correlated gene symbols.</h2><span id='topic+ddcorFindSignificant'></span>

<h3>Description</h3>

<p>Takes a table of differentially correlated genes with respect to one gene in the Gene2 column and returns the a list of vectors with unique, non-NA gene symbols for genes in each of the differentially correlated classes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ddcorFindSignificant(ddcor_res, pval_gene_thresh = 0.05, adjusted = FALSE,
  classes = FALSE, geneNameCol = c("Gene1", "Gene2"),
  unique_genes = FALSE, regcor = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ddcorFindSignificant_+3A_ddcor_res">ddcor_res</code></td>
<td>
<p>The table of differential correlations outputted from ddcor. Expected to have pValDiff or pValDiff_adj columns as well as zScoreDiff, Gene1, +/- Classes columns.</p>
</td></tr>
<tr><td><code id="ddcorFindSignificant_+3A_pval_gene_thresh">pval_gene_thresh</code></td>
<td>
<p>p-value threshold to call a gene as having significant differential correlation or not. Default = 0.05</p>
</td></tr>
<tr><td><code id="ddcorFindSignificant_+3A_adjusted">adjusted</code></td>
<td>
<p>Logical indicating whether adjusted p-values from the differential correlation table (i.e., column &quot;pValDiff_adj&quot;, when adjusted = TRUE) or unadjusted p-values (i.e., column &quot;pValDiff&quot;, when adjusted = FALSE) should be used to subset the table into significant and non-significant portions. Default = FALSE</p>
</td></tr>
<tr><td><code id="ddcorFindSignificant_+3A_classes">classes</code></td>
<td>
<p>Logical indicator specifying whether individual differential correlation gene classes should be extracted from the table or not. If not, only the zScoreDiff column is used to specify positively or negatively differentially correlated genes between the two conditions. Default = FALSE</p>
</td></tr>
<tr><td><code id="ddcorFindSignificant_+3A_genenamecol">geneNameCol</code></td>
<td>
<p>Character vector specifying the name of the columns that are used to extract the gene symbols. Note that the default is c(&quot;Gene1&quot;, &quot;Gene2&quot;), but this only makes sense in the context of a full DGCA experiment. In the case of a splitSet, you may want to use &quot;Gene1&quot; to avoid counting the splitSet names in all of the categories.</p>
</td></tr>
<tr><td><code id="ddcorFindSignificant_+3A_unique_genes">unique_genes</code></td>
<td>
<p>Logical, if TRUE indicates that unique gene symbols from each category compared to the other groups should be chosen prior to GO enrichment analysis.</p>
</td></tr>
<tr><td><code id="ddcorFindSignificant_+3A_regcor">regcor</code></td>
<td>
<p>Logical specifying whether the ddcorGO analysis should be performed on the results of a regcor data analysis. Note that the classes option is not available in this case.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of significantly differentially correlated genes.
</p>

<hr>
<h2 id='ddcorGO'>Gene ontology of differential correlation-classified genes.</h2><span id='topic+ddcorGO'></span>

<h3>Description</h3>

<p>Extracts a data frame of the top enriched gene sets in gene ontology databases using the hypergeometric test for gene synmols that are members of gene pairs in each of the classes specified in the differentially correlated gene pairs input table. Default parameter settings are to take in a result table with HGNC symbols and convert them to Ensembl symbols for gene ontology testing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ddcorGO(ddcor_res, universe, pval_gene_thresh = 0.05, classes = FALSE,
  geneNameCol = c("Gene1", "Gene2"), pval_GO_cutoff = 1,
  HGNC_clean = TRUE, HGNC_switch = TRUE, gene_ontology = "all",
  adjusted = FALSE, annotation = "org.Hs.eg.db", conditional = FALSE,
  calculateVariance = FALSE, unique_genes = FALSE, regcor = FALSE,
  ddcor_find_significant = TRUE, ddcorGO_res = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ddcorGO_+3A_ddcor_res">ddcor_res</code></td>
<td>
<p>The table of differential correlations outputted from ddcor. Expected to have pValDiff or pValDiff_adj columns as well as zScoreDiff, Gene1, +/- Classes columns.</p>
</td></tr>
<tr><td><code id="ddcorGO_+3A_universe">universe</code></td>
<td>
<p>Character vector of gene symbols which should be used as the background in the hypergeomtric test. If using this in the context of a DGCA experiment, this gene list most likely should be the gene set post-filtering, but prior to differential correlation analysis.</p>
</td></tr>
<tr><td><code id="ddcorGO_+3A_pval_gene_thresh">pval_gene_thresh</code></td>
<td>
<p>p-value threshold to call a gene as having significant differential correlation or not.</p>
</td></tr>
<tr><td><code id="ddcorGO_+3A_classes">classes</code></td>
<td>
<p>Logical indicator specifying whether individual differential correlation gene classes should be extracted from the table or not. If not, only the zScoreDiff column is used to specify positively or negatively differentially correlated genes between the two conditions.</p>
</td></tr>
<tr><td><code id="ddcorGO_+3A_genenamecol">geneNameCol</code></td>
<td>
<p>Character vector specifying the name of the columns that are used to extract the gene symbols. Note that the default is c(&quot;Gene1&quot;, &quot;Gene2&quot;), but this only makes sense in the context of a full DGCA experiment. In the case of a splitSet, you may want to use &quot;Gene1&quot; to avoid counting the splitSet names in all of the categories.</p>
</td></tr>
<tr><td><code id="ddcorGO_+3A_pval_go_cutoff">pval_GO_cutoff</code></td>
<td>
<p>Cutoff for the unadjusted p-values of gene ontology terms in the enrichment tests that should be displayed in the resulting table.</p>
</td></tr>
<tr><td><code id="ddcorGO_+3A_hgnc_clean">HGNC_clean</code></td>
<td>
<p>Logical indicating whether the input gene symbols should be switched to clean HGNC symbols using the checkGeneSymbols function from the R package HGNChelper. Only applies if HGNC symbols are inputted.</p>
</td></tr>
<tr><td><code id="ddcorGO_+3A_hgnc_switch">HGNC_switch</code></td>
<td>
<p>Logical indicating whether or not the input gene symbols need to be switched from HGNC to Ensembl, the latter of which is required for GOstats enrichment test. Note that this is done by selecting the first Enembl symbol that maps to a particular HGNC symbol, which is not always unique. If you need more precision on the conversion, you should do this outside of the function and insert the Ensembl list to the function.</p>
</td></tr>
<tr><td><code id="ddcorGO_+3A_gene_ontology">gene_ontology</code></td>
<td>
<p>A string specifying the branch of GO that should be used for enrichment analysis. One of &quot;BP&quot; (Biological Process), &quot;MF&quot; (Molecular Function), &quot;CC&quot; (Cellular Component), or &quot;all&quot;. If &quot;all&quot; is chosen, then this function finds the enrichment for all of the terms and combines them into one table. Default = &quot;all&quot;</p>
</td></tr>
<tr><td><code id="ddcorGO_+3A_adjusted">adjusted</code></td>
<td>
<p>Logical indicating whether adjusted p-values from the differential correlation table (i.e., column &quot;pValDiff_adj&quot;, when adjusted = TRUE) or unadjusted p-values (i.e., column &quot;pValDiff&quot;, when adjusted = FALSE) should be used to subset the table into significant and non-significant portions.</p>
</td></tr>
<tr><td><code id="ddcorGO_+3A_annotation">annotation</code></td>
<td>
<p>The library indicating the GO annotation database from which the Go terms should be mapped to gene symbols. Default = &quot;org.Hs.eg.db&quot;, which is the table for Homo sapiens. Other common choices include &quot;org.Mm.eg.db&quot;, &quot;org.Rn.eg.db&quot;. The corresponding annotation library needs to be installed.</p>
</td></tr>
<tr><td><code id="ddcorGO_+3A_conditional">conditional</code></td>
<td>
<p>Logical specifying whether the GO analysis should be done conditionally to take into account the hierarchical structure of the GO database in making sense of the gene set enrichments.</p>
</td></tr>
<tr><td><code id="ddcorGO_+3A_calculatevariance">calculateVariance</code></td>
<td>
<p>Optionally, find the variance of the odds ratio for each enrichment test. In particular, this finds the standard error of the log odds ratio, which converges to a normal distribution much more quickly than the non-log OR.</p>
</td></tr>
<tr><td><code id="ddcorGO_+3A_unique_genes">unique_genes</code></td>
<td>
<p>Logical, if TRUE indicates that unique gene symbols within gene pairs from each category compared to the other groups should be chosen prior to GO enrichment analysis.</p>
</td></tr>
<tr><td><code id="ddcorGO_+3A_regcor">regcor</code></td>
<td>
<p>Logical specifying whether the ddcorGO analysis should be performed on the results of a regcor data analysis. Note that the classes option is not available in this case.</p>
</td></tr>
<tr><td><code id="ddcorGO_+3A_ddcor_find_significant">ddcor_find_significant</code></td>
<td>
<p>Logical specifying whether this enrichment analysis should be performed on the result of a ddcor analysis. If FALSE, then a ddcorGO_res object, which is a named list of gene vectors, must be defined instead.</p>
</td></tr>
<tr><td><code id="ddcorGO_+3A_ddcorgo_res">ddcorGO_res</code></td>
<td>
<p>Optional named list of gene vectors to find the enrichment of if ddcor_find_signficiant is FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of data frames corresponding to the gene ontology enrichment analysis results for the extracted gene sets from each of the differential correlation classes.
</p>


<h3>References</h3>

<p>Agresti A: Categorical Data Analysis. 2012:70-77.
</p>

<hr>
<h2 id='ddMEGENA'>Integration function to use MEGENA to perform network analyses of DGCA results.</h2><span id='topic+ddMEGENA'></span>

<h3>Description</h3>

<p>Takes a table of results from a DGCA analysis and inputs it into the MEGENA package pipeline.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ddMEGENA(ddcor_res, adjusted = TRUE, pval_gene_thresh = 0.05,
  evalCompactness = TRUE, nPerm = 100, hubPVal = 0.05,
  modulePVal = 0.05, minModSize = 10, maxModSize = 1000,
  saveOutput = FALSE, parallelize = FALSE, nCores = 4, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ddMEGENA_+3A_ddcor_res">ddcor_res</code></td>
<td>
<p>The table of differential correlations outputted from ddcor. Expected to have pValDiff or pValDiff_adj columns as well as zScoreDiff, Gene1, +/- Classes columns.</p>
</td></tr>
<tr><td><code id="ddMEGENA_+3A_adjusted">adjusted</code></td>
<td>
<p>Logical indicating whether adjusted p-values from the differential correlation table (i.e., column &quot;pValDiff_adj&quot;, when adjusted = TRUE) or unadjusted p-values (i.e., column &quot;pValDiff&quot;, when adjusted = FALSE) should be used to subset the table into significant and non-significant portions.</p>
</td></tr>
<tr><td><code id="ddMEGENA_+3A_pval_gene_thresh">pval_gene_thresh</code></td>
<td>
<p>p-value threshold to call a gene as having significant differential correlation or not.</p>
</td></tr>
<tr><td><code id="ddMEGENA_+3A_evalcompactness">evalCompactness</code></td>
<td>
<p>Logical indicating whether or not the resulting modules should be filtered for compactness. For inputs with relatively small numbers of significant gene pairs, this may not be desirable. Note that if this option is not chosen, all of the modules will be returned, but some of the module-specific results will not be available for all of these modules.</p>
</td></tr>
<tr><td><code id="ddMEGENA_+3A_nperm">nPerm</code></td>
<td>
<p>The number of permutations to use in evaluating module hubs and module compactness in do.MEGENA.</p>
</td></tr>
<tr><td><code id="ddMEGENA_+3A_hubpval">hubPVal</code></td>
<td>
<p>The p-value threshold used to classify a gene as a hub within a module.</p>
</td></tr>
<tr><td><code id="ddMEGENA_+3A_modulepval">modulePVal</code></td>
<td>
<p>The p-value threshold used to include or disclude modules following module compactness evaluation in do.MEGENA.</p>
</td></tr>
<tr><td><code id="ddMEGENA_+3A_minmodsize">minModSize</code></td>
<td>
<p>The minimum module size.</p>
</td></tr>
<tr><td><code id="ddMEGENA_+3A_maxmodsize">maxModSize</code></td>
<td>
<p>The minimum module size.</p>
</td></tr>
<tr><td><code id="ddMEGENA_+3A_saveoutput">saveOutput</code></td>
<td>
<p>Whether the output of MEGENA should be saved in the current directory. Default = FALSE.</p>
</td></tr>
<tr><td><code id="ddMEGENA_+3A_parallelize">parallelize</code></td>
<td>
<p>Logical indicating whether or not multiple cores should be utilized as a form of parallel processing. Requires the doMC package.</p>
</td></tr>
<tr><td><code id="ddMEGENA_+3A_ncores">nCores</code></td>
<td>
<p>If parallelize is TRUE, the number of cores to use in the processing. Ignored if parallelize is FALSE.</p>
</td></tr>
<tr><td><code id="ddMEGENA_+3A_...">...</code></td>
<td>
<p>Additional arguments to do.MEGENA from the MEGENA R package.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing a the planar filter network, the data frame of identified differentially correlated modules, as well as various other objects including module-specific hub genes, depending on the parameters chosen.
</p>

<hr>
<h2 id='ddplot'>Create a heatmap showing the correlations in two conditions.</h2><span id='topic+ddplot'></span>

<h3>Description</h3>

<p>This function orders the differences in correlations between conditions by the median strength of correlation differences for each gene and plots a heatmap of the correlations in each condition (lower = condition A, upper = condition B) using the heatmap.2 function from the gplots package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ddplot(dcObject = NULL, corMatA = NULL, corMatB = NULL, zDiff = NULL,
  flip = TRUE, color_palette = NULL, customize_heatmap = FALSE,
  heatmapClassic = FALSE, corPower = 2, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ddplot_+3A_dcobject">dcObject</code></td>
<td>
<p>A differential correlation object from which correlation and differential correlation matrices will be extracted. Optional; can also input the correlation matrices and differential correlation matrix individually.</p>
</td></tr>
<tr><td><code id="ddplot_+3A_cormata">corMatA</code></td>
<td>
<p>Optional, correlation matrix from condition A. Will be plotted in the lower left triangle.</p>
</td></tr>
<tr><td><code id="ddplot_+3A_cormatb">corMatB</code></td>
<td>
<p>Optional, correlation matrix from condition B. Will be plotted in the upper right triangle.</p>
</td></tr>
<tr><td><code id="ddplot_+3A_zdiff">zDiff</code></td>
<td>
<p>Optional, difference measure of correlations between conditions A and B.</p>
</td></tr>
<tr><td><code id="ddplot_+3A_flip">flip</code></td>
<td>
<p>Switch the ordering of z-differences to be inverse. Default = TRUE</p>
</td></tr>
<tr><td><code id="ddplot_+3A_color_palette">color_palette</code></td>
<td>
<p>Colors for plotting the heatmap. If not specified, defaults to a color-blind palette where blue corresponds to a negative correlation and orange/red corresponds to a positive one.</p>
</td></tr>
<tr><td><code id="ddplot_+3A_customize_heatmap">customize_heatmap</code></td>
<td>
<p>Option to remove some default options in the heatmap plot, to allow users to add custom options.</p>
</td></tr>
<tr><td><code id="ddplot_+3A_heatmapclassic">heatmapClassic</code></td>
<td>
<p>Option to make the heatmap more granular (e.g., not showing the individual gene symbols) and more of a &quot;classic&quot; type of heatmap. Overrides most other heatmap options.</p>
</td></tr>
<tr><td><code id="ddplot_+3A_corpower">corPower</code></td>
<td>
<p>The power to raise the correlations to before plotting the classic heatmap. Larger correlation powers emphasize larger correlation values relatively more compared to smaller correlation values.</p>
</td></tr>
<tr><td><code id="ddplot_+3A_...">...</code></td>
<td>
<p>Additional plotting arguments to the heatmap.2 function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The sorted difference in z-score matrix in both conditions, which you can use to create your own plot if you'd prefer.
</p>

<hr>
<h2 id='design_mat'>Design matrix of cell type specifications of the single-cell RNA-seq samples.</h2><span id='topic+design_mat'></span>

<h3>Description</h3>

<p>Cell type specifications were performed by the authors. The total data set can be downloaded by following the links in the original paper.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>design_mat
</code></pre>


<h3>Format</h3>

<p>An object of class <code>matrix</code> with 158 rows and 2 columns.</p>


<h3>References</h3>

<p>Darmanis S, Sloan SA, Zhang Y, et al. A survey of human brain transcriptome diversity at the single cell level. Proc Natl Acad Sci USA. 2015;112(23):7285-90.
</p>

<hr>
<h2 id='extractModuleGO'>Extract results from the module GO analysis</h2><span id='topic+extractModuleGO'></span>

<h3>Description</h3>

<p>Turns the list of lists from the moduleGO function into a more comprehensible data frame. Note that if a GO term enrichment does not exist for that module, it is set as NA.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extractModuleGO(moduleGO_list, labels = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extractModuleGO_+3A_modulego_list">moduleGO_list</code></td>
<td>
<p>The list of list of data frames for each module to be turned into a data frame.</p>
</td></tr>
<tr><td><code id="extractModuleGO_+3A_labels">labels</code></td>
<td>
<p>Optional, a list of module names. Optional; if not inputted, these will be extracted from the list of module GO enrichments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame summarizing the GO term enrichments from each group, with columns on the ordered by the minimum p-value for OR term enrichment in any group.
</p>

<hr>
<h2 id='filterGenes'>Filter rows out of a matrix.</h2><span id='topic+filterGenes'></span>

<h3>Description</h3>

<p>Filter out rows in an input matrix that are not above a certain percentile with respect to a central tendency and/or dispersion measure. To be used, e.g, prior to differential correlation testing with the function ddcorall.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>filterGenes(inputMat, filterTypes = "central", keepRows = NULL,
  filterCentralType = "median", filterDispersionType = "dispersion_index",
  filterCentralPercentile = 0.25, filterDispersionPercentile = 0.25,
  sequential = FALSE, allGroups = FALSE, design = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="filterGenes_+3A_inputmat">inputMat</code></td>
<td>
<p>The matrix (or data.frame) of all numeric values (e.g., gene expression values from an RNA-seq or microarray study) that you are interested in analyzing. The rownames of this matrix should correspond to the identifiers that you are interested in protecting from the filter, if any.</p>
</td></tr>
<tr><td><code id="filterGenes_+3A_filtertypes">filterTypes</code></td>
<td>
<p>Vector containing up to two character strings, specifying the methods that should be used for filtering genes. Options include &quot;central&quot; and &quot;dispersion&quot; for filtering based on the measures of central tendency and dispersion, respectively. To use both, set this to c(&quot;central&quot;, &quot;dispersion&quot;).</p>
</td></tr>
<tr><td><code id="filterGenes_+3A_keeprows">keepRows</code></td>
<td>
<p>Optional character vector, specifying rownames (i.e., symbols) that should not be filtered out of the matrix even if they are found to be below the quantile specified for either the central tendency or dispersion, as applicable.</p>
</td></tr>
<tr><td><code id="filterGenes_+3A_filtercentraltype">filterCentralType</code></td>
<td>
<p>Method to be used for filtering for the central tendency of the input matrix. Options = &quot;mean&quot; (for arithmetic mean) and &quot;median&quot;.</p>
</td></tr>
<tr><td><code id="filterGenes_+3A_filterdispersiontype">filterDispersionType</code></td>
<td>
<p>Method to be used for filtering for the dispersion of the input matrix. Options = &quot;dispersion_index&quot;, &quot;cv&quot; (for coefficient of variation), and &quot;variance&quot;.</p>
</td></tr>
<tr><td><code id="filterGenes_+3A_filtercentralpercentile">filterCentralPercentile</code></td>
<td>
<p>If central tendency filtering is used, the quantile of the central tendency below which rows will be filtered out.</p>
</td></tr>
<tr><td><code id="filterGenes_+3A_filterdispersionpercentile">filterDispersionPercentile</code></td>
<td>
<p>If dispersion filtering is used, the quantile of the dispersion measure below which rows will be filtered out.</p>
</td></tr>
<tr><td><code id="filterGenes_+3A_sequential">sequential</code></td>
<td>
<p>If both central tendency and dispersion measures and used for filtering the input matrix, then sequential is a logical flag indicating whether the central tendency filtering steps should be performed prior to the dispersion filtering step (and quantile cutoff specification; if sequential = TRUE), or independently (if sequential = FALSE).</p>
</td></tr>
<tr><td><code id="filterGenes_+3A_allgroups">allGroups</code></td>
<td>
<p>Logical for whether genes need to pass the filter in all of the groups specified in the design matrix.</p>
</td></tr>
<tr><td><code id="filterGenes_+3A_design">design</code></td>
<td>
<p>A standard model.matrix created design matrix. Rows correspond to samples and colnames refer to the names of the conditions that you are interested in analyzing. Only 0's or 1's are allowed in the design matrix. Please see vignettes for more information.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A filtered matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(darmanis); data(design_mat); darmanis_subset = darmanis[1:30, ]
filtered_mat = filterGenes(inputMat = darmanis_subset, filterTypes = "central")
filtered_mat_both = filterGenes(inputMat = darmanis_subset,
 filterTypes = c("central", "dispersion"), filterCentralType = "mean",
 filterDispersionPercentile = 0.1)
filtered_mat_all_groups = filterGenes(inputMat = darmanis_subset,
 design = design_mat, filterTypes = "dispersion", allGroups = TRUE)
</code></pre>

<hr>
<h2 id='findGOTermEnrichment'>Find GO enrichment for a gene vector (using GOstats).</h2><span id='topic+findGOTermEnrichment'></span>

<h3>Description</h3>

<p>Given a gene character vector and a universe character vector, which can be either Ensembl or HGNC symbols, find the over-representation enrichment of the gene list relative to the universe in a gene ontology category using the hypergeometric test and the GOstats R package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>findGOTermEnrichment(gene_vector, universe, pval_GO_cutoff = 1,
  HGNC_switch = TRUE, HGNC_clean = TRUE, gene_ontology = "all",
  conditional = TRUE, annotation = "org.Hs.eg.db", cleanNames = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="findGOTermEnrichment_+3A_gene_vector">gene_vector</code></td>
<td>
<p>Character vector gene symbols of interest.</p>
</td></tr>
<tr><td><code id="findGOTermEnrichment_+3A_universe">universe</code></td>
<td>
<p>Character vector of gene symbols which should be used as the background in the hypergeomtric test. If using this in the context of a ddcor experiment, this gene list most likely should be the gene set post-filtering, but prior to differential correlation analysis.</p>
</td></tr>
<tr><td><code id="findGOTermEnrichment_+3A_pval_go_cutoff">pval_GO_cutoff</code></td>
<td>
<p>Cutoff for the p-values of gene ontology terms in the enrichment tests that should be displayed in the resulting table.</p>
</td></tr>
<tr><td><code id="findGOTermEnrichment_+3A_hgnc_switch">HGNC_switch</code></td>
<td>
<p>Logical indicating whether or not the input gene symbols need to be switched from HGNC to Ensembl, the latter of which is required for GOstats enrichment test. Note that this is done by selecting the first Enembl symbol that maps to a particular HGNC symbol, which is not always unique. If you need more precision, you should do this outside of the function and insert the Ensembl list to the function. Only applies if cleanNames is TRUE.</p>
</td></tr>
<tr><td><code id="findGOTermEnrichment_+3A_hgnc_clean">HGNC_clean</code></td>
<td>
<p>Logical indicating whether the input gene symbols should be switched to clean HGNC symbols using the checkGeneSymbols function from the R package HGNChelper. Only applies if HGNC symbols are inputted and cleanNames is TRUE.</p>
</td></tr>
<tr><td><code id="findGOTermEnrichment_+3A_gene_ontology">gene_ontology</code></td>
<td>
<p>A string specifying the branch of GO that should be used for enrichment analysis. One of &quot;BP&quot; (Biological Process), &quot;MF&quot; (Molecular Function), &quot;CC&quot; (Cellular Component), or &quot;all&quot;. If &quot;all&quot; is chosen, then this function finds the enrichment for all of the terms and combines them into one table. Default = &quot;all&quot;</p>
</td></tr>
<tr><td><code id="findGOTermEnrichment_+3A_conditional">conditional</code></td>
<td>
<p>Logical specifying whether the GO analysis should be done conditionally to take into account the hierarchical structure of the GO database in making sense of the gene set enrichments. Default = TRUE.</p>
</td></tr>
<tr><td><code id="findGOTermEnrichment_+3A_annotation">annotation</code></td>
<td>
<p>The library indicating the GO annotation database from which the Go terms should be mapped to gene symbols. Default = &quot;org.Hs.eg.db&quot;, which is the table for Homo sapiens. Other common choices include &quot;org.Mm.eg.db&quot;, &quot;org.Rn.eg.db&quot;. The corresponding annotation library needs to be installed.</p>
</td></tr>
<tr><td><code id="findGOTermEnrichment_+3A_cleannames">cleanNames</code></td>
<td>
<p>Logical, indicating whether the gene names for the universe and gene vector should be cleaned prior to enrichment analysis.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with the term enrichments of the GO enrichment analysis given the input gene set and universe.
</p>

<hr>
<h2 id='getCors'>Compute matrices necessary for differential correlation calculation.</h2><span id='topic+getCors'></span>

<h3>Description</h3>

<p>As a first step in the standard DGCA workflow, this function reads in a design matrix and an input matrix, splits the input matrix by the named groups defined in the design matrix, and outputs a list of matrices (correlation matrix, correlation significance matrix, and number of samples matrix) to be used by downstream parts of the analysis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getCors(inputMat, design, inputMatB = NULL, impute = FALSE,
  corrType = "pearson")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getCors_+3A_inputmat">inputMat</code></td>
<td>
<p>The matrix (or data.frame) of values (e.g., gene expression values from an RNA-seq or microarray study) that you are interested in analyzing. The rownames of this matrix should correspond to the identifiers whose correlations and differential correlations you are interested in analyzing, while the columns should correspond to the rows of the design matrix and should be separable into your groups.</p>
</td></tr>
<tr><td><code id="getCors_+3A_design">design</code></td>
<td>
<p>A standard model.matrix created design matrix. Rows correspond to samples and colnames refer to the names of the conditions that you are interested in analyzing. Only 0's or 1's are allowed in the design matrix. Please see vignettes for more information.</p>
</td></tr>
<tr><td><code id="getCors_+3A_inputmatb">inputMatB</code></td>
<td>
<p>Optional, secondary input matrix that allows you to calculate correlation and differential correlation for the rows between inputMat and imputMatB.</p>
</td></tr>
<tr><td><code id="getCors_+3A_impute">impute</code></td>
<td>
<p>A binary variable specifying whether values should be imputed if there are missing values. Note that the imputation is performed in the full input matrix (i.e., prior to subsetting) and uses k-nearest neighbors.</p>
</td></tr>
<tr><td><code id="getCors_+3A_corrtype">corrType</code></td>
<td>
<p>The correlation type of the analysis, limited to &quot;pearson&quot; or &quot;spearman&quot;. Default = &quot;pearson&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A corMats S4 class object, containing a list of matrices from each group, the design matrix, and a character vector of options.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(darmanis); data(design_mat); darmanis_subset = darmanis[1:30, ]
cors_res = getCors(inputMat = darmanis_subset, design = design_mat)
</code></pre>

<hr>
<h2 id='getDCorPerm'>Get permuted groupwise correlations and pairwise differential correlations.</h2><span id='topic+getDCorPerm'></span>

<h3>Description</h3>

<p>Takes input and methods and randomly permutes the data to do getCor as well as group-specific pairwiseDCor.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getDCorPerm(inputMat, design, compare, inputMatB = NULL, impute = FALSE,
  nPerms = 10, corrType = "pearson", corr_cutoff = 0.99,
  signType = "none")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getDCorPerm_+3A_inputmat">inputMat</code></td>
<td>
<p>The matrix (or data.frame) of values (e.g., gene expression values from an RNA-seq or microarray study) that you are interested in analyzing. The rownames of this matrix should correspond to the identifiers whose correlations and differential correlations you are interested in analyzing, while the columns should correspond to the rows of the design matrix and should be separable into your groups.</p>
</td></tr>
<tr><td><code id="getDCorPerm_+3A_design">design</code></td>
<td>
<p>A standard model.matrix created design matrix. Rows correspond to samples and colnames refer to the names of the conditions that you are interested in analyzing. Only 0's or 1's are allowed in the design matrix. Please see vignettes for more information.</p>
</td></tr>
<tr><td><code id="getDCorPerm_+3A_compare">compare</code></td>
<td>
<p>Vector of two character strings, each corresponding to one name in the list of correlation matrices that should be compared.</p>
</td></tr>
<tr><td><code id="getDCorPerm_+3A_inputmatb">inputMatB</code></td>
<td>
<p>Optional, secondary input matrix that allows you to calculate correlation and differential correlation for the rows between inputMat and imputMatB.</p>
</td></tr>
<tr><td><code id="getDCorPerm_+3A_impute">impute</code></td>
<td>
<p>A binary variable specifying whether values should be imputed if there are missing values. Note that the imputation is performed in the full input matrix (i.e., prior to subsetting) and uses k-nearest neighbors.</p>
</td></tr>
<tr><td><code id="getDCorPerm_+3A_nperms">nPerms</code></td>
<td>
<p>Number of permutations to generate.</p>
</td></tr>
<tr><td><code id="getDCorPerm_+3A_corrtype">corrType</code></td>
<td>
<p>The correlation type of the analysis, limited to &quot;pearson&quot; or &quot;spearman&quot;.</p>
</td></tr>
<tr><td><code id="getDCorPerm_+3A_corr_cutoff">corr_cutoff</code></td>
<td>
<p>Cutoff specifying correlation values beyond which will be truncated to this value, to reduce the effect of outlier correlation values when using small sample sizes. Default = 0.99</p>
</td></tr>
<tr><td><code id="getDCorPerm_+3A_signtype">signType</code></td>
<td>
<p>Coerce all correlation coefficients to be either positive (via &quot;positive&quot;), negative (via &quot;negative&quot;), or none (via &quot;none&quot;). This could be used if you think that going from a positive to a negative correlation is unlikely to occur biologically and is more likely to be due to noise, and you want to ignore these effects. Note that this does NOT affect the reported underlying correlation values, but does affect the z-score difference of correlation calculation. Default = &quot;none&quot;, for no coercing.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An array of permuted differences in z-scores calculated between conditions, with the third dimension corresponding to the number of permutations performed.
</p>

<hr>
<h2 id='getDCors'>Get groupwise correlations and pairwise differential correlations.</h2><span id='topic+getDCors'></span>

<h3>Description</h3>

<p>Takes input and methods to perform getCor as well as group-specific pairwiseDCor.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getDCors(inputMat, design, compare, inputMatB = NULL, impute = FALSE,
  corrType = "pearson", corr_cutoff = 0.99, signType = "none")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getDCors_+3A_inputmat">inputMat</code></td>
<td>
<p>The matrix (or data.frame) of values (e.g., gene expression values from an RNA-seq or microarray study) that you are interested in analyzing. The rownames of this matrix should correspond to the identifiers whose correlations and differential correlations you are interested in analyzing, while the columns should correspond to the rows of the design matrix and should be separable into your groups.</p>
</td></tr>
<tr><td><code id="getDCors_+3A_design">design</code></td>
<td>
<p>A standard model.matrix created design matrix. Rows correspond to samples and colnames refer to the names of the conditions that you are interested in analyzing. Only 0's or 1's are allowed in the design matrix. Please see ?model.matrix for more information.</p>
</td></tr>
<tr><td><code id="getDCors_+3A_compare">compare</code></td>
<td>
<p>Vector of two character strings, each corresponding to one name in the list of correlation matrices that should be compared.</p>
</td></tr>
<tr><td><code id="getDCors_+3A_inputmatb">inputMatB</code></td>
<td>
<p>Optional, secondary input matrix that allows you to calculate correlation and differential correlation for the rows between inputMat and imputMatB.</p>
</td></tr>
<tr><td><code id="getDCors_+3A_impute">impute</code></td>
<td>
<p>A binary variable specifying whether values should be imputed if there are missing values. Note that the imputation is performed in the full input matrix (i.e., prior to subsetting) and uses k-nearest neighbors.</p>
</td></tr>
<tr><td><code id="getDCors_+3A_corrtype">corrType</code></td>
<td>
<p>The correlation type of the analysis, limited to &quot;pearson&quot; or &quot;spearman&quot;.</p>
</td></tr>
<tr><td><code id="getDCors_+3A_corr_cutoff">corr_cutoff</code></td>
<td>
<p>Cutoff specifying correlation values beyond which will be truncated to this value, to reduce the effect of outlier correlation values when using small sample sizes.</p>
</td></tr>
<tr><td><code id="getDCors_+3A_signtype">signType</code></td>
<td>
<p>Coerce all correlation coefficients to be either positive (via &quot;positive&quot;), negative (via &quot;negative&quot;), or none (via &quot;none&quot;). This could be used if you think that going from a positive to a negative correlation is unlikely to occur biologically and is more likely to be due to noise, and you want to ignore these effects. Note that this does NOT affect the reported underlying correlation values, but does affect the z-score difference of correlation calculation. Default = &quot;none&quot;, for no coercing.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dcPair class object, containing the difference in z-scores for each comparison, the p-values of that differences, and the original correlation matrices and significances for subsequent classification steps.
data(darmanis); data(design_mat); darmanis_subset = darmanis[1:30, ]
dcors_res = getDCors(inputMat = darmanis_subset, design = design_mat, compare = c(&quot;oligodendrocyte&quot;, &quot;neuron&quot;))
</p>

<hr>
<h2 id='getGroupsFromDesign'>Split input matrix(es) based on the design matrix.</h2><span id='topic+getGroupsFromDesign'></span>

<h3>Description</h3>

<p>This function splits the input matrix(es) based on a design matrix, into a named list of subsetted matrices. If the design matrix has no names, this function will create names for the resulting list of matrices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getGroupsFromDesign(inputMat, design, inputMatB = NULL, secondMat = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getGroupsFromDesign_+3A_inputmat">inputMat</code></td>
<td>
<p>Input (e.g., expression) matrix which will be subsetted.</p>
</td></tr>
<tr><td><code id="getGroupsFromDesign_+3A_design">design</code></td>
<td>
<p>Standard design matrix, must specify at least two conditions. For more info, see ?model.matrix</p>
</td></tr>
<tr><td><code id="getGroupsFromDesign_+3A_inputmatb">inputMatB</code></td>
<td>
<p>Optional input (e.g., expression) matrix which will be subsetted in the same way.</p>
</td></tr>
<tr><td><code id="getGroupsFromDesign_+3A_secondmat">secondMat</code></td>
<td>
<p>Logical value indicating whether there is a second input matrix to be subsetted.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list whose first element is a list of subsetted matrices and whose second element is a list of group names.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(darmanis); data(design_mat); darmanis_subset = darmanis[1:30, ]
groups_from_design = getGroupsFromDesign(inputMat = darmanis_subset, design = design_mat)
str(groups_from_design)
</code></pre>

<hr>
<h2 id='makeDesign'>Create a design matrix from a character vector.</h2><span id='topic+makeDesign'></span>

<h3>Description</h3>

<p>This function wraps around model.matrix to create a design matrix based on the different levels in model.matrix. Note that the order of the column names of the design matrix will be in lexicographic order according to the locale in use. For more, see ?Comparison
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeDesign(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makeDesign_+3A_x">x</code></td>
<td>
<p>Character vector to be used to create the design matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A design matrix as the same type as returned using ?model.matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n_oligo_samples = 38; n_neuron_samples = 120
cell_type = c(rep("oligodendrocyte", n_oligo_samples), rep("neuron", n_neuron_samples))
design_mat = makeDesign(cell_type)
</code></pre>

<hr>
<h2 id='matCorr'>Calculate a correlation matrix.</h2><span id='topic+matCorr'></span>

<h3>Description</h3>

<p>This function takes one or two input matrices and calculates a correlation matrix from it using the speed-optimized correlation function from WGCNA.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>matCorr(matA, corrType, use = "pairwise.complete.obs", matB = NULL,
  secondMat = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="matCorr_+3A_mata">matA</code></td>
<td>
<p>Input data matrix with numeric entries.</p>
</td></tr>
<tr><td><code id="matCorr_+3A_corrtype">corrType</code></td>
<td>
<p>The type of correlation to be performed. Either &quot;pearson&quot; or &quot;spearman&quot;.</p>
</td></tr>
<tr><td><code id="matCorr_+3A_use">use</code></td>
<td>
<p>The &quot;use&quot; method for performing the correlation calculation. See ?cor for more information. Default = &quot;pairwise.complete.obs&quot; (which is one of the speed-optimized versions; see ?WGCNA::cor for more).</p>
</td></tr>
<tr><td><code id="matCorr_+3A_matb">matB</code></td>
<td>
<p>Optional input data matrix with which the comparison with matA will be made.</p>
</td></tr>
<tr><td><code id="matCorr_+3A_secondmat">secondMat</code></td>
<td>
<p>Logical indicator of whether there is a second matrix in the comparison or not.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A correlation matrix.
data(darmanis); darmanis_subset = darmanis[1:30, ]
matcor_res = matCorr(matA = darmanis_subset, corrType = &quot;pearson&quot;)
</p>

<hr>
<h2 id='matCorSig'>Calculate correlation matrix p-values.</h2><span id='topic+matCorSig'></span>

<h3>Description</h3>

<p>Calculate two-sided p-values from a pairwise correlations matrix and a corresponding &quot;number of samples&quot; matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>matCorSig(corrs, nsamp, secondMat = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="matCorSig_+3A_corrs">corrs</code></td>
<td>
<p>Computed correlation matrix.</p>
</td></tr>
<tr><td><code id="matCorSig_+3A_nsamp">nsamp</code></td>
<td>
<p>Computed number of samples used per call in the correlation matrix.</p>
</td></tr>
<tr><td><code id="matCorSig_+3A_secondmat">secondMat</code></td>
<td>
<p>Logical indicator of whether there is a second matrix in the comparison or not.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of p-values.
</p>


<h3>References</h3>

<p>HMisc R package https://cran.r-project.org/web/packages/Hmisc/index.html
</p>

<hr>
<h2 id='matNSamp'>Find the number of non-missing values.</h2><span id='topic+matNSamp'></span>

<h3>Description</h3>

<p>This function calculates the pairwise number of non-missing values in a matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>matNSamp(matA, impute = FALSE, matB = NULL, secondMat = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="matNSamp_+3A_mata">matA</code></td>
<td>
<p>Input data matrix with numeric entries.</p>
</td></tr>
<tr><td><code id="matNSamp_+3A_impute">impute</code></td>
<td>
<p>Binary value; if true, indicates that imputation was performed previously, and so checking for NAs is not necessary.</p>
</td></tr>
<tr><td><code id="matNSamp_+3A_matb">matB</code></td>
<td>
<p>Optional input data matrix with which the comparison with matA will be made.</p>
</td></tr>
<tr><td><code id="matNSamp_+3A_secondmat">secondMat</code></td>
<td>
<p>Logical indicator of whether there is a second matrix in the comparison or not.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A number of samples (nsamp) matrix.
data(darmanis); darmanis_subset = as.matrix(darmanis[1:30, ])
nsamp_res = matNSamp(darmanis_subset)
darmanis_subset[1, 1] = NA
nsamp_res_na = matNSamp(darmanis_subset)
</p>

<hr>
<h2 id='moduleDC'>Calculate modular differential connectivity (MDC)</h2><span id='topic+moduleDC'></span>

<h3>Description</h3>

<p>Takes modules of genes (possibly overlapping) and calculates the change in correlation among those genes between two conditions. Also reports the genes with the strongest gain in connectivity (i.e., average difference in z-score of &gt; 0) and the strongest loss of correlation between conditions for each module, if any pass the significance measure specified.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>moduleDC(inputMat, design, compare, genes, labels, corr_cutoff = 0.99,
  signType = "none", corrType = "pearson", nPerms = 50,
  oneSidedPVal = FALSE, gene_avg_signif = 0.05, number_DC_genes = 3,
  dCorAvgMethod = "median")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="moduleDC_+3A_inputmat">inputMat</code></td>
<td>
<p>The matrix (or data.frame) of values (e.g., gene expression values from an RNA-seq or microarray study) that you are interested in analyzing. The rownames of this matrix should correspond to the identifiers whose correlations and differential correlations you are interested in analyzing, while the columns should correspond to the rows of the design matrix and should be separable into your groups.</p>
</td></tr>
<tr><td><code id="moduleDC_+3A_design">design</code></td>
<td>
<p>A standard model.matrix created design matrix. Rows correspond to samples and colnames refer to the names of the conditions that you are interested in analyzing. Only 0's or 1's are allowed in the design matrix. Please see vignettes for more information.</p>
</td></tr>
<tr><td><code id="moduleDC_+3A_compare">compare</code></td>
<td>
<p>Vector of two character strings, each corresponding to one group name in the design matrix, that should be compared.</p>
</td></tr>
<tr><td><code id="moduleDC_+3A_genes">genes</code></td>
<td>
<p>A character vector specifying gene symbols, present as rows in the inputMat, corresponding to each module label in the labels argument.</p>
</td></tr>
<tr><td><code id="moduleDC_+3A_labels">labels</code></td>
<td>
<p>A character vector specifying module label names, one for each gene symbol in the genes argument, with overlap allowed (i.e., each gene can be in more than one module).</p>
</td></tr>
<tr><td><code id="moduleDC_+3A_corr_cutoff">corr_cutoff</code></td>
<td>
<p>Cutoff specifying correlation values beyond which will be truncated to this value, to reduce the effect of outlier correlation values when using small sample sizes. Note that this does NOT affect the underlying correlation values, but does affect the z-score difference of correlation calculation in the dcTopPairs table. Default = 0.99</p>
</td></tr>
<tr><td><code id="moduleDC_+3A_signtype">signType</code></td>
<td>
<p>Coerce all correlation coefficients to be either positive (via &quot;positive&quot;), negative (via &quot;negative&quot;), or none (via &quot;none&quot;) prior to calculating differential correlation. This could be used if, e.g., you think that going from a positive to a negative correlation is unlikely to occur biologically and is more likely to be due to noise, and you want to ignore these effects. Note that this does NOT affect the reported underlying correlation values, but does affect the z-score difference of correlation calculation. Default = &quot;none&quot;, for no coercing.</p>
</td></tr>
<tr><td><code id="moduleDC_+3A_corrtype">corrType</code></td>
<td>
<p>The correlation type of the analysis, limited to &quot;pearson&quot; or &quot;spearman&quot;. Default = &quot;pearson&quot;.</p>
</td></tr>
<tr><td><code id="moduleDC_+3A_nperms">nPerms</code></td>
<td>
<p>Number of permutations to generate in order to calculate the significance of the result.</p>
</td></tr>
<tr><td><code id="moduleDC_+3A_onesidedpval">oneSidedPVal</code></td>
<td>
<p>If the dCorAvgType test is total_average, this option specifies whether a one-sided p-value should be reported, as opposed to a two-sided p-value. That is, if the average difference of z-scores is greater than zero, test whether the permutation average difference of z-scores are less than that average to get the p-value, and vice versa for the case that the average difference of z-scores is less than 0. Otherwise, test whether the absolute value of the average difference in z-scores is greater than the absolute values of the permutation average difference in z-scores. Default = FALSE.</p>
</td></tr>
<tr><td><code id="moduleDC_+3A_gene_avg_signif">gene_avg_signif</code></td>
<td>
<p>The gene average differential correlation significance (adjusted for MHTC) required in order for the a gene to be reported as having a gain or loss in connectivity.</p>
</td></tr>
<tr><td><code id="moduleDC_+3A_number_dc_genes">number_DC_genes</code></td>
<td>
<p>The number of top differentially correlated genes with more correlation in each condition in each module to return in the data frame.</p>
</td></tr>
<tr><td><code id="moduleDC_+3A_dcoravgmethod">dCorAvgMethod</code></td>
<td>
<p>Character vector specifying the method for calculating the &quot;average&quot; differential correlation calculation that should be used. Options = &quot;median&quot;, &quot;mean&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with the module labels, the average change in difference in z-score between conditions (i.e., one measure of the modular average differential connectivity, or MeDC), and the empirical p-value for the significance of the change in correlation.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(darmanis)
module_genes = list(mod1 = rownames(darmanis)[1:100],
 mod2 = rownames(darmanis)[90:190], mod3 = rownames(darmanis)[190:290])
modules = stack(module_genes)
modules$ind = as.character(modules$ind)
moduleDC_res = moduleDC(inputMat = darmanis, design = design_mat,
 compare = c("oligodendrocyte", "neuron"), genes = modules$values,
 labels = modules$ind)
</code></pre>

<hr>
<h2 id='moduleGO'>Perform module GO-trait correlation</h2><span id='topic+moduleGO'></span>

<h3>Description</h3>

<p>Takes input vectors of gene symbols, labels of corresponding modules, and a universe gene set and leverages the GOstats package to perform GO enrichment analysis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>moduleGO(genes, labels, universe, HGNC_clean = TRUE, HGNC_switch = TRUE,
  gene_ontology = "all", pval_GO_cutoff = 1, annotation = "org.Hs.eg.db",
  conditional = FALSE, calculateVariance = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="moduleGO_+3A_genes">genes</code></td>
<td>
<p>A character vector specifying gene symbols, present as rows in the inputMat, corresponding to each module label in the labels argument.</p>
</td></tr>
<tr><td><code id="moduleGO_+3A_labels">labels</code></td>
<td>
<p>A character vector specifying module label names, one for each gene symbol in the genes argument, with overlap allowed (i.e., each gene can be in more than one module).</p>
</td></tr>
<tr><td><code id="moduleGO_+3A_universe">universe</code></td>
<td>
<p>Character vector of gene symbols which should be used as the background in the hypergeomtric test. If using this in the context of a DGCA experiment, this gene list most likely should be the gene set post-filtering, but prior to differential correlation analysis.</p>
</td></tr>
<tr><td><code id="moduleGO_+3A_hgnc_clean">HGNC_clean</code></td>
<td>
<p>Logical indicating whether the input gene symbols should be switched to clean HGNC symbols using the checkGeneSymbols function from the R package HGNChelper. Only applies if HGNC symbols are inputted.</p>
</td></tr>
<tr><td><code id="moduleGO_+3A_hgnc_switch">HGNC_switch</code></td>
<td>
<p>Logical indicating whether or not the input gene symbols need to be switched from HGNC to Ensembl, the latter of which is required for GOstats enrichment test. Note that this is done by selecting the first Ensembl symbol that maps to a particular HGNC symbol, which is not always unique. If you need more precision on the conversion, you should do this outside of the function and insert the Ensembl list to the function.</p>
</td></tr>
<tr><td><code id="moduleGO_+3A_gene_ontology">gene_ontology</code></td>
<td>
<p>A string specifying the branch of GO that should be used for enrichment analysis. One of &quot;BP&quot; (Biological Process), &quot;MF&quot; (Molecular Function), &quot;CC&quot; (Cellular Component), or &quot;all&quot;. If &quot;all&quot; is chosen, then this function finds the enrichment for all of the terms and combines them into one table. Default = &quot;all&quot;</p>
</td></tr>
<tr><td><code id="moduleGO_+3A_pval_go_cutoff">pval_GO_cutoff</code></td>
<td>
<p>Cutoff for the unadjusted p-values of gene ontology terms in the enrichment tests that should be displayed in the resulting table.</p>
</td></tr>
<tr><td><code id="moduleGO_+3A_annotation">annotation</code></td>
<td>
<p>The library indicating the GO annotation database from which the Go terms should be mapped to gene symbols. Default = &quot;org.Hs.eg.db&quot;, which is the table for Homo sapiens. Other common choices include &quot;org.Mm.eg.db&quot;, &quot;org.Rn.eg.db&quot;. The corresponding annotation library needs to be installed.</p>
</td></tr>
<tr><td><code id="moduleGO_+3A_conditional">conditional</code></td>
<td>
<p>Logical specifying whether the GO analysis should be done conditionally to take into account the hierarchical structure of the GO database in making sense of the gene set enrichments.</p>
</td></tr>
<tr><td><code id="moduleGO_+3A_calculatevariance">calculateVariance</code></td>
<td>
<p>Optionally, find the variance of the odds ratio for each enrichment test. In particular, this finds the standard error of the log odds ratio, which converges to a normal distribution much more quickly than the non-log OR.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of lists of df's, one corresponding to each module, containing GO enrichment information for each module in each of the GO categories selected.
</p>

<hr>
<h2 id='pairwiseDCor'>Calculate pairwise differential correlations.</h2><span id='topic+pairwiseDCor'></span>

<h3>Description</h3>

<p>Find the differential correlation between two conditions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pairwiseDCor(corMatsObj, compare, corr_cutoff = 0.99, corrType = "pearson",
  secondMat = FALSE, signType = "none")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pairwiseDCor_+3A_cormatsobj">corMatsObj</code></td>
<td>
<p>A class object containing a named list of lists of matrices, one list per condition, with each list containing a correlation matrix, a correlation significance p-values matrix, and a &quot;number of samples used to calculate the correlation&quot; matrix.</p>
</td></tr>
<tr><td><code id="pairwiseDCor_+3A_compare">compare</code></td>
<td>
<p>Vector of two character strings, each corresponding to one name in the list of correlation matrices that should be compared.</p>
</td></tr>
<tr><td><code id="pairwiseDCor_+3A_corr_cutoff">corr_cutoff</code></td>
<td>
<p>Cutoff specifying correlation values beyond which will be truncated to this value, to reduce the effect of outlier correlation values when using small sample sizes.</p>
</td></tr>
<tr><td><code id="pairwiseDCor_+3A_corrtype">corrType</code></td>
<td>
<p>The correlation type of the analysis, limited to &quot;pearson&quot; or &quot;spearman&quot;.</p>
</td></tr>
<tr><td><code id="pairwiseDCor_+3A_secondmat">secondMat</code></td>
<td>
<p>Logical indicator of whether there is a second matrix in the comparison or not.</p>
</td></tr>
<tr><td><code id="pairwiseDCor_+3A_signtype">signType</code></td>
<td>
<p>Coerce all correlation coefficients to be either positive (via &quot;positive&quot;), negative (via &quot;negative&quot;), or none (via &quot;none&quot;). This could be used if you think that going from a positive to a negative correlation is unlikely to occur biologically and is more likely to be due to noise, and you want to ignore these effects. Note that this does NOT affect the reported underlying correlation values, but does affect the z-score difference of correlation calculation. Default = &quot;none&quot;, for no coercing.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dcPair class object, containing the difference in z scores for each comparison, the p-values of that differences, and the original correlation matrices and significances for subsequent classification steps.
</p>

<hr>
<h2 id='permQValue'>Calculate q-values from DGCA class objects based on permutation-based empirical null statistics.</h2><span id='topic+permQValue'></span>

<h3>Description</h3>

<p>First, estimate empirical p-values based on a comparison of the actual and permuted test statistics. Next, estimate the proportion of true null hypotheses using the qvalue package as well as qvalues from the empirical p-values, using this value. If the estimated pi0 &lt;= 0, then sequentially recalculates using increasingly conservative set of lambda values, until lambda = 0.5.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>permQValue(dcObject, permObject, secondMat, testSlot, verbose = FALSE,
  plotFdr = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="permQValue_+3A_dcobject">dcObject</code></td>
<td>
<p>The original S4 class object containing the test statistics to be extracted.</p>
</td></tr>
<tr><td><code id="permQValue_+3A_permobject">permObject</code></td>
<td>
<p>The array of matrices containing the null test statistics.</p>
</td></tr>
<tr><td><code id="permQValue_+3A_secondmat">secondMat</code></td>
<td>
<p>Logical, indicating whether a second matrix was used in the construction of this dcObject and permObject. If FALSE, the upper.tri of both are extracted to avoid double counting test statistics.</p>
</td></tr>
<tr><td><code id="permQValue_+3A_testslot">testSlot</code></td>
<td>
<p>The slot of the dcObject to be removed for use as the actual test statistic.</p>
</td></tr>
<tr><td><code id="permQValue_+3A_verbose">verbose</code></td>
<td>
<p>Whether summaries of the q-value operations should be reported.</p>
</td></tr>
<tr><td><code id="permQValue_+3A_plotfdr">plotFdr</code></td>
<td>
<p>Allows for plotting of fdrtool p-value adjustment result OR empirical FDR q-value adjustment technique, if either of these are chosen. Requires fdrtool package OR qvalue package. Default = FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing a vectof of empirical p-values and a vector of q-values, both of the same length as the original actual test statistics.
</p>

<hr>
<h2 id='plotCors'>Plot gene pair correlations in multiple conditions.</h2><span id='topic+plotCors'></span>

<h3>Description</h3>

<p>Takes the original input matrix, a design matrix, and two gene symbols to plot the corelation in the conditions specified.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotCors(inputMat, design, compare, corrType = "pearson", geneA, geneB,
  oneRow = FALSE, smooth = TRUE, log = FALSE, ylab = NULL,
  xlab = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotCors_+3A_inputmat">inputMat</code></td>
<td>
<p>The matrix (or data.frame) of values (e.g., gene expression values from an RNA-seq or microarray study) that you are interested in analyzing. The rownames of this matrix should correspond to the identifiers whose correlations and differential correlations you are interested in analyzing, while the columns should correspond to the rows of the design matrix and should be separable into your groups.</p>
</td></tr>
<tr><td><code id="plotCors_+3A_design">design</code></td>
<td>
<p>A standard model.matrix created design matrix. Rows correspond to samples and colnames refer to the names of the conditions that you are interested in analyzing. Only 0's or 1's are allowed in the design matrix. Please see vignettes for more information.</p>
</td></tr>
<tr><td><code id="plotCors_+3A_compare">compare</code></td>
<td>
<p>Vector of two character strings, each corresponding to one group name in the design matrix, that should be compared.</p>
</td></tr>
<tr><td><code id="plotCors_+3A_corrtype">corrType</code></td>
<td>
<p>The correlation type of the analysis, limited to &quot;pearson&quot; or &quot;spearman&quot;. Default = &quot;pearson&quot;.</p>
</td></tr>
<tr><td><code id="plotCors_+3A_genea">geneA</code></td>
<td>
<p>The first gene symbol.</p>
</td></tr>
<tr><td><code id="plotCors_+3A_geneb">geneB</code></td>
<td>
<p>The second gene symbol.</p>
</td></tr>
<tr><td><code id="plotCors_+3A_onerow">oneRow</code></td>
<td>
<p>Coerce all of the conditions to be plotted on the same row (as opposed to wrapping to multiple rows; relevant if there are &gt;3 conditions).</p>
</td></tr>
<tr><td><code id="plotCors_+3A_smooth">smooth</code></td>
<td>
<p>Whether to perform lm-based smoothing of the trend in each condition and add this to the plot.</p>
</td></tr>
<tr><td><code id="plotCors_+3A_log">log</code></td>
<td>
<p>Logical, indicating whether the data should be log2-transformed prior to plotting (after adding a small constant of 0.5 to avoid problems with the log transform).</p>
</td></tr>
<tr><td><code id="plotCors_+3A_ylab">ylab</code></td>
<td>
<p>Override the y-axis label to one of your choice.</p>
</td></tr>
<tr><td><code id="plotCors_+3A_xlab">xlab</code></td>
<td>
<p>Override the x-axis label to one of your choice.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot2 object that can be plotted, further modified, and/or saved.
</p>

<hr>
<h2 id='plotGOOneGroup'>Plot results from a hypergeometric enrichment test for one condition.</h2><span id='topic+plotGOOneGroup'></span>

<h3>Description</h3>

<p>Uses ggplot2 to create a horizontal bar plot of the p-values (or odds-ratios) from enrichment tests of GO terms derived from differentially correlated gene sets (or any gene sets inputted into upstream functions). Note that the first column of each data frame is removed to allow for row binding, and otherwise the column names should match.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotGOOneGroup(dfList, nTerms = 5, minSize = 50, maxSize = 500,
  dataCol = "Pvalue", namesCol = "Term", labelsCol = "Ontology",
  legendTitle = "GO Type", adjustPVals = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotGOOneGroup_+3A_dflist">dfList</code></td>
<td>
<p>A named list of data frames corresponding to different GO term enrichments.</p>
</td></tr>
<tr><td><code id="plotGOOneGroup_+3A_nterms">nTerms</code></td>
<td>
<p>The number of most-enriched terms to plot from each GO term type.</p>
</td></tr>
<tr><td><code id="plotGOOneGroup_+3A_minsize">minSize</code></td>
<td>
<p>The number of genes above which a gene set should be removed from analysis (e.g., because it is so small as to be overly specific and untrustworthy).</p>
</td></tr>
<tr><td><code id="plotGOOneGroup_+3A_maxsize">maxSize</code></td>
<td>
<p>The number of genes above which a gene set should be removed from analysis (e.g., because it is so big as to be overly generic and relatively uninteresting).</p>
</td></tr>
<tr><td><code id="plotGOOneGroup_+3A_datacol">dataCol</code></td>
<td>
<p>Column of the input matrix to be plotted in the bar plot. If &quot;Pvalue&quot;, it will be -log10 transformed prior to plotting. If not &quot;Pvalue&quot;, the x-axis label should be changed manually following the function call.</p>
</td></tr>
<tr><td><code id="plotGOOneGroup_+3A_namescol">namesCol</code></td>
<td>
<p>The column specifying the name of the GO terms to be plotted.</p>
</td></tr>
<tr><td><code id="plotGOOneGroup_+3A_labelscol">labelsCol</code></td>
<td>
<p>The column specifying the fill labels of the GO terms to be plotted.</p>
</td></tr>
<tr><td><code id="plotGOOneGroup_+3A_legendtitle">legendTitle</code></td>
<td>
<p>The title for the legend in the resulting plot.</p>
</td></tr>
<tr><td><code id="plotGOOneGroup_+3A_adjustpvals">adjustPVals</code></td>
<td>
<p>Logical, indicating whether or not p-values should be adjusted by the Benjamini-Hochberg method.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An ggplot2 object that can be called in order to plot it, saved, or modified.
</p>

<hr>
<h2 id='plotGOTwoGroups'>Plot results from a hypergeometric enrichment test to compare two conditions.</h2><span id='topic+plotGOTwoGroups'></span>

<h3>Description</h3>

<p>Uses plotrix to create a pyramid plot of the odds-ratios from enrichment tests of GO terms derived from differentially correlated gene sets (or any gene sets inputted into upstream functions) in two conditions. Note that the first column of each data frame is removed to allow for row binding, and otherwise the column names should match.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotGOTwoGroups(dfList1, dfList2, nTerms = 5, minSize = 40,
  maxSize = 1000, labelsCol = "Ontology", adjustPVals = TRUE,
  plotrix_gap = 20, GOTermTypes = c("BP", "CC", "MF"), pValCutoff = 0.05,
  filterSignificant = FALSE, filterSigThresh = 0.05,
  labels = c("Corr Class 1", "GO Term Name", "Corr Class 2"),
  fill_zero_cats = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotGOTwoGroups_+3A_dflist1">dfList1</code></td>
<td>
<p>A named list of data frames corresponding to different GO term enrichments from the first condition or differential correlation class.</p>
</td></tr>
<tr><td><code id="plotGOTwoGroups_+3A_dflist2">dfList2</code></td>
<td>
<p>A named list of data frames corresponding to different GO term enrichments from the second condition or differential correlation class.</p>
</td></tr>
<tr><td><code id="plotGOTwoGroups_+3A_nterms">nTerms</code></td>
<td>
<p>The number of most difference-in-enrichment (i.e., difference adjusted p-value for the difference in log OR) terms to plot from each GO term type.</p>
</td></tr>
<tr><td><code id="plotGOTwoGroups_+3A_minsize">minSize</code></td>
<td>
<p>The number of genes above which a gene set should be removed from analysis (e.g., because it is so small as to be overly specific and untrustworthy).</p>
</td></tr>
<tr><td><code id="plotGOTwoGroups_+3A_maxsize">maxSize</code></td>
<td>
<p>The number of genes above which a gene set should be removed from analysis (e.g., because it is so big as to be overly generic and relatively uninteresting).</p>
</td></tr>
<tr><td><code id="plotGOTwoGroups_+3A_labelscol">labelsCol</code></td>
<td>
<p>The column specifying the fill labels of the GO terms to be plotted.</p>
</td></tr>
<tr><td><code id="plotGOTwoGroups_+3A_adjustpvals">adjustPVals</code></td>
<td>
<p>Logical, indicating whether or not p-values for the difference in log odds between conditions should be adjusted by the Benjamini-Hochberg method.</p>
</td></tr>
<tr><td><code id="plotGOTwoGroups_+3A_plotrix_gap">plotrix_gap</code></td>
<td>
<p>Parameter specifying the size of the gap between the two sides of the ORs.</p>
</td></tr>
<tr><td><code id="plotGOTwoGroups_+3A_gotermtypes">GOTermTypes</code></td>
<td>
<p>Character vector for the GO term types to be plotted.</p>
</td></tr>
<tr><td><code id="plotGOTwoGroups_+3A_pvalcutoff">pValCutoff</code></td>
<td>
<p>p-Value cutoff to specify how significant each term enrichment must be in at least one of the groups to be considered for the comparison between the conditions. If no cutoff is desired, set to 1.</p>
</td></tr>
<tr><td><code id="plotGOTwoGroups_+3A_filtersignificant">filterSignificant</code></td>
<td>
<p>Logical, indicating whether or not the p-value for the difference in ORs between groups should be required to be less than a particular threshold prior to downstream analysis.</p>
</td></tr>
<tr><td><code id="plotGOTwoGroups_+3A_filtersigthresh">filterSigThresh</code></td>
<td>
<p>Number indicating the threshold of the p-value for the difference in ORs between groups required if filterSignificant is TRUE.</p>
</td></tr>
<tr><td><code id="plotGOTwoGroups_+3A_labels">labels</code></td>
<td>
<p>Character vector specifying labels for the pyramid plot; first entry = left label, second entry = middle label, third entry = right label.</p>
</td></tr>
<tr><td><code id="plotGOTwoGroups_+3A_fill_zero_cats">fill_zero_cats</code></td>
<td>
<p>Logical, indicating whether counts of zero in some groups should be included in the comparisons. Adds 0.1 to the ORs and in the denominator of the count for the calculation of the SE in the cases where there are zero counts identified, as a convservative measure to prevent finding infinite differences between groups.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with the values used to create the plot.
</p>

<hr>
<h2 id='plotModuleGO'>Plot extracted results from module-based GO enrichment analysis using ggplot2.</h2><span id='topic+plotModuleGO'></span>

<h3>Description</h3>

<p>Takes a data frame of enrichment results in multiple modules and plots the results. Note that if a GO term enrichment does not exist for that module, it is set as 0 for an OR or 1 for a p-value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotModuleGO(df, nTerms = 5, termVector = NULL, modules = NULL,
  heatmapColor = NULL, plotOR = FALSE, axis_text_col = "black",
  axis_x_text_angle = 45, text_size = 10, guide_title = NULL,
  coord_flip = FALSE, adjust = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotModuleGO_+3A_df">df</code></td>
<td>
<p>The data frame of term enrichments to be plotted.</p>
</td></tr>
<tr><td><code id="plotModuleGO_+3A_nterms">nTerms</code></td>
<td>
<p>The number of terms for each module whose GO terms with the minimum enrichment p-values for that group should be plotted.</p>
</td></tr>
<tr><td><code id="plotModuleGO_+3A_termvector">termVector</code></td>
<td>
<p>Optional character vector of GO term strings to plot, overriding other options.</p>
</td></tr>
<tr><td><code id="plotModuleGO_+3A_modules">modules</code></td>
<td>
<p>Optional, a list of module names to plot. Optional; if not inputted, all of the module names in the data frame will be used.</p>
</td></tr>
<tr><td><code id="plotModuleGO_+3A_heatmapcolor">heatmapColor</code></td>
<td>
<p>Optional specification of the heatmap colors. If not specified, ?heat.colors will be used.</p>
</td></tr>
<tr><td><code id="plotModuleGO_+3A_plotor">plotOR</code></td>
<td>
<p>Logical, indicating whether odds ratios should be plotted on the heatmap, instead of -log10 p-values (the default).</p>
</td></tr>
<tr><td><code id="plotModuleGO_+3A_axis_text_col">axis_text_col</code></td>
<td>
<p>Color of axis text.</p>
</td></tr>
<tr><td><code id="plotModuleGO_+3A_axis_x_text_angle">axis_x_text_angle</code></td>
<td>
<p>Angle of x-axis text.</p>
</td></tr>
<tr><td><code id="plotModuleGO_+3A_text_size">text_size</code></td>
<td>
<p>Text size of axes and legend in plot.</p>
</td></tr>
<tr><td><code id="plotModuleGO_+3A_guide_title">guide_title</code></td>
<td>
<p>Optionally, specify the title of legend.</p>
</td></tr>
<tr><td><code id="plotModuleGO_+3A_coord_flip">coord_flip</code></td>
<td>
<p>Whether the coordinates should be flipped.</p>
</td></tr>
<tr><td><code id="plotModuleGO_+3A_adjust">adjust</code></td>
<td>
<p>If p-values are plotted, whether or not the enrichment p-values from each module should be adjusted by the Benjamini-Hochberg method.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame summarizing the GO term enrichments from each group, with columns on the ordered by the minimum p-value for OR term enrichment in any group.
</p>

<hr>
<h2 id='plotVals'>Creates a dotplot of the overall values for an individual gene in multiple conditions.</h2><span id='topic+plotVals'></span>

<h3>Description</h3>

<p>Takes the original input matrix, a design matrix, and one gene symbols (row name of the original matrix) to plot its values in the conditions specified, using a dotplot, +/- a summary bar. Will remove NAs prior to plotting.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotVals(inputMat, design, compare, gene, log = FALSE, ylab = NULL,
  xlab = NULL, add_summary_bar = TRUE, summary_bar = "mean",
  summary_width = 0.75, dotplot_width = 0.5, dotplot_size = NULL,
  dotplot_binwidth = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotVals_+3A_inputmat">inputMat</code></td>
<td>
<p>The matrix (or data.frame) of values (e.g., gene expression values from an RNA-seq or microarray study) that you are interested in analyzing. The rownames of this matrix should correspond to the identifiers whose values you are interested in analyzing, while the columns should correspond to the rows of the design matrix and should be separable into your groups.</p>
</td></tr>
<tr><td><code id="plotVals_+3A_design">design</code></td>
<td>
<p>A standard model.matrix created design matrix. Rows correspond to samples and colnames refer to the names of the conditions that you are interested in analyzing. Only 0's or 1's are allowed in the design matrix. Please see vignettes for more information.</p>
</td></tr>
<tr><td><code id="plotVals_+3A_compare">compare</code></td>
<td>
<p>Vector of two character strings, each corresponding to one group name in the design matrix, that should be compared.</p>
</td></tr>
<tr><td><code id="plotVals_+3A_gene">gene</code></td>
<td>
<p>The gene symbol (row identifier).</p>
</td></tr>
<tr><td><code id="plotVals_+3A_log">log</code></td>
<td>
<p>Logical, indicating whether the data should be log2-transformed prior to plotting (after adding a small constant of 0.5 to avoid problems with the log transform and stabilize the variance with respect to the mean).</p>
</td></tr>
<tr><td><code id="plotVals_+3A_ylab">ylab</code></td>
<td>
<p>Override the y-axis label to one of your choice.</p>
</td></tr>
<tr><td><code id="plotVals_+3A_xlab">xlab</code></td>
<td>
<p>Override the x-axis label to one of your choice.</p>
</td></tr>
<tr><td><code id="plotVals_+3A_add_summary_bar">add_summary_bar</code></td>
<td>
<p>Logical indicating whether to include a summary bar for each group.</p>
</td></tr>
<tr><td><code id="plotVals_+3A_summary_bar">summary_bar</code></td>
<td>
<p>If summary bar included, type of bar to use to calculate. Options = &quot;mean&quot;, &quot;median&quot;</p>
</td></tr>
<tr><td><code id="plotVals_+3A_summary_width">summary_width</code></td>
<td>
<p>Horizontal width of summary crossbar included.</p>
</td></tr>
<tr><td><code id="plotVals_+3A_dotplot_width">dotplot_width</code></td>
<td>
<p>The width of the dots in the dotplot. See ?geom_dotplot for more information.</p>
</td></tr>
<tr><td><code id="plotVals_+3A_dotplot_size">dotplot_size</code></td>
<td>
<p>The diameter of the dots in the dotplot. Affects the chart relative to the dotplot binwidth. If NULL, will be calculated automatically.</p>
</td></tr>
<tr><td><code id="plotVals_+3A_dotplot_binwidth">dotplot_binwidth</code></td>
<td>
<p>The binwidth size for the dots in the dotplot. If NULL, will be calculated automatically.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot2 object that can be plotted, further modified, and/or saved.
</p>

<hr>
<h2 id='switchGenesToHGCN'>Switches a gene vector to cleaned HGNC symbols.</h2><span id='topic+switchGenesToHGCN'></span>

<h3>Description</h3>

<p>Where possible, switches a character vector of gene names to cleaned and updated HGNC symbols.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>switchGenesToHGCN(gene_list)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="switchGenesToHGCN_+3A_gene_list">gene_list</code></td>
<td>
<p>Character vector of gene names.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Character vector of cleaned gene names.
</p>

<hr>
<h2 id='topDCGenes'>Ranks genes by their total number of differentially correlated gene pairs.</h2><span id='topic+topDCGenes'></span>

<h3>Description</h3>

<p>Returns list of lists for the top differentially correlated gene pairs in each direction and/or class.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>topDCGenes(ddcor_res, adjusted = FALSE, pval_gene_thresh = 0.05,
  geneNameCol = c("Gene1", "Gene2"), nGenes = "all", classes = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="topDCGenes_+3A_ddcor_res">ddcor_res</code></td>
<td>
<p>The table of differential correlations outputted from ddcor. Expected to have pValDiff or pValDiff_adj columns as well as zScoreDiff, Gene1, +/- Classes columns.</p>
</td></tr>
<tr><td><code id="topDCGenes_+3A_adjusted">adjusted</code></td>
<td>
<p>Logical indicating whether adjusted p-values from the differential correlation table (i.e., column &quot;pValDiff_adj&quot;, when adjusted = TRUE) or unadjusted p-values (i.e., column &quot;pValDiff&quot;, when adjusted = FALSE) should be used to subset the table into significant and non-significant portions.</p>
</td></tr>
<tr><td><code id="topDCGenes_+3A_pval_gene_thresh">pval_gene_thresh</code></td>
<td>
<p>p-value threshold to call a gene as having significant differential correlation or not.</p>
</td></tr>
<tr><td><code id="topDCGenes_+3A_genenamecol">geneNameCol</code></td>
<td>
<p>Character vector specifying the name of the columns that are used to extract the gene symbols. Note that the default is c(&quot;Gene1&quot;, &quot;Gene2&quot;), but this only makes sense in the context of a full DGCA experiment. In the case of a splitSet, you may want to use &quot;Gene1&quot; to avoid counting the splitSet names in all of the categories.</p>
</td></tr>
<tr><td><code id="topDCGenes_+3A_ngenes">nGenes</code></td>
<td>
<p>Number of genes to display in the resulting table. Default = &quot;all&quot;, but also can be restricted to a particular number.</p>
</td></tr>
<tr><td><code id="topDCGenes_+3A_classes">classes</code></td>
<td>
<p>Gets the number of differentially correlated gene pairs associated with each of the differential correlation classes.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with corresponding lists of genes most associated with each of the directions and/or correlation classes.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(darmanis); data(design_mat); darmanis_subset = darmanis[1:30, ]
ddcor_res = ddcorAll(inputMat = darmanis_subset, design = design_mat,
 compare = c("oligodendrocyte", "neuron"))
top_genes = topDCGenes(ddcor_res)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
