<!DOCTYPE html><html><head><title>Help for package RUnit</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {RUnit}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#.setUp'><p>Definition of RUnit Test Case code files.</p></a></li>
<li><a href='#checkFuncs'><p>RUnit check functions</p></a></li>
<li><a href='#inspect'><p>Track the executed code lines of a function or method.</p></a></li>
<li><a href='#options'><p>RUnit options</p></a></li>
<li><a href='#printHTML'><p>Write HTML pages of the tracking result.</p></a></li>
<li><a href='#RUnit'><p>RUnit - Package Description</p></a></li>
<li><a href='#RUnit-internal'><p>Internal functions</p></a></li>
<li><a href='#runTestSuite'><p>Definition and execution of RUnit test suites.</p></a></li>
<li><a href='#textProtocol'><p>Printing a plain text, HTML or JUnit-like XML version of an RUnit test run protocol.</p></a></li>
<li><a href='#tracker'><p>Tracking the results of the inspect process.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>0.4.33</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-02-09</td>
</tr>
<tr>
<td>Title:</td>
<td>R Unit Test Framework</td>
</tr>
<tr>
<td>Author:</td>
<td>Matthias Burger &lt;burgerm@users.sourceforge.net&gt;, Klaus
        Juenemann &lt;k.junemann@gmx.net&gt;, Thomas Koenig
        &lt;thomas.koenig@epigenomics.com&gt;</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Roman Zenka &lt;zenka.roman@mayo.edu&gt;</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.5.0), utils (&ge; 2.5.0), methods (&ge; 2.5.0), graphics
(&ge; 2.5.0)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>XML (&ge; 3.1.0)</td>
</tr>
<tr>
<td>Description:</td>
<td>R functions implementing a standard Unit Testing
        framework, with additional code inspection and report
        generation tools.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-02-22 17:11:58 UTC; m044910</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-02-22 17:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='.setUp'>Definition of RUnit Test Case code files.</h2><span id='topic+.setUp'></span><span id='topic+.tearDown'></span>

<h3>Description</h3>

<p>Either one or both functions have to be provided by the test case author, take
precedence over the dummy definitions provided by the RUnit
package and are called once for every test case identified.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.setUp()
.tearDown()
</code></pre>


<h3>Details</h3>

<p>To be written ...
</p>


<h3>Value</h3>

<p>Functions do not return a value; called for their side effects.
</p>


<h3>Author(s)</h3>

<p>Thomas König, Klaus Jünemann
&amp; Matthias Burger</p>


<h3>See Also</h3>

<p><code><a href="#topic+runTestFile">runTestFile</a></code>.
</p>

<hr>
<h2 id='checkFuncs'>RUnit check functions</h2><span id='topic+checkEquals'></span><span id='topic+checkEqualsNumeric'></span><span id='topic+checkIdentical'></span><span id='topic+checkTrue'></span><span id='topic+checkException'></span><span id='topic+DEACTIVATED'></span>

<h3>Description</h3>

<p>A set of functions used to check the results of some test
calculation. If these functions are called within the RUnit framework,
the results of the checks are stored and reported in the test
protocol.
</p>
<p><code>checkEquals</code> compares two R objects by invoking <code>all.equal</code> on
the two objects. If the objects are not equal an error is
generated and the failure is reported to the test logger such that it
appears in the test protocol.
</p>
<p><code>checkEqualsNumeric</code> works just like <code>checkEquals</code> except
that it invokes <code>all.equal.numeric</code> instead of <code>all.equal</code>
</p>
<p><code>checkIdentical</code> is a convenience wrapper around identical using
the error logging mechanism of RUnit.
</p>
<p><code>checkTrue</code> uses the function <code>identical</code> to check if the expression
provided as first argument evaluates to <code>TRUE</code>. If not, an error is
generated and the failure is reported to the test logger such that it
appears in the test protocol.
</p>
<p><code>checkException</code> evaluates the passed expression and uses the
<code>try</code> mechanism to check if the evaluation generates an error.
If it does the test is OK. Otherwise an error is
generated and the failure is reported to the test logger such that it
appears in the test protocol. 
</p>
<p><code>DEACTIVATED</code> interrupts the test function and reports the test case
as deactivated. In the test protocol deactivated test functions are
listed separately. Test case deactivation can be useful in the case of
major refactoring. Alternatively, test cases can be commented out
completely but then it is easy to forget the test case altogether.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>checkEquals(target, current, msg,
            tolerance = .Machine$double.eps^0.5, 
            checkNames = TRUE, ...)
checkEqualsNumeric(target, current, msg,
                   tolerance = .Machine$double.eps^0.5, ...)
checkIdentical(target, current, msg)
checkTrue(expr, msg)
checkException(expr, msg, silent = getOption("RUnit")$silent)
DEACTIVATED(msg)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="checkFuncs_+3A_current">current</code>, <code id="checkFuncs_+3A_target">target</code></td>
<td>
<p>objects to be compared (<code>checkEqualsNumeric</code> cannot 
handle S4 class objects).</p>
</td></tr>
<tr><td><code id="checkFuncs_+3A_msg">msg</code></td>
<td>
<p>an optional message to document a check and to facilitate
the identification of a possible failure. The message only appears
as text in the test protocol, it is not further used in any of the check 
functions.</p>
</td></tr>
<tr><td><code id="checkFuncs_+3A_tolerance">tolerance</code></td>
<td>
<p>numeric &gt;= 0.  A numeric check does not fail if
differences are smaller than &lsquo;tolerance&rsquo;.</p>
</td></tr>
<tr><td><code id="checkFuncs_+3A_checknames">checkNames</code></td>
<td>
<p>flag, if <code>FALSE</code> the names attributes are set to 
<code>NULL</code>
for both current and target before performing the check.</p>
</td></tr>
<tr><td><code id="checkFuncs_+3A_expr">expr</code></td>
<td>
<p>syntactically valid R expression which can be evaluated
and must return a logical scalar (<code>TRUE</code>|<code>FALSE</code>). A named 
expression is also allowed but the name is disregarded.</p>
</td></tr>
<tr><td><code id="checkFuncs_+3A_silent">silent</code></td>
<td>
<p>flag passed on to <code>try</code>, which determines if the
error message generated by the checked function is displayed. Queried from 
global options set for RUnit at package load.</p>
</td></tr>
<tr><td><code id="checkFuncs_+3A_...">...</code></td>
<td>
<p>optional arguments passed to <code>all.equal</code> or 
<code>all.equal.numeric</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The check functions are direct equivalents of the various
methods of the class junit.framework.Assert of Javas JUnit framework
which served as basis for the RUnit package.
</p>
<p>For functions defined inside a package equipped with a namespace only
exported functions can be accessed inside test cases directly. For
functions not exported the only way to test them is to use the 
'<code><a href="base.html#topic+ns-dblcolon">:::</a></code>'
operator combined with the package name as a prefix.
</p>
<p>Special care is required if test cases are written for S4 classes and
methods. If a new class is defined inside a test case via a
<code><a href="methods.html#topic+setClass">setClass</a></code> call the class is added to the global class
cache and thus available outside the test case. It will persist until
explicitly removed via a <code><a href="methods.html#topic+findClass">removeClass</a></code>
call. Same applies for new method
and generic definitions. Be sure to remove methods and classes in
each test case they are defined after the checks have been
performed. This is an advise gained from the cumbersome experience:
not doing so leads to difficult to pin down error causes incurred
from previously executed test cases.
For a simple example see the provided test cases in
/runitVirtualClassTest.r.
</p>


<h3>Author(s)</h3>

<p>Thomas König, Klaus Jünemann
&amp; Matthias Burger</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+all.equal">all.equal</a></code>, <code><a href="base.html#topic+all.equal.numeric">all.equal.numeric</a></code> and
<code><a href="base.html#topic+identical">identical</a></code> are the underlying comparison functions.
<code><a href="base.html#topic+try">try</a></code> is used for error catching.
<code><a href="#topic+.setUp">.setUp</a></code> for details on test case setup. See
<a href="#topic+RUnit-options">RUnit-options</a> for global options controlling log out.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
checkTrue(1 &lt; 2, "check1")     ## passes fine
## checkTrue(1 &gt; 2, "check2")  ## appears as failure in the test protocol

v &lt;- 1:3
w &lt;- 1:3
checkEquals(v, w)               ## passes fine
names(v) &lt;- c("A", "B", "C")
## checkEquals(v, w)            ## fails because v and w have different names
checkEqualsNumeric(v, w)        ## passes fine because names are ignored


x &lt;- rep(1:12, 2)
y &lt;- rep(0:1, 12)
res &lt;- list(a=1:3, b=letters, LM=lm(y ~ x))
res2 &lt;- list(a=seq(1,3,by=1), b=letters, LM=lm(y ~ x))
checkEquals( res, res2)        ## passes fine
checkIdentical( res, res)
checkIdentical( res2, res2)
## checkIdentical( res, res2)  ## fails because element 'a' differs in type


fun &lt;- function(x) {
  if(x)
  {
   stop("stop conditions signaled")
  }
  return()
}

checkException(fun(TRUE))      ## passes fine
## checkException(fun(FALSE))  ## failure, because fun raises no error
checkException(fun(TRUE), silent=TRUE)

##  special constants
##  same behaviour as for underlying base functions
checkEquals(NA, NA)
checkEquals(NaN, NaN)
checkEquals(Inf, Inf)

checkIdentical(NA, NA)
checkIdentical(NaN, NaN)
checkIdentical(-Inf, -Inf)

## DEACTIVATED("here one can document on the reason for deactivation")
</code></pre>

<hr>
<h2 id='inspect'>Track the executed code lines of a function or method.</h2><span id='topic+inspect'></span>

<h3>Description</h3>

<p><code>inspect</code> examines and modifies the source code of a function or
method.  After the modification of the source code, the modified function
will be executed and the result of the tracking process will be
stored. To store the information a <code>tracker</code> environment with the
name track must exist.
Note, that not all R code constructs can be handled at the current
state. In some cases it is not possible to track a specific code line.
Therefore, clearly structured code with consequent use of
opening and closing braces to indicate conditional expressions can
prevent these parser problems.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  inspect(expr, track = track)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="inspect_+3A_expr">expr</code></td>
<td>
<p>Any R function or method call.</p>
</td></tr>
<tr><td><code id="inspect_+3A_track">track</code></td>
<td>
<p>list object, as returned by a call to <code>tracker</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The return value of <code>inspect</code> is the result returned by
the function executed. If the function has no return value nothing is
returned either.</p>


<h3>Author(s)</h3>

<p>Thomas König, Klaus Jünemann
&amp; Matthias Burger</p>


<h3>See Also</h3>

<p><code><a href="#topic+tracker">tracker</a></code> for the call tracking object, and 
<code><a href="#topic+printHTML">printHTML</a></code> for displaying results.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## example function
foo &lt;- function(x){
   y &lt;- 0
   for(i in 1:100)
   {
      y &lt;- y + i
   }
   return(y)
}

## the name track is necessary
track &lt;- tracker()

## initialize the tracker
track$init()

## inspect the function
## res will collect the result of calling foo
res &lt;- inspect(foo(10), track = track)

## get the tracked function call info
resTrack &lt;- track$getTrackInfo()

## create HTML sites
printHTML(resTrack, baseDir=tempdir())
</code></pre>

<hr>
<h2 id='options'>RUnit options</h2><span id='topic+RUnit+20options'></span><span id='topic+RUnit-options'></span>

<h3>Description</h3>

<p>RUnit uses three options available via the global R options list
</p>


<h3>Details</h3>

<p>RUnit specif options are added to R's global options list on package
loading and removed again on pachage unloading.
</p>


<h3>Options used in RUnit</h3>


<dl>
<dt><code>silent</code>:</dt><dd><p>logical flag, default <code>FALSE</code>, sets the 'silent' argument for
<code>checkException</code>. Allows to globally silence output from
exception checks for all test suites excuted in one run.</p>
</dd>
<dt><code>verbose</code>:</dt><dd><p>non-negative integer, default <code>1</code>, <code>0</code>: surpresses enclosing
begin/end messages for each test case, <code>1</code>: output enclosing
begin/end messages for each test case</p>
</dd>
<dt><code>outfile</code>:</dt><dd><p><code>NULL</code>, connection or character, default
<code>NULL</code>. If non-null has to be an open connection or a file name.
Will be used to redirect all output to specified file/connection
using <code>sink</code>. Connection is close after test suite execution
call (via <code>runTestSuite</code> or <code>runTestFile</code>) has completed.
If the file exists it is overwriten.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Matthias Burger</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+options">options</a></code>, <code><a href="base.html#topic+getOption">getOption</a></code>, <code><a href="base.html#topic+sink">sink</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
##  quiet log output
ro &lt;- getOption("RUnit")
ro$silent &lt;- TRUE
ro$verbose &lt;- 0L
options("RUnit"=ro)

## End(Not run)
</code></pre>

<hr>
<h2 id='printHTML'>Write HTML pages of the tracking result.</h2><span id='topic+printHTML'></span>

<h3>Description</h3>

<p><code>printHTML</code> creates a subdirectory named
&quot;result&quot;  in the base directory specified via <code>baseDir</code>. All HTML pages 
and images will be put
in that directory.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  printHTML(object, baseDir = ".")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="printHTML_+3A_object">object</code></td>
<td>
<p>'trackInfo' S3 class object (list), containing the result of the
function <code>tracker</code>.</p>
</td></tr>
<tr><td><code id="printHTML_+3A_basedir">baseDir</code></td>
<td>
<p>A character string, specifying the base directory for
the HTML pages to be written to. Defaults to the current working directory.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>An &quot;index.html&quot; page will be created in the directory
&quot;results&quot; which is the root entry page of the HTML pages. The
displayed result for every tracked function consists of two HTML pages.
The first page is an overview on how
often every line of code was executed. Code lines not executed are
highlighted red, executed lines are shown in green. The second page is
a graph representation of the
execution flow of the function. Each code line has a edge pointing to
the next code line that is executed subsequently. Thus loops and jumps
become clearly visible.
</p>


<h3>Author(s)</h3>

<p>Thomas König, Klaus Jünemann
&amp; Matthias Burger</p>


<h3>See Also</h3>

<p><code><a href="#topic+tracker">tracker</a></code> for the call tracking object definition.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
##  example function
foo &lt;- function(x){
   y &lt;- 0
   for(i in 1:100)
   {
      y &lt;- y + i
   }
   return(y)
}

##  the name track is necessary
track &lt;- tracker()

##  initialize the tracker
track$init()

##  inspect the function
##  res is the result of foo
res &lt;- inspect(foo(10), track = track)

##  get the tracking info
resTrack &lt;- track$getTrackInfo()

##  create HTML pages
printHTML(resTrack, baseDir=tempdir())
</code></pre>

<hr>
<h2 id='RUnit'>RUnit - Package Description</h2><span id='topic+RUnit'></span>

<h3>Description</h3>

<p>This package models the common Unit Test framework for R
and provides functionality to track results of test case execution and
generate a summary report. It also provides tools for code inspection
and thus for test case coverage analysis.
The design is inspired by the popular JUnit unit test framework.
</p>
<p>This package comes with a set of unit tests, serving as a test battery to check 
correct functioning against new R versions released as well as practical 
examples for writing test cases (see the &lsquo;<span class="file">inst/unitTests</span>&rsquo; subdirectory of 
the source package, or &lsquo;<span class="file">unitTests</span>&rsquo; contained in the 
binary package version).
</p>


<h3>Author(s)</h3>

<p>Thomas König, Klaus Jünemann
&amp; Matthias Burger</p>


<h3>References</h3>

<p>RUnit - A Unit Test Framework for R. useR! 2004 Vienna</p>


<h3>See Also</h3>

<p>See  <code><a href="#topic+defineTestSuite">defineTestSuite</a></code>, <code><a href="#topic+runTestSuite">runTestSuite</a></code>
for unit testing or <code><a href="#topic+inspect">inspect</a></code> and
<code><a href="#topic+tracker">tracker</a></code> for code inspection.
</p>

<hr>
<h2 id='RUnit-internal'>Internal functions</h2><span id='topic+includeTracker'></span><span id='topic+plotConnection.trackInfo'></span><span id='topic+writeBeginBody'></span><span id='topic+writeBeginHead'></span><span id='topic+writeBeginHtml'></span><span id='topic+writeBeginTag'></span><span id='topic+writeBeginTable'></span><span id='topic+writeCR'></span><span id='topic+writeEndBody'></span><span id='topic+writeEndHead'></span><span id='topic+writeEndHtml'></span><span id='topic+writeEndTable'></span><span id='topic+writeEndTag'></span><span id='topic+writeHtmlEnd'></span><span id='topic+writeHtmlHeader'></span><span id='topic+writeHtmlSection'></span><span id='topic+writeHtmlSep'></span><span id='topic+writeImage'></span><span id='topic+writeLi'></span><span id='topic+writeLinkRef'></span><span id='topic+writeLink'></span><span id='topic+writeP'></span><span id='topic+writeRaw'></span><span id='topic+writeRawCR'></span><span id='topic+writeTableRow'></span><span id='topic+writeTitle'></span>

<h3>Description</h3>

<p>Helper functions and private methods not intended for direct use.
</p>

<hr>
<h2 id='runTestSuite'>Definition and execution of RUnit test suites.</h2><span id='topic+runTestSuite'></span><span id='topic+runTestFile'></span><span id='topic+defineTestSuite'></span><span id='topic+isValidTestSuite'></span>

<h3>Description</h3>

<p><code>runTestSuite</code> is the central function of the RUnit package.
Given one or more test suites it identifies and sources specified test
code files one after another and executes all specified test functions
defined therein. This is done sequentially for suites, test code files
and test functions. During the execution information about the test function calls including the
possible occurrence of failures or errors is recorded and returned at the
end of the test run. The return object can then be used to create a
test protocol of various formats.
</p>
<p><code>runTestFile</code> is just a  convenience function for executing the
tests in a single test file.
</p>
<p><code>defineTestSuite</code> is a helper function to define a test
suite. See below for a precise definition of a test suite.
</p>
<p><code>isValidTestSuite</code> checks if an object defines a valid test suite.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>defineTestSuite(name, dirs, testFileRegexp = "^runit.+\\.[rR]$",
                testFuncRegexp = "^test.+",
                rngKind = "Marsaglia-Multicarry",
                rngNormalKind = "Kinderman-Ramage")
isValidTestSuite(testSuite)
runTestSuite(testSuites, useOwnErrorHandler = TRUE, 
             verbose = getOption("RUnit")$verbose,
             gcBeforeTest = FALSE)
runTestFile(absFileName, useOwnErrorHandler = TRUE,
            testFuncRegexp = "^test.+",
            rngKind = "Marsaglia-Multicarry",
            rngNormalKind = "Kinderman-Ramage", 
            verbose = getOption("RUnit")$verbose,
            gcBeforeTest = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="runTestSuite_+3A_name">name</code></td>
<td>
<p>The name of the test suite.</p>
</td></tr>
<tr><td><code id="runTestSuite_+3A_dirs">dirs</code></td>
<td>
<p>Vector of absolute directory names where to look for test files.</p>
</td></tr>
<tr><td><code id="runTestSuite_+3A_testfileregexp">testFileRegexp</code></td>
<td>
<p>Regular expression for matching test files.</p>
</td></tr>
<tr><td><code id="runTestSuite_+3A_testfuncregexp">testFuncRegexp</code></td>
<td>
<p>Regular expression for matching test functions.</p>
</td></tr>
<tr><td><code id="runTestSuite_+3A_rngkind">rngKind</code></td>
<td>
<p>name of an available RNG  (see <code><a href="base.html#topic+Random">RNGkind</a></code> 
for possible options).</p>
</td></tr>
<tr><td><code id="runTestSuite_+3A_rngnormalkind">rngNormalKind</code></td>
<td>
<p>name of a valid rnorm RNG version (see 
<code><a href="base.html#topic+Random">RNGkind</a></code> for possible options).</p>
</td></tr>
<tr><td><code id="runTestSuite_+3A_testsuite">testSuite</code></td>
<td>
<p>A single object of class test suite.</p>
</td></tr>
<tr><td><code id="runTestSuite_+3A_testsuites">testSuites</code></td>
<td>
<p>A single object of class test suite or a list of
test suite objects.</p>
</td></tr>
<tr><td><code id="runTestSuite_+3A_useownerrorhandler">useOwnErrorHandler</code></td>
<td>
<p>If <code>TRUE</code> the RUnit framework installs
its own error handler during test case execution (but reinstalls the
original handler before it returns). If <code>FALSE</code> the error
handler is not touched by RUnit but then the test protocol does not
contain any call stacks in the case of errors.</p>
</td></tr>
<tr><td><code id="runTestSuite_+3A_verbose">verbose</code></td>
<td>
<p>level of verbosity of output log messages, 0: omits
begin/end comments for each test function. Queried from 
global options set for RUnit at package load.</p>
</td></tr>
<tr><td><code id="runTestSuite_+3A_absfilename">absFileName</code></td>
<td>
<p>Absolute file name of a test function.</p>
</td></tr>
<tr><td><code id="runTestSuite_+3A_gcbeforetest">gcBeforeTest</code></td>
<td>
<p>Run garbage collector before executing a test
for more precise test timing. Enabling this option makes the tests
run longer, especially when testing many small tests. By default
GC is disabled (since 0.4.32).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The basic idea of the RUnit test framework is to declare a certain set
of functions to be test functions and report the results of their
execution. The test functions must not take any parameter nor return
anything such that their execution can be automatised.
</p>
<p>The specification which functions are taken as test functions is
contained in an object of class  <code>RUnitTestSuite</code> which is a list
with the following elements.
</p>

<dl>
<dt>name</dt><dd><p>A simple character string. The name of a test suite is mainly used 
to create a well structure test protocol.</p>
</dd>
<dt>dirs</dt><dd><p>A character vector containing the absolute names of all
directories where to look for test files.</p>
</dd>
<dt>testFileRegexp</dt><dd><p>A regular expression specifying the test
files. All files in the test directories whose names match this
regular expression are taken as test files. Order of file names will
be alphabetical but depending on the used locale.</p>
</dd>
<dt>testFuncRegexp</dt><dd><p>A regular expression specifying the test
functions. All functions defined in the test files whose names match
this regular expression are used as test functions. Order of test
functions will be alphabetical.</p>
</dd>
</dl>

<p>After the RUnit framework has sequentially executed all test suites it returns all
data collected during the test run as an object of class
<code>RUnitTestData</code>. This is a (deeply nested)
list with one list element for each executed test suite. Each of these
executed test suite lists contains the following elements:
</p>

<dl>
<dt>nTestFunc</dt><dd><p>The number of test functions executed in the test
suite.</p>
</dd>
<dt>nErr</dt><dd><p>The number of errors that occurred during the execution.</p>
</dd>
<dt>nFail</dt><dd><p>The number of failures that occurred during the execution.</p>
</dd>
<dt>dirs</dt><dd><p>The test directories of the test suite.</p>
</dd>
<dt>testFileRegexp</dt><dd><p>The regular expression for identifying the test
files of the test suite.</p>
</dd>
<dt>testFuncRegexp</dt><dd><p>The regular expression for identifying the test
functions of the test suite.</p>
</dd>
<dt>sourceFileResults</dt><dd><p>A list containing the results for each
separate test file of the test suite.</p>
</dd>
</dl>

<p>The <code>sourceFileResults</code> list just mentioned contains one element
for each specified test function in the source file. This element is a list with
the following entries:
</p>

<dl>
<dt>kind</dt><dd><p>Character string with one of <code>success</code>, <code>error</code> or 
<code>failure</code> describing the outcome of the test function.</p>
</dd>
<dt>msg</dt><dd><p>the error message in case of an error or failure and
<code>NULL</code> for a successfully executed test function.</p>
</dd>
<dt>time</dt><dd><p>The duration (measured in seconds) of the successful
execution of a test function and <code>NULL</code> in the case of an error
or failure. When running with <code>gcBeforeTest</code> option 
set to <code>FALSE</code> (default since 0.4.32), the timing of the tests might
be misleading when garbage collector has to reclaim memory allocated by
a previous test.</p>
</dd>
<dt>traceBack</dt><dd><p>The full trace back as a character vector in the case of an 
error and <code>NULL</code> otherwise.</p>
</dd>
</dl>

<p>To further control test case execution it is possible to define two
parameterless function <code>.setUp</code> and <code><a href="#topic+.tearDown">.tearDown</a></code> in each
test file. <code>.setUp()</code> is executed directly before and
<code>.tearDown()</code> directly after each test function execution.
</p>
<p>Quite often, it is useful to base test cases on random numbers. To
make this procedure reproducible, the function <code>runTestSuite</code>
sets the random number generator to the default setting
<code>RNGkind(kind="Marsaglia-Multicarry",
    normal.kind="Kinderman-Ramage")</code> before sourcing each test file
(note that this default has been chosen due to historical reasons and
differs from the current R default). This default can be overwritten
by  configuring the random number generator at the beginning of a test
file. This setting, however, is valid only inside its own source file
and gets overwritten when the next test file is sourced.
</p>


<h3>Value</h3>

<p><code>runTestSuite</code> and <code>runTestFile</code> both return an object of
class RUnitTestData.
</p>
<p><code>defineTestSuite</code> returns an object of class  <code>RUnitTestSuite</code>.
</p>


<h3>Author(s)</h3>

<p>Thomas König, Klaus Jünemann
&amp; Matthias Burger</p>


<h3>See Also</h3>

<p><code><a href="#topic+checkTrue">checkTrue</a></code> and friends for writing test cases.
<code><a href="#topic+printTextProtocol">printTextProtocol</a></code> and <code><a href="#topic+printHTMLProtocol">printHTMLProtocol</a></code>
for printing the test protocol. See <a href="#topic+RUnit-options">RUnit-options</a> for global
options controlling log out.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## run some test suite
myTestSuite &lt;- defineTestSuite("RUnit Example",
                               system.file("examples", package = "RUnit"),
                               testFileRegexp = "correctTestCase.r")
testResult &lt;- runTestSuite(myTestSuite)

##  same but without the logger being involved
## source(file.path(system.file("examples", package = "RUnit"), 
##                  "correctTestCase.r"))
## test.correctTestCase()


## prints detailed text protocol
## to standard out:
printTextProtocol(testResult, showDetails = TRUE)

##  use current default RNGs
myTestSuite1 &lt;- defineTestSuite("RUnit Example",
                               system.file("examples", package = "RUnit"),
                               testFileRegexp = "correctTestCase.r",
                               rngKind = "Mersenne-Twister",
                               rngNormalKind = "Inversion")

testResult1 &lt;- runTestSuite(myTestSuite)


##  for single test files, e.g. outside a package context
testResult2 &lt;- runTestFile(file.path(system.file("examples", 
                                                 package = "RUnit"),
                                     "correctTestCase.r"))
printTextProtocol(testResult2, showDetails = TRUE)
</code></pre>

<hr>
<h2 id='textProtocol'>Printing a plain text, HTML or JUnit-like XML version of an RUnit test run protocol.</h2><span id='topic+printTextProtocol'></span><span id='topic+printHTMLProtocol'></span><span id='topic+printJUnitProtocol'></span><span id='topic+print.RUnitTestData'></span><span id='topic+summary.RUnitTestData'></span><span id='topic+getErrors'></span>

<h3>Description</h3>

<p><code>printTextProtocol</code> prints a plain text protocol of a test run.
The resulting test protocol can be configured through the function
arguments.
</p>
<p><code>printHTMLProtocol</code> prints an HTML protocol of a test run.
For long outputs this version of the test protocol is slightly more
readable than the plain text version due to links in the document.
The resulting test protocol can be configured through the function arguments.
</p>
<p><code>printJUnitProtocol</code> prints a JUnit-style XML protocol of a test run.
This feature is especially useful when running your RUnit tests through
a continuous integration server that understands JUnit (like Jenkins).
This machine-parseable output allows you to track errors over time,
sort by execution time and similar useful tricks. 
To take advantage of this function, you have to have the XML package installed.
</p>
<p><code>print</code> prints the number of executed test functions and the
number of failures and errors.
</p>
<p><code>summary</code> directly delegates the work to
<code>printTextProtocol</code>.
</p>
<p><code>getErrors</code> returns a list containing the number of test
functions, the number of deactivated functions (if there are any), the
number of errors and the number of failures.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  printTextProtocol(testData, fileName = "",
                    separateFailureList = TRUE,
                    showDetails = TRUE, traceBackCutOff = 9)
  printHTMLProtocol(testData, fileName = "",
                    separateFailureList = TRUE,
                    traceBackCutOff = 9,
                    testFileToLinkMap = function(x) x )
  printJUnitProtocol(testData, fileName = "")
  ## S3 method for class 'RUnitTestData'
print(x, ...)
  ## S3 method for class 'RUnitTestData'
summary(object, ...)
  getErrors(testData)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="textProtocol_+3A_testdata">testData</code>, <code id="textProtocol_+3A_x">x</code>, <code id="textProtocol_+3A_object">object</code></td>
<td>
<p>objects of class <code>RUnitTestData</code>, typically
obtained  as return value of a test run.</p>
</td></tr>
<tr><td><code id="textProtocol_+3A_filename">fileName</code></td>
<td>
<p>Connection where to print the text protocol (printing
is done by the <code>cat</code> command).</p>
</td></tr>
<tr><td><code id="textProtocol_+3A_separatefailurelist">separateFailureList</code></td>
<td>
<p>If <code>TRUE</code> a separate list of failures
and errors is produced at the top of the protocol. Otherwise, the
failures and errors are only listed in the details section.</p>
</td></tr>
<tr><td><code id="textProtocol_+3A_showdetails">showDetails</code></td>
<td>
<p>If <code>TRUE</code> the protocol contains a detailed listing of
all executed test functions.</p>
</td></tr>
<tr><td><code id="textProtocol_+3A_tracebackcutoff">traceBackCutOff</code></td>
<td>
<p>The details section of the test protocol contains the call stack for
all errors. The first few entries of the complete stack typically
contain the internal RUnit function calls that execute the test cases and
are irrelevant for debugging. This argument specifies how many calls
are removed from the stack before it is written to the protocol. The
default value is chosen such that all uninteresting RUnit calls are
removed from the stack if <code>runTestSuite</code> has been called from
the console. This argument takes effect only if
<code>showDetails=TRUE</code>.</p>
</td></tr>
<tr><td><code id="textProtocol_+3A_testfiletolinkmap">testFileToLinkMap</code></td>
<td>
<p>This function can be used to map the full name of the test file
to a corresponding html link to be used in the html protocol. By default, 
this is the identity map. See example below.</p>
</td></tr>
<tr><td><code id="textProtocol_+3A_...">...</code></td>
<td>
<p>additional arguments to summary are passed on to the
printTextProtocol() call.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The text protocol can roughly be divided into three sections with an
increasing amount of information. The first section as an overview just reports the
number of executed test functions and the number of failures and
errors. The second section describes all test suites. Optionally, all
errors and failures that occurred in some test suite are listed.
In the optional third section details are given about all executed
test functions in the order they were processed. For each test file
all test functions executed are listed in the order they were executed. After the test
function name the number of <code>check&lt;*&gt;</code> function calls inside the
test case and the execution time in seconds are stated. In the
case of an error or failure as much debug
information as possible is provided.
</p>


<h3>Author(s)</h3>

<p>Thomas König, Klaus Jünemann, Matthias Burger
&amp; Roman Zenka</p>


<h3>See Also</h3>

<p><code><a href="#topic+runTestSuite">runTestSuite</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## run some test suite
myTestSuite &lt;- defineTestSuite("RUnit Example",
                               system.file("examples", package = "RUnit"),
                               testFileRegexp = "correctTestCase.r")
testResult &lt;- runTestSuite(myTestSuite)


## prints detailed text protocol
## to standard out:
printTextProtocol(testResult, showDetails = TRUE)
## prints detailed html protocol
## to standard out
printHTMLProtocol(testResult)
## prints JUnit-style XML protocol
## to standard out. 
## You need to have XML package installed for this
if(require("XML")) {
  printJUnitProtocol(testResult)
}

## Not run: 
##  example function to add links to URL of the code files in a code
##  repository, here the SourceForge repository
testFileToSFLinkMap &lt;- function(testFileName, testDir = "tests") {
    ##  get unit test file name
    bname &lt;- basename(testFileName)
    
    ## figure out package name
    regExp &lt;- paste("^.*/([\.a-zA-Z0-9]*)/", testDir,"/.*$", sep = "")
    pack &lt;- sub(regExp, "\1", testFileName)
    return(paste("http://runit.cvs.sourceforge.net/runit/",
                 pack, testDir, bname, sep = "/"))
  }


##  example call for a test suite run on the RUnit package
testSuite &lt;- defineTestSuite("RUnit", "&lt;path-to-source-folder&gt;/RUnit/tests",
                             testFileRegexp = "^test.+")
testResult &lt;- runTestSuite(testSuite)
printHTMLProtocol(testResult, fileName = "RUnit-unit-test-log.html",
                  testFileToLinkMap = testFileToSFLinkMap )

## End(Not run)

</code></pre>

<hr>
<h2 id='tracker'>Tracking the results of the inspect process.</h2><span id='topic+tracker'></span>

<h3>Description</h3>

<p>The current implementation uses the 'closure trick' to hide all details from
the user and only allows to retrieve the results of the code inspection.
<code>tracker</code> is used to create a new environment to manage and store the results
of the tracking process. The <code>inspect</code> function requires such an
environment with the name &quot;track&quot; (currently mandatory). The tracker records how often each
and every function was called by <code>inspect</code> and summarizes the results of
all calls.
<code>tracker$init</code> initializes the tracker environment.
<code>tracker$getTrackInfo</code> returns a list with the tracked results of the
inspection process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tracker()
</code></pre>


<h3>Details</h3>

<p>The 'trackInfo' S3 class object (list) has one entry for each
function on the inspect list with the following elements:
</p>

<dl>
<dt>src</dt><dd><p>The source code of the function.</p>
</dd>
<dt>run</dt><dd><p>The number of executions for each line of code.</p>
</dd>
<dt>graph</dt><dd><p>A matrix. Each element in the matrix counts how often a
code line was called from the previous code line in the execution flow.</p>
</dd>
<dt>nrRuns</dt><dd><p>Counts how often the function was called.</p>
</dd>
<dt>funcCall</dt><dd><p>The declaration of the function.</p>
</dd>
</dl>



<h3>Methods</h3>


<table>
<tr>
 <td style="text-align: right;">
    </td><td style="text-align: left;"> <code>init</code> </td><td style="text-align: left;"> initializes the tracker environment</td>
</tr>
<tr>
 <td style="text-align: right;">
    </td><td style="text-align: left;"> <code>addFunc</code> </td><td style="text-align: left;"> add function to the inspect tracking list
    (internal use)</td>
</tr>
<tr>
 <td style="text-align: right;">
    </td><td style="text-align: left;"> <code>getSource</code> </td><td style="text-align: left;"> return the modified source code used for during inspection 
    the specified index (internal use)</td>
</tr>
<tr>
 <td style="text-align: right;">
    </td><td style="text-align: left;"> <code>bp</code> </td><td style="text-align: left;"> update tracking info for specified function
    index (internal use)</td>
</tr>
<tr>
 <td style="text-align: right;">
    </td><td style="text-align: left;"> <code>getTrackInfo</code> </td><td style="text-align: left;"> return 'trackInfo' object</td>
</tr>
<tr>
 <td style="text-align: right;">
    </td><td style="text-align: left;"> <code>isValid</code> </td><td style="text-align: left;"> check 'trackInfo' object for conformance to
    class contract </td>
</tr>
<tr>
 <td style="text-align: right;">
  </td>
</tr>

</table>



<h3>Author(s)</h3>

<p>Thomas König, Klaus Jünemann
&amp; Matthias Burger</p>


<h3>See Also</h3>

<p><code><a href="#topic+inspect">inspect</a></code> for the registration of functions &amp; methods to
be on the tracking list, and 
<code><a href="#topic+printHTML">printHTML</a></code> for displaying results
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## example functions
foo &lt;- function(x){
   y &lt;- 0
   for(i in 1:100)
   {
      y &lt;- y + i
   }
   return(y)
}

bar &lt;- function(x){
   y &lt;- 0
   for(i in 1:100)
   {
      y &lt;- y - i
   }
   return(y)
}



##  the object name track is 'fixed' (current implementation)
track &lt;- tracker()

##  initialize the tracker
track$init()

##  inspect the function
##  resFoo1 will contain the result of calling foo(50)
resFoo1 &lt;- inspect(foo(50), track = track)

resFoo2 &lt;- inspect(foo(20), track = track)

resBar1 &lt;- inspect(bar(30), track = track)

##  get the tracked function call info for all inspect calls
resTrack &lt;- track$getTrackInfo()

##  create HTML sites in folder &lt;tempdir&gt;/results for all inspect calls
printHTML(resTrack, baseDir=tempdir())
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
