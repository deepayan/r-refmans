<!DOCTYPE html><html><head><title>Help for package DeltaMAN</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {DeltaMAN}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#delta'><p>Compute the Delta coefficient</p></a></li>
<li><a href='#Kappa'><p>Compute the Cohen's kappa coefficient</p></a></li>
<li><a href='#multiDelta'><p>Performe massive Delta analysis</p></a></li>
<li><a href='#print.deltaMAN'><p>Print object of class deltaMAN.</p></a></li>
<li><a href='#runDeltaShinyApp'><p>Run Delta Shiny App</p></a></li>
<li><a href='#summary.delta'><p>Summary of Delta model</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Delta Measurement of Agreement for Nominal Data</td>
</tr>
<tr>
<td>Version:</td>
<td>0.5.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Analysis of agreement for nominal data between two raters using the Delta model. This model is proposed as an alternative to the widespread measure Cohen kappa coefficient, which performs poorly when the marginal distributions are very asymmetric (Martin-Andres and Femia-Marzo (2004), &lt;<a href="https://doi.org/10.1348%2F000711004849268">doi:10.1348/000711004849268</a>&gt;; Martin-Andres and Femia-Marzo (2008) &lt;<a href="https://doi.org/10.1080%2F03610920701669884">doi:10.1080/03610920701669884</a>&gt;). The package also contains a function to perform a massive analysis of multiple raters against a gold standard. A shiny app is also provided to obtain the measures of nominal agreement between two raters.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/LGPL-3">LGPL-3</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>shiny, shinyMatrix, xtable, shinyBS, knitr</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.0</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-06-23 07:33:42 UTC; amaldonado</td>
</tr>
<tr>
<td>Author:</td>
<td>Ana D. Maldonado <a href="https://orcid.org/0000-0001-8253-2526"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Pedro Femia Marzo <a href="https://orcid.org/0000-0002-1746-5619"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Antonio Martín Andrés
    <a href="https://orcid.org/0000-0002-2548-2638"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Ana D. Maldonado &lt;ana.d.maldonado@ual.es&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-06-23 18:10:18 UTC</td>
</tr>
</table>
<hr>
<h2 id='delta'>Compute the Delta coefficient</h2><span id='topic+delta'></span><span id='topic+Delta'></span>

<h3>Description</h3>

<p><code>delta()</code> computes Delta coefficient, or proportion of agreements that are not due to chance,
which is used to measure nominal agreement between two raters.
</p>
<p><code>delta()</code> and <code>Delta()</code> are synonyms.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>delta(
  data,
  standard = FALSE,
  fixedRows = FALSE,
  rawdata = NULL,
  tol = 1e-07,
  mxits = 100
)

Delta(
  data,
  standard = FALSE,
  fixedRows = FALSE,
  rawdata = NULL,
  tol = 1e-07,
  mxits = 100
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="delta_+3A_data">data</code></td>
<td>
<p>either a contingency table or raw data.</p>
</td></tr>
<tr><td><code id="delta_+3A_standard">standard</code></td>
<td>
<p>a logical value indicating whether the observer on the rows of the contingency table (or first column of raw data) is a goldstandard (i.e., gives the correct responses).</p>
</td></tr>
<tr><td><code id="delta_+3A_fixedrows">fixedRows</code></td>
<td>
<p>a logical value indicating whether the row marginals are fixed in advance (sampling type II) or not (sampling type I).</p>
</td></tr>
<tr><td><code id="delta_+3A_rawdata">rawdata</code></td>
<td>
<p>a logical value indicating whether the data is raw (TRUE) or a contingency table (FALSE). If not specified, the function will try to guess the data type.</p>
</td></tr>
<tr><td><code id="delta_+3A_tol">tol</code></td>
<td>
<p>the desired tolerance applied to find the root of the unknown constant B, needed to estimate the model parameters.</p>
</td></tr>
<tr><td><code id="delta_+3A_mxits">mxits</code></td>
<td>
<p>the maximum numer of iterations applied to find the root of the unknown constant B, needed to estimate the model parameters.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The allowed input data type are (1) contingency tables (of class <code>"table"</code> or <code>"matrix"</code>) or (2) raw data (of class <code>"data.frame"</code>).
If the data is of type (1), the empty classes (if any) are removed. If the data is of class (2), the function checks the number of columns (n) and throws an
error if n &lt; 2 or n &gt; 3. If n = 2, a frequency table is computed. If n = 3, it is assumed that one column represents the row index (normally, it is expected to be the first one).
Once the row index column is identified, it is removed and a frequency table is computed using the remaining two columns.
In all cases, the result is always a squared matrix, which will be used in the subsequent computation of the Delta coefficient.
The observer on the rows will be referred to as observer (or rater) R and the one on the columns will be referred to as observer (or rater) C.
</p>
<p>The function returns a list of 9 elements (if the number of classes is &gt;2):
</p>

<ul>
<li><p> Delta: This is a list of 2 elements:
(1) the estimates of the model: overall delta (Delta), partial delta for class j (partial_delta) and the distribution of responses made at random by observer C (proportions);
and the agreement measurements: agreement, conformity, predictivity and consistency (only some of the are shown, depending on the model assumed)
(2) the standard error of the estimates under the model assumed (sampling type I or II).
</p>
</li>
<li><p> Kappa: The estimate and standard error of the Cohen's Kappa coffiecient.
</p>
</li>
<li><p> Data: Input data and analyzed data (may be the same)
</p>
</li>
<li><p> GOF: Goodness of Fit for the Delta model. The chi squares statistic is computed. If the performed test is significative (p-value &lt; alpha), the model Delta is not suitable for the data.
</p>
</li>
<li><p> fixedRows: logical value that matches the &quot;fixedRows&quot; argument.
</p>
</li>
<li><p> standard: logical value that matches the &quot;standard&quot; argument.
</p>
</li>
<li><p> all.measures: This is a list including all the estimates and standard errors (disregarding the model assumed by the user).
</p>
</li>
<li><p> problem.parameters: This list contains information about the estimation of the auxiliary constant B, needed to estimate the model parameters.
</p>
</li>
<li><p> cov: This list contains 3 elements: the covariance matrix of the partial delta estimates; the covariance matrix of the proportion estimates; and the covariance matrix of the partial delta and proportion estimates.
</p>
</li></ul>

<p>If the number of classes is k = 2, another element is added to the aforementioned list, including the asymptotic analysis (asymptoticDelta).
</p>


<h3>Value</h3>

<p>An object of class <code>"delta"</code>, which is a list of 9 elements (or 10 if the dimension of the contingency table is 2x2). See details.
</p>


<h3>References</h3>

<p>Andrés, A. M., &amp; Marzo, P. F. (2004). Delta: A new measure of agreement between two raters. British journal of mathematical and statistical psychology, 57(1), 1-19.
</p>
<p>Andrés, A. M., &amp; Marzo, P. F. (2005). Chance-corrected measures of reliability and validity in KK tables. Statistical methods in medical research, 14(5), 473-492.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+summary.delta">summary.delta()</a></code> for the summary method created for objects of class delta, and <code><a href="#topic+print.deltaMAN">print.deltaMAN()</a></code> for the print method.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create a 3x3 matrix
m = matrix(c(15, 5, 0, 4, 21, 1, 3, 4, 25), ncol = 3)
# Compute the Delta coefficient assuming the rater on the rows 
# is a goldstandard and type II sampling.
obj = delta(m, standard = TRUE, fixedRows = TRUE)
# Get the complete report
summary(obj, fullReport = TRUE)

# Create a 2x2 matrix
m = matrix(c(15, 7, 3, 21), ncol = 2)
# Compute the Delta coefficient assuming no one is a goldstandard 
# and type I sampling.
obj = delta(m, standard = FALSE, fixedRows = FALSE)
# Get the report
summary(obj, fullReport = FALSE)

</code></pre>

<hr>
<h2 id='Kappa'>Compute the Cohen's kappa coefficient</h2><span id='topic+Kappa'></span>

<h3>Description</h3>

<p>Kappa() computes de Cohen's kappa coefficient for nominal or ordinal data.
If data is ordinal, weigthed kappa can be applied to allow disagreements to be weighted differently.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Kappa(
  m,
  r = 0,
  alternative = c("two.sided", "less", "greater"),
  conf.level = 0.95,
  partial = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Kappa_+3A_m">m</code></td>
<td>
<p>a squared matrix of frequencies between two observers.</p>
</td></tr>
<tr><td><code id="Kappa_+3A_r">r</code></td>
<td>
<p>an integer (0, 1, or 2) to create a matrix of weigths. See details.</p>
</td></tr>
<tr><td><code id="Kappa_+3A_alternative">alternative</code></td>
<td>
<p>a string specifying the alternative hypothesis to construct the confidence interval:
either &quot;two.sided&quot; (default), &quot;greater&quot; or &quot;less&quot;.</p>
</td></tr>
<tr><td><code id="Kappa_+3A_conf.level">conf.level</code></td>
<td>
<p>confidence level of the interval.</p>
</td></tr>
<tr><td><code id="Kappa_+3A_partial">partial</code></td>
<td>
<p>a logical value indicating whether to evaluate the degree of agreement of each category by collapsing the contingency table.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The weighted kappa can be computed when data are ordinal and the argument <code>r</code> is eigher 1 or 2:
</p>

<ul>
<li><p> if r = 0, unweighted kappa is computed (used for nominal variables)
</p>
</li>
<li><p> if r = 1, weighted kappa with linear formula is applied
</p>
</li>
<li><p> if r = 2, weighted kappa with quadratic formula is applied
</p>
</li></ul>



<h3>Value</h3>

<p>A list of 3 elements containing the kappa statistic, the standard error and the confidence interval.
If <code>"partial = TRUE"</code>, a data.frame containing 3 columns (the class, the unweighted partial kappa coefficient
for each class and the standards error of each estimate) is added to the list.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create a 3x3 matrix
m = matrix(c(15, 5, 0, 4, 21, 1, 3, 4, 25), ncol = 3)
# Compute the Kapa coefficient for nominal data
Kappa(m, r = 0, partial = TRUE)
# Compute the Kapa coefficient for ordinal data, using linear formula
Kappa(m, r = 1)
</code></pre>

<hr>
<h2 id='multiDelta'>Performe massive Delta analysis</h2><span id='topic+multiDelta'></span>

<h3>Description</h3>

<p><code>multiDelta()</code> performs the analysis of Delta for multiple raters against a goldstandard.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>multiDelta(
  data,
  which.measure = c("Delta", "Agreement", "Conformity", "Predictivity", "Consistency"),
  tol = 1e-07,
  mxits = 100
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="multiDelta_+3A_data">data</code></td>
<td>
<p>a data.frame whose first column is the goldstandard.</p>
</td></tr>
<tr><td><code id="multiDelta_+3A_which.measure">which.measure</code></td>
<td>
<p>character string indicating the measure of interest to retrieve from the analysis. Valid options are:
<code>"Delta"</code> (returns global Delta and SE), <code>"Agreement"</code> (returns measure of agreement of each category and SE),
<code>"Conformity"</code> (returns measure of conformity of each category and SE),
<code>"Predictivity"</code> (returns measure of predictivity of each category and SE),
and <code>"Consistency"</code> (returns measure of consistency of each category and SE).</p>
</td></tr>
<tr><td><code id="multiDelta_+3A_tol">tol</code></td>
<td>
<p>the desired tolerance applied to find the root of the unknown constant B, needed to estimate the model parameters.</p>
</td></tr>
<tr><td><code id="multiDelta_+3A_mxits">mxits</code></td>
<td>
<p>the maximum numer of iterations applied to find the root of the unknown constant B, needed to estimate the model parameters.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A print method is available for <code>"multiDelta"</code> objects.
The results can be reported as plain tex (tex = F) or LaTeX formatted (tex = T).
In the latter case, the table can be transposed (transpose = T).
</p>


<h3>Value</h3>

<p>An object of class <code>"multiDelta"</code>, which is a list of as many elements as measures selected.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create a data.frame for 1 goldstandards and 9 raters
dat = data.frame(replicate(10, sample(1:3, 120, replace = TRUE)))

# Compute de Delta model and return the Consistency a Conformity measures
mDelta = multiDelta(dat, which.measure = c('Consistency', 'Conformity'))
print(mDelta, tex = TRUE, transpose = TRUE)
</code></pre>

<hr>
<h2 id='print.deltaMAN'>Print object of class deltaMAN.</h2><span id='topic+print.deltaMAN'></span>

<h3>Description</h3>

<p><code>print</code> method for class <code>"deltaMAN"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'deltaMAN'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.deltaMAN_+3A_x">x</code></td>
<td>
<p>an object of class deltaMAN.</p>
</td></tr>
<tr><td><code id="print.deltaMAN_+3A_...">...</code></td>
<td>
<p>optional arguments passed to print for other classes created in the deltaMAN package.
Currently, it supports <code>"digits"</code> (the significant digits to be used)
and <code>"tex"</code> (a logical value indicating whether to generate formatted LaTeX output or plain output).
Also, optional argument <code>"transpose"</code> is available for objects of class <code>"multiDelta"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value. Results are printed on console.
</p>

<hr>
<h2 id='runDeltaShinyApp'>Run Delta Shiny App</h2><span id='topic+runDeltaShinyApp'></span>

<h3>Description</h3>

<p>Launch the Delta Shiny App to compute the Delta Measurement of Agreement for Nominal, from a user friendly interface.
The app also allows to download a report of results in .pdf or .tex (LaTeX) format. The latter format is compressed in a .zip file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>runDeltaShinyApp()
</code></pre>


<h3>Value</h3>

<p>No return value. A shiny app is launched.
</p>

<hr>
<h2 id='summary.delta'>Summary of Delta model</h2><span id='topic+summary.delta'></span>

<h3>Description</h3>

<p><code>summary</code> method for class <code>"delta"</code>.
This functions creates a report with the information contained in an object of class <code>"delta"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'delta'
summary(object, fullReport = FALSE, digits = 4, tex = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.delta_+3A_object">object</code></td>
<td>
<p>and object of class <code>"delta"</code></p>
</td></tr>
<tr><td><code id="summary.delta_+3A_fullreport">fullReport</code></td>
<td>
<p>a logical value indicating whether to generate an exhaustive report of the results (TRUE) or not (FALSE, default).</p>
</td></tr>
<tr><td><code id="summary.delta_+3A_digits">digits</code></td>
<td>
<p>an integer value indicating the significant digits to be used.</p>
</td></tr>
<tr><td><code id="summary.delta_+3A_tex">tex</code></td>
<td>
<p>a logical value indicating whether to generate formatted LaTeX output (TRUE) or plain output (FALSE, default).</p>
</td></tr>
<tr><td><code id="summary.delta_+3A_...">...</code></td>
<td>
<p>further arguments passed to summary. No one else is currently available.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value. Results are printed on console.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
