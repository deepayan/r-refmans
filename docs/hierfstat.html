<!DOCTYPE html><html><head><title>Help for package hierfstat</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {hierfstat}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#AIc'><p>Calculates corrected Assignment Index</p></a></li>
<li><a href='#allele.count'><p>Allelic counts</p></a></li>
<li><a href='#allelic.richness'><p>Estimates allelic richness</p></a></li>
<li><a href='#basic.stats'><p>Basic diversity and differentiation statistics</p></a></li>
<li><a href='#beta.dosage'><p>Estimates pairwise kinships and individual inbreeding coefficients from dosage data</p></a></li>
<li><a href='#betas'><p>Estimates <code class="reqn">\beta</code>s per population and a bootstrap confidence interval</p></a></li>
<li><a href='#biall2dos'><p>Converts bi-allelic SNPs from hierfstat format to dosage format</p></a></li>
<li><a href='#boot.ppbetas'><p>Estimates bootstrap confidence intervals for pairwise betas FST estimates</p></a></li>
<li><a href='#boot.ppfis'><p>Performs bootstrapping over loci of population's Fis</p></a></li>
<li><a href='#boot.ppfst'><p>Performs bootstrapping over loci of pairwise Fst</p></a></li>
<li><a href='#boot.vc'><p>Bootstrap confidence intervals for variance components</p></a></li>
<li><a href='#cont.isl'><p>A genetic dataset from a diploid organism in a continent-island model</p></a></li>
<li><a href='#cont.isl99'><p>A genetic dataset from a diploid organism in a continent-island model</p></a></li>
<li><a href='#crocrussula'><p>Genotypes and sex of 140 shrews Crocidura russula</p></a></li>
<li><a href='#diploid'><p>A genetic dataset from a diploid organism</p></a></li>
<li><a href='#exhier'><p>Example data set with 4 levels, one diploid and one haploid locus</p></a></li>
<li><a href='#fs.dosage'><p>Estimates F-statistics from dosage data</p></a></li>
<li><a href='#fstat2dos'><p>Converts a hierfstat genetic data frame to dosage data</p></a></li>
<li><a href='#g.stats'><p>Calculates likelihood-ratio G-statistic on contingency table</p></a></li>
<li><a href='#g.stats.glob'><p>Likelihood ratio G-statistic over loci</p></a></li>
<li><a href='#genet.dist'><p>Classical genetic distances estimation</p></a></li>
<li><a href='#genind2hierfstat'><p>Converts genind objects from adegenet into a hierfstat data frame</p></a></li>
<li><a href='#genot2al'><p>Separates diploid genotypes in its constituant alleles</p></a></li>
<li><a href='#getal'><p>Converts diploid genotypic data into allelic data</p></a></li>
<li><a href='#getal.b'><p>Converts diploid genotypic data into allelic data</p></a></li>
<li><a href='#grm2kinship'><p>Converts a Genetic Relationship Matrix (GRM) to a kinship matrix</p></a></li>
<li><a href='#gtrunchier'><p>Genotypes at 6 microsatellite loci of Galba truncatula from different patches in Western Switzerland</p></a></li>
<li><a href='#hierfstat'><p>General information on the hierfstat package</p></a></li>
<li><a href='#ind.count'><p>individual counts</p></a></li>
<li><a href='#indpca'><p>PCA on a matrix of individuals genotypes frequencies</p></a></li>
<li><a href='#kinship2dist'><p>Converts a kinship matrix to a distance matrix</p></a></li>
<li><a href='#kinship2grm'><p>Converts a kinship matrix to a Genetic Relation Matrix (GRM)</p></a></li>
<li><a href='#kinshipShift'><p>Shifts a kinship matrix</p></a></li>
<li><a href='#mat2vec'><p>Creates a vector from a matrix</p></a></li>
<li><a href='#matching'><p>Estimates matching between pairs of individuals</p></a></li>
<li><a href='#ms2bed'><p>Import the output of the <code>ms</code> program in a <code>BED</code> object</p></a></li>
<li><a href='#ms2dos'><p>Import <code>ms</code> output</p></a></li>
<li><a href='#nb.alleles'><p>Number of different alleles</p></a></li>
<li><a href='#pairwise.betas'><p>Estimates pairwise betas according to Weir and Goudet (2017)</p></a></li>
<li><a href='#pairwise.neifst'><p>Estimates pairwise FSTs according to Nei (1987)</p></a></li>
<li><a href='#pairwise.WCfst'><p>Estimates pairwise FSTs according to Weir and Cockerham (1984)</p></a></li>
<li><a href='#pcoa'><p>Principal coordinate analysis</p></a></li>
<li><a href='#pi.dosage'><p>Estimates nucleotide diversity (<code class="reqn">\pi</code>) from dosage data</p></a></li>
<li><a href='#pop.freq'><p>Allelic frequencies</p></a></li>
<li><a href='#pp.fst'><p>fst per pair</p></a></li>
<li><a href='#pp.sigma.loc'><p>wrapper to return per locus variance components</p></a></li>
<li><a href='#print.pp.fst'><p>print function for pp.fst</p></a></li>
<li><a href='#qn2.read.fstat'><p>Read QuantiNemo extended format for genotype files</p>
</p>
<p>Read QuantiNemo (<a href="http://www2.unil.ch/popgen/softwares/quantinemo/">http://www2.unil.ch/popgen/softwares/quantinemo/</a>) genotype files extended format (option 2)</p></a></li>
<li><a href='#read.fstat'><p>Reads data from a FSTAT file</p></a></li>
<li><a href='#read.fstat.data'><p>Reads data from a FSTAT file</p></a></li>
<li><a href='#read.ms'><p>Read data generated by Hudson ms program</p>
</p>
<p>Read data generated by</p>
<a href="http://home.uchicago.edu/rhudson1/source/mksamples.html">Hudson ms</a>
program, either as Haplotypes or as SNPs.</a></li>
<li><a href='#read.VCF'><p>Reads a VCF file into a BED object</p></a></li>
<li><a href='#samp.between'><p>Shuffles a sequence among groups defined by the input vector</p></a></li>
<li><a href='#samp.between.within'><p>Shuffles a sequence</p></a></li>
<li><a href='#samp.within'><p>Shuffles a sequence within groups defined by the input vector</p></a></li>
<li><a href='#sexbias.test'><p>Test for sex biased dispersal</p></a></li>
<li><a href='#sim.freq'><p>Simulates frequencies, for internal use only</p></a></li>
<li><a href='#sim.genot'><p>Simulates genotypes in an island model at equilibrium</p></a></li>
<li><a href='#sim.genot.metapop.t'><p>Simulate genetic data from a metapopulation model</p></a></li>
<li><a href='#sim.genot.t'><p>Simulate data from a non equilibrium continent-island model</p></a></li>
<li><a href='#subsampind'><p>Subsample a FSTAT data frame</p></a></li>
<li><a href='#TajimaD.dosage'><p>Estimates Tajima's D</p></a></li>
<li><a href='#test.between'><p>Tests the significance of the effect of test.lev on genetic differentiation</p></a></li>
<li><a href='#test.between.within'><p>Tests the significance of the effect of test.lev on genetic differentiation</p></a></li>
<li><a href='#test.g'><p>Tests the significance of the effect of level on genetic differentiation</p></a></li>
<li><a href='#test.within'><p>Tests the significance of the effect of inner.level on genetic differentiation within blocks defined by outer.level</p></a></li>
<li><a href='#theta.Watt.dosage'><p>Estimates <code class="reqn">\theta_{Watterson}</code> from dosage data</p></a></li>
<li><a href='#varcomp'><p>Estimates variance components for each allele of a locus</p></a></li>
<li><a href='#varcomp.glob'><p>Estimate variance components and hierarchical F-statistics over all loci</p></a></li>
<li><a href='#vec2mat'><p>Fills a triangular matrix from the inputed vector</p></a></li>
<li><a href='#wc'><p>Computes Weir and Cockrham estimates of Fstatistics</p></a></li>
<li><a href='#write.bayescan'><p>Writes a bayescan file</p></a></li>
<li><a href='#write.fstat'><p>Write an Fstat data file</p></a></li>
<li><a href='#write.ped'><p>Write ped file for analyses with PLINK</p></a></li>
<li><a href='#write.struct'><p>Write structure file</p></a></li>
<li><a href='#yangex'><p>Example data set from Yang (1998) appendix</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>0.5-11</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-05-03</td>
</tr>
<tr>
<td>Title:</td>
<td>Estimation and Tests of Hierarchical F-Statistics</td>
</tr>
<tr>
<td>Author:</td>
<td>Jerome Goudet [aut, cre],
  Thibaut Jombart [aut],
  Zhian N. Kamvar [ctb],
  Eric Archer [ctb],
  Olivier Hardy [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Jerome Goudet &lt;jerome.goudet@unil.ch&gt;</td>
</tr>
<tr>
<td>Imports:</td>
<td>ade4,adegenet,gaston,gtools,methods</td>
</tr>
<tr>
<td>Suggests:</td>
<td>ape, pegas, knitr, rmarkdown, testthat</td>
</tr>
<tr>
<td>Description:</td>
<td>Estimates hierarchical F-statistics from haploid or
    diploid genetic data with any numbers of levels in the hierarchy, following the
    algorithm of Yang (Evolution(1998), 52:950).
    Tests via randomisations the significance
    of each F and variance components, using the likelihood-ratio statistics G
    (Goudet et al. (1996) <a href="https://academic.oup.com/genetics/article/144/4/1933/6017091">https://academic.oup.com/genetics/article/144/4/1933/6017091</a>).
    Estimates genetic diversity statistics
    for haploid and diploid genetic datasets in various formats, including inbreeding and
    coancestry coefficients, and population specific F-statistics following
    Weir and Goudet (2017) <a href="https://academic.oup.com/genetics/article/206/4/2085/6072590">https://academic.oup.com/genetics/article/206/4/2085/6072590</a>.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://www.r-project.org">https://www.r-project.org</a>, <a href="https://github.com/jgx65/hierfstat">https://github.com/jgx65/hierfstat</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/jgx65/hierfstat/issues">https://github.com/jgx65/hierfstat/issues</a></td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-05-05 21:17:04 UTC; jgoudet</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-05-05 23:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='AIc'>Calculates corrected Assignment Index</h2><span id='topic+AIc'></span>

<h3>Description</h3>

<p>Calculates corrected Assignment Index as described in 
<a href="https://onlinelibrary.wiley.com/doi/abs/10.1046/j.1365-294X.2002.01496.x">Goudet etal. (2002)</a>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>AIc(dat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="AIc_+3A_dat">dat</code></td>
<td>
<p>a data frane with nlocs+1 columns,</p>
</td></tr>
</table>


<h3>Value</h3>

<p>aic  The corrected assignment index of each individual
</p>


<h3>Author(s)</h3>

<p>Jerome Goudet <a href="mailto:jerome.goudet@unil.ch">jerome.goudet@unil.ch</a>
</p>


<h3>References</h3>

<p><a href="https://onlinelibrary.wiley.com/doi/abs/10.1046/j.1365-294X.2002.01496.x">Goudet J, Perrin N, Waser P (2002)</a> 
Tests for sex-biased dispersal 
using bi-parentally inherited genetic markers 11, 1103:1114
</p>

<hr>
<h2 id='allele.count'>Allelic counts</h2><span id='topic+allele.count'></span>

<h3>Description</h3>

<p>Counts the number of copies of the different alleles at each locus and population</p>


<h3>Usage</h3>

<pre><code class='language-R'>allele.count(data,diploid=TRUE)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="allele.count_+3A_data">data</code></td>
<td>
<p>A data frame containing the population of origin in the first column and the genotypes in the following ones</p>
</td></tr>
<tr><td><code id="allele.count_+3A_diploid">diploid</code></td>
<td>
<p>Whether the data are from diploid individuals</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of tables, &ndash;each with np (number of populations) columns and nl (number of loci) rows&ndash; of the count of each allele
</p>


<h3>Author(s)</h3>

<p>Jerome Goudet <a href="mailto:jerome.goudet@unil.ch">jerome.goudet@unil.ch</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(gtrunchier)
allele.count(gtrunchier[,-2])
</code></pre>

<hr>
<h2 id='allelic.richness'>Estimates allelic richness</h2><span id='topic+allelic.richness'></span>

<h3>Description</h3>

<p>Estimates allelic richness, the rarefied allelic counts, per locus and population</p>


<h3>Usage</h3>

<pre><code class='language-R'>allelic.richness(data,min.n=NULL,diploid=TRUE)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="allelic.richness_+3A_data">data</code></td>
<td>
<p>A data frame, with as many rows as individuals. The first column contains the population to which the individual belongs, the following to the different loci</p>
</td></tr>
<tr><td><code id="allelic.richness_+3A_min.n">min.n</code></td>
<td>
<p>The number of alleles down to which the number of alleles should be rarefied. The default is the minimum number of individuals genotyped (times 2 for diploids)</p>
</td></tr>
<tr><td><code id="allelic.richness_+3A_diploid">diploid</code></td>
<td>
<p>a boolean specifying wether individuals are diploid (default) or haploid</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>min.all</code></td>
<td>
<p>The number of alleles used for rarefaction</p>
</td></tr>
<tr><td><code>Ar</code></td>
<td>
<p>A table with as many rows as loci and columns as populations containing the rarefied allele counts</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jerome Goudet <a href="mailto:jerome.goudet@unil.ch">jerome.goudet@unil.ch</a></p>


<h3>References</h3>

<p>El Mousadik A. and  Petit R.J. (1996) High level of genetic differentiation for allelic richness among populations of the argan tree argania spinosa skeels endemic to Morocco. Theoretical and Applied Genetics, 92:832-839
</p>
<p>Hurlbert S.H. (1971) The nonconcept of species diversity: a critique and alternative parameters. Ecology, 52:577-586
</p>
<p>Petit R.J.,  El Mousadik A. and Pons O. (1998) Identifying populations for conservation on the basis of genetic markers. Conservation Biology, 12:844-855
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(gtrunchier)
allelic.richness(gtrunchier[,-1])
</code></pre>

<hr>
<h2 id='basic.stats'>Basic diversity and differentiation statistics</h2><span id='topic+basic.stats'></span><span id='topic+Hs'></span><span id='topic+Ho'></span><span id='topic+print.basic.stats'></span>

<h3>Description</h3>

<p>Estimates individual counts, allelic frequencies, observed heterozygosities and genetic diversities per locus and population.
Also Estimates mean observed heterozygosities, mean gene diversities within population Hs, Gene diversities overall Ht and corrected Htp, and Dst, Dstp.
Finally, estimates Fst and Fstp as well as Fis following Nei (1987) per locus and overall loci</p>


<h3>Usage</h3>

<pre><code class='language-R'>basic.stats(data,diploid=TRUE,digits=4)

## S3 method for class 'basic.stats'
print(x,...)

Hs(data,...)

Ho(data,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="basic.stats_+3A_data">data</code></td>
<td>
<p>a data frame where the first column contains the population to which the different individuals belong, and the following columns contain the genotype of the individuals -one locus per column- </p>
</td></tr>
<tr><td><code id="basic.stats_+3A_diploid">diploid</code></td>
<td>
<p>Whether individuals are diploids (default) or haploids</p>
</td></tr>
<tr><td><code id="basic.stats_+3A_digits">digits</code></td>
<td>
<p>how many digits to print out in the output (default is 4)</p>
</td></tr>
<tr><td><code id="basic.stats_+3A_x">x</code></td>
<td>
<p>an object of class basic.stats</p>
</td></tr>
<tr><td><code id="basic.stats_+3A_...">...</code></td>
<td>
<p>further arguments to pass to print.bas.stats</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>n.ind.samp</code></td>
<td>
<p>A table &ndash;with np (number of populations) columns and nl (number of loci) rows&ndash; of genotype counts</p>
</td></tr>
<tr><td><code>pop.freq</code></td>
<td>
<p>A list containing allele frequencies. Each element of the list is one locus.
For each locus, Populations are in columns and alleles in rows</p>
</td></tr>
<tr><td><code>Ho</code></td>
<td>
<p>A table &ndash;with np (number of populations) columns and nl (number of loci) rows&ndash; of observed heterozygosities</p>
</td></tr>
<tr><td><code>Hs</code></td>
<td>
<p>A table &ndash;with np (number of populations) columns and nl (number of loci) rows&ndash; of observed gene diversities</p>
</td></tr>
<tr><td><code>Fis</code></td>
<td>
<p>A table &ndash;with np (number of populations) columns and nl (number of loci) rows&ndash;of observed Fis</p>
</td></tr>
<tr><td><code>perloc</code></td>
<td>
<p>A table &ndash;with as many rows as loci&ndash; containing basic statistics Ho, Hs, Ht, Dst, Ht', Dst', Fst, Fst' ,Fis, Dest</p>
</td></tr>
<tr><td><code>overall</code></td>
<td>
<p>Basic statistics averaged over loci</p>
</td></tr>
</table>


<h3>Note</h3>

<p>For the perloc and overall tables (see value section), the following statistics, defined in eq.7.38&ndash; 7.43 pp.164&ndash;5 of Nei (1987)
are estimated:
</p>
<p>The observed heterozygosity
</p>
<p style="text-align: center;"><code class="reqn">Ho= 1-\sum_k \sum_i  Pkii/np,</code>
</p>

<p>where <code class="reqn">Pkii</code> represents the proportion of homozygote <code class="reqn">i</code> in sample <code class="reqn">k</code> and
<code class="reqn">np</code> the number of samples.
</p>
<p>The within population gene diversity (sometimes misleadingly called expected
heterozygosity):
</p>
<p style="text-align: center;"><code class="reqn">Hs=\tilde{n}/(\tilde{n}-1)[1-\sum_i\bar{p_i^2}-Ho/2\tilde{n}],
</code>
</p>

<p>where <code class="reqn">\tilde{n}=np/\sum_k 1/n_k</code> and
<code class="reqn">\bar{p_i^2}=\sum_k p_{ki}^2/np</code>
</p>
<p>The overall gene diversity
</p>
<p style="text-align: center;"><code class="reqn">
Ht= 1-\sum_i\bar{p_i}^2+Hs/(\tilde{n} np)-Ho/(2\tilde{n}
np),</code>
</p>

<p>where <code class="reqn">\bar{p_i}=\sum_kp_{ki}/np</code>.
</p>
<p>The amount of gene diversity among samples <code class="reqn">Dst=Ht-Hs</code>
</p>
<p><code class="reqn">Dst'=np/(np-1)Dst</code>
</p>
<p><code class="reqn">Ht'=Hs+Dst'</code>
</p>
<p><code class="reqn">Fst=Dst/Ht</code>.(This is not the same as Nei's <code class="reqn">Gst</code>,
Nei's <code class="reqn">Gst</code> is an estimator of <code class="reqn">Fst</code> based on allele frequencies only)
</p>
<p><code class="reqn">Fst'=Dst'/Ht'</code>
</p>
<p><code class="reqn">Fis=1-Ho/Hs</code>
</p>
<p>Last, <code class="reqn">Dest=np/(np-1) (Ht'-Hs)/(1-Hs)</code> a measure of population
differentiation as defined by Jost (2008) is also given
</p>
<p>Here, the <code class="reqn">p_{ki}</code> are unweighted by sample size. These statistics are
estimated for each locus and an overall loci estimates is also given, as the
unweighted average of the per locus estimates. In this way, monomorphic loci
are accounted for (with estimated value of 0) in the overall estimates.
</p>
<p>Note that the equations used here all rely on genotypic rather than allelic
number and are corrected for heterozygosity.
</p>


<h3>Author(s)</h3>

<p>Jerome Goudet <a href="mailto:jerome.goudet@unil.ch">jerome.goudet@unil.ch</a></p>


<h3>References</h3>

<p>Nei M. (1987) Molecular Evolutionary Genetics. Columbia University Press
</p>
<p>Jost L (2008) GST and its relatives do not measure differentiation.
Molecular Ecology, 17, 4015-4026.
</p>
<p>Nei M, Chesser R (1983) Estimation of fixation indexes and gene diversities.
Annals of Human Genetics, 47, 253-259.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ind.count">ind.count</a></code>,<code><a href="#topic+pop.freq">pop.freq</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(gtrunchier)
basic.stats(gtrunchier[,-1])
Hs(gtrunchier[,-2])
Ho(gtrunchier[,-2])
</code></pre>

<hr>
<h2 id='beta.dosage'>Estimates pairwise kinships and individual inbreeding coefficients from dosage data</h2><span id='topic+beta.dosage'></span>

<h3>Description</h3>

<p>Estimates pairwise kinships (coancestries) and individual inbreeding coefficient 
using Weir and Goudet (2017) beta estimator.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>beta.dosage(dos,inb=TRUE,Mb=FALSE,MATCHING=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="beta.dosage_+3A_dos">dos</code></td>
<td>
<p>A matrix of 0, 1 and 2s with loci (SNPs) in columns and individuals in rows. 
Missing values are allowed</p>
</td></tr>
<tr><td><code id="beta.dosage_+3A_inb">inb</code></td>
<td>
<p>whether individual inbreeding coefficient should be estimated (rather than self-coancestries)</p>
</td></tr>
<tr><td><code id="beta.dosage_+3A_mb">Mb</code></td>
<td>
<p>whether to output the mean matching</p>
</td></tr>
<tr><td><code id="beta.dosage_+3A_matching">MATCHING</code></td>
<td>
<p>if <code>MATCHING=FALSE</code>, <code>dos</code> is a (ni x nl) dosage matrix; 
if <code>MATCHING=TRUE</code>, dos is a (ni x ni) matrix 
of matching proportions, as obtained from a call to the <code><a href="#topic+matching">matching</a></code> function</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is written for dosage data, i.e., how many doses of an allele (0, 1 or 2) an individual carries.
It should be use for bi-allelic markers only (e.g. SNPs), although you might &quot;force&quot; a k multiallelic locus to k biallelic
loci (see <code><a href="#topic+fstat2dos">fstat2dos</a></code>). 
</p>
<p>Matching proportions can be obtained by the following equation: <code class="reqn">M=\beta*(1-Mb)+Mb</code> 
</p>
<p>By default (<code>inb=TRUE</code>) the inbreeding coefficient is returned on the main diagonal.  
With <code>inb=FALSE</code>, self coancestries are reported.
</p>
<p>Twice the betas with self-coancestries on the diagonal gives the Genomic Relationship Matrix (GRM)     
</p>
<p>Following a suggestion from Olivier Hardy, missing data are removed from the estimation procedure, 
rather than imputed (this is taken care off automatically)
</p>


<h3>Value</h3>

<p>if <code>Mb</code>=FALSE, a matrix of pairwise kinships and inbreeding coefficients (if <code>inb</code>=TRUE) or self-coancestries 
(<code>inb</code>=FALSE);  
if <code>Mb</code>=TRUE, a list with elements <code>inb</code> (whether inbreeding coefficients rather than kinships should 
be returned on the main diagonal),
<code>MB</code> (the average off-diagonal matching) and <code>betas</code> the kinships or inbreeding coefficients.
</p>


<h3>Author(s)</h3>

<p>Jerome Goudet <a href="mailto:jerome.goudet@unil.ch">jerome.goudet@unil.ch</a>
</p>


<h3>References</h3>

<p><a href="https://academic.oup.com/genetics/article/206/4/2085/6072590">Weir, BS and Goudet J. 2017</a> A Unified Characterization 
of Population Structure and Relatedness. Genetics (2017) 206:2085 
</p>
<p><a href="https://onlinelibrary.wiley.com/doi/full/10.1111/mec.14833">Goudet, J., Kay, T. and Weir BS. 2018</a> How to estimate kinship. 
Molecular Ecology 27:4121.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
 dos&lt;-matrix(sample(0:2,size=10000,replace=TRUE),ncol=100)
 beta.dosage(dos,inb=TRUE)
 
 #matrix of kinship/inbreeding coeff
 data(gtrunchier)
 beta.dosage(fstat2dos(gtrunchier[,-c(1:2)]))
 
 #individual inbreeding coefficients
 dat&lt;-sim.genot(size=100,nbloc=100,nbal=20,mig=0.01,f=c(0,0.3,0.7))
 hist(diag(beta.dosage(fstat2dos(dat[,-1]))),breaks=-10:100/100,main="",xlab="",ylab="")
 abline(v=c(0.0,0.3,0.7),col="red")
 #only 20 loci
 hist(diag(beta.dosage(fstat2dos(dat[,2:21]))),breaks=-5:20/20,main="",xlab="",ylab="")
 abline(v=c(0.0,0.3,0.7),col="red")
 

## End(Not run)
</code></pre>

<hr>
<h2 id='betas'>Estimates <code class="reqn">\beta</code>s per population and a bootstrap confidence interval</h2><span id='topic+betas'></span><span id='topic+print.betas'></span>

<h3>Description</h3>

<p>Estimate populations (Population specific FST) or individual coancestries 
and a bootstrap confidence interval, assuming random mating
</p>


<h3>Usage</h3>

<pre><code class='language-R'>betas(dat,nboot=0,lim=c(0.025,0.975),diploid=TRUE,betaijT=FALSE)

## S3 method for class 'betas'
print(x, digits = 4, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="betas_+3A_dat">dat</code></td>
<td>
<p>data frame with genetic data and pop identifier</p>
</td></tr>
<tr><td><code id="betas_+3A_nboot">nboot</code></td>
<td>
<p>number of bootstrap samples.</p>
</td></tr>
<tr><td><code id="betas_+3A_lim">lim</code></td>
<td>
<p>width of the bootstrap confidence interval</p>
</td></tr>
<tr><td><code id="betas_+3A_diploid">diploid</code></td>
<td>
<p>whether the data comes from a diploid organism</p>
</td></tr>
<tr><td><code id="betas_+3A_betaijt">betaijT</code></td>
<td>
<p>whether to estimate individual coancestries</p>
</td></tr>
<tr><td><code id="betas_+3A_x">x</code></td>
<td>
<p>a betas object</p>
</td></tr>
<tr><td><code id="betas_+3A_digits">digits</code></td>
<td>
<p>number of digits to print</p>
</td></tr>
<tr><td><code id="betas_+3A_...">...</code></td>
<td>
<p>further arguments to pass to print</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If betaijT=TRUE, and the first column contains a unique identifier for 
each individual, the function returns the matrix of individual coancestries/kinships.  
Individual inbreeding coefficients can be obtained by multiplying by 2 the diagonal 
and substracting 1.
</p>


<h3>Value</h3>

<p>Hi Within population gene diversities (complement to 1 of matching probabilities)
</p>
<p>Hb Between populations gene diversities
</p>
<p>betaiovl Average <code class="reqn">\hat{\beta_{WT}^i}</code> over loci (Population specific FSTs), Table 3 of 
<a href="https://academic.oup.com/genetics/article/206/4/2085/6072590">Weir and Goudet, 2017 (Genetics)</a>
</p>
<p>betaW Average of the betaiovl <code class="reqn">\hat{\beta_{WT}}</code> over loci (overall population FST)
</p>
<p>ci The bootstrap confidence interval of population specific FSTs
(only if more than 100 bootstraps requested AND if more than 10 loci are present)
</p>
<p>if betaijT=TRUE, return the matrix of pairwise kinships only.
</p>


<h3>Methods (by generic)</h3>


<ul>
<li> <p><code>print</code>: print function for betas class
</p>
</li></ul>


<h3>Author(s)</h3>

<p>Jerome Goudet <a href="mailto:jerome.goudet@unil.ch">jerome.goudet@unil.ch</a>
</p>


<h3>References</h3>

<p><a href="https://academic.oup.com/genetics/article/206/4/2085/6072590">Weir and Goudet, 2017 (Genetics)</a> 
A unified characterization of population structure and relatedness.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fs.dosage">fs.dosage</a></code>, <code><a href="#topic+beta.dosage">beta.dosage</a></code> for Fst estimates (not assuming Random Mating) 
and kinship estimates from dosage data, respectively
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#3 different population sizes lead to 3 different betais
dat&lt;-sim.genot(size=40,N=c(50,200,1000),nbloc=50,nbal=10)
betas(dat,nboot=100)
 
#individual coancestries from the smallest population are large
ind.coan&lt;-betas(cbind(1:120,dat[,-1]),betaij=T)
diag(ind.coan$betaij)&lt;-NA
graphics::image(1:120,1:120,ind.coan$betaij,xlab="Inds",ylab="Inds")

## End(Not run)

</code></pre>

<hr>
<h2 id='biall2dos'>Converts bi-allelic SNPs from hierfstat format to dosage format</h2><span id='topic+biall2dos'></span>

<h3>Description</h3>

<p>Converts bi-allelic SNPs hierfstat format to dosage format, the number of alternate allele copies at a locus
for an individual, i.e. 11 -&gt; 0; 12 or 21 &gt;1 and 22 -&gt;2
</p>


<h3>Usage</h3>

<pre><code class='language-R'>biall2dos(dat,diploid=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="biall2dos_+3A_dat">dat</code></td>
<td>
<p>a hierfstat data frame without the first column (the population identifier), 
individuals in rows, columns with individual genotypes encoded as 11, 12, 21 and 22</p>
</td></tr>
<tr><td><code id="biall2dos_+3A_diploid">diploid</code></td>
<td>
<p>whether the data set is from a diploid organism</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix containing allelic dosages
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
biall2dos(sim.genot(nbal=2,nbloc=10)[,-1])  # a 10 column matrix

## End(Not run)

</code></pre>

<hr>
<h2 id='boot.ppbetas'>Estimates bootstrap confidence intervals for pairwise betas FST estimates</h2><span id='topic+boot.ppbetas'></span>

<h3>Description</h3>

<p>Estimates bootstrap confidence intervals for pairwise betas FST estimates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>boot.ppbetas(dat=dat,nboot=100,quant=c(0.025,0.975),diploid=TRUE,digits=4)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="boot.ppbetas_+3A_dat">dat</code></td>
<td>
<p>A data frame containing population of origin as the first column 
and multi-locus genotypes in following columns</p>
</td></tr>
<tr><td><code id="boot.ppbetas_+3A_nboot">nboot</code></td>
<td>
<p>the number of bootstrap samples to draw</p>
</td></tr>
<tr><td><code id="boot.ppbetas_+3A_quant">quant</code></td>
<td>
<p>the limit of the confidence intervals</p>
</td></tr>
<tr><td><code id="boot.ppbetas_+3A_diploid">diploid</code></td>
<td>
<p>whether the data is from a diploid (default) or haploid organism</p>
</td></tr>
<tr><td><code id="boot.ppbetas_+3A_digits">digits</code></td>
<td>
<p>how many digits to print out</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix with upper limit of the bootstrap CI
above the diagonal and lower limit below the diagonal
</p>


<h3>See Also</h3>

<p><a href="#topic+betas">betas</a> <a href="#topic+pairwise.betas">pairwise.betas</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(gtrunchier)
boot.ppbetas(gtrunchier[,-2])

## End(Not run)
</code></pre>

<hr>
<h2 id='boot.ppfis'>Performs bootstrapping over loci of population's Fis</h2><span id='topic+boot.ppfis'></span>

<h3>Description</h3>

<p>Performs bootstrapping over loci of population's Fis</p>


<h3>Usage</h3>

<pre><code class='language-R'>boot.ppfis(dat=dat,nboot=100,quant=c(0.025,0.975),diploid=TRUE,dig=4,...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="boot.ppfis_+3A_dat">dat</code></td>
<td>
<p>a genetic data frame</p>
</td></tr>
<tr><td><code id="boot.ppfis_+3A_nboot">nboot</code></td>
<td>
<p>number of bootstraps</p>
</td></tr>
<tr><td><code id="boot.ppfis_+3A_quant">quant</code></td>
<td>
<p>quantiles</p>
</td></tr>
<tr><td><code id="boot.ppfis_+3A_diploid">diploid</code></td>
<td>
<p>whether diploid data</p>
</td></tr>
<tr><td><code id="boot.ppfis_+3A_dig">dig</code></td>
<td>
<p>digits to print</p>
</td></tr>
<tr><td><code id="boot.ppfis_+3A_...">...</code></td>
<td>
<p>further arguments to pass to the function</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>call</code></td>
<td>
<p>function call</p>
</td></tr>
<tr><td><code>fis.ci</code></td>
<td>
<p>Bootstrap ci of Fis per population</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jerome Goudet <a href="mailto:jerome.goudet@unil.ch">jerome.goudet@unil.ch</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>dat&lt;-sim.genot(nbpop=4,nbloc=20,nbal=10,f=c(0,0.2,0.4,0.6))
boot.ppfis(dat)
</code></pre>

<hr>
<h2 id='boot.ppfst'>Performs bootstrapping over loci of pairwise Fst</h2><span id='topic+boot.ppfst'></span><span id='topic+print.boot.ppfst'></span>

<h3>Description</h3>

<p>Performs bootstrapping over loci of pairwise Fst</p>


<h3>Usage</h3>

<pre><code class='language-R'>boot.ppfst(dat=dat,nboot=100,quant=c(0.025,0.975),diploid=TRUE,...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="boot.ppfst_+3A_dat">dat</code></td>
<td>
<p>a genetic data frame</p>
</td></tr>
<tr><td><code id="boot.ppfst_+3A_nboot">nboot</code></td>
<td>
<p>number of bootstraps</p>
</td></tr>
<tr><td><code id="boot.ppfst_+3A_quant">quant</code></td>
<td>
<p>the quantiles for bootstrapped ci</p>
</td></tr>
<tr><td><code id="boot.ppfst_+3A_diploid">diploid</code></td>
<td>
<p>whether data are from diploid organisms</p>
</td></tr>
<tr><td><code id="boot.ppfst_+3A_...">...</code></td>
<td>
<p>further arguments to pass to the function</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>call</code></td>
<td>
<p>call to the function</p>
</td></tr>
<tr><td><code>ll</code></td>
<td>
<p>lower limit ci</p>
</td></tr>
<tr><td><code>ul</code></td>
<td>
<p>upper limit ci</p>
</td></tr>
<tr><td><code>vc.per.loc</code></td>
<td>
<p>for each pair of population, the variance components per locus</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jerome Goudet <a href="mailto:jerome.goudet@unil.ch">jerome.goudet@unil.ch</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(gtrunchier)
x&lt;-boot.ppfst(gtrunchier[,-2])
x$ll
x$ul
</code></pre>

<hr>
<h2 id='boot.vc'>Bootstrap confidence intervals for variance components</h2><span id='topic+boot.vc'></span>

<h3>Description</h3>

<p>Provides a bootstrap confidence interval (over loci) for sums of the different variance components (equivalent to gene diversity estimates at the different levels), and the  derived F-statistics, as suggested by Weir and Cockerham (1984). Will not run with less than 5 loci. Raymond and Rousset (199X) points out shortcomings of this method.</p>


<h3>Usage</h3>

<pre><code class='language-R'>boot.vc(levels=levels,loci=loci,diploid=TRUE,nboot=1000,quant=c(0.025,0.5,0.975))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="boot.vc_+3A_levels">levels</code></td>
<td>
<p>a data frame containing the different levels (factors) from the outermost (e.g. region) to the innermost before the individual</p>
</td></tr>
<tr><td><code id="boot.vc_+3A_loci">loci</code></td>
<td>
<p>a data frame containing the different loci</p>
</td></tr>
<tr><td><code id="boot.vc_+3A_diploid">diploid</code></td>
<td>
<p>Specify whether the data are coming from diploid or haploid organisms (diploid is the default)</p>
</td></tr>
<tr><td><code id="boot.vc_+3A_nboot">nboot</code></td>
<td>
<p>Specify the number of bootstrap to carry out. Default is 1000</p>
</td></tr>
<tr><td><code id="boot.vc_+3A_quant">quant</code></td>
<td>
<p>Specify which quantile to produce. Default is c(0.025,0.5,0.975) giving the percentile 95% CI and the median</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>boot</code></td>
<td>
<p>a data frame with the bootstrapped variance components. Could be used for obtaining bootstrap ci of statistics not listed here.</p>
</td></tr>
<tr><td><code>res</code></td>
<td>
<p>a data frame with the bootstrap derived statistics. H stands for gene diversity, F for F-statistics</p>
</td></tr>
<tr><td><code>ci</code></td>
<td>
<p>Confidence interval for each statistic.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Raymond M and Rousset F, 1995. An exact test for population differentiation. Evolution. 49:1280-1283
</p>
<p>Weir, B.S. (1996) Genetic Data Analysis II. Sinauer Associates.
</p>
<p>Weir BS and Cockerham CC, 1984. Estimating F-statistics for the analysis of population structure. Evolution 38:1358-1370.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+varcomp.glob">varcomp.glob</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>#load data set
data(gtrunchier)
boot.vc(gtrunchier[,c(1:2)],gtrunchier[,-c(1:2)],nboot=100)
</code></pre>

<hr>
<h2 id='cont.isl'>A genetic dataset from a diploid organism in a continent-island model</h2><span id='topic+cont.isl'></span>

<h3>Description</h3>

<p>A simple diploid dataset, with allele encoded as one digit number.  
Up to 4 alleles per locus
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(cont.isl)
</code></pre>


<h3>Format</h3>

<p>A data frame with 150 rows and 6 columns:
</p>

<dl>
<dt>Pop</dt><dd><p>Population identifier, from 1 to 3</p>
</dd>
<dt>loc.1</dt><dd><p>genotype at loc.1</p>
</dd>
<dt>loc.2</dt><dd><p>genotype at loc.2</p>
</dd>
<dt>loc.3</dt><dd><p>genotype at loc.3</p>
</dd>
<dt>loc.4</dt><dd><p>genotype at loc.4</p>
</dd>
<dt>loc.5</dt><dd><p>genotype at loc.5</p>
</dd>
</dl>
<p>...

</p>


<h3>Source</h3>

<p>generated with function sim.genot()
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(cont.isl)
allele.count(cont.isl)

</code></pre>

<hr>
<h2 id='cont.isl99'>A genetic dataset from a diploid organism in a continent-island model</h2><span id='topic+cont.isl99'></span>

<h3>Description</h3>

<p>A simple diploid dataset, with alleles encoded as two digits numbers.  
Up to 99 alleles per locus
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(cont.isl99)
</code></pre>


<h3>Format</h3>

<p>A data frame with 150 rows and 6 columns:
</p>

<dl>
<dt>Pop</dt><dd><p>Population identifier, from 1 to 3</p>
</dd>
<dt>loc.1</dt><dd><p>genotype at loc.1</p>
</dd>
<dt>loc.2</dt><dd><p>genotype at loc.2</p>
</dd>
<dt>loc.3</dt><dd><p>genotype at loc.3</p>
</dd>
<dt>loc.4</dt><dd><p>genotype at loc.4</p>
</dd>
<dt>loc.5</dt><dd><p>genotype at loc.5</p>
</dd>
</dl>
<p>...

</p>


<h3>Source</h3>

<p>generated with function sim.genot(nbal=99)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(cont.isl99)
allele.count(cont.isl99)

</code></pre>

<hr>
<h2 id='crocrussula'>Genotypes and sex of 140 shrews Crocidura russula</h2><span id='topic+crocrussula'></span>

<h3>Description</h3>

<p>A dataset containing microsatellite genotypes, population and sex of 140 Crocidura russula individuals</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(crocrussula)
</code></pre>


<h3>References</h3>

<p><a href="https://royalsocietypublishing.org/doi/10.1098/rspb.1997.0019">Favre et al. (1997)</a> Female-biased dispersal in the monogamous mammal Crocidura russula: evidence from field data and microsatellite  patterns. Proceedings of the Royal Society, B (264):  127-132
</p>
<p><a href="https://onlinelibrary.wiley.com/doi/abs/10.1046/j.1365-294X.2002.01496.x">Goudet J, Perrin N, Waser P (2002)</a> Tests for sex-biased dispersal using bi-parentally inherited genetic markers 11, 1103:1114
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(crocrussula)
aic&lt;-AIc(crocrussula$genot)
boxplot(aic~crocrussula$sex)
sexbias.test(crocrussula$genot,crocrussula$sex)
</code></pre>

<hr>
<h2 id='diploid'>A genetic dataset from a diploid organism</h2><span id='topic+diploid'></span>

<h3>Description</h3>

<p>A simple diploid dataset, with allele encoded as one digit number
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(diploid)
</code></pre>


<h3>Format</h3>

<p>A data frame with 44 rows and 6 columns:
</p>

<dl>
<dt>Pop</dt><dd><p>Population identifier, from 1 to 6</p>
</dd>
<dt>loc-1</dt><dd><p>genotype at loc-1 (only allele 4 present)</p>
</dd>
<dt>loc-2</dt><dd><p>genotype at loc-1 (alleles 3 and 4)</p>
</dd>
<dt>loc-3</dt><dd><p>genotype at loc-1 (alleles 2, 3 and 4)</p>
</dd>
<dt>loc-4</dt><dd><p>genotype at loc-1 (alleles 1, 2, 3 and 4)</p>
</dd>
<dt>loc-5</dt><dd><p>genotype at loc-1 (only allele 4)</p>
</dd>
</dl>
<p>...

</p>


<h3>Source</h3>

<p>Given in Weir, B.S. Genetic Data Analysis. Sinauer
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(diploid)
basic.stats(diploid)

</code></pre>

<hr>
<h2 id='exhier'>Example data set with 4 levels, one diploid and one haploid locus</h2><span id='topic+exhier'></span>

<h3>Description</h3>

<p>Example data set with 4 levels, one diploid and one haploid locus</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(exhier)
</code></pre>


<h3>Value</h3>

<table>
<tr><td><code>lev1</code></td>
<td>
<p>outermost level</p>
</td></tr>
<tr><td><code>lev2</code></td>
<td>
<p>level 2</p>
</td></tr>
<tr><td><code>lev3</code></td>
<td>
<p>Level 3</p>
</td></tr>
<tr><td><code>lev4</code></td>
<td>
<p>Level 4</p>
</td></tr>
<tr><td><code>diplo</code></td>
<td>
<p>Diploid locus</p>
</td></tr>
<tr><td><code>haplo</code></td>
<td>
<p>Haploid locus</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data(exhier)
varcomp(exhier[,1:5])
varcomp(exhier[,c(1:4,6)],diploid=FALSE)

</code></pre>

<hr>
<h2 id='fs.dosage'>Estimates F-statistics from dosage data</h2><span id='topic+fs.dosage'></span><span id='topic+fst.dosage'></span><span id='topic+fis.dosage'></span><span id='topic+pairwise.fst.dosage'></span><span id='topic+plot.fs.dosage'></span><span id='topic+print.fs.dosage'></span>

<h3>Description</h3>

<p>Reports individual inbreeding coefficients, Population specific and pairwise Fsts, and Fiss from dosage data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fs.dosage(dos, pop, matching = FALSE)

## S3 method for class 'fs.dosage'
plot(x, ...)

## S3 method for class 'fs.dosage'
print(x, digits = 4, ...)

fst.dosage(dos, pop, matching = FALSE)

fis.dosage(dos, pop, matching = FALSE)

pairwise.fst.dosage(dos, pop, matching = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fs.dosage_+3A_dos">dos</code></td>
<td>
<p>either a matrix with snps columns and individuals in rows containing allelic dosage (number [0,1 or 2] of alternate alleles); 
or a square matrix with as many rows and columns as the number of individuals and containing the proportion of matching alleles</p>
</td></tr>
<tr><td><code id="fs.dosage_+3A_pop">pop</code></td>
<td>
<p>a vector containing the identifier of the population to which the individual in the corresponding row belongs</p>
</td></tr>
<tr><td><code id="fs.dosage_+3A_matching">matching</code></td>
<td>
<p>logical:TRUE if dos is a square matrix of allelic matching; FALSE otherwise</p>
</td></tr>
<tr><td><code id="fs.dosage_+3A_x">x</code></td>
<td>
<p>a fs.dosage object</p>
</td></tr>
<tr><td><code id="fs.dosage_+3A_...">...</code></td>
<td>
<p>further arguments to pass</p>
</td></tr>
<tr><td><code id="fs.dosage_+3A_digits">digits</code></td>
<td>
<p>number of digits to print</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Fi list of individual inbreeding coefficients, estimated with the reference being the population to which the individual belongs.
</p>
<p>FsM matrix containing population specific FSTs on the diagonal. The off diagonal elements contains the average of the kinships 
for pairs of individuals, one from each population, relative to the mean kinship for pairs of individuals between populations.
</p>
<p>Fst2x2 matrix containing pairwise FSTs
</p>
<p>Fs The first row contains population specific and overall Fis, the second row population specific 
(average <code class="reqn">\hat{\beta_{ST}^i}</code> over loci)  FSTs and overall Fst <code class="reqn">\hat{\beta_{ST}}</code> (see Table 3 of 
<a href="https://academic.oup.com/genetics/article/206/4/2085/6072590">Weir and Goudet, 2017 (Genetics)</a>)
</p>


<h3>Methods (by generic)</h3>


<ul>
<li> <p><code>plot</code>: Plot function for fs.dosage class
</p>
</li>
<li> <p><code>print</code>: Print function for fs.dosage class
</p>
</li></ul>


<h3>Author(s)</h3>

<p>Jerome Goudet <a href="mailto:jerome.goudet@unil.ch">jerome.goudet@unil.ch</a>
</p>
<p><a href="https://academic.oup.com/genetics/article/206/4/2085/6072590">Weir, BS and Goudet J. 2017</a> A Unified Characterization 
of Population Structure and Relatedness. Genetics (2017) 206:2085
</p>


<h3>See Also</h3>

<p><code><a href="#topic+betas">betas</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
 dos&lt;-matrix(sample(0:2,size=10000,replace=TRUE),ncol=100)
 fs.dosage(dos,pop=rep(1:5,each=20))
 plot(fs.dosage(dos,pop=rep(1:5,each=20)))

## End(Not run)

</code></pre>

<hr>
<h2 id='fstat2dos'>Converts a hierfstat genetic data frame to dosage data</h2><span id='topic+fstat2dos'></span>

<h3>Description</h3>

<p>Converts a hierfstat genetic data frame to dosage. For each allele at each locus, 
allelic dosage (number of copies of the allele) is reported. The column name is the allele 
identifier
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fstat2dos(dat,diploid=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fstat2dos_+3A_dat">dat</code></td>
<td>
<p>data frame with genetic data without the first column (population identifier)</p>
</td></tr>
<tr><td><code id="fstat2dos_+3A_diploid">diploid</code></td>
<td>
<p>whether the data set is from a diploid organism</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix with <code class="reqn">\sum_l n_l^a</code> columns (where <code class="reqn">n_l^a</code> is the number of alleles 
at locus l), as many rows as individuals, and containing the number of copies (dosage) of the 
corresponding allele
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
dat&lt;-sim.genot(nbal=5,nbloc=10)
dos&lt;-fstat2dos(dat[,-1])
dim(dos) 
wc(dat)
fst.dosage(dos,pop=dat[,1])


## End(Not run) 
</code></pre>

<hr>
<h2 id='g.stats'>Calculates likelihood-ratio G-statistic on contingency table</h2><span id='topic+g.stats'></span>

<h3>Description</h3>

<p>Calculates the likelihood ratio G-statistic on a contingency table of alleles at one locus X sampling unit. The sampling unit could be any hierarchical level</p>


<h3>Usage</h3>

<pre><code class='language-R'>g.stats(data,diploid=TRUE)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="g.stats_+3A_data">data</code></td>
<td>
<p>a two-column data frame. The first column contains the sampling unit, the second the genotypes</p>
</td></tr>
<tr><td><code id="g.stats_+3A_diploid">diploid</code></td>
<td>
<p>Whether the data are from diploid (default) organisms</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>obs</code></td>
<td>
<p>Observed contingency table</p>
</td></tr>
<tr><td><code>exp</code></td>
<td>
<p>Expected number of allelic observations</p>
</td></tr>
<tr><td><code>X.squared</code></td>
<td>
<p>The chi-squared statistics, <code class="reqn">\sum\frac{(O-E)^2}{E}</code></p>
</td></tr>
<tr><td><code>g.stats</code></td>
<td>
<p>The likelihood ratio statistics, <code class="reqn">2 \sum(O \log(\frac{O}{E}))</code></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jerome Goudet,
DEE, UNIL, 
CH-1015
Lausanne
Switzerland 
</p>
<p><a href="mailto:jerome.goudet@unil.ch">jerome.goudet@unil.ch</a>
</p>


<h3>References</h3>

<p>Goudet J., Raymond, M., DeMeeus, T. and Rousset F. (1996) Testing differentiation in diploid populations. Genetics. 144: 1933-1940
</p>
<p>Goudet J. (2005). Hierfstat, a package for R to compute and test variance components and F-statistics. Molecular Ecology Notes. 5:184-186
</p>
<p>Petit E., Balloux F. and Goudet J.(2001) Sex-biased dispersal in a migratory bat: A characterization using sex-specific demographic parameters. Evolution 55: 635-640. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+g.stats.glob">g.stats.glob</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(gtrunchier)
attach(gtrunchier)
g.stats(data.frame(Patch,L21.V))
</code></pre>

<hr>
<h2 id='g.stats.glob'>Likelihood ratio G-statistic over loci</h2><span id='topic+g.stats.glob'></span>

<h3>Description</h3>

<p>Calculates the likelihood ratio G-statistic on a contingency table of alleles at one locus X sampling unit, and sums this statistic over the loci provided. The sampling unit could be any hierarchical level (patch, locality, region,...). By default, diploid data are assumed</p>


<h3>Usage</h3>

<pre><code class='language-R'>g.stats.glob(data,diploid=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="g.stats.glob_+3A_data">data</code></td>
<td>
<p>a data frame made of <kbd>nl+1</kbd> column, <kbd>nl</kbd> being the number of loci. The first column contains the sampling unit, the others the multi-locus genotype. Only complete multi-locus genotypes are kept for calculation</p>
</td></tr>
<tr><td><code id="g.stats.glob_+3A_diploid">diploid</code></td>
<td>
<p>Whether the data are from diploid (default) organisms</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>g.stats.l</code></td>
<td>
<p>Per locus likelihood ratio statistic</p>
</td></tr>
<tr><td><code>g.stats</code></td>
<td>
<p>Overall loci likelihood ratio statistic</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jerome Goudet,
DEE, UNIL, 
CH-1015
Lausanne
Switzerland 
</p>
<p><a href="mailto:jerome.goudet@unil.ch">jerome.goudet@unil.ch</a>
</p>


<h3>References</h3>

<p>Goudet J. (2005). Hierfstat, a package for R to compute and test variance components and F-statistics. Molecular Ecology Notes. 5:184-186
</p>
<p>Goudet J., Raymond, M., DeMeeus, T. and Rousset F. (1996) Testing differentiation in diploid populations. Genetics. 144: 1933-1940
</p>
<p>Petit E., Balloux F. and Goudet J.(2001) Sex-biased dispersal in a migratory bat: A characterization using sex-specific demographic parameters. Evolution 55: 635-640. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+g.stats">g.stats</a></code>, <code><a href="#topic+samp.within">samp.within</a></code>,<code><a href="#topic+samp.between">samp.between</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(gtrunchier)
attach(gtrunchier)
nperm&lt;-99
nobs&lt;-length(Patch)
gglobs.o&lt;-vector(length=(nperm+1))
gglobs.p&lt;-vector(length=(nperm+1))
gglobs.l&lt;-vector(length=(nperm+1))

gglobs.o[nperm+1]&lt;-g.stats.glob(data.frame(Patch,gtrunchier[,-c(1,2)]))$g.stats
gglobs.p[nperm+1]&lt;-g.stats.glob(data.frame(Patch,gtrunchier[,-c(1,2)]))$g.stats
gglobs.l[nperm+1]&lt;-g.stats.glob(data.frame(Locality,gtrunchier[,-c(1,2)]))$g.stats

for (i in 1:nperm) #careful, might take a while
{
  gglobs.o[i]&lt;-g.stats.glob(data.frame(Patch,gtrunchier[sample(Patch),-c(1,2)]))$g.stats
  gglobs.p[i]&lt;-g.stats.glob(data.frame(Patch,gtrunchier[samp.within(Locality),-c(1,2)]))$g.stats
  gglobs.l[i]&lt;-g.stats.glob(data.frame(Locality,gtrunchier[samp.between(Patch),-c(1,2)]))$g.stats
}
#p-value of first test (among patches)
p.globs.o&lt;-sum(gglobs.o&gt;=gglobs.o[nperm+1])/(nperm+1) 

#p-value of second test (among patches within localities)
p.globs.p&lt;-sum(gglobs.p&gt;=gglobs.p[nperm+1])/(nperm+1) 

#p-value of third test (among localities)
p.globs.l&lt;-sum(gglobs.l&gt;=gglobs.l[nperm+1])/(nperm+1) 


#Are alleles associated at random among patches
p.globs.o 

#Are alleles associated at random among patches within localities?
#Tests differentiation among patches within localities
p.globs.p 

#Are alleles associated at random among localities, keeping patches as one unit?
#Tests differentiation among localities
p.globs.l 

## End(Not run)
</code></pre>

<hr>
<h2 id='genet.dist'>Classical genetic distances estimation</h2><span id='topic+genet.dist'></span>

<h3>Description</h3>

<p>Estimates one of several genetic distances among all pairs of populations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>genet.dist(dat,diploid=TRUE,method="Dch")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="genet.dist_+3A_dat">dat</code></td>
<td>
<p>A data frame containing population of origin as the first column and multi-locus genotypes in following columns</p>
</td></tr>
<tr><td><code id="genet.dist_+3A_diploid">diploid</code></td>
<td>
<p>whether the data is from a diploid (default) or haploid organism.</p>
</td></tr>
<tr><td><code id="genet.dist_+3A_method">method</code></td>
<td>
<p>One of &ldquo;Dch&rdquo;,&ldquo;Da&rdquo;,&ldquo;Ds&rdquo;,&ldquo;Fst&rdquo;,&ldquo;Dm&rdquo;,&ldquo;Dr&rdquo;,&ldquo;Cp&rdquo; or &ldquo;X2&rdquo;, all described in Takezaki and Nei (1996). Additionally &ldquo;Nei87&rdquo; and &ldquo;WC84&rdquo; return pairwise FSTs estimated following Nei (1987) <a href="#topic+pairwise.neifst">pairwise.neifst</a> and Weir &amp; Cockerham (1984) <a href="#topic+pp.fst">pp.fst</a> respectively</p>
</td></tr>
</table>


<h3>Details</h3>

<p>the method argument specify which genetic distance to use, among eight, all briefly described in Takezaki and Nei (1996)
</p>
<p>&ldquo;Dch&rdquo; By default, Cavalli-Sforza and Edwards Chord distance (eqn 6 in the reference) is returned. 
This distance is used as default since Takezaki &amp; Nei (1996) found that it was the best to retrieve the relation among samples.
</p>
<p>&ldquo;Da&rdquo; This is Nei's et al genetic distance (eqn 7), performing nearly as well as &ldquo;Dch&rdquo;
</p>
<p>&ldquo;Ds&rdquo; Nei's standard genetic distance (eqn 1). Increases linearly with diverence time but has larger variance 
</p>
<p>&ldquo;Fst&rdquo; Latter's and also approximately Reynolds et al Genetic distance (eqn 3)
</p>
<p>&ldquo;Dm&rdquo; Nei's minimum distance (eqn 2)
</p>
<p>&ldquo;Dr&rdquo; Rogers's distance (eqn 4)
</p>
<p>&ldquo;Cp&rdquo; Prevosti et al's distance (eqn 5)
</p>
<p>&ldquo;X2&rdquo; Sanghvi's distance (eqn 8) 
</p>
<p>&ldquo;Nei87&rdquo; see <a href="#topic+pairwise.neifst">pairwise.neifst</a>
</p>
<p>&ldquo;WC84&rdquo;  see <a href="#topic+pairwise.WCfst">pairwise.WCfst</a>
</p>


<h3>Value</h3>

<p>A matrix of pairwise genetic distance
</p>


<h3>Author(s)</h3>

<p>Jerome Goudet <a href="mailto:jerome.goudet@unil.ch">jerome.goudet@unil.ch</a></p>


<h3>References</h3>

<p><a href="https://academic.oup.com/genetics/article/144/1/389/6016981">Takezaki &amp; Nei (1996)</a> Genetic distances and reconstruction of Phylogenetic trees from microsatellite DNA. Genetics 144:389-399
</p>
<p>Nei, M. (1987) Molecular Evolutionary Genetics. Columbia University Press
</p>
<p><a href="https://onlinelibrary.wiley.com/doi/10.1111/j.1558-5646.1984.tb05657.x">Weir B.S. and Cockerham C.C. (1984)</a> Estimating F-Statistics for the Analysis of Population Structure. Evolution 38:1358
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pairwise.WCfst">pairwise.WCfst</a></code> <code><a href="#topic+pairwise.neifst">pairwise.neifst</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(gtrunchier)
genet.dist(gtrunchier[,-1])
genet.dist(gtrunchier[,-1],method="Dr")
</code></pre>

<hr>
<h2 id='genind2hierfstat'>Converts genind objects from adegenet into a hierfstat data frame</h2><span id='topic+genind2hierfstat'></span>

<h3>Description</h3>

<p>Converts genind objects from adegenet into a hierfstat data frame
</p>


<h3>Usage</h3>

<pre><code class='language-R'>genind2hierfstat(dat,pop=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="genind2hierfstat_+3A_dat">dat</code></td>
<td>
<p>a genind object</p>
</td></tr>
<tr><td><code id="genind2hierfstat_+3A_pop">pop</code></td>
<td>
<p>a vector containing the population to which each individual belongs. 
If pop=NULL, pop taken from slot pop of the genind object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data frame with nloci+1 columns and ninds rows.  The first column
contains the population identifier, the following the genotypes at each locus
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
library(adegenet)
data(nancycats)
genind2hierfstat(nancycats)
basic.stats(nancycats)
genet.dist(nancycats)
data(H3N2)
basic.stats(genind2hierfstat(H3N2,pop=rep(1,dim(H3N2@tab)[1])),diploid=FALSE)

## End(Not run)

</code></pre>

<hr>
<h2 id='genot2al'>Separates diploid genotypes in its constituant alleles</h2><span id='topic+genot2al'></span>

<h3>Description</h3>

<p>Separates the input vector of diploid genotypes in two vectors each containing one allele, and returns a vector of length <kbd>2*length(y)</kbd> with the second part being the second allele
</p>


<h3>Usage</h3>

<pre><code class='language-R'>genot2al(y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="genot2al_+3A_y">y</code></td>
<td>
<p>the diploid genotypes at one locus</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns a vector of length <kbd>2*length(y)</kbd>, with the second half of the vector containing the second alleles</p>


<h3>Author(s)</h3>

<p>Jerome Goudet,
DEE, UNIL, 
CH-1015
Lausanne
Switzerland 
</p>
<p><a href="mailto:jerome.goudet@unil.ch">jerome.goudet@unil.ch</a>
</p>


<h3>References</h3>

<p>Goudet J. (2004). A library for R to compute and test variance components and F-statistics. In Prep
</p>


<h3>See Also</h3>

<p><code><a href="#topic+varcomp">varcomp</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(gtrunchier)
genot2al(gtrunchier[,4])
</code></pre>

<hr>
<h2 id='getal'>Converts diploid genotypic data into allelic data</h2><span id='topic+getal'></span>

<h3>Description</h3>

<p>Converts diploid genotypic data into allelic data</p>


<h3>Usage</h3>

<pre><code class='language-R'>getal(data)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getal_+3A_data">data</code></td>
<td>
<p>a data frame where the first column contains the population to which the different individuals belong, and the following columns contain the genotype of the individuals -one locus per column- </p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>data.al</code></td>
<td>
<p>a new data frame, with twice as many row as the input data frame and one extra column. each row of the first half of the data frame contains the first allele for each locus, and each row of the second half of the data frame contains the second allel at the locus. The extra column in second position corresponds to the identifier of the individual to which the allele belongs</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jerome Goudet <a href="mailto:jerome.goudet@unil.ch">jerome.goudet@unil.ch</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(gtrunchier)
getal(data.frame(gtrunchier[,-2]))
</code></pre>

<hr>
<h2 id='getal.b'>Converts diploid genotypic data into allelic data</h2><span id='topic+getal.b'></span>

<h3>Description</h3>

<p>Converts a data frame of genotypic diploid data with as many lines as
individuals (ni) and as many columns as loci (nl) into an array [ni,nl,2] of allelic data</p>


<h3>Usage</h3>

<pre><code class='language-R'>getal.b(data)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getal.b_+3A_data">data</code></td>
<td>
<p>a data frame with ni rows and nl columns. Each line encodes one individual, each column contains the genotype at one locus of the individual</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an array [ni,nl,2] of alleles. The two alleles are stored in the third dimension of the array
</p>


<h3>Author(s)</h3>

<p>Jerome Goudet <a href="mailto:jerome.goudet@unil.ch">jerome.goudet@unil.ch</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(gtrunchier)
#multilocus diploid genotype of the first individual
gtrunchier[1,-c(1:2)]
#the diploid genotype splitted in its two constituent alleles
getal.b(gtrunchier[,-c(1:2)])[1,,]
</code></pre>

<hr>
<h2 id='grm2kinship'>Converts a Genetic Relationship Matrix (GRM) to a kinship matrix</h2><span id='topic+grm2kinship'></span>

<h3>Description</h3>

<p>Converts a Genetic Relationship Matrix (GRM) to a kinship matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grm2kinship(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="grm2kinship_+3A_x">x</code></td>
<td>
<p>a square (GRM) matrix</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code class="reqn">k[ii]=x[ii]-1; k[ij]=x[ij]/2</code>
</p>


<h3>Value</h3>

<p>a kinship matrix
</p>


<h3>Author(s)</h3>

<p>Jerome Goudet <a href="mailto:jerome.goudet@unil.ch">jerome.goudet@unil.ch</a>
</p>

<hr>
<h2 id='gtrunchier'>Genotypes at 6 microsatellite loci of Galba truncatula from different patches in Western Switzerland</h2><span id='topic+gtrunchier'></span>

<h3>Description</h3>

<p>Data set consisting of the microsatellite genotypes of 370 Galba truncatula, a tiny freshwater snail, collecting from different localities and several patches within localities in Western Switzerland.</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(gtrunchier)
</code></pre>


<h3>Value</h3>

<table>
<tr><td><code>Locality</code></td>
<td>
<p>Identifier of the locality of origin</p>
</td></tr>
<tr><td><code>Patch</code></td>
<td>
<p>Identifier of the patch of origin</p>
</td></tr>
<tr><td><code>L21.V</code></td>
<td>
<p>Genotype at locus L21.V. For instance the first individual carries allele 2 and 2 at this locus </p>
<pre>gtrunchier\$L21.V[1]</pre></td></tr>
<tr><td><code>L37.J</code></td>
<td>
<p>Genotype at locus L37.J</p>
</td></tr>
<tr><td><code>L20.B</code></td>
<td>
<p>Genotype at locus L20.B</p>
</td></tr>
<tr><td><code>L29.V</code></td>
<td>
<p>Genotype at locus L29.V</p>
</td></tr>
<tr><td><code>L36.B</code></td>
<td>
<p>Genotype at locus L36.B</p>
</td></tr>
<tr><td><code>L16.J</code></td>
<td>
<p>Genotype at locus L16.J</p>
</td></tr>
</table>


<h3>References</h3>

<p>Trouve S., L. Degen et al. (2000) Microsatellites in the hermaphroditic snail, Lymnaea truncatula, intermediate host of the liver fluke, Fasciola hepatica.Molecular Ecology 9: 1662-1664.
</p>
<p>Trouve S., Degen L. and Goudet J. (2005) Ecological components and evolution of selfing in the freshwater snail Galba truncatula. Journal of Evolutionary Biology. 18, 358-370
</p>

<hr>
<h2 id='hierfstat'>General information on the hierfstat package</h2><span id='topic+hierfstat'></span>

<h3>Description</h3>

<p>This package contains functions to estimate hierarchical F-statistics for any number of hierarchical levels using the method described in Yang (1998).  It also contains functions allowing to test the significance of population differentiation at any given level using the likelihood ratio G-statistic, showed previoulsly to be the most powerful statistic to test for differnetiation (Goudet et al., 1996) . The difficulty in a hierarchical design is to identify which units should be permutted. Functions <kbd>samp.within</kbd> and <kbd>samp.between</kbd> give permutations of a sequence that allows reordering of the observations in the original data frame. An exemple of application is given in the help page for function <kbd>g.stats.glob</kbd>. 
</p>
<p>Hierfstat includes now all the capabilities of Fstat, and many others.  A new serie of functions implementing the statistics described in Weir and Goudet (2017) and Goudet et al. (2018)  (<kbd>beta.dosage, fs.dosage</kbd>) have been written to deal with large genomic data sets and take as input a matrix of allelic dosages, the number of alternate alleles an individual carries at a locus. 
</p>
<p>Several functions have been written to simulate genetic data, or to import them from existing sofwares such as <kbd>quantiNemo</kbd> or Hudson's <kbd>ms</kbd>
</p>
<p><kbd>Hierfstat</kbd> links easily with the <kbd>gaston, SNPRelate</kbd> and <kbd>adegenet</kbd> packages, among others.  
</p>


<h3>Author(s)</h3>

<p>Jerome Goudet <a href="mailto:jerome.goudet@unil.ch">jerome.goudet@unil.ch</a></p>


<h3>References</h3>

<p><a href="https://www2.unil.ch/popgen/research/reprints/goudet_men_2005.pdf">Goudet J. (2005)</a> Hierfstat, a package for R to compute and test variance components and F-statistics. Molecular Ecology Notes. 5:184-186
</p>
<p><a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC1207740/pdf/ge14441933.pdf">Goudet J., Raymond, M., DeMeeus, T. and Rousset F. (1996)</a> Testing differentiation in diploid populations. Genetics. 144: 1933-1940 
</p>
<p><a href="https://academic.oup.com/genetics/article/206/4/2085/6072590">Weir B.S. and Goudet J. (2017)</a> A Unified Characterization of Population Structure and Relatedness. Genetics. 206: 2085-2103
</p>
<p><a href="https://onlinelibrary.wiley.com/doi/full/10.1111/mec.14833">Goudet J., Kay T. and Weir B.S. (2018)</a> How to estimate kinship. Molecular Ecology.  27: 4121:4135
</p>
<p>Weir, B.S. (1996) Genetic Data Analysis II. Sinauer Associates.
</p>
<p><a href="https://onlinelibrary.wiley.com/doi/abs/10.1111/j.1558-5646.1998.tb01824.x">Yang, R.C. (1998)</a> Estimating hierarchical F-statistics. Evolution 52(4):950-956
</p>

<hr>
<h2 id='ind.count'>individual counts</h2><span id='topic+ind.count'></span>

<h3>Description</h3>

<p>Counts the number of individual genotyped per locus and population</p>


<h3>Usage</h3>

<pre><code class='language-R'>ind.count(data)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ind.count_+3A_data">data</code></td>
<td>
<p>a data frame containing the population of origin in the first column and the genotypes in the following ones</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A table &ndash;with np (number of populations) columns and nl (number of loci) rows&ndash; of genotype counts
</p>


<h3>Author(s)</h3>

<p>Jerome Goudet <a href="mailto:jerome.goudet@unil.ch">jerome.goudet@unil.ch</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(gtrunchier)
ind.count(gtrunchier[,-2])
</code></pre>

<hr>
<h2 id='indpca'>PCA on a matrix of individuals genotypes frequencies</h2><span id='topic+indpca'></span><span id='topic+print.indpca'></span><span id='topic+plot.indpca'></span>

<h3>Description</h3>

<p>Carry out a PCA on the centered, unscaled matrix of individual's allele frequencies.</p>


<h3>Usage</h3>

<pre><code class='language-R'>indpca(dat,ind.labels=NULL,scale=FALSE)

## S3 method for class 'indpca'
print(x,...)
## S3 method for class 'indpca'
plot(x,eigen=FALSE,ax1=1,ax2=2,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="indpca_+3A_dat">dat</code></td>
<td>
<p>A data frame with population of origin as first column, and genotypes in following columns.</p>
</td></tr>
<tr><td><code id="indpca_+3A_ind.labels">ind.labels</code></td>
<td>
<p>a vector of labels for the different individuals</p>
</td></tr>
<tr><td><code id="indpca_+3A_scale">scale</code></td>
<td>
<p>whether to standardize each column to variance 1 or to leave it as is (default)</p>
</td></tr>
<tr><td><code id="indpca_+3A_x">x</code></td>
<td>
<p>an indpca object</p>
</td></tr>
<tr><td><code id="indpca_+3A_eigen">eigen</code></td>
<td>
<p>whether to plot in an additional windows screeplot of the inertias for the different axes</p>
</td></tr>
<tr><td><code id="indpca_+3A_ax1">ax1</code></td>
<td>
<p>which PCA coordinates to plot on the x axis</p>
</td></tr>
<tr><td><code id="indpca_+3A_ax2">ax2</code></td>
<td>
<p>which PCA coordinates to plot on the y axis</p>
</td></tr>
<tr><td><code id="indpca_+3A_...">...</code></td>
<td>
<p>further arguments to pass to print or plot</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>indpca</code> with components
</p>
<table>
<tr><td><code>call</code></td>
<td>
<p>The function call</p>
</td></tr>
<tr><td><code>ipca</code></td>
<td>
<p>an object of class pca and dudi (see dudi.pca) in package ade4</p>
</td></tr>
<tr><td><code>mati</code></td>
<td>
<p>the original non centered matrice of individuals X alleles frequencies </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jerome Goudet <a href="mailto:jerome.goudet@unil.ch">jerome.goudet@unil.ch</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>##not run
data(gtrunchier)
x&lt;-indpca(gtrunchier[,-2],ind.labels=gtrunchier[,2])
plot(x,col=gtrunchier[,1],cex=0.7)
</code></pre>

<hr>
<h2 id='kinship2dist'>Converts a kinship matrix to a distance matrix</h2><span id='topic+kinship2dist'></span>

<h3>Description</h3>

<p>Converts a kinship matrix to a distance matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kinship2dist(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kinship2dist_+3A_x">x</code></td>
<td>
<p>A square matrix containg kinship coefficients</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code class="reqn">D_{ii}=0, D_{ij}=\frac{1-(x-min(x))}{(1-min(x))}</code>
</p>


<h3>Value</h3>

<p>A distance matrix
</p>


<h3>Author(s)</h3>

<p>Jerome Goudet <a href="mailto:jerome.goudet@unil.ch">jerome.goudet@unil.ch</a>
</p>

<hr>
<h2 id='kinship2grm'>Converts a kinship matrix to a Genetic Relation Matrix (GRM)</h2><span id='topic+kinship2grm'></span>

<h3>Description</h3>

<p>Converts a kinship matrix to a Genetic Relation Matrix (GRM)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kinship2grm(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kinship2grm_+3A_x">x</code></td>
<td>
<p>a square matrix containing kinship coefficients</p>
</td></tr>
</table>


<h3>Details</h3>

<p>for off-diagonal elements, <code class="reqn">GRM=2 \times x_{ij}</code>; for diagonal elements, <code class="reqn">GRM=1+ x_{ii}</code>
</p>


<h3>Value</h3>

<p>a GRM matrix
</p>


<h3>Author(s)</h3>

<p>Jerome Goudet <a href="mailto:jerome.goudet@unil.ch">jerome.goudet@unil.ch</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
dos&lt;-matrix(sample(0:2,replace=TRUE,size=1000),nrow=10) #dosage matrix for 10 inds at 100 loci
ks&lt;-beta.dosage(dos) # kinship matrix
kinship2grm(ks)

## End(Not run)  
</code></pre>

<hr>
<h2 id='kinshipShift'>Shifts a kinship matrix</h2><span id='topic+kinshipShift'></span>

<h3>Description</h3>

<p>Shifts a kinship matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kinshipShift(x,shift=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kinshipShift_+3A_x">x</code></td>
<td>
<p>a square matrix</p>
</td></tr>
<tr><td><code id="kinshipShift_+3A_shift">shift</code></td>
<td>
<p>the amount by which the elements of x should be shifted. if <code>shift==NULL</code>, 
the average of the off-diagonal elements is substracted</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The kinship matrix produced by <code>beta.dosage</code> is relative to the average kinship
of the set of individuals analysed (<code class="reqn">1/(n(n-1)/2) \sum_i \sum_{j&gt;i} x_{ij}=0</code>). 
Another reference point might be useful, for instance to avoid negative kinship values, one might
want to shift the matrix by <code class="reqn">min(x_{ij}), i \neq j</code>.
</p>


<h3>Value</h3>

<p>the shifted kinship matrix <code class="reqn">\frac{x-shift}{1-shift}</code>
</p>


<h3>Author(s)</h3>

<p>Jerome Goudet <a href="mailto:jerome.goudet@unil.ch">jerome.goudet@unil.ch</a>
</p>

<hr>
<h2 id='mat2vec'>Creates a vector from a matrix</h2><span id='topic+mat2vec'></span>

<h3>Description</h3>

<p>creates a vector from a matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mat2vec(mat,upper=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mat2vec_+3A_mat">mat</code></td>
<td>
<p>a symmetric matrix</p>
</td></tr>
<tr><td><code id="mat2vec_+3A_upper">upper</code></td>
<td>
<p>whether the upper triangular matrix is to be copied to the vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'>{

 mat2vec(matrix(1:16,nrow=4))
 mat2vec(matrix(1:16,nrow=4),upper=TRUE)
}
</code></pre>

<hr>
<h2 id='matching'>Estimates matching between pairs of individuals</h2><span id='topic+matching'></span>

<h3>Description</h3>

<p>Estimates matching between pairs of individuals (for each locus, gives 1 if the two individuals are homozygous
for the same allele, 0 if they are homozygous for a different allele, and 1/2 if at least one individual 
is heterozygous. Matching is the average of these 0, 1/2 and 1s)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>matching(dos)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="matching_+3A_dos">dos</code></td>
<td>
<p>A matrix of 0, 1 and 2s with loci (SNPs) in columns and individuals in rows. 
missing values are allowed</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is written for dosage data, i.e., how many doses of an allele (0, 1 or 2) an individual carries.
It should be use for bi-allelic markers only (e.g. SNPs), although you might &quot;force&quot; a k multiallelic locus to k 
biallelic loci (see <code><a href="#topic+fstat2dos">fstat2dos</a></code>).
</p>


<h3>Value</h3>

<p>a matrix of pairwise matching
</p>

<hr>
<h2 id='ms2bed'>Import the output of the <code>ms</code> program in a <code>BED</code> object</h2><span id='topic+ms2bed'></span>

<h3>Description</h3>

<p>Import the output of the <code>ms</code> program into a <code>BED</code> object, as defined in the 
<a href="https://cran.r-project.org/package=gaston">gaston</a> package
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ms2bed(fname)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ms2bed_+3A_fname">fname</code></td>
<td>
<p>the name of the text file containing <code>ms</code> output</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a bed object
</p>

<hr>
<h2 id='ms2dos'>Import <code>ms</code> output</h2><span id='topic+ms2dos'></span>

<h3>Description</h3>

<p>Import the output of the <code>ms</code> program into suitable format for further manipulation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ms2dos(fname)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ms2dos_+3A_fname">fname</code></td>
<td>
<p>a text file containing the output of the <code>ms program</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>alldat a matrix with as many row as (haploid) individuals and as many columns as SNPs
</p>
<p>bim a data frame with two components
chr contains the chromosome (replicate) id; pos contains the SNPs posoition on the chromosome
</p>

<hr>
<h2 id='nb.alleles'>Number of different alleles</h2><span id='topic+nb.alleles'></span>

<h3>Description</h3>

<p>Counts the number of different alleles at each locus and population</p>


<h3>Usage</h3>

<pre><code class='language-R'>nb.alleles(data,diploid=TRUE)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nb.alleles_+3A_data">data</code></td>
<td>
<p>A data frame containing the population of origin in the first column and the genotypes in the following ones</p>
</td></tr>
<tr><td><code id="nb.alleles_+3A_diploid">diploid</code></td>
<td>
<p>whether individuals are diploid</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A table, &ndash;with np (number of populations) columns and nl (number of loci) rows&ndash; of the number of different alleles
</p>


<h3>Author(s)</h3>

<p>Jerome Goudet <a href="mailto:jerome.goudet@unil.ch">jerome.goudet@unil.ch</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(gtrunchier)
nb.alleles(gtrunchier[,-2])
</code></pre>

<hr>
<h2 id='pairwise.betas'>Estimates pairwise betas according to Weir and Goudet (2017)</h2><span id='topic+pairwise.betas'></span>

<h3>Description</h3>

<p>Estimates pairwise betas according to Weir and Goudet (2017)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pairwise.betas(dat,diploid=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pairwise.betas_+3A_dat">dat</code></td>
<td>
<p>A data frame containing population of origin as the first column 
and multi-locus genotypes in following columns</p>
</td></tr>
<tr><td><code id="pairwise.betas_+3A_diploid">diploid</code></td>
<td>
<p>whether the data is from a diploid (default) or haploid organism</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix of pairwise betas
</p>


<h3>Author(s)</h3>

<p>Jerome Goudet <a href="mailto:jerome.goudet@unil.ch">jerome.goudet@unil.ch</a>
</p>
<p><a href="https://academic.oup.com/genetics/article/206/4/2085/6072590">Weir, BS and Goudet J. 2017</a> A Unified Characterization 
of Population Structure and Relatedness. Genetics (2017) 206:2085
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(gtrunchier)
pairwise.betas(gtrunchier[,-2],diploid=TRUE)

</code></pre>

<hr>
<h2 id='pairwise.neifst'>Estimates pairwise FSTs according to Nei (1987)</h2><span id='topic+pairwise.neifst'></span>

<h3>Description</h3>

<p>Estimate pairwise FSTs according to Nei (1987)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pairwise.neifst(dat,diploid=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pairwise.neifst_+3A_dat">dat</code></td>
<td>
<p>A data frame containing population of origin as the first column and 
multi-locus genotypes in following columns</p>
</td></tr>
<tr><td><code id="pairwise.neifst_+3A_diploid">diploid</code></td>
<td>
<p>whether the data is from a diploid (default) or haploid organism</p>
</td></tr>
</table>


<h3>Details</h3>

<p>FST are calculated using Nei (87) equations for FST', as described in the note 
section of  <a href="#topic+basic.stats">basic.stats</a>
</p>


<h3>Value</h3>

<p>A matrix of pairwise FSTs
</p>


<h3>Author(s)</h3>

<p>Jerome Goudet <a href="mailto:jerome.goudet@unil.ch">jerome.goudet@unil.ch</a>
</p>


<h3>References</h3>

<p>Nei, M. (1987) Molecular Evolutionary Genetics. Columbia University Press
</p>


<h3>See Also</h3>

<p><a href="#topic+pairwise.WCfst">pairwise.WCfst</a> <a href="#topic+genet.dist">genet.dist</a> <a href="#topic+basic.stats">basic.stats</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(gtrunchier)
pairwise.neifst(gtrunchier[,-2],diploid=TRUE)

</code></pre>

<hr>
<h2 id='pairwise.WCfst'>Estimates pairwise FSTs according to Weir and Cockerham (1984)</h2><span id='topic+pairwise.WCfst'></span>

<h3>Description</h3>

<p>Estimates pairwise FSTs according to Weir and Cockerham (1984)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pairwise.WCfst(dat,diploid=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pairwise.WCfst_+3A_dat">dat</code></td>
<td>
<p>A data frame containing population of origin as the first column 
and multi-locus genotypes in following columns</p>
</td></tr>
<tr><td><code id="pairwise.WCfst_+3A_diploid">diploid</code></td>
<td>
<p>whether the data is from a diploid (default) or haploid organism</p>
</td></tr>
</table>


<h3>Details</h3>

<p>FST are calculated using Weir &amp; Cockerham (1984) equations for FST', as described in the note section of  <a href="#topic+wc">wc</a>
</p>


<h3>Value</h3>

<p>A matrix of pairwise FSTs
</p>


<h3>Author(s)</h3>

<p>Jerome Goudet <a href="mailto:jerome.goudet@unil.ch">jerome.goudet@unil.ch</a>
</p>


<h3>References</h3>

<p>Weir, B.S. (1996) Genetic Data Analysis II. Sinauer Associates.
</p>
<p><a href="https://onlinelibrary.wiley.com/doi/10.1111/j.1558-5646.1984.tb05657.x">Weir B.S. and Cockerham C.C. (1984)</a> Estimating F-Statistics for the Analysis of Population Structure. Evolution 38:1358
</p>


<h3>See Also</h3>

<p><a href="#topic+pairwise.neifst">pairwise.neifst</a> <a href="#topic+genet.dist">genet.dist</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(gtrunchier)
pairwise.WCfst(gtrunchier[,-2],diploid=TRUE)

</code></pre>

<hr>
<h2 id='pcoa'>Principal coordinate analysis</h2><span id='topic+pcoa'></span>

<h3>Description</h3>

<p>principal coordinates analysis as described in Legendre &amp; Legendre Numerical Ecology</p>


<h3>Usage</h3>

<pre><code class='language-R'>pcoa(mat,plotit=TRUE,...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pcoa_+3A_mat">mat</code></td>
<td>
<p>a distance matrix</p>
</td></tr>
<tr><td><code id="pcoa_+3A_plotit">plotit</code></td>
<td>
<p>Whether to produce a plot of the pcoa</p>
</td></tr>
<tr><td><code id="pcoa_+3A_...">...</code></td>
<td>
<p>further arguments (graphical for instance) to pass to the function</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>valp</code></td>
<td>
<p>the eigen values of the pcoa</p>
</td></tr>
<tr><td><code>vecp</code></td>
<td>
<p>the eigen vectors of the pcoa (the coordinates of observations)</p>
</td></tr>
<tr><td><code>eucl</code></td>
<td>
<p>The cumulative euclidian distances among observations, </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jerome Goudet <a href="mailto:jerome.goudet@unil.ch">jerome.goudet@unil.ch</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(gtrunchier)
colo&lt;-c("black","red","blue","yellow","orange","green")
pcoa(as.matrix(genet.dist(gtrunchier[,-1])),col=rep(colo,c(5,5,4,5,5,5)))
</code></pre>

<hr>
<h2 id='pi.dosage'>Estimates nucleotide diversity (<code class="reqn">\pi</code>) from dosage data</h2><span id='topic+pi.dosage'></span>

<h3>Description</h3>

<p>Estimates nucleotide diversity <code class="reqn">\pi= \sum_l 2 p_ l(1-p_l) 2n/(2n-1)</code> from a
dosage matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pi.dosage(dos,L=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pi.dosage_+3A_dos">dos</code></td>
<td>
<p>a ni X nl dosage matrix containing the number of derived/alternate alleles each individual carries
at each SNP</p>
</td></tr>
<tr><td><code id="pi.dosage_+3A_l">L</code></td>
<td>
<p>the length of the sequence</p>
</td></tr>
</table>


<h3>Value</h3>

<p>if <code>L=NULL</code> (default), returns the sum over SNPs of nucleotide diversity; 
otherwise return the average nucleotide diversity per nucleotide given the length <code>L</code> of the sequence
</p>

<hr>
<h2 id='pop.freq'>Allelic frequencies</h2><span id='topic+pop.freq'></span>

<h3>Description</h3>

<p>Estimates allelic frequencies for each population and locus</p>


<h3>Usage</h3>

<pre><code class='language-R'>pop.freq(dat,diploid=TRUE)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pop.freq_+3A_dat">dat</code></td>
<td>
<p>a data frame where the first column contains the population to which the different individuals belong, and the following columns contain the genotype of the individuals -one locus per column- </p>
</td></tr>
<tr><td><code id="pop.freq_+3A_diploid">diploid</code></td>
<td>
<p>specify whether the data set consists of diploid (default) or haploid data</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing allele frequencies. Each element of the list is one locus.
For each locus, Populations are in columns and alleles in rows
</p>


<h3>Author(s)</h3>

<p>Jerome Goudet <a href="mailto:jerome.goudet@unil.ch">jerome.goudet@unil.ch</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(gtrunchier)
pop.freq(gtrunchier[,-2])
</code></pre>

<hr>
<h2 id='pp.fst'>fst per pair</h2><span id='topic+pp.fst'></span>

<h3>Description</h3>

<p>fst per pair following Weir and Cockerham (1984)</p>


<h3>Usage</h3>

<pre><code class='language-R'>pp.fst(dat=dat,diploid=TRUE,...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pp.fst_+3A_dat">dat</code></td>
<td>
<p>a genetic data frame</p>
</td></tr>
<tr><td><code id="pp.fst_+3A_diploid">diploid</code></td>
<td>
<p>whether data from diploid organism</p>
</td></tr>
<tr><td><code id="pp.fst_+3A_...">...</code></td>
<td>
<p>further arguments to pass to the function</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>call</code></td>
<td>
<p>function call</p>
</td></tr>
<tr><td><code>fst.pp</code></td>
<td>
<p>pairwise Fsts</p>
</td></tr>
<tr><td><code>vc.per.loc</code></td>
<td>
<p>for each pair of population, the variance components per locus</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jerome Goudet <a href="mailto:jerome.goudet@unil.ch">jerome.goudet@unil.ch</a></p>


<h3>References</h3>

<p><a href="https://onlinelibrary.wiley.com/doi/10.1111/j.1558-5646.1984.tb05657.x">Weir B.S. and Cockerham C.C. (1984)</a> Estimating F-Statistics for the Analysis of Population Structure. Evolution 38:1358
</p>
<p>Weir, B.S. (1996) Genetic Data Analysis II. Sinauer Associates.
</p>

<hr>
<h2 id='pp.sigma.loc'>wrapper to return per locus variance components</h2><span id='topic+pp.sigma.loc'></span>

<h3>Description</h3>

<p>wrapper to return per locus variance components between pairs of samples x &amp; y</p>


<h3>Usage</h3>

<pre><code class='language-R'>pp.sigma.loc(x,y,dat=dat,diploid=TRUE,...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pp.sigma.loc_+3A_x">x</code>, <code id="pp.sigma.loc_+3A_y">y</code></td>
<td>
<p>samples 1 and 2</p>
</td></tr>
<tr><td><code id="pp.sigma.loc_+3A_dat">dat</code></td>
<td>
<p>a genetic data set</p>
</td></tr>
<tr><td><code id="pp.sigma.loc_+3A_diploid">diploid</code></td>
<td>
<p>whether dats are diploid</p>
</td></tr>
<tr><td><code id="pp.sigma.loc_+3A_...">...</code></td>
<td>
<p>further arguments to pass to the function</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>sigma.loc</code></td>
<td>
<p>variance components per locus</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jerome Goudet <a href="mailto:jerome.goudet@unil.ch">jerome.goudet@unil.ch</a></p>

<hr>
<h2 id='print.pp.fst'>print function for pp.fst</h2><span id='topic+print.pp.fst'></span>

<h3>Description</h3>

<p>print function for pp.fst</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'pp.fst'
print(x,...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.pp.fst_+3A_x">x</code></td>
<td>
<p>an object of class <kbd>pp.fst</kbd></p>
</td></tr>
<tr><td><code id="print.pp.fst_+3A_...">...</code></td>
<td>
<p>further arguments to pass to the function</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jerome Goudet <a href="mailto:jerome.goudet@unil.ch">jerome.goudet@unil.ch</a></p>

<hr>
<h2 id='qn2.read.fstat'>Read QuantiNemo extended format for genotype files
Read QuantiNemo (<a href="http://www2.unil.ch/popgen/softwares/quantinemo/">http://www2.unil.ch/popgen/softwares/quantinemo/</a>) genotype files extended format (option 2)</h2><span id='topic+qn2.read.fstat'></span>

<h3>Description</h3>

<p>Read QuantiNemo extended format for genotype files
</p>
<p>Read QuantiNemo (<a href="http://www2.unil.ch/popgen/softwares/quantinemo/">http://www2.unil.ch/popgen/softwares/quantinemo/</a>) genotype files extended format (option 2)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qn2.read.fstat(fname, na.s = c("NA","NaN"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="qn2.read.fstat_+3A_fname">fname</code></td>
<td>
<p>quantinemo file name</p>
</td></tr>
<tr><td><code id="qn2.read.fstat_+3A_na.s">na.s</code></td>
<td>
<p>na string used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>dat  a data frame with nloc+1 columns, the first being the population
to which the individual belongs and the next being the genotypes, one column per locus; 
and ninds rows
</p>
<p>sex  the sex of the individuals
</p>


<h3>Author(s)</h3>

<p>Jerome Goudet <a href="mailto:jerome.goudet@unil.ch">jerome.goudet@unil.ch</a>
</p>


<h3>References</h3>

<p><a href="https://pubmed.ncbi.nlm.nih.gov/30816926/">Neuenschwander S, Michaud F, Goudet J (2019)</a> 
QuantiNemo 2: a Swiss knife to simulate complex demographic and genetic scenarios, 
forward and backward in time. Bioinformatics 35:886
</p>
<p><a href="https://academic.oup.com/bioinformatics/article/24/13/1552/237901">Neuenschwander S, Hospital F, Guillaume F, Goudet J (2008)</a> 
quantiNEMO: an individual-based program to simulate quantitative traits with explicit 
genetic architecture in a dynamic metapopulation. Bioinformatics 24:1552
</p>


<h3>See Also</h3>

<p><code><a href="#topic+read.fstat">read.fstat</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  dat&lt;-qn2.read.fstat(system.file("extdata","qn2_sex.dat",package="hierfstat"))
  sexbias.test(dat[[1]],sex=dat[[2]])
</code></pre>

<hr>
<h2 id='read.fstat'>Reads data from a FSTAT file</h2><span id='topic+read.fstat'></span>

<h3>Description</h3>

<p>Imports a <em>FSTAT</em> data file into R.
The data frame created is made of <kbd>nl+1</kbd> columns, <kbd>nl</kbd> being the number of loci.
The first column corresponds to the Population identifier,
the following columns contains the genotypes of the individuals.</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.fstat(fname, na.s = c("0","00","000","0000","00000","000000","NA"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read.fstat_+3A_fname">fname</code></td>
<td>
<p>a file in the FSTAT format (<a href="http://www.unil.ch/popgen/softwares/fstat.htm">http://www.unil.ch/popgen/softwares/fstat.htm</a>):
The file must have the following format:
</p>
<p>The first line contains 4 numbers: the number of samples, <kbd>np</kbd> , the number of loci, <kbd>nl</kbd>,
the highest number used to label an allele, <kbd>nu</kbd>, and a 1 if the code for alleles is a one digit
number (1-9), a 2 if code for alleles is a 2 digit number (01-99) or a 3 if code for alleles is a 3
digit number (001-999).  These 4 numbers need to be separated by any number of spaces.</p>
</td></tr>
</table>
<p>The first line is immediately followed by <kbd>nl</kbd> lines, each containing the name of a locus,
in the order they will appear in the rest of the file.
</p>
<p>On line <kbd>nl+2</kbd>, a series of numbers as follow:
</p>
<pre>1     0102   0103   0101  0203          0      0303</pre>
<p>The first number identifies the sample to which the individual belongs,
the second is the genotype of the individual at the first locus,
coded with a 2 digits number for each allele,
the third is the genotype at the second locus, until locus nl is entered
(in the example above, <kbd>nl=6</kbd>).  Missing genotypes are encoded with 0, 00, 0000, 000000 or NA.
Note that 0001 or 0100 are not a valid format, as both alleles at a locus have
to be known, otherwise, the genotype is considered as missing.
No empty lines are needed between samples.
</p>
<table>
<tr><td><code id="read.fstat_+3A_na.s">na.s</code></td>
<td>
<p>The strings that correspond to the missing value.
<em>You should note have to change this</em></p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data frame containing the desired data, in a format adequate to pass to <kbd>varcomp</kbd>
</p>


<h3>References</h3>

<p>Goudet J. (1995). FSTAT (Version 1.2): A computer program to calculate F- statistics. Journal of Heredity 86:485-486
</p>
<p>Goudet J. (2005). Hierfstat, a package for R to compute and test variance components and F-statistics. Molecular Ecology Notes. 5:184-186
</p>


<h3>Examples</h3>

<pre><code class='language-R'>read.fstat(paste(path.package("hierfstat"),"/extdata/diploid.dat",sep="",collapse=""))
</code></pre>

<hr>
<h2 id='read.fstat.data'>Reads data from a FSTAT file</h2><span id='topic+read.fstat.data'></span>

<h3>Description</h3>

<p>Imports a <em>FSTAT</em> data file into R.
The data frame created is made of <kbd>nl+1</kbd> columns, <kbd>nl</kbd> being the number of loci.
The first column corresponds to the Population identifier,
the following columns contains the genotypes of the individuals.</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.fstat.data(fname, na.s = c("0","00","000","0000","00000","000000","NA"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read.fstat.data_+3A_fname">fname</code></td>
<td>
<p>a file in the FSTAT format (<a href="http://www.unil.ch/popgen/softwares/fstat.htm">http://www.unil.ch/popgen/softwares/fstat.htm</a>):
The file must have the following format:
</p>
<p>The first line contains 4 numbers: the number of samples, <kbd>np</kbd> , the number of loci, <kbd>nl</kbd>,
the highest number used to label an allele, <kbd>nu</kbd>, and a 1 if the code for alleles is a one digit
number (1-9), a 2 if code for alleles is a 2 digit number (01-99) or a 3 if code for alleles is a 3
digit number (001-999).  These 4 numbers need to be separated by any number of spaces.</p>
</td></tr>
</table>
<p>The first line is immediately followed by <kbd>nl</kbd> lines, each containing the name of a locus,
in the order they will appear in the rest of the file.
</p>
<p>On line <kbd>nl+2</kbd>, a series of numbers as follow:
</p>
<pre>1     0102   0103   0101  0203          0      0303</pre>
<p>The first number identifies the sample to which the individual belongs,
the second is the genotype of the individual at the first locus,
coded with a 2 digits number for each allele,
the third is the genotype at the second locus, until locus nl is entered
(in the example above, <kbd>nl=6</kbd>).  Missing genotypes are encoded with 0, 00, 0000, 000000 or NA.
Note that 0001 or 0100 are not a valid format, as both alleles at a locus have
to be known, otherwise, the genotype is considered as missing.
No empty lines are needed between samples.
</p>
<table>
<tr><td><code id="read.fstat.data_+3A_na.s">na.s</code></td>
<td>
<p>The strings that correspond to the missing value.
<em>You should note have to change this</em></p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data frame containing the desired data, in a format adequate to pass to <kbd>varcomp</kbd>
</p>


<h3>References</h3>

<p>Goudet J. (1995). FSTAT (Version 1.2): A computer program to calculate F- statistics. Journal of Heredity 86:485-486
</p>
<p>Goudet J. (2005). Hierfstat, a package for R to compute and test variance components and F-statistics. Molecular Ecology Notes. 5:184-186
</p>


<h3>Examples</h3>

<pre><code class='language-R'>read.fstat.data(paste(path.package("hierfstat"),"/extdata/diploid.dat",sep="",collapse=""))
</code></pre>

<hr>
<h2 id='read.ms'>Read data generated by Hudson ms program
Read data generated by 
<a href="http://home.uchicago.edu/rhudson1/source/mksamples.html">Hudson ms</a> 
program, either as Haplotypes or as SNPs.</h2><span id='topic+read.ms'></span>

<h3>Description</h3>

<p>With argument what=&quot;SNP&quot;, each site is read as a SNP, with the ancestral allele encoded as 0 and the alternate 
allele encoded as 1.  If the ms output file contains several replicates, 
the different replicates will be collated together.  Hence, the number of loci is the sum of all
sites from all replicates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.ms(fname,what=c("SNP","Haplotype"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read.ms_+3A_fname">fname</code></td>
<td>
<p>file name containing ms output</p>
</td></tr>
<tr><td><code id="read.ms_+3A_what">what</code></td>
<td>
<p>whether to read ms output as SNPs or haplotypes</p>
</td></tr>
</table>


<h3>Details</h3>

<p>With argument what=&quot;Haplotype&quot;, each different sequence from a replicate 
is read as a haplotype, 
by converting it first to a factor, and then to an integer. There will be as many loci 
as there are replicates, and the number of alleles per locus will be the number of different
haplotypes in the corresponding replicate.
</p>


<h3>Value</h3>

<p>alldat  a data frame with nloc+1 columns, the first being the population
to which the individual belongs and the next being the genotypes, one column per locus; 
and one row per (haploid) individual.
</p>


<h3>Author(s)</h3>

<p>Jerome Goudet <a href="mailto:jerome.goudet@unil.ch">jerome.goudet@unil.ch</a>
</p>


<h3>References</h3>

<p><a href="https://academic.oup.com/bioinformatics/article-abstract/18/2/337/225783">Hudson, R. R. (2002) Generating samples under a Wright-Fisher neutral model of genetic variation</a>. Bioinformatics 18 : 337-338.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
  datH&lt;-read.ms(system.file("extdata","2pops_asspop.txt",package="hierfstat"),what="Haplotype")
  dim(datH)
  head(datH[,1:10]
  datS&lt;-read.ms(system.file("extdata","2pops_asspop.txt",package="hierfstat"),what="SNP")
  dim(datS)
  head(datS[,1:10])
  
## End(Not run)
</code></pre>

<hr>
<h2 id='read.VCF'>Reads a VCF file into a BED object</h2><span id='topic+read.VCF'></span>

<h3>Description</h3>

<p>Reads a <a href="https://samtools.github.io/hts-specs/">https://samtools.github.io/hts-specs/</a>Variant Call Format (VCF) file into a BED object,
retaining bi-allelic SNPs only
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.VCF(fname,BiAllelic=TRUE,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read.VCF_+3A_fname">fname</code></td>
<td>
<p>VCF file name. The VCF file can be compressed (VCF.gz)</p>
</td></tr>
<tr><td><code id="read.VCF_+3A_biallelic">BiAllelic</code></td>
<td>
<p>Logical. If TRUE, only bi-allelic SNPs are retained,
otherwise, all variant are kept</p>
</td></tr>
<tr><td><code id="read.VCF_+3A_...">...</code></td>
<td>
<p>other arguments to pass to the function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="gaston.html#topic+bed.matrix-class">bed.matrix-class</a></code> object
</p>


<h3>See Also</h3>

<p><code><a href="gaston.html#topic+read.vcf">read.vcf</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> 
 filepath &lt;-system.file("extdata", "LCT.vcf.gz", package="gaston")
 x1 &lt;- read.VCF( filepath )
 x1

</code></pre>

<hr>
<h2 id='samp.between'>Shuffles a sequence among groups defined by the input vector</h2><span id='topic+samp.between'></span>

<h3>Description</h3>

<p>Used to generate a permutation of a sequence <kbd>1:length(lev)</kbd>. blocks of observations are permutted, according to the vector <kbd>lev</kbd> passed to the function.</p>


<h3>Usage</h3>

<pre><code class='language-R'>samp.between(lev)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="samp.between_+3A_lev">lev</code></td>
<td>
<p>a vector containing the groups to be permuted.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector <kbd>1:length(lev)</kbd> (with blocks defined by data) randomly permuted. Usually, one passes the result to reorder observations in a data set in order to carry out permutation-based tests
</p>


<h3>Author(s)</h3>

<p>Jerome Goudet,
DEE, UNIL, 
CH-1015
Lausanne
Switzerland 
</p>
<p><a href="mailto:jerome.goudet@unil.ch">jerome.goudet@unil.ch</a>
</p>


<h3>References</h3>

<p>Goudet J. (2005). Hierfstat, a package for R to compute and test variance components and F-statistics. Molecular Ecology Notes. 5:184-186
</p>


<h3>See Also</h3>

<p><code><a href="#topic+samp.within">samp.within</a></code>, <code><a href="#topic+g.stats.glob">g.stats.glob</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>samp.between(rep(1:4,each=4))
#for an application see example in g.stats.glob
</code></pre>

<hr>
<h2 id='samp.between.within'>Shuffles a sequence</h2><span id='topic+samp.between.within'></span>

<h3>Description</h3>

<p>Used to generate a permutation of a sequence <kbd>1:length(inner.lev)</kbd>. blocks of observations defined by <kbd>inner.lev</kbd> are permutted within blocks defined by <kbd>outer.lev</kbd></p>


<h3>Usage</h3>

<pre><code class='language-R'>samp.between.within(inner.lev, outer.lev)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="samp.between.within_+3A_inner.lev">inner.lev</code></td>
<td>
<p>a vector containing the groups to be permuted.</p>
</td></tr>
<tr><td><code id="samp.between.within_+3A_outer.lev">outer.lev</code></td>
<td>
<p>a vector containing teh blocks within which observations are to be kept.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector <kbd>1:length(lev)</kbd> (with blocks defined by data) randomly permuted. Usually, one passes the result to reorder observations in a data set in order to carry out permutation-based tests
</p>


<h3>See Also</h3>

<p><code><a href="#topic+test.between.within">test.between.within</a></code>.</p>

<hr>
<h2 id='samp.within'>Shuffles a sequence within groups defined by the input vector</h2><span id='topic+samp.within'></span>

<h3>Description</h3>

<p>Used to generate a permutation of a sequence <kbd>1:length(lev)</kbd>. observations are permutted within blocks, according to the vector <kbd>lev</kbd> passed to the function.</p>


<h3>Usage</h3>

<pre><code class='language-R'>samp.within(lev)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="samp.within_+3A_lev">lev</code></td>
<td>
<p>a vector containing the group to which belongs the observations to be permuted.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector <kbd>1:length(lev)</kbd> (with blocks defined by </p>
<pre>lev</pre><p>) randomly permuted. Usually, one passes the result to reorder observations in a data set in order to carry out permutation-based tests.
</p>


<h3>Author(s)</h3>

<p>Jerome Goudet,
DEE, UNIL, 
CH-1015
Lausanne
Switzerland 
</p>
<p><a href="mailto:jerome.goudet@unil.ch">jerome.goudet@unil.ch</a>
</p>


<h3>References</h3>

<p>Goudet J. (2005). Hierfstat, a package for R to compute and test variance components and F-statistics. Molecular Ecology Notes. 5:184-186
</p>


<h3>See Also</h3>

<p><code><a href="#topic+samp.between">samp.between</a></code>,<code><a href="#topic+g.stats.glob">g.stats.glob</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>samp.within(rep(1:4,each=4))
#for an application see example in g.stats.glob
</code></pre>

<hr>
<h2 id='sexbias.test'>Test for sex biased dispersal</h2><span id='topic+sexbias.test'></span>

<h3>Description</h3>

<p>Test whether one
sex disperses more than the other using the method described in 
<a href="https://onlinelibrary.wiley.com/doi/abs/10.1046/j.1365-294X.2002.01496.x">Goudet etal. (2002)</a>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sexbias.test(dat,sex,nperm=NULL,test="mAIc",alternative="two.sided")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sexbias.test_+3A_dat">dat</code></td>
<td>
<p>a data frame with n.locs+1 columns and n.inds rows</p>
</td></tr>
<tr><td><code id="sexbias.test_+3A_sex">sex</code></td>
<td>
<p>a vector containing the individual's sex</p>
</td></tr>
<tr><td><code id="sexbias.test_+3A_nperm">nperm</code></td>
<td>
<p>the number of permutation to carry out</p>
</td></tr>
<tr><td><code id="sexbias.test_+3A_test">test</code></td>
<td>
<p>one of &quot;mAIc&quot; (default), &quot;vAIc&quot;,&quot;FIS&quot; or &quot;FST&quot;</p>
</td></tr>
<tr><td><code id="sexbias.test_+3A_alternative">alternative</code></td>
<td>
<p>one of &quot;two.sided&quot; (default),&quot;less&quot; or &quot;greater&quot;</p>
</td></tr>
</table>


<h3>Value</h3>

<p>call the function call
</p>
<p>res the observation for each sex
</p>
<p>statistic the observed statistic for the chosen test
</p>
<p>p.value the p-value of the hypothesis
</p>


<h3>Author(s)</h3>

<p>Jerome Goudet <a href="mailto:jerome.goudet@unil.ch">jerome.goudet@unil.ch</a>
</p>


<h3>References</h3>

<p><a href="https://onlinelibrary.wiley.com/doi/abs/10.1046/j.1365-294X.2002.01496.x">Goudet J, Perrin N, Waser P (2002)</a> Tests for sex-biased dispersal 
using bi-parentally inherited genetic markers 11, 1103:1114
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  data(crocrussula)
  sexbias.test(crocrussula$genot,crocrussula$sex)
  dat&lt;-qn2.read.fstat(system.file("extdata","qn2_sex.dat",package="hierfstat"))
  sexbias.test(dat[[1]],sex=dat[[2]])
  ## Not run: 
  sexbias.test(crocrussula$genot,crocrussula$sex,nperm=1000)
  sexbias.test(dat[[1]],sex=dat[[2]],nperm=100,test="FST",alternative="greater")
  
## End(Not run)
</code></pre>

<hr>
<h2 id='sim.freq'>Simulates frequencies, for internal use only</h2><span id='topic+sim.freq'></span>

<h3>Description</h3>

<p>Simulates frequencies, for internal use only</p>

<hr>
<h2 id='sim.genot'>Simulates genotypes in an island model at equilibrium</h2><span id='topic+sim.genot'></span>

<h3>Description</h3>

<p>Simulates genotypes from several individuals in several populations at several loci in an island model at equilibrium. The islands may differ in size and inbreeding coeeficients.</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim.genot(size=50,nbal=4,nbloc=5,nbpop=3,N=1000,mig=0.001,mut=0.0001,f=0)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sim.genot_+3A_size">size</code></td>
<td>
<p>The number of individuals to sample per population</p>
</td></tr>
<tr><td><code id="sim.genot_+3A_nbal">nbal</code></td>
<td>
<p>The maximum number of alleles present at a locus</p>
</td></tr>
<tr><td><code id="sim.genot_+3A_nbloc">nbloc</code></td>
<td>
<p>The number of loci to simulate</p>
</td></tr>
<tr><td><code id="sim.genot_+3A_nbpop">nbpop</code></td>
<td>
<p>The number of populations to simulate</p>
</td></tr>
<tr><td><code id="sim.genot_+3A_n">N</code></td>
<td>
<p>The population sizes for each island</p>
</td></tr>
<tr><td><code id="sim.genot_+3A_mig">mig</code></td>
<td>
<p>the proportion of migration among islands</p>
</td></tr>
<tr><td><code id="sim.genot_+3A_mut">mut</code></td>
<td>
<p>The loci mutation rate</p>
</td></tr>
<tr><td><code id="sim.genot_+3A_f">f</code></td>
<td>
<p>the inbreeding coefficient for each island</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data frame with nbpop*size lines and nbloc+1 columns. Individuals are in rows and genotypes in columns, the first column being the population identifier</p>


<h3>Author(s)</h3>

<p>Jerome Goudet <a href="mailto:jerome.goudet@unil.ch">jerome.goudet@unil.ch</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
dat&lt;-sim.genot(nbpop=4,nbal=20,nbloc=10,mig=0.001,mut=0.0001,N=c(100,100,1000,1000),f=0)
betas(dat)$betaiovl

## End(Not run)
</code></pre>

<hr>
<h2 id='sim.genot.metapop.t'>Simulate genetic data from a metapopulation model</h2><span id='topic+sim.genot.metapop.t'></span>

<h3>Description</h3>

<p>This function allows to simulate genetic data from a metapopulation
model, where each population can have a different size and a different inbreeding 
coefficient, and migration between each population is given in a migration matrix. 
</p>
<p>This function simulates genetic data under a migration matrix model.
Each population <code class="reqn">i</code> sends a proportion of migrant alleles <code class="reqn">m_{ij}</code> to population <code class="reqn">j</code> 
and receives a proportion of migrant alleles <code class="reqn">m_{ji}</code> from population <code class="reqn">j</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim.genot.metapop.t(size=50,nbal=4,nbloc=5,nbpop=3,N=1000,
mig=diag(3),mut=0.0001,f=0,t=100)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sim.genot.metapop.t_+3A_size">size</code></td>
<td>
<p>the number of sampled individuals per population</p>
</td></tr>
<tr><td><code id="sim.genot.metapop.t_+3A_nbal">nbal</code></td>
<td>
<p>the number of alleles per locus (maximum of 99)</p>
</td></tr>
<tr><td><code id="sim.genot.metapop.t_+3A_nbloc">nbloc</code></td>
<td>
<p>the number of loci to simulate</p>
</td></tr>
<tr><td><code id="sim.genot.metapop.t_+3A_nbpop">nbpop</code></td>
<td>
<p>the number of populations to simulate</p>
</td></tr>
<tr><td><code id="sim.genot.metapop.t_+3A_n">N</code></td>
<td>
<p>the effective population sizes of each population. If only one number, all
populations are assumed to be of the same size</p>
</td></tr>
<tr><td><code id="sim.genot.metapop.t_+3A_mig">mig</code></td>
<td>
<p>a matrix with nbpop rows and columns giving the migration rate 
from population i (in row) to population j (in column). Each row must sum to 1.</p>
</td></tr>
<tr><td><code id="sim.genot.metapop.t_+3A_mut">mut</code></td>
<td>
<p>the mutation rate of the loci</p>
</td></tr>
<tr><td><code id="sim.genot.metapop.t_+3A_f">f</code></td>
<td>
<p>the inbreeding coefficient for each population</p>
</td></tr>
<tr><td><code id="sim.genot.metapop.t_+3A_t">t</code></td>
<td>
<p>the number of generation since the islands were created</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In this model, <code class="reqn">\theta_t</code> can be written as a function of population size 
<code class="reqn">N_i</code>, migration rate <code class="reqn">m_{ij}</code>, mutation rate <code class="reqn">\mu</code> and <code class="reqn">\theta_{(t-1)}</code>.  
</p>
<p>The rational is as follows:
</p>
<p>With probability <code class="reqn">\frac{1}{N_i}</code>, 2 alleles from 2 different individuals in 
the current generation are sampled from the same individual of the previous 
generation:     
</p>
<p>-Half the time, the same allele is drawn from the parent;
</p>
<p>-The other half, two different alleles are drawn, but they are identical in 
proportion <code class="reqn">\theta_{(t-1)}</code>.
</p>
<p>-With  probability <code class="reqn">1-\frac{1}{N_i}</code>, the 2 alleles are drawn from different 
individuals in the previous generation, in which case they are identical in 
proportion <code class="reqn">\theta_{(t-1)}</code>.
</p>
<p>This holds providing that neither alleles have mutated or migrated.  This is 
the case with probability <code class="reqn">m_{ii}^2 \times (1-\mu)^2</code>.
If an allele is a mutant, then its coancestry with another allele 
is 0.
</p>
<p>Note also that the mutation scheme assumed is the infinite allele (or site) 
model.  If the number of alleles is finite (as will be the case in what follows),
the corresponding mutation model is the K-allele model and the mutation rate 
has to be adjusted to <code class="reqn">\mu'=\frac{K-1}{K}\mu</code>.
</p>
<p>Continue derivation
</p>


<h3>Value</h3>

<p>A data frame with size*nbpop rows and nbloc+1 columns. Each row is an
individual, the first column contains the identifier of the population to which the individual belongs, 
the following nbloc columns contain the genotype for each locus.
</p>


<h3>Author(s)</h3>

<p>Jerome Goudet <a href="mailto:jerome.goudet@unil.ch">jerome.goudet@unil.ch</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#2 populations
psize&lt;-c(10,1000)
mig.mat&lt;-matrix(c(0.99,0.01,0.1,0.9),nrow=2,byrow=TRUE)
dat&lt;-sim.genot.metapop.t(nbal=10,nbloc=100,nbpop=2,N=psize,mig=mig.mat,mut=0.00001,t=100)
betas(dat)$betaiovl # Population specific estimator of FST

#1D stepping stone
## Not run: 
np&lt;-10
m&lt;-0.2
mig.mat&lt;-diag(np)*(1-m)
diag(mig.mat[-1,-np])&lt;-m/2
diag(mig.mat[-np,-1])&lt;-m/2
mig.mat[1,1:2]&lt;-c(1-m/2,m/2)
mig.mat[np,(np-1):np]&lt;-c(m/2,1-m/2)
dat&lt;-sim.genot.metapop.t(nbal=10,nbloc=50,nbpop=np,mig=mig.mat,t=400)
pcoa(as.matrix(genet.dist(dat))) # principal coordinates plot

## End(Not run)

</code></pre>

<hr>
<h2 id='sim.genot.t'>Simulate data from a non equilibrium continent-island model</h2><span id='topic+sim.genot.t'></span>

<h3>Description</h3>

<p>This function allows to simulate genetic data from a non-equilibrium continent-island
model, where each island can have a different size and a different inbreeding 
coefficient. 
</p>
<p>This function simulates genetic data under the continent-islands model (IIM=TRUE) 
or the finite island model (IIM=FALSE).
In the IIM, a continent of 
infinite size sends migrants to islands of finite sizes <code class="reqn">N_i</code> at a rate 
<code class="reqn">m</code>. Alleles can also mutate to a new state at a rate <code class="reqn">\mu</code>. Under this model, 
the expected <code class="reqn">F_{STi}, \theta_i</code>, can be calculated and compared to empirical
estimates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim.genot.t(size=50,nbal=4,nbloc=5,nbpop=3,N=1000,
mig=0.001,mut=0.0001,f=0,t=100,IIM=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sim.genot.t_+3A_size">size</code></td>
<td>
<p>the number of sampled individuals per island</p>
</td></tr>
<tr><td><code id="sim.genot.t_+3A_nbal">nbal</code></td>
<td>
<p>the number of alleles per locus (maximum of 99)</p>
</td></tr>
<tr><td><code id="sim.genot.t_+3A_nbloc">nbloc</code></td>
<td>
<p>the number of loci to simulate</p>
</td></tr>
<tr><td><code id="sim.genot.t_+3A_nbpop">nbpop</code></td>
<td>
<p>the number of islands to simulate</p>
</td></tr>
<tr><td><code id="sim.genot.t_+3A_n">N</code></td>
<td>
<p>the effective population sizes of each island. If only one number, all
islands are assumed to be of the same size</p>
</td></tr>
<tr><td><code id="sim.genot.t_+3A_mig">mig</code></td>
<td>
<p>the migration rate from the continent to the islands</p>
</td></tr>
<tr><td><code id="sim.genot.t_+3A_mut">mut</code></td>
<td>
<p>the mutation rate of the loci</p>
</td></tr>
<tr><td><code id="sim.genot.t_+3A_f">f</code></td>
<td>
<p>the inbreeding coefficient for each island</p>
</td></tr>
<tr><td><code id="sim.genot.t_+3A_t">t</code></td>
<td>
<p>the number of generation since the islands were created</p>
</td></tr>
<tr><td><code id="sim.genot.t_+3A_iim">IIM</code></td>
<td>
<p>whether to simulate a continent island Model (default) or a migrant pool island Model</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In this model, <code class="reqn">\theta_t</code> can be written as a function of population size 
<code class="reqn">N_i</code>, migration rate <code class="reqn">m</code>, mutation rate <code class="reqn">\mu</code> and <code class="reqn">\theta_{(t-1)}</code>.  
</p>
<p>The rational is as follows:
</p>
<p>With probability <code class="reqn">\frac{1}{N}</code>, 2 alleles from 2 different individuals in 
the current generation are sampled from the same individual of the previous 
generation:     
</p>
<p>-Half the time, the same allele is drawn from the parent;
</p>
<p>-The other half, two different alleles are drawn, but they are identical in 
proportion <code class="reqn">\theta_{(t-1)}</code>.
</p>
<p>-With  probability <code class="reqn">1-\frac{1}{N}</code>, the 2 alleles are drawn from different 
individuals in the previous generation, in which case they are identical in 
proportion <code class="reqn">\theta_{(t-1)}</code>.
</p>
<p>This holds providing that neither alleles have mutated or migrated.  This is 
the case with probability <code class="reqn">(1-m)^2 \times (1-\mu)^2</code>.
If an allele is a mutant or a migrant, then its coancestry with another allele 
is 0 in the infinite continent-islands model (it is not the case in the finite island model).
</p>
<p>Note also that the mutation scheme assumed is the infinite allele (or site) 
model.  If the number of alleles is finite (as will be the case in what follows),
the corresponding mutation model is the K-allele model and the mutation rate 
has to be adjusted to <code class="reqn">\mu'=\frac{K-1}{K}\mu</code>.
</p>
<p>Lets substitute <code class="reqn">\alpha</code> for  <code class="reqn">(1-m)^2 (1-\mu)^2</code> and <code class="reqn">x</code> for
<code class="reqn">\frac{1}{2N}</code>.  
</p>
<p>The expectation of <code class="reqn">F_{ST}</code>, <code class="reqn">\theta</code> can be written as:
</p>
<p style="text-align: center;"><code class="reqn">\theta_t=(\alpha (1-x))^t \theta_0 + \frac{x}{1-x}\sum_{i=1}^t (\alpha (1-x))^i</code>
</p>
 
<p>which reduces to <code class="reqn">\theta_t=\frac{x}{1-x}\sum_{i=1}^t (\alpha (1-x))^i</code> if <code class="reqn">\theta_0=0</code>.
</p>
<p>Transition equations for <code class="reqn">theta</code> in the migrant-pool island model (IIM=FALSE) are given in Rouseet (1996). 
Currently, the migrant pool is made of equal contribution from each island, irrespective of their size.
</p>


<h3>Value</h3>

<p>A data frame with size*nbpop rows and nbloc+1 columns. Each row is an
individual, the first column contains the island to which the individual belongs, 
the following nbloc columns contain the genotype for each locus.
</p>


<h3>Author(s)</h3>

<p>Jerome Goudet <a href="mailto:jerome.goudet@unil.ch">jerome.goudet@unil.ch</a>
</p>


<h3>References</h3>

<p><a href="https://pubmed.ncbi.nlm.nih.gov/8846911/">Rousset, F. (1996)</a> Equilibrium values of measures of population subdivision for 
stepwise mutation processes. Genetics 142:1357
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
psize&lt;-c(100,1000,10000,100000,1000000)
dat&lt;-sim.genot.t(nbal=4,nbloc=20,nbpop=5,N=psize,mig=0.001,mut=0.0001,t=100)
summary(wc(dat)) #Weir and cockerham overall estimators of FST &amp; FIS
betas(dat) # Population specific estimator of FST

</code></pre>

<hr>
<h2 id='subsampind'>Subsample a FSTAT data frame</h2><span id='topic+subsampind'></span>

<h3>Description</h3>

<p>Subsample a given number of individuals from a FSTAT data frame</p>


<h3>Usage</h3>

<pre><code class='language-R'>subsampind(dat,sampsize = 10)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="subsampind_+3A_dat">dat</code></td>
<td>
<p>A data frame with population of origin as first column, and genotypes in following columns.</p>
</td></tr>
<tr><td><code id="subsampind_+3A_sampsize">sampsize</code></td>
<td>
<p>the number of individuals to sample in each population.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with population of origin as first column, and genotypes in following columns.  Each population is made of at most sampsize individuals
</p>


<h3>Author(s)</h3>

<p>Jerome Goudet <a href="mailto:jerome.goudet@unil.ch">jerome.goudet@unil.ch</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(gtrunchier)
subsampind(gtrunchier[,-1],6)  # check the warning
</code></pre>

<hr>
<h2 id='TajimaD.dosage'>Estimates Tajima's D</h2><span id='topic+TajimaD.dosage'></span>

<h3>Description</h3>

<p>Estimates Tajima's D from dosage data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TajimaD.dosage(dos)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="TajimaD.dosage_+3A_dos">dos</code></td>
<td>
<p>a ni X nl dosage matrix containing the number of derived/alternate alleles each individual carries
at each SNP</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Tajima's D (eqn 38 of Tajima, 1989)
</p>


<h3>References</h3>

<p><a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC1203831/">Tajima F. 1989</a> 
Statistical Method for Testing the Neutral Mutation Hypothesis by DNA Polymorphism. Genetics 123:585-595.
</p>

<hr>
<h2 id='test.between'>Tests the significance of the effect of test.lev on genetic differentiation</h2><span id='topic+test.between'></span>

<h3>Description</h3>

<p>Tests the significance of the effect of test.lev on genetic differentiation</p>


<h3>Usage</h3>

<pre><code class='language-R'>test.between(data, test.lev, rand.unit, nperm, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="test.between_+3A_data">data</code></td>
<td>
<p>a data frame containing the genotypes for the different loci</p>
</td></tr>
<tr><td><code id="test.between_+3A_test.lev">test.lev</code></td>
<td>
<p>A vector containing the units from which to construct the contingency tables</p>
</td></tr>
<tr><td><code id="test.between_+3A_rand.unit">rand.unit</code></td>
<td>
<p>A vector containing the assignment of each observation to the units to be permutted</p>
</td></tr>
<tr><td><code id="test.between_+3A_nperm">nperm</code></td>
<td>
<p>The number of permutations to carry out for the test</p>
</td></tr>
<tr><td><code id="test.between_+3A_...">...</code></td>
<td>
<p>Mainly here to allow passing <kbd>diploid=FALSE</kbd> if necessary</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>g.star</code></td>
<td>
<p>A vector containing all the generated g-statistics, the last one beeing the observed</p>
</td></tr>
<tr><td><code>p.val</code></td>
<td>
<p>The p-value associated with the test</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jerome Goudet <a href="mailto:jerome.goudet@unil.ch">jerome.goudet@unil.ch</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(gtrunchier)
attach(gtrunchier)
#test whether the locality level has a significant effect on genetic structuring
test.between(gtrunchier[,-c(1,2)],test.lev=Locality,rand.unit=Patch)
</code></pre>

<hr>
<h2 id='test.between.within'>Tests the significance of the effect of test.lev on genetic differentiation</h2><span id='topic+test.between.within'></span>

<h3>Description</h3>

<p>Tests, using permutations of <kbd>rand.unit</kbd> within units defined by the vector <kbd>within</kbd> the significance of the contingency tables allele X (levels of <kbd>test.lev</kbd>)</p>


<h3>Usage</h3>

<pre><code class='language-R'>test.between.within(data, within, test.lev, rand.unit, nperm, ...) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="test.between.within_+3A_data">data</code></td>
<td>
<p>a data frame containing the genotypes for the different loci</p>
</td></tr>
<tr><td><code id="test.between.within_+3A_within">within</code></td>
<td>
<p>A vector containing the units in which to keep the observations</p>
</td></tr>
<tr><td><code id="test.between.within_+3A_test.lev">test.lev</code></td>
<td>
<p>A vector containing the units from which to construct the contingency tables</p>
</td></tr>
<tr><td><code id="test.between.within_+3A_rand.unit">rand.unit</code></td>
<td>
<p>A vector containing the assignment of each observation to the units to be permutted</p>
</td></tr>
<tr><td><code id="test.between.within_+3A_nperm">nperm</code></td>
<td>
<p>The number of permutations to carry out for the test</p>
</td></tr>
<tr><td><code id="test.between.within_+3A_...">...</code></td>
<td>
<p>Mainly here to allow passing <kbd>diploid=FALSE</kbd> if necessary</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>g.star</code></td>
<td>
<p>A vector containing all the generated g-statistics, the last one beeing the observed</p>
</td></tr>
<tr><td><code>p.val</code></td>
<td>
<p>The p-value associated with the test</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jerome Goudet <a href="mailto:jerome.goudet@unil.ch">jerome.goudet@unil.ch</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(yangex)
attach(yangex)
#tests for the effect of spop on genetic structure
test.between.within(data.frame(genot),within=pop,test=spop,rand=sspop)
</code></pre>

<hr>
<h2 id='test.g'>Tests the significance of the effect of level on genetic differentiation</h2><span id='topic+test.g'></span>

<h3>Description</h3>

<p>Tests the significance of the effect of <kbd>level</kbd> on genetic differentiation</p>


<h3>Usage</h3>

<pre><code class='language-R'>test.g(data = data, level, nperm = 100,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="test.g_+3A_data">data</code></td>
<td>
<p>a data frame containing the genotypes for the different loci</p>
</td></tr>
<tr><td><code id="test.g_+3A_level">level</code></td>
<td>
<p>A vector containing the assignment of each observation to its level</p>
</td></tr>
<tr><td><code id="test.g_+3A_nperm">nperm</code></td>
<td>
<p>The number of permutations to carry out for the test</p>
</td></tr>
<tr><td><code id="test.g_+3A_...">...</code></td>
<td>
<p>Mainly here to allow passing <kbd>diploid=FALSE</kbd> if necessary</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>g.star</code></td>
<td>
<p>A vector containing all the generated g-statistics, the last one beeing the observed</p>
</td></tr>
<tr><td><code>p.val</code></td>
<td>
<p>The p-value associated with the test</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jerome Goudet <a href="mailto:jerome.goudet@unil.ch">jerome.goudet@unil.ch</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(gtrunchier)
attach(gtrunchier)
test.g(gtrunchier[,-c(1,2)],Locality)
</code></pre>

<hr>
<h2 id='test.within'>Tests the significance of the effect of inner.level on genetic differentiation within blocks defined by outer.level</h2><span id='topic+test.within'></span>

<h3>Description</h3>

<p>Tests the significance of the effect of inner.level on genetic differentiation within blocks defined by outer.level</p>


<h3>Usage</h3>

<pre><code class='language-R'>test.within(data, within, test.lev, nperm, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="test.within_+3A_data">data</code></td>
<td>
<p>a data frame containing the genotypes for the different loci</p>
</td></tr>
<tr><td><code id="test.within_+3A_within">within</code></td>
<td>
<p>A vector containing the units in which to keep the observations</p>
</td></tr>
<tr><td><code id="test.within_+3A_test.lev">test.lev</code></td>
<td>
<p>A vector containing the units from which to construct the contingency tables</p>
</td></tr>
<tr><td><code id="test.within_+3A_nperm">nperm</code></td>
<td>
<p>The number of permutations to carry out for the test</p>
</td></tr>
<tr><td><code id="test.within_+3A_...">...</code></td>
<td>
<p>Mainly here to allow passing <kbd>diploid=FALSE</kbd> if necessary</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>g.star</code></td>
<td>
<p>A vector containing all the generated g-statistics, the last one beeing the observed</p>
</td></tr>
<tr><td><code>p.val</code></td>
<td>
<p>The p-value associated with the test</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jerome Goudet <a href="mailto:jerome.goudet@unil.ch">jerome.goudet@unil.ch</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(gtrunchier)
attach(gtrunchier)
#tests whether the patch level has a significant effect on genetic structure
test.within(gtrunchier[,-c(1,2)],within=Locality,test.lev=Patch)
</code></pre>

<hr>
<h2 id='theta.Watt.dosage'>Estimates <code class="reqn">\theta_{Watterson}</code> from dosage data</h2><span id='topic+theta.Watt.dosage'></span>

<h3>Description</h3>

<p>Estimates <code class="reqn">\theta_{Watterson}=S/a</code>, where <code class="reqn">S</code> is the number of segregating sites
in a set of sequences and <code class="reqn">a=1/\sum_i^{n-1} i</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>theta.Watt.dosage(dos,L=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="theta.Watt.dosage_+3A_dos">dos</code></td>
<td>
<p>a ni X nl dosage matrix containing the number of derived/alternate alleles each individual carries
at each SNP</p>
</td></tr>
<tr><td><code id="theta.Watt.dosage_+3A_l">L</code></td>
<td>
<p>the length of the sequence</p>
</td></tr>
</table>


<h3>Value</h3>

<p>if <code>L=NULL</code> (default), returns <code class="reqn">\theta_{Watterson}</code>, else return <code class="reqn">\theta_{Watterson}/L</code>
</p>

<hr>
<h2 id='varcomp'>Estimates variance components for each allele of a locus</h2><span id='topic+varcomp'></span>

<h3>Description</h3>

<p>Estimates variance components for each allele for a (fully) hierarchical random design defined by all but the last column of the data frame  <kbd>data</kbd>, the last column containing the genetic data to analyse. Columns for the hierarchical design should be given from the outermost to the innermost before the individual (e.g. continent, region, population, patch,...)</p>


<h3>Usage</h3>

<pre><code class='language-R'>varcomp(data,diploid=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="varcomp_+3A_data">data</code></td>
<td>
<p>a data frame that contains the different factors from the outermost (e.g. region)
to the innermost before the individual. the last column of the data frame 'data' contains the locus to analyse, which can be multiallelic. Missing data are allowed.</p>
</td></tr>
<tr><td><code id="varcomp_+3A_diploid">diploid</code></td>
<td>
<p>a boolean stating whether the data come from diploid (TRUE=default) or haploid (FALSE) organisms</p>
</td></tr></table>


<h3>Details</h3>

<p>The format for genotypes is simply the code for the 2 alleles put one behind the other, without space in between. For instance if allele 1 at the locus has code <kbd>23</kbd> and allele 2 <kbd>39</kbd>, the genotype format is <kbd>2339</kbd>. 
</p>


<h3>Value</h3>

<table>
<tr><td><code>df</code></td>
<td>
<p>the degrees of freedom for each level</p>
</td></tr>
<tr><td><code>k</code></td>
<td>
<p>the k matrix, the coefficients associated with the variance components</p>
</td></tr>
<tr><td><code>res</code></td>
<td>
<p>the variance components for each allele</p>
</td></tr>
<tr><td><code>overall</code></td>
<td>
<p>the variance components summed over alleles</p>
</td></tr>
<tr><td><code>F</code></td>
<td>
<p>a matrix of hierarchical F-statistics type-coefficients
with the first line corresponding to <code class="reqn">F_{(n-1)/n}</code>,<code class="reqn">F_{(n-2)/n}</code>...<code class="reqn">F_{i/n}</code> and
the diagonal corresponding to <code class="reqn">F_{(n-1)/n}</code>, <code class="reqn">F_{(n-2)/(n-1)}</code>,<code class="reqn">F_{i/2}</code></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jerome Goudet,
DEE, UNIL, 
CH-1015
Lausanne
Switzerland 
</p>
<p><a href="mailto:jerome.goudet@unil.ch">jerome.goudet@unil.ch</a>
</p>
<p><a href="http://www.unil.ch/popgen/people/jerome.htm">http://www.unil.ch/popgen/people/jerome.htm</a>
</p>


<h3>References</h3>

<p>Goudet J. (2005). Hierfstat, a package for R to compute and test variance components and F-statistics. Molecular Ecology Notes. 5:184-186
</p>
<p>Weir, B.S. (1996) Genetic Data Analysis II. Sinauer Associates.
</p>
<p>Yang, R.C. (1998). Estimating hierarchical F-statistics. Evolution 52(4):950-956
</p>


<h3>See Also</h3>

<p><code><a href="#topic+varcomp.glob">varcomp.glob</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>#load data set
data(gtrunchier)
attach(gtrunchier)
#
varcomp(data.frame(Locality,Patch,L21.V))
</code></pre>

<hr>
<h2 id='varcomp.glob'>Estimate variance components and hierarchical F-statistics over all loci</h2><span id='topic+varcomp.glob'></span>

<h3>Description</h3>

<p>Return multilocus estimators of variance components and F-statistics</p>


<h3>Usage</h3>

<pre><code class='language-R'>varcomp.glob(levels=levels,loci=loci,diploid=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="varcomp.glob_+3A_levels">levels</code></td>
<td>
<p>a data frame containing the different levels (factors) from the outermost (e.g. region) to the innermost before the individual</p>
</td></tr>
<tr><td><code id="varcomp.glob_+3A_loci">loci</code></td>
<td>
<p>a data frame containing the different loci</p>
</td></tr>
<tr><td><code id="varcomp.glob_+3A_diploid">diploid</code></td>
<td>
<p>Specify whether the data are coming from diploid or haploid organisms (diploid is the default)</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>loc</code></td>
<td>
<p>The variance components for each locus</p>
</td></tr>
<tr><td><code>overall</code></td>
<td>
<p>The variance components summed over all loci</p>
</td></tr>
<tr><td><code>F</code></td>
<td>
<p>a matrix of hierarchical F-statistics type-coefficients
with the first line corresponding to <code class="reqn">F_{(n-1)/n}</code>,<code class="reqn">F_{(n-2)/n}</code>...<code class="reqn">F_{i/n}</code> and
the diagonal corresponding to <code class="reqn">F_{(n-1)/n}</code>, <code class="reqn">F_{(n-2)/(n-1)}</code>,<code class="reqn">F_{i/2}</code></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jerome Goudet
DEE, UNIL, 
CH-1015
Lausanne
Switzerland 
</p>
<p><a href="mailto:jerome.goudet@unil.ch">jerome.goudet@unil.ch</a>
</p>


<h3>References</h3>

<p>Weir, B.S. (1996) Genetic Data Analysis II. Sinauer Associates.
</p>
<p>Yang, R.C. (1998). Estimating hierarchical F-statistics. Evolution 52(4):950-956
</p>
<p>Goudet J. (2005). Hierfstat, a package for R to compute and test variance components and F-statistics. Molecular Ecology Notes. 5:184-186
</p>


<h3>See Also</h3>

<p><code><a href="#topic+varcomp">varcomp</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>#load data set
data(gtrunchier)
attach(gtrunchier)
varcomp.glob(data.frame(Locality,Patch),gtrunchier[,-c(1,2)])
</code></pre>

<hr>
<h2 id='vec2mat'>Fills a triangular matrix from the inputed vector</h2><span id='topic+vec2mat'></span>

<h3>Description</h3>

<p>Fills a triangular matrix from the inputed vector
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vec2mat(x,diag=FALSE,upper=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vec2mat_+3A_x">x</code></td>
<td>
<p>a vector</p>
</td></tr>
<tr><td><code id="vec2mat_+3A_diag">diag</code></td>
<td>
<p>whether the vector contains the diagonal elements</p>
</td></tr>
<tr><td><code id="vec2mat_+3A_upper">upper</code></td>
<td>
<p>whether the vector contains the upper trinagular matrix elements</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix
</p>


<h3>Examples</h3>

<pre><code class='language-R'>{
 vec2mat(1:10)
 vec2mat(1:10,diag=TRUE)
 vec2mat(1:10,upper=TRUE)
}
</code></pre>

<hr>
<h2 id='wc'>Computes Weir and Cockrham estimates of Fstatistics</h2><span id='topic+wc'></span><span id='topic+print.wc'></span>

<h3>Description</h3>

<p>Computes Weir and Cockerham estimates of Fstatistics</p>


<h3>Usage</h3>

<pre><code class='language-R'>wc(ndat,diploid=TRUE,pol=0.0)

## S3 method for class 'wc'
print(x,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wc_+3A_ndat">ndat</code></td>
<td>
<p>data frame with first column indicating population of origin and following representing loci</p>
</td></tr>
<tr><td><code id="wc_+3A_diploid">diploid</code></td>
<td>
<p>Whether data are diploid</p>
</td></tr>
<tr><td><code id="wc_+3A_pol">pol</code></td>
<td>
<p>level of polymorphism reqesuted for inclusion. Note used for now</p>
</td></tr>
<tr><td><code id="wc_+3A_x">x</code></td>
<td>
<p>an object of class wc</p>
</td></tr>
<tr><td><code id="wc_+3A_...">...</code></td>
<td>
<p>further arguments to pass to print.wc</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>sigma</code></td>
<td>
<p>variance components of allele frequencies for each allele, in the order among populations, among individuals within populations and within individuals</p>
</td></tr>
<tr><td><code>sigma.loc</code></td>
<td>
<p>variance components per locus</p>
</td></tr>
<tr><td><code>per.al</code></td>
<td>
<p>FST and FIS per allele</p>
</td></tr>
<tr><td><code>per.loc</code></td>
<td>
<p>FST and FIS per locus</p>
</td></tr>
<tr><td><code>FST</code></td>
<td>
<p>FST overall loci</p>
</td></tr>
<tr><td><code>FIS</code></td>
<td>
<p>FIS overall loci</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jerome Goudet <a href="mailto:jerome.goudet@unil.ch">jerome.goudet@unil.ch</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(gtrunchier)
wc(gtrunchier[,-1])
</code></pre>

<hr>
<h2 id='write.bayescan'>Writes a bayescan file</h2><span id='topic+write.bayescan'></span>

<h3>Description</h3>

<p>write the genotypes in a format suitable for
analysis with bayescan
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write.bayescan(dat=dat,diploid=TRUE,fn="dat.bsc")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="write.bayescan_+3A_dat">dat</code></td>
<td>
<p>a genotype data frame</p>
</td></tr>
<tr><td><code id="write.bayescan_+3A_diploid">diploid</code></td>
<td>
<p>whether the dataset is diploid or haploid</p>
</td></tr>
<tr><td><code id="write.bayescan_+3A_fn">fn</code></td>
<td>
<p>file name for output</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a text file fn is written in the current directory
</p>


<h3>Author(s)</h3>

<p>Jerome Goudet <a href="mailto:jerome.goudet@unil.ch">jerome.goudet@unil.ch</a>
</p>


<h3>References</h3>

<p><a href="https://academic.oup.com/genetics/article/180/2/977/6073889">Foll M and OE Gaggiotti (2008) 
Genetics 180: 977-993</a>
</p>
<p><a href="http://cmpg.unibe.ch/software/BayeScan/">http://cmpg.unibe.ch/software/BayeScan/</a>
</p>

<hr>
<h2 id='write.fstat'>Write an Fstat data file</h2><span id='topic+write.fstat'></span>

<h3>Description</h3>

<p>Write a data frame to a text file in the fstat data format, see <code>read.fstat</code></p>


<h3>Usage</h3>

<pre><code class='language-R'>write.fstat(dat,fname="genotypes.dat")</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="write.fstat_+3A_dat">dat</code></td>
<td>
<p>A data frame with first column containing the population identifier and remaining columns containing genotypes</p>
</td></tr>
<tr><td><code id="write.fstat_+3A_fname">fname</code></td>
<td>
<p>The name of teh text file to which the data frame should be written</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None</p>


<h3>Author(s)</h3>

<p>Jerome Goudet</p>


<h3>References</h3>

<p>Goudet J. (1995). FSTAT (Version 1.2): A computer program to calculate F- statistics. Journal of Heredity 86:485-486
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: data(gtrunchier)
write.fstat(gtrunchier[,-1],"galba.dat")

## End(Not run)</code></pre>

<hr>
<h2 id='write.ped'>Write ped file for analyses with PLINK</h2><span id='topic+write.ped'></span>

<h3>Description</h3>

<p>write a ped and a map file suitable for analysis with 
<a href="https://www.cog-genomics.org/plink2">PLINK</a>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write.ped(dat, ilab = NULL, pop = NULL, 
        fname = "dat",na.str="0",f.id=NULL,m.id=NULL,loc.pos=NULL,sex=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="write.ped_+3A_dat">dat</code></td>
<td>
<p>a hierfstat data frame. if pop=NULL, the first column should contain the population identifier, 
otherwise it contains genotypes at the first locus</p>
</td></tr>
<tr><td><code id="write.ped_+3A_ilab">ilab</code></td>
<td>
<p>individual labels</p>
</td></tr>
<tr><td><code id="write.ped_+3A_pop">pop</code></td>
<td>
<p>population id</p>
</td></tr>
<tr><td><code id="write.ped_+3A_fname">fname</code></td>
<td>
<p>filename for ped file</p>
</td></tr>
<tr><td><code id="write.ped_+3A_na.str">na.str</code></td>
<td>
<p>character string to use for missing values</p>
</td></tr>
<tr><td><code id="write.ped_+3A_f.id">f.id</code></td>
<td>
<p>father id. default to unknown</p>
</td></tr>
<tr><td><code id="write.ped_+3A_m.id">m.id</code></td>
<td>
<p>mother id. default to unknown</p>
</td></tr>
<tr><td><code id="write.ped_+3A_loc.pos">loc.pos</code></td>
<td>
<p>the loci position default to unknown</p>
</td></tr>
<tr><td><code id="write.ped_+3A_sex">sex</code></td>
<td>
<p>the individual sex. default to unknown</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a map file containing the loci positions
</p>
<p>a ped file containing genotypes etc...
</p>


<h3>References</h3>

<p><a href="https://academic.oup.com/gigascience/article/4/1/s13742-015-0047-8/2707533">Chang et al. (2015)</a> 
Second-generation PLINK: rising to the challenge of larger and richer datasets
</p>

<hr>
<h2 id='write.struct'>Write structure file</h2><span id='topic+write.struct'></span>

<h3>Description</h3>

<p>Write a genotype data set to a file in the structure format</p>


<h3>Usage</h3>

<pre><code class='language-R'>write.struct(dat,ilab=NULL,pop=NULL,MARKERNAMES=FALSE,MISSING=-9,fname="dat.str")</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="write.struct_+3A_dat">dat</code></td>
<td>
<p>a genotype dataframe</p>
</td></tr>
<tr><td><code id="write.struct_+3A_ilab">ilab</code></td>
<td>
<p>an (optional) column with individual labels</p>
</td></tr>
<tr><td><code id="write.struct_+3A_pop">pop</code></td>
<td>
<p>an (optional) column with population identifiers</p>
</td></tr>
<tr><td><code id="write.struct_+3A_markernames">MARKERNAMES</code></td>
<td>
<p>whether to add a row  with marker names. If TRUE, takes the loci names from dat</p>
</td></tr>
<tr><td><code id="write.struct_+3A_missing">MISSING</code></td>
<td>
<p>The code for missing alleles</p>
</td></tr>
<tr><td><code id="write.struct_+3A_fname">fname</code></td>
<td>
<p>a string containing the file name (default to &quot;dat.str&quot;)</p>
</td></tr></table>


<h3>Value</h3>

<p>a text file in the structure format</p>


<h3>Author(s)</h3>

<p>Jerome Goudet <a href="mailto:jerome.goudet@unil.ch">jerome.goudet@unil.ch</a></p>


<h3>References</h3>

<p>Pritchard JK etal. 2000. Inference of population structure using multilocus genotype data. Genetics 155:945-959</p>

<hr>
<h2 id='yangex'>Example data set from Yang (1998) appendix</h2><span id='topic+yangex'></span>

<h3>Description</h3>

<p>Reproduce the example data set used in Yang's paper appendix. 
The genotype (column genot) is invented</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(exhier)
</code></pre>


<h3>Value</h3>

<table>
<tr><td><code>pop</code></td>
<td>
<p>outermost level</p>
</td></tr>
<tr><td><code>spop</code></td>
<td>
<p>sub pop level</p>
</td></tr>
<tr><td><code>sspop</code></td>
<td>
<p>sub sub pop level</p>
</td></tr>
<tr><td><code>genot</code></td>
<td>
<p>dummy diploid genotype</p>
</td></tr>
</table>


<h3>References</h3>

<p>Yang, R.C. (1998). Estimating hierarchical F-statistics. Evolution 52(4):950-956
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(yangex)
varcomp(yangex)
#the k matrix should be the same as matrix (A2) in Yang's appendix, p. 956
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
