<!DOCTYPE html><html><head><title>Help for package magclass</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {magclass}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#magclass-package'><p>Data Class and Tools for Handling Spatial-Temporal Data</p></a></li>
<li><a href='#add_columns'><p>add_columns</p></a></li>
<li><a href='#add_dimension'><p>add_dimension</p></a></li>
<li><a href='#as_tibble.magpie'><p>magpie method for tibble::as_tibble</p></a></li>
<li><a href='#as.array-methods'><p>~~ Methods for Function as.array ~~</p></a></li>
<li><a href='#as.data.frame-methods'><p>~~ Methods for Function as.data.frame ~~</p></a></li>
<li><a href='#as.RasterBrick'><p>as.RasterBrick</p></a></li>
<li><a href='#as.SpatRaster'><p>as.SpatRaster</p></a></li>
<li><a href='#as.SpatRasterDataset'><p>as.SpatRasterDataset</p></a></li>
<li><a href='#as.SpatVector'><p>as.SpatVector</p></a></li>
<li><a href='#clean_magpie'><p>MAgPIE-Clean</p></a></li>
<li><a href='#collapseDim'><p>Collapse dataset dimensions</p></a></li>
<li><a href='#collapseNames'><p>Collapse dataset names</p></a></li>
<li><a href='#colSums-methods'><p>~~ Methods for Function colSums and colMeans ~~</p></a></li>
<li><a href='#complete_magpie'><p>complete_magpie</p></a></li>
<li><a href='#convergence'><p>convergence</p></a></li>
<li><a href='#copy.attributes'><p>Copy Attributes</p></a></li>
<li><a href='#copy.magpie'><p>Copy MAgPIE-files</p></a></li>
<li><a href='#dimCode'><p>dimCode</p></a></li>
<li><a href='#dimExists'><p>dimExists</p></a></li>
<li><a href='#dimOrder'><p>dimOrder</p></a></li>
<li><a href='#dimReduce'><p>dimReduce</p></a></li>
<li><a href='#dimSums'><p>Summation over dimensions</p></a></li>
<li><a href='#escapeRegex'><p>escapeRegex</p></a></li>
<li><a href='#fulldim'><p>Reconstructs full dimensionality of MAgPIE objects</p></a></li>
<li><a href='#getCells'><p>Get Cells</p></a></li>
<li><a href='#getComment'><p>getComment</p></a></li>
<li><a href='#getCoords'><p>Get Coordinates</p></a></li>
<li><a href='#getCPR'><p>Get cells per region</p></a></li>
<li><a href='#getDim'><p>getDim</p></a></li>
<li><a href='#getItems'><p>Get Items</p></a></li>
<li><a href='#getNames'><p>Get dataset names</p></a></li>
<li><a href='#getRegionList'><p>Get a list of celluare region-belongings</p></a></li>
<li><a href='#getRegions'><p>Get regions</p></a></li>
<li><a href='#getSets'><p>Get sets</p></a></li>
<li><a href='#getYears'><p>Get years</p></a></li>
<li><a href='#hasCoords'><p>Has Coordinates</p></a></li>
<li><a href='#hasSets'><p>Has Sets</p></a></li>
<li><a href='#head.magpie'><p>head/tail</p></a></li>
<li><a href='#is.temporal'><p>is.temporal, is.spatial</p></a></li>
<li><a href='#isYear'><p>isYear</p></a></li>
<li><a href='#log-methods'><p>log-method for MAgPIE objects</p></a></li>
<li><a href='#lowpass'><p>Lowpass Filter</p></a></li>
<li><a href='#magclassdata'><p>magclassdata</p></a></li>
<li><a href='#magpie_expand'><p>magpie_expand</p></a></li>
<li><a href='#magpie_expand_dim'><p>magpie_expand_dim</p></a></li>
<li><a href='#magpie-class'><p>Class &quot;magpie&quot; ~~~</p></a></li>
<li><a href='#magpiesort'><p>MAgPIE-Sort</p></a></li>
<li><a href='#magpply'><p>magpply</p></a></li>
<li><a href='#maxample'><p>maxample</p></a></li>
<li><a href='#mbind'><p>mbind</p></a></li>
<li><a href='#mcalc'><p>mcalc</p></a></li>
<li><a href='#mselect'><p>MSelect</p></a></li>
<li><a href='#ncells'><p>Count elements</p></a></li>
<li><a href='#ndim'><p>Count sub-dimensions</p></a></li>
<li><a href='#new.magpie'><p>new.magpie</p></a></li>
<li><a href='#population_magpie'><p>population_magpie</p></a></li>
<li><a href='#print.magpie'><p>print</p></a></li>
<li><a href='#read.magpie'><p>Read MAgPIE-object from file</p></a></li>
<li><a href='#read.report'><p>Read file in report format</p></a></li>
<li><a href='#replace_non_finite'><p>Replace Non-Finite Data</p></a></li>
<li><a href='#round-methods'><p>Round-method for MAgPIE objects</p></a></li>
<li><a href='#rowSums-methods'><p>~~ Methods for Function rowSums and rowMeans ~~</p></a></li>
<li><a href='#setItems'><p>Set Items</p></a></li>
<li><a href='#setNames-methods'><p>Get dataset names</p></a></li>
<li><a href='#show-methods'><p>~~ Method for function <code>show</code> ~~</p></a></li>
<li><a href='#sizeCheck'><p>sizeCheck</p></a></li>
<li><a href='#spatRasterToDataset'><p>spatRasterToDataset</p></a></li>
<li><a href='#str.magpie'><p>str</p></a></li>
<li><a href='#suppressSpecificWarnings'><p>suppressSpecificWarnings</p></a></li>
<li><a href='#time_interpolate'><p>time_interpolate</p></a></li>
<li><a href='#unitsplit'><p>splits a data.frame or vector of strings with form 'variable (unit)' into</p>
a data.frame with variable and unit separated</a></li>
<li><a href='#unwrap'><p>Unwrap</p></a></li>
<li><a href='#where'><p>where</p></a></li>
<li><a href='#wrap'><p>Wrap</p></a></li>
<li><a href='#write.magpie'><p>Write MAgPIE-object to file</p></a></li>
<li><a href='#write.report'><p>Write file in report format</p></a></li>
<li><a href='#write.report2'><p>Write file in report format</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Data Class and Tools for Handling Spatial-Temporal Data</td>
</tr>
<tr>
<td>Version:</td>
<td>6.13.2</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-01-18</td>
</tr>
<tr>
<td>Description:</td>
<td>Data class for increased interoperability working with
    spatial-temporal data together with corresponding functions and
    methods (conversions, basic calculations and basic data manipulation).
    The class distinguishes between spatial, temporal and other dimensions
    to facilitate the development and interoperability of tools build for
    it. Additional features are name-based addressing of data and internal
    consistency checks (e.g. checking for the right data order in
    calculations).</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/LGPL-3">LGPL-3</a> | file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/pik-piam/magclass">https://github.com/pik-piam/magclass</a>,
<a href="https://doi.org/10.5281/zenodo.1158580">https://doi.org/10.5281/zenodo.1158580</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/pik-piam/magclass/issues">https://github.com/pik-piam/magclass/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10.0), methods</td>
</tr>
<tr>
<td>Imports:</td>
<td>abind, data.table, stats</td>
</tr>
<tr>
<td>Suggests:</td>
<td>covr, lpjmlkit, knitr, ncdf4, pkgconfig, quitte, raster,
rmarkdown, terra, testthat (&ge; 3.1.5), tibble, withr</td>
</tr>
<tr>
<td>Additional_repositories:</td>
<td><a href="https://pik-piam.r-universe.dev">https://pik-piam.r-universe.dev</a></td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.0</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-01-18 20:56:51 UTC; jpd</td>
</tr>
<tr>
<td>Author:</td>
<td>Jan Philipp Dietrich [aut, cre],
  Benjamin Leon Bodirsky [aut],
  Markus Bonsch [aut],
  Florian Humpenoeder [aut],
  Stephen Bi [aut],
  Kristine Karstens [aut],
  Debbora Leip [aut],
  Pascal Sauer [aut],
  Lavinia Baumstark [ctb],
  Christoph Bertram [ctb],
  Anastasis Giannousakis [ctb],
  David Klein [ctb],
  Ina Neher [ctb],
  Michaja Pehl [ctb],
  Anselm Schultes [ctb],
  Miodrag Stevanovic [ctb],
  Xiaoxi Wang [ctb],
  Felicitas Beier [ctb],
  Mika Pfl√ºger [ctb],
  Oliver Richters [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Jan Philipp Dietrich &lt;dietrich@pik-potsdam.de&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-01-19 00:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='magclass-package'>Data Class and Tools for Handling Spatial-Temporal Data</h2><span id='topic+magclass-package'></span><span id='topic+_PACKAGE'></span><span id='topic+magclass'></span>

<h3>Description</h3>

<p>Data class for increased interoperability working with spatial-temporal
data together with corresponding functions and methods (conversions,
basic calculations and basic data manipulation). The class distinguishes
between spatial, temporal and other dimensions to facilitate the development
and interoperability of tools build for it. Additional features are name-based
addressing of data and internal consistency checks (e.g. checking for the
right data order in calculations).
</p>


<h3>Author(s)</h3>

<p>Maintainer: Jan Philipp Dietrich &lt;dietrich@pik-potsdam.de&gt;
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/pik-piam/magclass">https://github.com/pik-piam/magclass</a>
</p>
</li>
<li> <p>doi: <a href="https://doi.org/10.5281/zenodo.1158580">10.5281/zenodo.1158580</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/pik-piam/magclass/issues">https://github.com/pik-piam/magclass/issues</a>
</p>
</li></ul>


<hr>
<h2 id='add_columns'>add_columns</h2><span id='topic+add_columns'></span>

<h3>Description</h3>

<p>Function adds new columns to the existing magpie object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_columns(x, addnm = "new", dim = 3.1, fill = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_columns_+3A_x">x</code></td>
<td>
<p>MAgPIE object which should be extended.</p>
</td></tr>
<tr><td><code id="add_columns_+3A_addnm">addnm</code></td>
<td>
<p>The new elements that should be added to the (sub)dimension</p>
</td></tr>
<tr><td><code id="add_columns_+3A_dim">dim</code></td>
<td>
<p>The (sub)dimension to be filled either identified via
name or dimension code (see <code><a href="#topic+dimCode">dimCode</a></code> for more information)</p>
</td></tr>
<tr><td><code id="add_columns_+3A_fill">fill</code></td>
<td>
<p>fill value of length 1 for the newly added columns (NA by default)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The extended MAgPIE object
</p>


<h3>Author(s)</h3>

<p>Jan Philipp Dietrich, Benjamin Bodirsky
</p>


<h3>See Also</h3>

<p><code><a href="#topic+add_dimension">add_dimension</a></code>,<code><a href="#topic+dimCode">dimCode</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>a &lt;- maxample("animal")
a2 &lt;- add_columns(a, addnm = c("horse", "magpie"), dim = "species", fill = 42)
getItems(a2, dim = 3)
getItems(a2, dim = 3, split = TRUE)
head(a2[, , "magpie"])
</code></pre>

<hr>
<h2 id='add_dimension'>add_dimension</h2><span id='topic+add_dimension'></span>

<h3>Description</h3>

<p>Function adds a name dimension as dimension number &quot;dim&quot; with the name &quot;add&quot;
with an empty data column with the name &quot;nm&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_dimension(x, dim = 3.1, add = NULL, nm = "dummy")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_dimension_+3A_x">x</code></td>
<td>
<p>MAgPIE object which should be extended.</p>
</td></tr>
<tr><td><code id="add_dimension_+3A_dim">dim</code></td>
<td>
<p>The dimension number of the new dimension (e.g. 3.1)</p>
</td></tr>
<tr><td><code id="add_dimension_+3A_add">add</code></td>
<td>
<p>The name of the new dimension</p>
</td></tr>
<tr><td><code id="add_dimension_+3A_nm">nm</code></td>
<td>
<p>The name of the first entry in dimension &quot;add&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The extended MAgPIE object
</p>


<h3>Author(s)</h3>

<p>Jan Philipp Dietrich, Benjamin Bodirsky
</p>


<h3>See Also</h3>

<p><code><a href="#topic+add_columns">add_columns</a></code>,<code><a href="#topic+mbind">mbind</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
a &lt;- maxample("animal")
str(add_dimension(a, dim = 3.2))
str(add_dimension(a, dim = 2.3, nm = paste0("d", 1:3)))
</code></pre>

<hr>
<h2 id='as_tibble.magpie'>magpie method for tibble::as_tibble</h2><span id='topic+as_tibble.magpie'></span>

<h3>Description</h3>

<p>magpie method for tibble::as_tibble
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_tibble.magpie(
  x,
  ...,
  .rows = NULL,
  .name_repair = c("check_unique", "unique", "universal", "minimal"),
  rownames = pkgconfig::get_config("tibble::rownames", NULL)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as_tibble.magpie_+3A_x">x</code></td>
<td>
<p>A magpie object</p>
</td></tr>
<tr><td><code id="as_tibble.magpie_+3A_...">...</code></td>
<td>
<p>Unused, for extensibility.</p>
</td></tr>
<tr><td><code id="as_tibble.magpie_+3A_.rows">.rows</code></td>
<td>
<p>The number of rows, useful to create a 0-column tibble or
just as an additional check.</p>
</td></tr>
<tr><td><code id="as_tibble.magpie_+3A_.name_repair">.name_repair</code></td>
<td>
<p>Treatment of problematic column names:
</p>

<ul>
<li> <p><code>"minimal"</code>: No name repair or checks, beyond basic existence,
</p>
</li>
<li> <p><code>"unique"</code>: Make sure names are unique and not empty,
</p>
</li>
<li> <p><code>"check_unique"</code>: (default value), no name repair, but check they are
<code>unique</code>,
</p>
</li>
<li> <p><code>"universal"</code>: Make the names <code>unique</code> and syntactic
</p>
</li>
<li><p> a function: apply custom name repair (e.g., <code>.name_repair = make.names</code>
for names in the style of base R).
</p>
</li>
<li><p> A purrr-style anonymous function, see <code><a href="rlang.html#topic+as_function">rlang::as_function()</a></code>
</p>
</li></ul>

<p>This argument is passed on as <code>repair</code> to <code><a href="vctrs.html#topic+vec_as_names">vctrs::vec_as_names()</a></code>.
See there for more details on these terms and the strategies used
to enforce them.</p>
</td></tr>
<tr><td><code id="as_tibble.magpie_+3A_rownames">rownames</code></td>
<td>
<p>How to treat existing row names of a data frame or matrix:
</p>

<ul>
<li> <p><code>NULL</code>: remove row names. This is the default.
</p>
</li>
<li> <p><code>NA</code>: keep row names.
</p>
</li>
<li><p> A string: the name of a new column. Existing rownames are transferred
into this column and the <code>row.names</code> attribute is deleted.
Read more in <a href="tibble.html#topic+rownames">rownames</a>.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>A tibble object
</p>

<hr>
<h2 id='as.array-methods'>~~ Methods for Function as.array ~~</h2><span id='topic+as.array-methods'></span><span id='topic+as.array+2CANY-method'></span><span id='topic+as.array+2Cmagpie-method'></span>

<h3>Description</h3>

<p>~~ Methods for function <code>as.array</code> ~~
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'magpie'
as.array(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.array-methods_+3A_x">x</code></td>
<td>
<p>object which should be converted to an array</p>
</td></tr>
</table>


<h3>Methods</h3>


<dl>
<dt>list(&quot;signature(x = \&quot;ANY\&quot;)&quot;)</dt><dd><p> standard as.array-method </p>
</dd>
<dt>list(&quot;signature(x = \&quot;magpie\&quot;)&quot;)</dt><dd><p> Conversion takes place just by
removing MAgPIE-object specific elements </p>
</dd> </dl>


<hr>
<h2 id='as.data.frame-methods'>~~ Methods for Function as.data.frame ~~</h2><span id='topic+as.data.frame-methods'></span><span id='topic+as.data.frame'></span><span id='topic+as.data.frame+2CANY-method'></span><span id='topic+as.data.frame+2Cmagpie-method'></span>

<h3>Description</h3>

<p>~~ Methods for function <code>as.data.frame</code> ~~
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'magpie'
as.data.frame(x, rev = 1, raw = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.data.frame-methods_+3A_x">x</code></td>
<td>
<p>A MAgPIE-object</p>
</td></tr>
<tr><td><code id="as.data.frame-methods_+3A_rev">rev</code></td>
<td>
<p>The revision of the algorithm that should be used for conversion.
rev=1 creates columns with the predefined names Cell, Region, Year, Data1,
Data2,... and Value, rev=2 uses the set names of the MAgPIE object for
naming and adds an attribute &quot;dimtype&quot; to the data.frame which contains
information about the types of the different columns (spatial, temporal,
data or value), rev=3 is identical to rev=2 except that characters are
not being converted to factors (stringsAsFactors = FALSE).</p>
</td></tr>
<tr><td><code id="as.data.frame-methods_+3A_raw">raw</code></td>
<td>
<p>Logical to control whether years beginning with &quot;y&quot; should be
converted to integers (without &quot;y&quot;) and coordinates should be converted to
numerics. If set to raw columns are returned as they are in the initial
object.</p>
</td></tr>
</table>


<h3>Methods</h3>


<dl>
<dt>list(&quot;signature(x = \&quot;magpie\&quot;)&quot;)</dt><dd><p> Conversion creates columns for
Cell, Region, Year, Data1, Data2,... and Value </p>
</dd> </dl>



<h3>Examples</h3>

<pre><code class='language-R'>
pop &lt;- maxample("pop")
head(as.data.frame(pop))
head(as.data.frame(pop, rev = 2))

a &lt;- maxample("animal")
head(as.data.frame(a, rev = 3))
head(as.data.frame(a, rev = 3, raw = TRUE))
attr(as.data.frame(a, rev = 3), "dimtype")

</code></pre>

<hr>
<h2 id='as.RasterBrick'>as.RasterBrick</h2><span id='topic+as.RasterBrick'></span>

<h3>Description</h3>

<p>Convert magclass object to a RasterBrick object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.RasterBrick(x, res = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.RasterBrick_+3A_x">x</code></td>
<td>
<p>MAgPIE object</p>
</td></tr>
<tr><td><code id="as.RasterBrick_+3A_res">res</code></td>
<td>
<p>spatial data resolution. If not provided it will be guessed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A RasterBrick object
</p>


<h3>Author(s)</h3>

<p>Jan Philipp Dietrich
</p>


<h3>See Also</h3>

<p><code><a href="#topic+getCoords">getCoords</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
if (requireNamespace("raster", quietly = TRUE)) {
   r &lt;- raster::brick(ncols = 36, nrows = 18, nl = 4)
   r[14:18, 25:28] &lt;- (1:20 %*% t(1:4))
   names(r) &lt;- c("y2000..bla", "y2001..bla", "y2000..blub", "y2001..blub")
   m &lt;- as.magpie(r)
   r2 &lt;- as.RasterBrick(m)
}

## End(Not run)
</code></pre>

<hr>
<h2 id='as.SpatRaster'>as.SpatRaster</h2><span id='topic+as.SpatRaster'></span>

<h3>Description</h3>

<p>Convert magclass object to a SpatRaster object. Requires the terra package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.SpatRaster(x, res = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.SpatRaster_+3A_x">x</code></td>
<td>
<p>MAgPIE object</p>
</td></tr>
<tr><td><code id="as.SpatRaster_+3A_res">res</code></td>
<td>
<p>spatial data resolution. If not provided it will be guessed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A SpatRaster object
</p>


<h3>Author(s)</h3>

<p>Jan Philipp Dietrich
</p>


<h3>See Also</h3>

<p><code><a href="#topic+getCoords">getCoords</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (requireNamespace("terra", quietly = TRUE)) {
   r &lt;- terra::rast(ncols = 360, nrows = 180, nl = 4)
   r[85:89, 176:179] &lt;- (1:20 %*% t(1:4))
   r[15:19, 76:79] &lt;-   (10 + 1:20 %*% t(1:4))
   names(r) &lt;- c("y2000..bla", "y2001..bla", "y2000..blub", "y2001..blub")
   m &lt;- as.magpie(r)
   r2 &lt;- as.SpatRaster(m)
}
</code></pre>

<hr>
<h2 id='as.SpatRasterDataset'>as.SpatRasterDataset</h2><span id='topic+as.SpatRasterDataset'></span>

<h3>Description</h3>

<p>Convert magclass object to a SpatRasterDataset object. Requires the terra package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.SpatRasterDataset(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.SpatRasterDataset_+3A_...">...</code></td>
<td>
<p>arguments passed to as.SpatRaster</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Calls <code><a href="#topic+as.SpatRaster">as.SpatRaster</a></code> and then <code><a href="#topic+spatRasterToDataset">spatRasterToDataset</a></code>.
</p>


<h3>Value</h3>

<p>A SpatRasterDataset object
</p>


<h3>Author(s)</h3>

<p>Pascal Sauer
</p>

<hr>
<h2 id='as.SpatVector'>as.SpatVector</h2><span id='topic+as.SpatVector'></span>

<h3>Description</h3>

<p>Convert magclass object to a SpatVector object. Requires the terra package and
requires the magclass object to provide the geometry of the spatial entities
as &quot;geometry&quot; attribute in &quot;WKT&quot; format. (see object &quot;m&quot; in example).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.SpatVector(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.SpatVector_+3A_x">x</code></td>
<td>
<p>MAgPIE object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A SpatVector object
</p>


<h3>Author(s)</h3>

<p>Jan Philipp Dietrich
</p>


<h3>See Also</h3>

<p><code><a href="#topic+as.SpatRaster">as.SpatRaster</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (requireNamespace("terra", quietly = TRUE)) {
   r &lt;- terra::rast(ncols = 360, nrows = 180, nl = 4)
   r[85:89, 176:179] &lt;- (1:20 %*% t(1:4))
   r[15:19, 76:79] &lt;-   (10 + 1:20 %*% t(1:4))
   names(r) &lt;- c("y2000..bla", "y2001..bla", "y2000..blub", "y2001..blub")
   v &lt;- terra::as.polygons(r)
   m &lt;- as.magpie(v)
   attr(m, "geometry")
   attr(m, "crs")
   v2 &lt;- as.SpatVector(m)
}
</code></pre>

<hr>
<h2 id='clean_magpie'>MAgPIE-Clean</h2><span id='topic+clean_magpie'></span>

<h3>Description</h3>

<p>Function cleans MAgPIE objects so that they follow some extended magpie
object rules (currently it makes sure that the dimnames have names and
removes cell numbers if it is purely regional data)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clean_magpie(x, what = "all", maindim = 1:3)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="clean_magpie_+3A_x">x</code></td>
<td>
<p>MAgPIE object which should be cleaned.</p>
</td></tr>
<tr><td><code id="clean_magpie_+3A_what">what</code></td>
<td>
<p>term defining what type of cleaning should be performed. Current
modes are &quot;cells&quot; (removes cell numbers if the data seems to be regional -
this should be used carefully as it might remove cell numbers in some cases
in which they should not be removed), &quot;sets&quot; (making sure that all
dimensions have names), &quot;items&quot; (replace empty elements with single spaces &quot; &quot;)
and &quot;all&quot; (performing all available cleaning methods)</p>
</td></tr>
<tr><td><code id="clean_magpie_+3A_maindim">maindim</code></td>
<td>
<p>main dimension(s)  the cleaning should get applied to.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The eventually corrected MAgPIE object
</p>


<h3>Author(s)</h3>

<p>Jan Philipp Dietrich
</p>


<h3>See Also</h3>

<p><code>"<a href="#topic+magpie-class">magpie</a>"</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
pop &lt;- maxample("pop")
a &lt;- clean_magpie(pop)
</code></pre>

<hr>
<h2 id='collapseDim'>Collapse dataset dimensions</h2><span id='topic+collapseDim'></span>

<h3>Description</h3>

<p>This function will remove names in the data dimension which are the same for
each element (meaning that this data dimension contains exactly one element)
or, if forced, remove any other subdimension. It is a generalized version
of the function <code><a href="#topic+collapseNames">collapseNames</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>collapseDim(x, dim = NULL, keepdim = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="collapseDim_+3A_x">x</code></td>
<td>
<p>MAgPIE object</p>
</td></tr>
<tr><td><code id="collapseDim_+3A_dim">dim</code></td>
<td>
<p>Either NULL, dimension code or
name of dimension or a vector of these. If set to NULL all single entry subdimensions will
be removed as they are irrelevant to uniquely identfy a data element. If specified, only the specified
subdimensions will be removed (See <code><a href="#topic+dimCode">dimCode</a></code> for more details how to specify a subdimension).
CAUTION: The function also allows to specify subdimensions which are otherwise needed to clearly identify
an entry. By removing these subdimensions duplicates in the data will be created potentially causing
problems in the further use of the data set. Be careful in removing subdimensions.</p>
</td></tr>
<tr><td><code id="collapseDim_+3A_keepdim">keepdim</code></td>
<td>
<p>(only considered if <code>dim</code> is not specified) Can be used to converse
single element subdimension which otherwise would get deleted. If <code>dim</code> is specified
this setting will not have any effect.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The provided MAgPIE object with collapsed dimensions
</p>


<h3>Note</h3>

<p>This function has some similarities to <code><a href="#topic+dimReduce">dimReduce</a></code>, but
serves a different purpose. While <code><a href="#topic+collapseDim">collapseDim</a></code> only removes
dimensions which contain only a single element or which it is
specifically told to remove, <code><a href="#topic+dimReduce">dimReduce</a></code> looks whether the
entries of a multi-entry dimension are all the same and removes dimensions
for which this is the case. In some cases both will lead to the same result
but in many other cases the results will differ.
</p>


<h3>Author(s)</h3>

<p>Jan Philipp Dietrich
</p>


<h3>See Also</h3>

<p><code><a href="#topic+getItems">getItems</a></code>
<code>"<a href="#topic+magpie-class">magpie</a>"</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- new.magpie(c("GLO.1", "GLO.2"), 2000, c("bla.a", "bla.b"))
collapseDim(x)
collapseDim(x, keepdim = 1:2)
collapseDim(x, dim = 1.1)
collapseDim(x, dim = 3.2)
</code></pre>

<hr>
<h2 id='collapseNames'>Collapse dataset names</h2><span id='topic+collapseNames'></span>

<h3>Description</h3>

<p>This function has been superseded by <code><a href="#topic+collapseDim">collapseDim</a></code> which is a
more generalized version of this function. Please use this one instead!
</p>


<h3>Usage</h3>

<pre><code class='language-R'>collapseNames(x, collapsedim = NULL, preservedim = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="collapseNames_+3A_x">x</code></td>
<td>
<p>MAgPIE object</p>
</td></tr>
<tr><td><code id="collapseNames_+3A_collapsedim">collapsedim</code></td>
<td>
<p>If you want to remove the names of particular dimensions
provide the dimensions here. Since the function only works in the third dimension,
you have to count from there on (e.g. dim = 3.2 refers to collapsedim = 2).
Alternatively, you can also specify the name of the dimension. Default: NULL.
CAUTION with parameter collapsedim! You could also force him to remove dimnames,
which are NOT the same for each element and so create duplicates in dimnames.</p>
</td></tr>
<tr><td><code id="collapseNames_+3A_preservedim">preservedim</code></td>
<td>
<p>If you want to remove the name of particular dimensions except some,
you can specify the dimension(s) to preserve here. See collapsedim for naming convention.
Note that preservedim will be ignored in the case, of a specified collapsedim</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function will remove names in the data dimension which are the same for
each element (meaning that this data dimension contains exactly one element)
</p>


<h3>Value</h3>

<p>The provided MAgPIE object with collapsed names
</p>


<h3>Author(s)</h3>

<p>Jan Philipp Dietrich, David Klein, Xiaoxi Wang
</p>


<h3>See Also</h3>

<p><code><a href="#topic+collapseDim">collapseDim</a></code>, <code><a href="#topic+getItems">getItems</a></code>,
<code>"<a href="#topic+magpie-class">magpie</a>"</code>
</p>

<hr>
<h2 id='colSums-methods'>~~ Methods for Function colSums and colMeans ~~</h2><span id='topic+colSums-methods'></span><span id='topic+colSums+2CANY-method'></span><span id='topic+colSums+2Cmagpie-method'></span><span id='topic+colMeans-methods'></span><span id='topic+colMeans+2CANY-method'></span><span id='topic+colMeans+2Cmagpie-method'></span>

<h3>Description</h3>

<p>~~ Methods for function <code>colSums</code> and <code>colMeans</code> ~~
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'magpie'
colSums(x, na.rm = FALSE, dims = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="colSums-methods_+3A_x">x</code></td>
<td>
<p>object on which calculation should be performed</p>
</td></tr>
<tr><td><code id="colSums-methods_+3A_na.rm">na.rm</code></td>
<td>
<p>logical. Should missing values (including NaN) be omitted from the calculations?</p>
</td></tr>
<tr><td><code id="colSums-methods_+3A_dims">dims</code></td>
<td>
<p>integer: Which dimensions are regarded as &quot;rows&quot; or &quot;columns&quot; to sum over. For row*,
the sum or mean is over dimensions dims+1, ...; for col* it is over dimensions 1:dims.</p>
</td></tr>
<tr><td><code id="colSums-methods_+3A_...">...</code></td>
<td>
<p>further arguments passed to other colSums/colMeans methods</p>
</td></tr>
</table>


<h3>Methods</h3>


<dl>
<dt>list(&quot;signature(x = \&quot;ANY\&quot;)&quot;)</dt><dd><p> normal colSums and colMeans method </p>
</dd>
<dt>list(&quot;signature(x = \&quot;magpie\&quot;)&quot;)</dt><dd><p> classical method prepared to
handle MAgPIE objects </p>
</dd> </dl>


<hr>
<h2 id='complete_magpie'>complete_magpie</h2><span id='topic+complete_magpie'></span>

<h3>Description</h3>

<p>MAgPIE objects can be incomplete to reduce memory. This function blows up a
magpie object to its real dimensions, so you can apply unwrap.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>complete_magpie(x, fill = NA, dim = 3)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="complete_magpie_+3A_x">x</code></td>
<td>
<p>MAgPIE object which should be completed.</p>
</td></tr>
<tr><td><code id="complete_magpie_+3A_fill">fill</code></td>
<td>
<p>Value that shall be written into the missing entries</p>
</td></tr>
<tr><td><code id="complete_magpie_+3A_dim">dim</code></td>
<td>
<p>dimensions in which the completion should take place (1, 2 and/or 3). For
full completion use <code>1:3</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>The completed MAgPIE object
</p>


<h3>Author(s)</h3>

<p>Jan Philipp Dietrich, Benjamin Bodirsky
</p>


<h3>See Also</h3>

<p><code><a href="#topic+add_dimension">add_dimension</a></code>,<code><a href="#topic+clean_magpie">clean_magpie</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
pop &lt;- maxample("pop")
complete_magpie(pop)

ani &lt;- maxample("animal")
complete_magpie(ani)
</code></pre>

<hr>
<h2 id='convergence'>convergence</h2><span id='topic+convergence'></span>

<h3>Description</h3>

<p>Cross-Fades the values of one MAGPIE object into the values of another over
a certain time
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convergence(
  origin,
  aim,
  start_year = NULL,
  end_year = NULL,
  direction = NULL,
  type = "smooth",
  par = 1.5
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="convergence_+3A_origin">origin</code></td>
<td>
<p>an object with one name-column</p>
</td></tr>
<tr><td><code id="convergence_+3A_aim">aim</code></td>
<td>
<p>Can be twofold: An magpie object or a numeric value.</p>
</td></tr>
<tr><td><code id="convergence_+3A_start_year">start_year</code></td>
<td>
<p>year in which the convergence from origin to aim starts.
If set to NULL the the first year of aim is used as start_year</p>
</td></tr>
<tr><td><code id="convergence_+3A_end_year">end_year</code></td>
<td>
<p>year in which the convergence from origin to aim shall be
(nearly) reached. If set to NULL the the last year of aim is used as
end_year.</p>
</td></tr>
<tr><td><code id="convergence_+3A_direction">direction</code></td>
<td>
<p>NULL, &quot;up&quot; or &quot;down&quot;. NULL means normal convergence in both
directions, &quot;up&quot; is only a convergence if origin&lt;aim, &quot;down&quot; means only a
convergence if origin&gt;aim</p>
</td></tr>
<tr><td><code id="convergence_+3A_type">type</code></td>
<td>
<p>&quot;smooth&quot;, &quot;s&quot;, &quot;linear&quot; or &quot;decay&quot;. Describes the type of
convergence: linear means a linear conversion , s is an s-curve which starts
from origin in start_year and reaches aim precisely in end_year. After 50
percent of the convergence time, it reaches about the middle of the two
values. Its based on the function min(1, pos^4/(0.07+pos^4)*1.07) smooth is
a conversion based on the function x^3/(0.1+x^3).  In the latter case only
90% of convergence will be reached in the end year, because full
convergence is reached in infinity.  decay is a conversion based on the
function x/(1.5 + x)*2.5.</p>
</td></tr>
<tr><td><code id="convergence_+3A_par">par</code></td>
<td>
<p>parameter value for convergence function; currently only used for
type=&quot;decay&quot;</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns a time-series with the same timesteps as origin, which
lineary fades into the values of the aim object
</p>


<h3>Author(s)</h3>

<p>Benjamin Bodirsky, Jan Philipp Dietrich
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
pop &lt;- maxample("pop")
population &lt;- add_columns(pop, "MIX")
population[, , "MIX"] &lt;- convergence(population[, , "A2"], population[, , "B1"])
</code></pre>

<hr>
<h2 id='copy.attributes'>Copy Attributes</h2><span id='topic+copy.attributes'></span><span id='topic+copy.attributes+3C-'></span>

<h3>Description</h3>

<p>This function copies attributes from one object and assigns them to another.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>copy.attributes(
  from,
  to,
  delete = c("names", "row.names", "class", "dim", "dimnames"),
  delete2 = NULL
)

copy.attributes(
  to,
  delete = c("names", "row.names", "class", "dim", "dimnames"),
  delete2 = NULL
) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="copy.attributes_+3A_from">from</code></td>
<td>
<p>object from which the attributes should be taken</p>
</td></tr>
<tr><td><code id="copy.attributes_+3A_to">to</code></td>
<td>
<p>object to which the attributes should be written</p>
</td></tr>
<tr><td><code id="copy.attributes_+3A_delete">delete</code></td>
<td>
<p>attributes which should not be copied. By default this are
class specific attributes which might cause problems if copied to another
object. But you can add or remove attributes from the vector.</p>
</td></tr>
<tr><td><code id="copy.attributes_+3A_delete2">delete2</code></td>
<td>
<p>Identical to delete and just added for convenience for the
case that you want to delete additional attributes but do not want to repeat
the vector given in delete. In the function both vectors, delete and
delete2, are just merged to one deletion vector.</p>
</td></tr>
<tr><td><code id="copy.attributes_+3A_value">value</code></td>
<td>
<p>Same as &quot;from&quot; (object from which the attributes should be
taken)</p>
</td></tr>
</table>


<h3>Functions</h3>


<ul>
<li> <p><code>copy.attributes(
  to,
  delete = c("names", "row.names", "class", "dim", "dimnames"),
  delete2 = NULL
) &lt;- value</code>: assign attributes from object &quot;value&quot;
</p>
</li></ul>


<h3>Author(s)</h3>

<p>Jan Philipp Dietrich
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
from &lt;- array(12)
attr(from,"blablub") &lt;- "I am an attribute!"
attr(from,"blablub2") &lt;- "I am another attribute!"

print(attributes(from))

to &lt;- as.magpie(0)
print(attributes(to))

copy.attributes(to) &lt;- from
print(attributes(to))

</code></pre>

<hr>
<h2 id='copy.magpie'>Copy MAgPIE-files</h2><span id='topic+copy.magpie'></span>

<h3>Description</h3>

<p>This function copies MAgPIE-files from one location to another. During the
copying it is also possible to change the file type (e.g. from 'mz' to
'csv')
</p>


<h3>Usage</h3>

<pre><code class='language-R'>copy.magpie(input_file, output_file, round = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="copy.magpie_+3A_input_file">input_file</code></td>
<td>
<p>file, that should be copied</p>
</td></tr>
<tr><td><code id="copy.magpie_+3A_output_file">output_file</code></td>
<td>
<p>copy destination</p>
</td></tr>
<tr><td><code id="copy.magpie_+3A_round">round</code></td>
<td>
<p>number of digits the values should be rounded. NULL means no rounding</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jan Philipp Dietrich
</p>


<h3>See Also</h3>

<p><code><a href="#topic+read.magpie">read.magpie</a></code>,<code><a href="#topic+write.magpie">write.magpie</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# copy.magpie("bla.csv","blub.mz")
</code></pre>

<hr>
<h2 id='dimCode'>dimCode</h2><span id='topic+dimCode'></span>

<h3>Description</h3>

<p>Function converts a dimension name or number to a dimension Code used for
MAgPIE objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dimCode(dim, x, missing = 0, strict = FALSE, sep = ".")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dimCode_+3A_dim">dim</code></td>
<td>
<p>A vector of dimension numbers or dimension names which should be
translated</p>
</td></tr>
<tr><td><code id="dimCode_+3A_x">x</code></td>
<td>
<p>MAgPIE object in which the dimensions should be searched for.</p>
</td></tr>
<tr><td><code id="dimCode_+3A_missing">missing</code></td>
<td>
<p>Either a value to which a dimension should be set in case
that it is not found (default is 0), or &quot;stop&quot; indicating that the function
should throw an error in these cases.</p>
</td></tr>
<tr><td><code id="dimCode_+3A_strict">strict</code></td>
<td>
<p>if set to TRUE also properly set dimension names which refer
to non-existing subdimensions will be treated as missing, otherwise these
dimension codes will be returned, even if the subdimension does not exist</p>
</td></tr>
<tr><td><code id="dimCode_+3A_sep">sep</code></td>
<td>
<p>A character separating joined dimension names</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dimension code identifying the dimension. Either a integer which
represents the main dimensions (1=spatial, 2=temporal, 3=data) or a numeric,
representing the subdimensions of a dimension (e.g. 3.2 for the second data
dimension).
</p>


<h3>Author(s)</h3>

<p>Jan Philipp Dietrich, Kristine Karstens
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mselect">mselect</a></code>, <code><a href="#topic+getDim">getDim</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
pop &lt;- maxample("pop")
dimCode(c("t", "scenario", "blablub"), pop)
</code></pre>

<hr>
<h2 id='dimExists'>dimExists</h2><span id='topic+dimExists'></span>

<h3>Description</h3>

<p>Function checks whether a dimension exsist in a
MAgPIE objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dimExists(dim, x, sep = ".")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dimExists_+3A_dim">dim</code></td>
<td>
<p>A vector of dimension numbers or dimension names which should be
checked for</p>
</td></tr>
<tr><td><code id="dimExists_+3A_x">x</code></td>
<td>
<p>MAgPIE object in which the dimensions should be searched for.</p>
</td></tr>
<tr><td><code id="dimExists_+3A_sep">sep</code></td>
<td>
<p>A character separating joined dimension names</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Boolean indicating whether dimension exists or not
</p>


<h3>Author(s)</h3>

<p>Jan Philipp Dietrich
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dimCode">dimCode</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
pop &lt;- maxample("pop")
dimExists(c("t","scenario","blablub"),pop)

</code></pre>

<hr>
<h2 id='dimOrder'>dimOrder</h2><span id='topic+dimOrder'></span>

<h3>Description</h3>

<p>Changes the order of the sub-dimension in a magpie object
similar to unwrapping and applying the aperm command, but more efficient.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dimOrder(x, perm, dim = 3)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dimOrder_+3A_x">x</code></td>
<td>
<p>magpie object</p>
</td></tr>
<tr><td><code id="dimOrder_+3A_perm">perm</code></td>
<td>
<p>vector with the new order of the sub-dimension. Missing
sub-dimensions will added automatically at the end</p>
</td></tr>
<tr><td><code id="dimOrder_+3A_dim">dim</code></td>
<td>
<p>main dimension in which the order of sub-dimensions should
be changed (1, 2 or 3)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>magpie object
</p>


<h3>Author(s)</h3>

<p>Jan Philipp Dietrich, Benjamin Leon Bodirsky
</p>


<h3>Examples</h3>

<pre><code class='language-R'>a &lt;- maxample("animal")
head(a)
head(dimOrder(a, perm = 3:1, dim = 1))
head(dimOrder(a, perm = c(2,1,3), dim = 3))
</code></pre>

<hr>
<h2 id='dimReduce'>dimReduce</h2><span id='topic+dimReduce'></span>

<h3>Description</h3>

<p>Remove dimensions which contain identical data for all elements in it
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dimReduce(x, dim_exclude = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dimReduce_+3A_x">x</code></td>
<td>
<p>MAgPIE object which should be reduced</p>
</td></tr>
<tr><td><code id="dimReduce_+3A_dim_exclude">dim_exclude</code></td>
<td>
<p>Vector with names of dimensions which must not be reduced</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The reduced MAgPIE object
</p>


<h3>Note</h3>

<p>This function has some similarities to <code><a href="#topic+collapseDim">collapseDim</a></code>, but
serves a different purpose. While <code><a href="#topic+collapseDim">collapseDim</a></code> only removes
dimensions which contain only a single element or which it is
specifically told to remove, <code><a href="#topic+dimReduce">dimReduce</a></code> looks whether the
entries of a multi-entry dimension are all the same and removes dimensions
for which this is the case. In some cases both will lead to the same result
but in many other cases the results will differ.
</p>


<h3>Author(s)</h3>

<p>Jan Philipp Dietrich
</p>


<h3>See Also</h3>

<p><code><a href="#topic+add_dimension">add_dimension</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# create data with 5 identical scenarios
p &lt;- add_dimension(maxample("pop")[1:3, 1:3, ], nm = paste0("scen", 1:2))
str(p)
str(dimReduce(p))

# set years to same value
p[, , ] &lt;- setYears(p[, 1, ], NULL)
str(p)
str(dimReduce(p))

# set regions to same value
p[, , ] &lt;- setCells(p[1, , ], "GLO")
str(p)
str(dimReduce(p))
</code></pre>

<hr>
<h2 id='dimSums'>Summation over dimensions</h2><span id='topic+dimSums'></span>

<h3>Description</h3>

<p>This function sums over any (sub-)dimension of a magpie object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dimSums(x, dim = 3, na.rm = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dimSums_+3A_x">x</code></td>
<td>
<p>A MAgPIE-object</p>
</td></tr>
<tr><td><code id="dimSums_+3A_dim">dim</code></td>
<td>
<p>The dimensions(s) to sum over. A vector of dimension codes or dimension names.
See <code><a href="#topic+dimCode">dimCode</a></code> for more information</p>
</td></tr>
<tr><td><code id="dimSums_+3A_na.rm">na.rm</code></td>
<td>
<p>logical. Should missing values (including NaN) be omitted from
the calculations?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A MAgPIE object with values summed over the specified dimensions
</p>


<h3>Author(s)</h3>

<p>Jan Philipp Dietrich
</p>


<h3>See Also</h3>

<p><code><a href="Matrix.html#topic+rowSums">rowSums</a></code>, <code><a href="#topic+getItems">getItems</a></code>, <code><a href="#topic+dimCode">dimCode</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>a &lt;- maxample("animal")
dimSums(a, dim = c(1, 2, 3.2))
dimSums(a, dim = c("x", "y", "cell", "month"))
</code></pre>

<hr>
<h2 id='escapeRegex'>escapeRegex</h2><span id='topic+escapeRegex'></span>

<h3>Description</h3>

<p>Escapes all symbols in a string which have a special meaning in regular
expressions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>escapeRegex(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="escapeRegex_+3A_x">x</code></td>
<td>
<p>String or vector of strings that should be escaped.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The escaped strings.
</p>


<h3>Author(s)</h3>

<p>Jan Philipp Dietrich
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+grep">grep</a></code>
</p>

<hr>
<h2 id='fulldim'>Reconstructs full dimensionality of MAgPIE objects</h2><span id='topic+fulldim'></span>

<h3>Description</h3>

<p>If a MAgPIE object is created from a source with more than one data
dimension, these data dimensions are combined to a single dimension. fulldim
reconstructs the original dimensionality and reports it.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fulldim(x, sep = ".")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fulldim_+3A_x">x</code></td>
<td>
<p>A MAgPIE-object</p>
</td></tr>
<tr><td><code id="fulldim_+3A_sep">sep</code></td>
<td>
<p>A character separating joined dimension names</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing in the first element the dim output and in the
second element the dimnames output of the reconstructed array.
</p>


<h3>Author(s)</h3>

<p>Jan Philipp Dietrich
</p>


<h3>See Also</h3>

<p><code><a href="#topic+as.magpie">as.magpie</a></code>,<code><a href="#topic+unwrap">unwrap</a></code>,<code><a href="#topic+wrap">wrap</a></code>
</p>

<hr>
<h2 id='getCells'>Get Cells</h2><span id='topic+getCells'></span><span id='topic+getCells+3C-'></span><span id='topic+setCells'></span>

<h3>Description</h3>

<p>Extracts cell names of a MAgPIE-object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getCells(x)

getCells(x) &lt;- value

setCells(object, nm = "GLO")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getCells_+3A_x">x</code>, <code id="getCells_+3A_object">object</code></td>
<td>
<p>MAgPIE object</p>
</td></tr>
<tr><td><code id="getCells_+3A_value">value</code>, <code id="getCells_+3A_nm">nm</code></td>
<td>
<p>cell names the data should be set to.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>setCells is a shortcut to use a MAgPIE object with manipulated cell names.
setCells uses the variable names &quot;object&quot; and &quot;nm&quot; in order to be consistent
to the already existing function setNames.
</p>


<h3>Value</h3>

<p>getCells returns cell names of the MAgPIE-object, whereas setCells
returns the MAgPIE object with the manipulated cell names.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>getCells(x) &lt;- value</code>: set cell names
</p>
</li>
<li> <p><code>setCells()</code>: set cell names
</p>
</li></ul>


<h3>Author(s)</h3>

<p>Jan Philipp Dietrich
</p>


<h3>See Also</h3>

<p><code><a href="#topic+getRegions">getRegions</a></code>, <code><a href="#topic+getNames">getNames</a></code>,
<code><a href="#topic+setNames">setNames</a></code>, <code><a href="#topic+getCPR">getCPR</a></code>, <code><a href="#topic+read.magpie">read.magpie</a></code>,
<code><a href="#topic+write.magpie">write.magpie</a></code>, <code>"<a href="#topic+magpie-class">magpie</a>"</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
a &lt;- as.magpie(1)
 getCells(a)
 setCells(a, "AFR")
</code></pre>

<hr>
<h2 id='getComment'>getComment</h2><span id='topic+getComment'></span><span id='topic+getComment+3C-'></span><span id='topic+setComment'></span>

<h3>Description</h3>

<p>Extracts the comment from a MAgPIE-object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getComment(x)

getComment(x) &lt;- value

setComment(object, nm = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getComment_+3A_x">x</code>, <code id="getComment_+3A_object">object</code></td>
<td>
<p>MAgPIE object</p>
</td></tr>
<tr><td><code id="getComment_+3A_value">value</code>, <code id="getComment_+3A_nm">nm</code></td>
<td>
<p>A vector containing the comment.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>getComment returns the comment attached to a MAgPIE-object, NULL if
no comment is present. setComment returns the magpie object with the
modified comment.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>getComment(x) &lt;- value</code>: set comment
</p>
</li>
<li> <p><code>setComment()</code>: set comment
</p>
</li></ul>


<h3>Author(s)</h3>

<p>Markus Bonsch
</p>


<h3>See Also</h3>

<p><code><a href="#topic+getRegions">getRegions</a></code>, <code><a href="#topic+getNames">getNames</a></code>,
<code><a href="#topic+getYears">getYears</a></code>, <code><a href="#topic+getCPR">getCPR</a></code>, <code><a href="#topic+read.magpie">read.magpie</a></code>,
<code><a href="#topic+write.magpie">write.magpie</a></code>, <code>"<a href="#topic+magpie-class">magpie</a>"</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
 a &lt;- as.magpie(1)
 #returns NULL
 getComment(a)
 #set the comment
 getComment(a)&lt;-c("bla","blubb")
 getComment(a)

</code></pre>

<hr>
<h2 id='getCoords'>Get Coordinates</h2><span id='topic+getCoords'></span><span id='topic+getCoords+3C-'></span>

<h3>Description</h3>

<p>Extracts spatial coordinates of a MAgPIE-object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getCoords(x, xlab = "x", ylab = "y")

getCoords(x, xlab = "x", ylab = "y") &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getCoords_+3A_x">x</code></td>
<td>
<p>MAgPIE object</p>
</td></tr>
<tr><td><code id="getCoords_+3A_xlab">xlab</code></td>
<td>
<p>label of x-dimension</p>
</td></tr>
<tr><td><code id="getCoords_+3A_ylab">ylab</code></td>
<td>
<p>label of y-dimension</p>
</td></tr>
<tr><td><code id="getCoords_+3A_value">value</code></td>
<td>
<p>coordinates as two column data.frame the data should be set to
(first column = x, second column = y).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>coordinates of the MAgPIE-object
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>getCoords(x, xlab = "x", ylab = "y") &lt;- value</code>: set coordinates
</p>
</li></ul>


<h3>Author(s)</h3>

<p>Jan Philipp Dietrich
</p>


<h3>See Also</h3>

<p><code><a href="#topic+as.RasterBrick">as.RasterBrick</a></code>, <code><a href="#topic+getItems">getItems</a></code>, <code>"<a href="#topic+magpie-class">magpie</a>"</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>a &lt;- maxample("animal")
getCoords(a)
</code></pre>

<hr>
<h2 id='getCPR'>Get cells per region</h2><span id='topic+getCPR'></span>

<h3>Description</h3>

<p>Counts how often each element of the provided subdimension exists in the given
data set. Originally created to count the number of cells in a region (this
is also where its name originates from) it can now be used to count elements
of any subdimension via the dim argument.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getCPR(x, dim = 1.1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getCPR_+3A_x">x</code></td>
<td>
<p>MAgPIE object or a resolution written as numeric (currently only
data for 0.5 degree resolution is available).</p>
</td></tr>
<tr><td><code id="getCPR_+3A_dim">dim</code></td>
<td>
<p>Dimension for which the items should be returned. Either number or
name of dimension or a vector of these (in case of a vector all subimensions
must belong to the same main dimension!). See <code><a href="#topic+dimCode">dimCode</a></code> for more details.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>cells per region
</p>


<h3>Author(s)</h3>

<p>Jan Philipp Dietrich
</p>


<h3>See Also</h3>

<p><code><a href="#topic+getRegions">getRegions</a></code>, <code><a href="#topic+read.magpie">read.magpie</a></code>,
<code><a href="#topic+write.magpie">write.magpie</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
getCPR(0.5)
a &lt;- maxample("animal")
getCPR(a, dim = "color")
getCPR(a, dim = 3.2)
getCPR(a, dim = "country")
getCPR(a, dim = c("color", "species"))
</code></pre>

<hr>
<h2 id='getDim'>getDim</h2><span id='topic+getDim'></span>

<h3>Description</h3>

<p>Function which tries to detect the dimension to which the given elems belong
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getDim(elems, x, fullmatch = FALSE, dimCode = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getDim_+3A_elems">elems</code></td>
<td>
<p>A vector of characters containing the elements that should be
found in the MAgPIE object</p>
</td></tr>
<tr><td><code id="getDim_+3A_x">x</code></td>
<td>
<p>MAgPIE object in which elems should be searched for.</p>
</td></tr>
<tr><td><code id="getDim_+3A_fullmatch">fullmatch</code></td>
<td>
<p>If enabled, only dimensions which match exactly the elements
provided will be returned. Otherwise, it is sufficient if elems contains a subset
of the dimension.</p>
</td></tr>
<tr><td><code id="getDim_+3A_dimcode">dimCode</code></td>
<td>
<p>If enabled, the dimCode will be returned, otherwise the name
of the dimension.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The name or dimCode of the dimensions in which elems were found.
</p>


<h3>Author(s)</h3>

<p>Jan Philipp Dietrich
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mcalc">mcalc</a></code>,<code><a href="#topic+dimCode">dimCode</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
 pop &lt;- maxample("pop")
 getDim(c("AFR","CPA"),pop)
 getDim(c("AFR","CPA"),pop,fullmatch=TRUE)
 getDim(c("AFR","CPA"),pop,dimCode=FALSE)
 
</code></pre>

<hr>
<h2 id='getItems'>Get Items</h2><span id='topic+getItems'></span><span id='topic+getItems+3C-'></span>

<h3>Description</h3>

<p>Extract items of a given (sub-)dimension of a MAgPIE-object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getItems(x, dim = NULL, split = FALSE, full = FALSE)

getItems(x, dim, full = NULL, maindim = NULL, raw = FALSE) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getItems_+3A_x">x</code></td>
<td>
<p>MAgPIE object</p>
</td></tr>
<tr><td><code id="getItems_+3A_dim">dim</code></td>
<td>
<p>Dimension for which the items should be returned. Either number or
name of dimension or a vector of these. See <code><a href="#topic+dimCode">dimCode</a></code> for more details.</p>
</td></tr>
<tr><td><code id="getItems_+3A_split">split</code></td>
<td>
<p>Boolean which determines whether a main dimension should be split in subdimensions.
Only applicable to main dimensions (1,2,3) and ignored for all other.</p>
</td></tr>
<tr><td><code id="getItems_+3A_full">full</code></td>
<td>
<p>if TRUE dimension names are returned as they are (including repetitions), if FALSE only
the dimension elements (unique list of entries) are returned.</p>
</td></tr>
<tr><td><code id="getItems_+3A_maindim">maindim</code></td>
<td>
<p>main dimension the data should be added to (does not need to be set if <code>dim</code> exists
in the data. Should be set if <code>dim</code> might not exist, or if <code>dim</code> might potentially exist
in a different main dimension than the one anticipated).</p>
</td></tr>
<tr><td><code id="getItems_+3A_raw">raw</code></td>
<td>
<p>if set to FALSE inputs will be corrected (e.g. dots replaced by the letter &quot;p&quot;) if necessary. If
TRUE data will be written as is (risking the creation of inconsistent objects).</p>
</td></tr>
<tr><td><code id="getItems_+3A_value">value</code></td>
<td>
<p>a vector with the length of the main dimension the dimnames should be replaced in / added to.
If set to NULL the corresponding dimension will be removed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>items of the requested dimension in the MAgPIE-object. If split=TRUE and applied to a
main dimension (1,2,3) a list of items for each sub-dimension.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>getItems(x, dim, full = NULL, maindim = NULL, raw = FALSE) &lt;- value</code>: set dimension names
</p>
</li></ul>


<h3>Author(s)</h3>

<p>Jan Philipp Dietrich
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dimCode">dimCode</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- maxample("pop")
getItems(x, "scenario")
getItems(x, 3.1)
getItems(x, "i") &lt;- paste0("REG", seq_len(ncells(x)))
getItems(x, "i")
y &lt;- x[, 1, ]
getItems(y, "t") &lt;- NULL
</code></pre>

<hr>
<h2 id='getNames'>Get dataset names</h2><span id='topic+getNames'></span><span id='topic+getNames+3C-'></span>

<h3>Description</h3>

<p>Extracts dataset names of a MAgPIE-object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getNames(x, fulldim = FALSE, dim = NULL)

getNames(x, dim = NULL) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getNames_+3A_x">x</code></td>
<td>
<p>MAgPIE object</p>
</td></tr>
<tr><td><code id="getNames_+3A_fulldim">fulldim</code></td>
<td>
<p>specifies, how the object is treated. In case of FALSE, it is
assumed that x is 3 dimensional and dimnames(x)[[3]] is returned. In case of
TRUE, the dimnames of the real third dimension namesare returned</p>
</td></tr>
<tr><td><code id="getNames_+3A_dim">dim</code></td>
<td>
<p>Argument to choose a specific data dimension either by name of
the dimension or by number of the data dimension.</p>
</td></tr>
<tr><td><code id="getNames_+3A_value">value</code></td>
<td>
<p>a vector of names current names should be replaced with. If
only one data element exists you can also set the name to NULL.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>setNames is a shortcut to use a MAgPIE object with manipulated data names.
The setNames method uses the variable names &quot;object&quot; and &quot;nm&quot; in order to be
consistent to the already existing function setNames.
</p>


<h3>Value</h3>

<p>getNames returns data names of the MAgPIE-object, whereas setNames
returns the MAgPIE object with the manipulated data names.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>getNames(x, dim = NULL) &lt;- value</code>: set names
</p>
</li></ul>


<h3>Author(s)</h3>

<p>Jan Philipp Dietrich
</p>


<h3>See Also</h3>

<p><code><a href="#topic+setNames-methods">setNames-methods</a></code>, <code><a href="#topic+getRegions">getRegions</a></code>, <code><a href="#topic+getYears">getYears</a></code>,
<code><a href="#topic+getCPR">getCPR</a></code>, <code><a href="#topic+read.magpie">read.magpie</a></code>,
<code><a href="#topic+write.magpie">write.magpie</a></code>,<code><a href="#topic+ndata">ndata</a></code>,
<code>"<a href="#topic+magpie-class">magpie</a>"</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
a &lt;- as.magpie(1)
getNames(a)
setNames(a, "bla")

x &lt;- new.magpie("GLO", 2000, c("a.o1", "b.o1", "a.o2"))
getNames(x, dim = 2)

getSets(x, fulldim = FALSE)[3] &lt;- "bla.blub"
getNames(x, dim = "bla")

getSets(x)[4] &lt;- "ble"
getNames(x, dim = "ble") &lt;- c("Hi", "Bye")
x
</code></pre>

<hr>
<h2 id='getRegionList'>Get a list of celluare region-belongings</h2><span id='topic+getRegionList'></span><span id='topic+getRegionList+3C-'></span>

<h3>Description</h3>

<p>Extracts a vector containing the region of each cell of a MAgPIE-object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getRegionList(x)

getRegionList(x) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getRegionList_+3A_x">x</code></td>
<td>
<p>MAgPIE object</p>
</td></tr>
<tr><td><code id="getRegionList_+3A_value">value</code></td>
<td>
<p>A vector with ncell elements containing the regions of each
cell.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector with ncell elements containing the region of each cell.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>getRegionList(x) &lt;- value</code>: set region names
</p>
</li></ul>


<h3>Author(s)</h3>

<p>Jan Philipp Dietrich
</p>


<h3>See Also</h3>

<p><code><a href="#topic+getRegions">getRegions</a></code>,<code><a href="#topic+getYears">getYears</a></code>,
<code><a href="#topic+getNames">getNames</a></code>, <code><a href="#topic+getCPR">getCPR</a></code>, <code><a href="#topic+read.magpie">read.magpie</a></code>,
<code><a href="#topic+write.magpie">write.magpie</a></code>, <code>"<a href="#topic+magpie-class">magpie</a>"</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# a &lt;- read.magpie("example.mz")
# getRegionList(a)
</code></pre>

<hr>
<h2 id='getRegions'>Get regions</h2><span id='topic+getRegions'></span><span id='topic+getRegions+3C-'></span>

<h3>Description</h3>

<p>Extracts regions of a MAgPIE-object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getRegions(x)

getRegions(x) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getRegions_+3A_x">x</code></td>
<td>
<p>MAgPIE object</p>
</td></tr>
<tr><td><code id="getRegions_+3A_value">value</code></td>
<td>
<p>Vector containing the new region names of the MAgPIE objects.
If you also want to change the mapping of regions to cell please use
<code><a href="#topic+getRegionList">getRegionList</a></code> instead.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Regions of the MAgPIE-object
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>getRegions(x) &lt;- value</code>: overwrite region names
</p>
</li></ul>


<h3>Author(s)</h3>

<p>Jan Philipp Dietrich
</p>


<h3>See Also</h3>

<p><code><a href="#topic+getYears">getYears</a></code>, <code><a href="#topic+getNames">getNames</a></code>,
<code><a href="#topic+getCPR">getCPR</a></code>, <code><a href="#topic+read.magpie">read.magpie</a></code>, <code><a href="#topic+write.magpie">write.magpie</a></code>,
<code>"<a href="#topic+magpie-class">magpie</a>"</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# a &lt;- read.magpie("example.mz")
# getRegions(a)
</code></pre>

<hr>
<h2 id='getSets'>Get sets</h2><span id='topic+getSets'></span><span id='topic+getSets+3C-'></span>

<h3>Description</h3>

<p>Extracts sets of a MAgPIE-object if available
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getSets(x, fulldim = TRUE, sep = ".")

getSets(x, fulldim = TRUE, sep = ".") &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getSets_+3A_x">x</code></td>
<td>
<p>MAgPIE object</p>
</td></tr>
<tr><td><code id="getSets_+3A_fulldim">fulldim</code></td>
<td>
<p>bool: Consider dimension 3 as a possible aggregate of more
dimensions (TRUE) or stick to it as one dimension (FALSE)</p>
</td></tr>
<tr><td><code id="getSets_+3A_sep">sep</code></td>
<td>
<p>A character separating joined dimension names</p>
</td></tr>
<tr><td><code id="getSets_+3A_value">value</code></td>
<td>
<p>A vector with set names you want to replace the current set
names of the object with.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Sets of the MAgPIE-object. If no information about contained sets is
available NULL
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>getSets(x, fulldim = TRUE, sep = ".") &lt;- value</code>: replace set names
</p>
</li></ul>


<h3>Author(s)</h3>

<p>Markus Bonsch, Jan Philipp Dietrich
</p>


<h3>See Also</h3>

<p><code><a href="#topic+getRegions">getRegions</a></code>,
<code><a href="#topic+getNames">getNames</a></code>,<code><a href="#topic+getYears">getYears</a></code>, <code><a href="#topic+getCPR">getCPR</a></code>,
<code><a href="#topic+read.magpie">read.magpie</a></code>, <code><a href="#topic+write.magpie">write.magpie</a></code>,
<code>"<a href="#topic+magpie-class">magpie</a>"</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
a &lt;- new.magpie("GLO.1", 2000, c("a.o1", "b.o1", "a.o2"))
 getSets(a) &lt;- c("reg", "cell", "t", "bla", "blub")
 getSets(a)

 getSets(a)["d3.1"] &lt;- "BLA"
 getSets(a, fulldim = FALSE)
 getSets(a)
</code></pre>

<hr>
<h2 id='getYears'>Get years</h2><span id='topic+getYears'></span><span id='topic+getYears+3C-'></span><span id='topic+setYears'></span>

<h3>Description</h3>

<p>Extracts years of a MAgPIE-object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getYears(x, as.integer = FALSE)

getYears(x) &lt;- value

setYears(object, nm = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getYears_+3A_x">x</code>, <code id="getYears_+3A_object">object</code></td>
<td>
<p>MAgPIE object</p>
</td></tr>
<tr><td><code id="getYears_+3A_as.integer">as.integer</code></td>
<td>
<p>Switch to decide, if output should be the used year-name
(e.g. &quot;y1995&quot;) or the year as integer value (e.g. 1995)</p>
</td></tr>
<tr><td><code id="getYears_+3A_value">value</code>, <code id="getYears_+3A_nm">nm</code></td>
<td>
<p>Years the data should be set to. Either supplied as a vector
of integers or a vector of characters in the predefined year format
(&quot;y0000&quot;). If only 1 year exist you can also set the name of the year to
NULL.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>setYears is a shortcut to use a MAgPIE object with manipulated year names.
setYears uses the variable names &quot;object&quot; and &quot;nm&quot; in order to be consistent
to the already existing function setNames.
</p>


<h3>Value</h3>

<p>getYears returns years of the MAgPIE-object, whereas setYears
returns the MAgPIE object with the manipulated years.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>getYears(x) &lt;- value</code>: rename years
</p>
</li>
<li> <p><code>setYears()</code>: set years
</p>
</li></ul>


<h3>Author(s)</h3>

<p>Jan Philipp Dietrich
</p>


<h3>See Also</h3>

<p><code><a href="#topic+getRegions">getRegions</a></code>, <code><a href="#topic+getNames">getNames</a></code>,
<code><a href="#topic+setNames">setNames</a></code>, <code><a href="#topic+getCPR">getCPR</a></code>, <code><a href="#topic+read.magpie">read.magpie</a></code>,
<code><a href="#topic+write.magpie">write.magpie</a></code>, <code>"<a href="#topic+magpie-class">magpie</a>"</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
 a &lt;- as.magpie(1)
 getYears(a)
 setYears(a,1995)

</code></pre>

<hr>
<h2 id='hasCoords'>Has Coordinates</h2><span id='topic+hasCoords'></span>

<h3>Description</h3>

<p>Checks, whether object contains coordinates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hasCoords(x, xlab = "x", ylab = "y")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hasCoords_+3A_x">x</code></td>
<td>
<p>MAgPIE object</p>
</td></tr>
<tr><td><code id="hasCoords_+3A_xlab">xlab</code></td>
<td>
<p>label of x-dimension</p>
</td></tr>
<tr><td><code id="hasCoords_+3A_ylab">ylab</code></td>
<td>
<p>label of y-dimension</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Boolean indicating whether coordinates were found or not
</p>


<h3>Author(s)</h3>

<p>Jan Philipp Dietrich
</p>


<h3>See Also</h3>

<p><code><a href="#topic+getCoords">getCoords</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
hasCoords(maxample("pop"))
hasCoords(maxample("animal"))


</code></pre>

<hr>
<h2 id='hasSets'>Has Sets</h2><span id='topic+hasSets'></span>

<h3>Description</h3>

<p>Checks, whether set names have been set
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hasSets(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hasSets_+3A_x">x</code></td>
<td>
<p>MAgPIE object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Boolean indicating whether coordinates were found or not
</p>


<h3>Author(s)</h3>

<p>Jan Philipp Dietrich
</p>


<h3>See Also</h3>

<p><code><a href="#topic+getCoords">getCoords</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
hasSets(maxample("pop"))
hasSets(maxample("animal"))


</code></pre>

<hr>
<h2 id='head.magpie'>head/tail</h2><span id='topic+head.magpie'></span><span id='topic+tail.magpie'></span>

<h3>Description</h3>

<p>head and tail methods for MAgPIE objects to extract the head or tail of an
object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'magpie'
head(x, n1 = 3L, n2 = 6L, n3 = 2L, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="head.magpie_+3A_x">x</code></td>
<td>
<p>MAgPIE object</p>
</td></tr>
<tr><td><code id="head.magpie_+3A_n1">n1</code>, <code id="head.magpie_+3A_n2">n2</code>, <code id="head.magpie_+3A_n3">n3</code></td>
<td>
<p>number of lines in first, second and third dimension that
should be returned. If the given number is higher than the length of the
dimension all entries in this dimension will be returned.</p>
</td></tr>
<tr><td><code id="head.magpie_+3A_...">...</code></td>
<td>
<p>arguments to be passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>head returns the first n1 x n2 x n3 entries, tail returns the last
n1 x n2 x n3 entries.
</p>


<h3>Author(s)</h3>

<p>Jan Philipp Dietrich
</p>


<h3>See Also</h3>

<p><code><a href="utils.html#topic+head">head</a></code>, <code><a href="utils.html#topic+tail">tail</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
 pop &lt;- maxample("pop")
 head(pop)
 tail(pop,2,4,1)

</code></pre>

<hr>
<h2 id='is.temporal'>is.temporal, is.spatial</h2><span id='topic+is.temporal'></span><span id='topic+is.spatial'></span>

<h3>Description</h3>

<p>Functions to find out whether a vector consists of strings consistent with
the definition for auto-detection of temporal or spatial data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.temporal(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.temporal_+3A_x">x</code></td>
<td>
<p>A vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns TRUE or FALSE
</p>


<h3>Author(s)</h3>

<p>Jan Philipp Dietrich
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
is.temporal(1991:1993)
is.spatial(c("GLO","AFR"))

</code></pre>

<hr>
<h2 id='isYear'>isYear</h2><span id='topic+isYear'></span>

<h3>Description</h3>

<p>Function to find out whether a vector consists of strings in the format
&quot;yXXXX&quot; or &quot;XXXX&quot; with X being a number
</p>


<h3>Usage</h3>

<pre><code class='language-R'>isYear(x, with_y = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="isYear_+3A_x">x</code></td>
<td>
<p>A vector</p>
</td></tr>
<tr><td><code id="isYear_+3A_with_y">with_y</code></td>
<td>
<p>indicates which dataformat years have to have (4-digit without
y (e.g.1984) or 5digit including y (y1984))</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a vector of the length of x with TRUE and FALSE
</p>


<h3>Author(s)</h3>

<p>Benjamin Bodirsky
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- c("1955", "y1853", "12a4")
isYear(x, with_y = TRUE)
isYear(x, with_y = FALSE)
</code></pre>

<hr>
<h2 id='log-methods'>log-method for MAgPIE objects</h2><span id='topic+log-methods'></span><span id='topic+log+2Cmagpie-method'></span><span id='topic+logb-methods'></span><span id='topic+logb+2Cmagpie-method'></span>

<h3>Description</h3>

<p>log-method for MAgPIE-objects respectively. Works exactly as for arrays.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'magpie'
log(x, base = exp(1))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="log-methods_+3A_x">x</code></td>
<td>
<p>a magpie object</p>
</td></tr>
<tr><td><code id="log-methods_+3A_base">base</code></td>
<td>
<p>ia positive or complex number: the base with respect to which
logarithms are computed. Defaults to e=exp(1).</p>
</td></tr>
</table>


<h3>Methods</h3>


<dl>
<dt>x = &quot;magpie&quot;</dt><dd><p> works as log(x) for arrays. </p>
</dd>
</dl>


<hr>
<h2 id='lowpass'>Lowpass Filter</h2><span id='topic+lowpass'></span>

<h3>Description</h3>

<p>Filters high frequencies out of a time series. The filter
has the structure x'(n) = (x(n-1)+2*x(n)+x(n+1))/4
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lowpass(x, i = 1, fix = NULL, altFilter = NULL, warn = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lowpass_+3A_x">x</code></td>
<td>
<p>Vector of data points, that should be filtered or MAgPIE object</p>
</td></tr>
<tr><td><code id="lowpass_+3A_i">i</code></td>
<td>
<p>number of iterations the filter should be applied to the data</p>
</td></tr>
<tr><td><code id="lowpass_+3A_fix">fix</code></td>
<td>
<p>Fixes the starting and/or ending data point. Default value is
<code>NULL</code> which doesn't fix any point. Available options are:
<code>"start"</code> for fixing the starting point, <code>"end"</code> for fixing the
ending point and <code>"both"</code> for fixing both ends of the data.</p>
</td></tr>
<tr><td><code id="lowpass_+3A_altfilter">altFilter</code></td>
<td>
<p>set special filter rule to indexes defined in this
parameter. The special filter has the structure x'(n) = (2*x(n)+x(n+1))/3</p>
</td></tr>
<tr><td><code id="lowpass_+3A_warn">warn</code></td>
<td>
<p>boolean deciding whether lowpass issues a warning for
critical parameter choices or not</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The filtered data vector or MAgPIE object
</p>


<h3>Author(s)</h3>

<p>Jan Philipp Dietrich, Misko Stevanovic
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
lowpass(c(1, 2, 11, 3, 4))
# to fix the starting point
lowpass(c(0, 9, 1, 5, 14, 20, 6, 11, 0), i = 2, fix = "start")
</code></pre>

<hr>
<h2 id='magclassdata'>magclassdata</h2><span id='topic+magclassdata'></span>

<h3>Description</h3>

<p>General magclass-dataset
</p>


<h3>Details</h3>

<p>Please do not directly access that data. It should be only used by library
functions.
</p>


<h3>Author(s)</h3>

<p>Jan Philipp Dietrich
</p>

<hr>
<h2 id='magpie_expand'>magpie_expand</h2><span id='topic+magpie_expand'></span>

<h3>Description</h3>

<p>Expands a MAgPIE object based on a reference
</p>


<h3>Usage</h3>

<pre><code class='language-R'>magpie_expand(x, ref)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="magpie_expand_+3A_x">x</code></td>
<td>
<p>MAgPIE object that should be expanded</p>
</td></tr>
<tr><td><code id="magpie_expand_+3A_ref">ref</code></td>
<td>
<p>MAgPIE object that serves as a reference</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Expansion means here that the dimensions of x are expanded accordingly to
ref. Please note that this is really only about expansion. In the case that
one dimension of ref is smaller than of x nothing happens with this
dimension. At the moment magpie_expand is only internally available in the
magclass library
</p>
<p>You can influence the verbosity of this function by setting the option
&quot;magclass.verbosity&quot;. By default verbosity is set to 1 which means that
only warnings are returned. Setting verbosity to 2 means that warnings
as well as additional notes are returned. This is done by
options(verbosity.level=2)
</p>
<p>With version 5 of the package magpie_expand has been updated to a newer version
(currently 2.1) and since version 6 this is the only currently supported
version. To switch to the old setup you have to install magclass  in a version &lt; 6
and set <code>options(magclass_expand_version=1)</code>.
</p>
<p>By default expansion is based on the elements in a dimension ignoring the set name of
the dimension. To expand based on set names instead of contents (recommended) you can
switch <code>options(magclass_setMatching=TRUE)</code>. Please be careful with this setting
as it alters the behavior of magclass objects quite significantly! For more information
have a look at <code>vignette("magclass-expansion")</code>.
</p>


<h3>Value</h3>

<p>An expanded version of x.
</p>


<h3>Author(s)</h3>

<p>Jan Philipp Dietrich
</p>


<h3>See Also</h3>

<p><code><a href="#topic+as.magpie">as.magpie</a></code>, <code><a href="base.html#topic+options">options</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
a &lt;- new.magpie(c("AFR", "CPA"), "y1995", c("m", "n"))
b &lt;- new.magpie("GLO", "y1995", c("bla", "blub"))
magpie_expand(b, a)
options(magclass.verbosity = 2)
magpie_expand(b, a)
</code></pre>

<hr>
<h2 id='magpie_expand_dim'>magpie_expand_dim</h2><span id='topic+magpie_expand_dim'></span>

<h3>Description</h3>

<p>Expands a single MAgPIE object dimension
</p>


<h3>Usage</h3>

<pre><code class='language-R'>magpie_expand_dim(x, ref, dim = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="magpie_expand_dim_+3A_x">x</code></td>
<td>
<p>MAgPIE object that should be expanded</p>
</td></tr>
<tr><td><code id="magpie_expand_dim_+3A_ref">ref</code></td>
<td>
<p>MAgPIE object that serves as a reference</p>
</td></tr>
<tr><td><code id="magpie_expand_dim_+3A_dim">dim</code></td>
<td>
<p>dimension that should be expanded</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Expansion means here that the dimensions of x are expanded acordingly to
ref. Please note that this is really only about expansion. In the case that
one dimension of ref is smaller than of x nothing happens with this
dimension. At the moment magpie_expand is only internally available in the
magclass library
</p>
<p>In contrast to <code><a href="#topic+magpie_expand">magpie_expand</a></code> this function is expanding only a single
dimension. It is meant as a support function for <code><a href="#topic+magpie_expand">magpie_expand</a></code> itself.
</p>


<h3>Value</h3>

<p>An expanded version of x.
</p>


<h3>Author(s)</h3>

<p>Jan Philipp Dietrich
</p>


<h3>See Also</h3>

<p><code><a href="#topic+as.magpie">as.magpie</a></code>, <code><a href="base.html#topic+options">options</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>d &lt;- new.magpie(c("AFR.BLUB.1", "AFR.BLUB.2", "EUR.BLUB.1",
                    "AFR.BLA.1", "AFR.BLA.2", "EUR.BLA.1"), fill = 1)
 getSets(d)[1:3] &lt;- c("reg", "b", "i")
 e &lt;- new.magpie(c("BLA.AFR.A", "BLA.EUR.A", "BLUB.AFR.A", "BLUB.EUR.A",
                    "BLA.AFR.B", "BLA.EUR.B", "BLUB.AFR.B", "BLUB.EUR.B"), fill = 2)
 getSets(e)[1:3] &lt;- c("b", "reg", "a")
 magclass:::magpie_expand_dim(d, e, dim = 1)
</code></pre>

<hr>
<h2 id='magpie-class'>Class &quot;magpie&quot; ~~~</h2><span id='topic+magpie-class'></span><span id='topic+as.magpie'></span><span id='topic+as.magpie-methods'></span><span id='topic+as.magpie+2Cmagpie-method'></span><span id='topic+as.magpie+2Carray-method'></span><span id='topic+as.magpie+2Clpj-method'></span><span id='topic+as.magpie+2Cdata.frame-method'></span><span id='topic+as.magpie+2Cnumeric-method'></span><span id='topic+as.magpie+2CNULL-method'></span><span id='topic+as.magpie+2Cquitte-method'></span><span id='topic+as.magpie+2Ctbl_df-method'></span><span id='topic+as.magpie+2CRasterBrick-method'></span><span id='topic+as.magpie+2Clogical-method'></span><span id='topic+as.magpie+2CRasterLayer-method'></span><span id='topic+as.magpie+2CRasterStack-method'></span><span id='topic+as.magpie+2CSpatRaster-method'></span><span id='topic+as.magpie+2CLPJmLData-method'></span><span id='topic+as.magpie+2CSpatVector-method'></span><span id='topic+is.magpie'></span><span id='topic++5B+2Cmagpie-method'></span><span id='topic++5B+2Cmagpie+2CANY+2CANY-method'></span><span id='topic++5B+3C-+2Cmagpie+2CANY+2CANY-method'></span><span id='topic++5B+3C-+2Cmagpie-method'></span><span id='topic+Ops+2Cmagpie+2Cmagpie-method'></span><span id='topic+Ops+2Cmagpie+2Cnumeric-method'></span><span id='topic+Ops+2Cnumeric+2Cmagpie-method'></span><span id='topic+ifelse+2Cmagpie-method'></span><span id='topic+is.na+2Cmagpie-method'></span><span id='topic+is.nan+2Cmagpie-method'></span><span id='topic+is.infinite+2Cmagpie-method'></span><span id='topic+is.finite+2Cmagpie-method'></span>

<h3>Description</h3>

<p>The MAgPIE class is a data format for cellular MAgPIE data with a close
relationship to the array data format. <code>is.magpie</code> tests if <code>x</code> is
an MAgPIE-object, <code>as.magpie</code> transforms <code>x</code> to an MAgPIE-object
(if possible).
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="magpie-class_+3A_x">x</code></td>
<td>
<p>An object that should be either tested or transformed as/to an
MAgPIE-object.</p>
</td></tr>
<tr><td><code id="magpie-class_+3A_...">...</code></td>
<td>
<p>additional arguments supplied for the conversion to a MAgPIE
object. Allowed arguments for arrays and dataframes are <code>spatial</code> and
<code>temporal</code> both expecting a vector of dimension or column numbers which
contain the spatial or temporal information. By default both arguments are
set to NULL which means that the <code>as.magpie</code> will try to detect
automatically the temporal and spatial dimensions. The arguments will just
overwrite the automatic detection. If you want to specify that the data does
not contain a spatial or temporal dimension you can set the corresponding
argument to 0. In addition <code>as.magpie</code> for data.frames is also
expecting an argument called <code>datacol</code> which expects a number stating
which is the first column containing data. This argument should be used if
the dimensions are not detected corretly, e.g. if the last dimension column
contains years which are then detected as values and therefore interpreted
as first data column. In addition an argument <code>tidy=TRUE</code> can be used
to indicate that the data.frame structure is following the rules of tidy
data (last column is the data column all other columns contain dimension
information). This information will help the conversion. <code>sep</code> defines
the dimension separator (default is &quot;.&quot;) and <code>replacement</code> defines how
the separator as a reserved character should be converted in order to not
mess up with the object (default &quot;_&quot;).
Another available argument for conversions of data.frames and quitte
objects to magpie is <code>filter</code> if set to TRUE (default)
&quot;.&quot; (separator) will be replaced withe the <code>replacement</code> character and
empty entries will be replaced with a single space. If set to FALSE no filter
will be applied to the data.</p>
</td></tr>
</table>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form
<code>new("magpie", data, dim, dimnames, ...)</code>. MAgPIE objects have three
dimensions (cells,years,datatype) and the dimensionnames of the first
dimension have the structure &quot;REGION.cellnumber&quot;. MAgPIE-objects behave the
same like array-objects with 2 exceptions: <br /> 1.Dimensions of the object
will not collapse (e.g. <code>x[1,1,1]</code> will remain 3D instead of becoming
1D)<br /> 2.It is possible to extract full regions just by typing
<code>x["REGIONNAME",,]</code>. <br /><br />
</p>
<p>Please mind following standards: <br /> Header must not contain any purely
numeric entries, but combinations of characters and numbers are allowed
(e.g. &quot;bla&quot;,&quot;12&quot; is forbidden, wheras &quot;bla&quot;,&quot;b12&quot; is allowed)<br /> Years
always have the structure &quot;y&quot; + 4-digit number, e.g. &quot;y1995&quot;<br /> Regions
always have the structure 3 capital letters, e.g. &quot;AFR&quot; or &quot;GLO&quot;<br /><br /> This
standards are necessary to allow the scripts to detect headers, years and
regions properly and to have a distinction to other data.
</p>


<h3>Author(s)</h3>

<p>Jan Philipp Dietrich
</p>


<h3>See Also</h3>

<p><code><a href="#topic+read.magpie">read.magpie</a></code>, <code><a href="#topic+write.magpie">write.magpie</a></code>,
<code><a href="#topic+getRegions">getRegions</a></code>, <code><a href="#topic+getYears">getYears</a></code>, <code><a href="#topic+getNames">getNames</a></code>,
<code><a href="#topic+getCPR">getCPR</a></code>, <code><a href="#topic+ncells">ncells</a></code>, <code><a href="#topic+nyears">nyears</a></code>,
<code><a href="#topic+ndata">ndata</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
showClass("magpie")

pop &lt;- maxample("pop")

# returning PAO and PAS for 2025
pop["PA", 2025, , pmatch = "left"]

# returning CPA for 2025
pop["PA", 2025, , pmatch = "right"]

# returning CPA PAO and PAS for 2025
pop["PA", 2025, , pmatch = TRUE]

# returning PAS and 2025
pop["PAS", 2025, ]

# return all entries for year 2025
pop[2025, dim = 2]

# returning everything but values for PAS or values for 2025
pop["PAS", 2025, , invert = TRUE]

# accessing subdimension via set name

a &lt;- maxample("animal")
a[list(country = "NLD", y = "53p25"), , list(species = c("rabbit", "dog"))]

# please note that the list elements act as filter. For instance, the
# following example will not contain any dogs as the data set does
# not contain any dogs which are black.
a[list(country = "NLD", y = "53p25"), , list(species = c("rabbit", "dog"), color = "black")]

# it is also possible to extract given combinations of subdimensions
# via a data-frame
df &lt;- data.frame(getItems(a, 3, split = TRUE, full = TRUE))[c(1, 3, 4), ][3:2]
getItems(a[df], 3)

# Unknown dimensions to be added in output!
df$blub &lt;- paste0("bl", 1:dim(df)[1])
getItems(a[df], 3)
</code></pre>

<hr>
<h2 id='magpiesort'>MAgPIE-Sort</h2><span id='topic+magpiesort'></span>

<h3>Description</h3>

<p>Brings the spatial and temporal structure of MAgPIE objects in the right
order. This function is especially useful when you create new MAgPIE objects
as the order typically should be correct for MAgPIE objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>magpiesort(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="magpiesort_+3A_x">x</code></td>
<td>
<p>MAgPIE object which might not be in the right order.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The eventually corrected MAgPIE object (right order in spatial in
temporal dimension)
</p>


<h3>Author(s)</h3>

<p>Jan Philipp Dietrich
</p>


<h3>See Also</h3>

<p><code>"<a href="#topic+magpie-class">magpie</a>"</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
pop &lt;- maxample("pop")
a &lt;- magpiesort(pop)
</code></pre>

<hr>
<h2 id='magpply'>magpply</h2><span id='topic+magpply'></span>

<h3>Description</h3>

<p>apply command for magpieobjects. Very efficient for replacing loops.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>magpply(X, FUN, MARGIN = NULL, DIM = NULL, ..., INTEGRATE = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="magpply_+3A_x">X</code></td>
<td>
<p>magpie object</p>
</td></tr>
<tr><td><code id="magpply_+3A_fun">FUN</code></td>
<td>
<p>function that shall be applied X</p>
</td></tr>
<tr><td><code id="magpply_+3A_margin">MARGIN</code></td>
<td>
<p>dimension over which FUN shall be applied (like a loop over that dimension).
This dimension will be preserved in the output object (see also <code>DIM</code>).</p>
</td></tr>
<tr><td><code id="magpply_+3A_dim">DIM</code></td>
<td>
<p>dimension in which FUN shall be applied. This dimension will be missing in the output. DIM and MARGIN
are opposite ways of expressing the dimensions to be addressed and you must only use one of them with MARGIN
excluding dimensions from the calculation and DIM including them.</p>
</td></tr>
<tr><td><code id="magpply_+3A_...">...</code></td>
<td>
<p>further parameters passed on to FUN</p>
</td></tr>
<tr><td><code id="magpply_+3A_integrate">INTEGRATE</code></td>
<td>
<p>if TRUE, the output will be filled into an magpie object of the same dimensionality as X</p>
</td></tr>
</table>


<h3>Value</h3>

<p>magpie object
</p>


<h3>Author(s)</h3>

<p>Jan Philipp Dietrich, Benjamin Leon Bodirsky
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
pop &lt;- maxample("pop")
magpply(pop, FUN = sum, MARGIN = 2)
fourdim &lt;- pop * setNames(pop, c("jkk", "lk"))
magpply(fourdim, FUN = sum, MARGIN = c(1, 3.1))
</code></pre>

<hr>
<h2 id='maxample'>maxample</h2><span id='topic+maxample'></span>

<h3>Description</h3>

<p>A collection of magclass example data sets
</p>


<h3>Usage</h3>

<pre><code class='language-R'>maxample(data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="maxample_+3A_data">data</code></td>
<td>
<p>name of the example data set. Currently available are &quot;pop&quot; (regional population data,
previously named &quot;population_magpie&quot;), &quot;animal&quot; (fictional, high-dimensional animal sighting data set)
and &quot;bilateral&quot; (fictional, bilateral trade cost data set).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the chosen example data set
</p>


<h3>Author(s)</h3>

<p>Jan Philipp Dietrich
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
p &lt;- maxample("pop")
str(p)

a &lt;- maxample("animal")
str(a)
getItems(a, split = TRUE)
</code></pre>

<hr>
<h2 id='mbind'>mbind</h2><span id='topic+mbind'></span>

<h3>Description</h3>

<p>Merges MAgPIE-objects with identical structure in two dimensions. If data
differs in the temporal or spatial dimension each year or region/cell must
appear only once!
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mbind(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mbind_+3A_...">...</code></td>
<td>
<p>MAgPIE objects or a list of MAgPIE objects that should be merged.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The merged MAgPIE object
</p>


<h3>Author(s)</h3>

<p>Jan Philipp Dietrich, Misko Stevanovic
</p>


<h3>See Also</h3>

<p><code>"<a href="#topic+magpie-class">magpie</a>"</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
m &lt;- new.magpie(c("AFR", "CPA", "EUR"), c(1995, 2005), "Data1", fill = c(1, 2, 3, 4, 5, 6))
ms &lt;- dimSums(m, dim = 3.1)
mbind(m, ms)
my &lt;- new.magpie(getRegions(m), 2010, getNames(m), fill = c(6, 6, 4))
mbind(m, my)
md &lt;- new.magpie(getRegions(m), getYears(m), "Data2", fill = c(7, 6, 5, 7, 8, 9))
mbind(m, md)

pop &lt;- maxample("pop")
a &lt;- mbind(pop, pop)
dim(pop)
dim(a)
</code></pre>

<hr>
<h2 id='mcalc'>mcalc</h2><span id='topic+mcalc'></span><span id='topic+mcalc+3C-'></span>

<h3>Description</h3>

<p>Select values from a MAgPIE-object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mcalc(x, f, dim = NULL, append = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mcalc_+3A_x">x</code></td>
<td>
<p>MAgPIE object</p>
</td></tr>
<tr><td><code id="mcalc_+3A_f">f</code></td>
<td>
<p>A formula describing the calculation that should be performed</p>
</td></tr>
<tr><td><code id="mcalc_+3A_dim">dim</code></td>
<td>
<p>The dimension in which the manipulation should take place. If set
to NULL function tries to detect the dimension automatically.</p>
</td></tr>
<tr><td><code id="mcalc_+3A_append">append</code></td>
<td>
<p>If set to TRUE the result will be appended to x, otherwise the
result will be returned.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This functions only work for MAgPIE objects with named dimensions as the
dimension name (set_name) has to be used to indicate in which dimension the
entries should be searched for!
</p>


<h3>Value</h3>

<p>The calculated MAgPIE object in the case that append is set to
FALSE. Otherwise nothing is returned (as x is appended in place)
</p>


<h3>Author(s)</h3>

<p>Jan Philipp Dietrich
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mselect">mselect</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
pop &lt;- maxample("pop")
pop
mcalc(pop, X12 ~ A2 * B1, append = TRUE)
pop
mcalc(pop, `Nearly B1` ~ 0.5 * A2 + 99.5 * B1)
</code></pre>

<hr>
<h2 id='mselect'>MSelect</h2><span id='topic+mselect'></span><span id='topic+mselect+3C-'></span>

<h3>Description</h3>

<p>Select values from a MAgPIE-object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mselect(x, ..., collapseNames = FALSE)

mselect(x, ...) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mselect_+3A_x">x</code></td>
<td>
<p>MAgPIE object</p>
</td></tr>
<tr><td><code id="mselect_+3A_...">...</code></td>
<td>
<p>entry selections of the form
<code>set_name=c(set_elem1,set_elem2)</code>. Alternatively a single list element
containing these selections can be provided.</p>
</td></tr>
<tr><td><code id="mselect_+3A_collapsenames">collapseNames</code></td>
<td>
<p>Boolean which decides whether names should be collapsed
or not.</p>
</td></tr>
<tr><td><code id="mselect_+3A_value">value</code></td>
<td>
<p>values on which the selected magpie entries should be set.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This functions only work for MAgPIE objects with named dimensions as the
dimension name (set_name) has to be used to indicate in which dimension the
entries should be searched for!
</p>


<h3>Value</h3>

<p>The reduced MAgPIE object containing only the selected entries or
the full MAgPIE object in which a selection of entries was manipulated.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>mselect(x, ...) &lt;- value</code>: replace values in magpie object
</p>
</li></ul>


<h3>Author(s)</h3>

<p>Jan Philipp Dietrich
</p>


<h3>See Also</h3>

<p><code><a href="#topic+collapseNames">collapseNames</a></code>, <code>"<a href="#topic+magpie-class">magpie</a>"</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
pop &lt;- maxample("pop")
mselect(pop, i = c("AFR", "EUR"), scenario = "A2", t = "y2035")
</code></pre>

<hr>
<h2 id='ncells'>Count elements</h2><span id='topic+ncells'></span><span id='topic+nyears'></span><span id='topic+ndata'></span><span id='topic+nregions'></span>

<h3>Description</h3>

<p>Functions to count the number of cells/years/datasets/regions of an
MAgPIE-object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ncells(x)

ndata(x)

nregions(x)

nyears(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ncells_+3A_x">x</code></td>
<td>
<p>A MAgPIE-object</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>value</code></td>
<td>
<p>The number of cells/years/datasets/regions of <code>x</code></p>
</td></tr>
</table>


<h3>Functions</h3>


<ul>
<li> <p><code>ndata()</code>: count datasets
</p>
</li>
<li> <p><code>nregions()</code>: count regions
</p>
</li>
<li> <p><code>nyears()</code>: count years
</p>
</li></ul>


<h3>Author(s)</h3>

<p>Jan Philipp Dietrich
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
a &lt;- is.magpie(NULL)
ncells(a)
nyears(a)
ndata(a)
nregions(a)
</code></pre>

<hr>
<h2 id='ndim'>Count sub-dimensions</h2><span id='topic+ndim'></span>

<h3>Description</h3>

<p>Functions to count the subdimensions of an
MAgPIE-object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ndim(x, dim = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ndim_+3A_x">x</code></td>
<td>
<p>A MAgPIE-object</p>
</td></tr>
<tr><td><code id="ndim_+3A_dim">dim</code></td>
<td>
<p>main dimension in which the sub-dimensions should be counted. If NULL
the sum of all subdimensions is returned</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Number of subdimensions
</p>


<h3>Author(s)</h3>

<p>Jan Philipp Dietrich
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  a &lt;- maxample("animal")
  ndim(a)
  ndim(a,1)
  ndim(a,2)
  ndim(a,3)

</code></pre>

<hr>
<h2 id='new.magpie'>new.magpie</h2><span id='topic+new.magpie'></span>

<h3>Description</h3>

<p>Creates a new MAgPIE object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>new.magpie(
  cells_and_regions = "GLO",
  years = NULL,
  names = NULL,
  fill = NA,
  sort = FALSE,
  sets = NULL,
  unit = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="new.magpie_+3A_cells_and_regions">cells_and_regions</code></td>
<td>
<p>Either the region names (e.g. &quot;AFR&quot;), or the cells
(e.g. 1:10), or both in combination (e.g. &quot;AFR.1&quot;). NULL means no spatial
element.</p>
</td></tr>
<tr><td><code id="new.magpie_+3A_years">years</code></td>
<td>
<p>dimnames for years in the format &quot;yXXXX&quot; or as integers. NULL
means one year which is not further specified</p>
</td></tr>
<tr><td><code id="new.magpie_+3A_names">names</code></td>
<td>
<p>dimnames for names. NULL means one data element which is not
further specified</p>
</td></tr>
<tr><td><code id="new.magpie_+3A_fill">fill</code></td>
<td>
<p>Default value for the MAgPIE object</p>
</td></tr>
<tr><td><code id="new.magpie_+3A_sort">sort</code></td>
<td>
<p>Bolean. Decides, wheher output should be sorted or not.</p>
</td></tr>
<tr><td><code id="new.magpie_+3A_sets">sets</code></td>
<td>
<p>A vector of dimension names. See <code><a href="#topic+getSets">getSets</a></code> for more
information.</p>
</td></tr>
<tr><td><code id="new.magpie_+3A_unit">unit</code></td>
<td>
<p>deprecated</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an empty magpie object filled with fill, with the given dimnames
</p>


<h3>Author(s)</h3>

<p>Benjamin Bodirsky, Jan Philipp Dietrich
</p>


<h3>See Also</h3>

<p><code><a href="#topic+as.magpie">as.magpie</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
a &lt;- new.magpie(1:10, 1995:2000)
b &lt;- new.magpie(c("AFR", "CPA"), "y1995", c("bla", "blub"), sets = c("i", "t", "value"))
c &lt;- new.magpie()
</code></pre>

<hr>
<h2 id='population_magpie'>population_magpie</h2><span id='topic+population_magpie'></span>

<h3>Description</h3>

<p>Example dataset for a regional MAgPIE object
</p>


<h3>Value</h3>

<p>A2 and B1 population scenario from SRES
</p>


<h3>Author(s)</h3>

<p>Benjamin Bodirsky
</p>

<hr>
<h2 id='print.magpie'>print</h2><span id='topic+print.magpie'></span>

<h3>Description</h3>

<p>print method for MAgPIE objects for conventient display of magpie data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'magpie'
print(x, drop = TRUE, reshape = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.magpie_+3A_x">x</code></td>
<td>
<p>MAgPIE object</p>
</td></tr>
<tr><td><code id="print.magpie_+3A_drop">drop</code></td>
<td>
<p>argument which controls whether empty dimensions should be
skipped or not.</p>
</td></tr>
<tr><td><code id="print.magpie_+3A_reshape">reshape</code></td>
<td>
<p>argument that controls tabular representation of nested data
dimension cross tables, FALSE will reproduce standard print behavior
any pair of two dimension numbers will create a table for these two dims,
and loop over the other dimensions</p>
</td></tr>
<tr><td><code id="print.magpie_+3A_...">...</code></td>
<td>
<p>arguments to be passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Invisibly, the MAgPIE object x.
</p>


<h3>Author(s)</h3>

<p>Jan Philipp Dietrich, Kristine Karstens, Felicitas Beier
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+print">print</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
pop &lt;- maxample("pop")
print(pop)
print(pop[, 1, ], drop = FALSE)
print(pop[, 1, ])
</code></pre>

<hr>
<h2 id='read.magpie'>Read MAgPIE-object from file</h2><span id='topic+read.magpie'></span>

<h3>Description</h3>

<p>Reads a MAgPIE-file and converts it to a 3D array of the structure
(cells,years,datacolumn)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.magpie(
  file_name,
  file_folder = "",
  file_type = NULL,
  as.array = FALSE,
  comment.char = "*",
  check.names = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read.magpie_+3A_file_name">file_name</code></td>
<td>
<p>file name including file ending (wildcards are supported).
Optionally also the full path can be specified here (instead of splitting it
to file_name and file_folder)</p>
</td></tr>
<tr><td><code id="read.magpie_+3A_file_folder">file_folder</code></td>
<td>
<p>folder the file is located in (alternatively you can also
specify the full path in file_name - wildcards are supported)</p>
</td></tr>
<tr><td><code id="read.magpie_+3A_file_type">file_type</code></td>
<td>
<p>format the data is stored in. If file_type=NULL the file ending
of the file_name is used as format. If format is different to the formats
mentioned standard MAgPIE format is assumed. See <code><a href="#topic+write.magpie">write.magpie</a></code>
for a list of supported file formats.</p>
</td></tr>
<tr><td><code id="read.magpie_+3A_as.array">as.array</code></td>
<td>
<p>Should the input be transformed to an array? This can be
useful for regional or global inputs, but all advantages of the magpie-class
are lost.</p>
</td></tr>
<tr><td><code id="read.magpie_+3A_comment.char">comment.char</code></td>
<td>
<p>character: a character vector of length one containing a
single character or an empty string. Use &quot;&quot; to turn off the interpretation
of comments altogether. If a comment is found it will be stored in
attr(,&quot;comment&quot;). In text files the comment has to be at the beginning of
the file in order to be recognized by read.magpie.</p>
</td></tr>
<tr><td><code id="read.magpie_+3A_check.names">check.names</code></td>
<td>
<p>logical. If TRUE then the names of the variables in the
data frame are checked to ensure that they are syntactically valid variable
names. Same functionality as in read.table.</p>
</td></tr>
<tr><td><code id="read.magpie_+3A_...">...</code></td>
<td>
<p>additional arguments passed to specific read functions (e.g.
<code>varname</code> for specifying the variable to be read in from a multi-variable
NCDF file.)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <code><a href="#topic+write.magpie">write.magpie</a></code> for a list of supported file formats.
</p>


<h3>Value</h3>

<table>
<tr><td><code>x</code></td>
<td>
<p>MAgPIE-object</p>
</td></tr>
</table>


<h3>Note</h3>

<p>See <code><a href="#topic+write.magpie">write.magpie</a></code> for the detailed structure of binary MAgPIE formats .m and .mz.
</p>


<h3>Author(s)</h3>

<p>Jan Philipp Dietrich, Stephen Bi, Florian Humpenoeder, Pascal Sauer
</p>


<h3>See Also</h3>

<p><code>"<a href="#topic+magpie-class">magpie</a>"</code>, <code><a href="#topic+write.magpie">write.magpie</a></code>
</p>

<hr>
<h2 id='read.report'>Read file in report format</h2><span id='topic+read.report'></span>

<h3>Description</h3>

<p>This function reads the content of a reporting file (a file in the model
intercomparison file format *.mif) into a list of MAgPIE objects or a single
MAgPIE object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.report(file, as.list = TRUE, showSeparatorWarning = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read.report_+3A_file">file</code></td>
<td>
<p>file name the object should be read from.</p>
</td></tr>
<tr><td><code id="read.report_+3A_as.list">as.list</code></td>
<td>
<p>if TRUE a list is returned (default), if FALSE it is tried to
merge all information in one MAgPIE object (still under development and
works currently only if the entries for the different models and scenarios
have exactly the same regions and years).</p>
</td></tr>
<tr><td><code id="read.report_+3A_showseparatorwarning">showSeparatorWarning</code></td>
<td>
<p>Boolean (default value TRUE) that decides whether the warning
about the replacement of dots in variable names is displayed (default value) or not.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <strong>Model Intercomparison File Format (MIF)</strong> is the default file
format for data produced by Integrated Assessment Models. It is based on the
common format used for Model Intercomparison Projects such as EMF and SSP
with some slight changes/clarifications in its definition. For interactions
between models this format should be used. For everything else it is at least
recommended to use this format, too.
</p>
<p>Aim of this standardization is to achieve a more flexible and smooth
communication between models and to facilitate the creation of aggregated
outputs from integrated assessment scenario runs which then can easily be
uploaded to external databases such as the EMF or SSP database. By using this
standard most of the required decisions for a working input output interface
between models have already been specified which significantly reduces the
required work to get a new interaction running.
</p>
<p><strong>Definition</strong>
</p>
<p>The format is characterized by the following features:
</p>

<ul>
<li><p> The file ending is &quot;.mif&quot;
</p>
</li>
<li><p> The file is written in ASCII format
</p>
</li>
<li><p> Entries are separated with &quot;;&quot;, every line ends with a &quot;;&quot;
</p>
</li>
<li><p> The file always contains a header
</p>
</li>
<li><p> The format of the header is: <code>Model;Scenario;Region;Variable;Unit;&lt;ADDITIONAL_COLUMNS&gt;;&lt;YEARS&gt;;</code>
</p>
</li></ul>

<p>The first 5 entries always have to exist, &lt;ADDITIONAL_COLUMNS&gt; is additional
information which can be added optionally (e.g. &quot;Description&quot;) and &lt;YEARS&gt;
are the years for which data is delivered. &lt;YEARS&gt; are always written as 4
digit numbers. In the (very unlikely) case that a year before 1000 is used
the number has to start with a 0, e.g. 0950. &lt;ADDITIONAL_COLUMNS&gt; can be
anything, there are no further rules at the moment what it can contain.
However, there are strict rules for naming these columns. Allowed are single
names starting with a capital letter without special characters in it except
&quot;_&quot; which is allowed. Examples: &quot;Description&quot; allowed, &quot;More Description&quot; not
allowed, &quot;More_Description&quot; allowed, &quot;123Description&quot; not allowed,
&quot;Description123&quot; allowed. Scripts using this format must be able to ignore
additional columns. For years there are no specific limitations/requirements
which years should be reported. Scripts dealing with this data must be able
to work with different temporal resolutions. For variables basically
everything can be reported here. Missing values have to be marked with &quot;N/A&quot;.
</p>


<h3>Author(s)</h3>

<p>Jan Philipp Dietrich
</p>


<h3>See Also</h3>

<p><code><a href="#topic+write.report">write.report</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
read.report("report.csv")

## End(Not run)

</code></pre>

<hr>
<h2 id='replace_non_finite'>Replace Non-Finite Data</h2><span id='topic+replace_non_finite'></span>

<h3>Description</h3>

<p>Replaces all instances of non-finite data (<code>NA</code>, <code>NaN</code>, <code>Inf</code>, and <code>-Inf</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>replace_non_finite(x, replace = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="replace_non_finite_+3A_x">x</code></td>
<td>
<p>A vector or <code><a href="#topic+magclass">magpie</a></code> object.</p>
</td></tr>
<tr><td><code id="replace_non_finite_+3A_replace">replace</code></td>
<td>
<p>A value to replace non-finite data with.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector or <code><a href="#topic+magclass">magpie</a></code> object, same as <code>x</code>.
</p>


<h3>Author(s)</h3>

<p>Michaja Pehl
</p>


<h3>Examples</h3>

<pre><code class='language-R'>part  &lt;- new.magpie(letters[1:3], years = 'y1995', names = 'foo')
total &lt;- new.magpie(letters[1:3], years = 'y1995', names = 'foo')

part[,,]  &lt;- c(0, 1, 2)
total[,,] &lt;- c(0, 10, 10)

part / total

replace_non_finite(part / total)

</code></pre>

<hr>
<h2 id='round-methods'>Round-method for MAgPIE objects</h2><span id='topic+round-methods'></span><span id='topic+round+2Cmagpie-method'></span>

<h3>Description</h3>

<p>Round-method for MAgPIE-objects respectively. Works exactly as for arrays.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'magpie'
round(x, digits = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="round-methods_+3A_x">x</code></td>
<td>
<p>a magpie object</p>
</td></tr>
<tr><td><code id="round-methods_+3A_digits">digits</code></td>
<td>
<p>integer indicating the number of decimal places (round) or significant
digits (signif) to be used. Negative values are allowed.</p>
</td></tr>
</table>


<h3>Methods</h3>


<dl>
<dt>x = &quot;magpie&quot;</dt><dd><p> works as round(x) for arrays. </p>
</dd>
</dl>


<hr>
<h2 id='rowSums-methods'>~~ Methods for Function rowSums and rowMeans ~~</h2><span id='topic+rowSums-methods'></span><span id='topic+rowSums+2CANY-method'></span><span id='topic+rowSums+2Cmagpie-method'></span><span id='topic+rowMeans-methods'></span><span id='topic+rowMeans+2CANY-method'></span><span id='topic+rowMeans+2Cmagpie-method'></span>

<h3>Description</h3>

<p>~~ Methods for function <code>rowSums</code> and <code>rowMeans</code>~~
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'magpie'
rowSums(x, na.rm = FALSE, dims = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rowSums-methods_+3A_x">x</code></td>
<td>
<p>object on which calculation should be performed</p>
</td></tr>
<tr><td><code id="rowSums-methods_+3A_na.rm">na.rm</code></td>
<td>
<p>logical. Should missing values (including NaN) be omitted from the calculations?</p>
</td></tr>
<tr><td><code id="rowSums-methods_+3A_dims">dims</code></td>
<td>
<p>integer: Which dimensions are regarded as &quot;rows&quot; or &quot;columns&quot; to sum over. For row*,
the sum or mean is over dimensions dims+1, ...; for col* it is over dimensions 1:dims.</p>
</td></tr>
<tr><td><code id="rowSums-methods_+3A_...">...</code></td>
<td>
<p>further arguments passed to other colSums/colMeans methods</p>
</td></tr>
</table>


<h3>Methods</h3>


<dl>
<dt>list(&quot;signature(x = \&quot;ANY\&quot;)&quot;)</dt><dd><p> normal rowSums and rowMeans method </p>
</dd>
<dt>list(&quot;signature(x = \&quot;magpie\&quot;)&quot;)</dt><dd><p> classical method prepared to
handle MAgPIE objects </p>
</dd> </dl>


<hr>
<h2 id='setItems'>Set Items</h2><span id='topic+setItems'></span>

<h3>Description</h3>

<p>Set items of a given (sub-)dimension of a MAgPIE-object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setItems(x, dim, value, maindim = NULL, raw = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setItems_+3A_x">x</code></td>
<td>
<p>MAgPIE object</p>
</td></tr>
<tr><td><code id="setItems_+3A_dim">dim</code></td>
<td>
<p>Dimension for which the items should be returned. Either number or
name of dimension or a vector of these. See <code><a href="#topic+dimCode">dimCode</a></code> for more details.</p>
</td></tr>
<tr><td><code id="setItems_+3A_value">value</code></td>
<td>
<p>a vector with the length of the main dimension the dimnames should be replaced in / added to.
If set to NULL the corresponding dimension will be removed.</p>
</td></tr>
<tr><td><code id="setItems_+3A_maindim">maindim</code></td>
<td>
<p>main dimension the data should be added to (does not need to be set if <code>dim</code> exists
in the data. Should be set if <code>dim</code> might not exist, or if <code>dim</code> might potentially exist
in a different main dimension than the one anticipated).</p>
</td></tr>
<tr><td><code id="setItems_+3A_raw">raw</code></td>
<td>
<p>if set to FALSE inputs will be corrected (e.g. dots replaced by the letter &quot;p&quot;) if necessary. If
TRUE data will be written as is (risking the creation of inconsistent objects).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the manipulated MAgPIE object
</p>


<h3>Author(s)</h3>

<p>Jan Philipp Dietrich
</p>


<h3>See Also</h3>

<p><code><a href="#topic+getItems">getItems</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- maxample("pop")
setItems(x, "i", paste0("REG", 1:ncells(x)))
</code></pre>

<hr>
<h2 id='setNames-methods'>Get dataset names</h2><span id='topic+setNames-methods'></span><span id='topic+setNames'></span><span id='topic+setNames+2Cmagpie-method'></span><span id='topic+setNames+2CNULL-method'></span>

<h3>Description</h3>

<p>Extracts dataset names of a MAgPIE-object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'magpie'
setNames(object = nm, nm)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setNames-methods_+3A_object">object</code></td>
<td>
<p>MAgPIE object</p>
</td></tr>
<tr><td><code id="setNames-methods_+3A_nm">nm</code></td>
<td>
<p>a vector of names current names should be replaced with. If
only one data element exists you can also set the name to NULL.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>setNames is a shortcut to use a MAgPIE object with manipulated data names.
The setNames method uses the variable names &quot;object&quot; and &quot;nm&quot; in order to be
consistent to the already existing function setNames.
</p>


<h3>Methods</h3>


<dl>
<dt>list(&quot;signature(object = \&quot;ANY\&quot;)&quot;)</dt><dd><p> normal setNames method </p>
</dd>
<dt>list(&quot;signature(object = \&quot;magpie\&quot;)&quot;)</dt><dd><p> setNames for MAgPIE objects</p>
</dd> </dl>



<h3>See Also</h3>

<p><code><a href="#topic+getNames">getNames</a></code>,
</p>

<hr>
<h2 id='show-methods'>~~ Method for function <code>show</code> ~~</h2><span id='topic+show-methods'></span><span id='topic+show'></span><span id='topic+show+2CANY-method'></span><span id='topic+show+2Cmagpie-method'></span>

<h3>Description</h3>

<p>Show a magpie object by calling the default show method, print, or str,
depending on options(&quot;magclass_show_func&quot;).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'magpie'
show(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="show-methods_+3A_object">object</code></td>
<td>
<p>A MAgPIE-object</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Pascal Sauer
</p>

<hr>
<h2 id='sizeCheck'>sizeCheck</h2><span id='topic+sizeCheck'></span>

<h3>Description</h3>

<p>Calculates expected magclass object length and checks that it stays below
the limit defined with magclass_sizeLimit (default = 10^9). This is useful
to prevent out of memory errors in case of unwanted object expansions
Ignored if <code>getOption("magclass_sizeLimit")</code> is negative.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sizeCheck(dim)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sizeCheck_+3A_dim">dim</code></td>
<td>
<p>dimensions of the current object as returned by function <code>dim</code></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jan Philipp Dietrich
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pop &lt;- maxample("pop")
magclass:::sizeCheck(dim(pop))

## Not run: 
magclass:::sizeCheck(c(6765L, 10946L, 17711L))

## End(Not run)
</code></pre>

<hr>
<h2 id='spatRasterToDataset'>spatRasterToDataset</h2><span id='topic+spatRasterToDataset'></span>

<h3>Description</h3>

<p>Convert a SpatRaster to a SpatRasterDataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spatRasterToDataset(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spatRasterToDataset_+3A_x">x</code></td>
<td>
<p>SpatRaster with names of the form &quot;y[0-9]+..[varname]&quot;</p>
</td></tr>
</table>


<h3>Value</h3>

<p>SpatRasterDataset
</p>


<h3>Author(s)</h3>

<p>Pascal Sauer
</p>

<hr>
<h2 id='str.magpie'>str</h2><span id='topic+str.magpie'></span>

<h3>Description</h3>

<p>str method for MAgPIE objects for conventient display of the structure of a magpie object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'magpie'
str(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="str.magpie_+3A_object">object</code></td>
<td>
<p>MAgPIE object</p>
</td></tr>
<tr><td><code id="str.magpie_+3A_...">...</code></td>
<td>
<p>arguments to be passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In contrast to the default str this will not show the attributes of object@.Data as these
contain only a duplicate of dimnames. Also, dim is not shown, because the information it
provides is implicitly included in dimnames.
</p>


<h3>Author(s)</h3>

<p>Pascal Sauer
</p>


<h3>See Also</h3>

<p><code><a href="utils.html#topic+str">str</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>str(maxample("pop"))
</code></pre>

<hr>
<h2 id='suppressSpecificWarnings'>suppressSpecificWarnings</h2><span id='topic+suppressSpecificWarnings'></span>

<h3>Description</h3>

<p>Like <code><a href="base.html#topic+suppressWarnings">suppressWarnings</a></code>, but instead of suppressing all warnings this only suppresses
warnings if they match the given pattern.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>suppressSpecificWarnings(expr, regularExpr, fixed = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="suppressSpecificWarnings_+3A_expr">expr</code></td>
<td>
<p>The expression/code to evaluate, can be a block of code inside curly braces.</p>
</td></tr>
<tr><td><code id="suppressSpecificWarnings_+3A_regularexpr">regularExpr</code></td>
<td>
<p>Only warnings matching this regular expression are suppressed.</p>
</td></tr>
<tr><td><code id="suppressSpecificWarnings_+3A_fixed">fixed</code></td>
<td>
<p>Match the literal string given by regularExpr instead of interpreting it
as a regular expression. Passed to <code><a href="base.html#topic+grepl">grepl</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The result of evaluating expr.
</p>


<h3>Author(s)</h3>

<p>Pascal Sauer
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+suppressWarnings">suppressWarnings</a></code>
</p>

<hr>
<h2 id='time_interpolate'>time_interpolate</h2><span id='topic+time_interpolate'></span>

<h3>Description</h3>

<p>Function to extrapolate missing years in MAgPIE objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>time_interpolate(
  dataset,
  interpolated_year,
  integrate_interpolated_years = FALSE,
  extrapolation_type = "linear"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="time_interpolate_+3A_dataset">dataset</code></td>
<td>
<p>An MAgPIE object</p>
</td></tr>
<tr><td><code id="time_interpolate_+3A_interpolated_year">interpolated_year</code></td>
<td>
<p>Vector of years, of which values are required. Can
be in the formats 1999 or y1999.</p>
</td></tr>
<tr><td><code id="time_interpolate_+3A_integrate_interpolated_years">integrate_interpolated_years</code></td>
<td>
<p>FALSE returns only the dataset of the
interpolated year, TRUE returns the whole dataset, including all years of
data and the itnerpolated year</p>
</td></tr>
<tr><td><code id="time_interpolate_+3A_extrapolation_type">extrapolation_type</code></td>
<td>
<p>Determines what happens if extrapolation is
required, i.e. if a requested year lies outside the range of years in
<code>dataset</code>. Specify &quot;linear&quot; for a linear extrapolation. &quot;constant&quot; uses
the value from dataset closest in time to the requested year.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Uses linear extrapolation to estimate the values of the interpolated
year, using the values of the two surrounding years. If the value is before
or after the years in data, the two closest neighbours are used for
extrapolation.
</p>


<h3>Author(s)</h3>

<p>Benjamin Bodirsky, Jan Philipp Dietrich
</p>


<h3>See Also</h3>

<p><code><a href="#topic+convergence">convergence</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
p &lt;- maxample("pop")
time_interpolate(p, "y2000", integrate = TRUE)
time_interpolate(p, c("y1980", "y2000"), integrate = TRUE, extrapolation_type = "constant")
</code></pre>

<hr>
<h2 id='unitsplit'>splits a data.frame or vector of strings with form 'variable (unit)' into
a data.frame with variable and unit separated</h2><span id='topic+unitsplit'></span>

<h3>Description</h3>

<p>splits a data.frame or vector of strings with form 'variable (unit)' into
a data.frame with variable and unit separated
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unitsplit(x, col = "variable")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unitsplit_+3A_x">x</code></td>
<td>
<p>data.frame or vector of strings</p>
</td></tr>
<tr><td><code id="unitsplit_+3A_col">col</code></td>
<td>
<p>column name. Default: variable</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jan Philipp Dietrich, Mika Pfl√ºger, Oliver Richters
</p>

<hr>
<h2 id='unwrap'>Unwrap</h2><span id='topic+unwrap'></span>

<h3>Description</h3>

<p>Creates a higher dimensional array by separating all subdimensions in
the third dimension of a MAgPIE object and returning them as
separate dimension.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unwrap(x, sep = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unwrap_+3A_x">x</code></td>
<td>
<p>A MAgPIE object</p>
</td></tr>
<tr><td><code id="unwrap_+3A_sep">sep</code></td>
<td>
<p>deprecated, please do not use anymore</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An array with the full dimensionality of the original data
</p>


<h3>Author(s)</h3>

<p>Jan Philipp Dietrich
</p>


<h3>See Also</h3>

<p><code><a href="#topic+wrap">wrap</a></code>,<code><a href="#topic+fulldim">fulldim</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
a &lt;- as.magpie(array(1:6, c(3, 2), list(c("bla", "blub", "ble"), c("up", "down"))))
unwrap(a)
</code></pre>

<hr>
<h2 id='where'>where</h2><span id='topic+where'></span>

<h3>Description</h3>

<p>Analysis function for magpie objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>where(x, plot = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="where_+3A_x">x</code></td>
<td>
<p>A logical statement with a magpie object</p>
</td></tr>
<tr><td><code id="where_+3A_plot">plot</code></td>
<td>
<p>deprecated. Use the function whereplot in package luplot.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of analysis parameters
</p>


<h3>Author(s)</h3>

<p>Benjamin Leon Bodirsky, Jan Philipp Dietrich
</p>


<h3>See Also</h3>

<p>whereplot in package luplot
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
p &lt;- maxample("pop")
where(p &gt; 500)
</code></pre>

<hr>
<h2 id='wrap'>Wrap</h2><span id='topic+wrap'></span>

<h3>Description</h3>

<p>Reshape an array or a matrix by permuting and/or joining dimensions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wrap(x, map = list(NA), sep = ".")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wrap_+3A_x">x</code></td>
<td>
<p>An array</p>
</td></tr>
<tr><td><code id="wrap_+3A_map">map</code></td>
<td>
<p>A list of length equal to the number of dimensions in the
reshaped array. Each element should be an integer vectors specifying the
dimensions to be joined in corresponding new dimension. One element may
equal NA to indicate that that dimension should be a join of all
non-specified (remaining) dimensions. Default is to wrap everything into a
vector.</p>
</td></tr>
<tr><td><code id="wrap_+3A_sep">sep</code></td>
<td>
<p>A character separating joined dimension names</p>
</td></tr>
</table>


<h3>Note</h3>

<p>This function is extracted from the R.utils library which is licensed
under LGPL&gt;=2.1 and written by Henrik Bengtsson.
</p>


<h3>Author(s)</h3>

<p>Henrik Bengtsson, Jan Philipp Dietrich
</p>


<h3>See Also</h3>

<p><code><a href="#topic+unwrap">unwrap</a></code>,<code><a href="#topic+fulldim">fulldim</a></code>
</p>

<hr>
<h2 id='write.magpie'>Write MAgPIE-object to file</h2><span id='topic+write.magpie'></span>

<h3>Description</h3>

<p>Writes a magpie object to a file. The file type is determined by the filename extension.
The written file can be read again using <code><a href="#topic+read.magpie">read.magpie</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write.magpie(
  x,
  file_name,
  file_folder = "",
  file_type = NULL,
  append = FALSE,
  comment = NULL,
  comment.char = "*",
  mode = NULL,
  zname = "time",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="write.magpie_+3A_x">x</code></td>
<td>
<p>a magclass object. An exception is that formats written via the raster package
(currently &quot;nc&quot;, &quot;asc&quot;, &quot;grd&quot; and &quot;tif&quot;) also accept RasterBrick objects which have
been previously created from a magclass object via as.RasterBrick)</p>
</td></tr>
<tr><td><code id="write.magpie_+3A_file_name">file_name</code></td>
<td>
<p>file name including file ending (wildcards are supported).
Optionally also the full path can be specified here (instead of splitting it
to file_name and file_folder)</p>
</td></tr>
<tr><td><code id="write.magpie_+3A_file_folder">file_folder</code></td>
<td>
<p>folder the file should be written to (alternatively you
can also specify the full path in file_name - wildcards are supported)</p>
</td></tr>
<tr><td><code id="write.magpie_+3A_file_type">file_type</code></td>
<td>
<p>Format the data should be stored as. If file_type=NULL
the file ending of the file_name is used as format. See detailed
description for a list of available file types. Please be aware that the
file_name is independent of the file_type you choose here, so no additional
file ending will be added!</p>
</td></tr>
<tr><td><code id="write.magpie_+3A_append">append</code></td>
<td>
<p>Decides whether an existing file should be overwritten (FALSE)
or the data should be added to it (TRUE). Append = TRUE only works if the
existing data can be combined with the new data using the mbind function</p>
</td></tr>
<tr><td><code id="write.magpie_+3A_comment">comment</code></td>
<td>
<p>Vector of strings: Optional comment giving additional
information about the data. If different to NULL this will overwrite the
content of attr(x,&quot;comment&quot;)</p>
</td></tr>
<tr><td><code id="write.magpie_+3A_comment.char">comment.char</code></td>
<td>
<p>character: a character vector of length one containing a
single character or an empty string. Use &quot;&quot; to turn off the interpretation
of comments altogether.</p>
</td></tr>
<tr><td><code id="write.magpie_+3A_mode">mode</code></td>
<td>
<p>File permissions the file should be written with as 3-digit
number (e.g. &quot;777&quot; means full access for user, group and all, &quot;750&quot; means
full access for user, read access for group and no acess for anybody else).
Set to NULL system defaults will be used. Access codes are identical to the
codes used in unix function chmod.</p>
</td></tr>
<tr><td><code id="write.magpie_+3A_zname">zname</code></td>
<td>
<p>name of the time variable for raster files like nc, asc, grd and tif</p>
</td></tr>
<tr><td><code id="write.magpie_+3A_...">...</code></td>
<td>
<p>additional arguments passed to specific write functions</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function supports writing the following file types:
</p>

<ul>
<li><p> &quot;cs2&quot; is the new standard format for cellular data with or without header
and the first columns (year,regiospatial) or only (regiospatial)
</p>
</li>
<li><p> &quot;cs2b&quot; is identical to &quot;cs2&quot; except that it will suppress the data name
if it has only 1 element in the data dimension.
</p>
</li>
<li><p> &quot;csv&quot; is the standard format for regional data with or without header and
the first columns (year,region,cellnumber) or only (region,cellnumber)
</p>
</li>
<li><p> &quot;cs3&quot; is another csv format which is
specifically designed for multidimensional data for usage in GAMS.
</p>
</li>
<li><p> &quot;cs4&quot; alternative multidimensional format compatible to GAMS, in contrast
to cs3 it can also handle sparse data
</p>
</li>
<li><p> &quot;csvr&quot;, &quot;cs2r&quot;, &quot;cs3r&quot;, &quot;cs4r&quot; which are the same formats as the ones
previously explained with the only difference that they have a REMIND
compatible format
</p>
</li>
<li><p> &quot;cs5&quot; a more generalized version of cs4
</p>
</li>
<li><p> &quot;rds&quot; is an R-default format for storing R objects
</p>
</li>
<li><p> &quot;m&quot; (magpie) and &quot;mz&quot; (magpie zipped) are new formats developed to allow
a less storage intensive management of MAgPIE-data. The only difference
between both formats is that .mz is gzipped whereas .m is not compressed. So
.mz needs less memory, whereas .m might have a higher compatibility to other
languages
</p>
</li>
<li><p> &quot;asc&quot; is the ASCII grid format. It can only be applied for gridded data
and writes one file per year per data column. In the case that more than
one year and data column is supplied several files are written with the
structure filename_year_datacolumn.asc
</p>
</li>
<li><p> &quot;tif&quot; is the  GEOtiff format for gridded data.
</p>
</li>
<li><p> &quot;grd&quot; is the native raster format for gridded data.
</p>
</li>
<li><p> &quot;nc&quot; is the netCDF format for gridded data.
</p>
</li></ul>



<h3>Note</h3>

<p>The binary MAgPIE formats .m and .mz have the following content/structure
(you only have to care for that if you want to implement
read.magpie/write.magpie functions in other languages): <br /> <br />
[ FileFormatVersion | Current file format version number (currently 6) | integer | 2 Byte ] <br />
[ nchar_comment | Number of character bytes of the file comment | integer | 4 Byte ] <br />
[ nbyte_metadata | Number of bytes of the serialized metadata (currently = 0) | integer | 4 Byte ] <br />
[ nchar_sets | Number of characters bytes of all regionnames + 2 delimiter | integer | 2 Byte] <br />
[ nyears | Number of years | integer | 2 Byte ]<br />
[ yearList | All years of the dataset (0, if year is not present) | integer | 2*nyears Byte ] <br />
[ ncells | Number of cells | integer | 4 Byte ]<br />
[ nchar_cell | Number of characters bytes of all regionnames + (nreg-1) for delimiters | integer | 4 Byte ] <br />
[ cells | Cell names saved as cell1\cell2 (\n is the delimiter) | character | 1*nchar_cell Byte ] <br />
[ nelem | Total number of data elements | integer | 4 Byte ] <br />
[ nchar_data | Number of char. bytes of all datanames + (ndata - 1) for delimiters | integer | 4 Byte ] <br />
[ datanames | Names saved in the format data1\ndata2 (\n as del.) | character | 1*nchar_data Byte ] <br />
[ data | Data of the MAgPIE array in vectorized form | numeric | 4*nelem Byte ] <br />
[ comment | Comment with additional information about the data | character | 1*nchar_comment Byte ] <br />
[ sets | Set names with \n as delimiter | character | 1*nchar_sets Byte] <br />
[ metadata | serialized metadata information (currently not in use) | bytes | 1*nbyte_metadata Byte] <br />
</p>


<h3>Author(s)</h3>

<p>Jan Philipp Dietrich, Stephen Bi, Florian Humpenoeder, Pascal Sauer
</p>


<h3>See Also</h3>

<p><code>"<a href="#topic+magpie-class">magpie</a>"</code>,
<code><a href="#topic+read.magpie">read.magpie</a></code>,<code><a href="#topic+mbind">mbind</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pop &lt;- maxample("pop")
path &lt;- tempfile(fileext = ".mz")
write.magpie(pop, path)
pop2 &lt;- read.magpie(path)
</code></pre>

<hr>
<h2 id='write.report'>Write file in report format</h2><span id='topic+write.report'></span>

<h3>Description</h3>

<p>This function writes the content of a MAgPIE object into a file or returns
it directly using the reporting format as it is used for many model
inter-comparisons.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write.report(
  x,
  file = NULL,
  model = NULL,
  scenario = NULL,
  unit = NULL,
  ndigit = 4,
  append = FALSE,
  skipempty = TRUE,
  extracols = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="write.report_+3A_x">x</code></td>
<td>
<p>MAgPIE object or a list of lists with MAgPIE objects as created by
read.report. In the latter case settings for model and scenario are
overwritten by the information given in the list.</p>
</td></tr>
<tr><td><code id="write.report_+3A_file">file</code></td>
<td>
<p>file name the object should be written to. If NULL the formatted
content is returned</p>
</td></tr>
<tr><td><code id="write.report_+3A_model">model</code></td>
<td>
<p>Name of the model which calculated the results</p>
</td></tr>
<tr><td><code id="write.report_+3A_scenario">scenario</code></td>
<td>
<p>The scenario which was used to get that results.</p>
</td></tr>
<tr><td><code id="write.report_+3A_unit">unit</code></td>
<td>
<p>Unit of the data. Only relevant if unit is not already supplied
in Dimnames (format &quot;name (unit)&quot;). Can be either a single string or a
vector of strings with a length equal to the number of different data
elements in the MAgPIE object</p>
</td></tr>
<tr><td><code id="write.report_+3A_ndigit">ndigit</code></td>
<td>
<p>Number of digits the output should have</p>
</td></tr>
<tr><td><code id="write.report_+3A_append">append</code></td>
<td>
<p>Logical which decides whether data should be added to an
existing file or an existing file should be overwritten</p>
</td></tr>
<tr><td><code id="write.report_+3A_skipempty">skipempty</code></td>
<td>
<p>Determines whether empty entries (all data NA) should be
written to file or not.</p>
</td></tr>
<tr><td><code id="write.report_+3A_extracols">extracols</code></td>
<td>
<p>names of dimensions which should appear in the output as additional columns</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jan Philipp Dietrich
</p>


<h3>See Also</h3>

<p><code><a href="#topic+read.report">read.report</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
write.report(maxample("pop"))
</code></pre>

<hr>
<h2 id='write.report2'>Write file in report format</h2><span id='topic+write.report2'></span>

<h3>Description</h3>

<p>This function is deprecated, please use <code><a href="#topic+write.report">write.report</a></code> instead.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write.report2(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="write.report2_+3A_...">...</code></td>
<td>
<p>arguments are forwarded to <code><a href="#topic+write.report">write.report</a></code></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jan Philipp Dietrich
</p>


<h3>See Also</h3>

<p><code><a href="#topic+write.report">write.report</a></code>
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
