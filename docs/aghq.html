<!DOCTYPE html><html><head><title>Help for package aghq</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {aghq}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#aghq'><p>Adaptive Gauss-Hermite Quadrature</p></a></li>
<li><a href='#compute_moment'><p>Compute moments</p></a></li>
<li><a href='#compute_pdf_and_cdf'><p>Density and Cumulative Distribution Function</p></a></li>
<li><a href='#compute_quantiles'><p>Quantiles</p></a></li>
<li><a href='#correct_marginals'><p>Correct the posterior marginals of a fitted aghq object</p></a></li>
<li><a href='#default_control'><p>Default control arguments for <code>aghq::aghq()</code>.</p></a></li>
<li><a href='#default_control_marglaplace'><p>Default control arguments for <code>aghq::marginal_laplace()</code>.</p></a></li>
<li><a href='#default_control_tmb'><p>Default control arguments for <code>aghq::marginal_laplace_tmb()</code>.</p></a></li>
<li><a href='#default_transformation'><p>Default transformation</p></a></li>
<li><a href='#gcdata'><p>Globular Clusters data for Milky Way mass estimation</p></a></li>
<li><a href='#gcdatalist'><p>Transformed Globular Clusters data</p></a></li>
<li><a href='#get_hessian'><p>Obtain the Hessian from an aghq object</p></a></li>
<li><a href='#get_log_normconst'><p>Obtain the log-normalizing constant from a fitted quadrature object</p></a></li>
<li><a href='#get_mode'><p>Obtain the mode from an aghq object</p></a></li>
<li><a href='#get_nodesandweights'><p>Obtain the nodes and weights table from a fitted quadrature object</p></a></li>
<li><a href='#get_numquadpoints'><p>Obtain the number of quadrature nodes used from an aghq object</p></a></li>
<li><a href='#get_opt_results'><p>Obtain the optimization results from an aghq object</p></a></li>
<li><a href='#get_param_dim'><p>Obtain the parameter dimension from an aghq object</p></a></li>
<li><a href='#interpolate_marginal_posterior'><p>Interpolate the Marginal Posterior</p></a></li>
<li><a href='#laplace_approximation'><p>Laplace Approximation</p></a></li>
<li><a href='#make_moment_function'><p>Moments of Positive Functions</p></a></li>
<li><a href='#make_numeric_moment_function'><p>Compute numeric moments</p></a></li>
<li><a href='#make_transformation'><p>Marginal Parameter Transformations</p></a></li>
<li><a href='#marginal_laplace'><p>Marginal Laplace approximation</p></a></li>
<li><a href='#marginal_laplace_tmb'><p>AGHQ-normalized marginal Laplace approximation from a TMB function template</p></a></li>
<li><a href='#marginal_posterior'><p>Marginal Posteriors</p></a></li>
<li><a href='#nested_quadrature'><p>Nested, sparse Gaussian quadrature in AGHQ</p></a></li>
<li><a href='#normalize_logpost'><p>Normalize the joint posterior using AGHQ</p></a></li>
<li><a href='#optimize_theta'><p>Obtain function information necessary for performing quadrature</p></a></li>
<li><a href='#plot.aghq'><p>Plot method for AGHQ objects</p></a></li>
<li><a href='#print.aghq'><p>Print method for AGHQ objects</p></a></li>
<li><a href='#print.aghqsummary'><p>Print method for AGHQ summary objects</p></a></li>
<li><a href='#print.laplace'><p>Print method for AGHQ objects</p></a></li>
<li><a href='#print.laplacesummary'><p>Print method for laplacesummary objects</p></a></li>
<li><a href='#print.marginallaplacesummary'><p>Summary statistics for models using marginal Laplace approximations</p></a></li>
<li><a href='#sample_marginal'><p>Exact independent samples from an approximate posterior distribution</p></a></li>
<li><a href='#summary.aghq'><p>Summary statistics computed using AGHQ</p></a></li>
<li><a href='#summary.laplace'><p>Summary method for Laplace Approximation objects</p></a></li>
<li><a href='#summary.marginallaplace'><p>Summary statistics for models using marginal Laplace approximations</p></a></li>
<li><a href='#validate_control'><p>Validate a control list</p></a></li>
<li><a href='#validate_moment'><p>Validate a moment function object</p></a></li>
<li><a href='#validate_transformation'><p>Validate a transformation object</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Adaptive Gauss Hermite Quadrature for Bayesian Inference</td>
</tr>
<tr>
<td>Version:</td>
<td>0.4.1</td>
</tr>
<tr>
<td>Author:</td>
<td>Alex Stringer</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Alex Stringer &lt;alex.stringer@uwaterloo.ca&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Adaptive Gauss Hermite Quadrature for Bayesian inference.
    The AGHQ method for normalizing posterior distributions
    and making Bayesian inferences based on them. Functions are provided for doing
    quadrature and marginal Laplace approximations, and summary methods are provided
    for making inferences based on the results. 
    See Stringer (2021). "Implementing Adaptive Quadrature for Bayesian Inference: 
    the aghq Package" &lt;<a href="https://arxiv.org/abs/2101.04468">arXiv:2101.04468</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.1</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>methods, mvQuad, Matrix, rlang, polynom, splines, numDeriv</td>
</tr>
<tr>
<td>Suggests:</td>
<td>trustOptim, trust, testthat (&ge; 2.1.0), parallel</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-06-02 13:20:58 UTC; alexstringer</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-06-02 13:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='aghq'>Adaptive Gauss-Hermite Quadrature</h2><span id='topic+aghq'></span>

<h3>Description</h3>

<p>Normalize the log-posterior distribution using Adaptive Gauss-Hermite Quadrature.
This function takes in a function and its gradient and Hessian, and returns
a list of information about the normalized posterior, with methods for summarizing
and plotting.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>aghq(
  ff,
  k,
  startingvalue,
  transformation = default_transformation(),
  optresults = NULL,
  basegrid = NULL,
  control = default_control(),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="aghq_+3A_ff">ff</code></td>
<td>
<p>A list with three elements:
</p>

<ul>
<li><p><code>fn</code>: function taking argument <code>theta</code> and returning a numeric
value representing the log-posterior at <code>theta</code>
</p>
</li>
<li><p><code>gr</code>: function taking argument <code>theta</code> and returning a numeric
vector representing the gradient of the log-posterior at <code>theta</code>
</p>
</li>
<li><p><code>he</code>: function taking argument <code>theta</code> and returning a numeric
matrix representing the hessian of the log-posterior at <code>theta</code>
</p>
</li></ul>

<p>The user may wish to use <code>numDeriv::grad</code> and/or <code>numDeriv::hessian</code> to
obtain these. Alternatively, the user may consider the <code>TMB</code> package. This
list is deliberately formatted to match the output of <code>TMB::MakeADFun</code>.</p>
</td></tr>
<tr><td><code id="aghq_+3A_k">k</code></td>
<td>
<p>Integer, the number of quadrature points to use. I suggest at least 3. k = 1 corresponds to a Laplace
approximation.</p>
</td></tr>
<tr><td><code id="aghq_+3A_startingvalue">startingvalue</code></td>
<td>
<p>Value to start the optimization. <code>ff$fn(startingvalue)</code>,
<code>ff$gr(startingvalue)</code>, and <code>ff$he(startingvalue)</code> must all return
appropriate values without error.</p>
</td></tr>
<tr><td><code id="aghq_+3A_transformation">transformation</code></td>
<td>
<p>Optional. Do the quadrature for parameter <code>theta</code>, but
return summaries and plots for parameter <code>g(theta)</code>.
<code>transformation</code> is either: a) an <code>aghqtrans</code> object returned by <code>aghq::make_transformation</code>,
or b) a list that will be passed to that function internally. See <code>?aghq::make_transformation</code> for details.</p>
</td></tr>
<tr><td><code id="aghq_+3A_optresults">optresults</code></td>
<td>
<p>Optional. A list of the results of the optimization of the log
posterior, formatted according to the output of <code>aghq::optimize_theta</code>. The
<code>aghq::aghq</code> function handles the optimization for you; passing this list
overrides this, and is useful for when you know your optimization is too difficult to be
handled by general-purpose software. See the software paper for several examples of this.
If you're unsure whether this option is needed for your problem then it probably is not.</p>
</td></tr>
<tr><td><code id="aghq_+3A_basegrid">basegrid</code></td>
<td>
<p>Optional. Provide an object of class <code>NIGrid</code> from the <code>mvQuad</code>
package, representing the base quadrature rule that will be adapted. This is only
for users who want more complete control over the quadrature, and is not necessary
if you are fine with the default option which basically corresponds to
<code>mvQuad::createNIGrid(length(theta),'GHe',k,'product')</code>. <strong>Note</strong>: the <code>mvQuad</code>
functions used within <code>aghq</code> operate on grids in memory, so your <code>basegrid</code>
object will be changed after you run <code>aghq</code>.</p>
</td></tr>
<tr><td><code id="aghq_+3A_control">control</code></td>
<td>
<p>A list with elements
</p>

<ul>
<li><p><code>method</code>: optimization method to use:
</p>

<ul>
<li><p>'sparse_trust' (default): <code>trustOptim::trust.optim</code> with <code>method = 'sparse'</code>
</p>
</li>
<li><p>'SR1' (default): <code>trustOptim::trust.optim</code> with <code>method = 'SR1'</code>
</p>
</li>
<li><p>'trust': <code>trust::trust</code>
</p>
</li>
<li><p>'BFGS': <code>optim(...,method = "BFGS")</code>
</p>
</li></ul>

<p>Default is 'sparse_trust'.

</p>
</li>
<li><p><code>optcontrol</code>: optional: a list of control parameters to pass to the
internal optimizer you chose. The <code>aghq</code> package uses sensible defaults.
</p>
</li></ul>
</td></tr>
<tr><td><code id="aghq_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to <code>ff$fn</code>, <code>ff$gr</code>, and <code>ff$he</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When <code>k = 1</code> the AGHQ method is a Laplace approximation, and you should use
the <code>aghq::laplace_approximation</code> function, since some of the methods for
<code>aghq</code> objects won't work with only one quadrature point. Objects of
class <code>laplace</code> have different methods suited to this case. See <code>?aghq::laplace_approximation</code>.
</p>


<h3>Value</h3>

<p>An object of class <code>aghq</code> which is a list containing elements:
</p>

<ul>
<li><p>normalized_posterior: The output of the <code>normalize_logpost</code> function, which
itself is a list with elements:
</p>

<ul>
<li><p><code>nodesandweights</code>: a dataframe containing the nodes and weights for the adaptive quadrature rule, with the un-normalized and normalized log posterior evaluated at the nodes.
</p>
</li>
<li><p><code>thegrid</code>: a <code>NIGrid</code> object from the <code>mvQuad</code> package, see <code>?mvQuad::createNIGrid</code>.
</p>
</li>
<li><p><code>lognormconst</code>: the actual result of the quadrature: the log of the normalizing constant of the posterior.
</p>
</li></ul>

</li>
<li><p>marginals: a list of the same length as <code>startingvalue</code> of which element <code>j</code>
is the result of calling <code>aghq::marginal_posterior</code> with that <code>j</code>. This is
a tbl_df/tbl/data.frame containing the normalized log marginal posterior
for theta_j evaluated at the original quadrature points. Has columns
<code>"thetaj","logpost_normalized","weights"</code>, where <code>j</code> is the <code>j</code> you specified.

</p>
</li>
<li><p>optresults: information and results from the optimization of the log posterior, the
result of calling <code>aghq::optimize_theta</code>. This a list with elements:
</p>

<ul>
<li><p><code>ff</code>: the function list that was provided
</p>
</li>
<li><p><code>mode</code>: the mode of the log posterior
</p>
</li>
<li><p><code>hessian</code>: the hessian of the log posterior at the mode
</p>
</li>
<li><p><code>convergence</code>: specific to the optimizer used, a message indicating whether it converged
</p>
</li></ul>


</li>
<li><p>control: the control parameters passed
</p>
</li></ul>



<h3>See Also</h3>

<p>Other quadrature: 
<code><a href="#topic+get_hessian">get_hessian</a>()</code>,
<code><a href="#topic+get_log_normconst">get_log_normconst</a>()</code>,
<code><a href="#topic+get_mode">get_mode</a>()</code>,
<code><a href="#topic+get_nodesandweights">get_nodesandweights</a>()</code>,
<code><a href="#topic+get_numquadpoints">get_numquadpoints</a>()</code>,
<code><a href="#topic+get_opt_results">get_opt_results</a>()</code>,
<code><a href="#topic+get_param_dim">get_param_dim</a>()</code>,
<code><a href="#topic+laplace_approximation">laplace_approximation</a>()</code>,
<code><a href="#topic+marginal_laplace_tmb">marginal_laplace_tmb</a>()</code>,
<code><a href="#topic+marginal_laplace">marginal_laplace</a>()</code>,
<code><a href="#topic+nested_quadrature">nested_quadrature</a>()</code>,
<code><a href="#topic+normalize_logpost">normalize_logpost</a>()</code>,
<code><a href="#topic+optimize_theta">optimize_theta</a>()</code>,
<code><a href="#topic+plot.aghq">plot.aghq</a>()</code>,
<code><a href="#topic+print.aghqsummary">print.aghqsummary</a>()</code>,
<code><a href="#topic+print.aghq">print.aghq</a>()</code>,
<code><a href="#topic+print.laplacesummary">print.laplacesummary</a>()</code>,
<code><a href="#topic+print.laplace">print.laplace</a>()</code>,
<code><a href="#topic+print.marginallaplacesummary">print.marginallaplacesummary</a>()</code>,
<code><a href="#topic+summary.aghq">summary.aghq</a>()</code>,
<code><a href="#topic+summary.laplace">summary.laplace</a>()</code>,
<code><a href="#topic+summary.marginallaplace">summary.marginallaplace</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
logfteta2d &lt;- function(eta,y) {
  # eta is now (eta1,eta2)
  # y is now (y1,y2)
  n &lt;- length(y)
  n1 &lt;- ceiling(n/2)
  n2 &lt;- floor(n/2)
  y1 &lt;- y[1:n1]
  y2 &lt;- y[(n1+1):(n1+n2)]
  eta1 &lt;- eta[1]
  eta2 &lt;- eta[2]
  sum(y1) * eta1 - (length(y1) + 1) * exp(eta1) - sum(lgamma(y1+1)) + eta1 +
    sum(y2) * eta2 - (length(y2) + 1) * exp(eta2) - sum(lgamma(y2+1)) + eta2
}
set.seed(84343124)
n1 &lt;- 5
n2 &lt;- 5
n &lt;- n1+n2
y1 &lt;- rpois(n1,5)
y2 &lt;- rpois(n2,5)
objfunc2d &lt;- function(x) logfteta2d(x,c(y1,y2))
funlist2d &lt;- list(
  fn = objfunc2d,
  gr = function(x) numDeriv::grad(objfunc2d,x),
  he = function(x) numDeriv::hessian(objfunc2d,x)
)

thequadrature &lt;- aghq(funlist2d,3,c(0,0))

</code></pre>

<hr>
<h2 id='compute_moment'>Compute moments</h2><span id='topic+compute_moment'></span><span id='topic+compute_moment.list'></span><span id='topic+compute_moment.aghq'></span><span id='topic+compute_moment.default'></span>

<h3>Description</h3>

<p>Compute the moment of any function ff using AGHQ.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_moment(obj, ...)

## S3 method for class 'list'
compute_moment(
  obj,
  ff = function(x) 1,
  gg = NULL,
  nn = NULL,
  type = c("raw", "central"),
  method = c("auto", "reuse", "correct"),
  ...
)

## S3 method for class 'aghq'
compute_moment(
  obj,
  ff = function(x) 1,
  gg = NULL,
  nn = NULL,
  type = c("raw", "central"),
  method = c("auto", "reuse", "correct"),
  ...
)

## Default S3 method:
compute_moment(
  obj,
  ff = function(x) 1,
  gg = NULL,
  method = c("auto", "reuse", "correct"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute_moment_+3A_obj">obj</code></td>
<td>
<p>Object of class <code>aghq</code> output by <code>aghq::aghq()</code>. See <code>?aghq</code>.</p>
</td></tr>
<tr><td><code id="compute_moment_+3A_...">...</code></td>
<td>
<p>Used to pass additional argument <code>ff</code>.</p>
</td></tr>
<tr><td><code id="compute_moment_+3A_ff">ff</code></td>
<td>
<p>Any R function which takes in a numeric vector and returns a numeric vector. Exactly one of <code>ff</code> or <code>gg</code> must be provided. If both are provided, <code>aghq::compute_moment()</code> will use <code>gg</code>,
without warning.</p>
</td></tr>
<tr><td><code id="compute_moment_+3A_gg">gg</code></td>
<td>
<p>The output of, or an object which may be input to <code>aghq::make_moment_function()</code>. See documentation of that function. Exactly one of <code>ff</code> or <code>gg</code> must be provided. If both are provided, <code>aghq::compute_moment()</code> will use <code>gg</code>,
without warning.</p>
</td></tr>
<tr><td><code id="compute_moment_+3A_nn">nn</code></td>
<td>
<p>A numeric scalar. Compute the approximate moment of this order, <code>E(theta^nn|Y)</code>. See details.
If <code>nn</code> is provided, <code>compute_moment</code> will use it over <code>ff</code> or <code>gg</code>,
without warning.</p>
</td></tr>
<tr><td><code id="compute_moment_+3A_type">type</code></td>
<td>
<p>Either <code>'raw'</code> (default) or <code>'central'</code>, see details.</p>
</td></tr>
<tr><td><code id="compute_moment_+3A_method">method</code></td>
<td>
<p>Method for computing the quadrature points used to approximate moment. One of <code>'reuse'</code> (default) or <code>'correct'</code>. See details. The default SHOULD be <code>'correct'</code>; it is currently
set to <code>'reuse'</code> to maintain compatibility of results with previous versions. This will be switched in a future major release.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If multiple of <code>nn</code>, <code>gg</code>, and <code>ff</code> are provided, then <code>compute_moment</code>
will use <code>nn</code>, <code>gg</code>, or <code>ff</code>, in that order, without warning.
</p>
<p>There are several approximations available. The &quot;best&quot; one is obtained by specifying <code>gg</code>
and using <code>method = 'correct'</code>. This recomputes the mode and curvature for the
function <code>g(theta)posterior(theta)</code>, and takes the ratio of the AGHQ approximation
to this function to the AGHQ approximation to the marginal likelihood. This obtains the
same relative rate of convergence as the AGHQ approximation to the marginal likelihood. It
may take a little extra time, and only works for <strong>positive, scalar-valued</strong> functions <code>g</code>.
</p>
<p><code>method = 'reuse'</code> re-uses the AGHQ adapted points and weights. It's faster than the
correct method, because it does not involve any new optimization, it's just a weighted sum.
No convergence theory. Seems to work ok in &quot;practice&quot;. &quot;Works&quot; for arbitrary <code>g</code>.
</p>
<p>Specifying <code>ff</code> instead of <code>gg</code> automatically uses <code>method = 'reuse'</code>. This
interface is provided for backwards compatibility mostly. However, one advantage is that
it allows for <strong>vector-valued</strong> functions, in which case it just returns the corresponding
vector of approximate moments. Also, it only requires the adapted nodes and weights, not
the ability to evaluate the log-posterior and its derivatives, although this is unlikely
to be a practical concern.
</p>
<p>Specifying a numeric value <code>nn</code> will return the moment <code>E(theta^nn|Y)</code>.
This automatically does some internal shifting to get the evaluations away from zero,
to avoid the inherent problem of multi-modal &quot;posteriors&quot; that occurs when the posterior
mode is near zero, and account for the fact that some of the new adapted quadrature points
may be negative. So, the actual return value is <code>E(theta^nn + a|Y) - a</code> for a cleverly-chosen
value <code>a</code>.
</p>
<p>Finally, <code>type='raw'</code> computes raw moments <code>E(g(theta)|Y)</code>, where <code>type='central'</code>
computes central moments, <code>E(g(theta - E(g(theta)|Y))|Y)</code>. See examples.
</p>


<h3>Value</h3>

<p>A numeric vector containing the moment(s) of ff with respect to the joint
distribution being approximated using AGHQ.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>logfteta2d &lt;- function(eta,y) {
  # eta is now (eta1,eta2)
  # y is now (y1,y2)
  n &lt;- length(y)
  n1 &lt;- ceiling(n/2)
  n2 &lt;- floor(n/2)
  y1 &lt;- y[1:n1]
  y2 &lt;- y[(n1+1):(n1+n2)]
  eta1 &lt;- eta[1]
  eta2 &lt;- eta[2]
  sum(y1) * eta1 - (length(y1) + 1) * exp(eta1) - sum(lgamma(y1+1)) + eta1 +
    sum(y2) * eta2 - (length(y2) + 1) * exp(eta2) - sum(lgamma(y2+1)) + eta2
}
set.seed(84343124)
n1 &lt;- 5
n2 &lt;- 5
n &lt;- n1+n2
y1 &lt;- rpois(n1,5)
y2 &lt;- rpois(n2,5)
objfunc2d &lt;- function(x) logfteta2d(x,c(y1,y2))
funlist2d &lt;- list(
  fn = objfunc2d,
  gr = function(x) numDeriv::grad(objfunc2d,x),
  he = function(x) numDeriv::hessian(objfunc2d,x)
)
quad &lt;- aghq(funlist2d,7,c(0,0))

</code></pre>

<hr>
<h2 id='compute_pdf_and_cdf'>Density and Cumulative Distribution Function</h2><span id='topic+compute_pdf_and_cdf'></span><span id='topic+compute_pdf_and_cdf.default'></span><span id='topic+compute_pdf_and_cdf.list'></span><span id='topic+compute_pdf_and_cdf.aghq'></span>

<h3>Description</h3>

<p>Compute the density and cumulative distribution function of the approximate posterior.
The density is approximated on a find grid using a polynomial interpolant.
The CDF can't be computed exactly (if it could, you wouldn't be using quadrature!),
so a fine grid is laid down and the CDF is approximated at each grid point
using a simpler integration rule and a polynomial interpolant. This method tends
to work well, but won't always.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_pdf_and_cdf(obj, ...)

## Default S3 method:
compute_pdf_and_cdf(
  obj,
  transformation = default_transformation(),
  finegrid = NULL,
  interpolation = "auto",
  ...
)

## S3 method for class 'list'
compute_pdf_and_cdf(obj, transformation = default_transformation(), ...)

## S3 method for class 'aghq'
compute_pdf_and_cdf(obj, transformation = obj$transformation, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute_pdf_and_cdf_+3A_obj">obj</code></td>
<td>
<p>Either the output of <code>aghq::aghq()</code>, its list of marginal distributions
(element <code>marginals</code>), or an individual <code>data.frame</code> containing one of
these marginal distributions as output by <code>aghq::marginal_posterior()</code>.</p>
</td></tr>
<tr><td><code id="compute_pdf_and_cdf_+3A_...">...</code></td>
<td>
<p>Used to pass additional arguments.</p>
</td></tr>
<tr><td><code id="compute_pdf_and_cdf_+3A_transformation">transformation</code></td>
<td>
<p>Optional. Calculate pdf/cdf for a transformation of the parameter
whose posterior was normalized using adaptive quadrature.
<code>transformation</code> is either: a) an <code>aghqtrans</code> object returned by <code>aghq::make_transformation</code>,
or b) a list that will be passed to that function internally. See <code>?aghq::make_transformation</code> for details.</p>
</td></tr>
<tr><td><code id="compute_pdf_and_cdf_+3A_finegrid">finegrid</code></td>
<td>
<p>Optional, a grid of values on which to compute the CDF. The default makes
use of the values in <code>margpost</code> but if the results are unsuitable, you may wish to
modify this manually.</p>
</td></tr>
<tr><td><code id="compute_pdf_and_cdf_+3A_interpolation">interpolation</code></td>
<td>
<p>Which method to use for interpolating the marginal posterior, <code>'polynomial'</code> (default)
or <code>'spline'</code>? If <code>k &gt; 3</code> then the polynomial may be unstable and you should use the spline, but the spline
doesn't work <em>unless</em> <code>k &gt; 3</code> so it's not the default. See <code>interpolate_marginal_posterior()</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tbl_df/tbl/data.frame with columns <code>theta</code>, <code>pdf</code> and <code>cdf</code> corresponding
to the value of the parameter and its estimated PDF and CDF at that value.
</p>


<h3>See Also</h3>

<p>Other summaries: 
<code><a href="#topic+compute_quantiles">compute_quantiles</a>()</code>,
<code><a href="#topic+interpolate_marginal_posterior">interpolate_marginal_posterior</a>()</code>,
<code><a href="#topic+marginal_posterior">marginal_posterior</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>logfteta2d &lt;- function(eta,y) {
  # eta is now (eta1,eta2)
  # y is now (y1,y2)
  n &lt;- length(y)
  n1 &lt;- ceiling(n/2)
  n2 &lt;- floor(n/2)
  y1 &lt;- y[1:n1]
  y2 &lt;- y[(n1+1):(n1+n2)]
  eta1 &lt;- eta[1]
  eta2 &lt;- eta[2]
  sum(y1) * eta1 - (length(y1) + 1) * exp(eta1) - sum(lgamma(y1+1)) + eta1 +
    sum(y2) * eta2 - (length(y2) + 1) * exp(eta2) - sum(lgamma(y2+1)) + eta2
}
set.seed(84343124)
n1 &lt;- 5
n2 &lt;- 5
n &lt;- n1+n2
y1 &lt;- rpois(n1,5)
y2 &lt;- rpois(n2,5)
objfunc2d &lt;- function(x) logfteta2d(x,c(y1,y2))
funlist2d &lt;- list(
  fn = objfunc2d,
  gr = function(x) numDeriv::grad(objfunc2d,x),
  he = function(x) numDeriv::hessian(objfunc2d,x)
)
opt_sparsetrust_2d &lt;- optimize_theta(funlist2d,c(1.5,1.5))
margpost &lt;- marginal_posterior(opt_sparsetrust_2d,3,1) # margpost for theta1
thepdfandcdf &lt;- compute_pdf_and_cdf(margpost)
with(thepdfandcdf,{
  plot(pdf~theta,type='l')
  plot(cdf~theta,type='l')
})

</code></pre>

<hr>
<h2 id='compute_quantiles'>Quantiles</h2><span id='topic+compute_quantiles'></span><span id='topic+compute_quantiles.default'></span><span id='topic+compute_quantiles.list'></span><span id='topic+compute_quantiles.aghq'></span>

<h3>Description</h3>

<p>Compute marginal quantiles using AGHQ. This function works by first approximating
the CDF using <code>aghq::compute_pdf_and_cdf</code> and then inverting the approximation numerically.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_quantiles(
  obj,
  q = c(0.025, 0.975),
  transformation = default_transformation(),
  ...
)

## Default S3 method:
compute_quantiles(
  obj,
  q = c(0.025, 0.975),
  transformation = default_transformation(),
  interpolation = "auto",
  ...
)

## S3 method for class 'list'
compute_quantiles(
  obj,
  q = c(0.025, 0.975),
  transformation = default_transformation(),
  ...
)

## S3 method for class 'aghq'
compute_quantiles(
  obj,
  q = c(0.025, 0.975),
  transformation = obj$transformation,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute_quantiles_+3A_obj">obj</code></td>
<td>
<p>Either the output of <code>aghq::aghq()</code>, its list of marginal distributions
(element <code>marginals</code>), or an individual <code>data.frame</code> containing one of
these marginal distributions as output by <code>aghq::marginal_posterior()</code>.</p>
</td></tr>
<tr><td><code id="compute_quantiles_+3A_q">q</code></td>
<td>
<p>Numeric vector of values in (0,1). The quantiles to compute.</p>
</td></tr>
<tr><td><code id="compute_quantiles_+3A_transformation">transformation</code></td>
<td>
<p>Optional. Calculate marginal quantiles for a transformation of the parameter
whose posterior was normalized using adaptive quadrature.
<code>transformation</code> is either: a) an <code>aghqtrans</code> object returned by <code>aghq::make_transformation</code>,
or b) a list that will be passed to that function internally. See <code>?aghq::make_transformation</code> for details.
Note that since <code>g</code> has to be monotone anyways, this just returns <code>sort(g(q))</code> instead of <code>q</code>.</p>
</td></tr>
<tr><td><code id="compute_quantiles_+3A_...">...</code></td>
<td>
<p>Used to pass additional arguments.</p>
</td></tr>
<tr><td><code id="compute_quantiles_+3A_interpolation">interpolation</code></td>
<td>
<p>Which method to use for interpolating the marginal posterior, <code>'polynomial'</code> (default)
or <code>'spline'</code>? If <code>k &gt; 3</code> then the polynomial may be unstable and you should use the spline, but the spline
doesn't work <em>unless</em> <code>k &gt; 3</code> so it's not the default. See <code>interpolate_marginal_posterior()</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named numeric vector containing the quantiles you asked for, for the
variable whose marginal posterior you provided.
</p>


<h3>See Also</h3>

<p>Other summaries: 
<code><a href="#topic+compute_pdf_and_cdf">compute_pdf_and_cdf</a>()</code>,
<code><a href="#topic+interpolate_marginal_posterior">interpolate_marginal_posterior</a>()</code>,
<code><a href="#topic+marginal_posterior">marginal_posterior</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>logfteta2d &lt;- function(eta,y) {
  # eta is now (eta1,eta2)
  # y is now (y1,y2)
  n &lt;- length(y)
  n1 &lt;- ceiling(n/2)
  n2 &lt;- floor(n/2)
  y1 &lt;- y[1:n1]
  y2 &lt;- y[(n1+1):(n1+n2)]
  eta1 &lt;- eta[1]
  eta2 &lt;- eta[2]
  sum(y1) * eta1 - (length(y1) + 1) * exp(eta1) - sum(lgamma(y1+1)) + eta1 +
    sum(y2) * eta2 - (length(y2) + 1) * exp(eta2) - sum(lgamma(y2+1)) + eta2
}
set.seed(84343124)
n1 &lt;- 5
n2 &lt;- 5
n &lt;- n1+n2
y1 &lt;- rpois(n1,5)
y2 &lt;- rpois(n2,5)
objfunc2d &lt;- function(x) logfteta2d(x,c(y1,y2))
funlist2d &lt;- list(
  fn = objfunc2d,
  gr = function(x) numDeriv::grad(objfunc2d,x),
  he = function(x) numDeriv::hessian(objfunc2d,x)
)
opt_sparsetrust_2d &lt;- optimize_theta(funlist2d,c(1.5,1.5))
margpost &lt;- marginal_posterior(opt_sparsetrust_2d,3,1) # margpost for theta1
etaquant &lt;- compute_quantiles(margpost)
etaquant
# lambda = exp(eta)
exp(etaquant)
# Compare to truth
qgamma(.025,1+sum(y1),1+n1)
qgamma(.975,1+sum(y1),1+n1)



</code></pre>

<hr>
<h2 id='correct_marginals'>Correct the posterior marginals of a fitted aghq object</h2><span id='topic+correct_marginals'></span>

<h3>Description</h3>

<p>The default method of computation for aghq objects computes approximate marginals using an outdated algorithm
with no known theoretical properties. The updated algorithm computes pointwise approximate marginals that
satisfy the same rate of convergence as the original approximate marginal likelihood. This function takes
a fitted aghq object and recomputes its marginals using the updated algorithm
</p>


<h3>Usage</h3>

<pre><code class='language-R'>correct_marginals(quad, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="correct_marginals_+3A_quad">quad</code></td>
<td>
<p>An object of class <code>aghq</code> returned by <code>aghq::aghq()</code>.</p>
</td></tr>
<tr><td><code id="correct_marginals_+3A_...">...</code></td>
<td>
<p>Not used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>aghq</code> equal to the provided object, but with its
<code>marginals</code> component replaced with one calculated using <code>method='correct'</code>.
See <code>marginal_posterior</code>.
</p>

<hr>
<h2 id='default_control'>Default control arguments for <code>aghq::aghq()</code>.</h2><span id='topic+default_control'></span>

<h3>Description</h3>

<p>Run <code>default_control()</code> to print the list of valid control parameters
and their defaults, and run with named arguments to change the defaults.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>default_control(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="default_control_+3A_...">...</code></td>
<td>
<p>You can provide a named value for any control parameter and its
value will be set accordingly. See <code>?aghq</code> and examples here.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Valid options are:
</p>

<ul>
<li><p><code>method</code>: optimization method to use:
</p>

<ul>
<li><p>'BFGS' (default): <code>optim(...,method = "BFGS")</code>
</p>
</li>
<li><p>'sparse_trust': <code>trustOptim::trust.optim</code>
</p>
</li>
<li><p>'SR1': <code>trustOptim::trust.optim</code> with <code>method = 'SR1'</code>
</p>
</li>
<li><p>'sparse': <code>trust::trust</code>
</p>
</li></ul>

<p>Default is 'sparse_trust'.

</p>
</li>
<li> <p><code>negate</code>: default <code>FALSE</code>. Multiply the functions in <code>ff</code> by <code>-1</code>?
The reason for having this option is for full compatibility with <code>TMB</code>:
while of course <code>TMB</code> allows you to code up your log-posterior any way you like,
all of its excellent features including its automatic Laplace approximation and MCMC
sampling with <code>tmbstan</code> assume you have coded your template to return the
<strong>negated</strong> log-posterior. However, by default, <code>aghq</code> assumes you have
provided the log-posterior <strong>without negation</strong>. Set <code>negate = TRUE</code> if you
have provided a template which computes the <strong>negated</strong> log-posterior and its
derivatives.
</p>
</li>
<li> <p><code>ndConstruction</code>: construct a multivariate quadrature rule using a <code>"product"</code>
rule or a <code>"sparse"</code> grid? Default <code>"product"</code>. See <code>?mvQuad::createNIGrid()</code>.
</p>
</li>
<li> <p><code>interpolation</code>: how to interpolate the marginal posteriors. The <code>'auto'</code> option
(default) chooses for you and should always work well. The <code>'polynomial'</code>
option uses <code>polynom::poly.calc()</code> to construct a global polynomial interpolant
and has been observed to be unstable as the number of quadrature points gets larger, which
is obviously a bad thing. Try <code>'spline'</code> instead, which uses a cubic B-Spline
interpolant from <code>splines::interpSpline()</code>.
</p>
</li>
<li><p>numhessian: logical, default <code>FALSE</code>. Replace the <code>ff$he</code> with a numerically-differentiated
version, by calling <code>numDeriv::jacobian</code> on <code>ff$gr</code>. Used mainly for <code>TMB</code> with the automatic
Laplace approximation, which does not have an automatic Hessian.
</p>
</li>
<li><p>onlynormconst: logical, default <code>FALSE</code>. Skip everything after the calculation of the log integral,
and just return the numeric value of the log integral. Saves computation time, and most useful in cases
where <code>aghq</code> is being used as a step in a more complicated procedure.
</p>
</li>
<li><p>method_summaries: default <code>'reuse'</code>, method to use to compute moments and marginals. Choosing
<code>'correct'</code> corresponds to the approximations suggested in the <em>Stochastic Convergence...</em> paper,
which attain the same rate of convergence as the approximation to the marginal likelihood. See <code>?compute_moment</code>.
</p>
</li></ul>



<h3>Value</h3>

<p>A list of argument values.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
default_control()
default_control(method = "trust")
default_control(negate = TRUE)

</code></pre>

<hr>
<h2 id='default_control_marglaplace'>Default control arguments for <code>aghq::marginal_laplace()</code>.</h2><span id='topic+default_control_marglaplace'></span>

<h3>Description</h3>

<p>Run <code>default_control_marglaplace()</code> to print the list of valid control parameters
and their defaults, and run with named arguments to change the defaults.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>default_control_marglaplace(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="default_control_marglaplace_+3A_...">...</code></td>
<td>
<p>You can provide a named value for any control parameter and its
value will be set accordingly. See <code>?marginal_laplace</code> and examples here.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Valid options are:
</p>

<ul>
<li><p><code>method</code>: optimization method to use for the <code>theta</code> optimization:
</p>

<ul>
<li><p>'BFGS' (default): <code>optim(...,method = "BFGS")</code>
</p>
</li>
<li><p>'sparse_trust': <code>trustOptim::trust.optim</code>
</p>
</li>
<li><p>'SR1': <code>trustOptim::trust.optim</code> with <code>method = 'SR1'</code>
</p>
</li>
<li><p>'sparse': <code>trust::trust</code>
</p>
</li></ul>


</li>
<li><p><code>inner_method</code>: optimization method to use for the <code>W</code> optimization; same
options as for <code>method</code>. Default <code>inner_method</code> is 'sparse_trust' and default <code>method</code> is 'BFGS'.

</p>
</li>
<li> <p><code>negate</code>: default <code>FALSE</code>. Multiply the functions in <code>ff</code> by <code>-1</code>?
The reason for having this option is for full compatibility with <code>TMB</code>:
while of course <code>TMB</code> allows you to code up your log-posterior any way you like,
all of its excellent features including its automatic Laplace approximation and MCMC
sampling with <code>tmbstan</code> assume you have coded your template to return the
<strong>negated</strong> log-posterior. However, by default, <code>aghq</code> assumes you have
provided the log-posterior <strong>without negation</strong>. Set <code>negate = TRUE</code> if you
have provided a template which computes the <strong>negated</strong> log-posterior and its
derivatives. <strong>Note</strong> that I don't expect there to be any reason to need this
argument for <code>marginal_laplace</code>; if you are doing a marginal Laplace approximation
using the automatic Laplace approximation provided by <code>TMB</code>, you should
check out <code>aghq::marginal_laplace_tmb()</code>.
</p>
</li>
<li> <p><code>interpolation</code>: how to interpolate the marginal posteriors. The <code>'auto'</code> option
(default) chooses for you and should always work well. The <code>'polynomial'</code>
option uses <code>polynom::poly.calc()</code> to construct a global polynomial interpolant
and has been observed to be unstable as the number of quadrature points gets larger, which
is obviously a bad thing. Try <code>'spline'</code> instead, which uses a cubic B-Spline
interpolant from <code>splines::interpSpline()</code>.
</p>
</li>
<li><p>numhessian: logical, default <code>FALSE</code>. Replace the <code>ff$he</code> with a numerically-differentiated
version, by calling <code>numDeriv::jacobian</code> on <code>ff$gr</code>. Used mainly for <code>TMB</code> with the automatic
Laplace approximation, which does not have an automatic Hessian.
</p>
</li>
<li><p>onlynormconst: logical, default <code>FALSE</code>. Skip everything after the calculation of the log integral,
and just return the numeric value of the log integral. Saves computation time, and most useful in cases
where <code>aghq</code> is being used as a step in a more complicated procedure.
</p>
</li>
<li><p>method_summaries: default <code>'reuse'</code>, method to use to compute moments and marginals. Choosing
<code>'correct'</code> corresponds to the approximations suggested in the <em>Stochastic Convergence...</em> paper,
which attain the same rate of convergence as the approximation to the marginal likelihood. See <code>?compute_moment</code>.
</p>
</li></ul>



<h3>Value</h3>

<p>A list of argument values.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
default_control_marglaplace()
default_control_marglaplace(method = "trust")
default_control_marglaplace(method = "trust",inner_method = "trust")
default_control_marglaplace(negate = TRUE)

</code></pre>

<hr>
<h2 id='default_control_tmb'>Default control arguments for <code>aghq::marginal_laplace_tmb()</code>.</h2><span id='topic+default_control_tmb'></span>

<h3>Description</h3>

<p>Run <code>default_control_marglaplace()</code> to print the list of valid control parameters
and their defaults, and run with named arguments to change the defaults.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>default_control_tmb(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="default_control_tmb_+3A_...">...</code></td>
<td>
<p>You can provide a named value for any control parameter and its
value will be set accordingly. See <code>?marginal_laplace</code> and examples here.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Valid options are:
</p>

<ul>
<li><p><code>method</code>: optimization method to use for the <code>theta</code> optimization:
</p>

<ul>
<li><p>'BFGS' (default): <code>optim(...,method = "BFGS")</code>
</p>
</li>
<li><p>'sparse_trust': <code>trustOptim::trust.optim</code>
</p>
</li>
<li><p>'SR1': <code>trustOptim::trust.optim</code> with <code>method = 'SR1'</code>
</p>
</li>
<li><p>'sparse': <code>trust::trust</code>
</p>
</li></ul>


</li>
<li> <p><code>negate</code>: default <code>TRUE</code>. Assumes that your <code>TMB</code> function
template computes the <strong>negated</strong> log-posterior, which it must if you're using <code>TMB</code>'s automatic
Laplace approximation, which you must be if you're using this function!.
</p>
</li>
<li> <p><code>interpolation</code>: how to interpolate the marginal posteriors. The <code>'auto'</code> option
(default) chooses for you and should always work well. The <code>'polynomial'</code>
option uses <code>polynom::poly.calc()</code> to construct a global polynomial interpolant
and has been observed to be unstable as the number of quadrature points gets larger, which
is obviously a bad thing. Try <code>'spline'</code> instead, which uses a cubic B-Spline
interpolant from <code>splines::interpSpline()</code>.
</p>
</li>
<li><p>numhessian: logical, default <code>TRUE</code>. Replace the <code>ff$he</code> with a numerically-differentiated
version, by calling <code>numDeriv::jacobian</code> on <code>ff$gr</code>. Used mainly for <code>TMB</code> with the automatic
Laplace approximation, which does not have an automatic Hessian.
</p>
</li>
<li><p>onlynormconst: logical, default <code>FALSE</code>. Skip everything after the calculation of the log integral,
and just return the numeric value of the log integral. Saves computation time, and most useful in cases
where <code>aghq</code> is being used as a step in a more complicated procedure.
</p>
</li>
<li><p>method_summaries: default <code>'reuse'</code>, method to use to compute moments and marginals. Choosing
<code>'correct'</code> corresponds to the approximations suggested in the <em>Stochastic Convergence...</em> paper,
which attain the same rate of convergence as the approximation to the marginal likelihood. See <code>?compute_moment</code>.
</p>
</li></ul>



<h3>Value</h3>

<p>A list of argument values.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
default_control_tmb()
default_control_tmb(method = "trust")

</code></pre>

<hr>
<h2 id='default_transformation'>Default transformation</h2><span id='topic+default_transformation'></span>

<h3>Description</h3>

<p>Default (identity) transformation object. Default argument in package functions
which accept transformations, and useful for user inspection.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>default_transformation()
</code></pre>


<h3>See Also</h3>

<p>Other transformations: 
<code><a href="#topic+make_transformation">make_transformation</a>()</code>,
<code><a href="#topic+validate_transformation">validate_transformation</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
default_transformation()

</code></pre>

<hr>
<h2 id='gcdata'>Globular Clusters data for Milky Way mass estimation</h2><span id='topic+gcdata'></span>

<h3>Description</h3>

<p>Measurements on star clusters from Eadie and Harris (2016), for use
within the Milky Way mass estimation example. Data are documented
extensively by that source.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gcdata
</code></pre>


<h3>Format</h3>

<p>An object of class <code>tbl_df</code> (inherits from <code>tbl</code>, <code>data.frame</code>) with 70 rows and 25 columns.
</p>


<h3>Source</h3>

<p>Eadie GM, Harris WE (2016). “Bayesian mass estimates of the Milky Way: the dark and light sides of parameter assumptions.” The Astrophysical Journal, 829(108).
</p>

<hr>
<h2 id='gcdatalist'>Transformed Globular Clusters data</h2><span id='topic+gcdatalist'></span>

<h3>Description</h3>

<p>GC data prepared for input into the TMB template, for purposes of example.
There are a lot of example-specific data preprocessing steps that are not
related to the AGHQ method, so for brevity these are done beforehand.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gcdatalist
</code></pre>


<h3>Format</h3>

<p>An object of class <code>list</code> of length 6.
</p>


<h3>Source</h3>

<p>Eadie GM, Harris WE (2016). “Bayesian mass estimates of the Milky Way: the dark and light sides of parameter assumptions.” The Astrophysical Journal, 829(108).
</p>

<hr>
<h2 id='get_hessian'>Obtain the Hessian from an aghq object</h2><span id='topic+get_hessian'></span>

<h3>Description</h3>

<p>Quick helper method to retrieve the Hessian from an aghq object. Just
calls <code>aghq::get_opt_results</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_hessian(obj, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_hessian_+3A_obj">obj</code></td>
<td>
<p>Object of class <code>aghq</code> returned by <code>aghq::aghq</code>.</p>
</td></tr>
<tr><td><code id="get_hessian_+3A_...">...</code></td>
<td>
<p>Not used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric matrix of dimension <code>dim(theta) x dim(theta)</code> containing the negative Hessian of the log-posterior evaluated at the mode.
</p>


<h3>See Also</h3>

<p>Other quadrature: 
<code><a href="#topic+aghq">aghq</a>()</code>,
<code><a href="#topic+get_log_normconst">get_log_normconst</a>()</code>,
<code><a href="#topic+get_mode">get_mode</a>()</code>,
<code><a href="#topic+get_nodesandweights">get_nodesandweights</a>()</code>,
<code><a href="#topic+get_numquadpoints">get_numquadpoints</a>()</code>,
<code><a href="#topic+get_opt_results">get_opt_results</a>()</code>,
<code><a href="#topic+get_param_dim">get_param_dim</a>()</code>,
<code><a href="#topic+laplace_approximation">laplace_approximation</a>()</code>,
<code><a href="#topic+marginal_laplace_tmb">marginal_laplace_tmb</a>()</code>,
<code><a href="#topic+marginal_laplace">marginal_laplace</a>()</code>,
<code><a href="#topic+nested_quadrature">nested_quadrature</a>()</code>,
<code><a href="#topic+normalize_logpost">normalize_logpost</a>()</code>,
<code><a href="#topic+optimize_theta">optimize_theta</a>()</code>,
<code><a href="#topic+plot.aghq">plot.aghq</a>()</code>,
<code><a href="#topic+print.aghqsummary">print.aghqsummary</a>()</code>,
<code><a href="#topic+print.aghq">print.aghq</a>()</code>,
<code><a href="#topic+print.laplacesummary">print.laplacesummary</a>()</code>,
<code><a href="#topic+print.laplace">print.laplace</a>()</code>,
<code><a href="#topic+print.marginallaplacesummary">print.marginallaplacesummary</a>()</code>,
<code><a href="#topic+summary.aghq">summary.aghq</a>()</code>,
<code><a href="#topic+summary.laplace">summary.laplace</a>()</code>,
<code><a href="#topic+summary.marginallaplace">summary.marginallaplace</a>()</code>
</p>

<hr>
<h2 id='get_log_normconst'>Obtain the log-normalizing constant from a fitted quadrature object</h2><span id='topic+get_log_normconst'></span><span id='topic+get_log_normconst.default'></span><span id='topic+get_log_normconst.numeric'></span><span id='topic+get_log_normconst.aghq'></span><span id='topic+get_log_normconst.laplace'></span><span id='topic+get_log_normconst.marginallaplace'></span>

<h3>Description</h3>

<p>Quick helper S3 method to retrieve the log normalizing constant from an object
created using the aghq package. Methods for a list (returned by <code>aghq::normalize_posterior</code>)
and for objects of class <code>aghq</code>, <code>laplace</code>, and <code>marginallaplace</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_log_normconst(obj, ...)

## Default S3 method:
get_log_normconst(obj, ...)

## S3 method for class 'numeric'
get_log_normconst(obj, ...)

## S3 method for class 'aghq'
get_log_normconst(obj, ...)

## S3 method for class 'laplace'
get_log_normconst(obj, ...)

## S3 method for class 'marginallaplace'
get_log_normconst(obj, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_log_normconst_+3A_obj">obj</code></td>
<td>
<p>A list returned by <code>aghq::normalize_posterior</code> or an object of class <code>aghq</code>, <code>laplace</code>, or <code>marginallaplace</code>.</p>
</td></tr>
<tr><td><code id="get_log_normconst_+3A_...">...</code></td>
<td>
<p>Not used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A number representing the natural logarithm of the approximated normalizing constant.
</p>


<h3>See Also</h3>

<p>Other quadrature: 
<code><a href="#topic+aghq">aghq</a>()</code>,
<code><a href="#topic+get_hessian">get_hessian</a>()</code>,
<code><a href="#topic+get_mode">get_mode</a>()</code>,
<code><a href="#topic+get_nodesandweights">get_nodesandweights</a>()</code>,
<code><a href="#topic+get_numquadpoints">get_numquadpoints</a>()</code>,
<code><a href="#topic+get_opt_results">get_opt_results</a>()</code>,
<code><a href="#topic+get_param_dim">get_param_dim</a>()</code>,
<code><a href="#topic+laplace_approximation">laplace_approximation</a>()</code>,
<code><a href="#topic+marginal_laplace_tmb">marginal_laplace_tmb</a>()</code>,
<code><a href="#topic+marginal_laplace">marginal_laplace</a>()</code>,
<code><a href="#topic+nested_quadrature">nested_quadrature</a>()</code>,
<code><a href="#topic+normalize_logpost">normalize_logpost</a>()</code>,
<code><a href="#topic+optimize_theta">optimize_theta</a>()</code>,
<code><a href="#topic+plot.aghq">plot.aghq</a>()</code>,
<code><a href="#topic+print.aghqsummary">print.aghqsummary</a>()</code>,
<code><a href="#topic+print.aghq">print.aghq</a>()</code>,
<code><a href="#topic+print.laplacesummary">print.laplacesummary</a>()</code>,
<code><a href="#topic+print.laplace">print.laplace</a>()</code>,
<code><a href="#topic+print.marginallaplacesummary">print.marginallaplacesummary</a>()</code>,
<code><a href="#topic+summary.aghq">summary.aghq</a>()</code>,
<code><a href="#topic+summary.laplace">summary.laplace</a>()</code>,
<code><a href="#topic+summary.marginallaplace">summary.marginallaplace</a>()</code>
</p>

<hr>
<h2 id='get_mode'>Obtain the mode from an aghq object</h2><span id='topic+get_mode'></span>

<h3>Description</h3>

<p>Quick helper method to retrieve the mode from an aghq object. Just
calls <code>aghq::get_opt_results</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_mode(obj, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_mode_+3A_obj">obj</code></td>
<td>
<p>Object of class <code>aghq</code> returned by <code>aghq::aghq</code>.</p>
</td></tr>
<tr><td><code id="get_mode_+3A_...">...</code></td>
<td>
<p>Not used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector of length <code>dim(theta)</code> containing the posterior mode.
</p>


<h3>See Also</h3>

<p>Other quadrature: 
<code><a href="#topic+aghq">aghq</a>()</code>,
<code><a href="#topic+get_hessian">get_hessian</a>()</code>,
<code><a href="#topic+get_log_normconst">get_log_normconst</a>()</code>,
<code><a href="#topic+get_nodesandweights">get_nodesandweights</a>()</code>,
<code><a href="#topic+get_numquadpoints">get_numquadpoints</a>()</code>,
<code><a href="#topic+get_opt_results">get_opt_results</a>()</code>,
<code><a href="#topic+get_param_dim">get_param_dim</a>()</code>,
<code><a href="#topic+laplace_approximation">laplace_approximation</a>()</code>,
<code><a href="#topic+marginal_laplace_tmb">marginal_laplace_tmb</a>()</code>,
<code><a href="#topic+marginal_laplace">marginal_laplace</a>()</code>,
<code><a href="#topic+nested_quadrature">nested_quadrature</a>()</code>,
<code><a href="#topic+normalize_logpost">normalize_logpost</a>()</code>,
<code><a href="#topic+optimize_theta">optimize_theta</a>()</code>,
<code><a href="#topic+plot.aghq">plot.aghq</a>()</code>,
<code><a href="#topic+print.aghqsummary">print.aghqsummary</a>()</code>,
<code><a href="#topic+print.aghq">print.aghq</a>()</code>,
<code><a href="#topic+print.laplacesummary">print.laplacesummary</a>()</code>,
<code><a href="#topic+print.laplace">print.laplace</a>()</code>,
<code><a href="#topic+print.marginallaplacesummary">print.marginallaplacesummary</a>()</code>,
<code><a href="#topic+summary.aghq">summary.aghq</a>()</code>,
<code><a href="#topic+summary.laplace">summary.laplace</a>()</code>,
<code><a href="#topic+summary.marginallaplace">summary.marginallaplace</a>()</code>
</p>

<hr>
<h2 id='get_nodesandweights'>Obtain the nodes and weights table from a fitted quadrature object</h2><span id='topic+get_nodesandweights'></span><span id='topic+get_nodesandweights.default'></span><span id='topic+get_nodesandweights.list'></span><span id='topic+get_nodesandweights.data.frame'></span><span id='topic+get_nodesandweights.aghq'></span><span id='topic+get_nodesandweights.laplace'></span><span id='topic+get_nodesandweights.marginallaplace'></span>

<h3>Description</h3>

<p>Quick helper S3 method to retrieve the quadrature nodes and weights from an object
created using the aghq package. Methods for a list (returned by <code>aghq::normalize_posterior</code>)
and for objects of class <code>aghq</code>, <code>laplace</code>, and <code>marginallaplace</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_nodesandweights(obj, ...)

## Default S3 method:
get_nodesandweights(obj, ...)

## S3 method for class 'list'
get_nodesandweights(obj, ...)

## S3 method for class 'data.frame'
get_nodesandweights(obj, ...)

## S3 method for class 'aghq'
get_nodesandweights(obj, ...)

## S3 method for class 'laplace'
get_nodesandweights(obj, ...)

## S3 method for class 'marginallaplace'
get_nodesandweights(obj, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_nodesandweights_+3A_obj">obj</code></td>
<td>
<p>A list returned by <code>aghq::normalize_posterior</code> or an object of class <code>aghq</code>, <code>laplace</code>, or <code>marginallaplace</code>.</p>
</td></tr>
<tr><td><code id="get_nodesandweights_+3A_...">...</code></td>
<td>
<p>Not used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A number representing the natural logarithm of the approximated normalizing constant.
</p>


<h3>See Also</h3>

<p>Other quadrature: 
<code><a href="#topic+aghq">aghq</a>()</code>,
<code><a href="#topic+get_hessian">get_hessian</a>()</code>,
<code><a href="#topic+get_log_normconst">get_log_normconst</a>()</code>,
<code><a href="#topic+get_mode">get_mode</a>()</code>,
<code><a href="#topic+get_numquadpoints">get_numquadpoints</a>()</code>,
<code><a href="#topic+get_opt_results">get_opt_results</a>()</code>,
<code><a href="#topic+get_param_dim">get_param_dim</a>()</code>,
<code><a href="#topic+laplace_approximation">laplace_approximation</a>()</code>,
<code><a href="#topic+marginal_laplace_tmb">marginal_laplace_tmb</a>()</code>,
<code><a href="#topic+marginal_laplace">marginal_laplace</a>()</code>,
<code><a href="#topic+nested_quadrature">nested_quadrature</a>()</code>,
<code><a href="#topic+normalize_logpost">normalize_logpost</a>()</code>,
<code><a href="#topic+optimize_theta">optimize_theta</a>()</code>,
<code><a href="#topic+plot.aghq">plot.aghq</a>()</code>,
<code><a href="#topic+print.aghqsummary">print.aghqsummary</a>()</code>,
<code><a href="#topic+print.aghq">print.aghq</a>()</code>,
<code><a href="#topic+print.laplacesummary">print.laplacesummary</a>()</code>,
<code><a href="#topic+print.laplace">print.laplace</a>()</code>,
<code><a href="#topic+print.marginallaplacesummary">print.marginallaplacesummary</a>()</code>,
<code><a href="#topic+summary.aghq">summary.aghq</a>()</code>,
<code><a href="#topic+summary.laplace">summary.laplace</a>()</code>,
<code><a href="#topic+summary.marginallaplace">summary.marginallaplace</a>()</code>
</p>

<hr>
<h2 id='get_numquadpoints'>Obtain the number of quadrature nodes used from an aghq object</h2><span id='topic+get_numquadpoints'></span>

<h3>Description</h3>

<p>Quick helper S3 method to retrieve the number of quadrature points used when creating an aghq object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_numquadpoints(obj, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_numquadpoints_+3A_obj">obj</code></td>
<td>
<p>Object of class <code>aghq</code> returned by <code>aghq::aghq</code>.</p>
</td></tr>
<tr><td><code id="get_numquadpoints_+3A_...">...</code></td>
<td>
<p>Not used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector of length 1 containing <code>k</code>, the number of quadrature points used.
</p>


<h3>See Also</h3>

<p>Other quadrature: 
<code><a href="#topic+aghq">aghq</a>()</code>,
<code><a href="#topic+get_hessian">get_hessian</a>()</code>,
<code><a href="#topic+get_log_normconst">get_log_normconst</a>()</code>,
<code><a href="#topic+get_mode">get_mode</a>()</code>,
<code><a href="#topic+get_nodesandweights">get_nodesandweights</a>()</code>,
<code><a href="#topic+get_opt_results">get_opt_results</a>()</code>,
<code><a href="#topic+get_param_dim">get_param_dim</a>()</code>,
<code><a href="#topic+laplace_approximation">laplace_approximation</a>()</code>,
<code><a href="#topic+marginal_laplace_tmb">marginal_laplace_tmb</a>()</code>,
<code><a href="#topic+marginal_laplace">marginal_laplace</a>()</code>,
<code><a href="#topic+nested_quadrature">nested_quadrature</a>()</code>,
<code><a href="#topic+normalize_logpost">normalize_logpost</a>()</code>,
<code><a href="#topic+optimize_theta">optimize_theta</a>()</code>,
<code><a href="#topic+plot.aghq">plot.aghq</a>()</code>,
<code><a href="#topic+print.aghqsummary">print.aghqsummary</a>()</code>,
<code><a href="#topic+print.aghq">print.aghq</a>()</code>,
<code><a href="#topic+print.laplacesummary">print.laplacesummary</a>()</code>,
<code><a href="#topic+print.laplace">print.laplace</a>()</code>,
<code><a href="#topic+print.marginallaplacesummary">print.marginallaplacesummary</a>()</code>,
<code><a href="#topic+summary.aghq">summary.aghq</a>()</code>,
<code><a href="#topic+summary.laplace">summary.laplace</a>()</code>,
<code><a href="#topic+summary.marginallaplace">summary.marginallaplace</a>()</code>
</p>

<hr>
<h2 id='get_opt_results'>Obtain the optimization results from an aghq object</h2><span id='topic+get_opt_results'></span><span id='topic+get_opt_results.aghq'></span><span id='topic+get_opt_results.marginallaplace'></span>

<h3>Description</h3>

<p>Quick helper S3 method to retrieve the mode and Hessian from an aghq object. The
full results of calling <code>aghq::optimize_theta</code> are stored in <code>obj$optresults</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_opt_results(obj, ...)

## S3 method for class 'aghq'
get_opt_results(obj, ...)

## S3 method for class 'marginallaplace'
get_opt_results(obj, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_opt_results_+3A_obj">obj</code></td>
<td>
<p>Object of class <code>aghq</code> returned by <code>aghq::aghq</code>.</p>
</td></tr>
<tr><td><code id="get_opt_results_+3A_...">...</code></td>
<td>
<p>Not used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named list with elements:
</p>

<ul>
<li><p><code>mode</code>: a numeric vector of length <code>dim(theta)</code> containing the posterior mode.
</p>
</li>
<li><p><code>hessian</code>: a numeric matrix of dimension <code>dim(theta) x dim(theta)</code> containing the negative Hessian of the log-posterior evaluated at the mode.
</p>
</li></ul>

<p>For objects of class <code>marginallaplace</code>, a third list item <code>modesandhessians</code> is
a <code>data.frame</code> containing
the mode and Hessian of the <code>W</code> parameters evaluated at each adapted quadrature point.
</p>


<h3>See Also</h3>

<p>Other quadrature: 
<code><a href="#topic+aghq">aghq</a>()</code>,
<code><a href="#topic+get_hessian">get_hessian</a>()</code>,
<code><a href="#topic+get_log_normconst">get_log_normconst</a>()</code>,
<code><a href="#topic+get_mode">get_mode</a>()</code>,
<code><a href="#topic+get_nodesandweights">get_nodesandweights</a>()</code>,
<code><a href="#topic+get_numquadpoints">get_numquadpoints</a>()</code>,
<code><a href="#topic+get_param_dim">get_param_dim</a>()</code>,
<code><a href="#topic+laplace_approximation">laplace_approximation</a>()</code>,
<code><a href="#topic+marginal_laplace_tmb">marginal_laplace_tmb</a>()</code>,
<code><a href="#topic+marginal_laplace">marginal_laplace</a>()</code>,
<code><a href="#topic+nested_quadrature">nested_quadrature</a>()</code>,
<code><a href="#topic+normalize_logpost">normalize_logpost</a>()</code>,
<code><a href="#topic+optimize_theta">optimize_theta</a>()</code>,
<code><a href="#topic+plot.aghq">plot.aghq</a>()</code>,
<code><a href="#topic+print.aghqsummary">print.aghqsummary</a>()</code>,
<code><a href="#topic+print.aghq">print.aghq</a>()</code>,
<code><a href="#topic+print.laplacesummary">print.laplacesummary</a>()</code>,
<code><a href="#topic+print.laplace">print.laplace</a>()</code>,
<code><a href="#topic+print.marginallaplacesummary">print.marginallaplacesummary</a>()</code>,
<code><a href="#topic+summary.aghq">summary.aghq</a>()</code>,
<code><a href="#topic+summary.laplace">summary.laplace</a>()</code>,
<code><a href="#topic+summary.marginallaplace">summary.marginallaplace</a>()</code>
</p>

<hr>
<h2 id='get_param_dim'>Obtain the parameter dimension from an aghq object</h2><span id='topic+get_param_dim'></span><span id='topic+get_param_dim.aghq'></span>

<h3>Description</h3>

<p>Quick helper S3 method to retrieve the parameter dimension from an aghq object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_param_dim(obj, ...)

## S3 method for class 'aghq'
get_param_dim(obj, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_param_dim_+3A_obj">obj</code></td>
<td>
<p>Object of class <code>aghq</code> returned by <code>aghq::aghq</code>.</p>
</td></tr>
<tr><td><code id="get_param_dim_+3A_...">...</code></td>
<td>
<p>Not used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector of length 1 containing <code>p</code>, the parameter dimension.
</p>


<h3>See Also</h3>

<p>Other quadrature: 
<code><a href="#topic+aghq">aghq</a>()</code>,
<code><a href="#topic+get_hessian">get_hessian</a>()</code>,
<code><a href="#topic+get_log_normconst">get_log_normconst</a>()</code>,
<code><a href="#topic+get_mode">get_mode</a>()</code>,
<code><a href="#topic+get_nodesandweights">get_nodesandweights</a>()</code>,
<code><a href="#topic+get_numquadpoints">get_numquadpoints</a>()</code>,
<code><a href="#topic+get_opt_results">get_opt_results</a>()</code>,
<code><a href="#topic+laplace_approximation">laplace_approximation</a>()</code>,
<code><a href="#topic+marginal_laplace_tmb">marginal_laplace_tmb</a>()</code>,
<code><a href="#topic+marginal_laplace">marginal_laplace</a>()</code>,
<code><a href="#topic+nested_quadrature">nested_quadrature</a>()</code>,
<code><a href="#topic+normalize_logpost">normalize_logpost</a>()</code>,
<code><a href="#topic+optimize_theta">optimize_theta</a>()</code>,
<code><a href="#topic+plot.aghq">plot.aghq</a>()</code>,
<code><a href="#topic+print.aghqsummary">print.aghqsummary</a>()</code>,
<code><a href="#topic+print.aghq">print.aghq</a>()</code>,
<code><a href="#topic+print.laplacesummary">print.laplacesummary</a>()</code>,
<code><a href="#topic+print.laplace">print.laplace</a>()</code>,
<code><a href="#topic+print.marginallaplacesummary">print.marginallaplacesummary</a>()</code>,
<code><a href="#topic+summary.aghq">summary.aghq</a>()</code>,
<code><a href="#topic+summary.laplace">summary.laplace</a>()</code>,
<code><a href="#topic+summary.marginallaplace">summary.marginallaplace</a>()</code>
</p>

<hr>
<h2 id='interpolate_marginal_posterior'>Interpolate the Marginal Posterior</h2><span id='topic+interpolate_marginal_posterior'></span>

<h3>Description</h3>

<p>Build a Lagrange polynomial interpolant of the marginal posterior, for plotting
and for computing quantiles.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>interpolate_marginal_posterior(
  margpost,
  method = c("auto", "polynomial", "spline")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="interpolate_marginal_posterior_+3A_margpost">margpost</code></td>
<td>
<p>The output of <code>aghq::marginal_posterior</code>. See the documentation for that function.</p>
</td></tr>
<tr><td><code id="interpolate_marginal_posterior_+3A_method">method</code></td>
<td>
<p>The method to use. Default is a <code>k</code> point polynomial interpolant using <code>polynom::poly.calc()</code>.
This has been observed to result in unstable behaviour for larger numbers of quadrature points <code>k</code>,
which is of course undesirable. If <code>k &gt; 3</code>, you can set <code>method = 'spline'</code> to use <code>splines::interpSpline()</code> instead,
which uses cubic B-Splines. These should always be better than a straight polynomial, except don't work
when <code>k &lt; 4</code> which is why they aren't the default. If you try and set <code>method = 'spline'</code> with
<code>k &lt; 4</code> it will be changed back to polynomial, with a warning.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A function of <code>theta</code> which computes the log interpolated normalized marginal posterior.
</p>


<h3>See Also</h3>

<p>Other summaries: 
<code><a href="#topic+compute_pdf_and_cdf">compute_pdf_and_cdf</a>()</code>,
<code><a href="#topic+compute_quantiles">compute_quantiles</a>()</code>,
<code><a href="#topic+marginal_posterior">marginal_posterior</a>()</code>
</p>

<hr>
<h2 id='laplace_approximation'>Laplace Approximation</h2><span id='topic+laplace_approximation'></span>

<h3>Description</h3>

<p>Wrapper function to implement a Laplace approximation to the posterior. A
Laplace approximation is AGHQ with <code>k = 1</code> quadrature points.
However, the returned
object is of a different class <code>laplace</code>, and a different summary
method is given for it. It is especially useful for high-dimensional problems where
the curse of dimensionality renders the use of <code>k &gt; 1</code> quadrature points
infeasible. The summary method reflects the fact that the user may
be using this for a high-dimensional problem, and no plot method is given,
because there isn't anything
interesting to plot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>laplace_approximation(
  ff,
  startingvalue,
  optresults = NULL,
  control = default_control(),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="laplace_approximation_+3A_ff">ff</code></td>
<td>
<p>A list with three elements:
</p>

<ul>
<li><p><code>fn</code>: function taking argument <code>theta</code> and returning a numeric
value representing the log-posterior at <code>theta</code>
</p>
</li>
<li><p><code>gr</code>: function taking argument <code>theta</code> and returning a numeric
vector representing the gradient of the log-posterior at <code>theta</code>
</p>
</li>
<li><p><code>he</code>: function taking argument <code>theta</code> and returning a numeric
matrix representing the hessian of the log-posterior at <code>theta</code>
</p>
</li></ul>

<p>The user may wish to use <code>numDeriv::grad</code> and/or <code>numDeriv::hessian</code> to
obtain these. Alternatively, the user may consider the <code>TMB</code> package. This
list is deliberately formatted to match the output of <code>TMB::MakeADFun</code>.</p>
</td></tr>
<tr><td><code id="laplace_approximation_+3A_startingvalue">startingvalue</code></td>
<td>
<p>Value to start the optimization. <code>ff$fn(startingvalue)</code>,
<code>ff$gr(startingvalue)</code>, and <code>ff$he(startingvalue)</code> must all return
appropriate values without error.</p>
</td></tr>
<tr><td><code id="laplace_approximation_+3A_optresults">optresults</code></td>
<td>
<p>Optional. A list of the results of the optimization of the log
posterior, formatted according to the output of <code>aghq::optimize_theta</code>. The
<code>aghq::aghq</code> function handles the optimization for you; passing this list
overrides this, and is useful for when you know your optimization is too difficult to be
handled by general-purpose software. See the software paper for several examples of this.
If you're unsure whether this option is needed for your problem then it probably is not.</p>
</td></tr>
<tr><td><code id="laplace_approximation_+3A_control">control</code></td>
<td>
<p>A list with elements
</p>

<ul>
<li><p><code>method</code>: optimization method to use:
</p>

<ul>
<li><p>'sparse_trust' (default): <code>trustOptim::trust.optim</code> with <code>method = 'sparse'</code>
</p>
</li>
<li><p>'SR1' (default): <code>trustOptim::trust.optim</code> with <code>method = 'SR1'</code>
</p>
</li>
<li><p>'trust': <code>trust::trust</code>
</p>
</li>
<li><p>'BFGS': <code>optim(...,method = "BFGS")</code>
</p>
</li></ul>

<p>Default is 'sparse_trust'.

</p>
</li>
<li><p><code>optcontrol</code>: optional: a list of control parameters to pass to the
internal optimizer you chose. The <code>aghq</code> package uses sensible defaults.
</p>
</li></ul>
</td></tr>
<tr><td><code id="laplace_approximation_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to <code>ff$fn</code>, <code>ff$gr</code>, and <code>ff$he</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>laplace</code> with summary and plot methods. This
is simply a list with elements <code>lognormconst</code> containing the log of the
approximate normalizing constant, and <code>optresults</code> containing the optimization
results formatted the same way as <code>optimize_theta</code> and <code>aghq</code>.
</p>


<h3>See Also</h3>

<p>Other quadrature: 
<code><a href="#topic+aghq">aghq</a>()</code>,
<code><a href="#topic+get_hessian">get_hessian</a>()</code>,
<code><a href="#topic+get_log_normconst">get_log_normconst</a>()</code>,
<code><a href="#topic+get_mode">get_mode</a>()</code>,
<code><a href="#topic+get_nodesandweights">get_nodesandweights</a>()</code>,
<code><a href="#topic+get_numquadpoints">get_numquadpoints</a>()</code>,
<code><a href="#topic+get_opt_results">get_opt_results</a>()</code>,
<code><a href="#topic+get_param_dim">get_param_dim</a>()</code>,
<code><a href="#topic+marginal_laplace_tmb">marginal_laplace_tmb</a>()</code>,
<code><a href="#topic+marginal_laplace">marginal_laplace</a>()</code>,
<code><a href="#topic+nested_quadrature">nested_quadrature</a>()</code>,
<code><a href="#topic+normalize_logpost">normalize_logpost</a>()</code>,
<code><a href="#topic+optimize_theta">optimize_theta</a>()</code>,
<code><a href="#topic+plot.aghq">plot.aghq</a>()</code>,
<code><a href="#topic+print.aghqsummary">print.aghqsummary</a>()</code>,
<code><a href="#topic+print.aghq">print.aghq</a>()</code>,
<code><a href="#topic+print.laplacesummary">print.laplacesummary</a>()</code>,
<code><a href="#topic+print.laplace">print.laplace</a>()</code>,
<code><a href="#topic+print.marginallaplacesummary">print.marginallaplacesummary</a>()</code>,
<code><a href="#topic+summary.aghq">summary.aghq</a>()</code>,
<code><a href="#topic+summary.laplace">summary.laplace</a>()</code>,
<code><a href="#topic+summary.marginallaplace">summary.marginallaplace</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
logfteta2d &lt;- function(eta,y) {
  # eta is now (eta1,eta2)
  # y is now (y1,y2)
  n &lt;- length(y)
  n1 &lt;- ceiling(n/2)
  n2 &lt;- floor(n/2)
  y1 &lt;- y[1:n1]
  y2 &lt;- y[(n1+1):(n1+n2)]
  eta1 &lt;- eta[1]
  eta2 &lt;- eta[2]
  sum(y1) * eta1 - (length(y1) + 1) * exp(eta1) - sum(lgamma(y1+1)) + eta1 +
    sum(y2) * eta2 - (length(y2) + 1) * exp(eta2) - sum(lgamma(y2+1)) + eta2
}
set.seed(84343124)
n1 &lt;- 5
n2 &lt;- 5
n &lt;- n1+n2
y1 &lt;- rpois(n1,5)
y2 &lt;- rpois(n2,5)
objfunc2d &lt;- function(x) logfteta2d(x,c(y1,y2))
funlist2d &lt;- list(
  fn = objfunc2d,
  gr = function(x) numDeriv::grad(objfunc2d,x),
  he = function(x) numDeriv::hessian(objfunc2d,x)
)

thequadrature &lt;- aghq(funlist2d,3,c(0,0))

</code></pre>

<hr>
<h2 id='make_moment_function'>Moments of Positive Functions</h2><span id='topic+make_moment_function'></span><span id='topic+make_moment_function.aghqmoment'></span><span id='topic+make_moment_function.aghqtrans'></span><span id='topic+make_moment_function.function'></span><span id='topic+make_moment_function.character'></span><span id='topic+make_moment_function.list'></span><span id='topic+make_moment_function.default'></span>

<h3>Description</h3>

<p>Given an object <code>quad</code> of class <code>aghq</code> returned by <code>aghq::aghq()</code>, <code>aghq::compute_moment()</code>
will compute the moment of a positive function <code>g(theta)</code> of parameter <code>theta</code>. The present function,
<code>aghq::make_moment_function()</code>, assists the user in constructing the appropriate input to <code>aghq::compute_moment()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_moment_function(...)

## S3 method for class 'aghqmoment'
make_moment_function(gg, ...)

## S3 method for class 'aghqtrans'
make_moment_function(gg, ...)

## S3 method for class ''function''
make_moment_function(gg, ...)

## S3 method for class 'character'
make_moment_function(gg, ...)

## S3 method for class 'list'
make_moment_function(gg, ...)

## Default S3 method:
make_moment_function(gg, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_moment_function_+3A_...">...</code></td>
<td>
<p>Used to pass arguments to methods.</p>
</td></tr>
<tr><td><code id="make_moment_function_+3A_gg">gg</code></td>
<td>
<p>LOGARITHM of function <code style="white-space: pre;">&#8288;R^p -&gt; R^+&#8288;</code> of which the moment is to be computed along with its two derivatives. So for example providing gg = function(x) x will compute the moment of exp(x).
Provided either as a <code>function</code>, a <code>list</code>, an <code>aghqtrans</code> object, or an <code>aghqmoment</code> object. See details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The approximation of moments of positive functions implemented in <code>aghq::compute_moment()</code>
achieves the same asymptotic rate of convergence as the marginal likelihood. This involves computing a new mode and
Hessian depending on the original posterior mode and Hessian, and <code>g</code>. These computations are handled by <code>aghq::compute_moment()</code>,
re-using information from the original quadrature when feasible.
</p>
<p>Computation of moments is defined only for scalar-valued functions, with a vector moment just defined as a vector of moments. Consequently,
the user may input to <code>aghq:compute_moment()</code> a function <code>g: R^p -&gt; R^q+</code> for any <code>q</code>, and that function will return the corresponding
vector of moments. This is handled within <code>aghq::compute_moment()</code>. The <code>aghq::make_moment_function()</code> interface accepts the logarithm of <code>gg: R^p -&gt; R^+</code>, i.e.
a multivariable, scalar-valued positive function. This is mostly to keep first and second derivatives as 1d and 2d arrays (i.e. the gradient and the Hessian);
I deemed it too confusing for the user and the code-base to work with Jacobians and 2nd derivative tensors (if you're confused just reading this, there you go!).
But, see <code>aghq::compute_moment()</code> for how to handle the very common case where the <em>same</em> transformation is desired of all parameter coordinates; for example
when all parameters are on the log-scale and you want to compute <code>E(exp(theta))</code> for <em>vector</em> <code>theta</code>.
</p>
<p>If <code>gg</code> is a <code>function</code> or a <code>character</code> (like <code>'exp'</code>) it is first passed to <code>match.fun</code>, and then the output
object is constructed using <code>numDeriv::grad()</code> and <code>numDeriv::hessian()</code>. If <code>gg</code> is a <code>list</code> then it is assumed to
have elements <code>fn</code>, <code>gr</code>, and <code>he</code> of the correct form, and these elements are extracted and then passed back to <code>make_moment_function()</code>.
If <code>gg</code> is an object of class <code>aghqtrans</code> returned by <code>aghq::make_transformation()</code>, then <code>gg$fromtheta</code>
is passed back to <code>make_moment_function()</code>. If <code>gg</code> is an object of class <code>aghqtrans</code> then it is just returned.
</p>


<h3>Value</h3>

<p>Object of class <code>aghqmoment</code>, which is a list with elements <code>fn</code>,
<code>gr</code>, and <code>he</code>, exactly like the input to <code>aghq::aghq()</code> and related functions. Here <code>gg$fn</code> is
<code>log(gg(theta))</code>, <code>gg$gr</code> is its gradient, and <code>gg$he</code> its Hessian.
Object is suitable for checking with <code>aghq::validate_moment()</code>
and for inputting into <code>aghq::compute_moment()</code>.
</p>


<h3>See Also</h3>

<p>Other moments: 
<code><a href="#topic+validate_moment">validate_moment</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># E(exp(x))
mom1 &lt;- make_moment_function(force) # force = function(x) x
mom2 &lt;- make_moment_function('force')
mom3 &lt;- make_moment_function(list(fn=function(x) x,gr=function(x) 1,he = function(x) 0))

</code></pre>

<hr>
<h2 id='make_numeric_moment_function'>Compute numeric moments</h2><span id='topic+make_numeric_moment_function'></span><span id='topic+get_shift'></span>

<h3>Description</h3>

<p>Create a function suitable for computation of numeric moments. This function is
used internally by <code>compute_moment</code> when the user chooses <code>nn</code>, and is
unlikely to need to be called by a user directly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_numeric_moment_function(nn, j, quad = NULL, centre = 0, shift = NULL, ...)

get_shift(gg)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_numeric_moment_function_+3A_nn">nn</code></td>
<td>
<p>Order of moment to be computed, see <code>nn</code> argument of <code>compute_moment</code>.</p>
</td></tr>
<tr><td><code id="make_numeric_moment_function_+3A_j">j</code></td>
<td>
<p>Numeric, positive integer, index of parameter vector to compute the numeric
moment for.</p>
</td></tr>
<tr><td><code id="make_numeric_moment_function_+3A_quad">quad</code></td>
<td>
<p>Optional, object of class <code>aghq</code>, only used if <code>shift</code> is not <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="make_numeric_moment_function_+3A_centre">centre</code></td>
<td>
<p>Numeric scalar, added to <code>shift</code> to ensure that central moments
remain far from zero.</p>
</td></tr>
<tr><td><code id="make_numeric_moment_function_+3A_shift">shift</code></td>
<td>
<p>Numeric scalar, amount by which to shift <code>theta</code>. The function that this
outputs is <code>g(theta) = (theta)^nn + shift</code>, and <code>shift</code> is returned with the
object so that it may later be subtracted. Default of <code>NULL</code> chooses this value
internally.</p>
</td></tr>
<tr><td><code id="make_numeric_moment_function_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
<tr><td><code id="make_numeric_moment_function_+3A_gg">gg</code></td>
<td>
<p>Object of class <code>aghqmoment</code>. Returns the <code>shift</code> applied to
the moment function. Returns <code>0</code> if no shift applied.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Object of class <code>aghqmoment</code>, see <code>make_moment_function</code>
</p>

<hr>
<h2 id='make_transformation'>Marginal Parameter Transformations</h2><span id='topic+make_transformation'></span><span id='topic+make_transformation.aghqtrans'></span><span id='topic+make_transformation.list'></span><span id='topic+make_transformation.default'></span>

<h3>Description</h3>

<p>These functions make it easier for the user to represent marginal parameter transformations
for which inferences are to be made. Suppose quadrature is done on the posterior for parameter <code>theta</code>,
but interest lies in parameter <code>lambda = g(theta)</code> for smooth, monotone, univariate
<code>g</code>. This interface lets the user provide <code>g</code>, <code>g^-1</code>, and (optionally)
the Jacobian <code>dtheta/dlambda</code>, and <code>aghq</code> will do quadrature on the <code>theta</code> scale
but report summaries on the <code>lambda</code> scale. See a note in the Details below about
multidimensional parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_transformation(...)

## S3 method for class 'aghqtrans'
make_transformation(transobj, ...)

## S3 method for class 'list'
make_transformation(translist, ...)

## Default S3 method:
make_transformation(totheta, fromtheta, jacobian = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_transformation_+3A_...">...</code></td>
<td>
<p>Used to pass arguments to methods.</p>
</td></tr>
<tr><td><code id="make_transformation_+3A_transobj">transobj</code></td>
<td>
<p>An object of class <code>aghqtrans</code>. Just returns this object. This is for internal
compatibility.</p>
</td></tr>
<tr><td><code id="make_transformation_+3A_translist">translist</code></td>
<td>
<p>A list with elements <code>totheta</code>, <code>fromtheta</code>, and, optionally, <code>jacobian</code>.</p>
</td></tr>
<tr><td><code id="make_transformation_+3A_totheta">totheta</code></td>
<td>
<p>Inverse function <code>g^-1(theta)</code>. Specifically, takes vector
<code>g_1(theta_1)...g_p(theta_p)</code> and returns vector <code>theta_1...theta_p</code>.</p>
</td></tr>
<tr><td><code id="make_transformation_+3A_fromtheta">fromtheta</code></td>
<td>
<p>Function <code>g: R^p -&gt; R^p</code>, where <code>p = dim(theta)</code>.
Must take vector <code>theta_1...theta_p</code> and return vector <code>g_1(theta_1)...g_p(theta_p)</code>, i.e.
only independent/marginal transformations are allowed (but these are the only ones
of interest, see below). For <code>j=1...p</code>, the parameter of
inferential interest is <code>lambda_j = g_j(theta_j)</code> and the parameter whose posterior is being
normalized via <code>aghq</code> is <code>theta_j</code>.  Passed to <code>match.fun</code>.</p>
</td></tr>
<tr><td><code id="make_transformation_+3A_jacobian">jacobian</code></td>
<td>
<p>(optional) Function taking <code>theta</code> and returning the absolute value of the determinant of
the Jacobian <code>dtheta/dg(theta)</code>. If not provided, a numerically differentiated Jacobian is used as
follows: <code>numDeriv::jacobian(totheta,fromtheta(theta))</code>. Passed to <code>match.fun</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Often, the scale on which quadrature is done is not the scale on which the user
wishes to make inferences. For example, when a parameter <code>lambda&gt;0</code> is
of interest, the posterior for <code>theta = log(lambda)</code> may be better approximated
by a log-quadratic than that for <code>lambda</code>, so running <code>aghq</code> on the
likelihood and prior for <code>theta</code> may lead to faster and more stable optimization
as well as more accurate estimates. But, interest is still in the original parameter
<code>lambda = exp(theta)</code>.
</p>
<p>These considerations are by no means unique to the use of quadrature-based approximate
Bayesian inferences. However, when using (say) <code>MCMC</code>, inferences for summaries
of transformations of the parameter are just as easy as for the un-transformed parameter.
When using quadrature, a little bit more work is needed.
</p>
<p>The <code>aghq</code> package provides an interface for computing
posterior summaries of smooth, monotonic parameter transformations. If quadrature
is done on parameter <code>theta</code> and <code>g(theta)</code> is a univariate, smooth, monotone function,
then inferences are made for <code>lambda = g(theta)</code>. In the case that <code>theta</code> is
<code>p</code>-dimensional, <code>p &gt; 1</code>, the supplied function <code>g</code> is understood to
take in <code>theta_1...theta_p</code> and return <code>g_1(theta_1)...g_p(theta_p)</code>. The
Jacobian is diagonal.
</p>
<p>To reiterate, all of this discussion applies only to <em>marginal</em> parameter transformations.
For the full joint parameter, the only summary statistics you can even calculate at all
(at present?) are moments, and you can already calculate the moment of any function <code>h(theta)</code>
using <code>aghq::compute_moment</code>, so no additional interface is needed here.
</p>


<h3>Value</h3>

<p>Object of class <code>aghqtrans</code>, which is simply a list with elements <code>totheta</code>,
<code>fromtheta</code>, and <code>jacobian</code>. Object is suitable for checking with <code>aghq::validate_transformation</code>
and for inputting into any function in <code>aghq</code> which takes a <code>transformation</code> argument.
</p>


<h3>See Also</h3>

<p>Other transformations: 
<code><a href="#topic+default_transformation">default_transformation</a>()</code>,
<code><a href="#topic+validate_transformation">validate_transformation</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
make_transformation('log','exp')
make_transformation(log,exp)

</code></pre>

<hr>
<h2 id='marginal_laplace'>Marginal Laplace approximation</h2><span id='topic+marginal_laplace'></span>

<h3>Description</h3>

<p>Implement the marginal Laplace approximation of Tierney and Kadane (1986) for
finding the marginal posterior <code>(theta | Y)</code> from an unnormalized joint posterior
<code>(W,theta,Y)</code> where <code>W</code> is high dimensional and <code>theta</code> is low dimensional.
See the <code>AGHQ</code> software paper for a detailed example, or Stringer et. al. (2020).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>marginal_laplace(
  ff,
  k,
  startingvalue,
  transformation = default_transformation(),
  optresults = NULL,
  control = default_control_marglaplace(),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="marginal_laplace_+3A_ff">ff</code></td>
<td>
<p>A function list similar to that required by <code>aghq</code>. However, each
function now takes arguments <code>W</code> and <code>theta</code>. Explicitly, this is a
list containing elements:
</p>

<ul>
<li><p><code>fn</code>: function taking arguments <code>W</code> and <code>theta</code> and returning a numeric
value representing the log-joint posterior at <code>W,theta</code>
</p>
</li>
<li><p><code>gr</code>: function taking arguments <code>W</code> and <code>theta</code> and returning a numeric
vector representing the gradient with respect to <code>W</code> of the log-joint posterior at <code>W,theta</code>
</p>
</li>
<li><p><code>he</code>: function taking arguments <code>W</code> and <code>theta</code> and returning a numeric
matrix representing the hessian with respect to <code>W</code> of the log-joint posterior at <code>W,theta</code>
</p>
</li></ul>
</td></tr>
<tr><td><code id="marginal_laplace_+3A_k">k</code></td>
<td>
<p>Integer, the number of quadrature points to use. I suggest at least 3. k = 1 corresponds to a Laplace
approximation.</p>
</td></tr>
<tr><td><code id="marginal_laplace_+3A_startingvalue">startingvalue</code></td>
<td>
<p>A list with elements <code>W</code> and <code>theta</code>, which are numeric
vectors to start the optimizations for each variable. If you're using this method
then the log-joint posterior should be concave and these optimizations should not be
sensitive to starting values.</p>
</td></tr>
<tr><td><code id="marginal_laplace_+3A_transformation">transformation</code></td>
<td>
<p>Optional. Do the quadrature for parameter <code>theta</code>, but
return summaries and plots for parameter <code>g(theta)</code>. This applies to the <code>theta</code>
parameters only, not the <code>W</code> parameters.
<code>transformation</code> is either: a) an <code>aghqtrans</code> object returned by <code>aghq::make_transformation</code>,
or b) a list that will be passed to that function internally. See <code>?aghq::make_transformation</code> for details.</p>
</td></tr>
<tr><td><code id="marginal_laplace_+3A_optresults">optresults</code></td>
<td>
<p>Optional. A list of the results of the optimization of the log
posterior, formatted according to the output of <code>aghq::optimize_theta</code>. The
<code>aghq::aghq</code> function handles the optimization for you; passing this list
overrides this, and is useful for when you know your optimization is too difficult to be
handled by general-purpose software. See the software paper for several examples of this.
If you're unsure whether this option is needed for your problem then it probably is not.</p>
</td></tr>
<tr><td><code id="marginal_laplace_+3A_control">control</code></td>
<td>
<p>A list with elements
</p>

<ul>
<li><p><code>method</code>: optimization method to use for the <code>theta</code> optimization:
</p>

<ul>
<li><p>'sparse_trust' (default): <code>trustOptim::trust.optim</code>
</p>
</li>
<li><p>'sparse': <code>trust::trust</code>
</p>
</li>
<li><p>'BFGS': <code>optim(...,method = "BFGS")</code>
</p>
</li></ul>


</li>
<li><p><code>inner_method</code>: optimization method to use for the <code>W</code> optimization; same
options as for <code>method</code>
</p>
</li></ul>

<p>Default <code>inner_method</code> is 'sparse_trust' and default <code>method</code> is 'BFGS'.</p>
</td></tr>
<tr><td><code id="marginal_laplace_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to <code>ff$fn</code>, <code>ff$gr</code>, and <code>ff$he</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>k &gt; 1</code>, an object of class <code>marginallaplace</code>, which includes
the result of calling <code>aghq::aghq</code> on
the Laplace approximation of <code>(theta|Y)</code>, .... See software paper for full details.
If <code>k = 1</code>, an object of class <code>laplace</code> which is the result of calling
<code>aghq::laplace_approximation</code> on
the Laplace approximation of <code>(theta|Y)</code>.
</p>


<h3>See Also</h3>

<p>Other quadrature: 
<code><a href="#topic+aghq">aghq</a>()</code>,
<code><a href="#topic+get_hessian">get_hessian</a>()</code>,
<code><a href="#topic+get_log_normconst">get_log_normconst</a>()</code>,
<code><a href="#topic+get_mode">get_mode</a>()</code>,
<code><a href="#topic+get_nodesandweights">get_nodesandweights</a>()</code>,
<code><a href="#topic+get_numquadpoints">get_numquadpoints</a>()</code>,
<code><a href="#topic+get_opt_results">get_opt_results</a>()</code>,
<code><a href="#topic+get_param_dim">get_param_dim</a>()</code>,
<code><a href="#topic+laplace_approximation">laplace_approximation</a>()</code>,
<code><a href="#topic+marginal_laplace_tmb">marginal_laplace_tmb</a>()</code>,
<code><a href="#topic+nested_quadrature">nested_quadrature</a>()</code>,
<code><a href="#topic+normalize_logpost">normalize_logpost</a>()</code>,
<code><a href="#topic+optimize_theta">optimize_theta</a>()</code>,
<code><a href="#topic+plot.aghq">plot.aghq</a>()</code>,
<code><a href="#topic+print.aghqsummary">print.aghqsummary</a>()</code>,
<code><a href="#topic+print.aghq">print.aghq</a>()</code>,
<code><a href="#topic+print.laplacesummary">print.laplacesummary</a>()</code>,
<code><a href="#topic+print.laplace">print.laplace</a>()</code>,
<code><a href="#topic+print.marginallaplacesummary">print.marginallaplacesummary</a>()</code>,
<code><a href="#topic+summary.aghq">summary.aghq</a>()</code>,
<code><a href="#topic+summary.laplace">summary.laplace</a>()</code>,
<code><a href="#topic+summary.marginallaplace">summary.marginallaplace</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>logfteta2d &lt;- function(eta,y) {
  # eta is now (eta1,eta2)
  # y is now (y1,y2)
  n &lt;- length(y)
  n1 &lt;- ceiling(n/2)
  n2 &lt;- floor(n/2)
  y1 &lt;- y[1:n1]
  y2 &lt;- y[(n1+1):(n1+n2)]
  eta1 &lt;- eta[1]
  eta2 &lt;- eta[2]
  sum(y1) * eta1 - (length(y1) + 1) * exp(eta1) - sum(lgamma(y1+1)) + eta1 +
    sum(y2) * eta2 - (length(y2) + 1) * exp(eta2) - sum(lgamma(y2+1)) + eta2
}
set.seed(84343124)
n1 &lt;- 5
n2 &lt;- 5
n &lt;- n1+n2
y1 &lt;- rpois(n1,5)
y2 &lt;- rpois(n2,5)
objfunc2d &lt;- function(x) logfteta2d(x,c(y1,y2))
objfunc2dmarg &lt;- function(W,theta) objfunc2d(c(W,theta))
objfunc2dmarggr &lt;- function(W,theta) {
  fn &lt;- function(W) objfunc2dmarg(W,theta)
  numDeriv::grad(fn,W)
}
objfunc2dmarghe &lt;- function(W,theta) {
  fn &lt;- function(W) objfunc2dmarg(W,theta)
  numDeriv::hessian(fn,W)
}

funlist2dmarg &lt;- list(
  fn = objfunc2dmarg,
  gr = objfunc2dmarggr,
  he = objfunc2dmarghe
)
</code></pre>

<hr>
<h2 id='marginal_laplace_tmb'>AGHQ-normalized marginal Laplace approximation from a TMB function template</h2><span id='topic+marginal_laplace_tmb'></span>

<h3>Description</h3>

<p>Implement the algorithm from <code>aghq::marginal_laplace()</code>, but making use of
<code>TMB</code>'s automatic Laplace approximation. This function takes a function
list from <code>TMB::MakeADFun()</code> with a non-empty set of <code>random</code> parameters,
in which the <code>fn</code> and <code>gr</code> are the unnormalized marginal Laplace
approximation and its gradient. It then calls <code>aghq::aghq()</code> and formats
the resulting object so that its contents and class match the output of
<code>aghq::marginal_laplace()</code> and are hence suitable for post-processing
with <code>summary</code>, <code>aghq::sample_marginal()</code>, and so on.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>marginal_laplace_tmb(
  ff,
  k,
  startingvalue,
  transformation = default_transformation(),
  optresults = NULL,
  basegrid = NULL,
  control = default_control_tmb(),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="marginal_laplace_tmb_+3A_ff">ff</code></td>
<td>
<p>The output of calling <code>TMB::MakeADFun()</code> with <code>random</code> set
to a non-empty subset of the parameters. <strong>VERY IMPORTANT</strong>: <code>TMB</code>'s
automatic Laplace approximation requires you to write your template implementing
the <strong>negated</strong> log-posterior. Therefore, this list that you input here
will contain components <code>fn</code>, <code>gr</code> and <code>he</code> that implement the
<strong>negated</strong> log-posterior and its derivatives. This is <strong>opposite</strong>
to every other comparable function in the <code>aghq</code> package, and is done
here to emphasize compatibility with <code>TMB</code>.</p>
</td></tr>
<tr><td><code id="marginal_laplace_tmb_+3A_k">k</code></td>
<td>
<p>Integer, the number of quadrature points to use. I suggest at least 3. k = 1 corresponds to a Laplace
approximation.</p>
</td></tr>
<tr><td><code id="marginal_laplace_tmb_+3A_startingvalue">startingvalue</code></td>
<td>
<p>Value to start the optimization. <code>ff$fn(startingvalue)</code>,
<code>ff$gr(startingvalue)</code>, and <code>ff$he(startingvalue)</code> must all return
appropriate values without error.</p>
</td></tr>
<tr><td><code id="marginal_laplace_tmb_+3A_transformation">transformation</code></td>
<td>
<p>Optional. Do the quadrature for parameter <code>theta</code>, but
return summaries and plots for parameter <code>g(theta)</code>. This applies to the <code>theta</code>
parameters only, not the <code>W</code> parameters.
<code>transformation</code> is either: a) an <code>aghqtrans</code> object returned by <code>aghq::make_transformation</code>,
or b) a list that will be passed to that function internally. See <code>?aghq::make_transformation</code> for details.</p>
</td></tr>
<tr><td><code id="marginal_laplace_tmb_+3A_optresults">optresults</code></td>
<td>
<p>Optional. A list of the results of the optimization of the log
posterior, formatted according to the output of <code>aghq::optimize_theta</code>. The
<code>aghq::aghq</code> function handles the optimization for you; passing this list
overrides this, and is useful for when you know your optimization is too difficult to be
handled by general-purpose software. See the software paper for several examples of this.
If you're unsure whether this option is needed for your problem then it probably is not.</p>
</td></tr>
<tr><td><code id="marginal_laplace_tmb_+3A_basegrid">basegrid</code></td>
<td>
<p>Optional. Provide an object of class <code>NIGrid</code> from the <code>mvQuad</code>
package, representing the base quadrature rule that will be adapted. This is only
for users who want more complete control over the quadrature, and is not necessary
if you are fine with the default option which basically corresponds to
<code>mvQuad::createNIGrid(length(theta),'GHe',k,'product')</code>. <strong>Note</strong>: the <code>mvQuad</code>
functions used within <code>aghq</code> operate on grids in memory, so your <code>basegrid</code>
object will be changed after you run <code>aghq</code>.</p>
</td></tr>
<tr><td><code id="marginal_laplace_tmb_+3A_control">control</code></td>
<td>
<p>A list of control parameters. See <code>?default_control</code> for details. Valid options are:
</p>

<ul>
<li><p><code>method</code>: optimization method to use for the <code>theta</code> optimization:
</p>

<ul>
<li><p>'sparse_trust' (default): <code>trustOptim::trust.optim</code>
</p>
</li>
<li><p>'sparse': <code>trust::trust</code>
</p>
</li>
<li><p>'BFGS': <code>optim(...,method = "BFGS")</code>
</p>
</li></ul>


</li>
<li><p><code>inner_method</code>: optimization method to use for the <code>W</code> optimization; same
options as for <code>method</code>. Default <code>inner_method</code> is 'sparse_trust' and default <code>method</code> is 'BFGS'.

</p>
</li>
<li> <p><code>negate</code>: default <code>TRUE</code>. See <code>?default_control_tmb</code>. Assumes that your <code>TMB</code> function
template computes the <strong>negated</strong> log-posterior, which it must if you're using <code>TMB</code>'s automatic
Laplace approximation, which you must be if you're using this function!</p>
</li></ul>
<p>.</p>
</td></tr>
<tr><td><code id="marginal_laplace_tmb_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to <code>ff$fn</code>, <code>ff$gr</code>, and <code>ff$he</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Because <code>TMB</code> does not yet have the Hessian of the log marginal Laplace
approximation implemented, a numerically-differentiated jacobian of the gradient
is used via <code>numDeriv::jacobian()</code>. You can turn this off (using <code>ff$he()</code> instead,
which you'll have to modify yourself) using <code>default_control_tmb(numhessian = FALSE)</code>.
</p>


<h3>Value</h3>

<p>If <code>k &gt; 1</code>, an object of class <code>marginallaplace</code>
(and inheriting from class <code>aghq</code>) of the same
structure as that returned by <code>aghq::marginal_laplace()</code>, with <code>plot</code>
and <code>summary</code> methods, and suitable for input into <code>aghq::sample_marginal()</code>
for drawing posterior samples.
</p>


<h3>See Also</h3>

<p>Other quadrature: 
<code><a href="#topic+aghq">aghq</a>()</code>,
<code><a href="#topic+get_hessian">get_hessian</a>()</code>,
<code><a href="#topic+get_log_normconst">get_log_normconst</a>()</code>,
<code><a href="#topic+get_mode">get_mode</a>()</code>,
<code><a href="#topic+get_nodesandweights">get_nodesandweights</a>()</code>,
<code><a href="#topic+get_numquadpoints">get_numquadpoints</a>()</code>,
<code><a href="#topic+get_opt_results">get_opt_results</a>()</code>,
<code><a href="#topic+get_param_dim">get_param_dim</a>()</code>,
<code><a href="#topic+laplace_approximation">laplace_approximation</a>()</code>,
<code><a href="#topic+marginal_laplace">marginal_laplace</a>()</code>,
<code><a href="#topic+nested_quadrature">nested_quadrature</a>()</code>,
<code><a href="#topic+normalize_logpost">normalize_logpost</a>()</code>,
<code><a href="#topic+optimize_theta">optimize_theta</a>()</code>,
<code><a href="#topic+plot.aghq">plot.aghq</a>()</code>,
<code><a href="#topic+print.aghqsummary">print.aghqsummary</a>()</code>,
<code><a href="#topic+print.aghq">print.aghq</a>()</code>,
<code><a href="#topic+print.laplacesummary">print.laplacesummary</a>()</code>,
<code><a href="#topic+print.laplace">print.laplace</a>()</code>,
<code><a href="#topic+print.marginallaplacesummary">print.marginallaplacesummary</a>()</code>,
<code><a href="#topic+summary.aghq">summary.aghq</a>()</code>,
<code><a href="#topic+summary.laplace">summary.laplace</a>()</code>,
<code><a href="#topic+summary.marginallaplace">summary.marginallaplace</a>()</code>
</p>

<hr>
<h2 id='marginal_posterior'>Marginal Posteriors</h2><span id='topic+marginal_posterior'></span><span id='topic+marginal_posterior.aghq'></span><span id='topic+marginal_posterior.list'></span>

<h3>Description</h3>

<p>Compute the marginal posterior for a given parameter using AGHQ. This function is
mostly called within <code>aghq()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>marginal_posterior(...)

## S3 method for class 'aghq'
marginal_posterior(
  quad,
  j,
  qq = NULL,
  method = c("auto", "reuse", "correct"),
  ...
)

## S3 method for class 'list'
marginal_posterior(
  optresults,
  k,
  j,
  basegrid = NULL,
  ndConstruction = "product",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="marginal_posterior_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to <code>optresults$ff</code>, see <code>?optimize_theta</code>.</p>
</td></tr>
<tr><td><code id="marginal_posterior_+3A_quad">quad</code></td>
<td>
<p>Object returned by <code>aghq::aghq</code>.</p>
</td></tr>
<tr><td><code id="marginal_posterior_+3A_j">j</code></td>
<td>
<p>Integer between 1 and the dimension of the parameter space. Which
index of the parameter vector to compute the marginal posterior for.</p>
</td></tr>
<tr><td><code id="marginal_posterior_+3A_qq">qq</code></td>
<td>
<p>Numeric vector of length <code>&gt;=1</code> giving the points at which to evaluate the marginal posterior.
The default, <code>NULL</code>, chooses these points in a 'clever' way, see Details.</p>
</td></tr>
<tr><td><code id="marginal_posterior_+3A_method">method</code></td>
<td>
<p>Method for computing the quadrature points used to approximate moment.
One of 'reuse' (default) or 'correct'. See details.
The default SHOULD be 'correct'; it is currently set to 'reuse' to maintain compatibility of
results with previous versions. This will be switched in a future major release.</p>
</td></tr>
<tr><td><code id="marginal_posterior_+3A_optresults">optresults</code></td>
<td>
<p>The results of calling <code>aghq::optimize_theta()</code>: see return value of that function.</p>
</td></tr>
<tr><td><code id="marginal_posterior_+3A_k">k</code></td>
<td>
<p>Integer, the number of quadrature points to use. I suggest at least 3. k = 1 corresponds to a Laplace
approximation.</p>
</td></tr>
<tr><td><code id="marginal_posterior_+3A_basegrid">basegrid</code></td>
<td>
<p>Optional. Provide an object of class <code>NIGrid</code> from the <code>mvQuad</code>
package, representing the base quadrature rule that will be adapted. This is only
for users who want more complete control over the quadrature, and is not necessary
if you are fine with the default option which basically corresponds to
<code>mvQuad::createNIGrid(length(theta),'GHe',k,'product')</code>.</p>
</td></tr>
<tr><td><code id="marginal_posterior_+3A_ndconstruction">ndConstruction</code></td>
<td>
<p>Create a multivariate grid using a product or sparse construction?
Passed directly to <code>mvQuad::createNIGrid()</code>, see that function for further details. Note
that the use of sparse grids within <code>aghq</code> is currently <strong>experimental</strong> and not supported
by tests. In particular, calculation of marginal posteriors is known to fail currently.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>qq=NULL</code>, then it is set to the unique values in an adapted GHQ grid computed
assuming that <code>j=1</code> (there is nothing special about this procedure, it's just a way to provide
an apparently sensible default).
</p>
<p>If <code>method='reuse'</code>, then the parameter vector is reordered so <code>j=1</code>, and the
approximate marginal is computed by first computing the whole AGHQ grid, then summing over the other
indices. This is an outdated method that does not have any theory pertaining to it, and is included for
backwards compatibility. It does not use <code>qq</code> if supplied.
</p>
<p>If <code>method='correct'</code> then the theoretically-justified approximation from Section 2.4 of the 'Stochastic Convergence Rates...'
paper is returned.
</p>
<p><code>method='auto'</code> currently chooses <code>'reuse'</code> for backwards compatibility, but this will be
changed in a future release.
</p>


<h3>Value</h3>

<p>a data.frame containing the normalized log marginal posterior
for theta_j evaluated at the original quadrature points. Has columns
<code>"thetaj","logpost_normalized","weights"</code>, where <code>j</code> is the <code>j</code> you specified.
</p>


<h3>See Also</h3>

<p>Other summaries: 
<code><a href="#topic+compute_pdf_and_cdf">compute_pdf_and_cdf</a>()</code>,
<code><a href="#topic+compute_quantiles">compute_quantiles</a>()</code>,
<code><a href="#topic+interpolate_marginal_posterior">interpolate_marginal_posterior</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## A 2d example ##
logfteta2d &lt;- function(eta,y) {
  # eta is now (eta1,eta2)
  # y is now (y1,y2)
  n &lt;- length(y)
  n1 &lt;- ceiling(n/2)
  n2 &lt;- floor(n/2)
  y1 &lt;- y[1:n1]
  y2 &lt;- y[(n1+1):(n1+n2)]
  eta1 &lt;- eta[1]
  eta2 &lt;- eta[2]
  sum(y1) * eta1 - (length(y1) + 1) * exp(eta1) - sum(lgamma(y1+1)) + eta1 +
    sum(y2) * eta2 - (length(y2) + 1) * exp(eta2) - sum(lgamma(y2+1)) + eta2
}
set.seed(84343124)
n1 &lt;- 5
n2 &lt;- 5
n &lt;- n1+n2
y1 &lt;- rpois(n1,5)
y2 &lt;- rpois(n2,5)
objfunc2d &lt;- function(x) logfteta2d(x,c(y1,y2))
funlist2d &lt;- list(
  fn = objfunc2d,
  gr = function(x) numDeriv::grad(objfunc2d,x),
  he = function(x) numDeriv::hessian(objfunc2d,x)
)
opt_sparsetrust_2d &lt;- optimize_theta(funlist2d,c(1.5,1.5))

# Now actually do the marginal posteriors
marginal_posterior(opt_sparsetrust_2d,3,1)
marginal_posterior(opt_sparsetrust_2d,3,2)
marginal_posterior(opt_sparsetrust_2d,7,2)

</code></pre>

<hr>
<h2 id='nested_quadrature'>Nested, sparse Gaussian quadrature in AGHQ</h2><span id='topic+nested_quadrature'></span><span id='topic+adaptive_nested_quadrature'></span><span id='topic+get_quadtable'></span>

<h3>Description</h3>

<p>Compute a whole sequence of log normalizing constants
for <code>1,3,5,...,k</code> points,
using only the function evaluations from the <code>k</code>-point nested rule.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nested_quadrature(optresults, k, ndConstruction = "product", ...)

adaptive_nested_quadrature(optresults, k, ndConstruction = "product", ...)

get_quadtable(p, k, ndConstruction = "product", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nested_quadrature_+3A_optresults">optresults</code></td>
<td>
<p>The results of calling <code>aghq::optimize_theta()</code>: see return value of that function.
The dimension of the parameter <code>p</code> will be taken from <code>optresults$mode</code>.</p>
</td></tr>
<tr><td><code id="nested_quadrature_+3A_k">k</code></td>
<td>
<p>Integer, the number of quadrature points to use.</p>
</td></tr>
<tr><td><code id="nested_quadrature_+3A_ndconstruction">ndConstruction</code></td>
<td>
<p>Create a multivariate grid using a product or sparse construction?
Passed directly to <code>mvQuad::createNIGrid()</code>, see that function for further details.</p>
</td></tr>
<tr><td><code id="nested_quadrature_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to <code>optresults$ff</code>, see <code>?optimize_theta</code>.</p>
</td></tr>
<tr><td><code id="nested_quadrature_+3A_p">p</code></td>
<td>
<p>Dimension of the variable of integration.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>get_quadtable</code> currently uses <code>mvQuad</code> to compute the nodes and weights. This will be replaced
by a manual reading of the pre-tabulated nodes and weights.
</p>
<p><code>nested_quadrature</code> and <code>adaptive_nested_quadrature</code> take the <strong>log</strong> function values, just like <code>optimize_theta()</code>,
and return the <strong>log</strong> of the base/adapted quadrature rule.
</p>


<h3>Value</h3>

<p>For <code>get_quadtable</code>, a pre-computed table of nodes for the <code>k</code>-point rule,
with weights for the points from each of the <code>1,3,...,k</code>-point rules, for passing to
<code>nested_quadrature</code>. For <code>nested_quadrature</code> and <code>adaptive_nested_quadrature</code>, a named numeric vector of <code>optresults$fn</code>
values for each <code>k</code>.
</p>


<h3>See Also</h3>

<p>Other quadrature: 
<code><a href="#topic+aghq">aghq</a>()</code>,
<code><a href="#topic+get_hessian">get_hessian</a>()</code>,
<code><a href="#topic+get_log_normconst">get_log_normconst</a>()</code>,
<code><a href="#topic+get_mode">get_mode</a>()</code>,
<code><a href="#topic+get_nodesandweights">get_nodesandweights</a>()</code>,
<code><a href="#topic+get_numquadpoints">get_numquadpoints</a>()</code>,
<code><a href="#topic+get_opt_results">get_opt_results</a>()</code>,
<code><a href="#topic+get_param_dim">get_param_dim</a>()</code>,
<code><a href="#topic+laplace_approximation">laplace_approximation</a>()</code>,
<code><a href="#topic+marginal_laplace_tmb">marginal_laplace_tmb</a>()</code>,
<code><a href="#topic+marginal_laplace">marginal_laplace</a>()</code>,
<code><a href="#topic+normalize_logpost">normalize_logpost</a>()</code>,
<code><a href="#topic+optimize_theta">optimize_theta</a>()</code>,
<code><a href="#topic+plot.aghq">plot.aghq</a>()</code>,
<code><a href="#topic+print.aghqsummary">print.aghqsummary</a>()</code>,
<code><a href="#topic+print.aghq">print.aghq</a>()</code>,
<code><a href="#topic+print.laplacesummary">print.laplacesummary</a>()</code>,
<code><a href="#topic+print.laplace">print.laplace</a>()</code>,
<code><a href="#topic+print.marginallaplacesummary">print.marginallaplacesummary</a>()</code>,
<code><a href="#topic+summary.aghq">summary.aghq</a>()</code>,
<code><a href="#topic+summary.laplace">summary.laplace</a>()</code>,
<code><a href="#topic+summary.marginallaplace">summary.marginallaplace</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Same setup as optimize_theta
logfteta &lt;- function(eta,y) {
  sum(y) * eta - (length(y) + 1) * exp(eta) - sum(lgamma(y+1)) + eta
}
set.seed(84343124)
y &lt;- rpois(10,5) # Mode should be sum(y) / (10 + 1)
truemode &lt;- log((sum(y) + 1)/(length(y) + 1))
objfunc &lt;- function(x) logfteta(x,y)
funlist &lt;- list(
  fn = objfunc,
  gr = function(x) numDeriv::grad(objfunc,x),
  he = function(x) numDeriv::hessian(objfunc,x)
)
opt_sparsetrust &lt;- optimize_theta(funlist,1.5)

</code></pre>

<hr>
<h2 id='normalize_logpost'>Normalize the joint posterior using AGHQ</h2><span id='topic+normalize_logpost'></span>

<h3>Description</h3>

<p>This function takes in the optimization results from <code>aghq::optimize_theta()</code>
and returns a list with the quadrature points, weights, and normalization
information. Like <code>aghq::optimize_theta()</code>, this is designed for use only within
<code>aghq::aghq</code>, but is exported for debugging and documented in case you want to
modify it somehow, or something.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>normalize_logpost(
  optresults,
  k,
  whichfirst = 1,
  basegrid = NULL,
  ndConstruction = "product",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="normalize_logpost_+3A_optresults">optresults</code></td>
<td>
<p>The results of calling <code>aghq::optimize_theta()</code>: see return value of that function.</p>
</td></tr>
<tr><td><code id="normalize_logpost_+3A_k">k</code></td>
<td>
<p>Integer, the number of quadrature points to use. I suggest at least 3. k = 1 corresponds to a Laplace
approximation.</p>
</td></tr>
<tr><td><code id="normalize_logpost_+3A_whichfirst">whichfirst</code></td>
<td>
<p>Integer between 1 and the dimension of the parameter space, default 1.
The user shouldn't have to worry about this: it's used internally to re-order the parameter vector
before doing the quadrature, which is useful when calculating marginal posteriors.</p>
</td></tr>
<tr><td><code id="normalize_logpost_+3A_basegrid">basegrid</code></td>
<td>
<p>Optional. Provide an object of class <code>NIGrid</code> from the <code>mvQuad</code>
package, representing the base quadrature rule that will be adapted. This is only
for users who want more complete control over the quadrature, and is not necessary
if you are fine with the default option which basically corresponds to
<code>mvQuad::createNIGrid(length(theta),'GHe',k,'product')</code>.</p>
</td></tr>
<tr><td><code id="normalize_logpost_+3A_ndconstruction">ndConstruction</code></td>
<td>
<p>Create a multivariate grid using a product or sparse construction?
Passed directly to <code>mvQuad::createNIGrid()</code>, see that function for further details. Note
that the use of sparse grids within <code>aghq</code> is currently <strong>experimental</strong> and not supported
by tests. In particular, calculation of marginal posteriors is known to fail currently.</p>
</td></tr>
<tr><td><code id="normalize_logpost_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to <code>optresults$ff</code>, see <code>?optimize_theta</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If k &gt; 1, a list with elements:
</p>

<ul>
<li><p><code>nodesandweights</code>: a dataframe containing the nodes and weights for the adaptive quadrature rule, with the un-normalized and normalized log posterior evaluated at the nodes.
</p>
</li>
<li><p><code>thegrid</code>: a <code>NIGrid</code> object from the <code>mvQuad</code> package, see <code>?mvQuad::createNIGrid</code>.
</p>
</li>
<li><p><code>lognormconst</code>: the actual result of the quadrature: the log of the normalizing constant of the posterior.
</p>
</li></ul>



<h3>See Also</h3>

<p>Other quadrature: 
<code><a href="#topic+aghq">aghq</a>()</code>,
<code><a href="#topic+get_hessian">get_hessian</a>()</code>,
<code><a href="#topic+get_log_normconst">get_log_normconst</a>()</code>,
<code><a href="#topic+get_mode">get_mode</a>()</code>,
<code><a href="#topic+get_nodesandweights">get_nodesandweights</a>()</code>,
<code><a href="#topic+get_numquadpoints">get_numquadpoints</a>()</code>,
<code><a href="#topic+get_opt_results">get_opt_results</a>()</code>,
<code><a href="#topic+get_param_dim">get_param_dim</a>()</code>,
<code><a href="#topic+laplace_approximation">laplace_approximation</a>()</code>,
<code><a href="#topic+marginal_laplace_tmb">marginal_laplace_tmb</a>()</code>,
<code><a href="#topic+marginal_laplace">marginal_laplace</a>()</code>,
<code><a href="#topic+nested_quadrature">nested_quadrature</a>()</code>,
<code><a href="#topic+optimize_theta">optimize_theta</a>()</code>,
<code><a href="#topic+plot.aghq">plot.aghq</a>()</code>,
<code><a href="#topic+print.aghqsummary">print.aghqsummary</a>()</code>,
<code><a href="#topic+print.aghq">print.aghq</a>()</code>,
<code><a href="#topic+print.laplacesummary">print.laplacesummary</a>()</code>,
<code><a href="#topic+print.laplace">print.laplace</a>()</code>,
<code><a href="#topic+print.marginallaplacesummary">print.marginallaplacesummary</a>()</code>,
<code><a href="#topic+summary.aghq">summary.aghq</a>()</code>,
<code><a href="#topic+summary.laplace">summary.laplace</a>()</code>,
<code><a href="#topic+summary.marginallaplace">summary.marginallaplace</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Same setup as optimize_theta
logfteta &lt;- function(eta,y) {
  sum(y) * eta - (length(y) + 1) * exp(eta) - sum(lgamma(y+1)) + eta
}
set.seed(84343124)
y &lt;- rpois(10,5) # Mode should be sum(y) / (10 + 1)
truemode &lt;- log((sum(y) + 1)/(length(y) + 1))
objfunc &lt;- function(x) logfteta(x,y)
funlist &lt;- list(
  fn = objfunc,
  gr = function(x) numDeriv::grad(objfunc,x),
  he = function(x) numDeriv::hessian(objfunc,x)
)
opt_sparsetrust &lt;- optimize_theta(funlist,1.5)
opt_trust &lt;- optimize_theta(funlist,1.5,control = default_control(method = "trust"))
opt_bfgs &lt;- optimize_theta(funlist,1.5,control = default_control(method = "BFGS"))

# Quadrature with 3, 5, and 7 points using sparse trust region optimization:
norm_sparse_3 &lt;- normalize_logpost(opt_sparsetrust,3,1)
norm_sparse_5 &lt;- normalize_logpost(opt_sparsetrust,5,1)
norm_sparse_7 &lt;- normalize_logpost(opt_sparsetrust,7,1)

# Quadrature with 3, 5, and 7 points using dense trust region optimization:
norm_trust_3 &lt;- normalize_logpost(opt_trust,3,1)
norm_trust_5 &lt;- normalize_logpost(opt_trust,5,1)
norm_trust_7 &lt;- normalize_logpost(opt_trust,7,1)

# Quadrature with 3, 5, and 7 points using BFGS optimization:
norm_bfgs_3 &lt;- normalize_logpost(opt_bfgs,3,1)
norm_bfgs_5 &lt;- normalize_logpost(opt_bfgs,5,1)
norm_bfgs_7 &lt;- normalize_logpost(opt_bfgs,7,1)

</code></pre>

<hr>
<h2 id='optimize_theta'>Obtain function information necessary for performing quadrature</h2><span id='topic+optimize_theta'></span>

<h3>Description</h3>

<p>This function computes the two pieces of information needed about
the log posterior to do adaptive quadrature: the mode, and the hessian at the mode.
It is designed for use within <code>aghq::aghq</code>, but is exported in case users
need to debug the optimization process and documented in case users want to
write their own optimizations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>optimize_theta(ff, startingvalue, control = default_control(), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="optimize_theta_+3A_ff">ff</code></td>
<td>
<p>A list with three elements:
</p>

<ul>
<li><p><code>fn</code>: function taking argument <code>theta</code> and returning a numeric
value representing the log-posterior at <code>theta</code>
</p>
</li>
<li><p><code>gr</code>: function taking argument <code>theta</code> and returning a numeric
vector representing the gradient of the log-posterior at <code>theta</code>
</p>
</li>
<li><p><code>he</code>: function taking argument <code>theta</code> and returning a numeric
matrix representing the hessian of the log-posterior at <code>theta</code>
</p>
</li></ul>

<p>The user may wish to use <code>numDeriv::grad</code> and/or <code>numDeriv::hessian</code> to
obtain these. Alternatively, the user may consider the <code>TMB</code> package. This
list is deliberately formatted to match the output of <code>TMB::MakeADFun</code>.</p>
</td></tr>
<tr><td><code id="optimize_theta_+3A_startingvalue">startingvalue</code></td>
<td>
<p>Value to start the optimization. <code>ff$fn(startingvalue)</code>,
<code>ff$gr(startingvalue)</code>, and <code>ff$he(startingvalue)</code> must all return
appropriate values without error.</p>
</td></tr>
<tr><td><code id="optimize_theta_+3A_control">control</code></td>
<td>
<p>A list with elements
</p>

<ul>
<li><p><code>method</code>: optimization method to use:
</p>

<ul>
<li><p>'sparse_trust' (default): <code>trustOptim::trust.optim</code> with <code>method = 'sparse'</code>
</p>
</li>
<li><p>'SR1' (default): <code>trustOptim::trust.optim</code> with <code>method = 'SR1'</code>
</p>
</li>
<li><p>'trust': <code>trust::trust</code>
</p>
</li>
<li><p>'BFGS': <code>optim(...,method = "BFGS")</code>
</p>
</li></ul>

<p>Default is 'sparse_trust'.

</p>
</li>
<li><p><code>optcontrol</code>: optional: a list of control parameters to pass to the
internal optimizer you chose. The <code>aghq</code> package uses sensible defaults.
</p>
</li></ul>
</td></tr>
<tr><td><code id="optimize_theta_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to <code>ff$fn</code>, <code>ff$gr</code>, and <code>ff$he</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with elements
</p>

<ul>
<li><p><code>ff</code>: the function list that was provided
</p>
</li>
<li><p><code>mode</code>: the mode of the log posterior
</p>
</li>
<li><p><code>hessian</code>: the hessian of the log posterior at the mode
</p>
</li>
<li><p><code>convergence</code>: specific to the optimizer used, a message indicating whether it converged
</p>
</li></ul>



<h3>See Also</h3>

<p>Other quadrature: 
<code><a href="#topic+aghq">aghq</a>()</code>,
<code><a href="#topic+get_hessian">get_hessian</a>()</code>,
<code><a href="#topic+get_log_normconst">get_log_normconst</a>()</code>,
<code><a href="#topic+get_mode">get_mode</a>()</code>,
<code><a href="#topic+get_nodesandweights">get_nodesandweights</a>()</code>,
<code><a href="#topic+get_numquadpoints">get_numquadpoints</a>()</code>,
<code><a href="#topic+get_opt_results">get_opt_results</a>()</code>,
<code><a href="#topic+get_param_dim">get_param_dim</a>()</code>,
<code><a href="#topic+laplace_approximation">laplace_approximation</a>()</code>,
<code><a href="#topic+marginal_laplace_tmb">marginal_laplace_tmb</a>()</code>,
<code><a href="#topic+marginal_laplace">marginal_laplace</a>()</code>,
<code><a href="#topic+nested_quadrature">nested_quadrature</a>()</code>,
<code><a href="#topic+normalize_logpost">normalize_logpost</a>()</code>,
<code><a href="#topic+plot.aghq">plot.aghq</a>()</code>,
<code><a href="#topic+print.aghqsummary">print.aghqsummary</a>()</code>,
<code><a href="#topic+print.aghq">print.aghq</a>()</code>,
<code><a href="#topic+print.laplacesummary">print.laplacesummary</a>()</code>,
<code><a href="#topic+print.laplace">print.laplace</a>()</code>,
<code><a href="#topic+print.marginallaplacesummary">print.marginallaplacesummary</a>()</code>,
<code><a href="#topic+summary.aghq">summary.aghq</a>()</code>,
<code><a href="#topic+summary.laplace">summary.laplace</a>()</code>,
<code><a href="#topic+summary.marginallaplace">summary.marginallaplace</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Poisson/Exponential example
logfteta &lt;- function(eta,y) {
  sum(y) * eta - (length(y) + 1) * exp(eta) - sum(lgamma(y+1)) + eta
}

y &lt;- rpois(10,5) # Mode should be (sum(y) + 1) / (length(y) + 1)

objfunc &lt;- function(x) logfteta(x,y)
funlist &lt;- list(
  fn = objfunc,
  gr = function(x) numDeriv::grad(objfunc,x),
  he = function(x) numDeriv::hessian(objfunc,x)
)

optimize_theta(funlist,1.5)
optimize_theta(funlist,1.5,control = default_control(method = "trust"))
optimize_theta(funlist,1.5,control = default_control(method = "BFGS"))

</code></pre>

<hr>
<h2 id='plot.aghq'>Plot method for AGHQ objects</h2><span id='topic+plot.aghq'></span>

<h3>Description</h3>

<p>Plot the marginal pdf and cdf of the transformed parameter from an <code>aghq</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'aghq'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.aghq_+3A_x">x</code></td>
<td>
<p>The return value of <code>aghq::aghq</code>. Plots are created for the marginal
pdf and cdf of <code>x$transformation$fromtheta(theta)</code>.</p>
</td></tr>
<tr><td><code id="plot.aghq_+3A_...">...</code></td>
<td>
<p>not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Silently plots.
</p>


<h3>See Also</h3>

<p>Other quadrature: 
<code><a href="#topic+aghq">aghq</a>()</code>,
<code><a href="#topic+get_hessian">get_hessian</a>()</code>,
<code><a href="#topic+get_log_normconst">get_log_normconst</a>()</code>,
<code><a href="#topic+get_mode">get_mode</a>()</code>,
<code><a href="#topic+get_nodesandweights">get_nodesandweights</a>()</code>,
<code><a href="#topic+get_numquadpoints">get_numquadpoints</a>()</code>,
<code><a href="#topic+get_opt_results">get_opt_results</a>()</code>,
<code><a href="#topic+get_param_dim">get_param_dim</a>()</code>,
<code><a href="#topic+laplace_approximation">laplace_approximation</a>()</code>,
<code><a href="#topic+marginal_laplace_tmb">marginal_laplace_tmb</a>()</code>,
<code><a href="#topic+marginal_laplace">marginal_laplace</a>()</code>,
<code><a href="#topic+nested_quadrature">nested_quadrature</a>()</code>,
<code><a href="#topic+normalize_logpost">normalize_logpost</a>()</code>,
<code><a href="#topic+optimize_theta">optimize_theta</a>()</code>,
<code><a href="#topic+print.aghqsummary">print.aghqsummary</a>()</code>,
<code><a href="#topic+print.aghq">print.aghq</a>()</code>,
<code><a href="#topic+print.laplacesummary">print.laplacesummary</a>()</code>,
<code><a href="#topic+print.laplace">print.laplace</a>()</code>,
<code><a href="#topic+print.marginallaplacesummary">print.marginallaplacesummary</a>()</code>,
<code><a href="#topic+summary.aghq">summary.aghq</a>()</code>,
<code><a href="#topic+summary.laplace">summary.laplace</a>()</code>,
<code><a href="#topic+summary.marginallaplace">summary.marginallaplace</a>()</code>
</p>
<p>Other quadrature: 
<code><a href="#topic+aghq">aghq</a>()</code>,
<code><a href="#topic+get_hessian">get_hessian</a>()</code>,
<code><a href="#topic+get_log_normconst">get_log_normconst</a>()</code>,
<code><a href="#topic+get_mode">get_mode</a>()</code>,
<code><a href="#topic+get_nodesandweights">get_nodesandweights</a>()</code>,
<code><a href="#topic+get_numquadpoints">get_numquadpoints</a>()</code>,
<code><a href="#topic+get_opt_results">get_opt_results</a>()</code>,
<code><a href="#topic+get_param_dim">get_param_dim</a>()</code>,
<code><a href="#topic+laplace_approximation">laplace_approximation</a>()</code>,
<code><a href="#topic+marginal_laplace_tmb">marginal_laplace_tmb</a>()</code>,
<code><a href="#topic+marginal_laplace">marginal_laplace</a>()</code>,
<code><a href="#topic+nested_quadrature">nested_quadrature</a>()</code>,
<code><a href="#topic+normalize_logpost">normalize_logpost</a>()</code>,
<code><a href="#topic+optimize_theta">optimize_theta</a>()</code>,
<code><a href="#topic+print.aghqsummary">print.aghqsummary</a>()</code>,
<code><a href="#topic+print.aghq">print.aghq</a>()</code>,
<code><a href="#topic+print.laplacesummary">print.laplacesummary</a>()</code>,
<code><a href="#topic+print.laplace">print.laplace</a>()</code>,
<code><a href="#topic+print.marginallaplacesummary">print.marginallaplacesummary</a>()</code>,
<code><a href="#topic+summary.aghq">summary.aghq</a>()</code>,
<code><a href="#topic+summary.laplace">summary.laplace</a>()</code>,
<code><a href="#topic+summary.marginallaplace">summary.marginallaplace</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
logfteta2d &lt;- function(eta,y) {
  # eta is now (eta1,eta2)
  # y is now (y1,y2)
  n &lt;- length(y)
  n1 &lt;- ceiling(n/2)
  n2 &lt;- floor(n/2)
  y1 &lt;- y[1:n1]
  y2 &lt;- y[(n1+1):(n1+n2)]
  eta1 &lt;- eta[1]
  eta2 &lt;- eta[2]
  sum(y1) * eta1 - (length(y1) + 1) * exp(eta1) - sum(lgamma(y1+1)) + eta1 +
    sum(y2) * eta2 - (length(y2) + 1) * exp(eta2) - sum(lgamma(y2+1)) + eta2
}
set.seed(84343124)
n1 &lt;- 5
n2 &lt;- 5
n &lt;- n1+n2
y1 &lt;- rpois(n1,5)
y2 &lt;- rpois(n2,5)
objfunc2d &lt;- function(x) logfteta2d(x,c(y1,y2))
funlist2d &lt;- list(
  fn = objfunc2d,
  gr = function(x) numDeriv::grad(objfunc2d,x),
  he = function(x) numDeriv::hessian(objfunc2d,x)
)

thequadrature &lt;- aghq(funlist2d,3,c(0,0))
plot(thequadrature)

</code></pre>

<hr>
<h2 id='print.aghq'>Print method for AGHQ objects</h2><span id='topic+print.aghq'></span>

<h3>Description</h3>

<p>Pretty print the object&ndash; just gives some basic information and then suggests
the user call <code>summary(...)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'aghq'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.aghq_+3A_x">x</code></td>
<td>
<p>An object of class <code>aghq</code>.</p>
</td></tr>
<tr><td><code id="print.aghq_+3A_...">...</code></td>
<td>
<p>not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Silently prints summary information.
</p>


<h3>See Also</h3>

<p>Other quadrature: 
<code><a href="#topic+aghq">aghq</a>()</code>,
<code><a href="#topic+get_hessian">get_hessian</a>()</code>,
<code><a href="#topic+get_log_normconst">get_log_normconst</a>()</code>,
<code><a href="#topic+get_mode">get_mode</a>()</code>,
<code><a href="#topic+get_nodesandweights">get_nodesandweights</a>()</code>,
<code><a href="#topic+get_numquadpoints">get_numquadpoints</a>()</code>,
<code><a href="#topic+get_opt_results">get_opt_results</a>()</code>,
<code><a href="#topic+get_param_dim">get_param_dim</a>()</code>,
<code><a href="#topic+laplace_approximation">laplace_approximation</a>()</code>,
<code><a href="#topic+marginal_laplace_tmb">marginal_laplace_tmb</a>()</code>,
<code><a href="#topic+marginal_laplace">marginal_laplace</a>()</code>,
<code><a href="#topic+nested_quadrature">nested_quadrature</a>()</code>,
<code><a href="#topic+normalize_logpost">normalize_logpost</a>()</code>,
<code><a href="#topic+optimize_theta">optimize_theta</a>()</code>,
<code><a href="#topic+plot.aghq">plot.aghq</a>()</code>,
<code><a href="#topic+print.aghqsummary">print.aghqsummary</a>()</code>,
<code><a href="#topic+print.laplacesummary">print.laplacesummary</a>()</code>,
<code><a href="#topic+print.laplace">print.laplace</a>()</code>,
<code><a href="#topic+print.marginallaplacesummary">print.marginallaplacesummary</a>()</code>,
<code><a href="#topic+summary.aghq">summary.aghq</a>()</code>,
<code><a href="#topic+summary.laplace">summary.laplace</a>()</code>,
<code><a href="#topic+summary.marginallaplace">summary.marginallaplace</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
logfteta2d &lt;- function(eta,y) {
  # eta is now (eta1,eta2)
  # y is now (y1,y2)
  n &lt;- length(y)
  n1 &lt;- ceiling(n/2)
  n2 &lt;- floor(n/2)
  y1 &lt;- y[1:n1]
  y2 &lt;- y[(n1+1):(n1+n2)]
  eta1 &lt;- eta[1]
  eta2 &lt;- eta[2]
  sum(y1) * eta1 - (length(y1) + 1) * exp(eta1) - sum(lgamma(y1+1)) + eta1 +
    sum(y2) * eta2 - (length(y2) + 1) * exp(eta2) - sum(lgamma(y2+1)) + eta2
}
set.seed(84343124)
n1 &lt;- 5
n2 &lt;- 5
n &lt;- n1+n2
y1 &lt;- rpois(n1,5)
y2 &lt;- rpois(n2,5)
objfunc2d &lt;- function(x) logfteta2d(x,c(y1,y2))
funlist2d &lt;- list(
  fn = objfunc2d,
  gr = function(x) numDeriv::grad(objfunc2d,x),
  he = function(x) numDeriv::hessian(objfunc2d,x)
)

thequadrature &lt;- aghq(funlist2d,3,c(0,0))
thequadrature

</code></pre>

<hr>
<h2 id='print.aghqsummary'>Print method for AGHQ summary objects</h2><span id='topic+print.aghqsummary'></span>

<h3>Description</h3>

<p>Print the summary of an <code>aghq</code> object. Almost always called by invoking
<code>summary(...)</code> interactively in the console.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'aghqsummary'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.aghqsummary_+3A_x">x</code></td>
<td>
<p>The result of calling <code>summary(...)</code> on an object of class <code>aghq</code>.</p>
</td></tr>
<tr><td><code id="print.aghqsummary_+3A_...">...</code></td>
<td>
<p>not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Silently prints summary information.
</p>


<h3>See Also</h3>

<p>Other quadrature: 
<code><a href="#topic+aghq">aghq</a>()</code>,
<code><a href="#topic+get_hessian">get_hessian</a>()</code>,
<code><a href="#topic+get_log_normconst">get_log_normconst</a>()</code>,
<code><a href="#topic+get_mode">get_mode</a>()</code>,
<code><a href="#topic+get_nodesandweights">get_nodesandweights</a>()</code>,
<code><a href="#topic+get_numquadpoints">get_numquadpoints</a>()</code>,
<code><a href="#topic+get_opt_results">get_opt_results</a>()</code>,
<code><a href="#topic+get_param_dim">get_param_dim</a>()</code>,
<code><a href="#topic+laplace_approximation">laplace_approximation</a>()</code>,
<code><a href="#topic+marginal_laplace_tmb">marginal_laplace_tmb</a>()</code>,
<code><a href="#topic+marginal_laplace">marginal_laplace</a>()</code>,
<code><a href="#topic+nested_quadrature">nested_quadrature</a>()</code>,
<code><a href="#topic+normalize_logpost">normalize_logpost</a>()</code>,
<code><a href="#topic+optimize_theta">optimize_theta</a>()</code>,
<code><a href="#topic+plot.aghq">plot.aghq</a>()</code>,
<code><a href="#topic+print.aghq">print.aghq</a>()</code>,
<code><a href="#topic+print.laplacesummary">print.laplacesummary</a>()</code>,
<code><a href="#topic+print.laplace">print.laplace</a>()</code>,
<code><a href="#topic+print.marginallaplacesummary">print.marginallaplacesummary</a>()</code>,
<code><a href="#topic+summary.aghq">summary.aghq</a>()</code>,
<code><a href="#topic+summary.laplace">summary.laplace</a>()</code>,
<code><a href="#topic+summary.marginallaplace">summary.marginallaplace</a>()</code>
</p>
<p>Other quadrature: 
<code><a href="#topic+aghq">aghq</a>()</code>,
<code><a href="#topic+get_hessian">get_hessian</a>()</code>,
<code><a href="#topic+get_log_normconst">get_log_normconst</a>()</code>,
<code><a href="#topic+get_mode">get_mode</a>()</code>,
<code><a href="#topic+get_nodesandweights">get_nodesandweights</a>()</code>,
<code><a href="#topic+get_numquadpoints">get_numquadpoints</a>()</code>,
<code><a href="#topic+get_opt_results">get_opt_results</a>()</code>,
<code><a href="#topic+get_param_dim">get_param_dim</a>()</code>,
<code><a href="#topic+laplace_approximation">laplace_approximation</a>()</code>,
<code><a href="#topic+marginal_laplace_tmb">marginal_laplace_tmb</a>()</code>,
<code><a href="#topic+marginal_laplace">marginal_laplace</a>()</code>,
<code><a href="#topic+nested_quadrature">nested_quadrature</a>()</code>,
<code><a href="#topic+normalize_logpost">normalize_logpost</a>()</code>,
<code><a href="#topic+optimize_theta">optimize_theta</a>()</code>,
<code><a href="#topic+plot.aghq">plot.aghq</a>()</code>,
<code><a href="#topic+print.aghq">print.aghq</a>()</code>,
<code><a href="#topic+print.laplacesummary">print.laplacesummary</a>()</code>,
<code><a href="#topic+print.laplace">print.laplace</a>()</code>,
<code><a href="#topic+print.marginallaplacesummary">print.marginallaplacesummary</a>()</code>,
<code><a href="#topic+summary.aghq">summary.aghq</a>()</code>,
<code><a href="#topic+summary.laplace">summary.laplace</a>()</code>,
<code><a href="#topic+summary.marginallaplace">summary.marginallaplace</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
logfteta2d &lt;- function(eta,y) {
  # eta is now (eta1,eta2)
  # y is now (y1,y2)
  n &lt;- length(y)
  n1 &lt;- ceiling(n/2)
  n2 &lt;- floor(n/2)
  y1 &lt;- y[1:n1]
  y2 &lt;- y[(n1+1):(n1+n2)]
  eta1 &lt;- eta[1]
  eta2 &lt;- eta[2]
  sum(y1) * eta1 - (length(y1) + 1) * exp(eta1) - sum(lgamma(y1+1)) + eta1 +
    sum(y2) * eta2 - (length(y2) + 1) * exp(eta2) - sum(lgamma(y2+1)) + eta2
}
set.seed(84343124)
n1 &lt;- 5
n2 &lt;- 5
n &lt;- n1+n2
y1 &lt;- rpois(n1,5)
y2 &lt;- rpois(n2,5)
objfunc2d &lt;- function(x) logfteta2d(x,c(y1,y2))
funlist2d &lt;- list(
  fn = objfunc2d,
  gr = function(x) numDeriv::grad(objfunc2d,x),
  he = function(x) numDeriv::hessian(objfunc2d,x)
)

thequadrature &lt;- aghq(funlist2d,3,c(0,0))
# Summarize and automatically call its print() method when called interactively:
summary(thequadrature)

</code></pre>

<hr>
<h2 id='print.laplace'>Print method for AGHQ objects</h2><span id='topic+print.laplace'></span>

<h3>Description</h3>

<p>Pretty print the object&ndash; just gives some basic information and then suggests
the user call <code>summary(...)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'laplace'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.laplace_+3A_x">x</code></td>
<td>
<p>An object of class <code>aghq</code>.</p>
</td></tr>
<tr><td><code id="print.laplace_+3A_...">...</code></td>
<td>
<p>not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Silently prints summary information.
</p>


<h3>See Also</h3>

<p>Other quadrature: 
<code><a href="#topic+aghq">aghq</a>()</code>,
<code><a href="#topic+get_hessian">get_hessian</a>()</code>,
<code><a href="#topic+get_log_normconst">get_log_normconst</a>()</code>,
<code><a href="#topic+get_mode">get_mode</a>()</code>,
<code><a href="#topic+get_nodesandweights">get_nodesandweights</a>()</code>,
<code><a href="#topic+get_numquadpoints">get_numquadpoints</a>()</code>,
<code><a href="#topic+get_opt_results">get_opt_results</a>()</code>,
<code><a href="#topic+get_param_dim">get_param_dim</a>()</code>,
<code><a href="#topic+laplace_approximation">laplace_approximation</a>()</code>,
<code><a href="#topic+marginal_laplace_tmb">marginal_laplace_tmb</a>()</code>,
<code><a href="#topic+marginal_laplace">marginal_laplace</a>()</code>,
<code><a href="#topic+nested_quadrature">nested_quadrature</a>()</code>,
<code><a href="#topic+normalize_logpost">normalize_logpost</a>()</code>,
<code><a href="#topic+optimize_theta">optimize_theta</a>()</code>,
<code><a href="#topic+plot.aghq">plot.aghq</a>()</code>,
<code><a href="#topic+print.aghqsummary">print.aghqsummary</a>()</code>,
<code><a href="#topic+print.aghq">print.aghq</a>()</code>,
<code><a href="#topic+print.laplacesummary">print.laplacesummary</a>()</code>,
<code><a href="#topic+print.marginallaplacesummary">print.marginallaplacesummary</a>()</code>,
<code><a href="#topic+summary.aghq">summary.aghq</a>()</code>,
<code><a href="#topic+summary.laplace">summary.laplace</a>()</code>,
<code><a href="#topic+summary.marginallaplace">summary.marginallaplace</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
logfteta2d &lt;- function(eta,y) {
  # eta is now (eta1,eta2)
  # y is now (y1,y2)
  n &lt;- length(y)
  n1 &lt;- ceiling(n/2)
  n2 &lt;- floor(n/2)
  y1 &lt;- y[1:n1]
  y2 &lt;- y[(n1+1):(n1+n2)]
  eta1 &lt;- eta[1]
  eta2 &lt;- eta[2]
  sum(y1) * eta1 - (length(y1) + 1) * exp(eta1) - sum(lgamma(y1+1)) + eta1 +
    sum(y2) * eta2 - (length(y2) + 1) * exp(eta2) - sum(lgamma(y2+1)) + eta2
}
set.seed(84343124)
n1 &lt;- 5
n2 &lt;- 5
n &lt;- n1+n2
y1 &lt;- rpois(n1,5)
y2 &lt;- rpois(n2,5)
objfunc2d &lt;- function(x) logfteta2d(x,c(y1,y2))
funlist2d &lt;- list(
  fn = objfunc2d,
  gr = function(x) numDeriv::grad(objfunc2d,x),
  he = function(x) numDeriv::hessian(objfunc2d,x)
)

thequadrature &lt;- aghq(funlist2d,3,c(0,0))
thequadrature

</code></pre>

<hr>
<h2 id='print.laplacesummary'>Print method for laplacesummary objects</h2><span id='topic+print.laplacesummary'></span>

<h3>Description</h3>

<p>Print the summary of an <code>laplace</code> object. Almost always called by invoking
<code>summary(...)</code> interactively in the console.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'laplacesummary'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.laplacesummary_+3A_x">x</code></td>
<td>
<p>The result of calling <code>summary(...)</code> on an object of class <code>laplace</code>.</p>
</td></tr>
<tr><td><code id="print.laplacesummary_+3A_...">...</code></td>
<td>
<p>not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Silently prints summary information.
</p>


<h3>See Also</h3>

<p>Other quadrature: 
<code><a href="#topic+aghq">aghq</a>()</code>,
<code><a href="#topic+get_hessian">get_hessian</a>()</code>,
<code><a href="#topic+get_log_normconst">get_log_normconst</a>()</code>,
<code><a href="#topic+get_mode">get_mode</a>()</code>,
<code><a href="#topic+get_nodesandweights">get_nodesandweights</a>()</code>,
<code><a href="#topic+get_numquadpoints">get_numquadpoints</a>()</code>,
<code><a href="#topic+get_opt_results">get_opt_results</a>()</code>,
<code><a href="#topic+get_param_dim">get_param_dim</a>()</code>,
<code><a href="#topic+laplace_approximation">laplace_approximation</a>()</code>,
<code><a href="#topic+marginal_laplace_tmb">marginal_laplace_tmb</a>()</code>,
<code><a href="#topic+marginal_laplace">marginal_laplace</a>()</code>,
<code><a href="#topic+nested_quadrature">nested_quadrature</a>()</code>,
<code><a href="#topic+normalize_logpost">normalize_logpost</a>()</code>,
<code><a href="#topic+optimize_theta">optimize_theta</a>()</code>,
<code><a href="#topic+plot.aghq">plot.aghq</a>()</code>,
<code><a href="#topic+print.aghqsummary">print.aghqsummary</a>()</code>,
<code><a href="#topic+print.aghq">print.aghq</a>()</code>,
<code><a href="#topic+print.laplace">print.laplace</a>()</code>,
<code><a href="#topic+print.marginallaplacesummary">print.marginallaplacesummary</a>()</code>,
<code><a href="#topic+summary.aghq">summary.aghq</a>()</code>,
<code><a href="#topic+summary.laplace">summary.laplace</a>()</code>,
<code><a href="#topic+summary.marginallaplace">summary.marginallaplace</a>()</code>
</p>
<p>Other quadrature: 
<code><a href="#topic+aghq">aghq</a>()</code>,
<code><a href="#topic+get_hessian">get_hessian</a>()</code>,
<code><a href="#topic+get_log_normconst">get_log_normconst</a>()</code>,
<code><a href="#topic+get_mode">get_mode</a>()</code>,
<code><a href="#topic+get_nodesandweights">get_nodesandweights</a>()</code>,
<code><a href="#topic+get_numquadpoints">get_numquadpoints</a>()</code>,
<code><a href="#topic+get_opt_results">get_opt_results</a>()</code>,
<code><a href="#topic+get_param_dim">get_param_dim</a>()</code>,
<code><a href="#topic+laplace_approximation">laplace_approximation</a>()</code>,
<code><a href="#topic+marginal_laplace_tmb">marginal_laplace_tmb</a>()</code>,
<code><a href="#topic+marginal_laplace">marginal_laplace</a>()</code>,
<code><a href="#topic+nested_quadrature">nested_quadrature</a>()</code>,
<code><a href="#topic+normalize_logpost">normalize_logpost</a>()</code>,
<code><a href="#topic+optimize_theta">optimize_theta</a>()</code>,
<code><a href="#topic+plot.aghq">plot.aghq</a>()</code>,
<code><a href="#topic+print.aghqsummary">print.aghqsummary</a>()</code>,
<code><a href="#topic+print.aghq">print.aghq</a>()</code>,
<code><a href="#topic+print.laplace">print.laplace</a>()</code>,
<code><a href="#topic+print.marginallaplacesummary">print.marginallaplacesummary</a>()</code>,
<code><a href="#topic+summary.aghq">summary.aghq</a>()</code>,
<code><a href="#topic+summary.laplace">summary.laplace</a>()</code>,
<code><a href="#topic+summary.marginallaplace">summary.marginallaplace</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
logfteta2d &lt;- function(eta,y) {
  # eta is now (eta1,eta2)
  # y is now (y1,y2)
  n &lt;- length(y)
  n1 &lt;- ceiling(n/2)
  n2 &lt;- floor(n/2)
  y1 &lt;- y[1:n1]
  y2 &lt;- y[(n1+1):(n1+n2)]
  eta1 &lt;- eta[1]
  eta2 &lt;- eta[2]
  sum(y1) * eta1 - (length(y1) + 1) * exp(eta1) - sum(lgamma(y1+1)) + eta1 +
    sum(y2) * eta2 - (length(y2) + 1) * exp(eta2) - sum(lgamma(y2+1)) + eta2
}
set.seed(84343124)
n1 &lt;- 5
n2 &lt;- 5
n &lt;- n1+n2
y1 &lt;- rpois(n1,5)
y2 &lt;- rpois(n2,5)
objfunc2d &lt;- function(x) logfteta2d(x,c(y1,y2))
funlist2d &lt;- list(
  fn = objfunc2d,
  gr = function(x) numDeriv::grad(objfunc2d,x),
  he = function(x) numDeriv::hessian(objfunc2d,x)
)

thelaplace &lt;- laplace_approximation(funlist2d,c(0,0))
# Summarize and automatically call its print() method when called interactively:
summary(thelaplace)

</code></pre>

<hr>
<h2 id='print.marginallaplacesummary'>Summary statistics for models using marginal Laplace approximations</h2><span id='topic+print.marginallaplacesummary'></span>

<h3>Description</h3>

<p>The <code>summary.marginallaplace</code> calls <code>summary.aghq</code>, but also computes
summary statistics of the random effects, by drawing from their approximate
posterior using <code>aghq::sample_marginal</code> with the specified number
of samples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'marginallaplacesummary'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.marginallaplacesummary_+3A_x">x</code></td>
<td>
<p>Object of class <code>marginallaplacesummary</code> returned by calling
<code>summary</code> on an object of class <code>marginallaplace</code>.</p>
</td></tr>
<tr><td><code id="print.marginallaplacesummary_+3A_...">...</code></td>
<td>
<p>not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Nothing. Prints contents.
</p>


<h3>See Also</h3>

<p>Other quadrature: 
<code><a href="#topic+aghq">aghq</a>()</code>,
<code><a href="#topic+get_hessian">get_hessian</a>()</code>,
<code><a href="#topic+get_log_normconst">get_log_normconst</a>()</code>,
<code><a href="#topic+get_mode">get_mode</a>()</code>,
<code><a href="#topic+get_nodesandweights">get_nodesandweights</a>()</code>,
<code><a href="#topic+get_numquadpoints">get_numquadpoints</a>()</code>,
<code><a href="#topic+get_opt_results">get_opt_results</a>()</code>,
<code><a href="#topic+get_param_dim">get_param_dim</a>()</code>,
<code><a href="#topic+laplace_approximation">laplace_approximation</a>()</code>,
<code><a href="#topic+marginal_laplace_tmb">marginal_laplace_tmb</a>()</code>,
<code><a href="#topic+marginal_laplace">marginal_laplace</a>()</code>,
<code><a href="#topic+nested_quadrature">nested_quadrature</a>()</code>,
<code><a href="#topic+normalize_logpost">normalize_logpost</a>()</code>,
<code><a href="#topic+optimize_theta">optimize_theta</a>()</code>,
<code><a href="#topic+plot.aghq">plot.aghq</a>()</code>,
<code><a href="#topic+print.aghqsummary">print.aghqsummary</a>()</code>,
<code><a href="#topic+print.aghq">print.aghq</a>()</code>,
<code><a href="#topic+print.laplacesummary">print.laplacesummary</a>()</code>,
<code><a href="#topic+print.laplace">print.laplace</a>()</code>,
<code><a href="#topic+summary.aghq">summary.aghq</a>()</code>,
<code><a href="#topic+summary.laplace">summary.laplace</a>()</code>,
<code><a href="#topic+summary.marginallaplace">summary.marginallaplace</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>logfteta2d &lt;- function(eta,y) {
  # eta is now (eta1,eta2)
  # y is now (y1,y2)
  n &lt;- length(y)
  n1 &lt;- ceiling(n/2)
  n2 &lt;- floor(n/2)
  y1 &lt;- y[1:n1]
  y2 &lt;- y[(n1+1):(n1+n2)]
  eta1 &lt;- eta[1]
  eta2 &lt;- eta[2]
  sum(y1) * eta1 - (length(y1) + 1) * exp(eta1) - sum(lgamma(y1+1)) + eta1 +
    sum(y2) * eta2 - (length(y2) + 1) * exp(eta2) - sum(lgamma(y2+1)) + eta2
}
set.seed(84343124)
n1 &lt;- 5
n2 &lt;- 5
n &lt;- n1+n2
y1 &lt;- rpois(n1,5)
y2 &lt;- rpois(n2,5)
objfunc2d &lt;- function(x) logfteta2d(x,c(y1,y2))
objfunc2dmarg &lt;- function(W,theta) objfunc2d(c(W,theta))
objfunc2dmarggr &lt;- function(W,theta) {
  fn &lt;- function(W) objfunc2dmarg(W,theta)
  numDeriv::grad(fn,W)
}
objfunc2dmarghe &lt;- function(W,theta) {
  fn &lt;- function(W) objfunc2dmarg(W,theta)
  numDeriv::hessian(fn,W)
}

funlist2dmarg &lt;- list(
  fn = objfunc2dmarg,
  gr = objfunc2dmarggr,
  he = objfunc2dmarghe
)

themarginallaplace &lt;- aghq::marginal_laplace(funlist2dmarg,3,list(W = 0,theta = 0))
summary(themarginallaplace)
</code></pre>

<hr>
<h2 id='sample_marginal'>Exact independent samples from an approximate posterior distribution</h2><span id='topic+sample_marginal'></span><span id='topic+sample_marginal.aghq'></span><span id='topic+sample_marginal.marginallaplace'></span>

<h3>Description</h3>

<p>Draws samples from an approximate marginal distribution for general posteriors
approximated using <code>aghq</code>, or from the mixture-of-Gaussians approximation to the variables that were
marginalized over in a marginal Laplace approximation fit using <code>aghq::marginal_laplace</code>
or <code>aghq::marginal_laplace_tmb</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sample_marginal(
  quad,
  M,
  transformation = default_transformation(),
  interpolation = "auto",
  ...
)

## S3 method for class 'aghq'
sample_marginal(
  quad,
  M,
  transformation = quad$transformation,
  interpolation = "auto",
  ...
)

## S3 method for class 'marginallaplace'
sample_marginal(
  quad,
  M,
  transformation = quad$transformation,
  interpolation = "auto",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sample_marginal_+3A_quad">quad</code></td>
<td>
<p>Object from which to draw samples.
An object inheriting from class <code>marginallaplace</code>
(the result of running <code>aghq::marginal_laplace</code> or <code>aghq::marginal_laplace_tmb</code>),
or an object inheriting from class <code>aghq</code> (the result of running <code>aghq::aghq()</code>).
Can also provide a <code>data.frame</code> returned by <code>aghq::compute_pdf_and_cdf</code> in which
case samples are returned for <code>transparam</code> if <code>transformation</code> is provided,
and for <code>param</code> if <code>transformation = NULL</code>.</p>
</td></tr>
<tr><td><code id="sample_marginal_+3A_m">M</code></td>
<td>
<p>Numeric, integer saying how many samples to draw</p>
</td></tr>
<tr><td><code id="sample_marginal_+3A_transformation">transformation</code></td>
<td>
<p>Optional. Draw samples for a transformation of the parameter
whose posterior was normalized using adaptive quadrature.
<code>transformation</code> is either: a) an <code>aghqtrans</code> object returned by <code>aghq::make_transformation</code>,
or b) a list that will be passed to that function internally. See <code>?aghq::make_transformation</code> for details.</p>
</td></tr>
<tr><td><code id="sample_marginal_+3A_interpolation">interpolation</code></td>
<td>
<p>Which method to use for interpolating the marginal posteriors
(and hence to draw samples using the inverse CDF method), <code>'auto'</code> (choose for you), <code>'polynomial'</code>
or <code>'spline'</code>? If <code>k &gt; 3</code> then the polynomial may be unstable and you should use the spline, but the spline
doesn't work <em>unless</em> <code>k &gt; 3</code> so it's not the default. The default of <code>'auto'</code> figures this out for you.
See <code>interpolate_marginal_posterior()</code>.</p>
</td></tr>
<tr><td><code id="sample_marginal_+3A_...">...</code></td>
<td>
<p>Used to pass additional arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For objects of class <code>aghq</code> or their marginal distribution components,
sampling is done using the inverse CDF method, which is just <code>compute_quantiles(quad$marginals[[1]],runif(M))</code>.
</p>
<p>For marginal Laplace approximations (<code>aghq::marginal_laplace()</code>): this method samples from the posterior and returns a vector that is ordered
the same as the &quot;<code>W</code>&quot; variables in your marginal Laplace approximation. See Algorithm 1 in
Stringer et. al. (2021, https://arxiv.org/abs/2103.07425) for the algorithm; the details of sampling
from a Gaussian are described in the reference(s) therein, which makes use of the (sparse)
Cholesky factors. These are computed once for each quadrature point and stored.
</p>
<p>For the marginal Laplace approximations where the &quot;inner&quot; model is handled entirely by <code>TMB</code>
(<code>aghq::marginal_laplace_tmb</code>), the interface here is identical to above,
with the order of the &quot;<code>W</code>&quot; vector being determined by <code>TMB</code>. See the
<code>names</code> of <code>ff$env$last.par</code>, for example (where <code>ff</code> is your
template obtained from a call to <code>TMB::MakeADFun</code>.
</p>
<p>If <code>getOption('mc.cores',1L) &gt; 1</code>, the Cholesky decompositions of the Hessians are computed
in parallel using <code>parallel::mcapply</code>, for the Gaussian approximation involved for objects of class <code>marginallaplace</code>. This step is slow
so may be sped up by parallelization, if the matrices are sparse (and hence the operation is just slow, but not memory-intensive).
Uses the <code>parallel</code> package so is not available on Windows.
</p>


<h3>Value</h3>

<p>If run on a <code>marginallaplace</code> object, a list containing elements:
</p>

<ul>
<li><p><code>samps</code>:  <code>d x M</code> matrix where <code>d = dim(W)</code> and each column is a sample
from <code>pi(W|Y,theta)</code>
</p>
</li>
<li><p><code>theta</code>: <code>M x S</code> tibble where <code>S = dim(theta)</code> containing the value of <code>theta</code> for
each sample
</p>
</li>
<li><p><code>thetasamples</code>: A list of <code>S</code> numeric vectors each of length
<code>M</code> where the <code>j</code>th element is a sample from <code>pi(theta_{j}|Y)</code>. These are samples
from the <strong>marginals</strong>, NOT the <strong>joint</strong>. Sampling from the joint is a much more difficult
problem and how to do so in this context is an active area of research.
</p>
</li></ul>

<p>If run on an <code>aghq</code> object, then a list with just the <code>thetasamples</code> element. It still
returns a list to maintain output consistency across inputs.
</p>
<p>If, for some reason, you don't want to do the sampling from <code>pi(theta|Y)</code>, you can manually
set <code>quad$marginals = NULL</code>. Note that this sampling is typically <em>very</em> fast
and so I don't know why you would need to not do it but the option is there if you like.
</p>
<p>If, again for some reason, you just want samples from one marginal distribution using inverse CDF,
you can just do <code>compute_quantiles(quad$marginals[[1]],runif(M))</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>logfteta2d &lt;- function(eta,y) {
  # eta is now (eta1,eta2)
  # y is now (y1,y2)
  n &lt;- length(y)
  n1 &lt;- ceiling(n/2)
  n2 &lt;- floor(n/2)
  y1 &lt;- y[1:n1]
  y2 &lt;- y[(n1+1):(n1+n2)]
  eta1 &lt;- eta[1]
  eta2 &lt;- eta[2]
  sum(y1) * eta1 - (length(y1) + 1) * exp(eta1) - sum(lgamma(y1+1)) + eta1 +
    sum(y2) * eta2 - (length(y2) + 1) * exp(eta2) - sum(lgamma(y2+1)) + eta2
}
set.seed(84343124)
n1 &lt;- 5
n2 &lt;- 5
n &lt;- n1+n2
y1 &lt;- rpois(n1,5)
y2 &lt;- rpois(n2,5)
objfunc2d &lt;- function(x) logfteta2d(x,c(y1,y2))
objfunc2dmarg &lt;- function(W,theta) objfunc2d(c(W,theta))
objfunc2dmarggr &lt;- function(W,theta) {
  fn &lt;- function(W) objfunc2dmarg(W,theta)
  numDeriv::grad(fn,W)
}
objfunc2dmarghe &lt;- function(W,theta) {
  fn &lt;- function(W) objfunc2dmarg(W,theta)
  numDeriv::hessian(fn,W)
}

funlist2dmarg &lt;- list(
  fn = objfunc2dmarg,
  gr = objfunc2dmarggr,
  he = objfunc2dmarghe
)

</code></pre>

<hr>
<h2 id='summary.aghq'>Summary statistics computed using AGHQ</h2><span id='topic+summary.aghq'></span>

<h3>Description</h3>

<p>The <code>summary.aghq</code> method computes means, standard deviations, and
quantiles of the transformed parameter.
The associated print method
prints these along with diagnostic and other information about
the quadrature.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'aghq'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.aghq_+3A_object">object</code></td>
<td>
<p>The return value from <code>aghq::aghq</code>. Summaries are computed for
<code>object$transformation$fromtheta(theta)</code>.</p>
</td></tr>
<tr><td><code id="summary.aghq_+3A_...">...</code></td>
<td>
<p>not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of class <code>aghqsummary</code>, which has a print method. Elements:
</p>

<ul>
<li><p>mode: the mode of the log posterior
</p>
</li>
<li><p>hessian: the hessian of the log posterior at the mode
</p>
</li>
<li><p>covariance: the inverse of the hessian of the log posterior at the mode
</p>
</li>
<li><p>cholesky: the upper Cholesky triangle of the hessian of the log posterior at the mode
</p>
</li>
<li><p>quadpoints: the number of quadrature points used in each dimension
</p>
</li>
<li><p>dim: the dimension of the parameter space
</p>
</li>
<li><p>summarytable: a table containing the mean, median, mode, standard deviation
and quantiles of each transformed parameter, computed according to the posterior normalized
using AGHQ
</p>
</li></ul>



<h3>See Also</h3>

<p>Other quadrature: 
<code><a href="#topic+aghq">aghq</a>()</code>,
<code><a href="#topic+get_hessian">get_hessian</a>()</code>,
<code><a href="#topic+get_log_normconst">get_log_normconst</a>()</code>,
<code><a href="#topic+get_mode">get_mode</a>()</code>,
<code><a href="#topic+get_nodesandweights">get_nodesandweights</a>()</code>,
<code><a href="#topic+get_numquadpoints">get_numquadpoints</a>()</code>,
<code><a href="#topic+get_opt_results">get_opt_results</a>()</code>,
<code><a href="#topic+get_param_dim">get_param_dim</a>()</code>,
<code><a href="#topic+laplace_approximation">laplace_approximation</a>()</code>,
<code><a href="#topic+marginal_laplace_tmb">marginal_laplace_tmb</a>()</code>,
<code><a href="#topic+marginal_laplace">marginal_laplace</a>()</code>,
<code><a href="#topic+nested_quadrature">nested_quadrature</a>()</code>,
<code><a href="#topic+normalize_logpost">normalize_logpost</a>()</code>,
<code><a href="#topic+optimize_theta">optimize_theta</a>()</code>,
<code><a href="#topic+plot.aghq">plot.aghq</a>()</code>,
<code><a href="#topic+print.aghqsummary">print.aghqsummary</a>()</code>,
<code><a href="#topic+print.aghq">print.aghq</a>()</code>,
<code><a href="#topic+print.laplacesummary">print.laplacesummary</a>()</code>,
<code><a href="#topic+print.laplace">print.laplace</a>()</code>,
<code><a href="#topic+print.marginallaplacesummary">print.marginallaplacesummary</a>()</code>,
<code><a href="#topic+summary.laplace">summary.laplace</a>()</code>,
<code><a href="#topic+summary.marginallaplace">summary.marginallaplace</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
logfteta2d &lt;- function(eta,y) {
  # eta is now (eta1,eta2)
  # y is now (y1,y2)
  n &lt;- length(y)
  n1 &lt;- ceiling(n/2)
  n2 &lt;- floor(n/2)
  y1 &lt;- y[1:n1]
  y2 &lt;- y[(n1+1):(n1+n2)]
  eta1 &lt;- eta[1]
  eta2 &lt;- eta[2]
  sum(y1) * eta1 - (length(y1) + 1) * exp(eta1) - sum(lgamma(y1+1)) + eta1 +
    sum(y2) * eta2 - (length(y2) + 1) * exp(eta2) - sum(lgamma(y2+1)) + eta2
}
set.seed(84343124)
n1 &lt;- 5
n2 &lt;- 5
n &lt;- n1+n2
y1 &lt;- rpois(n1,5)
y2 &lt;- rpois(n2,5)
objfunc2d &lt;- function(x) logfteta2d(x,c(y1,y2))
funlist2d &lt;- list(
  fn = objfunc2d,
  gr = function(x) numDeriv::grad(objfunc2d,x),
  he = function(x) numDeriv::hessian(objfunc2d,x)
)

thequadrature &lt;- aghq(funlist2d,3,c(0,0))
# Summarize and automatically call its print() method when called interactively:
summary(thequadrature)
# or, compute the summary and save for further processing:
ss &lt;- summary(thequadrature)
str(ss)

</code></pre>

<hr>
<h2 id='summary.laplace'>Summary method for Laplace Approximation objects</h2><span id='topic+summary.laplace'></span>

<h3>Description</h3>

<p>Summary method for objects of class <code>laplace</code>. Similar
to the method for objects of class <code>aghq</code>, but assumes the
problem is high-dimensional and does not compute or
print any large objects or summaries. See <code>summary.aghq</code> for
further information.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'laplace'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.laplace_+3A_object">object</code></td>
<td>
<p>An object of class <code>laplace</code>.</p>
</td></tr>
<tr><td><code id="summary.laplace_+3A_...">...</code></td>
<td>
<p>not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Silently prints summary information.
</p>


<h3>See Also</h3>

<p>Other quadrature: 
<code><a href="#topic+aghq">aghq</a>()</code>,
<code><a href="#topic+get_hessian">get_hessian</a>()</code>,
<code><a href="#topic+get_log_normconst">get_log_normconst</a>()</code>,
<code><a href="#topic+get_mode">get_mode</a>()</code>,
<code><a href="#topic+get_nodesandweights">get_nodesandweights</a>()</code>,
<code><a href="#topic+get_numquadpoints">get_numquadpoints</a>()</code>,
<code><a href="#topic+get_opt_results">get_opt_results</a>()</code>,
<code><a href="#topic+get_param_dim">get_param_dim</a>()</code>,
<code><a href="#topic+laplace_approximation">laplace_approximation</a>()</code>,
<code><a href="#topic+marginal_laplace_tmb">marginal_laplace_tmb</a>()</code>,
<code><a href="#topic+marginal_laplace">marginal_laplace</a>()</code>,
<code><a href="#topic+nested_quadrature">nested_quadrature</a>()</code>,
<code><a href="#topic+normalize_logpost">normalize_logpost</a>()</code>,
<code><a href="#topic+optimize_theta">optimize_theta</a>()</code>,
<code><a href="#topic+plot.aghq">plot.aghq</a>()</code>,
<code><a href="#topic+print.aghqsummary">print.aghqsummary</a>()</code>,
<code><a href="#topic+print.aghq">print.aghq</a>()</code>,
<code><a href="#topic+print.laplacesummary">print.laplacesummary</a>()</code>,
<code><a href="#topic+print.laplace">print.laplace</a>()</code>,
<code><a href="#topic+print.marginallaplacesummary">print.marginallaplacesummary</a>()</code>,
<code><a href="#topic+summary.aghq">summary.aghq</a>()</code>,
<code><a href="#topic+summary.marginallaplace">summary.marginallaplace</a>()</code>
</p>
<p>Other quadrature: 
<code><a href="#topic+aghq">aghq</a>()</code>,
<code><a href="#topic+get_hessian">get_hessian</a>()</code>,
<code><a href="#topic+get_log_normconst">get_log_normconst</a>()</code>,
<code><a href="#topic+get_mode">get_mode</a>()</code>,
<code><a href="#topic+get_nodesandweights">get_nodesandweights</a>()</code>,
<code><a href="#topic+get_numquadpoints">get_numquadpoints</a>()</code>,
<code><a href="#topic+get_opt_results">get_opt_results</a>()</code>,
<code><a href="#topic+get_param_dim">get_param_dim</a>()</code>,
<code><a href="#topic+laplace_approximation">laplace_approximation</a>()</code>,
<code><a href="#topic+marginal_laplace_tmb">marginal_laplace_tmb</a>()</code>,
<code><a href="#topic+marginal_laplace">marginal_laplace</a>()</code>,
<code><a href="#topic+nested_quadrature">nested_quadrature</a>()</code>,
<code><a href="#topic+normalize_logpost">normalize_logpost</a>()</code>,
<code><a href="#topic+optimize_theta">optimize_theta</a>()</code>,
<code><a href="#topic+plot.aghq">plot.aghq</a>()</code>,
<code><a href="#topic+print.aghqsummary">print.aghqsummary</a>()</code>,
<code><a href="#topic+print.aghq">print.aghq</a>()</code>,
<code><a href="#topic+print.laplacesummary">print.laplacesummary</a>()</code>,
<code><a href="#topic+print.laplace">print.laplace</a>()</code>,
<code><a href="#topic+print.marginallaplacesummary">print.marginallaplacesummary</a>()</code>,
<code><a href="#topic+summary.aghq">summary.aghq</a>()</code>,
<code><a href="#topic+summary.marginallaplace">summary.marginallaplace</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
logfteta2d &lt;- function(eta,y) {
  # eta is now (eta1,eta2)
  # y is now (y1,y2)
  n &lt;- length(y)
  n1 &lt;- ceiling(n/2)
  n2 &lt;- floor(n/2)
  y1 &lt;- y[1:n1]
  y2 &lt;- y[(n1+1):(n1+n2)]
  eta1 &lt;- eta[1]
  eta2 &lt;- eta[2]
  sum(y1) * eta1 - (length(y1) + 1) * exp(eta1) - sum(lgamma(y1+1)) + eta1 +
    sum(y2) * eta2 - (length(y2) + 1) * exp(eta2) - sum(lgamma(y2+1)) + eta2
}
set.seed(84343124)
n1 &lt;- 5
n2 &lt;- 5
n &lt;- n1+n2
y1 &lt;- rpois(n1,5)
y2 &lt;- rpois(n2,5)
objfunc2d &lt;- function(x) logfteta2d(x,c(y1,y2))
funlist2d &lt;- list(
  fn = objfunc2d,
  gr = function(x) numDeriv::grad(objfunc2d,x),
  he = function(x) numDeriv::hessian(objfunc2d,x)
)

thelaplace &lt;- laplace_approximation(funlist2d,c(0,0))
# Summarize and automatically call its print() method when called interactively:
summary(thelaplace)

</code></pre>

<hr>
<h2 id='summary.marginallaplace'>Summary statistics for models using marginal Laplace approximations</h2><span id='topic+summary.marginallaplace'></span>

<h3>Description</h3>

<p>The <code>summary.marginallaplace</code> calls <code>summary.aghq</code>, but also computes
summary statistics of the random effects, by drawing from their approximate
posterior using <code>aghq::sample_marginal</code> with the specified number
of samples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'marginallaplace'
summary(object, M = 1000, max_print = 30, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.marginallaplace_+3A_object">object</code></td>
<td>
<p>Object inheriting from <strong>both</strong> classes <code>aghq</code> and <code>marginallaplace</code>,
for example as returned by <code>aghq::marginal_laplace</code> or <code>aghq::marginal_laplace_tmb</code>.</p>
</td></tr>
<tr><td><code id="summary.marginallaplace_+3A_m">M</code></td>
<td>
<p>Number of samples to use to compute summary statistics of the random effects.
Default <code>1000</code>. Lower runs faster, higher is more accurate.</p>
</td></tr>
<tr><td><code id="summary.marginallaplace_+3A_max_print">max_print</code></td>
<td>
<p>Sometimes there are a lot of random effects. If there are more random
effects than <code>max_print</code>, the random effects aren't summarized, and a note is printed
to this effect. Default <code>30</code>.</p>
</td></tr>
<tr><td><code id="summary.marginallaplace_+3A_...">...</code></td>
<td>
<p>not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing an object of class <code>aghqsummary</code> (see <code>summary.aghq</code>).
</p>


<h3>See Also</h3>

<p>Other quadrature: 
<code><a href="#topic+aghq">aghq</a>()</code>,
<code><a href="#topic+get_hessian">get_hessian</a>()</code>,
<code><a href="#topic+get_log_normconst">get_log_normconst</a>()</code>,
<code><a href="#topic+get_mode">get_mode</a>()</code>,
<code><a href="#topic+get_nodesandweights">get_nodesandweights</a>()</code>,
<code><a href="#topic+get_numquadpoints">get_numquadpoints</a>()</code>,
<code><a href="#topic+get_opt_results">get_opt_results</a>()</code>,
<code><a href="#topic+get_param_dim">get_param_dim</a>()</code>,
<code><a href="#topic+laplace_approximation">laplace_approximation</a>()</code>,
<code><a href="#topic+marginal_laplace_tmb">marginal_laplace_tmb</a>()</code>,
<code><a href="#topic+marginal_laplace">marginal_laplace</a>()</code>,
<code><a href="#topic+nested_quadrature">nested_quadrature</a>()</code>,
<code><a href="#topic+normalize_logpost">normalize_logpost</a>()</code>,
<code><a href="#topic+optimize_theta">optimize_theta</a>()</code>,
<code><a href="#topic+plot.aghq">plot.aghq</a>()</code>,
<code><a href="#topic+print.aghqsummary">print.aghqsummary</a>()</code>,
<code><a href="#topic+print.aghq">print.aghq</a>()</code>,
<code><a href="#topic+print.laplacesummary">print.laplacesummary</a>()</code>,
<code><a href="#topic+print.laplace">print.laplace</a>()</code>,
<code><a href="#topic+print.marginallaplacesummary">print.marginallaplacesummary</a>()</code>,
<code><a href="#topic+summary.aghq">summary.aghq</a>()</code>,
<code><a href="#topic+summary.laplace">summary.laplace</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>logfteta2d &lt;- function(eta,y) {
  # eta is now (eta1,eta2)
  # y is now (y1,y2)
  n &lt;- length(y)
  n1 &lt;- ceiling(n/2)
  n2 &lt;- floor(n/2)
  y1 &lt;- y[1:n1]
  y2 &lt;- y[(n1+1):(n1+n2)]
  eta1 &lt;- eta[1]
  eta2 &lt;- eta[2]
  sum(y1) * eta1 - (length(y1) + 1) * exp(eta1) - sum(lgamma(y1+1)) + eta1 +
    sum(y2) * eta2 - (length(y2) + 1) * exp(eta2) - sum(lgamma(y2+1)) + eta2
}
set.seed(84343124)
n1 &lt;- 5
n2 &lt;- 5
n &lt;- n1+n2
y1 &lt;- rpois(n1,5)
y2 &lt;- rpois(n2,5)
objfunc2d &lt;- function(x) logfteta2d(x,c(y1,y2))
objfunc2dmarg &lt;- function(W,theta) objfunc2d(c(W,theta))
objfunc2dmarggr &lt;- function(W,theta) {
  fn &lt;- function(W) objfunc2dmarg(W,theta)
  numDeriv::grad(fn,W)
}
objfunc2dmarghe &lt;- function(W,theta) {
  fn &lt;- function(W) objfunc2dmarg(W,theta)
  numDeriv::hessian(fn,W)
}

funlist2dmarg &lt;- list(
  fn = objfunc2dmarg,
  gr = objfunc2dmarggr,
  he = objfunc2dmarghe
)

themarginallaplace &lt;- aghq::marginal_laplace(funlist2dmarg,3,list(W = 0,theta = 0))
summary(themarginallaplace)
</code></pre>

<hr>
<h2 id='validate_control'>Validate a control list</h2><span id='topic+validate_control'></span>

<h3>Description</h3>

<p>This function checks that the names and value types for a supplied <code>control</code> list
are valid and are unlikely to cause further errors within <code>aghq</code> and related functions.
Users should not have to worry about this and should just use <code>default_control()</code> and related
constructors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>validate_control(control, type = c("aghq", "marglaplace", "tmb"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="validate_control_+3A_control">control</code></td>
<td>
<p>A list.</p>
</td></tr>
<tr><td><code id="validate_control_+3A_type">type</code></td>
<td>
<p>One of <code>c('aghq','marglapace','tmb')</code>. The type of control object to validate. Will
basically validate against the arguments required by <code>aghq</code>, <code>marginal_laplace</code>, and <code>marginal_laplace_tmb</code>,
respectively.</p>
</td></tr>
<tr><td><code id="validate_control_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>To users reading this: just use <code>default_control()</code>, <code>default_control_marglaplace()</code>, or <code>default_control_tmb()</code>
as appropriate, to ensure that your control arguments are correct. This function just exists to provide more
descriptive error messages in the event that an incompatible list is provided.
</p>


<h3>Value</h3>

<p>Logical, <code>TRUE</code> if the list of control arguments is valid, else <code>FALSE</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>validate_control(default_control())
validate_control(default_control_marglaplace(),type = "marglaplace")
validate_control(default_control_tmb(),type = "tmb")

</code></pre>

<hr>
<h2 id='validate_moment'>Validate a moment function object</h2><span id='topic+validate_moment'></span><span id='topic+validate_moment.aghqmoment'></span><span id='topic+validate_moment.list'></span><span id='topic+validate_moment.function'></span><span id='topic+validate_moment.character'></span><span id='topic+validate_moment.default'></span>

<h3>Description</h3>

<p>Routine for checking whether a given moment function object is valid.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>validate_moment(...)

## S3 method for class 'aghqmoment'
validate_moment(moment, checkpositive = FALSE, ...)

## S3 method for class 'list'
validate_moment(moment, checkpositive = FALSE, ...)

## S3 method for class ''function''
validate_moment(moment, checkpositive = FALSE, ...)

## S3 method for class 'character'
validate_moment(moment, checkpositive = FALSE, ...)

## Default S3 method:
validate_moment(moment, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="validate_moment_+3A_...">...</code></td>
<td>
<p>Used to pass arguments to methods.</p>
</td></tr>
<tr><td><code id="validate_moment_+3A_moment">moment</code></td>
<td>
<p>An object to check if it is a valid moment function or not. Can be an object of class <code>aghqmoment</code> returned by <code>aghq::make_moment_function()</code>,
or any object that can be passed to <code>aghq::make_moment_function()</code>.</p>
</td></tr>
<tr><td><code id="validate_moment_+3A_checkpositive">checkpositive</code></td>
<td>
<p>Default <code>FALSE</code>, do not check that <code>gg$fn(theta) &gt; 0</code>. Otherwise,
a vector of values for which to perform that check. No default values are provided, since <code>validate_moment</code>
has no way of determining the domain and range of <code>gg$fn</code>. This argument is
used internally in <code>aghq</code> package functions, with cleverly chosen check values.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function checks that:
</p>

<ul>
<li><p>The supplied object contains elements <code>fn</code>, <code>gr</code>, and <code>he</code>, and that they are all functions,
</p>
</li>
<li><p>If <code>checkpositive</code> is a vector of numbers, then it checks that <code>gg$fn(checkpositive)</code> is not <code>-Inf</code>, <code>NA</code>, or <code>NaN</code>. (It actually uses <code>is.infinite</code> for the first.)
</p>
</li></ul>

<p>In addition, if a <code>list</code> is provided, the function first checks that it contains the right elements,
then passes it to <code>make_moment_function</code>, then checks that. If a <code>function</code> or a <code>character</code> is provided,
it checks that <code>match.fun</code> works, and returns any errors or warnings from doing so in a clear way.
</p>
<p>This function throws an informative error messages when checks don't pass or themselves throw errors.
</p>


<h3>Value</h3>

<p><code>TRUE</code> if the function runs to completion without throwing an error.
</p>


<h3>See Also</h3>

<p>Other moments: 
<code><a href="#topic+make_moment_function">make_moment_function</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
mom1 &lt;- make_moment_function(exp)
mom2 &lt;- make_moment_function('exp')
mom3 &lt;- make_moment_function(list(fn=function(x) x,gr=function(x) 1,he = function(x) 0))
validate_moment(mom1)
validate_moment(mom2)
validate_moment(mom3)
## Not run: 
mombad1 &lt;- list(exp,exp,exp) # No names
mombad2 &lt;- list('exp','exp','exp') # List of not functions
mombad3 &lt;- make_moment_function(function(x) -exp(x)) # Not positive
validate_moment(mombad1)
validate_moment(mombad2)
validate_moment(mombad3)

## End(Not run)
</code></pre>

<hr>
<h2 id='validate_transformation'>Validate a transformation object</h2><span id='topic+validate_transformation'></span><span id='topic+validate_transformation.aghqtrans'></span><span id='topic+validate_transformation.list'></span><span id='topic+validate_transformation.default'></span>

<h3>Description</h3>

<p>Routine for checking whether a given transformation is valid.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>validate_transformation(...)

## S3 method for class 'aghqtrans'
validate_transformation(trans, checkinverse = FALSE, ...)

## S3 method for class 'list'
validate_transformation(translist, checkinverse = FALSE, ...)

## Default S3 method:
validate_transformation(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="validate_transformation_+3A_...">...</code></td>
<td>
<p>Used to pass arguments to methods.</p>
</td></tr>
<tr><td><code id="validate_transformation_+3A_trans">trans</code></td>
<td>
<p>A transformation object of class <code>aghqtrans</code> returned by <code>make_transformation</code>.</p>
</td></tr>
<tr><td><code id="validate_transformation_+3A_checkinverse">checkinverse</code></td>
<td>
<p>Default <code>FALSE</code>, do not check that <code>totheta(fromtheta(theta)) = theta</code>. Otherwise,
a vector of values for which to perform that check. No default values are provided, since <code>validate_transformation</code>
has no way of determining the domain and range of <code>totheta</code> and <code>fromtheta</code>. This argument is
used internally in <code>aghq</code> package functions, with cleverly chosen check values.</p>
</td></tr>
<tr><td><code id="validate_transformation_+3A_translist">translist</code></td>
<td>
<p>A list. Will be checked, passed to <code>aghqtrans</code>, and then checked again.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function checks that:
</p>

<ul>
<li><p>The supplied object contains elements <code>totheta</code>, <code>fromtheta</code>, and <code>jacobian</code>, and that they are all functions,
</p>
</li>
<li><p>If <code>checkinverse</code> is a vector of numbers, then it checks that <code>totheta(fromtheta(checkinverse)) == checkinverse</code>.
</p>
</li></ul>

<p>In addition, if a <code>list</code> is provided, the function first checks that it contains the right elements,
then passes it to <code>make_transformation</code>, then checks that.
</p>
<p>This function throws an informative error messages when checks don't pass or themselves throw errors.
</p>


<h3>Value</h3>

<p><code>TRUE</code> if the function runs to completion without throwing an error.
</p>


<h3>See Also</h3>

<p>Other transformations: 
<code><a href="#topic+default_transformation">default_transformation</a>()</code>,
<code><a href="#topic+make_transformation">make_transformation</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
t &lt;- make_transformation(log,exp)
validate_transformation(t)
t2 &lt;- list(totheta = log,fromtheta = exp)
validate_transformation(t2)
## Not run: 
t3 &lt;- make_transformation(log,log)
checkvals &lt;- exp(exp(rnorm(10)))
# Should throw an informative error because log isn't the inverse of log.
validate_transformation(t3,checkinverse = checkvals)

## End(Not run)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
