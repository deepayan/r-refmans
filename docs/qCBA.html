<!DOCTYPE html><html><head><title>Help for package qCBA</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {qCBA}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#arulesCBA2arcCBAModel'><p>arulesCBA2arcCBAModel Converts a model created by <span class="pkg">arulesCBA</span> so that it can be passed to qCBA</p></a></li>
<li><a href='#customCBARuleModel-class'><p>rCBARuleModel</p></a></li>
<li><a href='#getConfVectorForROC'><p>Returns vector with confidences for the positive class (useful for ROC or AUC computation)</p></a></li>
<li><a href='#mapDataTypes'><p>Map R types to qCBA</p></a></li>
<li><a href='#predict.qCBARuleModel'><p>Aplies qCBARuleModel</p></a></li>
<li><a href='#qcba'><p>qCBA Quantitative CBA</p></a></li>
<li><a href='#qcbaHumTemp'><p>Use the HumTemp dataset to test the one rule classification QCBA workflow.</p></a></li>
<li><a href='#qcbaIris'><p>Use the iris dataset to the test QCBA workflow.</p></a></li>
<li><a href='#qcbaIris2'><p>Use the Iris dataset to test the experimental multi-rule QCBA workflow.</p></a></li>
<li><a href='#qCBARuleModel-class'><p>qCBARuleModel</p></a></li>
<li><a href='#rcbaModel2CBARuleModel'><p>rcbaModel2arcCBARuleModel Converts a model created by <span class="pkg">rCBA</span> so that it can be passed to qCBA</p></a></li>
<li><a href='#sbrlModel2arcCBARuleModel'><p>sbrlModel2arcCBARuleModel Converts a model created by <span class="pkg">sbrl</span> so that it can be passed to qCBA</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Quantitative Classification by Association Rules</td>
</tr>
<tr>
<td>Version:</td>
<td>0.5.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2020-11-18</td>
</tr>
<tr>
<td>Author:</td>
<td>Tomas Kliegr</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Tomas Kliegr &lt;kliegr@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>CBA postprocessing algorithm that creates smaller models for datasets containing quantitative (numerical) attributes. Article describing QCBA is published in Tomas Kliegr (2017) &lt;<a href="https://arxiv.org/abs/1711.10166">arXiv:1711.10166</a>&gt;. The package can also postprocess results of the SBRL package, which is no longer in CRAN, but can be obtained from <a href="https://github.com/cran/sbrl">https://github.com/cran/sbrl</a>.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.7.0), arules (&ge; 1.6-6), rJava (&ge; 0.5-0), arc (&ge;
1.2), methods</td>
</tr>
<tr>
<td>Suggests:</td>
<td>arulesCBA (&ge; 1.2.0), rCBA (&ge; 0.3.0), stringr</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>Java (&gt;= 8)</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/kliegr/QCBA">https://github.com/kliegr/QCBA</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/kliegr/QCBA/issues">https://github.com/kliegr/QCBA/issues</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.0.2</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2020-11-18 10:44:02 UTC; tomas</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2020-11-19 08:30:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='arulesCBA2arcCBAModel'>arulesCBA2arcCBAModel Converts a model created by <span class="pkg">arulesCBA</span> so that it can be passed to qCBA</h2><span id='topic+arulesCBA2arcCBAModel'></span>

<h3>Description</h3>

<p>Creates instance of arc CBAmodel class from the <span class="pkg">arc</span> package
Instance of CBAmodel can then be passed to <a href="#topic+qcba">qcba</a>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>arulesCBA2arcCBAModel(
  arulesCBAModel,
  cutPoints,
  rawDataset,
  classAtt,
  attTypes
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="arulesCBA2arcCBAModel_+3A_arulescbamodel">arulesCBAModel</code></td>
<td>
<p>aobject returned  by arulesCBA::CBA()</p>
</td></tr>
<tr><td><code id="arulesCBA2arcCBAModel_+3A_cutpoints">cutPoints</code></td>
<td>
<p>specification of cutpoints applied on the data before they were passed to <code>rCBA::build</code></p>
</td></tr>
<tr><td><code id="arulesCBA2arcCBAModel_+3A_rawdataset">rawDataset</code></td>
<td>
<p>the raw data (before discretization). This dataset is used to guess attribute types if attTypes is not passed</p>
</td></tr>
<tr><td><code id="arulesCBA2arcCBAModel_+3A_classatt">classAtt</code></td>
<td>
<p>the name of the class attribute</p>
</td></tr>
<tr><td><code id="arulesCBA2arcCBAModel_+3A_atttypes">attTypes</code></td>
<td>
<p>vector of attribute types of the original data.  If set to null, you need to pass rawDataset.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
if (! requireNamespace("arulesCBA", quietly = TRUE)) {
 message("Please install arulesCBA: install.packages('arulesCBA')")
}  else {
 message("The following code might cause the 'pruning exception' rCBA error on some installations")
 classAtt &lt;- "Species"
 discrModel &lt;- discrNumeric(iris, classAtt)
 irisDisc &lt;- as.data.frame(lapply(discrModel$Disc.data, as.factor))
 arulesCBAModel &lt;- arulesCBA::CBA(Species ~ ., data = irisDisc, supp = 0.1, 
  conf=0.9)
 CBAmodel &lt;- arulesCBA2arcCBAModel(arulesCBAModel, discrModel$cutp,  iris, classAtt)
 qCBAmodel &lt;- qcba(cbaRuleModel=CBAmodel,datadf=iris)
 print(qCBAmodel@rules)
 }


</code></pre>

<hr>
<h2 id='customCBARuleModel-class'>rCBARuleModel</h2><span id='topic+customCBARuleModel-class'></span><span id='topic+customCBARuleModel'></span>

<h3>Description</h3>

<p>This class represents an CBA rule-based classifier, where rules are represented as string vectors in a data frame
</p>


<h3>Slots</h3>


<dl>
<dt><code>rules</code></dt><dd><p>dataframe output by <span class="pkg">rCBA</span></p>
</dd>
<dt><code>cutp</code></dt><dd><p>list of cutpoints</p>
</dd>
<dt><code>classAtt</code></dt><dd><p>name of the target class attribute</p>
</dd>
<dt><code>attTypes</code></dt><dd><p>attribute types</p>
</dd>
</dl>

<hr>
<h2 id='getConfVectorForROC'>Returns vector with confidences for the positive class (useful for ROC or AUC computation)</h2><span id='topic+getConfVectorForROC'></span>

<h3>Description</h3>

<p>Methods for computing ROC curves require a vector of confidences
of the positive class, while in qCBA, the confidence returned by predict.qCBARuleModel with
outputProbabilies = TRUE returns confidence for the predicted class.
This method converts the values to confidences for the positive class
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getConfVectorForROC(confidences, predictedClass, positiveClass)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getConfVectorForROC_+3A_confidences">confidences</code></td>
<td>
<p>Vector of confidences</p>
</td></tr>
<tr><td><code id="getConfVectorForROC_+3A_predictedclass">predictedClass</code></td>
<td>
<p>Vector with predicted classes</p>
</td></tr>
<tr><td><code id="getConfVectorForROC_+3A_positiveclass">positiveClass</code></td>
<td>
<p>Positive class (String)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector of confidence values
</p>


<h3>Examples</h3>

<pre><code class='language-R'>predictedClass = c("setosa","virginica")
confidences = c(0.9,0.6)
baseClass="setosa"
getConfVectorForROC(confidences,predictedClass,baseClass)
</code></pre>

<hr>
<h2 id='mapDataTypes'>Map R types to qCBA</h2><span id='topic+mapDataTypes'></span>

<h3>Description</h3>

<p>The QCBA Java implementation uses different names of some data types than are used in this R wrapper.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mapDataTypes(Rtypes)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mapDataTypes_+3A_rtypes">Rtypes</code></td>
<td>
<p>Vector with R data types</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector with qCBA data types
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mapDataTypes(unname(sapply(iris, class)))
</code></pre>

<hr>
<h2 id='predict.qCBARuleModel'>Aplies qCBARuleModel</h2><span id='topic+predict.qCBARuleModel'></span>

<h3>Description</h3>

<p>Applies <a href="#topic+qcba">qcba</a> rule model on provided data. 
Automatically detects whether one-rule or  multi-rule classification is used
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'qCBARuleModel'
predict(
  object,
  newdata,
  testingType,
  loglevel = "WARNING",
  outputFiringRuleIDs = FALSE,
  outputConfidenceScores = FALSE,
  confScoreType = "ordered",
  positiveClass = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.qCBARuleModel_+3A_object">object</code></td>
<td>
<p><a href="#topic+qCBARuleModel">qCBARuleModel</a> class instance</p>
</td></tr>
<tr><td><code id="predict.qCBARuleModel_+3A_newdata">newdata</code></td>
<td>
<p>data frame with data</p>
</td></tr>
<tr><td><code id="predict.qCBARuleModel_+3A_testingtype">testingType</code></td>
<td>
<p>either <code>mixture</code> for multi-rule classification or <code>firstRule</code> for one-rule classification. Applicable only when model is loaded from file.</p>
</td></tr>
<tr><td><code id="predict.qCBARuleModel_+3A_loglevel">loglevel</code></td>
<td>
<p>logger level from <code>java.util.logging</code></p>
</td></tr>
<tr><td><code id="predict.qCBARuleModel_+3A_outputfiringruleids">outputFiringRuleIDs</code></td>
<td>
<p>if set to TRUE, instead of predictions, the function will return one-based IDs of  rules used to classify each instance (one rule per instance).</p>
</td></tr>
<tr><td><code id="predict.qCBARuleModel_+3A_outputconfidencescores">outputConfidenceScores</code></td>
<td>
<p>if set to TRUE, instead of predictions, the function will return confidences of the firing rule</p>
</td></tr>
<tr><td><code id="predict.qCBARuleModel_+3A_confscoretype">confScoreType</code></td>
<td>
<p>applicable only if 'outputConfidenceScores=TRUE', possible values 'ordered' for confidence computed only for training instances reaching this rule, or 'global' for standard rule confidence computed from the complete training data</p>
</td></tr>
<tr><td><code id="predict.qCBARuleModel_+3A_positiveclass">positiveClass</code></td>
<td>
<p>This setting is only used if 'outputConfidenceScores=TRUE'. It should be used only for binary problems. In this 
case, the confidence values are recalculated so that these are not confidence values of the predicted class (default behaviour of 'outputConfidenceScores=TRUE')
but rather confidence values associated with the class designated as positive</p>
</td></tr>
<tr><td><code id="predict.qCBARuleModel_+3A_...">...</code></td>
<td>
<p>other arguments (currently not used)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector with predictions.
</p>


<h3>See Also</h3>

<p><a href="#topic+qcba">qcba</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>allData &lt;- datasets::iris[sample(nrow(datasets::iris)),]
trainFold &lt;- allData[1:100,]
testFold &lt;- allData[101:nrow(datasets::iris),]
rmCBA &lt;- cba(trainFold, classAtt="Species")
rmqCBA &lt;- qcba(cbaRuleModel=rmCBA, datadf=trainFold)
print(rmqCBA@rules)
prediction &lt;- predict(rmqCBA,testFold)
acc &lt;- CBARuleModelAccuracy(prediction, testFold[[rmqCBA@classAtt]])
message(acc)
firingRuleIDs &lt;- predict(rmqCBA,testFold,outputFiringRuleIDs=TRUE)
message("The second instance in testFold was classified by the following rule")
message(rmqCBA@rules[firingRuleIDs[2],1])
message("The second instance is")
message(testFold[2,])

</code></pre>

<hr>
<h2 id='qcba'>qCBA Quantitative CBA</h2><span id='topic+qcba'></span>

<h3>Description</h3>

<p>Creates QCBA model by from a CBA rule model.
The default values are set so that the function postprocesses CBA models, reducing their size. 
The resulting model has the same structure as CBA model: it is composed of an ordered list of crisp conjunctive rules,  intended to be applied for one-rule classification.
The experimental <code>annotate</code> and <code>fuzzification</code> parameters will trigger more complex postprocessing of CBA models: 
rules will be annotated with probability distributions and optionally fuzzy borders. The intended use of such models is multi-rule classification.
The <a href="stats.html#topic+predict">predict</a> function automatically determines whether the input model is a CBA model or an annotated model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qcba(
  cbaRuleModel,
  datadf,
  extendType = "numericOnly",
  defaultRuleOverlapPruning = "transactionBased",
  attributePruning = TRUE,
  trim_literal_boundaries = TRUE,
  continuousPruning = FALSE,
  postpruning = "cba",
  fuzzification = FALSE,
  annotate = FALSE,
  ruleOutputPath,
  minImprovement = 0,
  minCondImprovement = -1,
  minConf = 0.5,
  extensionStrategy = "ConfImprovementAgainstLastConfirmedExtension",
  loglevel = "WARNING",
  createHistorySlot = FALSE,
  timeExecution = FALSE,
  computeOrderedStats = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="qcba_+3A_cbarulemodel">cbaRuleModel</code></td>
<td>
<p>a <a href="arc.html#topic+CBARuleModel">CBARuleModel</a></p>
</td></tr>
<tr><td><code id="qcba_+3A_datadf">datadf</code></td>
<td>
<p>data frame with training data</p>
</td></tr>
<tr><td><code id="qcba_+3A_extendtype">extendType</code></td>
<td>
<p>possible extend types - numericOnly or noExtend</p>
</td></tr>
<tr><td><code id="qcba_+3A_defaultruleoverlappruning">defaultRuleOverlapPruning</code></td>
<td>
<p>pruning removing rules made redundant by the default rule; possible values: <code>noPruning</code>, <code>transactionBased</code>, <code>rangeBased</code>, <code>transactionBasedAsFirstStep</code></p>
</td></tr>
<tr><td><code id="qcba_+3A_attributepruning">attributePruning</code></td>
<td>
<p>remove redundant attributes</p>
</td></tr>
<tr><td><code id="qcba_+3A_trim_literal_boundaries">trim_literal_boundaries</code></td>
<td>
<p>trimming of literal boundaries enabled</p>
</td></tr>
<tr><td><code id="qcba_+3A_continuouspruning">continuousPruning</code></td>
<td>
<p>indicating continuous pruning is enabled</p>
</td></tr>
<tr><td><code id="qcba_+3A_postpruning">postpruning</code></td>
<td>
<p>type of  postpruning (<code>none</code>, <code>cba</code> - data coverage pruning, <code>greedy</code> - data coverage pruning stopping on first rule with total error worse than default)</p>
</td></tr>
<tr><td><code id="qcba_+3A_fuzzification">fuzzification</code></td>
<td>
<p>boolean indicating if fuzzification is enabled. Multi-rule classification model is produced if enabled. Fuzzification without annotation is not supported.</p>
</td></tr>
<tr><td><code id="qcba_+3A_annotate">annotate</code></td>
<td>
<p>boolean indicating if annotation with probability distributions is enabled, multi-rule classification model is produced if enabled</p>
</td></tr>
<tr><td><code id="qcba_+3A_ruleoutputpath">ruleOutputPath</code></td>
<td>
<p>path of file to which model will be saved. Must be set if multi rule classification is produced.</p>
</td></tr>
<tr><td><code id="qcba_+3A_minimprovement">minImprovement</code></td>
<td>
<p>parameter of qCBA extend procedure  (used when  <code>extensionStrategy=ConfImprovementAgainstLastConfirmedExtension</code> or <code>ConfImprovementAgainstSeedRule</code>)</p>
</td></tr>
<tr><td><code id="qcba_+3A_mincondimprovement">minCondImprovement</code></td>
<td>
<p>parameter of qCBA extend procedure</p>
</td></tr>
<tr><td><code id="qcba_+3A_minconf">minConf</code></td>
<td>
<p>minimum confidence  to accept extension (used when  extensionStrategy=MinConf)</p>
</td></tr>
<tr><td><code id="qcba_+3A_extensionstrategy">extensionStrategy</code></td>
<td>
<p>possible values: <code>ConfImprovementAgainstLastConfirmedExtension</code>, <code>ConfImprovementAgainstSeedRule</code>,<code>MinConf</code></p>
</td></tr>
<tr><td><code id="qcba_+3A_loglevel">loglevel</code></td>
<td>
<p>logger level from <code>java.util.logging</code></p>
</td></tr>
<tr><td><code id="qcba_+3A_createhistoryslot">createHistorySlot</code></td>
<td>
<p>creates a history slot on the resulting <a href="#topic+qCBARuleModel">qCBARuleModel</a> model, which contains an ordered list of extensions
that were created on input rules during the extension process</p>
</td></tr>
<tr><td><code id="qcba_+3A_timeexecution">timeExecution</code></td>
<td>
<p>reports execution time of the extend step</p>
</td></tr>
<tr><td><code id="qcba_+3A_computeorderedstats">computeOrderedStats</code></td>
<td>
<p>appends orderedConf and orderedSupp quality metrics to the resulting dataframe. Setting this parameter to FALSE will reduce the training time.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Object of class <a href="#topic+qCBARuleModel">qCBARuleModel</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>allData &lt;- datasets::iris[sample(nrow(datasets::iris)),]
trainFold &lt;- allData[1:100,]
rmCBA &lt;- cba(trainFold, classAtt="Species")
rmqCBA &lt;- qcba(cbaRuleModel=rmCBA,datadf=trainFold)
print(rmqCBA@rules)
</code></pre>

<hr>
<h2 id='qcbaHumTemp'>Use the HumTemp dataset to test the one rule classification QCBA workflow.</h2><span id='topic+qcbaHumTemp'></span>

<h3>Description</h3>

<p>Learns a CBA classifier and performs all QCBA postprocessing steps.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qcbaHumTemp()
</code></pre>


<h3>Value</h3>

<p>QCBA model
</p>

<hr>
<h2 id='qcbaIris'>Use the <a href="datasets.html#topic+iris">iris</a> dataset to the test QCBA workflow.</h2><span id='topic+qcbaIris'></span>

<h3>Description</h3>

<p>Learns a CBA classifier and performs all QCBA postprocessing steps
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qcbaIris()
</code></pre>


<h3>Value</h3>

<p>Accuracy.
</p>

<hr>
<h2 id='qcbaIris2'>Use the Iris dataset to test the experimental multi-rule QCBA workflow.</h2><span id='topic+qcbaIris2'></span>

<h3>Description</h3>

<p>Learns a CBA classifier, and then transforms it  to a multirule classifier,
including rule annotation and fuzzification. Applies the learnt model with rule mixture classification.
The model  is saved to a temporary file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qcbaIris2()
</code></pre>


<h3>Value</h3>

<p>Accuracy.
</p>

<hr>
<h2 id='qCBARuleModel-class'>qCBARuleModel</h2><span id='topic+qCBARuleModel-class'></span><span id='topic+qCBARuleModel'></span>

<h3>Description</h3>

<p>This class represents a QCBA rule-based classifier.
</p>


<h3>Slots</h3>


<dl>
<dt><code>rules</code></dt><dd><p>object of class rules from arules package postprocessed by <span class="pkg">qCBA</span></p>
</dd>
<dt><code>history</code></dt><dd><p>extension history</p>
</dd>
<dt><code>classAtt</code></dt><dd><p>name of the target class attribute</p>
</dd>
<dt><code>attTypes</code></dt><dd><p>attribute types</p>
</dd>
<dt><code>rulePath</code></dt><dd><p>path to file with rules, has priority over the rules slot</p>
</dd>
<dt><code>ruleCount</code></dt><dd><p>number of rules</p>
</dd>
</dl>

<hr>
<h2 id='rcbaModel2CBARuleModel'>rcbaModel2arcCBARuleModel Converts a model created by <span class="pkg">rCBA</span> so that it can be passed to qCBA</h2><span id='topic+rcbaModel2CBARuleModel'></span>

<h3>Description</h3>

<p>Creates instance of CBAmodel class from the <span class="pkg">arc</span> package
Instance of CBAmodel can then be passed to <a href="#topic+qcba">qcba</a>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rcbaModel2CBARuleModel(rcbaModel, cutPoints, classAtt, rawDataset, attTypes)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rcbaModel2CBARuleModel_+3A_rcbamodel">rcbaModel</code></td>
<td>
<p>object returned  by rCBA::build</p>
</td></tr>
<tr><td><code id="rcbaModel2CBARuleModel_+3A_cutpoints">cutPoints</code></td>
<td>
<p>specification of cutpoints applied on the data before they were passed to  <code>rCBA::build</code></p>
</td></tr>
<tr><td><code id="rcbaModel2CBARuleModel_+3A_classatt">classAtt</code></td>
<td>
<p>the name of the class attribute</p>
</td></tr>
<tr><td><code id="rcbaModel2CBARuleModel_+3A_rawdataset">rawDataset</code></td>
<td>
<p>the raw data (before discretization). This dataset is used to guess attribute types if attTypes is not passed</p>
</td></tr>
<tr><td><code id="rcbaModel2CBARuleModel_+3A_atttypes">attTypes</code></td>
<td>
<p>vector of attribute types of the original data.  If set to null, you need to pass rawDataset.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># this example takes about 10 seconds
if (! requireNamespace("rCBA", quietly = TRUE)) {
 message("Please install rCBA: install.packages('rCBA')")
} else
{
# This will run only outside a CRAN test, if the environment variable  NOT_CRAN is set to true
# This environment variable is set by devtools
if (identical(Sys.getenv("NOT_CRAN"), "true")) {
 library(rCBA)
 message(packageVersion("rCBA"))
 discrModel &lt;- discrNumeric(iris, "Species")
 irisDisc &lt;- as.data.frame(lapply(discrModel$Disc.data, as.factor))
 rCBAmodel &lt;- rCBA::build(irisDisc,parallel=FALSE, sa=list(timeout=0.01))
 CBAmodel &lt;- rcbaModel2CBARuleModel(rCBAmodel,discrModel$cutp,"Species",iris)
 qCBAmodel &lt;- qcba(CBAmodel,iris)
 print(qCBAmodel@rules)
 }
}


</code></pre>

<hr>
<h2 id='sbrlModel2arcCBARuleModel'>sbrlModel2arcCBARuleModel Converts a model created by <span class="pkg">sbrl</span> so that it can be passed to qCBA</h2><span id='topic+sbrlModel2arcCBARuleModel'></span>

<h3>Description</h3>

<p>Creates instance of  CBAmodel class from the <span class="pkg">arc</span> package. SBRL package is no longer in CRAN,
but can be obtained from https://github.com/cran/sbrl
Instance of  CBAmodel can then be passed to <a href="#topic+qcba">qcba</a>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sbrlModel2arcCBARuleModel(
  sbrl_model,
  cutPoints,
  rawDataset,
  classAtt,
  attTypes
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sbrlModel2arcCBARuleModel_+3A_sbrl_model">sbrl_model</code></td>
<td>
<p>object returned  by arulesCBA::CBA()</p>
</td></tr>
<tr><td><code id="sbrlModel2arcCBARuleModel_+3A_cutpoints">cutPoints</code></td>
<td>
<p>specification of cutpoints applied on the data before they were passed to <code>rCBA::build</code></p>
</td></tr>
<tr><td><code id="sbrlModel2arcCBARuleModel_+3A_rawdataset">rawDataset</code></td>
<td>
<p>the raw data (before discretization). This dataset is used to guess attribute types if attTypes is not passed</p>
</td></tr>
<tr><td><code id="sbrlModel2arcCBARuleModel_+3A_classatt">classAtt</code></td>
<td>
<p>the name of the class attribute</p>
</td></tr>
<tr><td><code id="sbrlModel2arcCBARuleModel_+3A_atttypes">attTypes</code></td>
<td>
<p>vector of attribute types of the original data.  If set to null, you need to pass rawDataset.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># if (! requireNamespace("rCBA", quietly = TRUE)) {
#  message("Please install rCBA to allow for sbrl model conversion")
#   return()
# } else if (! requireNamespace("sbrl", quietly = TRUE)) {
#  message("Please install sbrl to allow for postprocessing of sbrl models")
#} else
#{
#  library(sbrl)
#  library(rCBA)
#  #sbrl handles only binary problems, iris has 3 target classes - remove one class
#  set.seed(111)
#  allData &lt;- datasets::iris[sample(nrow(datasets::iris)),]
#  classToExclude&lt;-"versicolor"
#  allData &lt;- allData[allData$Species!=classToExclude, ]
#  # drop virginica level
#  allData$Species &lt;-allData$Species [, drop=TRUE]
#  trainFold &lt;- allData[1:50,]
#  testFold &lt;- allData[51:nrow(allData),]
#  sbrlFixedLabel&lt;-"label"
#  origLabel&lt;-"Species"

#  orignames&lt;-colnames(trainFold)
#  orignames[which(orignames == origLabel)]&lt;-sbrlFixedLabel
#  colnames(trainFold)&lt;-orignames
#   colnames(testFold)&lt;-orignames

#  # to recode label to binary values:
#  # first create dict mapping from original distinct class values to 0,1 
#  origval&lt;-levels(as.factor(trainFold$label))
#  newval&lt;-range(0,1)
#  dict&lt;-data.frame(origval,newval)
#  # then apply dict to train and test fold
#  trainFold$label&lt;-dict[match(trainFold$label, dict$origval), 2]
#  testFold$label&lt;-dict[match(testFold$label, dict$origval), 2]

#  # discretize training data
#  trainFoldDiscTemp &lt;- discrNumeric(trainFold, sbrlFixedLabel)
#  trainFoldDiscCutpoints &lt;- trainFoldDiscTemp$cutp
#  trainFoldDisc &lt;- as.data.frame(lapply(trainFoldDiscTemp$Disc.data, as.factor))

#  # discretize test data
#  testFoldDisc &lt;- applyCuts(testFold, trainFoldDiscCutpoints, infinite_bounds=TRUE, labels=TRUE)

#  # learn sbrl model
#  sbrl_model &lt;- sbrl(trainFoldDisc, iters=30000, pos_sign="0", 
#                   neg_sign="1", rule_minlen=1, rule_maxlen=10, 
#                    minsupport_pos=0.10, minsupport_neg=0.10, 
#                   lambda=10.0, eta=1.0, alpha=c(1,1), nchain=10)
#  # apply sbrl model on a test fold
#  yhat &lt;- predict(sbrl_model, testFoldDisc)
#  yvals&lt;- as.integer(yhat$V1&gt;0.5)
#  sbrl_acc&lt;-mean(as.integer(yvals == testFoldDisc$label))
#  message("SBRL RESULT")
#  sbrl_model
#  rm_sbrl&lt;-sbrlModel2arcCBARuleModel(sbrl_model,trainFoldDiscCutpoints,trainFold,sbrlFixedLabel) 
#  message(paste("sbrl acc=",sbrl_acc,"sbrl rule count=",nrow(sbrl_model$rs), "avg rule length", 
#  sum(rm_sbrl@rules@lhs@data)/length(rm_sbrl@rules)))
#  rmQCBA_sbrl &lt;- qcba(cbaRuleModel=rm_sbrl,datadf=trainFold)
#  prediction &lt;- predict(rmQCBA_sbrl,testFold)
#  acc_qcba_sbrl &lt;- CBARuleModelAccuracy(prediction, testFold[[rmQCBA_sbrl@classAtt]])
#  if (! requireNamespace("stringr", quietly = TRUE)) {
#    message("Please install stringr to compute average rule length for QCBA")
#    avg_rule_length &lt;- NA
#  } else
#  {
#    library(stringr)
#    avg_rule_length &lt;- (sum(unlist(lapply(rmQCBA_sbrl@rules[1],str_count,pattern=",")))+
#                          # assuming the last rule has antecedent length zero 
#                          nrow(rmQCBA_sbrl@rules)-1)/nrow(rmQCBA_sbrl@rules)
#  }
#  message("QCBA RESULT")
#  rmQCBA_sbrl@rules
#  message(paste("QCBA after SBRL acc=",acc_qcba_sbrl,"rule count=",
#   rmQCBA_sbrl@ruleCount, "avg rule length",  avg_rule_length))
#   unlink("tdata_R.label") # delete temp files created by SBRL
#   unlink("tdata_R.out")
# }
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
