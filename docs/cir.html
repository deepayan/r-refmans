<!DOCTYPE html><html lang="en"><head><title>Help for package cir</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {cir}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#cir-package'><p>Isotonic Regression, Centered Isotonic Regression, and Dose-Response Utilities</p></a></li>
<li><a href='#cirPAVA'><p>Centered-isotonic-regression (CIR) point estimation</p></a></li>
<li><a href='#deltaInverse'><p>Backend utility to calculate inverse (dose-finding) intervals, using local inversion and the Delta method</p></a></li>
<li><a href='#doseFind'><p>Inverse (dose-finding) point estimate (e.g., estimating a percentile)</p></a></li>
<li><a href='#DRshrink'><p>Shrinkage fix to mitigate bias in observed rates, under adaptive dose-finding designs</p></a></li>
<li><a href='#is.DRtrace'><p>Constructor functions and class-checking functions for DRtrace and doseResponse classes</p></a></li>
<li><a href='#isotInterval'><p>Backend utility to calculate analytical CIR/IR interval estimates, given the point estimates</p></a></li>
<li><a href='#morrisCI'><p>Analytical ordered-binary-Y confidence intervals, using the Morris (1988) algorithm</p></a></li>
<li><a href='#oldPAVA'><p>&quot;Old School&quot; isotonic-regression point estimates, with flexible dose-response input</p></a></li>
<li><a href='#plot.DRtrace'><p>Plotting Methods for DRtrace, doseResponse Objects</p></a></li>
<li><a href='#quickInverse'><p>Convenient point and Interval Inverse Estimation (&quot;Dose-Finding&quot;), using CIR or IR</p></a></li>
<li><a href='#quickIsotone'><p>Convenient Forward point and interval estimation via CIR or IR</p></a></li>
<li><a href='#slope'><p>Piecewise-linear local slopes given a (non-strictly) monotone x-y sequence</p></a></li>
<li><a href='#wilsonCI'><p>Standard unordered-Binomial confidence interval utilities.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Centered Isotonic Regression and Dose-Response Utilities</td>
</tr>
<tr>
<td>Version:</td>
<td>2.5.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2025-02-02</td>
</tr>
<tr>
<td>Description:</td>
<td>Isotonic regression (IR) and its improvement: centered isotonic regression (CIR). CIR is recommended in particular with small samples. Also, interval estimates for both, and additional utilities such as plotting dose-response data. For dev version and change history, see GitHub assaforon/cir.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-02-01 20:43:04 UTC; assaf</td>
</tr>
<tr>
<td>Author:</td>
<td>Assaf P. Oron [cre, aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Assaf P. Oron &lt;assaf.oron@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-02-01 21:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='cir-package'>Isotonic Regression, Centered Isotonic Regression, and Dose-Response Utilities</h2><span id='topic+cir-package'></span><span id='topic+cir'></span>

<h3>Description</h3>

<p>This package revolves around centered isotonic regression (CIR), an improvement to isotonic regression (IR). However, it also includes a flexible, useful implementation of IR, confidence-interval estimates for both CIR and IR, and additional utilities for dose-response and dose-finding data.</p>


<h3>Details</h3>

<p>Isotonic regression (IR) is a standard nonparametric estimation method for monotone data. We have developed an improvement to univariate IR, named centered isotonic regression (CIR). There are heuristic and theoretical justifications to prefer CIR over IR, but first and foremost, in most simulations it produces substantially smaller estimation error. More details appear in Oron and Flournoy (2017).
</p>
<p>This package implements CIR, but &quot;along the way&quot; an enhanced interface to univariate IR is also available. IR's base-R  implementation <code>isoreg</code> is very limited, as its own help page admits. A few other packages provide versions of IR, but to my knowledge the <code>cir</code> implementation offers some unique conveniences.
</p>
<p>In addition, Oron and Flournoy (2017) also develop theoretically-backed confidence intervals applicable to both CIR and IR. The package's convenience wrapper <code><a href="#topic+quickIsotone">quickIsotone</a></code> executes CIR (or IR if one chooses <code>estfun = oldPAVA</code>), and returns both point and interval estimates at the specified x values. 
</p>
<p>Since our motivation for studying IR comes from dose-finding designs such as Up-and-Down, there's analogous functionality for dose-finding (&quot;inverse&quot;) estimation of x given specified y values. In particular, <code><a href="#topic+quickInverse">quickInverse</a></code> offers inverse point and interval estimates in a single call. The package now also includes an optional bias-correction shrinkage method for such designs, informed by more recent research (Flournoy and Oron, 2020).
</p>
<p>The package's focus is dose-response data with the response assumed binary (coded as 0 or 1). Some functions might work for any input data, but others will not. In particular, the confidence intervals are only applicable to binary-response data.
</p>
<p>The package also includes two S3 classes, <code><a href="#topic+doseResponse">doseResponse</a></code> and <code><a href="#topic+DRtrace">DRtrace</a></code>. The former which is more heavily used, is a data frame with elements <code>x, y, wt</code>, summarizing the dose-response information. The latter is a &quot;trace&quot; or a running description of raw dose-response data, with <code>x, y, cohort</code> provided at the resolution of single observations. Each class has a <code>plot</code> method.
</p>
<p>If you intend to use <code>cir</code> mostly for analysis of an Up-and-Down experiment, note that the newer package <code>upndown</code> contains more convenient wrapper utilities for such usage. These wrappers use <code>cir</code> functions to carry out the basic estimation and visualization tasks.
</p>
<p>Enjoy!
</p>


<h3>Author(s)</h3>

<p>Assaf P. Oron.
</p>
<p>Maintainer: Assaf P. Oron <code>&lt;assaf.oron.at.gmail.com&gt;</code>
</p>


<h3>References</h3>

<p>Oron, A.P. and Flournoy, N., 2017. Centered Isotonic Regression: Point and Interval Estimation for Dose-Response Studies. Statistics in Biopharmaceutical Research 9, 258-267. (author's public version available on arxiv.org).
</p>
<p>Flournoy, N. and Oron, A.P., 2020. Bias Induced by Adaptive Dose-Finding Designs. Journal of Applied Statistics 47, 2431-2442.</p>

<hr>
<h2 id='cirPAVA'>Centered-isotonic-regression (CIR) point estimation</h2><span id='topic+cirPAVA'></span>

<h3>Description</h3>

<p>Nonparametric forward point estimation of a monotone response (y) as a function of dose (x), using the centered-isotonic-regression (CIR) algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cirPAVA(
  y,
  x = NULL,
  wt = NULL,
  outx = NULL,
  full = FALSE,
  dec = FALSE,
  strict = FALSE,
  interiorStrict = TRUE,
  ybounds = 0:1,
  adaptiveShrink = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cirPAVA_+3A_y">y</code></td>
<td>
<p>can be either of the following: y values (response rates), a <code><a href="#topic+DRtrace">DRtrace</a></code> object,  <code><a href="#topic+doseResponse">doseResponse</a></code> object, or valid input (potentially together with <code>x,wt</code>) to generate a <code><a href="#topic+doseResponse">doseResponse</a></code> object. See <code><a href="#topic+doseResponse">doseResponse</a></code> help for more.</p>
</td></tr>
<tr><td><code id="cirPAVA_+3A_x">x</code></td>
<td>
<p>dose levels (if not included in y).</p>
</td></tr>
<tr><td><code id="cirPAVA_+3A_wt">wt</code></td>
<td>
<p>weights (if not included in y).</p>
</td></tr>
<tr><td><code id="cirPAVA_+3A_outx">outx</code></td>
<td>
<p>vector of x values at which predictions will be made. If <code>NULL</code> (default), this will be set to the set of unique values in the x argument (or equivalently in <code>y$x</code>). Non-NULL inputs are relevant only if <code>full=TRUE</code>.</p>
</td></tr>
<tr><td><code id="cirPAVA_+3A_full">full</code></td>
<td>
<p>logical, is a more complete output desired? if <code>FALSE</code> (default), only a vector of point estimates for y at <code>outx</code> is returned.</p>
</td></tr>
<tr><td><code id="cirPAVA_+3A_dec">dec</code></td>
<td>
<p>logical, is the true function is assumed to be monotone decreasing rather than increasing? Default <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="cirPAVA_+3A_strict">strict</code></td>
<td>
<p>logical, should CIR enforce strict monotonicity by &quot;fixing&quot; flat intervals everywhere? Default <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="cirPAVA_+3A_interiorstrict">interiorStrict</code></td>
<td>
<p>logical, should CIR enforce strict monotonicity, but only for y values inside of <code>ybounds</code>?  Default <code>TRUE</code>. Choosing <code>FALSE</code> will be overridden if <code>strict=TRUE</code>, and a warning will be given.</p>
</td></tr>
<tr><td><code id="cirPAVA_+3A_ybounds">ybounds</code></td>
<td>
<p>numeric vector of length 2, relevant only under the default setting of <code>strict=FALSE, interiorStrict=TRUE</code>. Default <code>0:1</code>. See 'Details'.</p>
</td></tr>
<tr><td><code id="cirPAVA_+3A_adaptiveshrink">adaptiveShrink</code></td>
<td>
<p>logical, should the y-values be pre-shrunk towards a dose-finding experiment's target? Recommended if data were obtained via an adaptive dose-finding design. If <code>TRUE</code>, then must also provide a <code>target</code> argument that will be passed via <code>...</code>.</p>
</td></tr>
<tr><td><code id="cirPAVA_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to pre-processing functions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>CIR is a variation of isotonic regression (IR) that shrinks IR's constant (&quot;flat&quot;) intervals to single points and interpolates between these points, generating a curve that is strictly monotone everywhere except (possibly) near the boundaries.This is the underlying &quot;engine&quot; function implementing CIR. For a quick and more user-friendly wrapper that provides both point and interval estimates, use <code><a href="#topic+quickIsotone">quickIsotone</a></code>.
</p>
<p>Flat intervals in the raw input data, are handled with care. Under the default setting (<code>strict=FALSE, interiorStrict=TRUE</code>), flat intervals are treated as monotonicity violations, unless the <code class="reqn">y</code> value is on the boundary of its allowed range (default <code class="reqn">[0,1]</code>, appropriate for binary-response data). On that boundary, flat intervals are left unchanged.
</p>
<p>The algorithm is documented and discussed in Oron and Flournoy (2017). The function includes an <code>adaptiveShrink</code> option, to mitigate bias caused when using adaptive designs (Flournoy and Oron, 2020).
</p>


<h3>Value</h3>

<p>under default, returns a vector of y estimates at unique x values. With <code>full=TRUE</code>, returns a list of 3 <code><a href="#topic+doseResponse">doseResponse</a></code> objects name <code>output,input,shrinkage</code> for the output data at dose levels, the input data, and the function as fit at algorithm-generated shrinkage points, respectively.
</p>


<h3>Author(s)</h3>

<p>Assaf P. Oron <code>&lt;assaf.oron.at.gmail.com&gt;</code>
</p>


<h3>References</h3>

<p>Oron, A.P. and Flournoy, N., 2017. Centered Isotonic Regression: Point and Interval Estimation for Dose-Response Studies. Statistics in Biopharmaceutical Research 9, 258-267. (author's public version available on arxiv.org).
</p>
<p>Flournoy, N. and Oron, A.P., 2020. Bias Induced by Adaptive Dose-Finding Designs. Journal of Applied Statistics 47, 2431-2442.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+oldPAVA">oldPAVA</a></code>,<code><a href="#topic+quickIsotone">quickIsotone</a></code>; <code><a href="#topic+DRshrink">DRshrink</a></code> for explanation about <code>adaptiveShrink</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Interesting run (#664) from a simulated up-and-down ensemble:
# (x will be auto-generated as dose levels 1:5)
dat=doseResponse(y=c(1/7,1/8,1/2,1/4,4/17),wt=c(7,24,20,12,17))
# CIR, using the default 'quick' function that also provides CIs (default 90%).
# The experiment's goal is to find the 30th percentile. We deploy the empirical bias correction.
quick1=quickIsotone(dat, adaptiveShrink = TRUE, adaptiveCurve = TRUE, target = 0.3)
quick1
# Use 'estfun' argument to operate the same function with old PAVA as the estimator
# Here we neglect the bias correction to sharpen the old:new contrast
quick0=quickIsotone(dat,estfun=oldPAVA)
quick0

### Showing the data and the fits
par(mar=c(3,3,1,1),mgp=c(2,.5,0),tcl=-0.25)
plot(dat, ylim=c(0.05,0.55), las=1) # uses plot.doseResponse()
# The IR fit: a straightforward interpolation
lines(quick0$y,lty=2) 

# With CIR, 'quickIsotone' cannot show us the true underlying interpolation; 
# it only provides the estimates at requested points.  Interpolation should be done between 
# shrinkage points, not the original design points. So we must call the full 'cirPAVA' function:

slow1 = cirPAVA(dat, full=TRUE, adaptiveShrink = TRUE, adaptiveCurve = TRUE, target = 0.3)
# Now, compare these 3 (the first one is wrong, b/c it interpolates from design points):
midpts = 1:4 + 0.5
approx(1:5,quick1$y, xout=midpts)$y
# instead, you can just call 'quickIsotone' and specify 'outx'
quickIsotone(dat,outx=midpts , adaptiveShrink = TRUE, adaptiveCurve = TRUE, target = 0.3) 
approx(slow1$shrinkage$x,slow1$shrinkage$y,xout=midpts)$y # Or use 'cirPAVA'

# Ok... finally plotting the CIR curve
# Both flat intervals are shrunk, because neither are at y=0 or y=1
lines(slow1$shrinkage$x,slow1$shrinkage$y, lwd = 2)

# Last but not least, here's the true response function
lines(seq(1,5,0.1),pweibull(seq(1,5,0.1),shape=1.1615,scale=8.4839),col=2)
legend('topleft',pch=c(NA,'X',NA,NA),lty=c(1,NA,2,1),col=c(2,1,1,1),
	legend=c('True Curve','Observations','IR','CIR'), bty='n')
</code></pre>

<hr>
<h2 id='deltaInverse'>Backend utility to calculate inverse (dose-finding) intervals, using local inversion and the Delta method</h2><span id='topic+deltaInverse'></span>

<h3>Description</h3>

<p>Calculate left-bound to right-bound intervals for the dose point estimates, using local slopes at design points (places where observations exist) to invert the forward lower-upper bounds.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>deltaInverse(
  isotPoint,
  target = (1:3)/4,
  intfun = morrisCI,
  conf = 0.9,
  adaptiveCurve = FALSE,
  minslope = 0.01,
  slopeRefinement = TRUE,
  finegrid = 0.05,
  globalCheck = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="deltaInverse_+3A_isotpoint">isotPoint</code></td>
<td>
<p>The output of an estimation function such as <code><a href="#topic+cirPAVA">cirPAVA</a>,<a href="#topic+doseFind">doseFind</a></code>,  with the option <code>full=TRUE</code>. Should be at least a list of 3 <code><a href="#topic+doseResponse">doseResponse</a></code> objects named <code>input, output, shrinkage</code>.</p>
</td></tr>
<tr><td><code id="deltaInverse_+3A_target">target</code></td>
<td>
<p>A vector of target response rate(s), for which the interval is needed. Default (since version 2.3.0) is the 3 quartiles (<code>(1:3) / 4</code>). If changed to <code>NULL</code>, interval will be returned for the <code class="reqn">y</code> values of <code>isotPoint$output</code>.</p>
</td></tr>
<tr><td><code id="deltaInverse_+3A_intfun">intfun</code></td>
<td>
<p>the function to be used for initial (forward) interval estimation. Default <code><a href="#topic+morrisCI">morrisCI</a></code> (see help on that function for additional options).</p>
</td></tr>
<tr><td><code id="deltaInverse_+3A_conf">conf</code></td>
<td>
<p>numeric, the interval's confidence level as a fraction in (0,1). Default 0.9.</p>
</td></tr>
<tr><td><code id="deltaInverse_+3A_adaptivecurve">adaptiveCurve</code></td>
<td>
<p>logical, should the CIs be expanded by using a parabolic curve between estimation points rather than straight interpolation? Default <code>FALSE</code>. Switch to <code>TRUE</code> recommended when adaptive design was used, and <code>target</code> is outside of (0.4, 0.6).</p>
</td></tr>
<tr><td><code id="deltaInverse_+3A_minslope">minslope</code></td>
<td>
<p>minimum local slope (subsequently normalized by the dose-spacing unit) considered positive, passed on to <code><a href="#topic+slope">slope</a></code>. Needed to avoid unrealistically broad intervals. Default 0.01.</p>
</td></tr>
<tr><td><code id="deltaInverse_+3A_sloperefinement">slopeRefinement</code></td>
<td>
<p><strong>(new to 2.3.0)</strong> logical: whether to allow refinement of the slope estimate, including different slopes to the left and right of target. Default <code>TRUE</code>. See Details.</p>
</td></tr>
<tr><td><code id="deltaInverse_+3A_finegrid">finegrid</code></td>
<td>
<p>a numerical value used to guide how fine the grid of <code>x</code> values will be during slope estimation. Should be in (0,1) (preferably much less than 1). Default 0.05.</p>
</td></tr>
<tr><td><code id="deltaInverse_+3A_globalcheck">globalCheck</code></td>
<td>
<p><strong>(new to 2.4.0)</strong> logical: whether to allow narrowing of the bound, in case the &quot;global&quot; bound <em>(obtained via inverting the forward interval, and generally more conservative)</em> is narrower. Default <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="deltaInverse_+3A_...">...</code></td>
<td>
<p>additional arguments passed on to <code><a href="#topic+quickIsotone">quickIsotone</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is the &quot;backend engine&quot; for calculating confidence intervals for inverse (dose-finding) estimation. Methodologically this might be the most challenging task in the package. It is expected that most users will not interact with this function directly, but rather indirectly via the convenience wrapper <code><a href="#topic+quickInverse">quickInverse</a></code>.
</p>
<p>The Delta method in this application boils down to dividing the distance to the forward (vertical) bounds, by the slope, to get the left/right interval width. Both forward intervals and slopes are calculated across a standard set of <code class="reqn">x</code> values, then interpolated at horizontal cross-sections determined by <code>target</code>. Slope estimates are performed by <code><a href="#topic+slope">slope</a></code>.
</p>
<p>Starting version 2.3.0, by default the slope estimate is different to the right and left of target. The intervals should now better accommodate the sharp slope changes that often happen with discrete dose-response datasets. Operationally, the intervals are first estimated via the single-slope approach described above. Then using a finer grid of <code class="reqn">x</code> values, weighted-average slopes to the right and left of the point estimate separately are calculated over the first-stage's half-intervals. The weights are hard-coded as quadratic (Epanechnikov).
</p>
<p>An alternative and much simpler interval method (dubbed &quot;global&quot;) is hard-coded into <code><a href="#topic+quickInverse">quickInverse</a></code>, and can be chosen from there as an option. It is not recommended being far too conservative, and sometimes not existing. It is now also (since version 2.4.0) used in this function as a fallback upper bound on interval width.
</p>


<h3>Value</h3>

<p>two-column matrix with the left and right bounds, respectively
</p>


<h3>See Also</h3>

<p><code><a href="#topic+quickIsotone">quickIsotone</a></code>,<code><a href="#topic+quickInverse">quickInverse</a></code>,<code><a href="#topic+isotInterval">isotInterval</a></code>,
<code><a href="#topic+slope">slope</a></code>; <code><a href="#topic+DRshrink">DRshrink</a></code> for the shrinkage fix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Interesting run (#664) from a simulated up-and-down ensemble:
# (x will be auto-generated as dose levels 1:5)
dat=doseResponse(y=c(1/7,1/8,1/2,1/4,4/17), wt=c(7,24,20,12,17))
# The experiment's goal is to find the 30th percentile
quick1=quickIsotone(dat, adaptiveShrink = TRUE, target = 0.3)

# For inverse confidence intervals "the long way", 
#    we need a full CIR output object:
fwd1=cirPAVA(dat, full=TRUE, adaptiveShrink = TRUE, target = 0.3)
# Inverse intervals. 
# Note: 'target' specifies the y values at which the interval is calculated.
#       They are selected here based on the y range in which there are estimates.
yvals = c(seq(0.15, 0.3, 0.05), 0.33)
invDelta=deltaInverse(fwd1, target = yvals, adaptiveCurve = TRUE)
# stop()
# We added the adaptiveCurve option because the experiment's target is off-center,
#     and inverse-interval coverage tends to be lacking w/o that option.

### Showing the data and the estimates
par(mar=c(3,3,4,1), mgp=c(2,.5,0), tcl=-0.25)
# Following command uses plot.doseResponse()
plot(dat, ylim=c(0.05,0.55), 
     las=1, xlim=c(0,6.5), main="Inverse-Estimation CIs") 

# The true response function; true target is where it crosses the y=0.3 line
lines(seq(0,7,0.1), pweibull(seq(0,7,0.1), shape=1.1615, scale=8.4839), col=4, lwd=1.5)
abline(h=0.3, col=2, lwd=2, lty=3) ### The experiment's official target

# Forward CIs; the "global" inverse interval just draws horizontal lines between them
# To get these "global" intervals calculated for you at specific targets, choose 'delta=FALSE' 
#      when calling quickInverse()
lines(quick1$y, lwd=1.5, col='purple') 
lines(quick1$lower90conf,lty=2,col=3) 
lines(quick1$upper90conf,lty=2,col=3) 
# Note that only the upper forward bounds intersect the horizontal line at y=0.3.
#   Therefore, via the "global" approach there won't be a finite CI for the target estimate.

# Now, the default "local" inverse interval, which is finite for the range of estimated y values.
# In particular, it is finite for y=0.3.
# Note in the plot, how we make it equal to the "global" bound when the latter is narrower.
lines(invDelta[,1], yvals, lty=2, lwd=2)
lines(invDelta[,2], yvals, lty=2, lwd=2)

legend('topleft', pch=c(NA,NA,'X',NA,NA), lty=c(1,1,NA,2,2), 
       col=c(4,'purple', 1,1,3), lwd=c(1.5,1.5,0,2,1),
       legend = c('True Curve', 'CIR Curve', 'Observations', 
                  'Local Interval (default)',
                  'Forward/Global Interval'), bty='n')

</code></pre>

<hr>
<h2 id='doseFind'>Inverse (dose-finding) point estimate (e.g., estimating a percentile)</h2><span id='topic+doseFind'></span>

<h3>Description</h3>

<p>Inverse (&quot;dose-finding&quot;) point estimation of a dose (x) for a specified target y value (e.g., a response rate),
using a user-specified forward-estimation algorithm (default is CIR).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>doseFind(
  y,
  x = NULL,
  wt = NULL,
  estfun = cirPAVA,
  target = NULL,
  full = FALSE,
  dec = FALSE,
  extrapolate = FALSE,
  errOnFlat = FALSE,
  adaptiveShrink = FALSE,
  starget = target[1],
  tiemeth = "ordered",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="doseFind_+3A_y">y</code></td>
<td>
<p>can be either of the following: y values (response rates), a 2-column matrix with positive/negative response counts by dose, a <code><a href="#topic+DRtrace">DRtrace</a></code> object or a <code><a href="#topic+doseResponse">doseResponse</a></code> object.</p>
</td></tr>
<tr><td><code id="doseFind_+3A_x">x</code></td>
<td>
<p>dose levels (if not included in y).</p>
</td></tr>
<tr><td><code id="doseFind_+3A_wt">wt</code></td>
<td>
<p>weights (if not included in y).</p>
</td></tr>
<tr><td><code id="doseFind_+3A_estfun">estfun</code></td>
<td>
<p>the name of the dose-response estimation function. Default <code><a href="#topic+cirPAVA">cirPAVA</a></code>.</p>
</td></tr>
<tr><td><code id="doseFind_+3A_target">target</code></td>
<td>
<p>A vector of target response rate(s), for which the percentile dose estimate is needed. See Note.</p>
</td></tr>
<tr><td><code id="doseFind_+3A_full">full</code></td>
<td>
<p>logical, is a more complete output desired (relevant only for doseFind)? if <code>FALSE</code> (default), only a point estimate of the dose (x) for the provided target rate is returned.</p>
</td></tr>
<tr><td><code id="doseFind_+3A_dec">dec</code></td>
<td>
<p>(relevant only for doseFind) logical, is the true function is assumed to be monotone decreasing? Default <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="doseFind_+3A_extrapolate">extrapolate</code></td>
<td>
<p>logical: should extrapolation beyond the range of estimated y values be allowed? Default <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="doseFind_+3A_erronflat">errOnFlat</code></td>
<td>
<p>logical: in case the forward estimate is completely flat making dose-finding infeasible, should an error be returned? Under default (<code>FALSE</code>), <code>NA</code>s are returned for the target estimate.</p>
</td></tr>
<tr><td><code id="doseFind_+3A_adaptiveshrink">adaptiveShrink</code></td>
<td>
<p>logical, should the y-values be pre-shrunk towards an experiment's target? Recommended if data were obtained via an adaptive dose-finding design. See <code><a href="#topic+DRshrink">DRshrink</a></code> and the Note.</p>
</td></tr>
<tr><td><code id="doseFind_+3A_starget">starget</code></td>
<td>
<p>The shrinkage target. Defaults to <code>target[1]</code>.</p>
</td></tr>
<tr><td><code id="doseFind_+3A_tiemeth">tiemeth</code></td>
<td>
<p>The method to resolve ties. Default <code>"decide"</code>, meaning the function chooses based on context. See Details.</p>
</td></tr>
<tr><td><code id="doseFind_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to <code><a href="#topic+doseResponse">doseResponse</a></code> and <code>estfun</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function works by calling <code>estfun</code> for forward estimation of the x-y relationship, then using <code><a href="stats.html#topic+approx">approx</a></code> with the x and y roles reversed for inverse estimation. It is expected that most users will not interact with this function directly, but rather indirectly via the convenience wrapper <code><a href="#topic+quickInverse">quickInverse</a></code>.
</p>
<p>The <code>extrapolate</code> option sets the <code>rule</code> argument for this second call:
</p>

<ul>
<li> <p><code>extrapolate=TRUE</code> translates to <code>rule=2</code>, which actually means that the x value on the edge of the estimated y range will be assigned.
</p>
</li>
<li> <p><code>extrapolate=FALSE</code> (default) translates to <code>rule=1</code>, which means an <code>NA</code> will be returned for any target y value lying outside the estimated y range.
</p>
</li></ul>

<p>Note also that the function is set up to work with a vector of targets.
</p>
<p>If the data were obtained from an adaptive dose-finding design and you seek to estimate a dose other than the experiment's target, note that away from the target the estimates are likely biased (Flournoy and Oron, 2019). Use <code>adaptiveShrink=TRUE</code> to mitigate the bias. In addition, either provide the true target as <code>starget</code>, or a vector of values to <code>target</code>, with the first value being the true target.
</p>
<p>Tie-breaking - the <code>tiemeth</code> argument passed on as the <code>ties</code> argument for <code>approx()</code> - provides yet another complication: as of 2.5.0, the default is <code>"decide"</code>, which means <code>"ordered"</code> - unless <code>target</code> falls on the boundary of <code>y</code> estimates, in which case the most interior <code>x</code> value is chosen. A user-chosen value for <code>tiemeth</code> will override all of that; see <code>?approx</code> for options.
</p>


<h3>Value</h3>

<p>under default, returns point estimate(s) of the dose (x) for the provided target rate(s). With <code>full=TRUE</code>, returns a list with
</p>

<ul>
<li> <p><code>targest</code>: The said point estimate of x
</p>
</li>
<li> <p><code>input</code>:    a <code>doseResponse</code> object summarizing the input data
</p>
</li>
<li> <p><code>output</code>:  a <code>doseResponse</code> object with the forward estimate at design points
</p>
</li>
<li> <p><code>shrinkage</code>:  a <code>doseResponse</code> object which is the <code>alg</code> output of the forward-estimation function
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Assaf P. Oron <code>&lt;assaf.oron.at.gmail.com&gt;</code>
</p>


<h3>References</h3>

<p>Flournoy N and Oron AP, 2020. Bias Induced by Adaptive Dose-Finding Designs. Journal of Applied Statistics 47, 2431-2442.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+oldPAVA">oldPAVA</a></code>,<code><a href="#topic+cirPAVA">cirPAVA</a></code>. If you'd like point and interval estimates together, use <code><a href="#topic+quickInverse">quickInverse</a></code>.
</p>

<hr>
<h2 id='DRshrink'>Shrinkage fix to mitigate bias in observed rates, under adaptive dose-finding designs</h2><span id='topic+DRshrink'></span>

<h3>Description</h3>

<p>Adaptive dose-finding designs induce a bias on observed rates
away from the target dose. This is well-known in other adaptive-design fields,
but has been overlooked by the dose-finding research community.
Flournoy and Oron (2020) examine the bias in the dose-finding context,
and suggest a simple shrinkage fix that reduces both bias and variance.
The fix is analogous to the empirical-logit fix for zero counts in binary data,
but instead of adding 0.5 to each cell, <code>target</code> is added to the 1's at each dose,
and <code>1-target</code> to the 0's.
The shrinkage is applied to the raw observation, so CIR or IR are carried out
on the shrunk data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DRshrink(y, x = NULL, wt0 = NULL, target, swt = 1, nmin = 2, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="DRshrink_+3A_y">y</code></td>
<td>
<p>can be either of the following: y values (response rates), a 2-column matrix with positive/negative response counts by dose, a <code><a href="#topic+DRtrace">DRtrace</a></code> object or a <code><a href="#topic+doseResponse">doseResponse</a></code> object.</p>
</td></tr>
<tr><td><code id="DRshrink_+3A_x">x</code></td>
<td>
<p>dose levels (if not included in y).</p>
</td></tr>
<tr><td><code id="DRshrink_+3A_wt0">wt0</code></td>
<td>
<p>weights (if not included in y).</p>
</td></tr>
<tr><td><code id="DRshrink_+3A_target">target</code></td>
<td>
<p>the balance point (between 0 and 1) around which the design concentrates allocations.</p>
</td></tr>
<tr><td><code id="DRshrink_+3A_swt">swt</code></td>
<td>
<p>the weight of the shrinkage. Default 1 (a single observation)</p>
</td></tr>
<tr><td><code id="DRshrink_+3A_nmin">nmin</code></td>
<td>
<p>the minimum n at each dose, for the shrinkage to be applied. Default 2.</p>
</td></tr>
<tr><td><code id="DRshrink_+3A_...">...</code></td>
<td>
<p>parameters passed on to <code>doseResponse()</code></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Assaf P. Oron <code>&lt;assaf.oron.at.gmail.com&gt;</code>
</p>


<h3>References</h3>

<p>Flournoy N and Oron AP, 2020. Bias Induced by Adaptive Dose-Finding Designs. Journal of Applied Statistics 47, 2431-2442.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Summary of raw data from the notorious Neuenschwander et al. (Stat. Med., 2008) trial
## Note the use of the 'cohort' argument to specify the cohort order
neundatDose = doseResponse(x=c(1,2.5,5,10,20,25), y = c(rep(0,4),2/9,1), wt = c(3,4,5,4,9,2) )

neundatDose

# Compare to this:
DRshrink(neundatDose, target = 0.3)
</code></pre>

<hr>
<h2 id='is.DRtrace'>Constructor functions and class-checking functions for DRtrace and doseResponse classes</h2><span id='topic+is.DRtrace'></span><span id='topic+is.doseResponse'></span><span id='topic+DRtrace'></span><span id='topic+doseResponse'></span>

<h3>Description</h3>

<p>Functions to create and sanity-check objects of the <code>DRtrace</code> (dose-response experiment trace/trajectory) and <code>doseResponse</code> (dose-specific response-rate summary) classes. Note that the latter inherits from the former, purely for programming-convenience reasons.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.DRtrace(dr)

is.doseResponse(dr)

DRtrace(y, x = NULL, cohort = NULL, noyes = FALSE, ...)

doseResponse(y, x = NULL, wt = rep(1, length(y)), noyes = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is.DRtrace_+3A_dr">dr</code></td>
<td>
<p>the object being checked</p>
</td></tr>
<tr><td><code id="is.DRtrace_+3A_y">y</code>, <code id="is.DRtrace_+3A_x">x</code></td>
<td>
<p>see Details.</p>
</td></tr>
<tr><td><code id="is.DRtrace_+3A_cohort">cohort</code></td>
<td>
<p>(<code>DRtrace</code> only) specify each observation's cohorts, if there were cohorts. If all cohorts were the same size, then you can specify the size as a single number. If there were no cohorts, code will default this variable to <code>1:n</code></p>
</td></tr>
<tr><td><code id="is.DRtrace_+3A_noyes">noyes</code></td>
<td>
<p>logical, in case of a 2-column input is the 1st column 'no'? Default <code>FALSE</code>, meaning the 1st column is 'yes'.</p>
</td></tr>
<tr><td><code id="is.DRtrace_+3A_...">...</code></td>
<td>
<p>parameters passed on to <code>DRtrace()</code>, or ignored.</p>
</td></tr>
<tr><td><code id="is.DRtrace_+3A_wt">wt</code></td>
<td>
<p>(<code>doseResponse</code> only) the weights associated with each <code>x</code> value; usually the sample size or similar.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The input argument <code>y</code> can include the entire information, or as little as the <code>y</code> vector of responses (for a <code>DRtrace</code> object) or response rates (<code>doseResponse</code>). When including the entire information, it has to be a data frame with at least <code>y</code> (both y and x for <code>DRtrace</code>), or a two-column matrix with 'yes' and 'no' responses (assumed in this order, but can be the reverse with <code>noyes=TRUE</code>). In this case the doses <code>x</code> can be provided as a separate vector, or as the matrix row names. <code>doseResponse</code> will return an error if there are any duplicates in <code>x</code>.
</p>
<p>Even though both <code>DRtrace</code> and <code>doseResponse</code> accept two-column yes/no matrix input, the interpretation is different. For the former, this form of input is intended mostly to enable shorthand input when the experiment was run in cohorts. Each row represents a cohort's results, and rows must be in the order the experiment was run. For the latter, the yes-no table is a summary tabulation of responses and is treated accordingly, including rearrangement of rows to increasing <code>x</code>.
</p>


<h3>Value</h3>

<p>For constructor functions, the relevant object. For checking functions, a logical value indicating whether the object meets class definition.
</p>


<h3>Author(s)</h3>

<p>Assaf P. Oron <code>&lt;assaf.oron.at.gmail.com&gt;</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cirPAVA">cirPAVA</a></code>, <code><a href="#topic+plot.doseResponse">plot.doseResponse</a></code>,<code><a href="#topic+plot.DRtrace">plot.DRtrace</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Summary of raw data from the notorious Neuenschwander et al. (Stat. Med., 2008) trial
## Note the use of the 'cohort' argument to specify the cohort order
neundatTrace = DRtrace(x = c(rep(1:4, c(3,4,5,4) ), 7, 7, rep(6,9)),
                       y = c(rep(0,16), 1,1, rep(c(0,0,1),2), 0,0,0), 
                       cohort = rep(1:8, c(3,4,5,4, 2, 3,3,3)) )
par(mar=c(3,3,3,1), mgp=c(2,.5,0), tcl=-0.25)
layout(t(1:2))
plot(neundatTrace ,main="N. et al. (2008) Trajectory", xlab = 'Cohort', 
          ylab="Ordinal Dose Level" ,cex.main=1.5)

## Same data, in 'doseResponse' format with actual doses rather than dose levels
neundatDose = doseResponse(x=c(1,2.5,5,10,20,25), y = c(rep(0,4),2/9,1), wt = c(3,4,5,4,9,2) )
plot(neundatDose ,main="N. et al. (2008) Final Dose-Toxicity", ylim=c(0,1),
	xlab="Dose (mg/sq.m./wk)", ylab="Toxicity Response Curve (F)", cex.main=1.5)
## We can also convert the DRtrace object to doseResponse...
neundatLevel = doseResponse(neundatTrace)

### Now plotting the former, vs. IR/CIR estimates
neunCIR0 = cirPAVA(neundatDose,full=TRUE, adaptiveShrink = TRUE, target = 0.3)
lines(neunCIR0$shrinkage$x, neunCIR0$shrinkage$y)
legend(1,1, pch=c(4,NA), lty = 0:1, legend=c('Observations', 'CIR w/bias corr.'), bty='n')
</code></pre>

<hr>
<h2 id='isotInterval'>Backend utility to calculate analytical CIR/IR interval estimates, given the point estimates</h2><span id='topic+isotInterval'></span>

<h3>Description</h3>

<p>For confidence intervals at design points (x values with obesrvations), this function calls <code>intfun</code> to do the work. In addition, CIs for any x value are calculated using linear interpolation between design points (note that for CIR, this differs from the interpolation of point estimates which is carried out between shrinkage points, as explained in <code><a href="#topic+quickIsotone">quickIsotone</a></code>). The interval estimation method is presented and discussed by Oron and Flournoy (2017).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>isotInterval(
  isotPoint,
  outx = isotPoint$output$x,
  conf = 0.9,
  intfun = morrisCI,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="isotInterval_+3A_isotpoint">isotPoint</code></td>
<td>
<p>The output of an estimation function such as <code><a href="#topic+cirPAVA">cirPAVA</a></code>  with the option <code>full=TRUE</code>. Should be a list of 3 <code><a href="#topic+doseResponse">doseResponse</a></code> objects named <code>input, output, shrinkage</code>.</p>
</td></tr>
<tr><td><code id="isotInterval_+3A_outx">outx</code></td>
<td>
<p>vector of x values for which estimates will be made. If <code>NULL</code> (default), this will be set to the set of unique values in isotPoint$x argument (or equivalently in y$x).</p>
</td></tr>
<tr><td><code id="isotInterval_+3A_conf">conf</code></td>
<td>
<p>numeric, the interval's confidence level as a fraction in (0,1). Default 0.9.</p>
</td></tr>
<tr><td><code id="isotInterval_+3A_intfun">intfun</code></td>
<td>
<p>the function to be used for interval estimation. Default <code><a href="#topic+morrisCI">morrisCI</a></code> (see help on that function for additional options).</p>
</td></tr>
<tr><td><code id="isotInterval_+3A_...">...</code></td>
<td>
<p>additional arguments passed on to <code>intfun</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data frame with two variables <code>ciLow, ciHigh</code> containing the estimated lower and upper confidence bounds, respectively.
</p>


<h3>Note</h3>

<p>All provided algorithms and formulae are for binary/Binomial data only. For other data, write your own <code>intfun</code>, returning a two-column matrix.
</p>
<p>Interval coverage for extreme percentiles with adaptive designs may be lacking: use <code>adaptiveCurve=TRUE</code> whenever the <code>target</code> is outside (0.4, 0.6). This should work as far as the 10th or 90th percentile, but not for more extreme targets.
</p>


<h3>Author(s)</h3>

<p>Assaf P. Oron <code>&lt;assaf.oron.at.gmail.com&gt;</code>
</p>


<h3>References</h3>

<p>Oron, A.P. and Flournoy, N., 2017. Centered Isotonic Regression: Point and Interval Estimation for Dose-Response Studies. Statistics in Biopharmaceutical Research 3, 258-267.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+quickIsotone">quickIsotone</a></code>,<code><a href="#topic+quickInverse">quickInverse</a></code>,<code><a href="#topic+morrisCI">morrisCI</a></code>,
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Interesting run (#664) from a simulated up-and-down ensemble:
# (x will be auto-generated as dose levels 1:5)
dat=doseResponse(y=c(1/7,1/8,1/2,1/4,4/17),wt=c(7,24,20,12,17))
# The experiment's goal is to find the 30th percentile
slow1=cirPAVA(dat,full=TRUE)
# Default interval (Morris+Wilson); same as you get by directly calling 'quickIsotone'
int1=isotInterval(slow1)
# Morris without Wilson; the 'narrower=FALSE' argument is passed on to 'morrisCI'
int1_0=isotInterval(slow1,narrower=FALSE)
# Wilson without Morris
int2=isotInterval(slow1,intfun=wilsonCI)
# Agresti=Coull (the often-used "plus 2")
int3=isotInterval(slow1,intfun=agcouCI)
# Jeffrys (Bayesian-inspired) is also available
int4=isotInterval(slow1,intfun=jeffCI)

### Showing the data and the intervals
par(mar=c(3,3,4,1),mgp=c(2,.5,0),tcl=-0.25)
plot(dat,ylim=c(0,0.65),refsize=4,las=1,main="Forward-Estimation CIs") # uses plot.doseResponse()

# The true response function; true target is where it crosses the y=0.3 line
lines(seq(0,7,0.1),pweibull(seq(0,7,0.1),shape=1.1615,scale=8.4839),col=4)

lines(int1$ciLow,lty=2,col=2,lwd=2) 
lines(int1$ciHigh,lty=2,col=2,lwd=2) 

lines(int1_0$ciLow,lty=2) 
lines(int1_0$ciHigh,lty=2) 

lines(int2$ciLow,lty=2,col=3) 
lines(int2$ciHigh,lty=2,col=3) 
# Plotting the remaining 2 is skipped, as they are very similar to Wilson.

# Note how the default (red) boundaries take the tighter of the two options everywhere, 
# except for one place (dose 1 upper bound) where they go even tighter thanks to monotonicity 
# enforcement. This can often happen when sample size is uneven; since bounds tend to be 
# conservative it is rather safe to do.

legend('topleft',pch=c(NA,'X',NA,NA,NA),lty=c(1,NA,2,2,2),col=c(4,1,2,1,3),lwd=c(1,1,2,1,1),legend
=c('True Curve','Observations','Morris+Wilson (default)','Morris only','Wilson only'),bty='n')

</code></pre>

<hr>
<h2 id='morrisCI'>Analytical ordered-binary-Y confidence intervals, using the Morris (1988) algorithm</h2><span id='topic+morrisCI'></span>

<h3>Description</h3>

<p>Analytical confidence intervals for CIR and IR, using the recursive algorithm by Morris (1988), equation (4.3), for ordered-binary-Y point estimates. Optionally, the intervals are narrowed further using a backup (unordered) interval estimate at each individual x value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>morrisCI(
  y,
  n,
  phat = y/n,
  conf = 0.9,
  narrower = TRUE,
  alternate = wilsonCI,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="morrisCI_+3A_y">y</code></td>
<td>
<p>integer or numeric vector, the pointwise Binomial counts</p>
</td></tr>
<tr><td><code id="morrisCI_+3A_n">n</code></td>
<td>
<p>integer or numeric vector, the pointwise sample sizes</p>
</td></tr>
<tr><td><code id="morrisCI_+3A_phat">phat</code></td>
<td>
<p>numeric vector, the point estimates. Defaults to <code>y/n</code>, but when called by <code><a href="#topic+isotInterval">isotInterval</a></code> is overridden by the actual CIR/IR point estimate.</p>
</td></tr>
<tr><td><code id="morrisCI_+3A_conf">conf</code></td>
<td>
<p>numeric, the interval's confidence level as a fraction in (0,1). Default 0.9.</p>
</td></tr>
<tr><td><code id="morrisCI_+3A_narrower">narrower</code></td>
<td>
<p>logical, if the <code>alternate</code>-produced interval is narrower at any point, should it replace the Morris result? Also, can we enforce straightforward monotonocity to narrow the bounds? Default <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="morrisCI_+3A_alternate">alternate</code></td>
<td>
<p>function to use for alternate pointwise interval. Default <code>wilconCI</code>.</p>
</td></tr>
<tr><td><code id="morrisCI_+3A_...">...</code></td>
<td>
<p>parameters passed on to <code>alternate</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The default for backup is Wilson's (<code>wilconCI</code>). Also available are Jeffrys' (<code>jeffCI</code>) and Agresti-Coull (<code>agcouCI</code>).
</p>


<h3>Value</h3>

<p>A two-column matrix with the same number of rows as <code>length(phat)</code>, containing the calculated lower and upper bounds, respectively.
</p>


<h3>Note</h3>

<p>This function found and corrected a typo in equation (4.3), namely the use of G_(j+1) in the recursion. The recursion cannot start in this way. Rather, it is the use of theta_(j+1) that delivers information from adjacent doses. Or perhaps in other words, there is only one G function rather than a different one for each dose. The correction has been verified by reproducing the numbers in the Morris (1988) example (Table 1), and also approved by the original author.
</p>


<h3>Author(s)</h3>

<p>Assaf P. Oron <code>&lt;assaf.oron.at.gmail.com&gt;</code>
</p>


<h3>References</h3>

<p>Morris, M., 1988. Small-sample confidence limits for parameters under inequality constraints with application to quantal bioassay. Biometrics 44, 1083-1092.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+isotInterval">isotInterval</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Interesting run (#664) from a simulated up-and-down ensemble:
# (x will be auto-generated as dose levels 1:5)
dat=doseResponse(y=c(1/7,1/8,1/2,1/4,4/17),wt=c(7,24,20,12,17))
# The experiment's goal is to find the 30th percentile
slow1=cirPAVA(dat,full=TRUE)
# Default interval (Morris+Wilson); same as you get by directly calling 'quickIsotone'
int1=isotInterval(slow1)
# Morris without Wilson; the 'narrower=FALSE' argument is passed on to 'morrisCI'
int1_0=isotInterval(slow1,narrower=FALSE)
# Wilson without Morris
int2=isotInterval(slow1,intfun=wilsonCI)
# Agresti=Coull (the often-used "plus 2")
int3=isotInterval(slow1,intfun=agcouCI)
# Jeffrys (Bayesian-inspired) is also available
int4=isotInterval(slow1,intfun=jeffCI)

### Showing the data and the intervals
par(mar=c(3,3,4,1),mgp=c(2,.5,0),tcl=-0.25)
plot(dat,ylim=c(0,0.65),refsize=4,las=1,main="Forward-Estimation CIs") # uses plot.doseResponse()

# The true response function; true target is where it crosses the y=0.3 line
lines(seq(0,7,0.1),pweibull(seq(0,7,0.1),shape=1.1615,scale=8.4839),col=4)

lines(int1$ciLow,lty=2,col=2,lwd=2) 
lines(int1$ciHigh,lty=2,col=2,lwd=2) 

lines(int1_0$ciLow,lty=2) 
lines(int1_0$ciHigh,lty=2) 

lines(int2$ciLow,lty=2,col=3) 
lines(int2$ciHigh,lty=2,col=3) 
# Plotting the remaining 2 is skipped, as they are very similar to Wilson.

# Note how the default (red) boundaries take the tighter of the two options everywhere, 
# except for one place (dose 1 upper bound) where they go even tighter thanks to monotonicity 
# enforcement. This can often happen when sample size is uneven; since bounds tend to be 
# conservative it is rather safe to do.

legend('topleft',pch=c(NA,'X',NA,NA,NA),lty=c(1,NA,2,2,2),col=c(4,1,2,1,3),lwd=c(1,1,2,1,1),legend
=c('True Curve','Observations','Morris+Wilson (default)','Morris only','Wilson only'),bty='n')

</code></pre>

<hr>
<h2 id='oldPAVA'>&quot;Old School&quot; isotonic-regression point estimates, with flexible dose-response input</h2><span id='topic+oldPAVA'></span>

<h3>Description</h3>

<p>Nonparametric forward point estimation of a monotone response (y), using the standard isotonic-regression pool-adjacent-violators algorithm (PAVA). Core code from Raubertas (1994) with many modifications.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>oldPAVA(
  y,
  x = NULL,
  wt = rep(1, length(x)),
  outx = NULL,
  full = FALSE,
  dec = FALSE,
  adaptiveShrink = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="oldPAVA_+3A_y">y</code></td>
<td>
<p>can be either of the following: y values (response rates), a 2-column matrix with positive/negative response counts by dose, a <code><a href="#topic+DRtrace">DRtrace</a></code> object or a <code><a href="#topic+doseResponse">doseResponse</a></code> object.</p>
</td></tr>
<tr><td><code id="oldPAVA_+3A_x">x</code></td>
<td>
<p>dose levels (if not included in y). Note that the PAV algorithm doesn't really use them.</p>
</td></tr>
<tr><td><code id="oldPAVA_+3A_wt">wt</code></td>
<td>
<p>weights (if not included in y).</p>
</td></tr>
<tr><td><code id="oldPAVA_+3A_outx">outx</code></td>
<td>
<p>vector of x values for which predictions will be made. If <code>NULL</code> (default), this will be set to the set of unique values in the x argument (or equivalently in y$x). Non-NULL inputs are relevant only if <code>full=TRUE</code>.</p>
</td></tr>
<tr><td><code id="oldPAVA_+3A_full">full</code></td>
<td>
<p>logical, is a more complete output desired? if <code>FALSE</code> (default), only a vector of point estimates for y at the provided dose levels is returned</p>
</td></tr>
<tr><td><code id="oldPAVA_+3A_dec">dec</code></td>
<td>
<p>logical, is the true function is assumed to be monotone decreasing? Default <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="oldPAVA_+3A_adaptiveshrink">adaptiveShrink</code></td>
<td>
<p>logical, should the y-values be pre-shrunk towards an experimental target? May be relevant if data were obtain via an adaptive dose-finding design. See <code><a href="#topic+DRshrink">DRshrink</a></code>.</p>
</td></tr>
<tr><td><code id="oldPAVA_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to the constructor functions that pre-process the input.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Compute the isotonic regression (IR) point estimate of a numeric input vector <code>y</code>, with weights <code>wt</code>, with respect to simple order. The core algorithm is still the one coded by R.F. Raubertas, dated 02 Sep 1994. However, the input and output modules have been
modified to allow more flexible formats in either direction. The output is also compatible with the convenience wrapper <code><a href="#topic+quickIsotone">quickIsotone</a></code>; however you will have to set <code>estfun = oldPAVA</code> to get it to run IR rather than centered isotonic regression (CIR) which is the default for all wrapper functions in this package.
</p>
<p>Note that unlike CIR (see <code><a href="#topic+cirPAVA">cirPAVA</a></code>), this algorithm does not use the dose (x) values at all. For a discussion why CIR is preferred over the &quot;plain-vanilla&quot; PAVA of this function, see Oron and Flournoy (2017).
</p>


<h3>Value</h3>

<p>under default, returns a vector of y estimates at unique x values. With <code>full=TRUE</code>, returns a list of 3 <code><a href="#topic+doseResponse">doseResponse</a></code> objects named <code>output,input,shrinkage</code> for the output data at dose levels, the input data, and the function as fit at algorithm-generated points, respectively. For this function, the first and third objects are identical.
</p>


<h3>Author(s)</h3>

<p>C.R. Raubertas, Assaf P. Oron <code>&lt;assaf.oron.at.gmail.com&gt;</code>
</p>


<h3>References</h3>

<p>Oron, A.P. and Flournoy, N., 2017. Centered Isotonic Regression: Point and Interval Estimation for Dose-Response Studies. Statistics in Biopharmaceutical Research, In Press (author's public version available on arxiv.org).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cirPAVA">cirPAVA</a></code>
</p>

<hr>
<h2 id='plot.DRtrace'>Plotting Methods for DRtrace, doseResponse Objects</h2><span id='topic+plot.DRtrace'></span><span id='topic+plot.doseResponse'></span>

<h3>Description</h3>

<p>Plotting methods for <code><a href="#topic+doseResponse">doseResponse</a></code> and <code><a href="#topic+DRtrace">DRtrace</a></code> classes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'DRtrace'
plot(
  x,
  xlab = "Patient Order",
  ylab = "Dose",
  shape = "circle",
  connect = TRUE,
  mcol = 1,
  dosevals = NULL,
  offset = 0.2,
  ...
)

## S3 method for class 'doseResponse'
plot(
  x,
  xlab = "Dose",
  ylab = "Response",
  pch = "X",
  varsize = TRUE,
  refsize = sqrt(1/mean(x$weight)),
  connect = FALSE,
  mcol = 1,
  dosevals = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.DRtrace_+3A_x">x</code></td>
<td>
<p>the object, whether DRtrace or doseResponse</p>
</td></tr>
<tr><td><code id="plot.DRtrace_+3A_xlab">xlab</code>, <code id="plot.DRtrace_+3A_ylab">ylab</code></td>
<td>
<p>x-axis and y-axis labels passed on to <code><a href="base.html#topic+plot">plot</a></code></p>
</td></tr>
<tr><td><code id="plot.DRtrace_+3A_shape">shape</code></td>
<td>
<p>the plotting shape (DRtrace only): 'circle' (default), 'square', or 'triangle'</p>
</td></tr>
<tr><td><code id="plot.DRtrace_+3A_connect">connect</code></td>
<td>
<p>logical: whether to connect the symbols (generic plotting type 'b'). Default <code>TRUE</code> for <code><a href="#topic+DRtrace">DRtrace</a></code> and <code>FALSE</code> for <code><a href="#topic+doseResponse">doseResponse</a></code></p>
</td></tr>
<tr><td><code id="plot.DRtrace_+3A_mcol">mcol</code></td>
<td>
<p>The color of the main plotting symbols and connecting lines. Default 1 (the current palette's first color). Note: if you change the color and inadvertently use <code>col</code> instead, there will be an error message.</p>
</td></tr>
<tr><td><code id="plot.DRtrace_+3A_dosevals">dosevals</code></td>
<td>
<p>Dose values to be plotted along the x-axis (<code>plot.doseResponse</code>) or y-axis (<code>plot.DRtrace</code>) . If <code>NULL</code> (default), those will be the doses in the dataset (i.e.,<code>sort(unique(x$x))</code>).</p>
</td></tr>
<tr><td><code id="plot.DRtrace_+3A_offset">offset</code></td>
<td>
<p>(<code>DRtrace</code> only) In case of a cohort-based experiment, the relative vertical offset between symbols for outcomes within the same cohort (as fraction of dose spacing). Default 0.2.</p>
</td></tr>
<tr><td><code id="plot.DRtrace_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to <code><a href="base.html#topic+plot">plot</a></code>.
</p>
<p>Conversely, putting values on a different scale into <code>dosevals</code>, or even text labels instead of numbers, won't work. For the former, change the scale at the source data (i.e., in the plotted object). For the latter, sorry but no solution at present.</p>
</td></tr>
<tr><td><code id="plot.DRtrace_+3A_pch">pch</code></td>
<td>
<p>the plotting character (doseResponse only), the default being 'X' marks</p>
</td></tr>
<tr><td><code id="plot.DRtrace_+3A_varsize">varsize</code></td>
<td>
<p>(<code>doseResponse</code> only) logical, should symbol size vary by sample size? Default <code>TRUE</code></p>
</td></tr>
<tr><td><code id="plot.DRtrace_+3A_refsize">refsize</code></td>
<td>
<p>(<code>doseResponse</code> only) a reference size by which the plotting sizes will be multiplied. Default is <code>1/sqrt(mean(dr$weight))</code>, scaled so that if <code>varsize = TRUE</code> the weighted-average symbol size is 1. If <code>varsize = FALSE</code>, this argument is equivalent to <code>cex</code> in an ordinary x-y <code>plot()</code> call.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Generic methods for dose-response trajectory/trace (<code><a href="#topic+DRtrace">DRtrace</a></code>), and dose-response summary  (<code><a href="#topic+doseResponse">doseResponse</a></code>) class objects.
The <code><a href="#topic+DRtrace">DRtrace</a></code> plotting uses the typical convention of plotting dose-finding experimental trace, with dose levels (x) in the vertical axis and 1/0 responses (y) denoted via filled/empty circles, respectively. In other words, this generic plotting method is only relevant for binary 0/1 outcomes. If cohort information is provided via <code>x$cohort</code> (i.e., multiple observations considered as collected together rather than each data point sequentially), then the plotting will respect cohort structure.
The <code><a href="#topic+doseResponse">doseResponse</a></code> plotting has response rate on the y-axis and dose on the x-axis, and plots symbols whose area is proportional to the weights.
</p>


<h3>Author(s)</h3>

<p>Assaf P. Oron <code>&lt;assaf.oron.at.gmail.com&gt;</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+doseResponse">doseResponse</a></code>, <code><a href="#topic+DRtrace">DRtrace</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Summary of raw data from the notorious Neuenschwander et al. (Stat. Med., 2008) trial
## Note the use of the 'cohort' argument to specify the cohort order
neundatTrace = DRtrace(x = c(rep(1:4, c(3,4,5,4) ), 7, 7, rep(6,9)),
                       y = c(rep(0,16), 1,1, rep(c(0,0,1),2), 0,0,0), 
                       cohort = rep(1:8, c(3,4,5,4, 2, 3,3,3)) )
par(mar=c(3,3,3,1), mgp=c(2,.5,0), tcl=-0.25)
layout(t(1:2))
plot(neundatTrace ,main="N. et al. (2008) Trajectory", xlab = 'Cohort', 
          ylab="Ordinal Dose Level" ,cex.main=1.5)

## Same data, in 'doseResponse' format with actual doses rather than dose levels
neundatDose = doseResponse(x=c(1,2.5,5,10,20,25), y = c(rep(0,4),2/9,1), wt = c(3,4,5,4,9,2) )
plot(neundatDose ,main="N. et al. (2008) Final Dose-Toxicity", ylim=c(0,1),
	xlab="Dose (mg/sq.m./wk)", ylab="Toxicity Response Curve (F)", cex.main=1.5)
## We can also convert the DRtrace object to doseResponse...
neundatLevel = doseResponse(neundatTrace)

### Now plotting the former, vs. IR/CIR estimates
neunCIR0 = cirPAVA(neundatDose,full=TRUE, adaptiveShrink = TRUE, target = 0.3)
lines(neunCIR0$shrinkage$x, neunCIR0$shrinkage$y)
legend(1,1, pch=c(4,NA), lty = 0:1, legend=c('Observations', 'CIR w/bias corr.'), bty='n')
</code></pre>

<hr>
<h2 id='quickInverse'>Convenient point and Interval Inverse Estimation (&quot;Dose-Finding&quot;), using CIR or IR</h2><span id='topic+quickInverse'></span>

<h3>Description</h3>

<p>Convenience wrapper for point and interval estimation of the &quot;dose&quot; that would generate a <code>target</code> &quot;response&quot; value, using CIR and IR.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>quickInverse(
  y,
  x = NULL,
  wt = NULL,
  target,
  estfun = cirPAVA,
  intfun = morrisCI,
  delta = TRUE,
  conf = 0.9,
  resolution = 100,
  extrapolate = FALSE,
  adaptiveShrink = FALSE,
  starget = target[1],
  adaptiveCurve = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="quickInverse_+3A_y">y</code></td>
<td>
<p>can be either of the following: y values (response rates), a 2-column matrix with positive/negative response counts by dose, a <code><a href="#topic+DRtrace">DRtrace</a></code> object or a <code><a href="#topic+doseResponse">doseResponse</a></code> object.</p>
</td></tr>
<tr><td><code id="quickInverse_+3A_x">x</code></td>
<td>
<p>dose levels (if not included in y).</p>
</td></tr>
<tr><td><code id="quickInverse_+3A_wt">wt</code></td>
<td>
<p>weights (if not included in y).</p>
</td></tr>
<tr><td><code id="quickInverse_+3A_target">target</code></td>
<td>
<p>A vector of target response rate(s), for which the percentile dose estimate is needed. See Note.</p>
</td></tr>
<tr><td><code id="quickInverse_+3A_estfun">estfun</code></td>
<td>
<p>the function to be used for point estimation. Default <code><a href="#topic+cirPAVA">cirPAVA</a></code>.</p>
</td></tr>
<tr><td><code id="quickInverse_+3A_intfun">intfun</code></td>
<td>
<p>the function to be used for interval estimation. Default <code><a href="#topic+morrisCI">morrisCI</a></code> (see help on that function for additional options).</p>
</td></tr>
<tr><td><code id="quickInverse_+3A_delta">delta</code></td>
<td>
<p>logical: should intervals be calculated using the delta (&quot;local&quot;) method (default, <code>TRUE</code>) or back-drawn directly from the forward bounds? See Details.</p>
</td></tr>
<tr><td><code id="quickInverse_+3A_conf">conf</code></td>
<td>
<p>numeric, the interval's confidence level as a fraction in (0,1). Default 0.9.</p>
</td></tr>
<tr><td><code id="quickInverse_+3A_resolution">resolution</code></td>
<td>
<p>numeric: how fine should the grid for the inverse-interval approximation be? Default 100, which seems to be quite enough. See 'Details'.</p>
</td></tr>
<tr><td><code id="quickInverse_+3A_extrapolate">extrapolate</code></td>
<td>
<p>logical: should extrapolation beyond the range of estimated y values be allowed? Default <code>FALSE</code>. Note this affects only the point estimate; interval boundaries are not extrapolated.</p>
</td></tr>
<tr><td><code id="quickInverse_+3A_adaptiveshrink">adaptiveShrink</code></td>
<td>
<p>logical, should the y-values be pre-shrunk towards an experiment's target? Recommended when the data were obtained via an adaptive dose-finding design. See <code><a href="#topic+DRshrink">DRshrink</a></code> and the Note below.</p>
</td></tr>
<tr><td><code id="quickInverse_+3A_starget">starget</code></td>
<td>
<p>The shrinkage target. Defaults to <code>target[1]</code>.</p>
</td></tr>
<tr><td><code id="quickInverse_+3A_adaptivecurve">adaptiveCurve</code></td>
<td>
<p>logical, should the CIs be expanded by using a parabolic curve between estimation points rather than straight interpolation (default <code>FALSE</code>)? Recommended when adaptive design was used and <code>target</code> is not 0.5.</p>
</td></tr>
<tr><td><code id="quickInverse_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to <code><a href="#topic+doseFind">doseFind</a></code> and <code><a href="#topic+quickIsotone">quickIsotone</a></code>, and onwards from there.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The inverse point estimate is calculated in a straightforward manner from a forward estimate, using <code><a href="#topic+doseFind">doseFind</a></code>. For the inverse interval, the default option (<code>delta=TRUE</code>) calls <code><a href="#topic+deltaInverse">deltaInverse</a></code> for a &quot;local&quot; (Delta) inversion of the forward intervals.
If <code>delta=FALSE</code>, a second call to <code><a href="#topic+quickIsotone">quickIsotone</a></code> generates a high-resolution grid outlining the forward intervals. Then the algorithm &quot;draws a horizontal line&quot; at <code>y=target</code> to find the right and left bounds on this grid. Note that the right (upper) dose-finding confidence bound is found on the lower forward confidence bound, and vice versa. This approach is not recommended, tending to produce CIs that are too wide.
</p>
<p>If the data were obtained from an adaptive dose-finding design and you seek to estimate a dose other than the experiment's target, note that away from the target the estimates are likely biased (Flournoy and Oron, 2019). Use <code>adaptiveShrink=TRUE</code> to mitigate the bias. In addition, either provide the true target as <code>starget</code>, or a vector of values to <code>target</code>, with the first value being the true target.
</p>


<h3>Value</h3>

<p>A data frame with 4 elements:
</p>

<ul>
<li> <p><code>target</code>: The user-provided target values of y, at which x is estimated
</p>
</li>
<li> <p><code>point</code>: The point estimates of x
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;lowerPPconf,upperPPconf&#8288;</code>: the interval-boundary estimates for a 'PP'=<code>100*conf</code> confidence interval
</p>
</li></ul>



<h3>References</h3>

<p>Flournoy N and Oron AP, 2020. Bias Induced by Adaptive Dose-Finding Designs. Journal of Applied Statistics 47, 2431-2442.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+quickIsotone">quickIsotone</a></code>,<code><a href="#topic+doseFind">doseFind</a></code>,<code><a href="#topic+deltaInverse">deltaInverse</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Interesting run (#664) from a simulated up-and-down ensemble:
# (x will be auto-generated as dose levels 1:5)
dat=doseResponse(y=c(1/7,1/8,1/2,1/4,4/17),wt=c(7,24,20,12,17))
# The experiment's goal is to find the 30th percentile
inv1=quickInverse(dat, target=0.3, adaptiveShrink = TRUE, adaptiveCurve = TRUE)
# With old PAVA as the forward estimator, and without the adaptive-design corrections:
inv0=quickInverse(dat, target=0.3, estfun=oldPAVA)


### Showing the data and the estimates
par(mar=c(3,3,1,1), mgp=c(2,.5,0), tcl=-0.25)
plot(dat, ylim=c(0.05,0.55), las=1) # uses plot.doseResponse()

# The true response function; true target is where it crosses the y=0.3 line
lines(seq(1,5,0.1),pweibull(seq(1,5,0.1),shape=1.1615,scale=8.4839),col=4)
abline(h=0.3,col=2,lty=3)
# Plotting the point estimates, as "tick" marks on the y=0.3 line
lines(rep(inv1$point,2),c(0.25,0.35), lwd=1.5) # CIR
lines(rep(inv0$point,2),c(0.25,0.35),lty=2, lwd=1.5) # IR
# You could plot the CIs too, 
# Here's code to plot the CIR 90% CI as a light-green rectangle:
# rect(inv1$lower90conf,0.25,inv1$upper90conf,0.35,col=rgb(0,1,0,alpha=0.3),border=NA)
#  Intervals are plotted and interval options are explored more extensively 
#       in the 'deltaInverse' help page.

legend('topleft',pch=c(NA,'X',NA,NA),lty=c(1,NA,2,1),col=c(4,1,1,1),
	legend=c('True Curve','Observations','IR Estimate','CIR Estimate'),bty='n')

</code></pre>

<hr>
<h2 id='quickIsotone'>Convenient Forward point and interval estimation via CIR or IR</h2><span id='topic+quickIsotone'></span>

<h3>Description</h3>

<p>One-Stop-shop Forward point and confidence-interval estimation of a monotone response (y) as a function of dose (x), using centered-isotonic-regression (CIR, default) or isotonic regression. Input format is rather flexible.
This function calls <code><a href="#topic+cirPAVA">cirPAVA</a></code>, <code><a href="#topic+oldPAVA">oldPAVA</a></code>, or a user-written function, for the point estimate, then <code><a href="#topic+isotInterval">isotInterval</a></code> for the confidence interval. Vector input is allowed, but the preferred input format is a <code><a href="#topic+doseResponse">doseResponse</a></code> object.
An analogous function for dose-finding (inverse estimation) is <code><a href="#topic+quickInverse">quickInverse</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>quickIsotone(
  y,
  x = NULL,
  wt = NULL,
  outx = NULL,
  dec = FALSE,
  estfun = cirPAVA,
  intfun = morrisCI,
  conf = 0.9,
  adaptiveShrink = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="quickIsotone_+3A_y">y</code></td>
<td>
<p>can be either of the following: y values (response rates), a 2-column matrix with positive/negative response counts by dose, a <code><a href="#topic+DRtrace">DRtrace</a></code> object or a <code><a href="#topic+doseResponse">doseResponse</a></code> object.</p>
</td></tr>
<tr><td><code id="quickIsotone_+3A_x">x</code></td>
<td>
<p>dose levels (if not included in y). Note that the PAV algorithm doesn't really use them.</p>
</td></tr>
<tr><td><code id="quickIsotone_+3A_wt">wt</code></td>
<td>
<p>weights (if not included in y).</p>
</td></tr>
<tr><td><code id="quickIsotone_+3A_outx">outx</code></td>
<td>
<p>vector of x values for which predictions will be made. If <code>NULL</code> (default), this will be set to the set of unique values in the <code>x</code> argument (or equivalently in <code>y$x</code>).</p>
</td></tr>
<tr><td><code id="quickIsotone_+3A_dec">dec</code></td>
<td>
<p>logical, is the true function assumed to be monotone decreasing rather than increasing? Default <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="quickIsotone_+3A_estfun">estfun</code></td>
<td>
<p>the function to be used for point estimation. Default <code><a href="#topic+cirPAVA">cirPAVA</a></code>.</p>
</td></tr>
<tr><td><code id="quickIsotone_+3A_intfun">intfun</code></td>
<td>
<p>the function to be used for interval estimation. Default <code><a href="#topic+wilsonCI">wilsonCI</a></code> (see help on that function for additional options).</p>
</td></tr>
<tr><td><code id="quickIsotone_+3A_conf">conf</code></td>
<td>
<p>numeric, the interval's confidence level as a fraction in (0,1). Default 0.9.</p>
</td></tr>
<tr><td><code id="quickIsotone_+3A_adaptiveshrink">adaptiveShrink</code></td>
<td>
<p>logical, should the y-values be pre-shrunk towards an experiment's target? Recommended if data were obtained via an adaptive dose-finding design. If <code>TRUE</code>, then must also provide a <code>target</code> argument that will be passed via <code>...</code>.</p>
</td></tr>
<tr><td><code id="quickIsotone_+3A_...">...</code></td>
<td>
<p>arguments passed on to other functions (constructor, point estimate and interval estimate).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with 4 variables:
</p>

<ul>
<li> <p><code>x</code> either the input x values, or <code>outx</code> if specified;
</p>
</li>
<li> <p><code>y</code>  he point estimates of x;
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;lowerPPconf,upperPPconf&#8288;</code> the interval-boundary estimates for a <code>PP</code>=<code>100*conf</code> confidence interval.
</p>
</li></ul>



<h3>Note</h3>

<p>You can obtain interpolated point estimates for x values between the observed data by specifying them via <code>outx</code>. However, for CIR, do NOT commit the error of generating estimates at observations, then interpolating using <code><a href="stats.html#topic+approx">approx</a></code>. If you need to retain a set of estimates for plotting the entire fitted curve, or for future interpolation at unknown points, call <code><a href="#topic+cirPAVA">cirPAVA</a></code> directly with <code>full=TRUE</code>, then use the returned <code>shrinkage</code> data frame for plotting and interpolation. See example code below.
</p>
<p>If the data were obtained from an adaptive dose-finding design then away from the design's target the estimates are likely biased (Flournoy and Oron, 2020). Use <code>adaptiveShrink=TRUE</code> to mitigate the bias.
</p>


<h3>Author(s)</h3>

<p>Assaf P. Oron <code>&lt;assaf.oron.at.gmail.com&gt;</code>
</p>


<h3>References</h3>

<p>Oron, A.P. and Flournoy, N., 2017. Centered Isotonic Regression: Point and Interval Estimation for Dose-Response Studies. Statistics in Biopharmaceutical Research 9, 258-267. (author's public version available on arxiv.org).
</p>
<p>Flournoy, N. and Oron, A.P., 2020. Bias Induced by Adaptive Dose-Finding Designs. Journal of Applied Statistics 47, 2431-2442.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cirPAVA">cirPAVA</a></code>,<code><a href="#topic+oldPAVA">oldPAVA</a></code>,<code><a href="#topic+isotInterval">isotInterval</a></code>,<code><a href="#topic+quickInverse">quickInverse</a></code>,<code><a href="#topic+doseResponse">doseResponse</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Interesting run (#664) from a simulated up-and-down ensemble:
# (x will be auto-generated as dose levels 1:5)
dat=doseResponse(y=c(1/7,1/8,1/2,1/4,4/17),wt=c(7,24,20,12,17))
# CIR, using the default 'quick' function that also provides CIs (default 90%).
# The experiment's goal is to find the 30th percentile. We deploy the empirical bias correction.
quick1=quickIsotone(dat, adaptiveShrink = TRUE, adaptiveCurve = TRUE, target = 0.3)
quick1
# Use 'estfun' argument to operate the same function with old PAVA as the estimator
# Here we neglect the bias correction to sharpen the old:new contrast
quick0=quickIsotone(dat,estfun=oldPAVA)
quick0

### Showing the data and the fits
par(mar=c(3,3,1,1),mgp=c(2,.5,0),tcl=-0.25)
plot(dat, ylim=c(0.05,0.55), las=1) # uses plot.doseResponse()
# The IR fit: a straightforward interpolation
lines(quick0$y,lty=2) 

# With CIR, 'quickIsotone' cannot show us the true underlying interpolation; 
# it only provides the estimates at requested points.  Interpolation should be done between 
# shrinkage points, not the original design points. So we must call the full 'cirPAVA' function:

slow1 = cirPAVA(dat, full=TRUE, adaptiveShrink = TRUE, adaptiveCurve = TRUE, target = 0.3)
# Now, compare these 3 (the first one is wrong, b/c it interpolates from design points):
midpts = 1:4 + 0.5
approx(1:5,quick1$y, xout=midpts)$y
# instead, you can just call 'quickIsotone' and specify 'outx'
quickIsotone(dat,outx=midpts , adaptiveShrink = TRUE, adaptiveCurve = TRUE, target = 0.3) 
approx(slow1$shrinkage$x,slow1$shrinkage$y,xout=midpts)$y # Or use 'cirPAVA'

# Ok... finally plotting the CIR curve
# Both flat intervals are shrunk, because neither are at y=0 or y=1
lines(slow1$shrinkage$x,slow1$shrinkage$y, lwd = 2)

# Last but not least, here's the true response function
lines(seq(1,5,0.1),pweibull(seq(1,5,0.1),shape=1.1615,scale=8.4839),col=2)
legend('topleft',pch=c(NA,'X',NA,NA),lty=c(1,NA,2,1),col=c(2,1,1,1),
	legend=c('True Curve','Observations','IR','CIR'), bty='n')
</code></pre>

<hr>
<h2 id='slope'>Piecewise-linear local slopes given a (non-strictly) monotone x-y sequence</h2><span id='topic+slope'></span>

<h3>Description</h3>

<p>Estimate monotone piecewise-linear slopes, with the default behavior forbidding zero slope. This behavior is due to the fact that the function is used to invert confidence intervals using the Delta method. The input interval has to be strictly increasing in <code>x</code>, and (non-strictly) monotone in <code>y</code> (increasing or decreasing).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>slope(
  x,
  y,
  outx = x,
  allowZero = FALSE,
  tol = 0.01,
  full = FALSE,
  decreasing = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="slope_+3A_x">x</code></td>
<td>
<p>numeric or integer: input x values, must be strictly increasing</p>
</td></tr>
<tr><td><code id="slope_+3A_y">y</code></td>
<td>
<p>numeric: input y values, must be monotone (can be non-strict) and in line with the direction specified by <code>decreasing</code></p>
</td></tr>
<tr><td><code id="slope_+3A_outx">outx</code></td>
<td>
<p>numeric or integer: x values at which slopes are desired (default: same as input values)</p>
</td></tr>
<tr><td><code id="slope_+3A_allowzero">allowZero</code></td>
<td>
<p>logical: should zero be allowed in the output? Default <code>FALSE</code></p>
</td></tr>
<tr><td><code id="slope_+3A_tol">tol</code></td>
<td>
<p>tolerance level: when <code>allowZero=FALSE</code>, slope below that value is considered zero. Default 1e-2. Might need to change if you use unusual units for x or y.</p>
</td></tr>
<tr><td><code id="slope_+3A_full">full</code></td>
<td>
<p>logical: should a more detailed output be provided? Default <code>FALSE</code> (see details under 'Value').</p>
</td></tr>
<tr><td><code id="slope_+3A_decreasing">decreasing</code></td>
<td>
<p>logical: is input supposed to be monotone decreasing rather than increasing? Default <code>FALSE</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>At design points (i.e., the input <code>x</code> values), the function takes the average between the left and right slopes (on the edges the inside slope is technically replicated to the outside). If <code>allowZero=FALSE</code> (default), the algorithm gradually expands the x range over which slope is observed (by increments of one average <code>x</code> spacing), until a positive slope results. If the input is completely flat in <code>y</code> and <code>allowZero=FALSE</code>, the function returns <code>NA</code>s.
</p>


<h3>Value</h3>

<p>If <code>full=FALSE</code>, returns a vector of slopes at the points specified by <code>outx</code>.
</p>
<p>If <code>full=TRUE</code>, returns a list with slopes at the design point (<code>rawslopes</code>), the initial guess at output slopes (<code>initial</code>), and the official final ones (<code>final</code>).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+deltaInverse">deltaInverse</a></code>, which uses this function.
</p>

<hr>
<h2 id='wilsonCI'>Standard unordered-Binomial confidence interval utilities.</h2><span id='topic+wilsonCI'></span><span id='topic+agcouCI'></span><span id='topic+jeffCI'></span>

<h3>Description</h3>

<p>Standard small-sample Binomial confidence interval utilities, using the methods of Wilson, Agresti-Coull and Jeffrys.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wilsonCI(phat, n, conf = 0.9, ...)

agcouCI(phat, n, conf = 0.9, ...)

jeffCI(phat, n, conf = 0.9, w1 = 0.5, w2 = w1, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="wilsonCI_+3A_phat">phat</code></td>
<td>
<p>numeric vector, point estimates for which an interval is sought</p>
</td></tr>
<tr><td><code id="wilsonCI_+3A_n">n</code></td>
<td>
<p>integer vector of same length, of pointwise sample sizes</p>
</td></tr>
<tr><td><code id="wilsonCI_+3A_conf">conf</code></td>
<td>
<p>numeric in (0,1), the confidence level</p>
</td></tr>
<tr><td><code id="wilsonCI_+3A_...">...</code></td>
<td>
<p>pass-through for compatibility with a variety of calling functions</p>
</td></tr>
<tr><td><code id="wilsonCI_+3A_w1">w1</code>, <code id="wilsonCI_+3A_w2">w2</code></td>
<td>
<p>numeric, weights used in <code>jeffCI</code> only</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions implement the basic (uncorrected) three intervals which are seen by the consensus of literature as the &quot;safest&quot; off-the-shelf formulae. None of them account for ordering or monotonicity; therefore the <code>cir</code> package default is <code><a href="#topic+morrisCI">morrisCI</a></code> which does account for that, with the 3 unordered formulae used for optional narrowing of the interval at individual points.
</p>


<h3>Value</h3>

<p>A two-column matrix with the same number of rows as <code>length(phat)</code>, containing the calculated lower and upper bounds, respectively.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+isotInterval">isotInterval</a></code> for more details about how forward CIs are calculated, <code><a href="#topic+quickInverse">quickInverse</a></code> for inverse (dose-finding) intervals.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Interesting run (#664) from a simulated up-and-down ensemble:
# (x will be auto-generated as dose levels 1:5)
dat=doseResponse(y=c(1/7,1/8,1/2,1/4,4/17),wt=c(7,24,20,12,17))
# The experiment's goal is to find the 30th percentile
slow1=cirPAVA(dat,full=TRUE)
# Default interval (Morris+Wilson); same as you get by directly calling 'quickIsotone'
int1=isotInterval(slow1)
# Morris without Wilson; the 'narrower=FALSE' argument is passed on to 'morrisCI'
int1_0=isotInterval(slow1,narrower=FALSE)
# Wilson without Morris
int2=isotInterval(slow1,intfun=wilsonCI)
# Agresti=Coull (the often-used "plus 2")
int3=isotInterval(slow1,intfun=agcouCI)
# Jeffrys (Bayesian-inspired) is also available
int4=isotInterval(slow1,intfun=jeffCI)

### Showing the data and the intervals
par(mar=c(3,3,4,1),mgp=c(2,.5,0),tcl=-0.25)
plot(dat,ylim=c(0,0.65),refsize=4,las=1,main="Forward-Estimation CIs") # uses plot.doseResponse()

# The true response function; true target is where it crosses the y=0.3 line
lines(seq(0,7,0.1),pweibull(seq(0,7,0.1),shape=1.1615,scale=8.4839),col=4)

lines(int1$ciLow,lty=2,col=2,lwd=2) 
lines(int1$ciHigh,lty=2,col=2,lwd=2) 

lines(int1_0$ciLow,lty=2) 
lines(int1_0$ciHigh,lty=2) 

lines(int2$ciLow,lty=2,col=3) 
lines(int2$ciHigh,lty=2,col=3) 
# Plotting the remaining 2 is skipped, as they are very similar to Wilson.

# Note how the default (red) boundaries take the tighter of the two options everywhere, 
# except for one place (dose 1 upper bound) where they go even tighter thanks to monotonicity 
# enforcement. This can often happen when sample size is uneven; since bounds tend to be 
# conservative it is rather safe to do.

legend('topleft',pch=c(NA,'X',NA,NA,NA),lty=c(1,NA,2,2,2),col=c(4,1,2,1,3),lwd=c(1,1,2,1,1),legend
=c('True Curve','Observations','Morris+Wilson (default)','Morris only','Wilson only'),bty='n')

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
