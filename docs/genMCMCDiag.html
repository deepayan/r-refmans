<!DOCTYPE html><html lang="en"><head><title>Help for package genMCMCDiag</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {genMCMCDiag}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#genMCMCDiag-package'><p>genMCMCDiag: Generalized Convergence Diagnostics for Difficult MCMC Algorithms</p></a></li>
<li><a href='#bnMCMCResults'><p>Results from a Bayesian Network MCMC algorithm on simulated data</p></a></li>
<li><a href='#dpmmDistance'><p>DPMM Distance</p></a></li>
<li><a href='#estimateTsTime'><p>Uses generic formulas and rough time estimate to estimate time it will take to evaluate</p>
the TS algorithm on a set of unique draws with the tsTransform function.</a></li>
<li><a href='#eucDist'><p>Euclidean Distance</p></a></li>
<li><a href='#fitNN'><p>Helpful mini function to fit the nearest neighbor (NN) algorithm given a set and</p>
defined distance</a></li>
<li><a href='#genDiagnostic'><p>Generate Generalized Diagnostics for Markov Chain Monte Carlo Draws</p></a></li>
<li><a href='#hammingDist'><p>Hamming Distance</p></a></li>
<li><a href='#lanfearTransform'><p>Transforms a list of MCMC chains into a list of data.frames using the Lanfear transformation</p></a></li>
<li><a href='#listLabels'><p>Function to assign character labels to all unique objects in a list</p></a></li>
<li><a href='#partitionDist'><p>Partition Distance</p></a></li>
<li><a href='#print.mcmcDiag'><p>Print method for mcmcDiag objects</p></a></li>
<li><a href='#sess'><p>Calculate the effective sample size, per chain and in total, of draws from an MCMC algorithm</p></a></li>
<li><a href='#spsrf'><p>Calculate the Gelman-Rubin diagnostic of draws from an MCMC algorithm</p></a></li>
<li><a href='#standardTransform'><p>Transforms a list of MCMC chains into a list of dataframes with no modifications to values</p></a></li>
<li><a href='#straceplot'><p>Generate a traceplot of draws from a multi-chain MCMC</p></a></li>
<li><a href='#tsTransform'><p>Transforms a list of MCMC chains into a list of data.frames using the TS transformation</p></a></li>
<li><a href='#uniMCMCResults'><p>Results from a univariate MCMC algorithm on a simulated posterior</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Generalized Convergence Diagnostics for Difficult MCMC
Algorithms</td>
</tr>
<tr>
<td>Version:</td>
<td>0.2.3</td>
</tr>
<tr>
<td>Description:</td>
<td>Trace plots and convergence diagnostics for Markov Chain Monte Carlo (MCMC) algorithms on highly multivariate or unordered spaces. Methods outlined in a forthcoming paper.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/LukeDuttweiler/genMCMCDiag">https://github.com/LukeDuttweiler/genMCMCDiag</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/LukeDuttweiler/genMCMCDiag/issues">https://github.com/LukeDuttweiler/genMCMCDiag/issues</a></td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Imports:</td>
<td>ggplot2 (&ge; 3.0.0), coda (&ge; 0.19.0), mcmcse (&ge; 1.0.0), knitr
(&ge; 1.30), lifecycle</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-01-08 18:54:36 UTC; lduttweiler</td>
</tr>
<tr>
<td>Author:</td>
<td>Luke Duttweiler <a href="https://orcid.org/0000-0002-0467-995X"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre, cph]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Luke Duttweiler &lt;lduttweiler@hsph.harvard.edu&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-01-09 00:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='genMCMCDiag-package'>genMCMCDiag: Generalized Convergence Diagnostics for Difficult MCMC Algorithms</h2><span id='topic+genMCMCDiag'></span><span id='topic+genMCMCDiag-package'></span>

<h3>Description</h3>

<p>Trace plots and convergence diagnostics for Markov Chain Monte Carlo (MCMC) algorithms on highly multivariate or unordered spaces. Methods outlined in a forthcoming paper.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Luke Duttweiler <a href="mailto:lduttweiler@hsph.harvard.edu">lduttweiler@hsph.harvard.edu</a> (<a href="https://orcid.org/0000-0002-0467-995X">ORCID</a>) [copyright holder]
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/LukeDuttweiler/genMCMCDiag">https://github.com/LukeDuttweiler/genMCMCDiag</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/LukeDuttweiler/genMCMCDiag/issues">https://github.com/LukeDuttweiler/genMCMCDiag/issues</a>
</p>
</li></ul>


<hr>
<h2 id='bnMCMCResults'>Results from a Bayesian Network MCMC algorithm on simulated data</h2><span id='topic+bnMCMCResults'></span>

<h3>Description</h3>

<p>Results from a Bayesian Network Metropolis-Hastings algorithm run on simulated data.
Included for examples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bnMCMCResults
</code></pre>


<h3>Format</h3>



<h4><code>bnMCMCResults</code></h4>

<p>A list with 5 elements, each representing a different MCMC chain. Each element is
a list of data.frames describing a partition arrangement of a Bayesian Network.
</p>



<h3>Source</h3>

<p>Luke Duttweiler
</p>

<hr>
<h2 id='dpmmDistance'>DPMM Distance</h2><span id='topic+dpmmDistance'></span>

<h3>Description</h3>

<p>For an MCMC draw from a DPMM D_x, let Z_x be the vector of Z-scores of the
observations based on that observation's current group, and let A_x be the
0,1 adjacency matrix where </p>
<p style="text-align: center;"><code class="reqn">[A_x]_{ij} = 1</code>
</p>
<p> if observations i and j are in
the same group in draw D_x (so the diagonal is always 1s).
Then we define the DPMM distance between D_x and D_y as: </p>
<p style="text-align: center;"><code class="reqn">
   d(D_x, D_y) = |Z_x - Z_y|^T(|A_x - A_y| + I)|Z_x - Z_y|.
</code>
</p>



<h3>Usage</h3>

<pre><code class='language-R'>dpmmDistance(x, y)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dpmmDistance_+3A_x">x</code></td>
<td>
<p>List with elements 'Zscore' and 'Adj'</p>
</td></tr>
<tr><td><code id="dpmmDistance_+3A_y">y</code></td>
<td>
<p>List with elements 'Zscore' and 'Adj', both of same dimensions as in x.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric, DPMM distance between x and y.
</p>


<h3>Note</h3>

<p>For speed, no error handling if x and y do not have the same dimensions. The function
will break if 'Zscore' or 'Adj' doesn't exist though.
</p>

<hr>
<h2 id='estimateTsTime'>Uses generic formulas and rough time estimate to estimate time it will take to evaluate
the TS algorithm on a set of unique draws with the tsTransform function.</h2><span id='topic+estimateTsTime'></span>

<h3>Description</h3>

<p>Uses generic formulas and rough time estimate to estimate time it will take to evaluate
the TS algorithm on a set of unique draws with the tsTransform function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimateTsTime(distance, draw1, draw2, N)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="estimateTsTime_+3A_distance">distance</code></td>
<td>
<p>Function with two parameters x,y. Used to calculate distance between
draw1 and draw2</p>
</td></tr>
<tr><td><code id="estimateTsTime_+3A_draw1">draw1</code></td>
<td>
<p>Object that works as an argument for distance()</p>
</td></tr>
<tr><td><code id="estimateTsTime_+3A_draw2">draw2</code></td>
<td>
<p>Different object that works as an argument for distance()</p>
</td></tr>
<tr><td><code id="estimateTsTime_+3A_n">N</code></td>
<td>
<p>Number of unique draws for which the user is interested in evaluating
the time to completion for the TS algorithm</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Data.frame with 1 row and 2 columns. Entry one gives the standard completion time,
entry two gives the completion time if the fuzzy approximation is used.
</p>

<hr>
<h2 id='eucDist'>Euclidean Distance</h2><span id='topic+eucDist'></span>

<h3>Description</h3>

<p>Simple function to return the Euclidean distance between two objects. Acts elementwise.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eucDist(x, y)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="eucDist_+3A_x">x</code></td>
<td>
<p>Numeric vector or matrix.</p>
</td></tr>
<tr><td><code id="eucDist_+3A_y">y</code></td>
<td>
<p>Numeric vector or matrix of same dimensions as x.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric, elementwise Euclidean distance between x and y.
</p>


<h3>Note</h3>

<p>For speed, no error handling if x and y do not have the same dimensions, take care!
</p>


<h3>Examples</h3>

<pre><code class='language-R'>eucDist(c(0,0), c(1,1))
</code></pre>

<hr>
<h2 id='fitNN'>Helpful mini function to fit the nearest neighbor (NN) algorithm given a set and
defined distance</h2><span id='topic+fitNN'></span>

<h3>Description</h3>

<p>Helpful mini function to fit the nearest neighbor (NN) algorithm given a set and
defined distance
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fitNN(uniqueDraws, uniqueLabels, distance, minDist)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fitNN_+3A_uniquedraws">uniqueDraws</code></td>
<td>
<p>List of unique values that make up the set on which we are using
the NN algorithm</p>
</td></tr>
<tr><td><code id="fitNN_+3A_uniquelabels">uniqueLabels</code></td>
<td>
<p>List of unique labels associated 1-1 with the unique values</p>
</td></tr>
<tr><td><code id="fitNN_+3A_distance">distance</code></td>
<td>
<p>Function with arguments x,y that returns a distance
defined on the given values</p>
</td></tr>
<tr><td><code id="fitNN_+3A_mindist">minDist</code></td>
<td>
<p>Minimum possible distance between two points that aren't equivalent.
May be ignored, but if possible to specify, may speed up the algorithm.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List. tsSolution gives the ordered labels, tsValues gives the ordered values,
tsDiffs is a vector of distances between consecutive values in tsValues
</p>

<hr>
<h2 id='genDiagnostic'>Generate Generalized Diagnostics for Markov Chain Monte Carlo Draws</h2><span id='topic+genDiagnostic'></span>

<h3>Description</h3>

<p>This function generates generalized diagnostics for Markov Chain Monte Carlo (MCMC) draws, transforming the draws if specified, and evaluating selected diagnostics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>genDiagnostic(
  mhDraws,
  proximityMap = c("standard", "ts", "lanfear"),
  diagnostics = c("traceplot", "ess", "psrf"),
  distance = NULL,
  verbose = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="genDiagnostic_+3A_mhdraws">mhDraws</code></td>
<td>
<p>A list of MCMC draws, where each element is an ordered list or numeric vector representing the output of a single MCMC chain.</p>
</td></tr>
<tr><td><code id="genDiagnostic_+3A_proximitymap">proximityMap</code></td>
<td>
<p>Method (called a proximity-map) for transforming the MCMC draws. Options include 'standard', 'ts', 'lanfear', or a custom function. See details.</p>
</td></tr>
<tr><td><code id="genDiagnostic_+3A_diagnostics">diagnostics</code></td>
<td>
<p>A character vector or list of diagnostic functions to be evaluated. Options include 'traceplot', 'ess', 'psrf', or custom functions. See details.</p>
</td></tr>
<tr><td><code id="genDiagnostic_+3A_distance">distance</code></td>
<td>
<p>Function for evaluating distance between MCMC draws if required by 'method'. This should be a pairwise distance function that operates on elements of the chains from mhDraws. Note that the lanfear and ts proximityMaps ALWAYS require a distance function.</p>
</td></tr>
<tr><td><code id="genDiagnostic_+3A_verbose">verbose</code></td>
<td>
<p>If TRUE, informative messages are displayed.</p>
</td></tr>
<tr><td><code id="genDiagnostic_+3A_...">...</code></td>
<td>

<p>Arguments passed on to <code><a href="#topic+tsTransform">tsTransform</a></code>, <code><a href="#topic+lanfearTransform">lanfearTransform</a></code>
</p>

<dl>
<dt><code>minDist</code></dt><dd><p>Numeric. Value which specifies the minimum possible distance for two draws
which are not equal. See tsTransform details.</p>
</dd>
<dt><code>fuzzy</code></dt><dd><p>Logical. If TRUE computes an approximate version of the TS algorithm.
See tsTransform details.</p>
</dd>
<dt><code>fuzzyDist</code></dt><dd><p>Numeric. Parameter for approximate version of ts algorithm. See tsTransform details.</p>
</dd>
<dt><code>reference</code></dt><dd><p>Argument for method = 'lanfear'. Reference point for lanfearTransform (with exact same structure as each MCMC draw)
for draw comparison. If left NULL a random point is selected from the given draws.
See lanfearTransform details.</p>
</dd>
</dl>
</td></tr>
</table>


<h3>Details</h3>

<p>Built-in proximity-maps can be called with the appropriate character string in the 'proximity-map'
argument. For details on a particular proximity-map use ?lanfearTransform or ?tsTransform,
the standard proximity-map induces no transformation. Custom proximity-map
functions may be added as well. A custom function must be written to accept a list of mcmcChain
type objects, and output a list of dataframes with columns val (the transformed draw) and t (the MCMC chain order).
Each element in the list is the transformed MCMC chain corresponding to the input.
</p>
<p>Built-in diagnostics can be called with the appropriate character string in the 'diagnostics'
argument. Current diagnostic options are 'traceplot' for traceplots, 'ess' for Effective Sample Size,
and 'psrf' for the Gelman-Rubin Potential Scale Reduction Factor.
Additional custom diagnostic functions may be written. These functions should
act on a list of data.frames output from a transform function and should output as a relatively
small data.frame where the name of diagnostic is the first row.name.
</p>


<h3>Value</h3>

<p>An object of class 'mcmcDiag', containing evaluated diagnostics, transformed draws, and function call details.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Example using standard Traceplot
tstS &lt;- genDiagnostic(uniMCMCResults)
tstS

#Example using 'lanfear' traceplot
tstL &lt;- genDiagnostic(uniMCMCResults, proximityMap = 'lanfear', distance = eucDist,
                      reference = 0)
tstL

#Example using bayesian network sample data, with 'lanfear' proximityMap
tstBN1 &lt;- genDiagnostic(bnMCMCResults, proximityMap = 'lanfear', distance = partitionDist)
tstBN1

</code></pre>

<hr>
<h2 id='hammingDist'>Hamming Distance</h2><span id='topic+hammingDist'></span>

<h3>Description</h3>

<p>Simple function to return the Hamming distance between two objects. Acts elementwise.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hammingDist(x, y)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hammingDist_+3A_x">x</code></td>
<td>
<p>Binary vector or matrix</p>
</td></tr>
<tr><td><code id="hammingDist_+3A_y">y</code></td>
<td>
<p>Binary vector or matrix of same dimensions as x.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric, elementwise Hamming distance between x and y.
</p>


<h3>Note</h3>

<p>For speed, no error handling if x and y do not have the same dimensions. Also,
does not test to make sure x,y are binary, take care!
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- matrix(c(1,0,
              0,0), nrow = 2, byrow = TRUE)
y &lt;- diag(1,2)
hammingDist(x, y)
</code></pre>

<hr>
<h2 id='lanfearTransform'>Transforms a list of MCMC chains into a list of data.frames using the Lanfear transformation</h2><span id='topic+lanfearTransform'></span>

<h3>Description</h3>

<p>Transforms a list of MCMC chains into a list of data.frames using the Lanfear transformation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lanfearTransform(mhDraws, distance, reference = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lanfearTransform_+3A_mhdraws">mhDraws</code></td>
<td>
<p>List. Each element is a single chain from an MCMC algorithm. Each element should be a numeric vector (for univariate draws), or a list.</p>
</td></tr>
<tr><td><code id="lanfearTransform_+3A_distance">distance</code></td>
<td>
<p>Distance function defined on the space of MCMC draws. Should operate pairwise on the elements of the given chains. See details.</p>
</td></tr>
<tr><td><code id="lanfearTransform_+3A_reference">reference</code></td>
<td>
<p>Argument for method = 'lanfear'. Reference point for lanfearTransform (with exact same structure as each MCMC draw)
for draw comparison. If left NULL a random point is selected from the given draws.
See lanfearTransform details.</p>
</td></tr>
<tr><td><code id="lanfearTransform_+3A_...">...</code></td>
<td>
<p>Catches extra arguments. Not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Lanfear transformation works by specifying a reference point and then comparing each
MCMC draw back to that reference point using a distance function. The function returns
this distance value as the Lanfear transformation of each draw.
</p>


<h3>Value</h3>

<p>List of data.frames with columns 'val' which is the Lanfear transformation of each MCMC
draw, and 't' which gives the within-chain ordering of the MCMC draws.
Each data.frame is a separate chain.
</p>

<hr>
<h2 id='listLabels'>Function to assign character labels to all unique objects in a list</h2><span id='topic+listLabels'></span>

<h3>Description</h3>

<p>Function to assign character labels to all unique objects in a list
</p>


<h3>Usage</h3>

<pre><code class='language-R'>listLabels(lst)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="listLabels_+3A_lst">lst</code></td>
<td>
<p>A list of objects. Each object in the list should have
the same general structure</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector of labels. Objects in lst that are identical will be assigned
the same label.
</p>

<hr>
<h2 id='partitionDist'>Partition Distance</h2><span id='topic+partitionDist'></span>

<h3>Description</h3>

<p>Function to return the 'Partition' distance between two objects. Used for Bayesian
Networks with the 'partition-MCMC' algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>partitionDist(x, y)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="partitionDist_+3A_x">x</code></td>
<td>
<p>Data.frame with columns node and partition</p>
</td></tr>
<tr><td><code id="partitionDist_+3A_y">y</code></td>
<td>
<p>Data.frame with columns node and partition. Same nrows as x.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric, Partition distance between x and y.
</p>


<h3>Note</h3>

<p>For speed, no error handling if x and y do not have the same dimensions. Also,
does not test to make sure x,y are data.frames of integers, take care!
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- bnMCMCResults[[1]][[1]]
y &lt;- bnMCMCResults[[1]][[100]]
partitionDist(x, y)
</code></pre>

<hr>
<h2 id='print.mcmcDiag'>Print method for mcmcDiag objects</h2><span id='topic+print.mcmcDiag'></span>

<h3>Description</h3>

<p>Print method for mcmcDiag objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mcmcDiag'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.mcmcDiag_+3A_x">x</code></td>
<td>
<p>Object of class mcmcDiag</p>
</td></tr>
<tr><td><code id="print.mcmcDiag_+3A_...">...</code></td>
<td>
<p>Kept for consistency with print. Does nothing.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Invisible NULL, prints to console
</p>


<h3>Examples</h3>

<pre><code class='language-R'>print(genDiagnostic(uniMCMCResults))
</code></pre>

<hr>
<h2 id='sess'>Calculate the effective sample size, per chain and in total, of draws from an MCMC algorithm</h2><span id='topic+sess'></span>

<h3>Description</h3>

<p>Calculate the effective sample size, per chain and in total, of draws from an MCMC algorithm
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sess(mhDraws, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sess_+3A_mhdraws">mhDraws</code></td>
<td>
<p>List of data.frames. Each data.frame represents a single chain. Data.frame columns for which ESS is calculated should be named val.1, ..., val.k</p>
</td></tr>
<tr><td><code id="sess_+3A_...">...</code></td>
<td>
<p>Catches unnecessary additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Data.frame with 1 Row and (# Chains + 1) Columns. Each entry gives the estimated ESS for the chain or sum of chains.
</p>

<hr>
<h2 id='spsrf'>Calculate the Gelman-Rubin diagnostic of draws from an MCMC algorithm</h2><span id='topic+spsrf'></span>

<h3>Description</h3>

<p>Calculate the Gelman-Rubin diagnostic of draws from an MCMC algorithm
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spsrf(mhDraws, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="spsrf_+3A_mhdraws">mhDraws</code></td>
<td>
<p>List of data.frames with two columns. Each data.frame represents a single chain. Column names should be val.1 (for values) and t (for chain iteration).</p>
</td></tr>
<tr><td><code id="spsrf_+3A_...">...</code></td>
<td>
<p>Catches unnecessary additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Data.frame with 1 row and 2 columns. First entry gives estimated psrf, second gives upper 95% limit for GR statistic.
</p>

<hr>
<h2 id='standardTransform'>Transforms a list of MCMC chains into a list of dataframes with no modifications to values</h2><span id='topic+standardTransform'></span>

<h3>Description</h3>

<p>Transforms a list of MCMC chains into a list of dataframes with no modifications to values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>standardTransform(mhDraws, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="standardTransform_+3A_mhdraws">mhDraws</code></td>
<td>
<p>An list of numeric vectors</p>
</td></tr>
<tr><td><code id="standardTransform_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of data.frames with rows that represent MCMC draws.Each separate data.frame is a
different chain. Data.frames have columns 'val' for the numeric draws, and 't' for the
draw. Currently, using the standard transformation on anything other than univariate
draws is not supported.
</p>

<hr>
<h2 id='straceplot'>Generate a traceplot of draws from a multi-chain MCMC</h2><span id='topic+straceplot'></span>

<h3>Description</h3>

<p>Generate a traceplot of draws from a multi-chain MCMC
</p>


<h3>Usage</h3>

<pre><code class='language-R'>straceplot(mhDraws, method = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="straceplot_+3A_mhdraws">mhDraws</code></td>
<td>
<p>List of data.frames with two columns. Each data.frame represents a single chain. Column names should be val.1 (for values) and t (for chain iteration).</p>
</td></tr>
<tr><td><code id="straceplot_+3A_method">method</code></td>
<td>
<p>Character string - Name of method used to generate traceplot. Is used to generate the title of the traceplot.</p>
</td></tr>
<tr><td><code id="straceplot_+3A_...">...</code></td>
<td>
<p>Catches unused arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>ggplot2 plot object showing traceplot
</p>

<hr>
<h2 id='tsTransform'>Transforms a list of MCMC chains into a list of data.frames using the TS transformation</h2><span id='topic+tsTransform'></span>

<h3>Description</h3>

<p>Transforms a list of MCMC chains into a list of data.frames using the TS transformation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tsTransform(
  mhDraws,
  distance,
  minDist = 0,
  fuzzy = FALSE,
  fuzzyDist = 1,
  verbose = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tsTransform_+3A_mhdraws">mhDraws</code></td>
<td>
<p>List. Each element is a single chain from an MCMC algorithm. Each element should be a numeric vector (for univariate draws), or a list.</p>
</td></tr>
<tr><td><code id="tsTransform_+3A_distance">distance</code></td>
<td>
<p>Distance function defined on the space of MCMC draws. Should operate pairwise on the elements of the given chains. See details.</p>
</td></tr>
<tr><td><code id="tsTransform_+3A_mindist">minDist</code></td>
<td>
<p>Numeric. Value which specifies the minimum possible distance for two draws
which are not equal. See tsTransform details.</p>
</td></tr>
<tr><td><code id="tsTransform_+3A_fuzzy">fuzzy</code></td>
<td>
<p>Logical. If TRUE computes an approximate version of the TS algorithm.
See tsTransform details.</p>
</td></tr>
<tr><td><code id="tsTransform_+3A_fuzzydist">fuzzyDist</code></td>
<td>
<p>Numeric. Parameter for approximate version of ts algorithm. See tsTransform details.</p>
</td></tr>
<tr><td><code id="tsTransform_+3A_verbose">verbose</code></td>
<td>
<p>Logical. If TRUE, function prints out information about approximate
computation time</p>
</td></tr>
<tr><td><code id="tsTransform_+3A_...">...</code></td>
<td>
<p>Catches extra arguments. Not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The TS transformation sets up a traveling salesman algorithm by calculating the
pair-wise distances between each unique draw from the mhDraws and solving the resulting
TS problem with the nearest neighbor (NN) algorithm.
</p>
<p>minDist can be used to speed up the algorithm if it is known that
when x != y then distance(x, y) &gt;= minDist. Otherwise this should be ignored.
</p>
<p>The fuzzy approximation of the algorithm works by splitting the unique draws into
smaller sets each containing at most 1% of all unique draws,
and fitting the NN algorithm within each set, and then on the resulting 'end points'
of each set. The sets are created by randomly selecting a representative draw and then
putting the 'closest' draws with distance less than fuzzyDist into that set,
until the set contains 1% of all unique draws. The fuzzy approximation can GREATLY
reduce computation time, unless the fuzzyDistance specified is too small.
</p>


<h3>Value</h3>

<p>List of data.frames with columns 'val' which is the TS transformation of each
MCMC draw, and 't' which gives the within-chain ordering of the MCMC draws.
Each data.frame is a separate chain.
</p>

<hr>
<h2 id='uniMCMCResults'>Results from a univariate MCMC algorithm on a simulated posterior</h2><span id='topic+uniMCMCResults'></span>

<h3>Description</h3>

<p>Results from a univariate Metropolis-Hastings algorithm run on a tri-modal posterior.
Although the standard traceplot and Gelman-Rubin diagnostic show good mixing, the results
are actually mixing poorly. Included for examples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>uniMCMCResults
</code></pre>


<h3>Format</h3>



<h4><code>uniMCMCResults</code></h4>

<p>A list with 7 elements, each representing a different MCMC chain. Each element is
a numeric vector of length 2000
</p>



<h3>Source</h3>

<p>Luke Duttweiler
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
