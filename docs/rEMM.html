<!DOCTYPE html><html><head><title>Help for package rEMM</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {rEMM}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#16S'><p>Count Data for 16S rRNA Sequences</p></a></li>
<li><a href='#build'><p>Building an EMM using New Data</p></a></li>
<li><a href='#cluster'><p>Data stream clustering with tNN</p></a></li>
<li><a href='#combine'><p>Combining EMM Objects</p></a></li>
<li><a href='#Derwent'><p>Derwent Catchment Data</p></a></li>
<li><a href='#DSC_EMM'>
<p>DSC Interface for EMM and tNN (package stream)</p></a></li>
<li><a href='#EMM'>
<p>Creator for Class &quot;EMM&quot;</p></a></li>
<li><a href='#EMM-class'><p>Class &quot;EMM&quot;</p></a></li>
<li><a href='#EMMsim'><p>Synthetic Data to Demonstrate EMMs</p></a></li>
<li><a href='#EMMTraffic'><p>Hypothetical Traffic Data Set for EMM</p></a></li>
<li><a href='#fade'><p>Fading Cluster Structure and EMM Layer</p></a></li>
<li><a href='#find_clusters'><p> Find the EMM State/Cluster for an Observation</p></a></li>
<li><a href='#merge_clusters'><p>Merge States of an EMM</p></a></li>
<li><a href='#plot'><p>Visualize EMM Objects</p></a></li>
<li><a href='#predict'><p> Predict a Future State</p></a></li>
<li><a href='#prune'><p>Prune States and/or Transitions</p></a></li>
<li><a href='#recluster'><p>Reclustering EMM states</p></a></li>
<li><a href='#remove'><p> Remove States/Clusters or Transitions from an EMM</p></a></li>
<li><a href='#score'><p>Score a New Sequence Given an EMM</p></a></li>
<li><a href='#smooth_transitions'><p>Smooths transition counts between neighboring states/clusters</p></a></li>
<li><a href='#synthetic_stream'><p>Create a Synthetic Data Stream</p></a></li>
<li><a href='#tNN-class'><p>Class &quot;tNN&quot;</p></a></li>
<li><a href='#TRAC'><p>TRAC: Creating a Markov Model from a Regular Clustering</p></a></li>
<li><a href='#TRACDS-class'><p>Class &quot;TRACDS&quot;</p></a></li>
<li><a href='#transition'><p>Access Transition Probabilities/Counts in an EMM</p></a></li>
<li><a href='#transition_table'><p>Extract a Transition Table for a New Sequence Given an EMM</p></a></li>
<li><a href='#update'><p>Update a TRACDS temporal structure with new state assignements</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>1.2.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-06-25</td>
</tr>
<tr>
<td>Title:</td>
<td>Extensible Markov Model for Modelling Temporal Relationships
Between Clusters</td>
</tr>
<tr>
<td>Description:</td>
<td>Implements TRACDS (Temporal Relationships 
    between Clusters for Data Streams), a generalization of 
    Extensible Markov Model (EMM). TRACDS adds a temporal or order model
    to data stream clustering by superimposing a dynamically adapting
    Markov Chain. Also provides an implementation of EMM (TRACDS on top of tNN 
    data stream clustering). Development of this 
    package was supported in part by NSF IIS-0948893 and R21HG005912 from 
    the National Human Genome Research Institute. Hahsler and Dunham (2010) &lt;<a href="https://doi.org/10.18637%2Fjss.v035.i05">doi:10.18637/jss.v035.i05</a>&gt;.</td>
</tr>
<tr>
<td>Classification/ACM:</td>
<td>G.4, H.2.8, I.5.1</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/mhahsler/rEMM">https://github.com/mhahsler/rEMM</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10.0), proxy (&ge; 0.4-7), igraph</td>
</tr>
<tr>
<td>Imports:</td>
<td>methods, stats, stream, cluster, clusterGeneration, MASS,
utils</td>
</tr>
<tr>
<td>Suggests:</td>
<td>graph, Rgraphviz, testthat</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-06-25 18:45:29 UTC; hahsler</td>
</tr>
<tr>
<td>Author:</td>
<td>Michael Hahsler <a href="https://orcid.org/0000-0003-2716-1405"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre, cph],
  Margaret H. Dunham [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Michael Hahsler &lt;mhahsler@lyle.smu.edu&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-06-25 20:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='16S'>Count Data for 16S rRNA Sequences</h2><span id='topic+16S'></span><span id='topic+Alphaproteobacteria16S'></span><span id='topic+Mollicutes16S'></span>

<h3>Description</h3>

<p>This data set contains count data for 16S ribosomal RNA (rRNA) sequences for
the two phylogenetic classes Alphaproteobacteria and Mollicutes. 
The counts for 30
sequences for each class were obtained by counting the occurrence of triplets
of nucleotides in windows of length 100 without any overlap. To
separate sequences a row of dummy count of <code>NA</code> is used.</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("16S")</code></pre>


<h3>Format</h3>

<p><code>Alphaproteobacteria16S</code> and <code>Mollicutes16S</code> are matrices
with about 449 rows and 64 (number of possible triplets) columns. 
</p>


<h3>Source</h3>

<p>The raw sequence information was obtained from the 
National center for biotechnology information (NCBI) website at
http://www.ncbi.nih.gov/
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("16S")

emm &lt;- EMM("Kullback", threshold=0.1)
build(emm, Mollicutes16S+1)

## start state for sequences have an initial state probability &gt;0
it &lt;- initial_transition(emm)
it[it&gt;0]
</code></pre>

<hr>
<h2 id='build'>Building an EMM using New Data</h2><span id='topic+build'></span><span id='topic+build+2CEMM+2Cdata.frame-method'></span><span id='topic+build+2CEMM+2Cmatrix-method'></span><span id='topic+build+2CEMM+2Cnumeric-method'></span>

<h3>Description</h3>

<p>Add new data to an EMM.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>build(x, newdata, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="build_+3A_x">x</code></td>
<td>
<p> an <code>EMM</code> object. Note that the function will change the original EMM!</p>
</td></tr>
<tr><td><code id="build_+3A_newdata">newdata</code></td>
<td>
<p> a vector (one observation), or a matrix or data.frame
(each row is an observation) </p>
</td></tr>
<tr><td><code id="build_+3A_...">...</code></td>
<td>
<p> further arguments. If <code>newdata</code> is a matrix
or a data.frame then <code>verbose = TRUE</code> can be used to monitor
the progress of
building the model.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>build()</code> performs clustering and also updates the TRACDS temporal
layer.
</p>
<p><code>NA</code>s are handled in the data by using only the other
dimensions if the data for dissimilarity computation
(see package <span class="pkg">proxy</span>).
</p>


<h3>Value</h3>

<p>A reference to the changed EMM object with the data added.
Note: EMM objects store all variable data in an environment which
enables us to update partial data without copying the whole object. Assignment
will not create a copy! Use the provided method <code>copy()</code>.
</p>


<h3>See Also</h3>

<p>Class <code><a href="#topic+TRACDS-class">TRACDS</a></code>,
<code><a href="#topic+fade">fade</a></code> and <code><a href="proxy.html#topic+dist">dist</a></code>
in <span class="pkg">proxy</span>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## load EMMTraffic data
data("EMMTraffic")
EMMTraffic

## create EMM
emm &lt;- EMM(measure="eJaccard", threshold=0.2)

## build model using EMMTraffic data (note that the EMM object is
## changed without assignment!)
build(emm, EMMTraffic)
## same as: emm &lt;- build(emm, EMMTraffic)

size(emm)
plot(emm)

## emm2 &lt;- emm does not create a copy (just a reference)
## a "deep" copy is created using copy()
emm2&lt;- copy(emm)

## convert the emm into a graph
as.igraph(emm)
</code></pre>

<hr>
<h2 id='cluster'>Data stream clustering with tNN</h2><span id='topic+cluster'></span><span id='topic+cluster+2CtNN+2Cdata.frame-method'></span><span id='topic+cluster+2CtNN+2Cmatrix-method'></span><span id='topic+cluster+2CtNN+2Cnumeric-method'></span>

<h3>Description</h3>

<p>Cluster new data into an existing tNN object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cluster(x, newdata, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cluster_+3A_x">x</code></td>
<td>
<p> a <code>tNN</code> object. Note that this function canges the original object!</p>
</td></tr>
<tr><td><code id="cluster_+3A_newdata">newdata</code></td>
<td>
<p> a vector (one observation), or a matrix or data.frame
(each row is an observation). </p>
</td></tr>
<tr><td><code id="cluster_+3A_...">...</code></td>
<td>
<p> further arguments like <code>verbose</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>cluster()</code> implements tNN clustering The dissimilarity between
the new observation and the centers of the clusters is calculated. The
new observation is assigned to the closest cluster if the dissimilarity
value is smaller than the threshold (for the state).  If no such state
exists, a new state is created for the observation. This simple
clustering algorithm is called nearest neighbor threshold nearest
neighbor (threshold NN).
</p>
<p><code>NA</code>s are handled in the data by using only the other
dimensions if the data for dissimilarity computation
(see package~<span class="pkg">proxy</span>).
</p>
<p>The clusters which the data points in the last <code>cluster()</code>
operation where assigned to can be retrieved using the method 
<code>last_clustering()</code>.
</p>


<h3>Value</h3>

<p>A reference to the changed tNN object with the data added. 
Note: tNN objects store all variable data in an environment which 
enables us to update partial data without copying the whole object. Assignment
will not create a copy! Use the provided method <code>copy()</code>. 
</p>


<h3>See Also</h3>

 
<p>Class <code><a href="#topic+tNN-class">tNN</a></code>, 
<code><a href="#topic+fade">fade</a></code> and <code><a href="proxy.html#topic+dist">dist</a></code> 
in <span class="pkg">proxy</span>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>## load EMMTraffic data
data(EMMTraffic)

## create empty clustering
tnn &lt;- tNN(th=0.2, measure="eJaccard")
tnn

## cluster some data
cluster(tnn, EMMTraffic)
tnn

## what clusters were the data points assigned to?
last_clustering(tnn)

## plot the clustering as a scatterplot matrix of the cluster centers
plot(tnn)
</code></pre>

<hr>
<h2 id='combine'>Combining EMM Objects</h2><span id='topic+c'></span><span id='topic+c+2CEMM-method'></span>

<h3>Description</h3>

<p>Combines two or more EMMs into a single object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'EMM'
c(x, ..., copy=TRUE, recursive = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="combine_+3A_x">x</code></td>
<td>
<p> first <code>EMM</code> object. Note that this object will be changed
by the function if <code>copy=FALSE</code>! </p>
</td></tr>
<tr><td><code id="combine_+3A_...">...</code></td>
<td>
<p> further objects of the same class as <code>x</code> to be combined.</p>
</td></tr>
<tr><td><code id="combine_+3A_copy">copy</code></td>
<td>
<p> a logical. Copy <code>x</code> first? Otherwise x will be changed! </p>
</td></tr>
<tr><td><code id="combine_+3A_recursive">recursive</code></td>
<td>
<p> a logical. If <code>recursive=TRUE</code>,
the function recursively
descends through lists combining all their elements into a
vector.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns invisibly an object of the same class as <code>EMM</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+EMM-class">EMM-class</a></code>,
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("16S")

## create two EMMs for different data
emm1 &lt;- EMM("Kullback", threshold=0.1, data=Mollicutes16S+1)
emm2 &lt;- EMM("Kullback", threshold=0.1, data=Alphaproteobacteria16S+1)

## combine the two EMMs
emm12 &lt;- c(emm1, emm2)
## this is the same as:
## emm12 &lt;- copy(emm1)
## c(emm12, emm2, copy=FALSE)

## recluster states so similar states in the to EMMs will be merged
emm12r &lt;- recluster_tNN(emm12)

op &lt;- par(mfrow = c(1, 2), pty = "s")
plot(emm12, main="Two EMMs")
plot(emm12r, main="Two EMMs (reclustered)")
par(op)
</code></pre>

<hr>
<h2 id='Derwent'>Derwent Catchment Data</h2><span id='topic+Derwent'></span>

<h3>Description</h3>

<p>Data set with flow readings (in cubic meter per second) for six catchments of
in the vicinity of the Derwent river in the northern UK. 
The data was collected daily from November 1, 1971 &ndash; January 31, 1977.
The catchments are Long Bridge, Matlock Bath, Chat Sworth,
What Stand Well, Ashford (Wye) and Wind Field Park (Amber).
</p>
<p>The owner of the data is the Ridings Area Office of the Environment 
Agency North-East, UK.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(Derwent)</code></pre>


<h3>Format</h3>

<p>A matrix of size 1918 days times 6 catchments.
</p>


<h3>Source</h3>

<p>UK National River Flow Archive (NRFA),
<a href="https://nrfa.ceh.ac.uk/">https://nrfa.ceh.ac.uk/</a>
</p>
<p>The owner of the data is the Ridings Area Office of the Environment
Agency North-East, UK.
</p>


<h3>References</h3>

<p>Wikipedia, River Derwent, Yorkshire,
<a href="https://en.wikipedia.org/wiki/River_Derwent,_Yorkshire">https://en.wikipedia.org/wiki/River_Derwent,_Yorkshire</a>
</p>
<p>Wikipedia, River Wye, Derbyshire,
<a href="https://en.wikipedia.org/wiki/River_Wye,_Derbyshire">https://en.wikipedia.org/wiki/River_Wye,_Derbyshire</a>
</p>
<p>Wikipedia, River Amber,
<a href="https://en.wikipedia.org/wiki/River_Amber">https://en.wikipedia.org/wiki/River_Amber</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Derwent)

i &lt;- 1
plot(Derwent[,i], type="l", main=colnames(Derwent[i]), ylab="Gauged Flows")
</code></pre>

<hr>
<h2 id='DSC_EMM'>
DSC Interface for EMM and tNN (package stream)
</h2><span id='topic+DSC_EMM'></span><span id='topic+DSC_tNN'></span><span id='topic+get_EMM'></span><span id='topic+set_EMM'></span>

<h3>Description</h3>

<p>Provides Data Stream Clusterer (DSC) interfaces for EMM and tNN so they can be used in the
<span class="pkg">stream</span> framework.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DSC_EMM(formula = NULL, threshold = 0.2, measure = "euclidean", distFun = NULL,
    centroids = identical(tolower(measure), "euclidean"),
    lambda = 0)

DSC_tNN(formula = NULL, threshold = 0.2, measure = "euclidean",
    centroids = identical(tolower(measure), "euclidean"), lambda = 0)

get_EMM(dsc)
set_EMM(dsc, x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DSC_EMM_+3A_formula">formula</code></td>
<td>
<p><code>NULL</code> to use all features in the stream or a model <a href="stats.html#topic+formula">formula</a> of the form <code>~ X1 + X2</code>
to specify the features used for clustering. Only <code>.</code>, <code>+</code> and <code>-</code> are currently
supported in the formula.</p>
</td></tr>
<tr><td><code id="DSC_EMM_+3A_threshold">threshold</code></td>
<td>

<p>A <code>"numeric"</code> with the dissimilarity threshold used by the
clustering algorithm for assigning a new observation to existing clusters.
</p>
</td></tr>
<tr><td><code id="DSC_EMM_+3A_measure">measure</code></td>
<td>

<p>A <code>"character"</code> containing the name of the dissimilarity
measure used (see <code>dist</code> in <span class="pkg">proxy</span> for available measures).
</p>
</td></tr>
<tr><td><code id="DSC_EMM_+3A_distfun">distFun</code></td>
<td>

<p>Specify a function passed on as method to <code>dist</code> in <span class="pkg">proxy</span>
(see <code>dist</code> in <span class="pkg">proxy</span>).
The character string passed on as <code>measure</code> will be used as the
measure's name. 
</p>
</td></tr>
<tr><td><code id="DSC_EMM_+3A_centroids">centroids</code></td>
<td>

<p>A <code>"logical"</code> indicating if centroids are used for clusters.
If <code>FALSE</code>, pseudo medians (first observation of a cluster) are used to
represent a cluster.
</p>
</td></tr>
<tr><td><code id="DSC_EMM_+3A_lambda">lambda</code></td>
<td>
<p>A <code>"numeric"</code> specifying the
rate for fading.
</p>
</td></tr>
<tr><td><code id="DSC_EMM_+3A_dsc">dsc</code></td>
<td>
<p> an object of class <code>"DSC_EMM"</code>. </p>
</td></tr>
<tr><td><code id="DSC_EMM_+3A_x">x</code></td>
<td>
<p> an object of class <code>"EMM"</code> </p>
</td></tr>
</table>


<h3>Details</h3>

<p>DSC_tNN and DSC_EMM wrap the clustering algorithms so they can be used with the stream framework.
See <code><a href="stream.html#topic+DSC">DSC</a></code> for details.
</p>
<p><code>get_EMM()</code> and <code>set_EMM()</code> can be used to access the EMM object inside the DSC_EMM object.
</p>


<h3>Value</h3>

<p>An object of class <code>"DSC_EMM"</code> or <code>"DSC_tNN"</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(stream)

### tNN clustering example

stream &lt;- DSD_Gaussians()
stream

cl &lt;- DSC_tNN(threshold = .1)
cl

update(cl, stream, 100)
cl

get_centers(cl)
get_weights(cl)

plot(cl, stream)

## EMM clustering example
data("EMMsim")
plot(EMMsim_train, pch = NA)
lines(EMMsim_train, col = "gray")
points(EMMsim_train, pch = EMMsim_sequence_train)

stream &lt;- DSD_Memory(EMMsim_train)
stream

cl &lt;- DSC_EMM(threshold = 0.1, measure = "euclidean", lambda = .1)
update(cl, stream, n = 200)
cl

reset_stream(stream)
plot(cl, stream, n = 200, method = "pca")

# inspect and recluster the EMM in the DSC_EMM object
emm &lt;- get_EMM(cl)
plot(emm)

emm &lt;- recluster_hclust(emm, k = 4, method = "average")
plot(emm)

set_EMM(cl, emm)

reset_stream(stream)
plot(cl, stream, n = 200, method = "pca")
</code></pre>

<hr>
<h2 id='EMM'>
Creator for Class &quot;EMM&quot;
</h2><span id='topic+EMM'></span><span id='topic+object.size+2CEMM-method'></span>

<h3>Description</h3>

<p>Create a new object of class <code>"EMM"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EMM(threshold = 0.2, measure = "euclidean", distFun = NULL, 
    centroids = identical(tolower(measure), "euclidean"), 
    lambda = 0, data = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="EMM_+3A_threshold">threshold</code></td>
<td>

<p>Object of class <code>"numeric"</code> with the dissimilarity threshold used by the 
clustering algorithm for assigning a new observation to existing clusters.
</p>
</td></tr>
<tr><td><code id="EMM_+3A_measure">measure</code></td>
<td>

<p>Object of class <code>"character"</code> containing the name of the dissimilarity
measure used (see <code>dist</code> in <span class="pkg">proxy</span> for available measures).
</p>
</td></tr>
<tr><td><code id="EMM_+3A_distfun">distFun</code></td>
<td>

<p>Specify a function passed on as method to <code>dist</code> in <span class="pkg">proxy</span> 
(see <code>dist</code> in <span class="pkg">proxy</span>).
The character string passed on as <code>measure</code> will be used as the 
measure's name.
</p>
</td></tr>
<tr><td><code id="EMM_+3A_centroids">centroids</code></td>
<td>

<p>Object of class <code>"logical"</code> indicating if centroids are used for clusters.
If <code>FALSE</code>, pseudo medians (first observation of a cluster) are used to
represent a cluster.
</p>
</td></tr>
<tr><td><code id="EMM_+3A_lambda">lambda</code></td>
<td>
<p>Object of class <code>"numeric"</code> specifying the
rate for fading.
</p>
</td></tr>
<tr><td><code id="EMM_+3A_data">data</code></td>
<td>
<p>Initial data to build the EMM. 
This just calls <code>build</code> on the new EMM.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>"EMM"</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+EMM-class">EMM-class</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## load EMMTraffic data
data(EMMTraffic)

## create empty EMM
emm &lt;- EMM(threshold=0.2, measure="eJaccard", lambda=.1)
emm

## cluster some data
build(emm, EMMTraffic)
emm

## what clusters were the data points assigned to?
last_clustering(emm)

## plot the clustering as a graph
plot(emm)
</code></pre>

<hr>
<h2 id='EMM-class'>Class &quot;EMM&quot;</h2><span id='topic+EMM-class'></span><span id='topic+show+2CEMM-method'></span><span id='topic+size'></span><span id='topic+size+2CEMM-method'></span><span id='topic+copy'></span><span id='topic+copy+2CEMM-method'></span>

<h3>Description</h3>

<p>This class represents the extensible Markov Model.	It consists
of a simple data stream clustering algorithm (class <code>"tNN"</code>) and
a temporal layer (class <code>"TRACDS"</code>).</p>


<h3>Objects from the Class</h3>

<p>Objects can be created using the creator function <code>EMM</code> or by 
directly calling <code>new("EMM", ...)</code>. Most slots for the extended
classes can be used as parameters for <code>EMM</code>. 
</p>


<h3>Slots</h3>

<p>The slots are described in corresponding the extended classes 
(see section Extends). 
</p>


<h3>Extends</h3>

<p>Class <code>"<a href="#topic+tNN-class">tNN</a>"</code>, directly.
Class <code>"<a href="#topic+TRACDS-class">TRACDS</a>"</code>, directly.
</p>


<h3>Methods</h3>


<dl>
<dt>copy</dt><dd><p><code>signature(x = "EMM")</code>: Make a copy of the EMM object. 
Making explicit copies is necessary since the subclasses store 
information in environments which are not copied for regular 
assignements.</p>
</dd>
<dt>size</dt><dd><p><code>signature(x = "EMM")</code>: Returns the size of
the EMM (number of clusters/states).</p>
</dd>
</dl>



<h3>References</h3>

<p>M.H. Dunham, Y. Meng, J. Huang (2004): Extensible Markov Model, In:
<em>ICDM '04: Proceedings of the Fourth IEEE International
Conference on Data Mining,</em> pp. 371&ndash;374.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+build">build</a></code>,
<code><a href="#topic+fade">fade</a></code>,
<code><a href="#topic+merge_clusters">merge_clusters</a></code>,
<code><a href="#topic+plot">plot</a></code>,
<code><a href="#topic+prune">prune</a></code>,
<code><a href="#topic+rare_clusters">rare_clusters</a></code>,
<code><a href="#topic+rare_transitions">rare_transitions</a></code>,
<code><a href="#topic+remove_clusters">remove_clusters</a></code>,
<code><a href="#topic+remove_transitions">remove_transitions</a></code>,
<code><a href="#topic+remove_selftransitions">remove_selftransitions</a></code>,
<code><a href="#topic+recluster">recluster</a></code>, and
<code><a href="#topic+score">score</a></code>.
</p>

<hr>
<h2 id='EMMsim'>Synthetic Data to Demonstrate EMMs</h2><span id='topic+EMMsim'></span><span id='topic+EMMsim_train'></span><span id='topic+EMMsim_test'></span><span id='topic+EMMsim_sequence_train'></span><span id='topic+EMMsim_sequence_test'></span>

<h3>Description</h3>

<p>A simulated data set with four clusters in <code class="reqn">R^2</code>. Each cluster is
represented by a bivariate normally distributed random variable.
<code class="reqn">\mu</code> are the coordinates of the means of the
distributions and <code class="reqn">\Sigma</code> contains the covariance matrices.
Two data stream are created using a fixed sequence <code class="reqn">&lt;1,2,1,3,4&gt;</code>
through
the four clusters. For the training data, the sequence is repeated 40 times
(200 data points) and for the test data five times (25 data points).
</p>
<p>The code to generate the data is shown in the Examples section below.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(EMMsim)</code></pre>


<h3>Format</h3>

<p><code>EMMsim_train</code> and <code>EMMsim_test</code> are matrices containing the
data.
</p>
<p><code>EMMsim_sequence_train</code> and <code>EMMsim_sequence_test</code>
contain the sequence of the data through the four clusters.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(EMMsim)
plot(EMMsim_train)
points(EMMsim_test, col = "red")

## the data was generated by
## Not run: 
set.seed(1234)

## simulated data
mu &lt;- cbind(x = c(0, 0.2, 1, 0.9),
  y = c(0, 0.7, 1, 0.2))

sd_rho &lt;- cbind(
  x = c(0.2, 0.15, 0.05, 0.02),
  y = c(0.1, 0.04, 0.03, 0.05),
  rho = c(0, 0.7, 0.3,-0.4)
)

Sigma &lt;- lapply(
  1:nrow(sd_rho),
  FUN = function(i)
    rbind(
      c(sd_rho[i, "x"] ^ 2, sd_rho[i, "rho"] * sd_rho[i, "x"] * sd_rho[i, "y"]),
      c(sd_rho[i, "rho"] * sd_rho[i, "x"] * sd_rho[i, "y"], sd_rho[i, "y"] ^
          2)
    )
)

sequence &lt;- c(1, 2, 1, 3, 4)

EMMsim_sequence_train &lt;- rep(sequence, 40)
EMMsim_sequence_test &lt;- rep(sequence, 5)

library("MASS")
EMMsim_train &lt;- t(sapply(
  EMMsim_sequence_train,
  FUN = function(i)
    mvrnorm(1, mu = mu[i, ], Sigma = Sigma[[i]])
))

EMMsim_test &lt;- t(sapply(
  rep(EMMsim_sequence_test),
  FUN = function(i)
    mvrnorm(1, mu = mu[i, ], Sigma = Sigma[[i]])
))

## End(Not run)
</code></pre>

<hr>
<h2 id='EMMTraffic'>Hypothetical Traffic Data Set for EMM</h2><span id='topic+EMMTraffic'></span>

<h3>Description</h3>

<p>Each observation in this hypothetical data set is a vector of
seven values obtained from sensors located at specific
points on roads. Each sensor collects a count of the
number of vehicles which have crossed this sensor in
the preceding time interval.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(EMMTraffic)</code></pre>


<h3>Format</h3>

<p>A matrix with 12 observations (rows).
</p>


<h3>References</h3>

<p>M.H. Dunham, Y. Meng, J. Huang (2004): Extensible Markov Model, In: 
<em>ICDM '04: Proceedings of the Fourth IEEE International 
Conference on Data Mining,</em> pp. 371&ndash;374.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(EMMTraffic)
EMMTraffic
</code></pre>

<hr>
<h2 id='fade'>Fading Cluster Structure and EMM Layer</h2><span id='topic+fade'></span><span id='topic+fade+2CEMM+2Cnumeric+2Cnumeric-method'></span><span id='topic+fade+2CEMM+2Cmissing+2Cnumeric-method'></span><span id='topic+fade+2CEMM+2Cmissing+2Cmissing-method'></span><span id='topic+fade+2CEMM+2Cnumeric+2Cmissing-method'></span>

<h3>Description</h3>

<p>Reduces the weight of old observations in the data stream. 
<code>build</code> has a learning rate parameter
<code>lambda</code>. If this parameter is set, <code>build</code> automatically
fades all counts before a new data point is added. The second
mechanism is to explicitly call the function~<code>fade</code> whenever
fading is needed. This has the advantage that the overhead of manipulating
all counts in the EMM can be reduced and that fading can be used in a more
flexible manner. For example, if the data points are arriving at an irregular
rate, <code>fade</code> could be called at regular time intervals
(e.g., every second).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fade(x, t, lambda)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fade_+3A_x">x</code></td>
<td>
<p> an object of class <code>"EMM"</code>. Note that this
function will change <code>x</code>. </p>
</td></tr>
<tr><td><code id="fade_+3A_t">t</code></td>
<td>
<p> number of time intervals (if missing 1 is used) </p>
</td></tr>
<tr><td><code id="fade_+3A_lambda">lambda</code></td>
<td>
<p> learning rate. If <code>lambda</code> is missing, 
the learning rate specified for the EMM is used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Old data points are faded by using a weight.
We define the weight
for data that is <code class="reqn">t</code> timesteps in the past by the following strictly 
decreasing function:
</p>
<p style="text-align: center;"><code class="reqn">w_t = 2^{-\lambda t}</code>
</p>

<p>Since the weight is multiplicative, it can be applied iteratively by 
multiplying at each time step all counts by <code class="reqn">2^{-\lambda}</code>.
For the clustering algorithm the weight of the clusters (number of data
points assigned to the cluster) is faded. For the EMM the initial count vector
and all transition counts are faded.
</p>


<h3>Value</h3>

<p>Returns a reference to the changed object <code>x</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+EMM-class">EMM</a></code> and <code><a href="#topic+build">build</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data("EMMTraffic")

## For the example we use a very high learning rate
## this calls fade after each new data point
emm_l &lt;- EMM(measure="eJaccard", threshold=0.2, lambda = 1)
build(emm_l, EMMTraffic)

## build a regular EMM for comparison
emm &lt;- EMM(measure="eJaccard", threshold=0.2)
build(emm, EMMTraffic)

## compare the transition matrix
transition_matrix(emm)
transition_matrix(emm_l)

## compare graphs
op &lt;- par(mfrow = c(1, 2), pty = "m")
plot(emm, main = "regular EMM")
plot(emm_l, main = "EMM with high learning rate")
par(op)

</code></pre>

<hr>
<h2 id='find_clusters'> Find the EMM State/Cluster for an Observation </h2><span id='topic+find_clusters'></span><span id='topic+find_clusters+2CtNN+2Cnumeric-method'></span><span id='topic+find_clusters+2CtNN+2Cmatrix-method'></span><span id='topic+find_clusters+2CtNN+2Cdata.frame-method'></span>

<h3>Description</h3>

<p>Finds the cluster and thus the EMM states for observations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'tNN,matrix'
find_clusters(x, newdata, match_cluster=c("exact", "nn"), dist = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="find_clusters_+3A_x">x</code></td>
<td>
<p> an <code>EMM</code> object.</p>
</td></tr>
<tr><td><code id="find_clusters_+3A_newdata">newdata</code></td>
<td>
<p> a matrix/data.frame with observations.</p>
</td></tr>
<tr><td><code id="find_clusters_+3A_match_cluster">match_cluster</code></td>
<td>
<p> find exact or nearest neighbor (nn) cluster/state. 
If a number is supplied then the threshold times this number is
used for exact matching.</p>
</td></tr> 
<tr><td><code id="find_clusters_+3A_dist">dist</code></td>
<td>
<p> also report the distance to the chosen cluster/state (as a
data.frame).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the name of the matching clusters/states or a data.frame with
columns &quot;state&quot; and &quot;dist&quot; if <code>dist=TRUE</code>. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+EMM-class">EMM</a></code> and <code><a href="#topic+tNN-class">tNN</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>data("EMMTraffic")
emm &lt;- EMM(measure="eJaccard", threshold=0.2)
emm &lt;- build(emm, EMMTraffic)

find_clusters(emm, EMMTraffic)
find_clusters(emm, EMMTraffic, dist=TRUE)

## add noise to the data 
set.seed(1234)
newdata &lt;- sapply(EMMTraffic, jitter, amount=15)
## default is exact match
find_clusters(emm, newdata, dist=TRUE)
## match with nearest neighbor
find_clusters(emm, newdata, match_cluster="nn", dist=TRUE)
## exact match only if within .5 times threshold
find_clusters(emm, newdata, match_cluster=.5, dist=TRUE)
## exact match only if within 2 times threshold
find_clusters(emm, newdata, match_cluster=2, dist=TRUE)
</code></pre>

<hr>
<h2 id='merge_clusters'>Merge States of an EMM </h2><span id='topic+merge_clusters'></span><span id='topic+merge_clusters+2CEMM+2Ccharacter-method'></span><span id='topic+merge_clusters+2CEMM+2Cinteger-method'></span>

<h3>Description</h3>

<p>Merge several clusters/states of an EMM into a single cluster/state.</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'EMM,character'
merge_clusters(x, to_merge, clustering = FALSE, new_center = NULL, copy=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="merge_clusters_+3A_x">x</code></td>
<td>
<p> an <code>"EMM"</code> object. Note that the function will change this EMM!</p>
</td></tr>
<tr><td><code id="merge_clusters_+3A_to_merge">to_merge</code></td>
<td>
<p> vector of names of the states/clusters to merge. The
name of the first state in <code>to_merge</code>
is used as the name for the new state representing the merged states.</p>
</td></tr>
<tr><td><code id="merge_clusters_+3A_clustering">clustering</code></td>
<td>
<p> is <code>to_merge</code> a vector with
cluster assignments as created by a clustering algorithm? </p>
</td></tr>
<tr><td><code id="merge_clusters_+3A_new_center">new_center</code></td>
<td>
<p> supply new centers for the merged clusters.
New centroids are automatically
computed. If (pseudo) medoids are used, new medoids should be supplied.
If none is supplied, the medoid of the cluster in <code>to_merge</code> 
which has the most assigned observations 
is used as the new medoid (warning: this is probably not a good medoid!)</p>
</td></tr>
<tr><td><code id="merge_clusters_+3A_copy">copy</code></td>
<td>
<p> logical; make a copy of x before reclustering? Otherwise the function will change <code>x</code>!</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the changed EMM with the states/clusters merged invisibly.
If <code>copy=FALSE</code> then it returns a reference to the changes
object passed as <code>x</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("EMMTraffic")
emm &lt;- EMM(measure="eJaccard", threshold=0.2)
build(emm, EMMTraffic)
states(emm)

## create a new emm with states 1-3 merged
emm_m123 &lt;- merge_clusters(emm, c("1", "2", "3"))
states(emm_m123)
</code></pre>

<hr>
<h2 id='plot'>Visualize EMM Objects </h2><span id='topic+plot+2CEMM+2Cmissing-method'></span><span id='topic+plot'></span>

<h3>Description</h3>

<p>Visualize EMM objects.</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'EMM,missing'
plot(x, y,
  method=c("igraph", "interactive", "graph", "MDS",
           "cluster_counts", "transition_counts"),
  data = NULL, parameter=NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_+3A_x">x</code></td>
<td>
<p> an <code>EMM</code> object. </p>
</td></tr>
<tr><td><code id="plot_+3A_y">y</code></td>
<td>
<p> unused (just for compatibility with the generic for plot in
<span class="pkg">graphics</span>) </p>
</td></tr>
<tr><td><code id="plot_+3A_method">method</code></td>
<td>
<p> see details section.</p>
</td></tr>
<tr><td><code id="plot_+3A_data">data</code></td>
<td>
<p> Project the state centers onto these data. Points which do
not belong to any cluster are shown in blue.</p>
</td></tr>
<tr><td><code id="plot_+3A_parameter">parameter</code></td>
<td>
<p> a list of parameters for plotting (see Details section). </p>
</td></tr>
<tr><td><code id="plot_+3A_...">...</code></td>
<td>
<p> further arguments passed on to <code><a href="graphics.html#topic+plot.default">plot.default</a></code> or <code><a href="igraph.html#topic+plot.igraph">plot.igraph</a></code>. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>There are several methods for plotting:
</p>
<p><code>"igraph"</code> produces a graph representation of the EMM using <span class="pkg">igraph</span>.
Additional arguments like <code>layout</code> are passed on to plot for igraph.
</p>
<p><code>"interactive"</code> produces an interactive graph representation of the EMM (using <span class="pkg">igraph</span>).
Arguments suitable for <code>plot</code> in <span class="pkg">igraph</span> can be
passed on as <code>...</code>.
</p>
<p><code>"graph"</code> produces a graph representation of the EMM using <span class="pkg">Rgraphviz</span>.
If <span class="pkg">Rgraphviz</span> is not installed/available then the method reverts to
<code>"igraph"</code>.
</p>
<p><code>"MDS"</code> projects the cluster centers into 2-dimensional space.
</p>
<p><code>"cluster_counts"</code> produces a barplot for cluster counts.
</p>
<p><code>"transition_counts"</code> produces a barplot for transition counts.
</p>
<p>The following plotting parameters are currently supported (by some of the visualizations):
</p>

<dl>
<dt>state_counts</dt><dd><p>represent state counts by vertex size?
(default: <code>TRUE</code>)</p>
</dd>
<dt>arrow_width</dt><dd><p>represent transition counts/probabilities by arrow width?
(default: <code>TRUE</code>)</p>
</dd>
<dt>arrows</dt><dd><p>use <code>"counts"</code> or <code>"probabilities"</code> for
arrow width. (default: &quot;counts&quot;)</p>
</dd>
<dt>arrow_width_multiplier, state_size_multiplier</dt><dd><p> Controls the variation
of vertex sizes and edge widths (default: 1).</p>
</dd>
<dt>add_labels</dt><dd><p>add labels for centers (n/a for <code>type = "graph"</code>).</p>
</dd>
<dt>cluster_labels</dt><dd><p>cluster labels to use instead of 1,2,....</p>
</dd>
<dt>mark_clusters</dt><dd><p>Use different markers for points depending on the
state they belong to (only available for MDS when
<code>data</code> is specified).</p>
</dd>
<dt>draw_threshold</dt><dd><p>draw a circle around state centers to indicate the area in which points
are assigned to the cluster (experimental, only available for
MDS when <code>data</code> is specified). </p>
</dd>
<dt>mark_states, mark_state_color</dt><dd><p>a vector of state names to be marked
and the color(s) used for marking (default: red).</p>
</dd>
<dt>mark_transitions, mark_transitions_color</dt><dd><p>a vector of transition names
in the format &quot;3-&gt;2&quot; to be marked and the color(s)
used for marking (default: red).</p>
</dd>
</dl>

<p>For some plots (e.g., <code>"igraph"</code>) <code>...</code> is passed on to the
primitive plotting function and can be used to change the plot (colors, etc.)
See <code>? igraph.plotting</code>.
For <code>"graph"</code> the two special parameters &quot;nAttrs&quot; and &quot;eAttrs&quot;
for node and edge attributes can be used.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+EMM-class">EMM</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data("EMMTraffic")

emm &lt;- EMM(threshold = 0.2,
  measure = "eJaccard",
  data = EMMTraffic)

op &lt;- par(mfrow = c(2, 2), pty = "s")

plot(emm, main = "Graph")

## Plot the graph as a tree with a set root node and an aspect ratio of 1:1.
g &lt;- as.igraph(emm)
plot(emm, main = "Graph (tree layout)",
  layout = layout_as_tree(g, root = 1), asp = 1)

plot( emm, method = "MDS",
  main = "Graph (MDS projection)", xlim = c(-0.5, 0.5), ylim = c(-0.5, 0.5)
)

plot(emm, method = "MDS", data = EMMTraffic,
  main = "Projection of cluster \ncenters on data")
par(op)
</code></pre>

<hr>
<h2 id='predict'> Predict a Future State </h2><span id='topic+predict'></span><span id='topic+predict+2CTRACDS-method'></span>

<h3>Description</h3>

<p>Predict a state or the probability distribution over states in <code class="reqn">n</code> 
time steps.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'TRACDS'
predict(object, current_state = NULL, n=1, 
	probabilities = FALSE, randomized = FALSE, prior=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict_+3A_object">object</code></td>
<td>
<p> an <code>"EMM"</code>/<code>"TRACDS"</code> object. </p>
</td></tr>
<tr><td><code id="predict_+3A_current_state">current_state</code></td>
<td>
<p> use a specified current state. 
If <code>NULL</code>, the EMM's current state is used. </p>
</td></tr>
<tr><td><code id="predict_+3A_n">n</code></td>
<td>
<p> number of time steps. </p>
</td></tr>
<tr><td><code id="predict_+3A_probabilities">probabilities</code></td>
<td>
<p> if <code>TRUE</code>,
instead of the predicted state, the probability distribution is returned.</p>
</td></tr>
<tr><td><code id="predict_+3A_randomized">randomized</code></td>
<td>
<p> if <code>TRUE</code>, the predicted state is choosen
randomly with a selection probability proportional to its transition 
probability</p>
</td></tr>
<tr><td><code id="predict_+3A_prior">prior</code></td>
<td>
<p> add one to each transition count. This is equal
to starting with a uniform prior for the transition count distribution,
i.e. initially all transitions are equally likely. It also prevents the
product of probabilities to be zero if a transition was never observed. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Prediction is done using <code class="reqn">A^n</code> where <code class="reqn">A</code> is the transition 
probability matrix maintained by the EMM.
Random tie-breaking is used.
</p>


<h3>Value</h3>

<p>The name of the predicted state or a vector with the probability 
distribution over all states.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+transition_matrix">transition_matrix</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>data("EMMTraffic")
emm &lt;- EMM(measure="eJaccard", threshold=0.2)
emm &lt;- build(emm, EMMTraffic)

#plot(emm) ## plot graph

## Predict state starting an state 1 after 1, 2 and 100 time intervals
## Note, state 7 is an absorbing state.
predict(emm, n=1, current_state="1")
predict(emm, n=2, current_state="1")
predict(emm, n=100, current_state="1")

## Get probability distribution
predict(emm, n=2, current_state="1", probabilities = TRUE)
</code></pre>

<hr>
<h2 id='prune'>Prune States and/or Transitions</h2><span id='topic+prune'></span><span id='topic+prune+2CEMM-method'></span><span id='topic+rare_clusters'></span><span id='topic+rare_clusters+2CtNN-method'></span><span id='topic+rare_transitions'></span><span id='topic+rare_transitions+2CTRACDS-method'></span>

<h3>Description</h3>

<p>Simplifies an EMM and/or the clustering by removing all 
clusters/states and/or transitions 
which have a count of equal or smaller than a given threshold.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'EMM'
prune(x, count_threshold, clusters = TRUE, transitions = FALSE,
    copy = TRUE, compact = TRUE)

rare_clusters(x, count_threshold, ...)
rare_transitions(x, count_threshold, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prune_+3A_x">x</code></td>
<td>
<p> an object of class <code>"EMM"</code></p>
</td></tr>
<tr><td><code id="prune_+3A_count_threshold">count_threshold</code></td>
<td>
<p> all states/edges with a count of less or equal to the
threshold are removed from the model.</p>
</td></tr>
<tr><td><code id="prune_+3A_clusters">clusters</code></td>
<td>
<p> logical; prune clusters?</p>
</td></tr>
<tr><td><code id="prune_+3A_transitions">transitions</code></td>
<td>
<p> logical; prune transitions?</p>
</td></tr>
<tr><td><code id="prune_+3A_copy">copy</code></td>
<td>
<p> logical; make a copy of x before reclustering? Otherwise the function will change <code>x</code>!</p>
</td></tr>
<tr><td><code id="prune_+3A_compact">compact</code></td>
<td>
<p> logical; tries make the data structure used for the temporal model more compact after pruning. </p>
</td></tr>
<tr><td><code id="prune_+3A_...">...</code></td>
<td>
<p> further arguments (currently not used).</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>prune</code> returns invisibly an object of class <code>EMM</code>.
If <code>copy=FALSE</code> then it returns a reference to the changes
object passed as <code>x</code>.
</p>
<p><code>rare_clusters</code> returns a vector of names of rare clusters.
</p>
<p><code>rare_transitions</code> returns a data.frame of rare transitions.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+remove_transitions">remove_transitions</a></code>,
<code><a href="#topic+remove_clusters">remove_clusters</a></code>,
<code><a href="#topic+compact">compact</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("EMMTraffic")

## For the example we use a very high learning rate
emm_l &lt;- EMM(threshold=0.2, measure="eJaccard", lambda = 1)
build(emm_l, EMMTraffic)

## show state counts and transition counts
cluster_counts(emm_l)
transition_matrix(emm_l, type="counts")

## rare state/transitions
rare_clusters(emm_l, count_threshold=0.1)
rare_transitions(emm_l, count_threshold=0.1)

## remove all states with a threshold of 0.1
emm_lr &lt;- prune(emm_l, count_threshold=0.1)

## compare graphs
op &lt;- par(mfrow = c(1, 2), pty = "m")
plot(emm_l, main = "EMM with high learning rate")
plot(emm_lr, main = "Simplified EMM")
par(op)

</code></pre>

<hr>
<h2 id='recluster'>Reclustering EMM states</h2><span id='topic+recluster'></span><span id='topic+recluster_hclust'></span><span id='topic+recluster_hclust+2CEMM-method'></span><span id='topic+recluster_kmeans'></span><span id='topic+recluster_kmeans+2CEMM-method'></span><span id='topic+recluster_pam'></span><span id='topic+recluster_pam+2CEMM-method'></span><span id='topic+recluster_tNN'></span><span id='topic+recluster_tNN+2CEMM-method'></span><span id='topic+recluster_reachability'></span><span id='topic+recluster_reachability+2CEMM-method'></span><span id='topic+recluster_transitions'></span><span id='topic+recluster_transitions+2CEMM-method'></span>

<h3>Description</h3>

<p>Use various clustering methods to recluster states/clusters
in an EMM. The centers of the clusters in the EMM object are used as 
data points by the reclustering algorithm. States/centers put by reclustering
into the same cluster are merged to produce a new reclustered EMM.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'EMM'
recluster_hclust(x, k=NULL, h=NULL, method="average", 
    ...,prune=NULL, copy=TRUE)
## S4 method for signature 'EMM'
recluster_kmeans(x, k, ..., prune=NULL, copy=TRUE)
## S4 method for signature 'EMM'
recluster_pam(x, k, ..., prune=NULL, copy=TRUE)
## S4 method for signature 'EMM'
recluster_reachability(x, h, ..., prune=NULL, copy=TRUE)
## S4 method for signature 'EMM'
recluster_tNN(x, threshold=NULL, ..., prune=NULL, copy=TRUE)
## S4 method for signature 'EMM'
recluster_transitions(x, threshold=NULL, ..., prune=NULL, copy=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="recluster_+3A_x">x</code></td>
<td>
<p> an <code>"EMM"</code> object.</p>
</td></tr>
<tr><td><code id="recluster_+3A_k">k</code></td>
<td>
<p> number of clusters. </p>
</td></tr>
<tr><td><code id="recluster_+3A_h">h</code></td>
<td>
<p> heights where the dendrogram tree should be cut.</p>
</td></tr>
<tr><td><code id="recluster_+3A_threshold">threshold</code></td>
<td>
<p> threshold used on the dissimilarity to join 
clusters for tNN. If no threshold is specified then the threshold
stored in the EMM is used. </p>
</td></tr>
<tr><td><code id="recluster_+3A_method">method</code></td>
<td>
<p> clustering method used by <code>hclust</code>. </p>
</td></tr>
<tr><td><code id="recluster_+3A_...">...</code></td>
<td>
<p> additional arguments passed on to the clustering algorithm. </p>
</td></tr>
<tr><td><code id="recluster_+3A_prune">prune</code></td>
<td>
<p> logical; prune states with less 
than <code>prune</code> counts before reclustering. </p>
</td></tr>
<tr><td><code id="recluster_+3A_copy">copy</code></td>
<td>
<p> logical; make a copy of x before reclustering? Otherwise the function will change <code>x</code>! </p>
</td></tr>
</table>


<h3>Details</h3>

<p>For <code>recluster_kmeans</code> <code>k</code> can also be a set of initial cluster 
centers (see argument <code>centers</code> for <code>kmeans</code> in package <span class="pkg">stats</span>).
</p>
<p>For <code>recluster_hclust</code> <code>k</code> or <code>h</code> can also be a vector. 
The result is then a list with several (nested) EMMs, one for each value.
</p>
<p>For <code>recluster_reachability</code> reclusters all clusters which are reachable
from each other. A cluster <code class="reqn">j</code> is reachable from <code class="reqn">i</code> if
<code class="reqn">j</code>'s center is closer to <code class="reqn">i</code>'s center than <code>h</code> or if <code class="reqn">j</code> is
reachable by any cluster reachable by <code class="reqn">i</code>.
</p>
<p>For <code>recluster_tNN</code> reclusters such that two clusters with
centers less than the threshold apart will be reclustered into a
single cluster. This is useful, for example, after combining two models.
</p>
<p>For <code>recluster_transitions</code> does not recluster clusters!
It find groups of clusters which are overlapping (centers are
less than 2 thresholds apart) and then redistributes the transition weights
such that all members of one group are connected to all the members of the
other group using the same weight.
</p>


<h3>Value</h3>

<p>An object of class <code>"EMM"</code> or, if <code>copy=FALSE</code> a refernece 
to the changed object passed as <code>x</code>. 
</p>
<p>Clustering information is available
as the attribute <code>"cluster_info"</code>.
The information provided depends
in the clustering algorithm (see <code>hclust</code>, <code>kmeans</code> and <code>pam</code>).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+merge_clusters">merge_clusters</a></code>, <code><a href="#topic+prune">prune</a></code>, 
<code><a href="stats.html#topic+kmeans">kmeans</a></code>, <code><a href="stats.html#topic+hclust">hclust</a></code>,
<code><a href="cluster.html#topic+pam">pam</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(EMMsim)
emm &lt;- EMM(threshold = .2)
build(emm, EMMsim_train)

## do reclustering on a copy of the emm and plot dendrogram
emm_hc &lt;- recluster_hclust(emm, h = 0.6)

attr(emm_hc, "cluster_info")

## compare original and clustered EMM
op &lt;- par(mfrow = c(2, 2), pty = "m")   
plot(emm, method= "MDS", main ="original EMM", data = EMMsim_train) 
plot(attr(emm_hc, "cluster_info")$dendrogram)
abline(h=0.6, col="red")
plot(emm_hc, method="MDS", main ="clustered EMM", data = EMMsim_train) 
plot(emm_hc, method="MDS", main ="clustered EMM") 
par(op)
</code></pre>

<hr>
<h2 id='remove'> Remove States/Clusters or Transitions from an EMM </h2><span id='topic+remove_clusters'></span><span id='topic+remove_clusters+2CEMM+2Ccharacter-method'></span><span id='topic+remove_transitions'></span><span id='topic+remove_transitions+2CEMM+2Ccharacter+2Ccharacter-method'></span><span id='topic+remove_transitions+2CEMM+2Cmatrix+2Cmissing-method'></span><span id='topic+remove_selftransitions'></span><span id='topic+remove_selftransitions+2CEMM-method'></span>

<h3>Description</h3>

<p>Remove states/clusters or transitions from an EMM.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>remove_clusters(x, to_remove, copy = TRUE)
remove_transitions(x, from, to,copy = TRUE)
remove_selftransitions(x, copy = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="remove_+3A_x">x</code></td>
<td>
<p> an <code>EMM</code> object.</p>
</td></tr>
<tr><td><code id="remove_+3A_to_remove">to_remove</code></td>
<td>
<p> Names of states/clusters to remove.</p>
</td></tr>
<tr><td><code id="remove_+3A_from">from</code>, <code id="remove_+3A_to">to</code></td>
<td>
<p> Names of states for removing transitions. If <code>to</code> is
missing <code>from</code> has to contain a matrix with two columns
(from and to state names).</p>
</td></tr>
<tr><td><code id="remove_+3A_copy">copy</code></td>
<td>
<p> logical; make a copy of x before reclustering? Otherwise the function will change <code>x</code>!</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>remove_selftransitions</code> removes the transitions from each state to itself.
</p>


<h3>Value</h3>

<p>Returns a EMM with removed states/transitions.
If <code>copy=FALSE</code> a reference to the object <code>x</code>
with the states/transistions removed is returned.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("EMMTraffic")
emm &lt;- EMM(measure="eJaccard", threshold=0.2)
emm &lt;- build(emm, EMMTraffic)

## remove state 3
emm_rs3 &lt;- remove_clusters(emm, "3")

## remove transition 5-&gt;2
emm_rt52 &lt;- remove_transitions(emm, "5", "2")

## compare EMMs
op &lt;- par(mfrow = c(2, 2), pty = "m")
plot(emm, method = "igraph", main = "original EMM")
plot(emm_rs3, method = "igraph", main = "state 3 removed")
plot(emm_rt52, method = "igraph", main = "transition 5-&gt;2 removed")
par(op)
</code></pre>

<hr>
<h2 id='score'>Score a New Sequence Given an EMM</h2><span id='topic+score'></span><span id='topic+score+2CEMM+2Cnumeric-method'></span><span id='topic+score+2CEMM+2Cdata.frame-method'></span><span id='topic+score+2CEMM+2Cmatrix-method'></span><span id='topic+score+2CEMM+2CEMM-method'></span>

<h3>Description</h3>

<p>Calculates a score of how likely it is that a new sequence was generated
by the same process as the sequences used to build the EMM.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'EMM,matrix'
score(x, newdata, method = c("product", "log_sum", "sum",
        "log_odds", "supported_transitions", "supported_states",
        "sum_transitions",  "log_loss", "likelihood", "log_likelihood", "AIC"),
        match_cluster = "exact", random = FALSE, prior = TRUE, normalize = TRUE,
        initial_transition = FALSE, threshold = NA)
## S4 method for signature 'EMM,EMM'
score(x, newdata, method = c("product", "log_sum", "sum",
        "supported_transitions"), match_cluster = "exact", random = FALSE, prior = TRUE,
        initial_transition = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="score_+3A_x">x</code></td>
<td>
<p> an <code>EMM</code> object. </p>
</td></tr>
<tr><td><code id="score_+3A_newdata">newdata</code></td>
<td>
<p> sequence or another <code>EMM</code> object to score. </p>
</td></tr>
<tr><td><code id="score_+3A_method">method</code></td>
<td>
<p> method to calculate the score (see details) </p>
</td></tr>
<tr><td><code id="score_+3A_match_cluster">match_cluster</code></td>
<td>
<p> do the new observations have to fall within
the threshold of the cluster (<code>"exact"</code>) or is nearest neighbor
(<code>"nn"</code>) or weighted nearest neighbor (<code>weighted</code>) used?
If <code>match_cluster</code> is a number n then observations
need to fall within n times the clustering threshold of the cluster.</p>
</td></tr>
<tr><td><code id="score_+3A_random">random</code></td>
<td>
<p> logical; should the order of newdata be randomized? Can be used to compare the score with the
actual score. </p>
</td></tr>
<tr><td><code id="score_+3A_prior">prior</code></td>
<td>
<p> logical; add one to each transition count. This is equal
to start with a count of one  for each transition, i.e. initially all
transitions are equally likely. It prevents the product
of probabilities to be zero if a transition was never observed. </p>
</td></tr>
<tr><td><code id="score_+3A_normalize">normalize</code></td>
<td>
<p>logical; normalize the score by the length of the sequence.</p>
</td></tr>
<tr><td><code id="score_+3A_initial_transition">initial_transition</code></td>
<td>
<p> logical; include the initial transition
in the computation?</p>
</td></tr>
<tr><td><code id="score_+3A_threshold">threshold</code></td>
<td>
<p> minimum count threshold used by supported transitions and supported states.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The scores for a new sequence <code class="reqn">x</code> of length <code class="reqn">l</code> can be computed
by the following methods. For <code>match_cluster="exact"</code> or <code>"nn"</code>:
</p>

<dl>
<dt>&quot;product&quot;</dt><dd>
<p>Product of transition probabilities along the path of <code class="reqn">x</code> in the
model. A single missing transition (transition probability of zero)
will result in
a score of 0. Use <code>prior</code> to avoid this.
</p>
<p style="text-align: center;"><code class="reqn">S_\mathrm{product} = \sqrt[l-1]{\prod_{i=1}^{l-1}{a_{s(i),s(i+1)}}}</code>
</p>

<p>where <code class="reqn">a_{s(i),s(j)}</code> is the transition probability
between the state representing positions <code class="reqn">i</code> and <code class="reqn">j</code> in the sequence.
</p>
</dd>
<dt>&quot;sum&quot;</dt><dd>
<p>Average of transition probabilities along the path of <code class="reqn">x</code> in the
model.
</p>
<p style="text-align: center;"><code class="reqn">S_\mathrm{sum} = \frac{1}{l-1} \sum_{i=1}^{l-1}{a_{s(i),s(i+1)}}</code>
</p>

</dd>
<dt>&quot;log_sum&quot;</dt><dd>
<p>Average of the log of the transition probabilities along the path of
<code class="reqn">x</code> in the model. The ranking of the scores is equivalent to
the product of probabilities, however, the calculation is more reliable
since the product of probabilities might become a very small number.
</p>
<p>A single missing transition (transition probability of zero)
will result in a score of neg. infinity.
Use <code>prior</code> to avoid this.
</p>
<p style="text-align: center;"><code class="reqn">S_\mathrm{log\_sum} = \frac{1}{l-1} \sum_{i=1}^{l-1}{\mathrm{log}(a_{s(i),s(i+1)})}</code>
</p>

</dd>
<dt>&quot;supported_transitions&quot;</dt><dd><p>Fraction of transitions in the new sequence <code class="reqn">x</code> supported (present) in the model after assigning each data point in <code class="reqn">x</code> to a state in
the model.
</p>
<p style="text-align: center;"><code class="reqn">S_\mathrm{supported\_transitions} = \frac{1}{l-1} \sum_{i=1}^{l-1}{\mathrm{I}(a_{s(i),s(i+1)})}</code>
</p>

</dd>
<dt>&quot;supported_states&quot;</dt><dd><p>Fraction of points in the new sequence <code class="reqn">x</code>
for which a state (cluster) exists in the model. <code>match_cluster</code>
is always <code>"exact"</code> because for <code>"nn"</code> this measure would
always give 1. Note that this measure ignores transition information.
</p>
<p>If threshold is given, then only states with a count greater than the given threshold are counted as supported.
</p>
</dd>
<dt>&quot;sum_transitions&quot;</dt><dd><p>Sum of the counts on the edges in the model on the path of sequence <code class="reqn">x</code> normalized by the total number of transition counts in the model.
</p>
<p style="text-align: center;"><code class="reqn">S_\mathrm{sum\_transitions} = \frac{1}{l-1} \sum_{i=1}^{l-1}c_{s(i),s(i+1)}</code>
</p>

<p>where <code class="reqn">c_{s(i),s(i+1)}</code> is the transition count  between the state representing positions <code class="reqn">i</code> and <code class="reqn">j</code> in the sequence.
</p>
<p>If threshold is given, then only transitions with a count greater than the given threshold are counted as supported.
</p>
</dd>
<dt>&quot;likelihood&quot;, &quot;log_likelihood&quot;</dt><dd><p> The likelihood of the model given the new data is the
unnormalized product score (product of transition probabilities).</p>
</dd>
<dt>&quot;log_loss&quot;</dt><dd><p> The average log loss is defined as
</p>
<p style="text-align: center;"><code class="reqn">-sum(log2(a_s(i),s(i+1)))/(l-1)</code>
</p>

<p>It represents the average compression rate of the new sequence
given the model.
</p>
</dd>
<dt>&quot;AIC&quot;</dt><dd><p> Akaike Information Criterion corrected for finite sample size.
</p>
<p style="text-align: center;"><code class="reqn">2k - 2log(L) 2k(k-1)/(n-k-1)</code>
</p>

<p>where <code class="reqn">n=l-1</code> and <code class="reqn">k</code> is the model complexity measured by the number of
non-zero entries in the transition matrix.
We use the likelihood of the model given by the proportion
of supported transitions. AIC can be used for model selection
where the smallest value indicates the preferred model.
</p>
</dd>
</dl>

<p>where
<code class="reqn">x_i</code> represents the <code class="reqn">i</code>-th data point in the new sequence,
<code class="reqn">a(i,j)</code> is the transition probability from state <code class="reqn">i</code>
to state <code class="reqn">j</code> in the model,
<code class="reqn">s(i)</code> is the state the <code class="reqn">i</code>-th data point (<code class="reqn">x_i</code>) in
the new sequence is assigned to.
<code class="reqn">\mathrm{I(v)}</code> is an indicator function which is 0 for <code class="reqn">v=0</code> and 1 otherwise.
</p>
<p>For <code>match_cluster="weighted"</code>:
</p>

<dl>
<dt>&quot;product&quot;</dt><dd>
<p>Weighted version of the product of probabilities. The weight is
the  similarity between a new data point and the state in the model
it is assigned to.
</p>
<p style="text-align: center;"><code class="reqn">S_\mathrm{weighted\_product} = \sqrt[l-1]{\prod_{i=1}^{l-1}{\mathrm{simil}(x_i,s(i))\mathrm{simil}(x_i,s(i+1))  a_{s(i),s(i+1)}}}</code>
</p>

</dd>
<dt>&quot;sum&quot;</dt><dd>
<p>Weighted version of the sum of probabilities.
</p>
<p style="text-align: center;"><code class="reqn">S_\mathrm{weighted\_sum} = \frac{1}{l-1} \sum_{i=1}^{l-1}{\mathrm{simil}(x_i,s(i))\mathrm{simil}(x_i,s(i+1))  a_{s(i),s(i+1)}}</code>
</p>

</dd>
<dt>&quot;log_sum&quot;</dt><dd>
<p>Weighted version of the sum of the log of probabilities.
</p>
<p style="text-align: center;"><code class="reqn">S_\mathrm{weighted\_log\_sum} = \frac{1}{l-1} \sum_{i=1}^{l-1}{\mathrm{log}(\mathrm{simil}(x_i,s(i))\mathrm{simil}(x_i,s(i+1))  a_{s(i),s(i+1)})}</code>
</p>

</dd>
<dt>&quot;supported_states&quot;</dt><dd>
<p>Same as <code>"supported_states"</code> but instead of counting the
supported states, the similarity <code class="reqn">\mathrm{simil}(x_i,s(i))</code>
is used as a weight. Threshold is not implemented.
</p>
</dd>
</dl>

<p>where <code class="reqn">\mathrm{simil}(\cdot)</code> is a modified and normalized
similarity function given by
<code class="reqn">\mathrm{simil}(x,s) =  1- \frac{1}{1+e^{-\frac{\mathrm{d}(x, s)/t -1.5}{.2}}}</code>
where <code class="reqn">d</code> is the distance measure and <code class="reqn">t</code> is the threshold that
was used to create the model.
</p>


<h3>Value</h3>

<p>A scalar score value.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+transition">transition</a></code> to access transition probabilities
and <code><a href="#topic+find_clusters">find_clusters</a></code> for assigning observations to states/clusters. </p>


<h3>Examples</h3>

<pre><code class='language-R'>data("EMMsim")

emm &lt;- EMM(threshold = .2)
emm &lt;- build(emm, EMMsim_train)

# default is method "product". The score is much higher compared to a randomized order.
score(emm, EMMsim_test)
score(emm, EMMsim_test, random = TRUE)


### create shuffled data (destroy temporal relationship)
### and create noisy data
test_shuffled &lt;- EMMsim_test[sample(1:nrow(EMMsim_test)), ]
test_noise &lt;- jitter(EMMsim_test, amount = .3)

### helper for plotting
mybars &lt;- function(...) {
  oldpar &lt;- par(mar = c(5, 10, 4, 2))
  ss &lt;- rbind(...)
  barplot(
    ss[, ncol(ss):1],
    xlim = c(-1, 4),
    beside = TRUE,
    horiz = TRUE,
    las = 2,
    legend = rownames(ss)
  )
  par(oldpar)
}


### compare various scores
methods &lt;- c(
  "product",
  "sum",
  "log_sum",
  "supported_states",
  "supported_transitions",
  "sum_transitions",
  "log_loss",
  "likelihood"
)

### default is exact matching
clean &lt;-
  sapply(
    methods,
    FUN = function(m)
      score(emm, EMMsim_test, method = m)
  )

shuffled &lt;-
  sapply(
    methods,
    FUN = function(m)
      score(emm, test_shuffled, method = m)
  )

noise &lt;-
  sapply(
    methods,
    FUN = function(m)
      score(emm, test_noise, method = m)
  )

mybars(shuffled, noise, clean)

### weighted matching is better for noisy data
clean &lt;-
  sapply(
    methods,
    FUN = function(m)
      score(emm, EMMsim_test, method = m,
        match = "weighted")
  )

shuffled &lt;-
  sapply(
    methods,
    FUN = function(m)
      score(emm, test_shuffled, method = m,
        match = "weighted")
  )

noise &lt;-
  sapply(
    methods,
    FUN = function(m)
      score(emm, test_noise, method = m,
        match = "weighted")
  )

mybars(shuffled, noise, clean)
</code></pre>

<hr>
<h2 id='smooth_transitions'>Smooths transition counts between neighboring states/clusters</h2><span id='topic+smooth_transitions'></span><span id='topic+smooth_transitions+2CEMM-method'></span>

<h3>Description</h3>

<p>Each state/cluster gets the average count if all the outgoing transitions of
its neighbors (i.e., clusters which are within range x its threshold).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'EMM'
smooth_transitions(x, range = 2, copy = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="smooth_transitions_+3A_x">x</code></td>
<td>
<p> an object of class <code>"EMM"</code></p>
</td></tr>
<tr><td><code id="smooth_transitions_+3A_range">range</code></td>
<td>
<p> threshold multiplier for the smoothing range.</p>
</td></tr>
<tr><td><code id="smooth_transitions_+3A_copy">copy</code></td>
<td>
<p> logical; make a copy of x before reclustering? Otherwise the function will change <code>x</code>!</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>smooth_transitions</code> returns invisibly an object of class <code>EMM</code>.
If <code>copy=FALSE</code> then it returns a reference to the changes
object passed as <code>x</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+prune">prune</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("EMMTraffic")

## learn a model
emm &lt;- EMM(threshold=0.2, measure="eJaccard")
build(emm, EMMTraffic)

## smooth the model by adding tansitions
emm_s &lt;- smooth_transitions(emm)

## compare graphs
op &lt;- par(mfrow = c(1, 2), pty = "m")
plot(emm, method="MDS", main="Original")
plot(emm_s, method="MDS", main="Smoothed")
par(op)
</code></pre>

<hr>
<h2 id='synthetic_stream'>Create a Synthetic Data Stream</h2><span id='topic+synthetic_stream'></span>

<h3>Description</h3>

<p>This function creates a synthetic data stream
with data points in roughly <code class="reqn">[0, 1]^p</code> by choosing
points form k clusters following a sequence
through these clusters. Each cluster has a density function following a
d-dimensional normal distributions. In the test set outliers are introduced.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>synthetic_stream(k = 10, d = 2, n_subseq = 100, p_transition = 0.5, p_swap = 0,
n_train = 5000, n_test = 1000, p_outlier = 0.01, rangeVar = c(0, 0.005))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="synthetic_stream_+3A_k">k</code></td>
<td>
<p>number of clusters.</p>
</td></tr>
<tr><td><code id="synthetic_stream_+3A_d">d</code></td>
<td>
<p>dimensionality of data set.</p>
</td></tr>
<tr><td><code id="synthetic_stream_+3A_n_subseq">n_subseq</code></td>
<td>
<p>length of subsequence which will be repeat to create the data set.</p>
</td></tr>
<tr><td><code id="synthetic_stream_+3A_p_transition">p_transition</code></td>
<td>
<p>probability that the next position in the subsequence will belong to a different cluster.</p>
</td></tr>
<tr><td><code id="synthetic_stream_+3A_p_swap">p_swap</code></td>
<td>
<p>probability that two data points are swapped. This represents
measurement errors (e.g., a data points arrive out of order) or that
the data stream does not exactly follow the subsequence.</p>
</td></tr>
<tr><td><code id="synthetic_stream_+3A_n_train">n_train</code></td>
<td>
<p>size of training set (without outliers).</p>
</td></tr>
<tr><td><code id="synthetic_stream_+3A_n_test">n_test</code></td>
<td>
<p>size of test set (with outliers).</p>
</td></tr>
<tr><td><code id="synthetic_stream_+3A_p_outlier">p_outlier</code></td>
<td>
<p>probability that a data point is replaced by an outlier
(a randomly chosen point in <code class="reqn">[0,1]^p</code>).</p>
</td></tr>
<tr><td><code id="synthetic_stream_+3A_rangevar">rangeVar</code></td>
<td>
<p>Used to create the random covariance matrices for the
clusters. See <code>genPositiveDefMat()</code> in <span class="pkg">clusterGeneration</span>
for details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The data generation process creates a data set consisting of <code>k</code>
clusters in
roughly <code class="reqn">[0,1]^d</code>.  The data points for each cluster are be drawn from a
multivariate normal distribution given a random mean and a random
variance/covariance matrix for each cluster. The temporal aspect is modeled by
a fixed subsequence (of length <code>n_subseq</code>) through the k
clusters. In each step in the subsequence we
have a transition probability <code>p_transition</code> that the next data point
is in the same
cluster or in a randomly chosen other cluster, thus we can create slowly or
fast changing data.  For the complete sequence, the subsequence is repeated
to create <code>n_test</code>/<code>n_train</code> data points.
The data set is generated by drawing a data point from
the cluster corresponding to each position in the sequence. Outliers are
introduced by replacing data points in the data set with probability
<code>$p_outlier</code> by
randomly chosen data points in <code class="reqn">[0,1]^d</code>.
Finally, to introduce imperfection
in the temporal sequence (e.g., because the data does not follow exactly a
repeating sequence or because observations do not arrive in the correct order),
we swap two consecutive observations with probability <code>p_swap</code>.
</p>


<h3>Value</h3>

<p>A list with the following elements:
</p>
<table>
<tr><td><code>test</code></td>
<td>
<p> test data.</p>
</td></tr>
<tr><td><code>train</code></td>
<td>
<p> training data.</p>
</td></tr>
<tr><td><code>sequence_test</code></td>
<td>
<p> sequence of the test data points through the clusters.</p>
</td></tr>
<tr><td><code>sequence_train</code></td>
<td>
<p>sequence of the training data points through the clusters.</p>
</td></tr>
<tr><td><code>swap_test</code></td>
<td>
<p>index where points are swapped.</p>
</td></tr>
<tr><td><code>swap_train</code></td>
<td>
<p>index where points are swapped.</p>
</td></tr>
<tr><td><code>outlier_position</code></td>
<td>
<p> logical vector for outliers in test data.</p>
</td></tr>
<tr><td><code>model</code></td>
<td>
<p> centers and covariance matrices for the clusters. </p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## create only test data (with outliers)
ds &lt;- synthetic_stream(n_train = 0)

## plot test data
plot(ds$test, pch = ds$sequence_test, col = "gray")
text(ds$model$mu[, 1], ds$model$mu[, 2], 1:10)

## mark outliers
points(ds$test[ds$outlier_position, ],
  pch = 3, lwd = 2, col = "red")
</code></pre>

<hr>
<h2 id='tNN-class'>Class &quot;tNN&quot;</h2><span id='topic+tNN'></span><span id='topic+tNN-class'></span><span id='topic+StreamClustering-class'></span><span id='topic+cluster_centers'></span><span id='topic+cluster_centers+2CtNN-method'></span><span id='topic+copy+2CtNN-method'></span><span id='topic+cluster_counts'></span><span id='topic+cluster_counts+2CtNN-method'></span><span id='topic+clusters'></span><span id='topic+clusters+2CtNN-method'></span><span id='topic+nclusters'></span><span id='topic+nclusters+2CtNN-method'></span><span id='topic+last_clustering'></span><span id='topic+last_clustering+2CtNN-method'></span><span id='topic+plot+2CtNN+2Cmissing-method'></span><span id='topic+object.size+2CtNN-method'></span>

<h3>Description</h3>

<p>Implements the threshold Nearest Neighbor clustering algorithm
used by EMM.</p>


<h3>Objects from the Class</h3>

<p>Objects can be created with <code>new()</code> or by the creator function 
<code>tNN</code>.</p>


<h3>Slots</h3>


<dl>
<dt><code>measure</code>:</dt><dd><p>Object of class <code>"character"</code> containing
the name of the dissimilarity measure used  
(see <code>dist</code> in <span class="pkg">proxy</span> for available measures)</p>
</dd>
<dt><code>centroids</code>:</dt><dd><p>Object of class <code>"logical"</code> indicating
if centroids are used for clusters. If <code>FALSE</code>,
pseudo medians (first observation of a cluster) are used
to represent a cluster.</p>
</dd>
<dt><code>threshold</code>:</dt><dd><p>Object of class <code>"numeric"</code> 
with the dissimilarity threshold used
by the NN clustering algorithm for assigning a new
observation to existing clusters.</p>
</dd>
<dt><code>lambda</code>:</dt><dd><p>Object of class <code>"numeric"</code> specifying the
rate for fading.</p>
</dd>
<dt><code>lambda_factor</code>:</dt><dd><p>Object of class <code>"numeric"</code> expressing
the fading rate expressed as a factor.</p>
</dd>
<dt><code>tnn_d</code>:</dt><dd><p>An environment containing the variable
data for the tNN object:
</p>

<dl>
<dt><code>centers</code>:</dt><dd><p>Object of class <code>"matrix"</code> containing 
the cluster centers. </p>
</dd>
<dt><code>counts</code>:</dt><dd><p>Object of class <code>"numeric"</code> with the 
number of observations assigned to each cluster.</p>
</dd>
<dt><code>var_thresholds</code>:</dt><dd><p>Object of class <code>"numeric"</code> with the
dissimilarity thresholds for individual clusters (usually
the same as threshold).</p>
</dd>
<dt><code>last</code>:</dt><dd><p>A <code>"character"</code> vector containing the
cluster names the points for the previous call of
<code>cluster()</code> were assigned to.</p>
</dd>
</dl>

</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>copy</dt><dd><p><code>signature(x = "tNN")</code>: Make a copy of the tNN object. 
Making explicit copies is necessary since 
information is stored in an environment which is not copied 
for regular assignements.</p>
</dd>
<dt>cluster_centers</dt><dd><p><code>signature(x = "tNN")</code>: returns the cluster
centers as a matrix.</p>
</dd>
<dt>cluster_counts</dt><dd><p><code>signature(x = "tNN")</code>: returns the cluster 
counts as a vector.</p>
</dd>
<dt>clusters</dt><dd><p><code>signature(x = "tNN")</code>: returns the names of the
clusters.</p>
</dd>
<dt>last_clustering</dt><dd><p><code>signature(x = "tNN")</code>: returns the 
indices of the clusters the data points in the last cluster 
operation where assigned to. To save memory the last clustering 
information can be removed by setting the formal parameter
<code>remove</code> to <code>TRUE</code>.</p>
</dd>
<dt>nclusters</dt><dd><p><code>signature(x = "tNN")</code>: returns the number of clusters
in the clustering.</p>
</dd>
<dt>plot</dt><dd><p><code>signature(x = "tNN", y = "missing")</code>: plots the cluster
centers using a scatterplot matrix (see <code>pairs</code>).</p>
</dd>
</dl>



<h3>References</h3>

<p>M.H. Dunham, Y. Meng, J. Huang (2004): Extensible Markov Model, In:
<em>ICDM '04: Proceedings of the Fourth IEEE International
Conference on Data Mining,</em> pp. 371&ndash;374.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cluster">cluster</a></code> for adding new data to the clustering.
<code><a href="#topic+find_clusters">find_clusters</a></code> to find the nearest neighbor cluster 
for given data points.
<code><a href="#topic+EMM-class">EMM</a></code> extends &quot;tNN&quot;.
</p>

<hr>
<h2 id='TRAC'>TRAC: Creating a Markov Model from a Regular Clustering</h2><span id='topic+TRAC'></span>

<h3>Description</h3>

<p>Create an Markov model from a regular clustering (k-means or PAM) of
sequence data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TRAC(x, data = NULL, centers = NULL, measure = "euclidean")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="TRAC_+3A_x">x</code></td>
<td>
<p> a clustering object (result of kmeans or PAM), a
data set (a data matrix), or a vector with (integer) cluster assignments. </p>
</td></tr>
<tr><td><code id="TRAC_+3A_data">data</code></td>
<td>
<p> the data used for clustering (only used if <code>x</code>
is a cluster assignment vector).</p>
</td></tr>
<tr><td><code id="TRAC_+3A_centers">centers</code></td>
<td>
<p> if <code>x</code> is a cluster assignment vector, then a data.frame or matrix with the cluster centers needs to be supplies. Otherwise, <code>centers</code> is ignored.</p>
</td></tr>
<tr><td><code id="TRAC_+3A_measure">measure</code></td>
<td>
<p> used distance measure.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The order is inferred from the order in the original data set.
</p>


<h3>Value</h3>

<p>A <code>EMM</code> object representing the clustering of sequence data.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("EMMsim")

## using kmeans
cl &lt;- kmeans(EMMsim_train, 10)
emm &lt;- TRAC(cl)
emm
plot(emm, method = "MDS")

## using a cluster assignment vector (taken from the k-means clustering above)
x &lt;- cl$cluster
emm &lt;- TRAC(x, data = EMMsim_train)
emm
plot(emm, method = "MDS")
</code></pre>

<hr>
<h2 id='TRACDS-class'>Class &quot;TRACDS&quot;</h2><span id='topic+TRACDS-class'></span><span id='topic+TRACDS'></span><span id='topic+as.igraph'></span><span id='topic+as.igraph.TRACDS'></span><span id='topic+as.graph'></span><span id='topic+as.graph.TRACDS'></span><span id='topic+current_state'></span><span id='topic+current_state+2CTRACDS-method'></span><span id='topic+nstates'></span><span id='topic+nstates+2CTRACDS-method'></span><span id='topic+ntransitions'></span><span id='topic+ntransitions+2CTRACDS-method'></span><span id='topic+copy+2CTRACDS-method'></span><span id='topic+states'></span><span id='topic+states+2CTRACDS-method'></span><span id='topic+show+2CTRACDS-method'></span><span id='topic+plot+2CTRACDS+2Cmissing-method'></span><span id='topic+transitions'></span><span id='topic+transitions+2CTRACDS-method'></span><span id='topic+object.size+2CTRACDS-method'></span>

<h3>Description</h3>

<p>Representation of the temporal structure of a data stream clustering using a extensible Markov model.</p>


<h3>Objects from the Class</h3>

<p>Objects can be created using the creator function <code>TRACDS</code> or by
directly calling <code>new("TRACDS", ...)</code>. Most slots for the extended
classes can be used as parameters.
</p>


<h3>Slots</h3>


<dl>
<dt><code>lambda</code>:</dt><dd><p>Object of class <code>"numeric"</code> specifying the
rate for fading.</p>
</dd>
<dt><code>lambda_factor</code>:</dt><dd><p>Object of class <code>"numeric"</code> expressing
the fading rate expressed as a factor.</p>
</dd>
<dt><code>tracds_d</code>:</dt><dd><p>An environment containing all the
variable data of the TRACDS object:
</p>

<dl>
<dt><code>mm</code>:</dt><dd><p>Object of class <code>"SimpleMC"</code> representing the 
first order Markov model of the EMM. </p>
</dd>
<dt><code>current_state</code>:</dt><dd><p>Object of class <code>"character"</code> with the
name of current state in the EMM. <code>NA</code> means
no current state.</p>
</dd>
</dl>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>copy</dt><dd><p><code>signature(x = "TRACDS")</code>: Make a copy of the TRACDS object.
Making explicit copies is necessary since
information is stored in an environment which is not copied for regular
assignements.</p>
</dd>
<dt>current_state</dt><dd><p><code>signature(x = "TRACDS")</code>: returns the name of 
the current state. </p>
</dd>
<dt>nstates</dt><dd><p><code>signature(x = "TRACDS")</code>: returns the number of states.</p>
</dd>
<dt>ntransitions</dt><dd><p><code>signature(x = "TRACDS")</code>: returns the number of transitions with a count larger than 0 stored in the object.</p>
</dd>
<dt>plot</dt><dd><p><code>signature(x = "TRACDS", y = "missing")</code>: Plots the
object as a directed graph.</p>
</dd>
<dt>states</dt><dd><p><code>signature(x = "TRACDS")</code>: returns the names of the
states.</p>
</dd>
<dt>transitions</dt><dd><p><code>signature(x = "TRACDS")</code>: returns all transitions		as a matrix of state names with a from and a to column. </p>
</dd>
</dl>



<h3>Note</h3>

<p>A TRACDS object can be coerced to igraph or graph objects using 
<code>as.igraph</code>() and <code>as.graph()</code>.</p>


<h3>References</h3>

 
<p>Michael Hahsler and Margaret H. Dunham. Temporal structure learning for clustering massive data streams in real-time. In <em>SIAM Conference on Data Mining</em> (SDM11), pages 664&ndash;675. SIAM, April 2011. <a href="https://doi.org/10.1137/1.9781611972818.57">doi:10.1137/1.9781611972818.57</a>
</p>
<p>M. Hahsler, M. H. Dunham (2010): rEMM: Extensible Markov Model for 
Data Stream Clustering in R, <em>Journal of Statistical Software,</em> 35(5), 1-31,
URL <a href="https://doi.org/10.18637/jss.v035.i05">doi:10.18637/jss.v035.i05</a>
</p>
<p>M.H. Dunham, Y. Meng, J. Huang (2004): Extensible Markov Model, In:
<em>ICDM '04: Proceedings of the Fourth IEEE International
Conference on Data Mining,</em> pp. 371&ndash;374.
</p>


<h3>See Also</h3>

<p>Look at
<code><a href="#topic+transition">transition</a></code>,
<code><a href="#topic+transition_matrix">transition_matrix</a></code> and 
<code><a href="#topic+initial_transition">initial_transition</a></code> to access the transition information in
the EMM.
<code><a href="#topic+predict">predict</a></code> is used to predict future states of an EMM.
<code><a href="#topic+EMM-class">EMM</a></code> extends <code>"TRACDS"</code>.
</p>

<hr>
<h2 id='transition'>Access Transition Probabilities/Counts in an EMM </h2><span id='topic+transition'></span><span id='topic+transition+2CTRACDS+2Ccharacter+2Ccharacter-method'></span><span id='topic+transition+2CTRACDS+2Cmatrix+2Cmissing-method'></span><span id='topic+transition+2CTRACDS+2Cdata.frame+2Cmissing-method'></span><span id='topic+transition_matrix'></span><span id='topic+transition_matrix+2CTRACDS-method'></span><span id='topic+initial_transition'></span><span id='topic+initial_transition+2CTRACDS-method'></span>

<h3>Description</h3>

<p>Calculates individual transition probabilities/counts 
or a complete transition matrix
for an EMM (which contains <code>"TRACDS"</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'TRACDS,character,character'
transition(x, from, to, 
          type = c("probability", "counts", "log_odds"), prior = TRUE)
## S4 method for signature 'TRACDS'
transition_matrix(x, 
          type = c("probability", "counts", "log_odds"), prior = TRUE)
## S4 method for signature 'TRACDS'
initial_transition(x, 
          type = c("probability", "counts", "log_odds"), prior = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="transition_+3A_x">x</code></td>
<td>
<p> an object of class <code>"EMM"</code>/<code>"TRACDS"</code>.</p>
</td></tr>
<tr><td><code id="transition_+3A_from">from</code>, <code id="transition_+3A_to">to</code></td>
<td>
<p> Names a states. If <code>to</code> is missing, 
<code>from</code> has
to contain a matrix with two columns (a from column and a 
to column as returned by <code>transitions</code>).</p>
</td></tr>
<tr><td><code id="transition_+3A_type">type</code></td>
<td>
<p> What should be calculated? </p>
</td></tr>
<tr><td><code id="transition_+3A_prior">prior</code></td>
<td>
<p> add one to each transition count. This is equal
to starting with a uniform prior for the transition count distribution, 
i.e., initially all transitions are equally likely. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Log odds are calculated as <code class="reqn">ln(a/(1/n))</code> where <code class="reqn">a</code> is the probability
of the transition and <code class="reqn">n</code> is the number of states in the EMM.  <code class="reqn">1/n</code> is
the probability of a transition under the null model which assumes that the
transition probability from each state to each other state (including staying
in the same state) is the same, i.e., the null model has a transition matrix
with all entries equal to <code class="reqn">1/n</code>.
</p>


<h3>Value</h3>

<p>A scalar (for <code>transition</code>), a square matrix 
(for <code>transition_matrix</code>) or a vector (for <code>initial_transition</code>).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+EMM-class">EMM</a></code> which contains 
<code><a href="#topic+TRACDS-class">TRACDS</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data("EMMTraffic")
emm &lt;- EMM(measure="eJaccard", threshold=0.2)
emm &lt;- build(emm, EMMTraffic)

## get transition matrix
transition_matrix(emm, type="count", prior=FALSE)
transition_matrix(emm, type="count")
transition_matrix(emm, prior=FALSE)
transition_matrix(emm)

## get initial state probabilities
initial_transition(emm)

## access individual transition probability (state 1 -&gt; 2)
transition(emm, "1","2")

## get counts for all existing transitions
tr &lt;- transitions(emm)
tr
cbind(as.data.frame(tr), counts=transition(emm, tr, type="counts"))
</code></pre>

<hr>
<h2 id='transition_table'>Extract a Transition Table for a New Sequence Given an EMM</h2><span id='topic+transition_table'></span><span id='topic+transition_table+2CEMM+2Cnumeric-method'></span><span id='topic+transition_table+2CEMM+2Cdata.frame-method'></span><span id='topic+transition_table+2CEMM+2Cmatrix-method'></span>

<h3>Description</h3>

<p>Finds the state sequence of a new sequence in an EMM and returns a table
with the transition probabilities or counts.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'EMM,matrix'
transition_table(x, newdata, 
  type = c("probability", "counts", "log_odds"), 
  match_cluster = "exact", prior=TRUE, initial_transition = FALSE)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="transition_table_+3A_x">x</code></td>
<td>
<p> an <code>EMM</code> object. </p>
</td></tr>
<tr><td><code id="transition_table_+3A_newdata">newdata</code></td>
<td>
<p> new sequence, </p>
</td></tr>
<tr><td><code id="transition_table_+3A_type">type</code></td>
<td>
<p> the measure to return. </p>
</td></tr>
<tr><td><code id="transition_table_+3A_match_cluster">match_cluster</code></td>
<td>
<p> do the new observations have to fall within
the threshold of the cluster (<code>"exact"</code>) or is nearest neighbor 
used (<code>"nn"</code>)?</p>
</td></tr>
<tr><td><code id="transition_table_+3A_prior">prior</code></td>
<td>
<p> add one to each transition count. This is equal
to starting with a uniform prior for the transition count distribution, 
i.e. initially all transitions are equally likely. It also prevents the 
product of probabilities to be zero if a transition was never observed. </p>
</td></tr>
<tr><td><code id="transition_table_+3A_initial_transition">initial_transition</code></td>
<td>
<p> include the initial transition 
in the table?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame with three columns (from state, to state and the 
transition probability/count.)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+transition">transition</a></code> to access transition probabilities
and <code><a href="#topic+find_clusters">find_clusters</a></code> for assigning observations to states/clusters. </p>


<h3>Examples</h3>

<pre><code class='language-R'>data("EMMsim")

emm &lt;- EMM(threshold=.5)
emm &lt;- build(emm, EMMsim_train)

head(transition_table(emm, EMMsim_test))
head(transition_table(emm, EMMsim_test, type ="prob", initial_transition=TRUE))
</code></pre>

<hr>
<h2 id='update'>Update a TRACDS temporal structure with new state assignements</h2><span id='topic+update'></span><span id='topic+update+2CTRACDS-method'></span><span id='topic+reset'></span><span id='topic+reset+2CTRACDS-method'></span><span id='topic+compact'></span><span id='topic+compact+2CTRACDS-method'></span>

<h3>Description</h3>

<p>Add a sequence of new state assignments to a TRACDS object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'TRACDS'
update(object, newdata, verbose=FALSE, ...)
reset(x)
compact(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="update_+3A_x">x</code>, <code id="update_+3A_object">object</code></td>
<td>
<p> a <code>TRACDS</code> object. Note that this function changes the original object! </p>
</td></tr>
<tr><td><code id="update_+3A_newdata">newdata</code></td>
<td>
<p> a vector with a state assignemnt sequence (typically 
produced by clustering). </p>
</td></tr>
<tr><td><code id="update_+3A_verbose">verbose</code></td>
<td>
<p> logical; verbose output? </p>
</td></tr>
<tr><td><code id="update_+3A_...">...</code></td>
<td>
<p> further arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>update()</code>
adds a new state assignemnt sequenc to the TRACDS object by increasing the
transition counts and, if needed, creating new states.
</p>
<p><code>reset()</code> resets the current state to <code>NA</code> for reading in a
new sequence. An <code>NA</code> in <code>newdata</code>
also resets the current state.
</p>
<p><code>compact()</code> reduces the size (memory) used to store the temporal
transition matrix.
</p>


<h3>Value</h3>

<p>A reference to the changed TRACDS object with the data added. 
Note: EMM objects store all variable data in an environment which 
enables us to update partial data without copying the whole object. Assignment
will not create a copy! Use the provided method <code>copy()</code>. 
</p>


<h3>See Also</h3>

 
<p>Class <code><a href="#topic+TRACDS-class">TRACDS</a></code>, 
<code><a href="#topic+fade">fade</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>## create an empty TRACDS object
tracds &lt;- TRACDS()
tracds

## update with an cluster assignment sequence
update(tracds, c(1,2,5,5,2))
tracds

plot(tracds)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
