<!DOCTYPE html><html lang="en"><head><title>Help for package dagR</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {dagR}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#dagR-package'>
<p>Directed Acyclic Graphs: Analysis and Data Simulation</p></a></li>
<li><a href='#add.arc'>
<p>Add an arc to a DAG.</p></a></li>
<li><a href='#add.node'>
<p>Add a node to an existing DAG.</p></a></li>
<li><a href='#addAngle'>
<p>Sum up two radian angles.</p></a></li>
<li><a href='#allCombs'>
<p>Create all combinations of the elements of a vector.</p></a></li>
<li><a href='#angle'>
<p>Calculate radian angle of line between two points.</p></a></li>
<li><a href='#anglePoint'>
<p>Calculate coordinates at specific angle and distance.</p></a></li>
<li><a href='#assoc.exists'>
<p>Check if association between two DAG nodes exists.</p></a></li>
<li><a href='#brute.search'>
<p>Evaluate all possible adjustment sets of a DAG.</p></a></li>
<li><a href='#dag.adjust'>
<p>Adjust an existing DAG for covariables.</p></a></li>
<li><a href='#dag.adjustment'>
<p>Adjust a DAG for one or more variables.</p></a></li>
<li><a href='#dag.ancestors'>
<p>Identify ancestors of DAG nodes.</p></a></li>
<li><a href='#dag.draw'>
<p>Draw a DAG.</p></a></li>
<li><a href='#dag.init'>
<p>Set up a new DAG.</p></a></li>
<li><a href='#dag.legend'>
<p>Write the legend in a DAG drawing.</p></a></li>
<li><a href='#dag.letter'>
<p>Write a DAG node symbol.</p></a></li>
<li><a href='#dag.letter2'>
<p>Return a DAG node symbol.</p></a></li>
<li><a href='#dag.move'>
<p>Interactively move a node or curving point in a DAG.</p></a></li>
<li><a href='#dag.search'>
<p>Evaluate possible adjustment sets of a DAG.</p></a></li>
<li><a href='#dag.sim'>
<p>Simulate data based on a DAG.</p></a></li>
<li><a href='#dag.sim2'>
<p>Simulate data based on a DAG.</p></a></li>
<li><a href='#dagR2dagitty'>
<p>Create dagitty code from a dagR DAG</p></a></li>
<li><a href='#demo.dag0'>
<p>Set up demo DAG #0.</p></a></li>
<li><a href='#demo.dag1'>
<p>Set up demo DAG #1.</p></a></li>
<li><a href='#demo.dag2'>
<p>Set up demo DAG #2.</p></a></li>
<li><a href='#demo.dag3'>
<p>Set up demo DAG #3.</p></a></li>
<li><a href='#demo.dag4'>
<p>Set up demo DAG #4.</p></a></li>
<li><a href='#demo.dag5'>
<p>Set up demo DAG #5.</p></a></li>
<li><a href='#demo.dag6'>
<p>Set up demo DAG #6.</p></a></li>
<li><a href='#demo.dag7'>
<p>Set up demo DAG #7.</p></a></li>
<li><a href='#distPoints'>
<p>Calculate distance between two points.</p></a></li>
<li><a href='#eval.paths'>
<p>Evaluate potentially biasing paths in a DAG.</p></a></li>
<li><a href='#find.paths'>
<p>Find potentially biasing paths in a DAG.</p></a></li>
<li><a href='#garrows'>
<p>Draw a directed arc in a DAG.</p></a></li>
<li><a href='#inAngle'>
<p>Calculate angle between two arcs.</p></a></li>
<li><a href='#is.acyclic'>
<p>Check if a DAG actually is acyclic.</p></a></li>
<li><a href='#is.in'>
<p>Check if a specific numeric value occurs in a vector.</p></a></li>
<li><a href='#is.unknown'>
<p>Check if a DAG node presents an unknown variable.</p></a></li>
<li><a href='#msas'>
<p>Identify minimal sufficient adjustment sets.</p></a></li>
<li><a href='#plot.dagRdag'>
<p>Function to draw a DAG</p></a></li>
<li><a href='#print.dagRdag'>
<p>Prints the raw contents of an object of class dagRdag.</p></a></li>
<li><a href='#rm.arc'>
<p>Remove an arc from a DAG.</p></a></li>
<li><a href='#rm.node'>
<p>Remove a node from a DAG.</p></a></li>
<li><a href='#smoothArc'>
<p>Draw an undirected assocation in a DAG.</p></a></li>
<li><a href='#summary_dagRdag'>
<p>Summarize a DAG.</p></a></li>
<li><a href='#summary.dagRdag'>
<p>Summarize a DAG.</p></a></li>
<li><a href='#viv'>
<p>Is a numeric vector in another vector?</p></a></li>
<li><a href='#write.paths'>
<p>Write the paths into a DAG drawing.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Directed Acyclic Graphs: Analysis and Data Simulation</td>
</tr>
<tr>
<td>Version:</td>
<td>1.2.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-10-08</td>
</tr>
<tr>
<td>Author:</td>
<td>Lutz P Breitling</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Lutz P Breitling &lt;l.breitling@posteo.de&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Draw, manipulate, and evaluate directed
        acyclic graphs and simulate corresponding data, as described in International Journal of Epidemiology 50(6):1772-1777.</td>
</tr>
<tr>
<td>Imports:</td>
<td>graphics, stats, utils</td>
</tr>
<tr>
<td>Suggests:</td>
<td>dagitty(&ge; 0.3-1)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-10-09 09:00:17 UTC; lpb</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-10-09 09:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='dagR-package'>
Directed Acyclic Graphs: Analysis and Data Simulation
</h2><span id='topic+dagR-package'></span><span id='topic+dagR'></span>

<h3>Description</h3>

<p>The package dagR contains a couple of functions to draw, manipulate and evaluate directed acyclic graphs (DAG), with a focus on epidemiologic applications, namely the assessment of adjustment sets and potentially biasing paths.
The functions for finding and evaluating paths essentially implement the graphical algorithms outlined in Greenland (1999).<br /><br />
When using this package for your work, please cite Breitling (2010) and/or Breitling et al. (2022).<br /><br />
For motivations to use this package in epidemiology teaching and methodological research, please refer
to Duan et al. (2022).<br /><br />
<em>Note: As spelled out in the license, this suite of functions comes without any warranty, and cautious use is strongly advised.
Although testing was carried out as meticulously as possible, it must be expected that bugs or errors remain, in particular in the early versions of the package.
Please report any problems, concerns, but also suggestions for improvements or extensions to the author.</em><br /><br />
Important additions in future versions could be e.g. improved drawing routines with better formatting of alternative node symbols in the DAG (taking into account the string length) and algorithms with intelligent/efficient search for minimal adjustment sets.
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> dagR</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 1.2.1</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2022-10-09</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL-2</td>
</tr>
<tr>
 <td style="text-align: left;">
LazyLoad: </td><td style="text-align: left;"> yes</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p><code><a href="#topic+dag.init">dag.init</a></code> is used for setting up DAGs. See the code of the functions <code>demo.dag0</code> to <code>demo.dag6</code> for example code.
To adjust and/or evalute DAGs for biasing paths, use <code><a href="#topic+dag.adjust">dag.adjust</a></code>, <code><a href="#topic+dag.draw">dag.draw</a></code> for drawing a DAG.
<code><a href="#topic+dag.search">dag.search</a></code> uses <code><a href="#topic+brute.search">brute.search</a></code> to evaluate all possible adjustment sets, allowing the identification of minimal sufficient adjustment sets using <code><a href="#topic+msas">msas</a></code>.
<code><a href="#topic+dag.sim">dag.sim</a></code> simulates data (normally distributed or binary) according to
the causal structure given by a DAG object.<br /> 
In version 1.2.0, generic S3 methods (print, plot, summary) for dagR-DAGs were implemented, but the original functions <code>summary_dagRdag</code> to summarize and <code>dag.draw</code> to plot a DAG object were preserved for backwards compatibility. Export functions to other packages were added upon a reviewer request.<br /> Several helper functions currently are not hidden and should later be made internal.
<br /> <br /> <em>Please see the NEWS file for version changes and known open issues.</em>
</p>


<h3>Author(s)</h3>

<p>Lutz P Breitling &lt;l.breitling@posteo.de&gt;
</p>


<h3>References</h3>

<p>Breitling LP (2010). dagR: a suite of R functions for directed acyclic graphs. Epidemiology 21(4):586-587.<br />
Breitling LP, Duan C, Dragomir AD, Luta G (2022). Using dagR to identify minimal sufficient adjustment sets and to simulate data based on directed acyclic graphs. Int J Epidemiol  50(6):1772-1777 &lt;doi: <a href="https://doi.org/10.1093/ije/dyab167">10.1093/ije/dyab167</a>&gt;.<br />
Duan C, Dragomir AD, Luta G, Breitling LP (2022). Reflection on modern methods: Understanding bias and data analytical strategies through DAG-based data simulations. Int J Epidemiol 50(6):2091-2097 &lt;doi: <a href="https://doi.org/10.1093/ije/dyab096">10.1093/ije/dyab096</a>&gt;.<br />
Greenland S, Pearl J, Robins JM (1999). Causal diagrams for epidemiologic research. Epidemiology 10(1):37-48.<br />
</p>

<hr>
<h2 id='add.arc'>
Add an arc to a DAG.
</h2><span id='topic+add.arc'></span>

<h3>Description</h3>

<p>Conveniently add an arc to an existing DAG.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add.arc(dag, arc, type = 0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="add.arc_+3A_dag">dag</code></td>
<td>

<p>The DAG to which an arc should be added.
</p>
</td></tr>
<tr><td><code id="add.arc_+3A_arc">arc</code></td>
<td>

<p>A vector of length 2, indicating from which node (first element) to
which node (second element) the arc is to go.
Note: the node numbering follows the numbering of the existing
DAG (as shown in <code>dag.draw</code> with option <code>numbering=T</code>), not the numbering of <code>dag.init</code>.
</p>
</td></tr>
<tr><td><code id="add.arc_+3A_type">type</code></td>
<td>

<p>0 (=default) for a directed arc, 1 for an undirected association.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A DAG with the arc (and corresponding <code>arc.type</code>) added, and with the
path-related variables (<code>paths</code>, <code>pathsN</code>, <code>path.status</code>, <code>searchType</code>, <code>searchRes</code>) removed.
</p>


<h3>Author(s)</h3>

<p>Lutz P Breitling &lt;l.breitling@posteo.de&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rm.arc">rm.arc</a></code>, <code><a href="#topic+add.node">add.node</a></code>, <code><a href="#topic+rm.node">rm.node</a></code>
</p>

<hr>
<h2 id='add.node'>
Add a node to an existing DAG.
</h2><span id='topic+add.node'></span>

<h3>Description</h3>

<p>Conveniently adds a node to an existing DAG, inserting its coordinates and
label before the outcome node. Also updates the arcs correspondingly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add.node(dag, name = "unknown", type = 1, x = NA, y = NA)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="add.node_+3A_dag">dag</code></td>
<td>

<p>The DAG to which the node is to be added.
</p>
</td></tr>
<tr><td><code id="add.node_+3A_name">name</code></td>
<td>

<p>Label for the node (defaults to &quot;unknown&quot;).
</p>
</td></tr>
<tr><td><code id="add.node_+3A_type">type</code></td>
<td>

<p>Type of node (1=covariable, 2=unknown); defaults to 1.
</p>
</td></tr>
<tr><td><code id="add.node_+3A_x">x</code></td>
<td>

<p>X coordinate for the node position.
</p>
</td></tr>
<tr><td><code id="add.node_+3A_y">y</code></td>
<td>

<p>Y coordinate for the node position.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If no x and y coordinates are provided, the function places the node
in an arbitrary position, slightly different with each additional
node, so that one can more easily replace the nodes afterwards
using <code>dag.move</code>.
</p>


<h3>Value</h3>

<p>A DAG with the new node added.
</p>


<h3>Author(s)</h3>

<p>Lutz P Breitling &lt;l.breitling@posteo.de&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rm.node">rm.node</a></code>, <code><a href="#topic+add.arc">add.arc</a></code>, <code><a href="#topic+rm.arc">rm.arc</a></code>
</p>

<hr>
<h2 id='addAngle'>
Sum up two radian angles.
</h2><span id='topic+addAngle'></span>

<h3>Description</h3>

<p>Adds two radian angles together and applies modulus 2*pi.
This is internally called by smoothArc, though hardly needed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>addAngle(a, b)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="addAngle_+3A_a">a</code></td>
<td>

<p>Angle 1 in radian.
</p>
</td></tr>
<tr><td><code id="addAngle_+3A_b">b</code></td>
<td>

<p>Angle 2 in radian.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric value [0, 2*pi).
</p>


<h3>Author(s)</h3>

<p>Lutz P Breitling &lt;l.breitling@posteo.de&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+smoothArc">smoothArc</a></code>
</p>

<hr>
<h2 id='allCombs'>
Create all combinations of the elements of a vector.
</h2><span id='topic+allCombs'></span>

<h3>Description</h3>

<p>Creates a matrix with all combinations of 1 to all elements of the
vector provided. Elements to occur in all combinations can be specified.
This is internally called by <code>brute.search</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>allCombs(x, force = c(), trace = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="allCombs_+3A_x">x</code></td>
<td>

<p>A vector of elements of which combinations are to be formed.
</p>
</td></tr>
<tr><td><code id="allCombs_+3A_force">force</code></td>
<td>

<p>A vector of elements that are supposed to occur in each combination.
</p>
</td></tr>
<tr><td><code id="allCombs_+3A_trace">trace</code></td>
<td>

<p>A boolean indicating if some output should be printed (TRUE) or
not (FALSE=default).
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with one combination per row. For the shorter combinations,
the columns to the right are filled up with NA.
</p>


<h3>Author(s)</h3>

<p>Lutz P Breitling &lt;l.breitling@posteo.de&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+brute.search">brute.search</a></code>
</p>

<hr>
<h2 id='angle'>
Calculate radian angle of line between two points.
</h2><span id='topic+angle'></span>

<h3>Description</h3>

<p>Calculates the radian angle of the line connecting two points.
Internally called by <code>smoothArc</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>angle(A, B)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="angle_+3A_a">A</code></td>
<td>

<p>Vector of length two indicating the coordinates of the first point.
</p>
</td></tr>
<tr><td><code id="angle_+3A_b">B</code></td>
<td>

<p>Vector of length two indicating the coordinates of the second point.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric value [0, 2*pi).
</p>


<h3>Author(s)</h3>

<p>Lutz P Breitling &lt;l.breitling@posteo.de&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+smoothArc">smoothArc</a></code>, <code><a href="#topic+addAngle">addAngle</a></code>
</p>

<hr>
<h2 id='anglePoint'>
Calculate coordinates at specific angle and distance.
</h2><span id='topic+anglePoint'></span>

<h3>Description</h3>

<p>Calculates the coordinates of the point that is at
a specific radian angle in a specific distance from a source point.
Internally called by <code>smoothArc</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>anglePoint(A, angl, len)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="anglePoint_+3A_a">A</code></td>
<td>

<p>Vector of length two with the coordinates of the source point.
</p>
</td></tr>
<tr><td><code id="anglePoint_+3A_angl">angl</code></td>
<td>

<p>Radian angle indicating into which direction the new point is to
be calculated.
</p>
</td></tr>
<tr><td><code id="anglePoint_+3A_len">len</code></td>
<td>

<p>The distance at which the new point is situated from the source point.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of length two with the coordinates of the new point.
</p>


<h3>Note</h3>

<p>Another pretty superfluous helper function...
</p>


<h3>Author(s)</h3>

<p>Lutz P Breitling &lt;l.breitling@posteo.de&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+smoothArc">smoothArc</a></code>
</p>

<hr>
<h2 id='assoc.exists'>
Check if association between two DAG nodes exists.
</h2><span id='topic+assoc.exists'></span>

<h3>Description</h3>

<p>Checks if an association between two DAG nodes already exists, i.e.
does not need to be introduced when adjusting for a shared child etc.
Internally called by <code><a href="#topic+dag.adjustment">dag.adjustment</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>assoc.exists(dag, a, b)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="assoc.exists_+3A_dag">dag</code></td>
<td>

<p>The DAG to be dealt with.
</p>
</td></tr>
<tr><td><code id="assoc.exists_+3A_a">a</code></td>
<td>

<p>First node.
</p>
</td></tr>
<tr><td><code id="assoc.exists_+3A_b">b</code></td>
<td>

<p>Second node.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A boolean indicating whether or not an association between first node 
and second node already exists.
</p>


<h3>Author(s)</h3>

<p>Lutz P Breitling &lt;l.breitling@posteo.de&gt;
</p>

<hr>
<h2 id='brute.search'>
Evaluate all possible adjustment sets of a DAG.
</h2><span id='topic+brute.search'></span>

<h3>Description</h3>

<p>Evaluates all adjustment sets of a DAG, optionally including
adjustment sets including &quot;unknown&quot; nodes. If the DAG has
a non-empty adjustment set, only adjustment sets including
these adjustment variables are evaluated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>brute.search(dag, allow.unknown = FALSE, trace = TRUE, stop = 0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="brute.search_+3A_dag">dag</code></td>
<td>

<p>The DAG to be evaluated.
</p>
</td></tr>
<tr><td><code id="brute.search_+3A_allow.unknown">allow.unknown</code></td>
<td>

<p>Boolean indicating &quot;unknown&quot; nodes should be featured in the adjustment
sets to be evaluated (TRUE) or not (FALSE=default).
</p>
</td></tr>
<tr><td><code id="brute.search_+3A_trace">trace</code></td>
<td>

<p>Boolean indicating if some output should be produced (TRUE=default).
</p>
</td></tr>
<tr><td><code id="brute.search_+3A_stop">stop</code></td>
<td>

<p>If =0, all eligible adjustment sets are evaluated. If =1, evaluations are
stopped after the first sufficient adjustment set has been evaluated.
Defaults to 0.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe with the first columns (<code>X1..Xn</code>) indicating the variables in the respective adjustment set evaluated.
The column <code>totalPaths</code> indicates the number of paths found when adjusting for the respective set,
and <code>openPaths</code> indicates the number of biasing paths.
</p>


<h3>Note</h3>

<p>The output produced by <code>brute.search</code> allows to manually identify
sufficient and minimal sufficient adjustment sets, which in the future should
preferably be done by a helper summary function.
The evaluation of a complicated DAG like <code>demo.dag2</code> can take quite
some time, and future functions should either employ more intelligent
algorithms to search specifically for sufficient sets, or they should
allow e.g. the evaluation of adjustment sets of specific sizes.
</p>


<h3>Author(s)</h3>

<p>Lutz P Breitling &lt;l.breitling@posteo.de&gt;
</p>

<hr>
<h2 id='dag.adjust'>
Adjust an existing DAG for covariables.
</h2><span id='topic+dag.adjust'></span>

<h3>Description</h3>

<p>Looks for associations introduced by adjusting for
the covariables specified, then looks for biasing paths, and
finally evaluates these paths.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dag.adjust(dag, A = c())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dag.adjust_+3A_dag">dag</code></td>
<td>

<p>The DAG to be adjusted (or evaluated).
</p>
</td></tr>
<tr><td><code id="dag.adjust_+3A_a">A</code></td>
<td>

<p>Vector indicating the adjustment set. <em>The numbering is according to the nodes vector of the DAG, which is shown e.g. in the legend of a DAG drawn by <code>dag.draw</code>. This numbering is different (+1) from the one used in <code>dag.init</code>, because the nodes vector also contains the exposure at position 1 (in contrast to the covariables vector used in <code>dag.init</code>)!</em>
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the adjustment set is empty, the function only looks for
biasing paths and evalutes these.
</p>


<h3>Value</h3>

<p>A DAG with the adjustment set A, and possibly with additional
associations introduced by adjustment, biasing paths found,
and the status of these.<br />
If adjustment set is not empty, <code>searchType</code> and <code>searchRes</code> are set to <code>NULL</code>.
</p>


<h3>Note</h3>

<p>CAVE: Do not apply this to an already adjusted DAG, since
this might not be handled appropriately (see documentation
of <code>dag.adjustment</code> called by <code>dag.adjust</code>).
</p>


<h3>Author(s)</h3>

<p>Lutz P Breitling &lt;l.breitling@posteo.de&gt;
</p>


<h3>References</h3>

<p>Breitling LP (2010). dagR: a suite of R functions for directed acyclic graphs. Epidemiology 21(4):586-587.<br />
Breitling LP, Duan C, Dragomir AD, Luta G (2022). Using dagR to identify minimal sufficient adjustment sets and
to simulate data based on directed acyclic graphs. Int J Epidemiol 50(6):1772-1777.<br />
Greenland S, Pearl J, Robins JM (1999). Causal diagrams for epidemiologic research. Epidemiology 10(1):37-48.<br />
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dag.adjustment">dag.adjustment</a></code>, <code><a href="#topic+find.paths">find.paths</a></code>,
<code><a href="#topic+eval.paths">eval.paths</a></code>
</p>

<hr>
<h2 id='dag.adjustment'>
Adjust a DAG for one or more variables.
</h2><span id='topic+dag.adjustment'></span>

<h3>Description</h3>

<p>Identifies the associations introduced by adjustment for the
variables specified, and returns the DAG with these associations
added. Note that this is called internally by <code>dag.adjust</code>, which
makes sure that biasing paths are looked for and evaluted afterwards.
Thus, <code>dag.adjustment</code> should 1.) <em>not</em> be called directly, and
2.) <em>not</em> be called on an already adjusted DAG!
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dag.adjustment(dag, A=NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dag.adjustment_+3A_dag">dag</code></td>
<td>

<p>The DAG to be adjusted.
</p>
</td></tr>
<tr><td><code id="dag.adjustment_+3A_a">A</code></td>
<td>

<p>The adjustment set to be applied.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The adjustment set A specified when calling <code>dag.adjustment</code> overrules the
adjustment variables that are present in the DAG. To keep these in
the adjustment set, one has to add them to A.
</p>


<h3>Value</h3>

<p>A DAG with A as the adjustment set and the associations introduced by
adjustment for A added to the DAG.
</p>


<h3>Note</h3>

<p>You should <em>not</em> use <code>dag.adjustment</code> on an already adjusted
DAG, since it cannot identify associations that had been introduced
by the earlier adjustment. If the new adjustment set does not include
the adjustment variables present in the first set, the new DAG might
feature associations that actually only would be introduced when
adjusting for the variables featured in the first but not second
adjustment set.
</p>


<h3>Author(s)</h3>

<p>Lutz P Breitling &lt;l.breitling@posteo.de&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dag.adjust">dag.adjust</a></code>, <code><a href="#topic+find.paths">find.paths</a></code>,
<code><a href="#topic+eval.paths">eval.paths</a></code>
</p>

<hr>
<h2 id='dag.ancestors'>
Identify ancestors of DAG nodes.
</h2><span id='topic+dag.ancestors'></span>

<h3>Description</h3>

<p>This identifies those nodes in a DAG that are ancestors of the nodes specified, i.e. acc. to the model depicted by the DAG they causally precede those nodes.
Internally called by <code>dag.adjustment</code> in the context of finding associations introduced by adjustment.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dag.ancestors(dag, A)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dag.ancestors_+3A_dag">dag</code></td>
<td>

<p>The DAG to be evaluated.
</p>
</td></tr>
<tr><td><code id="dag.ancestors_+3A_a">A</code></td>
<td>

<p>A vector of nodes for which ancestors are to be identified.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector indicating which nodes are ancestors of those in A.
Note that A actually is included at the beginning of the vector.
</p>


<h3>Author(s)</h3>

<p>Lutz P Breitling &lt;l.breitling@posteo.de&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dag.adjust">dag.adjust</a></code>, <code><a href="#topic+dag.adjustment">dag.adjustment</a></code>
</p>

<hr>
<h2 id='dag.draw'>
Draw a DAG.
</h2><span id='topic+dag.draw'></span>

<h3>Description</h3>

<p>Draws a DAG defined in an object of class dagRdag (as of dagR version 1.2.0, the generic function plot.dagRdag can be used for this purpose, but dag.draw is maintained for backwards compatibility).
The nodes are represented by 'C' (covariables; numbered with subscripts) and 'U' (unknown/unmeasured covariables; numbered with subscripts), 'X' and 'Y' (exposure and outcome, respectively).
A legend presents the names of the nodes.
The X-&gt;Y arc is marked with a questionmark as the relationship of interest.
Adjusted variables are under- and over-lined.
Undirected associations are drawn with dashed lines.
If paths have been identified (and evaluated), these (and their status) are written next to the legend.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dag.draw(dag, legend = TRUE, paths = TRUE, numbering = FALSE,
 p = FALSE, alt.symb = TRUE, noxy = 0, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dag.draw_+3A_dag">dag</code></td>
<td>

<p>The DAG to be drawn.
</p>
</td></tr>
<tr><td><code id="dag.draw_+3A_legend">legend</code></td>
<td>

<p>Boolean indicating whether a node legend should be included.
</p>
</td></tr>
<tr><td><code id="dag.draw_+3A_paths">paths</code></td>
<td>

<p>Boolean indicating whether paths (and their status) should be written.
</p>
</td></tr>
<tr><td><code id="dag.draw_+3A_numbering">numbering</code></td>
<td>

<p>Boolean indicating whether the arcs should be numbered in the DAG.
</p>
</td></tr>
<tr><td><code id="dag.draw_+3A_p">p</code></td>
<td>

<p>Boolean indicating whether the curving points of undirected associations should be drawn.
</p>
</td></tr>
<tr><td><code id="dag.draw_+3A_alt.symb">alt.symb</code></td>
<td>

<p>Boolean indicating if the alternative node symbols (dag$symbols) should be used. Note that especially the legends and paths will not be formatted nicely if these symbols are longer strings.
</p>
</td></tr>
<tr><td><code id="dag.draw_+3A_noxy">noxy</code></td>
<td>

<p>Integer to indicate if the X-&gt;Y should not be drawn (0=default; 1=no arc; 2=arc, but no question mark).
</p>
</td></tr>
<tr><td><code id="dag.draw_+3A_...">...</code></td>
<td>

<p><em>Currently not used.</em>
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the DAG (for whatever reason...).
</p>


<h3>Author(s)</h3>

<p>Lutz P Breitling &lt;l.breitling@posteo.de&gt;
</p>


<h3>References</h3>

<p>Breitling LP (2010). dagR: a suite of R functions for directed acyclic graphs. Epidemiology 21(4):586-587.<br />
Breitling LP, Duan C, Dragomir AD, Luta G (2022). Using dagR to identify minimal sufficient adjustment sets and
to simulate data based on directed acyclic graphs. Int J Epidemiol 50(6):1772-1777.<br />
Greenland S, Pearl J, Robins JM (1999). Causal diagrams for epidemiologic research. Epidemiology 10(1):37-48.<br />
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dag.letter">dag.letter</a></code>, <code><a href="#topic+garrows">garrows</a></code>,
<code><a href="#topic+smoothArc">smoothArc</a></code>, <code><a href="#topic+dag.legend">dag.legend</a></code>,
<code><a href="#topic+write.paths">write.paths</a></code>
</p>

<hr>
<h2 id='dag.init'>
Set up a new DAG.
</h2><span id='topic+dag.init'></span>

<h3>Description</h3>

<p>Allows setting up a new DAG.
See the <code>demo.dag0</code> to <code>demo.dag6</code> functions for some example specifications.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dag.init(outcome = NULL, exposure = NULL, covs = c(), arcs = c(),
 assocs = c(), xgap = 0.04, ygap = 0.05, len = 0.1, y.name = NULL,
 x.name = NULL, cov.names = c(), symbols = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dag.init_+3A_outcome">outcome</code></td>
<td>

<p><em>Currently not used!</em>
</p>
</td></tr>
<tr><td><code id="dag.init_+3A_exposure">exposure</code></td>
<td>

<p><em>Currently not used!</em>
</p>
</td></tr>
<tr><td><code id="dag.init_+3A_covs">covs</code></td>
<td>

<p>Vector including an integer for each covariable to be in the DAG (1 for a &quot;standard&quot; covariable, 2 for an unknown/unmeasured one).
</p>
</td></tr>
<tr><td><code id="dag.init_+3A_arcs">arcs</code></td>
<td>

<p>Vector of duplets of integers, in which nodes from which an arc or undirected association is to emenate are followed by those to which it is to point. To refer to the exposure, use 0, to refer to the outcome, use -1, to refer to covariables, use and element of 1:length(covs).
</p>
</td></tr>
<tr><td><code id="dag.init_+3A_assocs">assocs</code></td>
<td>

<p>A vector of same length as covs, with 0 indicating directed arcs, 1 indicating undirected associations.
</p>
</td></tr>
<tr><td><code id="dag.init_+3A_xgap">xgap</code></td>
<td>

<p>How much x space is to be left between arc ends and nodes when drawing?
</p>
</td></tr>
<tr><td><code id="dag.init_+3A_ygap">ygap</code></td>
<td>

<p>How much y space is to be left between arc ends and nodes when drawing?
</p>
</td></tr>
<tr><td><code id="dag.init_+3A_len">len</code></td>
<td>

<p>Length of arrow whiskers when drawing.
</p>
</td></tr>
<tr><td><code id="dag.init_+3A_y.name">y.name</code></td>
<td>

<p>Label of outcome.
</p>
</td></tr>
<tr><td><code id="dag.init_+3A_x.name">x.name</code></td>
<td>

<p>Label of exposure.
</p>
</td></tr>
<tr><td><code id="dag.init_+3A_cov.names">cov.names</code></td>
<td>

<p>Vector of covariable labels.
</p>
</td></tr>
<tr><td><code id="dag.init_+3A_symbols">symbols</code></td>
<td>

<p>Vector of alternative node symbols. Longer symbols will not be formatted nicely. Note that the first element refers to the exposure, the following ones to the covariables, the last one to the outcome.
</p>
</td></tr>
<tr><td><code id="dag.init_+3A_...">...</code></td>
<td>

<p><em>Currently not used.</em>
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A DAG (objects of class <code>dagRdag</code>). Check out some of the demonstration DAGs for details.
The DAG is actually a list object, with elements
<code>cov.types</code> (the <code>covs</code> vector, with 0 put in front, and -1 at the end).;
<code>x</code> and <code>y</code> (coordinates for drawing the nodes, initially set up more or less in a half-circle above the x-&gt;y arc);
<code>arc</code> (the arcs, transformed into a matrix);
<code>arc.type</code> (the <code>assocs</code> vector);
<code>curve.x</code> and <code>curve.y</code> (if associations are featured, these provide the coordinates through which to curve);
<code>xgap</code>, <code>ygap</code>, <code>len</code> (the respective drawing parameters);
<code>symbols</code> (alternative node symbols);
<code>version</code> (dagR version).
</p>


<h3>Note</h3>

<p>CAVE: The numbering of the covariables and arc coordinates is different here than in the functions later used on the DAG (e.g. <code>add.arc</code>, <code>dag.adjust</code>)! The functions generally work according to the indexing of the R objects that they handle. Whereas for <code>dag.init</code> the <code>n</code> covariable nodes are numbered <code>1:n</code>, the node vector of the resulting DAG will also contain the exposure node at the beginning and the outcome node at the end, i.e. it will go from <code>1:(n+2)</code> with the covariables at <code>2:n+1</code>. <code>summary_dagRdag</code> will show the latter numbering. <em>Example</em>: when adjusting for the first covariable, <code>dag.adjust</code> must be handed the adjustment set <code>A=2</code>, as the first covariable will occupy the second node (the first node is occupied by the exposure).
</p>


<h3>Author(s)</h3>

<p>Lutz P Breitling &lt;l.breitling@posteo.de&gt;
</p>


<h3>References</h3>

<p>Breitling LP (2010). dagR: a suite of R functions for directed acyclic graphs. Epidemiology 21(4):586-587.<br />
Greenland S, Pearl J, Robins JM (1999). Causal diagrams for epidemiologic research. Epidemiology 10(1):37-48.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dag.draw">dag.draw</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#dag.init(covs = c(1, 1), arcs = c(0, 2, 1, 2, 1, 0, -1, 2))
</code></pre>

<hr>
<h2 id='dag.legend'>
Write the legend in a DAG drawing.
</h2><span id='topic+dag.legend'></span>

<h3>Description</h3>

<p>Lists the DAG symbols along with their names/labels below a DAG drawn.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dag.legend(dag, lx = -0.15, ly = -0.075, alt.symb = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dag.legend_+3A_dag">dag</code></td>
<td>

<p>The DAG for which the legend is needed.
</p>
</td></tr>
<tr><td><code id="dag.legend_+3A_lx">lx</code></td>
<td>

<p>X coordinate for repositioning legend.
</p>
</td></tr>
<tr><td><code id="dag.legend_+3A_ly">ly</code></td>
<td>

<p>Y coordinate for repositioning legend.
</p>
</td></tr>
<tr><td><code id="dag.legend_+3A_alt.symb">alt.symb</code></td>
<td>

<p>Boolean indicating if the alternative node symbols (dag$symbols) should be used. Note that the formatting is not changed, i.e. longer symbols will not be formatted nicely.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Lutz P Breitling &lt;l.breitling@posteo.de&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dag.draw">dag.draw</a></code>, <code><a href="#topic+write.paths">write.paths</a></code>
</p>

<hr>
<h2 id='dag.letter'>
Write a DAG node symbol.
</h2><span id='topic+dag.letter'></span>

<h3>Description</h3>

<p>Writes the node symbols, 'X' and 'Y' for exposure and outcome, 'C' and 'U' (with consecutive subscripts) for known and unknown covariables. Since v1.1.2, alt.symb allows the use of custom node symbols.
Unknownness is identified by either node name 'unknown' or covariable type '2' in the DAG object.
Note that adjusted nodes are marked by bar and underline; this currently does not apply to those marked as unknown.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dag.letter(dag, letter, x, y, alt.symb = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dag.letter_+3A_dag">dag</code></td>
<td>

<p>The DAG for which a node is to be written.
</p>
</td></tr>
<tr><td><code id="dag.letter_+3A_letter">letter</code></td>
<td>

<p>The node that is of interest.
</p>
</td></tr>
<tr><td><code id="dag.letter_+3A_x">x</code></td>
<td>

<p>X position.
</p>
</td></tr>
<tr><td><code id="dag.letter_+3A_y">y</code></td>
<td>

<p>Y position.
</p>
</td></tr>
<tr><td><code id="dag.letter_+3A_alt.symb">alt.symb</code></td>
<td>

<p>Boolean indicating if custom symbols (dag$symbols) should be used if available.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Lutz P Breitling &lt;l.breitling@posteo.de&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dag.draw">dag.draw</a></code>, <code><a href="#topic+dag.legend">dag.legend</a></code>,
<code><a href="#topic+write.paths">write.paths</a></code>
</p>

<hr>
<h2 id='dag.letter2'>
Return a DAG node symbol.
</h2><span id='topic+dag.letter2'></span>

<h3>Description</h3>

<p>Similar to dag.letter(), but returning a string to label a DAG node.
Adjusted nodes are marked by a preceding underscore.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dag.letter2(dag, letter, alt.symb)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dag.letter2_+3A_dag">dag</code></td>
<td>

<p>The dagRdag object for which a node symbol is to be returned.
</p>
</td></tr>
<tr><td><code id="dag.letter2_+3A_letter">letter</code></td>
<td>

<p>The number of the node for which the symbol (often a single letter...) is to be returned.
</p>
</td></tr>
<tr><td><code id="dag.letter2_+3A_alt.symb">alt.symb</code></td>
<td>

<p>If TRUE, the alternative node symbols of the DAG object will be used.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A string containing the DAG letter or alternative symbol.
</p>


<h3>Author(s)</h3>

<p>Lutz P Breitling &lt;l.breitling@posteo.de&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dag.letter">dag.letter</a></code>
</p>

<hr>
<h2 id='dag.move'>
Interactively move a node or curving point in a DAG.
</h2><span id='topic+dag.move'></span>

<h3>Description</h3>

<p>This allows to reposition a node or association curving point of a DAG graphically.
First, select a node or curving point by left-clicking close to it.
Then reposition it to any other position by left-clicking.
Once you are happy with the new position, right-click to exit.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dag.move(dag)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dag.move_+3A_dag">dag</code></td>
<td>

<p>The DAG to be modified.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The same DAG, but with the feature repositioned.
</p>


<h3>Author(s)</h3>

<p>Lutz P Breitling &lt;l.breitling@posteo.de&gt;
</p>

<hr>
<h2 id='dag.search'>
Evaluate possible adjustment sets of a DAG.
</h2><span id='topic+dag.search'></span>

<h3>Description</h3>

<p>Currently, this simply is a wrapper for <code>brute.search</code>, which returns the input DAG with the results of <code>brute.search</code> and a string describing the search setup.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dag.search(dag, type = "brute", allow.unknown = FALSE, trace = FALSE, stop = 0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dag.search_+3A_dag">dag</code></td>
<td>

<p>DAG to be evaluated.
</p>
</td></tr>
<tr><td><code id="dag.search_+3A_type">type</code></td>
<td>

<p>Type of search to be performed. Currently, only =brute is possible.
</p>
</td></tr>
<tr><td><code id="dag.search_+3A_allow.unknown">allow.unknown</code></td>
<td>

<p>See <code><a href="#topic+brute.search">brute.search</a></code>.
</p>
</td></tr>
<tr><td><code id="dag.search_+3A_trace">trace</code></td>
<td>

<p>See <code><a href="#topic+brute.search">brute.search</a></code>.
</p>
</td></tr>
<tr><td><code id="dag.search_+3A_stop">stop</code></td>
<td>

<p>See <code><a href="#topic+brute.search">brute.search</a></code>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The DAG with components <code>searchType</code> and <code>searchRes</code> added.
</p>


<h3>Author(s)</h3>

<p>Lutz P Breitling &lt;l.breitling@posteo.de&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+brute.search">brute.search</a></code>
</p>

<hr>
<h2 id='dag.sim'>
Simulate data based on a DAG.
</h2><span id='topic+dag.sim'></span>

<h3>Description</h3>

<p>Simulates data according to a DAG object. This function may be replaced by dag.sim2 in the future.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dag.sim(dag, b = rep(0, nrow(dag$arc)), bxy = 0, n, 
            mu = rep(0, length(dag$x)),
        binary = rep(0, length(dag$x)),
         stdev = rep(0, length(dag$x)), naming = 2, seed = NA, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dag.sim_+3A_dag">dag</code></td>
<td>

<p>The DAG object according to which data is to be simulated.
</p>
</td></tr>
<tr><td><code id="dag.sim_+3A_b">b</code></td>
<td>

<p>Vector of coefficients defining the direct effects of the DAG arcs.
</p>
</td></tr>
<tr><td><code id="dag.sim_+3A_bxy">bxy</code></td>
<td>

<p>Coefficient defining the direct effect of main exposure X on outcome Y.
</p>
</td></tr>
<tr><td><code id="dag.sim_+3A_n">n</code></td>
<td>

<p>Number of observations to be simulated.
</p>
</td></tr>
<tr><td><code id="dag.sim_+3A_mu">mu</code></td>
<td>

<p>Vector of means that are to be simulated for the different DAG nodes.
For binary nodes without an ancestor, the mean is taken as the prevalence to be simulated.
For binary nodes with ancestors, the mean is similarly interpreted (see details in Value section).
</p>
</td></tr>
<tr><td><code id="dag.sim_+3A_binary">binary</code></td>
<td>

<p>Vector indicating which nodes are to be continuous (=0) and binary (=1).
</p>
</td></tr>
<tr><td><code id="dag.sim_+3A_stdev">stdev</code></td>
<td>

<p>Vector of standard deviations for each node.
For nodes without ancestors, continuous data are drawn from a Normal distribution with this standard deviation.
For nodes with ancestors, this is the standard deviation of the residual noise that is added to the calculated observation values.
</p>
</td></tr>
<tr><td><code id="dag.sim_+3A_naming">naming</code></td>
<td>

<p>If =2, the alternative DAG node symbols are used for naming the variables in the output dataframe.
Otherwise, the output dataframe variables are named X1...Xn.
</p>
</td></tr>
<tr><td><code id="dag.sim_+3A_seed">seed</code></td>
<td>

<p>Seed to initialize the random number generator.
</p>
</td></tr>
<tr><td><code id="dag.sim_+3A_verbose">verbose</code></td>
<td>

<p>If =TRUE, additional output is given during the simulation, in particular showing the different calculation steps.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe with n (rows) observations featuring simulated data for each node (columns) in the DAG.
Simulation steps:
1. simulate data for nodes i without ancestors, drawing from Normal distribution with mean mu[i] and stdev[i]
(continuous node), or drawing from Bernoulli events with probability mu[i] (binary node).
2. simulate data for nodes i for which all ancestors already have been simulated by multiplying the ancestor values
with the corresponding arc coefficients and summing them up, shifting the resulting values to the mean mu[i] specified for the
currently simulated node (logit-transformed if binary), then adding noise drawn from a Normal distribution with mean 0
and standard deviation stdev[i], finally using the inverse logit of the resulting values as success probabilities
for simulating binary data if node is binary.
</p>


<h3>Note</h3>

<p>Undirected arcs are ignored in these simulations!
</p>


<h3>Author(s)</h3>

<p>Lutz P Breitling &lt;l.breitling@posteo.de&gt;
</p>


<h3>References</h3>

<p>Breitling LP, Duan C, Dragomir AD, Luta G (2022). Using dagR to identify minimal sufficient adjustment sets and
to simulate data based on directed acyclic graphs. Int J Epidemiol 50(6):1772-1777.<br />
Duan C, Dragomir AD, Luta G, Breitling LP (2022). Reflection on modern methods: Understanding bias and data
analytical strategies through DAG-based data simulations. Int J Epidemiol 50(6):2091-2097.<br />
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dag.sim2">dag.sim2</a></code>
</p>

<hr>
<h2 id='dag.sim2'>
Simulate data based on a DAG.
</h2><span id='topic+dag.sim2'></span>

<h3>Description</h3>

<p>Simulates data according to a DAG object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dag.sim2(dag, b = rep(0, nrow(dag$arc)), bxy = 0, n, 
                      distr  = rep(0, length(dag$x)),
                      mu     = rep(0, length(dag$x)),
                      stdev  = rep(0, length(dag$x)),
                      nu     = NA,
                      lambda = NA,
                      binary = NA,
                      naming = 2, seed = NA, verbose = FALSE) 
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dag.sim2_+3A_dag">dag</code></td>
<td>

<p>The DAG object according to which data is to be simulated.
</p>
</td></tr>
<tr><td><code id="dag.sim2_+3A_b">b</code></td>
<td>

<p>Vector of coefficients defining the direct effects of the DAG arcs (on linear scale).
</p>
</td></tr>
<tr><td><code id="dag.sim2_+3A_bxy">bxy</code></td>
<td>

<p>Coefficient defining the direct effect of main exposure X on outcome Y (on linear scale).
</p>
</td></tr>
<tr><td><code id="dag.sim2_+3A_n">n</code></td>
<td>

<p>Number of observations to be simulated.
</p>
</td></tr>
<tr><td><code id="dag.sim2_+3A_distr">distr</code></td>
<td>

<p>0 for Normal distribution continuous nodes,<br />
1 for binary nodes simulated from logistic model,<br />
1.1 for binary nodes simulated from logistic model (see mu),<br />
2 for binary nodes simulated from linear risk difference model,<br />
2.1 for binary nodes simulated from linear risk difference model (see mu)
</p>
</td></tr>
<tr><td><code id="dag.sim2_+3A_mu">mu</code></td>
<td>

<p>Vector of means that are to be simulated for the different DAG nodes:<br />
For normally distributed continuous variables, the overall mean simulated.<br />
For binary variables w/ distr=1 or distr=2, overall proportion of successes simulated.<br />
For binary variables w/ distr=1.1 or distr=2.1, proportion of successes simulated in the reference category (sum of coef-weighted predictors =0).
</p>
</td></tr>
<tr><td><code id="dag.sim2_+3A_stdev">stdev</code></td>
<td>

<p>Vector of standard deviations for each node.<br />
For nodes without ancestors, continuous data are drawn from a Normal distribution with this standard deviation.
For continuous nodes with ancestors, this is the standard deviation of the residual noise that is added to the calculated observation value.<br />
If used on binary variables with ancestors, this would analogously add residual noise to the calculated predictor, diluting the direct effects.
</p>
</td></tr>
<tr><td><code id="dag.sim2_+3A_nu">nu</code></td>
<td>

<p>Not used.
</p>
</td></tr>
<tr><td><code id="dag.sim2_+3A_lambda">lambda</code></td>
<td>

<p>Not used.
</p>
</td></tr>
<tr><td><code id="dag.sim2_+3A_binary">binary</code></td>
<td>

<p>For backwards compatibility: Vector indicating which nodes are to be continuous (=0) and binary (=1). If given, this is passed to argument &quot;distr&quot; and a warning is issued.
</p>
</td></tr>
<tr><td><code id="dag.sim2_+3A_naming">naming</code></td>
<td>

<p>If =2, the alternative DAG node symbols are used for naming the variables in the output dataframe.
Otherwise, the output dataframe variables are named X1...Xn.
</p>
</td></tr>
<tr><td><code id="dag.sim2_+3A_seed">seed</code></td>
<td>

<p>Seed to initialize the random number generator.
</p>
</td></tr>
<tr><td><code id="dag.sim2_+3A_verbose">verbose</code></td>
<td>

<p>If =TRUE, additional output is given during the simulation, in particular showing the different calculation steps.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe with n (rows) observations featuring simulated data for each node (columns) in the DAG.<br /><br />
Simulation steps:<br />
1. simulate data for nodes i without ancestors, drawing from Normal distribution with mean mu[i] and stdev[i]
(continuous node), or drawing from Bernoulli events with probability mu[i] (binary node).<br />
2. simulate data for nodes i for which all ancestors already have been simulated by multiplying the ancestor values
with the corresponding arc coefficients and summing them up, shifting the resulting values to the mean mu[i] (exceptions: distr=1.1 or
distr=2.1, as detailed in &quot;mu&quot; above) specified for the
currently simulated node (logit-transformed if binary based on logistic model), then adding noise drawn from a Normal distribution with mean 0
and standard deviation stdev[i], finally using the resulting values (inverse logit, if binary based on logistic model) as success probabilities
for simulating binary data if node is binary.<br /><br />
As the noise is added after shifting to the mean, the mean of the simulated data will not be exact. Also, the noise is added before calculating descendant nodes, i.e. it is sort of true inter-individual variation, rather than measurement error.<br /><br />
For the risk difference model, the success probability calculated by summing the weighted ancestors can easily be &lt;0 (or &gt;1).
If this happens, the probability is set to 0 (or 1), and a warning is issued.
</p>


<h3>Note</h3>

<p>Undirected arcs are ignored in these simulations.
</p>


<h3>Author(s)</h3>

<p>Lutz P Breitling &lt;l.breitling@posteo.de&gt;
</p>


<h3>References</h3>

<p>Breitling LP, Duan C, Dragomir AD, Luta G (2022). Using dagR to identify minimal sufficient adjustment sets and
to simulate data based on directed acyclic graphs. Int J Epidemiol 50(6):1772-1777.<br />
Duan C, Dragomir AD, Luta G, Breitling LP (2022). Reflection on modern methods: Understanding bias and data
analytical strategies through DAG-based data simulations. Int J Epidemiol 50(6):2091-2097.<br />
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dag.sim">dag.sim</a></code>
</p>

<hr>
<h2 id='dagR2dagitty'>
Create dagitty code from a dagR DAG
</h2><span id='topic+dagR2dagitty'></span>

<h3>Description</h3>

<p>Translates a DAG as defined in a dagRdag object created by dagR into
the dagitty package format. Node labeling follows the rules used for
plotting dagRdag objects, but adjusted nodes are marked by a preceding
underscore instead of under- and over-line.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dagR2dagitty(x, alt.symb = TRUE, only.code = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dagR2dagitty_+3A_x">x</code></td>
<td>

<p>The dagR DAG to be translated.
</p>
</td></tr>
<tr><td><code id="dagR2dagitty_+3A_alt.symb">alt.symb</code></td>
<td>

<p>Boolean indicating if the alternative node symbols should be used.
</p>
</td></tr>
<tr><td><code id="dagR2dagitty_+3A_only.code">only.code</code></td>
<td>

<p>If TRUE, a string with R dagitty function call is returned, which should be
checked by the user (and possibly edited as required) before running
it to create an equivalent dagitty DAG. If FALSE and the dagitty
package has been installed and loaded, the dagitty function is called
directly and the resulting dagitty DAG is returned.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Either a string containing dagitty syntax to translate the dagR DAG
into dagitty format, or a dagitty object.
</p>


<h3>Author(s)</h3>

<p>Lutz P Breitling &lt;l.breitling@posteo.de&gt;
</p>


<h3>References</h3>

<p>Breitling LP (2010). dagR: a suite of R functions for directed acyclic graphs. Epidemiology 21(4):586-587.<br />
Breitling LP, Duan C, Dragomir AD, Luta G (2022). Using dagR to identify minimal sufficient adjustment sets and
to simulate data based on directed acyclic graphs. Int J Epidemiol 50(6):1772-1777.<br />
<a href="https://cran.r-project.org/package=dagitty">https://cran.r-project.org/package=dagitty</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dag.letter2">dag.letter2</a></code>
</p>

<hr>
<h2 id='demo.dag0'>
Set up demo DAG #0.
</h2><span id='topic+demo.dag0'></span>

<h3>Description</h3>

<p>Initializes a simple DAG used during the dagR development phase.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>demo.dag0()
</code></pre>


<h3>Value</h3>

<p>Returns a DAG.
</p>


<h3>Author(s)</h3>

<p>Lutz P Breitling &lt;l.breitling@posteo.de&gt;
</p>


<h3>See Also</h3>

<p><code>demo.dag1</code>, <code>demo.dag2</code>, <code>demo.dag3</code>,
<code>demo.dag4</code>, <code>demo.dag5</code>, <code>demo.dag6</code>
</p>

<hr>
<h2 id='demo.dag1'>
Set up demo DAG #1.
</h2><span id='topic+demo.dag1'></span>

<h3>Description</h3>

<p>Initializes a classical &quot;M DAG&quot; useful for demonstrating harmful adjustment.
The DAG is motivated by figure 3 in Fleischer (2008)
and also featured in Breitling (2010).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>demo.dag1()
</code></pre>


<h3>Value</h3>

<p>Returns a DAG.
</p>


<h3>Author(s)</h3>

<p>Lutz P Breitling &lt;l.breitling@posteo.de&gt;
</p>


<h3>References</h3>

<p>Breitling LP (2010). dagR: a suite of R functions for directed acyclic graphs. Epidemiology 21(4):586-587.<br />
Fleischer NL, Diez Roux AV (2008). Using directed acyclic graphs to guide analyses of neighbourhood health effects: an introduction. J Epidemiol Community Health 62:842-846.
</p>


<h3>See Also</h3>

<p><code>demo.dag0</code>, <code>demo.dag2</code>, <code>demo.dag3</code>,
<code>demo.dag4</code>, <code>demo.dag5</code>, <code>demo.dag6</code>
</p>

<hr>
<h2 id='demo.dag2'>
Set up demo DAG #2.
</h2><span id='topic+demo.dag2'></span>

<h3>Description</h3>

<p>Initializes a more complex DAG, motivated by Shrier (2008).
This DAG was used to examine the performance of <code>brute.search</code> and
has been featured in Breitling (2010).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>demo.dag2()
</code></pre>


<h3>Value</h3>

<p>Returns a DAG.
</p>


<h3>Author(s)</h3>

<p>Lutz P Breitling &lt;l.breitling@posteo.de&gt;
</p>


<h3>References</h3>

<p>Breitling LP (2010). dagR: a suite of R functions for directed acyclic graphs. Epidemiology 21(4):586-587.<br />
Shrier I, Platt RW (2008). Reducing bias through directed acyclic graphs. BMC Med Res Methodol 8:70
</p>


<h3>See Also</h3>

<p><code>demo.dag0</code>, <code>demo.dag1</code>, <code>demo.dag3</code>,
<code>demo.dag4</code>, <code>demo.dag5</code>, <code>demo.dag6</code>
</p>

<hr>
<h2 id='demo.dag3'>
Set up demo DAG #3.
</h2><span id='topic+demo.dag3'></span>

<h3>Description</h3>

<p>Initializes a DAG motivated by the manual for the software DAG v0.11
(Knüppel 2009). This DAG has been featured in Breitling (2010).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>demo.dag3()
</code></pre>


<h3>Value</h3>

<p>Returns a DAG.
</p>


<h3>Author(s)</h3>

<p>Lutz P Breitling &lt;l.breitling@posteo.de&gt;
</p>


<h3>References</h3>

<p>Breitling LP (2010). dagR: a suite of R functions for directed acyclic graphs. Epidemiology 21(4):586-587.<br />
Knüppel S (2009). DAG v0.11 documentation (Oct 21, 2009). <a href="https://hsz.dife.de/dag/">https://hsz.dife.de/dag/</a>
</p>


<h3>See Also</h3>

<p><code>demo.dag0</code>, <code>demo.dag1</code>, <code>demo.dag2</code>,
<code>demo.dag4</code>, <code>demo.dag5</code>, <code>demo.dag6</code>
</p>

<hr>
<h2 id='demo.dag4'>
Set up demo DAG #4.
</h2><span id='topic+demo.dag4'></span>

<h3>Description</h3>

<p>Initializes a miscellaneous DAG.
What happens if you adjust for the exposure's child?
</p>


<h3>Usage</h3>

<pre><code class='language-R'>demo.dag4()
</code></pre>


<h3>Value</h3>

<p>Returns a DAG.
</p>


<h3>Author(s)</h3>

<p>Lutz P Breitling &lt;l.breitling@posteo.de&gt;
</p>


<h3>See Also</h3>

<p><code>demo.dag0</code>, <code>demo.dag1</code>, <code>demo.dag2</code>,
<code>demo.dag3</code>, <code>demo.dag5</code>, <code>demo.dag6</code>
</p>

<hr>
<h2 id='demo.dag5'>
Set up demo DAG #5.
</h2><span id='topic+demo.dag5'></span>

<h3>Description</h3>

<p>Initializes a miscellaneous DAG.
What happens if you adjust for the outcome's child?
</p>


<h3>Usage</h3>

<pre><code class='language-R'>demo.dag5()
</code></pre>


<h3>Value</h3>

<p>Returns a DAG.
</p>


<h3>Author(s)</h3>

<p>Lutz P Breitling &lt;l.breitling@posteo.de&gt;
</p>


<h3>See Also</h3>

<p><code>demo.dag0</code>, <code>demo.dag1</code>, <code>demo.dag2</code>,
<code>demo.dag3</code>, <code>demo.dag4</code>, <code>demo.dag6</code>
</p>

<hr>
<h2 id='demo.dag6'>
Set up demo DAG #6.
</h2><span id='topic+demo.dag6'></span>

<h3>Description</h3>

<p>Initializes a miscellaneous DAG.
What happens if you adjust for the collider?
</p>


<h3>Usage</h3>

<pre><code class='language-R'>demo.dag6()
</code></pre>


<h3>Value</h3>

<p>Returns a DAG.
</p>


<h3>Author(s)</h3>

<p>Lutz P Breitling &lt;l.breitling@posteo.de&gt;
</p>


<h3>See Also</h3>

<p><code>demo.dag0</code>, <code>demo.dag1</code>, <code>demo.dag2</code>,
<code>demo.dag3</code>, <code>demo.dag4</code>, <code>demo.dag5</code>
</p>

<hr>
<h2 id='demo.dag7'>
Set up demo DAG #7.
</h2><span id='topic+demo.dag7'></span>

<h3>Description</h3>

<p>Initializes a DAG motivated by the manual for the software DAG v0.11
(Kn\&quot;uppel 2009). This DAG has been featured in Breitling (2010).
The DAG is the same as DAG #3, but #7 demonstrates the use of alternative node symbols.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>demo.dag7()
</code></pre>


<h3>Value</h3>

<p>Returns a DAG.
</p>


<h3>Author(s)</h3>

<p>Lutz P Breitling &lt;l.breitling@posteo.de&gt;
</p>


<h3>References</h3>

<p>Breitling LP (2010). dagR: a suite of R functions for directed acyclic graphs. Epidemiology 21(4):586-587.<br />
Kn\&quot;uppel S (2009). DAG v0.11 documentation (Oct 21, 2009). <a href="https://hsz.dife.de/dag/">https://hsz.dife.de/dag/</a>
</p>


<h3>See Also</h3>

<p><code>demo.dag3</code>
</p>

<hr>
<h2 id='distPoints'>
Calculate distance between two points.
</h2><span id='topic+distPoints'></span>

<h3>Description</h3>

<p>Another rather superfluous helper function, internally used by <code>smoothArc</code>. Calculates the distance between two points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distPoints(A, B)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="distPoints_+3A_a">A</code></td>
<td>

<p>Vector of length two, indicating x and y of first point.
</p>
</td></tr>
<tr><td><code id="distPoints_+3A_b">B</code></td>
<td>

<p>Vector of length two, indicating x and y of second point.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Distance between the two points.
</p>


<h3>Author(s)</h3>

<p>Lutz P Breitling &lt;l.breitling@posteo.de&gt;
</p>

<hr>
<h2 id='eval.paths'>
Evaluate potentially biasing paths in a DAG.
</h2><span id='topic+eval.paths'></span>

<h3>Description</h3>

<p>This essentially implements the graphical algorithm described in Greenland (1999) to identify open &quot;backdoor&quot; (or not strictly backdoor, but potentially biasing) paths in a DAG.
Paths are identified as being 'open', 'blocked by collider', or 'blocked by adjustment'. If both latter conditions apply, 'blocked by collider' is returned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eval.paths(dag)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="eval.paths_+3A_dag">dag</code></td>
<td>

<p>A DAG to which <code>find.paths</code> has already been applied<br />
(e.g. within <code>dag.adjust</code>).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function identifies a collider-blocked path as 'blocked by collider' even if it has been unblocked by adjusting for the collider.
One could argue that this should not be the case.
However, the biasing seems to be sufficiently represented in the DAG by the introduction of the association &quot;jumping&quot; the collider and potentially opening biasing paths.
</p>


<h3>Value</h3>

<p>A DAG with component <code>path.status</code> added.
</p>


<h3>Author(s)</h3>

<p>Lutz P Breitling &lt;l.breitling@posteo.de&gt;
</p>


<h3>References</h3>

<p>Breitling LP (2010). dagR: a suite of R functions for directed acyclic graphs. Epidemiology 21(4):586-587.<br />
Greenland S, Pearl J, Robins JM (1999). Causal diagrams for epidemiologic research. Epidemiology 10(1):37-48.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dag.adjust">dag.adjust</a></code>, <code><a href="#topic+find.paths">find.paths</a></code>
</p>

<hr>
<h2 id='find.paths'>
Find potentially biasing paths in a DAG.
</h2><span id='topic+find.paths'></span>

<h3>Description</h3>

<p>This identifies paths linking exposure and outcome in a DAG.
Forward paths (including a directed arc emanating from the exposure) are <em>not</em> identified.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find.paths(dag)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="find.paths_+3A_dag">dag</code></td>
<td>

<p>A DAG for which paths should be found.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A DAG with components <code>pathsN</code> (number of paths identified) and <code>paths</code> (matrix with each row describing one path by indicating the arcs forming the path; ends with <code>NA</code> as some other function recognize the end of the path that way) added. 
</p>


<h3>Author(s)</h3>

<p>Lutz P Breitling &lt;l.breitling@posteo.de&gt;
</p>


<h3>References</h3>

<p>Breitling LP (2010). dagR: a suite of R functions for directed acyclic graphs. Epidemiology 21(4):586-587.<br />
Greenland S, Pearl J, Robins JM (1999). Causal diagrams for epidemiologic research. Epidemiology 10(1):37-48.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dag.adjust">dag.adjust</a></code>, <code><a href="#topic+eval.paths">eval.paths</a></code>
</p>

<hr>
<h2 id='garrows'>
Draw a directed arc in a DAG.
</h2><span id='topic+garrows'></span>

<h3>Description</h3>

<p>Internally called by <code>dag.draw</code> for drawing directed arcs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>garrows(x0, y0, x1, y1, xgap, ygap, len = 0.1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="garrows_+3A_x0">x0</code></td>
<td>

<p>X coordinate of origin.
</p>
</td></tr>
<tr><td><code id="garrows_+3A_y0">y0</code></td>
<td>

<p>Y coordinate of origin.
</p>
</td></tr>
<tr><td><code id="garrows_+3A_x1">x1</code></td>
<td>

<p>X coordinate of target node.
</p>
</td></tr>
<tr><td><code id="garrows_+3A_y1">y1</code></td>
<td>

<p>Y coordinate of target node.
</p>
</td></tr>
<tr><td><code id="garrows_+3A_xgap">xgap</code></td>
<td>

<p>Space between node and arc ends on x axis.
</p>
</td></tr>
<tr><td><code id="garrows_+3A_ygap">ygap</code></td>
<td>

<p>Space between node and arc ends on y axis.
</p>
</td></tr>
<tr><td><code id="garrows_+3A_len">len</code></td>
<td>

<p>Length of arrow whiskers (default=0.1).
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Lutz P Breitling &lt;l.breitling@posteo.de&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dag.draw">dag.draw</a></code>, <code><a href="#topic+smoothArc">smoothArc</a></code>
</p>

<hr>
<h2 id='inAngle'>
Calculate angle between two arcs.
</h2><span id='topic+inAngle'></span>

<h3>Description</h3>

<p>Another rather superfluous helper function, calculating the radian angle between two radian angles. Internally called by <code>smoothArc</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inAngle(a, b)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="inAngle_+3A_a">a</code></td>
<td>

<p>Radian angle 1.
</p>
</td></tr>
<tr><td><code id="inAngle_+3A_b">b</code></td>
<td>

<p>Radian angle 2.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric in range from -pi to pi.
</p>


<h3>Author(s)</h3>

<p>Lutz P Breitling &lt;l.breitling@posteo.de&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+smoothArc">smoothArc</a></code>
</p>

<hr>
<h2 id='is.acyclic'>
Check if a DAG actually is acyclic.
</h2><span id='topic+is.acyclic'></span>

<h3>Description</h3>

<p>This function checks for each node in a DAG whether backtracing arcs leading to it results in an &quot;infinite recursion&quot; error indicating that there actually is a cyclic part in the DAG (which then obviously seems not to be a DAG).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.acyclic(dag, maxSecs=NA)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is.acyclic_+3A_dag">dag</code></td>
<td>

<p>The DAG to be check.
</p>
</td></tr>
<tr><td><code id="is.acyclic_+3A_maxsecs">maxSecs</code></td>
<td>

<p>maximum time before function aborts;
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with two elements.
<code>acyclic</code> is a boolean indicating whether the DAG is acyclic (=TRUE) or contains a cyclic component (=FALSE).
<code>nodewise</code> is a vector containing 1 boolean per node in the DAG, TRUE indicating that backtracing from this node does not lead to a cyclic component, FALSE indicating that backtracing from this node leads to a cyclic component.
</p>


<h3>Author(s)</h3>

<p>Lutz P Breitling &lt;l.breitling@posteo.de&gt;
</p>

<hr>
<h2 id='is.in'>
Check if a specific numeric value occurs in a vector.
</h2><span id='topic+is.in'></span>

<h3>Description</h3>

<p>Another trivial helper function, called internally by <code>eval.paths</code>.
It checks whether the specified (numeric) value is part of a specified vector of (numeric) values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.in(x, c = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is.in_+3A_x">x</code></td>
<td>

<p>A numeric value, for which the presence in a vector is to be checked.
</p>
</td></tr>
<tr><td><code id="is.in_+3A_c">c</code></td>
<td>

<p>A vector of numeric values.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Boolean; TRUE if value is present, FALSE if not.
</p>


<h3>Author(s)</h3>

<p>Lutz P Breitling &lt;l.breitling@posteo.de&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+eval.paths">eval.paths</a></code>
</p>

<hr>
<h2 id='is.unknown'>
Check if a DAG node presents an unknown variable.
</h2><span id='topic+is.unknown'></span>

<h3>Description</h3>

<p>Another helper function, internally used by <code>brute.search</code>. It checks whether the node specified is of type=2 or is named 'unknown'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.unknown(x, dag)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is.unknown_+3A_x">x</code></td>
<td>

<p>The node of interest.
</p>
</td></tr>
<tr><td><code id="is.unknown_+3A_dag">dag</code></td>
<td>

<p>The DAG to be evaluated.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>TRUE if unknown (acc. to type or name), FALSE otherwise.
</p>


<h3>Author(s)</h3>

<p>Lutz P Breitling &lt;l.breitling@posteo.de&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+brute.search">brute.search</a></code>
</p>

<hr>
<h2 id='msas'>
Identify minimal sufficient adjustment sets.
</h2><span id='topic+msas'></span>

<h3>Description</h3>

<p>Evaluates DAG adjustment sets identified by a <code>dag.search</code> (or <code>brute.search</code>) for minimal sufficiency by counting for each sufficient adjustment set A how many smaller sufficient ones that are contained in A exist.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>msas(adjSets)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="msas_+3A_adjsets">adjSets</code></td>
<td>

<p>The <code>searchRes</code> component of a DAG (or the output of <code>brute.search</code>, which is used by <code>dag.adjust</code> to produce <code>searchRes</code>).
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector containing a <code>-1</code> for each insufficient adjustment set, and for sufficient ones the number of smaller sufficient ones contained in it. 
</p>


<h3>Author(s)</h3>

<p>Lutz P Breitling &lt;l.breitling@posteo.de&gt;
</p>


<h3>References</h3>

<p>Breitling LP (2010). dagR: a suite of R functions for directed acyclic graphs. Epidemiology 21(4):586-587.<br />
Breitling LP, Duan C, Dragomir AD, Luta G (2022). Using dagR to identify minimal sufficient adjustment sets and
to simulate data based on directed acyclic graphs. Int J Epidemiol 50(6):1772-1777.<br />
Greenland S, Pearl J, Robins JM (1999). Causal diagrams for epidemiologic research. Epidemiology 10(1):37-48.<br />
Knüppel S, Stang A (2010). DAG Program: identifying minimal sufficient adjustment sets. Epidemiology 21(1):159.<br />
</p>


<h3>See Also</h3>

<p><code><a href="#topic+viv">viv</a></code>, <code><a href="#topic+summary.dagRdag">summary.dagRdag</a></code>
</p>

<hr>
<h2 id='plot.dagRdag'>
Function to draw a DAG
</h2><span id='topic+plot.dagRdag'></span>

<h3>Description</h3>

<p>Generic function to draw a directed acyclic graph in an object of class dagRdag.
This essentially passes the DAG object to the function <code>dag.draw</code>, which is
maintained for backwards compatibility.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dagRdag'
plot(x, y, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.dagRdag_+3A_x">x</code></td>
<td>

<p>Object of class dagRdag to be passed to <code>dag.draw</code>.
</p>
</td></tr>
<tr><td><code id="plot.dagRdag_+3A_y">y</code></td>
<td>

<p>Currently not used.
</p>
</td></tr>
<tr><td><code id="plot.dagRdag_+3A_...">...</code></td>
<td>

<p>Other arguments to be passed to <code>dag.draw</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For all available arguments, see documentation of <code>dag.draw</code>.
</p>


<h3>Value</h3>

<p>The DAG object is returned.
</p>


<h3>Author(s)</h3>

<p>Lutz P Breitling &lt;l.breitling@posteo.de&gt;
</p>


<h3>References</h3>

<p>Breitling LP (2010). dagR: a suite of R functions for directed acyclic graphs. Epidemiology 21(4):586-587.<br />
Breitling LP, Duan C, Dragomir AD, Luta G (2022). Using dagR to identify minimal sufficient adjustment sets and
to simulate data based on directed acyclic graphs. Int J Epidemiol 50(6):1772-1777.<br />
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dag.draw">dag.draw</a></code>
</p>

<hr>
<h2 id='print.dagRdag'>
Prints the raw contents of an object of class dagRdag.
</h2><span id='topic+print.dagRdag'></span>

<h3>Description</h3>

<p>Generic function <code>print</code> code for class <code>dagRdag</code>. This uses the default <code>print</code> method for list objects and points the user to the availability of the more convenient <code>summary</code> method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dagRdag'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.dagRdag_+3A_x">x</code></td>
<td>

<p>An object of class <code>dagRdag</code>.</p>
</td></tr>
<tr><td><code id="print.dagRdag_+3A_...">...</code></td>
<td>

<p>Other arguments passed to the print routine.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Lutz P Breitling &lt;l.breitling@posteo.de&gt;
</p>

<hr>
<h2 id='rm.arc'>
Remove an arc from a DAG.
</h2><span id='topic+rm.arc'></span>

<h3>Description</h3>

<p>Conveniently remove an arc from an existing DAG.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rm.arc(dag, arc)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rm.arc_+3A_dag">dag</code></td>
<td>

<p>The DAG from which to remove the arc.
</p>
</td></tr>
<tr><td><code id="rm.arc_+3A_arc">arc</code></td>
<td>

<p>A single integer, indicating which arc is to be removed (refering to the respective row of the <code>dag$arc</code> matrix).
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A DAG with the arc specified removed along with the corresponding attributes like arc types, curves, and path evaluation variables.
</p>


<h3>Note</h3>

<p>The numbering of the arcs can be visualized by applying <code>dag.draw</code> with the option &quot;numbering=TRUE&quot;.
</p>


<h3>Author(s)</h3>

<p>Lutz P Breitling &lt;l.breitling@posteo.de&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+add.arc">add.arc</a></code>, <code><a href="#topic+add.node">add.node</a></code>, <code><a href="#topic+rm.node">rm.node</a></code>
</p>

<hr>
<h2 id='rm.node'>
Remove a node from a DAG.
</h2><span id='topic+rm.node'></span>

<h3>Description</h3>

<p>Conveniently remove a node from an existing DAG.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rm.node(dag, node)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rm.node_+3A_dag">dag</code></td>
<td>

<p>The DAG from which to remove the node.
</p>
</td></tr>
<tr><td><code id="rm.node_+3A_node">node</code></td>
<td>

<p>A single integer, indicating which node is to be removed.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A DAG with the node specified removed, along with the corresponding attributes and dependent variables, i.e. arcs involving this node are also removed, and the numbering of the nodes (and their occurrence in arcs) is corrected accordingly.
<br /> Note: Search components (<code>searchType</code>, <code>searchRes</code>) of the DAG currently are generally set to NULL, even if no path is removed. This is for simplicity, because the node numbers would need to be changed eg. in the <code>searchRes</code> variables etc.
</p>


<h3>Author(s)</h3>

<p>Lutz P Breitling &lt;l.breitling@posteo.de&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+add.node">add.node</a></code>, <code><a href="#topic+rm.arc">rm.arc</a></code>, <code><a href="#topic+add.arc">add.arc</a></code>
</p>

<hr>
<h2 id='smoothArc'>
Draw an undirected assocation in a DAG.
</h2><span id='topic+smoothArc'></span>

<h3>Description</h3>

<p>This draws a dashed connection between two points, curving it so that it goes through a third point.
This is internally used by <code>dag.draw</code> to draw associations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>smoothArc(A, B, C, res = 20, gap = 0.05, p = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="smoothArc_+3A_a">A</code></td>
<td>

<p>Vector of length 2, providing xy coordinates of first point.
</p>
</td></tr>
<tr><td><code id="smoothArc_+3A_b">B</code></td>
<td>

<p>Vector of length 2, providing xy coordinates of second point.
</p>
</td></tr>
<tr><td><code id="smoothArc_+3A_c">C</code></td>
<td>

<p>Vector of length 2, indicating xy coordinates through which the association should be curved.
</p>
</td></tr>
<tr><td><code id="smoothArc_+3A_res">res</code></td>
<td>

<p>How smooth should the curve be drawn?
</p>
</td></tr>
<tr><td><code id="smoothArc_+3A_gap">gap</code></td>
<td>

<p>How far from point A and B should the line end?
</p>
</td></tr>
<tr><td><code id="smoothArc_+3A_p">p</code></td>
<td>

<p>If TRUE, the point through which the curve goes is drawn (this is to allow better moving it with <code>dag.move</code>).
</p>
</td></tr>
</table>


<h3>Note</h3>

<p>In the version 1.0.1 distributed as online supplemental material with Breitling (2010), the function contains arbitrary default values used during development.
</p>


<h3>Author(s)</h3>

<p>Lutz P Breitling &lt;l.breitling@posteo.de&gt;
</p>


<h3>References</h3>

<p>Breitling LP (2010). dagR: a suite of R functions for directed acyclic graphs. Epidemiology 21(4):586-587.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dag.draw">dag.draw</a></code>, <code><a href="#topic+dag.move">dag.move</a></code>
</p>

<hr>
<h2 id='summary_dagRdag'>
Summarize a DAG.
</h2><span id='topic+summary_dagRdag'></span>

<h3>Description</h3>

<p>Generic function <code>summary()</code> working code for class <code>dagRdag</code>, which is used by package <code>dagR</code> from version 1.1.1 on. From version 1.2.0, <code>summary.dagRdag()</code> is available as a generic function, but summary_dagRdag is preserved for backwards compatibility.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>summary_dagRdag(dag)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary_dagRdag_+3A_dag">dag</code></td>
<td>

<p>An object of class <code>dagRdag</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Summarizes according to what functions have been applied to the DAG. It does not itself call <code>dag.search</code> and the like. Exception: is calls <code>is.acyclic</code> (with <code>maxSecs=5</code>).
</p>


<h3>Author(s)</h3>

<p>Lutz P Breitling &lt;l.breitling@posteo.de&gt;
</p>


<h3>References</h3>

<p>Breitling LP (2010). dagR: a suite of R functions for directed acyclic graphs. Epidemiology 21(4):586-587.
<br /> Greenland S, Pearl J, Robins JM (1999). Causal diagrams for epidemiologic reserach. Epidemiology 10(1):37-48.
<br /> Kn\&quot;uppel S, Stang A (2010). DAG Program: identifying minimal sufficient adjustment sets. Epidemiology 21(1):159.
</p>

<hr>
<h2 id='summary.dagRdag'>
Summarize a DAG.
</h2><span id='topic+summary.dagRdag'></span>

<h3>Description</h3>

<p>Generic function <code>summary()</code> for class <code>dagRdag</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dagRdag'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.dagRdag_+3A_object">object</code></td>
<td>

<p>An object of class <code>dagRdag</code>.</p>
</td></tr>
<tr><td><code id="summary.dagRdag_+3A_...">...</code></td>
<td>

<p>Currently not used.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Summarizes according to what functions have been applied to the DAG. It does not itself call <code>dag.search</code> and the like. Exception: is calls <code>is.acyclic</code> (with <code>maxSecs=5</code>).<br />
This function passes the <code>object</code> to <code>summary_dagRdag</code>, which is preserved for backwards compatibility.
</p>


<h3>Author(s)</h3>

<p>Lutz P Breitling &lt;l.breitling@posteo.de&gt;
</p>


<h3>References</h3>

<p>Breitling LP (2010). dagR: a suite of R functions for directed acyclic graphs. Epidemiology 21(4):586-587.
<br /> Greenland S, Pearl J, Robins JM (1999). Causal diagrams for epidemiologic research. Epidemiology 10(1):37-48.
<br /> Kn\&quot;uppel S, Stang A (2010). DAG Program: identifying minimal sufficient adjustment sets. Epidemiology 21(1):159.
</p>

<hr>
<h2 id='viv'>
Is a numeric vector in another vector?
</h2><span id='topic+viv'></span>

<h3>Description</h3>

<p>Checks if all numeric elements of a vector occur also in another vector. It is internally used by <code>msas</code> to check if some adjustment set is contained in another one.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>viv(v1, v2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="viv_+3A_v1">v1</code></td>
<td>

<p>The vector whose occurrence in v2 is to be checked.
</p>
</td></tr>
<tr><td><code id="viv_+3A_v2">v2</code></td>
<td>

<p>The vector in which v1 might occur.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If a value occurs more than once in v1, it is counted as contained in v2 if it appears there once.
<br /> An empty v1 (consisting only of NA) is considered to be contained in any v2.
</p>


<h3>Value</h3>

<p>TRUE if v1 occurs in v2, FALSE otherwise.
</p>


<h3>Author(s)</h3>

<p>Lutz P Breitling &lt;l.breitling@posteo.de&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+msas">msas</a></code>
</p>

<hr>
<h2 id='write.paths'>
Write the paths into a DAG drawing.
</h2><span id='topic+write.paths'></span>

<h3>Description</h3>

<p>Writes the paths into a DAG drawing, using the symbols ('C', 'U', 'X', 'Y') used in the drawing, indicating directed arcs by '&lt;' and '&gt;', undirected ones by '-'. Since version 1.1.2, alt.symb allow usage of custom node symbols, though multi-character symbols will not be formatted well.
Adjusted variables are under- and over-lined.
If the paths have been evaluated using <code>eval.paths</code>, the status are also written.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write.paths(dag, px = 0.5, py = -0.06, alt.symb = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="write.paths_+3A_dag">dag</code></td>
<td>

<p>The DAG that has been drawn.
</p>
</td></tr>
<tr><td><code id="write.paths_+3A_px">px</code></td>
<td>

<p>An x coordinate to change the position of the path writing.
</p>
</td></tr>
<tr><td><code id="write.paths_+3A_py">py</code></td>
<td>

<p>A y coordinate to change the position of the path writing.
</p>
</td></tr>
<tr><td><code id="write.paths_+3A_alt.symb">alt.symb</code></td>
<td>

<p>Boolean indicating if alternative node symbols (dag$symbols) should be used.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Lutz P Breitling &lt;l.breitling@posteo.de&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dag.draw">dag.draw</a></code>, <code><a href="#topic+find.paths">find.paths</a></code>,
<code><a href="#topic+eval.paths">eval.paths</a></code>, <code><a href="#topic+dag.legend">dag.legend</a></code>
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
