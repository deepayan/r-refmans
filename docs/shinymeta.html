<!DOCTYPE html><html lang="en"><head><title>Help for package shinymeta</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {shinymeta}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#buildScriptBundle'><p>Produce a zip bundle of code and results</p></a></li>
<li><a href='#displayCodeModal'><p>Display a shinyAce code editor via shiny modal</p></a></li>
<li><a href='#dotdot'><p>The dot-dot operator</p></a></li>
<li><a href='#expandChain'><p>Expand code objects</p></a></li>
<li><a href='#formatCode'><p>Deparse and format shinymeta expressions</p></a></li>
<li><a href='#knit_print.shinyMetaExpr'><p>Knitr S3 methods</p></a></li>
<li><a href='#metaAction'><p>Run/capture non-reactive code for side effects</p></a></li>
<li><a href='#metaExpr'><p>Mark an expression as a meta-expression</p></a></li>
<li><a href='#metaObserve'><p>Create a meta-reactive observer</p></a></li>
<li><a href='#metaReactive'><p>Create a meta-reactive expression</p></a></li>
<li><a href='#metaRender'><p>Create a meta-reactive output</p></a></li>
<li><a href='#outputCodeButton'><p>Overlay an icon on a shiny output</p></a></li>
<li><a href='#withMetaMode'><p>Evaluate an expression with meta mode activated</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Export Domain Logic from Shiny using Meta-Programming</td>
</tr>
<tr>
<td>Version:</td>
<td>0.2.0.3</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides tools for capturing logic in a Shiny app and exposing it as code that can be run outside of Shiny (e.g., from an R console). It also provides tools for bundling both the code and results to the end user.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://rstudio.github.io/shinymeta/">https://rstudio.github.io/shinymeta/</a>,
<a href="https://github.com/rstudio/shinymeta">https://github.com/rstudio/shinymeta</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>callr, fastmap, fs, rlang, htmltools, shiny (&ge; 1.6.0),
sourcetools, styler, utils</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.2</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, stringr, rmarkdown, testthat (&ge; 3.0), shinyAce,
clipr, dplyr, ggplot2, cranlogs, xfun, magrittr, zoo</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Collate:</td>
<td>'archive.R' 'display.R' 'format.R' 'imports.R' 'utils.R'
'metareactive.R' 'observe.R' 'globals.R' 'output-code.R'
'print.R' 'render.R' 'report.R' 'utils-format.R' 'zzz.R'</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-11-17 15:50:11 UTC; cpsievert</td>
</tr>
<tr>
<td>Author:</td>
<td>Joe Cheng [aut],
  Carson Sievert <a href="https://orcid.org/0000-0002-4958-2844"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [cre, aut],
  RStudio [cph]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Carson Sievert &lt;carson@rstudio.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-11-17 16:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='buildScriptBundle'>Produce a zip bundle of code and results</h2><span id='topic+buildScriptBundle'></span><span id='topic+buildRmdBundle'></span>

<h3>Description</h3>

<p>Produce a zip bundle of code and results
</p>


<h3>Usage</h3>

<pre><code class='language-R'>buildScriptBundle(
  code = NULL,
  output_zip_path,
  script_name = "script.R",
  include_files = list(),
  render = TRUE,
  render_args = list()
)

buildRmdBundle(
  report_template,
  output_zip_path,
  vars = list(),
  include_files = list(),
  render = TRUE,
  render_args = list()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="buildScriptBundle_+3A_code">code</code></td>
<td>
<p>A language object.</p>
</td></tr>
<tr><td><code id="buildScriptBundle_+3A_output_zip_path">output_zip_path</code></td>
<td>
<p>A filename for the resulting zip bundle.</p>
</td></tr>
<tr><td><code id="buildScriptBundle_+3A_script_name">script_name</code></td>
<td>
<p>A name for the R script in the zip bundle.</p>
</td></tr>
<tr><td><code id="buildScriptBundle_+3A_include_files">include_files</code></td>
<td>
<p>A named list consisting of additional files that should
be included in the zip bundle. The element names indicate the destination
path within the bundle, specified as a relative path; the element values
indicate the path to the actual file currently on disk, specified as either
a relative or absolute path.</p>
</td></tr>
<tr><td><code id="buildScriptBundle_+3A_render">render</code></td>
<td>
<p>Whether or not to call <code><a href="rmarkdown.html#topic+render">rmarkdown::render()</a></code> on the R script.</p>
</td></tr>
<tr><td><code id="buildScriptBundle_+3A_render_args">render_args</code></td>
<td>
<p>Arguments to provide to <code><a href="rmarkdown.html#topic+render">rmarkdown::render()</a></code>.</p>
</td></tr>
<tr><td><code id="buildScriptBundle_+3A_report_template">report_template</code></td>
<td>
<p>Filename of an Rmd template to be expanded by <code><a href="knitr.html#topic+knit_expand">knitr::knit_expand()</a></code>.</p>
</td></tr>
<tr><td><code id="buildScriptBundle_+3A_vars">vars</code></td>
<td>
<p>A named list of variables passed along to <code>...</code> in <code><a href="knitr.html#topic+knit_expand">knitr::knit_expand()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The path to a generated file.
</p>


<h3>See Also</h3>

<p>knitr::knit_expand
</p>

<hr>
<h2 id='displayCodeModal'>Display a shinyAce code editor via shiny modal</h2><span id='topic+displayCodeModal'></span>

<h3>Description</h3>

<p>Show a <code>shinyAce::aceEditor()</code> in a <code>shiny::modalDialog()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>displayCodeModal(
  code,
  title = NULL,
  clip = "clipboard",
  footer = shiny::modalButton("Dismiss"),
  size = c("m", "s", "l"),
  easyClose = TRUE,
  fade = TRUE,
  session = shiny::getDefaultReactiveDomain(),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="displayCodeModal_+3A_code">code</code></td>
<td>
<p>Either a language object or a character string.</p>
</td></tr>
<tr><td><code id="displayCodeModal_+3A_title">title</code></td>
<td>
<p>An optional title for the dialog.</p>
</td></tr>
<tr><td><code id="displayCodeModal_+3A_clip">clip</code></td>
<td>
<p>An <code><a href="shiny.html#topic+icon">icon()</a></code> <code>name</code> that a user can press to copy <code>code</code> to the clipboard.
If you wish to not have an icon, specify <code>clip = NULL</code>.</p>
</td></tr>
<tr><td><code id="displayCodeModal_+3A_footer">footer</code></td>
<td>
<p>UI for footer. Use <code>NULL</code> for no footer.</p>
</td></tr>
<tr><td><code id="displayCodeModal_+3A_size">size</code></td>
<td>
<p>One of <code>"s"</code> for small, <code>"m"</code> (the default) for medium,
or <code>"l"</code> for large.</p>
</td></tr>
<tr><td><code id="displayCodeModal_+3A_easyclose">easyClose</code></td>
<td>
<p>If <code>TRUE</code>, the modal dialog can be dismissed by
clicking outside the dialog box, or be pressing the Escape key. If
<code>FALSE</code> (the default), the modal dialog can't be dismissed in those
ways; instead it must be dismissed by clicking on a <code>modalButton()</code>, or
from a call to <code><a href="shiny.html#topic+showModal">removeModal()</a></code> on the server.</p>
</td></tr>
<tr><td><code id="displayCodeModal_+3A_fade">fade</code></td>
<td>
<p>If <code>FALSE</code>, the modal dialog will have no fade-in animation
(it will simply appear rather than fade in to view).</p>
</td></tr>
<tr><td><code id="displayCodeModal_+3A_session">session</code></td>
<td>
<p>a shiny session object (the default should almost always be used).</p>
</td></tr>
<tr><td><code id="displayCodeModal_+3A_...">...</code></td>
<td>
<p>arguments passed along to <code>shinyAce::aceEditor()</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>nothing. Call this function for its side effects.
</p>


<h3>See Also</h3>

<p><a href="#topic+outputCodeButton">outputCodeButton</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (interactive()) {
  library(shiny)
  ui &lt;- fluidPage(
    sliderInput("n", label = "Number of samples", min = 10, max = 100, value = 30),
    actionButton("code", icon("code")),
    plotOutput("p")
  )
  server &lt;- function(input, output) {
    output$p &lt;- metaRender(renderPlot, {
      plot(sample(..(input$n)))
    })
    observeEvent(input$code, {
      code &lt;- expandChain(output$p())
      displayCodeModal(code)
    })
  }
  shinyApp(ui, server)
}

</code></pre>

<hr>
<h2 id='dotdot'>The dot-dot operator</h2><span id='topic+dotdot'></span><span id='topic+..'></span>

<h3>Description</h3>

<p>In shinymeta, <code>..()</code> is designed for <em>annotating</em> portions of code
inside a <code>metaExpr</code> (or its higher-level friends <code>metaReactive</code>,
<code>metaObserve</code>, and <code>metaRender</code>). At run time, these <code style="white-space: pre;">&#8288;meta-&#8288;</code> functions search for
<code>..()</code> calls and replace them with something else (see Details). Outside
of these <code style="white-space: pre;">&#8288;meta-&#8288;</code> functions, <code>..()</code> is not defined, so one must take extra care when
interrogating any code within a <code style="white-space: pre;">&#8288;meta-&#8288;</code> function that contains <code>..()</code> (see Debugging).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>..(expr)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dotdot_+3A_expr">expr</code></td>
<td>
<p>A single code expression. Required.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>As discussed in the <a href="https://rstudio.github.io/shinymeta/articles/code-generation.html">Code Generation</a>
vignette, <code>..()</code> is used to mark reactive reads and unquote expressions inside
<code>metaExpr</code> (or its higher-level friends <code>metaReactive</code>, <code>metaObserve</code>, and <code>metaRender</code>).
The actual behavior of <code>..()</code> depends on the current
<a href="https://rstudio.github.io/shinymeta/articles/code-generation.html#execution">mode of execution</a>:
</p>

<ul>
<li> <p><strong>Normal execution</strong>: the <code>..()</code> call is stripped from the expression before evaluation.
For example, <code>..(dataset())</code> becomes <code>dataset()</code>, and <code>..(format(Sys.Date()))</code> becomes
<code>format(Sys.Date())</code>.
</p>
</li>
<li> <p><strong>Meta execution</strong> (as in <code><a href="#topic+expandChain">expandChain()</a></code>): reactive reads are replaced with a suitable
name or value (i.e. <code>..(dataset())</code> becomes <code>dataset</code> or similar) and other code is
replaced with its result (<code>..(format(Sys.Date()))</code> becomes e.g. <code>"2019-08-06"</code>).
</p>
</li></ul>



<h3>Value</h3>

<p><code>expr</code>, but annotated.
</p>


<h3>Debugging</h3>

<p>If <code>..()</code> is called in a context where it isn't defined (that is, outside of a meta-expression),
you'll see an error like: &quot;..() is only defined inside shinymeta meta-expressions&quot;.
In practice, this problem can manifest itself in at least 3 different ways:
</p>

<ol>
<li><p> Execution is halted, perhaps by inserting <code>browser()</code>, and from inside the <code style="white-space: pre;">&#8288;Browse&gt;&#8288;</code> prompt,
<code>..()</code> is called directly. This is also not allowed, because the purpose of <code>..()</code> is to be
searched-and-replaced away <em>before</em> <code>metaExpr</code> begins executing the code. As a result,
if you want to interrogate code that contains <code>..()</code> at the <code style="white-space: pre;">&#8288;Browse&gt;&#8288;</code> prompt,
make sure it's wrapped in <code>metaExpr</code> before evaluating it. Also, note that when
stepping through a <code>metaExpr</code> at the <code style="white-space: pre;">&#8288;Browse&gt;&#8288;</code> prompt with <code>n</code>, the debugger
will echo the actual code that's evaluated during normal execution (i.e., <code>..()</code> is stripped),
so that's another option for interrogating what happens during normal execution.
On the other hand, if you are wanting to interrogate what happens during meta-execution,
you can wrap a <code>metaExpr</code> with <code>expandChain()</code>.
</p>
</li>
<li> <p><code>..()</code> is used in a non-<code>metaExpr</code> portions of <code>metaReactive2</code>, <code>metaObserve2</code>, and
<code>metaRender2</code>. As discussed in <a href="https://rstudio.github.io/shinymeta/articles/code-generation.html#execution">The execution model</a>,
non-<code>metaExpr</code> portions of <code>-2</code> variants always use normal execution and are completely
ignored at code generation time, so <code>..()</code> isn't needed in this context.
</p>
</li>
<li><p> Crafted a bit of code that uses <code>..()</code> in a way that was too clever for
shinymeta to understand. For example, <code>lapply(1:5, ..)</code> is syntactically valid R code,
but it's nonsense from a shinymeta perspective.
</p>
</li></ol>



<h3>See Also</h3>

<p><code><a href="#topic+metaExpr">metaExpr()</a></code>, <code><a href="#topic+metaReactive">metaReactive()</a></code>, <code><a href="#topic+metaObserve">metaObserve()</a></code>, <code><a href="#topic+metaRender">metaRender()</a></code>
</p>

<hr>
<h2 id='expandChain'>Expand code objects</h2><span id='topic+expandChain'></span><span id='topic+newExpansionContext'></span>

<h3>Description</h3>

<p>Use <code>expandChain</code> to write code out of one or more metaReactive objects.
Each meta-reactive object (expression, observer, or renderer) will cause not
only its own code to be written, but that of its dependencies as well.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>newExpansionContext()

expandChain(..., .expansionContext = newExpansionContext())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="expandChain_+3A_...">...</code></td>
<td>
<p>All arguments must be unnamed, and must be one of: 1) calls to
meta-reactive objects, 2) comment string (e.g. <code>"# A comment"</code>), 3)
language object (e.g. <code>quote(print(1 + 1))</code>), or 4) <code>NULL</code> (which will be
ignored). Calls to meta-reactive objects can optionally be <code><a href="base.html#topic+invisible">invisible()</a></code>,
see Details.</p>
</td></tr>
<tr><td><code id="expandChain_+3A_.expansioncontext">.expansionContext</code></td>
<td>
<p>Accept the default value if calling <code>expandChain</code> a
single time to generate a corpus of code; or create an expansion context
object using <code>newExpansionContext()</code> and pass it to multiple related calls
of <code>expandChain</code>. See Details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>There are two ways to extract code from meta objects (i.e. <code><a href="#topic+metaReactive">metaReactive()</a></code>,
<code><a href="#topic+metaObserve">metaObserve()</a></code>, and <code><a href="#topic+metaRender">metaRender()</a></code>): <code>withMetaMode()</code> and <code>expandChain()</code>.
The simplest is <code>withMetaMode(obj())</code>, which crawls the tree of meta-reactive
dependencies and expands each <code>..()</code> in place.
</p>
<p>For example, consider these meta objects:</p>
<pre>    nums &lt;- metaReactive({ runif(100) })
    obs &lt;- metaObserve({
      summary(..(nums()))
      hist(..(nums()))
    })
</pre>
<p>When code is extracted using <code>withMetaMode</code>:</p>
<pre>    withMetaMode(obs())
</pre>
<p>The result looks like this:</p>
<pre>    summary(runif(100))
    plot(runif(100))
</pre>
<p>Notice how <code>runif(100)</code> is inlined wherever <code>..(nums())</code>
appears, which is not desirable if we wish to reuse the same
values for <code>summary()</code> and <code>plot()</code>.
</p>
<p>The <code>expandChain</code> function helps us workaround this issue
by assigning return values of <code>metaReactive()</code> expressions to
a name, then replaces relevant expansion (e.g., <code>..(nums())</code>)
with the appropriate name (e.g. <code>nums</code>).</p>
<pre>    expandChain(obs())
</pre>
<p>The result looks like this:</p>
<pre>    nums &lt;- runif(100)
    summary(nums)
    plot(nums)
</pre>
<p>You can pass multiple meta objects and/or comments to <code>expandChain</code>.</p>
<pre>    expandChain(
      "# Generate values",
      nums(),
      "# Summarize and plot",
      obs()
    )
</pre>
<p>Output:</p>
<pre>    # Load data
    nums &lt;- runif(100)
    nums
    # Inspect data
    summary(nums)
    plot(nums)
</pre>
<p>You can suppress the printing of the <code>nums</code> vector in the previous example by
wrapping the <code>nums()</code> argument to <code>expandChain()</code> with <code>invisible(nums())</code>.
</p>


<h3>Value</h3>

<p>The return value of <code>expandChain()</code> is a code object that's suitable for
printing or passing to <code><a href="#topic+displayCodeModal">displayCodeModal()</a></code>, <code><a href="#topic+buildScriptBundle">buildScriptBundle()</a></code>, or
<code><a href="#topic+buildRmdBundle">buildRmdBundle()</a></code>.
</p>
<p>The return value of <code>newExpansionContext</code> is an object that should be
passed to multiple <code>expandChain()</code> calls.
</p>


<h3>Preserving dependencies between <code>expandChain()</code> calls</h3>

<p>Sometimes we may have related meta objects that we want to generate code for,
but we want the code for some objects in one code chunk, and the code for
other objects in another code chunk; for example, you might be constructing
an R Markdown report that has a specific place for each code chunk.
</p>
<p>Within a single <code>expandChain()</code> call, all <code>metaReactive</code> objects are
guaranteed to only be declared once, even if they're declared on by multiple
meta objects; but since we're making two <code>expandChain()</code> calls, we will end
up with duplicated code. To remove this duplication, we need the second
<code>expandChain</code> call to know what code was emitted in the first <code>expandChain</code>
call.
</p>
<p>We can achieve this by creating an &quot;expansion context&quot; and sharing it between
the two calls.</p>
<pre>    exp_ctx &lt;- newExpansionContext()
    chunk1 &lt;- expandChain(.expansionContext = exp_ctx,
      invisible(nums())
    )
    chunk2 &lt;- expandChain(.expansionContext = exp_ctx,
      obs()
    )
</pre>
<p>After this code is run, <code>chunk1</code> contains only the definition of <code>nums</code> and
<code>chunk2</code> contains only the code for <code>obs</code>.
</p>


<h3>Substituting <code>metaReactive</code> objects</h3>

<p>Sometimes, when generating code, we want to completely replace the
implementation of a <code>metaReactive</code>. For example, our Shiny app might contain
this logic, using <code><a href="shiny.html#topic+fileInput">shiny::fileInput()</a></code>:</p>
<pre>    data &lt;- metaReactive2({
      req(input$file_upload)
      metaExpr(read.csv(..(input$file_upload$datapath)))
    })
    obs &lt;- metaObserve({
      summary(..(data()))
    })
</pre>
<p>Shiny's file input works by saving uploading files to a temp directory. The
file referred to by <code>input$file_upload$datapath</code> won't be available when
another user tries to run the generated code.
</p>
<p>You can use the expansion context object to swap out the implementation of
<code>data</code>, or any other <code>metaReactive</code>:</p>
<pre>    ec &lt;- newExpansionContext()
    ec$substituteMetaReactive(data, function() {
      metaExpr(read.csv("data.csv"))
    })

    expandChain(.expansionContext = ec, obs())
</pre>
<p>Result:</p>
<pre>    data &lt;- read.csv("data.csv")
    summary(data)
</pre>
<p>Just make sure this code ends up in a script or Rmd bundle that includes the
uploaded file as <code>data.csv</code>, and the user will be able to reproduce your
analysis.
</p>
<p>The <code>substituteMetaReactive</code> method takes two arguments: the <code>metaReactive</code>
object to substitute, and a function that takes zero arguments and returns a
quoted expression (for the nicest looking results, use <code>metaExpr</code> to create
the expression). This function will be invoked the first time the
<code>metaReactive</code> object is encountered (or if the <code>metaReactive</code> is defined
with <code>inline = TRUE</code>, then every time it is encountered).
</p>


<h3>References</h3>

<p><a href="https://rstudio.github.io/shinymeta/articles/code-generation.html">https://rstudio.github.io/shinymeta/articles/code-generation.html</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>input &lt;- list(dataset = "cars")

# varname is only required if srcref aren't supported
# (R CMD check disables them for some reason?)
mr &lt;- metaReactive({
  get(..(input$dataset), "package:datasets")
})

top &lt;- metaReactive({
  head(..(mr()))
})

bottom &lt;- metaReactive({
  tail(..(mr()))
})

obs &lt;- metaObserve({
  message("Top:")
  summary(..(top()))
  message("Bottom:")
  summary(..(bottom()))
})

# Simple case
expandChain(obs())

# Explicitly print top
expandChain(top(), obs())

# Separate into two code chunks
exp_ctx &lt;- newExpansionContext()
expandChain(.expansionContext = exp_ctx,
  invisible(top()),
  invisible(bottom()))
expandChain(.expansionContext = exp_ctx,
  obs())

</code></pre>

<hr>
<h2 id='formatCode'>Deparse and format shinymeta expressions</h2><span id='topic+formatCode'></span><span id='topic+styleText'></span><span id='topic+deparseCode'></span>

<h3>Description</h3>

<p>Turn unevaluated shinymeta expressions into (formatted or styled) text.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>formatCode(code, width = 500L, formatter = styleText, ...)

styleText(code, ...)

deparseCode(code, width = 500L)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="formatCode_+3A_code">code</code></td>
<td>
<p>Either an unevaluated expression or a deparsed code string.</p>
</td></tr>
<tr><td><code id="formatCode_+3A_width">width</code></td>
<td>
<p>The <code>width.cutoff</code> to use when <code><a href="base.html#topic+deparse">deparse()</a></code>-ing the <code>code</code> expression.</p>
</td></tr>
<tr><td><code id="formatCode_+3A_formatter">formatter</code></td>
<td>
<p>a function that accepts deparsed code (a character string)
as the first argument.</p>
</td></tr>
<tr><td><code id="formatCode_+3A_...">...</code></td>
<td>
<p>arguments passed along to the <code>formatter</code> function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Before any formatting takes place, the unevaluated expression is
deparsed into a string via <code><a href="#topic+deparseCode">deparseCode()</a></code>, which ensures that
shinymeta comment strings (i.e., literal strings that appear on their own line,
and begin with one or more <code style="white-space: pre;">&#8288;#&#8288;</code> characters.) are turned into comments and
superfluous <code style="white-space: pre;">&#8288;\{&#8288;</code> are removed. After deparsing, the <code>formatCode()</code> function then
calls the <code>formatter</code> function on the deparsed string to format (aka style) the code string.
The default <code>formatter</code>, <code>styleText()</code>, uses <code><a href="styler.html#topic+style_text">styler::style_text()</a></code> with a couple differences:
</p>

<ul>
<li><p> Pipe operators (<code style="white-space: pre;">&#8288;%&gt;%&#8288;</code>) are <em>always</em> followed by a line break.
</p>
</li>
<li><p> If the token appearing after a line-break is a comma/operator, the line-break is removed.
</p>
</li></ul>



<h3>Value</h3>

<p>Single-element character vector with formatted code
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
options(shiny.suppressMissingContextError = TRUE)

x &lt;- metaReactive({
  "# Here's a comment"
  sample(5) %&gt;% sum()
})

code &lt;- expandChain(x())

deparseCode(code)
formatCode(code)
formatCode(code, formatter = styler::style_text)
</code></pre>

<hr>
<h2 id='knit_print.shinyMetaExpr'>Knitr S3 methods</h2><span id='topic+knit_print.shinyMetaExpr'></span>

<h3>Description</h3>

<p>This S3 method allows <code><a href="#topic+metaExpr">metaExpr()</a></code>s to print themselves in
knitr/rmarkdown documents.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>knit_print.shinyMetaExpr(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="knit_print.shinyMetaExpr_+3A_x">x</code></td>
<td>
<p>Object to knit_print</p>
</td></tr>
<tr><td><code id="knit_print.shinyMetaExpr_+3A_...">...</code></td>
<td>
<p>Additional knit_print arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The deparsed code expression (as a string).
</p>

<hr>
<h2 id='metaAction'>Run/capture non-reactive code for side effects</h2><span id='topic+metaAction'></span>

<h3>Description</h3>

<p>Most apps start out with setup code that is non-reactive, such as
<code><a href="base.html#topic+library">library()</a></code> calls, loading of static data into local
variables, or <code><a href="base.html#topic+source">source</a></code>-ing of supplemental R scripts.
<code>metaAction</code> provides a convenient way to run such code for its side effects
(including declaring new variables) while making it easy to export that code
using <code><a href="#topic+expandChain">expandChain()</a></code>. Note that <code>metaAction</code> executes code directly in the
<code>env</code> environment (which defaults to the caller's environment), so any local
variables that are declared in the <code>expr</code> will be available outside of
<code>metaAction</code> as well.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>metaAction(expr, env = parent.frame(), quoted = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="metaAction_+3A_expr">expr</code></td>
<td>
<p>A code expression that will immediately be executed (before the
call to <code>metaAction</code> returns), and also stored for later retrieval (i.e.
meta mode).</p>
</td></tr>
<tr><td><code id="metaAction_+3A_env">env</code></td>
<td>
<p>An environment.</p>
</td></tr>
<tr><td><code id="metaAction_+3A_quoted">quoted</code></td>
<td>
<p>Is the expression quoted? This is useful when you want to use an expression
that is stored in a variable; to do so, it must be quoted with <code><a href="base.html#topic+quote">quote()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A function that, when called in meta mode (i.e. inside
<code><a href="#topic+expandChain">expandChain()</a></code>), will return the code in quoted form. If this function is
ever called outside of meta mode, it throws an error, as it is definitely
being called incorrectly.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
setup &lt;- metaAction({
  library(stats)

  "# Set the seed to ensure repeatable randomness"
  set.seed(100)

  x &lt;- 1
  y &lt;- 2
})

# The action has executed
print(x)
print(y)

# And also you can emit the code
expandChain(
  setup()
)

</code></pre>

<hr>
<h2 id='metaExpr'>Mark an expression as a meta-expression</h2><span id='topic+metaExpr'></span>

<h3>Description</h3>

<p>Mark an expression as a meta-expression
</p>


<h3>Usage</h3>

<pre><code class='language-R'>metaExpr(
  expr,
  env = parent.frame(),
  quoted = FALSE,
  localize = "auto",
  bindToReturn = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="metaExpr_+3A_expr">expr</code></td>
<td>
<p>An expression (quoted or unquoted).</p>
</td></tr>
<tr><td><code id="metaExpr_+3A_env">env</code></td>
<td>
<p>An environment.</p>
</td></tr>
<tr><td><code id="metaExpr_+3A_quoted">quoted</code></td>
<td>
<p>Is the expression quoted? This is useful when you want to use an expression
that is stored in a variable; to do so, it must be quoted with <code><a href="base.html#topic+quote">quote()</a></code>.</p>
</td></tr>
<tr><td><code id="metaExpr_+3A_localize">localize</code></td>
<td>
<p>Whether or not to wrap the returned expression in <code><a href="base.html#topic+local">local()</a></code>.
The default, <code>"auto"</code>, only wraps expressions with a top-level <code><a href="base.html#topic+return">return()</a></code>
statement (i.e., return statements in anonymized functions are ignored).</p>
</td></tr>
<tr><td><code id="metaExpr_+3A_bindtoreturn">bindToReturn</code></td>
<td>
<p>For non-<code>localize</code>d expressions, should an assignment
of a meta expression be applied to the <em>last child</em> of the top-level <code style="white-space: pre;">&#8288;\{&#8288;</code> call?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If inside meta mode, a quoted form of <code>expr</code> for use inside of
<code><a href="#topic+metaReactive2">metaReactive2()</a></code>, <code><a href="#topic+metaObserve2">metaObserve2()</a></code>, or <code><a href="#topic+metaRender2">metaRender2()</a></code>. Otherwise, in
normal execution, the result of evaluating <code>expr</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+metaReactive2">metaReactive2()</a></code>, <code><a href="#topic+metaObserve2">metaObserve2()</a></code>, <code><a href="#topic+metaRender2">metaRender2()</a></code>, <code><a href="#topic+dotdot">..</a></code>
</p>

<hr>
<h2 id='metaObserve'>Create a meta-reactive observer</h2><span id='topic+metaObserve'></span><span id='topic+metaObserve2'></span>

<h3>Description</h3>

<p>Create a <code><a href="shiny.html#topic+observe">observe()</a></code>r that, when invoked with meta-mode activated
(i.e. called within <code><a href="#topic+withMetaMode">withMetaMode()</a></code> or <code><a href="#topic+expandChain">expandChain()</a></code>), returns a
partially evaluated code expression. Outside of meta-mode,
<code>metaObserve()</code> is equivalent to <code>observe()</code>
(it fully evaluates the given expression).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>metaObserve(
  expr,
  env = parent.frame(),
  quoted = FALSE,
  label = NULL,
  domain = getDefaultReactiveDomain(),
  localize = "auto",
  bindToReturn = FALSE
)

metaObserve2(
  expr,
  env = parent.frame(),
  quoted = FALSE,
  label = NULL,
  domain = getDefaultReactiveDomain()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="metaObserve_+3A_expr">expr</code></td>
<td>
<p>An expression (quoted or unquoted).</p>
</td></tr>
<tr><td><code id="metaObserve_+3A_env">env</code></td>
<td>
<p>The parent environment for the reactive expression. By default,
this is the calling environment, the same as when defining an ordinary
non-reactive expression. If <code>x</code> is a quosure and <code>quoted</code> is <code>TRUE</code>,
then <code>env</code> is ignored.</p>
</td></tr>
<tr><td><code id="metaObserve_+3A_quoted">quoted</code></td>
<td>
<p>If it is <code>TRUE</code>, then the <code><a href="base.html#topic+quote">quote()</a></code>ed value of <code>x</code>
will be used when <code>x</code> is evaluated. If <code>x</code> is a quosure and you
would like to use its expression as a value for <code>x</code>, then you must set
<code>quoted</code> to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="metaObserve_+3A_label">label</code></td>
<td>
<p>A label for the observer, useful for debugging.</p>
</td></tr>
<tr><td><code id="metaObserve_+3A_domain">domain</code></td>
<td>
<p>See <a href="shiny.html#topic+domains">domains</a>.</p>
</td></tr>
<tr><td><code id="metaObserve_+3A_localize">localize</code></td>
<td>
<p>Whether or not to wrap the returned expression in <code><a href="base.html#topic+local">local()</a></code>.
The default, <code>"auto"</code>, only wraps expressions with a top-level <code><a href="base.html#topic+return">return()</a></code>
statement (i.e., return statements in anonymized functions are ignored).</p>
</td></tr>
<tr><td><code id="metaObserve_+3A_bindtoreturn">bindToReturn</code></td>
<td>
<p>For non-<code>localize</code>d expressions, should an assignment
of a meta expression be applied to the <em>last child</em> of the top-level <code style="white-space: pre;">&#8288;\{&#8288;</code> call?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If you wish to capture specific code inside of <code>expr</code> (e.g. ignore code
that has no meaning outside shiny, like <code><a href="shiny.html#topic+req">req()</a></code>), use <code>metaObserve2()</code> in combination
with <code>metaExpr()</code>. When using <code>metaObserve2()</code>, <code>expr</code> must return a <code>metaExpr()</code>.
</p>


<h3>Value</h3>

<p>A function that, when called in meta mode (i.e. inside
<code><a href="#topic+expandChain">expandChain()</a></code>), will return the code in quoted form. If this function is
ever called outside of meta mode, it throws an error, as it is definitely
being called incorrectly.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+metaExpr">metaExpr()</a></code>, <code><a href="#topic+dotdot">..</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# observers execute 'immediately'
x &lt;- 1
mo &lt;- metaObserve({
  x &lt;&lt;- x + 1
})
getFromNamespace("flushReact", "shiny")()
print(x)

# It only makes sense to invoke an meta-observer
# if we're in meta-mode (i.e., generating code)
expandChain(mo())

# Intentionally produces an error
## Not run: mo()

</code></pre>

<hr>
<h2 id='metaReactive'>Create a meta-reactive expression</h2><span id='topic+metaReactive'></span><span id='topic+metaReactive2'></span>

<h3>Description</h3>

<p>Create a <code><a href="shiny.html#topic+reactive">reactive()</a></code> that, when invoked with meta-mode activated
(i.e. called within <code><a href="#topic+withMetaMode">withMetaMode()</a></code> or <code><a href="#topic+expandChain">expandChain()</a></code>), returns a
code expression (instead of evaluating that expression and returning the value).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>metaReactive(
  expr,
  env = parent.frame(),
  quoted = FALSE,
  varname = NULL,
  domain = shiny::getDefaultReactiveDomain(),
  inline = FALSE,
  localize = "auto",
  bindToReturn = FALSE
)

metaReactive2(
  expr,
  env = parent.frame(),
  quoted = FALSE,
  varname = NULL,
  domain = shiny::getDefaultReactiveDomain(),
  inline = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="metaReactive_+3A_expr">expr</code></td>
<td>
<p>An expression (quoted or unquoted).</p>
</td></tr>
<tr><td><code id="metaReactive_+3A_env">env</code></td>
<td>
<p>The parent environment for the reactive expression. By default,
this is the calling environment, the same as when defining an ordinary
non-reactive expression. If <code>x</code> is a quosure and <code>quoted</code> is <code>TRUE</code>,
then <code>env</code> is ignored.</p>
</td></tr>
<tr><td><code id="metaReactive_+3A_quoted">quoted</code></td>
<td>
<p>If it is <code>TRUE</code>, then the <code><a href="base.html#topic+quote">quote()</a></code>ed value of <code>x</code>
will be used when <code>x</code> is evaluated. If <code>x</code> is a quosure and you
would like to use its expression as a value for <code>x</code>, then you must set
<code>quoted</code> to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="metaReactive_+3A_varname">varname</code></td>
<td>
<p>An R variable name that this object prefers to be named when
its code is extracted into an R script. (See also: <code><a href="#topic+expandChain">expandChain()</a></code>)</p>
</td></tr>
<tr><td><code id="metaReactive_+3A_domain">domain</code></td>
<td>
<p>See <a href="shiny.html#topic+domains">domains</a>.</p>
</td></tr>
<tr><td><code id="metaReactive_+3A_inline">inline</code></td>
<td>
<p>If <code>TRUE</code>, during code expansion, do not declare a variable for
this object; instead, inline the code into every call site. Use this to avoid
introducing variables for very simple expressions. (See also: <code><a href="#topic+expandChain">expandChain()</a></code>)</p>
</td></tr>
<tr><td><code id="metaReactive_+3A_localize">localize</code></td>
<td>
<p>Whether or not to wrap the returned expression in <code><a href="base.html#topic+local">local()</a></code>.
The default, <code>"auto"</code>, only wraps expressions with a top-level <code><a href="base.html#topic+return">return()</a></code>
statement (i.e., return statements in anonymized functions are ignored).</p>
</td></tr>
<tr><td><code id="metaReactive_+3A_bindtoreturn">bindToReturn</code></td>
<td>
<p>For non-<code>localize</code>d expressions, should an assignment
of a meta expression be applied to the <em>last child</em> of the top-level <code style="white-space: pre;">&#8288;\{&#8288;</code> call?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If you wish to capture specific code inside of <code>expr</code> (e.g. ignore code
that has no meaning outside shiny, like <code><a href="shiny.html#topic+req">req()</a></code>), use <code>metaReactive2()</code> in combination
with <code>metaExpr()</code>. When using <code>metaReactive2()</code>, <code>expr</code> must return a <code>metaExpr()</code>.
</p>
<p>If <code>varname</code> is unspecified, <a href="base.html#topic+srcref">srcref</a>s are used in attempt to infer the name
bound to the meta-reactive object. In order for this inference to work, the
<code>keep.source</code> <a href="base.html#topic+option">option</a> must be <code>TRUE</code> and <code>expr</code> must begin with <code style="white-space: pre;">&#8288;\{&#8288;</code>.
</p>


<h3>Value</h3>

<p>A function that, when called in meta mode (i.e. inside
<code><a href="#topic+expandChain">expandChain()</a></code>), will return the code in quoted form. When called outside
meta mode, it acts the same as a regular <code><a href="shiny.html#topic+reactive">shiny::reactive()</a></code> expression
call.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+metaExpr">metaExpr()</a></code>, <code><a href="#topic+dotdot">..</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(shiny)
options(shiny.suppressMissingContextError = TRUE)

input &lt;- list(x = 1)

y &lt;- metaReactive({
  req(input$x)
  a &lt;- ..(input$x) + 1
  b &lt;- a + 1
  c + 1
})

withMetaMode(y())
expandChain(y())

y &lt;- metaReactive2({
  req(input$x)

  metaExpr({
    a &lt;- ..(input$x) + 1
    b &lt;- a + 1
    c + 1
  }, bindToReturn = TRUE)
})

expandChain(y())

</code></pre>

<hr>
<h2 id='metaRender'>Create a meta-reactive output</h2><span id='topic+metaRender'></span><span id='topic+metaRender2'></span>

<h3>Description</h3>

<p>Create a meta-reactive output that, when invoked with meta-mode activated
(i.e. called within <code><a href="#topic+expandChain">expandChain()</a></code> or <code><a href="#topic+withMetaMode">withMetaMode()</a></code>), returns a
code expression (instead of evaluating that expression and returning the value).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>metaRender(
  renderFunc,
  expr,
  ...,
  env = parent.frame(),
  quoted = FALSE,
  localize = "auto",
  bindToReturn = FALSE
)

metaRender2(renderFunc, expr, ..., env = parent.frame(), quoted = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="metaRender_+3A_renderfunc">renderFunc</code></td>
<td>
<p>A reactive output function (e.g., <a href="shiny.html#topic+renderPlot">shiny::renderPlot</a>, <a href="shiny.html#topic+renderPrint">shiny::renderText</a>, <a href="shiny.html#topic+renderUI">shiny::renderUI</a>, etc).</p>
</td></tr>
<tr><td><code id="metaRender_+3A_expr">expr</code></td>
<td>
<p>An expression that generates given output expected by <code>renderFunc</code>.</p>
</td></tr>
<tr><td><code id="metaRender_+3A_...">...</code></td>
<td>
<p>Other arguments passed along to <code>renderFunc</code>.</p>
</td></tr>
<tr><td><code id="metaRender_+3A_env">env</code></td>
<td>
<p>The parent environment for the reactive expression. By default,
this is the calling environment, the same as when defining an ordinary
non-reactive expression. If <code>x</code> is a quosure and <code>quoted</code> is <code>TRUE</code>,
then <code>env</code> is ignored.</p>
</td></tr>
<tr><td><code id="metaRender_+3A_quoted">quoted</code></td>
<td>
<p>If it is <code>TRUE</code>, then the <code><a href="base.html#topic+quote">quote()</a></code>ed value of <code>x</code>
will be used when <code>x</code> is evaluated. If <code>x</code> is a quosure and you
would like to use its expression as a value for <code>x</code>, then you must set
<code>quoted</code> to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="metaRender_+3A_localize">localize</code></td>
<td>
<p>Whether or not to wrap the returned expression in <code><a href="base.html#topic+local">local()</a></code>.
The default, <code>"auto"</code>, only wraps expressions with a top-level <code><a href="base.html#topic+return">return()</a></code>
statement (i.e., return statements in anonymized functions are ignored).</p>
</td></tr>
<tr><td><code id="metaRender_+3A_bindtoreturn">bindToReturn</code></td>
<td>
<p>For non-<code>localize</code>d expressions, should an assignment
of a meta expression be applied to the <em>last child</em> of the top-level <code style="white-space: pre;">&#8288;\{&#8288;</code> call?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If you wish to capture specific code inside of <code>expr</code> (e.g. ignore code
that has no meaning outside shiny, like <code><a href="shiny.html#topic+req">req()</a></code>), use <code>metaRender2()</code> in combination
with <code>metaExpr()</code>. When using <code>metaRender2()</code>, <code>expr</code> must return a <code>metaExpr()</code>.
</p>
<p>Since package authors are allowed to create their own output rendering functions,
creating a meta-counterpart of an output renderer (e.g. <code>renderPlot()</code>) needs to be
more general than prefixing <code>meta</code> to the function name (as with <code>metaReactive()</code> and <code>metaObserve()</code>).
<code>metaRender()</code> makes some assumptions about the arguments taken by the render function,
assumptions that we believe are true for all existing render functions.
If you encounter a render function that doesn't seem to work properly,
please let us know by <a href="https://github.com/rstudio/shinymeta/issues">filing an issue on GitHub</a>.
</p>


<h3>Value</h3>

<p>An annotated render function, ready to be assigned to an output slot.
The function may also be called in meta mode (i.e., inside <code><a href="#topic+expandChain">expandChain()</a></code>)
to return the code in quoted form.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+metaExpr">metaExpr()</a></code>, <code><a href="#topic+dotdot">..</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (interactive()) {
  library(shiny)
  library(shinymeta)

  ui &lt;- fluidPage(
    selectInput("var", label = "Choose a variable", choices = names(cars)),
    verbatimTextOutput("Summary"),
    verbatimTextOutput("code")
  )

  server &lt;- function(input, output) {
    var &lt;- metaReactive({
      cars[[..(input$var)]]
    })
    output$Summary &lt;- metaRender(renderPrint, {
      summary(..(var()))
    })
    output$code &lt;- renderPrint({
      expandChain(output$Summary())
    })
  }

  shinyApp(ui, server)
}

</code></pre>

<hr>
<h2 id='outputCodeButton'>Overlay an icon on a shiny output</h2><span id='topic+outputCodeButton'></span>

<h3>Description</h3>

<p>Intended for overlaying a button over a shiny output, that when clicked,
displays code for reproducing that output. The button is
similar to an <code><a href="shiny.html#topic+actionButton">shiny::actionButton()</a></code>, but instead of providing an <code>inputId</code>,
the id is determined by the id of the <code>outputObj</code>. The name
of that input is a function of <code>outputObj</code>'s <code>outputId</code>:
<code>input$OUTPUTID_output_code</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>outputCodeButton(
  outputObj,
  label = "Show code",
  icon = shiny::icon("code"),
  width = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="outputCodeButton_+3A_outputobj">outputObj</code></td>
<td>
<p>A shiny output container (e.g., <a href="shiny.html#topic+plotOutput">shiny::plotOutput</a>, <a href="shiny.html#topic+textOutput">shiny::textOutput</a>, etc)</p>
</td></tr>
<tr><td><code id="outputCodeButton_+3A_label">label</code></td>
<td>
<p>The contents of the button or link&ndash;usually a text label, but
you could also use any other HTML, like an image.</p>
</td></tr>
<tr><td><code id="outputCodeButton_+3A_icon">icon</code></td>
<td>
<p>An optional <code><a href="shiny.html#topic+icon">icon()</a></code> to appear on the button.</p>
</td></tr>
<tr><td><code id="outputCodeButton_+3A_width">width</code></td>
<td>
<p>The width of the input, e.g. <code>'400px'</code>, or <code>'100%'</code>;
see <code><a href="shiny.html#topic+reexports">validateCssUnit()</a></code>.</p>
</td></tr>
<tr><td><code id="outputCodeButton_+3A_...">...</code></td>
<td>
<p>Named attributes to be applied to the button or link.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the <code>outputObj</code> wrapped in a card-like HTML container.
</p>


<h3>See Also</h3>

<p><a href="#topic+displayCodeModal">displayCodeModal</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (interactive()) {
  library(shiny)
  ui &lt;- fluidPage(
    sliderInput("n", label = "Number of samples", min = 10, max = 100, value = 30),
    outputCodeButton(plotOutput("p"))
  )
  server &lt;- function(input, output) {
    output$p &lt;- metaRender(renderPlot, {
      plot(sample(..(input$n)))
    })
    observeEvent(input$p_output_code, {
      code &lt;- expandChain(output$p())
      displayCodeModal(code)
    })
  }
  shinyApp(ui, server)
}

</code></pre>

<hr>
<h2 id='withMetaMode'>Evaluate an expression with meta mode activated</h2><span id='topic+withMetaMode'></span>

<h3>Description</h3>

<p>Evaluate an expression with meta mode activated
</p>


<h3>Usage</h3>

<pre><code class='language-R'>withMetaMode(expr, mode = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="withMetaMode_+3A_expr">expr</code></td>
<td>
<p>an expression.</p>
</td></tr>
<tr><td><code id="withMetaMode_+3A_mode">mode</code></td>
<td>
<p>whether or not to evaluate expression in meta mode.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The result of evaluating <code>expr</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+expandChain">expandChain()</a></code>
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
