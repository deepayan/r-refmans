<!DOCTYPE html><html><head><title>Help for package HistDAWass</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {HistDAWass}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#['><p>extract from a MatH Method [</p></a></li>
<li><a href='#*-methods'><p>Method *</p></a></li>
<li><a href='#+'><p>Method +</p></a></li>
<li><a href='#Age_Pyramids_2014'><p>Age pyramids of all the countries of the World in 2014</p></a></li>
<li><a href='#Agronomique'><p>Agronomique data</p></a></li>
<li><a href='#BLOOD'><p>Blood dataset for Histogram data analysis</p></a></li>
<li><a href='#BloodBRITO'><p>Blood dataset from Brito P. for Histogram data analysis</p></a></li>
<li><a href='#Center.cell.MatH'><p>Method Center.cell.MatH Centers all the cells of a matrix of distributions</p></a></li>
<li><a href='#checkEmptyBins'><p>Method <code>checkEmptyBins</code></p></a></li>
<li><a href='#China_Month'><p>A monthly climatic dataset of China</p></a></li>
<li><a href='#China_Seas'><p>A seasonal climatic dataset of China</p></a></li>
<li><a href='#compP'><p>Method <code>compP</code></p></a></li>
<li><a href='#compQ'><p>Method <code>compQ</code></p></a></li>
<li><a href='#crwtransform'><p>Method <code>crwtransform</code>: returns the centers and the radii of bins of a distribution</p></a></li>
<li><a href='#data2hist'><p>From real data to distributionH.</p></a></li>
<li><a href='#distributionH-class'><p>Class distributionH.</p></a></li>
<li><a href='#dotpW'><p>Method <code>dotpW</code></p></a></li>
<li><a href='#DouglasPeucker'><p>Ramer-Douglas-Peucker algorithm for curve fitting with a PolyLine</p></a></li>
<li><a href='#get.cell.MatH'><p>Method get.cell.MatH Returns the histogram in a cell of a matrix of distributions</p></a></li>
<li><a href='#get.distr'><p>Method <code>get.distr</code>: show the distribution</p></a></li>
<li><a href='#get.histo'><p>Method <code>get.histo</code>: show the distribution with bins</p></a></li>
<li><a href='#get.m'><p>Method <code>get.m</code>: the mean of a distribution</p></a></li>
<li><a href='#get.MatH.main.info'><p>Method get.MatH.main.info</p></a></li>
<li><a href='#get.MatH.ncols'><p>Method get.MatH.ncols</p></a></li>
<li><a href='#get.MatH.nrows'><p>Method get.MatH.nrows</p></a></li>
<li><a href='#get.MatH.rownames'><p>Method get.MatH.rownames</p></a></li>
<li><a href='#get.MatH.stats'><p>Method get.MatH.stats</p></a></li>
<li><a href='#get.MatH.varnames'><p>Method get.MatH.varnames</p></a></li>
<li><a href='#get.s'><p>Method <code>get.s</code>: the standard deviation of a distribution</p></a></li>
<li><a href='#HistDAWass-package'><p>Histogram-Valued Data Analysis</p></a></li>
<li><a href='#HTS-class'><p>Class HTS</p></a></li>
<li><a href='#HTS.exponential.smoothing'><p>Smoothing with exponential smoothing of a histogram time series</p></a></li>
<li><a href='#HTS.moving.averages'><p>Smoothing with moving averages of a histogram time series</p></a></li>
<li><a href='#HTS.predict.knn'><p>K-NN predictions of a histogram time series</p></a></li>
<li><a href='#is.registeredMH'><p>Method is.registeredMH</p></a></li>
<li><a href='#kurtH'><p>Method <code>kurtH</code>: computes the kurthosis of a distribution</p></a></li>
<li><a href='#MatH-class'><p>Class MatH.</p></a></li>
<li><a href='#meanH'><p>Method <code>meanH</code>: computes the mean of a distribution</p></a></li>
<li><a href='#minus'><p>Method -</p></a></li>
<li><a href='#OzoneFull'><p>Full Ozone dataset for Histogram data analysis</p></a></li>
<li><a href='#OzoneH'><p>Complete Ozone dataset for Histogram data analysis</p></a></li>
<li><a href='#plot_errors'><p>A function for plotting functions of errors</p></a></li>
<li><a href='#plot-distributionH'><p>plot for a distributionH object</p></a></li>
<li><a href='#plot-HTS'><p>Method plot for a histogram time series</p></a></li>
<li><a href='#plot-MatH'><p>Method plot for a matrix  of histograms</p></a></li>
<li><a href='#plot-TdistributionH'><p>plot for a TdistributionH object</p></a></li>
<li><a href='#plotPredVsObs'><p>A function for comparing observed vs predicted histograms</p></a></li>
<li><a href='#register'><p>Method <code>register</code></p></a></li>
<li><a href='#registerMH'><p>Method registerMH</p></a></li>
<li><a href='#RetHTS'><p>A histogram-valued dataset of returns</p></a></li>
<li><a href='#rQQ'><p>Method <code>rQQ</code></p></a></li>
<li><a href='#set.cell.MatH'><p>Method set.cell.MatH assign a histogram to a cell of a matrix of histograms</p></a></li>
<li><a href='#ShortestDistance'><p>Shortes distance from a point o a 2d segment</p></a></li>
<li><a href='#show'><p>Method show for distributionH</p></a></li>
<li><a href='#show-MatH'><p>Method show for MatH</p></a></li>
<li><a href='#skewH'><p>Method <code>skewH</code>: computes the skewness of a distribution</p></a></li>
<li><a href='#stations_coordinates'><p>Stations coordinates of China_Month and China_Seas datasets</p></a></li>
<li><a href='#stdH'><p>Method <code>stdH</code>: computes the standard deviation of a distribution</p></a></li>
<li><a href='#subsetHTS'><p>Method <code>subsetHTS</code>: extract a subset of a histogram time series</p></a></li>
<li><a href='#summaryHTS'><p>A function for summarize HTS</p></a></li>
<li><a href='#TdistributionH-class'><p>Class TdistributionH</p></a></li>
<li><a href='#TMatH-class'><p>Class TMatH</p></a></li>
<li><a href='#WassSqDistH'><p>Method <code>WassSqDistH</code></p></a></li>
<li><a href='#WH_2d_Adaptive_Kohonen_maps'><p>Batch Kohonen self-organizing 2d maps using adaptive distances for  histogram-valued data</p></a></li>
<li><a href='#WH_2d_Kohonen_maps'><p>Batch Kohonen self-organizing 2d maps for  histogram-valued data</p></a></li>
<li><a href='#WH_adaptive_fcmeans'><p>Fuzzy c-means with adaptive distances for histogram-valued data</p></a></li>
<li><a href='#WH_adaptive.kmeans'><p>K-means of a dataset of histogram-valued data using adaptive  Wasserstein distances</p></a></li>
<li><a href='#WH_fcmeans'><p>Fuzzy c-means of a dataset of histogram-valued data</p></a></li>
<li><a href='#WH_hclust'><p>Hierarchical clustering of histogram data</p></a></li>
<li><a href='#WH_kmeans'><p>K-means of a dataset of histogram-valued data</p></a></li>
<li><a href='#WH_MAT_DIST'><p>L2  Wasserstein distance matrix</p></a></li>
<li><a href='#WH.1d.PCA'><p>Principal components analysis  of histogram variable based on Wasserstein distance</p></a></li>
<li><a href='#WH.bind'><p>Method WH.bind</p></a></li>
<li><a href='#WH.bind.col'><p>Method WH.bind.col</p></a></li>
<li><a href='#WH.bind.row'><p>Method WH.bind.row</p></a></li>
<li><a href='#WH.correlation'><p>Method WH.correlation</p></a></li>
<li><a href='#WH.correlation2'><p>Method WH.correlation2</p></a></li>
<li><a href='#WH.mat.prod'><p>Method WH.mat.prod</p></a></li>
<li><a href='#WH.mat.sum'><p>Method WH.mat.sum</p></a></li>
<li><a href='#WH.MultiplePCA'><p>Principal components analysis  of a set of histogram variable based on Wasserstein distance</p></a></li>
<li><a href='#WH.plot_multiple_indivs'><p>Plot histograms of individuals after a  Multiple factor analysis of Histogram Variables</p></a></li>
<li><a href='#WH.plot_multiple_Spanish.funs'><p>Plotting Spanish fun plots for Multiple factor analysis of Histogram Variables</p></a></li>
<li><a href='#WH.regression.GOF'><p>Goodness of Fit indices for Multiple regression of histogram variables based on a two component model and L2 Wasserstein distance</p></a></li>
<li><a href='#WH.regression.two.components'><p>Multiple regression analysis for  histogram variables based on a two component model and L2 Wasserstein distance</p></a></li>
<li><a href='#WH.regression.two.components.predict'><p>Multiple regression analysis for  histogram variables based on a two component model and L2 Wasserstein distance</p></a></li>
<li><a href='#WH.SSQ'><p>Method WH.SSQ</p></a></li>
<li><a href='#WH.SSQ2'><p>Method WH.SSQ2</p></a></li>
<li><a href='#WH.var.covar'><p>Method WH.var.covar</p></a></li>
<li><a href='#WH.var.covar2'><p>Method WH.var.covar2</p></a></li>
<li><a href='#WH.vec.mean'><p>Method WH.vec.mean</p></a></li>
<li><a href='#WH.vec.sum'><p>Method WH.vec.sum</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Histogram-Valued Data Analysis</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.8</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-01-24</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Antonio Irpino &lt;antonio.irpino@unicampania.it&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>In the framework of Symbolic Data Analysis, a relatively new
    approach to the statistical analysis of multi-valued data, we consider
    histogram-valued data, i.e., data described by univariate histograms. The
    methods and the basic statistics for histogram-valued data are mainly based
    on the L2 Wasserstein metric between distributions, i.e., the Euclidean metric
    between quantile functions. The package contains unsupervised classification
    techniques, least square regression and tools for histogram-valued data and for
    histogram time series. An introducing paper is Irpino A. Verde R. (2015) &lt;<a href="https://doi.org/10.1007%2Fs11634-014-0176-4">doi:10.1007/s11634-014-0176-4</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Imports:</td>
<td>graphics, class, FactoMineR, ggplot2, ggridges, grid,
histogram, grDevices, stats, utils, Rcpp</td>
</tr>
<tr>
<td>Depends:</td>
<td>R(&ge; 3.1), methods</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Collate:</td>
<td>'For_Rccp_int.R' 'All_classes.R' 'RcppExports.R' 'Utility.R'
'Met_HTS.R' 'Met_MatH.R' 'Met_distributionH.R' 'Fuzzy_cmeans.R'
'H_time_series.R' 'HistDAWass-package.R' 'Kohonen_maps.R'
'principal_components.R' 'regression.R'
'unsuperv_classification.R' 'Plotting_with_ggplot.R'</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp,RcppArmadillo</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-01-24 17:14:46 UTC; antonio</td>
</tr>
<tr>
<td>Author:</td>
<td>Antonio Irpino <a href="https://orcid.org/0000-0001-9293-7180"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-01-24 17:42:31 UTC</td>
</tr>
</table>
<hr>
<h2 id='+5B'>extract from a MatH Method [</h2><span id='topic++5B'></span><span id='topic++5B+2CMatH+2CANY+2CANY+2CANY-method'></span><span id='topic++5B+2CMatH-method'></span>

<h3>Description</h3>

<p>This method overrides the &quot;[&quot; operator for a  <code>matH</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'MatH'
x[i, j, ..., drop = TRUE]
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B5B_+3A_x">x</code></td>
<td>
<p>a <code>matH</code> object</p>
</td></tr>
<tr><td><code id="+2B5B_+3A_i">i</code></td>
<td>
<p>a set of integer values identifying the rows</p>
</td></tr>
<tr><td><code id="+2B5B_+3A_j">j</code></td>
<td>
<p>a set of integer values identifying the columns</p>
</td></tr>
<tr><td><code id="+2B5B_+3A_...">...</code></td>
<td>
<p>not useful</p>
</td></tr>
<tr><td><code id="+2B5B_+3A_drop">drop</code></td>
<td>
<p>a logical value inherited from the basic method &quot;[&quot; but not used (default=TRUE)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>matH</code> object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>D &lt;- BLOOD # the BLOOD dataset
SUB_D &lt;- BLOOD[c(1, 2, 5), c(1, 2)]
</code></pre>

<hr>
<h2 id='+2A-methods'>Method *</h2><span id='topic++2A-methods'></span><span id='topic++2A+2CdistributionH+2CdistributionH-method'></span><span id='topic++2A+2Cnumeric+2CdistributionH-method'></span><span id='topic++2A+2CdistributionH+2Cnumeric-method'></span>

<h3>Description</h3>

<p>the product of a number and a distribution according to the L2 Wasssertein
</p>
<p>the product of a number and a distribution according to the L2 Wasssertein
</p>
<p>the product of a number and a distribution according to the L2 Wasssertein
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'distributionH,distributionH'
e1 * e2

## S4 method for signature 'numeric,distributionH'
e1 * e2

## S4 method for signature 'distributionH,numeric'
e1 * e2
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B2A-methods_+3A_e1">e1</code></td>
<td>
<p>a <code>distributionH</code> object or a number</p>
</td></tr>
<tr><td><code id="+2B2A-methods_+3A_e2">e2</code></td>
<td>
<p>a <code>distributionH</code> object or a number</p>
</td></tr>
</table>

<hr>
<h2 id='+2B'>Method +</h2><span id='topic++2B'></span><span id='topic++2B+2CdistributionH+2CdistributionH-method'></span><span id='topic++2B+2Cnumeric+2CdistributionH-method'></span><span id='topic++2B+2CdistributionH+2Cnumeric-method'></span>

<h3>Description</h3>

<p>the sum of two distribution according to the L2 Wasssertein
</p>
<p>the sum of a number and a distribution according to the L2 Wasssertein
</p>
<p>the sum of adistribution and a number according to the L2 Wasssertein
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'distributionH,distributionH'
e1 + e2

## S4 method for signature 'numeric,distributionH'
e1 + e2

## S4 method for signature 'distributionH,numeric'
e1 + e2
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B2B_+3A_e1">e1</code></td>
<td>
<p>a <code>distributionH</code> object or a number</p>
</td></tr>
<tr><td><code id="+2B2B_+3A_e2">e2</code></td>
<td>
<p>a <code>distributionH</code> object or a number</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>distributionH</code> object
</p>

<hr>
<h2 id='Age_Pyramids_2014'>Age pyramids of all the countries of the World in 2014</h2><span id='topic+Age_Pyramids_2014'></span>

<h3>Description</h3>

<p>The dataset contains a MatH (matrix of histogram-valued data) object, with three
hisogram-valued variables, the 5-years age (relative frequencies) distribution of all the population,
of the male and of the female population of 228 countries of the World. The  first row is the World data.
Thus it contains 229 rows(228 countries plus the World) and 3 variables: &quot;Both.Sexes.Population&quot;,
&quot;Male.Population&quot;, &quot;Female.Population&quot;
</p>


<h3>Format</h3>

<p>a <code>MatH</code> object, a matrix of distributions.
</p>


<h3>Author(s)</h3>

<p>Antonio Irpino, 2014-10-05
</p>


<h3>Source</h3>

<p>United States Census Bureau <a href="https://www.census.gov/data.html">https://www.census.gov/data.html</a>
</p>

<hr>
<h2 id='Agronomique'>Agronomique data</h2><span id='topic+Agronomique'></span>

<h3>Description</h3>

<p>A dataset with the distributions of marginal costs of farms in 22 France regions. It contains four
histogram variables: &quot;Y_TSC&quot; (Total costs of a farm),  &quot;X_Wheat&quot; (Costs for Wheat), &quot;X_Pig&quot; (Costs for Pigs)
&quot;X_Cmilk&quot; (Costs for Cow Milk)
</p>


<h3>Format</h3>

<p>a <code>MatH</code> object, a matrix of distributions.
</p>


<h3>Author(s)</h3>

<p>Antonio Irpino, 2014-10-05
</p>


<h3>Source</h3>

<p>Rosanna Verde, Antonio Irpino, Second University of Naples; Dominique Desbois, UMR Economie
publique, INRA-AgroParisTech, How to cope with modelling and privacy concerns? A regression model and a visualization tool for
aggregated data,  Conference of European Statistics Stakeholders,
Rome, November, 24-25,2014
</p>

<hr>
<h2 id='BLOOD'>Blood dataset for Histogram data analysis</h2><span id='topic+BLOOD'></span>

<h3>Description</h3>

<p>The dataset contains a MatH (matrix of histogram-valued data) object This
data set list 14 groups of patients described by 3 variables.
</p>


<h3>Format</h3>

<p>a <code>MatH</code> istance, 1 row per group.
</p>


<h3>Author(s)</h3>

<p>Antonio Irpino, 2014-10-05
</p>


<h3>Source</h3>

<p>Billard L. and Diday E. (2006). Symbolic Data Analysis: Conceptual
Statistics and Data Mining, Wiley.
</p>

<hr>
<h2 id='BloodBRITO'>Blood dataset from Brito P. for Histogram data analysis</h2><span id='topic+BloodBRITO'></span>

<h3>Description</h3>

<p>The dataset contains a MatH (matrix of histogram-valued data) object This
data set list 10 patients described by 2 variables.
</p>


<h3>Format</h3>

<p>a <code>MatH</code> istance, 1 row per patient.
</p>


<h3>Author(s)</h3>

<p>Antonio Irpino, 2014-10-05
</p>


<h3>Source</h3>

<p>Dias, S. and Brito P. Distribution and Symmetric Distribution
Regression Model for Histogram-Valued Variables, ArXiv, arXiv:1303.6199
[stat.ME]
</p>

<hr>
<h2 id='Center.cell.MatH'>Method Center.cell.MatH Centers all the cells of a matrix of distributions</h2><span id='topic+Center.cell.MatH'></span><span id='topic+Center.cell.MatH+2CMatH-method'></span>

<h3>Description</h3>

<p>The function transform a MatH object (i.e. a matrix of distributions),
such that each distribution is shifted and has a mean equal to zero
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Center.cell.MatH(object)

## S4 method for signature 'MatH'
Center.cell.MatH(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Center.cell.MatH_+3A_object">object</code></td>
<td>
<p>a MatH object, a matrix of distributions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>MatH</code> object, having each distribution with a zero mean.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>CEN_BLOOD &lt;- Center.cell.MatH(BLOOD)
get.MatH.stats(BLOOD, stat = "mean")
</code></pre>

<hr>
<h2 id='checkEmptyBins'>Method <code>checkEmptyBins</code></h2><span id='topic+checkEmptyBins'></span><span id='topic+checkEmptyBins+2CdistributionH-method'></span>

<h3>Description</h3>

<p>The method checking for empty bins in a distribution, i.e. if two cdf consecutive
values are equal. In that case a probability value of <code>1e-7</code> is
assigned to the empty bin and the cdf is recomputed. This methods is useful
for numerical reasons.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>checkEmptyBins(object)

## S4 method for signature 'distributionH'
checkEmptyBins(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="checkEmptyBins_+3A_object">object</code></td>
<td>
<p>a <code>distributionH</code> object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>distributionH</code> object without empty bins
</p>


<h3>Author(s)</h3>

<p>Antonio Irpino
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## ---- A mydist distribution with an empty bin i.e. two consecutive values of p are equal----
mydist &lt;- distributionH(x = c(1, 2, 3, 10), p = c(0, 0.5, 0.5, 1))
## ---- Checks for empty byns and returns the newdist object without empty bins ----
newdist &lt;- checkEmptyBins(mydist)
</code></pre>

<hr>
<h2 id='China_Month'>A monthly climatic dataset of China</h2><span id='topic+China_Month'></span>

<h3>Description</h3>

<p>A dataset with the distributions of some climatic variables collected for each month in 60 stations of China.
The collected variables are 168 i.e. 14 climatic variables observed for 12 months. The 14 variables are the following:
mean station pressure (mb), mean temperature, mean maximum temperature, mean minimum temperature,
total precipitation (mm), sunshine duration (h), mean cloud amount (percentage of sky cover),
mean relative humidity (
mean wind speed (m/s), dominant wind frequency (
extreme minimum temperature.
Use the command <code> get.MatH.main.info(China_Month)</code> for rapid info.
</p>


<h3>Format</h3>

<p>a <code>MatH</code> object, a matrix of distributions.
</p>


<h3>Author(s)</h3>

<p>Antonio Irpino, 2014-10-05
</p>


<h3>Source</h3>

<p>raw data are available here: <a href="https://data.ess-dive.lbl.gov/view/doi:10.3334/CDIAC/CLI.TR055">https://data.ess-dive.lbl.gov/view/doi:10.3334/CDIAC/CLI.TR055</a>
</p>

<hr>
<h2 id='China_Seas'>A seasonal climatic dataset of China</h2><span id='topic+China_Seas'></span>

<h3>Description</h3>

<p>A dataset with the distributions of some climatic variables collected for each season in 60 stations of China.
The collected variables are 56 i.e. 14 climatic variables observed for 4 seasons. The 14 variables are the following:
mean station pressure (mb), mean temperature, mean maximum temperature, mean minimum temperature,
total precipitation (mm), sunshine duration (h), mean cloud amount (percentage of sky cover),
mean relative humidity (
mean wind speed (m/s), dominant wind frequency (
extreme minimum temperature.
Use the command <code> get.MatH.main.info(China_Seas)</code> for rapid info.
</p>


<h3>Format</h3>

<p>a <code>MatH</code> object, a matrix of distributions.
</p>


<h3>Author(s)</h3>

<p>Antonio Irpino, 2014-10-05
</p>


<h3>Source</h3>

<p>raw data are available here: <a href="https://data.ess-dive.lbl.gov/view/doi:10.3334/CDIAC/CLI.TR055">https://data.ess-dive.lbl.gov/view/doi:10.3334/CDIAC/CLI.TR055</a>.
Climate Data Bases of the People's Republic of China 1841-1988 (TR055)
DOI: 10.3334/CDIAC/cli.tr055
</p>

<hr>
<h2 id='compP'>Method <code>compP</code></h2><span id='topic+compP'></span><span id='topic+compP+2CdistributionH+2Cnumeric-method'></span><span id='topic+compP+2CdistributionH-method'></span>

<h3>Description</h3>

<p>Compute the cdf probability at a given value for a histogram
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compP(object, q)

## S4 method for signature 'distributionH,numeric'
compP(object, q)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compP_+3A_object">object</code></td>
<td>
<p>is an object of <span class="env">distributionH</span> class</p>
</td></tr>
<tr><td><code id="compP_+3A_q">q</code></td>
<td>
<p>is a numeric value</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a value between 0 and 1.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## ---- A mydist distribution ----
mydist &lt;- distributionH(x = c(1, 2, 3, 10), p = c(0, 0.1, 0.5, 1))
## ---- Compute the cfd value for q=5 (not observed) ----
p &lt;- compP(mydist, 5)
</code></pre>

<hr>
<h2 id='compQ'>Method <code>compQ</code></h2><span id='topic+compQ'></span><span id='topic+compQ+2CdistributionH+2Cnumeric-method'></span><span id='topic+compQ+2CdistributionH-method'></span>

<h3>Description</h3>

<p>Compute the quantile value of a histogram for a given probability.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compQ(object, p)

## S4 method for signature 'distributionH,numeric'
compQ(object, p)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compQ_+3A_object">object</code></td>
<td>
<p>an object of <span class="env">distributionH</span> class</p>
</td></tr>
<tr><td><code id="compQ_+3A_p">p</code></td>
<td>
<p>a number between 0 and 1</p>
</td></tr>
</table>


<h3>Value</h3>

<p style="text-align: center;"><code class="reqn">y= F^{-1}(p)=Q(p)</code>
</p>
<p> A number that is the quantile of the passed
histogram <span class="env">object</span> at level <span class="env">p</span>.
</p>


<h3>Author(s)</h3>

<p>Antonio Irpino
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## ---- A mydist distribution ----
mydist &lt;- distributionH(x = c(1, 2, 3, 10), p = c(0, 0.1, 0.5, 1))
## ---- Compute the quantile of mydist for different values of p ----
y &lt;- compQ(mydist, 0.5) # the median
y &lt;- compQ(mydist, 0) # the minimum
y &lt;- compQ(mydist, 1) # the maximum
y &lt;- compQ(mydist, 0.25) # the first quartile
y &lt;- compQ(mydist, 0.9) # the ninth decile
</code></pre>

<hr>
<h2 id='crwtransform'>Method <code>crwtransform</code>: returns the centers and the radii of bins of a distribution</h2><span id='topic+crwtransform'></span><span id='topic+crwtransform+2CdistributionH-method'></span>

<h3>Description</h3>

<p>Centers and ranges calculation for bins of a histogram. It is useful for a
very fast computation of statistics and methods based on the L2 Wassertein
distance between histograms.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>crwtransform(object)

## S4 method for signature 'distributionH'
crwtransform(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="crwtransform_+3A_object">object</code></td>
<td>
<p>a <code>distributionH</code> object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing </p>
<table>
<tr><td><code>$Centers</code></td>
<td>
<p>The midpoints of the bins of the
histogram</p>
</td></tr> <tr><td><code>$Radii</code></td>
<td>
<p>The half-lenghts of the bins of the histogram</p>
</td></tr>
<tr><td><code>$Weights</code></td>
<td>
<p>The relative frequencies or the probailities associated with
each bin (the sum is equal to 1)</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Antonio Irpino
</p>


<h3>References</h3>

<p>Irpino, A., Verde, R., Lechevallier, Y. (2006) <em>Dynamic
clustering of histograms using Wasserstein metric</em>, In: Proceedings of
COMPSTAT 2006, Physica-Verlag, 869-876
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## ---- A mydist distribution ----
mydist &lt;- distributionH(x = c(1, 2, 3, 10), p = c(0, 0.1, 0.5, 1))
## ---- Compute the cfd value for q=5 (not observed) ----
crwtransform(mydist)
</code></pre>

<hr>
<h2 id='data2hist'>From real data to distributionH.</h2><span id='topic+data2hist'></span>

<h3>Description</h3>

<p>From real data to distributionH.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data2hist(
  data,
  algo = "histogram",
  type = "combined",
  qua = 10,
  breaks = numeric(0),
  epsilon = 0.01
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="data2hist_+3A_data">data</code></td>
<td>
<p>a set of numeric values.</p>
</td></tr>
<tr><td><code id="data2hist_+3A_algo">algo</code></td>
<td>
<p>(optional) a string. Default is &quot;histogram&quot;, i.e. the function &quot;histogram&quot;
defined in the <code><a href="histogram.html#topic+histogram">histogram</a></code>  package. <br /> If &quot;base&quot;
the <code><a href="graphics.html#topic+hist">hist</a></code> function is used. <br />
&quot;FixedQuantiles&quot; computes the histogram using as breaks a fixed number of quantiles.<br />
&quot;ManualBreaks&quot; computes a histogram where braks are provided as a vector of values.<br />
&quot;PolyLine&quot; computes a histogram using a piecewise linear approximation of the empirical
cumulative distribution function using the &quot;Ramer-Douglas-Peucker algorithm&quot;,
<a href="https://en.wikipedia.org/wiki/Ramer-Douglas-Peucker_algorithm">https://en.wikipedia.org/wiki/Ramer-Douglas-Peucker_algorithm</a>.
An <code>epsilon</code> parameter is required.
The data are scaled in order to have a standard deviation equal to one.</p>
</td></tr>
<tr><td><code id="data2hist_+3A_type">type</code></td>
<td>
<p>(optional) a string. Default is &quot;combined&quot; and generates
a histogram having regularly spaced breaks (i.e., equi-width bins) and
irregularly spaced ones. The choice is done accordingly with the penalization method described in
<code><a href="histogram.html#topic+histogram">histogram</a></code>. &quot;regular&quot; returns equi-width binned histograms, &quot;irregular&quot; returns
a histogram without equi-width histograms.</p>
</td></tr>
<tr><td><code id="data2hist_+3A_qua">qua</code></td>
<td>
<p>a positive integer to provide if <code>algo="FixedQuantiles"</code> is chosen. Default=10.</p>
</td></tr>
<tr><td><code id="data2hist_+3A_breaks">breaks</code></td>
<td>
<p>a vector of values to provide if  <code>algo="ManualBreaks"</code> is chosen.</p>
</td></tr>
<tr><td><code id="data2hist_+3A_epsilon">epsilon</code></td>
<td>
<p>a number between 0 and 1 to provide if <code>algo="PolyLine"</code> is chosen. Default=0.01.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>distributionH</code> object, i.e. a distribution.
</p>


<h3>See Also</h3>

<p><code><a href="histogram.html#topic+histogram">histogram</a></code> function
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data &lt;- rnorm(n = 1000, mean = 2, sd = 3)
mydist &lt;- data2hist(data)
plot(mydist)
</code></pre>

<hr>
<h2 id='distributionH-class'>Class distributionH.</h2><span id='topic+distributionH-class'></span><span id='topic+distributionH'></span><span id='topic+initialize+2CdistributionH-method'></span>

<h3>Description</h3>

<p>Class <code>"distributionH"</code> desfines an histogram object
The class describes a histogram by means of its cumulative distribution
function. The methods are develoved accordingly to the L2 Wasserstein
distance between distributions.
</p>
<p>A histogram object can be created also with the function <code>distributionH(...)</code>, the costructor function for creating an object containing the description of
a histogram.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'distributionH'
initialize(
  .Object,
  x = numeric(0),
  p = numeric(0),
  m = numeric(0),
  s = numeric(0)
)

distributionH(x = numeric(0), p = numeric(0))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="distributionH-class_+3A_.object">.Object</code></td>
<td>
<p>the type (&quot;distributionH&quot;)</p>
</td></tr>
<tr><td><code id="distributionH-class_+3A_x">x</code></td>
<td>
<p>a numeric vector. it is the domain of the distribution (i.e. the
extremes of bins).</p>
</td></tr>
<tr><td><code id="distributionH-class_+3A_p">p</code></td>
<td>
<p>a numeric vector (of the same lenght of x). It is the cumulative distribution function CDF.</p>
</td></tr>
<tr><td><code id="distributionH-class_+3A_m">m</code></td>
<td>
<p>(optional) a numeric value. Is the mean of the histogram.</p>
</td></tr>
<tr><td><code id="distributionH-class_+3A_s">s</code></td>
<td>
<p>(optional) a numeric positive value. It is the standard deviation of a histogram.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Class <code>distributionH</code> defines a histogram object
</p>


<h3>Value</h3>

<p>A <code>distributionH</code> object
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form
<code>new("distributionH", x, p, m, s)</code>.
</p>


<h3>Author(s)</h3>

<p>Antonio Irpino
</p>


<h3>References</h3>

<p>Irpino, A., Verde, R. (2015) <em>Basic
statistics for distributional symbolic variables: a new metric-based
approach</em> Advances in Data Analysis and Classification, DOI
10.1007/s11634-014-0176-4
</p>


<h3>See Also</h3>

<p><code><a href="#topic+meanH">meanH</a></code> computes the mean. <code><a href="#topic+stdH">stdH</a></code> computes the standard deviation.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#---- initialize a distributionH object mydist
# from a simple histogram
# ----------------------------
# | Bins    |  Prob  | cdf   |
# ----------------------------
# | [1,2)   |  0.4   | 0.4   |
# | [2,3]   |  0.6   | 1.0   |
# ----------------------------
# | Tot.    |  1.0   | -     |
# ----------------------------
mydist &lt;- new("distributionH", c(1, 2, 3), c(0, 0.4, 1))
str(mydist)
# OUTPUT
# Formal class 'distributionH' [package "HistDAWass"] with 4 slots
#   ..@ x: num [1:3] 1 2 3 the quantiles
#   ..@ p: num [1:3] 0 0.4 1 the cdf
#   ..@ m: num 2.1 the mean
#   ..@ s: num 0.569 the standard deviation
# or using
mydist &lt;- distributionH(x = c(1, 2, 3), p = c(0, 0.4, 1))
</code></pre>

<hr>
<h2 id='dotpW'>Method <code>dotpW</code></h2><span id='topic+dotpW'></span><span id='topic+dotpW+2CdistributionH+2CdistributionH-method'></span><span id='topic+dotpW+2CdistributionH-method'></span><span id='topic+dotpW+2Cnumeric+2CdistributionH-method'></span><span id='topic+dotpW+2CdistributionH+2Cnumeric-method'></span>

<h3>Description</h3>

<p>The dot product of two distributions inducing the L2 Wasserstein metric
</p>
<p>The dot product of a number (considered as an impulse distribution function) and a distribution
</p>
<p>The dot product of a distribution and a number (considered as an impulse distribution function).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dotpW(e1, e2)

## S4 method for signature 'distributionH,distributionH'
dotpW(e1, e2)

## S4 method for signature 'numeric,distributionH'
dotpW(e1, e2)

## S4 method for signature 'distributionH,numeric'
dotpW(e1, e2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dotpW_+3A_e1">e1</code></td>
<td>
<p>a <code>distributionH</code> object or a number</p>
</td></tr>
<tr><td><code id="dotpW_+3A_e2">e2</code></td>
<td>
<p>a <code>distributionH</code> object or a number</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric value
</p>


<h3>Author(s)</h3>

<p>Antonio Irpino
</p>


<h3>References</h3>

<p>Irpino, A., Verde, R. (2015) <em>Basic
statistics for distributional symbolic variables: a new metric-based
approach</em> Advances in Data Analysis and Classification, DOI 10.1007/s11634-014-0176-4
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## let's define two distributionH objects
mydist1 &lt;- distributionH(x = c(1, 2, 3, 10), p = c(0, 0.1, 0.5, 1))
mydist2 &lt;- distributionH(x = c(5, 7, 15), p = c(0, 0.7, 1))

## the dot product between the distributions
dotpW(mydist1, mydist2) #---&gt; 39.51429

## the dot product between a distribution and a numeric
dotpW(mydist1, 3) #---&gt; 13.2
dotpW(3, mydist1) #---&gt; 13.2


# DOTPW method -----
</code></pre>

<hr>
<h2 id='DouglasPeucker'>Ramer-Douglas-Peucker algorithm for curve fitting with a PolyLine</h2><span id='topic+DouglasPeucker'></span>

<h3>Description</h3>

<p>Ramer-Douglas-Peucker algorithm for curve fitting with a PolyLine
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DouglasPeucker(points, epsilon)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DouglasPeucker_+3A_points">points</code></td>
<td>
<p>a 2D matrix with the coordinates of 2D points</p>
</td></tr>
<tr><td><code id="DouglasPeucker_+3A_epsilon">epsilon</code></td>
<td>
<p>an number between 0 and 1. Recomended 0.01.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with the points of segments of a Poly Line.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+data2hist">data2hist</a></code> function
</p>

<hr>
<h2 id='get.cell.MatH'>Method get.cell.MatH Returns the histogram in a cell of a matrix of distributions</h2><span id='topic+get.cell.MatH'></span><span id='topic+get.cell.MatH+2CMatH+2Cnumeric+2Cnumeric-method'></span><span id='topic+get.cell.MatH+2CMatH-method'></span>

<h3>Description</h3>

<p>Returns the histogram data in the r-th row and the c-th column.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.cell.MatH(object, r, c)

## S4 method for signature 'MatH,numeric,numeric'
get.cell.MatH(object, r, c)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.cell.MatH_+3A_object">object</code></td>
<td>
<p>a MatH object, a matrix of distributions.</p>
</td></tr>
<tr><td><code id="get.cell.MatH_+3A_r">r</code></td>
<td>
<p>an integer, the row index.</p>
</td></tr>
<tr><td><code id="get.cell.MatH_+3A_c">c</code></td>
<td>
<p>an integer, the column index</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>distributionH</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>get.cell.MatH(BLOOD, r = 1, c = 1)
</code></pre>

<hr>
<h2 id='get.distr'>Method <code>get.distr</code>: show the distribution</h2><span id='topic+get.distr'></span><span id='topic+get.distr+2CdistributionH-method'></span>

<h3>Description</h3>

<p>This functon return the cumulative distribution function of a <code>distributionH</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.distr(object)

## S4 method for signature 'distributionH'
get.distr(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.distr_+3A_object">object</code></td>
<td>
<p>a <code>distributionH</code> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame: the first column contains the domain the second the CDF values.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>D &lt;- distributionH(x = c(1, 2, 3, 4), p = c(0, 0.2, 0.6, 1))
get.distr(D) # a data.frame describing the CDF of D
</code></pre>

<hr>
<h2 id='get.histo'>Method <code>get.histo</code>: show the distribution with bins</h2><span id='topic+get.histo'></span><span id='topic+get.histo+2CdistributionH-method'></span>

<h3>Description</h3>

<p>This functon return a data.frame describing the histogram of a <code>distributionH</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.histo(object)

## S4 method for signature 'distributionH'
get.histo(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.histo_+3A_object">object</code></td>
<td>
<p>a <code>distributionH</code> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix: the two columns contains the bounds of the histogram the third contains the probablity (or the relative frequency) of the bin.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>D &lt;- distributionH(x = c(1, 2, 3, 4), p = c(0, 0.2, 0.6, 1))
get.histo(D) # returns the histogram representation of D by a data.frame
</code></pre>

<hr>
<h2 id='get.m'>Method <code>get.m</code>: the mean of a distribution</h2><span id='topic+get.m'></span><span id='topic+get.m+2CdistributionH-method'></span>

<h3>Description</h3>

<p>This functon return the mean of a <code>distributionH</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.m(object)

## S4 method for signature 'distributionH'
get.m(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.m_+3A_object">object</code></td>
<td>
<p>a <code>distributionH</code> object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric value
</p>


<h3>Examples</h3>

<pre><code class='language-R'>D &lt;- distributionH(x = c(1, 2, 3, 4), p = c(0, 0.2, 0.6, 1))
get.m(D) # returns the mean of D
</code></pre>

<hr>
<h2 id='get.MatH.main.info'>Method get.MatH.main.info</h2><span id='topic+get.MatH.main.info'></span><span id='topic+get.MatH.main.info+2CMatH-method'></span>

<h3>Description</h3>

<p>It returns the number of rows, of columns the labels of rows and columns of a <code>MatH</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.MatH.main.info(object)

## S4 method for signature 'MatH'
get.MatH.main.info(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.MatH.main.info_+3A_object">object</code></td>
<td>
<p>a <code>MatH</code> object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of char, the labels of the columns, or the names of the variables.
</p>


<h3>Slots</h3>


<dl>
<dt><code>nrows</code></dt><dd><p>- the number of rows</p>
</dd>
<dt><code>ncols</code></dt><dd><p>- the number of columns</p>
</dd>
<dt><code>rownames</code></dt><dd><p>- a vector of char, the names of rows</p>
</dd>
<dt><code>varnames</code></dt><dd><p>- a vector of char, the names of columns</p>
</dd>
</dl>

<hr>
<h2 id='get.MatH.ncols'>Method get.MatH.ncols</h2><span id='topic+get.MatH.ncols'></span><span id='topic+get.MatH.ncols+2CMatH-method'></span>

<h3>Description</h3>

<p>It returns the number of columns of a <code>MatH</code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.MatH.ncols(object)

## S4 method for signature 'MatH'
get.MatH.ncols(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.MatH.ncols_+3A_object">object</code></td>
<td>
<p>a <code>MatH</code> object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An integer, the number of columns.
</p>

<hr>
<h2 id='get.MatH.nrows'>Method get.MatH.nrows</h2><span id='topic+get.MatH.nrows'></span><span id='topic+get.MatH.nrows+2CMatH-method'></span>

<h3>Description</h3>

<p>It returns the number of rows of a <code>MatH</code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'MatH'
get.MatH.nrows(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.MatH.nrows_+3A_object">object</code></td>
<td>
<p>a <code>MatH</code> object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An integer, the number of rows.
</p>

<hr>
<h2 id='get.MatH.rownames'>Method get.MatH.rownames</h2><span id='topic+get.MatH.rownames'></span><span id='topic+get.MatH.rownames+2CMatH-method'></span>

<h3>Description</h3>

<p>It returns the labels of the rows of a <code>MatH</code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.MatH.rownames(object)

## S4 method for signature 'MatH'
get.MatH.rownames(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.MatH.rownames_+3A_object">object</code></td>
<td>
<p>a <code>MatH</code> object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of char, the label of the rows.
</p>

<hr>
<h2 id='get.MatH.stats'>Method get.MatH.stats</h2><span id='topic+get.MatH.stats'></span><span id='topic+get.MatH.stats+2CMatH-method'></span>

<h3>Description</h3>

<p>It returns statistics for each distribution contained in a <code>MatH</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.MatH.stats(object, ...)

## S4 method for signature 'MatH'
get.MatH.stats(object, stat = "mean", prob = 0.5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.MatH.stats_+3A_object">object</code></td>
<td>
<p>a <code>MatH</code> object</p>
</td></tr>
<tr><td><code id="get.MatH.stats_+3A_...">...</code></td>
<td>
<p>a set of other parameters</p>
</td></tr>
<tr><td><code id="get.MatH.stats_+3A_stat">stat</code></td>
<td>
<p>(optional) a string containing the required statistic. Default='mean'<br />
- <code>stat='mean'</code> - for computing the mean of each histogram<br />
- <code>stat='median'</code> - for computing the median of each histogram<br />
- <code>stat='min'</code> - for computing the minimum of each histogram<br />
- <code>stat='max'</code> - for computing the maximum of each histogram<br />
- <code>stat='std'</code> - for computing the standard deviatio of each histogram<br />
- <code>stat='skewness'</code> - for computing the skewness of each histogram<br />
- <code>stat='kurtosis'</code> - for computing the kurtosis of each histogram<br />
- <code>stat='quantile'</code> - for computing the quantile ot level <code>prob</code> of each histogram<br /></p>
</td></tr>
<tr><td><code id="get.MatH.stats_+3A_prob">prob</code></td>
<td>
<p>(optional)a number between 0 and 1 for computing the value once choosen the <code>'quantile'</code> option for <code>stat</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list
</p>


<h3>Slots</h3>


<dl>
<dt><code>stat</code></dt><dd><p>- the chosen statistic</p>
</dd>
<dt><code>prob</code></dt><dd><p>- level of probability if stat='quantile'</p>
</dd>
<dt><code>MAT</code></dt><dd><p>- a matrix of values</p>
</dd>
</dl>


<h3>Examples</h3>

<pre><code class='language-R'>get.MatH.stats(BLOOD) # the means of the distributions in BLOOD dataset
get.MatH.stats(BLOOD, stat = "median") # the medians of the distributions in BLOOD dataset
get.MatH.stats(BLOOD, stat = "quantile", prob = 0.5) # the same as median
get.MatH.stats(BLOOD, stat = "min") # minima of the distributions in BLOOD dataset
get.MatH.stats(BLOOD, stat = "quantile", prob = 0) # the same as min
get.MatH.stats(BLOOD, stat = "max") # maxima of the distributions in BLOOD dataset
get.MatH.stats(BLOOD, stat = "quantile", prob = 1) # the same as max
get.MatH.stats(BLOOD, stat = "std") # standard deviations of the distributions in BLOOD dataset
get.MatH.stats(BLOOD, stat = "skewness") # skewness indices of the distributions in BLOOD dataset
get.MatH.stats(BLOOD, stat = "kurtosis") # kurtosis indices of the distributions in BLOOD dataset
get.MatH.stats(BLOOD, stat = "quantile", prob = 0.05)
# the fifth percentiles of distributions in BLOOD dataset
</code></pre>

<hr>
<h2 id='get.MatH.varnames'>Method get.MatH.varnames</h2><span id='topic+get.MatH.varnames'></span><span id='topic+get.MatH.varnames+2CMatH-method'></span>

<h3>Description</h3>

<p>It returns the labels of the columns, or the names of the variables, of a <code>MatH</code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.MatH.varnames(object)

## S4 method for signature 'MatH'
get.MatH.varnames(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.MatH.varnames_+3A_object">object</code></td>
<td>
<p>a <code>MatH</code> object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of char, the labels of the columns, or the names of the variables.
</p>

<hr>
<h2 id='get.s'>Method <code>get.s</code>: the standard deviation of a distribution</h2><span id='topic+get.s'></span><span id='topic+get.s+2CdistributionH-method'></span>

<h3>Description</h3>

<p>This functon return the standard deviation of a <code>distributionH</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.s(object)

## S4 method for signature 'distributionH'
get.s(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.s_+3A_object">object</code></td>
<td>
<p>a <code>distributionH</code> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric positive value, the standard deviation.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>D &lt;- distributionH(x = c(1, 2, 3, 4), p = c(0, 0.2, 0.6, 1))
get.s(D) # returns the standard deviation of D
</code></pre>

<hr>
<h2 id='HistDAWass-package'>Histogram-Valued Data Analysis</h2><span id='topic+HistDAWass-package'></span><span id='topic+HistDAWass'></span><span id='topic+_PACKAGE'></span>

<h3>Description</h3>

<p>We consider histogram-valued data, i.e., data described by univariate histograms. The
methods and the basic statistics for histogram-valued data are mainly based
on the L2 Wasserstein metric between distributions, i.e., a Euclidean metric
between quantile functions. The package contains unsupervised classification techniques,
least square regression and tools for histrogram-valued data and for histogram time series.
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;"> Package: </td><td style="text-align: left;"> HistDAWass</td>
</tr>
<tr>
 <td style="text-align: left;"> Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;"> Version:
</td><td style="text-align: left;"> 0.1.1</td>
</tr>
<tr>
 <td style="text-align: left;"> Date: </td><td style="text-align: left;"> 2014-09-17</td>
</tr>
<tr>
 <td style="text-align: left;"> License: </td><td style="text-align: left;"> GPL (&gt;=2)</td>
</tr>
<tr>
 <td style="text-align: left;"> Depends:
</td><td style="text-align: left;"> methods</td>
</tr>
<tr>
 <td style="text-align: left;"> </td>
</tr>

</table>
<p>  An overview of how to use the package, including the
most important functions
</p>


<h3>Author(s)</h3>

<p>Antonio Irpino &lt;antonio.irpino@unicampania.it&gt;
</p>


<h3>References</h3>

<p>Irpino, A., Verde, R. (2015) <em>Basic
statistics for distributional symbolic variables: a new metric-based
approach</em>, Advances in Data Analysis and Classification, Volume 9, Issue 2, pp 143&ndash;175.
DOI <a href="https://doi.org/10.1007/s11634-014-0176-4">doi:10.1007/s11634-014-0176-4</a><br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Generating a list of distributions
a &lt;- vector("list", 4)
a[[1]] &lt;- distributionH(
  x = c(80, 100, 120, 135, 150, 165, 180, 200, 240),
  p = c(0, 0.025, 0.1, 0.275, 0.525, 0.725, 0.887, 0.975, 1)
)
a[[2]] &lt;- distributionH(
  x = c(80, 100, 120, 135, 150, 165, 180, 195, 210, 240),
  p = c(0, 0.013, 0.101, 0.255, 0.508, 0.718, 0.895, 0.961, 0.987, 1)
)
a[[3]] &lt;- distributionH(
  x = c(95, 110, 125, 140, 155, 170, 185, 200, 215, 230, 245),
  p = c(0, 0.012, 0.041, 0.154, 0.36, 0.595, 0.781, 0.929, 0.972, 0.992, 1)
)
a[[4]] &lt;- distributionH(
  x = c(105, 120, 135, 150, 165, 180, 195, 210, 225, 240, 260),
  p = c(0, 0.009, 0.035, 0.081, 0.186, 0.385, 0.633, 0.832, 0.932, 0.977, 1)
)
# Generating a list of names of observations
namerows &lt;- list("u1", "u2")
# Generating a list of names of variables
namevars &lt;- list("Var_1", "Var_2")
# creating the MatH
Mat_of_distributions &lt;- MatH(
  x = a, nrows = 2, ncols = 2,
  rownames = namerows, varnames = namevars, by.row = FALSE
)
</code></pre>

<hr>
<h2 id='HTS-class'>Class HTS</h2><span id='topic+HTS-class'></span><span id='topic+HTS'></span><span id='topic+initialize+2CHTS-method'></span>

<h3>Description</h3>

<p>Class <code>HTS</code> defines a histogram time series, i.e. a set of histograms observed along time
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'HTS'
initialize(.Object, epocs = 1, ListOfTimedElements = c(new("TdistributionH")))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="HTS-class_+3A_.object">.Object</code></td>
<td>
<p>the object type (&quot;HTS&quot;) a histogram time series</p>
</td></tr>
<tr><td><code id="HTS-class_+3A_epocs">epocs</code></td>
<td>
<p>the number of histograms (one for each timepoint or period)</p>
</td></tr>
<tr><td><code id="HTS-class_+3A_listoftimedelements">ListOfTimedElements</code></td>
<td>
<p>a vector of <code>TdistributionH</code> objects</p>
</td></tr>
</table>

<hr>
<h2 id='HTS.exponential.smoothing'>Smoothing with exponential smoothing of a histogram time series</h2><span id='topic+HTS.exponential.smoothing'></span>

<h3>Description</h3>

<p>(Beta verson of) Extends theexponential smoothing of a time
series to a histogram time series,using L2 Wasserstein distance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>HTS.exponential.smoothing(HTS, alpha = 0.9)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="HTS.exponential.smoothing_+3A_hts">HTS</code></td>
<td>
<p>A <code>HTS</code> object (a histogram time series).</p>
</td></tr>
<tr><td><code id="HTS.exponential.smoothing_+3A_alpha">alpha</code></td>
<td>
<p>a number between 0 and 1 for exponential smoothing</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with the results of the smoothing procedure.
</p>


<h3>Slots</h3>


<dl>
<dt><code>smoothing.alpha</code></dt><dd><p>the alpha parameter</p>
</dd>
<dt><code>AveragedHTS</code></dt><dd><p>The smoothed HTS</p>
</dd>
</dl>


<h3>Examples</h3>

<pre><code class='language-R'>mov.expo.smooth &lt;- HTS.exponential.smoothing(HTS = RetHTS, alpha = 0.8)
# a show method for HTS must be implemented you can see it using
# str(mov.expo.smooth$AveragedHTS)
</code></pre>

<hr>
<h2 id='HTS.moving.averages'>Smoothing with moving averages of a histogram time series</h2><span id='topic+HTS.moving.averages'></span>

<h3>Description</h3>

<p>(Beta verson of) Extends the moving average smoothing of a time
series to a histogram time series, using L2 Wasserstein distance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>HTS.moving.averages(HTS, k = 3, weights = rep(1, k))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="HTS.moving.averages_+3A_hts">HTS</code></td>
<td>
<p>A <code>HTS</code> object (a histogram time series).</p>
</td></tr>
<tr><td><code id="HTS.moving.averages_+3A_k">k</code></td>
<td>
<p>an integer value, the number of elements for moving averages</p>
</td></tr>
<tr><td><code id="HTS.moving.averages_+3A_weights">weights</code></td>
<td>
<p>a vector of positive weights for a weighted moving average</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with the results of the smoothing procedure.
</p>


<h3>Slots</h3>


<dl>
<dt><code>k</code></dt><dd><p>the number of elements for the average</p>
</dd>
<dt><code>weights</code></dt><dd><p>the vector of weights for smoothing</p>
</dd>
<dt><code>AveragedHTS</code></dt><dd><p>The smoothed HTS</p>
</dd>
</dl>


<h3>Examples</h3>

<pre><code class='language-R'>mov.av.smoothed &lt;- HTS.moving.averages(HTS = RetHTS, k = 5)
# a show method for HTS must be implemented you can see it using
# str(mov.av.smoothed$AveragedHTS)
</code></pre>

<hr>
<h2 id='HTS.predict.knn'>K-NN predictions of a histogram time series</h2><span id='topic+HTS.predict.knn'></span>

<h3>Description</h3>

<p>(Beta verson of) Extends the K-NN algorithm for predicting a time
series to a histogram time series, using L2 Wasserstein distance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>HTS.predict.knn(HTS, position = length(HTS@data), k = 3)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="HTS.predict.knn_+3A_hts">HTS</code></td>
<td>
<p>A <code>HTS</code> object (a histogram time series).</p>
</td></tr>
<tr><td><code id="HTS.predict.knn_+3A_position">position</code></td>
<td>
<p>an integer, the data histogram to predict</p>
</td></tr>
<tr><td><code id="HTS.predict.knn_+3A_k">k</code></td>
<td>
<p>the number of neighbours (default=3)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Histogram time series (HTS) describe situations where a distribution of values is available
for each instant of time. These situations usually arise when contemporaneous or temporal aggregation
is required. In these cases, histograms provide a summary of the data that is more informative than those
provided by other aggregates such as the mean.
Some fields where HTS are useful include economy, official statistics and environmental science.
The function adapts the k-Nearest Neighbours (k-NN) algorithm to forecast HTS and, more generally,
to deal with histogram data. The proposed k-NN relies on the L2 Wasserstein distance that is used
to measure dissimilarities between sequences of histograms and to compute the forecasts.
</p>


<h3>Value</h3>

<p>a <code>distributionH</code> object predicted from data.
</p>


<h3>References</h3>

<p>Javier Arroyo, Carlos Mate, Forecasting histogram time series with k-nearest neighbours methods,
International Journal of Forecasting, Volume 25, Issue 1, January-March 2009, Pages 192-207,
ISSN 0169-2070, http://dx.doi.org/10.1016/j.ijforecast.2008.07.003.<br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>prediction &lt;- HTS.predict.knn(HTS = RetHTS, position = 108, k = 3)
</code></pre>

<hr>
<h2 id='is.registeredMH'>Method is.registeredMH</h2><span id='topic+is.registeredMH'></span><span id='topic+is.registeredMH+2CMatH-method'></span>

<h3>Description</h3>

<p>Checks if a <code>MatH</code> contains histograms described by the same number of
bins and the same cdf.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.registeredMH(object)

## S4 method for signature 'MatH'
is.registeredMH(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.registeredMH_+3A_object">object</code></td>
<td>
<p>A <code>MatH</code> object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>logical</code> value <code>TRUE</code> if the distributions share the
same cdf, <code>FALSE</code> otherwise.
</p>


<h3>Author(s)</h3>

<p>Antonio Irpino
</p>


<h3>References</h3>

<p>Irpino, A., Lechevallier, Y. and Verde, R. (2006): <em>Dynamic
clustering of histograms using Wasserstein metric</em> In: Rizzi, A., Vichi, M.
(eds.) COMPSTAT 2006. Physica-Verlag, Berlin, 869-876.<br /> Irpino, A.,Verde,
R. (2006): <em>A new Wasserstein based distance for the hierarchical
clustering of histogram symbolic data</em> In: Batanjeli, V., Bock, H.H.,
Ferligoj, A., Ziberna, A. (eds.) Data Science and Classification, IFCS 2006.
Springer, Berlin, 185-192.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## ---- initialize three distributionH objects mydist1 and mydist2
mydist1 &lt;- new("distributionH", c(1, 2, 3), c(0, 0.4, 1))
mydist2 &lt;- new("distributionH", c(7, 8, 10, 15), c(0, 0.2, 0.7, 1))
mydist3 &lt;- new("distributionH", c(9, 11, 20), c(0, 0.8, 1))
## create a MatH object
MyMAT &lt;- new("MatH", nrows = 1, ncols = 3, ListOfDist = c(mydist1, mydist2, mydist3), 1, 3)
is.registeredMH(MyMAT)
## [1] FALSE #the distributions do not share the same cdf
## Hint: check with str(MyMAT)

## register the two distributions
MATregistered &lt;- registerMH(MyMAT)
is.registeredMH(MATregistered)
## TRUE #the distributions share the same cdf
## Hint: check with str(MATregistered)
</code></pre>

<hr>
<h2 id='kurtH'>Method <code>kurtH</code>: computes the kurthosis of a distribution</h2><span id='topic+kurtH'></span><span id='topic+kurtH+2CdistributionH-method'></span>

<h3>Description</h3>

<p>Kurtosis of a histogram (using the fourth standardized moment)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kurtH(object)

## S4 method for signature 'distributionH'
kurtH(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kurtH_+3A_object">object</code></td>
<td>
<p>a <code>distributionH</code> object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A value for the kurtosis index, 3 is the kurtosis of a Gaussian
distribution
</p>


<h3>Author(s)</h3>

<p>Antonio Irpino
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## ---- A mydist distribution ----
mydist &lt;- distributionH(x = c(1, 2, 3, 10), p = c(0, 0.1, 0.5, 1))
## ---- Compute the kurtosis of mydist ----
kurtH(mydist) #---&gt; 1.473242
</code></pre>

<hr>
<h2 id='MatH-class'>Class MatH.</h2><span id='topic+MatH-class'></span><span id='topic+MatH'></span><span id='topic+initialize+2CMatH-method'></span>

<h3>Description</h3>

<p>Class <code>MatH</code> defines a matrix of <code>distributionH</code> objects
</p>
<p>This function create a matrix of histogram data, i.e. a <code>MatH</code>
object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'MatH'
initialize(
  .Object,
  nrows = 1,
  ncols = 1,
  ListOfDist = NULL,
  names.rows = NULL,
  names.cols = NULL,
  by.row = FALSE
)

MatH(
  x = NULL,
  nrows = 1,
  ncols = 1,
  rownames = NULL,
  varnames = NULL,
  by.row = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MatH-class_+3A_.object">.Object</code></td>
<td>
<p>the object type &quot;MatH&quot;</p>
</td></tr>
<tr><td><code id="MatH-class_+3A_nrows">nrows</code></td>
<td>
<p>(optional, default=1)an integer, the number of rows.</p>
</td></tr>
<tr><td><code id="MatH-class_+3A_ncols">ncols</code></td>
<td>
<p>(optional, default=1) an integer, the number of columns (aka
variables).</p>
</td></tr>
<tr><td><code id="MatH-class_+3A_listofdist">ListOfDist</code></td>
<td>
<p>a vector or a list of <code>distributionH</code> objects</p>
</td></tr>
<tr><td><code id="MatH-class_+3A_names.rows">names.rows</code></td>
<td>
<p>a vector or list of strings with thenames of the rows</p>
</td></tr>
<tr><td><code id="MatH-class_+3A_names.cols">names.cols</code></td>
<td>
<p>a vector or list of strings with thenames of the columns (variables)</p>
</td></tr>
<tr><td><code id="MatH-class_+3A_by.row">by.row</code></td>
<td>
<p>(optional, default=FALSE) a logical value, TRUE the matrix is
row wise filled, FALSE the matrix is filled column wise.</p>
</td></tr>
<tr><td><code id="MatH-class_+3A_x">x</code></td>
<td>
<p>(optional, default= an empty <code>distributionH</code> object) a list of
<code>distributionH</code> objects</p>
</td></tr>
<tr><td><code id="MatH-class_+3A_rownames">rownames</code></td>
<td>
<p>(optional, default=NULL) a list of strings containing the
names of the rows.</p>
</td></tr>
<tr><td><code id="MatH-class_+3A_varnames">varnames</code></td>
<td>
<p>(optional, default=NULL) a list of strings containing the
names of the columns (aka variables).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>matH</code> object
</p>


<h3>Author(s)</h3>

<p>Antonio Irpino
</p>


<h3>References</h3>

<p>Irpino, A., Verde, R. (2015) <em>Basic
statistics for distributional symbolic variables: a new metric-based
approach</em> Advances in Data Analysis and Classification, DOI
10.1007/s11634-014-0176-4
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## ---- create a list of six distributionH objects
ListOfDist &lt;- vector("list", 6)
ListOfDist[[1]] &lt;- distributionH(c(1, 2, 3), c(0, 0.4, 1))
ListOfDist[[2]] &lt;- distributionH(c(7, 8, 10, 15), c(0, 0.2, 0.7, 1))
ListOfDist[[3]] &lt;- distributionH(c(9, 11, 20), c(0, 0.5, 1))
ListOfDist[[4]] &lt;- distributionH(c(2, 5, 8), c(0, 0.3, 1))
ListOfDist[[5]] &lt;- distributionH(c(8, 10, 15), c(0, 0.75, 1))
ListOfDist[[6]] &lt;- distributionH(c(20, 22, 24), c(0, 0.12, 1))

## create a MatH object filling it by columns
MyMAT &lt;- new("MatH",
  nrows = 3, ncols = 2, ListOfDist = ListOfDist,
  names.rows = c("I1", "I2", "I3"), names.cols = c("Var1", "Var2"), by.row = FALSE
)

showClass("MatH")

# bulding an empty 10 by 4 matrix of histograms
MAT &lt;- MatH(nrows = 10, ncols = 4)
</code></pre>

<hr>
<h2 id='meanH'>Method <code>meanH</code>: computes the mean of a distribution</h2><span id='topic+meanH'></span><span id='topic+meanH+2CdistributionH-method'></span>

<h3>Description</h3>

<p>Mean of a histogram (First moment of the distribution)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>meanH(object)

## S4 method for signature 'distributionH'
meanH(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="meanH_+3A_object">object</code></td>
<td>
<p>a <code>distributionH</code> object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the mean of the distribution
</p>


<h3>Author(s)</h3>

<p>Antonio Irpino
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## ---- A mydist distribution ----
mydist &lt;- distributionH(x = c(1, 2, 3, 10), p = c(0, 0.1, 0.5, 1))
## ---- Compute the mean of mydist ----
meanH(mydist) #---&gt; 4.4
</code></pre>

<hr>
<h2 id='minus'>Method -</h2><span id='topic+minus'></span><span id='topic+-+2CdistributionH+2CdistributionH-method'></span><span id='topic+-+2Cnumeric+2CdistributionH-method'></span><span id='topic+-+2CdistributionH+2Cnumeric-method'></span>

<h3>Description</h3>

<p>the difference of two distribution according to the L2 Wasssertein
</p>
<p>the difference of a number and a distribution according to the L2 Wasssertein
</p>
<p>the difference of a distribution and a number according to the L2 Wasssertein
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'distributionH,distributionH'
e1 - e2

## S4 method for signature 'numeric,distributionH'
e1 - e2

## S4 method for signature 'distributionH,numeric'
e1 - e2
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="minus_+3A_e1">e1</code></td>
<td>
<p>a <code>distributionH</code> object or a number</p>
</td></tr>
<tr><td><code id="minus_+3A_e2">e2</code></td>
<td>
<p>a <code>distributionH</code> object or a number</p>
</td></tr>
</table>


<h3>Note</h3>

<p>it may not works properly if the difference is not a distribution
</p>

<hr>
<h2 id='OzoneFull'>Full Ozone dataset for Histogram data analysis</h2><span id='topic+OzoneFull'></span>

<h3>Description</h3>

<p>The dataset contains MatH (matrix of histogram-valued data) object This data
set list 78 stations located in the USA recording four variables, without
missing data.
</p>


<h3>Format</h3>

<p>a <code>MatH</code> istance, 1 row per station.
</p>


<h3>Author(s)</h3>

<p>Antonio Irpino, 2014-10-05
</p>


<h3>Source</h3>

<p>http://java.epa.gov/castnet/epa_jsp/prepackageddata.jsp
ftp://ftp.epa.gov/castnet/data/metdata.zip
</p>

<hr>
<h2 id='OzoneH'>Complete Ozone dataset for Histogram data analysis</h2><span id='topic+OzoneH'></span>

<h3>Description</h3>

<p>The dataset contains MatH (matrix of histogram-valued data) object This data
set list 84 stations located in the USA recording four variables. Some
stations contains missing data.
</p>


<h3>Format</h3>

<p>a <code>MatH</code> istance, 1 row per station.
</p>


<h3>Author(s)</h3>

<p>Antonio Irpino, 2014-10-05
</p>


<h3>Source</h3>

<p>http://java.epa.gov/castnet/epa_jsp/prepackageddata.jsp
ftp://ftp.epa.gov/castnet/data/metdata.zip
</p>

<hr>
<h2 id='plot_errors'>A function for plotting functions of errors</h2><span id='topic+plot_errors'></span>

<h3>Description</h3>

<p>This function allows the representation of the difference between observed histograms and
the respective predicted ones. It can
be used as a tool for interpreting preditive methods (for exampe, the regression of histogrma data)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_errors(PRED, OBS, type = "HISTO_QUA", np = 200)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_errors_+3A_pred">PRED</code></td>
<td>
<p>a <code>MatH</code> object with one column, the predicted data</p>
</td></tr>
<tr><td><code id="plot_errors_+3A_obs">OBS</code></td>
<td>
<p>a <code>MatH</code> object with one column, the observed data</p>
</td></tr>
<tr><td><code id="plot_errors_+3A_type">type</code></td>
<td>
<p>a string. &quot;HISTO_QUA&quot; (default), if ones want to compare histograms quantile differences<br />
&quot;HISTO_DEN&quot;, if ones want to show the histogram densities differences;<br />
&quot;DENS_KDE&quot; if ones want to show the differences between approximated densities (using KDE);<br /></p>
</td></tr>
<tr><td><code id="plot_errors_+3A_np">np</code></td>
<td>
<p>number of points considered for density  or quantile computation (default=200).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plot with functions of differences between observed and predicted histograms, and a
Root Mean Squared value computing by using the L2 Wasserstein distance.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## do a regression
pars &lt;- WH.regression.two.components(BLOOD, Yvar = 1, Xvars = c(2:3))
## predict data
PRED &lt;- WH.regression.two.components.predict(data = BLOOD[, 2:3], parameters = pars)
## define observed data
OBS &lt;- BLOOD[, 1]
plot_errors(PRED, OBS, "HISTO_QUA")
plot_errors(PRED, OBS, "HISTO_DEN")
plot_errors(PRED, OBS, "DENS_KDE")
</code></pre>

<hr>
<h2 id='plot-distributionH'>plot for a distributionH object</h2><span id='topic+plot-distributionH'></span><span id='topic+plot+2CdistributionH-method'></span>

<h3>Description</h3>

<p>A plot function for a <code>distributionH</code> object. The function returns a representation
of the histogram.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'distributionH'
plot(x, type = "HISTO", col = "green", border = "black")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot-distributionH_+3A_x">x</code></td>
<td>
<p>a <code>distributionH</code> object</p>
</td></tr>
<tr><td><code id="plot-distributionH_+3A_type">type</code></td>
<td>
<p>(optional) a string describing the type of plot, default=&quot;HISTO&quot;.<br /> Other allowed types are
<br />&quot;CDF&quot;=Cumulative distribution function, <br />&quot;QF&quot;= quantile function, <br />&quot;DENS&quot;=a density approximation,
<br />&quot;HBOXPLOT&quot;=horizontal boxplot, <br />&quot;VBOXPLOT&quot;= vertical boxplot,</p>
</td></tr>
<tr><td><code id="plot-distributionH_+3A_col">col</code></td>
<td>
<p>(optional) a string the color of the plot, default=&quot;green&quot;.</p>
</td></tr>
<tr><td><code id="plot-distributionH_+3A_border">border</code></td>
<td>
<p>(optional) a string the color of the border of the plot, default=&quot;black&quot;.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## ---- initialize a distributionH
mydist &lt;- distributionH(x = c(7, 8, 10, 15), p = c(0, 0.2, 0.7, 1))
# show the histogram
plot(mydist) # plots mydist
plot(mydist, type = "HISTO", col = "red", border = "blue") # plots mydist
plot(mydist, type = "DENS", col = "red", border = "blue") # plots a density approximation for mydist
plot(mydist, type = "HBOXPLOT") # plots a horizontal boxplot for mydist
plot(mydist, type = "VBOXPLOT") # plots a vertical boxplot for mydist
plot(mydist, type = "CDF") # plots the cumulative distribution function of mydist
plot(mydist, type = "QF") # plots the quantile function of mydist
</code></pre>

<hr>
<h2 id='plot-HTS'>Method plot for a histogram time series</h2><span id='topic+plot-HTS'></span><span id='topic+plot+2CHTS-method'></span>

<h3>Description</h3>

<p>An overloading plot function for a <code>HTS</code> object. The method returns a graphical representation
of a histogram time series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'HTS'
plot(x, y = "missing", type = "VIOLIN", border = "black", maxno.perplot = 30)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot-HTS_+3A_x">x</code></td>
<td>
<p>a <code>distributionH</code> object</p>
</td></tr>
<tr><td><code id="plot-HTS_+3A_y">y</code></td>
<td>
<p>not used in this implementation</p>
</td></tr>
<tr><td><code id="plot-HTS_+3A_type">type</code></td>
<td>
<p>(optional) a string describing the type of plot, default=&quot;BOXPLOT&quot;.<br />
Other allowed types are <br />
&quot;VIOLIN&quot;=a violin-plot representation,</p>
</td></tr>
<tr><td><code id="plot-HTS_+3A_border">border</code></td>
<td>
<p>(optional) a string the color of the border of the plot, default=&quot;black&quot;.</p>
</td></tr>
<tr><td><code id="plot-HTS_+3A_maxno.perplot">maxno.perplot</code></td>
<td>
<p>An integer (DEFAULT=30). Maximum number of timestamps per row.
It allows a plot organized by rows, each row of the plot contains a max number of time stamps
indicated by maxno.perplot.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>plot(subsetHTS(RetHTS, from = 1, to = 10)) # plots RetHTS dataset
## Not run: 
plot(RetHTS, type = "BOXPLOT", border = "blue", maxno.perplot = 20)
plot(RetHTS, type = "VIOLIN", border = "blue", maxno.perplot = 20)
plot(RetHTS, type = "VIOLIN", border = "blue", maxno.perplot = 10)

## End(Not run)
</code></pre>

<hr>
<h2 id='plot-MatH'>Method plot for a matrix  of histograms</h2><span id='topic+plot-MatH'></span><span id='topic+plot+2CMatH-method'></span>

<h3>Description</h3>

<p>An overloading plot function for a <code>MatH</code> object. The method returns a graphical representation
of the matrix of histograms.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'MatH'
plot(x, y = "missing", type = "HISTO", border = "black", angL = 330)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot-MatH_+3A_x">x</code></td>
<td>
<p>a <code>distributionH</code> object</p>
</td></tr>
<tr><td><code id="plot-MatH_+3A_y">y</code></td>
<td>
<p>not used in this implementation</p>
</td></tr>
<tr><td><code id="plot-MatH_+3A_type">type</code></td>
<td>
<p>(optional) a string describing the type of plot, default=&quot;HISTO&quot;.<br />
Other allowed types are <br />
&quot;DENS&quot;=a density approximation, <br />
&quot;BOXPLOT&quot;=l boxplot</p>
</td></tr>
<tr><td><code id="plot-MatH_+3A_border">border</code></td>
<td>
<p>(optional) a string the color of the border of the plot, default=&quot;black&quot;.</p>
</td></tr>
<tr><td><code id="plot-MatH_+3A_angl">angL</code></td>
<td>
<p>(optional) angle of labels of rows (DEFAULT=330).</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>plot(BLOOD) # plots BLOOD dataset
## Not run: 
plot(BLOOD, type = "HISTO", border = "blue") # plots a matrix of histograms
plot(BLOOD, type = "DENS", border = "blue") # plots a matrix of densities
plot(BLOOD, type = "BOXPLOT") # plots a  boxplots

## End(Not run)
</code></pre>

<hr>
<h2 id='plot-TdistributionH'>plot for a TdistributionH object</h2><span id='topic+plot-TdistributionH'></span><span id='topic+plot+2CTdistributionH-method'></span>

<h3>Description</h3>

<p>A plot function for a <code>TdistributionH</code> object. The function returns a representation
of the histogram.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'TdistributionH'
plot(x, type = "HISTO", col = "green", border = "black")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot-TdistributionH_+3A_x">x</code></td>
<td>
<p>a <code>TdistributionH</code> object</p>
</td></tr>
<tr><td><code id="plot-TdistributionH_+3A_type">type</code></td>
<td>
<p>(optional) a string describing the type of plot, default=&quot;HISTO&quot;.<br /> Other allowed types are
<br />&quot;CDF&quot;=Cumulative distribution function, <br />&quot;QF&quot;= quantile function, <br />&quot;DENS&quot;=a density approximation,
<br />&quot;HBOXPLOT&quot;=horizontal boxplot, <br />&quot;VBOXPLOT&quot;= vertical boxplot,</p>
</td></tr>
<tr><td><code id="plot-TdistributionH_+3A_col">col</code></td>
<td>
<p>(optional) a string the color of the plot, default=&quot;green&quot;.</p>
</td></tr>
<tr><td><code id="plot-TdistributionH_+3A_border">border</code></td>
<td>
<p>(optional) a string the color of the border of the plot, default=&quot;black&quot;.</p>
</td></tr>
</table>

<hr>
<h2 id='plotPredVsObs'>A function for comparing observed vs predicted histograms</h2><span id='topic+plotPredVsObs'></span>

<h3>Description</h3>

<p>This function allows the representation of observed vs predicted histograms. It can
be used as a tool for interpreting preditive methods (for exampe, the regression of histogrma data)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotPredVsObs(PRED, OBS, type = "HISTO", ncolu = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotPredVsObs_+3A_pred">PRED</code></td>
<td>
<p>a <code>MatH</code> object with one column, the predicted data</p>
</td></tr>
<tr><td><code id="plotPredVsObs_+3A_obs">OBS</code></td>
<td>
<p>a <code>MatH</code> object with one column, the observed data</p>
</td></tr>
<tr><td><code id="plotPredVsObs_+3A_type">type</code></td>
<td>
<p>a string. &quot;HISTO&quot; (default), if ones want to compare histograms<br />
&quot;CDF&quot;, if ones want to compare cumulative distribution functions;<br />
&quot;DENS&quot; if ones want to compare approximated densities (using KDE);<br /></p>
</td></tr>
<tr><td><code id="plotPredVsObs_+3A_ncolu">ncolu</code></td>
<td>
<p>number of columns in which is arranged the plot, default is 2. If you have a lot of data consider
to choose higher values.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plot with compared histogram-valued data.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## do a regression
pars &lt;- WH.regression.two.components(BLOOD, Yvar = 1, Xvars = c(2:3))
## predict data
PRED &lt;- WH.regression.two.components.predict(data = BLOOD[, 2:3], parameters = pars)
## define observed data
## Not run: 
OBS &lt;- BLOOD[, 1]
plotPredVsObs(PRED, OBS, "HISTO")
plotPredVsObs(PRED, OBS, "CDF")
plotPredVsObs(PRED, OBS, "DENS")

## End(Not run)
</code></pre>

<hr>
<h2 id='register'>Method <code>register</code></h2><span id='topic+register'></span><span id='topic+register+2CdistributionH+2CdistributionH-method'></span><span id='topic+register+2CdistributionH-method'></span>

<h3>Description</h3>

<p>Given two <code>distributionH</code> objects, it returns two equivalent distributions such that
they share the same cdf values. This function is useful for computing basic statistics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>register(object1, object2)

## S4 method for signature 'distributionH,distributionH'
register(object1, object2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="register_+3A_object1">object1</code></td>
<td>
<p>A <code>distributionH</code> object</p>
</td></tr>
<tr><td><code id="register_+3A_object2">object2</code></td>
<td>
<p>A <code>distributionH</code> object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The two <code>distributionH</code> objects in input sharing the same cdf (the <code>p</code>
slot)
</p>


<h3>Author(s)</h3>

<p>Antonio Irpino
</p>


<h3>References</h3>

<p>Irpino, A., Lechevallier, Y. and Verde, R. (2006): <em>Dynamic
clustering of histograms using Wasserstein metric</em> In: Rizzi, A., Vichi, M.
(eds.) COMPSTAT 2006. Physica-Verlag, Berlin, 869-876.<br /> Irpino, A.,Verde,
R. (2006): <em>A new Wasserstein based distance for the hierarchical
clustering of histogram symbolic data</em> In: Batanjeli, V., Bock, H.H.,
Ferligoj, A., Ziberna, A. (eds.) Data Science and Classification, IFCS 2006.
Springer, Berlin, 185-192.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## ---- initialize two distributionH objects mydist1 and mydist2
mydist1 &lt;- distributionH(c(1, 2, 3), c(0, 0.4, 1))
mydist2 &lt;- distributionH(c(7, 8, 10, 15), c(0, 0.2, 0.7, 1))
## register the two distributions
regDist &lt;- register(mydist1, mydist2)

## OUTPUT:
## regDist$[[1]]
## An object of class "distributionH"
## Slot "x": [1] 1.0 1.5 2.0 2.5 3.0
## Slot "p": [1] 0.0 0.2 0.4 0.7 1.0
## ...
## regDist$[[2]]
## An object of class "distributionH"
## Slot "x": [1] 7.0 8.0 8.8 10.0 15.0
## Slot "p": [1] 0.0 0.2 0.4  0.7  1.0
## ...
# The REGISTER function ----
</code></pre>

<hr>
<h2 id='registerMH'>Method registerMH</h2><span id='topic+registerMH'></span><span id='topic+registerMH+2CMatH-method'></span>

<h3>Description</h3>

<p><code>registerMH</code> method registers a set of distributions of a <code>MatH</code> object
All the
distribution are recomputed to obtain distributions sharing the same
<code>p</code> slot. This methods is useful for using fast computation of all
methods based on L2 Wasserstein metric. The distributions will have the same
number of element in the <code>x</code> slot without modifing their density
function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>registerMH(object)

## S4 method for signature 'MatH'
registerMH(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="registerMH_+3A_object">object</code></td>
<td>
<p>A <code>MatH</code> object (a matrix of distributions)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>MatH</code> object, a matrix of distributions sharing the same
<code>p</code> slot (i.e. the same cdf).
</p>


<h3>Author(s)</h3>

<p>Antonio Irpino
</p>


<h3>References</h3>

<p>Irpino, A., Lechevallier, Y. and Verde, R. (2006): <em>Dynamic
clustering of histograms using Wasserstein metric</em> In: Rizzi, A., Vichi, M.
(eds.) COMPSTAT 2006. Physica-Verlag, Berlin, 869-876.<br /> Irpino, A.,Verde,
R. (2006): <em>A new Wasserstein based distance for the hierarchical
clustering of histogram symbolic data</em> In: Batanjeli, V., Bock, H.H.,
Ferligoj, A., Ziberna, A. (eds.) Data Science and Classification, IFCS 2006.
Springer, Berlin, 185-192.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># initialize three distributionH objects mydist1 and mydist2
mydist1 &lt;- new("distributionH", c(1, 2, 3), c(0, 0.4, 1))
mydist2 &lt;- new("distributionH", c(7, 8, 10, 15), c(0, 0.2, 0.7, 1))
mydist3 &lt;- new("distributionH", c(9, 11, 20), c(0, 0.8, 1))
# create a MatH object

MyMAT &lt;- new("MatH", nrows = 1, ncols = 3, ListOfDist = c(mydist1, mydist2, mydist3), 1, 3)
# register the two distributions
MATregistered &lt;- registerMH(MyMAT)
#
# OUTPUT the structure of MATregstered
str(MATregistered)
#   Formal class 'MatH' [package "HistDAWass"] with 1 slots
#   .. @ M:List of 3
#   .. ..$ :Formal class 'distributionH' [package "HistDAWass"] with 4 slots
#   .. .. .. ..@ x: num [1:6] 1 1.5 2 2.5 2.67 ...
#   .. .. .. ..@ p: num [1:6] 0 0.2 0.4 0.7 0.8 1
#   ...
#   .. ..$ :Formal class 'distributionH' [package "HistDAWass"] with 4 slots
#   .. .. .. ..@ x: num [1:6] 7 8 8.8 10 11.7 ...
#   .. .. .. ..@ p: num [1:6] 0 0.2 0.4 0.7 0.8 1
#   ...
#   .. ..$ :Formal class 'distributionH' [package "HistDAWass"] with 4 slots
#   .. .. .. ..@ x: num [1:6] 9 9.5 10 10.8 11 ...
#   .. .. .. ..@ p: num [1:6] 0 0.2 0.4 0.7 0.8 1
#   ...
#   .. ..- attr(*, "dim")= int [1:2] 1 3
#   .. ..- attr(*, "dimnames")=List of 2
#   .. .. ..$ : chr "I1"
#   .. .. ..$ : chr [1:3] "X1" "X2" "X3"
#
</code></pre>

<hr>
<h2 id='RetHTS'>A histogram-valued dataset of returns</h2><span id='topic+RetHTS'></span>

<h3>Description</h3>

<p>A histogram-valued dataset of returns of dollar vs yen change rates
</p>


<h3>Format</h3>

<p>a <code>MatH</code> object, a matrix of distributions.
</p>


<h3>Author(s)</h3>

<p>Antonio Irpino, 2014-10-05
</p>

<hr>
<h2 id='rQQ'>Method <code>rQQ</code></h2><span id='topic+rQQ'></span><span id='topic+rQQ+2CdistributionH+2CdistributionH-method'></span><span id='topic+rQQ+2CdistributionH-method'></span>

<h3>Description</h3>

<p>Quantile-Quantile correlation between two distributions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rQQ(e1, e2)

## S4 method for signature 'distributionH,distributionH'
rQQ(e1, e2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rQQ_+3A_e1">e1</code></td>
<td>
<p>A <code>distributionH</code> object</p>
</td></tr>
<tr><td><code id="rQQ_+3A_e2">e2</code></td>
<td>
<p>A <code>distributionH</code> object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Pearson correlation index between quantiles
</p>


<h3>Author(s)</h3>

<p>Antonio Irpino
</p>


<h3>References</h3>

<p>Irpino, A., Verde, R. (2015) <em>Basic
statistics for distributional symbolic variables: a new metric-based
approach</em> Advances in Data Analysis and Classification, DOI 10.1007/s11634-014-0176-4
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## ---- initialize two distributionH object mydist1 and mydist2
mydist1 &lt;- distributionH(x = c(1, 2, 3), p = c(0, 0.4, 1))
mydist2 &lt;- distributionH(x = c(7, 8, 10, 15), p = c(0, 0.2, 0.7, 1))
## computes the rQQ
rQQ(mydist1, mydist2)
## OUTPUT 0.916894
</code></pre>

<hr>
<h2 id='set.cell.MatH'>Method set.cell.MatH assign a histogram to a cell of a matrix of histograms</h2><span id='topic+set.cell.MatH'></span><span id='topic+set.cell.MatH+2CdistributionH+2CMatH+2Cnumeric+2Cnumeric-method'></span><span id='topic+set.cell.MatH+2CMatH-method'></span>

<h3>Description</h3>

<p>Assign a histogram data to the r-th row and the c-th column of a matrix of histograms.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set.cell.MatH(object, mat, r, c)

## S4 method for signature 'distributionH,MatH,numeric,numeric'
set.cell.MatH(object, mat, r, c)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="set.cell.MatH_+3A_object">object</code></td>
<td>
<p>a distributionH object, a matrix of distributions.</p>
</td></tr>
<tr><td><code id="set.cell.MatH_+3A_mat">mat</code></td>
<td>
<p>a MatH object, a matrix of distributions.</p>
</td></tr>
<tr><td><code id="set.cell.MatH_+3A_r">r</code></td>
<td>
<p>an integer, the row index.</p>
</td></tr>
<tr><td><code id="set.cell.MatH_+3A_c">c</code></td>
<td>
<p>an integer, the column index</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>MatH</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mydist &lt;- distributionH(x = c(0, 1, 2, 3, 4), p = c(0, 0.1, 0.6, 0.9, 1))
MAT &lt;- set.cell.MatH(mydist, BLOOD, r = 1, c = 1)
</code></pre>

<hr>
<h2 id='ShortestDistance'>Shortes distance from a point o a 2d segment</h2><span id='topic+ShortestDistance'></span>

<h3>Description</h3>

<p>Shortes distance from a point o a 2d segment
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ShortestDistance(p, line)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ShortestDistance_+3A_p">p</code></td>
<td>
<p>coordinates of a point</p>
</td></tr>
<tr><td><code id="ShortestDistance_+3A_line">line</code></td>
<td>
<p>a 2x2 matrix with the coordinates of two points defining a line</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric value, the Euclidean distance of point <code>p</code> to the <code>line</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+data2hist">data2hist</a></code> function and <code><a href="#topic+DouglasPeucker">DouglasPeucker</a></code> function
</p>

<hr>
<h2 id='show'>Method show for distributionH</h2><span id='topic+show'></span><span id='topic+show+2CdistributionH-method'></span>

<h3>Description</h3>

<p>An overriding show function for a <code>distributionH</code> object. The function returns a representation
of the histogram, if the number of bins is high the central part of the histogram is truncated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'distributionH'
show(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="show_+3A_object">object</code></td>
<td>
<p>a <code>distributionH</code> object</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## ---- initialize a distributionH
mydist &lt;- distributionH(x = c(7, 8, 10, 15), p = c(0, 0.2, 0.7, 1))
# show the histogram
mydist
</code></pre>

<hr>
<h2 id='show-MatH'>Method show for MatH</h2><span id='topic+show-MatH'></span><span id='topic+show+2CMatH-method'></span>

<h3>Description</h3>

<p>An overriding show method for a <code>MatH</code> object. The method returns a representation
of the matrix using the mean and the standard deviation for each histogram.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'MatH'
show(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="show-MatH_+3A_object">object</code></td>
<td>
<p>a <code>MatH</code> object</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>show(BLOOD)
print(BLOOD)
BLOOD
</code></pre>

<hr>
<h2 id='skewH'>Method <code>skewH</code>: computes the skewness of a distribution</h2><span id='topic+skewH'></span><span id='topic+skewH+2CdistributionH-method'></span>

<h3>Description</h3>

<p>Skewness of a histogram (using the third standardized moment)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>skewH(object)

## S4 method for signature 'distributionH'
skewH(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="skewH_+3A_object">object</code></td>
<td>
<p>a <code>distributionH</code> object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A value for the skewness index
</p>


<h3>Author(s)</h3>

<p>Antonio Irpino
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## ---- A mydist distribution ----
mydist &lt;- distributionH(x = c(1, 2, 3, 10), p = c(0, 0.1, 0.5, 1))
## ---- Compute the skewness of mydist ----
skewH(mydist) #---&gt; -1.186017
</code></pre>

<hr>
<h2 id='stations_coordinates'>Stations coordinates of China_Month and China_Seas datasets</h2><span id='topic+stations_coordinates'></span>

<h3>Description</h3>

<p>A dataset containing the geographical coordinates of stations described in China_Month and China_Seas datasets
</p>


<h3>Format</h3>

<p>a data.frame
</p>


<h3>Author(s)</h3>

<p>Antonio Irpino, 2014-10-05
</p>


<h3>Source</h3>

<p>raw data are available here: <a href="https://data.ess-dive.lbl.gov/view/doi:10.3334/CDIAC/CLI.TR055">https://data.ess-dive.lbl.gov/view/doi:10.3334/CDIAC/CLI.TR055</a>.
Climate Data Bases of the People's Republic of China 1841-1988 (TR055)
DOI: 10.3334/CDIAC/cli.tr055
</p>

<hr>
<h2 id='stdH'>Method <code>stdH</code>: computes the standard deviation of a distribution</h2><span id='topic+stdH'></span><span id='topic+stdH+2CdistributionH-method'></span>

<h3>Description</h3>

<p>Standard deviation of a histogram (i.e., the square root of the centered
second moment)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stdH(object)

## S4 method for signature 'distributionH'
stdH(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stdH_+3A_object">object</code></td>
<td>
<p>a <code>distributionH</code> object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A value for the standard deviation
</p>


<h3>Author(s)</h3>

<p>Antonio Irpino
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## ---- A mydist distribution ----
mydist &lt;- distributionH(x = c(1, 2, 3, 10), p = c(0, 0.1, 0.5, 1))
## ---- Compute the standard deviation of mydist ----
stdH(mydist) #---&gt; 2.563851
</code></pre>

<hr>
<h2 id='subsetHTS'>Method <code>subsetHTS</code>: extract a subset of a histogram time series</h2><span id='topic+subsetHTS'></span><span id='topic+subsetHTS+2CHTS+2Cnumeric+2Cnumeric-method'></span>

<h3>Description</h3>

<p>This functon return the mean of a <code>distributionH</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>subsetHTS(object, from, to)

## S4 method for signature 'HTS,numeric,numeric'
subsetHTS(object, from, to)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="subsetHTS_+3A_object">object</code></td>
<td>
<p>a <code>HTS</code> object. A histogram 1d time series</p>
</td></tr>
<tr><td><code id="subsetHTS_+3A_from">from</code></td>
<td>
<p>an integer, the initioal timepont</p>
</td></tr>
<tr><td><code id="subsetHTS_+3A_to">to</code></td>
<td>
<p>an integer, a final timepoint</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>HTS</code> object. A histogram 1d time series
</p>


<h3>Examples</h3>

<pre><code class='language-R'>SUB_RetHTS &lt;- subsetHTS(RetHTS, from = 1, to = 20) # the first 20 elements
</code></pre>

<hr>
<h2 id='summaryHTS'>A function for summarize HTS</h2><span id='topic+summaryHTS'></span>

<h3>Description</h3>

<p>A summarizer for HTS
</p>


<h3>Usage</h3>

<pre><code class='language-R'>summaryHTS(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summaryHTS_+3A_x">x</code></td>
<td>
<p>a HTS</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with basic statistics.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>summaryHTS(subsetHTS(RetHTS, from = 1, to = 10))
</code></pre>

<hr>
<h2 id='TdistributionH-class'>Class TdistributionH</h2><span id='topic+TdistributionH-class'></span><span id='topic+TdistributionH'></span><span id='topic+initialize+2CTdistributionH-method'></span>

<h3>Description</h3>

<p>Class <code>TdistributionH</code> defines a histogram with a time (point or period)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'TdistributionH'
initialize(
  .Object,
  tstamp = numeric(0),
  period = list(start = -Inf, end = -Inf),
  x = numeric(0),
  p = numeric(0),
  m = numeric(0),
  s = numeric(0)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="TdistributionH-class_+3A_.object">.Object</code></td>
<td>
<p>the type of object (&quot;TdistributionH&quot;) a <code>"distributionH"</code> object with a time reference</p>
</td></tr>
<tr><td><code id="TdistributionH-class_+3A_tstamp">tstamp</code></td>
<td>
<p>a numeric value related to  a timestamp</p>
</td></tr>
<tr><td><code id="TdistributionH-class_+3A_period">period</code></td>
<td>
<p>a list of two values, the starting time and the ending time (alternative to tstamp if the
distribution is observed along a period and not on a timestamp)</p>
</td></tr>
<tr><td><code id="TdistributionH-class_+3A_x">x</code></td>
<td>
<p>a vector of increasing values, the domain of the distribution (the same of <code>distributionH</code> object)</p>
</td></tr>
<tr><td><code id="TdistributionH-class_+3A_p">p</code></td>
<td>
<p>a vector of increasing values from 0 to 1,
the CDF of the distribution (the same of <code>distributionH</code> object)</p>
</td></tr>
<tr><td><code id="TdistributionH-class_+3A_m">m</code></td>
<td>
<p>a number, the mean of the distribution (the same of <code>distributionH</code> object)</p>
</td></tr>
<tr><td><code id="TdistributionH-class_+3A_s">s</code></td>
<td>
<p>a positive number, the standard deviation of the distribution (the same of <code>distributionH</code> object)</p>
</td></tr>
</table>

<hr>
<h2 id='TMatH-class'>Class TMatH</h2><span id='topic+TMatH-class'></span><span id='topic+TMatH'></span><span id='topic+initialize+2CTMatH-method'></span>

<h3>Description</h3>

<p>Class <code>TMatH</code> defines a matrix of histograms, a <code>TMatH</code> object, with a time (a timepoint or a time window).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'TMatH'
initialize(
  .Object,
  tstamp = numeric(0),
  period = list(start = -Inf, end = -Inf),
  mat = new("MatH")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="TMatH-class_+3A_.object">.Object</code></td>
<td>
<p>the type of object (&quot;TMatH&quot;)</p>
</td></tr>
<tr><td><code id="TMatH-class_+3A_tstamp">tstamp</code></td>
<td>
<p>a vector of time stamps, numeric.</p>
</td></tr>
<tr><td><code id="TMatH-class_+3A_period">period</code></td>
<td>
<p>a list of pairs with a vectorof starting time and a vector ofending time.
This parameter is used alternatively to <code>tstamp</code> if the distributions are related to time periods
instead of timestamps</p>
</td></tr>
<tr><td><code id="TMatH-class_+3A_mat">mat</code></td>
<td>
<p>a <code>MatH</code> object</p>
</td></tr>
</table>

<hr>
<h2 id='WassSqDistH'>Method <code>WassSqDistH</code></h2><span id='topic+WassSqDistH'></span><span id='topic+WassSqDistH+2CdistributionH+2CdistributionH-method'></span><span id='topic+WassSqDistH+2CdistributionH-method'></span>

<h3>Description</h3>

<p>Computes the squared L2 Wasserstein distance between two <code>distributionH</code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>WassSqDistH(object1, object2, ...)

## S4 method for signature 'distributionH,distributionH'
WassSqDistH(object1 = object1, object2 = object2, details = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="WassSqDistH_+3A_object1">object1</code></td>
<td>
<p>is an object of <span class="env">distributionH</span> class</p>
</td></tr>
<tr><td><code id="WassSqDistH_+3A_object2">object2</code></td>
<td>
<p>is an object of <span class="env">distributionH</span> class</p>
</td></tr>
<tr><td><code id="WassSqDistH_+3A_...">...</code></td>
<td>
<p>optional parameters</p>
</td></tr>
<tr><td><code id="WassSqDistH_+3A_details">details</code></td>
<td>
<p>(optional, default=FALSE) is a logical value, if TRUE returns the decomposition of the distance</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>details=FALSE</code>, the function returns the squared L2 Wasserstein distance.<br />
If <code>details=TRUE</code>, the function returns list containing the squared distance, its
decomposition in three parts (position, size and shape) and the correlation coefficient between the quantile functions.
</p>


<h3>References</h3>

<p>Irpino, A. and Romano, E. (2007): <em>Optimal histogram representation of large data sets:
Fisher vs piecewise linear approximations</em>. RNTI E-9, 99-110.<br />
Irpino, A., Verde, R. (2015) <em>Basic
statistics for distributional symbolic variables: a new metric-based
approach</em> Advances in Data Analysis and Classification, DOI 10.1007/s11634-014-0176-4
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## ---- create two distributionH objects ----
mydist1 &lt;- distributionH(x = c(1, 2, 3), p = c(0, 0.4, 1))
mydist2 &lt;- distributionH(x = c(7, 8, 10, 15), p = c(0, 0.2, 0.7, 1))
# -- compute the squared L2 Waaserstein distance
WassSqDistH(mydist1, mydist2)
# -- compute the squared L2 Waaserstein distance with details
WassSqDistH(mydist1, mydist2, details = TRUE)
</code></pre>

<hr>
<h2 id='WH_2d_Adaptive_Kohonen_maps'>Batch Kohonen self-organizing 2d maps using adaptive distances for  histogram-valued data</h2><span id='topic+WH_2d_Adaptive_Kohonen_maps'></span>

<h3>Description</h3>

<p>The function implements a Batch Kohonen self-organizing 2d maps algorithm for  histogram-valued data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>WH_2d_Adaptive_Kohonen_maps(
  x,
  net = list(xdim = 4, ydim = 3, topo = c("rectangular")),
  kern.param = 2,
  TMAX = -9999,
  Tmin = -9999,
  niter = 30,
  repetitions,
  simplify = FALSE,
  qua = 10,
  standardize = FALSE,
  schema = 6,
  init.weights = "EQUAL",
  weight.sys = "PROD",
  theta = 2,
  Wfix = FALSE,
  verbose = FALSE,
  atleast = 2
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="WH_2d_Adaptive_Kohonen_maps_+3A_x">x</code></td>
<td>
<p>A MatH object (a matrix of distributionH).</p>
</td></tr>
<tr><td><code id="WH_2d_Adaptive_Kohonen_maps_+3A_net">net</code></td>
<td>
<p>a list describing the topology of the net <code>list(xdim=number of rows,
ydim=numbers of columns,topo=c('rectangular' or 'hexagonal'))</code>, see <code>somgrid</code> sintax in package<span class="pkg">class</span>
default <code>net=list(xdim=4,ydim=3,topo=c('rectangular'))</code></p>
</td></tr>
<tr><td><code id="WH_2d_Adaptive_Kohonen_maps_+3A_kern.param">kern.param</code></td>
<td>
<p>(default =2) the kernel parameter for the RBF kernel used in the algorithm</p>
</td></tr>
<tr><td><code id="WH_2d_Adaptive_Kohonen_maps_+3A_tmax">TMAX</code></td>
<td>
<p>a parameter useful for the iterations (default=2)</p>
</td></tr>
<tr><td><code id="WH_2d_Adaptive_Kohonen_maps_+3A_tmin">Tmin</code></td>
<td>
<p>a parameter useful for the iterations (default=0.2)</p>
</td></tr>
<tr><td><code id="WH_2d_Adaptive_Kohonen_maps_+3A_niter">niter</code></td>
<td>
<p>maximum number of iterations (default=30)</p>
</td></tr>
<tr><td><code id="WH_2d_Adaptive_Kohonen_maps_+3A_repetitions">repetitions</code></td>
<td>
<p>number of repetion of the algorithm (default=5), beacuase each launch may generate a local optimum</p>
</td></tr>
<tr><td><code id="WH_2d_Adaptive_Kohonen_maps_+3A_simplify">simplify</code></td>
<td>
<p>a logical parameter for speeding up computations (default=FALSE). If true data are recoded in order to have fast computations</p>
</td></tr>
<tr><td><code id="WH_2d_Adaptive_Kohonen_maps_+3A_qua">qua</code></td>
<td>
<p>if <code>simplify=TRUE</code> number of equally spaced quantiles for recodify the histograms (default=10)</p>
</td></tr>
<tr><td><code id="WH_2d_Adaptive_Kohonen_maps_+3A_standardize">standardize</code></td>
<td>
<p>A logic value (default is FALSE). If TRUE, histogram-valued data are standardized,  variable by variable,
using the Wassertein based standard deviation. Use if one wants to have variables with std equal to one.</p>
</td></tr>
<tr><td><code id="WH_2d_Adaptive_Kohonen_maps_+3A_schema">schema</code></td>
<td>
<p>a number from 1 to 4 <br />
1=A weight for each variable (default) <br />
2=A weight for the average and the dispersion component of each variable<br />
3=Same as 1 but a different set of weights for each cluster<br />
4=Same as 2 but a different set of weights for each cluster</p>
</td></tr>
<tr><td><code id="WH_2d_Adaptive_Kohonen_maps_+3A_init.weights">init.weights</code></td>
<td>
<p>a string how to initialize weights: 'EQUAL' (default), all weights are the same,</p>
</td></tr>
<tr><td><code id="WH_2d_Adaptive_Kohonen_maps_+3A_weight.sys">weight.sys</code></td>
<td>
<p>a string. Weights may add to one ('SUM') or their product is equal to 1 ('PROD', default).</p>
</td></tr>
<tr><td><code id="WH_2d_Adaptive_Kohonen_maps_+3A_theta">theta</code></td>
<td>
<p>a number. A parameter if <code>weight.sys='SUM'</code>, default is 2.</p>
</td></tr>
<tr><td><code id="WH_2d_Adaptive_Kohonen_maps_+3A_wfix">Wfix</code></td>
<td>
<p>a logical parameter (default=FALSE). If TRUE the algorithm does not use adaptive distances.</p>
</td></tr>
<tr><td><code id="WH_2d_Adaptive_Kohonen_maps_+3A_verbose">verbose</code></td>
<td>
<p>a logical parameter (default=FALSE). If TRUE details of
computation are shown during the execution.
#'</p>
</td></tr>
<tr><td><code id="WH_2d_Adaptive_Kohonen_maps_+3A_atleast">atleast</code></td>
<td>
<p>integer. Check for degeneration of the map into a very low number of
voronoi sets. (default 2) 2 means that the map will have at least 2 neurons
attracting data instances in their voronoi sets.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>An extension of Batch Self Organised Map (BSOM) is here proposed for  histogram data.
These kind of data have been defined in the context of symbolic data analysis.
The BSOM cost function is then based on a distance
function: the L2 Wasserstein distance. This distance has been widely proposed in several
techniques of analysis (clustering, regression) when input data are expressed by distributions
(empirical by histograms or theoretical by probability distributions).
The peculiarity of such distance is to be an Euclidean distance between quantile functions so
that all the properties proved for L2 distances are verified again. An adaptative versions of
BSOM is also introduced considering an automatic system of weights in the cost function in
order to take into account the different effect of the several variables in the Self-Organised Map
grid.
</p>


<h3>Value</h3>

<p>a list with the results of the Batch Kohonen map
</p>


<h3>Slots</h3>


<dl>
<dt><code>solution</code></dt><dd><p>A list.Returns the best solution among the <code>repetitions</code>etitions, i.e.
the one having the minimum sum of squares criterion.</p>
</dd>
<dt><code>solution$MAP</code></dt><dd><p>The map topology.</p>
</dd>
<dt><code>solution$IDX</code></dt><dd><p>A vector. The clusters at which the objects are assigned.</p>
</dd>
<dt><code>solution$cardinality</code></dt><dd><p>A vector. The cardinality of each final cluster.</p>
</dd>
<dt><code>solution$proto</code></dt><dd><p>A <code>MatH</code> object with the description of centers.</p>
</dd>
<dt><code>solution$Crit</code></dt><dd><p>A number. The criterion (Sum od square deviation
from the centers) value at the end of the run.</p>
</dd>
<dt><code>solution$Weights.comp</code></dt><dd><p>the final weights assigned to each component of the histogram variables</p>
</dd>
<dt><code>solution$Weight.sys</code></dt><dd><p>a string the type of weighting system ('SUM' or 'PRODUCT')</p>
</dd>
<dt><code>quality</code></dt><dd><p>A number. The percentage of Sum of square deviation explained by the model.
(The higher the better)</p>
</dd>
</dl>


<h3>References</h3>

<p>Irpino A, Verde R, De Carvalho FAT (2012). Batch self organizing maps for interval and histogram data.
In: Proceedings of COMPSTAT 2012. p. 143-154, ISI/IASC, ISBN: 978-90-73592-32-2
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
results &lt;- WH_2d_Adaptive_Kohonen_maps(
  x = BLOOD,
  net = list(xdim = 2, ydim = 3, topo = c("rectangular")),
  repetitions = 2, simplify = TRUE,
  qua = 10, standardize = TRUE
)

## End(Not run)
</code></pre>

<hr>
<h2 id='WH_2d_Kohonen_maps'>Batch Kohonen self-organizing 2d maps for  histogram-valued data</h2><span id='topic+WH_2d_Kohonen_maps'></span>

<h3>Description</h3>

<p>The function implements a Batch Kohonen self-organizing 2d maps algorithm for  histogram-valued data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>WH_2d_Kohonen_maps(
  x,
  net = list(xdim = 4, ydim = 3, topo = c("rectangular")),
  kern.param = 2,
  TMAX = 2,
  Tmin = 0.2,
  niter = 30,
  repetitions = 5,
  simplify = FALSE,
  qua = 10,
  standardize = FALSE,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="WH_2d_Kohonen_maps_+3A_x">x</code></td>
<td>
<p>A MatH object (a matrix of distributionH).</p>
</td></tr>
<tr><td><code id="WH_2d_Kohonen_maps_+3A_net">net</code></td>
<td>
<p>a list describing the topology of the net <code>list(xdim=number of rows,
ydim=numbers of columns,topo=c('rectangular' or 'hexagonal'))</code>, see <code>somgrid</code> sintax in package<span class="pkg">class</span>
default <code>net=list(xdim=4,ydim=3,topo=c('rectangular'))</code></p>
</td></tr>
<tr><td><code id="WH_2d_Kohonen_maps_+3A_kern.param">kern.param</code></td>
<td>
<p>(default =2) the kernel parameter for the RBF kernel used in the algorithm</p>
</td></tr>
<tr><td><code id="WH_2d_Kohonen_maps_+3A_tmax">TMAX</code></td>
<td>
<p>a parameter useful for the iterations (default=2)</p>
</td></tr>
<tr><td><code id="WH_2d_Kohonen_maps_+3A_tmin">Tmin</code></td>
<td>
<p>a parameter useful for the iterations (default=0.2)</p>
</td></tr>
<tr><td><code id="WH_2d_Kohonen_maps_+3A_niter">niter</code></td>
<td>
<p>maximum number of iterations (default=30)</p>
</td></tr>
<tr><td><code id="WH_2d_Kohonen_maps_+3A_repetitions">repetitions</code></td>
<td>
<p>number of repetion of the algorithm (default=5), beacuase each launch may generate a local optimum</p>
</td></tr>
<tr><td><code id="WH_2d_Kohonen_maps_+3A_simplify">simplify</code></td>
<td>
<p>a logical parameter for speeding up computations (default=FALSE). If true data are recoded in order to have fast computations</p>
</td></tr>
<tr><td><code id="WH_2d_Kohonen_maps_+3A_qua">qua</code></td>
<td>
<p>if <code>simplify=TRUE</code> number of equally spaced quantiles for recodify the histograms (default=10)</p>
</td></tr>
<tr><td><code id="WH_2d_Kohonen_maps_+3A_standardize">standardize</code></td>
<td>
<p>A logic value (default is FALSE). If TRUE, histogram-valued data are standardized,  variable by variable,
using the Wassertein based standard deviation. Use if one wants to have variables with std equal to one.</p>
</td></tr>
<tr><td><code id="WH_2d_Kohonen_maps_+3A_verbose">verbose</code></td>
<td>
<p>a logical parameter (default=FALSE). If TRUE details of
computation are shown during the execution.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>An extension of Batch Self Organised Map (BSOM) is here proposed for  histogram data.
These kind of data have been defined in the context of symbolic data analysis.
The BSOM cost function is then based on a distance
function: the L2 Wasserstein distance. This distance has been widely proposed in several
techniques of analysis (clustering, regression) when input data are expressed by distributions
(empirical by histograms or theoretical by probability distributions).
The peculiarity of such distance is to be an Euclidean distance between quantile functions so
that all the properties proved for L2 distances are verified again. An adaptative versions of
BSOM is also introduced considering an automatic system of weights in the cost function in
order to take into account the different effect of the several variables in the Self-Organised Map
grid.
</p>


<h3>Value</h3>

<p>a list with the results of the Batch Kohonen map
</p>


<h3>Slots</h3>


<dl>
<dt><code>solution</code></dt><dd><p>A list.Returns the best solution among the <code>repetitions</code>etitions, i.e.
the one having the minimum sum of squares criterion.</p>
</dd>
<dt><code>solution$MAP</code></dt><dd><p>The map topology.</p>
</dd>
<dt><code>solution$IDX</code></dt><dd><p>A vector. The clusters at which the objects are assigned.</p>
</dd>
<dt><code>solution$cardinality</code></dt><dd><p>A vector. The cardinality of each final cluster.</p>
</dd>
<dt><code>solution$proto</code></dt><dd><p>A <code>MatH</code> object with the description of centers.</p>
</dd>
<dt><code>solution$Crit</code></dt><dd><p>A number. The criterion (Sum od square deviation
from the centers) value at the end of the run.</p>
</dd>
<dt><code>quality</code></dt><dd><p>A number. The percentage of Sum of square deviation explained by the model.
(The higher the better)</p>
</dd>
</dl>


<h3>References</h3>

<p>Irpino A, Verde R, De Carvalho FAT (2012). Batch self organizing maps for interval and histogram data.
In: Proceedings of COMPSTAT 2012. p. 143-154, ISI/IASC, ISBN: 978-90-73592-32-2
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
results &lt;- WH_2d_Kohonen_maps(
  x = BLOOD,
  net = list(xdim = 2, ydim = 3, topo = c("rectangular")),
  repetitions = 2, simplify = TRUE,
  qua = 10, standardize = TRUE
)

## End(Not run)
</code></pre>

<hr>
<h2 id='WH_adaptive_fcmeans'>Fuzzy c-means with adaptive distances for histogram-valued data</h2><span id='topic+WH_adaptive_fcmeans'></span>

<h3>Description</h3>

<p>Fuzzy c-means of a dataset of histogram-valued data using different adaptive distances based on the L2 Wasserstein metric.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>WH_adaptive_fcmeans(
  x,
  k = 5,
  schema,
  m = 1.6,
  rep,
  simplify = FALSE,
  qua = 10,
  standardize = FALSE,
  init.weights = "EQUAL",
  weight.sys = "PROD",
  theta = 2,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="WH_adaptive_fcmeans_+3A_x">x</code></td>
<td>
<p>A MatH object (a matrix of distributionH).</p>
</td></tr>
<tr><td><code id="WH_adaptive_fcmeans_+3A_k">k</code></td>
<td>
<p>An integer, the number of groups.</p>
</td></tr>
<tr><td><code id="WH_adaptive_fcmeans_+3A_schema">schema</code></td>
<td>
<p>An integer. 1=one weight per variable, 2=two weights per variables (one for each component: the mean and the variability component),
3=one weight per variable and per cluster, 4= two weights per variable and per cluster.</p>
</td></tr>
<tr><td><code id="WH_adaptive_fcmeans_+3A_m">m</code></td>
<td>
<p>A number grater than 0, a fuzziness coefficient (default <code>m</code>=1.6).</p>
</td></tr>
<tr><td><code id="WH_adaptive_fcmeans_+3A_rep">rep</code></td>
<td>
<p>An integer, maximum number of repetitions of the algorithm (default <code>rep</code>=5).</p>
</td></tr>
<tr><td><code id="WH_adaptive_fcmeans_+3A_simplify">simplify</code></td>
<td>
<p>A logic value (default is FALSE), if TRUE histograms are recomputed in order to speed-up the algorithm.</p>
</td></tr>
<tr><td><code id="WH_adaptive_fcmeans_+3A_qua">qua</code></td>
<td>
<p>An integer, if <code>simplify</code>=TRUE is the number of quantiles used for recodify the histograms.</p>
</td></tr>
<tr><td><code id="WH_adaptive_fcmeans_+3A_standardize">standardize</code></td>
<td>
<p>A logic value (default is FALSE). If TRUE, histogram-valued data are standardized,  variable by variable, using the Wassertein based standard deviation. Use if one wants to have variables with std equal to one.</p>
</td></tr>
<tr><td><code id="WH_adaptive_fcmeans_+3A_init.weights">init.weights</code></td>
<td>
<p>A string. (default='EQUAL'). EQUAL, all variables or components have the same weight; 'RANDOM', a random assignment is done.</p>
</td></tr>
<tr><td><code id="WH_adaptive_fcmeans_+3A_weight.sys">weight.sys</code></td>
<td>
<p>A string. (default='PROD') PROD, Weights product is equal to one. SUM, the weights sum up to one.</p>
</td></tr>
<tr><td><code id="WH_adaptive_fcmeans_+3A_theta">theta</code></td>
<td>
<p>A number. (default=2) A parameter for the system of weights summing up to one.</p>
</td></tr>
<tr><td><code id="WH_adaptive_fcmeans_+3A_verbose">verbose</code></td>
<td>
<p>A logic value (default is FALSE). If TRUE  some details are provided.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The results of the fuzzy c-means of the set of Histogram-valued data <code>x</code> into  <code>k</code> cluster.
</p>
<table>
<tr><td><code>solution</code></td>
<td>
<p>A list.Returns the best solution among the <code>rep</code>etitions, i.e. the ona having the minimum sum of squares deviation.</p>
</td></tr>
<tr><td><code>solution$membership</code></td>
<td>
<p>A matrix. The membership degree of each unit to each cluster.</p>
</td></tr>
<tr><td><code>solution$IDX</code></td>
<td>
<p>A vector. The crisp assignement to a cluster.</p>
</td></tr>
<tr><td><code>solution$cardinality</code></td>
<td>
<p>A vector. The cardinality of each final cluster (after the crisp assignement).</p>
</td></tr>
<tr><td><code>solution$Crit</code></td>
<td>
<p>A number. The criterion (Sum od square deviation from the prototypes) value at the end of the run.</p>
</td></tr>
<tr><td><code>quality</code></td>
<td>
<p>A number. The percentage of Sum of square deviation explained by the model. (The higher the better)</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>results &lt;- WH_adaptive_fcmeans(
  x = BLOOD, k = 2, schema = 4, m = 1.5, rep = 3, simplify = TRUE,
  qua = 10, standardize = TRUE, init.weights = "EQUAL", weight.sys = "PROD"
)
</code></pre>

<hr>
<h2 id='WH_adaptive.kmeans'>K-means of a dataset of histogram-valued data using adaptive  Wasserstein distances</h2><span id='topic+WH_adaptive.kmeans'></span>

<h3>Description</h3>

<p>The function implements the k-means using adaptive distance for a set of histogram-valued data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>WH_adaptive.kmeans(
  x,
  k,
  schema = 1,
  init,
  rep,
  simplify = FALSE,
  qua = 10,
  standardize = FALSE,
  weight.sys = "PROD",
  theta = 2,
  init.weights = "EQUAL",
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="WH_adaptive.kmeans_+3A_x">x</code></td>
<td>
<p>A MatH object (a matrix of distributionH).</p>
</td></tr>
<tr><td><code id="WH_adaptive.kmeans_+3A_k">k</code></td>
<td>
<p>An integer, the number of groups.</p>
</td></tr>
<tr><td><code id="WH_adaptive.kmeans_+3A_schema">schema</code></td>
<td>
<p>a number from 1 to 4 <br />
1=A weight for each variable (default) <br />
2=A weight for the average and the dispersion component of each variable<br />
3=Same as 1 but a different set of weights for each cluster<br />
4=Same as 2 but a different set of weights for each cluster</p>
</td></tr>
<tr><td><code id="WH_adaptive.kmeans_+3A_init">init</code></td>
<td>
<p>(optional, do not use) initialization for partitioning the data default is 'RPART', other strategies shoul be implemented.</p>
</td></tr>
<tr><td><code id="WH_adaptive.kmeans_+3A_rep">rep</code></td>
<td>
<p>An integer, maximum number of repetitions of the algorithm (default <code>rep</code>=5).</p>
</td></tr>
<tr><td><code id="WH_adaptive.kmeans_+3A_simplify">simplify</code></td>
<td>
<p>A logic value (default is FALSE), if TRUE histograms are recomputed in order to speed-up the algorithm.</p>
</td></tr>
<tr><td><code id="WH_adaptive.kmeans_+3A_qua">qua</code></td>
<td>
<p>An integer, if <code>simplify</code>=TRUE is the number of quantiles used for recodify the histograms.</p>
</td></tr>
<tr><td><code id="WH_adaptive.kmeans_+3A_standardize">standardize</code></td>
<td>
<p>A logic value (default is FALSE). If TRUE, histogram-valued data are standardized,  variable by variable,
using the Wassertein based standard deviation. Use if one wants to have variables with std equal to one.</p>
</td></tr>
<tr><td><code id="WH_adaptive.kmeans_+3A_weight.sys">weight.sys</code></td>
<td>
<p>a string. Weights may add to one ('SUM') or their product is equal to 1 ('PROD', default).</p>
</td></tr>
<tr><td><code id="WH_adaptive.kmeans_+3A_theta">theta</code></td>
<td>
<p>a number. A parameter if <code>weight.sys='SUM'</code>, default is 2.</p>
</td></tr>
<tr><td><code id="WH_adaptive.kmeans_+3A_init.weights">init.weights</code></td>
<td>
<p>a string how to initialize weights: 'EQUAL' (default), all weights are the same,
'RANDOM', weights are initalised at random.</p>
</td></tr>
<tr><td><code id="WH_adaptive.kmeans_+3A_verbose">verbose</code></td>
<td>
<p>A logic value (default is FALSE). If TRUE, details on computations are shown.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with the results of the k-means of the set of Histogram-valued data <code>x</code> into  <code>k</code> cluster.
</p>


<h3>Slots</h3>


<dl>
<dt><code>solution</code></dt><dd><p>A list.Returns the best solution among the <code>rep</code>etitions, i.e.
the one having the minimum sum of squares criterion.</p>
</dd>
<dt><code>solution$IDX</code></dt><dd><p>A vector. The clusters at which the objects are assigned.</p>
</dd>
<dt><code>solution$cardinality</code></dt><dd><p>A vector. The cardinality of each final cluster.</p>
</dd>
<dt><code>solution$centers</code></dt><dd><p>A <code>MatH</code> object with the description of centers.</p>
</dd>
<dt><code>solution$Crit</code></dt><dd><p>A number. The criterion (Sum od square deviation
from the centers) value at the end of the run.</p>
</dd>
<dt><code>quality</code></dt><dd><p>A number. The percentage of Sum of square deviation explained by the model.
(The higher the better)</p>
</dd>
</dl>


<h3>References</h3>

<p>Irpino A., Rosanna V., De Carvalho F.A.T. (2014). Dynamic clustering of histogram data
based on adaptive squared Wasserstein distances. EXPERT SYSTEMS WITH APPLICATIONS, vol. 41, p. 3351-3366,
ISSN: 0957-4174, doi: http://dx.doi.org/10.1016/j.eswa.2013.12.001
</p>


<h3>Examples</h3>

<pre><code class='language-R'>results &lt;- WH_adaptive.kmeans(x = BLOOD, k = 2, rep = 10, 
            simplify = TRUE, qua = 10, standardize = TRUE)
</code></pre>

<hr>
<h2 id='WH_fcmeans'>Fuzzy c-means of a dataset of histogram-valued data</h2><span id='topic+WH_fcmeans'></span>

<h3>Description</h3>

<p>The function implements the fuzzy c-means for a set of histogram-valued data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>WH_fcmeans(x, k, m = 1.6, rep, simplify = FALSE, qua = 10, standardize = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="WH_fcmeans_+3A_x">x</code></td>
<td>
<p>A MatH object (a matrix of distributionH).</p>
</td></tr>
<tr><td><code id="WH_fcmeans_+3A_k">k</code></td>
<td>
<p>An integer, the number of groups.</p>
</td></tr>
<tr><td><code id="WH_fcmeans_+3A_m">m</code></td>
<td>
<p>A number grater than 0, a fuzziness coefficient (default <code>m</code>=1.6).</p>
</td></tr>
<tr><td><code id="WH_fcmeans_+3A_rep">rep</code></td>
<td>
<p>An integer, maximum number of repetitions of the algorithm (default <code>rep</code>=5).</p>
</td></tr>
<tr><td><code id="WH_fcmeans_+3A_simplify">simplify</code></td>
<td>
<p>A logic value (default is FALSE), if TRUE histograms are recomputed in order to speed-up the algorithm.</p>
</td></tr>
<tr><td><code id="WH_fcmeans_+3A_qua">qua</code></td>
<td>
<p>An integer, if <code>simplify</code>=TRUE is the number of quantiles used for recodify the histograms.</p>
</td></tr>
<tr><td><code id="WH_fcmeans_+3A_standardize">standardize</code></td>
<td>
<p>A logic value (default is FALSE). If TRUE, histogram-valued data are standardized,  variable by variable, using the Wassertein based standard deviation. Use if one wants to have variables with std equal to one.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with the results of the fuzzy c-means of the set of Histogram-valued data <code>x</code> into  <code>k</code> cluster.
</p>


<h3>Slots</h3>


<dl>
<dt><code>solution</code></dt><dd><p>A list.Returns the best solution among the <code>rep</code>etitions, i.e.
the one having the minimum sum of squares deviation.</p>
</dd>
<dt><code>solution$membership</code></dt><dd><p>A matrix. The membership degree of each unit to each cluster.</p>
</dd>
<dt><code>solution$IDX</code></dt><dd><p>A vector. The crisp assignement to a cluster.</p>
</dd>
<dt><code>solution$cardinality</code></dt><dd><p>A vector. The cardinality of each final cluster (after the crisp assignement).</p>
</dd>
<dt><code>solution$Crit</code></dt><dd><p>A number. The criterion (Sum of square deviation
from the prototypes) value at the end of the run.</p>
</dd>
<dt><code>quality</code></dt><dd><p>A number. The percentage of Sum of square deviation explained by the model.
(The higher the better)</p>
</dd>
</dl>


<h3>Examples</h3>

<pre><code class='language-R'>results &lt;- WH_fcmeans(x = BLOOD, k = 2, m = 1.5, rep = 10, 
                      simplify = TRUE, qua = 10, standardize = TRUE)
</code></pre>

<hr>
<h2 id='WH_hclust'>Hierarchical clustering of histogram data</h2><span id='topic+WH_hclust'></span>

<h3>Description</h3>

<p>The function implements a Hierarchical clustering
for a set of histogram-valued data, based on the L2 Wassertein distance.
Extends the <code>hclust</code> function of the <span class="pkg">stat</span> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>WH_hclust(
  x,
  simplify = FALSE,
  qua = 10,
  standardize = FALSE,
  distance = "WDIST",
  method = "complete"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="WH_hclust_+3A_x">x</code></td>
<td>
<p>A MatH object (a matrix of distributionH).</p>
</td></tr>
<tr><td><code id="WH_hclust_+3A_simplify">simplify</code></td>
<td>
<p>A logic value (default is FALSE), if TRUE histograms are recomputed in order to speed-up the algorithm.</p>
</td></tr>
<tr><td><code id="WH_hclust_+3A_qua">qua</code></td>
<td>
<p>An integer, if <code>simplify</code>=TRUE is the number of quantiles used for recodify the histograms.</p>
</td></tr>
<tr><td><code id="WH_hclust_+3A_standardize">standardize</code></td>
<td>
<p>A logic value (default is FALSE). If TRUE, histogram-valued data are standardized,  variable by variable,
using the Wassertein based standard deviation. Use if one wants to have variables with std equal to one.</p>
</td></tr>
<tr><td><code id="WH_hclust_+3A_distance">distance</code></td>
<td>
<p>A string default &quot;WDIST&quot; the L2 Wasserstein distance (other distances will be implemented)</p>
</td></tr>
<tr><td><code id="WH_hclust_+3A_method">method</code></td>
<td>
<p>A string, default=&quot;complete&quot;, is the the agglomeration method to be used.
This should be (an unambiguous abbreviation of) one of &quot;<code>ward.D</code>&quot;, &quot;<code>ward.D2</code>&quot;,
&quot;<code>single</code>&quot;, &quot;<code>complete</code>&quot;, &quot;<code>average</code>&quot; (= UPGMA), &quot;<code>mcquitty</code>&quot;
(= WPGMA), &quot;<code>median</code>&quot; (= WPGMC) or &quot;<code>centroid</code>&quot; (= UPGMC).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class hclust which describes the tree produced by
the clustering process.
</p>


<h3>References</h3>

<p>Irpino A., Verde R. (2006). A new Wasserstein based distance for the hierarchical clustering
of histogram symbolic data. In: Batanjeli et al. Data Science and Classification, IFCS 2006. p. 185-192,
BERLIN:Springer, ISBN: 3-540-34415-2
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+hclust">hclust</a></code> of <span class="pkg">stat</span> package for further details.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>results &lt;- WH_hclust(x = BLOOD, simplify = TRUE, method = "complete")
plot(results) # it plots the dendrogram
cutree(results, k = 5) # it returns the labels for 5 clusters
</code></pre>

<hr>
<h2 id='WH_kmeans'>K-means of a dataset of histogram-valued data</h2><span id='topic+WH_kmeans'></span>

<h3>Description</h3>

<p>The function implements the k-means for a set of histogram-valued data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>WH_kmeans(
  x,
  k,
  rep = 5,
  simplify = FALSE,
  qua = 10,
  standardize = FALSE,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="WH_kmeans_+3A_x">x</code></td>
<td>
<p>A MatH object (a matrix of distributionH).</p>
</td></tr>
<tr><td><code id="WH_kmeans_+3A_k">k</code></td>
<td>
<p>An integer, the number of groups.</p>
</td></tr>
<tr><td><code id="WH_kmeans_+3A_rep">rep</code></td>
<td>
<p>An integer, maximum number of repetitions of the algorithm (default <code>rep</code>=5).</p>
</td></tr>
<tr><td><code id="WH_kmeans_+3A_simplify">simplify</code></td>
<td>
<p>A logic value (default is FALSE), if TRUE histograms are recomputed in order to speed-up the algorithm.</p>
</td></tr>
<tr><td><code id="WH_kmeans_+3A_qua">qua</code></td>
<td>
<p>An integer, if <code>simplify</code>=TRUE is the number of quantiles used for recodify the histograms.</p>
</td></tr>
<tr><td><code id="WH_kmeans_+3A_standardize">standardize</code></td>
<td>
<p>A logic value (default is FALSE). If TRUE, histogram-valued data are standardized,  variable by variable,
using the Wassertein based standard deviation. Use if one wants to have variables with std equal to one.</p>
</td></tr>
<tr><td><code id="WH_kmeans_+3A_verbose">verbose</code></td>
<td>
<p>A logic value (default is FALSE). If TRUE, details on computations are shown.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with the results of the k-means of the set of Histogram-valued data <code>x</code> into  <code>k</code> cluster.
</p>


<h3>Slots</h3>


<dl>
<dt><code>solution</code></dt><dd><p>A list.Returns the best solution among the <code>rep</code>etitions, i.e.
the one having the minimum sum of squares criterion.</p>
</dd>
<dt><code>solution$IDX</code></dt><dd><p>A vector. The clusters at which the objects are assigned.</p>
</dd>
<dt><code>solution$cardinality</code></dt><dd><p>A vector. The cardinality of each final cluster.</p>
</dd>
<dt><code>solution$centers</code></dt><dd><p>A <code>MatH</code> object with the description of centers.</p>
</dd>
<dt><code>solution$Crit</code></dt><dd><p>A number. The criterion (Sum od square deviation
from the centers) value at the end of the run.</p>
</dd>
<dt><code>quality</code></dt><dd><p>A number. The percentage of Sum of square deviation explained by the model.
(The higher the better)</p>
</dd>
</dl>


<h3>References</h3>

<p>Irpino A., Verde R., Lechevallier Y. (2006). Dynamic clustering of histograms using Wasserstein
metric. In: Rizzi A., Vichi M.. COMPSTAT 2006 - Advances in computational statistics. p. 869-876,
Heidelberg:Physica-Verlag
</p>


<h3>Examples</h3>

<pre><code class='language-R'>results &lt;- WH_kmeans(
  x = BLOOD, k = 2, rep = 10, simplify = TRUE,
  qua = 10, standardize = TRUE, verbose = TRUE
)
</code></pre>

<hr>
<h2 id='WH_MAT_DIST'>L2  Wasserstein distance matrix</h2><span id='topic+WH_MAT_DIST'></span>

<h3>Description</h3>

<p>The function extracts the L2 Wasserstein distance matrix from a MatH object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>WH_MAT_DIST(x, simplify = FALSE, qua = 10, standardize = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="WH_MAT_DIST_+3A_x">x</code></td>
<td>
<p>A MatH object (a matrix of distributionH).</p>
</td></tr>
<tr><td><code id="WH_MAT_DIST_+3A_simplify">simplify</code></td>
<td>
<p>A logic value (default is FALSE), if TRUE histograms are recomputed in order to speed-up the algorithm.</p>
</td></tr>
<tr><td><code id="WH_MAT_DIST_+3A_qua">qua</code></td>
<td>
<p>An integer, if <code>simplify</code>=TRUE is the number of quantiles used for recodify the histograms.</p>
</td></tr>
<tr><td><code id="WH_MAT_DIST_+3A_standardize">standardize</code></td>
<td>
<p>A logic value (default is FALSE). If TRUE, histogram-valued data are standardized,  variable by variable,
using the Wasserstein based standard deviation. Use if one wants to have variables with std equal to one.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of squared L2 distances.
</p>


<h3>References</h3>

<p>Irpino A., Verde R. (2006). A new Wasserstein based distance for the hierarchical clustering
of histogram symbolic data. In: Batanjeli et al. Data Science and Classification, IFCS 2006. p. 185-192,
BERLIN:Springer, ISBN: 3-540-34415-2
</p>


<h3>Examples</h3>

<pre><code class='language-R'>DMAT &lt;- WH_MAT_DIST(x = BLOOD, simplify = TRUE)
</code></pre>

<hr>
<h2 id='WH.1d.PCA'>Principal components analysis  of histogram variable based on Wasserstein distance</h2><span id='topic+WH.1d.PCA'></span>

<h3>Description</h3>

<p>The function implements a Principal components analysis of histogram variable
based on Wasserstein distance. It performs a centered (not standardized) PCA on a set of quantiles of a variable.
Being a distribution a multivalued description, the analysis performs a dimensional reduction and a visualization of distributions.
It is a 1d (one dimension) becuse it is considered just one histogram variable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>WH.1d.PCA(
  data,
  var,
  quantiles = 10,
  plots = TRUE,
  listaxes = c(1:4),
  axisequal = FALSE,
  qcut = 1,
  outl = 0
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="WH.1d.PCA_+3A_data">data</code></td>
<td>
<p>A MatH object (a matrix of distributionH).</p>
</td></tr>
<tr><td><code id="WH.1d.PCA_+3A_var">var</code></td>
<td>
<p>An integer, the variable number.</p>
</td></tr>
<tr><td><code id="WH.1d.PCA_+3A_quantiles">quantiles</code></td>
<td>
<p>An integer, it is the number of quantiles used in the analysis.</p>
</td></tr>
<tr><td><code id="WH.1d.PCA_+3A_plots">plots</code></td>
<td>
<p>a logical value. Default=TRUE plots are drawn.</p>
</td></tr>
<tr><td><code id="WH.1d.PCA_+3A_listaxes">listaxes</code></td>
<td>
<p>A vector of integers listing the axis for the 2d factorial reperesntations.</p>
</td></tr>
<tr><td><code id="WH.1d.PCA_+3A_axisequal">axisequal</code></td>
<td>
<p>A logical value. Default TRUE, the plot have the same scale for the x and the y axes.</p>
</td></tr>
<tr><td><code id="WH.1d.PCA_+3A_qcut">qcut</code></td>
<td>
<p>a number between 0.5 and 1, it is used for the plot of densities, and avoids very peaked densities.
Default=1, all the densities are considered.</p>
</td></tr>
<tr><td><code id="WH.1d.PCA_+3A_outl">outl</code></td>
<td>
<p>a number between 0 (default)  and 0.5. For each distribution, is the amount of mass removed from the tails
of the distribution. For example, if 0.1, from each distribution is cut away a left tail and a right one each containing
the 0.1 of mass.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In the framework of symbolic data analysis (SDA), distribution-valued data
are defined as multivalued data, where each unit is described by a distribution
(e.g., a histogram, a density, or a quantile function) of a quantitative variable.
SDA provides different methods for analyzing multivalued data. Among them, the most relevant
techniques proposed for a dimensional reduction of multivalued quantitative variables is principal
component analysis (PCA). This paper gives a contribution in this context of analysis.
Starting from new association measures for distributional variables based on a peculiar metric
for distributions, the squared Wasserstein distance, a PCA approach is proposed for distribution-valued data,
represented by quantile-variables.
</p>


<h3>Value</h3>

<p>a list with the results of the PCA in the MFA format of package <span class="pkg">FactoMineR</span> for function MFA
</p>


<h3>References</h3>

<p>Verde, R.; Irpino, A.; Balzanella, A., &quot;Dimension Reduction Techniques for Distributional Symbolic Data,&quot; Cybernetics, IEEE Transactions on , vol.PP, no.99, pp.1,1
doi: 10.1109/TCYB.2015.2389653
keywords: Correlation;Covariance matrices;Distribution functions;Histograms;Measurement;Principal component analysis;Shape;Distributional data;Wasserstein distance;principal components analysis;quantiles,
<a href="https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;arnumber=7024099&amp;isnumber=6352949">https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;arnumber=7024099&amp;isnumber=6352949</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>results &lt;- WH.1d.PCA(data = BLOOD, var = 1, listaxes = c(1:2))
</code></pre>

<hr>
<h2 id='WH.bind'>Method WH.bind</h2><span id='topic+WH.bind'></span><span id='topic+WH.bind+2CMatH+2CMatH-method'></span><span id='topic+WH.bind+2CMatH-method'></span>

<h3>Description</h3>

<p>It attaches two <code>MatH</code> objects with the same columns by row, or the same rows by colum.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>WH.bind(object1, object2, byrow)

## S4 method for signature 'MatH,MatH'
WH.bind(object1, object2, byrow = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="WH.bind_+3A_object1">object1</code></td>
<td>
<p>a <code>MatH</code> object</p>
</td></tr>
<tr><td><code id="WH.bind_+3A_object2">object2</code></td>
<td>
<p>a <code>MatH</code> object</p>
</td></tr>
<tr><td><code id="WH.bind_+3A_byrow">byrow</code></td>
<td>
<p>a logical value (default=TRUE) attaches the objects by row</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>MatH</code> object,
</p>


<h3>See Also</h3>

<p><code><a href="#topic+WH.bind.row">WH.bind.row</a></code> for binding by row, <code><a href="#topic+WH.bind.col">WH.bind.col</a></code> for binding by column
</p>


<h3>Examples</h3>

<pre><code class='language-R'># binding by row
M1 &lt;- BLOOD[1:10, 1]
M2 &lt;- BLOOD[1:10, 3]
MAT &lt;- WH.bind(M1, M2, byrow = TRUE)
# binding by col
M1 &lt;- BLOOD[1:10, 1]
M2 &lt;- BLOOD[1:10, 3]
MAT &lt;- WH.bind(M1, M2, byrow = FALSE)
</code></pre>

<hr>
<h2 id='WH.bind.col'>Method WH.bind.col</h2><span id='topic+WH.bind.col'></span><span id='topic+WH.bind.col+2CMatH+2CMatH-method'></span><span id='topic+WH.bind.col+2CMatH-method'></span>

<h3>Description</h3>

<p>It attaches two <code>MatH</code> objects with the same rows by colums.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>WH.bind.col(object1, object2)

## S4 method for signature 'MatH,MatH'
WH.bind.col(object1, object2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="WH.bind.col_+3A_object1">object1</code></td>
<td>
<p>a <code>MatH</code> object</p>
</td></tr>
<tr><td><code id="WH.bind.col_+3A_object2">object2</code></td>
<td>
<p>a <code>MatH</code> object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>MatH</code> object,
</p>


<h3>Examples</h3>

<pre><code class='language-R'>M1 &lt;- BLOOD[1:10, 1]
M2 &lt;- BLOOD[1:10, 3]
MAT &lt;- WH.bind.col(M1, M2)
</code></pre>

<hr>
<h2 id='WH.bind.row'>Method WH.bind.row</h2><span id='topic+WH.bind.row'></span><span id='topic+WH.bind.row+2CMatH+2CMatH-method'></span><span id='topic+WH.bind.row+2CMatH-method'></span>

<h3>Description</h3>

<p>It attaches two <code>MatH</code> objects with the same columns by row.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>WH.bind.row(object1, object2)

## S4 method for signature 'MatH,MatH'
WH.bind.row(object1, object2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="WH.bind.row_+3A_object1">object1</code></td>
<td>
<p>a <code>MatH</code> object</p>
</td></tr>
<tr><td><code id="WH.bind.row_+3A_object2">object2</code></td>
<td>
<p>a <code>MatH</code> object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>MatH</code> object,
</p>


<h3>Examples</h3>

<pre><code class='language-R'>M1 &lt;- BLOOD[1:3, ]
M2 &lt;- BLOOD[5:8, ]
MAT &lt;- WH.bind.row(M1, M2)
</code></pre>

<hr>
<h2 id='WH.correlation'>Method WH.correlation</h2><span id='topic+WH.correlation'></span><span id='topic+WH.correlation+2CMatH-method'></span>

<h3>Description</h3>

<p>Compute the correlation matrix of a <code>MatH</code> object, i.e.
a matrix of values consistent with
a set of distributions equipped with a L2 wasserstein metric.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>WH.correlation(object, ...)

## S4 method for signature 'MatH'
WH.correlation(object, w = numeric(0))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="WH.correlation_+3A_object">object</code></td>
<td>
<p>a <code>MatH</code> object</p>
</td></tr>
<tr><td><code id="WH.correlation_+3A_...">...</code></td>
<td>
<p>some optional parameters</p>
</td></tr>
<tr><td><code id="WH.correlation_+3A_w">w</code></td>
<td>
<p>it is possible to add a vector of weights (positive numbers)
having the same size of the rows of the <code>MatH object</code>,
default = equal weight for each row</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a squared <code>matrix</code> with the (weighted) correlations indices
</p>


<h3>References</h3>

<p>Irpino, A., Verde, R. (2015) <em>Basic
statistics for distributional symbolic variables: a new metric-based
approach</em> Advances in Data Analysis and Classification, DOI
10.1007/s11634-014-0176-4
</p>


<h3>Examples</h3>

<pre><code class='language-R'>WH.correlation(BLOOD)
# generate a set of random weights
RN &lt;- runif(get.MatH.nrows(BLOOD))
WH.correlation(BLOOD, w = RN)
</code></pre>

<hr>
<h2 id='WH.correlation2'>Method WH.correlation2</h2><span id='topic+WH.correlation2'></span><span id='topic+WH.correlation2+2CMatH+2CMatH-method'></span><span id='topic+WH.correlation2+2CMatH-method'></span>

<h3>Description</h3>

<p>Compute the correlation matrix using two  <code>MatH</code> objects having the same number of rows,
It returns a rectangular a matrix of numbers, consistent with
a set of distributions equipped with a L2 wasserstein metric.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>WH.correlation2(object1, object2, ...)

## S4 method for signature 'MatH,MatH'
WH.correlation2(object1, object2, w = numeric(0))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="WH.correlation2_+3A_object1">object1</code></td>
<td>
<p>a <code>MatH</code> object</p>
</td></tr>
<tr><td><code id="WH.correlation2_+3A_object2">object2</code></td>
<td>
<p>a <code>MatH</code> object</p>
</td></tr>
<tr><td><code id="WH.correlation2_+3A_...">...</code></td>
<td>
<p>some optional parameters</p>
</td></tr>
<tr><td><code id="WH.correlation2_+3A_w">w</code></td>
<td>
<p>it is possible to add a vector of weights (positive numbers)
having the same size of the rows of the <code>MatH object</code>,
default = equal weight for each row</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a rectangular <code>matrix</code> with the weighted sum of squares
</p>


<h3>Examples</h3>

<pre><code class='language-R'>M1 &lt;- BLOOD[, 1]
M2 &lt;- BLOOD[, 2:3]
WH.correlation2(M1, M2)
# generate a set of random weights
RN &lt;- runif(get.MatH.nrows(BLOOD))
WH.correlation2(M1, M2, w = RN)
</code></pre>

<hr>
<h2 id='WH.mat.prod'>Method WH.mat.prod</h2><span id='topic+WH.mat.prod'></span><span id='topic+WH.mat.prod+2CMatH+2CMatH-method'></span><span id='topic+WH.mat.prod+2CMatH-method'></span>

<h3>Description</h3>

<p>It is the matrix product of two <code>MatH</code> objects, i.e. two matrices of distributions,
by using the dot product of two histograms that is consistent with
a set of distributions equipped with a L2 wasserstein metric.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>WH.mat.prod(object1, object2, ...)

## S4 method for signature 'MatH,MatH'
WH.mat.prod(object1, object2, traspose1 = FALSE, traspose2 = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="WH.mat.prod_+3A_object1">object1</code></td>
<td>
<p>a <code>MatH</code> object</p>
</td></tr>
<tr><td><code id="WH.mat.prod_+3A_object2">object2</code></td>
<td>
<p>a <code>MatH</code> object</p>
</td></tr>
<tr><td><code id="WH.mat.prod_+3A_...">...</code></td>
<td>
<p>other optional parameters</p>
</td></tr>
<tr><td><code id="WH.mat.prod_+3A_traspose1">traspose1</code></td>
<td>
<p>a logical value, default=FALSE. If TRUE trasposes object1</p>
</td></tr>
<tr><td><code id="WH.mat.prod_+3A_traspose2">traspose2</code></td>
<td>
<p>a logical value, default=FALSE. If TRUE trasposes object2</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix of numbers
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
M1 &lt;- BLOOD[1:5, ]
M2 &lt;- BLOOD[6:10, ]
MAT &lt;- WH.mat.prod(M1, M2, traspose1 = TRUE, traspose2 = FALSE)
</code></pre>

<hr>
<h2 id='WH.mat.sum'>Method WH.mat.sum</h2><span id='topic+WH.mat.sum'></span><span id='topic+WH.mat.sum+2CMatH+2CMatH-method'></span><span id='topic+WH.mat.sum+2CMatH-method'></span>

<h3>Description</h3>

<p>It sums two <code>MatH</code> objects, i.e. two matrices of distributions,
by summing the quantile functions of histograms. This sum is consistent with
a set of distributions equipped with a L2 wasserstein metric.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>WH.mat.sum(object1, object2)

## S4 method for signature 'MatH,MatH'
WH.mat.sum(object1, object2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="WH.mat.sum_+3A_object1">object1</code></td>
<td>
<p>a <code>MatH</code> object</p>
</td></tr>
<tr><td><code id="WH.mat.sum_+3A_object2">object2</code></td>
<td>
<p>a <code>MatH</code> object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>MatH</code> object,
</p>


<h3>Examples</h3>

<pre><code class='language-R'># binding by row
M1 &lt;- BLOOD[1:5, ]
M2 &lt;- BLOOD[6:10, ]
MAT &lt;- WH.mat.sum(M1, M2)
</code></pre>

<hr>
<h2 id='WH.MultiplePCA'>Principal components analysis  of a set of histogram variable based on Wasserstein distance</h2><span id='topic+WH.MultiplePCA'></span>

<h3>Description</h3>

<p>(Beta version) The function implements a Principal components analysis of a set of histogram variables
based on Wasserstein distance. It performs a centered (not standardized) PCA on a set of quantiles of a variable.
Being a distribution a multivalued description, the analysis performs a dimensional reduction and a visualization of distributions.
It is a 1d (one dimension) becuse it is considered just one histogram variable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>WH.MultiplePCA(data, list.of.vars, quantiles = 10, outl = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="WH.MultiplePCA_+3A_data">data</code></td>
<td>
<p>A MatH object (a matrix of distributionH).</p>
</td></tr>
<tr><td><code id="WH.MultiplePCA_+3A_list.of.vars">list.of.vars</code></td>
<td>
<p>A list of  integers, the active variables.</p>
</td></tr>
<tr><td><code id="WH.MultiplePCA_+3A_quantiles">quantiles</code></td>
<td>
<p>An integer, it is the number of quantiles used in the analysis.
Default=10.</p>
</td></tr>
<tr><td><code id="WH.MultiplePCA_+3A_outl">outl</code></td>
<td>
<p>a number between 0 (default)  and 0.5. For each distribution, is the amount of mass removed from the tails
of the distribution. For example, if 0.1, from each distribution is cut away a left tail and a right one each containing
the 0.1 of mass.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It is an extension of WH.1d.PCA to the multiple case.
</p>


<h3>Value</h3>

<p>a list with the results of the PCA in the MFA format of package <span class="pkg">FactoMineR</span> for function MFA
</p>

<hr>
<h2 id='WH.plot_multiple_indivs'>Plot histograms of individuals after a  Multiple factor analysis of Histogram Variables</h2><span id='topic+WH.plot_multiple_indivs'></span>

<h3>Description</h3>

<p>(Beta version) The function plots histogram data of the individuals for a particular
variable on a factorial palne after a Multiple factor analysis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>WH.plot_multiple_indivs(
  data,
  res,
  axes = c(1, 2),
  indiv = 0,
  var = 1,
  strx = 0.1,
  stry = 0.1,
  HISTO = TRUE,
  coor = 0,
  stat = "mean"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="WH.plot_multiple_indivs_+3A_data">data</code></td>
<td>
<p>a MatH object</p>
</td></tr>
<tr><td><code id="WH.plot_multiple_indivs_+3A_res">res</code></td>
<td>
<p>Results from WH.MultiplePCA.</p>
</td></tr>
<tr><td><code id="WH.plot_multiple_indivs_+3A_axes">axes</code></td>
<td>
<p>A list of  integers, the new factorial axes c(1,2) are the default.</p>
</td></tr>
<tr><td><code id="WH.plot_multiple_indivs_+3A_indiv">indiv</code></td>
<td>
<p>A list of objects (rows) of data to plot. Default=0 all the objects of data.</p>
</td></tr>
<tr><td><code id="WH.plot_multiple_indivs_+3A_var">var</code></td>
<td>
<p>An integer indicating an original histogrma variable to plot.</p>
</td></tr>
<tr><td><code id="WH.plot_multiple_indivs_+3A_strx">strx</code></td>
<td>
<p>a resizing factor for the domain of histograms (default=0.1 means
that each distribution has a support that is one tenth of the spread of the x axis)</p>
</td></tr>
<tr><td><code id="WH.plot_multiple_indivs_+3A_stry">stry</code></td>
<td>
<p>a resizing factor for the density of histograms (default=0.1 means
that each distribution has a density that is one tenth of the spread of the y axis)</p>
</td></tr>
<tr><td><code id="WH.plot_multiple_indivs_+3A_histo">HISTO</code></td>
<td>
<p>a logical value. Default=TRUE plots histograms, FALSE plot smooth densities.</p>
</td></tr>
<tr><td><code id="WH.plot_multiple_indivs_+3A_coor">coor</code></td>
<td>
<p>(optional) if 0 (Default) takes the coordinates in res, if a a matrix is passed the coordinates are those passed</p>
</td></tr>
<tr><td><code id="WH.plot_multiple_indivs_+3A_stat">stat</code></td>
<td>
<p>(optional) if 'mean'(Default) a plot of individuals labeled by the means is produced.
Otherwise if 'std', 'skewness' or 'kurtosis', data are labeled with this statistic.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a plot of class ggplot
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Do a MultiplePCA on the BLOOD dataset
## Not run: 
#' results=WH.MultiplePCA(BLOOD,list.of.vars = c(1:3))
# Plot histograms of variable 1 of BLOOD dataset on the first
# factorial plane showing histograms
WH.plot_multiple_indivs(BLOOD, results,
  axes = c(1, 2), var = 1, strx = 0.1,
  stry = 0.1, HISTO = TRUE
)
# Plot histograms of variable 1 of BLOOD dataset on the first
# factorial plane showing densities

WH.plot_multiple_indivs(BLOOD, results,
  axes = c(1, 2), var = 1, strx = 0.1,
  stry = 0.1, HISTO = FALSE
)

## End(Not run)

</code></pre>

<hr>
<h2 id='WH.plot_multiple_Spanish.funs'>Plotting Spanish fun plots for Multiple factor analysis of Histogram Variables</h2><span id='topic+WH.plot_multiple_Spanish.funs'></span>

<h3>Description</h3>

<p>The function plots the circle of correlation of the quantiles
of the histogrma variables after a Multiple factor analysis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>WH.plot_multiple_Spanish.funs(
  res,
  axes = c(1, 2),
  var = 1,
  LABS = TRUE,
  multi = TRUE,
  corplot = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="WH.plot_multiple_Spanish.funs_+3A_res">res</code></td>
<td>
<p>Results from WH.MultiplePCA, or WH.1D.PCA.</p>
</td></tr>
<tr><td><code id="WH.plot_multiple_Spanish.funs_+3A_axes">axes</code></td>
<td>
<p>A list of  integers, the new factorial axes c(1,2) are the default.</p>
</td></tr>
<tr><td><code id="WH.plot_multiple_Spanish.funs_+3A_var">var</code></td>
<td>
<p>A list of integers are the variables to plot.</p>
</td></tr>
<tr><td><code id="WH.plot_multiple_Spanish.funs_+3A_labs">LABS</code></td>
<td>
<p>Logical, if TRUE graph is labeled, otherwise it does not.</p>
</td></tr>
<tr><td><code id="WH.plot_multiple_Spanish.funs_+3A_multi">multi</code></td>
<td>
<p>Logical, if TRUE (default) results come from a WH.MultiplePCA,
if FALSE results come from WH.1D.PCA.</p>
</td></tr>
<tr><td><code id="WH.plot_multiple_Spanish.funs_+3A_corplot">corplot</code></td>
<td>
<p>Logical, if TRUE (default) the plot reports correlations, if FALSE
the coordinates of quantiles on the factorial plane</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a plot of class ggplot
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Do a MultiplePCA on the BLOOD dataset
## Not run: 
res &lt;- WH.MultiplePCA(BLOOD, list.of.vars = c(1:3))

## End(Not run)
# Plot results
## Not run: 
WH.plot_multiple_Spanish.funs(res, axes = c(1, 2), var = c(1:3))

## End(Not run)
</code></pre>

<hr>
<h2 id='WH.regression.GOF'>Goodness of Fit indices for Multiple regression of histogram variables based on a two component model and L2 Wasserstein distance</h2><span id='topic+WH.regression.GOF'></span>

<h3>Description</h3>

<p>It computes three goodness of fit indices using the results and the predictions of a regression done with <code>WH.regression.two.components</code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>WH.regression.GOF(observed, predicted)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="WH.regression.GOF_+3A_observed">observed</code></td>
<td>
<p>A one column MatH object, the observed histogram variable</p>
</td></tr>
<tr><td><code id="WH.regression.GOF_+3A_predicted">predicted</code></td>
<td>
<p>A one column MatH object, the predicted histogram variable.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with the GOF indices
</p>


<h3>References</h3>

<p>Irpino A, Verde R (in press 2015). Linear regression for numeric symbolic variables: a least squares approach
based on Wasserstein Distance. ADVANCES IN DATA ANALYSIS AND CLASSIFICATION, ISSN: 1862-5347, DOI:10.1007/s11634-015-0197-7 <br />
An extended version is available  on arXiv repository arXiv:1202.1436v2 <a href="https://arxiv.org/abs/1202.1436v2">https://arxiv.org/abs/1202.1436v2</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># do regression
model.parameters &lt;- WH.regression.two.components(data = BLOOD, Yvar = 1, Xvars = c(2:3))
#' # do prediction
Predicted.BLOOD &lt;- WH.regression.two.components.predict(data = BLOOD[, 2:3], 
                                              parameters = model.parameters)
# compute GOF indices
GOF.indices &lt;- WH.regression.GOF(observed = BLOOD[, 1], predicted = Predicted.BLOOD)
</code></pre>

<hr>
<h2 id='WH.regression.two.components'>Multiple regression analysis for  histogram variables based on a two component model and L2 Wasserstein distance</h2><span id='topic+WH.regression.two.components'></span>

<h3>Description</h3>

<p>The function implements Multiple regression analysis for  histogram variables based on
a two component model and L2 Wasserstein distance. Taking as imput dependent histogram variable and
a set of explanatory histogram variables the methods return a least squares estimation of a two component
regression model based on the decomposition of L2 Wasserstein metric for distributional data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>WH.regression.two.components(data, Yvar, Xvars, simplify = FALSE, qua = 20)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="WH.regression.two.components_+3A_data">data</code></td>
<td>
<p>A MatH object (a matrix of distributionH).</p>
</td></tr>
<tr><td><code id="WH.regression.two.components_+3A_yvar">Yvar</code></td>
<td>
<p>An integer, the dependent variable number in data.</p>
</td></tr>
<tr><td><code id="WH.regression.two.components_+3A_xvars">Xvars</code></td>
<td>
<p>A set of integers the explanantory variables in data.</p>
</td></tr>
<tr><td><code id="WH.regression.two.components_+3A_simplify">simplify</code></td>
<td>
<p>a logical argument (default=FALSE). If TRUE only few equally spaced quantiles
are considered (for speeding up the  algorithm)</p>
</td></tr>
<tr><td><code id="WH.regression.two.components_+3A_qua">qua</code></td>
<td>
<p>If <code>simplify=TRUE</code> is the number of quantiles to consider.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A two component regression model is implemented. The observed variables are histogram variables
according to the definition given in the framework
of Symbolic Data Analysis and the parameters of the model are estimated
using the classic Least Squares method. An appropriate metric is introduced
in order to measure the error between the observed and the predicted distributions.
In particular, the Wasserstein distance is proposed.
Such a metric permits to predict the response variable as direct linear combination of other independent
histogram variables.
</p>


<h3>Value</h3>

<p>a named vector with the model estimated parameters
</p>


<h3>References</h3>

<p>Irpino A, Verde R (in press 2015). Linear regression for numeric symbolic variables: a least squares approach
based on Wasserstein Distance. ADVANCES IN DATA ANALYSIS AND CLASSIFICATION, ISSN: 1862-5347, DOI:10.1007/s11634-015-0197-7 <br />
An extended version is available  on arXiv repository arXiv:1202.1436v2 <a href="https://arxiv.org/abs/1202.1436v2">https://arxiv.org/abs/1202.1436v2</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>model.parameters &lt;- WH.regression.two.components(data = BLOOD, Yvar = 1, Xvars = c(2:3))
</code></pre>

<hr>
<h2 id='WH.regression.two.components.predict'>Multiple regression analysis for  histogram variables based on a two component model and L2 Wasserstein distance</h2><span id='topic+WH.regression.two.components.predict'></span>

<h3>Description</h3>

<p>Predict distributions using the results of a regression done with <code>WH.regression.two.components</code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>WH.regression.two.components.predict(data, parameters)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="WH.regression.two.components.predict_+3A_data">data</code></td>
<td>
<p>A MatH object (a matrix of distributionH) explantory part.</p>
</td></tr>
<tr><td><code id="WH.regression.two.components.predict_+3A_parameters">parameters</code></td>
<td>
<p>A named vector with the parameter from a <code>WH.regression.two.components</code> model</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>MatH</code>  object, the predicted histograms
</p>


<h3>References</h3>

<p>Irpino A, Verde R (in press 2015). Linear regression for numeric symbolic variables: a least squares approach
based on Wasserstein Distance. ADVANCES IN DATA ANALYSIS AND CLASSIFICATION, ISSN: 1862-5347, DOI:10.1007/s11634-015-0197-7 <br />
An extended version is available  on arXiv repository arXiv:1202.1436v2 <a href="https://arxiv.org/abs/1202.1436v2">https://arxiv.org/abs/1202.1436v2</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># do regression
model.parameters &lt;- WH.regression.two.components(data = BLOOD, Yvar = 1, Xvars = c(2:3))
# do prediction
Predicted.BLOOD &lt;- WH.regression.two.components.predict(data = BLOOD[, 2:3], 
                                                        parameters = model.parameters)
</code></pre>

<hr>
<h2 id='WH.SSQ'>Method WH.SSQ</h2><span id='topic+WH.SSQ'></span><span id='topic+WH.SSQ+2CMatH-method'></span>

<h3>Description</h3>

<p>Compute the sum-of-squares-deviations (from the mean) matrix of a <code>MatH</code> object, i.e.
a matrix of numbers, consistent with
a set of distributions equipped with a L2 wasserstein metric.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>WH.SSQ(object, ...)

## S4 method for signature 'MatH'
WH.SSQ(object, w = numeric(0))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="WH.SSQ_+3A_object">object</code></td>
<td>
<p>a <code>MatH</code> object</p>
</td></tr>
<tr><td><code id="WH.SSQ_+3A_...">...</code></td>
<td>
<p>some optional parameters</p>
</td></tr>
<tr><td><code id="WH.SSQ_+3A_w">w</code></td>
<td>
<p>it is possible to add a vector of weights (positive numbers)
having the same size of the rows of the <code>MatH object</code>,
default = equal weight for each row</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a squared <code>matrix</code> with the weighted sum of squares
</p>


<h3>Examples</h3>

<pre><code class='language-R'>WH.SSQ(BLOOD)
# generate a set of random weights
RN &lt;- runif(get.MatH.nrows(BLOOD))
WH.SSQ(BLOOD, w = RN)
</code></pre>

<hr>
<h2 id='WH.SSQ2'>Method WH.SSQ2</h2><span id='topic+WH.SSQ2'></span><span id='topic+WH.SSQ2+2CMatH+2CMatH-method'></span><span id='topic+WH.SSQ2+2CMatH-method'></span>

<h3>Description</h3>

<p>Compute the sum-of-squares-deviations (from the mean) matrix using two  <code>MatH</code> objects having the same number of rows,
It returns a rectangular a matrix of numbers, consistent with
a set of distributions equipped with a L2 wasserstein metric.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>WH.SSQ2(object1, object2, ...)

## S4 method for signature 'MatH,MatH'
WH.SSQ2(object1, object2, w = numeric(0))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="WH.SSQ2_+3A_object1">object1</code></td>
<td>
<p>a <code>MatH</code> object</p>
</td></tr>
<tr><td><code id="WH.SSQ2_+3A_object2">object2</code></td>
<td>
<p>a <code>MatH</code> object</p>
</td></tr>
<tr><td><code id="WH.SSQ2_+3A_...">...</code></td>
<td>
<p>some optional parameters</p>
</td></tr>
<tr><td><code id="WH.SSQ2_+3A_w">w</code></td>
<td>
<p>it is possible to add a vector of weights (positive numbers)
having the same size of the rows of the <code>MatH object</code>,
default = equal weight for each row</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a rectangular <code>matrix</code> with the weighted sum of squares
</p>


<h3>Examples</h3>

<pre><code class='language-R'>M1 &lt;- BLOOD[, 1]
M2 &lt;- BLOOD[, 2:3]
WH.SSQ2(M1, M2)
# generate a set of random weights
RN &lt;- runif(get.MatH.nrows(BLOOD))
WH.SSQ2(M1, M2, w = RN)
</code></pre>

<hr>
<h2 id='WH.var.covar'>Method WH.var.covar</h2><span id='topic+WH.var.covar'></span><span id='topic+WH.var.covar+2CMatH-method'></span>

<h3>Description</h3>

<p>Compute the variance-covariance matrix of a <code>MatH</code> object, i.e.
a matrix of values consistent with
a set of distributions equipped with a L2 wasserstein metric.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>WH.var.covar(object, ...)

## S4 method for signature 'MatH'
WH.var.covar(object, w = numeric(0))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="WH.var.covar_+3A_object">object</code></td>
<td>
<p>a <code>MatH</code> object</p>
</td></tr>
<tr><td><code id="WH.var.covar_+3A_...">...</code></td>
<td>
<p>some optional parameters</p>
</td></tr>
<tr><td><code id="WH.var.covar_+3A_w">w</code></td>
<td>
<p>it is possible to add a vector of weights (positive numbers)
having the same size of the rows of the <code>MatH object</code>,
default = equal weight for each row</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a squared <code>matrix</code> with the (weighted) variance-covariance values
</p>


<h3>References</h3>

<p>Irpino, A., Verde, R. (2015) <em>Basic
statistics for distributional symbolic variables: a new metric-based
approach</em> Advances in Data Analysis and Classification, DOI
10.1007/s11634-014-0176-4
</p>


<h3>Examples</h3>

<pre><code class='language-R'>WH.var.covar(BLOOD)
# generate a set of random weights
RN &lt;- runif(get.MatH.nrows(BLOOD))
WH.var.covar(BLOOD, w = RN)
</code></pre>

<hr>
<h2 id='WH.var.covar2'>Method WH.var.covar2</h2><span id='topic+WH.var.covar2'></span><span id='topic+WH.var.covar2+2CMatH+2CMatH-method'></span><span id='topic+WH.var.covar2+2CMatH-method'></span>

<h3>Description</h3>

<p>Compute the covariance matrix using two  <code>MatH</code> objects having the same number of rows,
It returns a rectangular a matrix of numbers, consistent with
a set of distributions equipped with a L2 wasserstein metric.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>WH.var.covar2(object1, object2, ...)

## S4 method for signature 'MatH,MatH'
WH.var.covar2(object1, object2, w = numeric(0))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="WH.var.covar2_+3A_object1">object1</code></td>
<td>
<p>a <code>MatH</code> object</p>
</td></tr>
<tr><td><code id="WH.var.covar2_+3A_object2">object2</code></td>
<td>
<p>a <code>MatH</code> object</p>
</td></tr>
<tr><td><code id="WH.var.covar2_+3A_...">...</code></td>
<td>
<p>some optional parameters</p>
</td></tr>
<tr><td><code id="WH.var.covar2_+3A_w">w</code></td>
<td>
<p>it is possible to add a vector of weights (positive numbers)
having the same size of the rows of the <code>MatH object</code>,
default = equal weight for each row</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a rectangular <code>matrix</code> with the weighted sum of squares
</p>


<h3>Examples</h3>

<pre><code class='language-R'>M1 &lt;- BLOOD[, 1]
M2 &lt;- BLOOD[, 2:3]
WH.var.covar2(M1, M2)
# generate a set of random weights
RN &lt;- runif(get.MatH.nrows(BLOOD))
WH.var.covar2(M1, M2, w = RN)
</code></pre>

<hr>
<h2 id='WH.vec.mean'>Method WH.vec.mean</h2><span id='topic+WH.vec.mean'></span><span id='topic+WH.vec.mean+2CMatH-method'></span>

<h3>Description</h3>

<p>Compute a histogram that is the weighted mean of the set of histograms contained
in a <code>MatH</code> object, i.e. a matrix of histograms, consistent with
a set of distributions equipped with a L2 wasserstein metric.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>WH.vec.mean(object, ...)

## S4 method for signature 'MatH'
WH.vec.mean(object, w = numeric(0))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="WH.vec.mean_+3A_object">object</code></td>
<td>
<p>a <code>MatH</code> object</p>
</td></tr>
<tr><td><code id="WH.vec.mean_+3A_...">...</code></td>
<td>
<p>optional arguments</p>
</td></tr>
<tr><td><code id="WH.vec.mean_+3A_w">w</code></td>
<td>
<p>it is possible to add a vector of weights (positive numbers) having the same size of
the <code>MatH object</code>, default = equal weights for all</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>distributionH</code> object, i.e. a histogram
</p>


<h3>Examples</h3>

<pre><code class='language-R'>hmean &lt;- WH.vec.mean(BLOOD)
# generate a set of random weights
RN &lt;- runif(get.MatH.nrows(BLOOD) * get.MatH.ncols(BLOOD))
hmean &lt;- WH.vec.mean(BLOOD, w = RN)
</code></pre>

<hr>
<h2 id='WH.vec.sum'>Method WH.vec.sum</h2><span id='topic+WH.vec.sum'></span><span id='topic+WH.vec.sum+2CMatH-method'></span>

<h3>Description</h3>

<p>Compute a histogram that is the weighted sum of the set of histograms contained
in a <code>MatH</code> object, i.e. a matrix of histograms, consistent with
a set of distributions equipped with a L2 wasserstein metric.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>WH.vec.sum(object, ...)

## S4 method for signature 'MatH'
WH.vec.sum(object, w = numeric(0))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="WH.vec.sum_+3A_object">object</code></td>
<td>
<p>a <code>MatH</code> object</p>
</td></tr>
<tr><td><code id="WH.vec.sum_+3A_...">...</code></td>
<td>
<p>optional arguments</p>
</td></tr>
<tr><td><code id="WH.vec.sum_+3A_w">w</code></td>
<td>
<p>it is possible to add a vector of weights (positive numbers) having the same size of the <code>MatH object</code>,
default = equal weights for all cells</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>distributionH</code> object, i.e. a histogram
</p>


<h3>Examples</h3>

<pre><code class='language-R'>hsum &lt;- WH.vec.sum(BLOOD)
# generate a set of random weights
RN &lt;- runif(get.MatH.nrows(BLOOD) * get.MatH.ncols(BLOOD))
hsum &lt;- WH.vec.sum(BLOOD, w = RN)
### SUM of distributions ----
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
