<!DOCTYPE html><html lang="en"><head><title>Help for package DynaRankR</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {DynaRankR}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#C.crocuta.female'><p>Female spotted hyena dominance data</p></a></li>
<li><a href='#C.crocuta.male'><p>Male spotted hyena dominance data</p></a></li>
<li><a href='#dyadic_similarity'><p>Compare two rank orderings</p></a></li>
<li><a href='#edgelist_to_matrix'><p>Convert data from edgelist to interaction matrix</p></a></li>
<li><a href='#get_dynamics'><p>Calculate hierarchy dynamics</p></a></li>
<li><a href='#get_edgelist'><p>Convert data from interaction matrix to edgelist</p></a></li>
<li><a href='#informed_ds'><p>David's Score method informed by prior information</p></a></li>
<li><a href='#informed_elo'><p>Elo-rating method informed by prior information</p></a></li>
<li><a href='#informed_matreorder'><p>Infer longitudinal hierarchy using informed matrix reordering</p></a></li>
<li><a href='#plot_ranks'><p>Plot individual ranks or scores</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Inferring Longitudinal Dominance Hierarchies</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1.0</td>
</tr>
<tr>
<td>Author:</td>
<td>Eli D. Strauss </td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Eli D. Strauss &lt;straussed@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides functions for inferring longitudinal dominance hierarchies, which describe dominance relationships and their dynamics in a single latent hierarchy over time. Strauss &amp; Holekamp (in press). </td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.0.2</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Imports:</td>
<td>dplyr, rlang</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/straussed/DynaRankR">https://github.com/straussed/DynaRankR</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2020-02-13 14:51:45 UTC; straussed</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2020-02-13 15:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='C.crocuta.female'>Female spotted hyena dominance data</h2><span id='topic+C.crocuta.female'></span>

<h3>Description</h3>

<p>Data structures for inferring the ranks of adult female spotted hyenas
(Crocuta crocuta) from a single social group in the Maasai Mara National
Reserve in southern Kenya. Data are from the Talek clan collected between
1988 and 1995 by the Mara Hyena Project.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>C.crocuta.female
</code></pre>


<h3>Format</h3>

<p>List of 3 elements:
</p>

<dl>
<dt>initial.ranks</dt><dd><p>Starting order of females in 1988.</p>
</dd>
<dt>contestants</dt><dd><p>Dataframe of 182 rows and 4 variables.
There is one row per female per study year. <strong>id</strong> is the identity 
of the contestant. <strong>period</strong> is the study year. <strong>convention1</strong> is
the mother of the contestant, because female spotted hyena hierarchies are 
structured by maternal rank inheritance. <strong>convention2</strong> is the
intra-litter rank for contestants who were part of a twin litter.</p>
</dd>
<dt>interactions</dt><dd><p>Dataframe of 2043 rows and 3 variables. 
Each row corresponds to the outcome of one aggressive interaction between 
adult females.</p>
</dd>
</dl>

<hr>
<h2 id='C.crocuta.male'>Male spotted hyena dominance data</h2><span id='topic+C.crocuta.male'></span>

<h3>Description</h3>

<p>Data structures for inferring the ranks of adult male spotted hyenas
(Crocuta crocuta) from a single social group in the Maasai Mara National
Reserve in southern Kenya. Data are from the Talek clan collected between
1988 and 1995 by the Mara Hyena Project.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>C.crocuta.male
</code></pre>


<h3>Format</h3>

<p>List of 3 elements:
</p>

<dl>
<dt>initial.ranks</dt><dd><p>Starting order of males in 1988.</p>
</dd>
<dt>contestants</dt><dd><p>Dataframe of 143 rows and 3 variables.
There is one row per male per study year. <strong>id</strong> is the identity 
of the contestant. <strong>period</strong> is the study year. <strong>convention1</strong> is
the date that the male joined the clan, because male spotted hyena hierarchies
are structured by a tenure-based convention.</p>
</dd>
<dt>interactions</dt><dd><p>Dataframe of 474 rows and 3 variables. 
Each row corresponds to the outcome of one aggressive interaction between 
adult males.</p>
</dd>
</dl>

<hr>
<h2 id='dyadic_similarity'>Compare two rank orderings</h2><span id='topic+dyadic_similarity'></span>

<h3>Description</h3>

<p>This function compares two rank orderings that have the same elements. 
For an order of length <em>n</em> 
there are <em>n choose 2</em> dyadic relationships implied by that order. 
For example, the order a, b, c implies that a &gt; b, a  &gt; c, and b &gt; c.
The dyadic similarity between two orders is the proportion of implied 
dyadic relationships that are shared by the two orders.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dyadic_similarity(order1, order2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dyadic_similarity_+3A_order1">order1</code></td>
<td>
<p>The first rank ordering to be compared. Alternatively, this can
be supplied as an interaction matrix with identities as the dimension names.
All identities in order1 must be in order2.</p>
</td></tr>
<tr><td><code id="dyadic_similarity_+3A_order2">order2</code></td>
<td>
<p>The second rank ordering to be compared. Alternatively, this can
be supplied as an interaction matrix with identities as the dimension names. 
All identities in order2 must be in order1.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The proportion of dyadic relationships that are shared by the two orders.
This value is 1 if the orders are identical and 0 if the orders are
exact opposites.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dyadic_similarity(letters[1:20], letters[1:20]) #identical orders
dyadic_similarity(letters[1:20], letters[20:1]) #opposite orders
dyadic_similarity(sample(letters[1:20]), sample(letters[1:20])) #random orders

</code></pre>

<hr>
<h2 id='edgelist_to_matrix'>Convert data from edgelist to interaction matrix</h2><span id='topic+edgelist_to_matrix'></span>

<h3>Description</h3>

<p>This function converts data in edgelist format to an interaction matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>edgelist_to_matrix(edgelist, identities)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="edgelist_to_matrix_+3A_edgelist">edgelist</code></td>
<td>
<p>A two column matrix or dataframe with the identities of winners in the first column and losers in the second column.</p>
</td></tr>
<tr><td><code id="edgelist_to_matrix_+3A_identities">identities</code></td>
<td>
<p>A list of contestant identities. 
This list dictates the order in which contestants are arranged in the resulting matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Produces an interaction matrix with winners in the rows and losers in the columns. 
Contestants are arranged according to the order specified by identities.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>edges &lt;- C.crocuta.female$interactions[C.crocuta.female$interactions$period == 1989,1:2]
ids &lt;- C.crocuta.female$contestants[C.crocuta.female$contestants$period == 1989,'id']
edgelist_to_matrix(edgelist = edges, identities = ids)


</code></pre>

<hr>
<h2 id='get_dynamics'>Calculate hierarchy dynamics</h2><span id='topic+get_dynamics'></span>

<h3>Description</h3>

<p>Calculates hierarchy dynamics from an inferred longitudinal hierarchy,
returning the provided longitudinal hierarchy with added columns. 
The function calculates hierarchy dynamics for each individual in each period
(excluding the first period). Dynamics can be calculated in rank units or 
score units by specifying the <strong>type</strong> parameter. Rank dynamics are returned as 
the total dynamics (delta), active dynamics (delta.active), and passive
dynamics (delta.passive). Score dynamics are calculated as delta. 
See Strauss &amp; Holekamp (in revision) for more details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_dynamics(ranks, type = c("rank", "score"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_dynamics_+3A_ranks">ranks</code></td>
<td>
<p>A dataframe such as the output of the ranking functions provided
in the DynaRankR package. Should include at least the following 
columns:
</p>

<dl>
<dt>period</dt><dd><p>Study period.</p>
</dd>
<dt>id</dt><dd><p>Identity of contestant.</p>
</dd>
<dt>rank</dt><dd><p>Rank of id in period. Only required if calculating
rank dynamics.</p>
</dd>
<dt>score</dt><dd><p>Score of id in period. Only required if calculating
score dynamics.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="get_dynamics_+3A_type">type</code></td>
<td>
<p>A character string, either 'score' or 'rank'. Determines
whether rank dynamics or score dynamics are calculated.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the supplied dataframe with new column(s) for hierarchy dynamics. 
New individuals receive NA for all dynamics because they can not have undergone any changes.
</p>


<h3>References</h3>

<p>Strauss ED &amp; Holekamp KE (in revision). Journal of Animal Ecology.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>female.ranks &lt;- informed_elo(contestants = C.crocuta.female$contestants, convention = 'mri',
initial.ranks = C.crocuta.female$initial.ranks,
interactions = C.crocuta.female$interactions)

female.ranks.score &lt;- get_dynamics(ranks = female.ranks, type = 'score')
female.ranks.rank &lt;- get_dynamics(ranks = female.ranks, type = 'rank')

</code></pre>

<hr>
<h2 id='get_edgelist'>Convert data from interaction matrix to edgelist</h2><span id='topic+get_edgelist'></span>

<h3>Description</h3>

<p>This function converts data in an interaction matrix to edgelist format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_edgelist(mat)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_edgelist_+3A_mat">mat</code></td>
<td>
<p>Interaction matrix containing outcomes of interactions. Dimension names
are interpreted as individual identities.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A two-column dataframe with winners in the first column and losers in the second column.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>edges &lt;- C.crocuta.female$interactions[C.crocuta.female$interactions$period == 1989,1:2]
ids &lt;- C.crocuta.female$contestants[C.crocuta.female$contestants$period == 1989,'id']
mat &lt;- edgelist_to_matrix(edgelist = edges, identities = ids)
get_edgelist(mat) 

</code></pre>

<hr>
<h2 id='informed_ds'>David's Score method informed by prior information</h2><span id='topic+informed_ds'></span>

<h3>Description</h3>

<p>Use David's Score method to infer a dominance hierarchy over multiple study periods.
New contestants are added according to the convention specified by the user.
Scores are calculated using Dij and are normalized.  
Full description of the addition of new individuals is described
in Strauss &amp; Holekamp (in revision). To run the original David's Score procedure,
use convention flag 'none'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>informed_ds(contestants, convention, initial.ranks = NULL, interactions)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="informed_ds_+3A_contestants">contestants</code></td>
<td>
<p>A dataframe with the identities of the contestants for 
each study period along with the relevant data for 
adding them to the hierarchy. There should be one row per
contestant per study period.
Periods should appear in chronological order.
The dataframe should contain the following columns: 
</p>

<dl>
<dt>period</dt><dd><p>Study period.</p>
</dd>
<dt>id</dt><dd><p>Identity of contestant.</p>
</dd>
<dt>convention1</dt><dd><p>The primary convention by which new
individuals are added to the hierarchy. Interpretation
of this column varies depending on the value of the 
<strong>convention</strong> argument. If <strong>convention</strong> = none, 
this column is optional.</p>
</dd>
<dt>convention2</dt><dd><p>Optional. The secondary data for 
resolving ties in convention1. Interpretation
of this column varies depending on the value of the 
<strong>convention</strong> argument.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="informed_ds_+3A_convention">convention</code></td>
<td>
<p>A flag determining how new individuals are added to the
hierarchy. The value of this flag influences how the convention1
and convention2 columns of the <strong>contestants</strong> argument are interpreted.
Currently this function supports five options:
</p>

<dl>
<dt>none</dt><dd><p>The standard David's Score procedure (using Dij) is run. 
Individuals are not added according to prior information 
and scores are calculated independently for each period.</p>
</dd>
<dt>mri</dt><dd><p>New contestants are added to the hierarchy
according to maternal rank inheritance with youngest
ascendancy. <strong>convention1</strong> should be a vector of 
mother identities for each contestant. <strong>convention2</strong>
should be an optional vector of intra-litter ranks (lower 
numbers = higher rank) for resolving the order of 
contestants from the same mother
joining the hierarchy in the same study period.</p>
</dd>
<dt>tenure</dt><dd><p>New contestants are added to the hierarchy
according their tenure in the group. <strong>convention1</strong> should be a vector of 
dates on which each contestant joined the group. <strong>convention2</strong> should be an
optional vector of numerical data for resolving ties
in convention1 (e.g., body size). Higher values are 
considered higher rank.</p>
</dd>
<dt>age</dt><dd><p>New contestants are added to the hierarchy
according their age (older = higher rank).
<strong>convention1</strong> should be a vector of birthdates or 
numerical age classes. <strong>convention2</strong> should be an
optional vector of numerical data for resolving ties
in convention1 (e.g., body size). Higher values are 
considered higher rank.</p>
</dd>
<dt>phys_attr</dt><dd><p>New contestants are added to the hierarchy
according to some physical attribute (larger value = higher rank). 
<strong>convention1</strong> should be a vector of numerical attribute
measurements. <strong>convention2</strong> should be an
optional vector of numerical data for resolving ties
in convention1. Higher values are 
considered higher rank.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="informed_ds_+3A_initial.ranks">initial.ranks</code></td>
<td>
<p>The initial ordering of individuals for the first study
period. Required if using maternal rank inheritance as the convention.
For other conventions, if initial.ranks is not specified,
the order determined by convention1 is used to create the initial order.</p>
</td></tr>
<tr><td><code id="informed_ds_+3A_interactions">interactions</code></td>
<td>
<p>A dataframe of interaction data with the following columns:
</p>

<dl>
<dt>winner</dt><dd><p>Identities of winners.</p>
</dd>
<dt>loser</dt><dd><p>Identities of losers.</p>
</dd>
<dt>period</dt><dd><p>Study period in which interactions occurred.</p>
</dd></dl>
</td></tr>
</table>


<h3>Value</h3>

<p>Produces a dataframe with the following columns: 
</p>

<dl>
<dt>period</dt><dd><p>Study period.</p>
</dd>
<dt>id</dt><dd><p>Identity of contestant.</p>
</dd>
<dt>score</dt><dd><p>David's Score of contestant.</p>
</dd>
<dt>rank</dt><dd><p>Ordinal rank of contestant in study period. Lower numbers
equal higher rank.</p>
</dd>
<dt>stan.rank</dt><dd><p>Rank of contestant standardized for group size.
Values range from 1 (highest rank) to -1 (lowest rank).</p>
</dd>
<dt>old.order</dt><dd><p>Identity of contestants arranged in the previous order (the order they
were in before updating the order based on observations from the current
study period).</p>
</dd></dl>



<h3>References</h3>

<p>Strauss ED &amp; Holekamp KE (in revision). Journal of Animal Ecology.
</p>
<p>de Vries H, Stevens JMG, Vervaecke H (2006). Animal Behavior.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##Informed ds
female.ranks &lt;- informed_ds(contestants = C.crocuta.female$contestants, convention = 'mri',
initial.ranks = C.crocuta.female$initial.ranks,
interactions = C.crocuta.female$interactions)

##Standard ds
female.ranks &lt;- informed_ds(contestants = C.crocuta.female$contestants, convention = 'none',
interactions = C.crocuta.female$interactions)                          

</code></pre>

<hr>
<h2 id='informed_elo'>Elo-rating method informed by prior information</h2><span id='topic+informed_elo'></span>

<h3>Description</h3>

<p>Use Elo-rating method to infer a dominance hierarchy over multiple study periods.
New contestants are added according to the convention specified by the user. 
Full description of the addition of new individuals is described
in Strauss &amp; Holekamp (in revision). To run the original Elo-rating procedure,
use convention flag 'none'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>informed_elo(
  contestants,
  convention,
  K = 200,
  lambda = 100,
  initial.ranks = NULL,
  interactions
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="informed_elo_+3A_contestants">contestants</code></td>
<td>
<p>A dataframe with the identities of the contestants for 
each study period along with the relevant data for 
adding them to the hierarchy. There should be one row per
contestant per study period.
Periods should appear in chronological order.
The dataframe should contain the following columns: 
</p>

<dl>
<dt>period</dt><dd><p>Study period.</p>
</dd>
<dt>id</dt><dd><p>Identity of contestant.</p>
</dd>
<dt>convention1</dt><dd><p>The primary convention by which new
individuals are added to the hierarchy. Interpretation
of this column varies depending on the value of the 
<strong>convention</strong> argument. If <strong>convention</strong> = none, 
this column is optional.</p>
</dd>
<dt>convention2</dt><dd><p>Optional. The secondary data for 
resolving ties in convention1. Interpretation
of this column varies depending on the value of the 
<strong>convention</strong> argument.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="informed_elo_+3A_convention">convention</code></td>
<td>
<p>A flag determining how new individuals are added to the
hierarchy. The value of this flag influences how the convention1
and convention2 columns of the <strong>contestants</strong> argument are interpreted.
Currently this function supports five options:
</p>

<dl>
<dt>none</dt><dd><p>The standard Elo-rating procedure is run. 
Individuals joining the hierarchy receive a score equal to 
the mean of other group members.</p>
</dd>
<dt>mri</dt><dd><p>New contestants are added to the hierarchy
according to maternal rank inheritance with youngest
ascendancy. <strong>convention1</strong> should be a vector of 
mother identities for each contestant. <strong>convention2</strong>
should be an optional vector of intra-litter ranks (lower 
numbers = higher rank) for resolving the order of 
contestants from the same mother
joining the hierarchy in the same study period.</p>
</dd>
<dt>tenure</dt><dd><p>New contestants are added to the hierarchy
according their tenure in the group. <strong>convention1</strong> should be a vector of 
dates on which each contestant joined the group. <strong>convention2</strong> should be an
optional vector of numerical data for resolving ties
in convention1 (e.g., body size). Higher values are 
considered higher rank.</p>
</dd>
<dt>age</dt><dd><p>New contestants are added to the hierarchy
according their age (older = higher rank).
<strong>convention1</strong> should be a vector of birthdates or 
numerical age classes. <strong>convention2</strong> should be an
optional vector of numerical data for resolving ties
in convention1 (e.g., body size). Higher values are 
considered higher rank.</p>
</dd>
<dt>phys_attr</dt><dd><p>New contestants are added to the hierarchy
according to some physical attribute (larger value = higher rank). 
<strong>convention1</strong> should be a vector of numerical attribute
measurements. <strong>convention2</strong> should be an
optional vector of numerical data for resolving ties
in convention1. Higher values are 
considered higher rank.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="informed_elo_+3A_k">K</code></td>
<td>
<p>Parameter influencing the magnitude of score changes after each outcome.</p>
</td></tr>
<tr><td><code id="informed_elo_+3A_lambda">lambda</code></td>
<td>
<p>Parameter influencing the shape of the logistic function
linking the difference in score between winner and loser 
to the expected probability of each contestant winning.</p>
</td></tr>
<tr><td><code id="informed_elo_+3A_initial.ranks">initial.ranks</code></td>
<td>
<p>The initial ordering of individuals for the first study
period. Required if using maternal rank inheritance as the convention.
For other conventions, if initial.ranks is not specified,
the order determined by convention1 is used to create the initial order.</p>
</td></tr>
<tr><td><code id="informed_elo_+3A_interactions">interactions</code></td>
<td>
<p>A dataframe of interaction data with the following columns:
</p>

<dl>
<dt>winner</dt><dd><p>Identities of winners.</p>
</dd>
<dt>loser</dt><dd><p>Identities of losers.</p>
</dd>
<dt>period</dt><dd><p>Study period in which interactions occurred.</p>
</dd></dl>
</td></tr>
</table>


<h3>Value</h3>

<p>Produces a dataframe with the following columns: 
</p>

<dl>
<dt>period</dt><dd><p>Study period.</p>
</dd>
<dt>id</dt><dd><p>Identity of contestant.</p>
</dd>
<dt>score</dt><dd><p>Elo-rating score of contestant.</p>
</dd>
<dt>rank</dt><dd><p>Ordinal rank of contestant in study period. Lower numbers
equal higher rank.</p>
</dd>
<dt>stan.rank</dt><dd><p>Rank of contestant standardized for group size.
Values range from 1 (highest rank) to -1 (lowest rank).</p>
</dd>
<dt>old.order</dt><dd><p>Identity of contestants arranged in the previous order (the order they
were in before updating the order based on observations from current
study period).</p>
</dd></dl>



<h3>References</h3>

<p>Strauss ED &amp; Holekamp KE (in revision). Journal of Animal Ecology.
</p>
<p>Albers PCH &amp; de Vries H (2000). Animal Behavior.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##Informed elo
female.ranks &lt;- informed_elo(contestants = C.crocuta.female$contestants, convention = 'mri',
initial.ranks = C.crocuta.female$initial.ranks,
interactions = C.crocuta.female$interactions)

##Standard elo
female.ranks &lt;- informed_elo(contestants = C.crocuta.female$contestants, convention = 'none',
interactions = C.crocuta.female$interactions)

</code></pre>

<hr>
<h2 id='informed_matreorder'>Infer longitudinal hierarchy using informed matrix reordering</h2><span id='topic+informed_matreorder'></span>

<h3>Description</h3>

<p>Implements the Informed MatReorder method described in Strauss &amp; Holekamp (in revision)
to infer a dominance hierarchy over multiple study periods. For each
study period, ranks are inferred as modifications of the ranks from the previous
study period. First, new contestants are added according to the convention specified
by the user, and emigrated/dead contestants are removed. Then, matrix reordering is used
to change the position of contestants for whom data from the current study period
are inconsistent with this ordering. The optimal order is selected as the order 
that is most consistent with the data from the current period and is minimally 
changed from the previous study period.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>informed_matreorder(
  contestants,
  convention,
  n = 50,
  shuffles = 10,
  require.corroboration = FALSE,
  initial.ranks = NULL,
  interactions
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="informed_matreorder_+3A_contestants">contestants</code></td>
<td>
<p>A dataframe with the identities of the contestants for 
each study period along with the relevant data for 
adding them to the hierarchy. There should be one row per
contestant per study period.
Periods should appear in chronological order.
The dataframe should contain the following columns: 
</p>

<dl>
<dt>period</dt><dd><p>Study period.</p>
</dd>
<dt>id</dt><dd><p>Identity of contestant.</p>
</dd>
<dt>convention1</dt><dd><p>The primary convention by which new
individuals are added to the hierarchy. Interpretation
of this column varies depending on the value of the 
<strong>convention</strong> argument.</p>
</dd>
<dt>convention2</dt><dd><p>Optional. The secondary data for 
resolving ties in convention1. Interpretation
of this column varies depending on the value of the 
<strong>convention</strong> argument.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="informed_matreorder_+3A_convention">convention</code></td>
<td>
<p>A flag determining how new individuals are added to the
hierarchy. The value of this flag influences how the convention1
and convention2 columns of the contestants argument are interpreted.
Currently this function supports four options:
</p>

<dl>
<dt>mri</dt><dd><p>New contestants are added to the hierarchy
according to maternal rank inheritance with youngest
ascendancy. <strong>convention1</strong> should be a vector of 
mother identities for each contestant. <strong>convention2</strong>
should be an optional vector of intra-litter ranks (lower 
numbers = higher rank) for resolving the order of 
contestants from the same mother
joining the hierarchy in the same study period.</p>
</dd>
<dt>tenure</dt><dd><p>New contestants are added to the hierarchy
according their tenure in the group. <strong>convention1</strong> should be a vector of 
dates on which each contestant joined the group. <strong>convention2</strong> should be an
optional vector of numerical data for resolving ties
in convention1 (e.g., body size). Higher values are 
considered higher rank.</p>
</dd>
<dt>age</dt><dd><p>New contestants are added to the hierarchy
according their age (older = higher rank).
<strong>convention1</strong> should be a vector of birthdates or 
numerical age classes. <strong>convention2</strong> should be an
optional vector of numerical data for resolving ties
in convention1 (e.g., body size). Higher values are 
considered higher rank.</p>
</dd>
<dt>phys_attr</dt><dd><p>New contestants are added to the hierarchy
according to some physical attribute (larger value = higher rank). 
<strong>convention1</strong> should be a vector of numerical attribute
measurements. <strong>convention2</strong> should be an
optional vector of numerical data for resolving ties
in convention1. Higher values are 
considered higher rank.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="informed_matreorder_+3A_n">n</code></td>
<td>
<p>Number of separate reordering attempts per study period. Recommended 100.</p>
</td></tr>
<tr><td><code id="informed_matreorder_+3A_shuffles">shuffles</code></td>
<td>
<p>Number of reshuffling steps per reordering attempt. Recommended at least 10.</p>
</td></tr>
<tr><td><code id="informed_matreorder_+3A_require.corroboration">require.corroboration</code></td>
<td>
<p>A logical indicating whether to require corroborating
evidence from multiple study periods before changing a contestant's position
in the order. Useful for reducing the sensitivity of the method to aberrant
observations that don't reflect a lasting change in the true latent hierarchy.
If true, evidence indicating a change in status must be corroborated by
an additional observation in the following periods. See Strauss &amp; Holekamp
(in revision) for full details.</p>
</td></tr>
<tr><td><code id="informed_matreorder_+3A_initial.ranks">initial.ranks</code></td>
<td>
<p>The initial ordering of individuals for the first study
period. Required if using maternal rank inheritance as the convention.
For other conventions, if initial.ranks is not specified,
the order determined by convention1 is used to create the initial order.</p>
</td></tr>
<tr><td><code id="informed_matreorder_+3A_interactions">interactions</code></td>
<td>
<p>A dataframe of interaction data with the following columns:
</p>

<dl>
<dt>winner</dt><dd><p>Identities of winners.</p>
</dd>
<dt>loser</dt><dd><p>Identities of losers.</p>
</dd>
<dt>period</dt><dd><p>Study period in which interactions occurred.</p>
</dd></dl>
</td></tr>
</table>


<h3>Value</h3>

<p>Produces a dataframe with the following columns: 
</p>

<dl>
<dt>period</dt><dd><p>Study period.</p>
</dd>
<dt>id</dt><dd><p>Identity of contestant.</p>
</dd>
<dt>rank</dt><dd><p>Ordinal rank of contestant in study period. Lower numbers
equal higher rank.</p>
</dd>
<dt>stan.rank</dt><dd><p>Rank of contestant standardized for group size.
Values range from 1 (highest rank) to -1 (lowest rank).</p>
</dd>
<dt>old.order</dt><dd><p>Identity of contestants arranged in the previous order (the order they
were in before updating the order based on observations from current
study period).</p>
</dd>
</dl>



<h3>References</h3>

<p>Strauss ED &amp; Holekamp KE (in revision). Journal of Animal Ecology.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>conts &lt;- C.crocuta.female$contestants[C.crocuta.female$contestants$period &lt;= 1990,]
female.ranks &lt;- informed_matreorder(contestants = conts, 
convention = 'mri', n =1, shuffles = 10, require.corroboration = TRUE, 
initial.ranks = C.crocuta.female$initial.ranks,
interactions = C.crocuta.female$interactions)


</code></pre>

<hr>
<h2 id='plot_ranks'>Plot individual ranks or scores</h2><span id='topic+plot_ranks'></span>

<h3>Description</h3>

<p>Plot ranks of individuals in a single social group over multiple study periods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_ranks(ranks, type = c("rank", "stan.rank", "score"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_ranks_+3A_ranks">ranks</code></td>
<td>
<p>A dataframe of ranks. There should be one row per contestant per
study period. Must include at least the following columns:
</p>

<dl>
<dt>period</dt><dd><p>Study periods. They should appear in chronological order.</p>
</dd>
<dt>id</dt><dd><p>The identity of each contestant. Each contestant should appear
once per study period.</p>
</dd>
<dt>rank</dt><dd><p>The rank of each contestant in each study period. This can be
absolute rank or standardized rank. Only required if <strong>type</strong>
is 'rank'.</p>
</dd>
<dt>score</dt><dd><p>The score of each contestant. Only required if <strong>type</strong>
is 'score'.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="plot_ranks_+3A_type">type</code></td>
<td>
<p>A character string, either 'score', 'rank', or 'stan.rank'. Determines
whether scores, ranks, or standardized ranks are plotted.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>female.ranks &lt;- informed_elo(contestants = C.crocuta.female$contestants, convention = 'mri',
initial.ranks = C.crocuta.female$initial.ranks,
interactions = C.crocuta.female$interactions)

plot_ranks(female.ranks, type = 'rank')
plot_ranks(female.ranks, type = 'score')
plot_ranks(female.ranks, type = 'stan.rank')

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
