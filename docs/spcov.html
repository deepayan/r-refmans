<!DOCTYPE html><html><head><title>Help for package spcov</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {spcov}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#GenerateCliquesCovariance'><p>Generate a block diagonal covariance matrix</p></a></li>
<li><a href='#ProxADMM'><p>Solving penalized Frobenius problem.</p></a></li>
<li><a href='#spcov'><p>Sparse Covariance Estimation</p></a></li>
<li><a href='#spcov-package'><p>Sparse Estimation of a Covariance Matrix</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Sparse Estimation of a Covariance Matrix</td>
</tr>
<tr>
<td>Version:</td>
<td>1.3</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-09-21</td>
</tr>
<tr>
<td>Author:</td>
<td>Jacob Bien and Rob Tibshirani</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Jacob Bien &lt;jbien@usc.edu&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides a covariance estimator for multivariate normal
        data that is sparse and positive definite.  Implements the
        majorize-minimize algorithm described in Bien, J., and
        Tibshirani, R. (2011), "Sparse Estimation of a Covariance
        Matrix," Biometrika. 98(4). 807&ndash;820.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-09-23 16:43:26 UTC; jacobbien</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-09-23 20:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='GenerateCliquesCovariance'>Generate a block diagonal covariance matrix</h2><span id='topic+GenerateCliquesCovariance'></span>

<h3>Description</h3>

<p>This function is included in the package so that it can be used in the
example code provided in <code><a href="#topic+spcov">spcov</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GenerateCliquesCovariance(ncliques, cliquesize, theta)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GenerateCliquesCovariance_+3A_ncliques">ncliques</code></td>
<td>
<p>number of blocks</p>
</td></tr>
<tr><td><code id="GenerateCliquesCovariance_+3A_cliquesize">cliquesize</code></td>
<td>
<p>size of each block</p>
</td></tr>
<tr><td><code id="GenerateCliquesCovariance_+3A_theta">theta</code></td>
<td>
<p>magnitude of non-zeros</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function generates a block diagonal positive definite matrix with
randomly-signed, non-zero elements.  A shift is added to the diagonal of the
matrix so that its condition number equals <code>p</code>, the number of
variables.
</p>


<h3>Value</h3>

<table>
<tr><td><code>Sigma</code></td>
<td>
<p>the covariance matrix</p>
</td></tr> <tr><td><code>A</code></td>
<td>
<p>symmetric square root
of <code>Sigma</code></p>
</td></tr> <tr><td><code>shift</code></td>
<td>
<p>how much the eigenvalues were shifted.  See
details.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jacob Bien and Rob Tibshirani
</p>


<h3>References</h3>

<p>Bien, J., and Tibshirani, R. (2011), &quot;Sparse Estimation of a
Covariance Matrix,&quot; accepted for publication in Biometrika.
</p>

<hr>
<h2 id='ProxADMM'>Solving penalized Frobenius problem.</h2><span id='topic+ProxADMM'></span>

<h3>Description</h3>

<p>This function solves the optimization problem
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ProxADMM(A, del, lam, P, rho = 0.1, tol = 1e-06, maxiters = 100, verb = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ProxADMM_+3A_a">A</code></td>
<td>
<p>A symmetric matrix.</p>
</td></tr>
<tr><td><code id="ProxADMM_+3A_del">del</code></td>
<td>
<p>A non-negative scalar. Lower bound on eigenvalues.</p>
</td></tr>
<tr><td><code id="ProxADMM_+3A_lam">lam</code></td>
<td>
<p>A non-negative scalar. L1 penalty parameter.</p>
</td></tr>
<tr><td><code id="ProxADMM_+3A_p">P</code></td>
<td>
<p>Matrix with non-negative elements and dimension of A. Allows for
differing L1 penalty parameters.</p>
</td></tr>
<tr><td><code id="ProxADMM_+3A_rho">rho</code></td>
<td>
<p>ADMM parameter.  Can affect rate of convergence a lot.</p>
</td></tr>
<tr><td><code id="ProxADMM_+3A_tol">tol</code></td>
<td>
<p>Convergence threshold.</p>
</td></tr>
<tr><td><code id="ProxADMM_+3A_maxiters">maxiters</code></td>
<td>
<p>Maximum number of iterations.</p>
</td></tr>
<tr><td><code id="ProxADMM_+3A_verb">verb</code></td>
<td>
<p>Controls whether to be verbose.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Minimize_X (1/2)||X - A||_F^2 + lam||P*X||_1 s.t. X &gt;= del * I.
</p>
<p>This is the prox function for the generalized gradient descent of Bien &amp;
Tibshirani 2011 (see full reference below).
</p>
<p>This is the R implementation of the algorithm in Appendix 3 of Bien, J., and
Tibshirani, R. (2011), &quot;Sparse Estimation of a Covariance Matrix,&quot;
Biometrika. 98(4). 807&ndash;820.  It uses an ADMM approach to solve the problem
</p>
<p>Minimize_X (1/2)||X - A||_F^2 + lam||P*X||_1 s.t. X &gt;= del * I.
</p>
<p>Here, the multiplication between P and X is elementwise.  The inequality in
the constraint is a lower bound on the minimum eigenvalue of the matrix X.
</p>
<p>Note that there are two variables X and Z that are outputted.  Both are
estimates of the optimal X.  However, Z has exact zeros whereas X has
eigenvalues at least del.  Running the ADMM algorithm long enough, these two
are guaranteed to converge.
</p>


<h3>Value</h3>

<table>
<tr><td><code>X</code></td>
<td>
<p>Estimate of optimal X.</p>
</td></tr> <tr><td><code>Z</code></td>
<td>
<p>Estimate of optimal X.</p>
</td></tr>
<tr><td><code>obj</code></td>
<td>
<p>Objective values.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jacob Bien and Rob Tibshirani
</p>


<h3>References</h3>

<p>Bien, J., and Tibshirani, R. (2011), &quot;Sparse Estimation of a
Covariance Matrix,&quot; Biometrika. 98(4). 807&ndash;820.
</p>


<h3>See Also</h3>

<p>spcov
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(1)
n &lt;- 100
p &lt;- 200
# generate a covariance matrix:
model &lt;- GenerateCliquesCovariance(ncliques=4, cliquesize=p / 4, 1)

# generate data matrix with x[i, ] ~ N(0, model$Sigma):
x &lt;- matrix(rnorm(n * p), ncol=p) %*% model$A
S &lt;- var(x)

# compute sparse, positive covariance estimator:
P &lt;- matrix(1, p, p)
diag(P) &lt;- 0
lam &lt;- 0.1
aa &lt;- ProxADMM(S, 0.01, lam, P)

</code></pre>

<hr>
<h2 id='spcov'>Sparse Covariance Estimation</h2><span id='topic+spcov'></span>

<h3>Description</h3>

<p>Provides a sparse and positive definite estimate of a covariance matrix.
This function performs the majorize-minimize algorithm described in Bien &amp;
Tibshirani 2011 (see full reference below).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spcov(
  Sigma,
  S,
  lambda,
  step.size,
  nesterov = TRUE,
  n.outer.steps = 10000,
  n.inner.steps = 10000,
  tol.outer = 1e-04,
  thr.inner = 0.01,
  backtracking = 0.2,
  trace = 0
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spcov_+3A_sigma">Sigma</code></td>
<td>
<p>an initial guess for Sigma (suggestions: <code>S</code> or
<code>diag(diag(S)))</code>.</p>
</td></tr>
<tr><td><code id="spcov_+3A_s">S</code></td>
<td>
<p>the empirical covariance matrix of the data.  Must be positive
definite (if it is not, add a small constant to the diagonal).</p>
</td></tr>
<tr><td><code id="spcov_+3A_lambda">lambda</code></td>
<td>
<p>penalty parameter.  Either a scalar or a matrix of the same
dimension as <code>Sigma</code>.  This latter choice should be used to penalize
only off-diagonal elements.  All elements of <code>lambda</code> must be
non-negative.</p>
</td></tr>
<tr><td><code id="spcov_+3A_step.size">step.size</code></td>
<td>
<p>the step size to use in generalized gradient descent.
Affects speed of algorithm.</p>
</td></tr>
<tr><td><code id="spcov_+3A_nesterov">nesterov</code></td>
<td>
<p>indicates whether to use Nesterov's modification of
generalized gradient descent. Default: <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="spcov_+3A_n.outer.steps">n.outer.steps</code></td>
<td>
<p>maximum number of majorize-minimize steps to take
(recall that MM is the outer loop).</p>
</td></tr>
<tr><td><code id="spcov_+3A_n.inner.steps">n.inner.steps</code></td>
<td>
<p>maximum number of generalized gradient steps to take
(recall that generalized gradient descent is the inner loop).</p>
</td></tr>
<tr><td><code id="spcov_+3A_tol.outer">tol.outer</code></td>
<td>
<p>convergence threshold for outer (MM) loop.  Stops when drop
in objective between steps is less than <code>tol.outer</code>.</p>
</td></tr>
<tr><td><code id="spcov_+3A_thr.inner">thr.inner</code></td>
<td>
<p>convergence threshold for inner (i.e. generalized gradient)
loop.  Stops when mean absolute change in <code>Sigma</code> is less than
<code>thr.inner * mean(abs(S))</code>.</p>
</td></tr>
<tr><td><code id="spcov_+3A_backtracking">backtracking</code></td>
<td>
<p>if <code>FALSE</code>, then fixed step size used.  If numeric
and in (0,1), this is the parameter of backtracking that multiplies
<code>step.size</code> on each step.  Usually, in range of (0.1, 0.8). Default:
<code>0.2</code>.</p>
</td></tr>
<tr><td><code id="spcov_+3A_trace">trace</code></td>
<td>
<p>controls how verbose output should be.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is the R implementation of Algorithm 1 in Bien, J., and Tibshirani, R.
(2011), &quot;Sparse Estimation of a Covariance Matrix,&quot; Biometrika. 98(4).
807&ndash;820.  The goal is to approximately minimize (over Sigma) the following
non-convex optimization problem:
</p>
<p>minimize logdet(Sigma) + trace(S Sigma^-1) + || lambda*Sigma ||_1 subject to
Sigma positive definite.
</p>
<p>Here, the L1 norm and matrix multiplication between lambda and Sigma are
elementwise.  The empirical covariance matrix must be positive definite for
the optimization problem to have bounded objective (see Section 3.3 of
paper). We suggest adding a small constant to the diagonal of S if it is
not.  Since the above problem is not convex, the returned matrix is not
guaranteed to be a global minimum of the problem.
</p>
<p>In Section 3.2 of the paper, we mention a simple modification of gradient
descent due to Nesterov.  The argument <code>nesterov</code> controls whether to
use this modification (we suggest that it be used).  We also strongly
recommend using backtracking.  This allows the algorithm to begin by taking
large steps (the initial size is determined by the argument
<code>step.size</code>) and then to gradually reduce the size of steps.
</p>
<p>At the start of the algorithm, a lower bound (<code>delta</code> in the paper) on
the eigenvalues of the solution is calculated.  As shown in Equation (3) of
the paper, the prox function for our generalized gradient descent amounts to
minimizing (over a matrix X) a problem of the form
</p>
<p>minimize (1/2)|| X-A ||_F^2 + || lambda*X ||_1 subject to X &gt;= delta I
</p>
<p>This is implemented using an alternating direction method of multipliers
approach given in Appendix 3.
</p>


<h3>Value</h3>

<table>
<tr><td><code>Sigma</code></td>
<td>
<p>the sparse covariance estimate</p>
</td></tr> <tr><td><code>n.iter</code></td>
<td>
<p>a vector
giving the number of generalized gradient steps taken on each step of the MM
algorithm</p>
</td></tr> <tr><td><code>obj</code></td>
<td>
<p>a vector giving the objective values after each step
of the MM algorithm</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jacob Bien and Rob Tibshirani
</p>


<h3>References</h3>

<p>Bien, J., and Tibshirani, R. (2011), &quot;Sparse Estimation of a
Covariance Matrix,&quot; Biometrika. 98(4). 807&ndash;820.
</p>


<h3>See Also</h3>

<p>ProxADMM
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(1)
n &lt;- 100
p &lt;- 20
# generate a covariance matrix:
model &lt;- GenerateCliquesCovariance(ncliques=4, cliquesize=p / 4, 1)

# generate data matrix with x[i, ] ~ N(0, model$Sigma):
x &lt;- matrix(rnorm(n * p), ncol=p) %*% model$A
S &lt;- var(x)

# compute sparse, positive covariance estimator:
step.size &lt;- 100
tol &lt;- 1e-3
P &lt;- matrix(1, p, p)
diag(P) &lt;- 0
lam &lt;- 0.06
mm &lt;- spcov(Sigma=S, S=S, lambda=lam * P,
            step.size=step.size, n.inner.steps=200,
            thr.inner=0, tol.outer=tol, trace=1)
sqrt(mean((mm$Sigma - model$Sigma)^2))
sqrt(mean((S - model$Sigma)^2))
## Not run: image(mm$Sigma!=0)

</code></pre>

<hr>
<h2 id='spcov-package'>Sparse Estimation of a Covariance Matrix</h2><span id='topic+spcov-package'></span>

<h3>Description</h3>

<p>Performs the majorize-minimize algorithm described in
</p>


<h3>Details</h3>

<p>Bien, J., and Tibshirani, R. (2011), &quot;Sparse Estimation of a Covariance
Matrix,&quot; Biometrika. 98(4). 807&ndash;820.
</p>
<p>Generalized gradient descent is used to minimize each majorizer.
</p>

<table>
<tr>
 <td style="text-align: left;"> Package: </td><td style="text-align: left;"> spcov</td>
</tr>
<tr>
 <td style="text-align: left;"> Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;"> Version: </td><td style="text-align: left;">
1.01</td>
</tr>
<tr>
 <td style="text-align: left;"> Date: </td><td style="text-align: left;"> 2012-03-04</td>
</tr>
<tr>
 <td style="text-align: left;"> License: </td><td style="text-align: left;"> GPL-2</td>
</tr>
<tr>
 <td style="text-align: left;"> LazyLoad: </td><td style="text-align: left;">
yes</td>
</tr>
<tr>
 <td style="text-align: left;"> </td>
</tr>

</table>
<p> See the function <code>spcov</code>.
</p>


<h3>Author(s)</h3>

<p>Jacob Bien and Rob Tibshirani
</p>
<p>Maintainer: Jacob Bien &lt;jbien@stanford.edu&gt;
</p>


<h3>References</h3>

<p>Bien, J., and Tibshirani, R. (2011), &quot;Sparse Estimation of a
Covariance Matrix,&quot; Biometrika. 98(4). 807&ndash;820.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+spcov">spcov</a></code>
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
