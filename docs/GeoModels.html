<!DOCTYPE html><html><head><title>Help for package GeoModels</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {GeoModels}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#anomalies'><p>Annual precipitation anomalies in U.S.</p></a></li>
<li><a href='#austemp'><p>Maximum australian temperature</p></a></li>
<li><a href='#CheckBiv'><p>Checking Bivariate covariance models</p></a></li>
<li><a href='#CheckDistance'><p>Checking Distance</p></a></li>
<li><a href='#CheckSph'><p>Checking if a covariance is valid only on the sphere</p></a></li>
<li><a href='#CheckST'><p>Checking SpaceTime covariance models</p></a></li>
<li><a href='#CkCorrModel'><p>Checking Correlation Model</p></a></li>
<li><a href='#CkInput'><p>Checking Input</p></a></li>
<li><a href='#CkLikelihood'><p>Checking Composite-likelihood Type</p></a></li>
<li><a href='#CkModel'><p>Checking Random Field type</p></a></li>
<li><a href='#CkType'><p>Checking Likelihood Objects</p></a></li>
<li><a href='#CkVarType'><p>Checking Variance Estimates Type</p></a></li>
<li><a href='#CompIndLik2'><p>Optimizes the Composite indipendence log-likelihood</p></a></li>
<li><a href='#CompLik'><p>Optimizes the Composite log-likelihood</p></a></li>
<li><a href='#CompLik2'><p>Optimizes the Composite log-likelihood</p></a></li>
<li><a href='#CorrelationPar'><p>Lists the Parameters of a Correlation Model</p></a></li>
<li><a href='#CorrParam'><p>Lists the Parameters of a Correlation Model</p></a></li>
<li><a href='#GeoAniso'><p>Spatial Anisotropy correction</p></a></li>
<li><a href='#GeoCorrFct'><p>Spatial and Spatio-temporal correlation or  covariance of (non) Gaussian random fields</p></a></li>
<li><a href='#GeoCorrFct_Cop'><p>Spatial and Spatio-temporal correlation or  covariance of (non) Gaussian random fields (copula models)</p></a></li>
<li><a href='#GeoCovariogram'><p>Computes the fitted  variogram model.</p></a></li>
<li><a href='#GeoCovDisplay'><p>Image plot displaying the pattern of the sparsness  of a  covariance matrix.</p></a></li>
<li><a href='#GeoCovmatrix'><p>Spatial and Spatio-temporal Covariance Matrix of (non) Gaussian random fields</p></a></li>
<li><a href='#GeoCV'><p>n-fold  kriging Cross-validation</p></a></li>
<li><a href='#GeoFit'><p>Max-Likelihood-Based Fitting of Gaussian and non Gaussian random fieldss.</p></a></li>
<li><a href='#GeoFit2'><p>Max-Likelihood-Based Fitting of Gaussian and non Gaussian RFs.</p></a></li>
<li><a href='#GeoKrig'><p>Spatial (bivariate) and spatio temporal optimal linear prediction</p>
for Gaussian and non Gaussian random fields.</a></li>
<li><a href='#GeoKrigloc'><p>Spatial (bivariate) and spatio temporal optimal linear  local  prediction</p>
for Gaussian and non Gaussian RFs.</a></li>
<li><a href='#GeoNA'><p>Deleting  NA values (missing values) from a spatial or spatio-temporal dataset.</p></a></li>
<li><a href='#GeoNeighborhood'><p>Spatio (temporal) neighborhood selection for local kriging.</p></a></li>
<li><a href='#GeoNeighIndex'><p>Spatial or spatiotemporal  near neighbour indices.</p></a></li>
<li><a href='#GeoNosymindices'><p>GeoNosymindices.</p></a></li>
<li><a href='#GeoOutlier'><p>Spatio (temporal) outliers detection</p></a></li>
<li><a href='#GeoPit'><p>Probability integral  or normal score tranformation</p></a></li>
<li><a href='#GeoQQ'><p>Quantile-quantile plot</p></a></li>
<li><a href='#GeoResiduals'><p>Computes fitted covariance and/or  variogram</p></a></li>
<li><a href='#GeoScatterplot'><p>h-scatterplot for space and space-time data.</p></a></li>
<li><a href='#GeoSim'><p>Simulation of Gaussian and non Gaussian Random Fields.</p></a></li>
<li><a href='#GeoSimapprox'><p>Fast simulation of Gaussian and non Gaussian Random Fields.</p></a></li>
<li><a href='#GeoSimCopula'><p>Simulation of Gaussian and non Gaussian Random Fields using copula.</p></a></li>
<li><a href='#GeoTests'><p>Statistical Hypothesis Tests for Nested Models</p></a></li>
<li><a href='#GeoVarestbootstrap'><p>Update a <code>GeoFit</code> object   using parametric bootstrap for std error estimation</p></a></li>
<li><a href='#GeoVariogram'><p>Empirical semi-variogram estimation</p></a></li>
<li><a href='#GeoWLS'><p>WLS of Random Fields</p></a></li>
<li><a href='#Lik'><p>Optimizes the Log Likelihood</p></a></li>
<li><a href='#MatDecomp'><p>Matrix decomposition</p></a></li>
<li><a href='#MatSqrt, MatInv, MatLogDet'><p>Square root, inverse  and  log determinant of a (semi)positive definite matrix, given a matrix decomposition.</p></a></li>
<li><a href='#NuisParam'><p>Lists the Nuisance Parameters of a Random Field</p></a></li>
<li><a href='#NuisParam2'><p>Internal function handling Nuisance Parameters of a Random Field</p></a></li>
<li><a href='#plot.GeoVariogram'><p>Plot empirical spatial, spatio-temporal and spatial bivariate semi-Variogram</p></a></li>
<li><a href='#Prscores'>
<p>Computation of three predictive scores: RMSE, LSCORE, CRPS based on drop-one</p>
cross-validation prediction for spatial, spatiotemporal and bivariate Gaussian RF.</a></li>
<li><a href='#SimCE'><p>Circulant embeeding simulation</p></a></li>
<li><a href='#sp2Geo'><p>Extracting information from an sp or spacetime object</p></a></li>
<li><a href='#spanish_wind'><p>August monthly average wind speed in Spain between 1970-2000</p></a></li>
<li><a href='#StartParam'><p>Initializes the Parameters for Estimation Procedures</p></a></li>
<li><a href='#winds'><p>Irish Daily Wind Speeds</p></a></li>
<li><a href='#winds.coords'><p>Weather Stations of the Irish Daily Wind Speeds</p></a></li>
<li><a href='#WlsStart'><p>Computes Starting Values based on Weighted Least Squares</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Procedures for Gaussian and Non Gaussian Geostatistical (Large)
Data Analysis</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1.9</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-03-18</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Moreno Bevilacqua &lt;moreno.bevilacqua89@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Functions for Gaussian and Non Gaussian (bivariate) spatial and spatio-temporal data analysis are provided for a) simulation and inference  for random fields using standard likelihood and a likelihood approximation  method called  weighted composite likelihood based on pairs and b) prediction using (local) best linear unbiased prediction. Weighted composite likelihood can be very efficient for estimating massive datasets. Both regression and spatial (temporal) dependence analysis can be jointly performed. Covariance functions for spatial and spatial-temporal data on Euclidean domains and spheres are provided. There are also many useful functions for plotting and performing diagnostic analysis. Different non Gaussian random fields can be considered in the analysis. Among them, random fields with marginal distributions such as Skew-Gaussian, Student-t, Tukey-h, Sin-Arcsin, Two-piece, Weibull, Gamma, Log-Gaussian, Binomial, Negative Binomial  and Poisson. See the URL for the papers associated with this package, as for instance, Bevilacqua and Gaetan (2015) &lt;<a href="https://doi.org/10.1007%2Fs11222-014-9460-6">doi:10.1007/s11222-014-9460-6</a>&gt;, Bevilacqua et al. (2016) &lt;<a href="https://doi.org/10.1007%2Fs13253-016-0256-3">doi:10.1007/s13253-016-0256-3</a>&gt;, Vallejos et al. (2020) &lt;<a href="https://doi.org/10.1007%2F978-3-030-56681-4">doi:10.1007/978-3-030-56681-4</a>&gt;, Bevilacqua et. al (2020) &lt;<a href="https://doi.org/10.1002%2Fenv.2632">doi:10.1002/env.2632</a>&gt;, Bevilacqua et. al (2021) &lt;<a href="https://doi.org/10.1111%2Fsjos.12447">doi:10.1111/sjos.12447</a>&gt;, Bevilacqua et al. (2022) &lt;<a href="https://doi.org/10.1016%2Fj.jmva.2022.104949">doi:10.1016/j.jmva.2022.104949</a>&gt;, Morales-Navarrete et al. (2023) &lt;<a href="https://doi.org/10.1080%2F01621459.2022.2140053">doi:10.1080/01621459.2022.2140053</a>&gt;, and a large class of examples and tutorials.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.1.0), GPvecchia,fields, mapproj, shape, codetools</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Imports:</td>
<td>methods, spam, scatterplot3d, dfoptim, dotCall64,
optimParallel, parallel, plotrix, pracma, pbivnorm, zipfR,
sn,sp, nabor, numDeriv, hypergeo, lamW, GpGp,VGAM, data.table</td>
</tr>
<tr>
<td>Suggests:</td>
<td>actuar, GoFKernel</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://vmoprojs.github.io/GeoModels-page/">https://vmoprojs.github.io/GeoModels-page/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/vmoprojs/GeoModels/issues">https://github.com/vmoprojs/GeoModels/issues</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-03-21 08:06:10 UTC; morenobevilacqua</td>
</tr>
<tr>
<td>Author:</td>
<td>Moreno Bevilacqua <a href="https://orcid.org/0000-0001-8384-840X"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Víctor Morales-Oñate
    <a href="https://orcid.org/0000-0003-1922-6571"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  Christian Caamaño-Carrillo
    <a href="https://orcid.org/0000-0001-7241-3099"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut]</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-03-21 08:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='anomalies'>Annual precipitation anomalies in U.S.</h2><span id='topic+anomalies'></span>

<h3>Description</h3>

<p>A (<code class="reqn">7252 x 3</code>)-matrix containing lon/lat 
and yearly total precipitation anomalies registered at 7.352 location sites in USA.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(anomalies)</code></pre>


<h3>Format</h3>

<p>A numerical matrix of dimension <code class="reqn">7252 x 3</code>.</p>


<h3>Source</h3>

<p>Kaufman, C.G., Schervish, M.J., Nychka, D.W. (2008)
Covariance tapering for likelihood-based estimation in large spatial data sets.
<em>Journal of the American Statistical Association, Theory &amp; Methods</em>, <b>103</b>, 1545&ndash;1555.
</p>

<hr>
<h2 id='austemp'>Maximum australian temperature</h2><span id='topic+austemp'></span>

<h3>Description</h3>

<p>A matrix containing maximum  temperature in Australia in July 2011.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(austemp)</code></pre>


<h3>Format</h3>

<p>A (<code class="reqn">446 \times 4</code>)-matrix containing longitude, latitude, maximum temperature,
and the 'so called'  geometric temperature covariate.</p>


<h3>Source</h3>

<p>Bevilacqua M., Caamaño C., Morales-Oñate V.,   Arellano-Valle R. B. (2020)
Non-Gaussian Geostatistical Modeling using (skew) t Processes,
<em>Scandinavian Journal of  Statistics</em>.
</p>

<hr>
<h2 id='CheckBiv'>Checking Bivariate covariance models</h2><span id='topic+CheckBiv'></span>

<h3>Description</h3>

<p>The procedure control if the correlation model is bivariate.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CheckBiv(numbermodel)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CheckBiv_+3A_numbermodel">numbermodel</code></td>
<td>
<p>numeric; the number associated to a given correlation model.</p>
</td></tr>
</table>


<h3>Details</h3>

 
<p>The function check if  the correlation model is bivariate.
</p>


<h3>Value</h3>

<p>Return TRUE or FALSE depending if the correlation model is bivariate or not.
</p>


<h3>Author(s)</h3>

<p>Moreno Bevilacqua, <a href="mailto:moreno.bevilacqua89@gmail.com">moreno.bevilacqua89@gmail.com</a>,<a href="https://sites.google.com/view/moreno-bevilacqua/home">https://sites.google.com/view/moreno-bevilacqua/home</a>,
Víctor Morales Oñate, <a href="mailto:victor.morales@uv.cl">victor.morales@uv.cl</a>, <a href="https://sites.google.com/site/moralesonatevictor/">https://sites.google.com/site/moralesonatevictor/</a>,
Christian&quot;, Caamaño-Carrillo, <a href="mailto:chcaaman@ubiobio.cl">chcaaman@ubiobio.cl</a>,<a href="https://www.researchgate.net/profile/Christian-Caamano">https://www.researchgate.net/profile/Christian-Caamano</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(GeoModels)
CheckBiv(CkCorrModel("Bi_matern_sep"))

</code></pre>

<hr>
<h2 id='CheckDistance'>Checking Distance</h2><span id='topic+CheckDistance'></span>

<h3>Description</h3>

<p>The procedure controls the type of distance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CheckDistance(distance)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CheckDistance_+3A_distance">distance</code></td>
<td>
<p>String; the type of distance, for the
description see <code><a href="#topic+GeoCovmatrix">GeoCovmatrix</a></code>.
Default is <code>Eucl</code>. Other possible values are <code>Geod</code> 
and <code>Chor</code> that is euclidean, geodesic and chordal distance.</p>
</td></tr>
</table>


<h3>Details</h3>

<p> The function check if  the type of distance is valid.</p>


<h3>Value</h3>

<p>Returns 0,1,2 for  euclidean,geodesic, chordal distances 
respectively. Otherwise returns NULL.</p>


<h3>Author(s)</h3>

<p>Moreno Bevilacqua, <a href="mailto:moreno.bevilacqua89@gmail.com">moreno.bevilacqua89@gmail.com</a>,<a href="https://sites.google.com/view/moreno-bevilacqua/home">https://sites.google.com/view/moreno-bevilacqua/home</a>,
Víctor Morales Oñate, <a href="mailto:victor.morales@uv.cl">victor.morales@uv.cl</a>, <a href="https://sites.google.com/site/moralesonatevictor/">https://sites.google.com/site/moralesonatevictor/</a>,
Christian&quot;, Caamaño-Carrillo, <a href="mailto:chcaaman@ubiobio.cl">chcaaman@ubiobio.cl</a>,<a href="https://www.researchgate.net/profile/Christian-Caamano">https://www.researchgate.net/profile/Christian-Caamano</a>
</p>

<hr>
<h2 id='CheckSph'>Checking if a covariance is valid only on the sphere</h2><span id='topic+CheckSph'></span>

<h3>Description</h3>

<p>Subroutine called by InitParam.
The procedure controls if a covariance model is valid only on the sphere.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CheckSph(numbermodel)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CheckSph_+3A_numbermodel">numbermodel</code></td>
<td>
<p>Numeric; the code number for the covariance model.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function checks if a covariance is valid only on the sphere</p>


<h3>Value</h3>

<p>Returns TRUE or FALSE</p>


<h3>Author(s)</h3>

<p>Moreno Bevilacqua, <a href="mailto:moreno.bevilacqua89@gmail.com">moreno.bevilacqua89@gmail.com</a>,<a href="https://sites.google.com/view/moreno-bevilacqua/home">https://sites.google.com/view/moreno-bevilacqua/home</a>,
Víctor Morales Oñate, <a href="mailto:victor.morales@uv.cl">victor.morales@uv.cl</a>, <a href="https://sites.google.com/site/moralesonatevictor/">https://sites.google.com/site/moralesonatevictor/</a>,
Christian&quot;, Caamaño-Carrillo, <a href="mailto:chcaaman@ubiobio.cl">chcaaman@ubiobio.cl</a>,<a href="https://www.researchgate.net/profile/Christian-Caamano">https://www.researchgate.net/profile/Christian-Caamano</a>
</p>

<hr>
<h2 id='CheckST'>Checking SpaceTime covariance models</h2><span id='topic+CheckST'></span>

<h3>Description</h3>

<p>The procedure control if the correlation model is spacetime.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CheckST(numbermodel)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CheckST_+3A_numbermodel">numbermodel</code></td>
<td>
<p>numeric; the number associated to a given correlation model.</p>
</td></tr>
</table>


<h3>Details</h3>

<p> The function check if  the correlation model is spacetime.</p>


<h3>Value</h3>

<p>Returns TRUE or FALSE depending if the correlation model is spacetime or not.</p>


<h3>Author(s)</h3>

<p>Moreno Bevilacqua, <a href="mailto:moreno.bevilacqua89@gmail.com">moreno.bevilacqua89@gmail.com</a>,<a href="https://sites.google.com/view/moreno-bevilacqua/home">https://sites.google.com/view/moreno-bevilacqua/home</a>,
Víctor Morales Oñate, <a href="mailto:victor.morales@uv.cl">victor.morales@uv.cl</a>, <a href="https://sites.google.com/site/moralesonatevictor/">https://sites.google.com/site/moralesonatevictor/</a>,
Christian&quot;, Caamaño-Carrillo, <a href="mailto:chcaaman@ubiobio.cl">chcaaman@ubiobio.cl</a>,<a href="https://www.researchgate.net/profile/Christian-Caamano">https://www.researchgate.net/profile/Christian-Caamano</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(GeoModels)
CheckST(CkCorrModel("gneiting"))

</code></pre>

<hr>
<h2 id='CkCorrModel'>Checking Correlation Model</h2><span id='topic+CkCorrModel'></span>

<h3>Description</h3>

<p>The procedure controls if the correlation model
inserted is correct.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CkCorrModel(corrmodel)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CkCorrModel_+3A_corrmodel">corrmodel</code></td>
<td>
<p>String; the name of a correlation model, for the
description see <code><a href="#topic+GeoCovmatrix">GeoCovmatrix</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The procedure controls if the correlation model is correct</p>


<h3>Value</h3>

<p>Return a number associated to a given correlation model if the model
is considered in the package. Otherwise return NULL.</p>


<h3>Author(s)</h3>

<p>Moreno Bevilacqua, <a href="mailto:moreno.bevilacqua89@gmail.com">moreno.bevilacqua89@gmail.com</a>,<a href="https://sites.google.com/view/moreno-bevilacqua/home">https://sites.google.com/view/moreno-bevilacqua/home</a>,
Víctor Morales Oñate, <a href="mailto:victor.morales@uv.cl">victor.morales@uv.cl</a>, <a href="https://sites.google.com/site/moralesonatevictor/">https://sites.google.com/site/moralesonatevictor/</a>,
Christian&quot;, Caamaño-Carrillo, <a href="mailto:chcaaman@ubiobio.cl">chcaaman@ubiobio.cl</a>,<a href="https://www.researchgate.net/profile/Christian-Caamano">https://www.researchgate.net/profile/Christian-Caamano</a>
</p>

<hr>
<h2 id='CkInput'>Checking Input</h2><span id='topic+CkInput'></span>

<h3>Description</h3>

<p>Subroutine called by the fitting procedures.
The procedure controls the the validity of the input inserted by the users.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CkInput(coordx, coordy, coordt, coordx_dyn,corrmodel, data, distance, 
           fcall, fixed, grid,likelihood, maxdist, maxtime, 
            model, n,  optimizer, param, radius,
           start, taper, tapsep,  type, varest, vartype, 
           weighted,copula,X)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CkInput_+3A_coordx">coordx</code></td>
<td>
<p>A numeric (<code class="reqn">d \times 2</code>)-matrix (where
<code>d</code> is the number of points) assigning 2-dimensions of coordinates or a numeric vector assigning
1-dimension of coordinates.</p>
</td></tr>
<tr><td><code id="CkInput_+3A_coordy">coordy</code></td>
<td>
<p>A numeric vector assigning 1-dimension of
coordinates; <code>coordy</code> is interpreted only if <code>coordx</code> is a numeric
vector otherwise it will be ignored.</p>
</td></tr>
<tr><td><code id="CkInput_+3A_coordt">coordt</code></td>
<td>
<p>A numeric vector assigning 1-dimension of
temporal coordinates.</p>
</td></tr>
<tr><td><code id="CkInput_+3A_corrmodel">corrmodel</code></td>
<td>
<p>String; the name of a correlation model, for the
description see <code><a href="#topic+GeoFit">GeoFit</a></code>.</p>
</td></tr>
<tr><td><code id="CkInput_+3A_coordx_dyn">coordx_dyn</code></td>
<td>
<p>A list of <code class="reqn">m</code> numeric (<code class="reqn">d_t \times 2</code>)-matrices
containing dynamical (in time) spatial coordinates. Optional argument, the default is <code>NULL</code>
</p>
</td></tr>  
<tr><td><code id="CkInput_+3A_data">data</code></td>
<td>
<p>A numeric vector or a (<code class="reqn">n \times d</code>)-matrix or (<code class="reqn">d \times d
      \times n</code>)-matrix of observations.</p>
</td></tr>
<tr><td><code id="CkInput_+3A_distance">distance</code></td>
<td>
<p>String; the name of the spatial distance. The default is <code>Eucl</code>,
the euclidean distance. See the Section <b>Details</b>.</p>
</td></tr>
<tr><td><code id="CkInput_+3A_fcall">fcall</code></td>
<td>
<p>String; <code>Fitting</code> to call the fitting procedure and
<code>simulation</code> to call the simulation.</p>
</td></tr>
<tr><td><code id="CkInput_+3A_fixed">fixed</code></td>
<td>
<p>A named list giving the values of the parameters that
will be considered as known values. The listed parameters for a
given correlation function will be not estimated, i.e. if
<code>list(nugget=0)</code> the nugget effect is ignored.</p>
</td></tr>
<tr><td><code id="CkInput_+3A_grid">grid</code></td>
<td>
<p>Logical; if <code>FALSE</code> (the default) the data
are interpreted as a vector or a (<code class="reqn">n \times d</code>)-matrix,
instead if <code>TRUE</code> then (<code class="reqn">d \times d
      \times n</code>)-matrix is considered.</p>
</td></tr>
<tr><td><code id="CkInput_+3A_likelihood">likelihood</code></td>
<td>
<p>String; the configuration of the composite
likelihood. <code>Marginal</code> is the default.</p>
</td></tr>
<tr><td><code id="CkInput_+3A_maxdist">maxdist</code></td>
<td>
<p>Numeric; an optional positive value indicating the maximum
spatial distance considered in the composite-likelihood
computation.</p>
</td></tr>
<tr><td><code id="CkInput_+3A_maxtime">maxtime</code></td>
<td>
<p>Numeric; an optional positive value indicating the maximum
temporal lag separation in the composite-likelihood.</p>
</td></tr>
<tr><td><code id="CkInput_+3A_radius">radius</code></td>
<td>
<p>Numeric; the radius of the sphere in the case of lon-lat coordinates.
The default is 6371, the radius of the earth.</p>
</td></tr>  
<tr><td><code id="CkInput_+3A_model">model</code></td>
<td>
<p>String; the density associated to the likelihood
objects. <code>Gaussian</code> is the default.</p>
</td></tr>
<tr><td><code id="CkInput_+3A_n">n</code></td>
<td>
<p>Numeric; the number of trials in a binomial random fields.
Default is <code class="reqn">1</code>.</p>
</td></tr>    
<tr><td><code id="CkInput_+3A_optimizer">optimizer</code></td>
<td>
<p>String; the optimization algorithm
(see <code><a href="stats.html#topic+optim">optim</a></code> for details). 'Nelder-Mead' is the
default.</p>
</td></tr>
<tr><td><code id="CkInput_+3A_param">param</code></td>
<td>
<p>A numeric vector of parameters, needed only in
simulation. See <code><a href="#topic+GeoSim">GeoSim</a></code>.</p>
</td></tr>
<tr><td><code id="CkInput_+3A_start">start</code></td>
<td>
<p>A named list with the initial values of the
parameters that are used by the numerical routines in maximization
procedure. <code>NULL</code> is the default.</p>
</td></tr>
<tr><td><code id="CkInput_+3A_taper">taper</code></td>
<td>
<p>String; the name of the tapered correlation
function.</p>
</td></tr>
<tr><td><code id="CkInput_+3A_tapsep">tapsep</code></td>
<td>
<p>Numeric; an optional  value indicating the separabe parameter in the space time quasi taper (see <b>Details</b>).</p>
</td></tr>
<tr><td><code id="CkInput_+3A_type">type</code></td>
<td>
<p>String; the type of the likelihood objects. If <code>Pairwise</code> (the
default) then the marginal composite likelihood is formed by
pairwise marginal likelihoods.</p>
</td></tr>
<tr><td><code id="CkInput_+3A_varest">varest</code></td>
<td>
<p>Logical; if <code>TRUE</code> the estimate' variances and
standard errors are returned.
<code>FALSE</code> is the default.</p>
</td></tr>
<tr><td><code id="CkInput_+3A_vartype">vartype</code></td>
<td>
<p>String; the type of estimation method for computing
the estimate variances, see <code><a href="#topic+GeoFit">GeoFit</a></code>.</p>
</td></tr>
<tr><td><code id="CkInput_+3A_weighted">weighted</code></td>
<td>
<p>Logical; if <code>TRUE</code> the likelihood objects are
weighted. If <code>FALSE</code> (the
default) the composite likelihood is not weighted.</p>
</td></tr>
<tr><td><code id="CkInput_+3A_copula">copula</code></td>
<td>
<p>String; the type of copula. It can be &quot;Clayton&quot; or &quot;Gaussian&quot;</p>
</td></tr>
<tr><td><code id="CkInput_+3A_x">X</code></td>
<td>
<p>Numeric; Matrix of space-time covariates in the linear mean specification.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Subroutine called by the fitting procedures.
The procedure controls the the validity of the input inserted by the users.</p>


<h3>Value</h3>

<p>A list with the type of error associated with the input parameters.</p>


<h3>Author(s)</h3>

<p>Moreno Bevilacqua, <a href="mailto:moreno.bevilacqua89@gmail.com">moreno.bevilacqua89@gmail.com</a>,<a href="https://sites.google.com/view/moreno-bevilacqua/home">https://sites.google.com/view/moreno-bevilacqua/home</a>,
Víctor Morales Oñate, <a href="mailto:victor.morales@uv.cl">victor.morales@uv.cl</a>, <a href="https://sites.google.com/site/moralesonatevictor/">https://sites.google.com/site/moralesonatevictor/</a>,
Christian&quot;, Caamaño-Carrillo, <a href="mailto:chcaaman@ubiobio.cl">chcaaman@ubiobio.cl</a>,<a href="https://www.researchgate.net/profile/Christian-Caamano">https://www.researchgate.net/profile/Christian-Caamano</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+GeoFit">GeoFit</a></code></p>

<hr>
<h2 id='CkLikelihood'>Checking Composite-likelihood Type</h2><span id='topic+CkLikelihood'></span>

<h3>Description</h3>

<p>Subroutine called by InitParam.
The procedure controls the type of the composite-likelihood inserted
by the users.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CkLikelihood(likelihood)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CkLikelihood_+3A_likelihood">likelihood</code></td>
<td>
<p>String; the configuration of the composite
likelihood. <code>Marginal</code> is the default.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>  The function controls the type of the composite-likelihood inserted
by the users.</p>


<h3>Value</h3>

<p>The function returns a numeric positive integer, or NULL if the likelihood is invalid.</p>


<h3>Author(s)</h3>

<p>Moreno Bevilacqua, <a href="mailto:moreno.bevilacqua89@gmail.com">moreno.bevilacqua89@gmail.com</a>,<a href="https://sites.google.com/view/moreno-bevilacqua/home">https://sites.google.com/view/moreno-bevilacqua/home</a>,
Víctor Morales Oñate, <a href="mailto:victor.morales@uv.cl">victor.morales@uv.cl</a>, <a href="https://sites.google.com/site/moralesonatevictor/">https://sites.google.com/site/moralesonatevictor/</a>,
Christian&quot;, Caamaño-Carrillo, <a href="mailto:chcaaman@ubiobio.cl">chcaaman@ubiobio.cl</a>,<a href="https://www.researchgate.net/profile/Christian-Caamano">https://www.researchgate.net/profile/Christian-Caamano</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+GeoFit">GeoFit</a></code></p>

<hr>
<h2 id='CkModel'>Checking Random Field type</h2><span id='topic+CkModel'></span>

<h3>Description</h3>

<p>Subroutine called by InitParam.
The procedure controls the type of random field inserted by the users.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CkModel(model)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CkModel_+3A_model">model</code></td>
<td>
<p>String; the density associated to the likelihood
objects. <code>Gaussian</code> is the default.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function controls the type of random field inserted by the users.</p>


<h3>Value</h3>

<p>The function returns a numeric positive integer, or NULL if the model is invalid.</p>


<h3>Author(s)</h3>

<p>Moreno Bevilacqua, <a href="mailto:moreno.bevilacqua89@gmail.com">moreno.bevilacqua89@gmail.com</a>,<a href="https://sites.google.com/view/moreno-bevilacqua/home">https://sites.google.com/view/moreno-bevilacqua/home</a>,
Víctor Morales Oñate, <a href="mailto:victor.morales@uv.cl">victor.morales@uv.cl</a>, <a href="https://sites.google.com/site/moralesonatevictor/">https://sites.google.com/site/moralesonatevictor/</a>,
Christian&quot;, Caamaño-Carrillo, <a href="mailto:chcaaman@ubiobio.cl">chcaaman@ubiobio.cl</a>,<a href="https://www.researchgate.net/profile/Christian-Caamano">https://www.researchgate.net/profile/Christian-Caamano</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+GeoFit">GeoFit</a></code></p>

<hr>
<h2 id='CkType'>Checking Likelihood Objects</h2><span id='topic+CkType'></span>

<h3>Description</h3>

<p>Subroutine called by InitParam.
The procedure controls the type of likelihood objects inserted by the users.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CkType(type)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CkType_+3A_type">type</code></td>
<td>
<p>String; the type of the likelihood objects. If <code>Pairwise</code> (the
default) then the marginal composite likelihood is formed by
pairwise marginal likelihoods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The procedure checks the  likelihood Object</p>


<h3>Value</h3>

<p>The function returns a numeric positive integer, or NULL if the type of likelihood is invalid.</p>


<h3>Author(s)</h3>

<p>Moreno Bevilacqua, <a href="mailto:moreno.bevilacqua89@gmail.com">moreno.bevilacqua89@gmail.com</a>,<a href="https://sites.google.com/view/moreno-bevilacqua/home">https://sites.google.com/view/moreno-bevilacqua/home</a>,
Víctor Morales Oñate, <a href="mailto:victor.morales@uv.cl">victor.morales@uv.cl</a>, <a href="https://sites.google.com/site/moralesonatevictor/">https://sites.google.com/site/moralesonatevictor/</a>,
Christian&quot;, Caamaño-Carrillo, <a href="mailto:chcaaman@ubiobio.cl">chcaaman@ubiobio.cl</a>,<a href="https://www.researchgate.net/profile/Christian-Caamano">https://www.researchgate.net/profile/Christian-Caamano</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+GeoFit">GeoFit</a></code></p>

<hr>
<h2 id='CkVarType'>Checking Variance Estimates Type</h2><span id='topic+CkVarType'></span>

<h3>Description</h3>

<p>Subroutine called by InitParam.
The procedure controls the method used to compute the estimates' variances.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CkVarType(type)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CkVarType_+3A_type">type</code></td>
<td>
<p>String; the method used to compute the estimates'
variances. If <code>SubSamp</code>  the estimates' variances
are computed by the sub-sampling method, see <code><a href="#topic+GeoFit">GeoFit</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The procedure controls the method used to compute the estimates' variances</p>


<h3>Value</h3>

<p>The function returns a numeric positive integer, or NULL if the method is invalid.</p>


<h3>Author(s)</h3>

<p>Moreno Bevilacqua, <a href="mailto:moreno.bevilacqua89@gmail.com">moreno.bevilacqua89@gmail.com</a>,<a href="https://sites.google.com/view/moreno-bevilacqua/home">https://sites.google.com/view/moreno-bevilacqua/home</a>,
Víctor Morales Oñate, <a href="mailto:victor.morales@uv.cl">victor.morales@uv.cl</a>, <a href="https://sites.google.com/site/moralesonatevictor/">https://sites.google.com/site/moralesonatevictor/</a>,
Christian&quot;, Caamaño-Carrillo, <a href="mailto:chcaaman@ubiobio.cl">chcaaman@ubiobio.cl</a>,<a href="https://www.researchgate.net/profile/Christian-Caamano">https://www.researchgate.net/profile/Christian-Caamano</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+GeoFit">GeoFit</a></code></p>

<hr>
<h2 id='CompIndLik2'>Optimizes the Composite indipendence log-likelihood</h2><span id='topic+CompIndLik2'></span>

<h3>Description</h3>

<p>Subroutine called by GeoFit.
The procedure estimates the model parameters by maximisation of the indipendence 
composite log-likelihood.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CompIndLik2(bivariate, coordx, coordy ,coordt,
coordx_dyn, data, flagcorr, flagnuis, fixed,grid,
              lower, model, n, namescorr, namesnuis, 
              namesparam,
              numparam, optimizer, onlyvar, parallel, 
              param, spacetime, type,
              upper, namesupper, varest, ns, X,
              sensitivity,copula,MM)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CompIndLik2_+3A_bivariate">bivariate</code></td>
<td>
<p>Logical; if <code>TRUE</code> then the data come froma a bivariate random field. 
Otherwise from a univariate random field.</p>
</td></tr>
<tr><td><code id="CompIndLik2_+3A_coordx">coordx</code></td>
<td>
<p>A numeric (<code class="reqn">d \times 2</code>)-matrix (where
<code>d</code> is the number of points) assigning 2-dimensions of coordinates 
or a numeric vector assigning 1-dimension of coordinates.</p>
</td></tr>
<tr><td><code id="CompIndLik2_+3A_coordy">coordy</code></td>
<td>
<p>A numeric vector assigning 1-dimension of
coordinates; <code>coordy</code> is interpreted only if <code>coordx</code> is a numeric
vector otherwise it will be ignored.</p>
</td></tr>
<tr><td><code id="CompIndLik2_+3A_coordt">coordt</code></td>
<td>
<p>A numeric vector assigning 1-dimension of
temporal coordinates. Optional argument, the default is <code>NULL</code>
then a spatial random field is expected.</p>
</td></tr>
<tr><td><code id="CompIndLik2_+3A_coordx_dyn">coordx_dyn</code></td>
<td>
<p>A list of <code class="reqn">m</code> numeric (<code class="reqn">d_t \times 2</code>)-matrices
containing dynamical (in time) spatial coordinates. Optional argument, the default is <code>NULL</code> </p>
</td></tr>
<tr><td><code id="CompIndLik2_+3A_data">data</code></td>
<td>
<p>A numeric vector or a (<code class="reqn">n \times d</code>)-matrix or (<code class="reqn">d \times d
      \times n</code>)-matrix of observations.</p>
</td></tr>
<tr><td><code id="CompIndLik2_+3A_flagcorr">flagcorr</code></td>
<td>
<p>A numeric vector of binary values denoting which
paramerters of the correlation function will be estimated.</p>
</td></tr>
<tr><td><code id="CompIndLik2_+3A_flagnuis">flagnuis</code></td>
<td>
<p>A numeric vector of binary values denoting which
nuisance paramerters will be estimated.</p>
</td></tr>
<tr><td><code id="CompIndLik2_+3A_fixed">fixed</code></td>
<td>
<p>A numeric vector of parameters that
will be considered as known values.</p>
</td></tr>
<tr><td><code id="CompIndLik2_+3A_grid">grid</code></td>
<td>
<p>Logical; if <code>FALSE</code> (the default) the data
are interpreted as a vector or a (<code class="reqn">n \times d</code>)-matrix,
instead if <code>TRUE</code> then (<code class="reqn">d \times d
      \times n</code>)-matrix is considered.</p>
</td></tr>
<tr><td><code id="CompIndLik2_+3A_lower">lower</code></td>
<td>
<p>An optional named list giving the values  for the lower bound of the space parameter
when the optimizer is  <code>L-BFGS-B</code> or <code>nlminb</code>  or <code>optimize</code>. The 
names of the list must be the same of the names in the   <code>start</code> list.</p>
</td></tr>
<tr><td><code id="CompIndLik2_+3A_model">model</code></td>
<td>
<p>Numeric; the id value of the density associated to the likelihood objects.</p>
</td></tr>
<tr><td><code id="CompIndLik2_+3A_n">n</code></td>
<td>
<p>Numeric; number of trials in a binomial random fields.</p>
</td></tr>  
<tr><td><code id="CompIndLik2_+3A_namescorr">namescorr</code></td>
<td>
<p>String; the names of the correlation parameters.</p>
</td></tr>
<tr><td><code id="CompIndLik2_+3A_namesnuis">namesnuis</code></td>
<td>
<p>String; the names of the nuisance parameters.</p>
</td></tr>
<tr><td><code id="CompIndLik2_+3A_namesparam">namesparam</code></td>
<td>
<p>String; the names of the parameters to be maximised.</p>
</td></tr>
<tr><td><code id="CompIndLik2_+3A_numparam">numparam</code></td>
<td>
<p>Numeric; the number of parameters to be maximised.</p>
</td></tr>
<tr><td><code id="CompIndLik2_+3A_optimizer">optimizer</code></td>
<td>
<p>String; the optimization algorithm
(see <code><a href="stats.html#topic+optim">optim</a></code> for details). <code>Nelder-Mead</code> is the
default. Other possible choices are <code>nlm</code>, <code>BFGS</code>  <code>L-BFGS-B</code> and <code>nlminb</code>. 
In these last two cases upper and lower bounds can be passed by the user. In the case
of one-dimensional optimization, the function <code>optimize</code> is used.</p>
</td></tr>  
<tr><td><code id="CompIndLik2_+3A_onlyvar">onlyvar</code></td>
<td>
<p>Logical; if <code>TRUE</code>  (and varest is  <code>TRUE</code>) only
the variance covariance matrix is computed
without optimizing. <code>FALSE</code> is the default.</p>
</td></tr>  
<tr><td><code id="CompIndLik2_+3A_parallel">parallel</code></td>
<td>
<p>Logical; if <code>TRUE</code> optmization is performed using optimParallel 
using the maximum number of cores,  when optimizer is 
<code>L-BFGS-B</code>.<code>FALSE</code> is the default.</p>
</td></tr>  
<tr><td><code id="CompIndLik2_+3A_param">param</code></td>
<td>
<p>A numeric vector of parameters values.</p>
</td></tr>
<tr><td><code id="CompIndLik2_+3A_spacetime">spacetime</code></td>
<td>
<p>Logical; if <code>TRUE</code> the random field is spatial-temporal otherwise is a spatial field.</p>
</td></tr>
<tr><td><code id="CompIndLik2_+3A_type">type</code></td>
<td>
<p>String; the type of the likelihood objects. If <code>Pairwise</code> (the
default) then the marginal composite likelihood is formed by pairwise marginal likelihoods.</p>
</td></tr>
<tr><td><code id="CompIndLik2_+3A_upper">upper</code></td>
<td>
<p>An optional named list giving the values  for the upper bound 
of the space parameter when the optimizer is or <code>L-BFGS-B</code> or  <code>nlminb</code> or <code>optimize</code>. 
The names of the list must be the same of the names in the   <code>start</code> list.</p>
</td></tr>
<tr><td><code id="CompIndLik2_+3A_namesupper">namesupper</code></td>
<td>
<p>String; the names of the upper limit of the parameters.</p>
</td></tr>
<tr><td><code id="CompIndLik2_+3A_varest">varest</code></td>
<td>
<p>Logical; if <code>TRUE</code> the estimate variances and standard errors are returned.
<code>FALSE</code> is the default.</p>
</td></tr>
<tr><td><code id="CompIndLik2_+3A_ns">ns</code></td>
<td>
<p>Numeric; Number of (dynamical) temporal instants. </p>
</td></tr>   
<tr><td><code id="CompIndLik2_+3A_x">X</code></td>
<td>
<p>Numeric; Matrix of space-time covariates in the linear mean specification.</p>
</td></tr>
<tr><td><code id="CompIndLik2_+3A_sensitivity">sensitivity</code></td>
<td>
<p>Logical; if <code>TRUE</code> then  the sensitivy  matrix is computed</p>
</td></tr>
<tr><td><code id="CompIndLik2_+3A_copula">copula</code></td>
<td>
<p>String; the type of copula. It can be &quot;Clayton&quot; or &quot;Gaussian&quot;</p>
</td></tr>
<tr><td><code id="CompIndLik2_+3A_mm">MM</code></td>
<td>
<p>Numeric;a non constant fixed mean </p>
</td></tr>
</table>


<h3>Value</h3>

<p>Return a list from an <code>optim</code> call.</p>


<h3>Author(s)</h3>

<p>Moreno Bevilacqua, <a href="mailto:moreno.bevilacqua89@gmail.com">moreno.bevilacqua89@gmail.com</a>,<a href="https://sites.google.com/view/moreno-bevilacqua/home">https://sites.google.com/view/moreno-bevilacqua/home</a>,
Víctor Morales Oñate, <a href="mailto:victor.morales@uv.cl">victor.morales@uv.cl</a>, <a href="https://sites.google.com/site/moralesonatevictor/">https://sites.google.com/site/moralesonatevictor/</a>,
Christian&quot;, Caamaño-Carrillo, <a href="mailto:chcaaman@ubiobio.cl">chcaaman@ubiobio.cl</a>,<a href="https://www.researchgate.net/profile/Christian-Caamano">https://www.researchgate.net/profile/Christian-Caamano</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+GeoFit">GeoFit</a></code></p>

<hr>
<h2 id='CompLik'>Optimizes the Composite log-likelihood</h2><span id='topic+CompLik'></span>

<h3>Description</h3>

<p>Subroutine called by GeoFit.
The procedure estimates the model parameters by maximisation of the
composite log-likelihood.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CompLik(copula,bivariate, coordx, coordy ,coordt, 
coordx_dyn, corrmodel, data,distance,  flagcorr, 
flagnuis, fixed, GPU, grid,likelihood,local,lower, 
                 model, n, namescorr, namesnuis, 
                 namesparam,
               numparam, numparamcorr, optimizer, 
               onlyvar, parallel, param,
               spacetime, type,upper, varest, vartype,
               weigthed, winconst, winstp,winconst_t, 
               winstp_t, ns, X,sensitivity,MM,aniso)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CompLik_+3A_copula">copula</code></td>
<td>
<p>String; the type of copula. It can be &quot;Clayton&quot; or &quot;Gaussian&quot;</p>
</td></tr>
<tr><td><code id="CompLik_+3A_bivariate">bivariate</code></td>
<td>
<p>Logical; if <code>TRUE</code> then the data come froma a bivariate random field. 
Otherwise from a univariate random field.</p>
</td></tr>
<tr><td><code id="CompLik_+3A_coordx">coordx</code></td>
<td>
<p>A numeric (<code class="reqn">d \times 2</code>)-matrix (where
<code>d</code> is the number of points) assigning 2-dimensions of coordinates 
or a numeric vector assigning
1-dimension of coordinates.</p>
</td></tr>
<tr><td><code id="CompLik_+3A_coordy">coordy</code></td>
<td>
<p>A numeric vector assigning 1-dimension of
coordinates; <code>coordy</code> is interpreted only if <code>coordx</code> is a numeric
vector otherwise it will be ignored.</p>
</td></tr>
<tr><td><code id="CompLik_+3A_coordt">coordt</code></td>
<td>
<p>A numeric vector assigning 1-dimension of
temporal coordinates. Optional argument, the default is <code>NULL</code>
then a spatial random field is expected.</p>
</td></tr>  
<tr><td><code id="CompLik_+3A_coordx_dyn">coordx_dyn</code></td>
<td>
<p>A list of <code class="reqn">m</code> numeric (<code class="reqn">d_t \times 2</code>)-matrices
containing dynamical (in time) spatial coordinates. Optional argument, the default is <code>NULL</code>
</p>
</td></tr>
<tr><td><code id="CompLik_+3A_corrmodel">corrmodel</code></td>
<td>
<p>Numeric; the id of the correlation model.</p>
</td></tr>
<tr><td><code id="CompLik_+3A_data">data</code></td>
<td>
<p>A numeric vector or a (<code class="reqn">n \times d</code>)-matrix or (<code class="reqn">d \times d
      \times n</code>)-matrix of observations.</p>
</td></tr>
<tr><td><code id="CompLik_+3A_distance">distance</code></td>
<td>
<p>String; the name of the spatial distance. The default is <code>Eucl</code>,
the euclidean distance. See the Section <b>Details</b>.</p>
</td></tr>
<tr><td><code id="CompLik_+3A_flagcorr">flagcorr</code></td>
<td>
<p>A numeric vector of binary values denoting which
paramerters of the correlation function will be estimated.</p>
</td></tr>
<tr><td><code id="CompLik_+3A_flagnuis">flagnuis</code></td>
<td>
<p>A numeric vector of binary values denoting which
nuisance paramerters will be estimated.</p>
</td></tr>
<tr><td><code id="CompLik_+3A_fixed">fixed</code></td>
<td>
<p>A numeric vector of parameters that
will be considered as known values.</p>
</td></tr>
<tr><td><code id="CompLik_+3A_gpu">GPU</code></td>
<td>
<p>Numeric; if <code>NULL</code> (the default) 
no GPU computation is performed.</p>
</td></tr> 
<tr><td><code id="CompLik_+3A_grid">grid</code></td>
<td>
<p>Logical; if <code>FALSE</code> (the default) the data
are interpreted as a vector or a (<code class="reqn">n \times d</code>)-matrix,
instead if <code>TRUE</code> then (<code class="reqn">d \times d
      \times n</code>)-matrix is considered.</p>
</td></tr>
<tr><td><code id="CompLik_+3A_likelihood">likelihood</code></td>
<td>
<p>String; the configuration of the
compositelikelihood, see <code><a href="#topic+GeoFit">GeoFit</a></code>.</p>
</td></tr>
<tr><td><code id="CompLik_+3A_local">local</code></td>
<td>
<p>Numeric; number of local work-items of the GPU</p>
</td></tr>
<tr><td><code id="CompLik_+3A_lower">lower</code></td>
<td>
<p>An optional named list giving the values  for the lower bound of the space parameter
when the optimizer is  <code>L-BFGS-B</code> or <code>nlminb</code>  or <code>optimize</code>. The 
names of the list must be the same of the names in the   <code>start</code> list.</p>
</td></tr>
<tr><td><code id="CompLik_+3A_model">model</code></td>
<td>
<p>Numeric; the id value of the density associated to the likelihood
objects.</p>
</td></tr>
<tr><td><code id="CompLik_+3A_n">n</code></td>
<td>
<p>Numeric; number of trials in a binomial random fields.</p>
</td></tr>  
<tr><td><code id="CompLik_+3A_namescorr">namescorr</code></td>
<td>
<p>String; the names of the correlation parameters.</p>
</td></tr>
<tr><td><code id="CompLik_+3A_namesnuis">namesnuis</code></td>
<td>
<p>String; the names of the nuisance parameters.</p>
</td></tr>
<tr><td><code id="CompLik_+3A_namesparam">namesparam</code></td>
<td>
<p>String; the names of the parameters to be maximised.</p>
</td></tr>
<tr><td><code id="CompLik_+3A_numparam">numparam</code></td>
<td>
<p>Numeric; the number of parameters to be maximised.</p>
</td></tr>
<tr><td><code id="CompLik_+3A_numparamcorr">numparamcorr</code></td>
<td>
<p>Numeric; the number of correlation parameters.</p>
</td></tr>
<tr><td><code id="CompLik_+3A_optimizer">optimizer</code></td>
<td>
<p>String; the optimization algorithm
(see <code><a href="stats.html#topic+optim">optim</a></code> for details). <code>Nelder-Mead</code> is the
default. Other possible choices are <code>nlm</code>, <code>BFGS</code>  <code>L-BFGS-B</code> and <code>nlminb</code>. 
In these last two cases upper and lower bounds can be passed by the user. In the case
of one-dimensional optimization, the function <code>optimize</code> is used.</p>
</td></tr>  
<tr><td><code id="CompLik_+3A_onlyvar">onlyvar</code></td>
<td>
<p>Logical; if <code>TRUE</code>  (and varest is  <code>TRUE</code>) only
the variance covariance matrix is computed
without optimizing. <code>FALSE</code> is the default.</p>
</td></tr>  
<tr><td><code id="CompLik_+3A_parallel">parallel</code></td>
<td>
<p>Logical; if <code>TRUE</code> optmization is performed using optimParallel 
using the maximum number of cores,  when optimizer is 
<code>L-BFGS-B</code>.<code>FALSE</code> is the default.</p>
</td></tr>  
<tr><td><code id="CompLik_+3A_param">param</code></td>
<td>
<p>A numeric vector of parameters' values.</p>
</td></tr>
<tr><td><code id="CompLik_+3A_spacetime">spacetime</code></td>
<td>
<p>Logical; if <code>TRUE</code> the random field is
spatial-temporal otherwise is a spatial field.</p>
</td></tr>
<tr><td><code id="CompLik_+3A_type">type</code></td>
<td>
<p>String; the type of the likelihood objects. If <code>Pairwise</code> (the
default) then the marginal composite likelihood is formed by
pairwise marginal likelihoods.</p>
</td></tr>
<tr><td><code id="CompLik_+3A_upper">upper</code></td>
<td>
<p>An optional named list giving the values  for the upper bound 
of the space parameter when the optimizer is or <code>L-BFGS-B</code> or  <code>nlminb</code> or <code>optimize</code>. 
The names of the list must be the same of the names in the   <code>start</code> list.</p>
</td></tr>
<tr><td><code id="CompLik_+3A_varest">varest</code></td>
<td>
<p>Logical; if <code>TRUE</code> the estimate' variances and
standard errors are returned.
<code>FALSE</code> is the default.</p>
</td></tr>
<tr><td><code id="CompLik_+3A_vartype">vartype</code></td>
<td>
<p>String; the type of estimation method for computing
the estimate variances, see <code><a href="#topic+GeoFit">GeoFit</a></code>.</p>
</td></tr>
<tr><td><code id="CompLik_+3A_weigthed">weigthed</code></td>
<td>
<p>Logical; if <code>TRUE</code> then decreasing weigths coming 
from a compactly supported correlation function
with compact support <code>maxdist</code> (<code>maxtime</code>)are used.</p>
</td></tr>
<tr><td><code id="CompLik_+3A_winconst">winconst</code></td>
<td>
<p>Numeric; a positive value for computing the spatial  sub-window
in the sub-sampling procedure.</p>
</td></tr>
<tr><td><code id="CompLik_+3A_winstp">winstp</code></td>
<td>
<p>Numeric; a value in <code class="reqn">(0,1]</code> for defining the the proportion of 
overlapping in the spatial  sub-sampling procedure.</p>
</td></tr>
<tr><td><code id="CompLik_+3A_winconst_t">winconst_t</code></td>
<td>
<p>Numeric; a positive value for computing the temporal sub-window
in the sub-sampling procedure.</p>
</td></tr>
<tr><td><code id="CompLik_+3A_winstp_t">winstp_t</code></td>
<td>
<p>Numeric; a value in <code class="reqn">(0,1]</code> for defining the the proportion of 
overlapping in the temporal  sub-sampling procedure.</p>
</td></tr>
<tr><td><code id="CompLik_+3A_ns">ns</code></td>
<td>
<p>Numeric; Number of (dynamical) temporal instants. </p>
</td></tr>   
<tr><td><code id="CompLik_+3A_x">X</code></td>
<td>
<p>Numeric; Matrix of space-time covariates in the linear mean specification.</p>
</td></tr>
<tr><td><code id="CompLik_+3A_sensitivity">sensitivity</code></td>
<td>
<p>Logical; if <code>TRUE</code> then  the sensitivy  matrix is computed</p>
</td></tr>
<tr><td><code id="CompLik_+3A_mm">MM</code></td>
<td>
<p>Numeric;a non constant fixed mean </p>
</td></tr>
<tr><td><code id="CompLik_+3A_aniso">aniso</code></td>
<td>
<p>Logical; should anisotropy be considered?</p>
</td></tr>
</table>


<h3>Details</h3>

<p> Subroutine called by GeoFit.
The procedure estimates the model parameters by maximisation of the
composite log-likelihood</p>


<h3>Value</h3>

<p>Return a list from an <code>optim</code> call.</p>


<h3>Author(s)</h3>

<p>Moreno Bevilacqua, <a href="mailto:moreno.bevilacqua89@gmail.com">moreno.bevilacqua89@gmail.com</a>,<a href="https://sites.google.com/view/moreno-bevilacqua/home">https://sites.google.com/view/moreno-bevilacqua/home</a>,
Víctor Morales Oñate, <a href="mailto:victor.morales@uv.cl">victor.morales@uv.cl</a>, <a href="https://sites.google.com/site/moralesonatevictor/">https://sites.google.com/site/moralesonatevictor/</a>,
Christian&quot;, Caamaño-Carrillo, <a href="mailto:chcaaman@ubiobio.cl">chcaaman@ubiobio.cl</a>,<a href="https://www.researchgate.net/profile/Christian-Caamano">https://www.researchgate.net/profile/Christian-Caamano</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+GeoFit">GeoFit</a></code></p>

<hr>
<h2 id='CompLik2'>Optimizes the Composite log-likelihood</h2><span id='topic+CompLik2'></span>

<h3>Description</h3>

<p>Subroutine called by GeoFit.
The procedure estimates the model parameters by maximisation of the
composite log-likelihood.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CompLik2(copula,bivariate, coordx, coordy ,coordt,
coordx_dyn,corrmodel, data, distance, flagcorr, flagnuis, 
         fixed, GPU,grid,likelihood, local,lower, 
         model, n, namescorr, namesnuis, namesparam,
         numparam, numparamcorr, optimizer, onlyvar,
         parallel, param, spacetime, type,
         upper, varest, vartype, weigthed, winconst, 
         winstp,winconst_t, winstp_t, ns, X,sensitivity,
         colidx,rowidx,neighb,MM,aniso)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CompLik2_+3A_copula">copula</code></td>
<td>
<p>String; the type of copula. It can be &quot;Clayton&quot; or &quot;Gaussian&quot;</p>
</td></tr>
<tr><td><code id="CompLik2_+3A_bivariate">bivariate</code></td>
<td>
<p>Logical; if <code>TRUE</code> then the data come froma a bivariate random field. 
Otherwise from a univariate random field.</p>
</td></tr>
<tr><td><code id="CompLik2_+3A_coordx">coordx</code></td>
<td>
<p>A numeric (<code class="reqn">d \times 2</code>)-matrix (where
<code>d</code> is the number of points) assigning 2-dimensions of coordinates 
or a numeric vector assigning
1-dimension of coordinates.</p>
</td></tr>
<tr><td><code id="CompLik2_+3A_coordy">coordy</code></td>
<td>
<p>A numeric vector assigning 1-dimension of
coordinates; <code>coordy</code> is interpreted only if <code>coordx</code> is a numeric
vector otherwise it will be ignored.</p>
</td></tr>
<tr><td><code id="CompLik2_+3A_coordt">coordt</code></td>
<td>
<p>A numeric vector assigning 1-dimension of
temporal coordinates. Optional argument, the default is <code>NULL</code>
then a spatial random field is expected.</p>
</td></tr>  
<tr><td><code id="CompLik2_+3A_coordx_dyn">coordx_dyn</code></td>
<td>
<p>A list of <code class="reqn">m</code> numeric (<code class="reqn">d_t \times 2</code>)-matrices
containing dynamical (in time) spatial coordinates. Optional argument, the default is <code>NULL</code>
</p>
</td></tr>
<tr><td><code id="CompLik2_+3A_corrmodel">corrmodel</code></td>
<td>
<p>Numeric; the id of the correlation model.</p>
</td></tr>
<tr><td><code id="CompLik2_+3A_data">data</code></td>
<td>
<p>A numeric vector or a (<code class="reqn">n \times d</code>)-matrix or (<code class="reqn">d \times d
      \times n</code>)-matrix of observations.</p>
</td></tr>
<tr><td><code id="CompLik2_+3A_distance">distance</code></td>
<td>
<p>String; the name of the spatial distance. The default is <code>Eucl</code>,
the euclidean distance. See the Section <b>Details</b>.</p>
</td></tr>
<tr><td><code id="CompLik2_+3A_flagcorr">flagcorr</code></td>
<td>
<p>A numeric vector of binary values denoting which
paramerters of the correlation function will be estimated.</p>
</td></tr>
<tr><td><code id="CompLik2_+3A_flagnuis">flagnuis</code></td>
<td>
<p>A numeric vector of binary values denoting which
nuisance paramerters will be estimated.</p>
</td></tr>
<tr><td><code id="CompLik2_+3A_fixed">fixed</code></td>
<td>
<p>A numeric vector of parameters that
will be considered as known values.</p>
</td></tr>
<tr><td><code id="CompLik2_+3A_gpu">GPU</code></td>
<td>
<p>Numeric; if <code>NULL</code> (the default) 
no GPU computation is performed.</p>
</td></tr> 
<tr><td><code id="CompLik2_+3A_grid">grid</code></td>
<td>
<p>Logical; if <code>FALSE</code> (the default) the data
are interpreted as a vector or a (<code class="reqn">n \times d</code>)-matrix,
instead if <code>TRUE</code> then (<code class="reqn">d \times d
      \times n</code>)-matrix is considered.</p>
</td></tr>
<tr><td><code id="CompLik2_+3A_likelihood">likelihood</code></td>
<td>
<p>String; the configuration of the
compositelikelihood, see <code><a href="#topic+GeoFit">GeoFit</a></code>.</p>
</td></tr>
<tr><td><code id="CompLik2_+3A_local">local</code></td>
<td>
<p>Numeric; number of local work-items of the GPU</p>
</td></tr>
<tr><td><code id="CompLik2_+3A_lower">lower</code></td>
<td>
<p>An optional named list giving the values  for the lower bound of the space parameter
when the optimizer is  <code>L-BFGS-B</code> or <code>nlminb</code>  or <code>optimize</code>. The 
names of the list must be the same of the names in the   <code>start</code> list.</p>
</td></tr>
<tr><td><code id="CompLik2_+3A_model">model</code></td>
<td>
<p>Numeric; the id value of the density associated to the likelihood
objects.</p>
</td></tr>
<tr><td><code id="CompLik2_+3A_n">n</code></td>
<td>
<p>Numeric; number of trials in a binomial random fields.</p>
</td></tr>  
<tr><td><code id="CompLik2_+3A_namescorr">namescorr</code></td>
<td>
<p>String; the names of the correlation parameters.</p>
</td></tr>
<tr><td><code id="CompLik2_+3A_namesnuis">namesnuis</code></td>
<td>
<p>String; the names of the nuisance parameters.</p>
</td></tr>
<tr><td><code id="CompLik2_+3A_namesparam">namesparam</code></td>
<td>
<p>String; the names of the parameters to be maximised.</p>
</td></tr>
<tr><td><code id="CompLik2_+3A_numparam">numparam</code></td>
<td>
<p>Numeric; the number of parameters to be maximised.</p>
</td></tr>
<tr><td><code id="CompLik2_+3A_numparamcorr">numparamcorr</code></td>
<td>
<p>Numeric; the number of correlation parameters.</p>
</td></tr>
<tr><td><code id="CompLik2_+3A_optimizer">optimizer</code></td>
<td>
<p>String; the optimization algorithm
(see <code><a href="stats.html#topic+optim">optim</a></code> for details). <code>Nelder-Mead</code> is the
default. Other possible choices are <code>nlm</code>, <code>BFGS</code>  <code>L-BFGS-B</code> and <code>nlminb</code>. 
In these last two cases upper and lower bounds can be passed by the user. In the case
of one-dimensional optimization, the function <code>optimize</code> is used.</p>
</td></tr>  
<tr><td><code id="CompLik2_+3A_onlyvar">onlyvar</code></td>
<td>
<p>Logical; if <code>TRUE</code>  (and varest is  <code>TRUE</code>) only
the variance covariance matrix is computed
without optimizing. <code>FALSE</code> is the default.</p>
</td></tr>  
<tr><td><code id="CompLik2_+3A_parallel">parallel</code></td>
<td>
<p>Logical; if <code>TRUE</code> optmization is performed using optimParallel 
using the maximum number of cores,  when optimizer is 
<code>L-BFGS-B</code>.<code>FALSE</code> is the default.</p>
</td></tr>  
<tr><td><code id="CompLik2_+3A_param">param</code></td>
<td>
<p>A numeric vector of parameters' values.</p>
</td></tr>
<tr><td><code id="CompLik2_+3A_spacetime">spacetime</code></td>
<td>
<p>Logical; if <code>TRUE</code> the random field is
spatial-temporal otherwise is a spatial field.</p>
</td></tr>
<tr><td><code id="CompLik2_+3A_type">type</code></td>
<td>
<p>String; the type of the likelihood objects. If <code>Pairwise</code> (the
default) then the marginal composite likelihood is formed by
pairwise marginal likelihoods.</p>
</td></tr>
<tr><td><code id="CompLik2_+3A_upper">upper</code></td>
<td>
<p>An optional named list giving the values  for the upper bound 
of the space parameter when the optimizer is or <code>L-BFGS-B</code> or  <code>nlminb</code> or <code>optimize</code>. 
The names of the list must be the same of the names in the   <code>start</code> list.</p>
</td></tr>
<tr><td><code id="CompLik2_+3A_varest">varest</code></td>
<td>
<p>Logical; if <code>TRUE</code> the estimate' variances and
standard errors are returned.
<code>FALSE</code> is the default.</p>
</td></tr>
<tr><td><code id="CompLik2_+3A_vartype">vartype</code></td>
<td>
<p>String; the type of estimation method for computing
the estimate variances, see <code><a href="#topic+GeoFit">GeoFit</a></code>.</p>
</td></tr>
<tr><td><code id="CompLik2_+3A_weigthed">weigthed</code></td>
<td>
<p>Logical; if <code>TRUE</code> then decreasing weigths coming 
from a compactly supported correlation function
with compact support <code>maxdist</code> (<code>maxtime</code>)are used.</p>
</td></tr>
<tr><td><code id="CompLik2_+3A_winconst">winconst</code></td>
<td>
<p>Numeric; a positive value for computing the spatial  sub-window
in the sub-sampling procedure.</p>
</td></tr>
<tr><td><code id="CompLik2_+3A_winstp">winstp</code></td>
<td>
<p>Numeric; a value in <code class="reqn">(0,1]</code> for defining the the proportion of 
overlapping in the spatial  sub-sampling procedure.</p>
</td></tr>
<tr><td><code id="CompLik2_+3A_winconst_t">winconst_t</code></td>
<td>
<p>Numeric; a positive value for computing the temporal sub-window
in the sub-sampling procedure.</p>
</td></tr>
<tr><td><code id="CompLik2_+3A_winstp_t">winstp_t</code></td>
<td>
<p>Numeric; a value in <code class="reqn">(0,1]</code> for defining the the proportion of 
overlapping in the temporal  sub-sampling procedure.</p>
</td></tr>
<tr><td><code id="CompLik2_+3A_ns">ns</code></td>
<td>
<p>Numeric; Number of (dynamical) temporal instants. </p>
</td></tr>   
<tr><td><code id="CompLik2_+3A_x">X</code></td>
<td>
<p>Numeric; Matrix of space-time covariates in the linear mean specification.</p>
</td></tr>
<tr><td><code id="CompLik2_+3A_sensitivity">sensitivity</code></td>
<td>
<p>Logical; if <code>TRUE</code> then  the sensitivy  matrix is computed</p>
</td></tr>
<tr><td><code id="CompLik2_+3A_colidx">colidx</code></td>
<td>
<p>Numeric; Vector of indexes for spatial distances.</p>
</td></tr>
<tr><td><code id="CompLik2_+3A_rowidx">rowidx</code></td>
<td>
<p>Numeric; Vector of indexes for spatial distances.</p>
</td></tr>
<tr><td><code id="CompLik2_+3A_neighb">neighb</code></td>
<td>
<p>Numeric; an optional positive integer indicating the 
order of neighborhood location.</p>
</td></tr>
<tr><td><code id="CompLik2_+3A_mm">MM</code></td>
<td>
<p>Numeric;a non constant fixed mean </p>
</td></tr>
<tr><td><code id="CompLik2_+3A_aniso">aniso</code></td>
<td>
<p>Logical; should anisotropy be considered?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Return a list from an <code>optim</code> call.</p>


<h3>Author(s)</h3>

<p>Moreno Bevilacqua, <a href="mailto:moreno.bevilacqua89@gmail.com">moreno.bevilacqua89@gmail.com</a>,<a href="https://sites.google.com/view/moreno-bevilacqua/home">https://sites.google.com/view/moreno-bevilacqua/home</a>,
Víctor Morales Oñate, <a href="mailto:victor.morales@uv.cl">victor.morales@uv.cl</a>, <a href="https://sites.google.com/site/moralesonatevictor/">https://sites.google.com/site/moralesonatevictor/</a>,
Christian&quot;, Caamaño-Carrillo, <a href="mailto:chcaaman@ubiobio.cl">chcaaman@ubiobio.cl</a>,<a href="https://www.researchgate.net/profile/Christian-Caamano">https://www.researchgate.net/profile/Christian-Caamano</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+GeoFit">GeoFit</a></code></p>

<hr>
<h2 id='CorrelationPar'>Lists the Parameters of a Correlation Model</h2><span id='topic+CorrelationPar'></span>

<h3>Description</h3>

<p>Subroutine called by InitParam and other procedures.
The procedure returns a list with the parameters of a given
correlation model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CorrelationPar(corrmodel)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CorrelationPar_+3A_corrmodel">corrmodel</code></td>
<td>
<p>Integer; an integer associated to a given correlation model.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function return a list with the Parameters of a Correlation Model</p>


<h3>Value</h3>

<p>Return a vector string of correlation parameters.</p>


<h3>Author(s)</h3>

<p>Moreno Bevilacqua, <a href="mailto:moreno.bevilacqua89@gmail.com">moreno.bevilacqua89@gmail.com</a>,<a href="https://sites.google.com/view/moreno-bevilacqua/home">https://sites.google.com/view/moreno-bevilacqua/home</a>,
Víctor Morales Oñate, <a href="mailto:victor.morales@uv.cl">victor.morales@uv.cl</a>, <a href="https://sites.google.com/site/moralesonatevictor/">https://sites.google.com/site/moralesonatevictor/</a>,
Christian&quot;, Caamaño-Carrillo, <a href="mailto:chcaaman@ubiobio.cl">chcaaman@ubiobio.cl</a>,<a href="https://www.researchgate.net/profile/Christian-Caamano">https://www.researchgate.net/profile/Christian-Caamano</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+GeoFit">GeoFit</a></code></p>

<hr>
<h2 id='CorrParam'>Lists the Parameters of a Correlation Model</h2><span id='topic+CorrParam'></span>

<h3>Description</h3>

<p>The procedure returns a list with the  names of the parameters of a given
correlation model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CorrParam(corrmodel)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CorrParam_+3A_corrmodel">corrmodel</code></td>
<td>
<p>String: the name associated  to a given correlation model.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function return a list with the Parameters of a Correlation Model</p>


<h3>Value</h3>

<p>Return a vector string of correlation parameters.</p>


<h3>Author(s)</h3>

<p>Moreno Bevilacqua, <a href="mailto:moreno.bevilacqua89@gmail.com">moreno.bevilacqua89@gmail.com</a>,<a href="https://sites.google.com/view/moreno-bevilacqua/home">https://sites.google.com/view/moreno-bevilacqua/home</a>,
Víctor Morales Oñate, <a href="mailto:victor.morales@uv.cl">victor.morales@uv.cl</a>, <a href="https://sites.google.com/site/moralesonatevictor/">https://sites.google.com/site/moralesonatevictor/</a>,
Christian&quot;, Caamaño-Carrillo, <a href="mailto:chcaaman@ubiobio.cl">chcaaman@ubiobio.cl</a>,<a href="https://www.researchgate.net/profile/Christian-Caamano">https://www.researchgate.net/profile/Christian-Caamano</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+GeoCovmatrix">GeoCovmatrix</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>require(GeoModels)
################################################################
###
### Example 1. Parameters of the  Matern  model
###
###############################################################

CorrParam("Matern")


################################################################
###
### Example 2. Parameters of the  Generalized Wendland  model
###
###############################################################

CorrParam("GenWend")


################################################################
###
### Example 3. Parameters of the  Generalized Cauchy  model
###
###############################################################

CorrParam("GenCauchy")


################################################################
###
### Example 4. Parameters of the  space time Gneiting  model
###
###############################################################

CorrParam("Gneiting")


################################################################
###
### Example 5. Parameters of the bi-Matern separable  model.
###            Note that in the bivariate case variance paramters are
###            included
###############################################################

CorrParam("Bi_Matern_sep")
</code></pre>

<hr>
<h2 id='GeoAniso'>Spatial Anisotropy correction</h2><span id='topic+GeoAniso'></span>

<h3>Description</h3>

<p>Transforms or back-transforms a set of coordinates according to the geometric anisotropy parameters. </p>


<h3>Usage</h3>

<pre><code class='language-R'>GeoAniso(coords, anisopars=c(0,1), inverse = FALSE)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GeoAniso_+3A_coords">coords</code></td>
<td>
<p>An n x 2 matrix with the coordinates to be transformed.</p>
</td></tr>
<tr><td><code id="GeoAniso_+3A_anisopars">anisopars</code></td>
<td>
<p> A bivariate vector with the the anisotropy angle and the anisotropy ratio, respectively. The angle must be given in radians in [0,pi] and the anisotropy ratio must be greater or equal than 1.</p>
</td></tr>
<tr><td><code id="GeoAniso_+3A_inverse">inverse</code></td>
<td>
<p>Logical: Default to FALSE. If TRUE the reverse transformation is performed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Geometric anisotropy is defined by a linear  tranformation from the anisotropic space to the isotropic space  that is  </p>
<p style="text-align: center;"><code class="reqn">Y = X R S</code>
</p>

<p>where  X is a matrix with original coordinates (anisotropic space), and Y is a matrix with  transformed coordinates (isotropic space). 
Here R  is  a  rotation matrix  with associated anisotropy angle parameter (in <code class="reqn">[0,pi]</code>) and a <code class="reqn">S</code> is a shrinking matrix with associated anisotropy ratio 
parameter (greeater or equal than one).
The two parameters are specified in the anisopars argument as a bivariate numeric vector. The case <code class="reqn">(.,1)</code> corresponds to the isotropic case.
</p>


<h3>Value</h3>

<p>Returns a  matrix of transformed coordinates</p>


<h3>Author(s)</h3>

<p>Moreno Bevilacqua, <a href="mailto:moreno.bevilacqua89@gmail.com">moreno.bevilacqua89@gmail.com</a>,<a href="https://sites.google.com/view/moreno-bevilacqua/home">https://sites.google.com/view/moreno-bevilacqua/home</a>,
Víctor Morales Oñate, <a href="mailto:victor.morales@uv.cl">victor.morales@uv.cl</a>, <a href="https://sites.google.com/site/moralesonatevictor/">https://sites.google.com/site/moralesonatevictor/</a>,
Christian&quot;, Caamaño-Carrillo, <a href="mailto:chcaaman@ubiobio.cl">chcaaman@ubiobio.cl</a>,<a href="https://www.researchgate.net/profile/Christian-Caamano">https://www.researchgate.net/profile/Christian-Caamano</a>
</p>

<hr>
<h2 id='GeoCorrFct'>Spatial and Spatio-temporal correlation or  covariance of (non) Gaussian random fields</h2><span id='topic+GeoCorrFct'></span>

<h3>Description</h3>

<p>The function computes the  correlations of 
a spatial (or spatio-temporal or  bivariate spatial) Gaussian or non Gaussian randomm field
for a  given  correlation  model and a  set of spatial (temporal) distances.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GeoCorrFct(x,t=NULL,corrmodel, model="Gaussian",
distance="Eucl", param, radius=6371,n=1,
covariance=FALSE,variogram=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GeoCorrFct_+3A_x">x</code></td>
<td>
<p>A set of spatial distances.</p>
</td></tr>
<tr><td><code id="GeoCorrFct_+3A_t">t</code></td>
<td>
<p>A set of (optional) temporal distances.</p>
</td></tr>
<tr><td><code id="GeoCorrFct_+3A_corrmodel">corrmodel</code></td>
<td>
<p>String; the name of a correlation model, for the
description see the Section <b>Details</b>.</p>
</td></tr>
<tr><td><code id="GeoCorrFct_+3A_model">model</code></td>
<td>
<p>String; the type of RF. See <code><a href="#topic+GeoFit">GeoFit</a></code>.</p>
</td></tr>
<tr><td><code id="GeoCorrFct_+3A_distance">distance</code></td>
<td>
<p>String; the name of the spatial distance. The default
is <code>Eucl</code>, the euclidean distance. See <code><a href="#topic+GeoFit">GeoFit</a></code>.</p>
</td></tr>
<tr><td><code id="GeoCorrFct_+3A_param">param</code></td>
<td>
<p>A list of parameter values required  for the covariance
model.</p>
</td></tr>
<tr><td><code id="GeoCorrFct_+3A_radius">radius</code></td>
<td>
<p>Numeric; a value indicating  the radius of the sphere 
when using covariance models valid using the great circle distance. 
Default value is the radius of the earth in Km (i.e. 6371)</p>
</td></tr> 
<tr><td><code id="GeoCorrFct_+3A_n">n</code></td>
<td>
<p>Numeric; the number of trials in a (negative) binomial random fields.
Default is <code class="reqn">1</code>.</p>
</td></tr>
<tr><td><code id="GeoCorrFct_+3A_covariance">covariance</code></td>
<td>
<p>Logic; if TRUE then the covariance is returned. Default is FALSE</p>
</td></tr>
<tr><td><code id="GeoCorrFct_+3A_variogram">variogram</code></td>
<td>
<p>Logic; if FALSE then the covariance/coorelation is returned. Otherwise the associated
semivariogram is returned</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns  correlations or covariances values associated to a given parametric spatial and temporal correlation models.</p>


<h3>Author(s)</h3>

<p>Moreno Bevilacqua, <a href="mailto:moreno.bevilacqua89@gmail.com">moreno.bevilacqua89@gmail.com</a>,<a href="https://sites.google.com/view/moreno-bevilacqua/home">https://sites.google.com/view/moreno-bevilacqua/home</a>,
Víctor Morales Oñate, <a href="mailto:victor.morales@uv.cl">victor.morales@uv.cl</a>, <a href="https://sites.google.com/site/moralesonatevictor/">https://sites.google.com/site/moralesonatevictor/</a>,
Christian&quot;, Caamaño-Carrillo, <a href="mailto:chcaaman@ubiobio.cl">chcaaman@ubiobio.cl</a>,<a href="https://www.researchgate.net/profile/Christian-Caamano">https://www.researchgate.net/profile/Christian-Caamano</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(GeoModels)

################################################################
###
### Example 1. Correlation of a Gaussian random field with underlying 
### Matern correlation model
###
###############################################################
# Define the spatial distances
x = seq(0,1,0.005)
# Correlation Parameters for Matern model 
CorrParam("Matern")
NuisParam("Gaussian")
# Matern Parameters 
param=list(sill=1,smooth=0.5,scale=0.2/3,nugget=0,mean=0)
corr= GeoCorrFct(x=x, corrmodel="Matern", param=param,model="Gaussian")
plot(x,corr,ylim=c(0,1),type="l")

################################################################
###
### Example 2. Correlation of a Gaussian random field with underlying 
### Generalized Wendland-Matern correlation model
###
###############################################################
CorrParam("GenWend_Matern")
NuisParam("Gaussian")
# GenWend Matern Parameters 
param=list(sill=1,smooth=1,scale=0.1,nugget=0,power2=1/4,mean=0)
corr= GeoCorrFct(x=x, corrmodel="GenWend_Matern", param=param,model="Gaussian")
plot(x,corr,ylim=c(0,1),type="l")

################################################################
###
### Example 3. Correlation of a t random field with underlying 
### Generalized Wendland correlation model
###
###############################################################
CorrParam("GenWend")
NuisParam("StudentT")
x = seq(0,1,0.005)
param=list(sill=1,smooth=1,scale=0.5,nugget=0,power2=5,df=1/6,mean=0)
corr= GeoCorrFct(x=x, corrmodel="GenWend", param=param,model="StudentT")
plot(x,corr,ylim=c(0,1),type="l")

################################################################
###
### Example 4. Correlation of a LoggGaussian random field with underlying 
### Kummer correlation model
###
###############################################################
CorrParam("Kummer")
NuisParam("LogGaussian")
# GenWend Matern Parameters 
param=list(smooth=1,sill=0.5,scale=0.1,nugget=0,power2=1,mean=0)
corr= GeoCorrFct(x=x, corrmodel="Kummer", param=param,model="LogGaussian")
plot(x,corr,ylim=c(0,1),type="l")

################################################################
###
### Example 5. Correlation of Weibull random field with underlying 
### Generalized Cauchy correlation model
###
###############################################################
CorrParam("GenCauchy")
NuisParam("Weibull")
x = seq(0,1,0.005)
param=list(scale=0.2,nugget=0,power1=0.8, power2=0.8,shape=4,mean=0)
corr= GeoCorrFct(x=x, corrmodel="GenCauchy", param=param,model="Weibull")
plot(x,corr,ylim=c(0,1),type="l")

################################################################
###
### Example 6. Covariance of Poisson random field with underlying 
### Matern correlation model
###
###############################################################
CorrParam("Matern")
NuisParam("Poisson")
x = seq(0,1,0.005)
param=list(scale=0.6/3,nugget=0,smooth=0.5,mean=2)
cova= GeoCorrFct(x=x, corrmodel="Matern", param=param,model="Poisson",covariance=TRUE)
plot(x,cova,ylim=c(0,exp(2)),type="l")


################################################################
###
### Example 7. Correlation of a space time Gaussian random field 
### with underlying  spacetime separable Matern correlation model
###
###############################################################

## spatial and temporal distances 
h&lt;-seq(0,3,by=0.05)
times&lt;-seq(0,3,by=0.05)

# Correlation Parameters for the space time separable Matern model 
CorrParam("Matern")
NuisParam("Gaussian")
# Matern Parameters 
param=list(sill=1,scale_s=0.8/3,scale_t=1,nugget=0,mean=0,smooth_s=1.5,smooth_t=0.5)

corr= GeoCorrFct(x=h,t=times,corrmodel="Matern_Matern", param=param,model="Gaussian")

cc=matrix(corr,nrow=length(h),ncol=length(times))
persp(cc,x= h,y=times, theta = 20, phi = 30, 
                   ticktype = "detailed",zlab="",xlab="Distance",ylab="Time")


################################################################
###
### Example 8. Correlation of a bivariate Gaussian random field 
### with underlying  separable bivariate  Matern correlation model
###
###############################################################
# Define the spatial distances
x = seq(0,1,0.005)
# Correlation Parameters for the bivariate sep Matern model 
CorrParam("Bi_Matern_sep")
# Matern Parameters 
param=list(sill_1=1,sill_2=1,smooth=0.5,scale=0.2/3,mean_1=0,
                       mean_2=0,nugget_1=0,nugget_2=0,pcol=0.2)
corr= GeoCorrFct(x=x, corrmodel="Bi_Matern_sep", param=param,model="Gaussian")

# first correlation
plot(x,corr[1,],ylim=c(0,1),type="l")
# cross correlation
plot(x,corr[2,],ylim=c(0,1),type="l")
# second correlation
plot(x,corr[3,],ylim=c(0,1),type="l")

</code></pre>

<hr>
<h2 id='GeoCorrFct_Cop'>Spatial and Spatio-temporal correlation or  covariance of (non) Gaussian random fields (copula models)</h2><span id='topic+GeoCorrFct_Cop'></span>

<h3>Description</h3>

<p>The function computes the  correlations of a spatial or spatio-temporal 
or a bivariate spatial Gaussian or non Gaussian copula randomm field
with a  given  covariance model and a  set of spatial (temporal) distances.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GeoCorrFct_Cop(x,t=NULL,corrmodel, 
model="Gaussian",copula="Gaussian",
distance="Eucl", param, radius=6371,
n=1,covariance=FALSE,variogram=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GeoCorrFct_Cop_+3A_x">x</code></td>
<td>
<p>A set of spatial distances.</p>
</td></tr>
<tr><td><code id="GeoCorrFct_Cop_+3A_t">t</code></td>
<td>
<p>A set of (optional) temporal distances.</p>
</td></tr>
<tr><td><code id="GeoCorrFct_Cop_+3A_corrmodel">corrmodel</code></td>
<td>
<p>String; the name of a correlation model, for the
description see the Section <b>Details</b>.</p>
</td></tr>
<tr><td><code id="GeoCorrFct_Cop_+3A_model">model</code></td>
<td>
<p>String; the type of RF. See <code><a href="#topic+GeoFit">GeoFit</a></code>.</p>
</td></tr>
<tr><td><code id="GeoCorrFct_Cop_+3A_copula">copula</code></td>
<td>
<p>String; the type of copula. The two options are Gaussian and Clayton.</p>
</td></tr>
<tr><td><code id="GeoCorrFct_Cop_+3A_distance">distance</code></td>
<td>
<p>String; the name of the spatial distance. The default
is <code>Eucl</code>, the euclidean distance. See <code><a href="#topic+GeoFit">GeoFit</a></code>.</p>
</td></tr>
<tr><td><code id="GeoCorrFct_Cop_+3A_param">param</code></td>
<td>
<p>A list of parameter values required  for the covariance
model.</p>
</td></tr>
<tr><td><code id="GeoCorrFct_Cop_+3A_radius">radius</code></td>
<td>
<p>Numeric; a value indicating  the radius of the sphere 
when using covariance models valid using the great circle distance. 
Default value is the radius of the earth in Km (i.e. 6371)</p>
</td></tr> 
<tr><td><code id="GeoCorrFct_Cop_+3A_n">n</code></td>
<td>
<p>Numeric; the number of trials in a (negative) binomial random fields.
Default is <code class="reqn">1</code>.</p>
</td></tr>
<tr><td><code id="GeoCorrFct_Cop_+3A_covariance">covariance</code></td>
<td>
<p>Logic; if TRUE then the covariance is returned. Default is FALSE</p>
</td></tr>
<tr><td><code id="GeoCorrFct_Cop_+3A_variogram">variogram</code></td>
<td>
<p>Logic; if FALSE then the covariance/coorelation is returned. Otherwise the associated
semivariogram is returned</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a vector of  correlations or covariances values associated to a given parametric spatial and temporal correlation models.</p>


<h3>Author(s)</h3>

<p>Moreno Bevilacqua, <a href="mailto:moreno.bevilacqua89@gmail.com">moreno.bevilacqua89@gmail.com</a>,<a href="https://sites.google.com/view/moreno-bevilacqua/home">https://sites.google.com/view/moreno-bevilacqua/home</a>,
Víctor Morales Oñate, <a href="mailto:victor.morales@uv.cl">victor.morales@uv.cl</a>, <a href="https://sites.google.com/site/moralesonatevictor/">https://sites.google.com/site/moralesonatevictor/</a>,
Christian&quot;, Caamaño-Carrillo, <a href="mailto:chcaaman@ubiobio.cl">chcaaman@ubiobio.cl</a>,<a href="https://www.researchgate.net/profile/Christian-Caamano">https://www.researchgate.net/profile/Christian-Caamano</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(GeoModels)

################################################################
###
### Example 1. Correlation of a (mean reparametrized) beta random field with underlying 
### Matern correlation model using Gaussian and Clayton copulas
###
###############################################################

# Define the spatial distances
x = seq(0,0.4,0.01)

# Correlation Parameters for Matern model 
CorrParam("Matern")
NuisParam("Beta2")
# corr Gaussian copula
param=list(smooth=0.5,sill=1,scale=0.2/3,nugget=0,mean=0,min=0,max=1,shape=0.5)
corr1= GeoCorrFct_Cop(x=x, corrmodel="Matern", param=param,copula="Gaussian",model="Beta2")

# corr Clayton copula
param=list(smooth=0.5,sill=1,scale=0.2/3,nugget=0,mean=0,min=0,max=1,shape=0.5,nu=2)
corr2= GeoCorrFct_Cop(x=x, corrmodel="Matern", param=param,copula="Clayton",model="Beta2")

plot(x,corr1,ylim=c(0,1),type="l",xlab="distance",ylab="corr")
lines(x,corr2,ylim=c(0,1),lty=2)

legend("topright", legend=c("Gaussian Copula", "Clayton Copula"),
       , lty=1:2, cex=1.2)


</code></pre>

<hr>
<h2 id='GeoCovariogram'>Computes the fitted  variogram model.</h2><span id='topic+GeoCovariogram'></span>

<h3>Description</h3>

<p>The procedure computes and plots estimated covariance  or semivariogram  models of a Gaussian
or a  non Gaussian spatial (temporal or  bivariate spatial) random  field. It allows to add 
the empirical estimates in order to compare them with the fitted model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GeoCovariogram(fitted, distance="Eucl",answer.cov=FALSE,
            answer.vario=FALSE, answer.range=FALSE, fix.lags=NULL, 
             fix.lagt=NULL, show.cov=FALSE, show.vario=FALSE, 
            show.range=FALSE, add.cov=FALSE, add.vario=FALSE,
            pract.range=95, vario, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GeoCovariogram_+3A_fitted">fitted</code></td>
<td>
<p>A fitted object obtained from the
<code><a href="#topic+GeoFit">GeoFit</a></code> or <code><a href="#topic+GeoWLS">GeoWLS</a></code> procedures.</p>
</td></tr>
<tr><td><code id="GeoCovariogram_+3A_distance">distance</code></td>
<td>
<p>String; the name of the spatial distance. The default
is <code>Eucl</code>, the euclidean distance. See <code><a href="#topic+GeoFit">GeoFit</a></code>.</p>
</td></tr>
<tr><td><code id="GeoCovariogram_+3A_answer.cov">answer.cov</code></td>
<td>
<p>Logical; if <code>TRUE</code> a vector with the
estimated covariance function is returned; if <code>FALSE</code> (the
default) the covariance is not returned.</p>
</td></tr>
<tr><td><code id="GeoCovariogram_+3A_answer.vario">answer.vario</code></td>
<td>
<p>Logical; if <code>TRUE</code> a vector with the
estimated variogram is returned; if <code>FALSE</code> (the
default) the variogram is not returned.</p>
</td></tr>
<tr><td><code id="GeoCovariogram_+3A_answer.range">answer.range</code></td>
<td>
<p>Logical; if <code>TRUE</code> the estimated
pratical range is returned; if <code>FALSE</code> (the
default) the pratical range is not returned.</p>
</td></tr>
<tr><td><code id="GeoCovariogram_+3A_fix.lags">fix.lags</code></td>
<td>
<p>Integer; a positive value denoting the spatial lag to
consider for the plot of the temporal profile.</p>
</td></tr>
<tr><td><code id="GeoCovariogram_+3A_fix.lagt">fix.lagt</code></td>
<td>
<p>Integer; a positive value denoting the temporal lag to
consider for the plot of the spatial profile.</p>
</td></tr>
<tr><td><code id="GeoCovariogram_+3A_show.cov">show.cov</code></td>
<td>
<p>Logical; if <code>TRUE</code> the estimated
covariance function is plotted; if <code>FALSE</code> (the
default) the covariance function is not plotted.</p>
</td></tr>
<tr><td><code id="GeoCovariogram_+3A_show.vario">show.vario</code></td>
<td>
<p>Logical; if <code>TRUE</code> the estimated
variogram is plotted; if <code>FALSE</code> (the
default) the variogram is not plotted.</p>
</td></tr>
<tr><td><code id="GeoCovariogram_+3A_show.range">show.range</code></td>
<td>
<p>Logical; if <code>TRUE</code> the estimated
pratical range is added on the plot; if <code>FALSE</code> (the
default) the pratical range is not added.</p>
</td></tr>
<tr><td><code id="GeoCovariogram_+3A_add.cov">add.cov</code></td>
<td>
<p>Logical; if <code>TRUE</code> the vector of the
estimated covariance function is added on the current plot; if <code>FALSE</code> (the
default) the covariance is not added.</p>
</td></tr>
<tr><td><code id="GeoCovariogram_+3A_add.vario">add.vario</code></td>
<td>
<p>Logical; if <code>TRUE</code> the vector with the
estimated variogram is added on the current plot; if <code>FALSE</code> (the
default) the correlation is not added.</p>
</td></tr>
<tr><td><code id="GeoCovariogram_+3A_pract.range">pract.range</code></td>
<td>
<p>Numeric; the percent of the sill to be reached.</p>
</td></tr>
<tr><td><code id="GeoCovariogram_+3A_vario">vario</code></td>
<td>
<p>A <code>Variogram</code> object obtained from the
<code><a href="#topic+GeoVariogram">GeoVariogram</a></code> procedure.</p>
</td></tr>
<tr><td><code id="GeoCovariogram_+3A_...">...</code></td>
<td>
<p>other optional parameters which are passed to plot functions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function computes the fitted variogram model</p>


<h3>Value</h3>

<p> Produces a plot. No values are returned.</p>


<h3>Author(s)</h3>

<p>Moreno Bevilacqua, <a href="mailto:moreno.bevilacqua89@gmail.com">moreno.bevilacqua89@gmail.com</a>,<a href="https://sites.google.com/view/moreno-bevilacqua/home">https://sites.google.com/view/moreno-bevilacqua/home</a>,
Víctor Morales Oñate, <a href="mailto:victor.morales@uv.cl">victor.morales@uv.cl</a>, <a href="https://sites.google.com/site/moralesonatevictor/">https://sites.google.com/site/moralesonatevictor/</a>,
Christian&quot;, Caamaño-Carrillo, <a href="mailto:chcaaman@ubiobio.cl">chcaaman@ubiobio.cl</a>,<a href="https://www.researchgate.net/profile/Christian-Caamano">https://www.researchgate.net/profile/Christian-Caamano</a>
</p>


<h3>References</h3>

<p>Cressie, N. A. C. (1993) <em>Statistics for Spatial Data</em>. New York:
Wiley.
</p>
<p>Gaetan, C. and Guyon, X. (2010) Spatial Statistics and Modelling.
<em>Spring Verlang, New York</em>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+GeoFit">GeoFit</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(GeoModels)
library(scatterplot3d)

################################################################
###
### Example 1. Plot of fitted covariance and fitted 
### and empirical semivariogram from a  Gaussian RF 
### with Matern correlation. 
###
###############################################################
set.seed(21)
# Set the coordinates of the points:
x = runif(300, 0, 1)
y = runif(300, 0, 1)
coords=cbind(x,y)

# Set the model's parameters:
corrmodel = "Matern"
model = "Gaussian"
mean = 0
sill = 1
nugget = 0
scale = 0.2/3
smooth=0.5

param=list(mean=mean,sill=sill, nugget=nugget, scale=scale, smooth=smooth)
# Simulation of the Gaussian random field:
data = GeoSim(coordx=coords, corrmodel=corrmodel, model=model,param=param)$data
I=Inf
start=list(mean=0,scale=scale,sill=sill)
lower=list(mean=-I,scale=0,sill=0)
upper=list(mean= I,scale=I,sill=I)
fixed=list(nugget=nugget,smooth=smooth)
# Maximum composite-likelihood fitting of the Gaussian random field:
fit = GeoFit(data=data,coordx=coords, corrmodel=corrmodel,model=model,
            likelihood="Marginal",type='Pairwise',start=start,
            lower=lower,upper=upper,
            optimizer="nlminb", fixed=fixed,neighb=4)

# Empirical estimation of the variogram:
vario = GeoVariogram(data=data,coordx=coords,maxdist=0.5)

# Plot of covariance and variogram functions:
GeoCovariogram(fit, show.cov=TRUE,show.vario=TRUE, vario=vario,pch=20)

################################################################
###
### Example 2. Plot of fitted covariance and fitted 
### and empirical semivariogram from a  Binomial  
###  RF with exponential correlation. 
###
###############################################################
set.seed(2111)

model="Binomial";n=20
# Set the coordinates of the points:
x = runif(500, 0, 1)
y = runif(500, 0, 1)
coords=cbind(x,y)

# Set the model's parameters:
corrmodel = "exponential"
mean = 0
nugget = 0
scale = 0.2/3

param=list(mean=mean, nugget=nugget, scale=scale)
# Simulation of the Gaussian RF:
data = GeoSim(coordx=coords, corrmodel=corrmodel, model=model,param=param,n=n)$data

start=list(mean=0,scale=scale)
fixed=list(nugget=nugget)
# Maximum composite-likelihood fitting of the Binomial random field:
fit = GeoFit(data,coordx=coords, corrmodel=corrmodel,model=model,
             likelihood="Marginal",type='Pairwise',start=start,n=n,
             optimizer="BFGS", fixed=fixed,neighb=4)

# Empirical estimation of the variogram:
vario = GeoVariogram(data,coordx=coords,maxdist=0.5)

# Plot of covariance and variogram functions:
GeoCovariogram(fit, show.cov=TRUE,show.vario=TRUE, vario=vario,pch=20)


################################################################
###
### Example 3. Plot of fitted covariance and fitted 
### and empirical semivariogram from a  Weibull  RF
###   with Wend0 correlation. 
###
###############################################################
set.seed(111)

model="Weibull";shape=4
# Set the coordinates of the points:
x = runif(700, 0, 1)
y = runif(700, 0, 1)
coords=cbind(x,y)

# Set the model's parameters:
corrmodel = "Wend0"
mean = 0
nugget = 0
scale = 0.4
power2=4


param=list(mean=mean, nugget=nugget, scale=scale,shape=shape,power2=power2)
# Simulation of the Gaussian RF:
data = GeoSim(coordx=coords, corrmodel=corrmodel, model=model,param=param)$data

start=list(mean=0,scale=scale,shape=shape)
I=Inf
lower=list(mean=-I,scale=0,shape=0)
upper=list(mean= I,scale=I,shape=I)
fixed=list(nugget=nugget,power2=power2)

fit = GeoFit(data,coordx=coords, corrmodel=corrmodel,model=model,
             likelihood="Marginal",type='Pairwise',start=start,
             lower=lower,upper=upper,
             optimizer="nlminb", fixed=fixed,neighb=3)

# Empirical estimation of the variogram:
vario = GeoVariogram(data,coordx=coords,maxdist=0.5)

# Plot of covariance and variogram functions:
GeoCovariogram(fit, show.vario=TRUE, vario=vario,pch=20)

################################################################
###
### Example 4. Plot of  fitted  and empirical semivariogram
### from a space time Gaussian random fields  
### with double exponential correlation. 
###
###############################################################
set.seed(92)
# Define the spatial-coordinates of the points:
x = runif(50, 0, 1)
y = runif(50, 0, 1)
coords=cbind(x,y)
# Define the temporal sequence:
time = seq(0, 10, 1)


# Simulation of the spatio-temporal Gaussian random field:
data = GeoSim(coordx=coords, coordt=time, corrmodel="Exp_Exp",param=list(mean=mean,
              nugget=nugget,scale_s=0.5/3,scale_t=2/2,sill=sill))$data

fixed=list(nugget=0, mean=0)
start=list(scale_s=0.2, scale_t=0.5, sill=1)
# Maximum composite-likelihood fitting of the space-time Gaussian random field:
fit = GeoFit(data, coordx=coords, coordt=time, corrmodel="Exp_Exp", maxtime=1,
             neighb=3, likelihood="Marginal", type="Pairwise",fixed=fixed, start=start)

# Empirical estimation of spatio-temporal covariance:
vario = GeoVariogram(data,coordx=coords, coordt=time, maxtime=5,maxdist=0.5)

# Plot of the fitted space-time variogram
GeoCovariogram(fit,vario=vario,show.vario=TRUE)

# Plot of covariance, variogram and spatio and temporal profiles:
GeoCovariogram(fit,vario=vario,fix.lagt=1,fix.lags=1,show.vario=TRUE,pch=20)

</code></pre>

<hr>
<h2 id='GeoCovDisplay'>Image plot displaying the pattern of the sparsness  of a  covariance matrix.</h2><span id='topic+GeoCovDisplay'></span>

<h3>Description</h3>

<p>Image plot displaying the pattern of the sparsness  of a  covariance matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GeoCovDisplay(covmatrix,limits=FALSE,pch=2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GeoCovDisplay_+3A_covmatrix">covmatrix</code></td>
<td>
<p>An object of class  GeoCovmatrix. See the Section <b>Details</b>.</p>
</td></tr>
<tr><td><code id="GeoCovDisplay_+3A_limits">limits</code></td>
<td>
<p>Logical; If TRUE  and the covariance matrix is spatiotemporal or spatial bivariate
then vertical and horizontal lines are added  to the image plot.</p>
</td></tr>      
<tr><td><code id="GeoCovDisplay_+3A_pch">pch</code></td>
<td>
<p>Type of symbols to use in the image plot.</p>
</td></tr>
</table>


<h3>Details</h3>

 
<p>For a given covariance matrix object (<code><a href="#topic+GeoCovmatrix">GeoCovmatrix</a></code>)
the function diplays the  pattern of   the sparsness  of a  covariance matrix
where the white color represents 0 entries and black color represents  non zero entries</p>


<h3>Value</h3>

<p>Produces a plot. No values are returned.</p>


<h3>Author(s)</h3>

<p>Moreno Bevilacqua, <a href="mailto:moreno.bevilacqua89@gmail.com">moreno.bevilacqua89@gmail.com</a>,<a href="https://sites.google.com/view/moreno-bevilacqua/home">https://sites.google.com/view/moreno-bevilacqua/home</a>,
Víctor Morales Oñate, <a href="mailto:victor.morales@uv.cl">victor.morales@uv.cl</a>, <a href="https://sites.google.com/site/moralesonatevictor/">https://sites.google.com/site/moralesonatevictor/</a>,
Christian&quot;, Caamaño-Carrillo, <a href="mailto:chcaaman@ubiobio.cl">chcaaman@ubiobio.cl</a>,<a href="https://www.researchgate.net/profile/Christian-Caamano">https://www.researchgate.net/profile/Christian-Caamano</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+GeoCovmatrix">GeoCovmatrix</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(GeoModels)


  # Define the spatial-coordinates of the points:
x &lt;- runif(100, 0, 2)
y &lt;- runif(100, 0, 2)
coords=cbind(x,y)
matrix1 &lt;- GeoCovmatrix(coordx=coords, corrmodel="GenWend", param=list(smooth=0,
                      power2=4,sill=1,scale=0.2,nugget=0))
 
GeoCovDisplay(matrix1)

</code></pre>

<hr>
<h2 id='GeoCovmatrix'>Spatial and Spatio-temporal Covariance Matrix of (non) Gaussian random fields</h2><span id='topic+GeoCovmatrix'></span>

<h3>Description</h3>

<p>The function computes the  covariance matrix associated to 
a spatial or spatio(-temporal) or a bivariate spatial Gaussian or non Gaussian randomm field
with given  underlying covariance model and a  set of spatial location sites (and temporal instants).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GeoCovmatrix(coordx, coordy=NULL, coordt=NULL, coordx_dyn=NULL, corrmodel,
          distance="Eucl", grid=FALSE, maxdist=NULL, maxtime=NULL,
          model="Gaussian", n=1, param, anisopars=NULL, radius=6371, sparse=FALSE,
          taper=NULL, tapsep=NULL, type="Standard",copula=NULL,X=NULL,spobj=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GeoCovmatrix_+3A_coordx">coordx</code></td>
<td>
<p>A numeric (<code class="reqn">d \times 2</code>)-matrix (where
<code>d</code> is the number of spatial sites) giving 2-dimensions 
of spatial coordinates or a numeric <code class="reqn">d</code>-dimensional vector giving
1-dimension of spatial coordinates. Coordinates on a sphere for a 
fixed radius <code>radius</code> are passed in lon/lat format expressed in decimal degrees.</p>
</td></tr>
<tr><td><code id="GeoCovmatrix_+3A_coordy">coordy</code></td>
<td>
<p>A numeric vector giving 1-dimension of
spatial coordinates; <code>coordy</code> is interpreted only 
if <code>coordx</code> is a numeric vector or <code>grid=TRUE</code> otherwise it 
will be ignored. Optional argument, the default is <code>NULL</code> then
<code>coordx</code> is expected to be numeric a (<code class="reqn">d \times 2</code>)-matrix.</p>
</td></tr>
<tr><td><code id="GeoCovmatrix_+3A_coordt">coordt</code></td>
<td>
<p>A numeric vector giving 1-dimension of
temporal coordinates. At the moment implemented only for the
Gaussian case. Optional argument, the default is <code>NULL</code>
then a spatial random field is expected.</p>
</td></tr>
<tr><td><code id="GeoCovmatrix_+3A_coordx_dyn">coordx_dyn</code></td>
<td>
<p>A list of <code class="reqn">T</code> numeric (<code class="reqn">d_t \times 2</code>)-matrices
containing dynamical (in time) coordinates. Optional argument, the default is <code>NULL</code>
</p>
</td></tr>
<tr><td><code id="GeoCovmatrix_+3A_corrmodel">corrmodel</code></td>
<td>
<p>String; the name of a correlation model, for the
description see the Section <b>Details</b>.</p>
</td></tr>
<tr><td><code id="GeoCovmatrix_+3A_distance">distance</code></td>
<td>
<p>String; the name of the spatial distance. The default
is <code>Eucl</code>, the euclidean distance. See <code><a href="#topic+GeoFit">GeoFit</a></code>.</p>
</td></tr>
<tr><td><code id="GeoCovmatrix_+3A_grid">grid</code></td>
<td>
<p>Logical; if <code>FALSE</code> (the default) the data
are interpreted as spatial or spatial-temporal realisations on a set
of non-equispaced spatial sites (irregular grid). See
<code><a href="#topic+GeoFit">GeoFit</a></code>.</p>
</td></tr>
<tr><td><code id="GeoCovmatrix_+3A_maxdist">maxdist</code></td>
<td>
<p>Numeric; an optional positive value indicating the
marginal spatial compact support in the case of tapered covariance matrix.
See <code><a href="#topic+GeoFit">GeoFit</a></code>.</p>
</td></tr>
<tr><td><code id="GeoCovmatrix_+3A_maxtime">maxtime</code></td>
<td>
<p>Numeric; an optional positive value indicating the
marginal temporal compact support in the case of  spacetime tapered 
covariance matrix.  See <code><a href="#topic+GeoFit">GeoFit</a></code>.</p>
</td></tr>
<tr><td><code id="GeoCovmatrix_+3A_n">n</code></td>
<td>
<p>Numeric; the number of trials in a binomial random fields.
Default is <code class="reqn">1</code>.</p>
</td></tr> 
<tr><td><code id="GeoCovmatrix_+3A_model">model</code></td>
<td>
<p>String; the type of RF. See <code><a href="#topic+GeoFit">GeoFit</a></code>.</p>
</td></tr>
<tr><td><code id="GeoCovmatrix_+3A_param">param</code></td>
<td>
<p>A list of parameter values required  for the covariance
model.</p>
</td></tr>
<tr><td><code id="GeoCovmatrix_+3A_anisopars">anisopars</code></td>
<td>
<p> A list of two elements &quot;angle&quot; and &quot;ratio&quot; i.e. the anisotropy angle and the anisotropy ratio, respectively.</p>
</td></tr>
<tr><td><code id="GeoCovmatrix_+3A_radius">radius</code></td>
<td>
<p>Numeric; a value indicating  the radius of the sphere 
when using covariance models valid using the great circle distance. 
Default value is the radius of the earth in Km (i.e. 6371)</p>
</td></tr> 
<tr><td><code id="GeoCovmatrix_+3A_sparse">sparse</code></td>
<td>
<p>Logical; if <code>TRUE</code> the function return an object of class spam.
This option  should be used when  a parametric compactly supporte covariance is 
used. Default is FALSE. </p>
</td></tr>
<tr><td><code id="GeoCovmatrix_+3A_taper">taper</code></td>
<td>
<p>String; the name of the taper correlation
function if type is  <code>Tapering</code>, see the Section <b>Details</b>.</p>
</td></tr>
<tr><td><code id="GeoCovmatrix_+3A_tapsep">tapsep</code></td>
<td>
<p>Numeric; an optional  value indicating the separabe parameter in
the space-time non separable taper or the colocated correlation parameter in a bivariate 
spatial taper (see <b>Details</b>).</p>
</td></tr> 
<tr><td><code id="GeoCovmatrix_+3A_type">type</code></td>
<td>
<p>String; the type of covariance matrix
<code>Standard</code> (the default) or <code>Tapering</code> for tapered covariance matrix. </p>
</td></tr>
<tr><td><code id="GeoCovmatrix_+3A_copula">copula</code></td>
<td>
<p>String; the type of copula. It can be &quot;Clayton&quot; or &quot;Gaussian&quot;</p>
</td></tr>
<tr><td><code id="GeoCovmatrix_+3A_x">X</code></td>
<td>
<p>Numeric; Matrix of space-time covariates.</p>
</td></tr>
<tr><td><code id="GeoCovmatrix_+3A_spobj">spobj</code></td>
<td>
<p>An object of class sp or spacetime</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In the spatial case, the covariance matrix of the 
random vector </p>
<p style="text-align: center;"><code class="reqn">[Z(s_1),\ldots,Z(s_n,)]^T</code>
</p>
  
<p>with a specific spatial covariance model is computed. Here  <code class="reqn">n</code> is the number of the spatial location sites.
</p>
<p>In the space-time case,  the covariance matrix of the 
random vector </p>
<p style="text-align: center;"><code class="reqn">[Z(s_1,t_1),Z(s_2,t_1),\ldots,Z(s_n,t_1),\ldots,Z(s_n,t_m)]^T</code>
</p>

<p>with a specific  space time covariance model is computed.   Here <code class="reqn">m</code>  is the number of temporal instants.
</p>
<p>In the bivariate case, the covariance matrix of the 
random vector </p>
<p style="text-align: center;"><code class="reqn">[Z_1(s_1),Z_2(s_1),\ldots,Z_1(s_n),Z_2(s_n)]^T</code>
</p>

<p>with a specific spatial bivariate covariance model is computed.
</p>
<p>The location site <code class="reqn">s_i</code> can be a point in the <code class="reqn">d</code>-dimensional euclidean space with <code class="reqn">d=2</code>
or a point (given in lon/lat degree format) on a  sphere of arbitrary radius.
</p>
<p>Here there is the list of all the implemented space and space-time and bivariate 
correlation models. 
The argument <code>param</code> is a list including all the parameters of a given
correlation  model specified by  the argument <code>corrmodel</code>.
For each correlation model one can check the associated  parameters' names using <code><a href="#topic+CorrParam">CorrParam</a></code>.
In what follows 
<code class="reqn">\kappa&gt;0</code>, <code class="reqn">\beta&gt;0</code>, <code class="reqn"> \alpha, \alpha_s, \alpha_t \in (0,2] </code>,  and <code class="reqn">\gamma \in [0,1]</code>.
The associated parameters in the argument <code>param</code> are 
<code>smooth</code>, <code>power2</code>, <code>power</code>, <code>power_s</code>, <code>power_t</code> and <code>sep</code> respectively.
Moreover let <code class="reqn">1(A)=1</code>  when <code class="reqn">A</code> is true and <code class="reqn">0</code> otherwise.
</p>

<ul>
<li><p> Spatial correlation models:
</p>

<ol>
<li> <p><code class="reqn">Cauchy</code> defined as:
</p>
<p style="text-align: center;"><code class="reqn">R(h) = \left(1+h^2\right)^{-\beta/2}</code>
</p>

<p>It is a special case of the  <code>Gencauchy</code> model.
</p>
</li>
<li> <p><code class="reqn">Exp</code> defined as:
</p>
<p style="text-align: center;"><code class="reqn">R(h)  =e^{-h}</code>
</p>

<p>This model is a special case of the <code>Matern</code> and the <code>Stable</code> model.
</p>
</li>
<li> <p><code class="reqn">GenCauchy</code> (generalised <code class="reqn">Cauchy</code> in Gneiting and Schlater (2004)) defined as:
</p>
<p style="text-align: center;"><code class="reqn">R(h) = ( 1+h^{\alpha} )^{-\beta / \alpha}</code>
</p>
 
<p>If <code class="reqn">h</code> is the geodesic distance then <code class="reqn">\alpha \in (0,1]</code>.
</p>
</li>
<li> <p><code class="reqn">Matern</code> defined as:
</p>
<p style="text-align: center;"><code class="reqn">R(h) = 2^{1-\kappa} \Gamma(\kappa)^{-1} h^\kappa K_\kappa(h)</code>
</p>

<p>If <code class="reqn">h</code> is the geodesic distance then <code class="reqn">\kappa \in (0,0.5]</code>
</p>
</li>
<li> <p><code class="reqn">Kummer</code> (Kummer hypergeometric in  Ma and Bhadra (2022)) defined as:
</p>
<p style="text-align: center;"><code class="reqn">R(h) = \Gamma(\kappa+\alpha) U(\alpha,1-\kappa,\kappa h^2 ) / \Gamma(\kappa+\alpha)</code>
</p>

<p><code class="reqn">U(.,.,.)</code> is the Kummer hypergeometric function.
If <code class="reqn">h</code> is the geodesic distance then <code class="reqn">\kappa \in (0,0.5]</code>
</p>
</li>
<li> <p><code class="reqn">Kummer{\_}Matern</code> It is a rescaled version of the  <code class="reqn">Kummer</code> model  
that is <code class="reqn">h</code> must be divided by <code class="reqn">2(\kappa(1+\alpha)^{0.5}</code>.  When  <code class="reqn">\alpha</code> goes to infinity it is the Matern model. 
</p>
</li>
<li> <p><code class="reqn">Stable</code> defined as:
</p>
<p style="text-align: center;"><code class="reqn">R(h) = e^{-h^{\alpha}}</code>
</p>

<p>If <code class="reqn">h</code> is the geodesic distance then <code class="reqn">\alpha \in (0,1]</code>.
</p>
</li>
<li> <p><code class="reqn">Wave</code> defined as:
</p>
<p style="text-align: center;"><code class="reqn">R(h)=sin(h)/h</code>
</p>
 
<p>This model is valid only for dimensions less than or equal to 3.
</p>
</li>
<li> <p><code class="reqn">Wend0</code> defined as:
</p>
<p style="text-align: center;"><code class="reqn">R(h) = (1-h )^{\mu} 1(h \in [0,1])</code>
</p>

<p>where  <code class="reqn">\mu \ge 0.5(d+1)</code>. If <code class="reqn">h</code> is the geodesic distance then <code class="reqn">\mu \ge 2</code>.
</p>
</li>
<li> <p><code class="reqn">Wend1</code> defined as:
</p>
<p style="text-align: center;"><code class="reqn">R(h) = (1-h )^{\mu+1} (1+(\mu+1) h) 1(h \in [0,1])</code>
</p>

<p>where   <code class="reqn">\mu \ge 0.5(d+1)+1</code>. If <code class="reqn">h</code> is the geodesic distance then <code class="reqn">\mu \ge 4</code>.
</p>
</li>
<li> <p><code class="reqn">Wend2</code> defined as:
</p>
<p style="text-align: center;"><code class="reqn">R(h) = (1-h )^{\mu+2} (1+(\mu+2) h+ (1/3)((\mu+1)^2-1) h^2 ) 1(h \in [0,1])  </code>
</p>

<p>where <code class="reqn">\mu \ge 0.5(d+1)+2</code>. If <code class="reqn">h</code> is the geodesic distance then <code class="reqn">\mu \ge 6</code>.
</p>
</li>
<li> <p><code class="reqn">GenWend</code> (Generalized Wendland in  Bevilacqua et al.(2019)) defined as:
</p>
<p style="text-align: center;"><code class="reqn">R(h) =  A (1-h^2)^{\beta+\kappa} F(\beta/2,(\beta+1)/2,2\beta+\kappa+1,1-h^2) 1(h \in [0,1]) </code>
</p>

<p>where   <code class="reqn">\mu \ge 0.5(d+1)+\kappa</code>
and <code class="reqn">A=(\Gamma(\kappa)\Gamma(2\kappa+\beta+1))/(\Gamma(2\kappa)\Gamma(\beta+1-\kappa)2^{\beta+1})</code> and $F(.,.,.)$ 
is the Gaussian hypergeometric function.
The cases <code class="reqn">\kappa=0,1,2</code> correspond to the <code class="reqn">Wend0</code>, <code class="reqn">Wend1</code> and <code class="reqn">Wend2</code> respectively. 
</p>
</li>
<li> <p><code class="reqn">GenWend_{\_}Matern</code> (Generalized Wendland Matern in  Bevilacqua et al. (2022)). It is defined as a rescaled version of the Generalized Wendland that is <code class="reqn">h</code> must be divided by 
<code class="reqn">(\Gamma(\beta+2\kappa+1)/\Gamma(\beta))^{1/(1+2\kappa)}</code>. When  <code class="reqn">\beta</code> goes to infinity it is the Matern model.
</p>
</li>
<li> <p><code class="reqn">Hypergeometric2</code> (Hypegeometric model in Alegria and Emery (2022)) defined as:
</p>
<p style="text-align: center;"><code class="reqn">R(h) =  A (1-h^2)^{\beta+\alpha-\kappa-2} F(\beta-\kappa,\alpha-\kappa,\beta+\alpha-\kappa-1,1-h^2) 1(h \in [0,1]) </code>
</p>

<p>where   <code class="reqn">\mu \ge 0.5(d+1)+\kappa</code>
and <code class="reqn">A=(\Gamma(\beta-1)\Gamma(\alpha-1))/(\Gamma(\beta+\alpha-\kappa-1)\Gamma(\kappa-1))</code> and $F(.,.,.)$ 
is the Gaussian hypergeometric function.
</p>
</li>
<li> <p><code class="reqn">Hypergeometric</code> (Parsimonious Hypegeometric model in Alegria and Emery (2022)) defined as the model <code class="reqn">Hypergeometric2</code> with the restriction <code class="reqn">\beta=\alpha</code>. 
</p>
</li>
<li> <p><code class="reqn">Hypergeometric{\_}Matern</code> It is a rescaled version of the  Parsimonious  <code class="reqn">Hypergeometric</code> model  
that is <code class="reqn">h</code> must be divided by <code class="reqn">2\beta</code>.  When  <code class="reqn">\beta</code> goes to infinity it is the Matern model. 
</p>
</li>
<li> <p><code class="reqn">Multiquadric</code> defined as:
</p>
<p style="text-align: center;"><code class="reqn">R(h) = (1-\alpha0.5)^{2\beta}/(1+(\alpha0.5)^{2}-\alpha cos(h))^{\beta}, \quad h \in [0,\pi]</code>
</p>

<p>This model is valid on the unit sphere and <code class="reqn">h</code> is the geodesic distance.
</p>
</li>
<li> <p><code class="reqn">Sinpower</code> defined as:
</p>
<p style="text-align: center;"><code class="reqn">R(h) = 1-(sin(h/2))^{\alpha},\quad h \in [0,\pi]</code>
</p>

<p>This model is valid on the unit sphere and <code class="reqn">h</code> is the geodesic distance.
</p>
</li>
<li> <p><code class="reqn">Smoke</code> (F family in   Alegria et al. (2021)) defined as:
</p>
<p style="text-align: center;"><code class="reqn">R(h) =   K*F(1/{\alpha},1/{\alpha}+0.5,
                2/{\alpha}+0.5+{\kappa}),\quad h \in [0,\pi]</code>
</p>

<p>where      <code class="reqn">K =(\Gamma(a)\Gamma(i))/\Gamma(i)\Gamma(o)) </code>.      
This model is valid on the unit sphere and <code class="reqn">h</code> is the geodesic distance.
</p>
</li></ol>

</li>
<li><p> Spatio-temporal correlation models. 
</p>

<ul>
<li><p> Non-separable models:
</p>

<ol>
<li> <p><code class="reqn">Gneiting</code> defined as:
</p>
<p style="text-align: center;"><code class="reqn">R(h, u) = e^{ -h^{\alpha_s}/((1+u^{\alpha_t})^{0.5 \gamma \alpha_s })}/(1+u^{\alpha_t})</code>
</p>

</li>
<li> <p><code class="reqn">Gneiting</code><code>_</code><code class="reqn">GC</code> 
</p>
<p style="text-align: center;"><code class="reqn">R(h, u) =  e^{  -u^{\alpha_t} /((1+h^{\alpha_s})^{0.5 \gamma \alpha_t}) }/( 1+h^{\alpha_s}) </code>
</p>

<p>where <code class="reqn">h</code>  can be both the euclidean and the geodesic distance
</p>
</li>
<li> <p><code class="reqn">Iacocesare</code> 
</p>
<p style="text-align: center;"><code class="reqn">R(h, u) = (1+h^{\alpha_s}+u^\alpha_t)^{-\beta}</code>
</p>

</li>
<li> <p><code class="reqn">Porcu</code> 
</p>
<p style="text-align: center;"><code class="reqn">R(h, u) = (0.5 (1+h^{\alpha_s})^\gamma +0.5 (1+u^{\alpha_t})^\gamma)^{-\gamma^{-1}}</code>
</p>

</li>
<li> <p><code class="reqn">Porcu1</code> 
</p>
<p style="text-align: center;"><code class="reqn">R(h, u) =(e^{ -h^{\alpha_s} ( 1+u^{\alpha_t})^{0.5 \gamma \alpha_s}}) / ((1+u^{\alpha_t})^{1.5})</code>
</p>

</li>
<li> <p><code class="reqn">Stein</code> 
</p>
<p style="text-align: center;"><code class="reqn">R(h, u) = (h^{\psi(u)}K_{\psi(u)}(h))/(2^{\psi(u)}\Gamma(\psi(u)+1))</code>
</p>

<p>where <code class="reqn">\psi(u)=\nu+u^{0.5\alpha_t} </code>
</p>
</li>
<li> <p><code class="reqn">Gneiting</code><code>_</code><code class="reqn">mat</code><code>_</code><code class="reqn">S</code>,  defined as:
</p>
<p style="text-align: center;"><code class="reqn">R(h, u) =\phi(u)^{\tau_t}Mat(h\phi(u)^{-\beta},\nu_s)</code>
</p>

<p>where  <code class="reqn">\phi(u)=(1+u^{0.5\alpha_t})</code>,
<code class="reqn">\tau_t \ge  3.5+\nu_s</code>, <code class="reqn">\beta \in [0,1]</code>
</p>
</li>
<li> <p><code class="reqn">Gneiting</code><code>_</code><code class="reqn">mat</code><code>_</code><code class="reqn">T</code>,  defined interchanging h with u 
in <code class="reqn">Gneiting</code><code>_</code><code class="reqn">mat</code><code>_</code><code class="reqn">S</code>
</p>
</li>
<li> <p><code class="reqn">Gneiting</code><code>_</code><code class="reqn">wen</code><code>_</code><code class="reqn">S</code>,  defined as:
</p>
<p style="text-align: center;"><code class="reqn">R(h, u) =\phi(u)^{\tau_t}GenWend(h \phi(u)^{\beta},\nu_s,\mu_s)</code>
</p>

<p>where  <code class="reqn">\phi(u)=(1+u^{0.5\alpha_t})</code>,
<code class="reqn">\tau_t \geq 2.5+2\nu_s</code>, <code class="reqn">\beta \in [0,1]</code>
</p>
</li>
<li> <p><code class="reqn">Gneiting</code><code>_</code><code class="reqn">wen</code><code>_</code><code class="reqn">T</code>,  defined interchanging h with u 
in <code class="reqn">Gneiting</code><code>_</code><code class="reqn">wen</code><code>_</code><code class="reqn">S</code>
</p>
</li>
<li> <p><code class="reqn">Multiquadric</code><code>_</code><code class="reqn">st</code> defined as:
</p>
<p style="text-align: center;"><code class="reqn">R(h, u)= ((1-0.5\alpha_s)^2/(1+(0.5\alpha_s)^2-\alpha_s \psi(u) cos(h)))^{a_s} , \quad h \in [0,\pi]</code>
</p>

<p>where <code class="reqn">\psi(u)=(1+(u/a_t)^{\alpha_t})^{-1}</code>. This model is valid on the unit
sphere and <code class="reqn">h</code> is the geodesic distance.
</p>
</li>
<li> <p><code class="reqn">Sinpower</code><code>_</code><code class="reqn">st</code> defined as:
</p>
<p style="text-align: center;"><code class="reqn">R(h, u)=(e^{\alpha_s cos(h) \psi(u)/a_s} (1+\alpha_s cos(h) \psi(u) /a_s))/k</code>
</p>

<p>where <code class="reqn">\psi(u)=(1+(u/a_t)^{\alpha_t})^{-1} </code>    and <code class="reqn">k=(1+\alpha_s/a_s) exp(\alpha_s/a_s), \quad h \in [0,\pi]</code>
This model is valid on the unit sphere and <code class="reqn">h</code> is the geodesic distance.
</p>
</li></ol>
  
</li>
<li><p> Separable models.<br />
</p>
<p>Space-time separable correlation models are easly obtained as the product of a spatial and a temporal correlation model, that is
</p>
<p style="text-align: center;"><code class="reqn">R(h,u)=R(h) R(u)</code>
</p>

<p>Several combinations are possible:
</p>

<ol>
<li>  <p><code class="reqn">Exp</code><code>_</code><code class="reqn">Exp</code>  defined as:
</p>
<p style="text-align: center;"><code class="reqn">R(h, u) =Exp(h)Exp(u)</code>
</p>

</li>
<li>  <p><code class="reqn">Matern</code><code>_</code><code class="reqn">Matern</code> defined as:
</p>
<p style="text-align: center;"><code class="reqn">R(h, u) =Matern(h;\kappa_s)Matern(u;\kappa_t)</code>
</p>

</li>
<li>  <p><code class="reqn">GenWend</code><code>_</code><code class="reqn">GenWend</code> defined as 
</p>
<p style="text-align: center;"><code class="reqn">R(h, u) = GenWend(h;\kappa_s,\mu_s) GenWend(u;\kappa_t,\mu_t)</code>
</p>
<p>.
</p>
</li>
<li>  <p><code class="reqn">Stable</code><code>_</code><code class="reqn">Stable</code> defined as:
</p>
<p style="text-align: center;"><code class="reqn">R(h, u) =Stable(h;\alpha_s)Stable(u;\alpha_t)</code>
</p>

</li></ol>

<p>Note that some models are nested. (The <code class="reqn">Exp</code><code>_</code><code class="reqn">Exp</code> with <code class="reqn">Matern</code><code>_</code><code class="reqn">Matern</code> for instance.)
</p>
</li></ul>

</li>
<li><p> Spatial  bivariate correlation models (see below):
</p>

<ol>
<li>  <p><code class="reqn">Bi</code><code>_</code><code class="reqn">Matern</code> (Bivariate  full Matern model) 
</p>
</li>
<li>  <p><code class="reqn">Bi</code><code>_</code><code class="reqn">Matern</code><code>_</code><code class="reqn">contr</code> (Bivariate  Matern model with contrainsts) 
</p>
</li>
<li>  <p><code class="reqn">Bi</code><code>_</code><code class="reqn">Matern</code><code>_</code><code class="reqn">sep</code> (Bivariate  separable Matern model ) 
</p>
</li>
<li>  <p><code class="reqn">Bi</code><code>_</code><code class="reqn">LMC</code> (Bivariate  linear model of coregionalization)
</p>
</li>
<li>  <p><code class="reqn">Bi</code><code>_</code><code class="reqn">LMC</code><code>_</code><code class="reqn">contr</code> (Bivariate  linear model of coregionalization with constraints ) 
</p>
</li>
<li>  <p><code class="reqn">Bi</code><code>_</code><code class="reqn">Wendx</code> (Bivariate  full Wendland model) 
</p>
</li>
<li>  <p><code class="reqn">Bi</code><code>_</code><code class="reqn">Wendx</code><code>_</code><code class="reqn">contr</code> (Bivariate  Wendland model with contrainsts) 
</p>
</li>
<li>  <p><code class="reqn">Bi</code><code>_</code><code class="reqn">Wendx</code><code>_</code><code class="reqn">sep</code> (Bivariate  separable Wendland model) 
</p>
</li>
<li>  <p><code class="reqn">Bi</code><code>_</code><code class="reqn">Smoke</code> (Bivariate  full Smoke model on the unit sphere) 
</p>
</li></ol>

</li>
<li><p> Spatial taper.<br />
For spatial covariance tapering the taper functions are:
</p>

<ol>
<li> <p><code class="reqn">Bohman</code> defined as:
</p>
<p style="text-align: center;"><code class="reqn">T(h)=(1-h)(sin(2\pi h)/(2 \pi h))+(1-cos(2\pi h))/(2\pi^{2}h) 1_{[0,1]}(h)</code>
</p>

</li>
<li> <p><code class="reqn">Wendlandx, \quad x=0,1,2</code> defined as:
</p>
<p style="text-align: center;"><code class="reqn">T(h)=Wendx(h;x+2),   x=0,1,2</code>
</p>
<p>.
</p>
</li></ol>

</li>
<li><p> Spatio-temporal tapers. <br />
For spacetime covariance tapering the taper functions are:
</p>

<ol>
<li> <p><code class="reqn">Wendlandx</code><code>_</code><code class="reqn">Wendlandy</code>  (Separable tapers) <code class="reqn">x,y=0,1,2</code> defined as:
</p>
<p style="text-align: center;"><code class="reqn">T(h,u)=Wendx(h;x+2) Wendy(h;y+2),    x,y=0,1,2.</code>
</p>

</li>
<li> <p><code class="reqn">Wendlandx</code><code>_</code><code class="reqn">time</code> (Non separable temporal taper)  <code class="reqn">x=0,1,2</code> defined as:
<code class="reqn">Wenx</code><code>_</code><code class="reqn">time</code>, <code class="reqn">x=0,1,2</code>  assuming <code class="reqn">\alpha_t=2</code>, <code class="reqn">\mu_s=3.5+x</code>
and <code class="reqn">\gamma \in [0,1]</code> to be fixed using <code>tapsep</code>.
</p>
</li>
<li> <p><code class="reqn">Wendlandx</code><code>_</code><code class="reqn">space</code> (Non separable spatial taper)  <code class="reqn">x=0,1,2</code> defined as:
<code class="reqn">Wenx</code><code>_</code><code class="reqn">space</code>, <code class="reqn">x=0,1,2</code>  assuming <code class="reqn">\alpha_s=2</code>, <code class="reqn">\mu_t=3.5+x</code>
and <code class="reqn">\gamma \in [0,1]</code> to be fixed using <code>tapsep</code>.
</p>
</li></ol>

</li>
<li><p> Spatial  bivariate taper (see below).
</p>

<ol>
<li> <p><code class="reqn">Bi</code><code>_</code><code class="reqn">Wendlandx, \quad x=0,1,2</code>
</p>
</li></ol>

</li></ul>

<p><b>Remarks</b>:<br />
In what follows we assume <code class="reqn">\sigma^2,\sigma_1^2,\sigma_2^2,\tau^2,\tau_1^2,\tau_2^2,
 a,a_s,a_t,a_{11},a_{22},a_{12},\kappa_{11},\kappa_{22},\kappa_{12},f_{11},f_{12},f_{21},f_{22}</code> positive.
</p>
<p>The associated names of the parameters in  <code>param</code> are 
<code>sill</code>, <code>sill_1</code>,<code>sill_2</code>,
<code>nugget</code>, <code>nugget_1</code>,<code>nugget_2</code>,
<code>scale</code>,<code>scale_s</code>,<code>scale_t</code>, <code>scale_1</code>,<code>scale_2</code>,<code>scale_12</code>,
<code>smooth_1</code>,<code>smooth_2</code>,<code>smooth_12</code>, <code>a_1</code>,<code>a_12</code>,<code>a_21</code>,<code>a_2</code>
respectively.
</p>
<p>Let <code class="reqn">R(h)</code> be a  spatial correlation model given in standard notation.
Then the covariance model
applied with arbitrary variance, nugget  and scale equals to <code class="reqn">\sigma^2</code> if <code class="reqn">h=0</code> and
</p>
<p style="text-align: center;"><code class="reqn">C(h)=\sigma^2(1-\tau^2 ) R( h/a,,...), \quad     h &gt; 0</code>
</p>

<p>with nugget parameter  <code class="reqn">\tau^2</code> between 0 and 1.
Similarly if <code class="reqn">R(h,u)</code> is a spatio-temporal correlation model given in standard notation,
then the covariance model is <code class="reqn">\sigma^2</code> if <code class="reqn">h=0</code> and <code class="reqn">u=0</code> and 
</p>
<p style="text-align: center;"><code class="reqn">C(h,u)=\sigma^2(1-\tau^2 )R(h/a_s ,u/a_t,...) \quad h&gt;0, u&gt;0 </code>
</p>

<p>Here &lsquo;...&rsquo; stands for additional parameters.
</p>
<p>The bivariate models implemented are the following :
</p>

<ol>
<li> <p><code class="reqn">Bi</code><code>_</code><code class="reqn">Matern</code>  defined as: 
</p>
<p style="text-align: center;"><code class="reqn">C_{ij}(h)=\rho_{ij} (\sigma_i  \sigma_j+\tau_i^2 1(i=j,h=0))  Matern(h/a_{ij},\kappa_{ij}) \quad i,j=1,2.\quad h\ge 0</code>
</p>

<p>where <code class="reqn">\rho=\rho_{12}=\rho_{21}</code> is the correlation colocated parameter and   <code class="reqn">\rho_{ii}=1</code>.
The model  <code class="reqn">Bi</code><code>_</code><code class="reqn">Matern</code><code>_</code><code class="reqn">sep</code>  (separable matern) is a special case when
<code class="reqn">a=a_{11}=a_{12}=a_{22}</code> and <code class="reqn">\kappa=\kappa_{11}=\kappa_{12}=\kappa_{22}</code>.
The model  <code class="reqn">Bi</code><code>_</code><code class="reqn">Matern</code><code>_</code><code class="reqn">contr</code>  (constrained matern)
is a special case when <code class="reqn">a_{12}=0.5  (a_{11} + a_{22})</code> and  <code class="reqn">\kappa_{12}=0.5  (\kappa_{11} + \kappa_{22})</code>
</p>
</li>
<li> <p><code class="reqn">Bi</code><code>_</code><code class="reqn">Wendx</code>  (<code class="reqn">x=0,1,2</code>) defined as:
</p>
<p style="text-align: center;"><code class="reqn">C_{ij}(h)=\rho_{ij} (\sigma_i  \sigma_j+\tau_i^2 1(i=j,h=0))   Wendx(h/a_{ij},\nu_{ij}+1) \quad i,j=1,2.\quad h\ge 0</code>
</p>

<p>where <code class="reqn">\rho=\rho_{12}=\rho_{21}</code> is the correlation colocated parameter and   <code class="reqn">\rho_{ii}=1</code>.
The model  <code class="reqn">Bi</code><code>_</code><code class="reqn">Wendx</code><code>_</code><code class="reqn">sep</code>  (separable wendland) is a special case when
<code class="reqn">a=a_{11}=a_{12}=a_{22}</code> and <code class="reqn">\mu=\mu_{11}=\mu_{12}=\mu_{22}</code>.
The model  <code class="reqn">Bi</code><code>_</code><code class="reqn">Wendx</code><code>_</code><code class="reqn">contr</code>  (constrained matern)
is a special case when <code class="reqn">a_{12}=0.5  (a_{11} + a_{22})</code> and  <code class="reqn">\mu_{12}=0.5  (\mu_{11} + \mu_{22})</code>
</p>
</li>
<li>  <p><code class="reqn">Bi</code><code>_</code><code class="reqn">LMC</code> defined as:
</p>
<p style="text-align: center;"><code class="reqn">C_{ij}(h)=\sum_{k=1}^{2} (f_{ik}f_{jk}+\tau_i^2 1(i=j,h=0))   R(h/a_{k})       </code>
</p>

<p>where  <code class="reqn">R(h)</code> is a correlation model.
The model <code class="reqn">Bi</code><code>_</code><code class="reqn">LMC</code><code>_</code><code class="reqn">contr</code>
is a special case when  <code class="reqn">f=f_{12}=f_{21}</code>.   
Bivariate LMC models, in the current version of the package, is obtained with <code class="reqn">R(h)</code>  equal to the exponential correlation  model.
</p>
</li></ol>



<h3>Value</h3>

<p>Returns an object of class <code>GeoCovmatrix</code>.
An object of class <code>GeoCovmatrix</code> is a list containing
at most the following components:
</p>
<table>
<tr><td><code>bivariate</code></td>
<td>
<p>Logical:<code>TRUE</code> if the Gaussian random field is bivariaete
otherwise  <code>FALSE</code>;</p>
</td></tr>
<tr><td><code>coordx</code></td>
<td>
<p>A <code class="reqn">d</code>-dimensional vector of spatial coordinates;</p>
</td></tr>
<tr><td><code>coordy</code></td>
<td>
<p>A <code class="reqn">d</code>-dimensional vector of spatial coordinates;</p>
</td></tr>
<tr><td><code>coordt</code></td>
<td>
<p>A <code class="reqn">t</code>-dimensional vector of temporal coordinates;</p>
</td></tr>
<tr><td><code>coordx_dyn</code></td>
<td>
<p>A  list of <code class="reqn">t</code>  matrices of spatial coordinates;</p>
</td></tr>
<tr><td><code>covmatrix</code></td>
<td>
<p>The covariance matrix if <code>type</code> is<code>Standard</code>. An object of 
class spam if <code>type</code> is <code>Tapering</code> or <code>Standard</code> and
<code>sparse</code> is TRUE.</p>
</td></tr>
<tr><td><code>corrmodel</code></td>
<td>
<p>String: the correlation model;</p>
</td></tr>
<tr><td><code>distance</code></td>
<td>
<p>String: the type of spatial distance;</p>
</td></tr>
<tr><td><code>grid</code></td>
<td>
<p>Logical:<code>TRUE</code> if the spatial data are in a regular grid, otherwise  <code>FALSE</code>;</p>
</td></tr>
<tr><td><code>nozero</code></td>
<td>
<p>In the case of tapered matrix  the percentage of non zero values in the 
covariance matrix. Otherwise is NULL.</p>
</td></tr>
<tr><td><code>maxdist</code></td>
<td>
<p>Numeric: the marginal spatial compact support 
if <code>type</code> is <code>Tapering</code>;</p>
</td></tr>
<tr><td><code>maxtime</code></td>
<td>
<p>Numeric: the marginal temporal compact support 
if <code>type</code> is <code>Tapering</code>; </p>
</td></tr>
<tr><td><code>n</code></td>
<td>
<p>The number of trial for Binomial RFs</p>
</td></tr>       
<tr><td><code>namescorr</code></td>
<td>
<p>String: The names of the correlation parameters; </p>
</td></tr>
<tr><td><code>numcoord</code></td>
<td>
<p>Numeric: the number of spatial coordinates;</p>
</td></tr>
<tr><td><code>numtime</code></td>
<td>
<p>Numeric: the number the temporal  coordinates;</p>
</td></tr>
<tr><td><code>model</code></td>
<td>
<p>The type of RF, see <code><a href="#topic+GeoFit">GeoFit</a></code>.</p>
</td></tr>
<tr><td><code>param</code></td>
<td>
<p>Numeric: The covariance parameters;</p>
</td></tr>
<tr><td><code>tapmod</code></td>
<td>
<p>String: the taper model if <code>type</code> is <code>Tapering</code>. Otherwise is NULL.</p>
</td></tr>
<tr><td><code>spacetime</code></td>
<td>
<p><code>TRUE</code> if spatio-temporal and <code>FALSE</code> if spatial covariance model;</p>
</td></tr>
<tr><td><code>sparse</code></td>
<td>
<p>Logical: is the  returned object of class spam? ;</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Moreno Bevilacqua, <a href="mailto:moreno.bevilacqua89@gmail.com">moreno.bevilacqua89@gmail.com</a>,<a href="https://sites.google.com/view/moreno-bevilacqua/home">https://sites.google.com/view/moreno-bevilacqua/home</a>,
Víctor Morales Oñate, <a href="mailto:victor.morales@uv.cl">victor.morales@uv.cl</a>, <a href="https://sites.google.com/site/moralesonatevictor/">https://sites.google.com/site/moralesonatevictor/</a>,
Christian&quot;, Caamaño-Carrillo, <a href="mailto:chcaaman@ubiobio.cl">chcaaman@ubiobio.cl</a>,<a href="https://www.researchgate.net/profile/Christian-Caamano">https://www.researchgate.net/profile/Christian-Caamano</a>
</p>


<h3>References</h3>

<p>Alegria, A.,Cuevas-Pacheco, F.,Diggle, P, Porcu E. (2021)
The F-family of covariance functions: A Matérn analogue for modeling random fields on spheres.
<em>Spatial Statistics</em> 43, 100512
</p>
<p>Bevilacqua, M., Faouzi, T., Furrer, R., and Porcu, E. (2019). Estimation and prediction 
using generalized Wendland functions under fixed domain asymptotics. 
<em>Annals of Statistics</em>, 47(2), 828&ndash;856.
</p>
<p>Bevilacqua, M., Caamano-Carrillo, C., and Porcu, E. (2022). Unifying compactly supported 
and Matérn covariance functions in spatial statistics. 
<em>Journal of Multivariate Analysis</em>, 189, 104949.
</p>
<p>Daley J. D., Porcu E., Bevilacqua M. (2015) 
Classes of compactly supported covariance functions for multivariate random fields. 
<em>Stochastic Environmental Research and Risk Assessment</em>. 29 (4), 1249&ndash;1263. 
</p>
<p>Emery, X. and Alegria, A. (2022). The gauss hypergeometric covariance kernel for modeling second-order stationary random fields in euclidean spaces: its compact support, properties and spectral representation. <em>Stochastic Environmental Research and Risk Assessment</em>. 36 2819&ndash;2834.
</p>
<p>Gneiting, T. (2002). Nonseparable, stationary covariance functions for space-time data.
<em>Journal of the American Statistical Association</em>, 97, 590&ndash;600.
</p>
<p>Gneiting T, Kleiber W., Schlather M. 2010. Matern cross-covariance 
functions for multivariate random fields.  
<em>Journal of the American Statistical Association</em>, 105, 1167&ndash;1177.
</p>
<p>Ma, P., Bhadra, A. (2022). 
Beyond Matérn: on a class of interpretable confluent hypergeometric covariance functions.
<em>Journal of the American Statistical Association</em>,1&ndash;14.
</p>
<p>Porcu, E.,Bevilacqua, M. and Genton M.  (2015) 
Spatio-Temporal Covariance and Cross-Covariance Functions of the Great Circle Distance on a Sphere. 
<em>Journal of the American Statistical Association</em>. 
DOI: 10.1080/01621459.2015.1072541
</p>
<p>Gneiting, T. and Schlater M. (2004) 
Stochastic models that separate fractal dimension and the Hurst effect. 
<em>SSIAM Rev</em> 46, 269&ndash;282.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+GeoKrig">GeoKrig</a></code>,
<code><a href="#topic+GeoSim">GeoSim</a></code>,
<code><a href="#topic+GeoFit">GeoFit</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>library(GeoModels)


################################################################
###
### Example 1. Spatial covariance matrix associated to
### the Matern correlation model
###
###############################################################

# Define the spatial-coordinates of the points:
x = runif(500, 0, 1)
y = runif(500, 0, 1)
coords = cbind(x,y)

# Correlation Parameters for Matern model 
CorrParam("Matern")

# Matern Parameters 
param=list(smooth=0.5,sill=1,scale=0.2,nugget=0)

matrix1 = GeoCovmatrix(coordx=coords, corrmodel="Matern", param=param)
dim(matrix1$covmatrix)

################################################################
###
### Example 2. Spatial covariance matrix associated to
### the Generalized Wendland correlation model
###
###############################################################

# Correlation Parameters for Gen Wendland model 
CorrParam("GenWend")
# Gen Wendland Parameters 
param=list(sill=1,scale=0.2,nugget=0,smooth=0,power2=4)

matrix3 = GeoCovmatrix(coordx=coords, corrmodel="GenWend", param=param,sparse=TRUE)

# Percentage of no zero values in the tapered matrix
matrix3$nozero


################################################################
###
### Example 3. Spatial covariance matrix associated to
### the Kummer correlation model
###
###############################################################

# Correlation Parameters for kummer model 
CorrParam("Kummer")
param=list(sill=1,scale=0.2,nugget=0,smooth=0.5,power2=1)

matrix4 = GeoCovmatrix(coordx=coords, corrmodel="Kummer", param=param)

matrix4$covmatrix[1:4,1:4]


################################################################
###
### Example 4. Covariance matrix associated to
### the space-time double exponential correlation model
###
###############################################################

# Define the temporal-coordinates:
times = seq(1, 4, 1)

# Define covariance parameters
param=list(scale_s=0.3,scale_t=0.5,sill=1)

# Correlation Parameters for double exp model
CorrParam("Exp_Exp")

# Simulation of a spatial Gaussian random field:
matrix5 = GeoCovmatrix(coordx=coords, coordt=times, corrmodel="Exp_Exp",
                     param=param)

dim(matrix5$covmatrix)

################################################################
###
### Example 5. Covariance matrix associated to
### a  skew gaussian RF with Exp correlation model
###
###############################################################

param=list(sill=1,scale=0.3/3,nugget=0,skew=4)
# Simulation of a spatial Gaussian random field:
matrix6 = GeoCovmatrix(coordx=coords,  corrmodel="Exp", param=param, 
                     model="SkewGaussian")

# covariance matrix
matrix6$covmatrix[1:10,1:10]

################################################################
###
### Example 6. Covariance matrix associated to
### a  Weibull RF with Genwend correlation model
###
###############################################################

param=list(scale=0.3,nugget=0,shape=4,mean=0,smooth=1,power2=5)
# Simulation of a spatial Gaussian random field:
matrix7 = GeoCovmatrix(coordx=coords,  corrmodel="GenWend", param=param, 
                     sparse=TRUE,model="Weibull")

# covariance matrix
matrix7$nozero

################################################################
###
### Example 7. Covariance matrix associated to
### a  binomial gaussian RF with Wendland correlation model
###
###############################################################

param=list(scale=0.2,nugget=0,power2=4)
# Simulation of a spatial Gaussian random field:
matrix8 = GeoCovmatrix(coordx=coords,  corrmodel="Wend0", param=param,n=5, 
                     model="Binomial")

# covariance matrix
matrix8$covmatrix[1:10,1:10]

################################################################
###
### Example 8.  Covariance matrix associated to
### a bivariate Matern exponential correlation model
###
###############################################################

set.seed(8)
# Define the spatial-coordinates of the points:
x = runif(10, -1, 1)
y = runif(10, -1, 1)
coords = cbind(x,y)

# Parameters 
param=list(scale=0.3,mean_1=0,mean_2=0,sill_1=1,sill_2=1,
             nugget_1=0,nugget_2=0,smooth=0.5,pcol=-0.25)

# Covariance matrix 
matrix9 = GeoCovmatrix(coordx=coords, corrmodel="Bi_matern_sep", param=param)$covmatrix

head(matrix9)

</code></pre>

<hr>
<h2 id='GeoCV'>n-fold  kriging Cross-validation</h2><span id='topic+GeoCV'></span>

<h3>Description</h3>

<p>The procedure use the <code><a href="#topic+GeoKrig">GeoKrig</a></code> or <code><a href="#topic+GeoKrigloc">GeoKrigloc</a></code> function to compute n-fold  kriging cross-validation using informations from a <code><a href="#topic+GeoFit">GeoFit</a></code> object.  The function returns some prediction scores.</p>


<h3>Usage</h3>

<pre><code class='language-R'>GeoCV(fit, K=100, estimation=FALSE, optimizer="Nelder-Mead",
     lower=NULL, upper=NULL, n.fold=0.05,local=FALSE,
    neighb=NULL, maxdist=NULL,maxtime=NULL,sparse=FALSE,
    type_krig="Simple", which=1)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GeoCV_+3A_fit">fit</code></td>
<td>
<p>An object of class
<code><a href="#topic+GeoFit">GeoFit</a></code>.</p>
</td></tr>
<tr><td><code id="GeoCV_+3A_k">K</code></td>
<td>
<p>The number of iterations in cross-validation.</p>
</td></tr>
<tr><td><code id="GeoCV_+3A_estimation">estimation</code></td>
<td>
<p>Logical; if <code>TRUE</code> then  an estimation is performed at each iteration and the estimates are used in the prediction. 
Otherwise the estimates in the object fit are used.</p>
</td></tr>
<tr><td><code id="GeoCV_+3A_optimizer">optimizer</code></td>
<td>
<p>The type of optimization algorithm if estimation is  <code>TRUE</code>. See  <code><a href="#topic+GeoFit">GeoFit</a></code> for details.</p>
</td></tr>
<tr><td><code id="GeoCV_+3A_lower">lower</code></td>
<td>
<p>An optional named list giving the values  for the lower bound of the space parameter
when the optimizer is  <code>L-BFGS-B</code> or <code>nlminb</code>  or <code>optimize</code> if estimation is  <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="GeoCV_+3A_upper">upper</code></td>
<td>
<p>An optional named list giving the values  for the upper bound of the space parameter
when the optimizer is  <code>L-BFGS-B</code> or <code>nlminb</code>  or <code>optimize</code> if estimation is  <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="GeoCV_+3A_n.fold">n.fold</code></td>
<td>
<p>Numeric; the percentage of data to be deleted (and predicted) in the cross-validation procedure.</p>
</td></tr>
<tr><td><code id="GeoCV_+3A_local">local</code></td>
<td>
<p>Logical; If local is TRUE, then local kriging is performed. The default is FALSE.</p>
</td></tr>
<tr><td><code id="GeoCV_+3A_neighb">neighb</code></td>
<td>
<p>Numeric; an optional positive integer indicating the 
order of neighborhood if local kriging is performed.</p>
</td></tr>
<tr><td><code id="GeoCV_+3A_maxdist">maxdist</code></td>
<td>
<p>Numeric; an optional positive value indicating the distance in the spatial neighborhood
if local kriging is performed.</p>
</td></tr>
<tr><td><code id="GeoCV_+3A_maxtime">maxtime</code></td>
<td>
<p>Numeric; an optional positive value indicating the distance in the temporal neighborhood
if local kriging is performed.</p>
</td></tr>
<tr><td><code id="GeoCV_+3A_sparse">sparse</code></td>
<td>
<p>Logical; if <code>TRUE</code> kriging and simulation are computed with sparse matrices algorithms 
using spam package. Default is FALSE. It should be used with compactly supported covariances.</p>
</td></tr> 
<tr><td><code id="GeoCV_+3A_type_krig">type_krig</code></td>
<td>
<p>String; the type of kriging. If <code>Simple</code> (the
default) then simple kriging is performed. If <code>Optim</code> then optimal kriging is performed for some non-Gaussian RFs</p>
</td></tr>
<tr><td><code id="GeoCV_+3A_which">which</code></td>
<td>
<p>Numeric; In the case of bivariate  cokriging it indicates which variable to predict.
It can be 1 or 2</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an object  containing the following informations:
</p>
<table>
<tr><td><code>predicted</code></td>
<td>
<p>A list  of  the predicted values   in the CV procedure;</p>
</td></tr>
<tr><td><code>data_to_pred</code></td>
<td>
<p>A list  of  the data to predict  in the CV procedure;</p>
</td></tr>
<tr><td><code>mae</code></td>
<td>
<p>The vector of mean  absolute error in the CV procedure;</p>
</td></tr>
<tr><td><code>rmse</code></td>
<td>
<p>The vector of root mean  squared error in the CV procedure;</p>
</td></tr>
<tr><td><code>lscore</code></td>
<td>
<p>The vector of log-score in the CV procedure;</p>
</td></tr>
<tr><td><code>crps</code></td>
<td>
<p>The vector of continuous ranked probability score  in the CV procedure;</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Moreno Bevilacqua, <a href="mailto:moreno.bevilacqua89@gmail.com">moreno.bevilacqua89@gmail.com</a>,<a href="https://sites.google.com/view/moreno-bevilacqua/home">https://sites.google.com/view/moreno-bevilacqua/home</a>,
Víctor Morales Oñate, <a href="mailto:victor.morales@uv.cl">victor.morales@uv.cl</a>, <a href="https://sites.google.com/site/moralesonatevictor/">https://sites.google.com/site/moralesonatevictor/</a>,
Christian&quot;, Caamaño-Carrillo, <a href="mailto:chcaaman@ubiobio.cl">chcaaman@ubiobio.cl</a>,<a href="https://www.researchgate.net/profile/Christian-Caamano">https://www.researchgate.net/profile/Christian-Caamano</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+GeoKrig">GeoKrig</a></code>.</p>

<hr>
<h2 id='GeoFit'>Max-Likelihood-Based Fitting of Gaussian and non Gaussian random fieldss.</h2><span id='topic+GeoFit'></span><span id='topic+print.GeoFit'></span>

<h3>Description</h3>

<p>Maximum weighted composite-likelihood fitting for Gaussian  and some Non-Gaussian  
univariate spatial, spatio-temporal and bivariate spatial random fieldss
The function allows to fix any of the parameters and setting upper/lower bound in the optimization.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GeoFit(data, coordx, coordy=NULL, coordt=NULL, coordx_dyn=NULL,copula=NULL,
      corrmodel=NULL,distance="Eucl",fixed=NULL,anisopars=NULL,
      est.aniso=c(FALSE,FALSE),GPU=NULL, grid=FALSE, likelihood='Marginal',
     local=c(1,1),  lower=NULL,maxdist=Inf,neighb=NULL,
      maxtime=Inf, memdist=TRUE,method="cholesky", 
      model='Gaussian',n=1, onlyvar=FALSE ,
      optimizer='Nelder-Mead', parallel=FALSE, 
      radius=6371,  sensitivity=FALSE,sparse=FALSE, 
      start=NULL, taper=NULL, tapsep=NULL, 
      type='Pairwise', upper=NULL, varest=FALSE, 
      vartype='SubSamp', weighted=FALSE, winconst=NULL, winstp=NULL, 
      winconst_t=NULL, winstp_t=NULL,X=NULL,nosym=FALSE,spobj=NULL,spdata=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GeoFit_+3A_data">data</code></td>
<td>
<p>A <code class="reqn">d</code>-dimensional vector (a single spatial realisation)  or a (<code class="reqn">d \times d</code>)-matrix (a single spatial realisation on regular grid)
or a
(<code class="reqn">t \times d</code>)-matrix (a single spatial-temporal realisation)   or an (<code class="reqn">d \times d \times t \times n </code>)-array
(a single spatial-temporal realisation on regular grid).
For the description see the Section <b>Details</b>.</p>
</td></tr>
<tr><td><code id="GeoFit_+3A_coordx">coordx</code></td>
<td>
<p>A numeric (<code class="reqn">d \times 2</code>)-matrix (where
<code>d</code> is the number of spatial sites) assigning 2-dimensions of spatial coordinates or a numeric <code class="reqn">d</code>-dimensional vector assigning
1-dimension of spatial coordinates.  Coordinates on a sphere for a  fixed radius <code>radius</code> 
are passed in lon/lat format expressed in decimal degrees.</p>
</td></tr>
<tr><td><code id="GeoFit_+3A_coordy">coordy</code></td>
<td>
<p>A numeric vector assigning 1-dimension of
spatial coordinates; <code>coordy</code> is interpreted only if <code>coordx</code> is a numeric
vector or <code>grid=TRUE</code> otherwise it will be ignored. Optional argument, the default is <code>NULL</code> then <code>coordx</code> is expected to
be numeric a (<code class="reqn">d \times 2</code>)-matrix.</p>
</td></tr>
<tr><td><code id="GeoFit_+3A_coordt">coordt</code></td>
<td>
<p>A numeric vector assigning 1-dimension of
temporal coordinates.  Optional argument, the default is <code>NULL</code>
then a spatial random fields is expected.</p>
</td></tr>
<tr><td><code id="GeoFit_+3A_coordx_dyn">coordx_dyn</code></td>
<td>
<p>A list of <code class="reqn">m</code> numeric (<code class="reqn">d_t \times 2</code>)-matrices
containing dynamical (in time) spatial coordinates. Optional argument, the default is <code>NULL</code></p>
</td></tr>
<tr><td><code id="GeoFit_+3A_copula">copula</code></td>
<td>
<p>String; the type of copula. It can be &quot;Clayton&quot; or &quot;Gaussian&quot;</p>
</td></tr>
<tr><td><code id="GeoFit_+3A_corrmodel">corrmodel</code></td>
<td>
<p>String; the name of a correlation model, for the
description see the Section <b>Details</b>.</p>
</td></tr>
<tr><td><code id="GeoFit_+3A_distance">distance</code></td>
<td>
<p>String; the name of the spatial distance. The default is <code>Eucl</code>, the euclidean distance.
See the Section <b>Details</b>.</p>
</td></tr>
<tr><td><code id="GeoFit_+3A_fixed">fixed</code></td>
<td>
<p>An optional named list giving the values of the parameters that
will be considered as known values. The listed parameters for a
given correlation function will be not estimated.</p>
</td></tr>
<tr><td><code id="GeoFit_+3A_anisopars">anisopars</code></td>
<td>
<p> A list of two elements: &quot;angle&quot; and &quot;ratio&quot; i.e. the anisotropy angle and the anisotropy ratio, respectively.</p>
</td></tr>
<tr><td><code id="GeoFit_+3A_est.aniso">est.aniso</code></td>
<td>
<p> A bivariate logical vector  providing which  anisotropic parameters must be estimated.</p>
</td></tr>
<tr><td><code id="GeoFit_+3A_gpu">GPU</code></td>
<td>
<p>Numeric; if <code>NULL</code> (the default) 
no OpenCL computation is performed. The user can choose the device to be used. Use <code>DeviceInfo()</code> function to see available devices, only double precision devices are allowed</p>
</td></tr> 
<tr><td><code id="GeoFit_+3A_grid">grid</code></td>
<td>
<p>Logical; if <code>FALSE</code> (the default) the data
are interpreted as spatial or spatial-temporal realisations on a set
of non-equispaced spatial sites (irregular grid).</p>
</td></tr>
<tr><td><code id="GeoFit_+3A_likelihood">likelihood</code></td>
<td>
<p>String; the configuration of the composite
likelihood. <code>Marginal</code> is the default, see the Section <b>Details</b>.</p>
</td></tr>
<tr><td><code id="GeoFit_+3A_local">local</code></td>
<td>
<p>Numeric; number of local work-items of the OpenCL setup</p>
</td></tr>
<tr><td><code id="GeoFit_+3A_lower">lower</code></td>
<td>
<p>An optional named list giving the values  for the lower bound of the space parameter
when the optimizer is  <code>L-BFGS-B</code> or <code>nlminb</code>  or <code>optimize</code>. The 
names of the list must be the same of the names in the   <code>start</code> list.</p>
</td></tr>
<tr><td><code id="GeoFit_+3A_maxdist">maxdist</code></td>
<td>
<p>Numeric; an optional positive value indicating the maximum
spatial distance considered in the composite or tapered likelihood
computation. See the Section <b>Details</b> for more information.</p>
</td></tr>
<tr><td><code id="GeoFit_+3A_neighb">neighb</code></td>
<td>
<p>Numeric; an optional positive integer indicating the 
order of neighborhood  in the composite likelihood
computation. See the Section <b>Details</b> for more information.</p>
</td></tr>
<tr><td><code id="GeoFit_+3A_maxtime">maxtime</code></td>
<td>
<p>Numeric; an optional positive integer indicating the 
order of temporal neighborhood  in the composite likelihood
computation.</p>
</td></tr>
<tr><td><code id="GeoFit_+3A_memdist">memdist</code></td>
<td>
<p> Logical; if <code>TRUE</code> then  all  the distances  useful in the  composite likelihood 
estimation are computed before  the optimization. <code>FALSE</code> is deprecated. </p>
</td></tr>
<tr><td><code id="GeoFit_+3A_method">method</code></td>
<td>
<p>String; the type of matrix decomposition used in the simulation. Default is cholesky.
The other possible choices is <code>svd</code>.</p>
</td></tr>   
<tr><td><code id="GeoFit_+3A_model">model</code></td>
<td>
<p>String; the type of random fields and therefore the densities associated to the likelihood
objects. <code>Gaussian</code> is the default, see the Section
<b>Details</b>.</p>
</td></tr>
<tr><td><code id="GeoFit_+3A_n">n</code></td>
<td>
<p>Numeric; number of trials in a binomial random fields; number of successes in a negative binomial random fields </p>
</td></tr>  
<tr><td><code id="GeoFit_+3A_onlyvar">onlyvar</code></td>
<td>
<p>Logical; if <code>TRUE</code>  (and varest is  <code>TRUE</code>) only the variance covariance matrix is computed
without optimizing. <code>FALSE</code> is the default.</p>
</td></tr>
<tr><td><code id="GeoFit_+3A_optimizer">optimizer</code></td>
<td>
<p>String; the optimization algorithm
(see <code><a href="stats.html#topic+optim">optim</a></code> for details). <code>Nelder-Mead</code> is the
default. Other possible choices are <code>nlm</code>, <code>BFGS</code>, <code>SANN</code>, <code>L-BFGS-B</code> and <code>nlminb</code>. 
In these last two cases upper and lower bounds can be passed by the user. In the case
of one-dimensional optimization, the function <code>optimize</code> is used.</p>
</td></tr>  
<tr><td><code id="GeoFit_+3A_parallel">parallel</code></td>
<td>
<p>Logical; if <code>TRUE</code> optmization is performed using optimParallel using the maximum number of cores,  when optimizer is  <code>L-BFGS-B</code>.<code>FALSE</code> is the default.</p>
</td></tr>  
<tr><td><code id="GeoFit_+3A_radius">radius</code></td>
<td>
<p>Numeric; the radius of the sphere in the case of lon-lat coordinates.
The default is 6371, the radius of the earth.</p>
</td></tr>
<tr><td><code id="GeoFit_+3A_sensitivity">sensitivity</code></td>
<td>
<p>Logical; if <code>TRUE</code> then  the sensitivy  matrix is computed</p>
</td></tr>
<tr><td><code id="GeoFit_+3A_sparse">sparse</code></td>
<td>
<p>Logical; if <code>TRUE</code> then  maximum likelihood is computed
using sparse matrices algorithms (spam packake).It should be used
with compactly supported covariance models.<code>FALSE</code> is the default.</p>
</td></tr>
<tr><td><code id="GeoFit_+3A_start">start</code></td>
<td>
<p>An optional named list with the initial values of the
parameters that are used by the numerical routines in maximization
procedure. <code>NULL</code> is the default (see <b>Details</b>).</p>
</td></tr>
<tr><td><code id="GeoFit_+3A_taper">taper</code></td>
<td>
<p>String; the name of the type of covariance matrix.
It can be <code>Standard</code> (the default value) or
<code>Tapering</code> for taperd covariance matrix.</p>
</td></tr>
<tr><td><code id="GeoFit_+3A_tapsep">tapsep</code></td>
<td>
<p>Numeric; an optional  value indicating the separabe parameter in the 
space time adaptive taper (see <b>Details</b>).</p>
</td></tr>
<tr><td><code id="GeoFit_+3A_type">type</code></td>
<td>
<p>String; the type of the likelihood objects. If <code>Pairwise</code> (the
default) then the marginal composite likelihood is formed by
pairwise marginal likelihoods (see <b>Details</b>).</p>
</td></tr>
<tr><td><code id="GeoFit_+3A_upper">upper</code></td>
<td>
<p>An optional named list giving the values  for the upper bound 
of the space parameter when the optimizer is or <code>L-BFGS-B</code> or  <code>nlminb</code> or <code>optimize</code>. 
The names of the list must be the same of the names in the   <code>start</code> list.</p>
</td></tr>  
<tr><td><code id="GeoFit_+3A_varest">varest</code></td>
<td>
<p>Logical; if <code>TRUE</code> the estimates' variances and
standard errors are returned. For composite likelihood estimation it is deprecated.
Use sensitivity TRUE and update the object using the function <code>GeoVarestbootstrap</code>
<code>FALSE</code> is the default.</p>
</td></tr>
<tr><td><code id="GeoFit_+3A_vartype">vartype</code></td>
<td>
<p>String; (<code>SubSamp</code> the default) the type of
method used for computing
the estimates' variances, see the Section <b>Details</b>.</p>
</td></tr>
<tr><td><code id="GeoFit_+3A_weighted">weighted</code></td>
<td>
<p>Logical; if <code>TRUE</code> the likelihood objects are
weighted, see the Section <b>Details</b>. If <code>FALSE</code> (the
default) the composite likelihood is not weighted.</p>
</td></tr>
<tr><td><code id="GeoFit_+3A_winconst">winconst</code></td>
<td>
<p>Numeric; a bivariate positive vector for computing the spatial  sub-window
in the sub-sampling procedure. See <b>Details</b> for more information.</p>
</td></tr>
<tr><td><code id="GeoFit_+3A_winstp">winstp</code></td>
<td>
<p>Numeric; a value in <code class="reqn">(0,1]</code> for defining the the proportion of 
overlapping in the spatial  sub-sampling procedure. The case <code class="reqn">1</code> 
correspond to no overlapping. See <b>Details</b> for more information.</p>
</td></tr>
<tr><td><code id="GeoFit_+3A_winconst_t">winconst_t</code></td>
<td>
<p>Numeric; a positive value for computing the temporal sub-window
in the sub-sampling procedure. See <b>Details</b> for more information.</p>
</td></tr>
<tr><td><code id="GeoFit_+3A_winstp_t">winstp_t</code></td>
<td>
<p>Numeric; a value in <code class="reqn">(0,1]</code> for defining the the proportion of 
overlapping in the temporal  sub-sampling procedure. The case <code class="reqn">1</code> 
correspond to no overlapping. See <b>Details</b> for more information.</p>
</td></tr>
<tr><td><code id="GeoFit_+3A_x">X</code></td>
<td>
<p>Numeric; Matrix of spatio(temporal)covariates in the linear mean specification.</p>
</td></tr>
<tr><td><code id="GeoFit_+3A_nosym">nosym</code></td>
<td>
<p>Logical; if TRUE simmetric weights are not considered. This allows a faster but less efficient CL estimation. </p>
</td></tr>
<tr><td><code id="GeoFit_+3A_spobj">spobj</code></td>
<td>
<p>An object of class sp or spacetime</p>
</td></tr>
<tr><td><code id="GeoFit_+3A_spdata">spdata</code></td>
<td>
<p>Character:The name of data in the sp or spacetime object</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>GeoFit</code> provides  weighted composite likelihood  estimation based on pairs and independence composite likelihood estimation
for Gaussian and non Gaussian  random fields. Specifically, marginal and conditional  pairwise 
likelihood are considered for each type of random field (Gaussian and not Gaussian).
The optimization method is specified using <code>optimizer</code>. The default method is <code>Nelder-mead</code> and other available methods are <code>ucminf</code>, <code>nlm</code>, <code>BFGS</code>, <code>SANN</code>, <code>L-BFGS-B</code>,
and  <code>nlminb</code>. In the last two cases upper and lower bounds constraints in the optimization can be specified using <code>lower</code> and <code>upper</code> parameters.
</p>
<p>Depending on the dimension of <code>data</code> and on  the name of the correlation model, 
the observations   are assumed as a realization of
a spatial, spatio-temporal or bivariate random field.
Specifically, with <code>data</code>, <code>coordx</code>, <code>coordy</code>, <code>coordt</code> parameters:
</p>

<ul>
<li><p> If <code>data</code> is a numeric <code class="reqn">d</code>-dimensional vector, <code>coordx</code> and <code>coordy</code> are two
numeric <code class="reqn">d</code>-dimensional vectors (or <code>coordx</code> is (<code class="reqn">d \times 2</code>)-matrix and <code>coordy=NULL</code>), then the data are interpreted as a single spatial
realisation observed on <code class="reqn">d</code> spatial sites;
</p>
</li>
<li><p> If <code>data</code> is a numeric (<code class="reqn">t \times d</code>)-matrix, <code>coordx</code> and <code>coordy</code> are two
numeric <code class="reqn">d</code>-dimensional vectors (or <code>coordx</code> is (<code class="reqn">d \times 2</code>)-matrix and <code>coordy=NULL</code>),
<code>coordt</code> is a numeric <code class="reqn">t</code>-dimensional vector, then the data
are interpreted as a single spatial-temporal realisation of a random fields observed on <code>d</code> spatial sites and for <code>t</code> times.
</p>
</li>
<li><p> If <code>data</code> is a numeric (<code class="reqn">2 \times d</code>)-matrix, <code>coordx</code> and <code>coordy</code> are two
numeric <code class="reqn">d</code>-dimensional vectors (or <code>coordx</code> is (<code class="reqn">d \times 2</code>)-matrix and <code>coordy=NULL</code>), then the data
are interpreted as a single spatial realisation of a bivariate random fields observed on <code>d</code> spatial sites. 
</p>
</li>
<li><p> If <code>data</code> is a list,  <code>coordxdyn</code>  is a list and   <code>coordt</code> is a numeric <code class="reqn">t</code>-dimensional vector, then the data
are interpreted as a single spatial-temporal realisation of a random fields observed on dynamical spatial sites (different locations sites for each temporal instants) and for <code>t</code> times.
</p>
</li></ul>

<p>Is is also possible to specify a matrix of covariates using <code>X</code>.
Specifically:
</p>

<ul>
<li><p>  In the spatial case  <code>X</code> must be a (<code class="reqn">d \times k</code>) covariates matrix associated to  <code>data</code>  a numeric <code class="reqn">d</code>-dimensional vector;
</p>
</li>
<li><p>  In the spatiotemporal case  <code>X</code> must be a (<code class="reqn">N \times k</code>) covariates matrix associated to  <code>data</code>  a numeric (<code class="reqn">t \times d</code>)-matrix, where <code class="reqn">N=t\times d</code>;
</p>
</li>
<li><p>  In the spatiotemporal case  <code>X</code> must be a (<code class="reqn">N \times k</code>) covariates matrix associated to  <code>data</code>  a numeric (<code class="reqn">t \times d</code>)-matrix, where <code class="reqn">N=2\times d</code>;
</p>
</li></ul>

<p>The <code>corrmodel</code> parameter allows to select a specific correlation
function for the random fields. (See   <code><a href="#topic+GeoCovmatrix">GeoCovmatrix</a></code> ).
</p>
<p>The <code>distance</code> parameter allows to consider differents kinds of spatial distances.
The settings alternatives are:
</p>

<ol>
<li> <p><code>Eucl</code>, the euclidean distance (default value);
</p>
</li>
<li> <p><code>Chor</code>, the chordal distance;
</p>
</li>
<li> <p><code>Geod</code>, the geodesic distance;
</p>
</li></ol>

<p>The <code>likelihood</code> parameter represents the composite-likelihood
configurations. The settings alternatives are:
</p>

<ol>
<li> <p><code>Conditional</code>, the composite-likelihood is formed by
conditionals likelihoods;
</p>
</li>
<li> <p><code>Marginal</code>, the composite-likelihood is formed by
marginals likelihoods (default value);
</p>
</li>
<li> <p><code>Full</code>, the composite-likelihood turns out to be the standard likelihood;
</p>
</li></ol>

<p>It must be coupled with the  <code>type</code> parameter that can be fixed to 
</p>

<ol>
<li> <p><code>Pairwise</code>, the composite-likelihood is based on pairs;
</p>
</li>
<li> <p><code>Independence</code>, the composite-likelihood is based on indepedence;
</p>
</li>
<li> <p><code>Standard</code>, this is the option for  the standard likelihood;
</p>
</li></ol>

<p>The possible combinations are:
</p>

<ol>
<li>  <p><code>likelihood="Marginal"</code> and <code>type="Pairwise"</code> for  maximum marginal pairwise likelihood estimation (the default setting)
</p>
</li>
<li>  <p><code>likelihood="Conditional"</code> and <code>type="Pairwise"</code> for maximum  conditional pairwise likelihood estimation
</p>
</li>
<li>  <p><code>likelihood="Marginal"</code> and <code>type="Independence"</code> for  maximum independence composite likelihood estimation
</p>
</li>
<li>  <p><code>likelihood="Full"</code> and <code>type="Standard"</code> for  maximum stardard likelihood estimation 
</p>
</li></ol>

<p>The first three combinations can be used for any model. The standard likelihood can be used only for some specific model.
</p>
<p>The <code>model</code> parameter indicates the type of random field
considered. The available options are:
</p>
<p>random fields with marginal symmetric distribution:
</p>

<ul>
<li> <p><code>Gaussian</code>, for a Gaussian random field.   
</p>
</li>
<li> <p><code>StudentT</code>, for a StudentT random field (see  Bevilacqua M., Caamaño C., Arellano Valle R.B., Morales-Oñate V., 2020).
</p>
</li>
<li> <p><code>Tukeyh</code>, for a Tukeyh random field.
</p>
</li>
<li> <p><code>Tukeyh2</code>, for a Tukeyhh random field. (see Caamaño et al., 2023)
</p>
</li>
<li> <p><code>Logistic</code>, for a Logistic random field.
</p>
</li></ul>
   
<p>random fields with positive values and  right skewed marginal distribution:
</p>

<ul>
<li> <p><code>Gamma</code> for a Gamma  random fields (see  Bevilacqua M., Caamano C.,  Gaetan, 2020)
</p>
</li>
<li> <p><code>Weibull</code> for a Weibull  random fields (see  Bevilacqua M., Caamano C.,  Gaetan, 2020)
</p>
</li>
<li> <p><code>LogGaussian</code> for a  LogGaussian  random fields (see  Bevilacqua M., Caamano C.,  Gaetan, 2020)
</p>
</li>
<li> <p><code>LogLogistic</code> for a  LogLogistic random fields. 
</p>
</li></ul>

<p>random fields with with possibly asymmetric marginal distribution:
</p>

<ul>
<li> <p><code>SkewGaussian</code> for a skew Gaussian  random field (see   Alegrıa et al. (2017)).
</p>
</li>
<li> <p><code>SinhAsinh</code> for a Sinh-arcsinh  random field  (see Blasi et. al 2022).
</p>
</li>
<li> <p><code>TwopieceGaussian</code> for a Twopiece Gaussian random field   (see Bevilacqua et. al 2022).
</p>
</li>
<li> <p><code>TwopieceTukeyh</code> for a Twopiece Tukeyh random field   (see Bevilacqua et. al 2022).
</p>
</li></ul>

<p>random fields with for directional data
</p>
   
<ul>
<li> <p><code>Wrapped</code> for a wrapped Gaussian  random field (see  Alegria A., Bevilacqua, M., Porcu, E. (2016))
</p>
</li></ul>

<p>random fields with marginal counts data
</p>
  
<ul>
<li> <p><code>Poisson</code> for a Poisson  random field (see Morales-Navarrete et. al 2021).
</p>
</li>
<li> <p><code>PoissonZIP</code> for a zero inflated Poisson  random field (see Morales-Navarrete et. al 2021).
</p>
</li>
<li> <p><code>Binomial</code> for a Binomial  random field.
</p>
</li>
<li> <p><code>BinomialNeg</code> for a negative Binomial random field.
</p>
</li>
<li> <p><code>BinomialNegZINB</code> for a zero inflated negative Binomial random field.
</p>
</li></ul>

<p>random fields using Gaussian and Clayton copula (see Bevilacqua, Alvarado  and Caamaño, 2023) with the following marginal distribution:
</p>
   
<ul>
<li> <p><code>Gaussian</code> for Gaussian random field.
</p>
</li>
<li> <p><code>Beta2</code>  for Beta   random field.
</p>
</li></ul>

<p>For  a given <code>model</code> the associated parameters are given by nuisance and correlation parameters. In order to obtain the nuisance parameters associated with a specific model use <code><a href="#topic+NuisParam">NuisParam</a></code>. 
In order to obtain the correlation parameters associated with a given correlation model use 
<code><a href="#topic+CorrParam">CorrParam</a></code>.
</p>
<p>All the nuisance and covariance parameters must be specified
by the user using  the  <code>start</code>  and  the <code>fixed</code> parameter.
Specifically:
</p>
<p>The option <code>start</code> sets the starting values  parameters in the optimization process for the parameters  to be estimated.
The option <code>fixed</code> parameter allows to fix  some of the parameters.
</p>
<p>Regression parameters in the linear specification must be specified as <code>mean,mean1,..meank</code> (see <code><a href="#topic+NuisParam">NuisParam</a></code>).
In this case a matrix of covariates with suitable dimension must be specified using   <code>X</code>. 
In the case of a single mean then <code>X</code> should not be specified and it is interpreted as a vector of ones.
It is also possible to fix a vector of spatial or spatio-temporal means (estimated with other methods for instance).
</p>
<p>Two types  of binary weights can be used in  the weighted composite likelihood estimation based on pairs,
one based on neighboords and one based on distances.
</p>
<p>In the first  case  binary weights are set to 1 or 0 depending if the pairs are neighboords of a certain order (1, 2, 3, ..) specified by the parameter (<code>neighb</code>). This weighting scheme is effecient for large-data sets since the computation of the 'useful' pairs  in based on  fast nearest neighbour 
search (Caamaño et al., 2023).
</p>
<p>In the second case, binary weights are set to 1 or 0 depending if the pairs have distance lower than  (<code>maxdist</code>).
This weighting scheme is less inefficient for large data.
The same arguments of <code>neighb</code> applies  for <code>maxtime</code> that sets
the  order (1, 2, 3, ..) of temporal neighboords in spatial-temporal field.
</p>
<p>The <code>varest=TRUE</code> parameter specifies if the standard error estimation of the estimated parameters must be computed.
For Gaussian random fieldss and standard  likelihood estimation, standard  errors  are computed as square root of the diagonal elements of the inverse of the Hessian matrix (asymptotic covariance matrix of the estimates under increasing domain).
For Gaussian and non Gaussian  random fieldss and composite  likelihood estimation, standard errors estimate are computed as square root of the diagonal elements of the
Godambe Information matrix. (asymptotic covariance matrix of the estimates under increasing domain  (see  Bevilacqua et. al. (2012) , Bevilacqua and Gaetan (2013)).
</p>
<p>For standard error estimation  of weighted composite likelihood estimation
the option <code>sensitivity=TRUE</code> must be used. Then the  resulting  object  must be updated   using the function <code>GeoVarestbootstrap</code>. This allows to perform standard error estimation (it could be computationally intensive).
</p>
<p>The option  <code>varest=TRUE</code>  is deprecated for composite likelihood estimation and the comments below should not be considered.
The <code>varest=TRUE</code> option allows std error estimation trough a sub-sampling procedure.
In the  the sub-sampling procedure,<code>winconst</code>
and <code>winstp</code> parameters represent respectively a positive constant used to
determine the sub-window size and the the step with which the
sub-window moves. 
In the spatial case (subset of <code class="reqn">R^2</code>), the domain is seen as
a rectangle <code class="reqn">B \times H</code>, therefore the size of the
sub-window side <code class="reqn">b</code> is given by <code class="reqn">b=winconst \times
  \sqrt(B)</code> (similar is of <code class="reqn">H</code>).
For a complete description see Lee and Lahiri (2002).
By default <code>winconst</code> is set <code class="reqn">B / (4 \times \sqrt(B))</code>.  The <code>winstp</code> parameter is used to determine the sub-window step. The latter is given by the
proportion of the sub-window size, so that when <code>winstp=1</code> there
is not overlapping between contiguous sub-windows.
In the spatial case by default <code>winstp=0.5</code>.
The sub-window is moved
by successive steps in order to cover the entire spatial
domain.
Observations, that fall in disjoint or overlapping windows
are considered independent samples.
</p>
<p>In the spatio-temporal case  <code>winconst_t</code> represents
the lenght of the temporal sub-window. By default the size of the
sub-window is computed following the rule established in Li et al. (2007).
By default <code>winstp</code> is the time step.
</p>


<h3>Value</h3>

<p>Returns an object of class <code>GeoFit</code>.
An object of class <code>GeoFit</code> is a list containing
at most the following components:
</p>
<table>
<tr><td><code>bivariate</code></td>
<td>
<p>Logical:<code>TRUE</code> if the Gaussian random fields is bivariate, otherwise  <code>FALSE</code>;</p>
</td></tr>
<tr><td><code>clic</code></td>
<td>
<p>The composite information criterion, if the full
likelihood is considered then it coincides with the Akaike information
criterion;</p>
</td></tr>
<tr><td><code>coordx</code></td>
<td>
<p>A <code class="reqn">d</code>-dimensional vector of spatial coordinates;</p>
</td></tr>
<tr><td><code>coordy</code></td>
<td>
<p>A <code class="reqn">d</code>-dimensional vector of spatial coordinates;</p>
</td></tr>
<tr><td><code>coordt</code></td>
<td>
<p>A <code class="reqn">t</code>-dimensional vector of temporal coordinates;</p>
</td></tr>
<tr><td><code>coordx_dyn</code></td>
<td>
<p>A  list of dynamical (in time) spatial coordinates;</p>
</td></tr>
<tr><td><code>conf.int</code></td>
<td>
<p>Confidence intervals for  standard maximum likelihood estimation;</p>
</td></tr>
<tr><td><code>convergence</code></td>
<td>
<p>A string that denotes if convergence is reached;</p>
</td></tr>
<tr><td><code>copula</code></td>
<td>
<p>The type of copula;</p>
</td></tr>
<tr><td><code>corrmodel</code></td>
<td>
<p>The correlation model;</p>
</td></tr>
<tr><td><code>data</code></td>
<td>
<p>The vector or matrix or array of data;</p>
</td></tr>
<tr><td><code>distance</code></td>
<td>
<p>The type of spatial distance;</p>
</td></tr>
<tr><td><code>fixed</code></td>
<td>
<p>A list of the  fixed parameters;</p>
</td></tr>
<tr><td><code>iterations</code></td>
<td>
<p>The number of iteration used by the numerical routine;</p>
</td></tr>
<tr><td><code>likelihood</code></td>
<td>
<p>The configuration of the composite likelihood;</p>
</td></tr>
<tr><td><code>logCompLik</code></td>
<td>
<p>The value of the log composite-likelihood at the maximum;</p>
</td></tr>
<tr><td><code>maxdist</code></td>
<td>
<p>The maximum spatial distance used in the weigthed composite likelihood. 
If no spatial distance is specified then it is NULL;</p>
</td></tr>
<tr><td><code>maxtime</code></td>
<td>
<p>The 
order of temporal neighborhood  in the composite likelihood
computation. </p>
</td></tr>
<tr><td><code>message</code></td>
<td>
<p>Extra message passed from the numerical routines;</p>
</td></tr>
<tr><td><code>model</code></td>
<td>
<p>The density associated to the likelihood objects;</p>
</td></tr>
<tr><td><code>missp</code></td>
<td>
<p>True if a misspecified  Gaussian model is ued in  the composite likelihhod;</p>
</td></tr>
<tr><td><code>n</code></td>
<td>
<p>The number of trials in a binominal random fields;the number of successes in a  negative Binomial random fieldss;</p>
</td></tr> 
<tr><td><code>neighb</code></td>
<td>
<p>The 
order of spatial neighborhood  in the composite likelihood
computation. </p>
</td></tr>
<tr><td><code>ns</code></td>
<td>
<p>The number of (different) location sites in the bivariate case;</p>
</td></tr> 
<tr><td><code>nozero</code></td>
<td>
<p>In the case of tapered likelihood  the percentage of non zero values in the covariance matrix.
Otherwise is NULL.</p>
</td></tr>
<tr><td><code>numcoord</code></td>
<td>
<p>The number of spatial coordinates;</p>
</td></tr>
<tr><td><code>numtime</code></td>
<td>
<p>The number of the temporal realisations of the random fields;</p>
</td></tr>
<tr><td><code>param</code></td>
<td>
<p>A list of the   parameters' estimates;</p>
</td></tr>
<tr><td><code>radius</code></td>
<td>
<p>The radius of the sphere in the case of great  circle distance;</p>
</td></tr>
<tr><td><code>stderr</code></td>
<td>
<p>The vector of standard errors for  standard maximum likelihood estimation;</p>
</td></tr>
<tr><td><code>sensmat</code></td>
<td>
<p>The sensitivity matrix;</p>
</td></tr>
<tr><td><code>varcov</code></td>
<td>
<p>The matrix of the variance-covariance of the estimates;</p>
</td></tr>
<tr><td><code>varimat</code></td>
<td>
<p>The variability matrix;</p>
</td></tr>
<tr><td><code>vartype</code></td>
<td>
<p>The method used to compute the variance of the estimates;</p>
</td></tr>
<tr><td><code>type</code></td>
<td>
<p>The type of the likelihood objects.</p>
</td></tr>
<tr><td><code>winconst</code></td>
<td>
<p>The constant used to compute the window size in the
spatial sub-sampling;</p>
</td></tr>
<tr><td><code>winstp</code></td>
<td>
<p>The step used for moving the window in the spatial sub-sampling;</p>
</td></tr>
<tr><td><code>winconst_t</code></td>
<td>
<p>The constant used to compute the window size in the
spatio-temporal sub-sampling;</p>
</td></tr>
<tr><td><code>winstp_</code></td>
<td>
<p>The step used for moving the window in the spatio-temporal sub-sampling;</p>
</td></tr>
<tr><td><code>X</code></td>
<td>
<p>The matrix of covariates;</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Moreno Bevilacqua, <a href="mailto:moreno.bevilacqua89@gmail.com">moreno.bevilacqua89@gmail.com</a>,<a href="https://sites.google.com/view/moreno-bevilacqua/home">https://sites.google.com/view/moreno-bevilacqua/home</a>,
Víctor Morales Oñate, <a href="mailto:victor.morales@uv.cl">victor.morales@uv.cl</a>, <a href="https://sites.google.com/site/moralesonatevictor/">https://sites.google.com/site/moralesonatevictor/</a>,
Christian&quot;, Caamaño-Carrillo, <a href="mailto:chcaaman@ubiobio.cl">chcaaman@ubiobio.cl</a>,<a href="https://www.researchgate.net/profile/Christian-Caamano">https://www.researchgate.net/profile/Christian-Caamano</a>
</p>


<h3>References</h3>

<p><b>General Composite-likelihood</b>:
</p>
<p>Varin, C., Reid, N. and Firth, D. (2011). An Overview of Composite
Likelihood Methods. <em>Statistica Sinica</em>, <b>21</b>, 5&ndash;42.
</p>
<p>Varin, C. and Vidoni, P. (2005)
A Note on Composite Likelihood Inference and Model Selection.
<em>Biometrika</em>, <b>92</b>, 519&ndash;528.
</p>
<p><b>Non Gaussian random fields</b>: 
</p>
<p>Alegrıa A., Caro S., Bevilacqua M., Porcu E., Clarke J. (2017) <em>Estimating covariance functions of multivariate skew-Gaussian random fields on the sphere</em>. Spatial Statistics <b>22</b> 388-402
</p>
<p>Alegria A., Bevilacqua, M., Porcu, E. (2016) 
Likelihood-based inference for multivariate space-time wrapped-Gaussian fields. 
<em>Journal of Statistical Computation and Simulation</em>. <b>86(13)</b>, 2583&ndash;2597.
</p>
<p>Bevilacqua M., Caamano C.,  Gaetan C. (2020) On modeling positive continuous data with spatio-temporal dependence.  <em>Environmetrics</em>   <b>31(7)</b>
</p>
<p>Bevilacqua M., Caamaño C., Arellano Valle R.B., Morales-Oñate V.  (2020) Non-Gaussian Geostatistical Modeling using (skew) t Processes. <em>Scandinavian Journal of Statistics</em>.
</p>
<p>Blasi F., Caamaño C., Bevilacqua M., Furrer R. (2022) A selective view of climatological data and likelihood estimation  <em>Spatial Statistics</em>   10.1016/j.spasta.2022.100596
</p>
<p>Bevilacqua M., Caamaño C., Arellano-Valle R. B., Camilo Gomez C. (2022) A class of random fields with two-piece marginal distributions for modeling point-referenced data with spatial outliers. <em>Test</em>  10.1007/s11749-021-00797-5
</p>
<p>Morales-Navarrete D., Bevilacqua M., Caamaño C., Castro  L.M. (2022) Modelling Point Referenced Spatial Count Data: A Poisson Process Approach   <em>TJournal of the American Statistical Association</em> To appear
</p>
<p>Caamaño C., Bevilacqua M., López C., Morales-Oñate V. (2023) Nearest neighbours weighted composite likelihood based on pairs for (non-)Gaussian massive spatial data with an application to Tukey-hh random fields estimation  <em>Computational Statistics and Data Analysis</em> To appear
</p>
<p>Bevilacqua M., Alvarado E., Caamaño C., (2023) A flexible Clayton-like spatial copula with application to bounded support data <em>Journal of Multivariate Analysis</em> To appear 
</p>
<p><b>Weighted Composite-likelihood for (non-)Gaussian random fields</b>:
</p>
<p>Bevilacqua, M. Gaetan, C., Mateu, J. and Porcu, E. (2012)
Estimating space and space-time covariance functions for large data
sets: a weighted composite likelihood approach.
<em>Journal of the American Statistical Association, Theory &amp;
Methods</em>, <b>107</b>, 268&ndash;280.
</p>
<p>Bevilacqua, M., Gaetan, C. (2015) Comparing composite likelihood methods based on pairs for spatial Gaussian random fields.  <em>Statistics and Computing</em>, <b>25(5)</b>,  877-892.
</p>
<p>Caamaño C., Bevilacqua M., López C., Morales-Oñate V. (2023) Nearest neighbours weighted composite likelihood based on pairs for (non-)Gaussian massive spatial data with an application to Tukey-hh random fields estimation  <em>Computational Statistics and Data Analysis</em> To appear
</p>
<p><b>Sub-sampling estimation</b>:
</p>
<p>Heagerty, P. J. and Lumley T. (2000) Window Subsampling of Estimating
Functions with Application to Regression Models.
<em>Journal of the American Statistical Association, Theory &amp;
Methods</em>, <b>95</b>, 197&ndash;211.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(GeoModels)

###############################################################
############ Examples of spatial Gaussian random fieldss ################
###############################################################


# Define the spatial-coordinates of the points:
set.seed(3)
N=300  # number of location sites
x &lt;- runif(N, 0, 1)
set.seed(6)
y &lt;- runif(N, 0, 1)
coords &lt;- cbind(x,y)

# Define spatial matrix covariates and regression parameters
X=cbind(rep(1,N),runif(N))
mean &lt;- 0.2
mean1 &lt;- -0.5

# Set the covariance model's parameters:
corrmodel &lt;- "Matern"
sill &lt;- 1
nugget &lt;- 0
scale &lt;- 0.2/3
smooth=0.5


param&lt;-list(mean=mean,mean1=mean1,sill=sill,nugget=nugget,scale=scale,smooth=smooth)

# Simulation of the spatial Gaussian random fields:
data &lt;- GeoSim(coordx=coords,corrmodel=corrmodel, param=param,X=X)$data



################################################################
###
### Example 0. Maximum independence composite likelihood fitting of
### a Gaussian random fields (no dependence parameters)
### 
###############################################################
# setting starting parameters to be estimated
start&lt;-list(mean=mean,mean1=mean1,sill=sill)

fit1 &lt;- GeoFit(data=data,coordx=coords,likelihood="Marginal",
                    type="Independence", start=start,X=X)
print(fit1)


################################################################
###
### Example 1. Maximum conditional pairwise likelihood fitting of
### a Gaussian random fields using BFGS
### 
###############################################################
# setting fixed and starting parameters to be estimated
fixed&lt;-list(nugget=nugget,smooth=smooth)
start&lt;-list(mean=mean,mean1=mean1,scale=scale,sill=sill)

fit1 &lt;- GeoFit(data=data,coordx=coords,corrmodel=corrmodel, 
                    neighb=3,likelihood="Conditional",optimizer="BFGS",
                    type="Pairwise", start=start,fixed=fixed,X=X)
print(fit1)

################################################################
###
### Example 2. Standard Maximum likelihood fitting of
### a Gaussian random fields using nlminb
###
###############################################################
# Define the spatial-coordinates of the points:
set.seed(3)
N=100  # number of location sites
x &lt;- runif(N, 0, 1)
set.seed(6)
y &lt;- runif(N, 0, 1)
coords &lt;- cbind(x,y)

param&lt;-list(mean=mean,sill=sill,nugget=nugget,scale=scale,smooth=smooth)

data &lt;- GeoSim(coordx=coords,corrmodel=corrmodel, param=param)$data

# setting fixed and parameters to be estimated
fixed&lt;-list(nugget=nugget,smooth=smooth)
start&lt;-list(mean=mean,scale=scale,sill=sill)

I=Inf
lower&lt;-list(mean=-I,scale=0,sill=0)
upper&lt;-list(mean=I,scale=I,sill=I)
fit2 &lt;- GeoFit(data=data,coordx=coords,corrmodel=corrmodel,
                    optimizer="nlminb",upper=upper,lower=lower,
                    likelihood="Full",type="Standard", 
                    start=start,fixed=fixed)
print(fit2)


###############################################################
############ Examples of spatial non-Gaussian random fieldss #############
###############################################################


################################################################
###
### Example 3. Maximum pairwise likelihood fitting of a Weibull  random fields 
### with Generalized Wendland correlation with Nelder-Mead
### 
###############################################################
set.seed(524)
# Define the spatial-coordinates of the points:
N=300
x &lt;- runif(N, 0, 1)
y &lt;- runif(N, 0, 1)
coords &lt;- cbind(x,y)
X=cbind(rep(1,N),runif(N))
mean=1; mean1=2 # regression parameters
nugget=0
shape=2
scale=0.2
smooth=0

model="Weibull"
corrmodel="GenWend"
param=list(mean=mean,mean1=mean1,scale=scale,
                     shape=shape,nugget=nugget,power2=4,smooth=smooth)
# Simulation of a  non stationary weibull random fields:
data &lt;- GeoSim(coordx=coords, corrmodel=corrmodel,model=model,X=X,
           param=param)$data


fixed&lt;-list(nugget=nugget,power2=4,smooth=smooth)
start&lt;-list(mean=mean,mean1=mean1,scale=scale,shape=shape)

# Maximum independence likelihood:
fit &lt;- GeoFit(data=data, coordx=coords, X=X, 
           likelihood="Marginal",type="Independence", corrmodel=corrmodel,
         ,model=model, start=start, fixed=fixed)
print(unlist(fit$param))

## estimating  dependence parameter fixing vector mean   parameter
Xb=as.numeric(X %*% c(mean,mean1))
fixed&lt;-list(nugget=nugget,power2=4,smooth=smooth,mean=Xb)
start&lt;-list(scale=scale,shape=shape)

# Maximum conditional composite-likelihood fitting of the random fields:
fit1 &lt;- GeoFit(data=data,coordx=coords,corrmodel=corrmodel, model=model,
                    neighb=3,likelihood="Conditional",type="Pairwise",
                    optimizer="Nelder-Mead",
                    start=start,fixed=fixed)
print(unlist(fit1$param))



### joint estimation  of the dependence parameter and  mean   parameters
fixed&lt;-list(nugget=nugget,power2=4,smooth=smooth)
start&lt;-list(mean=mean,mean1=mean1,scale=scale,shape=shape)
fit2 &lt;- GeoFit(data=data,coordx=coords,corrmodel=corrmodel, model=model,
                    neighb=3,likelihood="Conditional",type="Pairwise",X=X,
                    optimizer="Nelder-Mead",
                    start=start,fixed=fixed)
print(unlist(fit2$param))



################################################################
###
### Example 4. Maximum pairwise likelihood fitting of
### a SinhAsinh-Gaussian spatial  random fields with Wendland correlation
###
###############################################################
set.seed(261)
model="SinhAsinh"
# Define the spatial-coordinates of the points:
x &lt;- runif(500, 0, 1)
y &lt;- runif(500, 0, 1)
coords &lt;- cbind(x,y)

corrmodel="Wend0"
mean=0;nugget=0
sill=1
skew=-0.5
tail=1.5
power2=4
c_supp=0.2

# model parameters
param=list(power2=power2,skew=skew,tail=tail,
             mean=mean,sill=sill,scale=c_supp,nugget=nugget)
data &lt;- GeoSim(coordx=coords, corrmodel=corrmodel,model=model, param=param)$data

plot(density(data))
fixed=list(power2=power2,nugget=nugget)
start=list(scale=c_supp,skew=skew,tail=tail,mean=mean,sill=sill)
# Maximum marginal pairwise likelihood:
fit1 &lt;- GeoFit(data=data,coordx=coords,corrmodel=corrmodel, model=model,
                    neighb=3,likelihood="Marginal",type="Pairwise",
                    start=start,fixed=fixed)
print(unlist(fit1$param))


################################################################
###
### Example 5. Maximum pairwise likelihood fitting of 
### a Binomial random fields with exponential correlation 
###
###############################################################

set.seed(422)
N=250
x &lt;- runif(N, 0, 1)
y &lt;- runif(N, 0, 1)
coords &lt;- cbind(x,y)
mean=0.1; mean1=0.8; mean2=-0.5 # regression parameters
X=cbind(rep(1,N),runif(N),runif(N)) # marix covariates
corrmodel &lt;- "Wend0"
param=list(mean=mean,mean1=mean1,mean2=mean2,nugget=0,scale=0.2,power2=4)
# Simulation of the spatial Binomial-Gaussian random fields:
data &lt;- GeoSim(coordx=coords, corrmodel=corrmodel, model="Binomial", n=10,X=X,
             param=param)$data


## estimating the marginal parameters using independence cl
fixed &lt;- list(power2=4,scale=0.2,nugget=0)
start &lt;- list(mean=mean,mean1=mean1,mean2=mean2)

# Maximum independence likelihood:
fit &lt;- GeoFit(data=data, coordx=coords,n=10, X=X, 
           likelihood="Marginal",type="Independence",corrmodel=corrmodel,
         ,model="Binomial", start=start, fixed=fixed)
                  
print(fit)


## estimating  dependence parameter fixing vector mean   parameter
Xb=as.numeric(X %*% c(mean,mean1,mean2))
fixed &lt;- list(nugget=0,power2=4,mean=Xb)
start &lt;- list(scale=0.2)

# Maximum conditional pairwise likelihood:
fit1 &lt;- GeoFit(data=data, coordx=coords, corrmodel=corrmodel,n=10, 
          likelihood="Conditional",type="Pairwise",  neighb=3
         ,model="Binomial", start=start, fixed=fixed)
                  
print(fit1)


## estimating jointly marginal   and dependnce parameters
fixed &lt;- list(nugget=0,power2=4)
start &lt;- list(mean=mean,mean1=mean1,mean2=mean2,scale=0.2)

# Maximum conditional pairwise likelihood:
fit2 &lt;- GeoFit(data=data, coordx=coords, corrmodel=corrmodel,n=10, X=X, 
          likelihood="Conditional",type="Pairwise",  neighb=3
         ,model="Binomial", start=start, fixed=fixed)
                  
print(fit2)


###############################################################
######### Examples of Gaussian spatio-temporal random fieldss ###########
###############################################################
set.seed(52)
# Define the temporal sequence:
time &lt;- seq(1, 9, 1)

# Define the spatial-coordinates of the points:
x &lt;- runif(20, 0, 1)
set.seed(42)
y &lt;- runif(20, 0, 1)
coords=cbind(x,y)

# Set the covariance model's parameters:
scale_s=0.2/3;scale_t=1
smooth_s=0.5;smooth_t=0.5
sill=1
nugget=0
mean=0

param&lt;-list(mean=0,scale_s=scale_s,scale_t=scale_t,
 smooth_t=smooth_t, smooth_s=smooth_s ,sill=sill,nugget=nugget)

# Simulation of the spatial-temporal Gaussian random fields:
data &lt;- GeoSim(coordx=coords,coordt=time,corrmodel="Matern_Matern",
              param=param)$data

################################################################
###
### Example 6. Maximum pairwise likelihood fitting of a
### space time Gaussian random fields with double-exponential correlation
###
###############################################################
# Fixed parameters
fixed&lt;-list(nugget=nugget,smooth_s=smooth_s,smooth_t=smooth_t)
# Starting value for the estimated parameters
start&lt;-list(mean=mean,scale_s=scale_s,scale_t=scale_t,sill=sill)

# Maximum composite-likelihood fitting of the random fields:
fit &lt;- GeoFit(data=data,coordx=coords,coordt=time,
                    corrmodel="Matern_Matern",maxtime=1,neighb=3,
                    likelihood="Marginal",type="Pairwise",
                     start=start,fixed=fixed)
print(fit)



###############################################################
######### Examples of a bivariate Gaussian  random fields ###########
###############################################################

################################################################
### Example 7. Maximum pairwise  likelihood fitting of a
### bivariate Gaussian random fields with separable Bivariate  matern 
### (cross) correlation model 
###############################################################

# Define the spatial-coordinates of the points:
set.seed(89)
x &lt;- runif(300, 0, 1)
y &lt;- runif(300, 0, 1)
coords=cbind(x,y)
# parameters
param=list(mean_1=0,mean_2=0,scale=0.1,smooth=0.5,sill_1=1,sill_2=1,
           nugget_1=0,nugget_2=0,pcol=0.2)

# Simulation of a spatial bivariate Gaussian random fields:
data &lt;- GeoSim(coordx=coords, corrmodel="Bi_Matern_sep", 
              param=param)$data

# selecting fixed and estimated parameters
fixed=list(mean_1=0,mean_2=0,nugget_1=0,nugget_2=0,smooth=0.5)
start=list(sill_1=var(data[1,]),sill_2=var(data[2,]),
           scale=0.1,pcol=cor(data[1,],data[2,]))


# Maximum marginal pairwise likelihood
fitcl&lt;- GeoFit(data=data, coordx=coords, corrmodel="Bi_Matern_sep",
                     likelihood="Marginal",type="Pairwise",
                     optimizer="BFGS" , start=start,fixed=fixed,
                     neighb=c(4,4,4))
print(fitcl)

</code></pre>

<hr>
<h2 id='GeoFit2'>Max-Likelihood-Based Fitting of Gaussian and non Gaussian RFs.</h2><span id='topic+GeoFit2'></span>

<h3>Description</h3>

<p>Maximum weighted composite-likelihood fitting for Gaussian  and some Non-Gaussian  
univariate spatial, spatio-temporal and bivariate spatial RFs.
A first preliminary estimation is performed using independence composite-likelihood for the 
marginal parameters of the model. The estimates are then used as starting values in the second 
final estimation step.
The function allows to fix any of the parameters and setting upper/lower bound in the optimization.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GeoFit2(data, coordx, coordy=NULL, coordt=NULL, coordx_dyn=NULL,
  copula=NULL,corrmodel,distance="Eucl",fixed=NULL,
     anisopars=NULL,est.aniso=c(FALSE,FALSE),GPU=NULL, 
     grid=FALSE, likelihood='Marginal',
     local=c(1,1),  lower=NULL,maxdist=Inf,neighb=NULL,
      maxtime=Inf, memdist=TRUE,method="cholesky", 
      model='Gaussian',n=1, onlyvar=FALSE ,
      optimizer='Nelder-Mead', parallel=FALSE, 
      radius=6371,  sensitivity=FALSE,sparse=FALSE,
       start=NULL, taper=NULL, tapsep=NULL, 
      type='Pairwise', upper=NULL, varest=FALSE, 
      vartype='SubSamp', weighted=FALSE, winconst=NULL, winstp=NULL, 
      winconst_t=NULL, winstp_t=NULL,X=NULL,nosym=FALSE,spobj=NULL,spdata=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GeoFit2_+3A_data">data</code></td>
<td>
<p>A <code class="reqn">d</code>-dimensional vector (a single spatial realisation)  or a (<code class="reqn">d \times d</code>)-matrix (a single spatial realisation on regular grid)
or a
(<code class="reqn">t \times d</code>)-matrix (a single spatial-temporal realisation)   or an (<code class="reqn">d \times d \times t \times n </code>)-array
(a single spatial-temporal realisation on regular grid).
For the description see the Section <b>Details</b>.</p>
</td></tr>
<tr><td><code id="GeoFit2_+3A_coordx">coordx</code></td>
<td>
<p>A numeric (<code class="reqn">d \times 2</code>)-matrix (where
<code>d</code> is the number of spatial sites) assigning 2-dimensions of spatial coordinates or a numeric <code class="reqn">d</code>-dimensional vector assigning
1-dimension of spatial coordinates.  Coordinates on a sphere for a  fixed radius <code>radius</code> 
are passed in lon/lat format expressed in decimal degrees.</p>
</td></tr>
<tr><td><code id="GeoFit2_+3A_coordy">coordy</code></td>
<td>
<p>A numeric vector assigning 1-dimension of
spatial coordinates; <code>coordy</code> is interpreted only if <code>coordx</code> is a numeric
vector or <code>grid=TRUE</code> otherwise it will be ignored. Optional argument, the default is <code>NULL</code> then <code>coordx</code> is expected to
be numeric a (<code class="reqn">d \times 2</code>)-matrix.</p>
</td></tr>
<tr><td><code id="GeoFit2_+3A_coordt">coordt</code></td>
<td>
<p>A numeric vector assigning 1-dimension of
temporal coordinates.  Optional argument, the default is <code>NULL</code>
then a spatial RF is expected.</p>
</td></tr>
<tr><td><code id="GeoFit2_+3A_coordx_dyn">coordx_dyn</code></td>
<td>
<p>A list of <code class="reqn">m</code> numeric (<code class="reqn">d_t \times 2</code>)-matrices
containing dynamical (in time) spatial coordinates. Optional argument, the default is <code>NULL</code></p>
</td></tr>
<tr><td><code id="GeoFit2_+3A_copula">copula</code></td>
<td>
<p>String; the type of copula. It can be &quot;Clayton&quot; or &quot;Gaussian&quot;</p>
</td></tr>
<tr><td><code id="GeoFit2_+3A_corrmodel">corrmodel</code></td>
<td>
<p>String; the name of a correlation model, for the
description see the Section <b>Details</b>.</p>
</td></tr>
<tr><td><code id="GeoFit2_+3A_distance">distance</code></td>
<td>
<p>String; the name of the spatial distance. The default is <code>Eucl</code>, the euclidean distance.
See the Section <b>Details</b>.</p>
</td></tr>
<tr><td><code id="GeoFit2_+3A_fixed">fixed</code></td>
<td>
<p>An optional named list giving the values of the parameters that
will be considered as known values. The listed parameters for a
given correlation function will be not estimated.</p>
</td></tr>
<tr><td><code id="GeoFit2_+3A_anisopars">anisopars</code></td>
<td>
<p> A list of two elements: &quot;angle&quot; and &quot;ratio&quot; i.e. the anisotropy angle and the anisotropy ratio, respectively.</p>
</td></tr>
<tr><td><code id="GeoFit2_+3A_est.aniso">est.aniso</code></td>
<td>
<p> A bivariate logical vector  providing which anisotropic parameters must be estimated.</p>
</td></tr>
<tr><td><code id="GeoFit2_+3A_gpu">GPU</code></td>
<td>
<p>Numeric; if <code>NULL</code> (the default) 
no OpenCL computation is performed. The user can choose the device to be used. Use <code>DeviceInfo()</code> function to see available devices, only double precision devices are allowed</p>
</td></tr> 
<tr><td><code id="GeoFit2_+3A_grid">grid</code></td>
<td>
<p>Logical; if <code>FALSE</code> (the default) the data
are interpreted as spatial or spatial-temporal realisations on a set
of non-equispaced spatial sites (irregular grid).</p>
</td></tr>
<tr><td><code id="GeoFit2_+3A_likelihood">likelihood</code></td>
<td>
<p>String; the configuration of the composite
likelihood. <code>Marginal</code> is the default, see the Section <b>Details</b>.</p>
</td></tr>
<tr><td><code id="GeoFit2_+3A_local">local</code></td>
<td>
<p>Numeric; number of local work-items of the OpenCL setup</p>
</td></tr>
<tr><td><code id="GeoFit2_+3A_lower">lower</code></td>
<td>
<p>An optional named list giving the values  for the lower bound of the space parameter
when the optimizer is  <code>L-BFGS-B</code> or <code>nlminb</code>   or <code>optimize</code>. The 
names of the list must be the same of the names in the   <code>start</code> list.</p>
</td></tr>
<tr><td><code id="GeoFit2_+3A_maxdist">maxdist</code></td>
<td>
<p>Numeric; an optional positive value indicating the maximum
spatial distance considered in the composite or tapered likelihood
computation. See the Section <b>Details</b> for more information.</p>
</td></tr>
<tr><td><code id="GeoFit2_+3A_neighb">neighb</code></td>
<td>
<p>Numeric; an optional positive integer indicating the 
order of neighborhood  in the composite likelihood
computation. See the Section <b>Details</b> for more information.</p>
</td></tr>
<tr><td><code id="GeoFit2_+3A_maxtime">maxtime</code></td>
<td>
<p>Numeric; an optional positive integer indicating the 
order of temporal neighborhood  in the composite likelihood
computation.</p>
</td></tr>
<tr><td><code id="GeoFit2_+3A_memdist">memdist</code></td>
<td>
<p> Logical; if <code>TRUE</code> then  all  the distances  useful in the  composite likelihood 
estimation are computed before  the optimization. <code>FALSE</code> is deprecated. </p>
</td></tr>
<tr><td><code id="GeoFit2_+3A_method">method</code></td>
<td>
<p>String; the type of matrix decomposition used in the simulation. Default is cholesky.
The other possible choices is <code>svd</code>.</p>
</td></tr>   
<tr><td><code id="GeoFit2_+3A_model">model</code></td>
<td>
<p>String; the type of RF and therefore the densities associated to the likelihood
objects. <code>Gaussian</code> is the default, see the Section
<b>Details</b>.</p>
</td></tr>
<tr><td><code id="GeoFit2_+3A_n">n</code></td>
<td>
<p>Numeric; number of trials in a binomial RF; number of successes in a negative binomial RF </p>
</td></tr>  
<tr><td><code id="GeoFit2_+3A_onlyvar">onlyvar</code></td>
<td>
<p>Logical; if <code>TRUE</code>  (and varest is  <code>TRUE</code>) only the variance covariance matrix is computed
without optimizing. <code>FALSE</code> is the default.</p>
</td></tr>
<tr><td><code id="GeoFit2_+3A_optimizer">optimizer</code></td>
<td>
<p>String; the optimization algorithm
(see <code><a href="stats.html#topic+optim">optim</a></code> for details). <code>Nelder-Mead</code> is the
default. Other possible choices are <code>nlm</code>, <code>BFGS</code>, <code>SANN</code>,  <code>L-BFGS-B</code> and <code>nlminb</code>. 
In these last two cases upper and lower bounds can be passed by the user. In the case
of one-dimensional optimization, the function <code>optimize</code> is used.  </p>
</td></tr>  
<tr><td><code id="GeoFit2_+3A_parallel">parallel</code></td>
<td>
<p>Logical; if <code>TRUE</code> optmization is performed using optimParallel using the maximum number of cores,  when optimizer is  <code>L-BFGS-B</code>.<code>FALSE</code> is the default.</p>
</td></tr>  
<tr><td><code id="GeoFit2_+3A_radius">radius</code></td>
<td>
<p>Numeric; the radius of the sphere in the case of lon-lat coordinates.
The default is 6371, the radius of the earth.</p>
</td></tr>
<tr><td><code id="GeoFit2_+3A_sensitivity">sensitivity</code></td>
<td>
<p>Logical; if <code>TRUE</code> then  the sensitivy  matrix is computed</p>
</td></tr>
<tr><td><code id="GeoFit2_+3A_sparse">sparse</code></td>
<td>
<p>Logical; if <code>TRUE</code> then  maximum likelihood is computed
using sparse matrices algorithms (spam packake).It should be used
with compactly supported covariance models.<code>FALSE</code> is the default.</p>
</td></tr>
<tr><td><code id="GeoFit2_+3A_start">start</code></td>
<td>
<p>An optional named list with the initial values of the
parameters that are used by the numerical routines in maximization
procedure. <code>NULL</code> is the default (see <b>Details</b>).</p>
</td></tr>
<tr><td><code id="GeoFit2_+3A_taper">taper</code></td>
<td>
<p>String; the name of the type of covariance matrix.
It can be <code>Standard</code> (the default value) or
<code>Tapering</code> for taperd covariance matrix.</p>
</td></tr>
<tr><td><code id="GeoFit2_+3A_tapsep">tapsep</code></td>
<td>
<p>Numeric; an optional  value indicating the separabe parameter in the 
space time adaptive taper (see <b>Details</b>).</p>
</td></tr>
<tr><td><code id="GeoFit2_+3A_type">type</code></td>
<td>
<p>String; the type of the likelihood objects. If <code>Pairwise</code> (the
default) then the marginal composite likelihood is formed by
pairwise marginal likelihoods (see <b>Details</b>).</p>
</td></tr>
<tr><td><code id="GeoFit2_+3A_upper">upper</code></td>
<td>
<p>An optional named list giving the values  for the upper bound 
of the space parameter when the optimizer is or <code>L-BFGS-B</code> or  <code>nlminb</code> or <code>optimize</code>. 
The names of the list must be the same of the names in the   <code>start</code> list.</p>
</td></tr>  
<tr><td><code id="GeoFit2_+3A_varest">varest</code></td>
<td>
<p>Logical; if <code>TRUE</code> the estimates' variances and
standard errors are returned. For composite likelihood estimation it is deprecated.
Use sensitivity TRUE and update the object using the function <code>GeoVarestbootstrap</code>
<code>FALSE</code> is the default.</p>
</td></tr>
<tr><td><code id="GeoFit2_+3A_vartype">vartype</code></td>
<td>
<p>String; (<code>SubSamp</code> the default) the type of
method used for computing
the estimates' variances, see the Section <b>Details</b>.</p>
</td></tr>
<tr><td><code id="GeoFit2_+3A_weighted">weighted</code></td>
<td>
<p>Logical; if <code>TRUE</code> the likelihood objects are
weighted, see the Section <b>Details</b>. If <code>FALSE</code> (the
default) the composite likelihood is not weighted.</p>
</td></tr>
<tr><td><code id="GeoFit2_+3A_winconst">winconst</code></td>
<td>
<p>Numeric; a bivariate positive vector for computing the spatial  sub-window
in the sub-sampling procedure. See <b>Details</b> for more information.</p>
</td></tr>
<tr><td><code id="GeoFit2_+3A_winstp">winstp</code></td>
<td>
<p>Numeric; a value in <code class="reqn">(0,1]</code> for defining the the proportion of 
overlapping in the spatial  sub-sampling procedure. The case <code class="reqn">1</code> 
correspond to no overlapping. See <b>Details</b> for more information.</p>
</td></tr>
<tr><td><code id="GeoFit2_+3A_winconst_t">winconst_t</code></td>
<td>
<p>Numeric; a positive value for computing the temporal sub-window
in the sub-sampling procedure. See <b>Details</b> for more information.</p>
</td></tr>
<tr><td><code id="GeoFit2_+3A_winstp_t">winstp_t</code></td>
<td>
<p>Numeric; a value in <code class="reqn">(0,1]</code> for defining the the proportion of 
overlapping in the temporal  sub-sampling procedure. The case <code class="reqn">1</code> 
correspond to no overlapping. See <b>Details</b> for more information.</p>
</td></tr>
<tr><td><code id="GeoFit2_+3A_x">X</code></td>
<td>
<p>Numeric; Matrix of spatio(temporal)covariates in the linear mean specification.</p>
</td></tr>
<tr><td><code id="GeoFit2_+3A_nosym">nosym</code></td>
<td>
<p>Logical; if TRUE simmetric weights are not considered. This allows a faster but less efficient CL estimation. </p>
</td></tr>
<tr><td><code id="GeoFit2_+3A_spobj">spobj</code></td>
<td>
<p>An object of class sp or spacetime</p>
</td></tr>
<tr><td><code id="GeoFit2_+3A_spdata">spdata</code></td>
<td>
<p>Character:The name of data in the sp or spacetime object</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>GeoFit2</code> is similar to the  function <code>GeoFit</code>.
However <code>GeoFit2</code>  performs a preliminary estimation  using maximum   indenpendence composite likelihood 
of the marginal parameters of the model and then use the obtained estimates as starting value in the global
weighted composite likelihood estimation (that includes marginal and dependence parameters).
This allows to obtain &quot;good&quot; starting values in the optimization algorithm for the marginal parameters.
</p>


<h3>Value</h3>

<p>Returns an object of class <code>GeoFit</code>.
An object of class <code>GeoFit</code> is a list containing
at most the following components:
</p>
<table>
<tr><td><code>bivariate</code></td>
<td>
<p>Logical:<code>TRUE</code> if the Gaussian RF is bivariate, otherwise  <code>FALSE</code>;</p>
</td></tr>
<tr><td><code>clic</code></td>
<td>
<p>The composite information criterion, if the full
likelihood is considered then it coincides with the Akaike information
criterion;</p>
</td></tr>
<tr><td><code>coordx</code></td>
<td>
<p>A <code class="reqn">d</code>-dimensional vector of spatial coordinates;</p>
</td></tr>
<tr><td><code>coordy</code></td>
<td>
<p>A <code class="reqn">d</code>-dimensional vector of spatial coordinates;</p>
</td></tr>
<tr><td><code>coordt</code></td>
<td>
<p>A <code class="reqn">t</code>-dimensional vector of temporal coordinates;</p>
</td></tr>
<tr><td><code>coordx_dyn</code></td>
<td>
<p>A  list of dynamical (in time) spatial coordinates;</p>
</td></tr>
<tr><td><code>conf.int</code></td>
<td>
<p>Confidence intervals for  standard maximum likelihood estimation;</p>
</td></tr>
<tr><td><code>convergence</code></td>
<td>
<p>A string that denotes if convergence is reached;</p>
</td></tr>
<tr><td><code>copula</code></td>
<td>
<p>The type of copula;</p>
</td></tr>
<tr><td><code>corrmodel</code></td>
<td>
<p>The correlation model;</p>
</td></tr>
<tr><td><code>data</code></td>
<td>
<p>The vector or matrix or array of data;</p>
</td></tr>
<tr><td><code>distance</code></td>
<td>
<p>The type of spatial distance;</p>
</td></tr>
<tr><td><code>fixed</code></td>
<td>
<p>A list of the  fixed parameters;</p>
</td></tr>
<tr><td><code>iterations</code></td>
<td>
<p>The number of iteration used by the numerical routine;</p>
</td></tr>
<tr><td><code>likelihood</code></td>
<td>
<p>The configuration of the composite likelihood;</p>
</td></tr>
<tr><td><code>logCompLik</code></td>
<td>
<p>The value of the log composite-likelihood at the maximum;</p>
</td></tr>
<tr><td><code>maxdist</code></td>
<td>
<p>The maximum spatial distance used in the weigthed composite likelihood. 
If no spatial distance is specified then it is NULL;</p>
</td></tr>
<tr><td><code>maxtime</code></td>
<td>
<p>The maximum temporal distance  used in the weigthed composite likelihood.
If no spatial distance is specified then it is NULL;</p>
</td></tr>
<tr><td><code>message</code></td>
<td>
<p>Extra message passed from the numerical routines;</p>
</td></tr>
<tr><td><code>model</code></td>
<td>
<p>The density associated to the likelihood objects;</p>
</td></tr>
<tr><td><code>missp</code></td>
<td>
<p>True if a misspecified  Gaussian model is ued in  the composite likelihhod;</p>
</td></tr>
<tr><td><code>n</code></td>
<td>
<p>The number of trials in a binominal RF;the number of successes in a  negative Binomial RFs;</p>
</td></tr> 
<tr><td><code>neighb</code></td>
<td>
<p>The 
order of spatial neighborhood  in the composite likelihood
computation. </p>
</td></tr>
<tr><td><code>ns</code></td>
<td>
<p>The number of (different) location sites in the bivariate case;</p>
</td></tr> 
<tr><td><code>nozero</code></td>
<td>
<p>In the case of tapered likelihood  the percentage of non zero values in the covariance matrix.
Otherwise is NULL.</p>
</td></tr>
<tr><td><code>numcoord</code></td>
<td>
<p>The number of spatial coordinates;</p>
</td></tr>
<tr><td><code>numtime</code></td>
<td>
<p>The number of the temporal realisations of the RF;</p>
</td></tr>
<tr><td><code>param</code></td>
<td>
<p>A list of the  parameters' estimates;</p>
</td></tr>
<tr><td><code>radius</code></td>
<td>
<p>The radius of the sphere in the case of great  circle distance;</p>
</td></tr>
<tr><td><code>stderr</code></td>
<td>
<p>The vector of standard errors for  standard maximum likelihood estimation;</p>
</td></tr>
<tr><td><code>sensmat</code></td>
<td>
<p>The sensitivity matrix;</p>
</td></tr>
<tr><td><code>varcov</code></td>
<td>
<p>The matrix of the variance-covariance of the estimates;</p>
</td></tr>
<tr><td><code>varimat</code></td>
<td>
<p>The variability matrix;</p>
</td></tr>
<tr><td><code>vartype</code></td>
<td>
<p>The method used to compute the variance of the estimates;</p>
</td></tr>
<tr><td><code>type</code></td>
<td>
<p>The type of the likelihood objects.</p>
</td></tr>
<tr><td><code>winconst</code></td>
<td>
<p>The constant used to compute the window size in the
spatial sub-sampling;</p>
</td></tr>
<tr><td><code>winstp</code></td>
<td>
<p>The step used for moving the window in the spatial sub-sampling;</p>
</td></tr>
<tr><td><code>winconst_t</code></td>
<td>
<p>The constant used to compute the window size in the
spatio-temporal sub-sampling;</p>
</td></tr>
<tr><td><code>winstp_</code></td>
<td>
<p>The step used for moving the window in the spatio-temporal sub-sampling;</p>
</td></tr>
<tr><td><code>X</code></td>
<td>
<p>The matrix of covariates;</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Moreno Bevilacqua, <a href="mailto:moreno.bevilacqua89@gmail.com">moreno.bevilacqua89@gmail.com</a>,<a href="https://sites.google.com/view/moreno-bevilacqua/home">https://sites.google.com/view/moreno-bevilacqua/home</a>,
Víctor Morales Oñate, <a href="mailto:victor.morales@uv.cl">victor.morales@uv.cl</a>, <a href="https://sites.google.com/site/moralesonatevictor/">https://sites.google.com/site/moralesonatevictor/</a>,
Christian&quot;, Caamaño-Carrillo, <a href="mailto:chcaaman@ubiobio.cl">chcaaman@ubiobio.cl</a>,<a href="https://www.researchgate.net/profile/Christian-Caamano">https://www.researchgate.net/profile/Christian-Caamano</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(GeoModels)


###############################################################
############ Examples of spatial Gaussian RFs ################
###############################################################

################################################################
###
### Example 1 : Maximum pairwise conditional likelihood fitting 
###  of a Gaussian RF with Matern correlation
###
###############################################################
model="Gaussian"
# Define the spatial-coordinates of the points:
set.seed(3)
N=400  # number of location sites
x &lt;- runif(N, 0, 1)
set.seed(6)
y &lt;- runif(N, 0, 1)
coords &lt;- cbind(x,y)

# Define spatial matrix covariates
X=cbind(rep(1,N),runif(N))

# Set the covariance model's parameters:
corrmodel &lt;- "Matern"
mean &lt;- 0.2
mean1 &lt;- -0.5
sill &lt;- 1
nugget &lt;- 0
scale &lt;- 0.2/3
smooth=0.5
param&lt;-list(mean=mean,mean1=mean1,sill=sill,nugget=nugget,scale=scale,smooth=smooth)

# Simulation of the spatial Gaussian RF:
data &lt;- GeoSim(coordx=coords,model=model,corrmodel=corrmodel, param=param,X=X)$data

fixed&lt;-list(nugget=nugget,smooth=smooth)
start&lt;-list(mean=mean,mean1=mean1,scale=scale,sill=sill)

################################################################
###
### Maximum pairwise likelihood fitting of
### Gaussian RFs with exponential correlation.
### 
###############################################################
fit1 &lt;- GeoFit2(data=data,coordx=coords,corrmodel=corrmodel, 
                    optimizer="BFGS",neighb=3,likelihood="Conditional",
                    type="Pairwise", start=start,fixed=fixed,X=X)
print(fit1)




###############################################################
############ Examples of spatial non-Gaussian RFs #############
###############################################################


################################################################
###
### Example 2. Maximum pairwise likelihood fitting of 
### a LogGaussian  RF with Generalized Wendland correlation
### 
###############################################################
set.seed(524)
# Define the spatial-coordinates of the points:
N=500
x &lt;- runif(N, 0, 1)
y &lt;- runif(N, 0, 1)
coords &lt;- cbind(x,y)
X=cbind(rep(1,N),runif(N))
mean=1; mean1=2 # regression parameters
nugget=0
sill=0.5
scale=0.2
smooth=0

model="LogGaussian"
corrmodel="GenWend"
param=list(mean=mean,mean1=mean1,sill=sill,scale=scale,
                    nugget=nugget,power2=4,smooth=smooth)
# Simulation of a  non stationary LogGaussian RF:
data &lt;- GeoSim(coordx=coords, corrmodel=corrmodel,model=model,X=X,
           param=param)$data

fixed&lt;-list(nugget=nugget,power2=4,smooth=smooth)
start&lt;-list(mean=mean,mean1=mean1,scale=scale,sill=sill)
I=Inf
lower&lt;-list(mean=-I,mean1=-I,scale=0,sill=0)
upper&lt;-list(mean= I,mean1= I,scale=I,sill=I)

# Maximum pairwise composite-likelihood fitting of the RF:
fit &lt;- GeoFit2(data=data,coordx=coords,corrmodel=corrmodel, model=model,
                    neighb=3,likelihood="Conditional",type="Pairwise",X=X,
                    optimizer="nlminb",lower=lower,upper=upper,
                    start=start,fixed=fixed)
print(unlist(fit$param))


################################################################
###
### Example 3. Maximum pairwise likelihood fitting of
### SinhAsinh   RFs with Wendland0 correlation
###
###############################################################
set.seed(261)
model="SinhAsinh"
# Define the spatial-coordinates of the points:
x &lt;- runif(500, 0, 1)
y &lt;- runif(500, 0, 1)
coords &lt;- cbind(x,y)

corrmodel="Wend0"
mean=0;nugget=0
sill=1
skew=-0.5
tail=1.5
power2=4
c_supp=0.2

# model parameters
param=list(power2=power2,skew=skew,tail=tail,
             mean=mean,sill=sill,scale=c_supp,nugget=nugget)
data &lt;- GeoSim(coordx=coords, corrmodel=corrmodel,model=model, param=param)$data

plot(density(data))
fixed=list(power2=power2,nugget=nugget)
start=list(scale=c_supp,skew=skew,tail=tail,mean=mean,sill=sill)
# Maximum pairwise likelihood:
fit1 &lt;- GeoFit2(data=data,coordx=coords,corrmodel=corrmodel, model=model,
                    neighb=3,likelihood="Marginal",type="Pairwise",
                    start=start,fixed=fixed)
print(unlist(fit1$param))



</code></pre>

<hr>
<h2 id='GeoKrig'>Spatial (bivariate) and spatio temporal optimal linear prediction 
for Gaussian and non Gaussian random fields.</h2><span id='topic+GeoKrig'></span>

<h3>Description</h3>

<p>For a  given set of  spatial location sites (and temporal instants),
the function computes optimal linear prediction and associated mean square error 
for the Gaussian and non Gaussian case.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GeoKrig(data, coordx, coordy=NULL, coordt=NULL, 
coordx_dyn=NULL, corrmodel,distance="Eucl",
    grid=FALSE, loc, maxdist=NULL, maxtime=NULL,
    method="cholesky", model="Gaussian", n=1,nloc=NULL,mse=FALSE, 
    lin_opt=TRUE,  param, anisopars=NULL,radius=6371, sparse=FALSE,
    taper=NULL,tapsep=NULL, time=NULL, type="Standard",type_mse=NULL,
     type_krig="Simple",weigthed=TRUE,which=1,
     copula=NULL, X=NULL,Xloc=NULL,Mloc=NULL,spobj=NULL,spdata=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GeoKrig_+3A_data">data</code></td>
<td>
<p>A <code class="reqn">d</code>-dimensional vector (a single spatial realisation) or a (<code class="reqn">d \times d</code>)-matrix (a single spatial realisation on regular grid) or a
(<code class="reqn">t \times d</code>)-matrix (a single spatial-temporal realisation)  or an (<code class="reqn">d \times d \times t \times n </code>)-array
(a single spatial-temporal realisation on regular grid) giving the data used for prediction.</p>
</td></tr>
<tr><td><code id="GeoKrig_+3A_coordx">coordx</code></td>
<td>
<p>A numeric (<code class="reqn">d \times 2</code>)-matrix (where <code>d</code> is the number of spatial sites) giving 2-dimensions of spatial coordinates or a numeric <code class="reqn">d</code>-dimensional vector giving 1-dimension of spatial coordinates used for prediction. <code class="reqn">d</code>-dimensional vector giving 1-dimension of spatial coordinates.   Coordinates on a sphere for a  fixed radius <code>radius</code> 
are passed in lon/lat format expressed in decimal degrees.</p>
</td></tr>
<tr><td><code id="GeoKrig_+3A_coordy">coordy</code></td>
<td>
<p>A numeric vector giving 1-dimension of
spatial coordinates used for prediction; <code>coordy</code> is interpreted only if <code>coordx</code> is a numeric
vector or <code>grid=TRUE</code> otherwise it will be ignored. Optional argument, the default is <code>NULL</code> then <code>coordx</code> is expected to be numeric a (<code class="reqn">d \times 2</code>)-matrix.</p>
</td></tr>
<tr><td><code id="GeoKrig_+3A_coordt">coordt</code></td>
<td>
<p>A numeric vector giving 1-dimension of
temporal coordinates used for prediction; the default is <code>NULL</code>
then a spatial random field is expected.</p>
</td></tr>
<tr><td><code id="GeoKrig_+3A_coordx_dyn">coordx_dyn</code></td>
<td>
<p>A list of <code class="reqn">m</code> numeric (<code class="reqn">d_t \times 2</code>)-matrices
containing dynamical (in time) spatial coordinates. Optional argument, the default is <code>NULL</code>
</p>
</td></tr>
<tr><td><code id="GeoKrig_+3A_corrmodel">corrmodel</code></td>
<td>
<p>String; the name of a correlation model, for the
description see the Section <b>Details</b>.</p>
</td></tr>
<tr><td><code id="GeoKrig_+3A_distance">distance</code></td>
<td>
<p>String; the name of the spatial distance. The default
is <code>Eucl</code>, the euclidean distance. See the Section
<b>Details</b> of <code><a href="#topic+GeoFit">GeoFit</a></code>.</p>
</td></tr>
<tr><td><code id="GeoKrig_+3A_grid">grid</code></td>
<td>
<p>Logical; if <code>FALSE</code> (the default) the data used for prediction
are interpreted as spatial or spatial-temporal realisations on a set
of non-equispaced spatial sites (irregular grid).</p>
</td></tr>
<tr><td><code id="GeoKrig_+3A_lin_opt">lin_opt</code></td>
<td>
<p>Logical;If TRUE (default) then  optimal (pairwise) linear  kriging is computed. Otherwise  optimal (pairwise) kriging is computed
in the mean square sense.</p>
</td></tr>  
<tr><td><code id="GeoKrig_+3A_loc">loc</code></td>
<td>
<p>A numeric (<code class="reqn">n \times 2</code>)-matrix (where
<code>n</code> is the number of spatial sites) giving 2-dimensions of spatial coordinates to be predicted.</p>
</td></tr>
<tr><td><code id="GeoKrig_+3A_maxdist">maxdist</code></td>
<td>
<p>Numeric; an optional positive value indicating the maximum
spatial compact support in the case of covariance tapering kriging.</p>
</td></tr>
<tr><td><code id="GeoKrig_+3A_maxtime">maxtime</code></td>
<td>
<p>Numeric; an optional positive value indicating the maximum
temporal compact support in the case of covasriance tapering kriging.</p>
</td></tr>
<tr><td><code id="GeoKrig_+3A_method">method</code></td>
<td>
<p>String; the type of matrix decomposition used in the simulation. Default is <code>cholesky</code>. 
The other possible choices is <code>svd</code>.</p>
</td></tr>
<tr><td><code id="GeoKrig_+3A_n">n</code></td>
<td>
<p>Numeric; the number of trials in a binomial random fields.
Default is <code class="reqn">1</code>.</p>
</td></tr>   
<tr><td><code id="GeoKrig_+3A_nloc">nloc</code></td>
<td>
<p>Numeric; the number of trials  of the locations sites to be predicted in a binomial random fields type II.
Default is <code class="reqn">1</code>.</p>
</td></tr> 
<tr><td><code id="GeoKrig_+3A_mse">mse</code></td>
<td>
<p>Logical; if <code>TRUE</code> (the default) MSE of the kriging predictor  is computed</p>
</td></tr>    
<tr><td><code id="GeoKrig_+3A_model">model</code></td>
<td>
<p>String; the type of RF and therefore the densities associated to the likelihood
objects. <code>Gaussian</code> is the default, see the Section
<b>Details</b>.</p>
</td></tr>      
<tr><td><code id="GeoKrig_+3A_param">param</code></td>
<td>
<p>A list of parameter values required  for the correlation model.See the Section <b>Details</b>.</p>
</td></tr>
<tr><td><code id="GeoKrig_+3A_anisopars">anisopars</code></td>
<td>
<p> A list of two elements: &quot;angle&quot; and &quot;ratio&quot; i.e. the anisotropy angle and the anisotropy ratio, respectively.</p>
</td></tr>
<tr><td><code id="GeoKrig_+3A_radius">radius</code></td>
<td>
<p>Numeric: the radius of the sphere if coordinates are passed in lon/lat format;</p>
</td></tr>
<tr><td><code id="GeoKrig_+3A_sparse">sparse</code></td>
<td>
<p>Logical; if <code>TRUE</code> kriging is computed with sparse matrices algorithms 
using spam package. Default is FALSE. It should be used with compactly supported covariances.</p>
</td></tr>        
<tr><td><code id="GeoKrig_+3A_taper">taper</code></td>
<td>
<p>String; the name of the taper correlation
function, see the Section <b>Details</b>.</p>
</td></tr>
<tr><td><code id="GeoKrig_+3A_tapsep">tapsep</code></td>
<td>
<p>Numeric; an optional  value indicating the separabe
parameter in the space time quasi taper (see <b>Details</b>).</p>
</td></tr>
<tr><td><code id="GeoKrig_+3A_time">time</code></td>
<td>
<p>A numeric (<code class="reqn">m \times 1</code>) vector (where
<code>m</code> is the number of temporal instants) giving the temporal instants to be predicted; the default is <code>NULL</code>
then only spatial prediction is performed.</p>
</td></tr>
<tr><td><code id="GeoKrig_+3A_type">type</code></td>
<td>
<p>String; if <code>Standard</code>   then standard kriging is performed;if <code>Tapering</code>   
then  kriging with covariance tapering is performed;if <code>Pairwise</code> then pairwise
kriging is performed</p>
</td></tr>
<tr><td><code id="GeoKrig_+3A_type_mse">type_mse</code></td>
<td>
<p>String; if  <code>Theoretical</code> then theoretical MSE pairwise kriging is computed.
If <code>SubSamp</code> then  an estimation based on subsampling is computed.</p>
</td></tr>  
<tr><td><code id="GeoKrig_+3A_type_krig">type_krig</code></td>
<td>
<p>String; the type of kriging. If <code>Simple</code> (the
default) then simple kriging is performed. If <code>Optim</code> then optimal kriging is performed for some non-Gaussian RFs</p>
</td></tr>
<tr><td><code id="GeoKrig_+3A_weigthed">weigthed</code></td>
<td>
<p>Logical; if <code>TRUE</code> then decreasing weigths coming 
from a compactly supported correlation function
with compact support <code>maxdist</code> (<code>maxtime</code>)are used in the pairwise kriging.</p>
</td></tr>
<tr><td><code id="GeoKrig_+3A_which">which</code></td>
<td>
<p>Numeric; In the case of bivariate (tapered) cokriging it indicates which variable to predict.
It can be 1 or 2</p>
</td></tr>
<tr><td><code id="GeoKrig_+3A_copula">copula</code></td>
<td>
<p>String; the type of copula. It can be &quot;Clayton&quot; or &quot;Gaussian&quot;</p>
</td></tr>
<tr><td><code id="GeoKrig_+3A_x">X</code></td>
<td>
<p>Numeric; Matrix of spatio(temporal)covariates in the linear mean specification.</p>
</td></tr>
<tr><td><code id="GeoKrig_+3A_xloc">Xloc</code></td>
<td>
<p>Numeric; Matrix of spatio(temporal)covariates in the linear mean specification
associated to predicted locations.</p>
</td></tr>
<tr><td><code id="GeoKrig_+3A_mloc">Mloc</code></td>
<td>
<p>Numeric; Vector of spatio(temporal) estimated means 
associated to predicted locations.</p>
</td></tr>
<tr><td><code id="GeoKrig_+3A_spobj">spobj</code></td>
<td>
<p>An object of class sp or spacetime</p>
</td></tr>
<tr><td><code id="GeoKrig_+3A_spdata">spdata</code></td>
<td>
<p>Character:The name of data in the sp or spacetime object</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Best linear unbiased predictor and associated mean square error is computed 
for Gaussian and some non Gaussian cases.
Specifically, for a spatial or spatio-temporal or spatial bivariate dataset, given a set of  spatial locations and
temporal istants and a correlation model
<code>corrmodel</code> with some fixed parameters and given  the type of RF (<code>model</code>) the function computes
simple  kriging, for the specified spatial locations
<code>loc</code> and temporal instants <code>time</code>, providing also the respective mean square error.
For the choice of the spatial or spatio temporal correlation model see details in <code><a href="#topic+GeoCovmatrix">GeoCovmatrix</a></code> function.
The list <code>param</code> specifies mean and covariance parameters, see <code><a href="#topic+CorrParam">CorrParam</a></code> and <code><a href="#topic+GeoCovmatrix">GeoCovmatrix</a></code> for details. The <code>type_krig</code> parameter indicates the type of kriging. In the
case of simple kriging, the known mean can be specified by the parameter
<code>mean</code> in the  list <code>param</code> (See examples).
</p>


<h3>Value</h3>

<p>Returns an object of class <code>Kg</code>.
An object of class <code>Kg</code> is a list containing
at most the following components:
</p>
<table>
<tr><td><code>bivariate</code></td>
<td>
<p><code>TRUE</code> if spatial bivariate cokriging is performed, otherwise  <code>FALSE</code>;</p>
</td></tr>
<tr><td><code>coordx</code></td>
<td>
<p>A <code class="reqn">d</code>-dimensional vector of spatial coordinates used for prediction;</p>
</td></tr>
<tr><td><code>coordy</code></td>
<td>
<p>A <code class="reqn">d</code>-dimensional vector of spatial coordinates used for prediction;</p>
</td></tr>
<tr><td><code>coordt</code></td>
<td>
<p>A <code class="reqn">t</code>-dimensional vector of temporal coordinates used for prediction;</p>
</td></tr>
<tr><td><code>corrmodel</code></td>
<td>
<p>String: the correlation model;</p>
</td></tr>
<tr><td><code>covmatrix</code></td>
<td>
<p>The covariance matrix if <code>type</code> is <code>Standard</code>. An object of class spam if <code>type</code> is <code>Tapering</code>   </p>
</td></tr>
<tr><td><code>data</code></td>
<td>
<p>The vector or matrix or array of data used for prediction</p>
</td></tr>
<tr><td><code>distance</code></td>
<td>
<p>String: the type of spatial distance;</p>
</td></tr>
<tr><td><code>grid</code></td>
<td>
<p><code>TRUE</code> if the spatial data used for prediction are observed in a regular grid, otherwise  <code>FALSE</code>;</p>
</td></tr>
<tr><td><code>loc</code></td>
<td>
<p>A (<code class="reqn">n \times 2</code>)-matrix of spatial locations to be predicted.</p>
</td></tr>
<tr><td><code>n</code></td>
<td>
<p>The number of trial for Binomial RFs</p>
</td></tr> 
<tr><td><code>nozero</code></td>
<td>
<p>In the case of tapered simple kriging the percentage of non zero values in the covariance matrix.
Otherwise is NULL.</p>
</td></tr>
<tr><td><code>numcoord</code></td>
<td>
<p>Numeric:he number <code class="reqn">d</code> of spatial coordinates used for prediction;</p>
</td></tr>
<tr><td><code>numloc</code></td>
<td>
<p>Numeric: the number <code class="reqn">n</code> of spatial coordinates to be predicted;</p>
</td></tr>
<tr><td><code>numtime</code></td>
<td>
<p>Numeric: the number <code class="reqn">d</code>  of the temporal instants used for prediction;</p>
</td></tr>
<tr><td><code>numt</code></td>
<td>
<p>Numeric: the number <code class="reqn">m</code>  of the temporal instants to be predicted;</p>
</td></tr>
<tr><td><code>model</code></td>
<td>
<p>The type of RF, see <code><a href="#topic+GeoFit">GeoFit</a></code>.</p>
</td></tr>
<tr><td><code>param</code></td>
<td>
<p>Numeric: The covariance parameters;</p>
</td></tr>
<tr><td><code>pred</code></td>
<td>
<p>A (<code class="reqn">m \times n</code>)-matrix of spatio or spatio temporal kriging prediction;</p>
</td></tr>
<tr><td><code>radius</code></td>
<td>
<p>Numeric: the radius of the sphere if coordinates are pssed in lon/lat format;</p>
</td></tr>
<tr><td><code>spacetime</code></td>
<td>
<p><code>TRUE</code> if spatio-temporal kriging and <code>FALSE</code> if
spatial kriging;</p>
</td></tr>
<tr><td><code>tapmod</code></td>
<td>
<p>String: the taper model if <code>type</code> is <code>Tapering</code>. Otherwise is NULL.</p>
</td></tr>
<tr><td><code>time</code></td>
<td>
<p>A <code class="reqn">m</code>-dimensional vector of temporal coordinates to be predicted;</p>
</td></tr>
<tr><td><code>type</code></td>
<td>
<p>String:  the type of kriging (Standard or Tapering).</p>
</td></tr>
<tr><td><code>type_krig</code></td>
<td>
<p>String: the type of kriging.</p>
</td></tr>
<tr><td><code>mse</code></td>
<td>
<p>A (<code class="reqn">m \times n</code>)-matrix of spatio or spatio temporal mean square error kriging prediction;</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Moreno Bevilacqua, <a href="mailto:moreno.bevilacqua89@gmail.com">moreno.bevilacqua89@gmail.com</a>,<a href="https://sites.google.com/view/moreno-bevilacqua/home">https://sites.google.com/view/moreno-bevilacqua/home</a>,
Víctor Morales Oñate, <a href="mailto:victor.morales@uv.cl">victor.morales@uv.cl</a>, <a href="https://sites.google.com/site/moralesonatevictor/">https://sites.google.com/site/moralesonatevictor/</a>,
Christian&quot;, Caamaño-Carrillo, <a href="mailto:chcaaman@ubiobio.cl">chcaaman@ubiobio.cl</a>,<a href="https://www.researchgate.net/profile/Christian-Caamano">https://www.researchgate.net/profile/Christian-Caamano</a>
</p>


<h3>References</h3>

<p>Gaetan, C. and Guyon, X. (2010) <em>Spatial Statistics and Modelling</em>.
Spring Verlang, New York.
Furrer R.,  Genton, M.G. and  Nychka D. (2006). <em>Covariance
Tapering for Interpolation of Large Spatial Datasets</em>.
Journal of Computational and Graphical Statistics, <b>15-3</b>, 502&ndash;523.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+GeoCovmatrix">GeoCovmatrix</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(GeoModels)

################################################################
########### Examples of spatial kriging ############
################################################################

################################################################
###
### Example 1. Spatial  kriging of a
### Gaussian random fields with Gen wendland correlation.
###
################################################################

model="Gaussian"
set.seed(79)
x = runif(400, 0, 1)
y = runif(400, 0, 1)
coords=cbind(x,y)
# Set the exponential cov parameters:
corrmodel = "GenWend"
mean=0; sill=5; nugget=0
scale=0.2;smooth=0;power2=4

param=list(mean=mean,sill=sill,nugget=nugget,scale=scale,smooth=smooth,power2=power2)

# Simulation of the spatial Gaussian random field:
data = GeoSim(coordx=coords, corrmodel=corrmodel,
              param=param)$data

## estimation with pairwise likelihood
fixed=list(nugget=nugget,smooth=0,power2=power2)
start=list(mean=0,scale=scale,sill=1)
I=Inf
lower=list(mean=-I,scale=0,sill=0)
upper=list(mean= I,scale=I,sill=I)
# Maximum pairwise likelihood fitting :
fit = GeoFit(data, coordx=coords, corrmodel=corrmodel,model=model,
                    likelihood='Marginal', type='Pairwise',neighb=3,
                    optimizer="nlminb", lower=lower,upper=upper,
                    start=start,fixed=fixed)

# locations to predict
xx=seq(0,1,0.03)
loc_to_pred=as.matrix(expand.grid(xx,xx))

pr=GeoKrig(loc=loc_to_pred,coordx=coords,corrmodel=corrmodel,
       model=model,param= param, data=data,mse=TRUE)

colour = rainbow(100)

opar=par(no.readonly = TRUE)
par(mfrow=c(1,3))
quilt.plot(coords,data,col=colour)
# simple kriging map prediction
image.plot(xx, xx, matrix(pr$pred,ncol=length(xx)),col=colour,
           xlab="",ylab="",
           main=" Kriging ")

# simple kriging MSE map prediction variance
image.plot(xx, xx, matrix(pr$mse,ncol=length(xx)),col=colour,
           xlab="",ylab="",main="Std error")
par(opar)

################################################################
###
### Example 2. Spatial  kriging of a Skew
### Gaussian random fields with Matern correlation.
###
################################################################
model="SkewGaussian"
set.seed(79)
x = runif(400, 0, 1)
y = runif(400, 0, 1)
coords=cbind(x,y)
# Set the exponential cov parameters:
corrmodel = "Matern"
mean=0
sill=2
nugget=0
scale=0.1
smooth=0.5
skew=3
param=list(mean=mean,sill=sill,nugget=nugget,scale=scale,smooth=smooth,skew=skew)

# Simulation of the spatial skew Gaussian random field:
data = GeoSim(coordx=coords, corrmodel=corrmodel,model=model,
              param=param)$data

fixed=list(nugget=nugget,smooth=smooth)
start=list(mean=0,scale=scale,sill=1,skew=skew)
I=Inf
lower=list(mean=-I,scale=0,sill=0,skew=-I)
upper=list(mean= I,scale=I,sill=I,skew=I)
# Maximum pairwise likelihood fitting :
fit = GeoFit2(data, coordx=coords, corrmodel=corrmodel,model=model,
                    likelihood='Marginal', type='Pairwise',neighb=3,
                    optimizer="nlminb", lower=lower,upper=upper,
                    start=start,fixed=fixed)

# locations to predict
xx=seq(0,1,0.03)
loc_to_pred=as.matrix(expand.grid(xx,xx))
## optimal linear kriging
pr=GeoKrig(loc=loc_to_pred,coordx=coords,corrmodel=corrmodel,
       model=model,param= param, data=data,mse=TRUE)

colour = rainbow(100)

opar=par(no.readonly = TRUE)
par(mfrow=c(1,3))
quilt.plot(coords,data,col=colour)
# simple kriging map prediction
image.plot(xx, xx, matrix(pr$pred,ncol=length(xx)),col=colour,
           xlab="",ylab="",
           main=" Kriging ")

# simple kriging MSE map prediction variance
image.plot(xx, xx, matrix(pr$mse,ncol=length(xx)),col=colour,
           xlab="",ylab="",main="Std error")
par(opar)

################################################################
###
### Example 3. Spatial  kriging  of a 
###   Gamma random field with mean spatial regression
###
###############################################################
set.seed(312)
model="Gamma"
corrmodel = "GenWend"  
# Define the spatial-coordinates of the points:
NN=400
coords=cbind(runif(NN),runif(NN))
## matrix covariates
a0=rep(1,NN)
a1=runif(NN,0,1)
X=cbind(a0,a1)
 ##Set model parameters
shape=2
## regression parameters
mean = 1;mean1= -0.2
# correlation parameters
nugget = 0;power2=4
scale = 0.3;smooth=0    

## simulation
param=list(shape=shape,nugget=nugget,mean=mean,mean1=mean1, 
  scale=scale,power2=power2,smooth=smooth)
data = GeoSim(coordx=coords,corrmodel=corrmodel, param=param,
                model=model,X=X)$data

#####starting and fixed parameters
fixed=list(nugget=nugget,power2=power2,smooth=smooth)
start=list(mean=mean,mean1=mean1, scale=scale,shape=shape)

## estimation with pairwise likelihood
fit2 = GeoFit(data=data,coordx=coords,corrmodel=corrmodel,X=X,
              neighb=3,likelihood="Conditional",type="Pairwise",
              start=start,fixed=fixed, model = model)
             
# locations to predict with associated covariates
xx=seq(0,1,0.03)
loc_to_pred=as.matrix(expand.grid(xx,xx))
NP=nrow(loc_to_pred)
a0=rep(1,NP)
a1=runif(NP,0,1)
Xloc=cbind(a0,a1)

#optimal linear  kriging 
pr=GeoKrig(data=data, coordx=coords,loc=loc_to_pred,corrmodel=corrmodel,model=model,mse=TRUE,
        X=X,Xloc=Xloc,
       sparse=TRUE,param=append(fit2$param,fit2$fixed))

## map 
opar=par(no.readonly = TRUE)
par(mfrow=c(1,3))
quilt.plot(coords,data,main="Data")
map=matrix(pr$pred,ncol=length(xx))
mapmse=matrix(pr$mse,ncol=length(xx))
image.plot(xx, xx, map,
           xlab="",ylab="",main="Kriging ")

image.plot(xx, xx, mapmse,
           xlab="",ylab="",main="MSE")
par(opar)


################################################################
########### Examples of spatio temporal kriging ############
################################################################

################################################################
###
### Example 3. Spatio temporal simple kriging of n locations
### sites and m temporal instants for a Gaussian random fields
### with estimated double Wendland correlation.
###
###############################################################
model="Gaussian"
# Define the spatial-coordinates of the points:
x = runif(30, 0, 1)
y = runif(30, 0, 1)
#coords=cbind(x,y)
times=1:5

# Define model correlation modek and associated parameters
corrmodel="Wend0_Wend0"
param=list(nugget=0,mean=0,power2_s=4,power2_t=4,
        scale_s=0.1,scale_t=2,sill=1)

# Simulation of the space time Gaussian random field:
set.seed(31)
data=GeoSim(coordx=coords,coordt=times,corrmodel=corrmodel,sparse=TRUE,
           param=param)$data

# Maximum pairwise likelihood fitting of the space time random field:
start = list(scale_s=0.15,scale_t=2,sill=1,mean=0)
fixed = list(nugget=0,power2_s=4,power2_t=4)
I=Inf
lower=list(scale_s=0,scale_t=0,sill=0,mean=-I)
upper=list(scale_s=I,scale_t=I,sill=I,mean=I)
fit = GeoFit(data, coordx=coords, coordt=times, model=model, corrmodel=corrmodel, 
             likelihood='Conditional', type='Pairwise',start=start,fixed=fixed,
              neighb=3,maxtime=1)


param=append(fit$param,fit$fixed)

# locations to predict
xx=seq(0,1,0.05)
loc_to_pred=as.matrix(expand.grid(xx,xx))
#  Define the times to predict
times_to_pred=1:2

pr=GeoKrig(loc=loc_to_pred,time=times_to_pred,coordx=coords,coordt=times,
      sparse=TRUE,corrmodel=corrmodel, param=param,data=data,mse=TRUE)

opar=par(no.readonly = TRUE)
par(mfrow=c(2,3))
zlim=c(-2.5,2.5)
colour = rainbow(100)

for(i in 1:2) {
quilt.plot(coords,data[i,] ,col=colour,main = paste(" data  at Time=" , i))   
image.plot(xx, xx, matrix(pr$pred[i,],ncol=length(xx)),col=colour,
        main = paste(" Kriging Time=" , i),ylab="")
image.plot(xx, xx, matrix(pr$mse[i,],ncol=length(xx)),col=colour,
           main = paste("Std err Time=" , i),ylab="")
}
par(opar)
</code></pre>

<hr>
<h2 id='GeoKrigloc'>Spatial (bivariate) and spatio temporal optimal linear  local  prediction 
for Gaussian and non Gaussian RFs.</h2><span id='topic+GeoKrigloc'></span>

<h3>Description</h3>

<p>For a  given set of  spatial location sites (and temporal instants),
the function computes optmal local  linear prediction and the associated mean squared error 
for the Gaussian and non Gaussian case using a spatial (temporal) neighborhood
computed using the  function <code><a href="#topic+GeoNeighborhood">GeoNeighborhood</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GeoKrigloc(data, coordx, coordy=NULL, coordt=NULL,
coordx_dyn=NULL, corrmodel, distance="Eucl", grid=FALSE, 
           loc, neighb=NULL, maxdist=NULL, 
           maxtime=NULL, method="cholesky",
           model="Gaussian", n=1,nloc=NULL, mse=FALSE,  
           param, anisopars=NULL,radius=6371,
           sparse=FALSE, time=NULL, type="Standard",type_mse=NULL,
            type_krig="Simple",weigthed=TRUE, 
            which=1, copula=NULL,X=NULL,Xloc=NULL,
            Mloc=NULL,spobj=NULL,spdata=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GeoKrigloc_+3A_data">data</code></td>
<td>
<p>A <code class="reqn">d</code>-dimensional vector (a single spatial realisation) or a (<code class="reqn">d \times d</code>)-matrix (a single spatial realisation on regular grid) or a
(<code class="reqn">t \times d</code>)-matrix (a single spatial-temporal realisation)  or an (<code class="reqn">d \times d \times t \times n </code>)-array
(a single spatial-temporal realisation on regular grid) giving the data used for prediction.</p>
</td></tr>
<tr><td><code id="GeoKrigloc_+3A_coordx">coordx</code></td>
<td>
<p>A numeric (<code class="reqn">d \times 2</code>)-matrix (where <code>d</code> is the number of spatial sites) giving 2-dimensions of spatial coordinates or a numeric <code class="reqn">d</code>-dimensional vector giving 1-dimension of spatial coordinates used for prediction. <code class="reqn">d</code>-dimensional vector giving 1-dimension of spatial coordinates.   Coordinates on a sphere for a  fixed radius <code>radius</code> 
are passed in lon/lat format expressed in decimal degrees.</p>
</td></tr>
<tr><td><code id="GeoKrigloc_+3A_coordy">coordy</code></td>
<td>
<p>A numeric vector giving 1-dimension of
spatial coordinates used for prediction; <code>coordy</code> is interpreted only if <code>coordx</code> is a numeric
vector or <code>grid=TRUE</code> otherwise it will be ignored. Optional argument, the default is <code>NULL</code> then <code>coordx</code> is expected to be numeric a (<code class="reqn">d \times 2</code>)-matrix.</p>
</td></tr>
<tr><td><code id="GeoKrigloc_+3A_coordt">coordt</code></td>
<td>
<p>A numeric vector giving 1-dimension of
temporal coordinates used for prediction; the default is <code>NULL</code>
then a spatial random field is expected.</p>
</td></tr>
<tr><td><code id="GeoKrigloc_+3A_coordx_dyn">coordx_dyn</code></td>
<td>
<p>A list of <code class="reqn">m</code> numeric (<code class="reqn">d_t \times 2</code>)-matrices
containing dynamical (in time) spatial coordinates. Optional argument, the default is <code>NULL</code>
</p>
</td></tr>
<tr><td><code id="GeoKrigloc_+3A_corrmodel">corrmodel</code></td>
<td>
<p>String; the name of a correlation model, for the
description see the Section <b>Details</b>.</p>
</td></tr>
<tr><td><code id="GeoKrigloc_+3A_distance">distance</code></td>
<td>
<p>String; the name of the spatial distance. The default
is <code>Eucl</code>, the euclidean distance. See the Section
<b>Details</b> of <code><a href="#topic+GeoFit">GeoFit</a></code>.</p>
</td></tr>
<tr><td><code id="GeoKrigloc_+3A_grid">grid</code></td>
<td>
<p>Logical; if <code>FALSE</code> (the default) the data used for prediction
are interpreted as spatial or spatial-temporal realisations on a set
of non-equispaced spatial sites (irregular grid).</p>
</td></tr>
<tr><td><code id="GeoKrigloc_+3A_loc">loc</code></td>
<td>
<p>A numeric (<code class="reqn">n \times 2</code>)-matrix (where
<code>n</code> is the number of spatial sites) giving 2-dimensions of spatial coordinates to be predicted.</p>
</td></tr>
<tr><td><code id="GeoKrigloc_+3A_neighb">neighb</code></td>
<td>
<p>Numeric; an optional positive integer indicating the 
order of the  neighborhood.</p>
</td></tr>
<tr><td><code id="GeoKrigloc_+3A_maxdist">maxdist</code></td>
<td>
<p>Numeric; an optional positive value indicating the distance in the spatial neighborhood.</p>
</td></tr>
<tr><td><code id="GeoKrigloc_+3A_maxtime">maxtime</code></td>
<td>
<p>Numeric; an optional positive integer value indicating the order of the temporal neighborhood.</p>
</td></tr>
<tr><td><code id="GeoKrigloc_+3A_method">method</code></td>
<td>
<p>String; the type of matrix decomposition used in the simulation. Default is <code>cholesky</code>. 
The other possible choices is <code>svd</code>.</p>
</td></tr>
<tr><td><code id="GeoKrigloc_+3A_n">n</code></td>
<td>
<p>Numeric; the number of trials in a binomial random fields.
Default is <code class="reqn">1</code>.</p>
</td></tr>   
<tr><td><code id="GeoKrigloc_+3A_nloc">nloc</code></td>
<td>
<p>Numeric; the number of trials  of the locations sites to be predicted in the binomial random field.
If missing then a rounded mean of n is considered.</p>
</td></tr> 
<tr><td><code id="GeoKrigloc_+3A_mse">mse</code></td>
<td>
<p>Logical; if <code>TRUE</code> (the default) MSE of the kriging predictor  is computed</p>
</td></tr>    
<tr><td><code id="GeoKrigloc_+3A_model">model</code></td>
<td>
<p>String; the type of RF and therefore the densities associated to the likelihood
objects. <code>Gaussian</code> is the default, see the Section
<b>Details</b>.</p>
</td></tr>      
<tr><td><code id="GeoKrigloc_+3A_param">param</code></td>
<td>
<p>A list of parameter values required  for the correlation model.See the Section <b>Details</b>.</p>
</td></tr>
<tr><td><code id="GeoKrigloc_+3A_anisopars">anisopars</code></td>
<td>
<p> A list of two elements: &quot;angle&quot; and &quot;ratio&quot; i.e. the anisotropy angle and the anisotropy ratio, respectively.</p>
</td></tr>
<tr><td><code id="GeoKrigloc_+3A_radius">radius</code></td>
<td>
<p>Numeric: the radius of the sphere if coordinates are passed in lon/lat format;</p>
</td></tr>
<tr><td><code id="GeoKrigloc_+3A_sparse">sparse</code></td>
<td>
<p>Logical; if <code>TRUE</code> kriging is computed with sparse matrices algorithms 
using spam package. Default is FALSE. It should be used with compactly supported covariances.</p>
</td></tr>        
<tr><td><code id="GeoKrigloc_+3A_time">time</code></td>
<td>
<p>A numeric (<code class="reqn">m \times 1</code>) vector (where
<code>m</code> is the number of temporal instants) giving the temporal instants to be predicted; the default is <code>NULL</code>
then only spatial prediction is performed.</p>
</td></tr>
<tr><td><code id="GeoKrigloc_+3A_type">type</code></td>
<td>
<p>String; if <code>Standard</code>   then standard kriging is performed;if <code>Tapering</code>   
then  kriging with covariance tapering is performed;if <code>Pairwise</code> then pairwise
kriging is performed</p>
</td></tr>
<tr><td><code id="GeoKrigloc_+3A_type_mse">type_mse</code></td>
<td>
<p>String; if  <code>Theoretical</code> then theoretical MSE pairwise kriging is computed.
If <code>SubSamp</code> then  an estimation based on subsampling is computed.</p>
</td></tr>  
<tr><td><code id="GeoKrigloc_+3A_type_krig">type_krig</code></td>
<td>
<p>String; the type of kriging. If <code>Simple</code> (the
default) then simple kriging is performed. If <code>Optim</code> then optimal kriging is performed for some non-Gaussian RFs</p>
</td></tr>
<tr><td><code id="GeoKrigloc_+3A_weigthed">weigthed</code></td>
<td>
<p>Logical; if <code>TRUE</code> then decreasing weigths coming 
from a compactly supported correlation function
with compact support <code>maxdist</code> (<code>maxtime</code>)are used in the pairwise kriging.</p>
</td></tr>
<tr><td><code id="GeoKrigloc_+3A_which">which</code></td>
<td>
<p>Numeric; In the case of bivariate (tapered) cokriging it indicates which variable to predict.
It can be 1 or 2</p>
</td></tr>
<tr><td><code id="GeoKrigloc_+3A_copula">copula</code></td>
<td>
<p>String; the type of copula. It can be &quot;Clayton&quot; or &quot;Gaussian&quot;</p>
</td></tr>
<tr><td><code id="GeoKrigloc_+3A_x">X</code></td>
<td>
<p>Numeric; Matrix of spatio(temporal)covariates in the linear mean specification.</p>
</td></tr>
<tr><td><code id="GeoKrigloc_+3A_xloc">Xloc</code></td>
<td>
<p>Numeric; Matrix of spatio(temporal)covariates in the linear mean specification
associated to predicted locations.</p>
</td></tr>
<tr><td><code id="GeoKrigloc_+3A_mloc">Mloc</code></td>
<td>
<p>Numeric; Vector of spatio(temporal) estimated means 
associated to predicted locations.</p>
</td></tr>
<tr><td><code id="GeoKrigloc_+3A_spobj">spobj</code></td>
<td>
<p>An object of class sp or spacetime</p>
</td></tr>
<tr><td><code id="GeoKrigloc_+3A_spdata">spdata</code></td>
<td>
<p>Character:The name of data in the sp or spacetime object</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function use the <code><a href="#topic+GeoKrig">GeoKrig</a></code> with a
spatial or spatio-temporal neighborhood computed using  the function <code><a href="#topic+GeoNeighborhood">GeoNeighborhood</a></code>.
The neighborhood is specified with the option <code>maxdist</code>  and <code>maxtime</code>.</p>


<h3>Value</h3>

<p>Returns an object of class <code>Kg</code>.
An object of class <code>Kg</code> is a list containing
at most the following components:
</p>
<table>
<tr><td><code>bivariate</code></td>
<td>
<p><code>TRUE</code> if spatial bivariate cokriging is performed, otherwise  <code>FALSE</code>;</p>
</td></tr>
<tr><td><code>coordx</code></td>
<td>
<p>A <code class="reqn">d</code>-dimensional vector of spatial coordinates used for prediction;</p>
</td></tr>
<tr><td><code>coordy</code></td>
<td>
<p>A <code class="reqn">d</code>-dimensional vector of spatial coordinates used for prediction;</p>
</td></tr>
<tr><td><code>coordt</code></td>
<td>
<p>A <code class="reqn">t</code>-dimensional vector of temporal coordinates used for prediction;</p>
</td></tr>
<tr><td><code>corrmodel</code></td>
<td>
<p>String: the correlation model;</p>
</td></tr>
<tr><td><code>covmatrix</code></td>
<td>
<p>The covariance matrix if <code>type</code> is <code>Standard</code>. An object of class spam if <code>type</code> is <code>Tapering</code>   </p>
</td></tr>
<tr><td><code>data</code></td>
<td>
<p>The vector or matrix or array of data used for prediction</p>
</td></tr>
<tr><td><code>distance</code></td>
<td>
<p>String: the type of spatial distance;</p>
</td></tr>
<tr><td><code>grid</code></td>
<td>
<p><code>TRUE</code> if the spatial data used for prediction are observed in a regular grid, otherwise  <code>FALSE</code>;</p>
</td></tr>
<tr><td><code>loc</code></td>
<td>
<p>A (<code class="reqn">n \times 2</code>)-matrix of spatial locations to be predicted.</p>
</td></tr>
<tr><td><code>n</code></td>
<td>
<p>The number of trial for Binomial RFs</p>
</td></tr> 
<tr><td><code>nozero</code></td>
<td>
<p>In the case of tapered simple kriging the percentage of non zero values in the covariance matrix.
Otherwise is NULL.</p>
</td></tr>
<tr><td><code>numcoord</code></td>
<td>
<p>Numeric:he number <code class="reqn">d</code> of spatial coordinates used for prediction;</p>
</td></tr>
<tr><td><code>numloc</code></td>
<td>
<p>Numeric: the number <code class="reqn">n</code> of spatial coordinates to be predicted;</p>
</td></tr>
<tr><td><code>numtime</code></td>
<td>
<p>Numeric: the number <code class="reqn">d</code>  of the temporal instants used for prediction;</p>
</td></tr>
<tr><td><code>numt</code></td>
<td>
<p>Numeric: the number <code class="reqn">m</code>  of the temporal instants to be predicted;</p>
</td></tr>
<tr><td><code>model</code></td>
<td>
<p>The type of RF, see <code><a href="#topic+GeoFit">GeoFit</a></code>.</p>
</td></tr>
<tr><td><code>param</code></td>
<td>
<p>Numeric: The covariance parameters;</p>
</td></tr>
<tr><td><code>pred</code></td>
<td>
<p>A (<code class="reqn">m \times n</code>)-matrix of spatio or spatio temporal kriging prediction;</p>
</td></tr>
<tr><td><code>radius</code></td>
<td>
<p>Numeric: the radius of the sphere if coordinates are pssed in lon/lat format;</p>
</td></tr>
<tr><td><code>spacetime</code></td>
<td>
<p><code>TRUE</code> if spatio-temporal kriging and <code>FALSE</code> if
spatial kriging;</p>
</td></tr>
<tr><td><code>tapmod</code></td>
<td>
<p>String: the taper model if <code>type</code> is <code>Tapering</code>. Otherwise is NULL.</p>
</td></tr>
<tr><td><code>time</code></td>
<td>
<p>A <code class="reqn">m</code>-dimensional vector of temporal coordinates to be predicted;</p>
</td></tr>
<tr><td><code>type</code></td>
<td>
<p>String:  the type of kriging (Standard or Tapering).</p>
</td></tr>
<tr><td><code>type_krig</code></td>
<td>
<p>String: the type of kriging.</p>
</td></tr>
<tr><td><code>mse</code></td>
<td>
<p>A (<code class="reqn">m \times n</code>)-matrix of spatio or spatio temporal mean square error kriging prediction;</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Moreno Bevilacqua, <a href="mailto:moreno.bevilacqua89@gmail.com">moreno.bevilacqua89@gmail.com</a>,<a href="https://sites.google.com/view/moreno-bevilacqua/home">https://sites.google.com/view/moreno-bevilacqua/home</a>,
Víctor Morales Oñate, <a href="mailto:victor.morales@uv.cl">victor.morales@uv.cl</a>, <a href="https://sites.google.com/site/moralesonatevictor/">https://sites.google.com/site/moralesonatevictor/</a>,
Christian&quot;, Caamaño-Carrillo, <a href="mailto:chcaaman@ubiobio.cl">chcaaman@ubiobio.cl</a>,<a href="https://www.researchgate.net/profile/Christian-Caamano">https://www.researchgate.net/profile/Christian-Caamano</a>
</p>


<h3>References</h3>

<p>Gaetan, C. and Guyon, X. (2010) <em>Spatial Statistics and Modelling</em>.
Spring Verlang, New York.
Furrer R.,  Genton, M.G. and  Nychka D. (2006). <em>Covariance
Tapering for Interpolation of Large Spatial Datasets</em>.
Journal of Computational and Graphical Statistics, <b>15-3</b>, 502&ndash;523.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+GeoCovmatrix">GeoCovmatrix</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
################################################################
############### Examples of Spatial local kriging  #############
################################################################
require(GeoModels)
####
model="Gaussian"

# Define the spatial-coordinates of the points:
set.seed(759)
x = runif(1000, 0, 1)
y = runif(1000, 0, 1)
coords=cbind(x,y)
# Set the exponential cov parameters:
corrmodel = "GenWend"
mean=0; sill=1
nugget=0; scale=0.2
param=list(mean=mean,sill=sill,nugget=nugget,smooth=0,
scale=scale,power2=4)

# Simulation of the spatial Gaussian random field:
data = GeoSim(coordx=coords, corrmodel=corrmodel,
              param=param)$data

# locations to predict
loc_to_pred=matrix(runif(8),4,2)
################################################################
###
### Example 1. Comparing spatial kriging with local kriging for
### a Gaussian random field with GenWend correlation.
### 
###############################################################
pr=GeoKrig(loc=loc_to_pred,coordx=coords,corrmodel=corrmodel,
      model=model,param= param, data=data,mse=TRUE)

pr_loc=GeoKrigloc(data=data,loc=loc_to_pred,coordx=coords,
corrmodel=corrmodel,
      model=model,neighb=100, param= param,mse=TRUE)

pr$pred;
pr_loc$pred


############################################################
#### Example: spatio temporal  Gaussian local kriging ######
############################################################


require(GeoModels)
require(fields)
set.seed(78)
coords=cbind(runif(50),runif(50))
coordt=seq(0,5,0.25)
corrmodel="Matern_Matern"
param=list(nugget=0,mean=0,scale_s=0.2/3,scale_t=0.25/3,sill=2,
  smooth_s=0.5,smooth_t=0.5)

data = GeoSim(coordx=coords, coordt=coordt,
     corrmodel=corrmodel, param=param)$data
##  four location to predict
loc_to_pred=matrix(runif(8),4,2)
## three temporal instants to predict
time=c(0.5,1.5,3.5)


pr=GeoKrig(data=data,loc=loc_to_pred,time=time,
coordx=coords,coordt=coordt,corrmodel=corrmodel,
  model="Gaussian", param= param, mse=TRUE)
pr_loc=GeoKrigloc(data=data,loc=loc_to_pred,
time=time,coordx=coords,coordt=coordt,corrmodel=corrmodel,
  neigh=25,maxtime=1,model="Gaussian", param= param, mse=TRUE)

##  full and local prediction 
pr$pred
pr_loc$pred

</code></pre>

<hr>
<h2 id='GeoNA'>Deleting  NA values (missing values) from a spatial or spatio-temporal dataset.</h2><span id='topic+GeoNA'></span>

<h3>Description</h3>

<p>The function deletes  NA  values from a spatial or spatio-temporal dataset  </p>


<h3>Usage</h3>

<pre><code class='language-R'>GeoNA(data, coordx, coordy=NULL, coordt=NULL,
coordx_dyn=NULL, grid=FALSE, X=NULL, setting="spatial")</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GeoNA_+3A_data">data</code></td>
<td>
<p>A <code class="reqn">d</code>-dimensional vector (a single spatial realisation) or a (<code class="reqn">d \times d</code>)-matrix (a single spatial realisation on regular grid) or a
(<code class="reqn">t \times d</code>)-matrix (a single spatial-temporal realisation)  or an (<code class="reqn">d \times d \times t \times n </code>)-array
(a single spatial-temporal realisation on regular grid) giving the data.</p>
</td></tr>
<tr><td><code id="GeoNA_+3A_coordx">coordx</code></td>
<td>
<p>A numeric (<code class="reqn">d \times 2</code>)-matrix (where
<code>d</code> is the number of spatial sites) giving 2-dimensions of spatial coordinates or a numeric <code class="reqn">d</code>-dimensional vector giving 1-dimension of spatial coordinates. <code class="reqn">d</code>-dimensional vector giving 1-dimension of spatial coordinates.   Coordinates on a sphere for a  fixed radius <code>radius</code> 
are passed in lon/lat format expressed in decimal degrees.</p>
</td></tr>
<tr><td><code id="GeoNA_+3A_coordy">coordy</code></td>
<td>
<p>A numeric vector giving 1-dimension of
spatial coordinates ; <code>coordy</code> is interpreted only if <code>coordx</code> is a numeric
vector or <code>grid=TRUE</code> otherwise it will be ignored. Optional argument, the default is <code>NULL</code> then <code>coordx</code> is expected to
be numeric a (<code class="reqn">d \times 2</code>)-matrix.</p>
</td></tr>
<tr><td><code id="GeoNA_+3A_coordt">coordt</code></td>
<td>
<p>A numeric vector giving 1-dimension of
temporal coordinates; the default is <code>NULL</code>
then a spatial random field is expected.</p>
</td></tr>
<tr><td><code id="GeoNA_+3A_coordx_dyn">coordx_dyn</code></td>
<td>
<p>A list of <code class="reqn">m</code> numeric (<code class="reqn">d_t \times 2</code>)-matrices
containing dynamical (in time) spatial coordinates. Optional argument, the default is <code>NULL</code> </p>
</td></tr>
<tr><td><code id="GeoNA_+3A_grid">grid</code></td>
<td>
<p>Logical; if <code>FALSE</code> (the default) the data 
are interpreted as spatial or spatial-temporal realisations on a set
of non-equispaced spatial sites (irregular grid).</p>
</td></tr>
<tr><td><code id="GeoNA_+3A_x">X</code></td>
<td>
<p>Numeric; Matrix of spatio(temporal) covariates in the linear mean specification.</p>
</td></tr>
<tr><td><code id="GeoNA_+3A_setting">setting</code></td>
<td>
<p>String; are data spatial, spatio-temporal or spatial bivariate
(respectively  <code>spatial</code>, <code>spacetime</code>, <code>bivariate</code>) </p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list containing the following components:
</p>
<table>
<tr><td><code>coordx</code></td>
<td>
<p>A <code class="reqn">d</code>-dimensional vector of spatial coordinates;</p>
</td></tr>
<tr><td><code>coordy</code></td>
<td>
<p>A <code class="reqn">d</code>-dimensional vector of spatial coordinates;</p>
</td></tr>
<tr><td><code>coordt</code></td>
<td>
<p>A <code class="reqn">t</code>-dimensional vector of temporal coordinates;</p>
</td></tr>
<tr><td><code>data</code></td>
<td>
<p>The data without NAvalues </p>
</td></tr>
<tr><td><code>grid</code></td>
<td>
<p><code>TRUE</code> if the spatial data  are observed in a regular grid, otherwise  <code>FALSE</code>;</p>
</td></tr>
<tr><td><code>perc</code></td>
<td>
<p>The percentage of NA values .</p>
</td></tr>
<tr><td><code>setting</code></td>
<td>
<p>Are data of spatial or spatio-temporal or spatial bivariate type</p>
</td></tr>
<tr><td><code>X</code></td>
<td>
<p>Covariates matrix </p>
</td></tr> 
</table>


<h3>Author(s)</h3>

<p>Moreno Bevilacqua, <a href="mailto:moreno.bevilacqua89@gmail.com">moreno.bevilacqua89@gmail.com</a>,<a href="https://sites.google.com/view/moreno-bevilacqua/home">https://sites.google.com/view/moreno-bevilacqua/home</a>,
Víctor Morales Oñate, <a href="mailto:victor.morales@uv.cl">victor.morales@uv.cl</a>, <a href="https://sites.google.com/site/moralesonatevictor/">https://sites.google.com/site/moralesonatevictor/</a>,
Christian&quot;, Caamaño-Carrillo, <a href="mailto:chcaaman@ubiobio.cl">chcaaman@ubiobio.cl</a>,<a href="https://www.researchgate.net/profile/Christian-Caamano">https://www.researchgate.net/profile/Christian-Caamano</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(GeoModels)

# Define the spatial-coordinates of the points:
set.seed(79)
x = runif(200, 0, 1)
y = runif(200, 0, 1)
coords=cbind(x,y)
# Set the exponential cov parameters:
corrmodel = "Matern"
mean=0
sill=1
nugget=0
scale=0.3/3
smooth=0.5
param=list(mean=mean,sill=sill,nugget=nugget,scale=scale,smooth=smooth)

# Simulation of the spatial Gaussian random field:
data = GeoSim(coordx=coords, corrmodel=corrmodel,
              param=param)$data


data[1:100]=NA
# removing NA
a=GeoNA(data,coordx=coords)
a$perc # percentage of NA values 
#a$coordx# spatial coordinates without missing values
#a$data # data without missinng values


</code></pre>

<hr>
<h2 id='GeoNeighborhood'>Spatio (temporal) neighborhood selection for local kriging.</h2><span id='topic+GeoNeighborhood'></span>

<h3>Description</h3>

<p>Given a set of spatio (temporal) locations and data, the procedure selects a spatio (temporal) neighborhood associated to some  given spatio (temporal) locations.
The neighborhood is computed  using a fixed  spatio (temporal) threshold
or considering a fixed number of spatio (temporal) neighbors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GeoNeighborhood(data=NULL, coordx, coordy=NULL,
coordt=NULL, coordx_dyn=NULL, bivariate=FALSE,
               distance="Eucl", grid=FALSE, 
               loc, neighb=NULL,maxdist=NULL,
               maxtime=NULL, radius=6371, time=NULL, 
               X=NULL,M=NULL,spobj=NULL,spdata=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GeoNeighborhood_+3A_data">data</code></td>
<td>
<p>An optional <code class="reqn">d</code>-dimensional vector (a single spatial realisation)  or a (<code class="reqn">d \times d</code>)-matrix (a single spatial realisation on regular grid)
or a
(<code class="reqn">t \times d</code>)-matrix (a single spatial-temporal realisation)   or an (<code class="reqn">d \times d \times t \times n </code>)-array
(a single spatial-temporal realisation on regular grid).</p>
</td></tr>
<tr><td><code id="GeoNeighborhood_+3A_coordx">coordx</code></td>
<td>
<p>A numeric (<code class="reqn">d \times 2</code>)-matrix (where
<code>d</code> is the number of spatial sites) giving 2-dimensions of spatial coordinates or a numeric <code class="reqn">d</code>-dimensional vector giving
1-dimension of spatial coordinates.
Coordinates on a sphere for a  fixed radius <code>radius</code> 
are passed in lon/lat format expressed in decimal degrees.</p>
</td></tr>
<tr><td><code id="GeoNeighborhood_+3A_coordy">coordy</code></td>
<td>
<p>A numeric vector giving 1-dimension of
spatial coordinates; <code>coordy</code> is interpreted only if <code>coordx</code> is a numeric
vector or <code>grid=TRUE</code> otherwise it will be ignored. Optional argument, the default is <code>NULL</code> then <code>coordx</code> is expected to
be numeric a (<code class="reqn">d \times 2</code>)-matrix.</p>
</td></tr>
<tr><td><code id="GeoNeighborhood_+3A_coordt">coordt</code></td>
<td>
<p>A numeric vector giving 1-dimension of
temporal coordinates.  Optional argument, the default is <code>NULL</code>
then a spatial RF is expected.</p>
</td></tr>
<tr><td><code id="GeoNeighborhood_+3A_coordx_dyn">coordx_dyn</code></td>
<td>
<p>A list of <code class="reqn">m</code> numeric (<code class="reqn">d_t \times 2</code>)-matrices
containing dynamical (in time) spatial coordinates. Optional argument, the default is <code>NULL</code>
</p>
</td></tr>
<tr><td><code id="GeoNeighborhood_+3A_bivariate">bivariate</code></td>
<td>
<p>If TRUE then data  is considered as spatial  bivariate data.</p>
</td></tr>
<tr><td><code id="GeoNeighborhood_+3A_distance">distance</code></td>
<td>
<p>String; the name of the spatial distance. The default
is <code>Eucl</code>, the euclidean distance. See the Section
<b>Details</b>  of <code><a href="#topic+GeoFit">GeoFit</a></code>.</p>
</td></tr>
<tr><td><code id="GeoNeighborhood_+3A_grid">grid</code></td>
<td>
<p>Logical; if <code>FALSE</code> (the default) the data
are interpreted as spatial or spatial-temporal realisations on a set
of non-equispaced spatial sites (irregular grid).</p>
</td></tr>
<tr><td><code id="GeoNeighborhood_+3A_loc">loc</code></td>
<td>
<p>A (<code class="reqn">1 \times 2</code>)-matrix  giving the spatial coordinate
of the location for which a neighborhood is computed .</p>
</td></tr>
<tr><td><code id="GeoNeighborhood_+3A_neighb">neighb</code></td>
<td>
<p>Numeric; an optional positive integer indicating the 
order of spatial neighborhood.</p>
</td></tr>
<tr><td><code id="GeoNeighborhood_+3A_maxdist">maxdist</code></td>
<td>
<p>Numeric; a positive value indicating the maximum
spatial distance considered in the spatial neighborhood
selection.</p>
</td></tr>
<tr><td><code id="GeoNeighborhood_+3A_maxtime">maxtime</code></td>
<td>
<p>Numeric; an optional positive integer indicating the 
order of temporal  neighborhood.</p>
</td></tr>
<tr><td><code id="GeoNeighborhood_+3A_radius">radius</code></td>
<td>
<p>Numeric; a value indicating  the radius of the sphere when using the great 
circle distance. Default value is the radius of the earth in Km (i.e. 6371)</p>
</td></tr>  
<tr><td><code id="GeoNeighborhood_+3A_time">time</code></td>
<td>
<p>Numeric; a value  giving the temporal instant for which a neighborhood is computed.</p>
</td></tr>
<tr><td><code id="GeoNeighborhood_+3A_x">X</code></td>
<td>
<p>Numeric; an optional Matrix of spatio (temporal) covariates.</p>
</td></tr>
<tr><td><code id="GeoNeighborhood_+3A_m">M</code></td>
<td>
<p>Numeric; an estimated spatio (temporal) mean vector.</p>
</td></tr>
<tr><td><code id="GeoNeighborhood_+3A_spobj">spobj</code></td>
<td>
<p>An object of class sp or spacetime</p>
</td></tr>
<tr><td><code id="GeoNeighborhood_+3A_spdata">spdata</code></td>
<td>
<p>Character:The name of data in the sp or spacetime object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list  containing the following informations:
</p>
<table>
<tr><td><code>coordx</code></td>
<td>
<p>A list  of  the  matrix coordinates of the computed spatial neighborhood ;</p>
</td></tr>
<tr><td><code>coordt</code></td>
<td>
<p>A vector  of the computed temporal neighborhood;</p>
</td></tr>
<tr><td><code>data</code></td>
<td>
<p>A list  of the vector of data associated with the spatio  (temporal) neighborhood;</p>
</td></tr>
<tr><td><code>distance</code></td>
<td>
<p>The type of spatial distance;</p>
</td></tr>
<tr><td><code>numcoord</code></td>
<td>
<p>The vector of numbers of location sites involved the spatial neighborhood;</p>
</td></tr>
<tr><td><code>numtime</code></td>
<td>
<p>The vector of numbers of temporal insttants involved the temporal neighborhood;</p>
</td></tr>
<tr><td><code>radius</code></td>
<td>
<p>The radius of the sphere if coordinates are passed in lon/lat format;</p>
</td></tr>
<tr><td><code>spacetime</code></td>
<td>
<p><code>TRUE</code> if spatio-temporal and <code>FALSE</code> if spatial RF;</p>
</td></tr>
<tr><td><code>X</code></td>
<td>
<p>The matrix of spatio  (temporal) covariates associated with the computed spatio  (temporal) neighborhood;</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Moreno Bevilacqua, <a href="mailto:moreno.bevilacqua89@gmail.com">moreno.bevilacqua89@gmail.com</a>,<a href="https://sites.google.com/view/moreno-bevilacqua/home">https://sites.google.com/view/moreno-bevilacqua/home</a>,
Víctor Morales Oñate, <a href="mailto:victor.morales@uv.cl">victor.morales@uv.cl</a>, <a href="https://sites.google.com/site/moralesonatevictor/">https://sites.google.com/site/moralesonatevictor/</a>,
Christian&quot;, Caamaño-Carrillo, <a href="mailto:chcaaman@ubiobio.cl">chcaaman@ubiobio.cl</a>,<a href="https://www.researchgate.net/profile/Christian-Caamano">https://www.researchgate.net/profile/Christian-Caamano</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(GeoModels)
##########################################
#### Example: spatial neighborhood  ######
##########################################
set.seed(75)
coords=cbind(runif(500),runif(500))

param=list(nugget=0,mean=0,scale=0.2,sill=1,
            power2=4,smooth=1)

data_all = GeoSim(coordx=coords, corrmodel="GenWend", 
                         param=param)$data

plot(coords)
##two locations 
loc_to_pred=matrix(c(0.3,0.5,0.7,0.2),2,2)

points(loc_to_pred,pch=20)
neigh=GeoNeighborhood(data_all, coordx=coords,  
                  loc=loc_to_pred,neighb=8)

# two Neighborhoods 
neigh$coordx
points(neigh$coordx[[1]],pch=20,col="red")
points(neigh$coordx[[2]],pch=20,col="blue")
# associated data
neigh$data


###################################################
#### Example: spatio temporal spatial neighborhood#  
###################################################

set.seed(78)
coords=matrix(runif(80),40,2)
coordt=seq(0,6,0.25)

param=list(nugget=0,mean=0,scale_s=0.2/3,scale_t=0.25/3,sill=2)

data_all = GeoSim(coordx=coords, coordt=coordt,corrmodel="Exp_Exp", 
                         param=param)$data
##  two location to predict
loc_to_pred=matrix(runif(4),2,2)
## three temporal instants to predict
time=c(1,2)

plot(coords,xlim=c(0,1),ylim=c(0,1))
points(loc_to_pred,pch=20)

neigh=GeoNeighborhood(data_all, coordx=coords,  coordt=coordt,
                  loc=loc_to_pred,time=time,neighb=3,maxtime=0.5)

# first spatio-temporal neighborhoods 
# with  associated data
neigh$coordx[[1]]
neigh$coordt[[1]]
neigh$data[[1]]

###################################################
#### Example: bivariate  spatial neighborhood #####  
###################################################

set.seed(79)
coords=matrix(runif(100),50,2)

param=list(mean_1=0,mean_2=0,scale=0.12,smooth=0.5,
           sill_1=1,sill_2=1,nugget_1=0,nugget_2=0,pcol=0.5)

data_all = GeoSim(coordx=coords,corrmodel="Bi_matern_sep",
                 param=param)$data
##  two location to predict
loc_to_pred=matrix(runif(4),2,2)

neigh=GeoNeighborhood(data_all, coordx=coords,bivariate=TRUE,
                  loc=loc_to_pred,maxdist=0.25)

plot(coords)
points(loc_to_pred,pch=20)
points(neigh$coordx[[1]],col="red",pch=20)
points(neigh$coordx[[2]],col="red",pch=20)

</code></pre>

<hr>
<h2 id='GeoNeighIndex'>Spatial or spatiotemporal  near neighbour indices.</h2><span id='topic+GeoNeighIndex'></span>

<h3>Description</h3>

<p>The function returns the indices associated with  a given spatial (temporal) neighbour and/or distance 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GeoNeighIndex(coordx,coordy=NULL,coordx_dyn=NULL,
coordt=NULL,distance="Eucl",neighb=4,maxdist=NULL,
maxtime=1,radius=6371,bivariate=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GeoNeighIndex_+3A_coordx">coordx</code></td>
<td>
<p>A numeric (<code class="reqn">d \times 2</code>)-matrix (where
<code>d</code> is the number of spatial sites) assigning 2-dimensions of spatial coordinates or a numeric <code class="reqn">d</code>-dimensional vector assigning
1-dimension of spatial coordinates.  Coordinates on a sphere for a  fixed radius <code>radius</code> 
are passed in lon/lat format expressed in decimal degrees.</p>
</td></tr>
<tr><td><code id="GeoNeighIndex_+3A_coordy">coordy</code></td>
<td>
<p>A numeric vector assigning 1-dimension of
spatial coordinates; <code>coordy</code> is interpreted only if <code>coordx</code> is a numeric
vector or <code>grid=TRUE</code> otherwise it will be ignored. Optional argument, the default is <code>NULL</code> then <code>coordx</code> is expected to
be numeric a (<code class="reqn">d \times 2</code>)-matrix.</p>
</td></tr>
<tr><td><code id="GeoNeighIndex_+3A_coordt">coordt</code></td>
<td>
<p>A numeric vector assigning 1-dimension of
temporal coordinates. Optional argument, the default is <code>NULL</code> then a spatial random field is expected.</p>
</td></tr>
<tr><td><code id="GeoNeighIndex_+3A_coordx_dyn">coordx_dyn</code></td>
<td>
<p>A list of <code class="reqn">m</code> numeric (<code class="reqn">d_t \times 2</code>)-matrices
containing dynamical (in time) spatial coordinates. Optional argument, the default is <code>NULL</code>
</p>
</td></tr>   
<tr><td><code id="GeoNeighIndex_+3A_distance">distance</code></td>
<td>
<p>String; the name of the spatial distance. The default
is <code>Eucl</code>, the euclidean distance. See the Section
<b>Details</b> of <code><a href="#topic+GeoFit">GeoFit</a></code>.</p>
</td></tr>
<tr><td><code id="GeoNeighIndex_+3A_neighb">neighb</code></td>
<td>
<p>Numeric; an optional (vector of) positive integer indicating the 
order of neighborhood. See the Section <b>Details</b> for more information.</p>
</td></tr>
<tr><td><code id="GeoNeighIndex_+3A_maxdist">maxdist</code></td>
<td>
<p>A numeric value denoting the spatial  distance <b>Details</b>.</p>
</td></tr>
<tr><td><code id="GeoNeighIndex_+3A_maxtime">maxtime</code></td>
<td>
<p>A numeric value denoting the temporal distance <b>Details</b>.</p>
</td></tr>
<tr><td><code id="GeoNeighIndex_+3A_radius">radius</code></td>
<td>
<p>Numeric; a value indicating  the radius of the sphere when 
using the great circle distance. Default value is the radius of the earth in Km (i.e. 6371)</p>
</td></tr> 
<tr><td><code id="GeoNeighIndex_+3A_bivariate">bivariate</code></td>
<td>
<p>Logical; if <code>FALSE</code> (the default) the data
are interpreted as univariate spatial or spatial-temporal realisations. 
Otherwise they are intrepreted as a a realization from a bivariate field.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function returns the  spatial or spatiotemporal indices of the pairs tha are neighboords of a certain order and/or with a certain fixed distance
</p>


<h3>Value</h3>

<p>Returns a list containing the following components:
</p>
<table>
<tr><td><code>colidx</code></td>
<td>
<p>First vector of indices</p>
</td></tr>
<tr><td><code>rowidx</code></td>
<td>
<p>Second vector of indices</p>
</td></tr>
<tr><td><code>lags</code></td>
<td>
<p>Vector of spatial distances</p>
</td></tr>
<tr><td><code>lagt</code></td>
<td>
<p>Vector of temporal distances</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Moreno Bevilacqua, <a href="mailto:moreno.bevilacqua89@gmail.com">moreno.bevilacqua89@gmail.com</a>,<a href="https://sites.google.com/view/moreno-bevilacqua/home">https://sites.google.com/view/moreno-bevilacqua/home</a>,
Víctor Morales Oñate, <a href="mailto:victor.morales@uv.cl">victor.morales@uv.cl</a>, <a href="https://sites.google.com/site/moralesonatevictor/">https://sites.google.com/site/moralesonatevictor/</a>,
Christian&quot;, Caamaño-Carrillo, <a href="mailto:chcaaman@ubiobio.cl">chcaaman@ubiobio.cl</a>,<a href="https://www.researchgate.net/profile/Christian-Caamano">https://www.researchgate.net/profile/Christian-Caamano</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

require(GeoModels)
NN = 400
coords = cbind(runif(NN),runif(NN))
scale=0.5/3
param = list(mean=0,sill=1,nugget=0,scale=0.5/3,smooth=0.5)
corrmodel = "Matern"; 

param = list(mean=0,sill=1,nugget=0,scale=scale,smooth=0.5)
set.seed(951)
data = GeoSim(coordx = coords,corrmodel = corrmodel,
                  model = "Gaussian",param = param)$data

sel=GeoNeighIndex(coordx=coords,maxdist=0.05)        

data1=data[sel$colidx]; data2=data[sel$rowidx]
## plotting pairs  that are neighboord of order 5
plot(data1,data2,xlab="",ylab="",main="h-scatterplot, dist=0.05")

</code></pre>

<hr>
<h2 id='GeoNosymindices'>GeoNosymindices.</h2><span id='topic+GeoNosymindices'></span>

<h3>Description</h3>

<p>Given a matrix of indices and associated distances the function return  a matrix of indices 
and associated distances, deleting the symmetric indices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GeoNosymindices(X,Y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GeoNosymindices_+3A_x">X</code></td>
<td>
<p>A matrix of indices</p>
</td></tr>
<tr><td><code id="GeoNosymindices_+3A_y">Y</code></td>
<td>
<p>Associated distances</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function return the  matrix of indices and associated distances, deleting the symmetric indices. 
</p>


<h3>Value</h3>

<p>Returns a list containing the following components:
</p>
<table>
<tr><td><code>xy</code></td>
<td>
<p>Matrix of indices</p>
</td></tr>
<tr><td><code>d</code></td>
<td>
<p>Associated distance</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Moreno Bevilacqua, <a href="mailto:moreno.bevilacqua89@gmail.com">moreno.bevilacqua89@gmail.com</a>,<a href="https://sites.google.com/view/moreno-bevilacqua/home">https://sites.google.com/view/moreno-bevilacqua/home</a>,
Víctor Morales Oñate, <a href="mailto:victor.morales@uv.cl">victor.morales@uv.cl</a>, <a href="https://sites.google.com/site/moralesonatevictor/">https://sites.google.com/site/moralesonatevictor/</a>,
Christian&quot;, Caamaño-Carrillo, <a href="mailto:chcaaman@ubiobio.cl">chcaaman@ubiobio.cl</a>,<a href="https://www.researchgate.net/profile/Christian-Caamano">https://www.researchgate.net/profile/Christian-Caamano</a>
</p>

<hr>
<h2 id='GeoOutlier'>Spatio (temporal) outliers detection</h2><span id='topic+GeoOutlier'></span>

<h3>Description</h3>

<p>Given a set of spatio (temporal) locations and data, the procedure select the spatial or spatiotemporal ouliers
using a specific algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GeoOutlier(data, coordx, coordy=NULL, coordt=NULL, coordx_dyn=NULL, 
             distance="Eucl", grid=FALSE,  neighb=10,alpha=0.001,
             method="Z-Median", radius=6371, bivariate=FALSE,X=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GeoOutlier_+3A_data">data</code></td>
<td>
<p>An optional <code class="reqn">d</code>-dimensional vector (a single spatial realisation)  or a (<code class="reqn">d \times d</code>)-matrix (a single spatial realisation on regular grid)
or a (<code class="reqn">t \times d</code>)-matrix (a single spatial-temporal realisation)   or an (<code class="reqn">d \times d \times t \times n </code>)-array
(a single spatial-temporal realisation on regular grid).</p>
</td></tr>
<tr><td><code id="GeoOutlier_+3A_coordx">coordx</code></td>
<td>
<p>A numeric (<code class="reqn">d \times 2</code>)-matrix (where
<code>d</code> is the number of spatial sites) giving 2-dimensions of spatial coordinates or a numeric <code class="reqn">d</code>-dimensional vector giving
1-dimension of spatial coordinates.
Coordinates on a sphere for a  fixed radius <code>radius</code> 
are passed in lon/lat format expressed in decimal degrees.</p>
</td></tr>
<tr><td><code id="GeoOutlier_+3A_coordy">coordy</code></td>
<td>
<p>A numeric vector giving 1-dimension of
spatial coordinates; <code>coordy</code> is interpreted only if <code>coordx</code> is a numeric
vector or <code>grid=TRUE</code> otherwise it will be ignored. Optional argument, the default is <code>NULL</code> then <code>coordx</code> is expected to
be numeric a (<code class="reqn">d \times 2</code>)-matrix.</p>
</td></tr>
<tr><td><code id="GeoOutlier_+3A_coordt">coordt</code></td>
<td>
<p>A numeric vector giving 1-dimension of
temporal coordinates.  Optional argument, the default is <code>NULL</code>
then a spatial RF is expected.</p>
</td></tr>
<tr><td><code id="GeoOutlier_+3A_coordx_dyn">coordx_dyn</code></td>
<td>
<p>A list of <code class="reqn">m</code> numeric (<code class="reqn">d_t \times 2</code>)-matrices
containing dynamical (in time) spatial coordinates. Optional argument, the default is <code>NULL</code>
</p>
</td></tr>
<tr><td><code id="GeoOutlier_+3A_distance">distance</code></td>
<td>
<p>String; the name of the spatial distance. The default
is <code>Eucl</code>, the euclidean distance. See the Section
<b>Details</b>  of <code><a href="#topic+GeoFit">GeoFit</a></code>.</p>
</td></tr>
<tr><td><code id="GeoOutlier_+3A_grid">grid</code></td>
<td>
<p>Logical; if <code>FALSE</code> (the default) the data
are interpreted as spatial or spatial-temporal realisations on a set
of non-equispaced spatial sites (irregular grid).</p>
</td></tr>
<tr><td><code id="GeoOutlier_+3A_neighb">neighb</code></td>
<td>
<p>Numeric; an optional positive integer indicating the 
order of neighborhoodused for Z-Median algorithm.</p>
</td></tr>
<tr><td><code id="GeoOutlier_+3A_alpha">alpha</code></td>
<td>
<p>Numeric; a numeric value between 0 and 1 used for Z-Median algorithm.</p>
</td></tr>
<tr><td><code id="GeoOutlier_+3A_method">method</code></td>
<td>
<p>String; The name of the algorithm for detecting spatial ouliers. Default is Z-median proposed in Chen et al. (2008)</p>
</td></tr>
<tr><td><code id="GeoOutlier_+3A_radius">radius</code></td>
<td>
<p>Numeric; a value indicating  the radius of the sphere when using the great 
circle distance. Default value is the radius of the earth in Km (i.e. 6371)</p>
</td></tr>  
<tr><td><code id="GeoOutlier_+3A_bivariate">bivariate</code></td>
<td>
<p>If TRUE then data  is considered as spatial  bivariate data.</p>
</td></tr>
<tr><td><code id="GeoOutlier_+3A_x">X</code></td>
<td>
<p>Numeric; an optional Matrix of spatio (temporal) covariates.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Return a  matrix or a list  containing the dected spatial or spatio-temporal outliers
</p>


<h3>Author(s)</h3>

<p>Moreno Bevilacqua, <a href="mailto:moreno.bevilacqua89@gmail.com">moreno.bevilacqua89@gmail.com</a>,<a href="https://sites.google.com/view/moreno-bevilacqua/home">https://sites.google.com/view/moreno-bevilacqua/home</a>,
Víctor Morales Oñate, <a href="mailto:victor.morales@uv.cl">victor.morales@uv.cl</a>, <a href="https://sites.google.com/site/moralesonatevictor/">https://sites.google.com/site/moralesonatevictor/</a>,
Christian&quot;, Caamaño-Carrillo, <a href="mailto:chcaaman@ubiobio.cl">chcaaman@ubiobio.cl</a>,<a href="https://www.researchgate.net/profile/Christian-Caamano">https://www.researchgate.net/profile/Christian-Caamano</a>
</p>


<h3>References</h3>

<p>Chen D, Lu C, Kou Y, Chen F (2008) On detecting spatial outliers. Geoinformatica 12:455–475
</p>
<p>Bevilacqua M., Caamaño C., Arellano-Valle R. B., Camilo Gomez C. (2022) A class of random fields with two-piece marginal distributions for modeling point-referenced data with spatial outliers. <em>Test</em>  10.1007/s11749-021-00797-5
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(GeoModels)
set.seed(1428)
NN = 1500
coords = cbind(runif(NN),runif(NN))
###
scale=0.5/3
corrmodel = "Matern"; 

param = list(mean=0,sill=1,nugget=0,scale=scale,smooth=0.5,skew=0)
data = GeoSim(coordx = coords,corrmodel = corrmodel,
                  model = "TwoPieceGaussian",param = param)$data

K=15         #parameter for outliers detection alghoritm
alpha=0.005  #parameter for outliers detection alghoritm
outlier=GeoOutlier(data=data, coordx = coords,neighb=K,alpha=alpha)
quilt.plot(coords,data)
for (i in 1:nrow(outlier))  plotrix::draw.circle(outlier[i,1], outlier[i,2],radius=0.02,lwd=2) 
nrow(outlier) # number of outliers

param = list(mean=0,sill=1,nugget=0.4,scale=scale,smooth=0.5)
data = GeoSim(coordx = coords,corrmodel = corrmodel,
                  model = "Gaussian",param = param)$data

K=15         #parameter for outliers detection alghoritm
alpha=0.005  #parameter for outliers detection alghoritm
outlier=GeoOutlier(data=data, coordx = coords,neighb=K,alpha=alpha)
quilt.plot(coords,data)
for (i in 1:nrow(outlier))  plotrix::draw.circle(outlier[i,1], outlier[i,2],radius=0.02,lwd=2)
nrow(outlier) # number of outliers
</code></pre>

<hr>
<h2 id='GeoPit'>Probability integral  or normal score tranformation</h2><span id='topic+GeoPit'></span>

<h3>Description</h3>

<p>The procedure  for a given GeoFit object applies  the probability integral tranformation or the normal score transformation to the data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GeoPit(fit,type="Uniform")</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GeoPit_+3A_fit">fit</code></td>
<td>
<p>A GeoFit object</p>
</td></tr></table>
<p>.
</p>
<table>
<tr><td><code id="GeoPit_+3A_type">type</code></td>
<td>
<p>The type of transformation. If &quot;Uniform&quot; then  the probability integral tranformation is performed.
If &quot;Gaussian&quot; then  the normal score transformation is performed. </p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an (updated) object of class <code>GeoFit</code></p>


<h3>Author(s)</h3>

<p>Moreno Bevilacqua, <a href="mailto:moreno.bevilacqua89@gmail.com">moreno.bevilacqua89@gmail.com</a>,<a href="https://sites.google.com/view/moreno-bevilacqua/home">https://sites.google.com/view/moreno-bevilacqua/home</a>,
Víctor Morales Oñate, <a href="mailto:victor.morales@uv.cl">victor.morales@uv.cl</a>, <a href="https://sites.google.com/site/moralesonatevictor/">https://sites.google.com/site/moralesonatevictor/</a>,
Christian&quot;, Caamaño-Carrillo, <a href="mailto:chcaaman@ubiobio.cl">chcaaman@ubiobio.cl</a>,<a href="https://www.researchgate.net/profile/Christian-Caamano">https://www.researchgate.net/profile/Christian-Caamano</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(GeoModels)

model="Beta2"
copula="Clayton"

set.seed(221)
NN=800
x &lt;- runif(NN);y &lt;- runif(NN)
coords=cbind(x,y)


shape=1.5
scale=0.2;power2=4
smooth=0
nugget=0
nu=8

corrmodel="GenWend"

min=-2;max=1
mean=0


param=list(smooth=smooth,power2=power2, min=min,max=max,
             mean=mean, nu=nu,
             scale=scale,nugget=nugget,shape=shape)

optimizer="nlminb"

data &lt;- GeoSimCopula(coordx=coords, corrmodel=corrmodel, 
model=model,param=param,copula=copula)$data

I=50
fixed&lt;-list(nugget=nugget,sill=1,scale=scale,smooth=smooth,power2=power2,min=min,max=max,nu=nu)
start&lt;-list(shape=shape,mean=mean)
lower&lt;-list(shape=0,mean=-I)
upper&lt;-list(shape=10,mean=I)

#### maximum independence likelihood
fit1 &lt;- GeoFit(data=data,coordx=coords,corrmodel=corrmodel,
model=model,likelihood="Marginal",type="Independence",
                      optimizer=optimizer,lower=lower,
                      upper=upper,copula=copula,
                    start=start,fixed=fixed)

## PIT transformation
aa=GeoPit(fit1,type="Uniform")
hist(aa$data,freq=FALSE)
GeoScatterplot(aa$data,coords,neighb=c(1,2))
## Normal score transformation
bb=GeoPit(fit1,type="Gaussian")
hist(bb$data,freq=FALSE)
GeoScatterplot(bb$data,coords,neighb=c(1,2))


</code></pre>

<hr>
<h2 id='GeoQQ'>Quantile-quantile plot </h2><span id='topic+GeoQQ'></span>

<h3>Description</h3>

<p>Based on a GeoFit object, the procedure  plots  a quantile-quantile plot or compares the fitted  density with the histogram of the data. It is useful as diagnostic tool.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GeoQQ(fit,type="Q",add=FALSE,ylim=c(0,1),breaks=10,...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GeoQQ_+3A_fit">fit</code></td>
<td>
<p>A GeoFit object possibly obtained from <code><a href="#topic+GeoResiduals">GeoResiduals</a></code>.</p>
</td></tr>
<tr><td><code id="GeoQQ_+3A_type">type</code></td>
<td>
<p>The type of plot. If Q then a qq-plot (default) is performed. If D then  a comparison between histrogram and the estimated marginal density is performed</p>
</td></tr>
<tr><td><code id="GeoQQ_+3A_add">add</code></td>
<td>
<p>Logical; if TRUE the the estimated density ia added over an existing one</p>
</td></tr> 
<tr><td><code id="GeoQQ_+3A_ylim">ylim</code></td>
<td>
<p>Numeric; a vector of length 2 used for the ylab parameter of the histogram plot.</p>
</td></tr> 
<tr><td><code id="GeoQQ_+3A_breaks">breaks</code></td>
<td>
<p>Numeric; an integer number specifyng  the number of cells ofthe histogram plot if the option type=D is chosen.</p>
</td></tr> 
<tr><td><code id="GeoQQ_+3A_...">...</code></td>
<td>
<p>Optional parameters passed to the plot function.</p>
</td></tr>
</table>


<h3>Value</h3>

 
<p>Produces a plot. No values are returned.
</p>


<h3>Author(s)</h3>

<p>Moreno Bevilacqua, <a href="mailto:moreno.bevilacqua89@gmail.com">moreno.bevilacqua89@gmail.com</a>,<a href="https://sites.google.com/view/moreno-bevilacqua/home">https://sites.google.com/view/moreno-bevilacqua/home</a>,
Víctor Morales Oñate, <a href="mailto:victor.morales@uv.cl">victor.morales@uv.cl</a>, <a href="https://sites.google.com/site/moralesonatevictor/">https://sites.google.com/site/moralesonatevictor/</a>,
Christian&quot;, Caamaño-Carrillo, <a href="mailto:chcaaman@ubiobio.cl">chcaaman@ubiobio.cl</a>,<a href="https://www.researchgate.net/profile/Christian-Caamano">https://www.researchgate.net/profile/Christian-Caamano</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(GeoModels)


##################
### Example 1
##################
set.seed(21)
model="Tukeyh";tail=0.1
N=400 # number of location sites
# Set the coordinates of the points:
x = runif(N, 0, 1)
y = runif(N, 0, 1)
coords=cbind(x,y)

# regression parameters
mean = 5
mean1=0.8

X=cbind(rep(1,N),runif(N))
# correlation parameters:
corrmodel = "Wend0"
sill = 1
nugget = 0
scale = 0.3
power2=4


param=list(mean=mean,mean1=mean1, sill=sill, nugget=nugget, 
	           scale=scale,tail=tail,power2=power2)
# Simulation of the Gaussian RF:
data = GeoSim(coordx=coords, corrmodel=corrmodel, X=X,model=model,param=param)$data

start=list(mean=mean,mean1=mean1, scale=scale,tail=tail)
fixed=list(nugget=nugget,sill=sill,power2=power2)
# Maximum composite-likelihood fitting 
fit = GeoFit(data,coordx=coords, corrmodel=corrmodel,model=model,X=X,
                    likelihood="Conditional",type='Pairwise',start=start,
                    fixed=fixed,neighb=4)

res=GeoResiduals(fit)
GeoQQ(res,type="Q")
GeoQQ(res,type="D",lwd=2,ylim=c(0,0.5),breaks=20)


##################
### Example 2
##################
set.seed(21)
model="Weibull";shape=1.5
N=600 # number of location sites
# Set the coordinates of the points:
x = runif(N, 0, 1)
y = runif(N, 0, 1)
coords=cbind(x,y)


# regression parameters
mean = 0

# correlation parameters:
corrmodel = "Matern"
smooth=0.5
nugget = 0
scale = 0.2/3


param=list(mean=mean, sill=1, nugget=nugget, 
             scale=scale,smooth=smooth, shape=shape)
# Simulation of the Gaussian RF:
data = GeoSim(coordx=coords, corrmodel=corrmodel,model=model,param=param)$data

start=list(mean=mean, scale=scale,shape=shape)
I=Inf
lower=list(mean=-I, scale=0,shape=0)
upper=list(mean= I, scale=I,shape=I)
I=Inf
fixed=list(nugget=nugget,sill=1,smooth=smooth)
# Maximum composite-likelihood fitting 
fit = GeoFit(data,coordx=coords, corrmodel=corrmodel,model=model,
                    likelihood="Conditional",type='Pairwise',start=start,
                    optimizer="nlminb",lower=lower,upper=upper,
                    fixed=fixed,neighb=3)
GeoQQ(fit,type="Q")
GeoQQ(fit,type="D",lwd=2,ylim=c(0,1),breaks=20)
</code></pre>

<hr>
<h2 id='GeoResiduals'>Computes fitted covariance and/or  variogram</h2><span id='topic+GeoResiduals'></span>

<h3>Description</h3>

<p>The procedure return a GeoFit object associated to  the estimated residuals
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GeoResiduals(fit)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GeoResiduals_+3A_fit">fit</code></td>
<td>
<p>A fitted object obtained from the
<code><a href="#topic+GeoFit">GeoFit</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an (updated) object of class <code>GeoFit</code>
</p>


<h3>Author(s)</h3>

<p>Moreno Bevilacqua, <a href="mailto:moreno.bevilacqua89@gmail.com">moreno.bevilacqua89@gmail.com</a>,<a href="https://sites.google.com/view/moreno-bevilacqua/home">https://sites.google.com/view/moreno-bevilacqua/home</a>,
Víctor Morales Oñate, <a href="mailto:victor.morales@uv.cl">victor.morales@uv.cl</a>, <a href="https://sites.google.com/site/moralesonatevictor/">https://sites.google.com/site/moralesonatevictor/</a>,
Christian&quot;, Caamaño-Carrillo, <a href="mailto:chcaaman@ubiobio.cl">chcaaman@ubiobio.cl</a>,<a href="https://www.researchgate.net/profile/Christian-Caamano">https://www.researchgate.net/profile/Christian-Caamano</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+GeoFit">GeoFit</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(GeoModels)



##############
###Example 1
##############
set.seed(211)
model="Gaussian";
N=700 # number of location sites
# Set the coordinates of the points:
x = runif(N, 0, 1)
y = runif(N, 0, 1)
coords=cbind(x,y)

# regression parameters
mean = 5
mean1=0.8

X=cbind(rep(1,N),runif(N))
# correlation parameters:
corrmodel = "Wend0"
sill = 1
nugget = 0
scale = 0.3
power2=4

param=list(mean=mean,mean1=mean1, sill=sill, nugget=nugget, 
             scale=scale,power2=power2)
# Simulation of the Gaussian RF:
data = GeoSim(coordx=coords, corrmodel=corrmodel, X=X,model=model,param=param)$data

start=list(mean=mean,mean1=mean1, scale=scale,sill=sill)
fixed=list(nugget=nugget,power2=power2)
# Maximum composite-likelihood fitting 
fit = GeoFit(data,coordx=coords, corrmodel=corrmodel,model=model,X=X,
                    likelihood="Conditional",type='Pairwise',start=start,
                    fixed=fixed,neighb=3)

res=GeoResiduals(fit)
mean(res$data) # should be approx 0
var(res$data) # should be approx 1
# checking goodness of fit marginal model
GeoQQ(res);GeoQQ(res,type="D",col="red",ylim=c(0,0.5),breaks=20);
# Empirical estimation of the variogram for the residuals:
vario = GeoVariogram(res$data,coordx=coords,maxdist=0.5)
# Comparison between empirical amd estimated semivariogram for the residuals
GeoCovariogram(res, show.vario=TRUE, vario=vario,pch=20)





##############
###Example 2
##############
model="Weibull";shape=4
N=700 # number of location sites
# Set the coordinates of the points:
x = runif(N, 0, 1)
y = runif(N, 0, 1)
coords=cbind(x,y)


# regression parameters
mean = 5
mean1=0.8

X=cbind(rep(1,N),runif(N))
# correlation parameters:
corrmodel = "Wend0"
sill = 1
nugget = 0
scale = 0.3
power2=4

param=list(mean=mean,mean1=mean1, sill=sill, nugget=nugget, 
	           scale=scale,shape=shape,power2=power2)
# Simulation of the Gaussian RF:
data = GeoSim(coordx=coords, corrmodel=corrmodel, X=X,model=model,param=param)$data

I=Inf
start=list(mean=mean,mean1=mean1, scale=scale,shape=shape)
lower=list(mean=-I,mean1=-I, scale=0,shape=0)
upper=list(mean= I,mean1= I, scale=I,shape=I)
fixed=list(nugget=nugget,sill=sill,power2=power2)
# Maximum composite-likelihood fitting 
fit = GeoFit(data,coordx=coords, corrmodel=corrmodel,model=model,X=X,
                    likelihood="Conditional",type='Pairwise',start=start,
                   optimizer="nlminb", lower=lower,upper=upper,
                    fixed=fixed,neighb=3)


res=GeoResiduals(fit)
mean(res$data) # should be approx 1
# checking goodness of fit marginal model
GeoQQ(res);GeoQQ(res,type="D",col="red",ylim=c(0,1.7),breaks=20);
# Empirical estimation of the variogram for the residuals:
vario = GeoVariogram(res$data,coordx=coords,maxdist=0.5)
# Comparison between empirical amd estimated semivariogram for the residuals
GeoCovariogram(res, show.vario=TRUE, vario=vario,pch=20)

</code></pre>

<hr>
<h2 id='GeoScatterplot'>h-scatterplot for space and space-time data.</h2><span id='topic+GeoScatterplot'></span>

<h3>Description</h3>

<p>The function produces h-scatterplots for the spatial, spatio-temporal and  bivariate setting. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GeoScatterplot(data, coordx, coordy=NULL, coordt=NULL, coordx_dyn=NULL,
           distance='Eucl', grid=FALSE, maxdist=NULL,neighb=NULL,
           times=NULL, numbins=4, radius=6371, bivariate=FALSE,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GeoScatterplot_+3A_data">data</code></td>
<td>
<p>A <code class="reqn">d</code>-dimensional vector (a single spatial realisation) or a (<code class="reqn">n \times d</code>)-matrix
(<code class="reqn">n</code> iid spatial realisations) or a (<code class="reqn">d \times d</code>)-matrix (a single spatial realisation on regular grid)
or an (<code class="reqn">d \times d \times n</code>)-array (<code class="reqn">n</code> iid spatial realisations on regular grid) or a
(<code class="reqn">t \times d</code>)-matrix (a single spatial-temporal realisation) or an (<code class="reqn">t \times d \times n </code>)-array
(<code class="reqn">n</code> iid spatial-temporal realisations) or or an (<code class="reqn">d \times d \times t \times n </code>)-array
(a single spatial-temporal realisation on regular grid) or an (<code class="reqn">d \times d \times t \times n </code>)-array
(<code class="reqn">n</code> iid spatial-temporal realisations on regular grid). See <code><a href="#topic+GeoFit">GeoFit</a></code> for details.</p>
</td></tr>
<tr><td><code id="GeoScatterplot_+3A_coordx">coordx</code></td>
<td>
<p>A numeric (<code class="reqn">d \times 2</code>)-matrix (where
<code>d</code> is the number of spatial sites) assigning 2-dimensions of spatial coordinates or a numeric <code class="reqn">d</code>-dimensional vector assigning
1-dimension of spatial coordinates.  Coordinates on a sphere for a  fixed radius <code>radius</code> 
are passed in lon/lat format expressed in decimal degrees.</p>
</td></tr>
<tr><td><code id="GeoScatterplot_+3A_coordy">coordy</code></td>
<td>
<p>A numeric vector assigning 1-dimension of
spatial coordinates; <code>coordy</code> is interpreted only if <code>coordx</code> is a numeric
vector or <code>grid=TRUE</code> otherwise it will be ignored. Optional argument, the default is <code>NULL</code> then <code>coordx</code> is expected to
be numeric a (<code class="reqn">d \times 2</code>)-matrix.</p>
</td></tr>
<tr><td><code id="GeoScatterplot_+3A_coordt">coordt</code></td>
<td>
<p>A numeric vector assigning 1-dimension of
temporal coordinates. Optional argument, the default is <code>NULL</code> then a spatial random field is expected.</p>
</td></tr>
<tr><td><code id="GeoScatterplot_+3A_coordx_dyn">coordx_dyn</code></td>
<td>
<p>A list of <code class="reqn">m</code> numeric (<code class="reqn">d_t \times 2</code>)-matrices
containing dynamical (in time) spatial coordinates. Optional argument, the default is <code>NULL</code>
</p>
</td></tr>   
<tr><td><code id="GeoScatterplot_+3A_distance">distance</code></td>
<td>
<p>String; the name of the spatial distance. The default
is <code>Eucl</code>, the euclidean distance. See the Section
<b>Details</b> of <code><a href="#topic+GeoFit">GeoFit</a></code>.</p>
</td></tr>
<tr><td><code id="GeoScatterplot_+3A_grid">grid</code></td>
<td>
<p>Logical; if <code>FALSE</code> (the default) the data
are interpreted as spatial or spatial-temporal realisations on a set of 
non-equispaced spatial sites.</p>
</td></tr>
<tr><td><code id="GeoScatterplot_+3A_maxdist">maxdist</code></td>
<td>
<p>A numeric value denoting the spatial maximum distance,
see the Section <b>Details</b>.</p>
</td></tr>
<tr><td><code id="GeoScatterplot_+3A_neighb">neighb</code></td>
<td>
<p>Numeric; an optional positive integer indicating the 
order of neighborhood. See the Section <b>Details</b> for more information.</p>
</td></tr>
<tr><td><code id="GeoScatterplot_+3A_times">times</code></td>
<td>
<p>A numeric vector denoting the temporal instants  involved <b>Details</b>.</p>
</td></tr>
<tr><td><code id="GeoScatterplot_+3A_numbins">numbins</code></td>
<td>
<p>A numeric value denoting the numbers of bins, see the
Section <b>Details</b>.</p>
</td></tr>
<tr><td><code id="GeoScatterplot_+3A_radius">radius</code></td>
<td>
<p>Numeric; a value indicating  the radius of the sphere when 
using the great circle distance. Default value is the radius of the earth in Km (i.e. 6371)</p>
</td></tr> 
<tr><td><code id="GeoScatterplot_+3A_bivariate">bivariate</code></td>
<td>
<p>Logical; if <code>FALSE</code> (the default) the data
are interpreted as univariate spatial or spatial-temporal realisations. 
Otherwise they are intrepreted as a a realization from a bivariate field.</p>
</td></tr>
<tr><td><code id="GeoScatterplot_+3A_...">...</code></td>
<td>
<p>Optional parameters passed to the plot function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>h-scatterplot is the plot of the pair values  that are neighborhood of a certain order or  with distances belonging to a certain interval.
In the first case a (vector of)  neighborhood must  be specified. In the second case a maximum distance (maxdist) and a number of lag-bins
(numbins) must be specified.
The method based on neighborhoods is recommended in particular for large datasets.
</p>


<h3>Value</h3>

<p>Produces a plot. No values are returned.</p>


<h3>Author(s)</h3>

<p>Moreno Bevilacqua, <a href="mailto:moreno.bevilacqua89@gmail.com">moreno.bevilacqua89@gmail.com</a>,<a href="https://sites.google.com/view/moreno-bevilacqua/home">https://sites.google.com/view/moreno-bevilacqua/home</a>,
Víctor Morales Oñate, <a href="mailto:victor.morales@uv.cl">victor.morales@uv.cl</a>, <a href="https://sites.google.com/site/moralesonatevictor/">https://sites.google.com/site/moralesonatevictor/</a>,
Christian&quot;, Caamaño-Carrillo, <a href="mailto:chcaaman@ubiobio.cl">chcaaman@ubiobio.cl</a>,<a href="https://www.researchgate.net/profile/Christian-Caamano">https://www.researchgate.net/profile/Christian-Caamano</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(GeoModels)
set.seed(514)

NN = 600
coords = cbind(runif(NN),runif(NN))

param = list(mean=0,sill=1,nugget=0,power2=4,scale=0.4,smooth=0)

corrmodel = "GenWend"; model = "Gaussian"

data = GeoSim(coordx = coords,corrmodel = corrmodel,
                  model = model,param = param)$data

# h-scatterplots for given a vector of neighborhoods
GeoScatterplot(data,coords,neighb=c(2,4))

</code></pre>

<hr>
<h2 id='GeoSim'>Simulation of Gaussian and non Gaussian Random Fields.</h2><span id='topic+GeoSim'></span><span id='topic+print.GeoSim'></span>

<h3>Description</h3>

<p>Simulation of Gaussian and some non Gaussian spatial, spatio-temporal and spatial bivariate 
random fields.
The function return a realization of a Random Field for a given covariance model and covariance parameters.
Simulation is based on Cholesky decomposition.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GeoSim(coordx, coordy=NULL, coordt=NULL, coordx_dyn=NULL, corrmodel, distance="Eucl",
      GPU=NULL, grid=FALSE, local=c(1,1),method="cholesky", model='Gaussian', n=1, param,
      anisopars=NULL,radius=6371, sparse=FALSE,X=NULL,spobj=NULL,nrep=1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GeoSim_+3A_coordx">coordx</code></td>
<td>
<p>A numeric (<code class="reqn">d \times 2</code>)-matrix (where
<code>d</code> is the number of spatial sites) giving 2-dimensions of spatial coordinates or a numeric <code class="reqn">d</code>-dimensional vector giving
1-dimension of spatial coordinates.
Coordinates on a sphere for a  fixed radius <code>radius</code> 
are passed in lon/lat format expressed in decimal degrees.</p>
</td></tr>
<tr><td><code id="GeoSim_+3A_coordy">coordy</code></td>
<td>
<p>A numeric vector giving 1-dimension of
spatial coordinates; <code>coordy</code> is interpreted only if <code>coordx</code> is a numeric
vector or <code>grid=TRUE</code> otherwise it will be ignored. Optional argument, the default is <code>NULL</code> then <code>coordx</code> is expected to
be numeric a (<code class="reqn">d \times 2</code>)-matrix.</p>
</td></tr>
<tr><td><code id="GeoSim_+3A_coordt">coordt</code></td>
<td>
<p>A numeric vector giving 1-dimension of
temporal coordinates.  Optional argument, the default is <code>NULL</code>
then a spatial RF is expected.</p>
</td></tr>
<tr><td><code id="GeoSim_+3A_coordx_dyn">coordx_dyn</code></td>
<td>
<p>A list of <code class="reqn">m</code> numeric (<code class="reqn">d_t \times 2</code>)-matrices
containing dynamical (in time) spatial coordinates. Optional argument, the default is <code>NULL</code>
</p>
</td></tr>
<tr><td><code id="GeoSim_+3A_corrmodel">corrmodel</code></td>
<td>
<p>String; the name of a correlation model, for the
description see the Section <b>Details</b>.</p>
</td></tr>
<tr><td><code id="GeoSim_+3A_distance">distance</code></td>
<td>
<p>String; the name of the spatial distance. The default
is <code>Eucl</code>, the euclidean distance. See the Section
<b>Details</b>  of <code><a href="#topic+GeoFit">GeoFit</a></code>.</p>
</td></tr>
<tr><td><code id="GeoSim_+3A_gpu">GPU</code></td>
<td>
<p>Numeric; if <code>NULL</code> (the default) 
no GPU computation is performed.</p>
</td></tr> 
<tr><td><code id="GeoSim_+3A_grid">grid</code></td>
<td>
<p>Logical; if <code>FALSE</code> (the default) the data
are interpreted as spatial or spatial-temporal realisations on a set
of non-equispaced spatial sites (irregular grid).</p>
</td></tr>
<tr><td><code id="GeoSim_+3A_local">local</code></td>
<td>
<p>Numeric; number of local work-items of the GPU</p>
</td></tr>
<tr><td><code id="GeoSim_+3A_method">method</code></td>
<td>
<p>String; the type of matrix decomposition used in the simulation. Default is cholesky. The other possible choices is <code>svd</code>.</p>
</td></tr> 
<tr><td><code id="GeoSim_+3A_model">model</code></td>
<td>
<p>String; the type of RF and therefore the densities associated to the likelihood
objects. <code>Gaussian</code> is the default, see the Section
<b>Details</b>.</p>
</td></tr>
<tr><td><code id="GeoSim_+3A_n">n</code></td>
<td>
<p>Numeric; the number of trials for binomial RFs. The number of successes in the negative Binomial RFs. Default is <code class="reqn">1</code>.</p>
</td></tr> 
<tr><td><code id="GeoSim_+3A_param">param</code></td>
<td>
<p>A list of parameter values required in the
simulation procedure of RFs, see <b>Examples</b>.</p>
</td></tr>
<tr><td><code id="GeoSim_+3A_anisopars">anisopars</code></td>
<td>
<p> A list of two elements &quot;angle&quot; and &quot;ratio&quot; i.e. the anisotropy angle and the anisotropy ratio, respectively.</p>
</td></tr>
<tr><td><code id="GeoSim_+3A_radius">radius</code></td>
<td>
<p>Numeric; a value indicating  the radius of the sphere when using the great 
circle distance. Default value is the radius of the earth in Km (i.e. 6371)</p>
</td></tr>  
<tr><td><code id="GeoSim_+3A_sparse">sparse</code></td>
<td>
<p>Logical; if <code>TRUE</code> then  cholesky decomposition is performed
using sparse matrices algorithms (spam packake). It should be used
with compactly supported covariance models.<code>FALSE</code> is the default.</p>
</td></tr>
<tr><td><code id="GeoSim_+3A_x">X</code></td>
<td>
<p>Numeric; Matrix of space-time covariates.</p>
</td></tr>
<tr><td><code id="GeoSim_+3A_spobj">spobj</code></td>
<td>
<p>An object of class sp or spacetime</p>
</td></tr>
<tr><td><code id="GeoSim_+3A_nrep">nrep</code></td>
<td>
<p>Numeric; Numbers of indipendent replicates.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an object of class <code>GeoSim</code>.
An object of class <code>GeoSim</code> is a list containing
at most the following components:
</p>
<table>
<tr><td><code>bivariate</code></td>
<td>
<p>Logical:<code>TRUE</code> if the Gaussian RF is bivariate, otherwise  <code>FALSE</code>;</p>
</td></tr>
<tr><td><code>coordx</code></td>
<td>
<p>A <code class="reqn">d</code>-dimensional vector of spatial coordinates;</p>
</td></tr>
<tr><td><code>coordy</code></td>
<td>
<p>A <code class="reqn">d</code>-dimensional vector of spatial coordinates;</p>
</td></tr>
<tr><td><code>coordt</code></td>
<td>
<p>A <code class="reqn">t</code>-dimensional vector of temporal coordinates;</p>
</td></tr>
<tr><td><code>coordx_dyn</code></td>
<td>
<p>A  list of dynamical (in time) spatial coordinates;</p>
</td></tr>
<tr><td><code>corrmodel</code></td>
<td>
<p>The correlation model; see <code><a href="#topic+GeoCovmatrix">GeoCovmatrix</a></code>.</p>
</td></tr>
<tr><td><code>data</code></td>
<td>
<p>The vector or matrix or array of data, see
<code><a href="#topic+GeoFit">GeoFit</a></code>;</p>
</td></tr>
<tr><td><code>distance</code></td>
<td>
<p>The type of spatial distance;</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>The method of simulation</p>
</td></tr>
<tr><td><code>model</code></td>
<td>
<p>The type of RF, see <code><a href="#topic+GeoFit">GeoFit</a></code>.</p>
</td></tr>
<tr><td><code>n</code></td>
<td>
<p>The number of trial for Binomial RFs;the number of successes in a negative Binomial RFs;</p>
</td></tr> 
<tr><td><code>numcoord</code></td>
<td>
<p>The number of spatial coordinates;</p>
</td></tr>
<tr><td><code>numtime</code></td>
<td>
<p>The number the temporal realisations of the RF;</p>
</td></tr>
<tr><td><code>param</code></td>
<td>
<p>The vector of  parameters' estimates;</p>
</td></tr>
<tr><td><code>radius</code></td>
<td>
<p>The radius of the sphere if coordinates are passed in lon/lat format;</p>
</td></tr>
<tr><td><code>spacetime</code></td>
<td>
<p><code>TRUE</code> if spatio-temporal and <code>FALSE</code> if
spatial RF;</p>
</td></tr>
<tr><td><code>nrep</code></td>
<td>
<p>The number of indipendent replicates;</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Moreno Bevilacqua, <a href="mailto:moreno.bevilacqua89@gmail.com">moreno.bevilacqua89@gmail.com</a>,<a href="https://sites.google.com/view/moreno-bevilacqua/home">https://sites.google.com/view/moreno-bevilacqua/home</a>,
Víctor Morales Oñate, <a href="mailto:victor.morales@uv.cl">victor.morales@uv.cl</a>, <a href="https://sites.google.com/site/moralesonatevictor/">https://sites.google.com/site/moralesonatevictor/</a>,
Christian&quot;, Caamaño-Carrillo, <a href="mailto:chcaaman@ubiobio.cl">chcaaman@ubiobio.cl</a>,<a href="https://www.researchgate.net/profile/Christian-Caamano">https://www.researchgate.net/profile/Christian-Caamano</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(GeoModels)
library(mapproj)


################################################################
###
### Example 1. Simulation of a spatial Gaussian RF on a regular grid
###
###############################################################

# Define the spatial-coordinates of the points:
x &lt;- runif(500);y &lt;- runif(500)
coords=cbind(x,y)
set.seed(261)
# Simulation of a spatial Gaussian RF with Matern correlation function
data1 &lt;- GeoSim(coordx=coords, corrmodel="Matern", param=list(smooth=0.5,
             mean=0,sill=1,scale=0.4/3,nugget=0))$data

# Simulation of a spatial Gaussian RF with Generalized Wendland correlation function
# using sparse alghorithm matrices
set.seed(261)
data2 &lt;- GeoSim(coordx=coords,  corrmodel="GenWend", param=list(smooth=0,
              power2=4,mean=0,sill=1,scale=0.4,nugget=0))$data
opar=par(no.readonly = TRUE)
par(mfrow=c(1,2))
quilt.plot(coords,data1,main="Matern",xlab="",ylab="")
quilt.plot(coords,data2,main="Wendland",xlab="",ylab="")   
par(opar)
             

################################################################
###
### Example 2. Simulation of a spatial geometric RF 
### with  underlying exponential correlation
### on a regular grid
###
################################################################

# Define the spatial-coordinates of the points:
x &lt;- runif(800);y &lt;- runif(800)
coords &lt;- cbind(x,y)
set.seed(251)
# Simulation of a spatial Binomial RF:
sim &lt;- GeoSim(coordx=coords, corrmodel="Wend0",
             model="BinomialNeg",n=1,sparse=TRUE,
             param=list(nugget=0,mean=0,scale=.2,power2=4))

quilt.plot(coords,sim$data,nlevel=max(sim$data),col=terrain.colors(max(sim$data+1))) 


################################################################
###
### Example 3. Simulation of a spatial Weibull  RF
### with  underlying exponential correlation 
###
###############################################################
# Define the spatial-coordinates of the points:
x &lt;- seq(0,1,0.032)
y &lt;- seq(0,1,0.032)
set.seed(261)
# Simulation of a spatial Gaussian RF with Matern correlation function
data1 &lt;- GeoSim(x,y,grid=TRUE, corrmodel="Exponential",model="Weibull", 
         param=list(shape=1.2,mean=0,scale=0.3/3,nugget=0))$data
image.plot(x,y,data1,main="Weibull RF",xlab="",ylab="")



################################################################
###
### Example 4. Simulation of a spatial t  RF
### with  with  underlying exponential correlation 
###
###############################################################
# Define the spatial-coordinates of the points:
x &lt;- seq(0,1,0.03)
y &lt;- seq(0,1,0.03)
set.seed(268)
# Simulation of a spatial Gaussian RF with Matern correlation function
data1 &lt;- GeoSim(x,y,grid=TRUE, corrmodel="GenWend",model="StudentT", sparse=TRUE,
         param=list(df=1/4,mean=0,sill=1,scale=0.3,nugget=0,smooth=1,power2=5))$data
image.plot(x,y,data1,col=terrain.colors(100),main="Student-t RF",xlab="",ylab="")




################################################################
###
### Example 5. Simulation of a sinhasinh RF
###   with  underlying Wend0 correlation.
###
###############################################################

# Define the spatial-coordinates of the points:
x &lt;- runif(500, 0, 2)
y &lt;- runif(500, 0, 2)
coords &lt;- cbind(x,y)
set.seed(261)
corrmodel="Wend0"
# Simulation of a spatial Gaussian RF:
param=list(power2=4,skew=0,tail=1,
             mean=0,sill=1,scale=0.2,nugget=0)  ## gaussian case
data0 &lt;- GeoSim(coordx=coords, corrmodel=corrmodel,
               model="SinhAsinh", param=param,sparse=TRUE)$data
plot(density(data0),xlim=c(-7,7))

param=list(power2=4,skew=0,tail=0.7,
             mean=0,sill=1,scale=0.2,nugget=0) ## heavy tails
data1 &lt;- GeoSim(coordx=coords, corrmodel=corrmodel,
               model="SinhAsinh", param=param,sparse=TRUE)$data
lines(density(data1),lty=2)

param=list(power2=4,skew=0.5,tail=1,
             mean=0,sill=1,scale=0.2,nugget=0)  ## asymmetry
data2 &lt;- GeoSim(coordx=coords, corrmodel=corrmodel,
               model="SinhAsinh", param=param,sparse=TRUE)$data
lines(density(data2),lty=3)


################################################################
###
### Example 6. Simulation of a bivariate Gaussian RF
### with separable bivariate exponential correlation model
### on a regular grid.
###
###############################################################

# Define the spatial-coordinates of the points:
x &lt;- runif(500, 0, 2)
y &lt;- runif(500, 0, 2)
coords &lt;- cbind(x,y)

# Simulation of a bivariate spatial Gaussian RF:
# with a separable Bivariate Matern
set.seed(12)
param=list(mean_1=4,mean_2=2,scale=0.12,smooth=0.5,
           sill_1=1,sill_2=1,nugget_1=0,nugget_2=0,pcol=0.5)
data &lt;- GeoSim(coordx=coords,corrmodel="Bi_matern_sep",
              param=param)$data
opar=par(no.readonly = TRUE)
par(mfrow=c(1,2))
quilt.plot(coords,data[1,],col=terrain.colors(100),main="1",xlab="",ylab="")
quilt.plot(coords,data[2,],col=terrain.colors(100),main="2",xlab="",ylab="")
par(opar)


################################################################
###
### Example 7. Simulation of a  spatio temporal Gaussian RF.
### observed on  dynamical location sites with double exponential correlation 
###
###############################################################

# Define the dynamical spatial-coordinates of the points:

coordt=1:5
coordx_dyn=list()
maxN=30
set.seed(8)
for(k in 1:length(coordt))
{
NN=sample(1:maxN,size=1)
x &lt;- runif(NN, 0, 1)
y &lt;- runif(NN, 0, 1)
coordx_dyn[[k]]=cbind(x,y)
}
coordx_dyn

param&lt;-list(nugget=0,mean=0,scale_s=0.2/3,scale_t=2/3,sill=1)
data &lt;- GeoSim(coordx_dyn=coordx_dyn, coordt=coordt, corrmodel="Exp_Exp",
                     param=param)$data
## spatial realization at first temporal instants
data[[1]]
## spatial realization at third temporal instants
data[[3]]




################################################################
###
### Example 8. Simulation of a Gaussian RF 
###  with a Wend0 correlation in the north emisphere of the planet earth
### using geodesic distance
###############################################################
distance="Geod";radius=6371

NN=3000 ## total point on the sphere on lon/lat format
set.seed(80)
coords=cbind(runif(NN,-180,180),runif(NN,0,90))
## Set the wendland parameters
corrmodel &lt;- "Wend0"
param&lt;-list(mean=0,sill=1,nugget=0,scale=1000,power2=3)
# Simulation of a spatial Gaussian RF on the sphere
#set.seed(2)
data &lt;- GeoSim(coordx=coords,corrmodel=corrmodel,sparse=TRUE,
               distance=distance,radius=radius,param=param)$data
#require(globe)
#globe::globeearth(eye=place("newyorkcity"))
#globe::globepoints(loc=coords,pch=20,col =  cm.colors(length(data),alpha=0.1)[rank(data)])




</code></pre>

<hr>
<h2 id='GeoSimapprox'>Fast simulation of Gaussian and non Gaussian Random Fields.</h2><span id='topic+GeoSimapprox'></span>

<h3>Description</h3>

<p>Simulation of Gaussian and some non Gaussian spatial, spatio-temporal and spatial bivariate 
random fields using approximate methods of simulation (circulant embeeding and turning bands)n(see Examples). 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GeoSimapprox(coordx, coordy=NULL, coordt=NULL, 
coordx_dyn=NULL,corrmodel, distance="Eucl",GPU=NULL, 
grid=FALSE,local=c(1,1),max.ext=1,
method="TB",M=30, L=1000,model='Gaussian',
n=1,param,anisopars=NULL, radius=6371,X=NULL,spobj=NULL,nrep=1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GeoSimapprox_+3A_coordx">coordx</code></td>
<td>
<p>A numeric (<code class="reqn">d \times 2</code>)-matrix (where
<code>d</code> is the number of spatial sites) giving 2-dimensions of spatial coordinates or a numeric <code class="reqn">d</code>-dimensional vector giving
1-dimension of spatial coordinates.
Coordinates on a sphere for a  fixed radius <code>radius</code> 
are passed in lon/lat format expressed in decimal degrees.</p>
</td></tr>
<tr><td><code id="GeoSimapprox_+3A_coordy">coordy</code></td>
<td>
<p>A numeric vector giving 1-dimension of
spatial coordinates; <code>coordy</code> is interpreted only if <code>coordx</code> is a numeric
vector or <code>grid=TRUE</code> otherwise it will be ignored. Optional argument, the default is <code>NULL</code> then <code>coordx</code> is expected to
be numeric a (<code class="reqn">d \times 2</code>)-matrix.</p>
</td></tr>
<tr><td><code id="GeoSimapprox_+3A_coordt">coordt</code></td>
<td>
<p>A numeric vector giving 1-dimension of
temporal coordinates.  Optional argument, the default is <code>NULL</code>
then a spatial RF is expected.</p>
</td></tr>
<tr><td><code id="GeoSimapprox_+3A_coordx_dyn">coordx_dyn</code></td>
<td>
<p>A list of <code class="reqn">m</code> numeric (<code class="reqn">d_t \times 2</code>)-matrices
containing dynamical (in time) spatial coordinates. Optional argument, the default is <code>NULL</code>
</p>
</td></tr>
<tr><td><code id="GeoSimapprox_+3A_corrmodel">corrmodel</code></td>
<td>
<p>String; the name of a correlation model, for the
description see the Section <b>Details</b>.</p>
</td></tr>
<tr><td><code id="GeoSimapprox_+3A_distance">distance</code></td>
<td>
<p>String; the name of the spatial distance. The default
is <code>Eucl</code>, the euclidean distance. See the Section
<b>Details</b>  of <code><a href="#topic+GeoFit">GeoFit</a></code>.</p>
</td></tr>
<tr><td><code id="GeoSimapprox_+3A_gpu">GPU</code></td>
<td>
<p>Numeric; if <code>NULL</code> (the default) 
no GPU computation is performed.</p>
</td></tr> 
<tr><td><code id="GeoSimapprox_+3A_grid">grid</code></td>
<td>
<p>Logical; if <code>FALSE</code> (the default) the data
are interpreted as spatial or spatial-temporal realisations on a set
of non-equispaced spatial sites (irregular grid).</p>
</td></tr>
<tr><td><code id="GeoSimapprox_+3A_local">local</code></td>
<td>
<p>Numeric; number of local work-items of the GPU</p>
</td></tr>
<tr><td><code id="GeoSimapprox_+3A_max.ext">max.ext</code></td>
<td>
<p>Numeric; The maximum extension of the simulation window (for the spatial CE method).</p>
</td></tr>
<tr><td><code id="GeoSimapprox_+3A_method">method</code></td>
<td>
<p>String; the type of approximation method. Default is <code>TB</code>  that is the 
turning band method. The other possible choice is <code>Vecchia</code> that is the Vechia method for the Matern model
and <code>CE</code> (circular embeeding) for the space time  case .</p>
</td></tr> 
<tr><td><code id="GeoSimapprox_+3A_m">M</code></td>
<td>
<p>Numeric; the number of neighboords in the Vecchia method.</p>
</td></tr> 
<tr><td><code id="GeoSimapprox_+3A_l">L</code></td>
<td>
<p>Numeric; the number of lines in the  turning band method.</p>
</td></tr> 
<tr><td><code id="GeoSimapprox_+3A_model">model</code></td>
<td>
<p>String; the type of RF and therefore the densities associated to the likelihood
objects. <code>Gaussian</code> is the default, see the Section
<b>Details</b>.</p>
</td></tr>
<tr><td><code id="GeoSimapprox_+3A_n">n</code></td>
<td>
<p>Numeric; the number of trials for binomial RFs. The number of successes in the negative Binomial RFs. Default is <code class="reqn">1</code>.</p>
</td></tr> 
<tr><td><code id="GeoSimapprox_+3A_param">param</code></td>
<td>
<p>A list of parameter values required in the
simulation procedure of RFs, see <b>Examples</b>.</p>
</td></tr>
<tr><td><code id="GeoSimapprox_+3A_anisopars">anisopars</code></td>
<td>
<p> A list of two elements &quot;angle&quot; and &quot;ratio&quot; i.e. the anisotropy angle and the anisotropy ratio, respectively.</p>
</td></tr>
<tr><td><code id="GeoSimapprox_+3A_radius">radius</code></td>
<td>
<p>Numeric; a value indicating  the radius of the sphere when using the great 
circle distance. Default value is the radius of the earth in Km (i.e. 6371)</p>
</td></tr>  
<tr><td><code id="GeoSimapprox_+3A_x">X</code></td>
<td>
<p>Numeric; Matrix of space-time covariates.</p>
</td></tr>
<tr><td><code id="GeoSimapprox_+3A_spobj">spobj</code></td>
<td>
<p>An object of class sp or spacetime</p>
</td></tr>
<tr><td><code id="GeoSimapprox_+3A_nrep">nrep</code></td>
<td>
<p>Numeric; Numbers of indipendent replicates.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an object of class <code>GeoSim</code>.
An object of class <code>GeoSim</code> is a list containing
at most the following components:
</p>
<table>
<tr><td><code>bivariate</code></td>
<td>
<p>Logical:<code>TRUE</code> if the Gaussian RF is bivariate, otherwise  <code>FALSE</code>;</p>
</td></tr>
<tr><td><code>coordx</code></td>
<td>
<p>A <code class="reqn">d</code>-dimensional vector of spatial coordinates;</p>
</td></tr>
<tr><td><code>coordy</code></td>
<td>
<p>A <code class="reqn">d</code>-dimensional vector of spatial coordinates;</p>
</td></tr>
<tr><td><code>coordt</code></td>
<td>
<p>A <code class="reqn">t</code>-dimensional vector of temporal coordinates;</p>
</td></tr>
<tr><td><code>coordx_dyn</code></td>
<td>
<p>A  list of dynamical (in time) spatial coordinates;</p>
</td></tr>
<tr><td><code>corrmodel</code></td>
<td>
<p>The correlation model; see <code><a href="#topic+GeoCovmatrix">GeoCovmatrix</a></code>.</p>
</td></tr>
<tr><td><code>data</code></td>
<td>
<p>The vector or matrix or array of data, see
<code><a href="#topic+GeoFit">GeoFit</a></code>;</p>
</td></tr>
<tr><td><code>distance</code></td>
<td>
<p>The type of spatial distance;</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>The method of simulation</p>
</td></tr>
<tr><td><code>model</code></td>
<td>
<p>The type of RF, see <code><a href="#topic+GeoFit">GeoFit</a></code>.</p>
</td></tr>
<tr><td><code>n</code></td>
<td>
<p>The number of trial for Binomial RFs;the number of successes in a negative Binomial RFs;</p>
</td></tr> 
<tr><td><code>numcoord</code></td>
<td>
<p>The number of spatial coordinates;</p>
</td></tr>
<tr><td><code>numtime</code></td>
<td>
<p>The number the temporal realisations of the RF;</p>
</td></tr>
<tr><td><code>param</code></td>
<td>
<p>The vector of  parameters' estimates;</p>
</td></tr>
<tr><td><code>radius</code></td>
<td>
<p>The radius of the sphere if coordinates are passed in lon/lat format;</p>
</td></tr>
<tr><td><code>spacetime</code></td>
<td>
<p><code>TRUE</code> if spatio-temporal and <code>FALSE</code> if
spatial RF;</p>
</td></tr>
<tr><td><code>nrep</code></td>
<td>
<p>The number of indipendent replicates;</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Moreno Bevilacqua, <a href="mailto:moreno.bevilacqua89@gmail.com">moreno.bevilacqua89@gmail.com</a>,<a href="https://sites.google.com/view/moreno-bevilacqua/home">https://sites.google.com/view/moreno-bevilacqua/home</a>,
Víctor Morales Oñate, <a href="mailto:victor.morales@uv.cl">victor.morales@uv.cl</a>, <a href="https://sites.google.com/site/moralesonatevictor/">https://sites.google.com/site/moralesonatevictor/</a>,
Christian&quot;, Caamaño-Carrillo, <a href="mailto:chcaaman@ubiobio.cl">chcaaman@ubiobio.cl</a>,<a href="https://www.researchgate.net/profile/Christian-Caamano">https://www.researchgate.net/profile/Christian-Caamano</a>
</p>


<h3>References</h3>

<p>T. Gneiting, H. Sevcikova, D. B. Percival, M. Schlather and Y. Jiang (2006)
Fast and Exact Simulation of Large Gaussian Lattice Systems in R2: Exploring the Limits
<em>Journal of Computational and Graphical Statistics</em> 15 (3)
</p>
<p>D. Arroyo, X. Emery (2020) An R Implementation of a Continuous Spectral Algorithm for Simulating Vector Gaussian Random Fields in Euclidean Spaces <em>ACM Transactions on Mathematical Software</em>  47(1)
</p>
<p>J. Guiness (2018) Permutation and Grouping Methods for Sharpening Gaussian Process Approximations <em>Technometrics</em> 60(4) 415-429.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(GeoModels)


################################################################
###
### Example 1. Simulation of a large spatial Gaussian RF 
###            with  Matern  covariance model
###            using circulant embeeding method
###            It works only for regular grid
###            for any typpe of correlation model
###############################################################
set.seed(68)
x = seq(0,1,0.005)
y = seq(0,1,0.005)
param=list(smooth=1.5,mean=0,sill=1,scale=0.2/3,nugget=0)
# Simulation of a spatial Gaussian RF with Matern correlation function
data1 &lt;- GeoSimapprox(coordx=x,coordy=y, grid=TRUE,corrmodel="Matern", model="Gaussian",
                      method="CE",param=param)$data
fields::image.plot( matrix(data1, length(x), length(y), byrow = TRUE) )

################################################################
###
### Example 2. Simulation of a large spatial Gaussian RF 
###            with  Matern  covariance model
###            using Turning band method
###            It works for (ir)regular grid
###            for the Matern model
###############################################################
set.seed(68)
x = runif(15000)
y = runif(15000)
coords=cbind(x,y)
param=list(smooth=0.5,mean=0,sill=1,scale=0.1,nugget=0)
# Simulation of a spatial Gaussian RF with Matern correlation function
data1 &lt;- GeoSimapprox(coords, corrmodel="Matern", model="Gaussian",
                      method="TB",param=param)$data
quilt.plot(coords,data1)


################################################################
###
### Example 3. Simulation of a large spatial Gaussian RF 
###            with  matern  covariance model
###            using Vecchia's method
###            It works  for (ir)regular grid
###            for the Matern model
###############################################################
set.seed(68)
x = runif(8000)
y = runif(8000)
coords=cbind(x,y)
param=list(smooth=0.5,mean=0,sill=1,scale=0.1,nugget=0)
# Simulation of a spatial Gaussian RF with Matern correlation function
data1 &lt;- GeoSimapprox(coords, corrmodel="Matern", model="Gaussian",
                      method="Vecchia",param=param)$data
quilt.plot(coords,data1)



################################################################
###
### Example 4. Simulation of a large spacetime Gaussian RF 
###            with separable matern  covariance model
###            using  Circular embeeding method
###            It works  for regular time grid
###            and separable spacetime models
###############################################################
set.seed(68)
coordt &lt;- (0:100)
coords &lt;- cbind( runif(100, 0 ,1), runif(100, 0 ,1))
param &lt;- list(mean  = 0, sill = 1, nugget = 0.25,
              scale_s = 0.05, scale_t = 2, 
              smooth_s = 0.5, smooth_t = 0.5)
# Simulation of a spatial Gaussian RF with Matern correlation function
param&lt;-list(nugget=0,mean=0,scale_s=0.2/3,scale_t=2/3,sill=1,smooth_s=0.5,smooth_t=0.5)

data &lt;- GeoSimapprox(coordx=coords, coordt=coordt, corrmodel="Matern_Matern",
                     model="Gaussian",method="CE",param=param)$data
dim(data)



################################################################
###
### Example 5. Simulation of a large spacetime Gaussian RF 
###            with separable GenWend covariance model
###            using  Circular embeeding method in time
###############################################################
set.seed(68)
# Simulation of a spatial Gaussian RF with Matern correlation function
param&lt;-list(nugget=0,mean=0,scale_s=0.2,scale_t=3,sill=1,
             smooth_s=0,smooth_t=0, power2_s=4,power2_t=4)

data &lt;- GeoSimapprox(coordx=coords, coordt=coordt, corrmodel="GenWend_GenWend",
                     model="Gaussian",method="CE",param=param)$data
dim(data)



</code></pre>

<hr>
<h2 id='GeoSimCopula'>Simulation of Gaussian and non Gaussian Random Fields using copula.</h2><span id='topic+GeoSimCopula'></span><span id='topic+print.GeoSimCopula'></span>

<h3>Description</h3>

<p>Simulation of Gaussian and some non Gaussian spatial, spatio-temporal and spatial bivariate 
random fields using Gaussian or Clayton copula.
The function return a realization of a Random Field for a given covariance model and covariance parameters.
Simulation is based on Cholesky decomposition.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GeoSimCopula(coordx, coordy=NULL, coordt=NULL, 
coordx_dyn=NULL, corrmodel, distance="Eucl",
      GPU=NULL, grid=FALSE, local=c(1,1),
      method="cholesky", model='Gaussian', n=1, param,
      anisopars=NULL,radius=6371, sparse=FALSE,
      copula="Gaussian",seed=NULL, X=NULL,spobj=NULL,nrep=1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GeoSimCopula_+3A_coordx">coordx</code></td>
<td>
<p>A numeric (<code class="reqn">d \times 2</code>)-matrix (where
<code>d</code> is the number of spatial sites) giving 2-dimensions of spatial coordinates or a numeric <code class="reqn">d</code>-dimensional vector giving
1-dimension of spatial coordinates.
Coordinates on a sphere for a  fixed radius <code>radius</code> 
are passed in lon/lat format expressed in decimal degrees.</p>
</td></tr>
<tr><td><code id="GeoSimCopula_+3A_coordy">coordy</code></td>
<td>
<p>A numeric vector giving 1-dimension of
spatial coordinates; <code>coordy</code> is interpreted only if <code>coordx</code> is a numeric
vector or <code>grid=TRUE</code> otherwise it will be ignored. Optional argument, the default is <code>NULL</code> then <code>coordx</code> is expected to
be numeric a (<code class="reqn">d \times 2</code>)-matrix.</p>
</td></tr>
<tr><td><code id="GeoSimCopula_+3A_coordt">coordt</code></td>
<td>
<p>A numeric vector giving 1-dimension of
temporal coordinates.  Optional argument, the default is <code>NULL</code>
then a spatial RF is expected.</p>
</td></tr>
<tr><td><code id="GeoSimCopula_+3A_coordx_dyn">coordx_dyn</code></td>
<td>
<p>A list of <code class="reqn">m</code> numeric (<code class="reqn">d_t \times 2</code>)-matrices
containing dynamical (in time) spatial coordinates. Optional argument, the default is <code>NULL</code>
</p>
</td></tr>
<tr><td><code id="GeoSimCopula_+3A_corrmodel">corrmodel</code></td>
<td>
<p>String; the name of a correlation model, for the
description see the Section <b>Details</b>.</p>
</td></tr>
<tr><td><code id="GeoSimCopula_+3A_distance">distance</code></td>
<td>
<p>String; the name of the spatial distance. The default
is <code>Eucl</code>, the euclidean distance. See the Section
<b>Details</b>  of <code><a href="#topic+GeoFit">GeoFit</a></code>.</p>
</td></tr>
<tr><td><code id="GeoSimCopula_+3A_gpu">GPU</code></td>
<td>
<p>Numeric; if <code>NULL</code> (the default) 
no GPU computation is performed.</p>
</td></tr> 
<tr><td><code id="GeoSimCopula_+3A_grid">grid</code></td>
<td>
<p>Logical; if <code>FALSE</code> (the default) the data
are interpreted as spatial or spatial-temporal realisations on a set
of non-equispaced spatial sites (irregular grid).</p>
</td></tr>
<tr><td><code id="GeoSimCopula_+3A_local">local</code></td>
<td>
<p>Numeric; number of local work-items of the GPU</p>
</td></tr>
<tr><td><code id="GeoSimCopula_+3A_method">method</code></td>
<td>
<p>String; the type of matrix decomposition used in the simulation. Default is cholesky. The other possible choices is <code>svd</code>.</p>
</td></tr> 
<tr><td><code id="GeoSimCopula_+3A_model">model</code></td>
<td>
<p>String; the type of RF and therefore the densities associated to the likelihood
objects. <code>Gaussian</code> is the default, see the Section
<b>Details</b>.</p>
</td></tr>
<tr><td><code id="GeoSimCopula_+3A_n">n</code></td>
<td>
<p>Numeric; the number of trials for binomial RFs. The number of successes in the negative Binomial RFs. Default is <code class="reqn">1</code>.</p>
</td></tr> 
<tr><td><code id="GeoSimCopula_+3A_param">param</code></td>
<td>
<p>A list of parameter values required in the
simulation procedure of RFs, see <b>Examples</b>.</p>
</td></tr>
<tr><td><code id="GeoSimCopula_+3A_anisopars">anisopars</code></td>
<td>
<p> A list of two elements &quot;angle&quot; and &quot;ratio&quot; i.e. the anisotropy angle and the anisotropy ratio, respectively.</p>
</td></tr>
<tr><td><code id="GeoSimCopula_+3A_radius">radius</code></td>
<td>
<p>Numeric; a value indicating  the radius of the sphere when using the great 
circle distance. Default value is the radius of the earth in Km (i.e. 6371)</p>
</td></tr>  
<tr><td><code id="GeoSimCopula_+3A_sparse">sparse</code></td>
<td>
<p>Logical; if <code>TRUE</code> then  cholesky decomposition is performed
using sparse matrices algorithms (spam packake). It should be used
with compactly supported covariance models.<code>FALSE</code> is the default.</p>
</td></tr>
<tr><td><code id="GeoSimCopula_+3A_copula">copula</code></td>
<td>
<p>String; the type of copula. It can be &quot;Clayton&quot; or &quot;Gaussian&quot;</p>
</td></tr>
<tr><td><code id="GeoSimCopula_+3A_seed">seed</code></td>
<td>
<p>Numeric; an integer used in set.seed function to reproduce the simulation.</p>
</td></tr>
<tr><td><code id="GeoSimCopula_+3A_x">X</code></td>
<td>
<p>Numeric; Matrix of space-time covariates.</p>
</td></tr>
<tr><td><code id="GeoSimCopula_+3A_spobj">spobj</code></td>
<td>
<p>An object of class sp or spacetime</p>
</td></tr>
<tr><td><code id="GeoSimCopula_+3A_nrep">nrep</code></td>
<td>
<p>Numeric; Numbers of indipendent replicates.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an object of class <code>GeoSimCopula</code>.
An object of class <code>GeoSimCopula</code> is a list containing
at most the following components:
</p>
<table>
<tr><td><code>bivariate</code></td>
<td>
<p>Logical:<code>TRUE</code> if the Gaussian RF is bivariate, otherwise  <code>FALSE</code>;</p>
</td></tr>
<tr><td><code>coordx</code></td>
<td>
<p>A <code class="reqn">d</code>-dimensional vector of spatial coordinates;</p>
</td></tr>
<tr><td><code>coordy</code></td>
<td>
<p>A <code class="reqn">d</code>-dimensional vector of spatial coordinates;</p>
</td></tr>
<tr><td><code>coordt</code></td>
<td>
<p>A <code class="reqn">t</code>-dimensional vector of temporal coordinates;</p>
</td></tr>
<tr><td><code>coordx_dyn</code></td>
<td>
<p>A  list of dynamical (in time) spatial coordinates;</p>
</td></tr>
<tr><td><code>corrmodel</code></td>
<td>
<p>The correlation model; see <code><a href="#topic+GeoCovmatrix">GeoCovmatrix</a></code>.</p>
</td></tr>
<tr><td><code>data</code></td>
<td>
<p>The vector or matrix or array of data, see
<code><a href="#topic+GeoFit">GeoFit</a></code>;</p>
</td></tr>
<tr><td><code>distance</code></td>
<td>
<p>The type of spatial distance;</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>The method of simulation</p>
</td></tr>
<tr><td><code>model</code></td>
<td>
<p>The type of RF, see <code><a href="#topic+GeoFit">GeoFit</a></code>.</p>
</td></tr>
<tr><td><code>n</code></td>
<td>
<p>The number of trial for Binomial RFs;the number of successes in a negative Binomial RFs;</p>
</td></tr> 
<tr><td><code>numcoord</code></td>
<td>
<p>The number of spatial coordinates;</p>
</td></tr>
<tr><td><code>numtime</code></td>
<td>
<p>The number the temporal realisations of the RF;</p>
</td></tr>
<tr><td><code>param</code></td>
<td>
<p>A list of the parameters</p>
</td></tr>
<tr><td><code>radius</code></td>
<td>
<p>The radius of the sphere if coordinates are passed in lon/lat format;</p>
</td></tr>
<tr><td><code>randseed</code></td>
<td>
<p>The seed used for the random simulation;</p>
</td></tr>
<tr><td><code>spacetime</code></td>
<td>
<p><code>TRUE</code> if spatio-temporal and <code>FALSE</code> if
spatial RF;</p>
</td></tr>
<tr><td><code>copula</code></td>
<td>
<p>The type of copula</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Moreno Bevilacqua, <a href="mailto:moreno.bevilacqua89@gmail.com">moreno.bevilacqua89@gmail.com</a>,<a href="https://sites.google.com/view/moreno-bevilacqua/home">https://sites.google.com/view/moreno-bevilacqua/home</a>,
Víctor Morales Oñate, <a href="mailto:victor.morales@uv.cl">victor.morales@uv.cl</a>, <a href="https://sites.google.com/site/moralesonatevictor/">https://sites.google.com/site/moralesonatevictor/</a>,
Christian&quot;, Caamaño-Carrillo, <a href="mailto:chcaaman@ubiobio.cl">chcaaman@ubiobio.cl</a>,<a href="https://www.researchgate.net/profile/Christian-Caamano">https://www.researchgate.net/profile/Christian-Caamano</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(GeoModels)

################################################################
###
### Example q. Simulation of a reparametrized Beta RF
### for beta regression
### with Gaussian and Clayton Copula 
### with  underlying Wendland correlation.
###
###############################################################
set.seed(261)
NN=1400
x &lt;- runif(NN);y &lt;- runif(NN)
coords=cbind(x,y)

shape1=3
shape2=3
smooth=0


corrmodel="GenWend"
min=0;max=1


X=cbind(rep(1,NN),runif(NN))

NuisParam("Beta2",num_betas=2,copula="Gaussian")
CorrParam("GenWend")


#### Gaussian copula
param=list(smooth=smooth,power2=4, min=min,max=max,
             mean=0.1,mean1=0.1,scale=0.3,nugget=0,shape=5)

data &lt;- GeoSimCopula(coordx=coords, corrmodel=corrmodel, model="Beta2",param=param,
  copula="Gaussian",sparse=TRUE,X=X)$data

quilt.plot(coords,data)


#### Clayton copula
NuisParam("Beta2",num_betas=2,copula="Clayton")
CorrParam("GenWend")
param=list(smooth=smooth,power2=4, min=min,max=max,
             mean=0.2,mean1=0.1,scale=0.3,nugget=0,shape=6,nu=4)
data1 &lt;- GeoSimCopula(coordx=coords, corrmodel=corrmodel, model="Beta2",param=param,
  copula="Clayton",sparse=TRUE,X=X)$data

hist(data1,freq=FALSE)
quilt.plot(coords,data1)

</code></pre>

<hr>
<h2 id='GeoTests'>Statistical Hypothesis Tests for Nested Models</h2><span id='topic+GeoTests'></span>

<h3>Description</h3>

<p>The function performs statistical hypothesis tests for nested models
based on composite or standard likelihood versions of Wald-type and
Wilks-type (likelihood ratio) statistics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GeoTests(object1, object2, ..., statistic)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GeoTests_+3A_object1">object1</code></td>
<td>
<p>An object of class <code>GeoFit</code>.</p>
</td></tr>
<tr><td><code id="GeoTests_+3A_object2">object2</code></td>
<td>
<p>An object of class <code>GeoFit</code> that is a nested
model within <code>object1</code>.</p>
</td></tr>
<tr><td><code id="GeoTests_+3A_...">...</code></td>
<td>
<p>Further successively nested objects.</p>
</td></tr>
<tr><td><code id="GeoTests_+3A_statistic">statistic</code></td>
<td>
<p>String; the name of the statistic used within the
hypothesis test (see <b>Details</b>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The implemented hypothesis tests for nested models are based on the
following statistics:
</p>

<ol>
<li><p> Wald-type (<code>Wald</code>);
</p>
</li>
<li><p> Likelihood ratio or Wilks-type (<code>Wilks</code> under standard likelihood); 
For composite likelihood available variants of the basic version are:
</p>

<ul>
<li><p> Rotnitzky and Jewell adjustment (<code>WilksRJ</code>);
</p>
</li>
<li><p> Satterhwaite adjustment (<code>WilksS</code>);
</p>
</li>
<li><p> Chandler and Bate adjustment (<code>WilksCB</code>);
</p>
</li>
<li><p> Pace, Salvan and Sartori adjustment (<code>WilksPSS</code>);
</p>
</li></ul>

</li></ol>

<p>More specifically,
consider an <code class="reqn">p</code>-dimensional random vector <code class="reqn">\mathbf{Y}</code> with
probability density function <code class="reqn">f(\mathbf{y};\mathbf{\theta})</code>,
where <code class="reqn">\mathbf{\theta} \in \Theta</code> is a
<code class="reqn">q</code>-dimensional vector of parameters. Suppose that
<code class="reqn">\mathbf{\theta}=(\mathbf{\psi},\mathbf{\tau})</code>
can be partitioned in a <code class="reqn">q'</code>-dimensional subvector <code class="reqn">\psi</code>
and <code class="reqn">q''</code>-dimensional subvector <code class="reqn">\tau</code>. Assume also to be
interested in testing the specific values of the vector
<code class="reqn">\psi</code>. Then, one can use some statistical
hypothesis tests for testing the null hypothesis <code class="reqn">H_0:
 \psi=\psi_0</code> against the alternative <code class="reqn">H_1:
 \psi \neq \psi_0</code>. Composite likelihood versions
of 'Wald' and 'score' statistics have the usual asymptotic
chi-square distribution with <code class="reqn">q'</code> degree of freedom. The Wald-type statistic is
</p>
<p style="text-align: center;"><code class="reqn">W=(\hat{\psi}-\psi_0)^T (G^{\psi \psi})^{-1}(\hat{\theta})(\hat{\psi}-\psi_0),</code>
</p>

<p>where <code class="reqn">G_{\psi \psi}</code> is the <code class="reqn">q' \times q'</code>
submatrix of the Godambe or Fisher information pertaining to <code class="reqn">\psi</code> and
<code class="reqn">\hat{\theta}</code> is the maximum likelihood estimator from
the full model. 
This statistic can be called from the
routine <code>GeoTests</code> assigning at the argument <code>statistic</code>
the value: <code>Wald</code>.
</p>
<p>Alternatively to the Wald-type  statistic one can use the
composite version of the Wilks-type or likelihood ratio statistic, given by
</p>
<p style="text-align: center;"><code class="reqn">W=2[C \ell(\hat{\mathbf{\theta}};\mathbf{y}) - C \ell\{\mathbf{\psi}_0,
   \hat{\mathbf{\tau}}(\mathbf{\psi}_0);\mathbf{y}\}].</code>
</p>

<p>In the composite likelihood case, the asymptotic distribution of the composite 
likelihood ratio statistic is given by
</p>
<p style="text-align: center;"><code class="reqn">W \dot{\sim} \sum_{i} \lambda_i \chi^2,</code>
</p>

<p>for <code class="reqn">i=1,\ldots,q'</code>, where <code class="reqn">\chi^2_i</code> are
<code class="reqn">q'</code> iid copies of a chi-square one random variable and
<code class="reqn">\lambda_1,\ldots,\lambda_{q'}</code>
are the eigenvalues of the matrix <code class="reqn">(H^{\psi \psi})^{-1} G^{\psi
 \psi}</code>. There exist several adjustments
to the composite likelihood ratio statistic in order to get an
approximated <code class="reqn">\chi^2_{q'}</code>. For example, Rotnitzky and Jewell
(1990) proposed the adjustment <code class="reqn">W'= W / \bar{\lambda}</code> where <code class="reqn">\bar{\lambda}</code> is the average
of the eigenvalues <code class="reqn">\lambda_i</code>. This statistic can be
called within the routine by the value: <code>WilksRJ</code>. A better
solution is proposed by Satterhwaite (1946) defining <code class="reqn">W''=\nu W /
 (q' \bar{\lambda})</code>, where <code class="reqn">\nu=(\sum_i
 \lambda)^2 / \sum_i \lambda^2_i</code> for
<code class="reqn">i=1\ldots,q'</code>, is the effective number of the degree of
freedom. Note that in this case the distribution of the likelihood ratio
statistic is a chi-square random variable with <code class="reqn">\nu</code> degree of
freedom. This statistic can be called from the routine assigning the
value: <code>WilksS</code>. For the adjustments suggested by Chandler and
Bate (2007) and Pace, Salvan and Sartori (2011) we refere to the articles (see
<b>References</b>), these versions can be called from the routine assigning
respectively the values: <code>WilksCB</code> and <code>WilksPSS</code>.
</p>


<h3>Value</h3>

<p>An object of class <code>c("data.frame")</code>. The object contain a table
with the results of the tested models. The rows represent the
responses for each model and the columns the following results:
</p>
<table>
<tr><td><code>Num.Par</code></td>
<td>
<p>The number of the model's parameters.</p>
</td></tr>
<tr><td><code>Diff.Par</code></td>
<td>
<p>The difference between the number of parameters of the model in the previous row
and those in the actual row.</p>
</td></tr>
<tr><td><code>Df</code></td>
<td>
<p>The effective number of degree of freedom of the chi-square distribution.</p>
</td></tr>
<tr><td><code>Chisq</code></td>
<td>
<p>The observed value of the statistic.</p>
</td></tr>
<tr><td><code>Pr(&gt;chisq)</code></td>
<td>
<p>The p-value of the quantile
<code>Chisq</code> computed using a chi-squared distribution with <code>Df</code> degrees
of freedom.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Moreno Bevilacqua, <a href="mailto:moreno.bevilacqua89@gmail.com">moreno.bevilacqua89@gmail.com</a>,<a href="https://sites.google.com/view/moreno-bevilacqua/home">https://sites.google.com/view/moreno-bevilacqua/home</a>,
Víctor Morales Oñate, <a href="mailto:victor.morales@uv.cl">victor.morales@uv.cl</a>, <a href="https://sites.google.com/site/moralesonatevictor/">https://sites.google.com/site/moralesonatevictor/</a>,
Christian&quot;, Caamaño-Carrillo, <a href="mailto:chcaaman@ubiobio.cl">chcaaman@ubiobio.cl</a>,<a href="https://www.researchgate.net/profile/Christian-Caamano">https://www.researchgate.net/profile/Christian-Caamano</a>
</p>


<h3>References</h3>

<p>Chandler, R. E., and Bate, S. (2007). Inference for Clustered Data Using the
Independence log-likelihood. <em>Biometrika</em>, <b>94</b>, 167&ndash;183.
</p>
<p>Pace, L., Salvan, A. and Sartori, N. (2011). Adjusting Composite
Likelihood Ratio Statistics. <em>Statistica Sinica</em>, <b>21</b>, 129&ndash;148.
</p>
<p>Rotnitzky, A. and Jewell, N. P. (1990). Hypothesis Testing of Regression
Parameters in Semiparametric Generalized Linear Models for Cluster
Correlated Data. <em>Biometrika</em>, <b>77</b>, 485&ndash;497.
</p>
<p>Satterthwaite, F. E. (1946). An Approximate Distribution of Estimates of
Variance Components. <em>Biometrics Bulletin</em>, <b>2</b>, 110&ndash;114.
</p>
<p>Varin, C., Reid, N. and Firth, D. (2011). An Overview of Composite
Likelihood Methods. <em>Statistica Sinica</em>, <b>21</b>, 5&ndash;42.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+GeoFit">GeoFit</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

library(GeoModels)

################################################################
###
### Example 1. Test on the parameter
### of a regression model using standard likelihood
###
###############################################################
set.seed(342)
model="Gaussian" 
# Define the spatial-coordinates of the points:
NN=150
x = runif(NN, 0, 1)
y = runif(NN, 0, 1)
coords = cbind(x,y)
# Parameters
mean=1; mean1=-1.25;  # regression parameters
nugget=0; sill=1

# matrix covariates
X=cbind(rep(1,nrow(coords)),runif(nrow(coords)))

# model correlation 
corrmodel="Wend0"
power2=4;c_supp=0.2

# simulation
param=list(power2=power2,mean=mean,mean1=mean1,
              sill=sill,scale=c_supp,nugget=nugget)
data = GeoSim(coordx=coords, corrmodel=corrmodel,model=model, param=param,X=X)$data

I=Inf
##### H1: (regressian mean)
fixed=list(nugget=nugget,power2=power2)
start=list(mean=mean,mean1=mean1,scale=c_supp,sill=sill)

lower=list(mean=-I,mean1=-I,scale=0,sill=0)
upper=list(mean=I,mean1=I,scale=I,sill=I)
# Maximum pairwise composite-likelihood fitting of the RF:
fitH1 = GeoFit(data=data,coordx=coords,corrmodel=corrmodel, model=model,
                   likelihood="Full",type="Standard",varest=TRUE,
                   lower=lower,upper=upper,
                   optimizer="nlminb",X=X,
                    start=start,fixed=fixed)

unlist(fitH1$param)

##### H0: (constant mean i.e beta1=0)
fixed=list(power2=power2,nugget=nugget,mean1=0)
start=list(mean=mean,scale=c_supp,sill=sill)
lower=list(mean=-I,scale=0,sill=0)
upper=list(mean=I,scale=I,sill=I)
# Maximum pairwise composite-likelihood fitting of the RF:
fitH0 = GeoFit(data=data,coordx=coords,corrmodel=corrmodel, model=model,
                    likelihood="Full",type="Standard",varest=TRUE,
                      lower=lower,upper=upper,
                   optimizer="nlminb",X=X,
                    start=start,fixed=fixed)


#  Wald statistic and likelihood ratio statistic test
#  rejecting null  hypothesis beta1=0
GeoTests(fitH1, fitH0 ,statistic='Wald')
GeoTests(fitH1, fitH0 , statistic='Wilks')



################################################################
###
### Example 2. Parametric test of Gaussianity
### using SinhAsinh random fields using standard likelihood
###
###############################################################
set.seed(34)
model="SinhAsinh" 
# Define the spatial-coordinates of the points:
NN=150
x = runif(NN, 0, 1)
y = runif(NN, 0, 1)
coords = cbind(x,y)
# Parameters
mean=0; nugget=0; sill=1
### skew and tail parameters
skew=0.6;tail=1.7   ## H0 is Gaussianity
# underlying model correlation 
corrmodel="Wend0"
power2=4;c_supp=0.2

# simulation
param=list(power2=power2,skew=skew,tail=tail,
             mean=mean,sill=sill,scale=c_supp,nugget=nugget)
data = GeoSim(coordx=coords, corrmodel=corrmodel,model=model, param=param)$data


##### H1: SinhAsinh model
fixed=list(power2=power2,nugget=nugget,mean=mean)
start=list(scale=c_supp,skew=skew,tail=tail,sill=sill)

lower=list(scale=0,skew=-1 ,tail=0.5,sill=0)
upper=list(scale=2,skew=1,tail=1.5,sill=5)
# Maximum pairwise composite-likelihood fitting of the RF:
fitH1 = GeoFit(data=data,coordx=coords,corrmodel=corrmodel, model=model,
                   likelihood="Full",type="Standard",varest=TRUE,
                   lower=lower,upper=upper,
                   optimizer="nlminb",
                    start=start,fixed=fixed)

unlist(fitH1$param)

##### H0: Gaussianity (i.e tail1=1, skew=0 fixed)
fixed=list(power2=power2,nugget=nugget,mean=mean,tail=1,skew=0)
start=list(scale=c_supp,sill=sill)
lower=list(scale=0,sill=0)
upper=list(scale=2,sill=5)
# Maximum pairwise composite-likelihood fitting of the RF:
fitH0 = GeoFit(data=data,coordx=coords,corrmodel=corrmodel, model=model,
                    likelihood="Full",type="Standard",varest=TRUE,
                      lower=lower,upper=upper,
                   optimizer="nlminb",
                    start=start,fixed=fixed)

#  Wald statistic and likelihood ratio statistic test
#  rejecting null  hypothesis tail=1,skew=0
GeoTests(fitH1, fitH0,statistic='Wald')
GeoTests(fitH1, fitH0,statistic='Wilks')

</code></pre>

<hr>
<h2 id='GeoVarestbootstrap'>Update a <code>GeoFit</code> object   using parametric bootstrap for std error estimation</h2><span id='topic+GeoVarestbootstrap'></span>

<h3>Description</h3>

<p>The procedure update a <code>GeoFit</code> object  estimating stderr estimation using parametric bootstrap.</p>


<h3>Usage</h3>

<pre><code class='language-R'>GeoVarestbootstrap(fit,K=100,sparse=FALSE,
GPU=NULL,local=c(1,1),optimizer="Nelder-Mead",
                     lower=NULL, upper=NULL, 
                     method="cholesky",alpha=0.95, M=30,L=500)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GeoVarestbootstrap_+3A_fit">fit</code></td>
<td>
<p>A fitted object obtained from the
<code><a href="#topic+GeoFit">GeoFit</a></code>.</p>
</td></tr>
<tr><td><code id="GeoVarestbootstrap_+3A_k">K</code></td>
<td>
<p>The number of simulations in the parametric bootstrap.</p>
</td></tr>
<tr><td><code id="GeoVarestbootstrap_+3A_sparse">sparse</code></td>
<td>
<p>Logical; if <code>TRUE</code> then  cholesky decomposition is performed
using sparse matrices algorithms (spam packake).</p>
</td></tr>
<tr><td><code id="GeoVarestbootstrap_+3A_gpu">GPU</code></td>
<td>
<p>Numeric; if <code>NULL</code> (the default) 
no OpenCL computation is performed. The user can choose the device to be used. Use <code>DeviceInfo()</code> function to see available devices, only double precision devices are allowed</p>
</td></tr> 
<tr><td><code id="GeoVarestbootstrap_+3A_local">local</code></td>
<td>
<p>Numeric; number of local work-items of the OpenCL setup</p>
</td></tr>
<tr><td><code id="GeoVarestbootstrap_+3A_optimizer">optimizer</code></td>
<td>
<p>The type of optimization algorithm. See  <code><a href="#topic+GeoFit">GeoFit</a></code> for details.</p>
</td></tr>
<tr><td><code id="GeoVarestbootstrap_+3A_lower">lower</code></td>
<td>
<p>An optional named list giving the values  for the lower bound of the space parameter
when the optimizer is  <code>L-BFGS-B</code> or <code>nlminb</code>  or <code>optimize</code>.</p>
</td></tr>
<tr><td><code id="GeoVarestbootstrap_+3A_upper">upper</code></td>
<td>
<p>An optional named list giving the values  for the upper bound of the space parameter
when the optimizer is  <code>L-BFGS-B</code> or <code>nlminb</code>  or <code>optimize</code>.</p>
</td></tr>
<tr><td><code id="GeoVarestbootstrap_+3A_method">method</code></td>
<td>
<p>String; The method of simulation. Default is <code>cholesky</code>. For large data set two options are <code>Vecchia</code> or <code>TB</code></p>
</td></tr>
<tr><td><code id="GeoVarestbootstrap_+3A_alpha">alpha</code></td>
<td>
<p> Numeric; The level of the confidence interval. </p>
</td></tr>
<tr><td><code id="GeoVarestbootstrap_+3A_m">M</code></td>
<td>
<p>Numeric; the number of neighboords in the Vecchia method.</p>
</td></tr> 
<tr><td><code id="GeoVarestbootstrap_+3A_l">L</code></td>
<td>
<p>Numeric; the number of lines in the  turning band method.</p>
</td></tr> 
</table>


<h3>Details</h3>

<p> The function update a <code>GeoFit</code> object  estimating stderr estimation 
and confidence interval using parametric bootstrap.</p>


<h3>Value</h3>

  
<p>Returns an (updated) object of class <code>GeoFit</code>.
</p>


<h3>Author(s)</h3>

<p>Moreno Bevilacqua, <a href="mailto:moreno.bevilacqua89@gmail.com">moreno.bevilacqua89@gmail.com</a>,<a href="https://sites.google.com/view/moreno-bevilacqua/home">https://sites.google.com/view/moreno-bevilacqua/home</a>,
Víctor Morales Oñate, <a href="mailto:victor.morales@uv.cl">victor.morales@uv.cl</a>, <a href="https://sites.google.com/site/moralesonatevictor/">https://sites.google.com/site/moralesonatevictor/</a>,
Christian&quot;, Caamaño-Carrillo, <a href="mailto:chcaaman@ubiobio.cl">chcaaman@ubiobio.cl</a>,<a href="https://www.researchgate.net/profile/Christian-Caamano">https://www.researchgate.net/profile/Christian-Caamano</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+GeoFit">GeoFit</a></code>.</p>

<hr>
<h2 id='GeoVariogram'>Empirical semi-variogram estimation</h2><span id='topic+GeoVariogram'></span>

<h3>Description</h3>

<p>The function returns an empirical estimate of the  semi-variogram  for spatio (temporal)  and bivariate 
random fields. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GeoVariogram(data, coordx, coordy=NULL, coordt=NULL, 
coordx_dyn=NULL,cloud=FALSE, distance="Eucl",
              grid=FALSE, maxdist=NULL,neighb=NULL,
              maxtime=NULL, memdist=FALSE,numbins=NULL, 
              radius=6371, type='variogram',bivariate=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GeoVariogram_+3A_data">data</code></td>
<td>
<p>A <code class="reqn">d</code>-dimensional vector (a single spatial realisation) or a (<code class="reqn">n \times d</code>)-matrix
(<code class="reqn">n</code> iid spatial realisations) or a (<code class="reqn">d \times d</code>)-matrix (a single spatial realisation on regular grid)
or an (<code class="reqn">d \times d \times n</code>)-array (<code class="reqn">n</code> iid spatial realisations on regular grid) or a
(<code class="reqn">t \times d</code>)-matrix (a single spatial-temporal realisation) or an (<code class="reqn">t \times d \times n </code>)-array
(<code class="reqn">n</code> iid spatial-temporal realisations) or or an (<code class="reqn">d \times d \times t \times n </code>)-array
(a single spatial-temporal realisation on regular grid) or an (<code class="reqn">d \times d \times t \times n </code>)-array
(<code class="reqn">n</code> iid spatial-temporal realisations on regular grid). See <code><a href="#topic+GeoFit">GeoFit</a></code> for details.</p>
</td></tr>
<tr><td><code id="GeoVariogram_+3A_coordx">coordx</code></td>
<td>
<p>A numeric (<code class="reqn">d \times 2</code>)-matrix (where
<code>d</code> is the number of spatial sites) assigning 2-dimensions of spatial coordinates or a numeric <code class="reqn">d</code>-dimensional vector assigning
1-dimension of spatial coordinates.  Coordinates on a sphere for a  fixed radius <code>radius</code> 
are passed in lon/lat format expressed in decimal degrees.</p>
</td></tr>
<tr><td><code id="GeoVariogram_+3A_coordy">coordy</code></td>
<td>
<p>A numeric vector assigning 1-dimension of
spatial coordinates; <code>coordy</code> is interpreted only if <code>coordx</code> is a numeric
vector or <code>grid=TRUE</code> otherwise it will be ignored. Optional argument, the default is <code>NULL</code> then <code>coordx</code> is expected to
be numeric a (<code class="reqn">d \times 2</code>)-matrix.</p>
</td></tr>
<tr><td><code id="GeoVariogram_+3A_coordt">coordt</code></td>
<td>
<p>A numeric vector assigning 1-dimension of
temporal coordinates. Optional argument, the default is <code>NULL</code> then a spatial random field is expected.</p>
</td></tr>
<tr><td><code id="GeoVariogram_+3A_coordx_dyn">coordx_dyn</code></td>
<td>
<p>A list of <code class="reqn">m</code> numeric (<code class="reqn">d_t \times 2</code>)-matrices
containing dynamical (in time) spatial coordinates. Optional argument, the default is <code>NULL</code>
</p>
</td></tr>   
<tr><td><code id="GeoVariogram_+3A_cloud">cloud</code></td>
<td>
<p>Logical; if <code>TRUE</code> the semivariogram cloud is computed,
otherwise if <code>FALSE</code> (the default) the empirical (binned)
semivariogram is returned.</p>
</td></tr>
<tr><td><code id="GeoVariogram_+3A_distance">distance</code></td>
<td>
<p>String; the name of the spatial distance. The default
is <code>Eucl</code>, the euclidean distance. See the Section
<b>Details</b> of <code><a href="#topic+GeoFit">GeoFit</a></code>.</p>
</td></tr>
<tr><td><code id="GeoVariogram_+3A_grid">grid</code></td>
<td>
<p>Logical; if <code>FALSE</code> (the default) the data
are interpreted as spatial or spatial-temporal realisations on a set of 
non-equispaced spatial sites.</p>
</td></tr>
<tr><td><code id="GeoVariogram_+3A_maxdist">maxdist</code></td>
<td>
<p>A numeric value denoting the spatial maximum distance,
see the Section <b>Details</b>.</p>
</td></tr>
<tr><td><code id="GeoVariogram_+3A_memdist">memdist</code></td>
<td>
<p> Logical; if <code>FALSE</code> then  all  the distances are computed during the semivariogram computation. If <code>TRUE</code> then the nabor package is used to find the distances specificing a <code>maxdist</code> and a <code>neighb</code>. The second option can be useful for large datasets</p>
</td></tr>
<tr><td><code id="GeoVariogram_+3A_neighb">neighb</code></td>
<td>
<p>Numeric; an optional positive integer indicating the 
order of neighborhood. See the Section <b>Details</b> for more information.</p>
</td></tr>
<tr><td><code id="GeoVariogram_+3A_maxtime">maxtime</code></td>
<td>
<p>A numeric value denoting the temporal maximum distance,
see the Section <b>Details</b>.</p>
</td></tr>
<tr><td><code id="GeoVariogram_+3A_numbins">numbins</code></td>
<td>
<p>A numeric value denoting the numbers of bins, see the
Section <b>Details</b>.</p>
</td></tr>
<tr><td><code id="GeoVariogram_+3A_radius">radius</code></td>
<td>
<p>Numeric; a value indicating  the radius of the sphere when 
using the great circle distance. Default value is the radius of the earth in Km (i.e. 6371)</p>
</td></tr> 
<tr><td><code id="GeoVariogram_+3A_type">type</code></td>
<td>
<p>A String denoting the type of semivariogram. The option
available is : <code>variogram</code>.</p>
</td></tr>
<tr><td><code id="GeoVariogram_+3A_bivariate">bivariate</code></td>
<td>
<p>Logical; if <code>FALSE</code> (the default) the data
are interpreted as univariate spatial or spatial-temporal realisations. 
Otherwise they are intrepreted as a a realization from a bivariate field.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>We briefly report the definitions of semi-variogram used for the spatial case. It can be easily extended 
to the space-time or spatial bivariate case.
In the case of a spatial Gaussian random field
the sample semivariogram estimator is defined by
</p>
<p style="text-align: center;"><code class="reqn">\hat{\gamma}(h) = 0.5 \sum_{x_i, x_j \in N(h)} (Z(x_i) - Z(x_j))^2 / |N(h)|</code>
</p>

<p>where <code class="reqn">N(h)</code> is the set of all the sample pairs whose distances fall into a tolerance region with size <code class="reqn">h</code>
(equispaced intervalls are considered).
</p>
<p>The  <code>numbins</code> parameter indicates the number of adjacent
intervals to consider in order to grouped distances with which to
compute the (weighted) lest squares.
</p>
<p>The <code>maxdist</code> parameter indicates the maximum spatial distance below which
the shorter distances will be considered in the calculation of
the semivariogram.
</p>
<p>The <code>maxdist</code> parameter can be coupled with the <code>neighb</code> parameter (setting <code>memdist=T</code>). This is useful when handling large dataset.
</p>
<p>The <code>maxtime</code> parameter indicates the maximum temporal distance below which
the shorter distances will be considered in the calculation of
the spatio-temoral semivariogram.
</p>


<h3>Value</h3>

<p>Returns an object of class <code>Variogram</code>.
An object of class <code>Variogram</code> is a list containing
at most the following components:
</p>
<table>
<tr><td><code>bins</code></td>
<td>
<p>Adjacent intervals of grouped spatial distances if
<code>cloud=FALSE</code>. Otherwise if <code>cloud=TRUE</code> all the spatial pairwise distances;</p>
</td></tr>
<tr><td><code>bint</code></td>
<td>
<p>Adjacent intervals of grouped temporal distances if
<code>cloud=FALSE</code>. Otherwise if <code>cloud=TRUE</code> all the temporal pairwise distances;</p>
</td></tr>
<tr><td><code>cloud</code></td>
<td>
<p>If the variogram cloud is returned (<code>TRUE</code>) or the
empirical variogram (<code>FALSE</code>);</p>
</td></tr>
<tr><td><code>centers</code></td>
<td>
<p>The centers of the spatial bins;</p>
</td></tr>
<tr><td><code>distance</code></td>
<td>
<p>The type of spatial distance;</p>
</td></tr>
<tr><td><code>lenbins</code></td>
<td>
<p>The number of pairs in each spatial bin;</p>
</td></tr>
<tr><td><code>lenbinst</code></td>
<td>
<p>The number of pairs in each spatial-temporal bin;</p>
</td></tr>
<tr><td><code>lenbint</code></td>
<td>
<p>The number of pairs in each temporal bin;</p>
</td></tr>
<tr><td><code>maxdist</code></td>
<td>
<p>The maximum spatial distance used for the calculation of the variogram.
If no spatial distance is specified then it is NULL;</p>
</td></tr>
<tr><td><code>maxtime</code></td>
<td>
<p>The maximum temporal distance used for the calculation of the variogram.
If no temporal distance is specified then it is NULL;</p>
</td></tr>
<tr><td><code>spacetime_dyn</code></td>
<td>
<p>If the space-time variogram is obtained using dynamical coordinates
then it is(<code>TRUE</code>).   </p>
</td></tr>
<tr><td><code>variograms</code></td>
<td>
<p>The empirical spatial variogram;</p>
</td></tr>
<tr><td><code>variogramst</code></td>
<td>
<p>The empirical spatial-temporal variogram;</p>
</td></tr>
<tr><td><code>variogramt</code></td>
<td>
<p>The empirical temporal variogram;</p>
</td></tr>
<tr><td><code>type</code></td>
<td>
<p>The type of estimated variogram</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Moreno Bevilacqua, <a href="mailto:moreno.bevilacqua89@gmail.com">moreno.bevilacqua89@gmail.com</a>,<a href="https://sites.google.com/view/moreno-bevilacqua/home">https://sites.google.com/view/moreno-bevilacqua/home</a>,
Víctor Morales Oñate, <a href="mailto:victor.morales@uv.cl">victor.morales@uv.cl</a>, <a href="https://sites.google.com/site/moralesonatevictor/">https://sites.google.com/site/moralesonatevictor/</a>,
Christian&quot;, Caamaño-Carrillo, <a href="mailto:chcaaman@ubiobio.cl">chcaaman@ubiobio.cl</a>,<a href="https://www.researchgate.net/profile/Christian-Caamano">https://www.researchgate.net/profile/Christian-Caamano</a>
</p>


<h3>References</h3>

<p>Cressie, N. A. C. (1993) <em>Statistics for Spatial Data</em>. New York: Wiley.
</p>
<p>Gaetan, C. and Guyon, X. (2010) <em>Spatial Statistics and Modelling</em>.
Spring Verlang, New York.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+GeoFit">GeoFit</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>library(GeoModels)

################################################################
###
### Example 1. Empirical estimation of the semi-variogram from a
### spatial Gaussian random field with exponential correlation.
###
###############################################################
set.seed(514)
# Set the coordinates of the sites:
x = runif(200, 0, 1)
y = runif(200, 0, 1)
coords = cbind(x,y)
# Set the model's parameters:
corrmodel = "Exponential"
mean = 0
sill = 1
nugget = 0
scale = 0.3/3

# Simulation of the spatial Gaussian random field:
data = GeoSim(coordx=coords, corrmodel=corrmodel, param=list(mean=mean,
              sill=sill, nugget=nugget, scale=scale))$data

# Empirical spatial semi-variogram estimation:
vario = GeoVariogram(coordx=coords,data=data,maxdist=0.6)

plot(vario,pch=20,ylim=c(0,1),ylab="Semivariogram",xlab="Distance")


################################################################
###
### Example 2. Empirical estimation of the variogram from a
### spatio-temporal Gaussian random fields with Gneiting
### correlation function.
###
###############################################################

set.seed(331)
# Define the temporal sequence:
# Set the coordinates of the sites:
x = runif(200, 0, 1)
y = runif(200, 0, 1)
coords = cbind(x,y)
times = seq(1,10,1)

# Simulation of a spatio-temporal Gaussian random field:
data = GeoSim(coordx=coords, coordt=times, corrmodel="gneiting",
              param=list(mean=0,scale_s=0.08,scale_t=0.4,sill=1,
              nugget=0,power_s=1,power_t=1,sep=0.5))$data

# Empirical spatio-temporal semi-variogram estimation:
vario_st = GeoVariogram(data=data, coordx=coords, coordt=times, maxtime=7,maxdist=0.5)

plot(vario_st)
      
################################################################
###
### Example 3. Empirical estimation of the (cross) semivariograms 
### from a bivariate Gaussian random fields with Matern
### correlation function.
###
###############################################################
# Simulation of a bivariate spatial Gaussian random field:
set.seed(293)
# Define the spatial-coordinates of the points:
x = runif(400, 0, 1)
y = runif(400, 0, 1)
coords=cbind(x,y)

# Simulation of a bivariate Gaussian Random field 
# with matern (cross)  covariance function
param=list(mean_1=0,mean_2=0,scale_1=0.1/3,scale_2=0.15/3,scale_12=0.15/3,
           sill_1=1,sill_2=1,nugget_1=0,nugget_2=0,
           smooth_1=0.5,smooth_12=0.5,smooth_2=0.5,pcol=0.3)  
data = GeoSim(coordx=coords, corrmodel="Bi_matern", param=param)$data

# Empirical  semi-(cross)variogram estimation:
biv_vario=GeoVariogram(data,coordx=coords, bivariate=TRUE,maxdist=c(0.5,0.5,0.5))  

plot(biv_vario,pch=20)
      
</code></pre>

<hr>
<h2 id='GeoWLS'>WLS of Random Fields</h2><span id='topic+GeoWLS'></span><span id='topic+print.GeoWLS'></span>

<h3>Description</h3>

<p>the function returns the parameters' estimates of a random field obtained by 
the weigthed least squares estimator.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GeoWLS(data, coordx, coordy=NULL, coordt=NULL, coordx_dyn=NULL, corrmodel, 
             distance="Eucl", fixed=NULL, grid=FALSE, maxdist=NULL,neighb=NULL,
             maxtime=NULL,  model='Gaussian', optimizer='Nelder-Mead',
             numbins=NULL, radius=6371, start=NULL, weighted=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GeoWLS_+3A_data">data</code></td>
<td>
<p>A <code class="reqn">d</code>-dimensional vector (a single spatial realisation)  or a (<code class="reqn">d \times d</code>)-matrix (a single spatial realisation on regular grid)
or an (<code class="reqn">d \times d \times n</code>)-array (<code class="reqn">n</code> iid spatial realisations on regular grid) or a
(<code class="reqn">t \times d</code>)-matrix (a single spatial-temporal realisation) or an (<code class="reqn">d \times d \times t \times n </code>)-array
(a single spatial-temporal realisation on regular grid). See <code><a href="#topic+GeoFit">GeoFit</a></code> for details.</p>
</td></tr>
<tr><td><code id="GeoWLS_+3A_coordx">coordx</code></td>
<td>
<p>A numeric (<code class="reqn">d \times 2</code>)-matrix (where
<code>d</code> is the number of spatial sites) giving 2-dimensions of spatial coordinates or a numeric <code class="reqn">d</code>-dimensional vector giving
1-dimension of spatial coordinates.</p>
</td></tr>
<tr><td><code id="GeoWLS_+3A_coordy">coordy</code></td>
<td>
<p>A numeric vector giving 1-dimension of
spatial coordinates; <code>coordy</code> is interpreted only if <code>coordx</code> is a numeric
vector or <code>grid=TRUE</code> otherwise it will be ignored. Optional argument, the default is <code>NULL</code> then <code>coordx</code> is expected to
be numeric a (<code class="reqn">d \times 2</code>)-matrix.</p>
</td></tr>
<tr><td><code id="GeoWLS_+3A_coordt">coordt</code></td>
<td>
<p>A numeric vector giving 1-dimension of
temporal coordinates. Optional argument, the default is <code>NULL</code> then a spatial random field is expected.</p>
</td></tr>
<tr><td><code id="GeoWLS_+3A_coordx_dyn">coordx_dyn</code></td>
<td>
<p>A list of <code class="reqn">m</code> numeric (<code class="reqn">d_t \times 2</code>)-matrices
containing dynamical (in time) spatial coordinates. Optional argument, the default is <code>NULL</code>
</p>
</td></tr>  
<tr><td><code id="GeoWLS_+3A_corrmodel">corrmodel</code></td>
<td>
<p>String; the name of a correlation model, for the
description (see <code><a href="#topic+GeoFit">GeoFit</a></code>).</p>
</td></tr>
<tr><td><code id="GeoWLS_+3A_distance">distance</code></td>
<td>
<p>String; the name of the spatial distance. The default is <code>Eucl</code>,
the euclidean distance. See the Section <b>Details</b>
of <code><a href="#topic+GeoFit">GeoFit</a></code>.</p>
</td></tr>
<tr><td><code id="GeoWLS_+3A_fixed">fixed</code></td>
<td>
<p>A named list giving the values of the parameters that
will be considered as known values. The listed parameters for a
given correlation function will be not estimated, i.e. if
<code>list(nugget=0)</code> the nugget effect is ignored.</p>
</td></tr>
<tr><td><code id="GeoWLS_+3A_grid">grid</code></td>
<td>
<p>Logical; if <code>FALSE</code> (the default) the data
are interpreted as a vector or a (<code class="reqn">n \times d</code>)-matrix,
instead if <code>TRUE</code> then (<code class="reqn">d \times d
      \times n</code>)-matrix is considered.</p>
</td></tr>
<tr><td><code id="GeoWLS_+3A_maxdist">maxdist</code></td>
<td>
<p>A numeric value denoting the maximum distance, see
<b>Details</b> in <code><a href="#topic+GeoFit">GeoFit</a></code>.</p>
</td></tr>
<tr><td><code id="GeoWLS_+3A_neighb">neighb</code></td>
<td>
<p>Numeric; an optional positive integer indicating the 
order of neighborhood. See <b>Details</b> and <code><a href="#topic+GeoFit">GeoFit</a></code></p>
</td></tr>
<tr><td><code id="GeoWLS_+3A_maxtime">maxtime</code></td>
<td>
<p>Numeric; an optional positive value indicating the maximum
temporal lag considered.See <b>Details</b> and <code><a href="#topic+GeoFit">GeoFit</a></code>.</p>
</td></tr>
<tr><td><code id="GeoWLS_+3A_model">model</code></td>
<td>
<p>String; the type of random field. <code>Gaussian</code> is the default, see
<code><a href="#topic+GeoFit">GeoFit</a></code> for the different types.</p>
</td></tr>
<tr><td><code id="GeoWLS_+3A_optimizer">optimizer</code></td>
<td>
<p>String; the optimization algorithm
(see <code><a href="stats.html#topic+optim">optim</a></code> for details). 'Nelder-Mead' is the
default.</p>
</td></tr>
<tr><td><code id="GeoWLS_+3A_numbins">numbins</code></td>
<td>
<p>A numeric value denoting the numbers of bins, see the
Section <b>Details</b></p>
</td></tr>
<tr><td><code id="GeoWLS_+3A_radius">radius</code></td>
<td>
<p>Numeric; a value indicating  the radius of the sphere when using the great circle distance.
Default value is the radius of the earth in Km (i.e. 6371)</p>
</td></tr> 
<tr><td><code id="GeoWLS_+3A_start">start</code></td>
<td>
<p>A named list with the initial values of the
parameters that are used by the numerical routines in maximization
procedure. <code>NULL</code> is the default (see <code><a href="#topic+GeoFit">GeoFit</a></code>).</p>
</td></tr>
<tr><td><code id="GeoWLS_+3A_weighted">weighted</code></td>
<td>
<p>Logical; if <code>TRUE</code> then the weighted least square
estimator is considered. If <code>FALSE</code> (the
default) then the classic least square is used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The  <code>numbins</code> parameter indicates the number of adjacent
intervals to consider in order to grouped distances with which to
compute the (weighted) lest squares.
</p>
<p>The <code>maxdist</code> parameter indicates the maximum distance below which
the shorter distances will be considered in the calculation of
the (weigthed) least squares.
</p>


<h3>Value</h3>

<p>Returns an object of class <code>WLS</code>.
An object of class <code>WLS</code> is a list containing
at most the following components:
</p>
<table>
<tr><td><code>bins</code></td>
<td>
<p>Adjacent intervals of grouped distances;</p>
</td></tr>
<tr><td><code>bint</code></td>
<td>
<p>Adjacent intervals of grouped temporal separations</p>
</td></tr>
<tr><td><code>centers</code></td>
<td>
<p>The centers of the bins;</p>
</td></tr>
<tr><td><code>coordx</code></td>
<td>
<p>The vector or matrix of spatial coordinates;</p>
</td></tr>
<tr><td><code>coordy</code></td>
<td>
<p>The vector of spatial coordinates;</p>
</td></tr>
<tr><td><code>coordt</code></td>
<td>
<p>The vector of temporal coordinates;</p>
</td></tr>
<tr><td><code>convergence</code></td>
<td>
<p>A string that denotes if convergence is reached;</p>
</td></tr>
<tr><td><code>corrmodel</code></td>
<td>
<p>The correlation model;</p>
</td></tr>
<tr><td><code>data</code></td>
<td>
<p>The vector or matrix of data;</p>
</td></tr>
<tr><td><code>distance</code></td>
<td>
<p>The type of spatial distance;</p>
</td></tr>
<tr><td><code>fixed</code></td>
<td>
<p>The vector of fixed parameters;</p>
</td></tr>
<tr><td><code>iterations</code></td>
<td>
<p>The number of iteration used by the numerical routine;</p>
</td></tr>
<tr><td><code>maxdist</code></td>
<td>
<p>The maximum spatial distance used for the calculation of the variogram used in least square estimation.
If no spatial distance is specified then it is NULL;</p>
</td></tr>
<tr><td><code>maxtime</code></td>
<td>
<p>The maximum temporal distance used for the calculation of the variogram used in least square estimation.
If no temporal distance is specified then it is NULL;</p>
</td></tr>
<tr><td><code>message</code></td>
<td>
<p>Extra message passed from the numerical routines;</p>
</td></tr>
<tr><td><code>model</code></td>
<td>
<p>The type of random fields;</p>
</td></tr>
<tr><td><code>numcoord</code></td>
<td>
<p>The number of spatial coordinates;</p>
</td></tr>
<tr><td><code>numtime</code></td>
<td>
<p>The number the temporal realisations of the random field;</p>
</td></tr>
<tr><td><code>param</code></td>
<td>
<p>The vector of  parameters' estimates;</p>
</td></tr>
<tr><td><code>variograms</code></td>
<td>
<p>The empirical spatial variogram;</p>
</td></tr>
<tr><td><code>variogramt</code></td>
<td>
<p>The empirical temporal variogram;</p>
</td></tr>
<tr><td><code>variogramst</code></td>
<td>
<p>The empirical spatial-temporal variogram;</p>
</td></tr>
<tr><td><code>weighted</code></td>
<td>
<p>A logical value indicating if its the weighted
method;</p>
</td></tr>
<tr><td><code>wls</code></td>
<td>
<p>The value of the least squares at the minimum.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Moreno Bevilacqua, <a href="mailto:moreno.bevilacqua89@gmail.com">moreno.bevilacqua89@gmail.com</a>,<a href="https://sites.google.com/view/moreno-bevilacqua/home">https://sites.google.com/view/moreno-bevilacqua/home</a>,
Víctor Morales Oñate, <a href="mailto:victor.morales@uv.cl">victor.morales@uv.cl</a>, <a href="https://sites.google.com/site/moralesonatevictor/">https://sites.google.com/site/moralesonatevictor/</a>,
Christian&quot;, Caamaño-Carrillo, <a href="mailto:chcaaman@ubiobio.cl">chcaaman@ubiobio.cl</a>,<a href="https://www.researchgate.net/profile/Christian-Caamano">https://www.researchgate.net/profile/Christian-Caamano</a>
</p>


<h3>References</h3>

<p>Cressie, N. A. C. (1993) <em>Statistics for Spatial Data</em>. New York:
Wiley.
</p>
<p>Gaetan, C. and Guyon, X. (2010) <em>Spatial Statistics and Modelling</em>.
Spring Verlang, New York.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+GeoFit">GeoFit</a></code>, <code><a href="stats.html#topic+optim">optim</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>library(GeoModels)


# Set the coordinates of the sites:

set.seed(211)
x &lt;- runif(200, 0, 1)
set.seed(98)
y &lt;- runif(200, 0, 1)
coords &lt;- cbind(x,y)

################################################################
###
### Example 1. Least square fitting of a Gaussian random field
### with exponential correlation.
###
###############################################################

# Set the model's parameters:
corrmodel &lt;- "Exponential"
mean &lt;- 0
sill &lt;- 1
nugget &lt;- 0
scale &lt;- 0.15/3
param &lt;- list(mean=0,sill=sill, nugget=nugget, scale=scale)
# Simulation of the Gaussian random field:
set.seed(2)
data &lt;- GeoSim(coordx=coords, corrmodel=corrmodel, param=param)$data

fixed=list(nugget=0,mean=mean)
start=list(scale=scale,sill=sill)
# Least square fitting of the random field:
fit &lt;- GeoWLS(data=data,coordx=coords, corrmodel=corrmodel,
         fixed=fixed,start=start,maxdist=0.5)

# Results:
print(fit)

</code></pre>

<hr>
<h2 id='Lik'>Optimizes the Log Likelihood</h2><span id='topic+Lik'></span>

<h3>Description</h3>

<p>Subroutine called by GeoFit.
The procedure estimates the model parameters by maximization of the
log-likelihood.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Lik(copula,bivariate,coordx,coordy,coordt,
coordx_dyn,corrmodel,data,fixed,flagcor,flagnuis,
           grid,lower,mdecomp,model,namescorr,
           namesnuis,namesparam,numcoord,
           numpairs,numparamcor,numtime,optimizer,
           onlyvar,parallel,param,radius,setup,
           spacetime,sparse,varest,taper,type,
           upper,ns,X,neighb,MM,aniso)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Lik_+3A_copula">copula</code></td>
<td>
<p>String; the type of copula. It can be &quot;Beta&quot; or &quot;Gaussian&quot;</p>
</td></tr>
<tr><td><code id="Lik_+3A_bivariate">bivariate</code></td>
<td>
<p>Logical; if <code>TRUE</code> then the data come froma a bivariate random field.
Otherwise from a univariate random field.</p>
</td></tr>
<tr><td><code id="Lik_+3A_coordx">coordx</code></td>
<td>
<p>A numeric (<code class="reqn">d \times 2</code>)-matrix (where
<code>d</code> is the number of spatial sites) assigning 2-dimensions of spatial coordinates 
or a numeric <code class="reqn">d</code>-dimensional vector assigning
1-dimension of spatial coordinates.</p>
</td></tr>
<tr><td><code id="Lik_+3A_coordy">coordy</code></td>
<td>
<p>A numeric vector assigning 1-dimension of
spatial coordinates; <code>coordy</code> is interpreted only if <code>coordx</code> is a numeric
vector or <code>grid=TRUE</code> otherwise it will be ignored. Optional argument, 
the default is <code>NULL</code> then <code>coordx</code> is expected to
be numeric a (<code class="reqn">d \times 2</code>)-matrix.</p>
</td></tr>
<tr><td><code id="Lik_+3A_coordt">coordt</code></td>
<td>
<p>A numeric vector assigning 1-dimension of
temporal coordinates. Optional argument, the default is <code>NULL</code>
then a spatial random field is expected.</p>
</td></tr>
<tr><td><code id="Lik_+3A_coordx_dyn">coordx_dyn</code></td>
<td>
<p>A list of <code class="reqn">m</code> numeric (<code class="reqn">d_t \times 2</code>)-matrices
containing dynamical (in time) spatial coordinates. Optional argument, the default is <code>NULL</code>
</p>
</td></tr>  
<tr><td><code id="Lik_+3A_corrmodel">corrmodel</code></td>
<td>
<p>Numeric; the id of the correlation model.</p>
</td></tr>
<tr><td><code id="Lik_+3A_data">data</code></td>
<td>
<p>A numeric vector or a (<code class="reqn">n \times d</code>)-matrix or (<code class="reqn">d \times d
      \times n</code>)-matrix of observations.</p>
</td></tr>
<tr><td><code id="Lik_+3A_flagcor">flagcor</code></td>
<td>
<p>A numeric vector of flags denoting which correlation
parameters have to be estimated.</p>
</td></tr>
<tr><td><code id="Lik_+3A_flagnuis">flagnuis</code></td>
<td>
<p>A numeric verctor of flags denoting which nuisance
parameters have to estimated.</p>
</td></tr>
<tr><td><code id="Lik_+3A_fixed">fixed</code></td>
<td>
<p>A numeric vector of parameters that
will be considered as known values.</p>
</td></tr>
<tr><td><code id="Lik_+3A_grid">grid</code></td>
<td>
<p>Logical; if <code>FALSE</code> (the default) the data
are interpreted as a vector or a (<code class="reqn">n \times d</code>)-matrix,
instead if <code>TRUE</code> then (<code class="reqn">d \times d
      \times n</code>)-matrix is considered.</p>
</td></tr>
<tr><td><code id="Lik_+3A_lower">lower</code></td>
<td>
<p>An optional named list giving the values  for the lower bound of the space parameter
when the optimizer is  <code>L-BFGS-B</code> or <code>nlminb</code>  or <code>optimize</code>. The 
names of the list must be the same of the names in the   <code>start</code> list.</p>
</td></tr>
<tr><td><code id="Lik_+3A_model">model</code></td>
<td>
<p>Numeric; the id value of the density associated to the likelihood
objects.</p>
</td></tr>
<tr><td><code id="Lik_+3A_namescorr">namescorr</code></td>
<td>
<p>String; the names of the correlation parameters.</p>
</td></tr>
<tr><td><code id="Lik_+3A_namesnuis">namesnuis</code></td>
<td>
<p>String; the names of the nuisance parameters.</p>
</td></tr>
<tr><td><code id="Lik_+3A_namesparam">namesparam</code></td>
<td>
<p>String; the names of the parameters to be maximised.</p>
</td></tr>
<tr><td><code id="Lik_+3A_numcoord">numcoord</code></td>
<td>
<p>Numeric; the number of coordinates.</p>
</td></tr>
<tr><td><code id="Lik_+3A_numpairs">numpairs</code></td>
<td>
<p>Numeric; the number of pairs.</p>
</td></tr>
<tr><td><code id="Lik_+3A_numparamcor">numparamcor</code></td>
<td>
<p>Numeric; the number of the correlation parameters.</p>
</td></tr>
<tr><td><code id="Lik_+3A_numtime">numtime</code></td>
<td>
<p>Numeric; the number of temporal observations.</p>
</td></tr>
<tr><td><code id="Lik_+3A_mdecomp">mdecomp</code></td>
<td>
<p>String; the type of matrix decomposition used in the simulation. Default is cholesky.
The other possible choices is <code>svd</code> (Singular values decomposition).</p>
</td></tr>     
<tr><td><code id="Lik_+3A_optimizer">optimizer</code></td>
<td>
<p>String; the optimization algorithm
(see <code><a href="stats.html#topic+optim">optim</a></code> for details). <code>Nelder-Mead</code> is the
default. Other possible choices are <code>nlm</code>, <code>BFGS</code>  <code>L-BFGS-B</code> and <code>nlminb</code>. 
In these last two cases upper and lower bounds can be passed by the user. In the case
of one-dimensional optimization, the function <code>optimize</code> is used.</p>
</td></tr>  
<tr><td><code id="Lik_+3A_onlyvar">onlyvar</code></td>
<td>
<p>Logical; if <code>TRUE</code>  (and varest is  <code>TRUE</code>) only the variance covariance matrix is computed
without optimizing. <code>FALSE</code> is the default.</p>
</td></tr>  
<tr><td><code id="Lik_+3A_parallel">parallel</code></td>
<td>
<p>Logical; if <code>TRUE</code> optmization is performed using optimParallel 
using the maximum number of cores,  when optimizer is  
<code>L-BFGS-B</code>.<code>FALSE</code> is the default.</p>
</td></tr> 
<tr><td><code id="Lik_+3A_param">param</code></td>
<td>
<p>A numeric vector of parameters.</p>
</td></tr>
<tr><td><code id="Lik_+3A_sparse">sparse</code></td>
<td>
<p>Logical; if <code>TRUE</code> then  maximum likelihood is computed
using sparse matrices algorithms.<code>FALSE</code> is the default.</p>
</td></tr>
<tr><td><code id="Lik_+3A_radius">radius</code></td>
<td>
<p>Numeric; the radius of the sphere when considering data on a sphere.</p>
</td></tr>
<tr><td><code id="Lik_+3A_ns">ns</code></td>
<td>
<p>Numeric: vector of number of location sites for each temporal instants</p>
</td></tr>  
<tr><td><code id="Lik_+3A_setup">setup</code></td>
<td>
<p>A List of useful components for the estimation based on the maximum tapered likelihood.</p>
</td></tr>
<tr><td><code id="Lik_+3A_spacetime">spacetime</code></td>
<td>
<p>Logical; if the random field is spatial
(<code>FALSE</code>) or spatio-temporal (<code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="Lik_+3A_varest">varest</code></td>
<td>
<p>Logical; if <code>TRUE</code> the estimate' variances and
standard errors are returned.
<code>FALSE</code> is the default.</p>
</td></tr>
<tr><td><code id="Lik_+3A_taper">taper</code></td>
<td>
<p>String; the name of the taper correlation function.</p>
</td></tr>
<tr><td><code id="Lik_+3A_type">type</code></td>
<td>
<p>String; the type of the likelihood objects. If <code>Pairwise</code> (the
default) then the marginal composite likelihood is formed by
pairwise marginal likelihoods.</p>
</td></tr>
<tr><td><code id="Lik_+3A_upper">upper</code></td>
<td>
<p>An optional named list giving the values  for the upper bound 
of the space parameter when the optimizer is or <code>L-BFGS-B</code> or  <code>nlminb</code> or <code>optimize</code>. 
The names of the list must be the same of the names in the   <code>start</code> list.</p>
</td></tr>
<tr><td><code id="Lik_+3A_x">X</code></td>
<td>
<p>Numeric; Matrix of spatio(temporal)covariates in the linear mean specification.</p>
</td></tr>
<tr><td><code id="Lik_+3A_neighb">neighb</code></td>
<td>
<p>Numeric;parameter for vecchia approximation using GPvecchia package</p>
</td></tr>
<tr><td><code id="Lik_+3A_mm">MM</code></td>
<td>
<p>Numeric;a non constant fixed mean </p>
</td></tr>
<tr><td><code id="Lik_+3A_aniso">aniso</code></td>
<td>
<p>Logical; should anisotropy be considered?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Return a list from an <code>optim</code> call.</p>


<h3>Author(s)</h3>

<p>Moreno Bevilacqua, <a href="mailto:moreno.bevilacqua89@gmail.com">moreno.bevilacqua89@gmail.com</a>,<a href="https://sites.google.com/view/moreno-bevilacqua/home">https://sites.google.com/view/moreno-bevilacqua/home</a>,
Víctor Morales Oñate, <a href="mailto:victor.morales@uv.cl">victor.morales@uv.cl</a>, <a href="https://sites.google.com/site/moralesonatevictor/">https://sites.google.com/site/moralesonatevictor/</a>,
Christian&quot;, Caamaño-Carrillo, <a href="mailto:chcaaman@ubiobio.cl">chcaaman@ubiobio.cl</a>,<a href="https://www.researchgate.net/profile/Christian-Caamano">https://www.researchgate.net/profile/Christian-Caamano</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+GeoFit">GeoFit</a></code></p>

<hr>
<h2 id='MatDecomp'>Matrix decomposition</h2><span id='topic+MatDecomp'></span>

<h3>Description</h3>

<p>Matrix decomposition.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MatDecomp(mtx, method)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MatDecomp_+3A_mtx">mtx</code></td>
<td>
<p>numeric; a square positive or semipositive definite matrix.</p>
</td></tr>
<tr><td><code id="MatDecomp_+3A_method">method</code></td>
<td>
<p>string; the type of matrix decomposition. 
Two possible choices: <code>cholesky</code> and <code>svd</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p> Decomposition of a square positive or positive semidefinite matrix.</p>


<h3>Value</h3>

<p>Return a matrix decomposition</p>


<h3>Author(s)</h3>

<p>Moreno Bevilacqua, <a href="mailto:moreno.bevilacqua89@gmail.com">moreno.bevilacqua89@gmail.com</a>,<a href="https://sites.google.com/view/moreno-bevilacqua/home">https://sites.google.com/view/moreno-bevilacqua/home</a>,
Víctor Morales Oñate, <a href="mailto:victor.morales@uv.cl">victor.morales@uv.cl</a>, <a href="https://sites.google.com/site/moralesonatevictor/">https://sites.google.com/site/moralesonatevictor/</a>,
Christian&quot;, Caamaño-Carrillo, <a href="mailto:chcaaman@ubiobio.cl">chcaaman@ubiobio.cl</a>,<a href="https://www.researchgate.net/profile/Christian-Caamano">https://www.researchgate.net/profile/Christian-Caamano</a>
</p>

<hr>
<h2 id='MatSqrt+2C+20MatInv+2C+20MatLogDet'>Square root, inverse  and  log determinant of a (semi)positive definite matrix, given a matrix decomposition.</h2><span id='topic+MatSqrt'></span><span id='topic+MatInv'></span><span id='topic+MatLogDet'></span>

<h3>Description</h3>

<p>Square root, inverse  and  log determinant of a (semi)positive definite matrix, given a matrix decomposition.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MatSqrt(mat.decomp,method) 
MatInv(mat.decomp,method)
MatLogDet(mat.decomp,method)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MatSqrt+2B2C+2B20MatInv+2B2C+2B20MatLogDet_+3A_mat.decomp">mat.decomp</code></td>
<td>
<p>numeric; a matrix decomposition.</p>
</td></tr>
<tr><td><code id="MatSqrt+2B2C+2B20MatInv+2B2C+2B20MatLogDet_+3A_method">method</code></td>
<td>
<p>string; the type of matrix decomposition. Two possible choices: <code>cholesky</code> and <code>svd</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returna a  square root or inverse  or  log determinant of a (semi)positive definite matrix, given a matrix decomposition.</p>


<h3>Author(s)</h3>

<p>Moreno Bevilacqua, <a href="mailto:moreno.bevilacqua89@gmail.com">moreno.bevilacqua89@gmail.com</a>,<a href="https://sites.google.com/view/moreno-bevilacqua/home">https://sites.google.com/view/moreno-bevilacqua/home</a>,
Víctor Morales Oñate, <a href="mailto:victor.morales@uv.cl">victor.morales@uv.cl</a>, <a href="https://sites.google.com/site/moralesonatevictor/">https://sites.google.com/site/moralesonatevictor/</a>,
Christian&quot;, Caamaño-Carrillo, <a href="mailto:chcaaman@ubiobio.cl">chcaaman@ubiobio.cl</a>,<a href="https://www.researchgate.net/profile/Christian-Caamano">https://www.researchgate.net/profile/Christian-Caamano</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+MatDecomp">MatDecomp</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'> library(GeoModels)
 ################################################################
 ###
 ### Example 1. Inverse of Covariance matrix associated to
 ### a Matern correlation model
 ###
 ###############################################################
 # Define the spatial-coordinates of the points:
 x &lt;- runif(15, 0, 1)
 y &lt;- runif(15, 0, 1)
 coords &lt;- cbind(x,y)
 # Matern Parameters
 param=list(smooth=0.5,sill=1,scale=0.2,nugget=0)
 a=matrix &lt;- GeoCovmatrix(coordx=coords, corrmodel="Matern", param=param)

 ## decomposition with cholesky method  
 b=MatDecomp(a$covmat,method="cholesky")
 ## inverse of covariance matrix
 inverse=MatInv(b,method="cholesky")
</code></pre>

<hr>
<h2 id='NuisParam'>Lists the Nuisance Parameters of a Random Field</h2><span id='topic+NuisParam'></span>

<h3>Description</h3>

<p>The procedure returns a list with the nuisance parameters of a given
random field model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NuisParam(model, bivariate=FALSE,num_betas=c(1,1),copula=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NuisParam_+3A_model">model</code></td>
<td>
<p>String; the name of a random field.</p>
</td></tr>
<tr><td><code id="NuisParam_+3A_bivariate">bivariate</code></td>
<td>
<p>Logical; if <code>FALSE</code> (the default) the correlation  model is univariate spatial or spatial-temporal.  
Otherwise is bivariate.</p>
</td></tr>
<tr><td><code id="NuisParam_+3A_num_betas">num_betas</code></td>
<td>
<p>Numerical; the nunber of mean parameters in the linear specification (default is 1)     </p>
</td></tr>
<tr><td><code id="NuisParam_+3A_copula">copula</code></td>
<td>
<p>The type of copula.</p>
</td></tr> 
</table>


<h3>Details</h3>

<p>The function returns a list with the nuisance parameters of a given
random field model.</p>


<h3>Value</h3>

<p>Return a vector string of nuisance parameters.</p>


<h3>Author(s)</h3>

<p>Moreno Bevilacqua, <a href="mailto:moreno.bevilacqua89@gmail.com">moreno.bevilacqua89@gmail.com</a>,<a href="https://sites.google.com/view/moreno-bevilacqua/home">https://sites.google.com/view/moreno-bevilacqua/home</a>,
Víctor Morales Oñate, <a href="mailto:victor.morales@uv.cl">victor.morales@uv.cl</a>, <a href="https://sites.google.com/site/moralesonatevictor/">https://sites.google.com/site/moralesonatevictor/</a>,
Christian&quot;, Caamaño-Carrillo, <a href="mailto:chcaaman@ubiobio.cl">chcaaman@ubiobio.cl</a>,<a href="https://www.researchgate.net/profile/Christian-Caamano">https://www.researchgate.net/profile/Christian-Caamano</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+GeoFit">GeoFit</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>library(GeoModels)

NuisParam("Gaussian")

NuisParam("Binomial")

NuisParam("Weibull",num_betas=2)

NuisParam("SkewGaussian", num_betas=3)

NuisParam("SinhAsinh")

NuisParam("Beta2",copula="Clayton")

NuisParam("StudentT")
## note that in the bivariate case sill and nugget are considered as correlation parameteres
NuisParam("Gaussian", bivariate=TRUE)

</code></pre>

<hr>
<h2 id='NuisParam2'>Internal function handling Nuisance Parameters of a Random Field</h2><span id='topic+NuisParam2'></span>

<h3>Description</h3>

<p>Internal function handling Nuisance Parameters of a Random Field.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NuisParam2(model, bivariate=FALSE,num_betas=c(1,1),copula=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NuisParam2_+3A_model">model</code></td>
<td>
<p>String; the name of a random field.</p>
</td></tr>
<tr><td><code id="NuisParam2_+3A_bivariate">bivariate</code></td>
<td>
<p>Logical; if <code>FALSE</code> (the default) the correlation  model is univariate spatial or spatial-temporal.  
Otherwise is bivariate.</p>
</td></tr>
<tr><td><code id="NuisParam2_+3A_num_betas">num_betas</code></td>
<td>
<p>Numerical; the nunber of mean parameters in the linear specification (default is 1)     </p>
</td></tr>
<tr><td><code id="NuisParam2_+3A_copula">copula</code></td>
<td>
<p>The type of copula.</p>
</td></tr> 
</table>


<h3>Details</h3>

<p>The function returns a list with the nuisance parameters of a given
random field model.</p>


<h3>Value</h3>

<p>Return a vector string of nuisance parameters.</p>


<h3>Author(s)</h3>

<p>Moreno Bevilacqua, <a href="mailto:moreno.bevilacqua89@gmail.com">moreno.bevilacqua89@gmail.com</a>,<a href="https://sites.google.com/view/moreno-bevilacqua/home">https://sites.google.com/view/moreno-bevilacqua/home</a>,
Víctor Morales Oñate, <a href="mailto:victor.morales@uv.cl">victor.morales@uv.cl</a>, <a href="https://sites.google.com/site/moralesonatevictor/">https://sites.google.com/site/moralesonatevictor/</a>,
Christian&quot;, Caamaño-Carrillo, <a href="mailto:chcaaman@ubiobio.cl">chcaaman@ubiobio.cl</a>,<a href="https://www.researchgate.net/profile/Christian-Caamano">https://www.researchgate.net/profile/Christian-Caamano</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+GeoFit">GeoFit</a></code></p>

<hr>
<h2 id='plot.GeoVariogram'>Plot empirical spatial, spatio-temporal and spatial bivariate semi-Variogram</h2><span id='topic+plot.GeoVariogram'></span>

<h3>Description</h3>

<p>Plot empirical spatial, spatio-temporal and spatial bivariate semi-Variogram using 
on object  <code><a href="#topic+GeoVariogram">GeoVariogram</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'GeoVariogram'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.GeoVariogram_+3A_x">x</code></td>
<td>
<p>an object of the class <code>"GeoVariogram"</code> </p>
</td></tr>
<tr><td><code id="plot.GeoVariogram_+3A_...">...</code></td>
<td>
<p>other arguments to be passed to the function
<code><a href="graphics.html#topic+plot">plot</a></code>   </p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function plots empirical semi   variogram in the spatial, spatio-temporal and spatial
bivariate case
</p>


<h3>Value</h3>

<p>Produces a plot.
No values are returned.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+GeoVariogram">GeoVariogram</a></code> for variogram computation and examples.
</p>

<hr>
<h2 id='Prscores'>
Computation of three predictive scores: RMSE, LSCORE, CRPS based on drop-one 
cross-validation prediction for spatial, spatiotemporal and bivariate Gaussian RF.</h2><span id='topic+Prscores'></span>

<h3>Description</h3>

<p>The function computes RMSE, LSCORE, CRPS predictive scores.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Prscores(data,  method="cholesky", matrix)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Prscores_+3A_data">data</code></td>
<td>
<p>A <code class="reqn">d</code>-dimensional vector (a single spatial realisation) 
or a a(<code class="reqn">t \times d</code>)-matrix (a single spatial-temporal realisation).
or a a(<code class="reqn">2 \times d</code>)-matrix (a single bivariate realisation).</p>
</td></tr>
<tr><td><code id="Prscores_+3A_method">method</code></td>
<td>
<p>String; the type of matrix decomposition used in the computation of the predictive scores. Default is <code>cholesky</code>. The other possible choices is <code>svd</code>.</p>
</td></tr> 
<tr><td><code id="Prscores_+3A_matrix">matrix</code></td>
<td>
<p>An object of class GeoCovmatrix. See the Section <b>Details</b>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For a given covariance matrix object (<code><a href="#topic+GeoCovmatrix">GeoCovmatrix</a></code>)
and a given spatial, spatiotemporal or bivariare realization
from a Gaussian random field,
the function computes three predictive scores.</p>


<h3>Value</h3>

<p>Returns a list  containing the following informations:
</p>
<table>
<tr><td><code>RMSE</code></td>
<td>
<p>Root-mean-square error predictive score</p>
</td></tr>
<tr><td><code>MAE</code></td>
<td>
<p>Mean absolute error predictive score</p>
</td></tr>
<tr><td><code>LSCORE</code></td>
<td>
<p>Logarithmic predictive score</p>
</td></tr>
<tr><td><code>CRPS</code></td>
<td>
<p>Continuous ranked probability predictive score</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Moreno Bevilacqua, <a href="mailto:moreno.bevilacqua89@gmail.com">moreno.bevilacqua89@gmail.com</a>,<a href="https://sites.google.com/view/moreno-bevilacqua/home">https://sites.google.com/view/moreno-bevilacqua/home</a>,
Víctor Morales Oñate, <a href="mailto:victor.morales@uv.cl">victor.morales@uv.cl</a>, <a href="https://sites.google.com/site/moralesonatevictor/">https://sites.google.com/site/moralesonatevictor/</a>,
Christian&quot;, Caamaño-Carrillo, <a href="mailto:chcaaman@ubiobio.cl">chcaaman@ubiobio.cl</a>,<a href="https://www.researchgate.net/profile/Christian-Caamano">https://www.researchgate.net/profile/Christian-Caamano</a>
</p>


<h3>References</h3>

<p>Zhang H. and Wang Y. (2010). <em>Kriging
and cross-validation for massive spatial data</em>.
Environmetrics, <b>21</b>, 290&ndash;304.
Gneiting T. and Raftery A. <em>Strictly Proper Scoring Rules, 
Prediction, and Estimation</em>.
Journal of the American Statistical Association, <b>102</b>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+GeoCovmatrix">GeoCovmatrix</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(GeoModels)
library(fields)

################################################################
######### Examples of predictive score computation  ############
################################################################

  # Define the spatial-coordinates of the points:
x &lt;- runif(500, 0, 2)
y &lt;- runif(500, 0, 2)
coords=cbind(x,y)
matrix1 &lt;- GeoCovmatrix(coordx=coords, corrmodel="Matern", param=list(smooth=0.5,
                      sill=1,scale=0.2,nugget=0))
 
data &lt;- GeoSim(coordx=coords, corrmodel="Matern", param=list(mean=0,smooth=0.5,
                      sill=1,scale=0.2,nugget=0))$data

Pr_scores &lt;- Prscores(data,matrix=matrix1)

Pr_scores

</code></pre>

<hr>
<h2 id='SimCE'>Circulant embeeding simulation</h2><span id='topic+SimCE'></span>

<h3>Description</h3>

<p>Subroutine called by GeoSimapprox.
The procedure return a simulation on a regular grid from a standard spatial Gaussian random field
with a specified correlation model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SimCE(M,N,x,y,corrmodel,param,mean.val, max.ext)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SimCE_+3A_m">M</code></td>
<td>
<p>Numeric; the dimension of x</p>
</td></tr>
<tr><td><code id="SimCE_+3A_n">N</code></td>
<td>
<p>Numeric; the dimension of y</p>
</td></tr>
<tr><td><code id="SimCE_+3A_x">x</code></td>
<td>
<p>A numeric <code class="reqn">M</code>-dimensional vector giving 1-dimension of spatial coordinates.</p>
</td></tr>
<tr><td><code id="SimCE_+3A_y">y</code></td>
<td>
<p>A numeric <code class="reqn">N</code>-dimensional vector giving 1-dimension of spatial coordinates.</p>
</td></tr>
<tr><td><code id="SimCE_+3A_corrmodel">corrmodel</code></td>
<td>
<p>String; the name of a correlation model.</p>
</td></tr>
<tr><td><code id="SimCE_+3A_param">param</code></td>
<td>
<p>A list of parameter values required in the simulation procedure.</p>
</td></tr>
<tr><td><code id="SimCE_+3A_mean.val">mean.val</code></td>
<td>
<p>The mean of the random field.</p>
</td></tr>
<tr><td><code id="SimCE_+3A_max.ext">max.ext</code></td>
<td>
<p>The maximum extension of the simulation window.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Return a list from an <code>optim</code> call.</p>


<h3>Author(s)</h3>

<p>Moreno Bevilacqua, <a href="mailto:moreno.bevilacqua89@gmail.com">moreno.bevilacqua89@gmail.com</a>,<a href="https://sites.google.com/view/moreno-bevilacqua/home">https://sites.google.com/view/moreno-bevilacqua/home</a>,
Víctor Morales Oñate, <a href="mailto:victor.morales@uv.cl">victor.morales@uv.cl</a>, <a href="https://sites.google.com/site/moralesonatevictor/">https://sites.google.com/site/moralesonatevictor/</a>,
Christian&quot;, Caamaño-Carrillo, <a href="mailto:chcaaman@ubiobio.cl">chcaaman@ubiobio.cl</a>,<a href="https://www.researchgate.net/profile/Christian-Caamano">https://www.researchgate.net/profile/Christian-Caamano</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+GeoSimapprox">GeoSimapprox</a></code></p>

<hr>
<h2 id='sp2Geo'>Extracting information from an sp or spacetime object</h2><span id='topic+sp2Geo'></span>

<h3>Description</h3>

<p>Extracting information from an sp or spacetime object</p>


<h3>Usage</h3>

<pre><code class='language-R'>sp2Geo(spobj,spdata = NULL)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sp2Geo_+3A_spobj">spobj</code></td>
<td>
<p>An object of class sp or spacetime</p>
</td></tr>
<tr><td><code id="sp2Geo_+3A_spdata">spdata</code></td>
<td>
<p>Character: The name of data in the sp or spacetime object</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function accepts as input a sp or spacetime object and the name of the  data of interest in the object  and it returns a list with some  useful informations  for Geomodels functions.
</p>


<h3>Value</h3>

<p>A list with spatio-temporal informations</p>


<h3>Author(s)</h3>

<p>Moreno Bevilacqua, <a href="mailto:moreno.bevilacqua89@gmail.com">moreno.bevilacqua89@gmail.com</a>,<a href="https://sites.google.com/view/moreno-bevilacqua/home">https://sites.google.com/view/moreno-bevilacqua/home</a>,
Víctor Morales Oñate, <a href="mailto:victor.morales@uv.cl">victor.morales@uv.cl</a>, <a href="https://sites.google.com/site/moralesonatevictor/">https://sites.google.com/site/moralesonatevictor/</a>,
Christian&quot;, Caamaño-Carrillo, <a href="mailto:chcaaman@ubiobio.cl">chcaaman@ubiobio.cl</a>,<a href="https://www.researchgate.net/profile/Christian-Caamano">https://www.researchgate.net/profile/Christian-Caamano</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Define the spatial-coordinates of the points:
set.seed(3)
N &lt;- 30  # number of location sites
x &lt;- runif(N, 0, 1)
set.seed(6)
y &lt;- runif(N, 0, 1)
coords &lt;- cbind(x,y)

# Define spatial matrix covariates and regression parameters
X &lt;- cbind(rep(1,N),runif(N))
# Define spatial matrix dependent variable
Y &lt;- rnorm(nrow(X))

obj1 &lt;- sp::SpatialPoints(coords)
obj2 &lt;- sp::SpatialPointsDataFrame(coords,data = data.frame(X,Y))

# sp2Geo info extraction
b &lt;- sp2Geo(obj2,spdata  = "Y")
class(b)
b
</code></pre>

<hr>
<h2 id='spanish_wind'>August monthly average wind speed in Spain between 1970-2000</h2><span id='topic+spanish_wind'></span>

<h3>Description</h3>

<p>A (<code class="reqn">6000x 3</code>)-matrix containing lon/lat 
and  august monthly average wind speed (2 m above the ground, meter/second) registered at 6000 location sites in the Iberian peninsula.
Data obtained from WorldClim version 2.1</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(spanish_wind)</code></pre>


<h3>Format</h3>

<p>A numerical matrix of dimension <code class="reqn">6000 x 3</code>.</p>


<h3>Source</h3>

<p>Fick, S.E., Hijmans, R.J. (2017) WorldClim 2: new 1km spatial resolution climate surfaces for global land areas.
<em>International Journal of Climatology</em>, <b>37</b>, 4302&ndash;4315.
</p>

<hr>
<h2 id='StartParam'>Initializes the Parameters for Estimation Procedures</h2><span id='topic+StartParam'></span>

<h3>Description</h3>

<p>Subroutine called by the fitting procedures.
The procedure initializes the parameters for the fitting procedure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>StartParam(coordx, coordy, coordt,coordx_dyn, corrmodel, data, distance, fcall, 
          fixed, grid,likelihood,  maxdist, neighb, maxtime, model, n,  param, 
          parscale, paramrange, radius,  start, taper, tapsep,
          type,typereal,varest, vartype, weighted, winconst,
          winstp, winconst_t, winstp_t,copula,X,memdist,nosym)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="StartParam_+3A_coordx">coordx</code></td>
<td>
<p>A numeric (<code class="reqn">d \times 2</code>)-matrix (where
<code>d</code> is the number of points) assigning 2-dimensions of coordinates or a numeric vector assigning
1-dimension of coordinates.</p>
</td></tr>
<tr><td><code id="StartParam_+3A_coordy">coordy</code></td>
<td>
<p>A numeric vector assigning 1-dimension of
coordinates; <code>coordy</code> is interpreted only if <code>coordx</code> is a numeric
vector otherwise it will be ignored.</p>
</td></tr>
<tr><td><code id="StartParam_+3A_coordt">coordt</code></td>
<td>
<p>A numeric vector assigning 1-dimension of
temporal coordinates.</p>
</td></tr>
<tr><td><code id="StartParam_+3A_coordx_dyn">coordx_dyn</code></td>
<td>
<p>A list of <code class="reqn">m</code> numeric (<code class="reqn">d_t \times 2</code>)-matrices
containing dynamical (in time) spatial coordinates. Optional argument, the default is <code>NULL</code>
</p>
</td></tr>  
<tr><td><code id="StartParam_+3A_corrmodel">corrmodel</code></td>
<td>
<p>String; the name of a correlation model.</p>
</td></tr>
<tr><td><code id="StartParam_+3A_data">data</code></td>
<td>
<p>A numeric vector or a (<code class="reqn">n \times d</code>)-matrix or (<code class="reqn">d \times d
      \times n</code>)-matrix of observations.</p>
</td></tr>
<tr><td><code id="StartParam_+3A_distance">distance</code></td>
<td>
<p>String; the name of the spatial distance. The default is <code>Eucl</code>,
the euclidean distance. See the Section <b>Details</b>.</p>
</td></tr>
<tr><td><code id="StartParam_+3A_fcall">fcall</code></td>
<td>
<p>String; &quot;fitting&quot; to call the fitting procedure and
&quot;simulation&quot; to call the simulation procedure.</p>
</td></tr>
<tr><td><code id="StartParam_+3A_fixed">fixed</code></td>
<td>
<p>A named list giving the values of the parameters that
will be considered as known values.</p>
</td></tr>
<tr><td><code id="StartParam_+3A_grid">grid</code></td>
<td>
<p>Logical; if <code>FALSE</code> (the default) the data
are interpreted as a vector or a (<code class="reqn">n \times d</code>)-matrix,
instead if <code>TRUE</code> then (<code class="reqn">d \times d
      \times n</code>)-matrix is considered.</p>
</td></tr>
<tr><td><code id="StartParam_+3A_likelihood">likelihood</code></td>
<td>
<p>String; the configuration of the composite
likelihood.</p>
</td></tr>
<tr><td><code id="StartParam_+3A_maxdist">maxdist</code></td>
<td>
<p>Numeric; an optional positive value indicating the maximum
spatial distance considered in the composite-likelihood
computation.</p>
</td></tr>
<tr><td><code id="StartParam_+3A_neighb">neighb</code></td>
<td>
<p>Numeric; an optional positive integer indicating the 
order of neighborhood  in the composite likelihood
computation. See the Section <b>Details</b> for more information.</p>
</td></tr>
<tr><td><code id="StartParam_+3A_maxtime">maxtime</code></td>
<td>
<p>Numeric; an optional positive value indicating the maximum
temporal lag considered in the composite-likelihood
computation.</p>
</td></tr> 
<tr><td><code id="StartParam_+3A_radius">radius</code></td>
<td>
<p>Numeric; the radius of the sphere in the case of lon-lat coordinates.
The default is 6371, the radius of the earth.</p>
</td></tr>  
<tr><td><code id="StartParam_+3A_model">model</code></td>
<td>
<p>String; the density associated to the likelihood
objects. <code>Gaussian</code> is the default.</p>
</td></tr>
<tr><td><code id="StartParam_+3A_n">n</code></td>
<td>
<p>Numeric; number of trials for binomial random fields.</p>
</td></tr>  
<tr><td><code id="StartParam_+3A_param">param</code></td>
<td>
<p>A numeric vector of parameter values required in the
simulation procedure of random fields.</p>
</td></tr>
<tr><td><code id="StartParam_+3A_parscale">parscale</code></td>
<td>
<p>A numeric vector of scaling factor to improve the
maximizing procedure, see <code><a href="stats.html#topic+optim">optim</a></code>.</p>
</td></tr>
<tr><td><code id="StartParam_+3A_paramrange">paramrange</code></td>
<td>
<p>A numeric vector of parameters ranges, see
<code><a href="stats.html#topic+optim">optim</a></code>.</p>
</td></tr>
<tr><td><code id="StartParam_+3A_start">start</code></td>
<td>
<p>A named list with the initial values of the
parameters that are used by the numerical routines in maximization
procedure.</p>
</td></tr>
<tr><td><code id="StartParam_+3A_taper">taper</code></td>
<td>
<p>String; the name of the type of covariance matrix.
It can be   <code>Standard</code> (the default value) or
<code>Tapering</code> for taperd covariance matrix.</p>
</td></tr>
<tr><td><code id="StartParam_+3A_tapsep">tapsep</code></td>
<td>
<p>Numeric; an optional  value indicating the separabe parameter in the space time 
adaptive taper (see <b>Details</b>).</p>
</td></tr>
<tr><td><code id="StartParam_+3A_type">type</code></td>
<td>
<p>String; the type of likelihood objects. Temporary value set
to be &quot;WLeastSquare&quot; (weigthed least-square) in order to compute the starting values.</p>
</td></tr>
<tr><td><code id="StartParam_+3A_typereal">typereal</code></td>
<td>
<p>String; the real type of likelihood objects. See <code><a href="#topic+GeoFit">GeoFit</a></code>.</p>
</td></tr>
<tr><td><code id="StartParam_+3A_varest">varest</code></td>
<td>
<p>Logical; if <code>TRUE</code> the estimates' variances and
standard errors are returned.
<code>FALSE</code> is the default.</p>
</td></tr>
<tr><td><code id="StartParam_+3A_vartype">vartype</code></td>
<td>
<p>String; the type of estimation method for computing
the estimate variances, see the Section <b>Details</b>.</p>
</td></tr>
<tr><td><code id="StartParam_+3A_weighted">weighted</code></td>
<td>
<p>Logical; if <code>TRUE</code> the likelihood objects are
weighted, see <code><a href="#topic+GeoFit">GeoFit</a></code>.</p>
</td></tr>
<tr><td><code id="StartParam_+3A_winconst">winconst</code></td>
<td>
<p>Numeric; a positive value for computing the spatial  sub-window
in the sub-sampling procedure.</p>
</td></tr>
<tr><td><code id="StartParam_+3A_winstp">winstp</code></td>
<td>
<p>Numeric; a value in <code class="reqn">(0,1]</code> for defining the the proportion of 
overlapping in the spatial  sub-sampling procedure.</p>
</td></tr>
<tr><td><code id="StartParam_+3A_winconst_t">winconst_t</code></td>
<td>
<p>Numeric; a positive value for computing the temporal sub-window
in the sub-sampling procedure.</p>
</td></tr>
<tr><td><code id="StartParam_+3A_winstp_t">winstp_t</code></td>
<td>
<p>Numeric; a value in <code class="reqn">(0,1]</code> for defining the the proportion of 
overlapping in the temporal  sub-sampling procedure.</p>
</td></tr>
<tr><td><code id="StartParam_+3A_copula">copula</code></td>
<td>
<p>The type of copula.</p>
</td></tr>
<tr><td><code id="StartParam_+3A_x">X</code></td>
<td>
<p>Numeric; Matrix of space-time covariates.</p>
</td></tr>   
<tr><td><code id="StartParam_+3A_memdist">memdist</code></td>
<td>
<p> Logical; if <code>TRUE</code> then  the distances in the  composite likelihood 
are computed before  the optmization. </p>
</td></tr>
<tr><td><code id="StartParam_+3A_nosym">nosym</code></td>
<td>
<p>Logical; if TRUE two simmetric weights are not considered </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Internal function called by  <code><a href="#topic+WlsStart">WlsStart</a></code>.</p>


<h3>Value</h3>

<p>A list with  a set of useful informations in the estimation procedure.</p>


<h3>Author(s)</h3>

<p>Moreno Bevilacqua, <a href="mailto:moreno.bevilacqua89@gmail.com">moreno.bevilacqua89@gmail.com</a>,<a href="https://sites.google.com/view/moreno-bevilacqua/home">https://sites.google.com/view/moreno-bevilacqua/home</a>,
Víctor Morales Oñate, <a href="mailto:victor.morales@uv.cl">victor.morales@uv.cl</a>, <a href="https://sites.google.com/site/moralesonatevictor/">https://sites.google.com/site/moralesonatevictor/</a>,
Christian&quot;, Caamaño-Carrillo, <a href="mailto:chcaaman@ubiobio.cl">chcaaman@ubiobio.cl</a>,<a href="https://www.researchgate.net/profile/Christian-Caamano">https://www.researchgate.net/profile/Christian-Caamano</a>
</p>

<hr>
<h2 id='winds'>Irish Daily Wind Speeds</h2><span id='topic+winds'></span>

<h3>Description</h3>

<p>A matrix containing daily wind speeds, in
kilometers per hour, from 1961 to 1978 at 12 sites in Ireland
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(winds)</code></pre>


<h3>Format</h3>

<p>A (<code class="reqn">6574 \times 11</code>)-matrix containing wind speed observations.</p>


<h3>Source</h3>

<p>Haslett, J. and Raftery, A. E. (1989),
Space-time modelling with long-memory dependence: assessing
Ireland's wind-power resource (with discussion),
<em>Applied Statistics</em>, 38, 1&ndash;50.
</p>

<hr>
<h2 id='winds.coords'>Weather Stations of the Irish Daily Wind Speeds</h2><span id='topic+winds.coords'></span>

<h3>Description</h3>

<p>A data frame containing information about the weather stations
where the data are recorded in Ireland.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(winds.coords)</code></pre>


<h3>Format</h3>

<p>A data frame containing site - the name of the city (character),
abbr - the abbrevation (character), elev - the elevation (numeric),
lat - latitude (numeric) and lon  - longitude.</p>


<h3>Source</h3>

<p>Haslett, J. and Raftery, A. E. (1989),
Space-time modelling with long-memory dependence: assessing
Ireland's wind-power resource (with discussion),
<em>Applied Statistics</em>, 38, 1&ndash;50.
</p>

<hr>
<h2 id='WlsStart'>Computes Starting Values based on Weighted Least Squares</h2><span id='topic+WlsStart'></span>

<h3>Description</h3>

<p>Subroutine called by GeoFit.
The function returns opportune starting values for the
composite-likelihood fitting procedure based on weigthed least squares.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>WlsStart(coordx, coordy, coordt, coordx_dyn, corrmodel, data, distance, fcall,
        fixed, grid,likelihood, maxdist, neighb,maxtime, model, n, param, 
        parscale, paramrange, radius,start, taper, tapsep, type, varest,
        vartype, weighted, winconst,winconst_t, winstp_t, winstp,copula,X,memdist,nosym)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="WlsStart_+3A_coordx">coordx</code></td>
<td>
<p>A numeric (<code class="reqn">d \times 2</code>)-matrix (where
<code>d</code> is the number of points) assigning 2-dimensions of coordinates or a numeric vector assigning
1-dimension of coordinates.</p>
</td></tr>
<tr><td><code id="WlsStart_+3A_coordy">coordy</code></td>
<td>
<p>A numeric vector assigning 1-dimension of
coordinates; <code>coordy</code> is interpreted only if <code>coordx</code> is a numeric
vector otherwise it will be ignored.</p>
</td></tr>
<tr><td><code id="WlsStart_+3A_coordt">coordt</code></td>
<td>
<p>A numeric vector assigning 1-dimension of
temporal coordinates.</p>
</td></tr>
<tr><td><code id="WlsStart_+3A_coordx_dyn">coordx_dyn</code></td>
<td>
<p>A list of <code class="reqn">m</code> numeric (<code class="reqn">d_t \times 2</code>)-matrices
containing dynamical (in time) spatial coordinates. Optional argument, the default is <code>NULL</code>
</p>
</td></tr>  
<tr><td><code id="WlsStart_+3A_corrmodel">corrmodel</code></td>
<td>
<p>String; the name of a correlation model, for the
description.</p>
</td></tr>
<tr><td><code id="WlsStart_+3A_data">data</code></td>
<td>
<p>A numeric vector or a (<code class="reqn">n \times d</code>)-matrix or (<code class="reqn">d \times d
      \times n</code>)-matrix of observations.</p>
</td></tr>
<tr><td><code id="WlsStart_+3A_distance">distance</code></td>
<td>
<p>String; the name of the spatial distance. The default is <code>Eucl</code>,
the euclidean distance. See the Section <b>Details</b>.</p>
</td></tr>
<tr><td><code id="WlsStart_+3A_fcall">fcall</code></td>
<td>
<p>String; &quot;fitting&quot; to call the fitting procedure and
&quot;simulation&quot; to call the simulation procedure.</p>
</td></tr>
<tr><td><code id="WlsStart_+3A_fixed">fixed</code></td>
<td>
<p>A named list giving the values of the parameters that
will be considered as known values.</p>
</td></tr>
<tr><td><code id="WlsStart_+3A_grid">grid</code></td>
<td>
<p>Logical; if <code>FALSE</code> (the default) the data
are interpreted as a vector or a (<code class="reqn">n \times d</code>)-matrix,
instead if <code>TRUE</code> then (<code class="reqn">d \times d
      \times n</code>)-matrix is considered.</p>
</td></tr>
<tr><td><code id="WlsStart_+3A_likelihood">likelihood</code></td>
<td>
<p>String; the configuration of the composite
likelihood.</p>
</td></tr>
<tr><td><code id="WlsStart_+3A_maxdist">maxdist</code></td>
<td>
<p>Numeric; an optional positive value indicating the maximum
spatial distance considered in the composite-likelihood
computation.</p>
</td></tr>
<tr><td><code id="WlsStart_+3A_neighb">neighb</code></td>
<td>
<p>Numeric; an optional positive integer indicating the 
order of neighborhood  in the composite likelihood
computation. See the Section <b>Details</b> for more information.</p>
</td></tr>
<tr><td><code id="WlsStart_+3A_maxtime">maxtime</code></td>
<td>
<p>Numeric; an optional positive value indicating the maximum
temporal separation considered in the composite-likelihood
computation.</p>
</td></tr> 
<tr><td><code id="WlsStart_+3A_model">model</code></td>
<td>
<p>String; the name of the model. Here the default is
<code>NULL</code>.</p>
</td></tr>
<tr><td><code id="WlsStart_+3A_n">n</code></td>
<td>
<p>Numeric; number of trials in a binomial random field.</p>
</td></tr>  
<tr><td><code id="WlsStart_+3A_param">param</code></td>
<td>
<p>A numeric vector of parameter values required in the
simulation procedure of random fields.</p>
</td></tr>
<tr><td><code id="WlsStart_+3A_parscale">parscale</code></td>
<td>
<p>A numeric vector with scaling values for improving the
maximisation routine.</p>
</td></tr>
<tr><td><code id="WlsStart_+3A_paramrange">paramrange</code></td>
<td>
<p>A numeric vector with the range of the parameter
space.</p>
</td></tr>
<tr><td><code id="WlsStart_+3A_radius">radius</code></td>
<td>
<p>Numeric; a value indicating  the radius of the sphere when using the great circle distance.
Default value is the radius of the earth in Km (i.e. 6371)</p>
</td></tr>   
<tr><td><code id="WlsStart_+3A_start">start</code></td>
<td>
<p>A numeric vector with starting values.</p>
</td></tr>
<tr><td><code id="WlsStart_+3A_taper">taper</code></td>
<td>
<p>String; the name of the type of covariance matrix.
It can be <code>Standard</code> (the default value) or
<code>Tapering</code> for taperd covariance matrix.</p>
</td></tr>
<tr><td><code id="WlsStart_+3A_tapsep">tapsep</code></td>
<td>
<p>Numeric; an optional  value indicating the separabe parameter in the space time quasi taper (see <b>Details</b>).</p>
</td></tr>
<tr><td><code id="WlsStart_+3A_type">type</code></td>
<td>
<p>String; the type of estimation method.</p>
</td></tr>
<tr><td><code id="WlsStart_+3A_varest">varest</code></td>
<td>
<p>Logical; if <code>TRUE</code> the estimates' variances and
standard errors are returned.
<code>FALSE</code> is the default.</p>
</td></tr>
<tr><td><code id="WlsStart_+3A_vartype">vartype</code></td>
<td>
<p>String; the type of estimation method for computing
the estimate variances, see the Section <b>Details</b>.</p>
</td></tr>
<tr><td><code id="WlsStart_+3A_weighted">weighted</code></td>
<td>
<p>Logical; if <code>TRUE</code> the likelihood objects are
weighted, see <code><a href="#topic+GeoFit">GeoFit</a></code>.</p>
</td></tr>
<tr><td><code id="WlsStart_+3A_winconst">winconst</code></td>
<td>
<p>Numeric; a positive value for computing the spatial  sub-window
in the sub-sampling procedure.</p>
</td></tr>
<tr><td><code id="WlsStart_+3A_winstp">winstp</code></td>
<td>
<p>Numeric; a value in <code class="reqn">(0,1]</code> for defining the the proportion of 
overlapping in the spatial  sub-sampling procedure.</p>
</td></tr>
<tr><td><code id="WlsStart_+3A_winconst_t">winconst_t</code></td>
<td>
<p>Numeric; a positive value for computing the temporal sub-window
in the sub-sampling procedure.</p>
</td></tr>
<tr><td><code id="WlsStart_+3A_winstp_t">winstp_t</code></td>
<td>
<p>Numeric; a value in <code class="reqn">(0,1]</code> for defining the the proportion of 
overlapping in the temporal  sub-sampling procedure.</p>
</td></tr>
<tr><td><code id="WlsStart_+3A_copula">copula</code></td>
<td>
<p>The type of copula.</p>
</td></tr>
<tr><td><code id="WlsStart_+3A_x">X</code></td>
<td>
<p>Numeric; Matrix of spatio(temporal)covariates in the linear mean specification.</p>
</td></tr>  
<tr><td><code id="WlsStart_+3A_memdist">memdist</code></td>
<td>
<p> Logical; if <code>TRUE</code> then  the distances in the  composite likelihood 
are computed before  the optmization. </p>
</td></tr>
<tr><td><code id="WlsStart_+3A_nosym">nosym</code></td>
<td>
<p>Logical; if TRUE two simmetric weights are not considered </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Internal function called by  <code><a href="#topic+GeoFit">GeoFit</a></code>.</p>


<h3>Value</h3>

<p>A list with  a set of useful informations in the estimation procedure.</p>


<h3>Author(s)</h3>

<p>Moreno Bevilacqua, <a href="mailto:moreno.bevilacqua89@gmail.com">moreno.bevilacqua89@gmail.com</a>,<a href="https://sites.google.com/view/moreno-bevilacqua/home">https://sites.google.com/view/moreno-bevilacqua/home</a>,
Víctor Morales Oñate, <a href="mailto:victor.morales@uv.cl">victor.morales@uv.cl</a>, <a href="https://sites.google.com/site/moralesonatevictor/">https://sites.google.com/site/moralesonatevictor/</a>,
Christian&quot;, Caamaño-Carrillo, <a href="mailto:chcaaman@ubiobio.cl">chcaaman@ubiobio.cl</a>,<a href="https://www.researchgate.net/profile/Christian-Caamano">https://www.researchgate.net/profile/Christian-Caamano</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+GeoFit">GeoFit</a></code>.</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
