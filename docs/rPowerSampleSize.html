<!DOCTYPE html><html><head><title>Help for package rPowerSampleSize</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {rPowerSampleSize}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#rPowerSampleSize-package'><p>Sample Size Computation and Data Analysis in the context of multiple continuous endpoints in clinical trials.</p></a></li>
<li><a href='#bonferroni.1m.ssc'>
<p>Sample Size Computation with Single Step Bonferroni Method in the Context of Multiple Continuous Endpoints.</p></a></li>
<li><a href='#complexity'>
<p>Computation of the complexity of the numerical computations.</p></a></li>
<li><a href='#data'>
<p>Simulated data</p></a></li>
<li><a href='#df.compute'>
<p>Computation of degrees of freedom.</p></a></li>
<li><a href='#global.1m.analysis'><p>Data analysis with a global method in the context of multiple continuous endpoints</p></a></li>
<li><a href='#global.1m.ssc'>
<p>Sample Size Computation Based on a Global Procedure in the Context of Multiple Continuous Endpoints</p></a></li>
<li><a href='#indiv.1m.analysis'>
<p>Data analysis with an individual testing procedure in the context of multiple continuous endpoints</p></a></li>
<li><a href='#indiv.1m.ssc'>
<p>Sample size computation with an individual testing procedure in the context of multiple continuous endpoints</p></a></li>
<li><a href='#indiv.analysis'>
<p>Data analysis using an individual testing procedure controlling the</p>
q-gFWER in the context of <code class="reqn">m</code> multiple continuous endpoints</a></li>
<li><a href='#indiv.rm.ssc'>
<p>Sample size determination in the context of multiple continuous</p>
endpoints with a control of the q-gFWER, for a given value of r-power
(generalized disjunctive power).</a></li>
<li><a href='#matrix.type.compute'>
<p>Computation of matrix type</p></a></li>
<li><a href='#montecarlo'>
<p>Monte carlo computation of power.</p></a></li>
<li><a href='#plot.rPower'>
<p>Plot of an rPower object</p></a></li>
<li><a href='#Psirmd'>
<p>Computation of power for step-down (Holm) procedure.</p></a></li>
<li><a href='#Psirms'>
<p>Computation of power for single step (Bonferroni) procedure.</p></a></li>
<li><a href='#Psirmu'>
<p>Computation of power for step-up (Hochberg) procedure.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Sample Size Computations Controlling the Type-II Generalized
Family-Wise Error Rate</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.2</td>
</tr>
<tr>
<td>Date:</td>
<td>2018-05-10</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&gt; 2)</a></td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>Author:</td>
<td>Pierre Lafaye de Micheaux, Benoit Liquet and Jeremie Riou   </td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Pierre Lafaye de Micheaux &lt;lafaye@unsw.edu.au&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>The significance of mean difference tests in clinical trials is established if at least r null hypotheses are rejected among m that are simultaneously tested. This package enables one to compute necessary sample sizes for single-step (Bonferroni) and step-wise procedures (Holm and Hochberg). These three procedures control the q-generalized family-wise error rate (probability of making at least q false rejections). Sample size is computed (for these single-step and step-wise procedures) in a such a way that the r-power (probability of rejecting at least r false null hypotheses, i.e. at least r significant endpoints among m) is above some given threshold, in the context of tests of difference of means for two groups of continuous endpoints (variables). Various types of structure of correlation are considered. It is also possible to analyse data (i.e., actually test difference in means) when these are available. The case r equals 1 is treated in separate functions that were used in Lafaye de Micheaux et al. (2014) &lt;<a href="https://doi.org/10.1080%2F10543406.2013.860156">doi:10.1080/10543406.2013.860156</a>&gt;.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10.0), mvtnorm, stats, ssanv, parallel</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2018-05-10 10:21:50 UTC; lafaye</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2018-05-10 12:16:42 UTC</td>
</tr>
</table>
<hr>
<h2 id='rPowerSampleSize-package'>Sample Size Computation and Data Analysis in the context of multiple continuous endpoints in clinical trials.
</h2><span id='topic+rPowerSampleSize-package'></span><span id='topic+rPowerSampleSize'></span>

<h3>Description</h3>

<p>The package rPowerSampleSize has been developped in order to compute the sample size, and to analyse the data, in the context of multiple primary continuous endpoints 
in clinical trials. Two approaches are available for the decision rule &ldquo;at least one significant endpoint among m&rdquo;. All the procedures which correspond to
this decision rule include 1m in the name of the function. An individual procedure based on Union-Intersection Procedure, and a global method based on multivariate 
linear model. This package for this decision rule contains four functions: two for the sample size determination (one for individual procedure, and one for a global 
method), and two for data analysis in order to resolve the multiple testing problems (one for individual procedure, and one for a global method). The sample size 
computation for the Bonferroni Procedure is also available. A generalisation of the first case is also available with a decision rule &ldquo;at least r significant endpoint
among the m primary endpoint&rdquo;. The procedure which corresponds to this decision rule include rm in the name of the function. We have one functions here where we study 
the sample size computation.
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> rPowerSampleSize</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 1.0</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2012-03-21</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL (&gt;2) </td>
</tr>
<tr>
 <td style="text-align: left;">
LazyLoad: </td><td style="text-align: left;"> yes</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Author(s)</h3>

<p>Pierre Lafaye de Micheaux, Benoit Liquet and Jeremie Riou
Maintainer: Pierre Lafaye de Micheaux &lt;lafaye@unsw.edu.au&gt; 
</p>

<hr>
<h2 id='bonferroni.1m.ssc'>
Sample Size Computation with Single Step Bonferroni Method in the Context of Multiple Continuous Endpoints.
</h2><span id='topic+bonferroni.1m.ssc'></span>

<h3>Description</h3>

<p>This function computes the sample size for an analysis of multiple test with a single step Bonferroni procedure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bonferroni.1m.ssc(mean.diff, sd, cor, power = 0.8, alpha = 0.05,
alternative = "two.sided")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bonferroni.1m.ssc_+3A_mean.diff">mean.diff</code></td>
<td>
<p>vector of the mean differences of the <code>m</code>
endpoints between both groups under the alternative hypothesis.</p>
</td></tr>
<tr><td><code id="bonferroni.1m.ssc_+3A_sd">sd</code></td>
<td>
<p>vector of the standard deviations of the <code>m</code>
endpoints. These are assumed identical for both groups.
</p>
</td></tr>
<tr><td><code id="bonferroni.1m.ssc_+3A_cor">cor</code></td>
<td>
<p>correlation matrix between the endpoints. These are assumed identical for both groups.</p>
</td></tr>
<tr><td><code id="bonferroni.1m.ssc_+3A_power">power</code></td>
<td>
<p>value which corresponds to the chosen power.
</p>
</td></tr>
<tr><td><code id="bonferroni.1m.ssc_+3A_alpha">alpha</code></td>
<td>
<p>value which correponds to the chosen Type-I error rate bound.
</p>
</td></tr>
<tr><td><code id="bonferroni.1m.ssc_+3A_alternative">alternative</code></td>
<td>
<p>character string specifying the alternative hypothesis, must be one of &quot;two.sided&quot; (default), &quot;greater&quot; or &quot;less&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>Sample size</code></td>
<td>
<p>The required sample size.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>P. Lafaye de Micheaux, B. Liquet and J. Riou
</p>


<h3>References</h3>

<p>Lafaye de Micheaux P., Liquet B., Marque S., Riou J. (2014). Power and
Sample Size Determination in Clinical Trials With Multiple Primary
Continuous Correlated Endpoints, <em>Journal of
Biopharmaceutical Statistics</em>, 24, 378&ndash;397.
Adcock, C. J. (2007). Sample size determination: a review.
<em>Journal of the Royal Statistical Society: Series D (The Statistician)</em>, 46:261-283. </p>


<h3>See Also</h3>

<p><code><a href="#topic+global.1m.analysis">global.1m.analysis</a></code>,
<code><a href="#topic+indiv.1m.ssc">indiv.1m.ssc</a></code>,
<code><a href="#topic+indiv.1m.analysis">indiv.1m.analysis</a></code>,
<code><a href="#topic+global.1m.ssc">global.1m.ssc</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Sample size computation for the global method
bonferroni.1m.ssc(mean.diff = c(0.1, 0.2, 0.3), sd = c(1, 1,1 ), cor =
diag(1, 3))

## End(Not run)
</code></pre>

<hr>
<h2 id='complexity'>
Computation of the complexity of the numerical computations.
</h2><span id='topic+complexity'></span>

<h3>Description</h3>

<p>This function computes the complexity of our formulas.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>complexity(method, exchangeable, r, p, display = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="complexity_+3A_method">method</code></td>
<td>
<p>&quot;Bonferroni&quot;, &quot;Hochberg&quot; or &quot;Holm&quot;.</p>
</td></tr>
<tr><td><code id="complexity_+3A_exchangeable">exchangeable</code></td>
<td>
<p>Logical indicating if we are in the exchangeable
case or not.</p>
</td></tr>
<tr><td><code id="complexity_+3A_r">r</code></td>
<td>
<p>integer, r = 1, ..., m. Desired number of endpoints to be declared significant.</p>
</td></tr>
<tr><td><code id="complexity_+3A_p">p</code></td>
<td>
<p>integer, p = 1, ..., m. Indicates the number of false null hypotheses.</p>
</td></tr>
<tr><td><code id="complexity_+3A_display">display</code></td>
<td>
<p>Logical. Should we display the complexity.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Complexity of the formulas (i.e., number of individual probabilities
computed using the function <code>pmvt</code> (or <code>pmvnorm</code>) in the non
exchangeable case).
</p>


<h3>Author(s)</h3>

<p>P. Lafaye de Micheaux, B. Liquet and J. Riou
</p>


<h3>References</h3>

<p>Delorme P., Lafaye de Micheaux P., Liquet B., Riou, J. (2015). Type-II Generalized Family-Wise Error Rate
Formulas with Application to Sample Size Determination. <em>Statistics in Medicine.</em> 
Romano J. and Shaikh A. (2006) Stepup Procedures For Control of
Generalizations of the Familywise Error Rate. <em>The Annals of Statistics</em>,
34(4), 1850&ndash;1873.
</p>

<hr>
<h2 id='data'>
Simulated data
</h2><span id='topic+data.sim'></span><span id='topic+data'></span>

<h3>Description</h3>

<p>This simulated dataset contains three outcomes, and one adjustement variable, divided in two groups.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(data.sim)</code></pre>


<h3>Format</h3>

<p>A data frame with 100 observations on the following 5 variables.
</p>

<dl>
<dt><code>Y1</code></dt><dd><p>numeric vector of the first outcome</p>
</dd>
<dt><code>Y2</code></dt><dd><p>numeric vector of the second outcome</p>
</dd>
<dt><code>Y3</code></dt><dd><p>numeric vector of the third outcome</p>
</dd>
<dt><code>Group</code></dt><dd><p>binary vector of the group variable</p>
</dd>
<dt><code>A</code></dt><dd><p>numeric vector of the adjustment variable</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>data(data.sim)
</code></pre>

<hr>
<h2 id='df.compute'>
Computation of degrees of freedom.
</h2><span id='topic+df.compute'></span>

<h3>Description</h3>

<p>This function computes the degrees of freedom.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>df.compute(nE, nC, SigmaE = NULL, SigmaC = NULL, matrix.type = NULL,
equalSigmas = NULL, m = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="df.compute_+3A_ne">nE</code></td>
<td>
<p>Sample size for the experimental (test) group.</p>
</td></tr>
<tr><td><code id="df.compute_+3A_nc">nC</code></td>
<td>
<p>Sample size for the control group.</p>
</td></tr>
<tr><td><code id="df.compute_+3A_sigmae">SigmaE</code></td>
<td>
<p>NULL or a matrix indicating the covariances between the
primary endpoints in the experimental (test) group. See Details.</p>
</td></tr>
<tr><td><code id="df.compute_+3A_sigmac">SigmaC</code></td>
<td>
<p>NULL or a matrix indicating the covariances between the
primary endpoints in the control group. See Details.</p>
</td></tr>
<tr><td><code id="df.compute_+3A_matrix.type">matrix.type</code></td>
<td>
<p>NULL or an integer among 1, 2, 3, 4, giving the
type of the matrices 'SigmaE' and 'SigmaC'. See Details.</p>
</td></tr>
<tr><td><code id="df.compute_+3A_equalsigmas">equalSigmas</code></td>
<td>
<p>NULL or a logical indicating if 'SigmaC' and
'SigmaE' are equal. See Details.</p>
</td></tr>
<tr><td><code id="df.compute_+3A_m">m</code></td>
<td>
<p>NULL or the value for <code>m</code>. See Details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>You should provide either both <code>SigmaE</code>, <code>SigmaC</code> or both
<code>matrix.type</code>, <code>equalSigmas</code>. When you provide the former, the
latter should be set to NULL. And vice versa. 
</p>


<h3>Value</h3>

<table>
<tr><td><code>df</code></td>
<td>
<p>The degrees of freedom.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>P. Lafaye de Micheaux, B. Liquet and J. Riou
</p>


<h3>References</h3>

<p>Delorme P., Lafaye de Micheaux P., Liquet B., Riou, J. (2015). Type-II Generalized Family-Wise Error Rate
Formulas with Application to Sample Size Determination. <em>Statistics in Medicine.</em> 
Romano J. and Shaikh A. (2006) Stepup Procedures For Control of
Generalizations of the Familywise Error Rate. <em>The Annals of Statistics</em>,
34(4), 1850&ndash;1873.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+global.1m.analysis">global.1m.analysis</a></code>,
<code><a href="#topic+indiv.1m.ssc">indiv.1m.ssc</a></code>,
<code><a href="#topic+indiv.1m.analysis">indiv.1m.analysis</a></code>,
<code><a href="#topic+global.1m.ssc">global.1m.ssc</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# standard deviation of the treatment effect
var &lt;- c(0.3520^2,0.6219^2,0.5427^2,0.6075^2,0.6277^2,0.5527^2,0.8066^2)

# Correlation matrix 
cov &lt;- matrix(1,ncol=7,nrow=7)
cov[1,2:7] &lt;- cov[2:7,1] &lt;- c(0.1341692,0.1373891,0.07480123,0.1401267,0.1280336,0.1614103)
cov[2,3:7] &lt;- cov[3:7,2] &lt;- c(0.2874531,0.18451960,0.3156895,0.2954996,0.3963837)
cov[3,4:7] &lt;- cov[4:7,3] &lt;- c(0.19903400,0.2736123,0.2369907,0.3423579)
cov[4,5:7] &lt;- cov[5:7,4] &lt;- c(0.1915028,0.1558958,0.2376056)
cov[5,6:7] &lt;- cov[6:7,5] &lt;- c(0.2642217,0.3969920)
cov[6,7] &lt;- cov[7,6] &lt;- c(0.3352029)

# Covariance matrix
diag(cov) &lt;- var

df.compute(SigmaE = cov, SigmaC = cov, nE = 20, nC = 30)


## End(Not run)
</code></pre>

<hr>
<h2 id='global.1m.analysis'>Data analysis with a global method in the context of multiple continuous endpoints</h2><span id='topic+global.1m.analysis'></span>

<h3>Description</h3>

<p>This function aims at analysing <code class="reqn">m</code> multiple continuous endpoints with a global procedure. The clinical aim
is to be able to detect a mean difference between the test <code class="reqn">T</code> and
the control <code class="reqn">C</code> product for at least one endpoint among <code class="reqn">m</code>. This method is based on a multivariate model taking into account
the correlations between the <code class="reqn">m</code> endpoints and possibly some adjustment variables. The result gives only a global decision.</p>


<h3>Usage</h3>

<pre><code class='language-R'>global.1m.analysis(XC, XT, A, alpha = 0.05, n = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="global.1m.analysis_+3A_xc">XC</code></td>
<td>
<p>matrix of the outcome for the control group.</p>
</td></tr>
<tr><td><code id="global.1m.analysis_+3A_xt">XT</code></td>
<td>
<p>matrix of the outcome for the test group.</p>
</td></tr>
<tr><td><code id="global.1m.analysis_+3A_a">A</code></td>
<td>
<p>matrix of the adjustment variables.</p>
</td></tr>
<tr><td><code id="global.1m.analysis_+3A_n">n</code></td>
<td>
<p>sample size of a group. The sample size needs to be the same for each group.</p>
</td></tr>
<tr><td><code id="global.1m.analysis_+3A_alpha">alpha</code></td>
<td>
<p>value which corresponds to the chosen Type-I error rate bound.</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>Pvalue</code></td>
<td>
<p>the p-value of the global test.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>P. Lafaye de Micheaux, B. Liquet and J. Riou
</p>


<h3>References</h3>

<p>Lafaye de Micheaux P., Liquet B., Marque S., Riou J. (2014). Power and
Sample Size Determination in Clinical Trials With Multiple Primary
Continuous Correlated Endpoints, <em>Journal of
Biopharmaceutical Statistics</em>, 24, 378&ndash;397.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+global.1m.ssc">global.1m.ssc</a></code>,
<code><a href="#topic+indiv.1m.ssc">indiv.1m.ssc</a></code>,
<code><a href="#topic+indiv.1m.analysis">indiv.1m.analysis</a></code>,
<code><a href="#topic+bonferroni.1m.ssc">bonferroni.1m.ssc</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Calling the data
data(data.sim)

# Data analysis for the global method
n &lt;- nrow(data) / 2

XC &lt;- data[1:n, 1:3]
XT &lt;- data[(n + 1):(2 * n), 1:3]

global.1m.analysis(XC = XC, XT = XT, A = data[, 5])
</code></pre>

<hr>
<h2 id='global.1m.ssc'>
Sample Size Computation Based on a Global Procedure in the Context of Multiple Continuous Endpoints
</h2><span id='topic+global.1m.ssc'></span>

<h3>Description</h3>

<p>This function computes the sample size with a global method in the
context of <code class="reqn">m</code> multiple continuous endpoints. Two groups are
considered: <code class="reqn">C</code> for control and <code class="reqn">T</code> for treatment. The clinical aim
is to be able to detect a mean difference between the test and the control product
for at least one endpoint among <code class="reqn">m</code>. This method is based on a
multivariate model with co-variates taking into account
the correlations between the endpoints.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>global.1m.ssc(method, mean.diff, sd, cor, v = NULL, M = NULL, 
power = 0.8, alpha = 0.05)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="global.1m.ssc_+3A_method">method</code></td>
<td>
<p>either &quot;Model&quot; if no co-variates are involved and &quot;Adj.Model&quot; for a model with co-variates.</p>
</td></tr>
<tr><td><code id="global.1m.ssc_+3A_mean.diff">mean.diff</code></td>
<td>
<p>vector of the mean differences of the <code>m</code>
endpoints between both groups under the alternative hypothesis.</p>
</td></tr>
<tr><td><code id="global.1m.ssc_+3A_sd">sd</code></td>
<td>
<p>vector of the standard deviations of the <code>m</code>
endpoints. These are assumed identical for both groups.</p>
</td></tr>
<tr><td><code id="global.1m.ssc_+3A_cor">cor</code></td>
<td>
<p>correlation matrix between the endpoints. These are assumed identical for both groups.</p>
</td></tr>
<tr><td><code id="global.1m.ssc_+3A_v">v</code></td>
<td>
<p><code class="reqn">v</code> is a <code class="reqn">p\times1</code> vector whose <code class="reqn">l^{th}</code>
component is <code class="reqn">v_{l}=\bar{a}_{l}^C-\bar{a}_l^T</code>, where <code class="reqn">p</code> is
the number of adjustment variables, and <code class="reqn">\bar{a}_{l}^{i}</code> is the
mean of the adjustment variable <code class="reqn">a_{l}</code> for the group <code class="reqn">i</code>,
<code class="reqn">i = C, T</code>.</p>
</td></tr> 
<tr><td><code id="global.1m.ssc_+3A_m">M</code></td>
<td>
<p><code class="reqn">M</code> is a <code class="reqn">p\times p</code> matrix with general term <code class="reqn">M_{l,l'}=\left(\overline{a_la_{l'}}^C-\bar{a}_l^C\bar{a}_{l'}^C\right)+\left(\overline{a_{l}a_{l'}}^T-\bar{a}_l^T\bar{a}_{l'}^T\right)</code>.</p>
</td></tr>
<tr><td><code id="global.1m.ssc_+3A_power">power</code></td>
<td>
<p>value which corresponds to the chosen power.
</p>
</td></tr>
<tr><td><code id="global.1m.ssc_+3A_alpha">alpha</code></td>
<td>
<p>value which correponds to the chosen Type-I error rate bound.
</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>Sample size</code></td>
<td>
<p>The required sample size.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>P. Lafaye de Micheaux, B. Liquet and J. Riou
</p>


<h3>References</h3>

<p>Lafaye de Micheaux P., Liquet B., Marque S., Riou J. (2014). Power and
Sample Size Determination in Clinical Trials With Multiple Primary
Continuous Correlated Endpoints, <em>Journal of
Biopharmaceutical Statistics</em>, 24, 378&ndash;397.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+global.1m.analysis">global.1m.analysis</a></code>,
<code><a href="#topic+indiv.1m.ssc">indiv.1m.ssc</a></code>,
<code><a href="#topic+indiv.1m.analysis">indiv.1m.analysis</a></code>,
<code><a href="#topic+bonferroni.1m.ssc">bonferroni.1m.ssc</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Sample size computation for the global method 
global.1m.ssc(method = "Adj.Model", mean.diff = c(0.1, 0.2, 0.3), sd =
c(1, 1, 1), cor = diag(1, 3), v = -0.2, M = 0.46)

# Table 2 in our 2014 paper:
Sigma2 &lt;- matrix(c(5.58, 2, 1.24, 2, 4.29, 1.59, 1.24, 1.59, 4.09), ncol = 3)
sd2 &lt;- sqrt(diag(Sigma2))
cor2 &lt;- diag(1 / sd2) %*% Sigma2 %*% diag(1 / sd2)
mu2 &lt;- c(0.35, 0.28, 0.46)
m &lt;- 3
global.1m.ssc(method = "Model", mean.diff = mu2, sd = sd2, cor = cor2)
</code></pre>

<hr>
<h2 id='indiv.1m.analysis'>
Data analysis with an individual testing procedure in the context of multiple continuous endpoints
</h2><span id='topic+indiv.1m.analysis'></span><span id='topic+fwer'></span><span id='topic+test.indiv'></span>

<h3>Description</h3>

<p>This function aims at analysing some multiple continuous endpoints with
an individual testing procedure. This method, based on
Union-Intersection test procedure, allows one to take into account
the correlations between the different endpoints in the analysis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>indiv.1m.analysis(method, XC, XT, varX = NULL, alpha = 0.05,
alternative = "two.sided", n = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="indiv.1m.analysis_+3A_method">method</code></td>
<td>
<p>description of the covariance matrix estimation. Two
choices are possible: &quot;Unknown&quot; (normality assumption and unknown
covariance matrix) and &quot;Asympt&quot; (asymptotic context).</p>
</td></tr>
<tr><td><code id="indiv.1m.analysis_+3A_xc">XC</code></td>
<td>
<p>matrix of the outcomes for the control group.</p>
</td></tr>
<tr><td><code id="indiv.1m.analysis_+3A_xt">XT</code></td>
<td>
<p>matrix of the outcomes for the test group.</p>
</td></tr>
<tr><td><code id="indiv.1m.analysis_+3A_varx">varX</code></td>
<td>
<p>covariance matrix. Should be provided when 'method' = 'Known'.</p>
</td></tr>
<tr><td><code id="indiv.1m.analysis_+3A_alpha">alpha</code></td>
<td>
<p>value which correponds to the chosen Type-I error rate bound.</p>
</td></tr>
<tr><td><code id="indiv.1m.analysis_+3A_alternative">alternative</code></td>
<td>
<p>character string specifying the alternative hypothesis, must be one of &quot;two.sided&quot; (default), &quot;greater&quot; or &quot;less&quot;.</p>
</td></tr>
<tr><td><code id="indiv.1m.analysis_+3A_n">n</code></td>
<td>
<p>NULL. Sample size of a group, computed from <code>XC</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>UnAdjPvalue</code></td>
<td>
<p>unadjusted p-values.</p>
</td></tr>
<tr><td><code>AdjPvalue</code></td>
<td>
<p>corrected p-values.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>P. Lafaye de Micheaux, B. Liquet and J. Riou
</p>


<h3>References</h3>

<p>Lafaye de Micheaux P., Liquet B., Marque S., Riou J. (2014). Power and
Sample Size Determination in Clinical Trials With Multiple Primary
Continuous Correlated Endpoints, <em>Journal of
Biopharmaceutical Statistics</em>, 24, 378&ndash;397.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+global.1m.ssc">global.1m.ssc</a></code>,
<code><a href="#topic+indiv.1m.ssc">indiv.1m.ssc</a></code>,
<code><a href="#topic+global.1m.analysis">global.1m.analysis</a></code>,
<code><a href="#topic+bonferroni.1m.ssc">bonferroni.1m.ssc</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Calling the data
data(data.sim)

# Data analysis for the individual method
n &lt;- nrow(data) / 2 

XC &lt;- data[1:n, 1:3]
XT &lt;- data[(n + 1):(2 * n), 1:3]

indiv.1m.analysis(method = "UnKnown", XC = XC, XT = XT)
</code></pre>

<hr>
<h2 id='indiv.1m.ssc'>
Sample size computation with an individual testing procedure in the context of multiple continuous endpoints
</h2><span id='topic+indiv.1m.ssc'></span><span id='topic+asympt.ssc'></span><span id='topic+known.ssc'></span><span id='topic+unknown.ssc'></span>

<h3>Description</h3>

<p>This function computes the sample size with an individual testing procedure in the
context of multiple continuous endpoints. This method, based on the
Union-Intersection testing procedure, allows one to take into account
the correlation between the different endpoints in the computation of the sample size.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>indiv.1m.ssc(method, ES, cor, power = 0.8, alpha = 0.05, alternative =
"two.sided", tol = 1e-04, maxiter = 1000, tol.uniroot = 1e-04)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="indiv.1m.ssc_+3A_method">method</code></td>
<td>
<p>description of the covariance matrix estimation. Two
choices are possible: &quot;Unknown&quot; (normality assumption and unknown
covariance matrix) and &quot;Asympt&quot; (asymptotic context).
</p>
</td></tr>
<tr><td><code id="indiv.1m.ssc_+3A_es">ES</code></td>
<td>
<p>vector indicating the values of the effect size. The definition of the effect size is presented in the &quot;Details&quot; section.
</p>
</td></tr>
<tr><td><code id="indiv.1m.ssc_+3A_cor">cor</code></td>
<td>
<p>matrix indicating the correlation matrix between the endpoints.
</p>
</td></tr>
<tr><td><code id="indiv.1m.ssc_+3A_power">power</code></td>
<td>
<p>value which corresponds to the chosen power.
</p>
</td></tr>
<tr><td><code id="indiv.1m.ssc_+3A_alpha">alpha</code></td>
<td>
<p>value which correponds to the chosen Type-I error rate bound.
</p>
</td></tr>
<tr><td><code id="indiv.1m.ssc_+3A_alternative">alternative</code></td>
<td>
<p>character string specifying the alternative hypothesis, must be one of &quot;two.sided&quot; (default), &quot;greater&quot; or &quot;less&quot;.</p>
</td></tr>
<tr><td><code id="indiv.1m.ssc_+3A_tol">tol</code></td>
<td>
<p>the desired accuracy (convergence tolerance) for our algorithm.</p>
</td></tr>
<tr><td><code id="indiv.1m.ssc_+3A_maxiter">maxiter</code></td>
<td>
<p>maximum number of iterations.</p>
</td></tr>
<tr><td><code id="indiv.1m.ssc_+3A_tol.uniroot">tol.uniroot</code></td>
<td>
<p>desired accuracy (convergence tolerance) for the
<code>uniroot.integer</code> function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>ES</code>: The effect size definition parameter for the <code class="reqn">k^{th}</code> endpoint is defined as <code class="reqn">\frac{\mu^{T}_{k}-\mu^{C}_{k}}{\sigma^{*}_{k}}</code>, where <code class="reqn">\sigma^{*}_{k}</code> refers to the standard deviation
of the population from which the different treatment groups were taken
and <code class="reqn">\mu^{T}_{k}-\mu^{C}_{k}</code> is the true mean difference between the test and the control group for the <code class="reqn">k^{th}</code> group. We consider that: <code class="reqn">\sigma^{*}_{k}=\frac{\sigma^{2}_{k,T}+\sigma^{2}_{k,C}}{2}</code>.
</p>


<h3>Value</h3>

<table>
<tr><td><code>Adjusted Type-I error rate</code></td>
<td>
<p>adjusted Type-I error rate.</p>
</td></tr>
<tr><td><code>Sample size</code></td>
<td>
<p>the required sample size.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>P. Lafaye de Micheaux, B .Liquet and J .Riou
</p>


<h3>References</h3>

<p>Lafaye de Micheaux P., Liquet B., Marque S., Riou J. (2014). Power and
Sample Size Determination in Clinical Trials With Multiple Primary
Continuous Correlated Endpoints, <em>Journal of
Biopharmaceutical Statistics</em>, 24, 378&ndash;397.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+global.1m.ssc">global.1m.ssc</a></code>,
<code><a href="#topic+global.1m.analysis">global.1m.analysis</a></code>,
<code><a href="#topic+indiv.1m.analysis">indiv.1m.analysis</a></code>,
<code><a href="#topic+bonferroni.1m.ssc">bonferroni.1m.ssc</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Sample size computation for the individual method
indiv.1m.ssc(method = "Known", ES = c(0.1, 0.2, 0.3), cor = diag(1, 3))

# Table 2 in our 2014 paper:
Sigma2 &lt;- matrix(c(5.58, 2, 1.24, 2, 4.29, 1.59, 1.24, 1.59, 4.09), ncol = 3)
sd2 &lt;- sqrt(diag(Sigma2))
cor2 &lt;- diag(1 / sd2) %*% Sigma2 %*% diag(1 / sd2)
mu2 &lt;- c(0.35, 0.28, 0.46)
m &lt;- 3
indiv.1m.ssc(method = "Known", ES = mu2 / sd2, cor = cor2)
</code></pre>

<hr>
<h2 id='indiv.analysis'>
Data analysis using an individual testing procedure controlling the
q-gFWER in the context of <code class="reqn">m</code> multiple continuous endpoints
</h2><span id='topic+indiv.analysis'></span>

<h3>Description</h3>

<p>This function aims at analysing some multiple continuous endpoints with
individual testing procedures (Bonferroni, Holm, Hochberg). These procedures, based on a Union-Intersection test procedure, allow to take into account
the correlation between the different endpoints in the analysis. This
function uses critical values from Romano et al. to control the
q-gFWER. Different structures of the covariance matrices between
endpoints are considered.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>indiv.analysis(method, XE, XC, d, matrix.type, equalSigmas, alpha =
0.05, q = 1, rho = NULL, alternative = "greater", orig.Hochberg = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="indiv.analysis_+3A_method">method</code></td>
<td>
<p>&quot;Bonferroni&quot;, &quot;Holm&quot; or &quot;Hochberg&quot;. When <code>method =
  "Hochberg"</code>, we use critical values involving the D1 term in formula
(11) of Romano et al. in order to control strongly the <code class="reqn">q</code>-FWER.
If you want to use the original Hochberg's
procedure, set <code>orig.Hochberg</code> to <code>TRUE</code>. Even for
<code class="reqn">q=1</code>, this is a bad idea except when the p-values can be assumed independent.</p>
</td></tr>
<tr><td><code id="indiv.analysis_+3A_xe">XE</code></td>
<td>
<p>matrix (of size <code class="reqn">n_E \times m</code>) of the outcome for the experimental (test) group.</p>
</td></tr>
<tr><td><code id="indiv.analysis_+3A_xc">XC</code></td>
<td>
<p>matrix (of size <code class="reqn">n_C \times m</code>) of the outcome for the control group.</p>
</td></tr>
<tr><td><code id="indiv.analysis_+3A_d">d</code></td>
<td>
<p>vector of length <code>m</code> indicating the true value of the differences in means
under the null hypothesis.</p>
</td></tr>
<tr><td><code id="indiv.analysis_+3A_matrix.type">matrix.type</code></td>
<td>
<p>integer value equal to 1, 2, 3, 4 or 5. A value of 1
indicates multisample sphericity. A value of 2 indicates multisample
variance components. A value of 3 indicates multisample compound
symmetry. A value of 4 indicates multisample compound
symmetry with unequal individual (endpoints) variances. A value of 5 indicates unstructured variance components.</p>
</td></tr>
<tr><td><code id="indiv.analysis_+3A_equalsigmas">equalSigmas</code></td>
<td>
<p>logical. Indicates if <code class="reqn">\Sigma_E</code> is equal to <code class="reqn">\Sigma_C</code>.</p>
</td></tr>
<tr><td><code id="indiv.analysis_+3A_alpha">alpha</code></td>
<td>
<p>value which corresponds to the chosen q-gFWER type-I
error rate control bound.</p>
</td></tr>
<tr><td><code id="indiv.analysis_+3A_q">q</code></td>
<td>
<p>integer. Value of 'q' (q=1,...,m) in the q-gFWER of Romano et
al., which is the probability to make at least <code>q</code> false
rejections. The default value <code>q=1</code> corresponds to the classical FWER control.</p>
</td></tr>
<tr><td><code id="indiv.analysis_+3A_rho">rho</code></td>
<td>
<p>NULL or should be provided only if <code>matrix.type</code> is equal
to 3 or 4. This is the value of correlation for the compound symmetry case.</p>
</td></tr>
<tr><td><code id="indiv.analysis_+3A_alternative">alternative</code></td>
<td>
<p>NOT USED YET. Character string specifying the
alternative hypothesis, must be one of &quot;two.sided&quot;, &quot;greater&quot; or
&quot;less&quot;.</p>
</td></tr>
<tr><td><code id="indiv.analysis_+3A_orig.hochberg">orig.Hochberg</code></td>
<td>
<p>logical. To use the standard Hochberg's procedure.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list(stat = statvec, pvals = pvals, AdjPvals = pvals.adj, sig2hat = varhatvec)
</p>
<table>
<tr><td><code>stat</code></td>
<td>
<p>individual test statistic values.</p>
</td></tr>
<tr><td><code>pvals</code></td>
<td>
<p>non corrected p-values.</p>
</td></tr>
<tr><td><code>pvals.adj</code></td>
<td>
<p>corrected p-values.</p>
</td></tr>
<tr><td><code>sig2hat</code></td>
<td>
<p>estimated variance (i.e., square of denominator of the test statistic.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>P. Lafaye de Micheaux, B. Liquet and J. Riou
</p>


<h3>References</h3>

<p>Delorme P., Lafaye de Micheaux P., Liquet B., Riou, J. (2015). Type-II Generalized Family-Wise Error Rate
Formulas with Application to Sample Size Determination. Submitted to
<em>Statistics in Medicine.</em>
</p>
<p>Romano J. and Shaikh A. (2006) Stepup Procedures For Control of
Generalizations of the Familywise Error Rate. <em>The Annals of Statistics</em>,
34(4), 1850&ndash;1873.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+indiv.rm.ssc">indiv.rm.ssc</a></code>,
</p>

<hr>
<h2 id='indiv.rm.ssc'>
Sample size determination in the context of multiple continuous
endpoints with a control of the q-gFWER, for a given value of r-power
(generalized disjunctive power).
</h2><span id='topic+indiv.rm.ssc'></span>

<h3>Description</h3>

<p>This function computes the sample size for an analysis of <code>m</code> multiple tests with a control of the q-gFWER.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>indiv.rm.ssc(method, asympt = FALSE, r, m, p = m, nCovernE = 1,
muC = NULL, muE = NULL, d = NULL, delta = NULL, SigmaC = NULL,
SigmaE = NULL, power = 0.8, alpha = 0.05, interval = c(2, 2000), q = 1,
maxpts = 25000, abseps = 0.001, releps = 0, nbcores = 1, LB = FALSE,
orig.Hochberg = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="indiv.rm.ssc_+3A_method">method</code></td>
<td>
<p>&quot;Bonferroni&quot;, &quot;Hochberg&quot; or &quot;Holm&quot;.  When <code>method = 
  "Hochberg"</code>, we use critical values involving the D1 term in formula
(11) of Romano et al. in order to control strongly the <code class="reqn">q</code>-FWER.
If you want to use the original Hochberg's
procedure, set <code>orig.Hochberg</code> to <code>TRUE</code>. Even for
<code class="reqn">q=1</code>, this is a bad idea except when the p-values can be assumed independent.</p>
</td></tr>
<tr><td><code id="indiv.rm.ssc_+3A_asympt">asympt</code></td>
<td>
<p>logical. <code>TRUE</code> for the use of the asymptotic approximation by a
multivariate normal distribution or <code>FALSE</code> for the multivariate Student distribution.</p>
</td></tr>
<tr><td><code id="indiv.rm.ssc_+3A_r">r</code></td>
<td>
<p>integer, r = 1, ..., m. Desired number of endpoints to be declared significant.</p>
</td></tr>
<tr><td><code id="indiv.rm.ssc_+3A_m">m</code></td>
<td>
<p>integer. Number of endpoints.</p>
</td></tr>
<tr><td><code id="indiv.rm.ssc_+3A_p">p</code></td>
<td>
<p>integer, p = 1, ..., m. Indicates the number of false null hypotheses.</p>
</td></tr>
<tr><td><code id="indiv.rm.ssc_+3A_ncoverne">nCovernE</code></td>
<td>
<p>ratio of <code>nC</code> over <code>nE</code>.</p>
</td></tr>
<tr><td><code id="indiv.rm.ssc_+3A_muc">muC</code></td>
<td>
<p><code>NULL</code> or a vector of length <code>m</code> of the true means of the control
group for all endpoints under the alternative hypothesis. If <code>muC</code>, <code>muE</code> and <code>d</code> are <code>NULL</code>, then <code>delta</code> should
be provided instead.</p>
</td></tr>
<tr><td><code id="indiv.rm.ssc_+3A_mue">muE</code></td>
<td>
<p><code>NULL</code> or a vector of length <code>m</code> of the true means of the experimental (test) group for all endpoints under the alternative hypothesis.</p>
</td></tr>
<tr><td><code id="indiv.rm.ssc_+3A_d">d</code></td>
<td>
<p><code>NULL</code> or a a vector of length <code>m</code> indicating the true value of the differences in means
under the null hypothesis.</p>
</td></tr>
<tr><td><code id="indiv.rm.ssc_+3A_delta">delta</code></td>
<td>
<p>should be <code>NULL</code> if <code>muC</code>, <code>muE</code> and
<code>d</code> are provided. If not, it is equal to <code>muE - muC - d</code> and
these parameters should be set to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="indiv.rm.ssc_+3A_sigmac">SigmaC</code></td>
<td>
<p>matrix giving the covariances between the <code>m</code> primary endpoints in the control group.</p>
</td></tr>
<tr><td><code id="indiv.rm.ssc_+3A_sigmae">SigmaE</code></td>
<td>
<p>matrix giving the covariances between the <code>m</code> primary
endpoints in the experimental (test) group.</p>
</td></tr>
<tr><td><code id="indiv.rm.ssc_+3A_power">power</code></td>
<td>
<p>a value which correponds to the chosen r-power.</p>
</td></tr>
<tr><td><code id="indiv.rm.ssc_+3A_alpha">alpha</code></td>
<td>
<p>a value which corresponds to the chosen q-gFWER type-I control bound.</p>
</td></tr>
<tr><td><code id="indiv.rm.ssc_+3A_interval">interval</code></td>
<td>
<p>an interval of values in which to search for the sample size. Left
endpoint should be greater than or equal to 2.</p>
</td></tr>
<tr><td><code id="indiv.rm.ssc_+3A_q">q</code></td>
<td>
<p>integer. Value of 'q' (q=1,...,m) in the q-gFWER of Romano et
al., which is the probability to make at least <code>q</code> false
rejections. The default value <code>q=1</code> corresponds to the classical FWER control.</p>
</td></tr>
<tr><td><code id="indiv.rm.ssc_+3A_maxpts">maxpts</code></td>
<td>
<p>convergence parameter used in the <code>GenzBretz</code>
function. A good choice is
<code>min(25000 * 10 ^ true.complexity, .Machine$integer.max)</code>
where <code>true.complexity</code> is computed with the <code>complexity</code>
function. But note that this might considerably increase the
computation time!</p>
</td></tr>
<tr><td><code id="indiv.rm.ssc_+3A_abseps">abseps</code></td>
<td>
<p>convergence parameter used in the <code>GenzBretz</code>
function. A good choice is
<code>max(0.001 / true.complexity, 1e-08)</code>
where <code>true.complexity</code> is computed with the <code>complexity</code>
function. But note that this might considerably increase the
computation time!</p>
</td></tr>
<tr><td><code id="indiv.rm.ssc_+3A_releps">releps</code></td>
<td>
<p>relative error tolerance as double used in the
<code>GenzBretz</code> function.</p>
</td></tr>
<tr><td><code id="indiv.rm.ssc_+3A_nbcores">nbcores</code></td>
<td>
<p>integer. Number of cores to use for parallel computations.</p>
</td></tr>
<tr><td><code id="indiv.rm.ssc_+3A_lb">LB</code></td>
<td>
<p>logical. Should we use a load balancing parallel computation.</p>
</td></tr>
<tr><td><code id="indiv.rm.ssc_+3A_orig.hochberg">orig.Hochberg</code></td>
<td>
<p>logical. To use the standard Hochberg's procedure.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The required sample size.
</p>


<h3>Note</h3>

<p>Results can differ from one time to another because the results of the
function <code>pmvt</code> are random. If this is the case, you should
consider increasing <code>maxpts</code> and decreasing <code>abseps</code>. In any
case, you should always double check using one of the functions
<code>Psirms</code>, <code>Psirmu</code> or <code>Psirmd</code> if the sample size you
obtained gives you the intended power, with an acceptable error (or at
least compute the power a few times with various seeds to see if results
are stable).
</p>


<h3>Author(s)</h3>

<p>P. Lafaye de Micheaux, B. Liquet and J. Riou
</p>


<h3>References</h3>

<p>Delorme P., Lafaye de Micheaux P., Liquet B., Riou, J. (2015). Type-II Generalized Family-Wise Error Rate
Formulas with Application to Sample Size Determination. Submitted to
<em>Statistics in Medicine.</em>
</p>
<p>Romano J. and Shaikh A. (2006) Stepup Procedures For Control of
Generalizations of the Familywise Error Rate. <em>The Annals of Statistics</em>,
34(4), 1850&ndash;1873.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+indiv.analysis">indiv.analysis</a></code>,
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Pneumovacs example (takes 37 mn to compute on 1 core)

# Treatment effect
delta &lt;- c(0.55, 0.34, 0.38, 0.20, 0.70, 0.38, 0.86)

# Variances of the m endpoints
var &lt;- c(0.3520, 0.6219, 0.5427, 0.6075, 0.6277,
0.5527, 0.8066) ^ 2

# Covariance matrix
cov &lt;- matrix(1, ncol = 7, nrow = 7)
cov[1, 2:7] &lt;- cov[2:7, 1] &lt;- c(0.1341692, 0.1373891, 0.07480123,
0.1401267, 0.1280336, 0.1614103)
cov[2, 3:7] &lt;- cov[3:7, 2] &lt;- c(0.2874531, 0.18451960, 0.3156895,
0.2954996, 0.3963837)
cov[3, 4:7] &lt;- cov[4:7, 3] &lt;- c(0.19903400, 0.2736123, 0.2369907, 0.3423579)
cov[4, 5:7] &lt;- cov[5:7, 4] &lt;- c(0.1915028, 0.1558958, 0.2376056)
cov[5, 6:7] &lt;- cov[6:7, 5] &lt;- c(0.2642217, 0.3969920)
cov[6, 7] &lt;- cov[7, 6] &lt;- 0.3352029
diag(cov) &lt;- var

indiv.rm.ssc(method = "Hochberg", asympt = FALSE, r = 3, m = 7, p = 7, nCovernE = 1,
muC = NULL, muE = NULL, d = NULL, delta = delta, SigmaC = cov,
SigmaE = cov, power = 0.8, alpha = 0.05, interval = c(10, 2000), q = 1)

# Pre-RELAX-AHF example from the paper by Teerlink et al. (2009),
# Relaxin for the treatment of patients with acute heart failure
# (Pre-RELAX-AHF): a multicentre, randomised,
# placebo-controlled, parallel-group, dose-finding phase IIb
# study, Lancet, 373: 1429--39

# Table 2 page 1432:
# ------------------
# Proportion with moderately or markedly better dyspnoea at 6 h, 12 h, and 24 h (Likert): 23% 40%
# Dyspnoea AUC change from baseline to day 5 (VAS [mmxh]): 1679 (2556) 2567 (2898) 
# Worsening heart failure through day 5: 21% 12%
# Length of stay (days): 12.0 (7.3) 10.2 (6.1) 
# Days alive out of hospital: 44.2 (14.2) 47.9 (10.1) 
# KM cardiovascular death or readmission (HR, 95% CI): 17.2% 2.6% (0.13, 0.02--1.03); p=0.053 
# KM cardiovascular death (HR, 95% CI):  14.3% 0.0% (0.00, 0.00--0.98); p=0.046 

# Table 4 page 1436:
# ------------------
# &gt;=25% increase at day 5: 8 (13%) 9 (21%) 
# &gt;=26 micro-mol/L increase at days 5 and 14: 4 (7%)  3 (7%) 
muC &lt;- c(23 / 100, 1679, 1 - 21 / 100, -12.0, 44.2, 1 - 17.2 / 100, 1 -
          14.3 / 100, 13 / 100, 7 / 100)
muE &lt;- c(40 / 100, 2567, 1 - 12 / 100, -10.2, 47.9, 1 - 2.60 / 100, 1,
         21 / 100, 7 / 100)

sdC &lt;- c(sqrt(0.23 * (1 - 0.23)), 2556, sqrt(0.79 * (1 - 0.79)), 7.3,
 14.2, sqrt(0.828 * (1 - 0.828)), sqrt(0.857 * (1 - 0.857)), sqrt(0.13 *
 (1 - 0.13)), sqrt(0.07 * (1 - 0.07)))
sdE &lt;- c(sqrt(0.4 * (1 - 0.4))  , 2898, sqrt(0.88 * (1 - 0.88)), 6.1,
 10.1, sqrt(0.974 * (1 - 0.974)), 1e-12                    , sqrt(0.21 * (1 - 0.21)), 
 sqrt(0.07 * (1 - 0.07)))

m &lt;- 9
rho &lt;- 0.1
cor &lt;- matrix(rho, nrow = m, ncol = m)
diag(cor) &lt;- 1
sd.pooled &lt;- sqrt(0.5 * sdE + 0.5 * sdC)
SigmaE &lt;- diag(sdE) %*% cor %*% diag(sdE)
SigmaC &lt;-diag(sdC) %*% cor %*% diag(sdC)
indiv.rm.ssc(method = "Bonferroni", asympt = FALSE, r = 6, m = 9, p = 9, nCovernE = 1,
  muC = NULL, muE = NULL, d = rep(0.0, m), delta = (muE - muC) / sd.pooled,
  SigmaC = cor, SigmaE = cor, power = 0.8, alpha = 0.1, interval = c(2, 500),
  q = 1, maxpts = 25000, abseps = 0.01, nbcores = 1, LB = TRUE)


## End(Not run)
</code></pre>

<hr>
<h2 id='matrix.type.compute'>
Computation of matrix type
</h2><span id='topic+matrix.type.compute'></span>

<h3>Description</h3>

<p>This function determines the type of matrix structure of <code class="reqn">\Sigma_E</code>
and <code class="reqn">\Sigma_C</code>, which can be multisample
sphericity (type 1), multisample variance components (type 2), multisample compound
symmetry (type 3) or unstructured variance components (type 4).</p>


<h3>Usage</h3>

<pre><code class='language-R'>matrix.type.compute(SigmaE, SigmaC, display.type = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="matrix.type.compute_+3A_sigmae">SigmaE</code></td>
<td>
<p>matrix giving the covariances between the
<code>m</code> primary endpoints in the experimental (test) group.</p>
</td></tr>
<tr><td><code id="matrix.type.compute_+3A_sigmac">SigmaC</code></td>
<td>
<p>matrix giving the covariances between the <code>m</code> primary endpoints in the control group.</p>
</td></tr>
<tr><td><code id="matrix.type.compute_+3A_display.type">display.type</code></td>
<td>
<p>Logical. Should we display the (name of) type of
the matrices.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Integer indicating the structure of the matrices: 1 if both are of type
1, 2 if both are of type 2, 3 if both are of type 3 or 4 if one of them
is of type 4. 
</p>


<h3>Author(s)</h3>

<p>P. Lafaye de Micheaux, B. Liquet and J. Riou
</p>


<h3>See Also</h3>

<p><code><a href="#topic+indiv.analysis">indiv.analysis</a></code>,
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Variances of the m endpoints
var &lt;- c(0.3520, 0.6219, 0.5427, 0.6075, 0.6277,
0.5527, 0.8066) ^ 2

# Covariance matrix
cov &lt;- matrix(1, ncol = 7, nrow = 7)
 cov[1, 2:7] &lt;- cov[2:7, 1] &lt;- c(0.1341692, 0.1373891, 0.07480123,
0.1401267, 0.1280336, 0.1614103)
cov[2, 3:7] &lt;- cov[3:7, 2] &lt;- c(0.2874531, 0.18451960, 0.3156895,
0.2954996, 0.3963837)
cov[3, 4:7] &lt;- cov[4:7, 3] &lt;- c(0.19903400, 0.2736123, 0.2369907, 0.3423579)
cov[4, 5:7] &lt;- cov[5:7, 4] &lt;- c(0.1915028, 0.1558958, 0.2376056)
cov[5, 6:7] &lt;- cov[6:7, 5] &lt;- c(0.2642217, 0.3969920)
cov[6, 7] &lt;- cov[7, 6] &lt;- 0.3352029
diag(cov) &lt;- var

matrix.type.compute(SigmaE = cov, SigmaC = cov, display = TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='montecarlo'>
Monte carlo computation of power.
</h2><span id='topic+montecarlo'></span>

<h3>Description</h3>

<p>This function approximates the power for a given sample size using a Monte
Carlo simulation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>montecarlo(method, M = 100000, nE, r, m, nCovernE = 1, muC,
muE, d = rep(0.0, m), SigmaE, SigmaC, alpha =
0.05, q = 1, nbcores = parallel::detectCores() - 1, alternative =
"greater",
orig.Hochberg = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="montecarlo_+3A_method">method</code></td>
<td>
<p>&quot;Bonferroni&quot;, &quot;Holm&quot; or &quot;Hochberg&quot;.  When <code>method =
  "Hochberg"</code>, we use critical values involving the D1 term in formula
(11) of Romano et al. in order to control strongly the <code class="reqn">q</code>-FWER.
If you want to use the original Hochberg's
procedure, set <code>orig.Hochberg</code> to <code>TRUE</code>. Even for
<code class="reqn">q=1</code>, this is a bad idea except when the p-values can be assumed independent.</p>
</td></tr>
<tr><td><code id="montecarlo_+3A_m">M</code></td>
<td>
<p>number of Monte Carlo repetitions. Dmitrienko et al. (2013)
suggested to take <code>M = 10 ^ 5</code>.</p>
</td></tr>
<tr><td><code id="montecarlo_+3A_ne">nE</code></td>
<td>
<p>integer. Sample size for the experimental (test) group.</p>
</td></tr>
<tr><td><code id="montecarlo_+3A_r">r</code></td>
<td>
<p>integer, r = 1, ..., m. Desired number of endpoints to be declared significant.</p>
</td></tr>
<tr><td><code id="montecarlo_+3A_m">m</code></td>
<td>
<p>integer. Number of endpoints.</p>
</td></tr>
<tr><td><code id="montecarlo_+3A_ncoverne">nCovernE</code></td>
<td>
<p>ratio of <code>nC</code> over <code>nE</code>.</p>
</td></tr>
<tr><td><code id="montecarlo_+3A_muc">muC</code></td>
<td>
<p>vector of length <code>m</code> of the true means of the control
group for all endpoints under the alternative hypothesis.</p>
</td></tr>
<tr><td><code id="montecarlo_+3A_mue">muE</code></td>
<td>
<p>vector of length <code>m</code> of the true means of the experimental (test) group for all endpoints under the alternative hypothesis.</p>
</td></tr>
<tr><td><code id="montecarlo_+3A_d">d</code></td>
<td>
<p>vector of length <code>m</code> indicating the true value of the differences in means
under the null hypothesis.</p>
</td></tr>
<tr><td><code id="montecarlo_+3A_sigmae">SigmaE</code></td>
<td>
<p>matrix indicating the covariances between the <code>m</code> 
primary endpoints in the experimental (test) group. See Details.</p>
</td></tr>
<tr><td><code id="montecarlo_+3A_sigmac">SigmaC</code></td>
<td>
<p>matrix indicating the covariances between the <code>m</code> 
primary endpoints in the control group. See Details.</p>
</td></tr>
<tr><td><code id="montecarlo_+3A_alpha">alpha</code></td>
<td>
<p>a value which corresponds to the chosen q-gFWER type-I control bound.</p>
</td></tr>
<tr><td><code id="montecarlo_+3A_q">q</code></td>
<td>
<p>integer. Value of 'q' (q = 1, ..., m) in the q-gFWER of Romano et
al., which is the probability to make at least <code>q</code> false
rejections. The default value <code>q=1</code> corresponds to the classical FWER control.</p>
</td></tr>
<tr><td><code id="montecarlo_+3A_nbcores">nbcores</code></td>
<td>
<p>number of cores to use for the computations.</p>
</td></tr>
<tr><td><code id="montecarlo_+3A_alternative">alternative</code></td>
<td>
<p>NOT USED YET. Character string specifying the alternative hypothesis, must be one of &quot;two.sided&quot;, &quot;greater&quot; or &quot;less&quot;.</p>
</td></tr>
<tr><td><code id="montecarlo_+3A_orig.hochberg">orig.Hochberg</code></td>
<td>
<p>logical. To use the standard Hochberg's procedure.</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>rpowBonf or rpowHoch or rpowHolm</code></td>
<td>
<p>List with one element giving the computed power.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>P. Lafaye de Micheaux, B. Liquet and J. Riou
</p>


<h3>References</h3>

<p>Delorme P., Lafaye de Micheaux P., Liquet B., Riou, J. (2015). Type-II Generalized Family-Wise Error Rate
Formulas with Application to Sample Size Determination. Submitted to <em>Statistics
in Medicine.</em> 
</p>
<p>Romano J. and Shaikh A. (2006) Stepup Procedures For Control of
Generalizations of the Familywise Error Rate. <em>The Annals of Statistics</em>,
34(4), 1850&ndash;1873.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+indiv.analysis">indiv.analysis</a></code>,
</p>

<hr>
<h2 id='plot.rPower'>
Plot of an rPower object
</h2><span id='topic+plot.rPower'></span>

<h3>Description</h3>

<p>For an <code>rPower</code> object which has been produced by <code><a href="#topic+montecarlo">montecarlo</a></code>, this function plots the distribution (estimated by Monte-Carlo) of the number of significant results (i.e, the realized values <code class="reqn">r</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'rPower'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.rPower_+3A_x">x</code></td>
<td>

<p>The name of an object of class <code>rPower</code>.
</p>
</td></tr>
<tr><td><code id="plot.rPower_+3A_...">...</code></td>
<td>
<p>Some methods for this generic require additional arguments. None are used in this method.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns graphs.
</p>


<h3>Author(s)</h3>

<p>P. Lafaye de Micheaux, B. Liquet and J. Riou
</p>


<h3>References</h3>

<p>Delorme P., Lafaye de Micheaux P., Liquet B., Riou, J. (2015). Type-II Generalized Family-Wise Error Rate
Formulas with Application to Sample Size Determination. Submitted to <em>Statistics
in Medicine.</em> </p>


<h3>See Also</h3>

<p><code><a href="#topic+montecarlo">montecarlo</a></code>
</p>

<hr>
<h2 id='Psirmd'>
Computation of power for step-down (Holm) procedure.
</h2><span id='topic+Psirmd'></span>

<h3>Description</h3>

<p>This function computes the power for an analysis of <code>m</code> multiple
tests with a control of the q-gFWER with the Holm procedure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Psirmd(r, m, p = m, nE, nCovernE = 1, delta, SigmaC, SigmaE,
alpha = 0.05, q = 1, asympt = FALSE,
maxpts = 25000, abseps = 0.001, releps = 0, nbcores = 1, LB = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Psirmd_+3A_r">r</code></td>
<td>
<p>integer, r = 1, ..., m. Desired number of endpoints to be declared significant.</p>
</td></tr>
<tr><td><code id="Psirmd_+3A_m">m</code></td>
<td>
<p>integer. Number of endpoints.</p>
</td></tr>
<tr><td><code id="Psirmd_+3A_p">p</code></td>
<td>
<p>integer, p = 1, ..., m. Indicates the number of false null hypotheses.</p>
</td></tr>
<tr><td><code id="Psirmd_+3A_ne">nE</code></td>
<td>
<p>integer. Sample size for the experimental (test) group.</p>
</td></tr>
<tr><td><code id="Psirmd_+3A_ncoverne">nCovernE</code></td>
<td>
<p>Ratio of <code>nC</code> over <code>nE</code>.</p>
</td></tr>
<tr><td><code id="Psirmd_+3A_delta">delta</code></td>
<td>
<p>vector of length <code>m</code> equal to <code>muE - muC - d</code>.</p>
</td></tr>
<tr><td><code id="Psirmd_+3A_sigmac">SigmaC</code></td>
<td>
<p>matrix giving the covariances between the <code>m</code> primary endpoints in the control group.</p>
</td></tr>
<tr><td><code id="Psirmd_+3A_sigmae">SigmaE</code></td>
<td>
<p>matrix giving the covariances between the <code>m</code> primary
endpoints in the experimental (test) group.</p>
</td></tr>
<tr><td><code id="Psirmd_+3A_alpha">alpha</code></td>
<td>
<p>a value which corresponds to the chosen q-gFWER type-I control bound.</p>
</td></tr>
<tr><td><code id="Psirmd_+3A_q">q</code></td>
<td>
<p>integer. Value of 'q' (q=1,...,m) in the q-gFWER of Romano et
al., which is the probability to make at least <code>q</code> false
rejections. The default value <code>q=1</code> corresponds to the classical FWER control.</p>
</td></tr>
<tr><td><code id="Psirmd_+3A_asympt">asympt</code></td>
<td>
<p>logical. <code>TRUE</code> for the use of the asymptotic approximation by a
multivariate normal distribution or <code>FALSE</code> for the multivariate
Student distribution.</p>
</td></tr>
<tr><td><code id="Psirmd_+3A_maxpts">maxpts</code></td>
<td>
<p>convergence parameter used in the <code>GenzBretz</code>
function. A suggested choice is <code>min(25000 * true.complexity, .Machine$integer.max)</code>
where <code>true.complexity</code> is computed with the <code>complexity</code>
function. 
But note that this might considerably increase the
computation time!</p>
</td></tr>
<tr><td><code id="Psirmd_+3A_abseps">abseps</code></td>
<td>
<p>convergence parameter used in the <code>GenzBretz</code>
function. A suggested choice is <code>max(0.001 / true.complexity, 1e-08)</code>
where <code>true.complexity</code> is computed with the <code>complexity</code>
function. 
But note that this might considerably increase the
computation time!</p>
</td></tr>
<tr><td><code id="Psirmd_+3A_releps">releps</code></td>
<td>
<p>relative error tolerance as double used in the
<code>GenzBretz</code> function.</p>
</td></tr>
<tr><td><code id="Psirmd_+3A_nbcores">nbcores</code></td>
<td>
<p>integer. Number of cores to use for parallel computations.</p>
</td></tr>
<tr><td><code id="Psirmd_+3A_lb">LB</code></td>
<td>
<p>logical. Should we use a load balancing parallel computation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List with two components:
</p>
<table>
<tr><td><code>pow</code></td>
<td>
<p>The computed power.</p>
</td></tr>
<tr><td><code>error</code></td>
<td>
<p>The sum of the absolute estimated errors for each call
to the <code>pmvt</code> (or <code>pmvnorm</code>) function. The number of such
calls is given (in the non exchangeable case) by the function <code>complexity</code>. Note that in the
exchangeable case, some probabilities are weighted. So an error
committed on such a probability is also inflated with the same
weight. Note also that this global error does not take into account
the signs of the individual errors and is thus most certainly higher
than the true error. In other words, you are 99 percent sure that
the true power is between 'pow' - 'error' and 'pow' + 'error', but
it is also probably much closer to 'pow', particularly if the
complexity is large.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Results can differ from one time to another because the results of the
function <code>pmvt</code> are random.  If this is the case, you should
consider increasing <code>maxpts</code> and decreasing <code>abseps</code>.
</p>


<h3>Author(s)</h3>

<p>P. Lafaye de Micheaux, B. Liquet and J. Riou
</p>


<h3>References</h3>

<p>Delorme P., Lafaye de Micheaux P., Liquet B., Riou, J. (2015). Type-II Generalized Family-Wise Error Rate
Formulas with Application to Sample Size Determination. Submitted to
<em>Statistics in Medicine.</em>
</p>
<p>Romano J. and Shaikh A. (2006) Stepup Procedures For Control of
Generalizations of the Familywise Error Rate. <em>The Annals of Statistics</em>,
34(4), 1850&ndash;1873.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+indiv.analysis">indiv.analysis</a></code>,
</p>

<hr>
<h2 id='Psirms'>
Computation of power for single step (Bonferroni) procedure.
</h2><span id='topic+Psirms'></span>

<h3>Description</h3>

<p>This function computes the power for an analysis of <code class="reqn">m</code> multiple
tests with a control of the q-gFWER by a Bonferroni procedure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Psirms(r, m, p = m, nE, nCovernE = 1, delta, SigmaC, SigmaE,
alpha = 0.05, q = 1, asympt = FALSE,
maxpts = 25000, abseps = 0.001, releps = 0, nbcores = 1, LB = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Psirms_+3A_r">r</code></td>
<td>
<p>integer, r = 1, ..., m. Desired number of endpoints to be declared significant.</p>
</td></tr>
<tr><td><code id="Psirms_+3A_m">m</code></td>
<td>
<p>integer. Number of endpoints.</p>
</td></tr>
<tr><td><code id="Psirms_+3A_p">p</code></td>
<td>
<p>integer, p = 1, ..., m. Indicates the number of false null hypotheses.</p>
</td></tr>
<tr><td><code id="Psirms_+3A_ne">nE</code></td>
<td>
<p>integer. Sample size for the experimental (test) group.</p>
</td></tr>
<tr><td><code id="Psirms_+3A_ncoverne">nCovernE</code></td>
<td>
<p>Ratio of <code>nC</code> over <code>nE</code>.</p>
</td></tr>
<tr><td><code id="Psirms_+3A_delta">delta</code></td>
<td>
<p>vector of length <code>m</code> equal to <code>muE - muC - d</code>.</p>
</td></tr>
<tr><td><code id="Psirms_+3A_sigmac">SigmaC</code></td>
<td>
<p>matrix giving the covariances between the <code>m</code> primary endpoints in the control group.</p>
</td></tr>
<tr><td><code id="Psirms_+3A_sigmae">SigmaE</code></td>
<td>
<p>matrix giving the covariances between the <code>m</code> primary
endpoints in the experimental (test) group.</p>
</td></tr>
<tr><td><code id="Psirms_+3A_alpha">alpha</code></td>
<td>
<p>a value which corresponds to the chosen q-gFWER type-I control bound.</p>
</td></tr>
<tr><td><code id="Psirms_+3A_q">q</code></td>
<td>
<p>integer. Value of 'q' (q=1,...,m) in the q-gFWER of Romano et
al., which is the probability to make at least <code>q</code> false
rejections. The default value <code>q=1</code> corresponds to the classical FWER control.</p>
</td></tr>
<tr><td><code id="Psirms_+3A_asympt">asympt</code></td>
<td>
<p>logical. <code>TRUE</code> for the use of the asymptotic approximation by a
multivariate normal distribution or <code>FALSE</code> for the multivariate
Student distribution.</p>
</td></tr>
<tr><td><code id="Psirms_+3A_maxpts">maxpts</code></td>
<td>
<p>convergence parameter used in the <code>GenzBretz</code>
function. A suggested choice is <code>min(25000 * true.complexity, .Machine$integer.max)</code>
where <code>true.complexity</code> is computed with the <code>complexity</code> function. But note that this might considerably increase the
computation time!</p>
</td></tr>
<tr><td><code id="Psirms_+3A_abseps">abseps</code></td>
<td>
<p>convergence parameter used in the <code>GenzBretz</code>
function. A suggested choice is <code>max(0.001 / true.complexity, 1e-08)</code>
where <code>true.complexity</code> is computed with the <code>complexity</code> function. But note that this might considerably increase the
computation time!</p>
</td></tr>
<tr><td><code id="Psirms_+3A_releps">releps</code></td>
<td>
<p>relative error tolerance as double used in the
<code>GenzBretz</code> function.</p>
</td></tr>
<tr><td><code id="Psirms_+3A_nbcores">nbcores</code></td>
<td>
<p>integer. Number of cores to use for parallel computations.</p>
</td></tr>
<tr><td><code id="Psirms_+3A_lb">LB</code></td>
<td>
<p>logical. Should we use a load balancing parallel computation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List with two components:
</p>
<table>
<tr><td><code>pow</code></td>
<td>
<p>The computed power.</p>
</td></tr>
<tr><td><code>error</code></td>
<td>
<p>The total sum of the absolute estimated errors for each call
to the <code>pmvt</code> (or <code>pmvnorm</code>) function. The number of such
calls is given (in the non exchangeable case) by the function <code>complexity</code>. Note that in the
exchangeable case, some probabilities are weighted. So an error
committed on such a probability is also inflated with the same weight. Note also that this global error does not take into account
the signs of the individual errors and is thus most certainly higher
than the true error. In other words, you are 99 percent sure that
the true power is between 'pow' - 'error' and 'pow' + 'error', but
it is also probably much closer to 'pow', particularly if the
complexity is large.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Results can differ from one time to another because the results of the
function <code>pmvt</code> are random.  If this is the case, you should
consider increasing <code>maxpts</code> and decreasing <code>abseps</code>.
</p>


<h3>Author(s)</h3>

<p>P. Lafaye de Micheaux, B. Liquet and J. Riou
</p>


<h3>References</h3>

<p>Delorme P., Lafaye de Micheaux P., Liquet B., Riou, J. (2015). Type-II Generalized Family-Wise Error Rate
Formulas with Application to Sample Size Determination. Submitted to <em>Statistics
in Medicine.</em> 
</p>
<p>Romano J. and Shaikh A. (2006) Stepup Procedures For Control of
Generalizations of the Familywise Error Rate. <em>The Annals of Statistics</em>,
34(4), 1850&ndash;1873.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+indiv.analysis">indiv.analysis</a></code>,
</p>

<hr>
<h2 id='Psirmu'>
Computation of power for step-up (Hochberg) procedure.
</h2><span id='topic+Psirmu'></span>

<h3>Description</h3>

<p>This function computes the power for an analysis of m multiple tests
with a control of the q-gFWER with the Hochberg procedure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Psirmu(r, m, p = m, nE, nCovernE = 1, delta, SigmaC, SigmaE,
alpha = 0.05, q = 1, asympt = FALSE,
maxpts = 25000, abseps = 0.001, releps = 0, nbcores = 1, LB = FALSE,
orig.Hochberg = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Psirmu_+3A_r">r</code></td>
<td>
<p>integer, r = 1, ..., m. Desired number of endpoints to be declared significant.</p>
</td></tr>
<tr><td><code id="Psirmu_+3A_m">m</code></td>
<td>
<p>integer. Number of endpoints.</p>
</td></tr>
<tr><td><code id="Psirmu_+3A_p">p</code></td>
<td>
<p>integer, p = 1, ..., m. Indicates the number of false null hypotheses.</p>
</td></tr>
<tr><td><code id="Psirmu_+3A_ne">nE</code></td>
<td>
<p>integer. Sample size for the experimental (test) group.</p>
</td></tr>
<tr><td><code id="Psirmu_+3A_ncoverne">nCovernE</code></td>
<td>
<p>Ratio of <code>nC</code> over <code>nE</code>.</p>
</td></tr>
<tr><td><code id="Psirmu_+3A_delta">delta</code></td>
<td>
<p>vector of length <code>m</code> equal to <code>muE - muC - d</code>.</p>
</td></tr>
<tr><td><code id="Psirmu_+3A_sigmac">SigmaC</code></td>
<td>
<p>matrix giving the covariances between the <code>m</code> primary endpoints in the control group.</p>
</td></tr>
<tr><td><code id="Psirmu_+3A_sigmae">SigmaE</code></td>
<td>
<p>matrix giving the covariances between the <code>m</code> primary
endpoints in the experimental (test) group.</p>
</td></tr>
<tr><td><code id="Psirmu_+3A_alpha">alpha</code></td>
<td>
<p>a value which corresponds to the chosen q-gFWER type-I control bound.</p>
</td></tr>
<tr><td><code id="Psirmu_+3A_q">q</code></td>
<td>
<p>integer. Value of 'q' (q=1,...,m) in the q-gFWER of Romano et
al., which is the probability to make at least <code>q</code> false
rejections. The default value <code>q=1</code> corresponds to the classical FWER control.</p>
</td></tr>
<tr><td><code id="Psirmu_+3A_asympt">asympt</code></td>
<td>
<p>logical. <code>TRUE</code> for the use of the asymptotic approximation by a
multivariate normal distribution or <code>FALSE</code> for the multivariate
Student distribution.</p>
</td></tr>
<tr><td><code id="Psirmu_+3A_maxpts">maxpts</code></td>
<td>
<p>convergence parameter used in the <code>GenzBretz</code>
function. A suggested choice is <code>min(25000 * true.complexity, .Machine$integer.max)</code>
where <code>true.complexity</code> is computed with the <code>complexity</code> function. But note that this might considerably increase the
computation time!</p>
</td></tr>
<tr><td><code id="Psirmu_+3A_abseps">abseps</code></td>
<td>
<p>convergence parameter used in the <code>GenzBretz</code>
function. A suggested choice is <code>max(0.001 / true.complexity, 1e-08)</code>
where <code>true.complexity</code> is computed with the <code>complexity</code> function. But note that this might considerably increase the
computation time!</p>
</td></tr>
<tr><td><code id="Psirmu_+3A_releps">releps</code></td>
<td>
<p>relative error tolerance as double used in the
<code>GenzBretz</code> function.</p>
</td></tr>
<tr><td><code id="Psirmu_+3A_nbcores">nbcores</code></td>
<td>
<p>integer. Number of cores to use for parallel computations.</p>
</td></tr>
<tr><td><code id="Psirmu_+3A_lb">LB</code></td>
<td>
<p>logical. Should we use a load balancing parallel computation.</p>
</td></tr>
<tr><td><code id="Psirmu_+3A_orig.hochberg">orig.Hochberg</code></td>
<td>
<p>logical. To use the standard Hochberg's procedure.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List with two components:
</p>
<table>
<tr><td><code>pow</code></td>
<td>
<p>The computed power.</p>
</td></tr>
<tr><td><code>error</code></td>
<td>
<p>The sum of the absolute estimated errors for each call
to the <code>pmvt</code> (or <code>pmvnorm</code>) function. The number of such
calls is given (in the non exchangeable case) by the function <code>complexity</code>. Note that in the
exchangeable case, some probabilities are weighted. So an error
committed on such a probability is also inflated with the same weight. Note also that this global error does not take into account
the signs of the individual errors and is thus most certainly higher
than the true error. In other words, you are 99 percent sure that
the true power is between 'pow' - 'error' and 'pow' + 'error', but
it is also probably much closer to 'pow', particularly if the
complexity is large.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Note that we use critical values involving the D1 term in formula
(11) of Romano et al. in order to control strongly the <code class="reqn">q</code>-FWER.
If you want to use the original Hochberg's
procedure, set <code>orig.Hochberg</code> to <code>TRUE</code>. Even for
<code class="reqn">q=1</code>, this is a bad idea except when the p-values can be assumed
independent.
</p>
<p>Results can differ from one time to another because the results of the
function <code>pmvt</code> are random.  If this is the case, you should
consider increasing <code>maxpts</code> and decreasing <code>abseps</code>.
</p>


<h3>Author(s)</h3>

<p>P. Lafaye de Micheaux, B. Liquet and J. Riou
</p>


<h3>References</h3>

<p>Delorme P., Lafaye de Micheaux P., Liquet B., Riou, J. (2015). Type-II Generalized Family-Wise Error Rate
Formulas with Application to Sample Size Determination. Submitted to <em>Statistics
in Medicine.</em> 
</p>
<p>Romano J. and Shaikh A. (2006) Stepup Procedures For Control of
Generalizations of the Familywise Error Rate. <em>The Annals of Statistics</em>,
34(4), 1850&ndash;1873.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+indiv.analysis">indiv.analysis</a></code>,
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
