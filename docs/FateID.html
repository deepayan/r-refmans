<!DOCTYPE html><html><head><title>Help for package FateID</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {FateID}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#compdr'><p>Computation of dimensional reduction representations</p></a></li>
<li><a href='#diffexpnb'><p>Function for differential expression analysis</p></a></li>
<li><a href='#fateBias'><p>Computation of fate bias</p></a></li>
<li><a href='#filterset'><p>Function for filtering expression data</p></a></li>
<li><a href='#gene2gene'><p>Comparative plot of the expression levels of two genes</p></a></li>
<li><a href='#getFeat'><p>Feature selection based on differentially expressed genes</p></a></li>
<li><a href='#getPart'><p>Inference of a cell type partition</p></a></li>
<li><a href='#getsom'><p>Topological ordering of pseudo-temporal expression profiles</p></a></li>
<li><a href='#impGenes'><p>Extract genes with high importance values for random forest classification</p></a></li>
<li><a href='#intestine'><p>Single-cell transcriptome data of intestinal epithelial cells</p></a></li>
<li><a href='#plotdiffgenesnb'><p>Function for plotting differentially expressed genes</p></a></li>
<li><a href='#plotexpression'><p>Plotting of pseudo-temporal expression profiles</p></a></li>
<li><a href='#plotexpressionProfile'><p>Plotting smoothed pseudo-temporal expression profiles for groups of genes</p></a></li>
<li><a href='#plotFateMap'><p>Plot dimensional reduction representation of the expression data</p></a></li>
<li><a href='#plotheatmap'><p>Heatmap of expression profiles</p></a></li>
<li><a href='#prcurve'><p>Computation of a principal curve for a given dimensional reduction representation</p></a></li>
<li><a href='#procsom'><p>Processing of self-organizing maps for pseudo-temporal expression profiles</p></a></li>
<li><a href='#reclassify'><p>Reclassification of cells</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Quantification of Fate Bias in Multipotent Progenitors</td>
</tr>
<tr>
<td>Version:</td>
<td>0.2.2</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-06-14</td>
</tr>
<tr>
<td>Author:</td>
<td>Dominic Grün &lt;dominic.gruen@gmail.com&gt;</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Dominic Grün &lt;dominic.gruen@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Application of 'FateID' allows computation and visualization of cell fate bias for multi-lineage single cell transcriptome data. Herman, J.S., Sagar, Grün D. (2018) &lt;<a href="https://doi.org/10.1038%2Fnmeth.4662">doi:10.1038/nmeth.4662</a>&gt;.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>graphics, grDevices, locfit, matrixStats, pheatmap, princurve,
randomForest, RColorBrewer, Rtsne, som, stats, umap, utils</td>
</tr>
<tr>
<td>Suggests:</td>
<td>DESeq2, knitr, rmarkdown</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-06-14 10:06:37 UTC; d.grun</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-06-14 11:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='compdr'>Computation of dimensional reduction representations</h2><span id='topic+compdr'></span>

<h3>Description</h3>

<p>This function computes dimensional reduction representations to a specified number of dimensions using a number of different algorithms: t-SNE, cmd, diffusion maps, umap
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compdr(
  x,
  z = NULL,
  m = c("tsne", "cmd", "umap"),
  k = 2,
  tsne.perplexity = 30,
  umap.pars = NULL,
  seed = 12345
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compdr_+3A_x">x</code></td>
<td>
<p>expression data frame with genes as rows and cells as columns. Gene IDs should be given as row names and cell IDs should be given as column names. This can be a reduced expression table only including the features (genes) to be used in the analysis.</p>
</td></tr>
<tr><td><code id="compdr_+3A_z">z</code></td>
<td>
<p>Matrix containing cell-to-cell distances to be used in the fate bias computation. Default is <code>NULL</code>. In this case, a correlation-based distance is computed from <code>x</code> by <code>1 - cor(x)</code></p>
</td></tr>
<tr><td><code id="compdr_+3A_m">m</code></td>
<td>
<p>a vector of dimensional reduction representations to be computed. The following representations can be computed: <code>cmd</code> (classical multidimensional scaling), <code>dm</code> (diffusion map), <code>tsne</code> (t-SNE map), <code>umap</code> (umap). The default value of m is <code>c("cmd","tsne","umap")</code>. Any subset of methods can be selected.</p>
</td></tr>
<tr><td><code id="compdr_+3A_k">k</code></td>
<td>
<p>vector of integers representing the dimensions for which the dimensional reduction representations will be computed. Default value is <code>2</code>.</p>
</td></tr>
<tr><td><code id="compdr_+3A_tsne.perplexity">tsne.perplexity</code></td>
<td>
<p>positive number. Perplexity used in the t-SNE computation. Default value is 30.</p>
</td></tr>
<tr><td><code id="compdr_+3A_umap.pars">umap.pars</code></td>
<td>
<p>umap parameters. See <span class="pkg">umap</span> package, <code>umap.defaults</code>. Default is <code>NULL</code> and <code>umap.defaults</code> are used. <code>umap.pars$input</code> is automatically set to <code>"dist"</code>, since the umap is computed for the distance object.</p>
</td></tr>
<tr><td><code id="compdr_+3A_seed">seed</code></td>
<td>
<p>integer seed for initialization. If equal to <code>NULL</code> then each run will yield slightly different results due to the randomness of the random forest algorithm. Default is <code>NULL</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A two-dimensional list with the dimensional reduction representation stored as data frames as components. Component names for the first dimension are given by one of the following algorithms:
</p>
<table>
<tr><td><code>cmd</code></td>
<td>
<p>classical multidimensional scaling computed by the <code>cmdscale</code> function of the <span class="pkg">stats</span> package.</p>
</td></tr>
<tr><td><code>tsne</code></td>
<td>
<p>t-SNE map computed by the <code>Rtsne</code> function of the <span class="pkg">Rtsne</span> package.</p>
</td></tr>
<tr><td><code>umap</code></td>
<td>
<p>umap computed by the <code>umap</code> function of the <span class="pkg">umap</span> package.</p>
</td></tr>
</table>
<p>Component names of the second dimension are a concatenation of a capital D and an integer number of the dimension. There is one component for each dimension in <code>k</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- intestine$x
dr &lt;- compdr(x,z=NULL,m="cmd",k=2,tsne.perplexity=30)
plot(dr[["cmd"]][["D2"]],pch=20,col="grey")

</code></pre>

<hr>
<h2 id='diffexpnb'>Function for differential expression analysis</h2><span id='topic+diffexpnb'></span>

<h3>Description</h3>

<p>This function performs differential expression analysis between two sets of single cell transcriptomes. The inference is based on a noise model or relies on the <code>DESeq2</code> approach.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>diffexpnb(
  x,
  A,
  B,
  DESeq = FALSE,
  method = "pooled",
  norm = FALSE,
  vfit = NULL,
  locreg = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="diffexpnb_+3A_x">x</code></td>
<td>
<p>expression data frame with genes as rows and cells as columns. Gene IDs should be given as row names and cell IDs should be given as column names. This can be a reduced expression table only including the features (genes) to be used in the analysis. This input has to be provided if <code>g</code> (see below) is given and corresponds to a valid gene ID, i. e. one of the rownames of <code>x</code>. The default value is <code>NULL</code>. In this case, cluster identities are highlighted in the plot.</p>
</td></tr>
<tr><td><code id="diffexpnb_+3A_a">A</code></td>
<td>
<p>vector of cell IDs corresponding column names of <code>x</code>. Differential expression in set <code>A</code> versus set <code>B</code> will be evaluated.</p>
</td></tr>
<tr><td><code id="diffexpnb_+3A_b">B</code></td>
<td>
<p>vector of cell IDs corresponding column names of <code>x</code>. Differential expression in set <code>A</code> versus set <code>B</code> will be evaluated.</p>
</td></tr>
<tr><td><code id="diffexpnb_+3A_deseq">DESeq</code></td>
<td>
<p>logical value. If <code>TRUE</code>, then <span class="pkg">DESeq2</span> is used for the inference of differentially expressed genes. In this case, it is recommended to provide non-normalized input data <code>x</code>. Default value is <code>FALSE</code></p>
</td></tr>
<tr><td><code id="diffexpnb_+3A_method">method</code></td>
<td>
<p>either &quot;per-condition&quot; or &quot;pooled&quot;. If DESeq is not used, this parameter determines, if the noise model is fitted for each set separately (&quot;per-condition&quot;) or for the pooled set comprising all cells in <code>A</code> and <code>B</code>. Default value is &quot;pooled&quot;.</p>
</td></tr>
<tr><td><code id="diffexpnb_+3A_norm">norm</code></td>
<td>
<p>logical value. If <code>TRUE</code> then the total transcript count in each cell is normalized to the minimum number of transcripts across all cells in set <code>A</code> and <code>B</code>. Default value is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="diffexpnb_+3A_vfit">vfit</code></td>
<td>
<p>function describing the background noise model. Inference of differentially expressed genes can be performed with a user-specified noise model describing the expression variance as a function of the mean expression. Default value is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="diffexpnb_+3A_locreg">locreg</code></td>
<td>
<p>logical value. If <code>FALSE</code> then regression of a second order polynomial is perfomed to determine the relation of variance and mean. If <code>TRUE</code> a local regression is performed instead. Default value is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="diffexpnb_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to the low level function <code>DESeqDataSetFromMatrix</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>DESeq</code> equals <code>TRUE</code>, the function returns the output of <span class="pkg">DESeq2</span>. In this case list of the following two components is returned:
</p>
<table>
<tr><td><code>cds</code></td>
<td>
<p>object returned by the <span class="pkg">DESeq2</span> function <code>DESeqDataSetFromMatrix</code>.</p>
</td></tr>
<tr><td><code>res</code></td>
<td>
<p>data frame containing the results of the <span class="pkg">DESeq2</span> analysis.</p>
</td></tr>
</table>
<p>Otherwise, a list of three components is returned:
</p>
<table>
<tr><td><code>vf1</code></td>
<td>
<p>a data frame of three columns, indicating the mean <code>m</code>, the variance <code>v</code> and the fitted variance <code>vm</code> for set <code>A</code>.</p>
</td></tr>
<tr><td><code>vf2</code></td>
<td>
<p>a data frame of three columns, indicating the mean <code>m</code>, the variance <code>v</code> and the fitted variance <code>vm</code> for set <code>B</code>.</p>
</td></tr>
<tr><td><code>res</code></td>
<td>
<p>a data frame with the results of the differential gene expression analysis with the structure of the <code>DESeq</code> output, displaying mean expression of the two sets, fold change and log2 fold change between the two sets, the p-value for differential expression (<code>pval</code>) and the Benjamini-Hochberg corrected false discovery rate (<code>padj</code>).</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- intestine$x
y &lt;- intestine$y
v &lt;- intestine$v

tar &lt;- c(6,9,13)
fb &lt;- fateBias(x,y,tar,z=NULL,minnr=5,minnrh=10,nbfactor=5,use.dist=FALSE,seed=NULL,nbtree=NULL)

thr &lt;- .3

A &lt;- rownames(fb$probs)[fb$probs[,"t6"]  &gt; .3]
B &lt;- rownames(fb$probs)[fb$probs[,"t13"] &gt; .3]
de &lt;- diffexpnb(v,A=A,B=B)

</code></pre>

<hr>
<h2 id='fateBias'>Computation of fate bias</h2><span id='topic+fateBias'></span>

<h3>Description</h3>

<p>This function computes fate biases for single cells based on expression data from a single cell sequencing experiment. It requires a clustering partition and a target cluster representing a commited state for each trajectory.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fateBias(
  x,
  y,
  tar,
  z = NULL,
  minnr = NULL,
  minnrh = NULL,
  adapt = TRUE,
  confidence = 0.75,
  nbfactor = 5,
  use.dist = FALSE,
  seed = NULL,
  nbtree = NULL,
  verbose = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fateBias_+3A_x">x</code></td>
<td>
<p>expression data frame with genes as rows and cells as columns. Gene IDs should be given as row names and cell IDs should be given as column names. This can be a reduced expression table only including the features (genes) to be used in the analysis.</p>
</td></tr>
<tr><td><code id="fateBias_+3A_y">y</code></td>
<td>
<p>clustering partition. A vector with an integer cluster number for each cell. The order of the cells has to be the same as for the columns of x.</p>
</td></tr>
<tr><td><code id="fateBias_+3A_tar">tar</code></td>
<td>
<p>vector of integers representing target cluster numbers. Each element of <code>tar</code> corresponds to a cluster of cells committed towards a particular mature state. One cluster per different cell lineage has to be given and is used as a starting point for learning the differentiation trajectory.</p>
</td></tr>
<tr><td><code id="fateBias_+3A_z">z</code></td>
<td>
<p>Matrix containing cell-to-cell distances to be used in the fate bias computation. Default is <code>NULL</code>. In this case, a correlation-based distance is computed from <code>x</code> by <code>1 - cor(x)</code>.</p>
</td></tr>
<tr><td><code id="fateBias_+3A_minnr">minnr</code></td>
<td>
<p>integer number of cells per target cluster to be selected for classification (test set) in each iteration. For each target cluster, the <code>minnr</code> cells with the highest similarity to a cell in the training set are selected for classification. If <code>z</code> is not <code>NULL</code> it is used as the similarity matrix for this step. Otherwise, <code>1-cor(x)</code> is used. Default value is <code>NULL</code> and <code>minnr</code> is estimated as the minimum of and 20 and half the median of target cluster sizes.</p>
</td></tr>
<tr><td><code id="fateBias_+3A_minnrh">minnrh</code></td>
<td>
<p>integer number of cells from the training set used for classification. From each training set, the <code>minnrh</code> cells with the highest similarity to the training set are selected. If <code>z</code> is not <code>NULL</code> it is used as the similarity matrix for this step. Default value is <code>NULL</code> and <code>minnrh</code> is estimated as the maximum of and 20 and half the median of target cluster sizes.</p>
</td></tr>
<tr><td><code id="fateBias_+3A_adapt">adapt</code></td>
<td>
<p>logical. If <code>TRUE</code> then the size of the test set for each target cluster is adapted based on the classification success in the previous iteration. For each target cluster, the number of successfully classified cells is determined, i.e. the number of cells with a minimum fraction of votes given by the <code>confidence</code> parameter for the target cluster, which gave rise to the inclusion of the cell in the test set (see <code>minnr</code>). Weights are then derived by dividing this number by the maximum across all clusters after adding a pseudocount of 1. The test set size <code>minnr</code> is rescaled for each cluster by the respective weight in the next iteration. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="fateBias_+3A_confidence">confidence</code></td>
<td>
<p>real number between 0 and 1. See <code>adapt</code> parameter. Default is 0.75.</p>
</td></tr>
<tr><td><code id="fateBias_+3A_nbfactor">nbfactor</code></td>
<td>
<p>positive integer number. Determines the number of trees grown for each random forest. The number of trees is given by the number of columns of th training set multiplied by <code>nbfactor</code>. Default value is 5.</p>
</td></tr>
<tr><td><code id="fateBias_+3A_use.dist">use.dist</code></td>
<td>
<p>logical value. If <code>TRUE</code> then the distance matrix is used as feature matrix (i. e. <code>z</code> if not equal to <code>NULL</code> and <code>1-cor(x)</code> otherwise). If <code>FALSE</code>, gene expression values in <code>x</code> are used. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="fateBias_+3A_seed">seed</code></td>
<td>
<p>integer seed for initialization. If equal to <code>NULL</code> then each run will yield slightly different results due to the radomness of the random forest algorithm. Default is <code>NULL</code></p>
</td></tr>
<tr><td><code id="fateBias_+3A_nbtree">nbtree</code></td>
<td>
<p>integer value. If given, it specifies the number of trees for each random forest explicitely. Default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="fateBias_+3A_verbose">verbose</code></td>
<td>
<p>logical. If <code>TRUE</code>, then print information to console.</p>
</td></tr>
<tr><td><code id="fateBias_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to the low level function <code>randomForest</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The bias is computed as the ratio of the number of random forest votes for a trajectory and the number of votes for the trajectory with the second largest number of votes. By this means only the trajectory with the largest number of votes will receive a bias &gt;1. The siginifcance is computed based on counting statistics on the difference in the number of votes. A significant bias requires a p-value &lt; 0.05. Cells are assigned to a trajectory if they exhibit a significant bias &gt;1 for this trajectory.
</p>


<h3>Value</h3>

<p>A list with the following three components:
</p>
<table>
<tr><td><code>probs</code></td>
<td>
<p>a data frame with the fraction of random forest votes for each cell. Columns represent the target clusters. Column names are given by a concatenation of <code>t</code> and target cluster number.</p>
</td></tr>
<tr><td><code>votes</code></td>
<td>
<p>a data frame with the number of random forest votes for each cell. Columns represent the target clusters. Column names are given by a concatenation of <code>t</code> and target cluster number.</p>
</td></tr>
<tr><td><code>tr</code></td>
<td>
<p>list of vectors. Each component contains the IDs of all cells on the trajectory to a given target cluster. Component names are given by a concatenation of <code>t</code> and target cluster number.</p>
</td></tr>
<tr><td><code>rfl</code></td>
<td>
<p>list of randomForest objects for each iteration of the classification.</p>
</td></tr>
<tr><td><code>trall</code></td>
<td>
<p>vector of cell ids ordered by the random forest iteration in which they have been classified into one of the target clusters.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- intestine$x
y &lt;- intestine$y
tar &lt;- c(6,9,13)
fb &lt;- fateBias(x,y,tar,minnr=5,minnrh=20,adapt=TRUE,confidence=0.75,nbfactor=5)
head(fb$probs)
</code></pre>

<hr>
<h2 id='filterset'>Function for filtering expression data</h2><span id='topic+filterset'></span>

<h3>Description</h3>

<p>This function discards lowly expressed genes from the expression data frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>filterset(x, n = NULL, minexpr = 2, minnumber = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="filterset_+3A_x">x</code></td>
<td>
<p>expression data frame with genes as rows and cells as columns. Gene IDs should be given as row names and cell IDs should be given as column names.</p>
</td></tr>
<tr><td><code id="filterset_+3A_n">n</code></td>
<td>
<p>ordered vector of cell IDs to be included. Cell IDs need to be column names of <code>x</code>. If not provided, then all cell IDs are included in arbitray order. Default value is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="filterset_+3A_minexpr">minexpr</code></td>
<td>
<p>positive real number. This is the minimum expression required for at least <code>minnumber</code> cells. All genes that do not fulfill this criterion are removed. The default value is 2.</p>
</td></tr>
<tr><td><code id="filterset_+3A_minnumber">minnumber</code></td>
<td>
<p>positive integer number. This is the minimum number of cells in which a gene needs to be expressed at least at a level of <code>minexpr</code>. All genes that do not fulfill this criterion are removed. The default value is 1.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Reduced expression data frame with genes as rows and cells as columns in the same order as in <code>n</code>.
</p>

<hr>
<h2 id='gene2gene'>Comparative plot of the expression levels of two genes</h2><span id='topic+gene2gene'></span>

<h3>Description</h3>

<p>This function produces a scatter plot of the expression levels of two genes. It allows plotting cells of selected clusters and permits highlighting of the fate bias.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gene2gene(
  x,
  y,
  g1,
  g2,
  clusters = NULL,
  fb = NULL,
  tn = NULL,
  col = NULL,
  tp = 1,
  plotnum = TRUE,
  seed = 12345
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gene2gene_+3A_x">x</code></td>
<td>
<p>expression data frame with genes as rows and cells as columns. Gene IDs should be given as row names and cell IDs should be given as column names. This can be a reduced expression table only including the features (genes) to be used in the analysis.</p>
</td></tr>
<tr><td><code id="gene2gene_+3A_y">y</code></td>
<td>
<p>clustering partition. A vector with an integer cluster number for each cell. The order of the cells has to be the same as for the columns of x.</p>
</td></tr>
<tr><td><code id="gene2gene_+3A_g1">g1</code></td>
<td>
<p>gene id corresponding to a valid row names of x. Expression of gene <code>g1</code> versus gene <code>g2</code> will be plotted.</p>
</td></tr>
<tr><td><code id="gene2gene_+3A_g2">g2</code></td>
<td>
<p>gene id corresponding to a valid row names of x. Expression of gene <code>g1</code> versus gene <code>g2</code> will be plotted.</p>
</td></tr>
<tr><td><code id="gene2gene_+3A_clusters">clusters</code></td>
<td>
<p>vector of valid cluster ids. Expression is displayed for cells in any of the clusters contained in <code>clusters</code>. If the argument is not given, cells of all clusters are displayed. Default value is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="gene2gene_+3A_fb">fb</code></td>
<td>
<p>fateBias object returned by the function <code>fateBias</code>. Default value is <code>NULL</code>. Only if both <code>tn</code> and <code>fb</code> are provided as input, the fate bias will be colour coded.</p>
</td></tr>
<tr><td><code id="gene2gene_+3A_tn">tn</code></td>
<td>
<p>name of a target cluster, i. e. concatenation of a <code>t</code> and the number of a target cluster. Has to correspond to a column name of <code>fb$probs</code>. The default value is <code>NULL</code>. Only if both <code>tn</code> and <code>fb</code> are provided as input, the fate bias will be colour coded.</p>
</td></tr>
<tr><td><code id="gene2gene_+3A_col">col</code></td>
<td>
<p>optional vector of valid color names for all clusters in <code>y</code> ordered by increasing cluster number. Default value is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="gene2gene_+3A_tp">tp</code></td>
<td>
<p>Transparency of points in the plot. Default value is 1, i. e. non-transparent.</p>
</td></tr>
<tr><td><code id="gene2gene_+3A_plotnum">plotnum</code></td>
<td>
<p>logical value. If <code>TRUE</code>, then cluster numbers are displayed on top of the data points. Default value is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="gene2gene_+3A_seed">seed</code></td>
<td>
<p>integer number. Random seed for determining colour scheme. Default is 12345.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- intestine$x
y &lt;- intestine$y
v &lt;- intestine$v

tar &lt;- c(6,9,13)
fb &lt;- fateBias(x,y,tar,z=NULL,minnr=5,minnrh=10,nbfactor=5,use.dist=FALSE,seed=NULL,nbtree=NULL)
gene2gene(v,y,"Muc2__chr7","Apoa1__chr9")
gene2gene(v,y,"Muc2__chr7","Apoa1__chr9",fb=fb,tn="t6",plotnum=FALSE)

</code></pre>

<hr>
<h2 id='getFeat'>Feature selection based on differentially expressed genes</h2><span id='topic+getFeat'></span>

<h3>Description</h3>

<p>This function performs a feature selection based on the inference of differentially expressed genes between each target cluster and all remaining cells.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getFeat(x, y, tar, fpv = 0.05, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getFeat_+3A_x">x</code></td>
<td>
<p>expression data frame with genes as rows and cells as columns. Gene IDs should be given as row names and cell IDs should be given as column names. This can be a reduced expression table only including the features (genes) to be used in the analysis.</p>
</td></tr>
<tr><td><code id="getFeat_+3A_y">y</code></td>
<td>
<p>clustering partition. A vector with an integer cluster number for each cell. The order of the cells has to be the same as for the columns of x.</p>
</td></tr>
<tr><td><code id="getFeat_+3A_tar">tar</code></td>
<td>
<p>vector of integers representing target cluster numbers. Each element of <code>tar</code> corresponds to a cluster of cells committed towards a particular mature state. One cluster per different cell lineage has to be given and is used as a starting point for learning the differentiation trajectory.</p>
</td></tr>
<tr><td><code id="getFeat_+3A_fpv">fpv</code></td>
<td>
<p>p-value cutoff for calling differentially expressed genes. This is a cutoff for the Benjamini-Hochberg corrected false discovery rate. Default value is 0.05.</p>
</td></tr>
<tr><td><code id="getFeat_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to the low level function <code>diffexpnb</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function determines differentially expressed between the cells in each of the target clusters in comparison to the remaining cells by using <code>diffexpnb</code> function.
</p>


<h3>Value</h3>

<p>A filtered expression table with features extracted based on differentially expressed genes.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- intestine$x
y &lt;- intestine$y
tar &lt;- c(6,9,13)
xf &lt;- getFeat(x,y,tar,fpv=.05)
</code></pre>

<hr>
<h2 id='getPart'>Inference of a cell type partition</h2><span id='topic+getPart'></span>

<h3>Description</h3>

<p>This function performs an inference of a cell type partition based on the expression of marker genes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getPart(x, FMarker, fthr = NULL, n = 25)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getPart_+3A_x">x</code></td>
<td>
<p>expression data frame with genes as rows and cells as columns. Gene IDs should be given as row names and cell IDs should be given as column names. This can be a reduced expression table only including the features (genes) to be used in the analysis.</p>
</td></tr>
<tr><td><code id="getPart_+3A_fmarker">FMarker</code></td>
<td>
<p>list of vectors of gene IDs corresponding to valid rownames of <code>x</code>. The gene IDs within each component of <code>FMarker</code> are considered as marker genes of one of the cell types in the dataset. The aggregated expression of the genes for each component is compared to a threshold defined by the input argument <code>fthr</code> or <code>n</code>. All cells exceeding this threshold are assigned to a cluster representing cells with expression of the respective marker genes.</p>
</td></tr>
<tr><td><code id="getPart_+3A_fthr">fthr</code></td>
<td>
<p>vector of real positive numbers. This vector has to have the same length as the list <code>FMarker</code> and contains a threshold for the aggregated expression of all genes in the corresponding component of <code>FMarker</code>. If NULL then a threshold is inferred from the <code>n</code> top-expressing cells for the genes in the respective component of <code>FMarker</code>.</p>
</td></tr>
<tr><td><code id="getPart_+3A_n">n</code></td>
<td>
<p>positive integer number. For each component of <code>FMarker</code> the expression of all genes is aggregated in every cell and the <code>n</code> top-expressing cells are extracted. The average expression across these cell defines the expression threshold applied to infer the partitioning. Default value is 25.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following three components:
</p>
<table>
<tr><td><code>part</code></td>
<td>
<p>A vector with a partitioning, i. e. cluster assignment for each cell.</p>
</td></tr>
<tr><td><code>tar</code></td>
<td>
<p>A vector with the numbers of target clusters. Cluster 1 comprises all cells with no enrichment of marker genes. The remaining clusters correspond to cell types up-regulating the markers in the list <code>FMarker</code> in the same order as in this list.</p>
</td></tr>
<tr><td><code>thr</code></td>
<td>
<p>A vector with expression threshold values applied for each component in the list <code>FMarker</code> in the same order as in this list.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- intestine$x
y &lt;- intestine$y

FMarker &lt;- list(c("Defa20__chr8","Defa24__chr8"), "Clca3__chr3", "Alpi__chr1")
xf &lt;- getPart(x,FMarker,fthr=NULL,n=5)

</code></pre>

<hr>
<h2 id='getsom'>Topological ordering of pseudo-temporal expression profiles</h2><span id='topic+getsom'></span>

<h3>Description</h3>

<p>This function computes a topological ordering of pseudo-temporal expression profiles of all genes by using 1-dimensional self-organizing maps.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getsom(x, nb = 1000, alpha = 0.5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getsom_+3A_x">x</code></td>
<td>
<p>expression data frame with genes as rows and cells as columns. Gene IDs should be given as row names and cell IDs should be given as column names. The pseudo-temporal expression profile of each gene is defined by the order of cell IDs, i. e. columns, in <code>x</code>.</p>
</td></tr>
<tr><td><code id="getsom_+3A_nb">nb</code></td>
<td>
<p>positive integer number. Number of nodes of the self-organizing map. Default value is 1000.</p>
</td></tr>
<tr><td><code id="getsom_+3A_alpha">alpha</code></td>
<td>
<p>positive real number. Pseudo-temporal expression profiles are derived by a local regression of expression values across the ordered cells using the function <code>loess</code> from the package <span class="pkg">stats</span>. This is the parameter, which controls the degree of smoothing. Larger values return smoother profiles. Default value is 0.5.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of the following three components:
</p>
<table>
<tr><td><code>som</code></td>
<td>
<p>a <code>som</code> object returned by the function <code>som</code> of the package <span class="pkg">som</span></p>
</td></tr>
<tr><td><code>x</code></td>
<td>
<p>pseudo-temporal expression profiles, i. e. the input expression data frame <code>x</code> after smoothing by running mean or local regression, respectivey, and normalization. The sum of smoothened gene expression values across all cells is normalized to 1.</p>
</td></tr>
<tr><td><code>zs</code></td>
<td>
<p>data frame of z-score transformed pseudo-temporal expression profiles.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>

x &lt;- intestine$x
y &lt;- intestine$y
v &lt;- intestine$v

tar &lt;- c(6,9,13)
fb &lt;- fateBias(x,y,tar,z=NULL,minnr=5,minnrh=10,nbfactor=5,use.dist=FALSE,seed=NULL,nbtree=NULL)
dr &lt;- compdr(x,z=NULL,m="cmd",k=2,tsne.perplexity=30)
pr &lt;- prcurve(y,fb,dr,k=2,m="cmd",trthr=0.4,start=NULL)
n &lt;- pr$trc[["t6"]]
fs  &lt;- filterset(v,n,minexpr=2,minnumber=1)
s1d &lt;- getsom(fs,nb=1000,alpha=.5)


</code></pre>

<hr>
<h2 id='impGenes'>Extract genes with high importance values for random forest classification</h2><span id='topic+impGenes'></span>

<h3>Description</h3>

<p>This function extracts all genes with an importance value for classifying cells into a given target cluster exceeding a given threshold for at least one of the random forest iterationns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>impGenes(fb, tn, ithr = 0.02, zthr = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="impGenes_+3A_fb">fb</code></td>
<td>
<p>fateBias object returned by the function <code>fateBias</code>. If <code>fb</code> is provided, then a principal curve is computed and shown in the plot. Default value is <code>NULL</code>. The curve is only displayed if <code>g</code> equal <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="impGenes_+3A_tn">tn</code></td>
<td>
<p>name of a target cluster, i. e. concatenation of a <code>t</code> and the number of a target cluster. Has to correspond to a column name of <code>fb$probs</code>.</p>
</td></tr>
<tr><td><code id="impGenes_+3A_ithr">ithr</code></td>
<td>
<p>positive real number. Threshold for the required importance measure (mean decrease in accuracy of classification upon removal, see <span class="pkg">randomForest</span>) to include a gene into the output as important feature for classying cells in <code>tn</code>. Default value is 0.02.</p>
</td></tr>
<tr><td><code id="impGenes_+3A_zthr">zthr</code></td>
<td>
<p>positive real number. Threshold for the required z-score of the importance measure (importance divided by the standard deviation of importance) to include a gene into the output as important feature for classying cells in <code>tn</code>. Default value is 2.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns a list of two elements.
</p>
<table>
<tr><td><code>d</code></td>
<td>
<p>a data frame with mean importance values for all genes surviving the filtering by <code>ithr</code> and <code>zthr</code>. Columns correspond to random forest iterations, starting from the initial target cluster.</p>
</td></tr>
<tr><td><code>d</code></td>
<td>
<p>a data frame with the standard deviation of importance values for all genes surviving the filtering by <code>ithr</code> and <code>zthr</code>. Columns correspond to random forest iterations, starting from the initial target cluster.</p>
</td></tr>
</table>
<p>The function produces a heatmap of <code>d</code> with hierarchical clustering of the rows using the function <code>pheatmap</code> from the <span class="pkg">pheatmap</span> package.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- intestine$x
y &lt;- intestine$y
tar &lt;- c(6,9,13)
fb &lt;- fateBias(x,y,tar,z=NULL,minnr=5,minnrh=10,nbfactor=5,use.dist=FALSE,seed=NULL,nbtree=NULL)
k &lt;- impGenes(fb,"t6",ithr=.02,zthr=2)
</code></pre>

<hr>
<h2 id='intestine'>Single-cell transcriptome data of intestinal epithelial cells</h2><span id='topic+intestine'></span>

<h3>Description</h3>

<p>This dataset contains gene expression values, i. e. transcript counts, of 278 intestinal epithelial cells, and additional information on different cell types in this sample.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>intestine
</code></pre>


<h3>Format</h3>

<p>A list of the following 5 components:
</p>

<dl>
<dt>x</dt><dd><p>data frame with genes as rows and cells as columns. This reduced data frame only contains expression of the most variable genes.</p>
</dd>
<dt>y</dt><dd><p>vector containing a clustering partition of the 278 cells into different cell types</p>
</dd>
<dt>v</dt><dd><p>data frame with genes as rows and cells as columns. This data frame contains expression of all genes.</p>
</dd>
<dt>fcol</dt><dd><p>vector containing colour values for all clusters in <code>y</code></p>
</dd>
</dl>



<h3>Value</h3>

<p>None
</p>


<h3>References</h3>

<p>Grün et al. (2016) Cell Stem Cell 19(2): 266-77
(<a href="https://pubmed.ncbi.nlm.nih.gov/27345837/">PubMed</a>)
</p>

<hr>
<h2 id='plotdiffgenesnb'>Function for plotting differentially expressed genes</h2><span id='topic+plotdiffgenesnb'></span>

<h3>Description</h3>

<p>This is a plotting function for visualizing the output of the <code>diffexpnb</code> function as MA plot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotdiffgenesnb(
  x,
  pthr = 0.05,
  padj = TRUE,
  lthr = 0,
  mthr = -Inf,
  Aname = NULL,
  Bname = NULL,
  show_names = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotdiffgenesnb_+3A_x">x</code></td>
<td>
<p>output of the function <code>diffexpnb</code>.</p>
</td></tr>
<tr><td><code id="plotdiffgenesnb_+3A_pthr">pthr</code></td>
<td>
<p>real number between 0 and 1. This number represents the p-value cutoff applied for displaying differentially expressed genes. Default value is 0.05. The parameter <code>padj</code> (see below) determines if this cutoff is applied to the uncorrected p-value or to the Benjamini-Hochberg corrected false discovery rate.</p>
</td></tr>
<tr><td><code id="plotdiffgenesnb_+3A_padj">padj</code></td>
<td>
<p>logical value. If <code>TRUE</code>, then genes with a Benjamini-Hochberg corrected false discovery rate lower than <code>pthr</code> are displayed. If <code>FALSE</code>, then genes with a p-value lower than <code>pthr</code> are displayed.</p>
</td></tr>
<tr><td><code id="plotdiffgenesnb_+3A_lthr">lthr</code></td>
<td>
<p>real number between 0 and Inf. Differentially expressed genes are displayed only for log2 fold-changes greater than <code>lthr</code>. Default value is 0.</p>
</td></tr>
<tr><td><code id="plotdiffgenesnb_+3A_mthr">mthr</code></td>
<td>
<p>real number between -Inf and Inf. Differentially expressed genes are displayed only for log2 mean expression greater than <code>mthr</code>. Default value is -Inf.</p>
</td></tr>
<tr><td><code id="plotdiffgenesnb_+3A_aname">Aname</code></td>
<td>
<p>name of expression set <code>A</code>, which was used as input to <code>diffexpnb</code>. If provided, this name is used in the axis labels. Default value is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="plotdiffgenesnb_+3A_bname">Bname</code></td>
<td>
<p>name of expression set <code>B</code>, which was used as input to <code>diffexpnb</code>. If provided, this name is used in the axis labels. Default value is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="plotdiffgenesnb_+3A_show_names">show_names</code></td>
<td>
<p>logical value. If <code>TRUE</code> then gene names displayed for differentially expressed genes. Default value is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="plotdiffgenesnb_+3A_...">...</code></td>
<td>
<p>Additional arguments for function <code>plot</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- intestine$x
y &lt;- intestine$y
v &lt;- intestine$v

tar &lt;- c(6,9,13)
fb &lt;- fateBias(x,y,tar,z=NULL,minnr=5,minnrh=10,nbfactor=5,use.dist=FALSE,seed=NULL,nbtree=NULL)

thr &lt;- .3

A &lt;- rownames(fb$probs)[fb$probs[,"t6"]  &gt; .3]
B &lt;- rownames(fb$probs)[fb$probs[,"t13"] &gt; .3]
de &lt;- diffexpnb(v,A=A,B=B)
plotdiffgenesnb(de,pthr=.05)

</code></pre>

<hr>
<h2 id='plotexpression'>Plotting of pseudo-temporal expression profiles</h2><span id='topic+plotexpression'></span>

<h3>Description</h3>

<p>This function allows plotting pseudo-temporal expression profiles for single genes or groups of genes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotexpression(
  x,
  y,
  g,
  n,
  logsc = FALSE,
  col = NULL,
  name = NULL,
  cluster = FALSE,
  alpha = 0.5,
  types = NULL,
  cex = 3,
  ylim = NULL,
  map = TRUE,
  leg = TRUE,
  seed = 12345,
  ylab = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotexpression_+3A_x">x</code></td>
<td>
<p>expression data frame with genes as rows and cells as columns. Gene IDs should be given as row names and cell IDs should be given as column names.</p>
</td></tr>
<tr><td><code id="plotexpression_+3A_y">y</code></td>
<td>
<p>clustering partition. A vector with an integer cluster number for each cell. The order of the cells has to be the same as for the columns of <code>x</code>.</p>
</td></tr>
<tr><td><code id="plotexpression_+3A_g">g</code></td>
<td>
<p>a gene ID corresponding to one of the rownames of <code>x</code>. It can also be a vector of gene IDs. In this case, the aggregated expression across all gene IDs is plotted.</p>
</td></tr>
<tr><td><code id="plotexpression_+3A_n">n</code></td>
<td>
<p>ordered vector of cell IDs to be included. Cell IDs need to be column names of <code>x</code>.</p>
</td></tr>
<tr><td><code id="plotexpression_+3A_logsc">logsc</code></td>
<td>
<p>logical value. If <code>TRUE</code>, then log2-transformed values are plotted. Default is <code>FALSE</code> and untransformed values are plotted.</p>
</td></tr>
<tr><td><code id="plotexpression_+3A_col">col</code></td>
<td>
<p>optional vector of valid color names for all clusters in <code>y</code> ordered by increasing cluster number. Default value is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="plotexpression_+3A_name">name</code></td>
<td>
<p>optional character string. This argument corresponds to a title for the plot. Default value is <code>NULL</code>. If not provided, and <code>g</code> is given, then <code>name</code> will equal <code>g</code> or <code>g[1]</code>, respectively, if <code>g</code> is a vector of gene IDs.</p>
</td></tr>
<tr><td><code id="plotexpression_+3A_cluster">cluster</code></td>
<td>
<p>logical value. If <code>TRUE</code> then the partitioning along the x-axis is indicated be vertical lines representing the boundaries of all positions with a given value in <code>y</code>. The average position across all cells in a cluster will be indicated on the x-axis.</p>
</td></tr>
<tr><td><code id="plotexpression_+3A_alpha">alpha</code></td>
<td>
<p>positive real number. Pseudo-temporal expression profiles are derived by a local regression of expression values across the ordered cells using the function <code>loess</code> from the package <span class="pkg">stats</span>. This is the parameter, which controls the degree of smoothing. Larger values return smoother profiles. Default value is 0.5.</p>
</td></tr>
<tr><td><code id="plotexpression_+3A_types">types</code></td>
<td>
<p>optional vector with IDs for different subsets of cells in <code>y</code>, e. g. different batches. All cells with the same ID will be displayed by the same symbol and color. Default value is <code>NULL</code></p>
</td></tr>
<tr><td><code id="plotexpression_+3A_cex">cex</code></td>
<td>
<p>size of data points. Default value is 3.</p>
</td></tr>
<tr><td><code id="plotexpression_+3A_ylim">ylim</code></td>
<td>
<p>vector of two numerical values: lower and upper limit of values shown on the y-axis. Default value is <code>NULL</code> and the whole range is shown.</p>
</td></tr>
<tr><td><code id="plotexpression_+3A_map">map</code></td>
<td>
<p>logical. If <code>TRUE</code> then data points are shown. Default value is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="plotexpression_+3A_leg">leg</code></td>
<td>
<p>logical. If <code>TRUE</code> then axes and labels are shown. Default value is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="plotexpression_+3A_seed">seed</code></td>
<td>
<p>integer number. Random seed for determining colour scheme. Default is 12345.</p>
</td></tr>
<tr><td><code id="plotexpression_+3A_ylab">ylab</code></td>
<td>
<p>Optional label for the y-axis. Default is <code>NULL</code> and axis is labeled &quot;norm. expression&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

x &lt;- intestine$x
y &lt;- intestine$y
v &lt;- intestine$v
fcol &lt;- intestine$col
tar &lt;- c(6,9,13)
fb &lt;- fateBias(x,y,tar,z=NULL,minnr=5,minnrh=10,nbfactor=5,use.dist=FALSE,seed=NULL,nbtree=NULL)
dr &lt;- compdr(x,z=NULL,m="cmd",k=2,tsne.perplexity=30)
pr &lt;- prcurve(y,fb,dr,k=2,m="cmd",trthr=0.4,start=NULL)
n &lt;- pr$trc[["t6"]]
fs  &lt;- filterset(v,n,minexpr=2,minnumber=1)
s1d &lt;- getsom(fs,nb=1000,alpha=.5)
ps &lt;- procsom(s1d,corthr=.85,minsom=3)
# plot average profile of all genes of node 1 in the self-organizing map
g &lt;- names(ps$nodes)[ps$nodes == 1]
plotexpression(v,y,g,n,col=fcol,name="Node 1",cluster=FALSE,alpha=.5,types=NULL)


</code></pre>

<hr>
<h2 id='plotexpressionProfile'>Plotting smoothed pseudo-temporal expression profiles for groups of genes</h2><span id='topic+plotexpressionProfile'></span>

<h3>Description</h3>

<p>This function allows plotting loess-smoothed pseudo-temporal expression profiles for groups of genes. To display gene expression profiles on the same scale, row sums are normalized to one.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotexpressionProfile(
  x,
  y,
  g,
  n,
  logsc = FALSE,
  col = NULL,
  name = NULL,
  cluster = FALSE,
  alpha = 0.5,
  lwd = 1,
  ylim = NULL,
  seed = 12345,
  ylab = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotexpressionProfile_+3A_x">x</code></td>
<td>
<p>expression data frame with genes as rows and cells as columns. Gene IDs should be given as row names and cell IDs should be given as column names.</p>
</td></tr>
<tr><td><code id="plotexpressionProfile_+3A_y">y</code></td>
<td>
<p>clustering partition. A vector with an integer cluster number for each cell. The order of the cells has to be the same as for the columns of <code>x</code>.</p>
</td></tr>
<tr><td><code id="plotexpressionProfile_+3A_g">g</code></td>
<td>
<p>a gene ID corresponding to one of the rownames of <code>x</code>. It can also be vector of gene IDs. In this case, a separate profile is plotted for each gene in <code>g</code>.</p>
</td></tr>
<tr><td><code id="plotexpressionProfile_+3A_n">n</code></td>
<td>
<p>ordered vector of cell IDs to be included. Cell IDs need to be column names of <code>x</code>.</p>
</td></tr>
<tr><td><code id="plotexpressionProfile_+3A_logsc">logsc</code></td>
<td>
<p>logical value. If <code>TRUE</code>, then log2-transformed values are plotted. Default is <code>FALSE</code> and untransformed values are plotted.</p>
</td></tr>
<tr><td><code id="plotexpressionProfile_+3A_col">col</code></td>
<td>
<p>optional vector of valid color names used for the profiles of all genes in <code>g</code>. Default value is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="plotexpressionProfile_+3A_name">name</code></td>
<td>
<p>optional character string. This argument corresponds to a title for the plot. Default value is <code>NULL</code>. If not provided, and <code>g</code> is given, then <code>name</code> will equal <code>g</code> or <code>g[1]</code>, respectively, if <code>g</code> is a vector of gene IDs.</p>
</td></tr>
<tr><td><code id="plotexpressionProfile_+3A_cluster">cluster</code></td>
<td>
<p>logical value. If <code>TRUE</code> then the partitioning along the x-axis is indicated be vertical lines representing the boundaries of all positions with a given value in <code>y</code>. The average position across all cells in a cluster will be indicated on the x-axis.</p>
</td></tr>
<tr><td><code id="plotexpressionProfile_+3A_alpha">alpha</code></td>
<td>
<p>positive real number. Pseudo-temporal expression profiles are derived by a local regression of expression values across the ordered cells using the function <code>loess</code> from the package <span class="pkg">stats</span>. This is the parameter, which controls the degree of smoothing. Larger values return smoother profiles. Default value is 0.5.</p>
</td></tr>
<tr><td><code id="plotexpressionProfile_+3A_lwd">lwd</code></td>
<td>
<p>line width of profiles. Default value is 1.</p>
</td></tr>
<tr><td><code id="plotexpressionProfile_+3A_ylim">ylim</code></td>
<td>
<p>vector of two numerical values: lower and upper limit of values shown on the y-axis. Default value is <code>NULL</code> and the whole range is shown.</p>
</td></tr>
<tr><td><code id="plotexpressionProfile_+3A_seed">seed</code></td>
<td>
<p>integer number. Random seed for determining colour scheme. Default is 12345.</p>
</td></tr>
<tr><td><code id="plotexpressionProfile_+3A_ylab">ylab</code></td>
<td>
<p>Optional label for the y-axis. Default is <code>NULL</code> and axis is labeled &quot;norm. expression&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

x &lt;- intestine$x
y &lt;- intestine$y
v &lt;- intestine$v
fcol &lt;- intestine$col
tar &lt;- c(6,9,13)
fb &lt;- fateBias(x,y,tar,z=NULL,minnr=5,minnrh=10,nbfactor=5,use.dist=FALSE,seed=NULL,nbtree=NULL)
dr &lt;- compdr(x,z=NULL,m="cmd",k=2,tsne.perplexity=30)
pr &lt;- prcurve(y,fb,dr,k=2,m="cmd",trthr=0.4,start=NULL)
n &lt;- pr$trc[["t6"]]
fs  &lt;- filterset(v,n,minexpr=2,minnumber=1)
s1d &lt;- getsom(fs,nb=1000,alpha=.5)
ps &lt;- procsom(s1d,corthr=.85,minsom=3)
# plot average profile of all genes of node 1 in the self-organizing map
g &lt;- sample(names(ps$nodes)[ps$nodes == 1],5)
plotexpressionProfile(v,y,g,n,col=fcol,name="Node 1",alpha=.2)


</code></pre>

<hr>
<h2 id='plotFateMap'>Plot dimensional reduction representation of the expression data</h2><span id='topic+plotFateMap'></span>

<h3>Description</h3>

<p>This function plots a dimensional reduction representation using the output of the <code>compdr</code> function as input. It allows display of the input clusters as well as color coding of fate bias probabilities and gene expression.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotFateMap(
  y,
  dr,
  x = NULL,
  g = NULL,
  n = NULL,
  prc = FALSE,
  logsc = FALSE,
  k = 2,
  m = "cmd",
  kr = NULL,
  col = NULL,
  fb = NULL,
  trthr = NULL,
  start = NULL,
  tp = 1,
  seed = 12345,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotFateMap_+3A_y">y</code></td>
<td>
<p>clustering partition. A vector with an integer cluster number for each cell. The order of the cells has to be the same as for the columns of x.</p>
</td></tr>
<tr><td><code id="plotFateMap_+3A_dr">dr</code></td>
<td>
<p>list of dimensional reduction representations returned by the function <code>compdr</code>.</p>
</td></tr>
<tr><td><code id="plotFateMap_+3A_x">x</code></td>
<td>
<p>expression data frame with genes as rows and cells as columns. Gene IDs should be given as row names and cell IDs should be given as column names. This can be a reduced expression table only including the features (genes) to be used in the analysis. This input has to be provided if <code>g</code> (see below) is given and corresponds to a valid gene ID, i. e. one of the rownames of <code>x</code>. The default value is <code>NULL</code>. In this case, cluster identities are highlighted in the plot.</p>
</td></tr>
<tr><td><code id="plotFateMap_+3A_g">g</code></td>
<td>
<p>either the name of one of the trajectories from <code>fb</code> or a gene ID corresponding to one of the rownames of <code>x</code>. In the latter case, the input argument <code>x</code> needs to be provided. A vector of gene IDs can also be provided. In this case, the aggregated expression across all gene IDs is plotted. If <code>g</code> equals E, then the entropy of fate bias is displayed. The default value is <code>NULL</code>. In this case, cluster identities are highlighted in the plot.</p>
</td></tr>
<tr><td><code id="plotFateMap_+3A_n">n</code></td>
<td>
<p>optional character string. This argument corresponds to a title for 2-dimensional plots. Default value is <code>NULL</code>. If not provided, and <code>g</code> is given, then <code>n</code> will equal <code>g</code> or g[1], respectively, if g is a vector of gene IDs.</p>
</td></tr>
<tr><td><code id="plotFateMap_+3A_prc">prc</code></td>
<td>
<p>logical. If <code>TRUE</code>, then a principal curve is computed and returned. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="plotFateMap_+3A_logsc">logsc</code></td>
<td>
<p>logical. If <code>TRUE</code>, then gene expression of fate bias probabilities are plotted on a log2 scale. Default value is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="plotFateMap_+3A_k">k</code></td>
<td>
<p>integer number for the dimension to be used. This dimension has to be present in <code>dr</code>. Only <code>k=2</code> is allowed starting from version 0.1.9.</p>
</td></tr>
<tr><td><code id="plotFateMap_+3A_m">m</code></td>
<td>
<p>name of the dimensional reduction algorithms to be used for the principal curve computation. One of <code>cmd</code>, <code>dm</code>, <code>tsne</code>, <code>umap</code>. Default value is <code>cmd</code>. Has to be a component of <code>dr</code>, i.e. previously computed by <code>compdr</code>.</p>
</td></tr>
<tr><td><code id="plotFateMap_+3A_kr">kr</code></td>
<td>
<p>integer vector. If <code>k</code>&gt;3 then <code>kr</code> indicates the dimensions to be plotted (either two or three of all possible dimensions). Default value is <code>NULL</code>. In this case, <code>kr</code> is given by <code>1:min(k,3)</code>.</p>
</td></tr>
<tr><td><code id="plotFateMap_+3A_col">col</code></td>
<td>
<p>optional vector of valid color names for all clusters in <code>y</code> ordered by increasing cluster number. Default value is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="plotFateMap_+3A_fb">fb</code></td>
<td>
<p>fateBias object returned by the function <code>fateBias</code>. If <code>fb</code> is provided, then a principal curve is computed and shown in the plot. Default value is <code>NULL</code>. The curve is only displayed if <code>g</code> equal <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="plotFateMap_+3A_trthr">trthr</code></td>
<td>
<p>real value representing the threshold of the fraction of random forest votes required for the inclusion of a given cell for the computation of the principal curve. If <code>NULL</code> then only cells with a significant bias &gt;1 are included for each trajectory. The bias is computed as the ratio of the number of votes for a trajectory and the number of votes for the trajectory with the second largest number of votes. By this means only the trajectory with the largest number of votes will receive a bias &gt;1. The siginifcance is computed based on counting statistics on the difference in the number of votes. A significant bias requires a p-value &lt; 0.05. Default value is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="plotFateMap_+3A_start">start</code></td>
<td>
<p>integer number representing a specified starting cluster number for all trajectories, i. e. a common progenitor cluster. The argument is optional. Default value is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="plotFateMap_+3A_tp">tp</code></td>
<td>
<p>Transparency of points in the plot to allow better visibility of the principal curves. Default value is 1, i. e. non-transparent.</p>
</td></tr>
<tr><td><code id="plotFateMap_+3A_seed">seed</code></td>
<td>
<p>integer number. Random seed for determining colour scheme. Default is 12345.</p>
</td></tr>
<tr><td><code id="plotFateMap_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to the low level function <code>principal_curve</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>fb</code> is provided as input argument and <code>prc</code> equals <code>TRUE</code> then the output corresponds to the output of <code>prcurve</code>. Otherwise, only ouput is generated is <code>g</code> equals E. In this case a vector of fate bias entropies for all cells is given.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- intestine$x
y &lt;- intestine$y
# v contains all genes (no feature selection like in x)
v &lt;- intestine$v
fcol &lt;- intestine$fcol
tar &lt;- c(6,9,13)
fb &lt;- fateBias(x,y,tar,z=NULL,minnr=5,minnrh=10,nbfactor=5,use.dist=FALSE,seed=NULL,nbtree=NULL)
dr &lt;- compdr(x,z=NULL,m="cmd",k=2,tsne.perplexity=30)

# plot principal curves
pr &lt;- plotFateMap(y,dr,k=2,prc=TRUE,m="cmd",col=fcol,fb=fb,trthr=0.25,start=NULL,tp=.5)

# plot expression of gene Apoa1__chr9
plotFateMap(y,dr,x=v,g="Apoa1__chr9",prc=FALSE,k=2,m="cmd",col=intestine$fcol)

</code></pre>

<hr>
<h2 id='plotheatmap'>Heatmap of expression profiles</h2><span id='topic+plotheatmap'></span>

<h3>Description</h3>

<p>This function allows plotting of normalized or z-score transformed pseudo-temporal expression profiles and permits highlighting of partitioning along the x-axis and the y-axis
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotheatmap(
  x,
  xpart = NULL,
  xcol = NULL,
  xlab = TRUE,
  xgrid = FALSE,
  ypart = NULL,
  ycol = NULL,
  ylab = TRUE,
  ygrid = FALSE,
  cex = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotheatmap_+3A_x">x</code></td>
<td>
<p>data frame with input data to show. Columns will be displayed on the x-axis and rows on the y-axis in the order given in <code>x</code>. For example, columns can correspond to cells in pseudo-temporal order and rows contain gene expression, i. e. rows can represent pseudo-temporal gene expression profiles.</p>
</td></tr>
<tr><td><code id="plotheatmap_+3A_xpart">xpart</code></td>
<td>
<p>optional vector with integer values indicating partitioning of the data points along the x-axis. For instance, <code>xpart</code> can be a cluster assignment of cell IDs. The order of the components has to be the same as for the columns in <code>x</code>. Default value is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="plotheatmap_+3A_xcol">xcol</code></td>
<td>
<p>optional vector with valid color names. The number of components has to be equal to the number of different values on <code>xpart</code>. If provided, these colors are used to highlight partitioning along the x-axis based on <code>xpart</code>. Default value is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="plotheatmap_+3A_xlab">xlab</code></td>
<td>
<p>logical value. If <code>TRUE</code> then the average position is indicated for each partition value along the x-axis. Default value is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="plotheatmap_+3A_xgrid">xgrid</code></td>
<td>
<p>logical value. If <code>TRUE</code> then the partitioning along the x-axis is indicated by vertical lines representing the boundaries of all positions with a given value in <code>xpart</code>.</p>
</td></tr>
<tr><td><code id="plotheatmap_+3A_ypart">ypart</code></td>
<td>
<p>optional vector with integer values indicating partitioning of the data points along the y-axis. For instance, <code>ypart</code> can be the assignment of gene IDs to nodes of a sel-organizing map. The order of the components has to be the same as for the rows in <code>x</code>. Default value is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="plotheatmap_+3A_ycol">ycol</code></td>
<td>
<p>optional vector with valid color names. The number of components has to be equal to the number of different values on <code>ypart</code>. If provided, these colors are used to highlight partitioning along the y-axis based on <code>ypart</code>. Default value is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="plotheatmap_+3A_ylab">ylab</code></td>
<td>
<p>logical value. If <code>TRUE</code> then the average position is indicated for each partition value along the y-axis. Default value is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="plotheatmap_+3A_ygrid">ygrid</code></td>
<td>
<p>logical value. If <code>TRUE</code> then the partitioning along the y-axis is indicated by horizontal lines representing the boundaries of all positions with a given value in <code>ypart</code>.</p>
</td></tr>
<tr><td><code id="plotheatmap_+3A_cex">cex</code></td>
<td>
<p>positive real number. Size of axis labels. Default is 1.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

x &lt;- intestine$x
y &lt;- intestine$y
v &lt;- intestine$v
fcol &lt;- intestine$col

tar &lt;- c(6,9,13)
fb &lt;- fateBias(x,y,tar,z=NULL,minnr=5,minnrh=10,nbfactor=5,use.dist=FALSE,seed=NULL,nbtree=NULL)
dr &lt;- compdr(x,z=NULL,m="cmd",k=2,tsne.perplexity=30)
pr &lt;- prcurve(y,fb,dr,k=2,m="cmd",trthr=0.4,start=NULL)
n &lt;- pr$trc[["t6"]]
fs  &lt;- filterset(v,n,minexpr=2,minnumber=1)
s1d &lt;- getsom(fs,nb=1000,alpha=.5)
ps &lt;- procsom(s1d,corthr=.85,minsom=3)
plotheatmap(ps$all.e,xpart=y[n],xcol=fcol,ypart=ps$nodes,xgrid=FALSE,ygrid=TRUE,xlab=FALSE)


</code></pre>

<hr>
<h2 id='prcurve'>Computation of a principal curve for a given dimensional reduction representation</h2><span id='topic+prcurve'></span>

<h3>Description</h3>

<p>This function computes a principal curve for a given dimensional reduction representation which is specified by component names of an object returned by <code>compdr</code> using the <span class="pkg">princurve</span> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prcurve(y, fb, dr, k = 2, m = "cmd", trthr = NULL, start = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prcurve_+3A_y">y</code></td>
<td>
<p>clustering partition. A vector with an integer cluster number for each cell. The order of the cells has to be the same as for the columns of x.</p>
</td></tr>
<tr><td><code id="prcurve_+3A_fb">fb</code></td>
<td>
<p>fateBias object returned by the function <code>fateBias</code>.</p>
</td></tr>
<tr><td><code id="prcurve_+3A_dr">dr</code></td>
<td>
<p>list of dimensional reduction representations returned by the function <code>compdr</code>.</p>
</td></tr>
<tr><td><code id="prcurve_+3A_k">k</code></td>
<td>
<p>integer number for the dimension to be used. This dimension has to be present in <code>dr</code>. Default value is 2.</p>
</td></tr>
<tr><td><code id="prcurve_+3A_m">m</code></td>
<td>
<p>name of the dimensional reduction algorithms to be used for the principal curve computation. One of <code>cmd</code>, <code>dm</code>, <code>tsne</code>, <code>umap</code>. Default value is <code>cmd</code>. Has to be a component of <code>dr</code>, i.e. previously computed by <code>compdr</code>.</p>
</td></tr>
<tr><td><code id="prcurve_+3A_trthr">trthr</code></td>
<td>
<p>real value representing the threshold of the fraction of random forest votes required for the inclusion of a given cell for the computation of the principal curve. If <code>NULL</code> then only cells with a significant bias &gt;1 are included for each trajectory. The bias is computed as the ratio of the number of votes for a trajectory and the number of votes for the trajectory with the second largest number of votes. By this means only the trajectory with the largest number of votes will receive a bias &gt;1. The siginifcance is computed based on counting statistics on the difference in the number of votes. A significant bias requires a p-value &lt; 0.05. Default value is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="prcurve_+3A_start">start</code></td>
<td>
<p>integer number representing a specified starting cluster number for all trajectories, i. e. a common progenitor cluster. The argument is optional. Default value is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="prcurve_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to the low level function <code>principal_curve</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function computes a principal curve for each differentiation trajectory by considering only cells that are assigned to the trajectory with a significant fate bias &gt;1 or at least <code>trthr</code> of the random forest votes, respectively.
</p>
<p>For simulateneous computation and plotting of the principal curve, see function <code>plotFateMap</code>.
</p>


<h3>Value</h3>

<p>A list of the following two components:
</p>
<table>
<tr><td><code>pr</code></td>
<td>
<p>A list of principal curve objects produced by the <code>principal_curve</code> function from the <span class="pkg">princurve</span> package. Each component corresponds to one differentiation trajectory giving rise to one of the target clusters from the <code>fb</code> object.</p>
</td></tr>
<tr><td><code>trc</code></td>
<td>
<p>A list of ordered cell IDs for each trajectory in <code>pr</code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- intestine$x
y &lt;- intestine$y
tar &lt;- c(6,9,13)
fb &lt;- fateBias(x,y,tar,z=NULL,minnr=5,minnrh=10,nbfactor=5,use.dist=FALSE,seed=NULL,nbtree=NULL)
dr &lt;- compdr(x,z=NULL,m="cmd",k=2,tsne.perplexity=30)
pr &lt;- prcurve(y,fb,dr,k=2,m="cmd",trthr=0.25,start=NULL)

</code></pre>

<hr>
<h2 id='procsom'>Processing of self-organizing maps for pseudo-temporal expression profiles</h2><span id='topic+procsom'></span>

<h3>Description</h3>

<p>This function processes the self-organizing maps produced by the function <code>getsom</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>procsom(s1d, corthr = 0.85, minsom = 3)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="procsom_+3A_s1d">s1d</code></td>
<td>
<p>output of function <code>getsom</code></p>
</td></tr>
<tr><td><code id="procsom_+3A_corthr">corthr</code></td>
<td>
<p>correlation threshold, i. e. a real number between 0 and 1. The z-score of the average normalized pseudo-temporal expression profiles within each node of the self-organizing map is computed, and the correlation of these z-scores between neighbouring nodes is computed. If the correlation is greater than <code>corthr</code>, neighbouring nodes are merged. Default value is 0.85.</p>
</td></tr>
<tr><td><code id="procsom_+3A_minsom">minsom</code></td>
<td>
<p>positive integer number. Nodes of the self-organizing map with less than <code>minsom</code> transcripts are discarded. Default value is 3.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of the following seven components:
</p>
<table>
<tr><td><code>k</code></td>
<td>
<p>vector of Pearson's correlation coefficient between node <code>i</code> and node <code>i+1</code> of the populated nodes of the self-organizing map.</p>
</td></tr>
<tr><td><code>nodes</code></td>
<td>
<p>vector with assignment of genes to nodes of the final self-organizing map (after merging). Components are node numbers and component names are gene IDs.</p>
</td></tr>
<tr><td><code>nodes.e</code></td>
<td>
<p>data frame with average normalized pseudo-temporal expression profile for each node, ordered by node number.</p>
</td></tr>
<tr><td><code>nodes.z</code></td>
<td>
<p>data frame with z-score transformed average normalized pseudo-temporal expression profile for each node, ordered by node number.</p>
</td></tr>
<tr><td><code>all.e</code></td>
<td>
<p>data frame with normalized pseudo-temporal expression profile for all genes in the self-organizing map, ordered by node number.</p>
</td></tr>
<tr><td><code>all.z</code></td>
<td>
<p>data frame with z-score transformed normalized pseudo-temporal expression profile for all genes in the self-organizing map, ordered by node number.</p>
</td></tr>
<tr><td><code>all.b</code></td>
<td>
<p>data frame with binarized pseudo-temporal expression profile for all genes in the self-organizing map, ordered by node number. Expression is 1 in cells with z-score &gt; 1 and -1 in cells with z-score &lt; -1, and 0 otherwise.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>

x &lt;- intestine$x
y &lt;- intestine$y
v &lt;- intestine$v

tar &lt;- c(6,9,13)
fb &lt;- fateBias(x,y,tar,z=NULL,minnr=5,minnrh=10,nbfactor=5,use.dist=FALSE,seed=NULL,nbtree=NULL)
dr &lt;- compdr(x,z=NULL,m="cmd",k=2,tsne.perplexity=30)
pr &lt;- prcurve(y,fb,dr,k=2,m="cmd",trthr=0.4,start=NULL)
n &lt;- pr$trc[["t6"]]
fs  &lt;- filterset(v,n,minexpr=2,minnumber=1)
s1d &lt;- getsom(fs,nb=1000,alpha=.5)
ps &lt;- procsom(s1d,corthr=.85,minsom=3)


</code></pre>

<hr>
<h2 id='reclassify'>Reclassification of cells</h2><span id='topic+reclassify'></span>

<h3>Description</h3>

<p>This function attempts to reassign additional cells in the dataset to one of the target clusters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reclassify(
  x,
  y,
  tar,
  z = NULL,
  clthr = 0.75,
  nbfactor = 5,
  use.dist = FALSE,
  seed = NULL,
  nbtree = NULL,
  q = 0.9,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reclassify_+3A_x">x</code></td>
<td>
<p>expression data frame with genes as rows and cells as columns. Gene IDs should be given as row names and cell IDs should be given as column names. This can be a reduced expression table only including the features (genes) to be used in the analysis.</p>
</td></tr>
<tr><td><code id="reclassify_+3A_y">y</code></td>
<td>
<p>clustering partition. A vector with an integer cluster number for each cell. The order of the cells has to be the same as for the columns of x.</p>
</td></tr>
<tr><td><code id="reclassify_+3A_tar">tar</code></td>
<td>
<p>vector of integers representing target cluster numbers. Each element of <code>tar</code> corresponds to a cluster of cells committed towards a particular mature state. One cluster per different cell lineage has to be given and is used as a starting point for learning the differentiation trajectory.</p>
</td></tr>
<tr><td><code id="reclassify_+3A_z">z</code></td>
<td>
<p>Matrix containing cell-to-cell distances to be used in the fate bias computation. Default is <code>NULL</code>. In this case, a correlation-based distance is computed from <code>x</code> by <code>1 - cor(x)</code></p>
</td></tr>
<tr><td><code id="reclassify_+3A_clthr">clthr</code></td>
<td>
<p>real number between zero and one. This is the threshold for the fraction of random forest votes required to assign a cell not contained within the target clusters to one of these clusters. The value of this parameter should be sufficiently high to only reclassify cells with a high-confidence assignment. Default value is 0.9.</p>
</td></tr>
<tr><td><code id="reclassify_+3A_nbfactor">nbfactor</code></td>
<td>
<p>positive integer number. Determines the number of trees grown for each random forest. The number of trees is given by the number of columns of th training set multiplied by <code>nbfactor</code>. Default value is 5.</p>
</td></tr>
<tr><td><code id="reclassify_+3A_use.dist">use.dist</code></td>
<td>
<p>logical value. If <code>TRUE</code> then the distance matrix is used as feature matrix (i. e. <code>z</code> if not equal to <code>NULL</code> and <code>1-cor(x)</code> otherwise). If <code>FALSE</code>, gene expression values in <code>x</code> are used. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="reclassify_+3A_seed">seed</code></td>
<td>
<p>integer seed for initialization. If equal to <code>NULL</code> then each run will yield slightly different results due to the radomness of the random forest algorithm. Default is <code>NULL</code></p>
</td></tr>
<tr><td><code id="reclassify_+3A_nbtree">nbtree</code></td>
<td>
<p>integer value. If given, it specifies the number of trees for each random forest explicitely. Default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="reclassify_+3A_q">q</code></td>
<td>
<p>real value between zero and one. This number specifies a threshold used for feature selection based on importance sampling. A reduced expression table is generated containing only features with an importance larger than the q-quantile for at least one of the classes (i. e. target clusters). Default value is 0.75.</p>
</td></tr>
<tr><td><code id="reclassify_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to the low level function <code>randomForest</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function uses random forest based supervised learning to assign cells not contained in the target clusters to one of these clusters. All cells not within any of the target clusters which receive a fraction of votes larger than <code>clthr</code> for one of the target clusters will be reassigned to this cluster. Since this function is developed to reclassify cells only if they can be assigned with high confidence, a high value of <code>clthr</code> (e. g. &gt; 0.75) should be applied.
</p>


<h3>Value</h3>

<p>A list with the following three components:
</p>
<table>
<tr><td><code>part</code></td>
<td>
<p>A vector with the revised cluster assignment for each cell in the same order as in the input argument <code>y</code>.</p>
</td></tr>
<tr><td><code>rf</code></td>
<td>
<p>The random forest object generated for the reclassification, with enabled importance sampling (see <span class="pkg">randomForest</span>).</p>
</td></tr>
<tr><td><code>xf</code></td>
<td>
<p>A filtered expression table with features extracted based on the important samples, only features with an importance larger than the q-quantile are for at least one of the classes are retained.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- intestine$x
y &lt;- intestine$y
tar &lt;- c(6,9,13)
rc &lt;- reclassify(x,y,tar,z=NULL,nbfactor=5,use.dist=FALSE,seed=NULL,nbtree=NULL,q=.9)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
