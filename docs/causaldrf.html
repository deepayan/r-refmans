<!DOCTYPE html><html><head><title>Help for package causaldrf</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {causaldrf}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#add_spl_est'><p>The additive spline estimator</p></a></li>
<li><a href='#aipwee_est'><p>Prediction with a residual bias correction estimator</p></a></li>
<li><a href='#bart_est'><p>The BART estimator</p></a></li>
<li><a href='#gam_est'><p>The GAM estimator</p></a></li>
<li><a href='#get_ci'><p>This calculates an upper and lower bound from bootstrap matrix</p></a></li>
<li><a href='#hi_est'><p>The Hirano and Imbens estimator</p></a></li>
<li><a href='#hi_sim_data'><p>Simulated data from Hirano and Imbens (2004)</p></a></li>
<li><a href='#iptw_est'><p>The inverse probability of treatment weighting (iptw) estimator</p></a></li>
<li><a href='#ismw_est'><p>The inverse second moment weighting (ismw) estimator</p></a></li>
<li><a href='#iw_est'><p>The inverse weighting estimator (nonparametric method)</p></a></li>
<li><a href='#nmes_data'><p>Data set containing data from the National Medical Expenditure Survey (NMES)</p></a></li>
<li><a href='#nw_est'><p>The Nadaraya-Watson modified estimator</p></a></li>
<li><a href='#overlap_fun'><p>This function creates an overlapping dataset</p></a></li>
<li><a href='#prop_spline_est'><p>The propensity-spline prediction estimator</p></a></li>
<li><a href='#reg_est'><p>The regression prediction estimator</p></a></li>
<li><a href='#scalar_wts'><p>This function calculates scalar weights for use in other models</p></a></li>
<li><a href='#sim_data'><p>Simulated data from Schafer and Galagate (2015)</p></a></li>
<li><a href='#t_mod'><p>A function to estimate conditional expected values and higher order moments</p></a></li>
<li><a href='#wtrg_est'><p>The weighted regression estimator</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Estimating Causal Dose Response Functions</td>
</tr>
<tr>
<td>Version:</td>
<td>0.4.2</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-09-29</td>
</tr>
<tr>
<td>Description:</td>
<td>Functions and data to estimate causal dose response functions given continuous, ordinal, or binary treatments.  A description of the methods is given in Galagate (2016) <a href="https://drum.lib.umd.edu/handle/1903/18170">https://drum.lib.umd.edu/handle/1903/18170</a>.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>LazyData:</td>
<td>TRUE</td>
</tr>
<tr>
<td>Depends:</td>
<td>R(&ge; 3.1.2)</td>
</tr>
<tr>
<td>Imports:</td>
<td>mgcv, splines, stats, survey,</td>
</tr>
<tr>
<td>Suggests:</td>
<td>BayesTree, dplyr, foreign, Hmisc, knitr, MASS, nnet,
reshape2, rmarkdown, sas7bdat, testthat, tidyr</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-09-29 19:28:22 UTC; DGalaga</td>
</tr>
<tr>
<td>Author:</td>
<td>Douglas Galagate [cre],
  Joseph Schafer [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Douglas Galagate &lt;galagated@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-09-29 20:40:10 UTC</td>
</tr>
</table>
<hr>
<h2 id='add_spl_est'>The additive spline estimator</h2><span id='topic+add_spl_est'></span>

<h3>Description</h3>

<p>This function estimates the ADRF with an additive spline estimator described
in Bia et al. (2014).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_spl_est(Y,
            treat,
            treat_formula,
            data,
            grid_val,
            knot_num,
            treat_mod,
            link_function,
            ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_spl_est_+3A_y">Y</code></td>
<td>
<p>is the the name of the outcome variable contained in <code>data</code>.</p>
</td></tr>
<tr><td><code id="add_spl_est_+3A_treat">treat</code></td>
<td>
<p>is the name of the treatment variable contained in
<code>data</code>.</p>
</td></tr>
<tr><td><code id="add_spl_est_+3A_treat_formula">treat_formula</code></td>
<td>
<p>an object of class &quot;formula&quot; (or one that can be
coerced to that class) that regresses <code>treat</code> on a linear combination
of <code>X</code>: a symbolic description of the model to be fitted.</p>
</td></tr>
<tr><td><code id="add_spl_est_+3A_data">data</code></td>
<td>
<p>is a dataframe containing <code>Y</code>, <code>treat</code>, and
<code>X</code>.</p>
</td></tr>
<tr><td><code id="add_spl_est_+3A_grid_val">grid_val</code></td>
<td>
<p>contains the treatment values to be evaluated.</p>
</td></tr>
<tr><td><code id="add_spl_est_+3A_knot_num">knot_num</code></td>
<td>
<p>is the number of knots used in outcome model</p>
</td></tr>
<tr><td><code id="add_spl_est_+3A_treat_mod">treat_mod</code></td>
<td>
<p>a description of the error distribution to be used in the
model for treatment. Options include: <code>"Normal"</code> for normal model,
<code>"LogNormal"</code> for lognormal model, <code>"Sqrt"</code> for square-root transformation
to a normal treatment, <code>"Poisson"</code> for Poisson model,
<code>"NegBinom"</code> for negative binomial model, <code>"Gamma"</code> for gamma
model.</p>
</td></tr>
<tr><td><code id="add_spl_est_+3A_link_function">link_function</code></td>
<td>
<p>is either &quot;log&quot;, &quot;inverse&quot;, or &quot;identity&quot; for the
&quot;Gamma&quot; <code>treat_mod</code>.</p>
</td></tr>
<tr><td><code id="add_spl_est_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to the outcome regression fitting function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function estimates the ADRF using additive splines in the
outcome model described in Bia et al. (2014).
</p>


<h3>Value</h3>

<p><code>add_spl_est</code>  returns an object of class &quot;causaldrf&quot;,
a list that contains the following components:
</p>
<table>
<tr><td><code>param</code></td>
<td>
<p>parameter estimates for a add_spl fit.</p>
</td></tr>
<tr><td><code>t_mod</code></td>
<td>
<p>the result of the treatment model fit.</p>
</td></tr>
<tr><td><code>out_mod</code></td>
<td>
<p>the result of the outcome model fit.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>the matched call.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Schafer, J.L., Galagate, D.L. (2015).  Causal inference with a
continuous treatment and outcome: alternative estimators for parametric
dose-response models. <em>Manuscript in preparation</em>.
</p>
<p>Bia, Michela, et al. (2014). A Stata package for the application of
semiparametric estimators of dose response functions.  <em>Stata Journal</em>
<b>14.3</b>, 580-604.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+nw_est">nw_est</a></code>, <code><a href="#topic+iw_est">iw_est</a></code>, <code><a href="#topic+hi_est">hi_est</a></code>, <code><a href="#topic+gam_est">gam_est</a></code>,
<code><a href="#topic+bart_est">bart_est</a></code>, etc. for other estimates.
</p>
<p><code><a href="#topic+t_mod">t_mod</a></code>, <code><a href="#topic+overlap_fun">overlap_fun</a></code> to prepare the <code>data</code>
for use in the different estimates.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Example from Schafer (2015).
example_data &lt;- sim_data
add_spl_list &lt;- add_spl_est(Y = Y,
            treat = T,
            treat_formula = T ~ B.1 + B.2 + B.3 + B.4 + B.5 + B.6 + B.7 + B.8,
            data = example_data,
            grid_val = seq(8, 16, by = 1),
            knot_num = 3,
            treat_mod = "Normal")


sample_index &lt;- sample(1:1000, 100)
plot(example_data$T[sample_index],
      example_data$Y[sample_index],
      xlab = "T",
      ylab = "Y",
      main = "additive spline estimate")

lines(seq(8, 16, by = 1),
      add_spl_list$param,
      lty = 2,
      lwd = 2,
      col = "blue")
legend('bottomright',
        "additive spline estimate",
        lty=2,
        lwd = 2,
        col = "blue",
        bty='Y', cex=1)

rm(example_data, add_spl_list, sample_index)

## See Vignette for more examples.
</code></pre>

<hr>
<h2 id='aipwee_est'>Prediction with a residual bias correction estimator</h2><span id='topic+aipwee_est'></span>

<h3>Description</h3>

<p>This method combines the regression estimator with a residual bias correction
for estimating a parametric ADRF.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>aipwee_est(Y,
           treat,
           covar_formula = ~ 1,
           covar_lin_formula = ~ 1,
           covar_sq_formula = ~ 1,
           data,
           e_treat_1 = NULL,
           e_treat_2 = NULL,
           e_treat_3 = NULL,
           e_treat_4 = NULL,
           degree = 1,
           wt = NULL,
           method = "same",
           spline_df = NULL,
           spline_const = 1,
           spline_linear = 1,
           spline_quad = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="aipwee_est_+3A_y">Y</code></td>
<td>
<p>is the the name of the outcome variable contained in <code>data</code>.</p>
</td></tr>
<tr><td><code id="aipwee_est_+3A_treat">treat</code></td>
<td>
<p>is the name of the treatment variable contained in
<code>data</code>.</p>
</td></tr>
<tr><td><code id="aipwee_est_+3A_covar_formula">covar_formula</code></td>
<td>
<p>is the formula to describe the covariates needed
to estimate the constant term:
<code>~ X.1 + ....</code>. Can include higher order terms or interactions.  i.e.
<code>~ X.1 + I(X.1^2) + X.1 * X.2 + ....</code>.  Don't forget the tilde before
listing the covariates.</p>
</td></tr>
<tr><td><code id="aipwee_est_+3A_covar_lin_formula">covar_lin_formula</code></td>
<td>
<p>is the formula to describe the covariates needed
to estimate the linear term, t:
<code>~ X.1 + ....</code>. Can include higher order terms or interactions.  i.e.
<code>~ X.1 + I(X.1^2) + X.1 * X.2 + ....</code>.  Don't forget the tilde before
listing the covariates.</p>
</td></tr>
<tr><td><code id="aipwee_est_+3A_covar_sq_formula">covar_sq_formula</code></td>
<td>
<p>is the formula to describe the covariates needed
to estimate the quadratic term, t^2:
<code>~ X.1 + ....</code>. Can include higher order terms or interactions.  i.e.
<code>~ X.1 + I(X.1^2) + X.1 * X.2 + ....</code>.  Don't forget the tilde before
listing the covariates.</p>
</td></tr>
<tr><td><code id="aipwee_est_+3A_data">data</code></td>
<td>
<p>is a dataframe containing <code>Y</code>, <code>treat</code>, and
<code>X</code>.</p>
</td></tr>
<tr><td><code id="aipwee_est_+3A_e_treat_1">e_treat_1</code></td>
<td>
<p>a vector, representing the conditional expectation of
<code>treat</code> from <code>T_mod</code>.</p>
</td></tr>
<tr><td><code id="aipwee_est_+3A_e_treat_2">e_treat_2</code></td>
<td>
<p>a vector, representing the conditional expectation of
<code>treat^2</code> from <code>T_mod</code>.</p>
</td></tr>
<tr><td><code id="aipwee_est_+3A_e_treat_3">e_treat_3</code></td>
<td>
<p>a vector, representing the conditional expectation of
<code>treat^3</code> from <code>T_mod</code>.</p>
</td></tr>
<tr><td><code id="aipwee_est_+3A_e_treat_4">e_treat_4</code></td>
<td>
<p>a vector, representing the conditional expectation of
<code>treat^4</code> from <code>T_mod</code>.</p>
</td></tr>
<tr><td><code id="aipwee_est_+3A_degree">degree</code></td>
<td>
<p>is 1 for linear and 2 for quadratic outcome model.</p>
</td></tr>
<tr><td><code id="aipwee_est_+3A_wt">wt</code></td>
<td>
<p>is weight used in lsfit for outcome regression.
Default is wt = NULL.</p>
</td></tr>
<tr><td><code id="aipwee_est_+3A_method">method</code></td>
<td>
<p>is &quot;same&quot; if the same set of covariates are used to estimate
the constant, linear, and/or quadratic term.  If method = &quot;different&quot;, then
different sets of covariates can be used to estimate the constant, linear,
and/or quadratic term.  covar_lin_formula and covar_sq_formula must be specified
if method = &quot;different&quot;.</p>
</td></tr>
<tr><td><code id="aipwee_est_+3A_spline_df">spline_df</code></td>
<td>
<p>degrees of freedom. The default, spline_df = NULL, corresponds to no knots.</p>
</td></tr>
<tr><td><code id="aipwee_est_+3A_spline_const">spline_const</code></td>
<td>
<p>is the number of spline terms needed to estimate the constant term.</p>
</td></tr>
<tr><td><code id="aipwee_est_+3A_spline_linear">spline_linear</code></td>
<td>
<p>is the number of spline terms needed to estimate the linear term.</p>
</td></tr>
<tr><td><code id="aipwee_est_+3A_spline_quad">spline_quad</code></td>
<td>
<p>is the number of spline terms needed to estimate the quadratic term.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This estimator bears a strong
resemblance to general regression estimators in the survey
literature, part of a more general class of calibration
estimators (Deville and Sarndal, 1992). It is
doubly robust, which means that it is consistent if
either of the models is true (Scharfstein, Rotnitzky and Robins
1999).  If the Y-model is correct, then the first term in
the previous equation is unbiased for <code class="reqn">\xi</code> and the second term has mean
zero even if the T-model is wrong. If the Y-model is incorrect, the
first term is biased, but the second term gives a consistent estimate
of (minus one times) the bias from the Y-model if the T-model is
correct.
</p>
<p>This function is a doubly-robust estimator that fits an outcome regression
model with a bias correction term.  For details see Schafer and Galagate (2015).
</p>


<h3>Value</h3>

<p><code>aipwee_est</code>  returns an object of class &quot;causaldrf_lsfit&quot;,
a list that contains the following components:
</p>
<table>
<tr><td><code>param</code></td>
<td>
<p>parameter estimates for a add_spl fit.</p>
</td></tr>
<tr><td><code>t_mod</code></td>
<td>
<p>the result of the treatment model fit.</p>
</td></tr>
<tr><td><code>out_mod</code></td>
<td>
<p>the result of the outcome model fit.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>the matched call.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Schafer, J.L., Galagate, D.L. (2015).  Causal inference with a
continuous treatment and outcome: alternative estimators for parametric
dose-response models. <em>Manuscript in preparation</em>.
</p>
<p>Schafer, Joseph L, Kang, Joseph (2008).  Average causal effects from
nonrandomized studies: a practical guide and simulated example.
<em>Psychological methods</em>, <b>13.4</b>, 279.
</p>
<p>Robins, James M and Rotnitzky, Andrea (1995).
Semiparametric efficiency in multivariate regression models with missing data
<em>Journal of the American Statistical Association</em>, <b>90.429</b>, 122&ndash;129.
</p>
<p>Scharfstein, Daniel O and Rotnitzky, Andrea and Robins, James M (1999).
Adjusting for nonignorable drop-out using semiparametric nonresponse models
<em>Journal of the American Statistical Association</em>, <b>94.448</b>, 1096&ndash;1120.
</p>
<p>Deville, Jean-Claude and Sarndal, Carl-Erik (1992).
Calibration estimators in survey sampling
<em>Journal of the American Statistical Association</em>, <b>87.418</b>, 376&ndash;380.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+iptw_est">iptw_est</a></code>, <code><a href="#topic+ismw_est">ismw_est</a></code>,
<code><a href="#topic+reg_est">reg_est</a></code>, <code><a href="#topic+wtrg_est">wtrg_est</a></code>,
##'    etc. for other estimates.
</p>
<p><code><a href="#topic+t_mod">t_mod</a></code>, <code><a href="#topic+overlap_fun">overlap_fun</a></code> to prepare the <code>data</code>
for use in the different estimates.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Example from Schafer (2015).

example_data &lt;- sim_data


t_mod_list &lt;- t_mod(treat = T,
              treat_formula = T ~ B.1 + B.2 + B.3 + B.4 + B.5 + B.6 + B.7 + B.8,
              data = example_data,
              treat_mod = "Normal")

cond_exp_data &lt;- t_mod_list$T_data
full_data &lt;- cbind(example_data, cond_exp_data)

aipwee_list &lt;- aipwee_est(Y = Y,
                         treat = T,
                         covar_formula = ~ B.1 + B.2 + B.3 + B.4 + B.5 + B.6 + B.7 + B.8,
                         covar_lin_formula = ~ 1,
                         covar_sq_formula = ~ 1,
                         data = example_data,
                         e_treat_1 = full_data$est_treat,
                         e_treat_2 = full_data$est_treat_sq,
                         e_treat_3 = full_data$est_treat_cube,
                         e_treat_4 = full_data$est_treat_quartic,
                         degree = 1,
                         wt = NULL,
                         method = "same",
                         spline_df = NULL,
                         spline_const = 1,
                         spline_linear = 1,
                         spline_quad = 1)

sample_index &lt;- sample(1:1000, 100)

plot(example_data$T[sample_index],
      example_data$Y[sample_index],
      xlab = "T",
      ylab = "Y",
      main = "aipwee estimate")

abline(aipwee_list$param[1],
        aipwee_list$param[2],
        lty = 2,
        lwd = 2,
        col = "blue")

legend('bottomright',
        "aipwee estimate",
        lty = 2,
        lwd = 2,
        col = "blue",
        bty='Y',
        cex=1)

rm(example_data, t_mod_list, cond_exp_data, full_data, aipwee_list, sample_index)
</code></pre>

<hr>
<h2 id='bart_est'>The BART estimator</h2><span id='topic+bart_est'></span>

<h3>Description</h3>

<p>This function estimates the ADRF using Bayesian additive regression trees (BART).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bart_est(Y,
         treat,
         outcome_formula,
         data,
         grid_val,
         ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bart_est_+3A_y">Y</code></td>
<td>
<p>is the the name of the outcome variable contained in <code>data</code>.</p>
</td></tr>
<tr><td><code id="bart_est_+3A_treat">treat</code></td>
<td>
<p>is the name of the treatment variable contained in
<code>data</code>.</p>
</td></tr>
<tr><td><code id="bart_est_+3A_outcome_formula">outcome_formula</code></td>
<td>
<p>is the formula used for fitting the outcome surface.
gps is one of the independent variables to use in the outcome_formula. ie.
<code>Y ~ treat + X.1 + X.2 + ...</code> or a variation of this.</p>
</td></tr>
<tr><td><code id="bart_est_+3A_data">data</code></td>
<td>
<p>is a dataframe containing <code>Y</code>, <code>treat</code>, and
<code>X</code>.</p>
</td></tr>
<tr><td><code id="bart_est_+3A_grid_val">grid_val</code></td>
<td>
<p>contains the treatment values to be evaluated.</p>
</td></tr>
<tr><td><code id="bart_est_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to the bart() outcome function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>BART is a prediction model that is applicable to many settings, one of which
is causal inference problems.  It is a sum of trees fit, but the influence
of each tree is held back by a regularization prior so that each tree only
contributes a small amount to the overall fit.  Priors are put on the
parameters to avoid overfitting the data and so that no single tree has
a significant influence on the model fit.
For more details see Chipman (2010).
</p>
<p>BART does not require fitting a treatment model.  Instead, it fits a
response surface to the whole dataset and if the response surface is
correctly specified, then the causal effect estimate is unbiased.
Although most of the focus on BART is for the binary treatment setting,
Hill (2011) also mentions an extension to the continuous or
multidose treatment setting.  When using BART in this continuous treatment
setting, Hill (2011) compares the outcomes of units with
treatment level <code class="reqn">T_i = t</code> to their outcomes had <code class="reqn">T_i = 0</code>.
This method infers the treatment effect of units had they not received
treatment compared to their actual observed treatment.  The comparison
is between <code class="reqn">Y_i(0)| (I = 1, T_i = t)</code> and <code class="reqn">Y_i(t)| (I = 1, T_i = t)</code>
where <code class="reqn">I = 1</code> means that the unit is part of the treatment group.
The causal effect is comparing the predicted outcome of units that
received treatment with what their predicted outcome would have been
had they received zero treatment.
</p>
<p>This method performs well in simulation studies.
One drawback from BART is the amount of computing time needed.
</p>


<h3>Value</h3>

<p><code>bart_est</code> returns an object of class &quot;causaldrf_simple&quot;,
a list that contains the following components:
</p>
<table>
<tr><td><code>param</code></td>
<td>
<p>parameter estimates for a bart fit.</p>
</td></tr>
<tr><td><code>out_mod</code></td>
<td>
<p>the result of the bart fit.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>the matched call.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Schafer, J.L., Galagate, D.L. (2015).  Causal inference with a
continuous treatment and outcome: alternative estimators for parametric
dose-response models. <em>Manuscript in preparation</em>.
</p>
<p>Hill, Jennifer L. (2011). Bayesian nonparametric modeling for causal
inference. <em>Journal of Computational and Graphical Statistics</em>
<b>20.1</b> (2011).
</p>
<p>Chipman, Hugh A and George, Edward I and McCulloch, Robert E and others (2010).
BART: Bayesian additive regression trees.
<em>The Annals of Applied Statistics</em>
<b>4.1</b>, 266&ndash;298.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+nw_est">nw_est</a></code>, <code><a href="#topic+iw_est">iw_est</a></code>, <code><a href="#topic+hi_est">hi_est</a></code>, <code><a href="#topic+gam_est">gam_est</a></code>,
<code><a href="#topic+add_spl_est">add_spl_est</a></code>, etc. for other estimates.
</p>
<p><code><a href="#topic+t_mod">t_mod</a></code>, <code><a href="#topic+overlap_fun">overlap_fun</a></code> to prepare the <code>data</code>
for use in the different estimates.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Example from Schafer (2015).  bart takes a few minutes to run (depending on computer).

example_data &lt;- sim_data


# This estimate takes a long time to run...
bart_list &lt;- bart_est(Y = Y,
          treat = T,
          outcome_formula = Y ~ T + B.1 + B.2 + B.3 + B.4 + B.5 + B.6 + B.7 + B.8,
          data = example_data,
          grid_val = seq(8, 16, by = 1))

sample_index &lt;- sample(1:1000, 100)

plot(example_data$T[sample_index],
    example_data$Y[sample_index],
    xlab = "T",
    ylab = "Y",
    main = "bart estimate")

lines(seq(8, 16, by = 1),
      bart_list$param,
      lty = 2,
      lwd = 2,
      col = "blue")

legend('bottomright',
        "bart estimate",
        lty=2,
        lwd = 2,
        col = "blue",
        bty='Y',
        cex=1)


rm(example_data, bart_list, sample_index)
</code></pre>

<hr>
<h2 id='gam_est'>The GAM estimator</h2><span id='topic+gam_est'></span>

<h3>Description</h3>

<p>This estimates the ADRF using a method similar to that described in Hirano and Imbens (2004),
but with spline basis terms in the outcome model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gam_est(Y,
        treat,
        treat_formula,
        data,
        grid_val,
        treat_mod,
        link_function,
        ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gam_est_+3A_y">Y</code></td>
<td>
<p>is the the name of the outcome variable contained in <code>data</code>.</p>
</td></tr>
<tr><td><code id="gam_est_+3A_treat">treat</code></td>
<td>
<p>is the name of the treatment variable contained in
<code>data</code>.</p>
</td></tr>
<tr><td><code id="gam_est_+3A_treat_formula">treat_formula</code></td>
<td>
<p>an object of class &quot;formula&quot; (or one that can be
coerced to that class) that regresses <code>treat</code> on a linear combination
of <code>X</code>: a symbolic description of the model to be fitted.</p>
</td></tr>
<tr><td><code id="gam_est_+3A_data">data</code></td>
<td>
<p>is a dataframe containing <code>Y</code> and <code>treat</code> and
<code>X</code>.</p>
</td></tr>
<tr><td><code id="gam_est_+3A_grid_val">grid_val</code></td>
<td>
<p>contains the treatment values to be evaluated.</p>
</td></tr>
<tr><td><code id="gam_est_+3A_treat_mod">treat_mod</code></td>
<td>
<p>a description of the error distribution to be used in the
model for treatment. Options include: <code>"Normal"</code> for normal model,
<code>"LogNormal"</code> for lognormal model, <code>"Sqrt"</code> for square-root transformation
to a normal treatment, <code>"Poisson"</code> for Poisson model,
<code>"NegBinom"</code> for negative binomial model, <code>"Gamma"</code> for gamma
model.</p>
</td></tr>
<tr><td><code id="gam_est_+3A_link_function">link_function</code></td>
<td>
<p>is either &quot;log&quot;, &quot;inverse&quot;, or &quot;identity&quot; for the
&quot;Gamma&quot; <code>treat_mod</code>.</p>
</td></tr>
<tr><td><code id="gam_est_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to the gam() outcome function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function estimates the ADRF similarly to the method described by
Hirano and Imbens (2004), but with a generalized additive model in the outcome
model.
</p>


<h3>Value</h3>

<p><code>gam_est</code> returns an object of class &quot;causaldrf&quot;,
a list that contains the following components:
</p>
<table>
<tr><td><code>param</code></td>
<td>
<p>parameter estimates for a gam fit.</p>
</td></tr>
<tr><td><code>t_mod</code></td>
<td>
<p>the result of the treatment model fit.</p>
</td></tr>
<tr><td><code>out_mod</code></td>
<td>
<p>the result of the outcome model fit.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>the matched call.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Schafer, J.L., Galagate, D.L. (2015).  Causal inference with a
continuous treatment and outcome: alternative estimators for parametric
dose-response models. <em>Manuscript in preparation</em>.
</p>
<p>Hirano, Keisuke, Imbens, Guido W (2004).  The propensity score with
continuous treatments.  <em>Applied Bayesian modeling and
causal inference from incomplete-data perspectives.</em>
</p>
<p>Flores, Carlos A and Flores-Lagunes, Alfonso and Gonzalez, Arturo and Neumann, Todd C (2012).
Estimating the effects of length of
exposure to instruction in a training program: the case of job corps.
<em>Review of Economics and Statistics</em>. <b>94.1</b>, 153-171
</p>


<h3>See Also</h3>

<p><code><a href="#topic+nw_est">nw_est</a></code>, <code><a href="#topic+iw_est">iw_est</a></code>, <code><a href="#topic+hi_est">hi_est</a></code>, <code><a href="#topic+gam_est">gam_est</a></code>,
<code><a href="#topic+add_spl_est">add_spl_est</a></code>,
<code><a href="#topic+bart_est">bart_est</a></code>, etc. for other estimates.
</p>
<p><code><a href="#topic+t_mod">t_mod</a></code>, <code><a href="#topic+overlap_fun">overlap_fun</a></code> to prepare the <code>data</code>
for use in the different estimates.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Example from Schafer (2015).

example_data &lt;- sim_data

gam_list &lt;- gam_est(Y = Y,
                treat = T,
                treat_formula = T ~ B.1 + B.2 + B.3 + B.4 + B.5 + B.6 + B.7 + B.8,
                data = example_data,
                grid_val = seq(8, 16, by = 1),
                treat_mod = "Normal")

sample_index &lt;- sample(1:1000, 100)

plot(example_data$T[sample_index],
      example_data$Y[sample_index],
      xlab = "T",
      ylab = "Y",
      main = "gam estimate")

lines(seq(8, 16, by = 1),
      gam_list$param,
      lty = 2,
      lwd = 2,
      col = "blue")

legend('bottomright',
        "gam estimate",
        lty=2,
        lwd = 2,
        col = "blue",
        bty='Y',
        cex=1)

rm(example_data, gam_list, sample_index)
</code></pre>

<hr>
<h2 id='get_ci'>This calculates an upper and lower bound from bootstrap matrix</h2><span id='topic+get_ci'></span>

<h3>Description</h3>

<p>This function takes a matrix containing the bootstrapped coefficients
from a parametric ADRF estimator and returns upper and lower 95 percent
confidence lines.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_ci(grid_val,
       coef_mat,
       degree)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_ci_+3A_grid_val">grid_val</code></td>
<td>
<p>is the vector of grid values on <code>treat</code> axis</p>
</td></tr>
<tr><td><code id="get_ci_+3A_coef_mat">coef_mat</code></td>
<td>
<p>contains the bootstrapped parameter estimates.</p>
</td></tr>
<tr><td><code id="get_ci_+3A_degree">degree</code></td>
<td>
<p>is 1 for linear and 2 for quadratic outcome model</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>get_ci</code> returns upper and lower 95 percent confidence lines.
</p>

<hr>
<h2 id='hi_est'>The Hirano and Imbens estimator</h2><span id='topic+hi_est'></span>

<h3>Description</h3>

<p>This function estimates the GPS function and estimates the
ADRF. The GPS score is based on different treatment models.  The treatment is
linearly related to Xs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hi_est(Y,
       treat,
       treat_formula,
       outcome_formula,
       data,
       grid_val,
       treat_mod,
       link_function,
       ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hi_est_+3A_y">Y</code></td>
<td>
<p>is the the name of the outcome variable contained in <code>data</code>.</p>
</td></tr>
<tr><td><code id="hi_est_+3A_treat">treat</code></td>
<td>
<p>is the name of the treatment variable contained in
<code>data</code>.</p>
</td></tr>
<tr><td><code id="hi_est_+3A_treat_formula">treat_formula</code></td>
<td>
<p>an object of class &quot;formula&quot; (or one that can be
coerced to that class) that regresses <code>treat</code> on a linear combination
of <code>X</code>: a symbolic description of the model to be fitted.</p>
</td></tr>
<tr><td><code id="hi_est_+3A_outcome_formula">outcome_formula</code></td>
<td>
<p>is the formula used for fitting the outcome surface.
gps is one of the independent variables to use in the outcome_formula. ie.
</p>
<p><code>Y ~ treat+ I(treat^2) + gps + I(gps^2) + treat * gps</code>
</p>
<p>or a variation
of this.  Use <code>gps</code> as the name of the variable representing the gps
in <code>outcome_formula</code>.</p>
</td></tr>
<tr><td><code id="hi_est_+3A_data">data</code></td>
<td>
<p>is a dataframe containing <code>Y</code>, <code>treat</code>, and
<code>X</code>.</p>
</td></tr>
<tr><td><code id="hi_est_+3A_grid_val">grid_val</code></td>
<td>
<p>contains the treatment values to be evaluated.</p>
</td></tr>
<tr><td><code id="hi_est_+3A_treat_mod">treat_mod</code></td>
<td>
<p>a description of the error distribution to be used in the
model for treatment. Options include: <code>"Normal"</code> for normal model,
<code>"LogNormal"</code> for lognormal model, <code>"Sqrt"</code> for square-root transformation
to a normal treatment, <code>"Poisson"</code> for Poisson model,
<code>"NegBinom"</code> for negative binomial model, <code>"Gamma"</code> for gamma
model, <code>"Binomial"</code> for binomial model.</p>
</td></tr>
<tr><td><code id="hi_est_+3A_link_function">link_function</code></td>
<td>
<p>For <code>treat_mod = "Gamma"</code> (fitted using glm) alternatives are &quot;log&quot; or &quot;inverse&quot;.
For <code>treat_mod = "Binomial"</code> (fitted using glm) alternatives are &quot;logit&quot;, &quot;probit&quot;, &quot;cauchit&quot;, &quot;log&quot; and &quot;cloglog&quot;.</p>
</td></tr>
<tr><td><code id="hi_est_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to the outcome lm() function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Hirano (2004) (HI) introduced this imputation-type method that
includes a GPS component.  The idea is to fit a parametric observable
(outcome) model, which includes the estimated GPS as a covariate, to impute
missing potential outcomes.
</p>
<p>The method requires several steps.  First, a model is used to relate
treatment to the recorded covariates.  For example,
<code class="reqn">T_i|\textbf{X}_i \sim \mathcal{N}(\textbf{X}_i^T \boldsymbol{\beta}, \sigma^2)</code>
and then estimate the <code class="reqn">\boldsymbol{\beta}</code> parameters.
Next, the GPS for each unit is estimated
</p>
<p style="text-align: center;"><code class="reqn">
\hat{R}_i(t) = \frac{1}{\sqrt{2 \pi \hat{\sigma}^2}  } e^{-\frac{(t - \textbf{X}_i^T \boldsymbol{\hat{\beta}})^2}{2 \hat{\sigma}^2}}
</code>
</p>

<p>These GPS estimates are used in the outcome or observable model.
The outcome is modeled as a function of <code class="reqn">T_i</code> and <code class="reqn">\hat{R}_i</code>
parametrically.  For example,
</p>
<p style="text-align: center;"><code class="reqn">
E[Y_i | T_i, R_i] = \alpha_0 + \alpha_1 T_i + \alpha_2 T_i^2 + \alpha_3 \hat{R}_i + \alpha_4 \hat{R}_i^2 + \alpha_5 \hat{R}_i\cdot T_i
</code>
</p>

<p>After collecting the estimated parameters in the outcome and treatment
models, plug-in the treatment values into the model to estimate the
missing potential outcomes of each individual at that treatment level.
For example, if we plug in <code class="reqn">T_i = t</code> into the estimated models, then
each unit will have a potential outcome estimated at treatment level
<code class="reqn">T_i= t</code>.
</p>
<p style="text-align: center;"><code class="reqn">
\hat{Y}_i(t) = \hat{\alpha}_0 + \hat{\alpha}_1 t + \hat{\alpha}_2 t^2 + \hat{\alpha}_3 \hat{R}_i(t) + \hat{\alpha}_4 \hat{R}_i^2(t) + \hat{\alpha}_5 \hat{R}_i(t) \cdot t
</code>
</p>

<p>The next step is to aggregate these estimated potential outcomes
to get an average treatment effect at dose level <code class="reqn">T_i = t</code>.
The mean outcome at dose-level <code class="reqn">T_i = t</code> is given by:
</p>
<p style="text-align: center;"><code class="reqn">
\hat{\mu}(t) = \frac{1}{N}\sum_i^N \hat{\alpha}_0 + \hat{\alpha}_1 t + \hat{\alpha}_2 t^2 + \hat{\alpha}_3 \hat{R}_i(t) + \hat{\alpha}_4 \hat{R^2}_i(t) + \hat{\alpha}_5 \hat{R}_i(t) \cdot t
</code>
</p>

<p>Different treatment levels are plugged into the previous equation
to estimate the missing potential outcomes.  If many <code class="reqn">t</code> values
are evaluated, then it is possible to trace out an ADRF.
</p>


<h3>Value</h3>

<p><code>hi_est</code> returns an object of class &quot;causaldrf&quot;,
a list that contains the following components:
</p>
<table>
<tr><td><code>param</code></td>
<td>
<p>parameter estimates for a hi fit.</p>
</td></tr>
<tr><td><code>t_mod</code></td>
<td>
<p>the result of the treatment model fit.</p>
</td></tr>
<tr><td><code>out_mod</code></td>
<td>
<p>the result of the outcome model fit.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>the matched call.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Schafer, J.L., Galagate, D.L. (2015).  Causal inference with a
continuous treatment and outcome: alternative estimators for parametric
dose-response models. <em>Manuscript in preparation</em>.
</p>
<p>Hirano, Keisuke, Imbens, Guido W (2004).  The propensity score with
continuous treatments.  <em>Applied Bayesian modeling and
causal inference from incomplete-data perspectives.</em>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+nw_est">nw_est</a></code>, <code><a href="#topic+iw_est">iw_est</a></code>, <code><a href="#topic+hi_est">hi_est</a></code>, <code><a href="#topic+gam_est">gam_est</a></code>,
<code><a href="#topic+add_spl_est">add_spl_est</a></code>,
<code><a href="#topic+bart_est">bart_est</a></code>, etc. for other estimates.
</p>
<p><code><a href="#topic+t_mod">t_mod</a></code>, <code><a href="#topic+overlap_fun">overlap_fun</a></code> to prepare the <code>data</code>
for use in the different estimates.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Example from Schafer (2015).

example_data &lt;- sim_data

hi_list &lt;- hi_est(Y = Y,
              treat = T,
              treat_formula = T ~ B.1 + B.2 + B.3 + B.4 + B.5 + B.6 + B.7 + B.8,
              outcome_formula = Y ~ T + I(T^2) + gps + I(gps^2) + T * gps,
              data = example_data,
              grid_val = seq(8, 16, by = 1),
              treat_mod = "Normal")

sample_index &lt;- sample(1:1000, 100)

plot(example_data$T[sample_index],
      example_data$Y[sample_index],
      xlab = "T",
      ylab = "Y",
      main = "hi estimate")

lines(seq(8, 16, by = 1),
      hi_list$param,
      lty = 2,
      lwd = 2,
      col = "blue")

legend('bottomright',
        "hi estimate",
        lty=2,
        lwd = 2,
        col = "blue",
        bty='Y',
        cex=1)

rm(example_data, hi_list, sample_index)


## Example from van der Wal, Willem M., and Ronald B. Geskus. (2011)
#Simulate data with continuous confounder and outcome, binomial exposure.
#Marginal causal effect of exposure on outcome: 10.
n &lt;- 1000
simdat &lt;- data.frame(l = rnorm(n, 10, 5))
a.lin &lt;- simdat$l - 10
pa &lt;- exp(a.lin)/(1 + exp(a.lin))
simdat$a &lt;- rbinom(n, 1, prob = pa)
simdat$y &lt;- 10*simdat$a + 0.5*simdat$l + rnorm(n, -10, 5)
simdat[1:5,]
temp_hi &lt;- hi_est(Y = y,
                 treat = a,
                 treat_formula = a ~ l,
                 outcome_formula = y ~ gps,
                 data = simdat,
                 grid_val = c(0, 1),
                 treat_mod = "Binomial",
                 link_function = "logit")

temp_hi[[1]]  # estimated coefficients
</code></pre>

<hr>
<h2 id='hi_sim_data'>Simulated data from Hirano and Imbens (2004)</h2><span id='topic+hi_sim_data'></span>

<h3>Description</h3>

<p>Simulated data used in the paper &quot;The propensity score with continuous
treatments.&quot;
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(hi_sim_data)
</code></pre>


<h3>Format</h3>

<p>A data frame with 1000 rows and 6 variables:</p>


<h3>Details</h3>

<p>A dataset containing hi_sim_data.
</p>


<h3>Source</h3>

<p>use the <code>hi_sample</code> function
</p>


<h3>References</h3>

<p>Hirano, Keisuke, and Guido W. Imbens.
&quot;The propensity score with continuous treatments.&quot;
<em>Applied Bayesian modeling and causal inference from
incomplete-data perspectives</em> (2004): 73-84.
</p>
<p>Moodie, Erica EM, and David A. Stephens.
&quot;Estimation of dose-response functions for longitudinal data
using the generalised propensity score.&quot;
<em>Statistical methods in medical research</em> <b>21.2</b> (2012): 149-166.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Example from Hirano and Imbens (2004).
data(hi_sim_data)
head(hi_sim_data)
</code></pre>

<hr>
<h2 id='iptw_est'>The inverse probability of treatment weighting (iptw) estimator</h2><span id='topic+iptw_est'></span>

<h3>Description</h3>

<p>The iptw method or importance weighting method estimates the ADRF by
weighting the data with stabilized or non-stabilized weights.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>iptw_est(Y,
         treat,
         treat_formula,
         numerator_formula,
         data,
         degree,
         treat_mod,
         link_function,
         ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="iptw_est_+3A_y">Y</code></td>
<td>
<p>is the the name of the outcome variable contained in <code>data</code>.</p>
</td></tr>
<tr><td><code id="iptw_est_+3A_treat">treat</code></td>
<td>
<p>is the name of the treatment variable contained in
<code>data</code>.</p>
</td></tr>
<tr><td><code id="iptw_est_+3A_treat_formula">treat_formula</code></td>
<td>
<p>an object of class &quot;formula&quot; (or one that can be
coerced to that class) that regresses <code>treat</code> on a linear combination
of <code>X</code>: a symbolic description of the model to be fitted.</p>
</td></tr>
<tr><td><code id="iptw_est_+3A_numerator_formula">numerator_formula</code></td>
<td>
<p>an object of class &quot;formula&quot; (or one that can be
coerced to that class) that regresses <code>treat</code> on a linear combination
of <code>X</code>: a symbolic description of the model to be fitted.  i.e.
<code>treat ~ 1</code>.</p>
</td></tr>
<tr><td><code id="iptw_est_+3A_data">data</code></td>
<td>
<p>is a dataframe containing <code>Y</code>, <code>treat</code>, and
<code>X</code>.</p>
</td></tr>
<tr><td><code id="iptw_est_+3A_degree">degree</code></td>
<td>
<p>is 1 for linear and 2 for quadratic outcome model.</p>
</td></tr>
<tr><td><code id="iptw_est_+3A_treat_mod">treat_mod</code></td>
<td>
<p>a description of the error distribution to be used in the
model for treatment. Options include: <code>"Normal"</code> for normal model,
<code>"LogNormal"</code> for lognormal model, <code>"Sqrt"</code> for square-root transformation
to a normal treatment, <code>"Poisson"</code> for Poisson model,
<code>"NegBinom"</code> for negative binomial model, <code>"Gamma"</code> for gamma
model, <code>"Binomial"</code> for binomial model, <code>"Ordinal"</code> for ordinal model,
<code>"Multinomial"</code> for multinomial model.</p>
</td></tr>
<tr><td><code id="iptw_est_+3A_link_function">link_function</code></td>
<td>
<p>specifies the link function between the variables in
numerator or denominator and exposure, respectively.
For <code>treat_mod = "Gamma"</code> (fitted using glm) alternatives are &quot;log&quot; or &quot;inverse&quot;.
For <code>treat_mod = "Binomial"</code> (fitted using glm) alternatives are &quot;logit&quot;, &quot;probit&quot;, &quot;cauchit&quot;, &quot;log&quot; and &quot;cloglog&quot;.
For <code>treat_mod = "Multinomial"</code> this argument is ignored, and
multinomial logistic regression models are always used (fitted using multinom).
For <code>treat_mod = "Ordinal"</code> (fitted using polr) alternatives are &quot;logit&quot;, &quot;probit&quot;, &quot;cauchit&quot;, and &quot;cloglog&quot;.</p>
</td></tr>
<tr><td><code id="iptw_est_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to the low level treatment regression fitting functions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This method uses inverse probability of treatment weighting to adjust
for possible biases.  For more details see Schafer and Galagate (2015) and
Robins, Hernan, and Brumback (2000).
</p>


<h3>Value</h3>

<p><code>iptw_est</code> returns an object of class &quot;causaldrf&quot;,
a list that contains the following components:
</p>
<table>
<tr><td><code>param</code></td>
<td>
<p>parameter estimates for a iptw fit.</p>
</td></tr>
<tr><td><code>t_mod</code></td>
<td>
<p>the result of the treatment model fit.</p>
</td></tr>
<tr><td><code>num_mod</code></td>
<td>
<p>the result of the numerator model fit.</p>
</td></tr>
<tr><td><code>weights</code></td>
<td>
<p>the estimated weights.</p>
</td></tr>
<tr><td><code>weight_data</code></td>
<td>
<p>the weights.</p>
</td></tr>
<tr><td><code>out_mod</code></td>
<td>
<p>the outcome model.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>the matched call.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Schafer, J.L., Galagate, D.L. (2015).  Causal inference with a
continuous treatment and outcome: alternative estimators for parametric
dose-response models. <em>Manuscript in preparation</em>.
</p>
<p>van der Wal, Willem M., and Ronald B. Geskus.
&quot;IPW: an R package for inverse probability weighting.&quot;
<em>Journal of Statistical Software</em> <b>43.13</b> (2011): 1-23.
</p>
<p>Robins, James M and Hernan, Miguel Angel and Brumback, Babette.
Marginal structural models and causal inference in epidemiology.
<em>Epidemiology</em> <b>11.5</b> (2000): 550&ndash;560.
</p>
<p>Zhu, Yeying and Coffman, Donna L and Ghosh, Debashis.
A Boosting Algorithm for Estimating Generalized Propensity Scores
with Continuous Treatments.
<em>Journal of Causal Inference</em> <b>3.1</b> (2015): 25&ndash;40.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+iptw_est">iptw_est</a></code>, <code><a href="#topic+ismw_est">ismw_est</a></code>,
<code><a href="#topic+reg_est">reg_est</a></code>, <code><a href="#topic+aipwee_est">aipwee_est</a></code>, <code><a href="#topic+wtrg_est">wtrg_est</a></code>,
etc. for other estimates.
</p>
<p><code><a href="#topic+t_mod">t_mod</a></code>, <code><a href="#topic+overlap_fun">overlap_fun</a></code> to prepare the <code>data</code>
for use in the different estimates.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Example from Schafer (2015).

example_data &lt;- sim_data

iptw_list &lt;- iptw_est(Y = Y,
              treat = T,
              treat_formula = T ~ B.1 + B.2 + B.3 + B.4 + B.5 + B.6 + B.7 + B.8,
              numerator_formula = T ~ 1,
              data = example_data,
              degree = 1,
              treat_mod = "Normal")

sample_index &lt;- sample(1:1000, 100)

plot(example_data$T[sample_index],
      example_data$Y[sample_index],
      xlab = "T",
      ylab = "Y",
      main = "iptw estimate")

abline(iptw_list$param[1],
        iptw_list$param[2],
        lty=2,
        lwd = 2,
        col = "blue")

legend('bottomright',
        "iptw estimate",
        lty=2,
        lwd = 2,
        col = "blue",
        bty='Y',
        cex=1)

rm(example_data, iptw_list, sample_index)


## Example from van der Wal, Willem M., and Ronald B. Geskus. (2011)
#Simulate data with continuous confounder and outcome, binomial exposure.
#Marginal causal effect of exposure on outcome: 10.
n &lt;- 1000
simdat &lt;- data.frame(l = rnorm(n, 10, 5))
a.lin &lt;- simdat$l - 10
pa &lt;- exp(a.lin)/(1 + exp(a.lin))
simdat$a &lt;- rbinom(n, 1, prob = pa)
simdat$y &lt;- 10*simdat$a + 0.5*simdat$l + rnorm(n, -10, 5)
simdat[1:5,]
temp_iptw &lt;- iptw_est(Y = y,
                      treat = a,
                      treat_formula = a ~ l,
                      numerator_formula = a ~ 1,
                      data = simdat,
                      degree = 1,
                      treat_mod = "Binomial",
                      link_function = "logit")


temp_iptw[[1]]  # estimated coefficients
</code></pre>

<hr>
<h2 id='ismw_est'>The inverse second moment weighting (ismw) estimator</h2><span id='topic+ismw_est'></span>

<h3>Description</h3>

<p>This method estimates the ADRF by using weighting matrices instead of
scalars.  The weight matrices require conditional expectations of the
treatment and higher order conditional expectations. It uses outputs from
the <code>t_mod</code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ismw_est(Y,
         treat,
         data,
         e_treat_1,
         e_treat_2,
         e_treat_3,
         e_treat_4,
         degree )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ismw_est_+3A_y">Y</code></td>
<td>
<p>is the the name of the outcome variable contained in <code>data</code>.</p>
</td></tr>
<tr><td><code id="ismw_est_+3A_treat">treat</code></td>
<td>
<p>is the name of the treatment variable contained in
<code>data</code>.</p>
</td></tr>
<tr><td><code id="ismw_est_+3A_data">data</code></td>
<td>
<p>is a dataframe containing <code>Y</code>, <code>treat</code>, and
<code>X</code>.</p>
</td></tr>
<tr><td><code id="ismw_est_+3A_e_treat_1">e_treat_1</code></td>
<td>
<p>a vector, representing the conditional expectation of
<code>treat</code> from <code>t_mod</code>.</p>
</td></tr>
<tr><td><code id="ismw_est_+3A_e_treat_2">e_treat_2</code></td>
<td>
<p>a vector, representing the conditional expectation of
<code>treat^2</code> from <code>t_mod</code>.</p>
</td></tr>
<tr><td><code id="ismw_est_+3A_e_treat_3">e_treat_3</code></td>
<td>
<p>a vector, representing the conditional expectation of
<code>treat^3</code> from <code>t_mod</code>.</p>
</td></tr>
<tr><td><code id="ismw_est_+3A_e_treat_4">e_treat_4</code></td>
<td>
<p>a vector, representing the conditional expectation of
<code>treat^4</code> from <code>t_mod</code>.</p>
</td></tr>
<tr><td><code id="ismw_est_+3A_degree">degree</code></td>
<td>
<p>is 1 for linear and 2 for quadratic outcome model.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function estimates the ADRF requires estimated moments and
uses the outputs of the t_mod function as inputs.  For more details,
see Schafer and Galagate (2015).
</p>


<h3>Value</h3>

<p><code>ismw_est</code> returns an object of class &quot;causaldrf_simple&quot;,
a list that contains the following components:
</p>
<table>
<tr><td><code>param</code></td>
<td>
<p>the estimated parameters.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>the matched call.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Schafer, J.L., Galagate, D.L. (2015).  Causal inference with a
continuous treatment and outcome: alternative estimators for parametric
dose-response models. <em>Manuscript in preparation</em>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+iptw_est">iptw_est</a></code>, <code><a href="#topic+ismw_est">ismw_est</a></code>,
<code><a href="#topic+reg_est">reg_est</a></code>, <code><a href="#topic+aipwee_est">aipwee_est</a></code>, <code><a href="#topic+wtrg_est">wtrg_est</a></code>,
etc. for other estimates.
</p>
<p><code><a href="#topic+t_mod">t_mod</a></code>, <code><a href="#topic+overlap_fun">overlap_fun</a></code> to prepare the <code>data</code>
for use in the different estimates.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Example from Schafer (2015).

example_data &lt;- sim_data

t_mod_list &lt;- t_mod(treat = T,
                treat_formula = T ~ B.1 + B.2 + B.3 + B.4 + B.5 + B.6 + B.7 + B.8,
                data = example_data,
                treat_mod = "Normal")

cond_exp_data &lt;- t_mod_list$T_data

full_data &lt;- cbind(example_data, cond_exp_data)

ismw_list &lt;- ismw_est(Y = Y,
                      treat = T,
                      data = full_data,
                      e_treat_1 = full_data$est_treat,
                      e_treat_2 = full_data$est_treat_sq,
                      e_treat_3 = full_data$est_treat_cube,
                      e_treat_4 = full_data$est_treat_quartic,
                      degree = 1)

sample_index &lt;- sample(1:1000, 100)

plot(example_data$T[sample_index],
      example_data$Y[sample_index],
      xlab = "T",
      ylab = "Y",
      main = "ismw estimate")

abline(ismw_list$param[1],
ismw_list$param[2],
        lty=2,
        lwd = 2,
        col = "blue")

legend('bottomright',
        "ismw estimate",
        lty=2,
        lwd = 2,
        col = "blue",
        bty='Y',
        cex=1)

rm(example_data, t_mod_list, cond_exp_data, full_data, ismw_list, sample_index)
</code></pre>

<hr>
<h2 id='iw_est'>The inverse weighting estimator (nonparametric method)</h2><span id='topic+iw_est'></span>

<h3>Description</h3>

<p>This is a nonparametric method that estimates the ADRF by using a local linear
regression of <code>Y</code> on <code>treat</code> with weighted kernel function.  For
details, see Flores et. al. (2012).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>iw_est(Y,
       treat,
       treat_formula,
       data,
       grid_val,
       bandw,
       treat_mod,
       link_function,
       ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="iw_est_+3A_y">Y</code></td>
<td>
<p>is the the name of the outcome variable contained in <code>data</code>.</p>
</td></tr>
<tr><td><code id="iw_est_+3A_treat">treat</code></td>
<td>
<p>is the name of the treatment variable contained in
<code>data</code>.</p>
</td></tr>
<tr><td><code id="iw_est_+3A_treat_formula">treat_formula</code></td>
<td>
<p>an object of class &quot;formula&quot; (or one that can be
coerced to that class) that regresses <code>treat</code> on a linear combination
of <code>X</code>: a symbolic description of the model to be fitted.</p>
</td></tr>
<tr><td><code id="iw_est_+3A_data">data</code></td>
<td>
<p>is a dataframe containing <code>Y</code>, <code>treat</code>, and
<code>X</code>.</p>
</td></tr>
<tr><td><code id="iw_est_+3A_grid_val">grid_val</code></td>
<td>
<p>contains the treatment values to be evaluated.</p>
</td></tr>
<tr><td><code id="iw_est_+3A_bandw">bandw</code></td>
<td>
<p>is the bandwidth.  Default is 1.</p>
</td></tr>
<tr><td><code id="iw_est_+3A_treat_mod">treat_mod</code></td>
<td>
<p>a description of the error distribution to be used in the
model for treatment. Options include: <code>"Normal"</code> for normal model,
<code>"LogNormal"</code> for lognormal model, <code>"Sqrt"</code> for square-root transformation
to a normal treatment, <code>"Poisson"</code> for Poisson model,
<code>"NegBinom"</code> for negative binomial model, <code>"Gamma"</code> for gamma
model.</p>
</td></tr>
<tr><td><code id="iw_est_+3A_link_function">link_function</code></td>
<td>
<p>is either &quot;log&quot;, &quot;inverse&quot;, or &quot;identity&quot; for the
&quot;Gamma&quot; <code>treat_mod</code>.</p>
</td></tr>
<tr><td><code id="iw_est_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to the treatment regression function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The ADRF is estimated by
</p>
<p style="text-align: center;"><code class="reqn">(D_{0}(t) S_{2}(t) - D_{1}(t) S_{1}(t)) / (S_{0}(t) S_{2}(t) - S_{1}^{2}(t)) </code>
</p>

<p>where </p>
<p style="text-align: center;"><code class="reqn">D_{j}(t) = \sum_{i = 1}^{N} \tilde{K}_{h, X} (T_i - t)  (T_i - t)^j Y_i</code>
</p>
<p> and
<code class="reqn">S_{j}(t) = \sum_{i = 1}^{N} \tilde{K}_{h, X} (T_i - t)  (T_i - t)^j</code>
<code class="reqn">\tilde{K}_{h, X}(t) = K_{h}(t) / \hat{R}_i(t)</code>
which is a local linear regression.
More details are given in Flores (2012).
</p>


<h3>Value</h3>

<p><code>iw_est</code> returns an object of class &quot;causaldrf&quot;,
a list that contains the following components:
</p>
<table>
<tr><td><code>param</code></td>
<td>
<p>parameter estimates for a iw fit.</p>
</td></tr>
<tr><td><code>t_mod</code></td>
<td>
<p>the result of the treatment model fit.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>the matched call.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Schafer, J.L., Galagate, D.L. (2015).  Causal inference with a
continuous treatment and outcome: alternative estimators for parametric
dose-response models. <em>Manuscript in preparation</em>.
</p>
<p>Flores, Carlos A., et al. &quot;Estimating the effects of length of exposure to
instruction in a training program: the case of job corps.&quot;
<em>Review of Economics and Statistics</em> <b>94.1</b> (2012): 153-171.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+nw_est">nw_est</a></code>, <code><a href="#topic+iw_est">iw_est</a></code>, <code><a href="#topic+hi_est">hi_est</a></code>, <code><a href="#topic+gam_est">gam_est</a></code>,
<code><a href="#topic+add_spl_est">add_spl_est</a></code>,
<code><a href="#topic+bart_est">bart_est</a></code>, etc. for other estimates.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Example from Schafer (2015).

example_data &lt;- sim_data

iw_list &lt;- iw_est(Y = Y,
                treat = T,
                treat_formula = T ~ B.1 + B.2 + B.3 + B.4 + B.5 + B.6 + B.7 + B.8,
                data = example_data,
                grid_val = seq(8, 16, by = 1),
                bandw = bw.SJ(example_data$T),
                treat_mod = "Normal")

sample_index &lt;- sample(1:1000, 100)

plot(example_data$T[sample_index],
      example_data$Y[sample_index],
      xlab = "T",
      ylab = "Y",
      main = "iw estimate")

lines(seq(8, 16, by = 1),
        iw_list$param,
        lty = 2,
        lwd = 2,
        col = "blue")

legend('bottomright',
        "iw estimate",
        lty=2,
        lwd = 2,
        col = "blue",
        bty='Y',
        cex=1)

rm(example_data, iw_list, sample_index)

## Example from Imai &amp; van Dyk (2004).

data("nmes_data")
head(nmes_data)
# look at only people with medical expenditures greater than 0
nmes_nonzero &lt;- nmes_data[which(nmes_data$TOTALEXP &gt; 0), ]


iw_list &lt;- iw_est(Y = TOTALEXP,
                  treat = packyears,
                  treat_formula = packyears ~ LASTAGE + I(LASTAGE^2) +
                    AGESMOKE + I(AGESMOKE^2) + MALE + RACE3 + beltuse +
                    educate + marital + SREGION + POVSTALB,
                  data = nmes_nonzero,
                  grid_val = seq(5, 100, by = 5),
                  bandw = bw.SJ(nmes_nonzero$packyears),
                  treat_mod = "LogNormal")

set.seed(307)
sample_index &lt;- sample(1:nrow(nmes_nonzero), 1000)

plot(nmes_nonzero$packyears[sample_index],
     nmes_nonzero$TOTALEXP[sample_index],
     xlab = "packyears",
     ylab = "TOTALEXP",
     main = "iw estimate",
     ylim = c(0, 10000),
     xlim = c(0, 100))

lines(seq(5, 100, by = 5),
      iw_list$param,
      lty = 2,
      lwd = 2,
      col = "blue")

legend('topright',
       "iw estimate",
       lty=2,
       lwd = 2,
       col = "blue",
       bty='Y',
       cex = 1)
abline(0, 0)
</code></pre>

<hr>
<h2 id='nmes_data'>Data set containing data from the National Medical Expenditure Survey (NMES)</h2><span id='topic+nmes_data'></span>

<h3>Description</h3>

<p>Data set from the NMES.
with 9708 observations and 12 variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(nmes_data)
</code></pre>


<h3>Format</h3>

<p>A dataset containing 9708 observations and 12 variables.</p>


<h3>References</h3>

<p>Imai, K., &amp; van Dyk, D.A. (2004).
Causal Inference With General Treatment Regimes: Generalizing the Propensity Score.
<em>Journal of the American Statistical Association</em>, <b>99(467)</b>.
</p>
<p>National Center for Health Services Research and Health Care Technology Assessment.
NATIONAL MEDICAL EXPENDITURE SURVEY, 1987:
INSTITUTIONAL POPULATION COMPONENT. Rockville, MD: Westat, Inc. [producer], 1987.
Ann Arbor, MI: Inter-university Consortium for Political and
Social Research [distributor], 1990. doi:10.3886/ICPSR09280.v1
</p>
<p>Bryer, Jason M.
&quot;TriMatch: An R Package for Propensity Score Matching of Non-binary Treatments.&quot;
The R User Conference, useR! 2013 July 10-12 2013
University of Castilla-La Mancha, Albacete, Spain. Vol. 10. No. 30. 2013.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(nmes_data)
head(nmes_data)
</code></pre>

<hr>
<h2 id='nw_est'>The Nadaraya-Watson modified estimator</h2><span id='topic+nw_est'></span>

<h3>Description</h3>

<p>This is a kernel based regression method that uses a kernel as a weighting
function to estimate the ADRF. The normal kernel is weighted by the inverse of the estimated
GPS.  See Flores et al. (2012) for more details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nw_est(Y,
       treat,
       treat_formula,
       data,
       grid_val,
       bandw,
       treat_mod,
       link_function,
       ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nw_est_+3A_y">Y</code></td>
<td>
<p>is the the name of the outcome variable contained in <code>data</code>.</p>
</td></tr>
<tr><td><code id="nw_est_+3A_treat">treat</code></td>
<td>
<p>is the name of the treatment variable contained in
<code>data</code>.</p>
</td></tr>
<tr><td><code id="nw_est_+3A_treat_formula">treat_formula</code></td>
<td>
<p>an object of class &quot;formula&quot; (or one that can be
coerced to that class) that regresses <code>treat</code> on a linear combination
of <code>X</code>: a symbolic description of the model to be fitted.</p>
</td></tr>
<tr><td><code id="nw_est_+3A_data">data</code></td>
<td>
<p>is a dataframe containing <code>Y</code> and <code>treat</code> and
<code>X</code>.</p>
</td></tr>
<tr><td><code id="nw_est_+3A_grid_val">grid_val</code></td>
<td>
<p>contains the treatment values to be evaluated.</p>
</td></tr>
<tr><td><code id="nw_est_+3A_bandw">bandw</code></td>
<td>
<p>is the bandwidth.  Default is 1.</p>
</td></tr>
<tr><td><code id="nw_est_+3A_treat_mod">treat_mod</code></td>
<td>
<p>a description of the error distribution to be used in the
model for treatment. Options include: <code>"Normal"</code> for normal model,
<code>"LogNormal"</code> for lognormal model, <code>"Sqrt"</code> for square-root transformation
to a normal treatment, <code>"Poisson"</code> for Poisson model,
<code>"NegBinom"</code> for negative binomial model, <code>"Gamma"</code> for gamma
model.</p>
</td></tr>
<tr><td><code id="nw_est_+3A_link_function">link_function</code></td>
<td>
<p>is either &quot;log&quot;, &quot;inverse&quot;, or &quot;identity&quot; for the
&quot;Gamma&quot; <code>treat_mod</code>.</p>
</td></tr>
<tr><td><code id="nw_est_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to the treatment regression function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This method is a version of the Nadarya-Watson estimator
Nadaraya (1964) which is a local constant regression but
weighted by the inverse of the estimated GPS.
</p>


<h3>Value</h3>

<p><code>nw_est</code> returns an object of class &quot;causaldrf&quot;,
a list that contains the following components:
</p>
<table>
<tr><td><code>param</code></td>
<td>
<p>parameter estimates for a nw fit.</p>
</td></tr>
<tr><td><code>t_mod</code></td>
<td>
<p>the result of the treatment model fit.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>the matched call.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Schafer, J.L., Galagate, D.L. (2015).  Causal inference with a
continuous treatment and outcome: alternative estimators for parametric
dose-response models. <em>Manuscript in preparation</em>.
</p>
<p>Flores, Carlos A., et al. &quot;Estimating the effects of length of exposure to
instruction in a training program: the case of job corps.&quot;
<em>Review of Economics and Statistics</em> <b>94.1</b> (2012): 153-171.
</p>
<p>Nadaraya, Elizbar A. &quot;On estimating regression.&quot;
<em>Theory of Probability and Its Applications</em> <b>9.1</b> (1964): 141&ndash;142.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+nw_est">nw_est</a></code>, <code><a href="#topic+iw_est">iw_est</a></code>, <code><a href="#topic+hi_est">hi_est</a></code>, <code><a href="#topic+gam_est">gam_est</a></code>,
<code><a href="#topic+add_spl_est">add_spl_est</a></code>,
<code><a href="#topic+bart_est">bart_est</a></code>, etc. for other estimates.
</p>
<p><code><a href="#topic+t_mod">t_mod</a></code>, <code><a href="#topic+overlap_fun">overlap_fun</a></code> to prepare the <code>data</code>
for use in the different estimates.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Example from Schafer (2015).

example_data &lt;- sim_data

nw_list &lt;- nw_est(Y = Y,
                treat = T,
                treat_formula = T ~ B.1 + B.2 + B.3 + B.4 + B.5 + B.6 + B.7 + B.8,
                data = example_data,
                grid_val = seq(8, 16, by = 1),
                bandw = bw.SJ(example_data$T),
                treat_mod = "Normal")

sample_index &lt;- sample(1:1000, 100)

plot(example_data$T[sample_index],
      example_data$Y[sample_index],
      xlab = "T",
      ylab = "Y",
      main = "nw estimate")

lines(seq(8, 16, by = 1),
      nw_list$param,
      lty = 2,
      lwd = 2,
      col = "blue")

legend('bottomright',
        "nw estimate",
        lty=2,
        lwd = 2,
        col = "blue",
        bty='Y',
        cex=1)

rm(example_data, nw_list, sample_index)
</code></pre>

<hr>
<h2 id='overlap_fun'>This function creates an overlapping dataset</h2><span id='topic+overlap_fun'></span>

<h3>Description</h3>

<p>This function ensures that the units overlap according to the estimated gps
values. The overlapping dataset depends on the number of classes
<code>n_class</code> to subclassify on.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>overlap_fun(Y,
            treat,
            treat_formula,
            data_set,
            n_class,
            treat_mod,
            link_function,
            ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="overlap_fun_+3A_y">Y</code></td>
<td>
<p>is the the name of the outcome variable contained in <code>data</code>.</p>
</td></tr>
<tr><td><code id="overlap_fun_+3A_treat">treat</code></td>
<td>
<p>is the name of the treatment variable contained in
<code>data</code>.</p>
</td></tr>
<tr><td><code id="overlap_fun_+3A_treat_formula">treat_formula</code></td>
<td>
<p>an object of class &quot;formula&quot; (or one that can be
coerced to that class) that regresses <code>treat</code> on a linear combination
of <code>X</code>: a symbolic description of the model to be fitted.</p>
</td></tr>
<tr><td><code id="overlap_fun_+3A_data_set">data_set</code></td>
<td>
<p>is a dataframe containing <code>Y</code>, <code>treat</code>, and
<code>X</code>.</p>
</td></tr>
<tr><td><code id="overlap_fun_+3A_n_class">n_class</code></td>
<td>
<p>is the number of classes to split <code>gps</code> into.</p>
</td></tr>
<tr><td><code id="overlap_fun_+3A_treat_mod">treat_mod</code></td>
<td>
<p>a description of the error distribution to be used in the
model for treatment. Options include: <code>"Normal"</code> for normal model,
<code>"LogNormal"</code> for lognormal model,  <code>"Sqrt"</code> for square-root transformation
to a normal treatment, <code>"Poisson"</code> for Poisson model,
<code>"NegBinom"</code> for negative binomial model, <code>"Gamma"</code> for gamma
model.</p>
</td></tr>
<tr><td><code id="overlap_fun_+3A_link_function">link_function</code></td>
<td>
<p>is either &quot;log&quot;, &quot;inverse&quot;, or &quot;identity&quot; for the
&quot;Gamma&quot; <code>treat_mod</code>.</p>
</td></tr>
<tr><td><code id="overlap_fun_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to the treatment regression function</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>overlap_fun</code> returns a list containing the following
elements: </p>
<table>
<tr><td><code>overlap_dataset</code></td>
<td>
<p>dataframe containing overlapping data.</p>
</td></tr>
<tr><td><code>median_vec</code></td>
<td>
<p>a vector containing median values.</p>
</td></tr>
<tr><td><code>overlap_treat_result</code></td>
<td>
<p>the resulting treatment fit.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Schafer, J.L., Galagate, D.L. (2015).  Causal inference with a
continuous treatment and outcome: alternative estimators for parametric
dose-response models. <em>Manuscript in preparation</em>.
</p>
<p>Bia, Michela, et al.
&quot;A Stata package for the application of semiparametric estimators of dose response functions.&quot;
<em>Stata Journal</em> <b>14.3</b> (2014): 580-604.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+iptw_est">iptw_est</a></code>, <code><a href="#topic+ismw_est">ismw_est</a></code>,
<code><a href="#topic+reg_est">reg_est</a></code>, <code><a href="#topic+aipwee_est">aipwee_est</a></code>, <code><a href="#topic+wtrg_est">wtrg_est</a></code>,
etc. for other estimates.
</p>
<p><code><a href="#topic+t_mod">t_mod</a></code>, <code><a href="#topic+overlap_fun">overlap_fun</a></code> to prepare the <code>data</code>
for use in the different estimates.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Example from Schafer (2015).

example_data &lt;- sim_data

overlap_list &lt;- overlap_fun(Y = Y,
                  treat = T,
                  treat_formula = T ~ B.1 + B.2 + B.3 + B.4 + B.5 + B.6 + B.7 + B.8,
                  data_set = example_data,
                  n_class = 3,
                  treat_mod = "Normal")

overlapped_data &lt;- overlap_list$overlap_dataset
summary(overlapped_data)

rm(example_data, overlap_list, overlapped_data)
</code></pre>

<hr>
<h2 id='prop_spline_est'>The propensity-spline prediction estimator</h2><span id='topic+prop_spline_est'></span>

<h3>Description</h3>

<p>This method estimates the linear or quadratic parameters of the ADRF by
estimating a least-squares fit on the basis functions which are composed of
combinations of the covariates, propensity spline basis, and treatment values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prop_spline_est(Y,
                treat,
                covar_formula = ~ 1,
                covar_lin_formula = ~ 1,
                covar_sq_formula = ~ 1,
                data,
                e_treat_1 = NULL,
                degree = 1,
                wt = NULL,
                method = "same",
                spline_df = NULL,
                spline_const = 1,
                spline_linear = 1,
                spline_quad = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prop_spline_est_+3A_y">Y</code></td>
<td>
<p>is the the name of the outcome variable contained in <code>data</code>.</p>
</td></tr>
<tr><td><code id="prop_spline_est_+3A_treat">treat</code></td>
<td>
<p>is the name of the treatment variable contained in
<code>data</code>.</p>
</td></tr>
<tr><td><code id="prop_spline_est_+3A_covar_formula">covar_formula</code></td>
<td>
<p>is the formula to describe the covariates needed
to estimate the constant term:
<code>~ X.1 + ....</code>. Can include higher order terms or interactions.  i.e.
<code>~ X.1 + I(X.1^2) + X.1 * X.2 + ....</code>.  Don't forget the tilde before
listing the covariates.</p>
</td></tr>
<tr><td><code id="prop_spline_est_+3A_covar_lin_formula">covar_lin_formula</code></td>
<td>
<p>is the formula to describe the covariates needed
to estimate the linear term, t:
<code>~ X.1 + ....</code>. Can include higher order terms or interactions.  i.e.
<code>~ X.1 + I(X.1^2) + X.1 * X.2 + ....</code>.  Don't forget the tilde before
listing the covariates.</p>
</td></tr>
<tr><td><code id="prop_spline_est_+3A_covar_sq_formula">covar_sq_formula</code></td>
<td>
<p>is the formula to describe the covariates needed
to estimate the quadratic term, t^2:
<code>~ X.1 + ....</code>. Can include higher order terms or interactions.  i.e.
<code>~ X.1 + I(X.1^2) + X.1 * X.2 + ....</code>.  Don't forget the tilde before
listing the covariates.</p>
</td></tr>
<tr><td><code id="prop_spline_est_+3A_data">data</code></td>
<td>
<p>is a dataframe containing <code>Y</code>, <code>treat</code>, and
<code>X</code>.</p>
</td></tr>
<tr><td><code id="prop_spline_est_+3A_e_treat_1">e_treat_1</code></td>
<td>
<p>a vector, representing the conditional expectation of
<code>treat</code> from <code>T_mod</code>.  Or, plug in gps estimates here to create
splines from the gps values.</p>
</td></tr>
<tr><td><code id="prop_spline_est_+3A_degree">degree</code></td>
<td>
<p>is 1 for linear and 2 for quadratic outcome model.</p>
</td></tr>
<tr><td><code id="prop_spline_est_+3A_wt">wt</code></td>
<td>
<p>is weight used in lsfit for outcome regression.
Default is wt = NULL.</p>
</td></tr>
<tr><td><code id="prop_spline_est_+3A_method">method</code></td>
<td>
<p>is &quot;same&quot; if the same set of covariates are used to estimate
the constant, linear, and/or quadratic term with no spline terms.  If method = &quot;different&quot;, then
different sets of covariates can be used to estimate the constant, linear,
and/or quadratic term.  To use spline terms, it is necessary to set
method = &quot;different&quot;.  covar_lin_formula and covar_sq_formula must be specified
if method = &quot;different&quot;.</p>
</td></tr>
<tr><td><code id="prop_spline_est_+3A_spline_df">spline_df</code></td>
<td>
<p>degrees of freedom. The default, spline_df = NULL, corresponds to no knots.</p>
</td></tr>
<tr><td><code id="prop_spline_est_+3A_spline_const">spline_const</code></td>
<td>
<p>is the number of spline terms to include when estimating the constant term.</p>
</td></tr>
<tr><td><code id="prop_spline_est_+3A_spline_linear">spline_linear</code></td>
<td>
<p>is the number of spline terms to include when estimating the linear term.</p>
</td></tr>
<tr><td><code id="prop_spline_est_+3A_spline_quad">spline_quad</code></td>
<td>
<p>is the number of spline terms to include when estimating the quadratic term.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function estimates the ADRF by the method described in Schafer and Galagate (2015),
that fits an outcome model using a function of the covariates and spline basis
functions derived from the propensity function component.
</p>


<h3>Value</h3>

<p><code>prop_spline_est</code> returns an object of class &quot;causaldrf_lsfit&quot;,
a list that contains the following components:
</p>
<table>
<tr><td><code>param</code></td>
<td>
<p>the estimated parameters.</p>
</td></tr>
<tr><td><code>out_mod</code></td>
<td>
<p>the result of the outcome model fit using lsfit.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>the matched call.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Schafer, J.L., Galagate, D.L. (2015).  Causal inference with a
continuous treatment and outcome: alternative estimators for parametric
dose-response models. <em>Manuscript in preparation</em>.
</p>
<p>Little, Roderick and An, Hyonggin (2004).  ROBUST LIKELIHOOD-BASED ANALYSIS
OF MULTIVARIATE DATA WITH MISSING VALUES. <em>Statistica Sinica</em>.
<b>14</b>: 949&ndash;968.
</p>
<p>Schafer, Joseph L, Kang, Joseph (2008).  Average causal effects from
nonrandomized studies: a practical guide and simulated example.
<em>Psychological methods</em>, <b>13.4</b>, 279.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+iptw_est">iptw_est</a></code>, <code><a href="#topic+ismw_est">ismw_est</a></code>,
<code><a href="#topic+reg_est">reg_est</a></code>, <code><a href="#topic+aipwee_est">aipwee_est</a></code>, <code><a href="#topic+wtrg_est">wtrg_est</a></code>,
etc. for other estimates.
</p>
<p><code><a href="#topic+t_mod">t_mod</a></code>, <code><a href="#topic+overlap_fun">overlap_fun</a></code> to prepare the <code>data</code>
for use in the different estimates.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Example from Schafer (2015).

example_data &lt;- sim_data

t_mod_list &lt;- t_mod(treat = T,
              treat_formula = T ~ B.1 + B.2 + B.3 + B.4 + B.5 + B.6 + B.7 + B.8,
              data = example_data,
              treat_mod = "Normal")

cond_exp_data &lt;- t_mod_list$T_data
full_data &lt;- cbind(example_data, cond_exp_data)

prop_spline_list &lt;- prop_spline_est(Y = Y,
                            treat = T,
                            covar_formula = ~ B.1 + B.2 + B.3 + B.4 + B.5 + B.6 + B.7 + B.8,
                            covar_lin_formula = ~ 1,
                            covar_sq_formula = ~ 1,
                            data = example_data,
                            e_treat_1 = full_data$est_treat,
                            degree = 1,
                            wt = NULL,
                            method = "different",
                            spline_df = 5,
                            spline_const = 4,
                            spline_linear = 4,
                            spline_quad = 4)

sample_index &lt;- sample(1:1000, 100)

plot(example_data$T[sample_index],
      example_data$Y[sample_index],
      xlab = "T",
      ylab = "Y",
      main = "propensity spline estimate")

abline(prop_spline_list$param[1],
        prop_spline_list$param[2],
        lty = 2,
        col = "blue",
        lwd = 2)

legend('bottomright',
        "propensity spline estimate",
        lty = 2,
        bty = 'Y',
        cex = 1,
        col = "blue",
        lwd = 2)

rm(example_data, prop_spline_list, sample_index)
</code></pre>

<hr>
<h2 id='reg_est'>The regression prediction estimator</h2><span id='topic+reg_est'></span>

<h3>Description</h3>

<p>This method estimates the linear or quadratic parameters of the ADRF by
estimating a least-squares fit on the basis functions which are composed of
combinations of the covariates and treatment values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reg_est(Y,
        treat,
        covar_formula,
        covar_lin_formula = NULL,
        covar_sq_formula = NULL,
        data,
        degree,
        wt = NULL,
        method = "same")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reg_est_+3A_y">Y</code></td>
<td>
<p>is the the name of the outcome variable contained in <code>data</code>.</p>
</td></tr>
<tr><td><code id="reg_est_+3A_treat">treat</code></td>
<td>
<p>is the name of the treatment variable contained in
<code>data</code>.</p>
</td></tr>
<tr><td><code id="reg_est_+3A_covar_formula">covar_formula</code></td>
<td>
<p>is the formula to describe the covariates needed
to estimate the constant term:
<code>~ X.1 + ....</code>. Can include higher order terms or interactions.  i.e.
<code>~ X.1 + I(X.1^2) + X.1 * X.2 + ....</code>.  Don't forget the tilde before
listing the covariates.</p>
</td></tr>
<tr><td><code id="reg_est_+3A_covar_lin_formula">covar_lin_formula</code></td>
<td>
<p>is the formula to describe the covariates needed
to estimate the linear term, t:
<code>~ X.1 + ....</code>. Can include higher order terms or interactions.  i.e.
<code>~ X.1 + I(X.1^2) + X.1 * X.2 + ....</code>.  Don't forget the tilde before
listing the covariates.</p>
</td></tr>
<tr><td><code id="reg_est_+3A_covar_sq_formula">covar_sq_formula</code></td>
<td>
<p>is the formula to describe the covariates needed
to estimate the quadratic term, t^2:
<code>~ X.1 + ....</code>. Can include higher order terms or interactions.  i.e.
<code>~ X.1 + I(X.1^2) + X.1 * X.2 + ....</code>.  Don't forget the tilde before
listing the covariates.</p>
</td></tr>
<tr><td><code id="reg_est_+3A_data">data</code></td>
<td>
<p>is a dataframe containing <code>Y</code>, <code>treat</code>, and
<code>X</code>.</p>
</td></tr>
<tr><td><code id="reg_est_+3A_degree">degree</code></td>
<td>
<p>is 1 for linear and 2 for quadratic outcome model.</p>
</td></tr>
<tr><td><code id="reg_est_+3A_wt">wt</code></td>
<td>
<p>is weight used in lsfit for outcome regression.
Default is wt = NULL.</p>
</td></tr>
<tr><td><code id="reg_est_+3A_method">method</code></td>
<td>
<p>is &quot;same&quot; if the same set of covariates are used to estimate
the constant, linear, and/or quadratic term.  If method = &quot;different&quot;, then
different sets of covariates can be used to estimate the constant, linear,
and/or quadratic term.  covar_lin_formula and covar_sq_formula must be specified
if method = &quot;different&quot;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function estimates the ADRF by the method described in Schafer and Galagate (2015)
that fits an outcome model using a function of the covariates.
</p>


<h3>Value</h3>

<p><code>reg_est</code> returns an object of class &quot;causaldrf_lsfit&quot;,
a list that contains the following components:
</p>
<table>
<tr><td><code>param</code></td>
<td>
<p>the estimated parameters.</p>
</td></tr>
<tr><td><code>out_mod</code></td>
<td>
<p>the result of the outcome model fit using lsfit.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>the matched call.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Schafer, J.L., Galagate, D.L. (2015).  Causal inference with a
continuous treatment and outcome: alternative estimators for parametric
dose-response models. <em>Manuscript in preparation</em>.
</p>
<p>Schafer, Joseph L, Kang, Joseph (2008).  Average causal effects from
nonrandomized studies: a practical guide and simulated example.
<em>Psychological methods</em>, <b>13.4</b>, 279.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+iptw_est">iptw_est</a></code>, <code><a href="#topic+ismw_est">ismw_est</a></code>,
<code><a href="#topic+aipwee_est">aipwee_est</a></code>, <code><a href="#topic+wtrg_est">wtrg_est</a></code>,
etc. for other estimates.
</p>
<p><code><a href="#topic+t_mod">t_mod</a></code>, <code><a href="#topic+overlap_fun">overlap_fun</a></code> to prepare the <code>data</code>
for use in the different estimates.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Example from Schafer (2015).

example_data &lt;- sim_data

reg_list &lt;- reg_est(Y = Y,
                    treat = T,
                    covar_formula = ~ B.1 + B.2 + B.3 + B.4 + B.5 + B.6 + B.7 + B.8,
                    covar_lin_formula = ~ 1,
                    covar_sq_formula = ~ 1,
                    data = example_data,
                    degree = 1,
                    wt = NULL,
                    method = "same")

sample_index &lt;- sample(1:1000, 100)

plot(example_data$T[sample_index],
      example_data$Y[sample_index],
      xlab = "T",
      ylab = "Y",
      main = "regression estimate")

abline(reg_list$param[1],
        reg_list$param[2],
        lty = 2,
        col = "blue",
        lwd = 2)

legend('bottomright',
        "regression estimate",
        lty = 2,
        bty = 'Y',
        cex = 1,
        col = "blue",
        lwd = 2)

rm(example_data, reg_list, sample_index)
</code></pre>

<hr>
<h2 id='scalar_wts'>This function calculates scalar weights for use in other models</h2><span id='topic+scalar_wts'></span>

<h3>Description</h3>

<p>This function calculates the scalar weights
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scalar_wts(treat,
           treat_formula,
           numerator_formula,
           data,
           treat_mod,
           link_function,
           ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scalar_wts_+3A_treat">treat</code></td>
<td>
<p>is the name of the treatment variable contained in
<code>data</code>.</p>
</td></tr>
<tr><td><code id="scalar_wts_+3A_treat_formula">treat_formula</code></td>
<td>
<p>an object of class &quot;formula&quot; (or one that can be
coerced to that class) that regresses <code>treat</code> on a linear combination
of <code>X</code>: a symbolic description of the model to be fitted.</p>
</td></tr>
<tr><td><code id="scalar_wts_+3A_numerator_formula">numerator_formula</code></td>
<td>
<p>an object of class &quot;formula&quot; (or one that can be
coerced to that class) that regresses <code>treat</code> on a linear combination
of <code>X</code>: a symbolic description of the model to be fitted.  i.e.
<code>treat ~ 1</code>.</p>
</td></tr>
<tr><td><code id="scalar_wts_+3A_data">data</code></td>
<td>
<p>is a dataframe containing <code>treat</code>, and
<code>X</code>.</p>
</td></tr>
<tr><td><code id="scalar_wts_+3A_treat_mod">treat_mod</code></td>
<td>
<p>a description of the error distribution to be used in the
model for treatment. Options include: <code>"Normal"</code> for normal model,
<code>"LogNormal"</code> for lognormal model, <code>"Poisson"</code> for Poisson model,
<code>"Sqrt"</code> for square-root transformation
to a normal treatment,
<code>"NegBinom"</code> for negative binomial model, <code>"Gamma"</code> for gamma
model.</p>
</td></tr>
<tr><td><code id="scalar_wts_+3A_link_function">link_function</code></td>
<td>
<p>is either &quot;log&quot;, &quot;inverse&quot;, or &quot;identity&quot; for the
&quot;Gamma&quot; <code>treat_mod</code>.</p>
</td></tr>
<tr><td><code id="scalar_wts_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to the treatment regression fitting function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>scalar_wts</code>  returns an object of class &quot;causaldrf_wts&quot;,
a list that contains the following components:
</p>
<table>
<tr><td><code>param</code></td>
<td>
<p>summary of estimated weights.</p>
</td></tr>
<tr><td><code>t_mod</code></td>
<td>
<p>the result of the treatment model fit.</p>
</td></tr>
<tr><td><code>num_mod</code></td>
<td>
<p>the result of the numerator model fit.</p>
</td></tr>
<tr><td><code>weights</code></td>
<td>
<p>estimated weights for each unit.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>the matched call.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Schafer, J.L., Galagate, D.L. (2015).  Causal inference with a
continuous treatment and outcome: alternative estimators for parametric
dose-response models. <em>Manuscript in preparation</em>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+iptw_est">iptw_est</a></code>, <code><a href="#topic+ismw_est">ismw_est</a></code>,
<code><a href="#topic+reg_est">reg_est</a></code>, <code><a href="#topic+aipwee_est">aipwee_est</a></code>, <code><a href="#topic+wtrg_est">wtrg_est</a></code>,
etc. for other estimates.
</p>
<p><code><a href="#topic+t_mod">t_mod</a></code>, <code><a href="#topic+overlap_fun">overlap_fun</a></code> to prepare the <code>data</code>
for use in the different estimates.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Example from Schafer (2015).

example_data &lt;- sim_data

scalar_wts_list &lt;- scalar_wts(treat = T,
                     treat_formula = T ~ B.1 + B.2 + B.3 + B.4 + B.5 + B.6 + B.7 + B.8,
                     numerator_formula = T ~ 1,
                     data = example_data,
                     treat_mod = "Normal")

sample_index &lt;- sample(1:1000, 100)

plot(example_data$T[sample_index],
     scalar_wts_list$weights[sample_index],
     xlab = "T",
     ylab = "weights",
     main = "scalar_wts")


rm(example_data, scalar_wts_list, sample_index)
</code></pre>

<hr>
<h2 id='sim_data'>Simulated data from Schafer and Galagate (2015)</h2><span id='topic+sim_data'></span>

<h3>Description</h3>

<p>Simulated data used in the paper &quot;Causal inference with a continuous
treatment and outcome: alternative estimators for parametric dose-response
models&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(sim_data)
</code></pre>


<h3>Format</h3>

<p>A data frame with 1000 rows and 20 variables:</p>


<h3>Details</h3>

<p>A dataset containing sim_data.
</p>


<h3>Value</h3>

<p><code>(A.1, A.2, A.3, A.4, A.5, A.6, A.7, A.8)</code> are the true measured covariates.
</p>
<p><code>(B.1, B.2, B.3, B.4, B.5, B.6, B.7, B.8)</code> are the transformed covariates.
</p>
<table>
<tr><td><code>T</code></td>
<td>
<p>treatment</p>
</td></tr>
<tr><td><code>Theta.1</code></td>
<td>
<p>unit level intercept</p>
</td></tr>
<tr><td><code>Theta.2</code></td>
<td>
<p>unit level slope</p>
</td></tr>
<tr><td><code>Y</code></td>
<td>
<p>outcome</p>
</td></tr>
</table>


<h3>Source</h3>

<p>use the <code>draw_sample</code> function
</p>


<h3>References</h3>

<p>Schafer, J.L., Galagate, D.L. (2015).  Causal inference with a
continuous treatment and outcome: alternative estimators for parametric
dose-response models. <em>Manuscript in preparation</em>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Example from Schafer (2015).
data(sim_data)
head(sim_data)
</code></pre>

<hr>
<h2 id='t_mod'>A function to estimate conditional expected values and higher order moments</h2><span id='topic+t_mod'></span>

<h3>Description</h3>

<p>This function fits a glm regression specified by the user to
estimate conditional moments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>t_mod(treat,
      treat_formula,
      data,
      treat_mod,
      link_function,
      ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="t_mod_+3A_treat">treat</code></td>
<td>
<p>is the name of the treatment variable contained in <code>data</code>.</p>
</td></tr>
<tr><td><code id="t_mod_+3A_treat_formula">treat_formula</code></td>
<td>
<p>an object of class &quot;formula&quot; (or one that can be coerced to that class)
that regresses <code>treat</code> on a linear combination of <code>X</code>:
a symbolic description of the model to be fitted.</p>
</td></tr>
<tr><td><code id="t_mod_+3A_data">data</code></td>
<td>
<p>is a dataframe containing <code>Y</code>, <code>treat</code>, and <code>X</code>.</p>
</td></tr>
<tr><td><code id="t_mod_+3A_treat_mod">treat_mod</code></td>
<td>
<p>a description of the error distribution
to be used in the model for treatment. Options include:
<code>"Normal"</code> for normal model,
<code>"LogNormal"</code> for lognormal model,
<code>"Sqrt"</code> for square-root transformation
to a normal treatment,
<code>"Poisson"</code> for Poisson model,
<code>"NegBinom"</code> for negative binomial model,
<code>"Gamma"</code> for gamma model.</p>
</td></tr>
<tr><td><code id="t_mod_+3A_link_function">link_function</code></td>
<td>
<p>is either &quot;log&quot;, &quot;inverse&quot;, or &quot;identity&quot; for the &quot;Gamma&quot; <code>treat_mod</code>.</p>
</td></tr>
<tr><td><code id="t_mod_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to the low level treatment regression fitting functions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>t_mod</code> returns a list containing the following elements:
</p>
<table>
<tr><td><code>T_data</code></td>
<td>
<p>a dataframe containing estimated treatment, estimated treatment squared,
estimated treatment cube, estimated treatment quartic, and estimated gps.</p>
</td></tr>
<tr><td><code>T_result</code></td>
<td>
<p>the result of the treatment model fit.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Schafer, J.L., Galagate, D.L. (2015).  Causal inference with a
continuous treatment and outcome: alternative estimators for parametric
dose-response models. <em>Manuscript in preparation</em>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ismw_est">ismw_est</a></code>, <code><a href="#topic+reg_est">reg_est</a></code>,
<code><a href="#topic+wtrg_est">wtrg_est</a></code>, <code><a href="#topic+aipwee_est">aipwee_est</a></code>, etc. for other estimates.
</p>
<p><code><a href="#topic+overlap_fun">overlap_fun</a></code> to prepare the <code>data</code> for use in the different estimates.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Example from Schafer (2015).

example_data &lt;- sim_data

t_mod_list &lt;- t_mod(treat = T,
                    treat_formula = T ~ B.1 + B.2 + B.3 + B.4 + B.5 + B.6 + B.7 + B.8,
                    data = example_data,
                    treat_mod = "Normal")

cond_exp_data &lt;- t_mod_list$T_data

full_data &lt;- cbind(example_data, cond_exp_data)

rm(example_data, t_mod_list, cond_exp_data, full_data)
</code></pre>

<hr>
<h2 id='wtrg_est'>The weighted regression estimator</h2><span id='topic+wtrg_est'></span>

<h3>Description</h3>

<p>This method uses weight matrices to
estimate parameters for an ADRF with quadratic or linear fits.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wtrg_est(Y,
         treat,
         covar_formula,
         data,
         e_treat_1,
         e_treat_2,
         e_treat_3,
         e_treat_4,
         degree)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wtrg_est_+3A_y">Y</code></td>
<td>
<p>is the output</p>
</td></tr>
<tr><td><code id="wtrg_est_+3A_treat">treat</code></td>
<td>
<p>is the treatment variable</p>
</td></tr>
<tr><td><code id="wtrg_est_+3A_covar_formula">covar_formula</code></td>
<td>
<p>is the formula for the covariates model of the form: ~ X.1 + ....</p>
</td></tr>
<tr><td><code id="wtrg_est_+3A_data">data</code></td>
<td>
<p>will contain all the data: X, treat, and Y</p>
</td></tr>
<tr><td><code id="wtrg_est_+3A_e_treat_1">e_treat_1</code></td>
<td>
<p>is estimated treatment</p>
</td></tr>
<tr><td><code id="wtrg_est_+3A_e_treat_2">e_treat_2</code></td>
<td>
<p>is estimated treatment squared</p>
</td></tr>
<tr><td><code id="wtrg_est_+3A_e_treat_3">e_treat_3</code></td>
<td>
<p>is estimated treatment cubed</p>
</td></tr>
<tr><td><code id="wtrg_est_+3A_e_treat_4">e_treat_4</code></td>
<td>
<p>is estimated treatment to the fourth</p>
</td></tr>
<tr><td><code id="wtrg_est_+3A_degree">degree</code></td>
<td>
<p>is 1 for linear fit and 2 for quadratic fit</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function estimates the ADRF by the method described in Schafer and Galagate (2015)
which uses weight matrices to adjust for possible bias.
</p>


<h3>Value</h3>

<p><code>wtrg_est</code> returns an object of class &quot;causaldrf&quot;,
a list that contains the following components:
</p>
<table>
<tr><td><code>param</code></td>
<td>
<p>the estimated parameters.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>the matched call.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Schafer, J.L., Galagate, D.L. (2015).  Causal inference with a
continuous treatment and outcome: alternative estimators for parametric
dose-response models. <em>Manuscript in preparation</em>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+iptw_est">iptw_est</a></code>, <code><a href="#topic+ismw_est">ismw_est</a></code>,
<code><a href="#topic+reg_est">reg_est</a></code>, <code><a href="#topic+aipwee_est">aipwee_est</a></code>, <code><a href="#topic+wtrg_est">wtrg_est</a></code>,
etc. for other estimates.
</p>
<p><code><a href="#topic+t_mod">t_mod</a></code>, <code><a href="#topic+overlap_fun">overlap_fun</a></code> to prepare the <code>data</code>
for use in the different estimates.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Example from Schafer (2015).

example_data &lt;- sim_data


t_mod_list &lt;- t_mod(treat = T,
              treat_formula = T ~ B.1 + B.2 + B.3 + B.4 + B.5 + B.6 + B.7 + B.8,
              data = example_data,
              treat_mod = "Normal")

cond_exp_data &lt;- t_mod_list$T_data
full_data &lt;- cbind(example_data, cond_exp_data)

wtrg_list &lt;- wtrg_est(Y = Y,
                      treat = T,
                      covar_formula = ~ B.1 + B.2 + B.3 + B.4 + B.5 + B.6 + B.7 + B.8,
                      data = example_data,
                      e_treat_1 = full_data$est_treat,
                      e_treat_2 = full_data$est_treat_sq,
                      e_treat_3 = full_data$est_treat_cube,
                      e_treat_4 = full_data$est_treat_quartic,
                      degree = 1)

sample_index &lt;- sample(1:1000, 100)

plot(example_data$T[sample_index],
      example_data$Y[sample_index],
      xlab = "T",
      ylab = "Y",
      main = "weighted regression estimate")

abline(wtrg_list$param[1],
        wtrg_list$param[2],
        lty = 2,
        lwd = 2,
        col = "blue")

legend('bottomright',
        "weighted regression estimate",
        lty = 2,
        lwd = 2,
        col = "blue",
        bty='Y',
        cex=1)

rm(example_data, t_mod_list, cond_exp_data, full_data, wtrg_list, sample_index)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
