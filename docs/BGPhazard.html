<!DOCTYPE html><html><head><title>Help for package BGPhazard</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {BGPhazard}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#BeMRes'><p>Markov Beta Model</p></a></li>
<li><a href='#BePlotDiag'><p>Diagnosis plots for PI, U, C and Epsilon</p></a></li>
<li><a href='#BePloth'><p>Plots for the discrete Hazard and Survival Function Estimates</p></a></li>
<li><a href='#BGPHazard'><p>BGPHazard: A package bayesian nonparametric inference in survival analysis.</p></a></li>
<li><a href='#BMTKleinbook'>
<p>Times to death or relapse (in days) for patients with bone marrow transplants for Hodgkin and non-Hodgkin lymphoma</p></a></li>
<li><a href='#BSBHaz'><p>BSBHaz posterior samples using Gibbs Sampler</p></a></li>
<li><a href='#BSBInit'><p>Initial setup for BSBHaz model</p></a></li>
<li><a href='#BSBPlotDiag'><p>Plot diagnostics for BSBHaz model</p></a></li>
<li><a href='#BSBPlotSumm'><p>Plot summaries for BSBHaz model</p></a></li>
<li><a href='#BSBSumm'><p>Get posterior summaries for BSBHaz model</p></a></li>
<li><a href='#CCuMRes'><p>Bayesian Semiparametric Cure Rate Model with an Unknown Threshold and</p>
Covariate Information</a></li>
<li><a href='#CCuPlotDiag'><p>Diagnostics plots for Lambda, Theta, Delta,</p>
U, C, Pi, Z and Epsilon. Hazard function, cure proportion and cure time for the median observation.</a></li>
<li><a href='#CCuPloth'><p>Plots for the Hazard and Survival Funcion Estimates</p></a></li>
<li><a href='#CGaMRes'><p>Markov Gamma Model with Covariates</p></a></li>
<li><a href='#CGaPlotDiag'><p>Diagnostics plots for lambda, U, C, Epsilon and Theta</p></a></li>
<li><a href='#CGaPloth'><p>Plots for the Hazard and Survival Funcion Estimates for the Bayesian</p>
non-parametric Markov gamma model with covariates in survival analysis.</a></li>
<li><a href='#cpo'><p>Conditional Predictive Ordinate (CPO) Statistic</p></a></li>
<li><a href='#crm3'>
<p>Simulated data from the proportional hazards cure rate model of Yakolev &amp; Tsodikov (1996) by taking a baseline density with a bounded support.</p></a></li>
<li><a href='#CuMRes'><p>Bayesian Semiparametric Cure Rate Model with an Unknown Threshold</p></a></li>
<li><a href='#CuPlotDiag'><p>Diagnosis plots for Lambda, U, C, Mu, Pi, Z and Epsilon</p></a></li>
<li><a href='#CuPloth'><p>Plots for the Hazard and Survival Funcion Estimates</p></a></li>
<li><a href='#GaMRes'><p>Markov Gamma Model</p></a></li>
<li><a href='#GaPlotDiag'><p>Diagnosis plots for Lambda, U, C and Epsilon</p></a></li>
<li><a href='#GaPloth'><p>Plots for the Hazard and Survival Function Estimates</p></a></li>
<li><a href='#gehan'>
<p>Times of Remission of Leukemia Patients (Gehan)</p></a></li>
<li><a href='#KIDNEY'><p>Recurrent infection of kidney catheters</p></a></li>
<li><a href='#leukemiaFZ'>
<p>Survival Times of Patients with Leukemia (Feigl and Zelen)</p></a></li>
<li><a href='#psych'>
<p>Death Times of Psychiatric Patients (Woolson)</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Markov Beta and Gamma Processes for Modeling Hazard Rates</td>
</tr>
<tr>
<td>Version:</td>
<td>2.1.1</td>
</tr>
<tr>
<td>Author:</td>
<td>L. E. Nieto-Barajas, J. A. Garcia Bueno, E.A. Morones Ishikawa and
    J. Pliego</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Emilio Akira Morones Ishikawa &lt;emiliomorones@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Computes the hazard rate estimate as described by
    Nieto-Barajas &amp; Walker (2002), Nieto-Barajas (2003), Nieto-Barajas &amp;
    Walker (2007) and Nieto-Barajas &amp; Yin (2008).</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/EAMI91/BGPhazard">https://github.com/EAMI91/BGPhazard</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/EAMI91/BGPhazard/issues">https://github.com/EAMI91/BGPhazard/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>Brobdingnag, dplyr, ggplot2, ggthemes, gridExtra, magrittr,
progress, purrr, readr, rlang, stats, stringr, survival,
tibble, tidyr, utils</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, testthat</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-09-03 14:20:05 UTC</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-09-02 22:32:51 UTC; emiliomorones</td>
</tr>
</table>
<hr>
<h2 id='BeMRes'>Markov Beta Model</h2><span id='topic+BeMRes'></span>

<h3>Description</h3>

<p>Posterior inference for the Bayesian non-parametric Markov beta model for discrete
survival times.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BeMRes(
  times,
  delta = rep(1, length(times)),
  alpha = rep(1e-04, K),
  beta = rep(1e-04, K),
  c.r = rep(0, K - 1),
  a.eps = 0.1,
  b.eps = 0.1,
  type.c = 4,
  epsilon = 1,
  iterations = 2000,
  burn.in = floor(iterations * 0.2),
  thinning = 5,
  printtime = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BeMRes_+3A_times">times</code></td>
<td>
<p>Numeric positive vector. Failure times.</p>
</td></tr>
<tr><td><code id="BeMRes_+3A_delta">delta</code></td>
<td>
<p>Logical vector. Status indicator. <code>TRUE</code> (1) indicates
exact lifetime is known, <code>FALSE</code> (0) indicates that the corresponding
failure time is right censored.</p>
</td></tr>
<tr><td><code id="BeMRes_+3A_alpha">alpha</code></td>
<td>
<p>Nonnegative vector. Small entries are recommended in order to
specify a non-informative prior distribution.</p>
</td></tr>
<tr><td><code id="BeMRes_+3A_beta">beta</code></td>
<td>
<p>Nonnegative vector. Small entries are recommended in order to
specify a non-informative prior distribution.</p>
</td></tr>
<tr><td><code id="BeMRes_+3A_c.r">c.r</code></td>
<td>
<p>Nonnegative vector. The higher the entries, the higher the
correlation of two consecutive failure times.</p>
</td></tr>
<tr><td><code id="BeMRes_+3A_a.eps">a.eps</code></td>
<td>
<p>Numeric. Shape parameter for the prior gamma distribution of
epsilon when <code>type.c = 4</code>.</p>
</td></tr>
<tr><td><code id="BeMRes_+3A_b.eps">b.eps</code></td>
<td>
<p>Numeric. Scale parameter for the prior gamma distribution of
epsilon when <code>type.c = 4</code>.</p>
</td></tr>
<tr><td><code id="BeMRes_+3A_type.c">type.c</code></td>
<td>
<p>Integer. 1=defines <code>c.r</code> as a zero-entry vector; 2=lets
the user define <code>c.r</code> freely; 3=assigns <code>c.r</code> an
exponential prior distribution with mean <code>epsilon</code>; 4=assigns <code>c.r</code> 
an exponential hierarchical distribution with mean <code>epsilon</code> which in turn has a
a Ga(a.eps, b.eps) distribution.</p>
</td></tr>
<tr><td><code id="BeMRes_+3A_epsilon">epsilon</code></td>
<td>
<p>Double. Mean of the exponential distribution assigned to
<code>c.r</code></p>
</td></tr>
<tr><td><code id="BeMRes_+3A_iterations">iterations</code></td>
<td>
<p>Integer. Number of iterations including the <code>burn.in</code>
and <code>thining</code> to be computed for the Markov chain.</p>
</td></tr>
<tr><td><code id="BeMRes_+3A_burn.in">burn.in</code></td>
<td>
<p>Integer. Length of the burn-in period for the Markov chain.</p>
</td></tr>
<tr><td><code id="BeMRes_+3A_thinning">thinning</code></td>
<td>
<p>Integer. Factor by which the chain will be thinned. Thinning
the Markov chain is to reduces autocorrelation.</p>
</td></tr>
<tr><td><code id="BeMRes_+3A_printtime">printtime</code></td>
<td>
<p>Logical. If <code>TRUE</code>, prints out the execution time.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Computes the Gibbs sampler given by the full conditional distributions of u
and Pi (Nieto-Barajas &amp; Walker, 2002) and arranges the resulting Markov
chain into a tibble which can be used to obtain posterior summaries.
</p>


<h3>Note</h3>

<p>It is recommended to verify chain's stationarity. This can be done by
checking each partition element individually. See <a href="#topic+BePlotDiag">BePlotDiag</a>.
</p>


<h3>References</h3>

<p>- Nieto-Barajas, L. E. &amp; Walker, S. G. (2002). Markov beta and
gamma processes for modelling hazard rates. <em>Scandinavian Journal of
Statistics</em> <strong>29</strong>: 413-424.
</p>


<h3>See Also</h3>

<p><a href="#topic+BePlotDiag">BePlotDiag</a>, <a href="#topic+BePloth">BePloth</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>


## Simulations may be time intensive. Be patient.

## Example 1
#  data(psych)
#  timesP &lt;- psych$time
#  deltaP &lt;- psych$death
#  BEX1 &lt;- BeMRes(timesP, deltaP, iterations = 3000, burn.in = 300, thinning = 1)

## Example 2
#  data(gehan)
#  timesG &lt;- gehan$time[gehan$treat == "control"]
#  deltaG &lt;- gehan$cens[gehan$treat == "control"]
#  BEX2 &lt;- BeMRes(timesG, deltaG, type.c = 2, c.r = rep(50, 22))



</code></pre>

<hr>
<h2 id='BePlotDiag'>Diagnosis plots for PI, U, C and Epsilon</h2><span id='topic+BePlotDiag'></span>

<h3>Description</h3>

<p>Diagnostic plots for hazard rate (PI), latent variable (U), dependence
parameter (C) and parameter of the hierarchical model (Epsilon).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BePlotDiag(M, variable = "PI", pos = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BePlotDiag_+3A_m">M</code></td>
<td>
<p>Tibble. Contains the output by
<code>BeMRes</code></p>
</td></tr>
<tr><td><code id="BePlotDiag_+3A_variable">variable</code></td>
<td>
<p>Either &quot;PI&quot;, &quot;U&quot;, &quot;C&quot; or &quot;Epsilon&quot;. Variable for which
diagnostic plot will be shown.</p>
</td></tr>
<tr><td><code id="BePlotDiag_+3A_pos">pos</code></td>
<td>
<p>Positive integer. Position of the selected <code>variable</code> to be
plotted.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function returns a diagnostics plot for the chain of the selected
variable. The diagnostics includes trace, ergodic mean, autocorrelation
function and histogram.
</p>


<h3>References</h3>

<p>- Nieto-Barajas, L. E. &amp; Walker, S. G. (2002). Markov beta and
gamma processes for modelling hazard rates. <em>Scandinavian Journal of
Statistics</em> <strong>29</strong>: 413-424.
</p>


<h3>See Also</h3>

<p><a href="#topic+BeMRes">BeMRes</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>


## Simulations may be time intensive. Be patient.

## Example 1
#  data(psych)
#  timesP &lt;- psych$time
#  deltaP &lt;- psych$death
#  BEX1 &lt;- BeMRes(timesP, deltaP, iterations = 3000, burn.in = 300, thinning = 1)
#  BePlotDiag(BEX1, variable = "PI", pos = 2)
#  BePlotDiag(BEX1, variable = "U", pos = 3)

## Example 2
#  data(gehan)
#  timesG &lt;- gehan$time[gehan$treat == "control"]
#  deltaG &lt;- gehan$cens[gehan$treat == "control"]
#  BEX2 &lt;- BeMRes(timesG, deltaG, type.c = 2, c.r = rep(50, 22))
#  BePlotDiag(BEX2, variable = "PI", pos = 5)
#  BePlotDiag(BEX2, variable = "U", pos = 4)



</code></pre>

<hr>
<h2 id='BePloth'>Plots for the discrete Hazard and Survival Function Estimates</h2><span id='topic+BePloth'></span>

<h3>Description</h3>

<p>Plots the resulting hazard function along with the survival function
estimates defined by the Markov beta process (Nieto-Barajas and Walker,
2002).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BePloth(
  M,
  type.h = "dot",
  add.survival = T,
  intervals = T,
  confidence = 0.95,
  summary = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BePloth_+3A_m">M</code></td>
<td>
<p>tibble. Contains the output generated by <code>BeMRres</code>.</p>
</td></tr>
<tr><td><code id="BePloth_+3A_type.h">type.h</code></td>
<td>
<p>character, &quot;line&quot; = plots the hazard rate of each interval
joined by a line, &quot;dot&quot; = plots the hazard rate of each interval with a dot.</p>
</td></tr>
<tr><td><code id="BePloth_+3A_add.survival">add.survival</code></td>
<td>
<p>logical, If <code>TRUE</code>, plots the Nelson-Alen based
estimate in the same graphic of the hazard rate and the Kaplan-Meier
estimates of the survival function.</p>
</td></tr>
<tr><td><code id="BePloth_+3A_intervals">intervals</code></td>
<td>
<p>logical. If TRUE, plots confidence bands for the selected functions including Nelson-Aalen and/or Kaplan-Meier estimate.</p>
</td></tr>
<tr><td><code id="BePloth_+3A_confidence">confidence</code></td>
<td>
<p>Numeric. Confidence band width.</p>
</td></tr>
<tr><td><code id="BePloth_+3A_summary">summary</code></td>
<td>
<p>Logical. If <code>TRUE</code>, a summary for hazard and survival
functions is returned as a tibble.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function returns estimators plots for the hazard rate as computed
by <code><a href="#topic+BeMRes">BeMRes</a></code> together with the Nelson-Aalen estimate along with their
confidence intervals for the data set given. Additionally, it plots the
survival function and the Kaplan-Meier estimate with their corresponding
credible intervals.
</p>


<h3>Value</h3>

<table>
<tr><td><code>SUM.h</code></td>
<td>
<p>Numeric tibble. Summary for the mean, median, and a
<code>confint / 100</code> confidence interval for each failure time of the hazard
function.</p>
</td></tr> <tr><td><code>SUM.S</code></td>
<td>
<p>Numeric tibble. Summary for the mean, median, and a
<code>confint / 100</code> confidence interval for each failure time of the survival
function.</p>
</td></tr>
</table>


<h3>References</h3>

<p>- Nieto-Barajas, L. E. &amp; Walker, S. G. (2002). Markov beta and
gamma processes for modelling hazard rates. <em>Scandinavian Journal of
Statistics</em> <strong>29</strong>: 413-424.
</p>


<h3>See Also</h3>

<p><a href="#topic+BeMRes">BeMRes</a>, <a href="#topic+BePlotDiag">BePlotDiag</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>


## Simulations may be time intensive. Be patient.

## Example 1
#  data(psych)
#  timesP &lt;- psych$time
#  deltaP &lt;- psych$death
#  BEX1 &lt;- BeMRes(timesP, deltaP, iterations = 3000, burn.in = 300, thinning = 1)
#  BePloth(BEX1)
#  sum &lt;- BePloth(BEX1, type.h = "line", summary = T)

## Example 2
#  data(gehan)
#  timesG &lt;- gehan$time[gehan$treat == "control"]
#  deltaG &lt;- gehan$cens[gehan$treat == "control"]
#  BEX2 &lt;- BeMRes(timesG, deltaG, type.c = 2, c.r = rep(50, 22))
#  BePloth(BEX2)



</code></pre>

<hr>
<h2 id='BGPHazard'>BGPHazard: A package bayesian nonparametric inference in survival analysis.</h2><span id='topic+BGPHazard'></span>

<h3>Description</h3>

<p>The BGPHazard package provides three categories of important functions:
simulating, diagnostic and result.
</p>


<h3>Simulating functions</h3>

<p>The simulating functions are used to make posterior inference for the bayesian survival 
semiparametric models as described by  
Nieto-Barajas and Walker (2002), Nieto-Barajas (2003) and Nieto-Barajas, L. E., &amp; Yin, G. (2008)
</p>


<h3>Diagnostic functions</h3>

<p>The diagnostic functions are used to make convergence diagnosics plots about the simulations of the parameters/variables.
</p>


<h3>Result functions</h3>

<p>The result functions are used to produce estimators plots of the hazard function 
along with the survival function defined by the model.
</p>

<hr>
<h2 id='BMTKleinbook'>
Times to death or relapse (in days) for patients with bone marrow transplants for Hodgkin and non-Hodgkin lymphoma
</h2><span id='topic+BMTKleinbook'></span>

<h3>Description</h3>

<p>Was collected on 43 bone marrow transplant patients at The Ohio State University Bone Marrow Transplant Unit. Details of this study can be found in Avalos et al. (1993).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(BMTKleinbook)</code></pre>


<h3>Format</h3>

<p>A data frame with 43 observations containing:
</p>

<dl>
<dt><code>times</code></dt><dd><p>time to death or relapse in days</p>
</dd>
<dt><code>delta</code></dt><dd><p>Status indicator: 1 = death or relapse; 0 = otherwise</p>
</dd>
<dt><code>tTransplant</code></dt><dd><p>Allogeneic transplant from an HLA match sibling donor (1) or an autogeneic transplant (0)</p>
</dd>
<dt><code>hodgkin</code></dt><dd><p>Hodgkin disease (1), or non-Hodgkin lymphoma (0)</p>
</dd>
<dt><code>karnofsky</code></dt><dd><p>The pretransplant Karnofsky score</p>
</dd>
<dt><code>waiting</code></dt><dd><p>Waiting time to transplant</p>
</dd>
</dl>



<h3>Source</h3>

<p>Klein, J. P., and Moeschberger, M. L. (2003). Survival analysis: techniques for censored and truncated data. Springer Science &amp; Business Media. 
</p>


<h3>References</h3>

<p>Copelan, E. A., Biggs, J. C., Thompson, J. M., Crilley, P., Szer, J., Klein, J. P., Kapoor, N.,
Avalos, B. R., Cunningham, I., Atkinson, K., Downs, K., Harmon, G. S., Daly, M. B., Brodsky, I., Bulova, S. I., and Tutschka, P. J. Treatment for Acute Myelocytic Leukemia with Allogeneic Bone Marrow Transplantation Following Preparation with Bu/Cy. Blood 78 (1991): 838-843.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Cox Cure Gama Process Example 1
# data(BMTKleinbook)
    # res &lt;- CCuMRes(BMTKleinbook, covs.x = c("tTransplant","hodgkin","karnofsky","waiting"),
    #                covs.y = c("tTransplant","hodgkin","karnofsky","waiting"),
    #                        type.t = 2, K = 72, length = 30,
    #                        alpha = rep(2,72), beta = rep(2,72), c.r = rep(50, 71), type.c = 2,
    #                        var.delta.str = .1, var.theta.str = 1,
    #                        var.delta.ini = 100, var.theta.ini = 100,
    #                        iterations = 100, burn.in = 10, thinning = 1)
</code></pre>

<hr>
<h2 id='BSBHaz'>BSBHaz posterior samples using Gibbs Sampler</h2><span id='topic+BSBHaz'></span>

<h3>Description</h3>

<p><code>BSBHaz</code> samples posterior observations from the bivariate survival
model (BSBHaz model) proposed by Nieto-Barajas &amp; Walker (2007).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BSBHaz(
  bsb_init,
  iter,
  burn_in = 0,
  omega_d = NULL,
  gamma_d = NULL,
  theta_d = NULL,
  seed = 42
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BSBHaz_+3A_bsb_init">bsb_init</code></td>
<td>
<p>An object of class 'BSBinit' created by
<code><a href="#topic+BSBInit">BSBInit</a></code>.</p>
</td></tr>
<tr><td><code id="BSBHaz_+3A_iter">iter</code></td>
<td>
<p>A positive integer. Number of samples generated by the Gibbs
Sampler.</p>
</td></tr>
<tr><td><code id="BSBHaz_+3A_burn_in">burn_in</code></td>
<td>
<p>A positive integer. Number of iterations that should be
discarded as burn in period.</p>
</td></tr>
<tr><td><code id="BSBHaz_+3A_omega_d">omega_d</code></td>
<td>
<p>A positive double. This parameter defines the interval used in
the Metropolis-Hastings algorithm to sample proposals for omega. See
details.</p>
</td></tr>
<tr><td><code id="BSBHaz_+3A_gamma_d">gamma_d</code></td>
<td>
<p>A positive double. This parameter defines the interval used in
the Metropolis-Hastings algorithm to sample proposals for gamma. See
details.</p>
</td></tr>
<tr><td><code id="BSBHaz_+3A_theta_d">theta_d</code></td>
<td>
<p>A positive double. This parameter defines the interval used in
the Metropolis-Hastings algorithm to sample proposals for theta. See
details.</p>
</td></tr>
<tr><td><code id="BSBHaz_+3A_seed">seed</code></td>
<td>
<p>Random seed used in sampling.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>BSBHaz (Nieto-Barajas &amp; Walker, 2007) is a bayesian semiparametric model for
bivariate survival data. The marginal densities are nonparametric survival
models and the joint density is constructed via a mixture. Dependence between
failure times is modeled using two frailties, and the dependence between
these frailties is modeled with a copula.
</p>
<p>This command obtains posterior samples from model parameters. The samples
from omega, gamma, and theta are obtained using the Metropolis-Hastings
algorithm. The proposal distributions are uniform for the three parameters.
The parameters <code>omega_d</code>, <code>gamma_d</code> and <code>theta_d</code> modify the
intervals from which the uniform proposals are sampled. If these parameters
are too large, the acceptance rates will decrease and the chains will get
stuck. On the other hand, if these parameters are small, the acceptance rates
will be too high and the chains will not explore the posterior support
effectively.
</p>


<h3>Value</h3>

<p>An object of class '<code>BSBHaz</code>' containing the samples from the
variables of interest.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>t1 &lt;- survival::Surv(c(1, 2, 3))
t2 &lt;- survival::Surv(c(1, 2, 3))

init &lt;- BSBInit(t1 = t1, t2 = t2, seed = 0)
samples &lt;- BSBHaz(init, iter = 10, omega_d = 2,
gamma_d = 10, seed = 10)
</code></pre>

<hr>
<h2 id='BSBInit'>Initial setup for BSBHaz model</h2><span id='topic+BSBInit'></span>

<h3>Description</h3>

<p><code>BSBInit</code> creates the necessary data structure for use in
<code><a href="#topic+BSBHaz">BSBHaz</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BSBInit(
  df = NULL,
  t1 = NULL,
  t2 = NULL,
  alpha = 0.001,
  beta = 0.001,
  c = 1000,
  part_len = 1,
  seed = 42
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BSBInit_+3A_df">df</code></td>
<td>
<p>A data frame with columns 't1', 't2', 'delta1', 'delta2'. Any other
columns not named 'id' are taken to be predictors. These predictors must be
numeric, i.e., <strong>categorical predictors must be one-hot encoded</strong>.</p>
</td></tr>
<tr><td><code id="BSBInit_+3A_t1">t1</code>, <code id="BSBInit_+3A_t2">t2</code></td>
<td>
<p>Objects of class 'Surv' as created by
<code><a href="survival.html#topic+Surv">Surv</a></code>.</p>
</td></tr>
<tr><td><code id="BSBInit_+3A_alpha">alpha</code>, <code id="BSBInit_+3A_beta">beta</code>, <code id="BSBInit_+3A_c">c</code></td>
<td>
<p>Doubles. Parameters for Markov gamma hazard priors.</p>
</td></tr>
<tr><td><code id="BSBInit_+3A_part_len">part_len</code></td>
<td>
<p>A double that gives the length of time partition intervals.</p>
</td></tr>
<tr><td><code id="BSBInit_+3A_seed">seed</code></td>
<td>
<p>Random seed for variable initialization.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function reads and formats censored bivariate survival data in the
following way. If <code>df</code> is provided, failure times and censoring
indicadors are assumed to be columns named 't1', 't2', 'delta1', and
'delta2'. Other columns not named 'id' (ignoring case) are taken to be
predictors. If <code>df</code> has no columns 'delta1' or 'delta2', observations
are taken as exact.
</p>
<p>If <code>df</code> is not provided, then <code>t1</code> and <code>t2</code> are expected to be
objects of class 'Surv' created by <code><a href="survival.html#topic+Surv">Surv</a></code> and the model
does not use predictors. Only right-censored observations are supported. Only
<code>df</code> or <code>t1</code> and <code>t2</code> must be supplied. <code>df</code> argument
comes first for use in pipes.
</p>


<h3>Value</h3>

<p>An object of class '<code>BSBinit</code>'
</p>


<h3>Examples</h3>

<pre><code class='language-R'>t1 &lt;- survival::Surv(c(1, 2, 3))
t2 &lt;- survival::Surv(c(1, 2, 3))

init &lt;- BSBInit(t1 = t1, t2 = t2, seed = 0)

</code></pre>

<hr>
<h2 id='BSBPlotDiag'>Plot diagnostics for BSBHaz model</h2><span id='topic+BSBPlotDiag'></span>

<h3>Description</h3>

<p>Plot diagnostics for BSBHaz model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BSBPlotDiag(
  bsbhaz,
  variable = c("omega1", "omega2", "lambda1", "lambda2", "gamma", "theta"),
  type = c("traceplot", "ergodic_means")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BSBPlotDiag_+3A_bsbhaz">bsbhaz</code></td>
<td>
<p>An object of class 'BSBHaz' created by
<code><a href="#topic+BSBHaz">BSBHaz</a></code>.</p>
</td></tr>
<tr><td><code id="BSBPlotDiag_+3A_variable">variable</code></td>
<td>
<p>A character indicating which variable to get the plot from.</p>
</td></tr>
<tr><td><code id="BSBPlotDiag_+3A_type">type</code></td>
<td>
<p>A character indicating if the plot should be a traceplot or plot
the ergodic means.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>t1 &lt;- survival::Surv(c(1, 2, 3))
t2 &lt;- survival::Surv(c(1, 2, 3))

init &lt;- BSBInit(t1 = t1, t2 = t2, seed = 0)
samples &lt;- BSBHaz(init, iter = 10, omega_d = 2,
gamma_d = 10, seed = 10)

BSBPlotDiag(samples, variable = "omega1", type = "traceplot")

</code></pre>

<hr>
<h2 id='BSBPlotSumm'>Plot summaries for BSBHaz model</h2><span id='topic+BSBPlotSumm'></span>

<h3>Description</h3>

<p>Plot summaries for BSBHaz model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BSBPlotSumm(bsbhaz, variable = c("lambda1", "lambda2", "s1", "s2"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BSBPlotSumm_+3A_bsbhaz">bsbhaz</code></td>
<td>
<p>An object of class 'BSBHaz' created by
<code><a href="#topic+BSBHaz">BSBHaz</a></code>.</p>
</td></tr>
<tr><td><code id="BSBPlotSumm_+3A_variable">variable</code></td>
<td>
<p>A character indicating the variable to plot.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>t1 &lt;- survival::Surv(c(1, 2, 3))
t2 &lt;- survival::Surv(c(1, 2, 3))

init &lt;- BSBInit(t1 = t1, t2 = t2, seed = 0)
samples &lt;- BSBHaz(init, iter = 10, omega_d = 2,
gamma_d = 10, seed = 10)

BSBPlotSumm(samples, "s1")
</code></pre>

<hr>
<h2 id='BSBSumm'>Get posterior summaries for BSBHaz model</h2><span id='topic+BSBSumm'></span>

<h3>Description</h3>

<p>Get posterior summaries for BSBHaz model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BSBSumm(
  bsbhaz,
  variable = c("omega1", "omega2", "lambda1", "lambda2", "gamma", "theta", "s1", "s2")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BSBSumm_+3A_bsbhaz">bsbhaz</code></td>
<td>
<p>An object of class 'BSBHaz' created by
<code><a href="#topic+BSBHaz">BSBHaz</a></code>.</p>
</td></tr>
<tr><td><code id="BSBSumm_+3A_variable">variable</code></td>
<td>
<p>A character indicating which variable to get summaries from.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with posterior sample means and a 95 % probability
interval. For <code>omega1</code>, <code>omega2</code>, <code>gamma</code>, and <code>theta</code>
also includes a column with the acceptance rates for the
Metropolis-Hastings algorithm.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>t1 &lt;- survival::Surv(c(1, 2, 3))
t2 &lt;- survival::Surv(c(1, 2, 3))

init &lt;- BSBInit(t1 = t1, t2 = t2, seed = 0)
samples &lt;- BSBHaz(init, iter = 10, omega_d = 2,
gamma_d = 10, seed = 10)

BSBSumm(samples, variable = "gamma")
BSBSumm(samples, variable = "omega1")
BSBSumm(samples, variable = "lambda1")
</code></pre>

<hr>
<h2 id='CCuMRes'>Bayesian Semiparametric Cure Rate Model with an Unknown Threshold and
Covariate Information</h2><span id='topic+CCuMRes'></span>

<h3>Description</h3>

<p>Posterior inference for the bayesian semiparmetric cure rate model with
covariates in survival analysis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CCuMRes(
  data,
  covs.x = names(data)[seq.int(3, ncol(data))],
  covs.y = names(data)[seq.int(3, ncol(data))],
  type.t = 3,
  K = 50,
  utao = NULL,
  alpha = rep(0.01, K),
  beta = rep(0.01, K),
  c.r = rep(0, K - 1),
  c.nu = 1,
  var.theta.str = 25,
  var.delta.str = 25,
  var.theta.ini = 100,
  var.delta.ini = 100,
  type.c = 4,
  a.eps = 0.1,
  b.eps = 0.1,
  epsilon = 1,
  iterations = 5000,
  burn.in = floor(iterations * 0.2),
  thinning = 3,
  printtime = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CCuMRes_+3A_data">data</code></td>
<td>
<p>Double tibble. Contains failure times in the first column,
status indicator in the second, and, from the third to the last column, the
covariate(s).</p>
</td></tr>
<tr><td><code id="CCuMRes_+3A_covs.x">covs.x</code></td>
<td>
<p>Character. Names of covariables to be part of the
multiplicative part of the hazard</p>
</td></tr>
<tr><td><code id="CCuMRes_+3A_covs.y">covs.y</code></td>
<td>
<p>Character. Names of covariables to determine the cure
threshold por each patient.</p>
</td></tr>
<tr><td><code id="CCuMRes_+3A_type.t">type.t</code></td>
<td>
<p>Integer. 1=computes uniformly-dense intervals; 2=
partition arbitrarily defined by the user with parameter utao and 3=same length intervals.</p>
</td></tr>
<tr><td><code id="CCuMRes_+3A_k">K</code></td>
<td>
<p>Integer. Partition length for the hazard function.</p>
</td></tr>
<tr><td><code id="CCuMRes_+3A_utao">utao</code></td>
<td>
<p>vector. Partition specified by the user when type.t = 2. The first value of 
the vector has to be 0 and the last one the maximum observed time, either censored or uncensored.</p>
</td></tr>
<tr><td><code id="CCuMRes_+3A_alpha">alpha</code></td>
<td>
<p>Nonnegative entry vector. Small entries are recommended in
order to specify a non-informative prior distribution.</p>
</td></tr>
<tr><td><code id="CCuMRes_+3A_beta">beta</code></td>
<td>
<p>Nonnegative entry vector. Small entries are recommended in order
to specify a non-informative prior distribution.</p>
</td></tr>
<tr><td><code id="CCuMRes_+3A_c.r">c.r</code></td>
<td>
<p>Nonnegative vector. The higher the entries, the higher the correlation of two consective intervals.</p>
</td></tr>
<tr><td><code id="CCuMRes_+3A_c.nu">c.nu</code></td>
<td>
<p>Tuning parameter for the proposal distribution for c. 
Only when <code>type.c</code> is 3 or 4.</p>
</td></tr>
<tr><td><code id="CCuMRes_+3A_var.theta.str">var.theta.str</code></td>
<td>
<p>Double. Variance of the proposal normal distribution
for theta in the Metropolis-Hastings step.</p>
</td></tr>
<tr><td><code id="CCuMRes_+3A_var.delta.str">var.delta.str</code></td>
<td>
<p>Double. Variance of the proposal normal distribution
for delta in the Metropolis-Hastings step.</p>
</td></tr>
<tr><td><code id="CCuMRes_+3A_var.theta.ini">var.theta.ini</code></td>
<td>
<p>Double. Variance of the prior normal distribution for theta.</p>
</td></tr>
<tr><td><code id="CCuMRes_+3A_var.delta.ini">var.delta.ini</code></td>
<td>
<p>Double. Variance of the prior normal distribution for delta.
from the acceptance ratio in the Metropolis-Hastings algorithm for delta*.</p>
</td></tr>
<tr><td><code id="CCuMRes_+3A_type.c">type.c</code></td>
<td>
<p>1=defines <code>c.r</code> as a zero-entry vector; 2=lets the user
define <code>c.r</code> freely; 3=assigns <code>c.r</code> an exponential prior
distribution with mean 1; 4=assigns <code>c.r</code> an exponential hierarchical 
distribution with mean <code>epsilon</code> which in turn has a Ga(a.eps, b.eps)
distribution.</p>
</td></tr>
<tr><td><code id="CCuMRes_+3A_a.eps">a.eps</code></td>
<td>
<p>Double. Shape parameter for the prior gamma distribution of
epsilon when <code>type.c = 4</code>.</p>
</td></tr>
<tr><td><code id="CCuMRes_+3A_b.eps">b.eps</code></td>
<td>
<p>Double. Scale parameter for the prior gamma distribution of
epsilon when <code>type.c = 4</code>.</p>
</td></tr>
<tr><td><code id="CCuMRes_+3A_epsilon">epsilon</code></td>
<td>
<p>Double. Mean of the exponencial distribution assigned to
<code>c.r</code> when <code>type.c = 3</code>.</p>
</td></tr>
<tr><td><code id="CCuMRes_+3A_iterations">iterations</code></td>
<td>
<p>Integer. Number of iterations including the <code>burn.in</code>
to be computed for the Markov chain.</p>
</td></tr>
<tr><td><code id="CCuMRes_+3A_burn.in">burn.in</code></td>
<td>
<p>Integer. Length of the burn-in period for the Markov chain.</p>
</td></tr>
<tr><td><code id="CCuMRes_+3A_thinning">thinning</code></td>
<td>
<p>Integer. Factor by which the chain will be thinned. Thinning
the Markov chain reduces autocorrelation.</p>
</td></tr>
<tr><td><code id="CCuMRes_+3A_printtime">printtime</code></td>
<td>
<p>Logical. If <code>TRUE</code>, prints out the execution time.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Computes the Gibbs sampler with the full conditional distributions of
all model parameters (Nieto-Barajas &amp; Yin, 2008) and arranges the resulting Markov
chain into a tibble which can be used to obtain posterior summaries. Prior
distributions for the regression coefficients Theta and Delta are assumend
independent normals with zero mean and variance <code>var.theta.ini</code>,
<code>var.delta.ini</code>, respectively.
</p>


<h3>Note</h3>

<p>It is recommended to verify chain's stationarity. This can be done by
checking each element individually. See <code><a href="#topic+CCuPlotDiag">CCuPlotDiag</a></code>.
</p>


<h3>References</h3>

<p>- Nieto-Barajas, L. E., &amp; Yin, G. (2008). Bayesian
semiparametric cure rate model with an unknown threshold. Scandinavian
Journal of Statistics, 35(3), 540-556.
https://doi.org/10.1111/j.1467-9469.2007.00589.x
</p>
<p>- Nieto-barajas, L. E. (2002). Discrete time Markov gamma processes and time
dependent covariates in survival analysis. Statistics, 2-5.
</p>


<h3>See Also</h3>

<p><a href="#topic+CCuPlotDiag">CCuPlotDiag</a>, <a href="#topic+CCuPloth">CCuPloth</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>


# data(BMTKleinbook)
    # res &lt;- CCuMRes(BMTKleinbook, covs.x = c("tTransplant","hodgkin","karnofsky","waiting"),
    #                covs.y = c("tTransplant","hodgkin","karnofsky","waiting"),
    #                        type.t = 2, K = 72, length = 30,
    #                        alpha = rep(2,72), beta = rep(2,72), c.r = rep(50, 71), type.c = 2,
    #                        var.delta.str = .1, var.theta.str = 1,
    #                        var.delta.ini = 100, var.theta.ini = 100,
    #                        iterations = 100, burn.in = 10, thinning = 1)



</code></pre>

<hr>
<h2 id='CCuPlotDiag'>Diagnostics plots for Lambda, Theta, Delta,
U, C, Pi, Z and Epsilon. Hazard function, cure proportion and cure time for the median observation.</h2><span id='topic+CCuPlotDiag'></span>

<h3>Description</h3>

<p>Diagnostic plots for hazard rate (Lambda), regression parameters for the
hazard (Theta), regression parameters for the cure rate (Delta), latent
variable (U), dependence parameter (C), mean of cure threshold (Mu), 
cure proportion (Pi), cure threshold (Z) and the
parameter of the hierarchical prior (Epsilon).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CCuPlotDiag(M, variable = "Lambda", pos = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CCuPlotDiag_+3A_m">M</code></td>
<td>
<p>tibble. Contains the output by
<code>CCuMRes</code>.</p>
</td></tr>
<tr><td><code id="CCuPlotDiag_+3A_variable">variable</code></td>
<td>
<p>Either &quot;Lambda&quot;, &quot;U&quot;, &quot;C&quot;, &quot;Mu&quot;, &quot;Pi&quot;, &quot;Z&quot; or &quot;Epsilon&quot;.
Variable for which diagnostic plot will be shown.</p>
</td></tr>
<tr><td><code id="CCuPlotDiag_+3A_pos">pos</code></td>
<td>
<p>Positive integer. Position of the selected <code>variable</code> to be
plotted.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function returns a diagnosyics plot for which the chain for the selected
variable can be monitored. Diagnostics includes trace, ergodic mean,
autocorrelation function and histogram.
</p>


<h3>References</h3>

<p>Nieto-Barajas, L. E., &amp; Yin, G. (2008). Bayesian semiparametric
cure rate model with an unknown threshold. <em>Scandinavian Journal of
Statistics</em>, <strong>35(3)</strong>, 540-556.
https://doi.org/10.1111/j.1467-9469.2007.00589.x
</p>


<h3>See Also</h3>

<p><a href="#topic+CCuMRes">CCuMRes</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>


## Simulations may be time intensive. Be patient.

## Example 1
# data(BMTKleinbook)
# res &lt;- CCuMRes(BMTKleinbook, covs.x = c("tTransplant","hodgkin","karnofsky","waiting"),
#                covs.y = c("tTransplant","hodgkin","karnofsky","waiting"),
#                        type.t = 2, K = 72, length = 30,
#                        alpha = rep(2,72), beta = rep(2,72), c.r = rep(50, 71), type.c = 2,
#                        var.delta.str = .1, var.theta.str = 1,
#                        var.delta.ini = 100, var.theta.ini = 100,
#                        iterations = 100, burn.in = 10, thinning = 1)
# CCuPlotDiag(M = res, variable = "Z")
# CCuPlotDiag(M = res, variable = "Pi.m")
# CCuPlotDiag(M = res, variable = "Lambda", pos = 2)
# CCuPlotDiag(M = res, variable = "U", pos = 4)




</code></pre>

<hr>
<h2 id='CCuPloth'>Plots for the Hazard and Survival Funcion Estimates</h2><span id='topic+CCuPloth'></span>

<h3>Description</h3>

<p>Plots the resulting hazard function and the survival function
estimates defined by the bayesian semiparametric cure rate model with 
an unknown threshold (Nieto-Barajas &amp; Yin, 2008).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CCuPloth(
  M,
  new_obs = NULL,
  type.h = "segment",
  qn = 0.5,
  intervals = T,
  confidence = 0.95,
  summary = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CCuPloth_+3A_m">M</code></td>
<td>
<p>tibble. Contains the output generated by <code>CuMRres</code>.</p>
</td></tr>
<tr><td><code id="CCuPloth_+3A_new_obs">new_obs</code></td>
<td>
<p>tibble. Contains the covariate information for new observations.</p>
</td></tr>
<tr><td><code id="CCuPloth_+3A_type.h">type.h</code></td>
<td>
<p>character. &quot;segment&quot;= use segments to plot hazard rates,
&quot;line&quot; = link hazard rates by a line</p>
</td></tr>
<tr><td><code id="CCuPloth_+3A_qn">qn</code></td>
<td>
<p>Numeric. Quantile for Tao (cure time) that should be visualized on the plot.</p>
</td></tr>
<tr><td><code id="CCuPloth_+3A_intervals">intervals</code></td>
<td>
<p>logical. If TRUE, plots credible intervals.</p>
</td></tr>
<tr><td><code id="CCuPloth_+3A_confidence">confidence</code></td>
<td>
<p>Numeric. Confidence level.</p>
</td></tr>
<tr><td><code id="CCuPloth_+3A_summary">summary</code></td>
<td>
<p>Logical. If <code>TRUE</code>, a summary for the hazard and survival
functions is returned as a tibble.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function returns estimators plots for the hazard rate as it is computed
by <a href="#topic+CCuMRes">CCuMRes</a> and the cure time (quantile of Tao specified by the user)
together with credible intervals. Additionally, it plots the survival function 
and the cure proportion estimates with their corresponding credible intervals.
</p>


<h3>Value</h3>

<table>
<tr><td><code>SUM.h</code></td>
<td>
<p>Numeric tibble. Summary for the mean, median, and a
<code>confint / 100</code> confidence interval for each segment of the hazard
function. If <code>summary = TRUE</code></p>
</td></tr> <tr><td><code>SUM.S</code></td>
<td>
<p>Numeric tibble. Summary for
the mean, median, and a <code>confint / 100</code> confidence interval for each
segment of the survival function. If <code>summary = TRUE</code></p>
</td></tr>
</table>


<h3>References</h3>

<p>- Nieto-Barajas, L. E. (2003). Discrete time Markov gamma
processes and time dependent covariates in survival analysis. <em>Bulletin
of the International Statistical Institute 54th Session</em>. Berlin. (CD-ROM).
</p>
<p>-Nieto-Barajas, L. E., &amp; Yin, G. (2008). Bayesian semiparametric cure rate
model with an unknown threshold. <em>Scandinavian Journal of Statistics</em>,
<strong>35(3)</strong>, 540-556. https://doi.org/10.1111/j.1467-9469.2007.00589.x
</p>


<h3>See Also</h3>

<p><a href="#topic+CCuMRes">CCuMRes</a>,
</p>


<h3>Examples</h3>

<pre><code class='language-R'>


## Simulations may be time intensive. Be patient.

## Example 1
# data(BMTKleinbook)
    # res &lt;- CCuMRes(BMTKleinbook, covs.x = c("tTransplant","hodgkin","karnofsky","waiting"),
    #                covs.y = c("tTransplant","hodgkin","karnofsky","waiting"),
    #                        type.t = 2, K = 72, length = 30,
    #                        alpha = rep(2,72), beta = rep(2,72), c.r = rep(50, 71), type.c = 2,
    #                        var.delta.str = .1, var.theta.str = 1,
    #                        var.delta.ini = 100, var.theta.ini = 100,
    #                        iterations = 100, burn.in = 10, thinning = 1)
    # 
    # CCuPloth(res, type.h = "segment",qn=.5, summary = T)
    # 
    # new_obs &lt;- tibble(tTransplant=c(0,0,0,0),
    #                       hodgkin=c(0,1,0,1),
    #                       karnofsky=c(90,90,60,60),
    #                       waiting=c(36,36,36,36)
    # )
    # 
    # ind &lt;- CCuPloth(res, new_obs, qn = .5)
    # ind



</code></pre>

<hr>
<h2 id='CGaMRes'>Markov Gamma Model with Covariates</h2><span id='topic+CGaMRes'></span>

<h3>Description</h3>

<p>Posterior inference for the Bayesian non-parametric Markov gamma model with
covariates in survival analysis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CGaMRes(
  data,
  type.t = 2,
  length = 1,
  K = 5,
  alpha = rep(0.01, K),
  beta = rep(0.01, K),
  c.r = rep(1, K - 1),
  c.nu = 1,
  var.theta.str = 25,
  var.theta.ini = 100,
  a.eps = 0.1,
  b.eps = 0.1,
  type.c = 4,
  epsilon = 1,
  iterations = 1000,
  burn.in = floor(iterations * 0.2),
  thinning = 3,
  printtime = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CGaMRes_+3A_data">data</code></td>
<td>
<p>Double tibble. Contains failure times in the first column,
status indicator in the second, and, from the third to the last column, the
covariate(s).</p>
</td></tr>
<tr><td><code id="CGaMRes_+3A_type.t">type.t</code></td>
<td>
<p>Integer. 1=computes uniformly-dense intervals; 2=length
intervals defined by user and 3=same length intervals.</p>
</td></tr>
<tr><td><code id="CGaMRes_+3A_length">length</code></td>
<td>
<p>Integer. Interval length of the partition.</p>
</td></tr>
<tr><td><code id="CGaMRes_+3A_k">K</code></td>
<td>
<p>Integer. Partition length for the hazard function.</p>
</td></tr>
<tr><td><code id="CGaMRes_+3A_alpha">alpha</code></td>
<td>
<p>Nonnegative entry vector. Small entries are recommended in
order to specify a non-informative prior distribution.</p>
</td></tr>
<tr><td><code id="CGaMRes_+3A_beta">beta</code></td>
<td>
<p>Nonnegative entry vector. Small entries are recommended in order
to specify a non-informative prior distribution.</p>
</td></tr>
<tr><td><code id="CGaMRes_+3A_c.r">c.r</code></td>
<td>
<p>Nonnegative vector. The higher the entries, the higher the correlation of 
two consecutive intervals.</p>
</td></tr>
<tr><td><code id="CGaMRes_+3A_c.nu">c.nu</code></td>
<td>
<p>Tuning parameter for the proposal distribution for c.</p>
</td></tr>
<tr><td><code id="CGaMRes_+3A_var.theta.str">var.theta.str</code></td>
<td>
<p>Double. Variance of the proposal normal distribution
for theta in the Metropolis-Hastings step.</p>
</td></tr>
<tr><td><code id="CGaMRes_+3A_var.theta.ini">var.theta.ini</code></td>
<td>
<p>Double. Variance of the prior normal distribution for theta.</p>
</td></tr>
<tr><td><code id="CGaMRes_+3A_a.eps">a.eps</code></td>
<td>
<p>Double. Shape parameter for the prior gamma distribution of
epsilon when <code>type.c = 4</code>.</p>
</td></tr>
<tr><td><code id="CGaMRes_+3A_b.eps">b.eps</code></td>
<td>
<p>Double. Scale parameter for the prior gamma distribution of
epsilon when <code>type.c = 4</code>.</p>
</td></tr>
<tr><td><code id="CGaMRes_+3A_type.c">type.c</code></td>
<td>
<p>1=defines <code>c.r</code> as a zero-entry vector; 2=lets the user
define <code>c.r</code> freely; 3=assigns <code>c.r</code> by computing an exponential
prior distribution with mean 1; 4=assigns <code>c.r</code> an exponential hierarchical
distribution with mean <code>epsilon</code> which in turn has a Ga(a.eps, b.eps)
distribution.</p>
</td></tr>
<tr><td><code id="CGaMRes_+3A_epsilon">epsilon</code></td>
<td>
<p>Double. Mean of the exponential distribution assigned to
<code>c.r</code> when <code>type.c = 3</code>.</p>
</td></tr>
<tr><td><code id="CGaMRes_+3A_iterations">iterations</code></td>
<td>
<p>Integer. Number of iterations including the <code>burn.in</code>
to be computed for the Markov chain.</p>
</td></tr>
<tr><td><code id="CGaMRes_+3A_burn.in">burn.in</code></td>
<td>
<p>Integer. Length of the burn-in period for the Markov chain.</p>
</td></tr>
<tr><td><code id="CGaMRes_+3A_thinning">thinning</code></td>
<td>
<p>Integer. Factor by which the chain will be thinned. Thinning
the Markov chain reduces autocorrelation.</p>
</td></tr>
<tr><td><code id="CGaMRes_+3A_printtime">printtime</code></td>
<td>
<p>Logical. If <code>TRUE</code>, prints out the execution time.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Computes the Gibbs sampler with the full conditional distributions of
Lambda and Theta (Nieto-Barajas, 2003) and arranges the resulting Markov
chain into a matrix which can be used to obtain posterior summaries. Prior
distributions for the re gression coefficients (Theta) are assumed independent normals
with zero mean and variance <code>var.theta.ini</code>.
</p>


<h3>Note</h3>

<p>It is recommended to verify chain's stationarity. This can be done by
checking each element individually. See <a href="#topic+CGaPlotDiag">CGaPlotDiag</a>
To obtain posterior summaries of the coefficients use function
<a href="#topic+CGaPloth">CGaPloth</a>.
</p>


<h3>References</h3>

<p>- Nieto-Barajas, L. E. (2003). Discrete time Markov gamma
processes and time dependent covariates in survival analysis. <em>Bulletin
of the International Statistical Institute 54th Session</em>. Berlin. (CD-ROM).
</p>
<p>- Nieto-Barajas, L. E. &amp; Walker, S. G. (2002). Markov beta and gamma
processes for modelling hazard rates. <em>Scandinavian Journal of
Statistics</em> <strong>29</strong>: 413-424.
</p>


<h3>See Also</h3>

<p><a href="#topic+CGaPlotDiag">CGaPlotDiag</a>, <a href="#topic+CGaPloth">CGaPloth</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>


## Simulations may be time intensive. Be patient.

## Example 1
#  data(leukemiaFZ)
#  leukemia1 &lt;- leukemiaFZ
#  leukemia1$wbc &lt;- log(leukemiaFZ$wbc)
#  CGEX1 &lt;- CGaMRes(data = leukemia1, K = 10, iterations = 100, thinning = 1)

## Example 2. Refer to "Cox-gamma model example" section in package vignette for details.
# SampWeibull &lt;- function(n, a = 10, b = 1, beta = c(1, 1)) {
#   M &lt;- tibble(i = seq(n), x_i1 = runif(n), x_i2 = runif(n), 
#               t_i = rweibull(n, shape = b, 
#                                 scale = 1 / (a * exp(x_i1*beta[1] + x_i2*beta[2]))),
#               c_i = rexp(n), delta = t_i &gt; c_i,
#               `min{c_i, d_i}` = min(t_i, c_i))
#   return(M)
# }
#  dat &lt;- SampWeibull(100, 0.1, 1, c(1, 1))
#  dat &lt;- dat %&gt;% select(4,6,2,3) 
#  CG &lt;- CGaMRes(data = leukemia1, K = 10, iterations = 100, thinning = 1)
#  CGaPloth(CG)



</code></pre>

<hr>
<h2 id='CGaPlotDiag'>Diagnostics plots for lambda, U, C, Epsilon and Theta</h2><span id='topic+CGaPlotDiag'></span>

<h3>Description</h3>

<p>Diagnostics plots for hazard rate (Lambda), latent variable (U), dependence
variable (C), parameter of the hierarchical model (Epsilon) and regression
coefficients (Theta).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CGaPlotDiag(M, variable = "Lambda", pos = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CGaPlotDiag_+3A_m">M</code></td>
<td>
<p>Tibble. Contains the output by <code>CGaMRes</code></p>
</td></tr>
<tr><td><code id="CGaPlotDiag_+3A_variable">variable</code></td>
<td>
<p>Either &quot;Lambda&quot;, &quot;U&quot;, &quot;C&quot;, &quot;Epsilon&quot; or &quot;Theta&quot;. Variable
for which diagnostics plot will be shown.</p>
</td></tr>
<tr><td><code id="CGaPlotDiag_+3A_pos">pos</code></td>
<td>
<p>Positive integer. Position of the selected <code>variable</code> to be
plotted.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function returns a diagnostics plot for the chain of the selected
variable. The diagnostics includes trace, ergodic mean, autocorrelation
function and histogram.
</p>


<h3>References</h3>

<p>- Nieto-Barajas, L. E. (2003). Discrete time Markov gamma
processes and time dependent covariates in survival analysis. <em>Bulletin
of the International Statistical Institute 54th Session</em>. Berlin. (CD-ROM).
</p>
<p>- Nieto-Barajas, L. E. &amp; Walker, S. G. (2002). Markov beta and gamma
processes for modelling hazard rates. <em>Scandinavian Journal of
Statistics</em> <strong>29</strong>: 413-424.
</p>


<h3>See Also</h3>

<p><a href="#topic+CGaMRes">CGaMRes</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

 
## Simulations may be time intensive. Be patient.

## Example 1
#  data(leukemiaFZ)
#  leukemia1 &lt;- leukemiaFZ
#  leukemia1$wbc &lt;- log(leukemiaFZ$wbc)
#  CGEX1 &lt;- CGaMRes(data = leukemia1, K = 10, iterations = 1000, thinning = 1)
#  CGaPlotDiag(CGEX1,variable="Theta",pos=1)



</code></pre>

<hr>
<h2 id='CGaPloth'>Plots for the Hazard and Survival Funcion Estimates for the Bayesian
non-parametric Markov gamma model with covariates in survival analysis.</h2><span id='topic+CGaPloth'></span>

<h3>Description</h3>

<p>Plots the resulting hazard function along with the survival function
estimate defined by the Markov gamma process with covariates (Nieto-Barajas,
2003).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CGaPloth(
  M,
  new_obs = NULL,
  type.h = "segment",
  coxSurv = T,
  intervals = T,
  confidence = 0.95,
  summary = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CGaPloth_+3A_m">M</code></td>
<td>
<p>tibble. Contains the output generated by <code>CuMRres</code>.</p>
</td></tr>
<tr><td><code id="CGaPloth_+3A_new_obs">new_obs</code></td>
<td>
<p>tibble. The function calculates the hazard rates and survival
function estimates for specific individuals expressed in a tibble, the names of the
columns have to be the same as the data input.</p>
</td></tr>
<tr><td><code id="CGaPloth_+3A_type.h">type.h</code></td>
<td>
<p>character. &quot;segment&quot;= use segments to plot hazard rates,
&quot;line&quot; = link hazard rates by a line</p>
</td></tr>
<tr><td><code id="CGaPloth_+3A_coxsurv">coxSurv</code></td>
<td>
<p>logical. Add estimated Survival function with the Cox-Model</p>
</td></tr>
<tr><td><code id="CGaPloth_+3A_intervals">intervals</code></td>
<td>
<p>logical. If TRUE, plots confidence bands for the selected functions including Cox-Model.</p>
</td></tr>
<tr><td><code id="CGaPloth_+3A_confidence">confidence</code></td>
<td>
<p>Numeric. Confidence level.</p>
</td></tr>
<tr><td><code id="CGaPloth_+3A_summary">summary</code></td>
<td>
<p>logical. If <code>TRUE</code>, a summary for hazard and survival
functions is returned as a tibble.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function return plots for the resulting hazard rate as it is computed
by <code><a href="#topic+CGaMRes">CGaMRes</a> and the quantile of Tao specified by the user aswell
as an annotation</code>. In the same plot the credible intervals for both
variables are plotted; The mean of Pi is also annotated. Additionally, it
plots the survival function with their corresponding credible intervals.
</p>


<h3>Value</h3>

<table>
<tr><td><code>SUM.h</code></td>
<td>
<p>Numeric tibble. Summary for the mean, median, and a
<code>confint / 100</code> confidence interval for each segment of the hazard
function. If <code>summary = TRUE</code></p>
</td></tr> <tr><td><code>SUM.S</code></td>
<td>
<p>Numeric tibble. Summary for
the mean, median, and a <code>confint / 100</code> confidence interval for each
segment of the survival function. If <code>summary = TRUE</code></p>
</td></tr>
</table>


<h3>References</h3>

<p>- Nieto-Barajas, L. E. (2003). Discrete time Markov gamma
processes and time dependent covariates in survival analysis. <em>Bulletin
of the International Statistical Institute 54th Session</em>. Berlin. (CD-ROM).
</p>
<p>- Nieto-Barajas, L. E. &amp; Walker, S. G. (2002). Markov beta and gamma
processes for modelling hazard rates. <em>Scandinavian Journal of
Statistics</em> <strong>29</strong>: 413-424.
</p>


<h3>See Also</h3>

<p><a href="#topic+CGaMRes">CGaMRes</a>,
</p>


<h3>Examples</h3>

<pre><code class='language-R'>


## Simulations may be time intensive. Be patient.

   # ## Example 1
   #  data(leukemiaFZ)
   #  leukemia1 &lt;- leukemiaFZ
   #  leukemia1$wbc &lt;- log(leukemiaFZ$wbc)
   #  CGEX1 &lt;- CGaMRes(data = leukemia1, K = 10, iterations = 100, thinning = 1)
   #  CGaPloth(CGEX1)



</code></pre>

<hr>
<h2 id='cpo'>Conditional Predictive Ordinate (CPO) Statistic</h2><span id='topic+cpo'></span>

<h3>Description</h3>

<p>Makes the CPO Plot and calculates the logarithm of the Pseudomarginal
likelihood (LPML).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cpo(res)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cpo_+3A_res">res</code></td>
<td>
<p>tibble. The output from the *Res functions, where * could either
be BeM, GaM, CGaM, CuM, CCuM</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Computes de CPO as a goodness of fit measure
</p>


<h3>Value</h3>

<table>
<tr><td><code>LPML</code></td>
<td>
<p>The value of the logarithm of the Pseudomarginal likelihood</p>
</td></tr>
<tr><td><code>plot</code></td>
<td>
<p>CPO Plot</p>
</td></tr> 
</table>


<h3>References</h3>

<p>See Geisser (1993); Gelfand, Dey, and Chang (1992); Dey, Chen,
and Chang (1997); and Sinha and Dey (1997)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>


## Example 1
#  data(gehan)
#  timesG &lt;- gehan$time[gehan$treat == "6-MP"]
#  deltaG &lt;- gehan$cens[gehan$treat == "6-MP"]
#  GEX1 &lt;- GaMRes(timesG, deltaG, K = 8, iterations = 3000)
#  cpo(GEX1)



</code></pre>

<hr>
<h2 id='crm3'>
Simulated data from the proportional hazards cure rate model of Yakolev &amp; Tsodikov (1996) by taking a baseline density with a bounded support.
</h2><span id='topic+crm3'></span>

<h3>Description</h3>

<p>Triangular distribution Tri(a, c, b) as the baseline density, which puts a probability of one to the interval [a, b] and the mode at c. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("crm3")</code></pre>


<h3>Format</h3>

<p>A data frame with 100 observations with the following 2 variables.
</p>

<dl>
<dt><code>times</code></dt><dd><p>Simulated time</p>
</dd>
<dt><code>delta</code></dt><dd><p>Simulated censoring</p>
</dd>
</dl>



<h3>Details</h3>

<p>In particular we took, a = 0, c = 1 and b = 4. The censoring time was independently generated from a uniform distribution to yield a 30% censoring rate. Sample size n = 100 and the cure proportion exp{-theta}=0.2.
</p>


<h3>Source</h3>

<p>Nieto-Barajas, L. E., &amp; Yin, G. (2008)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Cure Gama model Example 1
# data(crm3)
# times&lt;-crm3$times
# delta&lt;-crm3$delta
# res &lt;- CuMRes(times, delta, type.t = 2, 
#                   K = 100, length = .1, alpha = rep(1, 100  ), 
#                   beta = rep(1, 100),c.r = rep(50, 99), 
#                   iterations = 100, burn.in = 10, thinning = 1, type.c = 2)
</code></pre>

<hr>
<h2 id='CuMRes'>Bayesian Semiparametric Cure Rate Model with an Unknown Threshold</h2><span id='topic+CuMRes'></span>

<h3>Description</h3>

<p>Posterior inference for the bayesian semiparametric cure rate model in
survival analysis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CuMRes(
  times,
  delta = rep(1, length(times)),
  type.t = 3,
  K = 5,
  utao = NULL,
  alpha = rep(0.01, K),
  beta = rep(0.01, K),
  c.r = rep(1, (K - 1)),
  type.c = 4,
  epsilon = 1,
  c.nu = 1,
  a.eps = 0.1,
  b.eps = 0.1,
  a.mu = 0.01,
  b.mu = 0.01,
  iterations = 1000,
  burn.in = floor(iterations * 0.2),
  thinning = 5,
  printtime = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CuMRes_+3A_times">times</code></td>
<td>
<p>Numeric positive vector. Failure times.</p>
</td></tr>
<tr><td><code id="CuMRes_+3A_delta">delta</code></td>
<td>
<p>Logical vector. Status indicator. <code>TRUE</code> (1) indicates
exact lifetime is known, <code>FALSE</code> (0) indicates that the corresponding
failure time is right censored.</p>
</td></tr>
<tr><td><code id="CuMRes_+3A_type.t">type.t</code></td>
<td>
<p>Integer. 1=computes uniformly-dense intervals; 2=
partition arbitrarily defined by the user with parameter utao and 3=same length intervals.</p>
</td></tr>
<tr><td><code id="CuMRes_+3A_k">K</code></td>
<td>
<p>Integer. Partition length for the hazard function if
<code>type.t</code>=1 or <code>type.t</code>=3.</p>
</td></tr>
<tr><td><code id="CuMRes_+3A_utao">utao</code></td>
<td>
<p>vector. Partition specified by the user when type.t = 2. The first value of 
the vector has to be 0 and the last one the maximum observed time, either censored or uncensored.</p>
</td></tr>
<tr><td><code id="CuMRes_+3A_alpha">alpha</code></td>
<td>
<p>Nonnegative entry vector. Small entries are recommended in
order to specify a non-informative prior distribution.</p>
</td></tr>
<tr><td><code id="CuMRes_+3A_beta">beta</code></td>
<td>
<p>Nonnegative entry vector. Small entries are recommended in order
to specify a non-informative prior distribution.</p>
</td></tr>
<tr><td><code id="CuMRes_+3A_c.r">c.r</code></td>
<td>
<p>Nonnegative vector. The higher the entries, the higher the correlation of two consecutive intervals.</p>
</td></tr>
<tr><td><code id="CuMRes_+3A_type.c">type.c</code></td>
<td>
<p>1=defines <code>c.r</code> as a zero-entry vector; 2=lets the user
define <code>c.r</code> freely; 3=assigns <code>c.r</code> by computing an exponential
prior distribution with mean epsilon; 4=assigns <code>c.r</code> by computing an exponential hierarchical
distribution with mean <code>epsilon</code> which in turn has a Ga(a.eps, b.eps)
distribution.</p>
</td></tr>
<tr><td><code id="CuMRes_+3A_epsilon">epsilon</code></td>
<td>
<p>Double. Mean of the exponential distribution assigned to
<code>c.r</code> when <code>type.c = 3</code>. When <code>type.c = 4</code>, <code>epsilon</code> is
assigned a Ga(a.eps,b.eps) distribution.</p>
</td></tr>
<tr><td><code id="CuMRes_+3A_c.nu">c.nu</code></td>
<td>
<p>Tuning parameter for the proposal distribution for c.</p>
</td></tr>
<tr><td><code id="CuMRes_+3A_a.eps">a.eps</code></td>
<td>
<p>Numeric. Shape parameter for the prior gamma distribution of
epsilon when <code>type.c = 4</code>.</p>
</td></tr>
<tr><td><code id="CuMRes_+3A_b.eps">b.eps</code></td>
<td>
<p>Numeric. Scale parameter for the prior gamma distribution of
epsilon when <code>type.c = 4</code>.</p>
</td></tr>
<tr><td><code id="CuMRes_+3A_a.mu">a.mu</code></td>
<td>
<p>Numeric. Shape parameter for the prior gamma distribution of
mu</p>
</td></tr>
<tr><td><code id="CuMRes_+3A_b.mu">b.mu</code></td>
<td>
<p>Numeric. Scale parameter for the prior gamma distribution of
mu</p>
</td></tr>
<tr><td><code id="CuMRes_+3A_iterations">iterations</code></td>
<td>
<p>Integer. Number of iterations including the <code>burn.in</code>
to be computed for the Markov Chain.</p>
</td></tr>
<tr><td><code id="CuMRes_+3A_burn.in">burn.in</code></td>
<td>
<p>Integer. Length of the burn-in period for the Markov chain.</p>
</td></tr>
<tr><td><code id="CuMRes_+3A_thinning">thinning</code></td>
<td>
<p>Integer. Factor by which the chain will be thinned. Thinning
the Markov chain is to reduces autocorrelation.</p>
</td></tr>
<tr><td><code id="CuMRes_+3A_printtime">printtime</code></td>
<td>
<p>Logical. If <code>TRUE</code>, prints out the execution time.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Computes the Gibbs sampler with the full conditional distributions of
all model parameters (Nieto-Barajas &amp; Yin 2008) and arranges the resulting Markov
chain into a tibble which can be used to obtain posterior summaries.
</p>


<h3>Note</h3>

<p>It is recommended to verify chain's stationarity. This can be done by
checking each element individually. See <code><a href="#topic+CuPlotDiag">CuPlotDiag</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

## Simulations may be time intensive. Be patient.
## Example 1
# data(crm3)
# times&lt;-crm3$times
# delta&lt;-crm3$delta
# res &lt;- CuMRes(times, delta, type.t = 2, 
#                   K = 100, length = .1, alpha = rep(1, 100  ), 
#                   beta = rep(1, 100),c.r = rep(50, 99), 
#                   iterations = 100, burn.in = 10, thinning = 1, type.c = 2)


</code></pre>

<hr>
<h2 id='CuPlotDiag'>Diagnosis plots for Lambda, U, C, Mu, Pi, Z and Epsilon</h2><span id='topic+CuPlotDiag'></span>

<h3>Description</h3>

<p>Diagnostics plots for hazard rate (Lambda), latent variable (U), dependence
variable (C), mean of cure threshold (Mu), cure proportion (Pi), cure threshold (Z) and the parameter of the
hierarchical prior (Epsilon).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CuPlotDiag(M, variable = "Lambda", pos = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CuPlotDiag_+3A_m">M</code></td>
<td>
<p>List. Contains the output by <code>CuMRes</code>.</p>
</td></tr>
<tr><td><code id="CuPlotDiag_+3A_variable">variable</code></td>
<td>
<p>Either &quot;Lambda&quot;, &quot;U&quot;, &quot;C&quot;, &quot;Mu&quot;, &quot;Pi&quot;, &quot;Z&quot; or &quot;Epsilon&quot;.
Variable for which diagnostic plot will be shown.</p>
</td></tr>
<tr><td><code id="CuPlotDiag_+3A_pos">pos</code></td>
<td>
<p>Positive integer. Position of the selected <code>variable</code> to be
plotted.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function returns a diagnostics plot for which the chain for the selected
variable can be monitored. Diagnostics includes trace, ergodic mean,
autocorrelation function and histogram.
</p>


<h3>References</h3>

<p>Nieto-Barajas, L. E., &amp; Yin, G. (2008). Bayesian semiparametric
cure rate model with an unknown threshold. <em>Scandinavian Journal of
Statistics</em>, <strong>35(3)</strong>, 540-556.
https://doi.org/10.1111/j.1467-9469.2007.00589.x
</p>


<h3>See Also</h3>

<p><a href="#topic+CuMRes">CuMRes</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>


## Simulations may be time intensive. Be patient.

## Example 1
# data(crm3)
# times&lt;-crm3$times
# delta&lt;-crm3$delta
# res &lt;- CuMRes(times, delta, type.t = 2, 
#                   K = 100, length = .1, alpha = rep(1, 100  ), 
#                   beta = rep(1, 100),c.r = rep(50, 99), 
#                   iterations = 100, burn.in = 10, thinning = 1, type.c = 2)
# CuPlotDiag(M = res, variable = "Mu")
# CuPlotDiag(M = res, variable = "Z")
# CuPlotDiag(M = res, variable = "Pi")
# CuPlotDiag(M = res, variable = "Lambda", pos = 2)
# CuPlotDiag(M = res, variable = "U", pos = 4)
# CuPlotDiag(M = res, variable = "C", pos = 3)



</code></pre>

<hr>
<h2 id='CuPloth'>Plots for the Hazard and Survival Funcion Estimates</h2><span id='topic+CuPloth'></span>

<h3>Description</h3>

<p>Plots the hazard function and the survival function
estimates defined by the bayesian semiparametric cure 
rate model with an unknown threshold
(Nieto-Barajas &amp; Yin, 2008).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CuPloth(
  M,
  type.h = "segment",
  intervals = T,
  confidence = 0.95,
  qn = 0.5,
  summary = FALSE,
  position_label = "right"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CuPloth_+3A_m">M</code></td>
<td>
<p>tibble. Contains the output generated by <code>CuMRres</code>.</p>
</td></tr>
<tr><td><code id="CuPloth_+3A_type.h">type.h</code></td>
<td>
<p>character. &quot;segment&quot;= use segments to plot hazard rates,
&quot;line&quot; = link hazard rates by a line</p>
</td></tr>
<tr><td><code id="CuPloth_+3A_intervals">intervals</code></td>
<td>
<p>logical. If TRUE, plots credible intervals.</p>
</td></tr>
<tr><td><code id="CuPloth_+3A_confidence">confidence</code></td>
<td>
<p>Numeric. Confidence level.</p>
</td></tr>
<tr><td><code id="CuPloth_+3A_qn">qn</code></td>
<td>
<p>Numeric. Quantile for Tao that should be visualized on the plot.</p>
</td></tr>
<tr><td><code id="CuPloth_+3A_summary">summary</code></td>
<td>
<p>Logical. If <code>TRUE</code>, a summary for hazard and survival
functions is returned as a tibble.</p>
</td></tr>
<tr><td><code id="CuPloth_+3A_position_label">position_label</code></td>
<td>
<p>character. Labels on the right or left side of the
plot.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function return estimators plots for the resulting hazard rate as it is computed
by <a href="#topic+CuMRes">CuMRes</a> and the cure time (quantile of Tao specified by the user), 
together with credible intervals. Additionally, it plots the survival function and the cure proportion estimates
with their corresponding credible intervals.
</p>


<h3>Value</h3>

<table>
<tr><td><code>SUM.h</code></td>
<td>
<p>Numeric tibble. Summary for the mean, median, and a
<code>confint / 100</code> confidence interval for each segment of the hazard
function. If <code>summary = TRUE</code></p>
</td></tr> <tr><td><code>SUM.S</code></td>
<td>
<p>Numeric tibble. Summary for
the mean, median, and a <code>confint / 100</code> confidence interval for a grid of 
the survival function. If <code>summary = TRUE</code></p>
</td></tr>
</table>


<h3>References</h3>

<p>- Nieto-Barajas, L. E. (2003). Discrete time Markov gamma
processes and time dependent covariates in survival analysis. <em>Bulletin
of the International Statistical Institute 54th Session</em>. Berlin. (CD-ROM).
</p>
<p>-Nieto-Barajas, L. E., &amp; Yin, G. (2008). Bayesian semiparametric cure rate
model with an unknown threshold. <em>Scandinavian Journal of Statistics</em>,
<strong>35(3)</strong>, 540-556. https://doi.org/10.1111/j.1467-9469.2007.00589.x
</p>


<h3>See Also</h3>

<p><a href="#topic+CuMRes">CuMRes</a>,
</p>


<h3>Examples</h3>

<pre><code class='language-R'>


## Simulations may be time intensive. Be patient.

## Example 1
# data(crm3)
    # times&lt;-crm3$times
    # delta&lt;-crm3$delta
    # res &lt;- CuMRes(times, delta, type.t = 2, length = .1,
    #                   K = 100, alpha = rep(1, 100  ),
    #                   beta = rep(1, 100),c.r = rep(50, 99),
    #                   iterations = 100, burn.in = 10, thinning = 1, type.c = 2)
    # CuPloth(res, type.h = "segment",qn=.5, summary = T)
    # CuPloth(res, type.h = "line",qn=.5)




</code></pre>

<hr>
<h2 id='GaMRes'>Markov Gamma Model</h2><span id='topic+GaMRes'></span>

<h3>Description</h3>

<p>Computes the Gibbs sampler given by the full conditional distributions of U,
Lambda, C and Epsilon (Nieto-Barajas &amp; Walker, 2002) and arranges the
resulting Markov chain into a tibble which can be used to obtain posterior
summaries.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GaMRes(
  times,
  delta = rep(1, length(times)),
  type.t = 3,
  K = 5,
  utao = NULL,
  alpha = rep(0.01, K),
  beta = rep(0.01, K),
  c.r = rep(1, (K - 1)),
  c.nu = 1,
  a.eps = 0.1,
  b.eps = 0.1,
  type.c = 4,
  epsilon = 1,
  iterations = 1000,
  burn.in = floor(iterations * 0.2),
  thinning = 5,
  printtime = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GaMRes_+3A_times">times</code></td>
<td>
<p>Numeric positive vector. Failure times.</p>
</td></tr>
<tr><td><code id="GaMRes_+3A_delta">delta</code></td>
<td>
<p>Logical vector. Status indicator. <code>TRUE</code> (1) indicates
exact lifetime is known, <code>FALSE</code> (0) indicates that the corresponding
failure time is right censored.</p>
</td></tr>
<tr><td><code id="GaMRes_+3A_type.t">type.t</code></td>
<td>
<p>Integer. 1=computes uniformly-dense intervals; 2=
partition arbitrarily defined by the user with parameter utao and 3=same length intervals.</p>
</td></tr>
<tr><td><code id="GaMRes_+3A_k">K</code></td>
<td>
<p>Integer. Partition length for the hazard function if
<code>type.t</code>=1 or <code>type.t</code>=3.</p>
</td></tr>
<tr><td><code id="GaMRes_+3A_utao">utao</code></td>
<td>
<p>vector. Partition specified by the user when type.t = 2. The first value of 
the vector has to be 0 and the last one the maximum observed time, either censored or uncensored.</p>
</td></tr>
<tr><td><code id="GaMRes_+3A_alpha">alpha</code></td>
<td>
<p>Nonnegative entry vector. Small entries are recommended in
order to specify a non-informative prior distribution.</p>
</td></tr>
<tr><td><code id="GaMRes_+3A_beta">beta</code></td>
<td>
<p>Nonnegative entry vector. Small entries are recommended in order
to specify a non-informative prior distribution.</p>
</td></tr>
<tr><td><code id="GaMRes_+3A_c.r">c.r</code></td>
<td>
<p>Nonnegative vector. The higher the entries, the higher the correlation 
of two consecutive intervals.</p>
</td></tr>
<tr><td><code id="GaMRes_+3A_c.nu">c.nu</code></td>
<td>
<p>Tuning parameter for the proposal distribution for c.</p>
</td></tr>
<tr><td><code id="GaMRes_+3A_a.eps">a.eps</code></td>
<td>
<p>Numeric. Shape parameter for the prior gamma distribution of
epsilon when <code>type.c = 4</code>.</p>
</td></tr>
<tr><td><code id="GaMRes_+3A_b.eps">b.eps</code></td>
<td>
<p>Numeric. Scale parameter for the prior gamma distribution of
epsilon when <code>type.c = 4</code>.</p>
</td></tr>
<tr><td><code id="GaMRes_+3A_type.c">type.c</code></td>
<td>
<p>1=assigns <code>c.r</code> a zero-entry vector; 2=lets the user
define <code>c.r</code> freely; 3=assigns <code>c.r</code> an exponential prior
distribution with mean 1; 4=assigns <code>c.r</code> an exponential hierarchical
distribution with mean <code>epsilon</code> which in turn has a Ga(a.eps, b.eps)
distribution.</p>
</td></tr>
<tr><td><code id="GaMRes_+3A_epsilon">epsilon</code></td>
<td>
<p>Double. Mean of the exponential distribution assigned to
<code>c.r</code> when <code>type.c = 3</code></p>
</td></tr>
<tr><td><code id="GaMRes_+3A_iterations">iterations</code></td>
<td>
<p>Integer. Number of iterations including the <code>burn.in</code>
to be computed for the Markov chain.</p>
</td></tr>
<tr><td><code id="GaMRes_+3A_burn.in">burn.in</code></td>
<td>
<p>Integer. Length of the burn-in period for the Markov chain.</p>
</td></tr>
<tr><td><code id="GaMRes_+3A_thinning">thinning</code></td>
<td>
<p>Integer. Factor by which the chain will be thinned. Thinning
the Markov chain is to reducec autocorrelation.</p>
</td></tr>
<tr><td><code id="GaMRes_+3A_printtime">printtime</code></td>
<td>
<p>Logical. If <code>TRUE</code>, prints out the execution time.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Posterior inference for the Bayesian non-parametric Markov gamma model in
survival analysis.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

## Simulations may be time intensive. Be patient.

## Example 1 
data(gehan) 
timesG &lt;- gehan$time[gehan$treat == "6-MP"] 
deltaG &lt;- gehan$cens[gehan$treat == "6-MP"] 
 GEX1 &lt;- GaMRes(timesG, deltaG, K = 8, iterations = 3000)

## Example 2 
data(leukemiaFZ) 
timesFZ &lt;- leukemiaFZ$time 
deltaFZ &lt;- leukemiaFZ$delta 
GEX2 &lt;- GaMRes(timesFZ, deltaFZ, type.c = 4)



</code></pre>

<hr>
<h2 id='GaPlotDiag'>Diagnosis plots for Lambda, U, C and Epsilon</h2><span id='topic+GaPlotDiag'></span>

<h3>Description</h3>

<p>Diagnostics plots for hazard rate (Lambda), latent variable (U), dependence
parameter (C) and the parameter of the hierarchical prior (Epsilon).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GaPlotDiag(M, variable = "Lambda", pos = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GaPlotDiag_+3A_m">M</code></td>
<td>
<p>List. Contains the output
by <code>GaMRes</code>.</p>
</td></tr>
<tr><td><code id="GaPlotDiag_+3A_variable">variable</code></td>
<td>
<p>Either &quot;Lambda&quot;, &quot;U&quot;, &quot;C&quot; or &quot;Epsilon&quot;. Variable for which
informative plot will be shown.</p>
</td></tr>
<tr><td><code id="GaPlotDiag_+3A_pos">pos</code></td>
<td>
<p>Positive integer. Position of the selected <code>variable</code> to be
plotted.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function returns a diagnostics plot for which the chain of the selected
variable can be monitored. Diagnostics includes trace, ergodic mean,
autocorrelation function and histogram.
</p>


<h3>References</h3>

<p>- Nieto-Barajas, L. E. &amp; Walker, S. G. (2002). Markov beta and
gamma processes for modelling hazard rates. <em>Scandinavian Journal of
Statistics</em> <strong>29</strong>: 413-424.
</p>


<h3>See Also</h3>

<p><a href="#topic+GaMRes">GaMRes</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

 
## Simulations may be time intensive. Be patient.

## Example 1
#  data(gehan)
#  timesG &lt;- gehan$time[gehan$treat == "6-MP"]
#  deltaG &lt;- gehan$cens[gehan$treat == "6-MP"]
#  GEX1 &lt;- GaMRes(timesG, deltaG, K = 8, iterations = 3000)
#  GaPlotDiag(GEX1, variable = "Lambda", pos = 2)
#  GaPlotDiag(GEX1, variable = "U", pos = 5)

## Example 2
#  data(leukemiaFZ)
#  timesFZ &lt;- leukemiaFZ$time
#  deltaFZ &lt;- leukemiaFZ$delta
#  GEX2 &lt;- GaMRes(timesFZ, deltaFZ, type.c = 4)
#  GaPlotDiag(GEX2, variable = "Lambda", pos = 2)
#  GaPlotDiag(GEX2, variable = "U", pos = 3)



</code></pre>

<hr>
<h2 id='GaPloth'>Plots for the Hazard and Survival Function Estimates</h2><span id='topic+GaPloth'></span>

<h3>Description</h3>

<p>Plots the hazard function and with the survival function
estimates defined by the Markov gamma process with and without covariates
(Nieto-Barajas &amp; Walker, 2002).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GaPloth(
  M,
  type.h = "segment",
  addSurvival = T,
  intervals = T,
  confidence = 0.95,
  summary = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GaPloth_+3A_m">M</code></td>
<td>
<p>tibble. Contains the output by <code>CGaMRres</code> and <code>GaMRes</code>.</p>
</td></tr>
<tr><td><code id="GaPloth_+3A_type.h">type.h</code></td>
<td>
<p>character. &quot;segment&quot;= use segments to plot hazard rates,
&quot;line&quot; = link hazard rates by a line</p>
</td></tr>
<tr><td><code id="GaPloth_+3A_addsurvival">addSurvival</code></td>
<td>
<p>Logical. If <code>TRUE</code>, Nelson-Aalen estimate is plotted
over the hazard function and Kaplan-Meier estimate is plotted over the
survival function.</p>
</td></tr>
<tr><td><code id="GaPloth_+3A_intervals">intervals</code></td>
<td>
<p>logical. If TRUE, plots confidence bands for the selected functions including Nelson-Aalen and/or Kaplan-Meier estimate.</p>
</td></tr>
<tr><td><code id="GaPloth_+3A_confidence">confidence</code></td>
<td>
<p>Numeric. Confidence level.</p>
</td></tr>
<tr><td><code id="GaPloth_+3A_summary">summary</code></td>
<td>
<p>Logical. If <code>TRUE</code>, a summary for hazard and survival
functions is returned as a tibble.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function returns estimators plots for the resulting hazard rate as it is computed
by <a href="#topic+GaMRes">GaMRes</a> and <a href="#topic+CGaMRes">CGaMRes</a> and the Nelson-Aalen
estimate along with their confidence intervals for the data set given.
Additionally, it plots the survival function and the Kaplan-Meier estimate
with their corresponding credible/confidence intervals.
</p>


<h3>Value</h3>

<table>
<tr><td><code>SUM.h</code></td>
<td>
<p>Numeric tibble. Summary for the mean, median, and a
<code>confint / 100</code> confidence interval for each segment of the hazard
function. If <code>summary = TRUE</code></p>
</td></tr> <tr><td><code>SUM.S</code></td>
<td>
<p>Numeric tibble. Summary for
the mean, median, and a <code>confint / 100</code> confidence interval for a grid
of the survival function. If <code>summary = TRUE</code></p>
</td></tr>
</table>


<h3>References</h3>

<p>- Nieto-Barajas, L. E. (2003). Discrete time Markov gamma
processes and time dependent covariates in survival analysis. <em>Bulletin
of the International Statistical Institute 54th Session</em>. Berlin. (CD-ROM).
</p>
<p>- Nieto-Barajas, L. E. &amp; Walker, S. G. (2002). Markov beta and gamma
processes for modelling hazard rates. <em>Scandinavian Journal of
Statistics</em> <strong>29</strong>: 413-424.
</p>


<h3>See Also</h3>

<p><a href="#topic+GaMRes">GaMRes</a>, <a href="#topic+CGaMRes">CGaMRes</a>, <a href="#topic+CGaPlotDiag">CGaPlotDiag</a>,
<a href="#topic+GaPlotDiag">GaPlotDiag</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>


## Simulations may be time intensive. Be patient.

## Example 1
#  data(gehan)
#  timesG &lt;- gehan$time[gehan$treat == "6-MP"]
#  deltaG &lt;- gehan$cens[gehan$treat == "6-MP"]
#  GEX1 &lt;- GaMRes(timesG, deltaG, K = 8, iterations = 3000)
#  GaPloth(GEX1)


## Example 2
#  data(leukemiaFZ)
#  timesFZ &lt;- leukemiaFZ$time
#  deltaFZ &lt;- leukemiaFZ$delta
#  GEX2 &lt;- GaMRes(timesFZ, deltaFZ, type.c = 4)
#  GaPloth(GEX2)





</code></pre>

<hr>
<h2 id='gehan'>
Times of Remission of Leukemia Patients (Gehan)
</h2><span id='topic+gehan'></span>

<h3>Description</h3>

<p>Freireich et al. (1963) report the results of a clinical trial of a drug 6-mercaptopurine (6-MP) versus a placebo (control) in 42 children with acute leukemia. The trial was conducted at 11 American hospitals. The trial was conducted by matching pairs of patients at a given hospital by remission status (complete or partial) and randomizing within the pair to either a 6-MP or placebo maintenance therapy. Patients were followed until their leukemia returned (relapse) or until the end of the study (in weeks). The data was taken from Klein &amp; Moeschberger (2003) and is contained in the <code>MASS</code> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(gehan)</code></pre>


<h3>Format</h3>

<p>A data frame with 42 observations containing:
</p>

<dl>
<dt><code>pair</code></dt><dd><p>Pair index.</p>
</dd>
<dt><code>time</code></dt><dd><p>Remission time (weeks).</p>
</dd>
<dt><code>cens</code></dt><dd><p>Status: 0=censored.</p>
</dd>
<dt><code>treat</code></dt><dd><p>Treatment: control or 6-MP.</p>
</dd>
</dl>



<h3>Source</h3>

<p>Klein, J. P., &amp; Moeschberger, M. L. (2003). Survival analysis: techniques for censored and truncated data. Springer Science &amp; Business Media. 
</p>


<h3>References</h3>

<p>Freireich, E. J., et al. (1963). The effect of 6-mercaptopurine on the duration of steroid-induced remissions in acute leukemia: A model for evaluation of other potentially useful therapy. <em>Blood</em>, <strong>21(6)</strong>, 699-716.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Gamma Process Example 1 
#  data(gehan)
#  timesG &lt;- gehan$time[gehan$treat == "6-MP"]
#  deltaG &lt;- gehan$cens[gehan$treat == "6-MP"]
#  GEX1 &lt;- GaMRes(timesG, deltaG, K = 8, iterations = 3000)
#  GaPloth(GEX1)
</code></pre>

<hr>
<h2 id='KIDNEY'>Recurrent infection of kidney catheters</h2><span id='topic+KIDNEY'></span>

<h3>Description</h3>

<p>Data on the recurrent times to infection, at the point of insertion of the
catheter, for kidney patients using portable dialysis equipment. Catheters
may be removed for reasons other than infection, in which case the
observation is censored. Each patient has exactly 2 observations. Only sex
was kept as an explanatory variable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>KIDNEY
</code></pre>


<h3>Format</h3>

<p>A data frame with 38 rows and 6 variables:
</p>

<dl>
<dt>id</dt><dd><p>patient ID</p>
</dd>
<dt>t1,t2</dt><dd><p>times to infection</p>
</dd>
<dt>delta1,delta2</dt><dd><p>censorship indicators (1 = exact, 0 = right-censored)</p>
</dd>
<dt>sex</dt><dd><p>0 = female, 1 = male</p>
</dd>
</dl>



<h3>Source</h3>

<p><a href="https://www.mayo.edu/research/documents/kidneyhtml/doc-10027569">https://www.mayo.edu/research/documents/kidneyhtml/doc-10027569</a>
</p>

<hr>
<h2 id='leukemiaFZ'>
Survival Times of Patients with Leukemia (Feigl and Zelen)
</h2><span id='topic+leukemiaFZ'></span>

<h3>Description</h3>

<p>Survival times of 33 patients with leukemia (Feigl and Zeelen, 1965). Times are measured in weeks from diagnosis. Reported covariates are white blood cell counts (WBC) and a binary variable AG that indicates a positive or negative test related to the white blood cell
characteristics. Three of the observations were censored. The data was taken from Lawless (2003).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(leukemiaFZ)</code></pre>


<h3>Format</h3>

<p>A data frame with 33 observations on the following 4 variables.
</p>

<dl>
<dt><code>time</code></dt><dd><p>Weeks from diagnosis.</p>
</dd>
<dt><code>delta</code></dt><dd><p>Status indicator: 0=censored.</p>
</dd>
<dt><code>AG</code></dt><dd><p>Indicates a positive or negative test related to the white blood cell characteristics. (1=AG-positive, 2=AG-negative).</p>
</dd>
<dt><code>wbc</code></dt><dd><p>White blood cell counts in thousands (reported covariates).</p>
</dd>
</dl>



<h3>Source</h3>

<p>Lawless, J.F. (2003). Statistical Models and Methods for Lifetime Data. Wiley: New Jersey.
</p>


<h3>References</h3>

<p>Feigl, P. and Zelen, M. (1965). Estimation of Exponential Survival Probabilities with Concomitant Information. <em>Biometrics</em> <strong>21</strong>, 826-838.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Cox-Gamma Process Example 1
#  data(leukemiaFZ)
#  leukemia1 &lt;- leukemiaFZ
#  leukemia1$wbc &lt;- log(leukemiaFZ$wbc)
#  CGEX1 &lt;- CGaMRes(data = leukemia1, K = 10, iterations = 100, thinning = 1)
</code></pre>

<hr>
<h2 id='psych'>
Death Times of Psychiatric Patients (Woolson)
</h2><span id='topic+psych'></span>

<h3>Description</h3>

<p>Woolson (1981) has reported survival data on 26 psychiatric inpatients admitted to the University of Iowa hospitals during the years 1935-1948. This sample is part of a larger study of psychiatric inpatients discussed by Tsuang and Woolson (1977) and it is contained in the <code>KMsurv</code> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(psych)</code></pre>


<h3>Format</h3>

<p>A data frame with 26 observations containing:
</p>

<dl>
<dt><code>sex</code></dt><dd><p>Patient sex: 1=male, 2=female.</p>
</dd>
<dt><code>age</code></dt><dd><p>Age at first admission to the hospital.</p>
</dd>
<dt><code>time</code></dt><dd><p>Number of years of follow-up.</p>
</dd>
<dt><code>death</code></dt><dd><p>Patient status at the follow-up time: 0=alive, 1=dead.</p>
</dd>
</dl>



<h3>Source</h3>

<p>Klein, J. P., and Moeschberger, M. L. (2003). Survival analysis: techniques for censored and truncated data. Springer Science &amp; Business Media. 
</p>


<h3>References</h3>

<p>Tsuang, M. T. and Woolson, R. F. (1977). Mortality in Patients with Schizophrenia, Mania and
Depression. <em>British Journal of Psychiatry</em>, <strong>130</strong>: 162-166.
</p>
<p>Woolson, R. F. (1981). Rank Tests and a One-Sample Log Rank Test for Comparing Observed
Survival Data to a Standard Population. <em>Biometrics</em> <strong>37</strong>: 687-696.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Beta Process Example 1
## Example 1
#  data(psych)
#  timesP &lt;- psych$time
#  deltaP &lt;- psych$death
#  BEX1 &lt;- BeMRes(timesP, deltaP, iterations = 3000, burn.in = 300, thinning = 1)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
