<!DOCTYPE html><html lang="en-US"><head><title>Help for package ergmito</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {ergmito}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#as_adjmat'><p>An alternative to <code>as.matrix</code> to retrieve adjacency matrix fast</p></a></li>
<li><a href='#benchmarkito'><p>Utility to benchmark expression in R</p></a></li>
<li><a href='#blockdiagonalize'><p>Block-diagonal models using <code>ergm</code></p></a></li>
<li><a href='#check_support'><p>Check the convergence of ergmito estimates</p></a></li>
<li><a href='#count_stats'><p>Count Network Statistics</p></a></li>
<li><a href='#ergmito_boot'><p>Bootstrap of ergmito</p></a></li>
<li><a href='#ergmito_formulae'><p>Processing formulas in <code>ergmito</code></p></a></li>
<li><a href='#ergmito_gof'><p>Goodness of Fit diagnostics for ERGMito models</p></a></li>
<li><a href='#exact_loglik'><p>Vectorized calculation of ERGM exact log-likelihood</p></a></li>
<li><a href='#extract.ergmito'><p>Extract function to be used with the <code>texreg</code> package.</p></a></li>
<li><a href='#fivenets'><p>Example of a group of small networks</p></a></li>
<li><a href='#geodesic'><p>Geodesic distance matrix (all pairs)</p></a></li>
<li><a href='#induced_submat'><p>Extract a submatrix from a network</p></a></li>
<li><a href='#matrix_to_network'><p>Manipulation of network objects</p></a></li>
<li><a href='#new_ergmito_ptr'><p>Creates a new <code>ergmito_ptr</code></p></a></li>
<li><a href='#new_rergmito'><p>ERGMito sampler</p></a></li>
<li><a href='#nvertex'><p>Utility functions to query network dimensions</p></a></li>
<li><a href='#plot.ergmito'><p>Function to visualize the optimization surface</p></a></li>
<li><a href='#powerset'><p>Power set of Graphs of size <code>n</code></p></a></li>
<li><a href='#predict.ergmito'><p>Prediction method for <code>ergmito</code> objects</p></a></li>
<li><a href='#rbernoulli'><p>Random Bernoulli graph</p></a></li>
<li><a href='#same_dist'><p>Compare pairs of networks to see if those came from the same distribution</p></a></li>
<li><a href='#simulate.ergmito'><p>Draw samples from a fitted <code>ergmito</code> model</p></a></li>
<li><a href='#vcov.ergmito'><p>Estimation of ERGMs using Maximum Likelihood Estimation (MLE)</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Version:</td>
<td>0.3-1</td>
</tr>
<tr>
<td>Title:</td>
<td>Exponential Random Graph Models for Small Networks</td>
</tr>
<tr>
<td>Description:</td>
<td>Simulation and estimation of Exponential Random Graph Models (ERGMs)
  for small networks using exact statistics as shown in Vega Yon et al. (2020)
  &lt;<a href="https://doi.org/10.1016%2Fj.socnet.2020.07.005">doi:10.1016/j.socnet.2020.07.005</a>&gt;. As a difference from the 'ergm'
  package, 'ergmito' circumvents using Markov-Chain Maximum Likelihood Estimator
  (MC-MLE) and instead uses Maximum Likelihood Estimator (MLE) to fit ERGMs
  for small networks. As exhaustive enumeration is computationally feasible for
  small networks, this R package takes advantage of this and provides tools for
  calculating likelihood functions, and other relevant functions, directly,
  meaning that in many cases both estimation and simulation of ERGMs for
  small networks can be faster and more accurate than simulation-based
  algorithms.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.3.0)</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Imports:</td>
<td>ergm, network, MASS, Rcpp, texreg, stats, parallel, utils,
methods, graphics</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Suggests:</td>
<td>covr, sna, lmtest, fmcmc, coda, knitr, rmarkdown, tinytest</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://muriteams.github.io/ergmito/">https://muriteams.github.io/ergmito/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/muriteams/ergmito/issues">https://github.com/muriteams/ergmito/issues</a></td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-06-13 19:39:54 UTC; george</td>
</tr>
<tr>
<td>Author:</td>
<td>George Vega Yon <a href="https://orcid.org/0000-0002-3171-0844"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [cre, aut],
  Kayla de la Haye <a href="https://orcid.org/0000-0002-2536-7701"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ths],
  Army Research Laboratory and the U.S. Army Research Office [fnd] (Grant
    Number W911NF-15-1-0577)</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>George Vega Yon &lt;g.vegayon@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-06-14 10:42:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='as_adjmat'>An alternative to <code>as.matrix</code> to retrieve adjacency matrix fast</h2><span id='topic+as_adjmat'></span>

<h3>Description</h3>

<p>This function does not perform significant checks. Furthermore, this function
won't keep the row/col names.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_adjmat(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as_adjmat_+3A_x">x</code></td>
<td>
<p>An object to be coerced as an adjacency matrix.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(1231)
x &lt;- matrix_to_network(rbernoulli(rep(5, 100)))
benchmarkito(
  as_adjmat = as_adjmat(x),
  as.matrix = lapply(x, as.matrix)
)
</code></pre>

<hr>
<h2 id='benchmarkito'>Utility to benchmark expression in R</h2><span id='topic+benchmarkito'></span>

<h3>Description</h3>

<p>This is just an internal utility included in the package which is not designed
to be accurate. If you need accurate benchmarks, you should take a look at the
<a href="https://CRAN.R-project.org/package=microbenchmark"><span class="pkg">microbenchmark</span></a> and <a href="https://CRAN.R-project.org/package=bench"><span class="pkg">bench</span></a> R packages.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>benchmarkito(..., times = 100, rand_ord = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="benchmarkito_+3A_...">...</code></td>
<td>
<p>List of expressions to benchmark.</p>
</td></tr>
<tr><td><code id="benchmarkito_+3A_times">times</code></td>
<td>
<p>Integer scalar. Number of replicates.</p>
</td></tr>
<tr><td><code id="benchmarkito_+3A_rand_ord">rand_ord</code></td>
<td>
<p>Logical. When <code>TRUE</code>, the expressions are executed in a random
order.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The print method prints a summary including quantiles, relative elapsed times,
and the order (fastest to slowest).
</p>


<h3>Value</h3>

<p>A data frame of class <code>ergmito_benchmark</code> with <code>times</code> rows and the
following columns:
</p>

<ul>
<li> <p><code>id</code> Integer. Id of the expression.
</p>
</li>
<li> <p><code>expr</code> Factor. Expression executed.
</p>
</li>
<li> <p><code>user.self</code>, <code>sys.self</code>, <code>elapsed</code>, <code>sys.child</code> time in seconds (see <code><a href="base.html#topic+proc.time">proc.time()</a></code>).
</p>
</li></ul>

<p>Includes the following attributes: <code>ncalls</code>, <code>call</code>, <code>label</code>, and <code>expr</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>bm &lt;- benchmarkito(
  exp(1:100000),
  sqrt(1:100000),
  times = 20
)

plot(bm)
print(bm)

</code></pre>

<hr>
<h2 id='blockdiagonalize'>Block-diagonal models using <code>ergm</code></h2><span id='topic+blockdiagonalize'></span><span id='topic+splitnetwork'></span><span id='topic+ergm_blockdiag'></span>

<h3>Description</h3>

<p>These two functions are used to go back and forth from a pooled ergm vs a
blockdiagonal model, the latter to be fitted using <a href="ergm.html#topic+ergm">ergm::ergm</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>blockdiagonalize(x, attrname = "block")

splitnetwork(x, attrname)

ergm_blockdiag(formula, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="blockdiagonalize_+3A_x">x</code></td>
<td>
<p>In the case of <code>blockdiagonalize</code>, a list of networks or matrices.
For <code>splitnetwork</code> a single network object with a vertex attribute that can
be used to split the data.</p>
</td></tr>
<tr><td><code id="blockdiagonalize_+3A_attrname">attrname</code></td>
<td>
<p>Name of the attribute that holds the block ids.</p>
</td></tr>
<tr><td><code id="blockdiagonalize_+3A_formula">formula</code></td>
<td>
<p>An ergm model which networks' will be wrapped with
blockdiagonalize (see details).</p>
</td></tr>
<tr><td><code id="blockdiagonalize_+3A_...">...</code></td>
<td>
<p>Further arguments passed to the method.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>ergm_blockdiag</code> is a wrapper function that takes the
model's network, stacks the networks into a single block diagonal net, and
calls <a href="ergm.html#topic+ergm">ergm::ergm</a> with the option <code>constraints = blockdiag("block")</code>.
</p>
<p>One side effect of this function is that it loads the <code>ergm</code> package via
<a href="base.html#topic+requireNamespace">requireNamespace</a>, so after executing the function <code>ergm</code> the package will
be loaded.
</p>


<h3>Value</h3>

<p>An object of class <a href="ergm.html#topic+ergm">ergm::ergm</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(ergm)
data(fivenets)

fivenets2 &lt;- blockdiagonalize(fivenets, attrname = "block") # A network with
ans0 &lt;- ergm(
  fivenets2 ~ edges + nodematch("female"),
  constraints = ~blockdiag("block")
  )
ans1 &lt;- ergmito(fivenets ~ edges + nodematch("female"))

# This is equivalent
ans2 &lt;- ergm_blockdiag(fivenets ~ edges + nodematch("female"))

</code></pre>

<hr>
<h2 id='check_support'>Check the convergence of ergmito estimates</h2><span id='topic+check_support'></span><span id='topic+check_convergence'></span>

<h3>Description</h3>

<p>This is an internal function used to check the convergence of the optim function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_support(target_stats, stats_statmat, threshold = 0.8, warn = TRUE)

check_convergence(optim_output, model, support, crit = 5)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="check_support_+3A_target_stats">target_stats</code>, <code id="check_support_+3A_stats_statmat">stats_statmat</code></td>
<td>
<p>See <a href="#topic+ergmito_formulae">ergmito_formulae</a>.</p>
</td></tr>
<tr><td><code id="check_support_+3A_threshold">threshold</code></td>
<td>
<p>Numeric scalar. Confidence range for flagging an observed
statistic as potentially near the boundary.</p>
</td></tr>
<tr><td><code id="check_support_+3A_warn">warn</code></td>
<td>
<p>logical scalar.</p>
</td></tr>
<tr><td><code id="check_support_+3A_optim_output">optim_output</code></td>
<td>
<p>A list output from the <a href="stats.html#topic+optim">stats::optim</a> function.</p>
</td></tr>
<tr><td><code id="check_support_+3A_model">model</code></td>
<td>
<p>An object of class <a href="#topic+ergmito_loglik">ergmito_loglik</a>.</p>
</td></tr>
<tr><td><code id="check_support_+3A_support">support</code></td>
<td>
<p>As returned by <code>check_support</code>.</p>
</td></tr>
<tr><td><code id="check_support_+3A_crit">crit</code></td>
<td>
<p>Numeric scalar. Level at which a parameter estimate
will be questioned.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following components:
</p>

<ul>
<li> <p><code>par</code> Updated set of parameters
</p>
</li>
<li> <p><code>vcov</code> Updated variance-covariance matrix
</p>
</li>
<li> <p><code>valid</code> Vector of integers with the parameters that are marked as OK.
</p>
</li>
<li> <p><code>status</code> Return code of the analysis. See details.
</p>
</li>
<li> <p><code>note</code> A note describing the status.
</p>
</li></ul>



<h3>Return codes</h3>

<p>The function makes an analysis of the outcome of the model and makes the corresponding
adjustments when required. In particular, we check:
</p>

<ol>
<li><p> Whether the optimization algorithm converged or not
</p>
</li>
<li><p> If the obtained estimates maximize the function. If this is not the case,
the function checks whether the MLE may not exist. This usually happens
when the log-likelihood function can improve by making increments to parameters
that are already tagged as large. If the ll improves, then the value is
replaced with <code>Inf</code> (+- depending on the sign of the parameter).
</p>
</li>
<li><p> If the Hessian is semi-positive-definite, i.e. if it is invertible. If it
is not, it usually means that the function did not converged, in which
case we will use <a href="MASS.html#topic+ginv">MASS::ginv</a> instead.
</p>
</li></ol>

<p>The return codes are composed of two numbers, the first number gives information
regarding of the parameter estimates, while the second number give information
about the variance-covariance matrix.
</p>
<p>Column 1:
</p>

<ul>
<li><p> 0: Converged and estimates at the max.
</p>
</li>
<li><p> 1: It did not converged, but I see no issue in the max.
</p>
</li>
<li><p> 2: One or more estimates went to +/-Inf
</p>
</li>
<li><p> 3: All went to hell. All estimates went to +/-Inf
</p>
</li></ul>

<p>Column 2:
</p>

<ul>
<li><p> 0: Hessian is p.s.d.
</p>
</li>
<li><p> 1: Hessian is not not p.s.d.
</p>
</li></ul>

<p>Possible codes and corresponding messages:
</p>

<ul>
<li><p> 00 All OK (no message).
</p>
</li>
<li><p> 01 optim converged, but the Hessian is not p.s.d..
</p>
</li>
<li><p> 10 optim did not converged, but the estimates look OK..
</p>
</li>
<li><p> 11 optim did not converged, and the Hessian is not p.s.d..
</p>
</li>
<li><p> 20 A subset of the parameters estimates was replaced with +/-Inf..
</p>
</li>
<li><p> 21 A subset of the parameters estimates was replaced with +/-Inf,  and the Hessian matrix is not p.s.d..
</p>
</li>
<li><p> 30 All parameters went to +/-Inf suggesting that the MLE may not exists..
</p>
</li></ul>


<hr>
<h2 id='count_stats'>Count Network Statistics</h2><span id='topic+count_stats'></span><span id='topic+AVAILABLE_STATS'></span><span id='topic+count_stats.formula'></span><span id='topic+count_stats.list'></span>

<h3>Description</h3>

<p>This function is similar to what <a href="ergm.html#topic+summary_formula">ergm::summary_formula</a> does, but it provides
a fast wrapper suited for matrix class objects (see benchmark in the examples).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>count_stats(X, ...)

AVAILABLE_STATS()

## S3 method for class 'formula'
count_stats(X, ...)

## S3 method for class 'list'
count_stats(X, terms, attrs = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="count_stats_+3A_x">X</code></td>
<td>
<p>List of square matrices. (networks)</p>
</td></tr>
<tr><td><code id="count_stats_+3A_...">...</code></td>
<td>
<p>Passed to the method.</p>
</td></tr>
<tr><td><code id="count_stats_+3A_terms">terms</code></td>
<td>
<p>Character vector with the names of the statistics to calculate.
Currently, the only available statistics are: 'mutual', 'edges', 'ttriad', 'ctriad', 'ctriple', 'nodeicov', 'nodeocov', 'nodematch', 'triangle', 'balance', 't300', 't102', 'absdiff', 'idegree1.5', 'odegree1.5', 'ostar1', 'ostar2', 'ostar3', 'ostar4', 'istar1', 'istar2', 'istar3', 'istar4'.</p>
</td></tr>
<tr><td><code id="count_stats_+3A_attrs">attrs</code></td>
<td>
<p>A list of vectors. This is used when <code>term</code> has a nodal attribute
such as <code>nodeicov(attrname="")</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of size <code>length(X) * length(terms)</code> with the corresponding
counts of statistics.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># DGP 
set.seed(123199)
x &lt;- rbernoulli(rep(5, 10))
ans0 &lt;- count_stats(x, c("mutual", "edges"))

# Calculating using summary_formula
ans1 &lt;- lapply(x, function(i) {
  ergm::summary_formula(i ~ mutual + edges)
})

ans1 &lt;- do.call(rbind, ans1)

# Comparing
all.equal(unname(ans0), unname(ans1))

# count_stats is vectorized (and so faster)
bm &lt;- benchmarkito(
  count_stats = count_stats(x, c("mutual", "edges")),
  lapply      = lapply(x, function(i) {
  ergm::summary_formula(i ~ mutual + edges)
}), times = 50
)

plot(bm)

</code></pre>

<hr>
<h2 id='ergmito_boot'>Bootstrap of ergmito</h2><span id='topic+ergmito_boot'></span>

<h3>Description</h3>

<p>Bootstrap of ergmito
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ergmito_boot(x, ..., R, ncpus = 1L, cl = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ergmito_boot_+3A_x">x</code></td>
<td>
<p>Either a formula or an object of class <a href="#topic+ergmito">ergmito</a>.</p>
</td></tr>
<tr><td><code id="ergmito_boot_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to the method.</p>
</td></tr>
<tr><td><code id="ergmito_boot_+3A_r">R</code></td>
<td>
<p>Integer. Number of replicates</p>
</td></tr>
<tr><td><code id="ergmito_boot_+3A_ncpus">ncpus</code></td>
<td>
<p>Integer Number of CPUs to use. Only recommended if <code>ergmito</code> was
not compiled with OpenMP (otherwise it will be slower).</p>
</td></tr>
<tr><td><code id="ergmito_boot_+3A_cl">cl</code></td>
<td>
<p>An object of class <code>cluster</code> (see <code><a href="parallel.html#topic+makeCluster">makePSOCKcluster</a></code>)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The resulting sample of parameters estimates is then used to compute
the variance-covariance matrix of the model. Cases in which <code>Inf</code>/<code>NaN</code>/<code>NA</code>
values were returned are excluded from the calculation.
</p>


<h3>Value</h3>

<p>An object of class <code>ergmito_boot</code> and <a href="#topic+ergmito">ergmito</a>. This adds three
elements to the <code>ergmito</code> object:
</p>

<ul>
<li> <p><code>R</code> The number of replicates.
</p>
</li>
<li> <p><code>sample</code> A vector of length <code>R</code> with the cases used in each replicate.
</p>
</li>
<li> <p><code>dist</code> The distribution of fitted parameters.
</p>
</li>
<li> <p><code>nvalid</code> the number of cases used for computing the covar.
</p>
</li>
<li> <p><code>timer_boot</code> records the time the whole process took.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
data(fivenets)
set.seed(123)
ans0 &lt;- ergmito(fivenets ~ edges + ttriad)
ans1 &lt;- suppressWarnings(ergmito_boot(ans0, R = 100))
ans2 &lt;- suppressWarnings(ergmito_boot(fivenets ~ edges + ttriad, R = 100))

# Checking the differences
summary(ans0)
summary(ans1)
summary(ans2)
</code></pre>

<hr>
<h2 id='ergmito_formulae'>Processing formulas in <code>ergmito</code></h2><span id='topic+ergmito_formulae'></span><span id='topic+ergmito_loglik'></span>

<h3>Description</h3>

<p>Analyze formula objects returning the matrices of weights and sufficient
statistics to be used in the model together with the log-likelihood and
gradient functions for joint models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ergmito_formulae(
  model,
  model_update = NULL,
  target_stats = NULL,
  stats_weights = NULL,
  stats_statmat = NULL,
  target_offset = NULL,
  stats_offset = NULL,
  env = parent.frame(),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ergmito_formulae_+3A_model">model</code></td>
<td>
<p>A formula. The left-hand-side can be either a small network, or
a list of networks.</p>
</td></tr>
<tr><td><code id="ergmito_formulae_+3A_model_update">model_update</code></td>
<td>
<p>A formula. If specified, the after computing the
sufficient statistics (observed and support), the model is updated using
<code><a href="stats.html#topic+model.frame">stats::model.frame()</a></code>. This includes processing offset terms.</p>
</td></tr>
<tr><td><code id="ergmito_formulae_+3A_target_stats">target_stats</code></td>
<td>
<p>Observed statistics. If multiple networks, then a list, otherwise
a named vector (see <a href="ergm.html#topic+summary_formula">ergm::summary_formula</a>).</p>
</td></tr>
<tr><td><code id="ergmito_formulae_+3A_stats_weights">stats_weights</code>, <code id="ergmito_formulae_+3A_stats_statmat">stats_statmat</code></td>
<td>
<p>Lists of sufficient statistics and their
respective weights.</p>
</td></tr>
<tr><td><code id="ergmito_formulae_+3A_target_offset">target_offset</code>, <code id="ergmito_formulae_+3A_stats_offset">stats_offset</code></td>
<td>
<p>See <code><a href="#topic+exact_loglik">exact_loglik()</a></code>.</p>
</td></tr>
<tr><td><code id="ergmito_formulae_+3A_env">env</code></td>
<td>
<p>Environment in which <code>model</code> should be evaluated.</p>
</td></tr>
<tr><td><code id="ergmito_formulae_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <a href="ergm.html#topic+ergm.allstats">ergm::ergm.allstats</a>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>One of the main advantages of been able to compute exact likelihoods is that
we can build arbitrarily complex models in the same way that we would do in
the context of Generalized Linear Models, this is, adding offset terms,
interaction effects, or transformations of statistics without much effort.
</p>
<p>In particular, if the user passes a formula via <code>model_update</code>, the
cannonical additive ERGM can be modified to include other terms, for example,
if we wanted to add an interaction effect of the <code>nodematch("age")</code> with
network size, we can simply type
</p>
<div class="sourceCode"><pre>model_update = ~ . + I(nodematch.age * n)
</pre></div>
<p>The <code><a href="base.html#topic+I">I()</a></code> function allows operating over variables in the model, in this case,
we took the <code>nodematch.age</code> variable (which is the name that <code><a href="ergm.html#topic+ergm">ergm::ergm()</a></code>
assigns to it after computing the sufficient statistics) and multiplied it by
<code>n</code>, which is the network size (this variable is included by default).
</p>
<p>By default, the ergm package calculates up to 2^16 unique values for the
vector of sufficient statistics. This results in issues if the user tries to
fit a model with too heterogenous networks or sets of attributes. To deal
with this it suffices with adding the option <code>maxNumChangeStatVectors</code> in
the ergmito call, e.g.:
</p>
<div class="sourceCode"><pre># Networks of size 5 have up to 2^20 unique sets of sufficient statistics
ergmito(..., maxNumChangeStatVectors = 2^20)
</pre></div>
<p>See more in ?<a href="ergm.html#topic+ergm.allstats">ergm::ergm.allstats</a>.
</p>


<h3>Value</h3>

<p>A list of class <code>ergmito_loglik</code>.
</p>

<ul>
<li> <p><code>loglik</code> A function. The log-likelihood function.
</p>
</li>
<li> <p><code>grad</code> A function. The gradient of the model.
</p>
</li>
<li> <p><code>stats_weights</code>,<code>stats_statmat</code> two list of objects as returned by
<a href="ergm.html#topic+ergm.allstats">ergm::ergm.allstats</a>.
</p>
</li>
<li> <p><code>target_offset</code>,<code>stats_offset</code> A vector of offset terms and a list of
vectors of offset terms, one for the target stats and the other for the
support of the sufficient statistics (defaults to 0).
</p>
</li>
<li> <p><code>model</code> A formula. The model passed.
</p>
</li>
<li> <p><code>npars</code> Integer. Number of parameters.
</p>
</li>
<li> <p><code>nnets</code> Integer. Number of networks in the model.
</p>
</li>
<li> <p><code>vertex_attr</code> Character vector. Vertex attributes used in the model.
</p>
</li>
<li> <p><code>term_names</code> Names of the terms used in the model.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>data(fivenets)
model0 &lt;- ergmito_formulae(fivenets ~ edges + nodematch("female"))
print(model0)
model0$loglik(c(-2, 2))

# Model with interaction effects and an offset term
model1 &lt;- ergmito_formulae(
  fivenets ~ edges + nodematch("female"),
  model_update = ~ . + offset(edges) + I(edges * nodematch.female)
)
</code></pre>

<hr>
<h2 id='ergmito_gof'>Goodness of Fit diagnostics for ERGMito models</h2><span id='topic+ergmito_gof'></span><span id='topic+gof_ergmito'></span><span id='topic+plot.ergmito_gof'></span>

<h3>Description</h3>

<p>Goodness of Fit diagnostics for ERGMito models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gof_ergmito(
  object,
  GOF = NULL,
  GOF_update = NULL,
  probs = c(0.05, 0.95),
  sim_ci = FALSE,
  R = 50000L,
  ncores = 1L,
  ...
)

## S3 method for class 'ergmito_gof'
plot(
  x,
  y = NULL,
  main = NULL,
  sub = NULL,
  tnames = NULL,
  sort_by_ci = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ergmito_gof_+3A_object">object</code></td>
<td>
<p>An object of class <a href="#topic+ergmito">ergmito</a>.</p>
</td></tr>
<tr><td><code id="ergmito_gof_+3A_gof">GOF</code></td>
<td>
<p>Formula. Additional set of parameters to perform the GOF.</p>
</td></tr>
<tr><td><code id="ergmito_gof_+3A_gof_update">GOF_update</code></td>
<td>
<p>Formula. See the section on model updating in <code><a href="#topic+ergmito_formulae">ergmito_formulae()</a></code>.</p>
</td></tr>
<tr><td><code id="ergmito_gof_+3A_probs">probs</code></td>
<td>
<p>Numeric vector. Quantiles to plot (see details).</p>
</td></tr>
<tr><td><code id="ergmito_gof_+3A_sim_ci">sim_ci</code></td>
<td>
<p>Logical scalar. If <code>FALSE</code>, the default, it will compute the
quantiles analytically, otherwise it samples from the ERGM distribution.</p>
</td></tr>
<tr><td><code id="ergmito_gof_+3A_r">R</code></td>
<td>
<p>Integer scalar. Number of simulations to generate (passed to <a href="base.html#topic+sample">sample</a>).
This is only used if <code>sim_ci = TRUE</code>.</p>
</td></tr>
<tr><td><code id="ergmito_gof_+3A_ncores">ncores</code></td>
<td>
<p>Integer scalar. Number of cores to use for parallel computations
(currently ignored).</p>
</td></tr>
<tr><td><code id="ergmito_gof_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <a href="stats.html#topic+quantile">stats::quantile</a>.</p>
</td></tr>
<tr><td><code id="ergmito_gof_+3A_x">x</code></td>
<td>
<p>An object of class <code>ergmito_gof</code>.</p>
</td></tr>
<tr><td><code id="ergmito_gof_+3A_y">y</code></td>
<td>
<p>Ignored.</p>
</td></tr>
<tr><td><code id="ergmito_gof_+3A_main">main</code>, <code id="ergmito_gof_+3A_sub">sub</code></td>
<td>
<p>Title and subtitle of the plot (see <a href="graphics.html#topic+title">graphics::title</a>).</p>
</td></tr>
<tr><td><code id="ergmito_gof_+3A_tnames">tnames</code></td>
<td>
<p>A named character vector. Alternative names for the terms.</p>
</td></tr>
<tr><td><code id="ergmito_gof_+3A_sort_by_ci">sort_by_ci</code></td>
<td>
<p>Logical scalar. When <code>TRUE</code> it will sort the x-axis by the
with of the CI in for the first parameter of the model.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Goodness of Fit function uses the fitted ERGMito to calculate a given confidence
interval for a set of sufficient statistics. By default (and currently the
only available option), this is done on the sufficient statistics specified
in the model.
</p>
<p>In detail, the algorithm is executed as follow:
</p>
<p>For every network in the list of networks do:
</p>

<ol>
<li><p> Calculate the probability of observing each possible graph in its support
using the fitted model.
</p>
</li>
<li><p> If <code>sim_ci = TRUE</code>, draw <code>R</code> samples from each set of parameters using the
probabilities computed. Then using the <code>quantile</code> function, calculate the desired
quantiles of the sufficient statistics. Otherwise, compute the quantiles using
the analytic quantiles using the full distribution.'
</p>
</li></ol>

<p>The plot method is particularly convenient since it graphically shows whether
the target statistics of the model (observed statistics) fall within the
simulated range.
</p>
<p>The print method tries to copy (explicitly) the print method of the
<code>gof</code> function from the <code>ergm</code> R package.
</p>


<h3>Value</h3>

<p>An object of class <code>ergmito_gof</code>. This is a list with the following
components:
</p>

<ul>
<li> <p><code>ci</code> A list of matrices of length <code>nnets(object)</code> with the corresponding
confidence intervals for the statistics of the model.
</p>
</li>
<li> <p><code>target_stats</code> A matrix of the target statistics.
</p>
</li>
<li> <p><code>ergmito.probs</code> A list of numeric vectors of length <code>nnets(object)</code> with the
probabilities associated to each possible structure of network.
</p>
</li>
<li> <p><code>probs</code> The value passed via <code>probs</code>.
</p>
</li>
<li> <p><code>model</code> The fitted model.
</p>
</li>
<li> <p><code>term_names</code> Character vector. Names of the terms used in the model.
</p>
</li>
<li> <p><code>quantile.args</code> A list of the values passed via <code>...</code>.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># Fitting the fivenets model
data(fivenets, package = "ergmito")
fit &lt;- ergmito(fivenets ~ edges + nodematch("female"))

# Calculating the gof
ans &lt;- gof_ergmito(fit)

# Looking at the results
ans
plot(ans)
</code></pre>

<hr>
<h2 id='exact_loglik'>Vectorized calculation of ERGM exact log-likelihood</h2><span id='topic+exact_loglik'></span><span id='topic+exact_loglik.default'></span><span id='topic+exact_gradient'></span><span id='topic+exact_gradient.default'></span><span id='topic+exact_hessian'></span>

<h3>Description</h3>

<p>This function can be compared to <a href="ergm.html#topic+ergm.exact">ergm::ergm.exact</a> with the statistics not
centered at <code>x</code>, the vector of observed statistics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>exact_loglik(x, params, ..., as_prob = FALSE)

## Default S3 method:
exact_loglik(
  x,
  params,
  stats_weights,
  stats_statmat,
  target_offset = double(nrow(x)),
  stats_offset = lapply(stats_weights, function(i) double(length(i))),
  ...,
  as_prob = FALSE
)

exact_gradient(x, params, ...)

## Default S3 method:
exact_gradient(
  x,
  params,
  stats_weights,
  stats_statmat,
  target_offset = double(nrow(x)),
  stats_offset = lapply(stats_weights, function(i) double(length(i))),
  ...
)

exact_hessian(
  params,
  stats_weights,
  stats_statmat,
  stats_offset = lapply(stats_weights, function(i) double(length(i)))
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="exact_loglik_+3A_x">x</code></td>
<td>
<p>Matrix. Observed statistics</p>
</td></tr>
<tr><td><code id="exact_loglik_+3A_params">params</code></td>
<td>
<p>Numeric vector. Parameter values of the model.</p>
</td></tr>
<tr><td><code id="exact_loglik_+3A_...">...</code></td>
<td>
<p>Arguments passed to the default methods.</p>
</td></tr>
<tr><td><code id="exact_loglik_+3A_as_prob">as_prob</code></td>
<td>
<p>Logical scalar. When <code>TRUE</code>, the function returns probabilities
instead of log-likelihoods.</p>
</td></tr>
<tr><td><code id="exact_loglik_+3A_stats_weights">stats_weights</code></td>
<td>
<p>Either an integer vector or a list of integer vectors (see <a href="#topic+exact_loglik">exact_loglik</a>).</p>
</td></tr>
<tr><td><code id="exact_loglik_+3A_stats_statmat">stats_statmat</code></td>
<td>
<p>Either a matrix or a list of matrices (see <a href="#topic+exact_loglik">exact_loglik</a>).</p>
</td></tr>
<tr><td><code id="exact_loglik_+3A_target_offset">target_offset</code></td>
<td>
<p>Numeric vector of length <code>nrow(target_stats)</code>.</p>
</td></tr>
<tr><td><code id="exact_loglik_+3A_stats_offset">stats_offset</code></td>
<td>
<p>List of numeric vectors, each of length equal to the
lengths of vectors in <code>stats_weights</code> (see details).</p>
</td></tr>
</table>


<h3>Sufficient statistics</h3>

<p>One of the most important components of <code>ergmito</code> is calculating the full
support of the model's sufficient statistics. Right now, the package uses
the function <a href="ergm.html#topic+ergm.allstats">ergm::ergm.allstats</a> which returns a list of two objects:
</p>

<ul>
<li> <p><code>weights</code>: An integer vector of counts.
</p>
</li>
<li> <p><code>statmat</code>: A numeric matrix with the rows as unique vectors of sufficient
statistics.
</p>
</li></ul>

<p>Since <code>ergmito</code> can vectorize operations, in order to specify weights and
statistics matrices for each network in the model, the user needs to pass
two lists <code>stats_weights</code> and <code>stats_statmat</code>. While both lists have to
have the same length (since its elements are matched), this needs not to
be the case with the networks, as the user can specify a single set of
weights and statistics that will be recycled (smartly).
</p>
<p>In the case of offset terms, these can be passed directly via <code>target_offset</code>
and <code>stats_offset</code>. The first is a numeric vector of length equal to the
number of networks in the model. The later is a list of vectors that is
matched against <code>stats_weights</code>, so each of it's elements must be a
numeric vector of the same length that in the list of weights. By default
the offset terms are set to equal zero.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(fivenets)
ans &lt;- ergmito(fivenets ~ edges + nodematch("female"))

# This computes the likelihood for all the networks independently
with(ans$formulae, {
  exact_loglik(
    x      = target_stats,
    params = coef(ans),
    stats_weights = stats_weights,
    stats_statmat = stats_statmat
  )
})

# This should be close to zero
with(ans$formulae, {
  exact_gradient(
    x      = target_stats,
    params = coef(ans),
    stats_weights = stats_weights,
    stats_statmat = stats_statmat
  )
})

# Finally, the hessian
with(ans$formulae, {
  exact_hessian(
    params = coef(ans),
    stats_weights = stats_weights,
    stats_statmat = stats_statmat
  )
})

</code></pre>

<hr>
<h2 id='extract.ergmito'>Extract function to be used with the <code>texreg</code> package.</h2><span id='topic+extract.ergmito'></span>

<h3>Description</h3>

<p>To be used with the <a href="https://CRAN.R-project.org/package=texreg"><span class="pkg">texreg</span></a> package. This function can be used to
generate nice looking tables of ERGMitos estimates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract.ergmito(
  model,
  include.aic = TRUE,
  include.bic = TRUE,
  include.loglik = TRUE,
  include.nnets = TRUE,
  include.offset = TRUE,
  include.convergence = TRUE,
  include.timing = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="extract.ergmito_+3A_model">model</code></td>
<td>
<p>An object of class <code>ergmito</code>.</p>
</td></tr>
<tr><td><code id="extract.ergmito_+3A_include.aic">include.aic</code>, <code id="extract.ergmito_+3A_include.bic">include.bic</code>, <code id="extract.ergmito_+3A_include.loglik">include.loglik</code></td>
<td>
<p>See <a href="texreg.html#topic+extract">texreg::extract</a>.</p>
</td></tr>
<tr><td><code id="extract.ergmito_+3A_include.nnets">include.nnets</code></td>
<td>
<p>Logical. When true, it adds the Number of networks used
to the list of gof statistics. This can be useful when running pooled models.</p>
</td></tr>
<tr><td><code id="extract.ergmito_+3A_include.offset">include.offset</code></td>
<td>
<p>Logical. When equal to <code>TRUE</code>, it adds one line per
offset term to the table, omiting sd and significance.</p>
</td></tr>
<tr><td><code id="extract.ergmito_+3A_include.convergence">include.convergence</code></td>
<td>
<p>Logical. When true it, adds the convergence value
of the <a href="stats.html#topic+optim">stats::optim</a> function (0 means convergence).</p>
</td></tr>
<tr><td><code id="extract.ergmito_+3A_include.timing">include.timing</code></td>
<td>
<p>Logical, When true it will report the elapsed time
in seconds.</p>
</td></tr>
<tr><td><code id="extract.ergmito_+3A_...">...</code></td>
<td>
<p>Further arguments passed to the <code><a href="base.html#topic+summary">base::summary()</a></code> of <a href="#topic+ergmito">ergmito</a>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
library(texreg)
data(fivenets)
ans &lt;- ergmito(fivenets ~ edges + nodematch("female"))
screenreg(ans)

</code></pre>

<hr>
<h2 id='fivenets'>Example of a group of small networks</h2><span id='topic+fivenets'></span>

<h3>Description</h3>

<p>This list of networks was generated using the <a href="#topic+new_rergmito">new_rergmito</a> sampler from a
set of 5 baseline networks with a random vector of <code>female</code>. The sufficient
statistics that generate this data are <code>edges</code> and  <code>nodematch("female")</code> with parameters
-2.0 and 2.0 respectively.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fivenets
</code></pre>


<h3>Format</h3>

<p>An object of class <code>list</code> of length 5.
</p>

<hr>
<h2 id='geodesic'>Geodesic distance matrix (all pairs)</h2><span id='topic+geodesic'></span><span id='topic+geodesita'></span><span id='topic+geodesic.matrix'></span><span id='topic+geodesic.network'></span>

<h3>Description</h3>

<p>Calculates the shortest path between all pairs of vertices in a network.
This uses the power matrices to do so, which makes it efficient only for
small networks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geodesic(x, force = FALSE, ...)

geodesita(x, force = FALSE, ...)

## S3 method for class 'matrix'
geodesic(x, force = FALSE, simplify = FALSE, ...)

## S3 method for class 'network'
geodesic(x, force = FALSE, simplify = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="geodesic_+3A_x">x</code></td>
<td>
<p>Either a list of networks (or square integer matrices), an integer
matrix, a network, or an ergmito.</p>
</td></tr>
<tr><td><code id="geodesic_+3A_force">force</code></td>
<td>
<p>Logical scalar. If <code>force = FALSE</code> (the default) and <code>nvertex(x) &gt; 100</code>
it returns with an error. To force computation use <code>force = TRUE</code>.</p>
</td></tr>
<tr><td><code id="geodesic_+3A_...">...</code></td>
<td>
<p>Further arguments passed to the method.</p>
</td></tr>
<tr><td><code id="geodesic_+3A_simplify">simplify</code></td>
<td>
<p>Logical scalar. When <code>TRUE</code> it returns a matrix, otherwise,
a list of length <code>nnets(x)</code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data(fivenets)
geodesic(fivenets)

# Comparing with sna
if (require("sna")) {
  net0 &lt;- fivenets[[1]]
  net  &lt;- network::network(fivenets[[1]])
  benchmarkito(
    ergmito = ergmito::geodesic(net0),
    sna     = sna::geodist(net), times = 1000
  )
}
</code></pre>

<hr>
<h2 id='induced_submat'>Extract a submatrix from a network</h2><span id='topic+induced_submat'></span>

<h3>Description</h3>

<p>This is similar to <a href="network.html#topic+get.inducedSubgraph">network::get.inducedSubgraph</a>. The main difference is that
the resulting object will always be a list of matrices, and it is vectorized.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>induced_submat(x, v, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="induced_submat_+3A_x">x</code></td>
<td>
<p>Either a list or single matrices or network objects.</p>
</td></tr>
<tr><td><code id="induced_submat_+3A_v">v</code></td>
<td>
<p>Either a list or a single integer vector of vertices to subset.</p>
</td></tr>
<tr><td><code id="induced_submat_+3A_...">...</code></td>
<td>
<p>Currently ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Depending on the lengths of <code>x</code> and <code>v</code>, the function can take the
following strategies:
</p>

<ul>
<li><p> If both are of the same size, then it will match the networks and the vector
of indices.
</p>
</li>
<li><p> If <code>length(x) == 1</code>, then it will use that single network as a baseline
for generating the subgraphs.
</p>
</li>
<li><p> If <code>length(v) == 1</code>, then it will generate the subgraph using the same set
of vertices for each network.
</p>
</li>
<li><p> If both have more than one element, but different sizes, then the function
returns with an error.
</p>
</li></ul>



<h3>Value</h3>

<p>A list of matrices as a result of the subsetting.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rbernoulli(100)
induced_submat(x, c(1, 10, 30:50))

x &lt;- rbernoulli(c(20, 20))
induced_submat(x, c(1:10))

</code></pre>

<hr>
<h2 id='matrix_to_network'>Manipulation of network objects</h2><span id='topic+matrix_to_network'></span><span id='topic+matrix_to_network.matrix'></span>

<h3>Description</h3>

<p>This function implements a vectorized version of <a href="network.html#topic+network">network::network</a><code>.adjmat</code>.
It allows us to turn regular matrices into network objects quickly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>matrix_to_network(x, ...)

## S3 method for class 'matrix'
matrix_to_network(
  x,
  directed = rep(TRUE, length(x)),
  hyper = rep(FALSE, length(x)),
  loops = rep(FALSE, length(x)),
  multiple = rep(FALSE, length(x)),
  bipartite = rep(FALSE, length(x)),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="matrix_to_network_+3A_x">x</code></td>
<td>
<p>Either a single square matrix (adjacency matrix), or a list of these.</p>
</td></tr>
<tr><td><code id="matrix_to_network_+3A_...">...</code></td>
<td>
<p>Further arguments passed to the method.</p>
</td></tr>
<tr><td><code id="matrix_to_network_+3A_directed">directed</code></td>
<td>
<p>Logical scalar, if <code>FALSE</code> then the function only checks the
upper diagonal of the matrix assuming it is undirected.</p>
</td></tr>
<tr><td><code id="matrix_to_network_+3A_hyper">hyper</code>, <code id="matrix_to_network_+3A_multiple">multiple</code>, <code id="matrix_to_network_+3A_bipartite">bipartite</code></td>
<td>
<p>Currently Ignored. Right now all the network objects
created by this function set these parameters as <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="matrix_to_network_+3A_loops">loops</code></td>
<td>
<p>Logical scalar. When <code>FALSE</code> (default) it will skip the diagonal
of the adjacency matrix.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This version does not support adding the name parameter yet. The
function in the network package includes the name of the vertices as an
attribute.
</p>
<p>Just like in the network function, <code>NA</code> are checked and added accordingly, i.e.
if there is an <code>NA</code> in the matrix, then the value is recorded as a missing edge.
</p>


<h3>Value</h3>

<p>An object of class <code>network</code>. This is a list with the following elements:
</p>

<ul>
<li> <p><code>mel</code> <em>Master Edge List</em>: A named list with length equal to the number of edges in
the network. The list itself has 3 elements: <code>inl</code> (tail), <code>outl</code> (head), and
<code>atl</code> (attribute). By default <code>atl</code>, a list itself, has a single element: <code>na</code>.
</p>
</li>
<li> <p><code>gal</code> <em>Graph Attributes List</em>: a named list with the following elements:
</p>

<ul>
<li> <p><code>n</code> Number of nodes
</p>
</li>
<li> <p><code>mnext</code> Number of edges + 1
</p>
</li>
<li> <p><code>directed</code>,<code>hyper</code>,<code>loops</code>,<code>multiple</code>,<code>bipartite</code> The arguments passed to
the function.
</p>
</li></ul>

</li>
<li> <p><code>val</code> <em>Vertex Attributes List</em>
</p>
</li>
<li> <p><code>iel</code> <em>In Edgest List</em>
</p>
</li>
<li> <p><code>oel</code> <em>Out Edgest List</em>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>set.seed(155)
adjmats  &lt;- rbernoulli(rep(5, 20))
networks &lt;- matrix_to_network(adjmats)

</code></pre>

<hr>
<h2 id='new_ergmito_ptr'>Creates a new <code>ergmito_ptr</code></h2><span id='topic+new_ergmito_ptr'></span>

<h3>Description</h3>

<p>After calculating the support of the sufficient statistics, the second
most computationally expensive task is computing log-likelihoods,
Gradients, and Hessian matrices of ERGMs. This function creates a pointer to an
underlying class that is optimized to improve memory allocation and
save computation time when possible.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>new_ergmito_ptr(
  target_stats,
  stats_weights,
  stats_statmat,
  target_offset,
  stats_offset
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="new_ergmito_ptr_+3A_target_stats">target_stats</code>, <code id="new_ergmito_ptr_+3A_stats_weights">stats_weights</code>, <code id="new_ergmito_ptr_+3A_stats_statmat">stats_statmat</code>, <code id="new_ergmito_ptr_+3A_target_offset">target_offset</code>, <code id="new_ergmito_ptr_+3A_stats_offset">stats_offset</code></td>
<td>
<p>see <a href="#topic+exact_loglik">exact_loglik</a>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is for internal used only. Non-advanced users
are not encouraged to use it. See <a href="#topic+ergmito_formulae">ergmito_formulae</a> and <a href="#topic+exact_loglik">exact_loglik</a>
for user friendly wrappers of this function.
</p>


<h3>Recycling computations</h3>

<p>Some components of the likelihood, its gradient, and hessian can be
pre-computed and recycled when needed. For example, it is usually the
case that in optimization gradients are computed using a current state
of the model's parameter, which implies that the normalizing constant
and some other matrix products will be the same between the log-likelihood
and the gradient. Because of this, the underlying class <code>ergmito_ptr</code>
will only re-calculate these shared components if the parameter used
changes as well. This saves a significant amount of computation time.
</p>


<h3>Scope of the class methods</h3>

<p>To save space, the class creates pointers to the matrices of sufficient
statistics that the model uses. This means that once these objects are
deleted the log-likelihood and the gradient functions become invalid
from the computational point of view.
</p>

<hr>
<h2 id='new_rergmito'>ERGMito sampler</h2><span id='topic+new_rergmito'></span><span id='topic++5B.ergmito_sampler'></span>

<h3>Description</h3>

<p>Create a sampler object that allows you simulating streams of small networks
fast.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>new_rergmito(model, theta, ...)

## S3 method for class 'ergmito_sampler'
x[i, ...]
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="new_rergmito_+3A_model">model</code></td>
<td>
<p>A formula.</p>
</td></tr>
<tr><td><code id="new_rergmito_+3A_theta">theta</code></td>
<td>
<p>Named vector. Model parameters.</p>
</td></tr>
<tr><td><code id="new_rergmito_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code><a href="#topic+ergmito_formulae">ergmito_formulae()</a></code>.</p>
</td></tr>
<tr><td><code id="new_rergmito_+3A_x">x</code></td>
<td>
<p>An object of class <code>ergmito_sampler</code>.</p>
</td></tr>
<tr><td><code id="new_rergmito_+3A_i">i</code></td>
<td>
<p><code>i</code> is an integer vector indicating the indexes of the networks to
draw.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>While the <a href="https://CRAN.R-project.org/package=ergm"><span class="pkg">ergm</span></a> package is very efficient, it was not built to do some
of the computations required in the ergmito package. This translates in having
some of the functions of the package (ergm) with poor speed performance. This
led us to &quot;reinvent the wheel&quot; in some cases to speed things up, this includes
calculating observed statistics in a list of networks.
</p>
<p>The indexing method, <code style="white-space: pre;">&#8288;[.ergmito_sampler&#8288;</code>, allows extracting networks
directly by passing indexes. <code>i</code> indicates the index of the networks to draw,
which go from 1 through <code>2^(n*(n-1))</code> if directed and <code>2^(n*(n-1)/2)</code> if
undirected .
</p>


<h3>Value</h3>

<p>An environment with the following objects:
</p>

<ul>
<li> <p><code>calc_prob</code> A function to calculate each graph's probability under the
specified model.
</p>
</li>
<li> <p><code>call</code> A language object with the call.
</p>
</li>
<li> <p><code>counts</code> A list with 3 elements: <code>stats</code> the sufficient statistics of each network,
<code>weights</code> and <code>statmat</code> the overall matrices of sufficient statistics used to
compute the likelihood.
</p>
</li>
<li> <p><code>network</code> The baseline network used to either fit the model or obtain
attributes.
</p>
</li>
<li> <p><code>networks</code> A list with the actual sample space of networks.
</p>
</li>
<li> <p><code>probabilities</code> A numeric vector with each graph's probability.
</p>
</li>
<li> <p><code>sample</code> A function to draw samples. <code>n</code> specifies the number of samples to
draw and <code>theta</code> the parameter to use to calculate the likelihoods.
</p>
</li>
<li> <p><code>theta</code> Named numeric vector with the current values of the model parameters.
</p>
</li></ul>

<p>The indexing method <code style="white-space: pre;">&#8288;[.ergmito_sampler&#8288;</code> returns a list of networks
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# We can generate a sampler from a random graph
set.seed(7131)
ans &lt;- new_rergmito(rbernoulli(4) ~ edges, theta = -.5)

# Five samples
ans$sample(5)

# or we can use some nodal data:
data(fivenets)
ans &lt;- new_rergmito(
  fivenets[[3]] ~ edges + nodematch("female"),
  theta = c(-1, 1)
)

# Five samples
ans$sample(5) # All these networks have a "female" vertex attr

</code></pre>

<hr>
<h2 id='nvertex'>Utility functions to query network dimensions</h2><span id='topic+nvertex'></span><span id='topic+nedges'></span><span id='topic+nnets'></span><span id='topic+is_directed'></span>

<h3>Description</h3>

<p>Utility functions to query network dimensions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nvertex(x)

nedges(x, ...)

nnets(x)

is_directed(x, check_type = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nvertex_+3A_x">x</code></td>
<td>
<p>Either an object of class <a href="#topic+ergmito">ergmito</a>, <a href="network.html#topic+network">network</a>, <a href="stats.html#topic+formula">formula</a>, or <a href="base.html#topic+matrix">matrix</a>.</p>
</td></tr>
<tr><td><code id="nvertex_+3A_...">...</code></td>
<td>
<p>Further arguments passed to the method. Currently only <code>nedges.network</code>
receives arguments (see <a href="network.html#topic+network.edgecount">network::network.edgecount</a>).</p>
</td></tr>
<tr><td><code id="nvertex_+3A_check_type">check_type</code></td>
<td>
<p>Logical scalar. When checking for whether the network is
directed or not, we can ask the function to return with an error if what we
are checking is not an object of class network, otherwise it simply returns
false.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>is_directed</code> checks whether the passed networks are directed using
the function <code><a href="network.html#topic+network.indicators">is.directed</a></code>. In the case of multiple networks,
the function returns a logical vector. Only objects of class <code>network</code> can be
checked, otherwise, if <code>check_type = FALSE</code>, the function returns <code>TRUE</code> by default.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(771)
net &lt;- lapply(rbernoulli(c(4, 4)), network::network, directed = FALSE)
is_directed(net)
is_directed(net[[1]])
is_directed(net ~ edges)
## Not run: 
  is_directed(net[[1]][1:4, 1:4], check_type = TRUE) # Error

## End(Not run)
is_directed(net[[1]][1:4, 1:4])
</code></pre>

<hr>
<h2 id='plot.ergmito'>Function to visualize the optimization surface</h2><span id='topic+plot.ergmito'></span>

<h3>Description</h3>

<p>General diagnostics function. This function allows to visualize the surface
to be maximize at around a particular point.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ergmito'
plot(
  x,
  y = NULL,
  domain = NULL,
  plot. = TRUE,
  par_args = list(),
  image_args = list(),
  breaks = 20L,
  extension = 4L,
  params_labs = stats::setNames(names(coef(x)), names(coef(x))),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.ergmito_+3A_x">x</code></td>
<td>
<p>An object of class <a href="#topic+ergmito">ergmito</a>.</p>
</td></tr>
<tr><td><code id="plot.ergmito_+3A_y">y</code>, <code id="plot.ergmito_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
<tr><td><code id="plot.ergmito_+3A_domain">domain</code></td>
<td>
<p>A list.</p>
</td></tr>
<tr><td><code id="plot.ergmito_+3A_plot.">plot.</code></td>
<td>
<p>Logical. When <code>TRUE</code> (default), the function will call <a href="graphics.html#topic+image">graphics::image</a>
and plot all possible combination of parameters.</p>
</td></tr>
<tr><td><code id="plot.ergmito_+3A_par_args">par_args</code></td>
<td>
<p>Further arguments to be passed to <a href="graphics.html#topic+par">graphics::par</a></p>
</td></tr>
<tr><td><code id="plot.ergmito_+3A_image_args">image_args</code></td>
<td>
<p>Further arguments to be passed to <a href="graphics.html#topic+image">graphics::image</a></p>
</td></tr>
<tr><td><code id="plot.ergmito_+3A_breaks">breaks</code></td>
<td>
<p>Integer scalar. Number of splits per dimension.</p>
</td></tr>
<tr><td><code id="plot.ergmito_+3A_extension">extension</code></td>
<td>
<p>Numeric. Range value of the function.</p>
</td></tr>
<tr><td><code id="plot.ergmito_+3A_params_labs">params_labs</code></td>
<td>
<p>Named vector. Alternative labels for the parameters. It
should be in the form of <code>c("orignial name" = "new name")</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It calculates the surface coordinates for each pair of parameters included
in the ERGMito.
</p>


<h3>Value</h3>

<p>A list of length <code>choose(length(object$coef), 2)</code> (all possible
combinations of pairs of parameters), each with the following elements:
</p>

<ul>
<li> <p><code>z</code> A matrix
</p>
</li>
<li> <p><code>z</code> A vector
</p>
</li>
<li> <p><code>y</code> A vector
</p>
</li>
<li> <p><code>xlab</code> A string. Name of the ERGM parameter in the x-axis.
</p>
</li>
<li> <p><code>ylab</code> A string. Name of the ERGM parameter in the y-axis.
</p>
</li></ul>

<p>The list is returned invisible.
</p>


<h3>See Also</h3>

<p>The <a href="#topic+ergmito">ergmito</a> function.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(12)
x &lt;- rbernoulli(c(4, 4, 5))

ans &lt;- ergmito(x ~ edges + balance)

plot(ans)

</code></pre>

<hr>
<h2 id='powerset'>Power set of Graphs of size <code>n</code></h2><span id='topic+powerset'></span>

<h3>Description</h3>

<p>Generates the set of all possible binary networks of size <code>n</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>powerset(n, directed = TRUE, force = FALSE, chunk_size = 2e+05)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="powerset_+3A_n">n</code></td>
<td>
<p>Integer. Number of edges.</p>
</td></tr>
<tr><td><code id="powerset_+3A_directed">directed</code></td>
<td>
<p>Logical scalar. Whether to generate the power set of directed
or undirected graphs,</p>
</td></tr>
<tr><td><code id="powerset_+3A_force">force</code></td>
<td>
<p>Logical scalar. When <code>TRUE</code> it generates the power set for <code>n&gt;5</code>,
otherwise it returns with error.</p>
</td></tr>
<tr><td><code id="powerset_+3A_chunk_size">chunk_size</code></td>
<td>
<p>Number of matrices to process at a time. If n = 5, then
stack memory on the computer may overflow if <code>chunk_size</code> is relatively large.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>powerset(2)
powerset(4, directed = FALSE)
</code></pre>

<hr>
<h2 id='predict.ergmito'>Prediction method for <code>ergmito</code> objects</h2><span id='topic+predict.ergmito'></span>

<h3>Description</h3>

<p>Takes an <a href="#topic+ergmito">ergmito</a> object and makes prediction at tie level. See details for
information regarding its implementation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ergmito'
predict(object, newdata = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict.ergmito_+3A_object">object</code></td>
<td>
<p>An object of class <a href="#topic+ergmito">ergmito</a>.</p>
</td></tr>
<tr><td><code id="predict.ergmito_+3A_newdata">newdata</code></td>
<td>
<p>New set of networks (or network) on which to make the prediction.</p>
</td></tr>
<tr><td><code id="predict.ergmito_+3A_...">...</code></td>
<td>
<p>Passed to <a href="#topic+new_rergmito">new_rergmito</a>, the workhorse of this method.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>After fitting a model with a small network (or a set of them), we
can use the parameter estimates to calculate the likelihood of observing any
given tie in the network, this is, the marginal probabilites at the tie level.
</p>
<p>In particular, the function takes the full set of networks on the support of
the model and adds them up weighted by the probability of observing them as
predicted by the ERGM, formally:
</p>
<p style="text-align: center;"><code class="reqn">%
\hat{A} = \sum_i \mathbf{Pr}(A = a_i)\times a_i
</code>
</p>

<p>Where <code class="reqn">\hat{A}</code> is the predicted adjacency matrix, and
<code class="reqn">a_i</code> is the i-th network in the support of the model. This calculation
is done for each individual network used in the model.
</p>


<h3>Value</h3>

<p>A list of adjacency matrix of length <code>nnets(object)</code> or, if
specified <code>nnets(newdata)</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(fivenets)

# bernoulli graph
fit &lt;- ergmito(fivenets ~ edges) 

# all ties have the same likelihood
# which is roughly equal to:
# mean(nedges(fivenets)/(nvertex(fivenets)*(nvertex(fivenets) - 1)))
predict(fit) 


# If we take into account vertex attributes, now the story is different!
fit &lt;- ergmito(fivenets ~ edges + nodematch("female")) 

# Not all ties have the same likelihood, since it depends on homophily!
predict(fit) 
</code></pre>

<hr>
<h2 id='rbernoulli'>Random Bernoulli graph</h2><span id='topic+rbernoulli'></span>

<h3>Description</h3>

<p>Random Bernoulli graph
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rbernoulli(n, p = 0.5)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rbernoulli_+3A_n">n</code></td>
<td>
<p>Integer vector. Size of the graph. If <code>length(n) &gt; 1</code>, then it will
a list of random graphs.</p>
</td></tr>
<tr><td><code id="rbernoulli_+3A_p">p</code></td>
<td>
<p>Probability of a tie. This may be either a scalar, or a vector of the
same length of <code>n</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>n</code> is a single number, a square matrix of size <code>n</code> with zeros in
the diagonal. Otherwise it returns a list of <code>length(n)</code> square matrices of
sizes equal to those specified in <code>n</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># A graph of size 4
rbernoulli(4)

# 3 graphs of various sizes
rbernoulli(c(3, 4, 2))

# 3 graphs of various sizes and different probabilities
rbernoulli(c(3, 4, 6), c(.1, .2, .3))
</code></pre>

<hr>
<h2 id='same_dist'>Compare pairs of networks to see if those came from the same distribution</h2><span id='topic+same_dist'></span>

<h3>Description</h3>

<p>If two networks are of the same size, and their vertex attributes are
equal in terms of set comparison, then we say those came from the same
distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>same_dist(net0, net1, attrnames = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="same_dist_+3A_net0">net0</code>, <code id="same_dist_+3A_net1">net1</code></td>
<td>
<p>Networks to be compared.</p>
</td></tr>
<tr><td><code id="same_dist_+3A_attrnames">attrnames</code></td>
<td>
<p>Character vector. (optional) Names of the vertex attributes
to be be compared on. This is ignored in the matrix case.</p>
</td></tr>
<tr><td><code id="same_dist_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is used during the call of <a href="#topic+ergmito_formulae">ergmito_formulae</a> to
check whether the function can recycle previously computed statistics for
the likelihood function. In the case of models that only contain structural
terms, i.e. attribute less, this can save significant amount of computing
time and memory.
</p>


<h3>Value</h3>

<p>A logical with an attribute <code>what</code>. <code>TRUE</code> meaning that the two
networks come from the same distribution, and <code>FALSE</code> meaning that they do
not. If <code>FALSE</code> the <code>what</code> attribute will be equal to either <code>"size"</code> or
the name of the attribute that failed the comparison.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(fivenets)
same_dist(fivenets[[1]], fivenets[[2]]) # Yes, same size
same_dist(fivenets[[1]], fivenets[[2]], "female") # No, different attr dist
</code></pre>

<hr>
<h2 id='simulate.ergmito'>Draw samples from a fitted <code>ergmito</code> model</h2><span id='topic+simulate.ergmito'></span>

<h3>Description</h3>

<p>Draw samples from a fitted <code>ergmito</code> model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ergmito'
simulate(object, nsim = 1, seed = NULL, which_networks = 1L, theta = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="simulate.ergmito_+3A_object">object</code></td>
<td>
<p>An object of class <a href="#topic+ergmito">ergmito</a>.</p>
</td></tr>
<tr><td><code id="simulate.ergmito_+3A_nsim">nsim</code></td>
<td>
<p>Integer scalar. Number of samples to draw from the selected set
of networks.</p>
</td></tr>
<tr><td><code id="simulate.ergmito_+3A_seed">seed</code></td>
<td>
<p>See <a href="stats.html#topic+simulate">stats::simulate</a></p>
</td></tr>
<tr><td><code id="simulate.ergmito_+3A_which_networks">which_networks</code></td>
<td>
<p>Integer vector. Specifies what networks to sample from.
It must be within 1 and <code>nnets(object)</code>.</p>
</td></tr>
<tr><td><code id="simulate.ergmito_+3A_theta">theta</code>, <code id="simulate.ergmito_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <a href="#topic+new_rergmito">new_rergmito</a>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data(fivenets)
fit &lt;- ergmito(fivenets ~ edges + nodematch("female"))

# Drawing 200 samples from networks 1 and 3 from the model
ans &lt;- simulate(fit, nsim = 200, which_networks = c(1, 3))
</code></pre>

<hr>
<h2 id='vcov.ergmito'>Estimation of ERGMs using Maximum Likelihood Estimation (MLE)</h2><span id='topic+vcov.ergmito'></span><span id='topic+ergmito'></span>

<h3>Description</h3>

<p><code>ergmito</code> uses Maximum Likelihood Estimation (MLE) to fit Exponential Random
Graph Models for single or multiple small networks, the later using
pooled-data MLE. To do so we use exact likelihoods, which implies fully
enumerating the support of the model. Overall, the exact likelihood
calculation is only possible when dealing with directed (undirected) networks
size 5 (7). In general, directed (undirected) graphs with more than 5 (7)
vertices should not be fitted using MLE, but instead other methods such as
the MC-MLE algorithm or the Robbins-Monro Stochastic Approximation algorithm,
both of which are available in the ergm R package.The workhorse function of
<code>ergmito</code> is the <code>ergm</code> package function <code><a href="ergm.html#topic+ergm.allstats">ergm::ergm.allstats()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ergmito'
vcov(object, solver = NULL, ...)

ergmito(
  model,
  model_update = NULL,
  stats_weights = NULL,
  stats_statmat = NULL,
  optim.args = list(),
  init = NULL,
  use.grad = TRUE,
  target_stats = NULL,
  ntries = 1L,
  keep.stats = TRUE,
  target_offset = NULL,
  stats_offset = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vcov.ergmito_+3A_object">object</code></td>
<td>
<p>An object of class <code>ergmito</code></p>
</td></tr>
<tr><td><code id="vcov.ergmito_+3A_solver">solver</code></td>
<td>
<p>Function. Used to compute the inverse of the hessian matrix. When
not null, the variance-covariance matrix is recomputed using that function.
By default, <code>ergmito</code> uses <a href="MASS.html#topic+ginv">MASS::ginv</a>.</p>
</td></tr>
<tr><td><code id="vcov.ergmito_+3A_...">...</code></td>
<td>
<p>Further arguments passed to the method. In the case of <code>ergmito</code>,
<code>...</code> are passed to <a href="#topic+ergmito_formulae">ergmito_formulae</a>.</p>
</td></tr>
<tr><td><code id="vcov.ergmito_+3A_model">model</code></td>
<td>
<p>Model to estimate. See <a href="ergm.html#topic+ergm">ergm::ergm</a>. The only difference with
<code>ergm</code> is that the LHS can be a list of networks.</p>
</td></tr>
<tr><td><code id="vcov.ergmito_+3A_model_update">model_update</code></td>
<td>
<p>A <code><a href="stats.html#topic+formula">formula</a></code>. this can be used to
apply transformations, create interaction effects, add offset terms, etc.
(see examples below and more details in <a href="#topic+ergmito_formulae">ergmito_formulae</a>).</p>
</td></tr>
<tr><td><code id="vcov.ergmito_+3A_stats_weights">stats_weights</code></td>
<td>
<p>Either an integer vector or a list of integer vectors (see <a href="#topic+exact_loglik">exact_loglik</a>).</p>
</td></tr>
<tr><td><code id="vcov.ergmito_+3A_stats_statmat">stats_statmat</code></td>
<td>
<p>Either a matrix or a list of matrices (see <a href="#topic+exact_loglik">exact_loglik</a>).</p>
</td></tr>
<tr><td><code id="vcov.ergmito_+3A_optim.args">optim.args</code></td>
<td>
<p>List. Passed to <a href="stats.html#topic+optim">stats::optim</a>.</p>
</td></tr>
<tr><td><code id="vcov.ergmito_+3A_init">init</code></td>
<td>
<p>A numeric vector. Sets the starting parameters for the
optimization routine. Default is a vector of zeros.</p>
</td></tr>
<tr><td><code id="vcov.ergmito_+3A_use.grad">use.grad</code></td>
<td>
<p>Logical. When <code>TRUE</code> passes the gradient function to <code>optim</code>.
This is intended for testing only (internal use).</p>
</td></tr>
<tr><td><code id="vcov.ergmito_+3A_target_stats">target_stats</code></td>
<td>
<p>A matrix of target statistics (see <a href="ergm.html#topic+ergm">ergm::ergm</a>).</p>
</td></tr>
<tr><td><code id="vcov.ergmito_+3A_ntries">ntries</code></td>
<td>
<p>Integer scalar. Number of tries to estimate the MLE (see details).</p>
</td></tr>
<tr><td><code id="vcov.ergmito_+3A_keep.stats">keep.stats</code></td>
<td>
<p>Logical scalar. When <code>TRUE</code> (the default), the matrices
and vectors associated with the sufficient statistics will be returned.
Otherwise the function discards them. This may be useful for saving memory
space when estimating multiple models.</p>
</td></tr>
<tr><td><code id="vcov.ergmito_+3A_target_offset">target_offset</code>, <code id="vcov.ergmito_+3A_stats_offset">stats_offset</code></td>
<td>
<p>See <code><a href="#topic+exact_loglik">exact_loglik()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The support of the sufficient statistics is calculated using ERGM's
<code><a href="ergm.html#topic+ergm.allstats">ergm::ergm.allstats()</a></code> function.
</p>


<h3>Value</h3>

<p>An list of class <code>ergmito</code>:
</p>

<ul>
<li> <p><code>call</code>          The program call.
</p>
</li>
<li> <p><code>coef</code>          Named vector. Parameter estimates.
</p>
</li>
<li> <p><code>iterations</code>    Integer. Number of times the log-likelihood was evaluated
(see <a href="stats.html#topic+optim">stats::optim</a>).
</p>
</li>
<li> <p><code>mle.lik</code>       Numeric. Final value of the objective function.
</p>
</li>
<li> <p><code>null.lik</code>      Numeric. Final value of the objective function for the null model.
</p>
</li>
<li> <p><code>covar</code>         Square matrix of size <code>length(coef)</code>. Variance-covariance matrix
computed using the exact hessian as implemented in <a href="#topic+exact_hessian">exact_hessian</a>.
</p>
</li>
<li> <p><code>coef.init</code>     Named vector of length <code>length(coef)</code>. Initial set of parameters
used in the optimization.
</p>
</li>
<li> <p><code>formulae</code>      An object of class <a href="#topic+ergmito_formulae">ergmito_loglik</a>.
</p>
</li>
<li> <p><code>nobs</code>          Integer scalar. Number of networks in the model.
</p>
</li>
<li> <p><code>network</code>       Networks passed via <code>model</code>.
</p>
</li>
<li> <p><code>optim.out</code>,<code>optim.args</code> Results from the optim call and arguments passed to it.
</p>
</li>
<li> <p><code>status</code>,<code>note</code> Convergence code. See <a href="#topic+check_convergence">check_convergence</a>
</p>
</li>
<li> <p><code>best_try</code>      Integer scalar. Index of the run with the highest log-likelihood value.
</p>
</li>
<li> <p><code>history</code>       Matrix of size <code>ntries * (k + 1)</code>. History of the parameter
estimates and the reached log-likelihood values.
</p>
</li>
<li> <p><code>timer</code>         Vector of times (for benchmarking). Each unit marks the starting
point of the step.
</p>
</li></ul>

<p>Methods <code><a href="base.html#topic+print">base::print()</a></code>, <code><a href="base.html#topic+summary">base::summary()</a></code>, <code><a href="stats.html#topic+coef">stats::coef()</a></code>, <code><a href="stats.html#topic+logLik">stats::logLik()</a></code>,
<code><a href="stats.html#topic+nobs">stats::nobs()</a></code>, <code><a href="stats.html#topic+vcov">stats::vcov()</a></code>, <code><a href="stats.html#topic+AIC">stats::AIC()</a></code>, <code><a href="stats.html#topic+AIC">stats::BIC()</a></code>,
<code><a href="stats.html#topic+confint">stats::confint()</a></code>, and  <code><a href="stats.html#topic+formula">stats::formula()</a></code> are available.
</p>


<h3>MLE</h3>

<p>Maximum Likelihood Estimates are obtained using the <a href="stats.html#topic+optim">stats::optim</a> function.
The default method for maximization is <code>BFGS</code> using both the log-likelihood
function and its corresponding gradient.
</p>
<p>Another important factor to consider is the existence of the MLE estimates
As shown in Handcock (2003), if the observed statistics are near the border
if the support function (e.g. too many edges or almost none), then, even if
the MLE estimates exists, the optimization function may not be able to reach
the optima. Moreover, if the target (observed) statistics live in the boundary,
then the MLE estimates do not exists. In general, this should not be an issue
in the context of the pooled model, as the variability of observed statistics
should be enough to avoid those situations.
</p>
<p>The function <code>ergmito</code> will try to identify possible cases of non-existence,
of the MLE, and if identified then try to re estimate the model parameters using
larger values than the ones obtained, if the log-likelihood is greater, then it is
assumed that the model is degenerate and the corresponding values will be
replaced with either <code>+Inf</code> or  <code>-Inf</code>. By default, this behavior is checked
anytime that the absolute value of the estimates is greater than 5, or the
sufficient statistics were flagged as potentially outside of the interior of
the support (close to zero or to its max).
</p>
<p>In the case of <code>ntries</code>, the optimization is repeated that number of times,
each time perturbing the <code>init</code> parameter by adding a Normally distributed
vector. The result which reaches the highest log-likelihood will be the one
reported as parameter estimates. This feature is intended for testing only.
Anecdotally, <code>optim</code> reaches the max in the first try.
</p>


<h3>See Also</h3>

<p>The function <code><a href="#topic+plot.ergmito">plot.ergmito()</a></code> and <code><a href="#topic+gof_ergmito">gof_ergmito()</a></code> for post-estimation
diagnostics.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Generating a small graph
set.seed(12)
n &lt;- 4
net &lt;- rbernoulli(n, p = .3)

model &lt;- net ~ edges + mutual

library(ergm)
ans_ergmito &lt;- ergmito(model)
ans_ergm  &lt;- ergm(model)

# The ergmito should have a larger value
ergm.exact(ans_ergmito$coef, model)
ergm.exact(ans_ergm$coef, model)

summary(ans_ergmito)
summary(ans_ergm)

# Example 2: Estimating an ERGMito using data with know DGP parameters -----
data(fivenets) 

model1 &lt;- ergmito(fivenets ~ edges + nodematch("female"))
summary(model1) # This data has know parameters equal to -2.0 and 2.0

# Example 3: Likelihood ratio test using the lmtest R package

if (require(lmtest)) {
  data(fivenets)
  model1 &lt;- ergmito(fivenets ~ edges + nodematch("female"))
  model2 &lt;- ergmito(fivenets ~ edges + nodematch("female") + mutual)
  
  lrtest(model1, model2)
  # Likelihood ratio test
  # 
  # Model 1: fivenets ~ edges + nodematch("female") 
  # Model 2: fivenets ~ edges + nodematch("female") + mutual
  #   #Df  LogLik Df  Chisq Pr(&gt;Chisq)
  # 1   2 -34.671                     
  # 2   3 -34.205 1 0.9312     0.3346
}

# Example 4: Adding an reference term for edge-count ----------------------

# Simulating networks of different sizes
set.seed(12344)
nets &lt;- rbernoulli(c(rep(4, 10), rep(5, 10)), c(rep(.2, 10), rep(.1, 10)))

# Fitting an ergmito under the Bernoulli model
ans0 &lt;- ergmito(nets ~ edges)
summary(ans0)
# 
# ERGMito estimates
# 
# formula:
#   nets ~ edges
# 
#       Estimate Std. Error z value  Pr(&gt;|z|)    
# edges -1.68640    0.15396 -10.954 &lt; 2.2e-16 ***
# ---
# Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1
# AIC: 279.3753    BIC: 283.1436    (Smaller is better.) 


# Fitting the model including a reference term for networks of size 5.
# Notice that the variable -n- and other graph attributes can be used
# with -model_update-.
ans1 &lt;- ergmito(nets ~ edges, model_update = ~ I(edges * (n == 5)))
summary(ans1)
# 
# ERGMito estimates
# 
# formula:
#   nets ~ edges + I(edges * (n == 5))
# 
#                     Estimate Std. Error z value  Pr(&gt;|z|)    
# edges               -1.18958    0.21583 -5.5116 3.556e-08 ***
# I(edges * (n == 5)) -0.90116    0.31250 -2.8837   0.00393 ** 
# ---
# Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1
# AIC: 272.9916    BIC: 280.5282    (Smaller is better.) 

# The resulting parameter for the edge-count is smaller for networks
# of size five
plogis(coef(ans1)[1])   # 0.23
plogis(sum(coef(ans1))) # 0.11

# We can see that in this case the difference in edge-count matters.
if (require(lmtest)) {

  lrtest(ans0, ans1)
  # Likelihood ratio test
  # 
  # Model 1: nets ~ edges
  # Model 2: nets ~ edges + I(edges * (n == 5))
  # #Df  LogLik Df  Chisq Pr(&gt;Chisq)   
  # 1   1 -138.69                        
  # 2   2 -134.50  1 8.3837   0.003786 **
  #   ---
  #   Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1
}

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
