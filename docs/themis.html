<!DOCTYPE html><html lang="en"><head><title>Help for package themis</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {themis}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#themis-package'><p>themis: Extra Recipes Steps for Dealing with Unbalanced Data</p></a></li>
<li><a href='#adasyn'><p>Adaptive Synthetic Algorithm</p></a></li>
<li><a href='#bsmote'><p>borderline-SMOTE Algorithm</p></a></li>
<li><a href='#circle_example'><p>Synthetic Dataset With a Circle</p></a></li>
<li><a href='#nearmiss'><p>Remove Points Near Other Classes</p></a></li>
<li><a href='#reexports'><p>Objects exported from other packages</p></a></li>
<li><a href='#required_pkgs.step_adasyn'><p>S3 methods for tracking which additional packages are needed for steps.</p></a></li>
<li><a href='#smote'><p>SMOTE Algorithm</p></a></li>
<li><a href='#smotenc'><p>SMOTENC Algorithm</p></a></li>
<li><a href='#step_adasyn'><p>Apply Adaptive Synthetic Algorithm</p></a></li>
<li><a href='#step_bsmote'><p>Apply borderline-SMOTE Algorithm</p></a></li>
<li><a href='#step_downsample'><p>Down-Sample a Data Set Based on a Factor Variable</p></a></li>
<li><a href='#step_nearmiss'><p>Remove Points Near Other Classes</p></a></li>
<li><a href='#step_rose'><p>Apply ROSE Algorithm</p></a></li>
<li><a href='#step_smote'><p>Apply SMOTE Algorithm</p></a></li>
<li><a href='#step_smotenc'><p>Apply SMOTENC algorithm</p></a></li>
<li><a href='#step_tomek'><p>Remove Tomek’s Links</p></a></li>
<li><a href='#step_upsample'><p>Up-Sample a Data Set Based on a Factor Variable</p></a></li>
<li><a href='#tomek'><p>Remove Tomek's links</p></a></li>
<li><a href='#tunable.step_adasyn'><p>tunable methods for themis</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Extra Recipes Steps for Dealing with Unbalanced Data</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.3</td>
</tr>
<tr>
<td>Description:</td>
<td>A dataset with an uneven number of cases in each class is
    said to be unbalanced. Many models produce a subpar performance on
    unbalanced datasets. A dataset can be balanced by increasing the
    number of minority cases using SMOTE 2011 &lt;<a href="https://doi.org/10.48550%2FarXiv.1106.1813">doi:10.48550/arXiv.1106.1813</a>&gt;,
    BorderlineSMOTE 2005 &lt;<a href="https://doi.org/10.1007%2F11538059_91">doi:10.1007/11538059_91</a>&gt; and ADASYN 2008
    <a href="https://ieeexplore.ieee.org/document/4633969">https://ieeexplore.ieee.org/document/4633969</a>. Or by decreasing the
    number of majority cases using NearMiss 2003
    <a href="https://www.site.uottawa.ca/~nat/Workshop2003/jzhang.pdf">https://www.site.uottawa.ca/~nat/Workshop2003/jzhang.pdf</a> or Tomek
    link removal 1976 <a href="https://ieeexplore.ieee.org/document/4309452">https://ieeexplore.ieee.org/document/4309452</a>.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/tidymodels/themis">https://github.com/tidymodels/themis</a>,
<a href="https://themis.tidymodels.org">https://themis.tidymodels.org</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/tidymodels/themis/issues">https://github.com/tidymodels/themis/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.6), recipes (&ge; 1.1.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>cli, gower, lifecycle (&ge; 1.0.3), dplyr, generics (&ge; 0.1.0),
purrr, RANN, rlang (&ge; 1.1.0), ROSE, tibble, withr, glue,
hardhat, vctrs</td>
</tr>
<tr>
<td>Suggests:</td>
<td>covr, dials (&ge; 1.2.0), ggplot2, modeldata, testthat (&ge;
3.0.0)</td>
</tr>
<tr>
<td>Config/Needs/website:</td>
<td>tidyverse/tidytemplate</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-01-22 23:40:53 UTC; emilhvitfeldt</td>
</tr>
<tr>
<td>Author:</td>
<td>Emil Hvitfeldt <a href="https://orcid.org/0000-0002-0679-1945"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Posit Software, PBC [cph, fnd]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Emil Hvitfeldt &lt;emil.hvitfeldt@posit.co&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-01-23 00:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='themis-package'>themis: Extra Recipes Steps for Dealing with Unbalanced Data</h2><span id='topic+themis'></span><span id='topic+themis-package'></span>

<h3>Description</h3>

<p><img src="../help/figures/logo.png" style='float: right' alt='logo' width='120' />
</p>
<p>A dataset with an uneven number of cases in each class is said to be unbalanced. Many models produce a subpar performance on unbalanced datasets. A dataset can be balanced by increasing the number of minority cases using SMOTE 2011 <a href="https://arxiv.org/abs/1106.1813">arXiv:1106.1813</a>, BorderlineSMOTE 2005 <a href="https://doi.org/10.1007/11538059_91">doi:10.1007/11538059_91</a> and ADASYN 2008 <a href="https://ieeexplore.ieee.org/document/4633969">https://ieeexplore.ieee.org/document/4633969</a>. Or by decreasing the number of majority cases using NearMiss 2003 <a href="https://www.site.uottawa.ca/~nat/Workshop2003/jzhang.pdf">https://www.site.uottawa.ca/~nat/Workshop2003/jzhang.pdf</a> or Tomek link removal 1976 <a href="https://ieeexplore.ieee.org/document/4309452">https://ieeexplore.ieee.org/document/4309452</a>.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Emil Hvitfeldt <a href="mailto:emil.hvitfeldt@posit.co">emil.hvitfeldt@posit.co</a> (<a href="https://orcid.org/0000-0002-0679-1945">ORCID</a>)
</p>
<p>Other contributors:
</p>

<ul>
<li><p> Posit Software, PBC [copyright holder, funder]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/tidymodels/themis">https://github.com/tidymodels/themis</a>
</p>
</li>
<li> <p><a href="https://themis.tidymodels.org">https://themis.tidymodels.org</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/tidymodels/themis/issues">https://github.com/tidymodels/themis/issues</a>
</p>
</li></ul>


<hr>
<h2 id='adasyn'>Adaptive Synthetic Algorithm</h2><span id='topic+adasyn'></span>

<h3>Description</h3>

<p>Generates synthetic positive instances using ADASYN algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>adasyn(df, var, k = 5, over_ratio = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="adasyn_+3A_df">df</code></td>
<td>
<p>data.frame or tibble. Must have 1 factor variable and remaining
numeric variables.</p>
</td></tr>
<tr><td><code id="adasyn_+3A_var">var</code></td>
<td>
<p>Character, name of variable containing factor variable.</p>
</td></tr>
<tr><td><code id="adasyn_+3A_k">k</code></td>
<td>
<p>An integer. Number of nearest neighbor that are used
to generate the new examples of the minority class.</p>
</td></tr>
<tr><td><code id="adasyn_+3A_over_ratio">over_ratio</code></td>
<td>
<p>A numeric value for the ratio of the
minority-to-majority frequencies. The default value (1) means
that all other levels are sampled up to have the same
frequency as the most occurring level. A value of 0.5 would mean
that the minority levels will have (at most) (approximately)
half as many rows than the majority level.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>All columns used in this function must be numeric with no missing data.
</p>


<h3>Value</h3>

<p>A data.frame or tibble, depending on type of <code>df</code>.
</p>


<h3>References</h3>

<p>Chawla, N. V., Bowyer, K. W., Hall, L. O., and Kegelmeyer,
W. P. (2002). Smote: Synthetic minority over-sampling technique.
Journal of Artificial Intelligence Research, 16:321-357.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+step_adasyn">step_adasyn()</a></code> for step function of this method
</p>
<p>Other Direct Implementations: 
<code><a href="#topic+bsmote">bsmote</a>()</code>,
<code><a href="#topic+nearmiss">nearmiss</a>()</code>,
<code><a href="#topic+smote">smote</a>()</code>,
<code><a href="#topic+smotenc">smotenc</a>()</code>,
<code><a href="#topic+tomek">tomek</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>circle_numeric &lt;- circle_example[, c("x", "y", "class")]

res &lt;- adasyn(circle_numeric, var = "class")

res &lt;- adasyn(circle_numeric, var = "class", k = 10)

res &lt;- adasyn(circle_numeric, var = "class", over_ratio = 0.8)
</code></pre>

<hr>
<h2 id='bsmote'>borderline-SMOTE Algorithm</h2><span id='topic+bsmote'></span>

<h3>Description</h3>

<p>BSMOTE generates generate new examples of the minority class using nearest
neighbors of these cases in the border region between classes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bsmote(df, var, k = 5, over_ratio = 1, all_neighbors = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bsmote_+3A_df">df</code></td>
<td>
<p>data.frame or tibble. Must have 1 factor variable and remaining
numeric variables.</p>
</td></tr>
<tr><td><code id="bsmote_+3A_var">var</code></td>
<td>
<p>Character, name of variable containing factor variable.</p>
</td></tr>
<tr><td><code id="bsmote_+3A_k">k</code></td>
<td>
<p>An integer. Number of nearest neighbor that are used
to generate the new examples of the minority class.</p>
</td></tr>
<tr><td><code id="bsmote_+3A_over_ratio">over_ratio</code></td>
<td>
<p>A numeric value for the ratio of the
minority-to-majority frequencies. The default value (1) means
that all other levels are sampled up to have the same
frequency as the most occurring level. A value of 0.5 would mean
that the minority levels will have (at most) (approximately)
half as many rows than the majority level.</p>
</td></tr>
<tr><td><code id="bsmote_+3A_all_neighbors">all_neighbors</code></td>
<td>
<p>Type of two borderline-SMOTE method. Defaults to FALSE.
See details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This methods works the same way as <code><a href="#topic+smote">smote()</a></code>, expect that instead of
generating points around every point of of the minority class each point is
first being classified into the boxes &quot;danger&quot; and &quot;not&quot;. For each point the
k nearest neighbors is calculated. If all the neighbors comes from a
different class it is labeled noise and put in to the &quot;not&quot; box. If more then
half of the neighbors comes from a different class it is labeled &quot;danger.
</p>
<p>If <code>all_neighbors = FALSE</code> then points will be generated between nearest
neighbors in its own class. If <code>all_neighbors = TRUE</code> then points will be
generated between any nearest neighbors. See examples for visualization.
</p>
<p>The parameter <code>neighbors</code> controls the way the new examples are created.
For each currently existing minority class example X new examples will be
created (this is controlled by the parameter <code>over_ratio</code> as mentioned
above). These examples will be generated by using the information from the
<code>neighbors</code> nearest neighbor of each example of the minority class.
The parameter <code>neighbors</code> controls how many of these neighbor are used.
</p>
<p>All columns used in this step must be numeric with no missing data.
</p>


<h3>Value</h3>

<p>A data.frame or tibble, depending on type of <code>df</code>.
</p>


<h3>References</h3>

<p>Hui Han, Wen-Yuan Wang, and Bing-Huan Mao. Borderline-smote:
a new over-sampling method in imbalanced data sets learning. In
International Conference on Intelligent Computing, pages 878–887. Springer,
2005.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+step_bsmote">step_bsmote()</a></code> for step function of this method
</p>
<p>Other Direct Implementations: 
<code><a href="#topic+adasyn">adasyn</a>()</code>,
<code><a href="#topic+nearmiss">nearmiss</a>()</code>,
<code><a href="#topic+smote">smote</a>()</code>,
<code><a href="#topic+smotenc">smotenc</a>()</code>,
<code><a href="#topic+tomek">tomek</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>circle_numeric &lt;- circle_example[, c("x", "y", "class")]

res &lt;- bsmote(circle_numeric, var = "class")

res &lt;- bsmote(circle_numeric, var = "class", k = 10)

res &lt;- bsmote(circle_numeric, var = "class", over_ratio = 0.8)

res &lt;- bsmote(circle_numeric, var = "class", all_neighbors = TRUE)
</code></pre>

<hr>
<h2 id='circle_example'>Synthetic Dataset With a Circle</h2><span id='topic+circle_example'></span>

<h3>Description</h3>

<p>A random dataset with two classes one of which is inside a circle. Used for
examples to show how the different methods handles borders.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>circle_example
</code></pre>


<h3>Format</h3>

<p>A data frame with 200 rows and 4 variables:
</p>

<dl>
<dt>x</dt><dd><p>Numeric.</p>
</dd>
<dt>y</dt><dd><p>Numeric.</p>
</dd>
<dt>class</dt><dd><p>Factor, values &quot;Circle&quot; and &quot;Rest&quot;.</p>
</dd>
<dt>id</dt><dd><p>character, ID variable.</p>
</dd>
</dl>


<hr>
<h2 id='nearmiss'>Remove Points Near Other Classes</h2><span id='topic+nearmiss'></span>

<h3>Description</h3>

<p>Generates synthetic positive instances using nearmiss algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nearmiss(df, var, k = 5, under_ratio = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nearmiss_+3A_df">df</code></td>
<td>
<p>data.frame or tibble. Must have 1 factor variable and remaining
numeric variables.</p>
</td></tr>
<tr><td><code id="nearmiss_+3A_var">var</code></td>
<td>
<p>Character, name of variable containing factor variable.</p>
</td></tr>
<tr><td><code id="nearmiss_+3A_k">k</code></td>
<td>
<p>An integer. Number of nearest neighbor that are used
to generate the new examples of the minority class.</p>
</td></tr>
<tr><td><code id="nearmiss_+3A_under_ratio">under_ratio</code></td>
<td>
<p>A numeric value for the ratio of the
majority-to-minority frequencies. The default value (1) means
that all other levels are sampled down to have the same
frequency as the least occurring level. A value of 2 would mean
that the majority levels will have (at most) (approximately)
twice as many rows than the minority level.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>All columns used in this function must be numeric with no missing data.
</p>


<h3>Value</h3>

<p>A data.frame or tibble, depending on type of <code>df</code>.
</p>


<h3>References</h3>

<p>Inderjeet Mani and I Zhang. knn approach to unbalanced data
distributions: a case study involving information extraction. In Proceedings
of workshop on learning from imbalanced datasets, 2003.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+step_nearmiss">step_nearmiss()</a></code> for step function of this method
</p>
<p>Other Direct Implementations: 
<code><a href="#topic+adasyn">adasyn</a>()</code>,
<code><a href="#topic+bsmote">bsmote</a>()</code>,
<code><a href="#topic+smote">smote</a>()</code>,
<code><a href="#topic+smotenc">smotenc</a>()</code>,
<code><a href="#topic+tomek">tomek</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>circle_numeric &lt;- circle_example[, c("x", "y", "class")]

res &lt;- nearmiss(circle_numeric, var = "class")

res &lt;- nearmiss(circle_numeric, var = "class", k = 10)

res &lt;- nearmiss(circle_numeric, var = "class", under_ratio = 1.5)
</code></pre>

<hr>
<h2 id='reexports'>Objects exported from other packages</h2><span id='topic+reexports'></span><span id='topic+tidy'></span><span id='topic+required_pkgs'></span><span id='topic+tunable'></span>

<h3>Description</h3>

<p>These objects are imported from other packages. Follow the links
below to see their documentation.
</p>

<dl>
<dt>generics</dt><dd><p><code><a href="generics.html#topic+required_pkgs">required_pkgs</a></code>, <code><a href="generics.html#topic+tidy">tidy</a></code>, <code><a href="generics.html#topic+tunable">tunable</a></code></p>
</dd>
</dl>

<hr>
<h2 id='required_pkgs.step_adasyn'>S3 methods for tracking which additional packages are needed for steps.</h2><span id='topic+required_pkgs.step_adasyn'></span><span id='topic+required_pkgs.step_bsmote'></span><span id='topic+required_pkgs.step_downsample'></span><span id='topic+required_pkgs.step_nearmiss'></span><span id='topic+required_pkgs.step_rose'></span><span id='topic+required_pkgs.step_smote'></span><span id='topic+required_pkgs.step_smotenc'></span><span id='topic+required_pkgs.step_tomek'></span><span id='topic+required_pkgs.step_upsample'></span>

<h3>Description</h3>

<p>S3 methods for tracking which additional packages are needed for steps.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'step_adasyn'
required_pkgs(x, ...)

## S3 method for class 'step_bsmote'
required_pkgs(x, ...)

## S3 method for class 'step_downsample'
required_pkgs(x, ...)

## S3 method for class 'step_nearmiss'
required_pkgs(x, ...)

## S3 method for class 'step_rose'
required_pkgs(x, ...)

## S3 method for class 'step_smote'
required_pkgs(x, ...)

## S3 method for class 'step_smotenc'
required_pkgs(x, ...)

## S3 method for class 'step_tomek'
required_pkgs(x, ...)

## S3 method for class 'step_upsample'
required_pkgs(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="required_pkgs.step_adasyn_+3A_x">x</code></td>
<td>
<p>A recipe step</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector
</p>

<hr>
<h2 id='smote'>SMOTE Algorithm</h2><span id='topic+smote'></span>

<h3>Description</h3>

<p>SMOTE generates new examples of the minority class using nearest neighbors
of these cases.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>smote(df, var, k = 5, over_ratio = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="smote_+3A_df">df</code></td>
<td>
<p>data.frame or tibble. Must have 1 factor variable and remaining
numeric variables.</p>
</td></tr>
<tr><td><code id="smote_+3A_var">var</code></td>
<td>
<p>Character, name of variable containing factor variable.</p>
</td></tr>
<tr><td><code id="smote_+3A_k">k</code></td>
<td>
<p>An integer. Number of nearest neighbor that are used
to generate the new examples of the minority class.</p>
</td></tr>
<tr><td><code id="smote_+3A_over_ratio">over_ratio</code></td>
<td>
<p>A numeric value for the ratio of the
minority-to-majority frequencies. The default value (1) means
that all other levels are sampled up to have the same
frequency as the most occurring level. A value of 0.5 would mean
that the minority levels will have (at most) (approximately)
half as many rows than the majority level.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The parameter <code>neighbors</code> controls the way the new examples are created.
For each currently existing minority class example X new examples will be
created (this is controlled by the parameter <code>over_ratio</code> as mentioned
above). These examples will be generated by using the information from the
<code>neighbors</code> nearest neighbor of each example of the minority class.
The parameter <code>neighbors</code> controls how many of these neighbor are used.
All columns used in this function must be numeric with no missing data.
</p>


<h3>Value</h3>

<p>A data.frame or tibble, depending on type of <code>df</code>.
</p>


<h3>References</h3>

<p>Chawla, N. V., Bowyer, K. W., Hall, L. O., and Kegelmeyer,
W. P. (2002). Smote: Synthetic minority over-sampling technique.
Journal of Artificial Intelligence Research, 16:321-357.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+step_smote">step_smote()</a></code> for step function of this method
</p>
<p>Other Direct Implementations: 
<code><a href="#topic+adasyn">adasyn</a>()</code>,
<code><a href="#topic+bsmote">bsmote</a>()</code>,
<code><a href="#topic+nearmiss">nearmiss</a>()</code>,
<code><a href="#topic+smotenc">smotenc</a>()</code>,
<code><a href="#topic+tomek">tomek</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>circle_numeric &lt;- circle_example[, c("x", "y", "class")]

res &lt;- smote(circle_numeric, var = "class")

res &lt;- smote(circle_numeric, var = "class", k = 10)

res &lt;- smote(circle_numeric, var = "class", over_ratio = 0.8)
</code></pre>

<hr>
<h2 id='smotenc'>SMOTENC Algorithm</h2><span id='topic+smotenc'></span>

<h3>Description</h3>

<p>SMOTENC generates new examples of the minority class using nearest neighbors
of these cases, and can handle categorical variables
</p>


<h3>Usage</h3>

<pre><code class='language-R'>smotenc(df, var, k = 5, over_ratio = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="smotenc_+3A_df">df</code></td>
<td>
<p>data.frame or tibble. Must have 1 factor variable and remaining
numeric variables.</p>
</td></tr>
<tr><td><code id="smotenc_+3A_var">var</code></td>
<td>
<p>Character, name of variable containing factor variable.</p>
</td></tr>
<tr><td><code id="smotenc_+3A_k">k</code></td>
<td>
<p>An integer. Number of nearest neighbor that are used
to generate the new examples of the minority class.</p>
</td></tr>
<tr><td><code id="smotenc_+3A_over_ratio">over_ratio</code></td>
<td>
<p>A numeric value for the ratio of the
minority-to-majority frequencies. The default value (1) means
that all other levels are sampled up to have the same
frequency as the most occurring level. A value of 0.5 would mean
that the minority levels will have (at most) (approximately)
half as many rows than the majority level.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The parameter <code>neighbors</code> controls the way the new examples are created.
For each currently existing minority class example X new examples will be
created (this is controlled by the parameter <code>over_ratio</code> as mentioned
above). These examples will be generated by using the information from the
<code>neighbors</code> nearest neighbor of each example of the minority class.
The parameter <code>neighbors</code> controls how many of these neighbor are used.
Columns can be numeric and categorical with no missing data.
</p>


<h3>Value</h3>

<p>A data.frame or tibble, depending on type of <code>df</code>.
</p>


<h3>References</h3>

<p>Chawla, N. V., Bowyer, K. W., Hall, L. O., and Kegelmeyer,
W. P. (2002). Smote: Synthetic minority over-sampling technique.
Journal of Artificial Intelligence Research, 16:321-357.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+step_smotenc">step_smotenc()</a></code> for step function of this method
</p>
<p>Other Direct Implementations: 
<code><a href="#topic+adasyn">adasyn</a>()</code>,
<code><a href="#topic+bsmote">bsmote</a>()</code>,
<code><a href="#topic+nearmiss">nearmiss</a>()</code>,
<code><a href="#topic+smote">smote</a>()</code>,
<code><a href="#topic+tomek">tomek</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>circle_numeric &lt;- circle_example[, c("x", "y", "class")]

res &lt;- smotenc(circle_numeric, var = "class")

res &lt;- smotenc(circle_numeric, var = "class", k = 10)

res &lt;- smotenc(circle_numeric, var = "class", over_ratio = 0.8)
</code></pre>

<hr>
<h2 id='step_adasyn'>Apply Adaptive Synthetic Algorithm</h2><span id='topic+step_adasyn'></span><span id='topic+tidy.step_adasyn'></span>

<h3>Description</h3>

<p><code>step_adasyn()</code> creates a <em>specification</em> of a recipe step that generates
synthetic positive instances using ADASYN algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>step_adasyn(
  recipe,
  ...,
  role = NA,
  trained = FALSE,
  column = NULL,
  over_ratio = 1,
  neighbors = 5,
  skip = TRUE,
  seed = sample.int(10^5, 1),
  id = rand_id("adasyn")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="step_adasyn_+3A_recipe">recipe</code></td>
<td>
<p>A recipe object. The step will be added to the
sequence of operations for this recipe.</p>
</td></tr>
<tr><td><code id="step_adasyn_+3A_...">...</code></td>
<td>
<p>One or more selector functions to choose which
variable is used to sample the data. See <a href="recipes.html#topic+selections">recipes::selections</a>
for more details. The selection should result in <em>single
factor variable</em>. For the <code>tidy</code> method, these are not
currently used.</p>
</td></tr>
<tr><td><code id="step_adasyn_+3A_role">role</code></td>
<td>
<p>Not used by this step since no new variables are
created.</p>
</td></tr>
<tr><td><code id="step_adasyn_+3A_trained">trained</code></td>
<td>
<p>A logical to indicate if the quantities for
preprocessing have been estimated.</p>
</td></tr>
<tr><td><code id="step_adasyn_+3A_column">column</code></td>
<td>
<p>A character string of the variable name that will
be populated (eventually) by the <code>...</code> selectors.</p>
</td></tr>
<tr><td><code id="step_adasyn_+3A_over_ratio">over_ratio</code></td>
<td>
<p>A numeric value for the ratio of the
minority-to-majority frequencies. The default value (1) means
that all other levels are sampled up to have the same
frequency as the most occurring level. A value of 0.5 would mean
that the minority levels will have (at most) (approximately)
half as many rows than the majority level.</p>
</td></tr>
<tr><td><code id="step_adasyn_+3A_neighbors">neighbors</code></td>
<td>
<p>An integer. Number of nearest neighbor that are used
to generate the new examples of the minority class.</p>
</td></tr>
<tr><td><code id="step_adasyn_+3A_skip">skip</code></td>
<td>
<p>A logical. Should the step be skipped when the
recipe is baked by <code><a href="recipes.html#topic+bake">bake()</a></code>? While all operations are baked
when <code><a href="recipes.html#topic+prep">prep()</a></code> is run, some operations may not be able to be
conducted on new data (e.g. processing the outcome variable(s)).
Care should be taken when using <code>skip = TRUE</code> as it may affect
the computations for subsequent operations.</p>
</td></tr>
<tr><td><code id="step_adasyn_+3A_seed">seed</code></td>
<td>
<p>An integer that will be used as the seed when
applied.</p>
</td></tr>
<tr><td><code id="step_adasyn_+3A_id">id</code></td>
<td>
<p>A character string that is unique to this step to identify it.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>All columns in the data are sampled and returned by <code><a href="recipes.html#topic+juice">recipes::juice()</a></code>
and <code><a href="recipes.html#topic+bake">recipes::bake()</a></code>.
</p>
<p>All columns used in this step must be numeric with no missing data.
</p>
<p>When used in modeling, users should strongly consider using the
option <code>skip = TRUE</code> so that the extra sampling is <em>not</em>
conducted outside of the training set.
</p>


<h3>Value</h3>

<p>An updated version of <code>recipe</code> with the new step
added to the sequence of existing steps (if any). For the
<code>tidy</code> method, a tibble with columns <code>terms</code> which is
the variable used to sample.
</p>


<h3>Tidying</h3>

<p>When you <code><a href="recipes.html#topic+tidy.recipe">tidy()</a></code> this step, a tibble is retruned with
columns <code>terms</code> and <code>id</code>:
</p>

<dl>
<dt>terms</dt><dd><p>character, the selectors or variables selected</p>
</dd>
<dt>id</dt><dd><p>character, id of this step</p>
</dd>
</dl>



<h3>Tuning Parameters</h3>

<p>This step has 2 tuning parameters:
</p>

<ul>
<li> <p><code>over_ratio</code>: Over-Sampling Ratio (type: double, default: 1)
</p>
</li>
<li> <p><code>neighbors</code>: # Nearest Neighbors (type: integer, default: 5)
</p>
</li></ul>



<h3>Case weights</h3>

<p>The underlying operation does not allow for case weights.
</p>


<h3>References</h3>

<p>He, H., Bai, Y., Garcia, E. and Li, S. 2008. ADASYN: Adaptive
synthetic sampling approach for imbalanced learning. Proceedings of
IJCNN 2008. (IEEE World Congress on Computational Intelligence). IEEE
International Joint Conference. pp.1322-1328.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+adasyn">adasyn()</a></code> for direct implementation
</p>
<p>Other Steps for over-sampling: 
<code><a href="#topic+step_bsmote">step_bsmote</a>()</code>,
<code><a href="#topic+step_rose">step_rose</a>()</code>,
<code><a href="#topic+step_smote">step_smote</a>()</code>,
<code><a href="#topic+step_smotenc">step_smotenc</a>()</code>,
<code><a href="#topic+step_upsample">step_upsample</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(recipes)
library(modeldata)
data(hpc_data)

hpc_data0 &lt;- hpc_data %&gt;%
  select(-protocol, -day)

orig &lt;- count(hpc_data0, class, name = "orig")
orig

up_rec &lt;- recipe(class ~ ., data = hpc_data0) %&gt;%
  # Bring the minority levels up to about 1000 each
  # 1000/2211 is approx 0.4523
  step_adasyn(class, over_ratio = 0.4523) %&gt;%
  prep()

training &lt;- up_rec %&gt;%
  bake(new_data = NULL) %&gt;%
  count(class, name = "training")
training

# Since `skip` defaults to TRUE, baking the step has no effect
baked &lt;- up_rec %&gt;%
  bake(new_data = hpc_data0) %&gt;%
  count(class, name = "baked")
baked

# Note that if the original data contained more rows than the
# target n (= ratio * majority_n), the data are left alone:
orig %&gt;%
  left_join(training, by = "class") %&gt;%
  left_join(baked, by = "class")

library(ggplot2)

ggplot(circle_example, aes(x, y, color = class)) +
  geom_point() +
  labs(title = "Without ADASYN")

recipe(class ~ x + y, data = circle_example) %&gt;%
  step_adasyn(class) %&gt;%
  prep() %&gt;%
  bake(new_data = NULL) %&gt;%
  ggplot(aes(x, y, color = class)) +
  geom_point() +
  labs(title = "With ADASYN")

</code></pre>

<hr>
<h2 id='step_bsmote'>Apply borderline-SMOTE Algorithm</h2><span id='topic+step_bsmote'></span><span id='topic+tidy.step_bsmote'></span>

<h3>Description</h3>

<p><code>step_bsmote()</code> creates a <em>specification</em> of a recipe step that generate new
examples of the minority class using nearest neighbors of these cases in the
border region between classes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>step_bsmote(
  recipe,
  ...,
  role = NA,
  trained = FALSE,
  column = NULL,
  over_ratio = 1,
  neighbors = 5,
  all_neighbors = FALSE,
  skip = TRUE,
  seed = sample.int(10^5, 1),
  id = rand_id("bsmote")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="step_bsmote_+3A_recipe">recipe</code></td>
<td>
<p>A recipe object. The step will be added to the
sequence of operations for this recipe.</p>
</td></tr>
<tr><td><code id="step_bsmote_+3A_...">...</code></td>
<td>
<p>One or more selector functions to choose which
variable is used to sample the data. See <a href="recipes.html#topic+selections">recipes::selections</a>
for more details. The selection should result in <em>single
factor variable</em>. For the <code>tidy</code> method, these are not
currently used.</p>
</td></tr>
<tr><td><code id="step_bsmote_+3A_role">role</code></td>
<td>
<p>Not used by this step since no new variables are
created.</p>
</td></tr>
<tr><td><code id="step_bsmote_+3A_trained">trained</code></td>
<td>
<p>A logical to indicate if the quantities for
preprocessing have been estimated.</p>
</td></tr>
<tr><td><code id="step_bsmote_+3A_column">column</code></td>
<td>
<p>A character string of the variable name that will
be populated (eventually) by the <code>...</code> selectors.</p>
</td></tr>
<tr><td><code id="step_bsmote_+3A_over_ratio">over_ratio</code></td>
<td>
<p>A numeric value for the ratio of the
minority-to-majority frequencies. The default value (1) means
that all other levels are sampled up to have the same
frequency as the most occurring level. A value of 0.5 would mean
that the minority levels will have (at most) (approximately)
half as many rows than the majority level.</p>
</td></tr>
<tr><td><code id="step_bsmote_+3A_neighbors">neighbors</code></td>
<td>
<p>An integer. Number of nearest neighbor that are used
to generate the new examples of the minority class.</p>
</td></tr>
<tr><td><code id="step_bsmote_+3A_all_neighbors">all_neighbors</code></td>
<td>
<p>Type of two borderline-SMOTE method. Defaults to FALSE.
See details.</p>
</td></tr>
<tr><td><code id="step_bsmote_+3A_skip">skip</code></td>
<td>
<p>A logical. Should the step be skipped when the
recipe is baked by <code><a href="recipes.html#topic+bake">bake()</a></code>? While all operations are baked
when <code><a href="recipes.html#topic+prep">prep()</a></code> is run, some operations may not be able to be
conducted on new data (e.g. processing the outcome variable(s)).
Care should be taken when using <code>skip = TRUE</code> as it may affect
the computations for subsequent operations.</p>
</td></tr>
<tr><td><code id="step_bsmote_+3A_seed">seed</code></td>
<td>
<p>An integer that will be used as the seed when
smote-ing.</p>
</td></tr>
<tr><td><code id="step_bsmote_+3A_id">id</code></td>
<td>
<p>A character string that is unique to this step to identify it.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This methods works the same way as <code><a href="#topic+step_smote">step_smote()</a></code>, expect that instead of
generating points around every point of of the minority class each point is
first being classified into the boxes &quot;danger&quot; and &quot;not&quot;. For each point the
k nearest neighbors is calculated. If all the neighbors comes from a
different class it is labeled noise and put in to the &quot;not&quot; box. If more then
half of the neighbors comes from a different class it is labeled &quot;danger.
</p>
<p>If all_neighbors = FALSE then points will be generated between nearest
neighbors in its own class. If all_neighbors = TRUE then points will be
generated between any nearest neighbors. See examples for visualization.
</p>
<p>The parameter <code>neighbors</code> controls the way the new examples are created.
For each currently existing minority class example X new examples will be
created (this is controlled by the parameter <code>over_ratio</code> as mentioned
above). These examples will be generated by using the information from the
<code>neighbors</code> nearest neighbor of each example of the minority class.
The parameter <code>neighbors</code> controls how many of these neighbor are used.
</p>
<p>All columns in the data are sampled and returned by <code><a href="recipes.html#topic+juice">recipes::juice()</a></code>
and <code><a href="recipes.html#topic+bake">recipes::bake()</a></code>.
</p>
<p>All columns used in this step must be numeric with no missing data.
</p>
<p>When used in modeling, users should strongly consider using the
option <code>skip = TRUE</code> so that the extra sampling is <em>not</em>
conducted outside of the training set.
</p>


<h3>Value</h3>

<p>An updated version of <code>recipe</code> with the new step
added to the sequence of existing steps (if any). For the
<code>tidy</code> method, a tibble with columns <code>terms</code> which is
the variable used to sample.
</p>


<h3>Tidying</h3>

<p>When you <code><a href="recipes.html#topic+tidy.recipe">tidy()</a></code> this step, a tibble is retruned with
columns <code>terms</code> and <code>id</code>:
</p>

<dl>
<dt>terms</dt><dd><p>character, the selectors or variables selected</p>
</dd>
<dt>id</dt><dd><p>character, id of this step</p>
</dd>
</dl>



<h3>Tuning Parameters</h3>

<p>This step has 3 tuning parameters:
</p>

<ul>
<li> <p><code>over_ratio</code>: Over-Sampling Ratio (type: double, default: 1)
</p>
</li>
<li> <p><code>neighbors</code>: # Nearest Neighbors (type: integer, default: 5)
</p>
</li>
<li> <p><code>all_neighbors</code>: All Neighbors (type: logical, default: FALSE)
</p>
</li></ul>



<h3>Case weights</h3>

<p>The underlying operation does not allow for case weights.
</p>


<h3>References</h3>

<p>Hui Han, Wen-Yuan Wang, and Bing-Huan Mao. Borderline-smote:
a new over-sampling method in imbalanced data sets learning. In
International Conference on Intelligent Computing, pages 878–887. Springer,
2005.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bsmote">bsmote()</a></code> for direct implementation
</p>
<p>Other Steps for over-sampling: 
<code><a href="#topic+step_adasyn">step_adasyn</a>()</code>,
<code><a href="#topic+step_rose">step_rose</a>()</code>,
<code><a href="#topic+step_smote">step_smote</a>()</code>,
<code><a href="#topic+step_smotenc">step_smotenc</a>()</code>,
<code><a href="#topic+step_upsample">step_upsample</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(recipes)
library(modeldata)
data(hpc_data)

hpc_data0 &lt;- hpc_data %&gt;%
  select(-protocol, -day)

orig &lt;- count(hpc_data0, class, name = "orig")
orig

up_rec &lt;- recipe(class ~ ., data = hpc_data0) %&gt;%
  # Bring the minority levels up to about 1000 each
  # 1000/2211 is approx 0.4523
  step_bsmote(class, over_ratio = 0.4523) %&gt;%
  prep()

training &lt;- up_rec %&gt;%
  bake(new_data = NULL) %&gt;%
  count(class, name = "training")
training

# Since `skip` defaults to TRUE, baking the step has no effect
baked &lt;- up_rec %&gt;%
  bake(new_data = hpc_data0) %&gt;%
  count(class, name = "baked")
baked

# Note that if the original data contained more rows than the
# target n (= ratio * majority_n), the data are left alone:
orig %&gt;%
  left_join(training, by = "class") %&gt;%
  left_join(baked, by = "class")

library(ggplot2)

ggplot(circle_example, aes(x, y, color = class)) +
  geom_point() +
  labs(title = "Without SMOTE")

recipe(class ~ x + y, data = circle_example) %&gt;%
  step_bsmote(class, all_neighbors = FALSE) %&gt;%
  prep() %&gt;%
  bake(new_data = NULL) %&gt;%
  ggplot(aes(x, y, color = class)) +
  geom_point() +
  labs(title = "With borderline-SMOTE, all_neighbors = FALSE")

recipe(class ~ x + y, data = circle_example) %&gt;%
  step_bsmote(class, all_neighbors = TRUE) %&gt;%
  prep() %&gt;%
  bake(new_data = NULL) %&gt;%
  ggplot(aes(x, y, color = class)) +
  geom_point() +
  labs(title = "With borderline-SMOTE, all_neighbors = TRUE")

</code></pre>

<hr>
<h2 id='step_downsample'>Down-Sample a Data Set Based on a Factor Variable</h2><span id='topic+step_downsample'></span><span id='topic+tidy.step_downsample'></span>

<h3>Description</h3>

<p><code>step_downsample()</code> creates a <em>specification</em> of a recipe step that will
remove rows of a data set to make the occurrence of levels in a specific
factor level equal.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>step_downsample(
  recipe,
  ...,
  under_ratio = 1,
  ratio = deprecated(),
  role = NA,
  trained = FALSE,
  column = NULL,
  target = NA,
  skip = TRUE,
  seed = sample.int(10^5, 1),
  id = rand_id("downsample")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="step_downsample_+3A_recipe">recipe</code></td>
<td>
<p>A recipe object. The step will be added to the
sequence of operations for this recipe.</p>
</td></tr>
<tr><td><code id="step_downsample_+3A_...">...</code></td>
<td>
<p>One or more selector functions to choose which
variable is used to sample the data. See <a href="recipes.html#topic+selections">recipes::selections</a>
for more details. The selection should result in <em>single
factor variable</em>. For the <code>tidy</code> method, these are not
currently used.</p>
</td></tr>
<tr><td><code id="step_downsample_+3A_under_ratio">under_ratio</code></td>
<td>
<p>A numeric value for the ratio of the
majority-to-minority frequencies. The default value (1) means
that all other levels are sampled down to have the same
frequency as the least occurring level. A value of 2 would mean
that the majority levels will have (at most) (approximately)
twice as many rows than the minority level.</p>
</td></tr>
<tr><td><code id="step_downsample_+3A_ratio">ratio</code></td>
<td>
<p>Deprecated argument; same as <code>under_ratio</code></p>
</td></tr>
<tr><td><code id="step_downsample_+3A_role">role</code></td>
<td>
<p>Not used by this step since no new variables are
created.</p>
</td></tr>
<tr><td><code id="step_downsample_+3A_trained">trained</code></td>
<td>
<p>A logical to indicate if the quantities for
preprocessing have been estimated.</p>
</td></tr>
<tr><td><code id="step_downsample_+3A_column">column</code></td>
<td>
<p>A character string of the variable name that will
be populated (eventually) by the <code>...</code> selectors.</p>
</td></tr>
<tr><td><code id="step_downsample_+3A_target">target</code></td>
<td>
<p>An integer that will be used to subsample. This
should not be set by the user and will be populated by <code>prep</code>.</p>
</td></tr>
<tr><td><code id="step_downsample_+3A_skip">skip</code></td>
<td>
<p>A logical. Should the step be skipped when the
recipe is baked by <code><a href="recipes.html#topic+bake">bake()</a></code>? While all operations are baked
when <code><a href="recipes.html#topic+prep">prep()</a></code> is run, some operations may not be able to be
conducted on new data (e.g. processing the outcome variable(s)).
Care should be taken when using <code>skip = TRUE</code> as it may affect
the computations for subsequent operations.</p>
</td></tr>
<tr><td><code id="step_downsample_+3A_seed">seed</code></td>
<td>
<p>An integer that will be used as the seed when downsampling.</p>
</td></tr>
<tr><td><code id="step_downsample_+3A_id">id</code></td>
<td>
<p>A character string that is unique to this step to identify it.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Down-sampling is intended to be performed on the <em>training</em> set
alone. For this reason, the default is <code>skip = TRUE</code>.
</p>
<p>If there are missing values in the factor variable that is used
to define the sampling, missing data are selected at random in
the same way that the other factor levels are sampled. Missing
values are not used to determine the amount of data in the
minority level
</p>
<p>For any data with factor levels occurring with the same
frequency as the minority level, all data will be retained.
</p>
<p>All columns in the data are sampled and returned by <code><a href="recipes.html#topic+juice">recipes::juice()</a></code>
and <code><a href="recipes.html#topic+bake">recipes::bake()</a></code>.
</p>
<p>Keep in mind that the location of down-sampling in the step
may have effects. For example, if centering and scaling,
it is not clear whether those operations should be conducted
<em>before</em> or <em>after</em> rows are removed.
</p>


<h3>Value</h3>

<p>An updated version of <code>recipe</code> with the new step
added to the sequence of existing steps (if any). For the
<code>tidy</code> method, a tibble with columns <code>terms</code> which is
the variable used to sample.
</p>


<h3>Tidying</h3>

<p>When you <code><a href="recipes.html#topic+tidy.recipe">tidy()</a></code> this step, a tibble is retruned with
columns <code>terms</code> and <code>id</code>:
</p>

<dl>
<dt>terms</dt><dd><p>character, the selectors or variables selected</p>
</dd>
<dt>id</dt><dd><p>character, id of this step</p>
</dd>
</dl>



<h3>Tuning Parameters</h3>

<p>This step has 1 tuning parameters:
</p>

<ul>
<li> <p><code>under_ratio</code>: Under-Sampling Ratio (type: double, default: 1)
</p>
</li></ul>



<h3>Case weights</h3>

<p>This step performs an unsupervised operation that can utilize case weights.
To use them, see the documentation in <a href="recipes.html#topic+case_weights">recipes::case_weights</a> and the examples on
<code>tidymodels.org</code>.
</p>


<h3>See Also</h3>

<p>Other Steps for under-sampling: 
<code><a href="#topic+step_nearmiss">step_nearmiss</a>()</code>,
<code><a href="#topic+step_tomek">step_tomek</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(recipes)
library(modeldata)
data(hpc_data)

hpc_data0 &lt;- hpc_data %&gt;%
  select(-protocol, -day)

orig &lt;- count(hpc_data0, class, name = "orig")
orig

up_rec &lt;- recipe(class ~ ., data = hpc_data0) %&gt;%
  # Bring the majority levels down to about 1000 each
  # 1000/259 is approx 3.862
  step_downsample(class, under_ratio = 3.862) %&gt;%
  prep()

training &lt;- up_rec %&gt;%
  bake(new_data = NULL) %&gt;%
  count(class, name = "training")
training

# Since `skip` defaults to TRUE, baking the step has no effect
baked &lt;- up_rec %&gt;%
  bake(new_data = hpc_data0) %&gt;%
  count(class, name = "baked")
baked

# Note that if the original data contained more rows than the
# target n (= ratio * majority_n), the data are left alone:
orig %&gt;%
  left_join(training, by = "class") %&gt;%
  left_join(baked, by = "class")

library(ggplot2)

ggplot(circle_example, aes(x, y, color = class)) +
  geom_point() +
  labs(title = "Without downsample")

recipe(class ~ x + y, data = circle_example) %&gt;%
  step_downsample(class) %&gt;%
  prep() %&gt;%
  bake(new_data = NULL) %&gt;%
  ggplot(aes(x, y, color = class)) +
  geom_point() +
  labs(title = "With downsample")

</code></pre>

<hr>
<h2 id='step_nearmiss'>Remove Points Near Other Classes</h2><span id='topic+step_nearmiss'></span><span id='topic+tidy.step_nearmiss'></span>

<h3>Description</h3>

<p><code>step_nearmiss()</code> creates a <em>specification</em> of a recipe step that removes
majority class instances by undersampling points in the majority class based
on their distance to other points in the same class.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>step_nearmiss(
  recipe,
  ...,
  role = NA,
  trained = FALSE,
  column = NULL,
  under_ratio = 1,
  neighbors = 5,
  skip = TRUE,
  seed = sample.int(10^5, 1),
  id = rand_id("nearmiss")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="step_nearmiss_+3A_recipe">recipe</code></td>
<td>
<p>A recipe object. The step will be added to the
sequence of operations for this recipe.</p>
</td></tr>
<tr><td><code id="step_nearmiss_+3A_...">...</code></td>
<td>
<p>One or more selector functions to choose which
variable is used to sample the data. See <a href="recipes.html#topic+selections">recipes::selections</a>
for more details. The selection should result in <em>single
factor variable</em>. For the <code>tidy</code> method, these are not
currently used.</p>
</td></tr>
<tr><td><code id="step_nearmiss_+3A_role">role</code></td>
<td>
<p>Not used by this step since no new variables are
created.</p>
</td></tr>
<tr><td><code id="step_nearmiss_+3A_trained">trained</code></td>
<td>
<p>A logical to indicate if the quantities for
preprocessing have been estimated.</p>
</td></tr>
<tr><td><code id="step_nearmiss_+3A_column">column</code></td>
<td>
<p>A character string of the variable name that will
be populated (eventually) by the <code>...</code> selectors.</p>
</td></tr>
<tr><td><code id="step_nearmiss_+3A_under_ratio">under_ratio</code></td>
<td>
<p>A numeric value for the ratio of the
majority-to-minority frequencies. The default value (1) means
that all other levels are sampled down to have the same
frequency as the least occurring level. A value of 2 would mean
that the majority levels will have (at most) (approximately)
twice as many rows than the minority level.</p>
</td></tr>
<tr><td><code id="step_nearmiss_+3A_neighbors">neighbors</code></td>
<td>
<p>An integer. Number of nearest neighbor that are used
to generate the new examples of the minority class.</p>
</td></tr>
<tr><td><code id="step_nearmiss_+3A_skip">skip</code></td>
<td>
<p>A logical. Should the step be skipped when the
recipe is baked by <code><a href="recipes.html#topic+bake">bake()</a></code>? While all operations are baked
when <code><a href="recipes.html#topic+prep">prep()</a></code> is run, some operations may not be able to be
conducted on new data (e.g. processing the outcome variable(s)).
Care should be taken when using <code>skip = TRUE</code> as it may affect
the computations for subsequent operations.</p>
</td></tr>
<tr><td><code id="step_nearmiss_+3A_seed">seed</code></td>
<td>
<p>An integer that will be used as the seed when
applied.</p>
</td></tr>
<tr><td><code id="step_nearmiss_+3A_id">id</code></td>
<td>
<p>A character string that is unique to this step to identify it.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This method retains the points from the majority class which have the
smallest mean distance to the k nearest points in the minority class.
</p>
<p>All columns in the data are sampled and returned by <code><a href="recipes.html#topic+juice">recipes::juice()</a></code>
and <code><a href="recipes.html#topic+bake">recipes::bake()</a></code>.
</p>
<p>All columns used in this step must be numeric with no missing data.
</p>
<p>When used in modeling, users should strongly consider using the
option <code>skip = TRUE</code> so that the extra sampling is <em>not</em>
conducted outside of the training set.
</p>


<h3>Value</h3>

<p>An updated version of <code>recipe</code> with the new step
added to the sequence of existing steps (if any). For the
<code>tidy</code> method, a tibble with columns <code>terms</code> which is
the variable used to sample.
</p>


<h3>Tidying</h3>

<p>When you <code><a href="recipes.html#topic+tidy.recipe">tidy()</a></code> this step, a tibble is retruned with
columns <code>terms</code> and <code>id</code>:
</p>

<dl>
<dt>terms</dt><dd><p>character, the selectors or variables selected</p>
</dd>
<dt>id</dt><dd><p>character, id of this step</p>
</dd>
</dl>



<h3>Tuning Parameters</h3>

<p>This step has 2 tuning parameters:
</p>

<ul>
<li> <p><code>under_ratio</code>: Under-Sampling Ratio (type: double, default: 1)
</p>
</li>
<li> <p><code>neighbors</code>: # Nearest Neighbors (type: integer, default: 5)
</p>
</li></ul>



<h3>Case weights</h3>

<p>The underlying operation does not allow for case weights.
</p>


<h3>References</h3>

<p>Inderjeet Mani and I Zhang. knn approach to unbalanced data
distributions: a case study involving information extraction. In Proceedings
of workshop on learning from imbalanced datasets, 2003.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+nearmiss">nearmiss()</a></code> for direct implementation
</p>
<p>Other Steps for under-sampling: 
<code><a href="#topic+step_downsample">step_downsample</a>()</code>,
<code><a href="#topic+step_tomek">step_tomek</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(recipes)
library(modeldata)
data(hpc_data)

hpc_data0 &lt;- hpc_data %&gt;%
  select(-protocol, -day)

orig &lt;- count(hpc_data0, class, name = "orig")
orig

up_rec &lt;- recipe(class ~ ., data = hpc_data0) %&gt;%
  # Bring the majority levels down to about 1000 each
  # 1000/259 is approx 3.862
  step_nearmiss(class, under_ratio = 3.862) %&gt;%
  prep()

training &lt;- up_rec %&gt;%
  bake(new_data = NULL) %&gt;%
  count(class, name = "training")
training

# Since `skip` defaults to TRUE, baking the step has no effect
baked &lt;- up_rec %&gt;%
  bake(new_data = hpc_data0) %&gt;%
  count(class, name = "baked")
baked

# Note that if the original data contained more rows than the
# target n (= ratio * majority_n), the data are left alone:
orig %&gt;%
  left_join(training, by = "class") %&gt;%
  left_join(baked, by = "class")

library(ggplot2)

ggplot(circle_example, aes(x, y, color = class)) +
  geom_point() +
  labs(title = "Without NEARMISS") +
  xlim(c(1, 15)) +
  ylim(c(1, 15))

recipe(class ~ x + y, data = circle_example) %&gt;%
  step_nearmiss(class) %&gt;%
  prep() %&gt;%
  bake(new_data = NULL) %&gt;%
  ggplot(aes(x, y, color = class)) +
  geom_point() +
  labs(title = "With NEARMISS") +
  xlim(c(1, 15)) +
  ylim(c(1, 15))

</code></pre>

<hr>
<h2 id='step_rose'>Apply ROSE Algorithm</h2><span id='topic+step_rose'></span><span id='topic+tidy.step_rose'></span>

<h3>Description</h3>

<p><code>step_rose()</code> creates a <em>specification</em> of a recipe step that generates
sample of synthetic data by enlarging the features space of minority and
majority class example. Using <code><a href="ROSE.html#topic+ROSE">ROSE::ROSE()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>step_rose(
  recipe,
  ...,
  role = NA,
  trained = FALSE,
  column = NULL,
  over_ratio = 1,
  minority_prop = 0.5,
  minority_smoothness = 1,
  majority_smoothness = 1,
  skip = TRUE,
  seed = sample.int(10^5, 1),
  id = rand_id("rose")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="step_rose_+3A_recipe">recipe</code></td>
<td>
<p>A recipe object. The step will be added to the
sequence of operations for this recipe.</p>
</td></tr>
<tr><td><code id="step_rose_+3A_...">...</code></td>
<td>
<p>One or more selector functions to choose which
variable is used to sample the data. See <a href="recipes.html#topic+selections">recipes::selections</a>
for more details. The selection should result in <em>single
factor variable</em>. For the <code>tidy</code> method, these are not
currently used.</p>
</td></tr>
<tr><td><code id="step_rose_+3A_role">role</code></td>
<td>
<p>Not used by this step since no new variables are
created.</p>
</td></tr>
<tr><td><code id="step_rose_+3A_trained">trained</code></td>
<td>
<p>A logical to indicate if the quantities for
preprocessing have been estimated.</p>
</td></tr>
<tr><td><code id="step_rose_+3A_column">column</code></td>
<td>
<p>A character string of the variable name that will
be populated (eventually) by the <code>...</code> selectors.</p>
</td></tr>
<tr><td><code id="step_rose_+3A_over_ratio">over_ratio</code></td>
<td>
<p>A numeric value for the ratio of the
minority-to-majority frequencies. The default value (1) means
that all other levels are sampled up to have the same
frequency as the most occurring level. A value of 0.5 would mean
that the minority levels will have (at most) (approximately)
half as many rows than the majority level.</p>
</td></tr>
<tr><td><code id="step_rose_+3A_minority_prop">minority_prop</code></td>
<td>
<p>A numeric. Determines the of over-sampling of the
minority class. Defaults to 0.5.</p>
</td></tr>
<tr><td><code id="step_rose_+3A_minority_smoothness">minority_smoothness</code></td>
<td>
<p>A numeric. Shrink factor to be multiplied by the
smoothing parameters to estimate the conditional kernel density of the
minority class. Defaults to 1.</p>
</td></tr>
<tr><td><code id="step_rose_+3A_majority_smoothness">majority_smoothness</code></td>
<td>
<p>A numeric. Shrink factor to be multiplied by the
smoothing parameters to estimate the conditional kernel density of the
majority class. Defaults to 1.</p>
</td></tr>
<tr><td><code id="step_rose_+3A_skip">skip</code></td>
<td>
<p>A logical. Should the step be skipped when the
recipe is baked by <code><a href="recipes.html#topic+bake">bake()</a></code>? While all operations are baked
when <code><a href="recipes.html#topic+prep">prep()</a></code> is run, some operations may not be able to be
conducted on new data (e.g. processing the outcome variable(s)).
Care should be taken when using <code>skip = TRUE</code> as it may affect
the computations for subsequent operations.</p>
</td></tr>
<tr><td><code id="step_rose_+3A_seed">seed</code></td>
<td>
<p>An integer that will be used as the seed when
rose-ing.</p>
</td></tr>
<tr><td><code id="step_rose_+3A_id">id</code></td>
<td>
<p>A character string that is unique to this step to identify it.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The factor variable used to balance around must only have 2 levels.
</p>
<p>The ROSE algorithm works by selecting an observation belonging to class k
and generates new examples  in its neighborhood is determined by some matrix
H_k. Smaller values of these arguments have the effect of shrinking the
entries of the corresponding smoothing matrix H_k, Shrinking would be a
cautious choice if there is a concern that excessively large neighborhoods
could lead to blur the boundaries between the regions of the feature space
associated with each class.
</p>
<p>All columns in the data are sampled and returned by <code><a href="recipes.html#topic+juice">recipes::juice()</a></code>
and <code><a href="recipes.html#topic+bake">recipes::bake()</a></code>.
</p>
<p>When used in modeling, users should strongly consider using the
option <code>skip = TRUE</code> so that the extra sampling is <em>not</em>
conducted outside of the training set.
</p>


<h3>Value</h3>

<p>An updated version of <code>recipe</code> with the new step
added to the sequence of existing steps (if any). For the
<code>tidy</code> method, a tibble with columns <code>terms</code> which is
the variable used to sample.
</p>


<h3>Tidying</h3>

<p>When you <code><a href="recipes.html#topic+tidy.recipe">tidy()</a></code> this step, a tibble is retruned with
columns <code>terms</code> and <code>id</code>:
</p>

<dl>
<dt>terms</dt><dd><p>character, the selectors or variables selected</p>
</dd>
<dt>id</dt><dd><p>character, id of this step</p>
</dd>
</dl>



<h3>Tuning Parameters</h3>

<p>This step has 1 tuning parameters:
</p>

<ul>
<li> <p><code>over_ratio</code>: Over-Sampling Ratio (type: double, default: 1)
</p>
</li></ul>



<h3>Case weights</h3>

<p>The underlying operation does not allow for case weights.
</p>


<h3>References</h3>

<p>Lunardon, N., Menardi, G., and Torelli, N. (2014). ROSE: a
Package for Binary Imbalanced Learning. R Jorunal, 6:82–92.
</p>
<p>Menardi, G. and Torelli, N. (2014). Training and assessing
classification rules with imbalanced data. Data Mining and Knowledge
Discovery, 28:92–122.
</p>


<h3>See Also</h3>

<p>Other Steps for over-sampling: 
<code><a href="#topic+step_adasyn">step_adasyn</a>()</code>,
<code><a href="#topic+step_bsmote">step_bsmote</a>()</code>,
<code><a href="#topic+step_smote">step_smote</a>()</code>,
<code><a href="#topic+step_smotenc">step_smotenc</a>()</code>,
<code><a href="#topic+step_upsample">step_upsample</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(recipes)
library(modeldata)
data(hpc_data)

hpc_data0 &lt;- hpc_data %&gt;%
  mutate(class = factor(class == "VF", labels = c("not VF", "VF"))) %&gt;%
  select(-protocol, -day)

orig &lt;- count(hpc_data0, class, name = "orig")
orig

up_rec &lt;- recipe(class ~ ., data = hpc_data0) %&gt;%
  step_rose(class) %&gt;%
  prep()

training &lt;- up_rec %&gt;%
  bake(new_data = NULL) %&gt;%
  count(class, name = "training")
training

# Since `skip` defaults to TRUE, baking the step has no effect
baked &lt;- up_rec %&gt;%
  bake(new_data = hpc_data0) %&gt;%
  count(class, name = "baked")
baked

orig %&gt;%
  left_join(training, by = "class") %&gt;%
  left_join(baked, by = "class")

library(ggplot2)

ggplot(circle_example, aes(x, y, color = class)) +
  geom_point() +
  labs(title = "Without ROSE")

recipe(class ~ x + y, data = circle_example) %&gt;%
  step_rose(class) %&gt;%
  prep() %&gt;%
  bake(new_data = NULL) %&gt;%
  ggplot(aes(x, y, color = class)) +
  geom_point() +
  labs(title = "With ROSE")

</code></pre>

<hr>
<h2 id='step_smote'>Apply SMOTE Algorithm</h2><span id='topic+step_smote'></span><span id='topic+tidy.step_smote'></span>

<h3>Description</h3>

<p><code>step_smote()</code> creates a <em>specification</em> of a recipe step that generate new
examples of the  minority class using nearest neighbors of these cases.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>step_smote(
  recipe,
  ...,
  role = NA,
  trained = FALSE,
  column = NULL,
  over_ratio = 1,
  neighbors = 5,
  skip = TRUE,
  seed = sample.int(10^5, 1),
  id = rand_id("smote")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="step_smote_+3A_recipe">recipe</code></td>
<td>
<p>A recipe object. The step will be added to the
sequence of operations for this recipe.</p>
</td></tr>
<tr><td><code id="step_smote_+3A_...">...</code></td>
<td>
<p>One or more selector functions to choose which
variable is used to sample the data. See <a href="recipes.html#topic+selections">recipes::selections</a>
for more details. The selection should result in <em>single
factor variable</em>. For the <code>tidy</code> method, these are not
currently used.</p>
</td></tr>
<tr><td><code id="step_smote_+3A_role">role</code></td>
<td>
<p>Not used by this step since no new variables are
created.</p>
</td></tr>
<tr><td><code id="step_smote_+3A_trained">trained</code></td>
<td>
<p>A logical to indicate if the quantities for
preprocessing have been estimated.</p>
</td></tr>
<tr><td><code id="step_smote_+3A_column">column</code></td>
<td>
<p>A character string of the variable name that will
be populated (eventually) by the <code>...</code> selectors.</p>
</td></tr>
<tr><td><code id="step_smote_+3A_over_ratio">over_ratio</code></td>
<td>
<p>A numeric value for the ratio of the
minority-to-majority frequencies. The default value (1) means
that all other levels are sampled up to have the same
frequency as the most occurring level. A value of 0.5 would mean
that the minority levels will have (at most) (approximately)
half as many rows than the majority level.</p>
</td></tr>
<tr><td><code id="step_smote_+3A_neighbors">neighbors</code></td>
<td>
<p>An integer. Number of nearest neighbor that are used
to generate the new examples of the minority class.</p>
</td></tr>
<tr><td><code id="step_smote_+3A_skip">skip</code></td>
<td>
<p>A logical. Should the step be skipped when the
recipe is baked by <code><a href="recipes.html#topic+bake">bake()</a></code>? While all operations are baked
when <code><a href="recipes.html#topic+prep">prep()</a></code> is run, some operations may not be able to be
conducted on new data (e.g. processing the outcome variable(s)).
Care should be taken when using <code>skip = TRUE</code> as it may affect
the computations for subsequent operations.</p>
</td></tr>
<tr><td><code id="step_smote_+3A_seed">seed</code></td>
<td>
<p>An integer that will be used as the seed when
smote-ing.</p>
</td></tr>
<tr><td><code id="step_smote_+3A_id">id</code></td>
<td>
<p>A character string that is unique to this step to identify it.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The parameter <code>neighbors</code> controls the way the new examples are created.
For each currently existing minority class example X new examples will be
created (this is controlled by the parameter <code>over_ratio</code> as mentioned
above). These examples will be generated by using the information from the
<code>neighbors</code> nearest neighbor of each example of the minority class.
The parameter <code>neighbors</code> controls how many of these neighbor are used.
</p>
<p>All columns in the data are sampled and returned by <code><a href="recipes.html#topic+juice">recipes::juice()</a></code>
and <code><a href="recipes.html#topic+bake">recipes::bake()</a></code>.
</p>
<p>All columns used in this step must be numeric with no missing data.
</p>
<p>When used in modeling, users should strongly consider using the
option <code>skip = TRUE</code> so that the extra sampling is <em>not</em>
conducted outside of the training set.
</p>


<h3>Value</h3>

<p>An updated version of <code>recipe</code> with the new step
added to the sequence of existing steps (if any). For the
<code>tidy</code> method, a tibble with columns <code>terms</code> which is
the variable used to sample.
</p>


<h3>Tidying</h3>

<p>When you <code><a href="recipes.html#topic+tidy.recipe">tidy()</a></code> this step, a tibble is retruned with
columns <code>terms</code> and <code>id</code>:
</p>

<dl>
<dt>terms</dt><dd><p>character, the selectors or variables selected</p>
</dd>
<dt>id</dt><dd><p>character, id of this step</p>
</dd>
</dl>



<h3>Tuning Parameters</h3>

<p>This step has 2 tuning parameters:
</p>

<ul>
<li> <p><code>over_ratio</code>: Over-Sampling Ratio (type: double, default: 1)
</p>
</li>
<li> <p><code>neighbors</code>: # Nearest Neighbors (type: integer, default: 5)
</p>
</li></ul>



<h3>Case weights</h3>

<p>The underlying operation does not allow for case weights.
</p>


<h3>References</h3>

<p>Chawla, N. V., Bowyer, K. W., Hall, L. O., and Kegelmeyer,
W. P. (2002). Smote: Synthetic minority over-sampling technique.
Journal of Artificial Intelligence Research, 16:321-357.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+smote">smote()</a></code> for direct implementation
</p>
<p>Other Steps for over-sampling: 
<code><a href="#topic+step_adasyn">step_adasyn</a>()</code>,
<code><a href="#topic+step_bsmote">step_bsmote</a>()</code>,
<code><a href="#topic+step_rose">step_rose</a>()</code>,
<code><a href="#topic+step_smotenc">step_smotenc</a>()</code>,
<code><a href="#topic+step_upsample">step_upsample</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(recipes)
library(modeldata)
data(hpc_data)

hpc_data0 &lt;- hpc_data %&gt;%
  select(-protocol, -day)

orig &lt;- count(hpc_data0, class, name = "orig")
orig

up_rec &lt;- recipe(class ~ ., data = hpc_data0) %&gt;%
  # Bring the minority levels up to about 1000 each
  # 1000/2211 is approx 0.4523
  step_smote(class, over_ratio = 0.4523) %&gt;%
  prep()

training &lt;- up_rec %&gt;%
  bake(new_data = NULL) %&gt;%
  count(class, name = "training")
training

# Since `skip` defaults to TRUE, baking the step has no effect
baked &lt;- up_rec %&gt;%
  bake(new_data = hpc_data0) %&gt;%
  count(class, name = "baked")
baked

# Note that if the original data contained more rows than the
# target n (= ratio * majority_n), the data are left alone:
orig %&gt;%
  left_join(training, by = "class") %&gt;%
  left_join(baked, by = "class")

library(ggplot2)

ggplot(circle_example, aes(x, y, color = class)) +
  geom_point() +
  labs(title = "Without SMOTE")

recipe(class ~ x + y, data = circle_example) %&gt;%
  step_smote(class) %&gt;%
  prep() %&gt;%
  bake(new_data = NULL) %&gt;%
  ggplot(aes(x, y, color = class)) +
  geom_point() +
  labs(title = "With SMOTE")

</code></pre>

<hr>
<h2 id='step_smotenc'>Apply SMOTENC algorithm</h2><span id='topic+step_smotenc'></span><span id='topic+tidy.step_smotenc'></span>

<h3>Description</h3>

<p><code>step_smotenc()</code> creates a <em>specification</em> of a recipe step that generate new
examples of the  minority class using nearest neighbors of these cases.
Gower's distance is used to handle mixed data types. For categorical
variables, the most common category along neighbors is chosen.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>step_smotenc(
  recipe,
  ...,
  role = NA,
  trained = FALSE,
  column = NULL,
  over_ratio = 1,
  neighbors = 5,
  skip = TRUE,
  seed = sample.int(10^5, 1),
  id = rand_id("smotenc")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="step_smotenc_+3A_recipe">recipe</code></td>
<td>
<p>A recipe object. The step will be added to the
sequence of operations for this recipe.</p>
</td></tr>
<tr><td><code id="step_smotenc_+3A_...">...</code></td>
<td>
<p>One or more selector functions to choose which
variable is used to sample the data. See <a href="recipes.html#topic+selections">recipes::selections</a>
for more details. The selection should result in <em>single
factor variable</em>. For the <code>tidy</code> method, these are not
currently used.</p>
</td></tr>
<tr><td><code id="step_smotenc_+3A_role">role</code></td>
<td>
<p>Not used by this step since no new variables are
created.</p>
</td></tr>
<tr><td><code id="step_smotenc_+3A_trained">trained</code></td>
<td>
<p>A logical to indicate if the quantities for
preprocessing have been estimated.</p>
</td></tr>
<tr><td><code id="step_smotenc_+3A_column">column</code></td>
<td>
<p>A character string of the variable name that will
be populated (eventually) by the <code>...</code> selectors.</p>
</td></tr>
<tr><td><code id="step_smotenc_+3A_over_ratio">over_ratio</code></td>
<td>
<p>A numeric value for the ratio of the
minority-to-majority frequencies. The default value (1) means
that all other levels are sampled up to have the same
frequency as the most occurring level. A value of 0.5 would mean
that the minority levels will have (at most) (approximately)
half as many rows than the majority level.</p>
</td></tr>
<tr><td><code id="step_smotenc_+3A_neighbors">neighbors</code></td>
<td>
<p>An integer. Number of nearest neighbor that are used
to generate the new examples of the minority class.</p>
</td></tr>
<tr><td><code id="step_smotenc_+3A_skip">skip</code></td>
<td>
<p>A logical. Should the step be skipped when the
recipe is baked by <code><a href="recipes.html#topic+bake">bake()</a></code>? While all operations are baked
when <code><a href="recipes.html#topic+prep">prep()</a></code> is run, some operations may not be able to be
conducted on new data (e.g. processing the outcome variable(s)).
Care should be taken when using <code>skip = TRUE</code> as it may affect
the computations for subsequent operations.</p>
</td></tr>
<tr><td><code id="step_smotenc_+3A_seed">seed</code></td>
<td>
<p>An integer that will be used as the seed when
smote-ing.</p>
</td></tr>
<tr><td><code id="step_smotenc_+3A_id">id</code></td>
<td>
<p>A character string that is unique to this step to identify it.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The parameter <code>neighbors</code> controls the way the new examples are created.
For each currently existing minority class example X new examples will be
created (this is controlled by the parameter <code>over_ratio</code> as mentioned
above). These examples will be generated by using the information from the
<code>neighbors</code> nearest neighbor of each example of the minority class.
The parameter <code>neighbors</code> controls how many of these neighbor are used.
</p>
<p>All columns in the data are sampled and returned by <code><a href="recipes.html#topic+juice">recipes::juice()</a></code>
and <code><a href="recipes.html#topic+bake">recipes::bake()</a></code>.
</p>
<p>Columns can be numeric and categorical with no missing data.
</p>
<p>When used in modeling, users should strongly consider using the
option <code>skip = TRUE</code> so that the extra sampling is <em>not</em>
conducted outside of the training set.
</p>


<h3>Value</h3>

<p>An updated version of <code>recipe</code> with the new step
added to the sequence of existing steps (if any). For the
<code>tidy</code> method, a tibble with columns <code>terms</code> which is
the variable used to sample.
</p>


<h3>Tidying</h3>

<p>When you <code><a href="recipes.html#topic+tidy.recipe">tidy()</a></code> this step, a tibble is retruned with
columns <code>terms</code> and <code>id</code>:
</p>

<dl>
<dt>terms</dt><dd><p>character, the selectors or variables selected</p>
</dd>
<dt>id</dt><dd><p>character, id of this step</p>
</dd>
</dl>



<h3>Tuning Parameters</h3>

<p>This step has 2 tuning parameters:
</p>

<ul>
<li> <p><code>over_ratio</code>: Over-Sampling Ratio (type: double, default: 1)
</p>
</li>
<li> <p><code>neighbors</code>: # Nearest Neighbors (type: integer, default: 5)
</p>
</li></ul>



<h3>Case weights</h3>

<p>The underlying operation does not allow for case weights.
</p>


<h3>References</h3>

<p>Chawla, N. V., Bowyer, K. W., Hall, L. O., and Kegelmeyer,
W. P. (2002). Smote: Synthetic minority over-sampling technique.
Journal of Artificial Intelligence Research, 16:321-357.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+smotenc">smotenc()</a></code> for direct implementation
</p>
<p>Other Steps for over-sampling: 
<code><a href="#topic+step_adasyn">step_adasyn</a>()</code>,
<code><a href="#topic+step_bsmote">step_bsmote</a>()</code>,
<code><a href="#topic+step_rose">step_rose</a>()</code>,
<code><a href="#topic+step_smote">step_smote</a>()</code>,
<code><a href="#topic+step_upsample">step_upsample</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(recipes)
library(modeldata)
data(hpc_data)

orig &lt;- count(hpc_data, class, name = "orig")
orig

up_rec &lt;- recipe(class ~ ., data = hpc_data) %&gt;%
  step_impute_knn(all_predictors()) %&gt;%
  # Bring the minority levels up to about 1000 each
  # 1000/2211 is approx 0.4523
  step_smotenc(class, over_ratio = 0.4523) %&gt;%
  prep()

training &lt;- up_rec %&gt;%
  bake(new_data = NULL) %&gt;%
  count(class, name = "training")
training

# Since `skip` defaults to TRUE, baking the step has no effect
baked &lt;- up_rec %&gt;%
  bake(new_data = hpc_data) %&gt;%
  count(class, name = "baked")
baked

# Note that if the original data contained more rows than the
# target n (= ratio * majority_n), the data are left alone:
orig %&gt;%
  left_join(training, by = "class") %&gt;%
  left_join(baked, by = "class")

</code></pre>

<hr>
<h2 id='step_tomek'>Remove Tomek’s Links</h2><span id='topic+step_tomek'></span><span id='topic+tidy.step_tomek'></span>

<h3>Description</h3>

<p><code>step_tomek()</code> creates a <em>specification</em> of a recipe step that removes
majority class instances of tomek links.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>step_tomek(
  recipe,
  ...,
  role = NA,
  trained = FALSE,
  column = NULL,
  skip = TRUE,
  seed = sample.int(10^5, 1),
  id = rand_id("tomek")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="step_tomek_+3A_recipe">recipe</code></td>
<td>
<p>A recipe object. The step will be added to the
sequence of operations for this recipe.</p>
</td></tr>
<tr><td><code id="step_tomek_+3A_...">...</code></td>
<td>
<p>One or more selector functions to choose which
variable is used to sample the data. See <a href="recipes.html#topic+selections">recipes::selections</a>
for more details. The selection should result in <em>single
factor variable</em>. For the <code>tidy</code> method, these are not
currently used.</p>
</td></tr>
<tr><td><code id="step_tomek_+3A_role">role</code></td>
<td>
<p>Not used by this step since no new variables are
created.</p>
</td></tr>
<tr><td><code id="step_tomek_+3A_trained">trained</code></td>
<td>
<p>A logical to indicate if the quantities for
preprocessing have been estimated.</p>
</td></tr>
<tr><td><code id="step_tomek_+3A_column">column</code></td>
<td>
<p>A character string of the variable name that will
be populated (eventually) by the <code>...</code> selectors.</p>
</td></tr>
<tr><td><code id="step_tomek_+3A_skip">skip</code></td>
<td>
<p>A logical. Should the step be skipped when the
recipe is baked by <code><a href="recipes.html#topic+bake">bake()</a></code>? While all operations are baked
when <code><a href="recipes.html#topic+prep">prep()</a></code> is run, some operations may not be able to be
conducted on new data (e.g. processing the outcome variable(s)).
Care should be taken when using <code>skip = TRUE</code> as it may affect
the computations for subsequent operations.</p>
</td></tr>
<tr><td><code id="step_tomek_+3A_seed">seed</code></td>
<td>
<p>An integer that will be used as the seed when
applied.</p>
</td></tr>
<tr><td><code id="step_tomek_+3A_id">id</code></td>
<td>
<p>A character string that is unique to this step to identify it.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The factor variable used to balance around must only have 2 levels. All
other variables must be numerics with no missing data.
</p>
<p>A tomek link is defined as a pair of points from different classes and are
each others nearest neighbors.
</p>
<p>All columns in the data are sampled and returned by <code><a href="recipes.html#topic+juice">recipes::juice()</a></code>
and <code><a href="recipes.html#topic+bake">recipes::bake()</a></code>.
</p>
<p>When used in modeling, users should strongly consider using the
option <code>skip = TRUE</code> so that the extra sampling is <em>not</em>
conducted outside of the training set.
</p>


<h3>Value</h3>

<p>An updated version of <code>recipe</code> with the new step
added to the sequence of existing steps (if any). For the
<code>tidy</code> method, a tibble with columns <code>terms</code> which is
the variable used to sample.
</p>


<h3>Tidying</h3>

<p>When you <code><a href="recipes.html#topic+tidy.recipe">tidy()</a></code> this step, a tibble is retruned with
columns <code>terms</code> and <code>id</code>:
</p>

<dl>
<dt>terms</dt><dd><p>character, the selectors or variables selected</p>
</dd>
<dt>id</dt><dd><p>character, id of this step</p>
</dd>
</dl>



<h3>Case weights</h3>

<p>The underlying operation does not allow for case weights.
</p>


<h3>References</h3>

<p>Tomek. Two modifications of cnn. IEEE Trans. Syst. Man Cybern.,
6:769-772, 1976.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+tomek">tomek()</a></code> for direct implementation
</p>
<p>Other Steps for under-sampling: 
<code><a href="#topic+step_downsample">step_downsample</a>()</code>,
<code><a href="#topic+step_nearmiss">step_nearmiss</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(recipes)
library(modeldata)
data(hpc_data)

hpc_data0 &lt;- hpc_data %&gt;%
  select(-protocol, -day)

orig &lt;- count(hpc_data0, class, name = "orig")
orig

up_rec &lt;- recipe(class ~ ., data = hpc_data0) %&gt;%
  step_tomek(class) %&gt;%
  prep()

training &lt;- up_rec %&gt;%
  bake(new_data = NULL) %&gt;%
  count(class, name = "training")
training

# Since `skip` defaults to TRUE, baking the step has no effect
baked &lt;- up_rec %&gt;%
  bake(new_data = hpc_data0) %&gt;%
  count(class, name = "baked")
baked

orig %&gt;%
  left_join(training, by = "class") %&gt;%
  left_join(baked, by = "class")

library(ggplot2)

ggplot(circle_example, aes(x, y, color = class)) +
  geom_point() +
  labs(title = "Without Tomek") +
  xlim(c(1, 15)) +
  ylim(c(1, 15))

recipe(class ~ x + y, data = circle_example) %&gt;%
  step_tomek(class) %&gt;%
  prep() %&gt;%
  bake(new_data = NULL) %&gt;%
  ggplot(aes(x, y, color = class)) +
  geom_point() +
  labs(title = "With Tomek") +
  xlim(c(1, 15)) +
  ylim(c(1, 15))

</code></pre>

<hr>
<h2 id='step_upsample'>Up-Sample a Data Set Based on a Factor Variable</h2><span id='topic+step_upsample'></span><span id='topic+tidy.step_upsample'></span>

<h3>Description</h3>

<p><code>step_upsample()</code> creates a <em>specification</em> of a recipe step that will
replicate rows of a data set to make the occurrence of levels in a specific
factor level equal.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>step_upsample(
  recipe,
  ...,
  over_ratio = 1,
  ratio = deprecated(),
  role = NA,
  trained = FALSE,
  column = NULL,
  target = NA,
  skip = TRUE,
  seed = sample.int(10^5, 1),
  id = rand_id("upsample")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="step_upsample_+3A_recipe">recipe</code></td>
<td>
<p>A recipe object. The step will be added to the
sequence of operations for this recipe.</p>
</td></tr>
<tr><td><code id="step_upsample_+3A_...">...</code></td>
<td>
<p>One or more selector functions to choose which
variable is used to sample the data. See <a href="recipes.html#topic+selections">recipes::selections</a>
for more details. The selection should result in <em>single
factor variable</em>. For the <code>tidy</code> method, these are not
currently used.</p>
</td></tr>
<tr><td><code id="step_upsample_+3A_over_ratio">over_ratio</code></td>
<td>
<p>A numeric value for the ratio of the
minority-to-majority frequencies. The default value (1) means
that all other levels are sampled up to have the same
frequency as the most occurring level. A value of 0.5 would mean
that the minority levels will have (at most) (approximately)
half as many rows than the majority level.</p>
</td></tr>
<tr><td><code id="step_upsample_+3A_ratio">ratio</code></td>
<td>
<p>Deprecated argument; same as <code>over_ratio</code>.</p>
</td></tr>
<tr><td><code id="step_upsample_+3A_role">role</code></td>
<td>
<p>Not used by this step since no new variables are
created.</p>
</td></tr>
<tr><td><code id="step_upsample_+3A_trained">trained</code></td>
<td>
<p>A logical to indicate if the quantities for
preprocessing have been estimated.</p>
</td></tr>
<tr><td><code id="step_upsample_+3A_column">column</code></td>
<td>
<p>A character string of the variable name that will
be populated (eventually) by the <code>...</code> selectors.</p>
</td></tr>
<tr><td><code id="step_upsample_+3A_target">target</code></td>
<td>
<p>An integer that will be used to subsample. This
should not be set by the user and will be populated by <code>prep</code>.</p>
</td></tr>
<tr><td><code id="step_upsample_+3A_skip">skip</code></td>
<td>
<p>A logical. Should the step be skipped when the
recipe is baked by <code><a href="recipes.html#topic+bake">bake()</a></code>? While all operations are baked
when <code><a href="recipes.html#topic+prep">prep()</a></code> is run, some operations may not be able to be
conducted on new data (e.g. processing the outcome variable(s)).
Care should be taken when using <code>skip = TRUE</code> as it may affect
the computations for subsequent operations.</p>
</td></tr>
<tr><td><code id="step_upsample_+3A_seed">seed</code></td>
<td>
<p>An integer that will be used as the seed when upsampling.</p>
</td></tr>
<tr><td><code id="step_upsample_+3A_id">id</code></td>
<td>
<p>A character string that is unique to this step to identify it.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Up-sampling is intended to be performed on the <em>training</em> set
alone. For this reason, the default is <code>skip = TRUE</code>.
</p>
<p>If there are missing values in the factor variable that is used
to define the sampling, missing data are selected at random in
the same way that the other factor levels are sampled. Missing
values are not used to determine the amount of data in the
majority level (see example below).
</p>
<p>For any data with factor levels occurring with the same
frequency as the majority level, all data will be retained.
</p>
<p>All columns in the data are sampled and returned by <code><a href="recipes.html#topic+juice">recipes::juice()</a></code>
and <code><a href="recipes.html#topic+bake">recipes::bake()</a></code>.
</p>


<h3>Value</h3>

<p>An updated version of <code>recipe</code> with the new step
added to the sequence of existing steps (if any). For the
<code>tidy</code> method, a tibble with columns <code>terms</code> which is
the variable used to sample.
</p>


<h3>Tidying</h3>

<p>When you <code><a href="recipes.html#topic+tidy.recipe">tidy()</a></code> this step, a tibble is retruned with
columns <code>terms</code> and <code>id</code>:
</p>

<dl>
<dt>terms</dt><dd><p>character, the selectors or variables selected</p>
</dd>
<dt>id</dt><dd><p>character, id of this step</p>
</dd>
</dl>



<h3>Tuning Parameters</h3>

<p>This step has 1 tuning parameters:
</p>

<ul>
<li> <p><code>over_ratio</code>: Over-Sampling Ratio (type: double, default: 1)
</p>
</li></ul>



<h3>Case weights</h3>

<p>This step performs an unsupervised operation that can utilize case weights.
To use them, see the documentation in <a href="recipes.html#topic+case_weights">recipes::case_weights</a> and the examples on
<code>tidymodels.org</code>.
</p>


<h3>See Also</h3>

<p>Other Steps for over-sampling: 
<code><a href="#topic+step_adasyn">step_adasyn</a>()</code>,
<code><a href="#topic+step_bsmote">step_bsmote</a>()</code>,
<code><a href="#topic+step_rose">step_rose</a>()</code>,
<code><a href="#topic+step_smote">step_smote</a>()</code>,
<code><a href="#topic+step_smotenc">step_smotenc</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(recipes)
library(modeldata)
data(hpc_data)

hpc_data0 &lt;- hpc_data %&gt;%
  select(-protocol, -day)

orig &lt;- count(hpc_data0, class, name = "orig")
orig

up_rec &lt;- recipe(class ~ ., data = hpc_data0) %&gt;%
  # Bring the minority levels up to about 1000 each
  # 1000/2211 is approx 0.4523
  step_upsample(class, over_ratio = 0.4523) %&gt;%
  prep()

training &lt;- up_rec %&gt;%
  bake(new_data = NULL) %&gt;%
  count(class, name = "training")
training

# Since `skip` defaults to TRUE, baking the step has no effect
baked &lt;- up_rec %&gt;%
  bake(new_data = hpc_data0) %&gt;%
  count(class, name = "baked")
baked

# Note that if the original data contained more rows than the
# target n (= ratio * majority_n), the data are left alone:
orig %&gt;%
  left_join(training, by = "class") %&gt;%
  left_join(baked, by = "class")

library(ggplot2)

ggplot(circle_example, aes(x, y, color = class)) +
  geom_point() +
  labs(title = "Without upsample")

recipe(class ~ x + y, data = circle_example) %&gt;%
  step_upsample(class) %&gt;%
  prep() %&gt;%
  bake(new_data = NULL) %&gt;%
  ggplot(aes(x, y, color = class)) +
  geom_jitter(width = 0.1, height = 0.1) +
  labs(title = "With upsample (with jittering)")

</code></pre>

<hr>
<h2 id='tomek'>Remove Tomek's links</h2><span id='topic+tomek'></span>

<h3>Description</h3>

<p>Removed observations that are part of tomek links.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tomek(df, var)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tomek_+3A_df">df</code></td>
<td>
<p>data.frame or tibble. Must have 1 factor variable and remaining
numeric variables.</p>
</td></tr>
<tr><td><code id="tomek_+3A_var">var</code></td>
<td>
<p>Character, name of variable containing factor variable.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>All columns used in this function must be numeric with no missing data.
</p>


<h3>Value</h3>

<p>A data.frame or tibble, depending on type of <code>df</code>.
</p>


<h3>References</h3>

<p>Tomek. Two modifications of cnn. IEEE Trans. Syst. Man Cybern.,
6:769-772, 1976.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+step_tomek">step_tomek()</a></code> for step function of this method
</p>
<p>Other Direct Implementations: 
<code><a href="#topic+adasyn">adasyn</a>()</code>,
<code><a href="#topic+bsmote">bsmote</a>()</code>,
<code><a href="#topic+nearmiss">nearmiss</a>()</code>,
<code><a href="#topic+smote">smote</a>()</code>,
<code><a href="#topic+smotenc">smotenc</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>circle_numeric &lt;- circle_example[, c("x", "y", "class")]

res &lt;- tomek(circle_numeric, var = "class")
</code></pre>

<hr>
<h2 id='tunable.step_adasyn'>tunable methods for themis</h2><span id='topic+tunable.step_adasyn'></span><span id='topic+tunable.step_bsmote'></span><span id='topic+tunable.step_downsample'></span><span id='topic+tunable.step_nearmiss'></span><span id='topic+tunable.step_rose'></span><span id='topic+tunable.step_smote'></span><span id='topic+tunable.step_smotenc'></span><span id='topic+tunable_themis'></span><span id='topic+tunable.step_upsample'></span>

<h3>Description</h3>

<p>These functions define what parameters <em>can</em> be tuned for specific steps.
They also define the recommended objects from the <code>dials</code> package that can
be used to generate new parameter values and other characteristics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'step_adasyn'
tunable(x, ...)

## S3 method for class 'step_bsmote'
tunable(x, ...)

## S3 method for class 'step_downsample'
tunable(x, ...)

## S3 method for class 'step_nearmiss'
tunable(x, ...)

## S3 method for class 'step_rose'
tunable(x, ...)

## S3 method for class 'step_smote'
tunable(x, ...)

## S3 method for class 'step_smotenc'
tunable(x, ...)

## S3 method for class 'step_upsample'
tunable(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tunable.step_adasyn_+3A_x">x</code></td>
<td>
<p>A recipe step object</p>
</td></tr>
<tr><td><code id="tunable.step_adasyn_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tibble object.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
