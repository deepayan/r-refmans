<!DOCTYPE html><html lang="en"><head><title>Help for package matrans</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {matrans}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#pred.transsmap'><p>Prediction for new data based on Trans-SMAP.</p></a></li>
<li><a href='#simdata.gen'><p>Generate multi-source data from partially linear models.</p></a></li>
<li><a href='#trans.smap'><p>Parameter-transfer learning for partially linear models based on semiparametric model averaging.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Model Averaging-Assisted Optimal Transfer Learning</td>
</tr>
<tr>
<td>Version:</td>
<td>0.2.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Transfer learning, as a prevailing technique in computer sciences, aims to improve the performance of a target model by leveraging auxiliary information from heterogeneous source data. We provide novel tools for multi-source transfer learning under statistical models based on model averaging strategies, including linear regression models, partially linear models. Unlike existing transfer learning approaches, this method integrates the auxiliary information through data-driven weight assignments to avoid negative transfer. This is the first package for transfer learning based on the optimal model averaging frameworks, providing efficient implementations for practitioners in multi-source data modeling. The details are described in Hu and Zhang (2023) <a href="https://jmlr.org/papers/v24/23-0030.html">https://jmlr.org/papers/v24/23-0030.html</a>.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Imports:</td>
<td>caret, formatR, glmnet, MASS, quadprog, splines, stats</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10)</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-03-12 00:54:55 UTC; huxiaonan</td>
</tr>
<tr>
<td>Author:</td>
<td>Xiaonan Hu <a href="https://orcid.org/0000-0001-7614-2249"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut,
    cre],
  Xinyu Zhang [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Xiaonan Hu &lt;xiaonanhu@cnu.edu.cn&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-03-12 03:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='pred.transsmap'>Prediction for new data based on Trans-SMAP.</h2><span id='topic+pred.transsmap'></span>

<h3>Description</h3>

<p>Obtain predictions from a &quot;trans.smap&quot; object based on new samples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pred.transsmap(object, newdata, bs.para, if.lm = FALSE, if.penalty = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pred.transsmap_+3A_object">object</code></td>
<td>
<p>the output of function <code>trans.smap</code>.</p>
</td></tr>
<tr><td><code id="pred.transsmap_+3A_newdata">newdata</code></td>
<td>
<p>a list containing the new observations of predictors for prediction, the components of which is named as &quot;data.x&quot; for parametric variables and &quot;data.z&quot; for nonparametric variables. Should be in accordance with the data for training <code>object</code>.</p>
</td></tr>
<tr><td><code id="pred.transsmap_+3A_bs.para">bs.para</code></td>
<td>
<p>a list containing the parameters for B-spline construction in function <code>bs</code>. Should be a vector with names &quot;bs.df&quot; and &quot;bs.degree&quot;, each component of which is a vector with the same length as the number of nonparametric variables. For example, bs.para = list(bs.df=c(3,3,3), bs.degree=c(3,3,3)).
</p>

<ul>
<li><p> &quot;bs.df&quot;: degrees of freedom for each nonparametric component; The details can be referred to the arguments in function <code>bs</code>.
</p>
</li>
<li><p> &quot;bs.degree&quot;: degree of the piecewise polynomial for each nonparametric component; The default is 3 for cubic splines.
</p>
</li></ul>
</td></tr>
<tr><td><code id="pred.transsmap_+3A_if.lm">if.lm</code></td>
<td>
<p>the logical variable, whether to set the target model as ordinary linear model. Default is False.</p>
</td></tr>
<tr><td><code id="pred.transsmap_+3A_if.penalty">if.penalty</code></td>
<td>
<p>If TRUE,then LASSO estimation is done under the linear regression settings, and the &quot;newdata&quot; only constains &quot;data.x&quot;. Default is FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a result list containing the predicted values on new data and the estimated coefficient vector.
</p>


<h3>References</h3>

<p>Hu, X., &amp; Zhang, X. (2023). Optimal Parameter-Transfer Learning by Semiparametric Model Averaging. Journal of Machine Learning Research, 24(358), 1-53.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+trans.smap">trans.smap</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## correct target model setting

# generate simulation dataset
coeff0 &lt;- cbind(
  as.matrix(c(1.4, -1.2, 1, -0.8, 0.65, 0.3)),
  as.matrix(c(1.4, -1.2, 1, -0.8, 0.65, 0.3) + 0.02),
  as.matrix(c(1.4, -1.2, 1, -0.8, 0.65, 0.3) + 0.3),
  as.matrix(c(1.4, -1.2, 1, -0.8, 0.65, 0.3))
)
whole.data &lt;- simdata.gen(
  px = 6, num.source = 4, size = c(150, 200, 200, 150), coeff0 = coeff0,
  coeff.mis = as.matrix(c(coeff0[, 2], 1.8)), err.sigma = 0.5, rho = 0.5, size.test = 500,
  sim.set = "homo", tar.spec = "cor", if.heter = FALSE
)
data.train &lt;- whole.data$data.train
data.test &lt;- whole.data$data.test

# running Trans-SMAP and obtain the optimal weight vector
data.train$data.x[[2]] &lt;- data.train$data.x[[2]][, -7]
fit.transsmap &lt;- trans.smap(
  train.data = data.train, nfold = 5,
  bs.para = list(bs.df = rep(3, 3), bs.degree = rep(3, 3))
)
ma.weights &lt;- fit.transsmap$weight.est

# predict for new data
pred.res &lt;- pred.transsmap(
  object = fit.transsmap, newdata = data.test,
  bs.para = list(bs.df = rep(3, 3), bs.degree = rep(3, 3))
)
pred.val &lt;- pred.res$predict.val
predict.risk &lt;- sum((pred.val - data.test$data.x %*% data.test$beta.true - data.test$gz.te)^2) / 500


## misspecified target model setting

# generate simulation dataset
coeff.mis &lt;- matrix(c(c(coeff0[, 1], 0.1), c(coeff0[, 2], 1.8)), ncol = 2)
whole.data &lt;- simdata.gen(
  px = 6, num.source = 4, size = c(150, 200, 200, 150), coeff0 = coeff0,
  coeff.mis = coeff.mis, err.sigma = 0.5, rho = 0.5, size.test = 500,
  sim.set = "homo", tar.spec = "mis", if.heter = FALSE
)
data.train &lt;- whole.data$data.train
data.test &lt;- whole.data$data.test

# running Trans-SMAP and obtain the optimal weight vector
data.train$data.x[[1]] &lt;- data.train$data.x[[1]][, -7]
data.train$data.x[[2]] &lt;- data.train$data.x[[2]][, -7]
fit.transsmap &lt;- trans.smap(
  train.data = data.train, nfold = 5,
  bs.para = list(bs.df = rep(3, 3), bs.degree = rep(3, 3))
)
ma.weights &lt;- fit.transsmap$weight.est

# predict for new data
data.test.mis &lt;- data.test
data.test.mis$data.x &lt;- data.test.mis$data.x[, -7]
pred.res &lt;- pred.transsmap(
  object = fit.transsmap, newdata = data.test.mis,
  bs.para = list(bs.df = rep(3, 3), bs.degree = rep(3, 3))
)
pred.val &lt;- pred.res$predict.val
predict.risk &lt;- sum((pred.val - data.test$data.x %*% data.test$beta.true - data.test$gz.te)^2) / 500

</code></pre>

<hr>
<h2 id='simdata.gen'>Generate multi-source data from partially linear models.</h2><span id='topic+simdata.gen'></span>

<h3>Description</h3>

<p>Generate simulation datasets containing training data and testing data from partially linear models under various settings.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simdata.gen(
  px,
  num.source = 4,
  size,
  coeff0,
  coeff.mis,
  err.sigma,
  rho,
  size.test,
  sim.set = c("heter", "homo"),
  tar.spec = c("cor", "mis"),
  if.heter = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="simdata.gen_+3A_px">px</code></td>
<td>
<p>the dimension of the shared parametric component for all models. Should be an integer smaller than sample size.</p>
</td></tr>
<tr><td><code id="simdata.gen_+3A_num.source">num.source</code></td>
<td>
<p>the number of datasets. Should be the value 4 or 7.</p>
</td></tr>
<tr><td><code id="simdata.gen_+3A_size">size</code></td>
<td>
<p>the sample size of different datasets. Should be a vector of <code>num.source</code>.</p>
</td></tr>
<tr><td><code id="simdata.gen_+3A_coeff0">coeff0</code></td>
<td>
<p>a px * num.source matrix of the shared coefficient vector for all models.</p>
</td></tr>
<tr><td><code id="simdata.gen_+3A_coeff.mis">coeff.mis</code></td>
<td>
<p>the shared coefficient vector for the misspecified model. If tar.spec = 'cor', it should be a parameter vector of length px + 1 for the second misspecified source model. If tar.spec = 'mis', it should be a (px+1) * 2 matrix, in which the first column is the parameter vector for the misspecified target model and the second column is for the second misspecified source model. The last component of predictors for the misspecified model will be omitted in the estimation.</p>
</td></tr>
<tr><td><code id="simdata.gen_+3A_err.sigma">err.sigma</code></td>
<td>
<p>the standard deviations of the normal random errors in regression models.</p>
</td></tr>
<tr><td><code id="simdata.gen_+3A_rho">rho</code></td>
<td>
<p>the correlation coefficient in the multivariate normal distribution of the parametric variables.</p>
</td></tr>
<tr><td><code id="simdata.gen_+3A_size.test">size.test</code></td>
<td>
<p>the sample size of the testing target data.</p>
</td></tr>
<tr><td><code id="simdata.gen_+3A_sim.set">sim.set</code></td>
<td>
<p>the type of the nonparametric settings. Can be &quot;heter&quot; or &quot;homo&quot;, which represents the heterogeneous and homogeneous dimension settings, respectively.</p>
</td></tr>
<tr><td><code id="simdata.gen_+3A_tar.spec">tar.spec</code></td>
<td>
<p>the type of the target model specification. Can be &quot;cor&quot; or &quot;mis&quot;, which represents the corrected and misspecified target model, respectively.</p>
</td></tr>
<tr><td><code id="simdata.gen_+3A_if.heter">if.heter</code></td>
<td>
<p>the logical variable, whether to allow a heteroscedastic setup. Default is False.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of the training data and testing data, including the response, parametric predictors, nonparametric predictors, nonparametric values, coefficient vector.
</p>


<h3>References</h3>

<p>Hu, X., &amp; Zhang, X. (2023). Optimal Parameter-Transfer Learning by Semiparametric Model Averaging. Journal of Machine Learning Research, 24(358), 1-53.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>coeff0 &lt;- cbind(
  as.matrix(c(1.4, -1.2, 1, -0.8, 0.65, 0.3)),
  as.matrix(c(1.4, -1.2, 1, -0.8, 0.65, 0.3) + 0.02),
  as.matrix(c(1.4, -1.2, 1, -0.8, 0.65, 0.3) + 0.3),
  as.matrix(c(1.4, -1.2, 1, -0.8, 0.65, 0.3))
)
# correct target model setting
whole.data &lt;- simdata.gen(
  px = 6, num.source = 4, size = c(150, 200, 200, 150), coeff0 = coeff0,
  coeff.mis = as.matrix(c(coeff0[, 2], 1.8)), err.sigma = 0.5, rho = 0.5, size.test = 500,
  sim.set = "homo", tar.spec = "cor", if.heter = FALSE
)

# misspecified target model setting
coeff.mis &lt;- matrix(c(c(coeff0[, 1], 0.1), c(coeff0[, 2], 1.8)), ncol = 2)
whole.data &lt;- simdata.gen(
  px = 6, num.source = 4, size = c(150, 200, 200, 150), coeff0 = coeff0,
  coeff.mis = coeff.mis, err.sigma = 0.5, rho = 0.5, size.test = 500,
  sim.set = "homo", tar.spec = "mis", if.heter = FALSE
)
</code></pre>

<hr>
<h2 id='trans.smap'>Parameter-transfer learning for partially linear models based on semiparametric model averaging.</h2><span id='topic+trans.smap'></span>

<h3>Description</h3>

<p>Obtain optimal weights and estimated coefficients based on Trans-SMAP.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>trans.smap(
  train.data,
  nfold = NULL,
  bs.para,
  lm.set = NULL,
  if.penalty = FALSE,
  pen.para
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="trans.smap_+3A_train.data">train.data</code></td>
<td>
<p>a list containing the observations of predictors and response for fitting models. Should be a list with elements &quot;data.y&quot;, &quot;data.x&quot; and &quot;data.z&quot;, where &quot;data.y&quot; indicates a response list for all data sources, &quot;data.x&quot; indicates a parametric predictor list for all data sources, and &quot;data.z&quot; indicates a nonparametric predictor list for all data sources. Each element in &quot;data.x&quot; and &quot;data.z&quot; is a matrix with each row as an observation and each column as a variable. By default, the first element in &quot;data.y&quot;, &quot;data.x&quot; and &quot;data.z&quot; is target data, and others are source data.</p>
</td></tr>
<tr><td><code id="trans.smap_+3A_nfold">nfold</code></td>
<td>
<p>the number of folds for the cross-validation weight criterion. Default is NULL (leave-one-out).</p>
</td></tr>
<tr><td><code id="trans.smap_+3A_bs.para">bs.para</code></td>
<td>
<p>a list containing the parameters for B-spline construction in function <code>bs</code>. Should be a list with elements &quot;bs.df&quot; and &quot;bs.degree&quot;, each component of which is a vector with the same length as the number of nonparametric variables. For example, bs.para = list(bs.df=c(3,3,3), bs.degree=c(3,3,3)).
</p>

<ul>
<li><p> &quot;bs.df&quot;: degrees of freedom for each nonparametric component; The details can be referred to the arguments in function <code>bs</code>.
</p>
</li>
<li><p> &quot;bs.degree&quot;: degree of the piecewise polynomial for each nonparametric component; The default is 3 for cubic splines.
</p>
</li></ul>
</td></tr>
<tr><td><code id="trans.smap_+3A_lm.set">lm.set</code></td>
<td>
<p>the vector of indices for the linear regression models, which means the corresponding models are constructed by ordinary linear models instead of partially linear models. Default is NULL.</p>
</td></tr>
<tr><td><code id="trans.smap_+3A_if.penalty">if.penalty</code></td>
<td>
<p>If TRUE,then LASSO estimation is done under the linear regression settings, and the input data in &quot;train.data&quot; only constains &quot;data.y&quot; and &quot;data.x&quot;. Default is FALSE.</p>
</td></tr>
<tr><td><code id="trans.smap_+3A_pen.para">pen.para</code></td>
<td>
<p>a list containing the main parameters for k-fold cross-validation for <code>glmnet</code>. Should be a list with elements &quot;pen.nfold&quot; and &quot;pen.lambda&quot;.
</p>

<ul>
<li><p> &quot;pen.nfold&quot;: the number of folds for the cross-validation criterion to determine the tuning parameters. Default is 8.
</p>
</li>
<li><p> &quot;pen.lambda&quot;: Optional user-supplied lambda sequence; Default is NULL. The details can be referred to the arguments in function <code>cv.glmnet</code>.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>a result list containing the estimated weight vector, the execution time of solving the optimal weights and the summarized results of fitting models.
</p>


<h3>References</h3>

<p>Hu, X., &amp; Zhang, X. (2023). Optimal Parameter-Transfer Learning by Semiparametric Model Averaging. Journal of Machine Learning Research, 24(358), 1-53.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## correct target model setting

# generate simulation dataset
coeff0 &lt;- cbind(
  as.matrix(c(1.4, -1.2, 1, -0.8, 0.65, 0.3)),
  as.matrix(c(1.4, -1.2, 1, -0.8, 0.65, 0.3) + 0.02),
  as.matrix(c(1.4, -1.2, 1, -0.8, 0.65, 0.3) + 0.3),
  as.matrix(c(1.4, -1.2, 1, -0.8, 0.65, 0.3))
)
whole.data &lt;- simdata.gen(
  px = 6, num.source = 4, size = c(150, 200, 200, 150), coeff0 = coeff0,
  coeff.mis = as.matrix(c(coeff0[, 2], 1.8)), err.sigma = 0.5, rho = 0.5, size.test = 500,
  sim.set = "homo", tar.spec = "cor", if.heter = FALSE
)
data.train &lt;- whole.data$data.train
data.test &lt;- whole.data$data.test

# running Trans-SMAP and obtain the optimal weight vector
data.train$data.x[[2]] &lt;- data.train$data.x[[2]][, -7]
fit.transsmap &lt;- trans.smap(
  train.data = data.train, nfold = 5,
  bs.para = list(bs.df = rep(3, 3), bs.degree = rep(3, 3))
)
ma.weights &lt;- fit.transsmap$weight.est


## misspecified target model setting

# generate simulation dataset
coeff.mis &lt;- matrix(c(c(coeff0[, 1], 0.1), c(coeff0[, 2], 1.8)), ncol = 2)
whole.data &lt;- simdata.gen(
  px = 6, num.source = 4, size = c(150, 200, 200, 150), coeff0 = coeff0,
  coeff.mis = coeff.mis, err.sigma = 0.5, rho = 0.5, size.test = 500,
  sim.set = "homo", tar.spec = "mis", if.heter = FALSE
)
data.train &lt;- whole.data$data.train
data.test &lt;- whole.data$data.test

# running Trans-SMAP and obtain the optimal weight vector
data.train$data.x[[1]] &lt;- data.train$data.x[[1]][, -7]
data.train$data.x[[2]] &lt;- data.train$data.x[[2]][, -7]
fit.transsmap &lt;- trans.smap(
  train.data = data.train, nfold = 5,
  bs.para = list(bs.df = rep(3, 3), bs.degree = rep(3, 3))
)
ma.weights &lt;- fit.transsmap$weight.est

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
