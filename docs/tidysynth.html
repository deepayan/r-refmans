<!DOCTYPE html><html><head><title>Help for package tidysynth</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {tidysynth}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#%&gt;%'><p>Pipe operator</p></a></li>
<li><a href='#generate_control'><p>generate_control</p></a></li>
<li><a href='#generate_predictor'><p>generate_predictor</p></a></li>
<li><a href='#generate_weights'><p>generate_weights</p></a></li>
<li><a href='#grab_balance_table'><p>grab_balance_table</p></a></li>
<li><a href='#grab_loss'><p>grab_loss</p></a></li>
<li><a href='#grab_outcome'><p>grab_outcome</p></a></li>
<li><a href='#grab_predictor_weights'><p>grab_predictor_weights</p></a></li>
<li><a href='#grab_predictors'><p>grab_predictors</p></a></li>
<li><a href='#grab_significance'><p>grab_significance</p></a></li>
<li><a href='#grab_synthetic_control'><p>grab_synthetic_control</p></a></li>
<li><a href='#grab_unit_weights'><p>grab_unit_weights</p></a></li>
<li><a href='#plot_differences'><p>plot_difference</p></a></li>
<li><a href='#plot_mspe_ratio'><p>plot_mspe_ratio</p></a></li>
<li><a href='#plot_placebos'><p>plot_placebos</p></a></li>
<li><a href='#plot_trends'><p>plot_trends</p></a></li>
<li><a href='#plot_weights'><p>plot_weights</p></a></li>
<li><a href='#smoking'><p>smoking dataset</p></a></li>
<li><a href='#synth_method'><p>synth_method</p></a></li>
<li><a href='#synth_weights'><p>synth_weights</p></a></li>
<li><a href='#synthetic_control'><p>synthetic_control</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>A Tidy Implementation of the Synthetic Control Method</td>
</tr>
<tr>
<td>Version:</td>
<td>0.2.0</td>
</tr>
<tr>
<td>Description:</td>
<td>A synthetic control offers a way of evaluating the effect of an intervention in comparative case studies. The package makes a number of improvements when implementing the method in R. These improvements allow users to inspect, visualize, and tune the synthetic control more easily. A key benefit of a tidy implementation is that the entire preparation process for building the synthetic control can be accomplished in a single pipe.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>magrittr, tibble, dplyr, ggplot2, tidyr, forcats, rlang,
kernlab, rgenoud, optimx, stats</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-05-20 18:10:37 UTC; ed769</td>
</tr>
<tr>
<td>Author:</td>
<td>Eric Dunford <a href="https://orcid.org/0000-0003-3056-8687"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Eric Dunford &lt;ed769@georgetown.edu&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-05-21 07:10:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='+25+26gt+3B+25'>Pipe operator</h2><span id='topic++25+3E+25'></span>

<h3>Description</h3>

<p>See <code>magrittr::<a href="magrittr.html#topic+pipe">%&gt;%</a></code> for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lhs %&gt;% rhs
</code></pre>


<h3>Value</h3>

<p>passes data object to the subsequent function.
</p>

<hr>
<h2 id='generate_control'>generate_control</h2><span id='topic+generate_control'></span>

<h3>Description</h3>

<p>Uses the weights generated from <code>generate_weights()</code> to weight control units
from the donor pool to denerate a synthetic version of the treated unit time
series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate_control(data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generate_control_+3A_data">data</code></td>
<td>
<p>nested data of type <code>tbl_df</code> generated from <code>sythetic_control()</code>.
See <code>synthetic_control()</code> documentation for more information. In addition,
<code>.unit_weights</code> must be generate using <code>generate_weights()</code>. See
documentation for more information on how to generate weights.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>tbl_df</code> with nested fields containing the following:
</p>

<ul>
<li> <p><code>.id</code>: unit id for the intervention case (this will differ when a placebo
unit).
</p>
</li>
<li> <p><code>.placebo</code>: indicator field taking on the value of 1 if a unit is a
placebo unit, 0 if it's the specified treated unit.
</p>
</li>
<li> <p><code>.type</code>: type of the nested data construct: <code>treated</code> or <code>controls</code>.
Keeps tract of which data construct is located in <code>.outcome</code> field.
</p>
</li>
<li> <p><code>.outcome</code>: nested data construct containing the outcome variable
configured for the sythnetic control method. Data is configured into a wide
format for the optimization task.
</p>
</li>
<li> <p><code>.predictors</code>: nested data construct containing the covariate matrices
for the treated and control (donor) units. Data is configured into a wide
format for the optimization task.
</p>
</li>
<li> <p><code>.synthetic_control</code>: nested data construct containing the synthetic
control version of the outcome variable generated from the unit weights.
</p>
</li>
<li> <p><code>.unit_weights</code>: Nested column of unit weights (i.e. how each unit from
the donor pool contributes to the synthetic control). Weights should sum to
</p>
</li></ul>


<ol>
<li> 
</li></ol>


<ul>
<li> <p><code>.predictor_weights</code>: Nested column of predictor variable weights (i.e.
the significance of each predictor in optimizing the weights that generate
the synthetic control). Weights should sum to 1. If variable weights are
provided, those variable weights are provided.
</p>
</li>
<li> <p><code>.original_data</code>: original impute data filtered by treated or control
units. This allows for easy processing down stream when generating
predictors.
</p>
</li>
<li> <p><code>.meta</code>: stores information regarding the unit and time index, the
treated unit and time and the name of the outcome variable. Used downstream
in subsequent functions.
</p>
</li>
<li> <p><code>.loss</code>: the RMPE loss for both sets of weights.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>


# Smoking example data
data(smoking)

smoking_out &lt;-
smoking %&gt;%

# initial the synthetic control object
synthetic_control(outcome = cigsale,
                  unit = state,
                  time = year,
                  i_unit = "California",
                  i_time = 1988,
                  generate_placebos= FALSE) %&gt;%

# Generate the aggregate predictors used to generate the weights
  generate_predictor(time_window=1980:1988,
                     lnincome = mean(lnincome, na.rm = TRUE),
                     retprice = mean(retprice, na.rm = TRUE),
                     age15to24 = mean(age15to24, na.rm = TRUE)) %&gt;%

  generate_predictor(time_window=1984:1988,
                     beer = mean(beer, na.rm = TRUE)) %&gt;%

  generate_predictor(time_window=1975,
                     cigsale_1975 = cigsale) %&gt;%

  generate_predictor(time_window=1980,
                     cigsale_1980 = cigsale) %&gt;%

  generate_predictor(time_window=1988,
                     cigsale_1988 = cigsale) %&gt;%


  # Generate the fitted weights for the synthetic control
  generate_weights(optimization_window =1970:1988,
                   Margin.ipop=.02,Sigf.ipop=7,Bound.ipop=6) %&gt;%

  # Generate the synthetic control
  generate_control()

# Plot the observed and synthetic trend
smoking_out %&gt;% plot_trends(time_window = 1970:2000)



</code></pre>

<hr>
<h2 id='generate_predictor'>generate_predictor</h2><span id='topic+generate_predictor'></span>

<h3>Description</h3>

<p>Create one or more scalar variables summarizing covariate data across a
specified time window. These predictor variables are used to fit the
synthetic control.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate_predictor(data, time_window = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generate_predictor_+3A_data">data</code></td>
<td>
<p>nested data of type <code>tbl_df</code> generated from
<code>synthetic_control()</code>. See <code>synthetic_control()</code> documentation for more
information.</p>
</td></tr>
<tr><td><code id="generate_predictor_+3A_time_window">time_window</code></td>
<td>
<p>set time window from the pre-intervention period that the
data should be aggregated across to generate the specific predictor.
Default is to use the entire pre-intervention period.</p>
</td></tr>
<tr><td><code id="generate_predictor_+3A_...">...</code></td>
<td>
<p>Name-value pairs of summary functions. The name will be the name
of the variable in the result. The value should be an expression that
returns a single value like min(x), n(), or sum(is.na(y)). Note that for
all summary functions <code>na.rm = TRUE</code> argument should be specified as
aggregating across units with missing values is a common occurrence.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>matrices of aggregate-level covariates to be used in the following
minimization task.
</p>
<p style="text-align: center;"><code class="reqn">W^*(V) =  min \sum^M_{m=1} v_m (X_{1m} - \sum^{J+1}_{j=2}w_j X_{jm})^2</code>
</p>

<p>The importance of the generate predictors are determine by vector <code class="reqn">V</code>,
and the weights that determine unit-level importance are determined by vector
<code class="reqn">W</code>. The nested optimation task seeks to find optimal values of <code class="reqn">V</code>
and <code class="reqn">W</code>. Note also that <code class="reqn">V</code> can be provided by the user. See
<code>?generate_weights()</code>.
</p>


<h3>Value</h3>

<p><code>tbl_df</code> with nested fields containing the following:
</p>

<ul>
<li> <p><code>.id</code>: unit id for the intervention case (this will differ when a placebo
unit).
</p>
</li>
<li> <p><code>.placebo</code>: indicator field taking on the value of 1 if a unit is a
placebo unit, 0 if it's the specified treated unit.
</p>
</li>
<li> <p><code>.type</code>: type of the nested data construct: <code>treated</code> or <code>controls</code>.
Keeps tract of which data construct is located in <code>.outcome</code> field.
</p>
</li>
<li> <p><code>.outcome</code>: nested data construct containing the outcome variable
configured for the sythnetic control method. Data is configured into a wide
format for the optimization task.
</p>
</li>
<li> <p><code>.predictors</code>: nested data construct containing the covariate matrices
for the treated and control (donor) units. Data is configured into a wide
format for the optimization task.
</p>
</li>
<li> <p><code>.original_data</code>: original impute data filtered by treated or control
units. This allows for easy processing down stream when generating
predictors.
</p>
</li>
<li> <p><code>.meta</code>: stores information regarding the unit and time index, the
treated unit and time and the name of the outcome variable. Used downstream
in subsequent functions.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>


# Smoking example data
data(smoking)

smoking_out &lt;-
smoking %&gt;%

# initial the synthetic control object
synthetic_control(outcome = cigsale,
                  unit = state,
                  time = year,
                  i_unit = "California",
                  i_time = 1988,
                  generate_placebos= FALSE) %&gt;%

# Generate the aggregate predictors used to generate the weights
  generate_predictor(time_window=1980:1988,
                     lnincome = mean(lnincome, na.rm = TRUE),
                     retprice = mean(retprice, na.rm = TRUE),
                     age15to24 = mean(age15to24, na.rm = TRUE))

# Extract respective predictor matrices
smoking_out %&gt;% grab_predictors(type = "treated")
smoking_out %&gt;% grab_predictors(type = "controls")



</code></pre>

<hr>
<h2 id='generate_weights'>generate_weights</h2><span id='topic+generate_weights'></span>

<h3>Description</h3>

<p>Generates weights from the the aggregate-level predictors to generate the
synthetic control. These weights determine which variable and which unit from
the donor pool is important in generating the synthetic control.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate_weights(
  data,
  optimization_window = NULL,
  custom_variable_weights = NULL,
  include_fit = FALSE,
  optimization_method = c("Nelder-Mead", "BFGS"),
  genoud = FALSE,
  quadopt = "ipop",
  margin_ipop = 5e-04,
  sigf_ipop = 5,
  bound_ipop = 10,
  verbose = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generate_weights_+3A_data">data</code></td>
<td>
<p>nested data of type <code>tbl_df</code> generated from <code>sythetic_control()</code>.
See <code>synthetic_control()</code> documentation for more information. In addition,
a matrix of predictors must be prespecified using the
<code>generate_predictor()</code> function. See documentation for more information on
how to generate a predictor function.</p>
</td></tr>
<tr><td><code id="generate_weights_+3A_optimization_window">optimization_window</code></td>
<td>
<p>the temporal window of the pre-intervention
outcome time series to be used in the optimization task. Default behavior
uses the entire pre-intervention time period.</p>
</td></tr>
<tr><td><code id="generate_weights_+3A_custom_variable_weights">custom_variable_weights</code></td>
<td>
<p>a vector of provided weights that define a
variable's importance in the optimization task. The weights are intended to
reflect the users prior regarding the relative significance of each
variable. Vector must sum to one. Note that the method is significantly
faster when a custom variable weights are provided. Default behavior
assumes no wieghts are provided and thus must be learned from the data.</p>
</td></tr>
<tr><td><code id="generate_weights_+3A_include_fit">include_fit</code></td>
<td>
<p>Boolean flag, if TRUE, then the optimization output is
included in the outputted <code>tbl_df</code>.</p>
</td></tr>
<tr><td><code id="generate_weights_+3A_optimization_method">optimization_method</code></td>
<td>
<p>string vector that specifies the optimization
algorithms to be used. Permissable values are all optimization algorithms
that are currently implemented in the optimx function (see this function
for details). This list currently includes c('Nelder-Mead', 'BFGS', 'CG',
'L-BFGS-B', 'nlm', 'nlminb', 'spg', and 'ucminf&quot;). If multiple algorithms
are specified, synth will run the optimization with all chosen algorithms
and then return the result for the best performing method. Default is
c('Nelder-Mead','BFGS'). As an additional possibility, the user can also
specify 'All' which means that synth will run the results over all
algorithms in optimx.</p>
</td></tr>
<tr><td><code id="generate_weights_+3A_genoud">genoud</code></td>
<td>
<p>Logical flag. If true, synth embarks on a two step
optimization. In the first step, genoud, an optimization function that
combines evolutionary algorithm methods with a derivative-based
(quasi-Newton) method to solve difficult optimization problems, is used to
obtain a solution. See genoud for details. In the second step, the genoud
results are passed to the optimization algorithm(s) chosen in optimxmethod
for a local optimization within the neighborhood of the genoud solution.
This two step optimization procedure will require much more computing time,
but may yield lower loss in cases where the search space is highly
irregular.</p>
</td></tr>
<tr><td><code id="generate_weights_+3A_quadopt">quadopt</code></td>
<td>
<p>string vector that specifies the routine for quadratic
optimization over w weights. possible values are &quot;ipop&quot; and &quot;LowRankQP&quot;
(see ipop and LowRankQP for details). default is 'ipop'</p>
</td></tr>
<tr><td><code id="generate_weights_+3A_margin_ipop">margin_ipop</code></td>
<td>
<p>setting for ipop optimization routine: how close we get to
the constrains (see ipop for details)</p>
</td></tr>
<tr><td><code id="generate_weights_+3A_sigf_ipop">sigf_ipop</code></td>
<td>
<p>setting for ipop optimization routine: Precision (default: 7
significant figures (see ipop for details)</p>
</td></tr>
<tr><td><code id="generate_weights_+3A_bound_ipop">bound_ipop</code></td>
<td>
<p>setting for ipop optimization routine: Clipping bound for
the variables (see ipop for details)</p>
</td></tr>
<tr><td><code id="generate_weights_+3A_verbose">verbose</code></td>
<td>
<p>Logical flag. If TRUE then intermediate results will be shown.</p>
</td></tr>
<tr><td><code id="generate_weights_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to optimx and or genoud to
adjust optimization.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><strong>Optimization</strong>
</p>
<p>The method completes the following nested minimization task:
</p>
<p style="text-align: center;"><code class="reqn">W^*(V) =  min \sum^M_{m=1} v_m (X_{1m} - \sum^{J+1}_{j=2}w_j X_{jm})^2</code>
</p>

<p>Where <code class="reqn">X_1</code> and <code class="reqn">X_0</code>, which are matrices of aggregate-level
covariates, are generated using the <code>generate_predictor()</code> function. <code class="reqn">V</code>
denotes the variable weights with <code class="reqn">M</code> reflecting the total number of
predictor variables. Thus, the optimal weights are a function of <code class="reqn">V</code>.
</p>
<p>The weights themselves are optimized via the following:
</p>
<p style="text-align: center;"><code class="reqn">\sum^{T_0}_{t=1}(Y_{1t} - \sum^{J=1}_{j=2}w^*_j(V)Y_{jt})^2</code>
</p>

<p>where <code class="reqn">T_0</code> denotes the pre-intervention period (or a specific
optimization window supplied by the argument <code>time_window</code>); <code class="reqn">J</code> denotes
the number of control units from the donor pool, where <code class="reqn">j=1</code> reflects the
treated unit.
</p>
<p>Thus, the weights are selected in a manner that produces a synthetic
<code class="reqn">\hat{Y}</code> that approximates the observed <code class="reqn">Y</code> as closely as possible.
</p>
<p><strong>Variable Weights</strong>
</p>
<p>As proposed in Abadie and Gardeazabal (2003) and Abadie, Diamond, Hainmueller
(2010), the synth function routinely searches for the set of weights that
generate the best fitting convex combination of the control units. In other
words, the predictor weight matrix V (<code>custom_variable_weights</code>) is chosen
among all positive definite diagonal matrices such that MSPE is minimized for
the pre-intervention period. Instead of using this data-driven procedures to
search for the best fitting synthetic control group, the user may supply
their own weights using the <code>custom_variable_weights</code> argument. These weights
reflect the user's subjective assessment of the predictive power of the
variables generated by <code>generate_predictor()</code>.
</p>
<p>When generating weights for the placebo cases, the variable weights used for
the fit of the treated unit optimization. This ensures comparability between
the placebo and treated fits. In addition, it greatly decreases processing
time as the variable weights do not be learned for every placebo entry.
</p>


<h3>Value</h3>

<p><code>tbl_df</code> with nested fields containing the following:
</p>

<ul>
<li> <p><code>.id</code>: unit id for the intervention case (this will differ when a placebo
unit).
</p>
</li>
<li> <p><code>.placebo</code>: indicator field taking on the value of 1 if a unit is a
placebo unit, 0 if it's the specified treated unit.
</p>
</li>
<li> <p><code>.type</code>: type of the nested data construct: <code>treated</code> or <code>controls</code>.
Keeps tract of which data construct is located in <code>.outcome</code> field.
</p>
</li>
<li> <p><code>.outcome</code>: nested data construct containing the outcome variable
configured for the sythnetic control method. Data is configured into a wide
format for the optimization task.
</p>
</li>
<li> <p><code>.predictors</code>: nested data construct containing the covariate matrices
for the treated and control (donor) units. Data is configured into a wide
format for the optimization task.
</p>
</li>
<li> <p><code>.unit_weights</code>: Nested column of unit weights (i.e. how each unit from
the donor pool contributes to the synthetic control). Weights should sum to
</p>
</li></ul>


<ol>
<li> 
</li></ol>


<ul>
<li> <p><code>.predictor_weights</code>: Nested column of predictor variable weights (i.e.
the significance of each predictor in optimizing the weights that generate
the synthetic control). Weights should sum to 1. If variable weights are
provided, those variable weights are provided.
</p>
</li>
<li> <p><code>.original_data</code>: original impute data filtered by treated or control
units. This allows for easy processing down stream when generating
predictors.
</p>
</li>
<li> <p><code>.meta</code>: stores information regarding the unit and time index, the
treated unit and time and the name of the outcome variable. Used downstream
in subsequent functions.
</p>
</li>
<li> <p><code>.loss</code>: the RMPE loss for both sets of weights.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>


# Smoking example data
data(smoking)

smoking_out &lt;-
smoking %&gt;%

# initial the synthetic control object
synthetic_control(outcome = cigsale,
                  unit = state,
                  time = year,
                  i_unit = "California",
                  i_time = 1988,
                  generate_placebos= TRUE) %&gt;%

# Generate the aggregate predictors used to generate the weights
  generate_predictor(time_window=1980:1988,
                     lnincome = mean(lnincome, na.rm = TRUE),
                     retprice = mean(retprice, na.rm = TRUE),
                     age15to24 = mean(age15to24, na.rm = TRUE)) %&gt;%

  generate_predictor(time_window=1984:1988,
                     beer = mean(beer, na.rm = TRUE)) %&gt;%

  generate_predictor(time_window=1975,
                     cigsale_1975 = cigsale) %&gt;%

  generate_predictor(time_window=1980,
                     cigsale_1980 = cigsale) %&gt;%

  generate_predictor(time_window=1988,
                     cigsale_1988 = cigsale) %&gt;%


  # Generate the fitted weights for the synthetic control
  generate_weights(optimization_window =1970:1988,
                   Margin.ipop=.02,Sigf.ipop=7,Bound.ipop=6)

# Retrieve weights
smoking_out %&gt;% grab_predictor_weights()
smoking_out %&gt;% grab_unit_weights()

# Retrieve the placebo weights as well.
smoking_out %&gt;% grab_predictor_weights(placebo= TRUE)
smoking_out %&gt;% grab_unit_weights(placebo= TRUE)

# Plot the unit weights
smoking_out %&gt;% plot_weights()



</code></pre>

<hr>
<h2 id='grab_balance_table'>grab_balance_table</h2><span id='topic+grab_balance_table'></span>

<h3>Description</h3>

<p>Compare the distributions of the aggregate-level predictors for the observed
intervention unit, the synthetic control, and the donor pool average. Table
helps user compare the the level of balance produced by the synthetic
control.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grab_balance_table(data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="grab_balance_table_+3A_data">data</code></td>
<td>
<p>nested data of type <code>tbl_df</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>tibble data frame containing balance statistics between the
observed/synthetic unit and the donor pool for each variable used to fit
the synthetic control.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

data(smoking)
smoking_out &lt;-
smoking %&gt;%
synthetic_control(outcome = cigsale,
                  unit = state,
                  time = year,
                  i_unit = "California",
                  i_time = 1988,
                  generate_placebos=FALSE) %&gt;%
  generate_predictor(time_window=1980:1988,
                     lnincome = mean(lnincome, na.rm = TRUE),
                     retprice = mean(retprice, na.rm = TRUE),
                     age15to24 = mean(age15to24, na.rm = TRUE)) %&gt;%
  generate_predictor(time_window=1984:1988,
                     beer = mean(beer, na.rm = TRUE)) %&gt;%
  generate_predictor(time_window=1975,
                     cigsale_1975 = cigsale) %&gt;%
  generate_predictor(time_window=1980,
                     cigsale_1980 = cigsale) %&gt;%
  generate_predictor(time_window=1988,
                     cigsale_1988 = cigsale) %&gt;%
  generate_weights(optimization_window =1970:1988,
                   Margin.ipop=.02,Sigf.ipop=7,Bound.ipop=6) %&gt;%
  generate_control()

smoking_out %&gt;% grab_balance_table()



</code></pre>

<hr>
<h2 id='grab_loss'>grab_loss</h2><span id='topic+grab_loss'></span>

<h3>Description</h3>

<p>Extract the RMSE loss of the optimized weights from the synth pipeline.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grab_loss(data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="grab_loss_+3A_data">data</code></td>
<td>
<p>nested data of type <code>tbl_df</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>tibble data frame
</p>


<h3>Examples</h3>

<pre><code class='language-R'>


# Smoking example data
data(smoking)

smoking_out &lt;-
smoking %&gt;%

# initial the synthetic control object
synthetic_control(outcome = cigsale,
                  unit = state,
                  time = year,
                  i_unit = "California",
                  i_time = 1988,
                  generate_placebos=TRUE) %&gt;%

# Generate the aggregate predictors used to generate the weights
  generate_predictor(time_window=1980:1988,
                     lnincome = mean(lnincome, na.rm = TRUE),
                     retprice = mean(retprice, na.rm = TRUE),
                     age15to24 = mean(age15to24, na.rm = TRUE)) %&gt;%

  generate_predictor(time_window=1984:1988,
                     beer = mean(beer, na.rm = TRUE)) %&gt;%

  generate_predictor(time_window=1975,
                     cigsale_1975 = cigsale) %&gt;%

  generate_predictor(time_window=1980,
                     cigsale_1980 = cigsale) %&gt;%

  generate_predictor(time_window=1988,
                     cigsale_1988 = cigsale) %&gt;%


  # Generate the fitted weights for the synthetic control
  generate_weights(optimization_window =1970:1988,
                   Margin.ipop=.02,Sigf.ipop=7,Bound.ipop=6) %&gt;%

  # Generate the synthetic control
  generate_control()

# grab the MSPE loss from the optimization of the weights.
smoking_out %&gt;% grab_loss()



</code></pre>

<hr>
<h2 id='grab_outcome'>grab_outcome</h2><span id='topic+grab_outcome'></span>

<h3>Description</h3>

<p>Extract a data frame containing the outcome variable from the synth pipline.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grab_outcome(data, type = "treated", placebo = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="grab_outcome_+3A_data">data</code></td>
<td>
<p>nested data of type <code>tbl_df</code></p>
</td></tr>
<tr><td><code id="grab_outcome_+3A_type">type</code></td>
<td>
<p>string specifying which version of the data to extract: &quot;treated&quot;
or &quot;control&quot;. Default is &quot;treated&quot;.</p>
</td></tr>
<tr><td><code id="grab_outcome_+3A_placebo">placebo</code></td>
<td>
<p>boolean flag; if TRUE placebo values are returned as well (if
available). Default is FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>tibble data frame
</p>


<h3>Examples</h3>

<pre><code class='language-R'>


# Smoking example data
data(smoking)

smoking_out &lt;-
smoking %&gt;%

# initial the synthetic control object
synthetic_control(outcome = cigsale,
                  unit = state,
                  time = year,
                  i_unit = "California",
                  i_time = 1988,
                  generate_placebos=FALSE) %&gt;%

# Generate the aggregate predictors used to generate the weights
  generate_predictor(time_window=1980:1988,
                     lnincome = mean(lnincome, na.rm = TRUE),
                     retprice = mean(retprice, na.rm = TRUE),
                     age15to24 = mean(age15to24, na.rm = TRUE)) %&gt;%

  generate_predictor(time_window=1984:1988,
                     beer = mean(beer, na.rm = TRUE)) %&gt;%

  generate_predictor(time_window=1975,
                     cigsale_1975 = cigsale) %&gt;%

  generate_predictor(time_window=1980,
                     cigsale_1980 = cigsale) %&gt;%

  generate_predictor(time_window=1988,
                     cigsale_1988 = cigsale) %&gt;%


  # Generate the fitted weights for the synthetic control
  generate_weights(optimization_window =1970:1988,
                   Margin.ipop=.02,Sigf.ipop=7,Bound.ipop=6) %&gt;%

  # Generate the synthetic control
  generate_control()

# Grab outcome data frame for the treated unit
smoking_out %&gt;% grab_outcome()

# Grab outcome data frame for control units
smoking_out %&gt;% grab_outcome(type="controls")



</code></pre>

<hr>
<h2 id='grab_predictor_weights'>grab_predictor_weights</h2><span id='topic+grab_predictor_weights'></span>

<h3>Description</h3>

<p>Extract the predictor variable weights generated by <code>generate_weights()</code> from the
synth pipeline.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grab_predictor_weights(data, placebo = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="grab_predictor_weights_+3A_data">data</code></td>
<td>
<p>nested data of type <code>tbl_df</code></p>
</td></tr>
<tr><td><code id="grab_predictor_weights_+3A_placebo">placebo</code></td>
<td>
<p>boolean flag; if TRUE placebo values are returned as well (if
available). Default is FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>tibble data frame
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# Smoking example data
data(smoking)

smoking_out &lt;-
smoking %&gt;%

# initial the synthetic control object
synthetic_control(outcome = cigsale,
                  unit = state,
                  time = year,
                  i_unit = "California",
                  i_time = 1988,
                  generate_placebos=TRUE) %&gt;%

# Generate the aggregate predictors used to generate the weights
  generate_predictor(time_window=1980:1988,
                     lnincome = mean(lnincome, na.rm = TRUE),
                     retprice = mean(retprice, na.rm = TRUE),
                     age15to24 = mean(age15to24, na.rm = TRUE)) %&gt;%

  generate_predictor(time_window=1984:1988,
                     beer = mean(beer, na.rm = TRUE)) %&gt;%

  generate_predictor(time_window=1975,
                     cigsale_1975 = cigsale) %&gt;%

  generate_predictor(time_window=1980,
                     cigsale_1980 = cigsale) %&gt;%

  generate_predictor(time_window=1988,
                     cigsale_1988 = cigsale) %&gt;%


  # Generate the fitted weights for the synthetic control
  generate_weights(optimization_window =1970:1988,
                   Margin.ipop=.02,Sigf.ipop=7,Bound.ipop=6) %&gt;%

  # Generate the synthetic control
  generate_control()

# Grab the predictor weights data frame for the treated unit.
smoking_out %&gt;% grab_predictor_weights()

# Grab the predictor weights data frame for the placebo units as well.
smoking_out %&gt;% grab_predictor_weights(placebo=TRUE)



</code></pre>

<hr>
<h2 id='grab_predictors'>grab_predictors</h2><span id='topic+grab_predictors'></span>

<h3>Description</h3>

<p>Extract the aggregate-level covariates generated by <code>generate_predictor()</code> from
the synth pipeline.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grab_predictors(data, type = "treated", placebo = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="grab_predictors_+3A_data">data</code></td>
<td>
<p>nested data of type <code>tbl_df</code></p>
</td></tr>
<tr><td><code id="grab_predictors_+3A_type">type</code></td>
<td>
<p>string specifying which version of the data to extract: &quot;treated&quot;
or &quot;control&quot;. Default is &quot;treated&quot;.</p>
</td></tr>
<tr><td><code id="grab_predictors_+3A_placebo">placebo</code></td>
<td>
<p>boolean flag; if TRUE placebo values are returned as well (if
available). Default is FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>tibble data frame
</p>


<h3>Examples</h3>

<pre><code class='language-R'>


# Smoking example data
data(smoking)

smoking_out &lt;-
smoking %&gt;%

# initial the synthetic control object
synthetic_control(outcome = cigsale,
                  unit = state,
                  time = year,
                  i_unit = "California",
                  i_time = 1988,
                  generate_placebos=FALSE) %&gt;%

# Generate the aggregate predictors used to generate the weights
  generate_predictor(time_window=1980:1988,
                     lnincome = mean(lnincome, na.rm = TRUE),
                     retprice = mean(retprice, na.rm = TRUE),
                     age15to24 = mean(age15to24, na.rm = TRUE)) %&gt;%

  generate_predictor(time_window=1984:1988,
                     beer = mean(beer, na.rm = TRUE)) %&gt;%

  generate_predictor(time_window=1975,
                     cigsale_1975 = cigsale) %&gt;%

  generate_predictor(time_window=1980,
                     cigsale_1980 = cigsale) %&gt;%

  generate_predictor(time_window=1988,
                     cigsale_1988 = cigsale) %&gt;%


  # Generate the fitted weights for the synthetic control
  generate_weights(optimization_window =1970:1988,
                   Margin.ipop=.02,Sigf.ipop=7,Bound.ipop=6) %&gt;%

  # Generate the synthetic control
  generate_control()

# Grab predictors data frame for the treated unit
smoking_out %&gt;% grab_predictors()

# Grab predictors data frame for control units
smoking_out %&gt;% grab_predictors(type="controls")



</code></pre>

<hr>
<h2 id='grab_significance'>grab_significance</h2><span id='topic+grab_significance'></span>

<h3>Description</h3>

<p>Generate inferential statistics comparing the rarety of the unit that
actually received the intervention to the placebo units in the donor pool.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grab_significance(data, time_window = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="grab_significance_+3A_data">data</code></td>
<td>
<p>nested data of type <code>tbl_df</code></p>
</td></tr>
<tr><td><code id="grab_significance_+3A_time_window">time_window</code></td>
<td>
<p>time window that the significance values should be
computed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Inferential statitics are generated by comparing the observed difference
between the actual treated unit and its synthetic control to each placebo
unit and its synthetic control. The rarity of the actual to the placebo is
used to infer the likelihood of observing the effect.
</p>
<p>Inference in this framework leverages the mean squared predictive error
(MSPE) of the fit in the pre-period to the fit in the post-period as a ratio.
</p>
<p style="text-align: center;"><code class="reqn">\frac{RMSE_{Post}}{RMSE_{Pre}}</code>
</p>

<p>The ratio captures the differences between the pre-intervention fit and the
post-intervention divergence of the trend (i.e. the causal quantity). A good
fit in the pre-period denotes that the observed and synthetic case tracked
well together. Divergence in the post-period captures the difference brought
about by the intervention in the two trends. Thus, when the ratio is high, we
observe more of a difference between the two trends. If, however, the
pre-period fit is poor, or there is not substantial divergence in the
post-period, then this ratio amount will be smaller.
</p>
<p>The Fisher's Exact P-Value is generated by ranking the ratios for the treated
and placebo units. The P-Value is then calculated by dividing the rank of the
case over the total (rank/total). The case with the highest RMSE ratio is
rare given the distribution of cases as generated by the placebo. A more
detailed outline of inference within the synthetic control framework can be
found in Adabie et al. 2010.
</p>
<p>Note that conventional significance levels are not achievable if there is an
insufficient number of control cases. One needs at least 20 control case to
use the conventional .05 level. With fewer cases, significance levels need to
be adjusted to accommodate the low total rank. This is a bug of rank based
significance metrics.
</p>
<p>In addition to the Fisher's Precise P-Value, a Z-score is also included,
which is just the standardized RMSE ratios for all the cases. The Z-Score
captures the degree to which a particular case's RMSE ratio deviates from the
distribution of the placebo cases.
</p>


<h3>Value</h3>

<p>tibble data frame containing the following fields:
</p>

<ul>
<li> <p><code>unit_name</code>: name of the unit
</p>
</li>
<li> <p><code>type</code>: treated or donor unit (placebo)
</p>
</li>
<li> <p><code>pre_mspe</code>: pre-intervention period means squared predictive error
</p>
</li>
<li> <p><code>post_mspe</code>: post-intervention period means squared predictive error
</p>
</li>
<li> <p><code>mspe_ratio</code>: post_mspe/pre_mspe; captures the difference in fit in the
pre and post period. A good fit in the pre-period and a poor fit in the
post-period reflects a meaningful effect when comparing the difference
between the observed outcome and the synthetic control.
</p>
</li>
<li> <p><code>rank</code>: rank order of the mspe_ratio.
</p>
</li>
<li> <p><code>fishers_exact_pvalue</code>: rank/total to generate a p-value. Conventional
levels aren't achievable if there isn't a sufficient number of controls to
generate a large enough ranking. Need at least 20 control units to use the
conventional .05 level.
</p>
</li>
<li> <p><code>z_score</code>: (mspe_ratio-mean(mspe_ratio))/sd(mspe_ratio); captures the
degree to which the mspe_ratio of the treated unit deviates from the mean
of the placebo units. Provinding an alternative significance determination.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>


# Smoking example data
data(smoking)

smoking_out &lt;-
smoking %&gt;%

# initial the synthetic control object
synthetic_control(outcome = cigsale,
                  unit = state,
                  time = year,
                  i_unit = "California",
                  i_time = 1988,
                  generate_placebos=FALSE) %&gt;%

# Generate the aggregate predictors used to generate the weights
  generate_predictor(time_window=1980:1988,
                     lnincome = mean(lnincome, na.rm = TRUE),
                     retprice = mean(retprice, na.rm = TRUE),
                     age15to24 = mean(age15to24, na.rm = TRUE)) %&gt;%

  generate_predictor(time_window=1984:1988,
                     beer = mean(beer, na.rm = TRUE)) %&gt;%

  generate_predictor(time_window=1975,
                     cigsale_1975 = cigsale) %&gt;%

  generate_predictor(time_window=1980,
                     cigsale_1980 = cigsale) %&gt;%

  generate_predictor(time_window=1988,
                     cigsale_1988 = cigsale) %&gt;%


  # Generate the fitted weights for the synthetic control
  generate_weights(optimization_window =1970:1988,
                   Margin.ipop=.02,Sigf.ipop=7,Bound.ipop=6) %&gt;%

  # Generate the synthetic control
  generate_control()

# Plot the observed and synthetic trend
smoking_out %&gt;% grab_significance(time_window = 1970:2000)



</code></pre>

<hr>
<h2 id='grab_synthetic_control'>grab_synthetic_control</h2><span id='topic+grab_synthetic_control'></span>

<h3>Description</h3>

<p>Extract the synthetic control as a data frame generated using
<code>generate_control()</code> from the synth pipeline.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grab_synthetic_control(data, placebo = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="grab_synthetic_control_+3A_data">data</code></td>
<td>
<p>nested data of type <code>tbl_df</code></p>
</td></tr>
<tr><td><code id="grab_synthetic_control_+3A_placebo">placebo</code></td>
<td>
<p>boolean flag; if TRUE placebo values are returned as well (if
available). Default is FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>tibble data frame
</p>


<h3>Examples</h3>

<pre><code class='language-R'>


# Smoking example data
data(smoking)

smoking_out &lt;-
smoking %&gt;%

# initial the synthetic control object
synthetic_control(outcome = cigsale,
                  unit = state,
                  time = year,
                  i_unit = "California",
                  i_time = 1988,
                  generate_placebos=TRUE) %&gt;%

# Generate the aggregate predictors used to generate the weights
  generate_predictor(time_window=1980:1988,
                     lnincome = mean(lnincome, na.rm = TRUE),
                     retprice = mean(retprice, na.rm = TRUE),
                     age15to24 = mean(age15to24, na.rm = TRUE)) %&gt;%

  generate_predictor(time_window=1984:1988,
                     beer = mean(beer, na.rm = TRUE)) %&gt;%

  generate_predictor(time_window=1975,
                     cigsale_1975 = cigsale) %&gt;%

  generate_predictor(time_window=1980,
                     cigsale_1980 = cigsale) %&gt;%

  generate_predictor(time_window=1988,
                     cigsale_1988 = cigsale) %&gt;%


  # Generate the fitted weights for the synthetic control
  generate_weights(optimization_window =1970:1988,
                   Margin.ipop=.02,Sigf.ipop=7,Bound.ipop=6) %&gt;%

  # Generate the synthetic control
  generate_control()

# Grab a data frame containing the observed outcome and the synthetic control outcome
smoking_out %&gt;% grab_synthetic_control()


# Grab the data frame with the placebos.
smoking_out %&gt;% grab_synthetic_control(placebo=TRUE)



</code></pre>

<hr>
<h2 id='grab_unit_weights'>grab_unit_weights</h2><span id='topic+grab_unit_weights'></span>

<h3>Description</h3>

<p>Extract the unit weights generated by <code>generate_weights()</code> from the synth pipeline.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grab_unit_weights(data, placebo = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="grab_unit_weights_+3A_data">data</code></td>
<td>
<p>nested data of type <code>tbl_df</code></p>
</td></tr>
<tr><td><code id="grab_unit_weights_+3A_placebo">placebo</code></td>
<td>
<p>boolean flag; if TRUE placebo values are returned as well (if
available). Default is FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>tibble data frame
</p>


<h3>Examples</h3>

<pre><code class='language-R'>


# Smoking example data
data(smoking)

smoking_out &lt;-
smoking %&gt;%

# initial the synthetic control object
synthetic_control(outcome = cigsale,
                  unit = state,
                  time = year,
                  i_unit = "California",
                  i_time = 1988,
                  generate_placebos=TRUE) %&gt;%

# Generate the aggregate predictors used to generate the weights
  generate_predictor(time_window=1980:1988,
                     lnincome = mean(lnincome, na.rm = TRUE),
                     retprice = mean(retprice, na.rm = TRUE),
                     age15to24 = mean(age15to24, na.rm = TRUE)) %&gt;%

  generate_predictor(time_window=1984:1988,
                     beer = mean(beer, na.rm = TRUE)) %&gt;%

  generate_predictor(time_window=1975,
                     cigsale_1975 = cigsale) %&gt;%

  generate_predictor(time_window=1980,
                     cigsale_1980 = cigsale) %&gt;%

  generate_predictor(time_window=1988,
                     cigsale_1988 = cigsale) %&gt;%


  # Generate the fitted weights for the synthetic control
  generate_weights(optimization_window =1970:1988,
                   Margin.ipop=.02,Sigf.ipop=7,Bound.ipop=6)

# Grab the unit weights for the treated unit.
smoking_out %&gt;% grab_unit_weights()

# Grab the unit weights for the placebo units as well.
smoking_out %&gt;% grab_unit_weights(placebo=TRUE)



</code></pre>

<hr>
<h2 id='plot_differences'>plot_difference</h2><span id='topic+plot_differences'></span>

<h3>Description</h3>

<p>Plot the difference between the observed and synthetic control unit. The
difference captures the causal quantity (i.e. the magnitude of the difference
between the observed and counter-factual case).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_differences(data, time_window = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_differences_+3A_data">data</code></td>
<td>
<p>nested data of type <code>tbl_df</code>.</p>
</td></tr>
<tr><td><code id="plot_differences_+3A_time_window">time_window</code></td>
<td>
<p>time window of the trend plot.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>ggplot</code> object of the difference between the observed and synthetic
trends.
</p>
<p><code>ggplot</code> object of difference between the observed and synthetic control unit.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>



# Smoking example data
data(smoking)

smoking_out &lt;-
smoking %&gt;%

# initial the synthetic control object
synthetic_control(outcome = cigsale,
                  unit = state,
                  time = year,
                  i_unit = "California",
                  i_time = 1988,
                  generate_placebos=TRUE) %&gt;%

# Generate the aggregate predictors used to generate the weights
  generate_predictor(time_window=1980:1988,
                     lnincome = mean(lnincome, na.rm = TRUE),
                     retprice = mean(retprice, na.rm = TRUE),
                     age15to24 = mean(age15to24, na.rm = TRUE)) %&gt;%

  generate_predictor(time_window=1984:1988,
                     beer = mean(beer, na.rm = TRUE)) %&gt;%

  generate_predictor(time_window=1975,
                     cigsale_1975 = cigsale) %&gt;%

  generate_predictor(time_window=1980,
                     cigsale_1980 = cigsale) %&gt;%

  generate_predictor(time_window=1988,
                     cigsale_1988 = cigsale) %&gt;%


  # Generate the fitted weights for the synthetic control
  generate_weights(optimization_window =1970:1988,
                   Margin.ipop=.02,Sigf.ipop=7,Bound.ipop=6) %&gt;%

  # Generate the synthetic control
  generate_control()

# Plot the observed and synthetic trend
smoking_out %&gt;% plot_differences(time_window = 1970:2000)



</code></pre>

<hr>
<h2 id='plot_mspe_ratio'>plot_mspe_ratio</h2><span id='topic+plot_mspe_ratio'></span>

<h3>Description</h3>

<p>Plot the MSPE ratios for each case (observed and placebos). The ratio is used
for inference in the synthetic control setup. The following plot ranks the
RMSE ratio's in descending order.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_mspe_ratio(data, time_window = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_mspe_ratio_+3A_data">data</code></td>
<td>
<p>nested data of type <code>tbl_df</code>.</p>
</td></tr>
<tr><td><code id="plot_mspe_ratio_+3A_time_window">time_window</code></td>
<td>
<p>time window that the pre- and post-period values should be
used to compute the MSPE ratio.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Inferential statitics are generated by comparing the observed difference
between the actual treated unit and its synthetic control to each placebo
unit and its synthetic control. The rarity of the actual to the placebo is
used to infer the likelihood of observing the effect.
</p>
<p>Inference in this framework leverages the mean squared predictive error
(MSPE) of the fit in the pre-period to the fit in the post-period as a ratio.
</p>
<p style="text-align: center;"><code class="reqn">\frac{RMSE_{Post}}{RMSE_{Pre}}</code>
</p>

<p>The ratio captures the differences between the pre-intervention fit and the
post-intervention divergence of the trend (i.e. the causal quantity). A good
fit in the pre-period denotes that the observed and synthetic case tracked
well together. Divergence in the post-period captures the difference brought
about by the intervention in the two trends. Thus, when the ratio is high, we
observe more of a difference between the two trends. If, however, the
pre-period fit is poor, or there is not substantial divergence in the
post-period, then this ratio amount will be smaller. A more detailed outline
of inference within the synthetic control framework can be found in Adabie et
al. 2010.
</p>


<h3>Value</h3>

<p><code>ggplot</code> object plotting the MSPE ratios by case.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>


# Smoking example data
data(smoking)

smoking_out &lt;-
smoking %&gt;%

# initial the synthetic control object
synthetic_control(outcome = cigsale,
                  unit = state,
                  time = year,
                  i_unit = "California",
                  i_time = 1988,
                  generate_placebos=TRUE) %&gt;%

# Generate the aggregate predictors used to generate the weights
  generate_predictor(time_window=1980:1988,
                     lnincome = mean(lnincome, na.rm = TRUE),
                     retprice = mean(retprice, na.rm = TRUE),
                     age15to24 = mean(age15to24, na.rm = TRUE)) %&gt;%

  generate_predictor(time_window=1984:1988,
                     beer = mean(beer, na.rm = TRUE)) %&gt;%

  generate_predictor(time_window=1975,
                     cigsale_1975 = cigsale) %&gt;%

  generate_predictor(time_window=1980,
                     cigsale_1980 = cigsale) %&gt;%

  generate_predictor(time_window=1988,
                     cigsale_1988 = cigsale) %&gt;%


  # Generate the fitted weights for the synthetic control
  generate_weights(optimization_window =1970:1988,
                   Margin.ipop=.02,Sigf.ipop=7,Bound.ipop=6) %&gt;%

  # Generate the synthetic control
  generate_control()

# Plot the observed and synthetic trend
smoking_out %&gt;% plot_mspe_ratio(time_window = 1970:2000)



</code></pre>

<hr>
<h2 id='plot_placebos'>plot_placebos</h2><span id='topic+plot_placebos'></span>

<h3>Description</h3>

<p>Plot the difference between the observed and sythetic control unit for the
treated and the placebo units. The difference captures the causal quantity
(i.e. the magnitude of the difference between the observed and counterfactual
case). Plotting the actual treated observation against the placebos captures
the likelihood (or rarity) of the observed differenced trend.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_placebos(data, time_window = NULL, prune = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_placebos_+3A_data">data</code></td>
<td>
<p>nested data of type <code>tbl_df</code>.</p>
</td></tr>
<tr><td><code id="plot_placebos_+3A_time_window">time_window</code></td>
<td>
<p>time window of the tbl_df plot.</p>
</td></tr>
<tr><td><code id="plot_placebos_+3A_prune">prune</code></td>
<td>
<p>boolean flag; if TRUE, then all placebo cases with a pre-period
RMSPE exceeding two times the treated unit pre-period RMSPE are pruned;
Default is TRUE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function provides a pruning rule where all placebo cases with a
pre-period root mean squared predictive error (RMSPE) exceeding two times the
treated unit pre-period RMSPE are pruned. This helps overcome scale issues
when a particular placebo case has poor fit in the pre-period.
</p>
<p>See documentation on <code>?synthetic_control</code> on how to generate placebo cases.
When initializing a synth pipeline, set the <code>generate_placebos</code> argument to
<code>TRUE</code>. The processing pipeline remains the same.
</p>


<h3>Value</h3>

<p><code>ggplot</code> object of the difference between the observed and synthetic
trends for the treated and placebo units.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>


# Smoking example data
data(smoking)

smoking_out &lt;-
smoking %&gt;%

# initial the synthetic control object
synthetic_control(outcome = cigsale,
                  unit = state,
                  time = year,
                  i_unit = "California",
                  i_time = 1988,
                  generate_placebos=TRUE) %&gt;%

# Generate the aggregate predictors used to generate the weights
  generate_predictor(time_window=1980:1988,
                     lnincome = mean(lnincome, na.rm = TRUE),
                     retprice = mean(retprice, na.rm = TRUE),
                     age15to24 = mean(age15to24, na.rm = TRUE)) %&gt;%

  generate_predictor(time_window=1984:1988,
                     beer = mean(beer, na.rm = TRUE)) %&gt;%

  generate_predictor(time_window=1975,
                     cigsale_1975 = cigsale) %&gt;%

  generate_predictor(time_window=1980,
                     cigsale_1980 = cigsale) %&gt;%

  generate_predictor(time_window=1988,
                     cigsale_1988 = cigsale) %&gt;%


  # Generate the fitted weights for the synthetic control
  generate_weights(optimization_window =1970:1988,
                   Margin.ipop=.02,Sigf.ipop=7,Bound.ipop=6) %&gt;%

  # Generate the synthetic control
  generate_control()

# Plot the observed and synthetic trend
smoking_out %&gt;% plot_placebos(time_window = 1970:2000)



</code></pre>

<hr>
<h2 id='plot_trends'>plot_trends</h2><span id='topic+plot_trends'></span>

<h3>Description</h3>

<p>Plot the observed and synthetic trends for the treated units.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_trends(data, time_window = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_trends_+3A_data">data</code></td>
<td>
<p>nested data of type <code>tbl_df</code>.</p>
</td></tr>
<tr><td><code id="plot_trends_+3A_time_window">time_window</code></td>
<td>
<p>time window of the trend plot.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Synthetic control is a visual-based method, like Regression Discontinuity, so
inspection of the pre-intervention period fits is key assessing the sythetic
control's fit. A poor fit in the pre-period reduces confidence in the
post-period trend capturing the counterfactual.
</p>
<p>See <code>?generate_control()</code> for information on how to generate a synthetic
control unit.
</p>


<h3>Value</h3>

<p><code>ggplot</code> object of the observed and synthetic trends.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>


# Smoking example data
data(smoking)

smoking_out &lt;-
smoking %&gt;%

# initial the synthetic control object
synthetic_control(outcome = cigsale,
                  unit = state,
                  time = year,
                  i_unit = "California",
                  i_time = 1988,
                  generate_placebos=TRUE) %&gt;%

# Generate the aggregate predictors used to generate the weights
  generate_predictor(time_window=1980:1988,
                     lnincome = mean(lnincome, na.rm = TRUE),
                     retprice = mean(retprice, na.rm = TRUE),
                     age15to24 = mean(age15to24, na.rm = TRUE)) %&gt;%

  generate_predictor(time_window=1984:1988,
                     beer = mean(beer, na.rm = TRUE)) %&gt;%

  generate_predictor(time_window=1975,
                     cigsale_1975 = cigsale) %&gt;%

  generate_predictor(time_window=1980,
                     cigsale_1980 = cigsale) %&gt;%

  generate_predictor(time_window=1988,
                     cigsale_1988 = cigsale) %&gt;%


  # Generate the fitted weights for the synthetic control
  generate_weights(optimization_window =1970:1988,
                   Margin.ipop=.02,Sigf.ipop=7,Bound.ipop=6) %&gt;%

  # Generate the synthetic control
  generate_control()

# Plot the observed and synthetic trend
smoking_out %&gt;% plot_trends(time_window = 1970:2000)




</code></pre>

<hr>
<h2 id='plot_weights'>plot_weights</h2><span id='topic+plot_weights'></span>

<h3>Description</h3>

<p>Plot the unit and predictor variable weights generated using <code>generate_weights()</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_weights(data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_weights_+3A_data">data</code></td>
<td>
<p>nested data of type <code>tbl_df</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <code>grab_unit_weights()</code> and <code>grab_predictor_weights()</code>
</p>


<h3>Value</h3>

<p>a <code>ggplot</code> object that plots the unit and variable weights.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>


# Smoking example data
data(smoking)

smoking_out &lt;-
smoking %&gt;%

# initial the synthetic control object
synthetic_control(outcome = cigsale,
                  unit = state,
                  time = year,
                  i_unit = "California",
                  i_time = 1988,
                  generate_placebos=TRUE) %&gt;%

# Generate the aggregate predictors used to generate the weights
  generate_predictor(time_window=1980:1988,
                     lnincome = mean(lnincome, na.rm = TRUE),
                     retprice = mean(retprice, na.rm = TRUE),
                     age15to24 = mean(age15to24, na.rm = TRUE)) %&gt;%

  generate_predictor(time_window=1984:1988,
                     beer = mean(beer, na.rm = TRUE)) %&gt;%

  generate_predictor(time_window=1975,
                     cigsale_1975 = cigsale) %&gt;%

  generate_predictor(time_window=1980,
                     cigsale_1980 = cigsale) %&gt;%

  generate_predictor(time_window=1988,
                     cigsale_1988 = cigsale) %&gt;%


  # Generate the fitted weights for the synthetic control
  generate_weights(optimization_window =1970:1988,
                   Margin.ipop=.02,Sigf.ipop=7,Bound.ipop=6) %&gt;%

  # Generate the synthetic control
  generate_control()

# Plot the observed and synthetic trend
smoking_out %&gt;% plot_weights()



</code></pre>

<hr>
<h2 id='smoking'>smoking dataset</h2><span id='topic+smoking'></span>

<h3>Description</h3>

<p>A dataset on the implementation of Proposition 99 in California in 1988. Data
contains information on California and 38 other (control/donor) states used
in Abadie et al. 2010's paper walking through the synthetic control method.
Covers the time range 1970 to 2000
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(smoking)
</code></pre>


<h3>Format</h3>

<p>A data frame with 1209 rows and 7 variables: </p>

<dl>
<dt>state</dt><dd><p>name of U.S. state</p>
</dd> <dt>year</dt><dd><p>year</p>
</dd> <dt>cigsale</dt><dd><p>cigarette
sales pack per 100,000 people</p>
</dd> <dt>lnincome</dt><dd><p>log mean income</p>
</dd>
<dt>beer</dt><dd><p>beer sales per 100,000 people</p>
</dd> <dt>age15to24</dt><dd><p>Proportion of
the population between 15 and 24</p>
</dd> <dt>retprice</dt><dd><p>Retail price of a box of
cigarettes</p>
</dd> </dl>



<h3>Source</h3>

<p>https://economics.mit.edu/files/11859
</p>


<h3>References</h3>

<p>Abadie, A., Diamond, A. and Hainmueller, J., 2010. Synthetic
control methods for comparative case studies: Estimating the effect of
California’s tobacco control program. Journal of the American statistical
Association, 105(490), pp.493-505.
</p>

<hr>
<h2 id='synth_method'>synth_method</h2><span id='topic+synth_method'></span>

<h3>Description</h3>

<p>AUX Function: Original synthetic control method proposed by (Abadie et al.
2003, 2010, 2015) and implemented in <code>synth</code> package. Method has been
commandeered for internal use here.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>synth_method(
  treatment_unit_covariates = NULL,
  control_units_covariates = NULL,
  control_units_outcome = NULL,
  treatment_unit_outcome = NULL,
  custom.v = NULL,
  optimxmethod = c("Nelder-Mead", "BFGS"),
  genoud = FALSE,
  Margin.ipop = 5e-04,
  Sigf.ipop = 5,
  Bound.ipop = 10,
  verbose = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="synth_method_+3A_treatment_unit_covariates">treatment_unit_covariates</code></td>
<td>
<p>matrix of treated predictor data</p>
</td></tr>
<tr><td><code id="synth_method_+3A_control_units_covariates">control_units_covariates</code></td>
<td>
<p>matrix of controls' predictor data.</p>
</td></tr>
<tr><td><code id="synth_method_+3A_control_units_outcome">control_units_outcome</code></td>
<td>
<p>matrix of controls' outcome data for the
pre-treatment periods over which MSPE is to be minimized.</p>
</td></tr>
<tr><td><code id="synth_method_+3A_treatment_unit_outcome">treatment_unit_outcome</code></td>
<td>
<p>matrix of treated outcome data for the
pre-treatment periods over which MSPE is to be minimized.</p>
</td></tr>
<tr><td><code id="synth_method_+3A_custom.v">custom.v</code></td>
<td>
<p>vector of weights for predictors supplied by the user. uses
synth to bypass optimization for solution.V. See details.</p>
</td></tr>
<tr><td><code id="synth_method_+3A_optimxmethod">optimxmethod</code></td>
<td>
<p>string vector that specifies the optimization algorithms
to be used. Permissible values are all optimization algorithms that are
currently implemented in the optimx function (see this function for
details). This list currently includes c(&quot;Nelder-Mead', 'BFGS', 'CG',
'L-BFGS-B', 'nlm', 'nlminb', 'spg', and 'ucminf&quot;). If multiple algorithms
are specified, synth will run the optimization with all chosen algorithms
and then return the result for the best performing method. Default is
c(&quot;Nelder-Mead&quot;, &quot;BFGS&quot;). As an additional possibility, the user can also
specify 'All' which means that synth will run the results over all
algorithms in optimx.</p>
</td></tr>
<tr><td><code id="synth_method_+3A_genoud">genoud</code></td>
<td>
<p>Logical flag. If true, synth embarks on a two step
optimization. In the first step, genoud, an optimization function that
combines evolutionary algorithm methods with a derivative-based
(quasi-Newton) method to solve difficult optimization problems, is used to
obtain a solution. See genoud for details. In the second step, the genoud
results are passed to the optimization algorithm(s) chosen in optimxmethod
for a local optimization within the neighborhood of the genoud solution.
This two step optimization procedure will require much more computing time,
but may yield lower loss in cases where the search space is highly
irregular.</p>
</td></tr>
<tr><td><code id="synth_method_+3A_margin.ipop">Margin.ipop</code></td>
<td>
<p>setting for ipop optimization routine: how close we get to
the constrains (see ipop for details)</p>
</td></tr>
<tr><td><code id="synth_method_+3A_sigf.ipop">Sigf.ipop</code></td>
<td>
<p>setting for ipop optimization routine: Precision (default: 7
significant figures (see ipop for details)</p>
</td></tr>
<tr><td><code id="synth_method_+3A_bound.ipop">Bound.ipop</code></td>
<td>
<p>setting for ipop optimization routine: Clipping bound for
the variables (see ipop for details)</p>
</td></tr>
<tr><td><code id="synth_method_+3A_verbose">verbose</code></td>
<td>
<p>Logical flag. If TRUE then intermediate results will be shown.</p>
</td></tr>
<tr><td><code id="synth_method_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to optimx and or genoud to
adjust optimization.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Synth works as the main engine of the <code>tidysynth</code> package. More on the method
and estimation procedures can be found in (Abadie et al. 2010).
</p>
<p>As proposed in Abadie and Gardeazabal (2003) and Abadie, Diamond,
Hainmueller (2010), the synth function routinely searches for the set of
weights that generate the best fitting convex combination of the control
units. In other words, the predictor weight matrix V is chosen among all
positive definite diagonal matrices such that MSPE is minimized for the
pre-intervention period. Instead of using this data-driven procedures to
search for the best fitting synthetic control group, the user may supply
his own vector of V weights, based on his subjective assessment of the
predictive power of the variables in treatment_unit_covariates and
control_units_covariates. In this case, the vector of V weights for each
variable should be supplied via the custom.V option in synth and the
optimization over the V matrices is bypassed.
</p>


<h3>Value</h3>

<p>solution.v =	vector of predictor weights; solution.w = vector of
weights across the controls; loss.v	= MSPE from optimization over v and w
weights; loss.w	= Loss from optimization over w weights; custom.v	=if this
argument was specified in the call to synth, this outputs the weight vector
specified; rgV.optim = Results from optimx() minimization. Could be used
for diagnostics.
</p>

<hr>
<h2 id='synth_weights'>synth_weights</h2><span id='topic+synth_weights'></span>

<h3>Description</h3>

<p>Auxiliary Function for generating individual weights for each unit-specific
data entry. The method allows of opimtizing weights for all placebo and
treated data configurations (assuming there are placebo configurations to
generate)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>synth_weights(
  data,
  time_window = NULL,
  custom_variable_weights = NULL,
  include_fit = FALSE,
  optimization_method = c("Nelder-Mead", "BFGS"),
  genoud = FALSE,
  quadopt = "ipop",
  Margin.ipop = 5e-04,
  Sigf.ipop = 5,
  Bound.ipop = 10,
  verbose = verbose,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="synth_weights_+3A_data">data</code></td>
<td>
<p>nested data of type <code>synth_tbl</code> generated from
<code>sythetic_control()</code>. See <code>synthetic_control()</code> documentation for more
information. In addition, a matrix of predictors must be pre-specified
using the <code>generate_predictor()</code> function. See documentation for more
information on how to generate a predictor function.</p>
</td></tr>
<tr><td><code id="synth_weights_+3A_time_window">time_window</code></td>
<td>
<p>the temporal window of the pre-intervention outcome time
series to be used in the optimization task. Default behavior uses the
entire pre-intervention time period.</p>
</td></tr>
<tr><td><code id="synth_weights_+3A_custom_variable_weights">custom_variable_weights</code></td>
<td>
<p>a vector of provided weights that define a
variable's importance in the optimization task. The weights are intended to
reflect the users prior regarding the relative significance of each
variable. Vector must sum to one. Note that the method is significantly
faster when a custom variable weights are provided. Default behavior
assumes no wieghts are provided and thus must be learned from the data.</p>
</td></tr>
<tr><td><code id="synth_weights_+3A_include_fit">include_fit</code></td>
<td>
<p>Boolean flag, if TRUE, then the optimization output is
included in the outputted <code>tbl_df</code>.</p>
</td></tr>
<tr><td><code id="synth_weights_+3A_optimization_method">optimization_method</code></td>
<td>
<p>string vector that specifies the optimization
algorithms to be used. Permissable values are all optimization algorithms
that are currently implemented in the optimx function (see this function
for details). This list currently includes c(&quot;Nelder-Mead', 'BFGS', 'CG',
'L-BFGS-B', 'nlm', 'nlminb', 'spg', and 'ucminf&quot;). If multiple algorithms
are specified, synth will run the optimization with all chosen algorithms
and then return the result for the best performing method. Default is
&quot;BFGS&quot;. As an additional possibility, the user can also specify 'All' which
means that synth will run the results over all algorithms in optimx.</p>
</td></tr>
<tr><td><code id="synth_weights_+3A_genoud">genoud</code></td>
<td>
<p>Logical flag. If true, synth embarks on a two step
optimization. In the first step, genoud, an optimization function that
combines evolutionary algorithm methods with a derivative-based
(quasi-Newton) method to solve difficult optimization problems, is used to
obtain a solution. See genoud for details. In the second step, the genoud
results are passed to the optimization algorithm(s) chosen in optimxmethod
for a local optimization within the neighborhood of the genoud solution.
This two step optimization procedure will require much more computing time,
but may yield lower loss in cases where the search space is highly
irregular.</p>
</td></tr>
<tr><td><code id="synth_weights_+3A_quadopt">quadopt</code></td>
<td>
<p>string vector that specifies the routine for quadratic
optimization over w weights. possible values are &quot;ipop&quot; and &quot;LowRankQP&quot;
(see ipop and LowRankQP for details). default is 'ipop'</p>
</td></tr>
<tr><td><code id="synth_weights_+3A_margin.ipop">Margin.ipop</code></td>
<td>
<p>setting for ipop optimization routine: how close we get to
the constraints (see ipop for details)</p>
</td></tr>
<tr><td><code id="synth_weights_+3A_sigf.ipop">Sigf.ipop</code></td>
<td>
<p>setting for ipop optimization routine: Precision (default: 7
significant figures (see ipop for details)</p>
</td></tr>
<tr><td><code id="synth_weights_+3A_bound.ipop">Bound.ipop</code></td>
<td>
<p>setting for ipop optimization routine: Clipping bound for
the variables (see ipop for details)</p>
</td></tr>
<tr><td><code id="synth_weights_+3A_verbose">verbose</code></td>
<td>
<p>Logical flag. If TRUE then intermediate results will be shown.</p>
</td></tr>
<tr><td><code id="synth_weights_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to optimx and or genoud to
adjust optimization.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>tibble data frame with optimized weights attached.
</p>

<hr>
<h2 id='synthetic_control'>synthetic_control</h2><span id='topic+synthetic_control'></span>

<h3>Description</h3>

<p><code>synthetic_control()</code> declares the input data frame for use in the synthetic
control method. Allows for the specification of the panel units along with
the intervention unit and time (<code>treated</code>). All units that are not the
designated treated units are entered into the donor pool from which the
synthetic control is generated. All time points prior and equal to the
intervention time are designated as the pre-intervention period; and all time
periods after are the post-intervention period.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>synthetic_control(
  data = NULL,
  outcome = NULL,
  unit = NULL,
  time = NULL,
  i_unit = NULL,
  i_time = NULL,
  generate_placebos = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="synthetic_control_+3A_data">data</code></td>
<td>
<p>panel data frame in long format (i.e. unit of analysis is
unit-time period, such as country-year) containing both treated and control
donor pool units. All units/time periods that are not desired to be in the
donor should be excluded prior to passing to <code>synthetic_control()</code>.</p>
</td></tr>
<tr><td><code id="synthetic_control_+3A_outcome">outcome</code></td>
<td>
<p>Name of the outcome variable. Outcome variable should be a
continuous measure that is observed across multiple time points.</p>
</td></tr>
<tr><td><code id="synthetic_control_+3A_unit">unit</code></td>
<td>
<p>Name of the case unit variable in the panel data.</p>
</td></tr>
<tr><td><code id="synthetic_control_+3A_time">time</code></td>
<td>
<p>Name of the time unit variable in the panel data.</p>
</td></tr>
<tr><td><code id="synthetic_control_+3A_i_unit">i_unit</code></td>
<td>
<p>Name of the treated case unit where the intervention occurred.</p>
</td></tr>
<tr><td><code id="synthetic_control_+3A_i_time">i_time</code></td>
<td>
<p>Name of the treated time period when the intervention occurred.</p>
</td></tr>
<tr><td><code id="synthetic_control_+3A_generate_placebos">generate_placebos</code></td>
<td>
<p>logical flag requesting that placebo versions of the
data be generated for downstream inferential methods. Generates a version
of the nested data where each control unit is the intervention unit.
Default is TRUE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that <code>synthetic_control()</code> also allows for the simultaneous generation
of placebo units (i.e. units where the treated unit is one of the controls).
The addition of the placebo units increases computation time (as a synthetic
control needs to be generated for each placebo unit) but it allows for
inference as outlined in Abadie et al. 2010.
</p>


<h3>Value</h3>

<p><code>tbl_df</code> with nested fields containing the following:
</p>

<ul>
<li> <p><code>.id</code>: unit id for the intervention case (this will differ when a placebo
unit).
</p>
</li>
<li> <p><code>.placebo</code>: indicator field taking on the value of 1 if a unit is a
placebo unit, 0 if it's the specified treated unit.
</p>
</li>
<li> <p><code>.type</code>: type of the nested data construct: <code>treated</code> or <code>controls</code>.
Keeps tract of which data construct is located in <code>.outcome</code> field.
</p>
</li>
<li> <p><code>.outcome</code>: nested data construct containing the outcome variable
configured for the sythnetic control method. Data is configured into a wide
formate for the optimization task.
</p>
</li>
<li> <p><code>.original_data</code>: original impute data filtered by treated or control
units. This allows for easy processing down stream when generating
predictors.
</p>
</li>
<li> <p><code>.meta</code>: stores information regarding the unit and time index, the
treated unit and time and the name of the outcome variable. Used downstream
in subsequent functions.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
############################
###### Basic Example #######
############################


# Smoking example data
data(smoking)

# initial the synthetic control object
smoking_out &lt;-
smoking %&gt;%
synthetic_control(outcome = cigsale,
                  unit = state,
                  time = year,
                  i_unit = "California",
                  i_time = 1988,
                  generate_placebos= FALSE)

# data configuration
dplyr::glimpse(smoking_out)

# Grap the organized outcome variables
smoking_out %&gt;% grab_outcome(type = "treated")
smoking_out %&gt;% grab_outcome(type = "controls")


###################################
####### Full implementation #######
###################################


# Smoking example data
data(smoking)

smoking_out &lt;-
smoking %&gt;%

# initial the synthetic control object
synthetic_control(outcome = cigsale,
                  unit = state,
                  time = year,
                  i_unit = "California",
                  i_time = 1988,
                  generate_placebos= FALSE) %&gt;%

# Generate the aggregate predictors used to generate the weights
  generate_predictor(time_window=1980:1988,
                     lnincome = mean(lnincome, na.rm = TRUE),
                     retprice = mean(retprice, na.rm = TRUE),
                     age15to24 = mean(age15to24, na.rm = TRUE)) %&gt;%

  generate_predictor(time_window=1984:1988,
                     beer = mean(beer, na.rm = TRUE)) %&gt;%

  generate_predictor(time_window=1975,
                     cigsale_1975 = cigsale) %&gt;%

  generate_predictor(time_window=1980,
                     cigsale_1980 = cigsale) %&gt;%

  generate_predictor(time_window=1988,
                     cigsale_1988 = cigsale) %&gt;%


  # Generate the fitted weights for the synthetic control
  generate_weights(optimization_window =1970:1988,
                   Margin.ipop=.02,Sigf.ipop=7,Bound.ipop=6) %&gt;%

  # Generate the synthetic control
  generate_control()

# Plot the observed and synthetic trend
smoking_out %&gt;% plot_trends(time_window = 1970:2000)




</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
