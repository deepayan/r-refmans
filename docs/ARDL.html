<!DOCTYPE html><html lang="en"><head><title>Help for package ARDL</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {ARDL}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#ARDL-package'><p>ARDL: ARDL, ECM and Bounds-Test for Cointegration</p></a></li>
<li><a href='#ardl'><p>ARDL model regression</p></a></li>
<li><a href='#auto_ardl'><p>Automatic ARDL model selection</p></a></li>
<li><a href='#bounds_f_test'><p>Bounds Wald-test for no cointegration</p></a></li>
<li><a href='#bounds_t_test'><p>Bounds t-test for no cointegration</p></a></li>
<li><a href='#build_ardl_formula'><p>ARDL formula specification builder</p></a></li>
<li><a href='#build_recm_formula'><p>RECM formula specification builder</p></a></li>
<li><a href='#build_uecm_formula'><p>UECM formula specification builder</p></a></li>
<li><a href='#coint_eq'><p>Cointegrating equation (long-run level relationship)</p></a></li>
<li><a href='#delta_method'><p>Delta method</p></a></li>
<li><a href='#denmark'><p>The Danish data on money income prices and interest rates</p></a></li>
<li><a href='#f_bounds_sim'><p>Critical value bounds stochastic simulation for Wald bounds-test for no</p>
cointegration</a></li>
<li><a href='#f_test_custom'><p>F-test of regression's overall significance</p></a></li>
<li><a href='#multipliers'><p>Multipliers estimation</p></a></li>
<li><a href='#NT2022'><p>The UK earnings equation data from Natsiopoulos and Tzeremes (2022)</p></a></li>
<li><a href='#parse_case'><p>Case parser</p></a></li>
<li><a href='#parse_formula'><p>Formula parser</p></a></li>
<li><a href='#parse_order'><p>Order parser</p></a></li>
<li><a href='#plot_delay'><p>Create plots for the delay multipliers</p></a></li>
<li><a href='#plot_lr'><p>Create plot for the long-run (cointegrating) equation</p></a></li>
<li><a href='#PSS2001'><p>The UK earnings equation data from Pesaran et al. (2001)</p></a></li>
<li><a href='#recm'><p>Restricted ECM regression</p></a></li>
<li><a href='#t_bounds_sim'><p>Critical value bounds stochastic simulation for t-bounds test for no</p>
cointegration</a></li>
<li><a href='#to_lm'><p>Convert dynlm model (ardl, uecm, recm) to lm model</p></a></li>
<li><a href='#uecm'><p>Unrestricted ECM regression</p></a></li>
<li><a href='#vcov_custom'><p>Variance-Covariance matrix of a regression</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>ARDL, ECM and Bounds-Test for Cointegration</td>
</tr>
<tr>
<td>Description:</td>
<td>Creates complex autoregressive distributed lag (ARDL) models and 
    constructs the underlying unrestricted and restricted error correction 
    model (ECM) automatically, just by providing the order. It also performs
    the bounds-test for cointegration as described in Pesaran et al. (2001) 
    &lt;<a href="https://doi.org/10.1002%2Fjae.616">doi:10.1002/jae.616</a>&gt; and provides the multipliers and the cointegrating
    equation. The validity and the accuracy of this package have been verified 
    by successfully replicating the results of Pesaran et al. (2001) in 
    Natsiopoulos and Tzeremes (2022) &lt;<a href="https://doi.org/10.1002%2Fjae.2919">doi:10.1002/jae.2919</a>&gt;.</td>
</tr>
<tr>
<td>Version:</td>
<td>0.2.4</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/Natsiopoulos/ARDL/issues">https://github.com/Natsiopoulos/ARDL/issues</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/Natsiopoulos/ARDL">https://github.com/Natsiopoulos/ARDL</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>strucchange, tseries, qpcR, sandwich, testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>aod, dplyr, dynlm, gridExtra, ggplot2, lmtest, msm, stringr,
zoo</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-08-20 09:29:37 UTC; axter</td>
</tr>
<tr>
<td>Author:</td>
<td>Kleanthis Natsiopoulos
    <a href="https://orcid.org/0000-0003-1180-2984"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre],
  Nickolaos Tzeremes
    <a href="https://orcid.org/0000-0002-6938-3404"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Kleanthis Natsiopoulos &lt;klnatsio@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-08-21 08:02:41 UTC</td>
</tr>
</table>
<hr>
<h2 id='ARDL-package'>ARDL: ARDL, ECM and Bounds-Test for Cointegration</h2><span id='topic+ARDL'></span><span id='topic+ARDL-package'></span>

<h3>Description</h3>

<p><img src="../help/figures/logo.png" style='float: right' alt='logo' width='120' />
</p>
<p>Creates complex autoregressive distributed lag (ARDL) models and constructs the underlying unrestricted and restricted error correction model (ECM) automatically, just by providing the order. It also performs the bounds-test for cointegration as described in Pesaran et al. (2001) <a href="https://doi.org/10.1002/jae.616">doi:10.1002/jae.616</a> and provides the multipliers and the cointegrating equation. The validity and the accuracy of this package have been verified by successfully replicating the results of Pesaran et al. (2001) in Natsiopoulos and Tzeremes (2022) <a href="https://doi.org/10.1002/jae.2919">doi:10.1002/jae.2919</a>.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Kleanthis Natsiopoulos <a href="mailto:klnatsio@gmail.com">klnatsio@gmail.com</a> (<a href="https://orcid.org/0000-0003-1180-2984">ORCID</a>)
</p>
<p>Authors:
</p>

<ul>
<li><p> Nickolaos Tzeremes <a href="mailto:bus9nt@econ.uth.gr">bus9nt@econ.uth.gr</a> (<a href="https://orcid.org/0000-0002-6938-3404">ORCID</a>)
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/Natsiopoulos/ARDL">https://github.com/Natsiopoulos/ARDL</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/Natsiopoulos/ARDL/issues">https://github.com/Natsiopoulos/ARDL/issues</a>
</p>
</li></ul>


<hr>
<h2 id='ardl'>ARDL model regression</h2><span id='topic+ardl'></span><span id='topic+ardl.uecm'></span><span id='topic+ardl.default'></span>

<h3>Description</h3>

<p>A simple way to construct complex ARDL specifications providing just the
model order additional to the model formula. It uses
<code><a href="dynlm.html#topic+dynlm">dynlm</a></code> under the hood. <code>ardl</code> is a generic function
and the default method constructs an 'ardl' model while the other method
takes a model of <code><a href="base.html#topic+class">class</a></code> 'uecm' and converts in into an
'ardl'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ardl(...)

## S3 method for class 'uecm'
ardl(object, ...)

## Default S3 method:
ardl(formula, data, order, start = NULL, end = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ardl_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to the low level regression
fitting functions.</p>
</td></tr>
<tr><td><code id="ardl_+3A_object">object</code></td>
<td>
<p>An object of <code><a href="base.html#topic+class">class</a></code> 'uecm'.</p>
</td></tr>
<tr><td><code id="ardl_+3A_formula">formula</code></td>
<td>
<p>A &quot;formula&quot; describing the linear model. Details for model
specification are given under 'Details'.</p>
</td></tr>
<tr><td><code id="ardl_+3A_data">data</code></td>
<td>
<p>A time series object (e.g., &quot;ts&quot;, &quot;zoo&quot; or &quot;zooreg&quot;) or a data
frame containing the variables in the model. In the case of a data frame,
it is coerced into a <code><a href="stats.html#topic+ts">ts</a></code> object with <code>start = 1</code>,
<code>end = nrow(data)</code> and <code>frequency = 1</code>. If not found in data, the
variables are NOT taken from any environment.</p>
</td></tr>
<tr><td><code id="ardl_+3A_order">order</code></td>
<td>
<p>A specification of the order of the ARDL model. A numeric vector
of the same length as the total number of variables (excluding the fixed
ones, see 'Details'). It should only contain positive integers or 0. An
integer could be provided if all variables are of the same order.</p>
</td></tr>
<tr><td><code id="ardl_+3A_start">start</code></td>
<td>
<p>Start of the time period which should be used for fitting the
model.</p>
</td></tr>
<tr><td><code id="ardl_+3A_end">end</code></td>
<td>
<p>End of the time period which should be used for fitting the model.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>formula</code> should contain only variables that exist in the data
provided through <code>data</code> plus some additional functions supported by
<code><a href="dynlm.html#topic+dynlm">dynlm</a></code> (i.e., <code>trend()</code>).
</p>
<p>You can also specify fixed variables that are not supposed to be lagged (e.g.
dummies etc.) simply by placing them after <code>|</code>. For example, <code>y ~
x1 + x2 | z1 + z2</code> where <code>z1</code> and <code>z2</code> are the fixed variables and
should not be considered in <code>order</code>. Note that the <code>|</code> notion
should not be confused with the same notion in <code>dynlm</code> where it
introduces instrumental variables.
</p>


<h3>Value</h3>

<p><code>ardl</code> returns an object of <code><a href="base.html#topic+class">class</a></code>
<code>c("dynlm", "lm", "ardl")</code>. In addition, attributes 'order', 'data',
'parsed_formula' and 'full_formula' are provided.
</p>


<h3>Mathematical Formula</h3>

<p>The general form of an <code class="reqn">ARDL(p,q_{1},\dots,q_{k})</code> is:
</p>
<p style="text-align: center;"><code class="reqn">y_{t} = c_{0} + c_{1}t + \sum_{i=1}^{p}b_{y,i}y_{t-i} +
\sum_{j=1}^{k}\sum_{l=0}^{q_{j}}b_{j,l}x_{j,t-l} + \epsilon_{t}</code>
</p>



<h3>Author(s)</h3>

<p>Kleanthis Natsiopoulos, <a href="mailto:klnatsio@gmail.com">klnatsio@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+uecm">uecm</a></code>, <code><a href="#topic+recm">recm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(denmark)

## Estimate an ARDL(3,1,3,2) model -------------------------------------

ardl_3132 &lt;- ardl(LRM ~ LRY + IBO + IDE, data = denmark, order = c(3,1,3,2))
summary(ardl_3132)

## Add dummies or other variables that should stay fixed ---------------

d_74Q1_75Q3 &lt;- ifelse(time(denmark) &gt;= 1974 &amp; time(denmark) &lt;= 1975.5, 1, 0)

# the date can also be setted as below
d_74Q1_75Q3_ &lt;- ifelse(time(denmark) &gt;= "1974 Q1" &amp; time(denmark) &lt;= "1975 Q3", 1, 0)
identical(d_74Q1_75Q3, d_74Q1_75Q3_)
den &lt;- cbind(denmark, d_74Q1_75Q3)
ardl_3132_d &lt;- ardl(LRM ~ LRY + IBO + IDE | d_74Q1_75Q3,
                    data = den, order = c(3,1,3,2))
summary(ardl_3132_d)
compare &lt;- data.frame(AIC = c(AIC(ardl_3132), AIC(ardl_3132_d)),
                      BIC = c(BIC(ardl_3132), BIC(ardl_3132_d)))
rownames(compare) &lt;- c("no dummy", "with dummy")
compare

## Estimate an ARDL(3,1,3,2) model with a linear trend -----------------

ardl_3132_tr &lt;- ardl(LRM ~ LRY + IBO + IDE + trend(LRM),
                     data = denmark, order = c(3,1,3,2))

# Alternative time trend specifications:
# time(LRM)                 1974 + (0, 1, ..., 55)/4 time(data)
# trend(LRM)                (1, 2, ..., 55)/4        (1:n)/freq
# trend(LRM, scale = FALSE) (1, 2, ..., 55)          1:n

## Subsample ARDL regression (start after 1975 Q4) ---------------------

ardl_3132_sub &lt;- ardl(LRM ~ LRY + IBO + IDE, data = denmark,
                      order = c(3,1,3,2), start = "1975 Q4")

# the date can also be setted as below
ardl_3132_sub2 &lt;- ardl(LRM ~ LRY + IBO + IDE, data = denmark,
                       order = c(3,1,3,2), start = c(1975,4))
identical(ardl_3132_sub, ardl_3132_sub2)
summary(ardl_3132_sub)

## Ease of use ---------------------------------------------------------

# The model specification of the ardl_3132 model can be created as easy as order=c(3,1,3,2)
# or else, it could be done using the dynlm package as:
library(dynlm)
m &lt;- dynlm(LRM ~ L(LRM, 1) + L(LRM, 2) + L(LRM, 3) + LRY + L(LRY, 1) + IBO + L(IBO, 1) +
           L(IBO, 2) + L(IBO, 3) + IDE + L(IDE, 1) + L(IDE, 2), data = denmark)
identical(m$coefficients, ardl_3132$coefficients)

# The full formula can be extracted from the ARDL model, and this is equal to
ardl_3132$full_formula
m2 &lt;- dynlm(ardl_3132$full_formula, data = ardl_3132$data)
identical(m$coefficients, m2$coefficients)

## Post-estimation testing ---------------------------------------------

# See examples in the help file of the uecm() function

</code></pre>

<hr>
<h2 id='auto_ardl'>Automatic ARDL model selection</h2><span id='topic+auto_ardl'></span>

<h3>Description</h3>

<p>It searches for the best ARDL order specification, according to the selected
criterion, taking into account the constraints provided.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>auto_ardl(
  formula,
  data,
  max_order,
  fixed_order = -1,
  starting_order = NULL,
  selection = "AIC",
  selection_minmax = c("min", "max"),
  grid = FALSE,
  search_type = c("horizontal", "vertical"),
  start = NULL,
  end = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="auto_ardl_+3A_formula">formula</code></td>
<td>
<p>A &quot;formula&quot; describing the linear model. Details for model
specification are given under 'Details' in the help file of the
<code><a href="#topic+ardl">ardl</a></code> function.</p>
</td></tr>
<tr><td><code id="auto_ardl_+3A_data">data</code></td>
<td>
<p>A time series object (e.g., &quot;ts&quot;, &quot;zoo&quot; or &quot;zooreg&quot;) or a data
frame containing the variables in the model. In the case of a data frame,
it is coerced into a <code><a href="stats.html#topic+ts">ts</a></code> object with <code>start = 1</code>,
<code>end = nrow(data)</code> and <code>frequency = 1</code>. If not found in data, the
variables are NOT taken from any environment.</p>
</td></tr>
<tr><td><code id="auto_ardl_+3A_max_order">max_order</code></td>
<td>
<p>It sets the maximum order for each variable where the search
is taking place. A numeric vector of the same length as the total number of
variables (excluding the fixed ones, see 'Details' in the help file of the
<code><a href="#topic+ardl">ardl</a></code> function). It should only contain positive integers. An
integer could be provided if the maximum order for all variables is the
same.</p>
</td></tr>
<tr><td><code id="auto_ardl_+3A_fixed_order">fixed_order</code></td>
<td>
<p>It allows setting a fixed order for some variables. The
algorithm will not search for any other order than this. A numeric vector
of the same length as the total number of variables (excluding the fixed
ones). It should contain positive integers or 0 to set as a constraint. A
-1 should be provided for any variable that should not be constrained.
<code>fixed_order</code> overrides the corresponding <code>max_order</code> and
<code>starting_order</code>.</p>
</td></tr>
<tr><td><code id="auto_ardl_+3A_starting_order">starting_order</code></td>
<td>
<p>Specifies the order for each variable from which each
search will start. It is a numeric vector of the same length as the total
number of variables (excluding the fixed ones). It should contain positive
integers or 0 or only one integer could be provided if the starting order
for all variables is the same. Default is set to NULL. If unspecified
(<code>NULL</code>) and <code>grid = FALSE</code>, then all possible <code class="reqn">ARDL(p)</code>
models are calculated (constraints are taken into account), where <code class="reqn">p</code>
is the minimum value in <code>max_order</code>. Note that where
<code>starting_order</code> is provided, its first element will be the minimum
value of <code class="reqn">p</code> that the searching algorithm will consider (think of it like
a 'minimum p order' restriction) (see 'Searching algorithm' below). If
<code>grid = TRUE</code>, only the first argument (<code class="reqn">p</code>) will have an effect.</p>
</td></tr>
<tr><td><code id="auto_ardl_+3A_selection">selection</code></td>
<td>
<p>A character string specifying the selection criterion
according to which the candidate models will be ranked. Default is
<code><a href="stats.html#topic+AIC">AIC</a></code>. Any other selection criterion can be used (a user
specified or a function from another package) as long as it can be applied
as <code>selection(model)</code>. The preferred model is the one with the smaller
value of the selection criterion. If the selection criterion works the
other way around (the bigger the better), <code>selection_minmax = "max"</code>
should also be supplied (see 'Examples' below).</p>
</td></tr>
<tr><td><code id="auto_ardl_+3A_selection_minmax">selection_minmax</code></td>
<td>
<p>A character string that indicates whether the
criterion in <code>selection</code> is supposed to be minimized (default) or
maximized.</p>
</td></tr>
<tr><td><code id="auto_ardl_+3A_grid">grid</code></td>
<td>
<p>If <code>FALSE</code> (default), the stepwise searching regression
algorithm will search for the best model by adding and subtracting terms
corresponding to different ARDL orders. If <code>TRUE</code>, the whole set of
all possible ARDL models (accounting for constraints) will be evaluated.
Note that this method can be very time-consuming in case that
<code>max_order</code> is big and there are many independent variables that
create a very big number of possible combinations.</p>
</td></tr>
<tr><td><code id="auto_ardl_+3A_search_type">search_type</code></td>
<td>
<p>A character string describing the search type. If
&quot;horizontal&quot; (default), the searching algorithm increases or decreases by 1
the order of each variable in each iteration. When the order of the last
variable has been accessed, it begins again from the first variable until
it converges. If &quot;vertical&quot;, the searching algorithm increases or decreases
by 1 the order of a variable until it converges. Then it continues the same
for the next variable. The two options result to very similar top orders.
The default (&quot;horizontal&quot;), sometimes is a little more accurate, but the
&quot;vertical&quot; is almost 2 times faster. Not applicable if <code>grid = TRUE</code>.</p>
</td></tr>
<tr><td><code id="auto_ardl_+3A_start">start</code></td>
<td>
<p>Start of the time period which should be used for fitting the
model.</p>
</td></tr>
<tr><td><code id="auto_ardl_+3A_end">end</code></td>
<td>
<p>End of the time period which should be used for fitting the model.</p>
</td></tr>
<tr><td><code id="auto_ardl_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to the low level regression
fitting functions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>auto_ardl</code> returns a list which contains:
</p>
<table role = "presentation">
<tr><td><code>best_model</code></td>
<td>
<p>An object of class <code>c("dynlm", "lm", "ardl")</code></p>
</td></tr>
<tr><td><code>best_order</code></td>
<td>
<p>A numeric vector with the order of the best model selected</p>
</td></tr>
<tr><td><code>top_orders</code></td>
<td>
<p>A data.frame with the orders of the top 20 models</p>
</td></tr>
</table>


<h3>Searching algorithm</h3>

<p>The algorithm performs the optimization process
starting from multiple starting points concerning the autoregressive order
<code class="reqn">p</code>. The searching algorithm will perform a complete search, each time
starting from a different starting order. These orders are presented in the
tables below, for <code>grid = FALSE</code> and different values of
<code>starting_order</code>.
</p>
<p><code>starting_order = NULL</code>:
</p>

<table>
<tr>
 <td style="text-align: center;">
  ARDL(p) </td><td style="text-align: center;"> -&gt; </td><td style="text-align: center;"> p </td><td style="text-align: center;"> q1 </td><td style="text-align: center;"> q2 </td><td style="text-align: center;"> ... </td><td style="text-align: center;"> qk</td>
</tr>
<tr>
 <td style="text-align: center;">
  ARDL(1) </td><td style="text-align: center;"> -&gt; </td><td style="text-align: center;"> 1 </td><td style="text-align: center;"> 1 </td><td style="text-align: center;"> 1 </td><td style="text-align: center;"> ... </td><td style="text-align: center;"> 1</td>
</tr>
<tr>
 <td style="text-align: center;">
  ARDL(2) </td><td style="text-align: center;"> -&gt; </td><td style="text-align: center;"> 2 </td><td style="text-align: center;"> 2 </td><td style="text-align: center;"> 2 </td><td style="text-align: center;"> ... </td><td style="text-align: center;"> 2</td>
</tr>
<tr>
 <td style="text-align: center;">
  : </td><td style="text-align: center;"> -&gt; </td><td style="text-align: center;"> : </td><td style="text-align: center;"> : </td><td style="text-align: center;"> : </td><td style="text-align: center;"> : </td><td style="text-align: center;"> :</td>
</tr>
<tr>
 <td style="text-align: center;">
  ARDL(P) </td><td style="text-align: center;"> -&gt; </td><td style="text-align: center;"> P </td><td style="text-align: center;"> P </td><td style="text-align: center;"> P </td><td style="text-align: center;"> ... </td><td style="text-align: center;"> P
  </td>
</tr>

</table>

<p><code>starting_order = c(3, 0, 1, 2)</code>:
</p>

<table>
<tr>
 <td style="text-align: center;">
  p </td><td style="text-align: center;"> q1 </td><td style="text-align: center;"> q2 </td><td style="text-align: center;"> q3</td>
</tr>
<tr>
 <td style="text-align: center;">
  3 </td><td style="text-align: center;"> 0 </td><td style="text-align: center;"> 1 </td><td style="text-align: center;"> 2</td>
</tr>
<tr>
 <td style="text-align: center;">
  4 </td><td style="text-align: center;"> 0 </td><td style="text-align: center;"> 1 </td><td style="text-align: center;"> 2</td>
</tr>
<tr>
 <td style="text-align: center;">
  : </td><td style="text-align: center;"> : </td><td style="text-align: center;"> : </td><td style="text-align: center;"> :</td>
</tr>
<tr>
 <td style="text-align: center;">
  P </td><td style="text-align: center;"> 0 </td><td style="text-align: center;"> 1 </td><td style="text-align: center;"> 2
  </td>
</tr>

</table>



<h3>Author(s)</h3>

<p>Kleanthis Natsiopoulos, <a href="mailto:klnatsio@gmail.com">klnatsio@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ardl">ardl</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(denmark)

## Find the best ARDL order --------------------------------------------

# Up to 5 for the autoregressive order (p) and 4 for the rest (q1, q2, q3)

# Using the defaults search_type = "horizontal", grid = FALSE and selection = "AIC"
# ("Not run" indications only for testing purposes)
## Not run: 
model1 &lt;- auto_ardl(LRM ~ LRY + IBO + IDE, data = denmark,
                    max_order = c(5,4,4,4))
model1$top_orders

## Same, with search_type = "vertical" -------------------------------

model1_h &lt;- auto_ardl(LRM ~ LRY + IBO + IDE, data = denmark,
                      max_order = c(5,4,4,4), search_type = "vertical")
model1_h$top_orders

## Find the global optimum ARDL order ----------------------------------

# It may take more than 10 seconds
model_grid &lt;- auto_ardl(LRM ~ LRY + IBO + IDE, data = denmark,
                        max_order = c(5,4,4,4), grid = TRUE)

## Different selection criteria ----------------------------------------

# Using BIC as selection criterion instead of AIC
model1_b &lt;- auto_ardl(LRM ~ LRY + IBO + IDE, data = denmark,
                      max_order = c(5,4,4,4), selection = "BIC")
model1_b$top_orders

# Using other criteria like adjusted R squared (the bigger the better)
adjr2 &lt;- function(x) { summary(x)$adj.r.squared }
model1_adjr2 &lt;- auto_ardl(LRM ~ LRY + IBO + IDE, data = denmark,
                           max_order = c(5,4,4,4), selection = "adjr2",
                           selection_minmax = "max")
model1_adjr2$top_orders

# Using functions from other packages as selection criteria
if (requireNamespace("qpcR", quietly = TRUE)) {

library(qpcR)
model1_aicc &lt;- auto_ardl(LRM ~ LRY + IBO + IDE, data = denmark,
                          max_order = c(5,4,4,4), selection = "AICc")
model1_aicc$top_orders
adjr2 &lt;- function(x){ Rsq.ad(x) }
model1_adjr2 &lt;- auto_ardl(LRM ~ LRY + IBO + IDE, data = denmark,
                           max_order = c(5,4,4,4), selection = "adjr2",
                           selection_minmax = "max")
model1_adjr2$top_orders

## DIfferent starting order --------------------------------------------

# The searching algorithm will start from the following starting orders:
# p q1 q2 q3
# 1 1  3  2
# 2 1  3  2
# 3 1  3  2
# 4 1  3  2
# 5 1  3  2

model1_so &lt;- auto_ardl(LRM ~ LRY + IBO + IDE, data = denmark,
                        max_order = c(5,4,4,4), starting_order = c(1,1,3,2))

# Starting from p=3 (don't search for p=1 and p=2)
# Starting orders:
# p q1 q2 q3
# 3 1  3  2
# 4 1  3  2
# 5 1  3  2

model1_so_3 &lt;- auto_ardl(LRM ~ LRY + IBO + IDE, data = denmark,
                        max_order = c(5,4,4,4), starting_order = c(3,1,3,2))

# If starting_order = NULL, the starting orders for each iteration will be:
# p q1 q2 q3
# 1 1  1  1
# 2 2  2  2
# 3 3  3  3
# 4 4  4  4
# 5 5  5  5
}

## Add constraints -----------------------------------------------------

# Restrict only the order of IBO to be 2
model1_ibo2 &lt;- auto_ardl(LRM ~ LRY + IBO + IDE, data = denmark,
                        max_order = c(5,4,4,4), fixed_order = c(-1,-1,2,-1))
model1_ibo2$top_orders

# Restrict the order of LRM to be 3 and the order of IBO to be 2
model1_lrm3_ibo2 &lt;- auto_ardl(LRM ~ LRY + IBO + IDE, data = denmark,
                        max_order = c(5,4,4,4), fixed_order = c(3,-1,2,-1))
model1_lrm3_ibo2$top_orders

## Set the starting date for the regression (data starts at "1974 Q1") -

# Set regression starting date to "1976 Q1"
model1_76q1 &lt;- auto_ardl(LRM ~ LRY + IBO + IDE, data = denmark,
                        max_order = c(5,4,4,4), start = "1976 Q1")
start(model1_76q1$best_model)

## End(Not run)
</code></pre>

<hr>
<h2 id='bounds_f_test'>Bounds Wald-test for no cointegration</h2><span id='topic+bounds_f_test'></span>

<h3>Description</h3>

<p><code>bounds_f_test</code> performs the Wald bounds-test for no cointegration
<cite>Pesaran et al. (2001)</cite>. It is a Wald test on the parameters of a UECM
(Unrestricted Error Correction Model) expressed either as a Chisq-statistic
or as an F-statistic.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bounds_f_test(
  object,
  case,
  alpha = NULL,
  pvalue = TRUE,
  exact = FALSE,
  R = 40000,
  test = c("F", "Chisq"),
  vcov_matrix = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bounds_f_test_+3A_object">object</code></td>
<td>
<p>An object of <code><a href="base.html#topic+class">class</a></code> 'ardl' or 'uecm'.</p>
</td></tr>
<tr><td><code id="bounds_f_test_+3A_case">case</code></td>
<td>
<p>An integer from 1-5 or a character string specifying whether the
'intercept' and/or the 'trend' have to participate in the short-run or the
long-run relationship (cointegrating equation) (see section 'Cases' below).</p>
</td></tr>
<tr><td><code id="bounds_f_test_+3A_alpha">alpha</code></td>
<td>
<p>A numeric value between 0 and 1 indicating the significance
level of the critical value bounds. If <code>NULL</code> (default), no critical
value bounds for a specific level of significance are provide, only the
p-value. See section 'alpha, bounds and p-value' below for details.</p>
</td></tr>
<tr><td><code id="bounds_f_test_+3A_pvalue">pvalue</code></td>
<td>
<p>A logical indicating whether you want the p-value to be
provided. The default is <code>TRUE</code>. See section 'alpha, bounds and
p-value' below for details.</p>
</td></tr>
<tr><td><code id="bounds_f_test_+3A_exact">exact</code></td>
<td>
<p>A logical indicating whether you want asymptotic (T = 1000) or
exact sample size critical value bounds and p-value. The default is
<code>FALSE</code> for asymptotic. See section 'alpha, bounds and p-value' below
for details.</p>
</td></tr>
<tr><td><code id="bounds_f_test_+3A_r">R</code></td>
<td>
<p>An integer indicating how many iterations will be used if
<code>exact = TRUE</code>. Default is 40000.</p>
</td></tr>
<tr><td><code id="bounds_f_test_+3A_test">test</code></td>
<td>
<p>A character vector indicating whether you want the Wald test to
be expressed as 'F' or as 'Chisq' statistic. Default is &quot;F&quot;.</p>
</td></tr>
<tr><td><code id="bounds_f_test_+3A_vcov_matrix">vcov_matrix</code></td>
<td>
<p>The estimated covariance matrix of the random variable
that the test uses to estimate the test statistic. The default is
<code>vcov(object)</code> (when <code>vcov_matrix = NULL</code>), but other estimations
of the covariance matrix of the regression's estimated coefficients can
also be used (e.g., using <code><a href="sandwich.html#topic+vcovHC">vcovHC</a></code> or
<code><a href="sandwich.html#topic+vcovHAC">vcovHAC</a></code>). Only applicable if the input object is of
class &quot;uecm&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with class &quot;htest&quot; containing the following components:
</p>
<table role = "presentation">
<tr><td><code>method</code></td>
<td>
<p>a character string indicating what type of test was
performed.</p>
</td></tr>
<tr><td><code>alternative</code></td>
<td>
<p>a character string describing the alternative
hypothesis.</p>
</td></tr>
<tr><td><code>statistic</code></td>
<td>
<p>the value of the test statistic.</p>
</td></tr>
<tr><td><code>null.value</code></td>
<td>
<p>the value of the population parameters <code>k</code>
(the number of independent variables) and <code>T</code> (the number of
observations) specified by the null hypothesis.</p>
</td></tr>
<tr><td><code>data.name</code></td>
<td>
<p>a character string giving the name(s) of the data.</p>
</td></tr>
<tr><td><code>parameters</code></td>
<td>
<p>numeric vector containing the critical value
bounds.</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>the p-value of the test.</p>
</td></tr>
<tr><td><code>PSS2001parameters</code></td>
<td>
<p>numeric vector containing the critical
value bounds as presented by <cite>Pesaran et al. (2001)</cite>. See section
'alpha, bounds and p-value' below for details.</p>
</td></tr>
<tr><td><code>tab</code></td>
<td>
<p>data.frame containing the statistic, the critical value
bounds, the alpha level of significance and the p-value.</p>
</td></tr>
</table>


<h3>Hypothesis testing</h3>

<p style="text-align: center;"><code class="reqn">\Delta y_{t} = c_{0} + c_{1}t +
  \pi_{y}y_{t-1} + \sum_{j=1}^{k}\pi_{j}x_{j,t-1} +
  \sum_{i=1}^{p-1}\psi_{y,i}\Delta y_{t-i} +
  \sum_{j=1}^{k}\sum_{l=1}^{q_{j}-1} \psi_{j,l}\Delta x_{j,t-l} +
  \sum_{j=1}^{k}\omega_{j}\Delta x_{j,t} + \epsilon_{t}</code>
</p>


<dl>
<dt>Cases 1, 3, 5:</dt><dd></dd>
</dl>

<p style="text-align: center;"><code class="reqn">\mathbf{H_{0}:} \pi_{y} = \pi_{1} = \dots = \pi_{k} = 0</code>
</p>

<p style="text-align: center;"><code class="reqn">\mathbf{H_{1}:} \pi_{y} \neq \pi_{1} \neq \dots \neq \pi_{k} \neq 0</code>
</p>


<dl>
<dt>Case 2:</dt><dd></dd>
</dl>

<p style="text-align: center;"><code class="reqn">\mathbf{H_{0}:} \pi_{y} = \pi_{1} = \dots = \pi_{k} = c_{0} = 0</code>
</p>

<p style="text-align: center;"><code class="reqn">\mathbf{H_{1}:} \pi_{y} \neq \pi_{1} \neq \dots \neq \pi_{k} \neq c_{0} \neq 0</code>
</p>


<dl>
<dt>Case 4:</dt><dd></dd>
</dl>

<p style="text-align: center;"><code class="reqn">\mathbf{H_{0}:} \pi_{y} = \pi_{1} = \dots = \pi_{k} = c_{1} = 0</code>
</p>

<p style="text-align: center;"><code class="reqn">\mathbf{H_{1}:} \pi_{y} \neq \pi_{1} \neq \dots \neq \pi_{k} \neq c_{1} \neq 0</code>
</p>



<h3>alpha, bounds and p-value</h3>

<p>In this section it is explained how the
critical value bounds and p-values are obtained.
</p>

<ul>
<li><p> If <code>exact = FALSE</code>, then the asymptotic (T = 1000) critical
value bounds and p-value are provided.
</p>
</li>
<li><p> Only the asymptotic critical value bounds and p-values, and only
for k &lt;= 10 are precalculated, everything else has to be computed.
</p>
</li>
<li><p> Precalculated critical value bounds and p-values were simulated
using <code>set.seed(2020)</code> and <code>R = 70000</code>.
</p>
</li>
<li><p> Precalculated critical value bounds exist only for <code>alpha</code>
being one of the 0.005, 0.01, 0.025, 0.05, 0.075, 0.1, 0.15 or 0.2,
everything else has to be computed.
</p>
</li>
<li><p> If <code>alpha</code> is one of the 0.1, 0.05, 0.025 or 0.01 (and
<code>exact = FALSE</code> and k &lt;= 10), <code>PSS2001parameters</code> shows
the critical value bounds presented in <cite>Pesaran et al. (2001)</cite>
(less precise).
</p>
</li></ul>



<h3>Cases</h3>

<p>According to <cite>Pesaran et al. (2001)</cite>, we distinguish the
long-run relationship (cointegrating equation) (and thus the bounds-test and
the Restricted ECMs) between 5 different cases. These differ in terms of
whether the 'intercept' and/or the 'trend' are restricted to participate in
the long-run relationship or they are unrestricted and so they participate in
the short-run relationship.
</p>

<dl>
<dt>Case 1:</dt><dd>
<ul>
<li><p> No <em>intercept</em> and no <em>trend</em>.
</p>
</li>
<li> <p><code>case</code> inputs: 1 or &quot;n&quot; where &quot;n&quot; stands for none.</p>
</li></ul>
</dd>
<dt>Case 2:</dt><dd>
<ul>
<li><p> Restricted <em>intercept</em> and no <em>trend</em>.
</p>
</li>
<li> <p><code>case</code> inputs: 2 or &quot;rc&quot; where &quot;rc&quot; stands for restricted
constant.</p>
</li></ul>
</dd>
<dt>Case 3:</dt><dd>
<ul>
<li><p> Unrestricted <em>intercept</em> and no <em>trend</em>.
</p>
</li>
<li> <p><code>case</code> inputs: 3 or &quot;uc&quot; where &quot;uc&quot; stands for unrestricted
constant.</p>
</li></ul>
</dd>
<dt>Case 4:</dt><dd>
<ul>
<li><p> Unrestricted <em>intercept</em> and restricted <em>trend</em>.
</p>
</li>
<li> <p><code>case</code> inputs: 4 or &quot;ucrt&quot; where &quot;ucrt&quot; stands for
unrestricted constant and restricted trend.</p>
</li></ul>
</dd>
<dt>Case 5:</dt><dd>
<ul>
<li><p> Unrestricted <em>intercept</em> and unrestricted <em>trend</em>.
</p>
</li>
<li> <p><code>case</code> inputs: 5 or &quot;ucut&quot; where &quot;ucut&quot; stands for
unrestricted constant and unrestricted trend.</p>
</li></ul>
</dd>
</dl>

<p>Note that you can't restrict (or leave unrestricted) a parameter that doesn't
exist in the input model. For example, you can't compute <code>recm(object,
case=3)</code> if the object is an ARDL (or UECM) model with no intercept. The same
way, you can't compute <code>bounds_f_test(object, case=5)</code> if the object is
an ARDL (or UECM) model with no linear trend.
</p>


<h3>References</h3>

<p>Pesaran, M. H., Shin, Y., &amp; Smith, R. J. (2001). Bounds
testing approaches to the analysis of level relationships. <em>Journal of
Applied Econometrics</em>, 16(3), 289-326
</p>


<h3>Author(s)</h3>

<p>Kleanthis Natsiopoulos, <a href="mailto:klnatsio@gmail.com">klnatsio@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bounds_t_test">bounds_t_test</a></code> <code><a href="#topic+ardl">ardl</a></code> <code><a href="#topic+uecm">uecm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(denmark)

## How to use cases under different models (regarding deterministic terms)

## Construct an ARDL(3,1,3,2) model with different deterministic terms -

# Without constant
ardl_3132_n &lt;- ardl(LRM ~ LRY + IBO + IDE -1, data = denmark, order = c(3,1,3,2))

# With constant
ardl_3132_c &lt;- ardl(LRM ~ LRY + IBO + IDE, data = denmark, order = c(3,1,3,2))

# With constant and trend
ardl_3132_ct &lt;- ardl(LRM ~ LRY + IBO + IDE + trend(LRM), data = denmark, order = c(3,1,3,2))

## F-bounds test for no level relationship (no cointegration) ----------

# For the model without a constant
bounds_f_test(ardl_3132_n, case = 1)
# or
bounds_f_test(ardl_3132_n, case = "n")

# For the model with a constant
# Including the constant term in the long-run relationship (restricted constant)
bounds_f_test(ardl_3132_c, case = 2)
# or
bounds_f_test(ardl_3132_c, case = "rc")

# Including the constant term in the short-run relationship (unrestricted constant)
bounds_f_test(ardl_3132_c, case = "uc")
# or
bounds_f_test(ardl_3132_c, case = 3)

# For the model with constant and trend
# Including the constant term in the short-run and the trend in the long-run relationship
# (unrestricted constant and restricted trend)
bounds_f_test(ardl_3132_ct, case = "ucrt")
# or
bounds_f_test(ardl_3132_ct, case = 4)

# For the model with constant and trend
# Including the constant term and the trend in the short-run relationship
# (unrestricted constant and unrestricted trend)
bounds_f_test(ardl_3132_ct, case = "ucut")
# or
bounds_f_test(ardl_3132_ct, case = 5)

## Note that you can't restrict a deterministic term that doesn't exist

# For example, the following tests will produce an error:
## Not run: 
bounds_f_test(ardl_3132_c, case = 1)
bounds_f_test(ardl_3132_ct, case = 3)
bounds_f_test(ardl_3132_c, case = 4)

## End(Not run)

## Asymptotic p-value and critical value bounds (assuming T = 1000) ----

# Include critical value bounds for a certain level of significance

# F-statistic is larger than the I(1) bound (for a=0.05) as expected (p-value &lt; 0.05)
bft &lt;- bounds_f_test(ardl_3132_c, case = 2, alpha = 0.05)
bft
bft$tab

# Traditional but less precise critical value bounds, as presented in Pesaran et al. (2001)
bft$PSS2001parameters

# F-statistic is slightly larger than the I(1) bound (for a=0.005)
# as p-value is slightly smaller than 0.005
bounds_f_test(ardl_3132_c, case = 2, alpha = 0.005)

## Exact sample size p-value and critical value bounds -----------------

# Setting a seed is suggested to allow the replication of results
# 'R' can be increased for more accurate resutls

# F-statistic is smaller than the I(1) bound (for a=0.01) as expected (p-value &gt; 0.01)
# Note that the exact sample p-value (0.01285) is very different than the asymptotic (0.004418)
# It can take more than 30 seconds
## Not run: 
set.seed(2020)
bounds_f_test(ardl_3132_c, case = 2, alpha = 0.01, exact = TRUE)

## End(Not run)

## "F" and "Chisq" statistics ------------------------------------------

# The p-value is the same, the test-statistic and critical value bounds are different but analogous
bounds_f_test(ardl_3132_c, case = 2, alpha = 0.01)
bounds_f_test(ardl_3132_c, case = 2, alpha = 0.01, test = "Chisq")
</code></pre>

<hr>
<h2 id='bounds_t_test'>Bounds t-test for no cointegration</h2><span id='topic+bounds_t_test'></span>

<h3>Description</h3>

<p><code>bounds_t_test</code> performs the t-bounds test for no cointegration
<cite>Pesaran et al. (2001)</cite>. It is a t-test on the parameters of a UECM
(Unrestricted Error Correction Model).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bounds_t_test(
  object,
  case,
  alpha = NULL,
  pvalue = TRUE,
  exact = FALSE,
  R = 40000,
  vcov_matrix = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bounds_t_test_+3A_object">object</code></td>
<td>
<p>An object of <code><a href="base.html#topic+class">class</a></code> 'ardl' or 'uecm'.</p>
</td></tr>
<tr><td><code id="bounds_t_test_+3A_case">case</code></td>
<td>
<p>An integer (1, 3 or 5) or a character string specifying whether
the 'intercept' and/or the 'trend' have to participate in the
short-run relationship (see section 'Cases' below). Note that the t-bounds
test can't be applied for cases 2 and 4.</p>
</td></tr>
<tr><td><code id="bounds_t_test_+3A_alpha">alpha</code></td>
<td>
<p>A numeric value between 0 and 1 indicating the significance
level of the critical value bounds. If <code>NULL</code> (default), no critical
value bounds for a specific level of significance are provide, only the
p-value. See section 'alpha, bounds and p-value' below for details.</p>
</td></tr>
<tr><td><code id="bounds_t_test_+3A_pvalue">pvalue</code></td>
<td>
<p>A logical indicating whether you want the p-value to be
provided. The default is <code>TRUE</code>. See section 'alpha, bounds and
p-value' below for details.</p>
</td></tr>
<tr><td><code id="bounds_t_test_+3A_exact">exact</code></td>
<td>
<p>A logical indicating whether you want asymptotic (T = 1000) or
exact sample size critical value bounds and p-value. The default is
<code>FALSE</code> for asymptotic. See section 'alpha, bounds and p-value' below
for details.</p>
</td></tr>
<tr><td><code id="bounds_t_test_+3A_r">R</code></td>
<td>
<p>An integer indicating how many iterations will be used if
<code>exact = TRUE</code>. Default is 40000.</p>
</td></tr>
<tr><td><code id="bounds_t_test_+3A_vcov_matrix">vcov_matrix</code></td>
<td>
<p>The estimated covariance matrix of the random variable
that the test uses to estimate the test statistic. The default is
<code>vcov(object)</code> (when <code>vcov_matrix = NULL</code>), but other estimations
of the covariance matrix of the regression's estimated coefficients can
also be used (e.g., using <code><a href="sandwich.html#topic+vcovHC">vcovHC</a></code> or
<code><a href="sandwich.html#topic+vcovHAC">vcovHAC</a></code>). Only applicable if the input object is of
class &quot;uecm&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with class &quot;htest&quot; containing the following components:
</p>
<table role = "presentation">
<tr><td><code>method</code></td>
<td>
<p>a character string indicating what type of test was
performed.</p>
</td></tr>
<tr><td><code>alternative</code></td>
<td>
<p>a character string describing the alternative
hypothesis.</p>
</td></tr>
<tr><td><code>statistic</code></td>
<td>
<p>the value of the test statistic.</p>
</td></tr>
<tr><td><code>null.value</code></td>
<td>
<p>the value of the population parameters <code>k</code>
(the number of independent variables) and <code>T</code> (the number of
observations) specified by the null hypothesis.</p>
</td></tr>
<tr><td><code>data.name</code></td>
<td>
<p>a character string giving the name(s) of the data.</p>
</td></tr>
<tr><td><code>parameters</code></td>
<td>
<p>numeric vector containing the critical value
bounds.</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>the p-value of the test.</p>
</td></tr>
<tr><td><code>PSS2001parameters</code></td>
<td>
<p>numeric vector containing the critical
value bounds as presented by <cite>Pesaran et al. (2001)</cite>. See section
'alpha, bounds and p-value' below for details.</p>
</td></tr>
<tr><td><code>tab</code></td>
<td>
<p>data.frame containing the statistic, the critical value
bounds, the alpha level of significance and the p-value.</p>
</td></tr>
</table>


<h3>Hypothesis testing</h3>

<p style="text-align: center;"><code class="reqn">\Delta y_{t} = c_{0} + c_{1}t +
  \pi_{y}y_{t-1} + \sum_{j=1}^{k}\pi_{j}x_{j,t-1} +
  \sum_{i=1}^{p-1}\psi_{y,i}\Delta y_{t-i} +
  \sum_{j=1}^{k}\sum_{l=1}^{q_{j}-1} \psi_{j,l}\Delta x_{j,t-l} +
  \sum_{j=1}^{k}\omega_{j}\Delta x_{j,t} + \epsilon_{t}</code>
</p>

<p style="text-align: center;"><code class="reqn">\mathbf{H_{0}:} \pi_{y} = 0</code>
</p>

<p style="text-align: center;"><code class="reqn">\mathbf{H_{1}:} \pi_{y} \neq 0</code>
</p>



<h3>alpha, bounds and p-value</h3>

<p>In this section it is explained how the
critical value bounds and p-values are obtained.
</p>

<ul>
<li><p> If <code>exact = FALSE</code>, then the asymptotic (T = 1000) critical
value bounds and p-value are provided.
</p>
</li>
<li><p> Only the asymptotic critical value bounds and p-values, and only
for k &lt;= 10 are precalculated, everything else has to be computed.
</p>
</li>
<li><p> Precalculated critical value bounds and p-values were simulated
using <code>set.seed(2020)</code> and <code>R = 70000</code>.
</p>
</li>
<li><p> Precalculated critical value bounds exist only for <code>alpha</code>
being one of the 0.005, 0.01, 0.025, 0.05, 0.075, 0.1, 0.15 or 0.2,
everything else has to be computed.
</p>
</li>
<li><p> If <code>alpha</code> is one of the 0.1, 0.05, 0.025 or 0.01 (and
<code>exact = FALSE</code> and k &lt;= 10), <code>PSS2001parameters</code> shows
the critical value bounds presented in <cite>Pesaran et al. (2001)</cite>
(less precise).
</p>
</li></ul>



<h3>Cases</h3>

<p>According to <cite>Pesaran et al. (2001)</cite>, we distinguish the
long-run relationship (cointegrating equation) (and thus the bounds-test and
the Restricted ECMs) between 5 different cases. These differ in terms of
whether the 'intercept' and/or the 'trend' are restricted to participate in
the long-run relationship or they are unrestricted and so they participate in
the short-run relationship.
</p>

<dl>
<dt>Case 1:</dt><dd>
<ul>
<li><p> No <em>intercept</em> and no <em>trend</em>.
</p>
</li>
<li> <p><code>case</code> inputs: 1 or &quot;n&quot; where &quot;n&quot; stands for none.</p>
</li></ul>
</dd>
<dt>Case 2:</dt><dd>
<ul>
<li><p> Restricted <em>intercept</em> and no <em>trend</em>.
</p>
</li>
<li> <p><code>case</code> inputs: 2 or &quot;rc&quot; where &quot;rc&quot; stands for restricted
constant.</p>
</li></ul>
</dd>
<dt>Case 3:</dt><dd>
<ul>
<li><p> Unrestricted <em>intercept</em> and no <em>trend</em>.
</p>
</li>
<li> <p><code>case</code> inputs: 3 or &quot;uc&quot; where &quot;uc&quot; stands for unrestricted
constant.</p>
</li></ul>
</dd>
<dt>Case 4:</dt><dd>
<ul>
<li><p> Unrestricted <em>intercept</em> and restricted <em>trend</em>.
</p>
</li>
<li> <p><code>case</code> inputs: 4 or &quot;ucrt&quot; where &quot;ucrt&quot; stands for
unrestricted constant and restricted trend.</p>
</li></ul>
</dd>
<dt>Case 5:</dt><dd>
<ul>
<li><p> Unrestricted <em>intercept</em> and unrestricted <em>trend</em>.
</p>
</li>
<li> <p><code>case</code> inputs: 5 or &quot;ucut&quot; where &quot;ucut&quot; stands for
unrestricted constant and unrestricted trend.</p>
</li></ul>
</dd>
</dl>

<p>Note that you can't restrict (or leave unrestricted) a parameter that doesn't
exist in the input model. For example, you can't compute <code>recm(object,
case=3)</code> if the object is an ARDL (or UECM) model with no intercept. The same
way, you can't compute <code>bounds_f_test(object, case=5)</code> if the object is
an ARDL (or UECM) model with no linear trend.
</p>


<h3>References</h3>

<p>Pesaran, M. H., Shin, Y., &amp; Smith, R. J. (2001). Bounds
testing approaches to the analysis of level relationships. <em>Journal of
Applied Econometrics</em>, 16(3), 289-326
</p>


<h3>Author(s)</h3>

<p>Kleanthis Natsiopoulos, <a href="mailto:klnatsio@gmail.com">klnatsio@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bounds_f_test">bounds_f_test</a></code> <code><a href="#topic+ardl">ardl</a></code> <code><a href="#topic+uecm">uecm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(denmark)

## How to use cases under different models (regarding deterministic terms)

## Construct an ARDL(3,1,3,2) model with different deterministic terms -

# Without constant
ardl_3132_n &lt;- ardl(LRM ~ LRY + IBO + IDE -1, data = denmark, order = c(3,1,3,2))

# With constant
ardl_3132_c &lt;- ardl(LRM ~ LRY + IBO + IDE, data = denmark, order = c(3,1,3,2))

# With constant and trend
ardl_3132_ct &lt;- ardl(LRM ~ LRY + IBO + IDE + trend(LRM), data = denmark, order = c(3,1,3,2))

## t-bounds test for no level relationship (no cointegration) ----------

# For the model without a constant
bounds_t_test(ardl_3132_n, case = 1)
# or
bounds_t_test(ardl_3132_n, case = "n")

# For the model with a constant
# Including the constant term in the short-run relationship (unrestricted constant)
bounds_t_test(ardl_3132_c, case = "uc")
# or
bounds_t_test(ardl_3132_c, case = 3)

# For the model with constant and trend
# Including the constant term and the trend in the short-run relationship
# (unrestricted constant and unrestricted trend)
bounds_t_test(ardl_3132_ct, case = "ucut")
# or
bounds_t_test(ardl_3132_ct, case = 5)

## Note that you can't use bounds t-test for cases 2 and 4, or use a wrong model

# For example, the following tests will produce an error:
## Not run: 
bounds_t_test(ardl_3132_n, case = 2)
bounds_t_test(ardl_3132_c, case = 4)
bounds_t_test(ardl_3132_ct, case = 3)

## End(Not run)

## Asymptotic p-value and critical value bounds (assuming T = 1000) ----

# Include critical value bounds for a certain level of significance

# t-statistic is larger than the I(1) bound (for a=0.05) as expected (p-value &lt; 0.05)
btt &lt;- bounds_t_test(ardl_3132_c, case = 3, alpha = 0.05)
btt
btt$tab

# Traditional but less precise critical value bounds, as presented in Pesaran et al. (2001)
btt$PSS2001parameters

# t-statistic doesn't exceed the I(1) bound (for a=0.005) as p-value is greater than 0.005
bounds_t_test(ardl_3132_c, case = 3, alpha = 0.005)

## Exact sample size p-value and critical value bounds -----------------

# Setting a seed is suggested to allow the replication of results
# 'R' can be increased for more accurate resutls

# t-statistic is smaller than the I(1) bound (for a=0.01) as expected (p-value &gt; 0.01)
# Note that the exact sample p-value (0.009874) is very different than the asymptotic (0.005538)
# It can take more than 90 seconds
## Not run: 
set.seed(2020)
bounds_t_test(ardl_3132_c, case = 3, alpha = 0.01, exact = TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='build_ardl_formula'>ARDL formula specification builder</h2><span id='topic+build_ardl_formula'></span>

<h3>Description</h3>

<p>It creates the ARDL specification according to the given &quot;formula&quot; and their
corresponding &quot;orders&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>build_ardl_formula(parsed_formula, order)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="build_ardl_formula_+3A_parsed_formula">parsed_formula</code></td>
<td>
<p>A list containing the formula parts as returned from
<code><a href="#topic+parse_formula">parse_formula</a></code>.</p>
</td></tr>
<tr><td><code id="build_ardl_formula_+3A_order">order</code></td>
<td>
<p>A numeric vector with the ARDL order as returned from
<code><a href="#topic+parse_order">parse_order(restriction = FALSE)</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>build_ardl_formula</code> returns a list containing the full formula
and the independent and dependent parts of the formula separated. The full
formula is ready to be used as input in the <code>dynlm</code> function.
</p>


<h3>Author(s)</h3>

<p>Kleanthis Natsiopoulos, <a href="mailto:klnatsio@gmail.com">klnatsio@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+build_uecm_formula">build_uecm_formula</a></code>, <code><a href="#topic+build_recm_formula">build_recm_formula</a></code>
</p>

<hr>
<h2 id='build_recm_formula'>RECM formula specification builder</h2><span id='topic+build_recm_formula'></span>

<h3>Description</h3>

<p>It creates the RECM (Restricted Error Correction Model) specification
according to the given &quot;formula&quot; and the corresponding &quot;order&quot; of the
underlying ARDL.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>build_recm_formula(parsed_formula, order, case)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="build_recm_formula_+3A_parsed_formula">parsed_formula</code></td>
<td>
<p>A list containing the formula parts as returned from
<code><a href="#topic+parse_formula">parse_formula</a></code>.</p>
</td></tr>
<tr><td><code id="build_recm_formula_+3A_order">order</code></td>
<td>
<p>A numeric vector with the underlying ARDL order as returned from
<code><a href="#topic+parse_order">parse_order(restriction = FALSE)</a></code>.</p>
</td></tr>
<tr><td><code id="build_recm_formula_+3A_case">case</code></td>
<td>
<p>An integer from 1-5 or a character string specifying whether the
'intercept' or the 'trend' have to participate in the 
long-run/cointegrating relationship/equation (see 'Details').</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>build_recm_formula</code> returns a list containing the full formula
and the independent and dependent parts of the formula separated. The full
formula is ready to be used as input in the <code>dynlm</code> function providing
also the 'ect' (error correction term) to the data.
</p>


<h3>Author(s)</h3>

<p>Kleanthis Natsiopoulos, <a href="mailto:klnatsio@gmail.com">klnatsio@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+build_ardl_formula">build_ardl_formula</a></code>, <code><a href="#topic+build_uecm_formula">build_uecm_formula</a></code>
</p>

<hr>
<h2 id='build_uecm_formula'>UECM formula specification builder</h2><span id='topic+build_uecm_formula'></span>

<h3>Description</h3>

<p>It creates the UECM (Unrestricted Error Correction Model) specification
according to the given &quot;formula&quot; and the corresponding &quot;order&quot; of the
underlying ARDL.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>build_uecm_formula(parsed_formula, order)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="build_uecm_formula_+3A_parsed_formula">parsed_formula</code></td>
<td>
<p>A list containing the formula parts as returned from
<code><a href="#topic+parse_formula">parse_formula</a></code>.</p>
</td></tr>
<tr><td><code id="build_uecm_formula_+3A_order">order</code></td>
<td>
<p>A numeric vector with the underlying ARDL order as returned from
<code><a href="#topic+parse_order">parse_order(restriction = FALSE)</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>build_uecm_formula</code> returns a list containing the full formula
and the independent and dependent parts of the formula separated. The full
formula is ready to be used as input in the <code>dynlm</code> function.
</p>


<h3>Author(s)</h3>

<p>Kleanthis Natsiopoulos, <a href="mailto:klnatsio@gmail.com">klnatsio@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+build_ardl_formula">build_ardl_formula</a></code>, <code><a href="#topic+build_recm_formula">build_recm_formula</a></code>
</p>

<hr>
<h2 id='coint_eq'>Cointegrating equation (long-run level relationship)</h2><span id='topic+coint_eq'></span><span id='topic+coint_eq.recm'></span><span id='topic+coint_eq.default'></span>

<h3>Description</h3>

<p>Creates the cointegrating equation (long-run level relationship) providing an
'ardl', 'uecm' or 'recm' model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coint_eq(object, case)

## S3 method for class 'recm'
coint_eq(object, ...)

## Default S3 method:
coint_eq(object, case)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="coint_eq_+3A_object">object</code></td>
<td>
<p>An object of <code><a href="base.html#topic+class">class</a></code> 'ardl', 'uecm' or
'recm'.</p>
</td></tr>
<tr><td><code id="coint_eq_+3A_case">case</code></td>
<td>
<p>An integer from 1-5 or a character string specifying whether the
'intercept' and/or the 'trend' have to participate in the long-run level
relationship (cointegrating equation) (see section 'Cases' below). If the
input object is of class 'recm', <code>case</code> is not needed as the model is
already under a certain case.</p>
</td></tr>
<tr><td><code id="coint_eq_+3A_...">...</code></td>
<td>
<p>Currently unused argument.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>coint_eq</code> returns an numeric vector containing the
cointegrating equation.
</p>


<h3>Cases</h3>

<p>According to <cite>Pesaran et al. (2001)</cite>, we distinguish the
long-run relationship (cointegrating equation) (and thus the bounds-test and
the Restricted ECMs) between 5 different cases. These differ in terms of
whether the 'intercept' and/or the 'trend' are restricted to participate in
the long-run relationship or they are unrestricted and so they participate in
the short-run relationship.
</p>

<dl>
<dt>Case 1:</dt><dd>
<ul>
<li><p> No <em>intercept</em> and no <em>trend</em>.
</p>
</li>
<li> <p><code>case</code> inputs: 1 or &quot;n&quot; where &quot;n&quot; stands for none.</p>
</li></ul>
</dd>
<dt>Case 2:</dt><dd>
<ul>
<li><p> Restricted <em>intercept</em> and no <em>trend</em>.
</p>
</li>
<li> <p><code>case</code> inputs: 2 or &quot;rc&quot; where &quot;rc&quot; stands for restricted
constant.</p>
</li></ul>
</dd>
<dt>Case 3:</dt><dd>
<ul>
<li><p> Unrestricted <em>intercept</em> and no <em>trend</em>.
</p>
</li>
<li> <p><code>case</code> inputs: 3 or &quot;uc&quot; where &quot;uc&quot; stands for unrestricted
constant.</p>
</li></ul>
</dd>
<dt>Case 4:</dt><dd>
<ul>
<li><p> Unrestricted <em>intercept</em> and restricted <em>trend</em>.
</p>
</li>
<li> <p><code>case</code> inputs: 4 or &quot;ucrt&quot; where &quot;ucrt&quot; stands for
unrestricted constant and restricted trend.</p>
</li></ul>
</dd>
<dt>Case 5:</dt><dd>
<ul>
<li><p> Unrestricted <em>intercept</em> and unrestricted <em>trend</em>.
</p>
</li>
<li> <p><code>case</code> inputs: 5 or &quot;ucut&quot; where &quot;ucut&quot; stands for
unrestricted constant and unrestricted trend.</p>
</li></ul>
</dd>
</dl>

<p>Note that you can't restrict (or leave unrestricted) a parameter that doesn't
exist in the input model. For example, you can't compute <code>recm(object,
case=3)</code> if the object is an ARDL (or UECM) model with no intercept. The same
way, you can't compute <code>bounds_f_test(object, case=5)</code> if the object is
an ARDL (or UECM) model with no linear trend.
</p>


<h3>References</h3>

<p>Pesaran, M. H., Shin, Y., &amp; Smith, R. J. (2001). Bounds
testing approaches to the analysis of level relationships. <em>Journal of
Applied Econometrics</em>, 16(3), 289-326
</p>


<h3>Author(s)</h3>

<p>Kleanthis Natsiopoulos, <a href="mailto:klnatsio@gmail.com">klnatsio@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot_lr">plot_lr</a></code> <code><a href="#topic+ardl">ardl</a></code> <code><a href="#topic+uecm">uecm</a></code> <code><a href="#topic+recm">recm</a></code>
<code><a href="#topic+bounds_f_test">bounds_f_test</a></code> <code><a href="#topic+bounds_t_test">bounds_t_test</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(denmark)
library(zoo) # for cbind.zoo()

## Estimate the Cointegrating Equation of an ARDL(3,1,3,2) model -------

# From an ARDL model (under case 2, restricted constant)
ardl_3132 &lt;- ardl(LRM ~ LRY + IBO + IDE, data = denmark, order = c(3,1,3,2))
ce2_ardl &lt;- coint_eq(ardl_3132, case = 2)

# From an UECM (under case 2, restricted constant)
uecm_3132 &lt;- uecm(ardl_3132)
ce2_uecm &lt;- coint_eq(uecm_3132, case = 2)

# From a RECM (under case 2, restricted constant)
# Notice that if a RECM has already been estimated under a certain case,
# the 'coint_eq()' can't be under different case, so no 'case' argument needed.
recm_3132 &lt;- recm(uecm_3132, case = 2)
# The RECM is already under case 2, so the 'case' argument is no needed
ce2_recm &lt;- coint_eq(recm_3132)

identical(ce2_ardl, ce2_uecm, ce2_recm)

## Check for a degenerate level relationship ---------------------------

# The bounds F-test under both cases reject the Null Hypothesis of no level relationship.
bounds_f_test(ardl_3132, case = 2)
bounds_f_test(ardl_3132, case = 3)

# The bounds t-test also rejects the NUll Hypothesis of no level relationship.
bounds_t_test(ardl_3132, case = 3)

# But when the constant enters the long-run equation (case 3)
# this becomes a degenerate relationship.
ce3_ardl &lt;- coint_eq(ardl_3132, case = 3)

plot_lr(ardl_3132, coint_eq = ce2_ardl, show.legend = TRUE)

plot_lr(ardl_3132, coint_eq = ce3_ardl, show.legend = TRUE)
plot_lr(ardl_3132, coint_eq = ce3_ardl, facets = TRUE, show.legend = TRUE)
</code></pre>

<hr>
<h2 id='delta_method'>Delta method</h2><span id='topic+delta_method'></span><span id='topic+delta_method.ardl'></span><span id='topic+delta_method.uecm'></span>

<h3>Description</h3>

<p>An internal generic function, customized for approximating the standard
errors of the estimated multipliers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>delta_method(object, vcov_matrix = NULL)

## S3 method for class 'ardl'
delta_method(object, vcov_matrix = NULL)

## S3 method for class 'uecm'
delta_method(object, vcov_matrix = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="delta_method_+3A_object">object</code></td>
<td>
<p>An object of <code><a href="base.html#topic+class">class</a></code> 'ardl' or 'uecm'.</p>
</td></tr>
<tr><td><code id="delta_method_+3A_vcov_matrix">vcov_matrix</code></td>
<td>
<p>The estimated covariance matrix of the random variable
that the transformation function uses to estimate the standard errors (and
so the t-statistics and p-values) of the multipliers. The default is
<code>vcov(object)</code> (when <code>vcov_matrix = NULL</code>), but other estimations
of the covariance matrix of the regression's estimated coefficients can
also be used (e.g., using <code><a href="sandwich.html#topic+vcovHC">vcovHC</a></code> or
<code><a href="sandwich.html#topic+vcovHAC">vcovHAC</a></code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function invokes two different <code><a href="utils.html#topic+methods">methods</a></code>, one for
objects of <code><a href="base.html#topic+class">class</a></code> 'ardl' and one for objects of
<code>class</code> 'uecm'. This is because of the different (but equivalent)
transformation functions that are used for each class/model ('ardl' and
'uecm') to estimate the multipliers.
</p>


<h3>Value</h3>

<p><code>delta_method</code> returns a numeric vector of the same length as
the number of the independent variables (excluding the fixed ones) in the
model.
</p>


<h3>Author(s)</h3>

<p>Kleanthis Natsiopoulos, <a href="mailto:klnatsio@gmail.com">klnatsio@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+multipliers">multipliers</a></code>, <code><a href="#topic+ardl">ardl</a></code>, <code><a href="#topic+uecm">uecm</a></code>
</p>

<hr>
<h2 id='denmark'>The Danish data on money income prices and interest rates</h2><span id='topic+denmark'></span>

<h3>Description</h3>

<p>This data set contains the series used by S. Johansen and K. Juselius for
estimating a money demand function of Denmark.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>denmark
</code></pre>


<h3>Format</h3>

<p>A time-series object with 55 rows and 5 variables. Time period from 1974:Q1
until 1987:Q3.
</p>

<dl>
<dt>LRM</dt><dd><p>logarithm of real money, M2</p>
</dd>
<dt>LRY</dt><dd><p>logarithm of real income</p>
</dd>
<dt>LPY</dt><dd><p>logarithm of price deflator</p>
</dd>
<dt>IBO</dt><dd><p>bond rate</p>
</dd>
<dt>IDE</dt><dd><p>bank deposit rate</p>
</dd>
</dl>



<h3>Details</h3>

<p>An object of class &quot;zooreg&quot; &quot;zoo&quot;.
</p>


<h3>Source</h3>

<p><a href="https://onlinelibrary.wiley.com/doi/10.1111/j.1468-0084.1990.mp52002003.x">https://onlinelibrary.wiley.com/doi/10.1111/j.1468-0084.1990.mp52002003.x</a>
</p>


<h3>References</h3>

<p>Johansen, S. and Juselius, K. (1990), Maximum Likelihood
Estimation and Inference on Cointegration &ndash; with Applications to the Demand
for Money, <em>Oxford Bulletin of Economics and Statistics</em>, <b>52, 2</b>,
169&ndash;210.
</p>

<hr>
<h2 id='f_bounds_sim'>Critical value bounds stochastic simulation for Wald bounds-test for no
cointegration</h2><span id='topic+f_bounds_sim'></span>

<h3>Description</h3>

<p><code>f_bounds_sim</code> simulates the critical value bounds for the  Wald
bounds-test for no cointegration <cite>Pesaran et al. (2001)</cite> expressed both
as F-statistics and as Chisq-statistics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>f_bounds_sim(case, k, alpha, T, R = 40000)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="f_bounds_sim_+3A_case">case</code></td>
<td>
<p>An integer from 1-5 specifying whether the 'intercept' and/or the
trend' have to participate in the long-run/cointegrating
relationship/equation (see section 'Cases' in <code><a href="#topic+bounds_f_test">bounds_f_test</a></code>).</p>
</td></tr>
<tr><td><code id="f_bounds_sim_+3A_k">k</code></td>
<td>
<p>The number of independent variables.</p>
</td></tr>
<tr><td><code id="f_bounds_sim_+3A_alpha">alpha</code></td>
<td>
<p>A numeric vector between 0 and 1 indicating the significance
level of the critical value bounds. Multiple values can be used.</p>
</td></tr>
<tr><td><code id="f_bounds_sim_+3A_t">T</code></td>
<td>
<p>An integer indicating the number of observations.</p>
</td></tr>
<tr><td><code id="f_bounds_sim_+3A_r">R</code></td>
<td>
<p>An integer indicating how many iterations will be used. Default is
40000.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>f_bounds_sim</code> returns a list containing two data frames. One
with the critical value bounds for the F-statistic and one with the
critical value bounds for the Chisq-statistic.
</p>


<h3>Author(s)</h3>

<p>Kleanthis Natsiopoulos, <a href="mailto:klnatsio@gmail.com">klnatsio@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+t_bounds_sim">t_bounds_sim</a></code> <code><a href="#topic+bounds_f_test">bounds_f_test</a></code>
</p>

<hr>
<h2 id='f_test_custom'>F-test of regression's overall significance</h2><span id='topic+f_test_custom'></span>

<h3>Description</h3>

<p><code>f_test_custom</code> performs an overall significance F-test on a regression.
It is used along with <code><a href="stats.html#topic+.lm.fit">.lm.fit</a></code> to get the F-statistic as
this is about 10 times faster than extracting it from a regression using
<code><a href="stats.html#topic+lm">lm</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>f_test_custom(dep_var, indep_vars, model_res, const = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="f_test_custom_+3A_dep_var">dep_var</code></td>
<td>
<p>A numeric vector or a matrix with one column representing the
dependent variable.</p>
</td></tr>
<tr><td><code id="f_test_custom_+3A_indep_vars">indep_vars</code></td>
<td>
<p>A matrix representing the independent variables.</p>
</td></tr>
<tr><td><code id="f_test_custom_+3A_model_res">model_res</code></td>
<td>
<p>A numeric vector representing the regression's residuals.</p>
</td></tr>
<tr><td><code id="f_test_custom_+3A_const">const</code></td>
<td>
<p>A logical indicating whether the constant term should be
restricted too.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>f_test_custom</code> returns a list containing the F-statistic and
the numerator's degrees of freedom.
</p>


<h3>Author(s)</h3>

<p>Kleanthis Natsiopoulos, <a href="mailto:klnatsio@gmail.com">klnatsio@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+vcov_custom">vcov_custom</a></code> <code><a href="#topic+f_bounds_sim">f_bounds_sim</a></code>
<code><a href="#topic+t_bounds_sim">t_bounds_sim</a></code>independent
</p>

<hr>
<h2 id='multipliers'>Multipliers estimation</h2><span id='topic+multipliers'></span><span id='topic+multipliers.ardl'></span><span id='topic+multipliers.uecm'></span>

<h3>Description</h3>

<p><code>multipliers</code> is a generic function used to estimate short-run (impact),
delay, interim and long-run (total) multipliers, accompanied by their
corresponding standard errors, t-statistics and p-values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>multipliers(object, type = "lr", vcov_matrix = NULL, se = FALSE)

## S3 method for class 'ardl'
multipliers(object, type = "lr", vcov_matrix = NULL, se = FALSE)

## S3 method for class 'uecm'
multipliers(object, type = "lr", vcov_matrix = NULL, se = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="multipliers_+3A_object">object</code></td>
<td>
<p>An object of <code><a href="base.html#topic+class">class</a></code> 'ardl' or 'uecm'.</p>
</td></tr>
<tr><td><code id="multipliers_+3A_type">type</code></td>
<td>
<p>A character string describing the type of multipliers. Use &quot;lr&quot;
for long-run (total) multipliers (default), &quot;sr&quot; or 0 for short-run (impact)
multipliers or an integer between 1 and 200 for delay and interim multipliers.</p>
</td></tr>
<tr><td><code id="multipliers_+3A_vcov_matrix">vcov_matrix</code></td>
<td>
<p>The estimated covariance matrix of the random variable
that the transformation function uses to estimate the standard errors (and
so the t-statistics and p-values) of the multipliers. The default is
<code>vcov(object)</code> (when <code>vcov_matrix = NULL</code>), but other estimations
of the covariance matrix of the regression's estimated coefficients can
also be used (e.g., using <code><a href="sandwich.html#topic+vcovHC">vcovHC</a></code> or
<code><a href="sandwich.html#topic+vcovHAC">vcovHAC</a></code>).</p>
</td></tr>
<tr><td><code id="multipliers_+3A_se">se</code></td>
<td>
<p>A logical indicating whether you want standard errors for delay
multipliers to be provided. The default is FALSE. Note that this parameter
does not refer to the standard errors for the long-run and short-run
multipliers, for which are always calculated. IMPORTANT: Calculating standard
errors for long periods of delays may cause your computer to run out of
memory and terminate your R session, losing important unsaved work. As a rule
of thumb, try not to exceed <code>type = 19</code> when <code>se = TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function invokes two different <code><a href="utils.html#topic+methods">methods</a></code>, one for
objects of <code><a href="base.html#topic+class">class</a></code> 'ardl' and one for objects of
<code>class</code> 'uecm'. This is because of the different (but equivalent)
transformation functions that are used for each class/model ('ardl' and
'uecm') to estimate the multipliers.
</p>
<p><code>type = 0</code> is equivalent to <code>type = "sr"</code>.
</p>
<p>Note that the interim multipliers are the cumulative sum of the delays, and
that the sum of the interim multipliers (for long enough periods) and thus
a distant enough interim multiplier match the long-run multipliers.
</p>
<p>The delay (interim) multiplier can be interpreted as the effect on the
dependent variable in period t+s, resulting from an instant (sustained) shock
to an independent variable in period t.
</p>
<p>The delta method is used for approximating the standard errors (and thus the
t-statistics and p-values) of the estimated long-run and delay multipliers.
</p>


<h3>Value</h3>

<p><code>multipliers</code> returns (for long and short run multipliers) a
data.frame containing the independent variables (including possibly
existing intercept or trend and excluding the fixed variables) and their
corresponding standard errors, t-statistics and p-values. For delay and
interim multipliers it returns a list with a data.frame for each variable,
containing the delay and interim multipliers for each period.
</p>


<h3>Mathematical Formula</h3>

<p><strong>Short-Run Multipliers:</strong>
</p>

<dl>
<dt>As derived from an ARDL:</dt><dd></dd>
</dl>

<p style="text-align: center;"><code class="reqn">\frac{\partial y_{t}}{\partial x_{j,t}} = b_{j,0} \;\;\;\;\; j \in \{1,\dots,k\}</code>
</p>


<dl>
<dt>As derived from an Unrestricted ECM:</dt><dd></dd>
</dl>

<p style="text-align: center;"><code class="reqn">\frac{\partial y_{t}}{\partial x_{j,t}} = \omega_{j} \;\;\;\;\; j \in \{1,\dots,k\}</code>
</p>


<dl>
<dt>Constant and Linear Trend:</dt><dd></dd>
</dl>

<p style="text-align: center;"><code class="reqn">c_{0}</code>
</p>

<p style="text-align: center;"><code class="reqn">c_{1}</code>
</p>

<p><strong>Delay &amp; Interim Multipliers:</strong>
</p>

<dl>
<dt>As derived from an ARDL:</dt><dd></dd>
</dl>

<p style="text-align: center;"><code class="reqn">Delay_{x_{j},s} = \frac{\partial y_{t+s}}{\partial x_{j,t}} = b_{j,s} + \sum_{i=1}^{min\{p,s\}} b_{y,i} \frac{\partial y_{t+(s-i)}}{\partial x_{j,t}} \;\;\;\;\; b_{j,s} = 0 \;\; \forall \;\; s &gt; q</code>
</p>

<p style="text-align: center;"><code class="reqn">Interim_{x_{j},s} = \sum_{i=0}^{s} Delay_{x_{j},s}</code>
</p>


<dl>
<dt>Constant and Linear Trend:</dt><dd></dd>
</dl>

<p style="text-align: center;"><code class="reqn">Delay_{intercept,s} = c_{0} + \sum_{i=1}^{min\{p,s\}} b_{y,i} Delay_{intercept,s-i} \;\;\;\;\; c_{0} = 0 \;\; \forall \;\; s \neq 0</code>
</p>

<p style="text-align: center;"><code class="reqn">Interim_{intercept,s} = \sum_{i=0}^{s} Delay_{intercept,s}</code>
</p>

<p style="text-align: center;"><code class="reqn">Delay_{trend,s} = c_{1} + \sum_{i=1}^{min\{p,s\}} b_{y,i} Delay_{trend,s-i} \;\;\;\;\; c_{1} = 0 \;\; \forall \;\; s \neq 0</code>
</p>

<p style="text-align: center;"><code class="reqn">Interim_{trend,s} = \sum_{i=0}^{s} Delay_{trend,s}</code>
</p>

<p><strong>Long-Run Multipliers:</strong>
</p>

<dl>
<dt>As derived from an ARDL:</dt><dd></dd>
</dl>

<p style="text-align: center;"><code class="reqn">\frac{\partial y_{t+\infty}}{\partial x_{j,t}} = \theta_{j} = \frac{\sum_{l=0}^{q_{j}}b_{j,l}}{1-\sum_{i=1}^{p}b_{y,i}} \;\;\;\;\; j \in \{1,\dots,k\}</code>
</p>


<dl>
<dt>Constant and Linear Trend:</dt><dd></dd>
</dl>

<p style="text-align: center;"><code class="reqn">\mu = \frac{c_{0}}{1-\sum_{i=1}^{p}b_{y,i}}</code>
</p>

<p style="text-align: center;"><code class="reqn">\delta = \frac{c_{1}}{1-\sum_{i=1}^{p}b_{y,i}}</code>
</p>


<dl>
<dt>As derived from an Unrestricted ECM:</dt><dd></dd>
</dl>

<p style="text-align: center;"><code class="reqn">\frac{\partial y_{t+\infty}}{\partial x_{j,t}} = \theta_{j} = \frac{\pi_{j}}{-\pi_{y}} \;\;\;\;\; j \in \{1,\dots,k\}</code>
</p>


<dl>
<dt>Constant and Linear Trend:</dt><dd></dd>
</dl>

<p style="text-align: center;"><code class="reqn">\mu = \frac{c_{0}}{-\pi_{y}}</code>
</p>

<p style="text-align: center;"><code class="reqn">\delta = \frac{c_{1}}{-\pi_{y}}</code>
</p>



<h3>Author(s)</h3>

<p>Kleanthis Natsiopoulos, <a href="mailto:klnatsio@gmail.com">klnatsio@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ardl">ardl</a></code>, <code><a href="#topic+uecm">uecm</a></code>, <code><a href="#topic+plot_delay">plot_delay</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(denmark)

## Estimate the long-run multipliers of an ARDL(3,1,3,2) model ---------

# From an ARDL model
ardl_3132 &lt;- ardl(LRM ~ LRY + IBO + IDE, data = denmark, order = c(3,1,3,2))
mult_ardl &lt;- multipliers(ardl_3132)
mult_ardl

# From an UECM
uecm_3132 &lt;- uecm(ardl_3132)
mult_uecm &lt;- multipliers(uecm_3132)
mult_uecm

all.equal(mult_ardl, mult_uecm)


## Estimate the short-run multipliers of an ARDL(3,1,3,2) model --------

mult_sr &lt;- multipliers(uecm_3132, type = "sr")
mult_0 &lt;- multipliers(uecm_3132, type = 0)
all.equal(mult_sr, mult_0)


## Estimate the delay &amp; interim multipliers of an ARDL(3,1,3,2) model --

mult_lr &lt;- multipliers(uecm_3132, type = "lr")
mult_inter80 &lt;- multipliers(uecm_3132, type = 80)

mult_lr
sum(mult_inter80$`(Intercept)`$Delay)
mult_inter80$`(Intercept)`$Interim[nrow(mult_inter80$`(Intercept)`)]
sum(mult_inter80$LRY$Delay)
mult_inter80$LRY$Interim[nrow(mult_inter80$LRY)]
sum(mult_inter80$IBO$Delay)
mult_inter80$IBO$Interim[nrow(mult_inter80$IBO)]
sum(mult_inter80$IDE$Delay)
mult_inter80$IDE$Interim[nrow(mult_inter80$IDE)]
plot(mult_inter80$LRY$Delay, type='l')
plot(mult_inter80$LRY$Interim, type='l')

mult_inter12 &lt;- multipliers(uecm_3132, type = 12, se = TRUE)
plot_delay(mult_inter12, interval = 0.95)
</code></pre>

<hr>
<h2 id='NT2022'>The UK earnings equation data from Natsiopoulos and Tzeremes (2022)</h2><span id='topic+NT2022'></span>

<h3>Description</h3>

<p>This data set contains the series used by Natsiopoulos and Tzeremes (2022) for re-estimating the UK earnings equation.
The clean format of the data retrieved from the Data Archive of Natsiopoulos and Tzeremes (2022).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NT2022
</code></pre>


<h3>Format</h3>

<p>A time-series object with 196 rows and 9 variables. Time period from 1971:Q1
until 2019:Q4.
</p>

<dl>
<dt>time</dt><dd><p>time variable</p>
</dd>
<dt>w</dt><dd><p>real wage</p>
</dd>
<dt>Prod</dt><dd><p>labor productivity</p>
</dd>
<dt>UR</dt><dd><p>unemployment rate</p>
</dd>
<dt>Wedge</dt><dd><p>wedge effect</p>
</dd>
<dt>Union</dt><dd><p>union power</p>
</dd>
<dt>D7475</dt><dd><p>income policies 1974:Q1-1975:Q4</p>
</dd>
<dt>D7579</dt><dd><p>income policies 1975:Q1-1979:Q4</p>
</dd>
<dt>UnionR</dt><dd><p>union membership</p>
</dd>
</dl>



<h3>Details</h3>

<p>An object of class &quot;zooreg&quot; &quot;zoo&quot;.
</p>


<h3>Source</h3>

<p><a href="http://qed.econ.queensu.ca/jae/datasets/natsiopoulos001/">http://qed.econ.queensu.ca/jae/datasets/natsiopoulos001/</a>
</p>


<h3>References</h3>

<p>Kleanthis Natsiopoulos and Nickolaos G. Tzeremes, (2022), &quot;ARDL bounds test for
Cointegration: Replicating the Pesaran et al. (2001) Results for the UK Earnings Equation Using R&quot;,
<em>Journal of Applied Econometrics</em>, <b>37, 5</b>, 1079&ndash;1090.
<a href="https://doi.org/10.1002/jae.2919">doi:10.1002/jae.2919</a>
</p>

<hr>
<h2 id='parse_case'>Case parser</h2><span id='topic+parse_case'></span>

<h3>Description</h3>

<p>It parses the 'case' and checks the integrity of the 'case' input and the
compatibility with the formula.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parse_case(parsed_formula, case)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="parse_case_+3A_parsed_formula">parsed_formula</code></td>
<td>
<p>A list containing the formula parts as returned from
<code><a href="#topic+parse_formula">parse_formula</a></code>.</p>
</td></tr>
<tr><td><code id="parse_case_+3A_case">case</code></td>
<td>
<p>An integer from 1-5 or a character string specifying whether the
'intercept' and/or the 'trend' have to participate in the short-run or the
long-run relationship (cointegrating equation) (see section 'Cases' below).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that the statistical significance of 'ect' in a RECM should not be
tested using the corresponding t-statistic (or the p-value) because it
doesn't follow a standard t-distribution. Instead, the
<code><a href="#topic+bounds_t_test">bounds_t_test</a></code> should be used.
</p>


<h3>Value</h3>

<p>An integer from 1-5 representing the case.
</p>


<h3>References</h3>

<p>Pesaran, M. H., Shin, Y., &amp; Smith, R. J. (2001). Bounds
testing approaches to the analysis of level relationships. <em>Journal of
Applied Econometrics</em>, 16(3), 289-326
</p>


<h3>Author(s)</h3>

<p>Kleanthis Natsiopoulos, <a href="mailto:klnatsio@gmail.com">klnatsio@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+parse_formula">parse_formula</a></code>
</p>

<hr>
<h2 id='parse_formula'>Formula parser</h2><span id='topic+parse_formula'></span>

<h3>Description</h3>

<p>It parses the formula and separates the dependent, independent and fixed
variables and also the constant and linear trends (if present).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parse_formula(formula, colnames_data)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="parse_formula_+3A_formula">formula</code></td>
<td>
<p>A &quot;formula&quot; describing the linear model. Details for model
specification are given under 'Details'.</p>
</td></tr>
<tr><td><code id="parse_formula_+3A_colnames_data">colnames_data</code></td>
<td>
<p>A character vector containing the colnames of the data
used in the formula (usually via <code>colnames(data)</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The notation we follow (e.g., using y, x, z, w etc.) is according to
<cite>Pesaran et al. (2001)</cite>.
</p>
<p>The <code>formula</code> should contain only variables that exist in the data
provided through <code>data</code> plus some additional functions supported by
<code><a href="dynlm.html#topic+dynlm">dynlm</a></code> (i.e., <code>trend()</code>).
</p>
<p>You can also specify fixed variables that are not supposed to be lagged (e.g.
dummies etc.) simply by placing them after <code>|</code>. For example, <code>y ~
x1 + x2 | z1 + z2</code> where <code>z1</code> and <code>z2</code> are the fixed variables and
should not be considered in <code>order</code>. Note that the <code>|</code> notion
should not be confused with the same notion in <code>dynlm</code> where it
introduces instrumental variables.
</p>


<h3>Value</h3>

<p>A list containing other lists with the names of the dependent,
independent and fixed variables, the constant and linear trends and the
number of variables in each category.
</p>


<h3>References</h3>

<p>Pesaran, M. H., Shin, Y., &amp; Smith, R. J. (2001). Bounds
testing approaches to the analysis of level relationships. <em>Journal of
Applied Econometrics</em>, 16(3), 289-326
</p>


<h3>Author(s)</h3>

<p>Kleanthis Natsiopoulos, <a href="mailto:klnatsio@gmail.com">klnatsio@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+parse_order">parse_order</a></code>
</p>

<hr>
<h2 id='parse_order'>Order parser</h2><span id='topic+parse_order'></span>

<h3>Description</h3>

<p>It parses the order and checks the integrity of the order input.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parse_order(orders, order_name, var_names, kz, restriction = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="parse_order_+3A_orders">orders</code></td>
<td>
<p>A numeric vector of the same length as the total number of
variables (excluding the fixed ones). If the input is <code>order</code> or
<code>max_order</code> it should only contain positive integers or 0. If the
input is <code>fixed_order</code> it should also contain the value '-1'
indicating that a specific order should not be fixed. An integer could be
provided if all variables are of the same order (or all '-1' in the case of
<code>fixed_order</code>).</p>
</td></tr>
<tr><td><code id="parse_order_+3A_order_name">order_name</code></td>
<td>
<p>The name of the function argument that is passed into
<code>order</code>.</p>
</td></tr>
<tr><td><code id="parse_order_+3A_var_names">var_names</code></td>
<td>
<p>The names of the variables corresponding to the orders.</p>
</td></tr>
<tr><td><code id="parse_order_+3A_kz">kz</code></td>
<td>
<p>An integer. The number of dependent and independent variables.</p>
</td></tr>
<tr><td><code id="parse_order_+3A_restriction">restriction</code></td>
<td>
<p>When the input in <code>orders</code> is either <code>order</code> or
<code>max_order</code> it should be <code>FALSE</code> (default). When the input is
<code>fixed_order</code> it should be '-1' indicating that the input in
<code>orders</code> is a restriction for the 'order' of the model (either upper
bound or fixed order).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector of the same length as the total number of variables
(excluding the fixed ones).
</p>


<h3>Author(s)</h3>

<p>Kleanthis Natsiopoulos, <a href="mailto:klnatsio@gmail.com">klnatsio@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+parse_formula">parse_formula</a></code>
</p>

<hr>
<h2 id='plot_delay'>Create plots for the delay multipliers</h2><span id='topic+plot_delay'></span>

<h3>Description</h3>

<p>Creates plots for the delay multipliers and their uncertainty intervals based
on their estimated standard errors. This is a basic
<code><a href="ggplot2.html#topic+ggplot">ggplot</a></code> with a few customizable parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_delay(
  multipliers,
  facets_ncol = 2,
  interval = FALSE,
  interval_color = "blue",
  show.legend = FALSE,
  xlab = "Period",
  ylab = "Delay",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_delay_+3A_multipliers">multipliers</code></td>
<td>
<p>A list returned from <code><a href="#topic+multipliers">multipliers</a></code>,
in which <code>type</code> is a positive integer to return delay multipliers.</p>
</td></tr>
<tr><td><code id="plot_delay_+3A_facets_ncol">facets_ncol</code></td>
<td>
<p>If a positive integer, it indicates the number of the
columns in the facet. If FALSE, each plot is created separately. The default
is 2.</p>
</td></tr>
<tr><td><code id="plot_delay_+3A_interval">interval</code></td>
<td>
<p>If FALSE (default), no uncertainty intervals are drawn. If a
positive integer, the intervals are this number times the standard error. If
a number between 0 and 1 (e.g. 0.95), the equivalent confidence interval is
drawn (e.g. 95% CI). In case of the confidence intervals, they are based on
the Gaussian distribution.</p>
</td></tr>
<tr><td><code id="plot_delay_+3A_interval_color">interval_color</code></td>
<td>
<p>The color of the uncertainty intervals. Default is
&quot;blue&quot;.</p>
</td></tr>
<tr><td><code id="plot_delay_+3A_show.legend">show.legend</code></td>
<td>
<p>A logical indicating whether the interval legend is shown.
Default is FALSE.</p>
</td></tr>
<tr><td><code id="plot_delay_+3A_xlab">xlab</code>, <code id="plot_delay_+3A_ylab">ylab</code></td>
<td>
<p>Names displayed at the x and y axes respectively. Default is
&quot;Period&quot; and &quot;Delay&quot; respectively.</p>
</td></tr>
<tr><td><code id="plot_delay_+3A_...">...</code></td>
<td>
<p>Currently unused argument.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>plot_delay</code> returns a number of <code><a href="ggplot2.html#topic+ggplot">ggplot</a></code>
objects.
</p>


<h3>Author(s)</h3>

<p>Kleanthis Natsiopoulos, <a href="mailto:klnatsio@gmail.com">klnatsio@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+multipliers">multipliers</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ardl_3132 &lt;- ardl(LRM ~ LRY + IBO + IDE, data = denmark, order = c(3,1,3,2))
delay_mult &lt;- multipliers(ardl_3132, type = 12, se = TRUE)

## Simply plot the delay multipliers -----------------------------------

plot_delay(delay_mult)

## Rearrange them ------------------------------------------------------

plot_delay(delay_mult, facets_ncol = 1)

## Add 1 standard deviation uncertainty intervals ----------------------

plot_delay(delay_mult, interval = 1)

## Add 95% confidence intervals, change color and add legend -----------

plot_delay(delay_mult, interval = 0.95, interval_color = "darkgrey",
           show.legend = TRUE)
</code></pre>

<hr>
<h2 id='plot_lr'>Create plot for the long-run (cointegrating) equation</h2><span id='topic+plot_lr'></span>

<h3>Description</h3>

<p>Creates a plot for the long-run relationship in comparison with the dependent
variable, and the fitted values of the model. This is a basic
<code><a href="ggplot2.html#topic+ggplot">ggplot</a></code> with a few customizable parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_lr(
  object,
  coint_eq,
  facets = FALSE,
  show_fitted = FALSE,
  show.legend = FALSE,
  xlab = "Time",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_lr_+3A_object">object</code></td>
<td>
<p>An object of <code><a href="base.html#topic+class">class</a></code> 'ardl'.</p>
</td></tr>
<tr><td><code id="plot_lr_+3A_coint_eq">coint_eq</code></td>
<td>
<p>The objected returned from <code><a href="#topic+coint_eq">coint_eq</a></code>.</p>
</td></tr>
<tr><td><code id="plot_lr_+3A_facets">facets</code></td>
<td>
<p>A logical indicating whether the long-run relationship appears
in a separate plot. Default is FALSE.</p>
</td></tr>
<tr><td><code id="plot_lr_+3A_show_fitted">show_fitted</code></td>
<td>
<p>A logical indicating whether the fitted values are shown.
Default is FALSE.</p>
</td></tr>
<tr><td><code id="plot_lr_+3A_show.legend">show.legend</code></td>
<td>
<p>A logical indicating whether the legend is shown.
Default is FALSE.</p>
</td></tr>
<tr><td><code id="plot_lr_+3A_xlab">xlab</code></td>
<td>
<p>Name displayed at the x axis. Default is &quot;Time&quot;.</p>
</td></tr>
<tr><td><code id="plot_lr_+3A_...">...</code></td>
<td>
<p>Currently unused argument.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>plot_lr</code> returns a <code><a href="ggplot2.html#topic+ggplot">ggplot</a></code> object.
</p>


<h3>Author(s)</h3>

<p>Kleanthis Natsiopoulos, <a href="mailto:klnatsio@gmail.com">klnatsio@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+coint_eq">coint_eq</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ardl_3132 &lt;- ardl(LRM ~ LRY + IBO + IDE, data = denmark, order = c(3,1,3,2))
ce2 &lt;- coint_eq(ardl_3132, case = 2)

plot_lr(ardl_3132, coint_eq = ce2)

## Compare fitted values and place long-run relationship separately ----

ce3 &lt;- coint_eq(ardl_3132, case = 3)
plot_lr(ardl_3132, coint_eq = ce3, facets = TRUE, show_fitted = TRUE,
        show.legend = TRUE)

</code></pre>

<hr>
<h2 id='PSS2001'>The UK earnings equation data from Pesaran et al. (2001)</h2><span id='topic+PSS2001'></span>

<h3>Description</h3>

<p>This data set contains the series used by Pesaran et al. (2001) for estimating the UK earnings equation.
The clean format of the data retrieved from the Data Archive of Natsiopoulos and Tzeremes (2022).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PSS2001
</code></pre>


<h3>Format</h3>

<p>A time-series object with 112 rows and 7 variables. Time period from 1970:Q1
until 1997:Q4.
</p>

<dl>
<dt>w</dt><dd><p>real wage</p>
</dd>
<dt>Prod</dt><dd><p>labor productivity</p>
</dd>
<dt>UR</dt><dd><p>unemployment rate</p>
</dd>
<dt>Wedge</dt><dd><p>wedge effect</p>
</dd>
<dt>Union</dt><dd><p>union power</p>
</dd>
<dt>D7475</dt><dd><p>income policies 1974:Q1-1975:Q4</p>
</dd>
<dt>D7579</dt><dd><p>income policies 1975:Q1-1979:Q4</p>
</dd>
</dl>



<h3>Details</h3>

<p>An object of class &quot;zooreg&quot; &quot;zoo&quot;.
</p>


<h3>Source</h3>

<p><a href="http://qed.econ.queensu.ca/jae/datasets/pesaran001/">http://qed.econ.queensu.ca/jae/datasets/pesaran001/</a>
<a href="http://qed.econ.queensu.ca/jae/datasets/natsiopoulos001/">http://qed.econ.queensu.ca/jae/datasets/natsiopoulos001/</a>
</p>


<h3>References</h3>

<p>M. Hashem Pesaran, Richard J. Smith, and Yongcheol Shin, (2001), &quot;Bounds Testing
Approaches to the Analysis of Level Relationships&quot;, <em>Journal of Applied
Econometrics</em>, <b>16, 3</b>, 289&ndash;326.
</p>
<p>Kleanthis Natsiopoulos and Nickolaos G. Tzeremes, (2022), &quot;ARDL bounds test for
Cointegration: Replicating the Pesaran et al. (2001) Results for the
UK Earnings Equation Using R&quot;,
<em>Journal of Applied Econometrics</em>, <b>37, 5</b>, 1079&ndash;1090.
<a href="https://doi.org/10.1002/jae.2919">doi:10.1002/jae.2919</a>
</p>

<hr>
<h2 id='recm'>Restricted ECM regression</h2><span id='topic+recm'></span>

<h3>Description</h3>

<p>Creates the Restricted Error Correction Model (RECM). This is the conditional
RECM, which is the RECM of the underlying ARDL.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>recm(object, case)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="recm_+3A_object">object</code></td>
<td>
<p>An object of <code><a href="base.html#topic+class">class</a></code> 'ardl' or 'uecm'.</p>
</td></tr>
<tr><td><code id="recm_+3A_case">case</code></td>
<td>
<p>An integer from 1-5 or a character string specifying whether the
'intercept' and/or the 'trend' have to participate in the short-run or the
long-run relationship (cointegrating equation) (see section 'Cases' below).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that the statistical significance of 'ect' in a RECM should not be
tested using the corresponding t-statistic (or the p-value) because it
doesn't follow a standard t-distribution. Instead, the
<code><a href="#topic+bounds_t_test">bounds_t_test</a></code> should be used.
</p>


<h3>Value</h3>

<p><code>recm</code> returns an object of <code><a href="base.html#topic+class">class</a></code>
<code>c("dynlm", "lm", "recm")</code>. In addition, attributes 'order', 'data',
'parsed_formula' and 'full_formula' are provided.
</p>


<h3>Mathematical Formula</h3>

<p>The formula of a Restricted ECM conditional to
an <code class="reqn">ARDL(p,q_{1},\dots,q_{k})</code> is: </p>
<p style="text-align: center;"><code class="reqn">\Delta
  y_{t} = c_{0} + c_{1}t + \sum_{i=1}^{p-1}\psi_{y,i}\Delta y_{t-i} +
  \sum_{j=1}^{k}\sum_{l=1}^{q_{j}-1} \psi_{j,l}\Delta x_{j,t-l} +
  \sum_{j=1}^{k}\omega_{j}\Delta x_{j,t} + \pi_{y}ECT_{t} + \epsilon_{t}</code>
</p>

<p style="text-align: center;"><code class="reqn">\psi_{j,l} = 0 \;\; \forall \;\; q_{j} = 1, \psi_{j,l} = \omega_{j} =
   0 \;\; \forall \;\; q_{j} = 0</code>
</p>


<dl>
<dt>Under Case 1:</dt><dd>
<ul>
<li> <p><code class="reqn">c_{0}=c_{1}=0</code>
</p>
</li>
<li> <p><code class="reqn">ECT = y_{t-1} - (\sum_{j=1}^{k} \theta_{j} x_{j,t-1})</code></p>
</li></ul>
</dd>
<dt>Under Case 2:</dt><dd>
<ul>
<li> <p><code class="reqn">c_{0}=c_{1}=0</code>
</p>
</li>
<li> <p><code class="reqn">ECT = y_{t-1} - (\mu + \sum_{j=1}^{k}\theta_{j} x_{j,t-1})</code></p>
</li></ul>
</dd>
<dt>Under Case 3:</dt><dd>
<ul>
<li> <p><code class="reqn">c_{1}=0</code>
</p>
</li>
<li> <p><code class="reqn">ECT = y_{t-1} - (\sum_{j=1}^{k} \theta_{j} x_{j,t-1})</code></p>
</li></ul>
</dd>
<dt>Under Case 4:</dt><dd>
<ul>
<li> <p><code class="reqn">c_{1}=0</code>
</p>
</li>
<li> <p><code class="reqn">ECT = y_{t-1} - (\delta(t-1)+ \sum_{j=1}^{k} \theta_{j} x_{j,t-1})</code></p>
</li></ul>
</dd>
<dt>Under Case 5:</dt><dd>
<ul>
<li> <p><code class="reqn">ECT = y_{t-1} - (\sum_{j=1}^{k} \theta_{j} x_{j,t-1})</code></p>
</li></ul>
</dd>
</dl>

<p>In all cases, <code class="reqn">x_{j,t-1}</code> in <code class="reqn">ECT</code> is replaced by <code class="reqn">x_{j,t} \;\;\;\;\; \forall \;\; q_{j} = 0</code>
</p>


<h3>Cases</h3>

<p>According to <cite>Pesaran et al. (2001)</cite>, we distinguish the
long-run relationship (cointegrating equation) (and thus the bounds-test and
the Restricted ECMs) between 5 different cases. These differ in terms of
whether the 'intercept' and/or the 'trend' are restricted to participate in
the long-run relationship or they are unrestricted and so they participate in
the short-run relationship.
</p>

<dl>
<dt>Case 1:</dt><dd>
<ul>
<li><p> No <em>intercept</em> and no <em>trend</em>.
</p>
</li>
<li> <p><code>case</code> inputs: 1 or &quot;n&quot; where &quot;n&quot; stands for none.</p>
</li></ul>
</dd>
<dt>Case 2:</dt><dd>
<ul>
<li><p> Restricted <em>intercept</em> and no <em>trend</em>.
</p>
</li>
<li> <p><code>case</code> inputs: 2 or &quot;rc&quot; where &quot;rc&quot; stands for restricted
constant.</p>
</li></ul>
</dd>
<dt>Case 3:</dt><dd>
<ul>
<li><p> Unrestricted <em>intercept</em> and no <em>trend</em>.
</p>
</li>
<li> <p><code>case</code> inputs: 3 or &quot;uc&quot; where &quot;uc&quot; stands for unrestricted
constant.</p>
</li></ul>
</dd>
<dt>Case 4:</dt><dd>
<ul>
<li><p> Unrestricted <em>intercept</em> and restricted <em>trend</em>.
</p>
</li>
<li> <p><code>case</code> inputs: 4 or &quot;ucrt&quot; where &quot;ucrt&quot; stands for
unrestricted constant and restricted trend.</p>
</li></ul>
</dd>
<dt>Case 5:</dt><dd>
<ul>
<li><p> Unrestricted <em>intercept</em> and unrestricted <em>trend</em>.
</p>
</li>
<li> <p><code>case</code> inputs: 5 or &quot;ucut&quot; where &quot;ucut&quot; stands for
unrestricted constant and unrestricted trend.</p>
</li></ul>
</dd>
</dl>

<p>Note that you can't restrict (or leave unrestricted) a parameter that doesn't
exist in the input model. For example, you can't compute <code>recm(object,
case=3)</code> if the object is an ARDL (or UECM) model with no intercept. The same
way, you can't compute <code>bounds_f_test(object, case=5)</code> if the object is
an ARDL (or UECM) model with no linear trend.
</p>


<h3>References</h3>

<p>Pesaran, M. H., Shin, Y., &amp; Smith, R. J. (2001). Bounds
testing approaches to the analysis of level relationships. <em>Journal of
Applied Econometrics</em>, 16(3), 289-326
</p>


<h3>Author(s)</h3>

<p>Kleanthis Natsiopoulos, <a href="mailto:klnatsio@gmail.com">klnatsio@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ardl">ardl</a></code> <code><a href="#topic+uecm">uecm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(denmark)

## Estimate the RECM, conditional to it's underlying ARDL(3,1,3,2) -----

# Indirectly from an ARDL
ardl_3132 &lt;- ardl(LRM ~ LRY + IBO + IDE, data = denmark, order = c(3,1,3,2))
recm_3132 &lt;- recm(ardl_3132, case = 2)

# Indirectly from an UECM
uecm_3132 &lt;- uecm(ardl_3132)
recm_3132_ &lt;- recm(uecm_3132, case = 2)
identical(recm_3132, recm_3132_)
summary(recm_3132)

## Error Correction Term (ect) &amp; Speed of Adjustment -------------------

# The coefficient of the ect,
# shows the Speed of Adjustment towards equilibrium.
# Note that this can be also be obtained from an UECM,
# through the coefficient of the term L(y, 1) (where y is the dependent variable).
tail(recm_3132$coefficients, 1)
uecm_3132$coefficients[2]

## Post-estimation testing ---------------------------------------------

# See examples in the help file of the uecm() function

</code></pre>

<hr>
<h2 id='t_bounds_sim'>Critical value bounds stochastic simulation for t-bounds test for no
cointegration</h2><span id='topic+t_bounds_sim'></span>

<h3>Description</h3>

<p><code>t_bounds_sim</code> simulates the critical value bounds for the t-bounds test
for no cointegration <cite>Pesaran et al. (2001)</cite>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>t_bounds_sim(case, k, alpha, T, R = 40000)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="t_bounds_sim_+3A_case">case</code></td>
<td>
<p>An integer (1, 3 or 5) specifying whether the 'intercept' and/or
the trend' have to participate in the short-run relationship (see section
'Cases' in <code><a href="#topic+bounds_t_test">bounds_t_test</a></code>).</p>
</td></tr>
<tr><td><code id="t_bounds_sim_+3A_k">k</code></td>
<td>
<p>The number of independent variables.</p>
</td></tr>
<tr><td><code id="t_bounds_sim_+3A_alpha">alpha</code></td>
<td>
<p>A numeric vector between 0 and 1 indicating the significance
level of the critical value bounds. Multiple values can be used.</p>
</td></tr>
<tr><td><code id="t_bounds_sim_+3A_t">T</code></td>
<td>
<p>An integer indicating the number of observations.</p>
</td></tr>
<tr><td><code id="t_bounds_sim_+3A_r">R</code></td>
<td>
<p>An integer indicating how many iterations will be used. Default is
40000.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>t_bounds_sim</code> returns a data frame with the critical value
bounds for the t-statistic.
</p>


<h3>Author(s)</h3>

<p>Kleanthis Natsiopoulos, <a href="mailto:klnatsio@gmail.com">klnatsio@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+f_bounds_sim">f_bounds_sim</a></code> <code><a href="#topic+bounds_t_test">bounds_t_test</a></code>
</p>

<hr>
<h2 id='to_lm'>Convert dynlm model (ardl, uecm, recm) to lm model</h2><span id='topic+to_lm'></span>

<h3>Description</h3>

<p>Takes a <code><a href="dynlm.html#topic+dynlm">dynlm</a></code> model of <code><a href="base.html#topic+class">class</a></code> 'ardl',
'uecm' or 'recm' and converts it into an <code><a href="stats.html#topic+lm">lm</a></code> model. This
can help using the model as a regular <code><a href="stats.html#topic+lm">lm</a></code> model with
functions that are not compatible with <code><a href="dynlm.html#topic+dynlm">dynlm</a></code> models such
as the <code><a href="stats.html#topic+predict">predict</a></code> function to forecast.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>to_lm(object, fix_names = FALSE, data_class = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="to_lm_+3A_object">object</code></td>
<td>
<p>An object of <code><a href="base.html#topic+class">class</a></code> 'ardl', 'uecm' or 'recm'.</p>
</td></tr>
<tr><td><code id="to_lm_+3A_fix_names">fix_names</code></td>
<td>
<p>A logical, indicating whether the variable names should be
rewritten without special functions and character in the names such as &quot;d()&quot;
or &quot;L()&quot;. When <code>fix_names = TRUE</code>, the characters &quot;(&quot;, and &quot;,&quot; are
replaces with &quot;.&quot;, and &quot;)&quot; and spaces are deleted. The name of the dependent
variable is always transformed, regardless of the value of this parameter.
Default is FALSE.</p>
</td></tr>
<tr><td><code id="to_lm_+3A_data_class">data_class</code></td>
<td>
<p>If &quot;ts&quot;, it converts the data class to
<code><a href="stats.html#topic+ts">ts</a></code> (see examples for its usage). The default is
<code><a href="base.html#topic+NULL">NULL</a></code>, which uses the same data provided in the original
object.</p>
</td></tr>
<tr><td><code id="to_lm_+3A_...">...</code></td>
<td>
<p>Currently unused argument.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>to_lm</code> returns an object of <code><a href="base.html#topic+class">class</a></code>
<code>"lm"</code>.
</p>


<h3>Author(s)</h3>

<p>Kleanthis Natsiopoulos, <a href="mailto:klnatsio@gmail.com">klnatsio@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ardl">ardl</a></code>, <code><a href="#topic+uecm">uecm</a></code>, <code><a href="#topic+recm">recm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Convert ARDL into lm ------------------------------------------------

ardl_3132 &lt;- ardl(LRM ~ LRY + IBO + IDE, data = denmark, order = c(3,1,3,2))
ardl_3132_lm &lt;- to_lm(ardl_3132)
summary(ardl_3132)$coefficients
summary(ardl_3132_lm)$coefficients

## Convert UECM into lm ------------------------------------------------

uecm_3132 &lt;- uecm(ardl_3132)
uecm_3132_lm &lt;- to_lm(uecm_3132)
summary(uecm_3132)$coefficients
summary(uecm_3132_lm)$coefficients

## Convert RECM into lm ------------------------------------------------

recm_3132 &lt;- recm(ardl_3132, case = 2)
recm_3132_lm &lt;- to_lm(recm_3132)
summary(recm_3132)$coefficients
summary(recm_3132_lm)$coefficients

## Use the lm model to forecast ----------------------------------------

# Forecast using the in-sample data
insample_data &lt;- ardl_3132$model
head(insample_data)
predicted_values &lt;- predict(ardl_3132_lm, newdata = insample_data)

# The predicted values are expected to be the same as the fitted values
ardl_3132$fitted.values
predicted_values

# Convert to ts class for the plot
predicted_values &lt;- ts(predicted_values, start = c(1974,4), frequency=4)
plot(denmark$LRM, lwd=4) #The input dependent variable
lines(ardl_3132$fitted.values, lwd=4, col="blue") #The fitted values
lines(predicted_values, lty=2, lwd=2, col="red") #The predicted values

## Convert to lm for post-estimation testing ---------------------------

# Ramsey's RESET test for functional form
library(lmtest) # for resettest()
library(strucchange) # for efp(), and sctest()

## Not run: 
    # This produces an error.
    # resettest() cannot use data of class 'zoo' such as the 'denmark' data
    # used to build the original model
    resettest(uecm_3132, type = c("regressor"))

## End(Not run)

uecm_3132_lm &lt;- to_lm(uecm_3132, data_class = "ts")
resettest(uecm_3132_lm, power = 2)

# CUSUM test for structural change detection
## Not run: 
    # This produces an error.
    # efp() does not understand special functions such as "d()" and "L()"
    efp(uecm_3132$full_formula, data = uecm_3132$model)

## End(Not run)

uecm_3132_lm_names &lt;- to_lm(uecm_3132, fix_names = TRUE)
fluctuation &lt;- efp(uecm_3132_lm_names$full_formula,
                   data = uecm_3132_lm_names$model)
sctest(fluctuation)
plot(fluctuation)

</code></pre>

<hr>
<h2 id='uecm'>Unrestricted ECM regression</h2><span id='topic+uecm'></span><span id='topic+uecm.ardl'></span><span id='topic+uecm.default'></span>

<h3>Description</h3>

<p><code>uecm</code> is a generic function used to construct Unrestricted Error
Correction Models (UECM). The function invokes two different
<code><a href="utils.html#topic+methods">methods</a></code>. The default method works exactly like
<code><a href="#topic+ardl">ardl</a></code>. The other method requires an object of
<code><a href="base.html#topic+class">class</a></code> 'ardl'. Both methods create the conditional UECM,
which is the UECM of the underlying ARDL.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>uecm(...)

## S3 method for class 'ardl'
uecm(object, ...)

## Default S3 method:
uecm(formula, data, order, start = NULL, end = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="uecm_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to the low level regression
fitting functions.</p>
</td></tr>
<tr><td><code id="uecm_+3A_object">object</code></td>
<td>
<p>An object of <code><a href="base.html#topic+class">class</a></code> 'ardl'.</p>
</td></tr>
<tr><td><code id="uecm_+3A_formula">formula</code></td>
<td>
<p>A &quot;formula&quot; describing the linear model. Details for model
specification are given under 'Details'.</p>
</td></tr>
<tr><td><code id="uecm_+3A_data">data</code></td>
<td>
<p>A time series object (e.g., &quot;ts&quot;, &quot;zoo&quot; or &quot;zooreg&quot;) or a data
frame containing the variables in the model. In the case of a data frame,
it is coerced into a <code><a href="stats.html#topic+ts">ts</a></code> object with <code>start = 1</code>,
<code>end = nrow(data)</code> and <code>frequency = 1</code>. If not found in data, the
variables are NOT taken from any environment.</p>
</td></tr>
<tr><td><code id="uecm_+3A_order">order</code></td>
<td>
<p>A specification of the order of the underlying ARDL model (e.g.,
for the UECM of an ARDL(1,0,2) model it should be <code>order = c(1,0,2)</code>).
A numeric vector of the same length as the total number of variables
(excluding the fixed ones, see 'Details'). It should only contain positive
integers or 0. An integer could be provided if all variables are of the
same order.</p>
</td></tr>
<tr><td><code id="uecm_+3A_start">start</code></td>
<td>
<p>Start of the time period which should be used for fitting the
model.</p>
</td></tr>
<tr><td><code id="uecm_+3A_end">end</code></td>
<td>
<p>End of the time period which should be used for fitting the model.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>formula</code> should contain only variables that exist in the data
provided through <code>data</code> plus some additional functions supported by
<code><a href="dynlm.html#topic+dynlm">dynlm</a></code> (i.e., <code>trend()</code>).
</p>
<p>You can also specify fixed variables that are not supposed to be lagged (e.g.
dummies etc.) simply by placing them after <code>|</code>. For example, <code>y ~
x1 + x2 | z1 + z2</code> where <code>z1</code> and <code>z2</code> are the fixed variables and
should not be considered in <code>order</code>. Note that the <code>|</code> notion
should not be confused with the same notion in <code>dynlm</code> where it
introduces instrumental variables.
</p>


<h3>Value</h3>

<p><code>uecm</code> returns an object of <code><a href="base.html#topic+class">class</a></code>
<code>c("dynlm", "lm", "uecm")</code>. In addition, attributes 'order', 'data',
'parsed_formula' and 'full_formula' are provided.
</p>


<h3>Mathematical Formula</h3>

<p>The formula of an Unrestricted ECM conditional
to an <code class="reqn">ARDL(p,q_{1},\dots,q_{k})</code> is: </p>
<p style="text-align: center;"><code class="reqn">\Delta
  y_{t} = c_{0} + c_{1}t + \pi_{y}y_{t-1} + \sum_{j=1}^{k}\pi_{j}x_{j,t-1} +
  \sum_{i=1}^{p-1}\psi_{y,i}\Delta y_{t-i} +
  \sum_{j=1}^{k}\sum_{l=1}^{q_{j}-1} \psi_{j,l}\Delta x_{j,t-l} +
  \sum_{j=1}^{k}\omega_{j}\Delta x_{j,t} + \epsilon_{t}</code>
</p>

<p style="text-align: center;"><code class="reqn">\psi_{j,l} = 0 \;\; \forall \;\; q_{j} \leq 1, \;\;\;\;\; \psi_{y,i}
  = 0 \;\; if \;\; p = 1</code>
</p>

<p>In addition, <code class="reqn">x_{j,t-1}</code> and <code class="reqn">\Delta x_{j,t}</code> cancel out
becoming <code class="reqn">x_{j,t} \;\; \forall \;\; q_{j} = 0</code>
</p>


<h3>Author(s)</h3>

<p>Kleanthis Natsiopoulos, <a href="mailto:klnatsio@gmail.com">klnatsio@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ardl">ardl</a></code> <code><a href="#topic+recm">recm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(denmark)

## Estimate the UECM, conditional to it's underlying ARDL(3,1,3,2) -----

# Indirectly
ardl_3132 &lt;- ardl(LRM ~ LRY + IBO + IDE, data = denmark, order = c(3,1,3,2))
uecm_3132 &lt;- uecm(ardl_3132)

# Directly
uecm_3132_ &lt;- uecm(LRM ~ LRY + IBO + IDE, data = denmark, order = c(3,1,3,2))
identical(uecm_3132, uecm_3132_)
summary(uecm_3132)

## Post-estimation testing ---------------------------------------------

library(lmtest) # for bgtest(), bptest(), and resettest()
library(tseries) # for jarque.bera.test()
library(strucchange) # for efp(), and sctest()

# Breusch-Godfrey test for higher-order serial correlation
bgtest(uecm_3132, order = 4)

# Breusch-Pagan test against heteroskedasticity
bptest(uecm_3132)

# Ramsey's RESET test for functional form
## Not run: 
    # This produces an error.
    # resettest() cannot use data of class 'zoo' such as the 'denmark' data
    # used to build the original model
    resettest(uecm_3132, type = c("regressor"))

## End(Not run)

uecm_3132_lm &lt;- to_lm(uecm_3132, data_class = "ts")
resettest(uecm_3132_lm, power = 2)

# Jarque-Bera test for normality
jarque.bera.test(residuals(uecm_3132))

# CUSUM test for structural change detection
## Not run: 
    # This produces an error.
    # efp() does not understand special functions such as "d()" and "L()"
    efp(uecm_3132$full_formula, data = uecm_3132$model)

## End(Not run)

uecm_3132_lm_names &lt;- to_lm(uecm_3132, fix_names = TRUE)
fluctuation &lt;- efp(uecm_3132_lm_names$full_formula,
                   data = uecm_3132_lm_names$model)
sctest(fluctuation)
plot(fluctuation)

</code></pre>

<hr>
<h2 id='vcov_custom'>Variance-Covariance matrix of a regression</h2><span id='topic+vcov_custom'></span>

<h3>Description</h3>

<p><code>vcov_custom</code> creates the Variance-Covariance matrix of a regression. It
is used instead of the <code><a href="stats.html#topic+vcov">vcov</a></code> because the latter doesn't
work with <code><a href="stats.html#topic+.lm.fit">.lm.fit</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vcov_custom(indep_vars, model_res)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vcov_custom_+3A_indep_vars">indep_vars</code></td>
<td>
<p>A matrix representing the independent variables.</p>
</td></tr>
<tr><td><code id="vcov_custom_+3A_model_res">model_res</code></td>
<td>
<p>A numeric vector representing the regression's residuals.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>vcov_custom</code> returns a Variance-Covariance matrix.
</p>


<h3>Author(s)</h3>

<p>Kleanthis Natsiopoulos, <a href="mailto:klnatsio@gmail.com">klnatsio@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+f_test_custom">f_test_custom</a></code> <code><a href="#topic+f_bounds_sim">f_bounds_sim</a></code>
<code><a href="#topic+t_bounds_sim">t_bounds_sim</a></code>
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
