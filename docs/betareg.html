<!DOCTYPE html><html><head><title>Help for package betareg</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {betareg}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#betamix'><p>Finite Mixtures of Beta Regression for Rates and Proportions</p></a></li>
<li><a href='#betareg'><p>Beta Regression for Rates and Proportions</p></a></li>
<li><a href='#betareg.control'><p>Control Parameters for Beta Regression</p></a></li>
<li><a href='#betatree'><p>Beta Regression Trees</p></a></li>
<li><a href='#CarTask'>
<p>Partition-primed Probability Judgement Task for Car Dealership</p></a></li>
<li><a href='#FoodExpenditure'><p>Proportion of Household Income Spent on Food</p></a></li>
<li><a href='#GasolineYield'><p>Estimation of Gasoline Yields from Crude Oil</p></a></li>
<li><a href='#gleverage'><p>Generalized Leverage Values</p></a></li>
<li><a href='#ImpreciseTask'>
<p>Imprecise Probabilities for Sunday Weather and Boeing Stock Task</p></a></li>
<li><a href='#MockJurors'><p>Confidence of Mock Jurors in Their Verdicts</p></a></li>
<li><a href='#plot.betareg'><p>Diagnostic Plots for betareg Objects</p></a></li>
<li><a href='#predict.betareg'><p>Prediction Method for betareg Objects</p></a></li>
<li><a href='#ReadingSkills'><p>Dyslexia and IQ Predicting Reading Accuracy</p></a></li>
<li><a href='#residuals.betareg'><p>Residuals Method for betareg Objects</p></a></li>
<li><a href='#StressAnxiety'><p>Dependency of Anxiety on Stress</p></a></li>
<li><a href='#summary.betareg'><p>Methods for betareg Objects</p></a></li>
<li><a href='#WeatherTask'>
<p>Weather Task With Priming and Precise and Imprecise Probabilities</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>3.1-4</td>
</tr>
<tr>
<td>Date:</td>
<td>2021-02-09</td>
</tr>
<tr>
<td>Title:</td>
<td>Beta Regression</td>
</tr>
<tr>
<td>Description:</td>
<td>Beta regression for modeling beta-distributed dependent variables, e.g., rates and proportions.
  In addition to maximum likelihood regression (for both mean and precision of a beta-distributed
  response), bias-corrected and bias-reduced estimation as well as finite mixture models and
  recursive partitioning for beta regressions are provided.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>graphics, grDevices, methods, stats, flexmix, Formula, lmtest,
modeltools, sandwich</td>
</tr>
<tr>
<td>Suggests:</td>
<td>car, lattice, partykit, strucchange</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-02-09 14:41:53 UTC; zeileis</td>
</tr>
<tr>
<td>Author:</td>
<td>Achim Zeileis [aut, cre],
  Francisco Cribari-Neto [aut],
  Bettina Gruen [aut],
  Ioannis Kosmidis [aut],
  Alexandre B. Simas [ctb] (earlier version by),
  Andrea V. Rocha [ctb] (earlier version by)</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Achim Zeileis &lt;Achim.Zeileis@R-project.org&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-02-09 19:20:11 UTC</td>
</tr>
</table>
<hr>
<h2 id='betamix'>Finite Mixtures of Beta Regression for Rates and Proportions</h2><span id='topic+betamix'></span><span id='topic+extraComponent'></span><span id='topic+fitted+2CFLXMRbeta-method'></span><span id='topic+fitted+2Cbetamix-method'></span><span id='topic+posterior+2Cbetamix+2CANY-method'></span><span id='topic+clusters+2Cbetamix+2CANY-method'></span><span id='topic+predict+2CFLXMRbeta-method'></span><span id='topic+predict+2CFLXMRbetafix-method'></span><span id='topic+predict+2Cbetamix-method'></span>

<h3>Description</h3>

<p>Fit finite mixtures of beta regression models for rates and
proportions via maximum likelihood with the EM algorithm using a
parametrization with mean (depending through a link function on the
covariates) and precision parameter (called phi).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>betamix(formula, data, k, subset, na.action, weights, offset,
  link = c("logit", "probit", "cloglog", "cauchit", "log",
    "loglog"), link.phi = "log",
  control = betareg.control(...), cluster = NULL,
  FLXconcomitant = NULL, FLXcontrol = list(), verbose = FALSE,
  nstart = if (is.null(cluster)) 3 else 1, which = "BIC", 
  ID, fixed, extra_components, ...)

extraComponent(type = c("uniform", "betareg"), coef, delta,
  link = "logit", link.phi = "log")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="betamix_+3A_formula">formula</code></td>
<td>
<p>symbolic description of the model (of type <code>y ~ x</code>
or <code>y ~ x | z</code>; for details see <code><a href="#topic+betareg">betareg</a></code>).</p>
</td></tr>
<tr><td><code id="betamix_+3A_data">data</code>, <code id="betamix_+3A_subset">subset</code>, <code id="betamix_+3A_na.action">na.action</code></td>
<td>
<p>arguments controlling formula processing
via <code><a href="stats.html#topic+model.frame">model.frame</a></code>.</p>
</td></tr>
<tr><td><code id="betamix_+3A_weights">weights</code></td>
<td>
<p>optional numeric vector of integer case weights.</p>
</td></tr>
<tr><td><code id="betamix_+3A_offset">offset</code></td>
<td>
<p>optional numeric vector with an a priori known component to be
included in the linear predictor for the mean.</p>
</td></tr>
<tr><td><code id="betamix_+3A_k">k</code></td>
<td>
<p>a vector of integers indicating the number of components of
the finite mixture; passed in turn to the <code>k</code> argument
of <code><a href="flexmix.html#topic+stepFlexmix">stepFlexmix</a></code>.</p>
</td></tr>
<tr><td><code id="betamix_+3A_link">link</code></td>
<td>
<p>character specification of the link function in
the mean model (mu). Currently, <code>"logit"</code>, <code>"probit"</code>,
<code>"cloglog"</code>, <code>"cauchit"</code>, <code>"log"</code>, <code>"loglog"</code> are supported.
Alternatively, an object of class <code>"link-glm"</code> can be supplied.</p>
</td></tr>
<tr><td><code id="betamix_+3A_link.phi">link.phi</code></td>
<td>
<p>character specification of the link function in
the precision model (phi). Currently, <code>"identity"</code>,
<code>"log"</code>, <code>"sqrt"</code> are supported. The default is <code>"log"</code>
unless <code>formula</code> is of type <code>y ~ x</code> where the default is
<code>"identity"</code> (for backward compatibility).
Alternatively, an object of class <code>"link-glm"</code> can be supplied.</p>
</td></tr>
<tr><td><code id="betamix_+3A_control">control</code></td>
<td>
<p>a list of control arguments specified via
<code><a href="#topic+betareg.control">betareg.control</a></code>.</p>
</td></tr>
<tr><td><code id="betamix_+3A_cluster">cluster</code></td>
<td>
<p>Either a matrix with <code>k</code> columns of initial
cluster membership probabilities for each observation; or a factor
or integer vector with the initial cluster
assignments of observations at the start of the EM
algorithm. Default is random assignment into <code>k</code>
clusters.</p>
</td></tr>
<tr><td><code id="betamix_+3A_flxconcomitant">FLXconcomitant</code></td>
<td>
<p>concomitant variable model; object of class
<code>FLXP</code>. Default is the object returned by calling
<code><a href="flexmix.html#topic+FLXPconstant">FLXPconstant</a></code>.
The argument <code>FLXconcomitant</code> can be omitted if <code>formula</code>
is a three-part formula of type <code>y ~ x | z | w</code>, where <code>w</code>
specificies the concomitant variables.</p>
</td></tr>
<tr><td><code id="betamix_+3A_flxcontrol">FLXcontrol</code></td>
<td>
<p>object of class <code>"FLXcontrol"</code> or a named list;
controls the EM algorithm and passed in turn to the <code>control</code>
argument of <code><a href="flexmix.html#topic+flexmix">flexmix</a></code>.</p>
</td></tr>
<tr><td><code id="betamix_+3A_verbose">verbose</code></td>
<td>
<p>a logical; if <code>TRUE</code> progress information is shown
for different starts of the EM algorithm.</p>
</td></tr>
<tr><td><code id="betamix_+3A_nstart">nstart</code></td>
<td>
<p>for each value of <code>k</code> run
<code><a href="flexmix.html#topic+stepFlexmix">stepFlexmix</a></code> <code>nstart</code> times and keep only
the solution with maximum likelihood.</p>
</td></tr>
<tr><td><code id="betamix_+3A_which">which</code></td>
<td>
<p>number of model to get if <code>k</code> is a vector of
integers longer than one. If character, interpreted as
number of components or name of an information criterion.</p>
</td></tr>
<tr><td><code id="betamix_+3A_id">ID</code></td>
<td>
<p>grouping variable indicating if observations are from the same
individual, i.e. the component membership is restricted to be the
same for these observations.</p>
</td></tr>
<tr><td><code id="betamix_+3A_fixed">fixed</code></td>
<td>
<p>symbolic description of the model for the parameters
fixed over components (of type <code>~ x | z</code>).</p>
</td></tr>
<tr><td><code id="betamix_+3A_extra_components">extra_components</code></td>
<td>
<p>a list containing objects returned by
<code>extraComponent()</code>.</p>
</td></tr>
<tr><td><code id="betamix_+3A_...">...</code></td>
<td>
<p>arguments passed to <code><a href="#topic+betareg.control">betareg.control</a></code>.</p>
</td></tr>
<tr><td><code id="betamix_+3A_type">type</code></td>
<td>
<p>specifies if the component follows a uniform distribution
or a beta regression model.</p>
</td></tr>
<tr><td><code id="betamix_+3A_coef">coef</code></td>
<td>
<p>a vector with the coefficients to determine the midpoint
of the uniform distribution or names list with the coefficients for
the mean and precision of the beta regression model.</p>
</td></tr>
<tr><td><code id="betamix_+3A_delta">delta</code></td>
<td>
<p>numeric; half-length of the interval of the uniform
distribution.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The arguments and the model specification are similar to
<code><a href="#topic+betareg">betareg</a></code>. Internally <code><a href="flexmix.html#topic+stepFlexmix">stepFlexmix</a></code>
is called with suitable arguments to fit the finite mixture model with
the EM algorithm. See Grün et al. (2012) for more details.
</p>
<p><code>extra_components</code> is a list where each element corresponds to a
component where the parameters are fixed a-priori.
</p>


<h3>Value</h3>

<p>An object of class <code>"flexmix"</code> containing the best model with
respect to the log likelihood or the one selected according to
<code>which</code> if <code>k</code> is a vector of integers longer than 1.
</p>


<h3>Author(s)</h3>

<p>Bettina Grün and Achim Zeileis
</p>


<h3>References</h3>

<p>Cribari-Neto, F., and Zeileis, A. (2010). Beta Regression in R.
<em>Journal of Statistical Software</em>, <b>34</b>(2), 1&ndash;24.
doi: <a href="https://doi.org/10.18637/jss.v034.i02">10.18637/jss.v034.i02</a>
</p>
<p>Grün, B., Kosmidis, I., and Zeileis, A. (2012).
Extended Beta Regression in R: Shaken, Stirred, Mixed, and Partitioned.
<em>Journal of Statistical Software</em>, <b>48</b>(11), 1&ndash;25.
doi: <a href="https://doi.org/10.18637/jss.v048.i11">10.18637/jss.v048.i11</a>
</p>
<p>Grün, B., and Leisch, F. (2008). FlexMix Version 2: Finite Mixtures
with Concomitant Variables and Varying and Constant Parameters.
<em>Journal of Statistical Software</em>, <b>28</b>(4), 1&ndash;35.
doi: <a href="https://doi.org/10.18637/jss.v028.i04">10.18637/jss.v028.i04</a>
</p>
<p>Leisch, F. (2004). FlexMix: A General Framework for Finite Mixture
Models and Latent Class Regression in R.
<em>Journal of Statistical Software</em>, <b>11</b>(8), 1&ndash;18.
doi: <a href="https://doi.org/10.18637/jss.v011.i08">10.18637/jss.v011.i08</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+betareg">betareg</a></code>, <code><a href="flexmix.html#topic+flexmix">flexmix</a></code>,
<code><a href="flexmix.html#topic+stepFlexmix">stepFlexmix</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>options(digits = 4)
suppressWarnings(RNGversion("3.5.0"))

## data with two groups of dyslexic and non-dyslexic children
data("ReadingSkills", package = "betareg")

set.seed(4040)
## try to capture accuracy ~ iq relationship (without using dyslexia
## information) using two beta regression components and one additional
## extra component for a perfect reading score
rs_mix &lt;- betamix(accuracy ~ iq, data = ReadingSkills, k = 3,
  nstart = 10, extra_components = extraComponent(type = "uniform",
  coef = 0.99, delta = 0.01))

## visualize result
## intensities based on posterior probabilities
prob &lt;- 2 * (posterior(rs_mix)[cbind(1:nrow(ReadingSkills),
   clusters(rs_mix))] - 0.5)
## associated HCL colors
col0 &lt;- hcl(c(260, 0, 130), 65, 45, fixup = FALSE)
col1 &lt;- col0[clusters(rs_mix)]
col2 &lt;- hcl(c(260, 0, 130)[clusters(rs_mix)], 65 * abs(prob)^1.5,
   95 - 50 * abs(prob)^1.5, fixup = FALSE)
## scatter plot
plot(accuracy ~ iq, data = ReadingSkills, col = col2, pch = 19,
   cex = 1.5, xlim = c(-2, 2))
points(accuracy ~ iq, data = ReadingSkills, cex = 1.5, pch = 1,
   col = col1)
## fitted lines
iq &lt;- -30:30/10
cf &lt;- rbind(coef(rs_mix, model = "mean", component = 1:2),
   c(qlogis(0.99), 0))
for(i in 1:3)
   lines(iq, plogis(cf[i, 1] + cf[i, 2] * iq), lwd = 2,
         col = col0[i])

## refit the model including a concomitant variable model
## using the dyslexia information
w &lt;- rnorm(nrow(ReadingSkills), 
           c(-1, 1)[as.integer(ReadingSkills$dyslexia)])

## The argument FLXconcomitant can be omitted when specifying
## the model via a three part formula given by
## accuracy ~ iq | 1 | w
## The posteriors from the previously fitted model are used
## for initialization.
library("flexmix")
rs_mix2 &lt;- betamix(accuracy ~ iq, data = ReadingSkills,
  extra_components = extraComponent(type = "uniform",
  coef = 0.99, delta = 0.01), cluster = posterior(rs_mix),
  FLXconcomitant = FLXPmultinom(~w))
coef(rs_mix2, which = "concomitant")
summary(rs_mix2, which = "concomitant")
</code></pre>

<hr>
<h2 id='betareg'>Beta Regression for Rates and Proportions</h2><span id='topic+betareg'></span><span id='topic+betareg.fit'></span>

<h3>Description</h3>

<p>Fit beta regression models for rates and proportions via maximum likelihood
using a parametrization with mean (depending through a link function on the
covariates) and precision parameter (called phi).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>betareg(formula, data, subset, na.action, weights, offset,
  link = c("logit", "probit", "cloglog", "cauchit", "log", "loglog"),
  link.phi = NULL, type = c("ML", "BC", "BR"),
  control = betareg.control(...), model = TRUE,
  y = TRUE, x = FALSE, ...)

betareg.fit(x, y, z = NULL, weights = NULL, offset = NULL,
  link = "logit", link.phi = "log", type = "ML", control = betareg.control())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="betareg_+3A_formula">formula</code></td>
<td>
<p>symbolic description of the model (of type <code>y ~ x</code>
or <code>y ~ x | z</code>; for details see below).</p>
</td></tr>
<tr><td><code id="betareg_+3A_data">data</code>, <code id="betareg_+3A_subset">subset</code>, <code id="betareg_+3A_na.action">na.action</code></td>
<td>
<p>arguments controlling formula processing
via <code><a href="stats.html#topic+model.frame">model.frame</a></code>.</p>
</td></tr>
<tr><td><code id="betareg_+3A_weights">weights</code></td>
<td>
<p>optional numeric vector of case weights.</p>
</td></tr>
<tr><td><code id="betareg_+3A_offset">offset</code></td>
<td>
<p>optional numeric vector with an a priori known component to be
included in the linear predictor for the mean. In <code>betareg.fit</code>,
<code>offset</code> may also be a list of two offsets for the mean and precision
equation, respectively.</p>
</td></tr>
<tr><td><code id="betareg_+3A_link">link</code></td>
<td>
<p>character specification of the link function in
the mean model (mu). Currently, <code>"logit"</code>, <code>"probit"</code>,
<code>"cloglog"</code>, <code>"cauchit"</code>, <code>"log"</code>, <code>"loglog"</code> are supported.
Alternatively, an object of class <code>"link-glm"</code> can be supplied.</p>
</td></tr>
<tr><td><code id="betareg_+3A_link.phi">link.phi</code></td>
<td>
<p>character specification of the link function in
the precision model (phi). Currently, <code>"identity"</code>,
<code>"log"</code>, <code>"sqrt"</code> are supported. The default is <code>"log"</code>
unless <code>formula</code> is of type <code>y ~ x</code> where the default is
<code>"identity"</code> (for backward compatibility).
Alternatively, an object of class <code>"link-glm"</code> can be supplied.</p>
</td></tr>
<tr><td><code id="betareg_+3A_type">type</code></td>
<td>
<p>character specification of the type of estimator. Currently,
maximum likelihood (<code>"ML"</code>), ML with bias correction (<code>"BC"</code>),
and ML with bias reduction (<code>"BR"</code>) are supported.</p>
</td></tr>
<tr><td><code id="betareg_+3A_control">control</code></td>
<td>
<p>a list of control arguments specified via
<code><a href="#topic+betareg.control">betareg.control</a></code>.</p>
</td></tr>
<tr><td><code id="betareg_+3A_model">model</code>, <code id="betareg_+3A_y">y</code>, <code id="betareg_+3A_x">x</code></td>
<td>
<p>logicals. If <code>TRUE</code> the corresponding components
of the fit (model frame, response, model matrix) are returned.
For <code>betareg.fit</code>, <code>x</code> should be a numeric regressor matrix
and <code>y</code> should be the numeric response vector (with values in (0,1)).</p>
</td></tr>
<tr><td><code id="betareg_+3A_z">z</code></td>
<td>
<p>numeric matrix. Regressor matrix for the precision model, defaulting
to an intercept only.</p>
</td></tr>
<tr><td><code id="betareg_+3A_...">...</code></td>
<td>
<p>arguments passed to <code><a href="#topic+betareg.control">betareg.control</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Beta regression as suggested by Ferrari and Cribari-Neto (2004) and extended
by Simas, Barreto-Souza, and Rocha (2010) is implemented in <code>betareg</code>.
It is useful in situations where the dependent variable is continuous and restricted to
the unit interval (0, 1), e.g., resulting from rates or proportions. It is modeled to be
beta-distributed with parametrization using mean and precision parameter (called phi).
The mean is linked, as in generalized linear models (GLMs), to the responses through a link
function and a linear predictor. Additionally, the precision parameter phi can be linked
to another (potentially overlapping) set of regressors through a second link function,
resulting in a model with variable dispersion.  
Estimation is performed by maximum likelihood (ML) via <code><a href="stats.html#topic+optim">optim</a></code> using
analytical gradients and (by default) starting values from an auxiliary linear regression
of the transformed response. Subsequently, the <code>optim</code> result may be enhanced
by an additional Fisher scoring iteration using analytical gradients and expected information.
This slightly improves the optimization by moving the gradients even closer to zero
(for <code>type = "ML"</code> and <code>"BC"</code>) or solving the bias-adjusted estimating equations
(for <code>type = "BR"</code>). For the former two estimators, the optional Fisher scoring
can be disabled by setting <code>fsmaxit = 0</code> in the control arguments. See
Cribari-Neto and Zeileis (2010) and Grün et al. (2012) for details.
</p>
<p>In the beta regression as introduced by Ferrari and Cribari-Neto (2004), the mean of
the response is linked to a linear predictor described by <code>y ~ x1 + x2</code> using
a <code>link</code> function while the precision parameter phi is assumed to be
constant. Simas et al. (2009) suggest to extend this model by linking phi to an
additional set of regressors (<code>z1 + z2</code>, say): In <code>betareg</code> this can be
specified in a formula of type <code>y ~ x1 + x2 | z1 + z2</code> where the regressors
in the two parts can be overlapping. In the precision model (for phi), the link
function <code>link.phi</code> is used. The default is a <code>"log"</code> link unless no
precision model is specified. In the latter case (i.e., when the formula is of type
<code>y ~ x1 + x2</code>), the <code>"identity"</code> link is used by default for backward
compatibility.
</p>
<p>Simas et al. (2009) also suggest further extensions (non-linear specificiations,
bias correction) which are not yet implemented in <code>betareg</code>. However,
Kosmidis and Firth (2010) discuss general algorithms for bias correction/reduction,
both of which are available in <code>betareg</code> by setting the <code>type</code> argument
accordingly. (Technical note: In case, either bias correction or reduction is requested,
the second derivative of the inverse link function is required for <code>link</code> and
<code>link.phi</code>. If the two links are specified by their names (as done by default
in <code>betareg</code>), then the <code>"link-glm"</code> objects are enhanced automatically
by the required additional <code>dmu.deta</code> function. However, if a <code>"link-glm"</code>
object is supplied directly by the user, it needs to have the <code>dmu.deta</code>
function.)
</p>
<p>The main parameters of interest are the coefficients in the linear predictor of the mean
model. The additional parameters in the precision model (phi) can either
be treated as full model parameters (default) or as nuisance parameters. In the latter case
the estimation does not change, only the reported information in output from <code>print</code>,
<code>summary</code>, or <code>coef</code> (among others) will be different. See also <code><a href="#topic+betareg.control">betareg.control</a></code>.
</p>
<p>A set of standard extractor functions for fitted model objects is available for
objects of class <code>"betareg"</code>, including methods to the generic functions
<code><a href="base.html#topic+print">print</a></code>, <code><a href="base.html#topic+summary">summary</a></code>, <code><a href="graphics.html#topic+plot">plot</a></code>, <code><a href="stats.html#topic+coef">coef</a></code>, 
<code><a href="stats.html#topic+vcov">vcov</a></code>, <code><a href="stats.html#topic+logLik">logLik</a></code>, <code><a href="stats.html#topic+residuals">residuals</a></code>, 
<code><a href="stats.html#topic+predict">predict</a></code>, <code><a href="stats.html#topic+terms">terms</a></code>,
<code><a href="stats.html#topic+model.frame">model.frame</a></code>, <code><a href="stats.html#topic+model.matrix">model.matrix</a></code>,
<code>cooks.distance</code> and <code>hatvalues</code> (see <code><a href="stats.html#topic+influence.measures">influence.measures</a></code>),
<code><a href="#topic+gleverage">gleverage</a></code> (new generic), <code><a href="sandwich.html#topic+estfun">estfun</a></code> and
<code><a href="sandwich.html#topic+bread">bread</a></code> (from the <span class="pkg">sandwich</span> package), and
<code><a href="lmtest.html#topic+coeftest">coeftest</a></code> (from the <span class="pkg">lmtest</span> package).
</p>
<p>See <code><a href="#topic+predict.betareg">predict.betareg</a></code>, <code><a href="#topic+residuals.betareg">residuals.betareg</a></code>, <code><a href="#topic+plot.betareg">plot.betareg</a></code>,
and <code><a href="#topic+summary.betareg">summary.betareg</a></code> for more details on all methods.
</p>
<p>The original version of the package was written by Alexandre B. Simas and Andrea V. Rocha
(up to version 1.2). Starting from version 2.0-0 the code was rewritten by Achim Zeileis.
</p>


<h3>Value</h3>

<p><code>betareg</code> returns an object of class <code>"betareg"</code>, i.e., a list with components as follows.
<code>betareg.fit</code> returns an unclassed list with components up to <code>converged</code>.
</p>
<table>
<tr><td><code>coefficients</code></td>
<td>
<p>a list with elements <code>"mean"</code> and <code>"precision"</code>
containing the coefficients from the respective models,</p>
</td></tr>
<tr><td><code>residuals</code></td>
<td>
<p>a vector of raw residuals (observed - fitted),</p>
</td></tr>
<tr><td><code>fitted.values</code></td>
<td>
<p>a vector of fitted means,</p>
</td></tr>
<tr><td><code>optim</code></td>
<td>
<p>output from the <code>optim</code> call for maximizing the log-likelihood(s),</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>the method argument passed to the <code>optim</code> call,</p>
</td></tr>
<tr><td><code>control</code></td>
<td>
<p>the control arguments passed to the <code>optim</code> call,</p>
</td></tr>
<tr><td><code>start</code></td>
<td>
<p>the starting values for the parameters passed to the <code>optim</code> call,</p>
</td></tr>
<tr><td><code>weights</code></td>
<td>
<p>the weights used (if any),</p>
</td></tr>
<tr><td><code>offset</code></td>
<td>
<p>a list of offset vectors used (if any),</p>
</td></tr>
<tr><td><code>n</code></td>
<td>
<p>number of observations,</p>
</td></tr>
<tr><td><code>nobs</code></td>
<td>
<p>number of observations with non-zero weights,</p>
</td></tr>
<tr><td><code>df.null</code></td>
<td>
<p>residual degrees of freedom in the null model (constant mean and dispersion),
i.e., <code>n - 2</code>,</p>
</td></tr>
<tr><td><code>df.residual</code></td>
<td>
<p>residual degrees of freedom in the fitted model,</p>
</td></tr>
<tr><td><code>phi</code></td>
<td>
<p>logical indicating whether the precision (phi) coefficients will be
treated as full model parameters or nuisance parameters in subsequent calls to
<code>print</code>, <code>summary</code>, <code>coef</code> etc.,</p>
</td></tr>
<tr><td><code>loglik</code></td>
<td>
<p>log-likelihood of the fitted model,</p>
</td></tr>
<tr><td><code>vcov</code></td>
<td>
<p>covariance matrix of all parameters in the model,</p>
</td></tr>
<tr><td><code>pseudo.r.squared</code></td>
<td>
<p>pseudo R-squared value (squared correlation of linear predictor
and link-transformed response),</p>
</td></tr>
<tr><td><code>link</code></td>
<td>
<p>a list with elements <code>"mean"</code> and <code>"precision"</code>
containing the link objects for the respective models,</p>
</td></tr>
<tr><td><code>converged</code></td>
<td>
<p>logical indicating successful convergence of <code>optim</code>,</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>the original function call,</p>
</td></tr>
<tr><td><code>formula</code></td>
<td>
<p>the original formula,</p>
</td></tr>  
<tr><td><code>terms</code></td>
<td>
<p>a list with elements <code>"mean"</code>, <code>"precision"</code> and
<code>"full"</code> containing the terms objects for the respective models,</p>
</td></tr>
<tr><td><code>levels</code></td>
<td>
<p>a list with elements <code>"mean"</code>, <code>"precision"</code> and
<code>"full"</code> containing the levels of the categorical regressors,</p>
</td></tr>
<tr><td><code>contrasts</code></td>
<td>
<p>a list with elements <code>"mean"</code> and <code>"precision"</code>
containing the contrasts corresponding to <code>levels</code> from the
respective models,</p>
</td></tr>
<tr><td><code>model</code></td>
<td>
<p>the full model frame (if <code>model = TRUE</code>),</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>the response proportion vector (if <code>y = TRUE</code>),</p>
</td></tr>
<tr><td><code>x</code></td>
<td>
<p>a list with elements <code>"mean"</code> and <code>"precision"</code>
containing the model matrices from the respective models
(if <code>x = TRUE</code>).</p>
</td></tr>
</table>


<h3>References</h3>

<p>Cribari-Neto, F., and Zeileis, A. (2010). Beta Regression in R.
<em>Journal of Statistical Software</em>, <b>34</b>(2), 1&ndash;24.
doi: <a href="https://doi.org/10.18637/jss.v034.i02">10.18637/jss.v034.i02</a>
</p>
<p>Ferrari, S.L.P., and Cribari-Neto, F. (2004).
Beta Regression for Modeling Rates and Proportions.
<em>Journal of Applied Statistics</em>, <b>31</b>(7), 799&ndash;815.
</p>
<p>Grün, B., Kosmidis, I., and Zeileis, A. (2012).
Extended Beta Regression in R: Shaken, Stirred, Mixed, and Partitioned.
<em>Journal of Statistical Software</em>, <b>48</b>(11), 1&ndash;25.
doi: <a href="https://doi.org/10.18637/jss.v048.i11">10.18637/jss.v048.i11</a>
</p>
<p>Kosmidis, I., and Firth, D. (2010).
A Generic Algorithm for Reducing Bias in Parametric Estimation.
<em>Electronic Journal of Statistics</em>, <b>4</b>, 1097&ndash;1112.
</p>
<p>Simas, A.B., Barreto-Souza, W., and Rocha, A.V. (2010).
Improved Estimators for a General Class of Beta Regression Models.
<em>Computational Statistics &amp; Data Analysis</em>, <b>54</b>(2), 348&ndash;366.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+summary.betareg">summary.betareg</a></code>, <code><a href="#topic+predict.betareg">predict.betareg</a></code>, <code><a href="#topic+residuals.betareg">residuals.betareg</a></code>,
<code><a href="Formula.html#topic+Formula">Formula</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>options(digits = 4)

## Section 4 from Ferrari and Cribari-Neto (2004)
data("GasolineYield", package = "betareg")
data("FoodExpenditure", package = "betareg")

## Table 1
gy &lt;- betareg(yield ~ batch + temp, data = GasolineYield)
summary(gy)

## Table 2
fe_lin &lt;- lm(I(food/income) ~ income + persons, data = FoodExpenditure)
library("lmtest")
bptest(fe_lin)
fe_beta &lt;- betareg(I(food/income) ~ income + persons, data = FoodExpenditure)
summary(fe_beta)

## nested model comparisons via Wald and LR tests
fe_beta2 &lt;- betareg(I(food/income) ~ income, data = FoodExpenditure)
lrtest(fe_beta, fe_beta2)
waldtest(fe_beta, fe_beta2)


## Section 3 from online supplements to Simas et al. (2010)
## mean model as in gy above
## precision model with regressor temp
gy2 &lt;- betareg(yield ~ batch + temp | temp, data = GasolineYield)

## MLE column in Table 19
summary(gy2)

## LRT row in Table 18
lrtest(gy, gy2)
</code></pre>

<hr>
<h2 id='betareg.control'>Control Parameters for Beta Regression</h2><span id='topic+betareg.control'></span>

<h3>Description</h3>

<p>Various parameters that control fitting of beta regression models
using <code><a href="#topic+betareg">betareg</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>betareg.control(phi = TRUE, method = "BFGS", maxit = 5000,
  hessian = FALSE, trace = FALSE, start = NULL,
  fsmaxit = 200, fstol = 1e-8, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="betareg.control_+3A_phi">phi</code></td>
<td>
<p>logical indicating whether the precision parameter
phi should be treated as a full model parameter (<code>TRUE</code>, default)
or as a nuisance parameter.</p>
</td></tr>
<tr><td><code id="betareg.control_+3A_method">method</code></td>
<td>
<p>characters string specifying the <code>method</code> argument
passed to <code><a href="stats.html#topic+optim">optim</a></code>.</p>
</td></tr>
<tr><td><code id="betareg.control_+3A_maxit">maxit</code></td>
<td>
<p>integer specifying the <code>maxit</code> argument (maximal number
of iterations) passed to <code><a href="stats.html#topic+optim">optim</a></code>.</p>
</td></tr>
<tr><td><code id="betareg.control_+3A_trace">trace</code></td>
<td>
<p>logical or integer controlling whether tracing information on  
the progress of the optimization should be produced (passed to <code><a href="stats.html#topic+optim">optim</a></code>).</p>
</td></tr>
<tr><td><code id="betareg.control_+3A_hessian">hessian</code></td>
<td>
<p>logical. Should the numerical Hessian matrix from the <code>optim</code> output
be used for estimation of the covariance matrix? By default the analytical solution is employed.
For details see below.</p>
</td></tr>
<tr><td><code id="betareg.control_+3A_start">start</code></td>
<td>
<p>an optional vector with starting values for all parameters (including phi).</p>
</td></tr>
<tr><td><code id="betareg.control_+3A_fsmaxit">fsmaxit</code></td>
<td>
<p>integer specifying maximal number of additional (quasi) Fisher scoring
iterations. For details see below.</p>
</td></tr>
<tr><td><code id="betareg.control_+3A_fstol">fstol</code></td>
<td>
<p>numeric tolerance for convergence in (quasi) Fisher scoring.
For details see below.</p>
</td></tr>
<tr><td><code id="betareg.control_+3A_...">...</code></td>
<td>
<p>arguments passed to <code><a href="stats.html#topic+optim">optim</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>All parameters in <code><a href="#topic+betareg">betareg</a></code> are estimated by maximum likelihood
using <code><a href="stats.html#topic+optim">optim</a></code> with control options set in <code><a href="#topic+betareg.control">betareg.control</a></code>.
Most arguments are passed on directly to <code>optim</code>, and <code>start</code> controls
how <code>optim</code> is called.
</p>
<p>After the <code>optim</code> maximization, an additional (quasi) Fisher scoring
can be perfomed to further enhance the result or to perform additional bias reduction.
If <code>fsmaxit</code> is greater than zero, this additional optimization is
performed and it converges if the threshold <code>fstol</code> is attained
for the cross-product of the step size.
</p>
<p>Starting values can be supplied via <code>start</code> or estimated by
<code><a href="stats.html#topic+lmfit">lm.wfit</a></code>, using the link-transformed response.
Covariances are in general derived analytically. Only if <code>type = "ML"</code> and
<code>hessian = TRUE</code>, they are determined numerically using the Hessian matrix
returned by <code>optim</code>. In the latter case no Fisher scoring iterations are
performed.
</p>
<p>The main parameters of interest are the coefficients in the linear predictor of the
model and the additional precision parameter phi which can either
be treated as a full model parameter (default) or as a nuisance parameter. In the latter case
the estimation does not change, only the reported information in output from <code>print</code>,
<code>summary</code>, or <code>coef</code> (among others) will be different. See also examples.
</p>


<h3>Value</h3>

<p>A list with the arguments specified.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+betareg">betareg</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>options(digits = 4)

data("GasolineYield", package = "betareg")

## regression with phi as full model parameter
gy1 &lt;- betareg(yield ~ batch + temp, data = GasolineYield)
gy1

## regression with phi as nuisance parameter
gy2 &lt;- betareg(yield ~ batch + temp, data = GasolineYield, phi = FALSE)
gy2

## compare reported output
coef(gy1)
coef(gy2)
summary(gy1)
summary(gy2)
</code></pre>

<hr>
<h2 id='betatree'>Beta Regression Trees</h2><span id='topic+betatree'></span><span id='topic+plot.betatree'></span><span id='topic+print.betatree'></span><span id='topic+predict.betatree'></span><span id='topic+sctest.betatree'></span>

<h3>Description</h3>

<p>Fit beta regression trees via model-based recursive partitioning.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>betatree(formula, partition,
  data, subset = NULL, na.action = na.omit, weights, offset, cluster,
  link = "logit", link.phi = "log", control = betareg.control(),
  ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="betatree_+3A_formula">formula</code></td>
<td>
<p>symbolic description of the model of type <code>y ~ x</code>
or <code>y ~ x | z</code>, specifying the variables influencing mean
and precision of <code>y</code>, respectively. For details see <code><a href="#topic+betareg">betareg</a></code>.</p>
</td></tr>
<tr><td><code id="betatree_+3A_partition">partition</code></td>
<td>
<p>symbolic description of the partitioning variables,
e.g., <code>~ p1 + p2</code>. The argument <code>partition</code> can be omitted
if <code>formula</code> is a three-part formula of type <code>y ~ x | z | p1 + p2</code>.</p>
</td></tr>  
<tr><td><code id="betatree_+3A_data">data</code>, <code id="betatree_+3A_subset">subset</code>, <code id="betatree_+3A_na.action">na.action</code>, <code id="betatree_+3A_weights">weights</code>, <code id="betatree_+3A_offset">offset</code>, <code id="betatree_+3A_cluster">cluster</code></td>
<td>
<p>arguments controlling
data/model processing passed to <code><a href="partykit.html#topic+mob">mob</a></code>.</p>
</td></tr>
<tr><td><code id="betatree_+3A_link">link</code></td>
<td>
<p>character specification of the link function in
the mean model (mu). Currently, <code>"logit"</code>, <code>"probit"</code>,
<code>"cloglog"</code>, <code>"cauchit"</code>, <code>"log"</code>, <code>"loglog"</code> are supported.
Alternatively, an object of class <code>"link-glm"</code> can be supplied.</p>
</td></tr>
<tr><td><code id="betatree_+3A_link.phi">link.phi</code></td>
<td>
<p>character specification of the link function in
the precision model (phi). Currently, <code>"identity"</code>,
<code>"log"</code>, <code>"sqrt"</code> are supported.
Alternatively, an object of class <code>"link-glm"</code> can be supplied.</p>
</td></tr>
<tr><td><code id="betatree_+3A_control">control</code></td>
<td>
<p>a list of control arguments for the beta regression specified via
<code><a href="#topic+betareg.control">betareg.control</a></code>.</p>
</td></tr>
<tr><td><code id="betatree_+3A_...">...</code></td>
<td>
<p>further control arguments for the recursive partitioning
passed to <code><a href="partykit.html#topic+mob_control">mob_control</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Beta regression trees are an application of model-based recursive partitioning
(implemented in <code><a href="partykit.html#topic+mob">mob</a></code>, see Zeileis et al. 2008) to
beta regression (implemented in <code><a href="#topic+betareg">betareg</a></code>, see Cribari-Neto
and Zeileis 2010). See also Grün at al. (2012) for more details.
</p>
<p>Various methods are provided for <code>"betatree"</code> objects, most of them
inherit their behavior from <code>"mob"</code> objects (e.g., <code>print</code>, <code>summary</code>,
<code>coef</code>, etc.). The <code>plot</code> method employs the <code><a href="partykit.html#topic+node_bivplot">node_bivplot</a></code>
panel-generating function.
</p>


<h3>Value</h3>

<p><code>betatree()</code> returns an object of S3 class <code>"betatree"</code> which
inherits from <code>"modelparty"</code>.
</p>


<h3>References</h3>

<p>Cribari-Neto, F., and Zeileis, A. (2010). Beta Regression in R.
<em>Journal of Statistical Software</em>, <b>34</b>(2), 1&ndash;24.
doi: <a href="https://doi.org/10.18637/jss.v034.i02">10.18637/jss.v034.i02</a>
</p>
<p>Grün, B., Kosmidis, I., and Zeileis, A. (2012).
Extended Beta Regression in R: Shaken, Stirred, Mixed, and Partitioned.
<em>Journal of Statistical Software</em>, <b>48</b>(11), 1&ndash;25.
doi: <a href="https://doi.org/10.18637/jss.v048.i11">10.18637/jss.v048.i11</a>
</p>
<p>Zeileis, A., Hothorn, T., and Hornik K. (2008).
Model-Based Recursive Partitioning.
<em>Journal of Computational and Graphical Statistics</em>, 
<b>17</b>(2), 492&ndash;514.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+betareg">betareg</a></code>, <code><a href="#topic+betareg.fit">betareg.fit</a></code>, <code><a href="partykit.html#topic+mob">mob</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>options(digits = 4)
suppressWarnings(RNGversion("3.5.0"))

## data with two groups of dyslexic and non-dyslexic children
data("ReadingSkills", package = "betareg")
## additional random noise (not associated with reading scores)
set.seed(1071)
ReadingSkills$x1 &lt;- rnorm(nrow(ReadingSkills))
ReadingSkills$x2 &lt;- runif(nrow(ReadingSkills))
ReadingSkills$x3 &lt;- factor(rnorm(nrow(ReadingSkills)) &gt; 0)

## fit beta regression tree: in each node
##   - accurcay's mean and precision depends on iq
##   - partitioning is done by dyslexia and the noise variables x1, x2, x3
## only dyslexia is correctly selected for splitting
bt &lt;- betatree(accuracy ~ iq | iq, ~ dyslexia + x1 + x2 + x3,
  data = ReadingSkills, minsize = 10)
plot(bt)

## inspect result
coef(bt)
if(require("strucchange")) sctest(bt)
## IGNORE_RDIFF_BEGIN
summary(bt, node = 2)
summary(bt, node = 3)
## IGNORE_RDIFF_END

## add a numerical variable with relevant information for splitting
ReadingSkills$x4 &lt;- rnorm(nrow(ReadingSkills), c(-1.5, 1.5)[ReadingSkills$dyslexia])

bt2 &lt;- betatree(accuracy ~ iq | iq, ~ x1 + x2 + x3 + x4,
  data = ReadingSkills, minsize = 10)
plot(bt2)

## inspect result
coef(bt2)
if(require("strucchange")) sctest(bt2)
## IGNORE_RDIFF_BEGIN
summary(bt2, node = 2)
summary(bt2, node = 3)
## IGNORE_RDIFF_END
</code></pre>

<hr>
<h2 id='CarTask'>
Partition-primed Probability Judgement Task for Car Dealership
</h2><span id='topic+CarTask'></span>

<h3>Description</h3>

<p>In this study participants were asked to judge how likely it is that a
customer trades in a coupe or that a customer buys a car form a
specific salesperson out of four possible salespersons.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(CarTask)</code></pre>


<h3>Format</h3>

<p>A data frame with 155 observations on the following 3 variables.
</p>

<dl>
<dt><code>task</code></dt><dd><p>a factor with levels <code>Car</code> and
<code>Salesperson</code> indicating the condition.</p>
</dd>
<dt><code>probability</code></dt><dd><p>a numeric vector of the estimated probability.</p>
</dd>
<dt><code>NFCCscale</code></dt><dd><p>a numeric vector of the NFCC scale.</p>
</dd>
</dl>



<h3>Details</h3>

<p>All participants in the study were undergraduate students at The
Australian National University, some of whom obtained course credit in
first-year Psychology for their participation in the study.
</p>
<p>The NFCC scale is a combined scale of the Need for Closure and Need
for Certainty scales which are strongly correlated.
</p>
<p>For <code>task</code> the questions were:
</p>

<dl>
<dt>Car</dt><dd><p>What is the probability that a customer trades in a coupe?</p>
</dd>
<dt>Salesperson</dt><dd><p>What is the probability that a customer buys a
car from Carlos?</p>
</dd>
</dl>



<h3>Source</h3>

<p>Taken from Smithson et al. (2011) supplements.
</p>


<h3>References</h3>

<p>Smithson, M., Merkle, E.C., and Verkuilen, J. (2011). Beta
Regression Finite Mixture Models of Polarization and Priming.
<em>Journal of Educational and Behavioral Statistics</em>, <b>36</b>(6), 804&ndash;831.
doi: <a href="https://doi.org/10.3102/1076998610396893">10.3102/1076998610396893</a>
</p>
<p>Smithson, M., and Segale, C. (2009). Partition Priming in Judgments of
Imprecise Probabilities. <em>Journal of Statistical Theory and
Practice</em>, <b>3</b>(1), 169&ndash;181.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("CarTask", package = "betareg")
library("flexmix")
car_betamix &lt;- betamix(probability ~ 1, data = CarTask, k = 3,
  extra_components = list(extraComponent(type = "uniform", coef = 1/2,
  delta = 0.01), extraComponent(type = "uniform", coef = 1/4, delta = 0.01)),
  FLXconcomitant = FLXPmultinom(~ task))
</code></pre>

<hr>
<h2 id='FoodExpenditure'>Proportion of Household Income Spent on Food</h2><span id='topic+FoodExpenditure'></span>

<h3>Description</h3>

<p>Data on proportion of income spent on food for a random sample of 38 households in a large US city.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("FoodExpenditure")</code></pre>


<h3>Format</h3>

<p>A data frame containing 38 observations on 3 variables.
</p>

<dl>
<dt>food</dt><dd><p>household expenditures for food.</p>
</dd>
<dt>income</dt><dd><p>household income.</p>
</dd>
<dt>persons</dt><dd><p>number of persons living in household.</p>
</dd>
</dl>



<h3>Source</h3>

<p>Taken from Griffiths et al. (1993, Table 15.4).
</p>


<h3>References</h3>

<p>Cribari-Neto, F., and Zeileis, A. (2010). Beta Regression in R.
<em>Journal of Statistical Software</em>, <b>34</b>(2), 1&ndash;24.
doi: <a href="https://doi.org/10.18637/jss.v034.i02">10.18637/jss.v034.i02</a>
</p>
<p>Ferrari, S.L.P., and Cribari-Neto, F. (2004).
Beta Regression for Modeling Rates and Proportions.
<em>Journal of Applied Statistics</em>, <b>31</b>(7), 799&ndash;815.
</p>
<p>Griffiths, W.E., Hill, R.C., and Judge, G.G. (1993).
<em>Learning and Practicing Econometrics</em>
New York: John Wiley and Sons.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+betareg">betareg</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data("FoodExpenditure", package = "betareg")

## Ferrari and Cribari-Neto (2004)
## Section 4
fe_lin &lt;- lm(I(food/income) ~ income + persons, data = FoodExpenditure)
library("lmtest")
bptest(fe_lin)

## Table 2
fe_beta &lt;- betareg(I(food/income) ~ income + persons, data = FoodExpenditure)
summary(fe_beta)
</code></pre>

<hr>
<h2 id='GasolineYield'>Estimation of Gasoline Yields from Crude Oil</h2><span id='topic+GasolineYield'></span>

<h3>Description</h3>

<p>Operational data of the proportion of crude oil converted to gasoline after
distillation and fractionation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("GasolineYield")</code></pre>


<h3>Format</h3>

<p>A data frame containing 32 observations on 6 variables.
</p>

<dl>
<dt>yield</dt><dd><p>proportion of crude oil converted to gasoline after distillation and fractionation.</p>
</dd>
<dt>gravity</dt><dd><p>crude oil gravity (degrees API).</p>
</dd>
<dt>pressure</dt><dd><p>vapor pressure of crude oil (lbf/in2).</p>
</dd>
<dt>temp10</dt><dd><p>temperature (degrees F) at which 10 percent of crude oil has vaporized.</p>
</dd>
<dt>temp</dt><dd><p>temperature (degrees F) at which all gasoline has vaporized.</p>
</dd>
<dt>batch</dt><dd><p>factor indicating unique batch of conditions <code>gravity</code>,
<code>pressure</code>, and <code>temp10</code>.</p>
</dd>
</dl>



<h3>Details</h3>

<p>This dataset was collected by Prater (1956), its dependent variable is the
proportion of crude oil after distillation and fractionation. This dataset was
analyzed by Atkinson (1985), who used the linear regression model and noted that
there is &ldquo;indication that the error distribution is not quite symmetrical,
giving rise to some unduly large and small residuals&rdquo; (p. 60).
</p>
<p>The dataset contains 32 observations on the response and on the independent
variables. It has been noted (Daniel and Wood, 1971, Chapter 8) that there are only
ten sets of values of the first three explanatory variables which correspond to
ten different crudes and were subjected to experimentally controlled distillation
conditions. These conditions are captured in variable <code>batch</code> and
the data were ordered according to the ascending order of <code>temp10</code>.
</p>


<h3>Source</h3>

<p>Taken from Prater (1956).
</p>


<h3>References</h3>

<p>Atkinson, A.C. (1985).
<em>Plots, Transformations and Regression: An Introduction to Graphical Methods of Diagnostic Regression Analysis</em>.
New York: Oxford University Press.
</p>
<p>Cribari-Neto, F., and Zeileis, A. (2010). Beta Regression in R.
<em>Journal of Statistical Software</em>, <b>34</b>(2), 1&ndash;24.
doi: <a href="https://doi.org/10.18637/jss.v034.i02">10.18637/jss.v034.i02</a>
</p>
<p>Daniel, C., and Wood, F.S. (1971).
<em>Fitting Equations to Data</em>.
New York: John Wiley and Sons.
</p>
<p>Ferrari, S.L.P., and Cribari-Neto, F. (2004).
Beta Regression for Modeling Rates and Proportions.
<em>Journal of Applied Statistics</em>, <b>31</b>(7), 799&ndash;815.
</p>
<p>Prater, N.H. (1956).
Estimate Gasoline Yields from Crudes.
<em>Petroleum Refiner</em>, <b>35</b>(5), 236&ndash;238.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+betareg">betareg</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## IGNORE_RDIFF_BEGIN
data("GasolineYield", package = "betareg")

gy1 &lt;- betareg(yield ~ gravity + pressure + temp10 + temp, data = GasolineYield)
summary(gy1)

## Ferrari and Cribari-Neto (2004)
gy2 &lt;- betareg(yield ~ batch + temp, data = GasolineYield)
## Table 1
summary(gy2)
## Figure 2
par(mfrow = c(3, 2))
plot(gy2, which = 1, type = "pearson", sub.caption = "")
plot(gy2, which = 1, type = "deviance", sub.caption = "")
plot(gy2, which = 5, type = "deviance", sub.caption = "")
plot(gy2, which = 4, type = "pearson", sub.caption = "")
plot(gy2, which = 2:3)
par(mfrow = c(1, 1))

## exclude 4th observation
gy2a &lt;- update(gy2, subset = -4)
gy2a
summary(gy2a)
## IGNORE_RDIFF_END
</code></pre>

<hr>
<h2 id='gleverage'>Generalized Leverage Values</h2><span id='topic+gleverage'></span><span id='topic+gleverage.betareg'></span>

<h3>Description</h3>

<p>Compute the generalized leverages values for fitted models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gleverage(model, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gleverage_+3A_model">model</code></td>
<td>
<p>a model object.</p>
</td></tr>
<tr><td><code id="gleverage_+3A_...">...</code></td>
<td>
<p>further arguments passed to methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>gleverage</code> is a new generic for computing generalized leverage values as suggested by
Wei, Hu, and Fung (1998). Currently, there is only a method for <code>betareg</code> models, implementing
the formulas from Rocha and Simas (2011) which are consistent with the formulas from
Ferrari and Cribari-Neto (2004) for the fixed dispersion case.
</p>
<p>Currently, the vector of generalized leverages requires computations and
storage of order <code class="reqn">n \times n</code>.
</p>


<h3>References</h3>

<p>Ferrari, S.L.P., and Cribari-Neto, F. (2004).
Beta Regression for Modeling Rates and Proportions.
<em>Journal of Applied Statistics</em>, <b>31</b>(7), 799&ndash;815.
</p>
<p>Rocha, A.V., and Simas,  A.B. (2011).
Influence Diagnostics in a General Class of Beta Regression Models.
<em>Test</em>, <b>20</b>(1), 95&ndash;119.
doi: <a href="https://doi.org/10.1007/s11749-010-0189-z">10.1007/s11749-010-0189-z</a>
</p>
<p>Wei, B.-C., and Hu, Y.-Q., and Fung, W.-K. (1998).
Generalized Leverage and Its Applications.
<em>Scandinavian Journal of Statistics</em>, <b>25</b>, 25&ndash;37.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+betareg">betareg</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>options(digits = 4)
data("GasolineYield", package = "betareg")
gy &lt;- betareg(yield ~ batch + temp, data = GasolineYield)
gleverage(gy)
</code></pre>

<hr>
<h2 id='ImpreciseTask'>
Imprecise Probabilities for Sunday Weather and Boeing Stock Task
</h2><span id='topic+ImpreciseTask'></span>

<h3>Description</h3>

<p>In this study participants were asked to estimate upper and lower
probabilities for event to occur and not to occur.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(ImpreciseTask)</code></pre>


<h3>Format</h3>

<p>A data frame with 242 observations on the following 3 variables.
</p>

<dl>
<dt><code>task</code></dt><dd><p>a factor with levels <code>Boeing stock</code> and <code>Sunday weather</code>.</p>
</dd>
<dt><code>location</code></dt><dd><p>a numeric vector of the average of the lower
estimate for the event not to occur and the upper estimate for the
event to occur.</p>
</dd>
<dt><code>difference</code></dt><dd><p>a numeric vector of the differences of the
lower and upper estimate for the event to occur.</p>
</dd>
</dl>



<h3>Details</h3>

<p>All participants in the study were either first- or second-year
undergraduate students in psychology, none of whom had a strong
background in probability or were familiar with imprecise probability
theories. 
</p>
<p>For the sunday weather task see <code><a href="#topic+WeatherTask">WeatherTask</a></code>. For the Boeing
stock task participants were asked to estimate the probability that
Boeing's stock would rise more than those in a list of 30 companies.
</p>
<p>For each task participants were asked to provide lower and upper
estimates for the event to occur and not to occur.  
</p>


<h3>Source</h3>

<p>Taken from Smithson et al. (2011) supplements.
</p>


<h3>References</h3>

<p>Smithson, M., Merkle, E.C., and Verkuilen, J. (2011). Beta
Regression Finite Mixture Models of Polarization and Priming.
<em>Journal of Educational and Behavioral Statistics</em>, <b>36</b>(6), 804&ndash;831.
doi: <a href="https://doi.org/10.3102/1076998610396893">10.3102/1076998610396893</a>
</p>
<p>Smithson, M., and Segale, C. (2009). Partition Priming in Judgments of
Imprecise Probabilities. <em>Journal of Statistical Theory and
Practice</em>, <b>3</b>(1), 169&ndash;181.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("ImpreciseTask", package = "betareg")
library("flexmix")
wt_betamix &lt;- betamix(location ~ difference * task, data = ImpreciseTask, k = 2,
  extra_components = extraComponent(type = "betareg", coef =
    list(mean = 0, precision = 8)),
  FLXconcomitant = FLXPmultinom(~ task))
</code></pre>

<hr>
<h2 id='MockJurors'>Confidence of Mock Jurors in Their Verdicts</h2><span id='topic+MockJurors'></span>

<h3>Description</h3>

<p>Data with responses of naive mock jurors to the conventional
conventional two-option verdict (guilt vs. acquittal) versus a
three-option verdict setup (the third option was the Scottish
'not proven' alternative), in the presence/absence of conflicting
testimonial evidence.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("MockJurors")</code></pre>


<h3>Format</h3>

<p>A data frame containing 104 observations on 3 variables.
</p>

<dl>
<dt>verdict</dt><dd><p>factor indicating whether a two-option or
three-option verdict is requested. (A sum contrast rather
than treatment contrast is employed.)</p>
</dd>
<dt>conflict</dt><dd><p>factor. Is there conflicting testimonial evidence?
(A sum contrast rather than treatment contrast is employed.)</p>
</dd>
<dt>confidence</dt><dd><p>jurors degree of confidence in his/her verdict,
scaled to the open unit interval (see below).</p>
</dd>
</dl>



<h3>Details</h3>

<p>The data were collected by Daily (2004) among first-year psychology
students at Australian National University. Smithson and Verkuilen (2006)
employed the data scaling the original confidence (on a scale 0&ndash;100)
to the open unit interval: <code>((original_confidence/100) * 103 - 0.5) / 104</code>.
</p>
<p>The original coding of <code>conflict</code> in the data provided from Smithson's
homepage is -1/1 which Smithson and Verkuilen (2006) describe to mean
no/yes. However, all their results (sample statistics, histograms, etc.)
suggest that it actually means yes/no which was employed in <code>MockJurors</code>.
</p>


<h3>Source</h3>

<p>Example 1 from Smithson and Verkuilen (2006) supplements.
</p>


<h3>References</h3>

<p>Deady, S. (2004).
The Psychological Third Verdict: 'Not Proven' or 'Not Willing to Make a Decision'?
<em>Unpublished honors thesis</em>, The Australian National University, Canberra.
</p>
<p>Smithson, M., and Verkuilen, J. (2006).
A Better Lemon Squeezer? Maximum-Likelihood Regression with
Beta-Distributed Dependent Variables.
<em>Psychological Methods</em>, <b>11</b>(7), 54&ndash;71.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+betareg">betareg</a></code>, <code><a href="#topic+ReadingSkills">ReadingSkills</a></code>, <code><a href="#topic+StressAnxiety">StressAnxiety</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data("MockJurors", package = "betareg")
library("lmtest")

## Smithson &amp; Verkuilen (2006, Table 1)
## variable dispersion model
## (NOTE: numerical rather than analytical Hessian is used for replication,
##  Smithson &amp; Verkuilen erroneously compute one-sided p-values)
mj_vd &lt;- betareg(confidence ~ verdict * conflict | verdict * conflict,
  data = MockJurors, hessian = TRUE)
summary(mj_vd)

## model selection for beta regression: null model, fixed dispersion model (p. 61)
mj_null &lt;- betareg(confidence ~ 1 | 1, data = MockJurors)
mj_fd &lt;-   betareg(confidence ~ verdict * conflict | 1, data = MockJurors)
lrtest(mj_null, mj_fd)
lrtest(mj_null, mj_vd)
## McFadden's pseudo-R-squared
1 - as.vector(logLik(mj_null)/logLik(mj_vd))

## visualization
if(require("lattice")) {
  histogram(~ confidence | conflict + verdict, data = MockJurors,
    col = "lightgray", breaks = 0:10/10, type = "density")
}

## see demo("SmithsonVerkuilen2006", package = "betareg") for more details
</code></pre>

<hr>
<h2 id='plot.betareg'>Diagnostic Plots for betareg Objects</h2><span id='topic+plot.betareg'></span>

<h3>Description</h3>

<p>Various types of standard diagnostic plots can be produced, involving various types of
residuals, influence measures etc.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'betareg'
plot(x, which = 1:4,
  caption = c("Residuals vs indices of obs.", "Cook's distance plot",
    "Generalized leverage vs predicted values", "Residuals vs linear predictor", 
    "Half-normal plot of residuals", "Predicted vs observed values"),
    sub.caption = paste(deparse(x$call), collapse = "\n"), main = "", 
    ask = prod(par("mfcol")) &lt; length(which) &amp;&amp; dev.interactive(), 
    ..., type = "sweighted2", nsim = 100, level = 0.9)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.betareg_+3A_x">x</code></td>
<td>
<p>fitted model object of class <code>"betareg"</code>.</p>
</td></tr>
<tr><td><code id="plot.betareg_+3A_which">which</code></td>
<td>
<p>numeric. If a subset of the plots is required, specify a subset of the numbers <code>1:6</code>.</p>
</td></tr>
<tr><td><code id="plot.betareg_+3A_caption">caption</code></td>
<td>
<p>character. Captions to appear above the plots.</p>
</td></tr>
<tr><td><code id="plot.betareg_+3A_sub.caption">sub.caption</code></td>
<td>
<p>character. Common title-above figures if there are multiple.</p>
</td></tr>
<tr><td><code id="plot.betareg_+3A_main">main</code></td>
<td>
<p>character. Title to each plot in addition to the above <code>caption</code>.</p>
</td></tr>
<tr><td><code id="plot.betareg_+3A_ask">ask</code></td>
<td>
<p>logical. If <code>TRUE</code>, the user is asked before each plot.</p>
</td></tr>
<tr><td><code id="plot.betareg_+3A_...">...</code></td>
<td>
<p>other parameters to be passed through to plotting functions.</p>
</td></tr>
<tr><td><code id="plot.betareg_+3A_type">type</code></td>
<td>
<p>character indicating type of residual to be used, see <code><a href="#topic+residuals.betareg">residuals.betareg</a></code>.</p>
</td></tr>
<tr><td><code id="plot.betareg_+3A_nsim">nsim</code></td>
<td>
<p>numeric. Number of simulations in half-normal plots.</p>
</td></tr>
<tr><td><code id="plot.betareg_+3A_level">level</code></td>
<td>
<p>numeric. Confidence level in half-normal plots.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>plot</code> method for <code><a href="#topic+betareg">betareg</a></code> objects produces various types
of diagnostic plots. Most of these are standard for regression models and involve
various types of residuals, influence measures etc. See Ferrari and Cribari-Neto (2004)
for a discussion of some of these displays.
</p>
<p>The <code>which</code> argument can be used to select a subset of currently six supported
types of displays. The corresponding element of <code>caption</code> contains a brief
description. In some more detail, the displays are: Residuals (as selected by
<code>type</code>) vs indices of observations (<code>which = 1</code>). Cook's distances
vs indices of observations (<code>which = 2</code>). Generalized leverage vs
predicted values (<code>which = 3</code>). Residuals vs linear predictor  (<code>which = 4</code>).
Half-normal plot of residuals (<code>which = 5</code>), which is obtained using a simulation
approach. Predicted vs observed values (<code>which = 6</code>).
</p>


<h3>References</h3>

<p>Cribari-Neto, F., and Zeileis, A. (2010). Beta Regression in R.
<em>Journal of Statistical Software</em>, <b>34</b>(2), 1&ndash;24.
doi: <a href="https://doi.org/10.18637/jss.v034.i02">10.18637/jss.v034.i02</a>
</p>
<p>Ferrari, S.L.P., and Cribari-Neto, F. (2004).
Beta Regression for Modeling Rates and Proportions.
<em>Journal of Applied Statistics</em>, <b>31</b>(7), 799&ndash;815.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+betareg">betareg</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data("GasolineYield", package = "betareg")

gy &lt;- betareg(yield ~ gravity + pressure + temp10 + temp, data = GasolineYield)

par(mfrow = c(3, 2))
plot(gy, which = 1:6)
par(mfrow = c(1, 1))
</code></pre>

<hr>
<h2 id='predict.betareg'>Prediction Method for betareg Objects</h2><span id='topic+predict.betareg'></span>

<h3>Description</h3>

<p>Extract various types of predictions from beta regression models:
either on the scale of responses in (0, 1) or the scale of
the linear predictor.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'betareg'
predict(object, newdata = NULL,
  type = c("response", "link", "precision", "variance", "quantile"),
  na.action = na.pass, at = 0.5, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.betareg_+3A_object">object</code></td>
<td>
<p>fitted model object of class <code>"betareg"</code>.</p>
</td></tr>
<tr><td><code id="predict.betareg_+3A_newdata">newdata</code></td>
<td>
<p>optionally, a data frame in which to look for variables with
which to predict. If omitted, the original observations are used.</p>
</td></tr>
<tr><td><code id="predict.betareg_+3A_type">type</code></td>
<td>
<p>character indicating type of predictions: fitted means of response (<code>"response"</code>),
corresponding linear predictor (<code>"link"</code>), fitted precision parameter
phi (<code>"precision"</code>), fitted variances of response (<code>"variance"</code>),
or fitted quantile(s) of the response distribution (<code>"quantile"</code>).</p>
</td></tr>
<tr><td><code id="predict.betareg_+3A_na.action">na.action</code></td>
<td>
<p>function determining what should be done with missing values
in <code>newdata</code>. The default is to predict <code>NA</code>.</p>
</td></tr>
<tr><td><code id="predict.betareg_+3A_at">at</code></td>
<td>
<p>numeric vector indicating the level(s) at which quantiles
should be predicted (only if <code>type = "quantile"</code>), defaulting
to the median <code>at = 0.5</code>.</p>
</td></tr>
<tr><td><code id="predict.betareg_+3A_...">...</code></td>
<td>
<p>currently not used.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>options(digits = 4)

data("GasolineYield", package = "betareg")

gy2 &lt;- betareg(yield ~ batch + temp | temp, data = GasolineYield)

cbind(
  predict(gy2, type = "response"),
  predict(gy2, type = "link"),
  predict(gy2, type = "precision"),
  predict(gy2, type = "variance"),
  predict(gy2, type = "quantile", at = c(0.25, 0.5, 0.75))
)
</code></pre>

<hr>
<h2 id='ReadingSkills'>Dyslexia and IQ Predicting Reading Accuracy</h2><span id='topic+ReadingSkills'></span>

<h3>Description</h3>

<p>Data for assessing the contribution of non-verbal IQ to
children's reading skills in dyslexic and non-dyslexic children.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("ReadingSkills")</code></pre>


<h3>Format</h3>

<p>A data frame containing 44 observations on 3 variables.
</p>

<dl>
<dt>accuracy</dt><dd><p>reading score scaled to the open unit interval (see below).</p>
</dd>
<dt>dyslexia</dt><dd><p>factor. Is the child dyslexic? (A sum contrast rather
than treatment contrast is employed.)</p>
</dd>
<dt>iq</dt><dd><p>non-verbal intelligence quotient transformed to z-scores.</p>
</dd>
</dl>



<h3>Details</h3>

<p>The data were collected by Pammer and Kevan (2004) and employed by
Smithson and Verkuilen (2006). The original reading accuracy score was transformed
by Smithson and Verkuilen (2006) so that <code>accuracy</code> is in the open unit
interval (0, 1) and beta regression can be employed. First, the original accuracy
was scaled using the minimal and maximal score (<code>a</code> and <code>b</code>, respectively)
that can be obtained in the test: <code>(original_accuracy - a) / (b - a)</code>
(<code>a</code> and <code>b</code> are not provided). Subsequently, the scaled score is transformed
to the unit interval using a continuity correction: <code>(scaled_accuracy * (n-1) - 0.5) / n</code>
(either with some rounding or using <code>n = 50</code> rather than 44).
</p>


<h3>Source</h3>

<p>Example 3 from Smithson and Verkuilen (2006) supplements.
</p>


<h3>References</h3>

<p>Cribari-Neto, F., and Zeileis, A. (2010). Beta Regression in R.
<em>Journal of Statistical Software</em>, <b>34</b>(2), 1&ndash;24.
doi: <a href="https://doi.org/10.18637/jss.v034.i02">10.18637/jss.v034.i02</a>
</p>
<p>Grün, B., Kosmidis, I., and Zeileis, A. (2012).
Extended Beta Regression in R: Shaken, Stirred, Mixed, and Partitioned.
<em>Journal of Statistical Software</em>, <b>48</b>(11), 1&ndash;25.
doi: <a href="https://doi.org/10.18637/jss.v048.i11">10.18637/jss.v048.i11</a>
</p>
<p>Pammer, K., and Kevan, A. (2004).
The Contribution of Visual Sensitivity, Phonological Processing
and Non-Verbal IQ to Children's Reading.
<em>Unpublished manuscript</em>, The Australian National University, Canberra.
</p>
<p>Smithson, M., and Verkuilen, J. (2006).
A Better Lemon Squeezer? Maximum-Likelihood Regression with
Beta-Distributed Dependent Variables.
<em>Psychological Methods</em>, <b>11</b>(7), 54&ndash;71.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+betareg">betareg</a></code>, <code><a href="#topic+MockJurors">MockJurors</a></code>, <code><a href="#topic+StressAnxiety">StressAnxiety</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data("ReadingSkills", package = "betareg")

## Smithson &amp; Verkuilen (2006, Table 5)
## OLS regression
## (Note: typo in iq coefficient: 0.3954 instead of 0.3594)
rs_ols &lt;- lm(qlogis(accuracy) ~ dyslexia * iq, data = ReadingSkills)
summary(rs_ols)
## Beta regression (with numerical rather than analytic standard errors)
## (Note: Smithson &amp; Verkuilen erroneously compute one-sided p-values)
rs_beta &lt;- betareg(accuracy ~ dyslexia * iq | dyslexia + iq,
  data = ReadingSkills, hessian = TRUE)
summary(rs_beta)

## visualization
plot(accuracy ~ iq, data = ReadingSkills, col = as.numeric(dyslexia), pch = 19)
nd &lt;- data.frame(dyslexia = "no", iq = -30:30/10)
lines(nd$iq, predict(rs_beta, nd))
lines(nd$iq, plogis(predict(rs_ols, nd)), lty = 2)
nd &lt;- data.frame(dyslexia = "yes", iq = -30:30/10)
lines(nd$iq, predict(rs_beta, nd), col = 2)
lines(nd$iq, plogis(predict(rs_ols, nd)), col = 2, lty = 2)

## see demo("SmithsonVerkuilen2006", package = "betareg") for more details
</code></pre>

<hr>
<h2 id='residuals.betareg'>Residuals Method for betareg Objects</h2><span id='topic+residuals.betareg'></span>

<h3>Description</h3>

<p>Extract various types of residuals from beta regression models:
raw response residuals (observed - fitted), Pearson residuals (raw residuals scaled by
square root of variance function), deviance residuals (scaled log-likelihood contributions),
and different kinds of weighted residuals suggested by Espinheira et al. (2008).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'betareg'
residuals(object,
  type = c("sweighted2", "deviance", "pearson", "response", "weighted", "sweighted"),
  ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="residuals.betareg_+3A_object">object</code></td>
<td>
<p>fitted model object of class <code>"betareg"</code>.</p>
</td></tr>
<tr><td><code id="residuals.betareg_+3A_type">type</code></td>
<td>
<p>character indicating type of residuals.</p>
</td></tr>
<tr><td><code id="residuals.betareg_+3A_...">...</code></td>
<td>
<p>currently not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The definitions of all residuals are provided in Espinheira et al. (2008):
Equation 2 for <code>"pearson"</code>, last equation on page 409 for <code>"deviance"</code>,
Equation 6 for <code>"weighted"</code>, Equation 7 for <code>"sweighted"</code>, and
Equation 8 for <code>"sweighted2"</code>.
</p>
<p>Espinheira et al. (2008) recommend to use <code>"sweighted2"</code>, hence this is 
the default in the <code>residuals()</code> method. Note, however, that these are
rather burdensome to compute because they require operations of <code class="reqn">O(n^2)</code>
and hence might be prohibitively costly in large sample.
</p>


<h3>References</h3>

<p>Cribari-Neto, F., and Zeileis, A. (2010). Beta Regression in R.
<em>Journal of Statistical Software</em>, <b>34</b>(2), 1&ndash;24.
doi: <a href="https://doi.org/10.18637/jss.v034.i02">10.18637/jss.v034.i02</a>
</p>
<p>Espinheira, P.L., Ferrari, S.L.P., and Cribari-Neto, F. (2008).
On Beta Regression Residuals.
<em>Journal of Applied Statistics</em>, <b>35</b>(4), 407&ndash;419.
</p>
<p>Ferrari, S.L.P., and Cribari-Neto, F. (2004).
Beta Regression for Modeling Rates and Proportions.
<em>Journal of Applied Statistics</em>, <b>31</b>(7), 799&ndash;815.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+betareg">betareg</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>options(digits = 4)

data("GasolineYield", package = "betareg")

gy &lt;- betareg(yield ~ gravity + pressure + temp10 + temp, data = GasolineYield)

gy_res &lt;- cbind(
  residuals(gy, type = "pearson"),
  residuals(gy, type = "deviance"),
  residuals(gy, type = "response"),
  residuals(gy, type = "weighted"),
  residuals(gy, type = "sweighted"),
  residuals(gy, type = "sweighted2")
)
colnames(gy_res) &lt;- c("pearson", "deviance", "response",
  "weighted", "sweighted", "sweighted2")
pairs(gy_res)
</code></pre>

<hr>
<h2 id='StressAnxiety'>Dependency of Anxiety on Stress</h2><span id='topic+StressAnxiety'></span>

<h3>Description</h3>

<p>Stress and anxiety among nonclinical women in Townsville, Queensland, Australia.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("StressAnxiety")</code></pre>


<h3>Format</h3>

<p>A data frame containing 166 observations on 2 variables.
</p>

<dl>
<dt>stress</dt><dd><p>score, linearly transformed to the open unit
interval (see below).</p>
</dd>
<dt>anxiety</dt><dd><p>score, linearly transformed to the open unit
interval (see below).</p>
</dd>
</dl>



<h3>Details</h3>

<p>Both variables were assess on the Depression Anxiety Stress Scales, ranging
from 0 to 42. Smithson and Verkuilen (2006) transformed these to the open
unit interval (without providing details about this transformation).
</p>


<h3>Source</h3>

<p>Example 2 from Smithson and Verkuilen (2006) supplements.
</p>


<h3>References</h3>

<p>Smithson, M., and Verkuilen, J. (2006).
A Better Lemon Squeezer? Maximum-Likelihood Regression with
Beta-Distributed Dependent Variables.
<em>Psychological Methods</em>, <b>11</b>(7), 54&ndash;71.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+betareg">betareg</a></code>, <code><a href="#topic+MockJurors">MockJurors</a></code>, <code><a href="#topic+ReadingSkills">ReadingSkills</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data("StressAnxiety", package = "betareg")
StressAnxiety &lt;- StressAnxiety[order(StressAnxiety$stress),]

## Smithson &amp; Verkuilen (2006, Table 4)
sa_null &lt;- betareg(anxiety ~ 1 | 1,
  data = StressAnxiety, hessian = TRUE)
sa_stress &lt;- betareg(anxiety ~ stress | stress,
  data = StressAnxiety, hessian = TRUE)
summary(sa_null)
summary(sa_stress)
AIC(sa_null, sa_stress)
1 - as.vector(logLik(sa_null)/logLik(sa_stress))

## visualization
attach(StressAnxiety)
plot(jitter(anxiety) ~ jitter(stress),
  xlab = "Stress", ylab = "Anxiety",
  xlim = c(0, 1), ylim = c(0, 1))
lines(lowess(anxiety ~ stress))
lines(fitted(sa_stress) ~ stress, lty = 2)
lines(fitted(lm(anxiety ~ stress)) ~ stress, lty = 3)
legend("topleft", c("lowess", "betareg", "lm"), lty = 1:3, bty = "n")
detach(StressAnxiety)

## see demo("SmithsonVerkuilen2006", package = "betareg") for more details
</code></pre>

<hr>
<h2 id='summary.betareg'>Methods for betareg Objects</h2><span id='topic+print.betareg'></span><span id='topic+summary.betareg'></span><span id='topic+print.summary.betareg'></span><span id='topic+coef.betareg'></span><span id='topic+vcov.betareg'></span><span id='topic+bread.betareg'></span><span id='topic+estfun.betareg'></span><span id='topic+coeftest.betareg'></span><span id='topic+logLik.betareg'></span><span id='topic+terms.betareg'></span><span id='topic+model.frame.betareg'></span><span id='topic+model.matrix.betareg'></span><span id='topic+cooks.distance.betareg'></span><span id='topic+hatvalues.betareg'></span>

<h3>Description</h3>

<p>Methods for extracting information from fitted beta
regression model objects of class <code>"betareg"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'betareg'
summary(object, phi = NULL, type = "sweighted2", ...)

## S3 method for class 'betareg'
coef(object, model = c("full", "mean", "precision"), phi = NULL, ...)
## S3 method for class 'betareg'
vcov(object, model = c("full", "mean", "precision"), phi = NULL, ...)
## S3 method for class 'betareg'
bread(x, phi = NULL, ...)
## S3 method for class 'betareg'
estfun(x, phi = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.betareg_+3A_object">object</code>, <code id="summary.betareg_+3A_x">x</code></td>
<td>
<p>fitted model object of class <code>"betareg"</code>.</p>
</td></tr>
<tr><td><code id="summary.betareg_+3A_phi">phi</code></td>
<td>
<p>logical indicating whether the parameters in the precision model
(for phi) should be reported as full model parameters (<code>TRUE</code>) or
nuisance parameters (<code>FALSE</code>). The default is taken from
<code>object$phi</code>.</p>
</td></tr>
<tr><td><code id="summary.betareg_+3A_type">type</code></td>
<td>
<p>character specifying type of residuals to be included in the
summary output, see <code><a href="#topic+residuals.betareg">residuals.betareg</a></code>.</p>
</td></tr>
<tr><td><code id="summary.betareg_+3A_model">model</code></td>
<td>
<p>character specifying for which component of the model coefficients/covariance
should be extracted. (Only used if <code>phi</code> is <code>NULL</code>.)</p>
</td></tr>
<tr><td><code id="summary.betareg_+3A_...">...</code></td>
<td>
<p>currently not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A set of standard extractor functions for fitted model objects is available for
objects of class <code>"betareg"</code>, including methods to the generic functions
<code><a href="base.html#topic+print">print</a></code> and <code><a href="base.html#topic+summary">summary</a></code> which print the estimated
coefficients along with some further information. The <code>summary</code> in particular
supplies partial Wald tests based on the coefficients and the covariance matrix.
As usual, the <code>summary</code> method returns an object of class <code>"summary.betareg"</code>
containing the relevant summary statistics which can subsequently be printed
using the associated <code>print</code> method. Note that the default residuals
<code>"sweighted2"</code> might be burdensome to compute in large samples and hence might
need modification in such applications.
</p>
<p>A <code><a href="stats.html#topic+logLik">logLik</a></code> method is provided, hence <code><a href="stats.html#topic+AIC">AIC</a></code>
can be called to compute information criteria.
</p>


<h3>References</h3>

<p>Cribari-Neto, F., and Zeileis, A. (2010). Beta Regression in R.
<em>Journal of Statistical Software</em>, <b>34</b>(2), 1&ndash;24.
doi: <a href="https://doi.org/10.18637/jss.v034.i02">10.18637/jss.v034.i02</a>
</p>
<p>Ferrari, S.L.P., and Cribari-Neto, F. (2004).
Beta Regression for Modeling Rates and Proportions.
<em>Journal of Applied Statistics</em>, <b>31</b>(7), 799&ndash;815.
</p>
<p>Simas, A.B., and Barreto-Souza, W., and Rocha, A.V. (2010).
Improved Estimators for a General Class of Beta Regression Models.
<em>Computational Statistics &amp; Data Analysis</em>, <b>54</b>(2), 348&ndash;366.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+betareg">betareg</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>options(digits = 4)

data("GasolineYield", package = "betareg")

gy2 &lt;- betareg(yield ~ batch + temp | temp, data = GasolineYield)

summary(gy2)
coef(gy2)
vcov(gy2)
logLik(gy2)
AIC(gy2)

coef(gy2, model = "mean")
coef(gy2, model = "precision")
summary(gy2, phi = FALSE)
</code></pre>

<hr>
<h2 id='WeatherTask'>
Weather Task With Priming and Precise and Imprecise Probabilities 
</h2><span id='topic+WeatherTask'></span>

<h3>Description</h3>

<p>In this study participants were asked to judge how likely Sunday is to
be the hottest day of the week.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(WeatherTask)</code></pre>


<h3>Format</h3>

<p>A data frame with 345 observations on the following 3 variables.
</p>

<dl>
<dt><code>priming</code></dt><dd><p>a factor with levels <code>two-fold</code> (case
prime) and <code>seven-fold</code> (class prime).</p>
</dd>
<dt><code>eliciting</code></dt><dd><p>a factor with levels <code>precise</code> and
<code>imprecise</code> (lower and upper limit).</p>
</dd>
<dt><code>agreement</code></dt><dd><p>a numeric vector, probability indicated by
participants or the average between minimum and maximum
probability indicated.</p>
</dd>
</dl>



<h3>Details</h3>

<p>All participants in the study were either first- or second-year
undergraduate students in psychology, none of whom had a strong
background in probability or were familiar with imprecise probability
theories. 
</p>
<p>For <code>priming</code> the questions were:
</p>

<dl>
<dt>two-fold</dt><dd><p>[What is the probability that] the temperature at
Canberra airport on Sunday will be higher than every other day
next week?</p>
</dd>
<dt>seven-fold</dt><dd><p>[What is the probability that] the highest
temperature of the week at Canberra airport will occur on Sunday?</p>
</dd>
</dl>

<p>For <code>eliciting</code> the instructions were if
</p>

<dl>
<dt>precise</dt><dd><p>to assign a probability estimate,</p>
</dd>
<dt>imprecise</dt><dd><p>to assign a lower and upper probability estimate.</p>
</dd>
</dl>



<h3>Source</h3>

<p>Taken from Smithson et al. (2011) supplements.
</p>


<h3>References</h3>

<p>Smithson, M., Merkle, E.C., and Verkuilen, J. (2011). Beta
Regression Finite Mixture Models of Polarization and Priming.
<em>Journal of Educational and Behavioral Statistics</em>, <b>36</b>(6), 804&ndash;831.
doi: <a href="https://doi.org/10.3102/1076998610396893">10.3102/1076998610396893</a>
</p>
<p>Smithson, M., and Segale, C. (2009). Partition Priming in Judgments of
Imprecise Probabilities. <em>Journal of Statistical Theory and
Practice</em>, <b>3</b>(1), 169&ndash;181.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("WeatherTask", package = "betareg")
library("flexmix")
wt_betamix &lt;- betamix(agreement ~ 1, data = WeatherTask, k = 2,
  extra_components = extraComponent(type = "betareg", coef =
    list(mean = 0, precision = 2)),
  FLXconcomitant = FLXPmultinom(~ priming + eliciting))
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
