<!DOCTYPE html><html><head><title>Help for package bikm1</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {bikm1}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#ARI'><p>ARI function for agreement between two partitions</p></a></li>
<li><a href='#BIKM1_LBM_Binary'><p>BIKM1_LBM_Binary fitting procedure</p></a></li>
<li><a href='#BIKM1_LBM_Binary-class'><p>Class &quot;BIKM1_LBM_Binary&quot;</p></a></li>
<li><a href='#BIKM1_LBM_Poisson'><p>BIKM1_LBM_Poisson fitting procedure</p></a></li>
<li><a href='#BIKM1_LBM_Poisson-class'><p>Class &quot;BIKM1_LBM_Poisson&quot;</p></a></li>
<li><a href='#BIKM1_MLBM_Binary'><p>BIKM1_MLBM_Binary fitting procedure</p></a></li>
<li><a href='#BIKM1_MLBM_Binary-class'><p>Class &quot;BIKM1_MLBM_Binary&quot;</p></a></li>
<li><a href='#bikm1-package'><p>bikm1 package</p></a></li>
<li><a href='#BinBlocICL_LBM'><p>BinBlocICL_LBM function  for computation of the ICL criterion in the Binary LBM</p></a></li>
<li><a href='#BinBlocICL_MLBM'><p>BinBlocICL_MLBM function  for computation of the ICL criterion in the MLBM</p></a></li>
<li><a href='#BinBlocRnd_LBM'><p>BinBlocRnd_LBM function for binary data matrix simulation</p></a></li>
<li><a href='#BinBlocRnd_MLBM'><p>BinBlocRnd_MLBM function for binary double data matrix simulation</p></a></li>
<li><a href='#BinBlocVisu_LBM'><p>BinBlocVisu_LBM function for visualization of binary matrix datasets</p></a></li>
<li><a href='#BinBlocVisu_MLBM'><p>BinBlocVisu_MLBM function for visualization of double matrix datasets</p></a></li>
<li><a href='#BinBlocVisuResum_LBM'><p>BinBlocVisuResum_LBM function  for visualization of binary matrix data-sets</p></a></li>
<li><a href='#BinBlocVisuResum_MLBM'><p>BinBlocVisuResum_MLBM function  for visualization of double matrix datasets</p></a></li>
<li><a href='#CARI'><p>CARI function for agreement between co-clustering partitions</p></a></li>
<li><a href='#CE_LBM'><p>CE_LBM function for agreement between co-clustering partitions</p></a></li>
<li><a href='#CE_MLBM'><p>CE_MLBM function for agreement between co-clustering partitions in the MBLM</p></a></li>
<li><a href='#CE_simple'><p>CE_simple function for agreement between clustering partitions</p></a></li>
<li><a href='#CoNMI'><p>CoNMI function for agreement between co-clustering partitions</p></a></li>
<li><a href='#ENMI'><p>ENMI function for agreement between co-clustering partitions</p></a></li>
<li><a href='#MI_simple'><p>MI_simple function for agreement between two partitions</p></a></li>
<li><a href='#NCE_LBM'><p>NCE_LBM function for agreement between co-clustering partitions using NCE_simple</p></a></li>
<li><a href='#NCE_simple'><p>NCE_simple function for agreement between clustering partitions</p></a></li>
<li><a href='#plot,BIKM1_LBM_Binary-method'><p>Plot method for a <code>BIKM1_LBM_Binary</code> object</p></a></li>
<li><a href='#plot,BIKM1_LBM_Poisson-method'><p>Plot method for a <code>BIKM1_LBM_Poisson</code> object</p></a></li>
<li><a href='#plot,BIKM1_MLBM_Binary-method'><p>Plot method for a <code>BIKM1_MLBM_Binary</code> object</p></a></li>
<li><a href='#PoissonBlocBIC'><p>PoissonBlocBIC function for the computation of the BIC criterion in the Poisson LBM</p></a></li>
<li><a href='#PoissonBlocICL'><p>PoissonBlocICL function for the computation of the ICL criterion in the Poisson LBM</p></a></li>
<li><a href='#PoissonBlocRnd'><p>PoissonBlocRnd function for contingency data simulation</p></a></li>
<li><a href='#PoissonBlocVisu'><p>PoissonBlocVisu function for visualization of contingency datasets</p></a></li>
<li><a href='#PoissonBlocVisuResum'><p>PoissonBlocVisuResum function  for visualization of contingency datasets</p></a></li>
<li><a href='#print,BIKM1_LBM_Binary-method'><p>Print method for a BIKM1_LBM_Binary object</p></a></li>
<li><a href='#print,BIKM1_LBM_Poisson-method'><p>Print method for a BIKM1_LBM_Poisson object</p></a></li>
<li><a href='#print,BIKM1_MLBM_Binary-method'><p>Print method for a BIKM1_MLBM_Binary object</p></a></li>
<li><a href='#show,BIKM1_LBM_Binary-method'><p>Show method for a BIKM1_LBM_Binary object</p></a></li>
<li><a href='#show,BIKM1_LBM_Poisson-method'><p>Show method for a BIKM1_LBM_Poisson object</p></a></li>
<li><a href='#show,BIKM1_MLBM_Binary-method'><p>Show method for a BIKM1_MLBM_Binary object</p></a></li>
<li><a href='#summary,BIKM1_LBM_Binary-method'><p>Summary method for a BIKM1_LBM_Binary object</p></a></li>
<li><a href='#summary,BIKM1_LBM_Poisson-method'><p>Summary method for a BIKM1_LBM_Poisson object</p></a></li>
<li><a href='#summary,BIKM1_MLBM_Binary-method'><p>Summary method for a BIKM1_MLBM_Binary object</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Co-Clustering Adjusted Rand Index and Bikm1 Procedure for
Contingency and Binary Data-Sets</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1.0</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Valerie Robert &lt;valerie.robert.math@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Co-clustering of the rows and columns of a contingency or binary matrix, or double binary matrices and model selection for the number of row and column clusters. Three models are considered: the Poisson latent block model for contingency matrix, the binary latent block model for binary matrix and a new model we develop: the multiple latent block model for double binary matrices. A new procedure named bikm1 is implemented to investigate more efficiently the grid of numbers of clusters. Then, the studied model selection criteria are the integrated completed likelihood (ICL) and the Bayesian integrated likelihood (BIC). Finally, the co-clustering adjusted Rand index (CARI) to measure agreement between co-clustering partitions is implemented. Robert Valerie, Vasseur Yann, Brault Vincent (2021) &lt;<a href="https://doi.org/10.1007%2Fs00357-020-09379-w">doi:10.1007/s00357-020-09379-w</a>&gt;.</td>
</tr>
<tr>
<td>Imports:</td>
<td>gtools, stats, graphics, grDevices, methods, parallel, ade4,
pracma, ggplot2, reshape2, grid, lpSolve</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-07-14 06:19:58 UTC; valerierobert</td>
</tr>
<tr>
<td>Author:</td>
<td>Valerie Robert [aut, cre]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-07-16 07:30:20 UTC</td>
</tr>
</table>
<hr>
<h2 id='ARI'>ARI function for agreement between two partitions</h2><span id='topic+ARI'></span>

<h3>Description</h3>

<p>Produce a measure of agreement between two partitions. A value of 1 means a perfect match.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ARI(v,vprime)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ARI_+3A_v">v</code></td>
<td>
<p>numeric vector  specifying the class of observations.</p>
</td></tr>
<tr><td><code id="ARI_+3A_vprime">vprime</code></td>
<td>
<p>numeric vector specifying another partitions of observations.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list including the arguments:
</p>
<p><code>ari</code>: value of the index.
</p>
<p><code>nv</code>: contingency table which the index is based on.
</p>


<h3>References</h3>

<p>Hubert and Arabie. Comparing partitions. Journal of
classification (1985).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(bikm1)
J=200
K=120
h=3
l=2
theta=list()
theta$rho_h=1/h *matrix(1,h,1)
theta$tau_l=1/l *matrix(1,l,1)
theta$gamma_hl=matrix(c(1, 6,4, 1, 7, 1),ncol=2)
data=PoissonBlocRnd(J,K,theta)
res=BIKM1_LBM_Poisson(data$x,4,4,4,init_choice='random')
mv=ARI(res@model_max$v, data$xrow)
mv$ari
mv$nv
mw=ARI(res@model_max$w, data$xcol)

</code></pre>

<hr>
<h2 id='BIKM1_LBM_Binary'>BIKM1_LBM_Binary fitting procedure</h2><span id='topic+BIKM1_LBM_Binary'></span>

<h3>Description</h3>

<p>Produce a blockwise estimation of a contingency matrix of observations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BIKM1_LBM_Binary(x,Gmax,Hmax,a=4,b=1,
Gstart=2,Hstart=2,init_choice='smallVBayes',userparam=NULL,
ntry=50,criterion_choice='ICL', mc.cores=1,verbose=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BIKM1_LBM_Binary_+3A_x">x</code></td>
<td>
<p>binary matrix of observations.</p>
</td></tr>
<tr><td><code id="BIKM1_LBM_Binary_+3A_gmax">Gmax</code></td>
<td>
<p>a positive integer less than number of rows.</p>
</td></tr>
<tr><td><code id="BIKM1_LBM_Binary_+3A_hmax">Hmax</code></td>
<td>
<p>a positive integer less than number of columns.The bikm1 procedure stops while the numbers of rows is higher than Gmax or the number of columns is higher than Hmax.</p>
</td></tr>
<tr><td><code id="BIKM1_LBM_Binary_+3A_a">a</code></td>
<td>
<p>hyperparameter used in the VBayes algorithm for priors on the mixing proportions.
By default, a=4.</p>
</td></tr>
<tr><td><code id="BIKM1_LBM_Binary_+3A_b">b</code></td>
<td>
<p>hyperparameter used in the VBayes algorithm for prior on the Bernoulli parameter.
By default, b=1.</p>
</td></tr>
<tr><td><code id="BIKM1_LBM_Binary_+3A_gstart">Gstart</code></td>
<td>
<p>a positive integer to initialize the procedure with number of row clusters.
By default, Gstart=2.</p>
</td></tr>
<tr><td><code id="BIKM1_LBM_Binary_+3A_hstart">Hstart</code></td>
<td>
<p>a positive integer to initialize the procedure with number of column clusters.
By default, Hstart=2.</p>
</td></tr>
<tr><td><code id="BIKM1_LBM_Binary_+3A_init_choice">init_choice</code></td>
<td>
<p>a character string corresponding to the chosen initialization strategy used for the procedure, which can be &quot;random&quot; or &quot;smallVBayes&quot; or &quot;user&quot;.
By default, init_choice=&quot;smallVBayes&quot;.</p>
</td></tr>
<tr><td><code id="BIKM1_LBM_Binary_+3A_userparam">userparam</code></td>
<td>
<p>in the case where init_choice is &quot;user&quot;, a list containing partitions z and w. By default userparam=NULL.</p>
</td></tr>
<tr><td><code id="BIKM1_LBM_Binary_+3A_ntry">ntry</code></td>
<td>
<p>a positive integer corresponding to the number of times which is launched the small VBayes or random initialization strategy. By default ntry=100.</p>
</td></tr>
<tr><td><code id="BIKM1_LBM_Binary_+3A_criterion_choice">criterion_choice</code></td>
<td>
<p>a character string corresponding to the chosen criterion used for model selection, which can be &quot;ICL&quot; as for now.
By default, criterion_choice=&quot;ICL&quot;.</p>
</td></tr>
<tr><td><code id="BIKM1_LBM_Binary_+3A_mc.cores">mc.cores</code></td>
<td>
<p>a positive integer corresponding to the available number of cores for parallel computing.
By default, mc.cores=1.</p>
</td></tr>
<tr><td><code id="BIKM1_LBM_Binary_+3A_verbose">verbose</code></td>
<td>
<p>logical. To display each step and the result. By default verbose=TRUE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a BIKM1_LBM_Binary object including
</p>
<p><code>model_max</code>: the selected model by the procedure with free energy W, theta, conditional probabilities (s_ig, r_jh), iter, empty_cluster, and the selected partitions z and w.
</p>
<p><code>criterion_choice</code>: the chosen criterion
</p>
<p><code>init_choice</code>: the chosen init choice
</p>
<p><code>criterion tab</code>:  the matrix containing the criterion values for each selected number of row and column
</p>
<p><code>W_tab</code>: the matrix containing the free energy values for each selected number of row and column
</p>
<p><code>criterion_max</code>: the maximum of the criterion values
</p>
<p><code>gopt</code>: the selected number of rows
</p>
<p><code>hopt</code>: the selected number of columns
</p>


<h3>References</h3>

<p>Govaert and Nadif. Co-clustering, Wyley (2013).
</p>
<p>Keribin, Brault and Celeux. Estimation and Selection for the Latent Block Model on Categorical Data, Statistics and Computing (2014).
</p>
<p>Robert. Classification crois\'ee pour l'analyse de bases de donn\'ees de grandes dimensions de pharmacovigilance. Paris Saclay (2017).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
require(bikm1)
set.seed(42)
n=200
J=120
g=3
h=2
theta=list()
theta$pi_g=1/g *matrix(1,g,1)
theta$rho_h=1/h *matrix(1,h,1)
theta$alpha_gh=matrix(runif(6),ncol=h)
data=BinBlocRnd_LBM(n,J,theta)
res=BIKM1_LBM_Binary(data$x,3,2,Gstart=3,Hstart=2,
init_choice='user',userparam=list(z=data$xrow,v=data$xcol))

</code></pre>

<hr>
<h2 id='BIKM1_LBM_Binary-class'>Class &quot;BIKM1_LBM_Binary&quot;</h2><span id='topic+BIKM1_LBM_Binary-class'></span>

<h3>Description</h3>

<p>Class of object returned by the <code><a href="#topic+BIKM1_LBM_Binary">BIKM1_LBM_Binary</a></code> function.
</p>


<h3>Slots</h3>


<dl>
<dt><code>model_max</code>: </dt><dd><p>The selected model by the procedure with free energy W, theta, conditional probabilities (s_ig, r_jh), iter, empty_cluster, and the selected partitions z and v.</p>
</dd>
<dt><code>criterion_choice</code>: </dt><dd><p>A character string corresponding to the chosen criterion used for model selection, which can be &quot;ICL&quot; or &quot;BIC&quot;.</p>
</dd>
<dt><code>init_choice</code>: </dt><dd><p>A character string corresponding to the chosen initialization strategy used for the procedure, which can be &quot;random&quot; or &quot;Gibbs&quot; or &quot;smallVBayes&quot;.</p>
</dd>
<dt><code>criterion_tab</code>: </dt><dd><p>The matrix corresponding to the values of the chosen criterion for pairs of numbers of clusters visited by the BIKM1_LBM_Binary function. The matrix rows design the numbers of row clusters. If a pair is not visited, by default, the value is -Inf.</p>
</dd>
<dt><code>W_tab</code>: </dt><dd><p>The matrix corresponding to the values of the free energy (minimizer of the loglikelihood in the algorithm) for pairs of numbers of clusters visited by the procedure. The matrix rows design the numbers of row clusters. If a pair is not visited, by default, the value is -Inf.</p>
</dd>
<dt><code>criterion_max</code>: </dt><dd><p>Numeric indicating the maximum of the criterion values, calculated on the pairs of numbers of clusters visited by the BIKM1_LBM_Binary function.</p>
</dd>
<dt><code>gopt</code>: </dt><dd><p>An integer value indicating the number of row clusters selected by the BIKM1_LBM_Binary function.</p>
</dd>
<dt><code>hopt</code>: </dt><dd><p>An integer value indicating the number of column clusters selected by the BIKM1_LBM_Binary function.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>
require(bikm1)
n=200
J=120
g=3
h=2
theta=list()
theta$pi_g=1/g *matrix(1,g,1)
theta$rho_h=1/h *matrix(1,h,1)
theta$alpha_gh=matrix(runif(6),ncol=h)
data=BinBlocRnd_LBM(n,J,theta)
res=BIKM1_LBM_Binary(data$x,3,3,a=4,init_choice='smallVBayes')
</code></pre>

<hr>
<h2 id='BIKM1_LBM_Poisson'>BIKM1_LBM_Poisson fitting procedure</h2><span id='topic+BIKM1_LBM_Poisson'></span>

<h3>Description</h3>

<p>Produce a blockwise estimation of a contingency matrix of observations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BIKM1_LBM_Poisson(x,Hmax,Lmax,a=4,alpha=1,beta=0.01,
Hstart=2,Lstart=2,normalization=FALSE,init_choice='smallVBayes',
userparam=NULL,ntry=50,criterion_choice='ICL', mc.cores=1,verbose=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BIKM1_LBM_Poisson_+3A_x">x</code></td>
<td>
<p>contingency matrix of observations.</p>
</td></tr>
<tr><td><code id="BIKM1_LBM_Poisson_+3A_hmax">Hmax</code></td>
<td>
<p>a positive integer less than number of rows.</p>
</td></tr>
<tr><td><code id="BIKM1_LBM_Poisson_+3A_lmax">Lmax</code></td>
<td>
<p>a positive integer less than number of columns.The bikm1 procedure stops while the numbers of rows is higher than Hmax or the number of columns is higher than Lmax.</p>
</td></tr>
<tr><td><code id="BIKM1_LBM_Poisson_+3A_a">a</code></td>
<td>
<p>hyperparameter used in the VBayes algorithm for priors on the mixing proportions.
By default, a=4.</p>
</td></tr>
<tr><td><code id="BIKM1_LBM_Poisson_+3A_alpha">alpha</code></td>
<td>
<p>hyperparameter used in the VBayes algorithm for prior on the Poisson parameter.
By default, alpha=1.</p>
</td></tr>
<tr><td><code id="BIKM1_LBM_Poisson_+3A_beta">beta</code></td>
<td>
<p>hyperparameter used in the VBayes algorithm for prior on the Poisson parameter.
By default, beta=0.01.</p>
</td></tr>
<tr><td><code id="BIKM1_LBM_Poisson_+3A_hstart">Hstart</code></td>
<td>
<p>a positive integer to initialize the procedure with number of row clusters.
By default, Hstart=2.</p>
</td></tr>
<tr><td><code id="BIKM1_LBM_Poisson_+3A_lstart">Lstart</code></td>
<td>
<p>a positive integer to initialize the procedure with number of column clusters.
By default, Lstart=2.</p>
</td></tr>
<tr><td><code id="BIKM1_LBM_Poisson_+3A_normalization">normalization</code></td>
<td>
<p>logical. To use the normalized Poisson modelling in the Latent Block Model. By default normalization=FALSE.</p>
</td></tr>
<tr><td><code id="BIKM1_LBM_Poisson_+3A_init_choice">init_choice</code></td>
<td>
<p>character string corresponding to the chosen initialization strategy used for the procedure, which can be &quot;random&quot; or &quot;Gibbs&quot; (higher time computation) or &quot;smallVBayes&quot; or &quot;user&quot;.
By default, init_choice=&quot;smallVBayes&quot;</p>
</td></tr>
<tr><td><code id="BIKM1_LBM_Poisson_+3A_userparam">userparam</code></td>
<td>
<p>In the case where init_choice is &quot;user&quot;, a list containing partitions v and w.</p>
</td></tr>
<tr><td><code id="BIKM1_LBM_Poisson_+3A_ntry">ntry</code></td>
<td>
<p>a positive integer corresponding to the number of times which is launched the small VBayes or random initialization strategy. By default ntry=50.</p>
</td></tr>
<tr><td><code id="BIKM1_LBM_Poisson_+3A_criterion_choice">criterion_choice</code></td>
<td>
<p>Character string corresponding to the chosen criterion used for model selection, which can be &quot;ICL&quot; or &quot;BIC&quot;.
By default, criterion_choice=&quot;ICL&quot;.</p>
</td></tr>
<tr><td><code id="BIKM1_LBM_Poisson_+3A_mc.cores">mc.cores</code></td>
<td>
<p>a positive integer corresponding to the available number of cores for parallel computing.
By default, mc.cores=1.</p>
</td></tr>
<tr><td><code id="BIKM1_LBM_Poisson_+3A_verbose">verbose</code></td>
<td>
<p>logical. To display each step and the result. By default verbose=TRUE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a BIKM1_LBM_Poisson object including
</p>
<p><code>model_max</code>: the selected model by the procedure with free energy W, theta, conditional probabilities (r_jh, t_kl), iter, empty_cluster, and the selected partitions v and w.
</p>
<p><code>criterion_choice</code>: the chosen criterion
</p>
<p><code>init_choice</code>: the chosen init choice
</p>
<p><code>criterion tab</code>: matrix containing the criterion values for each selected number of row and column
</p>
<p><code>W_tab</code>: matrix containing the free energy values for each selected number of row and column
</p>
<p><code>criterion_max</code>: maximum of the criterion values
</p>
<p><code>hopt</code>: the selected number of rows
</p>
<p><code>lopt</code>: the selected number of columns
</p>


<h3>References</h3>

<p>Keribin, Celeux and Robert, The Latent Block Model: a useful model for high dimensional data.
https://hal.inria.fr/hal-01658589/document
</p>
<p>Govaert and Nadif. Co-clustering, Wyley (2013).
</p>
<p>Keribin, Brault and Celeux. Estimation and Selection for the Latent Block Model on Categorical Data, Statistics and Computing (2014).
</p>
<p>Robert. Classification crois\'ee pour l'analyse de bases de donn\'ees de grandes dimensions de pharmacovigilance. Paris Saclay (2017).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(bikm1)
J=200
K=120
h=3
l=2
theta=list()
theta$rho_h=1/h *matrix(1,h,1)
theta$tau_l=1/l *matrix(1,l,1)
theta$gamma_hl=matrix(c(1, 6,4, 1, 7, 1),ncol=2)
data=PoissonBlocRnd(J,K,theta)
res=BIKM1_LBM_Poisson(data$x,3,2,Hstart=3,Lstart=2,
init_choice='user',userparam=list(v=data$xrow,w=data$xcol))

</code></pre>

<hr>
<h2 id='BIKM1_LBM_Poisson-class'>Class &quot;BIKM1_LBM_Poisson&quot;</h2><span id='topic+BIKM1_LBM_Poisson-class'></span>

<h3>Description</h3>

<p>Class of object returned by the <code><a href="#topic+BIKM1_LBM_Poisson">BIKM1_LBM_Poisson</a></code> function.
</p>


<h3>Slots</h3>


<dl>
<dt><code>model_max</code>: </dt><dd><p>The selected model by the procedure with free energy W, theta, conditional probabilities (r_jh, t_kl), iter, empty_cluster, and the selected partitions v and w. </p>
</dd>
<dt><code>criterion_choice</code>: </dt><dd><p>A character string corresponding to the chosen criterion used for model selection, which can be &quot;ICL&quot; or &quot;BIC&quot;.</p>
</dd>
<dt><code>init_choice</code>: </dt><dd><p>A character string corresponding to the chosen initialization strategy used for the procedure, which can be &quot;random&quot; or &quot;Gibbs&quot; or &quot;smallVBayes&quot;.</p>
</dd>
<dt><code>criterion_tab</code>: </dt><dd><p>The matrix corresponding to the values of the chosen criterion for pairs of numbers of clusters visited by the BIKM1_LBM_Poisson function. The matrix rows design the numbers of row clusters. If a pair is not visited, by default, the value is -Inf.</p>
</dd>
<dt><code>W_tab</code>: </dt><dd><p>The matrix corresponding to the values of the free energy (minimizer of the loglikelihood in the algorithm) for pairs of numbers of clusters visited by the procedure. The matrix rows design the numbers of row clusters. If a pair is not visited, by default, the value is -Inf.</p>
</dd>
<dt><code>criterion_max</code>: </dt><dd><p>Numeric indicating the maximum of the criterion values, calculated on the pairs of numbers of clusters visited by the BIKM1_LBM_Poisson function.</p>
</dd>
<dt><code>lopt</code>: </dt><dd><p>An Integer value indicating the number of row clusters selected by the BIKM1_LBM_Poisson function.</p>
</dd>
<dt><code>hopt</code>: </dt><dd><p>An integer value indicating the number of column clusters selected by the BIKM1_LBM_Poisson function.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>
require(bikm1)
set.seed(42)
J=200
K=120
h=3
l=2
theta=list()
theta$rho_h=1/h *matrix(1,h,1)
theta$tau_l=1/l *matrix(1,l,1)
theta$gamma_hl=matrix(floor(runif(h*l)*20+1),ncol=l)
data=PoissonBlocRnd(J,K,theta)
res=BIKM1_LBM_Poisson(data$x,3,3,4,init_choice='smallVBayes')
</code></pre>

<hr>
<h2 id='BIKM1_MLBM_Binary'>BIKM1_MLBM_Binary fitting procedure</h2><span id='topic+BIKM1_MLBM_Binary'></span>

<h3>Description</h3>

<p>Produce a blockwise estimation of  double matrices of observations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BIKM1_MLBM_Binary(x,y,Gmax,Hmax,Lmax,a=4,b=1,
Gstart=2,Hstart=2,Lstart=2,init_choice='smallVBayes',userparam=NULL,
ntry=50,criterion_choice='ICL', mc.cores=1,verbose=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BIKM1_MLBM_Binary_+3A_x">x</code></td>
<td>
<p>matrix of observations (1rst matrix).</p>
</td></tr>
<tr><td><code id="BIKM1_MLBM_Binary_+3A_y">y</code></td>
<td>
<p>matrix of observations (2nd matrix).</p>
</td></tr>
<tr><td><code id="BIKM1_MLBM_Binary_+3A_gmax">Gmax</code></td>
<td>
<p>a positive integer less than number of rows.</p>
</td></tr>
<tr><td><code id="BIKM1_MLBM_Binary_+3A_hmax">Hmax</code></td>
<td>
<p>a positive integer less than number of columns of the 1st matrix.</p>
</td></tr>
<tr><td><code id="BIKM1_MLBM_Binary_+3A_lmax">Lmax</code></td>
<td>
<p>a positive integer less than number of columns of the 2nd matrix. The bikm1 procedure stops while the numbers of rows is higher than Gmax or the number of columns is higher than Hmax or the numbers of columns(2nd matrix) is higher than Lmax.</p>
</td></tr>
<tr><td><code id="BIKM1_MLBM_Binary_+3A_a">a</code></td>
<td>
<p>hyperparameter used in the VBayes algorithm for priors on the mixing proportions.
By default, a=4.</p>
</td></tr>
<tr><td><code id="BIKM1_MLBM_Binary_+3A_b">b</code></td>
<td>
<p>hyperparameter used in the VBayes algorithm for prior on the Bernoulli parameter.
By default, b=1.</p>
</td></tr>
<tr><td><code id="BIKM1_MLBM_Binary_+3A_gstart">Gstart</code></td>
<td>
<p>a positive integer to initialize the procedure with number of row clusters.
By default, Gstart=2.</p>
</td></tr>
<tr><td><code id="BIKM1_MLBM_Binary_+3A_hstart">Hstart</code></td>
<td>
<p>a positive integer to initialize the procedure with number of column clusters.
By default, Hstart=2.</p>
</td></tr>
<tr><td><code id="BIKM1_MLBM_Binary_+3A_lstart">Lstart</code></td>
<td>
<p>a positive integer to initialize the procedure with number of column clusters.
By default, Lstart=2.</p>
</td></tr>
<tr><td><code id="BIKM1_MLBM_Binary_+3A_init_choice">init_choice</code></td>
<td>
<p>character string corresponding to the chosen initialization strategy used for the procedure, which can be &quot;random&quot; or &quot;smallVBayes&quot; or &quot;user&quot;.
By default, init_choice=&quot;smallVBayes&quot;.</p>
</td></tr>
<tr><td><code id="BIKM1_MLBM_Binary_+3A_userparam">userparam</code></td>
<td>
<p>In the case where init_choice is &quot;user&quot;, a list containing partitions z,v and w.</p>
</td></tr>
<tr><td><code id="BIKM1_MLBM_Binary_+3A_ntry">ntry</code></td>
<td>
<p>a positive integer corresponding to the number of times which is launched the small VBayes initialization strategy. By default ntry=100.</p>
</td></tr>
<tr><td><code id="BIKM1_MLBM_Binary_+3A_criterion_choice">criterion_choice</code></td>
<td>
<p>Character string corresponding to the chosen criterion used for model selection, which can be &quot;ICL&quot; as for now.
By default, criterion_choice=&quot;ICL&quot;.</p>
</td></tr>
<tr><td><code id="BIKM1_MLBM_Binary_+3A_mc.cores">mc.cores</code></td>
<td>
<p>a positive integer corresponding to the available number of cores for parallel computing.
By default, mc.cores=1.</p>
</td></tr>
<tr><td><code id="BIKM1_MLBM_Binary_+3A_verbose">verbose</code></td>
<td>
<p>logical. To display each step and the result. By default verbose=TRUE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a BIKM1_MLBM_Binary object including
</p>
<p><code>model_max</code>: the selected model by the procedure including free energy W, theta, conditional probabilities (s_ig, r_jh,t_kl), iter, empty_cluster, and the selected partitions z,v and w.
</p>
<p><code>criterion_choice</code>: the chosen criterion
</p>
<p><code>init_choice</code>: the chosen init_choice
</p>
<p><code>criterion_tab</code>: matrix containing the criterion values for each selected number of row and column
</p>
<p><code>W_tab</code>: matrix containing the free energy values for each selected number of row and column
</p>
<p><code>criterion_max</code>: maximum of the criterion values
</p>
<p><code>gopt</code>: the selected number of rows
</p>
<p><code>hopt</code>: the selected number of columns (1rst matrix)
</p>
<p><code>lopt</code>: the selected number of columns (2nd matrix)
</p>


<h3>References</h3>

<p>Govaert and Nadif. Co-clustering, Wyley (2013).
</p>
<p>Keribin, Brault and Celeux. Estimation and Selection for the Latent Block Model on Categorical Data, Statistics and Computing (2014).
</p>
<p>Robert. Classification crois\'ee pour l'analyse de bases de donn\'ees de grandes dimensions de pharmacovigilance. Paris Saclay (2017).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
require(bikm1)
set.seed(42)
n=200
J=120
K=120
g=3
h=2
l=2
theta=list()
theta$pi_g=1/g *matrix(1,g,1)
theta$rho_h=1/h *matrix(1,h,1)
theta$tau_l=1/l *matrix(1,l,1)
theta$alpha_gh=matrix(runif(6),ncol=h)
theta$beta_gl=matrix(runif(6),ncol=l)
data=BinBlocRnd_MLBM(n,J,K,theta)
res=BIKM1_MLBM_Binary(data$x,data$y,3,2,2,Gstart=3,Hstart=2,Lstart=2,init_choice='user',
userparam=list(z=data$xrow,v=data$xcolx,w=data$xcoly))


</code></pre>

<hr>
<h2 id='BIKM1_MLBM_Binary-class'>Class &quot;BIKM1_MLBM_Binary&quot;</h2><span id='topic+BIKM1_MLBM_Binary-class'></span>

<h3>Description</h3>

<p>Class of object returned by the <code><a href="#topic+BIKM1_MLBM_Binary">BIKM1_MLBM_Binary</a></code> function.
</p>


<h3>Slots</h3>


<dl>
<dt><code>model_max</code>: </dt><dd><p>The selected model by the procedure with free energy W, theta, conditional probabilities (s_ig, r_jh, t_kl), iter, empty_cluster, and the selected partitions z, v and w. </p>
</dd>
<dt><code>criterion_choice</code>: </dt><dd><p>A character string corresponding to the chosen criterion used for model selection, which can be &quot;ICL&quot; or &quot;BIC&quot;.</p>
</dd>
<dt><code>init_choice</code>: </dt><dd><p>A character string corresponding to the chosen initialization strategy used for the procedure, which can be &quot;random&quot; or &quot;Gibbs&quot; or &quot;smallVBayes&quot;.</p>
</dd>
<dt><code>criterion_tab</code>: </dt><dd><p>The matrix corresponding to the values of the chosen criterion for pairs of numbers of clusters visited by the BIKM1_MLBM_Binary function. The matrix rows design the numbers of row clusters. If a pair is not visited, by default, the value is -Inf.</p>
</dd>
<dt><code>W_tab</code>: </dt><dd><p>The matrix corresponding to the values of the free energy (minimizer of the loglikelihood in the algorithm) for pairs of numbers of clusters visited by the procedure. The matrix rows design the numbers of row clusters. If a pair is not visited, by default, the value is -Inf.</p>
</dd>
<dt><code>criterion_max</code>: </dt><dd><p>Numeric indicating the maximum of the criterion values, calculated on the pairs of numbers of clusters visited by the BIKM1_MLBM_Binary function.</p>
</dd>
<dt><code>gopt</code>: </dt><dd><p>An integer value indicating the number of row clusters selected by the BIKM1_MLBM_Binary function.</p>
</dd>
<dt><code>hopt</code>: </dt><dd><p>An integer value indicating the number of column clusters for the first matrix selected by the BIKM1_MLBM_Binary function.</p>
</dd>
<dt><code>lopt</code>: </dt><dd><p>An integer value indicating the number of row clusters for the second matrix selected by the BIKM1_MLBM_Binary function.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>
require(bikm1)
n=200
J=120
K=120
g=3
h=2
l=2
theta=list()
theta$pi_g=1/g *matrix(1,g,1)
theta$rho_h=1/h *matrix(1,h,1)
theta$tau_l=1/l *matrix(1,l,1)
theta$alpha_gh=matrix(runif(6),ncol=h)
theta$beta_gl=matrix(runif(6),ncol=l)
data=BinBlocRnd_MLBM(n,J,K,theta)
res=BIKM1_MLBM_Binary(data$x,data$y,3,3,3,4,init_choice='smallVBayes')
</code></pre>

<hr>
<h2 id='bikm1-package'>bikm1 package</h2><span id='topic+bikm1-package'></span>

<h3>Description</h3>

<p>This package is designed to co-cluster a contingency (resp. binary) matrix, or  double binary matrices in blocks respectively under the (normalized or not) Poisson (resp binary) Latent Block Model and the Multiple Latent Block Model. It enables to automatically select the number of row and column clusters and to compare partition estimations with reference partitions.
</p>


<h3>Features</h3>

<p>Package for the segmentation of the rows and columns inducing a co-clustering and automatically select the number of row and column clusters.
</p>


<h3>Model 1 </h3>

<p><code><a href="#topic+BIKM1_LBM_Poisson">BIKM1_LBM_Poisson</a></code> . This fitting procedure produces a <code><a href="#topic+BIKM1_LBM_Poisson-class">BIKM1_LBM_Poisson</a></code> object.
</p>


<h3>Model 2 </h3>

<p><code><a href="#topic+BIKM1_LBM_Binary">BIKM1_LBM_Binary</a></code> . This fitting procedure produces a <code><a href="#topic+BIKM1_LBM_Binary-class">BIKM1_LBM_Binary</a></code> object.
</p>


<h3>Model 3</h3>

<p><code><a href="#topic+BIKM1_MLBM_Binary">BIKM1_MLBM_Binary</a></code> . This fitting procedure produces a <code><a href="#topic+BIKM1_MLBM_Binary-class">BIKM1_MLBM_Binary</a></code> object.
</p>


<h3>Technical remarks</h3>

<p>Display of the result with <code><a href="#topic+plot+2CBIKM1_LBM_Poisson-method">plot,BIKM1_LBM_Poisson-method</a></code> and
</p>
<p>with <code><a href="#topic+show+2CBIKM1_LBM_Poisson-method">show,BIKM1_LBM_Poisson-method</a></code>, with <code><a href="#topic+summary+2CBIKM1_LBM_Poisson-method">summary,BIKM1_LBM_Poisson-method</a></code> and with <code><a href="#topic+print+2CBIKM1_LBM_Poisson-method">print,BIKM1_LBM_Poisson-method</a></code>.
</p>
<p>Display of the result with <code><a href="#topic+plot+2CBIKM1_LBM_Binary-method">plot,BIKM1_LBM_Binary-method</a></code> and
</p>
<p>with <code><a href="#topic+show+2CBIKM1_LBM_Binary-method">show,BIKM1_LBM_Binary-method</a></code>, with <code><a href="#topic+summary+2CBIKM1_LBM_Binary-method">summary,BIKM1_LBM_Binary-method</a></code> and with <code><a href="#topic+print+2CBIKM1_LBM_Binary-method">print,BIKM1_LBM_Binary-method</a></code>.
</p>
<p>Display of the result with <code><a href="#topic+plot+2CBIKM1_MLBM_Binary-method">plot,BIKM1_MLBM_Binary-method</a></code> and
</p>
<p>with <code><a href="#topic+show+2CBIKM1_MLBM_Binary-method">show,BIKM1_MLBM_Binary-method</a></code>, with <code><a href="#topic+summary+2CBIKM1_MLBM_Binary-method">summary,BIKM1_MLBM_Binary-method</a></code> and with <code><a href="#topic+print+2CBIKM1_MLBM_Binary-method">print,BIKM1_MLBM_Binary-method</a></code>.
</p>


<h3>Author(s)</h3>

<p>Valerie Robert <a href="mailto:valerie.robert.math@gmail.com">valerie.robert.math@gmail.com</a>
</p>


<h3>References</h3>

<p>Keribin, Celeux and Robert, The Latent Block Model: a useful model for high dimensional data. https://hal.inria.fr/hal-01658589/document
</p>
<p>Govaert and Nadif. Co-clustering, Wyley (2013).
</p>
<p>Keribin, Brault and Celeux. Estimation and Selection for the Latent Block Model on Categorical Data, Statistics and Computing (2014).
</p>
<p>Robert. Classification croisee pour l'analyse de bases de donnees de grandes dimensions de pharmacovigilance. Thesis, Paris Saclay (2017).
</p>
<p>Robert, Vasseur and Brault. Comparing high dimensional partitions with the Co-clustering Adjusted Rand Index, Journal of Classification, 38(1), 158-186 (2021).
</p>

<hr>
<h2 id='BinBlocICL_LBM'>BinBlocICL_LBM function  for computation of the ICL criterion in the Binary LBM</h2><span id='topic+BinBlocICL_LBM'></span>

<h3>Description</h3>

<p>Produce a value of the ICL criterion in the Binary LBM.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BinBlocICL_LBM(a,b,x,z1,v1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BinBlocICL_LBM_+3A_a">a</code></td>
<td>
<p>an hyperparameter for priors on the mixing proportions. By default, a=4.</p>
</td></tr>
<tr><td><code id="BinBlocICL_LBM_+3A_b">b</code></td>
<td>
<p>an hyperparameter for prior on the Bernoulli parameter. By default, b=1.</p>
</td></tr>
<tr><td><code id="BinBlocICL_LBM_+3A_x">x</code></td>
<td>
<p>contingency matrix of observations.</p>
</td></tr>
<tr><td><code id="BinBlocICL_LBM_+3A_z1">z1</code></td>
<td>
<p>a numeric vector specifying the class of rows.</p>
</td></tr>
<tr><td><code id="BinBlocICL_LBM_+3A_v1">v1</code></td>
<td>
<p>a numeric vector specifying the class of columns.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a value of the ICL criterion.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(bikm1)
set.seed(42)
n=200
J=120
g=3
h=2
theta=list()
theta$pi_g=1/g *matrix(1,g,1)
theta$rho_h=1/h *matrix(1,h,1)
theta$alpha_gh=matrix(runif(6),ncol=h)
data=BinBlocRnd_LBM(n,J,theta)
BinBlocICL_LBM(a=4,b=1,data$x, data$xrow,data$xcol)
</code></pre>

<hr>
<h2 id='BinBlocICL_MLBM'>BinBlocICL_MLBM function  for computation of the ICL criterion in the MLBM</h2><span id='topic+BinBlocICL_MLBM'></span>

<h3>Description</h3>

<p>Produce a plot object representing the resumed co-clustered data-sets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BinBlocICL_MLBM(a,b,x,y,z1,v1,w1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BinBlocICL_MLBM_+3A_a">a</code></td>
<td>
<p>an hyperparameter for priors on the mixing proportions. By default, a=4.</p>
</td></tr>
<tr><td><code id="BinBlocICL_MLBM_+3A_b">b</code></td>
<td>
<p>an hyperparameter for prior on the Bernoulli parameter. By default, b=1.</p>
</td></tr>
<tr><td><code id="BinBlocICL_MLBM_+3A_x">x</code></td>
<td>
<p>binary matrix of observations (1rst matrix).</p>
</td></tr>
<tr><td><code id="BinBlocICL_MLBM_+3A_y">y</code></td>
<td>
<p>binary matrix of observations (2nd matrix).</p>
</td></tr>
<tr><td><code id="BinBlocICL_MLBM_+3A_z1">z1</code></td>
<td>
<p>a numeric vector specifying the class of rows.</p>
</td></tr>
<tr><td><code id="BinBlocICL_MLBM_+3A_v1">v1</code></td>
<td>
<p>a numeric vector specifying the class of columns (1rst matrix).</p>
</td></tr>
<tr><td><code id="BinBlocICL_MLBM_+3A_w1">w1</code></td>
<td>
<p>a numeric vector specifying the class of columns (2nd matrix).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a value of the ICL criterion.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(bikm1)
set.seed(42)
n=200
J=120
K=120
g=2
h=2
l=2
theta=list()
theta$pi_g=1/g *matrix(1,g,1)
theta$rho_h=1/h *matrix(1,h,1)
theta$tau_l=1/l *matrix(1,l,1)
theta$alpha_gh=matrix(runif(4),ncol=h)
theta$beta_gl=matrix(runif(4),ncol=l)
data=BinBlocRnd_MLBM(n,J,K,theta)
res=BIKM1_MLBM_Binary(data$x,data$y,2,2,2,4,init_choice='smallVBayes')
BinBlocICL_MLBM(a=4,b=1,data$x,data$y, data$xrow,data$xcolx,data$xcoly)
</code></pre>

<hr>
<h2 id='BinBlocRnd_LBM'>BinBlocRnd_LBM function for binary data matrix simulation</h2><span id='topic+BinBlocRnd_LBM'></span>

<h3>Description</h3>

<p>Produce a data matrix generated under the Binary Latent Block Model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BinBlocRnd_LBM(n,J,theta)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BinBlocRnd_LBM_+3A_n">n</code></td>
<td>
<p>a positive integer specifying the number of expected rows.</p>
</td></tr>
<tr><td><code id="BinBlocRnd_LBM_+3A_j">J</code></td>
<td>
<p>a positive integer specifying the number of expected columns.</p>
</td></tr>
<tr><td><code id="BinBlocRnd_LBM_+3A_theta">theta</code></td>
<td>
<p>a list specifying the model parameters:
</p>
<p><code>pi_g</code>: a vector specifying the row mixing proportions.
</p>
<p><code>rho_h</code>: a vector specifying the matrix column mixing proportions.
</p>
<p><code>alpha_gh</code>: a matrix specifying the distribution parameter of the matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list including the arguments:
</p>
<p><code>x</code>: simulated  data matrix.
</p>
<p><code>xrow</code>: numeric vector specifying row partition.
</p>
<p><code>xcol</code>: numeric vector specifying  column partition.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(bikm1)
set.seed(42)
n=200
J=120
g=3
h=2
theta=list()
theta$pi_g=1/g *matrix(1,g,1)
theta$rho_h=1/h *matrix(1,h,1)
theta$alpha_gh=matrix(runif(6),ncol=h)
data=BinBlocRnd_LBM(n,J,theta)

</code></pre>

<hr>
<h2 id='BinBlocRnd_MLBM'>BinBlocRnd_MLBM function for binary double data matrix simulation</h2><span id='topic+BinBlocRnd_MLBM'></span>

<h3>Description</h3>

<p>Produce two simulated data matrices generated under the Binary Multiple Latent Block Model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BinBlocRnd_MLBM(n,J,K,theta)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BinBlocRnd_MLBM_+3A_n">n</code></td>
<td>
<p>a positive integer specifying the number of expected rows.</p>
</td></tr>
<tr><td><code id="BinBlocRnd_MLBM_+3A_j">J</code></td>
<td>
<p>a positive integer specifying the number of expected columns of the first matrix.</p>
</td></tr>
<tr><td><code id="BinBlocRnd_MLBM_+3A_k">K</code></td>
<td>
<p>a positive integer specifying the number of expected columns of the second matrix.</p>
</td></tr>
<tr><td><code id="BinBlocRnd_MLBM_+3A_theta">theta</code></td>
<td>
<p>a list specifying the model parameters:
</p>
<p><code>pi_g</code>: a vector specifying the row mixing proportions.
</p>
<p><code>rho_h</code>: a vector specifying the first matrix column mixing proportions.
</p>
<p><code>tau_l</code>: a vector specifying the second matrix column mixing proportions.
</p>
<p><code>alpha_gh</code>: a matrix specifying the distribution parameter of the first matrix.
</p>
<p><code>beta_gl</code>: a matrix specifying the distribution parameter of the second matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list including the arguments:
</p>
<p><code>x</code>: simulated first  data matrix.
<code>y</code>: simulated second data matrix.
</p>
<p><code>xrow</code>: numeric vector specifying row partition.
</p>
<p><code>xcolx</code>: numeric vector specifying first matrix column partition.
</p>
<p><code>xcoly</code>: numeric vector specifying second matrix column partition.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(bikm1)
set.seed(42)
n=200
J=120
K=120
g=3
h=2
l=2
theta=list()
theta$pi_g=1/g *matrix(1,g,1)
theta$rho_h=1/h *matrix(1,h,1)
theta$tau_l=1/l *matrix(1,l,1)
theta$alpha_gh=matrix(runif(6),ncol=h)
theta$beta_gl=matrix(runif(6),ncol=l)
data=BinBlocRnd_MLBM(n,J,K,theta)

</code></pre>

<hr>
<h2 id='BinBlocVisu_LBM'>BinBlocVisu_LBM function for visualization of binary matrix datasets</h2><span id='topic+BinBlocVisu_LBM'></span>

<h3>Description</h3>

<p>Produce a plot object representing the co-clustered data-sets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BinBlocVisu_LBM(x,z,v)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BinBlocVisu_LBM_+3A_x">x</code></td>
<td>
<p>data matrix of observations.</p>
</td></tr>
<tr><td><code id="BinBlocVisu_LBM_+3A_z">z</code></td>
<td>
<p>a numeric vector specifying the class of rows.</p>
</td></tr>
<tr><td><code id="BinBlocVisu_LBM_+3A_v">v</code></td>
<td>
<p>a numeric vector specifying the class of columns.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <span class="pkg">plot</span> object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
require(bikm1)
set.seed(42)
n=200
J=120
g=3
h=2
theta=list()
theta$pi_g=1/g *matrix(1,g,1)
theta$rho_h=1/h *matrix(1,h,1)
theta$alpha_gh=matrix(runif(6),ncol=h)
data=BinBlocRnd_LBM(n,J,theta)
BinBlocVisu_LBM(data$x,data$xrow,data$xcol)
</code></pre>

<hr>
<h2 id='BinBlocVisu_MLBM'>BinBlocVisu_MLBM function for visualization of double matrix datasets</h2><span id='topic+BinBlocVisu_MLBM'></span>

<h3>Description</h3>

<p>Produce a plot object representing the co-clustered data-sets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BinBlocVisu_MLBM(x,y,z,v,w)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BinBlocVisu_MLBM_+3A_x">x</code></td>
<td>
<p>first data matrix of observations.</p>
</td></tr>
<tr><td><code id="BinBlocVisu_MLBM_+3A_y">y</code></td>
<td>
<p>second data matrix of observations.</p>
</td></tr>
<tr><td><code id="BinBlocVisu_MLBM_+3A_z">z</code></td>
<td>
<p>a numeric vector specifying the class of rows.</p>
</td></tr>
<tr><td><code id="BinBlocVisu_MLBM_+3A_v">v</code></td>
<td>
<p>a numeric vector specifying the class of columns (1rst matrix).</p>
</td></tr>
<tr><td><code id="BinBlocVisu_MLBM_+3A_w">w</code></td>
<td>
<p>a numeric vector specifying the class of columns (2nd matrix).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <span class="pkg">plot</span> object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
require(bikm1)
set.seed(42)
n=200
J=120
K=120
g=3
h=2
l=2
theta=list()
theta$pi_g=1/g *matrix(1,g,1)
theta$rho_h=1/h *matrix(1,h,1)
theta$tau_l=1/l *matrix(1,l,1)
theta$alpha_gh=matrix(runif(6),ncol=h)
theta$beta_gl=matrix(runif(6),ncol=l)
data=BinBlocRnd_MLBM(n,J,K,theta)
BinBlocVisu_MLBM(data$x,data$y, data$xrow,data$xcolx,data$xcoly)
</code></pre>

<hr>
<h2 id='BinBlocVisuResum_LBM'>BinBlocVisuResum_LBM function  for visualization of binary matrix data-sets</h2><span id='topic+BinBlocVisuResum_LBM'></span>

<h3>Description</h3>

<p>Produce a plot object representing the resumed co-clustered data-sets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BinBlocVisuResum_LBM(x,z,v)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BinBlocVisuResum_LBM_+3A_x">x</code></td>
<td>
<p>binary matrix of observations.</p>
</td></tr>
<tr><td><code id="BinBlocVisuResum_LBM_+3A_z">z</code></td>
<td>
<p>a numeric vector specifying the class of rows.</p>
</td></tr>
<tr><td><code id="BinBlocVisuResum_LBM_+3A_v">v</code></td>
<td>
<p>a numeric vector specifying the class of columns.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <span class="pkg">plot</span> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(bikm1)
set.seed(42)
n=200
J=120
g=3
h=2
theta=list()
theta$pi_g=1/g *matrix(1,g,1)
theta$rho_h=1/h *matrix(1,h,1)
theta$alpha_gh=matrix(runif(6),ncol=h)
data=BinBlocRnd_LBM(n,J,theta)
BinBlocVisuResum_LBM(data$x,data$xrow,data$xcol)
</code></pre>

<hr>
<h2 id='BinBlocVisuResum_MLBM'>BinBlocVisuResum_MLBM function  for visualization of double matrix datasets</h2><span id='topic+BinBlocVisuResum_MLBM'></span>

<h3>Description</h3>

<p>Produce a plot object representing the resumed co-clustered data-sets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BinBlocVisuResum_MLBM(x,y,z,v,w)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BinBlocVisuResum_MLBM_+3A_x">x</code></td>
<td>
<p>binary matrix of observations.</p>
</td></tr>
<tr><td><code id="BinBlocVisuResum_MLBM_+3A_y">y</code></td>
<td>
<p>binary second matrix of observations.</p>
</td></tr>
<tr><td><code id="BinBlocVisuResum_MLBM_+3A_z">z</code></td>
<td>
<p>a numeric vector specifying the class of rows.</p>
</td></tr>
<tr><td><code id="BinBlocVisuResum_MLBM_+3A_v">v</code></td>
<td>
<p>a numeric vector specifying the class of columns (1rst matrix).</p>
</td></tr>
<tr><td><code id="BinBlocVisuResum_MLBM_+3A_w">w</code></td>
<td>
<p>a numeric vector specifying the class of columns (2nd matrix).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <span class="pkg">plot</span> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(bikm1)
set.seed(42)
n=200
J=120
K=120
g=3
h=2
l=2
theta=list()
theta$pi_g=1/g *matrix(1,g,1)
theta$rho_h=1/h *matrix(1,h,1)
theta$tau_l=1/l *matrix(1,l,1)
theta$alpha_gh=matrix(runif(6),ncol=h)
theta$beta_gl=matrix(runif(6),ncol=l)
data=BinBlocRnd_MLBM(n,J,K,theta)
BinBlocVisuResum_MLBM(data$x,data$y, data$xrow,data$xcolx,data$xcoly)
</code></pre>

<hr>
<h2 id='CARI'>CARI function for agreement between co-clustering partitions</h2><span id='topic+CARI'></span>

<h3>Description</h3>

<p>Produce a measure of agreement between two pairs of partitions for co-clustering. A value of 1 means a perfect match.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CARI(v,w,vprime,wprime)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CARI_+3A_v">v</code></td>
<td>
<p>numeric vector  specifying the class of  rows.</p>
</td></tr>
<tr><td><code id="CARI_+3A_w">w</code></td>
<td>
<p>numeric vector specifying the class of columns.</p>
</td></tr>
<tr><td><code id="CARI_+3A_vprime">vprime</code></td>
<td>
<p>numeric vector  specifying another partition of rows.</p>
</td></tr>
<tr><td><code id="CARI_+3A_wprime">wprime</code></td>
<td>
<p>numeric vector specifying another partition of columns.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list including the arguments:
</p>
<p><code>cari</code>: value of the index (between 0 and 1). A value of 1 corresponds to a perfect match.
</p>
<p><code>nvw</code>: contingency table which the index is based on.
</p>


<h3>References</h3>

<p>Robert, Vasseur and Brault. Comparing high dimensional partitions with the Co-clustering Adjusted Rand Index, Journal of classification 38 (1), 158-186 (2021).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(bikm1)
J=200
K=120
h=3
l=2
theta=list()
theta$rho_h=1/h *matrix(1,h,1)
theta$tau_l=1/l *matrix(1,l,1)
theta$gamma_hl=matrix(c(1, 6,4, 1, 7, 1),ncol=2)
data=PoissonBlocRnd(J,K,theta)
res=BIKM1_LBM_Poisson(data$x,4,4,4,init_choice='smallVBayes')
me=CARI(res@model_max$v,res@model_max$w, data$xrow,data$xcol)
me$cari
me$nvw
</code></pre>

<hr>
<h2 id='CE_LBM'>CE_LBM function for agreement between co-clustering partitions</h2><span id='topic+CE_LBM'></span>

<h3>Description</h3>

<p>Produce a measure of agreement between two pairs of partitions for co-clustering using CE_simple on columns and rows of a matrix. A value of 1 means a perfect match.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CE_LBM(v,w,vprime,wprime)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CE_LBM_+3A_v">v</code></td>
<td>
<p>numeric vector  specifying the class of  rows.</p>
</td></tr>
<tr><td><code id="CE_LBM_+3A_w">w</code></td>
<td>
<p>numeric vector  specifying the class of  columns.</p>
</td></tr>
<tr><td><code id="CE_LBM_+3A_vprime">vprime</code></td>
<td>
<p>numeric vector  specifying another partition of  rows.</p>
</td></tr>
<tr><td><code id="CE_LBM_+3A_wprime">wprime</code></td>
<td>
<p>numeric vector  specifying another partition of  columns.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>ce_vw: the value of the index (between 0 and 1). A value of 0 corresponds to a perfect match.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
require(bikm1)
set.seed(42)
v=floor(runif(4)*2)
vprime=floor(runif(4)*2)
w=floor(runif(4)*3)
wprime=floor(runif(4)*3)
error=CE_LBM(v,w,vprime,wprime)

</code></pre>

<hr>
<h2 id='CE_MLBM'>CE_MLBM function for agreement between co-clustering partitions in the MBLM</h2><span id='topic+CE_MLBM'></span>

<h3>Description</h3>

<p>Produce a measure of agreement between two triplets of partitions for co-clustering. A value of 1 means a perfect match.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CE_MLBM(z,v,w,zprime,vprime,wprime)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CE_MLBM_+3A_z">z</code></td>
<td>
<p>numeric vector  specifying the class of  rows.</p>
</td></tr>
<tr><td><code id="CE_MLBM_+3A_v">v</code></td>
<td>
<p>numeric vector specifying the class of column partitions for the first matrix.</p>
</td></tr>
<tr><td><code id="CE_MLBM_+3A_w">w</code></td>
<td>
<p>numeric vector specifying the class of column partitions for the second matrix.</p>
</td></tr>
<tr><td><code id="CE_MLBM_+3A_zprime">zprime</code></td>
<td>
<p>numeric vector  specifying another partitions of rows.</p>
</td></tr>
<tr><td><code id="CE_MLBM_+3A_vprime">vprime</code></td>
<td>
<p>numeric vector specifying another partition of columns for the first matrix.</p>
</td></tr>
<tr><td><code id="CE_MLBM_+3A_wprime">wprime</code></td>
<td>
<p>numeric vector specifying another partition of columns for the second matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the value of the index (between 0 and 1). A value of 0 corresponds to a perfect match.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
require(bikm1)
set.seed(42)
n=200
J=120
K=120
g=2
h=2
l=2
theta=list()
theta$pi_g=1/g *matrix(1,g,1)
theta$rho_h=1/h *matrix(1,h,1)
theta$tau_l=1/l *matrix(1,l,1)
theta$alpha_gh=matrix(runif(4),ncol=h)
theta$beta_gl=matrix(runif(4),ncol=l)
data=BinBlocRnd_MLBM(n,J,K,theta)
res=BIKM1_MLBM_Binary(data$x,data$y,2,2,2,4,init_choice='smallVBayes')
error=CE_MLBM(res@model_max$z,res@model_max$v,res@model_max$w,data$xrow,data$xcolx,data$xcoly)

</code></pre>

<hr>
<h2 id='CE_simple'>CE_simple function for agreement between clustering partitions</h2><span id='topic+CE_simple'></span>

<h3>Description</h3>

<p>Produce a measure of agreement between two  partitions for clustering. A value of 1 means a perfect match.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CE_simple(v,vprime)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CE_simple_+3A_v">v</code></td>
<td>
<p>numeric vector  specifying the class of  rows.</p>
</td></tr>
<tr><td><code id="CE_simple_+3A_vprime">vprime</code></td>
<td>
<p>numeric vector  specifying the class of  rows.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the value of the index.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
require(bikm1)
set.seed(42)
v=floor(runif(4)*3)
vprime=floor(runif(4)*3)
error=CE_simple(v,vprime)
error

</code></pre>

<hr>
<h2 id='CoNMI'>CoNMI function for agreement between co-clustering partitions</h2><span id='topic+CoNMI'></span>

<h3>Description</h3>

<p>Produce a measure of agreement between two pairs of partitions for co-clustering. A value of 1 means a perfect match.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CoNMI(v,w,vprime,wprime)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CoNMI_+3A_v">v</code></td>
<td>
<p>numeric vector  specifying the class of  rows.</p>
</td></tr>
<tr><td><code id="CoNMI_+3A_w">w</code></td>
<td>
<p>numeric vector specifying the class of columns.</p>
</td></tr>
<tr><td><code id="CoNMI_+3A_vprime">vprime</code></td>
<td>
<p>numeric vector  specifying another partition of rows.</p>
</td></tr>
<tr><td><code id="CoNMI_+3A_wprime">wprime</code></td>
<td>
<p>numeric vector specifying another partition of columns.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the value of the index.
</p>


<h3>References</h3>

<p>Robert, Vasseur and Brault. Comparing high dimensional partitions with the Co-clustering Adjusted Rand Index, Journal of Classification (2021).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(bikm1)
J=200
K=120
h=3
l=2
theta=list()
theta$rho_h=1/h *matrix(1,h,1)
theta$tau_l=1/l *matrix(1,l,1)
theta$gamma_hl=matrix(c(1, 6,4, 1, 7, 1),ncol=2)
data=PoissonBlocRnd(J,K,theta)
res=BIKM1_LBM_Poisson(data$x,4,4,4,init_choice='smallVBayes')
me=CoNMI(res@model_max$v,res@model_max$w, data$xrow,data$xcol)
me
</code></pre>

<hr>
<h2 id='ENMI'>ENMI function for agreement between co-clustering partitions</h2><span id='topic+ENMI'></span>

<h3>Description</h3>

<p>Produce a measure of agreement between two pairs of partitions for co-clustering. A value of 1 means a perfect match.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ENMI(v,w,vprime,wprime)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ENMI_+3A_v">v</code></td>
<td>
<p>numeric vector  specifying the class of  rows.</p>
</td></tr>
<tr><td><code id="ENMI_+3A_w">w</code></td>
<td>
<p>numeric vector specifying the class of columns.</p>
</td></tr>
<tr><td><code id="ENMI_+3A_vprime">vprime</code></td>
<td>
<p>numeric vector  specifying another partition of rows.</p>
</td></tr>
<tr><td><code id="ENMI_+3A_wprime">wprime</code></td>
<td>
<p>numeric vector specifying another partition of columns.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the value of the index.
</p>


<h3>References</h3>

<p>Robert, Vasseur and Brault. Comparing high dimensional partitions with the Co-clustering Adjusted Rand Index, Journal of Classification (2021).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(bikm1)
J=200
K=120
h=3
l=2
theta=list()
theta$rho_h=1/h *matrix(1,h,1)
theta$tau_l=1/l *matrix(1,l,1)
theta$gamma_hl=matrix(c(1, 6,4, 1, 7, 1),ncol=2)
data=PoissonBlocRnd(J,K,theta)
res=BIKM1_LBM_Poisson(data$x,4,4,4,init_choice='smallVBayes')
me=ENMI(res@model_max$v,res@model_max$w, data$xrow,data$xcol)
me
</code></pre>

<hr>
<h2 id='MI_simple'>MI_simple function for agreement between two partitions</h2><span id='topic+MI_simple'></span>

<h3>Description</h3>

<p>Produce a measure of agreement between two partitions.(between 0 and 1). A value of 1 corresponds to a perfect match.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MI_simple(v,vprime)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MI_simple_+3A_v">v</code></td>
<td>
<p>numeric vector  specifying the class of observations.</p>
</td></tr>
<tr><td><code id="MI_simple_+3A_vprime">vprime</code></td>
<td>
<p>numeric vector specifying another partitions of observations.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the value of the index.
</p>


<h3>References</h3>

<p>Robert, Vasseur and Brault. Comparing high-dimensional partitions with the Co-clustering Adjusted Rand Index. Journal of
Classification (2021).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(bikm1)
J=200
K=120
h=3
l=2
theta=list()
theta$rho_h=1/h *matrix(1,h,1)
theta$tau_l=1/l *matrix(1,l,1)
theta$gamma_hl=matrix(c(1, 6,4, 1, 7, 1),ncol=2)
data=PoissonBlocRnd(J,K,theta)
res=BIKM1_LBM_Poisson(data$x,4,4,4,init_choice='random')
mi=MI_simple(res@model_max$v, data$xrow)
mi
mw=MI_simple(res@model_max$w, data$xcol)

</code></pre>

<hr>
<h2 id='NCE_LBM'>NCE_LBM function for agreement between co-clustering partitions using NCE_simple</h2><span id='topic+NCE_LBM'></span>

<h3>Description</h3>

<p>Produce a measure of agreement between two pairs of partitions for co-clustering. A value of 1 means a perfect match.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NCE_LBM(v,w,vprime,wprime)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NCE_LBM_+3A_v">v</code></td>
<td>
<p>numeric vector  specifying the class of  rows.</p>
</td></tr>
<tr><td><code id="NCE_LBM_+3A_w">w</code></td>
<td>
<p>numeric vector  specifying the class of  columns.</p>
</td></tr>
<tr><td><code id="NCE_LBM_+3A_vprime">vprime</code></td>
<td>
<p>numeric vector  specifying another partition of  rows.</p>
</td></tr>
<tr><td><code id="NCE_LBM_+3A_wprime">wprime</code></td>
<td>
<p>numeric vector  specifying another partition of  columns.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the value of the index.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
require(bikm1)
set.seed(42)
v=floor(runif(4)*2)
vprime=floor(runif(4)*2)
w=floor(runif(4)*3)
wprime=floor(runif(4)*3)
error=NCE_LBM(v,w,vprime,wprime)

</code></pre>

<hr>
<h2 id='NCE_simple'>NCE_simple function for agreement between clustering partitions</h2><span id='topic+NCE_simple'></span>

<h3>Description</h3>

<p>Produce a measure of agreement between two  partitions for clustering. A value of 1 means a perfect match. It's the normalized version of CE_simple.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NCE_simple(v,vprime)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NCE_simple_+3A_v">v</code></td>
<td>
<p>numeric vector  specifying the class of  rows.</p>
</td></tr>
<tr><td><code id="NCE_simple_+3A_vprime">vprime</code></td>
<td>
<p>numeric vector  specifying the class of  rows.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the value of the index. A value of 0 means a perfect match.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
require(bikm1)
set.seed(42)
v=floor(runif(4)*3)
vprime=floor(runif(4)*3)
error=NCE_simple(v,vprime)
error

</code></pre>

<hr>
<h2 id='plot+2CBIKM1_LBM_Binary-method'>Plot method for a <code><a href="#topic+BIKM1_LBM_Binary-class">BIKM1_LBM_Binary</a></code> object</h2><span id='topic+plot+2CBIKM1_LBM_Binary-method'></span>

<h3>Description</h3>

<p>Produce respectively one plot of two-dimensional segmentation of a <code>BIKM1_LBM_Binary</code> fit, a plot of evolution of  the chosen criterion as a function of the number of row and column clusters, and a boxplot of conditional posteriors for each row and column cluster.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'BIKM1_LBM_Binary'
plot(x, y, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot+2B2CBIKM1_LBM_Binary-method_+3A_x">x</code></td>
<td>
<p>an object of class <code>BIKM1_LBM_Binary</code>.</p>
</td></tr>
<tr><td><code id="plot+2B2CBIKM1_LBM_Binary-method_+3A_y">y</code></td>
<td>
<p>binary matrix of observations.</p>
</td></tr>
<tr><td><code id="plot+2B2CBIKM1_LBM_Binary-method_+3A_...">...</code></td>
<td>
<p>in the plot method, additional parameters (ignored)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>One <span class="pkg">plot</span> (initial and estimated partitions) and three <span class="pkg">ggplot2</span> objects (conditional posterior in each cluster for each matrix and the graph
of chosen criterion values.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(bikm1)
g=5
h=3
theta=list()
theta$pi_g=t(1/g*rep(1,g))
theta$rho_h=t(1/h*rep(1,h))
eps=0.1
theta$alpha_gh=matrix(c(1-eps,eps,eps,eps,1-eps,eps,eps,1-eps,1-eps,
1-eps,1-eps,eps,eps,eps,eps),ncol=h,byrow=TRUE)
n=250
J=150
data=BinBlocRnd_LBM(n,J,theta)
BinBlocVisu_LBM(data$x, data$xrow,data$xcol)
res=BIKM1_LBM_Binary(data$x,8,5,4,init_choice='smallVBayes')
BinBlocVisu_LBM(data$x,res@model_max$z,res@model_max$v)
e=CARI(data$xrow,data$xcol,res@model_max$z,res@model_max$v)
plot(res,data)
</code></pre>

<hr>
<h2 id='plot+2CBIKM1_LBM_Poisson-method'>Plot method for a <code><a href="#topic+BIKM1_LBM_Poisson-class">BIKM1_LBM_Poisson</a></code> object</h2><span id='topic+plot+2CBIKM1_LBM_Poisson-method'></span>

<h3>Description</h3>

<p>Produce respectively one plot of two-dimensional segmentation of a <code>BIKM1_LBM_Poisson</code> fit, an evolution of the criterion as a function of the numbers of rows and columns, and a boxplot of conditional posteriors for each row and column cluster.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'BIKM1_LBM_Poisson'
plot(x, y, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot+2B2CBIKM1_LBM_Poisson-method_+3A_x">x</code></td>
<td>
<p>an object of class <code>BIKM1_LBM_Poisson</code>.</p>
</td></tr>
<tr><td><code id="plot+2B2CBIKM1_LBM_Poisson-method_+3A_y">y</code></td>
<td>
<p>a list specifying
</p>
<p><code>x</code> : contingency matrix of observations.</p>
</td></tr>
<tr><td><code id="plot+2B2CBIKM1_LBM_Poisson-method_+3A_...">...</code></td>
<td>
<p>in the plot method, additional parameters (ignored)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Two <span class="pkg">plot</span>s (initial matrix and block estimation) and two <span class="pkg">ggplot2</span> objects (conditional posterior in each cluster and the graph of chosen criterion values).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(bikm1)
J=200
K=120
h=3
l=2
theta=list()
theta$rho_h=1/h *matrix(1,h,1)
theta$tau_l=1/l *matrix(1,l,1)
theta$gamma_hl=matrix(c(1, 6,4, 1, 7, 1),ncol=2)
data=PoissonBlocRnd(J,K,theta)
res=BIKM1_LBM_Poisson(data$x,3,3,4,init_choice='random')
plot(res,data)
</code></pre>

<hr>
<h2 id='plot+2CBIKM1_MLBM_Binary-method'>Plot method for a <code><a href="#topic+BIKM1_MLBM_Binary-class">BIKM1_MLBM_Binary</a></code> object</h2><span id='topic+plot+2CBIKM1_MLBM_Binary-method'></span>

<h3>Description</h3>

<p>Produce respectively a plot of two-dimensional segmentation of a <code>BIKM1_MLBM_Binary</code> fit, and a boxplot of conditional posteriors for each row and column cluster.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'BIKM1_MLBM_Binary'
plot(x, y, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot+2B2CBIKM1_MLBM_Binary-method_+3A_x">x</code></td>
<td>
<p>an object of class <code>BIKM1_MLBM_Binary</code>.</p>
</td></tr>
<tr><td><code id="plot+2B2CBIKM1_MLBM_Binary-method_+3A_y">y</code></td>
<td>
<p>a list specifying :
</p>
<p><code>x</code>: the first matrix of observations
</p>
<p><code>y</code>: the second matrix of observations.</p>
</td></tr>
<tr><td><code id="plot+2B2CBIKM1_MLBM_Binary-method_+3A_...">...</code></td>
<td>
<p>in the plot method, additional parameters (ignored)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Two <span class="pkg">plot</span> and on <span class="pkg">ggplot2</span> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(bikm1)
n=200
J=120
K=120
g=3
h=2
l=2
theta=list()
theta$pi_g=1/g *matrix(1,g,1)
theta$rho_h=1/h *matrix(1,h,1)
theta$tau_l=1/l *matrix(1,l,1)
theta$alpha_gh=matrix(runif(6),ncol=h)
theta$beta_gl=matrix(runif(6),ncol=l)
data=BinBlocRnd_MLBM(n,J,K,theta)
res=BIKM1_MLBM_Binary(data$x,data$y,3,3,3,4)
plot(res,data)
</code></pre>

<hr>
<h2 id='PoissonBlocBIC'>PoissonBlocBIC function for the computation of the BIC criterion in the Poisson LBM</h2><span id='topic+PoissonBlocBIC'></span>

<h3>Description</h3>

<p>Produce a value of the BIC criterion for co-clustering partitions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PoissonBlocBIC(a,alpha,beta,v1,w1,x,res,normalization)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PoissonBlocBIC_+3A_a">a</code></td>
<td>
<p>hyperparameter used in the VBayes algorithm for priors on the mixing proportions. By default, a=4.</p>
</td></tr>
<tr><td><code id="PoissonBlocBIC_+3A_alpha">alpha</code></td>
<td>
<p>hyperparameter used in the VBayes algorithm for prior on the Poisson parameter. By default, alpha=1.</p>
</td></tr>
<tr><td><code id="PoissonBlocBIC_+3A_beta">beta</code></td>
<td>
<p>hyperparameter used in the VBayes algorithm for prior on the Poisson parameter. By default, beta=0.01.</p>
</td></tr>
<tr><td><code id="PoissonBlocBIC_+3A_v1">v1</code></td>
<td>
<p>a numeric vector of row partitions</p>
</td></tr>
<tr><td><code id="PoissonBlocBIC_+3A_w1">w1</code></td>
<td>
<p>a numeric vector of column partitions</p>
</td></tr>
<tr><td><code id="PoissonBlocBIC_+3A_x">x</code></td>
<td>
<p>contingency matrix of observations.</p>
</td></tr>
<tr><td><code id="PoissonBlocBIC_+3A_res">res</code></td>
<td>
<p>a BIKM1_LBM_Poisson object
<code>rho_h</code> mixing row proportions
<code>tau_l</code> mixing column proportions
<code>gamma_hl</code> Bernoulli parameters</p>
</td></tr>
<tr><td><code id="PoissonBlocBIC_+3A_normalization">normalization</code></td>
<td>
<p>logical. To use the normalized Poisson modelling in the Latent Block Model. By default normalization=FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a value of the BIC criterion
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(bikm1)
J=200
K=120
h=3
l=2
theta=list()
theta$rho_h=1/h*matrix(1,h,1)
theta$tau_l=1/l*matrix(1,l,1)
theta$gamma_hl=matrix(c(1, 6,4, 1, 7, 1),ncol=2)
data=PoissonBlocRnd(J,K,theta)
res=BIKM1_LBM_Poisson(data$x,3,3,4,init_choice='smallVBayes')
bic=PoissonBlocBIC(v1=res@model_max$v,w1=res@model_max$w,x=data$x,res=res,normalization=TRUE)
</code></pre>

<hr>
<h2 id='PoissonBlocICL'>PoissonBlocICL function for the computation of the ICL criterion in the Poisson LBM</h2><span id='topic+PoissonBlocICL'></span>

<h3>Description</h3>

<p>Produce a value of the ICL criterion for co-clustering partitions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PoissonBlocICL(a,alpha,beta,x,v1,w1,normalization)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PoissonBlocICL_+3A_a">a</code></td>
<td>
<p>hyperparameter used in the VBayes algorithm for priors on the mixing proportions. By default, a=4.</p>
</td></tr>
<tr><td><code id="PoissonBlocICL_+3A_alpha">alpha</code></td>
<td>
<p>hyperparameter used in the VBayes algorithm for prior on the Poisson parameter. By default, alpha=1.</p>
</td></tr>
<tr><td><code id="PoissonBlocICL_+3A_beta">beta</code></td>
<td>
<p>hyperparameter used in the VBayes algorithm for prior on the Poisson parameter. By default, beta=0.01.</p>
</td></tr>
<tr><td><code id="PoissonBlocICL_+3A_x">x</code></td>
<td>
<p>contingency matrix of observations.</p>
</td></tr>
<tr><td><code id="PoissonBlocICL_+3A_v1">v1</code></td>
<td>
<p>a numeric vector specifying the class of rows.</p>
</td></tr>
<tr><td><code id="PoissonBlocICL_+3A_w1">w1</code></td>
<td>
<p>a numeric vector specifying the class of columns.</p>
</td></tr>
<tr><td><code id="PoissonBlocICL_+3A_normalization">normalization</code></td>
<td>
<p>logical. To use the normalized Poisson modelling in the Latent Block Model. By default normalization=FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a value of the ICL criterion
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(bikm1)
J=200
K=120
h=3
l=2
theta=list()
theta$rho_h=(1/h)*matrix(1,h,1)
theta$tau_l=(1/l)*matrix(1,l,1)
theta$gamma_hl=matrix(c(1, 6,4, 1, 7, 1),ncol=2)
data=PoissonBlocRnd(J,K,theta)
res=BIKM1_LBM_Poisson(data$x,4,4,4,init_choice='smallVBayes')
icl=PoissonBlocICL(4,1,0.01,data$x,res@model_max$v,res@model_max$w, normalization=FALSE)
</code></pre>

<hr>
<h2 id='PoissonBlocRnd'>PoissonBlocRnd function for contingency data simulation</h2><span id='topic+PoissonBlocRnd'></span>

<h3>Description</h3>

<p>Produce a simulated data matrix generated under the Poisson Latent Block Model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PoissonBlocRnd(J,K,theta)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PoissonBlocRnd_+3A_j">J</code></td>
<td>
<p>a positive integer specifying the number of expected rows.</p>
</td></tr>
<tr><td><code id="PoissonBlocRnd_+3A_k">K</code></td>
<td>
<p>a positive integer specifying the number of expected columns.</p>
</td></tr>
<tr><td><code id="PoissonBlocRnd_+3A_theta">theta</code></td>
<td>
<p>a list specifying the model parameters:
</p>
<p><code>rho_h</code>: a vector specifying the row mixing proportions.
</p>
<p><code>tau_l</code>: a vector specifying the column mixing proportions.
</p>
<p><code>gamma_hl</code>: a matrix specifying the distribution parameter.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list including the arguments:
</p>
<p><code>x</code>: simulated contingency data matrix.
</p>
<p><code>xrow</code>: numeric vector specifying row partition.
</p>
<p><code>xcol</code>: numeric vector specifying column partition.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(bikm1)
J=200
K=120
h=3
l=2
theta=list()
theta$rho_h=1/h *matrix(1,h,1)
theta$tau_l=1/l *matrix(1,l,1)
theta$gamma_hl=matrix(c(1, 6,4, 1, 7, 1),ncol=2)
data=PoissonBlocRnd(J,K,theta)

</code></pre>

<hr>
<h2 id='PoissonBlocVisu'>PoissonBlocVisu function for visualization of contingency datasets</h2><span id='topic+PoissonBlocVisu'></span>

<h3>Description</h3>

<p>Produce a plot object representing the co-clustered data-sets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PoissonBlocVisu(x,v,w)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PoissonBlocVisu_+3A_x">x</code></td>
<td>
<p>contingency matrix of observations.</p>
</td></tr>
<tr><td><code id="PoissonBlocVisu_+3A_v">v</code></td>
<td>
<p>a numeric vector specifying the class of rows.</p>
</td></tr>
<tr><td><code id="PoissonBlocVisu_+3A_w">w</code></td>
<td>
<p>a numeric vector specifying the class of columns.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <span class="pkg">plot</span> object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
require(bikm1)
J=200
K=120
h=3
l=2
theta=list()
theta$rho_h=1/h *matrix(1,h,1)
theta$tau_l=1/l *matrix(1,l,1)
theta$gamma_hl=matrix(c(1, 6,4, 1, 7, 1),ncol=2)
data=PoissonBlocRnd(J,K,theta)
PoissonBlocVisu(data$x,data$xrow,data$xcol)
</code></pre>

<hr>
<h2 id='PoissonBlocVisuResum'>PoissonBlocVisuResum function  for visualization of contingency datasets</h2><span id='topic+PoissonBlocVisuResum'></span>

<h3>Description</h3>

<p>Produce a plot object representing the resumed co-clustered data-sets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PoissonBlocVisuResum(x,v,w)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PoissonBlocVisuResum_+3A_x">x</code></td>
<td>
<p>contingency matrix of observations.</p>
</td></tr>
<tr><td><code id="PoissonBlocVisuResum_+3A_v">v</code></td>
<td>
<p>a numeric vector specifying the class of rows.</p>
</td></tr>
<tr><td><code id="PoissonBlocVisuResum_+3A_w">w</code></td>
<td>
<p>a numeric vector specifying the class of columns.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <span class="pkg">plot</span> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(bikm1)
J=200
K=120
h=3
l=2
theta=list()
theta$rho_h=1/h *matrix(1,h,1)
theta$tau_l=1/l *matrix(1,l,1)
theta$gamma_hl=matrix(c(1, 6,4, 1, 7, 1),ncol=2)
data=PoissonBlocRnd(J,K,theta)
PoissonBlocVisuResum(data$x,data$xrow,data$xcol)
</code></pre>

<hr>
<h2 id='print+2CBIKM1_LBM_Binary-method'>Print method for a BIKM1_LBM_Binary object</h2><span id='topic+print+2CBIKM1_LBM_Binary-method'></span>

<h3>Description</h3>

<p>Print method for a <code><a href="#topic+BIKM1_LBM_Binary-class">BIKM1_LBM_Binary</a></code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'BIKM1_LBM_Binary'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print+2B2CBIKM1_LBM_Binary-method_+3A_x">x</code></td>
<td>
<p>in the print method, a BIKM1_LBM_Binary object</p>
</td></tr>
<tr><td><code id="print+2B2CBIKM1_LBM_Binary-method_+3A_...">...</code></td>
<td>
<p>in the print method, additional parameters (ignored)</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>require(bikm1)
n=200
J=120
g=3
h=2
theta=list()
theta$pi_g=1/g *matrix(1,g,1)
theta$rho_h=1/h *matrix(1,h,1)
theta$alpha_gh=matrix(runif(6),ncol=h)
data=BinBlocRnd_LBM(n,J,theta)
res=BIKM1_LBM_Binary(data$x,3,2,4,init_choice='random')
print(res)

</code></pre>

<hr>
<h2 id='print+2CBIKM1_LBM_Poisson-method'>Print method for a BIKM1_LBM_Poisson object</h2><span id='topic+print+2CBIKM1_LBM_Poisson-method'></span>

<h3>Description</h3>

<p>Print method for a <code><a href="#topic+BIKM1_LBM_Poisson-class">BIKM1_LBM_Poisson</a></code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'BIKM1_LBM_Poisson'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print+2B2CBIKM1_LBM_Poisson-method_+3A_x">x</code></td>
<td>
<p>in the print method, a BIKM1_LBM_Poisson object</p>
</td></tr>
<tr><td><code id="print+2B2CBIKM1_LBM_Poisson-method_+3A_...">...</code></td>
<td>
<p>in the print method, additional parameters (ignored)</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>require(bikm1)
J=200
K=120
h=3
l=2
theta=list()
theta$rho_h=1/h *matrix(1,h,1)
theta$tau_l=1/l *matrix(1,l,1)
theta$gamma_hl=matrix(c(1, 6,4, 1, 7, 1),ncol=2)
data=PoissonBlocRnd(J,K,theta)
res=BIKM1_LBM_Poisson(data$x,3,2,4,init_choice='random')
print(res)

</code></pre>

<hr>
<h2 id='print+2CBIKM1_MLBM_Binary-method'>Print method for a BIKM1_MLBM_Binary object</h2><span id='topic+print+2CBIKM1_MLBM_Binary-method'></span>

<h3>Description</h3>

<p>Print method for a <code><a href="#topic+BIKM1_MLBM_Binary-class">BIKM1_MLBM_Binary</a></code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'BIKM1_MLBM_Binary'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print+2B2CBIKM1_MLBM_Binary-method_+3A_x">x</code></td>
<td>
<p>in the print method, a BIKM1_MLBM_Binary object</p>
</td></tr>
<tr><td><code id="print+2B2CBIKM1_MLBM_Binary-method_+3A_...">...</code></td>
<td>
<p>in the print method, additional parameters (ignored)</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>require(bikm1)
n=200
J=120
K=120
g=3
h=2
l=2
theta=list()
theta$pi_g=1/g *matrix(1,g,1)
theta$rho_h=1/h *matrix(1,h,1)
theta$tau_l=1/l *matrix(1,l,1)
theta$alpha_gh=matrix(runif(6),ncol=h)
theta$beta_gl=matrix(runif(6),ncol=l)
data=BinBlocRnd_MLBM(n,J,K,theta)
res=BIKM1_MLBM_Binary(data$x,data$y,3,3,3,4)
print(res)

</code></pre>

<hr>
<h2 id='show+2CBIKM1_LBM_Binary-method'>Show method for a BIKM1_LBM_Binary object</h2><span id='topic+show+2CBIKM1_LBM_Binary-method'></span>

<h3>Description</h3>

<p>show method for a <code><a href="#topic+BIKM1_LBM_Binary-class">BIKM1_LBM_Binary</a></code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'BIKM1_LBM_Binary'
show(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="show+2B2CBIKM1_LBM_Binary-method_+3A_object">object</code></td>
<td>
<p>a BIKM1_LBM_Binary object</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>require(bikm1)
n=200
J=120
g=3
h=2
theta=list()
theta$pi_g=1/g *matrix(1,g,1)
theta$rho_h=1/h *matrix(1,h,1)
theta$alpha_gh=matrix(runif(6),ncol=h)
data=BinBlocRnd_LBM(n,J,theta)
res=BIKM1_LBM_Binary(data$x,4,4,4,init_choice='random')
show(res)

</code></pre>

<hr>
<h2 id='show+2CBIKM1_LBM_Poisson-method'>Show method for a BIKM1_LBM_Poisson object</h2><span id='topic+show+2CBIKM1_LBM_Poisson-method'></span>

<h3>Description</h3>

<p>show method for a <code><a href="#topic+BIKM1_LBM_Poisson-class">BIKM1_LBM_Poisson</a></code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'BIKM1_LBM_Poisson'
show(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="show+2B2CBIKM1_LBM_Poisson-method_+3A_object">object</code></td>
<td>
<p>a BIKM1_LBM_Poisson object</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>require(bikm1)
J=200
K=120
h=3
l=2
theta=list()
theta$rho_h=1/h *matrix(1,h,1)
theta$tau_l=1/l *matrix(1,l,1)
theta$gamma_hl=matrix(c(1, 6,4, 1, 7, 1),ncol=2)
data=PoissonBlocRnd(J,K,theta)
res=BIKM1_LBM_Poisson(data$x,4,4,4,init_choice='random')
show(res)

</code></pre>

<hr>
<h2 id='show+2CBIKM1_MLBM_Binary-method'>Show method for a BIKM1_MLBM_Binary object</h2><span id='topic+show+2CBIKM1_MLBM_Binary-method'></span>

<h3>Description</h3>

<p>show method for a <code><a href="#topic+BIKM1_MLBM_Binary-class">BIKM1_MLBM_Binary</a></code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'BIKM1_MLBM_Binary'
show(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="show+2B2CBIKM1_MLBM_Binary-method_+3A_object">object</code></td>
<td>
<p>a BIKM1_MLBM_Binary object</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>require(bikm1)
n=200
J=120
K=120
g=3
h=2
l=2
theta=list()
theta$pi_g=1/g *matrix(1,g,1)
theta$rho_h=1/h *matrix(1,h,1)
theta$tau_l=1/l *matrix(1,l,1)
theta$alpha_gh=matrix(runif(6),ncol=h)
theta$beta_gl=matrix(runif(6),ncol=l)
data=BinBlocRnd_MLBM(n,J,K,theta)
res=BIKM1_MLBM_Binary(data$x,data$y,3,3,3,4)
show(res)

</code></pre>

<hr>
<h2 id='summary+2CBIKM1_LBM_Binary-method'>Summary method for a BIKM1_LBM_Binary object</h2><span id='topic+summary+2CBIKM1_LBM_Binary-method'></span>

<h3>Description</h3>

<p>Produce a summary of informations of a <code>BIKM1_LBM_Binary</code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'BIKM1_LBM_Binary'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary+2B2CBIKM1_LBM_Binary-method_+3A_object">object</code></td>
<td>
<p>in the summary method, a BIKM1_LBM_Binary object</p>
</td></tr>
<tr><td><code id="summary+2B2CBIKM1_LBM_Binary-method_+3A_...">...</code></td>
<td>
<p>in the summary method, additional parameters (ignored)</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>require(bikm1)
n=200
J=120
g=3
h=2
theta=list()
theta$pi_g=1/g *matrix(1,g,1)
theta$rho_h=1/h *matrix(1,h,1)
theta$alpha_gh=matrix(runif(6),ncol=h)
data=BinBlocRnd_LBM(n,J,theta)
res=BIKM1_LBM_Binary(data$x,3,2,4,init_choice='random')
summary(res)


</code></pre>

<hr>
<h2 id='summary+2CBIKM1_LBM_Poisson-method'>Summary method for a BIKM1_LBM_Poisson object</h2><span id='topic+summary+2CBIKM1_LBM_Poisson-method'></span>

<h3>Description</h3>

<p>Produce a summary of informations of a <code>BIKM1_LBM_Poisson</code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'BIKM1_LBM_Poisson'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary+2B2CBIKM1_LBM_Poisson-method_+3A_object">object</code></td>
<td>
<p>in the summary method, a BIKM1_LBM_Poisson object</p>
</td></tr>
<tr><td><code id="summary+2B2CBIKM1_LBM_Poisson-method_+3A_...">...</code></td>
<td>
<p>in the summary method, additional parameters (ignored)</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>require(bikm1)
J=200
K=120
h=3
l=2
theta=list()
theta$rho_h=1/h *matrix(1,h,1)
theta$tau_l=1/l *matrix(1,l,1)
theta$gamma_hl=matrix(c(1, 6,4, 1, 7, 1),ncol=2)
data=PoissonBlocRnd(J,K,theta)
res=BIKM1_LBM_Poisson(data$x,4,4,4,init_choice='random')
summary(res)


</code></pre>

<hr>
<h2 id='summary+2CBIKM1_MLBM_Binary-method'>Summary method for a BIKM1_MLBM_Binary object</h2><span id='topic+summary+2CBIKM1_MLBM_Binary-method'></span>

<h3>Description</h3>

<p>Produce a summary of informations of a <code>BIKM1_MLBM_Binary</code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'BIKM1_MLBM_Binary'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary+2B2CBIKM1_MLBM_Binary-method_+3A_object">object</code></td>
<td>
<p>in the summary method, a BIKM1_MLBM_Binary object</p>
</td></tr>
<tr><td><code id="summary+2B2CBIKM1_MLBM_Binary-method_+3A_...">...</code></td>
<td>
<p>in the summary method, additional parameters (ignored)</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>require(bikm1)
n=200
J=120
K=120
g=3
h=2
l=2
theta=list()
theta$pi_g=1/g *matrix(1,g,1)
theta$rho_h=1/h *matrix(1,h,1)
theta$tau_l=1/l *matrix(1,l,1)
theta$alpha_gh=matrix(runif(6),ncol=h)
theta$beta_gl=matrix(runif(6),ncol=l)
data=BinBlocRnd_MLBM(n,J,K,theta)
res=BIKM1_MLBM_Binary(data$x,data$y,3,3,3,4)
summary(res)


</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
