<!DOCTYPE html><html><head><title>Help for package plsRcox</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {plsRcox}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#coxDKpls2DR'><p>Fitting a Direct Kernel PLS model on the (Deviance) Residuals</p></a></li>
<li><a href='#coxDKplsDR'><p>Fitting a Direct Kernel PLS model on the (Deviance) Residuals</p></a></li>
<li><a href='#coxDKsplsDR'><p>Fitting a Direct Kernel sPLSR model on the (Deviance) Residuals</p></a></li>
<li><a href='#coxpls'><p>Fitting a Cox-Model on PLSR components</p></a></li>
<li><a href='#coxpls2'><p>Fitting a Cox-Model on PLSR components</p></a></li>
<li><a href='#coxpls2DR'><p>Fitting a PLSR model on the (Deviance) Residuals</p></a></li>
<li><a href='#coxpls3'><p>Fitting a Cox-Model on PLSR components</p></a></li>
<li><a href='#coxpls3DR'><p>Fitting a PLSR model on the (Deviance) Residuals</p></a></li>
<li><a href='#coxplsDR'><p>Fitting a PLSR model on the (Deviance) Residuals</p></a></li>
<li><a href='#coxsplsDR'><p>Fitting a sPLSR model on the (Deviance) Residuals</p></a></li>
<li><a href='#cv.autoplsRcox'><p>Cross-validating an autoplsRcox-Model</p></a></li>
<li><a href='#cv.coxDKplsDR'><p>Cross-validating a DKplsDR-Model</p></a></li>
<li><a href='#cv.coxDKsplsDR'><p>Cross-validating a DKsplsDR-Model</p></a></li>
<li><a href='#cv.coxpls'><p>Cross-validating a Cox-Model fitted on PLSR components</p></a></li>
<li><a href='#cv.coxplsDR'><p>Cross-validating a plsDR-Model</p></a></li>
<li><a href='#cv.coxsplsDR'><p>Cross-validating a splsDR-Model</p></a></li>
<li><a href='#cv.larsDR'><p>Cross-validating a larsDR-Model</p></a></li>
<li><a href='#cv.plsRcox'><p>Cross-validating a plsRcox-Model</p></a></li>
<li><a href='#DKplsRcox'><p>Partial least squares Regression generalized linear models</p></a></li>
<li><a href='#DR_coxph'><p>(Deviance) Residuals Computation</p></a></li>
<li><a href='#internal-plsRcox'><p>Internal plsRcox functions</p></a></li>
<li><a href='#larsDR_coxph'><p>Fitting a LASSO/LARS model on the (Deviance) Residuals</p></a></li>
<li><a href='#micro.censure'><p>Microsat features and survival times</p></a></li>
<li><a href='#plsRcox'><p>Partial least squares Regression generalized linear models</p></a></li>
<li><a href='#plsRcox-package'><p>plsRcox-package: Partial Least Squares Regression for Cox Models and Related Techniques</p></a></li>
<li><a href='#predict.plsRcoxmodel'><p>Print method for plsRcox models</p></a></li>
<li><a href='#print.plsRcoxmodel'><p>Print method for plsRcox models</p></a></li>
<li><a href='#print.summary.plsRcoxmodel'><p>Print method for summaries of plsRcox models</p></a></li>
<li><a href='#summary.plsRcoxmodel'><p>Summary method for plsRcox models</p></a></li>
<li><a href='#Xmicro.censure_compl_imp'><p>Imputed Microsat features</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>1.7.7</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-11-29</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.4.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>survival, plsRglm, lars, pls, kernlab, mixOmics, risksetROC,
survcomp, survAUC, rms</td>
</tr>
<tr>
<td>Suggests:</td>
<td>survivalROC, plsdof</td>
</tr>
<tr>
<td>Title:</td>
<td>Partial Least Squares Regression for Cox Models and Related
Techniques</td>
</tr>
<tr>
<td>Author:</td>
<td>Frederic Bertrand <a href="https://orcid.org/0000-0002-0837-8281"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [cre, aut],
  Myriam Maumy-Bertrand
    <a href="https://orcid.org/0000-0002-4615-1512"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Frederic Bertrand &lt;frederic.bertrand@utt.fr&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides Partial least squares Regression and various regular, sparse or kernel, techniques for fitting Cox models in high dimensional settings &lt;<a href="https://doi.org/10.1093%2Fbioinformatics%2Fbtu660">doi:10.1093/bioinformatics/btu660</a>&gt;, Bastien, P., Bertrand, F., Meyer N., Maumy-Bertrand, M. (2015), Deviance residuals-based sparse PLS and sparse kernel PLS regression for censored data, Bioinformatics, 31(3):397-404. Cross validation criteria were studied in &lt;<a href="https://arxiv.org/abs/1810.02962">arXiv:1810.02962</a>&gt;, Bertrand, F., Bastien, Ph. and Maumy-Bertrand, M. (2018), Cross validating extensions of kernel, sparse or regular partial least squares regression models to censored data.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="http://fbertran.github.io/plsRcox/">http://fbertran.github.io/plsRcox/</a>,
<a href="https://github.com/fbertran/plsRcox/">https://github.com/fbertran/plsRcox/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/fbertran/plsRcox/issues/">https://github.com/fbertran/plsRcox/issues/</a></td>
</tr>
<tr>
<td>Classification/MSC:</td>
<td>62N01, 62N02, 62N03, 62N99</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-11-29 13:49:39 UTC; fbertran</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-11-29 15:10:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='coxDKpls2DR'>Fitting a Direct Kernel PLS model on the (Deviance) Residuals</h2><span id='topic+coxDKpls2DR'></span><span id='topic+coxDKpls2DR.default'></span><span id='topic+coxDKpls2DR.formula'></span>

<h3>Description</h3>

<p>This function computes the Direct Kernel PLSR model with the Residuals of a
Cox-Model fitted with an intercept as the only explanatory variable as the
response and Xplan as explanatory variables. Default behaviour uses the
Deviance residuals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coxDKpls2DR(Xplan, ...)

## Default S3 method:
coxDKpls2DR(
  Xplan,
  time,
  time2,
  event,
  type,
  origin,
  typeres = "deviance",
  collapse,
  weighted,
  scaleX = TRUE,
  scaleY = TRUE,
  ncomp = min(7, ncol(Xplan)),
  methodpls = "kernelpls",
  validation = "CV",
  plot = FALSE,
  allres = FALSE,
  kernel = "rbfdot",
  hyperkernel,
  verbose = TRUE,
  ...
)

## S3 method for class 'formula'
coxDKpls2DR(
  Xplan,
  time,
  time2,
  event,
  type,
  origin,
  typeres = "deviance",
  collapse,
  weighted,
  scaleX = TRUE,
  scaleY = TRUE,
  ncomp = min(7, ncol(Xplan)),
  methodpls = "kernelpls",
  validation = "CV",
  plot = FALSE,
  allres = FALSE,
  dataXplan = NULL,
  subset,
  weights,
  model_frame = FALSE,
  kernel = "rbfdot",
  hyperkernel,
  verbose = TRUE,
  model_matrix = FALSE,
  contrasts.arg = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coxDKpls2DR_+3A_xplan">Xplan</code></td>
<td>
<p>a formula or a matrix with the eXplanatory variables (training)
dataset</p>
</td></tr>
<tr><td><code id="coxDKpls2DR_+3A_...">...</code></td>
<td>
<p>Arguments to be passed on to <code>survival::coxph</code>.</p>
</td></tr>
<tr><td><code id="coxDKpls2DR_+3A_time">time</code></td>
<td>
<p>for right censored data, this is the follow up time. For
interval data, the first argument is the starting time for the interval.</p>
</td></tr>
<tr><td><code id="coxDKpls2DR_+3A_time2">time2</code></td>
<td>
<p>The status indicator, normally 0=alive, 1=dead. Other choices
are <code>TRUE/FALSE</code> (<code>TRUE</code> = death) or 1/2 (2=death). For interval
censored data, the status indicator is 0=right censored, 1=event at
<code>time</code>, 2=left censored, 3=interval censored. Although unusual, the
event indicator can be omitted, in which case all subjects are assumed to
have an event.</p>
</td></tr>
<tr><td><code id="coxDKpls2DR_+3A_event">event</code></td>
<td>
<p>ending time of the interval for interval censored or counting
process data only. Intervals are assumed to be open on the left and closed
on the right, <code>(start, end]</code>. For counting process data, event
indicates whether an event occurred at the end of the interval.</p>
</td></tr>
<tr><td><code id="coxDKpls2DR_+3A_type">type</code></td>
<td>
<p>character string specifying the type of censoring. Possible
values are <code>"right"</code>, <code>"left"</code>, <code>"counting"</code>,
<code>"interval"</code>, or <code>"interval2"</code>. The default is <code>"right"</code> or
<code>"counting"</code> depending on whether the <code>time2</code> argument is absent
or present, respectively.</p>
</td></tr>
<tr><td><code id="coxDKpls2DR_+3A_origin">origin</code></td>
<td>
<p>for counting process data, the hazard function origin. This
option was intended to be used in conjunction with a model containing time
dependent strata in order to align the subjects properly when they cross
over from one strata to another, but it has rarely proven useful.</p>
</td></tr>
<tr><td><code id="coxDKpls2DR_+3A_typeres">typeres</code></td>
<td>
<p>character string indicating the type of residual desired.
Possible values are <code>"martingale"</code>, <code>"deviance"</code>, <code>"score"</code>,
<code>"schoenfeld"</code>, <code>"dfbeta"</code>, <code>"dfbetas"</code>, and
<code>"scaledsch"</code>. Only enough of the string to determine a unique match is
required.</p>
</td></tr>
<tr><td><code id="coxDKpls2DR_+3A_collapse">collapse</code></td>
<td>
<p>vector indicating which rows to collapse (sum) over. In
time-dependent models more than one row data can pertain to a single
individual. If there were 4 individuals represented by 3, 1, 2 and 4 rows of
data respectively, then <code>collapse=c(1,1,1,2,3,3,4,4,4,4)</code> could be used
to obtain per subject rather than per observation residuals.</p>
</td></tr>
<tr><td><code id="coxDKpls2DR_+3A_weighted">weighted</code></td>
<td>
<p>if <code>TRUE</code> and the model was fit with case weights, then
the weighted residuals are returned.</p>
</td></tr>
<tr><td><code id="coxDKpls2DR_+3A_scalex">scaleX</code></td>
<td>
<p>Should the <code>Xplan</code> columns be standardized ?</p>
</td></tr>
<tr><td><code id="coxDKpls2DR_+3A_scaley">scaleY</code></td>
<td>
<p>Should the <code>time</code> values be standardized ?</p>
</td></tr>
<tr><td><code id="coxDKpls2DR_+3A_ncomp">ncomp</code></td>
<td>
<p>The number of components to include in the model. The number of
components to fit is specified with the argument ncomp. It this is not
supplied, the maximal number of components is used (taking account of any
cross-validation).</p>
</td></tr>
<tr><td><code id="coxDKpls2DR_+3A_methodpls">methodpls</code></td>
<td>
<p>The multivariate regression method to be used. See
<code><a href="pls.html#topic+mvrCv">mvrCv</a></code> for details.</p>
</td></tr>
<tr><td><code id="coxDKpls2DR_+3A_validation">validation</code></td>
<td>
<p>character. What kind of (internal) validation to use. If
<code>validation = "CV"</code>, cross-validation is performed. The number and type
of cross-validation segments are specified with the arguments
<code>segments</code> and <code>segment.type</code>. See <code><a href="pls.html#topic+mvrCv">mvrCv</a></code> for
details. If <code>validation = "LOO"</code>, leave-one-out cross-validation is
performed. It is an error to specify the segments when <code>validation =
"LOO"</code> is specified.</p>
</td></tr>
<tr><td><code id="coxDKpls2DR_+3A_plot">plot</code></td>
<td>
<p>Should the survival function be plotted ?)</p>
</td></tr>
<tr><td><code id="coxDKpls2DR_+3A_allres">allres</code></td>
<td>
<p>FALSE to return only the Cox model and TRUE for additionnal
results. See details. Defaults to FALSE.</p>
</td></tr>
<tr><td><code id="coxDKpls2DR_+3A_kernel">kernel</code></td>
<td>
<p>the kernel function used in training and predicting. This
parameter can be set to any function, of class kernel, which computes the
inner product in feature space between two vector arguments (see
<a href="kernlab.html#topic+kernels">kernels</a>). The <code>kernlab</code> package provides the most
popular kernel functions which can be used by setting the kernel parameter
to the following strings: </p>
 <dl>
<dt>list(&quot;rbfdot&quot;)</dt><dd><p>Radial Basis
kernel &quot;Gaussian&quot;</p>
</dd> <dt>list(&quot;polydot&quot;)</dt><dd><p>Polynomial kernel</p>
</dd>
<dt>list(&quot;vanilladot&quot;)</dt><dd><p>Linear kernel</p>
</dd> <dt>list(&quot;tanhdot&quot;)</dt><dd><p>Hyperbolic
tangent kernel</p>
</dd> <dt>list(&quot;laplacedot&quot;)</dt><dd><p>Laplacian kernel</p>
</dd>
<dt>list(&quot;besseldot&quot;)</dt><dd><p>Bessel kernel</p>
</dd> <dt>list(&quot;anovadot&quot;)</dt><dd><p>ANOVA RBF
kernel</p>
</dd> <dt>list(&quot;splinedot&quot;)</dt><dd><p>Spline kernel</p>
</dd> </dl>
</td></tr>
<tr><td><code id="coxDKpls2DR_+3A_hyperkernel">hyperkernel</code></td>
<td>
<p>the list of hyper-parameters (kernel parameters). This is
a list which contains the parameters to be used with the kernel function.
For valid parameters for existing kernels are : </p>
 <ul>
<li>
<p><code>sigma</code>, inverse kernel width for the Radial Basis kernel function
&quot;rbfdot&quot; and the Laplacian kernel &quot;laplacedot&quot;.  </p>
</li>
<li> <p><code>degree</code>,
<code>scale</code>, <code>offset</code> for the Polynomial kernel &quot;polydot&quot;.  </p>
</li>
<li>
<p><code>scale</code>, offset for the Hyperbolic tangent kernel function &quot;tanhdot&quot;.
</p>
</li>
<li> <p><code>sigma</code>, <code>order</code>, <code>degree</code> for the Bessel kernel
&quot;besseldot&quot;.  </p>
</li>
<li> <p><code>sigma</code>, <code>degree</code> for the ANOVA kernel
&quot;anovadot&quot;.  </p>
</li></ul>
<p> In the case of a Radial Basis kernel function (Gaussian) or
Laplacian kernel, if <code>hyperkernel</code> is missing, the heuristics in sigest
are used to calculate a good sigma value from the data.</p>
</td></tr>
<tr><td><code id="coxDKpls2DR_+3A_verbose">verbose</code></td>
<td>
<p>Should some details be displayed ?</p>
</td></tr>
<tr><td><code id="coxDKpls2DR_+3A_dataxplan">dataXplan</code></td>
<td>
<p>an optional data frame, list or environment (or object
coercible by <code><a href="base.html#topic+as.data.frame">as.data.frame</a></code> to a data frame) containing the
variables in the model. If not found in <code>dataXplan</code>, the variables are
taken from <code>environment(Xplan)</code>, typically the environment from which
<code>coxDKpls2DR</code> is called.</p>
</td></tr>
<tr><td><code id="coxDKpls2DR_+3A_subset">subset</code></td>
<td>
<p>an optional vector specifying a subset of observations to be
used in the fitting process.</p>
</td></tr>
<tr><td><code id="coxDKpls2DR_+3A_weights">weights</code></td>
<td>
<p>an optional vector of 'prior weights' to be used in the
fitting process. Should be <code>NULL</code> or a numeric vector.</p>
</td></tr>
<tr><td><code id="coxDKpls2DR_+3A_model_frame">model_frame</code></td>
<td>
<p>If <code>TRUE</code>, the model frame is returned.</p>
</td></tr>
<tr><td><code id="coxDKpls2DR_+3A_model_matrix">model_matrix</code></td>
<td>
<p>If <code>TRUE</code>, the model matrix is returned.</p>
</td></tr>
<tr><td><code id="coxDKpls2DR_+3A_contrasts.arg">contrasts.arg</code></td>
<td>
<p>a list, whose entries are values (numeric matrices, 
functions or character strings naming functions) to be used as replacement 
values for the contrasts replacement function and whose names are the names 
of columns of data containing factors.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>allres=FALSE</code> returns only the final Cox-model. If
<code>allres=TRUE</code> returns a list with the PLS components, the final
Cox-model and the PLSR model. <code>allres=TRUE</code> is useful for evluating
model prediction accuracy on a test sample.
</p>


<h3>Value</h3>

<p>If <code>allres=FALSE</code> : </p>
<table>
<tr><td><code>cox_DKpls2DR</code></td>
<td>
<p>Final Cox-model.</p>
</td></tr></table>
<p> If
<code>allres=TRUE</code> : </p>
<table>
<tr><td><code>tt_DKpls2DR</code></td>
<td>
<p>PLSR components.</p>
</td></tr>
<tr><td><code>cox_DKpls2DR</code></td>
<td>
<p>Final Cox-model.</p>
</td></tr> <tr><td><code>DKpls2DR_mod</code></td>
<td>
<p>The PLSR model.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Frédéric Bertrand<br />
<a href="mailto:frederic.bertrand@utt.fr">frederic.bertrand@utt.fr</a><br />
<a href="http://www-irma.u-strasbg.fr/~fbertran/">http://www-irma.u-strasbg.fr/~fbertran/</a>
</p>


<h3>References</h3>

<p>plsRcox, Cox-Models in a high dimensional setting in R, Frederic
Bertrand, Philippe Bastien, Nicolas Meyer and Myriam Maumy-Bertrand (2014).
Proceedings of User2014!, Los Angeles, page 152.<br />
</p>
<p>Deviance residuals-based sparse PLS and sparse kernel PLS regression for
censored data, Philippe Bastien, Frederic Bertrand, Nicolas Meyer and Myriam
Maumy-Bertrand (2015), Bioinformatics, 31(3):397-404,
doi:10.1093/bioinformatics/btu660.
</p>


<h3>See Also</h3>

<p><code><a href="survival.html#topic+coxph">coxph</a></code>, <code><a href="pls.html#topic+plsr">plsr</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(micro.censure)
data(Xmicro.censure_compl_imp)

X_train_micro &lt;- apply((as.matrix(Xmicro.censure_compl_imp)),FUN="as.numeric",MARGIN=2)[1:80,]
X_train_micro_df &lt;- data.frame(X_train_micro)
Y_train_micro &lt;- micro.censure$survyear[1:80]
C_train_micro &lt;- micro.censure$DC[1:80]

(cox_DKpls2DR_fit=coxDKpls2DR(X_train_micro,Y_train_micro,C_train_micro,ncomp=6,validation="CV"))

#Fixing sigma to compare with pls2DR on Gram matrix; should be identical
(cox_DKpls2DR_fit=coxDKpls2DR(X_train_micro,Y_train_micro,C_train_micro,ncomp=6,
validation="CV",hyperkernel=list(sigma=0.01292786)))

X_train_micro_kern &lt;- kernlab::kernelMatrix(kernlab::rbfdot(sigma=0.01292786),scale(X_train_micro))
(cox_DKpls2DR_fit2=coxpls2DR(~X_train_micro_kern,Y_train_micro,C_train_micro,ncomp=6,
validation="CV",scaleX=FALSE))

(cox_DKpls2DR_fit=coxDKpls2DR(X_train_micro,Y_train_micro,C_train_micro,ncomp=6,
validation="CV",kernel="laplacedot",hyperkernel=list(sigma=0.01292786)))

X_train_micro_kern &lt;- kernlab::kernelMatrix(kernlab::laplacedot(sigma=0.01292786),
scale(X_train_micro))
(cox_DKpls2DR_fit2=coxpls2DR(~X_train_micro_kern,Y_train_micro,C_train_micro,ncomp=6,
validation="CV",scaleX=FALSE))

(cox_DKpls2DR_fit=coxDKpls2DR(~X_train_micro,Y_train_micro,C_train_micro,ncomp=6,validation="CV"))
(cox_DKpls2DR_fit=coxDKpls2DR(~.,Y_train_micro,C_train_micro,ncomp=6,validation="CV",
dataXplan=X_train_micro_df))

(cox_DKpls2DR_fit=coxDKpls2DR(X_train_micro,Y_train_micro,C_train_micro,ncomp=6,
validation="CV",allres=TRUE))
(cox_DKpls2DR_fit=coxDKpls2DR(~X_train_micro,Y_train_micro,C_train_micro,ncomp=6,
validation="CV",allres=TRUE))
(cox_DKpls2DR_fit=coxDKpls2DR(~.,Y_train_micro,C_train_micro,ncomp=6,validation="CV",
allres=TRUE,dataXplan=X_train_micro_df))


rm(X_train_micro,Y_train_micro,C_train_micro,cox_DKpls2DR_fit)

</code></pre>

<hr>
<h2 id='coxDKplsDR'>Fitting a Direct Kernel PLS model on the (Deviance) Residuals</h2><span id='topic+coxDKplsDR'></span><span id='topic+coxDKplsDR.default'></span><span id='topic+coxDKplsDR.formula'></span>

<h3>Description</h3>

<p>This function computes the Cox Model based on PLSR components computed model
with </p>
<ul>
<li><p> as the response: the Residuals of a Cox-Model fitted with no covariate
</p>
</li>
<li><p> as explanatory variables: a Kernel transform of Xplan.</p>
</li></ul>

<p>It uses the package <code>kernlab</code> to compute the Kernel
transforms of Xplan, then the package <code>mixOmics</code> to perform PLSR fit.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coxDKplsDR(Xplan, ...)

## Default S3 method:
coxDKplsDR(
  Xplan,
  time,
  time2,
  event,
  type,
  origin,
  typeres = "deviance",
  collapse,
  weighted,
  scaleX = TRUE,
  scaleY = TRUE,
  ncomp = min(7, ncol(Xplan)),
  modepls = "regression",
  plot = FALSE,
  allres = FALSE,
  kernel = "rbfdot",
  hyperkernel,
  verbose = TRUE,
  ...
)

## S3 method for class 'formula'
coxDKplsDR(
  Xplan,
  time,
  time2,
  event,
  type,
  origin,
  typeres = "deviance",
  collapse,
  weighted,
  scaleX = TRUE,
  scaleY = TRUE,
  ncomp = min(7, ncol(Xplan)),
  modepls = "regression",
  plot = FALSE,
  allres = FALSE,
  dataXplan = NULL,
  subset,
  weights,
  model_frame = FALSE,
  kernel = "rbfdot",
  hyperkernel,
  verbose = TRUE,
  model_matrix = FALSE,
  contrasts.arg = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coxDKplsDR_+3A_xplan">Xplan</code></td>
<td>
<p>a formula or a matrix with the eXplanatory variables (training)
dataset</p>
</td></tr>
<tr><td><code id="coxDKplsDR_+3A_...">...</code></td>
<td>
<p>Arguments to be passed on to <code>survival::coxph</code>.</p>
</td></tr>
<tr><td><code id="coxDKplsDR_+3A_time">time</code></td>
<td>
<p>for right censored data, this is the follow up time. For
interval data, the first argument is the starting time for the interval.</p>
</td></tr>
<tr><td><code id="coxDKplsDR_+3A_time2">time2</code></td>
<td>
<p>The status indicator, normally 0=alive, 1=dead. Other choices
are <code>TRUE/FALSE</code> (<code>TRUE</code> = death) or 1/2 (2=death). For interval
censored data, the status indicator is 0=right censored, 1=event at
<code>time</code>, 2=left censored, 3=interval censored. Although unusual, the
event indicator can be omitted, in which case all subjects are assumed to
have an event.</p>
</td></tr>
<tr><td><code id="coxDKplsDR_+3A_event">event</code></td>
<td>
<p>ending time of the interval for interval censored or counting
process data only. Intervals are assumed to be open on the left and closed
on the right, <code>(start, end]</code>. For counting process data, event
indicates whether an event occurred at the end of the interval.</p>
</td></tr>
<tr><td><code id="coxDKplsDR_+3A_type">type</code></td>
<td>
<p>character string specifying the type of censoring. Possible
values are <code>"right"</code>, <code>"left"</code>, <code>"counting"</code>,
<code>"interval"</code>, or <code>"interval2"</code>. The default is <code>"right"</code> or
<code>"counting"</code> depending on whether the <code>time2</code> argument is absent
or present, respectively.</p>
</td></tr>
<tr><td><code id="coxDKplsDR_+3A_origin">origin</code></td>
<td>
<p>for counting process data, the hazard function origin. This
option was intended to be used in conjunction with a model containing time
dependent strata in order to align the subjects properly when they cross
over from one strata to another, but it has rarely proven useful.</p>
</td></tr>
<tr><td><code id="coxDKplsDR_+3A_typeres">typeres</code></td>
<td>
<p>character string indicating the type of residual desired.
Possible values are <code>"martingale"</code>, <code>"deviance"</code>, <code>"score"</code>,
<code>"schoenfeld"</code>, <code>"dfbeta"</code>, <code>"dfbetas"</code>, and
<code>"scaledsch"</code>. Only enough of the string to determine a unique match is
required.</p>
</td></tr>
<tr><td><code id="coxDKplsDR_+3A_collapse">collapse</code></td>
<td>
<p>vector indicating which rows to collapse (sum) over. In
time-dependent models more than one row data can pertain to a single
individual. If there were 4 individuals represented by 3, 1, 2 and 4 rows of
data respectively, then <code>collapse=c(1,1,1,2,3,3,4,4,4,4)</code> could be used
to obtain per subject rather than per observation residuals.</p>
</td></tr>
<tr><td><code id="coxDKplsDR_+3A_weighted">weighted</code></td>
<td>
<p>if <code>TRUE</code> and the model was fit with case weights, then
the weighted residuals are returned.</p>
</td></tr>
<tr><td><code id="coxDKplsDR_+3A_scalex">scaleX</code></td>
<td>
<p>Should the <code>Xplan</code> columns be standardized ?</p>
</td></tr>
<tr><td><code id="coxDKplsDR_+3A_scaley">scaleY</code></td>
<td>
<p>Should the <code>time</code> values be standardized ?</p>
</td></tr>
<tr><td><code id="coxDKplsDR_+3A_ncomp">ncomp</code></td>
<td>
<p>The number of components to include in the model. The number of
components to fit is specified with the argument ncomp. It this is not
supplied, the maximal number of components is used.</p>
</td></tr>
<tr><td><code id="coxDKplsDR_+3A_modepls">modepls</code></td>
<td>
<p>character string. What type of algorithm to use, (partially)
matching one of &quot;regression&quot;, &quot;canonical&quot;, &quot;invariant&quot; or &quot;classic&quot;. See
<code><a href="mixOmics.html#topic+pls">pls</a></code> for details</p>
</td></tr>
<tr><td><code id="coxDKplsDR_+3A_plot">plot</code></td>
<td>
<p>Should the survival function be plotted ?)</p>
</td></tr>
<tr><td><code id="coxDKplsDR_+3A_allres">allres</code></td>
<td>
<p>FALSE to return only the Cox model and TRUE for additionnal
results. See details. Defaults to FALSE.</p>
</td></tr>
<tr><td><code id="coxDKplsDR_+3A_kernel">kernel</code></td>
<td>
<p>the kernel function used in training and predicting. This
parameter can be set to any function, of class kernel, which computes the
inner product in feature space between two vector arguments (see
<a href="kernlab.html#topic+kernels">kernels</a>). The <code>kernlab</code> package provides the most
popular kernel functions which can be used by setting the kernel parameter
to the following strings: </p>
 <dl>
<dt>list(&quot;rbfdot&quot;)</dt><dd><p>Radial Basis
kernel &quot;Gaussian&quot;</p>
</dd> <dt>list(&quot;polydot&quot;)</dt><dd><p>Polynomial kernel</p>
</dd>
<dt>list(&quot;vanilladot&quot;)</dt><dd><p>Linear kernel</p>
</dd> <dt>list(&quot;tanhdot&quot;)</dt><dd><p>Hyperbolic
tangent kernel</p>
</dd> <dt>list(&quot;laplacedot&quot;)</dt><dd><p>Laplacian kernel</p>
</dd>
<dt>list(&quot;besseldot&quot;)</dt><dd><p>Bessel kernel</p>
</dd> <dt>list(&quot;anovadot&quot;)</dt><dd><p>ANOVA RBF
kernel</p>
</dd> <dt>list(&quot;splinedot&quot;)</dt><dd><p>Spline kernel</p>
</dd> </dl>
</td></tr>
<tr><td><code id="coxDKplsDR_+3A_hyperkernel">hyperkernel</code></td>
<td>
<p>the list of hyper-parameters (kernel parameters). This is
a list which contains the parameters to be used with the kernel function.
For valid parameters for existing kernels are : </p>
 <ul>
<li>
<p><code>sigma</code>, inverse kernel width for the Radial Basis kernel function
&quot;rbfdot&quot; and the Laplacian kernel &quot;laplacedot&quot;.  </p>
</li>
<li> <p><code>degree</code>,
<code>scale</code>, <code>offset</code> for the Polynomial kernel &quot;polydot&quot;.  </p>
</li>
<li>
<p><code>scale</code>, offset for the Hyperbolic tangent kernel function &quot;tanhdot&quot;.
</p>
</li>
<li> <p><code>sigma</code>, <code>order</code>, <code>degree</code> for the Bessel kernel
&quot;besseldot&quot;.  </p>
</li>
<li> <p><code>sigma</code>, <code>degree</code> for the ANOVA kernel
&quot;anovadot&quot;.  </p>
</li></ul>
<p> In the case of a Radial Basis kernel function (Gaussian) or
Laplacian kernel, if <code>hyperkernel</code> is missing, the heuristics in sigest
are used to calculate a good sigma value from the data.</p>
</td></tr>
<tr><td><code id="coxDKplsDR_+3A_verbose">verbose</code></td>
<td>
<p>Should some details be displayed ?</p>
</td></tr>
<tr><td><code id="coxDKplsDR_+3A_dataxplan">dataXplan</code></td>
<td>
<p>an optional data frame, list or environment (or object
coercible by <code><a href="base.html#topic+as.data.frame">as.data.frame</a></code> to a data frame) containing the
variables in the model. If not found in <code>dataXplan</code>, the variables are
taken from <code>environment(Xplan)</code>, typically the environment from which
<code>coxDKplsDR</code> is called.</p>
</td></tr>
<tr><td><code id="coxDKplsDR_+3A_subset">subset</code></td>
<td>
<p>an optional vector specifying a subset of observations to be
used in the fitting process.</p>
</td></tr>
<tr><td><code id="coxDKplsDR_+3A_weights">weights</code></td>
<td>
<p>an optional vector of 'prior weights' to be used in the
fitting process. Should be <code>NULL</code> or a numeric vector.</p>
</td></tr>
<tr><td><code id="coxDKplsDR_+3A_model_frame">model_frame</code></td>
<td>
<p>If <code>TRUE</code>, the model frame is returned.</p>
</td></tr>
<tr><td><code id="coxDKplsDR_+3A_model_matrix">model_matrix</code></td>
<td>
<p>If <code>TRUE</code>, the model matrix is returned.</p>
</td></tr>
<tr><td><code id="coxDKplsDR_+3A_contrasts.arg">contrasts.arg</code></td>
<td>
<p>a list, whose entries are values (numeric matrices, 
functions or character strings naming functions) to be used as replacement 
values for the contrasts replacement function and whose names are the names 
of columns of data containing factors.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>allres=FALSE</code> returns only the final Cox-model. If
<code>allres=TRUE</code> returns a list with the PLS components, the final
Cox-model and the PLSR model. <code>allres=TRUE</code> is useful for evluating
model prediction accuracy on a test sample.
</p>


<h3>Value</h3>

<p>If <code>allres=FALSE</code> : </p>
<table>
<tr><td><code>cox_DKplsDR</code></td>
<td>
<p>Final Cox-model.</p>
</td></tr></table>
<p> If
<code>allres=TRUE</code> : </p>
<table>
<tr><td><code>tt_DKplsDR</code></td>
<td>
<p>PLSR components.</p>
</td></tr>
<tr><td><code>cox_DKplsDR</code></td>
<td>
<p>Final Cox-model.</p>
</td></tr> <tr><td><code>DKplsDR_mod</code></td>
<td>
<p>The PLSR model.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Frédéric Bertrand<br />
<a href="mailto:frederic.bertrand@utt.fr">frederic.bertrand@utt.fr</a><br />
<a href="http://www-irma.u-strasbg.fr/~fbertran/">http://www-irma.u-strasbg.fr/~fbertran/</a>
</p>


<h3>References</h3>

<p>plsRcox, Cox-Models in a high dimensional setting in R, Frederic
Bertrand, Philippe Bastien, Nicolas Meyer and Myriam Maumy-Bertrand (2014).
Proceedings of User2014!, Los Angeles, page 152.<br />
</p>
<p>Deviance residuals-based sparse PLS and sparse kernel PLS regression for
censored data, Philippe Bastien, Frederic Bertrand, Nicolas Meyer and Myriam
Maumy-Bertrand (2015), Bioinformatics, 31(3):397-404,
doi:10.1093/bioinformatics/btu660.
</p>


<h3>See Also</h3>

<p><code><a href="survival.html#topic+coxph">coxph</a></code>, <code><a href="pls.html#topic+plsr">plsr</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(micro.censure)
data(Xmicro.censure_compl_imp)

X_train_micro &lt;- apply((as.matrix(Xmicro.censure_compl_imp)),FUN="as.numeric",MARGIN=2)[1:80,]
X_train_micro_df &lt;- data.frame(X_train_micro)
Y_train_micro &lt;- micro.censure$survyear[1:80]
C_train_micro &lt;- micro.censure$DC[1:80]

(cox_DKplsDR_fit=coxDKplsDR(X_train_micro,Y_train_micro,C_train_micro,ncomp=6))

#Fixing sigma to compare with plsDR on Gram matrix; should be identical
(cox_DKplsDR_fit=coxDKplsDR(X_train_micro,Y_train_micro,C_train_micro,ncomp=6,
hyperkernel=list(sigma=0.01292786)))

X_train_micro_kern &lt;- kernlab::kernelMatrix(kernlab::rbfdot(sigma=0.01292786),
scale(X_train_micro))
(cox_DKplsDR_fit2=coxplsDR(~X_train_micro_kern,Y_train_micro,C_train_micro,ncomp=6,scaleX=FALSE))

(cox_DKplsDR_fit=coxDKplsDR(X_train_micro,Y_train_micro,C_train_micro,ncomp=6,
kernel="laplacedot",hyperkernel=list(sigma=0.01292786)))

X_train_micro_kern &lt;- kernlab::kernelMatrix(kernlab::laplacedot(sigma=0.01292786),
scale(X_train_micro))
(cox_DKplsDR_fit2=coxplsDR(~X_train_micro_kern,Y_train_micro,C_train_micro,ncomp=6,scaleX=FALSE))

(cox_DKplsDR_fit=coxDKplsDR(~X_train_micro,Y_train_micro,C_train_micro,ncomp=6))
(cox_DKplsDR_fit=coxDKplsDR(~.,Y_train_micro,C_train_micro,ncomp=6,dataXplan=X_train_micro_df))

(cox_DKplsDR_fit=coxDKplsDR(X_train_micro,Y_train_micro,C_train_micro,ncomp=6,allres=TRUE))
(cox_DKplsDR_fit=coxDKplsDR(~X_train_micro,Y_train_micro,C_train_micro,ncomp=6,allres=TRUE))
(cox_DKplsDR_fit=coxDKplsDR(~.,Y_train_micro,C_train_micro,ncomp=6,allres=TRUE,
dataXplan=X_train_micro_df))


rm(X_train_micro,Y_train_micro,C_train_micro,cox_DKplsDR_fit)

</code></pre>

<hr>
<h2 id='coxDKsplsDR'>Fitting a Direct Kernel sPLSR model on the (Deviance) Residuals</h2><span id='topic+coxDKsplsDR'></span><span id='topic+coxDKsplsDR.default'></span><span id='topic+coxDKsplsDR.formula'></span>

<h3>Description</h3>

<p>This function computes the Cox Model based on sPLSR components computed
model with </p>
<ul>
<li><p> as the response: the Residuals of a Cox-Model 
fitted with no covariate </p>
</li>
<li><p> as explanatory variables: a Kernel 
transform of Xplan.</p>
</li></ul>
 
<p>It uses the package <code>kernlab</code> to compute the Kernel
transforms of Xplan, the package <code>spls</code> to perform the first step in
SPLSR then <code>mixOmics</code> to perform PLSR step fit.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coxDKsplsDR(Xplan, ...)

## Default S3 method:
coxDKsplsDR(
  Xplan,
  time,
  time2,
  event,
  type,
  origin,
  typeres = "deviance",
  collapse,
  weighted,
  scaleX = TRUE,
  scaleY = TRUE,
  ncomp = min(7, ncol(Xplan)),
  modepls = "regression",
  plot = FALSE,
  allres = FALSE,
  eta,
  trace = FALSE,
  kernel = "rbfdot",
  hyperkernel,
  verbose = TRUE,
  ...
)

## S3 method for class 'formula'
coxDKsplsDR(
  Xplan,
  time,
  time2,
  event,
  type,
  origin,
  typeres = "deviance",
  collapse,
  weighted,
  scaleX = TRUE,
  scaleY = TRUE,
  ncomp = min(7, ncol(Xplan)),
  modepls = "regression",
  plot = FALSE,
  allres = FALSE,
  dataXplan = NULL,
  subset,
  weights,
  model_frame = FALSE,
  eta,
  trace = FALSE,
  kernel = "rbfdot",
  hyperkernel,
  verbose = TRUE,
  model_matrix = FALSE,
  contrasts.arg = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coxDKsplsDR_+3A_xplan">Xplan</code></td>
<td>
<p>a formula or a matrix with the eXplanatory variables (training)
dataset</p>
</td></tr>
<tr><td><code id="coxDKsplsDR_+3A_...">...</code></td>
<td>
<p>Arguments to be passed on to <code>survival::coxph</code>.</p>
</td></tr>
<tr><td><code id="coxDKsplsDR_+3A_time">time</code></td>
<td>
<p>for right censored data, this is the follow up time. For
interval data, the first argument is the starting time for the interval.</p>
</td></tr>
<tr><td><code id="coxDKsplsDR_+3A_time2">time2</code></td>
<td>
<p>The status indicator, normally 0=alive, 1=dead. Other choices
are <code>TRUE/FALSE</code> (<code>TRUE</code> = death) or 1/2 (2=death). For interval
censored data, the status indicator is 0=right censored, 1=event at
<code>time</code>, 2=left censored, 3=interval censored. Although unusual, the
event indicator can be omitted, in which case all subjects are assumed to
have an event.</p>
</td></tr>
<tr><td><code id="coxDKsplsDR_+3A_event">event</code></td>
<td>
<p>ending time of the interval for interval censored or counting
process data only. Intervals are assumed to be open on the left and closed
on the right, <code>(start, end]</code>. For counting process data, event
indicates whether an event occurred at the end of the interval.</p>
</td></tr>
<tr><td><code id="coxDKsplsDR_+3A_type">type</code></td>
<td>
<p>character string specifying the type of censoring. Possible
values are <code>"right"</code>, <code>"left"</code>, <code>"counting"</code>,
<code>"interval"</code>, or <code>"interval2"</code>. The default is <code>"right"</code> or
<code>"counting"</code> depending on whether the <code>time2</code> argument is absent
or present, respectively.</p>
</td></tr>
<tr><td><code id="coxDKsplsDR_+3A_origin">origin</code></td>
<td>
<p>for counting process data, the hazard function origin. This
option was intended to be used in conjunction with a model containing time
dependent strata in order to align the subjects properly when they cross
over from one strata to another, but it has rarely proven useful.</p>
</td></tr>
<tr><td><code id="coxDKsplsDR_+3A_typeres">typeres</code></td>
<td>
<p>character string indicating the type of residual desired.
Possible values are <code>"martingale"</code>, <code>"deviance"</code>, <code>"score"</code>,
<code>"schoenfeld"</code>, <code>"dfbeta"</code>, <code>"dfbetas"</code>, and
<code>"scaledsch"</code>. Only enough of the string to determine a unique match is
required.</p>
</td></tr>
<tr><td><code id="coxDKsplsDR_+3A_collapse">collapse</code></td>
<td>
<p>vector indicating which rows to collapse (sum) over. In
time-dependent models more than one row data can pertain to a single
individual. If there were 4 individuals represented by 3, 1, 2 and 4 rows of
data respectively, then <code>collapse=c(1,1,1,2,3,3,4,4,4,4)</code> could be used
to obtain per subject rather than per observation residuals.</p>
</td></tr>
<tr><td><code id="coxDKsplsDR_+3A_weighted">weighted</code></td>
<td>
<p>if <code>TRUE</code> and the model was fit with case weights, then
the weighted residuals are returned.</p>
</td></tr>
<tr><td><code id="coxDKsplsDR_+3A_scalex">scaleX</code></td>
<td>
<p>Should the <code>Xplan</code> columns be standardized ?</p>
</td></tr>
<tr><td><code id="coxDKsplsDR_+3A_scaley">scaleY</code></td>
<td>
<p>Should the <code>time</code> values be standardized ?</p>
</td></tr>
<tr><td><code id="coxDKsplsDR_+3A_ncomp">ncomp</code></td>
<td>
<p>The number of components to include in the model. The number of
components to fit is specified with the argument ncomp. It this is not
supplied, the maximal number of components is used.</p>
</td></tr>
<tr><td><code id="coxDKsplsDR_+3A_modepls">modepls</code></td>
<td>
<p>character string. What type of algorithm to use, (partially)
matching one of &quot;regression&quot;, &quot;canonical&quot;, &quot;invariant&quot; or &quot;classic&quot;. See
<code><a href="mixOmics.html#topic+pls">pls</a></code> for details</p>
</td></tr>
<tr><td><code id="coxDKsplsDR_+3A_plot">plot</code></td>
<td>
<p>Should the survival function be plotted ?)</p>
</td></tr>
<tr><td><code id="coxDKsplsDR_+3A_allres">allres</code></td>
<td>
<p>FALSE to return only the Cox model and TRUE for additionnal
results. See details. Defaults to FALSE.</p>
</td></tr>
<tr><td><code id="coxDKsplsDR_+3A_eta">eta</code></td>
<td>
<p>Thresholding parameter. <code>eta</code> should be between 0 and 1.</p>
</td></tr>
<tr><td><code id="coxDKsplsDR_+3A_trace">trace</code></td>
<td>
<p>Print out the progress of variable selection?</p>
</td></tr>
<tr><td><code id="coxDKsplsDR_+3A_kernel">kernel</code></td>
<td>
<p>the kernel function used in training and predicting. This
parameter can be set to any function, of class kernel, which computes the
inner product in feature space between two vector arguments (see
<a href="kernlab.html#topic+kernels">kernels</a>). The <code>kernlab</code> package provides the most
popular kernel functions which can be used by setting the kernel parameter
to the following strings: </p>
 <dl>
<dt>list(&quot;rbfdot&quot;)</dt><dd><p>Radial Basis
kernel &quot;Gaussian&quot;</p>
</dd> <dt>list(&quot;polydot&quot;)</dt><dd><p>Polynomial kernel</p>
</dd>
<dt>list(&quot;vanilladot&quot;)</dt><dd><p>Linear kernel</p>
</dd> <dt>list(&quot;tanhdot&quot;)</dt><dd><p>Hyperbolic
tangent kernel</p>
</dd> <dt>list(&quot;laplacedot&quot;)</dt><dd><p>Laplacian kernel</p>
</dd>
<dt>list(&quot;besseldot&quot;)</dt><dd><p>Bessel kernel</p>
</dd> <dt>list(&quot;anovadot&quot;)</dt><dd><p>ANOVA RBF
kernel</p>
</dd> <dt>list(&quot;splinedot&quot;)</dt><dd><p>Spline kernel</p>
</dd> </dl>
</td></tr>
<tr><td><code id="coxDKsplsDR_+3A_hyperkernel">hyperkernel</code></td>
<td>
<p>the list of hyper-parameters (kernel parameters). This is
a list which contains the parameters to be used with the kernel function.
For valid parameters for existing kernels are : </p>
 <ul>
<li>
<p><code>sigma</code>, inverse kernel width for the Radial Basis kernel function
&quot;rbfdot&quot; and the Laplacian kernel &quot;laplacedot&quot;.  </p>
</li>
<li> <p><code>degree</code>,
<code>scale</code>, <code>offset</code> for the Polynomial kernel &quot;polydot&quot;.  </p>
</li>
<li>
<p><code>scale</code>, offset for the Hyperbolic tangent kernel function &quot;tanhdot&quot;.
</p>
</li>
<li> <p><code>sigma</code>, <code>order</code>, <code>degree</code> for the Bessel kernel
&quot;besseldot&quot;.  </p>
</li>
<li> <p><code>sigma</code>, <code>degree</code> for the ANOVA kernel
&quot;anovadot&quot;.  </p>
</li></ul>
<p> In the case of a Radial Basis kernel function (Gaussian) or
Laplacian kernel, if <code>hyperkernel</code> is missing, the heuristics in sigest
are used to calculate a good sigma value from the data.</p>
</td></tr>
<tr><td><code id="coxDKsplsDR_+3A_verbose">verbose</code></td>
<td>
<p>Should some details be displayed ?</p>
</td></tr>
<tr><td><code id="coxDKsplsDR_+3A_dataxplan">dataXplan</code></td>
<td>
<p>an optional data frame, list or environment (or object
coercible by <code><a href="base.html#topic+as.data.frame">as.data.frame</a></code> to a data frame) containing the
variables in the model. If not found in <code>dataXplan</code>, the variables are
taken from <code>environment(Xplan)</code>, typically the environment from which
<code>coxDKsplsDR</code> is called.</p>
</td></tr>
<tr><td><code id="coxDKsplsDR_+3A_subset">subset</code></td>
<td>
<p>an optional vector specifying a subset of observations to be
used in the fitting process.</p>
</td></tr>
<tr><td><code id="coxDKsplsDR_+3A_weights">weights</code></td>
<td>
<p>an optional vector of 'prior weights' to be used in the
fitting process. Should be <code>NULL</code> or a numeric vector.</p>
</td></tr>
<tr><td><code id="coxDKsplsDR_+3A_model_frame">model_frame</code></td>
<td>
<p>If <code>TRUE</code>, the model frame is returned.</p>
</td></tr>
<tr><td><code id="coxDKsplsDR_+3A_model_matrix">model_matrix</code></td>
<td>
<p>If <code>TRUE</code>, the model matrix is returned.</p>
</td></tr>
<tr><td><code id="coxDKsplsDR_+3A_contrasts.arg">contrasts.arg</code></td>
<td>
<p>a list, whose entries are values (numeric matrices, 
functions or character strings naming functions) to be used as replacement 
values for the contrasts replacement function and whose names are the names 
of columns of data containing factors.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>allres=FALSE</code> returns only the final Cox-model. If
<code>allres=TRUE</code> returns a list with the sPLS components, the final
Cox-model and the sPLSR model. <code>allres=TRUE</code> is useful for evluating
model prediction accuracy on a test sample.
</p>


<h3>Value</h3>

<p>If <code>allres=FALSE</code> : </p>
<table>
<tr><td><code>cox_DKsplsDR</code></td>
<td>
<p>Final Cox-model.</p>
</td></tr></table>
<p> If
<code>allres=TRUE</code> : </p>
<table>
<tr><td><code>tt_DKsplsDR</code></td>
<td>
<p>sPLSR components.</p>
</td></tr>
<tr><td><code>cox_DKsplsDR</code></td>
<td>
<p>Final Cox-model.</p>
</td></tr> <tr><td><code>DKsplsDR_mod</code></td>
<td>
<p>The sPLSR model.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Frédéric Bertrand<br />
<a href="mailto:frederic.bertrand@utt.fr">frederic.bertrand@utt.fr</a><br />
<a href="http://www-irma.u-strasbg.fr/~fbertran/">http://www-irma.u-strasbg.fr/~fbertran/</a>
</p>


<h3>References</h3>

<p>plsRcox, Cox-Models in a high dimensional setting in R, Frederic
Bertrand, Philippe Bastien, Nicolas Meyer and Myriam Maumy-Bertrand (2014).
Proceedings of User2014!, Los Angeles, page 152.<br />
</p>
<p>Deviance residuals-based sparse PLS and sparse kernel PLS regression for
censored data, Philippe Bastien, Frederic Bertrand, Nicolas Meyer and Myriam
Maumy-Bertrand (2015), Bioinformatics, 31(3):397-404,
doi:10.1093/bioinformatics/btu660.
</p>


<h3>See Also</h3>

<p><code><a href="survival.html#topic+coxph">coxph</a></code>, <code><a href="pls.html#topic+plsr">plsr</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(micro.censure)
data(Xmicro.censure_compl_imp)

X_train_micro &lt;- apply((as.matrix(Xmicro.censure_compl_imp)),FUN="as.numeric",MARGIN=2)[1:80,]
X_train_micro_df &lt;- data.frame(X_train_micro)
Y_train_micro &lt;- micro.censure$survyear[1:80]
C_train_micro &lt;- micro.censure$DC[1:80]

(cox_DKsplsDR_fit=coxDKsplsDR(X_train_micro,Y_train_micro,C_train_micro,ncomp=6,
validation="CV",eta=.5))
(cox_DKsplsDR_fit=coxDKsplsDR(~X_train_micro,Y_train_micro,C_train_micro,ncomp=6,
validation="CV",eta=.5))
(cox_DKsplsDR_fit=coxDKsplsDR(~.,Y_train_micro,C_train_micro,ncomp=6,
validation="CV",dataXplan=data.frame(X_train_micro),eta=.5))

(cox_DKsplsDR_fit=coxDKsplsDR(X_train_micro,Y_train_micro,C_train_micro,ncomp=6,
validation="CV",allres=TRUE,eta=.5))
(cox_DKsplsDR_fit=coxDKsplsDR(~X_train_micro,Y_train_micro,C_train_micro,ncomp=6,
validation="CV",allres=TRUE,eta=.5))
(cox_DKsplsDR_fit=coxDKsplsDR(~.,Y_train_micro,C_train_micro,ncomp=6,
validation="CV",allres=TRUE,dataXplan=data.frame(X_train_micro),eta=.5))

rm(X_train_micro,Y_train_micro,C_train_micro,cox_DKsplsDR_fit)

</code></pre>

<hr>
<h2 id='coxpls'>Fitting a Cox-Model on PLSR components</h2><span id='topic+coxpls'></span><span id='topic+coxpls.default'></span><span id='topic+coxpls.formula'></span>

<h3>Description</h3>

<p>This function computes the Cox Model based on PLSR components computed model
with </p>
<ul>
<li><p> as the response: the Survival time </p>
</li>
<li><p> as explanatory
variables: Xplan.  </p>
</li></ul>
<p> It uses the package <code>mixOmics</code> to perform PLSR
fit.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coxpls(Xplan, ...)

## Default S3 method:
coxpls(
  Xplan,
  time,
  time2,
  event,
  type,
  origin,
  typeres = "deviance",
  collapse,
  weighted,
  scaleX = TRUE,
  scaleY = TRUE,
  ncomp = min(7, ncol(Xplan)),
  modepls = "regression",
  plot = FALSE,
  allres = FALSE,
  ...
)

## S3 method for class 'formula'
coxpls(
  Xplan,
  time,
  time2,
  event,
  type,
  origin,
  typeres = "deviance",
  collapse,
  weighted,
  scaleX = TRUE,
  scaleY = TRUE,
  ncomp = min(7, ncol(Xplan)),
  modepls = "regression",
  plot = FALSE,
  allres = FALSE,
  dataXplan = NULL,
  subset,
  weights,
  model_frame = FALSE,
  model_matrix = FALSE,
  contrasts.arg = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coxpls_+3A_xplan">Xplan</code></td>
<td>
<p>a formula or a matrix with the eXplanatory variables (training)
dataset</p>
</td></tr>
<tr><td><code id="coxpls_+3A_...">...</code></td>
<td>
<p>Arguments to be passed on to <code>survival::coxph</code>.</p>
</td></tr>
<tr><td><code id="coxpls_+3A_time">time</code></td>
<td>
<p>for right censored data, this is the follow up time. For
interval data, the first argument is the starting time for the interval.</p>
</td></tr>
<tr><td><code id="coxpls_+3A_time2">time2</code></td>
<td>
<p>The status indicator, normally 0=alive, 1=dead. Other choices
are <code>TRUE/FALSE</code> (<code>TRUE</code> = death) or 1/2 (2=death). For interval
censored data, the status indicator is 0=right censored, 1=event at
<code>time</code>, 2=left censored, 3=interval censored. Although unusual, the
event indicator can be omitted, in which case all subjects are assumed to
have an event.</p>
</td></tr>
<tr><td><code id="coxpls_+3A_event">event</code></td>
<td>
<p>ending time of the interval for interval censored or counting
process data only. Intervals are assumed to be open on the left and closed
on the right, <code>(start, end]</code>. For counting process data, event
indicates whether an event occurred at the end of the interval.</p>
</td></tr>
<tr><td><code id="coxpls_+3A_type">type</code></td>
<td>
<p>character string specifying the type of censoring. Possible
values are <code>"right"</code>, <code>"left"</code>, <code>"counting"</code>,
<code>"interval"</code>, or <code>"interval2"</code>. The default is <code>"right"</code> or
<code>"counting"</code> depending on whether the <code>time2</code> argument is absent
or present, respectively.</p>
</td></tr>
<tr><td><code id="coxpls_+3A_origin">origin</code></td>
<td>
<p>for counting process data, the hazard function origin. This
option was intended to be used in conjunction with a model containing time
dependent strata in order to align the subjects properly when they cross
over from one strata to another, but it has rarely proven useful.</p>
</td></tr>
<tr><td><code id="coxpls_+3A_typeres">typeres</code></td>
<td>
<p>character string indicating the type of residual desired.
Possible values are <code>"martingale"</code>, <code>"deviance"</code>, <code>"score"</code>,
<code>"schoenfeld"</code>, <code>"dfbeta"</code>, <code>"dfbetas"</code>, and
<code>"scaledsch"</code>. Only enough of the string to determine a unique match is
required.</p>
</td></tr>
<tr><td><code id="coxpls_+3A_collapse">collapse</code></td>
<td>
<p>vector indicating which rows to collapse (sum) over. In
time-dependent models more than one row data can pertain to a single
individual. If there were 4 individuals represented by 3, 1, 2 and 4 rows of
data respectively, then <code>collapse=c(1,1,1,2,3,3,4,4,4,4)</code> could be used
to obtain per subject rather than per observation residuals.</p>
</td></tr>
<tr><td><code id="coxpls_+3A_weighted">weighted</code></td>
<td>
<p>if <code>TRUE</code> and the model was fit with case weights, then
the weighted residuals are returned.</p>
</td></tr>
<tr><td><code id="coxpls_+3A_scalex">scaleX</code></td>
<td>
<p>Should the <code>Xplan</code> columns be standardized ?</p>
</td></tr>
<tr><td><code id="coxpls_+3A_scaley">scaleY</code></td>
<td>
<p>Should the <code>time</code> values be standardized ?</p>
</td></tr>
<tr><td><code id="coxpls_+3A_ncomp">ncomp</code></td>
<td>
<p>The number of components to include in the model. It this is
not supplied, min(7,maximal number) components is used.</p>
</td></tr>
<tr><td><code id="coxpls_+3A_modepls">modepls</code></td>
<td>
<p>character string. What type of algorithm to use, (partially)
matching one of &quot;regression&quot;, &quot;canonical&quot;, &quot;invariant&quot; or &quot;classic&quot;. See
<code><a href="mixOmics.html#topic+pls">pls</a></code> for details</p>
</td></tr>
<tr><td><code id="coxpls_+3A_plot">plot</code></td>
<td>
<p>Should the survival function be plotted ?)</p>
</td></tr>
<tr><td><code id="coxpls_+3A_allres">allres</code></td>
<td>
<p>FALSE to return only the Cox model and TRUE for additionnal
results. See details. Defaults to FALSE.</p>
</td></tr>
<tr><td><code id="coxpls_+3A_dataxplan">dataXplan</code></td>
<td>
<p>an optional data frame, list or environment (or object
coercible by <code><a href="base.html#topic+as.data.frame">as.data.frame</a></code> to a data frame) containing the
variables in the model. If not found in <code>dataXplan</code>, the variables are
taken from <code>environment(Xplan)</code>, typically the environment from which
<code>coxpls</code> is called.</p>
</td></tr>
<tr><td><code id="coxpls_+3A_subset">subset</code></td>
<td>
<p>an optional vector specifying a subset of observations to be
used in the fitting process.</p>
</td></tr>
<tr><td><code id="coxpls_+3A_weights">weights</code></td>
<td>
<p>an optional vector of 'prior weights' to be used in the
fitting process. Should be <code>NULL</code> or a numeric vector.</p>
</td></tr>
<tr><td><code id="coxpls_+3A_model_frame">model_frame</code></td>
<td>
<p>If <code>TRUE</code>, the model frame is returned.</p>
</td></tr>
<tr><td><code id="coxpls_+3A_model_matrix">model_matrix</code></td>
<td>
<p>If <code>TRUE</code>, the model matrix is returned.</p>
</td></tr>
<tr><td><code id="coxpls_+3A_contrasts.arg">contrasts.arg</code></td>
<td>
<p>a list, whose entries are values (numeric matrices, 
functions or character strings naming functions) to be used as replacement 
values for the contrasts replacement function and whose names are the names 
of columns of data containing factors.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>allres=FALSE</code> returns only the final Cox-model. If
<code>allres=TRUE</code> returns a list with the PLS components, the final
Cox-model and the PLSR model. <code>allres=TRUE</code> is useful for evluating
model prediction accuracy on a test sample.
</p>


<h3>Value</h3>

<p>If <code>allres=FALSE</code> : </p>
<table>
<tr><td><code>cox_pls</code></td>
<td>
<p>Final Cox-model.</p>
</td></tr></table>
<p> If
<code>allres=TRUE</code> : </p>
<table>
<tr><td><code>tt_pls</code></td>
<td>
<p>PLSR components.</p>
</td></tr> <tr><td><code>cox_pls</code></td>
<td>
<p>Final
Cox-model.</p>
</td></tr> <tr><td><code>pls_mod</code></td>
<td>
<p>The PLSR model.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Frédéric Bertrand<br />
<a href="mailto:frederic.bertrand@utt.fr">frederic.bertrand@utt.fr</a><br />
<a href="http://www-irma.u-strasbg.fr/~fbertran/">http://www-irma.u-strasbg.fr/~fbertran/</a>
</p>


<h3>References</h3>

<p>plsRcox, Cox-Models in a high dimensional setting in R, Frederic
Bertrand, Philippe Bastien, Nicolas Meyer and Myriam Maumy-Bertrand (2014).
Proceedings of User2014!, Los Angeles, page 152.<br />
</p>
<p>Deviance residuals-based sparse PLS and sparse kernel PLS regression for
censored data, Philippe Bastien, Frederic Bertrand, Nicolas Meyer and Myriam
Maumy-Bertrand (2015), Bioinformatics, 31(3):397-404,
doi:10.1093/bioinformatics/btu660.
</p>


<h3>See Also</h3>

<p><code><a href="survival.html#topic+coxph">coxph</a></code>, <code><a href="pls.html#topic+plsr">plsr</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(micro.censure)
data(Xmicro.censure_compl_imp)

X_train_micro &lt;- apply((as.matrix(Xmicro.censure_compl_imp)),FUN="as.numeric",MARGIN=2)[1:80,]
X_train_micro_df &lt;- data.frame(X_train_micro)
Y_train_micro &lt;- micro.censure$survyear[1:80]
C_train_micro &lt;- micro.censure$DC[1:80]

(cox_pls_fit=coxpls(X_train_micro,Y_train_micro,C_train_micro,ncomp=6))
(cox_pls_fit=coxpls(~X_train_micro,Y_train_micro,C_train_micro,ncomp=6))
(cox_pls_fit=coxpls(~.,Y_train_micro,C_train_micro,ncomp=6,dataXplan=X_train_micro_df))

rm(X_train_micro,Y_train_micro,C_train_micro,cox_pls_fit)

</code></pre>

<hr>
<h2 id='coxpls2'>Fitting a Cox-Model on PLSR components</h2><span id='topic+coxpls2'></span><span id='topic+coxpls2.default'></span><span id='topic+coxpls2.formula'></span>

<h3>Description</h3>

<p>This function computes the the Cox-Model with PLSR components as the
explanatory variables. It uses the package <code>pls</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coxpls2(Xplan, ...)

## Default S3 method:
coxpls2(
  Xplan,
  time,
  time2,
  event,
  type,
  origin,
  typeres = "deviance",
  collapse,
  weighted,
  scaleX = TRUE,
  scaleY = TRUE,
  ncomp = min(7, ncol(Xplan)),
  methodpls = "kernelpls",
  validation = "CV",
  plot = FALSE,
  allres = FALSE,
  ...
)

## S3 method for class 'formula'
coxpls2(
  Xplan,
  time,
  time2,
  event,
  type,
  origin,
  typeres = "deviance",
  collapse,
  weighted,
  scaleX = TRUE,
  scaleY = TRUE,
  ncomp = min(7, ncol(Xplan)),
  methodpls = "kernelpls",
  validation = "CV",
  plot = FALSE,
  allres = FALSE,
  dataXplan = NULL,
  subset,
  weights,
  model_frame = FALSE,
  model_matrix = FALSE,
  contrasts.arg = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coxpls2_+3A_xplan">Xplan</code></td>
<td>
<p>a formula or a matrix with the eXplanatory variables (training)
dataset</p>
</td></tr>
<tr><td><code id="coxpls2_+3A_...">...</code></td>
<td>
<p>Arguments to be passed on to <code>survival::coxph</code>.</p>
</td></tr>
<tr><td><code id="coxpls2_+3A_time">time</code></td>
<td>
<p>for right censored data, this is the follow up time. For
interval data, the first argument is the starting time for the interval.</p>
</td></tr>
<tr><td><code id="coxpls2_+3A_time2">time2</code></td>
<td>
<p>The status indicator, normally 0=alive, 1=dead. Other choices
are <code>TRUE/FALSE</code> (<code>TRUE</code> = death) or 1/2 (2=death). For interval
censored data, the status indicator is 0=right censored, 1=event at
<code>time</code>, 2=left censored, 3=interval censored. Although unusual, the
event indicator can be omitted, in which case all subjects are assumed to
have an event.</p>
</td></tr>
<tr><td><code id="coxpls2_+3A_event">event</code></td>
<td>
<p>ending time of the interval for interval censored or counting
process data only. Intervals are assumed to be open on the left and closed
on the right, <code>(start, end]</code>. For counting process data, event
indicates whether an event occurred at the end of the interval.</p>
</td></tr>
<tr><td><code id="coxpls2_+3A_type">type</code></td>
<td>
<p>character string specifying the type of censoring. Possible
values are <code>"right"</code>, <code>"left"</code>, <code>"counting"</code>,
<code>"interval"</code>, or <code>"interval2"</code>. The default is <code>"right"</code> or
<code>"counting"</code> depending on whether the <code>time2</code> argument is absent
or present, respectively.</p>
</td></tr>
<tr><td><code id="coxpls2_+3A_origin">origin</code></td>
<td>
<p>for counting process data, the hazard function origin. This
option was intended to be used in conjunction with a model containing time
dependent strata in order to align the subjects properly when they cross
over from one strata to another, but it has rarely proven useful.</p>
</td></tr>
<tr><td><code id="coxpls2_+3A_typeres">typeres</code></td>
<td>
<p>character string indicating the type of residual desired.
Possible values are <code>"martingale"</code>, <code>"deviance"</code>, <code>"score"</code>,
<code>"schoenfeld"</code>, <code>"dfbeta"</code>, <code>"dfbetas"</code>, and
<code>"scaledsch"</code>. Only enough of the string to determine a unique match is
required.</p>
</td></tr>
<tr><td><code id="coxpls2_+3A_collapse">collapse</code></td>
<td>
<p>vector indicating which rows to collapse (sum) over. In
time-dependent models more than one row data can pertain to a single
individual. If there were 4 individuals represented by 3, 1, 2 and 4 rows of
data respectively, then <code>collapse=c(1,1,1,2,3,3,4,4,4,4)</code> could be used
to obtain per subject rather than per observation residuals.</p>
</td></tr>
<tr><td><code id="coxpls2_+3A_weighted">weighted</code></td>
<td>
<p>if <code>TRUE</code> and the model was fit with case weights, then
the weighted residuals are returned.</p>
</td></tr>
<tr><td><code id="coxpls2_+3A_scalex">scaleX</code></td>
<td>
<p>Should the <code>Xplan</code> columns be standardized ?</p>
</td></tr>
<tr><td><code id="coxpls2_+3A_scaley">scaleY</code></td>
<td>
<p>Should the <code>time</code> values be standardized ?</p>
</td></tr>
<tr><td><code id="coxpls2_+3A_ncomp">ncomp</code></td>
<td>
<p>The number of components to include in the model. The number of
components to fit is specified with the argument ncomp. It this is not
supplied, the maximal number of components is used (taking account of any
cross-validation).</p>
</td></tr>
<tr><td><code id="coxpls2_+3A_methodpls">methodpls</code></td>
<td>
<p>The multivariate regression method to be used. See
<code><a href="pls.html#topic+mvrCv">mvrCv</a></code> for details.</p>
</td></tr>
<tr><td><code id="coxpls2_+3A_validation">validation</code></td>
<td>
<p>character. What kind of (internal) validation to use. If
<code>validation = "CV"</code>, cross-validation is performed. The number and type
of cross-validation segments are specified with the arguments
<code>segments</code> and <code>segment.type</code>. See <code><a href="pls.html#topic+mvrCv">mvrCv</a></code> for
details. If <code>validation = "LOO"</code>, leave-one-out cross-validation is
performed. It is an error to specify the segments when <code>validation =
"LOO"</code> is specified.</p>
</td></tr>
<tr><td><code id="coxpls2_+3A_plot">plot</code></td>
<td>
<p>Should the survival function be plotted ?)</p>
</td></tr>
<tr><td><code id="coxpls2_+3A_allres">allres</code></td>
<td>
<p>FALSE to return only the Cox model and TRUE for additionnal
results. See details. Defaults to FALSE.</p>
</td></tr>
<tr><td><code id="coxpls2_+3A_dataxplan">dataXplan</code></td>
<td>
<p>an optional data frame, list or environment (or object
coercible by <code><a href="base.html#topic+as.data.frame">as.data.frame</a></code> to a data frame) containing the
variables in the model. If not found in <code>dataXplan</code>, the variables are
taken from <code>environment(Xplan)</code>, typically the environment from which
<code>coxpls2</code> is called.</p>
</td></tr>
<tr><td><code id="coxpls2_+3A_subset">subset</code></td>
<td>
<p>an optional vector specifying a subset of observations to be
used in the fitting process.</p>
</td></tr>
<tr><td><code id="coxpls2_+3A_weights">weights</code></td>
<td>
<p>an optional vector of 'prior weights' to be used in the
fitting process. Should be <code>NULL</code> or a numeric vector.</p>
</td></tr>
<tr><td><code id="coxpls2_+3A_model_frame">model_frame</code></td>
<td>
<p>If <code>TRUE</code>, the model frame is returned.</p>
</td></tr>
<tr><td><code id="coxpls2_+3A_model_matrix">model_matrix</code></td>
<td>
<p>If <code>TRUE</code>, the model matrix is returned.</p>
</td></tr>
<tr><td><code id="coxpls2_+3A_contrasts.arg">contrasts.arg</code></td>
<td>
<p>a list, whose entries are values (numeric matrices, 
functions or character strings naming functions) to be used as replacement 
values for the contrasts replacement function and whose names are the names 
of columns of data containing factors.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>allres=FALSE</code> returns only the final Cox-model. If
<code>allres=TRUE</code> returns a list with the PLS components, the final
Cox-model and the PLSR model. <code>allres=TRUE</code> is useful for evluating
model prediction accuracy on a test sample.
</p>


<h3>Value</h3>

<p>If <code>allres=FALSE</code> : </p>
<table>
<tr><td><code>cox_pls</code></td>
<td>
<p>Final Cox-model.</p>
</td></tr></table>
<p> If
<code>allres=TRUE</code> : </p>
<table>
<tr><td><code>tt_pls</code></td>
<td>
<p>PLSR components.</p>
</td></tr> <tr><td><code>cox_pls</code></td>
<td>
<p>Final
Cox-model.</p>
</td></tr> <tr><td><code>pls_mod</code></td>
<td>
<p>The PLSR model.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Frédéric Bertrand<br />
<a href="mailto:frederic.bertrand@utt.fr">frederic.bertrand@utt.fr</a><br />
<a href="http://www-irma.u-strasbg.fr/~fbertran/">http://www-irma.u-strasbg.fr/~fbertran/</a>
</p>


<h3>References</h3>

<p>plsRcox, Cox-Models in a high dimensional setting in R, Frederic
Bertrand, Philippe Bastien, Nicolas Meyer and Myriam Maumy-Bertrand (2014).
Proceedings of User2014!, Los Angeles, page 152.<br />
</p>
<p>Deviance residuals-based sparse PLS and sparse kernel PLS regression for
censored data, Philippe Bastien, Frederic Bertrand, Nicolas Meyer and Myriam
Maumy-Bertrand (2015), Bioinformatics, 31(3):397-404,
doi:10.1093/bioinformatics/btu660.
</p>


<h3>See Also</h3>

<p><code><a href="survival.html#topic+coxph">coxph</a></code>, <code><a href="pls.html#topic+plsr">plsr</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(micro.censure)
data(Xmicro.censure_compl_imp)

X_train_micro &lt;- apply((as.matrix(Xmicro.censure_compl_imp)),FUN="as.numeric",MARGIN=2)[1:80,]
X_train_micro_df &lt;- data.frame(X_train_micro)
Y_train_micro &lt;- micro.censure$survyear[1:80]
C_train_micro &lt;- micro.censure$DC[1:80]

(cox_pls_fit=coxpls2(X_train_micro,Y_train_micro,C_train_micro,ncomp=6,validation="CV"))
(cox_pls_fit=coxpls2(~X_train_micro,Y_train_micro,C_train_micro,ncomp=6,validation="CV"))
(cox_pls_fit=coxpls2(~.,Y_train_micro,C_train_micro,ncomp=6,validation="CV",
dataXplan=X_train_micro_df))

rm(X_train_micro,Y_train_micro,C_train_micro,cox_pls_fit)

</code></pre>

<hr>
<h2 id='coxpls2DR'>Fitting a PLSR model on the (Deviance) Residuals</h2><span id='topic+coxpls2DR'></span><span id='topic+coxpls2DR.default'></span><span id='topic+coxpls2DR.formula'></span>

<h3>Description</h3>

<p>This function computes the PLSR model with the Residuals of a Cox-Model
fitted with an intercept as the only explanatory variable as the response
and Xplan as explanatory variables. Default behaviour uses the Deviance
residuals. It uses the package <code>pls</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coxpls2DR(Xplan, ...)

## Default S3 method:
coxpls2DR(
  Xplan,
  time,
  time2,
  event,
  type,
  origin,
  typeres = "deviance",
  collapse,
  weighted,
  scaleX = TRUE,
  scaleY = TRUE,
  ncomp = min(7, ncol(Xplan)),
  methodpls = "kernelpls",
  validation = "CV",
  plot = FALSE,
  allres = FALSE,
  ...
)

## S3 method for class 'formula'
coxpls2DR(
  Xplan,
  time,
  time2,
  event,
  type,
  origin,
  typeres = "deviance",
  collapse,
  weighted,
  scaleX = TRUE,
  scaleY = TRUE,
  ncomp = min(7, ncol(Xplan)),
  methodpls = "kernelpls",
  validation = "CV",
  plot = FALSE,
  allres = FALSE,
  dataXplan = NULL,
  subset,
  weights,
  model_frame = FALSE,
  model_matrix = FALSE,
  contrasts.arg = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coxpls2DR_+3A_xplan">Xplan</code></td>
<td>
<p>a formula or a matrix with the eXplanatory variables (training)
dataset</p>
</td></tr>
<tr><td><code id="coxpls2DR_+3A_...">...</code></td>
<td>
<p>Arguments to be passed on to <code>survival::coxph</code>.</p>
</td></tr>
<tr><td><code id="coxpls2DR_+3A_time">time</code></td>
<td>
<p>for right censored data, this is the follow up time. For
interval data, the first argument is the starting time for the interval.</p>
</td></tr>
<tr><td><code id="coxpls2DR_+3A_time2">time2</code></td>
<td>
<p>The status indicator, normally 0=alive, 1=dead. Other choices
are <code>TRUE/FALSE</code> (<code>TRUE</code> = death) or 1/2 (2=death). For interval
censored data, the status indicator is 0=right censored, 1=event at
<code>time</code>, 2=left censored, 3=interval censored. Although unusual, the
event indicator can be omitted, in which case all subjects are assumed to
have an event.</p>
</td></tr>
<tr><td><code id="coxpls2DR_+3A_event">event</code></td>
<td>
<p>ending time of the interval for interval censored or counting
process data only. Intervals are assumed to be open on the left and closed
on the right, <code>(start, end]</code>. For counting process data, event
indicates whether an event occurred at the end of the interval.</p>
</td></tr>
<tr><td><code id="coxpls2DR_+3A_type">type</code></td>
<td>
<p>character string specifying the type of censoring. Possible
values are <code>"right"</code>, <code>"left"</code>, <code>"counting"</code>,
<code>"interval"</code>, or <code>"interval2"</code>. The default is <code>"right"</code> or
<code>"counting"</code> depending on whether the <code>time2</code> argument is absent
or present, respectively.</p>
</td></tr>
<tr><td><code id="coxpls2DR_+3A_origin">origin</code></td>
<td>
<p>for counting process data, the hazard function origin. This
option was intended to be used in conjunction with a model containing time
dependent strata in order to align the subjects properly when they cross
over from one strata to another, but it has rarely proven useful.</p>
</td></tr>
<tr><td><code id="coxpls2DR_+3A_typeres">typeres</code></td>
<td>
<p>character string indicating the type of residual desired.
Possible values are <code>"martingale"</code>, <code>"deviance"</code>, <code>"score"</code>,
<code>"schoenfeld"</code>, <code>"dfbeta"</code>, <code>"dfbetas"</code>, and
<code>"scaledsch"</code>. Only enough of the string to determine a unique match is
required.</p>
</td></tr>
<tr><td><code id="coxpls2DR_+3A_collapse">collapse</code></td>
<td>
<p>vector indicating which rows to collapse (sum) over. In
time-dependent models more than one row data can pertain to a single
individual. If there were 4 individuals represented by 3, 1, 2 and 4 rows of
data respectively, then <code>collapse=c(1,1,1,2,3,3,4,4,4,4)</code> could be used
to obtain per subject rather than per observation residuals.</p>
</td></tr>
<tr><td><code id="coxpls2DR_+3A_weighted">weighted</code></td>
<td>
<p>if <code>TRUE</code> and the model was fit with case weights, then
the weighted residuals are returned.</p>
</td></tr>
<tr><td><code id="coxpls2DR_+3A_scalex">scaleX</code></td>
<td>
<p>Should the <code>Xplan</code> columns be standardized ?</p>
</td></tr>
<tr><td><code id="coxpls2DR_+3A_scaley">scaleY</code></td>
<td>
<p>Should the <code>time</code> values be standardized ?</p>
</td></tr>
<tr><td><code id="coxpls2DR_+3A_ncomp">ncomp</code></td>
<td>
<p>The number of components to include in the model. The number of
components to fit is specified with the argument ncomp. It this is not
supplied, the maximal number of components is used (taking account of any
cross-validation).</p>
</td></tr>
<tr><td><code id="coxpls2DR_+3A_methodpls">methodpls</code></td>
<td>
<p>The multivariate regression method to be used. See
<code><a href="pls.html#topic+mvrCv">mvrCv</a></code> for details.</p>
</td></tr>
<tr><td><code id="coxpls2DR_+3A_validation">validation</code></td>
<td>
<p>character. What kind of (internal) validation to use. If
<code>validation = "CV"</code>, cross-validation is performed. The number and type
of cross-validation segments are specified with the arguments
<code>segments</code> and <code>segment.type</code>. See <code><a href="pls.html#topic+mvrCv">mvrCv</a></code> for
details. If <code>validation = "LOO"</code>, leave-one-out cross-validation is
performed. It is an error to specify the segments when <code>validation =
"LOO"</code> is specified.</p>
</td></tr>
<tr><td><code id="coxpls2DR_+3A_plot">plot</code></td>
<td>
<p>Should the survival function be plotted ?)</p>
</td></tr>
<tr><td><code id="coxpls2DR_+3A_allres">allres</code></td>
<td>
<p>FALSE to return only the Cox model and TRUE for additionnal
results. See details. Defaults to FALSE.</p>
</td></tr>
<tr><td><code id="coxpls2DR_+3A_dataxplan">dataXplan</code></td>
<td>
<p>an optional data frame, list or environment (or object
coercible by <code><a href="base.html#topic+as.data.frame">as.data.frame</a></code> to a data frame) containing the
variables in the model. If not found in <code>dataXplan</code>, the variables are
taken from <code>environment(Xplan)</code>, typically the environment from which
<code>coxpls2DR</code> is called.</p>
</td></tr>
<tr><td><code id="coxpls2DR_+3A_subset">subset</code></td>
<td>
<p>an optional vector specifying a subset of observations to be
used in the fitting process.</p>
</td></tr>
<tr><td><code id="coxpls2DR_+3A_weights">weights</code></td>
<td>
<p>an optional vector of 'prior weights' to be used in the
fitting process. Should be <code>NULL</code> or a numeric vector.</p>
</td></tr>
<tr><td><code id="coxpls2DR_+3A_model_frame">model_frame</code></td>
<td>
<p>If <code>TRUE</code>, the model frame is returned.</p>
</td></tr>
<tr><td><code id="coxpls2DR_+3A_model_matrix">model_matrix</code></td>
<td>
<p>If <code>TRUE</code>, the model matrix is returned.</p>
</td></tr>
<tr><td><code id="coxpls2DR_+3A_contrasts.arg">contrasts.arg</code></td>
<td>
<p>a list, whose entries are values (numeric matrices, 
functions or character strings naming functions) to be used as replacement 
values for the contrasts replacement function and whose names are the names 
of columns of data containing factors.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>allres=FALSE</code> returns only the final Cox-model. If
<code>allres=TRUE</code> returns a list with the PLS components, the final
Cox-model and the PLSR model. <code>allres=TRUE</code> is useful for evluating
model prediction accuracy on a test sample.
</p>


<h3>Value</h3>

<p>If <code>allres=FALSE</code> : </p>
<table>
<tr><td><code>cox_pls2DR</code></td>
<td>
<p>Final Cox-model.</p>
</td></tr></table>
<p> If
<code>allres=TRUE</code> : </p>
<table>
<tr><td><code>tt_pls2DR</code></td>
<td>
<p>PLSR components.</p>
</td></tr>
<tr><td><code>cox_pls2DR</code></td>
<td>
<p>Final Cox-model.</p>
</td></tr> <tr><td><code>pls2DR_mod</code></td>
<td>
<p>The PLSR model.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Frédéric Bertrand<br />
<a href="mailto:frederic.bertrand@utt.fr">frederic.bertrand@utt.fr</a><br />
<a href="http://www-irma.u-strasbg.fr/~fbertran/">http://www-irma.u-strasbg.fr/~fbertran/</a>
</p>


<h3>References</h3>

<p>plsRcox, Cox-Models in a high dimensional setting in R, Frederic
Bertrand, Philippe Bastien, Nicolas Meyer and Myriam Maumy-Bertrand (2014).
Proceedings of User2014!, Los Angeles, page 152.<br />
</p>
<p>Deviance residuals-based sparse PLS and sparse kernel PLS regression for
censored data, Philippe Bastien, Frederic Bertrand, Nicolas Meyer and Myriam
Maumy-Bertrand (2015), Bioinformatics, 31(3):397-404,
doi:10.1093/bioinformatics/btu660.
</p>


<h3>See Also</h3>

<p><code><a href="survival.html#topic+coxph">coxph</a></code>, <code><a href="pls.html#topic+plsr">plsr</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(micro.censure)
data(Xmicro.censure_compl_imp)

X_train_micro &lt;- apply((as.matrix(Xmicro.censure_compl_imp)),FUN="as.numeric",MARGIN=2)[1:80,]
X_train_micro_df &lt;- data.frame(X_train_micro)
Y_train_micro &lt;- micro.censure$survyear[1:80]
C_train_micro &lt;- micro.censure$DC[1:80]

(cox_pls2DR_fit=coxpls2DR(X_train_micro,Y_train_micro,C_train_micro,ncomp=6,validation="none"))
(cox_pls2DR_fit2=coxpls2DR(~X_train_micro,Y_train_micro,C_train_micro,ncomp=6,validation="none"))
(cox_pls2DR_fit3=coxpls2DR(~.,Y_train_micro,C_train_micro,ncomp=6,validation="none",
dataXplan=X_train_micro_df))

rm(X_train_micro,Y_train_micro,C_train_micro,cox_pls2DR_fit,cox_pls2DR_fit2,cox_pls2DR_fit3)

</code></pre>

<hr>
<h2 id='coxpls3'>Fitting a Cox-Model on PLSR components</h2><span id='topic+coxpls3'></span><span id='topic+coxpls3.default'></span><span id='topic+coxpls3.formula'></span>

<h3>Description</h3>

<p>This function computes the the Cox-Model with PLSR components as the
explanatory variables. It uses the package <code>plsRglm</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coxpls3(Xplan, ...)

## Default S3 method:
coxpls3(
  Xplan,
  time,
  time2,
  event,
  type,
  origin,
  typeres = "deviance",
  collapse,
  weighted,
  scaleX = TRUE,
  scaleY = TRUE,
  nt = min(7, ncol(Xplan)),
  typeVC = "none",
  plot = FALSE,
  allres = FALSE,
  sparse = FALSE,
  sparseStop = TRUE,
  ...
)

## S3 method for class 'formula'
coxpls3(
  Xplan,
  time,
  time2,
  event,
  type,
  origin,
  typeres = "deviance",
  collapse,
  weighted,
  scaleX = TRUE,
  scaleY = TRUE,
  nt = min(7, ncol(Xplan)),
  typeVC = "none",
  plot = FALSE,
  allres = FALSE,
  dataXplan = NULL,
  subset,
  weights,
  model_frame = FALSE,
  sparse = FALSE,
  sparseStop = TRUE,
  model_matrix = FALSE,
  contrasts.arg = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coxpls3_+3A_xplan">Xplan</code></td>
<td>
<p>a formula or a matrix with the eXplanatory variables (training)
dataset</p>
</td></tr>
<tr><td><code id="coxpls3_+3A_...">...</code></td>
<td>
<p>Arguments to be passed on to <code>survival::coxph</code> and to
<code>plsRglm::PLS_lm</code>.</p>
</td></tr>
<tr><td><code id="coxpls3_+3A_time">time</code></td>
<td>
<p>for right censored data, this is the follow up time. For
interval data, the first argument is the starting time for the interval.</p>
</td></tr>
<tr><td><code id="coxpls3_+3A_time2">time2</code></td>
<td>
<p>The status indicator, normally 0=alive, 1=dead. Other choices
are <code>TRUE/FALSE</code> (<code>TRUE</code> = death) or 1/2 (2=death). For interval
censored data, the status indicator is 0=right censored, 1=event at
<code>time</code>, 2=left censored, 3=interval censored. Although unusual, the
event indicator can be omitted, in which case all subjects are assumed to
have an event.</p>
</td></tr>
<tr><td><code id="coxpls3_+3A_event">event</code></td>
<td>
<p>ending time of the interval for interval censored or counting
process data only. Intervals are assumed to be open on the left and closed
on the right, <code>(start, end]</code>. For counting process data, event
indicates whether an event occurred at the end of the interval.</p>
</td></tr>
<tr><td><code id="coxpls3_+3A_type">type</code></td>
<td>
<p>character string specifying the type of censoring. Possible
values are <code>"right"</code>, <code>"left"</code>, <code>"counting"</code>,
<code>"interval"</code>, or <code>"interval2"</code>. The default is <code>"right"</code> or
<code>"counting"</code> depending on whether the <code>time2</code> argument is absent
or present, respectively.</p>
</td></tr>
<tr><td><code id="coxpls3_+3A_origin">origin</code></td>
<td>
<p>for counting process data, the hazard function origin. This
option was intended to be used in conjunction with a model containing time
dependent strata in order to align the subjects properly when they cross
over from one strata to another, but it has rarely proven useful.</p>
</td></tr>
<tr><td><code id="coxpls3_+3A_typeres">typeres</code></td>
<td>
<p>character string indicating the type of residual desired.
Possible values are <code>"martingale"</code>, <code>"deviance"</code>, <code>"score"</code>,
<code>"schoenfeld"</code>, <code>"dfbeta"</code>, <code>"dfbetas"</code>, and
<code>"scaledsch"</code>. Only enough of the string to determine a unique match is
required.</p>
</td></tr>
<tr><td><code id="coxpls3_+3A_collapse">collapse</code></td>
<td>
<p>vector indicating which rows to collapse (sum) over. In
time-dependent models more than one row data can pertain to a single
individual. If there were 4 individuals represented by 3, 1, 2 and 4 rows of
data respectively, then <code>collapse=c(1,1,1,2,3,3,4,4,4,4)</code> could be used
to obtain per subject rather than per observation residuals.</p>
</td></tr>
<tr><td><code id="coxpls3_+3A_weighted">weighted</code></td>
<td>
<p>if <code>TRUE</code> and the model was fit with case weights, then
the weighted residuals are returned.</p>
</td></tr>
<tr><td><code id="coxpls3_+3A_scalex">scaleX</code></td>
<td>
<p>Should the <code>Xplan</code> columns be standardized ?</p>
</td></tr>
<tr><td><code id="coxpls3_+3A_scaley">scaleY</code></td>
<td>
<p>Should the <code>time</code> values be standardized ?</p>
</td></tr>
<tr><td><code id="coxpls3_+3A_nt">nt</code></td>
<td>
<p>Number of PLSR components to fit.</p>
</td></tr>
<tr><td><code id="coxpls3_+3A_typevc">typeVC</code></td>
<td>
<p>type of leave one out crossed validation. Several procedures
are available and may be forced.  </p>
 <dl>
<dt>list(&quot;none&quot;)</dt><dd><p>no crossed
validation</p>
</dd> <dt>list(&quot;standard&quot;)</dt><dd><p>as in SIMCA for datasets without missing
values and with all values predicted as those with missing values for
datasets with any missing values</p>
</dd> <dt>list(&quot;missingdata&quot;)</dt><dd><p>all values
predicted as those with missing values for datasets with any missing values</p>
</dd>
<dt>list(&quot;adaptative&quot;)</dt><dd><p>predict a response value for an x with any missing
value as those with missing values and for an x without any missing value as
those without missing values.</p>
</dd> </dl>
</td></tr>
<tr><td><code id="coxpls3_+3A_plot">plot</code></td>
<td>
<p>Should the survival function be plotted ?)</p>
</td></tr>
<tr><td><code id="coxpls3_+3A_allres">allres</code></td>
<td>
<p>FALSE to return only the Cox model and TRUE for additionnal
results. See details. Defaults to FALSE.</p>
</td></tr>
<tr><td><code id="coxpls3_+3A_sparse">sparse</code></td>
<td>
<p>should the coefficients of non-significant predictors
(&lt;<code>alpha.pvals.expli</code>) be set to 0</p>
</td></tr>
<tr><td><code id="coxpls3_+3A_sparsestop">sparseStop</code></td>
<td>
<p>should component extraction stop when no significant
predictors (&lt;<code>alpha.pvals.expli</code>) are found</p>
</td></tr>
<tr><td><code id="coxpls3_+3A_dataxplan">dataXplan</code></td>
<td>
<p>an optional data frame, list or environment (or object
coercible by <code><a href="base.html#topic+as.data.frame">as.data.frame</a></code> to a data frame) containing the
variables in the model. If not found in <code>dataXplan</code>, the variables are
taken from <code>environment(Xplan)</code>, typically the environment from which
<code>coxpls3</code> is called.</p>
</td></tr>
<tr><td><code id="coxpls3_+3A_subset">subset</code></td>
<td>
<p>an optional vector specifying a subset of observations to be
used in the fitting process.</p>
</td></tr>
<tr><td><code id="coxpls3_+3A_weights">weights</code></td>
<td>
<p>an optional vector of 'prior weights' to be used in the
fitting process. Should be <code>NULL</code> or a numeric vector.</p>
</td></tr>
<tr><td><code id="coxpls3_+3A_model_frame">model_frame</code></td>
<td>
<p>If <code>TRUE</code>, the model frame is returned.</p>
</td></tr>
<tr><td><code id="coxpls3_+3A_model_matrix">model_matrix</code></td>
<td>
<p>If <code>TRUE</code>, the model matrix is returned.</p>
</td></tr>
<tr><td><code id="coxpls3_+3A_contrasts.arg">contrasts.arg</code></td>
<td>
<p>a list, whose entries are values (numeric matrices, 
functions or character strings naming functions) to be used as replacement 
values for the contrasts replacement function and whose names are the names 
of columns of data containing factors.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>allres=FALSE</code> returns only the final Cox-model. If
<code>allres=TRUE</code> returns a list with the PLS components, the final
Cox-model and the PLSR model. <code>allres=TRUE</code> is useful for evluating
model prediction accuracy on a test sample.
</p>


<h3>Value</h3>

<p>If <code>allres=FALSE</code> : </p>
<table>
<tr><td><code>cox_pls3</code></td>
<td>
<p>Final Cox-model.</p>
</td></tr></table>
<p> If
<code>allres=TRUE</code> : </p>
<table>
<tr><td><code>tt_pls3</code></td>
<td>
<p>PLSR components.</p>
</td></tr> <tr><td><code>cox_pls3</code></td>
<td>
<p>Final
Cox-model.</p>
</td></tr> <tr><td><code>pls3_mod</code></td>
<td>
<p>The PLSR model.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Frédéric Bertrand<br />
<a href="mailto:frederic.bertrand@utt.fr">frederic.bertrand@utt.fr</a><br />
<a href="http://www-irma.u-strasbg.fr/~fbertran/">http://www-irma.u-strasbg.fr/~fbertran/</a>
</p>


<h3>References</h3>

<p>plsRcox, Cox-Models in a high dimensional setting in R, Frederic
Bertrand, Philippe Bastien, Nicolas Meyer and Myriam Maumy-Bertrand (2014).
Proceedings of User2014!, Los Angeles, page 152.<br />
</p>
<p>Deviance residuals-based sparse PLS and sparse kernel PLS regression for
censored data, Philippe Bastien, Frederic Bertrand, Nicolas Meyer and Myriam
Maumy-Bertrand (2015), Bioinformatics, 31(3):397-404,
doi:10.1093/bioinformatics/btu660.
</p>


<h3>See Also</h3>

<p><code><a href="survival.html#topic+coxph">coxph</a></code>, <code><a href="plsRglm.html#topic+PLS_lm">PLS_lm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(micro.censure)
data(Xmicro.censure_compl_imp)

X_train_micro &lt;- apply((as.matrix(Xmicro.censure_compl_imp)),FUN="as.numeric",MARGIN=2)[1:80,]
X_train_micro_df &lt;- data.frame(X_train_micro)
Y_train_micro &lt;- micro.censure$survyear[1:80]
C_train_micro &lt;- micro.censure$DC[1:80]

(cox_pls3_fit &lt;- coxpls3(X_train_micro,Y_train_micro,C_train_micro,nt=7,typeVC="none"))
(cox_pls3_fit2 &lt;- coxpls3(~X_train_micro,Y_train_micro,C_train_micro,nt=7,typeVC="none"))
(cox_pls3_fit3 &lt;- coxpls3(~.,Y_train_micro,C_train_micro,nt=7,typeVC="none",data=X_train_micro_df))
(cox_pls3_fit4 &lt;- coxpls3(~.,Y_train_micro,C_train_micro,nt=7,typeVC="none",
data=X_train_micro_df,sparse=TRUE))
(cox_pls3_fit5 &lt;- coxpls3(~.,Y_train_micro,C_train_micro,nt=7,typeVC="none",
data=X_train_micro_df,sparse=FALSE,sparseStop=TRUE))

rm(X_train_micro,Y_train_micro,C_train_micro,cox_pls3_fit,cox_pls3_fit2,
cox_pls3_fit3,cox_pls3_fit4,cox_pls3_fit5)

</code></pre>

<hr>
<h2 id='coxpls3DR'>Fitting a PLSR model on the (Deviance) Residuals</h2><span id='topic+coxpls3DR'></span><span id='topic+coxpls3DR.default'></span><span id='topic+coxpls3DR.formula'></span>

<h3>Description</h3>

<p>This function computes the PLSR model with the Residuals of a Cox-Model
fitted with an intercept as the only explanatory variable as the response
and Xplan as explanatory variables. Default behaviour uses the Deviance
residuals. It uses the package <code>plsRglm</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coxpls3DR(Xplan, ...)

## Default S3 method:
coxpls3DR(
  Xplan,
  time,
  time2,
  event,
  type,
  origin,
  typeres = "deviance",
  collapse,
  weighted,
  scaleX = TRUE,
  scaleY = TRUE,
  nt = min(7, ncol(Xplan)),
  typeVC = "none",
  plot = FALSE,
  allres = FALSE,
  sparse = FALSE,
  sparseStop = TRUE,
  ...
)

## S3 method for class 'formula'
coxpls3DR(
  Xplan,
  time,
  time2,
  event,
  type,
  origin,
  typeres = "deviance",
  collapse,
  weighted,
  scaleX = TRUE,
  scaleY = TRUE,
  nt = min(7, ncol(Xplan)),
  typeVC = "none",
  plot = FALSE,
  allres = FALSE,
  dataXplan = NULL,
  subset,
  weights,
  model_frame = FALSE,
  sparse = FALSE,
  sparseStop = TRUE,
  model_matrix = FALSE,
  contrasts.arg = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coxpls3DR_+3A_xplan">Xplan</code></td>
<td>
<p>a formula or a matrix with the eXplanatory variables (training)
dataset</p>
</td></tr>
<tr><td><code id="coxpls3DR_+3A_...">...</code></td>
<td>
<p>Arguments to be passed on to <code>survival::coxph</code> and to
<code>plsRglm::PLS_lm</code>.</p>
</td></tr>
<tr><td><code id="coxpls3DR_+3A_time">time</code></td>
<td>
<p>for right censored data, this is the follow up time. For
interval data, the first argument is the starting time for the interval.</p>
</td></tr>
<tr><td><code id="coxpls3DR_+3A_time2">time2</code></td>
<td>
<p>The status indicator, normally 0=alive, 1=dead. Other choices
are <code>TRUE/FALSE</code> (<code>TRUE</code> = death) or 1/2 (2=death). For interval
censored data, the status indicator is 0=right censored, 1=event at
<code>time</code>, 2=left censored, 3=interval censored. Although unusual, the
event indicator can be omitted, in which case all subjects are assumed to
have an event.</p>
</td></tr>
<tr><td><code id="coxpls3DR_+3A_event">event</code></td>
<td>
<p>ending time of the interval for interval censored or counting
process data only. Intervals are assumed to be open on the left and closed
on the right, <code>(start, end]</code>. For counting process data, event
indicates whether an event occurred at the end of the interval.</p>
</td></tr>
<tr><td><code id="coxpls3DR_+3A_type">type</code></td>
<td>
<p>character string specifying the type of censoring. Possible
values are <code>"right"</code>, <code>"left"</code>, <code>"counting"</code>,
<code>"interval"</code>, or <code>"interval2"</code>. The default is <code>"right"</code> or
<code>"counting"</code> depending on whether the <code>time2</code> argument is absent
or present, respectively.</p>
</td></tr>
<tr><td><code id="coxpls3DR_+3A_origin">origin</code></td>
<td>
<p>for counting process data, the hazard function origin. This
option was intended to be used in conjunction with a model containing time
dependent strata in order to align the subjects properly when they cross
over from one strata to another, but it has rarely proven useful.</p>
</td></tr>
<tr><td><code id="coxpls3DR_+3A_typeres">typeres</code></td>
<td>
<p>character string indicating the type of residual desired.
Possible values are <code>"martingale"</code>, <code>"deviance"</code>, <code>"score"</code>,
<code>"schoenfeld"</code>, <code>"dfbeta"</code>, <code>"dfbetas"</code>, and
<code>"scaledsch"</code>. Only enough of the string to determine a unique match is
required.</p>
</td></tr>
<tr><td><code id="coxpls3DR_+3A_collapse">collapse</code></td>
<td>
<p>vector indicating which rows to collapse (sum) over. In
time-dependent models more than one row data can pertain to a single
individual. If there were 4 individuals represented by 3, 1, 2 and 4 rows of
data respectively, then <code>collapse=c(1,1,1,2,3,3,4,4,4,4)</code> could be used
to obtain per subject rather than per observation residuals.</p>
</td></tr>
<tr><td><code id="coxpls3DR_+3A_weighted">weighted</code></td>
<td>
<p>if <code>TRUE</code> and the model was fit with case weights, then
the weighted residuals are returned.</p>
</td></tr>
<tr><td><code id="coxpls3DR_+3A_scalex">scaleX</code></td>
<td>
<p>Should the <code>Xplan</code> columns be standardized ?</p>
</td></tr>
<tr><td><code id="coxpls3DR_+3A_scaley">scaleY</code></td>
<td>
<p>Should the <code>time</code> values be standardized ?</p>
</td></tr>
<tr><td><code id="coxpls3DR_+3A_nt">nt</code></td>
<td>
<p>Number of PLSR components to fit.</p>
</td></tr>
<tr><td><code id="coxpls3DR_+3A_typevc">typeVC</code></td>
<td>
<p>type of leave one out crossed validation. Several procedures
are available and may be forced.  </p>
 <dl>
<dt>list(&quot;none&quot;)</dt><dd><p>no crossed
validation</p>
</dd> <dt>list(&quot;standard&quot;)</dt><dd><p>as in SIMCA for datasets without missing
values and with all values predicted as those with missing values for
datasets with any missing values</p>
</dd> <dt>list(&quot;missingdata&quot;)</dt><dd><p>all values
predicted as those with missing values for datasets with any missing values</p>
</dd>
<dt>list(&quot;adaptative&quot;)</dt><dd><p>predict a response value for an x with any missing
value as those with missing values and for an x without any missing value as
those without missing values.</p>
</dd> </dl>
</td></tr>
<tr><td><code id="coxpls3DR_+3A_plot">plot</code></td>
<td>
<p>Should the survival function be plotted ?)</p>
</td></tr>
<tr><td><code id="coxpls3DR_+3A_allres">allres</code></td>
<td>
<p>FALSE to return only the Cox model and TRUE for additionnal
results. See details. Defaults to FALSE.</p>
</td></tr>
<tr><td><code id="coxpls3DR_+3A_sparse">sparse</code></td>
<td>
<p>should the coefficients of non-significant predictors
(&lt;<code>alpha.pvals.expli</code>) be set to 0</p>
</td></tr>
<tr><td><code id="coxpls3DR_+3A_sparsestop">sparseStop</code></td>
<td>
<p>should component extraction stop when no significant
predictors (&lt;<code>alpha.pvals.expli</code>) are found</p>
</td></tr>
<tr><td><code id="coxpls3DR_+3A_dataxplan">dataXplan</code></td>
<td>
<p>an optional data frame, list or environment (or object
coercible by <code><a href="base.html#topic+as.data.frame">as.data.frame</a></code> to a data frame) containing the
variables in the model. If not found in <code>dataXplan</code>, the variables are
taken from <code>environment(Xplan)</code>, typically the environment from which
<code>coxpls3DR</code> is called.</p>
</td></tr>
<tr><td><code id="coxpls3DR_+3A_subset">subset</code></td>
<td>
<p>an optional vector specifying a subset of observations to be
used in the fitting process.</p>
</td></tr>
<tr><td><code id="coxpls3DR_+3A_weights">weights</code></td>
<td>
<p>an optional vector of 'prior weights' to be used in the
fitting process. Should be <code>NULL</code> or a numeric vector.</p>
</td></tr>
<tr><td><code id="coxpls3DR_+3A_model_frame">model_frame</code></td>
<td>
<p>If <code>TRUE</code>, the model frame is returned.</p>
</td></tr>
<tr><td><code id="coxpls3DR_+3A_model_matrix">model_matrix</code></td>
<td>
<p>If <code>TRUE</code>, the model matrix is returned.</p>
</td></tr>
<tr><td><code id="coxpls3DR_+3A_contrasts.arg">contrasts.arg</code></td>
<td>
<p>a list, whose entries are values (numeric matrices, 
functions or character strings naming functions) to be used as replacement 
values for the contrasts replacement function and whose names are the names 
of columns of data containing factors.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>allres=FALSE</code> returns only the final Cox-model. If
<code>allres=TRUE</code> returns a list with the PLS components, the final
Cox-model and the PLSR model. <code>allres=TRUE</code> is useful for evluating
model prediction accuracy on a test sample.
</p>


<h3>Value</h3>

<p>If <code>allres=FALSE</code> : </p>
<table>
<tr><td><code>cox_pls3DR</code></td>
<td>
<p>Final Cox-model.</p>
</td></tr></table>
<p> If
<code>allres=TRUE</code> : </p>
<table>
<tr><td><code>tt_pls3DR</code></td>
<td>
<p>PLSR components.</p>
</td></tr>
<tr><td><code>cox_pls3DR</code></td>
<td>
<p>Final Cox-model.</p>
</td></tr> <tr><td><code>pls3DR_mod</code></td>
<td>
<p>The PLSR model.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Frédéric Bertrand<br />
<a href="mailto:frederic.bertrand@utt.fr">frederic.bertrand@utt.fr</a><br />
<a href="http://www-irma.u-strasbg.fr/~fbertran/">http://www-irma.u-strasbg.fr/~fbertran/</a>
</p>


<h3>References</h3>

<p>plsRcox, Cox-Models in a high dimensional setting in R, Frederic
Bertrand, Philippe Bastien, Nicolas Meyer and Myriam Maumy-Bertrand (2014).
Proceedings of User2014!, Los Angeles, page 152.<br />
</p>
<p>Deviance residuals-based sparse PLS and sparse kernel PLS regression for
censored data, Philippe Bastien, Frederic Bertrand, Nicolas Meyer and Myriam
Maumy-Bertrand (2015), Bioinformatics, 31(3):397-404,
doi:10.1093/bioinformatics/btu660.
</p>


<h3>See Also</h3>

<p><code><a href="survival.html#topic+coxph">coxph</a></code>, <code><a href="plsRglm.html#topic+PLS_lm">PLS_lm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(micro.censure)
data(Xmicro.censure_compl_imp)

X_train_micro &lt;- apply((as.matrix(Xmicro.censure_compl_imp)),FUN="as.numeric",MARGIN=2)[1:80,]
X_train_micro_df &lt;- data.frame(X_train_micro)
Y_train_micro &lt;- micro.censure$survyear[1:80]
C_train_micro &lt;- micro.censure$DC[1:80]

(cox_pls3DR_fit &lt;- coxpls3DR(X_train_micro,Y_train_micro,C_train_micro,nt=7))
(cox_pls3DR_fit2 &lt;- coxpls3DR(~X_train_micro,Y_train_micro,C_train_micro,nt=7))
(cox_pls3DR_fit3 &lt;- coxpls3DR(~.,Y_train_micro,C_train_micro,nt=7,dataXplan=X_train_micro_df))
(cox_pls3DR_fit4 &lt;- coxpls3DR(~.,Y_train_micro,C_train_micro,nt=7,typeVC="none",
data=X_train_micro_df,sparse=TRUE))
(cox_pls3DR_fit5 &lt;- coxpls3DR(~.,Y_train_micro,C_train_micro,nt=7,typeVC="none",
data=X_train_micro_df,sparse=TRUE,sparseStop=FALSE))

rm(X_train_micro,Y_train_micro,C_train_micro,cox_pls3DR_fit,cox_pls3DR_fit2,
cox_pls3DR_fit3,cox_pls3DR_fit4,cox_pls3DR_fit5)


</code></pre>

<hr>
<h2 id='coxplsDR'>Fitting a PLSR model on the (Deviance) Residuals</h2><span id='topic+coxplsDR'></span><span id='topic+coxplsDR.default'></span><span id='topic+coxplsDR.formula'></span>

<h3>Description</h3>

<p>This function computes the Cox Model based on PLSR components computed model
with </p>
 <ul>
<li><p> as the response: the Residuals of a Cox-Model fitted
with no covariate </p>
</li>
<li><p> as explanatory variables: Xplan.  </p>
</li></ul>
<p> It uses the
package <code>mixOmics</code> to perform PLSR fit.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coxplsDR(Xplan, ...)

## Default S3 method:
coxplsDR(
  Xplan,
  time,
  time2,
  event,
  type,
  origin,
  typeres = "deviance",
  collapse,
  weighted,
  scaleX = TRUE,
  scaleY = TRUE,
  ncomp = min(7, ncol(Xplan)),
  modepls = "regression",
  plot = FALSE,
  allres = FALSE,
  ...
)

## S3 method for class 'formula'
coxplsDR(
  Xplan,
  time,
  time2,
  event,
  type,
  origin,
  typeres = "deviance",
  collapse,
  weighted,
  scaleX = TRUE,
  scaleY = TRUE,
  ncomp = min(7, ncol(Xplan)),
  modepls = "regression",
  plot = FALSE,
  allres = FALSE,
  dataXplan = NULL,
  subset,
  weights,
  model_frame = FALSE,
  model_matrix = FALSE,
  contrasts.arg = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coxplsDR_+3A_xplan">Xplan</code></td>
<td>
<p>a formula or a matrix with the eXplanatory variables (training)
dataset</p>
</td></tr>
<tr><td><code id="coxplsDR_+3A_...">...</code></td>
<td>
<p>Arguments to be passed on to <code>survival::coxph</code>.</p>
</td></tr>
<tr><td><code id="coxplsDR_+3A_time">time</code></td>
<td>
<p>for right censored data, this is the follow up time. For
interval data, the first argument is the starting time for the interval.</p>
</td></tr>
<tr><td><code id="coxplsDR_+3A_time2">time2</code></td>
<td>
<p>The status indicator, normally 0=alive, 1=dead. Other choices
are <code>TRUE/FALSE</code> (<code>TRUE</code> = death) or 1/2 (2=death). For interval
censored data, the status indicator is 0=right censored, 1=event at
<code>time</code>, 2=left censored, 3=interval censored. Although unusual, the
event indicator can be omitted, in which case all subjects are assumed to
have an event.</p>
</td></tr>
<tr><td><code id="coxplsDR_+3A_event">event</code></td>
<td>
<p>ending time of the interval for interval censored or counting
process data only. Intervals are assumed to be open on the left and closed
on the right, <code>(start, end]</code>. For counting process data, event
indicates whether an event occurred at the end of the interval.</p>
</td></tr>
<tr><td><code id="coxplsDR_+3A_type">type</code></td>
<td>
<p>character string specifying the type of censoring. Possible
values are <code>"right"</code>, <code>"left"</code>, <code>"counting"</code>,
<code>"interval"</code>, or <code>"interval2"</code>. The default is <code>"right"</code> or
<code>"counting"</code> depending on whether the <code>time2</code> argument is absent
or present, respectively.</p>
</td></tr>
<tr><td><code id="coxplsDR_+3A_origin">origin</code></td>
<td>
<p>for counting process data, the hazard function origin. This
option was intended to be used in conjunction with a model containing time
dependent strata in order to align the subjects properly when they cross
over from one strata to another, but it has rarely proven useful.</p>
</td></tr>
<tr><td><code id="coxplsDR_+3A_typeres">typeres</code></td>
<td>
<p>character string indicating the type of residual desired.
Possible values are <code>"martingale"</code>, <code>"deviance"</code>, <code>"score"</code>,
<code>"schoenfeld"</code>, <code>"dfbeta"</code>, <code>"dfbetas"</code>, and
<code>"scaledsch"</code>. Only enough of the string to determine a unique match is
required.</p>
</td></tr>
<tr><td><code id="coxplsDR_+3A_collapse">collapse</code></td>
<td>
<p>vector indicating which rows to collapse (sum) over. In
time-dependent models more than one row data can pertain to a single
individual. If there were 4 individuals represented by 3, 1, 2 and 4 rows of
data respectively, then <code>collapse=c(1,1,1,2,3,3,4,4,4,4)</code> could be used
to obtain per subject rather than per observation residuals.</p>
</td></tr>
<tr><td><code id="coxplsDR_+3A_weighted">weighted</code></td>
<td>
<p>if <code>TRUE</code> and the model was fit with case weights, then
the weighted residuals are returned.</p>
</td></tr>
<tr><td><code id="coxplsDR_+3A_scalex">scaleX</code></td>
<td>
<p>Should the <code>Xplan</code> columns be standardized ?</p>
</td></tr>
<tr><td><code id="coxplsDR_+3A_scaley">scaleY</code></td>
<td>
<p>Should the <code>time</code> values be standardized ?</p>
</td></tr>
<tr><td><code id="coxplsDR_+3A_ncomp">ncomp</code></td>
<td>
<p>The number of components to include in the model. The number of
components to fit is specified with the argument ncomp. It this is not
supplied, the maximal number of components is used.</p>
</td></tr>
<tr><td><code id="coxplsDR_+3A_modepls">modepls</code></td>
<td>
<p>character string. What type of algorithm to use, (partially)
matching one of &quot;regression&quot;, &quot;canonical&quot;, &quot;invariant&quot; or &quot;classic&quot;. See
<code><a href="mixOmics.html#topic+pls">pls</a></code> for details</p>
</td></tr>
<tr><td><code id="coxplsDR_+3A_plot">plot</code></td>
<td>
<p>Should the survival function be plotted ?)</p>
</td></tr>
<tr><td><code id="coxplsDR_+3A_allres">allres</code></td>
<td>
<p>FALSE to return only the Cox model and TRUE for additionnal
results. See details. Defaults to FALSE.</p>
</td></tr>
<tr><td><code id="coxplsDR_+3A_dataxplan">dataXplan</code></td>
<td>
<p>an optional data frame, list or environment (or object
coercible by <code><a href="base.html#topic+as.data.frame">as.data.frame</a></code> to a data frame) containing the
variables in the model. If not found in <code>dataXplan</code>, the variables are
taken from <code>environment(Xplan)</code>, typically the environment from which
<code>coxplsDR</code> is called.</p>
</td></tr>
<tr><td><code id="coxplsDR_+3A_subset">subset</code></td>
<td>
<p>an optional vector specifying a subset of observations to be
used in the fitting process.</p>
</td></tr>
<tr><td><code id="coxplsDR_+3A_weights">weights</code></td>
<td>
<p>an optional vector of 'prior weights' to be used in the
fitting process. Should be <code>NULL</code> or a numeric vector.</p>
</td></tr>
<tr><td><code id="coxplsDR_+3A_model_frame">model_frame</code></td>
<td>
<p>If <code>TRUE</code>, the model frame is returned.</p>
</td></tr>
<tr><td><code id="coxplsDR_+3A_model_matrix">model_matrix</code></td>
<td>
<p>If <code>TRUE</code>, the model matrix is returned.</p>
</td></tr>
<tr><td><code id="coxplsDR_+3A_contrasts.arg">contrasts.arg</code></td>
<td>
<p>a list, whose entries are values (numeric matrices, 
functions or character strings naming functions) to be used as replacement 
values for the contrasts replacement function and whose names are the names 
of columns of data containing factors.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>allres=FALSE</code> returns only the final Cox-model. If
<code>allres=TRUE</code> returns a list with the PLS components, the final
Cox-model and the PLSR model. <code>allres=TRUE</code> is useful for evluating
model prediction accuracy on a test sample.
</p>


<h3>Value</h3>

<p>If <code>allres=FALSE</code> : </p>
<table>
<tr><td><code>cox_plsDR</code></td>
<td>
<p>Final Cox-model.</p>
</td></tr></table>
<p> If
<code>allres=TRUE</code> : </p>
<table>
<tr><td><code>tt_plsDR</code></td>
<td>
<p>PLSR components.</p>
</td></tr>
<tr><td><code>cox_plsDR</code></td>
<td>
<p>Final Cox-model.</p>
</td></tr> <tr><td><code>plsDR_mod</code></td>
<td>
<p>The PLSR model.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Frédéric Bertrand<br />
<a href="mailto:frederic.bertrand@utt.fr">frederic.bertrand@utt.fr</a><br />
<a href="http://www-irma.u-strasbg.fr/~fbertran/">http://www-irma.u-strasbg.fr/~fbertran/</a>
</p>


<h3>References</h3>

<p>plsRcox, Cox-Models in a high dimensional setting in R, Frederic
Bertrand, Philippe Bastien, Nicolas Meyer and Myriam Maumy-Bertrand (2014).
Proceedings of User2014!, Los Angeles, page 152.<br />
</p>
<p>Deviance residuals-based sparse PLS and sparse kernel PLS regression for
censored data, Philippe Bastien, Frederic Bertrand, Nicolas Meyer and Myriam
Maumy-Bertrand (2015), Bioinformatics, 31(3):397-404,
doi:10.1093/bioinformatics/btu660.
</p>


<h3>See Also</h3>

<p><code><a href="survival.html#topic+coxph">coxph</a></code>, <code><a href="pls.html#topic+plsr">plsr</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(micro.censure)
data(Xmicro.censure_compl_imp)

X_train_micro &lt;- apply((as.matrix(Xmicro.censure_compl_imp)),FUN="as.numeric",MARGIN=2)[1:80,]
X_train_micro_df &lt;- data.frame(X_train_micro)
Y_train_micro &lt;- micro.censure$survyear[1:80]
C_train_micro &lt;- micro.censure$DC[1:80]

(cox_plsDR_fit=coxplsDR(X_train_micro,Y_train_micro,C_train_micro,ncomp=6))
(cox_plsDR_fit2=coxplsDR(~X_train_micro,Y_train_micro,C_train_micro,ncomp=6))
(cox_plsDR_fit3=coxplsDR(~.,Y_train_micro,C_train_micro,ncomp=6,dataXplan=X_train_micro_df))

rm(X_train_micro,Y_train_micro,C_train_micro,cox_plsDR_fit,cox_plsDR_fit2,cox_plsDR_fit3)

</code></pre>

<hr>
<h2 id='coxsplsDR'>Fitting a sPLSR model on the (Deviance) Residuals</h2><span id='topic+coxsplsDR'></span><span id='topic+coxsplsDR.default'></span><span id='topic+coxsplsDR.formula'></span>

<h3>Description</h3>

<p>This function computes the Cox Model based on sPLSR components computed
model with </p>
 <ul>
<li><p> as the response: the Residuals of a Cox-Model
fitted with no covariate </p>
</li>
<li><p> as explanatory variables: Xplan.  </p>
</li></ul>
<p> It uses
the package <code>spls</code> to perform the first step in SPLSR then
<code>mixOmics</code> to perform PLSR step fit.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coxsplsDR(Xplan, ...)

## Default S3 method:
coxsplsDR(
  Xplan,
  time,
  time2,
  event,
  type,
  origin,
  typeres = "deviance",
  collapse,
  weighted,
  scaleX = TRUE,
  scaleY = TRUE,
  ncomp = min(7, ncol(Xplan)),
  modepls = "regression",
  plot = FALSE,
  allres = FALSE,
  eta = 0.5,
  trace = FALSE,
  ...
)

## S3 method for class 'formula'
coxsplsDR(
  Xplan,
  time,
  time2,
  event,
  type,
  origin,
  typeres = "deviance",
  collapse,
  weighted,
  scaleX = TRUE,
  scaleY = TRUE,
  ncomp = min(7, ncol(Xplan)),
  modepls = "regression",
  plot = FALSE,
  allres = FALSE,
  dataXplan = NULL,
  subset,
  weights,
  model_frame = FALSE,
  eta = 0.5,
  trace = FALSE,
  model_matrix = FALSE,
  contrasts.arg = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coxsplsDR_+3A_xplan">Xplan</code></td>
<td>
<p>a formula or a matrix with the eXplanatory variables (training)
dataset</p>
</td></tr>
<tr><td><code id="coxsplsDR_+3A_...">...</code></td>
<td>
<p>Arguments to be passed on to <code>survival::coxph</code>.</p>
</td></tr>
<tr><td><code id="coxsplsDR_+3A_time">time</code></td>
<td>
<p>for right censored data, this is the follow up time. For
interval data, the first argument is the starting time for the interval.</p>
</td></tr>
<tr><td><code id="coxsplsDR_+3A_time2">time2</code></td>
<td>
<p>The status indicator, normally 0=alive, 1=dead. Other choices
are <code>TRUE/FALSE</code> (<code>TRUE</code> = death) or 1/2 (2=death). For interval
censored data, the status indicator is 0=right censored, 1=event at
<code>time</code>, 2=left censored, 3=interval censored. Although unusual, the
event indicator can be omitted, in which case all subjects are assumed to
have an event.</p>
</td></tr>
<tr><td><code id="coxsplsDR_+3A_event">event</code></td>
<td>
<p>ending time of the interval for interval censored or counting
process data only. Intervals are assumed to be open on the left and closed
on the right, <code>(start, end]</code>. For counting process data, event
indicates whether an event occurred at the end of the interval.</p>
</td></tr>
<tr><td><code id="coxsplsDR_+3A_type">type</code></td>
<td>
<p>character string specifying the type of censoring. Possible
values are <code>"right"</code>, <code>"left"</code>, <code>"counting"</code>,
<code>"interval"</code>, or <code>"interval2"</code>. The default is <code>"right"</code> or
<code>"counting"</code> depending on whether the <code>time2</code> argument is absent
or present, respectively.</p>
</td></tr>
<tr><td><code id="coxsplsDR_+3A_origin">origin</code></td>
<td>
<p>for counting process data, the hazard function origin. This
option was intended to be used in conjunction with a model containing time
dependent strata in order to align the subjects properly when they cross
over from one strata to another, but it has rarely proven useful.</p>
</td></tr>
<tr><td><code id="coxsplsDR_+3A_typeres">typeres</code></td>
<td>
<p>character string indicating the type of residual desired.
Possible values are <code>"martingale"</code>, <code>"deviance"</code>, <code>"score"</code>,
<code>"schoenfeld"</code>, <code>"dfbeta"</code>, <code>"dfbetas"</code>, and
<code>"scaledsch"</code>. Only enough of the string to determine a unique match is
required.</p>
</td></tr>
<tr><td><code id="coxsplsDR_+3A_collapse">collapse</code></td>
<td>
<p>vector indicating which rows to collapse (sum) over. In
time-dependent models more than one row data can pertain to a single
individual. If there were 4 individuals represented by 3, 1, 2 and 4 rows of
data respectively, then <code>collapse=c(1,1,1,2,3,3,4,4,4,4)</code> could be used
to obtain per subject rather than per observation residuals.</p>
</td></tr>
<tr><td><code id="coxsplsDR_+3A_weighted">weighted</code></td>
<td>
<p>if <code>TRUE</code> and the model was fit with case weights, then
the weighted residuals are returned.</p>
</td></tr>
<tr><td><code id="coxsplsDR_+3A_scalex">scaleX</code></td>
<td>
<p>Should the <code>Xplan</code> columns be standardized ?</p>
</td></tr>
<tr><td><code id="coxsplsDR_+3A_scaley">scaleY</code></td>
<td>
<p>Should the <code>time</code> values be standardized ?</p>
</td></tr>
<tr><td><code id="coxsplsDR_+3A_ncomp">ncomp</code></td>
<td>
<p>The number of components to include in the model. The number of
components to fit is specified with the argument ncomp. It this is not
supplied, the maximal number of components is used.</p>
</td></tr>
<tr><td><code id="coxsplsDR_+3A_modepls">modepls</code></td>
<td>
<p>character string. What type of algorithm to use, (partially)
matching one of &quot;regression&quot;, &quot;canonical&quot;, &quot;invariant&quot; or &quot;classic&quot;. See
<code><a href="mixOmics.html#topic+pls">pls</a></code> for details</p>
</td></tr>
<tr><td><code id="coxsplsDR_+3A_plot">plot</code></td>
<td>
<p>Should the survival function be plotted ?)</p>
</td></tr>
<tr><td><code id="coxsplsDR_+3A_allres">allres</code></td>
<td>
<p>FALSE to return only the Cox model and TRUE for additionnal
results. See details. Defaults to FALSE.</p>
</td></tr>
<tr><td><code id="coxsplsDR_+3A_eta">eta</code></td>
<td>
<p>Thresholding parameter. <code>eta</code> should be between 0 and 1.</p>
</td></tr>
<tr><td><code id="coxsplsDR_+3A_trace">trace</code></td>
<td>
<p>Print out the progress of variable selection?</p>
</td></tr>
<tr><td><code id="coxsplsDR_+3A_dataxplan">dataXplan</code></td>
<td>
<p>an optional data frame, list or environment (or object
coercible by <code><a href="base.html#topic+as.data.frame">as.data.frame</a></code> to a data frame) containing the
variables in the model. If not found in <code>dataXplan</code>, the variables are
taken from <code>environment(Xplan)</code>, typically the environment from which
<code>coxsplsDR</code> is called.</p>
</td></tr>
<tr><td><code id="coxsplsDR_+3A_subset">subset</code></td>
<td>
<p>an optional vector specifying a subset of observations to be
used in the fitting process.</p>
</td></tr>
<tr><td><code id="coxsplsDR_+3A_weights">weights</code></td>
<td>
<p>an optional vector of 'prior weights' to be used in the
fitting process. Should be <code>NULL</code> or a numeric vector.</p>
</td></tr>
<tr><td><code id="coxsplsDR_+3A_model_frame">model_frame</code></td>
<td>
<p>If <code>TRUE</code>, the model frame is returned.</p>
</td></tr>
<tr><td><code id="coxsplsDR_+3A_model_matrix">model_matrix</code></td>
<td>
<p>If <code>TRUE</code>, the model matrix is returned.</p>
</td></tr>
<tr><td><code id="coxsplsDR_+3A_contrasts.arg">contrasts.arg</code></td>
<td>
<p>a list, whose entries are values (numeric matrices, 
functions or character strings naming functions) to be used as replacement 
values for the contrasts replacement function and whose names are the names 
of columns of data containing factors.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>allres=FALSE</code> returns only the final Cox-model. If
<code>allres=TRUE</code> returns a list with the sPLS components, the final
Cox-model and the sPLSR model. <code>allres=TRUE</code> is useful for evluating
model prediction accuracy on a test sample.
</p>


<h3>Value</h3>

<p>If <code>allres=FALSE</code> : </p>
<table>
<tr><td><code>cox_splsDR</code></td>
<td>
<p>Final Cox-model.</p>
</td></tr></table>
<p> If
<code>allres=TRUE</code> : </p>
<table>
<tr><td><code>tt_splsDR</code></td>
<td>
<p>sPLSR components.</p>
</td></tr>
<tr><td><code>cox_splsDR</code></td>
<td>
<p>Final Cox-model.</p>
</td></tr> <tr><td><code>splsDR_mod</code></td>
<td>
<p>The sPLSR model.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Frédéric Bertrand<br />
<a href="mailto:frederic.bertrand@utt.fr">frederic.bertrand@utt.fr</a><br />
<a href="http://www-irma.u-strasbg.fr/~fbertran/">http://www-irma.u-strasbg.fr/~fbertran/</a>
</p>


<h3>References</h3>

<p>plsRcox, Cox-Models in a high dimensional setting in R, Frederic
Bertrand, Philippe Bastien, Nicolas Meyer and Myriam Maumy-Bertrand (2014).
Proceedings of User2014!, Los Angeles, page 152.<br />
</p>
<p>Deviance residuals-based sparse PLS and sparse kernel PLS regression for
censored data, Philippe Bastien, Frederic Bertrand, Nicolas Meyer and Myriam
Maumy-Bertrand (2015), Bioinformatics, 31(3):397-404,
doi:10.1093/bioinformatics/btu660.
</p>


<h3>See Also</h3>

<p><code><a href="survival.html#topic+coxph">coxph</a></code>, <code><a href="pls.html#topic+plsr">plsr</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(micro.censure)
data(Xmicro.censure_compl_imp)

X_train_micro &lt;- apply((as.matrix(Xmicro.censure_compl_imp)),FUN="as.numeric",MARGIN=2)[1:80,]
X_train_micro_df &lt;- data.frame(X_train_micro)
Y_train_micro &lt;- micro.censure$survyear[1:80]
C_train_micro &lt;- micro.censure$DC[1:80]

(cox_splsDR_fit=coxsplsDR(X_train_micro,Y_train_micro,C_train_micro,ncomp=6,eta=.5))
(cox_splsDR_fit2=coxsplsDR(~X_train_micro,Y_train_micro,C_train_micro,ncomp=6,eta=.5,trace=TRUE))
(cox_splsDR_fit3=coxsplsDR(~.,Y_train_micro,C_train_micro,ncomp=6,
dataXplan=X_train_micro_df,eta=.5))

rm(X_train_micro,Y_train_micro,C_train_micro,cox_splsDR_fit,cox_splsDR_fit2,cox_splsDR_fit3)

</code></pre>

<hr>
<h2 id='cv.autoplsRcox'>Cross-validating an autoplsRcox-Model</h2><span id='topic+cv.autoplsRcox'></span>

<h3>Description</h3>

<p>This function cross-validates <a href="#topic+plsRcox">plsRcox</a> models with automatic number of
components selection.<br />
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cv.autoplsRcox(
  data,
  method = c("efron", "breslow"),
  nfold = 5,
  nt = 10,
  plot.it = TRUE,
  se = TRUE,
  givefold,
  scaleX = TRUE,
  folddetails = FALSE,
  allCVcrit = FALSE,
  details = FALSE,
  namedataset = "data",
  save = FALSE,
  verbose = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cv.autoplsRcox_+3A_data">data</code></td>
<td>
<p>A list of three items: </p>
 <ul>
<li><p><code>x</code> the explanatory
variables passed to <code><a href="#topic+plsRcox">plsRcox</a></code>'s <code>Xplan</code> argument,
</p>
</li>
<li><p><code>time</code> passed to <code><a href="#topic+plsRcox">plsRcox</a></code>'s <code>time</code> argument,
</p>
</li>
<li><p><code>status</code> <code><a href="#topic+plsRcox">plsRcox</a></code>'s <code>status</code> argument.  </p>
</li></ul>
</td></tr>
<tr><td><code id="cv.autoplsRcox_+3A_method">method</code></td>
<td>
<p>A character string specifying the method for tie handling. If
there are no tied death times all the methods are equivalent. The Efron
approximation is used as the default here, it is more accurate when dealing
with tied death times, and is as efficient computationally.</p>
</td></tr>
<tr><td><code id="cv.autoplsRcox_+3A_nfold">nfold</code></td>
<td>
<p>The number of folds to use to perform the cross-validation
process.</p>
</td></tr>
<tr><td><code id="cv.autoplsRcox_+3A_nt">nt</code></td>
<td>
<p>The number of components to include in the model. It this is not
supplied, 10 components are fitted.</p>
</td></tr>
<tr><td><code id="cv.autoplsRcox_+3A_plot.it">plot.it</code></td>
<td>
<p>Shall the results be displayed on a plot ?</p>
</td></tr>
<tr><td><code id="cv.autoplsRcox_+3A_se">se</code></td>
<td>
<p>Should standard errors be plotted ?</p>
</td></tr>
<tr><td><code id="cv.autoplsRcox_+3A_givefold">givefold</code></td>
<td>
<p>Explicit list of omited values in each fold can be provided
using this argument.</p>
</td></tr>
<tr><td><code id="cv.autoplsRcox_+3A_scalex">scaleX</code></td>
<td>
<p>Shall the predictors be standardized ?</p>
</td></tr>
<tr><td><code id="cv.autoplsRcox_+3A_folddetails">folddetails</code></td>
<td>
<p>Should values and completion status for each folds be
returned ?</p>
</td></tr>
<tr><td><code id="cv.autoplsRcox_+3A_allcvcrit">allCVcrit</code></td>
<td>
<p>Should the other 13 CV criteria be evaled and returned ?</p>
</td></tr>
<tr><td><code id="cv.autoplsRcox_+3A_details">details</code></td>
<td>
<p>Should all results of the functions that perform error
computations be returned ?</p>
</td></tr>
<tr><td><code id="cv.autoplsRcox_+3A_namedataset">namedataset</code></td>
<td>
<p>Name to use to craft temporary results names</p>
</td></tr>
<tr><td><code id="cv.autoplsRcox_+3A_save">save</code></td>
<td>
<p>Should temporary results be saved ?</p>
</td></tr>
<tr><td><code id="cv.autoplsRcox_+3A_verbose">verbose</code></td>
<td>
<p>Should some CV details be displayed ?</p>
</td></tr>
<tr><td><code id="cv.autoplsRcox_+3A_...">...</code></td>
<td>
<p>Other arguments to pass to <code><a href="#topic+plsRcox">plsRcox</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It only computes the recommended iAUCSH criterion. Set <code>allCVcrit=TRUE</code>
to retrieve the 13 other ones.
</p>


<h3>Value</h3>

<table>
<tr><td><code>nt</code></td>
<td>
<p>The number of components requested</p>
</td></tr>
<tr><td><code>cv.error1</code></td>
<td>
<p>Vector with the mean values, across folds, of, per fold
unit, Cross-validated log-partial-likelihood for models with 0 to nt
components.</p>
</td></tr> <tr><td><code>cv.error2</code></td>
<td>
<p>Vector with the mean values, across folds, of,
per fold unit, van Houwelingen Cross-validated log-partial-likelihood for
models with 0 to nt components.</p>
</td></tr> <tr><td><code>cv.error3</code></td>
<td>
<p>Vector with the mean
values, across folds, of iAUC_CD for models with 0 to nt components.</p>
</td></tr>
<tr><td><code>cv.error4</code></td>
<td>
<p>Vector with the mean values, across folds, of iAUC_hc for
models with 0 to nt components.</p>
</td></tr> <tr><td><code>cv.error5</code></td>
<td>
<p>Vector with the mean
values, across folds, of iAUC_sh for models with 0 to nt components.</p>
</td></tr>
<tr><td><code>cv.error6</code></td>
<td>
<p>Vector with the mean values, across folds, of iAUC_Uno for
models with 0 to nt components.</p>
</td></tr> <tr><td><code>cv.error7</code></td>
<td>
<p>Vector with the mean
values, across folds, of iAUC_hz.train for models with 0 to nt components.</p>
</td></tr>
<tr><td><code>cv.error8</code></td>
<td>
<p>Vector with the mean values, across folds, of iAUC_hz.test
for models with 0 to nt components.</p>
</td></tr> <tr><td><code>cv.error9</code></td>
<td>
<p>Vector with the mean
values, across folds, of iAUC_survivalROC.train for models with 0 to nt
components.</p>
</td></tr> <tr><td><code>cv.error10</code></td>
<td>
<p>Vector with the mean values, across folds, of
iAUC_survivalROC.test for models with 0 to nt components.</p>
</td></tr>
<tr><td><code>cv.error11</code></td>
<td>
<p>Vector with the mean values, across folds, of iBrierScore
unw for models with 0 to nt components.</p>
</td></tr> <tr><td><code>cv.error12</code></td>
<td>
<p>Vector with the
mean values, across folds, of iSchmidScore (robust BS) unw for models with 0
to nt components.</p>
</td></tr> <tr><td><code>cv.error13</code></td>
<td>
<p>Vector with the mean values, across
folds, of iBrierScore w for models with 0 to nt components.</p>
</td></tr>
<tr><td><code>cv.error14</code></td>
<td>
<p>Vector with the mean values, across folds, of iSchmidScore
(robust BS) w for models with 0 to nt components.</p>
</td></tr> <tr><td><code>cv.se1</code></td>
<td>
<p>Vector with
the standard error values, across folds, of, per fold unit, Cross-validated
log-partial-likelihood for models with 0 to nt components.</p>
</td></tr>
<tr><td><code>cv.se2</code></td>
<td>
<p>Vector with the standard error values, across folds, of, per
fold unit, van Houwelingen Cross-validated log-partial-likelihood for models
with 0 to nt components.</p>
</td></tr> <tr><td><code>cv.se3</code></td>
<td>
<p>Vector with the standard error
values, across folds, of iAUC_CD for models with 0 to nt components.</p>
</td></tr>
<tr><td><code>cv.se4</code></td>
<td>
<p>Vector with the standard error values, across folds, of
iAUC_hc for models with 0 to nt components.</p>
</td></tr> <tr><td><code>cv.se5</code></td>
<td>
<p>Vector with the
standard error values, across folds, of iAUC_sh for models with 0 to nt
components.</p>
</td></tr> <tr><td><code>cv.se6</code></td>
<td>
<p>Vector with the standard error values, across
folds, of iAUC_Uno for models with 0 to nt components.</p>
</td></tr> <tr><td><code>cv.se7</code></td>
<td>
<p>Vector
with the standard error values, across folds, of iAUC_hz.train for models
with 0 to nt components.</p>
</td></tr> <tr><td><code>cv.se8</code></td>
<td>
<p>Vector with the standard error
values, across folds, of iAUC_hz.test for models with 0 to nt components.</p>
</td></tr>
<tr><td><code>cv.se9</code></td>
<td>
<p>Vector with the standard error values, across folds, of
iAUC_survivalROC.train for models with 0 to nt components.</p>
</td></tr>
<tr><td><code>cv.se10</code></td>
<td>
<p>Vector with the standard error values, across folds, of
iAUC_survivalROC.test for models with 0 to nt components.</p>
</td></tr>
<tr><td><code>cv.se11</code></td>
<td>
<p>Vector with the standard error values, across folds, of
iBrierScore unw for models with 0 to nt components.</p>
</td></tr> <tr><td><code>cv.se12</code></td>
<td>
<p>Vector
with the standard error values, across folds, of iSchmidScore (robust BS)
unw for models with 0 to nt components.</p>
</td></tr> <tr><td><code>cv.se13</code></td>
<td>
<p>Vector with the
standard error values, across folds, of iBrierScore w for models with 0 to
nt components.</p>
</td></tr> <tr><td><code>cv.se14</code></td>
<td>
<p>Vector with the standard error values, across
folds, of iSchmidScore (robust BS) w for models with 0 to nt components.</p>
</td></tr>
<tr><td><code>folds</code></td>
<td>
<p>Explicit list of the values that were omited values in each
fold.</p>
</td></tr> <tr><td><code>lambda.min1</code></td>
<td>
<p>Vector with the standard error values, across
folds, of, per fold unit, Cross-validated log-partial-likelihood for models
with 0 to nt components.</p>
</td></tr> <tr><td><code>lambda.min2</code></td>
<td>
<p>Vector with the standard error
values, across folds, of, per fold unit, van Houwelingen Cross-validated
log-partial-likelihood for models with 0 to nt components.</p>
</td></tr>
<tr><td><code>lambda.min1</code></td>
<td>
<p>Optimal Nbr of components, min Cross-validated
log-partial-likelihood criterion.</p>
</td></tr> <tr><td><code>lambda.se1</code></td>
<td>
<p>Optimal Nbr of
components, min+1se Cross-validated log-partial-likelihood criterion.</p>
</td></tr>
<tr><td><code>lambda.min2</code></td>
<td>
<p>Optimal Nbr of components, min van Houwelingen
Cross-validated log-partial-likelihood.</p>
</td></tr> <tr><td><code>lambda.se2</code></td>
<td>
<p>Optimal Nbr of
components, min+1se van Houwelingen Cross-validated log-partial-likelihood.</p>
</td></tr>
<tr><td><code>lambda.min3</code></td>
<td>
<p>Optimal Nbr of components, max iAUC_CD criterion.</p>
</td></tr>
<tr><td><code>lambda.se3</code></td>
<td>
<p>Optimal Nbr of components, max+1se iAUC_CD criterion.</p>
</td></tr>
<tr><td><code>lambda.min4</code></td>
<td>
<p>Optimal Nbr of components, max iAUC_hc criterion.</p>
</td></tr>
<tr><td><code>lambda.se4</code></td>
<td>
<p>Optimal Nbr of components, max+1se iAUC_hc criterion.</p>
</td></tr>
<tr><td><code>lambda.min5</code></td>
<td>
<p>Optimal Nbr of components, max iAUC_sh criterion.</p>
</td></tr>
<tr><td><code>lambda.se5</code></td>
<td>
<p>Optimal Nbr of components, max+1se iAUC_sh criterion.</p>
</td></tr>
<tr><td><code>lambda.min6</code></td>
<td>
<p>Optimal Nbr of components, max iAUC_Uno criterion.</p>
</td></tr>
<tr><td><code>lambda.se6</code></td>
<td>
<p>Optimal Nbr of components, max+1se iAUC_Uno criterion.</p>
</td></tr>
<tr><td><code>lambda.min7</code></td>
<td>
<p>Optimal Nbr of components, max iAUC_hz.train criterion.</p>
</td></tr>
<tr><td><code>lambda.se7</code></td>
<td>
<p>Optimal Nbr of components, max+1se iAUC_hz.train
criterion.</p>
</td></tr> <tr><td><code>lambda.min8</code></td>
<td>
<p>Optimal Nbr of components, max iAUC_hz.test
criterion.</p>
</td></tr> <tr><td><code>lambda.se8</code></td>
<td>
<p>Optimal Nbr of components, max+1se
iAUC_hz.test criterion.</p>
</td></tr> <tr><td><code>lambda.min9</code></td>
<td>
<p>Optimal Nbr of components, max
iAUC_survivalROC.train criterion.</p>
</td></tr> <tr><td><code>lambda.se9</code></td>
<td>
<p>Optimal Nbr of
components, max+1se iAUC_survivalROC.train criterion.</p>
</td></tr>
<tr><td><code>lambda.min10</code></td>
<td>
<p>Optimal Nbr of components, max iAUC_survivalROC.test
criterion.</p>
</td></tr> <tr><td><code>lambda.se10</code></td>
<td>
<p>Optimal Nbr of components, max+1se
iAUC_survivalROC.test criterion.</p>
</td></tr> <tr><td><code>lambda.min11</code></td>
<td>
<p>Optimal Nbr of
components, min iBrierScore unw criterion.</p>
</td></tr> <tr><td><code>lambda.se11</code></td>
<td>
<p>Optimal Nbr
of components, min+1se iBrierScore unw criterion.</p>
</td></tr>
<tr><td><code>lambda.min12</code></td>
<td>
<p>Optimal Nbr of components, min iSchmidScore unw
criterion.</p>
</td></tr> <tr><td><code>lambda.se12</code></td>
<td>
<p>Optimal Nbr of components, min+1se
iSchmidScore unw criterion.</p>
</td></tr> <tr><td><code>lambda.min13</code></td>
<td>
<p>Optimal Nbr of components,
min iBrierScore w criterion.</p>
</td></tr> <tr><td><code>lambda.se13</code></td>
<td>
<p>Optimal Nbr of components,
min+1se iBrierScore w criterion.</p>
</td></tr> <tr><td><code>lambda.min14</code></td>
<td>
<p>Optimal Nbr of
components, min iSchmidScore w criterion.</p>
</td></tr> <tr><td><code>lambda.se14</code></td>
<td>
<p>Optimal Nbr of
components, min+1se iSchmidScore w criterion.</p>
</td></tr> <tr><td><code>errormat1-14</code></td>
<td>
<p>If
<code>details=TRUE</code>, matrices with the error values for every folds across
each of the components and each of the criteria</p>
</td></tr> <tr><td><code>completed.cv1-14</code></td>
<td>
<p>If
<code>details=TRUE</code>, matrices with logical values for every folds across
each of the components and each of the criteria: <code>TRUE</code> if the
computation was completed and <code>FALSE</code> it is failed.</p>
</td></tr>
<tr><td><code>All_indics</code></td>
<td>
<p>All results of the functions that perform error
computation, for each fold, each component and error criterion.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Frédéric Bertrand<br />
<a href="mailto:frederic.bertrand@utt.fr">frederic.bertrand@utt.fr</a><br />
<a href="http://www-irma.u-strasbg.fr/~fbertran/">http://www-irma.u-strasbg.fr/~fbertran/</a>
</p>


<h3>References</h3>

<p>plsRcox, Cox-Models in a high dimensional setting in R, Frederic
Bertrand, Philippe Bastien, Nicolas Meyer and Myriam Maumy-Bertrand (2014).
Proceedings of User2014!, Los Angeles, page 152.<br />
</p>
<p>Deviance residuals-based sparse PLS and sparse kernel PLS regression for
censored data, Philippe Bastien, Frederic Bertrand, Nicolas Meyer and Myriam
Maumy-Bertrand (2015), Bioinformatics, 31(3):397-404,
doi:10.1093/bioinformatics/btu660.
</p>
<p>Cross validating extensions of kernel, sparse or regular partial least
squares regression models to censored data, Bertrand, F., Bastien, Ph. and
Maumy-Bertrand, M. (2018), <a href="https://arxiv.org/abs/1810.01005">https://arxiv.org/abs/1810.01005</a>.
</p>


<h3>See Also</h3>

<p>See Also <code><a href="#topic+plsRcox">plsRcox</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(micro.censure)
data(Xmicro.censure_compl_imp)
set.seed(123456)
X_train_micro &lt;- apply((as.matrix(Xmicro.censure_compl_imp)),FUN="as.numeric",MARGIN=2)[1:80,]
X_train_micro_df &lt;- data.frame(X_train_micro)
Y_train_micro &lt;- micro.censure$survyear[1:80]
C_train_micro &lt;- micro.censure$DC[1:80]

#Should be run with a higher value of nt (at least 10)
(cv.autoplsRcox.res=cv.autoplsRcox(list(x=X_train_micro,time=Y_train_micro,
status=C_train_micro),nt=3,verbose=FALSE))

</code></pre>

<hr>
<h2 id='cv.coxDKplsDR'>Cross-validating a DKplsDR-Model</h2><span id='topic+cv.coxDKplsDR'></span>

<h3>Description</h3>

<p>This function cross-validates <a href="#topic+coxDKplsDR">coxDKplsDR</a> models.<br />
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cv.coxDKplsDR(
  data,
  method = c("efron", "breslow"),
  nfold = 5,
  nt = 10,
  plot.it = TRUE,
  se = TRUE,
  givefold,
  scaleX = TRUE,
  folddetails = FALSE,
  allCVcrit = FALSE,
  details = FALSE,
  namedataset = "data",
  save = FALSE,
  verbose = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cv.coxDKplsDR_+3A_data">data</code></td>
<td>
<p>A list of three items: </p>
 <ul>
<li><p><code>x</code> the explanatory
variables passed to <code><a href="#topic+coxDKplsDR">coxDKplsDR</a></code>'s <code>Xplan</code> argument,
</p>
</li>
<li><p><code>time</code> passed to <code><a href="#topic+coxDKplsDR">coxDKplsDR</a></code>'s <code>time</code> argument,
</p>
</li>
<li><p><code>status</code> <code><a href="#topic+coxDKplsDR">coxDKplsDR</a></code>'s <code>status</code> argument.  </p>
</li></ul>
</td></tr>
<tr><td><code id="cv.coxDKplsDR_+3A_method">method</code></td>
<td>
<p>A character string specifying the method for tie handling. If
there are no tied death times all the methods are equivalent. The Efron
approximation is used as the default here, it is more accurate when dealing
with tied death times, and is as efficient computationally.</p>
</td></tr>
<tr><td><code id="cv.coxDKplsDR_+3A_nfold">nfold</code></td>
<td>
<p>The number of folds to use to perform the cross-validation
process.</p>
</td></tr>
<tr><td><code id="cv.coxDKplsDR_+3A_nt">nt</code></td>
<td>
<p>The number of components to include in the model. It this is not
supplied, 10 components are fitted.</p>
</td></tr>
<tr><td><code id="cv.coxDKplsDR_+3A_plot.it">plot.it</code></td>
<td>
<p>Shall the results be displayed on a plot ?</p>
</td></tr>
<tr><td><code id="cv.coxDKplsDR_+3A_se">se</code></td>
<td>
<p>Should standard errors be plotted ?</p>
</td></tr>
<tr><td><code id="cv.coxDKplsDR_+3A_givefold">givefold</code></td>
<td>
<p>Explicit list of omited values in each fold can be provided
using this argument.</p>
</td></tr>
<tr><td><code id="cv.coxDKplsDR_+3A_scalex">scaleX</code></td>
<td>
<p>Shall the predictors be standardized ?</p>
</td></tr>
<tr><td><code id="cv.coxDKplsDR_+3A_folddetails">folddetails</code></td>
<td>
<p>Should values and completion status for each folds be
returned ?</p>
</td></tr>
<tr><td><code id="cv.coxDKplsDR_+3A_allcvcrit">allCVcrit</code></td>
<td>
<p>Should the other 13 CV criteria be evaled and returned ?</p>
</td></tr>
<tr><td><code id="cv.coxDKplsDR_+3A_details">details</code></td>
<td>
<p>Should all results of the functions that perform error
computations be returned ?</p>
</td></tr>
<tr><td><code id="cv.coxDKplsDR_+3A_namedataset">namedataset</code></td>
<td>
<p>Name to use to craft temporary results names</p>
</td></tr>
<tr><td><code id="cv.coxDKplsDR_+3A_save">save</code></td>
<td>
<p>Should temporary results be saved ?</p>
</td></tr>
<tr><td><code id="cv.coxDKplsDR_+3A_verbose">verbose</code></td>
<td>
<p>Should some CV details be displayed ?</p>
</td></tr>
<tr><td><code id="cv.coxDKplsDR_+3A_...">...</code></td>
<td>
<p>Other arguments to pass to <code><a href="#topic+coxDKplsDR">coxDKplsDR</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It only computes the recommended iAUCSurvROC criterion. Set
<code>allCVcrit=TRUE</code> to retrieve the 13 other ones.
</p>


<h3>Value</h3>

<table>
<tr><td><code>nt</code></td>
<td>
<p>The number of components requested</p>
</td></tr>
<tr><td><code>cv.error1</code></td>
<td>
<p>Vector with the mean values, across folds, of, per fold
unit, Cross-validated log-partial-likelihood for models with 0 to nt
components.</p>
</td></tr> <tr><td><code>cv.error2</code></td>
<td>
<p>Vector with the mean values, across folds, of,
per fold unit, van Houwelingen Cross-validated log-partial-likelihood for
models with 0 to nt components.</p>
</td></tr> <tr><td><code>cv.error3</code></td>
<td>
<p>Vector with the mean
values, across folds, of iAUC_CD for models with 0 to nt components.</p>
</td></tr>
<tr><td><code>cv.error4</code></td>
<td>
<p>Vector with the mean values, across folds, of iAUC_hc for
models with 0 to nt components.</p>
</td></tr> <tr><td><code>cv.error5</code></td>
<td>
<p>Vector with the mean
values, across folds, of iAUC_sh for models with 0 to nt components.</p>
</td></tr>
<tr><td><code>cv.error6</code></td>
<td>
<p>Vector with the mean values, across folds, of iAUC_Uno for
models with 0 to nt components.</p>
</td></tr> <tr><td><code>cv.error7</code></td>
<td>
<p>Vector with the mean
values, across folds, of iAUC_hz.train for models with 0 to nt components.</p>
</td></tr>
<tr><td><code>cv.error8</code></td>
<td>
<p>Vector with the mean values, across folds, of iAUC_hz.test
for models with 0 to nt components.</p>
</td></tr> <tr><td><code>cv.error9</code></td>
<td>
<p>Vector with the mean
values, across folds, of iAUC_survivalROC.train for models with 0 to nt
components.</p>
</td></tr> <tr><td><code>cv.error10</code></td>
<td>
<p>Vector with the mean values, across folds, of
iAUC_survivalROC.test for models with 0 to nt components.</p>
</td></tr>
<tr><td><code>cv.error11</code></td>
<td>
<p>Vector with the mean values, across folds, of iBrierScore
unw for models with 0 to nt components.</p>
</td></tr> <tr><td><code>cv.error12</code></td>
<td>
<p>Vector with the
mean values, across folds, of iSchmidScore (robust BS) unw for models with 0
to nt components.</p>
</td></tr> <tr><td><code>cv.error13</code></td>
<td>
<p>Vector with the mean values, across
folds, of iBrierScore w for models with 0 to nt components.</p>
</td></tr>
<tr><td><code>cv.error14</code></td>
<td>
<p>Vector with the mean values, across folds, of iSchmidScore
(robust BS) w for models with 0 to nt components.</p>
</td></tr> <tr><td><code>cv.se1</code></td>
<td>
<p>Vector with
the standard error values, across folds, of, per fold unit, Cross-validated
log-partial-likelihood for models with 0 to nt components.</p>
</td></tr>
<tr><td><code>cv.se2</code></td>
<td>
<p>Vector with the standard error values, across folds, of, per
fold unit, van Houwelingen Cross-validated log-partial-likelihood for models
with 0 to nt components.</p>
</td></tr> <tr><td><code>cv.se3</code></td>
<td>
<p>Vector with the standard error
values, across folds, of iAUC_CD for models with 0 to nt components.</p>
</td></tr>
<tr><td><code>cv.se4</code></td>
<td>
<p>Vector with the standard error values, across folds, of
iAUC_hc for models with 0 to nt components.</p>
</td></tr> <tr><td><code>cv.se5</code></td>
<td>
<p>Vector with the
standard error values, across folds, of iAUC_sh for models with 0 to nt
components.</p>
</td></tr> <tr><td><code>cv.se6</code></td>
<td>
<p>Vector with the standard error values, across
folds, of iAUC_Uno for models with 0 to nt components.</p>
</td></tr> <tr><td><code>cv.se7</code></td>
<td>
<p>Vector
with the standard error values, across folds, of iAUC_hz.train for models
with 0 to nt components.</p>
</td></tr> <tr><td><code>cv.se8</code></td>
<td>
<p>Vector with the standard error
values, across folds, of iAUC_hz.test for models with 0 to nt components.</p>
</td></tr>
<tr><td><code>cv.se9</code></td>
<td>
<p>Vector with the standard error values, across folds, of
iAUC_survivalROC.train for models with 0 to nt components.</p>
</td></tr>
<tr><td><code>cv.se10</code></td>
<td>
<p>Vector with the standard error values, across folds, of
iAUC_survivalROC.test for models with 0 to nt components.</p>
</td></tr>
<tr><td><code>cv.se11</code></td>
<td>
<p>Vector with the standard error values, across folds, of
iBrierScore unw for models with 0 to nt components.</p>
</td></tr> <tr><td><code>cv.se12</code></td>
<td>
<p>Vector
with the standard error values, across folds, of iSchmidScore (robust BS)
unw for models with 0 to nt components.</p>
</td></tr> <tr><td><code>cv.se13</code></td>
<td>
<p>Vector with the
standard error values, across folds, of iBrierScore w for models with 0 to
nt components.</p>
</td></tr> <tr><td><code>cv.se14</code></td>
<td>
<p>Vector with the standard error values, across
folds, of iSchmidScore (robust BS) w for models with 0 to nt components.</p>
</td></tr>
<tr><td><code>folds</code></td>
<td>
<p>Explicit list of the values that were omited values in each
fold.</p>
</td></tr> <tr><td><code>lambda.min1</code></td>
<td>
<p>Vector with the standard error values, across
folds, of, per fold unit, Cross-validated log-partial-likelihood for models
with 0 to nt components.</p>
</td></tr> <tr><td><code>lambda.min2</code></td>
<td>
<p>Vector with the standard error
values, across folds, of, per fold unit, van Houwelingen Cross-validated
log-partial-likelihood for models with 0 to nt components.</p>
</td></tr>
<tr><td><code>lambda.min1</code></td>
<td>
<p>Optimal Nbr of components, min Cross-validated
log-partial-likelihood criterion.</p>
</td></tr> <tr><td><code>lambda.se1</code></td>
<td>
<p>Optimal Nbr of
components, min+1se Cross-validated log-partial-likelihood criterion.</p>
</td></tr>
<tr><td><code>lambda.min2</code></td>
<td>
<p>Optimal Nbr of components, min van Houwelingen
Cross-validated log-partial-likelihood.</p>
</td></tr> <tr><td><code>lambda.se2</code></td>
<td>
<p>Optimal Nbr of
components, min+1se van Houwelingen Cross-validated log-partial-likelihood.</p>
</td></tr>
<tr><td><code>lambda.min3</code></td>
<td>
<p>Optimal Nbr of components, max iAUC_CD criterion.</p>
</td></tr>
<tr><td><code>lambda.se3</code></td>
<td>
<p>Optimal Nbr of components, max+1se iAUC_CD criterion.</p>
</td></tr>
<tr><td><code>lambda.min4</code></td>
<td>
<p>Optimal Nbr of components, max iAUC_hc criterion.</p>
</td></tr>
<tr><td><code>lambda.se4</code></td>
<td>
<p>Optimal Nbr of components, max+1se iAUC_hc criterion.</p>
</td></tr>
<tr><td><code>lambda.min5</code></td>
<td>
<p>Optimal Nbr of components, max iAUC_sh criterion.</p>
</td></tr>
<tr><td><code>lambda.se5</code></td>
<td>
<p>Optimal Nbr of components, max+1se iAUC_sh criterion.</p>
</td></tr>
<tr><td><code>lambda.min6</code></td>
<td>
<p>Optimal Nbr of components, max iAUC_Uno criterion.</p>
</td></tr>
<tr><td><code>lambda.se6</code></td>
<td>
<p>Optimal Nbr of components, max+1se iAUC_Uno criterion.</p>
</td></tr>
<tr><td><code>lambda.min7</code></td>
<td>
<p>Optimal Nbr of components, max iAUC_hz.train criterion.</p>
</td></tr>
<tr><td><code>lambda.se7</code></td>
<td>
<p>Optimal Nbr of components, max+1se iAUC_hz.train
criterion.</p>
</td></tr> <tr><td><code>lambda.min8</code></td>
<td>
<p>Optimal Nbr of components, max iAUC_hz.test
criterion.</p>
</td></tr> <tr><td><code>lambda.se8</code></td>
<td>
<p>Optimal Nbr of components, max+1se
iAUC_hz.test criterion.</p>
</td></tr> <tr><td><code>lambda.min9</code></td>
<td>
<p>Optimal Nbr of components, max
iAUC_survivalROC.train criterion.</p>
</td></tr> <tr><td><code>lambda.se9</code></td>
<td>
<p>Optimal Nbr of
components, max+1se iAUC_survivalROC.train criterion.</p>
</td></tr>
<tr><td><code>lambda.min10</code></td>
<td>
<p>Optimal Nbr of components, max iAUC_survivalROC.test
criterion.</p>
</td></tr> <tr><td><code>lambda.se10</code></td>
<td>
<p>Optimal Nbr of components, max+1se
iAUC_survivalROC.test criterion.</p>
</td></tr> <tr><td><code>lambda.min11</code></td>
<td>
<p>Optimal Nbr of
components, min iBrierScore unw criterion.</p>
</td></tr> <tr><td><code>lambda.se11</code></td>
<td>
<p>Optimal Nbr
of components, min+1se iBrierScore unw criterion.</p>
</td></tr>
<tr><td><code>lambda.min12</code></td>
<td>
<p>Optimal Nbr of components, min iSchmidScore unw
criterion.</p>
</td></tr> <tr><td><code>lambda.se12</code></td>
<td>
<p>Optimal Nbr of components, min+1se
iSchmidScore unw criterion.</p>
</td></tr> <tr><td><code>lambda.min13</code></td>
<td>
<p>Optimal Nbr of components,
min iBrierScore w criterion.</p>
</td></tr> <tr><td><code>lambda.se13</code></td>
<td>
<p>Optimal Nbr of components,
min+1se iBrierScore w criterion.</p>
</td></tr> <tr><td><code>lambda.min14</code></td>
<td>
<p>Optimal Nbr of
components, min iSchmidScore w criterion.</p>
</td></tr> <tr><td><code>lambda.se14</code></td>
<td>
<p>Optimal Nbr of
components, min+1se iSchmidScore w criterion.</p>
</td></tr> <tr><td><code>errormat1-14</code></td>
<td>
<p>If
<code>details=TRUE</code>, matrices with the error values for every folds across
each of the components and each of the criteria</p>
</td></tr> <tr><td><code>completed.cv1-14</code></td>
<td>
<p>If
<code>details=TRUE</code>, matrices with logical values for every folds across
each of the components and each of the criteria: <code>TRUE</code> if the
computation was completed and <code>FALSE</code> it is failed.</p>
</td></tr>
<tr><td><code>All_indics</code></td>
<td>
<p>All results of the functions that perform error
computation, for each fold, each component and error criterion.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Frédéric Bertrand<br />
<a href="mailto:frederic.bertrand@utt.fr">frederic.bertrand@utt.fr</a><br />
<a href="http://www-irma.u-strasbg.fr/~fbertran/">http://www-irma.u-strasbg.fr/~fbertran/</a>
</p>


<h3>References</h3>

<p>plsRcox, Cox-Models in a high dimensional setting in R, Frederic
Bertrand, Philippe Bastien, Nicolas Meyer and Myriam Maumy-Bertrand (2014).
Proceedings of User2014!, Los Angeles, page 152.<br />
</p>
<p>Deviance residuals-based sparse PLS and sparse kernel PLS regression for
censored data, Philippe Bastien, Frederic Bertrand, Nicolas Meyer and Myriam
Maumy-Bertrand (2015), Bioinformatics, 31(3):397-404,
doi:10.1093/bioinformatics/btu660.
</p>
<p>Cross validating extensions of kernel, sparse or regular partial least
squares regression models to censored data, Bertrand, F., Bastien, Ph. and
Maumy-Bertrand, M. (2018), <a href="https://arxiv.org/abs/1810.01005">https://arxiv.org/abs/1810.01005</a>.
</p>


<h3>See Also</h3>

<p>See Also <code><a href="#topic+coxDKplsDR">coxDKplsDR</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(micro.censure)
data(Xmicro.censure_compl_imp)
set.seed(123456)
X_train_micro &lt;- apply((as.matrix(Xmicro.censure_compl_imp)),FUN="as.numeric",MARGIN=2)[1:80,]
X_train_micro_df &lt;- data.frame(X_train_micro)
Y_train_micro &lt;- micro.censure$survyear[1:80]
C_train_micro &lt;- micro.censure$DC[1:80]

#Should be run with a higher value of nt (at least 10)
(cv.coxDKplsDR.res=cv.coxDKplsDR(list(x=X_train_micro,time=Y_train_micro,
status=C_train_micro),nt=3))

</code></pre>

<hr>
<h2 id='cv.coxDKsplsDR'>Cross-validating a DKsplsDR-Model</h2><span id='topic+cv.coxDKsplsDR'></span>

<h3>Description</h3>

<p>This function cross-validates <a href="#topic+coxDKsplsDR">coxDKsplsDR</a> models.<br />
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cv.coxDKsplsDR(
  data,
  method = c("efron", "breslow"),
  nfold = 5,
  nt = 10,
  eta = 0.5,
  plot.it = TRUE,
  se = TRUE,
  givefold,
  scaleX = TRUE,
  scaleY = FALSE,
  folddetails = FALSE,
  allCVcrit = FALSE,
  details = FALSE,
  namedataset = "data",
  save = FALSE,
  verbose = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cv.coxDKsplsDR_+3A_data">data</code></td>
<td>
<p>A list of three items: </p>
 <ul>
<li><p><code>x</code> the explanatory
variables passed to <code><a href="#topic+coxDKsplsDR">coxDKsplsDR</a></code>'s <code>Xplan</code> argument,
</p>
</li>
<li><p><code>time</code> passed to <code><a href="#topic+coxDKsplsDR">coxDKsplsDR</a></code>'s <code>time</code> argument,
</p>
</li>
<li><p><code>status</code> <code><a href="#topic+coxDKsplsDR">coxDKsplsDR</a></code>'s <code>status</code> argument.  </p>
</li></ul>
</td></tr>
<tr><td><code id="cv.coxDKsplsDR_+3A_method">method</code></td>
<td>
<p>A character string specifying the method for tie handling. If
there are no tied death times all the methods are equivalent. The Efron
approximation is used as the default here, it is more accurate when dealing
with tied death times, and is as efficient computationally.</p>
</td></tr>
<tr><td><code id="cv.coxDKsplsDR_+3A_nfold">nfold</code></td>
<td>
<p>The number of folds to use to perform the cross-validation
process.</p>
</td></tr>
<tr><td><code id="cv.coxDKsplsDR_+3A_nt">nt</code></td>
<td>
<p>The number of components to include in the model. It this is not
supplied, 10 components are fitted.</p>
</td></tr>
<tr><td><code id="cv.coxDKsplsDR_+3A_eta">eta</code></td>
<td>
<p>Thresholding parameter. <code>eta</code> should be between 0 and 1.</p>
</td></tr>
<tr><td><code id="cv.coxDKsplsDR_+3A_plot.it">plot.it</code></td>
<td>
<p>Shall the results be displayed on a plot ?</p>
</td></tr>
<tr><td><code id="cv.coxDKsplsDR_+3A_se">se</code></td>
<td>
<p>Should standard errors be plotted ?</p>
</td></tr>
<tr><td><code id="cv.coxDKsplsDR_+3A_givefold">givefold</code></td>
<td>
<p>Explicit list of omited values in each fold can be provided
using this argument.</p>
</td></tr>
<tr><td><code id="cv.coxDKsplsDR_+3A_scalex">scaleX</code></td>
<td>
<p>Shall the predictors be standardized ?</p>
</td></tr>
<tr><td><code id="cv.coxDKsplsDR_+3A_scaley">scaleY</code></td>
<td>
<p>Should the <code>time</code> values be standardized ?</p>
</td></tr>
<tr><td><code id="cv.coxDKsplsDR_+3A_folddetails">folddetails</code></td>
<td>
<p>Should values and completion status for each folds be
returned ?</p>
</td></tr>
<tr><td><code id="cv.coxDKsplsDR_+3A_allcvcrit">allCVcrit</code></td>
<td>
<p>Should the other 13 CV criteria be evaled and returned ?</p>
</td></tr>
<tr><td><code id="cv.coxDKsplsDR_+3A_details">details</code></td>
<td>
<p>Should all results of the functions that perform error
computations be returned ?</p>
</td></tr>
<tr><td><code id="cv.coxDKsplsDR_+3A_namedataset">namedataset</code></td>
<td>
<p>Name to use to craft temporary results names</p>
</td></tr>
<tr><td><code id="cv.coxDKsplsDR_+3A_save">save</code></td>
<td>
<p>Should temporary results be saved ?</p>
</td></tr>
<tr><td><code id="cv.coxDKsplsDR_+3A_verbose">verbose</code></td>
<td>
<p>Should some CV details be displayed ?</p>
</td></tr>
<tr><td><code id="cv.coxDKsplsDR_+3A_...">...</code></td>
<td>
<p>Other arguments to pass to <code><a href="#topic+coxDKsplsDR">coxDKsplsDR</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It only computes the recommended iAUCSurvROC criterion. Set
<code>allCVcrit=TRUE</code> to retrieve the 13 other ones.
</p>


<h3>Value</h3>

<table>
<tr><td><code>nt</code></td>
<td>
<p>The number of components requested</p>
</td></tr>
<tr><td><code>cv.error1</code></td>
<td>
<p>Vector with the mean values, across folds, of, per fold
unit, Cross-validated log-partial-likelihood for models with 0 to nt
components.</p>
</td></tr> <tr><td><code>cv.error2</code></td>
<td>
<p>Vector with the mean values, across folds, of,
per fold unit, van Houwelingen Cross-validated log-partial-likelihood for
models with 0 to nt components.</p>
</td></tr> <tr><td><code>cv.error3</code></td>
<td>
<p>Vector with the mean
values, across folds, of iAUC_CD for models with 0 to nt components.</p>
</td></tr>
<tr><td><code>cv.error4</code></td>
<td>
<p>Vector with the mean values, across folds, of iAUC_hc for
models with 0 to nt components.</p>
</td></tr> <tr><td><code>cv.error5</code></td>
<td>
<p>Vector with the mean
values, across folds, of iAUC_sh for models with 0 to nt components.</p>
</td></tr>
<tr><td><code>cv.error6</code></td>
<td>
<p>Vector with the mean values, across folds, of iAUC_Uno for
models with 0 to nt components.</p>
</td></tr> <tr><td><code>cv.error7</code></td>
<td>
<p>Vector with the mean
values, across folds, of iAUC_hz.train for models with 0 to nt components.</p>
</td></tr>
<tr><td><code>cv.error8</code></td>
<td>
<p>Vector with the mean values, across folds, of iAUC_hz.test
for models with 0 to nt components.</p>
</td></tr> <tr><td><code>cv.error9</code></td>
<td>
<p>Vector with the mean
values, across folds, of iAUC_survivalROC.train for models with 0 to nt
components.</p>
</td></tr> <tr><td><code>cv.error10</code></td>
<td>
<p>Vector with the mean values, across folds, of
iAUC_survivalROC.test for models with 0 to nt components.</p>
</td></tr>
<tr><td><code>cv.error11</code></td>
<td>
<p>Vector with the mean values, across folds, of iBrierScore
unw for models with 0 to nt components.</p>
</td></tr> <tr><td><code>cv.error12</code></td>
<td>
<p>Vector with the
mean values, across folds, of iSchmidScore (robust BS) unw for models with 0
to nt components.</p>
</td></tr> <tr><td><code>cv.error13</code></td>
<td>
<p>Vector with the mean values, across
folds, of iBrierScore w for models with 0 to nt components.</p>
</td></tr>
<tr><td><code>cv.error14</code></td>
<td>
<p>Vector with the mean values, across folds, of iSchmidScore
(robust BS) w for models with 0 to nt components.</p>
</td></tr> <tr><td><code>cv.se1</code></td>
<td>
<p>Vector with
the standard error values, across folds, of, per fold unit, Cross-validated
log-partial-likelihood for models with 0 to nt components.</p>
</td></tr>
<tr><td><code>cv.se2</code></td>
<td>
<p>Vector with the standard error values, across folds, of, per
fold unit, van Houwelingen Cross-validated log-partial-likelihood for models
with 0 to nt components.</p>
</td></tr> <tr><td><code>cv.se3</code></td>
<td>
<p>Vector with the standard error
values, across folds, of iAUC_CD for models with 0 to nt components.</p>
</td></tr>
<tr><td><code>cv.se4</code></td>
<td>
<p>Vector with the standard error values, across folds, of
iAUC_hc for models with 0 to nt components.</p>
</td></tr> <tr><td><code>cv.se5</code></td>
<td>
<p>Vector with the
standard error values, across folds, of iAUC_sh for models with 0 to nt
components.</p>
</td></tr> <tr><td><code>cv.se6</code></td>
<td>
<p>Vector with the standard error values, across
folds, of iAUC_Uno for models with 0 to nt components.</p>
</td></tr> <tr><td><code>cv.se7</code></td>
<td>
<p>Vector
with the standard error values, across folds, of iAUC_hz.train for models
with 0 to nt components.</p>
</td></tr> <tr><td><code>cv.se8</code></td>
<td>
<p>Vector with the standard error
values, across folds, of iAUC_hz.test for models with 0 to nt components.</p>
</td></tr>
<tr><td><code>cv.se9</code></td>
<td>
<p>Vector with the standard error values, across folds, of
iAUC_survivalROC.train for models with 0 to nt components.</p>
</td></tr>
<tr><td><code>cv.se10</code></td>
<td>
<p>Vector with the standard error values, across folds, of
iAUC_survivalROC.test for models with 0 to nt components.</p>
</td></tr>
<tr><td><code>cv.se11</code></td>
<td>
<p>Vector with the standard error values, across folds, of
iBrierScore unw for models with 0 to nt components.</p>
</td></tr> <tr><td><code>cv.se12</code></td>
<td>
<p>Vector
with the standard error values, across folds, of iSchmidScore (robust BS)
unw for models with 0 to nt components.</p>
</td></tr> <tr><td><code>cv.se13</code></td>
<td>
<p>Vector with the
standard error values, across folds, of iBrierScore w for models with 0 to
nt components.</p>
</td></tr> <tr><td><code>cv.se14</code></td>
<td>
<p>Vector with the standard error values, across
folds, of iSchmidScore (robust BS) w for models with 0 to nt components.</p>
</td></tr>
<tr><td><code>folds</code></td>
<td>
<p>Explicit list of the values that were omited values in each
fold.</p>
</td></tr> <tr><td><code>lambda.min1</code></td>
<td>
<p>Vector with the standard error values, across
folds, of, per fold unit, Cross-validated log-partial-likelihood for models
with 0 to nt components.</p>
</td></tr> <tr><td><code>lambda.min2</code></td>
<td>
<p>Vector with the standard error
values, across folds, of, per fold unit, van Houwelingen Cross-validated
log-partial-likelihood for models with 0 to nt components.</p>
</td></tr>
<tr><td><code>lambda.min1</code></td>
<td>
<p>Optimal Nbr of components, min Cross-validated
log-partial-likelihood criterion.</p>
</td></tr> <tr><td><code>lambda.se1</code></td>
<td>
<p>Optimal Nbr of
components, min+1se Cross-validated log-partial-likelihood criterion.</p>
</td></tr>
<tr><td><code>lambda.min2</code></td>
<td>
<p>Optimal Nbr of components, min van Houwelingen
Cross-validated log-partial-likelihood.</p>
</td></tr> <tr><td><code>lambda.se2</code></td>
<td>
<p>Optimal Nbr of
components, min+1se van Houwelingen Cross-validated log-partial-likelihood.</p>
</td></tr>
<tr><td><code>lambda.min3</code></td>
<td>
<p>Optimal Nbr of components, max iAUC_CD criterion.</p>
</td></tr>
<tr><td><code>lambda.se3</code></td>
<td>
<p>Optimal Nbr of components, max+1se iAUC_CD criterion.</p>
</td></tr>
<tr><td><code>lambda.min4</code></td>
<td>
<p>Optimal Nbr of components, max iAUC_hc criterion.</p>
</td></tr>
<tr><td><code>lambda.se4</code></td>
<td>
<p>Optimal Nbr of components, max+1se iAUC_hc criterion.</p>
</td></tr>
<tr><td><code>lambda.min5</code></td>
<td>
<p>Optimal Nbr of components, max iAUC_sh criterion.</p>
</td></tr>
<tr><td><code>lambda.se5</code></td>
<td>
<p>Optimal Nbr of components, max+1se iAUC_sh criterion.</p>
</td></tr>
<tr><td><code>lambda.min6</code></td>
<td>
<p>Optimal Nbr of components, max iAUC_Uno criterion.</p>
</td></tr>
<tr><td><code>lambda.se6</code></td>
<td>
<p>Optimal Nbr of components, max+1se iAUC_Uno criterion.</p>
</td></tr>
<tr><td><code>lambda.min7</code></td>
<td>
<p>Optimal Nbr of components, max iAUC_hz.train criterion.</p>
</td></tr>
<tr><td><code>lambda.se7</code></td>
<td>
<p>Optimal Nbr of components, max+1se iAUC_hz.train
criterion.</p>
</td></tr> <tr><td><code>lambda.min8</code></td>
<td>
<p>Optimal Nbr of components, max iAUC_hz.test
criterion.</p>
</td></tr> <tr><td><code>lambda.se8</code></td>
<td>
<p>Optimal Nbr of components, max+1se
iAUC_hz.test criterion.</p>
</td></tr> <tr><td><code>lambda.min9</code></td>
<td>
<p>Optimal Nbr of components, max
iAUC_survivalROC.train criterion.</p>
</td></tr> <tr><td><code>lambda.se9</code></td>
<td>
<p>Optimal Nbr of
components, max+1se iAUC_survivalROC.train criterion.</p>
</td></tr>
<tr><td><code>lambda.min10</code></td>
<td>
<p>Optimal Nbr of components, max iAUC_survivalROC.test
criterion.</p>
</td></tr> <tr><td><code>lambda.se10</code></td>
<td>
<p>Optimal Nbr of components, max+1se
iAUC_survivalROC.test criterion.</p>
</td></tr> <tr><td><code>lambda.min11</code></td>
<td>
<p>Optimal Nbr of
components, min iBrierScore unw criterion.</p>
</td></tr> <tr><td><code>lambda.se11</code></td>
<td>
<p>Optimal Nbr
of components, min+1se iBrierScore unw criterion.</p>
</td></tr>
<tr><td><code>lambda.min12</code></td>
<td>
<p>Optimal Nbr of components, min iSchmidScore unw
criterion.</p>
</td></tr> <tr><td><code>lambda.se12</code></td>
<td>
<p>Optimal Nbr of components, min+1se
iSchmidScore unw criterion.</p>
</td></tr> <tr><td><code>lambda.min13</code></td>
<td>
<p>Optimal Nbr of components,
min iBrierScore w criterion.</p>
</td></tr> <tr><td><code>lambda.se13</code></td>
<td>
<p>Optimal Nbr of components,
min+1se iBrierScore w criterion.</p>
</td></tr> <tr><td><code>lambda.min14</code></td>
<td>
<p>Optimal Nbr of
components, min iSchmidScore w criterion.</p>
</td></tr> <tr><td><code>lambda.se14</code></td>
<td>
<p>Optimal Nbr of
components, min+1se iSchmidScore w criterion.</p>
</td></tr> <tr><td><code>errormat1-14</code></td>
<td>
<p>If
<code>details=TRUE</code>, matrices with the error values for every folds across
each of the components and each of the criteria</p>
</td></tr> <tr><td><code>completed.cv1-14</code></td>
<td>
<p>If
<code>details=TRUE</code>, matrices with logical values for every folds across
each of the components and each of the criteria: <code>TRUE</code> if the
computation was completed and <code>FALSE</code> it is failed.</p>
</td></tr>
<tr><td><code>All_indics</code></td>
<td>
<p>All results of the functions that perform error
computation, for each fold, each component and error criterion.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Frédéric Bertrand<br />
<a href="mailto:frederic.bertrand@utt.fr">frederic.bertrand@utt.fr</a><br />
<a href="http://www-irma.u-strasbg.fr/~fbertran/">http://www-irma.u-strasbg.fr/~fbertran/</a>
</p>


<h3>References</h3>

<p>plsRcox, Cox-Models in a high dimensional setting in R, Frederic
Bertrand, Philippe Bastien, Nicolas Meyer and Myriam Maumy-Bertrand (2014).
Proceedings of User2014!, Los Angeles, page 152.<br />
</p>
<p>Deviance residuals-based sparse PLS and sparse kernel PLS regression for
censored data, Philippe Bastien, Frederic Bertrand, Nicolas Meyer and Myriam
Maumy-Bertrand (2015), Bioinformatics, 31(3):397-404,
doi:10.1093/bioinformatics/btu660.
</p>
<p>Cross validating extensions of kernel, sparse or regular partial least
squares regression models to censored data, Bertrand, F., Bastien, Ph. and
Maumy-Bertrand, M. (2018), <a href="https://arxiv.org/abs/1810.01005">https://arxiv.org/abs/1810.01005</a>.
</p>


<h3>See Also</h3>

<p>See Also <code><a href="#topic+coxDKsplsDR">coxDKsplsDR</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(micro.censure)
data(Xmicro.censure_compl_imp)
set.seed(123456)
X_train_micro &lt;- apply((as.matrix(Xmicro.censure_compl_imp)),FUN="as.numeric",MARGIN=2)[1:80,]
X_train_micro_df &lt;- data.frame(X_train_micro)
Y_train_micro &lt;- micro.censure$survyear[1:80]
C_train_micro &lt;- micro.censure$DC[1:80]

#Should be run with a higher value of nt (at least 10) and a grid of eta
(cv.coxDKsplsDR.res=cv.coxDKsplsDR(list(x=X_train_micro,time=Y_train_micro,
status=C_train_micro),nt=3,eta=.1))

</code></pre>

<hr>
<h2 id='cv.coxpls'>Cross-validating a Cox-Model fitted on PLSR components</h2><span id='topic+cv.coxpls'></span>

<h3>Description</h3>

<p>This function cross-validates <a href="#topic+coxpls">coxpls</a> models.<br />
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cv.coxpls(
  data,
  method = c("efron", "breslow"),
  nfold = 5,
  nt = 10,
  plot.it = TRUE,
  se = TRUE,
  givefold,
  scaleX = TRUE,
  folddetails = FALSE,
  allCVcrit = FALSE,
  details = FALSE,
  namedataset = "data",
  save = FALSE,
  verbose = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cv.coxpls_+3A_data">data</code></td>
<td>
<p>A list of three items: </p>
 <ul>
<li><p><code>x</code> the explanatory
variables passed to <code><a href="#topic+coxpls">coxpls</a></code>'s <code>Xplan</code> argument,
</p>
</li>
<li><p><code>time</code> passed to <code><a href="#topic+coxpls">coxpls</a></code>'s <code>time</code> argument,
</p>
</li>
<li><p><code>status</code> <code><a href="#topic+coxpls">coxpls</a></code>'s <code>status</code> argument.  </p>
</li></ul>
</td></tr>
<tr><td><code id="cv.coxpls_+3A_method">method</code></td>
<td>
<p>A character string specifying the method for tie handling. If
there are no tied death times all the methods are equivalent. The Efron
approximation is used as the default here, it is more accurate when dealing
with tied death times, and is as efficient computationally.</p>
</td></tr>
<tr><td><code id="cv.coxpls_+3A_nfold">nfold</code></td>
<td>
<p>The number of folds to use to perform the cross-validation
process.</p>
</td></tr>
<tr><td><code id="cv.coxpls_+3A_nt">nt</code></td>
<td>
<p>The number of components to include in the model. It this is not
supplied, 10 components are fitted.</p>
</td></tr>
<tr><td><code id="cv.coxpls_+3A_plot.it">plot.it</code></td>
<td>
<p>Shall the results be displayed on a plot ?</p>
</td></tr>
<tr><td><code id="cv.coxpls_+3A_se">se</code></td>
<td>
<p>Should standard errors be plotted ?</p>
</td></tr>
<tr><td><code id="cv.coxpls_+3A_givefold">givefold</code></td>
<td>
<p>Explicit list of omited values in each fold can be provided
using this argument.</p>
</td></tr>
<tr><td><code id="cv.coxpls_+3A_scalex">scaleX</code></td>
<td>
<p>Shall the predictors be standardized ?</p>
</td></tr>
<tr><td><code id="cv.coxpls_+3A_folddetails">folddetails</code></td>
<td>
<p>Should values and completion status for each folds be
returned ?</p>
</td></tr>
<tr><td><code id="cv.coxpls_+3A_allcvcrit">allCVcrit</code></td>
<td>
<p>Should the other 13 CV criteria be evaled and returned ?</p>
</td></tr>
<tr><td><code id="cv.coxpls_+3A_details">details</code></td>
<td>
<p>Should all results of the functions that perform error
computations be returned ?</p>
</td></tr>
<tr><td><code id="cv.coxpls_+3A_namedataset">namedataset</code></td>
<td>
<p>Name to use to craft temporary results names</p>
</td></tr>
<tr><td><code id="cv.coxpls_+3A_save">save</code></td>
<td>
<p>Should temporary results be saved ?</p>
</td></tr>
<tr><td><code id="cv.coxpls_+3A_verbose">verbose</code></td>
<td>
<p>Should some CV details be displayed ?</p>
</td></tr>
<tr><td><code id="cv.coxpls_+3A_...">...</code></td>
<td>
<p>Other arguments to pass to <code><a href="#topic+coxpls">coxpls</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It only computes the recommended iAUCSurvROC criterion. Set
<code>allCVcrit=TRUE</code> to retrieve the 13 other ones.
</p>


<h3>Value</h3>

<table>
<tr><td><code>nt</code></td>
<td>
<p>The number of components requested</p>
</td></tr>
<tr><td><code>cv.error1</code></td>
<td>
<p>Vector with the mean values, across folds, of, per fold
unit, Cross-validated log-partial-likelihood for models with 0 to nt
components.</p>
</td></tr> <tr><td><code>cv.error2</code></td>
<td>
<p>Vector with the mean values, across folds, of,
per fold unit, van Houwelingen Cross-validated log-partial-likelihood for
models with 0 to nt components.</p>
</td></tr> <tr><td><code>cv.error3</code></td>
<td>
<p>Vector with the mean
values, across folds, of iAUC_CD for models with 0 to nt components.</p>
</td></tr>
<tr><td><code>cv.error4</code></td>
<td>
<p>Vector with the mean values, across folds, of iAUC_hc for
models with 0 to nt components.</p>
</td></tr> <tr><td><code>cv.error5</code></td>
<td>
<p>Vector with the mean
values, across folds, of iAUC_sh for models with 0 to nt components.</p>
</td></tr>
<tr><td><code>cv.error6</code></td>
<td>
<p>Vector with the mean values, across folds, of iAUC_Uno for
models with 0 to nt components.</p>
</td></tr> <tr><td><code>cv.error7</code></td>
<td>
<p>Vector with the mean
values, across folds, of iAUC_hz.train for models with 0 to nt components.</p>
</td></tr>
<tr><td><code>cv.error8</code></td>
<td>
<p>Vector with the mean values, across folds, of iAUC_hz.test
for models with 0 to nt components.</p>
</td></tr> <tr><td><code>cv.error9</code></td>
<td>
<p>Vector with the mean
values, across folds, of iAUC_survivalROC.train for models with 0 to nt
components.</p>
</td></tr> <tr><td><code>cv.error10</code></td>
<td>
<p>Vector with the mean values, across folds, of
iAUC_survivalROC.test for models with 0 to nt components.</p>
</td></tr>
<tr><td><code>cv.error11</code></td>
<td>
<p>Vector with the mean values, across folds, of iBrierScore
unw for models with 0 to nt components.</p>
</td></tr> <tr><td><code>cv.error12</code></td>
<td>
<p>Vector with the
mean values, across folds, of iSchmidScore (robust BS) unw for models with 0
to nt components.</p>
</td></tr> <tr><td><code>cv.error13</code></td>
<td>
<p>Vector with the mean values, across
folds, of iBrierScore w for models with 0 to nt components.</p>
</td></tr>
<tr><td><code>cv.error14</code></td>
<td>
<p>Vector with the mean values, across folds, of iSchmidScore
(robust BS) w for models with 0 to nt components.</p>
</td></tr> <tr><td><code>cv.se1</code></td>
<td>
<p>Vector with
the standard error values, across folds, of, per fold unit, Cross-validated
log-partial-likelihood for models with 0 to nt components.</p>
</td></tr>
<tr><td><code>cv.se2</code></td>
<td>
<p>Vector with the standard error values, across folds, of, per
fold unit, van Houwelingen Cross-validated log-partial-likelihood for models
with 0 to nt components.</p>
</td></tr> <tr><td><code>cv.se3</code></td>
<td>
<p>Vector with the standard error
values, across folds, of iAUC_CD for models with 0 to nt components.</p>
</td></tr>
<tr><td><code>cv.se4</code></td>
<td>
<p>Vector with the standard error values, across folds, of
iAUC_hc for models with 0 to nt components.</p>
</td></tr> <tr><td><code>cv.se5</code></td>
<td>
<p>Vector with the
standard error values, across folds, of iAUC_sh for models with 0 to nt
components.</p>
</td></tr> <tr><td><code>cv.se6</code></td>
<td>
<p>Vector with the standard error values, across
folds, of iAUC_Uno for models with 0 to nt components.</p>
</td></tr> <tr><td><code>cv.se7</code></td>
<td>
<p>Vector
with the standard error values, across folds, of iAUC_hz.train for models
with 0 to nt components.</p>
</td></tr> <tr><td><code>cv.se8</code></td>
<td>
<p>Vector with the standard error
values, across folds, of iAUC_hz.test for models with 0 to nt components.</p>
</td></tr>
<tr><td><code>cv.se9</code></td>
<td>
<p>Vector with the standard error values, across folds, of
iAUC_survivalROC.train for models with 0 to nt components.</p>
</td></tr>
<tr><td><code>cv.se10</code></td>
<td>
<p>Vector with the standard error values, across folds, of
iAUC_survivalROC.test for models with 0 to nt components.</p>
</td></tr>
<tr><td><code>cv.se11</code></td>
<td>
<p>Vector with the standard error values, across folds, of
iBrierScore unw for models with 0 to nt components.</p>
</td></tr> <tr><td><code>cv.se12</code></td>
<td>
<p>Vector
with the standard error values, across folds, of iSchmidScore (robust BS)
unw for models with 0 to nt components.</p>
</td></tr> <tr><td><code>cv.se13</code></td>
<td>
<p>Vector with the
standard error values, across folds, of iBrierScore w for models with 0 to
nt components.</p>
</td></tr> <tr><td><code>cv.se14</code></td>
<td>
<p>Vector with the standard error values, across
folds, of iSchmidScore (robust BS) w for models with 0 to nt components.</p>
</td></tr>
<tr><td><code>folds</code></td>
<td>
<p>Explicit list of the values that were omited values in each
fold.</p>
</td></tr> <tr><td><code>lambda.min1</code></td>
<td>
<p>Vector with the standard error values, across
folds, of, per fold unit, Cross-validated log-partial-likelihood for models
with 0 to nt components.</p>
</td></tr> <tr><td><code>lambda.min2</code></td>
<td>
<p>Vector with the standard error
values, across folds, of, per fold unit, van Houwelingen Cross-validated
log-partial-likelihood for models with 0 to nt components.</p>
</td></tr>
<tr><td><code>lambda.min1</code></td>
<td>
<p>Optimal Nbr of components, min Cross-validated
log-partial-likelihood criterion.</p>
</td></tr> <tr><td><code>lambda.se1</code></td>
<td>
<p>Optimal Nbr of
components, min+1se Cross-validated log-partial-likelihood criterion.</p>
</td></tr>
<tr><td><code>lambda.min2</code></td>
<td>
<p>Optimal Nbr of components, min van Houwelingen
Cross-validated log-partial-likelihood.</p>
</td></tr> <tr><td><code>lambda.se2</code></td>
<td>
<p>Optimal Nbr of
components, min+1se van Houwelingen Cross-validated log-partial-likelihood.</p>
</td></tr>
<tr><td><code>lambda.min3</code></td>
<td>
<p>Optimal Nbr of components, max iAUC_CD criterion.</p>
</td></tr>
<tr><td><code>lambda.se3</code></td>
<td>
<p>Optimal Nbr of components, max+1se iAUC_CD criterion.</p>
</td></tr>
<tr><td><code>lambda.min4</code></td>
<td>
<p>Optimal Nbr of components, max iAUC_hc criterion.</p>
</td></tr>
<tr><td><code>lambda.se4</code></td>
<td>
<p>Optimal Nbr of components, max+1se iAUC_hc criterion.</p>
</td></tr>
<tr><td><code>lambda.min5</code></td>
<td>
<p>Optimal Nbr of components, max iAUC_sh criterion.</p>
</td></tr>
<tr><td><code>lambda.se5</code></td>
<td>
<p>Optimal Nbr of components, max+1se iAUC_sh criterion.</p>
</td></tr>
<tr><td><code>lambda.min6</code></td>
<td>
<p>Optimal Nbr of components, max iAUC_Uno criterion.</p>
</td></tr>
<tr><td><code>lambda.se6</code></td>
<td>
<p>Optimal Nbr of components, max+1se iAUC_Uno criterion.</p>
</td></tr>
<tr><td><code>lambda.min7</code></td>
<td>
<p>Optimal Nbr of components, max iAUC_hz.train criterion.</p>
</td></tr>
<tr><td><code>lambda.se7</code></td>
<td>
<p>Optimal Nbr of components, max+1se iAUC_hz.train
criterion.</p>
</td></tr> <tr><td><code>lambda.min8</code></td>
<td>
<p>Optimal Nbr of components, max iAUC_hz.test
criterion.</p>
</td></tr> <tr><td><code>lambda.se8</code></td>
<td>
<p>Optimal Nbr of components, max+1se
iAUC_hz.test criterion.</p>
</td></tr> <tr><td><code>lambda.min9</code></td>
<td>
<p>Optimal Nbr of components, max
iAUC_survivalROC.train criterion.</p>
</td></tr> <tr><td><code>lambda.se9</code></td>
<td>
<p>Optimal Nbr of
components, max+1se iAUC_survivalROC.train criterion.</p>
</td></tr>
<tr><td><code>lambda.min10</code></td>
<td>
<p>Optimal Nbr of components, max iAUC_survivalROC.test
criterion.</p>
</td></tr> <tr><td><code>lambda.se10</code></td>
<td>
<p>Optimal Nbr of components, max+1se
iAUC_survivalROC.test criterion.</p>
</td></tr> <tr><td><code>lambda.min11</code></td>
<td>
<p>Optimal Nbr of
components, min iBrierScore unw criterion.</p>
</td></tr> <tr><td><code>lambda.se11</code></td>
<td>
<p>Optimal Nbr
of components, min+1se iBrierScore unw criterion.</p>
</td></tr>
<tr><td><code>lambda.min12</code></td>
<td>
<p>Optimal Nbr of components, min iSchmidScore unw
criterion.</p>
</td></tr> <tr><td><code>lambda.se12</code></td>
<td>
<p>Optimal Nbr of components, min+1se
iSchmidScore unw criterion.</p>
</td></tr> <tr><td><code>lambda.min13</code></td>
<td>
<p>Optimal Nbr of components,
min iBrierScore w criterion.</p>
</td></tr> <tr><td><code>lambda.se13</code></td>
<td>
<p>Optimal Nbr of components,
min+1se iBrierScore w criterion.</p>
</td></tr> <tr><td><code>lambda.min14</code></td>
<td>
<p>Optimal Nbr of
components, min iSchmidScore w criterion.</p>
</td></tr> <tr><td><code>lambda.se14</code></td>
<td>
<p>Optimal Nbr of
components, min+1se iSchmidScore w criterion.</p>
</td></tr> <tr><td><code>errormat1-14</code></td>
<td>
<p>If
<code>details=TRUE</code>, matrices with the error values for every folds across
each of the components and each of the criteria</p>
</td></tr> <tr><td><code>completed.cv1-14</code></td>
<td>
<p>If
<code>details=TRUE</code>, matrices with logical values for every folds across
each of the components and each of the criteria: <code>TRUE</code> if the
computation was completed and <code>FALSE</code> it is failed.</p>
</td></tr>
<tr><td><code>All_indics</code></td>
<td>
<p>All results of the functions that perform error
computation, for each fold, each component and error criterion.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Frédéric Bertrand<br />
<a href="mailto:frederic.bertrand@utt.fr">frederic.bertrand@utt.fr</a><br />
<a href="http://www-irma.u-strasbg.fr/~fbertran/">http://www-irma.u-strasbg.fr/~fbertran/</a>
</p>


<h3>References</h3>

<p>plsRcox, Cox-Models in a high dimensional setting in R, Frederic
Bertrand, Philippe Bastien, Nicolas Meyer and Myriam Maumy-Bertrand (2014).
Proceedings of User2014!, Los Angeles, page 152.<br />
</p>
<p>Deviance residuals-based sparse PLS and sparse kernel PLS regression for
censored data, Philippe Bastien, Frederic Bertrand, Nicolas Meyer and Myriam
Maumy-Bertrand (2015), Bioinformatics, 31(3):397-404,
doi:10.1093/bioinformatics/btu660.
</p>
<p>Cross validating extensions of kernel, sparse or regular partial least
squares regression models to censored data, Bertrand, F., Bastien, Ph. and
Maumy-Bertrand, M. (2018), <a href="https://arxiv.org/abs/1810.01005">https://arxiv.org/abs/1810.01005</a>.
</p>


<h3>See Also</h3>

<p>See Also <code><a href="#topic+coxpls">coxpls</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(micro.censure)
data(Xmicro.censure_compl_imp)
set.seed(123456)
X_train_micro &lt;- apply((as.matrix(Xmicro.censure_compl_imp)),FUN="as.numeric",MARGIN=2)[1:80,]
X_train_micro_df &lt;- data.frame(X_train_micro)
Y_train_micro &lt;- micro.censure$survyear[1:80]
C_train_micro &lt;- micro.censure$DC[1:80]

#Should be run with a higher value of nt (at least 10)
(cv.coxpls.res=cv.coxpls(list(x=X_train_micro,time=Y_train_micro,status=C_train_micro),nt=3))

</code></pre>

<hr>
<h2 id='cv.coxplsDR'>Cross-validating a plsDR-Model</h2><span id='topic+cv.coxplsDR'></span>

<h3>Description</h3>

<p>This function cross-validates <a href="#topic+coxplsDR">coxplsDR</a> models.<br />
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cv.coxplsDR(
  data,
  method = c("efron", "breslow"),
  nfold = 5,
  nt = 10,
  plot.it = TRUE,
  se = TRUE,
  givefold,
  scaleX = TRUE,
  folddetails = FALSE,
  allCVcrit = FALSE,
  details = FALSE,
  namedataset = "data",
  save = FALSE,
  verbose = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cv.coxplsDR_+3A_data">data</code></td>
<td>
<p>A list of three items: </p>
 <ul>
<li><p><code>x</code> the explanatory
variables passed to <code><a href="#topic+coxplsDR">coxplsDR</a></code>'s <code>Xplan</code> argument,
</p>
</li>
<li><p><code>time</code> passed to <code><a href="#topic+coxplsDR">coxplsDR</a></code>'s <code>time</code> argument,
</p>
</li>
<li><p><code>status</code> <code><a href="#topic+coxplsDR">coxplsDR</a></code>'s <code>status</code> argument.  </p>
</li></ul>
</td></tr>
<tr><td><code id="cv.coxplsDR_+3A_method">method</code></td>
<td>
<p>A character string specifying the method for tie handling. If
there are no tied death times all the methods are equivalent. The Efron
approximation is used as the default here, it is more accurate when dealing
with tied death times, and is as efficient computationally.</p>
</td></tr>
<tr><td><code id="cv.coxplsDR_+3A_nfold">nfold</code></td>
<td>
<p>The number of folds to use to perform the cross-validation
process.</p>
</td></tr>
<tr><td><code id="cv.coxplsDR_+3A_nt">nt</code></td>
<td>
<p>The number of components to include in the model. It this is not
supplied, 10 components are fitted.</p>
</td></tr>
<tr><td><code id="cv.coxplsDR_+3A_plot.it">plot.it</code></td>
<td>
<p>Shall the results be displayed on a plot ?</p>
</td></tr>
<tr><td><code id="cv.coxplsDR_+3A_se">se</code></td>
<td>
<p>Should standard errors be plotted ?</p>
</td></tr>
<tr><td><code id="cv.coxplsDR_+3A_givefold">givefold</code></td>
<td>
<p>Explicit list of omited values in each fold can be provided
using this argument.</p>
</td></tr>
<tr><td><code id="cv.coxplsDR_+3A_scalex">scaleX</code></td>
<td>
<p>Shall the predictors be standardized ?</p>
</td></tr>
<tr><td><code id="cv.coxplsDR_+3A_folddetails">folddetails</code></td>
<td>
<p>Should values and completion status for each folds be
returned ?</p>
</td></tr>
<tr><td><code id="cv.coxplsDR_+3A_allcvcrit">allCVcrit</code></td>
<td>
<p>Should the other 13 CV criteria be evaled and returned ?</p>
</td></tr>
<tr><td><code id="cv.coxplsDR_+3A_details">details</code></td>
<td>
<p>Should all results of the functions that perform error
computations be returned ?</p>
</td></tr>
<tr><td><code id="cv.coxplsDR_+3A_namedataset">namedataset</code></td>
<td>
<p>Name to use to craft temporary results names</p>
</td></tr>
<tr><td><code id="cv.coxplsDR_+3A_save">save</code></td>
<td>
<p>Should temporary results be saved ?</p>
</td></tr>
<tr><td><code id="cv.coxplsDR_+3A_verbose">verbose</code></td>
<td>
<p>Should some CV details be displayed ?</p>
</td></tr>
<tr><td><code id="cv.coxplsDR_+3A_...">...</code></td>
<td>
<p>Other arguments to pass to <code><a href="#topic+coxplsDR">coxplsDR</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It only computes the recommended iAUCSurvROC criterion. Set
<code>allCVcrit=TRUE</code> to retrieve the 13 other ones.
</p>


<h3>Value</h3>

<table>
<tr><td><code>nt</code></td>
<td>
<p>The number of components requested</p>
</td></tr>
<tr><td><code>cv.error1</code></td>
<td>
<p>Vector with the mean values, across folds, of, per fold
unit, Cross-validated log-partial-likelihood for models with 0 to nt
components.</p>
</td></tr> <tr><td><code>cv.error2</code></td>
<td>
<p>Vector with the mean values, across folds, of,
per fold unit, van Houwelingen Cross-validated log-partial-likelihood for
models with 0 to nt components.</p>
</td></tr> <tr><td><code>cv.error3</code></td>
<td>
<p>Vector with the mean
values, across folds, of iAUC_CD for models with 0 to nt components.</p>
</td></tr>
<tr><td><code>cv.error4</code></td>
<td>
<p>Vector with the mean values, across folds, of iAUC_hc for
models with 0 to nt components.</p>
</td></tr> <tr><td><code>cv.error5</code></td>
<td>
<p>Vector with the mean
values, across folds, of iAUC_sh for models with 0 to nt components.</p>
</td></tr>
<tr><td><code>cv.error6</code></td>
<td>
<p>Vector with the mean values, across folds, of iAUC_Uno for
models with 0 to nt components.</p>
</td></tr> <tr><td><code>cv.error7</code></td>
<td>
<p>Vector with the mean
values, across folds, of iAUC_hz.train for models with 0 to nt components.</p>
</td></tr>
<tr><td><code>cv.error8</code></td>
<td>
<p>Vector with the mean values, across folds, of iAUC_hz.test
for models with 0 to nt components.</p>
</td></tr> <tr><td><code>cv.error9</code></td>
<td>
<p>Vector with the mean
values, across folds, of iAUC_survivalROC.train for models with 0 to nt
components.</p>
</td></tr> <tr><td><code>cv.error10</code></td>
<td>
<p>Vector with the mean values, across folds, of
iAUC_survivalROC.test for models with 0 to nt components.</p>
</td></tr>
<tr><td><code>cv.error11</code></td>
<td>
<p>Vector with the mean values, across folds, of iBrierScore
unw for models with 0 to nt components.</p>
</td></tr> <tr><td><code>cv.error12</code></td>
<td>
<p>Vector with the
mean values, across folds, of iSchmidScore (robust BS) unw for models with 0
to nt components.</p>
</td></tr> <tr><td><code>cv.error13</code></td>
<td>
<p>Vector with the mean values, across
folds, of iBrierScore w for models with 0 to nt components.</p>
</td></tr>
<tr><td><code>cv.error14</code></td>
<td>
<p>Vector with the mean values, across folds, of iSchmidScore
(robust BS) w for models with 0 to nt components.</p>
</td></tr> <tr><td><code>cv.se1</code></td>
<td>
<p>Vector with
the standard error values, across folds, of, per fold unit, Cross-validated
log-partial-likelihood for models with 0 to nt components.</p>
</td></tr>
<tr><td><code>cv.se2</code></td>
<td>
<p>Vector with the standard error values, across folds, of, per
fold unit, van Houwelingen Cross-validated log-partial-likelihood for models
with 0 to nt components.</p>
</td></tr> <tr><td><code>cv.se3</code></td>
<td>
<p>Vector with the standard error
values, across folds, of iAUC_CD for models with 0 to nt components.</p>
</td></tr>
<tr><td><code>cv.se4</code></td>
<td>
<p>Vector with the standard error values, across folds, of
iAUC_hc for models with 0 to nt components.</p>
</td></tr> <tr><td><code>cv.se5</code></td>
<td>
<p>Vector with the
standard error values, across folds, of iAUC_sh for models with 0 to nt
components.</p>
</td></tr> <tr><td><code>cv.se6</code></td>
<td>
<p>Vector with the standard error values, across
folds, of iAUC_Uno for models with 0 to nt components.</p>
</td></tr> <tr><td><code>cv.se7</code></td>
<td>
<p>Vector
with the standard error values, across folds, of iAUC_hz.train for models
with 0 to nt components.</p>
</td></tr> <tr><td><code>cv.se8</code></td>
<td>
<p>Vector with the standard error
values, across folds, of iAUC_hz.test for models with 0 to nt components.</p>
</td></tr>
<tr><td><code>cv.se9</code></td>
<td>
<p>Vector with the standard error values, across folds, of
iAUC_survivalROC.train for models with 0 to nt components.</p>
</td></tr>
<tr><td><code>cv.se10</code></td>
<td>
<p>Vector with the standard error values, across folds, of
iAUC_survivalROC.test for models with 0 to nt components.</p>
</td></tr>
<tr><td><code>cv.se11</code></td>
<td>
<p>Vector with the standard error values, across folds, of
iBrierScore unw for models with 0 to nt components.</p>
</td></tr> <tr><td><code>cv.se12</code></td>
<td>
<p>Vector
with the standard error values, across folds, of iSchmidScore (robust BS)
unw for models with 0 to nt components.</p>
</td></tr> <tr><td><code>cv.se13</code></td>
<td>
<p>Vector with the
standard error values, across folds, of iBrierScore w for models with 0 to
nt components.</p>
</td></tr> <tr><td><code>cv.se14</code></td>
<td>
<p>Vector with the standard error values, across
folds, of iSchmidScore (robust BS) w for models with 0 to nt components.</p>
</td></tr>
<tr><td><code>folds</code></td>
<td>
<p>Explicit list of the values that were omited values in each
fold.</p>
</td></tr> <tr><td><code>lambda.min1</code></td>
<td>
<p>Vector with the standard error values, across
folds, of, per fold unit, Cross-validated log-partial-likelihood for models
with 0 to nt components.</p>
</td></tr> <tr><td><code>lambda.min2</code></td>
<td>
<p>Vector with the standard error
values, across folds, of, per fold unit, van Houwelingen Cross-validated
log-partial-likelihood for models with 0 to nt components.</p>
</td></tr>
<tr><td><code>lambda.min1</code></td>
<td>
<p>Optimal Nbr of components, min Cross-validated
log-partial-likelihood criterion.</p>
</td></tr> <tr><td><code>lambda.se1</code></td>
<td>
<p>Optimal Nbr of
components, min+1se Cross-validated log-partial-likelihood criterion.</p>
</td></tr>
<tr><td><code>lambda.min2</code></td>
<td>
<p>Optimal Nbr of components, min van Houwelingen
Cross-validated log-partial-likelihood.</p>
</td></tr> <tr><td><code>lambda.se2</code></td>
<td>
<p>Optimal Nbr of
components, min+1se van Houwelingen Cross-validated log-partial-likelihood.</p>
</td></tr>
<tr><td><code>lambda.min3</code></td>
<td>
<p>Optimal Nbr of components, max iAUC_CD criterion.</p>
</td></tr>
<tr><td><code>lambda.se3</code></td>
<td>
<p>Optimal Nbr of components, max+1se iAUC_CD criterion.</p>
</td></tr>
<tr><td><code>lambda.min4</code></td>
<td>
<p>Optimal Nbr of components, max iAUC_hc criterion.</p>
</td></tr>
<tr><td><code>lambda.se4</code></td>
<td>
<p>Optimal Nbr of components, max+1se iAUC_hc criterion.</p>
</td></tr>
<tr><td><code>lambda.min5</code></td>
<td>
<p>Optimal Nbr of components, max iAUC_sh criterion.</p>
</td></tr>
<tr><td><code>lambda.se5</code></td>
<td>
<p>Optimal Nbr of components, max+1se iAUC_sh criterion.</p>
</td></tr>
<tr><td><code>lambda.min6</code></td>
<td>
<p>Optimal Nbr of components, max iAUC_Uno criterion.</p>
</td></tr>
<tr><td><code>lambda.se6</code></td>
<td>
<p>Optimal Nbr of components, max+1se iAUC_Uno criterion.</p>
</td></tr>
<tr><td><code>lambda.min7</code></td>
<td>
<p>Optimal Nbr of components, max iAUC_hz.train criterion.</p>
</td></tr>
<tr><td><code>lambda.se7</code></td>
<td>
<p>Optimal Nbr of components, max+1se iAUC_hz.train
criterion.</p>
</td></tr> <tr><td><code>lambda.min8</code></td>
<td>
<p>Optimal Nbr of components, max iAUC_hz.test
criterion.</p>
</td></tr> <tr><td><code>lambda.se8</code></td>
<td>
<p>Optimal Nbr of components, max+1se
iAUC_hz.test criterion.</p>
</td></tr> <tr><td><code>lambda.min9</code></td>
<td>
<p>Optimal Nbr of components, max
iAUC_survivalROC.train criterion.</p>
</td></tr> <tr><td><code>lambda.se9</code></td>
<td>
<p>Optimal Nbr of
components, max+1se iAUC_survivalROC.train criterion.</p>
</td></tr>
<tr><td><code>lambda.min10</code></td>
<td>
<p>Optimal Nbr of components, max iAUC_survivalROC.test
criterion.</p>
</td></tr> <tr><td><code>lambda.se10</code></td>
<td>
<p>Optimal Nbr of components, max+1se
iAUC_survivalROC.test criterion.</p>
</td></tr> <tr><td><code>lambda.min11</code></td>
<td>
<p>Optimal Nbr of
components, min iBrierScore unw criterion.</p>
</td></tr> <tr><td><code>lambda.se11</code></td>
<td>
<p>Optimal Nbr
of components, min+1se iBrierScore unw criterion.</p>
</td></tr>
<tr><td><code>lambda.min12</code></td>
<td>
<p>Optimal Nbr of components, min iSchmidScore unw
criterion.</p>
</td></tr> <tr><td><code>lambda.se12</code></td>
<td>
<p>Optimal Nbr of components, min+1se
iSchmidScore unw criterion.</p>
</td></tr> <tr><td><code>lambda.min13</code></td>
<td>
<p>Optimal Nbr of components,
min iBrierScore w criterion.</p>
</td></tr> <tr><td><code>lambda.se13</code></td>
<td>
<p>Optimal Nbr of components,
min+1se iBrierScore w criterion.</p>
</td></tr> <tr><td><code>lambda.min14</code></td>
<td>
<p>Optimal Nbr of
components, min iSchmidScore w criterion.</p>
</td></tr> <tr><td><code>lambda.se14</code></td>
<td>
<p>Optimal Nbr of
components, min+1se iSchmidScore w criterion.</p>
</td></tr> <tr><td><code>errormat1-14</code></td>
<td>
<p>If
<code>details=TRUE</code>, matrices with the error values for every folds across
each of the components and each of the criteria</p>
</td></tr> <tr><td><code>completed.cv1-14</code></td>
<td>
<p>If
<code>details=TRUE</code>, matrices with logical values for every folds across
each of the components and each of the criteria: <code>TRUE</code> if the
computation was completed and <code>FALSE</code> it is failed.</p>
</td></tr>
<tr><td><code>All_indics</code></td>
<td>
<p>All results of the functions that perform error
computation, for each fold, each component and error criterion.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Frédéric Bertrand<br />
<a href="mailto:frederic.bertrand@utt.fr">frederic.bertrand@utt.fr</a><br />
<a href="http://www-irma.u-strasbg.fr/~fbertran/">http://www-irma.u-strasbg.fr/~fbertran/</a>
</p>


<h3>References</h3>

<p>plsRcox, Cox-Models in a high dimensional setting in R, Frederic
Bertrand, Philippe Bastien, Nicolas Meyer and Myriam Maumy-Bertrand (2014).
Proceedings of User2014!, Los Angeles, page 152.<br />
</p>
<p>Deviance residuals-based sparse PLS and sparse kernel PLS regression for
censored data, Philippe Bastien, Frederic Bertrand, Nicolas Meyer and Myriam
Maumy-Bertrand (2015), Bioinformatics, 31(3):397-404,
doi:10.1093/bioinformatics/btu660.
</p>
<p>Cross validating extensions of kernel, sparse or regular partial least
squares regression models to censored data, Bertrand, F., Bastien, Ph. and
Maumy-Bertrand, M. (2018), <a href="https://arxiv.org/abs/1810.01005">https://arxiv.org/abs/1810.01005</a>.
</p>


<h3>See Also</h3>

<p>See Also <code><a href="#topic+coxplsDR">coxplsDR</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(micro.censure)
data(Xmicro.censure_compl_imp)
set.seed(123456)
X_train_micro &lt;- apply((as.matrix(Xmicro.censure_compl_imp)),FUN="as.numeric",MARGIN=2)[1:80,]
X_train_micro_df &lt;- data.frame(X_train_micro)
Y_train_micro &lt;- micro.censure$survyear[1:80]
C_train_micro &lt;- micro.censure$DC[1:80]

#Should be run with a higher value of nt (at least 10)
(cv.coxplsDR.res=cv.coxplsDR(list(x=X_train_micro,time=Y_train_micro,status=C_train_micro),nt=3))

</code></pre>

<hr>
<h2 id='cv.coxsplsDR'>Cross-validating a splsDR-Model</h2><span id='topic+cv.coxsplsDR'></span>

<h3>Description</h3>

<p>This function cross-validates <a href="#topic+coxsplsDR">coxsplsDR</a> models.<br />
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cv.coxsplsDR(
  data,
  method = c("efron", "breslow"),
  nfold = 5,
  nt = 10,
  eta = 0.5,
  plot.it = TRUE,
  se = TRUE,
  givefold,
  scaleX = TRUE,
  scaleY = FALSE,
  folddetails = FALSE,
  allCVcrit = FALSE,
  details = FALSE,
  namedataset = "data",
  save = FALSE,
  verbose = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cv.coxsplsDR_+3A_data">data</code></td>
<td>
<p>A list of three items: </p>
 <ul>
<li><p><code>x</code> the explanatory
variables passed to <code><a href="#topic+coxsplsDR">coxsplsDR</a></code>'s <code>Xplan</code> argument,
</p>
</li>
<li><p><code>time</code> passed to <code><a href="#topic+coxsplsDR">coxsplsDR</a></code>'s <code>time</code> argument,
</p>
</li>
<li><p><code>status</code> <code><a href="#topic+coxsplsDR">coxsplsDR</a></code>'s <code>status</code> argument.  </p>
</li></ul>
</td></tr>
<tr><td><code id="cv.coxsplsDR_+3A_method">method</code></td>
<td>
<p>A character string specifying the method for tie handling. If
there are no tied death times all the methods are equivalent. The Efron
approximation is used as the default here, it is more accurate when dealing
with tied death times, and is as efficient computationally.</p>
</td></tr>
<tr><td><code id="cv.coxsplsDR_+3A_nfold">nfold</code></td>
<td>
<p>The number of folds to use to perform the cross-validation
process.</p>
</td></tr>
<tr><td><code id="cv.coxsplsDR_+3A_nt">nt</code></td>
<td>
<p>The number of components to include in the model. It this is not
supplied, 10 components are fitted.</p>
</td></tr>
<tr><td><code id="cv.coxsplsDR_+3A_eta">eta</code></td>
<td>
<p>Thresholding parameter. <code>eta</code> should be between 0 and 1.</p>
</td></tr>
<tr><td><code id="cv.coxsplsDR_+3A_plot.it">plot.it</code></td>
<td>
<p>Shall the results be displayed on a plot ?</p>
</td></tr>
<tr><td><code id="cv.coxsplsDR_+3A_se">se</code></td>
<td>
<p>Should standard errors be plotted ?</p>
</td></tr>
<tr><td><code id="cv.coxsplsDR_+3A_givefold">givefold</code></td>
<td>
<p>Explicit list of omited values in each fold can be provided
using this argument.</p>
</td></tr>
<tr><td><code id="cv.coxsplsDR_+3A_scalex">scaleX</code></td>
<td>
<p>Shall the predictors be standardized ?</p>
</td></tr>
<tr><td><code id="cv.coxsplsDR_+3A_scaley">scaleY</code></td>
<td>
<p>Should the <code>time</code> values be standardized ?</p>
</td></tr>
<tr><td><code id="cv.coxsplsDR_+3A_folddetails">folddetails</code></td>
<td>
<p>Should values and completion status for each folds be
returned ?</p>
</td></tr>
<tr><td><code id="cv.coxsplsDR_+3A_allcvcrit">allCVcrit</code></td>
<td>
<p>Should the other 13 CV criteria be evaled and returned ?</p>
</td></tr>
<tr><td><code id="cv.coxsplsDR_+3A_details">details</code></td>
<td>
<p>Should all results of the functions that perform error
computations be returned ?</p>
</td></tr>
<tr><td><code id="cv.coxsplsDR_+3A_namedataset">namedataset</code></td>
<td>
<p>Name to use to craft temporary results names</p>
</td></tr>
<tr><td><code id="cv.coxsplsDR_+3A_save">save</code></td>
<td>
<p>Should temporary results be saved ?</p>
</td></tr>
<tr><td><code id="cv.coxsplsDR_+3A_verbose">verbose</code></td>
<td>
<p>Should some CV details be displayed ?</p>
</td></tr>
<tr><td><code id="cv.coxsplsDR_+3A_...">...</code></td>
<td>
<p>Other arguments to pass to <code><a href="#topic+coxsplsDR">coxsplsDR</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It only computes the recommended iAUCSurvROC criterion. Set
<code>allCVcrit=TRUE</code> to retrieve the 13 other ones.
</p>


<h3>Value</h3>

<table>
<tr><td><code>nt</code></td>
<td>
<p>The number of components requested</p>
</td></tr>
<tr><td><code>cv.error1</code></td>
<td>
<p>Vector with the mean values, across folds, of, per fold
unit, Cross-validated log-partial-likelihood for models with 0 to nt
components.</p>
</td></tr> <tr><td><code>cv.error2</code></td>
<td>
<p>Vector with the mean values, across folds, of,
per fold unit, van Houwelingen Cross-validated log-partial-likelihood for
models with 0 to nt components.</p>
</td></tr> <tr><td><code>cv.error3</code></td>
<td>
<p>Vector with the mean
values, across folds, of iAUC_CD for models with 0 to nt components.</p>
</td></tr>
<tr><td><code>cv.error4</code></td>
<td>
<p>Vector with the mean values, across folds, of iAUC_hc for
models with 0 to nt components.</p>
</td></tr> <tr><td><code>cv.error5</code></td>
<td>
<p>Vector with the mean
values, across folds, of iAUC_sh for models with 0 to nt components.</p>
</td></tr>
<tr><td><code>cv.error6</code></td>
<td>
<p>Vector with the mean values, across folds, of iAUC_Uno for
models with 0 to nt components.</p>
</td></tr> <tr><td><code>cv.error7</code></td>
<td>
<p>Vector with the mean
values, across folds, of iAUC_hz.train for models with 0 to nt components.</p>
</td></tr>
<tr><td><code>cv.error8</code></td>
<td>
<p>Vector with the mean values, across folds, of iAUC_hz.test
for models with 0 to nt components.</p>
</td></tr> <tr><td><code>cv.error9</code></td>
<td>
<p>Vector with the mean
values, across folds, of iAUC_survivalROC.train for models with 0 to nt
components.</p>
</td></tr> <tr><td><code>cv.error10</code></td>
<td>
<p>Vector with the mean values, across folds, of
iAUC_survivalROC.test for models with 0 to nt components.</p>
</td></tr>
<tr><td><code>cv.error11</code></td>
<td>
<p>Vector with the mean values, across folds, of iBrierScore
unw for models with 0 to nt components.</p>
</td></tr> <tr><td><code>cv.error12</code></td>
<td>
<p>Vector with the
mean values, across folds, of iSchmidScore (robust BS) unw for models with 0
to nt components.</p>
</td></tr> <tr><td><code>cv.error13</code></td>
<td>
<p>Vector with the mean values, across
folds, of iBrierScore w for models with 0 to nt components.</p>
</td></tr>
<tr><td><code>cv.error14</code></td>
<td>
<p>Vector with the mean values, across folds, of iSchmidScore
(robust BS) w for models with 0 to nt components.</p>
</td></tr> <tr><td><code>cv.se1</code></td>
<td>
<p>Vector with
the standard error values, across folds, of, per fold unit, Cross-validated
log-partial-likelihood for models with 0 to nt components.</p>
</td></tr>
<tr><td><code>cv.se2</code></td>
<td>
<p>Vector with the standard error values, across folds, of, per
fold unit, van Houwelingen Cross-validated log-partial-likelihood for models
with 0 to nt components.</p>
</td></tr> <tr><td><code>cv.se3</code></td>
<td>
<p>Vector with the standard error
values, across folds, of iAUC_CD for models with 0 to nt components.</p>
</td></tr>
<tr><td><code>cv.se4</code></td>
<td>
<p>Vector with the standard error values, across folds, of
iAUC_hc for models with 0 to nt components.</p>
</td></tr> <tr><td><code>cv.se5</code></td>
<td>
<p>Vector with the
standard error values, across folds, of iAUC_sh for models with 0 to nt
components.</p>
</td></tr> <tr><td><code>cv.se6</code></td>
<td>
<p>Vector with the standard error values, across
folds, of iAUC_Uno for models with 0 to nt components.</p>
</td></tr> <tr><td><code>cv.se7</code></td>
<td>
<p>Vector
with the standard error values, across folds, of iAUC_hz.train for models
with 0 to nt components.</p>
</td></tr> <tr><td><code>cv.se8</code></td>
<td>
<p>Vector with the standard error
values, across folds, of iAUC_hz.test for models with 0 to nt components.</p>
</td></tr>
<tr><td><code>cv.se9</code></td>
<td>
<p>Vector with the standard error values, across folds, of
iAUC_survivalROC.train for models with 0 to nt components.</p>
</td></tr>
<tr><td><code>cv.se10</code></td>
<td>
<p>Vector with the standard error values, across folds, of
iAUC_survivalROC.test for models with 0 to nt components.</p>
</td></tr>
<tr><td><code>cv.se11</code></td>
<td>
<p>Vector with the standard error values, across folds, of
iBrierScore unw for models with 0 to nt components.</p>
</td></tr> <tr><td><code>cv.se12</code></td>
<td>
<p>Vector
with the standard error values, across folds, of iSchmidScore (robust BS)
unw for models with 0 to nt components.</p>
</td></tr> <tr><td><code>cv.se13</code></td>
<td>
<p>Vector with the
standard error values, across folds, of iBrierScore w for models with 0 to
nt components.</p>
</td></tr> <tr><td><code>cv.se14</code></td>
<td>
<p>Vector with the standard error values, across
folds, of iSchmidScore (robust BS) w for models with 0 to nt components.</p>
</td></tr>
<tr><td><code>folds</code></td>
<td>
<p>Explicit list of the values that were omited values in each
fold.</p>
</td></tr> <tr><td><code>lambda.min1</code></td>
<td>
<p>Vector with the standard error values, across
folds, of, per fold unit, Cross-validated log-partial-likelihood for models
with 0 to nt components.</p>
</td></tr> <tr><td><code>lambda.min2</code></td>
<td>
<p>Vector with the standard error
values, across folds, of, per fold unit, van Houwelingen Cross-validated
log-partial-likelihood for models with 0 to nt components.</p>
</td></tr>
<tr><td><code>lambda.min1</code></td>
<td>
<p>Optimal Nbr of components, min Cross-validated
log-partial-likelihood criterion.</p>
</td></tr> <tr><td><code>lambda.se1</code></td>
<td>
<p>Optimal Nbr of
components, min+1se Cross-validated log-partial-likelihood criterion.</p>
</td></tr>
<tr><td><code>lambda.min2</code></td>
<td>
<p>Optimal Nbr of components, min van Houwelingen
Cross-validated log-partial-likelihood.</p>
</td></tr> <tr><td><code>lambda.se2</code></td>
<td>
<p>Optimal Nbr of
components, min+1se van Houwelingen Cross-validated log-partial-likelihood.</p>
</td></tr>
<tr><td><code>lambda.min3</code></td>
<td>
<p>Optimal Nbr of components, max iAUC_CD criterion.</p>
</td></tr>
<tr><td><code>lambda.se3</code></td>
<td>
<p>Optimal Nbr of components, max+1se iAUC_CD criterion.</p>
</td></tr>
<tr><td><code>lambda.min4</code></td>
<td>
<p>Optimal Nbr of components, max iAUC_hc criterion.</p>
</td></tr>
<tr><td><code>lambda.se4</code></td>
<td>
<p>Optimal Nbr of components, max+1se iAUC_hc criterion.</p>
</td></tr>
<tr><td><code>lambda.min5</code></td>
<td>
<p>Optimal Nbr of components, max iAUC_sh criterion.</p>
</td></tr>
<tr><td><code>lambda.se5</code></td>
<td>
<p>Optimal Nbr of components, max+1se iAUC_sh criterion.</p>
</td></tr>
<tr><td><code>lambda.min6</code></td>
<td>
<p>Optimal Nbr of components, max iAUC_Uno criterion.</p>
</td></tr>
<tr><td><code>lambda.se6</code></td>
<td>
<p>Optimal Nbr of components, max+1se iAUC_Uno criterion.</p>
</td></tr>
<tr><td><code>lambda.min7</code></td>
<td>
<p>Optimal Nbr of components, max iAUC_hz.train criterion.</p>
</td></tr>
<tr><td><code>lambda.se7</code></td>
<td>
<p>Optimal Nbr of components, max+1se iAUC_hz.train
criterion.</p>
</td></tr> <tr><td><code>lambda.min8</code></td>
<td>
<p>Optimal Nbr of components, max iAUC_hz.test
criterion.</p>
</td></tr> <tr><td><code>lambda.se8</code></td>
<td>
<p>Optimal Nbr of components, max+1se
iAUC_hz.test criterion.</p>
</td></tr> <tr><td><code>lambda.min9</code></td>
<td>
<p>Optimal Nbr of components, max
iAUC_survivalROC.train criterion.</p>
</td></tr> <tr><td><code>lambda.se9</code></td>
<td>
<p>Optimal Nbr of
components, max+1se iAUC_survivalROC.train criterion.</p>
</td></tr>
<tr><td><code>lambda.min10</code></td>
<td>
<p>Optimal Nbr of components, max iAUC_survivalROC.test
criterion.</p>
</td></tr> <tr><td><code>lambda.se10</code></td>
<td>
<p>Optimal Nbr of components, max+1se
iAUC_survivalROC.test criterion.</p>
</td></tr> <tr><td><code>lambda.min11</code></td>
<td>
<p>Optimal Nbr of
components, min iBrierScore unw criterion.</p>
</td></tr> <tr><td><code>lambda.se11</code></td>
<td>
<p>Optimal Nbr
of components, min+1se iBrierScore unw criterion.</p>
</td></tr>
<tr><td><code>lambda.min12</code></td>
<td>
<p>Optimal Nbr of components, min iSchmidScore unw
criterion.</p>
</td></tr> <tr><td><code>lambda.se12</code></td>
<td>
<p>Optimal Nbr of components, min+1se
iSchmidScore unw criterion.</p>
</td></tr> <tr><td><code>lambda.min13</code></td>
<td>
<p>Optimal Nbr of components,
min iBrierScore w criterion.</p>
</td></tr> <tr><td><code>lambda.se13</code></td>
<td>
<p>Optimal Nbr of components,
min+1se iBrierScore w criterion.</p>
</td></tr> <tr><td><code>lambda.min14</code></td>
<td>
<p>Optimal Nbr of
components, min iSchmidScore w criterion.</p>
</td></tr> <tr><td><code>lambda.se14</code></td>
<td>
<p>Optimal Nbr of
components, min+1se iSchmidScore w criterion.</p>
</td></tr> <tr><td><code>errormat1-14</code></td>
<td>
<p>If
<code>details=TRUE</code>, matrices with the error values for every folds across
each of the components and each of the criteria</p>
</td></tr> <tr><td><code>completed.cv1-14</code></td>
<td>
<p>If
<code>details=TRUE</code>, matrices with logical values for every folds across
each of the components and each of the criteria: <code>TRUE</code> if the
computation was completed and <code>FALSE</code> it is failed.</p>
</td></tr>
<tr><td><code>All_indics</code></td>
<td>
<p>All results of the functions that perform error
computation, for each fold, each component and error criterion.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Frédéric Bertrand<br />
<a href="mailto:frederic.bertrand@utt.fr">frederic.bertrand@utt.fr</a><br />
<a href="http://www-irma.u-strasbg.fr/~fbertran/">http://www-irma.u-strasbg.fr/~fbertran/</a>
</p>


<h3>References</h3>

<p>plsRcox, Cox-Models in a high dimensional setting in R, Frederic
Bertrand, Philippe Bastien, Nicolas Meyer and Myriam Maumy-Bertrand (2014).
Proceedings of User2014!, Los Angeles, page 152.<br />
</p>
<p>Deviance residuals-based sparse PLS and sparse kernel PLS regression for
censored data, Philippe Bastien, Frederic Bertrand, Nicolas Meyer and Myriam
Maumy-Bertrand (2015), Bioinformatics, 31(3):397-404,
doi:10.1093/bioinformatics/btu660.
</p>
<p>Cross validating extensions of kernel, sparse or regular partial least
squares regression models to censored data, Bertrand, F., Bastien, Ph. and
Maumy-Bertrand, M. (2018), <a href="https://arxiv.org/abs/1810.01005">https://arxiv.org/abs/1810.01005</a>.
</p>


<h3>See Also</h3>

<p>See Also <code><a href="#topic+coxsplsDR">coxsplsDR</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(micro.censure)
data(Xmicro.censure_compl_imp)
set.seed(123456)
X_train_micro &lt;- apply((as.matrix(Xmicro.censure_compl_imp)),FUN="as.numeric",MARGIN=2)[1:80,]
X_train_micro_df &lt;- data.frame(X_train_micro)
Y_train_micro &lt;- micro.censure$survyear[1:80]
C_train_micro &lt;- micro.censure$DC[1:80]

#Should be run with a higher value of nt (at least 10) and a grid of eta
(cv.coxsplsDR.res=cv.coxsplsDR(list(x=X_train_micro,time=Y_train_micro,
status=C_train_micro),nt=3,eta=.1))

</code></pre>

<hr>
<h2 id='cv.larsDR'>Cross-validating a larsDR-Model</h2><span id='topic+cv.larsDR'></span>

<h3>Description</h3>

<p>This function cross-validates <a href="#topic+larsDR_coxph">larsDR_coxph</a> models.<br />
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cv.larsDR(
  data,
  method = c("efron", "breslow"),
  nfold = 5,
  fraction = seq(0, 1, length = 100),
  plot.it = TRUE,
  se = TRUE,
  givefold,
  scaleX = TRUE,
  scaleY = FALSE,
  folddetails = FALSE,
  allCVcrit = FALSE,
  details = FALSE,
  namedataset = "data",
  save = FALSE,
  verbose = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cv.larsDR_+3A_data">data</code></td>
<td>
<p>A list of three items: </p>
 <ul>
<li><p><code>x</code> the explanatory
variables passed to <code><a href="#topic+larsDR_coxph">larsDR_coxph</a></code>'s <code>Xplan</code> argument,
</p>
</li>
<li><p><code>time</code> passed to <code><a href="#topic+larsDR_coxph">larsDR_coxph</a></code>'s <code>time</code>
argument, </p>
</li>
<li><p><code>status</code> <code><a href="#topic+larsDR_coxph">larsDR_coxph</a></code>'s <code>status</code>
argument.  </p>
</li></ul>
</td></tr>
<tr><td><code id="cv.larsDR_+3A_method">method</code></td>
<td>
<p>A character string specifying the method for tie handling. If
there are no tied death times all the methods are equivalent. The Efron
approximation is used as the default here, it is more accurate when dealing
with tied death times, and is as efficient computationally.</p>
</td></tr>
<tr><td><code id="cv.larsDR_+3A_nfold">nfold</code></td>
<td>
<p>The number of folds to use to perform the cross-validation
process.</p>
</td></tr>
<tr><td><code id="cv.larsDR_+3A_fraction">fraction</code></td>
<td>
<p>L1 norm fraction.</p>
</td></tr>
<tr><td><code id="cv.larsDR_+3A_plot.it">plot.it</code></td>
<td>
<p>Shall the results be displayed on a plot ?</p>
</td></tr>
<tr><td><code id="cv.larsDR_+3A_se">se</code></td>
<td>
<p>Should standard errors be plotted ?</p>
</td></tr>
<tr><td><code id="cv.larsDR_+3A_givefold">givefold</code></td>
<td>
<p>Explicit list of omited values in each fold can be provided
using this argument.</p>
</td></tr>
<tr><td><code id="cv.larsDR_+3A_scalex">scaleX</code></td>
<td>
<p>Shall the predictors be standardized ?</p>
</td></tr>
<tr><td><code id="cv.larsDR_+3A_scaley">scaleY</code></td>
<td>
<p>Should the <code>time</code> values be standardized ?</p>
</td></tr>
<tr><td><code id="cv.larsDR_+3A_folddetails">folddetails</code></td>
<td>
<p>Should values and completion status for each folds be
returned ?</p>
</td></tr>
<tr><td><code id="cv.larsDR_+3A_allcvcrit">allCVcrit</code></td>
<td>
<p>Should the other 13 CV criteria be evaled and returned ?</p>
</td></tr>
<tr><td><code id="cv.larsDR_+3A_details">details</code></td>
<td>
<p>Should all results of the functions that perform error
computations be returned ?</p>
</td></tr>
<tr><td><code id="cv.larsDR_+3A_namedataset">namedataset</code></td>
<td>
<p>Name to use to craft temporary results names</p>
</td></tr>
<tr><td><code id="cv.larsDR_+3A_save">save</code></td>
<td>
<p>Should temporary results be saved ?</p>
</td></tr>
<tr><td><code id="cv.larsDR_+3A_verbose">verbose</code></td>
<td>
<p>Should some CV details be displayed ?</p>
</td></tr>
<tr><td><code id="cv.larsDR_+3A_...">...</code></td>
<td>
<p>Other arguments to pass to <code><a href="#topic+larsDR_coxph">larsDR_coxph</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It only computes the recommended van Houwelingen CV partial likelihood
criterion criterion. Set <code>allCVcrit=TRUE</code> to retrieve the 13 other
ones.
</p>


<h3>Value</h3>

<table>
<tr><td><code>nt</code></td>
<td>
<p>The number of components requested</p>
</td></tr>
<tr><td><code>cv.error1</code></td>
<td>
<p>Vector with the mean values, across folds, of, per fold
unit, Cross-validated log-partial-likelihood for models with 0 to nt
components.</p>
</td></tr> <tr><td><code>cv.error2</code></td>
<td>
<p>Vector with the mean values, across folds, of,
per fold unit, van Houwelingen Cross-validated log-partial-likelihood for
models with 0 to nt components.</p>
</td></tr> <tr><td><code>cv.error3</code></td>
<td>
<p>Vector with the mean
values, across folds, of iAUC_CD for models with 0 to nt components.</p>
</td></tr>
<tr><td><code>cv.error4</code></td>
<td>
<p>Vector with the mean values, across folds, of iAUC_hc for
models with 0 to nt components.</p>
</td></tr> <tr><td><code>cv.error5</code></td>
<td>
<p>Vector with the mean
values, across folds, of iAUC_sh for models with 0 to nt components.</p>
</td></tr>
<tr><td><code>cv.error6</code></td>
<td>
<p>Vector with the mean values, across folds, of iAUC_Uno for
models with 0 to nt components.</p>
</td></tr> <tr><td><code>cv.error7</code></td>
<td>
<p>Vector with the mean
values, across folds, of iAUC_hz.train for models with 0 to nt components.</p>
</td></tr>
<tr><td><code>cv.error8</code></td>
<td>
<p>Vector with the mean values, across folds, of iAUC_hz.test
for models with 0 to nt components.</p>
</td></tr> <tr><td><code>cv.error9</code></td>
<td>
<p>Vector with the mean
values, across folds, of iAUC_survivalROC.train for models with 0 to nt
components.</p>
</td></tr> <tr><td><code>cv.error10</code></td>
<td>
<p>Vector with the mean values, across folds, of
iAUC_survivalROC.test for models with 0 to nt components.</p>
</td></tr>
<tr><td><code>cv.error11</code></td>
<td>
<p>Vector with the mean values, across folds, of iBrierScore
unw for models with 0 to nt components.</p>
</td></tr> <tr><td><code>cv.error12</code></td>
<td>
<p>Vector with the
mean values, across folds, of iSchmidScore (robust BS) unw for models with 0
to nt components.</p>
</td></tr> <tr><td><code>cv.error13</code></td>
<td>
<p>Vector with the mean values, across
folds, of iBrierScore w for models with 0 to nt components.</p>
</td></tr>
<tr><td><code>cv.error14</code></td>
<td>
<p>Vector with the mean values, across folds, of iSchmidScore
(robust BS) w for models with 0 to nt components.</p>
</td></tr> <tr><td><code>cv.se1</code></td>
<td>
<p>Vector with
the standard error values, across folds, of, per fold unit, Cross-validated
log-partial-likelihood for models with 0 to nt components.</p>
</td></tr>
<tr><td><code>cv.se2</code></td>
<td>
<p>Vector with the standard error values, across folds, of, per
fold unit, van Houwelingen Cross-validated log-partial-likelihood for models
with 0 to nt components.</p>
</td></tr> <tr><td><code>cv.se3</code></td>
<td>
<p>Vector with the standard error
values, across folds, of iAUC_CD for models with 0 to nt components.</p>
</td></tr>
<tr><td><code>cv.se4</code></td>
<td>
<p>Vector with the standard error values, across folds, of
iAUC_hc for models with 0 to nt components.</p>
</td></tr> <tr><td><code>cv.se5</code></td>
<td>
<p>Vector with the
standard error values, across folds, of iAUC_sh for models with 0 to nt
components.</p>
</td></tr> <tr><td><code>cv.se6</code></td>
<td>
<p>Vector with the standard error values, across
folds, of iAUC_Uno for models with 0 to nt components.</p>
</td></tr> <tr><td><code>cv.se7</code></td>
<td>
<p>Vector
with the standard error values, across folds, of iAUC_hz.train for models
with 0 to nt components.</p>
</td></tr> <tr><td><code>cv.se8</code></td>
<td>
<p>Vector with the standard error
values, across folds, of iAUC_hz.test for models with 0 to nt components.</p>
</td></tr>
<tr><td><code>cv.se9</code></td>
<td>
<p>Vector with the standard error values, across folds, of
iAUC_survivalROC.train for models with 0 to nt components.</p>
</td></tr>
<tr><td><code>cv.se10</code></td>
<td>
<p>Vector with the standard error values, across folds, of
iAUC_survivalROC.test for models with 0 to nt components.</p>
</td></tr>
<tr><td><code>cv.se11</code></td>
<td>
<p>Vector with the standard error values, across folds, of
iBrierScore unw for models with 0 to nt components.</p>
</td></tr> <tr><td><code>cv.se12</code></td>
<td>
<p>Vector
with the standard error values, across folds, of iSchmidScore (robust BS)
unw for models with 0 to nt components.</p>
</td></tr> <tr><td><code>cv.se13</code></td>
<td>
<p>Vector with the
standard error values, across folds, of iBrierScore w for models with 0 to
nt components.</p>
</td></tr> <tr><td><code>cv.se14</code></td>
<td>
<p>Vector with the standard error values, across
folds, of iSchmidScore (robust BS) w for models with 0 to nt components.</p>
</td></tr>
<tr><td><code>folds</code></td>
<td>
<p>Explicit list of the values that were omited values in each
fold.</p>
</td></tr> <tr><td><code>lambda.min1</code></td>
<td>
<p>Vector with the standard error values, across
folds, of, per fold unit, Cross-validated log-partial-likelihood for models
with 0 to nt components.</p>
</td></tr> <tr><td><code>lambda.min2</code></td>
<td>
<p>Vector with the standard error
values, across folds, of, per fold unit, van Houwelingen Cross-validated
log-partial-likelihood for models with 0 to nt components.</p>
</td></tr>
<tr><td><code>lambda.min1</code></td>
<td>
<p>Optimal Nbr of components, min Cross-validated
log-partial-likelihood criterion.</p>
</td></tr> <tr><td><code>lambda.se1</code></td>
<td>
<p>Optimal Nbr of
components, min+1se Cross-validated log-partial-likelihood criterion.</p>
</td></tr>
<tr><td><code>lambda.min2</code></td>
<td>
<p>Optimal Nbr of components, min van Houwelingen
Cross-validated log-partial-likelihood.</p>
</td></tr> <tr><td><code>lambda.se2</code></td>
<td>
<p>Optimal Nbr of
components, min+1se van Houwelingen Cross-validated log-partial-likelihood.</p>
</td></tr>
<tr><td><code>lambda.min3</code></td>
<td>
<p>Optimal Nbr of components, max iAUC_CD criterion.</p>
</td></tr>
<tr><td><code>lambda.se3</code></td>
<td>
<p>Optimal Nbr of components, max+1se iAUC_CD criterion.</p>
</td></tr>
<tr><td><code>lambda.min4</code></td>
<td>
<p>Optimal Nbr of components, max iAUC_hc criterion.</p>
</td></tr>
<tr><td><code>lambda.se4</code></td>
<td>
<p>Optimal Nbr of components, max+1se iAUC_hc criterion.</p>
</td></tr>
<tr><td><code>lambda.min5</code></td>
<td>
<p>Optimal Nbr of components, max iAUC_sh criterion.</p>
</td></tr>
<tr><td><code>lambda.se5</code></td>
<td>
<p>Optimal Nbr of components, max+1se iAUC_sh criterion.</p>
</td></tr>
<tr><td><code>lambda.min6</code></td>
<td>
<p>Optimal Nbr of components, max iAUC_Uno criterion.</p>
</td></tr>
<tr><td><code>lambda.se6</code></td>
<td>
<p>Optimal Nbr of components, max+1se iAUC_Uno criterion.</p>
</td></tr>
<tr><td><code>lambda.min7</code></td>
<td>
<p>Optimal Nbr of components, max iAUC_hz.train criterion.</p>
</td></tr>
<tr><td><code>lambda.se7</code></td>
<td>
<p>Optimal Nbr of components, max+1se iAUC_hz.train
criterion.</p>
</td></tr> <tr><td><code>lambda.min8</code></td>
<td>
<p>Optimal Nbr of components, max iAUC_hz.test
criterion.</p>
</td></tr> <tr><td><code>lambda.se8</code></td>
<td>
<p>Optimal Nbr of components, max+1se
iAUC_hz.test criterion.</p>
</td></tr> <tr><td><code>lambda.min9</code></td>
<td>
<p>Optimal Nbr of components, max
iAUC_survivalROC.train criterion.</p>
</td></tr> <tr><td><code>lambda.se9</code></td>
<td>
<p>Optimal Nbr of
components, max+1se iAUC_survivalROC.train criterion.</p>
</td></tr>
<tr><td><code>lambda.min10</code></td>
<td>
<p>Optimal Nbr of components, max iAUC_survivalROC.test
criterion.</p>
</td></tr> <tr><td><code>lambda.se10</code></td>
<td>
<p>Optimal Nbr of components, max+1se
iAUC_survivalROC.test criterion.</p>
</td></tr> <tr><td><code>lambda.min11</code></td>
<td>
<p>Optimal Nbr of
components, min iBrierScore unw criterion.</p>
</td></tr> <tr><td><code>lambda.se11</code></td>
<td>
<p>Optimal Nbr
of components, min+1se iBrierScore unw criterion.</p>
</td></tr>
<tr><td><code>lambda.min12</code></td>
<td>
<p>Optimal Nbr of components, min iSchmidScore unw
criterion.</p>
</td></tr> <tr><td><code>lambda.se12</code></td>
<td>
<p>Optimal Nbr of components, min+1se
iSchmidScore unw criterion.</p>
</td></tr> <tr><td><code>lambda.min13</code></td>
<td>
<p>Optimal Nbr of components,
min iBrierScore w criterion.</p>
</td></tr> <tr><td><code>lambda.se13</code></td>
<td>
<p>Optimal Nbr of components,
min+1se iBrierScore w criterion.</p>
</td></tr> <tr><td><code>lambda.min14</code></td>
<td>
<p>Optimal Nbr of
components, min iSchmidScore w criterion.</p>
</td></tr> <tr><td><code>lambda.se14</code></td>
<td>
<p>Optimal Nbr of
components, min+1se iSchmidScore w criterion.</p>
</td></tr> <tr><td><code>errormat1-14</code></td>
<td>
<p>If
<code>details=TRUE</code>, matrices with the error values for every folds across
each of the components and each of the criteria</p>
</td></tr> <tr><td><code>completed.cv1-14</code></td>
<td>
<p>If
<code>details=TRUE</code>, matrices with logical values for every folds across
each of the components and each of the criteria: <code>TRUE</code> if the
computation was completed and <code>FALSE</code> it is failed.</p>
</td></tr>
<tr><td><code>larsmodfull</code></td>
<td>
<p>Lars model fitted on the residuals.</p>
</td></tr>
<tr><td><code>All_indics</code></td>
<td>
<p>All results of the functions that perform error
computation, for each fold, each component and error criterion.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Frédéric Bertrand<br />
<a href="mailto:frederic.bertrand@utt.fr">frederic.bertrand@utt.fr</a><br />
<a href="http://www-irma.u-strasbg.fr/~fbertran/">http://www-irma.u-strasbg.fr/~fbertran/</a>
</p>


<h3>References</h3>

<p>plsRcox, Cox-Models in a high dimensional setting in R, Frederic
Bertrand, Philippe Bastien, Nicolas Meyer and Myriam Maumy-Bertrand (2014).
Proceedings of User2014!, Los Angeles, page 152.<br />
</p>
<p>Deviance residuals-based sparse PLS and sparse kernel PLS regression for
censored data, Philippe Bastien, Frederic Bertrand, Nicolas Meyer and Myriam
Maumy-Bertrand (2015), Bioinformatics, 31(3):397-404,
doi:10.1093/bioinformatics/btu660.
</p>


<h3>See Also</h3>

<p>See Also <code><a href="#topic+larsDR_coxph">larsDR_coxph</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(micro.censure)
data(Xmicro.censure_compl_imp)
set.seed(123456)
X_train_micro &lt;- apply((as.matrix(Xmicro.censure_compl_imp)),FUN="as.numeric",MARGIN=2)[1:80,]
X_train_micro_df &lt;- data.frame(X_train_micro)
Y_train_micro &lt;- micro.censure$survyear[1:80]
C_train_micro &lt;- micro.censure$DC[1:80]

#Should be run with the default: fraction = seq(0, 1, length = 100)
(cv.larsDR.res=cv.larsDR(list(x=X_train_micro,time=Y_train_micro,
status=C_train_micro),se=TRUE,fraction=seq(0, 1, length = 4)))

</code></pre>

<hr>
<h2 id='cv.plsRcox'>Cross-validating a plsRcox-Model</h2><span id='topic+cv.plsRcox'></span>

<h3>Description</h3>

<p>This function cross-validates <a href="#topic+plsRcox">plsRcox</a> models.<br />
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cv.plsRcox(
  data,
  method = c("efron", "breslow"),
  nfold = 5,
  nt = 10,
  plot.it = TRUE,
  se = TRUE,
  givefold,
  scaleX = TRUE,
  folddetails = FALSE,
  allCVcrit = FALSE,
  details = FALSE,
  namedataset = "data",
  save = FALSE,
  verbose = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cv.plsRcox_+3A_data">data</code></td>
<td>
<p>A list of three items: </p>
 <ul>
<li><p><code>x</code> the explanatory
variables passed to <code><a href="#topic+plsRcox">plsRcox</a></code>'s <code>Xplan</code> argument,
</p>
</li>
<li><p><code>time</code> passed to <code><a href="#topic+plsRcox">plsRcox</a></code>'s <code>time</code> argument,
</p>
</li>
<li><p><code>status</code> <code><a href="#topic+plsRcox">plsRcox</a></code>'s <code>status</code> argument.  </p>
</li></ul>
</td></tr>
<tr><td><code id="cv.plsRcox_+3A_method">method</code></td>
<td>
<p>A character string specifying the method for tie handling. If
there are no tied death times all the methods are equivalent. The Efron
approximation is used as the default here, it is more accurate when dealing
with tied death times, and is as efficient computationally.</p>
</td></tr>
<tr><td><code id="cv.plsRcox_+3A_nfold">nfold</code></td>
<td>
<p>The number of folds to use to perform the cross-validation
process.</p>
</td></tr>
<tr><td><code id="cv.plsRcox_+3A_nt">nt</code></td>
<td>
<p>The number of components to include in the model. It this is not
supplied, 10 components are fitted.</p>
</td></tr>
<tr><td><code id="cv.plsRcox_+3A_plot.it">plot.it</code></td>
<td>
<p>Shall the results be displayed on a plot ?</p>
</td></tr>
<tr><td><code id="cv.plsRcox_+3A_se">se</code></td>
<td>
<p>Should standard errors be plotted ?</p>
</td></tr>
<tr><td><code id="cv.plsRcox_+3A_givefold">givefold</code></td>
<td>
<p>Explicit list of omited values in each fold can be provided
using this argument.</p>
</td></tr>
<tr><td><code id="cv.plsRcox_+3A_scalex">scaleX</code></td>
<td>
<p>Shall the predictors be standardized ?</p>
</td></tr>
<tr><td><code id="cv.plsRcox_+3A_folddetails">folddetails</code></td>
<td>
<p>Should values and completion status for each folds be
returned ?</p>
</td></tr>
<tr><td><code id="cv.plsRcox_+3A_allcvcrit">allCVcrit</code></td>
<td>
<p>Should the other 13 CV criteria be evaled and returned ?</p>
</td></tr>
<tr><td><code id="cv.plsRcox_+3A_details">details</code></td>
<td>
<p>Should all results of the functions that perform error
computations be returned ?</p>
</td></tr>
<tr><td><code id="cv.plsRcox_+3A_namedataset">namedataset</code></td>
<td>
<p>Name to use to craft temporary results names</p>
</td></tr>
<tr><td><code id="cv.plsRcox_+3A_save">save</code></td>
<td>
<p>Should temporary results be saved ?</p>
</td></tr>
<tr><td><code id="cv.plsRcox_+3A_verbose">verbose</code></td>
<td>
<p>Should some CV details be displayed ?</p>
</td></tr>
<tr><td><code id="cv.plsRcox_+3A_...">...</code></td>
<td>
<p>Other arguments to pass to <code><a href="#topic+plsRcox">plsRcox</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It only computes the recommended iAUCSH criterion. Set <code>allCVcrit=TRUE</code>
to retrieve the 13 other ones.
</p>


<h3>Value</h3>

<table>
<tr><td><code>nt</code></td>
<td>
<p>The number of components requested</p>
</td></tr>
<tr><td><code>cv.error1</code></td>
<td>
<p>Vector with the mean values, across folds, of, per fold
unit, Cross-validated log-partial-likelihood for models with 0 to nt
components.</p>
</td></tr> <tr><td><code>cv.error2</code></td>
<td>
<p>Vector with the mean values, across folds, of,
per fold unit, van Houwelingen Cross-validated log-partial-likelihood for
models with 0 to nt components.</p>
</td></tr> <tr><td><code>cv.error3</code></td>
<td>
<p>Vector with the mean
values, across folds, of iAUC_CD for models with 0 to nt components.</p>
</td></tr>
<tr><td><code>cv.error4</code></td>
<td>
<p>Vector with the mean values, across folds, of iAUC_hc for
models with 0 to nt components.</p>
</td></tr> <tr><td><code>cv.error5</code></td>
<td>
<p>Vector with the mean
values, across folds, of iAUC_sh for models with 0 to nt components.</p>
</td></tr>
<tr><td><code>cv.error6</code></td>
<td>
<p>Vector with the mean values, across folds, of iAUC_Uno for
models with 0 to nt components.</p>
</td></tr> <tr><td><code>cv.error7</code></td>
<td>
<p>Vector with the mean
values, across folds, of iAUC_hz.train for models with 0 to nt components.</p>
</td></tr>
<tr><td><code>cv.error8</code></td>
<td>
<p>Vector with the mean values, across folds, of iAUC_hz.test
for models with 0 to nt components.</p>
</td></tr> <tr><td><code>cv.error9</code></td>
<td>
<p>Vector with the mean
values, across folds, of iAUC_survivalROC.train for models with 0 to nt
components.</p>
</td></tr> <tr><td><code>cv.error10</code></td>
<td>
<p>Vector with the mean values, across folds, of
iAUC_survivalROC.test for models with 0 to nt components.</p>
</td></tr>
<tr><td><code>cv.error11</code></td>
<td>
<p>Vector with the mean values, across folds, of iBrierScore
unw for models with 0 to nt components.</p>
</td></tr> <tr><td><code>cv.error12</code></td>
<td>
<p>Vector with the
mean values, across folds, of iSchmidScore (robust BS) unw for models with 0
to nt components.</p>
</td></tr> <tr><td><code>cv.error13</code></td>
<td>
<p>Vector with the mean values, across
folds, of iBrierScore w for models with 0 to nt components.</p>
</td></tr>
<tr><td><code>cv.error14</code></td>
<td>
<p>Vector with the mean values, across folds, of iSchmidScore
(robust BS) w for models with 0 to nt components.</p>
</td></tr> <tr><td><code>cv.se1</code></td>
<td>
<p>Vector with
the standard error values, across folds, of, per fold unit, Cross-validated
log-partial-likelihood for models with 0 to nt components.</p>
</td></tr>
<tr><td><code>cv.se2</code></td>
<td>
<p>Vector with the standard error values, across folds, of, per
fold unit, van Houwelingen Cross-validated log-partial-likelihood for models
with 0 to nt components.</p>
</td></tr> <tr><td><code>cv.se3</code></td>
<td>
<p>Vector with the standard error
values, across folds, of iAUC_CD for models with 0 to nt components.</p>
</td></tr>
<tr><td><code>cv.se4</code></td>
<td>
<p>Vector with the standard error values, across folds, of
iAUC_hc for models with 0 to nt components.</p>
</td></tr> <tr><td><code>cv.se5</code></td>
<td>
<p>Vector with the
standard error values, across folds, of iAUC_sh for models with 0 to nt
components.</p>
</td></tr> <tr><td><code>cv.se6</code></td>
<td>
<p>Vector with the standard error values, across
folds, of iAUC_Uno for models with 0 to nt components.</p>
</td></tr> <tr><td><code>cv.se7</code></td>
<td>
<p>Vector
with the standard error values, across folds, of iAUC_hz.train for models
with 0 to nt components.</p>
</td></tr> <tr><td><code>cv.se8</code></td>
<td>
<p>Vector with the standard error
values, across folds, of iAUC_hz.test for models with 0 to nt components.</p>
</td></tr>
<tr><td><code>cv.se9</code></td>
<td>
<p>Vector with the standard error values, across folds, of
iAUC_survivalROC.train for models with 0 to nt components.</p>
</td></tr>
<tr><td><code>cv.se10</code></td>
<td>
<p>Vector with the standard error values, across folds, of
iAUC_survivalROC.test for models with 0 to nt components.</p>
</td></tr>
<tr><td><code>cv.se11</code></td>
<td>
<p>Vector with the standard error values, across folds, of
iBrierScore unw for models with 0 to nt components.</p>
</td></tr> <tr><td><code>cv.se12</code></td>
<td>
<p>Vector
with the standard error values, across folds, of iSchmidScore (robust BS)
unw for models with 0 to nt components.</p>
</td></tr> <tr><td><code>cv.se13</code></td>
<td>
<p>Vector with the
standard error values, across folds, of iBrierScore w for models with 0 to
nt components.</p>
</td></tr> <tr><td><code>cv.se14</code></td>
<td>
<p>Vector with the standard error values, across
folds, of iSchmidScore (robust BS) w for models with 0 to nt components.</p>
</td></tr>
<tr><td><code>folds</code></td>
<td>
<p>Explicit list of the values that were omited values in each
fold.</p>
</td></tr> <tr><td><code>lambda.min1</code></td>
<td>
<p>Vector with the standard error values, across
folds, of, per fold unit, Cross-validated log-partial-likelihood for models
with 0 to nt components.</p>
</td></tr> <tr><td><code>lambda.min2</code></td>
<td>
<p>Vector with the standard error
values, across folds, of, per fold unit, van Houwelingen Cross-validated
log-partial-likelihood for models with 0 to nt components.</p>
</td></tr>
<tr><td><code>lambda.min1</code></td>
<td>
<p>Optimal Nbr of components, min Cross-validated
log-partial-likelihood criterion.</p>
</td></tr> <tr><td><code>lambda.se1</code></td>
<td>
<p>Optimal Nbr of
components, min+1se Cross-validated log-partial-likelihood criterion.</p>
</td></tr>
<tr><td><code>lambda.min2</code></td>
<td>
<p>Optimal Nbr of components, min van Houwelingen
Cross-validated log-partial-likelihood.</p>
</td></tr> <tr><td><code>lambda.se2</code></td>
<td>
<p>Optimal Nbr of
components, min+1se van Houwelingen Cross-validated log-partial-likelihood.</p>
</td></tr>
<tr><td><code>lambda.min3</code></td>
<td>
<p>Optimal Nbr of components, max iAUC_CD criterion.</p>
</td></tr>
<tr><td><code>lambda.se3</code></td>
<td>
<p>Optimal Nbr of components, max+1se iAUC_CD criterion.</p>
</td></tr>
<tr><td><code>lambda.min4</code></td>
<td>
<p>Optimal Nbr of components, max iAUC_hc criterion.</p>
</td></tr>
<tr><td><code>lambda.se4</code></td>
<td>
<p>Optimal Nbr of components, max+1se iAUC_hc criterion.</p>
</td></tr>
<tr><td><code>lambda.min5</code></td>
<td>
<p>Optimal Nbr of components, max iAUC_sh criterion.</p>
</td></tr>
<tr><td><code>lambda.se5</code></td>
<td>
<p>Optimal Nbr of components, max+1se iAUC_sh criterion.</p>
</td></tr>
<tr><td><code>lambda.min6</code></td>
<td>
<p>Optimal Nbr of components, max iAUC_Uno criterion.</p>
</td></tr>
<tr><td><code>lambda.se6</code></td>
<td>
<p>Optimal Nbr of components, max+1se iAUC_Uno criterion.</p>
</td></tr>
<tr><td><code>lambda.min7</code></td>
<td>
<p>Optimal Nbr of components, max iAUC_hz.train criterion.</p>
</td></tr>
<tr><td><code>lambda.se7</code></td>
<td>
<p>Optimal Nbr of components, max+1se iAUC_hz.train
criterion.</p>
</td></tr> <tr><td><code>lambda.min8</code></td>
<td>
<p>Optimal Nbr of components, max iAUC_hz.test
criterion.</p>
</td></tr> <tr><td><code>lambda.se8</code></td>
<td>
<p>Optimal Nbr of components, max+1se
iAUC_hz.test criterion.</p>
</td></tr> <tr><td><code>lambda.min9</code></td>
<td>
<p>Optimal Nbr of components, max
iAUC_survivalROC.train criterion.</p>
</td></tr> <tr><td><code>lambda.se9</code></td>
<td>
<p>Optimal Nbr of
components, max+1se iAUC_survivalROC.train criterion.</p>
</td></tr>
<tr><td><code>lambda.min10</code></td>
<td>
<p>Optimal Nbr of components, max iAUC_survivalROC.test
criterion.</p>
</td></tr> <tr><td><code>lambda.se10</code></td>
<td>
<p>Optimal Nbr of components, max+1se
iAUC_survivalROC.test criterion.</p>
</td></tr> <tr><td><code>lambda.min11</code></td>
<td>
<p>Optimal Nbr of
components, min iBrierScore unw criterion.</p>
</td></tr> <tr><td><code>lambda.se11</code></td>
<td>
<p>Optimal Nbr
of components, min+1se iBrierScore unw criterion.</p>
</td></tr>
<tr><td><code>lambda.min12</code></td>
<td>
<p>Optimal Nbr of components, min iSchmidScore unw
criterion.</p>
</td></tr> <tr><td><code>lambda.se12</code></td>
<td>
<p>Optimal Nbr of components, min+1se
iSchmidScore unw criterion.</p>
</td></tr> <tr><td><code>lambda.min13</code></td>
<td>
<p>Optimal Nbr of components,
min iBrierScore w criterion.</p>
</td></tr> <tr><td><code>lambda.se13</code></td>
<td>
<p>Optimal Nbr of components,
min+1se iBrierScore w criterion.</p>
</td></tr> <tr><td><code>lambda.min14</code></td>
<td>
<p>Optimal Nbr of
components, min iSchmidScore w criterion.</p>
</td></tr> <tr><td><code>lambda.se14</code></td>
<td>
<p>Optimal Nbr of
components, min+1se iSchmidScore w criterion.</p>
</td></tr> <tr><td><code>errormat1-14</code></td>
<td>
<p>If
<code>details=TRUE</code>, matrices with the error values for every folds across
each of the components and each of the criteria</p>
</td></tr> <tr><td><code>completed.cv1-14</code></td>
<td>
<p>If
<code>details=TRUE</code>, matrices with logical values for every folds across
each of the components and each of the criteria: <code>TRUE</code> if the
computation was completed and <code>FALSE</code> it is failed.</p>
</td></tr>
<tr><td><code>All_indics</code></td>
<td>
<p>All results of the functions that perform error
computation, for each fold, each component and error criterion.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Frédéric Bertrand<br />
<a href="mailto:frederic.bertrand@utt.fr">frederic.bertrand@utt.fr</a><br />
<a href="http://www-irma.u-strasbg.fr/~fbertran/">http://www-irma.u-strasbg.fr/~fbertran/</a>
</p>


<h3>References</h3>

<p>plsRcox, Cox-Models in a high dimensional setting in R, Frederic
Bertrand, Philippe Bastien, Nicolas Meyer and Myriam Maumy-Bertrand (2014).
Proceedings of User2014!, Los Angeles, page 152.<br />
</p>
<p>Deviance residuals-based sparse PLS and sparse kernel PLS regression for
censored data, Philippe Bastien, Frederic Bertrand, Nicolas Meyer and Myriam
Maumy-Bertrand (2015), Bioinformatics, 31(3):397-404,
doi:10.1093/bioinformatics/btu660.
</p>
<p>Cross validating extensions of kernel, sparse or regular partial least
squares regression models to censored data, Bertrand, F., Bastien, Ph. and
Maumy-Bertrand, M. (2018), <a href="https://arxiv.org/abs/1810.01005">https://arxiv.org/abs/1810.01005</a>.
</p>


<h3>See Also</h3>

<p>See Also <code><a href="#topic+plsRcox">plsRcox</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(micro.censure)
data(Xmicro.censure_compl_imp)
set.seed(123456)
X_train_micro &lt;- apply((as.matrix(Xmicro.censure_compl_imp)),FUN="as.numeric",MARGIN=2)[1:80,]
X_train_micro_df &lt;- data.frame(X_train_micro)
Y_train_micro &lt;- micro.censure$survyear[1:80]
C_train_micro &lt;- micro.censure$DC[1:80]

#Should be run with a higher value of nt (at least 10)
(cv.plsRcox.res=cv.plsRcox(list(x=X_train_micro,time=Y_train_micro,status=C_train_micro),nt=3))

</code></pre>

<hr>
<h2 id='DKplsRcox'>Partial least squares Regression generalized linear models</h2><span id='topic+DKplsRcox'></span><span id='topic+DKplsRcoxmodel.default'></span><span id='topic+DKplsRcoxmodel.formula'></span><span id='topic+DKplsRcoxmodel'></span>

<h3>Description</h3>

<p>This function implements an extension of Partial least squares Regression to
Cox Models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DKplsRcox(Xplan, ...)

DKplsRcoxmodel(Xplan, ...)

## Default S3 method:
DKplsRcoxmodel(
  Xplan,
  time,
  time2,
  event,
  type,
  origin,
  typeres = "deviance",
  collapse,
  weighted,
  scaleX = TRUE,
  scaleY = TRUE,
  nt = min(2, ncol(Xplan)),
  limQ2set = 0.0975,
  dataPredictY = Xplan,
  pvals.expli = FALSE,
  alpha.pvals.expli = 0.05,
  tol_Xi = 10^(-12),
  weights,
  control,
  sparse = FALSE,
  sparseStop = TRUE,
  plot = FALSE,
  allres = FALSE,
  kernel = "rbfdot",
  hyperkernel,
  verbose = TRUE,
  ...
)

## S3 method for class 'formula'
DKplsRcoxmodel(
  Xplan,
  time,
  time2,
  event,
  type,
  origin,
  typeres = "deviance",
  collapse,
  weighted,
  scaleX = TRUE,
  scaleY = NULL,
  dataXplan = NULL,
  nt = min(2, ncol(Xplan)),
  limQ2set = 0.0975,
  dataPredictY = Xplan,
  pvals.expli = FALSE,
  model_frame = FALSE,
  alpha.pvals.expli = 0.05,
  tol_Xi = 10^(-12),
  weights,
  subset,
  control,
  sparse = FALSE,
  sparseStop = TRUE,
  plot = FALSE,
  allres = FALSE,
  kernel = "rbfdot",
  hyperkernel,
  verbose = TRUE,
  model_matrix = FALSE,
  contrasts.arg = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DKplsRcox_+3A_xplan">Xplan</code></td>
<td>
<p>a formula or a matrix with the eXplanatory variables (training)
dataset</p>
</td></tr>
<tr><td><code id="DKplsRcox_+3A_...">...</code></td>
<td>
<p>arguments to pass to <code>plsRmodel.default</code> or to
<code>plsRmodel.formula</code></p>
</td></tr>
<tr><td><code id="DKplsRcox_+3A_time">time</code></td>
<td>
<p>for right censored data, this is the follow up time. For
interval data, the first argument is the starting time for the interval.</p>
</td></tr>
<tr><td><code id="DKplsRcox_+3A_time2">time2</code></td>
<td>
<p>The status indicator, normally 0=alive, 1=dead. Other choices
are <code>TRUE/FALSE</code> (<code>TRUE</code> = death) or 1/2 (2=death). For interval
censored data, the status indicator is 0=right censored, 1=event at
<code>time</code>, 2=left censored, 3=interval censored. Although unusual, the
event indicator can be omitted, in which case all subjects are assumed to
have an event.</p>
</td></tr>
<tr><td><code id="DKplsRcox_+3A_event">event</code></td>
<td>
<p>ending time of the interval for interval censored or counting
process data only. Intervals are assumed to be open on the left and closed
on the right, <code>(start, end]</code>. For counting process data, event
indicates whether an event occurred at the end of the interval.</p>
</td></tr>
<tr><td><code id="DKplsRcox_+3A_type">type</code></td>
<td>
<p>character string specifying the type of censoring. Possible
values are <code>"right"</code>, <code>"left"</code>, <code>"counting"</code>,
<code>"interval"</code>, or <code>"interval2"</code>. The default is <code>"right"</code> or
<code>"counting"</code> depending on whether the <code>time2</code> argument is absent
or present, respectively.</p>
</td></tr>
<tr><td><code id="DKplsRcox_+3A_origin">origin</code></td>
<td>
<p>for counting process data, the hazard function origin. This
option was intended to be used in conjunction with a model containing time
dependent strata in order to align the subjects properly when they cross
over from one strata to another, but it has rarely proven useful.</p>
</td></tr>
<tr><td><code id="DKplsRcox_+3A_typeres">typeres</code></td>
<td>
<p>character string indicating the type of residual desired.
Possible values are <code>"martingale"</code>, <code>"deviance"</code>, <code>"score"</code>,
<code>"schoenfeld"</code>, <code>"dfbeta"</code>, <code>"dfbetas"</code>, and
<code>"scaledsch"</code>. Only enough of the string to determine a unique match is
required.</p>
</td></tr>
<tr><td><code id="DKplsRcox_+3A_collapse">collapse</code></td>
<td>
<p>vector indicating which rows to collapse (sum) over. In
time-dependent models more than one row data can pertain to a single
individual. If there were 4 individuals represented by 3, 1, 2 and 4 rows of
data respectively, then <code>collapse=c(1,1,1,2,3,3,4,4,4,4)</code> could be used
to obtain per subject rather than per observation residuals.</p>
</td></tr>
<tr><td><code id="DKplsRcox_+3A_weighted">weighted</code></td>
<td>
<p>if <code>TRUE</code> and the model was fit with case weights, then
the weighted residuals are returned.</p>
</td></tr>
<tr><td><code id="DKplsRcox_+3A_scalex">scaleX</code></td>
<td>
<p>Should the <code>Xplan</code> columns be standardized ?</p>
</td></tr>
<tr><td><code id="DKplsRcox_+3A_scaley">scaleY</code></td>
<td>
<p>Should the <code>time</code> values be standardized ?</p>
</td></tr>
<tr><td><code id="DKplsRcox_+3A_nt">nt</code></td>
<td>
<p>number of components to be extracted</p>
</td></tr>
<tr><td><code id="DKplsRcox_+3A_limq2set">limQ2set</code></td>
<td>
<p>limit value for the Q2</p>
</td></tr>
<tr><td><code id="DKplsRcox_+3A_datapredicty">dataPredictY</code></td>
<td>
<p>predictor(s) (testing) dataset</p>
</td></tr>
<tr><td><code id="DKplsRcox_+3A_pvals.expli">pvals.expli</code></td>
<td>
<p>should individual p-values be reported to tune model
selection ?</p>
</td></tr>
<tr><td><code id="DKplsRcox_+3A_alpha.pvals.expli">alpha.pvals.expli</code></td>
<td>
<p>level of significance for predictors when
pvals.expli=TRUE</p>
</td></tr>
<tr><td><code id="DKplsRcox_+3A_tol_xi">tol_Xi</code></td>
<td>
<p>minimal value for Norm2(Xi) and <code class="reqn">\mathrm{det}(pp' \times
pp)</code> if there is any missing value in the <code>dataX</code>. It
defaults to <code class="reqn">10^{-12}</code></p>
</td></tr>
<tr><td><code id="DKplsRcox_+3A_weights">weights</code></td>
<td>
<p>an optional vector of 'prior weights' to be used in the
fitting process. Should be <code>NULL</code> or a numeric vector.</p>
</td></tr>
<tr><td><code id="DKplsRcox_+3A_control">control</code></td>
<td>
<p>a list of parameters for controlling the fitting process. For
<code>glm.fit</code> this is passed to <code><a href="stats.html#topic+glm.control">glm.control</a></code>.</p>
</td></tr>
<tr><td><code id="DKplsRcox_+3A_sparse">sparse</code></td>
<td>
<p>should the coefficients of non-significant predictors
(&lt;<code>alpha.pvals.expli</code>) be set to 0</p>
</td></tr>
<tr><td><code id="DKplsRcox_+3A_sparsestop">sparseStop</code></td>
<td>
<p>should component extraction stop when no significant
predictors (&lt;<code>alpha.pvals.expli</code>) are found</p>
</td></tr>
<tr><td><code id="DKplsRcox_+3A_plot">plot</code></td>
<td>
<p>Should the survival function be plotted ?)</p>
</td></tr>
<tr><td><code id="DKplsRcox_+3A_allres">allres</code></td>
<td>
<p>FALSE to return only the Cox model and TRUE for additionnal
results. See details. Defaults to FALSE.</p>
</td></tr>
<tr><td><code id="DKplsRcox_+3A_kernel">kernel</code></td>
<td>
<p>the kernel function used in training and predicting. This
parameter can be set to any function, of class kernel, which computes the
inner product in feature space between two vector arguments (see
<a href="kernlab.html#topic+kernels">kernels</a>). The <code>kernlab</code> package provides the most
popular kernel functions which can be used by setting the kernel parameter
to the following strings: </p>
 <dl>
<dt>list(&quot;rbfdot&quot;)</dt><dd><p>Radial Basis
kernel &quot;Gaussian&quot;</p>
</dd> <dt>list(&quot;polydot&quot;)</dt><dd><p>Polynomial kernel</p>
</dd>
<dt>list(&quot;vanilladot&quot;)</dt><dd><p>Linear kernel</p>
</dd> <dt>list(&quot;tanhdot&quot;)</dt><dd><p>Hyperbolic
tangent kernel</p>
</dd> <dt>list(&quot;laplacedot&quot;)</dt><dd><p>Laplacian kernel</p>
</dd>
<dt>list(&quot;besseldot&quot;)</dt><dd><p>Bessel kernel</p>
</dd> <dt>list(&quot;anovadot&quot;)</dt><dd><p>ANOVA RBF
kernel</p>
</dd> <dt>list(&quot;splinedot&quot;)</dt><dd><p>Spline kernel</p>
</dd> </dl>
</td></tr>
<tr><td><code id="DKplsRcox_+3A_hyperkernel">hyperkernel</code></td>
<td>
<p>the list of hyper-parameters (kernel parameters). This is
a list which contains the parameters to be used with the kernel function.
For valid parameters for existing kernels are : </p>
 <ul>
<li>
<p><code>sigma</code>, inverse kernel width for the Radial Basis kernel function
&quot;rbfdot&quot; and the Laplacian kernel &quot;laplacedot&quot;.  </p>
</li>
<li> <p><code>degree</code>,
<code>scale</code>, <code>offset</code> for the Polynomial kernel &quot;polydot&quot;.  </p>
</li>
<li>
<p><code>scale</code>, offset for the Hyperbolic tangent kernel function &quot;tanhdot&quot;.
</p>
</li>
<li> <p><code>sigma</code>, <code>order</code>, <code>degree</code> for the Bessel kernel
&quot;besseldot&quot;.  </p>
</li>
<li> <p><code>sigma</code>, <code>degree</code> for the ANOVA kernel
&quot;anovadot&quot;.  </p>
</li></ul>
<p> In the case of a Radial Basis kernel function (Gaussian) or
Laplacian kernel, if <code>hyperkernel</code> is missing, the heuristics in sigest
are used to calculate a good sigma value from the data.</p>
</td></tr>
<tr><td><code id="DKplsRcox_+3A_verbose">verbose</code></td>
<td>
<p>Should some details be displayed ?</p>
</td></tr>
<tr><td><code id="DKplsRcox_+3A_dataxplan">dataXplan</code></td>
<td>
<p>an optional data frame, list or environment (or object
coercible by <code><a href="base.html#topic+as.data.frame">as.data.frame</a></code> to a data frame) containing the
variables in the model. If not found in <code>dataXplan</code>, the variables are
taken from <code>environment(Xplan)</code>, typically the environment from which
<code>coxDKplsDR</code> is called.</p>
</td></tr>
<tr><td><code id="DKplsRcox_+3A_model_frame">model_frame</code></td>
<td>
<p>If <code>TRUE</code>, the model frame is returned.</p>
</td></tr>
<tr><td><code id="DKplsRcox_+3A_subset">subset</code></td>
<td>
<p>an optional vector specifying a subset of observations to be
used in the fitting process.</p>
</td></tr>
<tr><td><code id="DKplsRcox_+3A_model_matrix">model_matrix</code></td>
<td>
<p>If <code>TRUE</code>, the model matrix is returned.</p>
</td></tr>
<tr><td><code id="DKplsRcox_+3A_contrasts.arg">contrasts.arg</code></td>
<td>
<p>a list, whose entries are values (numeric matrices, 
functions or character strings naming functions) to be used as replacement 
values for the contrasts replacement function and whose names are the names 
of columns of data containing factors.</p>
</td></tr>
<tr><td><code id="DKplsRcox_+3A_method">method</code></td>
<td>
<p>the method to be used in fitting the model. The default method
<code>"glm.fit"</code> uses iteratively reweighted least squares (IWLS).
User-supplied fitting functions can be supplied either as a function or a
character string naming a function, with a function which takes the same
arguments as <code>glm.fit</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A typical predictor has the form response ~ terms where response is the
(numeric) response vector and terms is a series of terms which specifies a
linear predictor for response. A terms specification of the form first +
second indicates all the terms in first together with all the terms in
second with any duplicates removed.
</p>
<p>A specification of the form first:second indicates the the set of terms
obtained by taking the interactions of all terms in first with all terms in
second. The specification first*second indicates the cross of first and
second. This is the same as first + second + first:second.
</p>
<p>The terms in the formula will be re-ordered so that main effects come first,
followed by the interactions, all second-order, all third-order and so on:
to avoid this pass a terms object as the formula.
</p>
<p>Non-NULL weights can be used to indicate that different observations have
different dispersions (with the values in weights being inversely
proportional to the dispersions); or equivalently, when the elements of
weights are positive integers w_i, that each response y_i is the mean of w_i
unit-weight observations.
</p>


<h3>Value</h3>

<p>Depends on the model that was used to fit the model.
</p>


<h3>Author(s)</h3>

<p>Frédéric Bertrand<br />
<a href="mailto:frederic.bertrand@utt.fr">frederic.bertrand@utt.fr</a><br />
<a href="http://www-irma.u-strasbg.fr/~fbertran/">http://www-irma.u-strasbg.fr/~fbertran/</a>
</p>


<h3>References</h3>

<p>plsRcox, Cox-Models in a high dimensional setting in R, Frederic
Bertrand, Philippe Bastien, Nicolas Meyer and Myriam Maumy-Bertrand (2014).
Proceedings of User2014!, Los Angeles, page 152.<br />
</p>
<p>Deviance residuals-based sparse PLS and sparse kernel PLS regression for
censored data, Philippe Bastien, Frederic Bertrand, Nicolas Meyer and Myriam
Maumy-Bertrand (2015), Bioinformatics, 31(3):397-404,
doi:10.1093/bioinformatics/btu660.
</p>


<h3>See Also</h3>

<p><code><a href="plsRglm.html#topic+plsR">plsR</a></code> and <code><a href="plsRglm.html#topic+plsRglm">plsRglm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(micro.censure)
data(Xmicro.censure_compl_imp)

X_train_micro &lt;- apply((as.matrix(Xmicro.censure_compl_imp)),FUN="as.numeric",MARGIN=2)[1:80,]
X_train_micro_df &lt;- data.frame(X_train_micro)
Y_train_micro &lt;- micro.censure$survyear[1:80]
C_train_micro &lt;- micro.censure$DC[1:80]


DKplsRcox(X_train_micro,time=Y_train_micro,event=C_train_micro,nt=5)
DKplsRcox(~X_train_micro,time=Y_train_micro,event=C_train_micro,nt=5)



DKplsRcox(Xplan=X_train_micro,time=Y_train_micro,event=C_train_micro,nt=5,sparse=TRUE, 
alpha.pvals.expli=.15)
DKplsRcox(Xplan=~X_train_micro,time=Y_train_micro,event=C_train_micro,nt=5,sparse=TRUE,
alpha.pvals.expli=.15)


</code></pre>

<hr>
<h2 id='DR_coxph'>(Deviance) Residuals Computation</h2><span id='topic+DR_coxph'></span>

<h3>Description</h3>

<p>This function computes the Residuals for a Cox-Model fitted with an
intercept as the only explanatory variable. Default behaviour gives the
Deviance residuals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DR_coxph(
  time,
  time2,
  event,
  type,
  origin,
  typeres = "deviance",
  collapse,
  weighted,
  scaleY = TRUE,
  plot = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DR_coxph_+3A_time">time</code></td>
<td>
<p>for right censored data, this is the follow up time. For
interval data, the first argument is the starting time for the interval.</p>
</td></tr>
<tr><td><code id="DR_coxph_+3A_time2">time2</code></td>
<td>
<p>The status indicator, normally 0=alive, 1=dead. Other choices
are <code>TRUE/FALSE</code> (<code>TRUE</code> = death) or 1/2 (2=death). For interval
censored data, the status indicator is 0=right censored, 1=event at
<code>time</code>, 2=left censored, 3=interval censored. Although unusual, the
event indicator can be omitted, in which case all subjects are assumed to
have an event.</p>
</td></tr>
<tr><td><code id="DR_coxph_+3A_event">event</code></td>
<td>
<p>ending time of the interval for interval censored or counting
process data only. Intervals are assumed to be open on the left and closed
on the right, <code>(start, end]</code>. For counting process data, event
indicates whether an event occurred at the end of the interval.</p>
</td></tr>
<tr><td><code id="DR_coxph_+3A_type">type</code></td>
<td>
<p>character string specifying the type of censoring. Possible
values are <code>"right"</code>, <code>"left"</code>, <code>"counting"</code>,
<code>"interval"</code>, or <code>"interval2"</code>. The default is <code>"right"</code> or
<code>"counting"</code> depending on whether the <code>time2</code> argument is absent
or present, respectively.</p>
</td></tr>
<tr><td><code id="DR_coxph_+3A_origin">origin</code></td>
<td>
<p>for counting process data, the hazard function origin. This
option was intended to be used in conjunction with a model containing time
dependent strata in order to align the subjects properly when they cross
over from one strata to another, but it has rarely proven useful.</p>
</td></tr>
<tr><td><code id="DR_coxph_+3A_typeres">typeres</code></td>
<td>
<p>character string indicating the type of residual desired.
Possible values are <code>"martingale"</code>, <code>"deviance"</code>, <code>"score"</code>,
<code>"schoenfeld"</code>, <code>"dfbeta"</code>, <code>"dfbetas"</code>, and
<code>"scaledsch"</code>. Only enough of the string to determine a unique match is
required.</p>
</td></tr>
<tr><td><code id="DR_coxph_+3A_collapse">collapse</code></td>
<td>
<p>vector indicating which rows to collapse (sum) over. In
time-dependent models more than one row data can pertain to a single
individual. If there were 4 individuals represented by 3, 1, 2 and 4 rows of
data respectively, then <code>collapse=c(1,1,1,2,3,3,4,4,4,4)</code> could be used
to obtain per subject rather than per observation residuals.</p>
</td></tr>
<tr><td><code id="DR_coxph_+3A_weighted">weighted</code></td>
<td>
<p>if <code>TRUE</code> and the model was fit with case weights, then
the weighted residuals are returned.</p>
</td></tr>
<tr><td><code id="DR_coxph_+3A_scaley">scaleY</code></td>
<td>
<p>Should the <code>time</code> values be standardized ?</p>
</td></tr>
<tr><td><code id="DR_coxph_+3A_plot">plot</code></td>
<td>
<p>Should the survival function be plotted ?)</p>
</td></tr>
<tr><td><code id="DR_coxph_+3A_...">...</code></td>
<td>
<p>Arguments to be passed on to <code>survival::coxph</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>Named num</code></td>
<td>
<p>Vector of the residual values.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Frédéric Bertrand<br />
<a href="mailto:frederic.bertrand@utt.fr">frederic.bertrand@utt.fr</a><br />
<a href="http://www-irma.u-strasbg.fr/~fbertran/">http://www-irma.u-strasbg.fr/~fbertran/</a>
</p>


<h3>References</h3>

<p>plsRcox, Cox-Models in a high dimensional setting in R, Frederic
Bertrand, Philippe Bastien, Nicolas Meyer and Myriam Maumy-Bertrand (2014).
Proceedings of User2014!, Los Angeles, page 152.<br />
</p>
<p>Deviance residuals-based sparse PLS and sparse kernel PLS regression for
censored data, Philippe Bastien, Frederic Bertrand, Nicolas Meyer and Myriam
Maumy-Bertrand (2015), Bioinformatics, 31(3):397-404,
doi:10.1093/bioinformatics/btu660.
</p>


<h3>See Also</h3>

<p><code><a href="survival.html#topic+coxph">coxph</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(micro.censure)
Y_train_micro &lt;- micro.censure$survyear[1:80]
C_train_micro &lt;- micro.censure$DC[1:80]

DR_coxph(Y_train_micro,C_train_micro,plot=TRUE)
DR_coxph(Y_train_micro,C_train_micro,scaleY=FALSE,plot=TRUE)
DR_coxph(Y_train_micro,C_train_micro,scaleY=TRUE,plot=TRUE)

rm(Y_train_micro,C_train_micro)

</code></pre>

<hr>
<h2 id='internal-plsRcox'>Internal plsRcox functions</h2><span id='topic+internal-plsRcox'></span><span id='topic+getIndic'></span><span id='topic+getIndicCV'></span><span id='topic+getIndicCViAUCSH'></span><span id='topic+getIndicCViAUCSurvROCTest'></span><span id='topic+correctp.cox'></span><span id='topic+spls.cox'></span><span id='topic+ust'></span><span id='topic+spls.dv'></span><span id='topic+pls.cox'></span><span id='topic+predict.pls.cox'></span>

<h3>Description</h3>

<p>These are not to be called by the user.
</p>


<h3>Author(s)</h3>

<p>Frédéric Bertrand<br />
<a href="mailto:frederic.bertrand@utt.fr">frederic.bertrand@utt.fr</a><br />
<a href="http://www-irma.u-strasbg.fr/~fbertran/">http://www-irma.u-strasbg.fr/~fbertran/</a>
</p>


<h3>References</h3>

<p>plsRcox, Cox-Models in a high dimensional setting in R, Frederic
Bertrand, Philippe Bastien, Nicolas Meyer and Myriam Maumy-Bertrand (2014).
Proceedings of User2014!, Los Angeles, page 152.<br />
</p>
<p>Deviance residuals-based sparse PLS and sparse kernel PLS regression for
censored data, Philippe Bastien, Frederic Bertrand, Nicolas Meyer and Myriam
Maumy-Bertrand (2015), Bioinformatics, 31(3):397-404,
doi:10.1093/bioinformatics/btu660.
</p>

<hr>
<h2 id='larsDR_coxph'>Fitting a LASSO/LARS model on the (Deviance) Residuals</h2><span id='topic+larsDR_coxph'></span><span id='topic+larsDR_coxph.default'></span><span id='topic+larsDR_coxph.formula'></span>

<h3>Description</h3>

<p>This function computes the Cox Model based on lars variables computed model
with </p>
 <ul>
<li><p> as the response: the Residuals of a Cox-Model fitted
with no covariate </p>
</li>
<li><p> as explanatory variables: Xplan.  </p>
</li></ul>
<p> It uses the
package <code>lars</code> to perform PLSR fit.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>larsDR_coxph(Xplan, ...)

## Default S3 method:
larsDR_coxph(
  Xplan,
  time,
  time2,
  event,
  type,
  origin,
  typeres = "deviance",
  collapse,
  weighted,
  scaleX = FALSE,
  scaleY = TRUE,
  plot = FALSE,
  typelars = "lasso",
  normalize = TRUE,
  max.steps,
  use.Gram = TRUE,
  allres = FALSE,
  verbose = TRUE,
  ...
)

## S3 method for class 'formula'
larsDR_coxph(
  Xplan,
  time,
  time2,
  event,
  type,
  origin,
  typeres = "deviance",
  collapse,
  weighted,
  scaleX = FALSE,
  scaleY = TRUE,
  plot = FALSE,
  typelars = "lasso",
  normalize = TRUE,
  max.steps,
  use.Gram = TRUE,
  allres = FALSE,
  dataXplan = NULL,
  subset,
  weights,
  model_frame = FALSE,
  model_matrix = FALSE,
  verbose = TRUE,
  contrasts.arg = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="larsDR_coxph_+3A_xplan">Xplan</code></td>
<td>
<p>a formula or a matrix with the eXplanatory variables (training)
dataset</p>
</td></tr>
<tr><td><code id="larsDR_coxph_+3A_...">...</code></td>
<td>
<p>Arguments to be passed on to <code>survival::coxph</code> or to
<code>lars::lars</code>.</p>
</td></tr>
<tr><td><code id="larsDR_coxph_+3A_time">time</code></td>
<td>
<p>for right censored data, this is the follow up time. For
interval data, the first argument is the starting time for the interval.</p>
</td></tr>
<tr><td><code id="larsDR_coxph_+3A_time2">time2</code></td>
<td>
<p>The status indicator, normally 0=alive, 1=dead. Other choices
are <code>TRUE/FALSE</code> (<code>TRUE</code> = death) or 1/2 (2=death). For interval
censored data, the status indicator is 0=right censored, 1=event at
<code>time</code>, 2=left censored, 3=interval censored. Although unusual, the
event indicator can be omitted, in which case all subjects are assumed to
have an event.</p>
</td></tr>
<tr><td><code id="larsDR_coxph_+3A_event">event</code></td>
<td>
<p>ending time of the interval for interval censored or counting
process data only. Intervals are assumed to be open on the left and closed
on the right, <code>(start, end]</code>. For counting process data, event
indicates whether an event occurred at the end of the interval.</p>
</td></tr>
<tr><td><code id="larsDR_coxph_+3A_type">type</code></td>
<td>
<p>character string specifying the type of censoring. Possible
values are <code>"right"</code>, <code>"left"</code>, <code>"counting"</code>,
<code>"interval"</code>, or <code>"interval2"</code>. The default is <code>"right"</code> or
<code>"counting"</code> depending on whether the <code>time2</code> argument is absent
or present, respectively.</p>
</td></tr>
<tr><td><code id="larsDR_coxph_+3A_origin">origin</code></td>
<td>
<p>for counting process data, the hazard function origin. This
option was intended to be used in conjunction with a model containing time
dependent strata in order to align the subjects properly when they cross
over from one strata to another, but it has rarely proven useful.</p>
</td></tr>
<tr><td><code id="larsDR_coxph_+3A_typeres">typeres</code></td>
<td>
<p>character string indicating the type of residual desired.
Possible values are <code>"martingale"</code>, <code>"deviance"</code>, <code>"score"</code>,
<code>"schoenfeld"</code>, <code>"dfbeta"</code>, <code>"dfbetas"</code>, and
<code>"scaledsch"</code>. Only enough of the string to determine a unique match is
required.</p>
</td></tr>
<tr><td><code id="larsDR_coxph_+3A_collapse">collapse</code></td>
<td>
<p>vector indicating which rows to collapse (sum) over. In
time-dependent models more than one row data can pertain to a single
individual. If there were 4 individuals represented by 3, 1, 2 and 4 rows of
data respectively, then <code>collapse=c(1,1,1,2,3,3,4,4,4,4)</code> could be used
to obtain per subject rather than per observation residuals.</p>
</td></tr>
<tr><td><code id="larsDR_coxph_+3A_weighted">weighted</code></td>
<td>
<p>if <code>TRUE</code> and the model was fit with case weights, then
the weighted residuals are returned.</p>
</td></tr>
<tr><td><code id="larsDR_coxph_+3A_scalex">scaleX</code></td>
<td>
<p>Should the <code>Xplan</code> columns be standardized ?</p>
</td></tr>
<tr><td><code id="larsDR_coxph_+3A_scaley">scaleY</code></td>
<td>
<p>Should the <code>time</code> values be standardized ?</p>
</td></tr>
<tr><td><code id="larsDR_coxph_+3A_plot">plot</code></td>
<td>
<p>Should the survival function be plotted ?)</p>
</td></tr>
<tr><td><code id="larsDR_coxph_+3A_typelars">typelars</code></td>
<td>
<p>One of <code>"lasso"</code>, <code>"lar"</code>,
<code>"forward.stagewise"</code> or <code>"stepwise"</code>. The names can be
abbreviated to any unique substring. Default is <code>"lasso"</code>.</p>
</td></tr>
<tr><td><code id="larsDR_coxph_+3A_normalize">normalize</code></td>
<td>
<p>If TRUE, each variable is standardized to have unit L2
norm, otherwise it is left alone. Default is TRUE.</p>
</td></tr>
<tr><td><code id="larsDR_coxph_+3A_max.steps">max.steps</code></td>
<td>
<p>Limit the number of steps taken; the default is <code>8 *
min(m, n-intercept)</code>, with m the number of variables, and n the number of
samples. For <code>type="lar"</code> or <code>type="stepwise"</code>, the maximum number
of steps is <code>min(m,n-intercept)</code>. For <code>type="lasso"</code> and
especially <code>type="forward.stagewise"</code>, there can be many more terms,
because although no more than min(m,n-intercept) variables can be active
during any step, variables are frequently droppped and added as the
algorithm proceeds. Although the default usually guarantees that the
algorithm has proceeded to the saturated fit, users should check.</p>
</td></tr>
<tr><td><code id="larsDR_coxph_+3A_use.gram">use.Gram</code></td>
<td>
<p>When the number m of variables is very large, i.e. larger
than N, then you may not want LARS to precompute the Gram matrix. Default is
<code>use.Gram=TRUE</code></p>
</td></tr>
<tr><td><code id="larsDR_coxph_+3A_allres">allres</code></td>
<td>
<p>FALSE to return only the Cox model and TRUE for additionnal
results. See details. Defaults to FALSE.</p>
</td></tr>
<tr><td><code id="larsDR_coxph_+3A_verbose">verbose</code></td>
<td>
<p>Should some details be displayed ?</p>
</td></tr>
<tr><td><code id="larsDR_coxph_+3A_dataxplan">dataXplan</code></td>
<td>
<p>an optional data frame, list or environment (or object
coercible by <code><a href="base.html#topic+as.data.frame">as.data.frame</a></code> to a data frame) containing the
variables in the model. If not found in <code>dataXplan</code>, the variables are
taken from <code>environment(Xplan)</code>, typically the environment from which
<code>plscox</code> is called.</p>
</td></tr>
<tr><td><code id="larsDR_coxph_+3A_subset">subset</code></td>
<td>
<p>an optional vector specifying a subset of observations to be
used in the fitting process.</p>
</td></tr>
<tr><td><code id="larsDR_coxph_+3A_weights">weights</code></td>
<td>
<p>an optional vector of 'prior weights' to be used in the
fitting process. Should be <code>NULL</code> or a numeric vector.</p>
</td></tr>
<tr><td><code id="larsDR_coxph_+3A_model_frame">model_frame</code></td>
<td>
<p>If <code>TRUE</code>, the model frame is returned.</p>
</td></tr>
<tr><td><code id="larsDR_coxph_+3A_model_matrix">model_matrix</code></td>
<td>
<p>If <code>TRUE</code>, the model matrix is returned.</p>
</td></tr>
<tr><td><code id="larsDR_coxph_+3A_contrasts.arg">contrasts.arg</code></td>
<td>
<p>a list, whose entries are values (numeric matrices, 
functions or character strings naming functions) to be used as replacement 
values for the contrasts replacement function and whose names are the names 
of columns of data containing factors.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function computes the LASSO/LARS model with the Residuals of a
Cox-Model fitted with an intercept as the only explanatory variable as the
response and Xplan as explanatory variables. Default behaviour uses the
Deviance residuals.
</p>
<p>If <code>allres=FALSE</code> returns only the final Cox-model. If
<code>allres=TRUE</code> returns a list with the (Deviance) Residuals, the
LASSO/LARS model fitted to the (Deviance) Residuals, the eXplanatory
variables and the final Cox-model. <code>allres=TRUE</code> is useful for
evluating model prediction accuracy on a test sample.
</p>


<h3>Value</h3>

<p>If <code>allres=FALSE</code> : </p>
<table>
<tr><td><code>cox_larsDR</code></td>
<td>
<p>Final Cox-model.</p>
</td></tr></table>
<p> If
<code>allres=TRUE</code> : </p>
<table>
<tr><td><code>DR_coxph</code></td>
<td>
<p>The (Deviance) Residuals.</p>
</td></tr>
<tr><td><code>larsDR</code></td>
<td>
<p>The LASSO/LARS model fitted to the (Deviance) Residuals.</p>
</td></tr>
<tr><td><code>X_larsDR</code></td>
<td>
<p>The eXplanatory variables.</p>
</td></tr> <tr><td><code>cox_larsDR</code></td>
<td>
<p>Final
Cox-model.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Frédéric Bertrand<br />
<a href="mailto:frederic.bertrand@utt.fr">frederic.bertrand@utt.fr</a><br />
<a href="http://www-irma.u-strasbg.fr/~fbertran/">http://www-irma.u-strasbg.fr/~fbertran/</a>
</p>


<h3>References</h3>

<p>plsRcox, Cox-Models in a high dimensional setting in R, Frederic
Bertrand, Philippe Bastien, Nicolas Meyer and Myriam Maumy-Bertrand (2014).
Proceedings of User2014!, Los Angeles, page 152.<br />
</p>
<p>Deviance residuals-based sparse PLS and sparse kernel PLS regression for
censored data, Philippe Bastien, Frederic Bertrand, Nicolas Meyer and Myriam
Maumy-Bertrand (2015), Bioinformatics, 31(3):397-404,
doi:10.1093/bioinformatics/btu660.
</p>


<h3>See Also</h3>

<p><code><a href="survival.html#topic+coxph">coxph</a></code>, <code><a href="lars.html#topic+lars">lars</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(micro.censure)
data(Xmicro.censure_compl_imp)

X_train_micro &lt;- apply((as.matrix(Xmicro.censure_compl_imp)),FUN="as.numeric",MARGIN=2)[1:80,]
X_train_micro_df &lt;- data.frame(X_train_micro)
Y_train_micro &lt;- micro.censure$survyear[1:80]
C_train_micro &lt;- micro.censure$DC[1:80]

(cox_larsDR_fit &lt;- larsDR_coxph(X_train_micro,Y_train_micro,C_train_micro,max.steps=6,
use.Gram=FALSE,scaleX=TRUE))
(cox_larsDR_fit &lt;- larsDR_coxph(~X_train_micro,Y_train_micro,C_train_micro,max.steps=6,
use.Gram=FALSE,scaleX=TRUE))
(cox_larsDR_fit &lt;- larsDR_coxph(~.,Y_train_micro,C_train_micro,max.steps=6,
use.Gram=FALSE,scaleX=TRUE,dataXplan=X_train_micro_df))

larsDR_coxph(~X_train_micro,Y_train_micro,C_train_micro,max.steps=6,use.Gram=FALSE)
larsDR_coxph(~X_train_micro,Y_train_micro,C_train_micro,max.steps=6,use.Gram=FALSE,scaleX=FALSE)
larsDR_coxph(~X_train_micro,Y_train_micro,C_train_micro,max.steps=6,use.Gram=FALSE,
scaleX=TRUE,allres=TRUE)

rm(X_train_micro,Y_train_micro,C_train_micro,cox_larsDR_fit)

</code></pre>

<hr>
<h2 id='micro.censure'>Microsat features and survival times</h2><span id='topic+micro.censure'></span>

<h3>Description</h3>

<p>This dataset provides Microsat specifications and survival times.
</p>


<h3>Format</h3>

<p>A data frame with 117 observations on the following 43 variables.
</p>
 <dl>
<dt>numpat</dt><dd><p>a factor with levels <code>B1006</code>
<code>B1017</code> <code>B1028</code> <code>B1031</code> <code>B1046</code> <code>B1059</code>
<code>B1068</code> <code>B1071</code> <code>B1102</code> <code>B1115</code> <code>B1124</code>
<code>B1139</code> <code>B1157</code> <code>B1161</code> <code>B1164</code> <code>B1188</code>
<code>B1190</code> <code>B1192</code> <code>B1203</code> <code>B1211</code> <code>B1221</code>
<code>B1225</code> <code>B1226</code> <code>B1227</code> <code>B1237</code> <code>B1251</code>
<code>B1258</code> <code>B1266</code> <code>B1271</code> <code>B1282</code> <code>B1284</code>
<code>B1285</code> <code>B1286</code> <code>B1287</code> <code>B1290</code> <code>B1292</code>
<code>B1298</code> <code>B1302</code> <code>B1304</code> <code>B1310</code> <code>B1319</code>
<code>B1327</code> <code>B1353</code> <code>B1357</code> <code>B1363</code> <code>B1368</code>
<code>B1372</code> <code>B1373</code> <code>B1379</code> <code>B1388</code> <code>B1392</code>
<code>B1397</code> <code>B1403</code> <code>B1418</code> <code>B1421t1</code> <code>B1421t2</code>
<code>B1448</code> <code>B1451</code> <code>B1455</code> <code>B1460</code> <code>B1462</code>
<code>B1466</code> <code>B1469</code> <code>B1493</code> <code>B1500</code> <code>B1502</code>
<code>B1519</code> <code>B1523</code> <code>B1529</code> <code>B1530</code> <code>B1544</code>
<code>B1548</code> <code>B500</code> <code>B532</code> <code>B550</code> <code>B558</code> <code>B563</code>
<code>B582</code> <code>B605</code> <code>B609</code> <code>B634</code> <code>B652</code> <code>B667</code>
<code>B679</code> <code>B701</code> <code>B722</code> <code>B728</code> <code>B731</code> <code>B736</code>
<code>B739</code> <code>B744</code> <code>B766</code> <code>B771</code> <code>B777</code> <code>B788</code>
<code>B800</code> <code>B836</code> <code>B838</code> <code>B841</code> <code>B848</code> <code>B871</code>
<code>B873</code> <code>B883</code> <code>B889</code> <code>B912</code> <code>B924</code> <code>B925</code>
<code>B927</code> <code>B938</code> <code>B952</code> <code>B954</code> <code>B955</code> <code>B968</code>
<code>B972</code> <code>B976</code> <code>B982</code> <code>B984</code></p>
</dd> <dt>D18S61</dt><dd><p>a
numeric vector</p>
</dd> <dt>D17S794</dt><dd><p>a numeric vector</p>
</dd>
<dt>D13S173</dt><dd><p>a numeric vector</p>
</dd> <dt>D20S107</dt><dd><p>a numeric
vector</p>
</dd> <dt>TP53</dt><dd><p>a numeric vector</p>
</dd> <dt>D9S171</dt><dd><p>a
numeric vector</p>
</dd> <dt>D8S264</dt><dd><p>a numeric vector</p>
</dd>
<dt>D5S346</dt><dd><p>a numeric vector</p>
</dd> <dt>D22S928</dt><dd><p>a numeric
vector</p>
</dd> <dt>D18S53</dt><dd><p>a numeric vector</p>
</dd> <dt>D1S225</dt><dd><p>a
numeric vector</p>
</dd> <dt>D3S1282</dt><dd><p>a numeric vector</p>
</dd>
<dt>D15S127</dt><dd><p>a numeric vector</p>
</dd> <dt>D1S305</dt><dd><p>a numeric
vector</p>
</dd> <dt>D1S207</dt><dd><p>a numeric vector</p>
</dd> <dt>D2S138</dt><dd><p>a
numeric vector</p>
</dd> <dt>D16S422</dt><dd><p>a numeric vector</p>
</dd>
<dt>D9S179</dt><dd><p>a numeric vector</p>
</dd> <dt>D10S191</dt><dd><p>a numeric
vector</p>
</dd> <dt>D4S394</dt><dd><p>a numeric vector</p>
</dd> <dt>D1S197</dt><dd><p>a
numeric vector</p>
</dd> <dt>D6S264</dt><dd><p>a numeric vector</p>
</dd>
<dt>D14S65</dt><dd><p>a numeric vector</p>
</dd> <dt>D17S790</dt><dd><p>a numeric
vector</p>
</dd> <dt>D5S430</dt><dd><p>a numeric vector</p>
</dd> <dt>D3S1283</dt><dd><p>a
numeric vector</p>
</dd> <dt>D4S414</dt><dd><p>a numeric vector</p>
</dd>
<dt>D8S283</dt><dd><p>a numeric vector</p>
</dd> <dt>D11S916</dt><dd><p>a numeric
vector</p>
</dd> <dt>D2S159</dt><dd><p>a numeric vector</p>
</dd> <dt>D16S408</dt><dd><p>a
numeric vector</p>
</dd> <dt>D6S275</dt><dd><p>a numeric vector</p>
</dd>
<dt>D10S192</dt><dd><p>a numeric vector</p>
</dd> <dt>sexe</dt><dd><p>a numeric
vector</p>
</dd> <dt>Agediag</dt><dd><p>a numeric vector</p>
</dd> <dt>Siege</dt><dd><p>a
numeric vector</p>
</dd> <dt>T</dt><dd><p>a numeric vector</p>
</dd> <dt>N</dt><dd><p>a
numeric vector</p>
</dd> <dt>M</dt><dd><p>a numeric vector</p>
</dd> <dt>STADE</dt><dd><p>a
factor with levels <code>0</code> <code>1</code> <code>2</code> <code>3</code> <code>4</code></p>
</dd>
<dt>survyear</dt><dd><p>a numeric vector</p>
</dd> <dt>DC</dt><dd><p>a numeric
vector</p>
</dd> </dl>



<h3>Source</h3>

<p>Allelotyping identification of genomic alterations in rectal
chromosomally unstable tumors without preoperative treatment,
#' Benoît Romain, Agnès Neuville, Nicolas Meyer,
Cécile Brigand, Serge Rohr, Anne Schneider, Marie-Pierre Gaub
and Dominique Guenot, <em>BMC Cancer 2010</em>, 10:561,
doi:10.1186/1471-2407-10-561.
</p>


<h3>References</h3>

<p>plsRcox, Cox-Models in a high dimensional setting in R, Frederic
Bertrand, Philippe Bastien, Nicolas Meyer and Myriam Maumy-Bertrand (2014).
Proceedings of User2014!, Los Angeles, page 152.<br />
</p>
<p>Deviance residuals-based sparse PLS and sparse kernel PLS regression for
censored data, Philippe Bastien, Frederic Bertrand, Nicolas Meyer and Myriam
Maumy-Bertrand (2015), Bioinformatics, 31(3):397-404,
doi:10.1093/bioinformatics/btu660.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

data(micro.censure)
Y_train_micro &lt;- micro.censure$survyear[1:80]
C_train_micro &lt;- micro.censure$DC[1:80]
Y_test_micro &lt;- micro.censure$survyear[81:117]
C_test_micro &lt;- micro.censure$DC[81:117]
rm(Y_train_micro,C_train_micro,Y_test_micro,C_test_micro)


</code></pre>

<hr>
<h2 id='plsRcox'>Partial least squares Regression generalized linear models</h2><span id='topic+plsRcox'></span><span id='topic+plsRcoxmodel.default'></span><span id='topic+plsRcoxmodel.formula'></span><span id='topic+plsRcoxmodel'></span>

<h3>Description</h3>

<p>This function implements an extension of Partial least squares Regression to
Cox Models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plsRcox(Xplan, ...)

plsRcoxmodel(Xplan, ...)

## Default S3 method:
plsRcoxmodel(
  Xplan,
  time,
  time2,
  event,
  type,
  origin,
  typeres = "deviance",
  collapse,
  weighted,
  scaleX = TRUE,
  scaleY = TRUE,
  nt = min(2, ncol(Xplan)),
  limQ2set = 0.0975,
  dataPredictY = Xplan,
  pvals.expli = FALSE,
  alpha.pvals.expli = 0.05,
  tol_Xi = 10^(-12),
  weights,
  control,
  sparse = FALSE,
  sparseStop = TRUE,
  allres = TRUE,
  verbose = TRUE,
  ...
)

## S3 method for class 'formula'
plsRcoxmodel(
  Xplan,
  time,
  time2,
  event,
  type,
  origin,
  typeres = "deviance",
  collapse,
  weighted,
  scaleX = TRUE,
  scaleY = NULL,
  dataXplan = NULL,
  nt = min(2, ncol(Xplan)),
  limQ2set = 0.0975,
  dataPredictY = Xplan,
  pvals.expli = FALSE,
  model_frame = FALSE,
  alpha.pvals.expli = 0.05,
  tol_Xi = 10^(-12),
  weights,
  subset,
  control,
  sparse = FALSE,
  sparseStop = TRUE,
  allres = TRUE,
  verbose = TRUE,
  model_matrix = FALSE,
  contrasts.arg = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plsRcox_+3A_xplan">Xplan</code></td>
<td>
<p>a formula or a matrix with the eXplanatory variables (training)
dataset</p>
</td></tr>
<tr><td><code id="plsRcox_+3A_...">...</code></td>
<td>
<p>arguments to pass to <code>plsRmodel.default</code> or to
<code>plsRmodel.formula</code></p>
</td></tr>
<tr><td><code id="plsRcox_+3A_time">time</code></td>
<td>
<p>for right censored data, this is the follow up time. For
interval data, the first argument is the starting time for the interval.</p>
</td></tr>
<tr><td><code id="plsRcox_+3A_time2">time2</code></td>
<td>
<p>The status indicator, normally 0=alive, 1=dead. Other choices
are <code>TRUE/FALSE</code> (<code>TRUE</code> = death) or 1/2 (2=death). For interval
censored data, the status indicator is 0=right censored, 1=event at
<code>time</code>, 2=left censored, 3=interval censored. Although unusual, the
event indicator can be omitted, in which case all subjects are assumed to
have an event.</p>
</td></tr>
<tr><td><code id="plsRcox_+3A_event">event</code></td>
<td>
<p>ending time of the interval for interval censored or counting
process data only. Intervals are assumed to be open on the left and closed
on the right, <code>(start, end]</code>. For counting process data, event
indicates whether an event occurred at the end of the interval.</p>
</td></tr>
<tr><td><code id="plsRcox_+3A_type">type</code></td>
<td>
<p>character string specifying the type of censoring. Possible
values are <code>"right"</code>, <code>"left"</code>, <code>"counting"</code>,
<code>"interval"</code>, or <code>"interval2"</code>. The default is <code>"right"</code> or
<code>"counting"</code> depending on whether the <code>time2</code> argument is absent
or present, respectively.</p>
</td></tr>
<tr><td><code id="plsRcox_+3A_origin">origin</code></td>
<td>
<p>for counting process data, the hazard function origin. This
option was intended to be used in conjunction with a model containing time
dependent strata in order to align the subjects properly when they cross
over from one strata to another, but it has rarely proven useful.</p>
</td></tr>
<tr><td><code id="plsRcox_+3A_typeres">typeres</code></td>
<td>
<p>character string indicating the type of residual desired.
Possible values are <code>"martingale"</code>, <code>"deviance"</code>, <code>"score"</code>,
<code>"schoenfeld"</code>, <code>"dfbeta"</code>, <code>"dfbetas"</code>, and
<code>"scaledsch"</code>. Only enough of the string to determine a unique match is
required.</p>
</td></tr>
<tr><td><code id="plsRcox_+3A_collapse">collapse</code></td>
<td>
<p>vector indicating which rows to collapse (sum) over. In
time-dependent models more than one row data can pertain to a single
individual. If there were 4 individuals represented by 3, 1, 2 and 4 rows of
data respectively, then <code>collapse=c(1,1,1,2,3,3,4,4,4,4)</code> could be used
to obtain per subject rather than per observation residuals.</p>
</td></tr>
<tr><td><code id="plsRcox_+3A_weighted">weighted</code></td>
<td>
<p>if <code>TRUE</code> and the model was fit with case weights, then
the weighted residuals are returned.</p>
</td></tr>
<tr><td><code id="plsRcox_+3A_scalex">scaleX</code></td>
<td>
<p>Should the <code>Xplan</code> columns be standardized ?</p>
</td></tr>
<tr><td><code id="plsRcox_+3A_scaley">scaleY</code></td>
<td>
<p>Should the <code>time</code> values be standardized ?</p>
</td></tr>
<tr><td><code id="plsRcox_+3A_nt">nt</code></td>
<td>
<p>number of components to be extracted</p>
</td></tr>
<tr><td><code id="plsRcox_+3A_limq2set">limQ2set</code></td>
<td>
<p>limit value for the Q2</p>
</td></tr>
<tr><td><code id="plsRcox_+3A_datapredicty">dataPredictY</code></td>
<td>
<p>predictor(s) (testing) dataset</p>
</td></tr>
<tr><td><code id="plsRcox_+3A_pvals.expli">pvals.expli</code></td>
<td>
<p>should individual p-values be reported to tune model
selection ?</p>
</td></tr>
<tr><td><code id="plsRcox_+3A_alpha.pvals.expli">alpha.pvals.expli</code></td>
<td>
<p>level of significance for predictors when
pvals.expli=TRUE</p>
</td></tr>
<tr><td><code id="plsRcox_+3A_tol_xi">tol_Xi</code></td>
<td>
<p>minimal value for Norm2(Xi) and <code class="reqn">\mathrm{det}(pp' \times
pp)</code> if there is any missing value in the <code>dataX</code>. It
defaults to <code class="reqn">10^{-12}</code></p>
</td></tr>
<tr><td><code id="plsRcox_+3A_weights">weights</code></td>
<td>
<p>an optional vector of 'prior weights' to be used in the
fitting process. Should be <code>NULL</code> or a numeric vector.</p>
</td></tr>
<tr><td><code id="plsRcox_+3A_control">control</code></td>
<td>
<p>a list of parameters for controlling the fitting process. For
<code>glm.fit</code> this is passed to <code><a href="stats.html#topic+glm.control">glm.control</a></code>.</p>
</td></tr>
<tr><td><code id="plsRcox_+3A_sparse">sparse</code></td>
<td>
<p>should the coefficients of non-significant predictors
(&lt;<code>alpha.pvals.expli</code>) be set to 0</p>
</td></tr>
<tr><td><code id="plsRcox_+3A_sparsestop">sparseStop</code></td>
<td>
<p>should component extraction stop when no significant
predictors (&lt;<code>alpha.pvals.expli</code>) are found</p>
</td></tr>
<tr><td><code id="plsRcox_+3A_allres">allres</code></td>
<td>
<p>FALSE to return only the Cox model and TRUE for additionnal
results. See details. Defaults to FALSE.</p>
</td></tr>
<tr><td><code id="plsRcox_+3A_verbose">verbose</code></td>
<td>
<p>Should some details be displayed ?</p>
</td></tr>
<tr><td><code id="plsRcox_+3A_dataxplan">dataXplan</code></td>
<td>
<p>an optional data frame, list or environment (or object
coercible by <code><a href="base.html#topic+as.data.frame">as.data.frame</a></code> to a data frame) containing the
variables in the model. If not found in <code>dataXplan</code>, the variables are
taken from <code>environment(Xplan)</code>, typically the environment from which
<code>coxDKplsDR</code> is called.</p>
</td></tr>
<tr><td><code id="plsRcox_+3A_model_frame">model_frame</code></td>
<td>
<p>If <code>TRUE</code>, the model frame is returned.</p>
</td></tr>
<tr><td><code id="plsRcox_+3A_subset">subset</code></td>
<td>
<p>an optional vector specifying a subset of observations to be
used in the fitting process.</p>
</td></tr>
<tr><td><code id="plsRcox_+3A_model_matrix">model_matrix</code></td>
<td>
<p>If <code>TRUE</code>, the model matrix is returned.</p>
</td></tr>
<tr><td><code id="plsRcox_+3A_contrasts.arg">contrasts.arg</code></td>
<td>
<p>a list, whose entries are values (numeric matrices, 
functions or character strings naming functions) to be used as replacement 
values for the contrasts replacement function and whose names are the names 
of columns of data containing factors.</p>
</td></tr>
<tr><td><code id="plsRcox_+3A_method">method</code></td>
<td>
<p>the method to be used in fitting the model. The default method
<code>"glm.fit"</code> uses iteratively reweighted least squares (IWLS).
User-supplied fitting functions can be supplied either as a function or a
character string naming a function, with a function which takes the same
arguments as <code>glm.fit</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A typical predictor has the form response ~ terms where response is the
(numeric) response vector and terms is a series of terms which specifies a
linear predictor for response. A terms specification of the form first +
second indicates all the terms in first together with all the terms in
second with any duplicates removed.
</p>
<p>A specification of the form first:second indicates the the set of terms
obtained by taking the interactions of all terms in first with all terms in
second. The specification first*second indicates the cross of first and
second. This is the same as first + second + first:second.
</p>
<p>The terms in the formula will be re-ordered so that main effects come first,
followed by the interactions, all second-order, all third-order and so on:
to avoid this pass a terms object as the formula.
</p>
<p>Non-NULL weights can be used to indicate that different observations have
different dispersions (with the values in weights being inversely
proportional to the dispersions); or equivalently, when the elements of
weights are positive integers w_i, that each response y_i is the mean of w_i
unit-weight observations.
</p>


<h3>Value</h3>

<p>Depends on the model that was used to fit the model.
</p>


<h3>Author(s)</h3>

<p>Frédéric Bertrand<br />
<a href="mailto:frederic.bertrand@utt.fr">frederic.bertrand@utt.fr</a><br />
<a href="http://www-irma.u-strasbg.fr/~fbertran/">http://www-irma.u-strasbg.fr/~fbertran/</a>
</p>


<h3>References</h3>

<p>plsRcox, Cox-Models in a high dimensional setting in R, Frederic
Bertrand, Philippe Bastien, Nicolas Meyer and Myriam Maumy-Bertrand (2014).
Proceedings of User2014!, Los Angeles, page 152.<br />
</p>
<p>Deviance residuals-based sparse PLS and sparse kernel PLS regression for
censored data, Philippe Bastien, Frederic Bertrand, Nicolas Meyer and Myriam
Maumy-Bertrand (2015), Bioinformatics, 31(3):397-404,
doi:10.1093/bioinformatics/btu660.
</p>


<h3>See Also</h3>

<p><code><a href="plsRglm.html#topic+plsR">plsR</a></code> and <code><a href="plsRglm.html#topic+plsRglm">plsRglm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(micro.censure)
data(Xmicro.censure_compl_imp)

X_train_micro &lt;- apply((as.matrix(Xmicro.censure_compl_imp)),FUN="as.numeric",MARGIN=2)[1:80,]
X_train_micro_df &lt;- data.frame(X_train_micro)
Y_train_micro &lt;- micro.censure$survyear[1:80]
C_train_micro &lt;- micro.censure$DC[1:80]

plsRcox(X_train_micro,time=Y_train_micro,event=C_train_micro,nt=5)
plsRcox(~X_train_micro,time=Y_train_micro,event=C_train_micro,nt=5)

plsRcox(Xplan=X_train_micro,time=Y_train_micro,event=C_train_micro,nt=5,sparse=TRUE,
alpha.pvals.expli=.15)
plsRcox(Xplan=~X_train_micro,time=Y_train_micro,event=C_train_micro,nt=5,sparse=TRUE,
alpha.pvals.expli=.15)

</code></pre>

<hr>
<h2 id='plsRcox-package'>plsRcox-package: Partial Least Squares Regression for Cox Models and Related Techniques</h2><span id='topic+plsRcox-package'></span>

<h3>Description</h3>

<p>Provides Partial least squares Regression and various regular, sparse or kernel, techniques for fitting Cox models in high dimensional settings &lt;doi:10.1093/bioinformatics/btu660&gt;, Bastien, P., Bertrand, F., Meyer N., Maumy-Bertrand, M. (2015), Deviance residuals-based sparse PLS and sparse kernel PLS regression for censored data, Bioinformatics, 31(3):397-404. Cross validation criteria were studied in &lt;arXiv:1810.02962&gt;, Bertrand, F., Bastien, Ph. and Maumy-Bertrand, M. (2018), Cross validating extensions of kernel, sparse or regular partial least squares regression models to censored data.
</p>


<h3>References</h3>

<p>Bastien, P., Bertrand, F., Meyer N., Maumy-Bertrand, M. (2015), Deviance residuals-based sparse PLS and sparse kernel PLS regression for censored data, Bioinformatics, 31(3):397-404. &lt;doi:10.1093/bioinformatics/btu660&gt;. Cross validation criteria were studied in &lt;arXiv:1810.02962&gt;, Bertrand, F., Bastien, Ph. and Maumy-Bertrand, M. (2018), Cross validating extensions of kernel, sparse or regular partial least squares regression models to censored data.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># The original allelotyping dataset

library(plsRcox)
data(micro.censure)
Y_train_micro &lt;- micro.censure$survyear[1:80]
C_train_micro &lt;- micro.censure$DC[1:80]
Y_test_micro &lt;- micro.censure$survyear[81:117]
C_test_micro &lt;- micro.censure$DC[81:117]

data(Xmicro.censure_compl_imp)
X_train_micro &lt;- apply((as.matrix(Xmicro.censure_compl_imp)),
FUN="as.numeric",MARGIN=2)[1:80,]
X_train_micro_df &lt;- data.frame(X_train_micro)

# coxsplsDR
cox_splsDR_fit=coxsplsDR(X_train_micro,Y_train_micro,C_train_micro,
ncomp=6,eta=.5)
cox_splsDR_fit
cox_splsDR_fit2=coxsplsDR(~X_train_micro,Y_train_micro,C_train_micro,
ncomp=6,eta=.5,trace=TRUE)
cox_splsDR_fit2
cox_splsDR_fit3=coxsplsDR(~.,Y_train_micro,C_train_micro,ncomp=6,
dataXplan=X_train_micro_df,eta=.5)
cox_splsDR_fit3
rm(cox_splsDR_fit,cox_splsDR_fit2,cox_splsDR_fit3)

</code></pre>

<hr>
<h2 id='predict.plsRcoxmodel'>Print method for plsRcox models</h2><span id='topic+predict.plsRcoxmodel'></span>

<h3>Description</h3>

<p>This function provides a predict method for the class <code>"plsRcoxmodel"</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'plsRcoxmodel'
predict(
  object,
  newdata,
  comps = object$computed_nt,
  type = c("lp", "risk", "expected", "terms", "scores"),
  se.fit = FALSE,
  weights,
  methodNA = "adaptative",
  verbose = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.plsRcoxmodel_+3A_object">object</code></td>
<td>
<p>An object of the class <code>"plsRcoxmodel"</code>.</p>
</td></tr>
<tr><td><code id="predict.plsRcoxmodel_+3A_newdata">newdata</code></td>
<td>
<p>An optional data frame in which to look for variables with
which to predict. If omitted, the fitted values are used.</p>
</td></tr>
<tr><td><code id="predict.plsRcoxmodel_+3A_comps">comps</code></td>
<td>
<p>A value with a single value of component to use for prediction.</p>
</td></tr>
<tr><td><code id="predict.plsRcoxmodel_+3A_type">type</code></td>
<td>
<p>Type of predicted value. Choices are the linear predictor
(&quot;<code>lp</code>&quot;), the risk score exp(lp) (&quot;<code>risk</code>&quot;), the expected number
of events given the covariates and follow-up time (&quot;<code>expected</code>&quot;), the
terms of the linear predictor (&quot;<code>terms</code>&quot;) or the scores
(&quot;<code>scores</code>&quot;).</p>
</td></tr>
<tr><td><code id="predict.plsRcoxmodel_+3A_se.fit">se.fit</code></td>
<td>
<p>If TRUE, pointwise standard errors are produced for the
predictions using the Cox model.</p>
</td></tr>
<tr><td><code id="predict.plsRcoxmodel_+3A_weights">weights</code></td>
<td>
<p>Vector of case weights. If <code>weights</code> is a vector of
integers, then the estimated coefficients are equivalent to estimating the
model from data with the individual <code>cases</code> replicated as many times as
indicated by <code>weights</code>.</p>
</td></tr>
<tr><td><code id="predict.plsRcoxmodel_+3A_methodna">methodNA</code></td>
<td>
<p>Selects the way of predicting the response or the scores of
the new data. For complete rows, without any missing value, there are two
different ways of computing the prediction. As a consequence, for mixed
datasets, with complete and incomplete rows, there are two ways of computing
prediction : either predicts any row as if there were missing values in it
(<code>missingdata</code>) or selects the prediction method accordingly to the
completeness of the row (<code>adaptative</code>).</p>
</td></tr>
<tr><td><code id="predict.plsRcoxmodel_+3A_verbose">verbose</code></td>
<td>
<p>Should some details be displayed ?</p>
</td></tr>
<tr><td><code id="predict.plsRcoxmodel_+3A_...">...</code></td>
<td>
<p>Arguments to be passed on to <code>survival::coxph</code> and to
<code>plsRglm::PLS_lm</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>When type is &quot;<code>response</code>&quot;, a matrix of predicted response
values is returned.<br /> When type is &quot;<code>scores</code>&quot;, a score matrix is
returned.
</p>


<h3>Author(s)</h3>

<p>Frédéric Bertrand<br />
<a href="mailto:frederic.bertrand@utt.fr">frederic.bertrand@utt.fr</a><br />
<a href="http://www-irma.u-strasbg.fr/~fbertran/">http://www-irma.u-strasbg.fr/~fbertran/</a>
</p>


<h3>References</h3>

<p>plsRcox, Cox-Models in a high dimensional setting in R, Frederic
Bertrand, Philippe Bastien, Nicolas Meyer and Myriam Maumy-Bertrand (2014).
Proceedings of User2014!, Los Angeles, page 152.<br />
</p>
<p>Deviance residuals-based sparse PLS and sparse kernel PLS regression for
censored data, Philippe Bastien, Frederic Bertrand, Nicolas Meyer and Myriam
Maumy-Bertrand (2015), Bioinformatics, 31(3):397-404,
doi:10.1093/bioinformatics/btu660.
</p>


<h3>See Also</h3>

<p><code><a href="survival.html#topic+predict.coxph">predict.coxph</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(micro.censure)
data(Xmicro.censure_compl_imp)

X_train_micro &lt;- apply((as.matrix(Xmicro.censure_compl_imp)),FUN="as.numeric",MARGIN=2)[1:80,]
Y_train_micro &lt;- micro.censure$survyear[1:80]
C_train_micro &lt;- micro.censure$DC[1:80]

modpls &lt;- plsRcox(X_train_micro,time=Y_train_micro,event=C_train_micro,nt=3)

predict(modpls)    
#Identical to predict(modpls,type="lp")    

predict(modpls,type="risk")    
predict(modpls,type="expected")    
predict(modpls,type="terms")    
predict(modpls,type="scores")    

predict(modpls,se.fit=TRUE)    
#Identical to predict(modpls,type="lp")    
predict(modpls,type="risk",se.fit=TRUE)    
predict(modpls,type="expected",se.fit=TRUE)    
predict(modpls,type="terms",se.fit=TRUE)    
predict(modpls,type="scores",se.fit=TRUE)    


#Identical to predict(modpls,type="lp")    
predict(modpls,newdata=X_train_micro[1:5,],type="risk")    
#predict(modpls,newdata=X_train_micro[1:5,],type="expected")    
predict(modpls,newdata=X_train_micro[1:5,],type="terms")    
predict(modpls,newdata=X_train_micro[1:5,],type="scores")    

#Identical to predict(modpls,type="lp")    
predict(modpls,newdata=X_train_micro[1:5,],type="risk",se.fit=TRUE)    
#predict(modpls,newdata=X_train_micro[1:5,],type="expected",se.fit=TRUE)    
predict(modpls,newdata=X_train_micro[1:5,],type="terms",se.fit=TRUE)    
predict(modpls,newdata=X_train_micro[1:5,],type="scores")    

predict(modpls,newdata=X_train_micro[1:5,],type="risk",comps=1)    
predict(modpls,newdata=X_train_micro[1:5,],type="risk",comps=2)    
predict(modpls,newdata=X_train_micro[1:5,],type="risk",comps=3)    
try(predict(modpls,newdata=X_train_micro[1:5,],type="risk",comps=4))

predict(modpls,newdata=X_train_micro[1:5,],type="terms",comps=1)    
predict(modpls,newdata=X_train_micro[1:5,],type="terms",comps=2)    
predict(modpls,newdata=X_train_micro[1:5,],type="terms",comps=3)    
try(predict(modpls,newdata=X_train_micro[1:5,],type="terms",comps=4))

predict(modpls,newdata=X_train_micro[1:5,],type="scores",comps=1)    
predict(modpls,newdata=X_train_micro[1:5,],type="scores",comps=2)    
predict(modpls,newdata=X_train_micro[1:5,],type="scores",comps=3)    
try(predict(modpls,newdata=X_train_micro[1:5,],type="scores",comps=4))

</code></pre>

<hr>
<h2 id='print.plsRcoxmodel'>Print method for plsRcox models</h2><span id='topic+print.plsRcoxmodel'></span>

<h3>Description</h3>

<p>This function provides a print method for the class <code>"plsRcoxmodel"</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'plsRcoxmodel'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.plsRcoxmodel_+3A_x">x</code></td>
<td>
<p>an object of the class <code>"plsRcoxmodel"</code></p>
</td></tr>
<tr><td><code id="print.plsRcoxmodel_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>NULL</code>
</p>


<h3>Author(s)</h3>

<p>Frédéric Bertrand<br />
<a href="mailto:frederic.bertrand@utt.fr">frederic.bertrand@utt.fr</a><br />
<a href="http://www-irma.u-strasbg.fr/~fbertran/">http://www-irma.u-strasbg.fr/~fbertran/</a>
</p>


<h3>References</h3>

<p>plsRcox, Cox-Models in a high dimensional setting in R, Frederic
Bertrand, Philippe Bastien, Nicolas Meyer and Myriam Maumy-Bertrand (2014).
Proceedings of User2014!, Los Angeles, page 152.<br />
</p>
<p>Deviance residuals-based sparse PLS and sparse kernel PLS regression for
censored data, Philippe Bastien, Frederic Bertrand, Nicolas Meyer and Myriam
Maumy-Bertrand (2015), Bioinformatics, 31(3):397-404,
doi:10.1093/bioinformatics/btu660.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+print">print</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(micro.censure)
data(Xmicro.censure_compl_imp)

X_train_micro &lt;- apply((as.matrix(Xmicro.censure_compl_imp)),FUN="as.numeric",MARGIN=2)[1:80,]
Y_train_micro &lt;- micro.censure$survyear[1:80]
C_train_micro &lt;- micro.censure$DC[1:80]

modpls &lt;- plsRcox(X_train_micro,time=Y_train_micro,event=C_train_micro,nt=3)
print(modpls)

</code></pre>

<hr>
<h2 id='print.summary.plsRcoxmodel'>Print method for summaries of plsRcox models</h2><span id='topic+print.summary.plsRcoxmodel'></span>

<h3>Description</h3>

<p>This function provides a print method for the class
<code>"summary.plsRcoxmodel"</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'summary.plsRcoxmodel'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.summary.plsRcoxmodel_+3A_x">x</code></td>
<td>
<p>an object of the class <code>"summary.plsRcoxmodel"</code></p>
</td></tr>
<tr><td><code id="print.summary.plsRcoxmodel_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>language</code></td>
<td>
<p>call of the model</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Frédéric Bertrand<br />
<a href="mailto:frederic.bertrand@utt.fr">frederic.bertrand@utt.fr</a><br />
<a href="http://www-irma.u-strasbg.fr/~fbertran/">http://www-irma.u-strasbg.fr/~fbertran/</a>
</p>


<h3>References</h3>

<p>plsRcox, Cox-Models in a high dimensional setting in R, Frederic
Bertrand, Philippe Bastien, Nicolas Meyer and Myriam Maumy-Bertrand (2014).
Proceedings of User2014!, Los Angeles, page 152.<br />
</p>
<p>Deviance residuals-based sparse PLS and sparse kernel PLS regression for
censored data, Philippe Bastien, Frederic Bertrand, Nicolas Meyer and Myriam
Maumy-Bertrand (2015), Bioinformatics, 31(3):397-404,
doi:10.1093/bioinformatics/btu660.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+print">print</a></code> and <code><a href="base.html#topic+summary">summary</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(micro.censure)
data(Xmicro.censure_compl_imp)

X_train_micro &lt;- apply((as.matrix(Xmicro.censure_compl_imp)),FUN="as.numeric",MARGIN=2)[1:80,]
Y_train_micro &lt;- micro.censure$survyear[1:80]
C_train_micro &lt;- micro.censure$DC[1:80]

modpls &lt;- plsRcox(X_train_micro,time=Y_train_micro,event=C_train_micro,nt=3)
print(summary(modpls))

</code></pre>

<hr>
<h2 id='summary.plsRcoxmodel'>Summary method for plsRcox models</h2><span id='topic+summary.plsRcoxmodel'></span>

<h3>Description</h3>

<p>This function provides a summary method for the class <code>"plsRcoxmodel"</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'plsRcoxmodel'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.plsRcoxmodel_+3A_object">object</code></td>
<td>
<p>an object of the class <code>"plsRcoxmodel"</code></p>
</td></tr>
<tr><td><code id="summary.plsRcoxmodel_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to or from methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>call</code></td>
<td>
<p>function call of plsRcox models</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Frédéric Bertrand<br />
<a href="mailto:frederic.bertrand@utt.fr">frederic.bertrand@utt.fr</a><br />
<a href="http://www-irma.u-strasbg.fr/~fbertran/">http://www-irma.u-strasbg.fr/~fbertran/</a>
</p>


<h3>References</h3>

<p>plsRcox, Cox-Models in a high dimensional setting in R, Frederic
Bertrand, Philippe Bastien, Nicolas Meyer and Myriam Maumy-Bertrand (2014).
Proceedings of User2014!, Los Angeles, page 152.<br />
</p>
<p>Deviance residuals-based sparse PLS and sparse kernel PLS regression for
censored data, Philippe Bastien, Frederic Bertrand, Nicolas Meyer and Myriam
Maumy-Bertrand (2015), Bioinformatics, 31(3):397-404,
doi:10.1093/bioinformatics/btu660.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+summary">summary</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(micro.censure)
data(Xmicro.censure_compl_imp)

X_train_micro &lt;- apply((as.matrix(Xmicro.censure_compl_imp)),FUN="as.numeric",MARGIN=2)[1:80,]
Y_train_micro &lt;- micro.censure$survyear[1:80]
C_train_micro &lt;- micro.censure$DC[1:80]

modpls &lt;- plsRcox(X_train_micro,time=Y_train_micro,event=C_train_micro,nt=3)
summary(modpls)

</code></pre>

<hr>
<h2 id='Xmicro.censure_compl_imp'>Imputed Microsat features</h2><span id='topic+Xmicro.censure_compl_imp'></span>

<h3>Description</h3>

<p>This dataset provides imputed microsat specifications. Imputations were
computed using Multivariate Imputation by Chained Equations (MICE) using
predictive mean matching for the numeric columns, logistic regression
imputation for the binary data or the factors with 2 levels and polytomous
regression imputation for categorical data i.e. factors with three or more
levels.
</p>


<h3>Format</h3>

<p>A data frame with 117 observations on the following 40 variables.
</p>
 <dl>
<dt>D18S61</dt><dd><p>a numeric vector</p>
</dd> <dt>D17S794</dt><dd><p>a
numeric vector</p>
</dd> <dt>D13S173</dt><dd><p>a numeric vector</p>
</dd>
<dt>D20S107</dt><dd><p>a numeric vector</p>
</dd> <dt>TP53</dt><dd><p>a numeric
vector</p>
</dd> <dt>D9S171</dt><dd><p>a numeric vector</p>
</dd> <dt>D8S264</dt><dd><p>a
numeric vector</p>
</dd> <dt>D5S346</dt><dd><p>a numeric vector</p>
</dd>
<dt>D22S928</dt><dd><p>a numeric vector</p>
</dd> <dt>D18S53</dt><dd><p>a numeric
vector</p>
</dd> <dt>D1S225</dt><dd><p>a numeric vector</p>
</dd> <dt>D3S1282</dt><dd><p>a
numeric vector</p>
</dd> <dt>D15S127</dt><dd><p>a numeric vector</p>
</dd>
<dt>D1S305</dt><dd><p>a numeric vector</p>
</dd> <dt>D1S207</dt><dd><p>a numeric
vector</p>
</dd> <dt>D2S138</dt><dd><p>a numeric vector</p>
</dd> <dt>D16S422</dt><dd><p>a
numeric vector</p>
</dd> <dt>D9S179</dt><dd><p>a numeric vector</p>
</dd>
<dt>D10S191</dt><dd><p>a numeric vector</p>
</dd> <dt>D4S394</dt><dd><p>a numeric
vector</p>
</dd> <dt>D1S197</dt><dd><p>a numeric vector</p>
</dd> <dt>D6S264</dt><dd><p>a
numeric vector</p>
</dd> <dt>D14S65</dt><dd><p>a numeric vector</p>
</dd>
<dt>D17S790</dt><dd><p>a numeric vector</p>
</dd> <dt>D5S430</dt><dd><p>a numeric
vector</p>
</dd> <dt>D3S1283</dt><dd><p>a numeric vector</p>
</dd> <dt>D4S414</dt><dd><p>a
numeric vector</p>
</dd> <dt>D8S283</dt><dd><p>a numeric vector</p>
</dd>
<dt>D11S916</dt><dd><p>a numeric vector</p>
</dd> <dt>D2S159</dt><dd><p>a numeric
vector</p>
</dd> <dt>D16S408</dt><dd><p>a numeric vector</p>
</dd> <dt>D6S275</dt><dd><p>a
numeric vector</p>
</dd> <dt>D10S192</dt><dd><p>a numeric vector</p>
</dd>
<dt>sexe</dt><dd><p>a numeric vector</p>
</dd> <dt>Agediag</dt><dd><p>a numeric
vector</p>
</dd> <dt>Siege</dt><dd><p>a numeric vector</p>
</dd> <dt>T</dt><dd><p>a numeric
vector</p>
</dd> <dt>N</dt><dd><p>a numeric vector</p>
</dd> <dt>M</dt><dd><p>a numeric
vector</p>
</dd> <dt>STADE</dt><dd><p>a factor with levels <code>0</code> <code>1</code> <code>2</code>
<code>3</code> <code>4</code></p>
</dd> </dl>



<h3>Source</h3>

<p>Allelotyping identification of genomic alterations in rectal
chromosomally unstable tumors without preoperative treatment,
Benoît Romain, Agnès Neuville, Nicolas Meyer,
Cécile Brigand, Serge Rohr, Anne Schneider, Marie-Pierre Gaub
and Dominique Guenot, <em>BMC Cancer 2010</em>, 10:561,
doi:10.1186/1471-2407-10-561.
</p>


<h3>References</h3>

<p>plsRcox, Cox-Models in a high dimensional setting in R, Frederic
Bertrand, Philippe Bastien, Nicolas Meyer and Myriam Maumy-Bertrand (2014).
Proceedings of User2014!, Los Angeles, page 152.<br />
</p>
<p>Deviance residuals-based sparse PLS and sparse kernel PLS regression for
censored data, Philippe Bastien, Frederic Bertrand, Nicolas Meyer and Myriam
Maumy-Bertrand (2015), Bioinformatics, 31(3):397-404,
doi:10.1093/bioinformatics/btu660.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

data(Xmicro.censure_compl_imp)
X_train_micro &lt;- Xmicro.censure_compl_imp[1:80,]
X_test_micro &lt;- Xmicro.censure_compl_imp[81:117,]
rm(X_train_micro,X_test_micro)


</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
