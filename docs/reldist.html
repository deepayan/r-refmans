<!DOCTYPE html><html><head><title>Help for package reldist</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {reldist}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#gini'><p>Compute the Gini Coefficient</p></a></li>
<li><a href='#nls'><p>Permanent wage growth in two cohorts of the NLS</p></a></li>
<li><a href='#precipitation'><p>Annual Precipitation in US Cities</p></a></li>
<li><a href='#reldist'><p>Inference for Relative Distributions</p></a></li>
<li><a href='#reldist-internal'><p>Internal reldist Objects</p></a></li>
<li><a href='#resplot'><p>Relative distribution plot to a Standard Normal</p></a></li>
<li><a href='#wtd.iqr'><p>Weighted Interquartile range</p></a></li>
<li><a href='#wtd.quantile'><p>Weighted Quantiles</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>1.7-2</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-02-16</td>
</tr>
<tr>
<td>Title:</td>
<td>Relative Distribution Methods</td>
</tr>
<tr>
<td>Author:</td>
<td>Mark S. Handcock &lt;handcock@stat.ucla.edu&gt;</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Mark S. Handcock &lt;handcock@stat.ucla.edu&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Tools for the comparison of distributions. This includes nonparametric estimation of the relative distribution PDF and CDF and numerical summaries as described in "Relative Distribution Methods in the Social Sciences" by Mark S. Handcock and Martina Morris, Springer-Verlag, 1999, Springer-Verlag, ISBN 0387987789.</td>
</tr>
<tr>
<td>Imports:</td>
<td>mgcv, densEstBayes</td>
</tr>
<tr>
<td>Suggests:</td>
<td>locfit</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="http://www.stat.ucla.edu/~handcock/RelDist/">http://www.stat.ucla.edu/~handcock/RelDist/</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-02-17 17:06:44 UTC; handcock</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-02-17 22:30:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='gini'>Compute the Gini Coefficient</h2><span id='topic+gini'></span>

<h3>Description</h3>

<p>Computes the Gini coefficient based on (possibly weighted) sample data
</p>


<h3>Usage</h3>

<pre><code class='language-R'> gini(x,  weights=rep(1,length=length(x)))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gini_+3A_x">x</code></td>
<td>
<p>a vector containing at least non-negative elements</p>
</td></tr>
<tr><td><code id="gini_+3A_weights">weights</code></td>
<td>
<p>an optional vector of sample weights for <code>x</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>Gini</code> is the Gini coefficient, a common measure of inequality
within a distribution. It is commonly used to measure income inequality.
It is defined as twice the area between the 45 degree line
and a Lorenz curve, where the Lorenz curve is a graph describing the share of
total income T accruing to the poorest fraction p of the population.
</p>
<p>In typical use the values of <code>x</code> are the incomes of individuals from a survey
and the <code>weights</code> are the corresponding survey weights.
If the values of <code>x</code> are the mean incomes within income classes and the
weights <code>weights</code> are the corresponding population proportions within those
classes, the function computes an estimate of the Gini coefficient of the
underlying income distribution. 
</p>


<h3>Value</h3>

<p>the Gini coefficient (between 0 and 1).
</p>


<h3>Author(s)</h3>

<p>Mark S. Handcock <a href="mailto:handcock@stat.ucla.edu">handcock@stat.ucla.edu</a></p>


<h3>Source</h3>

<p><em>Relative Distribution Methods in the Social Sciences</em>,
by Mark S. Handcock and Martina Morris, Springer-Verlag, Inc., New York, 1999.
ISBN 0387987789.</p>


<h3>References</h3>

<p><em>Relative Distribution Methods in the
Social Sciences</em>, by Mark S. Handcock and Martina Morris,
Springer-Verlag, Inc., New York, 1999. ISBN 0387987789.
</p>
<p><em>Divergent Paths: Economic Mobility in the New
American Labor Market</em>, Russell Sage Foundation, New York, June 2001
Annette D. Bernhardt, Martina Morris, Mark S. Handcock and Marc Scott.
</p>
<p><em>Measurement of Inequality</em>, by F. A. Cowell, in A. B. Atkinson /
F. Bourguignon (Eds): Handbook of Income Distribution, Amsterdam, 2000.
</p>
<p><em>Measuring Inequality</em>, by F. A. Cowell, Prentice Hall/Harvester 
Wheatshef, 1995.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+reldist">reldist</a></code>, <code><a href="#topic+nls">nls</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'># generate vector (of incomes)
x &lt;- c(541, 1463, 2445, 3438, 4437, 5401, 6392, 8304, 11904, 22261)
# compute Gini coefficient
gini(x)
# generate a vector of weights.
w &lt;- runif(n=length(x))
gini(x,w)
#
# Compute the inequality in income growth for the recent cohort of the
# National Longitudinal Survey (NLS) initiated in 1979.
#
library(reldist)
data(nls)
help(nls)
# Compute the wage growth
y &lt;- exp(recent$chpermwage)
# Compute the unweighted estimate
gini(y)
# Compute the weighted estimate
gini(y,w=recent$wgt)
</code></pre>

<hr>
<h2 id='nls'>Permanent wage growth in two cohorts of the NLS</h2><span id='topic+nls'></span><span id='topic+original'></span><span id='topic+recent'></span>

<h3>Description</h3>

<p>These data are from two cohorts of the National Longitudinal Survey
(NLS) initiated in 1966 and 1979. The cohorts are referred to as the
&lsquo;original&rsquo; and the &lsquo;recent&rsquo; cohort, respectively.
The data represents the permanent wage
growth of each individual in the cohort from age 16 through
36. This was used in Handcock and Morris (1999) and Bernhardt,
Morris, Handcock and Scott (2001) to study the question of wage
mobility. A development of the estimation of these permanent
wages and their relevance to the study of wage mobility is
given in  Handcock and Morris (1999).  For the purposes of
this <code>reldist</code> package, we can regard the permanent
wages as measurements on two groups that we wish to compare.
</p>
<p>The data set is comprised of two <code>data.frame</code>s  called
&lsquo;original&rsquo; and &lsquo;recent&rsquo;. Each has
three columns: <code>chpermwage</code>: the change in permanent wages 
(in log-dollars), <code>endeduc</code>: the final achieved
educational level (in years), and <code>wgt</code>: the sample weight.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> data(nls)
</code></pre>


<h3>Source</h3>

<p><em>Relative Distribution Methods in the Social Sciences</em>, 
by Mark S. Handcock and Martina Morris, Springer-Verlag, Inc., New York, 1999. ISBN 0387987789.</p>


<h3>References</h3>

<p><em>Relative Distribution Methods in the
Social Sciences</em>, by Mark S. Handcock and Martina Morris,
Springer-Verlag, Inc., New York, 1999. ISBN 0387987789.
</p>
<p><em>Divergent Paths: Economic Mobility in the New
American Labor Market</em>, Russell Sage Foundation, New York, June 2001
Annette D. Bernhardt, Martina Morris, Mark S. Handcock and Marc Scott.
</p>


<h3>See Also</h3>

<p>reldist</p>

<hr>
<h2 id='precipitation'>Annual Precipitation in US Cities</h2><span id='topic+precipitation'></span>

<h3>Description</h3>

<p>The average amount of precipitation (rainfall) in inches for each of
70 United States (and Puerto Rico) cities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(precipitation)</code></pre>


<h3>Format</h3>

<p>A named vector of length 70.
</p>


<h3>Details</h3>

<p>This is a clone of the <code>precip</code> R dataset to avoid a bug in R.</p>


<h3>Source</h3>

<p>Statistical Abstracts of the United States, 1975.
</p>


<h3>References</h3>

<p>McNeil, D. R. (1977)
<em>Interactive Data Analysis</em>.
New York: Wiley.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(graphics)
data(precipitation)
dotchart(precipitation[order(precipitation)], main="precipitation data")
title(sub = "Average annual precipitation (in.)")
</code></pre>

<hr>
<h2 id='reldist'>Inference for Relative Distributions</h2><span id='topic+reldist'></span>

<h3>Description</h3>

<p>Estimate and graph relative distribution and density functions for continuous or discrete data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reldist(y, yo=FALSE, ywgt=FALSE,yowgt=FALSE,
  show="none", decomp="locadd",
  location="median", scale="IQR",
  rpmult=FALSE, 
  z=FALSE, zo=FALSE,
  smooth = 0.35, 
  quiet = TRUE, 
  cdfplot=FALSE,
  ci=FALSE,
  bar="no",
  add=FALSE,
  graph=TRUE, type="l",
  xlab="Reference proportion",ylab="Relative Density",yaxs="r",
  yolabs=pretty(yo), yolabslabs=NULL, 
  ylabs=pretty(y), ylabslabs=NULL,
  yolabsloc=0.6, ylabsloc=1, 
  ylim=NULL, cex=0.8, lty=1,
  binn=5000,
  aicc=seq(0.0001, 5, length=30),
  deciles=(0:10)/10,
  discrete=FALSE,
  method="Bayes",
  y0=NULL,
  control = list(samples = 4000, burnin = 1000),
  ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reldist_+3A_y">y</code></td>
<td>
<p>Sample from comparison distribution.</p>
</td></tr>
<tr><td><code id="reldist_+3A_yo">yo</code></td>
<td>
<p>Sample from reference distribution.</p>
</td></tr>
<tr><td><code id="reldist_+3A_discrete">discrete</code></td>
<td>
<p>Do <code>y</code> and <code>yo</code> refer to a 
discrete distribution? If <code>TRUE</code> a discrete estimator is 
used instead of the default continuous one.</p>
</td></tr>
<tr><td><code id="reldist_+3A_smooth">smooth</code></td>
<td>
<p>Degree of smoothness required in the fit.
Higher values lead to smoother curves, lower positive
values lead to closer fits to the observed data.  If it is
not specified the value that minimizes GCV is used. If a
value less than zero is specified then the value is chosen
to minimize a corrected AIC. If <code>discrete=TRUE</code>
it is the minimum number of values to pool in the reference
distribution in the probability mass function estimate.</p>
</td></tr>
<tr><td><code id="reldist_+3A_method">method</code></td>
<td>
<p>Method used to estimate the relative density. The default
(<code>"Bayes"</code>) uses a density estimator based on Poisson Nonparametric Regression and Bayesian inference developed by Wand and Wu (2022).
The option (<code>"bgk"</code>) uses a Gaussian kernel density estimator for bounded
domain one-dimensional data developed by Botev, Grotowski and Kroese
(2010). The option (<code>"gam"</code>) uses a local likelihood approach
based on smoothed Poisson regression. The option <code>"loclik"</code> uses
log-splines. The option <code>"quick"</code> uses the Anscombe transformation
to stabilize variances. In versions prior to 1.3 the <code>"quick"</code>
approach was used.</p>
</td></tr>
<tr><td><code id="reldist_+3A_graph">graph</code></td>
<td>
<p>Graph the results on the current device.</p>
</td></tr>
<tr><td><code id="reldist_+3A_bar">bar</code></td>
<td>
<p>Graph the deciles on the current device.  Possible values
of <code>bar</code> are <code>"no"</code> (no deciles plotted), <code>"yes"</code>
(deciles plotted with the non-parametric fit,<br />
<code>"only"</code>(deciles plotted without non-parametric fit).</p>
</td></tr>
<tr><td><code id="reldist_+3A_add">add</code></td>
<td>
<p>Add the density to the current plot?</p>
</td></tr>
<tr><td><code id="reldist_+3A_ylim">ylim</code></td>
<td>
<p>plotting limit for the vertical axis.</p>
</td></tr>
<tr><td><code id="reldist_+3A_lty">lty</code></td>
<td>
<p>Line type to be used for the density.</p>
</td></tr>
<tr><td><code id="reldist_+3A_xlab">xlab</code></td>
<td>
<p>Horizontal label.</p>
</td></tr>
<tr><td><code id="reldist_+3A_ylab">ylab</code></td>
<td>
<p>Vertical label.</p>
</td></tr>
<tr><td><code id="reldist_+3A_ylabs">ylabs</code></td>
<td>
<p>Locations for label to be added to the right axis.</p>
</td></tr>
<tr><td><code id="reldist_+3A_ylabslabs">ylabslabs</code></td>
<td>
<p>Labels indicating the original scale for the
comparison distribution.</p>
</td></tr>
<tr><td><code id="reldist_+3A_ylabsloc">ylabsloc</code></td>
<td>
<p>Distance of labels to right of axis (in lines).</p>
</td></tr>
<tr><td><code id="reldist_+3A_yolabs">yolabs</code></td>
<td>
<p>locations for labels to be added to the tip axis.</p>
</td></tr>
<tr><td><code id="reldist_+3A_yolabslabs">yolabslabs</code></td>
<td>
<p>Labels indicating the original scale for the
reference distribution.</p>
</td></tr>
<tr><td><code id="reldist_+3A_yolabsloc">yolabsloc</code></td>
<td>
<p>Distance of labels above axis (in lines).</p>
</td></tr>
<tr><td><code id="reldist_+3A_yaxs">yaxs</code></td>
<td>
<p>Style of vertical axis.</p>
</td></tr>
<tr><td><code id="reldist_+3A_cdfplot">cdfplot</code></td>
<td>
<p>calculate and plot the CDF rather than the density.</p>
</td></tr>
<tr><td><code id="reldist_+3A_quiet">quiet</code></td>
<td>
<p>Should the output be returned invisibly?</p>
</td></tr>
<tr><td><code id="reldist_+3A_ci">ci</code></td>
<td>
<p>Plot (pointwise) 95% confidence intervals?</p>
</td></tr>
<tr><td><code id="reldist_+3A_ywgt">ywgt</code></td>
<td>
<p>Weights on the comparison sample.</p>
</td></tr>
<tr><td><code id="reldist_+3A_yowgt">yowgt</code></td>
<td>
<p>Weights on the reference sample.</p>
</td></tr>
<tr><td><code id="reldist_+3A_z">z</code></td>
<td>
<p>Covariate on the comparison sample to be used to adjust it
to the reference distribution. Only used if the form of matching 
specified in<br />
<code>decomp="covariate"</code>.</p>
</td></tr>
<tr><td><code id="reldist_+3A_zo">zo</code></td>
<td>
<p>Covariate on the reference sample to be used in
the adjustment.  to the reference distribution. Only used if
the form of matching specified in<br />
<code>decomp="covariate"</code>.</p>
</td></tr>
<tr><td><code id="reldist_+3A_show">show</code></td>
<td>
<p>Type of relative distribution to produce.  Possible values
are <code>"none"</code> (comparisons to reference), <code>residual</code>
(location-matched reference to reference), <code>effect</code> (comparison
to location-matched reference).</p>
</td></tr>
<tr><td><code id="reldist_+3A_decomp">decomp</code></td>
<td>
<p>Form of matching to the comparison sample.  Possible
values are <code>locmult</code> (multiplicatively scale the reference),
<code>locadd</code> (additively shift the reference), <code>lsadd</code>
(location/scale additive shift), <code>covariate</code> (covariate adjust
the reference (requires z and zo to be specified)).</p>
</td></tr>
<tr><td><code id="reldist_+3A_location">location</code></td>
<td>
<p>How to measure location.  Possible values are
<code>"mean"</code> and <code>"median"</code>.</p>
</td></tr>
<tr><td><code id="reldist_+3A_scale">scale</code></td>
<td>
<p>How to measure the scale.  Possible values are
<code>"standev"</code> (standard deviation) and <code>IQR</code> (interquartile
range).</p>
</td></tr>
<tr><td><code id="reldist_+3A_rpmult">rpmult</code></td>
<td>
<p>Only in calculation of polarization indices:
multiplicatively scale the reference sample to the comparison sample
before comparing the two distributions?</p>
</td></tr>
<tr><td><code id="reldist_+3A_binn">binn</code></td>
<td>
<p>Number of bins used in the smoother.</p>
</td></tr>
<tr><td><code id="reldist_+3A_deciles">deciles</code></td>
<td>
<p>The percentiles used for the histogram bins. Typically
deciles (i.e., 0.0, 0.1, 0.2,...,0.9, 1.0), but any set can be used
(e.g., quintiles, terciles).</p>
</td></tr>
<tr><td><code id="reldist_+3A_aicc">aicc</code></td>
<td>
<p>Values of the smoothing parameter to search
over in minimizing the corrected AIC. Only used if 
<code>method="gam"</code> and <code>smooth</code> is less than 0.</p>
</td></tr>
<tr><td><code id="reldist_+3A_type">type</code></td>
<td>
<p>Type of plot to use. See <code>par()</code>.</p>
</td></tr>
<tr><td><code id="reldist_+3A_cex">cex</code></td>
<td>
<p>Character expansion to use in plots. See <code>par()</code>.</p>
</td></tr>
<tr><td><code id="reldist_+3A_y0">y0</code></td>
<td>
<p>A test to see if <code>yo</code> was passed. If <code>y0</code> is passed 
it prints a warning.  If <code>y0</code> is passed and <code>yo</code> is not passed 
then <code>y0</code> is used as the sample from reference distribution.</p>
</td></tr>
<tr><td><code id="reldist_+3A_control">control</code></td>
<td>
<p>list; A simple list of control options for the STAN HMC computation used when <code>method="Bayes"</code>, the default.
The two components are <code>samples=4000</code>, the number of samples drawn and <code>burnin=1000</code>, the burn-in used.</p>
</td></tr>
<tr><td><code id="reldist_+3A_...">...</code></td>
<td>
<p>Additional arguments to the plot functions. See <code>par()</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>x</code></td>
<td>
<p>Horizontal coordinates for the density (typically
percentages).</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>Density at x.</p>
</td></tr>
<tr><td><code>rp</code></td>
<td>
<p>95% confidence interval for the median relative
polarization as lower bound, estimate, upper bound.</p>
</td></tr>
<tr><td><code>rpl</code></td>
<td>
<p>95% confidence interval for the lower relative
polarization as lower bound, estimate, upper bound.</p>
</td></tr>
<tr><td><code>rpu</code></td>
<td>
<p>95% confidence interval for the upper relative
polarization as lower bound, estimate, upper bound.</p>
</td></tr>
<tr><td><code>cdf</code></td>
<td>
<p>x coordinates for the CDF (typically percentages) and y CDF
at x.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Most of the code is for the plotting and tinkering.  The guts of the
method are forming the relative data at the top.  The rest is a
standard fixed interval density estimation with a few bells and
whistles.</p>


<h3>References</h3>

<p>For more examples see the tech report
</p>
<p>Mark S. Handcock and Eric Mark Aldrich <em>Applying Relative Distribution Methods in R</em>
University of Washington CSSS Working Paper No.
27, Available at SSRN: <a href="https://doi.org/10.2139/ssrn.1515775">doi:10.2139/ssrn.1515775</a>.
</p>
<p>Z. I. Botev, J. F. Grotowski and D. P. Kroese
<em>Kernel Density Estimation Via Diffusion</em>
Annals of Statistics, 2010, Volume 38, Number 5, Pages 2916-2957.
</p>
<p>M. Wand and J. C. F. Yu
<em>Density Estimation via Bayesian Inference Engines</em>
AStA Advances in Statistical Analysis, 2021, <a href="https://doi.org/10.1007/s10182-021-00422-8">doi:10.1007/s10182-021-00422-8</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# First load the data.
#

data(nls, package="reldist")

#
# A simple example comparing permanent wages of the original to the
# recent cohort in the NLS.  See H&amp;M (1999) for details.

reldist(y=recent$chpermwage,yo=original$chpermwage,method="bgk")

#
# A more sophisticated version of the same.
#

reldist(y=recent$chpermwage, yo=original$chpermwage,
        yowgt=original$wgt, ywgt=recent$wgt,      
        bar=TRUE,                                   
        smooth=0.1, method="bgk",                             
        yolabs=seq(-1, 3, by=0.5),                 
        ylim=c(0, 3.0),cex=0.8,                   
        ylab="Relative Density",                 
        xlab="Proportion of the Original Cohort")

#
# A CDF version.
#

reldist(y=recent$chpermwage, yo=original$chpermwage,
    yowgt=original$wgt, ywgt=recent$wgt,      
    cdfplot=TRUE,                               
    smooth=0.4,                              
    yolabs=seq(-1,3,by=0.5),                 
    ylabs=seq(-1,3,by=0.5),                  
    cex=0.8,                                 
    method="bgk",                             
    ylab="proportion of the recent cohort",  
    xlab="proportion of the original cohort")
</code></pre>

<hr>
<h2 id='reldist-internal'>Internal reldist Objects</h2><span id='topic+rcdist'></span><span id='topic+rddata'></span><span id='topic+rddist'></span><span id='topic+rdeciles'></span><span id='topic+really.missing'></span><span id='topic+relasp'></span><span id='topic+rmdata'></span><span id='topic+rpluy'></span><span id='topic+rpy'></span><span id='topic+bgk_kde'></span><span id='topic+wtd.mean'></span><span id='topic+wtd.median'></span><span id='topic+wtd.var'></span><span id='topic+entropy'></span><span id='topic+rdsamp'></span>

<h3>Description</h3>

<p>Internal reldist functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>entropy(x,xo=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reldist-internal_+3A_x">x</code></td>
<td>
<p>a list with components <code>x</code> and <code>y</code>. The vector <code>y</code> are
the relative density estimates at the values in the vector
<code>x</code>. The latter are in the unit interval.</p>
</td></tr>
<tr><td><code id="reldist-internal_+3A_xo">xo</code></td>
<td>
<p>a list with components <code>x</code> and <code>y</code> like the first argument. If given the relative entropy (or Kullback-Liebler divergence) of the first to the second argument is calculated.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Most of these are not to be called by the user.
</p>


<h3>Value</h3>

<p>If <code>xo</code> is given, the relative entropy (or Kullback-Liebler divergence) of the first to the second argument is calculated. Otherwise the entropy of the distribution specified by <code>x</code>.</p>


<h3>See Also</h3>

<p>reldist</p>

<hr>
<h2 id='resplot'>Relative distribution plot to a Standard Normal</h2><span id='topic+resplot'></span>

<h3>Description</h3>

<p><code>resplot</code> produces a relative distribution of the values to a standard 
normal.
</p>
<p>Graphical parameters may be given as arguments to <code>resplot</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>resplot(x,
       standardize=TRUE,
       xlab="Gaussian Cumulative Proportion",
       method="Bayes",
       ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="resplot_+3A_x">x</code></td>
<td>
<p>The first sample for <code>resplot</code>.</p>
</td></tr>
<tr><td><code id="resplot_+3A_standardize">standardize</code></td>
<td>
<p>Should the sample be converted to standard units first?</p>
</td></tr>
<tr><td><code id="resplot_+3A_xlab">xlab</code></td>
<td>
<p>plot labels.</p>
</td></tr>
<tr><td><code id="resplot_+3A_method">method</code></td>
<td>
<p>Method used to estimate the relative density. The default
(<code>"Bayes"</code>) uses a density estimator based on Poisson Nonparametric 
Regression and Bayesian inference developed by Wand and Wu (2022).
The option (<code>"bgk"</code>) uses a Gaussian kernel density estimator for bounded
domain one-dimensional data developed by Botev, Grotowski and Kroese
(2010). The option (<code>"gam"</code>) uses a local likelihood approach
based on smoothed Poisson regression. The option <code>"loclik"</code> uses
log-splines. The option <code>"quick"</code> uses the Anscombe transformation
to stabilize variances. In versions prior to 1.3 the <code>"quick"</code>
approach was used.</p>
</td></tr>
<tr><td><code id="resplot_+3A_...">...</code></td>
<td>
<p>graphical parameters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with components summarizing the relative distribution. See
<code>reldist</code> for the details.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+reldist">reldist</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>y &lt;- rnorm(2000)
resplot(y, method="bgk")
data(precipitation)
resplot(precipitation, ylab = "Precipitation [in/yr] for 70 US cities", method="bgk")
</code></pre>

<hr>
<h2 id='wtd.iqr'>Weighted Interquartile range</h2><span id='topic+wtd.iqr'></span><span id='topic+iqr'></span>

<h3>Description</h3>

<p>Compute weighted Interquartile range (iqr)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wtd.iqr (x, na.rm = FALSE, weight=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wtd.iqr_+3A_x">x</code></td>
<td>
<p> Vector of data, same length as <code>weight</code> </p>
</td></tr>
<tr><td><code id="wtd.iqr_+3A_na.rm">na.rm</code></td>
<td>
<p>Logical:  Should NAs be stripped before computation proceeds?</p>
</td></tr>
<tr><td><code id="wtd.iqr_+3A_weight">weight</code></td>
<td>
<p> Vector of weights. If NULL, the default, weights are not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Uses a simple algorithm based on sorting.
</p>


<h3>Value</h3>

<p>Returns an empirical interquartile range from a weighted sample.
</p>

<hr>
<h2 id='wtd.quantile'>Weighted Quantiles</h2><span id='topic+wtd.quantile'></span>

<h3>Description</h3>

<p>Compute weighted quantile
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wtd.quantile (x, q=0.5, na.rm = FALSE, weight=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wtd.quantile_+3A_x">x</code></td>
<td>
<p> Vector of data, same length as <code>weight</code> </p>
</td></tr>
<tr><td><code id="wtd.quantile_+3A_q">q</code></td>
<td>
<p> Quantile to compute </p>
</td></tr>
<tr><td><code id="wtd.quantile_+3A_na.rm">na.rm</code></td>
<td>
<p>Logical:  Should NAs be stripped before computation proceeds?</p>
</td></tr>
<tr><td><code id="wtd.quantile_+3A_weight">weight</code></td>
<td>
<p> Vector of weights.  If NULL, the default, weights are not used. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Uses a simple algorithm based on sorting.
</p>


<h3>Value</h3>

<p>Returns an empirical q quantile from a weighted sample.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
