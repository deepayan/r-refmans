<!DOCTYPE html><html><head><title>Help for package ShellChron</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {ShellChron}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#+25+26gt+3B+25'><p>Pipe operator</p></a></li>
<li><a href='#age_corr'><p>Function that corrects chronologies for sudden jumps in time</p></a></li>
<li><a href='#cumdy'><p>Function to detect year transitions and calculate cumulative age</p>
of model results</a></li>
<li><a href='#cumulative_day'><p>Function to detect year transitions and calculate cumulative age of model results</p></a></li>
<li><a href='#d18O_model'><p>Function to convert SST data to d18O</p></a></li>
<li><a href='#data_import'><p>Function to import d18O data and process yearmarkers and calculation windows</p></a></li>
<li><a href='#export_results'><p>Function to merge and export the results of the ShellChron model</p></a></li>
<li><a href='#growth_model'><p>Function that models a d18O curve through SST and GR sinusoids</p></a></li>
<li><a href='#growth_rate_curve'><p>Function that creates a skewed sinusoidal growth rate (GR) curve</p>
from a list of parameters</a></li>
<li><a href='#mc_err_form'><p>Function that propagates measurement uncertainty through model results</p></a></li>
<li><a href='#mc_err_orth'><p>Function that propagates measurement uncertainty through model results</p></a></li>
<li><a href='#mc_err_proj'><p>Function that propagates measurement uncertainty through model results</p></a></li>
<li><a href='#peakid'><p>Function that identifies peaks in a dataset</p></a></li>
<li><a href='#run_model'><p>Function that optimizes sinusoid parameters to fit d18O data</p></a></li>
<li><a href='#sd_wt'><p>Function to calculate weighted standard deviation</p></a></li>
<li><a href='#sinreg'><p>Function that carries out a sinusoidal regression</p></a></li>
<li><a href='#temperature_curve'><p>Function that creates a sinusoidal Sea Surface Temperature (SST) curve</p>
from a list of parameters</a></li>
<li><a href='#Virtual_shell'><p>Virtual input data for ShellChron</p></a></li>
<li><a href='#wrap_function'><p>Full ShellChron workflow wrapped in a single function</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Builds Chronologies from Oxygen Isotope Profiles in Shells</td>
</tr>
<tr>
<td>Version:</td>
<td>0.4.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Takes as input a stable oxygen isotope (d18O) profile measured in growth direction (D)
	through a shell + uncertainties in both variables (d18O_err &amp; D_err). It then models the seasonality
	in the d18O record by fitting a combination of a growth and temperature sine wave to year-length chunks of
	the data (see Judd et al., (2018) &lt;<a href="https://doi.org/10.1016%2Fj.palaeo.2017.09.034">doi:10.1016/j.palaeo.2017.09.034</a>&gt;). This modeling is carried out along a sliding window through the data and yields estimates of
	the day of the year (Julian Day) and local growth rate for each data point. Uncertainties in both modeling
	routine and the data itself are propagated and pooled to obtain a confidence envelope around the age of
	each data point in the shell. The end result is a shell chronology consisting of estimated ages of shell
	formation relative to the annual cycle with their uncertainties. All formulae in the package serve this
	purpose, but the user can customize the model (e.g. number of days in a year and the mineralogy of the
	shell carbonate) through input parameters.</td>
</tr>
<tr>
<td>Imports:</td>
<td>rtop (&ge; 0.5.14), zoo (&ge; 1.8.7), ggplot2 (&ge; 3.2.1), ggpubr
(&ge; 0.4.0), tidyr (&ge; 1.1.1), scales (&ge; 1.1.0), dplyr,
magrittr</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/nielsjdewinter/ShellChron">https://github.com/nielsjdewinter/ShellChron</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/nielsjdewinter/ShellChron/issues">https://github.com/nielsjdewinter/ShellChron/issues</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-07-05 12:28:05 UTC; Convernaum</td>
</tr>
<tr>
<td>Author:</td>
<td>Niels de Winter <a href="https://orcid.org/0000-0002-1453-5407"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Niels de Winter &lt;niels_de_winter@live.nl&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-07-05 12:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='+25+26gt+3B+25'>Pipe operator</h2><span id='topic++25+3E+25'></span>

<h3>Description</h3>

<p>See <code>magrittr::<a href="magrittr.html#topic+pipe">%&gt;%</a></code> for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lhs %&gt;% rhs
</code></pre>

<hr>
<h2 id='age_corr'>Function that corrects chronologies for sudden jumps in time</h2><span id='topic+age_corr'></span>

<h3>Description</h3>

<p>Some occurrences in the model results can lead the CumDY function
to detect extra year transitions, resulting in sudden jumps in
the shell chronology or a start of the chronology at an age
beyond 1 year. This function removes these sharp transitions
and late onset by adding or subtracting whole years to the age
result.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>age_corr(resultarray, T_per = 365, plot = TRUE, agecorrection = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="age_corr_+3A_resultarray">resultarray</code></td>
<td>
<p>Array containing the full results of
the optimized growth model</p>
</td></tr>
<tr><td><code id="age_corr_+3A_t_per">T_per</code></td>
<td>
<p>The period length of one year (in days)</p>
</td></tr>
<tr><td><code id="age_corr_+3A_plot">plot</code></td>
<td>
<p>Should the results be plotted? (/codeTRUE/FALSE)</p>
</td></tr>
<tr><td><code id="age_corr_+3A_agecorrection">agecorrection</code></td>
<td>
<p>Correct for jumps in age (/codeTRUE) or
only for starting time (/codeFALSE)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An updated and corrected version of <code>resultarray</code>
</p>


<h3>References</h3>

<p>package dependencies: ggplot2 3.2.1
</p>


<h3>Examples</h3>

<pre><code class='language-R'>testarray &lt;- array(NA, dim = c(20, 16, 9)) # Create empty array
# with correct third dimension
windowfill &lt;- seq(10, 100, 10) # Create dummy simulation data 
# (ages) to copy through the array
for(i in 6:length(testarray[1, , 1])){
    testarray[, i, 3] &lt;- c(windowfill,
        rep(NA, length(testarray[, 1, 3]) - length(windowfill)))
    windowfill &lt;- c(NA, windowfill + 31)
}
testarray2 &lt;- age_corr(testarray, 365, FALSE, FALSE) # Apply function on 
array
</code></pre>

<hr>
<h2 id='cumdy'>Function to detect year transitions and calculate cumulative age
of model results</h2><span id='topic+cumdy'></span>

<h3>Description</h3>

<p>Takes the result of iterative growth modeling and
transforms data from Julian Day (0 - 365) to cumulative
day of the shell age by detecting where transitions
from one year to the next occur and adding full years
(365 days) to simulations in later years.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cumdy(resultarray, threshold = 5, plotyearmarkers = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cumdy_+3A_resultarray">resultarray</code></td>
<td>
<p>Array containing the full results of
the optimized growth model</p>
</td></tr>
<tr><td><code id="cumdy_+3A_threshold">threshold</code></td>
<td>
<p>Artificial threshold value used to recognize
peaks in occurrences of year transitions (default = 5)</p>
</td></tr>
<tr><td><code id="cumdy_+3A_plotyearmarkers">plotyearmarkers</code></td>
<td>
<p>Should the location of identified year
transitions be plotted? <code>TRUE/FALSE</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A new version of the resultarray with Julian Day model
estimates replaced by estimates of cumulative age of the record
in days.
</p>


<h3>References</h3>

<p>package dependencies: zoo 1.8.7
</p>


<h3>Examples</h3>

<pre><code class='language-R'>testarray &lt;- array(NA, dim = c(20, 16, 9)) # Create empty array
# with correct third dimension
windowfill &lt;- seq(50, 500, 50) # Create dummy simulation data 
# (ages) to copy through the array
for(i in 6:length(testarray[1, , 1])){
    testarray[, i, 3] &lt;- c(windowfill, rep(NA, length(testarray[, 1, 3]) -
        length(windowfill)))
    windowfill &lt;- c(NA, (windowfill + 51) %% 365)
}
testarray[, 1, 3] &lt;- seq(1, length(testarray[, 1, 3]), 1) # Add
# dummy /code{D} column.
testarray2 &lt;- cumdy(testarray, 3, FALSE) # Apply function on array
</code></pre>

<hr>
<h2 id='cumulative_day'>Function to detect year transitions and calculate cumulative age of model results</h2><span id='topic+cumulative_day'></span>

<h3>Description</h3>

<p>Takes the result of iterative growth modeling and
transforms data from Julian Day (0 - 365) to cumulative
day of the shell age by detecting where transitions
from one year to the next occur and adding full years
(365 days) to simulations in later years.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cumulative_day(
  resultarray,
  plotyearmarkers = TRUE,
  export_peakid = TRUE,
  path = tempdir()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cumulative_day_+3A_resultarray">resultarray</code></td>
<td>
<p>Array containing the full results of
the optimized growth model</p>
</td></tr>
<tr><td><code id="cumulative_day_+3A_plotyearmarkers">plotyearmarkers</code></td>
<td>
<p>Should the location of identified year
transitions be plotted? <code>TRUE/FALSE</code></p>
</td></tr>
<tr><td><code id="cumulative_day_+3A_export_peakid">export_peakid</code></td>
<td>
<p>Should the result of peak identification
be plotted? <code>TRUE/FALSE</code></p>
</td></tr>
<tr><td><code id="cumulative_day_+3A_path">path</code></td>
<td>
<p>Export path (defaults to tempdir())</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A new version of the Julian Day tab of the resultarray
with Julian Day model estimates replaced by estimates of
cumulative age of the record in days.
</p>


<h3>References</h3>

<p>package dependencies: zoo 1.8.7; scales 1.1.0; graphics
function dependencies: peakid
</p>


<h3>Examples</h3>

<pre><code class='language-R'>testarray &lt;- array(NA, dim = c(40, 36, 9)) # Create empty array
# with correct third dimension
windowfill &lt;- seq(50, 500, 50) %% 365 # Create dummy simulation data 
# (ages) to copy through the array
for(i in 6:length(testarray[1, , 1])){
    testarray[, i, 3] &lt;- c(windowfill, rep(NA, length(testarray[, 1, 3]) - 
        length(windowfill)))
    windowfill &lt;- c(NA, (windowfill + 51) %% 365)
}
# Add dummy /code{D} column.
testarray[, 1, 3] &lt;- seq(1, length(testarray[, 1, 3]), 1)
# Add dummy YEARMARKER column
testarray[, 3, 3] &lt;- c(0, rep(c(0, 0, 0, 0, 0, 0, 1), 5), 0, 0, 0, 0)
# Add dummy d18Oc column
testarray[, 2, 3] &lt;- sin((2 * pi * (testarray[, 1, 3] - 8 + 7 / 4)) / 7)
testarray2 &lt;- suppressWarnings(cumulative_day(testarray, FALSE, FALSE, tempdir()))
# Apply function on array
</code></pre>

<hr>
<h2 id='d18O_model'>Function to convert SST data to d18O</h2><span id='topic+d18O_model'></span>

<h3>Description</h3>

<p>Takes a matrix of SST data (in degrees C) against time (in days), information
about the d18O value (in permille VSMOW) of the water and how it changes
through the year and the transfer function used for of the record (e.g.
Kim and O'Neil, 1997 or Grossman and Ku, 1986). Converts the SST data to d18O
data using the supplied empirical transfer function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>d18O_model(SST, d18Ow = 0, transfer_function = "KimONeil97")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="d18O_model_+3A_sst">SST</code></td>
<td>
<p>Matrix with a time column (values in days) and an SST column
(values in degrees C)</p>
</td></tr>
<tr><td><code id="d18O_model_+3A_d18ow">d18Ow</code></td>
<td>
<p>Either a single value (constant d18Ow) or a vector of length
equal to the period in SST data (365 days by default) containing information
about seasonality in d18Ow. Defaults to constant d18Ow of 0 permille VSMOW
(the modern mean ocean value)</p>
</td></tr>
<tr><td><code id="d18O_model_+3A_transfer_function">transfer_function</code></td>
<td>
<p>String containing the name of the transfer function
(for example: <code>"KimONeil97"</code> or <code>"GrossmanKu86"</code>). Defaults to
Kim and O'Neil (1997).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector containing d18O values for each SST value in <code>"SST"</code>
</p>


<h3>References</h3>

<p>Grossman, E.L., Ku, T., Oxygen and carbon isotope fractionation in biogenic
aragonite: temperature effects, <em>Chemical Geology</em> <strong>1986</strong>, <em>59.1</em>, 59-74.
doi: <a href="https://doi.org/10.1016/0168-9622(86)90057-6">10.1016/0168-9622(86)90057-6</a>
Kim, S., O'Niel, J.R., Equilibrium and nonequilibrium oxygen
isotope effects in synthetic carbonates, <em>Geochimica et Cosmochimica Acta</em>
<strong>1997</strong>, <em>61.16</em>, 3461-3475.
doi: <a href="https://doi.org/10.1016/S0016-7037(97)00169-5">10.1016/S0016-7037(97)00169-5</a>
Dettman, D.L., Reische, A.K., Lohmann, K.C., Controls on the stable isotope
composition of seasonal growth bands in aragonitic fresh-water bivalves
(Unionidae), <em>Geochimica et Cosmochimica Acta</em> <strong>1999</strong>, <em>63.7-8</em>, 1049-1057.
doi: <a href="https://doi.org/10.1016/S0016-7037(99)00020-4">10.1016/S0016-7037(99)00020-4</a>
Brand, W.A., Coplen, T.B., Vogl, J., Rosner, M., Prohaska, T., Assessment of
international reference materials for isotope-ratio analysis (IUPAC Technical
Report), <em>Pure and Applied Chemistry</em> <strong>2014</strong>, <em>86.3</em>, 425-467.
doi: <a href="https://doi.org/10.1515/pac-2013-1023">10.1515/pac-2013-1023</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create dummy SST data
t &lt;- seq(1, 40, 1)
T &lt;- sin((2 * pi * (seq(1, 40, 1) - 8 + 10 / 4)) / 10)
SST &lt;- cbind(t, T)
# Run d18O model function
d18O &lt;- d18O_model(SST, 0, "KimONeil97")
</code></pre>

<hr>
<h2 id='data_import'>Function to import d18O data and process yearmarkers and calculation windows</h2><span id='topic+data_import'></span>

<h3>Description</h3>

<p>Takes the name of a file that is formatted according to the standard format
and converts it to an object to be used later in the model. In doing so, the
function also reads the user-provided yearmarkers in the file and uses them
as a basis for the length of windows used throughout the model. This ensures
that windows are not too short and by default contain at least one year of
growth for modeling.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data_import(file_name)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="data_import_+3A_file_name">file_name</code></td>
<td>
<p>Name of the file that contains sampling distance and d18O
data. Note that sampling distance should be given in micrometers, because the
SCEUA model underperforms when the growth rate figures are very small
(&lt;0.1 mm/day).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing an object with the original data and details on
the position and length of modeling windows
</p>


<h3>Examples</h3>

<pre><code class='language-R'>importlist &lt;- data_import(file_name = system.file("extdata",
    "Virtual_shell.csv", package = "ShellChron")) # Run function on attached
    # dummy data

# Bad data file lacking YEARMARKER column
## Not run: importlist &lt;- data_import(file_name = system.file("extdata",
    "Bad_data.csv", package = "ShellChron"))
## End(Not run)
</code></pre>

<hr>
<h2 id='export_results'>Function to merge and export the results of the ShellChron model</h2><span id='topic+export_results'></span>

<h3>Description</h3>

<p>Takes the input data and model results and reformats
them to tables of key parameters such as growth rate
and shell age for each datapoint for easy plotting.
This final function also combines uncertainties in the
model result arising from uncertainties in input data
(provided by the user) and uncertainties of the model
(from overlapping modeling windows).
Includes some optional plotting options.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>export_results(
  path = getwd(),
  dat,
  resultarray,
  parmat,
  MC = 1000,
  dynwindow,
  plot = FALSE,
  plot_export = TRUE,
  export_raw = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="export_results_+3A_path">path</code></td>
<td>
<p>Path where result files are exported</p>
</td></tr>
<tr><td><code id="export_results_+3A_dat">dat</code></td>
<td>
<p>Matrix containing the input data</p>
</td></tr>
<tr><td><code id="export_results_+3A_resultarray">resultarray</code></td>
<td>
<p>Array containing the full results of
the optimized growth model</p>
</td></tr>
<tr><td><code id="export_results_+3A_parmat">parmat</code></td>
<td>
<p>Matrix listing all optimized growth
rate and SST parameters used to model d18O in each data
window</p>
</td></tr>
<tr><td><code id="export_results_+3A_mc">MC</code></td>
<td>
<p>Number of Monte Carlo simulations to apply for
error propagation. Default = 1000</p>
</td></tr>
<tr><td><code id="export_results_+3A_dynwindow">dynwindow</code></td>
<td>
<p>Information on the position and length
of modeling windows</p>
</td></tr>
<tr><td><code id="export_results_+3A_plot">plot</code></td>
<td>
<p>Should an overview of the results of modeling
be plotted? <code>TRUE/FALSE</code></p>
</td></tr>
<tr><td><code id="export_results_+3A_plot_export">plot_export</code></td>
<td>
<p>Should the overview plot be exported as
a PDF file? <code>TRUE/FALSE</code></p>
</td></tr>
<tr><td><code id="export_results_+3A_export_raw">export_raw</code></td>
<td>
<p>Export tables containing all raw model
results before being merged into tidy tables? <code>TRUE/FALSE</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>CSV tables of model results in the current working
directory + optional plots in PDF format
</p>


<h3>References</h3>

<p>package dependencies: tidyverse 1.3.0; ggpubr 0.4.0; magrittr
function dependencies: sd_wt
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create dummy input data column by column
dat &lt;- as.data.frame(seq(1000, 40000, 1000))
colnames(dat) &lt;- "D"
dat$d18Oc &lt;- sin((2 * pi * (seq(1, 40, 1) - 8 + 7 / 4)) / 7)
dat$YEARMARKER &lt;- c(0, rep(c(0, 0, 0, 0, 0, 0, 1), 5), 0, 0, 0, 0)
dat$D_err &lt;- rep(100, 40)
dat$d18Oc_err &lt;- rep(0.1, 40)

testarray &lt;- array(NA, dim = c(40, 36, 9)) # Create empty array
# with correct third dimension
windowfill &lt;- seq(50, 500, 50) %% 365 # Create dummy simulation data 
# (ages) to copy through the array
for(i in 6:length(testarray[1, , 1])){
    testarray[, i, 3] &lt;- c(windowfill, rep(NA, length(testarray[, 1, 3]) -
        length(windowfill)))
    windowfill &lt;- c(NA, (windowfill + 51) %% 365)
}
# Add dummy /code{D} column.
testarray[, 1, 3] &lt;- seq(1, length(testarray[, 1, 3]), 1)
# Add dummy YEARMARKER column
testarray[, 3, 3] &lt;- c(0, rep(c(0, 0, 0, 0, 0, 0, 1), 5), 0, 0, 0, 0)
# Add dummy d18Oc column
testarray[, 2, 3] &lt;- sin((2 * pi * (testarray[, 1, 3] - 8 + 7 / 4)) / 7)
# Create dummy seasonality data
seas &lt;- as.data.frame(seq(1, 365, 1))
colnames(seas) &lt;- "t"
seas$SST &lt;- 15 + 10 * sin((2 * pi * (seq(1, 365, 1) - 182.5 +
    365 / 4)) / 365)
seas$GR &lt;- 10 + 10 * sin((2 * pi * (seq(1, 365, 1) - 100 + 365 / 4)) / 365)
seas$d18O &lt;- (exp((18.03 * 1000 / (seas$SST + 273.15) - 32.42) / 1000) - 1) *
    1000 + (0.97002 * 0 - 29.98)
# Apply dummy seasonality data to generate other tabs of testarray
testarray[, , 1] &lt;- seas$d18O[match(testarray[, , 3], seas$t)] # d18O values
tab &lt;- testarray[, , 1]
tab[which(!is.na(tab))] &lt;- 0.1
testarray[, , 2] &lt;- tab # dummy d18O residuals
testarray[, , 4] &lt;- seas$GR[match(testarray[, , 3], seas$t)] # growth rates
testarray[, , 5] &lt;- seas$SST[match(testarray[, , 3], seas$t)] # temperature
tab[which(!is.na(tab))] &lt;- 0.1
testarray[, , 6] &lt;- tab # dummy d18O SD
tab[which(!is.na(tab))] &lt;- 20
testarray[, , 7] &lt;- tab # dummy time SD
tab[which(!is.na(tab))] &lt;- 3
testarray[, , 8] &lt;- tab # dummy GR SD
tab[which(!is.na(tab))] &lt;- 1
testarray[, , 9] &lt;- tab # dummy temperature SD
darray &lt;- array(rep(as.matrix(dat), 9), dim = c(40, 5, 9))
testarray[, 1:5, ] &lt;- darray

# Create dummy dynwindow data
dynwindow &lt;- as.data.frame(seq(1, 31, 1))
colnames(dynwindow) &lt;- "x"
dynwindow$y &lt;- rep(10, 31)

dimnames(testarray) &lt;- list(
    paste("sample", 1:length(testarray[, 1, 3])),
    c(colnames(dat), paste("window", 1:length(dynwindow$x))),
    c("Modeled_d18O",
        "d18O_residuals",
        "Time_of_year",
        "Instantaneous_growth_rate",
        "Modeled temperature",
        "Modeled_d18O_SD",
        "Time_of_Year_SD",
        "Instantaneous_growth_rate_SD",
        "Modeled_temperature_SD")
)

# Set parameters
G_amp &lt;- 20
G_per &lt;- 365
G_pha &lt;- 100
G_av &lt;- 15
G_skw &lt;- 70
T_amp &lt;- 20
T_per &lt;- 365
T_pha &lt;- 150
T_av &lt;- 15
pars &lt;- c(T_amp, T_pha, T_av, G_amp, G_pha, G_av, G_skw)
parsSD &lt;- c(3, 10, 3, 5, 10, 3, 5) # Artificial variability in parameters
parmat &lt;- matrix(rnorm(length(pars) * length(dynwindow$x)), nrow =
    length(pars)) * parsSD + matrix(rep(pars, length(dynwindow$x)),
    nrow = length(pars))
rownames(parmat) &lt;- c("T_amp", "T_pha", "T_av", "G_amp", "G_pha", "G_av",
    "G_skw")
# Run export function
test &lt;- export_results(path = tempdir(),
    dat,
    testarray,
    parmat,
    MC = 1000,
    dynwindow,
    plot = FALSE,
    plot_export = FALSE,
    export_raw = FALSE)
</code></pre>

<hr>
<h2 id='growth_model'>Function that models a d18O curve through SST and GR sinusoids</h2><span id='topic+growth_model'></span>

<h3>Description</h3>

<p>The core function of the ShellChron growth model. Uses growth
rate and SST (Sea Surface Temperature) sinusoids to model d18O
data to be matched with the input. In the ShellChron modeling
routine, this function is optimized using the SCEUA algorithm
and applied on sliding windows through the dataset to estimate
the age of each datapoint
</p>


<h3>Usage</h3>

<pre><code class='language-R'>growth_model(
  pars,
  T_per = 365,
  G_per = 365,
  years = 1,
  t_int = 1,
  transfer_function = "KimONeil97",
  d18Ow = "default",
  Dsam,
  Osam,
  t_maxtemp = 182.5,
  plot = FALSE,
  MC = 1000,
  D_err = NULL,
  O_err = NULL,
  return = "SSR"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="growth_model_+3A_pars">pars</code></td>
<td>
<p>List of parameters for temperature and growth rate sinusoids
<code>pars &lt;- c(T_amp, T_pha, T_av, G_amp, G_pha, G_av, G_skw)</code></p>
</td></tr>
<tr><td><code id="growth_model_+3A_t_per">T_per</code></td>
<td>
<p>Period of SST sinusoid (in days; default = 365)</p>
</td></tr>
<tr><td><code id="growth_model_+3A_g_per">G_per</code></td>
<td>
<p>Period of growth rate sinusoid (in days; default = 365)</p>
</td></tr>
<tr><td><code id="growth_model_+3A_years">years</code></td>
<td>
<p>Number of years to be modeled (default = 1)</p>
</td></tr>
<tr><td><code id="growth_model_+3A_t_int">t_int</code></td>
<td>
<p>Time interval (in days; default = 1)</p>
</td></tr>
<tr><td><code id="growth_model_+3A_transfer_function">transfer_function</code></td>
<td>
<p>Transfer function used to convert d18Oc to temperature
data.</p>
</td></tr>
<tr><td><code id="growth_model_+3A_d18ow">d18Ow</code></td>
<td>
<p>Either a single value (constant d18Ow) or a vector of length
equal to the period in SST data (365 days by default) containing information
about seasonality in d18Ow. Defaults to constant d18Ow of 0 permille VSMOW
(the modern mean ocean value)</p>
</td></tr>
<tr><td><code id="growth_model_+3A_dsam">Dsam</code></td>
<td>
<p>Vector of <code>D</code> values serving as input (keep unit consistent
throughout model)</p>
</td></tr>
<tr><td><code id="growth_model_+3A_osam">Osam</code></td>
<td>
<p>Vector of <code>d18Oc</code> values serving as input (in permille VPDB)</p>
</td></tr>
<tr><td><code id="growth_model_+3A_t_maxtemp">t_maxtemp</code></td>
<td>
<p>Timing of the warmest day of the year (in julian day;
default = 182.5, or May 26th halfway through the year)</p>
</td></tr>
<tr><td><code id="growth_model_+3A_plot">plot</code></td>
<td>
<p>Should results of modeling be plotted? <code>TRUE/FALSE</code></p>
</td></tr>
<tr><td><code id="growth_model_+3A_mc">MC</code></td>
<td>
<p>Number of Monte Carlo simulations to apply for error propagation
Default = 1000</p>
</td></tr>
<tr><td><code id="growth_model_+3A_d_err">D_err</code></td>
<td>
<p>OPTIONAL: Vector containing errors on <code>Dsam</code></p>
</td></tr>
<tr><td><code id="growth_model_+3A_o_err">O_err</code></td>
<td>
<p>OPTIONAL: Vector containing errors on <code>Osam</code></p>
</td></tr>
<tr><td><code id="growth_model_+3A_return">return</code></td>
<td>
<p>String indicating whether to return just the Sum of Squared
Residuals (&quot;SSR&quot;) or a matrix containing the results of the model and the
propagated uncertainties (if applicable)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Depending on the value of the &quot;return&quot; parameter either a single
value representing the Sum of Squared Residuals (&quot;SSR&quot;) as a measure for
the closeness of the match between modeled d18O and input values, or a
matrix containing the full result of the modeling including propagated
uncertainties if applicable.
</p>


<h3>References</h3>

<p>package dependencies: ggplot2 3.2.1
function dependencies: temperature_curve, d18O_model, growth_rate_curve,
mc_err_orth
</p>
<p>doi: <a href="https://doi.org/10.1016/j.palaeo.2017.09.034">10.1016/j.palaeo.2017.09.034</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Set parameters
G_amp &lt;- 20
G_per &lt;- 365
G_pha &lt;- 100
G_av &lt;- 15
G_skw &lt;- 70
T_amp &lt;- 20
T_per &lt;- 365
T_pha &lt;- 150
T_av &lt;- 15
pars &lt;- c(T_amp, T_pha, T_av, G_amp, G_pha, G_av, G_skw)
d18Ow &lt;- 0
# Create dummy data
Dsam &lt;- seq(1, 40, 1)
Osam &lt;- sin((2 * pi * (seq(1, 40, 1) - 8 + 30 / 4)) / 30)
# Test returning residual sum of squares for optimization
SSR &lt;- growth_model(pars, T_per, G_per, Dsam = Dsam, Osam = Osam,
    return = "SSR")
# Test returning full model result
resmat &lt;- growth_model(pars, T_per, G_per, Dsam = Dsam, Osam = Osam,
    return = "result")
</code></pre>

<hr>
<h2 id='growth_rate_curve'>Function that creates a skewed sinusoidal growth rate (GR) curve
from a list of parameters</h2><span id='topic+growth_rate_curve'></span>

<h3>Description</h3>

<p>Takes the specified parameters for amplitude, period, phase, average value
and skewness factor as well as the number of years specified and the time
interval. It then creates a skewed sinusoid based on the boundary conditions.
The skewness factor (<code>G_skw</code>) determines whether the sinusoid is skewed
towards the front (<code>G_skw &lt; 50</code>) or the back of the annual peak in
growth rate (<code>G_skw &gt; 50</code>).
Used as intermediate step during iterative modeling.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>growth_rate_curve(G_par, years = 1, t_int = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="growth_rate_curve_+3A_g_par">G_par</code></td>
<td>
<p>List of four parameters describing (in order) amplitude
(<code>G_amp</code>; in micrometer/day), period (<code>G_per</code>; in days), phase
(<code>G_pha</code> in day of the year), average growth rate (<code>G_av</code>; in
micrometer/day) and the skewness factor (<code>G_skw</code> between 0 and 100)</p>
</td></tr>
<tr><td><code id="growth_rate_curve_+3A_years">years</code></td>
<td>
<p>Length of the preferred sinusoid in number of years (defaults
to 1)</p>
</td></tr>
<tr><td><code id="growth_rate_curve_+3A_t_int">t_int</code></td>
<td>
<p>Time interval of sinusoidal record (in days)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix containing columns for time (in days) and GR
(in micrometer/day)
</p>


<h3>References</h3>

<p>doi: <a href="https://doi.org/10.1016/j.palaeo.2017.09.034">10.1016/j.palaeo.2017.09.034</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Set parameters
G_amp &lt;- 20
G_per &lt;- 365
G_pha &lt;- 100
G_av &lt;- 15
G_skw &lt;- 70
G_par &lt;- c(G_amp, G_per, G_pha, G_av, G_skw)
# Run GR model function
GR &lt;- growth_rate_curve(G_par, 1, 1)
</code></pre>

<hr>
<h2 id='mc_err_form'>Function that propagates measurement uncertainty through model results</h2><span id='topic+mc_err_form'></span>

<h3>Description</h3>

<p>Function to propagate combined errors on <code>x</code> (= <code>Dsam</code>) and
<code>y</code> (= <code>Osam</code>) on the modeled X (= <code>D</code>) and Y
(= <code>d18Oc</code>) values by means of projection of uncertainties
through the modeled <code>X-Y</code> relationship
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mc_err_form(x, x_err, y, y_err, X, Y, MC = 1000)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mc_err_form_+3A_x">x</code></td>
<td>
<p>Vector of <code>x</code> values of input data</p>
</td></tr>
<tr><td><code id="mc_err_form_+3A_x_err">x_err</code></td>
<td>
<p>Vector of uncertainties on <code>x</code> values</p>
</td></tr>
<tr><td><code id="mc_err_form_+3A_y">y</code></td>
<td>
<p>Vector of <code>y</code> values of input data</p>
</td></tr>
<tr><td><code id="mc_err_form_+3A_y_err">y_err</code></td>
<td>
<p>Vector of uncertainties on <code>y</code> values</p>
</td></tr>
<tr><td><code id="mc_err_form_+3A_x">X</code></td>
<td>
<p>Vector of modeled <code>X</code> values on which the uncertainty is
to be projected</p>
</td></tr>
<tr><td><code id="mc_err_form_+3A_y">Y</code></td>
<td>
<p>Matrix of modeled x and <code>Y</code> values</p>
</td></tr>
<tr><td><code id="mc_err_form_+3A_mc">MC</code></td>
<td>
<p>Number of Monte Carlo simulations to apply for error propagation
Default = 1000</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note: projection leads to large uncertainties on shallow parts of the
<code>X–Y</code> curve
</p>


<h3>Value</h3>

<p>A vector listing the standard deviations of propagated errors
propagated on all <code>X</code> values.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create dummy data for input
x &lt;-  seq(1, 40, 1)
x_err &lt;- rep(0.1, 40)
y &lt;- sin((2 * pi * (seq(1, 40, 1) - 8 + 30 / 4)) / 30)
y_err &lt;- rep(0.1, 40)
X &lt;- seq(1.5, 39.5, 1)
Y &lt;- cbind(seq(1, 39, 1), 0.9 * sin((2 * pi * (seq(1, 39, 1) - 9 +
    25 / 4)) / 25))
# Run function
result &lt;- mc_err_form(x, x_err, y, y_err, X, Y, 1000)
</code></pre>

<hr>
<h2 id='mc_err_orth'>Function that propagates measurement uncertainty through model results</h2><span id='topic+mc_err_orth'></span>

<h3>Description</h3>

<p>Function to propagate combined errors on <code>x</code> (= <code>Dsam</code>) and
<code>y</code> (= <code>Osam</code>) on the modeled X (= <code>D</code>) and Y
(= <code>d18Oc</code>) values by means of orthogonal projection of uncertainty
on <code>x</code> and <code>y</code> onto the model curve
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mc_err_orth(x, x_err, y, y_err, X, Y, MC = 1000)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mc_err_orth_+3A_x">x</code></td>
<td>
<p>Vector of <code>x</code> values of input data</p>
</td></tr>
<tr><td><code id="mc_err_orth_+3A_x_err">x_err</code></td>
<td>
<p>Vector of uncertainties on <code>x</code> values</p>
</td></tr>
<tr><td><code id="mc_err_orth_+3A_y">y</code></td>
<td>
<p>Vector of <code>y</code> values of input data</p>
</td></tr>
<tr><td><code id="mc_err_orth_+3A_y_err">y_err</code></td>
<td>
<p>Vector of uncertainties on <code>y</code> values</p>
</td></tr>
<tr><td><code id="mc_err_orth_+3A_x">X</code></td>
<td>
<p>Vector of modeled <code>X</code> values on which the uncertainty is
to be projected</p>
</td></tr>
<tr><td><code id="mc_err_orth_+3A_y">Y</code></td>
<td>
<p>Matrix of modeled <code>X</code> and <code>Y</code> values</p>
</td></tr>
<tr><td><code id="mc_err_orth_+3A_mc">MC</code></td>
<td>
<p>Number of Monte Carlo simulations to apply for error propagation
Default = 1000</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector listing the standard deviations of propagated errors
propagated on all <code>X</code> values.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create dummy data for input
x &lt;-  seq(1, 40, 1)
x_err &lt;- rep(0.1, 40)
y &lt;- sin((2 * pi * (seq(1, 40, 1) - 8 + 30 / 4)) / 30)
y_err &lt;- rep(0.1, 40)
X &lt;- seq(1.5, 39.5, 1)
Y &lt;- cbind(seq(1, 39, 1), 0.9 * sin((2 * pi * (seq(1, 39, 1) - 9 +
    25 / 4)) / 25))
# Run function
result &lt;- mc_err_orth(x, x_err, y, y_err, X, Y, 1000)
</code></pre>

<hr>
<h2 id='mc_err_proj'>Function that propagates measurement uncertainty through model results</h2><span id='topic+mc_err_proj'></span>

<h3>Description</h3>

<p>Function to propagate combined errors on <code>x</code> (= <code>Dsam</code>) and
<code>y</code> (= <code>Osam</code>) on the modeled X (= <code>D</code>) and Y
(= <code>d18Oc</code>) values by means of direct projection of y–uncertainty
on <code>x</code> and then combine the errors on both in the <code>x</code> domain
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mc_err_proj(x, x_err, y, y_err, X, Y, MC = 1000)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mc_err_proj_+3A_x">x</code></td>
<td>
<p>Vector of <code>x</code> values of input data</p>
</td></tr>
<tr><td><code id="mc_err_proj_+3A_x_err">x_err</code></td>
<td>
<p>Vector of uncertainties on <code>x</code> values</p>
</td></tr>
<tr><td><code id="mc_err_proj_+3A_y">y</code></td>
<td>
<p>Vector of <code>y</code> values of input data</p>
</td></tr>
<tr><td><code id="mc_err_proj_+3A_y_err">y_err</code></td>
<td>
<p>Vector of uncertainties on <code>y</code> values</p>
</td></tr>
<tr><td><code id="mc_err_proj_+3A_x">X</code></td>
<td>
<p>Vector of modeled <code>X</code> values on which the uncertainty is
to be projected</p>
</td></tr>
<tr><td><code id="mc_err_proj_+3A_y">Y</code></td>
<td>
<p>Matrix of modeled x and <code>Y</code> values</p>
</td></tr>
<tr><td><code id="mc_err_proj_+3A_mc">MC</code></td>
<td>
<p>Number of Monte Carlo simulations to apply for error propagation
Default = 1000</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note: projection y_err on x_err leads to large X errors on shallow
slopes due to numerical calculation of fist derivative.
</p>


<h3>Value</h3>

<p>A vector listing the standard deviations of propagated errors
propagated on all <code>X</code> values.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create dummy data for input
x &lt;-  seq(1, 40, 1)
x_err &lt;- rep(0.1, 40)
y &lt;- sin((2 * pi * (seq(1, 40, 1) - 8 + 30 / 4)) / 30)
y_err &lt;- rep(0.1, 40)
X &lt;- seq(1.5, 39.5, 1)
Y &lt;- cbind(seq(1, 39, 1), 0.9 * sin((2 * pi * (seq(1, 39, 1) - 9 +
    25 / 4)) / 25))
# Run function
result &lt;- mc_err_proj(x, x_err, y, y_err, X, Y, 1000)
</code></pre>

<hr>
<h2 id='peakid'>Function that identifies peaks in a dataset</h2><span id='topic+peakid'></span>

<h3>Description</h3>

<p>Developed by William A. Huber
</p>


<h3>Usage</h3>

<pre><code class='language-R'>peakid(x, y, w = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="peakid_+3A_x">x</code></td>
<td>
<p>Vector of <code>x</code> values of input data</p>
</td></tr>
<tr><td><code id="peakid_+3A_y">y</code></td>
<td>
<p>Vector of <code>y</code> values of input data</p>
</td></tr>
<tr><td><code id="peakid_+3A_w">w</code></td>
<td>
<p>Window size for smoothing data</p>
</td></tr>
<tr><td><code id="peakid_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed into LOESS function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector listing the standard deviations of propagated errors
propagated on all <code>X</code> values.
</p>


<h3>References</h3>

<p>package dependencies: zoo 1.8.7
</p>
<p>Huber, W.A., Data Smoothing and Peak Detection, Rpubs,
Last accessed: December 8th, 2020.
<a href="https://rpubs.com/mengxu/peak_detection">https://rpubs.com/mengxu/peak_detection</a>
</p>


<h3>See Also</h3>

<p>https://rpubs.com/mengxu/peak_detection
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create dummy periodic data
x &lt;- seq(1, 100, 1)
y &lt;- sin((2 * pi * (seq(1, 100, 1) - 8 + 20 / 4)) / 20)
# Run peakid function
result &lt;- peakid(x, y, w = 20)
</code></pre>

<hr>
<h2 id='run_model'>Function that optimizes sinusoid parameters to fit d18O data</h2><span id='topic+run_model'></span>

<h3>Description</h3>

<p>The second core function of the ShellChron growth model. Loops
through all data windows and uses the <code>growth_model</code> function
to create d18O series that match the input data. This step is
iterated and optimized (minimizing the Sum of Squared Residuals)
through the SCEUA algorithm (by Duan et al., 1992) which finds
the optimal input parameters to the growth rate and Sea Surface
Temperature (SST) sinusoids to simulate d18O data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>run_model(
  dat,
  dynwindow,
  transfer_function = "KimONeil97",
  d18Ow = 0,
  T_per = 365,
  G_per = 365,
  t_int = 1,
  t_maxtemp = 182.5,
  SCEUApar = c(1, 25, 10000, 5, 0.01, 0.01),
  sinfit = TRUE,
  MC = 1000,
  plot = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="run_model_+3A_dat">dat</code></td>
<td>
<p>Matrix containing the input data</p>
</td></tr>
<tr><td><code id="run_model_+3A_dynwindow">dynwindow</code></td>
<td>
<p>Information on the position and length of modeling
windows</p>
</td></tr>
<tr><td><code id="run_model_+3A_transfer_function">transfer_function</code></td>
<td>
<p>Transfer function used to convert d18Oc to temperature
data.</p>
</td></tr>
<tr><td><code id="run_model_+3A_d18ow">d18Ow</code></td>
<td>
<p>Either a single value (constant d18Ow) or a vector of length
equal to the period in SST data (365 days by default) containing information
about seasonality in d18Ow. Defaults to constant d18Ow of 0 permille VSMOW
(the modern mean ocean value)</p>
</td></tr>
<tr><td><code id="run_model_+3A_t_per">T_per</code></td>
<td>
<p>Period of SST sinusoid (in days; default = 365)</p>
</td></tr>
<tr><td><code id="run_model_+3A_g_per">G_per</code></td>
<td>
<p>Period of growth rate sinusoid (in days; default = 365)</p>
</td></tr>
<tr><td><code id="run_model_+3A_t_int">t_int</code></td>
<td>
<p>Time interval (in days; default = 1)</p>
</td></tr>
<tr><td><code id="run_model_+3A_t_maxtemp">t_maxtemp</code></td>
<td>
<p>Timing of the warmest day of the year (in julian day;
default = 182.5, or May 26th halfway through the year)</p>
</td></tr>
<tr><td><code id="run_model_+3A_sceuapar">SCEUApar</code></td>
<td>
<p>Parameters for SCEUA optimization (iniflg, ngs, maxn, kstop
pcento, peps). For details, refer to Duan et al. (1992) in references</p>
</td></tr>
<tr><td><code id="run_model_+3A_sinfit">sinfit</code></td>
<td>
<p>Apply sinusoidal fitting to guess initial parameters for SCEUA
optimization? <code>TRUE/FALSE</code></p>
</td></tr>
<tr><td><code id="run_model_+3A_mc">MC</code></td>
<td>
<p>Number of Monte Carlo simulations to apply for error propagation
Default = 1000</p>
</td></tr>
<tr><td><code id="run_model_+3A_plot">plot</code></td>
<td>
<p>Should results of modeling be plotted? <code>TRUE/FALSE</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the <code>resultarray</code> which contains the full
result of all simulations on each data window and the <code>parmat</code> listing
all optimized growth rate and SST parameters used to model d18O in each data
window
</p>


<h3>References</h3>

<p>package dependencies: ggplot2 3.2.1; rtop 0.5.14
Function dependencies: sinreg, d18O_model, growth_model
</p>
<p>doi: <a href="https://doi.org/10.1029/91WR02985">10.1029/91WR02985</a>
</p>


<h3>See Also</h3>

<p>Duan, Qingyun, Soroosh Sorooshian, and Vijai Gupta. &quot;Effective and
efficient global optimization for conceptual rainfall runoff models.&quot; Water
resources research 28.4 (1992): 1015-1031. https://doi.org/10.1029/91WR02985
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create dummy input data column by column
dat &lt;- as.data.frame(seq(1000, 40000, 1000))
colnames(dat) &lt;- "D"
dat$d18Oc &lt;- sin((2 * pi * (seq(1, 40, 1) - 8 + 7 / 4)) / 7)
dat$YEARMARKER &lt;- c(0, rep(c(0, 0, 0, 0, 0, 0, 1), 5), 0, 0, 0, 0)
dat$D_err &lt;- rep(100, 40)
dat$d18Oc_err &lt;- rep(0.1, 40)
# Create dummy dynwindow data
dynwindow &lt;- as.data.frame(seq(1, 29, 2))
colnames(dynwindow) &lt;- "x"
dynwindow$y &lt;- rep(12, 15)
# Run model function
resultlist &lt;- run_model(dat = dat,
    dynwindow = dynwindow,
    transfer_function = "KimONeil97",
    d18Ow = 0,
    T_per = 365,
    G_per = 365,
    t_int = 1,
    t_maxtemp = 182.5,
    SCEUApar = c(1, 25, 10000, 5, 0.01, 0.01),
    sinfit = TRUE,
    MC = 1000,
    plot = FALSE)
</code></pre>

<hr>
<h2 id='sd_wt'>Function to calculate weighted standard deviation</h2><span id='topic+sd_wt'></span>

<h3>Description</h3>

<p>Calculates the standard deviation of a weighted sample set
while propagating sample weights through the calculation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sd_wt(x, w, na.rm = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sd_wt_+3A_x">x</code></td>
<td>
<p>Vector containing the values in the set</p>
</td></tr>
<tr><td><code id="sd_wt_+3A_w">w</code></td>
<td>
<p>Vector containing the weights to each value (in
the same order as <code>x</code>
the optimized growth model</p>
</td></tr>
<tr><td><code id="sd_wt_+3A_na.rm">na.rm</code></td>
<td>
<p>Should NA values be removed from the set prior
to calculation? <code>TRUE/FALSE</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>The standard deviation of the weighted set of <code>x</code> values
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create dummy data
x &lt;- seq(1, 10, 0.5)
w &lt;- c(seq(0.1, 1, 0.1), seq(0.9, 0.1, -0.1))
SDw &lt;- sd_wt(x, w, na.rm = TRUE) # Run the function
</code></pre>

<hr>
<h2 id='sinreg'>Function that carries out a sinusoidal regression</h2><span id='topic+sinreg'></span>

<h3>Description</h3>

<p>Fits a sinusoid through data provided as an <code>x</code> and <code>y</code>
vector and returns a list containing both the fitted curve and the
parameters of that curve.
Used to produce initial values for modeling data windows and later
to find peaks in modeled julian day values to align the result to
a cumulative age timeline.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sinreg(x, y, fixed_period = NA, plot = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sinreg_+3A_x">x</code></td>
<td>
<p>Vector of <code>x</code> values of input data</p>
</td></tr>
<tr><td><code id="sinreg_+3A_y">y</code></td>
<td>
<p>Vector of <code>y</code> values of input data</p>
</td></tr>
<tr><td><code id="sinreg_+3A_fixed_period">fixed_period</code></td>
<td>
<p>Optional variable for fixing the period of the sinusoid
in the depth domain. Defaults to <code>NA</code>, period is not fixed. Supply a
single value to fix the period.</p>
</td></tr>
<tr><td><code id="sinreg_+3A_plot">plot</code></td>
<td>
<p>Should the fitting result be plotted? <code>TRUE/FALSE</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing a vector of parameters of the fitted sinusoid
and the fitted values belonging to each <code>x</code> value.
Fitting parameters:
<code>I</code> = the mean annual value of the sinusoid (height)
<code>A</code> = the amplitude of the sinusoid
<code>Dper</code> = the period of the sinusoid in <code>x</code> domain
<code>peak</code> = the location of the peak in the sinusoid
<code>R2adj</code> = the adjusted <code>R^2</code> value of the fit
<code>p</code> = the p-value of the fit
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create dummy data
x &lt;- seq(1000, 11000, 1000)
y &lt;- sin((2 * pi * (seq(1, 11, 1) - 8 + 7 / 4)) / 7)
sinlist &lt;- sinreg(x, y, plot = FALSE) # Run the function
</code></pre>

<hr>
<h2 id='temperature_curve'>Function that creates a sinusoidal Sea Surface Temperature (SST) curve
from a list of parameters</h2><span id='topic+temperature_curve'></span>

<h3>Description</h3>

<p>Takes the specified parameters for amplitude, period, phase and average value
as well as the number of years specified and the time interval. It then
creates a sinusoid based on the boundary conditions. Used as intermediate
step during iterative modeling.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>temperature_curve(T_par, years = 1, t_int = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="temperature_curve_+3A_t_par">T_par</code></td>
<td>
<p>List of four parameters describing (in order) amplitude
(<code>T_amp</code>; in degrees C), period (<code>T_per</code>; in days), phase
(<code>T_pha</code> in day of the year) and average temperature (<code>T_av</code>;
in degrees C)</p>
</td></tr>
<tr><td><code id="temperature_curve_+3A_years">years</code></td>
<td>
<p>Length of the preferred sinusoid in number of years (defaults
to 1)</p>
</td></tr>
<tr><td><code id="temperature_curve_+3A_t_int">t_int</code></td>
<td>
<p>Time interval of sinusoidal record (in days)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix containing columns for time (in days) and SST (in degrees C)
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Set parameters
T_amp &lt;- 20
T_per &lt;- 365
T_pha &lt;- 150
T_av &lt;- 15
T_par &lt;- c(T_amp, T_per, T_pha, T_av)
SST &lt;- temperature_curve(T_par, 1, 1) # Run the function
</code></pre>

<hr>
<h2 id='Virtual_shell'>Virtual input data for ShellChron</h2><span id='topic+Virtual_shell'></span>

<h3>Description</h3>

<p>A dataset containing data used to test the ShellChron functions.
Generated using the code in &quot;Generate_Virtual_shell.r&quot; in <code>data-raw</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Virtual_shell
</code></pre>


<h3>Format</h3>

<p>A data frame with 80 rows and 5 variables:
</p>

<dl>
<dt>D</dt><dd><p>Depth, in <code class="reqn">\mu</code>m along the virtual record</p>
</dd>
<dt>d18Oc</dt><dd><p>stable oxygen isotope value, in permille VPDB</p>
</dd>
<dt>D_err</dt><dd><p>Depth uncertainty, in <code class="reqn">\mu</code>m</p>
</dd>
<dt>d18Oc_err</dt><dd><p>stable oxygen isotope value uncertainty, in permille VPDB</p>
</dd>
<dt>YEARMARKER</dt><dd><p>&quot;1&quot; marking year transitions</p>
</dd>
</dl>
<p>...

</p>


<h3>Source</h3>

<p>See code to generate data in <code>data-raw</code>
Modified after virtual data described in de Winter et al., 2021
<a href="https://doi.org/gk98">https://doi.org/gk98</a>
</p>

<hr>
<h2 id='wrap_function'>Full ShellChron workflow wrapped in a single function</h2><span id='topic+wrap_function'></span>

<h3>Description</h3>

<p>Takes starting parameters and names of input files
and directory and runs through all the steps of the
ShellChron model. Function includes options for plotting
and exporting raw data, which are parsed into underlying
formulae.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wrap_function(
  path = getwd(),
  file_name,
  transfer_function = "KimONeil97",
  t_int = 1,
  T_per = 365,
  d18Ow = 0,
  t_maxtemp = 182.5,
  SCEUApar = c(1, 25, 10000, 5, 0.01, 0.01),
  sinfit = TRUE,
  MC = 1000,
  plot = TRUE,
  plot_export = TRUE,
  export_raw = FALSE,
  export_path = getwd()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wrap_function_+3A_path">path</code></td>
<td>
<p>String containing the path to the directory
that contains the input data.</p>
</td></tr>
<tr><td><code id="wrap_function_+3A_file_name">file_name</code></td>
<td>
<p>Name of the file that contains d18O data</p>
</td></tr>
<tr><td><code id="wrap_function_+3A_transfer_function">transfer_function</code></td>
<td>
<p>String containing the name of the
transfer function. Defaults to Kim and O'Neil, 1997.</p>
</td></tr>
<tr><td><code id="wrap_function_+3A_t_int">t_int</code></td>
<td>
<p>Time interval (in days; default = 1)</p>
</td></tr>
<tr><td><code id="wrap_function_+3A_t_per">T_per</code></td>
<td>
<p>Period of SST sinusoid (in days;
default = 365)</p>
</td></tr>
<tr><td><code id="wrap_function_+3A_d18ow">d18Ow</code></td>
<td>
<p>Either a single value (constant d18Ow)
or a vector of length equal to the period in SST data
(365 days by default) containing information about
seasonality in d18Ow. Defaults to constant d18Ow of
0 permille VSMOW (the modern mean ocean value)</p>
</td></tr>
<tr><td><code id="wrap_function_+3A_t_maxtemp">t_maxtemp</code></td>
<td>
<p>Timing of the warmest day of the year
(in julian day; default = 182.5, or May 26th halfway
through the year)</p>
</td></tr>
<tr><td><code id="wrap_function_+3A_sceuapar">SCEUApar</code></td>
<td>
<p>Parameters for SCEUA optimization (iniflg, ngs, maxn, kstop
pcento, peps) For details, refer to Duan et al. (1992) in references</p>
</td></tr>
<tr><td><code id="wrap_function_+3A_sinfit">sinfit</code></td>
<td>
<p>Apply sinusoidal fitting to guess initial parameters for SCEUA
optimization? <code>TRUE/FALSE</code></p>
</td></tr>
<tr><td><code id="wrap_function_+3A_mc">MC</code></td>
<td>
<p>Number of Monte Carlo simulations to apply for
error propagation. Default = 1000</p>
</td></tr>
<tr><td><code id="wrap_function_+3A_plot">plot</code></td>
<td>
<p>Should an overview of the results of modeling
be plotted? <code>TRUE/FALSE</code></p>
</td></tr>
<tr><td><code id="wrap_function_+3A_plot_export">plot_export</code></td>
<td>
<p>Should the overview plot be exported as
a PDF file? <code>TRUE/FALSE</code></p>
</td></tr>
<tr><td><code id="wrap_function_+3A_export_raw">export_raw</code></td>
<td>
<p>Export tables containing all raw model
results before being merged into tidy tables? <code>TRUE/FALSE</code></p>
</td></tr>
<tr><td><code id="wrap_function_+3A_export_path">export_path</code></td>
<td>
<p>Path where result files are exported</p>
</td></tr>
</table>


<h3>Value</h3>

<p>CSV tables of model results in the current working
directory, optional plots in PDF format and list object of
model results for further processing in the R workspace.
</p>


<h3>References</h3>

<p>function dependencies: data_import, run_model, cumulative_day,
export_results
</p>


<h3>Examples</h3>

<pre><code class='language-R'># find attached dummy data
example &lt;- wrap_function(path = getwd(),
    file_name = system.file("extdata", "Virtual_shell.csv",
    package = "ShellChron"),
    transfer_function = "KimONeil97",
    t_int = 1,
    T_per = 365,
    d18Ow = 0,
    t_maxtemp = 182.5,
    SCEUApar = c(1, 25, 10000, 5, 0.01, 0.01),
    sinfit = TRUE,
    MC = 1000,
    plot = FALSE,
    plot_export = FALSE,
    export_raw = FALSE,
    export_path = tempdir()) # Run function
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
