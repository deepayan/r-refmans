<!DOCTYPE html><html lang="en"><head><title>Help for package inTrees</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {inTrees}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#applyLearner'>
<p>apply a simplified tree ensemble learner (STEL) to data</p></a></li>
<li><a href='#buildLearner'>
<p>build a simplified tree ensemble learner (STEL)</p></a></li>
<li><a href='#computeRuleInfor'>
<p>compute rule information</p></a></li>
<li><a href='#dataSimulate'>
<p>Simulate data</p></a></li>
<li><a href='#dicretizeVector'>
<p>discretize a variable</p></a></li>
<li><a href='#extractRules'>
<p>Extract rules from a list of trees</p></a></li>
<li><a href='#formatGBM'>
<p>internal</p></a></li>
<li><a href='#GBM2List'>
<p>Transform gbm object to a list of trees</p></a></li>
<li><a href='#getFreqPattern'>
<p>calculate frequent variable interactions</p></a></li>
<li><a href='#getRuleMetric'>
<p>Assign outcomes to a conditions, and measure the rules</p></a></li>
<li><a href='#getTypeX'>
<p>get type of each variable</p></a></li>
<li><a href='#lookupRule'>
<p>internal</p></a></li>
<li><a href='#measureRule'>
<p>internal</p></a></li>
<li><a href='#Num2Level'>
<p>internal function</p></a></li>
<li><a href='#presentRules'>
<p>Present a learner using column names instead of X[i,]</p></a></li>
<li><a href='#pruneRule'>
<p>Prune irrevant variable-value pair from a rule condition</p></a></li>
<li><a href='#pruneSingleRule'>
<p>internal</p></a></li>
<li><a href='#RF2List'>
<p>Transform a random forest object to a list of trees</p></a></li>
<li><a href='#rule2Table'>
<p>internal function</p></a></li>
<li><a href='#ruleList2Exec'>
<p>internal</p></a></li>
<li><a href='#selectRuleRRF'>
<p>select a set of relevant and non-redundant rules</p></a></li>
<li><a href='#singleRuleList2Exec'>
<p>internal</p></a></li>
<li><a href='#sortRule'>
<p>internal</p></a></li>
<li><a href='#treeVisit'>
<p>internal function</p></a></li>
<li><a href='#voteAllRules'>
<p>internal</p></a></li>
<li><a href='#XGB2List'>
<p>Transform an xgboost object to a list of trees</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Interpret Tree Ensembles</td>
</tr>
<tr>
<td>Version:</td>
<td>1.4</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-04-22</td>
</tr>
<tr>
<td>Imports:</td>
<td>RRF, arules, gbm, xtable, xgboost, data.table, methods</td>
</tr>
<tr>
<td>Description:</td>
<td>For tree ensembles such as random forests, regularized random forests and gradient boosted trees, this package provides functions for: extracting, measuring and pruning rules; selecting a compact rule set; summarizing rules into a learner; calculating frequent variable interactions; formatting rules in latex code.  Reference: Interpreting tree ensembles with inTrees (Houtao Deng, 2019, &lt;<a href="https://doi.org/10.1007%2Fs41060-018-0144-8">doi:10.1007/s41060-018-0144-8</a>&gt;).</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Houtao Deng &lt;softwaredeng@gmail.com&gt;</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/softwaredeng/inTrees/issues">https://github.com/softwaredeng/inTrees/issues</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-04-23 05:26:26 UTC; houtaodeng</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-04-23 06:10:03 UTC</td>
</tr>
<tr>
<td>Author:</td>
<td>Houtao Deng [aut, cre],
  Xin Guan [aut],
  Vadim Khotilovich [aut]</td>
</tr>
</table>
<hr>
<h2 id='applyLearner'>
apply a simplified tree ensemble learner (STEL) to data
</h2><span id='topic+applyLearner'></span>

<h3>Description</h3>

<p>apply STEL to data and get predictions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>applyLearner(learner, X)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="applyLearner_+3A_learner">learner</code></td>
<td>

<p>a matrix with rules ordered by priority
</p>
</td></tr>
<tr><td><code id="applyLearner_+3A_x">X</code></td>
<td>

<p>predictor variable matrix
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>predictions for the data
</p>


<h3>See Also</h3>

<p><code><a href="#topic+buildLearner">buildLearner</a></code>
</p>

<hr>
<h2 id='buildLearner'>
build a simplified tree ensemble learner (STEL)
</h2><span id='topic+buildLearner'></span>

<h3>Description</h3>

<p>Build a simplified tree ensemble learner (STEL). Currently works only for classification problems. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>buildLearner(ruleMetric, X, target, minFreq = 0.01)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="buildLearner_+3A_rulemetric">ruleMetric</code></td>
<td>

<p>a matrix including the conditions, predictions, and and metrics
</p>
</td></tr>
<tr><td><code id="buildLearner_+3A_x">X</code></td>
<td>

<p>predictor variable matrix
</p>
</td></tr>
<tr><td><code id="buildLearner_+3A_target">target</code></td>
<td>

<p>target variable
</p>
</td></tr>
<tr><td><code id="buildLearner_+3A_minfreq">minFreq</code></td>
<td>

<p>minimum frequency of a rule condition in order to be included in STEL. 
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix including the conditions, prediction, and metrics, ordered by priority.
</p>


<h3>Author(s)</h3>

<p>Houtao Deng
</p>


<h3>References</h3>

<p>Houtao Deng, Interpreting Tree Ensembles with inTrees, technical report, 2014
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(iris)
library(RRF)
X &lt;- iris[,1:(ncol(iris)-1)]
target &lt;- iris[,"Species"] 
rf &lt;- RRF(X,as.factor(target),ntree=100) # build an ordinary RF 
treeList &lt;- RF2List(rf)
ruleExec &lt;- extractRules(treeList,X)
ruleExec &lt;- unique(ruleExec)
ruleMetric &lt;- getRuleMetric(ruleExec,X,target) # measure rules
ruleMetric &lt;- pruneRule(ruleMetric,X,target) # prune each rule
#ruleMetric &lt;- selectRuleRRF(ruleMetric,X,target) # rule selection
learner &lt;- buildLearner(ruleMetric,X,target)
pred &lt;- applyLearner(learner,X)
read &lt;- presentRules(learner,colnames(X)) # more readable format

# format the rule and metrics as a table in latex code
library(xtable)
print(xtable(read), include.rownames=FALSE)
print(xtable(ruleMetric[1:2,]), include.rownames=FALSE)

</code></pre>

<hr>
<h2 id='computeRuleInfor'>
compute rule information
</h2><span id='topic+computeRuleInfor'></span>

<h3>Description</h3>

<p>compute rule information
</p>


<h3>Usage</h3>

<pre><code class='language-R'>computeRuleInfor(instIx, pred, target)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="computeRuleInfor_+3A_instix">instIx</code></td>
<td>
 
<p>indices of the intances
</p>
</td></tr>
<tr><td><code id="computeRuleInfor_+3A_pred">pred</code></td>
<td>

<p>prediction from a rule
</p>
</td></tr>
<tr><td><code id="computeRuleInfor_+3A_target">target</code></td>
<td>

<p>target values for the instances
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>return error and frequency
</p>


<h3>Examples</h3>

<pre><code class='language-R'>	# this is an internal function.
</code></pre>

<hr>
<h2 id='dataSimulate'>
Simulate data
</h2><span id='topic+dataSimulate'></span>

<h3>Description</h3>

<p>Simulate data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dataSimulate(flag = 1, nCol = 20, nRow = 1000)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dataSimulate_+3A_flag">flag</code></td>
<td>
<p>1 (default): team optimization; 2: non-linear; 3: linear. 
</p>
</td></tr>
<tr><td><code id="dataSimulate_+3A_ncol">nCol</code></td>
<td>
<p>the number of columns in the data set. must &gt;= 2. 
</p>
</td></tr>
<tr><td><code id="dataSimulate_+3A_nrow">nRow</code></td>
<td>
<p>the number of rows in the data set.  
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>predictor variable matrix and target variable
</p>


<h3>Examples</h3>

<pre><code class='language-R'>res &lt;- dataSimulate(flag=1)
X &lt;- res$X; 
target &lt;- res$target
</code></pre>

<hr>
<h2 id='dicretizeVector'>
discretize a variable
</h2><span id='topic+dicretizeVector'></span>

<h3>Description</h3>

<p>discretize a variable
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dicretizeVector(v, K = 3)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dicretizeVector_+3A_v">v</code></td>
<td>
 
<p>vector
</p>
</td></tr>
<tr><td><code id="dicretizeVector_+3A_k">K</code></td>
<td>

<p>discretize into up to K levels with equal frequency
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>discretized levels for v
</p>


<h3>Examples</h3>

<pre><code class='language-R'> data(iris)
 dicretizeVector(iris[,1],3)
</code></pre>

<hr>
<h2 id='extractRules'>
Extract rules from a list of trees
</h2><span id='topic+extractRules'></span>

<h3>Description</h3>

<p>Extract rule conditions from a list of trees. Use functions RF2List/GBM2List to transform RF/GBM objects to list of trees. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extractRules(treeList, X, ntree = 100, maxdepth = 6, random = FALSE, digits = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="extractRules_+3A_treelist">treeList</code></td>
<td>

<p>tree list
</p>
</td></tr>
<tr><td><code id="extractRules_+3A_x">X</code></td>
<td>

<p>predictor variable matrix
</p>
</td></tr>
<tr><td><code id="extractRules_+3A_ntree">ntree</code></td>
<td>

<p>conditions are extracted from the first ntree trees 
</p>
</td></tr>
<tr><td><code id="extractRules_+3A_maxdepth">maxdepth</code></td>
<td>

<p>conditions are extracted from the top maxdepth levels from each tree
</p>
</td></tr>
<tr><td><code id="extractRules_+3A_random">random</code></td>
<td>

<p>the max depth for each tree is an integer randomly chosen between 1 and maxdepth
</p>
</td></tr>
<tr><td><code id="extractRules_+3A_digits">digits</code></td>
<td>

<p>digits for rounding
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a set of rule conditions
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    library(RRF)
    data(iris)
    X &lt;- iris[,1:(ncol(iris)-1)]
    target &lt;- iris[,"Species"] 
    rf &lt;- RRF(X,as.factor(target),ntree=100) # build an ordinary RF 
    treeList &lt;- RF2List(rf)
    ruleExec &lt;- extractRules(treeList,X,digits=4) # transform to R-executable rules
    ruleExec &lt;- unique(ruleExec)
</code></pre>

<hr>
<h2 id='formatGBM'>
internal
</h2><span id='topic+formatGBM'></span>

<h3>Description</h3>

<p>internal
</p>


<h3>Usage</h3>

<pre><code class='language-R'>formatGBM(gbmList, splitBin,X)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="formatGBM_+3A_gbmlist">gbmList</code></td>
<td>

</td></tr>
<tr><td><code id="formatGBM_+3A_splitbin">splitBin</code></td>
<td>

</td></tr>
<tr><td><code id="formatGBM_+3A_x">X</code></td>
<td>

<p>predictor variable matrix
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##---- Should be DIRECTLY executable !! ----
##-- ==&gt;  Define data, use random,
##--	or do  help(data=index)  for the standard data sets.

## The function is currently defined as
function (gbmList, splitBin,X) 
{
    for (j in 1:length(gbmList$list)) {
        a &lt;- gbmList$list[[j]]
        rownames(a) &lt;- 1:nrow(a)
        a$status &lt;- a$SplitVar
        a &lt;- a[, c("LeftNode", "RightNode", "MissingNode", "SplitVar", 
            "SplitCodePred", "status")]
        a[which(a[, "SplitVar"] &gt;= 0), c("SplitVar", "LeftNode", 
            "RightNode", "MissingNode")] &lt;- a[which(a[, "SplitVar"] &gt;= 
            0), c("SplitVar", "LeftNode", "RightNode", "MissingNode")] + 
            1
        ix &lt;- a$MissingNode[which(a$MissingNode &gt; 0)]
        if (length(ix) &gt; 0) 
            a$status[ix] &lt;- 10
        a &lt;- a[, c("LeftNode", "RightNode", "SplitVar", "SplitCodePred", 
            "status")]
        cat &lt;- which(sapply(X, is.factor) &amp; !sapply(X, is.ordered))
        ix &lt;- which(a[, "SplitVar"] %in% cat)
        for (i in ix) a[i, "SplitCodePred"] &lt;- splitBin[a[i, 
            "SplitCodePred"] + 1]
        colnames(a) &lt;- c("left daughter", "right daughter", "split var", 
            "split point", "status")
        gbmList$list[[j]] &lt;- a
    }
    return(gbmList)
  }
</code></pre>

<hr>
<h2 id='GBM2List'>
Transform gbm object to a list of trees
</h2><span id='topic+GBM2List'></span>

<h3>Description</h3>

<p>Transform gbm object to a list of trees that can be used for rule condition extraction
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GBM2List(gbm1,X)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="GBM2List_+3A_gbm1">gbm1</code></td>
<td>

<p>gbm object
</p>
</td></tr>
<tr><td><code id="GBM2List_+3A_x">X</code></td>
<td>

<p>predictor variable matrix
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of trees in an inTrees-required format
</p>


<h3>See Also</h3>

<p><code><a href="#topic+RF2List">RF2List</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    library(gbm)
    data(iris)
    X &lt;- iris[,1:(ncol(iris)-1)]
    target &lt;- iris[,"Species"] 
    gbmFit &lt;- gbm(Species~ ., data=iris, n.tree = 400,
                    interaction.depth = 10,distribution="multinomial")
    treeList &lt;- GBM2List(gbmFit,X)
    ruleExec = extractRules(treeList,X)
    ruleExec &lt;- unique(ruleExec)
    #ruleExec &lt;- ruleExec[1:min(2000,length(ruleExec)),,drop=FALSE]
    ruleMetric &lt;- getRuleMetric(ruleExec,X,target)
    ruleMetric &lt;- pruneRule(ruleMetric,X,target)
    ruleMetric &lt;- unique(ruleMetric)
    learner &lt;- buildLearner(ruleMetric,X,target)
    pred &lt;- applyLearner(learner,X)
    readableLearner &lt;- presentRules(learner,colnames(X)) # more readable format
    err &lt;- 1-sum(pred==target)/length(pred);
</code></pre>

<hr>
<h2 id='getFreqPattern'>
calculate frequent variable interactions
</h2><span id='topic+getFreqPattern'></span>

<h3>Description</h3>

<p>calculate frequent variable interactions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getFreqPattern(ruleMetric, minsup = 0.01, minconf = 0.5, minlen = 1, maxlen = 4)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getFreqPattern_+3A_rulemetric">ruleMetric</code></td>
<td>

<p>a matrix including conditions, predictions, and the metrics
</p>
</td></tr>
<tr><td><code id="getFreqPattern_+3A_minsup">minsup</code></td>
<td>

<p>minimum support of conditions in a tree ensemble
</p>
</td></tr>
<tr><td><code id="getFreqPattern_+3A_minconf">minconf</code></td>
<td>

<p>minimum confidence of the rules
</p>
</td></tr>
<tr><td><code id="getFreqPattern_+3A_minlen">minlen</code></td>
<td>

<p>minimum length of the conditions
</p>
</td></tr>
<tr><td><code id="getFreqPattern_+3A_maxlen">maxlen</code></td>
<td>

<p>max length of the conditions
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix including frequent variable interations (in a form of conditions),  predictions, length, support, and confidence.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(RRF)
library(arules)
data(iris)
X &lt;- iris[,1:(ncol(iris)-1)]
target &lt;- iris[,"Species"] 
rf &lt;- RRF(X,as.factor(target),ntree=100) # build an ordinary RF 
treeList &lt;- RF2List(rf)
ruleExec &lt;- extractRules(treeList,X) # transform to R-executable rules
ruleMetric &lt;- getRuleMetric(ruleExec,X,target) 
freqPattern &lt;- getFreqPattern(ruleMetric)
freqPatternMetric &lt;- getRuleMetric(freqPattern,X,target)
</code></pre>

<hr>
<h2 id='getRuleMetric'>
Assign outcomes to a conditions, and measure the rules
</h2><span id='topic+getRuleMetric'></span>

<h3>Description</h3>

<p>Assign outcomes to a conditions, and measure the rules
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getRuleMetric(ruleExec, X, target)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getRuleMetric_+3A_ruleexec">ruleExec</code></td>
<td>

<p>a set of rule conditions
</p>
</td></tr>
<tr><td><code id="getRuleMetric_+3A_x">X</code></td>
<td>

<p>predictor variable matrix
</p>
</td></tr>
<tr><td><code id="getRuleMetric_+3A_target">target</code></td>
<td>

<p>target variable
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix including the condictions, predictions, and metrics
</p>


<h3>References</h3>

<p>Houtao Deng, Interpreting Tree Ensembles with inTrees, technical report, 2014
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(RRF)
data(iris)
X &lt;- iris[,1:(ncol(iris)-1)]
target &lt;- iris[,"Species"] 
rf &lt;- RRF(X,as.factor(target),ntree=100) # build an ordinary RF 
treeList &lt;- RF2List(rf)
ruleExec &lt;- extractRules(treeList,X) # transform to R-executable rules
ruleExec &lt;- unique(ruleExec)
ruleMetric &lt;- getRuleMetric(ruleExec,X,target) # measure rules
</code></pre>

<hr>
<h2 id='getTypeX'>
get type of each variable
</h2><span id='topic+getTypeX'></span>

<h3>Description</h3>

<p>get type of each variable: numeric or categorical
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getTypeX(X)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getTypeX_+3A_x">X</code></td>
<td>

</td></tr>
</table>


<h3>Value</h3>

<p>A vector indicating each variable's type: numeric: 1; categorical: 2
</p>

<hr>
<h2 id='lookupRule'>
internal
</h2><span id='topic+lookupRule'></span>

<h3>Description</h3>

<p>internal
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lookupRule(rules, strList)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lookupRule_+3A_rules">rules</code></td>
<td>

</td></tr>
<tr><td><code id="lookupRule_+3A_strlist">strList</code></td>
<td>

</td></tr>
</table>


<h3>Value</h3>

<p>rules that matched to strList
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##---- Should be DIRECTLY executable !! ----
##-- ==&gt;  Define data, use random,
##--	or do  help(data=index)  for the standard data sets.

## The function is currently defined as
function (rules, strList) 
{
    ix &lt;- grep(strList[1], rules[, "condition"])
    if (length(strList) &gt;= 2) {
        for (i in 2:length(strList)) {
            ix2 &lt;- grep(strList[i], rules[, "condition"])
            ix &lt;- intersect(ix, ix2)
        }
    }
    if (length(ix) &gt;= 1) 
        return(rules[ix, , drop = FALSE])
    if (length(ix) == 0) 
        return(NULL)
  }
</code></pre>

<hr>
<h2 id='measureRule'>
internal
</h2><span id='topic+measureRule'></span>

<h3>Description</h3>

<p>internal
</p>


<h3>Usage</h3>

<pre><code class='language-R'>measureRule(ruleExec, X, target, pred = NULL, regMethod = "mean")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="measureRule_+3A_ruleexec">ruleExec</code></td>
<td>

</td></tr>
<tr><td><code id="measureRule_+3A_x">X</code></td>
<td>

</td></tr>
<tr><td><code id="measureRule_+3A_target">target</code></td>
<td>

</td></tr>
<tr><td><code id="measureRule_+3A_pred">pred</code></td>
<td>

</td></tr>
<tr><td><code id="measureRule_+3A_regmethod">regMethod</code></td>
<td>

</td></tr>
</table>


<h3>Value</h3>

<p>data frame including rule's length, frequency, error, rule condition and prediction
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##---- Should be DIRECTLY executable !! ----
##-- ==&gt;  Define data, use random,
##--	or do  help(data=index)  for the standard data sets.

## The function is currently defined as
function (ruleExec, X, target, pred = NULL) 
{
    len &lt;- length(unlist(strsplit(ruleExec, split = " &amp; ")))
    origRule &lt;- ruleExec
    ruleExec &lt;- paste("which(", ruleExec, ")")
    ixMatch &lt;- eval(parse(text = ruleExec))
    if (length(ixMatch) == 0) {
        v &lt;- c("-1", "-1", "-1", "", "")
        names(v) &lt;- c("len", "freq", "err", "condition", "pred")
        return(v)
    }
    ys &lt;- target[ixMatch]
    freq &lt;- round(length(ys)/nrow(X), digits = 3)
    if (is.numeric(target)) {
        ysMost &lt;- mean(ys)
        err &lt;- sum((ysMost - ys)^2)/length(ys)
    }
    else {
        if (length(pred) &gt; 0) {
            ysMost = pred
        }
        else {
            ysMost &lt;- names(which.max(table(ys)))
        }
        conf &lt;- round(table(ys)[ysMost]/sum(table(ys)), digits = 3)
        err &lt;- 1 - conf
    }
    rule &lt;- origRule
    v &lt;- c(len, freq, err, rule, ysMost)
    names(v) &lt;- c("len", "freq", "err", "condition", "pred")
    return(v)
  }
</code></pre>

<hr>
<h2 id='Num2Level'>
internal function
</h2><span id='topic+Num2Level'></span>

<h3>Description</h3>

<p>internal function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Num2Level(rfList, splitV)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Num2Level_+3A_rflist">rfList</code></td>
<td>

</td></tr>
<tr><td><code id="Num2Level_+3A_splitv">splitV</code></td>
<td>

</td></tr>
</table>


<h3>Value</h3>

<p>data frame with numeric variables converted to categorical variables. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##---- Should be DIRECTLY executable !! ----
##-- ==&gt;  Define data, use random,
##--	or do  help(data=index)  for the standard data sets.

## The function is currently defined as
function (rfList, splitV) 
{
    for (i in 1:rfList$ntree) {
        rfList$list[[i]] &lt;- data.frame(rfList$list[[i]])
        rfList$list[[i]][, "prediction"] &lt;- data.frame(dicretizeVector(rfList$list[[i]][, 
            "prediction"], splitV))
        colnames(rfList$list[[i]]) &lt;- c("left daughter", "right daughter", 
            "split var", "split point", "status", "prediction")
    }
    return(rfList)
  }
</code></pre>

<hr>
<h2 id='presentRules'>
Present a learner using column names instead of X[i,]
</h2><span id='topic+presentRules'></span>

<h3>Description</h3>

<p>Present a learner using column names instead of X[i,]
</p>


<h3>Usage</h3>

<pre><code class='language-R'>presentRules(rules, colN, digits)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="presentRules_+3A_rules">rules</code></td>
<td>

<p>a set of rules
</p>
</td></tr>
<tr><td><code id="presentRules_+3A_coln">colN</code></td>
<td>

<p>a vector including the column names
</p>
</td></tr>
<tr><td><code id="presentRules_+3A_digits">digits</code></td>
<td>

<p>digits for rounding
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix including the conditions (with column names), etc.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+buildLearner">buildLearner</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> # See function "buildLearner"
</code></pre>

<hr>
<h2 id='pruneRule'>
Prune irrevant variable-value pair from a rule condition
</h2><span id='topic+pruneRule'></span>

<h3>Description</h3>

<p>Prune irrevant variable-value pair from a rule condition
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pruneRule(rules, X, target, maxDecay = 0.05, typeDecay = 2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pruneRule_+3A_rules">rules</code></td>
<td>

<p>A metrix including the rules and metrics
</p>
</td></tr>
<tr><td><code id="pruneRule_+3A_x">X</code></td>
<td>

<p>predictor variable matrix
</p>
</td></tr>
<tr><td><code id="pruneRule_+3A_target">target</code></td>
<td>

<p>target variable vector
</p>
</td></tr>
<tr><td><code id="pruneRule_+3A_maxdecay">maxDecay</code></td>
<td>

<p>threshold of decay
</p>
</td></tr>
<tr><td><code id="pruneRule_+3A_typedecay">typeDecay</code></td>
<td>

<p>1: relative error; 2: error; default :2
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix including the rules each being pruned, and metrics
</p>


<h3>Author(s)</h3>

<p>Houtao Deng
</p>


<h3>References</h3>

<p>Houtao Deng, Interpreting Tree Ensembles with inTrees, technical report, 2014
</p>


<h3>See Also</h3>

<p><code><a href="#topic+buildLearner">buildLearner</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># see function "buildLearner"
</code></pre>

<hr>
<h2 id='pruneSingleRule'>
internal
</h2><span id='topic+pruneSingleRule'></span>

<h3>Description</h3>

<p>internal
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pruneSingleRule(rule, X, target, maxDecay, typeDecay)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pruneSingleRule_+3A_rule">rule</code></td>
<td>

</td></tr>
<tr><td><code id="pruneSingleRule_+3A_x">X</code></td>
<td>

</td></tr>
<tr><td><code id="pruneSingleRule_+3A_target">target</code></td>
<td>

</td></tr>
<tr><td><code id="pruneSingleRule_+3A_maxdecay">maxDecay</code></td>
<td>

</td></tr>
<tr><td><code id="pruneSingleRule_+3A_typedecay">typeDecay</code></td>
<td>

</td></tr>
</table>


<h3>Value</h3>

<p>a pruned rule and its metrics. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##---- Should be DIRECTLY executable !! ----
##-- ==&gt;  Define data, use random,
##--	or do  help(data=index)  for the standard data sets.

## The function is currently defined as
function (rule, X, target, maxDecay, typeDecay) 
{
    newRuleMetric &lt;- measureRule(rule["condition"], X, target)
    errOrig &lt;- as.numeric(newRuleMetric["err"])
    ruleV &lt;- unlist(strsplit(rule["condition"], split = " &amp; "))
    pred &lt;- rule["pred"]
    if (length(ruleV) == 1) 
        return(newRuleMetric)
    for (i in length(ruleV):1) {
        restRule &lt;- ruleV[-i]
        restRule &lt;- paste(restRule, collapse = " &amp; ")
        metricTmp &lt;- measureRule(restRule, X, target, pred)
        errNew &lt;- as.numeric(metricTmp["err"])
        if (typeDecay == 1) {
            decay &lt;- (errNew - errOrig)/max(errOrig, 1e-06)
        }
        else {
            decay &lt;- (errNew - errOrig)
        }
        if (decay &lt;= maxDecay) {
            ruleV &lt;- ruleV[-i]
            newRuleMetric &lt;- metricTmp
            if (length(ruleV) &lt;= 1) 
                break
        }
    }
    return(newRuleMetric)
  }
</code></pre>

<hr>
<h2 id='RF2List'>
Transform a random forest object to a list of trees
</h2><span id='topic+RF2List'></span>

<h3>Description</h3>

<p>Transform a random forest object to a list of trees
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RF2List(rf)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="RF2List_+3A_rf">rf</code></td>
<td>

<p>random forest object
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of trees 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+GBM2List">GBM2List</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(RRF)
data(iris)
X &lt;- iris[,1:(ncol(iris)-1)]
target &lt;- iris[,"Species"] 
rf &lt;- RRF(X,as.factor(target),ntree=100) # build an ordinary RF 
treeList &lt;- RF2List(rf)
ruleExec &lt;- extractRules(treeList,X) # transform to R-executable rules
</code></pre>

<hr>
<h2 id='rule2Table'>
internal function
</h2><span id='topic+rule2Table'></span>

<h3>Description</h3>

<p>internal function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rule2Table(ruleExec, X, target)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rule2Table_+3A_ruleexec">ruleExec</code></td>
<td>

</td></tr>
<tr><td><code id="rule2Table_+3A_x">X</code></td>
<td>

</td></tr>
<tr><td><code id="rule2Table_+3A_target">target</code></td>
<td>

</td></tr>
</table>


<h3>Value</h3>

<p>a matrix of indicators matching each rule condition and each row of data 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##---- Should be DIRECTLY executable !! ----
##-- ==&gt;  Define data, use random,
##--	or do  help(data=index)  for the standard data sets.

## The function is currently defined as
function (ruleExec, X, target) 
{
    I &lt;- rep(0, nrow(X))
    ruleExec &lt;- paste("which(", ruleExec, ")")
    ixMatch &lt;- eval(parse(text = ruleExec))
    if (length(ixMatch) &gt; 0) 
        I[ixMatch] &lt;- 1
    names(I) = NULL
    return(I)
  }
</code></pre>

<hr>
<h2 id='ruleList2Exec'>
internal
</h2><span id='topic+ruleList2Exec'></span>

<h3>Description</h3>

<p>internal
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ruleList2Exec(X, allRulesList)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ruleList2Exec_+3A_x">X</code></td>
<td>

</td></tr>
<tr><td><code id="ruleList2Exec_+3A_allruleslist">allRulesList</code></td>
<td>

</td></tr>
</table>


<h3>Value</h3>

<p>data frame containing rule conditions
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##---- Should be DIRECTLY executable !! ----
##-- ==&gt;  Define data, use random,
##--	or do  help(data=index)  for the standard data sets.

## The function is currently defined as
function (X, allRulesList) 
{
    typeX = getTypeX(X)
    ruleExec &lt;- unique(t(sapply(allRulesList, singleRuleList2Exec, 
        typeX = typeX)))
    ruleExec &lt;- t(ruleExec)
    colnames(ruleExec) &lt;- "condition"
    return(ruleExec)
  }
</code></pre>

<hr>
<h2 id='selectRuleRRF'>
select a set of relevant and non-redundant rules
</h2><span id='topic+selectRuleRRF'></span>

<h3>Description</h3>

<p>select a set of relevant and non-redundant rules using regularized random forests
</p>


<h3>Usage</h3>

<pre><code class='language-R'>selectRuleRRF(ruleMetric, X, target)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="selectRuleRRF_+3A_rulemetric">ruleMetric</code></td>
<td>

<p>a matrix including the rules and metrics
</p>
</td></tr>
<tr><td><code id="selectRuleRRF_+3A_x">X</code></td>
<td>

<p>predictor variable matrix
</p>
</td></tr>
<tr><td><code id="selectRuleRRF_+3A_target">target</code></td>
<td>

<p>response variable
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix including a set of relevant and non-redundant rules, and their metrics
</p>


<h3>Author(s)</h3>

<p>Houtao Deng
</p>


<h3>See Also</h3>

<p><code><a href="#topic+buildLearner">buildLearner</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> # See function "buildLearner:
</code></pre>

<hr>
<h2 id='singleRuleList2Exec'>
internal
</h2><span id='topic+singleRuleList2Exec'></span>

<h3>Description</h3>

<p>internal
</p>


<h3>Usage</h3>

<pre><code class='language-R'>singleRuleList2Exec(ruleList, typeX)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="singleRuleList2Exec_+3A_rulelist">ruleList</code></td>
<td>

</td></tr>
<tr><td><code id="singleRuleList2Exec_+3A_typex">typeX</code></td>
<td>

</td></tr>
</table>


<h3>Value</h3>

<p>data frame containing rule conditions
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##---- Should be DIRECTLY executable !! ----
##-- ==&gt;  Define data, use random,
##--	or do  help(data=index)  for the standard data sets.

## The function is currently defined as
function (ruleList, typeX) 
{
    ruleExec &lt;- ""
    vars &lt;- ls(ruleList)
    vars &lt;- vars[order(as.numeric(vars))]
    for (i in 1:length(vars)) {
        if (typeX[as.numeric(vars[i])] == 2) {
            values &lt;- paste("c(", paste(paste("'", ruleList[[vars[i]]], 
                "'", sep = ""), collapse = ","), ")", sep = "")
            tmp = paste("X[,", vars[i], "] %in% ", values, sep = "")
        }
        else {
            tmp = ruleList[[vars[i]]]
        }
        if (i == 1) 
            ruleExec &lt;- paste(ruleExec, tmp, sep = "")
        if (i &gt; 1) 
            ruleExec &lt;- paste(ruleExec, " &amp; ", tmp, sep = "")
    }
    return(c(ruleExec))
  }
</code></pre>

<hr>
<h2 id='sortRule'>
internal 
</h2><span id='topic+sortRule'></span>

<h3>Description</h3>

<p>internal
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sortRule(M, decreasing = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sortRule_+3A_m">M</code></td>
<td>

</td></tr>
<tr><td><code id="sortRule_+3A_decreasing">decreasing</code></td>
<td>

</td></tr>
</table>


<h3>Value</h3>

<p>sorted rule conditions  
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##---- Should be DIRECTLY executable !! ----
##-- ==&gt;  Define data, use random,
##--	or do  help(data=index)  for the standard data sets.

## The function is currently defined as
function (M, decreasing = TRUE) 
{
    qIx = order((1 - as.numeric(ruleMetric[, "err"])), as.numeric(ruleMetric[, 
        "freq"]), -as.numeric(ruleMetric[, "len"]), decreasing = decreasing)
    return(M[qIx, ])
  }
</code></pre>

<hr>
<h2 id='treeVisit'>
internal function
</h2><span id='topic+treeVisit'></span>

<h3>Description</h3>

<p>internal function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>treeVisit(tree, rowIx, count, ruleSet, rule, levelX, length, max_length, digits)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="treeVisit_+3A_tree">tree</code></td>
<td>

</td></tr>
<tr><td><code id="treeVisit_+3A_rowix">rowIx</code></td>
<td>

</td></tr>
<tr><td><code id="treeVisit_+3A_count">count</code></td>
<td>

</td></tr>
<tr><td><code id="treeVisit_+3A_ruleset">ruleSet</code></td>
<td>

</td></tr>
<tr><td><code id="treeVisit_+3A_rule">rule</code></td>
<td>

</td></tr>
<tr><td><code id="treeVisit_+3A_levelx">levelX</code></td>
<td>

</td></tr>
<tr><td><code id="treeVisit_+3A_length">length</code></td>
<td>

</td></tr>
<tr><td><code id="treeVisit_+3A_max_length">max_length</code></td>
<td>

</td></tr>
<tr><td><code id="treeVisit_+3A_digits">digits</code></td>
<td>

</td></tr>
</table>


<h3>Value</h3>

<p>a list containing rules and the count   
</p>

<hr>
<h2 id='voteAllRules'>
internal
</h2><span id='topic+voteAllRules'></span>

<h3>Description</h3>

<p>Predictions from a rule set
</p>


<h3>Usage</h3>

<pre><code class='language-R'>voteAllRules(ruleMetric, X, type = "r", method = "median")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="voteAllRules_+3A_rulemetric">ruleMetric</code></td>
<td>

<p>rules and metrics
</p>
</td></tr>
<tr><td><code id="voteAllRules_+3A_x">X</code></td>
<td>

<p>predictor variable matrix
</p>
</td></tr>
<tr><td><code id="voteAllRules_+3A_type">type</code></td>
<td>

<p>regression or classification
</p>
</td></tr>
<tr><td><code id="voteAllRules_+3A_method">method</code></td>
<td>

<p>for regression, use median or average
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>predictions from the rule set
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##---- Should be DIRECTLY executable !! ----
##-- ==&gt;  Define data, use random,
##--	or do  help(data=index)  for the standard data sets.

## The function is currently defined as
function (ruleMetric, X, type = "r", method = "median") 
{
    xVoteList = vector("list", nrow(X))
    predY &lt;- rep("", nrow(X))
    for (i in 1:nrow(ruleMetric)) {
        ixMatch &lt;- eval(parse(text = paste("which(", ruleMetric[i, 
            "condition"], ")")))
        if (length(ixMatch) == 0) 
            next
        for (ii in ixMatch) {
            xVoteList[[ii]] = c(xVoteList[[ii]], ruleMetric[i, 
                "pred"])
        }
    }
    for (i in 1:length(xVoteList)) {
        thisV &lt;- xVoteList[[i]]
        if (length(thisV) == 0) 
            next
        if (type == "c") 
            predY[i] &lt;- names(table(thisV)[which.max(table(thisV))])
        if (type == "r") {
            thisV = as.numeric(thisV)
            if (method == "median") {
                predY[i] &lt;- median(thisV)
            }
            else {
                predY[i] &lt;- mean(thisV)
            }
        }
    }
    if (type == "r") 
        predY &lt;- as.numeric(predY)
    return(predY)
  }
</code></pre>

<hr>
<h2 id='XGB2List'>
Transform an xgboost object to a list of trees
</h2><span id='topic+XGB2List'></span>

<h3>Description</h3>

<p>Transform an xgboost object to a list of trees
</p>


<h3>Usage</h3>

<pre><code class='language-R'>XGB2List(xgb, X)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="XGB2List_+3A_xgb">xgb</code></td>
<td>

<p>xgboost object
</p>
</td></tr>
<tr><td><code id="XGB2List_+3A_x">X</code></td>
<td>

<p>predictor variable matrix
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of trees in an inTrees-required format
</p>


<h3>See Also</h3>

<p><code><a href="#topic+XGB2List">XGB2List</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>	library(data.table)
	library(xgboost)
	# test data set 1: iris
	X &lt;- within(iris,rm("Species")); Y &lt;- iris[,"Species"]
	X &lt;- within(iris,rm("Species")); Y &lt;- iris[,"Species"]
	model_mat &lt;- model.matrix(~. -1, data=X)
	xgb &lt;- xgboost(model_mat, label = as.numeric(Y) - 1, nrounds = 20, 
		objective = "multi:softprob", num_class = 3 )
	tree_list &lt;- XGB2List(xgb,model_mat)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
