<!DOCTYPE html><html><head><title>Help for package texmex</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {texmex}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#texmex-package'><p>Extreme value modelling</p></a></li>
<li><a href='#.exprel'><p>Accurately compute (exp(x) - 1) / x</p></a></li>
<li><a href='#.log1mexp'><p>Accurately compute log(1-exp(x))</p></a></li>
<li><a href='#.log1prel'><p>Accurately compute log(1 + x) / x</p></a></li>
<li><a href='#.specfun.safe.product'><p>Compute pmax(x y, -1) in such a way that zeros in x beat</p>
infinities in y.</a></li>
<li><a href='#addExcesses'><p>Annotate a threshold selection ggplot</p></a></li>
<li><a href='#AIC.evmOpt'><p>Information Criteria</p></a></li>
<li><a href='#bootmex'><p>Bootstrap a conditional multivariate extreme values model</p></a></li>
<li><a href='#chi'><p>Measures of extremal dependence</p></a></li>
<li><a href='#copula'><p>Calculate the copula of a matrix of variables</p></a></li>
<li><a href='#cv'><p>Cross-validation for a model object</p></a></li>
<li><a href='#cv.evmOpt'><p>Cross-validation for the shape parameter in an extreme values model</p></a></li>
<li><a href='#degp3'><p>Density, cumulative density, quantiles and random number generation for the</p>
extended generalized Pareto distribution 3</a></li>
<li><a href='#dgev'><p>Density, cumulative density, quantiles and random number generation for the</p>
generalized extreme value distribution</a></li>
<li><a href='#dgpd'><p>Density, cumulative density, quantiles and random number generation for the</p>
generalized Pareto distribution</a></li>
<li><a href='#dgumbel'><p>The Gumbel distribution</p></a></li>
<li><a href='#edf'><p>Compute empirical distribution function</p></a></li>
<li><a href='#egp3RangeFit'><p>Estimate the EGP3 distribution power parameter over a range of thresholds</p></a></li>
<li><a href='#endPoint'><p>Calculate upper end point for a fitted extreme value model</p></a></li>
<li><a href='#evm'><p>Extreme value modelling</p></a></li>
<li><a href='#evmBoot'><p>Bootstrap an evmOpt fit</p></a></li>
<li><a href='#evmSim'><p>MCMC simulation around an evmOpt fit</p></a></li>
<li><a href='#evmSimSetSeed'><p>Set the seed from a fitted evmSim object.</p></a></li>
<li><a href='#extremalIndex'><p>Extremal index estimation and automatic declustering</p></a></li>
<li><a href='#ggplot.copula'><p>Fancy plotting for copulas</p></a></li>
<li><a href='#ggplot.declustered'><p>Diagnostic plots for an declustered object</p></a></li>
<li><a href='#ggplot.evmBoot'><p>Diagnostic plots for the replicate estimated parameter values in an evmBoot object</p></a></li>
<li><a href='#ggplot.evmOpt'><p>Diagnostic plots for an evm object</p></a></li>
<li><a href='#ggplot.evmSim'><p>Diagnostic plots for the Markov chains in an evmSim object</p></a></li>
<li><a href='#ggplot.mex'><p>Conditional multivariate extreme values modelling</p></a></li>
<li><a href='#ggplot.migpd'><p>Fit multiple independent generalized Pareto models</p></a></li>
<li><a href='#ggplot.rl.evmOpt'><p>Plotting function for return level estimation</p></a></li>
<li><a href='#gpd.prof'><p>Profile likelihood based confidence intervals for GPD</p></a></li>
<li><a href='#gpdRangeFit'><p>Estimate generalized Pareto distribution parameters over a range of values</p></a></li>
<li><a href='#JointExceedanceCurve'><p>Joint exceedance curves</p></a></li>
<li><a href='#liver'><p>Liver related laboratory data</p></a></li>
<li><a href='#logLik.evmOpt'><p>Log-likelihood for evmOpt objects</p></a></li>
<li><a href='#makeReferenceMarginalDistribution'><p>Provide full marginal reference distribution for for maringal transformation</p></a></li>
<li><a href='#MCS'><p>Multivariate conditional Spearman's rho</p></a></li>
<li><a href='#mexDependence'><p>Estimate the dependence parameters in a conditional multivariate extreme</p>
values model</a></li>
<li><a href='#mexMonteCarlo'><p>Simulation from dependence models</p></a></li>
<li><a href='#mexRangeFit'><p>Estimate dependence parameters in a conditional multivariate extreme values</p>
model over a range of thresholds.</a></li>
<li><a href='#migpdCoefs'><p>Change values of parameters in a migpd object</p></a></li>
<li><a href='#mrl'><p>Mean residual life plot</p></a></li>
<li><a href='#plot.copula'><p>Plot copulas</p></a></li>
<li><a href='#plot.evmOpt'><p>Plots for evmOpt objects</p></a></li>
<li><a href='#plot.evmSim'><p>Plots for evmSim objects</p></a></li>
<li><a href='#plot.lp.evmOpt'><p>Predict return levels from extreme value models, or obtain the linear</p>
predictors.</a></li>
<li><a href='#plot.rl.evmOpt'><p>Return levels</p></a></li>
<li><a href='#print.evmOpt'><p>Print evmOpt objects</p></a></li>
<li><a href='#rain+2C+20wavesurge+20and+20portpirie'><p>Rain, wavesurge, portpirie and nidd datasets.</p></a></li>
<li><a href='#rFrechet'><p>Extreme Value random process generation.</p></a></li>
<li><a href='#rglo'><p>Generalized logistic distribution</p></a></li>
<li><a href='#rMaxAR'><p>Extreme Value random process generation.</p></a></li>
<li><a href='#simulate.evmOpt'><p>Simulate from a fitted evm object</p></a></li>
<li><a href='#summer+20and+20winter+20data'><p>Air pollution data, separately for summer and winter months</p></a></li>
<li><a href='#texmexFamily'><p>Create families of distributions</p></a></li>
<li><a href='#thinAndBurn'><p>Process Metropolis output from extreme value model fitting to discard</p>
unwanted observations.</a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Statistical Modelling of Extreme Values</td>
</tr>
<tr>
<td>Version:</td>
<td>2.4.9</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-03-04</td>
</tr>
<tr>
<td>Author:</td>
<td>Harry Southworth [aut, cre],
  Janet E. Heffernan [aut],
  Paul D. Metcalfe [aut],
  Yiannis Papastathopoulos [ctb],
  Alec Stephenson [ctb],
  Stuart Coles [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Harry Southworth &lt;harry.southworth@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Statistical extreme value modelling of threshold excesses, maxima
    and multivariate extremes. Univariate models for threshold excesses and maxima
    are the Generalised Pareto, and Generalised Extreme Value model respectively.
    These models may be fitted by using maximum (optionally penalised-)likelihood,
    or Bayesian estimation, and both classes of models may be fitted with covariates
    in any/all model parameters. Model diagnostics support the fitting process.
    Graphical output for visualising fitted models and return level estimates is
    provided. For serially dependent sequences, the intervals declustering algorithm
    of Ferro and Segers (2003) &lt;<a href="https://doi.org/10.1111%2F1467-9868.00401">doi:10.1111/1467-9868.00401</a>&gt; is provided, with
    diagnostic support to aid selection of threshold and declustering horizon.
    Multivariate modelling is performed via the conditional approach of Heffernan
    and Tawn (2004) &lt;<a href="https://doi.org/10.1111%2Fj.1467-9868.2004.02050.x">doi:10.1111/j.1467-9868.2004.02050.x</a>&gt;, with graphical tools for
    threshold selection and to diagnose estimation convergence.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Depends:</td>
<td>mvtnorm, ggplot2, stats</td>
</tr>
<tr>
<td>Suggests:</td>
<td>MASS, gridExtra, parallel, lattice, knitr, rmarkdown, dplyr,
tidyr, testthat, devtools, survival, ismev</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 0.12.18)</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>LazyData:</td>
<td>yes</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/harrysouthworth/texmex">https://github.com/harrysouthworth/texmex</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Collate:</td>
<td>'AIC.evm.R' 'Dcond.R' 'Profile_likelihood_HT_unc.R'
'Profile_likelihood_cd_nm_joint_D_KT.R'
'Profile_likelihood_cd_nm_joint_D_KT_neg.R' 'RcppExports.R'
'bootmex.R' 'gpd.sandwich.R' 'gpd.info.R' 'texmexFamily.R'
'cgpd.R' 'chi.R' 'coef.evmSim.R' 'coefficients.evm.R'
'coefficients.migpd.R' 'constructObject.R' 'copulas.R' 'cv.R'
'degp3.R' 'dgev.R' 'dgpd.R' 'efficient.closures.R' 'egp3.R'
'egp3RangeFit.R' 'endPoint.R' 'estimate_HT.R'
'estimate_HT_KPT_joint_posneg_nm.R' 'evm.R' 'evm.simSetSeed.R'
'evmBoot.R' 'evmFit.R' 'evmSim.R' 'extremalIndex.R' 'gev.R'
'ggplot.bayes.R' 'ggplot.boot.R' 'ggplot.cluster.R'
'ggplot.evm.R' 'ggplot.mex.R' 'ggplot.migpd.R'
'ggplot.predict.R' 'ggplot.thresh.R' 'glo.R'
'globalVariables.R' 'gpd.R' 'gpdProfileLikRetLevels.R'
'gpdRangeFit.R' 'gumbel.R' 'hist.evm.R' 'initial_posneg.R'
'jointExceedanceCurves.R' 'mex.R' 'mexDependence.R'
'mexDependenceLowLevelFunctions.R' 'mexMonteCarlo.R'
'mexRangeFit.R' 'mexTransform.R' 'migpd.R' 'migpdCoefs.R'
'mrl.R' 'mspearman.R' 'multivariate.cauchy.R' 'pegp3.R'
'pgev.R' 'pgpd.R' 'plot.bootmex.R' 'plot.evm.R' 'plot.evmSim.R'
'plot.mex.R' 'plot.mexPrediction.R' 'plot.migpd.R'
'plot.predict.link.evm.R' 'plotrl.evm.R' 'ppevm.R'
'predict.evm.R' 'predict.mex.R' 'predictWorkers.R'
'print.bootmex.R' 'print.evm.R' 'print.evmSim.R'
'print.mexDependence.R' 'print.mexPrediction.R' 'print.migpd.R'
'profile_minmax_joint_posneg_KT.R' 'qegp3.R' 'qgev.R' 'qgpd.R'
'qgpd2.R' 'qqevm.R' 'rMaxAR.R' 'regp3.R' 'residuals.evm.R'
'revTransform.R' 'rgev.R' 'rgpd.R' 'roots.R' 'simulate.R'
'sombrero-internal.R' 'summary.evm.R' 'summary.evmSim.R'
'summary.migpd.R' 'summary.predict.mex.R' 'texmex-package.R'
'texmexWorkers.R' 'thinAndBurn.evm.sim.R' 'u2gpd.R'
'weibull.info.R' 'weibull.R'</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-03-04 16:20:59 UTC; harry</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-03-04 16:40:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='texmex-package'>Extreme value modelling</h2><span id='topic+texmex-package'></span><span id='topic+texmex'></span>

<h3>Description</h3>

<p>Extreme values modelling, including the conditional multivariate approach of
Heffernan and Tawn (2004).
</p>


<h3>Details</h3>

<p>The
package was originally called &lsquo;texmex&rsquo; for Threshold EXceedances and
Multivariate EXtremes. However, it is no longer the case that only threshold
excess models are implemented, so the &lsquo;tex&rsquo; bit doesn't make sense. So, the
package is called &lsquo;texmex&rsquo; because it used to be called &lsquo;texmex&rsquo;.
</p>
<p><code><a href="#topic+evm">evm</a></code>: Fit extreme value distributions to data, possibly with
covariates. Use maximum likelihood estimation, maximum penalized likelihood
estimation, simulate from the posterior distribution or run a parametric
bootstrap. Extreme value families include the generalized Pareto
distribution (<code>gpd</code>) and generalized extreme value (<code>gev</code>)
distribution.
</p>
<p><code><a href="#topic+mex">mex</a></code>: Fit multiple, independent generalized Pareto models to
the the upper tails of the columns of a data set, and estimate the
conditional dependence structure between the columns using the method of
Heffernan and Tawn.
</p>
<p><code><a href="#topic+bootmex">bootmex</a></code>: Bootstrap estimation for parameters in generalized
Pareto models and in the dependence structure.
</p>
<p><code><a href="#topic+declust">declust</a></code>: Estimation of extremal index and subsequent
declustering of dependent sequences using the intervals estimator of Ferro
and Segers.
</p>


<h3>Author(s)</h3>

<p>Harry Southworth, Janet E. Heffernan, Paul D. Metcalfe
</p>
<p>Maintainer: Harry Southworth &lt;harry.southworth@gmail.com&gt;
</p>
<p>URL: https://github.com/harrysouthworth/texmex
</p>


<h3>References</h3>

<p>J. E. Heffernan and J. A. Tawn, A conditional approach for
multivariate extreme values, Journal of the Royal Statistical society B, 66,
497 &ndash; 546, 2004.
</p>
<p>C.A.T Ferro and J. Segers, Inference for Clusters of Extreme Values, Journal
of the Royal Statistical society B, 65, 545 &ndash; 556, 2003.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Analyse the winter data used by Heffernan and Tawn
mymex &lt;- mex(winter, mqu = .7, penalty="none", dqu=.7, which = "NO")
plot(mymex)
# Only do 10 replicates to keep CRAN checks happy. Do many more in any
# real application
myboot &lt;- bootmex(mymex, R=10)
plot(myboot)
mypred &lt;- predict(myboot,  pqu=.95)
summary(mypred , probs = c( .025, .5, .975 ))

# Analyse the liver data included in the package
library(MASS) # For the rlm function

liver &lt;- liver[liver$ALP.M &gt; 1,] # Get rid of outlier
liver$ndose &lt;- as.numeric(liver$dose)

alt &lt;- resid(rlm(log(ALT.M) ~ log(ALT.B) + ndose, data=liver, method="MM"))
ast &lt;- resid(rlm(log(AST.M) ~ log(AST.B) + ndose, data=liver, method="MM"))
alp &lt;- resid(rlm(log(ALP.M) ~ log(ALP.B) + ndose, data=liver, method="MM"))
tbl &lt;- resid(rlm(log(TBL.M) ~ log(TBL.B) + ndose, data=liver, method="MM"))

r &lt;- data.frame(alt=alt, ast=ast, alp=alp, tbl=tbl)

Amex &lt;- mex(r[liver$dose == "A",], mqu=.7)
Bmex &lt;- mex(r[liver$dose == "B",], mqu=.7)
Cmex &lt;- mex(r[liver$dose == "C",], mqu=.7)
Dmex &lt;- mex(r[liver$dose == "D",], mqu=.7)

par(mfcol=c(3,3))
plot(Amex)

plot(Dmex, col="blue")

## Take a closer look at the marginal behaviour of ALT

r$ndose &lt;- liver$ndose

altmod1 &lt;- evm(alt, qu=.7, phi = ~ ndose, xi = ~ ndose, data=r)
altmod2 &lt;- evm(alt, qu=.7, phi = ~ ndose, data=r)
altmod3 &lt;- evm(alt, qu=.7, xi = ~ ndose, data=r)
altmod4 &lt;- evm(alt, qu=.7, data=r)

# Prefer model 3, with term for xi on basis of AIC

balt3 &lt;- evm(alt, qu=.7, xi = ~ ndose, data=r, method="simulate")
par(mfrow=c(3,3))
plot(balt3)

# use longer burn-in and also thin the output

balt3 &lt;- thinAndBurn(balt3,burn=1000,thin=5)
plot(balt3)

# Get some simulated values for dose D

DParam &lt;- predict(balt3,type="lp",newdata=data.frame(ndose=4),all=TRUE)$obj$link[[1]]

simD &lt;- rgpd(nrow(DParam), sigma=exp(DParam[,"phi"]), xi=DParam[,"xi"], u=quantile(alt, .7))

# These are simulated residuals. Get some baselines and transform all
# to raw scale

b &lt;- sample(log(liver$ALT.M), size=nrow(balt3$param), replace=TRUE)
res &lt;- exp(b + simD)

# estimate quantiles on raw scale
quantile(res, prob=c(.5, .75, .9, .95, .99))

# estimate proportion exceeding 3*upper limit of normal mean(res &gt;
# 36 * 3) # 36 is the upper limit of normal for ALT

</code></pre>

<hr>
<h2 id='.exprel'>Accurately compute (exp(x) - 1) / x</h2><span id='topic+.exprel'></span>

<h3>Description</h3>

<p>Accurately compute (exp(x) - 1) / x
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.exprel(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".exprel_+3A_x">x</code></td>
<td>
<p>numeric vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric vector
</p>

<hr>
<h2 id='.log1mexp'>Accurately compute log(1-exp(x))</h2><span id='topic+.log1mexp'></span>

<h3>Description</h3>

<p>Accurately compute log(1-exp(x))
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.log1mexp(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".log1mexp_+3A_x">x</code></td>
<td>
<p>numeric vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a numeric vector
</p>

<hr>
<h2 id='.log1prel'>Accurately compute log(1 + x) / x</h2><span id='topic+.log1prel'></span>

<h3>Description</h3>

<p>Accurately compute log(1 + x) / x
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.log1prel(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".log1prel_+3A_x">x</code></td>
<td>
<p>numeric vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric vector
</p>

<hr>
<h2 id='.specfun.safe.product'>Compute pmax(x y, -1) in such a way that zeros in x beat
infinities in y.</h2><span id='topic+.specfun.safe.product'></span>

<h3>Description</h3>

<p>This is a common pattern in much of the distribution code, so it's
worth factoring out.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.specfun.safe.product(x, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".specfun.safe.product_+3A_x">x</code></td>
<td>
<p>a numeric vector</p>
</td></tr>
<tr><td><code id=".specfun.safe.product_+3A_y">y</code></td>
<td>
<p>a numeric vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an appropriate numeric vector
</p>

<hr>
<h2 id='addExcesses'>Annotate a threshold selection ggplot</h2><span id='topic+addExcesses'></span>

<h3>Description</h3>

<p>Annotate a threshold selection ggplot with the number
of exceedances of various thresholds.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>addExcesses(p, x, y, data, textsize)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="addExcesses_+3A_p">p</code></td>
<td>
<p>An object produced by ggplot</p>
</td></tr>
<tr><td><code id="addExcesses_+3A_x">x</code></td>
<td>
<p>Horizontal axis data containing the full range.</p>
</td></tr>
<tr><td><code id="addExcesses_+3A_y">y</code></td>
<td>
<p>Verticle axis data containing the full range.</p>
</td></tr>
<tr><td><code id="addExcesses_+3A_data">data</code></td>
<td>
<p>The actual data being considered for GPD modelling.</p>
</td></tr>
<tr><td><code id="addExcesses_+3A_textsize">textsize</code></td>
<td>
<p>The size of the text in the annotations.</p>
</td></tr>
</table>

<hr>
<h2 id='AIC.evmOpt'>Information Criteria</h2><span id='topic+AIC.evmOpt'></span><span id='topic+AIC.evmSim'></span>

<h3>Description</h3>

<p>Compute AIC and (approximate) DIC for <code>evmOpt</code> objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'evmOpt'
AIC(object, penalized = FALSE, nsamp = 1000, DIC, WAIC, ..., k = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="AIC.evmOpt_+3A_object">object</code></td>
<td>
<p>fit model object</p>
</td></tr>
<tr><td><code id="AIC.evmOpt_+3A_penalized">penalized</code></td>
<td>
<p>whether to use the penalized log-likelihood</p>
</td></tr>
<tr><td><code id="AIC.evmOpt_+3A_nsamp">nsamp</code></td>
<td>
<p>Number of approximate Gaussian sample to use in computing DIC.
Defaults to <code>nsamp=1e3</code>. Only used when the object has class 'evmOpt'.</p>
</td></tr>
<tr><td><code id="AIC.evmOpt_+3A_dic">DIC</code></td>
<td>
<p>Logical. Whether to compute DIC. Defaults to <code>DIC = TRUE</code>.
Only applicable to objects of class 'evmSim'.</p>
</td></tr>
<tr><td><code id="AIC.evmOpt_+3A_waic">WAIC</code></td>
<td>
<p>Logical. Whether to compute WAIC. Defaults to <code>WAIC = TRUE</code>.
Only applicable to objects of class 'evmSim'.</p>
</td></tr>
<tr><td><code id="AIC.evmOpt_+3A_...">...</code></td>
<td>
<p>other arguments currently ignored</p>
</td></tr>
<tr><td><code id="AIC.evmOpt_+3A_k">k</code></td>
<td>
<p>numeric, the penalty per parameter to be used; the
default <code>k = 2</code> is the classical AIC.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the object has class 'evmOpt', <code>nsamp</code> random draws are
made from the Gaussian distribution with mean and covariance inferred from
the model object. The result will be an approximate DIC. Note that AIC should
not be trusted if priors are not flat. For example, if you use a regularizing
prior on xi, say xi ~ N(0, 0.25), AIC can be misleading and DIC should be
preferred. If the object has class 'evmSim', the actual posterior draws are
used in the computation. Also note that sometimes the optimizer returns
an approximatae covariance that is not postive-semidefinite, in which case
the DIC will be reported as NA.
</p>


<h3>Value</h3>

<p>The AIC and DIC
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+AIC">AIC</a></code>
</p>

<hr>
<h2 id='bootmex'>Bootstrap a conditional multivariate extreme values model</h2><span id='topic+bootmex'></span><span id='topic+print.bootmex'></span><span id='topic+plot.bootmex'></span>

<h3>Description</h3>

<p>Bootstrap a conditional multivariate extreme values model following the
method of Heffernan and Tawn, 2004.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bootmex(x, R = 100, nPass=3, trace=10,referenceMargin=NULL)

## S3 method for class 'bootmex'
plot(x, plots = "gpd", main = "", ...)
## S3 method for class 'bootmex'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bootmex_+3A_x">x</code></td>
<td>
<p>An object of class &quot;mex&quot; as returned by function <code><a href="#topic+mex">mex</a></code>.</p>
</td></tr>
<tr><td><code id="bootmex_+3A_r">R</code></td>
<td>
<p>The number of bootstrap runs to perform. Defaults to <code>R</code>=100.</p>
</td></tr>
<tr><td><code id="bootmex_+3A_npass">nPass</code></td>
<td>
<p>An integer. Sometimes, particularly with small samples, the
estimation process fails with some bootstrap samples. The function checks
which runs fail and takes additional bootstrap samples in an attempt to get
parameter estimates. By default, it has nPass=3 attempts at this before
giving up.</p>
</td></tr>
<tr><td><code id="bootmex_+3A_trace">trace</code></td>
<td>
<p>How often to inform the user of progress. Defaults to
<code>trace=10</code>.</p>
</td></tr>
<tr><td><code id="bootmex_+3A_referencemargin">referenceMargin</code></td>
<td>
<p>Optional set of reference marginal distributions to use
for marginal transformation if the data's own marginal distribution is not
appropriate (for instance if only data for which one variable is large is
available, the marginal distributions of the other variables will not be
represented by the available data).  This object can be created from a
combination of datasets and fitted GPDs using the function
<code>makeReferenceMarginalDistribution</code>.</p>
</td></tr>
<tr><td><code id="bootmex_+3A_plots">plots</code></td>
<td>
<p>What type of diagnostic plots to produce.  Defaults to &quot;gpd&quot; in
which case gpd parameter estimate plots are produced otherwise plots are
made for the dependence parameters.</p>
</td></tr>
<tr><td><code id="bootmex_+3A_main">main</code></td>
<td>
<p>Title for plots.</p>
</td></tr>
<tr><td><code id="bootmex_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed to methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Details of the bootstrap method are given by Heffernan and Tawn (2004). The
procedure is semi-parametric.
</p>
<p>Firstly, values of all variables are simulated independently from the
parametric Gumbel or Laplace distributions (depending on the choice of
<code>margins</code> in the original call to <code><a href="#topic+mex">mex</a></code>). The sample size
and data dimension match that of the original data set.  Then an empirical
bootstrap sample is generated from the original data after its
transformation to the Gumbel/Laplace scale. Again, sample size and structure
match the original data set. The empirical bootstrap samples from each
margin are then sorted, and then replaced by their corresponding values from
the sorted Gumbel/Laplace samples. This procedure preserves the dependence
structure of the empirical bootstrap sample while ensuring the marginal
properties of the resulting semi-parametric bootstrap sample are those of
the parametric Gumbel/Laplace distribution.
</p>
<p>The simulated, ordered Laplace/Gumbel sample is then transformed to the
scale of the original data by using the Probability Integral Transform.
Values beneath the original thresholds for fitting of the GPD tail models
are transformed by using the empirical distribution functions and for values
above these thresholds, the fitted GPDs are used.  This completes the
semi-parametric bootstrap from the data.
</p>
<p>Parameter estimation is then carried out as follows: The parameters in the
generalized Pareto distributions are estimated by using the bootrap data,
these data are then transformed to the Laplace/Gumbel scale using the
orginal threshold, their empirical distribution function and these estimated
GPD parameters. The variables in the dependence structure of these variables
are then estimated.
</p>
<p>Note that maximum likelihood estimation will often fail for small samples
when the generalized Pareto distribution is being fit. Therefore it will
often be useful to use penalized likelihood estimation. The function
<code>bootmex</code> does whatever was done in the call to <code>migpd</code> or
<code>mex</code> that generated the object with which it is being called.
</p>
<p>Also note that sometimes (again, usually with small data sets) all of the
simulated Laplace/Gumbel random numbers will be beneath the threshold for
the conditioning variable. Such samples are abandoned by <code>bootmex</code> and
a new sample is generated. This probably introduces some bias into the
resulting bootstrap distributions.
</p>
<p>The <code>plot</code> method produces histograms of bootstrap gpd parameters (the
default) or scatterplots of dependence parameters with the point estimates
for the original data shown.
</p>
<p>By design, there is no <code>coef</code> method. The bootstrapping is done to
account for uncertainty. It is not obvious that adjusting the parameters for
the mean bias is the correct thing to do.
</p>


<h3>Value</h3>

<p>An object of class 'bootmex'. Print and plot functions are
available.
</p>


<h3>Author(s)</h3>

<p>Harry Southworth
</p>


<h3>References</h3>

<p>J. E. Heffernan and J. A. Tawn, A conditional approach for
multivariate extreme values, Journal of the Royal Statistical society B, 66,
497 &ndash; 546, 2004
</p>


<h3>See Also</h3>

<p><code><a href="#topic+migpd">migpd</a></code>, <code><a href="#topic+mexDependence">mexDependence</a> </code>,
<code><a href="#topic+bootmex">bootmex</a></code>, <code><a href="#topic+predict.mex">predict.mex</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

mymex &lt;- mex(winter , mqu = .7, dqu = .7, which = "NO")
myboot &lt;- bootmex(mymex)
myboot
plot(myboot,plots="gpd")
plot(myboot,plots="dependence")

</code></pre>

<hr>
<h2 id='chi'>Measures of extremal dependence</h2><span id='topic+chi'></span><span id='topic+summary.chi'></span><span id='topic+plot.chi'></span><span id='topic+print.chi'></span><span id='topic+ggplot.chi'></span><span id='topic+print.summary.chi'></span>

<h3>Description</h3>

<p>Compute measures of extremal dependence for 2 variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>chi(data, nq = 100, qlim = NULL, alpha = 0.05, trunc = TRUE)

## S3 method for class 'chi'
summary(object, ...)

## S3 method for class 'summary.chi'
print(x, digits=3, ...)

## S3 method for class 'chi'
print(x, ...)

## S3 method for class 'chi'
plot(x, show=c("Chi"=TRUE,"ChiBar"=TRUE), lty=1,
cilty=2, col=1, spcases=TRUE, cicol=1, xlim=c(0, 1), ylimChi =
c(-1, 1), ylimChiBar = c(-1, 1), mainChi = "Chi", mainChiBar =
"Chi Bar", xlab = "Quantile", ylabChi =
expression(chi(u)), ylabChiBar = expression(bar(chi)(u)),
ask, ...)

## S3 method for class 'chi'
ggplot(data=NULL, mapping, xlab = "Quantile", 
ylab=c("ChiBar" = expression(bar(chi)(u)), "Chi" = expression(chi(u))),
main=c("ChiBar" = "Chi Bar",       "Chi" = "Chi"),
xlim = c(0, 1), ylim =list("Chi" = c(-1, 1),"ChiBar" = c(-1, 1)),
ptcol="blue",fill="orange",show=c("ChiBar"=TRUE,"Chi"=TRUE),
spcases = TRUE,plot., ..., environment)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="chi_+3A_data">data</code></td>
<td>
<p>A matrix containing 2 numeric columns.</p>
</td></tr>
<tr><td><code id="chi_+3A_nq">nq</code></td>
<td>
<p>The number of quantiles at which to evaluate the dependence
measures.</p>
</td></tr>
<tr><td><code id="chi_+3A_qlim">qlim</code></td>
<td>
<p>The minimum and maximum quantiles at which to do the evaluation.</p>
</td></tr>
<tr><td><code id="chi_+3A_alpha">alpha</code></td>
<td>
<p>The size of the confidence interval to be used. Defaults to
<code>alpha = 0.05</code>.</p>
</td></tr>
<tr><td><code id="chi_+3A_trunc">trunc</code></td>
<td>
<p>Logical flag indicating whether the estimates should be
truncated at their theoretical bounds.  Defaults to <code>trunc = TRUE</code>.</p>
</td></tr>
<tr><td><code id="chi_+3A_x">x</code>, <code id="chi_+3A_object">object</code></td>
<td>
<p>An object of class <code>chi</code>.</p>
</td></tr>
<tr><td><code id="chi_+3A_digits">digits</code></td>
<td>
<p>Number of digits for printing.</p>
</td></tr>
<tr><td><code id="chi_+3A_show">show</code></td>
<td>
<p>Logical, of length 2, names &quot;Chi&quot; and &quot;ChiBar&quot;.  Defaults to<br />
<code>c("Chi" = TRUE, "ChiBar" = TRUE)</code>.</p>
</td></tr>
<tr><td><code id="chi_+3A_lty">lty</code>, <code id="chi_+3A_cilty">cilty</code>, <code id="chi_+3A_col">col</code>, <code id="chi_+3A_cicol">cicol</code></td>
<td>
<p>Line types and colours for the the estimated
quantities and their confidence intervals.</p>
</td></tr>
<tr><td><code id="chi_+3A_xlim">xlim</code>, <code id="chi_+3A_ylimchi">ylimChi</code>, <code id="chi_+3A_ylimchibar">ylimChiBar</code></td>
<td>
<p>Limits for the axes.</p>
</td></tr>
<tr><td><code id="chi_+3A_mainchi">mainChi</code>, <code id="chi_+3A_mainchibar">mainChiBar</code></td>
<td>
<p>Main titles for the plots.</p>
</td></tr>
<tr><td><code id="chi_+3A_xlab">xlab</code>, <code id="chi_+3A_ylabchi">ylabChi</code>, <code id="chi_+3A_ylabchibar">ylabChiBar</code></td>
<td>
<p>Axis labels for the plots.</p>
</td></tr>
<tr><td><code id="chi_+3A_mapping">mapping</code>, <code id="chi_+3A_ylab">ylab</code>, <code id="chi_+3A_main">main</code>, <code id="chi_+3A_ylim">ylim</code>, <code id="chi_+3A_ptcol">ptcol</code>, <code id="chi_+3A_fill">fill</code>, <code id="chi_+3A_environment">environment</code></td>
<td>
<p>Arguments to ggplot methods.</p>
</td></tr>
<tr><td><code id="chi_+3A_spcases">spcases</code></td>
<td>
<p>Whether or not to plot special cases of perfect (positive and
negative) dependence and indpenendence. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="chi_+3A_plot.">plot.</code></td>
<td>
<p>whether to plot to active graphics device.</p>
</td></tr>
<tr><td><code id="chi_+3A_ask">ask</code></td>
<td>
<p>Whether or not to ask before reusing the graphics device.</p>
</td></tr>
<tr><td><code id="chi_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed to methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Computes the functions chi and chi-bar described by Coles, Heffernan and
Tawn (1999). The limiting values of these functions as the quantile
approaches 1 give an empirical measure of the type and strength of tail
dependendce exhibited by the data.
</p>
<p>A limiting value of ChiBar equal to 1 indicates Asymptotic Dependence, in
which case the limiting value of Chi gives a measure of the strength of
dependence in this class.  A limiting value of ChiBar of less than 1
indicates Asymptotic Independence in which case Chi is irrelevant and the
limiting value of ChiBar gives a measure of the strength of dependence.
</p>
<p>The plot and ggplot methods show the ChiBar and Chi functions.  In the case of the
confidence interval for ChiBar excluding the value 1 for all of the largest
quantiles, the plot of the Chi function is shown in grey.
</p>


<h3>Value</h3>

<p>An object of class <code>chi</code> containing the following.
</p>
<table>
<tr><td><code>chi</code></td>
<td>
<p>Values of chi and their estimated upper and lower confidence
limits.</p>
</td></tr> <tr><td><code>chibar</code></td>
<td>
<p>Values of chibar and their estimated upper and lower
confidence limits.</p>
</td></tr> <tr><td><code>quantile</code></td>
<td>
<p>The quantiles at which chi and chi-bar
were evaluated.</p>
</td></tr> <tr><td><code>chiulb</code>, <code>chibarulb</code></td>
<td>
<p>Upper and lower bounds for chi and
chi-bar.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>When the data contain ties, the values of chi and chibar are
calculated by assigning distinct ranks to tied values using the <code>rank</code>
function with argument <code>ties.method = "first"</code>.  This results in the
values of chi and chibar being sensitive to the order in which the tied
values appear in the data.
</p>
<p>The code is a fairly simple reorganization of code written by Janet E.
Heffernan and Alec Stephenson and which appears in the <code>chiplot</code>
function in the <code>evd</code> package.
</p>


<h3>Author(s)</h3>

<p>Janet E. Heffernan, Alec Stephenson, Harry Southworth
</p>


<h3>References</h3>

<p>S. Coles, J. E. Heffernan and J. A. Tawn, Dependence measures
for extreme values analyses, Extremes, 2, 339 &ndash; 365, 1999.
</p>
<p>A. G. Stephenson. evd: Extreme Value Distributions, R News, 2, 2002.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+MCS">MCS</a></code>, <code><a href="base.html#topic+rank">rank</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

D &lt;- liver[liver$dose == "D",]
chiD &lt;- chi(D[, 5:6])
par(mfrow=c(1,2))
ggplot(chiD)

A &lt;- liver[liver$dose == "A",]
chiA &lt;- chi(A[, 5:6])
# here the limiting value of chi bar(u) lies away from one so the chi plot is
# not relevant and is plotted in grey
ggplot(chiA) 



</code></pre>

<hr>
<h2 id='copula'>Calculate the copula of a matrix of variables</h2><span id='topic+copula'></span><span id='topic+copula.default'></span><span id='topic+copula.data.frame'></span><span id='topic+copula.matrix'></span>

<h3>Description</h3>

<p>Returns the copula of several random variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>copula(x, na.last = NA, ...)

## Default S3 method:
copula(x, na.last = NA, ...)

## S3 method for class 'data.frame'
copula(x, na.last = NA, ...)

## S3 method for class 'matrix'
copula(x, na.last = NA, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="copula_+3A_x">x</code></td>
<td>
<p>A matrix or data.frame containing numeric variables.</p>
</td></tr>
<tr><td><code id="copula_+3A_na.last">na.last</code></td>
<td>
<p>How to treat missing values. See <code>rank</code> for details.</p>
</td></tr>
<tr><td><code id="copula_+3A_...">...</code></td>
<td>
<p>further arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The result is obtained by applying <code><a href="#topic+edf">edf</a></code> to each column of
<code>x</code> in turn.
</p>
<p>Print and plot methods are available for the copula class.
</p>


<h3>Value</h3>

<p>A matrix with the same dimensions as <code>x</code>, each column of which
contains the quantiles of each column of <code>x</code>. This object is of class
<code>copula</code>.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>copula(default)</code>: default method
</p>
</li>
<li> <p><code>copula(data.frame)</code>: data frame method
</p>
</li>
<li> <p><code>copula(matrix)</code>: matrix method
</p>
</li></ul>


<h3>Author(s)</h3>

<p>Harry Southworth
</p>


<h3>See Also</h3>

<p><code><a href="#topic+edf">edf</a></code> <code><a href="#topic+plot.copula">plot.copula</a></code> <code><a href="#topic+ggplot.copula">ggplot.copula</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  D &lt;- liver[liver$dose == "D",]
  Dco &lt;- copula(D)
  plot(Dco)

</code></pre>

<hr>
<h2 id='cv'>Cross-validation for a model object</h2><span id='topic+cv'></span><span id='topic+print.cv'></span><span id='topic+summary.cv'></span><span id='topic+plot.cv'></span><span id='topic+ggplot.cv'></span>

<h3>Description</h3>

<p>Cross-validation for a model object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cv(object, folds = 10, ...)

## S3 method for class 'cv'
print(x, ...)

## S3 method for class 'cv'
summary(object, ...)

## S3 method for class 'cv'
plot(x, y, ...)

## S3 method for class 'cv'
ggplot(data, mapping = NULL, ..., environment = parent.frame())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cv_+3A_object">object</code></td>
<td>
<p>A model object.</p>
</td></tr>
<tr><td><code id="cv_+3A_folds">folds</code></td>
<td>
<p>The number of cross-validation folds to use. Defaults to
<code>folds = 10</code>.</p>
</td></tr>
<tr><td><code id="cv_+3A_...">...</code></td>
<td>
<p>Other arguments to be passed through to methods.</p>
</td></tr>
<tr><td><code id="cv_+3A_x">x</code>, <code id="cv_+3A_y">y</code></td>
<td>
<p>Arguments to plot method.</p>
</td></tr>
<tr><td><code id="cv_+3A_data">data</code>, <code id="cv_+3A_mapping">mapping</code>, <code id="cv_+3A_environment">environment</code></td>
<td>
<p>Arguments ggplot method.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function is generic. At present, only objects of class 'evmOpt',
as returned by <code>texmex::evm</code> can be used.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cv.evmOpt">cv.evmOpt</a></code>
</p>

<hr>
<h2 id='cv.evmOpt'>Cross-validation for the shape parameter in an extreme values model</h2><span id='topic+cv.evmOpt'></span>

<h3>Description</h3>

<p>Cross-validation for the shape parameter in an extreme values model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'evmOpt'
cv(
  object,
  folds = 10,
  ...,
  penalty = "gaussian",
  range = seq(1, 25, length.out = 25),
  shape = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cv.evmOpt_+3A_object">object</code></td>
<td>
<p>An object of class 'evmOpt' as returned by <code>evm</code>.</p>
</td></tr>
<tr><td><code id="cv.evmOpt_+3A_folds">folds</code></td>
<td>
<p>Integer giving the number of cross-validation folds to use.
Defaults to <code>folds = 10</code>.</p>
</td></tr>
<tr><td><code id="cv.evmOpt_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
<tr><td><code id="cv.evmOpt_+3A_penalty">penalty</code></td>
<td>
<p>String specifying the type of penalty to use. Defaults to
<code>penalty = "gaussian"</code> which is equivalent to using a quadratic
penalty. The other allowed value is <code>penalty = "lasso"</code> and an L1
penalty is used.</p>
</td></tr>
<tr><td><code id="cv.evmOpt_+3A_range">range</code></td>
<td>
<p>A sequence of values for the penalty parameter. Defaults to
<code>range = seq(1, 25, length.out = 25)</code>.
The values are taken to be the reciprocals of the prior variance so must
be strictly positive.</p>
</td></tr>
<tr><td><code id="cv.evmOpt_+3A_shape">shape</code></td>
<td>
<p>String giving the name of the shape parameter. Defaults to
<code>shape = NULL</code> and the function tries to guess.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Only the shape parameter is assumed to be penalized. The penalty
can be thought of in terms of the variance of a prior distribution, which
is equivalent to a quadratic penalty. Because the shape parameter will
usually be between -1/2 and 1/2, a prior N(0, 1/16) distribution will
likely be a good starting point, so values that span 16 will usually be
appropriate.
</p>
<p>Note that the procedure appears to frequently prefer larger penalties over
smaller ones, effectively driving the shape parameter to zero. However,
if you are fitting distributions that can model long tails, there is
probably a good reason for that and you should use your prior knowledge
to determine if non-zero values of the shape are plausible, rather than
rely solely on an automated procedure.
</p>
<p>Also note that small numbers of observations can have a big impact on
parameter estimates. Because cross-validation involves randomly assigning
values to folds, the results are generally different from one run to
the next. These to features combined can produce quite big differences
between cross-validation runs and it is advisable to use either
leave-one-out (by setting <code>folds</code> to be the same as the length of
the data), or to run the procedure several times and average over them.
</p>
<p>@note At present, only models without covariates are implemented.
</p>

<hr>
<h2 id='degp3'>Density, cumulative density, quantiles and random number generation for the
extended generalized Pareto distribution 3</h2><span id='topic+degp3'></span><span id='topic+pegp3'></span><span id='topic+qegp3'></span><span id='topic+regp3'></span>

<h3>Description</h3>

<p>Density, cumulative density, quantiles and random number generation for the
EGP3 distribution of Papastathopoulos and Tawn
</p>


<h3>Usage</h3>

<pre><code class='language-R'>degp3(x, kappa = 1, sigma, xi, u = 0, log.d = FALSE)

pegp3(q, kappa = 1, sigma, xi, u = 0, lower.tail = TRUE, log.p = FALSE)

qegp3(p, kappa = 1, sigma, xi, u = 0, lower.tail = TRUE, log.p = FALSE)

regp3(n, kappa = 1, sigma, xi, u = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="degp3_+3A_x">x</code>, <code id="degp3_+3A_q">q</code>, <code id="degp3_+3A_p">p</code></td>
<td>
<p>Value, quantile or probability respectively.</p>
</td></tr>
<tr><td><code id="degp3_+3A_kappa">kappa</code></td>
<td>
<p>The power parameter (Papastathopoulos and Tawn call it the
shape parameter and call what we call the shape parameter the tail index.)</p>
</td></tr>
<tr><td><code id="degp3_+3A_sigma">sigma</code></td>
<td>
<p>Scale parameter.</p>
</td></tr>
<tr><td><code id="degp3_+3A_xi">xi</code></td>
<td>
<p>Shape parameter.</p>
</td></tr>
<tr><td><code id="degp3_+3A_u">u</code></td>
<td>
<p>Threshold</p>
</td></tr>
<tr><td><code id="degp3_+3A_log.d">log.d</code>, <code id="degp3_+3A_log.p">log.p</code></td>
<td>
<p>Whether or not to work on the log scale.</p>
</td></tr>
<tr><td><code id="degp3_+3A_lower.tail">lower.tail</code></td>
<td>
<p>Whether to return the lower tail.</p>
</td></tr>
<tr><td><code id="degp3_+3A_n">n</code></td>
<td>
<p>Number of random numbers to simulate.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Harry Southworth
</p>


<h3>References</h3>

<p>I. Papastathopoulos and J. A. Tawn, Extended generalized Pareto
modles for tail estimation, Journal of Statistical Planning and Inference,
143, 131 &ndash; 143, 2013
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  x &lt;- regp3(1000, kappa=2, sigma=1, xi=.5)
  hist(x)
  x &lt;- regp3(1000, kappa=2, sigma=exp(rnorm(1000, 1, .25)), xi=rnorm(1000, .5, .2))
  hist(x)
  plot(pegp3(x, kappa=2, sigma=1, xi=.5))

</code></pre>

<hr>
<h2 id='dgev'>Density, cumulative density, quantiles and random number generation for the
generalized extreme value distribution</h2><span id='topic+dgev'></span><span id='topic+pgev'></span><span id='topic+qgev'></span><span id='topic+rgev'></span>

<h3>Description</h3>

<p>Density, cumulative density, quantiles and random number generation for the
generalized extreme value distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dgev(x, mu, sigma, xi, log.d = FALSE)

pgev(q, mu, sigma, xi, lower.tail = TRUE, log.p = FALSE)

qgev(p, mu, sigma, xi, lower.tail = TRUE, log.p = FALSE)

rgev(n, mu, sigma, xi)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dgev_+3A_x">x</code>, <code id="dgev_+3A_q">q</code>, <code id="dgev_+3A_p">p</code></td>
<td>
<p>Value, quantile or probability respectively.</p>
</td></tr>
<tr><td><code id="dgev_+3A_mu">mu</code></td>
<td>
<p>Location parameter.</p>
</td></tr>
<tr><td><code id="dgev_+3A_sigma">sigma</code></td>
<td>
<p>Scale parameter.</p>
</td></tr>
<tr><td><code id="dgev_+3A_xi">xi</code></td>
<td>
<p>Shape parameter.</p>
</td></tr>
<tr><td><code id="dgev_+3A_log.d">log.d</code>, <code id="dgev_+3A_log.p">log.p</code></td>
<td>
<p>Whether or not to work on the log scale.</p>
</td></tr>
<tr><td><code id="dgev_+3A_lower.tail">lower.tail</code></td>
<td>
<p>Whether to return the lower tail.</p>
</td></tr>
<tr><td><code id="dgev_+3A_n">n</code></td>
<td>
<p>Number of random numbers to simulate.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Random number generation is done as a transformation of the Gumbel
distribution; Gumbel random variates are generated as the negative logarithm
of standard exponentials.
</p>


<h3>Author(s)</h3>

<p>Harry Southworth
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  x &lt;- rgev(1000, mu=0, sigma=1, xi=.5)
  hist(x)
  x &lt;- rgev(1000, mu=0, sigma=exp(rnorm(1000, 1, .25)), xi=rnorm(1000, .5, .2))
  hist(x)
  plot(pgev(x, mu=0, sigma=1, xi=.5))

</code></pre>

<hr>
<h2 id='dgpd'>Density, cumulative density, quantiles and random number generation for the
generalized Pareto distribution</h2><span id='topic+dgpd'></span><span id='topic+pgpd'></span><span id='topic+qgpd'></span><span id='topic+rgpd'></span>

<h3>Description</h3>

<p>Density, cumulative density, quantiles and random number generation for the
generalized Pareto distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dgpd(x, sigma, xi, u = 0, log.d = FALSE)

pgpd(q, sigma, xi, u = 0, lower.tail = TRUE, log.p = FALSE)

qgpd(p, sigma, xi, u = 0, lower.tail = TRUE, log.p = FALSE)

rgpd(n, sigma, xi, u = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dgpd_+3A_x">x</code>, <code id="dgpd_+3A_q">q</code>, <code id="dgpd_+3A_p">p</code></td>
<td>
<p>Value, quantile or probability respectively.</p>
</td></tr>
<tr><td><code id="dgpd_+3A_sigma">sigma</code></td>
<td>
<p>Scale parameter.</p>
</td></tr>
<tr><td><code id="dgpd_+3A_xi">xi</code></td>
<td>
<p>Shape parameter.</p>
</td></tr>
<tr><td><code id="dgpd_+3A_u">u</code></td>
<td>
<p>Threshold</p>
</td></tr>
<tr><td><code id="dgpd_+3A_log.d">log.d</code>, <code id="dgpd_+3A_log.p">log.p</code></td>
<td>
<p>Whether or not to work on the log scale.</p>
</td></tr>
<tr><td><code id="dgpd_+3A_lower.tail">lower.tail</code></td>
<td>
<p>Whether to return the lower tail.</p>
</td></tr>
<tr><td><code id="dgpd_+3A_n">n</code></td>
<td>
<p>Number of random numbers to simulate.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Random number generation is done by transformation of a standard
exponential.
</p>


<h3>Author(s)</h3>

<p>Janet E Heffernan, Paul Metcalfe, Harry Southworth
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  x &lt;- rgpd(1000, sigma=1, xi=.5)
  hist(x)
  x &lt;- rgpd(1000, sigma=exp(rnorm(1000, 1, .25)), xi=rnorm(1000, .5, .2))
  hist(x)
  plot(pgpd(x, sigma=1, xi=.5))

</code></pre>

<hr>
<h2 id='dgumbel'>The Gumbel distribution</h2><span id='topic+dgumbel'></span><span id='topic+rgumbel'></span><span id='topic+pgumbel'></span><span id='topic+qgumbel'></span>

<h3>Description</h3>

<p>Density, distribution and quantile functions, and random number
generation for the Gumbel distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dgumbel(x, mu, sigma, log.d = FALSE)

rgumbel(n, mu, sigma)

pgumbel(q, mu, sigma, lower.tail = TRUE, log.p = FALSE)

qgumbel(p, mu, sigma, lower.tail = TRUE, log.p = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dgumbel_+3A_x">x</code>, <code id="dgumbel_+3A_q">q</code>, <code id="dgumbel_+3A_p">p</code></td>
<td>
<p>Vectors of quantiles or probabilities.</p>
</td></tr>
<tr><td><code id="dgumbel_+3A_mu">mu</code></td>
<td>
<p>The location parameter.</p>
</td></tr>
<tr><td><code id="dgumbel_+3A_sigma">sigma</code></td>
<td>
<p>The scale parameter.</p>
</td></tr>
<tr><td><code id="dgumbel_+3A_log.d">log.d</code>, <code id="dgumbel_+3A_log.p">log.p</code></td>
<td>
<p>Whether to return logged values, or to treat probabilities/densities as being logged.</p>
</td></tr>
<tr><td><code id="dgumbel_+3A_n">n</code></td>
<td>
<p>The number of observations.</p>
</td></tr>
<tr><td><code id="dgumbel_+3A_lower.tail">lower.tail</code></td>
<td>
<p>Whether to return the lower tail. If <code>lower.tail=FALSE</code>,
the upper tail is returned.</p>
</td></tr>
</table>

<hr>
<h2 id='edf'>Compute empirical distribution function</h2><span id='topic+edf'></span>

<h3>Description</h3>

<p>Compute the empirical distribution function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>edf(x, na.last = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="edf_+3A_x">x</code></td>
<td>
<p>A numeric vector</p>
</td></tr>
<tr><td><code id="edf_+3A_na.last">na.last</code></td>
<td>
<p>How to treat missing values. See <code><a href="base.html#topic+rank">rank</a></code> for
details.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of quantiles relating to the observations in <code>x</code>.
</p>


<h3>Author(s)</h3>

<p>Harry Southworth
</p>


<h3>See Also</h3>

<p><code><a href="#topic+copula">copula</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
plot(winter$NO, edf(winter$NO))

</code></pre>

<hr>
<h2 id='egp3RangeFit'>Estimate the EGP3 distribution power parameter over a range of thresholds</h2><span id='topic+egp3RangeFit'></span><span id='topic+print.egp3RangeFit'></span><span id='topic+plot.egp3RangeFit'></span><span id='topic+ggplot.egp3RangeFit'></span>

<h3>Description</h3>

<p>Estimate extended generalized Pareto distribution power parameter over a
range of values, using maximum (penalized) likelihood.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>egp3RangeFit(data, umin=quantile(data, .05), umax=quantile(data,
.95), nint = 10, penalty = "gaussian", priorParameters = NULL, alpha=0.05)
## S3 method for class 'egp3RangeFit'
print(x, ...)
## S3 method for class 'egp3RangeFit'
plot(x, xlab = "Threshold", ylab = "kappa", main = NULL, addNexcesses=TRUE, log.="", ...)
## S3 method for class 'egp3RangeFit'
ggplot(data, mapping, xlab = "Threshold", ylab = expression(kappa),
main=NULL,fill="orange", col="blue",addNexcesses=TRUE, textsize=4, ..., environment)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="egp3RangeFit_+3A_data">data</code></td>
<td>
<p>The data vector to be modelled.</p>
</td></tr>
<tr><td><code id="egp3RangeFit_+3A_umin">umin</code></td>
<td>
<p>The minimum threshold above which to estimate the parameters.</p>
</td></tr>
<tr><td><code id="egp3RangeFit_+3A_umax">umax</code></td>
<td>
<p>The maximum threshold above which to estimate the parameters.</p>
</td></tr>
<tr><td><code id="egp3RangeFit_+3A_nint">nint</code></td>
<td>
<p>The number of thresholds at which to perform the estimation.</p>
</td></tr>
<tr><td><code id="egp3RangeFit_+3A_penalty">penalty</code></td>
<td>
<p>The type of penalty to be used in the maximum penalized
likelihood estimation. Should be either &quot;gaussian&quot; or &quot;none&quot;. Defaults to
&quot;gaussian&quot;.</p>
</td></tr>
<tr><td><code id="egp3RangeFit_+3A_priorparameters">priorParameters</code></td>
<td>
<p>Parameters to be used for the penalty function.  See
the help for <code><a href="#topic+evm">evm</a></code> for more informaiton.</p>
</td></tr>
<tr><td><code id="egp3RangeFit_+3A_alpha">alpha</code></td>
<td>
<p>100(1 - alpha)% confidence intervals will be plotted with the
point estimates. Defaults to <code>alpha = 0.05</code>.</p>
</td></tr>
<tr><td><code id="egp3RangeFit_+3A_x">x</code></td>
<td>
<p>Argument to the <code>print</code> functions.</p>
</td></tr>
<tr><td><code id="egp3RangeFit_+3A_xlab">xlab</code></td>
<td>
<p>Label for the x-axis.</p>
</td></tr>
<tr><td><code id="egp3RangeFit_+3A_ylab">ylab</code></td>
<td>
<p>Label for the y-axis.</p>
</td></tr>
<tr><td><code id="egp3RangeFit_+3A_main">main</code></td>
<td>
<p>The main title.</p>
</td></tr>
<tr><td><code id="egp3RangeFit_+3A_textsize">textsize</code></td>
<td>
<p>Size of text for annotation showing number of threshold excesses.</p>
</td></tr>
<tr><td><code id="egp3RangeFit_+3A_addnexcesses">addNexcesses</code></td>
<td>
<p>Annotate top axis with numbers of threshold excesses
arising with the corresponding values of threshold on the bottom axis.</p>
</td></tr>
<tr><td><code id="egp3RangeFit_+3A_log.">log.</code></td>
<td>
<p>Argument passed through to <code>plot</code>. Can take values &quot;x&quot; for
plotting the x-axis on the log scale, &quot;y&quot; for plotting the y-axis on the log
scale, &quot;xy&quot; for both, or &quot;&quot; (the default) for neither.</p>
</td></tr>
<tr><td><code id="egp3RangeFit_+3A_mapping">mapping</code>, <code id="egp3RangeFit_+3A_fill">fill</code>, <code id="egp3RangeFit_+3A_col">col</code>, <code id="egp3RangeFit_+3A_environment">environment</code></td>
<td>
<p>Arguments to ggplot method.</p>
</td></tr>
<tr><td><code id="egp3RangeFit_+3A_...">...</code></td>
<td>
<p>Arguments to <code>plot</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Papastathopoulos and Tawn present 3 extended versions of the generalized
Pareto distribution. Using the <code>egp3</code> texmex family object, the power
parameter in the EGP3 distribution is estimated on the log scale, a
confidence interval is calculated and the result is transformed back to the
scale of the power parameter and returned to the user.
</p>
<p>When the power paramer, kappa, is equal to 1, the EPG3 distribution is
identical to the generalized Pareto distribution. Therefore, the plot of the
estimated parameter over a range of thresholds provides a diagnostic for
threshold selection: the lowest value of kappa whose confidence interval
includes 1 is suggested as the threshold for generalized Pareto modelling.
</p>
<p>If lower thresholds are used and the EGP3 distribution itself is used for
modelling, some care should be taken to ensure the model provides a
reasonable degree of fit to the data. Limited experience suggests that such
models seldom fit well and the main value of the EGP3 distribution is as a
diagnostic for threshold selection as described here.
</p>
<p>Note this function does not extend to assessing model fit when there are
covariates included in the model.
</p>


<h3>Author(s)</h3>

<p>Harry Southworth
</p>


<h3>References</h3>

<p>I. Papastathopoulos and J. A. Tawn, Extended generalized Pareto
modles for tail estimation, Journal of Statistical Planning and Inference,
143, 131 &ndash; 143, 2013
</p>


<h3>See Also</h3>

<p><code><a href="#topic+evm">evm</a></code>, <code><a href="#topic+gpdRangeFit">gpdRangeFit</a></code>, <code><a href="#topic+mrl">mrl</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
 # because of the time it takes to run
erf &lt;- egp3RangeFit(rain)
plot(erf)
ggplot(erf)


</code></pre>

<hr>
<h2 id='endPoint'>Calculate upper end point for a fitted extreme value model</h2><span id='topic+endPoint'></span><span id='topic+endPoint.evmOpt'></span><span id='topic+endPoint.evmSim'></span><span id='topic+endPoint.evmBoot'></span>

<h3>Description</h3>

<p>Calculate upper end point for fitted extreme value model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>endPoint(y, verbose=TRUE, .unique=TRUE, ...)

## S3 method for class 'evmOpt'
endPoint(y,verbose=TRUE, .unique=TRUE, ...)
## S3 method for class 'evmSim'
endPoint(y,verbose=TRUE, .unique=TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="endPoint_+3A_y">y</code></td>
<td>
<p>Object of class <code>evmOpt</code> or <code>evmSim</code>, as returned by
<code><a href="#topic+evm">evm</a></code>.</p>
</td></tr>
<tr><td><code id="endPoint_+3A_verbose">verbose</code></td>
<td>
<p>Whether to print output.</p>
</td></tr>
<tr><td><code id="endPoint_+3A_.unique">.unique</code></td>
<td>
<p>Whether or not to use only unique values of <code>y</code>.</p>
</td></tr>
<tr><td><code id="endPoint_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to the <code><a href="base.html#topic+signif">signif</a></code>
function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>In cases where the fitted shape parameter is negative, the fitted
finite upper endpoint of the extreme value model.
</p>


<h3>Author(s)</h3>

<p>Janet E. Heffernan
</p>

<hr>
<h2 id='evm'>Extreme value modelling</h2><span id='topic+evm'></span><span id='topic+evmReal'></span><span id='topic+evm.default'></span>

<h3>Description</h3>

<p>Likelihood based modelling and inference for extreme value models, possibly
with explanatory variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>evm(y, data = NULL, ...)

evmReal(y, data)

evm.default(
  y,
  data = NULL,
  family = gpd,
  th = -Inf,
  qu,
  ...,
  penalty = NULL,
  prior = "gaussian",
  method = "optimize",
  cov = "observed",
  start = NULL,
  priorParameters = NULL,
  maxit = 10000,
  trace = NULL,
  iter = 40500,
  burn = 500,
  thin = 4,
  chains = 1,
  proposal.dist = c("gaussian", "cauchy"),
  jump.cov,
  jump.const = NULL,
  R = 1000,
  cores = NULL,
  export = NULL,
  verbose = TRUE,
  call = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="evm_+3A_y">y</code></td>
<td>
<p>Either a numeric vector, the name of a variable in <code>data</code>
or a string representing the name of a
variable in <code>data</code>. NOTE THAT the use of non-standard evaluation is
likely to be removed from future versions of texmex.</p>
</td></tr>
<tr><td><code id="evm_+3A_data">data</code></td>
<td>
<p>A data frame containing <code>y</code> and any covariates.</p>
</td></tr>
<tr><td><code id="evm_+3A_...">...</code></td>
<td>
<p>In <code>evm</code>, formulae for the parameters in the family, e.g.
<code>phi = ~ x</code>. If none are specified, they all default to <code>~1</code>.</p>
</td></tr>
<tr><td><code id="evm_+3A_family">family</code></td>
<td>
<p>An object of class 'texmexFamily'. Defaults to
<code>family=gpd</code> and a generalized Pareto distribution (GPD) is fit to the data.
Alternatively the family could be <code>gev</code>, <code>weibull</code> or
<code>gumbel</code>, resulting in a generalized extreme value distribution, Weibull
or Gumbell distribution being fit. Family <code>cgpd</code> fits the generalized
Pareto distribution but with the shape parameter constrained to be
&gt; 0.5 by using the link function suggested by Yee and Stephenson (2007),
<code class="reqn">\eta</code> = log(<code class="reqn">\xi</code> + 0.5). Family <code>egp3</code> fits the extended
GP family 3 of Papastathopoulos and Tawn (2013). No other families are currently
available in texmex, but users may write their own.</p>
</td></tr>
<tr><td><code id="evm_+3A_th">th</code></td>
<td>
<p>For threshold excess models (such as when <code>family=gpd</code>), the
threshold for <code>y</code>, exceedances above which will be used to fit the
upper tail model. Note that if you have already thresholded your data and
want to model all of <code>y</code>, you still need to specify <code>th</code>.</p>
</td></tr>
<tr><td><code id="evm_+3A_qu">qu</code></td>
<td>
<p>An alternative to <code>th</code>, a probability defined such that
<code>quantile(y,qu)</code> equals <code>th</code>.</p>
</td></tr>
<tr><td><code id="evm_+3A_penalty">penalty</code></td>
<td>
<p>How to penalize the likelhood. Currently, either &quot;none&quot;&quot;,
&quot;gaussian&quot;&quot; or &quot;lasso&quot;&quot; are the only allowed values. If <code>penalty</code> is
&quot;gaussian&quot; or &quot;lasso&quot; then the parameters for the penalization are specified
through the <code>priorParameters</code> argument. See below. Defaults to
<code>penalty=NULL</code> and applies maximum likelihood estimation.</p>
</td></tr>
<tr><td><code id="evm_+3A_prior">prior</code></td>
<td>
<p>If <code>method = "optimize"</code>, just an alternative way of
specifying the penalty, and only one or neither of <code>penalty</code> and
<code>prior</code> should be given. If <code>method = "simulate"</code>, prior must be
&quot;gaussian&quot; because no other prior distributions have been implemented.</p>
</td></tr>
<tr><td><code id="evm_+3A_method">method</code></td>
<td>
<p>Should be either &quot;optimize&quot; (the default), &quot;simulate&quot; or
&quot;bootstrap&quot;.  The first letter or various abbreviations will do. If
'optimize' is used, the (penalized) likelihood is directly optimized using
<code>optim</code> and point estimates (either ML or MAP estimates) are returned
with other information. If &quot;simulate&quot;, a Metropolis algorithm is used to
simulate from the joint posterior distribution of the parameters. If
&quot;bootstrap&quot;, a parametric boostrap is performed.</p>
</td></tr>
<tr><td><code id="evm_+3A_cov">cov</code></td>
<td>
<p>How to compute the covariance matrix of the parameters. Defaults
to <code>cov = "observed"</code> in which case the observed information matrix is
used, if the <code>info</code> element of the <code>texmexFamily</code> object is
present. Note that currently, this is not implemented for <code>gev</code>.
Alternatives are <code>cov = "numeric"</code> in which case a numerical
approximation of the Hessian is used (see the help for <code>optim</code>), or
<code>cov = "sandwich"</code> if the <code>sandwich</code> element of the
<code>texmexFamily</code> object is implemented.  The <code>cov = "sandwich"</code>
method implements the Huber sandwich correction to the covariance matrix for
data which are not independent and in which case the likelihood function no
longer has the interpretation of a joint likelihood, but instead should be
interpreted as a pseudo-likelihod.
</p>
<p>In some cases, particularly with small samples, the numerical approximation
can be quite different from the closed form (<code>cov="observed"</code>) result,
and the value derived from the observed information should be preferred.
However, in either case, since the underlying log-likelihood may be far from
quadratic for small samples, the resulting estimates of standard errors are
liable to approximate poorly the true standard errors. Also see the comments
in the Details section, below.</p>
</td></tr>
<tr><td><code id="evm_+3A_start">start</code></td>
<td>
<p>Starting values for the parameters, to be passed to
<code>optim</code>.  If not provided, the function will use the <code>start</code>
element of the <code>texmexFamily</code> object if it exists.</p>
</td></tr>
<tr><td><code id="evm_+3A_priorparameters">priorParameters</code></td>
<td>
<p>A list with two components. The first should be a
vector of means, the second should be a covariance matrix if the
penalty/prior is &quot;gaussian&quot; or &quot;quadratic&quot; and a diagonal precision matrix
if the penalty/prior is &quot;lasso&quot;, &quot;L1&quot; or &quot;Laplace&quot;.  If <code>method =
"simulate"</code> then these represent the parameters in the Gaussian prior
distribution.  If <code>method = 'optimize'</code> then these represent the
parameters in the penalty function.  If not supplied: all default prior
means are zero; all default prior variances are <code class="reqn">10^4</code>; all covariances
are zero.</p>
</td></tr>
<tr><td><code id="evm_+3A_maxit">maxit</code></td>
<td>
<p>The number of iterations allowed in <code>optim</code>.</p>
</td></tr>
<tr><td><code id="evm_+3A_trace">trace</code></td>
<td>
<p>Whether or not to print progress to screen. If <code>method =
"optimize"</code>, the argument is passed into <code>optim</code> &ndash; see the help for
that function. If <code>method = "simulate"</code>, the argument determines at how
many steps of the Markov chain the function should tell the user, and in
this case it defaults to <code>trace = 10000</code>.</p>
</td></tr>
<tr><td><code id="evm_+3A_iter">iter</code></td>
<td>
<p>Number of simulations to generate under <code>method =
"simulate"</code>.  Defaults to 40500.</p>
</td></tr>
<tr><td><code id="evm_+3A_burn">burn</code></td>
<td>
<p>The number of initial steps to be discarded. Defaults to 500.</p>
</td></tr>
<tr><td><code id="evm_+3A_thin">thin</code></td>
<td>
<p>The degree of thinning of the resulting Markov chains. Defaults
to 4 (one in every 4 steps is retained).</p>
</td></tr>
<tr><td><code id="evm_+3A_chains">chains</code></td>
<td>
<p>The number of Markov chains to run. Defaults to 1. If you run
more than 1, the function tries to figure out how to do it in parallel
using as many cores as there are chains.</p>
</td></tr>
<tr><td><code id="evm_+3A_proposal.dist">proposal.dist</code></td>
<td>
<p>The proposal distribution to use, either multivariate
gaussian or a multivariate Cauchy.</p>
</td></tr>
<tr><td><code id="evm_+3A_jump.cov">jump.cov</code></td>
<td>
<p>Covariance matrix for proposal distribution of Metropolis
algorithm.  This is scaled by <code>jump.const</code>.</p>
</td></tr>
<tr><td><code id="evm_+3A_jump.const">jump.const</code></td>
<td>
<p>Control parameter for the Metropolis algorithm.</p>
</td></tr>
<tr><td><code id="evm_+3A_r">R</code></td>
<td>
<p>The number of parametric bootstrap samples to run when <code>method
= "bootstrap"</code> is requested. Defaults to 1000.</p>
</td></tr>
<tr><td><code id="evm_+3A_cores">cores</code></td>
<td>
<p>The number of cores to use when bootstrapping. Defaults to
<code>cores=NULL</code> and the function guesses how many cores are available and
uses them all.</p>
</td></tr>
<tr><td><code id="evm_+3A_export">export</code></td>
<td>
<p>Character vector of names of objects to export if parallel
processing is being used and you are using objects from outside of
texmex. It it passed to <code>parallel::clusterExport</code> and used by
<code>texmex::evmBoot</code>.</p>
</td></tr>
<tr><td><code id="evm_+3A_verbose">verbose</code></td>
<td>
<p>Whether or not to print progress to screen. Defaults to
<code>verbose=TRUE</code>.</p>
</td></tr>
<tr><td><code id="evm_+3A_call">call</code></td>
<td>
<p>Used internally, defaults to <code>call = NULL</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The main modelling function is <code>evm</code> (extreme value model) and the
distribution to be used is specified by passing an object of class
<code>texmexFamily</code> to the <code>family</code> argument.
</p>
<p>The default <code>texmexFamily</code> object used by <code>evm</code> is <code>gpd</code>.
Currently, the other <code>texmexFamily</code> objects available are <code>gev</code>
which results in fitting a generalized extreme value (GEV) distribution to
the data, <code>gpdIntCensored</code> which can be used to fit the GPD to data which has
been rounded to a given number of decimal places by recognisiing the data as
interval censored, and <code>egp3</code> which fits the extended generalized Pareto
distribution version 3 of Papastathopoulos and Tawn (2013).
</p>
<p>See Coles (2001) for an introduction to extreme value modelling and the GPD
and GEV models.
</p>
<p>For the GPD model, we use the following parameterisation of evm:
</p>
<p style="text-align: center;"><code class="reqn">P(Y \le y) = 1 - (1 + \xi y / \sigma)^{-1/\xi}</code>
</p>

<p>for <code class="reqn">y \ge 0</code> and <code class="reqn">1 + \xi y / \sigma \ge 0.</code>
</p>
<p>For the GEV model, we use:
</p>
<p style="text-align: center;"><code class="reqn">P(Y \le y) = exp (-(1 + \xi (y - \mu) / \sigma) ^{-1/\xi})</code>
</p>

<p>In each case, the scale parameter is sigma (<code class="reqn">\sigma</code>) and the shape
parameter is xi (<code class="reqn">\xi</code>). The GEV distribution also has location
parameter mu (<code class="reqn">\mu</code>). See Papastathopoulos and Tawn (2013) for
specification of the EGP3 model.
</p>
<p>Working with the log of the scale parameter improves the stability of
computations, makes a quadratic penalty more appropriate and enables the
inclusion of covariates in the model for the scale parameter, which must
remain positive.  We therefore work with <code class="reqn">\phi</code>=log(<code class="reqn">\sigma</code>).  All
specification of priors or penalty functions refer to <code class="reqn">\phi</code> rather than
<code class="reqn">\sigma</code>.  A quadratic penalty can be thought of as a Gaussian prior
distribution, whence the terminology of the function.
</p>
<p>Parameters of the evm are estimated by using maximum (penalized) likelihood
(<code>method = "optimize"</code>), or by simulating from the posterior
distribution of the model parameters using a Metropolis algorithm
(<code>method = "simulate"</code>).  In the latter case, <code>start</code> is used as a
starting value for the Metropolis algorithm; in its absence, the maximum
penalized likelhood point estimates are computed and used.
</p>
<p>A boostrap approach is also available (<code>method = "bootstrap"</code>).  This
runs a parametric bootstrap, simulating from the model fit by optimization.
</p>
<p>When <code>method = "simulate"</code> the <code>print</code> and <code>summary</code>
functions give posterior means and standard deviations. Posterior means are
also returned by the <code>coef</code> method. Depending on what you want to do
and what the posterior distributions look like (use <code>plot</code> method) you
might want to work with quantiles of the posterior distributions instead of
relying on standard errors.
</p>
<p>When <code>method = "bootstrap"</code>, summaries of the bootstrap distribution
and the bootstrap estimate of bias are displayed.
</p>


<h3>Value</h3>

<p>If <code>method = "optimize"</code>, an object of class <code>evmOpt</code>:
</p>
<table>
<tr><td><code>call</code></td>
<td>
<p>The call to <code>evmSim</code> that produced the object.</p>
</td></tr>
<tr><td><code>data</code></td>
<td>
<p>The original data (above and below the threshold for fitting if
a distribution for threshold excesses has been used). In detail, <code>data</code>
is a list with elements <code>y</code> and <code>D</code>. <code>y</code> is the response
variable and <code>D</code> is a list containing the design matrices implied by
any formlae used in the call to <code>evm</code>.</p>
</td></tr> <tr><td><code>convergence</code></td>
<td>
<p>Output from
<code>optim</code> relating to whether or not the optimizer converged.</p>
</td></tr>
<tr><td><code>message</code></td>
<td>
<p>A message telling the user whether or not convergence was
achieved.</p>
</td></tr> <tr><td><code>threshold</code></td>
<td>
<p>The threshold of the data above which the evmSim
model was fit.</p>
</td></tr> <tr><td><code>penalty</code></td>
<td>
<p>The type of penalty function used, if any.</p>
</td></tr>
<tr><td><code>coefficients</code></td>
<td>
<p>The parameter estimates as computed under maximum
likelihood or maximum penalized likelihood.</p>
</td></tr> <tr><td><code>rate</code></td>
<td>
<p>The proportion of
observations above the threshold. If the model is not a threshold exceedance
model (e.g. the GEV model), the rate will be 1.</p>
</td></tr>
<tr><td><code>priorParameters</code></td>
<td>
<p>See above.</p>
</td></tr>
<tr><td><code>residuals</code></td>
<td>
<p>Residuals computed using the residual function in the
<code>texmexFamily</code> object, if any. These are used primarly for producing
QQ and PP plots via <code><a href="#topic+plot.evmOpt">plot.evmOpt</a></code> or <code><a href="#topic+ggplot.evmOpt">ggplot.evmOpt</a></code>.
The residuals are transformed values of the raw data, accounting for the
parameter estimates: see the <code>residuals</code> component of the
<code><a href="#topic+texmexFamily">texmexFamily</a></code> object for the calculations. For the generalized
Pareto family, they are (if the model fits well) standard exponential variates;
for the GEV family, standard Gumbel variates.</p>
</td></tr>
<tr><td><code>ploglik</code></td>
<td>
<p>The value of the
optimized penalized log-likelihood.</p>
</td></tr> <tr><td><code>loglik</code></td>
<td>
<p>The value of the
optimized (unpenalized) log-likelihood. If <code>penalty='none'</code> is used,
this will be identical to <code>ploglik</code>, above.</p>
</td></tr> <tr><td><code>cov</code></td>
<td>
<p>The estimated
covariance of the parameters in the model.</p>
</td></tr> <tr><td><code>se</code></td>
<td>
<p>The estimated standard
errors of the parameters in the model.</p>
</td></tr> <tr><td><code>xlevels</code></td>
<td>
<p>A named list
containing a named list for each design matrix (main parameter) in the
model. Each list contians an element named after each factor in the linear
predictor for the respective design matrix. These are used by the
<code>predict</code> method to ensure all factor levels are known, even if they
don't appear in <code>newdata</code>.</p>
</td></tr>
</table>
<p>If <code>method = "simulate"</code>, an object of class <code>evmSim</code>:
</p>
<table>
<tr><td><code>call</code></td>
<td>
<p>The call to <code>evmSim</code> that produced the object.</p>
</td></tr>
<tr><td><code>threshold</code></td>
<td>
<p>The threshold above which the model was fit.</p>
</td></tr>
<tr><td><code>map</code></td>
<td>
<p>The point estimates found by maximum penalized likelihood and
which were used as the starting point for the Markov chain.  This is of
class <code>evmOpt</code> and methods for this class (such as resid and plot) may
be useful.</p>
</td></tr> <tr><td><code>burn</code></td>
<td>
<p>The number of steps of the Markov chain that are to
be treated as the burn-in and not used in inferences.</p>
</td></tr> <tr><td><code>thin</code></td>
<td>
<p>The
degree of thinning used.</p>
</td></tr> <tr><td><code>chains</code></td>
<td>
<p>The entire Markov chain generated by
the Metropolis algorithm.</p>
</td></tr> <tr><td><code>y</code></td>
<td>
<p>The response data above the threshold
for fitting.</p>
</td></tr> <tr><td><code>seed</code></td>
<td>
<p>The seed used by the random number generator.</p>
</td></tr>
<tr><td><code>param</code></td>
<td>
<p>The remainder of the chain after deleting the burn-in and
applying any thinning.</p>
</td></tr>
</table>
<p>If <code>method = "bootstrap"</code>, an object of class <code>evmBoot</code>:
</p>
<table>
<tr><td><code>call</code></td>
<td>
<p>The call to <code>evmBoot</code> that produced the object.</p>
</td></tr>
<tr><td><code>replicates</code></td>
<td>
<p>The parameter estimates from the bootstrap fits.</p>
</td></tr>
<tr><td><code>map</code></td>
<td>
<p>The fit by by maximum penalized likelihood to the orginal data.
This is of class <code>evmOpt</code> and methods for this class (such as resid and
plot) may be useful.</p>
</td></tr>
</table>
<p>There are summary, plot, print, residuals and coefficients methods available for these
classes.
</p>


<h3>Note</h3>

<p>For both GPD and GEV models, when there are estimated values of
<code class="reqn">\xi \le -0.5</code>, the regularity conditions of the likelihood break down
and inference based on approximate standard errors cannot be performed. In
this case, the most fruitful approach to inference appears to be by the
bootstrap. It might be possible to simulate from the posterior, but finding
a good proposal distribution might be difficult and you should take care to
get an acceptance rate that is reasonably high (around 40% when there are
no covariates, lower otherwise). To constrain the parameter space of the GP
shape parameter, use <code>family = cgpd</code> in the call to <code>evm</code> and
the transformation <code class="reqn">\eta</code> = log(<code class="reqn">\xi</code> + 0.5) is used, as suggested
by Yee and Stephenson (2007).
</p>


<h3>Author(s)</h3>

<p>Janet E. Heffernan, Harry Southworth. Some of the internal code is
based on the <code>gpd.fit</code> function in the <code>ismev</code> package and is due
to Stuart Coles.
</p>


<h3>References</h3>

<p>S. Coles. An Introduction to Statistical Modelling of Extreme
Values. Springer, 2001.
</p>
<p>I. Papastathopoulos and J. A. Tawn, Extended generalised Pareto models for
tail estimation, Journal of Statistical Planning and Inference, 143, 131 -
143, 2013.
</p>
<p>T. W. Yee and A. G. Stephenson, Vector generalized linear and additive
extreme value models, Extremes, 10, 1 &ndash; 19, 2007.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.evmOpt">plot.evmOpt</a></code> <code><a href="#topic+ggplot.evmOpt">ggplot.evmOpt</a></code> <code><a href="#topic+rl.evmOpt">rl.evmOpt</a></code>, <code><a href="#topic+predict.evmOpt">predict.evmOpt</a></code>,
<code><a href="#topic+evm.declustered">evm.declustered</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  
  #mod &lt;- evm(rain, th=30)
  #mod
  #par(mfrow=c(2, 2))
  #plot(mod)
  

  
  mod &lt;- evm(rain, th=30, method="sim")
  par(mfrow=c(3, 2))
  plot(mod)
  

  
  mod &lt;- evm(SeaLevel, data=portpirie, family=gev)
  mod
  plot(mod)
  

  
  mod &lt;- evm(SeaLevel, data=portpirie, family=gev, method="sim")
  par(mfrow=c(3, 3))
  plot(mod)
  


</code></pre>

<hr>
<h2 id='evmBoot'>Bootstrap an evmOpt fit</h2><span id='topic+evmBoot'></span><span id='topic+summary.evmBoot'></span><span id='topic+plot.evmBoot'></span><span id='topic+coef.evmBoot'></span><span id='topic+print.summary.evmBoot'></span><span id='topic+print.evmBoot'></span>

<h3>Description</h3>

<p>This runs a parametric bootstrap simulating from an optimized
model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>evmBoot(o, R=1000, trace=100, cores=NULL, export=NULL, theCall)
## S3 method for class 'evmBoot'
summary(object,...)
## S3 method for class 'evmBoot'
plot(x,col=4,border=NULL,...)
## S3 method for class 'evmBoot'
coef(object,...)
## S3 method for class 'summary.evmBoot'
print(x,...)
## S3 method for class 'evmBoot'
print(x,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="evmBoot_+3A_o">o</code></td>
<td>
<p>a fit <code>evmOpt</code> object</p>
</td></tr>
<tr><td><code id="evmBoot_+3A_r">R</code></td>
<td>
<p>the number of parametric bootstrap samples to run</p>
</td></tr>
<tr><td><code id="evmBoot_+3A_trace">trace</code></td>
<td>
<p>the frequency of trace messages</p>
</td></tr>
<tr><td><code id="evmBoot_+3A_cores">cores</code></td>
<td>
<p>The number of coresto use when bootstrapping. Defaults
to <code>cores=NULL</code> and the function guesses how many cores
are available and uses them all.</p>
</td></tr>
<tr><td><code id="evmBoot_+3A_export">export</code></td>
<td>
<p>Character vector of names of variables to export. See the
help file for <code>parallel::export</code>. Defaults to <code>export = NULL</code>
and most users will never need to use it.</p>
</td></tr>
<tr><td><code id="evmBoot_+3A_thecall">theCall</code></td>
<td>
<p>(for internal use)</p>
</td></tr>
<tr><td><code id="evmBoot_+3A_x">x</code></td>
<td>
<p>an <code><a href="#topic+evmBoot">evmBoot</a></code> object</p>
</td></tr>
<tr><td><code id="evmBoot_+3A_col">col</code></td>
<td>
<p>colour used to fill histogram</p>
</td></tr>
<tr><td><code id="evmBoot_+3A_border">border</code></td>
<td>
<p>the colour of the border around the bars</p>
</td></tr>
<tr><td><code id="evmBoot_+3A_object">object</code></td>
<td>
<p>a <code><a href="#topic+evmBoot">evmBoot</a></code> object</p>
</td></tr>
<tr><td><code id="evmBoot_+3A_...">...</code></td>
<td>
<p>other arguments passed to internal functions</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>evmBoot</code>; a list with
</p>
<table>
<tr><td><code>call</code></td>
<td>
<p>The call to <code>evmBoot</code> that produced the object.</p>
</td></tr>
<tr><td><code>replicates</code></td>
<td>
<p>The parameter estimates from the bootstrap fits.</p>
</td></tr>
<tr><td><code>map</code></td>
<td>
<p>The fit by by maximum penalized likelihood to the original data.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>It is not expected that a user will need to call
this function directly; you are directed to <code><a href="#topic+evm">evm</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+evm">evm</a></code>
</p>

<hr>
<h2 id='evmSim'>MCMC simulation around an evmOpt fit</h2><span id='topic+evmSim'></span>

<h3>Description</h3>

<p>MCMC simulation around an evmOpt fit
</p>


<h3>Usage</h3>

<pre><code class='language-R'>evmSim(
  o,
  priorParameters,
  prop.dist,
  jump.const,
  jump.cov,
  iter,
  start,
  thin,
  burn,
  chains,
  export = NULL,
  verbose,
  trace,
  theCall,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="evmSim_+3A_o">o</code></td>
<td>
<p>a fit <code>evmOpt</code> object</p>
</td></tr>
<tr><td><code id="evmSim_+3A_priorparameters">priorParameters</code></td>
<td>
<p>A list with two components. The first should
be a vector of means, the second should be a covariance matrix
if the penalty/prior is &quot;gaussian&quot; or &quot;quadratic&quot; and a
diagonal precision matrix if the penalty/prior is &quot;lasso&quot;, &quot;L1&quot;
or &quot;Laplace&quot;.  If <code>method = "simulate"</code> then these
represent the parameters in the Gaussian prior distribution.
If <code>method = 'optimize'</code> then these represent the
parameters in the penalty function.  If not supplied: all
default prior means are zero; all default prior variances are
<code class="reqn">10^4</code>; all covariances are zero.</p>
</td></tr>
<tr><td><code id="evmSim_+3A_prop.dist">prop.dist</code></td>
<td>
<p>The proposal distribution to use, either
multivariate gaussian or a multivariate Cauchy.</p>
</td></tr>
<tr><td><code id="evmSim_+3A_jump.const">jump.const</code></td>
<td>
<p>Control parameter for the Metropolis algorithm.</p>
</td></tr>
<tr><td><code id="evmSim_+3A_jump.cov">jump.cov</code></td>
<td>
<p>Covariance matrix for proposal distribution of
Metropolis algorithm.  This is scaled by <code>jump.const</code>.</p>
</td></tr>
<tr><td><code id="evmSim_+3A_iter">iter</code></td>
<td>
<p>Number of simulations to generate</p>
</td></tr>
<tr><td><code id="evmSim_+3A_start">start</code></td>
<td>
<p>Starting values for the chain; if missing, defaults to
the MAP/ML estimates in <code>o</code>.</p>
</td></tr>
<tr><td><code id="evmSim_+3A_thin">thin</code></td>
<td>
<p>The degree of thinning of the resulting Markov chains.</p>
</td></tr>
<tr><td><code id="evmSim_+3A_burn">burn</code></td>
<td>
<p>The number of initial steps to be discarded.</p>
</td></tr>
<tr><td><code id="evmSim_+3A_chains">chains</code></td>
<td>
<p>The number of Markov chains to run. Defaults to 1. If you run
more, the function will try to figure out how to do it in parallel using
the same number of cores as chains.</p>
</td></tr>
<tr><td><code id="evmSim_+3A_export">export</code></td>
<td>
<p>Character vector of names of variables to export. See the
help file for <code>parallel::export</code>. Defaults to <code>export = NULL</code>
and most users will never need to use it. Only matters on Windows.</p>
</td></tr>
<tr><td><code id="evmSim_+3A_verbose">verbose</code></td>
<td>
<p>Whether or not to print progress to screen. Defaults
to <code>verbose=TRUE</code>.</p>
</td></tr>
<tr><td><code id="evmSim_+3A_trace">trace</code></td>
<td>
<p>How frequently to talk to the user</p>
</td></tr>
<tr><td><code id="evmSim_+3A_thecall">theCall</code></td>
<td>
<p>(internal use only)</p>
</td></tr>
<tr><td><code id="evmSim_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class <code>evmSim</code>:
</p>
<table>
<tr><td><code>call</code></td>
<td>
<p>The call to <code>evmSim</code> that produced the object.</p>
</td></tr>
<tr><td><code>threshold</code></td>
<td>
<p>The threshold above which the model was fit.</p>
</td></tr>
<tr><td><code>map</code></td>
<td>
<p>The point estimates found by maximum penalized
likelihood and which were used as the starting point for the Markov
chain.  This is of class <code>evmOpt</code> and methods for this class
(such as resid and plot) may be useful.</p>
</td></tr>
<tr><td><code>burn</code></td>
<td>
<p>The number of steps of the Markov chain that are to be
treated as the burn-in and not used in inferences.</p>
</td></tr>
<tr><td><code>thin</code></td>
<td>
<p>The degree of thinning used.</p>
</td></tr>
<tr><td><code>chains</code></td>
<td>
<p>The entire Markov chain generated by the Metropolis
algorithm.</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>The response data above the threshold for
fitting.</p>
</td></tr>
<tr><td><code>seed</code></td>
<td>
<p>The seed used by the random number generator.</p>
</td></tr>
<tr><td><code>param</code></td>
<td>
<p>The remainder of the chain after deleting
the burn-in and applying any thinning.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>it is not expected that the user should call this directly
</p>

<hr>
<h2 id='evmSimSetSeed'>Set the seed from a fitted evmSim object.</h2><span id='topic+evmSimSetSeed'></span>

<h3>Description</h3>

<p>Set the seed from a fitted <code>evmSim</code> object to ensure reproducibility of
output.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>evmSimSetSeed(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="evmSimSetSeed_+3A_x">x</code></td>
<td>
<p>An object of class <code>evmSim</code>, as returned by <code>evm</code> using
<code>method = "simulate"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Sets the seed to the value used to fit the model.
</p>


<h3>Author(s)</h3>

<p>Harry Southworth
</p>


<h3>See Also</h3>

<p><code><a href="#topic+evm">evm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  
 data &lt;- rnorm(1000)
 mod &lt;- evm(data, qu=.7, method="simulate")
 evmSimSetSeed(mod)
 mod1 &lt;- evm(data, qu=.7, method="simulate") # this produces the same MCMC output as mod


</code></pre>

<hr>
<h2 id='extremalIndex'>Extremal index estimation and automatic declustering</h2><span id='topic+extremalIndex'></span><span id='topic+extremalIndexRangeFit'></span><span id='topic+declust'></span><span id='topic+declust.default'></span><span id='topic+declust.extremalIndex'></span><span id='topic+print.extremalIndex'></span><span id='topic+plot.declustered'></span><span id='topic+print.declustered'></span><span id='topic+bootExtremalIndex'></span><span id='topic+evm.declustered'></span><span id='topic+plot.extremalIndexRangeFit'></span><span id='topic+ggplot.extremalIndexRangeFit'></span>

<h3>Description</h3>

<p>Given a threshold which defines excesses above that threshold, estimate the
extremal index of a dependent sequence by using the method of Ferro and
Segers, 2003.  The extremal index estimate can then be used to carry out
automatic declustering of the sequence to identify independent clusters and
estimate the GPD for cluster maxima.  Graphical diagnostics of model fit are
available.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extremalIndex(y, data = NULL, threshold)

extremalIndexRangeFit(y, data = NULL, umin = quantile(y,.5), umax =
quantile(y, 0.95), nint = 10, nboot = 100, alpha = .05, estGPD=TRUE,
verbose = TRUE, trace = 10, ...)

bootExtremalIndex(x)

declust(y, r=NULL, data = NULL, ...)

## S3 method for class 'extremalIndex'
declust(y, r=NULL,...)

## S3 method for class 'declustered'
plot(x, ylab = "Data",...)

## S3 method for class 'declustered'
evm(y, data=NULL, family=gpd, ...)

## S3 method for class 'extremalIndexRangeFit'
plot(x,addNexcesses=TRUE,estGPD=TRUE,...)

## S3 method for class 'extremalIndex'
print(x,...)

## S3 method for class 'declustered'
print(x,...)

## S3 method for class 'extremalIndexRangeFit'
ggplot(data=NULL, mapping, xlab, ylab, main,
ylim = "auto",ptcol="dark blue",col="dark blue",fill="orange",
textsize=4,addNexcesses=TRUE,estGPD=TRUE,..., environment)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extremalIndex_+3A_y">y</code></td>
<td>
<p>Argument to function <code>extremalIndex</code>: either a numeric vector
or the name of a variable in <code>data</code>.</p>
</td></tr>
<tr><td><code id="extremalIndex_+3A_data">data</code></td>
<td>
<p>A data frame containing <code>y</code> and any covariates. In
<code>evm.declustered</code>, it should be NULL and is included to match the
arguments of generic <code>evm</code>.</p>
</td></tr>
<tr><td><code id="extremalIndex_+3A_threshold">threshold</code></td>
<td>
<p>The threshold for <code>y</code>, exceedances above which will be
used to estimate the extremal index and carry out automatic declustering.</p>
</td></tr>
<tr><td><code id="extremalIndex_+3A_family">family</code></td>
<td>
<p>The type of extreme value model. The user should not change
this from its default in <code>evm.declustered</code>.</p>
</td></tr>
<tr><td><code id="extremalIndex_+3A_x">x</code></td>
<td>
<p>Objects passed to methods.</p>
</td></tr>
<tr><td><code id="extremalIndex_+3A_r">r</code></td>
<td>
<p>Positivie integer: run length to be used under &quot;runs&quot; declustering.
If specified then so-called &quot;runs&quot; declustering will be carried out,
otherwise defaults to NULL in which case the automatic &quot;intervals&quot;
declustering method of Ferro and Segers is used.</p>
</td></tr>
<tr><td><code id="extremalIndex_+3A_umin">umin</code></td>
<td>
<p>The minimum threshold above which to esimate the parameters.</p>
</td></tr>
<tr><td><code id="extremalIndex_+3A_umax">umax</code></td>
<td>
<p>The maximum threshold above which to esimate the parameters.</p>
</td></tr>
<tr><td><code id="extremalIndex_+3A_nint">nint</code></td>
<td>
<p>The number of thresholds at which to perform the estimation.</p>
</td></tr>
<tr><td><code id="extremalIndex_+3A_nboot">nboot</code></td>
<td>
<p>Number of bootstrap samples to simulate at each threshold for
estimation.</p>
</td></tr>
<tr><td><code id="extremalIndex_+3A_alpha">alpha</code></td>
<td>
<p>100(1 - alpha)% confidence intervals will be plotted with the
point estimates. Defaults to <code>alpha = 0.05</code>.</p>
</td></tr>
<tr><td><code id="extremalIndex_+3A_xlab">xlab</code></td>
<td>
<p>Label for the x-axis (ggplot).</p>
</td></tr>
<tr><td><code id="extremalIndex_+3A_ylab">ylab</code></td>
<td>
<p>Label for the y-axis (ggplot).</p>
</td></tr>
<tr><td><code id="extremalIndex_+3A_addnexcesses">addNexcesses</code></td>
<td>
<p>Whether to annotate the top axis of plots with the
number of excesses above the corresponding threhsold. Defaults to
<code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="extremalIndex_+3A_estgpd">estGPD</code></td>
<td>
<p>Whether to estimate GPD parameters at each choice of
thereshold &ndash; defaults to <code>TRUE</code> in which case the GPD parameters are
estimated.</p>
</td></tr>
<tr><td><code id="extremalIndex_+3A_verbose">verbose</code></td>
<td>
<p>Whether to report on progress in RangeFit calculations.
Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="extremalIndex_+3A_trace">trace</code></td>
<td>
<p>How frequently to report bootstrap progress in RangeFit
calculations.  Defaults to 10.</p>
</td></tr>
<tr><td><code id="extremalIndex_+3A_mapping">mapping</code>, <code id="extremalIndex_+3A_main">main</code>, <code id="extremalIndex_+3A_ylim">ylim</code>, <code id="extremalIndex_+3A_ptcol">ptcol</code>, <code id="extremalIndex_+3A_col">col</code>, <code id="extremalIndex_+3A_fill">fill</code>, <code id="extremalIndex_+3A_textsize">textsize</code>, <code id="extremalIndex_+3A_environment">environment</code></td>
<td>
<p>Further arguments to ggplot method.</p>
</td></tr>
<tr><td><code id="extremalIndex_+3A_...">...</code></td>
<td>
<p>Further arguments to methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>extremalIndex</code> estimates the extremal index of a
dependent series of observations above a given threshold <code>threshold</code>,
returning an object of class &quot;extremalIndex&quot;.  Plot and print methods are
available for this class. A graphical diagnostic akin to Figure 1 in Ferro
and Segers (2003) is produced by the <code>plot</code> method for this class.
This plot is used to test the model assumption underpinning the estimation,
with good fit being indicated by interexceedance times which correspond to
inter-cluster times lying close to the diagonal line indicated.
</p>
<p>In addition to good model fit, an appropriate choice of threshold is one
above which the estimated extremal index is stable over further, higher
thresholds (up to estimation uncertainty).  This can be assessed by using
the function <code>extremalIndexRangeFit</code>, which examines a range of
threshold values.  At each threshold, the extremal index is estimated; that
estimate is used to decluster the series and the parameters of the GPD are
optionally estimated for the resulting declustered series.  Uncertainty in
the estimation of the extremal index and GPD parameters is assessed by using
a bootstrap scheme which accounts for uncertainty in the extremal index
estimation, and the corresponding uncertainty in the declustering of the
series. There are <code>plot</code> and <code>ggplot</code> methods for output of this function, which is of class <code>extremalIndexRangeFit</code>.
</p>
<p>The function <code>declust</code> returns an object of class &quot;declustered&quot;,
identifying independent clusters in the original series. Print, plot and
show methods are available for this class. The GPD model can be fitted to
objects of this class, including the use of covariates in the linear
predictors for the parameters of the GPD.  See examples below.
</p>


<h3>Value</h3>

<p>The function <code>extremalIndex</code> returns a list of class
&quot;extremalIndex&quot;: </p>
<table>
<tr><td><code>EIintervals</code></td>
<td>
<p>Estimate of the extremal index by using
the intervals estimator of Ferro and Segers.</p>
</td></tr> <tr><td><code>threshold</code></td>
<td>
<p>threshold for
declustering and estimation</p>
</td></tr> <tr><td><code>TotalN</code></td>
<td>
<p>length of original data series</p>
</td></tr>
<tr><td><code>nExceed</code></td>
<td>
<p>number of exceedances of <code>threshold</code> in original
series.</p>
</td></tr> <tr><td><code>thExceedanceProb</code></td>
<td>
<p>probablity of threshold exceedance in
original series.</p>
</td></tr> <tr><td><code>call</code></td>
<td>
<p>the original function call </p>
</td></tr>
<tr><td><code>interExceedTimes</code></td>
<td>
<p>times between threshold exceedances</p>
</td></tr>
<tr><td><code>thExceedances</code></td>
<td>
<p>observation from the original series which are above
<code>threshold</code></p>
</td></tr> <tr><td><code>exceedanceTimes</code></td>
<td>
<p>times of occurrance of threshold
exceedances</p>
</td></tr> <tr><td><code>y</code></td>
<td>
<p>original dependent series</p>
</td></tr> <tr><td><code>data</code></td>
<td>
<p>data frame or
NULL</p>
</td></tr>
</table>
<p>The function <code>declust</code> returns a list of type &quot;declustered&quot;:
</p>
<table>
<tr><td><code>clusters</code></td>
<td>
<p>integer labels assigning threshold exceedances to clusters</p>
</td></tr>
<tr><td><code>sizes</code></td>
<td>
<p>number of exceedances in each cluster</p>
</td></tr>
<tr><td><code>clusterMaxima</code></td>
<td>
<p>vector made up of the largest observation from each
distinct cluster.  In the case of ties, the first value is taken.</p>
</td></tr>
<tr><td><code>isClusterMax</code></td>
<td>
<p>logical; length equal to number of threshold
exceedances, value is <code>TRUE</code> for threshold exceedances which correspond
to cluster maxima</p>
</td></tr> <tr><td><code>y</code></td>
<td>
<p>see entry for object of class &quot;extremalIndex&quot;
above</p>
</td></tr> <tr><td><code>data</code></td>
<td>
<p>see entry for object of class &quot;extremalIndex&quot; above</p>
</td></tr>
<tr><td><code>threshold</code></td>
<td>
<p>see entry for object of class &quot;extremalIndex&quot; above</p>
</td></tr>
<tr><td><code>EIintervals</code></td>
<td>
<p>see entry for object of class &quot;extremalIndex&quot; above</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>see entry for object of class &quot;extremalIndex&quot; above</p>
</td></tr>
<tr><td><code>InterExceedTimes</code></td>
<td>
<p>times between threshold exceedances, length is one
less than the number of threshold exceedances</p>
</td></tr> <tr><td><code>InterCluster</code></td>
<td>
<p>logical:
indicates inter exceedance times larger than <code>r</code> the run length used
for declustering</p>
</td></tr> <tr><td><code>thExceedances</code></td>
<td>
<p>see entry for object of class
&quot;extremalIndex&quot; above</p>
</td></tr> <tr><td><code>exceedanceTimes</code></td>
<td>
<p>see entry for object of class
&quot;extremalIndex&quot; above</p>
</td></tr> <tr><td><code>r</code></td>
<td>
<p>run length used for declustering</p>
</td></tr>
<tr><td><code>nClusters</code></td>
<td>
<p>Number of indenendent clusters identified</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>Method used for declustering (either &quot;intervals&quot; or &quot;runs&quot;)</p>
</td></tr>
</table>
<p>The function <code>bootExtremalIndex</code> return a single vector corersponding
to a bootstrap sample from the original series: observations are censored at
<code>threshold</code> so that values below this threshold are indicated by the
value -1.
</p>
<p>The method <code>evm</code> for class &quot;declustered&quot; returns an object of type
&quot;evmOpt&quot; or &quot;evmSim&quot; depending on the precise function call - see
documentation for <code><a href="#topic+evm">evm</a></code>.
</p>


<h3>Author(s)</h3>

<p>Janet E. Heffernan
</p>


<h3>References</h3>

<p>Ferro, C.A.T. and Segers, J., (2003) &quot;Inference for clusters of
Extreme Values&quot;, JRSS B 65, Part 2, pp 545&ndash;556.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+evm">evm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
par(mfrow=c(2,2));
extremalIndexRangeFit(summer$O3,nboot=10)
ei &lt;- extremalIndex(summer$O3,threshold=45)
plot(ei)
d &lt;- declust(ei)
plot(d)
evm(d)

## fitting with covariates:

so2 &lt;- extremalIndex(SO2,data=winter,threshold=15)
plot(so2)
so2 &lt;- extremalIndex(SO2,data=winter,threshold=20)
plot(so2) ## fits better

so2.d &lt;- declust(so2)
par(mfrow=c(1,1)); plot(so2.d)
so2.d.gpd &lt;- evm(so2.d) # AIC 661.1

evm(so2.d,phi=~NO)
evm(so2.d,phi=~NO2)
evm(so2.d,phi=~O3) # better AIC 651.9
evm(so2.d,phi=~PM10)

so2.d.gpd.o3 &lt;- evm(so2.d,phi=~O3)

par(mfrow=c(2,2)); plot(so2.d.gpd.o3)

</code></pre>

<hr>
<h2 id='ggplot.copula'>Fancy plotting for copulas</h2><span id='topic+ggplot.copula'></span>

<h3>Description</h3>

<p>Fancy plotting for copulas
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'copula'
ggplot(
  data,
  mapping = aes(),
  color = "blue",
  alpha = 0.7,
  jitter = FALSE,
  jitter.factor = 0.05,
  point.size = 1,
  smooth = FALSE,
  smooth.method = "auto",
  smooth.se = TRUE,
  smooth.level = 0.95,
  smooth.formula = y ~ x,
  legend.position = "none",
  legend.title = ggplot2::waiver(),
  diag = FALSE,
  lower = TRUE,
  ticks = TRUE,
  ...,
  environment = parent.frame()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ggplot.copula_+3A_data">data</code></td>
<td>
<p>A data.frame.</p>
</td></tr>
<tr><td><code id="ggplot.copula_+3A_mapping">mapping</code></td>
<td>
<p>Not used.</p>
</td></tr>
<tr><td><code id="ggplot.copula_+3A_color">color</code></td>
<td>
<p>Defaults to <code>color = "blue"</code>.</p>
</td></tr>
<tr><td><code id="ggplot.copula_+3A_alpha">alpha</code></td>
<td>
<p>Defaults to <code>alpha = 0.7</code>.</p>
</td></tr>
<tr><td><code id="ggplot.copula_+3A_jitter">jitter</code></td>
<td>
<p>If <code>jitter=TRUE</code>, the values are jittered
before plotting. Defaults to <code>jitter. = FALSE</code>.</p>
</td></tr>
<tr><td><code id="ggplot.copula_+3A_jitter.factor">jitter.factor</code></td>
<td>
<p>How much jittering to use. Defaults to
<code>jitter.factor = .05</code>.</p>
</td></tr>
<tr><td><code id="ggplot.copula_+3A_point.size">point.size</code></td>
<td>
<p>Defaults to <code>point.size = 1</code>.</p>
</td></tr>
<tr><td><code id="ggplot.copula_+3A_smooth">smooth</code></td>
<td>
<p>Defaults to <code>smooth = FALSE</code>.</p>
</td></tr>
<tr><td><code id="ggplot.copula_+3A_smooth.method">smooth.method</code></td>
<td>
<p>Defaults to <code>smooth.method = "auto"</code> and is passed
to <code>geom_smooth</code> only when <code>smooth = TRUE</code>.</p>
</td></tr>
<tr><td><code id="ggplot.copula_+3A_smooth.se">smooth.se</code></td>
<td>
<p>Defaults to <code>smooth.se = TRUE</code> and is used only when
<code>smooth = TRUE</code>.</p>
</td></tr>
<tr><td><code id="ggplot.copula_+3A_smooth.level">smooth.level</code></td>
<td>
<p>Defaults to <code>smooth.level = 0.95</code> and is used only
when <code>smooth = TRUE</code>.</p>
</td></tr>
<tr><td><code id="ggplot.copula_+3A_smooth.formula">smooth.formula</code></td>
<td>
<p>A formula, defaulting to <code>smooth.formula = y ~ x</code>
to be passed as the <code>formula</code> argument to <code>geom_smooth</code>.</p>
</td></tr>
<tr><td><code id="ggplot.copula_+3A_legend.position">legend.position</code></td>
<td>
<p>Passed into <code>theme</code>, defaults to <code>legend.position="none"</code>.</p>
</td></tr>
<tr><td><code id="ggplot.copula_+3A_legend.title">legend.title</code></td>
<td>
<p>Passed into <code>theme</code>. Defaults to <code>legend.title = waiver()</code>.</p>
</td></tr>
<tr><td><code id="ggplot.copula_+3A_diag">diag</code></td>
<td>
<p>Defaults to <code>diag = FALSE</code> and panels on the diagonal are not
produced.</p>
</td></tr>
<tr><td><code id="ggplot.copula_+3A_lower">lower</code></td>
<td>
<p>Defaults to <code>lower = TRUE</code> and only the lower triangle is plotted.</p>
</td></tr>
<tr><td><code id="ggplot.copula_+3A_ticks">ticks</code></td>
<td>
<p>Defaults to <code>ticks = TRUE</code> and ticks and their labels are put
on the axes. Otherwise, no tick or labels are used.</p>
</td></tr>
<tr><td><code id="ggplot.copula_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
<tr><td><code id="ggplot.copula_+3A_environment">environment</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>

<hr>
<h2 id='ggplot.declustered'>Diagnostic plots for an declustered object</h2><span id='topic+ggplot.declustered'></span><span id='topic+ggplot.extremalIndex'></span>

<h3>Description</h3>

<p>Create and display diagnostic plots for a declustered object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'declustered'
ggplot(
  data = NULL,
  mapping,
  xlab,
  ylab,
  main,
  ptcol = c("blue", "orange"),
  col = "light blue",
  plot. = TRUE,
  ...,
  environment
)

## S3 method for class 'extremalIndex'
ggplot(
  data = NULL,
  mapping,
  xlab,
  ylab,
  main,
  ptcol = "blue",
  col = "light blue",
  plot. = TRUE,
  ...,
  environment
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ggplot.declustered_+3A_data">data</code></td>
<td>
<p>An object of class <code>declustered</code> or <code>extremalIndex</code>.</p>
</td></tr>
<tr><td><code id="ggplot.declustered_+3A_mapping">mapping</code></td>
<td>
<p>Not used.</p>
</td></tr>
<tr><td><code id="ggplot.declustered_+3A_xlab">xlab</code></td>
<td>
<p>Label for the x-axis.</p>
</td></tr>
<tr><td><code id="ggplot.declustered_+3A_ylab">ylab</code></td>
<td>
<p>Label for the y-axis.</p>
</td></tr>
<tr><td><code id="ggplot.declustered_+3A_main">main</code></td>
<td>
<p>Plot title.</p>
</td></tr>
<tr><td><code id="ggplot.declustered_+3A_ptcol">ptcol</code></td>
<td>
<p>Colour for points. Defaults to <code>ptcol="blue"</code>.</p>
</td></tr>
<tr><td><code id="ggplot.declustered_+3A_col">col</code></td>
<td>
<p>Colour for lines. Defaults to <code>col="light blue"</code>.</p>
</td></tr>
<tr><td><code id="ggplot.declustered_+3A_plot.">plot.</code></td>
<td>
<p>Whether or not to display the output. Defaults to <code>plot.=TRUE</code>.</p>
</td></tr>
<tr><td><code id="ggplot.declustered_+3A_...">...</code></td>
<td>
<p>Other arguments passed through to underlying plot functions.</p>
</td></tr>
<tr><td><code id="ggplot.declustered_+3A_environment">environment</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>

<hr>
<h2 id='ggplot.evmBoot'>Diagnostic plots for the replicate estimated parameter values in an evmBoot object</h2><span id='topic+ggplot.evmBoot'></span><span id='topic+ggbootdensplots'></span>

<h3>Description</h3>

<p>Diagnostic plots for the replicate estimated parameter values in an evmBoot object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'evmBoot'
ggplot(
  data = NULL,
  mapping,
  denscol = "light blue",
  histcol = "dark blue",
  linecol = "orange",
  plot.it = TRUE,
  ...,
  environment
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ggplot.evmBoot_+3A_data">data</code></td>
<td>
<p>An object of class 'evmBoot'.</p>
</td></tr>
<tr><td><code id="ggplot.evmBoot_+3A_mapping">mapping</code>, <code id="ggplot.evmBoot_+3A_environment">environment</code></td>
<td>
<p>ignored</p>
</td></tr>
<tr><td><code id="ggplot.evmBoot_+3A_denscol">denscol</code></td>
<td>
<p>Colour for the densities. Defaults to 'light blue'.</p>
</td></tr>
<tr><td><code id="ggplot.evmBoot_+3A_histcol">histcol</code></td>
<td>
<p>Colour for the histograms. Defaults to 'dark blue'.</p>
</td></tr>
<tr><td><code id="ggplot.evmBoot_+3A_linecol">linecol</code></td>
<td>
<p>Colour for the point estimate lines. Decaults to 'orange'.</p>
</td></tr>
<tr><td><code id="ggplot.evmBoot_+3A_plot.it">plot.it</code></td>
<td>
<p>Whether or not to actually print the plots. Defaults
to <code>plot.it=TRUE</code>.  If <code>plot.it=FALSE</code>, you might
want to control the layout. Do this with
<code>do.call("grid.arrange", c(plots, ncol=2))</code>, for example,
where <code>plots</code> is the objected returned by
<code>ggplot.evmBoot</code>.</p>
</td></tr>
<tr><td><code id="ggplot.evmBoot_+3A_...">...</code></td>
<td>
<p>Additional arguments to <code>ggplot</code>, currently unused.</p>
</td></tr>
</table>

<hr>
<h2 id='ggplot.evmOpt'>Diagnostic plots for an evm object</h2><span id='topic+ggplot.evmOpt'></span><span id='topic+ggplot.ppevm'></span><span id='topic+ggplot.qqevm'></span><span id='topic+ggplot.hist.evmOpt'></span><span id='topic+ggplot.evmOpt+2C'></span><span id='topic+ggplotrl'></span>

<h3>Description</h3>

<p>Create and display diagnostic plots for an evm object. See <code><a href="#topic+plot.evmOpt">plot.evmOpt</a></code>
for further details on what is being plotted.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'evmOpt'
ggplot(
  data,
  mapping,
  which = 1:4,
  main = rep(NULL, 4),
  xlab = rep(NULL, 4),
  nsim = 1000,
  alpha = 0.05,
  jitter.width = 0,
  jitter.height = 0,
  ptcol = "blue",
  span = 2/3,
  col = "light blue",
  fill = "orange",
  plot. = TRUE,
  ncol = 2,
  nrow = 2,
  ...,
  environment
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ggplot.evmOpt_+3A_data">data</code></td>
<td>
<p>An object of class <code>evm</code>.</p>
</td></tr>
<tr><td><code id="ggplot.evmOpt_+3A_mapping">mapping</code>, <code id="ggplot.evmOpt_+3A_environment">environment</code></td>
<td>
<p>ignored</p>
</td></tr>
<tr><td><code id="ggplot.evmOpt_+3A_which">which</code></td>
<td>
<p>Which plots to produce. Defaults to <code>which=1:4</code>.</p>
</td></tr>
<tr><td><code id="ggplot.evmOpt_+3A_main">main</code></td>
<td>
<p>Main titles. Should have length 4.</p>
</td></tr>
<tr><td><code id="ggplot.evmOpt_+3A_xlab">xlab</code></td>
<td>
<p>Labels for x-axes.</p>
</td></tr>
<tr><td><code id="ggplot.evmOpt_+3A_nsim">nsim</code></td>
<td>
<p>Number of simulated datasets to create to form
tolerance regions.</p>
</td></tr>
<tr><td><code id="ggplot.evmOpt_+3A_alpha">alpha</code></td>
<td>
<p>Used to compute coverage of pointwise confidence
intervals.</p>
</td></tr>
<tr><td><code id="ggplot.evmOpt_+3A_jitter.width">jitter.width</code>, <code id="ggplot.evmOpt_+3A_jitter.height">jitter.height</code></td>
<td>
<p>Used to control the amount of
jittering of points in the plots of the residuals versus
covariates (when covariates are in the model).  Defaults to
<code>jitter.width=0, jitter.height = 0</code>.</p>
</td></tr>
<tr><td><code id="ggplot.evmOpt_+3A_ptcol">ptcol</code></td>
<td>
<p>Colour for points. Defaults to <code>ptcol="blue"</code>.</p>
</td></tr>
<tr><td><code id="ggplot.evmOpt_+3A_span">span</code></td>
<td>
<p>Passed to the loess smoother and defaults to
<code>span=2/3</code>. Sometimes this choice is poor: if the loess
smoother looks wrong, try <code>span=1</code>.</p>
</td></tr>
<tr><td><code id="ggplot.evmOpt_+3A_col">col</code></td>
<td>
<p>Colour for lines. Defaults to <code>col="light blue"</code>.</p>
</td></tr>
<tr><td><code id="ggplot.evmOpt_+3A_fill">fill</code></td>
<td>
<p>Colour for confidence regions. Defaults to
<code>fill="orange"</code></p>
</td></tr>
<tr><td><code id="ggplot.evmOpt_+3A_plot.">plot.</code></td>
<td>
<p>Whether or not to display the output. Defaults to
<code>plot.=TRUE</code>.  If the display doesn't have the desired row
and column layout, the user should specify <code>plot.=FALSE</code>,
asign the output to an object, and use <code>grid.arrange</code> to
display it.</p>
</td></tr>
<tr><td><code id="ggplot.evmOpt_+3A_ncol">ncol</code></td>
<td>
<p>The number of columns wanted in the resulting
plot. Defaults to <code>ncol=2</code>. This argument is passed into
<code>grid.arrange</code>.</p>
</td></tr>
<tr><td><code id="ggplot.evmOpt_+3A_nrow">nrow</code></td>
<td>
<p>The number of rows wanted in the resulting
plot. Defaults to <code>nrow=2</code>. This argument is passed into
<code>grid.arrange</code>.</p>
</td></tr>
<tr><td><code id="ggplot.evmOpt_+3A_...">...</code></td>
<td>
<p>Other arguments passed through to underlying plot
functions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function attempts to arrange the plots nicely. If the
output isn't what was wanted, the function returns the graphs
to the user as a list so that the user can use
<code>grid.arrange</code> directly.  Also, if you have one or more
covariates in the model and the loess smoother looks wrong, try
setting <code>span=1</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.evmOpt">plot.evmOpt</a></code>
</p>

<hr>
<h2 id='ggplot.evmSim'>Diagnostic plots for the Markov chains in an evmSim object</h2><span id='topic+ggplot.evmSim'></span><span id='topic+ggtraceplots'></span><span id='topic+ggdensplots'></span><span id='topic+ggacfplots'></span>

<h3>Description</h3>

<p>Diagnostic plots for the Markov chains in an evmSim object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'evmSim'
ggplot(
  data = NULL,
  mapping,
  which.plots = 1:3,
  chain = 1,
  denscol = "dark blue",
  acfcol = "light blue",
  plot.it = TRUE,
  ...,
  environment
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ggplot.evmSim_+3A_data">data</code></td>
<td>
<p>An object of class 'evmSim'.</p>
</td></tr>
<tr><td><code id="ggplot.evmSim_+3A_mapping">mapping</code>, <code id="ggplot.evmSim_+3A_environment">environment</code></td>
<td>
<p>ignored</p>
</td></tr>
<tr><td><code id="ggplot.evmSim_+3A_which.plots">which.plots</code></td>
<td>
<p>Which plots to produce. Density plots correspond
to 1, trace plots of the Markov chains to 2 and autocorrelation
function plots to 3.</p>
</td></tr>
<tr><td><code id="ggplot.evmSim_+3A_chain">chain</code></td>
<td>
<p>An integer indicating which chain to plot (only relevant if there
is more than 1 chain). Defaults to 1. If you ran multiple chains, you
should look at diagnostics for all of them.</p>
</td></tr>
<tr><td><code id="ggplot.evmSim_+3A_denscol">denscol</code></td>
<td>
<p>Colour for the density plots. Defaults to 'dark blue'.</p>
</td></tr>
<tr><td><code id="ggplot.evmSim_+3A_acfcol">acfcol</code></td>
<td>
<p>Colour for the ACF plots. Defaults to 'light blue'.</p>
</td></tr>
<tr><td><code id="ggplot.evmSim_+3A_plot.it">plot.it</code></td>
<td>
<p>Whether or not to actually print the plots. Defaults
to <code>plot.it=TRUE</code>.  If <code>plot.it=FALSE</code>, you might
want to control the layout. Do this with
<code>do.call("grid.arrange", c(plots, ncol=2))</code>, for example,
where <code>plots</code> is the objected returned by
<code>ggplot.evmSim</code>.</p>
</td></tr>
<tr><td><code id="ggplot.evmSim_+3A_...">...</code></td>
<td>
<p>Additional arguments to <code>ggplot</code>, currently unused.</p>
</td></tr>
</table>

<hr>
<h2 id='ggplot.mex'>Conditional multivariate extreme values modelling</h2><span id='topic+ggplot.mex'></span><span id='topic+mex'></span><span id='topic+plot.mex'></span><span id='topic+print.mex'></span><span id='topic+predict.mex'></span><span id='topic+summary.predict.mex'></span><span id='topic+plot.predict.mex'></span><span id='topic+mexAll'></span><span id='topic+print.mexList'></span><span id='topic+print.summary.mex'></span><span id='topic+summary.mex'></span><span id='topic+ggplot.predict.mex'></span>

<h3>Description</h3>

<p>Fit the conditional multivariate extreme value model of Heffernan and Tawn
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mex'
ggplot(
  data = NULL,
  mapping,
  ptcol = "blue",
  col = "cornflowerblue",
  fill = "orange",
  plot. = TRUE,
  quantiles = seq(0.1, by = 0.2, len = 5),
  ...,
  environment
)

mex(
  data,
  which,
  mth,
  mqu,
  dqu,
  cov = "numeric",
  family = gpd,
  margins = "laplace",
  constrain = TRUE,
  v = 10,
  penalty = "gaussian",
  maxit = 10000,
  trace = 0,
  verbose = FALSE,
  priorParameters = NULL
)

mexAll(data, mqu, dqu)

## S3 method for class 'mexList'
print(x, ...)

## S3 method for class 'mex'
plot(x, quantiles = seq(0.1, by = 0.2, len = 5), col = "grey", ...)

## S3 method for class 'predict.mex'
plot(x, pch = c(1, 3, 20), col = c(2, 8, 3), cex = c(1, 1, 1), ask = TRUE, ...)

## S3 method for class 'predict.mex'
ggplot(
  data = NULL,
  mapping,
  xlab,
  ylab,
  main,
  ptcol = c("grey", "dark blue", "orange"),
  col = "dark blue",
  fill = "orange",
  shape = 16:18,
  size = rep(1, 3),
  plot. = TRUE,
  ...,
  environment
)

## S3 method for class 'mex'
predict(
  object,
  which,
  pqu = 0.99,
  nsim = 1000,
  trace = 10,
  smoothZdistribution = FALSE,
  ...
)

## S3 method for class 'predict.mex'
summary(object, mth, probs = c(0.05, 0.5, 0.95), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ggplot.mex_+3A_data">data</code></td>
<td>
<p>A numeric matrix or data.frame, the columns of which are to be
modelled.</p>
</td></tr>
<tr><td><code id="ggplot.mex_+3A_col">col</code></td>
<td>
<p>In <code>plot</code> method for objects of class <code>mex</code>, the colour
for points on scatterplots of residuals and original data respectively.  In
<code>plot</code> method for objects of class <code>predict.mex</code>, the colours of
points for observed, and simulated data (conditioning variable not the
largest) and simulated data (conditioning variable is the largest)
respectively.</p>
</td></tr>
<tr><td><code id="ggplot.mex_+3A_quantiles">quantiles</code></td>
<td>
<p>A vector of quantiles taking values between 0 and 1
specifying the quantiles of the conditional distributions which will be
plotted.</p>
</td></tr>
<tr><td><code id="ggplot.mex_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed to methods.</p>
</td></tr>
<tr><td><code id="ggplot.mex_+3A_which">which</code></td>
<td>
<p>The variable on which to condition.  This can be either scalar,
indicating the column number of the conditioning variable, or character,
giving the column name of the conditioning variable.</p>
</td></tr>
<tr><td><code id="ggplot.mex_+3A_mth">mth</code></td>
<td>
<p>Marginal thresholds. In <code>mex</code>, the threshold above which to
fit generalized Pareto distributions.  If this is a vector of length 1, the
same threshold will be used for each variable. Otherwise, it should be a
vector whose length is equal to the number of columns in <code>data</code>.
</p>
<p>In <code>summary.predict.mex</code>, the thresholds over which to simulate data
from the fitted multivariate model. If not supplied, it is taken to be the
thresholds that were used to fit the dependence model on the scale of the
original data.</p>
</td></tr>
<tr><td><code id="ggplot.mex_+3A_mqu">mqu</code></td>
<td>
<p>Marginal quantiles As an alternative to specifying the marginal
GPD fitting thresholds via <code>mth</code>, you can specify the quantile (a
probability) above which to fit generalized Pareto distributions. If this is
a vector of length 1, the same quantile will be used for each variable.
Otherwise, it should be a vector whose length is equal to the number of
columns in <code>data</code>.</p>
</td></tr>
<tr><td><code id="ggplot.mex_+3A_dqu">dqu</code></td>
<td>
<p>Dependence quantile. Used to specify the quantile at which to
threshold the conditioning variable data when estimating the dependence
parameters.  For example <code>dqu=0.7</code> will result in the data with the
highest 30% of values of the conditioning variable being used to estimate
the dependence parameters.  The same threshold will be used for each
dependent variable.  If not supplied then the default is to set
<code>dqu=mqu[which]</code> the quantile corresponding to the threshold used to
fit the marginal model to the tail of the conditioning variable.  Note that
there is no requirement for the quantiles used for marginal fitting
(<code>mqu</code>) and dependence fitting (<code>dqu</code>) to be the same, or for them
to be ordered in any way.</p>
</td></tr>
<tr><td><code id="ggplot.mex_+3A_cov">cov</code></td>
<td>
<p>String, passed through to <code>evm</code>: how to estimate the covariance.
Defaults to <code>cov = "observed"</code>.</p>
</td></tr>
<tr><td><code id="ggplot.mex_+3A_family">family</code></td>
<td>
<p>An object of class &quot;texmexFamily&quot;. Should be either
<code>family = gpd</code> or <code>family = cgpd</code> and defaults to the first of those.</p>
</td></tr>
<tr><td><code id="ggplot.mex_+3A_margins">margins</code></td>
<td>
<p>See documentation for <code><a href="#topic+mexDependence">mexDependence</a></code>.</p>
</td></tr>
<tr><td><code id="ggplot.mex_+3A_constrain">constrain</code></td>
<td>
<p>See documentation for <code><a href="#topic+mexDependence">mexDependence</a></code>.</p>
</td></tr>
<tr><td><code id="ggplot.mex_+3A_v">v</code></td>
<td>
<p>See documentation for <code><a href="#topic+mexDependence">mexDependence</a></code>.</p>
</td></tr>
<tr><td><code id="ggplot.mex_+3A_penalty">penalty</code></td>
<td>
<p>How to penalize the likelihood when estimating the marginal
generalized Pareto distributions. Defaults to &ldquo;gaussian&rdquo;. See the help
file for <code><a href="#topic+evm">evm</a></code> for more information.</p>
</td></tr>
<tr><td><code id="ggplot.mex_+3A_maxit">maxit</code></td>
<td>
<p>The maximum number of iterations to be used by the optimizer.
defaults to <code>maxit = 10000</code>.</p>
</td></tr>
<tr><td><code id="ggplot.mex_+3A_trace">trace</code></td>
<td>
<p>Passed internally to <code><a href="stats.html#topic+optim">optim</a></code>. Whether or not to
inform the user of the progress of the optimizer. Defaults to 0, indicating
no trace.</p>
</td></tr>
<tr><td><code id="ggplot.mex_+3A_verbose">verbose</code></td>
<td>
<p>Whether or not to keep the user informed of progress.
Defaults to <code>verbose = FALSE</code>.</p>
</td></tr>
<tr><td><code id="ggplot.mex_+3A_priorparameters">priorParameters</code></td>
<td>
<p>Parameters of prior/penalty used for estimation of
the GPD parameters.  This is only used if <code>penalty = "gaussian"</code>.  It
is a named list, each element of which contains two components: the first
component should be a vector of length 2 corresponding to the location of
the Gaussian distribution; the second a 2x2 matrix corresponding to the
covariance matrix of the distribution.  The names should match the names of
the columns of <code>data</code>.  If not provided, the default priors are
independent normal, centred at zero, with variance 10000 for phi=log(sigma)
and 0.25 for xi. See the details section.</p>
</td></tr>
<tr><td><code id="ggplot.mex_+3A_x">x</code>, <code id="ggplot.mex_+3A_object">object</code></td>
<td>
<p>Object of class <code>mex</code> or <code>summary.mex</code> as returned by these functions respectively.</p>
</td></tr>
<tr><td><code id="ggplot.mex_+3A_pch">pch</code>, <code id="ggplot.mex_+3A_cex">cex</code></td>
<td>
<p>Plotting characters: colours and symbol expansion. The
observed and simulated data are plotted using different symbols, controlled
by these arguments and <code>col</code>, each of which should be of length 2.</p>
</td></tr>
<tr><td><code id="ggplot.mex_+3A_ask">ask</code></td>
<td>
<p>Whether or not to ask before changing the plot. Defaults to
<code>ask = TRUE</code>.</p>
</td></tr>
<tr><td><code id="ggplot.mex_+3A_shape">shape</code>, <code id="ggplot.mex_+3A_size">size</code>, <code id="ggplot.mex_+3A_mapping">mapping</code>, <code id="ggplot.mex_+3A_ptcol">ptcol</code>, <code id="ggplot.mex_+3A_fill">fill</code>, <code id="ggplot.mex_+3A_plot.">plot.</code>, <code id="ggplot.mex_+3A_environment">environment</code>, <code id="ggplot.mex_+3A_xlab">xlab</code>, <code id="ggplot.mex_+3A_ylab">ylab</code>, <code id="ggplot.mex_+3A_main">main</code></td>
<td>
<p>Further arguments to plot and ggplot methods.</p>
</td></tr>
<tr><td><code id="ggplot.mex_+3A_pqu">pqu</code></td>
<td>
<p>Prediction quantile. Argument to <code>predict</code> method. The
quantile of the conditioning variable above which it will be simulated for
importance sampling based prediction.  Defaults to <code>pqu = .99 </code>.</p>
</td></tr>
<tr><td><code id="ggplot.mex_+3A_nsim">nsim</code></td>
<td>
<p>Argument to <code>predict</code> method. The number of simulated
observations to be generated for prediction.</p>
</td></tr>
<tr><td><code id="ggplot.mex_+3A_smoothzdistribution">smoothZdistribution</code></td>
<td>
<p>In <code>predict.mex</code>, whether or not to sample
from the smoothed distribution of the underlying residuals.  Defaults to
<code>FALSE</code>, in which case no smoothing is carried out.  If <code>TRUE</code>
then each margin of the underlying multivariate residual is smoothed
independently, by using kernel smoothing with a normal kernel, and bandwith
chosen using the <code><a href="stats.html#topic+bw.nrd">bw.nrd</a></code> function.  This can be useful for
removing &quot;stripeyness&quot; in importance samples which have few values in the
conditional tails.</p>
</td></tr>
<tr><td><code id="ggplot.mex_+3A_probs">probs</code></td>
<td>
<p>In <code>summary</code> method for objects of class
<code>predict.mex</code>: the quantiles of the conditional distribution(s) to
calculate.  Defaults to 5%, 50% and 95%.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>mex</code> works as follows. First, Generalized Pareto
distributions (GPD) are fitted to the upper tails of each of the marginal
distributions of the data: the GPD parameters are estimated for each column
of the data in turn, independently of all other columns. Then, the
conditional multivariate approach of Heffernan and Tawn is used to model the
dependence between variables. The returned object is of class &quot;mex&quot;.
</p>
<p>This function is a wrapper for calls to <code><a href="#topic+migpd">migpd</a></code> and
<code><a href="#topic+mexDependence">mexDependence</a></code>, which estimate parameters of the marginal and
dependence components of the Heffernan and Tawn model respectively.  See
documentation of these functions for details of modelling issues including
the use of penalties / priors, threshold choice and checking for convergence
of parameter estimates.
</p>
<p>The <code>plot</code> method produces diagnostic plots for the fitted dependence
model described by Heffernan and Tawn, 2004.  The plots are best viewed by
using the plotting area split by <code>par(mfcol=c(.,.))</code> rather than
<code>mfrow</code>, see examples below.  Three diagnostic plots are produced for
each dependent variable:
</p>
<p>1) Scatterplots of the residuals Z from the fitted model of Heffernan and
Tawn (2004) are plotted against the quantile of the conditioning variable,
with a lowess curve showing the local mean of these points.  2) The absolute
value of <code>Z-mean(Z)</code> is also plotted, again with the lowess curve
showing the local mean of these points.  Any trend in the location or
scatter of these variables with the conditioning variable indicates a
violation of the model assumption that the residuals Z are indepenendent of
the conditioning variable.  This can be indicative of the dependence
threshold used being too low. 3) The final plots show the original data (on
the original scale) and the fitted quantiles (specified by <code>quantiles</code>)
of the conditional distribution of each dependent variable given the
conditioning variable.  A model that fits well will have good agreement
between the distribution of the raw data (shown by the scatter plot) and the
fitted quantiles. Note that the raw data are a sample from the joint
distribution, whereas the quantiles are those of the estimated conditional
distribution given the value of the conditioning variable, and while these
two distributions should move into the same part of the sample space as the
conditioning variable becomes more extreme, they are not the same thing!
</p>
<p>The <code>predict</code> method for <code>mex</code> works as follows. The returned
object has class &quot;predict.mex&quot;. Simulated values of the dependent variables
are created, given that the conditioning variable is above its 100<code>pqu</code>
quantile.  If <code>predict.mex</code> is passed an object <code>object</code> of class
<code>"mex"</code> then the simulated values are based only on the point estimate
of the dependence model parameters, and the original data.  If
<code>predict.mex</code> is passed an object <code>object</code> of class
<code>"bootmex"</code> then the returned value additionally contains simulated
replicate data sets corresponding to the bootstrap model parameter
estimates.  In both cases, the simulated values based on the original data
and point estimates appear in component <code>object$data$simulated</code>. The
simulated data from the bootstrap estimates appear in
<code>object$replicates</code>.
</p>
<p>The <code>plot</code> method for class <code>"predict.mex"</code> displays both the
original data and the simulated data generated above the threshold for
prediction; it shows the threshold for prediction (vertical line) and also
the curve joining equal quantiles of the marginal distributions &ndash; this is
for reference: variables that are perfectly dependent will lie exactly on
this curve.  Original data are shown with one plotting character and
simulated data with another; colours of simulated point distinguish those
points which have the conditioning variable as the largest (on a quantile
scale) or not the largest.
</p>
<p>The function <code>mexAll</code> fits a collection of GPD and conditional
dependence models, the same fitted GPD being used for all of the dependence
model fits.  This can be used in turn to generate Monte Carlo samples from
the entire sample space usign the collected dependence models.
</p>


<h3>Value</h3>

<p>A call to <code>mex</code> returns an list of class <code>mex</code> containing
the following three items: </p>
<table>
<tr><td><code>margins</code></td>
<td>
<p>An object of class
<code><a href="#topic+migpd">migpd</a></code>.</p>
</td></tr> <tr><td><code>dependence</code></td>
<td>
<p>An object of class
<code><a href="#topic+mexDependence">mexDependence</a></code>.</p>
</td></tr> <tr><td><code>call</code></td>
<td>
<p>This matches the original function
call.</p>
</td></tr></table>
<p> There are <code>plot</code>, <code>summary</code>, <code>coef</code> and <code>predict</code>
methods for this class.
</p>
<p>A call to <code>predict.mex</code> does the importance sampling for prediction,
and returns a list of class <code>"predict.mex"</code> for which there are print
and plot methods available.  The summary method for this class of object is
intended to be used following a call to the predict method, to estimate
quantiles or probabilities of threshold excesses for the fitted conditional
distributions given the conditioning variable above the threshold for
prediction.  See examples below.
</p>
<p>There are <code>print</code>, <code>summary</code> and <code>plot</code> methods available for
the class &quot;predict.mex&quot;.
</p>


<h3>Note</h3>

<p>The package <code>texmex</code> is equipped to fit GPD models to the upper
marginal tails only, not the lower tails.  This is appropriate for
extrapolating into the tails of any dependent variable when dependence
between this variable and the conditioning variable is positive.  In the
case of negative dependence between the conditioning variable and any
dependent variable, estimation of the conditional distribution of the
dependent variable for extreme values of the conditioning variable would
naturally visit the lower tail of the dependent variable.  Extrapolation
beyond the range of the observed lower tail is not supported in the current
version of <code>texmex</code>. In cases where negative dependence is observed and
extrapolation is required into the lower tail of the dependent variable, the
situation is trivially resolved by working with a reflection of the
dependent variable (Y becomes -Y and so the upper and lower tails are
swapped). Results can be calculated for the reflected variable then
reflected back to the correct scale.  This is satisfactory when only the
pair of variables (the conditioning and single dependent variable) are of
interest, but when genuine multivariate (as opposed to simply bivariate)
structure is of interest, this approach will destroy the dependence
structure between the reflected dependent variable and the remaining
dependent variables.
</p>


<h3>Author(s)</h3>

<p>Harry Southworth, Janet E. Heffernan
</p>


<h3>References</h3>

<p>J. E. Heffernan and J. A. Tawn, A conditional approach for
multivariate extreme values, Journal of the Royal Statistical Society B, 66,
497 - 546, 2004
</p>


<h3>See Also</h3>

<p><code><a href="#topic+migpd">migpd</a></code>, <code><a href="#topic+mexDependence">mexDependence</a></code>,
<code><a href="#topic+bootmex">bootmex</a></code>, <code><a href="#topic+mexMonteCarlo">mexMonteCarlo</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
w &lt;- mex(winter, mqu=.7, dqu=0.7, which="O3")
w
par(mfcol=c(3, 2))
plot(w)

par(mfcol=c(2,2))
p &lt;- predict(w)
summary(p)
summary(p,probs=c(0.01,0.2,0.5,0.8,0.99))
summary(p,probs=0.5,mth=c(40,50,150,25,50))
p
plot(p)


</code></pre>

<hr>
<h2 id='ggplot.migpd'>Fit multiple independent generalized Pareto models</h2><span id='topic+ggplot.migpd'></span><span id='topic+migpd'></span><span id='topic+plot.migpd'></span>

<h3>Description</h3>

<p>Fit multiple independent generalized Pareto models as the first step of
conditional multivariate extreme values modelling following the approach of
Heffernan and Tawn, 2004.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'migpd'
ggplot(
  data,
  mapping = NULL,
  main = c("Probability plot", "Quantile plot", "Return level plot",
    "Histogram and density"),
  xlab = rep(NULL, 4),
  nsim = 1000,
  alpha = 0.05,
  ...,
  environment
)

migpd(
  data,
  mth,
  mqu,
  penalty = "gaussian",
  maxit = 10000,
  trace = 0,
  verbose = FALSE,
  priorParameters = NULL,
  cov = "observed",
  family = gpd
)

## S3 method for class 'migpd'
plot(
  x,
  main = c("Probability plot", "Quantile plot", "Return level plot",
    "Histogram and density"),
  xlab = rep(NULL, 4),
  nsim = 1000,
  alpha = 0.05,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ggplot.migpd_+3A_data">data</code></td>
<td>
<p>A matrix or data.frame, each column of which is to be modelled.</p>
</td></tr>
<tr><td><code id="ggplot.migpd_+3A_mapping">mapping</code>, <code id="ggplot.migpd_+3A_environment">environment</code></td>
<td>
<p>Further arguments to ggplot method.</p>
</td></tr>
<tr><td><code id="ggplot.migpd_+3A_main">main</code></td>
<td>
<p>Character vector of length four: titles for plots produced by
<code>plot</code> and <code>ggplot</code> methods.</p>
</td></tr>
<tr><td><code id="ggplot.migpd_+3A_xlab">xlab</code></td>
<td>
<p>As <code>main</code> but for x-axes labels.</p>
</td></tr>
<tr><td><code id="ggplot.migpd_+3A_nsim">nsim</code></td>
<td>
<p>Number of simulations on which to base tolerance envelopes in
<code>plot</code> and <code>ggplot</code> methods.</p>
</td></tr>
<tr><td><code id="ggplot.migpd_+3A_alpha">alpha</code></td>
<td>
<p>Significance level for tolerance and confidence intervals in
<code>plot</code> and <code>ggplot</code> methods.</p>
</td></tr>
<tr><td><code id="ggplot.migpd_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed to methods.</p>
</td></tr>
<tr><td><code id="ggplot.migpd_+3A_mth">mth</code></td>
<td>
<p>Marginal thresholds. Thresholds above which to fit the models.
Only one of <code>mth</code> and <code>mqu</code> should be supplied. Length one (in
which case a common threshold is used) or length equal to the number of
columns of <code>data</code> (in which case values correspond to thresholds for
each of the columns respectively).</p>
</td></tr>
<tr><td><code id="ggplot.migpd_+3A_mqu">mqu</code></td>
<td>
<p>Marginal quantiles. Quantiles above which to fit the models. Only
one of <code>mth</code> and <code>mqu</code> should be supplied. Length as for
<code>mth</code> above.</p>
</td></tr>
<tr><td><code id="ggplot.migpd_+3A_penalty">penalty</code></td>
<td>
<p>How the likelihood should be penalized. Defaults to
&quot;gaussian&quot;. See documentation for <code><a href="#topic+evm">evm</a></code>.</p>
</td></tr>
<tr><td><code id="ggplot.migpd_+3A_maxit">maxit</code></td>
<td>
<p>The maximum number of iterations to be used by the optimizer.</p>
</td></tr>
<tr><td><code id="ggplot.migpd_+3A_trace">trace</code></td>
<td>
<p>Whether or not to tell the user how the optimizer is getting
on. The argument is passed into <code><a href="stats.html#topic+optim">optim</a></code> &ndash; see the help for that
function.</p>
</td></tr>
<tr><td><code id="ggplot.migpd_+3A_verbose">verbose</code></td>
<td>
<p>Controls whether or not the function prints to screen every
time it fits a model. Defaults to FALSE.</p>
</td></tr>
<tr><td><code id="ggplot.migpd_+3A_priorparameters">priorParameters</code></td>
<td>
<p>Only used if <code>penalty = 'gaussian'</code>. A named
list, each element of which contains two components: the first should be a
vector of length 2 corresponding to the location of the Gaussian
distribution; the second should be 2x2 matrix corresponding to the
covariance matrix of the distribution. The names should match the names of
the columns of <code>data</code>. If not provided, it defaults to independent
priors being centred at zero, with variance 10000 for log(sigma) and 0.25
for xi. See the details section.</p>
</td></tr>
<tr><td><code id="ggplot.migpd_+3A_cov">cov</code></td>
<td>
<p>String, passed through to <code>evm</code>: how to estimate the covariance.
Defaults to <code>cov = "observed"</code>.</p>
</td></tr>
<tr><td><code id="ggplot.migpd_+3A_family">family</code></td>
<td>
<p>An object of class &quot;texmexFamily&quot;. Should be either
<code>family = gpd</code> or <code>family = cgpd</code> and defaults to the first of those.</p>
</td></tr>
<tr><td><code id="ggplot.migpd_+3A_x">x</code></td>
<td>
<p>Object of class <code>migpd</code> as returned by function <code>migpd</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The parameters in the generalized Pareto distribution are estimated for each
column of the data in turn, independently of all other columns. Note,
covariate modelling of GPD parameters is not supported.
</p>
<p>Maximum likelihood estimation often fails with generalized Pareto
distributions because of the likelihood becoming flat (see, for example,
Hosking et al, 1985).  Therefore the function allows penalized likelihood
estimation, which is the same as maximum a posteriori estimation from a
Bayesian point of view.
</p>
<p>By default quadratic penalization is used, corresponding to using a Gaussian
prior. If no genuine prior information is available, the following argument
can be used. If xi = -1, the generalized Pareto distribution corresponds to
the uniform distribution, and if xi is 1 or greater, the expectation is
infinite. Thefore, xi is likely to fall in the region (-1, 1). A Gaussian
distribution centred at zero and with standard deviation 0.5 will have
little mass outside of (-1, 1) and so will often be a reasonable prior for
xi. For log(sigma) a Gaussian distribution, centred at zero and with
standard deviation 100 will often be vague.  If a Gaussian penalty is
specified but no parameters are given, the function will assume such
indpendent priors.
</p>
<p>Note that internally the function works with log(sigma), not sigma. The
reasons are that quadratic penalization makes more sense for phi=log(sigma)
than for sigma (because the distribution of log(sigma) will be more nearly
symmetric), and because it was found to stabilize computations.
</p>
<p>The associated <code>coef</code>, <code>print</code> and <code>summary</code> functions
exponentiate the log(sigma) parameter to return results on the expected
scale. If you are accessesing the parameters directly, however, take care to
be sure what scale the results are on.
</p>
<p>Threshold selection can be carried out with the help of functions
<code><a href="#topic+mrl">mrl</a></code> and <code><a href="#topic+gpdRangeFit">gpdRangeFit</a></code>.
</p>


<h3>Value</h3>

<p>An object of class &quot;migpd&quot;. There are <code>coef</code>, <code>print</code>,
<code>plot</code>, <code>ggplot</code> and <code>summary</code> functions available.
</p>


<h3>Note</h3>

<p>You are encourage to use the <code>mqu</code> argument and not <code>mth</code>.
If you use <code>mth</code>, the quantiles then need to be estimated. There
are, at the time of writing, 9 methods of estimating quantiles build into
the <code>quantile</code> function. Tiny differences can cause problems in
later stages of the analysis if functions try to simulate in an area
that is legitimate according to the numerical value of the threshold, but
not according to the estimated quantile.
</p>


<h3>Author(s)</h3>

<p>Harry Southworth
</p>


<h3>References</h3>

<p>J. E. Heffernan and J. A. Tawn, A conditional approach for
multivariate extreme values, Journal of the Royal Statistical society B, 66,
497 &ndash; 546, 2004
</p>
<p>J. R. M. Hosking and J. R. Wallis, Parameter and quantile estimation for the
generalized Pareto distribution, Technometrics, 29, 339 &ndash; 349, 1987
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mex">mex</a></code>, <code><a href="#topic+mexDependence">mexDependence</a></code>,
<code><a href="#topic+bootmex">bootmex</a></code>, <code><a href="#topic+predict.mex">predict.mex</a></code>, <code><a href="#topic+gpdRangeFit">gpdRangeFit</a></code>,
<code><a href="#topic+mrl">mrl</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

mygpd &lt;- migpd(winter, mqu=.7, penalty = "none")
mygpd
summary(mygpd)
plot(mygpd)
g &lt;- ggplot(mygpd)


</code></pre>

<hr>
<h2 id='ggplot.rl.evmOpt'>Plotting function for return level estimation</h2><span id='topic+ggplot.rl.evmOpt'></span><span id='topic+ggplot.rl.evmSim'></span><span id='topic+ggplot.rl.evmBoot'></span><span id='topic+ggplot.lp.evmOpt'></span><span id='topic+ggplot.lp.evmSim'></span><span id='topic+ggplot.lp.evmBoot'></span>

<h3>Description</h3>

<p>Plotting function for return level estimation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'rl.evmOpt'
ggplot(
  data = NULL,
  mapping,
  xlab,
  ylab,
  main,
  ylim = "auto",
  ptcol = "blue",
  col = "light blue",
  fill = "orange",
  alpha = 0.5,
  ...,
  environment
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ggplot.rl.evmOpt_+3A_data">data</code></td>
<td>
<p>An object of class <code>rl.evmOpt</code>, <code>rl.evmBoot</code>, <code>rl.evmSim</code>, <code>lp.evmOpt</code>, <code>lp.evmBoot</code> or <code>lp.evmSim</code>, .</p>
</td></tr>
<tr><td><code id="ggplot.rl.evmOpt_+3A_mapping">mapping</code></td>
<td>
<p>Not used.</p>
</td></tr>
<tr><td><code id="ggplot.rl.evmOpt_+3A_xlab">xlab</code></td>
<td>
<p>Label for the x-axis.</p>
</td></tr>
<tr><td><code id="ggplot.rl.evmOpt_+3A_ylab">ylab</code></td>
<td>
<p>Label for the y-axis.</p>
</td></tr>
<tr><td><code id="ggplot.rl.evmOpt_+3A_main">main</code></td>
<td>
<p>Plot title.</p>
</td></tr>
<tr><td><code id="ggplot.rl.evmOpt_+3A_ylim">ylim</code></td>
<td>
<p>Plot limits for y-axis.</p>
</td></tr>
<tr><td><code id="ggplot.rl.evmOpt_+3A_ptcol">ptcol</code></td>
<td>
<p>Colour for points. Defaults to <code>ptcol="blue"</code>.</p>
</td></tr>
<tr><td><code id="ggplot.rl.evmOpt_+3A_col">col</code></td>
<td>
<p>Colour for lines. Defaults to <code>col="light blue"</code>.</p>
</td></tr>
<tr><td><code id="ggplot.rl.evmOpt_+3A_fill">fill</code></td>
<td>
<p>Colour for shading polygons.</p>
</td></tr>
<tr><td><code id="ggplot.rl.evmOpt_+3A_alpha">alpha</code></td>
<td>
<p>Transparency.</p>
</td></tr>
<tr><td><code id="ggplot.rl.evmOpt_+3A_...">...</code></td>
<td>
<p>Other arguments passed through to underlying plot functions.</p>
</td></tr>
<tr><td><code id="ggplot.rl.evmOpt_+3A_environment">environment</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>

<hr>
<h2 id='gpd.prof'>Profile likelihood based confidence intervals for GPD</h2><span id='topic+gpd.prof'></span>

<h3>Description</h3>

<p>Calculates profile likelilhood based confidence intervals for a given fitted GPD model &ndash; this is only implemented for two parameter GPD with no covariates in the model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gpd.prof(
  z,
  m,
  xmax,
  xlow,
  conf = 0.95,
  nint = 50,
  PlotIt = FALSE,
  mult = 2,
  priorParameters = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gpd.prof_+3A_z">z</code></td>
<td>
<p>a fitted <code>evmOpt</code> object</p>
</td></tr>
<tr><td><code id="gpd.prof_+3A_m">m</code></td>
<td>
<p>return period : units are number of observations</p>
</td></tr>
<tr><td><code id="gpd.prof_+3A_xmax">xmax</code></td>
<td>
<p>point estimate of the return level, this is used to bracket the roots of the equation used to calculate the ends of the profile likelihood based confidence interval.  The value need not be exact.</p>
</td></tr>
<tr><td><code id="gpd.prof_+3A_xlow">xlow</code></td>
<td>
<p>value lower than the lower end of the confidence interval, for bracketing in root finding</p>
</td></tr>
<tr><td><code id="gpd.prof_+3A_conf">conf</code></td>
<td>
<p>confidence level, defaults to 0.95</p>
</td></tr>
<tr><td><code id="gpd.prof_+3A_nint">nint</code></td>
<td>
<p>used for plotting if required, number of points at which to calculate the profile likelihood for plotting, defaults to 50</p>
</td></tr>
<tr><td><code id="gpd.prof_+3A_plotit">PlotIt</code></td>
<td>
<p>logical, whether or not to plot the profile likelihood, defaults to <code>FALSE</code></p>
</td></tr>
<tr><td><code id="gpd.prof_+3A_mult">mult</code></td>
<td>
<p>used to calculate the starting point for the root finding for solving to find the upper end of the confidence interval.  The starting point is <code>mult*xmax</code> minus the lower end point. If this starting point is beyond the estimated upper endpoint of the fitted distribution then this can cause an error, and the value of <code>mult</code> should be reduced</p>
</td></tr>
<tr><td><code id="gpd.prof_+3A_priorparameters">priorParameters</code></td>
<td>
<p>optional, value of prior/penalty parameters used for penalised likelihood estimation, default to NULL</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric vector of length two, with lower and upper ends of the estiamted confidence intervals respectively.
</p>

<hr>
<h2 id='gpdRangeFit'>Estimate generalized Pareto distribution parameters over a range of values</h2><span id='topic+gpdRangeFit'></span><span id='topic+print.gpdRangeFit'></span><span id='topic+summary.gpdRangeFit'></span><span id='topic+print.summary.gpdRangeFit'></span><span id='topic+plot.gpdRangeFit'></span><span id='topic+ggplot.gpdRangeFit'></span>

<h3>Description</h3>

<p>Estimate generalized Pareto distribution parameters over a range of values,
using maximum (penalized) likelihood.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gpdRangeFit(data, umin=quantile(data, .05), umax=quantile(data, .95),
nint = 10, penalty = "gaussian", priorParameters = NULL, alpha=0.05,
cov="observed")
## S3 method for class 'gpdRangeFit'
print(x, ...)
## S3 method for class 'gpdRangeFit'
summary(object, ...)
## S3 method for class 'summary.gpdRangeFit'
print(x, ...)
## S3 method for class 'gpdRangeFit'
plot(x, xlab = "Threshold", ylab = NULL, main = NULL, addNexcesses=TRUE, ...)
## S3 method for class 'gpdRangeFit'
ggplot(data, mapping, xlab="Threshold", ylab=NULL,
main=NULL, fill="orange", col="blue", addNexcesses = TRUE, textsize=4, ...,
environment)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gpdRangeFit_+3A_data">data</code></td>
<td>
<p>The data vector to be modelled.</p>
</td></tr>
<tr><td><code id="gpdRangeFit_+3A_umin">umin</code></td>
<td>
<p>The minimum threshold above which to estimate the parameters.</p>
</td></tr>
<tr><td><code id="gpdRangeFit_+3A_umax">umax</code></td>
<td>
<p>The maximum threshold above which to estimate the parameters.</p>
</td></tr>
<tr><td><code id="gpdRangeFit_+3A_nint">nint</code></td>
<td>
<p>The number of thresholds at which to perform the estimation.</p>
</td></tr>
<tr><td><code id="gpdRangeFit_+3A_penalty">penalty</code></td>
<td>
<p>The type of penalty to be used in the maximum penalized
likelihood estimation. Should be either &quot;gaussian&quot; or &quot;none&quot;. Defaults to
&quot;gaussian&quot;.</p>
</td></tr>
<tr><td><code id="gpdRangeFit_+3A_priorparameters">priorParameters</code></td>
<td>
<p>Parameters to be used for the penalty function.  See
the help for <code><a href="#topic+evm">evm</a></code> for more informaiton.</p>
</td></tr>
<tr><td><code id="gpdRangeFit_+3A_alpha">alpha</code></td>
<td>
<p>100(1 - alpha)% confidence intervals will be plotted with the
point estimates. Defaults to <code>alpha = 0.05</code>.</p>
</td></tr>
<tr><td><code id="gpdRangeFit_+3A_cov">cov</code></td>
<td>
<p>How to compute the covariance matrix of the parameters. Defaults
to <code>cov = "observed"</code> in which case the observed information matrix is
used, if the <code>info</code> element of the <code>texmexFamily</code> object is
present. See more detailed documentation of this argument in
<code><a href="#topic+evm">evm</a></code>.</p>
</td></tr>
<tr><td><code id="gpdRangeFit_+3A_x">x</code>, <code id="gpdRangeFit_+3A_object">object</code></td>
<td>
<p>Arguments to <code>print</code> and <code>summary</code> functions.</p>
</td></tr>
<tr><td><code id="gpdRangeFit_+3A_xlab">xlab</code></td>
<td>
<p>Label for the x-axis.</p>
</td></tr>
<tr><td><code id="gpdRangeFit_+3A_ylab">ylab</code></td>
<td>
<p>Label for the y-axis.</p>
</td></tr>
<tr><td><code id="gpdRangeFit_+3A_main">main</code></td>
<td>
<p>The main title.</p>
</td></tr>
<tr><td><code id="gpdRangeFit_+3A_addnexcesses">addNexcesses</code></td>
<td>
<p>Annotate top axis with numbers of threshold excesses
arising with the corresponding values of threshold on the bottom axis.</p>
</td></tr>
<tr><td><code id="gpdRangeFit_+3A_col">col</code></td>
<td>
<p>Colour of the line on the threshold stability plot.</p>
</td></tr>
<tr><td><code id="gpdRangeFit_+3A_fill">fill</code></td>
<td>
<p>Colour of the pointwise confidence region on the threshold
stability plots.</p>
</td></tr>
<tr><td><code id="gpdRangeFit_+3A_textsize">textsize</code></td>
<td>
<p>Size of text on the plot (ggplot). Defaults to
<code>textsize=4</code>.</p>
</td></tr>
<tr><td><code id="gpdRangeFit_+3A_...">...</code></td>
<td>
<p>Arguments to <code>plot</code>.</p>
</td></tr>
<tr><td><code id="gpdRangeFit_+3A_mapping">mapping</code>, <code id="gpdRangeFit_+3A_environment">environment</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is Stuart Coles' <code>gpd.fitrange</code>, as it appears in the <code>ismev</code>
package, refactored into a function that does the computations, and method
functions. The function uses <code>evm</code> internally and uses the default
options for that function.
</p>
<p>Note this function does not extend to assessing model fit when there are
covariates included in the model.
</p>


<h3>Author(s)</h3>

<p>Stuart Coles, Janet E Heffernan, Harry Southworth
</p>


<h3>See Also</h3>

<p><code><a href="#topic+evm">evm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
par(mfrow=c(1,2))
plot(gpdRangeFit(rain))

</code></pre>

<hr>
<h2 id='JointExceedanceCurve'>Joint exceedance curves</h2><span id='topic+JointExceedanceCurve'></span><span id='topic+geom_jointExcCurve'></span><span id='topic+JointExceedanceCurve.default'></span><span id='topic+JointExceedanceCurve.mexMC'></span><span id='topic+JointExceedanceCurve.predict.mex'></span><span id='topic+calcJointExceedanceCurve'></span><span id='topic+print.jointExcCurve'></span>

<h3>Description</h3>

<p>Calculate bivariate joint exceedance curves
</p>


<h3>Usage</h3>

<pre><code class='language-R'>JointExceedanceCurve(Sample, ExceedanceProb,...)
## S3 method for class 'jointExcCurve'
print(x,...)

## Default S3 method:
JointExceedanceCurve(Sample, ExceedanceProb, n = 50, x = NULL, ...)

## S3 method for class 'mexMC'
JointExceedanceCurve(
  Sample,
  ExceedanceProb,
  n = 50,
  x = NULL,
  which = 1:2,
  ...
)

## S3 method for class 'predict.mex'
JointExceedanceCurve(
  Sample,
  ExceedanceProb,
  n = 50,
  x = NULL,
  which = 1:2,
  ...
)

calcJointExceedanceCurve(Sample, ExceedanceProb, n = 50, x = NULL)

## S3 method for class 'jointExcCurve'
print(x, ...)

geom_jointExcCurve(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="JointExceedanceCurve_+3A_sample">Sample</code></td>
<td>
<p>Monte Carlo (or other) sample from which to calculate joint exceedance curve</p>
</td></tr>
<tr><td><code id="JointExceedanceCurve_+3A_exceedanceprob">ExceedanceProb</code></td>
<td>
<p>Takes values between 0 and 1, constant value of joint exceedance probability for which the curve will be calculated</p>
</td></tr>
<tr><td><code id="JointExceedanceCurve_+3A_...">...</code></td>
<td>
<p>Further aguments to be passed to methods</p>
</td></tr>
<tr><td><code id="JointExceedanceCurve_+3A_n">n</code></td>
<td>
<p>If <code>x=NULL</code> then this is HALF the number of points at which the curve will be estimated (ie the curve is calculated at 2n locations)</p>
</td></tr>
<tr><td><code id="JointExceedanceCurve_+3A_x">x</code></td>
<td>
<p>If specified by the user, the values of in the first dimension of <code>Sample</code> at which to calculate the curve. Defaults to <code>NULL</code> otherwise should be a numeric vector within the range of the first dimension of <code>Sample</code>.</p>
</td></tr>
<tr><td><code id="JointExceedanceCurve_+3A_which">which</code></td>
<td>
<p>Vector length two identifying which margins to use for joint exceedance curve estimation. Can be integer vector, giving column numbers of original data matrix, or character vector identifying variables by name (these must match column names in original data).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Calculates pairs of points (x,y) for which the point exceedance
probability P(X&gt;x and Y&gt;y) is constant.  This is available only in
two dimensions: for higher dimensional data, the bivariate margin
will be used and other variables ignored. Takes as input either a
two column matrix of observations, output from <code>mexMonteCarlo</code>
(in which case samples from all fitted models are used to calculate curves)
or output from a call to the <code>predict</code> method for an object of
class <code>mex</code> (in which case just the single fitted model is used
for estimation, with the importance sample generated in the call
to <code>predict</code> being used to calculate the joint exceedance curve).
</p>


<h3>Value</h3>

<p>Returns an object of class <code>jointExcCurve</code>. This is a
list of length two, one for each variable for which the curve is
calculated.  Each item of the list is a vector of coordinate values
for the variable in question.  Attributes include <code>names</code> and
the exceedance probability used to calculate the curve <code>ExceedanceProb</code>.
</p>
<p>The curve is calculated by finding pairs of points (x,y) for which the empirical
probability P(X&gt;x, Y&gt;y) of both variables exceeding their corresponding value is equal
to the specified <code>ExceedanceProb</code>.  Note that when this is calculated
for an object of class <code>predict.mex</code> (returned by a call to the <code>predict</code>
method for an object of class <code>mex</code>) then the exceedance probability is
interpreted as the UNCONDITIONAL exceedance probability of the importance sample,
ie the probability of sampled values occurring from the original modelled joint
distribution, and NOT the conditional distribution used to generate the
importance sample.
</p>
<p>Estimated curve can be added to a ggplot of the data (and/or importance sample) by using the function <code>geom_jointExcCurve</code>, see examples below.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
 # for data frame of raw data
 Sigma &lt;- matrix(c(1, .5, .5, 1), ncol=2)
 m1 &lt;- rmvnorm(5000,sigma=Sigma)
 m1 &lt;- as.data.frame(m1)
 j1 &lt;- JointExceedanceCurve(m1,0.01)
 j2 &lt;- JointExceedanceCurve(m1,0.005)
 j3 &lt;- JointExceedanceCurve(m1,0.001)
 ggplot(m1,aes(V1,V2)) + geom_point(colour="dark blue",alpha=0.5) +
 geom_jointExcCurve(j1,colour="orange") +
 geom_jointExcCurve(j2,colour="orange") +
 geom_jointExcCurve(j3,colour="orange")

 # using importance sample generated by call to predict for object of class mex
 m &lt;- mex(winter,mqu=0.7,dqu=0.7,which="NO")
 m2 &lt;- predict(m,nsim=5000,pqu=0.999)
 g &lt;- ggplot(m2,plot.=FALSE)
 j4 &lt;- JointExceedanceCurve(m2,0.0005,which=c("NO","NO2"))
 j5 &lt;- JointExceedanceCurve(m2,0.0002,which=c("NO","NO2"))
 j6 &lt;- JointExceedanceCurve(m2,0.0001,which=c("NO","NO2"))
 g[[2]] +
     geom_jointExcCurve(j4,aes(NO,NO2),col="orange") +
     geom_jointExcCurve(j5,aes(NO,NO2),col="orange") +
     geom_jointExcCurve(j6,aes(NO,NO2),col="orange")

# for augmented dataset, generated by MC sampling from collection of fitted H+T models
 m &lt;- mexAll(winter,mqu=0.7,dqu=rep(0.7,5))
 m3 &lt;- mexMonteCarlo(nSample=5000,mexList=m)
 j7 &lt;- JointExceedanceCurve(m3,0.05,which=c("NO","NO2"))
 j8 &lt;- JointExceedanceCurve(m3,0.02,which=c("NO","NO2"))
 j9 &lt;- JointExceedanceCurve(m3,0.01,which=c("NO","NO2"))
 ggplot(as.data.frame(m3$MCsample[,c("NO","NO2")]),aes(NO,NO2)) +
     geom_point(col="light blue",alpha=0.5) +
     geom_jointExcCurve(j7,col="orange") +
     geom_jointExcCurve(j8,col="orange") +
     geom_jointExcCurve(j9,col="orange")

</code></pre>

<hr>
<h2 id='liver'>Liver related laboratory data</h2><span id='topic+liver'></span>

<h3>Description</h3>

<p>Liver related laboratory data from a randomized, blind, parallel group
clinical trial with 4 doses of a drug.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(liver)
</code></pre>


<h3>Format</h3>

<p>A data frame with 606 observations on the following 9 variables.
</p>

<dl>
<dt>ALP.B</dt><dd><p>Alkaline phosphatase at baseline. A numeric vector.</p>
</dd>
<dt>ALT.B</dt><dd><p>Alanine aminotransferase at baseline. A numeric vector.</p>
</dd>
<dt>AST.B</dt><dd><p>Aspartate aminotransferase at baseline. A numeric vector.</p>
</dd>
<dt>TBL.B</dt><dd><p>Total bilirubin at baseline. A numeric vector.</p>
</dd>
<dt>ALP.M</dt><dd><p>Alkaline phosphatase after treatment. A numeric vector.</p>
</dd>
<dt>ALT.M</dt><dd><p>Alanine aminotransferase after treatment. A numeric vector.</p>
</dd>
<dt>AST.M</dt><dd><p>Aspartate aminotransferase after treatment. A numeric vector.</p>
</dd>
<dt>TBL.M</dt><dd><p>Total bilirubin after treatment. A numeric vector.</p>
</dd>
<dt>dose</dt><dd><p>The treatment group (i.e. dose group). A factor with levels <code>A</code> <code>B</code> <code>C</code> <code>D</code></p>
</dd>
</dl>



<h3>Details</h3>

<p>Dose A is the lowest dose, dose, B the next, C the next, and D the highest
dose. The baseline values were taken prior to any treatment being received,
and the clinical trial had a single post-baseline visit.
</p>


<h3>Source</h3>

<p>AstraZeneca data on file.
</p>

<hr>
<h2 id='logLik.evmOpt'>Log-likelihood for evmOpt objects</h2><span id='topic+logLik.evmOpt'></span>

<h3>Description</h3>

<p>Return the log-likelihood or penalized log-likelihood for
<code>evmOpt</code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'evmOpt'
logLik(object, penalized = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logLik.evmOpt_+3A_object">object</code></td>
<td>
<p>fit model object</p>
</td></tr>
<tr><td><code id="logLik.evmOpt_+3A_penalized">penalized</code></td>
<td>
<p>whether to return the penalized log-likelihood</p>
</td></tr>
<tr><td><code id="logLik.evmOpt_+3A_...">...</code></td>
<td>
<p>some methods need more arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class <code>logLik</code>
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+logLik">logLik</a></code>
</p>

<hr>
<h2 id='makeReferenceMarginalDistribution'>Provide full marginal reference distribution for for maringal transformation</h2><span id='topic+makeReferenceMarginalDistribution'></span>

<h3>Description</h3>

<p>This gives the option of providing a set of reference marginal distributions to use for marginal transformation if the data's own marginal distribution is not appropriate (for instance if only data for which one variable is large is available, the marginal distributions of the other variables will not be represented by the available data).  In such situations, the user can supply the full marginal information of the non-thresholded variables which are necessary to transform these variables correctly from the original margins to Gumbel/Laplace for estimation of dependence model parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeReferenceMarginalDistribution(x, r, whichNoChange = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makeReferenceMarginalDistribution_+3A_x">x</code></td>
<td>
<p>output from migpd fit to the original data which does not represent at least one marginal distribution</p>
</td></tr>
<tr><td><code id="makeReferenceMarginalDistribution_+3A_r">r</code></td>
<td>
<p>output from migpd fit to the reference data which does represent the correct marginal distribution of the variable with incomplete representation in <code>x</code></p>
</td></tr>
<tr><td><code id="makeReferenceMarginalDistribution_+3A_whichnochange">whichNoChange</code></td>
<td>
<p>Margins which are not to use the supplied reference distribution <code>r</code> have numeric indices, giving column numbers in original dataframe, listed in <code>whichNoChange</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class &quot;migpd&quot;.
</p>

<hr>
<h2 id='MCS'>Multivariate conditional Spearman's rho</h2><span id='topic+MCS'></span><span id='topic+plot.MCS'></span><span id='topic+ggplot.MCS'></span><span id='topic+print.MCS'></span><span id='topic+bootMCS'></span><span id='topic+plot.bootMCS'></span><span id='topic+print.bootMCS'></span><span id='topic+summary.bootMCS'></span><span id='topic+ggplot.bootMCS'></span><span id='topic+print.summary.bootMCS'></span>

<h3>Description</h3>

<p>Compute multivariate conditional Spearman's rho over a range of quantiles.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MCS(X, p = seq(0.1, 0.9, by = 0.1))

## S3 method for class 'MCS'
plot(x, xlab = "p", ylab = "MCS", ...)

## S3 method for class 'MCS'
ggplot(data, mapping, main = "", ..., environment)

bootMCS(X, p = seq(0.1, 0.9, by = 0.1), R = 100, trace = 10)

## S3 method for class 'bootMCS'
ggplot(data, mapping, main = "", alpha = 0.05, ylim, ..., environment)

## S3 method for class 'bootMCS'
plot(x, xlab = "p", ylab = "MCS", alpha = 0.05, ylim, ...)

## S3 method for class 'bootMCS'
summary(object, alpha = 0.05, ...)

## S3 method for class 'summary.bootMCS'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MCS_+3A_x">X</code></td>
<td>
<p>A matrix of numeric variables.</p>
</td></tr>
<tr><td><code id="MCS_+3A_p">p</code></td>
<td>
<p>The quantiles at which to evaluate.</p>
</td></tr>
<tr><td><code id="MCS_+3A_x">x</code>, <code id="MCS_+3A_object">object</code></td>
<td>
<p>An object of class <code>MCS</code> or <code>bootMCS</code>.</p>
</td></tr>
<tr><td><code id="MCS_+3A_xlab">xlab</code>, <code id="MCS_+3A_ylab">ylab</code></td>
<td>
<p>Axis labels.</p>
</td></tr>
<tr><td><code id="MCS_+3A_...">...</code></td>
<td>
<p>Optional arguments to be passed into methods.</p>
</td></tr>
<tr><td><code id="MCS_+3A_data">data</code>, <code id="MCS_+3A_mapping">mapping</code>, <code id="MCS_+3A_main">main</code>, <code id="MCS_+3A_environment">environment</code></td>
<td>
<p>Arguments to ggplot method.</p>
</td></tr>
<tr><td><code id="MCS_+3A_r">R</code></td>
<td>
<p>The number of bootstrap samples to run. Defaults to <code>R = 100</code>.</p>
</td></tr>
<tr><td><code id="MCS_+3A_trace">trace</code></td>
<td>
<p>How often to inform the user of progress. Defaults to
<code>trace = 10</code>.</p>
</td></tr>
<tr><td><code id="MCS_+3A_alpha">alpha</code></td>
<td>
<p>A 100(1 - alpha)% pointwise confidence interval will be
produced.  Defaults to <code>alpha = 0.05</code>.</p>
</td></tr>
<tr><td><code id="MCS_+3A_ylim">ylim</code></td>
<td>
<p>Plotting limits for bootstrap plot.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The method is described in detail by Schmid and Schmidt (2007).  The main
code was written by Yiannis Papastathopoulos, wrappers written by Harry
Southworth.
</p>
<p>When the result of a call to <code>bootMCS</code> is plotted, simple quantile
bootstrap confidence intervals are displayed.
</p>


<h3>Value</h3>

<p>MCS returns an object of class <code>MCS</code>.  There are plot and
print methods available for this class.
</p>
<table>
<tr><td><code>MCS</code></td>
<td>
<p>The estimated correlations.</p>
</td></tr> <tr><td><code>p</code></td>
<td>
<p>The quantiles at which
the correlations were evaluated at</p>
</td></tr> <tr><td><code>call</code></td>
<td>
<p>The function call used.</p>
</td></tr>
</table>
<p>bootMCS returns an object of class <code>bootMCS</code>. There are plot and
summary methods available for this class.
</p>
<table>
<tr><td><code>replicates</code></td>
<td>
<p>Bootstrap replicates.</p>
</td></tr> <tr><td><code>p</code></td>
<td>
<p>The quantiles at which
the correlations were evaluated at</p>
</td></tr> <tr><td><code>R</code></td>
<td>
<p>Number of bootstrap samples.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>The function call used.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Yiannis Papastathopoulos, Harry Southworth
</p>


<h3>References</h3>

<p>F. Schmid and R. Schmidt, Multivariate conditional versions of
Spearman's rho and related measures of tail dependence, Journal of
Multivariate Analysis, 98, 1123 &ndash; 1140, 2007
</p>


<h3>See Also</h3>

<p><code><a href="#topic+chi">chi</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
D &lt;- liver[liver$dose == "D",]
plot(D)

Dmcs &lt;- bootMCS(D[, 5:6])
Dmcs
plot(Dmcs)

</code></pre>

<hr>
<h2 id='mexDependence'>Estimate the dependence parameters in a conditional multivariate extreme
values model</h2><span id='topic+mexDependence'></span>

<h3>Description</h3>

<p>Estimate the dependence parameters in a conditional multivariate extreme
values model using the approach of Heffernan and Tawn, 2004.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mexDependence(x, which, dqu, margins="laplace",
    constrain=TRUE, v = 10, maxit=1000000, start=c(.01, .01),
    marTransform="mixture", referenceMargin = NULL, nOptim = 1,
    PlotLikDo=FALSE, PlotLikRange=list(a=c(-1,1),b=c(-3,1)),
    PlotLikTitle=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mexDependence_+3A_x">x</code></td>
<td>
<p>An object of class &quot;migpd&quot; as returned by
<code><a href="#topic+migpd">migpd</a></code>.</p>
</td></tr>
<tr><td><code id="mexDependence_+3A_which">which</code></td>
<td>
<p>The name of the variable on which to condition. This
is the name of a column of the data that was passed into
<code>migpd</code>.</p>
</td></tr>
<tr><td><code id="mexDependence_+3A_dqu">dqu</code></td>
<td>
<p>See documentation for this argument in
<code><a href="#topic+mex">mex</a></code>.</p>
</td></tr>
<tr><td><code id="mexDependence_+3A_margins">margins</code></td>
<td>
<p>The form of margins to which the data are
transformed for carrying out dependence estimation.  Defaults
to &quot;laplace&quot;, with the alternative option being &quot;gumbel&quot;.  The
choice of margins has an impact on the interpretation of the
fitted dependence parameters.  Under Gumbel margins, the
estimated parameters a and b describe only positive dependence,
while c and d describe negative dependence in this case.  For
Laplace margins, only parameters a and b are estimated as these
capture both positive and negative dependence.</p>
</td></tr>
<tr><td><code id="mexDependence_+3A_constrain">constrain</code></td>
<td>
<p>Logical value.  Defaults to <code>constrain=TRUE</code>
although this will subsequently be changed to FALSE if
<code>margins="gumbel"</code> for which constrained estimation is not
implemented.  If <code>margins="laplace"</code> and
<code>constrain=TRUE</code> then the dependence parameter space is
constrained to allow only combinations of parameters which give
the correct stochastic ordering between (positively and
negatively) asymptotically dependent variables and variables
which are asymptotically independent.</p>
</td></tr>
<tr><td><code id="mexDependence_+3A_v">v</code></td>
<td>
<p>Scalar. Tuning parameter used to carry out constrained
estimation of dependence structure under
<code>constrain=TRUE</code>. Takes positive values greater than 1;
values between 2 and 10 are recommended.</p>
</td></tr>
<tr><td><code id="mexDependence_+3A_maxit">maxit</code></td>
<td>
<p>The maximum number of iterations to be used by the
optimizer.  Defaults to <code>maxit = 1000000</code>.</p>
</td></tr>
<tr><td><code id="mexDependence_+3A_start">start</code></td>
<td>
<p>Optional starting value for dependence estimation.
This can be: a vector of length two, with values corresponding
to dependence parameters a and b respectively, and in which
case <code>start</code> is used as a starting value for numerical
estimation of each of the dependence models to be estimated; a
matrix with two rows corresponding to dependence parameters a
and b respectively and number of columns equal to the number of
dependence models to be estimated (the ordering of the columns
will be as in the original data matrix); or a previously
estimated object of class &quot;mex&quot; whose dependence parameter
estimates are used as a starting point for estimation.  Note
that under <code>constrain=TRUE</code>, if supplied, <code>start</code>
must lie within the permitted area of the parameter space.</p>
</td></tr>
<tr><td><code id="mexDependence_+3A_martransform">marTransform</code></td>
<td>
<p>Optional form of transformation to be used for
probability integral transform of data from original to Gumbel
or Laplace margins.  Takes values <code>marTransform="mixture"</code>
(the default) or <code>marTransform="empirical"</code>. When
<code>marTransform="mixture"</code>, the rank transform is used below
the corresponding GPD fitting threshold used in <code>x</code>, and
the fitted gpd tail model is used above this threshold.  When
<code>marTransform="empirical"</code> the rank transform is used for
the entire range of each marginal distribution.</p>
</td></tr>
<tr><td><code id="mexDependence_+3A_referencemargin">referenceMargin</code></td>
<td>
<p>Optional set of reference marginal
distributions to use for marginal transformation if the data's
own marginal distribution is not appropriate (for instance if
only data for which one variable is large is available, the
marginal distributions of the other variables will not be
represented by the available data).  This object can be created
from a combination of datasets and fitted GPDs using the
function <code>makeReferenceMarginalDistribution</code>.</p>
</td></tr>
<tr><td><code id="mexDependence_+3A_noptim">nOptim</code></td>
<td>
<p>Number of times to run optimiser when estimating
dependence model parameters. Defaults to 1.  In the case of
<code>nOptim &gt; 1</code> the first call to the optimiser uses the
value <code>start</code> as a starting point, while subsequent calls
to the optimiser are started at the parameter value to which
the previous call converged.</p>
</td></tr>
<tr><td><code id="mexDependence_+3A_plotlikdo">PlotLikDo</code></td>
<td>
<p>Logical value: whether or not to plot the profile
likelihood surface for dependence model parameters under
constrained estimation.</p>
</td></tr>
<tr><td><code id="mexDependence_+3A_plotlikrange">PlotLikRange</code></td>
<td>
<p>This is used to specify a region of the
parameter space over which to plot the profile log-likelihood
surface.  List of length 2; each item being a vector of length
two corresponding to the plotting ranges for dependence
parameters a and b respectively. If this argument is not
missing, then <code>PlotLikDo</code> is set equal to TRUE.</p>
</td></tr>
<tr><td><code id="mexDependence_+3A_plotliktitle">PlotLikTitle</code></td>
<td>
<p>Used only if <code>PlotLikDo=TRUE</code>.  Character
string.  Optional title added to the profile log-likelihood
surface plot.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Estimates the extremal dependence structure of the data in <code>x</code>.  The
precise nature of the estimation depends on the value of <code>margins</code>.  If
<code>margins="laplace"</code> (the default) then dependence parameters a and b
are estimated after transformation of the data to Laplace marginal
distributions.  These parameters can describe both positive and negative
dependence.  If <code>margins="gumbel"</code> then the parameters a, b, c and d in
the dependence structure described by Heffernan and Tawn (2004) are
estimated in the following two steps: first, a and b are estimated; then, if
a=0 and b is negative, parameters c and d are estimated (this is the case of
negative dependence). Otherwise c and d will be fixed at zero (this is the
case of positive dependence).
</p>
<p>If <code>margins="laplace"</code> then the option of constrained parameter
estimation is available by setting argument <code>constrain=TRUE</code>.  The
default is to constrain the values of the parameters
(<code>constrain=TRUE</code>).  This constrained estimation ensures validity of
the estimated model, and enforces the consistency of the fitted dependence
model with the strength of extremal dependence exhibited by the data.  More
details are given in Keef et al. (2013).  The effect of this constraint is
to limit the shape of the dependence parameter space so that its boundary is
curved rather than following the original box constraints suggested by
Heffernan and Tawn (2004).  The constraint brings with it some performance
issues for the optimiser used to estimate the dependence parameters, in
particular sensitivity to choice of starting value which we describe now.
</p>
<p>The dependence parameter estimates returned by this function can be
particularly sensitive to the choice of starting value used for the
optimisation.  This is especially true when <code>margins="laplace"</code> and
<code>constrain=TRUE</code>, in which case the maximum of the objective function
can lie on the edge of the (possibly curved) constrained parameter space.
It is therefore up to the user to check that the reported parameter
estimates really do correspond to the maximum of the profile lilkelihood
surface.  This is easily carried out by using the visual diagnostics invoked
by setting <code>PlotLikDo=TRUE</code> and adjusting the plotting area by using
the argument <code>PlotLikRange</code> to focus on the region containing the
surface maximum.  See an example below which illustrates the use of this
diagnostic.
</p>


<h3>Value</h3>

<p>An object of class <code>mex</code> which is a list containing
the following three objects: </p>
<table>
<tr><td><code>margins</code></td>
<td>
<p>An object of class
<code><a href="#topic+migpd">migpd</a></code>.</p>
</td></tr> <tr><td><code>dependence</code></td>
<td>
<p>An object of class
<code><a href="#topic+mexDependence">mexDependence</a></code>.</p>
</td></tr> <tr><td><code>call</code></td>
<td>
<p>This matches the
original function call.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Harry Southworth, Janet E. Heffernan
</p>


<h3>References</h3>

<p>J. E. Heffernan and J. A. Tawn, A conditional approach
for multivariate extreme values, Journal of the Royal
Statistical society B, 66, 497 &ndash; 546, 2004.
</p>
<p>C. Keef, I. Papastathopoulos and J. A. Tawn.  Estimation of the conditional
distribution of a multivariate variable given that one of its components is
large: Additional constraints for the Heffernan and Tawn model, Journal of
Multivariate Analysis, 115, 396 &ndash; 404, 2013
</p>


<h3>See Also</h3>

<p><code><a href="#topic+migpd">migpd</a></code>, <code><a href="#topic+bootmex">bootmex</a></code>,
<code><a href="#topic+predict.mex">predict.mex</a></code>, <code><a href="#topic+plot.mex">plot.mex</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(winter)
mygpd &lt;- migpd(winter , mqu=.7, penalty="none")
mexDependence(mygpd , which = "NO", dqu=.7)

# focus on 2-d example with parameter estimates on boundary of constrained parameter space:
NO.NO2 &lt;- migpd(winter[,2:3] , mqu=.7, penalty="none")

# starting value gives estimate far from true max:
mexDependence(NO.NO2, which = "NO",dqu=0.7,start=c(0.01,0.01),
              PlotLikDo=TRUE,PlotLikTitle=c("NO2 | NO"))

# zoom in on plotting region containing maximum:
mexDependence(NO.NO2, which = "NO",dqu=0.7,start=c(0.01,0.01),
              PlotLikDo=TRUE,PlotLikTitle=c("NO2 | NO"),
              PlotLikRange = list(a=c(0,0.8),b=c(-0.2,0.6)))

# try different starting value:
mexDependence(NO.NO2, which = "NO",dqu=0.7,start=c(0.1,0.1),
              PlotLikDo=TRUE,PlotLikTitle=c("NO2 | NO"),
              PlotLikRange = list(a=c(0,0.8),b=c(-0.2,0.6)))


</code></pre>

<hr>
<h2 id='mexMonteCarlo'>Simulation from dependence models</h2><span id='topic+mexMonteCarlo'></span>

<h3>Description</h3>

<p>Simulate Monte Carlo sample from a collection of fitted conditional
dependence models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mexMonteCarlo(nSample,mexList,mult=10)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mexMonteCarlo_+3A_nsample">nSample</code></td>
<td>
<p>Required sample size.</p>
</td></tr>
<tr><td><code id="mexMonteCarlo_+3A_mexlist">mexList</code></td>
<td>
<p>List of fitted dependence models (returned by
<code><a href="#topic+mexAll">mexAll</a></code>).</p>
</td></tr>
<tr><td><code id="mexMonteCarlo_+3A_mult">mult</code></td>
<td>
<p>Integer specifying what multiple of the total number of points
should be generated for rejection sample</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Generates a Monte Carlo sample of the required size from a collection of
conditional multivariate extreme values model of Heffernan and Tawn, 2004.
For each marginal variable, the model that conditions on that margin is used
to simulate values in the part of the sample space for which that margin is
the largest of all marignal variables (measured on a quantile scale).
</p>


<h3>Value</h3>

<p>A list with the following components:
</p>
<table>
<tr><td><code>nR</code></td>
<td>
<p>For each margin, number of original Monte Carlo points replaced by
points generated under the corresponding conditional model.</p>
</td></tr>
<tr><td><code>MCsample</code></td>
<td>
<p>Matrix contiaining the Monte Carlo sample, dimension
<code>nSample</code> by dimension of original dataset.</p>
</td></tr> <tr><td><code>whichMax</code></td>
<td>
<p>Vector of
indices indicating which variable is largest (on the quantile scale)</p>
</td></tr>
<tr><td><code>whichMaxAboveThresh</code></td>
<td>
<p>Logical vector indicating which of the variables
identified by <code>whichMax</code> are additionally above the corresponding
threshold for dependence estimation.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Harry Southworth, Janet E. Heffernan
</p>


<h3>References</h3>

<p>J. E. Heffernan and J. A. Tawn, A conditional approach for
multivariate extreme values, Journal of the Royal Statistical society B, 66,
497 &ndash; 546, 2004
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  mAll &lt;- mexAll(winter,mqu=0.7,dqu=c(0.7,0.7,0.7,0.7,0.7))
  mexMC &lt;- mexMonteCarlo(5000,mAll)
  pairs(mexMC$MCsample)

</code></pre>

<hr>
<h2 id='mexRangeFit'>Estimate dependence parameters in a conditional multivariate extreme values
model over a range of thresholds.</h2><span id='topic+mexRangeFit'></span>

<h3>Description</h3>

<p>Diagnostic tool to aid the choice of threshold to be used for the estimation
of the dependence parameters in the conditional multivariate extreme values
model of Heffernan and Tawn, 2004.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mexRangeFit(x, which, quantiles = seq(0.5, 0.9, length = 9),
start=c(.01, .01), R = 10, nPass=3, trace=10, margins = "laplace", constrain
= TRUE, v = 10, referenceMargin=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mexRangeFit_+3A_x">x</code></td>
<td>
<p>An object of class <code><a href="#topic+mex">mex</a></code> or <code><a href="#topic+migpd">migpd</a></code>.</p>
</td></tr>
<tr><td><code id="mexRangeFit_+3A_which">which</code></td>
<td>
<p>The variable on which to condition.</p>
</td></tr>
<tr><td><code id="mexRangeFit_+3A_quantiles">quantiles</code></td>
<td>
<p>A numeric vector specifying the quantiles of the marginal
distribution of the conditioning variable at which to fit the dependence
model.</p>
</td></tr>
<tr><td><code id="mexRangeFit_+3A_start">start</code></td>
<td>
<p>See documentation for this argument in
<code><a href="#topic+mexDependence">mexDependence</a></code>.</p>
</td></tr>
<tr><td><code id="mexRangeFit_+3A_r">R</code></td>
<td>
<p>The number of bootstrap runs to perform at each threshold. Defaults
to <code>R</code>=10.</p>
</td></tr>
<tr><td><code id="mexRangeFit_+3A_npass">nPass</code></td>
<td>
<p>Argument passed to function <code><a href="#topic+bootmex">bootmex</a></code>.</p>
</td></tr>
<tr><td><code id="mexRangeFit_+3A_trace">trace</code></td>
<td>
<p>Argument passed to function <code><a href="#topic+bootmex">bootmex</a></code>.</p>
</td></tr>
<tr><td><code id="mexRangeFit_+3A_margins">margins</code></td>
<td>
<p>Argument passed to function <code><a href="#topic+mexDependence">mexDependence</a></code>.</p>
</td></tr>
<tr><td><code id="mexRangeFit_+3A_constrain">constrain</code></td>
<td>
<p>Argument passed to function <code><a href="#topic+mexDependence">mexDependence</a></code>.</p>
</td></tr>
<tr><td><code id="mexRangeFit_+3A_v">v</code></td>
<td>
<p>Argument passed to function <code><a href="#topic+mexDependence">mexDependence</a></code>.</p>
</td></tr>
<tr><td><code id="mexRangeFit_+3A_referencemargin">referenceMargin</code></td>
<td>
<p>Optional set of reference marginal distributions to use for marginal transformation if the data's own marginal distribution is not appropriate (for instance if only data for which one variable is large is available, the marginal distributions of the other variables will not be represented by the available data).  This object can be created from a combination of datasets and fitted GPDs using the function <code>makeReferenceMarginalDistribution</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Dependence model parameters are estimated using a range of threshold values.
The sampling variability of these estimates is characterised using the
bootstrap.  Point estimates and bootstrap estimates are finally plotted over
the range of thresholds.  Choice of threshold should be made such that the
point estimates at the chosen threshold and beyond are constant, up to
sampling variation.
</p>


<h3>Value</h3>

<p>NULL.
</p>


<h3>Author(s)</h3>

<p>Harry Southworth, Janet E. Heffernan
</p>


<h3>References</h3>

<p>J. E. Heffernan and J. A. Tawn, A conditional approach for
multivariate extreme values, Journal of the Royal Statistical society B, 66,
497 &ndash; 546, 2004
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mexDependence">mexDependence</a></code>, <code><a href="#topic+bootmex">bootmex</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

  w &lt;- migpd(winter, mqu=.7)
  w
  par(mfrow=c(4,2))
  plot(mexRangeFit(w, which=1),main="Winter data, Heffernan and Tawn 2004",cex=0.5)


</code></pre>

<hr>
<h2 id='migpdCoefs'>Change values of parameters in a migpd object</h2><span id='topic+migpdCoefs'></span>

<h3>Description</h3>

<p>Change the values of parameters in a <code>migpd</code> object. You might want to
do this after modelling marginal distributions as functions of covariates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>migpdCoefs(object, which, coefs)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="migpdCoefs_+3A_object">object</code></td>
<td>
<p>An object of class <code>migpd</code>.</p>
</td></tr>
<tr><td><code id="migpdCoefs_+3A_which">which</code></td>
<td>
<p>Which models in the <code>migpd</code> object you want to change.</p>
</td></tr>
<tr><td><code id="migpdCoefs_+3A_coefs">coefs</code></td>
<td>
<p>The coefficients that you want to change to. If <code>which</code>
has length 1, <code>coefs</code> can be a vector of parameters.  Otherwise, it
should be a list of vectors, and the list should have the same length as
<code>which</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>migpd</code> object. See the help for <code><a href="#topic+migpd">migpd</a></code>.
</p>


<h3>Author(s)</h3>

<p>Harry Southworth
</p>


<h3>See Also</h3>

<p><code><a href="#topic+migpd">migpd</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(MASS)
liver &lt;- liver
liver$ndose &lt;- as.numeric(liver$dose)
d &lt;- data.frame(alt = resid(rlm(log(ALT.M) ~ log(ALT.B) + ndose, data=liver)),
                ast = resid(rlm(log(AST.M) ~ log(AST.B) + ndose, data=liver)),
                alp = resid(rlm(log(ALP.M) ~ log(ALP.B) + ndose, data=liver)),
                tbl = resid(rlm(log(TBL.M) ~ log(TBL.B) + ndose, data=liver)))

Dgpds &lt;- migpd(d[liver$dose == "D", 1:4], mqu=.7)

d$ndose &lt;- liver$ndose
galt &lt;- evm("alt", data=d, qu=.7, xi = ~ ndose)
gast &lt;- evm("ast", data=d, qu=.7, xi = ~ ndose)
galp &lt;- evm("alp", data=d, qu=.7, xi = ~ ndose)

altco &lt;- predict(galt,type="lp",newdata=data.frame(ndose=4))$obj$link[1:2]
astco &lt;- predict(gast,type="lp",newdata=data.frame(ndose=4))$obj$link[1:2]
alpco &lt;- predict(galp,type="lp",newdata=data.frame(ndose=4))$obj$link[1:2]

Dgpd &lt;- migpdCoefs(Dgpds, which=c("alt", "ast", "alp"),
                   coefs=list(altco, astco, alpco))

summary(Dgpd)
summary(Dgpds)


</code></pre>

<hr>
<h2 id='mrl'>Mean residual life plot</h2><span id='topic+mrl'></span><span id='topic+print.mrl'></span><span id='topic+summary.mrl'></span><span id='topic+print.summary.mrl'></span><span id='topic+plot.mrl'></span><span id='topic+ggplot.mrl'></span>

<h3>Description</h3>

<p>Calculate mean residual life and plot it to aid the identification of a
threshold over which to fit a generalized Pareto distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mrl(data, umin = min(data), umax = max(data) - 0.1, nint = 100,
alpha=.050)
## S3 method for class 'mrl'
print(x, ...)
## S3 method for class 'summary.mrl'
print(x, ...)
## S3 method for class 'mrl'
summary(object, ...)
## S3 method for class 'mrl'
plot(x, xlab="Threshold", ylab="Mean excess", ...)
## S3 method for class 'mrl'
ggplot(data, mapping, xlab = "Threshold",
  ylab = "Mean excess", main=NULL,fill="orange", col="blue",
  rug=TRUE, addNexcesses=TRUE, textsize=4, ..., environment)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mrl_+3A_data">data</code></td>
<td>
<p>A numeric vector.</p>
</td></tr>
<tr><td><code id="mrl_+3A_umin">umin</code></td>
<td>
<p>The minimum value over which to threshold the data.</p>
</td></tr>
<tr><td><code id="mrl_+3A_umax">umax</code></td>
<td>
<p>The maximum value over which to threshold the data.</p>
</td></tr>
<tr><td><code id="mrl_+3A_nint">nint</code></td>
<td>
<p>The number of points at which to compute the plot.</p>
</td></tr>
<tr><td><code id="mrl_+3A_alpha">alpha</code></td>
<td>
<p>Used to determine coverage of confidence interval to plot.
Defaults to plotting a 95% interval.</p>
</td></tr>
<tr><td><code id="mrl_+3A_x">x</code>, <code id="mrl_+3A_object">object</code></td>
<td>
<p>Arguments to print, summary and plot functions.</p>
</td></tr>
<tr><td><code id="mrl_+3A_xlab">xlab</code></td>
<td>
<p>Label for the x-axis. Defaults to <code>xlab="Threshold"</code>.</p>
</td></tr>
<tr><td><code id="mrl_+3A_ylab">ylab</code></td>
<td>
<p>Label for the y-axis. Defaults to <code>ylab="Mean excess"</code>.</p>
</td></tr>
<tr><td><code id="mrl_+3A_...">...</code></td>
<td>
<p>Optional arguments to <code>plot</code>.</p>
</td></tr>
<tr><td><code id="mrl_+3A_col">col</code></td>
<td>
<p>Colour of the line on the MRL plot.</p>
</td></tr>
<tr><td><code id="mrl_+3A_rug">rug</code></td>
<td>
<p>Whether to add raw data as a rug along axis of plot.</p>
</td></tr>
<tr><td><code id="mrl_+3A_fill">fill</code></td>
<td>
<p>Colour of the pointwise confidence region on the MRL plot.</p>
</td></tr>
<tr><td><code id="mrl_+3A_main">main</code></td>
<td>
<p>Main title.</p>
</td></tr>
<tr><td><code id="mrl_+3A_addnexcesses">addNexcesses</code></td>
<td>
<p>Whether to annotate the plot with the numbers of
excesses over increasing thresholds. Defaults to <code>addNexcesses=TRUE</code>.</p>
</td></tr>
<tr><td><code id="mrl_+3A_textsize">textsize</code></td>
<td>
<p>Size of text on the plot (ggplot). Defaults to
<code>textsize=4</code>.</p>
</td></tr>
<tr><td><code id="mrl_+3A_mapping">mapping</code>, <code id="mrl_+3A_environment">environment</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Threshold choice for the fitting of the GPD is guided by the shape of the
Mean Residual Life plot.  A threshold which is suitably high will have a
corresponding mrl plot which is approximately linear in shape above the
threshold (up to sampling variation).
</p>


<h3>Value</h3>

<p>A list with two components. <code>data</code> is the original data,
<code>mrl</code> is a matrix containing information to produce the mean residual
life plot.
</p>


<h3>Note</h3>

<p>The function was originally written by Stuart Coles and appears in the
<code>ismev</code> package. This version modified by Harry Southworth to allow
more control over the appearance of the plot.
</p>


<h3>Author(s)</h3>

<p>Janet E. Heffernan, Harry Southworth
</p>


<h3>References</h3>

<p>S. Coles, An Introduction to Statistical Modeling of Extreme
Values, Springer, 2001
</p>

<hr>
<h2 id='plot.copula'>Plot copulas</h2><span id='topic+plot.copula'></span>

<h3>Description</h3>

<p>Plot copulas
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'copula'
plot(x, jitter. = FALSE, jitter.factor = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.copula_+3A_x">x</code></td>
<td>
<p>A copula object</p>
</td></tr>
<tr><td><code id="plot.copula_+3A_jitter.">jitter.</code></td>
<td>
<p>If <code>jitter=TRUE</code>, the values are jittered
before plotting. Defaults to <code>jitter. = FALSE</code>.</p>
</td></tr>
<tr><td><code id="plot.copula_+3A_jitter.factor">jitter.factor</code></td>
<td>
<p>How much jittering to use. Defaults to
<code>jitter.factor = 1</code>.</p>
</td></tr>
<tr><td><code id="plot.copula_+3A_...">...</code></td>
<td>
<p>Other arguments to pass through to <code>plot</code>.</p>
</td></tr>
</table>

<hr>
<h2 id='plot.evmOpt'>Plots for evmOpt objects</h2><span id='topic+plot.evmOpt'></span>

<h3>Description</h3>

<p>Various plots for <code>evmOpt</code> objects. These differ depending on
whether or not there are covariates in the model.  If there are no
covariates then the diagnostic plots are PP- and QQ-plots, a return
level plot (produced by <code>plotrl.evmSim</code>) and a histogram of
the data with superimposed density estimate.  These are all
calculated using the data on the original scale. If there are
covariates in the model then the diagnostics consist of PP- and QQ-
plots calculated by using the model residuals (which will be
standard exponential devaiates under the GPD model and standard
Gumbel deviates under the GEV model), and plots of residuals versus
fitted model parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'evmOpt'
plot(
  x,
  main = rep(NULL, 4),
  xlab = rep(NULL, 4),
  nsim = 1000,
  alpha = 0.05,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.evmOpt_+3A_x">x</code></td>
<td>
<p>an object of class <code>evmOpt</code></p>
</td></tr>
<tr><td><code id="plot.evmOpt_+3A_main">main</code></td>
<td>
<p>titles for diagnostic plots. Should be a vector of
length 4, with values corresponding to the character strings to
appear on the titles of the pp, qq, return level, and density
estimate plots respectively.</p>
</td></tr>
<tr><td><code id="plot.evmOpt_+3A_xlab">xlab</code></td>
<td>
<p>As for <code>main</code> but labels for x-axes rather than
titles.</p>
</td></tr>
<tr><td><code id="plot.evmOpt_+3A_nsim">nsim</code></td>
<td>
<p>The number of replicates to be simulated to produce the
simulated tolerance intervals.</p>
</td></tr>
<tr><td><code id="plot.evmOpt_+3A_alpha">alpha</code></td>
<td>
<p>A <code class="reqn">100(1 - \alpha)\%</code> simulation
envelope is produced.</p>
</td></tr>
<tr><td><code id="plot.evmOpt_+3A_...">...</code></td>
<td>
<p>FIXME</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The PP- and QQ-plots show simulated pointwise tolerance intervals.
The region is a <code class="reqn">100(1 - \alpha)\%</code> region based
on <code>nsim</code> simulated samples.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+evm">evm</a></code>
</p>

<hr>
<h2 id='plot.evmSim'>Plots for evmSim objects</h2><span id='topic+plot.evmSim'></span>

<h3>Description</h3>

<p>This function produces diagnostic plots for the Markov chains used
to simulate from the posterior distributions for the model
parameters. If the chains have converged on the posterior
distributions, the trace plots should look like
&quot;fat hairy caterpillars&quot; and their cumulative means should converge
rapidly. Moreover, the autocorrelation functions should converge
quickly to zero.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'evmSim'
plot(
  x,
  which.plots = 1:3,
  chain = 1,
  density.adjust = 2,
  print.seed = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.evmSim_+3A_x">x</code></td>
<td>
<p>an object of class <code>evmSim</code></p>
</td></tr>
<tr><td><code id="plot.evmSim_+3A_which.plots">which.plots</code></td>
<td>
<p>Which plots to produce. Option 1 gives kernel
density estimates, 2 gives traces of the Markov chains with
superimposed cumulative means, 3 gives autocorrelation
functions.</p>
</td></tr>
<tr><td><code id="plot.evmSim_+3A_chain">chain</code></td>
<td>
<p>Which chain to use in the trace and ACF plots. Only used if
more than one chain was run. Defaults to <code>chain = 1</code>. If you ran
multiple chains, you'll want to look at them all.</p>
</td></tr>
<tr><td><code id="plot.evmSim_+3A_density.adjust">density.adjust</code></td>
<td>
<p>In <code>plot</code> method for class
<code>evmSim</code>.  Passed into <code>density</code>. Controls the amount
of smoothing of the kernel density estimate.</p>
</td></tr>
<tr><td><code id="plot.evmSim_+3A_print.seed">print.seed</code></td>
<td>
<p>Whether or not to print the seed used in the
simulations, or to annotate the plots with it.</p>
</td></tr>
<tr><td><code id="plot.evmSim_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+evm">evm</a></code>
</p>
<p><code><a href="stats.html#topic+density">density</a></code>
</p>

<hr>
<h2 id='plot.lp.evmOpt'>Predict return levels from extreme value models, or obtain the linear
predictors.</h2><span id='topic+plot.lp.evmOpt'></span><span id='topic+predict.evmOpt'></span><span id='topic+linearPredictors.evmOpt'></span><span id='topic+linearPredictors'></span><span id='topic+predict.evmSim'></span><span id='topic+linearPredictors.evmSim'></span><span id='topic+predict.evmBoot'></span><span id='topic+linearPredictors.evmBoot'></span><span id='topic+print.lp.evmOpt'></span>

<h3>Description</h3>

<p>Predict return levels from extreme value models, or obtain the linear
predictors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lp.evmOpt'
plot(
  x,
  main = NULL,
  pch = 1,
  ptcol = 2,
  cex = 0.75,
  linecol = 4,
  cicol = 1,
  polycol = 15,
  plot. = TRUE,
  ...
)

## S3 method for class 'evmOpt'
predict(
  object,
  M = 1000,
  newdata = NULL,
  type = "return level",
  se.fit = FALSE,
  ci.fit = FALSE,
  alpha = 0.05,
  unique. = TRUE,
  ...
)

## S3 method for class 'evmOpt'
linearPredictors(
  object,
  newdata = NULL,
  se.fit = FALSE,
  ci.fit = FALSE,
  alpha = 0.05,
  unique. = TRUE,
  full.cov = FALSE,
  ...
)

linearPredictors(
  object,
  newdata = NULL,
  se.fit = FALSE,
  ci.fit = FALSE,
  alpha = 0.05,
  unique. = TRUE,
  ...
)

## S3 method for class 'evmSim'
predict(
  object,
  M = 1000,
  newdata = NULL,
  type = "return level",
  se.fit = FALSE,
  ci.fit = FALSE,
  alpha = 0.05,
  unique. = TRUE,
  all = FALSE,
  sumfun = NULL,
  ...
)

## S3 method for class 'evmSim'
linearPredictors(
  object,
  newdata = NULL,
  se.fit = FALSE,
  ci.fit = FALSE,
  alpha = 0.05,
  unique. = TRUE,
  all = FALSE,
  sumfun = NULL,
  ...
)

## S3 method for class 'evmBoot'
predict(
  object,
  M = 1000,
  newdata = NULL,
  type = "return level",
  se.fit = FALSE,
  ci.fit = FALSE,
  alpha = 0.05,
  unique. = TRUE,
  all = FALSE,
  sumfun = NULL,
  ...
)

## S3 method for class 'evmBoot'
linearPredictors(
  object,
  newdata = NULL,
  se.fit = FALSE,
  ci.fit = FALSE,
  alpha = 0.05,
  unique. = TRUE,
  all = FALSE,
  sumfun = NULL,
  ...
)

## S3 method for class 'lp.evmOpt'
print(x, digits = 3, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.lp.evmOpt_+3A_x">x</code></td>
<td>
<p>An object of class <code>lp.evmOpt</code>, <code>lp.evmSim</code> or
<code>lp.evmBoot</code>, to be passed to methods for these classes.</p>
</td></tr>
<tr><td><code id="plot.lp.evmOpt_+3A_main">main</code>, <code id="plot.lp.evmOpt_+3A_pch">pch</code>, <code id="plot.lp.evmOpt_+3A_ptcol">ptcol</code>, <code id="plot.lp.evmOpt_+3A_cex">cex</code>, <code id="plot.lp.evmOpt_+3A_linecol">linecol</code>, <code id="plot.lp.evmOpt_+3A_cicol">cicol</code>, <code id="plot.lp.evmOpt_+3A_polycol">polycol</code>, <code id="plot.lp.evmOpt_+3A_plot">plot</code>, <code id="plot.lp.evmOpt_+3A_plot.">plot.</code></td>
<td>
<p>Further arguments to plot
methods.</p>
</td></tr>
<tr><td><code id="plot.lp.evmOpt_+3A_...">...</code></td>
<td>
<p>Further arguments to methods.</p>
</td></tr>
<tr><td><code id="plot.lp.evmOpt_+3A_object">object</code></td>
<td>
<p>An object of class <code>evmOpt</code>, <code>evmSim</code> or
<code>evmBoot</code>.</p>
</td></tr>
<tr><td><code id="plot.lp.evmOpt_+3A_m">M</code></td>
<td>
<p>The return period: units are number of observations. Defaults to
<code>M = 1000</code>. If a vector is passed, a list is returned, with items
corresponding to the different values of the vector <code>M</code>.</p>
</td></tr>
<tr><td><code id="plot.lp.evmOpt_+3A_newdata">newdata</code></td>
<td>
<p>The new data that you want to make the prediction for.
Defaults in <code>newdata = NULL</code> in which case the data used in fitting the
model will be used. Column names must match those of the original data
matrix used for model fitting.</p>
</td></tr>
<tr><td><code id="plot.lp.evmOpt_+3A_type">type</code></td>
<td>
<p>For the predict methods, the type of prediction, either &quot;return
level&quot; (or &quot;rl&quot;) or &quot;link&quot; (or &quot;lp&quot;). Defaults to <code>type = "return
level"</code>. When a return level is wanted, the user can specify the associated
return period via the <code>M</code> argument. If <code>type = "link"</code> the linear
predictor(s) for <code>phi</code> and <code>xi</code> (or whatever other parameters are
in your <code>texmexFamily</code> are returned.
</p>
<p>For the plot methods for simulation based estimation of underlying
distributions i.e. objects derived from &quot;evmSim&quot; and &quot;evmBoot&quot; classes,
whether to use the sample median <code>type="median"</code> or mean
<code>type="mean"</code> estimate of the parameter.</p>
</td></tr>
<tr><td><code id="plot.lp.evmOpt_+3A_se.fit">se.fit</code></td>
<td>
<p>Whether or not to return the standard error of the predicted
value. Defaults to <code>se.fit = FALSE</code> and is not implemented for
<code>predict.evmSim</code> or <code>predict.evmBoot</code>.</p>
</td></tr>
<tr><td><code id="plot.lp.evmOpt_+3A_ci.fit">ci.fit</code></td>
<td>
<p>Whether or not to return a confidence interval for the
predicted value. Defaults to <code>ci.fit = FALSE</code>. For objects of class
<code>evmOpt</code>, if set to <code>TRUE</code> then the confidence interval is a
simple symmetric confidence interval based on the estimated approximate
standard error. For the <code>evmSim</code> and <code>evmBoot</code> methods, the
confidence interval represents quantiles of the simulated distribution of
the parameters.</p>
</td></tr>
<tr><td><code id="plot.lp.evmOpt_+3A_alpha">alpha</code></td>
<td>
<p>If <code>ci.fit = TRUE</code>, a 100(1 - alpha)% confidence interval
is returned. Defaults to <code>alpha = 0.050</code>.</p>
</td></tr>
<tr><td><code id="plot.lp.evmOpt_+3A_unique.">unique.</code></td>
<td>
<p>If <code>unique. = TRUE</code>, predictions for only the unique
values of the linear predictors are returned, rather than for every row of
<code>newdata</code>. Defaults to <code>unique. = TRUE</code>.</p>
</td></tr>
<tr><td><code id="plot.lp.evmOpt_+3A_full.cov">full.cov</code></td>
<td>
<p>Should the full covariance matrix be returned as part of a
<code>list</code> object. This is used internally and not intended for direct use.
Defaults to <code>full.cov = FALSE</code></p>
</td></tr>
<tr><td><code id="plot.lp.evmOpt_+3A_all">all</code></td>
<td>
<p>For the <code>evmSim</code> and <code>evmBoot</code> methods, if <code>all =
TRUE</code>, the predictions are returned for every simulated parameter vector.
Otherwise, only a summary of the posterior/bootstrap distribution is
returned. Defaults to <code>all = FALSE</code>.</p>
</td></tr>
<tr><td><code id="plot.lp.evmOpt_+3A_sumfun">sumfun</code></td>
<td>
<p>For the <code>evmSim</code> and <code>evmBoot</code> methods, a summary
function can be passed in. If <code>sumfun = FALSE</code>, the default, the
summary function used returns the estimated mean and median, and quantiles
implied by <code>alpha</code>.</p>
</td></tr>
<tr><td><code id="plot.lp.evmOpt_+3A_digits">digits</code></td>
<td>
<p>Number of digits to show when printing objects.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>By default, return levels predicted from the unique values of the linear
predictors are returned. For the <code>evmBoot</code> method, estimates of
confidence intervals are simply quantiles of the bootstrap sample. The
<code>evmBoot</code> method is just a wrapper for the <code>evmSim</code> method.
</p>


<h3>Value</h3>

<p>A list with two entries: the first being the call and the
second being a further list with one entry for each value of
<code>M</code>.
</p>


<h3>Note</h3>

<p>At present, the confidence intervals returned for an object of class
<code>evmOpt</code> are simple confidence intervals based on assumptions of
normality that are likely to be far from the truth in many cases. A better
approach would be to use profile likelihood, and we intend to implement this
method at a future date.  Alternatively, the credible intervals returned by
using Bayesian estimation and the predict method for class &quot;evmSim&quot; will
tend to give a better representation of the asymmetry of the estimated
intervals around the parameter point estimates.
</p>


<h3>Author(s)</h3>

<p>Harry Southworth and Janet E. Heffernan
</p>

<hr>
<h2 id='plot.rl.evmOpt'>Return levels</h2><span id='topic+plot.rl.evmOpt'></span><span id='topic+plot.rl.evmSim'></span><span id='topic+plot.rl.evmBoot'></span><span id='topic+rl'></span><span id='topic+rl.evmOpt'></span><span id='topic+rl.evmSim'></span><span id='topic+rl.evmBoot'></span><span id='topic+print.rl.evmOpt'></span>

<h3>Description</h3>

<p>Computation of return levels and confidence intervals for extreme
value models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'rl.evmOpt'
plot(
  x,
  xlab,
  ylab,
  main,
  pch = 1,
  ptcol = 2,
  cex = 0.75,
  linecol = 4,
  cicol = 0,
  polycol = 15,
  smooth = FALSE,
  sameAxes = TRUE,
  type = "median",
  ylim = NULL,
  plot. = TRUE,
  ...
)

## S3 method for class 'rl.evmSim'
plot(
  x,
  xlab,
  ylab,
  main,
  pch = 1,
  ptcol = 2,
  cex = 0.75,
  linecol = 4,
  cicol = 0,
  polycol = 15,
  smooth = FALSE,
  sameAxes = TRUE,
  type = "median",
  ylim = NULL,
  plot. = TRUE,
  ...
)

## S3 method for class 'rl.evmBoot'
plot(
  x,
  xlab,
  ylab,
  main,
  pch = 1,
  ptcol = 2,
  cex = 0.75,
  linecol = 4,
  cicol = 0,
  polycol = 15,
  smooth = FALSE,
  sameAxes = TRUE,
  type = "median",
  ylim = NULL,
  plot. = TRUE,
  ...
)

rl(
  object,
  M = 1000,
  newdata = NULL,
  se.fit = FALSE,
  ci.fit = FALSE,
  alpha = 0.05,
  unique. = TRUE,
  ...
)

## S3 method for class 'evmOpt'
rl(
  object,
  M = 1000,
  newdata = NULL,
  se.fit = FALSE,
  ci.fit = FALSE,
  alpha = 0.05,
  unique. = TRUE,
  ...
)

## S3 method for class 'evmSim'
rl(
  object,
  M = 1000,
  newdata = NULL,
  se.fit = FALSE,
  ci.fit = FALSE,
  alpha = 0.05,
  unique. = TRUE,
  all = FALSE,
  sumfun = NULL,
  ...
)

## S3 method for class 'evmBoot'
rl(
  object,
  M = 1000,
  newdata = NULL,
  se.fit = FALSE,
  ci.fit = FALSE,
  alpha = 0.05,
  unique. = TRUE,
  all = FALSE,
  sumfun = NULL,
  ...
)

## S3 method for class 'rl.evmOpt'
print(x, digits = 3, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.rl.evmOpt_+3A_x">x</code></td>
<td>
<p>Object passed to plot and print methods.</p>
</td></tr>
<tr><td><code id="plot.rl.evmOpt_+3A_xlab">xlab</code>, <code id="plot.rl.evmOpt_+3A_ylab">ylab</code>, <code id="plot.rl.evmOpt_+3A_main">main</code>, <code id="plot.rl.evmOpt_+3A_pch">pch</code>, <code id="plot.rl.evmOpt_+3A_ptcol">ptcol</code>, <code id="plot.rl.evmOpt_+3A_cex">cex</code>, <code id="plot.rl.evmOpt_+3A_linecol">linecol</code>, <code id="plot.rl.evmOpt_+3A_cicol">cicol</code>, <code id="plot.rl.evmOpt_+3A_polycol">polycol</code>, <code id="plot.rl.evmOpt_+3A_smooth">smooth</code>, <code id="plot.rl.evmOpt_+3A_sameaxes">sameAxes</code>, <code id="plot.rl.evmOpt_+3A_ylim">ylim</code></td>
<td>
<p>Further arguments to plot methods.</p>
</td></tr>
<tr><td><code id="plot.rl.evmOpt_+3A_type">type</code></td>
<td>
<p>For calls to plot methods for objects of class
<code>rl.evmSim</code> or <code>rl.evmBoot</code>, specifies whether to
use the sample mean (<code>type="mean"</code>) or median
(<code>type="median"</code>) estimate of the return levels.</p>
</td></tr>
<tr><td><code id="plot.rl.evmOpt_+3A_plot.">plot.</code></td>
<td>
<p>Parameter for plot method, whether to produce plots.</p>
</td></tr>
<tr><td><code id="plot.rl.evmOpt_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed to methods.</p>
</td></tr>
<tr><td><code id="plot.rl.evmOpt_+3A_object">object</code></td>
<td>
<p>An object of class <code>evmOpt</code>, <code>evmSim</code> or
<code>evmBoot</code>.</p>
</td></tr>
<tr><td><code id="plot.rl.evmOpt_+3A_m">M</code></td>
<td>
<p>The M-observation return level is computed by the
function. Defaults to <code>M = 1000</code>.</p>
</td></tr>
<tr><td><code id="plot.rl.evmOpt_+3A_newdata">newdata</code></td>
<td>
<p>Data from which to calculate the return level. If
not provided, the original data used to fit the model is used.
Column names must match those of original data matrix used for
model fitting.</p>
</td></tr>
<tr><td><code id="plot.rl.evmOpt_+3A_se.fit">se.fit</code></td>
<td>
<p>Whether or not to return the standard error of the
predicted value. Defaults to <code>se.fit = FALSE</code>.</p>
</td></tr>
<tr><td><code id="plot.rl.evmOpt_+3A_ci.fit">ci.fit</code></td>
<td>
<p>Whether or not to return a confidence interval for
the predicted value. Defaults to <code>ci.fit = FALSE</code>. For
objects of class <code>evmOpt</code>, if set to <code>TRUE</code> then the
confidence interval is a simple symmetric confidence interval
based on the estimated approximate standard error. For the
<code>evmSim</code> and <code>evmBoot</code> methods, the confidence
interval represents quantiles of the simulated distribution of
the parameters.</p>
</td></tr>
<tr><td><code id="plot.rl.evmOpt_+3A_alpha">alpha</code></td>
<td>
<p>If <code>ci.fit = TRUE</code>, a 100(1 - alpha)%
confidence interval is returned. Defaults to <code>alpha =
0.050</code>.</p>
</td></tr>
<tr><td><code id="plot.rl.evmOpt_+3A_unique.">unique.</code></td>
<td>
<p>If <code>unique. = TRUE</code>, predictions for only the
unique values of the linear predictors are returned, rather
than for every row of the original dataframe or of
<code>newdata</code> if this latter is specified. Defaults to
<code>unique. = TRUE</code>.</p>
</td></tr>
<tr><td><code id="plot.rl.evmOpt_+3A_all">all</code></td>
<td>
<p>For the <code>evmSim</code> and <code>evmBoot</code> methods, if
<code>all = TRUE</code>, the predictions are returned for every
simulated parameter vector. Otherwise, only a summary of the
posterior/bootstrap distribution is returned. Defaults to
<code>all = FALSE</code>.</p>
</td></tr>
<tr><td><code id="plot.rl.evmOpt_+3A_sumfun">sumfun</code></td>
<td>
<p>For the <code>evmSim</code> and <code>evmBoot</code> methods, a
summary function can be passed in. If <code>sumfun = FALSE</code>,
the default, the summary function used returns the estimated
mean and median, and quantiles implied by <code>alpha</code>.</p>
</td></tr>
<tr><td><code id="plot.rl.evmOpt_+3A_digits">digits</code></td>
<td>
<p>Number of digits to show when printing output.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The M-observation return level is defined as the value
that is expected to be exceeded only once every M
observations. Thus, it is an estimate of a high quantile of
the fitted distribution.
</p>
<p>In models fit by the <code>evm</code> family of functions with
<code>family=gpd</code>, only a fraction of the data is actually
included in the model; the fitted GPD is a conditional model,
conditioning on the threshold having been exceeded. This
consideration is taken into account by <code>rl</code> which calculates
unconditional return levels from the entire distribution of
observations above and below the GPD fitting threshold.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mod &lt;- evm(rain, qu=.8) # daily rainfall observations
rl(mod, M=100*365) # 100-year return level
</code></pre>

<hr>
<h2 id='print.evmOpt'>Print evmOpt objects</h2><span id='topic+print.evmOpt'></span>

<h3>Description</h3>

<p>Print evmOpt objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'evmOpt'
print(x, digits = max(3, getOption("digits") - 3), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.evmOpt_+3A_x">x</code></td>
<td>
<p>a fit evmOpt object</p>
</td></tr>
<tr><td><code id="print.evmOpt_+3A_digits">digits</code></td>
<td>
<p>number of digits used for printing</p>
</td></tr>
<tr><td><code id="print.evmOpt_+3A_...">...</code></td>
<td>
<p>further arguments passed to <code><a href="base.html#topic+format">format</a></code></p>
</td></tr>
</table>

<hr>
<h2 id='rain+2C+20wavesurge+20and+20portpirie'>Rain, wavesurge, portpirie and nidd datasets.</h2><span id='topic+rain+2C+20wavesurge+20and+20portpirie'></span><span id='topic+rain'></span><span id='topic+wavesurge'></span><span id='topic+portpirie'></span><span id='topic+nidd'></span>

<h3>Description</h3>

<p>Rainfall, wave-surge, Port Pirie and River Nidd data sets.
</p>


<h3>Format</h3>

<p>The format of the rain data is: num [1:17531] 0 2.3 1.3 6.9 4.6 0 1
1.5 1.8 1.8 ...
</p>
<p>The wave-surge data is bivariate and is used for testing functions in
<code>texmex</code>.
</p>
<p>The Port Pirie data has two columns: 'Year' and 'SeaLevel'.
</p>
<p>The River Nidd data represents 154 measurements of the level of the River
Nidd at Hunsingore Weir (Yorkshire, UK) between 1934 and 1969. Each
measurement breaches the threshold of $65 m^3/2$. Various authors have
analysed this dataset, as described by Papastathopoulos and Tawn~<cite>egp</cite>,
there being some apparent difficulty in identifying a threshold above which
GPD models are suitable.
</p>


<h3>Details</h3>

<p>The rain, wave-surge and Port Pirie datasets are used by Coles and appear in
the <code>ismev</code> package. The River Nidd data appear in the <code>evir</code>
package.
</p>


<h3>Source</h3>

<p>Copied from the <code>ismev</code> package and the <code>evir</code> package
</p>


<h3>References</h3>

<p>S. Coles, An Introduction to Statistical Modeling of Extreme
Values, Springer, 2001
</p>
<p>I. Papastathopoulos and J. A. Tawn, Extended Generalised Pareto Models for
Tail Estimation, Journal of Statistical Planning and Inference, 143, 134 &ndash;
143, 2011
</p>

<hr>
<h2 id='rFrechet'>Extreme Value random process generation.</h2><span id='topic+rFrechet'></span>

<h3>Description</h3>

<p>Extreme Value random process generation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rFrechet(n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rFrechet_+3A_n">n</code></td>
<td>
<p>Number of samples to generate.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Generation of samples from unit Frechet processes.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rFrechet(1000)
</code></pre>

<hr>
<h2 id='rglo'>Generalized logistic distribution</h2><span id='topic+rglo'></span><span id='topic+pglo'></span><span id='topic+qglo'></span><span id='topic+dglo'></span>

<h3>Description</h3>

<p>Density, distribution and quantile functions, and random number
generation for the Generalized logistic distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rglo(n, mu, sigma, xi)

dglo(x, mu, sigma, xi, log.d = FALSE)

pglo(q, mu, sigma, xi, lower.tail = TRUE, log.p = FALSE)

qglo(p, mu, sigma, xi, lower.tail = TRUE, log.p = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rglo_+3A_n">n</code></td>
<td>
<p>Number of random numbers to generate.</p>
</td></tr>
<tr><td><code id="rglo_+3A_mu">mu</code></td>
<td>
<p>Location parameter.</p>
</td></tr>
<tr><td><code id="rglo_+3A_sigma">sigma</code></td>
<td>
<p>Scale parameter.</p>
</td></tr>
<tr><td><code id="rglo_+3A_xi">xi</code></td>
<td>
<p>Shape parameter.</p>
</td></tr>
<tr><td><code id="rglo_+3A_x">x</code>, <code id="rglo_+3A_q">q</code>, <code id="rglo_+3A_p">p</code></td>
<td>
<p>Value, quantile or probability respectively.</p>
</td></tr>
<tr><td><code id="rglo_+3A_log.d">log.d</code>, <code id="rglo_+3A_log.p">log.p</code></td>
<td>
<p>Whether to work on the log scale.</p>
</td></tr>
<tr><td><code id="rglo_+3A_lower.tail">lower.tail</code></td>
<td>
<p>Whether to return the lower tail.</p>
</td></tr>
</table>

<hr>
<h2 id='rMaxAR'>Extreme Value random process generation.</h2><span id='topic+rMaxAR'></span>

<h3>Description</h3>

<p>Extreme Value random process generation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rMaxAR(n,theta)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rMaxAR_+3A_n">n</code></td>
<td>
<p>Number of samples to generate.</p>
</td></tr>
<tr><td><code id="rMaxAR_+3A_theta">theta</code></td>
<td>
<p>Parameter of the MAX AR process, takes values between 0 and 1.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Generation of samples from  Max AR(theta) processes.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rMaxAR(1000,0.2)
</code></pre>

<hr>
<h2 id='simulate.evmOpt'>Simulate from a fitted evm object</h2><span id='topic+simulate.evmOpt'></span><span id='topic+simulate.evmSim'></span><span id='topic+simulate.evmBoot'></span>

<h3>Description</h3>

<p>Simulate random numbers from a fitted evm object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'evmOpt'
simulate(object, nsim = 1, seed = NULL, param = NULL, ...)

## S3 method for class 'evmSim'
simulate(object, nsim = 1, seed = NULL, ...)

## S3 method for class 'evmBoot'
simulate(object, nsim = 1, seed = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simulate.evmOpt_+3A_object">object</code></td>
<td>
<p>A fitted evm object having class 'evmOpt', 'evmSim' or
'evmBoot'.</p>
</td></tr>
<tr><td><code id="simulate.evmOpt_+3A_nsim">nsim</code></td>
<td>
<p>The number of simulations to perform. Defaults to <code>nsim=1</code>.
A single simulation involves simulating a new set of responses from the data
that was provided to <code>evm</code> (after thresholding if thresholding is
performed.)</p>
</td></tr>
<tr><td><code id="simulate.evmOpt_+3A_seed">seed</code></td>
<td>
<p>An integer to be passed to <code>set.seed</code>. Defaults to
<code>seed=NULL</code>.</p>
</td></tr>
<tr><td><code id="simulate.evmOpt_+3A_param">param</code></td>
<td>
<p>Parameters to use in the random number generator. Defaults to
<code>param=NULL</code> in which case the parameters from the fitted model are
used.  For <code>simulate.evmSim</code> and <code>simulate.evmBoot</code>, this argument
is not available and the simulated parameters or replicates are used.</p>
</td></tr>
<tr><td><code id="simulate.evmOpt_+3A_...">...</code></td>
<td>
<p>Unused.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For <code>simulate.evmSim</code> and <code>simulate.evmBoot</code>, the parameters from
the Markov chains or bootstrap replicates are randomly permuted prior to
each set of simulated responses being computed. In this way, reusing the
same set of values is avoided.
</p>


<h3>Value</h3>

<p>If <code>nsim=1</code>, a vector or random numbers simulated from the
fitted model object.  If <code>nsim &gt; 1</code>, a matrix with each column being a
set of simulated responses.
</p>


<h3>Author(s)</h3>

<p>Paul Metcalfe, Harry Southworth
</p>


<h3>See Also</h3>

<p><code><a href="#topic+evm">evm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
mod &lt;- evm(rain, qu=.95)
hist(simulate(mod, 100))

</code></pre>

<hr>
<h2 id='summer+20and+20winter+20data'>Air pollution data, separately for summer and winter months</h2><span id='topic+summer+20and+20winter+20data'></span><span id='topic+summer'></span><span id='topic+winter'></span>

<h3>Description</h3>

<p>Air pollution data from Leeds (U.K.) city centre, collected from 1994 to
1998. The <code>summer</code> data set corresponds to the months of April to July
inclusive. The <code>winter</code> data set corresponds to the months of November
to February inclusive. Some outliers have been removed, as discussed by
Heffernan and Tawn, 2004.
</p>


<h3>Format</h3>

<p>Data frames with 578 (summer) and 532 (winter) observations on the
following 5 variables.
</p>

<dl>
<dt>O3</dt><dd><p>Daily maximum ozone in
parts per billion.</p>
</dd>
<dt>NO2</dt><dd><p>Daily maximum NO2 in parts per
billion.</p>
</dd>
<dt>NO</dt><dd><p>Daily maximum NO in parts per billion.</p>
</dd>
<dt>SO2</dt><dd><p>Daily maximum SO2 in parts per billion.</p>
</dd>
<dt>PM10</dt><dd><p>Daily maximum PM10 in micrograms/metre^3</p>
</dd>
</dl>



<h3>Source</h3>

<p>Provided as online supplementary material to Heffernan and Tawn,
2004:
</p>
<p>http://www.blackwellpublishing.com/rss/Readmefiles/heffernan.htm
</p>


<h3>References</h3>

<p>J. E. Heffernan and J. A. Tawn, A conditional approach for
multivariate extreme values, Journal of the Royal Statistical society B, 66,
497 &ndash; 546, 2004
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(summer)
data(winter)

</code></pre>

<hr>
<h2 id='texmexFamily'>Create families of distributions</h2><span id='topic+texmexFamily'></span><span id='topic+print.texmexFamily'></span><span id='topic+summary.texmexFamily'></span><span id='topic+gpd'></span><span id='topic+gpdIntCensored'></span><span id='topic+glo'></span><span id='topic+gev'></span><span id='topic+egp3'></span><span id='topic+cgpd'></span><span id='topic+weibull'></span><span id='topic+gumbel'></span><span id='topic+print.summary.texmexFamily'></span>

<h3>Description</h3>

<p>Create families of distributions for use with extreme value
modelling.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>texmexFamily(name, log.lik, param, info = NULL, sandwich =
    NULL, start = NULL, resid = NULL, rl, delta, endpoint, density,
    rng, prob, quant)
    ## S3 method for class 'texmexFamily'
print(x,...)
    ## S3 method for class 'texmexFamily'
summary(object,...)
    ## S3 method for class 'summary.texmexFamily'
print(x,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="texmexFamily_+3A_name">name</code></td>
<td>
<p>The name of the distribution.</p>
</td></tr>
<tr><td><code id="texmexFamily_+3A_log.lik">log.lik</code></td>
<td>
<p>The distribution's log-likelihood function.</p>
</td></tr>
<tr><td><code id="texmexFamily_+3A_param">param</code></td>
<td>
<p>The names of the parameters in the model.</p>
</td></tr>
<tr><td><code id="texmexFamily_+3A_info">info</code></td>
<td>
<p>Function to compute the information matrix. If not
provided, the modelling functions will work with a numerical
approximation.</p>
</td></tr>
<tr><td><code id="texmexFamily_+3A_sandwich">sandwich</code></td>
<td>
<p>Function to compute the filling in the Huber
sandwich estimator of the covariance matrix of parameter
estimates, used for dependent data. Only implemented in family
<code>gpd</code>.</p>
</td></tr>
<tr><td><code id="texmexFamily_+3A_start">start</code></td>
<td>
<p>Function to compute starting parameters for the
model. If not provided, the modelling functions will try to
guess.</p>
</td></tr>
<tr><td><code id="texmexFamily_+3A_resid">resid</code></td>
<td>
<p>Function to compute residuals for the model.</p>
</td></tr>
<tr><td><code id="texmexFamily_+3A_rl">rl</code></td>
<td>
<p>Function to compute return levels.</p>
</td></tr>
<tr><td><code id="texmexFamily_+3A_delta">delta</code></td>
<td>
<p>Function to compute adjustments for covariance for
return levels.</p>
</td></tr>
<tr><td><code id="texmexFamily_+3A_endpoint">endpoint</code></td>
<td>
<p>Function to compute the upper or lower endpoint of
the fitted distribution.</p>
</td></tr>
<tr><td><code id="texmexFamily_+3A_density">density</code></td>
<td>
<p>Function to compute the density.</p>
</td></tr>
<tr><td><code id="texmexFamily_+3A_rng">rng</code></td>
<td>
<p>Function for random number generation.</p>
</td></tr>
<tr><td><code id="texmexFamily_+3A_prob">prob</code></td>
<td>
<p>Function to compute cumulative probabilities.</p>
</td></tr>
<tr><td><code id="texmexFamily_+3A_quant">quant</code></td>
<td>
<p>Function to compute quantiles.</p>
</td></tr>
<tr><td><code id="texmexFamily_+3A_...">...</code></td>
<td>
<p>Additional arguments to the print and summary methods.</p>
</td></tr>
<tr><td><code id="texmexFamily_+3A_x">x</code>, <code id="texmexFamily_+3A_object">object</code></td>
<td>
<p>An object of class 'texmexFamily'.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>density</code>, <code>rng</code>, <code>prob</code> and <code>quant</code>
functions can be simple wrappers for the usual d, r, p and q
functions. They should take a matrix with number of columns equal
to the number of parameters, and a fitted model object even if the
model object is not used by the function.
</p>
<p>Examples of &quot;texmexFamily&quot; objects are <code>gpd</code>, <code>gev</code>, <code>glo</code>,
<code>gpdIntCensored</code>, <code>weibull</code>, <code>gumbel</code> and <code>egp3</code>.  Take a look at
those objects to see how the functions should be constructed.
</p>
<p>The functions are used by the modelling functions to create
diagnostic plots, predictions, etc..
</p>


<h3>Value</h3>

<p>A object of class &quot;texmexFamily&quot;, which is essentially a
list containing the input arguments. If <code>info</code>,
<code>sandwich</code>, <code>start</code>, <code>resid</code> are not provided,
they default to <code>NULL</code>.
</p>


<h3>Note</h3>

<p>The <code>gpd</code>, <code>gev</code>, <code>weibull</code>, generalised logistic (<code>glo</code>), 
<code>gumbel</code>, <code>gpdIntCensored</code> and <code>egp3</code> families are provided. 
The <code><a href="#topic+evm">evm</a></code> function defaults to using the <code>gpd</code> family.
</p>


<h3>Author(s)</h3>

<p>Harry Southworth
</p>


<h3>See Also</h3>

<p><code><a href="#topic+evm">evm</a></code>
</p>

<hr>
<h2 id='thinAndBurn'>Process Metropolis output from extreme value model fitting to discard
unwanted observations.</h2><span id='topic+thinAndBurn'></span><span id='topic+thinAndBurn.evmSim'></span>

<h3>Description</h3>

<p>Process observations from Metropolis fitting of extreme value models, to
thin the output and discard observations from burn-in period.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'evmSim'
thinAndBurn(object, burn, thin)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="thinAndBurn_+3A_object">object</code></td>
<td>
<p>Object of class 'evmSim' as returned by <code>evm</code> called with
<code>method="simulate"</code>.</p>
</td></tr>
<tr><td><code id="thinAndBurn_+3A_burn">burn</code></td>
<td>
<p>The number of observations from the simulated Markov Chain to be
discarded as burn-in. Must be a non-negative integer, for no burn-in use
<code>burn=0</code>.</p>
</td></tr>
<tr><td><code id="thinAndBurn_+3A_thin">thin</code></td>
<td>
<p><code>thin</code> or its reciprocal must be a positive integer.  If
integer valued, this specifies the frequency of observations from the
simulated Markov Chain which will be retained.  If specified as a
proportion, this is the proportion of values which will be retained. For no
thinning use <code>thin=1</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Object of class <code>evmSim</code>.  See Value returned by
<code><a href="#topic+evm">evm</a></code> using <code>method = "simulate"</code> for details.
</p>
<p>Note that the original chain is not discarded when this function is called:
<code>thinAndBurn</code> can be called recursively on the original object with
different values of <code>burn</code> and <code>thin</code> without the object getting
progressively smaller!
</p>


<h3>Author(s)</h3>

<p>Harry Southworth, Janet E. Heffernan
</p>


<h3>See Also</h3>

<p><code><a href="#topic+evm">evm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  x &lt;- rnorm(1000)
  # For the values of burn and thin below, we should do many more iterations.
  # The number of iterations is kept low here due to the run time allowed
  # by CRAN.
  mod &lt;- evm(x, qu=.7, method="sim", iter=11000)
  mod
  par(mfrow=c(3, 2))
  plot(mod)
  mod1 &lt;- thinAndBurn(mod,burn=1000, thin=5)
  plot(mod1)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
