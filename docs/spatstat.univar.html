<!DOCTYPE html><html><head><title>Help for package spatstat.univar</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {spatstat.univar}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#spatstat.univar-package'><p>The spatstat.univar Package</p></a></li>
<li><a href='#bw.abram'>
<p>Abramson's Adaptive Bandwidths</p></a></li>
<li><a href='#bw.abram.default'>
<p>Abramson's Adaptive Bandwidths For Numeric Data</p></a></li>
<li><a href='#CDF'>
<p>Cumulative Distribution Function From Kernel Density Estimate</p></a></li>
<li><a href='#densityAdaptiveKernel'>
<p>Adaptive Kernel Estimation of Density or Intensity</p></a></li>
<li><a href='#dkernel'><p>Kernel distributions and random generation</p></a></li>
<li><a href='#ewcdf'><p>Weighted Empirical Cumulative Distribution Function</p></a></li>
<li><a href='#firstdigit'>
<p>Digits in Decimal Representation</p></a></li>
<li><a href='#hotrod'>
<p>Heat Kernel for a One-Dimensional Rod</p></a></li>
<li><a href='#indefinteg'>
<p>Indefinite Integral</p></a></li>
<li><a href='#integral'>
<p>Integral of a Function or Spatial Object</p></a></li>
<li><a href='#integral.density'>
<p>Compute Integral of One-Dimensional Kernel Density Estimate.</p></a></li>
<li><a href='#kaplan.meier'><p>Kaplan-Meier Estimator using Histogram Data</p></a></li>
<li><a href='#kernel.factor'><p>Scale factor for density kernel</p></a></li>
<li><a href='#kernel.moment'><p>Incomplete Moment of Smoothing Kernel</p></a></li>
<li><a href='#kernel.squint'><p>Integral of Squared Kernel</p></a></li>
<li><a href='#km.rs'><p>Kaplan-Meier and Reduced Sample Estimator using Histograms</p></a></li>
<li><a href='#mean.ewcdf'><p>Mean of Empirical Cumulative Distribution Function</p></a></li>
<li><a href='#quantile.density'>
<p>Quantiles of a Density Estimate</p></a></li>
<li><a href='#quantile.ewcdf'>
<p>Quantiles of Weighted Empirical Cumulative Distribution Function</p></a></li>
<li><a href='#quantilefun'>
<p>Quantile Function</p></a></li>
<li><a href='#reduced.sample'><p>Reduced Sample Estimator using Histogram Data</p></a></li>
<li><a href='#rounding'>
<p>Detect Numerical Rounding</p></a></li>
<li><a href='#spatstat.univar-internal'><p>Internal Functions</p></a></li>
<li><a href='#stieltjes'><p>Compute Integral of Function Against Cumulative Distribution</p></a></li>
<li><a href='#transformquantiles'>
<p>Transform the Quantiles</p></a></li>
<li><a href='#uniquemap.default'>
<p>Map Duplicate Entries to Unique Entries</p></a></li>
<li><a href='#unnormdensity'>
<p>Weighted kernel smoother</p></a></li>
<li><a href='#weighted.median'>
<p>Weighted Median, Quantiles or Variance</p></a></li>
<li><a href='#whist'>
<p>Weighted Histogram</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>3.0-0</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-06-28</td>
</tr>
<tr>
<td>Title:</td>
<td>One-Dimensional Probability Distribution Support for the
'spatstat' Family</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Adrian Baddeley &lt;Adrian.Baddeley@curtin.edu.au&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0), stats</td>
</tr>
<tr>
<td>Imports:</td>
<td>spatstat.utils (&ge; 3.0-5)</td>
</tr>
<tr>
<td>Description:</td>
<td>Estimation of one-dimensional probability distributions
	     including kernel density estimation, weighted empirical cumulative
	     distribution functions, Kaplan-Meier and reduced-sample estimators
	     for right-censored data, heat kernels, kernel properties,
	     quantiles and integration.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="http://spatstat.org/">http://spatstat.org/</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>ByteCompile:</td>
<td>true</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/spatstat/spatstat.univar/issues">https://github.com/spatstat/spatstat.univar/issues</a></td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-06-28 01:17:49 UTC; adrian</td>
</tr>
<tr>
<td>Author:</td>
<td>Adrian Baddeley <a href="https://orcid.org/0000-0001-9499-8382"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre, cph],
  Tilman M. Davies <a href="https://orcid.org/0000-0003-0565-1825"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, ctb, cph],
  Martin L. Hazelton
    <a href="https://orcid.org/0000-0001-7831-725X"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, ctb,
    cph],
  Ege Rubak <a href="https://orcid.org/0000-0002-6675-533X"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut,
    cph],
  Rolf Turner <a href="https://orcid.org/0000-0001-5521-5218"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut,
    cph],
  Greg McSwiggan [ctb, cph]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-06-28 04:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='spatstat.univar-package'>The spatstat.univar Package</h2><span id='topic+spatstat.univar-package'></span><span id='topic+spatstat.univar'></span>

<h3>Description</h3>

<p>The <span class="pkg">spatstat.univar</span> package
belongs to the <span class="pkg">spatstat</span> family of packages.
It provides utilities for estimating the probability distribution
of one-dimensional (real-valued) data.
</p>


<h3>Details</h3>

<p>This package is a member of the <span class="pkg">spatstat</span>
family of packages. It provides utilities for
estimation of the probability distribution of
one-dimensional (i.e. numerical, real-valued) data.
The utilities include:
</p>

<dl>
<dt>kernel density estimation:</dt><dd>
<p>including
unnormalised weighted densities, and cumulative distribution
functions of density estimates.
</p>
</dd>
<dt>weighted distributions and weighted statistics:</dt><dd>
<p>including weighted empirical cumulative distributions, weighted median,
weighted quantiles, calculating the CDF from a density estimate
</p>
</dd>
<dt>estimation for right-censored data:</dt><dd>
<p>including Kaplan-Meier, reduced-sample and other estimators
of the cumulative distribution function and hazard function
from right-censored data
</p>
</dd>
<dt>quantiles:</dt><dd>
<p>including calculation of quantiles from an empirical cumulative
distribution or a kernel density estimate
</p>
</dd>
<dt>kernels:</dt><dd>
<p>including calculation of the probability density, cumulative distribution
function, quantiles, random generation, moments and partial
moments of the standard smoothing kernels
</p>
</dd>
<dt>heat kernel:</dt><dd>
<p>calculation of the one-dimensional heat kernel in an interval
</p>
</dd>
<dt>integration:</dt><dd>
<p>Numerical integration including Stieltjes integrals
and indefinite integrals.
</p>
</dd>
</dl>

<p>The facilities are described in more detail below.
</p>
<p><b>Kernel density estimation</b>
</p>
<p>The package supports 
fixed-bandwidth and variable-bandwidth kernel estimation
of probability densities from numerical data.
It provides boundary corrections for kernel estimates
of densities on the positive half-line (applicable when the original
observations are positive numbers) for both fixed-bandwidth
and variable-bandwidth estimates.
</p>
<p>If the observations have numerical weights associated with them,
these weights will not be automatically normalised, and indeed
the weights may be negative or zero. This is 
unlike the standard <span class="rlang"><b>R</b></span> method <code><a href="stats.html#topic+density.default">density.default</a></code>.
</p>
<p>The main functions are:
</p>

<table>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+unnormdensity">unnormdensity</a></code>
    </td><td style="text-align: left;">
    extension of <code><a href="stats.html#topic+density.default">density.default</a></code>
    allowing weights to be negative or zero.
    </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+densityAdaptiveKernel">densityAdaptiveKernel</a></code>
    </td><td style="text-align: left;">
    adaptive (variable-bandwidth) kernel estimate 
    </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+bw.abram.default">bw.abram.default</a></code>
    </td><td style="text-align: left;">
    calculate data-dependent bandwidths using Abramson rule
    </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+CDF.density">CDF.density</a></code> </td><td style="text-align: left;"> cumulative distribution function from
    kernel density estimate
  </td>
</tr>

</table>

<p><b>Weighted distributions and weighted statistics</b>
</p>
<p>Weighted versions of standard operations such as the histogram
and empirical distribution function are provided:
</p>

<table>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+whist">whist</a></code> </td><td style="text-align: left;"> weighted histogram </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+ewcdf">ewcdf</a></code> </td><td style="text-align: left;"> weighted empirical cumulative distribution
    function </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+mean.ewcdf">mean.ewcdf</a></code> </td><td style="text-align: left;"> mean of weighted ecdf </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+quantile.ewcdf">quantile.ewcdf</a></code> </td><td style="text-align: left;"> quantiles of weighted ecdf </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+weighted.median">weighted.median</a></code> </td><td style="text-align: left;"> weighted median of numeric values </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+weighted.quantile">weighted.quantile</a></code> </td><td style="text-align: left;"> weighted quantile of numeric values </td>
</tr>
<tr>
 <td style="text-align: left;">
  </td>
</tr>

</table>

<p><b>Estimation for right-censored data</b>
</p>
<p>Facilities are provided for estimating the probability distribution
of right-censored lifetimes (non-negative real random variables).
</p>

<table>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+kaplan.meier">kaplan.meier</a></code> </td><td style="text-align: left;"> Kaplan-Meier estimator of cumulative
    distribution function and hazard rate, from right-censored data </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+reduced.sample">reduced.sample</a></code> </td><td style="text-align: left;"> reduced-sample estimator of
    cumulative distribution function, from right-censored data
  </td>
</tr>

</table>

<p><b>Quantiles</b>
</p>
<p>Facilities are provided for computing the quantiles
of a probability distribution, given estimates of the
probability density or the cumulative distribution function
and so on.
</p>

<table>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+CDF.density">CDF.density</a></code> </td><td style="text-align: left;"> cumulative distribution function from
    kernel density estimate </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+quantile.density">quantile.density</a></code> </td><td style="text-align: left;"> quantiles of kernel density estimate </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+quantile.ewcdf">quantile.ewcdf</a></code> </td><td style="text-align: left;"> quantiles of weighted ecdf </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+quantilefun">quantilefun</a></code> </td><td style="text-align: left;"> quantiles as a function </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+quantilefun.ewcdf">quantilefun.ewcdf</a></code> </td><td style="text-align: left;"> quantiles as a function </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+weighted.quantile">weighted.quantile</a></code> </td><td style="text-align: left;"> weighted quantile of numeric values </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+transformquantiles">transformquantiles</a></code> </td><td style="text-align: left;"> transform the quantiles of a dataset
  </td>
</tr>

</table>

<p><b>Kernels</b>
</p>
<p>The standard <span class="rlang"><b>R</b></span> function <code><a href="stats.html#topic+density.default">density.default</a></code>
recognises a list of smoothing kernels by name:
<code>"gaussian"</code>, <code>"rectangular"</code>, <code>"triangular"</code>,
<code>"epanechnikov"</code>, <code>"biweight"</code>, <code>"cosine"</code>
and <code>"optcosine"</code>. For these kernels, <span class="pkg">spatstat.univar</span>
provides various characteristics:
</p>

<table>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+dkernel">dkernel</a></code>
    </td><td style="text-align: left;">
    probability density of the kernel
    </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+pkernel">pkernel</a></code>
    </td><td style="text-align: left;">
    cumulative distribution function of the kernel
    </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+qkernel">qkernel</a></code>
    </td><td style="text-align: left;">
    quantiles of the kernel
    </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+rkernel">rkernel</a></code>
    </td><td style="text-align: left;">
    generate simulated realisations from the kernel
    </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+kernel.factor">kernel.factor</a></code>
    </td><td style="text-align: left;">
    scale factor relating bandwidth to half-width of kernel
    </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+kernel.moment">kernel.moment</a></code>
    </td><td style="text-align: left;">
    partial moment of kernel
    </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+kernel.squint">kernel.squint</a></code>
    </td><td style="text-align: left;">
    integral of squared kernel
  </td>
</tr>

</table>

<p><b>Heat kernels</b>
</p>
<p>The heat kernel in an interval can be calculated.
</p>

<table>
<tr>
 <td style="text-align: left;">  
    <code><a href="#topic+hotrod">hotrod</a></code>
    </td><td style="text-align: left;">
    calculate the heat kernel in an interval
  </td>
</tr>

</table>

<p><b>Integration</b>
</p>
<p>A few facilities are provided for calculating integrals
of real functions.
</p>

<table>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+indefinteg">indefinteg</a></code> </td><td style="text-align: left;"> indefinite integral </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+integral.density">integral.density</a></code> </td><td style="text-align: left;"> integral of a kernel density
    estimate </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+stieltjes">stieltjes</a></code> </td><td style="text-align: left;"> Stieltjes integral
  </td>
</tr>

</table>

<p><b>Utilities</b>
</p>
<p>A few utilities for numerical data are also provided.
</p>

<table>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+uniquemap.default">uniquemap.default</a></code> </td><td style="text-align: left;"> map duplicates to unique entries </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+rounding.default">rounding.default</a></code> </td><td style="text-align: left;"> determine whether values have
    been rounded </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+firstdigit">firstdigit</a></code> </td><td style="text-align: left;"> leading digit in decimal
    representation </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+lastdigit">lastdigit</a></code> </td><td style="text-align: left;"> least significant digit in decimal
    representation </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+ndigits">ndigits</a></code> </td><td style="text-align: left;"> number of digits in decimal
    representation
  </td>
</tr>

</table>



<h3>Licence</h3>

<p>This library and its documentation are usable under the terms of the &quot;GNU 
General Public License&quot;, a copy of which is distributed with the package.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Tilman Davies <a href="mailto:Tilman.Davies@otago.ac.nz">Tilman.Davies@otago.ac.nz</a>, Martin Hazelton <a href="mailto:Martin.Hazelton@otago.ac.nz">Martin.Hazelton@otago.ac.nz</a>, Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Greg McSwiggan.
</p>

<hr>
<h2 id='bw.abram'>
Abramson's Adaptive Bandwidths
</h2><span id='topic+bw.abram'></span>

<h3>Description</h3>

<p>Computes adaptive smoothing bandwidths
according to the inverse-square-root rule of Abramson (1982).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bw.abram(X, h0, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bw.abram_+3A_x">X</code></td>
<td>

<p>Data to be smoothed.
</p>
</td></tr>
<tr><td><code id="bw.abram_+3A_h0">h0</code></td>
<td>

<p>Global smoothing bandwidth. A numeric value.
</p>
</td></tr>
<tr><td><code id="bw.abram_+3A_...">...</code></td>
<td>

<p>Additional arguments passed to methods.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function computes adaptive smoothing bandwidths for a dataset,
using the methods of Abramson (1982) and Hall and Marron (1988).
</p>
<p>The function <code>bw.abram</code> is generic.
There is a default method <code><a href="#topic+bw.abram.default">bw.abram.default</a></code>.
The <span class="pkg">spatstat</span> package family includes methods for spatial objects.
</p>


<h3>Value</h3>

<p>See the documentation for the particular method.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>.
</p>


<h3>References</h3>

<p>Abramson, I. (1982)
On bandwidth variation in kernel estimates &mdash; a square root law.
<em>Annals of Statistics</em>, <b>10</b>(4), 1217-1223. 
</p>
<p>Hall, P. and Marron, J.S. (1988)
Variable window width kernel density estimates of probability
densities.
<em>Probability Theory and Related Fields</em>, <b>80</b>, 37-49. 
</p>
<p>Silverman, B.W. (1986)
<em>Density Estimation for Statistics and Data Analysis</em>.
Chapman and Hall, New York.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bw.abram.default">bw.abram.default</a></code>
</p>

<hr>
<h2 id='bw.abram.default'>
Abramson's Adaptive Bandwidths For Numeric Data
</h2><span id='topic+bw.abram.default'></span>

<h3>Description</h3>

<p>Computes adaptive smoothing bandwidths for numeric data,
according to the inverse-square-root rule of Abramson (1982).
</p>


<h3>Usage</h3>

<pre><code class='language-R'> ## Default S3 method:
bw.abram(X, h0, ...,
    at = c("data", "grid"),
    pilot = NULL, hp = h0, trim = 5, smoother = density.default)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bw.abram.default_+3A_x">X</code></td>
<td>

<p>Data for which bandwidths should be calculated. A numeric vector.
</p>
</td></tr>
<tr><td><code id="bw.abram.default_+3A_h0">h0</code></td>
<td>

<p>A scalar value giving the global smoothing bandwidth
in the same units as <code>X</code>.
The default is <code>h0=<a href="stats.html#topic+bw.nrd0">bw.nrd0</a>(X)</code>.
</p>
</td></tr>
<tr><td><code id="bw.abram.default_+3A_...">...</code></td>
<td>

<p>Arguments passed to <code><a href="stats.html#topic+density.default">density.default</a></code>
(or to <code>smoother</code>) controlling the range of values <code>x</code>
at which the density will be estimated, when <code>at="grid"</code>.
</p>
</td></tr>
<tr><td><code id="bw.abram.default_+3A_at">at</code></td>
<td>

<p>Character string (partially matched) specifying whether to
compute bandwidth values only at the data points of <code>X</code>
(<code>at = 'data'</code>, the default) or on a grid of <code>x</code> values
(<code>at = 'grid'</code>).
</p>
</td></tr>
<tr><td><code id="bw.abram.default_+3A_pilot">pilot</code></td>
<td>

<p>Optional. Specification of a pilot density (possibly unnormalised).
Either a numeric vector giving the pilot density for each
data point of <code>X</code>, a <code>function</code> in the <span class="rlang"><b>R</b></span> language,
or a probability density estimate (object of class <code>"density"</code>).
If <code>pilot=NULL</code> the pilot density
is computed by applying fixed-bandwidth density estimation to
<code>X</code> using bandwidth <code>hp</code>.
</p>
</td></tr>
<tr><td><code id="bw.abram.default_+3A_hp">hp</code></td>
<td>

<p>Optional. A scalar pilot bandwidth, used for estimation
of the pilot density, if <code>pilot</code> is not given.
</p>
</td></tr>
<tr><td><code id="bw.abram.default_+3A_trim">trim</code></td>
<td>

<p>A trimming value required to curb excessively large bandwidths.
See Details. The default is sensible in most cases.
</p>
</td></tr>
<tr><td><code id="bw.abram.default_+3A_smoother">smoother</code></td>
<td>

<p>Smoother for the pilot.
A function or character string, specifying the function
to be used to compute the pilot estimate when
<code>pilot</code> is <code>NULL</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function computes adaptive smoothing bandwidths
using the methods of Abramson (1982) and Hall and Marron (1988).
</p>
<p>The function <code><a href="#topic+bw.abram">bw.abram</a></code> is generic. The function
<code>bw.abram.default</code> documented here is the default method
which is designed for numeric data.
</p>
<p>If <code>at="data"</code> (the default) a smoothing bandwidth is
computed for each data point in <code>X</code>. Alternatively if
<code>at="grid"</code> a smoothing bandwidth is computed for
a grid of <code>x</code> values.
</p>
<p>Under the Abramson-Hall-Marron rule, the bandwidth at location <code class="reqn">u</code> is
</p>
<p style="text-align: center;"><code class="reqn">
    h(u) = \mbox{\texttt{h0}}
    * \mbox{min}[ \frac{\tilde{f}(u)^{-1/2}}{\gamma}, \mbox{\texttt{trim}} ]
  </code>
</p>

<p>where <code class="reqn">\tilde{f}(u)</code> is a pilot estimate of the 
probability density. The variable bandwidths are rescaled by <code class="reqn">\gamma</code>, the
geometric mean of the <code class="reqn">\tilde{f}(u)^{-1/2}</code> terms evaluated at the
data; this allows the global bandwidth <code>h0</code> to be considered on
the same scale as a corresponding fixed bandwidth. The trimming value
<code>trim</code> has the same interpretation as the required &lsquo;clipping&rsquo; of
the pilot density at some small nominal value (see Hall and Marron,
1988), to necessarily prevent extreme bandwidths (which
can occur at very isolated observations).
</p>
<p>The pilot density or intensity is determined as follows:
</p>

<ul>
<li><p> If <code>pilot</code> is a <code>function</code> in the <span class="rlang"><b>R</b></span> language,
this is taken as the pilot density.
</p>
</li>
<li><p> If <code>pilot</code> is a probability density estimate
(object of class <code>"density"</code> produced by
<code><a href="stats.html#topic+density.default">density.default</a></code>) then this is taken as the 
pilot density.
</p>
</li>
<li><p> If <code>pilot</code> is <code>NULL</code>, then the pilot intensity is
computed as a fixed-bandwidth kernel
intensity estimate using <code><a href="stats.html#topic+density.default">density.default</a></code> applied to
the data <code>X</code> using
the pilot bandwidth <code>hp</code>.
</p>
</li></ul>

<p>In each case the pilot density is renormalised to
become a probability density, and then the Abramson rule is applied.
</p>
<p>Instead of calculating the pilot as a fixed-bandwidth density
estimate, the user can specify another density estimation procedure
using the argument <code>smoother</code>. This should be either a function
or the character string name of a function. It will replace
<code><a href="stats.html#topic+density.default">density.default</a></code> as the function used to calculate the
pilot estimate. The pilot estimate will be computed as
<code>smoother(X, sigma=hp, ...)</code> if <code>pilot</code> is <code>NULL</code>,
or <code>smoother(pilot, sigma=hp, ...)</code> if <code>pilot</code> is a point
pattern. If <code>smoother</code> does not recognise the argument name
<code>sigma</code> for the smoothing bandwidth, then <code>hp</code> is effectively
ignored.
</p>


<h3>Value</h3>

<p>Either a numeric vector of the same length as <code>X</code>
giving the Abramson bandwidth for each point
(when <code>at = "data"</code>, the default),
or a <code>function</code> giving the Abramson bandwidths
as a function of location.
</p>


<h3>Author(s)</h3>

<p>Tilman Davies <a href="mailto:Tilman.Davies@otago.ac.nz">Tilman.Davies@otago.ac.nz</a>. Adapted by Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>.
</p>


<h3>References</h3>

<p>Abramson, I. (1982)
On bandwidth variation in kernel estimates &mdash; a square root law.
<em>Annals of Statistics</em>, <b>10</b>(4), 1217-1223. 
</p>
<p>Hall, P. and Marron, J.S. (1988)
Variable window width kernel density estimates of probability
densities.
<em>Probability Theory and Related Fields</em>, <b>80</b>, 37-49. 
</p>
<p>Silverman, B.W. (1986)
<em>Density Estimation for Statistics and Data Analysis</em>.
Chapman and Hall, New York.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bw.abram">bw.abram</a></code>,
<code><a href="stats.html#topic+bw.nrd0">bw.nrd0</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  xx &lt;- rexp(20)
  bw.abram(xx)
</code></pre>

<hr>
<h2 id='CDF'>
Cumulative Distribution Function From Kernel Density Estimate
</h2><span id='topic+CDF'></span><span id='topic+CDF.density'></span>

<h3>Description</h3>

<p>Given a kernel estimate of a probability density,
compute the corresponding cumulative distribution function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CDF(f, ...)

## S3 method for class 'density'
CDF(f, ..., warn = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CDF_+3A_f">f</code></td>
<td>

<p>Density estimate (object of class <code>"density"</code>).
</p>
</td></tr>
<tr><td><code id="CDF_+3A_...">...</code></td>
<td>

<p>Ignored.
</p>
</td></tr>
<tr><td><code id="CDF_+3A_warn">warn</code></td>
<td>

<p>Logical value indicating whether to issue a warning if the
density estimate <code>f</code> had to be renormalised because it
was computed in a restricted interval.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>CDF</code> is generic, with a method for class <code>"density"</code>.
</p>
<p>This calculates the cumulative distribution function
whose probability density has been estimated and stored in the object
<code>f</code>. The object <code>f</code> must belong to the class <code>"density"</code>,
and would typically have been obtained from a call to the function
<code><a href="stats.html#topic+density">density</a></code>.
</p>


<h3>Value</h3>

<p>A function, which can be applied to any numeric value or vector of
values.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+density">density</a></code>,
<code><a href="#topic+quantile.density">quantile.density</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   b &lt;- density(runif(10))
   f &lt;- CDF(b)
   f(0.5)
   plot(f)
</code></pre>

<hr>
<h2 id='densityAdaptiveKernel'>
Adaptive Kernel Estimation of Density or Intensity
</h2><span id='topic+densityAdaptiveKernel'></span>

<h3>Description</h3>

<p>Computes an adaptive estimate of probability density or intensity
using a variable-bandwidth smoothing kernel.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  densityAdaptiveKernel(X, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="densityAdaptiveKernel_+3A_x">X</code></td>
<td>

<p>Data to be smoothed. 
</p>
</td></tr>
<tr><td><code id="densityAdaptiveKernel_+3A_...">...</code></td>
<td>

<p>Additional arguments passed to methods.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This generic function computes an adaptive kernel estimate of 
probability density or intensity.
</p>
<p>The function <code>densityAdaptiveKernel</code> is generic.
The <span class="pkg">spatstat</span> package family includes methods for spatial objects.
</p>


<h3>Value</h3>

<p>See documentation for each method.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a> and Tilman Davies <a href="mailto:Tilman.Davies@otago.ac.nz">Tilman.Davies@otago.ac.nz</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bw.abram">bw.abram</a></code>.
</p>

<hr>
<h2 id='dkernel'>Kernel distributions and random generation</h2><span id='topic+dkernel'></span><span id='topic+pkernel'></span><span id='topic+qkernel'></span><span id='topic+rkernel'></span>

<h3>Description</h3>

<p>Density, distribution function, quantile function and random
generation for several distributions used in kernel estimation
for numerical data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dkernel(x, kernel = "gaussian", mean = 0, sd = 1)
pkernel(q, kernel = "gaussian", mean = 0, sd = 1, lower.tail = TRUE)
qkernel(p, kernel = "gaussian", mean = 0, sd = 1, lower.tail = TRUE)
rkernel(n, kernel = "gaussian", mean = 0, sd = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dkernel_+3A_x">x</code>, <code id="dkernel_+3A_q">q</code></td>
<td>
<p>Vector of quantiles.</p>
</td></tr>
<tr><td><code id="dkernel_+3A_p">p</code></td>
<td>
<p>Vector of probabilities.</p>
</td></tr>
<tr><td><code id="dkernel_+3A_kernel">kernel</code></td>
<td>

<p>String name of the kernel.
Options are
<code>"gaussian"</code>, <code>"rectangular"</code>,
<code>"triangular"</code>,
<code>"epanechnikov"</code>,
<code>"biweight"</code>,
<code>"cosine"</code> and <code>"optcosine"</code>.
(Partial matching is used).
</p>
</td></tr>
<tr><td><code id="dkernel_+3A_n">n</code></td>
<td>
<p>Number of observations.</p>
</td></tr>
<tr><td><code id="dkernel_+3A_mean">mean</code></td>
<td>
<p>Mean of distribution.</p>
</td></tr>
<tr><td><code id="dkernel_+3A_sd">sd</code></td>
<td>
<p>Standard deviation of distribution.</p>
</td></tr>
<tr><td><code id="dkernel_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical; if <code>TRUE</code> (the default),
then probabilities are <code class="reqn">P(X \le x)</code>,
otherwise, <code class="reqn">P(X &gt; x)</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions give the
probability density, cumulative distribution function,
quantile function and random generation for several
distributions used in kernel estimation for one-dimensional
(numerical) data.
</p>
<p>The available kernels are those used in <code><a href="stats.html#topic+density.default">density.default</a></code>,
namely <code>"gaussian"</code>, <code>"rectangular"</code>,
<code>"triangular"</code>,
<code>"epanechnikov"</code>,
<code>"biweight"</code>,
<code>"cosine"</code> and <code>"optcosine"</code>.
For more information about these kernels,
see <code><a href="stats.html#topic+density.default">density.default</a></code>. 
</p>
<p><code>dkernel</code> gives the probability density,
<code>pkernel</code> gives the cumulative distribution function,
<code>qkernel</code> gives the quantile function,
and <code>rkernel</code> generates random deviates.
</p>


<h3>Value</h3>

<p>A numeric vector.
For <code>dkernel</code>, a vector of the same length as <code>x</code>
containing the corresponding values of the probability density.
For <code>pkernel</code>, a vector of the same length as <code>x</code>
containing the corresponding values of the cumulative distribution function.
For <code>qkernel</code>, a vector of the same length as <code>p</code>
containing the corresponding quantiles.
For <code>rkernel</code>, a vector of length <code>n</code>
containing randomly generated values.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
and Martin Hazelton <a href="mailto:Martin.Hazelton@otago.ac.nz">Martin.Hazelton@otago.ac.nz</a>.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+density.default">density.default</a></code>,
<code><a href="#topic+kernel.factor">kernel.factor</a></code>,
<code><a href="#topic+kernel.moment">kernel.moment</a></code>,
<code><a href="#topic+kernel.squint">kernel.squint</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  x &lt;- seq(-3,3,length=100)
  plot(x, dkernel(x, "epa"), type="l",
           main=c("Epanechnikov kernel", "probability density"))
  plot(x, pkernel(x, "opt"), type="l",
           main=c("OptCosine kernel", "cumulative distribution function"))
  p &lt;- seq(0,1, length=256)
  plot(p, qkernel(p, "biw"), type="l",
           main=c("Biweight kernel", "cumulative distribution function"))
  y &lt;- rkernel(100, "tri")
  hist(y, main="Random variates from triangular density")
  rug(y)
</code></pre>

<hr>
<h2 id='ewcdf'>Weighted Empirical Cumulative Distribution Function</h2><span id='topic+ewcdf'></span>

<h3>Description</h3>

<p>Compute a weighted version of the
empirical cumulative distribution function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ewcdf(x, weights = NULL, normalise=TRUE, adjust=1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ewcdf_+3A_x">x</code></td>
<td>
<p>Numeric vector of observations.</p>
</td></tr>
<tr><td><code id="ewcdf_+3A_weights">weights</code></td>
<td>

<p>Optional. Numeric vector of non-negative weights for <code>x</code>.
Defaults to equal weight 1 for each entry of <code>x</code>.
</p>
</td></tr>
<tr><td><code id="ewcdf_+3A_normalise">normalise</code></td>
<td>

<p>Logical value indicating whether the weights should be rescaled
so that they sum to 1.
</p>
</td></tr>
<tr><td><code id="ewcdf_+3A_adjust">adjust</code></td>
<td>

<p>Numeric value. Adjustment factor.
The weights will be multiplied by <code>adjust</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a modification of the standard function <code><a href="stats.html#topic+ecdf">ecdf</a></code>
allowing the observations <code>x</code> to have weights.
</p>
<p>The weighted e.c.d.f. (empirical cumulative distribution function)
<code>Fn</code> is defined so that, for any real number <code>y</code>, the value of
<code>Fn(y)</code> is equal to the total weight of all entries of
<code>x</code> that are less than or equal to <code>y</code>. That is
<code>Fn(y) = sum(weights[x &lt;= y])</code>.
</p>
<p>Thus <code>Fn</code> is a step function which jumps at the
values of <code>x</code>. The height of the jump at a point <code>y</code>
is the total weight of all entries in <code>x</code> 
number of tied observations at that value.  Missing values are
ignored.
</p>
<p>If <code>weights</code> is omitted, the default is equivalent to
<code>ecdf(x)</code> except for the class membership.
</p>
<p>The result of <code>ewcdf</code> is a function, of class <code>"ewcdf"</code>,
inheriting from the classes <code>"ecdf"</code> (only if <code>normalise=TRUE</code>)
and <code>"stepfun"</code>.
</p>
<p>The class <code>ewcdf</code> has methods for
<code><a href="base.html#topic+print">print</a></code>, 
<code><a href="stats.html#topic+quantile">quantile</a></code>
and <code><a href="base.html#topic+mean">mean</a></code>.
</p>
<p>The inherited classes <code>ecdf</code> and <code>stepfun</code>
have methods for <code><a href="base.html#topic+plot">plot</a></code> and <code><a href="base.html#topic+summary">summary</a></code>.
</p>


<h3>Value</h3>

<p>A function, of class <code>"ewcdf"</code>, inheriting from 
<code>"ecdf"</code> (if <code>normalise=TRUE</code>) and <code>"stepfun"</code>. 
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+ecdf">ecdf</a></code>.
</p>
<p><code><a href="#topic+quantile.ewcdf">quantile.ewcdf</a></code>, <code><a href="#topic+mean.ewcdf">mean.ewcdf</a></code>.
</p>
<p>Integrals with respect to the weighted cumulative distribution function
can be computed using <code><a href="#topic+stieltjes">stieltjes</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   x &lt;- rnorm(100)
   w &lt;- runif(100)
   plot(e &lt;- ewcdf(x,w))
   e
</code></pre>

<hr>
<h2 id='firstdigit'>
Digits in Decimal Representation
</h2><span id='topic+firstdigit'></span><span id='topic+lastdigit'></span><span id='topic+ndigits'></span>

<h3>Description</h3>

<p>Find the first or last digit in the decimal representation of a number.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>firstdigit(x)
lastdigit(x)
ndigits(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="firstdigit_+3A_x">x</code></td>
<td>
<p>A numeric value or numeric vector.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>firstdigit(x)</code> finds the first (most significant) digit,
<code>lastdigit(x)</code> finds the last (least significant) digit,
and <code>ndigits(x)</code> finds the number of digits,
in the decimal representation of each entry of <code>x</code>.
The decimal representation is truncated at the number of digits
available for double precision numbers on the hardware, usually 15.
</p>


<h3>Value</h3>

<p>An integer or integer vector of the same length as <code>x</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rounding">rounding</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>firstdigit(42)
lastdigit(42)
ndigits(42)

firstdigit(-0.1234)
lastdigit(-0.1234)
ndigits(-0.1234)

firstdigit(0)
lastdigit(0)
ndigits(0)
</code></pre>

<hr>
<h2 id='hotrod'>
Heat Kernel for a One-Dimensional Rod
</h2><span id='topic+hotrod'></span>

<h3>Description</h3>

<p>Calculate values of the heat kernel on a one-dimensional rod.
The ends of the rod may be assumed to be insulated,
or absorbing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hotrod(len, xsource, xquery, sigma, ends=c("insulated", "absorbing"), nmax=20)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hotrod_+3A_len">len</code></td>
<td>

<p>Length of the rod. A single number or numeric vector.
</p>
</td></tr>
<tr><td><code id="hotrod_+3A_xsource">xsource</code></td>
<td>

<p>Positions of the source points, from the left end of the rod
(in the same distance units as <code>len</code>).
A single number or numeric vector.
</p>
</td></tr>
<tr><td><code id="hotrod_+3A_xquery">xquery</code></td>
<td>

<p>Positions of the query points, from the left end of the rod
(in the same distance units as <code>len</code>).
A single number or numeric vector.
</p>
</td></tr>
<tr><td><code id="hotrod_+3A_sigma">sigma</code></td>
<td>

<p>Bandwidth for kernel. A single number or a numeric vector.
</p>
</td></tr>
<tr><td><code id="hotrod_+3A_ends">ends</code></td>
<td>

<p>Character string (partially matched) specifying whether the
ends of the rod are assumed to be insulated or absorbing.
</p>
</td></tr>
<tr><td><code id="hotrod_+3A_nmax">nmax</code></td>
<td>

<p>Number of terms in the infinite sum to use.
A single integer or an integer vector.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Computes the heat kernel as an infinite sum.
</p>


<h3>Value</h3>

<p>Number or numeric vector.
</p>


<h3>Author(s)</h3>

<p>Greg McSwiggan and Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  curve(hotrod(1, 0.1, x, 0.7))

  # check it's a probability density
  f &lt;- function(x) hotrod(1, 0.1, x, 0.7)
  integrate(f, 0, 1)

  ## absorbing ends
  curve(hotrod(1, 0.1, x, 0.7, ends="a"))
</code></pre>

<hr>
<h2 id='indefinteg'>
Indefinite Integral
</h2><span id='topic+indefinteg'></span>

<h3>Description</h3>

<p>Computes the indefinite integral of the given function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  indefinteg(f, x, ...,
             method=c("trapezoid", "quadrature"),
             lower=min(x), nfine=8192) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="indefinteg_+3A_f">f</code></td>
<td>

<p>an <span class="rlang"><b>R</b></span> function taking a numeric first argument and returning a
numeric vector of the same length.
</p>
</td></tr>
<tr><td><code id="indefinteg_+3A_x">x</code></td>
<td>

<p>Vector of values of the argument for which the indefinite integral
should be evaluated. 
</p>
</td></tr>
<tr><td><code id="indefinteg_+3A_...">...</code></td>
<td>

<p>additional arguments to be passed to <code>f</code>.
</p>
</td></tr>
<tr><td><code id="indefinteg_+3A_method">method</code></td>
<td>

<p>String (partially matched) specifying how to compute the integrals.
</p>
</td></tr>
<tr><td><code id="indefinteg_+3A_lower">lower</code></td>
<td>

<p>Lower limit of integration. A single number.
</p>
</td></tr>
<tr><td><code id="indefinteg_+3A_nfine">nfine</code></td>
<td>

<p>Number of sub-intervals to use for computation
if <code>method='trapezoid'</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The indefinite integral of the given function <code>f</code>
is computed numerically at each of the desired values <code>x</code>.
The lower limit of integration is taken to be <code>min(x)</code>.
</p>
<p>The result is a numeric vector <code>y</code> of the same length as
<code>x</code>, with entries
</p>
<p style="text-align: center;"><code class="reqn">
    y_i = \int_{\mbox{lower}}^{x_i} f(t) dt
  </code>
</p>

<p>If <code>method='trapezoid'</code> (the default),
the integrals are computed rapidly using the trapezoid rule.
If <code>method='quadrature'</code> the integrals are computed
accurately but much more slowly, using the numerical quadrature routine
<code><a href="stats.html#topic+integrate">integrate</a></code>.
</p>
<p>If <code>method='trapezoid'</code> 
the function <code>f</code> is first evaluated 
on a finer grid of values of the function argument.
The fine grid contains <code>nfine</code> sample points.
The values of the indefinite integral on the fine grid
are computed using the trapezoidal approximation.
Finally the values of the indefinite integral are extracted at
the desired argument values <code>x</code>.
</p>


<h3>Value</h3>

<p>Numeric vector of the same length as <code>x</code>. 
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+integrate">integrate</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  curve(indefinteg(sin, x), to=pi)
</code></pre>

<hr>
<h2 id='integral'>
Integral of a Function or Spatial Object
</h2><span id='topic+integral'></span>

<h3>Description</h3>

<p>Computes the integral of a function or spatial object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>integral(f, domain=NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="integral_+3A_f">f</code></td>
<td>

<p>A function, or a spatial object that can be treated as a function.
</p>
</td></tr>
<tr><td><code id="integral_+3A_domain">domain</code></td>
<td>

<p>Optional. Data specifying the domain of integration.
</p>
</td></tr>
<tr><td><code id="integral_+3A_...">...</code></td>
<td>

<p>Arguments passed to methods.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>integral</code> is generic.
It calculates the integral of a function, or
the integral of a spatial object that can be treated as a function.
It has methods
for one-dimensional functions (<code>"density"</code>, <code>"fv"</code>)
and for spatial objects
(<code>"im"</code>, <code>"msr"</code>, <code>"linim"</code>, <code>"linfun"</code>).
</p>


<h3>Value</h3>

<p>A single numeric or complex value, or a vector of such values.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>See Also</h3>


<p><code><a href="#topic+integral.density">integral.density</a></code>.
</p>
<p><code>integral.im</code> in package <code>spatstat.geom</code>.
</p>

<hr>
<h2 id='integral.density'>
Compute Integral of One-Dimensional Kernel Density Estimate.
</h2><span id='topic+integral.density'></span>

<h3>Description</h3>

<p>Compute the integral of a kernel density estimate
over a specified range.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'density'
integral(f, domain = NULL, weight=NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="integral.density_+3A_f">f</code></td>
<td>

<p>A one-dimensional probability density estimate
(object of class <code>"density"</code>) obtained from the
function <code><a href="stats.html#topic+density.default">density.default</a></code> or
from <code><a href="#topic+unnormdensity">unnormdensity</a></code>.
</p>
</td></tr>
<tr><td><code id="integral.density_+3A_domain">domain</code></td>
<td>

<p>Optional. Range of values of the argument <code class="reqn">x</code> over which the
density <code class="reqn">f(x)</code> should be integrated. A numeric vector of length
2 giving the minimum and maximum values of <code class="reqn">x</code>. Infinite limits
are permitted.
</p>
</td></tr>
<tr><td><code id="integral.density_+3A_weight">weight</code></td>
<td>

<p>Optional. A <code>function(x)</code> specifying a weight integrand.
</p>
</td></tr>
<tr><td><code id="integral.density_+3A_...">...</code></td>
<td>

<p>Ignored.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a method for the generic function <code><a href="#topic+integral">integral</a></code>.
It computes the numerical integral
</p>
<p style="text-align: center;"><code class="reqn">
    I = \int f(x) dx
  </code>
</p>

<p>of the density estimate <code>f</code>.
If <code>weight</code> is specified, then the weighted integral
</p>
<p style="text-align: center;"><code class="reqn">
    I = \int w(x) f(x) dx
  </code>
</p>

<p>is computed, where <code class="reqn">w</code> is the function specified by <code>weight</code>.
This function must return finite numerical values.
</p>
<p>If <code>domain</code> is specified, the integral is restricted to the
interval of <code class="reqn">x</code> values given by the <code>domain</code>.
</p>
<p>Integrals are calculated numerically using the trapezoidal rule
restricted to the domain given.
</p>


<h3>Value</h3>

<p>A single numerical value.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+density.default">density.default</a></code>
</p>
<p><code><a href="#topic+quantile.density">quantile.density</a></code>, <code><a href="#topic+CDF.density">CDF.density</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  x &lt;- runif(10)
  d &lt;- density(x, bw=0.1)
  integral(d) # should be approximately 1
  integral(d, domain=c(-Inf, 0)) # mass on negative half-line
  ## mean of density
  integral(d, weight=function(x) x)
</code></pre>

<hr>
<h2 id='kaplan.meier'>Kaplan-Meier Estimator using Histogram Data</h2><span id='topic+kaplan.meier'></span>

<h3>Description</h3>

<p>Compute the Kaplan-Meier estimator of a survival time distribution
function, from histogram data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  kaplan.meier(obs, nco, breaks, upperobs=0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kaplan.meier_+3A_obs">obs</code></td>
<td>
<p>vector of <code class="reqn">n</code> integers giving the histogram of
all observations (censored or uncensored survival times)
</p>
</td></tr>
<tr><td><code id="kaplan.meier_+3A_nco">nco</code></td>
<td>
<p>vector of <code class="reqn">n</code> integers giving the histogram of
uncensored observations (those survival times that are less than or
equal to the censoring time)
</p>
</td></tr>
<tr><td><code id="kaplan.meier_+3A_breaks">breaks</code></td>
<td>
<p>Vector of <code class="reqn">n+1</code> breakpoints which were used to form
both histograms.
</p>
</td></tr>
<tr><td><code id="kaplan.meier_+3A_upperobs">upperobs</code></td>
<td>

<p>Number of observations beyond the rightmost breakpoint, if any.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is needed mainly for internal use in <span class="pkg">spatstat</span>,
but may be useful in other applications where you want to form the
Kaplan-Meier estimator from a huge dataset.
</p>
<p>Suppose <code class="reqn">T_i</code> are the survival times of individuals
<code class="reqn">i=1,\ldots,M</code> with unknown distribution function <code class="reqn">F(t)</code>
which we wish to estimate. Suppose these times are right-censored
by random censoring times <code class="reqn">C_i</code>.
Thus the observations consist of right-censored survival times
<code class="reqn">\tilde T_i = \min(T_i,C_i)</code>
and non-censoring indicators
<code class="reqn">D_i = 1\{T_i \le C_i\}</code>
for each <code class="reqn">i</code>.
</p>
<p>If the number of observations <code class="reqn">M</code> is large, it is efficient to
use histograms.
Form the histogram <code>obs</code> of all observed times <code class="reqn">\tilde T_i</code>.
That is, <code>obs[k]</code> counts the number of values 
<code class="reqn">\tilde T_i</code> in the interval
<code>(breaks[k],breaks[k+1]]</code> for <code class="reqn">k &gt; 1</code>
and <code>[breaks[1],breaks[2]]</code> for <code class="reqn">k = 1</code>.
Also form the histogram <code>nco</code> of all uncensored times,
i.e. those <code class="reqn">\tilde T_i</code> such that <code class="reqn">D_i=1</code>.
These two histograms are the arguments passed to <code>kaplan.meier</code>.
</p>
<p>The vectors <code>km</code> and <code>lambda</code> returned by <code>kaplan.meier</code>
are (histogram approximations to) the Kaplan-Meier estimator
of <code class="reqn">F(t)</code> and its hazard rate <code class="reqn">\lambda(t)</code>.
Specifically, <code>km[k]</code> is an estimate of
<code>F(breaks[k+1])</code>, and <code>lambda[k]</code> is an estimate of
the average of <code class="reqn">\lambda(t)</code> over the interval
<code>(breaks[k],breaks[k+1])</code>.
</p>
<p>The histogram breaks must include <code class="reqn">0</code>.
If the histogram breaks do not span the range of the observations,
it is important to count how many survival times
<code class="reqn">\tilde T_i</code> exceed the rightmost breakpoint,
and give this as the value <code>upperobs</code>.
</p>


<h3>Value</h3>

<p>A list with two elements:
</p>
<table>
<tr><td><code>km</code></td>
<td>
<p>Kaplan-Meier estimate of the survival time c.d.f. <code class="reqn">F(t)</code>
</p>
</td></tr>
<tr><td><code>lambda</code></td>
<td>
<p>corresponding Nelson-Aalen estimate of the
hazard rate <code class="reqn">\lambda(t)</code>
</p>
</td></tr>
</table>
<p>These are numeric vectors of length <code class="reqn">n</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+reduced.sample">reduced.sample</a></code>,
<code><a href="#topic+km.rs">km.rs</a></code>
</p>

<hr>
<h2 id='kernel.factor'>Scale factor for density kernel</h2><span id='topic+kernel.factor'></span>

<h3>Description</h3>

<p>Returns a scale factor for the kernels used in density estimation
for numerical data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  kernel.factor(kernel = "gaussian")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kernel.factor_+3A_kernel">kernel</code></td>
<td>

<p>String name of the kernel.
Options are
<code>"gaussian"</code>, <code>"rectangular"</code>,
<code>"triangular"</code>,
<code>"epanechnikov"</code>,
<code>"biweight"</code>,
<code>"cosine"</code> and <code>"optcosine"</code>.
(Partial matching is used).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Kernel estimation of a probability density in one dimension
is performed by <code><a href="stats.html#topic+density.default">density.default</a></code>
using a kernel function selected from the list above.
</p>
<p>This function computes a scale constant for the kernel.
For the Gaussian kernel, this constant is equal to 1.
Otherwise, the constant <code class="reqn">c</code> is such that the kernel
with standard deviation <code class="reqn">1</code> is supported on the interval
<code class="reqn">[-c,c]</code>. 
</p>
<p>For more information about these kernels,
see <code><a href="stats.html#topic+density.default">density.default</a></code>. 
</p>


<h3>Value</h3>

<p>A single number.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
and Martin Hazelton <a href="mailto:Martin.Hazelton@otago.ac.nz">Martin.Hazelton@otago.ac.nz</a>.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+density.default">density.default</a></code>,
<code><a href="#topic+dkernel">dkernel</a></code>,
<code><a href="#topic+kernel.moment">kernel.moment</a></code>,
<code><a href="#topic+kernel.squint">kernel.squint</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   kernel.factor("rect")
   # bandwidth for Epanechnikov kernel with half-width h=1
   h &lt;- 1
   bw &lt;- h/kernel.factor("epa")
</code></pre>

<hr>
<h2 id='kernel.moment'>Incomplete Moment of Smoothing Kernel</h2><span id='topic+kernel.moment'></span>

<h3>Description</h3>

<p>Computes the complete or incomplete <code class="reqn">m</code>th moment of a
smoothing kernel.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  kernel.moment(m, r, kernel = "gaussian", mean=0, sd=1/kernel.factor(kernel))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kernel.moment_+3A_m">m</code></td>
<td>

<p>Exponent (order of moment).
An integer.
</p>
</td></tr>
<tr><td><code id="kernel.moment_+3A_r">r</code></td>
<td>

<p>Upper limit of integration for the incomplete moment.
A numeric value or numeric vector.
Set <code>r=Inf</code> to obtain the complete moment.
</p>
</td></tr>
<tr><td><code id="kernel.moment_+3A_kernel">kernel</code></td>
<td>

<p>String name of the kernel.
Options are
<code>"gaussian"</code>, <code>"rectangular"</code>,
<code>"triangular"</code>,
<code>"epanechnikov"</code>,
<code>"biweight"</code>,
<code>"cosine"</code> and <code>"optcosine"</code>.
(Partial matching is used).
</p>
</td></tr>
<tr><td><code id="kernel.moment_+3A_mean">mean</code>, <code id="kernel.moment_+3A_sd">sd</code></td>
<td>

<p>Optional numerical values giving the mean and standard deviation
of the kernel.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Kernel estimation of a probability density in one dimension
is performed by <code><a href="stats.html#topic+density.default">density.default</a></code>
using a kernel function selected from the list above.
For more information about these kernels,
see <code><a href="stats.html#topic+density.default">density.default</a></code>. 
</p>
<p>The function <code>kernel.moment</code> computes the integral 
</p>
<p style="text-align: center;"><code class="reqn">
    \int_{-\infty}^r t^m k(t) dt
  </code>
</p>

<p>where <code class="reqn">k(t)</code> is the selected kernel, <code class="reqn">r</code> is the upper limit of
integration, and <code class="reqn">m</code> is the exponent or order.
</p>
<p>Note that, if <code>mean</code> and <code>sd</code> are not specified, the
calculations assume that <code class="reqn">k(t)</code> is the <b>standard form</b> of the kernel,
which has support <code class="reqn">[-1,1]</code> and
standard deviation <code class="reqn">sigma = 1/c</code> where <code>c = kernel.factor(kernel)</code>.
</p>
<p>The code uses the explicit analytic expressions when
<code>m = 0, 1, 2</code> and numerical integration otherwise.
</p>


<h3>Value</h3>

<p>A single number, or a numeric vector of the same length as <code>r</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
and Martin Hazelton <a href="mailto:Martin.Hazelton@otago.ac.nz">Martin.Hazelton@otago.ac.nz</a>.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+density.default">density.default</a></code>,
<code><a href="#topic+dkernel">dkernel</a></code>,
<code><a href="#topic+kernel.factor">kernel.factor</a></code>,
<code><a href="#topic+kernel.squint">kernel.squint</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   kernel.moment(1, 0.1, "epa")
   curve(kernel.moment(2, x, "epa"), from=-1, to=1)
</code></pre>

<hr>
<h2 id='kernel.squint'>Integral of Squared Kernel</h2><span id='topic+kernel.squint'></span>

<h3>Description</h3>

<p>Computes the integral of the squared kernel,
for the kernels used in density estimation
for numerical data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  kernel.squint(kernel = "gaussian", bw=1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kernel.squint_+3A_kernel">kernel</code></td>
<td>

<p>String name of the kernel.
Options are
<code>"gaussian"</code>, <code>"rectangular"</code>,
<code>"triangular"</code>,
<code>"epanechnikov"</code>,
<code>"biweight"</code>,
<code>"cosine"</code> and <code>"optcosine"</code>.
(Partial matching is used).
</p>
</td></tr>
<tr><td><code id="kernel.squint_+3A_bw">bw</code></td>
<td>

<p>Bandwidth (standard deviation) of the kernel.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Kernel estimation of a probability density in one dimension
is performed by <code><a href="stats.html#topic+density.default">density.default</a></code>
using a kernel function selected from the list above.
</p>
<p>This function computes the integral of the squared kernel,
</p>
<p style="text-align: center;"><code class="reqn">
    R = \int_{-\infty}^{\infty} k(x)^2 \, {\rm d}x
  </code>
</p>

<p>where <code class="reqn">k(x)</code> is the kernel with bandwidth <code>bw</code>.
</p>


<h3>Value</h3>

<p>A single number.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a> and Martin Hazelton <a href="mailto:Martin.Hazelton@otago.ac.nz">Martin.Hazelton@otago.ac.nz</a>.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+density.default">density.default</a></code>,
<code><a href="#topic+dkernel">dkernel</a></code>,
<code><a href="#topic+kernel.moment">kernel.moment</a></code>,
<code><a href="#topic+kernel.factor">kernel.factor</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   kernel.squint("gaussian", 3)

   # integral of squared Epanechnikov kernel with half-width h=1
   h &lt;- 1
   bw &lt;- h/kernel.factor("epa")
   kernel.squint("epa", bw)
</code></pre>

<hr>
<h2 id='km.rs'>Kaplan-Meier and Reduced Sample Estimator using Histograms</h2><span id='topic+km.rs'></span>

<h3>Description</h3>

<p>Compute the Kaplan-Meier and Reduced Sample estimators of a
survival time distribution function, using histogram techniques
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  km.rs(o, cc, d, breaks)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="km.rs_+3A_o">o</code></td>
<td>
<p>vector of observed survival times
</p>
</td></tr>
<tr><td><code id="km.rs_+3A_cc">cc</code></td>
<td>
<p>vector of censoring times
</p>
</td></tr>
<tr><td><code id="km.rs_+3A_d">d</code></td>
<td>
<p>vector of non-censoring indicators
</p>
</td></tr>
<tr><td><code id="km.rs_+3A_breaks">breaks</code></td>
<td>
<p>Vector of breakpoints to be used to form histograms.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is needed mainly for internal use in <span class="pkg">spatstat</span>,
but may be useful in other applications where you want to form the
Kaplan-Meier estimator from a huge dataset.
</p>
<p>Suppose <code class="reqn">T_i</code> are the survival times of individuals
<code class="reqn">i=1,\ldots,M</code> with unknown distribution function <code class="reqn">F(t)</code>
which we wish to estimate. Suppose these times are right-censored
by random censoring times <code class="reqn">C_i</code>.
Thus the observations consist of right-censored survival times
<code class="reqn">\tilde T_i = \min(T_i,C_i)</code>
and non-censoring indicators
<code class="reqn">D_i = 1\{T_i \le C_i\}</code>
for each <code class="reqn">i</code>.
</p>
<p>The arguments to this function are 
vectors <code>o</code>, <code>cc</code>, <code>d</code>
of observed values of <code class="reqn">\tilde T_i</code>, <code class="reqn">C_i</code>
and <code class="reqn">D_i</code> respectively.
The function computes histograms and forms the reduced-sample
and Kaplan-Meier estimates of  <code class="reqn">F(t)</code> by
invoking the functions <code><a href="#topic+kaplan.meier">kaplan.meier</a></code>
and <code><a href="#topic+reduced.sample">reduced.sample</a></code>.
This is efficient if the lengths of <code>o</code>, <code>cc</code>, <code>d</code>
(i.e. the number of observations) is large.
</p>
<p>The vectors <code>km</code> and <code>hazard</code> returned by <code>kaplan.meier</code>
are (histogram approximations to) the Kaplan-Meier estimator
of <code class="reqn">F(t)</code> and its hazard rate <code class="reqn">\lambda(t)</code>.
Specifically, <code>km[k]</code> is an estimate of
<code>F(breaks[k+1])</code>, and <code>lambda[k]</code> is an estimate of
the average of <code class="reqn">\lambda(t)</code> over the interval
<code>(breaks[k],breaks[k+1])</code>. This approximation is exact only if the
survival times are discrete and the 
histogram breaks are fine enough to ensure that each interval
<code>(breaks[k],breaks[k+1])</code> contains only one possible value of
the survival time. 
</p>
<p>The vector <code>rs</code> is the reduced-sample estimator,
<code>rs[k]</code> being the reduced sample estimate of <code>F(breaks[k+1])</code>.
This value is exact, i.e. the use of histograms does not introduce any
approximation error in the reduced-sample estimator.
</p>


<h3>Value</h3>

<p>A list with five elements
</p>
<table>
<tr><td><code>rs</code></td>
<td>
<p>Reduced-sample estimate of the survival time c.d.f. <code class="reqn">F(t)</code>
</p>
</td></tr>
<tr><td><code>km</code></td>
<td>
<p>Kaplan-Meier estimate of the survival time c.d.f. <code class="reqn">F(t)</code>
</p>
</td></tr>
<tr><td><code>hazard</code></td>
<td>
<p>corresponding Nelson-Aalen estimate of the
hazard rate <code class="reqn">\lambda(t)</code>
</p>
</td></tr>
<tr><td><code>r</code></td>
<td>
<p>values of <code class="reqn">t</code> for which <code class="reqn">F(t)</code> is estimated
</p>
</td></tr>
<tr><td><code>breaks</code></td>
<td>
<p>the breakpoints vector
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+reduced.sample">reduced.sample</a></code>,
<code><a href="#topic+kaplan.meier">kaplan.meier</a></code>
</p>

<hr>
<h2 id='mean.ewcdf'>Mean of Empirical Cumulative Distribution Function</h2><span id='topic+mean.ewcdf'></span><span id='topic+mean.ecdf'></span>

<h3>Description</h3>

<p>Calculates the mean of a (weighted or unweighted)
empirical cumulative distribution function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ecdf'
mean(x, trim=0, ...)

## S3 method for class 'ewcdf'
mean(x, trim=0, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mean.ewcdf_+3A_x">x</code></td>
<td>

<p>An empirical cumulative distribution function
(object of class <code>"ecdf"</code> created by <code><a href="stats.html#topic+ecdf">ecdf</a></code>)
or a weighted empirical cumulative distribution function
(object of class <code>"ewcdf"</code> created by <code><a href="#topic+ewcdf">ewcdf</a></code>).
</p>
</td></tr>
<tr><td><code id="mean.ewcdf_+3A_trim">trim</code></td>
<td>

<p>The fraction (0 to 0.5) of data values to be trimmed from
each end of their range, before the mean is computed.
</p>
</td></tr>
<tr><td><code id="mean.ewcdf_+3A_...">...</code></td>
<td>

<p>Ignored.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions are methods for the generic
<code><a href="base.html#topic+mean">mean</a></code> 
for the classes <code>"ecdf"</code> and <code>"ewcdf"</code>.
</p>
<p>They calculate the mean of the probability distribution
corresponding to the cumulative distribution function <code>x</code>.
This is equivalent to calculating the (weighted or unweighted)
mean of the original data values.
</p>
<p>For <em>weighted</em> empirical cumulative distribution functions
(class <code>"ewcdf"</code>) the weights will first be normalised so that they
sum to 1. The result of <code>mean.ewcdf</code>
is always an average or weighted average or the original data values.
The argument <code>trim</code> is interpreted as a probability
under this normalised distribution; the corresponding
quantiles are computed, and data outside these quantiles is deleted
before calculating the weighted mean.
</p>


<h3>Value</h3>

<p>A single number.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>See Also</h3>

<p>Generic <code><a href="base.html#topic+mean">mean</a></code> and
<code><a href="stats.html#topic+weighted.mean">weighted.mean</a></code>.
</p>
<p><code><a href="stats.html#topic+ecdf">ecdf</a></code>, <code><a href="#topic+ewcdf">ewcdf</a></code>
to create the cumulative distribution functions.
</p>
<p><code><a href="#topic+stieltjes">stieltjes</a></code> for integration with respect to
a cumulative distribution function.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  x &lt;- 1:5
  mean(x)
  mean(ecdf(x))
  w &lt;- 1:5
  mean(ewcdf(x, w))
</code></pre>

<hr>
<h2 id='quantile.density'>
Quantiles of a Density Estimate
</h2><span id='topic+quantile.density'></span>

<h3>Description</h3>

<p>Given a kernel estimate of a probability density, compute quantiles.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'density'
quantile(x, probs = seq(0, 1, 0.25), names = TRUE,
        ..., warn = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="quantile.density_+3A_x">x</code></td>
<td>

<p>Object of class <code>"density"</code> computed by a method for
<code><a href="stats.html#topic+density">density</a></code>
</p>
</td></tr>
<tr><td><code id="quantile.density_+3A_probs">probs</code></td>
<td>

<p>Numeric vector of probabilities for which the quantiles are required.
</p>
</td></tr>
<tr><td><code id="quantile.density_+3A_names">names</code></td>
<td>

<p>Logical value indicating whether to attach names (based on
<code>probs</code>) to the result.
</p>
</td></tr>
<tr><td><code id="quantile.density_+3A_...">...</code></td>
<td>

<p>Ignored.
</p>
</td></tr>
<tr><td><code id="quantile.density_+3A_warn">warn</code></td>
<td>

<p>Logical value indicating whether to issue a warning if the
density estimate <code>x</code> had to be renormalised because it
was computed in a restricted interval.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function calculates quantiles of the probability distribution
whose probability density has been estimated and stored in the object
<code>x</code>. The object <code>x</code> must belong to the class <code>"density"</code>,
and would typically have been obtained from a call to the function
<code><a href="stats.html#topic+density">density</a></code>.
</p>
<p>The probability density is first normalised so that the total
probability is equal to 1. A warning is issued if the density
estimate was restricted to an interval (i.e. if <code>x</code>
was created by a call to   <code><a href="stats.html#topic+density">density</a></code> which
included either of the arguments <code>from</code> and <code>to</code>).
</p>
<p>Next, the density estimate is numerically integrated to obtain an estimate
of the cumulative distribution function <code class="reqn">F(x)</code>. Then
for each desired probability <code class="reqn">p</code>, the algorithm finds the
corresponding quantile <code class="reqn">q</code>.
</p>
<p>The quantile <code class="reqn">q</code> corresponding to probability <code class="reqn">p</code>
satisfies <code class="reqn">F(q) = p</code> up to
the resolution of the grid of values contained in <code>x</code>.
The quantile is computed from the right, that is,
<code class="reqn">q</code> is the smallest available value of <code class="reqn">x</code> such that
<code class="reqn">F(x) \ge p</code>.
</p>


<h3>Value</h3>

<p>A numeric vector containing the quantiles.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.  
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+quantile">quantile</a></code>, 
<code><a href="#topic+quantile.ewcdf">quantile.ewcdf</a></code>, 
<code><a href="#topic+CDF">CDF</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   dd &lt;- density(runif(10))
   quantile(dd)
</code></pre>

<hr>
<h2 id='quantile.ewcdf'>
Quantiles of Weighted Empirical Cumulative Distribution Function
</h2><span id='topic+quantile.ewcdf'></span>

<h3>Description</h3>

<p>Compute quantiles of a weighted empirical cumulative distribution function.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'ewcdf'
quantile(x, probs = seq(0, 1, 0.25),
                 names = TRUE, ...,
                 normalise = TRUE, type=1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="quantile.ewcdf_+3A_x">x</code></td>
<td>

<p>A weighted empirical cumulative distribution function
(object of class <code>"ewcdf"</code>, produced by <code><a href="#topic+ewcdf">ewcdf</a></code>)
for which the quantiles are desired.
</p>
</td></tr>
<tr><td><code id="quantile.ewcdf_+3A_probs">probs</code></td>
<td>

<p>probabilities for which the quantiles are desired.
A numeric vector of values between 0 and 1.
</p>
</td></tr>
<tr><td><code id="quantile.ewcdf_+3A_names">names</code></td>
<td>

<p>Logical. If <code>TRUE</code>, the resulting vector of quantiles is
annotated with names corresponding to <code>probs</code>.
</p>
</td></tr>
<tr><td><code id="quantile.ewcdf_+3A_...">...</code></td>
<td>

<p>Ignored.
</p>
</td></tr>
<tr><td><code id="quantile.ewcdf_+3A_normalise">normalise</code></td>
<td>

<p>Logical value indicating whether <code>x</code> should first be normalised
so that it ranges between 0 and 1. 
</p>
</td></tr>
<tr><td><code id="quantile.ewcdf_+3A_type">type</code></td>
<td>

<p>Integer specifying the type of quantile to be calculated,
as explained in <code><a href="stats.html#topic+quantile.default">quantile.default</a></code>.
Only types 1 and 2 are currently implemented.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a method for the generic <code><a href="stats.html#topic+quantile">quantile</a></code>
function for the class <code>ewcdf</code> of empirical weighted cumulative
distribution functions.
</p>
<p>The quantile for a probability <code>p</code> is computed
as the right-continuous inverse of the cumulative
distribution function <code>x</code> (assuming <code>type=1</code>, the default).
</p>
<p>If <code>normalise=TRUE</code> (the default),
the weighted cumulative function <code>x</code> is first normalised to
have total mass <code>1</code> so that it can be interpreted as a
cumulative probability distribution function. 
</p>


<h3>Value</h3>

<p>Numeric vector of quantiles, of the same length as <code>probs</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>
and Kevin Ummel.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ewcdf">ewcdf</a></code>, 
<code><a href="stats.html#topic+quantile">quantile</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  z &lt;- rnorm(50)
  w &lt;- runif(50)
  Fun &lt;- ewcdf(z, w)
  quantile(Fun, c(0.95,0.99))
</code></pre>

<hr>
<h2 id='quantilefun'>
Quantile Function
</h2><span id='topic+quantilefun'></span><span id='topic+quantilefun.ecdf'></span><span id='topic+quantilefun.ewcdf'></span>

<h3>Description</h3>

<p>Return the inverse function of a cumulative distribution function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  quantilefun(x, ...)

  ## S3 method for class 'ecdf'
quantilefun(x, ..., type=1)

  ## S3 method for class 'ewcdf'
quantilefun(x, ..., type=1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="quantilefun_+3A_x">x</code></td>
<td>

<p>Data for which the quantile function should be calculated.
Either an object containing data (such as a pixel image)
or an object representing a cumulative distribution function
(of class <code>"ecdf"</code> or <code>"ewcdf"</code>).
</p>
</td></tr>
<tr><td><code id="quantilefun_+3A_...">...</code></td>
<td>

<p>Other arguments passed to methods.
</p>
</td></tr>
<tr><td><code id="quantilefun_+3A_type">type</code></td>
<td>

<p>Integer specifying the type of quantiles,
as explained in <code><a href="stats.html#topic+quantile.default">quantile.default</a></code>.
Only types 1 and 2 are currently implemented.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Whereas the command <code><a href="stats.html#topic+quantile">quantile</a></code> calculates
the quantiles of a dataset corresponding to desired probabilities
<code class="reqn">p</code>, the command <code>quantilefun</code>
returns a function which can be used to compute any quantiles of the
dataset. 
</p>
<p>If <code>f &lt;- quantilefun(x)</code> then <code>f</code> is a function such that
<code>f(p)</code> is the quantile associated with any given probability <code>p</code>.
For example <code>f(0.5)</code> is the median of the original data, and
<code>f(0.99)</code> is the 99th percentile of the original data.
</p>
<p>If <code>x</code> is a pixel image (object of class <code>"im"</code>)
then the pixel values of <code>x</code> will be extracted
and the quantile function of the pixel values is constructed.
</p>
<p>If <code>x</code> is an object representing a cumulative distribution
function (object of class <code>"ecdf"</code> or <code>"ewcdf"</code>) then the
quantile function of the original data is constructed.
</p>


<h3>Value</h3>

<p>A function in the <span class="rlang"><b>R</b></span> language.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ewcdf">ewcdf</a></code>, 
<code><a href="#topic+quantile.ewcdf">quantile.ewcdf</a></code>, 
<code><a href="stats.html#topic+ecdf">ecdf</a></code>,
<code><a href="stats.html#topic+quantile">quantile</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  ## numeric data
  z &lt;- rnorm(50)
  FZ &lt;- ecdf(z)
  QZ &lt;- quantilefun(FZ)
  QZ(0.5) # median value of z
  if(interactive()) plot(QZ,xlim=c(0,1),xlab="probability",ylab="quantile of z")
</code></pre>

<hr>
<h2 id='reduced.sample'>Reduced Sample Estimator using Histogram Data</h2><span id='topic+reduced.sample'></span>

<h3>Description</h3>

<p>Compute the Reduced Sample estimator of a survival time distribution
function, from histogram data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  reduced.sample(nco, cen, ncc, show=FALSE, uppercen=0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reduced.sample_+3A_nco">nco</code></td>
<td>
<p>vector of counts giving the histogram of
uncensored observations (those survival times that are less than or
equal to the censoring time)
</p>
</td></tr>
<tr><td><code id="reduced.sample_+3A_cen">cen</code></td>
<td>
<p>vector of counts giving the histogram of
censoring times
</p>
</td></tr>
<tr><td><code id="reduced.sample_+3A_ncc">ncc</code></td>
<td>
<p>vector of counts giving the histogram of
censoring times for the uncensored observations only 
</p>
</td></tr>
<tr><td><code id="reduced.sample_+3A_uppercen">uppercen</code></td>
<td>

<p>number of censoring times greater than the rightmost
histogram breakpoint (if there are any)
</p>
</td></tr>
<tr><td><code id="reduced.sample_+3A_show">show</code></td>
<td>
<p>Logical value controlling the amount of detail
returned by the function value (see below)
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is needed mainly for internal use in <span class="pkg">spatstat</span>,
but may be useful in other applications where you want to form the
reduced sample estimator from a huge dataset.
</p>
<p>Suppose <code class="reqn">T_i</code> are the survival times of individuals
<code class="reqn">i=1,\ldots,M</code> with unknown distribution function <code class="reqn">F(t)</code>
which we wish to estimate. Suppose these times are right-censored
by random censoring times <code class="reqn">C_i</code>.
Thus the observations consist of right-censored survival times
<code class="reqn">\tilde T_i = \min(T_i,C_i)</code>
and non-censoring indicators
<code class="reqn">D_i = 1\{T_i \le C_i\}</code>
for each <code class="reqn">i</code>.
</p>
<p>If the number of observations <code class="reqn">M</code> is large, it is efficient to
use histograms.
Form the histogram <code>cen</code> of all censoring times <code class="reqn">C_i</code>.
That is, <code>obs[k]</code> counts the number of values 
<code class="reqn">C_i</code> in the interval
<code>(breaks[k],breaks[k+1]]</code> for <code class="reqn">k &gt; 1</code>
and <code>[breaks[1],breaks[2]]</code> for <code class="reqn">k = 1</code>.
Also form the histogram <code>nco</code> of all uncensored times,
i.e. those <code class="reqn">\tilde T_i</code> such that <code class="reqn">D_i=1</code>,
and the histogram of all censoring times for which the survival time
is uncensored,
i.e. those <code class="reqn">C_i</code> such that <code class="reqn">D_i=1</code>.
These three histograms are the arguments passed to <code>kaplan.meier</code>.
</p>
<p>The return value <code>rs</code> is the reduced-sample estimator
of the distribution function <code class="reqn">F(t)</code>. Specifically,
<code>rs[k]</code> is the reduced sample estimate of <code>F(breaks[k+1])</code>.
The value is exact, i.e. the use of histograms does not introduce any
approximation error.
</p>
<p>Note that, for the results to be valid, either the histogram breaks
must span the censoring times, or the number of censoring times
that do not fall in a histogram cell must have been counted in
<code>uppercen</code>.
</p>


<h3>Value</h3>

<p>If <code>show = FALSE</code>, a numeric vector giving the values of
the reduced sample estimator.
If <code>show=TRUE</code>, a list with three components which are
vectors of equal length,
</p>
<table>
<tr><td><code>rs</code></td>
<td>
<p>Reduced sample estimate of the survival time c.d.f. <code class="reqn">F(t)</code>
</p>
</td></tr>
<tr><td><code>numerator</code></td>
<td>
<p>numerator of the reduced sample estimator
</p>
</td></tr>
<tr><td><code>denominator</code></td>
<td>
<p>denominator of the reduced sample estimator
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+kaplan.meier">kaplan.meier</a></code>,
<code><a href="#topic+km.rs">km.rs</a></code>
</p>

<hr>
<h2 id='rounding'>
Detect Numerical Rounding 
</h2><span id='topic+rounding'></span><span id='topic+rounding.default'></span>

<h3>Description</h3>

<p>Given a numeric vector,
determine whether the values have been rounded
to a certain number of decimal places.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rounding(x)

## Default S3 method:
rounding(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rounding_+3A_x">x</code></td>
<td>

<p>A numeric vector, or an object containing numeric spatial coordinates.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>rounding</code> is generic.
Its purpose is to determine whether numerical values have been rounded
to a certain number of decimal places.
</p>
<p>The <span class="pkg">spatstat</span> family of packages provides methods for
<code>rounding</code> for various spatial objects.
</p>
<p>For a numeric vector <code>x</code>, the default method <code>rounding.default</code>
determines whether the values in <code>x</code> have been rounded
to a certain number of decimal places.
</p>

<ul>
<li> 
<p>If the entries of <code>x</code> are not all integers, then
<code>rounding(x)</code> returns the smallest number of digits <code>d</code>
after the decimal point
such that <code><a href="base.html#topic+round">round</a>(x, digits=d)</code> is identical to
<code>x</code>.
For example if <code>rounding(x) = 2</code> then the entries of
<code>x</code> are rounded to 2 decimal places, and are multiples of 0.01.
</p>
</li>
<li> 
<p>If all the entries of <code>x</code> are integers, then
<code>rounding(x)</code> returns <code>-d</code>, where
<code>d</code> is the smallest number of digits <em>before</em> the decimal point
such that <code><a href="base.html#topic+round">round</a>(x, digits=-d)</code> is identical to
<code>x</code>.
For example if <code>rounding(x) = -3</code> then the entries of
<code>x</code> are multiples of 1000.
If <code>rounding(x) = 0</code> then the entries of <code>x</code> are integers
but not multiples of 10.
</p>
</li>
<li>
<p>If all entries of <code>x</code> are equal to 0, a value of 0 is returned.
</p>
</li></ul>



<h3>Value</h3>

<p>An integer.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code>round.ppp</code> in package <code>spatstat.geom</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   rounding(c(0.1, 0.3, 1.2))
   rounding(c(1940, 1880, 2010))
   rounding(0)
</code></pre>

<hr>
<h2 id='spatstat.univar-internal'>Internal Functions</h2><span id='topic+as.breakpts'></span><span id='topic+breakpts'></span><span id='topic+breakpts.from.r'></span><span id='topic+check.hist.lengths'></span><span id='topic+km.rs.opt'></span><span id='topic+make.even.breaks'></span><span id='topic+match.kernel'></span><span id='topic+print.ewcdf'></span><span id='topic+quantilefun.interpolatedCDF'></span><span id='topic+IdenticalRowPair'></span><span id='topic+IdenticalRows'></span><span id='topic+StieltjesCalc'></span><span id='topic+StieltjesCalc.stepfun'></span>

<h3>Description</h3>

<p>Undocumented Functions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.breakpts(...)
breakpts(val, maxi, even, npos, step)
breakpts.from.r(r)
check.hist.lengths(hist, breaks)
make.even.breaks(bmax, npos, bstep)
km.rs.opt(o, cc, d, breaks, KM, RS)
make.even.breaks(bmax, npos, bstep)
match.kernel(kernel)
## S3 method for class 'ewcdf'
print(x, digits, ...)
## S3 method for class 'interpolatedCDF'
quantilefun(x, ..., type)
IdenticalRowPair(i,j,a,b)
IdenticalRows(i,j,a,b)
StieltjesCalc(M, f, ...)
## S3 method for class 'stepfun'
StieltjesCalc(M, f, ...)
</code></pre>


<h3>Details</h3>

<p>These functions are not documented.
</p>


<h3>Value</h3>

<p><code>as.breakpts</code>, <code>breakpts</code>, <code>breakpts.from.r</code> and
<code>make.even.breaks</code> return an object of class <code>"breakpts"</code>
which defines a sequence of breakpoints, identifies whether they are
equally-spaced and so on. <code>match.kernel</code> returns a single
character string. <code>check.hist.lengths</code> returns <code>NULL</code>.
<code>quantilefun.interpolatedCDF</code> returns a function.
The <code>print</code> method returns <code>NULL</code>. Other functions are
not documented.
</p>

<hr>
<h2 id='stieltjes'>Compute Integral of Function Against Cumulative Distribution</h2><span id='topic+stieltjes'></span>

<h3>Description</h3>

<p>Computes the Stieltjes integral 
of a function <code class="reqn">f</code> with respect to a function <code class="reqn">M</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stieltjes(f, M, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stieltjes_+3A_f">f</code></td>
<td>

<p>The integrand. A function in the <span class="rlang"><b>R</b></span> language.
</p>
</td></tr>
<tr><td><code id="stieltjes_+3A_m">M</code></td>
<td>

<p>The cumulative function against which <code>f</code> will be
integrated. An object of class <code>"fv"</code> or <code>"stepfun"</code>.
</p>
</td></tr>
<tr><td><code id="stieltjes_+3A_...">...</code></td>
<td>

<p>Additional arguments passed to <code>f</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This command computes the Stieltjes integral
</p>
<p style="text-align: center;"><code class="reqn">I = \int f(x) dM(x)</code>
</p>

<p>of a real-valued function <code class="reqn">f(x)</code>
with respect to a nondecreasing function <code class="reqn">M(x)</code>.
</p>
<p>One common use of the Stieltjes integral is
to find the mean value of a random variable from its
cumulative distribution function <code class="reqn">F(x)</code>. The mean value is
the Stieltjes integral of <code class="reqn">f(x)=x</code> with respect to <code class="reqn">F(x)</code>.
</p>
<p>The argument <code>f</code> should be a <code>function</code> in the <span class="rlang"><b>R</b></span> language.
It should accept a numeric vector argument <code>x</code> and should return
a numeric vector of the same length.
</p>
<p>The argument <code>M</code> should be either a step function
(object of class <code>"stepfun"</code>) or a function value table
(object of class <code>"fv"</code> 
).
Objects of class <code>"stepfun"</code> are returned by
<code><a href="stats.html#topic+ecdf">ecdf</a></code>, <code><a href="#topic+ewcdf">ewcdf</a></code>,

and other utilities.


</p>


<h3>Value</h3>

<p>A list containing the value of the Stieltjes integral
computed using each of the versions of the function <code>M</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  x &lt;- runif(100)
  w &lt;- runif(100)
  H &lt;- ewcdf(x, w)
  stieltjes(function(x) { x^2 }, H)


</code></pre>

<hr>
<h2 id='transformquantiles'>
Transform the Quantiles
</h2><span id='topic+transformquantiles'></span>

<h3>Description</h3>

<p>Apply a transformation to the quantiles of a vector,
or to the quantiles of the pixel values in a pixel image.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>transformquantiles(X, uniform = FALSE, reverse = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="transformquantiles_+3A_x">X</code></td>
<td>

<p>A numeric vector, matrix, array, or a pixel image
(object of class <code>"im"</code>).
</p>
</td></tr>
<tr><td><code id="transformquantiles_+3A_uniform">uniform</code></td>
<td>

<p>Logical value specifying whether each quantile value should be
replaced by the corresponding cumulative probability
(called <em>histogram equalisation</em>, <em>transformation to uniformity</em>
or <em>probability integral transformation</em>).
</p>
</td></tr>
<tr><td><code id="transformquantiles_+3A_reverse">reverse</code></td>
<td>

<p>Logical value specifying whether to swap the
upper and lower quantiles. 
</p>
</td></tr>
<tr><td><code id="transformquantiles_+3A_...">...</code></td>
<td>

<p>Ignored.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The argument <code>X</code> may be a vector, matrix,
array, or a pixel image (object of class <code>"im"</code>).
</p>
<p>The algorithm will first extract the entries or pixel values of
<code>X</code> as a vector, and sort the values into ascending order.
</p>
<p>If <code>uniform=TRUE</code>, the entries in this vector will be replaced by the
corresponding cumulative probabilities (the <code>k</code>th
smallest value will be replaced by the
number <code>(k-0.5)/n</code> where <code>n</code> is the total number of values).
</p>
<p>If <code>reverse=TRUE</code>, the resulting vector will be reversed
so that it is in descending order (so that the <code>k</code>th smallest
value will be swapped with the <code>k</code>th largest value).
</p>
<p>Finally the transformed values will be replaced into the original
positions in the vector, matrix, array, or pixel image.
</p>
<p>The case <code>uniform=TRUE, reverse=FALSE</code> is called
<em>transformation to uniformity</em>, the
<em>probability integral transformation</em>,
<em>histogram equalisation</em>, or <em>quantile transformation</em>.
The resulting values are uniformly distributed between 0 and 1;
a histogram of the values in <code>X</code> is flat.
</p>


<h3>Value</h3>

<p>Another object of the same type as <code>X</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>See Also</h3>

<p>To apply an arbitrary function <code>f</code> to the pixel values in an image,
use the idiom <code>X[] &lt;- f(X[])</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  X &lt;- c(3, 5, 1, 2, 4)
  transformquantiles(X, reverse=TRUE)
  transformquantiles(X, uniform=TRUE)
  transformquantiles(X, uniform=TRUE, reverse=TRUE)

</code></pre>

<hr>
<h2 id='uniquemap.default'>
Map Duplicate Entries to Unique Entries
</h2><span id='topic+uniquemap'></span><span id='topic+uniquemap.default'></span><span id='topic+uniquemap.data.frame'></span><span id='topic+uniquemap.matrix'></span>

<h3>Description</h3>

<p>Determine whether entries in a vector
(or rows in a matrix or data frame)
are duplicated,
choose a unique representative for each set of duplicates,
and map the duplicates to the unique representative.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>uniquemap(x)

## Default S3 method:
uniquemap(x)

## S3 method for class 'data.frame'
uniquemap(x)

## S3 method for class 'matrix'
uniquemap(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="uniquemap.default_+3A_x">x</code></td>
<td>

<p>A vector, data frame or matrix,
or another type of data.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>uniquemap</code> is generic, with methods
for point patterns, data frames, and a default method.
</p>
<p>The default method expects a vector. It determines whether any entries
of the vector <code>x</code> are duplicated,
and constructs a mapping of the indices of <code>x</code>
so that all duplicates are mapped to a unique representative index.
</p>
<p>The result is an integer vector <code>u</code> such that
<code>u[j] = i</code> if
the entries <code>x[i]</code> and <code>x[j]</code> are identical and
point <code>i</code> has been chosen as the unique representative.
The entry <code>u[i] = i</code> means either that point <code>i</code> is
unique, or that it has been chosen as the unique representative
of its equivalence class.
</p>
<p>The method for <code>data.frame</code> determines whether any rows of the
data frame <code>x</code> are duplicated, and constructs a mapping of the
row indices so that all duplicate rows are mapped to a unique
representative row.
</p>


<h3>Value</h3>

<p>An integer vector.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+duplicated">duplicated</a></code>.
</p>
<p><code>uniquemap.ppp</code> in <span class="pkg">spatstat.geom</span>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  x &lt;- c(3, 5, 2, 4, 2, 3)
  uniquemap(x)

  df &lt;- data.frame(A=x, B=42)
  uniquemap(df)

  z &lt;- cbind(x, 10-x)
  uniquemap(z)
</code></pre>

<hr>
<h2 id='unnormdensity'>
Weighted kernel smoother
</h2><span id='topic+unnormdensity'></span>

<h3>Description</h3>

<p>An unnormalised version of kernel density estimation
where the weights are not required to sum to 1.
The weights may be positive, negative or zero.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unnormdensity(x, ..., weights = NULL, defaults)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unnormdensity_+3A_x">x</code></td>
<td>

<p>Numeric vector of data
</p>
</td></tr>
<tr><td><code id="unnormdensity_+3A_...">...</code></td>
<td>

<p>Optional arguments passed to <code><a href="stats.html#topic+density.default">density.default</a></code>.
Arguments must be <em>named</em>.
</p>
</td></tr></table>
<p>'
</p>
<table>
<tr><td><code id="unnormdensity_+3A_weights">weights</code></td>
<td>

<p>Optional numeric vector of weights for the data.
The default is equivalent to assuming a weight of 1 for each observation.
</p>
</td></tr>
<tr><td><code id="unnormdensity_+3A_defaults">defaults</code></td>
<td>

<p>Optional, named list of arguments passed to
<code><a href="stats.html#topic+density.default">density.default</a></code>. These will be overridden by
arguments in <code>...</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is an alternative to the standard <span class="rlang"><b>R</b></span> kernel density estimation function
<code><a href="stats.html#topic+density.default">density.default</a></code>.
</p>
<p>The standard <code><a href="stats.html#topic+density.default">density.default</a></code>
requires the <code>weights</code> to be nonnegative numbers that add up to 1,
and returns a probability density (a function that integrates to 1).
</p>
<p>This function <code>unnormdensity</code> does not impose any requirement
on the <code>weights</code> except that they be finite. Individual weights may be
positive, negative or zero. The result is a function that does not
necessarily integrate to 1 and may be negative. The result is
the convolution of the kernel <code class="reqn">k</code> with the weighted data,
</p>
<p style="text-align: center;"><code class="reqn">
    f(x) = \sum_i w_i k(x- x_i)
  </code>
</p>

<p>where <code class="reqn">x_i</code> are the data points and <code class="reqn">w_i</code> are the
weights.
</p>
<p>The argument <code>weights</code> should be a numeric vector of the same
length as <code>x</code>, or a single numeric value. The default is to
assume a weight of 1 for each observation in <code>x</code>.
</p>
<p>The algorithm first selects the kernel bandwidth by
applying <code><a href="stats.html#topic+density.default">density.default</a></code> to the data
<code>x</code> with normalised, positive weight vector
<code>w = abs(weights)/sum(abs(weights))</code> and
extracting the selected bandwidth.
Then the result is computed by applying
applying <code><a href="stats.html#topic+density.default">density.default</a></code> to <code>x</code> twice
using the normalised positive and negative parts of the weights.
</p>
<p>Note that the arguments <code>...</code> must be passed by name,
i.e. in the form (<code>name=value</code>). Arguments that do not match
an argument of <code><a href="stats.html#topic+density.default">density.default</a></code> will be ignored
<em>silently</em>.
</p>


<h3>Value</h3>

<p>Object of class <code>"density"</code> as described in
<code><a href="stats.html#topic+density.default">density.default</a></code>.
</p>


<h3>Warning</h3>

<p>If <code>weights</code> is not specified,
the default is to assign a weight <code class="reqn">w_i=1</code> to each
observation <code class="reqn">x_i</code>.
</p>
<p>This is not the same behaviour as in <code><a href="stats.html#topic+density.default">density.default</a></code> which
effectively assumes a weight of <code class="reqn">1/n</code> for each observation <code class="reqn">x_i</code>
where <code>n=length(x)</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+density.default">density.default</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  d &lt;- unnormdensity(1:3, weights=c(-1,0,1), bw=0.3)
  if(interactive()) plot(d)
</code></pre>

<hr>
<h2 id='weighted.median'>
Weighted Median, Quantiles or Variance
</h2><span id='topic+weighted.median'></span><span id='topic+weighted.quantile'></span><span id='topic+weighted.var'></span>

<h3>Description</h3>

<p>Compute the median, quantiles or variance of a set of numbers which have
weights associated with them.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>weighted.median(x, w, na.rm = TRUE, type=2, collapse=TRUE)

weighted.quantile(x, w, probs=seq(0,1,0.25), na.rm = TRUE, type=4, collapse=TRUE)

weighted.var(x, w, na.rm = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="weighted.median_+3A_x">x</code></td>
<td>

<p>Data values.
A vector of numeric values, for which the median or quantiles are required.
</p>
</td></tr>
<tr><td><code id="weighted.median_+3A_w">w</code></td>
<td>

<p>Weights.
A vector of nonnegative numbers, of the same length as <code>x</code>.
</p>
</td></tr>
<tr><td><code id="weighted.median_+3A_probs">probs</code></td>
<td>

<p>Probabilities for which the quantiles should be computed.
A numeric vector of values between 0 and 1.
</p>
</td></tr>
<tr><td><code id="weighted.median_+3A_na.rm">na.rm</code></td>
<td>

<p>Logical. Whether to ignore <code>NA</code> values.
</p>
</td></tr>
<tr><td><code id="weighted.median_+3A_type">type</code></td>
<td>

<p>Integer specifying the rule for calculating the median or quantile,
corresponding to the rules available for
<code><a href="stats.html#topic+quantile">quantile</a></code>.
The only valid choices are <code>type=1</code>, <code>2</code> or <code>4</code>.
See Details.
</p>
</td></tr>
<tr><td><code id="weighted.median_+3A_collapse">collapse</code></td>
<td>
<p>Research use only.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>i</code>th observation <code>x[i]</code> is treated as having
a weight proportional to <code>w[i]</code>.
</p>
<p>The weighted median is a value <code>m</code>
such that the total weight of data less than or equal to <code>m</code>
is equal to half the total weight. More generally, the weighted quantile with
probability <code>p</code> is a value <code>q</code> 
such that the total weight of data less than or equal to <code>q</code>
is equal to <code>p</code> times the total weight.
</p>
<p>If there is no such value, then
</p>

<ul>
<li><p> if <code>type=1</code>, the next largest value is returned
(this is the right-continuous inverse of the left-continuous
cumulative distribution function);
</p>
</li>
<li><p> if <code>type=2</code>, the average of the two surrounding values is
returned (the average of the right-continuous and left-continuous
inverses);
</p>
</li>
<li><p> if <code>type=4</code>, linear interpolation is performed.
</p>
</li></ul>

<p>Note that the default rule for <code>weighted.median</code> is
<code>type=2</code>, consistent with the traditional definition of the median, 
while the default for <code>weighted.quantile</code> is <code>type=4</code>.
</p>


<h3>Value</h3>

<p>A numeric value or vector.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+quantile">quantile</a></code>, <code><a href="stats.html#topic+median">median</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  x &lt;- 1:20
  w &lt;- runif(20)
  weighted.median(x, w)
  weighted.quantile(x, w)
  weighted.var(x, w)
</code></pre>

<hr>
<h2 id='whist'>
Weighted Histogram
</h2><span id='topic+whist'></span>

<h3>Description</h3>

<p>Computes the weighted histogram of a set of observations
with a given set of weights.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>whist(x, breaks, weights = NULL, method=c("C", "interpreted"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="whist_+3A_x">x</code></td>
<td>

<p>Numeric vector of observed values.
</p>
</td></tr>
<tr><td><code id="whist_+3A_breaks">breaks</code></td>
<td>

<p>Vector of breakpoints for the histogram. 
</p>
</td></tr>
<tr><td><code id="whist_+3A_weights">weights</code></td>
<td>

<p>Numeric vector of weights for the observed values. 
</p>
</td></tr>
<tr><td><code id="whist_+3A_method">method</code></td>
<td>

<p>Developer use only.
A character string specifying whether to use internal C code
(<code>method="C"</code>, the default) or interpreted <span class="rlang"><b>R</b></span> code
(<code>method="interpreted"</code>). 
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This low-level function computes (but does not plot) the weighted
histogram of a vector of observations <code>x</code> using a given
vector of <code>weights</code>.
</p>
<p>The arguments <code>x</code> and <code>weights</code> should be numeric vectors of
equal length. They may include <code>NA</code> or infinite values.
</p>
<p>The argument <code>breaks</code> should be a numeric vector whose entries
are strictly increasing. These values define the boundaries between the
successive histogram cells.
The breaks <em>do not</em> have to span the range
of the observations.
</p>
<p>There are <code>N-1</code> histogram cells, where <code>N = length(breaks)</code>.
An observation <code>x[i]</code> falls in the <code>j</code>th cell if
<code>breaks[j] &lt;= x[i] &lt; breaks[j+1]</code> (for <code>j &lt; N-1</code>)
or
<code>breaks[j] &lt;= x[i] &lt;= breaks[j+1]</code> (for <code>j = N-1</code>).
The weighted histogram value <code>h[j]</code> for the <code>j</code>th cell is
the sum of <code>weights[i]</code> for all observations <code>x[i]</code> that
fall in the cell.
</p>
<p>Note that, in contrast to the function <code><a href="graphics.html#topic+hist">hist</a></code>,
the function <code>whist</code> does not require the breakpoints to span the
range of the observations <code>x</code>. Values of <code>x</code> that fall outside the
range of <code>breaks</code> are handled separately; their total weight
is returned as an attribute of the histogram. 
</p>


<h3>Value</h3>

<p>A numeric vector of length <code>N-1</code> containing the
histogram values, where <code>N = length(breaks)</code>.
</p>
<p>The return value also has attributes <code>"low"</code> and <code>"high"</code>
giving the total weight of all observations that are less than
the lowest breakpoint, or greater than the highest breakpoint,
respectively.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>
<p>with thanks to Peter Dalgaard.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  x &lt;- rnorm(100)
  b &lt;- seq(-1,1,length=21)
  w &lt;- runif(100)
  whist(x,b,w)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
