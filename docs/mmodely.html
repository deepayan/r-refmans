<!DOCTYPE html><html><head><title>Help for package mmodely</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {mmodely}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#average.fit.models'><p>Calculate a weighted average of pglm</p></a></li>
<li><a href='#calc.q2n.ratio'><p>Calculate the ratio of fit predictor variables to sample size</p></a></li>
<li><a href='#cept'><p>Include all variables except ...</p></a></li>
<li><a href='#comp.data'><p>Comparative Data</p></a></li>
<li><a href='#compare.data.gs.vs.tree.tips'><p>Find data being dropped by mismatches to the tree</p></a></li>
<li><a href='#correct.AIC'><p>Correct AIC</p></a></li>
<li><a href='#count.mod.vars'><p>Count the predictor variables in a model</p></a></li>
<li><a href='#ct.possible.models'><p>Count all possible model combinations</p></a></li>
<li><a href='#drop.na.data'><p>Drop any rows with NA values</p></a></li>
<li><a href='#fit.1ln.rprt'><p>Report a model fit in a single line of text output</p></a></li>
<li><a href='#get.mod.clmns'><p>Get model columns</p></a></li>
<li><a href='#get.mod.outcome'><p>Get the outcome variable from a model string</p></a></li>
<li><a href='#get.mod.vars'><p>Get model variable names</p></a></li>
<li><a href='#get.model.combos'><p>All combinations of predictor variables</p></a></li>
<li><a href='#get.pgls.coefs'><p>Get coeficients from a list of PGLS model-fits (from each selected subset)</p></a></li>
<li><a href='#get.phylo.stats'><p>Get tree statistics for a trait</p></a></li>
<li><a href='#gs.check'><p>Check &quot;Genus species&quot; name formatting</p></a></li>
<li><a href='#gs.names.mismatch.check'><p>Check &quot;Genus species&quot; name formatting</p></a></li>
<li><a href='#gs.rename'><p>Rename the Genus species information in a data frame</p></a></li>
<li><a href='#interpolate'><p>Interpolate missing data in a data frame</p></a></li>
<li><a href='#missing.data'><p>Report missing values in a dataframe</p></a></li>
<li><a href='#missing.fill.in'><p>Fill in missing values in a dataframe with a secondary source</p></a></li>
<li><a href='#pgls.iter'><p>Iterate through PGLS estimations</p></a></li>
<li><a href='#pgls.iter.stats'><p>Statistics from PGLS runs</p></a></li>
<li><a href='#pgls.print'><p>Print the results of a PGLS model fit</p></a></li>
<li><a href='#pgls.report'><p>Report PGLS results as a table</p></a></li>
<li><a href='#pgls.wrap'><p>A Wrapper for PGLS model</p></a></li>
<li><a href='#plot.confound.grid'><p>Plot a grid of x y plots split by a confounder z</p></a></li>
<li><a href='#plot.pgls.iters'><p>Plot the PGLS iterations</p></a></li>
<li><a href='#plot.pgls.R2AIC'><p>Plot (R2 vs AIC) results of a collection of fit PGLS models</p></a></li>
<li><a href='#plot.transformed.phylo'><p>Plot a transformed phylogenetic tree</p></a></li>
<li><a href='#plot.xy.ab.p'><p>An x/y scatterplot with a linear regression line and p-value</p></a></li>
<li><a href='#select.best.models'><p>Get the best model from list of PGLS model fits</p></a></li>
<li><a href='#sparge.modsel'><p>Coeficients distribution [sparge] plot of models selected from each subset</p></a></li>
<li><a href='#trim.phylo'><p>Trim a phylogenetic tree using Genus species names</p></a></li>
<li><a href='#weight.IC'><p>Get IC weights</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>0.2.5</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-05-05</td>
</tr>
<tr>
<td>Title:</td>
<td>Modeling Multivariate Origins Determinants - Evolutionary
Lineages in Ecology</td>
</tr>
<tr>
<td>Author:</td>
<td>David M Schruth</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>David M Schruth &lt;dschruth@anthropoidea.org&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.0.0),caper</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, caroline, ape</td>
</tr>
<tr>
<td>Description:</td>
<td>
 Perform multivariate modeling of evolved traits, with special attention to
 understanding the interplay of the multi-factorial determinants of their origins
 in complex ecological settings (Stephens, 2007 &lt;<a href="https://doi.org/10.1016%2Fj.tree.2006.12.003">doi:10.1016/j.tree.2006.12.003</a>&gt;).
 This software primarily concentrates on phylogenetic regression analysis, enabling
 implementation of tree transformation averaging and visualization functionality.
 Functions additionally support information theoretic approaches
 (Grueber, 2011 &lt;<a href="https://doi.org/10.1111%2Fj.1420-9101.2010.02210.x">doi:10.1111/j.1420-9101.2010.02210.x</a>&gt;;
 Garamszegi, 2011 &lt;<a href="https://doi.org/10.1007%2Fs00265-010-1028-7">doi:10.1007/s00265-010-1028-7</a>&gt;)
 such as  model averaging and selection of phylogenetic models.
 Accessory functions are also implemented for coef standardization (Cade 2015), 
 selection uncertainty, and variable importance (Burnham &amp; Anderson 2000).
 There are other numerous functions for visualizing confounded variables,
 plotting phylogenetic trees, as well as reporting and exporting modeling results.
 Lastly, as challenges to ecology are inherently multifarious, and therefore often
 multi-dataset, this package features several functions to support the identification,
 interpolation, merging, and updating of missing data and outdated nomenclature.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.apache.org/LICENSE-1.1">Apache License version 1.1</a> | <a href="https://www.apache.org/licenses/LICENSE-2.0">Apache License version 2.0</a> [expanded from: Apache License]</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-05-17 00:40:29 UTC; mint</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-05-17 07:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='average.fit.models'>Calculate a weighted average of pglm</h2><span id='topic+average.fit.models'></span><span id='topic+variable.importance'></span>

<h3>Description</h3>

<p>These function takes the output of pgls.iter and uses its list of objects  model fits, optimzations (e.g.AICc) and performs a weighted average on the ctoefficients estimated in the former by weighting by the latter. The parameters can also optionally be converted to binary by specifying &quot;binary=FALSE&quot; or just running the alias wraper function for assessing evidence of variable importance (Burnham &amp; Anderson 2000).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>average.fit.models(vars, fits, optims,weight='AICw',
         by=c('n','q','nXq','rwGsm')[1], round.digits=5, binary=FALSE, standardize=FALSE)
variable.importance(vars, fits, optims,weight='AICw',
         by=c('n','q','nXq','rwGsm')[1], round.digits=5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="average.fit.models_+3A_vars">vars</code></td>
<td>
<p>variable names of model</p>
</td></tr>
<tr><td><code id="average.fit.models_+3A_fits">fits</code></td>
<td>
<p>a list of PGLS model fits</p>
</td></tr>
<tr><td><code id="average.fit.models_+3A_optims">optims</code></td>
<td>
<p>a list of PGLS optimization paramters (should include &quot;AICw&quot;)</p>
</td></tr>
<tr><td><code id="average.fit.models_+3A_weight">weight</code></td>
<td>
<p>a column name in the optims that specifies the weights to be used in the average</p>
</td></tr>
<tr><td><code id="average.fit.models_+3A_by">by</code></td>
<td>
<p>unique identifier used to group sub-datasets for reporting (defaults to n) </p>
</td></tr>
<tr><td><code id="average.fit.models_+3A_round.digits">round.digits</code></td>
<td>
<p>the tnumber of decimal places of the resultant mean to ouput</p>
</td></tr>
<tr><td><code id="average.fit.models_+3A_binary">binary</code></td>
<td>
<p>converts all parameters to binary for presense or absense to calculate 'importance'</p>
</td></tr>
<tr><td><code id="average.fit.models_+3A_standardize">standardize</code></td>
<td>
<p>standardize the coefficient estimates by partial standard deviations, according to Cade (2015)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of AICc difference weighted [AICw] averages of PGLS coefficients.
Also returns model 'selection' errors or the square root of 'uncertainties' (Burnham &amp; Anderson 2000) 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data.path &lt;- system.file("extdata","primate-example.data.csv", package="mmodely")
data &lt;- read.csv(data.path, row.names=1)
pvs &lt;- names(data[3:5])
data$gn_sp &lt;- rownames(data)

tree.path &lt;- system.file("extdata","primate-springer.2012.tre", package="mmodely")
phyl &lt;- ape::read.tree(tree.path)[[5]]

comp &lt;- comp.data(phylo=phyl, df=data)

mods &lt;- get.model.combos(predictor.vars=pvs, outcome.var='OC', min.q=2)

PGLSi &lt;- pgls.iter(models=mods, phylo=phyl, df=data, k=1,l=1,d=1) 

average.fit.models(vars=c('mass.Kg','group.size'), fits=PGLSi$fits, optims=PGLSi$optim)
variable.importance(vars=c('mass.Kg','group.size'), fits=PGLSi$fits, optims=PGLSi$optim)

</code></pre>

<hr>
<h2 id='calc.q2n.ratio'>Calculate the ratio of fit predictor variables to sample size</h2><span id='topic+calc.q2n.ratio'></span>

<h3>Description</h3>

<p>The one in ten rule of thumb for model fitting suggest at least 10 fold as many data as parametes fit. This function allows for easily calculating that ratio on model selected PGLS fits.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc.q2n.ratio(coefs)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calc.q2n.ratio_+3A_coefs">coefs</code></td>
<td>
<p>a list of coefficients extracted from fit PGLS models</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the ratio of q to n (on average for all extracted fit models) 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data.path &lt;- system.file("extdata","primate-example.data.csv", package="mmodely")
data &lt;- read.csv(data.path, row.names=1)
pvs &lt;- names(data[3:5])
data$gn_sp &lt;- rownames(data)

tree.path &lt;- system.file("extdata","primate-springer.2012.tre", package="mmodely")
phyl &lt;- ape::read.tree(tree.path)[[5]]

comp &lt;- comp.data(phylo=phyl, df=data)

mods &lt;- get.model.combos(predictor.vars=pvs, outcome.var='OC', min.q=2)

PGLSi &lt;- pgls.iter(models=mods, phylo=phyl, df=data, k=1,l=1,d=1) 

coefs.objs &lt;- get.pgls.coefs(PGLSi$fits, est='Estimate')

calc.q2n.ratio(coefs.objs)

</code></pre>

<hr>
<h2 id='cept'>Include all variables except ...</h2><span id='topic+cept'></span>

<h3>Description</h3>

<p>This function takes a dataframe, list, or a named vector of variable (column) names to subset
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cept(x,except='gn_sp')
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cept_+3A_x">x</code></td>
<td>
<p>a dataframe, list, or named vector</p>
</td></tr>
<tr><td><code id="cept_+3A_except">except</code></td>
<td>
<p>a vector of the names of the items in x to exclude</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the subset of x without those 'except' items specified
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data.path &lt;- system.file("extdata","primate-example.data.csv", package="mmodely")
data &lt;- read.csv(data.path, row.names=1)

df.except.gnsp &lt;- cept(x=data,except='gn_sp')

</code></pre>

<hr>
<h2 id='comp.data'>Comparative Data</h2><span id='topic+comp.data'></span>

<h3>Description</h3>

<p>This is a shortcut function that wraps around &quot;comparative.data&quot; for use in the PGLS function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>comp.data(phylo,df,gn_sp='gn_sp')
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="comp.data_+3A_phylo">phylo</code></td>
<td>
<p>a tre file of the format phylo</p>
</td></tr>
<tr><td><code id="comp.data_+3A_df">df</code></td>
<td>
<p>a data.frame with row names matching number and tip labels of 'tree'</p>
</td></tr>
<tr><td><code id="comp.data_+3A_gn_sp">gn_sp</code></td>
<td>
<p>the column name (e.g. &quot;gn_sp&quot;) that indicates how to match df with tree</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a &quot;comparative data&quot; table for use in PGLS modeling
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data.path &lt;- system.file("extdata","primate-example.data.csv", package="mmodely")
data &lt;- read.csv(data.path, row.names=1)
pvs &lt;- names(data[3:5])
data$gn_sp &lt;- rownames(data)

tree.path &lt;- system.file("extdata","primate-springer.2012.tre", package="mmodely")
phyl &lt;- ape::read.tree(tree.path)[[5]]

comp &lt;- comp.data(phylo=phyl, df=data)


</code></pre>

<hr>
<h2 id='compare.data.gs.vs.tree.tips'>Find data being dropped by mismatches to the tree</h2><span id='topic+compare.data.gs.vs.tree.tips'></span>

<h3>Description</h3>

<p>This function simply lists the rows of the data that are not getting matched to tips of the tree.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compare.data.gs.vs.tree.tips(data, phylo, match.on=c('gn_sp','rownames')[1])
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compare.data.gs.vs.tree.tips_+3A_data">data</code></td>
<td>
<p>a data frame with genus species information as row names and a column named &quot;gn_sp&quot; </p>
</td></tr>
<tr><td><code id="compare.data.gs.vs.tree.tips_+3A_phylo">phylo</code></td>
<td>
<p>a phylogenetic tree with labeled tip</p>
</td></tr>
<tr><td><code id="compare.data.gs.vs.tree.tips_+3A_match.on">match.on</code></td>
<td>
<p>use a character string specifiying where the 'Genus_species' vector lies</p>
</td></tr>
</table>


<h3>Value</h3>

<p>prints rows that are not matched ot the tree tips
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data.path &lt;- system.file("extdata","primate-example.data.csv", package="mmodely")
data &lt;- read.csv(data.path, row.names=1)
data$gn_sp &lt;- rownames(data)

tree.path &lt;- system.file("extdata","primate-springer.2012.tre", package="mmodely")
phyl &lt;- ape::read.tree(tree.path)[[5]]


compare.data.gs.vs.tree.tips(data, phyl, match.on='rownames')

</code></pre>

<hr>
<h2 id='correct.AIC'>Correct AIC</h2><span id='topic+correct.AIC'></span>

<h3>Description</h3>

<p>Calculate a corrected Akaiki Information Criterion 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>correct.AIC(AIC, K,n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="correct.AIC_+3A_aic">AIC</code></td>
<td>
<p>a vector of AIC values</p>
</td></tr>
<tr><td><code id="correct.AIC_+3A_k">K</code></td>
<td>
<p>number of parameters</p>
</td></tr>
<tr><td><code id="correct.AIC_+3A_n">n</code></td>
<td>
<p>number of data</p>
</td></tr>
</table>


<h3>Value</h3>

<p>corrected AIC values
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
correct.AIC(AIC=100,K=10,n=100)

</code></pre>

<hr>
<h2 id='count.mod.vars'>Count the predictor variables in a model</h2><span id='topic+count.mod.vars'></span>

<h3>Description</h3>

<p>This function takes a model string and counts the number of predictor variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>count.mod.vars(model)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="count.mod.vars_+3A_model">model</code></td>
<td>
<p>model specified as a string in the form &quot;y ~ x1 + x2 ...&quot;</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an integer specifying the count of predictor variables
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
count &lt;- count.mod.vars(model=formula('y ~ x1 + x2'))
if(count == 2) { print('sane'); }else{ print('insane')} 

</code></pre>

<hr>
<h2 id='ct.possible.models'>Count all possible model combinations</h2><span id='topic+ct.possible.models'></span>

<h3>Description</h3>

<p>Count all combinations of predictor variables in a multivariate regression model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ct.possible.models(q)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ct.possible.models_+3A_q">q</code></td>
<td>
<p>number of predictor variables</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a count of the number of possible models
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
ct.possible.models(9)

</code></pre>

<hr>
<h2 id='drop.na.data'>Drop any rows with NA values</h2><span id='topic+drop.na.data'></span>

<h3>Description</h3>

<p>This function takes a dataframe as input and removes any rows that have NA as values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>drop.na.data(df, vars=names(df))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="drop.na.data_+3A_df">df</code></td>
<td>
<p>a dataframe</p>
</td></tr>
<tr><td><code id="drop.na.data_+3A_vars">vars</code></td>
<td>
<p>sub set of variable (column) names to use in searching for missing values</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A subset of 'df' that only has non-missing values in the columns specified by 'vars'
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
path &lt;- system.file("extdata","primate-example.data.csv", package="mmodely")
data &lt;- read.csv(path, row.names=1)

df.nona &lt;- drop.na.data(data, vars=names(df))


</code></pre>

<hr>
<h2 id='fit.1ln.rprt'>Report a model fit in a single line of text output</h2><span id='topic+fit.1ln.rprt'></span>

<h3>Description</h3>

<p>This function takes a fit multivariate regression model as input and converts the normal tabular output into a single line using repeated &quot;+&quot;or&quot;-&quot; symbols for significance
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit.1ln.rprt(fit, method=c('std.dev','p-value')[1], decimal.places=3, 
             name.char.len=6, print.inline=TRUE, rtrn.line=FALSE, R2AIC=TRUE,mn='')
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fit.1ln.rprt_+3A_fit">fit</code></td>
<td>
<p>a fit model</p>
</td></tr>
<tr><td><code id="fit.1ln.rprt_+3A_method">method</code></td>
<td>
<p>how to calculate the number of pluses or minuses before each coefficient name (default is standard deviations)</p>
</td></tr>
<tr><td><code id="fit.1ln.rprt_+3A_decimal.places">decimal.places</code></td>
<td>
<p>the number of decimal places to use in reporting p-values</p>
</td></tr>
<tr><td><code id="fit.1ln.rprt_+3A_name.char.len">name.char.len</code></td>
<td>
<p>the maximum length to use when truncating variable names</p>
</td></tr>
<tr><td><code id="fit.1ln.rprt_+3A_r2aic">R2AIC</code></td>
<td>
<p>boolean for also returning/printing AIC and R^2 values</p>
</td></tr>
<tr><td><code id="fit.1ln.rprt_+3A_print.inline">print.inline</code></td>
<td>
<p>should the outout string be printed to the terminal?</p>
</td></tr>
<tr><td><code id="fit.1ln.rprt_+3A_rtrn.line">rtrn.line</code></td>
<td>
<p>should the output string be returned as a characters string?</p>
</td></tr>
<tr><td><code id="fit.1ln.rprt_+3A_mn">mn</code></td>
<td>
<p>model number prefixed to printout if 'print.inline' is TRUE</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character string of the form &quot;++var1 +var5 var3 | -var2 &ndash;var4&quot; indicating signifcance and direction of regression results
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
path &lt;- system.file("extdata","primate-example.data.csv", package="mmodely")
data &lt;- read.csv(path, row.names=1)

model.fit &lt;- lm('OC ~ mass.Kg + group.size + arboreal + leap.pct', data=data)

fit.1ln.rprt(fit=model.fit, decimal.places=3, name.char.len=6, print.inline=TRUE, rtrn.line=FALSE)

</code></pre>

<hr>
<h2 id='get.mod.clmns'>Get model columns</h2><span id='topic+get.mod.clmns'></span>

<h3>Description</h3>

<p>Get the variable names from a model string by splitting on &quot;+&quot; and '~' using both 'get.mod.outcome' and 'get.mod.vars'. The results are passed to the comp.data function for eventual use in PGLS modeling. 'gn_sp' is included as it is typically required to link tree tips to rows of the comparative data. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.mod.clmns(model, gs.clmn='gn_sp')
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.mod.clmns_+3A_model">model</code></td>
<td>
<p>a model string of the form &quot;y ~ x1 + x2 ...&quot;</p>
</td></tr>
<tr><td><code id="get.mod.clmns_+3A_gs.clmn">gs.clmn</code></td>
<td>
<p>the column header for the vector of &quot;Genus_species&quot; names, to link a tree tips to rows</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of characters enummerating the columns to retain in PGLS modeling (input to df param in the 'comp.data' function)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
model.columns &lt;- get.mod.clmns(model=formula('y ~ x1 + x2'))

</code></pre>

<hr>
<h2 id='get.mod.outcome'>Get the outcome variable from a model string</h2><span id='topic+get.mod.outcome'></span>

<h3>Description</h3>

<p>Get the outcome variable from the front of a model formula string. Used as part of 'get.mod.clmns' to be passed to 'comp.data'
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.mod.outcome(model)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.mod.outcome_+3A_model">model</code></td>
<td>
<p>a character string of a formula of the form 'y ~ x1 + x2 ...'</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a character string specifying the outcome variable
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
model.columns &lt;- get.mod.clmns(model=formula('y ~ x1 + x2'))

</code></pre>

<hr>
<h2 id='get.mod.vars'>Get model variable names</h2><span id='topic+get.mod.vars'></span>

<h3>Description</h3>

<p>Split the predictor string of a model formula into it's constituent character strings.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.mod.vars(model)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.mod.vars_+3A_model">model</code></td>
<td>
<p>a character string of a formula of the form 'y ~ x1 + x2'</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of character strings of variable names (e.g. corresponding to column names for comp.data input)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
model.variables &lt;- get.mod.vars(model='y ~ x1 + x2')

</code></pre>

<hr>
<h2 id='get.model.combos'>All combinations of predictor variables</h2><span id='topic+get.model.combos'></span>

<h3>Description</h3>

<p>Enumerate all combinations of predictor variables in a multivariate regression model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.model.combos(outcome.var, predictor.vars, min.q=1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.model.combos_+3A_predictor.vars">predictor.vars</code></td>
<td>
<p>predictor variables names (a vector of character strings)</p>
</td></tr>
<tr><td><code id="get.model.combos_+3A_outcome.var">outcome.var</code></td>
<td>
<p>outcome variable name (character string)</p>
</td></tr>
<tr><td><code id="get.model.combos_+3A_min.q">min.q</code></td>
<td>
<p>minimum number of predictor variables to include in the mode (default is 2) </p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of models as character strings of the form &quot;y ~ x1 + x2 ...&quot;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
path &lt;- system.file("extdata","primate-example.data.csv", package="mmodely")
data &lt;- read.csv(path, row.names=1)

get.model.combos(outcome.var='OC', predictor.vars=names(data),  min.q=2)

</code></pre>

<hr>
<h2 id='get.pgls.coefs'>Get coeficients from a list of PGLS model-fits (from each selected subset)</h2><span id='topic+get.pgls.coefs'></span>

<h3>Description</h3>

<p>Post PGLS model selection, the list of all possible PGLS model fits can be subset and passed to this function, which harvests out the coefficients or t-values for each model into bins for the coefficients
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.pgls.coefs(pgls.fits, est=c("t value","Estimate","Pr(&gt;|t|)")[1])
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.pgls.coefs_+3A_pgls.fits">pgls.fits</code></td>
<td>
<p>a list of PGLS models output from 'pgls' or 'pgls.report' </p>
</td></tr>
<tr><td><code id="get.pgls.coefs_+3A_est">est</code></td>
<td>
<p>a character string indicating if Estimate or t value should be used as data points in the plot, default is 'Estimate'</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of PGLS coeficients (lists of estimates and t-values) organized by coeficient-named bins
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data.path &lt;- system.file("extdata","primate-example.data.csv", package="mmodely")
data &lt;- read.csv(data.path, row.names=1)
pvs &lt;- names(data[3:5])
data$gn_sp &lt;- rownames(data)

tree.path &lt;- system.file("extdata","primate-springer.2012.tre", package="mmodely")
phyl &lt;- ape::read.tree(tree.path)[[5]]

comp &lt;- comp.data(phylo=phyl, df=data)

mods &lt;- get.model.combos(predictor.vars=pvs, outcome.var='OC', min.q=2)

PGLSi &lt;- pgls.iter(models=mods, phylo=phyl, df=data, k=1,l=1,d=1) 

coefs.objs &lt;- get.pgls.coefs(PGLSi$fits, est='Estimate')

</code></pre>

<hr>
<h2 id='get.phylo.stats'>Get tree statistics for a trait</h2><span id='topic+get.phylo.stats'></span>

<h3>Description</h3>

<p>This function uses Pagel's lambda, Blombergs k, and Ancestral Character Estimation [ACE] to calculate statistics on a tree given a specified trait.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.phylo.stats(phylo, data, trait.clmn, gs.clmn='gn_sp', 
                ace.method='REML',ace.scaled=TRUE, ace.kappa=1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.phylo.stats_+3A_phylo">phylo</code></td>
<td>
<p>PARAMDESCRIPTION</p>
</td></tr>
<tr><td><code id="get.phylo.stats_+3A_data">data</code></td>
<td>
<p>PARAMDESCRIPTION</p>
</td></tr>
<tr><td><code id="get.phylo.stats_+3A_trait.clmn">trait.clmn</code></td>
<td>
<p>PARAMDESCRIPTION</p>
</td></tr>
<tr><td><code id="get.phylo.stats_+3A_gs.clmn">gs.clmn</code></td>
<td>
<p>PARAMDESCRIPTION</p>
</td></tr>
<tr><td><code id="get.phylo.stats_+3A_ace.method">ace.method</code></td>
<td>
<p>PARAMDESCRIPTION</p>
</td></tr>
<tr><td><code id="get.phylo.stats_+3A_ace.scaled">ace.scaled</code></td>
<td>
<p>PARAMDESCRIPTION</p>
</td></tr>
<tr><td><code id="get.phylo.stats_+3A_ace.kappa">ace.kappa</code></td>
<td>
<p>PARAMDESCRIPTION</p>
</td></tr>
</table>


<h3>Value</h3>

<p>statistics on a particular trait within a tree (Pagel's lambda, Blomberg's  k, and the most ancestral ACE estimate) 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data.path &lt;- system.file("extdata","primate-example.data.csv", package="mmodely")
data &lt;- read.csv(data.path, row.names=1)

data$gn_sp &lt;- rownames(data)

tree.path &lt;- system.file("extdata","primate-springer.2012.tre", package="mmodely")
phyl &lt;- ape::read.tree(tree.path)[[5]]

get.phylo.stats(phylo=phyl, data=data, trait.clmn='OC', 
        gs.clmn='gn_sp', ace.method='REML',ace.scaled=TRUE, ace.kappa=1)

</code></pre>

<hr>
<h2 id='gs.check'>Check &quot;Genus species&quot; name formatting</h2><span id='topic+gs.check'></span>

<h3>Description</h3>

<p>This convienience function checks to make sure that all of the elements the provided character vector adhere to the &quot;Genus species&quot; naming convention format. Default delimiters between genus and species names in the string are &quot; &quot;, &quot;_&quot;, or &quot;.&quot; 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gs.check(genus.species, sep='[ _\\.]')
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gs.check_+3A_genus.species">genus.species</code></td>
<td>
<p>a vector of character strings specifiying the combination of Genus [and] species</p>
</td></tr>
<tr><td><code id="gs.check_+3A_sep">sep</code></td>
<td>
<p>a regular expression between genus and species</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
path &lt;- system.file("extdata","primate-example.data.csv", package="mmodely")
gs.tab &lt;- read.csv(path, row.names=1)
gs.tab$gn_sp &lt;- rownames(gs.tab)

gs.check(genus.species=gs.tab$gn_sp, sep='[ _\\.]')

</code></pre>

<hr>
<h2 id='gs.names.mismatch.check'>Check &quot;Genus species&quot; name formatting</h2><span id='topic+gs.names.mismatch.check'></span>

<h3>Description</h3>

<p>This convienience function checks to make sure that all of the elements the provided character vector adhere to the &quot;Genus species&quot; naming convention format. Default delimiters between genus and species names in the string are &quot; &quot;, &quot;_&quot;, or &quot;.&quot; 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gs.names.mismatch.check(df, alias.table.path, gs.clmn='gn_sp')
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gs.names.mismatch.check_+3A_df">df</code></td>
<td>
<p>a data frame with genus species information as row names and optionally in a column named &quot;gn_sp&quot; </p>
</td></tr>
<tr><td><code id="gs.names.mismatch.check_+3A_alias.table.path">alias.table.path</code></td>
<td>
<p>a file system path (e.g. 'inst/extdata/primate.taxa.aliases.tab') to a lookup table with 'old.name' and 'new.name' as columns</p>
</td></tr>
<tr><td><code id="gs.names.mismatch.check_+3A_gs.clmn">gs.clmn</code></td>
<td>
<p>the name of the column containing the 'Genus_species' vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
path &lt;- system.file("extdata","primate-example.data.csv", package="mmodely")
gs.tab &lt;- read.csv(path, row.names=1)
gs.tab$gn_sp &lt;- rownames(gs.tab)

path.look &lt;- system.file("extdata","primate.taxa.aliases.tab", package="mmodely")

gs.names.mismatch.check(gs.tab, alias.table.path=path.look, gs.clmn='gn_sp')

</code></pre>

<hr>
<h2 id='gs.rename'>Rename the Genus species information in a data frame</h2><span id='topic+gs.rename'></span>

<h3>Description</h3>

<p>This function takes a data frame (with a genus species column) and proceeds to use an external look-up table to update the names if they've been changed
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gs.rename(df, alias.table.path, retro=FALSE, update.gn_sp=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gs.rename_+3A_df">df</code></td>
<td>
<p>a data frame with genus species information as row names and optionally in a column named &quot;gn_sp&quot; </p>
</td></tr>
<tr><td><code id="gs.rename_+3A_alias.table.path">alias.table.path</code></td>
<td>
<p>a file system path (e.g. 'inst/extdata/primate.taxa.aliases.tab') to a lookup table with 'old.name' and 'new.name' as columns</p>
</td></tr>
<tr><td><code id="gs.rename_+3A_retro">retro</code></td>
<td>
<p>a boolean (T/F) parameter specifying if the renaming should go from new to old instead of the default of old to new</p>
</td></tr>
<tr><td><code id="gs.rename_+3A_update.gn_sp">update.gn_sp</code></td>
<td>
<p>a boolean parameter specifying if the 'gn_sp' column should also be updated with 'new.name's</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the original data frame with (potentially) updated row names and updated gn_sp column values
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
path.data &lt;- system.file("extdata","primate-example.data.csv", package="mmodely")
data &lt;- read.csv(path.data, row.names=1)

path.look &lt;- system.file("extdata","primate.taxa.aliases.tab", package="mmodely")

data.renamed &lt;- gs.rename(df=data, alias.table.path=path.look, retro=FALSE, update.gn_sp=FALSE)

</code></pre>

<hr>
<h2 id='interpolate'>Interpolate missing data in a data frame</h2><span id='topic+interpolate'></span>

<h3>Description</h3>

<p>This function finds NA values and interpolates using averaging values of nearby genus and species  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>interpolate(df, taxa=c('genus','family'), clmns=1:length(df))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="interpolate_+3A_df">df</code></td>
<td>
<p>a data frame</p>
</td></tr>
<tr><td><code id="interpolate_+3A_taxa">taxa</code></td>
<td>
<p>a vector of taxonomic ranks (corresonding to columns) to assist in guiding the interpolating</p>
</td></tr>
<tr><td><code id="interpolate_+3A_clmns">clmns</code></td>
<td>
<p>the names of the columns to interpolate over </p>
</td></tr>
</table>


<h3>Value</h3>

<p>a modified data frame without missing values in the columns specified
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
path &lt;- system.file("extdata","primate-example.data.csv", package="mmodely")
gs.tab &lt;- read.csv(path, row.names=1)

clmns &lt;- match(c('mass.Kg','DPL.km'),names(gs.tab))
df.2 &lt;- interpolate(df=gs.tab, taxa='genus', clmns=clmns)

</code></pre>

<hr>
<h2 id='missing.data'>Report missing values in a dataframe</h2><span id='topic+missing.data'></span>

<h3>Description</h3>

<p>This funciton reports column and rowwise missing data. It can also list the rownames for missing columns or the column names for missing rows.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>missing.data(x, cols=NULL, rows=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="missing.data_+3A_x">x</code></td>
<td>
<p>a dataframe</p>
</td></tr>
<tr><td><code id="missing.data_+3A_cols">cols</code></td>
<td>
<p>print the specific rows corresponding to missing values in this column</p>
</td></tr>
<tr><td><code id="missing.data_+3A_rows">rows</code></td>
<td>
<p>print the specific cols corresponding to missing values in this rowname</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a report on column versus row wise missing data
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
path &lt;- system.file("extdata","primate-example.data.csv", package="mmodely")
data &lt;- read.csv(path, row.names=1)

missing.data(data)


</code></pre>

<hr>
<h2 id='missing.fill.in'>Fill in missing values in a dataframe with a secondary source</h2><span id='topic+missing.fill.in'></span>

<h3>Description</h3>

<p>This function uses the (non-missing) values from one column to fill in the missing values of another 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>missing.fill.in(x, var.from, var.to)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="missing.fill.in_+3A_x">x</code></td>
<td>
<p>a dataframe or matrix</p>
</td></tr>
<tr><td><code id="missing.fill.in_+3A_var.from">var.from</code></td>
<td>
<p>secondary variable (of the same type and units) providing values to 'var.to'</p>
</td></tr>
<tr><td><code id="missing.fill.in_+3A_var.to">var.to</code></td>
<td>
<p>primary variable with missing values to fill in by 'var.from'</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a modified dataframe with fewer missing values in the 'var.to' column
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
df &lt;- data.frame(a=c(1,2,NA),b=c(1,NA,3),c=c(1,2,6))
missing.fill.in(df, 'c','a')

</code></pre>

<hr>
<h2 id='pgls.iter'>Iterate through PGLS estimations</h2><span id='topic+pgls.iter'></span>

<h3>Description</h3>

<p>This function takes phylogenetic tree and a list of (all possible) combinations of variables as a vector of model strings and estimates PGLS fits based on the bounds or tree parameters provided seperately.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pgls.iter(models, phylo, df,  gs.clmn='gn_sp', 
          b=list(lambda=c(.2,1),kappa=c(.2,2.8),delta=c(.2,2.8)),l='ML', k='ML',d='ML') 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pgls.iter_+3A_models">models</code></td>
<td>
<p>a vector of all possible model formulas (as character strings)</p>
</td></tr>
<tr><td><code id="pgls.iter_+3A_phylo">phylo</code></td>
<td>
<p>a phylogenetic tree</p>
</td></tr>
<tr><td><code id="pgls.iter_+3A_df">df</code></td>
<td>
<p>the name of the column used to specify 'Genus_species'</p>
</td></tr>
<tr><td><code id="pgls.iter_+3A_gs.clmn">gs.clmn</code></td>
<td>
<p>the name of the column containing the 'Genus_species' vector</p>
</td></tr>
<tr><td><code id="pgls.iter_+3A_b">b</code></td>
<td>
<p>a list of vectors of upper and lower bounds for kappa, lambda, and delta</p>
</td></tr>
<tr><td><code id="pgls.iter_+3A_k">k</code></td>
<td>
<p>the fixed or 'ML' value for kappa</p>
</td></tr>
<tr><td><code id="pgls.iter_+3A_l">l</code></td>
<td>
<p>the fixed or 'ML' value for lambda</p>
</td></tr>
<tr><td><code id="pgls.iter_+3A_d">d</code></td>
<td>
<p>the fixed or 'ML' value for delta</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of fit PGLS regression models plus 'optim' and 'param' support tables 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

data.path &lt;- system.file("extdata","primate-example.data.csv", package="mmodely")
data &lt;- read.csv(data.path, row.names=1)
pvs &lt;- names(data[3:5])
data$gn_sp &lt;- rownames(data)

tree.path &lt;- system.file("extdata","primate-springer.2012.tre", package="mmodely")
phyl &lt;- ape::read.tree(tree.path)[[5]]

comp &lt;- comp.data(phylo=phyl, df=data)

mods &lt;- get.model.combos(predictor.vars=pvs, outcome.var='OC', min.q=2)

PGLSi &lt;- pgls.iter(models=mods, phylo=phyl, df=data, k=1,l=1,d=1) 

</code></pre>

<hr>
<h2 id='pgls.iter.stats'>Statistics from PGLS runs</h2><span id='topic+pgls.iter.stats'></span>

<h3>Description</h3>

<p>Print (and plot) statistics from a list of PGLSs fitted models and tables of associated parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pgls.iter.stats(PGLSi, verbose=TRUE, plots=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pgls.iter.stats_+3A_pglsi">PGLSi</code></td>
<td>
<p>a list of PGLS iter objects, each of which is list including: fitted PGLS model, a optim table, and a tree-transformation parameter table</p>
</td></tr>
<tr><td><code id="pgls.iter.stats_+3A_verbose">verbose</code></td>
<td>
<p>the model formula (as acharacter string)</p>
</td></tr>
<tr><td><code id="pgls.iter.stats_+3A_plots">plots</code></td>
<td>
<p>the fixed or 'ML' value for kappa</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A summary statistics on each of the objects in the PGLS list of lists
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data.path &lt;- system.file("extdata","primate-example.data.csv", package="mmodely")
data &lt;- read.csv(data.path, row.names=1)
pvs &lt;- names(data[3:5])
data$gn_sp &lt;- rownames(data)

tree.path &lt;- system.file("extdata","primate-springer.2012.tre", package="mmodely")
phyl &lt;- ape::read.tree(tree.path)[[5]]

comp &lt;- comp.data(phylo=phyl, df=data)

mods &lt;- get.model.combos(predictor.vars=pvs, outcome.var='OC', min.q=2)

PGLSi &lt;- pgls.iter(models=mods, phylo=phyl, df=data, k=1,l=1,d=1) 

pgls.iter.stats(PGLSi, verbose=TRUE, plots=FALSE)

</code></pre>

<hr>
<h2 id='pgls.print'>Print the results of a PGLS model fit</h2><span id='topic+pgls.print'></span>

<h3>Description</h3>

<p>Print the results of a PGLS model fit
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pgls.print(pgls, all.vars=names(pgls$data$data)[-1], 
           model.no=NA, mtx.out=NA, write=TRUE, print=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pgls.print_+3A_pgls">pgls</code></td>
<td>
<p>a fit PGLS model</p>
</td></tr>
<tr><td><code id="pgls.print_+3A_all.vars">all.vars</code></td>
<td>
<p>the names of all the variables to be reported</p>
</td></tr>
<tr><td><code id="pgls.print_+3A_model.no">model.no</code></td>
<td>
<p>the model number (can be the order that models were run</p>
</td></tr>
<tr><td><code id="pgls.print_+3A_mtx.out">mtx.out</code></td>
<td>
<p>should a matrix of the tabular summary results be returned</p>
</td></tr>
<tr><td><code id="pgls.print_+3A_write">write</code></td>
<td>
<p>should the matrix of summary results be written to disk?</p>
</td></tr>
<tr><td><code id="pgls.print_+3A_print">print</code></td>
<td>
<p>should the matrix of summary results be printed to screen?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of summary results of a fit PGLS model
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data.path &lt;- system.file("extdata","primate-example.data.csv", package="mmodely")
data &lt;- read.csv(data.path, row.names=1)
data$gn_sp &lt;- rownames(data)

tree.path &lt;- system.file("extdata","primate-springer.2012.tre", package="mmodely")

#5. RAxML phylogram based on the 61199 bp concatenation of 69 nuclear and ten mitochondrial genes.
phyl &lt;- ape::read.tree(tree.path)[[5]]

phyl &lt;- trim.phylo(phylo=phyl, gs.vect=data$gn_sp)

comp &lt;- comp.data(phylo=phyl, df=data)

a.PGLS &lt;- caper::pgls(formula('OC~mass.Kg + DPL.km'),  data=comp)

pgls.print(a.PGLS, all.vars=names(a.PGLS$data$data)[-1],
           model.no=NA, mtx.out='', write=FALSE, print=FALSE)


</code></pre>

<hr>
<h2 id='pgls.report'>Report PGLS results as a table</h2><span id='topic+pgls.report'></span>

<h3>Description</h3>

<p>Output a spreadsheet ready tabular summary of a fit PGLS model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pgls.report(cd, f=formula('y~x'), l=1,k=1,d=1, 
            bounds=list(lambda=c(.2,1),kappa=c(.2,2.7),delta=c(.2,2.7)), 
            anova=FALSE, mod.no='NA', out='pgls.output-temp',QC.plot=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pgls.report_+3A_cd">cd</code></td>
<td>
<p>a comparative data object, here created by 'comp.data'</p>
</td></tr>
<tr><td><code id="pgls.report_+3A_f">f</code></td>
<td>
<p>the model formula (as acharacter string)</p>
</td></tr>
<tr><td><code id="pgls.report_+3A_k">k</code></td>
<td>
<p>the fixed or 'ML' value for kappa</p>
</td></tr>
<tr><td><code id="pgls.report_+3A_l">l</code></td>
<td>
<p>the fixed or 'ML' value for lambda</p>
</td></tr>
<tr><td><code id="pgls.report_+3A_d">d</code></td>
<td>
<p>the fixed or 'ML' value for delta</p>
</td></tr>
<tr><td><code id="pgls.report_+3A_bounds">bounds</code></td>
<td>
<p>a list of vectors of upper and lower bounds for kappa, lambda, and delta</p>
</td></tr>
<tr><td><code id="pgls.report_+3A_anova">anova</code></td>
<td>
<p>should an anova be run on the fit model and output to the terminal?</p>
</td></tr>
<tr><td><code id="pgls.report_+3A_mod.no">mod.no</code></td>
<td>
<p>the model number (can be the order that models were run)</p>
</td></tr>
<tr><td><code id="pgls.report_+3A_out">out</code></td>
<td>
<p>the base filename to be printed out</p>
</td></tr>
<tr><td><code id="pgls.report_+3A_qc.plot">QC.plot</code></td>
<td>
<p>should a quality control plot be output to screen?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A summary results of a fit PGLS model with ANOVA and tabular spreadsheet ready csv filesystem output.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

data.path &lt;- system.file("extdata","primate-example.data.csv", package="mmodely")
data &lt;- read.csv(data.path, row.names=1)
data$gn_sp &lt;- rownames(data)

tree.path &lt;- system.file("extdata","primate-springer.2012.tre", package="mmodely")
#5. RAxML phylogram based on the 61199 bp concatenation of 69 nuclear and ten mitochondrial genes. 
phyl &lt;- ape::read.tree(tree.path)[[5]]

phyl &lt;- trim.phylo(phylo=phyl, gs.vect=data$gn_sp)

comp &lt;- comp.data(phylo=phyl, df=data)

pgls.report(comp, f=formula('OC~mass.Kg + DPL.km'), l=1,k=1,d=1,
             anova=FALSE, mod.no='555', out='', QC.plot=TRUE)

</code></pre>

<hr>
<h2 id='pgls.wrap'>A Wrapper for PGLS model</h2><span id='topic+pgls.wrap'></span>

<h3>Description</h3>

<p>Print the results of an unfit PGLS model 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pgls.wrap(cd,f,b,l,k,d,all.vars=names(cd$data)[-1], 
           model.no=NA, mtx.out=NA, write=TRUE,print=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pgls.wrap_+3A_cd">cd</code></td>
<td>
<p>a 'comparative data' object, here created by 'comp.data(phylo, df, gs.clmn)'</p>
</td></tr>
<tr><td><code id="pgls.wrap_+3A_f">f</code></td>
<td>
<p>the model formula (as acharacter string)</p>
</td></tr>
<tr><td><code id="pgls.wrap_+3A_b">b</code></td>
<td>
<p>a list of vectors of upper and lower bounds for kappa, lambda, and delta</p>
</td></tr>
<tr><td><code id="pgls.wrap_+3A_l">l</code></td>
<td>
<p>the fixed or 'ML' value for lambda</p>
</td></tr>
<tr><td><code id="pgls.wrap_+3A_k">k</code></td>
<td>
<p>the fixed or 'ML' value for kappa</p>
</td></tr>
<tr><td><code id="pgls.wrap_+3A_d">d</code></td>
<td>
<p>the fixed or 'ML' value for delta</p>
</td></tr>
<tr><td><code id="pgls.wrap_+3A_all.vars">all.vars</code></td>
<td>
<p>the names of all the variables to be reported</p>
</td></tr>
<tr><td><code id="pgls.wrap_+3A_model.no">model.no</code></td>
<td>
<p>the model number (can be the order that models were run</p>
</td></tr>
<tr><td><code id="pgls.wrap_+3A_mtx.out">mtx.out</code></td>
<td>
<p>should a matrix of the tabular summary results be returned</p>
</td></tr>
<tr><td><code id="pgls.wrap_+3A_write">write</code></td>
<td>
<p>should the matrix of summary results be written to disk?</p>
</td></tr>
<tr><td><code id="pgls.wrap_+3A_print">print</code></td>
<td>
<p>should the matrix of summary results be printed to screen?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of summary results of a fit PGLS model
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data.path &lt;- system.file("extdata","primate-example.data.csv", package="mmodely")
data &lt;- read.csv(data.path, row.names=1)
data$gn_sp &lt;- rownames(data)

tree.path &lt;- system.file("extdata","primate-springer.2012.tre", package="mmodely")
#5. RAxML phylogram based on the 61199 bp concatenation of 69 nuclear and ten mitochondrial genes.
phyl &lt;- ape::read.tree(tree.path)[[5]]

phyl &lt;- trim.phylo(phylo=phyl, gs.vect=data$gn_sp)

comp &lt;- comp.data(phylo=phyl, df=data)

model &lt;- 'OC ~ mass.Kg + group.size'

pgls.wrap(cd=comp,f=model,b=list(kappa=c(.3,3),lambda=c(.3,3),delta=c(.3,3)), 
           l=1,k=1,d=1,all.vars=names(cd.obj$data)[-1])

</code></pre>

<hr>
<h2 id='plot.confound.grid'>Plot a grid of x y plots split by a confounder z</h2><span id='topic+plot.confound.grid'></span>

<h3>Description</h3>

<p>Plot a grid of x y plots showing how a third confounding variable 'z' changes the slope
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'confound.grid'
plot(x, Y='y', X='x', confounder='z', breaks=3,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.confound.grid_+3A_x">x</code></td>
<td>
<p>a data frame</p>
</td></tr>
<tr><td><code id="plot.confound.grid_+3A_y">Y</code></td>
<td>
<p>the name of the column with the dependent/outcome variable</p>
</td></tr>
<tr><td><code id="plot.confound.grid_+3A_x">X</code></td>
<td>
<p>the name of the column with the predictor variable</p>
</td></tr>
<tr><td><code id="plot.confound.grid_+3A_confounder">confounder</code></td>
<td>
<p>the name of the column with confounding variable</p>
</td></tr>
<tr><td><code id="plot.confound.grid_+3A_breaks">breaks</code></td>
<td>
<p>number or vector of breaks to split the plots horizontally (across x)</p>
</td></tr>
<tr><td><code id="plot.confound.grid_+3A_...">...</code></td>
<td>
<p>other arguments passed to 'plot'</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a confound grid plot
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
path &lt;- system.file("extdata","primate-example.data.csv", package="mmodely")
data &lt;- read.csv(path, row.names=1)
data$col &lt;- c('yellow','red')[data$nocturnal+1]

plot.confound.grid(x=data, Y='OC', X='leap.pct', confounder='mass.Kg')

</code></pre>

<hr>
<h2 id='plot.pgls.iters'>Plot the PGLS iterations</h2><span id='topic+plot.pgls.iters'></span>

<h3>Description</h3>

<p>A plot of AIC (and AICc) vs R^2 (and adjusted R^2) for all of the PGLS iterations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'pgls.iters'
plot(x, 
      bests=bestBy(x$optim, by=c('n','q','qXn','rwGsm')[1], best=c('AICc','R2.adj')[1], 
                         inverse=FALSE), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.pgls.iters_+3A_x">x</code></td>
<td>
<p>a PGLSi[teration] object (a list of pgls model fits as well as optimization and tree parameter tables)</p>
</td></tr>
<tr><td><code id="plot.pgls.iters_+3A_bests">bests</code></td>
<td>
<p>a table of the 'best' models to highlight in the plot based on some optimization criterion (e.g. R2)</p>
</td></tr>
<tr><td><code id="plot.pgls.iters_+3A_...">...</code></td>
<td>
<p>other parameters passed to 'plot'</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a plot of all of PGLS iterations
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data.path &lt;- system.file("extdata","primate-example.data.csv", package="mmodely")
data &lt;- read.csv(data.path, row.names=1)
pvs &lt;- names(data[3:5])
data$gn_sp &lt;- rownames(data)

tree.path &lt;- system.file("extdata","primate-springer.2012.tre", package="mmodely")
phyl &lt;- ape::read.tree(tree.path)[[5]]

mods &lt;- get.model.combos(predictor.vars=pvs, outcome.var='OC', min.q=2)

PGLSi &lt;- pgls.iter(models=mods, phylo=phyl, df=data, k=1,l=1,d=1) 


# sprinkle in some missing data so as to make model selection more interesting
for(pv in pvs){ data[sample(x=1:nrow(data),size=2),pv] &lt;- NA} 

PGLSi &lt;- pgls.iter(models=mods, phylo=phyl, df=data, k=1,l=1,d=1) 

# find the lowest AIC within each q by n sized sub-dataset
plot.pgls.iters(x=PGLSi)

</code></pre>

<hr>
<h2 id='plot.pgls.R2AIC'>Plot (R2 vs AIC) results of a collection of fit PGLS models</h2><span id='topic+plot.pgls.R2AIC'></span>

<h3>Description</h3>

<p>Plots a single panel of R^2 versus AIC, using versions of your choosing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'pgls.R2AIC'
plot(x, 
            bests=bestBy(x, by=c('n','q','qXn','rwGsm')[4], best=c('AICc','R2.adj')[1], 
            inverse=c(FALSE,TRUE)[1]),bcl=rgb(1,1,1,maxColorValue=3,alpha=1), nx=2, 
            model.as.title='', ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.pgls.R2AIC_+3A_x">x</code></td>
<td>
<p>a PGLSi[teration]$optim [optimization] table </p>
</td></tr>
<tr><td><code id="plot.pgls.R2AIC_+3A_bests">bests</code></td>
<td>
<p>a list of the best PGLS models grouped by variable count and sorted by some metric (e.g. adjusted R2)</p>
</td></tr>
<tr><td><code id="plot.pgls.R2AIC_+3A_bcl">bcl</code></td>
<td>
<p>background color of plot point</p>
</td></tr>
<tr><td><code id="plot.pgls.R2AIC_+3A_nx">nx</code></td>
<td>
<p>point size expansion factor to multiply against sample size ratio (this model to max of all models)</p>
</td></tr>
<tr><td><code id="plot.pgls.R2AIC_+3A_model.as.title">model.as.title</code></td>
<td>
<p>uses model.1ln.report to create a short character string of the &quot;best&quot; model results as a title</p>
</td></tr>
<tr><td><code id="plot.pgls.R2AIC_+3A_...">...</code></td>
<td>
<p>other parameters passed to 'plot'</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a plot of R2 versus AIC of many PGLS models
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data.path &lt;- system.file("extdata","primate-example.data.csv", package="mmodely")
data &lt;- read.csv(data.path, row.names=1)
pvs &lt;- names(data[3:6])
data$gn_sp &lt;- rownames(data)

tree.path &lt;- system.file("extdata","primate-springer.2012.tre", package="mmodely")
phyl &lt;- ape::read.tree(tree.path)[[5]]

mods &lt;- get.model.combos(predictor.vars=pvs, outcome.var='OC', min.q=2)

# sprinkle in some missing data so as to make model selection more interesting
for(pv in pvs){ data[sample(x=1:nrow(data),size=2),pv] &lt;- NA} 

PGLSi &lt;- pgls.iter(models=mods, phylo=phyl, df=data, k=1,l=1,d=1) 

plot.pgls.R2AIC(PGLSi$optim)   # find the lowest AIC within each q by n sized sub-dataset

</code></pre>

<hr>
<h2 id='plot.transformed.phylo'>Plot a transformed phylogenetic tree</h2><span id='topic+plot.transformed.phylo'></span>

<h3>Description</h3>

<p>PGLS regression will use maximum likelihood to estimate tree parameters while also estimating regression parameters. Here we provide a utility function to visualize what this new tree would look like in two dimensions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'transformed.phylo'
plot(x, delta=1,kappa=1,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.transformed.phylo_+3A_x">x</code></td>
<td>
<p>a phylogenetic tree</p>
</td></tr>
<tr><td><code id="plot.transformed.phylo_+3A_delta">delta</code></td>
<td>
<p>an integer between 0 and 3</p>
</td></tr>
<tr><td><code id="plot.transformed.phylo_+3A_kappa">kappa</code></td>
<td>
<p>an integer between 0 and 3</p>
</td></tr>
<tr><td><code id="plot.transformed.phylo_+3A_...">...</code></td>
<td>
<p>other parameters passed to 'plot'</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a plot of a transformed phylogenetic tree
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
tree.path &lt;- system.file("extdata","primate-springer.2012.tre", package="mmodely")
phyl &lt;- ape::read.tree(tree.path)[[5]]

plot.transformed.phylo(x=phyl, delta=2.3,kappa=2.1)

</code></pre>

<hr>
<h2 id='plot.xy.ab.p'>An x/y scatterplot with a linear regression line and p-value</h2><span id='topic+plot.xy.ab.p'></span>

<h3>Description</h3>

<p>This function performs a simple scatter plot but also superimposses a linear regression trend (abline) and optionally also the p-value of this line
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'xy.ab.p'
plot(x, x.var, y.var, 
fit.line=TRUE, p.value=TRUE, slope=TRUE, p.col='red', plot.labels=TRUE, verbose=TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.xy.ab.p_+3A_x">x</code></td>
<td>
<p>a data frame</p>
</td></tr>
<tr><td><code id="plot.xy.ab.p_+3A_x.var">x.var</code></td>
<td>
<p>the name of the x variable in df</p>
</td></tr>
<tr><td><code id="plot.xy.ab.p_+3A_y.var">y.var</code></td>
<td>
<p>the name of the y variable in df</p>
</td></tr>
<tr><td><code id="plot.xy.ab.p_+3A_fit.line">fit.line</code></td>
<td>
<p>should a fit (ab) line be drawn?</p>
</td></tr>
<tr><td><code id="plot.xy.ab.p_+3A_p.value">p.value</code></td>
<td>
<p>should the p-value be printed on the plot?</p>
</td></tr>
<tr><td><code id="plot.xy.ab.p_+3A_slope">slope</code></td>
<td>
<p>should the slope be printed on the plot?</p>
</td></tr>
<tr><td><code id="plot.xy.ab.p_+3A_p.col">p.col</code></td>
<td>
<p>should the plot be labeled?</p>
</td></tr>
<tr><td><code id="plot.xy.ab.p_+3A_plot.labels">plot.labels</code></td>
<td>
<p>should all of thie model fit information be printed out?</p>
</td></tr>
<tr><td><code id="plot.xy.ab.p_+3A_verbose">verbose</code></td>
<td>
<p>should all other information be printed out too?</p>
</td></tr>
<tr><td><code id="plot.xy.ab.p_+3A_...">...</code></td>
<td>
<p>other parameters passed to 'plot'</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An x/y scatterplot with regression line
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
path &lt;- system.file("extdata","primate-example.data.csv", package="mmodely")
data &lt;- read.csv(path, row.names=1)

plot.xy.ab.p(x=data, x.var='OC', y.var='group.size', 
        fit.line=TRUE, p.value=TRUE, slope=TRUE, p.col='red', plot.labels=TRUE, verbose=TRUE)

</code></pre>

<hr>
<h2 id='select.best.models'>Get the best model from list of PGLS model fits</h2><span id='topic+select.best.models'></span>

<h3>Description</h3>

<p>Get the outcome variable from the front of a model formula string. Used as part of 'get.mod.clmns' to be passed to 'comp.data'
</p>


<h3>Usage</h3>

<pre><code class='language-R'>select.best.models(PGLSi, using=c('AICc','R2.adj','AIC','R2')[1],
                             by=c('n','q','nXq','rwGsm')[1])
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="select.best.models_+3A_pglsi">PGLSi</code></td>
<td>
<p>a list of PGLS iter objects, each of which is list including: fitted PGLS model, a optim table, and a tree-transformation parameter table</p>
</td></tr>
<tr><td><code id="select.best.models_+3A_using">using</code></td>
<td>
<p>performance metric to use in searching for the best model</p>
</td></tr>
<tr><td><code id="select.best.models_+3A_by">by</code></td>
<td>
<p>unique identifier used to group sub-datasets for reporting (defaults to n) </p>
</td></tr>
</table>


<h3>Value</h3>

<p>a line corresponding to the &quot;best&quot; models from the PGLSi &quot;optim&quot; table
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data.path &lt;- system.file("extdata","primate-example.data.csv", package="mmodely")
data &lt;- read.csv(data.path, row.names=1)
pvs &lt;- names(data[3:5])
data$gn_sp &lt;- rownames(data)

tree.path &lt;- system.file("extdata","primate-springer.2012.tre", package="mmodely")
phyl &lt;- ape::read.tree(tree.path)[[5]]

comp &lt;- comp.data(phylo=phyl, df=data)

mods &lt;- get.model.combos(predictor.vars=pvs, outcome.var='OC', min.q=2)

PGLSi &lt;- pgls.iter(models=mods, phylo=phyl, df=data, k=1,l=1,d=1) 

a.PGLS &lt;- select.best.models(PGLSi, by=c('R2.adj','AICc')[1])

</code></pre>

<hr>
<h2 id='sparge.modsel'>Coeficients distribution [sparge] plot of models selected from each subset</h2><span id='topic+sparge.modsel'></span>

<h3>Description</h3>

<p>Plot the raw distribution of points corresponding to the coefficients harvested from the best model of each subset of the dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sparge.modsel(PC, jit.f=1, R2x=3, nx=2, n.max=max(unlist(PC$n)), zeroline=TRUE,
                  add=FALSE, pd=0, pvs=names(PC$coefs), pvlabs=NULL, 
                  xlim=range(unlist(PC$coefs)),
                  MA = NULL, ap=8, ac = 1, ax = nx, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sparge.modsel_+3A_pc">PC</code></td>
<td>
<p>a list of vectors of pooled coefficients (or scores) harvested from the 'best' selected modeling runs (out put from 'get.pgls.coefs') </p>
</td></tr>
<tr><td><code id="sparge.modsel_+3A_jit.f">jit.f</code></td>
<td>
<p>factor for random jittering (see 'jitter()'</p>
</td></tr>
<tr><td><code id="sparge.modsel_+3A_r2x">R2x</code></td>
<td>
<p>the line width expansion factor according to R^2 value</p>
</td></tr>
<tr><td><code id="sparge.modsel_+3A_nx">nx</code></td>
<td>
<p>the point size expansion factor according to sample size of model</p>
</td></tr> 
<tr><td><code id="sparge.modsel_+3A_n.max">n.max</code></td>
<td>
<p>the maximum sample size used in all models</p>
</td></tr> 
<tr><td><code id="sparge.modsel_+3A_zeroline">zeroline</code></td>
<td>
<p>should we add an abline at x=0?</p>
</td></tr>
<tr><td><code id="sparge.modsel_+3A_add">add</code></td>
<td>
<p>should we add to the existing plot?</p>
</td></tr>
<tr><td><code id="sparge.modsel_+3A_pd">pd</code></td>
<td>
<p>'position dodge' moves all y axis plotting positions up or down by this provided value (useful for adding multiple distributions for the same param)</p>
</td></tr>
<tr><td><code id="sparge.modsel_+3A_pvs">pvs</code></td>
<td>
<p>the predictor variable vector for ordering the y-axis labels</p>
</td></tr>
<tr><td><code id="sparge.modsel_+3A_pvlabs">pvlabs</code></td>
<td>
<p>the predictor variable labels for labeling the plot (defaults to pvs)</p>
</td></tr>
<tr><td><code id="sparge.modsel_+3A_xlim">xlim</code></td>
<td>
<p>x axis plot limits</p>
</td></tr>
<tr><td><code id="sparge.modsel_+3A_ma">MA</code></td>
<td>
<p>matrix of model averages (defaults to NULL)</p>
</td></tr>
<tr><td><code id="sparge.modsel_+3A_ap">ap</code></td>
<td>
<p>coded numeric point character symbol used for model averaged parameter position</p>
</td></tr>
<tr><td><code id="sparge.modsel_+3A_ac">ac</code></td>
<td>
<p>color symbol used for model averaged parameters plot character</p>
</td></tr>
<tr><td><code id="sparge.modsel_+3A_ax">ax</code></td>
<td>
<p>expansion factor to expant model average parameter plot character (defaults to nx)</p>
</td></tr>
<tr><td><code id="sparge.modsel_+3A_...">...</code></td>
<td>
<p>other parameters passed on to plot</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a 'sparge' [sprinkle/smear] plot of coefficent distributions
</p>


<h3>See Also</h3>

<p>See also 'boxplot' and 'stripchart' in package 'graphics' as well as 'violin', 'bean', 'ridgelines', and 'raincloud' plots.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data.path &lt;- system.file("extdata","primate-example.data.csv", package="mmodely")
data &lt;- read.csv(data.path, row.names=1)
pvs &lt;- names(data[3:5])
data$gn_sp &lt;- rownames(data)

tree.path &lt;- system.file("extdata","primate-springer.2012.tre", package="mmodely")
phyl &lt;- ape::read.tree(tree.path)[[5]]

mods &lt;- get.model.combos(predictor.vars=pvs, outcome.var='OC', min.q=2)

PGLSi &lt;- pgls.iter(models=mods, phylo=phyl, df=data, k=1,l=1,d=1) 

coefs.objs &lt;- get.pgls.coefs(PGLSi$fits, est='Estimate')

sparge.modsel(coefs.objs)

</code></pre>

<hr>
<h2 id='trim.phylo'>Trim a phylogenetic tree using Genus species names</h2><span id='topic+trim.phylo'></span>

<h3>Description</h3>

<p>Read in a vector of genus species names and a tree and drop the tips in the tree that match the vector of names.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>trim.phylo(phylo, gs.vect)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="trim.phylo_+3A_phylo">phylo</code></td>
<td>
<p>a phylogenetic tree</p>
</td></tr>
<tr><td><code id="trim.phylo_+3A_gs.vect">gs.vect</code></td>
<td>
<p>a vector of character strings in the 'Genus_species' format</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a plot of a transformed phylogenetic tree
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data.path &lt;- system.file("extdata","primate-example.data.csv", package="mmodely")
data &lt;- read.csv(data.path, row.names=1)
data$gn_sp &lt;- rownames(data)

tree.path &lt;- system.file("extdata","primate-springer.2012.tre", package="mmodely")
phylo &lt;- read.tree(tree.path)[[5]]

trim.phylo(phylo, gs.vect=data$gn_sp)

</code></pre>

<hr>
<h2 id='weight.IC'>Get IC weights </h2><span id='topic+weight.IC'></span>

<h3>Description</h3>

<p>An implementation of IC weighting that first calulates the difference in IC values by subtracting all values from the lowest IC value. Second, the changes are expoentiated divided by a sum of the same and exponentiated yet again.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>weight.IC(IC)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="weight.IC_+3A_ic">IC</code></td>
<td>
<p>a vector of IC values</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of IC based weights
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data.path &lt;- system.file("extdata","primate-example.data.csv", package="mmodely")
data &lt;- read.csv(data.path, row.names=1)
pvs &lt;- names(data[3:5])
data$gn_sp &lt;- rownames(data)

tree.path &lt;- system.file("extdata","primate-springer.2012.tre", package="mmodely")
phyl &lt;- ape::read.tree(tree.path)[[5]]

comp &lt;- comp.data(phylo=phyl, df=data)

mods &lt;- get.model.combos(predictor.vars=pvs, outcome.var='OC', min.q=2)

PGLSi &lt;- pgls.iter(models=mods, phylo=phyl, df=data, k=1,l=1,d=1) 

AICc.w &lt;- weight.IC(IC=PGLSi$optim$AICc)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
