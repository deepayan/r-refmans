<!DOCTYPE html><html lang="en"><head><title>Help for package stenR</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {stenR}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#attach_scales'><p>Attach additional StandardScale to already created ScoreTable</p></a></li>
<li><a href='#check_score_between'><p>Pick up standarized value from ScoringTable</p></a></li>
<li><a href='#CombScaleSpec'><p>Combined Scale Specification</p></a></li>
<li><a href='#CompScoreTable'><p>R6 class for producing easily re-computable ScoreTable</p></a></li>
<li><a href='#default_scales'><p>Default Standard Scales</p></a></li>
<li><a href='#export_ScaleSpec'><p>Export scale specification</p></a></li>
<li><a href='#export_ScoringTable'><p>Export ScoringTable</p></a></li>
<li><a href='#extract_observations'><p>Extract observations from data</p></a></li>
<li><a href='#FrequencyTable'><p>Create a FrequencyTable</p></a></li>
<li><a href='#GroupAssignment'><p>Assign to groups based on GroupConditions</p></a></li>
<li><a href='#GroupConditions'><p>Conditions for observation grouping</p></a></li>
<li><a href='#GroupedFrequencyTable'><p>Create GroupedFrequencyTable</p></a></li>
<li><a href='#GroupedScoreTable'><p>Create GroupedScoreTable</p></a></li>
<li><a href='#handle_retain'><p>Handle retain columns</p></a></li>
<li><a href='#HEXACO_60'><p>Sample data of HEXACO-60 questionnaire results</p></a></li>
<li><a href='#import_ScaleSpec'><p>Import scale specification</p></a></li>
<li><a href='#import_ScoringTable'><p>Import ScoringTable</p></a></li>
<li><a href='#intersect_GroupAssignment'><p>Intersect two GroupAssignment</p></a></li>
<li><a href='#IPIP_NEO_300'><p>Sample data of IPIP-NEO-300 questionnaire results</p></a></li>
<li><a href='#is_stenR_classes'><p>Checkers for stenR S3 and R6 classes</p></a></li>
<li><a href='#mockNAtable'><p>Mockup NA table</p></a></li>
<li><a href='#normalize_score'><p>Normalize raw scores</p></a></li>
<li><a href='#normalize_scores_df'><p>Normalize raw scores for multiple variables</p></a></li>
<li><a href='#normalize_scores_grouped'><p>Normalize scores using GroupedFrequencyTables or GroupedScoreTables</p></a></li>
<li><a href='#normalize_scores_scoring'><p>Normalize scores using ScoringTables</p></a></li>
<li><a href='#plot.GroupedFrequencyTable'><p>Gerenic plot of the GroupedFrequencyTable</p></a></li>
<li><a href='#plot.GroupedScoreTable'><p>Gerenic plot of the GroupedScoreTable</p></a></li>
<li><a href='#qualify_to_groups'><p>Qualify observations to groups for normalization</p></a></li>
<li><a href='#ScaleSpec'><p>Scale Specification object</p></a></li>
<li><a href='#ScoreTable'><p>Create a ScoreTable</p></a></li>
<li><a href='#SimFrequencyTable'><p>Generate FrequencyTable using simulated distribution</p></a></li>
<li><a href='#SLCS'><p>Sample data of SLCS questionnaire results</p></a></li>
<li><a href='#StandardScale'><p>Specify standard scale</p></a></li>
<li><a href='#strip_ScoreTable'><p>Revert the ScoreTable back to FrequencyTable object.</p></a></li>
<li><a href='#sum_items_to_scale'><p>Sum up discrete raw data</p></a></li>
<li><a href='#to_ScoringTable'><p>Create ScoringTable</p></a></li>
<li><a href='#verify_GC_for_ST'><p>Internal function to verify the provided conditions with conditions available</p>
in imported <em>ScoringTable</em></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Standardization of Raw Discrete Questionnaire Scores</td>
</tr>
<tr>
<td>Version:</td>
<td>0.6.9</td>
</tr>
<tr>
<td>Description:</td>
<td>An user-friendly framework to preprocess raw item
             scores of questionnaires into factors or scores and standardize
             them. Standardization can be made either by their normalization
             in representative sample, or by import of premade scoring table.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.2</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.1)</td>
</tr>
<tr>
<td>Imports:</td>
<td>cli, data.table, dplyr, moments, rlang, R6, stats</td>
</tr>
<tr>
<td>Suggests:</td>
<td>covr, ggplot2, jsonlite, knitr, rmarkdown, SimMultiCorrData,
testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://statismike.github.io/stenR/">https://statismike.github.io/stenR/</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-08-17 20:19:11 UTC; kosin</td>
</tr>
<tr>
<td>Author:</td>
<td>Michal Kosinski <a href="https://orcid.org/0000-0002-8426-3654"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Michal Kosinski &lt;kosinski.mich@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-08-19 11:20:01 UTC</td>
</tr>
</table>
<hr>
<h2 id='attach_scales'>Attach additional StandardScale to already created ScoreTable</h2><span id='topic+attach_scales'></span>

<h3>Description</h3>

<p>Attach additional StandardScale to already created ScoreTable
</p>


<h3>Usage</h3>

<pre><code class='language-R'>attach_scales(x, scale)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="attach_scales_+3A_x">x</code></td>
<td>
<p>A <em>ScoreTable</em> object</p>
</td></tr>
<tr><td><code id="attach_scales_+3A_scale">scale</code></td>
<td>
<p>a <em>StandardScale</em> object or list of multiple <em>StandardScale</em> objects</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># having a ScoreTable with one StandardScale attached
st &lt;- ScoreTable(FrequencyTable(HEXACO_60$HEX_C), STEN)
st$scale
names(st$table)

# possibly attach more scales to ScoreTable
st &lt;- attach_scales(st, list(STANINE, WECHSLER_IQ))
st$scale
names(st$table)
</code></pre>

<hr>
<h2 id='check_score_between'>Pick up standarized value from ScoringTable</h2><span id='topic+check_score_between'></span>

<h3>Description</h3>

<p>Internal function for picking up the standardized value from
ScoringTable for single observation. <code><a href="#topic+normalize_scores_scoring">normalize_scores_scoring()</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_score_between(x, col_raw, col_score)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="check_score_between_+3A_x">x</code></td>
<td>
<p>raw score</p>
</td></tr>
<tr><td><code id="check_score_between_+3A_col_raw">col_raw</code></td>
<td>
<p>Column of raw scores from ScoringTable</p>
</td></tr>
<tr><td><code id="check_score_between_+3A_col_score">col_score</code></td>
<td>
<p>COlumn of StandardScale score from ScoringTable</p>
</td></tr>
</table>

<hr>
<h2 id='CombScaleSpec'>Combined Scale Specification</h2><span id='topic+CombScaleSpec'></span><span id='topic+print.CombScaleSpec'></span><span id='topic+summary.CombScaleSpec'></span>

<h3>Description</h3>

<p>Combine multiple <code>ScaleSpec</code> objects into one in regards of <code><a href="#topic+sum_items_to_scale">sum_items_to_scale()</a></code>
function. Useful when one scale of factor contains items of different possible
values or if there is hierarchy of scale or factors.
</p>
<p>Also allows combining <code>CombScaleSpec</code> object if the factor structure have deeper
hierarchy.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CombScaleSpec(name, ..., reverse = character(0))

## S3 method for class 'CombScaleSpec'
print(x, ...)

## S3 method for class 'CombScaleSpec'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CombScaleSpec_+3A_name">name</code></td>
<td>
<p>Name of the combined scale or factor</p>
</td></tr>
<tr><td><code id="CombScaleSpec_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
<tr><td><code id="CombScaleSpec_+3A_reverse">reverse</code></td>
<td>
<p>character vector containing names of the underlying subscales
or factors that need to be reversed</p>
</td></tr>
<tr><td><code id="CombScaleSpec_+3A_x">x</code></td>
<td>
<p>a <em>CombScaleSpec</em> object</p>
</td></tr>
<tr><td><code id="CombScaleSpec_+3A_object">object</code></td>
<td>
<p>a <em>CombScaleSpec</em> object</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>CombScaleSpec</code> object
</p>


<h3>See Also</h3>

<p>Other item preprocessing functions: 
<code><a href="#topic+ScaleSpec">ScaleSpec</a>()</code>,
<code><a href="#topic+sum_items_to_scale">sum_items_to_scale</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># ScaleSpec objects to Combine

first_scale &lt;- ScaleSpec(
  name = "First Scale",
  item_names = c("Item_1", "Item_2"),
  min = 1,
  max = 5
)

second_scale &lt;- ScaleSpec(
  name = "Second Scale",
  item_names = c("Item_3", "Item_4"),
  min = 0,
  max = 7,
  reverse = "Item_3"
)

third_scale &lt;- ScaleSpec(
  name = "Third Scale",
  item_names = c("Item_5", "Item_6"),
  min = 1,
  max = 5
)

# You can combine few ScaleSpec objects into CombScaleSpec

first_comb &lt;- CombScaleSpec(
  name = "First Comb",
  first_scale,
  second_scale,
  reverse = "Second Scale"
)

print(first_comb)

# And also other CombScaleSpec objects!

second_comb &lt;- CombScaleSpec(
  name = "Second Comb",
  first_comb,
  third_scale
)

print(second_comb)

</code></pre>

<hr>
<h2 id='CompScoreTable'>R6 class for producing easily re-computable ScoreTable</h2><span id='topic+CompScoreTable'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
Computable ScoreTable class. It can compute and store <code><a href="#topic+ScoreTable">ScoreTable</a>s</code>
for multiple variables containing raw score results.
</p>
<p>After computation, it could be also used to compute new standardized scores
for provided raw scores and integrate them into stored tables.
</p>
<p><code>summary()</code> function can be used to get general information about
<code>CompScoreTable</code> object.
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-new"><code>CompScoreTable$new()</code></a>
</p>
</li>
<li> <p><a href="#method-attach_StandardScale"><code>CompScoreTable$attach_StandardScale()</code></a>
</p>
</li>
<li> <p><a href="#method-attach_FrequencyTable"><code>CompScoreTable$attach_FrequencyTable()</code></a>
</p>
</li>
<li> <p><a href="#method-export_ScoreTable"><code>CompScoreTable$export_ScoreTable()</code></a>
</p>
</li>
<li> <p><a href="#method-standardize"><code>CompScoreTable$standardize()</code></a>
</p>
</li>
<li> <p><a href="#method-clone"><code>CompScoreTable$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-new"></a>



<h4>Method <code>new()</code></h4>

<p>Initialize a <code>CompScoreTable</code> object. You can attach one or many
<code>StandardScale</code> and <code>FrequencyTable</code> objects
</p>


<h5>Usage</h5>

<div class="r"><pre>CompScoreTable$new(tables = NULL, scales = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>tables</code></dt><dd><p>Named list of <code>FrequencyTable</code> objects to be attached. Names
will indicate the name of variable for which the table is calculated.
Defaults to <code>NULL</code>, so no tables will be available at the beginning.</p>
</dd>
<dt><code>scales</code></dt><dd><p><code>StandardScale</code> object or list of such objects to be attached.
They will be used for calculation of <code>ScoreTables.</code> Defaults to <code>NULL</code>, so no
scales wil be available at the beginning.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p>Both <code>FrequencyTable</code> and <code>StandardScale</code> objects can be attached
with appropriate methods after object initialization.
</p>



<h5>Returns</h5>

<p>CompScoreTable object
</p>


<hr>
<a id="method-attach_StandardScale"></a>



<h4>Method <code>attach_StandardScale()</code></h4>

<p>Attach new scale to the object. If there are any ScoreTables
already computed, score for newly-attached scale will be computed automatically.
</p>


<h5>Usage</h5>

<div class="r"><pre>CompScoreTable$attach_StandardScale(scale, overwrite = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>scale</code></dt><dd><p><code>StandardScale</code> object defining a scale</p>
</dd>
<dt><code>overwrite</code></dt><dd><p>boolean indicating if the definition for a scale
of the same name should be overwritten</p>
</dd>
</dl>

</div>


<hr>
<a id="method-attach_FrequencyTable"></a>



<h4>Method <code>attach_FrequencyTable()</code></h4>

<p>Attach previously generated <code>FrequencyTable</code> for a given
variable. <code>ScoreTable</code> containing every attached scale will be calulcated
automatically based on every new <code>FrequencyTable</code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>CompScoreTable$attach_FrequencyTable(
  ft,
  var,
  if_exists = c("stop", "append", "replace")
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>ft</code></dt><dd><p>FrequencyTable to be attached</p>
</dd>
<dt><code>var</code></dt><dd><p>String with the name of the variable</p>
</dd>
<dt><code>if_exists</code></dt><dd><p>Action that should be taken if <code>FrequencyTable</code> for
given variable already exists in the object.
</p>

<ul>
<li> <p><code>stop</code> DEFAULT: don't do anything
</p>
</li>
<li> <p><code>append</code> recalculates existing table
</p>
</li>
<li> <p><code>replace</code> replaces existing table
</p>
</li></ul>
</dd>
</dl>

</div>


<hr>
<a id="method-export_ScoreTable"></a>



<h4>Method <code>export_ScoreTable()</code></h4>

<p>Export list of <code>ScoreTables</code> from the object
</p>


<h5>Usage</h5>

<div class="r"><pre>CompScoreTable$export_ScoreTable(vars = NULL, strip = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>vars</code></dt><dd><p>Names of the variables for which to get the tables.
If left at <code>NULL</code> default - get all off them.</p>
</dd>
<dt><code>strip</code></dt><dd><p>logical indicating if the <code>ScoreTables</code> should be stripped
down to <code>FrequencyTables</code> during export. Defaults to <code>FALSE</code></p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>list of <code>ScoreTable</code> or <code>FrequencyTable</code> object
</p>


<hr>
<a id="method-standardize"></a>



<h4>Method <code>standardize()</code></h4>

<p>Compute standardize scores for <code>data.frame</code> of raw scores.
Additionally, the raw scores can be used to recalculate ScoreTables
before computing (using <code>calc = T</code>).
</p>


<h5>Usage</h5>

<div class="r"><pre>CompScoreTable$standardize(data, what, vars = names(data), calc = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>data</code></dt><dd><p>data.frame containing raw scores.</p>
</dd>
<dt><code>what</code></dt><dd><p>the values to get. One of either:
</p>

<ul>
<li> <p><code>quan</code> - the quantile of raw score in the distribution
</p>
</li>
<li> <p><code>Z</code> - normalized Z score for the raw scores
</p>
</li>
<li><p> name of the scale attached to the <code>CompScoreTable</code> object
</p>
</li></ul>
</dd>
<dt><code>vars</code></dt><dd><p>vector of variable names which will taken into account</p>
</dd>
<dt><code>calc</code></dt><dd><p>should the <code>ScoreTables</code> be computed (or recalculated, if
some are already provided?). Default to <code>TRUE</code></p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p><code>data.frame</code> with standardized values
</p>


<hr>
<a id="method-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>CompScoreTable$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>



<hr>
<h2 id='default_scales'>Default Standard Scales</h2><span id='topic+default_scales'></span><span id='topic+STEN'></span><span id='topic+STANINE'></span><span id='topic+TANINE'></span><span id='topic+TETRONIC'></span><span id='topic+WECHSLER_IQ'></span>

<h3>Description</h3>

<p>Few <code>StandardScale</code> objects pre-defined for usage. To create
any other, use <code><a href="#topic+StandardScale">StandardScale()</a></code> function.
</p>

<ul>
<li> <p><strong>STEN</strong>: M: 5.5, SD: 2, min: 1, max: 10
</p>
</li>
<li> <p><strong>STANINE</strong>: M: 5, SD: 2, min: 1, max: 9
</p>
</li>
<li> <p><strong>TANINE</strong>: M: 50, SD: 10, min: 1, max: 100
</p>
</li>
<li> <p><strong>TETRONIC</strong>: M: 10, SD: 4, min: 0, max: 20
</p>
</li>
<li> <p><strong>WECHSLER_IQ</strong>: M: 100, SD: 15, min: 40, max: 160
</p>
</li></ul>


<hr>
<h2 id='export_ScaleSpec'>Export scale specification</h2><span id='topic+export_ScaleSpec'></span>

<h3>Description</h3>

<p>Function to export ScaleSpec or CombScaleSpec object into json file
which can be imported by <code><a href="#topic+import_ScaleSpec">import_ScaleSpec()</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>export_ScaleSpec(spec, out_file)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="export_ScaleSpec_+3A_spec">spec</code></td>
<td>
<p>ScaleSpec or CombScaleSpec object to export</p>
</td></tr>
<tr><td><code id="export_ScaleSpec_+3A_out_file">out_file</code></td>
<td>
<p>path to output file</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other import/export functions: 
<code><a href="#topic+export_ScoringTable">export_ScoringTable</a>()</code>,
<code><a href="#topic+import_ScaleSpec">import_ScaleSpec</a>()</code>,
<code><a href="#topic+import_ScoringTable">import_ScoringTable</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create temp files
ScaleSpecJSON &lt;- tempfile(fileext = ".json")
CombScaleJSON &lt;- tempfile(fileext = ".json")

####         import/export ScaleSpec        ####
# create scale spec for export
scaleSpec &lt;- ScaleSpec(
  name = "First Scale", 
  item_names = c("Item_1", "Item_2"), 
  min = 1,  max = 5)

# export / import
export_ScaleSpec(scaleSpec, ScaleSpecJSON)

imported_scaleSpec &lt;- import_ScaleSpec(ScaleSpecJSON)

# check if they are the same
all.equal(scaleSpec, imported_scaleSpec)

####      import/export CombScaleSpec       ####
# create second scale and CombScaleSpec object
second_scale &lt;- ScaleSpec(
  name = "Second Scale", 
  item_names = c("Item_3", "Item_4"),  
  min = 0, max = 7, 
  reverse = "Item_3"
)
combScale &lt;- CombScaleSpec(
  name = "First Comb", 
  scaleSpec, 
  second_scale,
  reverse = "Second Scale")

# export / import
export_ScaleSpec(combScale, CombScaleJSON)
imported_CombScale &lt;- import_ScaleSpec(CombScaleJSON)

# check if they are the same
all.equal(combScale, imported_CombScale)
</code></pre>

<hr>
<h2 id='export_ScoringTable'>Export ScoringTable</h2><span id='topic+export_ScoringTable'></span>

<h3>Description</h3>

<p>After creation of <code>ScoringTable</code> it can be handy to export it
into universally recognized and readable format. Two formats are currently
supported: <em>csv</em> and <em>json</em>. They can be imported back into <code>ScoringTable</code>
using <code><a href="#topic+import_ScoringTable">import_ScoringTable()</a></code> function.
</p>

<ul>
<li> <p><em>csv</em> format is universally readable - it can be opened, edited
and altered (eg. before publication) in any spreadsheet editor. In case of
<code>ScoringTable</code> created from <code>GroupedScoreTable</code>, <code>GroupConditions</code> can
be exported to another <em>csv</em> file, creating two different files.
</p>
</li>
<li> <p><em>json</em> format can be more obtuse, but it allows export of both
<code>ScoringTable</code> itself and <code>GroupConditions</code> in the same <em>json</em> file.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>export_ScoringTable(
  table,
  out_file,
  method = c("csv", "json", "object"),
  cond_file
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="export_ScoringTable_+3A_table">table</code></td>
<td>
<p>A <code>ScoringTable</code> object to export</p>
</td></tr>
<tr><td><code id="export_ScoringTable_+3A_out_file">out_file</code></td>
<td>
<p>Output file. Ignored if <code>method = "object"</code></p>
</td></tr>
<tr><td><code id="export_ScoringTable_+3A_method">method</code></td>
<td>
<p>Method for export, either <code>"csv"</code>, <code>"json"</code> or <code>"object"</code></p>
</td></tr>
<tr><td><code id="export_ScoringTable_+3A_cond_file">cond_file</code></td>
<td>
<p>Output file for <code>GroupConditions</code>. Used only
if <code>method = csv</code> and <code>table</code> created with <code>GroupedScoreTable</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list containing <code>ScoringTable</code> as a <code>tibble</code> and <code>GroupConditions</code>
if <code>method = "object"</code>. <code>NULL</code> for other methods
</p>


<h3>See Also</h3>

<p>import_ScoringTable
</p>
<p>Other import/export functions: 
<code><a href="#topic+export_ScaleSpec">export_ScaleSpec</a>()</code>,
<code><a href="#topic+import_ScaleSpec">import_ScaleSpec</a>()</code>,
<code><a href="#topic+import_ScoringTable">import_ScoringTable</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Scoring table to export / import #

Consc_ST &lt;- 
  GroupedFrequencyTable(
    data = IPIP_NEO_300,
    conditions = GroupConditions("Sex", "M" ~ sex == "M", "F" ~ sex == "F"), 
    var = "C") |&gt;
  GroupedScoreTable(scale = STEN) |&gt;
  to_ScoringTable(min_raw = 60, max_raw = 300)

#### Export/import method: csv ####

scoretable_csv &lt;- tempfile(fileext = ".csv")
conditions_csv &lt;- tempfile(fileext = ".csv")

export_ScoringTable(
  table = Consc_ST,
  out_file = scoretable_csv,
  method = "csv",
  cond_file = conditions_csv
)

## check if these are regular csv files
writeLines(head(readLines(scoretable_csv)))
writeLines(head(readLines(conditions_csv)))

imported_from_csv &lt;- import_ScoringTable(
  source = scoretable_csv,
  method = "csv",
  cond_file = conditions_csv
)

all.equal(Consc_ST, imported_from_csv)

#### Export/import method: json ####
scoretable_json &lt;- tempfile(fileext = ".json")

export_ScoringTable(
  table = Consc_ST,
  out_file = scoretable_json,
  method = "json"
)

## check if this is regular json file
writeLines(head(readLines(scoretable_json)))

imported_from_json &lt;- import_ScoringTable(
  source = scoretable_json,
  method = "json"
)

all.equal(Consc_ST, imported_from_json)
</code></pre>

<hr>
<h2 id='extract_observations'>Extract observations from data</h2><span id='topic+extract_observations'></span>

<h3>Description</h3>

<p>On basis of <em>GroupAssignment</em> extract one or many groups from
provided data.frame
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract_observations(
  data,
  groups,
  group_names = NULL,
  extract_mode = c("list", "data.frame"),
  strict_names = TRUE,
  simplify = FALSE,
  id
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="extract_observations_+3A_data">data</code></td>
<td>
<p><em>data.frame</em> from which to extract data</p>
</td></tr>
<tr><td><code id="extract_observations_+3A_groups">groups</code></td>
<td>
<p><em>GroupAssignment</em> object on basis of which extract the data.</p>
</td></tr>
<tr><td><code id="extract_observations_+3A_group_names">group_names</code></td>
<td>
<p><em>character</em> vector of group names which to extract. If kept
as default <code>NULL</code>, all groups are extracted.</p>
</td></tr>
<tr><td><code id="extract_observations_+3A_extract_mode">extract_mode</code></td>
<td>
<p><em>character</em>: either <code>list</code> or <code>data.frame</code>. When kept as
default: <code>list</code>, data is extracted as named list: where the name of list is
name of the groups, and each one contains <em>data.frame</em> with observations.
When <code>data.frame</code> is used, then assigned data is returned as one <em>data.frame</em>
with new column named: <code>GroupAssignment</code>, declaring the group.</p>
</td></tr>
<tr><td><code id="extract_observations_+3A_strict_names">strict_names</code></td>
<td>
<p><em>boolean</em> If <code>TRUE</code>, then intersected groups are extracted
using <em>strict</em> strategy: <code>group_names</code> need to be provided in form: <code>"group1:group2"</code>. If
<code>FALSE</code>, then intersected groups will be taken into regard separately, so
eg. when <code>"group1"</code> is provided to <code>group_names</code>, all of: <code>"group1:group2"</code>,
<code>"group1:group3"</code>, <code>"group1:groupN"</code>  will be extracted. Defaults to <code>TRUE</code></p>
</td></tr>
<tr><td><code id="extract_observations_+3A_simplify">simplify</code></td>
<td>
<p><em>boolean</em> If <code>TRUE</code>, then when only one group is to be
returned, it returns as <code>data.frame</code> without taking into account value of
<code>group_name</code> argument. Defaults to <code>FALSE</code></p>
</td></tr>
<tr><td><code id="extract_observations_+3A_id">id</code></td>
<td>
<p>If <em>GroupAssignment</em> mode is <code>id</code>, and you want to overwrite the
original <code>id_col</code>, provide a name of the column there. If none is provided,
then the default <code>id_col</code> will be used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>either:
</p>

<ul>
<li> <p><em>named list</em> of <em>data.frames</em> if <code>extract_mode = 'list'</code>
</p>
</li>
<li> <p><em>data.frame</em> if <code>extract_mode = 'data.frame'</code> or if only one group is to be
returned and <code>simplify = TRUE</code>
</p>
</li></ul>



<h3>See Also</h3>

<p>Other observation grouping functions: 
<code><a href="#topic+GroupAssignment">GroupAssignment</a>()</code>,
<code><a href="#topic+intersect_GroupAssignment">intersect_GroupAssignment</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#### Create Group Conditions ####
sex_grouping &lt;- GroupConditions(
  conditions_category = "Sex",
  "M" ~ sex == "M",
  "F" ~ sex == "F",
  "O" ~ !sex %in% c("M", "F")
)

age_grouping &lt;- GroupConditions(
  conditions_category = "Age",
  "to 20" ~ age &lt; 20,
  "20 to 40" ~ age &gt;= 20 &amp; age &lt;= 40,
  "41 to 60" ~ age &gt; 40 &amp; age &lt;= 60,
  "above 60" ~ age &gt; 60
)

#### Create Group Assignement ####
# can be done both with indices, so later this can be used only on the same data
# or with IDs - so later it can be done with only subset or transformed original data

sex_assignment &lt;- GroupAssignment(HEXACO_60, sex_grouping, id = "user_id")
age_assignment &lt;- GroupAssignment(HEXACO_60, age_grouping, id = "user_id")

#### Intersect two Group Assignement ###
# with additional forcing set
intersected &lt;- intersect_GroupAssignment(
  sex_assignment,
  age_assignment,
  force_exhaustive = TRUE,
  force_disjoint = FALSE
)

extracted &lt;- extract_observations(
  HEXACO_60,
  groups = intersected,
  group_names = c("M"),
  extract_mode = "data.frame",
  strict_names = FALSE)

# only groups created from "M" group were extracted
# groups without observations were dropped
table(extracted$GroupAssignment)
</code></pre>

<hr>
<h2 id='FrequencyTable'>Create a FrequencyTable</h2><span id='topic+FrequencyTable'></span><span id='topic+print.FrequencyTable'></span><span id='topic+plot.FrequencyTable'></span><span id='topic+summary.FrequencyTable'></span>

<h3>Description</h3>

<p>Normalizes the distribution of raw scores. It can be used to construct
<code><a href="#topic+ScoreTable">ScoreTable()</a></code> with the use of some <code><a href="#topic+StandardScale">StandardScale()</a></code> to normalize and
standardize the raw discrete scores.
</p>
<p><code>plot.FrequencyTable</code> method requires <code>ggplot2</code> package to be installed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FrequencyTable(data)

## S3 method for class 'FrequencyTable'
print(x, ...)

## S3 method for class 'FrequencyTable'
plot(x, ...)

## S3 method for class 'FrequencyTable'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="FrequencyTable_+3A_data">data</code></td>
<td>
<p>vector of raw scores. Double values are coerced to integer</p>
</td></tr>
<tr><td><code id="FrequencyTable_+3A_x">x</code></td>
<td>
<p>A <code>FrequencyTable</code> object</p>
</td></tr>
<tr><td><code id="FrequencyTable_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
<tr><td><code id="FrequencyTable_+3A_object">object</code></td>
<td>
<p>A <code>FrequencyTable</code> object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>FrequencyTable object. Consists of:
</p>

<ul>
<li><p> table: data.frame with number of observations (<code>n</code>), frequency in sample
(<code>freq</code>), quantile (<code>quan</code>) and normalized Z-score (<code>Z</code>) for each point in
raw score
</p>
</li>
<li><p> status: list containing the total number of simulated observations (<code>n</code>)
and information about raw scores range completion (<code>range</code>): complete or incomplete
</p>
</li></ul>

<p><code>data.frame</code> of descriptive statistcs
</p>


<h3>See Also</h3>

<p><code><a href="#topic+SimFrequencyTable">SimFrequencyTable()</a></code>
</p>

<hr>
<h2 id='GroupAssignment'>Assign to groups based on GroupConditions</h2><span id='topic+GroupAssignment'></span><span id='topic+print.GroupAssignment'></span><span id='topic+summary.GroupAssignment'></span>

<h3>Description</h3>

<p>Using <em>GroupConditions</em> object, assign observations to one
of the groups. It can export either indices of the observations, or their
unique <strong>ID</strong>: if column name is provided in <code>id</code> argument. Mostly used internally
by more complex functions and <code style="white-space: pre;">&#8288;R6 classes&#8288;</code>, but could also be useful
on its own.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GroupAssignment(
  data,
  conditions,
  id,
  force_disjoint,
  force_exhaustive,
  skip_faulty = FALSE,
  .all = FALSE,
  ...
)

## S3 method for class 'GroupAssignment'
print(x, ...)

## S3 method for class 'GroupAssignment'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="GroupAssignment_+3A_data">data</code></td>
<td>
<p>data.frame containing observations</p>
</td></tr>
<tr><td><code id="GroupAssignment_+3A_conditions">conditions</code></td>
<td>
<p><em>GroupConditions</em> object</p>
</td></tr>
<tr><td><code id="GroupAssignment_+3A_id">id</code></td>
<td>
<p><em>character</em> name of the column containing unique <strong>ID</strong> of the
observations to assign to each group. If not provided, indices
will be used instead.</p>
</td></tr>
<tr><td><code id="GroupAssignment_+3A_force_disjoint">force_disjoint</code></td>
<td>
<p><em>boolean</em> indicating if groups disjointedness should be
forced in case when one observation would pass conditions for more than one
group. If <code>TRUE</code>, the first condition which will be met will indicate
the group the observation will be assigned to. If not provided, the default
from <code>conditions</code> will be used</p>
</td></tr>
<tr><td><code id="GroupAssignment_+3A_force_exhaustive">force_exhaustive</code></td>
<td>
<p><em>boolean</em> indicating if groups exhausiveness should
be forced in case when there are observations that don't pass any of the provided
conditions. If <code>TRUE</code>, then they will be assigned to <code>.NA</code> group. If not provided, the default
from <code>conditions</code> will be used</p>
</td></tr>
<tr><td><code id="GroupAssignment_+3A_skip_faulty">skip_faulty</code></td>
<td>
<p><em>boolean</em> should the faulty <code>condition</code> be skipped?
If <code>FALSE</code> as in default, error will be produced. Faultiness of seemingly correct
condition may be caused by variable names to not be present in the <code>data</code>.</p>
</td></tr>
<tr><td><code id="GroupAssignment_+3A_.all">.all</code></td>
<td>
<p><em>boolean</em>. If <code>TRUE</code>, then additional group named <code>.all</code>
will be created, which will contain all observations. Useful when object will be
used for creation of <code><a href="#topic+GroupedFrequencyTable">GroupedFrequencyTable()</a></code></p>
</td></tr>
<tr><td><code id="GroupAssignment_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to or from method</p>
</td></tr>
<tr><td><code id="GroupAssignment_+3A_x">x</code></td>
<td>
<p>object</p>
</td></tr>
<tr><td><code id="GroupAssignment_+3A_object">object</code></td>
<td>
<p><code>GroupAssignment</code> object</p>
</td></tr>
</table>


<h3>Value</h3>

<p><em>GroupAssignment</em> object
</p>
<p>list of summaries, invisibly
</p>


<h3>See Also</h3>

<p>Other observation grouping functions: 
<code><a href="#topic+extract_observations">extract_observations</a>()</code>,
<code><a href="#topic+intersect_GroupAssignment">intersect_GroupAssignment</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>age_grouping &lt;- GroupConditions(
  conditions_category = "Age",
  "to 20" ~ age &lt; 20,
  "20 to 40" ~ age &gt;= 20 &amp; age &lt;= 40,
  "40 to 60" ~ age &gt;= 40 &amp; age &lt; 60
)

# on basis of GroupConditions create GroupAssignment

age_assignment &lt;- GroupAssignment(
  data = HEXACO_60,
  age_grouping)

print(age_assignment)

# overwrite the default settings imposed by `GroupConditions`

age_assignment_forced &lt;- GroupAssignment(
  data = HEXACO_60,
  age_grouping,
  force_exhaustive = TRUE)

summary(age_assignment_forced)

# you can also use other unique identifier from your data

age_assignment_forced_w_id &lt;- GroupAssignment(
  data = HEXACO_60,
  age_grouping,
  id = "user_id",
  force_exhaustive = TRUE)

summary(age_assignment_forced_w_id)
</code></pre>

<hr>
<h2 id='GroupConditions'>Conditions for observation grouping</h2><span id='topic+GroupConditions'></span><span id='topic+print.GroupConditions'></span><span id='topic+as.data.frame.GroupConditions'></span>

<h3>Description</h3>

<p>With help of this function you can create GroupingConditions
object, holding the basis of observation grouping. Objects of this class
can be provided to complex functions to automatically group observations
accordingly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GroupConditions(
  conditions_category,
  ...,
  force_disjoint = TRUE,
  force_exhaustive = FALSE,
  .dots = list()
)

## S3 method for class 'GroupConditions'
print(x, ...)

## S3 method for class 'GroupConditions'
as.data.frame(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="GroupConditions_+3A_conditions_category">conditions_category</code></td>
<td>
<p><em>chracter</em> value describing character of the group
conditions. Mainly informative.</p>
</td></tr>
<tr><td><code id="GroupConditions_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to or from methods.</p>
</td></tr>
<tr><td><code id="GroupConditions_+3A_force_disjoint">force_disjoint</code></td>
<td>
<p><em>boolean</em> indicating if the condition formulas by default
should be handled with <code>force_disjoint</code> strategy. By default <code>TRUE</code>.
If <code>TRUE</code>, the first condition which will be met will indicate
the group the observation will be assigned to.</p>
</td></tr>
<tr><td><code id="GroupConditions_+3A_force_exhaustive">force_exhaustive</code></td>
<td>
<p><em>boolean</em> indicating if groups exhaustiveness should
be forced in case when there are observations that don't pass any of the provided
conditions. If <code>TRUE</code>, then they will be assigned to <code>.NA</code> group. Defaults
to <code>FALSE</code></p>
</td></tr>
<tr><td><code id="GroupConditions_+3A_.dots">.dots</code></td>
<td>
<p><em>formulas</em> in form of a <em>list</em></p>
</td></tr>
<tr><td><code id="GroupConditions_+3A_x">x</code></td>
<td>
<p><code>GroupConditions</code> object</p>
</td></tr>
</table>


<h3>Value</h3>

<p><em>GroupConditions</em> object
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create GroupConditions with formula-style conditions per each group

sex_grouping &lt;- GroupConditions(
  conditions_category = "Sex",
  "M" ~ sex == "M",
  "F" ~ sex == "F",
  "O" ~ !sex %in% c("M", "F")
)
print(sex_grouping)

# GroupConditions can also mark if the groups should be handled by default
# with forced disjoint (default `TRUE`) and exhaustiveness (default `FALSE`)

age_grouping &lt;- GroupConditions(
  conditions_category = "Age",
  "to 20" ~ age &lt; 20,
  "20 to 40" ~ age &gt;= 20 &amp; age &lt;= 40,
  "40 to 60" ~ age &gt;= 40 &amp; age &lt; 60,
  force_disjoint = FALSE,
  force_exhaustive = TRUE
)
print(age_grouping)
</code></pre>

<hr>
<h2 id='GroupedFrequencyTable'>Create GroupedFrequencyTable</h2><span id='topic+GroupedFrequencyTable'></span><span id='topic+print.GroupedFrequencyTable'></span><span id='topic+summary.GroupedFrequencyTable'></span>

<h3>Description</h3>

<p>Using <code><a href="#topic+GroupConditions">GroupConditions()</a></code> object and source <code>data.frame</code> compute
a set of <code><a href="#topic+FrequencyTable">FrequencyTable()</a></code>s for single variable
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GroupedFrequencyTable(
  data,
  conditions,
  var,
  force_disjoint = FALSE,
  .all = TRUE
)

## S3 method for class 'GroupedFrequencyTable'
print(x, ...)

## S3 method for class 'GroupedFrequencyTable'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="GroupedFrequencyTable_+3A_data">data</code></td>
<td>
<p>source <code>data.frame</code></p>
</td></tr>
<tr><td><code id="GroupedFrequencyTable_+3A_conditions">conditions</code></td>
<td>
<p>up to two <code>GroupConditions</code> objects. These objects will be
passed along during creation of higher-level objects and used when
<code><a href="#topic+normalize_scores_grouped">normalize_scores_grouped()</a></code> will be called. If two objects are provided,
then intersection of groups will be made.</p>
</td></tr>
<tr><td><code id="GroupedFrequencyTable_+3A_var">var</code></td>
<td>
<p>name of variable to compute <code>GroupedFrequencyTable</code> for</p>
</td></tr>
<tr><td><code id="GroupedFrequencyTable_+3A_force_disjoint">force_disjoint</code></td>
<td>
<p>It is recommended to keep it as default
<code>FALSE</code>, unless the sample size is very big and it is completely mandatory
to have the groups disjointed.</p>
</td></tr>
<tr><td><code id="GroupedFrequencyTable_+3A_.all">.all</code></td>
<td>
<p>should <em>.all</em> or <em>.all1</em> and <em>.all2</em> groups
be generated. If they are not generated, all score normalization
procedures will fail if the observation can't be assigned to any of the
provided conditions (eg. because of missing data), leaving it's score as <code>NA</code>.
Defaults to <code>TRUE</code></p>
</td></tr>
<tr><td><code id="GroupedFrequencyTable_+3A_x">x</code></td>
<td>
<p>A <code>GroupedFrequencyTable</code> object</p>
</td></tr>
<tr><td><code id="GroupedFrequencyTable_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
<tr><td><code id="GroupedFrequencyTable_+3A_object">object</code></td>
<td>
<p>A <code>GroupedFrequencyTable</code> object</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>force_exhaustive</code> will always be checked as <code>FALSE</code> during the
calculations. It is mandatory for validity of the created <em>FrequencyTables</em>
</p>


<h3>Value</h3>

<p><code>data.frame</code> of descriptive statistcs
</p>


<h3>See Also</h3>

<p>plot.GroupedFrequencyTable
</p>

<hr>
<h2 id='GroupedScoreTable'>Create GroupedScoreTable</h2><span id='topic+GroupedScoreTable'></span><span id='topic+print.GroupedScoreTable'></span>

<h3>Description</h3>

<p>Create GroupedScoreTable
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GroupedScoreTable(table, scale)

## S3 method for class 'GroupedScoreTable'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="GroupedScoreTable_+3A_table">table</code></td>
<td>
<p><code>GroupedFrequencyTable</code> object</p>
</td></tr>
<tr><td><code id="GroupedScoreTable_+3A_scale">scale</code></td>
<td>
<p>a <code>StandardScale</code> object or list of multiple <code>StandardScale</code> objects</p>
</td></tr>
<tr><td><code id="GroupedScoreTable_+3A_x">x</code></td>
<td>
<p>A <code>GroupedScoreTable</code> object</p>
</td></tr>
<tr><td><code id="GroupedScoreTable_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>GroupedScoreTable</code> object, which consists of named <code>list</code> of
<code>ScoreTable</code> objects and <code>GroupConditions</code> object used for grouping
</p>


<h3>See Also</h3>

<p>plot.GroupedScoreTable
</p>

<hr>
<h2 id='handle_retain'>Handle retain columns</h2><span id='topic+handle_retain'></span>

<h3>Description</h3>

<p>Internal function that handles <em>retain</em> columns in non-base
normalize_scores functions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>handle_retain(data, output, retain)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="handle_retain_+3A_data">data</code></td>
<td>
<p>input data</p>
</td></tr>
<tr><td><code id="handle_retain_+3A_output">output</code></td>
<td>
<p>output data.frame</p>
</td></tr>
<tr><td><code id="handle_retain_+3A_retain">retain</code></td>
<td>
<p>retain value</p>
</td></tr>
</table>

<hr>
<h2 id='HEXACO_60'>Sample data of HEXACO-60 questionnaire results</h2><span id='topic+HEXACO_60'></span>

<h3>Description</h3>

<p>Dataset containing summed scale scores of HEXACO-60 questionnaire. They
were obtained during 2020 study on Polish incidental sample.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>HEXACO_60
</code></pre>


<h3>Format</h3>

<p>A data frame with 204 rows and 9 variables
</p>

<dl>
<dt>user_id</dt><dd><p>identity anonimized with 'ids::adjective_animal'</p>
</dd>
<dt>sex</dt><dd><p>sex of the participant ('M'ale, 'F'emale or 'O'ther)</p>
</dd>
<dt>age</dt><dd><p>age of the participant (15&ndash;62)</p>
</dd>
<dt>HEX_H</dt><dd><p>Honesty-Humility raw score (14&ndash;50)</p>
</dd>
<dt>HEX_E</dt><dd><p>Emotionality raw score (10&ndash;47)</p>
</dd>
<dt>HEX_X</dt><dd><p>eXtraversion raw score (11&ndash;46)</p>
</dd>
<dt>HEX_A</dt><dd><p>Agreeableness raw score (12&ndash;45)</p>
</dd>
<dt>HEX_C</dt><dd><p>Consciousness raw score (17&ndash;50)</p>
</dd>
<dt>HEX_O</dt><dd><p>Openness to Experience raw score (18&ndash;50)</p>
</dd>
</dl>



<h3>Details</h3>

<p>All HEXACO scales consists of 10 items with responses as numeric values 1-5
(so the absolute min and max are 10-50)
</p>

<hr>
<h2 id='import_ScaleSpec'>Import scale specification</h2><span id='topic+import_ScaleSpec'></span>

<h3>Description</h3>

<p>Function to import ScaleSpec or CombScaleSpec object from json file
that havebeen exported with <code><a href="#topic+export_ScaleSpec">export_ScaleSpec()</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>import_ScaleSpec(source)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="import_ScaleSpec_+3A_source">source</code></td>
<td>
<p>path to JSON file containing exported object</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other import/export functions: 
<code><a href="#topic+export_ScaleSpec">export_ScaleSpec</a>()</code>,
<code><a href="#topic+export_ScoringTable">export_ScoringTable</a>()</code>,
<code><a href="#topic+import_ScoringTable">import_ScoringTable</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create temp files
ScaleSpecJSON &lt;- tempfile(fileext = ".json")
CombScaleJSON &lt;- tempfile(fileext = ".json")

####         import/export ScaleSpec        ####
# create scale spec for export
scaleSpec &lt;- ScaleSpec(
  name = "First Scale", 
  item_names = c("Item_1", "Item_2"), 
  min = 1,  max = 5)

# export / import
export_ScaleSpec(scaleSpec, ScaleSpecJSON)

imported_scaleSpec &lt;- import_ScaleSpec(ScaleSpecJSON)

# check if they are the same
all.equal(scaleSpec, imported_scaleSpec)

####      import/export CombScaleSpec       ####
# create second scale and CombScaleSpec object
second_scale &lt;- ScaleSpec(
  name = "Second Scale", 
  item_names = c("Item_3", "Item_4"),  
  min = 0, max = 7, 
  reverse = "Item_3"
)
combScale &lt;- CombScaleSpec(
  name = "First Comb", 
  scaleSpec, 
  second_scale,
  reverse = "Second Scale")

# export / import
export_ScaleSpec(combScale, CombScaleJSON)
imported_CombScale &lt;- import_ScaleSpec(CombScaleJSON)

# check if they are the same
all.equal(combScale, imported_CombScale)
</code></pre>

<hr>
<h2 id='import_ScoringTable'>Import ScoringTable</h2><span id='topic+import_ScoringTable'></span>

<h3>Description</h3>

<p><code>ScoringTable</code> can be imported from <code>csv</code>, <code>json</code> file or
<code>tibble</code>. Source file or object can be either an output of <code><a href="#topic+export_ScoringTable">export_ScoringTable()</a></code>
function, or created by hand - though it needs to be created following the
correct format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>import_ScoringTable(
  source,
  method = c("csv", "json", "object"),
  cond_file,
  conditions
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="import_ScoringTable_+3A_source">source</code></td>
<td>
<p>Path to the file to import the <code>ScoringTable</code> from (for <em>csv</em> and <em>json</em> methods)
or <code>ScoringTable</code> in form of <code>data.frame</code> (for <em>object</em> method)</p>
</td></tr>
<tr><td><code id="import_ScoringTable_+3A_method">method</code></td>
<td>
<p>Method for import, either <em>csv</em>, <em>json</em> or <em>object</em></p>
</td></tr>
<tr><td><code id="import_ScoringTable_+3A_cond_file">cond_file</code></td>
<td>
<p>File to import the <code>GroupConditions</code> from, if using <em>csv</em> method</p>
</td></tr>
<tr><td><code id="import_ScoringTable_+3A_conditions">conditions</code></td>
<td>
<p><code>GroupCondition</code> object or list of up to two of them. Mandatory
for <em>object</em> method and <em>csv</em> method if no <code>cond_file</code> is provided. If provided
while using <em>json</em> method, original <code>GroupConditions</code> will be ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>ScoringTable</code> object
</p>


<h3>See Also</h3>

<p>export_ScoringTable
</p>
<p>Other import/export functions: 
<code><a href="#topic+export_ScaleSpec">export_ScaleSpec</a>()</code>,
<code><a href="#topic+export_ScoringTable">export_ScoringTable</a>()</code>,
<code><a href="#topic+import_ScaleSpec">import_ScaleSpec</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Scoring table to export / import #

Consc_ST &lt;- 
  GroupedFrequencyTable(
    data = IPIP_NEO_300,
    conditions = GroupConditions("Sex", "M" ~ sex == "M", "F" ~ sex == "F"), 
    var = "C") |&gt;
  GroupedScoreTable(scale = STEN) |&gt;
  to_ScoringTable(min_raw = 60, max_raw = 300)

#### Export/import method: csv ####

scoretable_csv &lt;- tempfile(fileext = ".csv")
conditions_csv &lt;- tempfile(fileext = ".csv")

export_ScoringTable(
  table = Consc_ST,
  out_file = scoretable_csv,
  method = "csv",
  cond_file = conditions_csv
)

## check if these are regular csv files
writeLines(head(readLines(scoretable_csv)))
writeLines(head(readLines(conditions_csv)))

imported_from_csv &lt;- import_ScoringTable(
  source = scoretable_csv,
  method = "csv",
  cond_file = conditions_csv
)

all.equal(Consc_ST, imported_from_csv)

#### Export/import method: json ####
scoretable_json &lt;- tempfile(fileext = ".json")

export_ScoringTable(
  table = Consc_ST,
  out_file = scoretable_json,
  method = "json"
)

## check if this is regular json file
writeLines(head(readLines(scoretable_json)))

imported_from_json &lt;- import_ScoringTable(
  source = scoretable_json,
  method = "json"
)

all.equal(Consc_ST, imported_from_json)
</code></pre>

<hr>
<h2 id='intersect_GroupAssignment'>Intersect two GroupAssignment</h2><span id='topic+intersect_GroupAssignment'></span>

<h3>Description</h3>

<p>You can intersect two GroupAssignment with this function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>intersect_GroupAssignment(
  GA1,
  GA2,
  force_disjoint = TRUE,
  force_exhaustive = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="intersect_GroupAssignment_+3A_ga1">GA1</code>, <code id="intersect_GroupAssignment_+3A_ga2">GA2</code></td>
<td>
<p><em>GroupAssignment</em> objects to intersect. No previously intersected
objects can be intersected again.</p>
</td></tr>
<tr><td><code id="intersect_GroupAssignment_+3A_force_disjoint">force_disjoint</code></td>
<td>
<p><em>boolean</em> indicating if groups disjointedness should be
forced in case when one observation would end in multiple intersections.
If <code>TRUE</code>, observation will remain only in the first intersection to which
it will be assigned. Default to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="intersect_GroupAssignment_+3A_force_exhaustive">force_exhaustive</code></td>
<td>
<p><em>boolean</em> indicating if elements that are not assigned
to any of the intersecting groups should be gathered together in <code>.NA:.NA</code> group</p>
</td></tr>
</table>


<h3>Value</h3>

<p><em>GroupAssignment</em> object with intersected groups.
</p>


<h3>See Also</h3>

<p>Other observation grouping functions: 
<code><a href="#topic+GroupAssignment">GroupAssignment</a>()</code>,
<code><a href="#topic+extract_observations">extract_observations</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sex_grouping &lt;- GroupConditions(
  conditions_category = "Sex",
  "M" ~ sex == "M",
  "F" ~ sex == "F",
  "O" ~ !sex %in% c("M", "F")
)

age_grouping &lt;- GroupConditions(
  conditions_category = "Age",
  "to 20" ~ age &lt; 20,
  "20 to 40" ~ age &gt;= 20 &amp; age &lt;= 40,
  "40 to 60" ~ age &gt;= 40 &amp; age &lt; 60,
  force_exhaustive = TRUE,
  force_disjoint = FALSE
)

# intersect two distinct GroupAssignements

intersected &lt;- intersect_GroupAssignment(
  GA1 = GroupAssignment(HEXACO_60, sex_grouping),
  GA2 = GroupAssignment(HEXACO_60, age_grouping),
  force_exhaustive = TRUE,
  force_disjoint = FALSE
)

summary(intersected)

</code></pre>

<hr>
<h2 id='IPIP_NEO_300'>Sample data of IPIP-NEO-300 questionnaire results</h2><span id='topic+IPIP_NEO_300'></span>

<h3>Description</h3>

<p>Dataset containing sample of 13198 results of IPIP-NEO-300 results from
Johnson J.A. study published at 2014, preprocessed using <code><a href="#topic+sum_items_to_scale">sum_items_to_scale()</a></code>
function. It contains many observations of different ages and sexes, also
including <code>NA</code> values, whenever at least one of the underlying item scores were
missing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>IPIP_NEO_300
</code></pre>


<h3>Format</h3>

<p>A data frame with 13198 rows and 7 variables
</p>

<dl>
<dt>sex</dt><dd><p>sex of the participant ('M'ale or 'F'emale)</p>
</dd>
<dt>age</dt><dd><p>age of the participant (10&ndash;98)</p>
</dd>
<dt>N</dt><dd><p>Raw score for Neuroticism scale (63&ndash;292)</p>
</dd>
<dt>E</dt><dd><p>Raw score for Extraversion scale (80&ndash;296)</p>
</dd>
<dt>O</dt><dd><p>Raw score for Openness to Experience (76&ndash;298)</p>
</dd>
<dt>A</dt><dd><p>Raw score for Agreeableness (66&ndash;292)</p>
</dd>
<dt>C</dt><dd><p>Raw score for Consciousness (81&ndash;299)</p>
</dd>
</dl>



<h3>References</h3>

<p>Johnson, J. A. (2014). Measuring thirty facets of the five factor model with a
120-item public domain inventory: Development of the IPIP-NEO-120.
Journal of Research in Personality, 51, 78-89.
</p>

<hr>
<h2 id='is_stenR_classes'>Checkers for stenR S3 and R6 classes</h2><span id='topic+is_stenR_classes'></span><span id='topic+is.GroupConditions'></span><span id='topic+is.GroupAssignment'></span><span id='topic+is.intersected'></span><span id='topic+is.ScaleSpec'></span><span id='topic+is.CombScaleSpec'></span><span id='topic+is.FrequencyTable'></span><span id='topic+is.GroupedFrequencyTable'></span><span id='topic+is.ScoreTable'></span><span id='topic+is.GroupedScoreTable'></span><span id='topic+is.ScoringTable'></span><span id='topic+is.StandardScale'></span><span id='topic+is.Simulated'></span>

<h3>Description</h3>

<p>Various functions to check if given <span class="rlang"><b>R</b></span> object is of given class. Additionally:
</p>

<ul>
<li> <p><code>is.intersected()</code> checks if the <code>GroupAssignment</code> object have been created
with <code><a href="#topic+intersect_GroupAssignment">intersect_GroupAssignment()</a></code> and <code>GroupedFrequencyTable</code>,
<code>GroupedScoreTable</code> or <code>ScoringTable</code> have been created with two <code>GroupConditions</code>
objects.
</p>
</li>
<li> <p><code>is.Simulated()</code> checks if the <code>FrequencyTable</code> or <code>ScoreTable</code> have been
created on basis of simulated distribution (based on <code><a href="#topic+SimFrequencyTable">SimFrequencyTable()</a></code>)
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>is.GroupConditions(x)

is.GroupAssignment(x)

is.intersected(x)

is.ScaleSpec(x)

is.CombScaleSpec(x)

is.FrequencyTable(x)

is.GroupedFrequencyTable(x)

is.Simulated(x)

is.ScoreTable(x)

is.GroupedScoreTable(x)

is.ScoringTable(x)

is.StandardScale(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is_stenR_classes_+3A_x">x</code></td>
<td>
<p>any <span class="rlang"><b>R</b></span> object</p>
</td></tr>
</table>

<hr>
<h2 id='mockNAtable'>Mockup NA table</h2><span id='topic+mockNAtable'></span>

<h3>Description</h3>

<p>Creates mockup table if none is available for given group. Used in
<code><a href="#topic+normalize_scores_grouped">normalize_scores_grouped()</a></code>. All results passed through it will have their values
&quot;normalized&quot; into <code>NA</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mockNAtable(table)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mockNAtable_+3A_table">table</code></td>
<td>
<p>Table to mockup</p>
</td></tr>
</table>

<hr>
<h2 id='normalize_score'>Normalize raw scores</h2><span id='topic+normalize_score'></span>

<h3>Description</h3>

<p>Use computed <code>FrequencyTable</code> or <code>ScoreTable</code> to normalize the
provided raw scores.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>normalize_score(x, table, what)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="normalize_score_+3A_x">x</code></td>
<td>
<p>vector of raw scores to normalize</p>
</td></tr>
<tr><td><code id="normalize_score_+3A_table">table</code></td>
<td>
<p><code>FrequencyTable</code> or <code>ScoreTable</code> object</p>
</td></tr>
<tr><td><code id="normalize_score_+3A_what">what</code></td>
<td>
<p>the values to get. One of either:
</p>

<ul>
<li> <p><code>quan</code> - the quantile of x in the raw score distribution
</p>
</li>
<li> <p><code>Z</code> - normalized Z score for the x raw score
</p>
</li>
<li><p> name of the scale calculated in <code>ScoreTable</code> provided to <code>table</code> argument
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric vector with values specified in <code>what</code> argument
</p>


<h3>See Also</h3>

<p>Other score-normalization functions: 
<code><a href="#topic+normalize_scores_df">normalize_scores_df</a>()</code>,
<code><a href="#topic+normalize_scores_grouped">normalize_scores_grouped</a>()</code>,
<code><a href="#topic+normalize_scores_scoring">normalize_scores_scoring</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># normalize with FrequencyTable
suppressMessages(
  ft &lt;- FrequencyTable(HEXACO_60$HEX_H)
)

normalize_score(HEXACO_60$HEX_H[1:5], ft, what = "Z")

# normalize with ScoreTable
st &lt;- ScoreTable(ft, list(STEN, STANINE))

normalize_score(HEXACO_60$HEX_H[1:5], st, what = "sten")
normalize_score(HEXACO_60$HEX_H[1:5], st, what = "stanine")
</code></pre>

<hr>
<h2 id='normalize_scores_df'>Normalize raw scores for multiple variables</h2><span id='topic+normalize_scores_df'></span>

<h3>Description</h3>

<p>Wrapper for <code><a href="#topic+normalize_score">normalize_score()</a></code> that works on data frame
and multiple variables
</p>


<h3>Usage</h3>

<pre><code class='language-R'>normalize_scores_df(data, vars, ..., what, retain = FALSE, .dots = list())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="normalize_scores_df_+3A_data">data</code></td>
<td>
<p><code>data.frame</code> containing raw scores</p>
</td></tr>
<tr><td><code id="normalize_scores_df_+3A_vars">vars</code></td>
<td>
<p>names of columns to normalize. Length of <code>vars</code>
need to be the same as number of tables provided to either <code>...</code> or <code>.dots</code></p>
</td></tr>
<tr><td><code id="normalize_scores_df_+3A_...">...</code></td>
<td>
<p><code>ScoreTable</code> or <code>FrequencyTable</code> objects to be used for normalization</p>
</td></tr>
<tr><td><code id="normalize_scores_df_+3A_what">what</code></td>
<td>
<p>the values to get. One of either:
</p>

<ul>
<li> <p><code>quan</code> - the quantile of x in the raw score distribution
</p>
</li>
<li> <p><code>Z</code> - normalized Z score for the x raw score
</p>
</li>
<li><p> name of the scale calculated in <code>ScoreTables</code> provided to <code>...</code> or
<code>.dots</code> argument
</p>
</li></ul>
</td></tr>
<tr><td><code id="normalize_scores_df_+3A_retain">retain</code></td>
<td>
<p>either boolean: <code>TRUE</code> if all columns in the <code>data</code> are to be
retained, <code>FALSE</code> if none; or character vector with names of columns to be retained</p>
</td></tr>
<tr><td><code id="normalize_scores_df_+3A_.dots">.dots</code></td>
<td>
<p><code>ScoreTable</code> or <code>FrequencyTable</code> objects provided as a list,
instead of individually in <code>...</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>data.frame</code> with normalized scores
</p>


<h3>See Also</h3>

<p>Other score-normalization functions: 
<code><a href="#topic+normalize_scores_grouped">normalize_scores_grouped</a>()</code>,
<code><a href="#topic+normalize_scores_scoring">normalize_scores_scoring</a>()</code>,
<code><a href="#topic+normalize_score">normalize_score</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># normalize multiple variables with FrequencyTable
suppressMessages({
  ft_H &lt;- FrequencyTable(HEXACO_60$HEX_H)
  ft_E &lt;- FrequencyTable(HEXACO_60$HEX_E)
  ft_X &lt;- FrequencyTable(HEXACO_60$HEX_X)
})

normalize_scores_df(data = head(HEXACO_60), 
                    vars = c("HEX_H", "HEX_E", "HEX_X"),
                    ft_H,
                    ft_E,
                    ft_X,
                    what = "quan")

# normalize multiple variables with ScoreTable
st_H &lt;- ScoreTable(ft_H, STEN)
st_E &lt;- ScoreTable(ft_E, STEN)
st_X &lt;- ScoreTable(ft_X, STEN)

normalize_scores_df(data = head(HEXACO_60), 
                    vars = c("HEX_H", "HEX_E", "HEX_X"),
                    st_H,
                    st_E,
                    st_X,
                    what = "sten")
</code></pre>

<hr>
<h2 id='normalize_scores_grouped'>Normalize scores using GroupedFrequencyTables or GroupedScoreTables</h2><span id='topic+normalize_scores_grouped'></span>

<h3>Description</h3>

<p>Normalize scores using either <code>GroupedFrequencyTable</code> or
<code>GroupedScoreTable</code> for one or more variables. Given data.frame should also
contain columns used in <code>GroupingConditions</code> attached to the table
</p>


<h3>Usage</h3>

<pre><code class='language-R'>normalize_scores_grouped(
  data,
  vars,
  ...,
  what,
  retain = FALSE,
  group_col = NULL,
  .dots = list()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="normalize_scores_grouped_+3A_data">data</code></td>
<td>
<p>data.frame object containing raw scores</p>
</td></tr>
<tr><td><code id="normalize_scores_grouped_+3A_vars">vars</code></td>
<td>
<p>names of columns to normalize. Length of vars
need to be the same as number of tables provided to either <code>...</code> or <code>.dots</code></p>
</td></tr>
<tr><td><code id="normalize_scores_grouped_+3A_...">...</code></td>
<td>
<p><code>GroupedFrequencyTable</code> or <code>GroupedScoreTable</code> objects to be used
for normalization. They should be provided in the same order as <code>vars</code></p>
</td></tr>
<tr><td><code id="normalize_scores_grouped_+3A_what">what</code></td>
<td>
<p>the values to get. One of either:
</p>

<ul>
<li> <p><code>quan</code> - the quantile of x in the raw score distribution
</p>
</li>
<li> <p><code>Z</code> - normalized Z score for the x raw score
</p>
</li>
<li><p> name of the scale calculated in <code>GroupedScoreTables</code> provided to <code>...</code> or
<code>.dots</code> argument
</p>
</li></ul>
</td></tr>
<tr><td><code id="normalize_scores_grouped_+3A_retain">retain</code></td>
<td>
<p>either boolean: <code>TRUE</code> if all columns in the <code>data</code> are to be
retained, <code>FALSE</code> if none; or character vector with names of columns to be retained</p>
</td></tr>
<tr><td><code id="normalize_scores_grouped_+3A_group_col">group_col</code></td>
<td>
<p>name of the column for name of the group each
observation was qualified into. If left as default <code>NULL</code>, they won't be returned.</p>
</td></tr>
<tr><td><code id="normalize_scores_grouped_+3A_.dots">.dots</code></td>
<td>
<p><code>GroupedFrequencyTable</code> or <code>GroupedScoreTable</code> objects provided
as a list, instead of individually in <code>...</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.frame with normalized scores
</p>


<h3>See Also</h3>

<p>Other score-normalization functions: 
<code><a href="#topic+normalize_scores_df">normalize_scores_df</a>()</code>,
<code><a href="#topic+normalize_scores_scoring">normalize_scores_scoring</a>()</code>,
<code><a href="#topic+normalize_score">normalize_score</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># setup - create necessary objects #
suppressMessages({
  age_grouping &lt;- GroupConditions(
    conditions_category = "Age",
    "below 22" ~ age &lt; 22,
    "23-60" ~ age &gt;= 23 &amp; age &lt;= 60,
    "above 60" ~ age &gt; 60
  )
  sex_grouping &lt;- GroupConditions(
    conditions_category = "Sex",
    "Male" ~ sex == "M",
    "Female" ~ sex == "F"
  )
  NEU_gft &lt;- GroupedFrequencyTable(
    data = IPIP_NEO_300,
    conditions = list(age_grouping, sex_grouping),
    var = "N"
  )
  NEU_gst &lt;- GroupedScoreTable(
    NEU_gft,
    scale = list(STEN, STANINE)
  )
})

#### normalize scores ####
# to Z score or quantile using GroupedFrequencyTable
normalized_to_quan &lt;- normalize_scores_grouped(
  IPIP_NEO_300,
  vars = "N",
  NEU_gft,
  what = "quan",
  retain = c("sex", "age")
)

# only 'sex' and 'age' are retained
head(normalized_to_quan)

# to StandardScale attached to GroupedScoreTable
normalized_to_STEN &lt;- normalize_scores_grouped(
  IPIP_NEO_300,
  vars = "N",
  NEU_gst,
  what = "stanine",
  retain = FALSE,
  group_col = "sex_age_group"
)

# none is retained, 'sex_age_group' is created
head(normalized_to_STEN)
</code></pre>

<hr>
<h2 id='normalize_scores_scoring'>Normalize scores using ScoringTables</h2><span id='topic+normalize_scores_scoring'></span>

<h3>Description</h3>

<p>Normalize scores using either <code>ScoringTable</code> objects for one or
more variables. Given data.frame should also contain columns used in
<code>GroupingConditions</code> attached to the table (if any)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>normalize_scores_scoring(
  data,
  vars,
  ...,
  retain = FALSE,
  group_col = NULL,
  .dots = list()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="normalize_scores_scoring_+3A_data">data</code></td>
<td>
<p>data.frame containing raw scores</p>
</td></tr>
<tr><td><code id="normalize_scores_scoring_+3A_vars">vars</code></td>
<td>
<p>names of columns to normalize. Length of vars
need to be the same as number of tables provided to either <code>...</code> or <code>.dots</code></p>
</td></tr>
<tr><td><code id="normalize_scores_scoring_+3A_...">...</code></td>
<td>
<p><code>ScoringTable</code> objects to be used for normalization. They should
be provided in the same order as <code>vars</code></p>
</td></tr>
<tr><td><code id="normalize_scores_scoring_+3A_retain">retain</code></td>
<td>
<p>either boolean: <code>TRUE</code> if all columns in the <code>data</code> are to be
retained, <code>FALSE</code> if none; or names of columns to be retained</p>
</td></tr>
<tr><td><code id="normalize_scores_scoring_+3A_group_col">group_col</code></td>
<td>
<p>name of the column for name of the group each
observation was qualified into. If left as default <code>NULL</code>, they won't be returned.
Ignored if no conditions are available</p>
</td></tr>
<tr><td><code id="normalize_scores_scoring_+3A_.dots">.dots</code></td>
<td>
<p><code>ScoringTable</code> objects provided as a list, instead of individually in <code>...</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.frame with normalized scores
</p>


<h3>See Also</h3>

<p>Other score-normalization functions: 
<code><a href="#topic+normalize_scores_df">normalize_scores_df</a>()</code>,
<code><a href="#topic+normalize_scores_grouped">normalize_scores_grouped</a>()</code>,
<code><a href="#topic+normalize_score">normalize_score</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Scoring table to export / import #
suppressMessages(
  Consc_ST &lt;- 
    GroupedFrequencyTable(
      data = IPIP_NEO_300,
      conditions = GroupConditions("Sex", "M" ~ sex == "M", "F" ~ sex == "F"), 
      var = "C") |&gt;
    GroupedScoreTable(scale = STEN) |&gt;
    to_ScoringTable(min_raw = 60, max_raw = 300)
)

# normalize scores
Consc_norm &lt;- 
  normalize_scores_scoring(
    data = IPIP_NEO_300,
    vars = "C",
    Consc_ST,
    group_col = "Group"
  )

str(Consc_norm)
</code></pre>

<hr>
<h2 id='plot.GroupedFrequencyTable'>Gerenic plot of the GroupedFrequencyTable</h2><span id='topic+plot.GroupedFrequencyTable'></span>

<h3>Description</h3>

<p>Generic plot using <code>ggplot2</code>. It plots FrequencyTables for all
groups by default, or only chosen ones using when <code>group_names</code> argument is specified.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'GroupedFrequencyTable'
plot(
  x,
  group_names = NULL,
  strict_names = TRUE,
  plot_grid = is.intersected(x),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.GroupedFrequencyTable_+3A_x">x</code></td>
<td>
<p>A <code>GroupedFrequencyTable</code> object</p>
</td></tr>
<tr><td><code id="plot.GroupedFrequencyTable_+3A_group_names">group_names</code></td>
<td>
<p>vector specifying which groups should appear in the plots</p>
</td></tr>
<tr><td><code id="plot.GroupedFrequencyTable_+3A_strict_names">strict_names</code></td>
<td>
<p>If <code>TRUE</code>, then intersected groups are filtered
using <em>strict</em> strategy: <code>group_names</code> need to be provided in form: <code>"group1:group2"</code>. If
<code>FALSE</code>, then intersected groups will be taken into regard separately, so
eg. when <code>"group1"</code> is provided to <code>group_names</code>, all of: <code>"group1:group2"</code>,
<code>"group1:group3"</code>, <code>"group1:groupN"</code>  will be plotted. Defaults to <code>TRUE</code></p>
</td></tr>
<tr><td><code id="plot.GroupedFrequencyTable_+3A_plot_grid">plot_grid</code></td>
<td>
<p>boolean indicating if the <code><a href="ggplot2.html#topic+facet_grid">ggplot2::facet_grid()</a></code> should be used.
If <code>FALSE</code>, then <code><a href="ggplot2.html#topic+facet_wrap">ggplot2::facet_wrap()</a></code> is used. If groups are not intersected,
then it will be ignored and <code>facet_wrap</code> will be used.</p>
</td></tr>
<tr><td><code id="plot.GroupedFrequencyTable_+3A_...">...</code></td>
<td>
<p>named list of additional arguments passed to <code>facet</code> function
used.</p>
</td></tr>
</table>

<hr>
<h2 id='plot.GroupedScoreTable'>Gerenic plot of the GroupedScoreTable</h2><span id='topic+plot.GroupedScoreTable'></span>

<h3>Description</h3>

<p>Generic plot using <code>ggplot2</code>. It plots ScoreTables for all
groups by default, or only chosen ones using when <code>group_names</code> argument is specified.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'GroupedScoreTable'
plot(
  x,
  scale_name = NULL,
  group_names = NULL,
  strict_names = TRUE,
  plot_grid = is.intersected(x),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.GroupedScoreTable_+3A_x">x</code></td>
<td>
<p>A <code>GroupedScoreTable</code> object</p>
</td></tr>
<tr><td><code id="plot.GroupedScoreTable_+3A_scale_name">scale_name</code></td>
<td>
<p>if scores for multiple scales available, provide the name
of the scale for plotting.</p>
</td></tr>
<tr><td><code id="plot.GroupedScoreTable_+3A_group_names">group_names</code></td>
<td>
<p>names specifying which groups should appear in the plots</p>
</td></tr>
<tr><td><code id="plot.GroupedScoreTable_+3A_strict_names">strict_names</code></td>
<td>
<p>If <code>TRUE</code>, then intersected groups are filtered
using <em>strict</em> strategy: <code>group_names</code> need to be provided in form: <code>"group1:group2"</code>. If
<code>FALSE</code>, then intersected groups will be taken into regard separately, so
eg. when <code>"group1"</code> is provided to <code>group_names</code>, all of: <code>"group1:group2"</code>,
<code>"group1:group3"</code>, <code>"group1:groupN"</code>  will be plotted. Defaults to <code>TRUE</code></p>
</td></tr>
<tr><td><code id="plot.GroupedScoreTable_+3A_plot_grid">plot_grid</code></td>
<td>
<p>boolean indicating if the <code><a href="ggplot2.html#topic+facet_grid">ggplot2::facet_grid()</a></code> should be used.
If <code>FALSE</code>, then <code><a href="ggplot2.html#topic+facet_wrap">ggplot2::facet_wrap()</a></code> is used. If groups are not intersected,
then it will be ignored and <code>facet_wrap</code> will be used.</p>
</td></tr>
<tr><td><code id="plot.GroupedScoreTable_+3A_...">...</code></td>
<td>
<p>named list of additional arguments passed to <code>facet</code> function.</p>
</td></tr>
</table>

<hr>
<h2 id='qualify_to_groups'>Qualify observations to groups for normalization</h2><span id='topic+qualify_to_groups'></span>

<h3>Description</h3>

<p>Function used internally in <code><a href="#topic+normalize_scores_grouped">normalize_scores_grouped()</a></code> and
<code><a href="#topic+normalize_scores_scoring">normalize_scores_scoring()</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qualify_to_groups(data, conditions)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="qualify_to_groups_+3A_data">data</code></td>
<td>
<p>Data with observations to group by</p>
</td></tr>
<tr><td><code id="qualify_to_groups_+3A_conditions">conditions</code></td>
<td>
<p>GroupConditions passed to normalization function</p>
</td></tr>
</table>

<hr>
<h2 id='ScaleSpec'>Scale Specification object</h2><span id='topic+ScaleSpec'></span><span id='topic+print.ScaleSpec'></span><span id='topic+summary.ScaleSpec'></span>

<h3>Description</h3>

<p>Object containing scale or factor specification data. It describes
the scale or factor, with regard to which items from the source data are part
of it, which need to be summed with reverse scoring, and how to handle <code>NA</code>s.
To be used with <code><a href="#topic+sum_items_to_scale">sum_items_to_scale()</a></code> function to preprocess item data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ScaleSpec(
  name,
  item_names,
  min,
  max,
  reverse = character(0),
  na_strategy = c("asis", "mean", "median", "mode"),
  na_value = as.integer(NA),
  na_value_custom
)

## S3 method for class 'ScaleSpec'
print(x, ...)

## S3 method for class 'ScaleSpec'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ScaleSpec_+3A_name">name</code></td>
<td>
<p>character with name of the scale/factor</p>
</td></tr>
<tr><td><code id="ScaleSpec_+3A_item_names">item_names</code></td>
<td>
<p>character vector containing names of the items that the
scale/factor consists of.</p>
</td></tr>
<tr><td><code id="ScaleSpec_+3A_min">min</code>, <code id="ScaleSpec_+3A_max">max</code></td>
<td>
<p>integer containing the default minimal/maximal value that the
answer to the item can be scored as.</p>
</td></tr>
<tr><td><code id="ScaleSpec_+3A_reverse">reverse</code></td>
<td>
<p>character vector containing names of the items that need to be
reversed during scale/factor summing. Reversed using the default <code>"min"</code> and
<code>"max"</code> values.</p>
</td></tr>
<tr><td><code id="ScaleSpec_+3A_na_strategy">na_strategy</code></td>
<td>
<p>character vector specifying which strategy should be taken
during filling of <code>NA</code>. Defaults to <code>"asis"</code> and, other options are <code>"mean"</code>,
<code>"median"</code> and <code>"mode"</code>. Strategies are explained in the details section.</p>
</td></tr>
<tr><td><code id="ScaleSpec_+3A_na_value">na_value</code></td>
<td>
<p>integer value to be input in missing values as default.
Defaults to <code>as.integer(NA)</code>.</p>
</td></tr>
<tr><td><code id="ScaleSpec_+3A_na_value_custom">na_value_custom</code></td>
<td>
<p>if there are any need for specific questions be gives
specific values in place of <code>NA</code>s, provide a named integer vector there. Names
should be the names of the questons.</p>
</td></tr>
<tr><td><code id="ScaleSpec_+3A_x">x</code></td>
<td>
<p>a <code>ScaleSpec</code> object</p>
</td></tr>
<tr><td><code id="ScaleSpec_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
<tr><td><code id="ScaleSpec_+3A_object">object</code></td>
<td>
<p>a <code>ScaleSpec</code> object</p>
</td></tr>
</table>


<h3>Details</h3>



<h4>NA imputation</h4>

<p>it specifies how <code>NA</code> values should be treated during <code><a href="#topic+sum_items_to_scale">sum_items_to_scale()</a></code>
function run.
<strong>asis</strong> strategy is literal: the values specified in <code>na_value</code> or <code>na_value_custom</code>
will be used without any changes.
<strong>mean</strong>, <strong>median</strong> and <strong>mode</strong> are functional strategies. They work on a
rowwise basis, so the appropriate value for every observation will be used.
If there are no values provided to check for the <em>mean</em>, <em>median</em> or <em>mode</em>,
the value provided in <code>na_value</code> or <code>na_value_custom</code> will be used. The
values of <em>mean</em> and <em>median</em> will be rounded before imputation.
</p>



<h4>Order of operations</h4>


<ul>
<li><p> item reversion
</p>
</li>
<li><p> functional <code>NA</code>s imputation
</p>
</li>
<li><p> literal <code>NA</code>s imputation
</p>
</li></ul>




<h3>Value</h3>

<p>object of <code>ScaleSpec</code> class
</p>
<p>data.frame of item names, if they are reversed, and custom NA value if available, invisibly
</p>


<h3>See Also</h3>

<p>Other item preprocessing functions: 
<code><a href="#topic+CombScaleSpec">CombScaleSpec</a>()</code>,
<code><a href="#topic+sum_items_to_scale">sum_items_to_scale</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># simple scale specification

simple_scaleSpec &lt;- ScaleSpec(
  name = "simple",
  # scale consists of 5 items
  item_names = c("item_1", "item_2", "item_3", "item_4", "item_5"),
  # item scores can take range of values: 1-5
  min = 1,
  max = 5,
  # item 2 and 5 need to be reversed
  reverse = c("item_2", "item_5"))

print(simple_scaleSpec)

# scale specification with literal NA imputation strategy 

asis_scaleSpec &lt;- ScaleSpec(
  name = "w_asis",
  item_names = c("item_1", "item_2", "item_3", "item_4", "item_5"),
  min = 1,
  max = 5,
  reverse = "item_2",
  # na values by default will be filled with `3`
  na_value = 3,
  # except for item_4, where they will be filled with `2`
  na_value_custom = c(item_4 = 2)
)

print(asis_scaleSpec)

# scale specification with functional NA imputation strategy

func_scaleSpec &lt;- ScaleSpec(
  name = "w_func",
  item_names = c("item_1", "item_2", "item_3", "item_4", "item_5"),
  min = 1,
  max = 5,
  reverse = "item_2",
  # strategies available are 'mean', 'median' and 'mode'
  na_strategy = "mean"
)

print(func_scaleSpec)
</code></pre>

<hr>
<h2 id='ScoreTable'>Create a ScoreTable</h2><span id='topic+ScoreTable'></span><span id='topic+print.ScoreTable'></span><span id='topic+plot.ScoreTable'></span>

<h3>Description</h3>

<p>Creates a table to calculate scores in specified standardized
scale for each discrete raw score. Uses normalization provided by
<code><a href="#topic+FrequencyTable">FrequencyTable()</a></code> and scale definition created with
<code><a href="#topic+StandardScale">StandardScale()</a></code>.
</p>
<p>After creation it can be used to normalize and standardize raw scores with
<code><a href="#topic+normalize_score">normalize_score()</a></code> or <code><a href="#topic+normalize_scores_df">normalize_scores_df()</a></code>.
</p>
<p><code><a href="#topic+plot.ScoreTable">plot.ScoreTable()</a></code> method requires <code>ggplot2</code> package to be installed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ScoreTable(ft, scale)

## S3 method for class 'ScoreTable'
print(x, ...)

## S3 method for class 'ScoreTable'
plot(x, scale_name = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ScoreTable_+3A_ft">ft</code></td>
<td>
<p>a <code>FrequencyTable</code> object</p>
</td></tr>
<tr><td><code id="ScoreTable_+3A_scale">scale</code></td>
<td>
<p>a <code>StandardScale</code> object or list of multiple <code>StandardScale</code> objects</p>
</td></tr>
<tr><td><code id="ScoreTable_+3A_x">x</code></td>
<td>
<p>a <code>ScoreTable</code> object</p>
</td></tr>
<tr><td><code id="ScoreTable_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods</p>
</td></tr>
<tr><td><code id="ScoreTable_+3A_scale_name">scale_name</code></td>
<td>
<p>if scores for multiple scales available, provide the name
of the scale for plotting.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>object of class <code>ScoreTable</code>. Consists of:
</p>

<ul>
<li><p> table: data.frame containing for each point in the raw score:
</p>

<ul>
<li><p> number of observations (<code>n</code>),
</p>
</li>
<li><p> frequency in sample (<code>freq</code>),
</p>
</li>
<li><p> quantile (<code>quan</code>),
</p>
</li>
<li><p> normalized Z-score (<code>Z</code>),
</p>
</li>
<li><p> score transformed to every of provided <code>StandardScales</code>
</p>
</li></ul>

</li>
<li><p> status: list containing the total number of simulated observations (<code>n</code>)
and information about raw scores range completion (<code>range</code>): complete or incomplete
</p>
</li>
<li><p> scale: named list of all attached <code>StandardScale</code> objects \
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># firstly compute FrequencyTable for a variable
ft &lt;- FrequencyTable(HEXACO_60$HEX_A)

# then create a ScoreTable
st &lt;- ScoreTable(ft, STEN)

# ScoreTable is ready to use!
st
</code></pre>

<hr>
<h2 id='SimFrequencyTable'>Generate FrequencyTable using simulated distribution</h2><span id='topic+SimFrequencyTable'></span>

<h3>Description</h3>

<p>It is always best to use raw scores for computing the <code>FrequencyTable</code>.
They aren't always available - in that case, this function can be used
to simulate the distribution given its descriptive statistics.
</p>
<p>This simulation should be always treated as an estimate.
</p>
<p>The distribution is generated using the <strong>Fleishmann</strong> method from
<code><a href="SimMultiCorrData.html#topic+nonnormvar1">SimMultiCorrData::nonnormvar1()</a></code> function. The
<code>SimMultiCorrData</code> package needs to be installed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SimFrequencyTable(min, max, M, SD, skew = 0, kurt = 3, n = 10000, seed = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="SimFrequencyTable_+3A_min">min</code></td>
<td>
<p>minimum value of raw score</p>
</td></tr>
<tr><td><code id="SimFrequencyTable_+3A_max">max</code></td>
<td>
<p>maximum value of raw score</p>
</td></tr>
<tr><td><code id="SimFrequencyTable_+3A_m">M</code></td>
<td>
<p>mean of the raw scores distribution</p>
</td></tr>
<tr><td><code id="SimFrequencyTable_+3A_sd">SD</code></td>
<td>
<p>standard deviation of the raw scores distribution</p>
</td></tr>
<tr><td><code id="SimFrequencyTable_+3A_skew">skew</code></td>
<td>
<p>skewness of the raw scores distribution. Defaults to <code>0</code> for
normal distribution</p>
</td></tr>
<tr><td><code id="SimFrequencyTable_+3A_kurt">kurt</code></td>
<td>
<p>kurtosis of the raw scores distribution. Defaults to <code>3</code> for
normal distribution</p>
</td></tr>
<tr><td><code id="SimFrequencyTable_+3A_n">n</code></td>
<td>
<p>number of observations to simulate. Defaults to <code>10000</code>, but greater
values could be used to generate better estimates. Final number of observations
in the generated Frequency Table may be less - all values lower than <code>min</code> and
higher than <code>max</code> are filtered out.</p>
</td></tr>
<tr><td><code id="SimFrequencyTable_+3A_seed">seed</code></td>
<td>
<p>the seed value for random number generation</p>
</td></tr>
</table>


<h3>Value</h3>

<p>FrequencyTable object created with simulated data. Consists of:
</p>

<ul>
<li><p> table: data.frame with number of observations (<code>n</code>), frequency in sample
(<code>freq</code>), quantile (<code>quan</code>) and normalized Z-score (<code>Z</code>) for each point in
raw score
</p>
</li>
<li><p> status: list containing the total number of simulated observations (<code>n</code>)
and information about raw scores range completion (<code>range</code>): complete or incomplete
</p>
</li></ul>


<hr>
<h2 id='SLCS'>Sample data of SLCS questionnaire results</h2><span id='topic+SLCS'></span>

<h3>Description</h3>

<p>Dataset containing individual items answers of SLCS questionnaire. They
were obtained during 2020 study on Polish incidental sample.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SLCS
</code></pre>


<h3>Format</h3>

<p>A data frame with 103 rows and 19 variables
</p>

<dl>
<dt>user_id</dt><dd><p>identity anonimized with 'ids::adjective_animal'</p>
</dd>
<dt>sex</dt><dd><p>sex of the participant ('M'ale, 'F'emale or 'O'ther)</p>
</dd>
<dt>age</dt><dd><p>age of the participant (15&ndash;68)</p>
</dd>
<dt>SLCS_1, SLCS_2, SLCS_3, SLCS_4, SLCS_5, SLCS_6, SLCS_7, SLCS_8, SLCS_9, SLCS_10,
SLCS_11, SLCS_12, SLCS_13, SLCS_14, SLCS_15, SLCS_16</dt><dd><p>Score for each of measure items. (1&ndash;5)</p>
</dd>
</dl>



<h3>Details</h3>

<p>All SLCS item responses can take integer values 1-5. The measure consists
of two sub-scales: Self-Liking and Self-Competence, and the General Score
can also be calculated. Below are the item numbers that are used for each
sub-scale (<code>R</code> near the number means that the item need to be reversed.)
</p>

<ul>
<li><p> Self-Liking: 1R, 3, 5, 6R, 7R, 9, 11, 15R
</p>
</li>
<li><p> Self-Competence: 2, 4, 8R, 10R, 12, 13R, 14, 16
</p>
</li>
<li><p> General Score: All of the above items (they need to be reversed as in sub-scales)
</p>
</li></ul>


<hr>
<h2 id='StandardScale'>Specify standard scale</h2><span id='topic+StandardScale'></span><span id='topic+print.StandardScale'></span><span id='topic+plot.StandardScale'></span>

<h3>Description</h3>

<p><code>StandardScale</code> objects are used with <code><a href="#topic+ScoreTable">ScoreTable()</a></code> or
<code><a href="#topic+GroupedScoreTable">GroupedScoreTable()</a></code> objects to recalculate <code><a href="#topic+FrequencyTable">FrequencyTable()</a></code> or
<code><a href="#topic+GroupedFrequencyTable">GroupedFrequencyTable()</a></code> into some standardized scale score.
</p>
<p>There are few <code>StandardScale</code> defaults available.
</p>
<p>Plot method requires <code>ggplot2</code> package to be installed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>StandardScale(name, M, SD, min, max)

## S3 method for class 'StandardScale'
print(x, ...)

## S3 method for class 'StandardScale'
plot(x, n = 1000, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="StandardScale_+3A_name">name</code></td>
<td>
<p>Name of the scale</p>
</td></tr>
<tr><td><code id="StandardScale_+3A_m">M</code></td>
<td>
<p>Mean of the scale</p>
</td></tr>
<tr><td><code id="StandardScale_+3A_sd">SD</code></td>
<td>
<p>Standard deviation of the scale</p>
</td></tr>
<tr><td><code id="StandardScale_+3A_min">min</code></td>
<td>
<p>Minimal value the scale takes</p>
</td></tr>
<tr><td><code id="StandardScale_+3A_max">max</code></td>
<td>
<p>Maximal value the scale takes</p>
</td></tr>
<tr><td><code id="StandardScale_+3A_x">x</code></td>
<td>
<p>a <code>StandardScale</code> object</p>
</td></tr>
<tr><td><code id="StandardScale_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
<tr><td><code id="StandardScale_+3A_n">n</code></td>
<td>
<p>Number of points the plot generates. The higher the number, the more
detailed are the plots. Default to 1000 for nicely detailed plot.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>StandardScale object
</p>

<hr>
<h2 id='strip_ScoreTable'>Revert the ScoreTable back to FrequencyTable object.</h2><span id='topic+strip_ScoreTable'></span>

<h3>Description</h3>

<p>Revert the ScoreTable back to FrequencyTable object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>strip_ScoreTable(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="strip_ScoreTable_+3A_x">x</code></td>
<td>
<p>a <em>ScoreTable</em> object</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># having a ScoreTable object
st &lt;- ScoreTable(FrequencyTable(HEXACO_60$HEX_X), TANINE)
class(st)

# revert it back to the FrequencyTable
ft &lt;- strip_ScoreTable(st)
class(ft)
</code></pre>

<hr>
<h2 id='sum_items_to_scale'>Sum up discrete raw data</h2><span id='topic+sum_items_to_scale'></span>

<h3>Description</h3>

<p>Helper function to sum-up and - if needed - automatically
reverse discrete raw item values to scale or factor that they
are measuring.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sum_items_to_scale(data, ..., retain = FALSE, .dots = list())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sum_items_to_scale_+3A_data">data</code></td>
<td>
<p><code>data.frame</code> object containing numerical values of items data</p>
</td></tr>
<tr><td><code id="sum_items_to_scale_+3A_...">...</code></td>
<td>
<p>objects of class <code>ScaleSpec</code> or <code>CombScaleSpec</code>. If all item names
are found in <code>data</code>, summed items will be available in returned data.frame
as column named as their <code>name</code> value.</p>
</td></tr>
<tr><td><code id="sum_items_to_scale_+3A_retain">retain</code></td>
<td>
<p>either <code>boolean</code>: <code>TRUE</code> if all columns in the <code>data</code> are to be
retained, <code>FALSE</code> if none, or character vector with names of columns to be retained</p>
</td></tr>
<tr><td><code id="sum_items_to_scale_+3A_.dots">.dots</code></td>
<td>
<p><code>ScaleSpec</code> or <code>CombScaleSpec</code> objects provided as a list, instead
of individually in <code>...</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>All summing up of the raw discrete values into scale or factor
score is done according to provided specifications utilizing <code><a href="#topic+ScaleSpec">ScaleSpec()</a></code>
objects. For more information refer to their constructor help page.
</p>


<h3>Value</h3>

<p>object of class <code>data.frame</code>
</p>


<h3>See Also</h3>

<p>Other item preprocessing functions: 
<code><a href="#topic+CombScaleSpec">CombScaleSpec</a>()</code>,
<code><a href="#topic+ScaleSpec">ScaleSpec</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create the Scale Specifications for SLCS dataset
## Self-Liking specification
SL_spec &lt;- ScaleSpec(
  name = "Self-Liking",
  item_names = paste("SLCS", c(1, 3, 5, 6, 7, 9, 11, 15), sep = "_"),
  reverse = paste("SLCS", c(1, 6, 7, 15), sep = "_"),
  min = 1,
  max = 5)

## Self-Competence specification
SC_spec &lt;- ScaleSpec(
  name = "Self-Competence",
  item_names = paste("SLCS", c(2, 4, 8, 10, 12, 13, 14, 16), sep = "_"),
  reverse = paste("SLCS", c(8, 10, 13), sep = "_"),
  min = 1,
  max = 5)

## General Score specification
GS_spec &lt;- CombScaleSpec(
  name = "General Score",
  SL_spec,
  SC_spec)

# Sum the raw item scores to raw scale scores
SLCS_summed &lt;- sum_items_to_scale(SLCS, SL_spec, SC_spec, GS_spec, retain = "user_id")
summary(SLCS_summed)
</code></pre>

<hr>
<h2 id='to_ScoringTable'>Create ScoringTable</h2><span id='topic+to_ScoringTable'></span><span id='topic+to_ScoringTable.ScoreTable'></span><span id='topic+to_ScoringTable.GroupedScoreTable'></span><span id='topic+summary.ScoringTable'></span>

<h3>Description</h3>

<p>ScoringTable is a simple version of <code><a href="#topic+ScoreTable">ScoreTable()</a></code> or <code><a href="#topic+GroupedScoreTable">GroupedScoreTable()</a></code>,
that don't include the <code>FrequencyTable</code> internally. It can be easily
saved to <code>csv</code> or <code>json</code> using <code><a href="#topic+export_ScoringTable">export_ScoringTable()</a></code> and loaded from these
files using <code><a href="#topic+import_ScoringTable">import_ScoringTable()</a></code>.
</p>
<p>When using <code>GroupedScoreTable</code>, the columns will be named the same as the
name of group. If it was created using two <code>GroupCondition</code> object, the names
of columns will be names of the groups seperated by <code>:</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>to_ScoringTable(table, ...)

## S3 method for class 'ScoreTable'
to_ScoringTable(
  table,
  scale = NULL,
  min_raw = NULL,
  max_raw = NULL,
  score_colname = "Score",
  ...
)

## S3 method for class 'GroupedScoreTable'
to_ScoringTable(table, scale = NULL, min_raw = NULL, max_raw = NULL, ...)

## S3 method for class 'ScoringTable'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="to_ScoringTable_+3A_table">table</code></td>
<td>
<p><code>ScoreTable</code> or <code>GroupedScoreTable</code> object</p>
</td></tr>
<tr><td><code id="to_ScoringTable_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
<tr><td><code id="to_ScoringTable_+3A_scale">scale</code></td>
<td>
<p>name of the scale attached in <code>table</code>. If only one
scale is attached, it can be left as default <code>NULL</code></p>
</td></tr>
<tr><td><code id="to_ScoringTable_+3A_min_raw">min_raw</code>, <code id="to_ScoringTable_+3A_max_raw">max_raw</code></td>
<td>
<p>absolute minimum/maximum score that can be received.
If left as default <code>NULL</code>, the minimum/maximum available in the data will be
used.</p>
</td></tr>
<tr><td><code id="to_ScoringTable_+3A_score_colname">score_colname</code></td>
<td>
<p>Name of the column containing the raw scores</p>
</td></tr>
<tr><td><code id="to_ScoringTable_+3A_object">object</code></td>
<td>
<p><code>ScoringTable</code> object</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>ScoringTable</code> object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Extr_ST &lt;- 
  # create FrequencyTable
  FrequencyTable(data = IPIP_NEO_300$E) |&gt;
  # create ScoreTable
  ScoreTable(scale = STEN) |&gt;
  # and transform into ScoringTable
  to_ScoringTable(
    min_raw = 60,
    max_raw = 300
  )

summary(Extr_ST)
#### GroupConditions creation ####

sex_grouping &lt;- GroupConditions(
  conditions_category = "Sex",
  "Male" ~ sex == "M",
  "Female" ~ sex == "F"
)

####   Creating ScoringTable   #### 
##     based on grouped data     ##

Neu_ST &lt;- 
  # create FrequencyTable
  GroupedFrequencyTable(
    data = IPIP_NEO_300,
    conditions = sex_grouping, 
    var = "N") |&gt;
  # create ScoreTable
  GroupedScoreTable(
    scale = STEN) |&gt;
  # and transform into ScoringTable
  to_ScoringTable(
    min_raw = 60,
    max_raw = 300
  )

summary(Neu_ST)
</code></pre>

<hr>
<h2 id='verify_GC_for_ST'>Internal function to verify the provided conditions with conditions available
in imported <em>ScoringTable</em></h2><span id='topic+verify_GC_for_ST'></span>

<h3>Description</h3>

<p>Internal function to verify the provided conditions with conditions available
in imported <em>ScoringTable</em>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>verify_GC_for_ST(st_df, gc_df)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="verify_GC_for_ST_+3A_st_df">st_df</code></td>
<td>
<p>data.frame form of ScoreTable</p>
</td></tr>
<tr><td><code id="verify_GC_for_ST_+3A_gc_df">gc_df</code></td>
<td>
<p>data.frame form of GroupConditions</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of <em>GroupConditions</em> objects or <code>NULL</code>
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
