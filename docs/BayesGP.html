<!DOCTYPE html><html lang="en"><head><title>Help for package BayesGP</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {BayesGP}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#ccData'><p>A simulated dataset from the case-crossover model.</p></a></li>
<li><a href='#compute_d_step_sgpsd'><p>Compute the SD correction factor for sgp</p></a></li>
<li><a href='#compute_post_fun_iwp'><p>Computing the posterior samples of the function or its derivative using the posterior samples</p>
of the basis coefficients for iwp</a></li>
<li><a href='#compute_post_fun_sgp'><p>Computing the posterior samples of the function using the posterior samples</p>
of the basis coefficients for sGP</a></li>
<li><a href='#compute_weights_precision'><p>Constructing the precision matrix given the knot sequence</p></a></li>
<li><a href='#compute_weights_precision_helper'><p>Constructing the precision matrix given the knot sequence (helper)</p></a></li>
<li><a href='#covid_canada'><p>The COVID-19 daily death data in Canada.</p></a></li>
<li><a href='#custom_template'><p>Custom Template Function</p></a></li>
<li><a href='#dummy'><p>Roxygen commands</p></a></li>
<li><a href='#extract_mean_interval_given_samps'><p>Construct posterior inference given samples</p></a></li>
<li><a href='#f'><p>Function defined to enhance the usability for users on IDEs.</p></a></li>
<li><a href='#get_default_option_list_MCMC'><p>Get default options for MCMC implementation</p></a></li>
<li><a href='#global_poly_helper'><p>Constructing and evaluating the global polynomials, to account for boundary conditions (design matrix)</p></a></li>
<li><a href='#global_poly_helper_sgp'><p>Constructing and evaluating the global polynomials, to account for boundary conditions (design matrix) of sgp</p></a></li>
<li><a href='#local_poly_helper'><p>Constructing and evaluating the local O-spline basis (design matrix)</p></a></li>
<li><a href='#model_fit'><p>Model fitting with random effects/fixed effects</p></a></li>
<li><a href='#model_fit_loop'><p>Repeated fitting Bayesian Hierarchical Models for a sequence of values of the looping variable.</p></a></li>
<li><a href='#para_density'><p>Obtain the posterior and prior density of all the parameters in the fitted model</p></a></li>
<li><a href='#PEN_death'><p>The monthly all-cause mortality for male with age less than 40 in Pennsylvania.</p></a></li>
<li><a href='#post_table'><p>Obtain the posterior summary table for all the parameters in the fitted model</p></a></li>
<li><a href='#predict.FitResult'><p>To predict the GP component in the fitted model, at the locations specified in 'newdata'.</p></a></li>
<li><a href='#prior_conversion_iwp'><p>Construct prior based on d-step prediction SD (for iwp)</p></a></li>
<li><a href='#prior_conversion_sgp'><p>Construct prior based on d-step prediction SD (for sgp)</p></a></li>
<li><a href='#sample_fixed_effect'><p>Extract the posterior samples from the fitted model for the target fixed variables.</p></a></li>
<li><a href='#sd_density'><p>Obtain the posterior density of a SD parameter in the fitted model</p></a></li>
<li><a href='#sd_plot'><p>Plot the posterior density of a SD parameter in the fitted model</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Efficient Implementation of Gaussian Process in Bayesian
Hierarchical Models</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.3</td>
</tr>
<tr>
<td>Description:</td>
<td>Implements Bayesian hierarchical models with flexible Gaussian process priors, focusing on Extended Latent Gaussian Models and incorporating various Gaussian process priors for Bayesian smoothing. Computations leverage finite element approximations and adaptive quadrature for efficient inference. Methods are detailed in Zhang, Stringer, Brown, and Stafford (2023) &lt;<a href="https://doi.org/10.1177%2F09622802221134172">doi:10.1177/09622802221134172</a>&gt;; Zhang, Stringer, Brown, and Stafford (2024) &lt;<a href="https://doi.org/10.1080%2F10618600.2023.2289532">doi:10.1080/10618600.2023.2289532</a>&gt;; Zhang, Brown, and Stafford (2023) &lt;<a href="https://doi.org/10.48550%2FarXiv.2305.09914">doi:10.48550/arXiv.2305.09914</a>&gt;; and Stringer, Brown, and Stafford (2021) &lt;<a href="https://doi.org/10.1111%2Fbiom.13329">doi:10.1111/biom.13329</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>TMB (&ge; 1.9.7), RcppEigen</td>
</tr>
<tr>
<td>Imports:</td>
<td>TMB (&ge; 1.9.7), numDeriv, rstan, sfsmisc, Matrix (&ge; 1.6.3),
aghq (&ge; 0.4.1), fda, tmbstan, LaplacesDemon, methods</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.6.0)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>rmarkdown, knitr, survival, testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-11-10 22:31:24 UTC; ziangzhang</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Author:</td>
<td>Ziang Zhang [aut, cre],
  Yongwei Lin [aut],
  Alex Stringer [aut],
  Patrick Brown [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Ziang Zhang &lt;ziangzhang@uchicago.edu&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-11-12 14:20:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='ccData'>A simulated dataset from the case-crossover model.</h2><span id='topic+ccData'></span>

<h3>Description</h3>

<p>A simulated dataset from the case-crossover model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ccData
</code></pre>


<h3>Format</h3>

<p>'ccData'
A data frame with 3596 rows and 6 columns.
</p>

<hr>
<h2 id='compute_d_step_sgpsd'>Compute the SD correction factor for sgp</h2><span id='topic+compute_d_step_sgpsd'></span>

<h3>Description</h3>

<p>Compute the SD correction factor for sgp
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_d_step_sgpsd(d, a)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="compute_d_step_sgpsd_+3A_d">d</code></td>
<td>
<p>A numeric value for the prediction step.</p>
</td></tr>
<tr><td><code id="compute_d_step_sgpsd_+3A_a">a</code></td>
<td>
<p>The frequency parameter of the sgp.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The correction factor c that should be used to compute the d-step PSD as c*SD.
</p>

<hr>
<h2 id='compute_post_fun_iwp'>Computing the posterior samples of the function or its derivative using the posterior samples
of the basis coefficients for iwp</h2><span id='topic+compute_post_fun_iwp'></span>

<h3>Description</h3>

<p>Computing the posterior samples of the function or its derivative using the posterior samples
of the basis coefficients for iwp
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_post_fun_iwp(
  samps,
  global_samps = NULL,
  knots,
  refined_x,
  p,
  degree = 0,
  intercept_samps = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="compute_post_fun_iwp_+3A_samps">samps</code></td>
<td>
<p>A matrix that consists of posterior samples for the O-spline basis coefficients. Each column
represents a particular sample of coefficients, and each row is associated with one basis function. This can
be extracted using 'sample_marginal' function from 'aghq' package.</p>
</td></tr>
<tr><td><code id="compute_post_fun_iwp_+3A_global_samps">global_samps</code></td>
<td>
<p>A matrix that consists of posterior samples for the global basis coefficients. If NULL,
assume there will be no global polynomials and the boundary conditions are exactly zero.</p>
</td></tr>
<tr><td><code id="compute_post_fun_iwp_+3A_knots">knots</code></td>
<td>
<p>A vector of knots used to construct the O-spline basis, first knot should be viewed as &quot;0&quot;,
the reference starting location. These k knots will define (k-1) basis function in total.</p>
</td></tr>
<tr><td><code id="compute_post_fun_iwp_+3A_refined_x">refined_x</code></td>
<td>
<p>A vector of locations to evaluate the O-spline basis</p>
</td></tr>
<tr><td><code id="compute_post_fun_iwp_+3A_p">p</code></td>
<td>
<p>An integer value indicates the order of smoothness</p>
</td></tr>
<tr><td><code id="compute_post_fun_iwp_+3A_degree">degree</code></td>
<td>
<p>The order of the derivative to take, if zero, implies to consider the function itself.</p>
</td></tr>
<tr><td><code id="compute_post_fun_iwp_+3A_intercept_samps">intercept_samps</code></td>
<td>
<p>A matrix that consists of posterior samples for the intercept parameter. If NULL, assume
the function evaluated at zero is zero.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame that contains different samples of the function or its derivative, with the first column
being the locations of evaluations x = refined_x.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>knots &lt;- c(0, 0.2, 0.4, 0.6)
samps &lt;- matrix(rnorm(n = (3 * 10)), ncol = 10)
result &lt;- compute_post_fun_iwp(samps = samps, knots = knots, refined_x = seq(0, 1, by = 0.1), p = 2)
plot(result[, 2] ~ result$x, type = "l", ylim = c(-0.3, 0.3))
for (i in 1:9) {
  lines(result[, (i + 1)] ~ result$x, lty = "dashed", ylim = c(-0.1, 0.1))
}
global_samps &lt;- matrix(rnorm(n = (2 * 10), sd = 0.1), ncol = 10)
</code></pre>

<hr>
<h2 id='compute_post_fun_sgp'>Computing the posterior samples of the function using the posterior samples
of the basis coefficients for sGP</h2><span id='topic+compute_post_fun_sgp'></span>

<h3>Description</h3>

<p>Computing the posterior samples of the function using the posterior samples
of the basis coefficients for sGP
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_post_fun_sgp(
  samps,
  global_samps = NULL,
  k,
  refined_x,
  a,
  region,
  boundary = TRUE,
  m,
  intercept_samps = NULL,
  initial_location = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="compute_post_fun_sgp_+3A_samps">samps</code></td>
<td>
<p>A matrix that consists of posterior samples for the O-spline basis coefficients. Each column
represents a particular sample of coefficients, and each row is associated with one basis function. This can
be extracted using 'sample_marginal' function from 'aghq' package.</p>
</td></tr>
<tr><td><code id="compute_post_fun_sgp_+3A_global_samps">global_samps</code></td>
<td>
<p>A matrix that consists of posterior samples for the global basis coefficients. If NULL,
assume there will be no global polynomials and the boundary conditions are exactly zero.</p>
</td></tr>
<tr><td><code id="compute_post_fun_sgp_+3A_k">k</code></td>
<td>
<p>The number of the sB basis.</p>
</td></tr>
<tr><td><code id="compute_post_fun_sgp_+3A_refined_x">refined_x</code></td>
<td>
<p>A vector of locations to evaluate the sB basis</p>
</td></tr>
<tr><td><code id="compute_post_fun_sgp_+3A_a">a</code></td>
<td>
<p>The frequency of sGP.</p>
</td></tr>
<tr><td><code id="compute_post_fun_sgp_+3A_region">region</code></td>
<td>
<p>The region to define the sB basis</p>
</td></tr>
<tr><td><code id="compute_post_fun_sgp_+3A_boundary">boundary</code></td>
<td>
<p>A boolean variable to indicate whether the boundary condition should be considered in the prediction.</p>
</td></tr>
<tr><td><code id="compute_post_fun_sgp_+3A_m">m</code></td>
<td>
<p>The number of harmonics to consider</p>
</td></tr>
<tr><td><code id="compute_post_fun_sgp_+3A_intercept_samps">intercept_samps</code></td>
<td>
<p>A matrix that consists of posterior samples for the intercept parameter. If NULL, assume there is no intercept samples to adjust.</p>
</td></tr>
<tr><td><code id="compute_post_fun_sgp_+3A_initial_location">initial_location</code></td>
<td>
<p>The initial location of the sGP.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame that contains different samples of the function, with the first column
being the locations of evaluations x = refined_x.
</p>

<hr>
<h2 id='compute_weights_precision'>Constructing the precision matrix given the knot sequence</h2><span id='topic+compute_weights_precision'></span>

<h3>Description</h3>

<p>Constructing the precision matrix given the knot sequence
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_weights_precision(object)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="compute_weights_precision_+3A_object">object</code></td>
<td>
<p>A fitted model object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A precision matrix of the corresponding basis function, should be diagonal matrix with
size (k-1) by (k-1).
</p>

<hr>
<h2 id='compute_weights_precision_helper'>Constructing the precision matrix given the knot sequence (helper)</h2><span id='topic+compute_weights_precision_helper'></span>

<h3>Description</h3>

<p>Constructing the precision matrix given the knot sequence (helper)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_weights_precision_helper(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="compute_weights_precision_helper_+3A_x">x</code></td>
<td>
<p>A vector of knots used to construct the O-spline basis, first knot should be viewed as &quot;0&quot;,
the reference starting location. These k knots will define (k-1) basis function in total.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A precision matrix of the corresponding basis function, should be diagonal matrix with
size (k-1) by (k-1).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>compute_weights_precision_helper(x = c(0,0.2,0.4,0.6,0.8))
</code></pre>

<hr>
<h2 id='covid_canada'>The COVID-19 daily death data in Canada.</h2><span id='topic+covid_canada'></span>

<h3>Description</h3>

<p>A subset of the the COVID-19 daily death data collected between 2020 to 2022. The data is obtained from
COVID-19 Data Repository by the Center for Systems Science and Engineering (CSSE) at
Johns Hopkins University (Dong et al., 2020).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>covid_canada
</code></pre>


<h3>Format</h3>

<p>'covid_canada'
A data frame with 787 rows and 5 columns:
</p>

<dl>
<dt>Date</dt><dd><p>The date of the measurement.</p>
</dd>
<dt>new_deaths</dt><dd><p>The number of new deaths at that date.</p>
</dd>
<dt>t</dt><dd><p>The converted numerical value of 'Date'.</p>
</dd>
<dt>weekdays 1-6</dt><dd><p>Coded as 1 if the date is the corresponding weekday, -1 else if the date is on Sunday, and 0 otherwise.</p>
</dd>
<dt>index</dt><dd><p>The index of that observation.</p>
</dd>
</dl>



<h3>Source</h3>

<p>Dong, E., H. Du, and L. Gardner (2020). An interactive web-based dashboard to track
covid-19 in real time. <em>The Lancet infectious diseases 20 (5)</em>, 533–534.
</p>

<hr>
<h2 id='custom_template'>Custom Template Function</h2><span id='topic+custom_template'></span>

<h3>Description</h3>

<p>This function allows for the dynamic modification of a C++ template
within the BayesGP package. Users can specify custom content for the 
log-likelihood as well as the log-prior of the SD parameter in the template.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>custom_template(
  SETUP = NULL,
  LOG_LIKELIHOOD = NULL,
  LOG_PRIOR = NULL,
  compile_template = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="custom_template_+3A_setup">SETUP</code></td>
<td>
<p>A character string or vector containing the 
lines of C++ code to be inserted before the computation of log-likelihood.</p>
</td></tr>
<tr><td><code id="custom_template_+3A_log_likelihood">LOG_LIKELIHOOD</code></td>
<td>
<p>A character string or vector containing the 
lines of C++ code to be inserted in the log-likelihood section of 
the template. Should be NULL if no changes are to be made to this section.</p>
</td></tr>
<tr><td><code id="custom_template_+3A_log_prior">LOG_PRIOR</code></td>
<td>
<p>A character string or vector containing the 
lines of C++ code to be inserted in the log-prior (of the SD parameter) section of 
the template. Should be NULL if no changes are to be made to this section.</p>
</td></tr>
<tr><td><code id="custom_template_+3A_compile_template">compile_template</code></td>
<td>
<p>A indicator of whether the new template should be compiled. default is FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A string representing the path to the temporary .so (or .dll) file
containing the compiled custom C++ code.
</p>

<hr>
<h2 id='dummy'>Roxygen commands</h2><span id='topic+dummy'></span>

<h3>Description</h3>

<p>Roxygen commands
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dummy()
</code></pre>

<hr>
<h2 id='extract_mean_interval_given_samps'>Construct posterior inference given samples</h2><span id='topic+extract_mean_interval_given_samps'></span>

<h3>Description</h3>

<p>Construct posterior inference given samples
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract_mean_interval_given_samps(samps, level = 0.95, quantiles = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="extract_mean_interval_given_samps_+3A_samps">samps</code></td>
<td>
<p>Posterior samples of f or its derivative, with the first column being evaluation
points x. This can be yielded by 'compute_post_fun_iwp' function.</p>
</td></tr>
<tr><td><code id="extract_mean_interval_given_samps_+3A_level">level</code></td>
<td>
<p>The level to compute the pointwise interval. Ignored when quantiles are provided.</p>
</td></tr>
<tr><td><code id="extract_mean_interval_given_samps_+3A_quantiles">quantiles</code></td>
<td>
<p>A numeric vector of quantiles to be computed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe with a column for evaluation locations x, and posterior mean and pointwise
intervals at that set of locations.
</p>

<hr>
<h2 id='f'>Function defined to enhance the usability for users on IDEs.</h2><span id='topic+f'></span>

<h3>Description</h3>

<p>Function defined to enhance the usability for users on IDEs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>f(
  smoothing_var,
  model = "iid",
  sd.prior = NULL,
  boundary.prior = NULL,
  initial_location = c("middle", "left", "right")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="f_+3A_smoothing_var">smoothing_var</code></td>
<td>
<p>The variable name of the smoothing variable.</p>
</td></tr>
<tr><td><code id="f_+3A_model">model</code></td>
<td>
<p>The name of the smoothing model.</p>
</td></tr>
<tr><td><code id="f_+3A_sd.prior">sd.prior</code></td>
<td>
<p>A list/vector that specifies the prior of the sd parameter.</p>
</td></tr>
<tr><td><code id="f_+3A_boundary.prior">boundary.prior</code></td>
<td>
<p>A list/vector that specifies the prior of the boundary parameter.</p>
</td></tr>
<tr><td><code id="f_+3A_initial_location">initial_location</code></td>
<td>
<p>A character/number that specifies the initial location of the smoothing variable.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A call object that can be used in the model_fit formula to indicate a smooth term or random effect.
</p>

<hr>
<h2 id='get_default_option_list_MCMC'>Get default options for MCMC implementation</h2><span id='topic+get_default_option_list_MCMC'></span>

<h3>Description</h3>

<p>This function takes an optional list of options and fills in any missing values with a set of default MCMC options.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_default_option_list_MCMC(option_list = list())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_default_option_list_MCMC_+3A_option_list">option_list</code></td>
<td>
<p>A list of options to be passed to the MCMC. If some options are missing, the function will use default values.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the complete set of options with defaults where necessary.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example: Get the default option list
options &lt;- get_default_option_list_MCMC()
print(options)

</code></pre>

<hr>
<h2 id='global_poly_helper'>Constructing and evaluating the global polynomials, to account for boundary conditions (design matrix)</h2><span id='topic+global_poly_helper'></span>

<h3>Description</h3>

<p>Constructing and evaluating the global polynomials, to account for boundary conditions (design matrix)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>global_poly_helper(x, p = 2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="global_poly_helper_+3A_x">x</code></td>
<td>
<p>A vector of locations to evaluate the global polynomials</p>
</td></tr>
<tr><td><code id="global_poly_helper_+3A_p">p</code></td>
<td>
<p>An integer value indicates the order of smoothness</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with i,j componet being the value of jth basis function
value at ith element of x, the ncol should equal to p, and nrow
should equal to the number of elements in x
</p>


<h3>Examples</h3>

<pre><code class='language-R'>global_poly_helper(x = c(0, 0.2, 0.4, 0.6, 0.8), p = 2)
</code></pre>

<hr>
<h2 id='global_poly_helper_sgp'>Constructing and evaluating the global polynomials, to account for boundary conditions (design matrix) of sgp</h2><span id='topic+global_poly_helper_sgp'></span>

<h3>Description</h3>

<p>Constructing and evaluating the global polynomials, to account for boundary conditions (design matrix) of sgp
</p>


<h3>Usage</h3>

<pre><code class='language-R'>global_poly_helper_sgp(refined_x, a, m, initial_location = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="global_poly_helper_sgp_+3A_refined_x">refined_x</code></td>
<td>
<p>A vector of locations to evaluate the sB basis</p>
</td></tr>
<tr><td><code id="global_poly_helper_sgp_+3A_a">a</code></td>
<td>
<p>The frequency of sgp.</p>
</td></tr>
<tr><td><code id="global_poly_helper_sgp_+3A_m">m</code></td>
<td>
<p>The number of harmonics to consider</p>
</td></tr>
<tr><td><code id="global_poly_helper_sgp_+3A_initial_location">initial_location</code></td>
<td>
<p>The value of the initial location. If NULL, the minimum value of refined_x will be used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with i,j componet being the value of jth basis function
value at ith element of x, the ncol should equal to (2*m), and nrow
should equal to the number of elements in x
</p>

<hr>
<h2 id='local_poly_helper'>Constructing and evaluating the local O-spline basis (design matrix)</h2><span id='topic+local_poly_helper'></span>

<h3>Description</h3>

<p>Constructing and evaluating the local O-spline basis (design matrix)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>local_poly_helper(knots, refined_x, p = 2, neg_sign_order = 0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="local_poly_helper_+3A_knots">knots</code></td>
<td>
<p>A vector of knots used to construct the O-spline basis, first knot should be viewed as &quot;0&quot;,
the reference starting location. These k knots will define (k-1) basis function in total.</p>
</td></tr>
<tr><td><code id="local_poly_helper_+3A_refined_x">refined_x</code></td>
<td>
<p>A vector of locations to evaluate the O-spline basis</p>
</td></tr>
<tr><td><code id="local_poly_helper_+3A_p">p</code></td>
<td>
<p>An integer value indicates the order of smoothness</p>
</td></tr>
<tr><td><code id="local_poly_helper_+3A_neg_sign_order">neg_sign_order</code></td>
<td>
<p>An integer value N such that D = ((-1)^N)*D for the splines at negative knots. Default is 0.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with i,j component being the value of jth basis function
value at ith element of refined_x, the ncol should equal to number of knots minus 1, and nrow
should equal to the number of elements in refined_x.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>local_poly_helper(knots = c(0, 0.2, 0.4, 0.6, 0.8), refined_x = seq(0, 0.8, by = 0.1), p = 2)
</code></pre>

<hr>
<h2 id='model_fit'>Model fitting with random effects/fixed effects</h2><span id='topic+model_fit'></span>

<h3>Description</h3>

<p>Fitting a hierarchical model based on the provided formula, data and parameters such as type of method and family of response.
Returning the S4 objects for the random effects, concatenated design matrix for the intercepts and fixed effects, fitted model,
indexes to partition the posterior samples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>model_fit(
  formula,
  data,
  method = "aghq",
  family = "gaussian",
  control.family,
  control.fixed,
  aghq_k = 4,
  size = NULL,
  cens = NULL,
  weight = NULL,
  strata = NULL,
  M = 3000,
  customized_template = NULL,
  Customized_RE = NULL,
  option_list = list(),
  envir = parent.frame(),
  extra_theta_num = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="model_fit_+3A_formula">formula</code></td>
<td>
<p>A formula that contains one response variable, and covariates with either random or fixed effect.</p>
</td></tr>
<tr><td><code id="model_fit_+3A_data">data</code></td>
<td>
<p>A dataframe that contains the response variable and other covariates mentioned in the formula.</p>
</td></tr>
<tr><td><code id="model_fit_+3A_method">method</code></td>
<td>
<p>The inference method used in the model. By default, the method is set to be &quot;aghq&quot;.</p>
</td></tr>
<tr><td><code id="model_fit_+3A_family">family</code></td>
<td>
<p>The family of response used in the model. By default, the family is set to be &quot;gaussian&quot;.</p>
</td></tr>
<tr><td><code id="model_fit_+3A_control.family">control.family</code></td>
<td>
<p>Parameters used to specify the priors for the family parameters, such as the standard deviation parameter of Gaussian family. For example control.family = 1 in the Gaussian family corresponds to an Exponential prior to the standard deviation parameter of the Gaussian noise with median 1. When left unspecified, the default prior is an Exponential prior with median 1.</p>
</td></tr>
<tr><td><code id="model_fit_+3A_control.fixed">control.fixed</code></td>
<td>
<p>Parameters used to specify the priors for the fixed effects. For example control.fixed = list(intercept = list(prec = 0.001, mean = 0)) will setup the prior N(0,1/0.001) for the intercept parameter. When left unspecified, all fixed effect parameters will be assigned independent N(0,1/0.001) priors.</p>
</td></tr>
<tr><td><code id="model_fit_+3A_aghq_k">aghq_k</code></td>
<td>
<p>An integer to specify the number of quadrature points used in the aghq method. By default, the value is 4.</p>
</td></tr>
<tr><td><code id="model_fit_+3A_size">size</code></td>
<td>
<p>The name of the size variable, should be one of the variables in 'data'. The default value is &quot;NULL&quot;, corresponding to a vector of 1s. This is only used for the Binomial family, and denotes the number of binomial trails.</p>
</td></tr>
<tr><td><code id="model_fit_+3A_cens">cens</code></td>
<td>
<p>The name of the right-censoring indicator, should be one of the variables in 'data'. The default value is &quot;NULL&quot;. This is only used for the CoxPH family.</p>
</td></tr>
<tr><td><code id="model_fit_+3A_weight">weight</code></td>
<td>
<p>The name of the weight variable, should be one of the variables in 'data'. The default value is &quot;NULL&quot;, corresponding to a vector of 1s. This is only used for the Case-Crossover family, and denotes the weight of each observation.</p>
</td></tr>
<tr><td><code id="model_fit_+3A_strata">strata</code></td>
<td>
<p>The name of the strata variable, should be one of the variables in 'data'. The default value is &quot;NULL&quot;. This is only used for the Case-Crossover family, and denotes the strata of each observation.</p>
</td></tr>
<tr><td><code id="model_fit_+3A_m">M</code></td>
<td>
<p>The number of posterior samples to be taken, by default is 3000.</p>
</td></tr>
<tr><td><code id="model_fit_+3A_customized_template">customized_template</code></td>
<td>
<p>The name of the customized cpp template that the user wants to use instead. By default this is NULL, and the cpp template 'BayesGP' will be used.</p>
</td></tr>
<tr><td><code id="model_fit_+3A_customized_re">Customized_RE</code></td>
<td>
<p>The list that contains the compute_B and compute_P functions for the customized random effect. By default, this is NULL and there is not customized random effect in the model.</p>
</td></tr>
<tr><td><code id="model_fit_+3A_option_list">option_list</code></td>
<td>
<p>A list that controls the details of the inference algorithm, by default is an empty list.</p>
</td></tr>
<tr><td><code id="model_fit_+3A_envir">envir</code></td>
<td>
<p>The environment in which the formula and other expressions are to be evaluated. 
Defaults to 'parent.frame()', which refers to the environment from which the function was called.
This allows the function to access variables that are defined in the calling function's scope.</p>
</td></tr>
<tr><td><code id="model_fit_+3A_extra_theta_num">extra_theta_num</code></td>
<td>
<p>An integer number to indicate the extra number of parameters required in the 'theta' vector. Should only be specified when using customized template.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list that contains following items: the S4 objects for the random effects (instances), concatenated design matrix for
the fixed effects (design_mat_fixed), fitted aghq (mod) and indexes to partition the posterior samples
(boundary_samp_indexes, random_samp_indexes and fixed_samp_indexes).
</p>

<hr>
<h2 id='model_fit_loop'>Repeated fitting Bayesian Hierarchical Models for a sequence of values of the looping variable.</h2><span id='topic+model_fit_loop'></span>

<h3>Description</h3>

<p>Performs repeated model fitting over a sequence of values for a specified variable within a hierarchical model.
This function repeatedly fits a model for each value of the looping variable, compiles the log marginal likelihoods,
and calculates the posterior probabilities for the variable's values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>model_fit_loop(
  loop_holder = "LOOP",
  loop_values,
  prior_func = function(x) {
     1
 },
  parallel = FALSE,
  cores = (parallel::detectCores() - 1),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="model_fit_loop_+3A_loop_holder">loop_holder</code></td>
<td>
<p>A string specifying the name of the variable to loop over. The default value is 'LOOP'.</p>
</td></tr>
<tr><td><code id="model_fit_loop_+3A_loop_values">loop_values</code></td>
<td>
<p>A numeric vector containing the values to loop over for the specified variable.</p>
</td></tr>
<tr><td><code id="model_fit_loop_+3A_prior_func">prior_func</code></td>
<td>
<p>A function that takes the specified loop_values and returns the values of the prior for the loop variable.
By default, it is a uniform prior which returns a constant value, indicating equal probability for all values.</p>
</td></tr>
<tr><td><code id="model_fit_loop_+3A_parallel">parallel</code></td>
<td>
<p>Logical, indicating whether or not to run the model fitting in parallel (default is FALSE).</p>
</td></tr>
<tr><td><code id="model_fit_loop_+3A_cores">cores</code></td>
<td>
<p>The number of cores to use for parallel execution (default is detected cores - 1).</p>
</td></tr>
<tr><td><code id="model_fit_loop_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to the model fitting function 'model_fit'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame containing the values of the looping variable, their corresponding log marginal likelihoods,
and posterior probabilities.
</p>

<hr>
<h2 id='para_density'>Obtain the posterior and prior density of all the parameters in the fitted model</h2><span id='topic+para_density'></span>

<h3>Description</h3>

<p>Obtain the posterior and prior density of all the parameters in the fitted model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>para_density(object)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="para_density_+3A_object">object</code></td>
<td>
<p>The fitted object from the function 'model_fit'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of data frames, each data frame contains the posterior density of the corresponding parameter.
</p>

<hr>
<h2 id='PEN_death'>The monthly all-cause mortality for male with age less than 40 in Pennsylvania.</h2><span id='topic+PEN_death'></span>

<h3>Description</h3>

<p>The monthly all-cause mortality for male with age less than 40 in Pennsylvania.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PEN_death
</code></pre>


<h3>Format</h3>

<p>'PEN_death'
A data frame with 299 rows of observations.
</p>

<hr>
<h2 id='post_table'>Obtain the posterior summary table for all the parameters in the fitted model</h2><span id='topic+post_table'></span>

<h3>Description</h3>

<p>Obtain the posterior summary table for all the parameters in the fitted model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>post_table(object, quantiles = c(0.025, 0.975), digits = 3)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="post_table_+3A_object">object</code></td>
<td>
<p>The fitted object from the function 'model_fit'.</p>
</td></tr>
<tr><td><code id="post_table_+3A_quantiles">quantiles</code></td>
<td>
<p>The specified quantile to display the posterior summary, default is c(0.025, 0.975).</p>
</td></tr>
<tr><td><code id="post_table_+3A_digits">digits</code></td>
<td>
<p>The significant digits to be kept in the result, default is 3.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame that contains the posterior summary of all the parameters in the fitted model.
</p>

<hr>
<h2 id='predict.FitResult'>To predict the GP component in the fitted model, at the locations specified in 'newdata'.</h2><span id='topic+predict.FitResult'></span>

<h3>Description</h3>

<p>To predict the GP component in the fitted model, at the locations specified in 'newdata'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'FitResult'
predict(
  object,
  newdata = NULL,
  variable,
  deriv = 0,
  include.intercept = TRUE,
  only.samples = FALSE,
  quantiles = c(0.025, 0.5, 0.975),
  boundary.condition = "Yes",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict.FitResult_+3A_object">object</code></td>
<td>
<p>The fitted object from the function 'model_fit'.</p>
</td></tr>
<tr><td><code id="predict.FitResult_+3A_newdata">newdata</code></td>
<td>
<p>The dataset that contains the locations to be predicted for the specified GP. Its column names must include 'variable'.</p>
</td></tr>
<tr><td><code id="predict.FitResult_+3A_variable">variable</code></td>
<td>
<p>The name of the variable to be predicted, should be in the 'newdata'.</p>
</td></tr>
<tr><td><code id="predict.FitResult_+3A_deriv">deriv</code></td>
<td>
<p>The degree of derivative that the user specifies for inference. Only applicable for a GP in the 'iwp' type.</p>
</td></tr>
<tr><td><code id="predict.FitResult_+3A_include.intercept">include.intercept</code></td>
<td>
<p>A logical variable specifying whether the intercept should be accounted when doing the prediction. The default is TRUE. For Coxph model, this 
variable will be forced to FALSE.</p>
</td></tr>
<tr><td><code id="predict.FitResult_+3A_only.samples">only.samples</code></td>
<td>
<p>A logical variable indicating whether only the posterior samples are required. The default is FALSE, and the summary of posterior samples will be reported.</p>
</td></tr>
<tr><td><code id="predict.FitResult_+3A_quantiles">quantiles</code></td>
<td>
<p>A numeric vector of quantiles that predict.FitResult will produce, the default is c(0.025, 0.5, 0.975).</p>
</td></tr>
<tr><td><code id="predict.FitResult_+3A_boundary.condition">boundary.condition</code></td>
<td>
<p>A string specifies whether the boundary.condition should be considered in the prediction, should be one of c(&quot;yes&quot;, &quot;no&quot;, &quot;only&quot;). The default option is &quot;Yes&quot;.</p>
</td></tr>
<tr><td><code id="predict.FitResult_+3A_...">...</code></td>
<td>
<p>Other arguments to be passed to the function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame that contains the posterior mean and pointwise intervals (or posterior samples) at the locations specified in 'newdata'.
</p>

<hr>
<h2 id='prior_conversion_iwp'>Construct prior based on d-step prediction SD (for iwp)</h2><span id='topic+prior_conversion_iwp'></span>

<h3>Description</h3>

<p>Construct prior based on d-step prediction SD (for iwp)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prior_conversion_iwp(d, prior, p)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="prior_conversion_iwp_+3A_d">d</code></td>
<td>
<p>A numeric value for the prediction step.</p>
</td></tr>
<tr><td><code id="prior_conversion_iwp_+3A_prior">prior</code></td>
<td>
<p>A list that contains alpha and u. This specifies the target prior on the d-step SD <code class="reqn">\sigma(d)</code>, such that <code class="reqn">P(\sigma(d) &gt; u) = alpha</code>.</p>
</td></tr>
<tr><td><code id="prior_conversion_iwp_+3A_p">p</code></td>
<td>
<p>An integer for the order of iwp.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list that contains alpha and u. The prior for the smoothness parameter <code class="reqn">\sigma</code> such that <code class="reqn">P(\sigma &gt; u) = alpha</code>, that yields the ideal prior on the d-step SD.
</p>

<hr>
<h2 id='prior_conversion_sgp'>Construct prior based on d-step prediction SD (for sgp)</h2><span id='topic+prior_conversion_sgp'></span>

<h3>Description</h3>

<p>Construct prior based on d-step prediction SD (for sgp)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prior_conversion_sgp(d, prior, freq, period, a, m = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="prior_conversion_sgp_+3A_d">d</code></td>
<td>
<p>A numeric value for the prediction step.</p>
</td></tr>
<tr><td><code id="prior_conversion_sgp_+3A_prior">prior</code></td>
<td>
<p>A list that contains alpha and u. This specifies the target prior on the d-step SD <code class="reqn">\sigma(d)</code>, such that <code class="reqn">P(\sigma(d) &gt; u) = alpha</code>.</p>
</td></tr>
<tr><td><code id="prior_conversion_sgp_+3A_freq">freq</code></td>
<td>
<p>The frequency of the sgp, ignored if a is provided.</p>
</td></tr>
<tr><td><code id="prior_conversion_sgp_+3A_period">period</code></td>
<td>
<p>The period of the sgp, ignored if a or freq is provided.</p>
</td></tr>
<tr><td><code id="prior_conversion_sgp_+3A_a">a</code></td>
<td>
<p>The frequency parameter of the sgp.</p>
</td></tr>
<tr><td><code id="prior_conversion_sgp_+3A_m">m</code></td>
<td>
<p>The number of harmonics that should be considered, by default m = 1 represents only the sgp.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list that contains alpha and u. The prior for the smoothness parameter <code class="reqn">\sigma</code> such that <code class="reqn">P(\sigma &gt; u) = alpha</code>, that yields the ideal prior on the d-step SD.
</p>

<hr>
<h2 id='sample_fixed_effect'>Extract the posterior samples from the fitted model for the target fixed variables.</h2><span id='topic+sample_fixed_effect'></span>

<h3>Description</h3>

<p>Extract the posterior samples from the fitted model for the target fixed variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sample_fixed_effect(model_fit, variables)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sample_fixed_effect_+3A_model_fit">model_fit</code></td>
<td>
<p>The result from model_fit().</p>
</td></tr>
<tr><td><code id="sample_fixed_effect_+3A_variables">variables</code></td>
<td>
<p>A vector of names of the target fixed variables to sample.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with columns being the posterior samples of the target fixed effect variables.
</p>

<hr>
<h2 id='sd_density'>Obtain the posterior density of a SD parameter in the fitted model</h2><span id='topic+sd_density'></span>

<h3>Description</h3>

<p>Obtain the posterior density of a SD parameter in the fitted model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sd_density(
  object,
  component = NULL,
  h = NULL,
  theta_logprior = NULL,
  MCMC_samps_only = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sd_density_+3A_object">object</code></td>
<td>
<p>The fitted object from the function 'model_fit'.</p>
</td></tr>
<tr><td><code id="sd_density_+3A_component">component</code></td>
<td>
<p>The component of the SD parameter that you want to show. By default this is 'NULL', indicating the family.sd is of interest.</p>
</td></tr>
<tr><td><code id="sd_density_+3A_h">h</code></td>
<td>
<p>For PSD, the unit of predictive step to consider, by default is set to 'NULL', indicating the result is using the same 'h' as in the model fitting.</p>
</td></tr>
<tr><td><code id="sd_density_+3A_theta_logprior">theta_logprior</code></td>
<td>
<p>The log prior function used on the selected SD parameter. By default is 'NULL', and the current Exponential prior will be used.</p>
</td></tr>
<tr><td><code id="sd_density_+3A_mcmc_samps_only">MCMC_samps_only</code></td>
<td>
<p>For model fitted with MCMC, whether only the posterior samples are needed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame that contains the posterior and prior densities of the SD parameter. The SD parameter will be converted into PSD if applicable.
</p>

<hr>
<h2 id='sd_plot'>Plot the posterior density of a SD parameter in the fitted model</h2><span id='topic+sd_plot'></span>

<h3>Description</h3>

<p>Plot the posterior density of a SD parameter in the fitted model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sd_plot(object, component = NULL, h = NULL, theta_logprior = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sd_plot_+3A_object">object</code></td>
<td>
<p>The fitted object from the function 'model_fit'.</p>
</td></tr>
<tr><td><code id="sd_plot_+3A_component">component</code></td>
<td>
<p>The component of the SD parameter that you want to show. By default this is 'NULL', indicating the family.sd is of interest.</p>
</td></tr>
<tr><td><code id="sd_plot_+3A_h">h</code></td>
<td>
<p>For PSD, the unit of predictive step to consider, by default is set to 'NULL', indicating the result is using the same 'h' as in the model fitting.</p>
</td></tr>
<tr><td><code id="sd_plot_+3A_theta_logprior">theta_logprior</code></td>
<td>
<p>The log prior function used on the selected SD parameter. By default is 'NULL', and the current Exponential prior will be used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plot that shows the posterior and prior density of the SD parameter. The SD parameter will be converted into PSD if applicable.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
