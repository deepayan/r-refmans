<!DOCTYPE html><html><head><title>Help for package escalation</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {escalation}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#as_tibble.derived_dose_selector'><p>Cast <code>dose_selector</code> object to <code>tibble</code>.</p></a></li>
<li><a href='#as_tibble.dose_paths'><p>Cast <code>dose_paths</code> object to <code>tibble</code>.</p></a></li>
<li><a href='#as_tibble.simulations_collection'><p>Convert a simulations_collection to a tibble</p></a></li>
<li><a href='#calculate_probabilities'><p>Calculate dose-path probabilities</p></a></li>
<li><a href='#cohort'><p>Cohort numbers of evaluated patients.</p></a></li>
<li><a href='#cohorts_of_n'><p>Sample times between patient arrivals using the exponential distribution.</p></a></li>
<li><a href='#continue'><p>Should this dose-finding experiment continue?</p></a></li>
<li><a href='#convergence_plot'><p>Plot the convergence processes from a collection of simulations.</p></a></li>
<li><a href='#CorrelatedPatientSample'><p>A sample of patients that experience correlated events in simulations.</p></a></li>
<li><a href='#crystallised_dose_paths'><p>Dose-paths with probabilities attached.</p></a></li>
<li><a href='#demand_n_at_dose'><p>Demand there are n patients at a dose before condisdering stopping.</p></a></li>
<li><a href='#dont_skip_doses'><p>Prevent skipping of doses.</p></a></li>
<li><a href='#dose_admissible'><p>Is each dose admissible?</p></a></li>
<li><a href='#dose_indices'><p>Dose indices</p></a></li>
<li><a href='#dose_paths'><p>Dose pathways</p></a></li>
<li><a href='#dose_paths_function'><p>Get function for calculating dose pathways.</p></a></li>
<li><a href='#doses_given'><p>Doses given to patients.</p></a></li>
<li><a href='#eff'><p>Binary efficacy outcomes.</p></a></li>
<li><a href='#eff_at_dose'><p>Number of toxicities seen at each dose.</p></a></li>
<li><a href='#eff_limit'><p>Efficacy rate limit</p></a></li>
<li><a href='#empiric_eff_rate'><p>Observed efficacy rate at each dose.</p></a></li>
<li><a href='#empiric_tox_rate'><p>Observed toxicity rate at each dose.</p></a></li>
<li><a href='#enforce_three_plus_three'><p>Enforce that a trial path has followed the 3+3 method.</p></a></li>
<li><a href='#escalation-package'><p>The 'escalation' package.</p></a></li>
<li><a href='#fit'><p>Fit a dose-finding model.</p></a></li>
<li><a href='#follow_path'><p>Follow a pre-determined dose administration path.</p></a></li>
<li><a href='#get_boin'><p>Get an object to fit the BOIN model using the BOIN package.</p></a></li>
<li><a href='#get_boin12'><p>Get an object to fit the BOIN12 model for phase I/II dose-finding.</p></a></li>
<li><a href='#get_dfcrm'><p>Get an object to fit the CRM model using the dfcrm package.</p></a></li>
<li><a href='#get_dose_paths'><p>Calculate future dose paths.</p></a></li>
<li><a href='#get_empiric_crm_skeleton_weights'><p>Get posterior model weights for several empiric CRM skeletons.</p></a></li>
<li><a href='#get_mtpi'><p>Get an object to fit the mTPI dose-finding model.</p></a></li>
<li><a href='#get_mtpi2'><p>Get an object to fit the mTPI-2 dose-finding model.</p></a></li>
<li><a href='#get_potential_outcomes'><p>Get potential outcomes from a list of PatientSamples</p></a></li>
<li><a href='#get_random_selector'><p>Get an object to fit a dose-selector that randomly selects doses.</p></a></li>
<li><a href='#get_three_plus_three'><p>Get an object to fit the 3+3 model.</p></a></li>
<li><a href='#get_tpi'><p>Get an object to fit the TPI dose-finding model.</p></a></li>
<li><a href='#get_trialr_crm'><p>Get an object to fit the CRM model using the trialr package.</p></a></li>
<li><a href='#get_trialr_efftox'><p>Get an object to fit the EffTox model using the trialr package.</p></a></li>
<li><a href='#get_trialr_nbg'><p>Get an object to fit the NBG dose-finding model using the trialr package.</p></a></li>
<li><a href='#get_wages_and_tait'><p>Get an object to fit Wages &amp; Tait's model for phase I/II dose-finding.</p></a></li>
<li><a href='#graph_paths'><p>Visualise dose-paths as a graph</p></a></li>
<li><a href='#is_randomising'><p>Is this selector currently randomly allocating doses?</p></a></li>
<li><a href='#mean_prob_eff'><p>Mean efficacy rate at each dose.</p></a></li>
<li><a href='#mean_prob_tox'><p>Mean toxicity rate at each dose.</p></a></li>
<li><a href='#median_prob_eff'><p>Median efficacy rate at each dose.</p></a></li>
<li><a href='#median_prob_tox'><p>Median toxicity rate at each dose.</p></a></li>
<li><a href='#model_frame'><p>Model data-frame.</p></a></li>
<li><a href='#n_at_dose'><p>Number of patients treated at each dose.</p></a></li>
<li><a href='#n_at_recommended_dose'><p>Number of patients treated at the recommended dose.</p></a></li>
<li><a href='#num_cohort_outcomes'><p>Number of different possible outcomes for a cohort of patients</p></a></li>
<li><a href='#num_dose_path_nodes'><p>Number of nodes in dose-paths analysis</p></a></li>
<li><a href='#num_doses'><p>Number of doses.</p></a></li>
<li><a href='#num_eff'><p>Total number of efficacies seen.</p></a></li>
<li><a href='#num_patients'><p>Number of patients evaluated.</p></a></li>
<li><a href='#num_tox'><p>Total number of toxicities seen.</p></a></li>
<li><a href='#parse_phase1_2_outcomes'><p>Parse a string of phase I/II dose-finding outcomes to vector notation.</p></a></li>
<li><a href='#parse_phase1_outcomes'><p>Parse a string of phase I dose-finding outcomes to vector notation.</p></a></li>
<li><a href='#PatientSample'><p>A sample of patients to use in simulations.</p></a></li>
<li><a href='#phase1_2_outcomes_to_cohorts'><p>Break a phase I/II outcome string into a list of cohort parts.</p></a></li>
<li><a href='#phase1_outcomes_to_cohorts'><p>Break a phase I outcome string into a list of cohort parts.</p></a></li>
<li><a href='#prob_administer'><p>Percentage of patients treated at each dose.</p></a></li>
<li><a href='#prob_eff_quantile'><p>Quantile of the efficacy rate at each dose.</p></a></li>
<li><a href='#prob_recommend'><p>Probability of recommendation</p></a></li>
<li><a href='#prob_tox_exceeds'><p>Probability that the toxicity rate exceeds some threshold.</p></a></li>
<li><a href='#prob_tox_quantile'><p>Quantile of the toxicity rate at each dose.</p></a></li>
<li><a href='#prob_tox_samples'><p>Get samples of the probability of toxicity.</p></a></li>
<li><a href='#recommended_dose'><p>Recommended dose for next patient or cohort.</p></a></li>
<li><a href='#select_boin_mtd'><p>Select dose by BOIN's MTD-choosing algorithm.</p></a></li>
<li><a href='#select_boin12_obd'><p>Select dose by BOIN12's OBD-choosing algorithm.</p></a></li>
<li><a href='#select_dose_by_cibp'><p>Select dose by the CIBP selection criterion.</p></a></li>
<li><a href='#select_mtpi_mtd'><p>Select dose by mTPI's MTD-choosing algorithm.</p></a></li>
<li><a href='#select_mtpi2_mtd'><p>Select dose by mTPI2's MTD-choosing algorithm.</p></a></li>
<li><a href='#select_tpi_mtd'><p>Select dose by TPI's MTD-choosing algorithm.</p></a></li>
<li><a href='#selector'><p>Dose selector.</p></a></li>
<li><a href='#selector_factory'><p>Dose selector factory.</p></a></li>
<li><a href='#simulate_compare'><p>Simulate clinical trials for several designs using common patients.</p></a></li>
<li><a href='#simulate_trials'><p>Simulate clinical trials.</p></a></li>
<li><a href='#simulation_function'><p>Get function for simulating trials.</p></a></li>
<li><a href='#simulations'><p>Simulated trials.</p></a></li>
<li><a href='#simulations_collection'><p>Make an instance of type <code>simulations_collection</code></p></a></li>
<li><a href='#spread_paths'><p>Spread the information in dose_finding_paths object to a wide data.frame format.</p></a></li>
<li><a href='#stack_sims_vert'><p>Stack <code>simulations_collection</code> results vertically</p></a></li>
<li><a href='#stop_at_n'><p>Stop when there are n patients in total.</p></a></li>
<li><a href='#stop_when_n_at_dose'><p>Stop when there are n patients at a dose.</p></a></li>
<li><a href='#stop_when_too_toxic'><p>Stop trial and recommend no dose when a dose is too toxic.</p></a></li>
<li><a href='#stop_when_tox_ci_covered'><p>Stop when uncertainty interval of prob tox is covered.</p></a></li>
<li><a href='#supports_sampling'><p>Does this selector support sampling of outcomes?</p></a></li>
<li><a href='#three_plus_three'><p>Fit the 3+3 model to some outcomes.</p></a></li>
<li><a href='#tox'><p>Binary toxicity outcomes.</p></a></li>
<li><a href='#tox_at_dose'><p>Number of toxicities seen at each dose.</p></a></li>
<li><a href='#tox_limit'><p>Toxicity rate limit</p></a></li>
<li><a href='#tox_target'><p>Target toxicity rate</p></a></li>
<li><a href='#trial_duration'><p>Duration of trials.</p></a></li>
<li><a href='#try_rescue_dose'><p>Demand that a rescue dose is tried before stopping is permitted.</p></a></li>
<li><a href='#utility'><p>Utility score of each dose.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>A Modular Approach to Dose-Finding Clinical Trials</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.8</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-02-23</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Kristian Brock &lt;kristian.brock@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Methods for working with dose-finding clinical trials. We provide 
    implementations of many dose-finding clinical trial designs, including the 
    continual reassessment method (CRM) by O'Quigley et al. (1990) 
    &lt;<a href="https://doi.org/10.2307%2F2531628">doi:10.2307/2531628</a>&gt;, the toxicity probability interval (TPI) design by Ji
    et al. (2007) &lt;<a href="https://doi.org/10.1177%2F1740774507079442">doi:10.1177/1740774507079442</a>&gt;, the modified TPI (mTPI) design
    by Ji et al. (2010) &lt;<a href="https://doi.org/10.1177%2F1740774510382799">doi:10.1177/1740774510382799</a>&gt;, the Bayesian optimal 
    interval design (BOIN) by Liu &amp; Yuan (2015) &lt;<a href="https://doi.org/10.1111%2Frssc.12089">doi:10.1111/rssc.12089</a>&gt;, EffTox
    by Thall &amp; Cook (2004) &lt;<a href="https://doi.org/10.1111%2Fj.0006-341X.2004.00218.x">doi:10.1111/j.0006-341X.2004.00218.x</a>&gt;; the design of
    Wages &amp; Tait (2015) &lt;<a href="https://doi.org/10.1080%2F10543406.2014.920873">doi:10.1080/10543406.2014.920873</a>&gt;, and the 3+3 
    described by Korn et al. (1994) &lt;<a href="https://doi.org/10.1002%2Fsim.4780131802">doi:10.1002/sim.4780131802</a>&gt;. All designs
    are implemented with a common interface. We also offer optional additional 
    classes to tailor the behaviour of all designs, including avoiding skipping 
    doses, stopping after n patients have been treated at the recommended dose,  
    stopping when a toxicity condition is met, or demanding that n patients are 
    treated before stopping is allowed. By daisy-chaining together these classes
    using the pipe operator from 'magrittr', it is simple to tailor the 
    behaviour of a dose-finding design so it behaves how the trialist wants.
    Having provided a flexible interface for specifying designs, we then provide
    functions to run simulations and calculate dose-paths for future cohorts of 
    patients.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Depends:</td>
<td>magrittr</td>
</tr>
<tr>
<td>Imports:</td>
<td>dplyr, tidyr (&ge; 1.0), tidyselect, stringr, purrr, tibble,
ggplot2, gtools, dfcrm, BOIN, trialr (&ge; 0.1.5), DiagrammeR,
RColorBrewer, viridis, binom, R6, mvtnorm</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, knitr, rmarkdown, covr</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-02-23 14:47:17 UTC; kristian</td>
</tr>
<tr>
<td>Author:</td>
<td>Kristian Brock <a href="https://orcid.org/0000-0002-3921-0166"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Daniel Slade <a href="https://orcid.org/0000-0001-6063-1283"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Michael Sweeting <a href="https://orcid.org/0000-0003-0980-8956"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-02-23 16:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='as_tibble.derived_dose_selector'>Cast <code>dose_selector</code> object to <code><a href="tibble.html#topic+tibble">tibble</a></code>.</h2><span id='topic+as_tibble.derived_dose_selector'></span>

<h3>Description</h3>

<p>Cast <code>dose_selector</code> object to <code><a href="tibble.html#topic+tibble">tibble</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'derived_dose_selector'
as_tibble(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as_tibble.derived_dose_selector_+3A_x">x</code></td>
<td>
<p>Object of class <code>dose_selector</code>.</p>
</td></tr>
<tr><td><code id="as_tibble.derived_dose_selector_+3A_...">...</code></td>
<td>
<p>Extra args passed onwards.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Object of class <code><a href="tibble.html#topic+tibble">tibble</a></code>
</p>

<hr>
<h2 id='as_tibble.dose_paths'>Cast <code><a href="#topic+dose_paths">dose_paths</a></code> object to <code><a href="tibble.html#topic+tibble">tibble</a></code>.</h2><span id='topic+as_tibble.dose_paths'></span>

<h3>Description</h3>

<p>Cast <code><a href="#topic+dose_paths">dose_paths</a></code> object to <code><a href="tibble.html#topic+tibble">tibble</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dose_paths'
as_tibble(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as_tibble.dose_paths_+3A_x">x</code></td>
<td>
<p>Object of class <code>dose_finding_paths</code>.</p>
</td></tr>
<tr><td><code id="as_tibble.dose_paths_+3A_...">...</code></td>
<td>
<p>Extra args passed onwards.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Object of class <code><a href="tibble.html#topic+tibble">tibble</a></code>
</p>

<hr>
<h2 id='as_tibble.simulations_collection'>Convert a simulations_collection to a tibble</h2><span id='topic+as_tibble.simulations_collection'></span>

<h3>Description</h3>

<p>Cumulative statistics are shown to gauge how the simulations converge.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'simulations_collection'
as_tibble(x, target_dose = NULL, alpha = 0.05, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as_tibble.simulations_collection_+3A_x">x</code></td>
<td>
<p>object of type <code><a href="#topic+simulations_collection">simulations_collection</a></code></p>
</td></tr>
<tr><td><code id="as_tibble.simulations_collection_+3A_target_dose">target_dose</code></td>
<td>
<p>numerical dose index, or NULL (default) for all doses</p>
</td></tr>
<tr><td><code id="as_tibble.simulations_collection_+3A_alpha">alpha</code></td>
<td>
<p>significance level for symmetrical confidence intervals</p>
</td></tr>
<tr><td><code id="as_tibble.simulations_collection_+3A_...">...</code></td>
<td>
<p>extra args are ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a tibble with cols:
</p>

<ul>
<li> <p><code>dose</code>, the dose-level
</p>
</li>
<li> <p><code>n</code>, cumulative inference using the first n simulated iterations
</p>
</li>
<li> <p><code>design.x</code>, The first design in the comparison, aka design X
</p>
</li>
<li> <p><code>hit.x</code>, logical showing if design X recommended dose in iterate n
</p>
</li>
<li> <p><code>design.y</code>, The second design in the comparison, aka design Y
</p>
</li>
<li> <p><code>hit.x</code>, logical showing if design Y recommended dose in iterate n
</p>
</li>
<li> <p><code>X</code>, cumulative sum of hit.x within dose, i.e. count of recommendations
</p>
</li>
<li> <p><code>X2</code>, cumulative sum of hit.x^2 within dose
</p>
</li>
<li> <p><code>Y</code>, cumulative sum of hit.y within dose, i.e. count of recommendations
</p>
</li>
<li> <p><code>Y2</code>, cumulative sum of hit.y^2 within dose
</p>
</li>
<li> <p><code>XY</code>, cumulative sum of hit.x * hit.y within dose
</p>
</li>
<li> <p><code>psi1</code>, X / n
</p>
</li>
<li> <p><code>psi2</code>, Y / n
</p>
</li>
<li> <p><code>v_psi1</code>, variance of psi1
</p>
</li>
<li> <p><code>v_psi2</code>, variance of psi2
</p>
</li>
<li> <p><code>cov_psi12</code>, covariance of psi1 and psi2
</p>
</li>
<li> <p><code>delta</code>, psi1 - psi2
</p>
</li>
<li> <p><code>v_delta</code>, variance of delta
</p>
</li>
<li> <p><code>se_delta</code>, standard error of delta
</p>
</li>
<li> <p><code>delta_l</code>, delta - q * se_delta, where q is alpha / 2 normal quantile
</p>
</li>
<li> <p><code>delta_u</code>, delta + q * se_delta, where q is alpha / 2 normal quantile
</p>
</li>
<li> <p><code>comparison</code>, Label of design.x vs design.y, using design names
</p>
</li></ul>


<hr>
<h2 id='calculate_probabilities'>Calculate dose-path probabilities</h2><span id='topic+calculate_probabilities'></span>

<h3>Description</h3>

<p>Crystallise a set of <code><a href="#topic+dose_paths">dose_paths</a></code> with probabilities to calculate
how likely each path is. Once probabilised in this way, the probabilities of
the terminal nodes in this set of paths will sum to 1. This allows users to
calculate operating characteristics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculate_probabilities(dose_paths, true_prob_tox, true_prob_eff = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calculate_probabilities_+3A_dose_paths">dose_paths</code></td>
<td>
<p>Object of type <code><a href="#topic+dose_paths">dose_paths</a></code></p>
</td></tr>
<tr><td><code id="calculate_probabilities_+3A_true_prob_tox">true_prob_tox</code></td>
<td>
<p>Numeric vector, true probability of toxicity.</p>
</td></tr>
<tr><td><code id="calculate_probabilities_+3A_true_prob_eff">true_prob_eff</code></td>
<td>
<p>vector of true efficacy probabilities, optionally NULL
if efficacy not analysed.</p>
</td></tr>
<tr><td><code id="calculate_probabilities_+3A_...">...</code></td>
<td>
<p>Extra parameters</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+dose_paths">dose_paths</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Phase 1 example.
# Calculate dose paths for the first three cohorts in a 3+3 trial of 5 doses:
paths &lt;- get_three_plus_three(num_doses = 5) %&gt;%
  get_dose_paths(cohort_sizes = c(3, 3, 3))

# Set the true probabilities of toxicity
true_prob_tox &lt;- c(0.12, 0.27, 0.44, 0.53, 0.57)
# And calculate exact operating performance
x &lt;- paths %&gt;% calculate_probabilities(true_prob_tox)
prob_recommend(x)

# Phase 1/2 example.
prob_select = c(0.1, 0.3, 0.5, 0.07, 0.03)
selector_factory &lt;- get_random_selector(prob_select = prob_select,
                                        supports_efficacy = TRUE)
paths &lt;- selector_factory %&gt;% get_dose_paths(cohort_sizes = c(2, 2))
true_prob_eff &lt;- c(0.27, 0.35, 0.41, 0.44, 0.45)
x &lt;- paths %&gt;% calculate_probabilities(true_prob_tox = true_prob_tox,
                                       true_prob_eff = true_prob_eff)
prob_recommend(x)
</code></pre>

<hr>
<h2 id='cohort'>Cohort numbers of evaluated patients.</h2><span id='topic+cohort'></span>

<h3>Description</h3>

<p>Get a vector of integers that reflect the cohorts to which the evaluated
patients belong.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cohort(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cohort_+3A_x">x</code></td>
<td>
<p>Object of type <code><a href="#topic+selector">selector</a></code>.</p>
</td></tr>
<tr><td><code id="cohort_+3A_...">...</code></td>
<td>
<p>Extra args are passed onwards.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an integer vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'>skeleton &lt;- c(0.05, 0.1, 0.25, 0.4, 0.6)
target &lt;- 0.25
model &lt;- get_dfcrm(skeleton = skeleton, target = target)
fit &lt;- model %&gt;% fit('1NNN 2NTN')
fit %&gt;% cohort()
</code></pre>

<hr>
<h2 id='cohorts_of_n'>Sample times between patient arrivals using the exponential distribution.</h2><span id='topic+cohorts_of_n'></span>

<h3>Description</h3>

<p>Sample times between patient arrivals using the exponential distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cohorts_of_n(n = 3, mean_time_delta = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cohorts_of_n_+3A_n">n</code></td>
<td>
<p>integer, sample arrival times for this many patients.</p>
</td></tr>
<tr><td><code id="cohorts_of_n_+3A_mean_time_delta">mean_time_delta</code></td>
<td>
<p>the average gap between patient arrival times. I.e.
the reciprocal of the rate parameter in an Exponential distribution.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>data.frame</code> with column time_delta containing durations of time
between patient arrivals.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cohorts_of_n()
cohorts_of_n(n = 10, mean_time_delta = 5)
</code></pre>

<hr>
<h2 id='continue'>Should this dose-finding experiment continue?</h2><span id='topic+continue'></span>

<h3>Description</h3>

<p>Should this dose-finding experiment continue? Or have circumstances prevailed
that dictate this trial should stop? This method is critical to the automatic
calculation of statistical operating characteristics and dose-pathways. You
add stopping behaviours to designs using calls like <code><a href="#topic+stop_at_n">stop_at_n</a></code>
and <code><a href="#topic+stop_when_too_toxic">stop_when_too_toxic</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>continue(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="continue_+3A_x">x</code></td>
<td>
<p>Object of type <code><a href="#topic+selector">selector</a></code>.</p>
</td></tr>
<tr><td><code id="continue_+3A_...">...</code></td>
<td>
<p>Extra args are passed onwards.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>logical
</p>


<h3>Examples</h3>

<pre><code class='language-R'>skeleton &lt;- c(0.05, 0.1, 0.25, 0.4, 0.6)
target &lt;- 0.25
model1 &lt;- get_dfcrm(skeleton = skeleton, target = target)
fit1 &lt;- model1 %&gt;% fit('1NNN 2NTN')
fit1 %&gt;% continue()

model2 &lt;- get_dfcrm(skeleton = skeleton, target = target) %&gt;%
  stop_at_n(n = 6)
fit2 &lt;- model2 %&gt;% fit('1NNN 2NTN')
fit2 %&gt;% continue()
</code></pre>

<hr>
<h2 id='convergence_plot'>Plot the convergence processes from a collection of simulations.</h2><span id='topic+convergence_plot'></span>

<h3>Description</h3>

<p>Plot the convergence processes from a collection of simulations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convergence_plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="convergence_plot_+3A_x">x</code></td>
<td>
<p>object of type <code><a href="#topic+simulations_collection">simulations_collection</a></code></p>
</td></tr>
<tr><td><code id="convergence_plot_+3A_...">...</code></td>
<td>
<p>extra args are passed onwards to stack_sims_vert</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a ggplot2 plot
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# See ? simulate_compare

## End(Not run)
</code></pre>

<hr>
<h2 id='CorrelatedPatientSample'>A sample of patients that experience correlated events in simulations.</h2><span id='topic+CorrelatedPatientSample'></span>

<h3>Description</h3>

<p>Class to house the latent random variables that govern toxicity and efficacy
events in patients. Instances of this class can be used in simulation-like
tasks to effectively use the same simulated individuals in different designs,
thus supporting reduced Monte Carlo error and more efficient comparison. This
class differs from <code><a href="#topic+PatientSample">PatientSample</a></code> in that the latent variables
that underlie efficacy and toxicity events, and therefore those events
themselves, are correlated, e.g. for positive association, a patient that
experiences toxicity has increased probability of experiencing efficacy too.
Correlated uniformly-distributed variables are obtained by inverting
bivariate normal variables. The extent to which the events are correlated is
controlled by rho, the correlation of the two normal variables.
</p>


<h3>Super class</h3>

<p><code><a href="#topic+PatientSample">escalation::PatientSample</a></code> -&gt; <code>CorrelatedPatientSample</code>
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>num_patients</code></dt><dd><p>('integer(1)')<br /></p>
</dd>
<dt><code>mu</code></dt><dd><p>('numeric(2)')<br /></p>
</dd>
<dt><code>sigma</code></dt><dd><p>('matrix(2, 2)')<br /></p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-CorrelatedPatientSample-new"><code>CorrelatedPatientSample$new()</code></a>
</p>
</li>
<li> <p><a href="#method-CorrelatedPatientSample-expand_to"><code>CorrelatedPatientSample$expand_to()</code></a>
</p>
</li>
<li> <p><a href="#method-CorrelatedPatientSample-clone"><code>CorrelatedPatientSample$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="escalation" data-topic="PatientSample" data-id="get_eff_u"><a href='../../escalation/html/PatientSample.html#method-PatientSample-get_eff_u'><code>escalation::PatientSample$get_eff_u()</code></a></span></li>
<li><span class="pkg-link" data-pkg="escalation" data-topic="PatientSample" data-id="get_patient_eff"><a href='../../escalation/html/PatientSample.html#method-PatientSample-get_patient_eff'><code>escalation::PatientSample$get_patient_eff()</code></a></span></li>
<li><span class="pkg-link" data-pkg="escalation" data-topic="PatientSample" data-id="get_patient_tox"><a href='../../escalation/html/PatientSample.html#method-PatientSample-get_patient_tox'><code>escalation::PatientSample$get_patient_tox()</code></a></span></li>
<li><span class="pkg-link" data-pkg="escalation" data-topic="PatientSample" data-id="get_tox_u"><a href='../../escalation/html/PatientSample.html#method-PatientSample-get_tox_u'><code>escalation::PatientSample$get_tox_u()</code></a></span></li>
<li><span class="pkg-link" data-pkg="escalation" data-topic="PatientSample" data-id="set_eff_and_tox"><a href='../../escalation/html/PatientSample.html#method-PatientSample-set_eff_and_tox'><code>escalation::PatientSample$set_eff_and_tox()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-CorrelatedPatientSample-new"></a>



<h4>Method <code>new()</code></h4>

<p>Creator.
</p>


<h5>Usage</h5>

<div class="r"><pre>CorrelatedPatientSample$new(num_patients = 0, rho = 0)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>num_patients</code></dt><dd><p>('integer(1)').</p>
</dd>
<dt><code>rho</code></dt><dd><p>('integer(1)') correlation of</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>[CorrelatedPatientSample].
</p>


<hr>
<a id="method-CorrelatedPatientSample-expand_to"></a>



<h4>Method <code>expand_to()</code></h4>

<p>Expand sample to size at least num_patients
</p>


<h5>Usage</h5>

<div class="r"><pre>CorrelatedPatientSample$expand_to(num_patients)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>num_patients</code></dt><dd><p>('integer(1)').</p>
</dd>
</dl>

</div>


<hr>
<a id="method-CorrelatedPatientSample-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>CorrelatedPatientSample$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>References</h3>

<p>Sweeting, M., Slade, D., Jackson, D., &amp; Brock, K. (2023).
Potential outcome simulation for efficient head-to-head comparison of
adaptive dose-finding designs. Preprint.
</p>

<hr>
<h2 id='crystallised_dose_paths'>Dose-paths with probabilities attached.</h2><span id='topic+crystallised_dose_paths'></span>

<h3>Description</h3>

<p><code><a href="#topic+dose_paths">dose_paths</a></code> reflect all possible paths a dose-finding trial may
take. When the probability of those paths is calculated using an assumed set
of true dose-event probabilities, in this package those paths are said to be
crysallised. Once crystallised, operating charactersitics can be calculated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>crystallised_dose_paths(
  dose_paths,
  true_prob_tox,
  true_prob_eff = NULL,
  terminal_nodes
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="crystallised_dose_paths_+3A_dose_paths">dose_paths</code></td>
<td>
<p>Object of type <code><a href="#topic+dose_paths">dose_paths</a></code></p>
</td></tr>
<tr><td><code id="crystallised_dose_paths_+3A_true_prob_tox">true_prob_tox</code></td>
<td>
<p>vector of toxicity probabilities at doses 1..n</p>
</td></tr>
<tr><td><code id="crystallised_dose_paths_+3A_true_prob_eff">true_prob_eff</code></td>
<td>
<p>vector of efficacy probabilities at doses 1..n,
optionally NULL if efficacy not evaluated.</p>
</td></tr>
<tr><td><code id="crystallised_dose_paths_+3A_terminal_nodes">terminal_nodes</code></td>
<td>
<p>tibble of terminal nodes on the dose-paths</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of type crystallised_dose_paths
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Calculate dose paths for the first three cohorts in a 3+3 trial of 5 doses:
paths &lt;- get_three_plus_three(num_doses = 5) %&gt;%
  get_dose_paths(cohort_sizes = c(3, 3, 3))

# Set the true probabilities of toxicity
true_prob_tox &lt;- c(0.12, 0.27, 0.44, 0.53, 0.57)
# Crytallise the paths with the probabilities of toxicity
x &lt;- paths %&gt;% calculate_probabilities(true_prob_tox)
# And then examine, for example, the probabilities of recommending each dose
# at the terminal nodes of these paths:
prob_recommend(x)
</code></pre>

<hr>
<h2 id='demand_n_at_dose'>Demand there are n patients at a dose before condisdering stopping.</h2><span id='topic+demand_n_at_dose'></span>

<h3>Description</h3>

<p>This method continues a dose-finding trial until there are n patients at a
dose. Once that condition is met, it delegates stopping responsibility to its
parent dose selector, whatever that might be. This class is greedy in that it
meets its own needs before asking any other selectors in a chain what they
want. Thus, different behaviours may be achieved by nesting dose selectors
in different orders. See examples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>demand_n_at_dose(parent_selector_factory, n, dose)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="demand_n_at_dose_+3A_parent_selector_factory">parent_selector_factory</code></td>
<td>
<p>Object of type <code><a href="#topic+selector_factory">selector_factory</a></code>.</p>
</td></tr>
<tr><td><code id="demand_n_at_dose_+3A_n">n</code></td>
<td>
<p>Continue at least until there are n at a dose.</p>
</td></tr>
<tr><td><code id="demand_n_at_dose_+3A_dose">dose</code></td>
<td>
<p><code>'any'</code> to continue until there are n at any dose;
<code>'recommended'</code> to continue until there are n at the recommended dose;
or an integer to continue until there are n at a particular dose-level.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of type <code><a href="#topic+selector_factory">selector_factory</a></code> that can fit a
dose-finding model to outcomes.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>skeleton &lt;- c(0.05, 0.1, 0.25, 0.4, 0.6)
target &lt;- 0.25

# This model will demand 9 at any dose before it countenances stopping.
model1 &lt;- get_dfcrm(skeleton = skeleton, target = target) %&gt;%
  demand_n_at_dose(n = 9, dose = 'any')

# This model will recommend continuing:
model1 %&gt;% fit('1NNT 1NNN 2TNN 2NNN') %&gt;% continue()
# It tells you to continue because there is no selector considering when
# you should stop - dfcrm implements no stopping rule by default.

# In contrast, we can add a stopping selector to discern the behaviour of
# demand_n_at_dose. We will demand 9 are seen at the recommended dose before
# stopping is permitted in model3:
model2 &lt;- get_dfcrm(skeleton = skeleton, target = target) %&gt;%
  stop_at_n(n = 12)
model3 &lt;- get_dfcrm(skeleton = skeleton, target = target) %&gt;%
  stop_at_n(n = 12) %&gt;%
  demand_n_at_dose(n = 9, dose = 'recommended')

# This model advocates stopping because 12 patients are seen in total:
model2 %&gt;% fit('1NNN 1NNN 2TNN 2NNN') %&gt;% continue()
# But this model advocates continuing because 9 patients have not been seen
# at any dose yet:
model3 %&gt;% fit('1NNN 1NNN 2TNN 2NNN') %&gt;% continue()
# This shows how demand_n_at_dose overrides stopping behaviours that come
# before it in the daisychain.

# Once 9 are seen at the recommended dose, the decision to stop is made:
fit &lt;- model3 %&gt;% fit('1NNN 1NNN 2TNN 2NNN 2TTN')
fit %&gt;% continue()
fit %&gt;% recommended_dose()
</code></pre>

<hr>
<h2 id='dont_skip_doses'>Prevent skipping of doses.</h2><span id='topic+dont_skip_doses'></span>

<h3>Description</h3>

<p>This method optionally prevents dose selectors from skipping doses when
escalating and / or deescalating. The default is that skipping when
escalating is prevented but skipping when deescalating is permitted, but both
of these behaviours can be altered.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dont_skip_doses(
  parent_selector_factory,
  when_escalating = TRUE,
  when_deescalating = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dont_skip_doses_+3A_parent_selector_factory">parent_selector_factory</code></td>
<td>
<p>Object of type <code><a href="#topic+selector_factory">selector_factory</a></code>.</p>
</td></tr>
<tr><td><code id="dont_skip_doses_+3A_when_escalating">when_escalating</code></td>
<td>
<p>TRUE to prevent skipping when attempting to escalate.</p>
</td></tr>
<tr><td><code id="dont_skip_doses_+3A_when_deescalating">when_deescalating</code></td>
<td>
<p>TRUE to prevent skipping when attempting to
deescalate.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of type <code><a href="#topic+selector_factory">selector_factory</a></code> that can fit a
dose-finding model to outcomes.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>skeleton &lt;- c(0.05, 0.1, 0.25, 0.4, 0.6)
target &lt;- 0.25
model1 &lt;- get_dfcrm(skeleton = skeleton, target = target) %&gt;%
  dont_skip_doses()
fit1 &lt;- model1 %&gt;% fit('1NNN')

model2 &lt;- get_dfcrm(skeleton = skeleton, target = target)
fit2 &lt;- model2 %&gt;% fit('1NNN')

# fit1 will not skip doses
fit1 %&gt;% recommended_dose()
# But fit2 will:
fit2 %&gt;% recommended_dose()

# Similar demonstration for de-escalation
model1 &lt;- get_dfcrm(skeleton = skeleton, target = target) %&gt;%
  dont_skip_doses(when_deescalating = TRUE)
fit1 &lt;- model1 %&gt;% fit('1NNN 2N 3TTT')

model2 &lt;- get_dfcrm(skeleton = skeleton, target = target)
fit2 &lt;- model2 %&gt;% fit('1NNN 2N 3TTT')

# fit1 will not skip doses
fit1 %&gt;% recommended_dose()
# But fit2 will:
fit2 %&gt;% recommended_dose()
</code></pre>

<hr>
<h2 id='dose_admissible'>Is each dose admissible?</h2><span id='topic+dose_admissible'></span>

<h3>Description</h3>

<p>Get a vector of logical values reflecting whether each dose is admissible.
Admissibility is defined in different ways for different models, and may not
be defined at all in some models. For instance, in the TPI method, doses are
inadmissible when the posterior probability is high that the toxicity rate
exceeds the target value. In contrast, admissibility is not defined in the
general CRM model (but it can be added with auxiliary classes). In this
latter case, doses are implicitly considered to be admissible, by default.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dose_admissible(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dose_admissible_+3A_x">x</code></td>
<td>
<p>Object of class <code><a href="#topic+selector">selector</a></code></p>
</td></tr>
<tr><td><code id="dose_admissible_+3A_...">...</code></td>
<td>
<p>arguments passed to other methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a logical vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'>outcomes &lt;- '1NNN 2TTT'

# TPI example. This method defines admissibility.
fit1 &lt;- get_tpi(num_doses = 5, target = 0.3, k1 = 1, k2 = 1.5,
                exclusion_certainty = 0.95) %&gt;%
  fit(outcomes)
fit1 %&gt;% dose_admissible()

# Ordinary CRM example with no admissibility function.
skeleton &lt;- c(0.05, 0.1, 0.25, 0.4, 0.6)
target &lt;- 0.25
fit2 &lt;- get_dfcrm(skeleton = skeleton, target = target) %&gt;%
  fit(outcomes)
fit2 %&gt;% dose_admissible()

# Same CRM example with added admissibility function
fit3 &lt;- get_dfcrm(skeleton = skeleton, target = target) %&gt;%
  stop_when_too_toxic(dose = 1, tox_threshold = target, confidence = 0.8) %&gt;%
  fit(outcomes)
fit3 %&gt;% dose_admissible()
</code></pre>

<hr>
<h2 id='dose_indices'>Dose indices</h2><span id='topic+dose_indices'></span>

<h3>Description</h3>

<p>Get the integers from 1 to the number of doses under investigation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dose_indices(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dose_indices_+3A_x">x</code></td>
<td>
<p>Object of type <code><a href="#topic+selector">selector</a></code>.</p>
</td></tr>
<tr><td><code id="dose_indices_+3A_...">...</code></td>
<td>
<p>Extra args are passed onwards.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an integer vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'>skeleton &lt;- c(0.05, 0.1, 0.25, 0.4, 0.6)
target &lt;- 0.25
model &lt;- get_dfcrm(skeleton = skeleton, target = target)
fit &lt;- model %&gt;% fit('1NNN 2NTN')
fit %&gt;% dose_indices()
</code></pre>

<hr>
<h2 id='dose_paths'>Dose pathways</h2><span id='topic+dose_paths'></span>

<h3>Description</h3>

<p>A dose-escalation design exists to select doses in response to observed
outcomes. The entire space of possible responses can be calculated to show
the behaviour of a design in response to all feasible outcomes. The
<code><a href="#topic+get_dose_paths">get_dose_paths</a></code> function performs that task and returns an
instance of this object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dose_paths()
</code></pre>


<h3>See Also</h3>

<p><code><a href="#topic+selector">selector</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Calculate dose-paths for the 3+3 design:
paths &lt;- get_three_plus_three(num_doses = 5) %&gt;%
  get_dose_paths(cohort_sizes = c(3, 3))
</code></pre>

<hr>
<h2 id='dose_paths_function'>Get function for calculating dose pathways.</h2><span id='topic+dose_paths_function'></span>

<h3>Description</h3>

<p>This function does not need to be called by users. It is used internally.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dose_paths_function(selector_factory)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dose_paths_function_+3A_selector_factory">selector_factory</code></td>
<td>
<p>Object of type <code><a href="#topic+selector_factory">selector_factory</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A function.
</p>

<hr>
<h2 id='doses_given'>Doses given to patients.</h2><span id='topic+doses_given'></span>

<h3>Description</h3>

<p>Get a vector of the dose-levels that have been administered to patients.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>doses_given(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="doses_given_+3A_x">x</code></td>
<td>
<p>Object of type <code><a href="#topic+selector">selector</a></code>.</p>
</td></tr>
<tr><td><code id="doses_given_+3A_...">...</code></td>
<td>
<p>Extra args are passed onwards.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an integer vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'>skeleton &lt;- c(0.05, 0.1, 0.25, 0.4, 0.6)
target &lt;- 0.25
model &lt;- get_dfcrm(skeleton = skeleton, target = target)
fit &lt;- model %&gt;% fit('1NNN 2NTN')
fit %&gt;% doses_given()
</code></pre>

<hr>
<h2 id='eff'>Binary efficacy outcomes.</h2><span id='topic+eff'></span>

<h3>Description</h3>

<p>Get a vector of the binary efficacy outcomes for evaluated patients.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eff(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="eff_+3A_x">x</code></td>
<td>
<p>Object of type <code><a href="#topic+selector">selector</a></code>.</p>
</td></tr>
<tr><td><code id="eff_+3A_...">...</code></td>
<td>
<p>Extra args are passed onwards.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an integer vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'>prob_select = c(0.1, 0.3, 0.5, 0.07, 0.03)
model &lt;- get_random_selector(prob_select = prob_select,
                             supports_efficacy = TRUE)
x &lt;- model %&gt;% fit('1NTN 2EN 5BB')
eff(x)
</code></pre>

<hr>
<h2 id='eff_at_dose'>Number of toxicities seen at each dose.</h2><span id='topic+eff_at_dose'></span>

<h3>Description</h3>

<p>Get the number of toxicities seen at each dose under investigation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eff_at_dose(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="eff_at_dose_+3A_x">x</code></td>
<td>
<p>Object of class <code><a href="#topic+selector">selector</a></code></p>
</td></tr>
<tr><td><code id="eff_at_dose_+3A_...">...</code></td>
<td>
<p>arguments passed to other methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an integer vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'>prob_select = c(0.1, 0.3, 0.5, 0.07, 0.03)
model &lt;- get_random_selector(prob_select = prob_select,
                             supports_efficacy = TRUE)
x &lt;- model %&gt;% fit('1NTN 2EN 5BB')
eff_at_dose(x)
</code></pre>

<hr>
<h2 id='eff_limit'>Efficacy rate limit</h2><span id='topic+eff_limit'></span>

<h3>Description</h3>

<p>Get the minimum permissible efficacy rate, if supported. NULL if not.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eff_limit(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="eff_limit_+3A_x">x</code></td>
<td>
<p>Object of type <code><a href="#topic+selector">selector</a></code>.</p>
</td></tr>
<tr><td><code id="eff_limit_+3A_...">...</code></td>
<td>
<p>Extra args are passed onwards.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric
</p>


<h3>Examples</h3>

<pre><code class='language-R'>efftox_priors &lt;- trialr::efftox_priors
p &lt;- efftox_priors(alpha_mean = -7.9593, alpha_sd = 3.5487,
                   beta_mean = 1.5482, beta_sd = 3.5018,
                   gamma_mean = 0.7367, gamma_sd = 2.5423,
                   zeta_mean = 3.4181, zeta_sd = 2.4406,
                   eta_mean = 0, eta_sd = 0.2,
                   psi_mean = 0, psi_sd = 1)
real_doses = c(1.0, 2.0, 4.0, 6.6, 10.0)
model &lt;- get_trialr_efftox(real_doses = real_doses,
                           efficacy_hurdle = 0.5, toxicity_hurdle = 0.3,
                           p_e = 0.1, p_t = 0.1,
                           eff0 = 0.5, tox1 = 0.65,
                           eff_star = 0.7, tox_star = 0.25,
                           priors = p, iter = 1000, chains = 1, seed = 2020)
x &lt;- model %&gt;% fit('1N 2E 3B')
eff_limit(x)
</code></pre>

<hr>
<h2 id='empiric_eff_rate'>Observed efficacy rate at each dose.</h2><span id='topic+empiric_eff_rate'></span>

<h3>Description</h3>

<p>Get the empirical or observed efficacy rate seen at each dose under
investigation. This is simply the number of efficacies divded by the number
of patients evaluated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>empiric_eff_rate(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="empiric_eff_rate_+3A_x">x</code></td>
<td>
<p>Object of class <code><a href="#topic+selector">selector</a></code></p>
</td></tr>
<tr><td><code id="empiric_eff_rate_+3A_...">...</code></td>
<td>
<p>arguments passed to other methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a numerical vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'>prob_select = c(0.1, 0.3, 0.5, 0.07, 0.03)
model &lt;- get_random_selector(prob_select = prob_select,
                             supports_efficacy = TRUE)
x &lt;- model %&gt;% fit('1NTN 2EN 5BB')
empiric_tox_rate(x)
</code></pre>

<hr>
<h2 id='empiric_tox_rate'>Observed toxicity rate at each dose.</h2><span id='topic+empiric_tox_rate'></span>

<h3>Description</h3>

<p>Get the empirical or observed toxicity rate seen at each dose under
investigation. This is simply the number of toxicities divded by the number
of patients evaluated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>empiric_tox_rate(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="empiric_tox_rate_+3A_x">x</code></td>
<td>
<p>Object of class <code><a href="#topic+selector">selector</a></code></p>
</td></tr>
<tr><td><code id="empiric_tox_rate_+3A_...">...</code></td>
<td>
<p>arguments passed to other methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a numerical vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'># CRM example
skeleton &lt;- c(0.05, 0.1, 0.25, 0.4, 0.6)
target &lt;- 0.25
outcomes &lt;- '1NNN 2NTN'
fit &lt;- get_dfcrm(skeleton = skeleton, target = target) %&gt;% fit(outcomes)
fit %&gt;% empiric_tox_rate()
</code></pre>

<hr>
<h2 id='enforce_three_plus_three'>Enforce that a trial path has followed the 3+3 method.</h2><span id='topic+enforce_three_plus_three'></span>

<h3>Description</h3>

<p>This function stops with en error if it detects that outcomes describing  a
trial path have diverged from that advocated by the 3+3 method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>enforce_three_plus_three(outcomes, allow_deescalate = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="enforce_three_plus_three_+3A_outcomes">outcomes</code></td>
<td>
<p>Outcomes observed. See <code><a href="#topic+parse_phase1_outcomes">parse_phase1_outcomes</a></code>.</p>
</td></tr>
<tr><td><code id="enforce_three_plus_three_+3A_allow_deescalate">allow_deescalate</code></td>
<td>
<p>TRUE to allow de-escalation, as described by Korn et
al. Default is FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Nothing. Function stops if problem detected.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
enforce_three_plus_three('1NNN 2NTN 2NNN')  # OK
enforce_three_plus_three('1NNN 2NTN 2N')  # OK too, albeit in-progress cohort
enforce_three_plus_three('1NNN 1N')  # Not OK because should have escalated

## End(Not run)
</code></pre>

<hr>
<h2 id='escalation-package'>The 'escalation' package.</h2><span id='topic+escalation-package'></span><span id='topic+escalation'></span>

<h3>Description</h3>

<p>escalation provides methods for working with dose-finding clinical trials.
We provide implementations of many dose-finding clinical trial designs,
ncluding the continual reassessment method (CRM) by O'Quigley et al. (1990)
&lt;doi:10.2307/2531628&gt;, the toxicity probability interval (TPI) design by Ji
et al. (2007) &lt;doi:10.1177/1740774507079442&gt;, the modified TPI (mTPI) design
by Ji et al. (2010) &lt;doi:10.1177/1740774510382799&gt;, the Bayesian optimal
interval design (BOIN) by Liu &amp; Yuan (2015) &lt;doi:10.1111/rssc.12089&gt;, EffTox
by Thall &amp; Cook (2004) &lt;doi:10.1111/j.0006-341X.2004.00218.x&gt;; the design of
Wages &amp; Tait (2015) &lt;doi:10.1080/10543406.2014.920873&gt;, and the 3+3
described by Korn et al. (1994) &lt;doi:10.1002/sim.4780131802&gt;. All designs
are implemented with a common interface. We also offer optional additional
classes to tailor the behaviour of all designs, including avoiding skipping
doses, stopping after n patients have been treated at the recommended dose,
stopping when a toxicity condition is met, or demanding that n patients are
treated before stopping is allowed. By daisy-chaining together these classes
using the pipe operator from 'magrittr', it is simple to tailor the
behaviour of a dose-finding design so it behaves how the trialist wants.
Having provided a flexible interface for specifying designs, we then provide
functions to run simulations and calculate dose-paths for future cohorts of
patients.
</p>

<hr>
<h2 id='fit'>Fit a dose-finding model.</h2><span id='topic+fit'></span>

<h3>Description</h3>

<p>Fit a dose-finding model to some outcomes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit(selector_factory, outcomes, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fit_+3A_selector_factory">selector_factory</code></td>
<td>
<p>Object of type <code><a href="#topic+selector_factory">selector_factory</a></code>.</p>
</td></tr>
<tr><td><code id="fit_+3A_outcomes">outcomes</code></td>
<td>
<p>Outcome string. See <code><a href="#topic+parse_phase1_outcomes">parse_phase1_outcomes</a></code>.</p>
</td></tr>
<tr><td><code id="fit_+3A_...">...</code></td>
<td>
<p>Extra args are passed onwards.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Object of generic type <code><a href="#topic+selector">selector</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+selector">selector</a></code>, <code><a href="#topic+selector_factory">selector_factory</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>skeleton &lt;- c(0.05, 0.1, 0.25, 0.4, 0.6)
target &lt;- 0.25
model &lt;- get_dfcrm(skeleton = skeleton, target = target)
fit &lt;- model %&gt;% fit('1NNN 2NTN')
fit %&gt;% recommended_dose()  # Etc
</code></pre>

<hr>
<h2 id='follow_path'>Follow a pre-determined dose administration path.</h2><span id='topic+follow_path'></span>

<h3>Description</h3>

<p>This method creates a dose selector that will follow a pre-specified trial
path. Whilst the trial path is matched by realised outcomes, the selector
will recommend the next dose in the desired sequence. As soon as the observed
outcomes diverge from the desired path, the selector stops giving dose
recommendations. This makes it possible, for instance, to specify a fixed
escalation plan that should be followed until the first toxicity is seen.
This tactic is used by some model-based designs to get rapidly to the doses
where the action is. See, for example, the dfcrm package and Cheung (2011).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>follow_path(path)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="follow_path_+3A_path">path</code></td>
<td>
<p>Follow this outcome path. See <code><a href="#topic+parse_phase1_outcomes">parse_phase1_outcomes</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of type <code><a href="#topic+selector_factory">selector_factory</a></code> that can fit a
dose-finding model to outcomes.
</p>


<h3>References</h3>

<p>Cheung. Dose Finding by the Continual Reassessment Method. 2011.
Chapman and Hall/CRC. ISBN 9781420091519
</p>


<h3>Examples</h3>

<pre><code class='language-R'>model1 &lt;- follow_path(path = '1NNN 2NNN 3NNN 4NNN')

fit1 &lt;- model1 %&gt;% fit('1NNN 2N')
fit1 %&gt;% recommended_dose()
fit1 %&gt;% continue()
# The model recommends continuing at dose 2 because the observed outcomes
# perfectly match the desired escalation path.

fit2 &lt;- model1 %&gt;% fit('1NNN 2NT')
fit2 %&gt;% recommended_dose()
fit2 %&gt;% continue()
# Uh oh. Toxicity has now been seen, the outcomes diverge from the sought
# path, hence this class recommends no dose now.
# At this point, we can hand over dose selection decisions to another class
# by chaining them together, like:
model2 &lt;- follow_path(path = '1NNN 2NNN 3NNN 4NNN') %&gt;%
  get_dfcrm(skeleton = c(0.05, 0.1, 0.25, 0.4, 0.6), target = 0.25)
fit3 &lt;- model2 %&gt;% fit('1NNN 2NT')
# Now the CRM model is using all of the outcomes to calculate the next dose:
fit3 %&gt;% recommended_dose()
fit3 %&gt;% continue()
</code></pre>

<hr>
<h2 id='get_boin'>Get an object to fit the BOIN model using the BOIN package.</h2><span id='topic+get_boin'></span>

<h3>Description</h3>

<p>Get an object to fit the BOIN model using the BOIN package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_boin(num_doses, target, use_stopping_rule = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_boin_+3A_num_doses">num_doses</code></td>
<td>
<p>Number of doses under investigation.</p>
</td></tr>
<tr><td><code id="get_boin_+3A_target">target</code></td>
<td>
<p>We seek a dose with this probability of toxicity.</p>
</td></tr>
<tr><td><code id="get_boin_+3A_use_stopping_rule">use_stopping_rule</code></td>
<td>
<p>TRUE to use the toxicity stopping rule described in
Yan et al. (2019). FALSE to suppress the authors' stopping rule, with the
assumption being that you will test the necessity to stop early in some other
way.</p>
</td></tr>
<tr><td><code id="get_boin_+3A_...">...</code></td>
<td>
<p>Extra args are passed to <code><a href="BOIN.html#topic+get.boundary">get.boundary</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of type <code><a href="#topic+selector_factory">selector_factory</a></code> that can fit the
BOIN model to outcomes.
</p>


<h3>References</h3>

<p>Yan, F., Pan, H., Zhang, L., Liu, S., &amp; Yuan, Y. (2019).
BOIN: An R Package for Designing Single-Agent and Drug-Combination
Dose-Finding Trials Using Bayesian Optimal Interval Designs.
Journal of Statistical Software, 27(November 2017), 035.
https://doi.org/10.18637/jss.v000.i00
</p>
<p>Liu, S., &amp; Yuan, Y. (2015).
Bayesian optimal designs for Phase I clinical trials.
J. R. Stat. Soc. C, 64, 507523.
https://doi.org/10.1111/rssc.12089
</p>


<h3>Examples</h3>

<pre><code class='language-R'>target &lt;- 0.25
model1 &lt;- get_boin(num_doses = 5, target = target)

outcomes &lt;- '1NNN 2NTN'
model1 %&gt;% fit(outcomes) %&gt;% recommended_dose()

</code></pre>

<hr>
<h2 id='get_boin12'>Get an object to fit the BOIN12 model for phase I/II dose-finding.</h2><span id='topic+get_boin12'></span>

<h3>Description</h3>

<p>This function returns an object that can be used to fit the BOIN12 model for
phase I/II dose-finding, i.e. it selects doses according to efficacy and
toxicity outcomes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_boin12(
  num_doses,
  phi_t,
  phi_e,
  u1 = 100,
  u2,
  u3,
  u4 = 0,
  n_star = 6,
  c_t = 0.95,
  c_e = 0.9,
  start_dose = 1,
  prior_alpha = 1,
  prior_beta = 1,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_boin12_+3A_num_doses">num_doses</code></td>
<td>
<p>integer, num of doses under investigation</p>
</td></tr>
<tr><td><code id="get_boin12_+3A_phi_t">phi_t</code></td>
<td>
<p>Probability of toxicity threshold</p>
</td></tr>
<tr><td><code id="get_boin12_+3A_phi_e">phi_e</code></td>
<td>
<p>Probability of efficacy threshold</p>
</td></tr>
<tr><td><code id="get_boin12_+3A_u1">u1</code></td>
<td>
<p>utility of efficacy without toxicity, 100 by default</p>
</td></tr>
<tr><td><code id="get_boin12_+3A_u2">u2</code></td>
<td>
<p>utility of no efficacy and no toxicity, between u1 and u4</p>
</td></tr>
<tr><td><code id="get_boin12_+3A_u3">u3</code></td>
<td>
<p>utility of efficacy and toxicity, between u1 and u4</p>
</td></tr>
<tr><td><code id="get_boin12_+3A_u4">u4</code></td>
<td>
<p>utility of toxicity without efficacy , 0 by default</p>
</td></tr>
<tr><td><code id="get_boin12_+3A_n_star">n_star</code></td>
<td>
<p>when tox is within bounds, stop exploring higher doses when n
at dose is greater than or equal to this value. 6 by default.</p>
</td></tr>
<tr><td><code id="get_boin12_+3A_c_t">c_t</code></td>
<td>
<p>certainty required to flag excess toxicity, 0.95 by default</p>
</td></tr>
<tr><td><code id="get_boin12_+3A_c_e">c_e</code></td>
<td>
<p>certainty required to flag deficient efficacy, 0.9 by default</p>
</td></tr>
<tr><td><code id="get_boin12_+3A_start_dose">start_dose</code></td>
<td>
<p>index of starting dose, 1 by default (i.e. lowest dose)</p>
</td></tr>
<tr><td><code id="get_boin12_+3A_prior_alpha">prior_alpha</code></td>
<td>
<p>first shape param for prior on beta prior, 1 by default</p>
</td></tr>
<tr><td><code id="get_boin12_+3A_prior_beta">prior_beta</code></td>
<td>
<p>second shape param for prior on beta prior, 1 by default</p>
</td></tr>
<tr><td><code id="get_boin12_+3A_...">...</code></td>
<td>
<p>Extra args are passed onwards.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of type <code><a href="#topic+selector_factory">selector_factory</a></code> that can fit the
BOIN12 model to outcomes.
</p>


<h3>References</h3>

<p>Lin, R., Zhou, Y., Yan, F., Li, D., &amp; Yuan, Y. (2020).
BOIN12: Bayesian optimal interval phase I/II trial design for utility-based
dose finding in immunotherapy and targeted therapies.
JCO precision oncology, 4, 1393-1402.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Examples in Lin et al.
model &lt;- get_boin12(num_doses = 5, phi_t = 0.35, phi_e = 0.25,
                    u2 = 40, u3 = 60, n_star = 6)
fit &lt;- model %&gt;% fit('1NNN 2ENT 3ETT 2EEN')
fit %&gt;% recommended_dose()
fit %&gt;% continue()
fit %&gt;% is_randomising()
fit %&gt;% dose_admissible()
fit %&gt;% prob_administer()

</code></pre>

<hr>
<h2 id='get_dfcrm'>Get an object to fit the CRM model using the dfcrm package.</h2><span id='topic+get_dfcrm'></span>

<h3>Description</h3>

<p>This function returns an object that can be used to fit a CRM model using
methods provided by the dfcrm package.
</p>
<p>Dose selectors are designed to be daisy-chained together to achieve different
behaviours. This class is a **resumptive** selector, meaning it carries on
when the previous dose selector, where present, has elected not to continue.
For example, this allows instances of this class to be preceded by a selector
that follows a fixed path in an initial escalation plan, such as that
provided by <code><a href="#topic+follow_path">follow_path</a></code>. In this example, when the observed
trial outcomes deviate from that initial plan, the selector following the
fixed path elects not to continue and responsibility passes to this class.
See Examples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_dfcrm(parent_selector_factory = NULL, skeleton, target, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_dfcrm_+3A_parent_selector_factory">parent_selector_factory</code></td>
<td>
<p>optional object of type
<code><a href="#topic+selector_factory">selector_factory</a></code> that is in charge of dose selection before
this class gets involved. Leave as NULL to just use CRM from the start.</p>
</td></tr>
<tr><td><code id="get_dfcrm_+3A_skeleton">skeleton</code></td>
<td>
<p>Dose-toxicity skeleton, a non-decreasing vector of
probabilities.</p>
</td></tr>
<tr><td><code id="get_dfcrm_+3A_target">target</code></td>
<td>
<p>We seek a dose with this probability of toxicity.</p>
</td></tr>
<tr><td><code id="get_dfcrm_+3A_...">...</code></td>
<td>
<p>Extra args are passed to <code><a href="dfcrm.html#topic+crm">crm</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of type <code><a href="#topic+selector_factory">selector_factory</a></code> that can fit the
CRM model to outcomes.
</p>


<h3>References</h3>

<p>Cheung, K. 2019. dfcrm: Dose-Finding by the Continual Reassessment Method.
R package version 0.2-2.1. https://CRAN.R-project.org/package=dfcrm
</p>
<p>Cheung, K. 2011. Dose Finding by the Continual Reassessment Method.
Chapman and Hall/CRC. ISBN 9781420091519
</p>
<p>OQuigley J, Pepe M, Fisher L. Continual reassessment method: a practical
design for phase 1 clinical trials in cancer. Biometrics. 1990;46(1):33-48.
doi:10.2307/2531628
</p>


<h3>Examples</h3>

<pre><code class='language-R'>skeleton &lt;- c(0.05, 0.1, 0.25, 0.4, 0.6)
target &lt;- 0.25
model1 &lt;- get_dfcrm(skeleton = skeleton, target = target)

# By default, dfcrm fits the empiric model:
outcomes &lt;- '1NNN 2NTN'
model1 %&gt;% fit(outcomes) %&gt;% recommended_dose()

# But we can provide extra args to get_dfcrm that are than passed onwards to
# the call to dfcrm::crm to override the defaults. For example, if we want
# the one-parameter logistic model:
model2 &lt;- get_dfcrm(skeleton = skeleton, target = target, model = 'logistic')
model2 %&gt;% fit(outcomes) %&gt;% recommended_dose()
# dfcrm does not offer a two-parameter logistic model but other classes do.

# We can use an initial dose-escalation plan, a pre-specified path that
# should be followed until trial outcomes deviate, at which point the CRM
# model takes over. For instance, if we want to use two patients at each of
# the first three doses in the absence of toxicity, irrespective the model's
# advice, we would run:
model1 &lt;- follow_path('1NN 2NN 3NN') %&gt;%
  get_dfcrm(skeleton = skeleton, target = target)

# If outcomes match the desired path, the path is followed further:
model1 %&gt;% fit('1NN 2N') %&gt;% recommended_dose()

# But when the outcomes diverge:
model1 %&gt;% fit('1NN 2T') %&gt;% recommended_dose()

# Or the pre-specified path comes to an end:
model1 %&gt;% fit('1NN 2NN 3NN') %&gt;% recommended_dose()
# The CRM model takes over.

</code></pre>

<hr>
<h2 id='get_dose_paths'>Calculate future dose paths.</h2><span id='topic+get_dose_paths'></span>

<h3>Description</h3>

<p>A dose-escalation design exists to select doses in response to observed
outcomes. The entire space of possible responses can be calculated to show
the behaviour of a design in response to all feasible outcomes. This function
performs that task.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_dose_paths(selector_factory, cohort_sizes, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_dose_paths_+3A_selector_factory">selector_factory</code></td>
<td>
<p>Object of type <code><a href="#topic+selector_factory">selector_factory</a></code>.</p>
</td></tr>
<tr><td><code id="get_dose_paths_+3A_cohort_sizes">cohort_sizes</code></td>
<td>
<p>Integer vector representing sizes of</p>
</td></tr>
<tr><td><code id="get_dose_paths_+3A_...">...</code></td>
<td>
<p>Extra args are passed onwards.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Object of type <code><a href="#topic+dose_paths">dose_paths</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Calculate paths for a 3+3 design for the next two cohorts of three patients
paths &lt;- get_three_plus_three(num_doses = 5) %&gt;%
  get_dose_paths(cohort_sizes = c(3, 3))
</code></pre>

<hr>
<h2 id='get_empiric_crm_skeleton_weights'>Get posterior model weights for several empiric CRM skeletons.</h2><span id='topic+get_empiric_crm_skeleton_weights'></span>

<h3>Description</h3>

<p>Get posterior model weights for several empiric CRM skeletons, assuming a
normal prior on the beta model parameter
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_empiric_crm_skeleton_weights(
  skeletons,
  events_at_dose,
  n_at_dose,
  prior = rep(1, nrow(skeletons))
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_empiric_crm_skeleton_weights_+3A_skeletons">skeletons</code></td>
<td>
<p>matrix with one skeleton per row, so that the number of
columns is the number of doses under investigation.</p>
</td></tr>
<tr><td><code id="get_empiric_crm_skeleton_weights_+3A_events_at_dose">events_at_dose</code></td>
<td>
<p>integer vector of number of events at doses</p>
</td></tr>
<tr><td><code id="get_empiric_crm_skeleton_weights_+3A_n_at_dose">n_at_dose</code></td>
<td>
<p>integer vector of number of patients at doses</p>
</td></tr>
<tr><td><code id="get_empiric_crm_skeleton_weights_+3A_prior">prior</code></td>
<td>
<p>vector of prior model weights. Length should be same as number
of rows in <code>skeletons</code>. Default is equal weighting.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numerical vector, posterior weights of the skeletons.
</p>

<hr>
<h2 id='get_mtpi'>Get an object to fit the mTPI dose-finding model.</h2><span id='topic+get_mtpi'></span>

<h3>Description</h3>

<p>The modified toxicity probability interval (mTPI)is a dose-escalation design
by Ji et al. As the name suggests, it is an adaptation of the TPI design.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_mtpi(
  parent_selector_factory = NULL,
  num_doses,
  target,
  epsilon1,
  epsilon2,
  exclusion_certainty,
  alpha = 1,
  beta = 1,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_mtpi_+3A_parent_selector_factory">parent_selector_factory</code></td>
<td>
<p>Object of type <code><a href="#topic+selector_factory">selector_factory</a></code>.</p>
</td></tr>
<tr><td><code id="get_mtpi_+3A_num_doses">num_doses</code></td>
<td>
<p>Number of doses under investigation.</p>
</td></tr>
<tr><td><code id="get_mtpi_+3A_target">target</code></td>
<td>
<p>We seek a dose with this probability of toxicity.</p>
</td></tr>
<tr><td><code id="get_mtpi_+3A_epsilon1">epsilon1</code></td>
<td>
<p>This parameter determines the lower bound of the
equivalence interval. See Details.</p>
</td></tr>
<tr><td><code id="get_mtpi_+3A_epsilon2">epsilon2</code></td>
<td>
<p>This parameter determines the upper bound of the
equivalence interval. See Details.</p>
</td></tr>
<tr><td><code id="get_mtpi_+3A_exclusion_certainty">exclusion_certainty</code></td>
<td>
<p>Numeric, threshold posterior certainty required to
exclude a dose for being excessively toxic. The authors discuss values in the
range 0.7 - 0.95. Set to a value &gt; 1 to suppress the dose exclusion
mechanism. The authors use the Greek letter xi for this parameter.</p>
</td></tr>
<tr><td><code id="get_mtpi_+3A_alpha">alpha</code></td>
<td>
<p>First shape parameter of the beta prior distribution on the
probability of toxicity.</p>
</td></tr>
<tr><td><code id="get_mtpi_+3A_beta">beta</code></td>
<td>
<p>Second shape parameter of the beta prior distribution on the
probability of toxicity.</p>
</td></tr>
<tr><td><code id="get_mtpi_+3A_...">...</code></td>
<td>
<p>Extra args are passed onwards.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of type <code><a href="#topic+selector_factory">selector_factory</a></code> that can fit the
TPI model to outcomes.
</p>


<h3>Details</h3>

<p>The design seeks a dose with probability of toxicity <code class="reqn">p_{i}</code>
close to a target probability <code class="reqn">p_{T}</code> by iteratively calculating the
interval </p>
<p style="text-align: center;"><code class="reqn">p_{T} - \epsilon_{1} &lt; p_{i} &lt; p_{T} + \epsilon_{2}</code>
</p>

<p>In this model, <code class="reqn">\epsilon_{1}</code> and <code class="reqn">\epsilon_{2}</code> are specified
constants. <code class="reqn">p_{i}</code> is estimated by a Bayesian beta-binomial conjugate
model </p>
<p style="text-align: center;"><code class="reqn">p_{i} | data \sim Beta(\alpha + x_{1}, \beta + n_{i} - x_{i}),</code>
</p>

<p>where <code class="reqn">x_{i}</code> is the number of toxicities observed and <code class="reqn">n_{i}</code> is the
number of patients treated at dose <code class="reqn">i</code>, and <code class="reqn">\alpha</code> and <code class="reqn">\beta</code>
are hyperparameters for the beta prior on <code class="reqn">p_{i}</code>.
A dose is excluded as inadmissible if
</p>
<p style="text-align: center;"><code class="reqn">P(p_{i} &gt; p_{T} | data) &gt; \xi</code>
</p>

<p>The trial commences at a starting dose, possibly dose 1. If dose <code class="reqn">i</code>
has just been evaluated in patient(s), dose selection decisions proceed by
calculating the unit probability mass of the true toxicity rate at dose
<code class="reqn">i</code> using the partition of the probability space
<code class="reqn">p_{i} &lt; p_{T} - \epsilon_{1}</code>,
<code class="reqn">p_{T} - \epsilon_{1} &lt; p_{i} &lt; p_{T} + \epsilon_{2}</code>, and
<code class="reqn">p_{i} &gt; p_{T} + \epsilon_{2}</code>.
The unit probability mass (UPM) of an interval is the posterior probability
that the true toxicity rate belongs to the interval divided by the width of
the interval. The interval with maximal UPM determines the recommendation for
the next patient(s), with the intervals corresponding to decisions tp
escalate, stay, and de-escalate dose, respectively. Further to this are rules
that prevent escalation to an inadmissible dose.
In their paper, the authors demonstrate acceptable operating performance
using <code class="reqn">\alpha = \beta = 1</code>, <code class="reqn">K_{1} = 1</code>, <code class="reqn">K_{2} = 1.5</code> and
<code class="reqn">\xi = 0.95</code>.
See the publications for full details.
</p>


<h3>References</h3>

<p>Ji, Y., Liu, P., Li, Y., &amp; Bekele, B. N. (2010).
A modified toxicity probability interval method for dose-finding trials.
Clinical Trials, 7(6), 653-663. https://doi.org/10.1177/1740774510382799
</p>
<p>Ji, Y., &amp; Yang, S. (2017).
On the Interval-Based Dose-Finding Designs, 1-26.
Retrieved from https://arxiv.org/abs/1706.03277
</p>


<h3>Examples</h3>

<pre><code class='language-R'>target &lt;- 0.25
model1 &lt;- get_mtpi(num_doses = 5, target = target, epsilon1 = 0.05,
  epsilon2 = 0.05, exclusion_certainty = 0.95)

outcomes &lt;- '1NNN 2NTN'
model1 %&gt;% fit(outcomes) %&gt;% recommended_dose()

</code></pre>

<hr>
<h2 id='get_mtpi2'>Get an object to fit the mTPI-2 dose-finding model.</h2><span id='topic+get_mtpi2'></span>

<h3>Description</h3>

<p>The modified toxicity probability interval 2 (mTPI-2) is a dose-escalation
design by Guo et al. As the name suggests, it is an adaptation of the mTPI
design.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_mtpi2(
  parent_selector_factory = NULL,
  num_doses,
  target,
  epsilon1,
  epsilon2,
  exclusion_certainty,
  alpha = 1,
  beta = 1,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_mtpi2_+3A_parent_selector_factory">parent_selector_factory</code></td>
<td>
<p>Object of type <code><a href="#topic+selector_factory">selector_factory</a></code>.</p>
</td></tr>
<tr><td><code id="get_mtpi2_+3A_num_doses">num_doses</code></td>
<td>
<p>Number of doses under investigation.</p>
</td></tr>
<tr><td><code id="get_mtpi2_+3A_target">target</code></td>
<td>
<p>We seek a dose with this probability of toxicity.</p>
</td></tr>
<tr><td><code id="get_mtpi2_+3A_epsilon1">epsilon1</code></td>
<td>
<p>This parameter determines the lower bound of the
equivalence interval. See Details.</p>
</td></tr>
<tr><td><code id="get_mtpi2_+3A_epsilon2">epsilon2</code></td>
<td>
<p>This parameter determines the upper bound of the
equivalence interval. See Details.</p>
</td></tr>
<tr><td><code id="get_mtpi2_+3A_exclusion_certainty">exclusion_certainty</code></td>
<td>
<p>Numeric, threshold posterior certainty required to
exclude a dose for being excessively toxic. The authors discuss values in the
range 0.7 - 0.95. Set to a value &gt; 1 to suppress the dose exclusion
mechanism. The authors use the Greek letter xi for this parameter.</p>
</td></tr>
<tr><td><code id="get_mtpi2_+3A_alpha">alpha</code></td>
<td>
<p>First shape parameter of the beta prior distribution on the
probability of toxicity.</p>
</td></tr>
<tr><td><code id="get_mtpi2_+3A_beta">beta</code></td>
<td>
<p>Second shape parameter of the beta prior distribution on the
probability of toxicity.</p>
</td></tr>
<tr><td><code id="get_mtpi2_+3A_...">...</code></td>
<td>
<p>Extra args are passed onwards.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of type <code><a href="#topic+selector_factory">selector_factory</a></code> that can fit the
mTPI-2 model to outcomes.
</p>


<h3>Details</h3>

<p>The design seeks a dose with probability of toxicity <code class="reqn">p_{i}</code>
close to a target probability <code class="reqn">p_{T}</code> by iteratively calculating the
interval </p>
<p style="text-align: center;"><code class="reqn">p_{T} - \epsilon_{1} &lt; p_{i} &lt; p_{T} + \epsilon_{2}</code>
</p>

<p>In this model, <code class="reqn">\epsilon_{1}</code> and <code class="reqn">\epsilon_{2}</code> are specified
constants. <code class="reqn">p_{i}</code> is estimated by a Bayesian beta-binomial conjugate
model </p>
<p style="text-align: center;"><code class="reqn">p_{i} | data \sim Beta(\alpha + x_{1}, \beta + n_{i} - x_{i}),</code>
</p>

<p>where <code class="reqn">x_{i}</code> is the number of toxicities observed and <code class="reqn">n_{i}</code> is the
number of patients treated at dose <code class="reqn">i</code>, and <code class="reqn">\alpha</code> and <code class="reqn">\beta</code>
are hyperparameters for the beta prior on <code class="reqn">p_{i}</code>.
A dose is excluded as inadmissible if
</p>
<p style="text-align: center;"><code class="reqn">P(p_{i} &gt; p_{T} | data) &gt; \xi</code>
</p>

<p>The trial commences at a starting dose, possibly dose 1. If dose <code class="reqn">i</code>
has just been evaluated in patient(s), dose selection decisions proceed by
calculating the unit probability mass of the true toxicity rate at dose
<code class="reqn">i</code> using the partition of the probability space into subintervals with
equal length given by<code class="reqn">(\epsilon_{1} + \epsilon_{2})</code>. <code class="reqn">EI</code> is the
equivalence interval <code class="reqn">p_{T} - epsilon_{1}, p_{T} - epsilon_{2}</code>, with
<code class="reqn">LI</code> the set of all intervals below, and <code class="reqn">HI</code> the set of all
intervals above.
The unit probability mass (UPM) of an interval is the posterior probability
that the true toxicity rate belongs to the interval divided by the width of
the interval. The interval with maximal UPM determines the recommendation for
the next patient(s), with the intervals corresponding to decisions to
escalate, stay, and de-escalate dose, respectively. Further to this are rules
that prevent escalation to an inadmissible dose.
In the original mTPI paper, the authors demonstrate acceptable operating
performance using <code class="reqn">\alpha = \beta = 1</code>, <code class="reqn">K_{1} = 1</code>,
<code class="reqn">K_{2} = 1.5</code> and  <code class="reqn">\xi = 0.95</code>.
The authors of the mTPI-2 approach show desirable performance as compared
to the original mTPI method, under particular parameter choices.
See the publications for full details.
</p>


<h3>References</h3>

<p>Ji, Y., Liu, P., Li, Y., &amp; Bekele, B. N. (2010).
A modified toxicity probability interval method for dose-finding trials.
Clinical Trials, 7(6), 653663. https://doi.org/10.1177/1740774510382799
</p>
<p>Ji, Y., &amp; Yang, S. (2017).
On the Interval-Based Dose-Finding Designs, 126.
Retrieved from https://arxiv.org/abs/1706.03277
</p>
<p>Guo, W., Wang, SJ., Yang, S., Lynn, H., Ji, Y. (2017).
A Bayesian Interval Dose-Finding Design Addressing Ockham's Razor: mTPI-2.
https://doi.org/10.1016/j.cct.2017.04.006
</p>


<h3>Examples</h3>

<pre><code class='language-R'>target &lt;- 0.25
model1 &lt;- get_mtpi2(num_doses = 5, target = target, epsilon1 = 0.05,
  epsilon2 = 0.05, exclusion_certainty = 0.95)

outcomes &lt;- '1NNN 2NTN'
model1 %&gt;% fit(outcomes) %&gt;% recommended_dose()

</code></pre>

<hr>
<h2 id='get_potential_outcomes'>Get potential outcomes from a list of PatientSamples</h2><span id='topic+get_potential_outcomes'></span>

<h3>Description</h3>

<p>An instance of <code><a href="#topic+PatientSample">PatientSample</a></code>, or one of its subclasses like
<code><a href="#topic+CorrelatedPatientSample">CorrelatedPatientSample</a></code>, reflects one particular state of the
world, where patient i would reliably experience a toxicity or efficacy
event if treated at a particular dose. This function, given true toxicity and
efficacy probabilities at doses 1, ..., num_doses, calculates 0/1 matrices to
reflect whether the patients in those samples would have experienced toxicity
and efficacy at the doses, had they been dosed as such. Using the
vernacular of causal inference, these are _potential outcomes_. At any single
instant, a patient can only be dosed at one dose, so only one of the
outcomes for a patient would in reality have been observed; the rest are
counterfactual.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_potential_outcomes(patient_samples, true_prob_tox, true_prob_eff)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_potential_outcomes_+3A_patient_samples">patient_samples</code></td>
<td>
<p>list of <code><a href="#topic+PatientSample">PatientSample</a></code> objects, or
subclass thereof.</p>
</td></tr>
<tr><td><code id="get_potential_outcomes_+3A_true_prob_tox">true_prob_tox</code></td>
<td>
<p>vector of probabilities of toxicity outcomes at doses</p>
</td></tr>
<tr><td><code id="get_potential_outcomes_+3A_true_prob_eff">true_prob_eff</code></td>
<td>
<p>vector of probabilities of efficacy outcomes at doses</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of lists, with names tox and eff, each mapping to a matrix of
the potential outcomes.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>num_sims &lt;- 10
ps &lt;- lapply(1:num_sims, function(x) PatientSample$new())
# Set tox_u and eff_u for each simulation
set.seed(2024)
lapply(1:num_sims, function(x) {
  tox_u_new &lt;- runif(n = 20)
  eff_u_new &lt;- runif(n = 20)
  ps[[x]]$set_eff_and_tox(tox_u = tox_u_new, eff_u = eff_u_new)
})
true_prob_tox &lt;- c(0.05, 0.10, 0.15, 0.18, 0.45)
true_prob_eff &lt;- c(0.40, 0.50, 0.52, 0.53, 0.53)
get_potential_outcomes(
  patient_samples = ps,
  true_prob_tox = true_prob_tox,
  true_prob_eff = true_prob_eff
)
</code></pre>

<hr>
<h2 id='get_random_selector'>Get an object to fit a dose-selector that randomly selects doses.</h2><span id='topic+get_random_selector'></span>

<h3>Description</h3>

<p>Get an object to fit a dose-selector that randomly selects doses. Whilst this
design is unlikely to pass the ethical hurdles when investigating truly
experimental treatments, this class is useful for illustrating methods and
can be useful for benchmarking.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_random_selector(
  parent_selector_factory = NULL,
  prob_select,
  supports_efficacy = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_random_selector_+3A_parent_selector_factory">parent_selector_factory</code></td>
<td>
<p>optional object of type
<code><a href="#topic+selector_factory">selector_factory</a></code> that is in charge of dose selection before
this class gets involved. Leave as NULL to just select random doses from the
start.</p>
</td></tr>
<tr><td><code id="get_random_selector_+3A_prob_select">prob_select</code></td>
<td>
<p>vector of probabilities, the probability of selecting
dose 1...n</p>
</td></tr>
<tr><td><code id="get_random_selector_+3A_supports_efficacy">supports_efficacy</code></td>
<td>
<p>TRUE to monitor toxicity and efficacy outcomes;
FALSE (by default) to just monitor toxicity outcomes.</p>
</td></tr>
<tr><td><code id="get_random_selector_+3A_...">...</code></td>
<td>
<p>Extra args are ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of type <code><a href="#topic+selector_factory">selector_factory</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>prob_select = c(0.1, 0.3, 0.5, 0.07, 0.03)
model &lt;- get_random_selector(prob_select = prob_select)
fit &lt;- model %&gt;% fit('1NTN')
fit %&gt;% recommended_dose() # This is random
# We could also precede this selector with a set path:
model &lt;- follow_path('1NN 2NN 3NN') %&gt;%
  get_random_selector(prob_select = prob_select)
fit &lt;- model %&gt;% fit('1NN')
fit %&gt;% recommended_dose() # This is not-random; it comes from the path.
fit &lt;- model %&gt;% fit('1NN 2NT')
fit %&gt;% recommended_dose() # This is random; the path is discarded.
</code></pre>

<hr>
<h2 id='get_three_plus_three'>Get an object to fit the 3+3 model.</h2><span id='topic+get_three_plus_three'></span>

<h3>Description</h3>

<p>Get an object to fit the 3+3 model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_three_plus_three(num_doses, allow_deescalate = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_three_plus_three_+3A_num_doses">num_doses</code></td>
<td>
<p>Number of doses under investigation.</p>
</td></tr>
<tr><td><code id="get_three_plus_three_+3A_allow_deescalate">allow_deescalate</code></td>
<td>
<p>TRUE to allow de-escalation, as described by Korn et
al. Default is FALSE.</p>
</td></tr>
<tr><td><code id="get_three_plus_three_+3A_...">...</code></td>
<td>
<p>Extra args are not currently used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of type <code><a href="#topic+selector_factory">selector_factory</a></code> that can fit the
3+3 model to outcomes.
</p>


<h3>References</h3>

<p>Storer BE. Design and Analysis of Phase I Clinical Trials. Biometrics.
1989;45(3):925-937. doi:10.2307/2531693
</p>
<p>Korn EL, Midthune D, Chen TT, Rubinstein LV, Christian MC, Simon RM.
A comparison of two phase I trial designs. Statistics in Medicine.
1994;13(18):1799-1806. doi:10.1002/sim.4780131802
</p>


<h3>Examples</h3>

<pre><code class='language-R'>model &lt;- get_three_plus_three(num_doses = 5)

fit1 &lt;- model %&gt;% fit('1NNN 2NTN')
fit1 %&gt;% recommended_dose()
fit1 %&gt;% continue()

fit2 &lt;- model %&gt;% fit('1NNN 2NTN 2NNT')
fit2 %&gt;% recommended_dose()
fit2 %&gt;% continue()

</code></pre>

<hr>
<h2 id='get_tpi'>Get an object to fit the TPI dose-finding model.</h2><span id='topic+get_tpi'></span>

<h3>Description</h3>

<p>The toxicity probability interval (TPI)is a dose-escalation design
by Ji et al.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_tpi(
  num_doses,
  target,
  k1,
  k2,
  exclusion_certainty,
  alpha = 0.005,
  beta = 0.005,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_tpi_+3A_num_doses">num_doses</code></td>
<td>
<p>Number of doses under investigation.</p>
</td></tr>
<tr><td><code id="get_tpi_+3A_target">target</code></td>
<td>
<p>We seek a dose with this probability of toxicity.</p>
</td></tr>
<tr><td><code id="get_tpi_+3A_k1">k1</code></td>
<td>
<p>The K1 parameter in TPI determines the upper bound of the
equivalence interval. See Details.</p>
</td></tr>
<tr><td><code id="get_tpi_+3A_k2">k2</code></td>
<td>
<p>The K2 parameter in TPI determines the lower bound of the
equivalence interval. See Details.</p>
</td></tr>
<tr><td><code id="get_tpi_+3A_exclusion_certainty">exclusion_certainty</code></td>
<td>
<p>Numeric, threshold posterior certainty required to
exclude a dose for being excessively toxic. The authors discuss values in the
range 0.7 - 0.95. Set to a value &gt; 1 to suppress the dose exclusion
mechanism. The authors use the Greek letter xi for this parameter.</p>
</td></tr>
<tr><td><code id="get_tpi_+3A_alpha">alpha</code></td>
<td>
<p>First shape parameter of the beta prior distribution on the
probability of toxicity.</p>
</td></tr>
<tr><td><code id="get_tpi_+3A_beta">beta</code></td>
<td>
<p>Second shape parameter of the beta prior distribution on the
probability of toxicity.</p>
</td></tr>
<tr><td><code id="get_tpi_+3A_...">...</code></td>
<td>
<p>Extra args are passed onwards.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of type <code><a href="#topic+selector_factory">selector_factory</a></code> that can fit the
TPI model to outcomes.
</p>


<h3>Details</h3>

<p>The design seeks a dose with probability of toxicity <code class="reqn">p_{i}</code>
close to a target probability <code class="reqn">p_{T}</code> by iteratively calculating the
interval </p>
<p style="text-align: center;"><code class="reqn">p_{T} - K_{2} \sigma_{i} &lt; p_{i} &lt; p_{T} + K_{1} \sigma_{i}</code>
</p>

<p>In this model, <code class="reqn">K_{1}</code> and <code class="reqn">K_{2}</code> are specified constants and
<code class="reqn">\sigma_{i}</code> is the standard deviation of <code class="reqn">p_{i}</code> arising from a
Bayesian beta-binomial conjugate model
</p>
<p style="text-align: center;"><code class="reqn">p_{i} | data \sim Beta(\alpha + x_{i}, \beta + n_{i} - x_{i}),</code>
</p>

<p>where <code class="reqn">x_{i}</code> is the number of toxicities observed and <code class="reqn">n_{i}</code> is the
number of patients treated at dose <code class="reqn">i</code>, and <code class="reqn">\alpha</code> and <code class="reqn">\beta</code>
are hyperparameters for the beta prior on <code class="reqn">p_{i}</code>.
A dose is excluded as inadmissible if
</p>
<p style="text-align: center;"><code class="reqn">P(p_{i} &gt; p_{T} | data) &gt; \xi</code>
</p>

<p>The trial commences at a starting dose, possibly dose 1. If dose <code class="reqn">i</code>
has just been evaluated in patient(s), dose selection decisions proceed by
calculating the posterior probability that the true toxicity rate at dose
<code class="reqn">i</code> belongs to the three partition regions
<code class="reqn">p_{i} &lt; p_{T} - K_{2} \sigma_{i}</code>,
<code class="reqn">p_{T} - K_{2} \sigma_{i} &lt; p_{i} &lt; p_{T} + K_{1} \sigma_{i}</code>, and
<code class="reqn">p_{i} &gt; p_{T} + K_{2} \sigma_{i}</code>, corresponding to decisions escalate,
stay, and de-escalate dose, respectively. Further to this are rules that
prevent escalation to an inadmissible dose.
In their paper, the authors demonstrate acceptable operating performance
using <code class="reqn">\alpha = \beta = 0.005</code>, <code class="reqn">K_{1} = 1</code>, <code class="reqn">K_{2} = 1.5</code> and
<code class="reqn">\xi = 0.95</code>.
See the publications for full details.
</p>


<h3>References</h3>

<p>Ji, Y., Li, Y., &amp; Bekele, B. N. (2007).
Dose-finding in phase I clinical trials based on toxicity probability
intervals.
Clinical Trials, 4(3), 235244. https://doi.org/10.1177/1740774507079442
</p>
<p>Ji, Y., &amp; Yang, S. (2017).
On the Interval-Based Dose-Finding Designs, 126.
Retrieved from https://arxiv.org/abs/1706.03277
</p>


<h3>Examples</h3>

<pre><code class='language-R'>target &lt;- 0.25
model1 &lt;- get_tpi(num_doses = 5, target = target, k1 = 1, k2 = 1.5,
  exclusion_certainty = 0.95)

outcomes &lt;- '1NNN 2NTN'
model1 %&gt;% fit(outcomes) %&gt;% recommended_dose()

</code></pre>

<hr>
<h2 id='get_trialr_crm'>Get an object to fit the CRM model using the trialr package.</h2><span id='topic+get_trialr_crm'></span>

<h3>Description</h3>

<p>This function returns an object that can be used to fit a CRM model using
methods provided by the trialr package.
</p>
<p>Dose selectors are designed to be daisy-chained together to achieve different
behaviours. This class is a **resumptive** selector, meaning it carries on
when the previous dose selector, where present, has elected not to continue.
For example, this allows instances of this class to be preceded by a selector
that follows a fixed path in an initial escalation plan, such as that
provided by <code><a href="#topic+follow_path">follow_path</a></code>. In this example, when the observed
trial outcomes deviate from that initial plan, the selector following the
fixed path elects not to continue and responsibility passes to this class.
See Examples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_trialr_crm(parent_selector_factory = NULL, skeleton, target, model, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_trialr_crm_+3A_parent_selector_factory">parent_selector_factory</code></td>
<td>
<p>optional object of type
<code><a href="#topic+selector_factory">selector_factory</a></code> that is in charge of dose selection before
this class gets involved. Leave as NULL to just use CRM from the start.</p>
</td></tr>
<tr><td><code id="get_trialr_crm_+3A_skeleton">skeleton</code></td>
<td>
<p>Dose-toxicity skeleton, a non-decreasing vector of
probabilities.</p>
</td></tr>
<tr><td><code id="get_trialr_crm_+3A_target">target</code></td>
<td>
<p>We seek a dose with this probability of toxicity.</p>
</td></tr>
<tr><td><code id="get_trialr_crm_+3A_model">model</code></td>
<td>
<p>character string identifying which model form to use. Options
include empiric, logistic, logistic2. The model form chosen determines which
prior hyperparameters are required. See <code><a href="trialr.html#topic+stan_crm">stan_crm</a></code>
for more details.</p>
</td></tr>
<tr><td><code id="get_trialr_crm_+3A_...">...</code></td>
<td>
<p>Extra args are passed to <code><a href="trialr.html#topic+stan_crm">stan_crm</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of type <code><a href="#topic+selector_factory">selector_factory</a></code> that can fit the
CRM model to outcomes.
</p>


<h3>References</h3>

<p>Kristian Brock (2020). trialr: Clinical Trial Designs in 'rstan'.
R package version 0.1.5. https://github.com/brockk/trialr
</p>
<p>Kristian Brock (2019). trialr: Bayesian Clinical Trial Designs in R and Stan.
arXiv preprint arXiv:1907.00161.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>skeleton &lt;- c(0.05, 0.1, 0.25, 0.4, 0.6)
target &lt;- 0.25
# The model to use must be specified in trialr:
model1 &lt;- get_trialr_crm(skeleton = skeleton, target = target,
                         model = 'empiric', beta_sd = 1.34)
# Refer to the trialr documentation for more details on model forms.
outcomes &lt;- '1NNN 2NTN'
model1 %&gt;% fit(outcomes) %&gt;% recommended_dose()

# But we can provide extra args to trialr that are than passed onwards to
# the call to trialr::stan_crm to override the defaults.
# For example, if we want the one-parameter logistic model, we run:
model2 &lt;- get_trialr_crm(skeleton = skeleton, target = target,
                         model = 'logistic', a0 = 3,
                         beta_mean = 0, beta_sd = 1)
model2 %&gt;% fit(outcomes) %&gt;% recommended_dose()
# And, if we want the two-parameter logistic model, we run:
model3 &lt;- get_trialr_crm(skeleton = skeleton, target = target,
                         model = 'logistic2',
                         alpha_mean = 0, alpha_sd = 2,
                         beta_mean = 0, beta_sd = 1)
model3 %&gt;% fit(outcomes) %&gt;% recommended_dose()

# We can use an initial dose-escalation plan, a pre-specified path that
# should be followed until trial outcomes deviate, at which point the CRM
# model takes over. For instance, if we want to use two patients at each of
# the first three doses in the absence of toxicity, irrespective the model's
# advice, we would run:
model1 &lt;- follow_path('1NN 2NN 3NN') %&gt;%
  get_trialr_crm(skeleton = skeleton, target = target, model = 'empiric',
                 beta_sd = 1.34)

# If outcomes match the desired path, the path is followed further:
model1 %&gt;% fit('1NN 2N') %&gt;% recommended_dose()

# But when the outcomes diverge:
model1 %&gt;% fit('1NN 2T') %&gt;% recommended_dose()

# Or the pre-specified path comes to an end:
model1 %&gt;% fit('1NN 2NN 3NN') %&gt;% recommended_dose()
# ...the CRM model takes over.

</code></pre>

<hr>
<h2 id='get_trialr_efftox'>Get an object to fit the EffTox model using the trialr package.</h2><span id='topic+get_trialr_efftox'></span>

<h3>Description</h3>

<p>This function returns an object that can be used to fit the EffTox model for
phase I/II dose-finding using methods provided by the trialr package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_trialr_efftox(
  parent_selector_factory = NULL,
  real_doses,
  efficacy_hurdle,
  toxicity_hurdle,
  p_e,
  p_t,
  eff0,
  tox1,
  eff_star,
  tox_star,
  priors,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_trialr_efftox_+3A_parent_selector_factory">parent_selector_factory</code></td>
<td>
<p>optional object of type
<code><a href="#topic+selector_factory">selector_factory</a></code> that is in charge of dose selection before
this class gets involved. Leave as NULL to just use EffTox from the start.</p>
</td></tr>
<tr><td><code id="get_trialr_efftox_+3A_real_doses">real_doses</code></td>
<td>
<p>A vector of numbers, the doses under investigation. They
should be ordered from lowest to highest and be in consistent units.
E.g. to conduct a dose-finding trial of doses 10mg, 20mg and 50mg, use
c(10, 20, 50).</p>
</td></tr>
<tr><td><code id="get_trialr_efftox_+3A_efficacy_hurdle">efficacy_hurdle</code></td>
<td>
<p>Minimum acceptable efficacy probability.
A number between 0 and 1.</p>
</td></tr>
<tr><td><code id="get_trialr_efftox_+3A_toxicity_hurdle">toxicity_hurdle</code></td>
<td>
<p>Maximum acceptable toxicity probability.
A number between 0 and 1.</p>
</td></tr>
<tr><td><code id="get_trialr_efftox_+3A_p_e">p_e</code></td>
<td>
<p>Certainty required to infer a dose is acceptable with regards to
being probably efficacious; a number between 0 and 1.</p>
</td></tr>
<tr><td><code id="get_trialr_efftox_+3A_p_t">p_t</code></td>
<td>
<p>Certainty required to infer a dose is acceptable with regards to
being probably tolerable; a number between 0 and 1.</p>
</td></tr>
<tr><td><code id="get_trialr_efftox_+3A_eff0">eff0</code></td>
<td>
<p>Efficacy probability required when toxicity is impossible;
a number between 0 and 1 (see Details).</p>
</td></tr>
<tr><td><code id="get_trialr_efftox_+3A_tox1">tox1</code></td>
<td>
<p>Toxicity probability permitted when efficacy is guaranteed;
a number between 0 and 1 (see Details).</p>
</td></tr>
<tr><td><code id="get_trialr_efftox_+3A_eff_star">eff_star</code></td>
<td>
<p>Efficacy probability of an equi-utility third point (see
Details).</p>
</td></tr>
<tr><td><code id="get_trialr_efftox_+3A_tox_star">tox_star</code></td>
<td>
<p>Toxicity probability of an equi-utility third point (see
Details).</p>
</td></tr>
<tr><td><code id="get_trialr_efftox_+3A_priors">priors</code></td>
<td>
<p>instance of class <code>trialr{efftox_priors}</code>, the
hyperparameters for normal priors on the six model parameters.</p>
</td></tr>
<tr><td><code id="get_trialr_efftox_+3A_...">...</code></td>
<td>
<p>Extra args are passed to <code><a href="trialr.html#topic+stan_efftox">stan_efftox</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of type <code><a href="#topic+selector_factory">selector_factory</a></code> that can fit the
EffTox model to outcomes.
</p>


<h3>References</h3>

<p>Thall, P., &amp; Cook, J. (2004). Dose-Finding Based on Efficacy-Toxicity
Trade-Offs. Biometrics, 60(3), 684-693.
https://doi.org/10.1111/j.0006-341X.2004.00218.x
</p>
<p>Thall, P., Herrick, R., Nguyen, H., Venier, J., &amp; Norris, J. (2014).
Effective sample size for computing prior hyperparameters in Bayesian
phase I-II dose-finding. Clinical Trials, 11(6), 657-666.
https://doi.org/10.1177/1740774514547397
</p>
<p>Brock, K. (2020). trialr: Clinical Trial Designs in 'rstan'.
R package version 0.1.5. https://github.com/brockk/trialr
</p>
<p>Brock, K. (2019). trialr: Bayesian Clinical Trial Designs in R and Stan.
arXiv preprint arXiv:1907.00161.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>efftox_priors &lt;- trialr::efftox_priors
p &lt;- efftox_priors(alpha_mean = -7.9593, alpha_sd = 3.5487,
                   beta_mean = 1.5482, beta_sd = 3.5018,
                   gamma_mean = 0.7367, gamma_sd = 2.5423,
                   zeta_mean = 3.4181, zeta_sd = 2.4406,
                   eta_mean = 0, eta_sd = 0.2,
                   psi_mean = 0, psi_sd = 1)
real_doses = c(1.0, 2.0, 4.0, 6.6, 10.0)
model &lt;- get_trialr_efftox(real_doses = real_doses,
                           efficacy_hurdle = 0.5, toxicity_hurdle = 0.3,
                           p_e = 0.1, p_t = 0.1,
                           eff0 = 0.5, tox1 = 0.65,
                           eff_star = 0.7, tox_star = 0.25,
                           priors = p, iter = 1000, chains = 1, seed = 2020)

</code></pre>

<hr>
<h2 id='get_trialr_nbg'>Get an object to fit the NBG dose-finding model using the trialr package.</h2><span id='topic+get_trialr_nbg'></span>

<h3>Description</h3>

<p>This function returns an object that can be used to fit a Neuenschwander,
Branson and Gsponer (NBG) model for dose-finding using methods provided by
the trialr package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_trialr_nbg(
  parent_selector_factory = NULL,
  real_doses,
  d_star,
  target,
  alpha_mean,
  alpha_sd,
  beta_mean,
  beta_sd,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_trialr_nbg_+3A_parent_selector_factory">parent_selector_factory</code></td>
<td>
<p>optional object of type
<code><a href="#topic+selector_factory">selector_factory</a></code> that is in charge of dose selection before
this class gets involved. Leave as NULL to just use this model from the start.</p>
</td></tr>
<tr><td><code id="get_trialr_nbg_+3A_real_doses">real_doses</code></td>
<td>
<p>Doses under investigation, a non-decreasing vector of
numbers.</p>
</td></tr>
<tr><td><code id="get_trialr_nbg_+3A_d_star">d_star</code></td>
<td>
<p>Numeric, reference dose for calculating the covariate
<code>log(dose / d_star)</code> when fitting the model. Sometimes (but not always)
taken to be the max dose in real_doses.</p>
</td></tr>
<tr><td><code id="get_trialr_nbg_+3A_target">target</code></td>
<td>
<p>We seek a dose with this probability of toxicity.</p>
</td></tr>
<tr><td><code id="get_trialr_nbg_+3A_alpha_mean">alpha_mean</code></td>
<td>
<p>Prior mean of intercept variable for normal prior.
See Details. Also see documentation for trialr package for further details.</p>
</td></tr>
<tr><td><code id="get_trialr_nbg_+3A_alpha_sd">alpha_sd</code></td>
<td>
<p>Prior standard deviation of intercept variable for normal prior.
See Details. Also see documentation for trialr package for further details.</p>
</td></tr>
<tr><td><code id="get_trialr_nbg_+3A_beta_mean">beta_mean</code></td>
<td>
<p>Prior mean of gradient variable for normal prior.
See Details. Also see documentation for trialr package for further details.</p>
</td></tr>
<tr><td><code id="get_trialr_nbg_+3A_beta_sd">beta_sd</code></td>
<td>
<p>Prior standard deviation of slope variable for normal prior.
See Details. Also see documentation for trialr package for further details.</p>
</td></tr>
<tr><td><code id="get_trialr_nbg_+3A_...">...</code></td>
<td>
<p>Extra args are passed to <code><a href="trialr.html#topic+stan_nbg">stan_nbg</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The model form implemented in trialr is:
</p>
<p><code class="reqn">F(x_{i}, \alpha, \beta) = 1 / (1 + \exp{-(\alpha + \exp{(\beta)} log(x_i / d_*))}) </code>
</p>
<p>with normal priors on alpha and beta.
</p>
<p>Dose selectors are designed to be daisy-chained together to achieve different
behaviours. This class is a **resumptive** selector, meaning it carries on
when the previous dose selector, where present, has elected not to continue.
For example, this allows instances of this class to be preceded by a selector
that follows a fixed path in an initial escalation plan, such as that
provided by <code><a href="#topic+follow_path">follow_path</a></code>. In this example, when the observed
trial outcomes deviate from that initial plan, the selector following the
fixed path elects not to continue and responsibility passes to this class.
See examples under <code><a href="#topic+get_dfcrm">get_dfcrm</a></code>.
</p>


<h3>Value</h3>

<p>an object of type <code><a href="#topic+selector_factory">selector_factory</a></code> that can fit the
NBG model to outcomes.
</p>


<h3>References</h3>

<p>Neuenschwander, B., Branson, M., &amp; Gsponer, T. (2008).
Critical aspects of the Bayesian approach to phase I cancer trials.
Statistics in Medicine, 27, 24202439. https://doi.org/10.1002/sim.3230
</p>
<p>Brock, K. (2020). trialr: Clinical Trial Designs in 'rstan'.
R package version 0.1.5. https://github.com/brockk/trialr
</p>
<p>Brock, K. (2019). trialr: Bayesian Clinical Trial Designs in R and Stan.
arXiv preprint arXiv:1907.00161.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>real_doses &lt;- c(5, 10, 25, 40, 60)
d_star &lt;- 60
target &lt;- 0.25

model &lt;- get_trialr_nbg(real_doses = real_doses, d_star = d_star,
                        target = target,
                        alpha_mean = 2, alpha_sd = 1,
                        beta_mean = 0.5, beta_sd = 1)
# Refer to the trialr documentation for more details on model &amp; priors.
outcomes &lt;- '1NNN 2NTN'
fit &lt;- model %&gt;% fit(outcomes)
fit %&gt;% recommended_dose()
fit %&gt;% mean_prob_tox()

</code></pre>

<hr>
<h2 id='get_wages_and_tait'>Get an object to fit Wages &amp; Tait's model for phase I/II dose-finding.</h2><span id='topic+get_wages_and_tait'></span>

<h3>Description</h3>

<p>This function returns an object that can be used to fit Wages &amp; Taits model
for phase I/II dose-finding, i.e. it selects doses according to efficacy and
toxicity outcomes. This function delegates prior-to-posterior calculations to
the dfcrm package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_wages_and_tait(
  parent_selector_factory = NULL,
  tox_skeleton,
  eff_skeletons,
  eff_skeleton_weights = rep(1, nrow(eff_skeletons)),
  tox_limit,
  eff_limit,
  num_randomise,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_wages_and_tait_+3A_parent_selector_factory">parent_selector_factory</code></td>
<td>
<p>optional object of type
<code><a href="#topic+selector_factory">selector_factory</a></code> that is in charge of dose selection before
this class gets involved. Leave NULL to just use this model from the start.</p>
</td></tr>
<tr><td><code id="get_wages_and_tait_+3A_tox_skeleton">tox_skeleton</code></td>
<td>
<p>Dose-toxicity skeleton, a non-decreasing vector of
probabilities.</p>
</td></tr>
<tr><td><code id="get_wages_and_tait_+3A_eff_skeletons">eff_skeletons</code></td>
<td>
<p>Matrix of dose-efficacy skeletons, with the skeletons in
rows. I.e. number of cols is equal to number of doses, and number of rows is
equal to number of efficacy skeletons under consideration.</p>
</td></tr>
<tr><td><code id="get_wages_and_tait_+3A_eff_skeleton_weights">eff_skeleton_weights</code></td>
<td>
<p>numerical vector, prior weights to efficacy
skeletons. Should have length equal to number of rows in
<code>eff_skeletons</code>. Default is equal weights.</p>
</td></tr>
<tr><td><code id="get_wages_and_tait_+3A_tox_limit">tox_limit</code></td>
<td>
<p>We seek a dose with probability of toxicity no greater than
this. Value determines the admissible set. See Wages &amp; Tait (2015).</p>
</td></tr>
<tr><td><code id="get_wages_and_tait_+3A_eff_limit">eff_limit</code></td>
<td>
<p>We seek a dose with probability of efficacy no less than
this.</p>
</td></tr>
<tr><td><code id="get_wages_and_tait_+3A_num_randomise">num_randomise</code></td>
<td>
<p>integer, maximum number of patients to use in the
adaptive randomisation phase of the trial.</p>
</td></tr>
<tr><td><code id="get_wages_and_tait_+3A_...">...</code></td>
<td>
<p>Extra args are passed onwards.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of type <code><a href="#topic+selector_factory">selector_factory</a></code>.
</p>


<h3>References</h3>

<p>Wages, N. A., &amp; Tait, C. (2015).
Seamless Phase I/II Adaptive Design for Oncology Trials of Molecularly
Targeted Agents.
Journal of Biopharmaceutical Statistics, 25(5), 903920.
https://doi.org/10.1080/10543406.2014.920873
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example in Wages &amp; Tait (2015)
tox_skeleton = c(0.01, 0.08, 0.15, 0.22, 0.29, 0.36)
eff_skeletons = matrix(nrow=11, ncol=6)
eff_skeletons[1,] &lt;- c(0.60, 0.50, 0.40, 0.30, 0.20, 0.10)
eff_skeletons[2,] &lt;- c(0.50, 0.60, 0.50, 0.40, 0.30, 0.20)
eff_skeletons[3,] &lt;- c(0.40, 0.50, 0.60, 0.50, 0.40, 0.30)
eff_skeletons[4,] &lt;- c(0.30, 0.40, 0.50, 0.60, 0.50, 0.40)
eff_skeletons[5,] &lt;- c(0.20, 0.30, 0.40, 0.50, 0.60, 0.50)
eff_skeletons[6,] &lt;- c(0.10, 0.20, 0.30, 0.40, 0.50, 0.60)
eff_skeletons[7,] &lt;- c(0.20, 0.30, 0.40, 0.50, 0.60, 0.60)
eff_skeletons[8,] &lt;- c(0.30, 0.40, 0.50, 0.60, 0.60, 0.60)
eff_skeletons[9,] &lt;- c(0.40, 0.50, 0.60, 0.60, 0.60, 0.60)
eff_skeletons[10,] &lt;- c(0.50, 0.60, 0.60, 0.60, 0.60, 0.60)
eff_skeletons[11,] &lt;- c(rep(0.60, 6))
eff_skeleton_weights = rep(1, nrow(eff_skeletons))
tox_limit = 0.33
eff_limit = 0.05
model &lt;- get_wages_and_tait(tox_skeleton = tox_skeleton,
                            eff_skeletons = eff_skeletons,
                            tox_limit = tox_limit, eff_limit = eff_limit,
                            num_randomise = 20)
fit &lt;- model %&gt;% fit('1NN 2EN 3BE')
fit %&gt;% recommended_dose()
fit %&gt;% is_randomising()
fit %&gt;% dose_admissible()
fit %&gt;% prob_administer()

</code></pre>

<hr>
<h2 id='graph_paths'>Visualise dose-paths as a graph</h2><span id='topic+graph_paths'></span>

<h3>Description</h3>

<p>Visualise dose-paths as a graph
</p>


<h3>Usage</h3>

<pre><code class='language-R'>graph_paths(paths, viridis_palette = "viridis", RColorBrewer_palette = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="graph_paths_+3A_paths">paths</code></td>
<td>
<p>Object of type <code><a href="#topic+dose_paths">dose_paths</a></code></p>
</td></tr>
<tr><td><code id="graph_paths_+3A_viridis_palette">viridis_palette</code></td>
<td>
<p>optional name of a colour palette in the
viridis package.</p>
</td></tr>
<tr><td><code id="graph_paths_+3A_rcolorbrewer_palette">RColorBrewer_palette</code></td>
<td>
<p>optional name of a colour palette in the
RColorBrewer package.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The viridis package supports palettes: viridis, magma, plasma, inferno, and
cividis. The RColorBrewer package supports many palettes. Refer to those
packages on CRAN for more details.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>paths &lt;- get_three_plus_three(num_doses = 5) %&gt;%
  get_dose_paths(cohort_sizes = c(3, 3, 3))
## Not run: 
graph_paths(paths)
graph_paths(paths, viridis_palette = 'plasma')
graph_paths(paths, RColorBrewer_palette = 'YlOrRd')

## End(Not run)
</code></pre>

<hr>
<h2 id='is_randomising'>Is this selector currently randomly allocating doses?</h2><span id='topic+is_randomising'></span>

<h3>Description</h3>

<p>Get the percentage of patients evaluated at each dose under investigation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_randomising(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_randomising_+3A_x">x</code></td>
<td>
<p>Object of class <code><a href="#topic+selector">selector</a></code></p>
</td></tr>
<tr><td><code id="is_randomising_+3A_...">...</code></td>
<td>
<p>arguments passed to other methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a logical value
</p>


<h3>Examples</h3>

<pre><code class='language-R'>outcomes &lt;- '1NNN 2NTN'
fit &lt;- get_random_selector(prob_select = c(0.1, 0.6, 0.3)) %&gt;%
  fit(outcomes)
fit %&gt;% is_randomising()
</code></pre>

<hr>
<h2 id='mean_prob_eff'>Mean efficacy rate at each dose.</h2><span id='topic+mean_prob_eff'></span>

<h3>Description</h3>

<p>Get the estimated mean efficacy rate at each dose under investigation. This
is a set of modelled statistics. The underlying models estimate efficacy
probabilities in different ways. If no model-based estimate of the mean is
available, this function will return a vector of NAs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mean_prob_eff(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mean_prob_eff_+3A_x">x</code></td>
<td>
<p>Object of class <code><a href="#topic+selector">selector</a></code></p>
</td></tr>
<tr><td><code id="mean_prob_eff_+3A_...">...</code></td>
<td>
<p>arguments passed to other methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a numerical vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'>efftox_priors &lt;- trialr::efftox_priors
p &lt;- efftox_priors(alpha_mean = -7.9593, alpha_sd = 3.5487,
                   beta_mean = 1.5482, beta_sd = 3.5018,
                   gamma_mean = 0.7367, gamma_sd = 2.5423,
                   zeta_mean = 3.4181, zeta_sd = 2.4406,
                   eta_mean = 0, eta_sd = 0.2,
                   psi_mean = 0, psi_sd = 1)
real_doses = c(1.0, 2.0, 4.0, 6.6, 10.0)
model &lt;- get_trialr_efftox(real_doses = real_doses,
                           efficacy_hurdle = 0.5, toxicity_hurdle = 0.3,
                           p_e = 0.1, p_t = 0.1,
                           eff0 = 0.5, tox1 = 0.65,
                           eff_star = 0.7, tox_star = 0.25,
                           priors = p, iter = 1000, chains = 1, seed = 2020)
x &lt;- model %&gt;% fit('1N 2E 3B')
mean_prob_eff(x)
</code></pre>

<hr>
<h2 id='mean_prob_tox'>Mean toxicity rate at each dose.</h2><span id='topic+mean_prob_tox'></span>

<h3>Description</h3>

<p>Get the estimated mean toxicity rate at each dose under investigation. This
is a set of modelled statistics. The underlying models estimate toxicity
probabilities in different ways. If no model-based estimate of the mean is
available, this function will return a vector of NAs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mean_prob_tox(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mean_prob_tox_+3A_x">x</code></td>
<td>
<p>Object of class <code><a href="#topic+selector">selector</a></code></p>
</td></tr>
<tr><td><code id="mean_prob_tox_+3A_...">...</code></td>
<td>
<p>arguments passed to other methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a numerical vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'># CRM example
skeleton &lt;- c(0.05, 0.1, 0.25, 0.4, 0.6)
target &lt;- 0.25
outcomes &lt;- '1NNN 2NTN'
fit &lt;- get_dfcrm(skeleton = skeleton, target = target) %&gt;% fit(outcomes)
fit %&gt;% mean_prob_tox()
</code></pre>

<hr>
<h2 id='median_prob_eff'>Median efficacy rate at each dose.</h2><span id='topic+median_prob_eff'></span>

<h3>Description</h3>

<p>Get the estimated median efficacy rate at each dose under investigation. This
is a set of modelled statistics. The underlying models estimate efficacy
probabilities in different ways. If no model-based estimate of the median is
available, this function will return a vector of NAs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>median_prob_eff(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="median_prob_eff_+3A_x">x</code></td>
<td>
<p>Object of class <code><a href="#topic+selector">selector</a></code></p>
</td></tr>
<tr><td><code id="median_prob_eff_+3A_...">...</code></td>
<td>
<p>arguments passed to other methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a numerical vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'>efftox_priors &lt;- trialr::efftox_priors
p &lt;- efftox_priors(alpha_mean = -7.9593, alpha_sd = 3.5487,
                   beta_mean = 1.5482, beta_sd = 3.5018,
                   gamma_mean = 0.7367, gamma_sd = 2.5423,
                   zeta_mean = 3.4181, zeta_sd = 2.4406,
                   eta_mean = 0, eta_sd = 0.2,
                   psi_mean = 0, psi_sd = 1)
real_doses = c(1.0, 2.0, 4.0, 6.6, 10.0)
model &lt;- get_trialr_efftox(real_doses = real_doses,
                           efficacy_hurdle = 0.5, toxicity_hurdle = 0.3,
                           p_e = 0.1, p_t = 0.1,
                           eff0 = 0.5, tox1 = 0.65,
                           eff_star = 0.7, tox_star = 0.25,
                           priors = p, iter = 1000, chains = 1, seed = 2020)
x &lt;- model %&gt;% fit('1N 2E 3B')
median_prob_eff(x)
</code></pre>

<hr>
<h2 id='median_prob_tox'>Median toxicity rate at each dose.</h2><span id='topic+median_prob_tox'></span>

<h3>Description</h3>

<p>Get the estimated median toxicity rate at each dose under investigation. This
is a set of modelled statistics. The underlying models estimate toxicity
probabilities in different ways. If no model-based estimate of the median is
available, this function will return a vector of NAs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>median_prob_tox(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="median_prob_tox_+3A_x">x</code></td>
<td>
<p>Object of class <code><a href="#topic+selector">selector</a></code></p>
</td></tr>
<tr><td><code id="median_prob_tox_+3A_...">...</code></td>
<td>
<p>arguments passed to other methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a numerical vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'># CRM example
skeleton &lt;- c(0.05, 0.1, 0.25, 0.4, 0.6)
target &lt;- 0.25
outcomes &lt;- '1NNN 2NTN'
fit &lt;- get_dfcrm(skeleton = skeleton, target = target) %&gt;% fit(outcomes)
fit %&gt;% median_prob_tox()
</code></pre>

<hr>
<h2 id='model_frame'>Model data-frame.</h2><span id='topic+model_frame'></span>

<h3>Description</h3>

<p>Get the model data-frame for a dose-finding analysis, inlcuding columns for
patient id, cohort id, dose administered, and toxicity outcome. In some
scenarios, further columns are provided.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>model_frame(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="model_frame_+3A_x">x</code></td>
<td>
<p>Object of type <code><a href="#topic+selector">selector</a></code>.</p>
</td></tr>
<tr><td><code id="model_frame_+3A_...">...</code></td>
<td>
<p>Extra args are passed onwards.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code><a href="tibble.html#topic+tibble">tibble</a></code>, which acts like a <code>data.frame</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># In a toxicity-only setting:
skeleton &lt;- c(0.05, 0.1, 0.25, 0.4, 0.6)
target &lt;- 0.25
model &lt;- get_dfcrm(skeleton = skeleton, target = target)
fit &lt;- model %&gt;% fit('1NNN 2NTN')
fit %&gt;% model_frame()

# In an efficacy-toxicity setting
prob_select = c(0.1, 0.3, 0.5, 0.07, 0.03)
model &lt;- get_random_selector(prob_select = prob_select,
                             supports_efficacy = TRUE)
x &lt;- model %&gt;% fit('1NTN 2EN 5BB', supports_efficacy = TRUE)
fit %&gt;% model_frame()
</code></pre>

<hr>
<h2 id='n_at_dose'>Number of patients treated at each dose.</h2><span id='topic+n_at_dose'></span>

<h3>Description</h3>

<p>Get the number of patients evaluated at each dose under investigation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>n_at_dose(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="n_at_dose_+3A_x">x</code></td>
<td>
<p>Object of class <code><a href="#topic+selector">selector</a></code></p>
</td></tr>
<tr><td><code id="n_at_dose_+3A_...">...</code></td>
<td>
<p>arguments passed to other methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an integer vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'># CRM example
skeleton &lt;- c(0.05, 0.1, 0.25, 0.4, 0.6)
target &lt;- 0.25
outcomes &lt;- '1NNN 2NTN'
fit &lt;- get_dfcrm(skeleton = skeleton, target = target) %&gt;% fit(outcomes)
fit %&gt;% n_at_dose()
</code></pre>

<hr>
<h2 id='n_at_recommended_dose'>Number of patients treated at the recommended dose.</h2><span id='topic+n_at_recommended_dose'></span>

<h3>Description</h3>

<p>Get the number of patients evaluated at the recommended dose.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>n_at_recommended_dose(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="n_at_recommended_dose_+3A_x">x</code></td>
<td>
<p>Object of class <code><a href="#topic+selector">selector</a></code></p>
</td></tr>
<tr><td><code id="n_at_recommended_dose_+3A_...">...</code></td>
<td>
<p>arguments passed to other methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an integer
</p>


<h3>Examples</h3>

<pre><code class='language-R'># CRM example
skeleton &lt;- c(0.05, 0.1, 0.25, 0.4, 0.6)
target &lt;- 0.25
outcomes &lt;- '1NNN 2NTN'
fit &lt;- get_dfcrm(skeleton = skeleton, target = target) %&gt;% fit(outcomes)
fit %&gt;% n_at_recommended_dose()
</code></pre>

<hr>
<h2 id='num_cohort_outcomes'>Number of different possible outcomes for a cohort of patients</h2><span id='topic+num_cohort_outcomes'></span>

<h3>Description</h3>

<p>Number of different possible outcomes for a cohort of patients, each of
which will experience one of a number of discrete outcomes. For instance, in
a typical phase I dose-finding trial, each patient will experience:
no-toxicity (N); or toxicity (T). The number of possible outcomes per patient
is two. For a cohort of three patients, the number of cohort outcomes is
four: NNN, NNT, NTT, TTT. Consider a more complex example: in a seamless
phase I/II trial with efficacy and toxicity outcomes, an individual patient
will experience one of four distinct outcomes: efficacy only (E); toxicity
only (T); both efficacy and toxicity (B) or neither. How many different
outcomes are there for a cohort of three patients? The answer is 20 but it is
non-trivial to see why. This convenience function calculates that number
using the formula for the number of combinations with replacement,
</p>


<h3>Usage</h3>

<pre><code class='language-R'>num_cohort_outcomes(num_patient_outcomes, cohort_size)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="num_cohort_outcomes_+3A_num_patient_outcomes">num_patient_outcomes</code></td>
<td>
<p>integer, number of distinct possible outcomes for
each single patient</p>
</td></tr>
<tr><td><code id="num_cohort_outcomes_+3A_cohort_size">cohort_size</code></td>
<td>
<p>integer, number of patients in the cohort</p>
</td></tr>
</table>


<h3>Value</h3>

<p>integer, number of distinct possible cohort outcomes
</p>


<h3>Examples</h3>

<pre><code class='language-R'># As described in example, N or T in a cohort of three:
num_cohort_outcomes(num_patient_outcomes = 2, cohort_size = 3)
# Also described in example, E, T, B or N in a cohort of three:
num_cohort_outcomes(num_patient_outcomes = 4, cohort_size = 3)
</code></pre>

<hr>
<h2 id='num_dose_path_nodes'>Number of nodes in dose-paths analysis</h2><span id='topic+num_dose_path_nodes'></span>

<h3>Description</h3>

<p>Number of possible nodes in an exhaustive analysis of dose-paths in a
dose-finding trial. The number of nodes at depth i is the the number of nodes
at depth i-1 multiplied by the number of possible cohort outcomes at depth i.
For instance, if there were 16 nodes at the previous depth and four possible
cohort outcomes at the current depth, then there are 64 possible nodes at the
current depth. Knowing the number of nodes in a dose-paths analysis helps the
analyst decide whether simulation or dose-paths are a better tool for
assessing operating characteristics of a dose-finding design.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>num_dose_path_nodes(num_patient_outcomes, cohort_sizes)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="num_dose_path_nodes_+3A_num_patient_outcomes">num_patient_outcomes</code></td>
<td>
<p>integer, number of distinct possible outcomes for
each single patient</p>
</td></tr>
<tr><td><code id="num_dose_path_nodes_+3A_cohort_sizes">cohort_sizes</code></td>
<td>
<p>integer vector of cohort sizes</p>
</td></tr>
</table>


<h3>Value</h3>

<p>integer vector, number of nodes at increasing depths. The total
number of nodes is the sum of this vector.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># In a 3+3 design, there are two possible outcomes for each patient and
# patients are evaluated in cohorts of three. In an analysis of dose-paths in
# the first two cohorts of three, how many nodes are there?
num_dose_path_nodes(num_patient_outcomes = 2, cohort_sizes = rep(3, 2))
# In contrast, using an EffTox design there are four possible outcomes for
# each patient. In a similar analysis of dose-paths in the first two cohorts
# of three, how many nodes are there now?
num_dose_path_nodes(num_patient_outcomes = 4, cohort_sizes = rep(3, 2))
</code></pre>

<hr>
<h2 id='num_doses'>Number of doses.</h2><span id='topic+num_doses'></span>

<h3>Description</h3>

<p>Get the number of doses under investigation in a dose-finding trial.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>num_doses(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="num_doses_+3A_x">x</code></td>
<td>
<p>Object of type <code><a href="#topic+selector">selector</a></code>.</p>
</td></tr>
<tr><td><code id="num_doses_+3A_...">...</code></td>
<td>
<p>Extra args are passed onwards.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>integer
</p>


<h3>Examples</h3>

<pre><code class='language-R'>skeleton &lt;- c(0.05, 0.1, 0.25, 0.4, 0.6)
target &lt;- 0.25
model &lt;- get_dfcrm(skeleton = skeleton, target = target)
fit &lt;- model %&gt;% fit('1NNN 2NTN')
fit %&gt;% num_doses()
</code></pre>

<hr>
<h2 id='num_eff'>Total number of efficacies seen.</h2><span id='topic+num_eff'></span>

<h3>Description</h3>

<p>Get the number of efficacies seen in a dose-finding trial.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>num_eff(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="num_eff_+3A_x">x</code></td>
<td>
<p>Object of type <code><a href="#topic+selector">selector</a></code>.</p>
</td></tr>
<tr><td><code id="num_eff_+3A_...">...</code></td>
<td>
<p>Extra args are passed onwards.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>integer
</p>


<h3>Examples</h3>

<pre><code class='language-R'>prob_select = c(0.1, 0.3, 0.5, 0.07, 0.03)
model &lt;- get_random_selector(prob_select = prob_select,
                             supports_efficacy = TRUE)
x &lt;- model %&gt;% fit('1NTN 2EN 5BB')
num_eff(x)
</code></pre>

<hr>
<h2 id='num_patients'>Number of patients evaluated.</h2><span id='topic+num_patients'></span>

<h3>Description</h3>

<p>Get the number of patients evaluated in a dose-finding trial.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>num_patients(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="num_patients_+3A_x">x</code></td>
<td>
<p>Object of type <code><a href="#topic+selector">selector</a></code>.</p>
</td></tr>
<tr><td><code id="num_patients_+3A_...">...</code></td>
<td>
<p>Extra args are passed onwards.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>integer
</p>


<h3>Examples</h3>

<pre><code class='language-R'>skeleton &lt;- c(0.05, 0.1, 0.25, 0.4, 0.6)
target &lt;- 0.25
model &lt;- get_dfcrm(skeleton = skeleton, target = target)
fit &lt;- model %&gt;% fit('1NNN 2NTN')
fit %&gt;% num_patients()
</code></pre>

<hr>
<h2 id='num_tox'>Total number of toxicities seen.</h2><span id='topic+num_tox'></span>

<h3>Description</h3>

<p>Get the number of toxicities seen in a dose-finding trial.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>num_tox(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="num_tox_+3A_x">x</code></td>
<td>
<p>Object of type <code><a href="#topic+selector">selector</a></code>.</p>
</td></tr>
<tr><td><code id="num_tox_+3A_...">...</code></td>
<td>
<p>Extra args are passed onwards.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>integer
</p>


<h3>Examples</h3>

<pre><code class='language-R'>skeleton &lt;- c(0.05, 0.1, 0.25, 0.4, 0.6)
target &lt;- 0.25
model &lt;- get_dfcrm(skeleton = skeleton, target = target)
fit &lt;- model %&gt;% fit('1NNN 2NTN')
fit %&gt;% num_tox()
</code></pre>

<hr>
<h2 id='parse_phase1_2_outcomes'>Parse a string of phase I/II dose-finding outcomes to vector notation.</h2><span id='topic+parse_phase1_2_outcomes'></span>

<h3>Description</h3>

<p>Parse a string of phase I/II dose-finding outcomes to a binary
vector notation necessary for model invocation.
</p>
<p>The outcome string describes the doses given, outcomes observed and groups
patients into cohorts. The format of the string is described in Brock et al.
(2017). See Examples.
</p>
<p>The letters E, T, N and B are used to represents patients that
experienced (E)fficacy only, (T)oxicity only, (B)oth efficacy and toxicity,
and (N)either. These letters are concatenated after numerical dose-levels to
convey the outcomes of cohorts of patients. For instance, <code>2ETB</code>
represents a cohort of three patients that were treated at dose-level 2, and
experienced efficacy, toxicity and both events, respectively. The results of
cohorts are separated by spaces. Thus, <code>2ETB 1NN</code> extends our previous
example, where the next cohort of two were treated at dose-level 1 and both
patients experienced neither efficacy nor toxicity. See Examples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parse_phase1_2_outcomes(outcomes, as_list = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="parse_phase1_2_outcomes_+3A_outcomes">outcomes</code></td>
<td>
<p>character string, conveying doses given and outcomes
observed.</p>
</td></tr>
<tr><td><code id="parse_phase1_2_outcomes_+3A_as_list">as_list</code></td>
<td>
<p>TRUE (the default) to return a <code>list</code>;
FALSE to return a <code>data.frame</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>as_list == TRUE</code>, a list with elements <code>eff</code>,
<code>tox</code>, <code>dose</code> and <code>num_patients</code>. If <code>as_list == FALSE</code>,
a data.frame with columns <code>eff</code>, <code>tox</code> and <code>dose</code>.
</p>


<h3>References</h3>

<p>Brock, K., Billingham, L., Copland, M., Siddique, S., Sirovica, M., &amp; Yap, C.
(2017). Implementing the EffTox dose-finding design in the Matchpoint trial.
BMC Medical Research Methodology, 17(1), 112.
https://doi.org/10.1186/s12874-017-0381-x
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x = parse_phase1_2_outcomes('1NNE 2EEN 3TBB')
# Three cohorts of three patients. The first cohort was treated at dose 1 and
# had no toxicity with one efficacy, etc.
x$num_patients  # 9
x$dose         # c(1, 1, 1, 2, 2, 2, 3, 3, 3)
x$eff           # c(0, 0, 1, 1, 1, 0, 0, 1, 1)
sum(x$eff)      # 5
x$tox           # c(0, 0, 0, 0, 0, 0, 1, 1, 1)
sum(x$tox)      # 3

# The same information can be parsed to a data-frame:
y = parse_phase1_2_outcomes('1NNE 2EEN 3TBB', as_list = FALSE)
y
</code></pre>

<hr>
<h2 id='parse_phase1_outcomes'>Parse a string of phase I dose-finding outcomes to vector notation.</h2><span id='topic+parse_phase1_outcomes'></span>

<h3>Description</h3>

<p>Parse a string of phase I dose-finding outcomes to a binary
vector notation necessary for model invocation.
</p>
<p>The outcome string describes the doses given, outcomes observed and groups
patients into cohorts. The format of the string is described in Brock (2019),
and that itself is the phase I analogue of the similar idea described in
Brock et al. (2017). See Examples.
</p>
<p>The letters T and N are used to represents patients that experienced
(T)oxicity and (N)o toxicity. These letters are concatenated after numerical
dose-levels to convey the outcomes of cohorts of patients.
For instance, <code>2NNT</code> represents a cohort of three patients that were
treated at dose-level 2, one of whom experienced toxicity, and two that did
not. The results of cohorts are separated by spaces. Thus, <code>2NNT 1NN</code>
extends our previous example, where the next cohort of two were treated at
dose-level 1 and neither experienced toxicity. See examples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parse_phase1_outcomes(outcomes, as_list = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="parse_phase1_outcomes_+3A_outcomes">outcomes</code></td>
<td>
<p>character string, conveying doses given and outcomes
observed.</p>
</td></tr>
<tr><td><code id="parse_phase1_outcomes_+3A_as_list">as_list</code></td>
<td>
<p>TRUE (the default) to return a <code>list</code>;
FALSE to return a <code>data.frame</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>as_list == TRUE</code>, a list with elements <code>tox</code>,
<code>doses</code> and <code>num_patients</code>. If <code>as_list == FALSE</code>, a
data.frame with columns <code>tox</code> and <code>doses</code>.
</p>


<h3>References</h3>

<p>Brock, K. (2019). trialr: Bayesian Clinical Trial Designs in R and Stan.
arXiv:1907.00161 [stat.CO]
</p>
<p>Brock, K., Billingham, L., Copland, M., Siddique, S., Sirovica, M., &amp; Yap, C.
(2017). Implementing the EffTox dose-finding design in the Matchpoint trial.
BMC Medical Research Methodology, 17(1), 112.
https://doi.org/10.1186/s12874-017-0381-x
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x = parse_phase1_outcomes('1NNN 2NTN 3TTT')
# Three cohorts of three patients. The first cohort was treated at dose 1 and
# none had toxicity. The second cohort was treated at dose 2 and one of the
# three had toxicity. Finally, cohort three was treated at dose 3 and all
# patients had toxicity.
x$num_patients  # 9
x$doses         # c(1, 1, 1, 2, 2, 2, 3, 3, 3)
x$tox           # c(0, 0, 0, 0, 1, 0, 1, 1, 1)
sum(x$tox)      # 4

# The same information can be parsed to a data-frame:
y = parse_phase1_outcomes('1NNN 2NTN 3TTT', as_list = FALSE)
y
</code></pre>

<hr>
<h2 id='PatientSample'>A sample of patients to use in simulations.</h2><span id='topic+PatientSample'></span>

<h3>Description</h3>

<p>Class to house the latent random variables that govern toxicity and efficacy
events in patients. Instances of this class can be used in simulation-like
tasks to effectively use the same simulated individuals in different designs,
thus supporting reduced Monte Carlo error and more efficient comparison.
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>num_patients</code></dt><dd><p>('integer(1)')<br /></p>
</dd>
<dt><code>tox_u</code></dt><dd><p>('numeric(num_patients)')<br /></p>
</dd>
<dt><code>eff_u</code></dt><dd><p>('numeric(num_patients)')<br /></p>
</dd>
<dt><code>can_grow</code></dt><dd><p>('logical(1)')<br /></p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-PatientSample-new"><code>PatientSample$new()</code></a>
</p>
</li>
<li> <p><a href="#method-PatientSample-set_eff_and_tox"><code>PatientSample$set_eff_and_tox()</code></a>
</p>
</li>
<li> <p><a href="#method-PatientSample-expand_to"><code>PatientSample$expand_to()</code></a>
</p>
</li>
<li> <p><a href="#method-PatientSample-get_tox_u"><code>PatientSample$get_tox_u()</code></a>
</p>
</li>
<li> <p><a href="#method-PatientSample-get_patient_tox"><code>PatientSample$get_patient_tox()</code></a>
</p>
</li>
<li> <p><a href="#method-PatientSample-get_eff_u"><code>PatientSample$get_eff_u()</code></a>
</p>
</li>
<li> <p><a href="#method-PatientSample-get_patient_eff"><code>PatientSample$get_patient_eff()</code></a>
</p>
</li>
<li> <p><a href="#method-PatientSample-clone"><code>PatientSample$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-PatientSample-new"></a>



<h4>Method <code>new()</code></h4>

<p>Creator.
</p>


<h5>Usage</h5>

<div class="r"><pre>PatientSample$new(num_patients = 0)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>num_patients</code></dt><dd><p>('integer(1)').</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>[PatientSample].
</p>


<hr>
<a id="method-PatientSample-set_eff_and_tox"></a>



<h4>Method <code>set_eff_and_tox()</code></h4>

<p>Set the toxicity and efficacy latent variables that govern occurrence of
toxicity and efficacy events. By default, instances of this class
automatically grow these latent variables to accommodate arbitrarily high
sample sizes. However, when you set these latent variables manually via
this function, you override the ability of the class to self-manage, so
its ability to grow is turned off by setting the internal variable
<code>self$can_grow &lt;- FALSE</code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>PatientSample$set_eff_and_tox(tox_u, eff_u)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>tox_u</code></dt><dd><p>('numeric()').</p>
</dd>
<dt><code>eff_u</code></dt><dd><p>('numeric()').</p>
</dd>
</dl>

</div>


<hr>
<a id="method-PatientSample-expand_to"></a>



<h4>Method <code>expand_to()</code></h4>

<p>Expand sample to size at least num_patients
</p>


<h5>Usage</h5>

<div class="r"><pre>PatientSample$expand_to(num_patients)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>num_patients</code></dt><dd><p>('integer(1)').</p>
</dd>
</dl>

</div>


<hr>
<a id="method-PatientSample-get_tox_u"></a>



<h4>Method <code>get_tox_u()</code></h4>

<p>Get toxicity latent variable for patient i
</p>


<h5>Usage</h5>

<div class="r"><pre>PatientSample$get_tox_u(i)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>i</code></dt><dd><p>('integer(1)') patient index</p>
</dd>
</dl>

</div>


<hr>
<a id="method-PatientSample-get_patient_tox"></a>



<h4>Method <code>get_patient_tox()</code></h4>

<p>Get 0 or 1 event marker for whether toxicity occurred in patient i
</p>


<h5>Usage</h5>

<div class="r"><pre>PatientSample$get_patient_tox(i, prob_tox)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>i</code></dt><dd><p>('integer(1)') patient index</p>
</dd>
<dt><code>prob_tox</code></dt><dd><p>('numeric(1)') probability of toxicity</p>
</dd>
</dl>

</div>


<hr>
<a id="method-PatientSample-get_eff_u"></a>



<h4>Method <code>get_eff_u()</code></h4>

<p>Get efficacy latent variable for patient i
</p>


<h5>Usage</h5>

<div class="r"><pre>PatientSample$get_eff_u(i)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>i</code></dt><dd><p>('integer(1)') patient index</p>
</dd>
</dl>

</div>


<hr>
<a id="method-PatientSample-get_patient_eff"></a>



<h4>Method <code>get_patient_eff()</code></h4>

<p>Get 0 or 1 event marker for whether efficacy occurred in patient i
</p>


<h5>Usage</h5>

<div class="r"><pre>PatientSample$get_patient_eff(i, prob_eff)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>i</code></dt><dd><p>('integer(1)') patient index</p>
</dd>
<dt><code>prob_eff</code></dt><dd><p>('numeric(1)') probability of efficacy</p>
</dd>
</dl>

</div>


<hr>
<a id="method-PatientSample-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>PatientSample$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>References</h3>

<p>Sweeting, M., Slade, D., Jackson, D., &amp; Brock, K. (2023).
Potential outcome simulation for efficient head-to-head comparison of
adaptive dose-finding designs. Preprint.
</p>

<hr>
<h2 id='phase1_2_outcomes_to_cohorts'>Break a phase I/II outcome string into a list of cohort parts.</h2><span id='topic+phase1_2_outcomes_to_cohorts'></span>

<h3>Description</h3>

<p>Break a phase I/II outcome string into a list of cohort parts.
</p>
<p>Break a phase I/II outcome string into a list of cohort parts.
</p>
<p>The outcome string describes the doses given, outcomes observed and the
timing of analyses that recommend a dose. The format of the string is
described in Brock _et al_. (2017).
</p>
<p>The letters E, T, N &amp; B are used to represents patients that experienced
(E)fficacy, (T)oxicity, (N)either and (B)oth. These letters are concatenated
after numerical dose-levels to convey the outcomes of cohorts of patients.
For instance, <code>2NET</code> represents a cohort of three patients that were
treated at dose-level 2, one of whom experienced toxicity only, one that
experienced efficacy only, and one that had neither.
The results of cohorts are separated by spaces and it is assumed that a
dose-finding decision takes place at the end of a cohort. Thus,
<code>2NET 1NN</code> builds on our previous example, where the next cohort of two
were treated at dose-level 1 and neither of these patients experienced
either event See examples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>phase1_2_outcomes_to_cohorts(outcomes)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="phase1_2_outcomes_to_cohorts_+3A_outcomes">outcomes</code></td>
<td>
<p>character string representing the doses given, outcomes
observed, and timing of analyses. See Description.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with a slot for each cohort. Each cohort slot is itself a
list, containing elements:
* <code>dose</code>, the integer dose delivered to the cohort;
* <code>outcomes</code>, a character string representing the <code>E</code>, <code>T</code>
<code>N</code> or <code>B</code> outcomes for the patients in this cohort.
</p>


<h3>References</h3>

<p>Brock, K., Billingham, L., Copland, M., Siddique, S., Sirovica, M., &amp; Yap, C.
(2017). Implementing the EffTox dose-finding design in the Matchpoint trial.
BMC Medical Research Methodology, 17(1), 112.
https://doi.org/10.1186/s12874-017-0381-x
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x = phase1_2_outcomes_to_cohorts('1NEN 2ENT 3TB')
length(x)
x[[1]]$dose
x[[1]]$outcomes
x[[2]]$dose
x[[2]]$outcomes
x[[3]]$dose
x[[3]]$outcomes

</code></pre>

<hr>
<h2 id='phase1_outcomes_to_cohorts'>Break a phase I outcome string into a list of cohort parts.</h2><span id='topic+phase1_outcomes_to_cohorts'></span>

<h3>Description</h3>

<p>Break a phase I outcome string into a list of cohort parts.
</p>
<p>Break a phase I outcome string into a list of cohort parts.
</p>
<p>The outcome string describes the doses given, outcomes observed and the
timing of analyses that recommend a dose. The format of the string is
described in Brock (2019), and that itself is the phase I analogue of the
similar idea described in Brock _et al_. (2017).
</p>
<p>The letters T and N are used to represents patients that experienced
(T)oxicity and (N)o toxicity. These letters are concatenated after numerical
dose-levels to convey the outcomes of cohorts of patients.
For instance, <code>2NNT</code> represents a cohort of three patients that were
treated at dose-level 2, one of whom experienced toxicity, and two that did
not. The results of cohorts are separated by spaces and it is assumed that a
dose-finding decision takes place at the end of a cohort. Thus,
<code>2NNT 1NN</code> builds on our previous example, where the next cohort of two
were treated at dose-level 1 and neither of these patients experienced
toxicity. See examples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>phase1_outcomes_to_cohorts(outcomes)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="phase1_outcomes_to_cohorts_+3A_outcomes">outcomes</code></td>
<td>
<p>character string representing the doses given, outcomes
observed, and timing of analyses. See Description.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with a slot for each cohort. Each cohort slot is itself a
list, containing elements:
* <code>dose</code>, the integer dose delivered to the cohort;
* <code>outcomes</code>, a character string representing the <code>T</code> or <code>N</code>
outcomes for the patients in this cohort.
</p>


<h3>References</h3>

<p>Brock, K. (2019). trialr: Bayesian Clinical Trial Designs in R and Stan.
arXiv:1907.00161 [stat.CO]
</p>
<p>Brock, K., Billingham, L., Copland, M., Siddique, S., Sirovica, M., &amp; Yap, C.
(2017). Implementing the EffTox dose-finding design in the Matchpoint trial.
BMC Medical Research Methodology, 17(1), 112.
https://doi.org/10.1186/s12874-017-0381-x
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x = phase1_outcomes_to_cohorts('1NNN 2NNT 3TT')
length(x)
x[[1]]$dose
x[[1]]$outcomes
x[[2]]$dose
x[[2]]$outcomes
x[[3]]$dose
x[[3]]$outcomes

</code></pre>

<hr>
<h2 id='prob_administer'>Percentage of patients treated at each dose.</h2><span id='topic+prob_administer'></span>

<h3>Description</h3>

<p>Get the percentage of patients evaluated at each dose under investigation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prob_administer(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prob_administer_+3A_x">x</code></td>
<td>
<p>Object of class <code><a href="#topic+selector">selector</a></code></p>
</td></tr>
<tr><td><code id="prob_administer_+3A_...">...</code></td>
<td>
<p>arguments passed to other methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a numerical vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'># CRM example
skeleton &lt;- c(0.05, 0.1, 0.25, 0.4, 0.6)
target &lt;- 0.25
outcomes &lt;- '1NNN 2NTN'
fit &lt;- get_dfcrm(skeleton = skeleton, target = target) %&gt;% fit(outcomes)
fit %&gt;% prob_administer()
</code></pre>

<hr>
<h2 id='prob_eff_quantile'>Quantile of the efficacy rate at each dose.</h2><span id='topic+prob_eff_quantile'></span>

<h3>Description</h3>

<p>Get the estimated quantile of the efficacy rate at each dose under
investigation. This is a set of modelled statistics. The underlying models
estimate efficacy probabilities in different ways. If no model-based
estimate of the median is available, this function will return a vector of
NAs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prob_eff_quantile(x, p, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prob_eff_quantile_+3A_x">x</code></td>
<td>
<p>Object of class <code><a href="#topic+selector">selector</a></code></p>
</td></tr>
<tr><td><code id="prob_eff_quantile_+3A_p">p</code></td>
<td>
<p>quantile probability, decimal value between 0 and 1</p>
</td></tr>
<tr><td><code id="prob_eff_quantile_+3A_...">...</code></td>
<td>
<p>arguments passed to other methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a numerical vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'>efftox_priors &lt;- trialr::efftox_priors
p &lt;- efftox_priors(alpha_mean = -7.9593, alpha_sd = 3.5487,
                   beta_mean = 1.5482, beta_sd = 3.5018,
                   gamma_mean = 0.7367, gamma_sd = 2.5423,
                   zeta_mean = 3.4181, zeta_sd = 2.4406,
                   eta_mean = 0, eta_sd = 0.2,
                   psi_mean = 0, psi_sd = 1)
real_doses = c(1.0, 2.0, 4.0, 6.6, 10.0)
model &lt;- get_trialr_efftox(real_doses = real_doses,
                           efficacy_hurdle = 0.5, toxicity_hurdle = 0.3,
                           p_e = 0.1, p_t = 0.1,
                           eff0 = 0.5, tox1 = 0.65,
                           eff_star = 0.7, tox_star = 0.25,
                           priors = p, iter = 1000, chains = 1, seed = 2020)
x &lt;- model %&gt;% fit('1N 2E 3B')
prob_tox_quantile(x, p = 0.9)
</code></pre>

<hr>
<h2 id='prob_recommend'>Probability of recommendation</h2><span id='topic+prob_recommend'></span>

<h3>Description</h3>

<p>Get the probabilities that each of the doses under investigation is
recommended.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prob_recommend(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prob_recommend_+3A_x">x</code></td>
<td>
<p>Object of type <code><a href="#topic+simulations">simulations</a></code>.</p>
</td></tr>
<tr><td><code id="prob_recommend_+3A_...">...</code></td>
<td>
<p>arguments passed to other methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector of probabilities
</p>


<h3>Examples</h3>

<pre><code class='language-R'>true_prob_tox &lt;- c(0.12, 0.27, 0.44, 0.53, 0.57)
sims &lt;- get_three_plus_three(num_doses = 5) %&gt;%
  simulate_trials(num_sims = 50, true_prob_tox = true_prob_tox)
sims %&gt;% prob_recommend
</code></pre>

<hr>
<h2 id='prob_tox_exceeds'>Probability that the toxicity rate exceeds some threshold.</h2><span id='topic+prob_tox_exceeds'></span><span id='topic+prob_eff_exceeds'></span>

<h3>Description</h3>

<p>Get the probability that the toxicity rate at each dose exceeds some
threshold.
</p>
<p>Get the probability that the efficacy rate at each dose exceeds some
threshold.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prob_tox_exceeds(x, threshold, ...)

prob_eff_exceeds(x, threshold, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prob_tox_exceeds_+3A_x">x</code></td>
<td>
<p>Object of type <code><a href="#topic+selector">selector</a></code></p>
</td></tr>
<tr><td><code id="prob_tox_exceeds_+3A_threshold">threshold</code></td>
<td>
<p>Probability that efficacy rate exceeds what?</p>
</td></tr>
<tr><td><code id="prob_tox_exceeds_+3A_...">...</code></td>
<td>
<p>arguments passed to other methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numerical vector of probabilities
</p>
<p>numerical vector of probabilities
</p>


<h3>Examples</h3>

<pre><code class='language-R'># CRM example
skeleton &lt;- c(0.05, 0.1, 0.25, 0.4, 0.6)
target &lt;- 0.25
outcomes &lt;- '1NNN 2NTN'
fit &lt;- get_dfcrm(skeleton = skeleton, target = target) %&gt;% fit(outcomes)
# What is probability that tox rate at each dose exceeds target by &gt;= 10%?
fit %&gt;% prob_tox_exceeds(threshold = target + 0.1)
efftox_priors &lt;- trialr::efftox_priors
p &lt;- efftox_priors(alpha_mean = -7.9593, alpha_sd = 3.5487,
                   beta_mean = 1.5482, beta_sd = 3.5018,
                   gamma_mean = 0.7367, gamma_sd = 2.5423,
                   zeta_mean = 3.4181, zeta_sd = 2.4406,
                   eta_mean = 0, eta_sd = 0.2,
                   psi_mean = 0, psi_sd = 1)
real_doses = c(1.0, 2.0, 4.0, 6.6, 10.0)
model &lt;- get_trialr_efftox(real_doses = real_doses,
                           efficacy_hurdle = 0.5, toxicity_hurdle = 0.3,
                           p_e = 0.1, p_t = 0.1,
                           eff0 = 0.5, tox1 = 0.65,
                           eff_star = 0.7, tox_star = 0.25,
                           priors = p, iter = 1000, chains = 1, seed = 2020)
x &lt;- model %&gt;% fit('1N 2E 3B')
prob_tox_exceeds(x, threshold = 0.45)
</code></pre>

<hr>
<h2 id='prob_tox_quantile'>Quantile of the toxicity rate at each dose.</h2><span id='topic+prob_tox_quantile'></span>

<h3>Description</h3>

<p>Get the estimated quantile of the toxicity rate at each dose under
investigation. This is a set of modelled statistics. The underlying models
estimate toxicity probabilities in different ways. If no model-based
estimate of the median is available, this function will return a vector of
NAs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prob_tox_quantile(x, p, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prob_tox_quantile_+3A_x">x</code></td>
<td>
<p>Object of class <code><a href="#topic+selector">selector</a></code></p>
</td></tr>
<tr><td><code id="prob_tox_quantile_+3A_p">p</code></td>
<td>
<p>quantile probability, decimal value between 0 and 1</p>
</td></tr>
<tr><td><code id="prob_tox_quantile_+3A_...">...</code></td>
<td>
<p>arguments passed to other methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a numerical vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'># CRM example
skeleton &lt;- c(0.05, 0.1, 0.25, 0.4, 0.6)
target &lt;- 0.25
outcomes &lt;- '1NNN 2NTN'
fit &lt;- get_dfcrm(skeleton = skeleton, target = target) %&gt;% fit(outcomes)
fit %&gt;% prob_tox_quantile(p = 0.9)
</code></pre>

<hr>
<h2 id='prob_tox_samples'>Get samples of the probability of toxicity.</h2><span id='topic+prob_tox_samples'></span><span id='topic+prob_eff_samples'></span>

<h3>Description</h3>

<p>Get samples of the probability of toxicity. For instance, a Bayesian approach
that supports sampling would be expected to return posterior samples of the
probability of toxicity. If this class does not support sampling, this
function will raise an error. You can check whether this class supports
sampling by calling <code><a href="#topic+supports_sampling">supports_sampling</a></code>.
</p>
<p>Get samples of the probability of efficacy For instance, a Bayesian approach
that supports sampling would be expected to return posterior samples of the
probability of toxicity. If this class does not support sampling, this
function will raise an error. You can check whether this class supports
sampling by calling <code><a href="#topic+supports_sampling">supports_sampling</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prob_tox_samples(x, tall = FALSE, ...)

prob_eff_samples(x, tall = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prob_tox_samples_+3A_x">x</code></td>
<td>
<p>Object of type <code><a href="#topic+selector">selector</a></code></p>
</td></tr>
<tr><td><code id="prob_tox_samples_+3A_tall">tall</code></td>
<td>
<p>logical, if FALSE, a wide data-frame is returned with columns
pertaining to the doses and column names the dose indices.
If TRUE, a tall data-frame is returned with data for all doses stacked
vertically. In this mode, column names will include <code>dose</code> and
<code>prob_eff</code>.</p>
</td></tr>
<tr><td><code id="prob_tox_samples_+3A_...">...</code></td>
<td>
<p>arguments passed to other methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data-frame like object
</p>
<p>data-frame like object
</p>


<h3>Examples</h3>

<pre><code class='language-R'># CRM example
skeleton &lt;- c(0.05, 0.1, 0.25, 0.4, 0.6)
target &lt;- 0.25
outcomes &lt;- '1NNN 2NTN'
fit &lt;- get_dfcrm(skeleton = skeleton, target = target) %&gt;% fit(outcomes)
fit %&gt;% prob_tox_samples()
fit %&gt;% prob_tox_samples(tall = TRUE)
efftox_priors &lt;- trialr::efftox_priors
p &lt;- efftox_priors(alpha_mean = -7.9593, alpha_sd = 3.5487,
                   beta_mean = 1.5482, beta_sd = 3.5018,
                   gamma_mean = 0.7367, gamma_sd = 2.5423,
                   zeta_mean = 3.4181, zeta_sd = 2.4406,
                   eta_mean = 0, eta_sd = 0.2,
                   psi_mean = 0, psi_sd = 1)
real_doses = c(1.0, 2.0, 4.0, 6.6, 10.0)
model &lt;- get_trialr_efftox(real_doses = real_doses,
                           efficacy_hurdle = 0.5, toxicity_hurdle = 0.3,
                           p_e = 0.1, p_t = 0.1,
                           eff0 = 0.5, tox1 = 0.65,
                           eff_star = 0.7, tox_star = 0.25,
                           priors = p, iter = 1000, chains = 1, seed = 2020)
x &lt;- model %&gt;% fit('1N 2E 3B')
prob_tox_samples(x, tall = TRUE)
</code></pre>

<hr>
<h2 id='recommended_dose'>Recommended dose for next patient or cohort.</h2><span id='topic+recommended_dose'></span>

<h3>Description</h3>

<p>Get the dose recommended for the next patient or cohort in a dose-finding
trial.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>recommended_dose(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="recommended_dose_+3A_x">x</code></td>
<td>
<p>Object of type <code><a href="#topic+selector">selector</a></code>.</p>
</td></tr>
<tr><td><code id="recommended_dose_+3A_...">...</code></td>
<td>
<p>Extra args are passed onwards.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>integer
</p>


<h3>Examples</h3>

<pre><code class='language-R'>skeleton &lt;- c(0.05, 0.1, 0.25, 0.4, 0.6)
target &lt;- 0.25
model &lt;- get_dfcrm(skeleton = skeleton, target = target)
fit &lt;- model %&gt;% fit('1NNN 2NTN')
fit %&gt;% recommended_dose()
</code></pre>

<hr>
<h2 id='select_boin_mtd'>Select dose by BOIN's MTD-choosing algorithm.</h2><span id='topic+select_boin_mtd'></span>

<h3>Description</h3>

<p>This method selects dose by the algorithm for identifying the maximum
tolerable dose (MTD) described in Yan et al. (2019). This class is intended
to be used when a BOIN trial has reached its maximum sample size. Thus, it
intends to make the final dose recommendation after the regular BOIN dose
selection algorithm, as implemented by <code><a href="#topic+get_boin">get_boin</a></code>, including any
additional behaviours that govern stopping (etc), has gracefully concluded a
dose-finding trial. However, the class can be used in any scenario where
there is a target toxicity rate. See Examples. Note - this class will not
override the parent dose selector when the parent is advocating no dose. Thus
this class will not reinstate a dangerous dose.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>select_boin_mtd(
  parent_selector_factory,
  when = c("finally", "always"),
  target = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="select_boin_mtd_+3A_parent_selector_factory">parent_selector_factory</code></td>
<td>
<p>Object of type <code><a href="#topic+selector_factory">selector_factory</a></code>.</p>
</td></tr>
<tr><td><code id="select_boin_mtd_+3A_when">when</code></td>
<td>
<p>Either of: 'finally' to select dose only when the parent
dose-selector has finished, by returning continue() == FALSE; or 'always'
to use this dose-selection algorithm for every dose decision. As per the
authors' original intentions, the default is 'finally'.</p>
</td></tr>
<tr><td><code id="select_boin_mtd_+3A_target">target</code></td>
<td>
<p>We seek a dose with this probability of toxicity. If not
provided, the value will be sought from the parent dose-selector.</p>
</td></tr>
<tr><td><code id="select_boin_mtd_+3A_...">...</code></td>
<td>
<p>Extra args are passed to <code><a href="BOIN.html#topic+select.mtd">select.mtd</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of type <code><a href="#topic+selector_factory">selector_factory</a></code>.
</p>


<h3>References</h3>

<p>Yan, F., Pan, H., Zhang, L., Liu, S., &amp; Yuan, Y. (2019). BOIN: An
R Package for Designing Single-Agent and Drug-Combination Dose-Finding Trials
Using Bayesian Optimal Interval Designs. Journal of Statistical Software,
27(November 2017), 035. https://doi.org/10.18637/jss.v000.i00
</p>


<h3>Examples</h3>

<pre><code class='language-R'># This class is intended to make the final dose selection in a BOIN trial:
target &lt;- 0.25
model &lt;- get_boin(num_doses = 5, target = target) %&gt;%
  stop_at_n(n = 12) %&gt;%
  select_boin_mtd()

outcomes &lt;- '1NNN 2NTN 2NNN 3NTT'
model %&gt;% fit(outcomes) %&gt;% recommended_dose()

# However, since behaviour is modular in this package, we can use this method
# to select dose at every dose decision if we wanted:
model2 &lt;- get_boin(num_doses = 5, target = target) %&gt;%
  select_boin_mtd(when = 'always')
model2 %&gt;% fit('1NNT') %&gt;% recommended_dose()
model2 %&gt;% fit('1NNN 2NNT') %&gt;% recommended_dose()

# and with any underlying model:
skeleton &lt;- c(0.05, 0.1, 0.25, 0.4, 0.6)
model3 &lt;- get_dfcrm(skeleton = skeleton, target = target) %&gt;%
  select_boin_mtd(when = 'always')
model3 %&gt;% fit('1NNT') %&gt;% recommended_dose()
model3 %&gt;% fit('1NNN 2NNT') %&gt;% recommended_dose()

</code></pre>

<hr>
<h2 id='select_boin12_obd'>Select dose by BOIN12's OBD-choosing algorithm.</h2><span id='topic+select_boin12_obd'></span>

<h3>Description</h3>

<p>This method selects dose by the algorithm for identifying the optimal
biological dose (OBD) described in Lin et al. (2020). This class is intended
to be used when a BOIN12 trial has reached its maximum sample size. Thus, it
intends to make the final dose recommendation after the regular BOIN12 dose
selection algorithm, as implemented by <code><a href="#topic+get_boin12">get_boin12</a></code>, has
gracefully concluded a dose-finding trial. However, the class can be used in
any scenario where there is a limit toxicity rate. See Examples.
Note - this class will not override the parent dose selector when the parent
is advocating no dose. Thus this class will not reinstate a dangerous dose.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>select_boin12_obd(
  parent_selector_factory,
  when = c("finally", "always"),
  tox_limit = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="select_boin12_obd_+3A_parent_selector_factory">parent_selector_factory</code></td>
<td>
<p>Object of type <code><a href="#topic+selector_factory">selector_factory</a></code>.</p>
</td></tr>
<tr><td><code id="select_boin12_obd_+3A_when">when</code></td>
<td>
<p>Either of: 'finally' to select dose only when the parent
dose-selector has finished, by returning continue() == FALSE; or 'always'
to use this dose-selection algorithm for every dose decision. As per the
authors' original intentions, the default is 'finally'.</p>
</td></tr>
<tr><td><code id="select_boin12_obd_+3A_tox_limit">tox_limit</code></td>
<td>
<p>We seek a dose with toxicity probability no greater than.
If not provided, the value will be sought from the parent dose-selector.</p>
</td></tr>
<tr><td><code id="select_boin12_obd_+3A_...">...</code></td>
<td>
<p>Extra args are ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of type <code><a href="#topic+selector_factory">selector_factory</a></code>.
</p>


<h3>References</h3>

<p>Lin, R., Zhou, Y., Yan, F., Li, D., &amp; Yuan, Y. (2020).
BOIN12: Bayesian optimal interval phase I/II trial design for utility-based
dose finding in immunotherapy and targeted therapies.
JCO precision oncology, 4, 1393-1402.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># This class is intended to make the final dose selection in a BOIN12 trial:
tox_limit &lt;- 0.35
model &lt;- get_boin12(num_doses = 5, phi_t = 0.35, phi_e = 0.25,
                    u2 = 40, u3 = 60, n_star = 6) %&gt;%
  stop_at_n(n = 12) %&gt;%
  select_boin12_obd()

outcomes &lt;- '1NNN 2NTN 2NNN 3NTT'
model %&gt;% fit(outcomes) %&gt;% recommended_dose()

# However, since behaviour is modular in this package, we can use this method
# to select dose at every dose decision:
model2 &lt;- get_boin12(num_doses = 5, phi_t = 0.35, phi_e = 0.25,
                    u2 = 40, u3 = 60, n_star = 6) %&gt;%
  select_boin12_obd(when = 'always')
model2 %&gt;% fit('1NNT') %&gt;% recommended_dose()
model2 %&gt;% fit('1NNN 2NNT') %&gt;% recommended_dose()

</code></pre>

<hr>
<h2 id='select_dose_by_cibp'>Select dose by the CIBP selection criterion.</h2><span id='topic+select_dose_by_cibp'></span>

<h3>Description</h3>

<p>This method selects dose by the convex infinite bounds penalisation (CIBP)
criterion of Mozgunov &amp; Jaki. Their method is mindful of the uncertainty in
the estimates of the probability of toxicity and uses an asymmetry parameter
to penalise escalation to risky doses.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>select_dose_by_cibp(parent_selector_factory, a, target = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="select_dose_by_cibp_+3A_parent_selector_factory">parent_selector_factory</code></td>
<td>
<p>Object of type <code><a href="#topic+selector_factory">selector_factory</a></code>.</p>
</td></tr>
<tr><td><code id="select_dose_by_cibp_+3A_a">a</code></td>
<td>
<p>Number between 0 and 2, the asymmetry parameter. See References.</p>
</td></tr>
<tr><td><code id="select_dose_by_cibp_+3A_target">target</code></td>
<td>
<p>We seek a dose with this probability of toxicity. If not
provided, the value will be sought from the parent dose-selector.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of type <code><a href="#topic+selector_factory">selector_factory</a></code> that can fit a
dose-finding model to outcomes.
</p>


<h3>References</h3>

<p>Mozgunov P, Jaki T. Improving safety of the continual reassessment method via
a modified allocation rule. Statistics in Medicine.1-17. doi:10.1002/sim.8450
</p>


<h3>Examples</h3>

<pre><code class='language-R'>skeleton &lt;- c(0.05, 0.1, 0.25, 0.4, 0.6)
target &lt;- 0.33

# Let's compare escalation behaviour of a CRM model without CIBP criterion:
model1 &lt;- get_dfcrm(skeleton = skeleton, target = target)
# To one with the CIBP criterion:
model2 &lt;- get_dfcrm(skeleton = skeleton, target = target) %&gt;%
  select_dose_by_cibp(a = 0.3)

# Despite one-in-three tox at first dose, regular model is ready to escalate:
model1 %&gt;% fit('1NTN') %&gt;% recommended_dose()
# But the model using CIBP is more risk averse:
model2 %&gt;% fit('1NTN') %&gt;% recommended_dose()

</code></pre>

<hr>
<h2 id='select_mtpi_mtd'>Select dose by mTPI's MTD-choosing algorithm.</h2><span id='topic+select_mtpi_mtd'></span>

<h3>Description</h3>

<p>This method selects dose by the algorithm for identifying the maximum
tolerable dose (MTD) described in Ji et al. (2010). This class is intended
to be used when a mTPI trial has reached its maximum sample size. Thus, it
intends to make the final dose recommendation after the regular mTPI dose
selection algorithm, as implemented by <code><a href="#topic+get_mtpi">get_mtpi</a></code>, including any
additional behaviours that govern stopping (etc), has gracefully concluded a
dose-finding trial. However, the class can be used in any scenario where
there is a target toxicity rate. See Examples. Note - this class will not
override the parent dose selector when the parent is advocating no dose. Thus
this class will not reinstate a dangerous dose.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>select_mtpi_mtd(
  parent_selector_factory,
  when = c("finally", "always"),
  target = NULL,
  exclusion_certainty,
  alpha = 1,
  beta = 1,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="select_mtpi_mtd_+3A_parent_selector_factory">parent_selector_factory</code></td>
<td>
<p>Object of type <code><a href="#topic+selector_factory">selector_factory</a></code>.</p>
</td></tr>
<tr><td><code id="select_mtpi_mtd_+3A_when">when</code></td>
<td>
<p>Either of: 'finally' to select dose only when the parent
dose-selector has finished, by returning continue() == FALSE; or 'always'
to use this dose-selection algorithm for every dose decision. As per the
authors' original intentions, the default is 'finally'.</p>
</td></tr>
<tr><td><code id="select_mtpi_mtd_+3A_target">target</code></td>
<td>
<p>We seek a dose with this probability of toxicity. If not
provided, the value will be sought from the parent dose-selector.</p>
</td></tr>
<tr><td><code id="select_mtpi_mtd_+3A_exclusion_certainty">exclusion_certainty</code></td>
<td>
<p>Numeric, threshold posterior certainty required to
exclude a dose for being excessively toxic. The authors discuss values in the
range 0.7 - 0.95. Set to a value &gt; 1 to suppress the dose exclusion
mechanism. The authors use the Greek letter xi for this parameter.</p>
</td></tr>
<tr><td><code id="select_mtpi_mtd_+3A_alpha">alpha</code></td>
<td>
<p>First shape parameter of the beta prior distribution on the
probability of toxicity.</p>
</td></tr>
<tr><td><code id="select_mtpi_mtd_+3A_beta">beta</code></td>
<td>
<p>Second shape parameter of the beta prior distribution on the
probability of toxicity.</p>
</td></tr>
<tr><td><code id="select_mtpi_mtd_+3A_...">...</code></td>
<td>
<p>Extra args are passed onwards.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of type <code><a href="#topic+selector_factory">selector_factory</a></code>.
</p>


<h3>References</h3>

<p>Ji, Y., Liu, P., Li, Y., &amp; Bekele, B. N. (2010).
A modified toxicity probability interval method for dose-finding trials.
Clinical Trials, 7(6), 653-663. https://doi.org/10.1177/1740774510382799
</p>
<p>Ji, Y., &amp; Yang, S. (2017).
On the Interval-Based Dose-Finding Designs, 1-26.
Retrieved from https://arxiv.org/abs/1706.03277
</p>


<h3>Examples</h3>

<pre><code class='language-R'># This class is intended to make the final dose selection in a mTPI trial:
target &lt;- 0.25
model &lt;- get_mtpi(num_doses = 5, target = target,
                  epsilon1 = 0.05, epsilon2 = 0.05,
                  exclusion_certainty = 0.95) %&gt;%
  stop_at_n(n = 12) %&gt;%
  select_mtpi_mtd(exclusion_certainty = 0.95)

outcomes &lt;- '1NNN 2NTN 2NNN 3NTT'
model %&gt;% fit(outcomes) %&gt;% recommended_dose()

# However, since behaviour is modular in this package, we can use this method
# to select dose at every dose decision if we wanted:
model2 &lt;- get_mtpi(num_doses = 5, target = target,
                   epsilon1 = 0.05, epsilon2 = 0.05,
                   exclusion_certainty = 0.95) %&gt;%
  select_mtpi_mtd(when = 'always', exclusion_certainty = 0.95)
model2 %&gt;% fit('1NNT') %&gt;% recommended_dose()
model2 %&gt;% fit('1NNN 2NNT') %&gt;% recommended_dose()

# and with any underlying model:
skeleton &lt;- c(0.05, 0.1, 0.25, 0.4, 0.6)
model3 &lt;- get_dfcrm(skeleton = skeleton, target = target) %&gt;%
  select_mtpi_mtd(when = 'always', exclusion_certainty = 0.95)
model3 %&gt;% fit('1NNT') %&gt;% recommended_dose()
model3 %&gt;% fit('1NNN 2NNT') %&gt;% recommended_dose()

</code></pre>

<hr>
<h2 id='select_mtpi2_mtd'>Select dose by mTPI2's MTD-choosing algorithm.</h2><span id='topic+select_mtpi2_mtd'></span>

<h3>Description</h3>

<p>This method selects dose by the algorithm for identifying the maximum
tolerable dose (MTD) described in Guo et al. (2017). This class is intended
to be used when a mTPI2 trial has reached its maximum sample size. Thus, it
intends to make the final dose recommendation after the regular mTPI2 dose
selection algorithm, as implemented by <code><a href="#topic+get_mtpi2">get_mtpi2</a></code>, including any
additional behaviours that govern stopping (etc), has gracefully concluded a
dose-finding trial. However, the class can be used in any scenario where
there is a target toxicity rate. See Examples. Note - this class will not
override the parent dose selector when the parent is advocating no dose. Thus
this class will not reinstate a dangerous dose.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>select_mtpi2_mtd(
  parent_selector_factory,
  when = c("finally", "always"),
  target = NULL,
  exclusion_certainty,
  alpha = 1,
  beta = 1,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="select_mtpi2_mtd_+3A_parent_selector_factory">parent_selector_factory</code></td>
<td>
<p>Object of type <code><a href="#topic+selector_factory">selector_factory</a></code>.</p>
</td></tr>
<tr><td><code id="select_mtpi2_mtd_+3A_when">when</code></td>
<td>
<p>Either of: 'finally' to select dose only when the parent
dose-selector has finished, by returning continue() == FALSE; or 'always'
to use this dose-selection algorithm for every dose decision. As per the
authors' original intentions, the default is 'finally'.</p>
</td></tr>
<tr><td><code id="select_mtpi2_mtd_+3A_target">target</code></td>
<td>
<p>We seek a dose with this probability of toxicity. If not
provided, the value will be sought from the parent dose-selector.</p>
</td></tr>
<tr><td><code id="select_mtpi2_mtd_+3A_exclusion_certainty">exclusion_certainty</code></td>
<td>
<p>Numeric, threshold posterior certainty required to
exclude a dose for being excessively toxic. The authors discuss values in the
range 0.7 - 0.95. Set to a value &gt; 1 to suppress the dose exclusion
mechanism. The authors use the Greek letter xi for this parameter.</p>
</td></tr>
<tr><td><code id="select_mtpi2_mtd_+3A_alpha">alpha</code></td>
<td>
<p>First shape parameter of the beta prior distribution on the
probability of toxicity.</p>
</td></tr>
<tr><td><code id="select_mtpi2_mtd_+3A_beta">beta</code></td>
<td>
<p>Second shape parameter of the beta prior distribution on the
probability of toxicity.</p>
</td></tr>
<tr><td><code id="select_mtpi2_mtd_+3A_...">...</code></td>
<td>
<p>Extra args are passed onwards.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of type <code><a href="#topic+selector_factory">selector_factory</a></code>.
</p>


<h3>References</h3>

<p>Guo, W., Wang, SJ., Yang, S., Lynn, H., Ji, Y. (2017).
A Bayesian Interval Dose-Finding Design Addressing Ockham's Razor: mTPI-2.
https://doi.org/10.1016/j.cct.2017.04.006
</p>


<h3>Examples</h3>

<pre><code class='language-R'># This class is intended to make the final dose selection in a mTPI2 trial:
target &lt;- 0.25
model &lt;- get_mtpi2(num_doses = 5, target = target,
                   epsilon1 = 0.05, epsilon2 = 0.05,
                   exclusion_certainty = 0.95) %&gt;%
  stop_at_n(n = 12) %&gt;%
  select_mtpi2_mtd(exclusion_certainty = 0.95)

outcomes &lt;- '1NNN 2NTN 2NNN 3NTT'
model %&gt;% fit(outcomes) %&gt;% recommended_dose()

# However, since behaviour is modular in this package, we can use this method
# to select dose at every dose decision if we wanted:
model2 &lt;- get_mtpi2(num_doses = 5, target = target,
                    epsilon1 = 0.05, epsilon2 = 0.05,
                    exclusion_certainty = 0.95) %&gt;%
  select_mtpi2_mtd(when = 'always', exclusion_certainty = 0.95)
model2 %&gt;% fit('1NNT') %&gt;% recommended_dose()
model2 %&gt;% fit('1NNN 2NNT') %&gt;% recommended_dose()

# and with any underlying model:
skeleton &lt;- c(0.05, 0.1, 0.25, 0.4, 0.6)
model3 &lt;- get_dfcrm(skeleton = skeleton, target = target) %&gt;%
  select_mtpi2_mtd(when = 'always', exclusion_certainty = 0.95)
model3 %&gt;% fit('1NNT') %&gt;% recommended_dose()
model3 %&gt;% fit('1NNN 2NNT') %&gt;% recommended_dose()

</code></pre>

<hr>
<h2 id='select_tpi_mtd'>Select dose by TPI's MTD-choosing algorithm.</h2><span id='topic+select_tpi_mtd'></span>

<h3>Description</h3>

<p>This method selects dose by the algorithm for identifying the maximum
tolerable dose (MTD) described in Ji et al. (2007). This class is intended
to be used when a TPI trial has reached its maximum sample size. Thus, it
intends to make the final dose recommendation after the regular TPI dose
selection algorithm, as implemented by <code><a href="#topic+get_tpi">get_tpi</a></code>, including any
additional behaviours that govern stopping (etc), has gracefully concluded a
dose-finding trial. However, the class can be used in any scenario where
there is a target toxicity rate. See Examples. Note - this class will not
override the parent dose selector when the parent is advocating no dose. Thus
this class will not reinstate a dangerous dose.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>select_tpi_mtd(
  parent_selector_factory,
  when = c("finally", "always"),
  target = NULL,
  exclusion_certainty,
  alpha = 1,
  beta = 1,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="select_tpi_mtd_+3A_parent_selector_factory">parent_selector_factory</code></td>
<td>
<p>Object of type <code><a href="#topic+selector_factory">selector_factory</a></code>.</p>
</td></tr>
<tr><td><code id="select_tpi_mtd_+3A_when">when</code></td>
<td>
<p>Either of: 'finally' to select dose only when the parent
dose-selector has finished, by returning continue() == FALSE; or 'always'
to use this dose-selection algorithm for every dose decision. As per the
authors' original intentions, the default is 'finally'.</p>
</td></tr>
<tr><td><code id="select_tpi_mtd_+3A_target">target</code></td>
<td>
<p>We seek a dose with this probability of toxicity. If not
provided, the value will be sought from the parent dose-selector.</p>
</td></tr>
<tr><td><code id="select_tpi_mtd_+3A_exclusion_certainty">exclusion_certainty</code></td>
<td>
<p>Numeric, threshold posterior certainty required to
exclude a dose for being excessively toxic. The authors discuss values in the
range 0.7 - 0.95. Set to a value &gt; 1 to suppress the dose exclusion
mechanism. The authors use the Greek letter xi for this parameter.</p>
</td></tr>
<tr><td><code id="select_tpi_mtd_+3A_alpha">alpha</code></td>
<td>
<p>First shape parameter of the beta prior distribution on the
probability of toxicity.</p>
</td></tr>
<tr><td><code id="select_tpi_mtd_+3A_beta">beta</code></td>
<td>
<p>Second shape parameter of the beta prior distribution on the
probability of toxicity.</p>
</td></tr>
<tr><td><code id="select_tpi_mtd_+3A_...">...</code></td>
<td>
<p>Extra args are passed onwards.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of type <code><a href="#topic+selector_factory">selector_factory</a></code>.
</p>


<h3>References</h3>

<p>Ji, Y., Li, Y., &amp; Bekele, B. N. (2007).
Dose-finding in phase I clinical trials based on toxicity probability
intervals.
Clinical Trials, 4(3), 235244. https://doi.org/10.1177/1740774507079442
</p>


<h3>Examples</h3>

<pre><code class='language-R'># This class is intended to make the final dose selection in a mTPI2 trial:
target &lt;- 0.25
model &lt;- get_tpi(num_doses = 5, target = target,
                 k1 = 1, k2 = 1.5,
                 exclusion_certainty = 0.95) %&gt;%
  stop_at_n(n = 12) %&gt;%
  select_tpi_mtd(exclusion_certainty = 0.95)

outcomes &lt;- '1NNN 2NTN 2NNN 3NTT'
model %&gt;% fit(outcomes) %&gt;% recommended_dose()

# However, since behaviour is modular in this package, we can use this method
# to select dose at every dose decision if we wanted:
model2 &lt;- get_tpi(num_doses = 5, target = target,
                  k1 = 1, k2 = 1.5,
                  exclusion_certainty = 0.95) %&gt;%
  select_tpi_mtd(when = 'always', exclusion_certainty = 0.95)
model2 %&gt;% fit('1NNT') %&gt;% recommended_dose()
model2 %&gt;% fit('1NNN 2NNT') %&gt;% recommended_dose()

# and with any underlying model:
skeleton &lt;- c(0.05, 0.1, 0.25, 0.4, 0.6)
model3 &lt;- get_dfcrm(skeleton = skeleton, target = target) %&gt;%
  select_tpi_mtd(when = 'always', exclusion_certainty = 0.95)
model3 %&gt;% fit('1NNT') %&gt;% recommended_dose()
model3 %&gt;% fit('1NNN 2NNT') %&gt;% recommended_dose()

</code></pre>

<hr>
<h2 id='selector'>Dose selector.</h2><span id='topic+selector'></span>

<h3>Description</h3>

<p>This is a core class in this package. It encapsulates that an object (e.g. a
CRM model, a 3+3 model) is able to recommend doses, keep track of how many
patients have been treated at what doses, what toxicity outcomes have been
seen, and whether a trial should continue. It offers a consistent interface
to many dose-finding methods, including CRM, TPI, mTPI, BOIN, EffTox, 3+3,
and more.
</p>
<p>Once you have a standardised interface, modularisation offers a powerful way
to adorn dose-finding methods with extra desirable behaviour. <code>selector</code>
objects can be daisy-chained togther using <code>magrittr</code>'s pipe operator.
For instance, the CRM fitting method in <code>dfcrm</code> is fantastic because it
runs quickly and is simple to call. However, it does not recommend that a
trial stops if a dose is too toxic or if n patients have already been treated
at the recommended dose. Each of these behaviours can be bolted on via
additional selectors. Furthermore, those behaviours and more can be bolted
on to any dose selector because of the modular approach implemented in
<code>escalation</code>. See Examples.
</p>
<p><code>selector</code> objects are obtained by calling the <code><a href="#topic+fit">fit</a></code>
function on a <code><a href="#topic+selector_factory">selector_factory</a></code> object.
A <code><a href="#topic+selector_factory">selector_factory</a></code> object is obtained by initially calling a
function like <code><a href="#topic+get_dfcrm">get_dfcrm</a></code>, <code><a href="#topic+get_three_plus_three">get_three_plus_three</a></code> or
<code><a href="#topic+get_boin">get_boin</a></code>. Users may then add desired extra behaviour with
subsequent calls to functions like <code><a href="#topic+stop_when_n_at_dose">stop_when_n_at_dose</a></code> or
<code><a href="#topic+stop_when_too_toxic">stop_when_too_toxic</a></code>.
</p>
<p>The <code>selector</code> class also supports that an object will be able to
perform inferential calculations on the rates of toxicity via functions like
<code><a href="#topic+mean_prob_tox">mean_prob_tox</a></code>, <code><a href="#topic+median_prob_tox">median_prob_tox</a></code>, and
<code><a href="#topic+prob_tox_exceeds">prob_tox_exceeds</a></code>. However, naturally the sophistication of
those calculations will vary by model implementation. For example, a full
MCMC method will be able to quantify any probability you like by working with
posterior samples. In contrast, a method like the <code><a href="dfcrm.html#topic+crm">crm</a></code>
function in <code>dfcrm</code> that uses the plug-in method to estimate posterior
dose-toxicity curves cannot natively estimate the median probability of tox.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>selector()
</code></pre>


<h3>Details</h3>

<p>Every <code>selector</code> object implements the following functions:
</p>

<ul>
<li> <p><code><a href="#topic+tox_target">tox_target</a></code>
</p>
</li>
<li> <p><code><a href="#topic+num_patients">num_patients</a></code>
</p>
</li>
<li> <p><code><a href="#topic+cohort">cohort</a></code>
</p>
</li>
<li> <p><code><a href="#topic+doses_given">doses_given</a></code>
</p>
</li>
<li> <p><code><a href="#topic+tox">tox</a></code>
</p>
</li>
<li> <p><code><a href="#topic+num_tox">num_tox</a></code>
</p>
</li>
<li> <p><code><a href="#topic+model_frame">model_frame</a></code>
</p>
</li>
<li> <p><code><a href="#topic+num_doses">num_doses</a></code>
</p>
</li>
<li> <p><code><a href="#topic+dose_indices">dose_indices</a></code>
</p>
</li>
<li> <p><code><a href="#topic+recommended_dose">recommended_dose</a></code>
</p>
</li>
<li> <p><code><a href="#topic+continue">continue</a></code>
</p>
</li>
<li> <p><code><a href="#topic+n_at_dose">n_at_dose</a></code>
</p>
</li>
<li> <p><code><a href="#topic+n_at_recommended_dose">n_at_recommended_dose</a></code>
</p>
</li>
<li> <p><code><a href="#topic+is_randomising">is_randomising</a></code>
</p>
</li>
<li> <p><code><a href="#topic+prob_administer">prob_administer</a></code>
</p>
</li>
<li> <p><code><a href="#topic+tox_at_dose">tox_at_dose</a></code>
</p>
</li>
<li> <p><code><a href="#topic+empiric_tox_rate">empiric_tox_rate</a></code>
</p>
</li>
<li> <p><code><a href="#topic+mean_prob_tox">mean_prob_tox</a></code>
</p>
</li>
<li> <p><code><a href="#topic+median_prob_tox">median_prob_tox</a></code>
</p>
</li>
<li> <p><code><a href="#topic+dose_admissible">dose_admissible</a></code>
</p>
</li>
<li> <p><code><a href="#topic+prob_tox_quantile">prob_tox_quantile</a></code>
</p>
</li>
<li> <p><code><a href="#topic+prob_tox_exceeds">prob_tox_exceeds</a></code>
</p>
</li>
<li> <p><code><a href="#topic+supports_sampling">supports_sampling</a></code>
</p>
</li>
<li> <p><code><a href="#topic+prob_tox_samples">prob_tox_samples</a></code>
</p>
</li></ul>

<p>Some selectors also add:
</p>

<ul>
<li> <p><code><a href="#topic+tox_limit">tox_limit</a></code>
</p>
</li>
<li> <p><code><a href="#topic+eff_limit">eff_limit</a></code>
</p>
</li>
<li> <p><code><a href="#topic+eff">eff</a></code>
</p>
</li>
<li> <p><code><a href="#topic+num_eff">num_eff</a></code>
</p>
</li>
<li> <p><code><a href="#topic+eff_at_dose">eff_at_dose</a></code>
</p>
</li>
<li> <p><code><a href="#topic+empiric_eff_rate">empiric_eff_rate</a></code>
</p>
</li>
<li> <p><code><a href="#topic+mean_prob_eff">mean_prob_eff</a></code>
</p>
</li>
<li> <p><code><a href="#topic+median_prob_eff">median_prob_eff</a></code>
</p>
</li>
<li> <p><code><a href="#topic+prob_eff_quantile">prob_eff_quantile</a></code>
</p>
</li>
<li> <p><code><a href="#topic+prob_eff_exceeds">prob_eff_exceeds</a></code>
</p>
</li>
<li> <p><code><a href="#topic+prob_eff_samples">prob_eff_samples</a></code>
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+selector_factory">selector_factory</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Start with a simple CRM model
skeleton &lt;- c(0.05, 0.1, 0.25, 0.4, 0.6)
target &lt;- 0.25
model1 &lt;- get_dfcrm(skeleton = skeleton, target = target)

# Add a rule to stop when 9 patients are treated at the recommended dose
model2 &lt;- get_dfcrm(skeleton = skeleton, target = target) %&gt;%
  stop_when_n_at_dose(n = 9, dose = 'recommended')

# Add a rule to stop if toxicity rate at lowest dose likely exceeds target
model3 &lt;- get_dfcrm(skeleton = skeleton, target = target) %&gt;%
  stop_when_n_at_dose(n = 9, dose = 'recommended') %&gt;%
  stop_when_too_toxic(dose = 1, tox_threshold = target, confidence = 0.5)

# We now have three CRM models that differ in their stopping behaviour.
# Let's fit each to some outcomes to see those differences:

outcomes &lt;- '1NNN 2NTT 1NNT'
fit1 &lt;- model1 %&gt;% fit(outcomes)
fit2 &lt;- model2 %&gt;% fit(outcomes)
fit3 &lt;- model3 %&gt;% fit(outcomes)

fit1 %&gt;% recommended_dose()
fit1 %&gt;% continue()

fit2 %&gt;% recommended_dose()
fit2 %&gt;% continue()

fit3 %&gt;% recommended_dose()
fit3 %&gt;% continue()
# Already model3 wants to stop because of excessive toxicity.

# Let's carry on with models 1 and 2 by adding another cohort:

outcomes &lt;- '1NNN 2NTT 1NNT 1NNN'
fit1 &lt;- model1 %&gt;% fit(outcomes)
fit2 &lt;- model2 %&gt;% fit(outcomes)

fit1 %&gt;% recommended_dose()
fit1 %&gt;% continue()

fit2 %&gt;% recommended_dose()
fit2 %&gt;% continue()

# Model1 wants to continue - in fact it will never stop.
# In contrast, model2 has seen 9 at dose 1 so, rather than suggest dose 1
# again, it suggests the trial should stop.

# For contrast, let us consider a BOIN model on the same outcomes
boin_fitter &lt;- get_boin(num_doses = length(skeleton), target = target)
fit4 &lt;- boin_fitter %&gt;% fit(outcomes)
fit4 %&gt;% recommended_dose()
fit4 %&gt;% continue()

# Full selector interface:
fit &lt;- fit2
fit %&gt;% tox_target()
fit %&gt;% num_patients()
fit %&gt;% cohort()
fit %&gt;% doses_given()
fit %&gt;% tox()
fit %&gt;% num_tox()
fit %&gt;% model_frame()
fit %&gt;% num_doses()
fit %&gt;% dose_indices()
fit %&gt;% recommended_dose()
fit %&gt;% continue()
fit %&gt;% n_at_dose()
fit %&gt;% n_at_recommended_dose()
fit %&gt;% is_randomising()
fit %&gt;% prob_administer()
fit %&gt;% tox_at_dose()
fit %&gt;% empiric_tox_rate()
fit %&gt;% mean_prob_tox()
fit %&gt;% median_prob_tox()
fit %&gt;% dose_admissible()
fit %&gt;% prob_tox_quantile(0.9)
fit %&gt;% prob_tox_exceeds(0.5)
fit %&gt;% supports_sampling()
fit %&gt;% prob_tox_samples()
</code></pre>

<hr>
<h2 id='selector_factory'>Dose selector factory.</h2><span id='topic+selector_factory'></span>

<h3>Description</h3>

<p>Along with <code><a href="#topic+selector">selector</a></code>, this is the second core class in the
<code>escalation</code> package. It exists to do one thing: fit outcomes from
dose-finding trials to the models we use to select doses.
</p>
<p>A <code><a href="#topic+selector_factory">selector_factory</a></code> object is obtained by initially calling a
function like <code><a href="#topic+get_dfcrm">get_dfcrm</a></code>, <code><a href="#topic+get_three_plus_three">get_three_plus_three</a></code> or
<code><a href="#topic+get_boin">get_boin</a></code>. Users may then add desired extra behaviour with
subsequent calls to functions like <code><a href="#topic+stop_when_n_at_dose">stop_when_n_at_dose</a></code> or
<code><a href="#topic+stop_when_too_toxic">stop_when_too_toxic</a></code>.
<code>selector</code> objects are obtained by calling the <code><a href="#topic+fit">fit</a></code>
function on a <code><a href="#topic+selector_factory">selector_factory</a></code> object. Refer to examples to see
how this works.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>selector_factory()
</code></pre>


<h3>See Also</h3>

<p><code><a href="#topic+selector">selector</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Start with a simple CRM model
skeleton &lt;- c(0.05, 0.1, 0.25, 0.4, 0.6)
target &lt;- 0.25
model1 &lt;- get_dfcrm(skeleton = skeleton, target = target)

# Add a rule to stop when 9 patients are treated at the recommended dose
model2 &lt;- get_dfcrm(skeleton = skeleton, target = target) %&gt;%
  stop_when_n_at_dose(n = 9, dose = 'recommended')

# Add a rule to stop if toxicity rate at lowest dose likely exceeds target
model3 &lt;- get_dfcrm(skeleton = skeleton, target = target) %&gt;%
  stop_when_n_at_dose(n = 9, dose = 'recommended') %&gt;%
  stop_when_too_toxic(dose = 1, tox_threshold = target, confidence = 0.5)

# We now have three CRM models that differ in their stopping behaviour.
# Let's fit each to some outcomes to see those differences:

outcomes &lt;- '1NNN 2NTT 1NNT'
fit1 &lt;- model1 %&gt;% fit(outcomes)
fit2 &lt;- model2 %&gt;% fit(outcomes)
fit3 &lt;- model3 %&gt;% fit(outcomes)

fit1 %&gt;% recommended_dose()
fit1 %&gt;% continue()

fit2 %&gt;% recommended_dose()
fit2 %&gt;% continue()

fit3 %&gt;% recommended_dose()
fit3 %&gt;% continue()
# Already model3 wants to stop because of excessive toxicity.

# Let's carry on with models 1 and 2 by adding another cohort:

outcomes &lt;- '1NNN 2NTT 1NNT 1NNN'
fit1 &lt;- model1 %&gt;% fit(outcomes)
fit2 &lt;- model2 %&gt;% fit(outcomes)

fit1 %&gt;% recommended_dose()
fit1 %&gt;% continue()

fit2 %&gt;% recommended_dose()
fit2 %&gt;% continue()

# Model1 wants to continue - in fact it will never stop.
# In contrast, model2 has seen 9 at dose 1 so, rather than suggest dose 1
# again, it suggests the trial should stop.

# For contrast, let us consider a BOIN model on the same outcomes
boin_fitter &lt;- get_boin(num_doses = length(skeleton), target = target)
fit4 &lt;- boin_fitter %&gt;% fit(outcomes)
fit4 %&gt;% recommended_dose()
fit4 %&gt;% continue()
</code></pre>

<hr>
<h2 id='simulate_compare'>Simulate clinical trials for several designs using common patients.</h2><span id='topic+simulate_compare'></span>

<h3>Description</h3>

<p>This function takes a list of several
<code><a href="#topic+selector_factory">selector_factory</a></code>s, such as those returned by
<code><a href="#topic+get_dfcrm">get_dfcrm</a></code>, <code><a href="#topic+get_boin">get_boin</a></code> or
<code><a href="#topic+get_three_plus_three">get_three_plus_three</a></code>, and conducts many notional clinical
trials. The simulated patients in the trials are common across designs. For
example, in a comparison of the three designs mentioned above, the first
simulated CRM trial uses the same notional patients as the first simulated
BOIN trial, etc. Using common patients within iterate across designs
reduces MCMC errors of comparisons, so this method is efficient for
comparing designs. See Sweeting et al. for full details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulate_compare(
  designs,
  num_sims,
  true_prob_tox,
  true_prob_eff = NULL,
  patient_samples = NULL,
  rho = NULL,
  return_patient_samples = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simulate_compare_+3A_designs">designs</code></td>
<td>
<p>list, mapping design names to objects of type
<code><a href="#topic+selector_factory">selector_factory</a></code>.</p>
</td></tr>
<tr><td><code id="simulate_compare_+3A_num_sims">num_sims</code></td>
<td>
<p>integer, number of trial iterations to simulate.</p>
</td></tr>
<tr><td><code id="simulate_compare_+3A_true_prob_tox">true_prob_tox</code></td>
<td>
<p>numeric vector of true but unknown toxicity
probabilities</p>
</td></tr>
<tr><td><code id="simulate_compare_+3A_true_prob_eff">true_prob_eff</code></td>
<td>
<p>numeric vector of true but unknown efficacy
probabilities. NULL if efficacy not analysed.</p>
</td></tr>
<tr><td><code id="simulate_compare_+3A_patient_samples">patient_samples</code></td>
<td>
<p>Optional list of length <code>num_sims</code>, where each
element is an instance of <code><a href="#topic+PatientSample">PatientSample</a></code> or a subclass like
<code><a href="#topic+CorrelatedPatientSample">CorrelatedPatientSample</a></code>. These objects control the occurrence
of toxicity and efficacy events in patients. They are specifiable to allow
fine-grained control to users. See the vignette on Simulation.</p>
</td></tr>
<tr><td><code id="simulate_compare_+3A_rho">rho</code></td>
<td>
<p>Optional correlation between -1 and 1 for the latent uniform
variables that determine toxicity and efficacy events. Non-correlated events
is the default.</p>
</td></tr>
<tr><td><code id="simulate_compare_+3A_return_patient_samples">return_patient_samples</code></td>
<td>
<p>TRUE to get the list of patient sample objects
returned in the patient_samples attribute of the retured object.</p>
</td></tr>
<tr><td><code id="simulate_compare_+3A_...">...</code></td>
<td>
<p>Extra args are passed onwards.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>By default, dose decisions in simulated trials are made after each
cohort of 3 patients. This can be changed by providing a function by the
<code>sample_patient_arrivals</code> parameter that simulates the arrival of new
patients. The new patients will be added to the existing patients and the
model will be fit to the set of all patients. The function that simulates
patient arrivals should take as a single parameter a data-frame with one
row for each existing patient and columns including cohort, patient, dose,
tox, time (and possibly also eff and weight, if a phase I/II or
time-to-event method is used). The provision of data on the existing
patients allows the patient sampling function to be adaptive. The function
should return a data-frame with a row for each new patient and a column for
time_delta, the time between the arrival of this patient and the previous,
as in <code><a href="#topic+cohorts_of_n">cohorts_of_n</a></code>. See Examples.
</p>
<p>This method can simulate the culmination of trials that are partly
completed. We just have to specify the outcomes already observed via the
<code>previous_outcomes</code> parameter. Each simulated trial will commence from
those outcomes seen thus far. See Examples.
</p>
<p>We can specify the immediate next dose by specifying <code>next_dose</code>. If
omitted, the next dose is calculated by invoking the model on the outcomes
seen thus far.
</p>
<p>Designs must eventually choose to stop the trial. Some designs, like 3+3,
have intrinsic stopping rules. However, some selectors like those derived
from <code><a href="#topic+get_dfcrm">get_dfcrm</a></code> offer no default stopping method. You may need
to append stopping behaviour to your selector via something like
<code><a href="#topic+stop_at_n">stop_at_n</a></code> or <code><a href="#topic+stop_when_n_at_dose">stop_when_n_at_dose</a></code>, etc. To
safeguard against simulating runaway trials that never end, the function
will halt a simulated trial after 30 invocations of the dose-selection
decision. To breach this limit, specify <code>i_like_big_trials = TRUE</code> in
the function call. However, when you forego the safety net, the onus is on
you to write selectors that will eventually stop the trial! See Examples.
</p>
<p>The model is fit to the prevailing data at each dose selection point. By
default, only the final model fit for each simulated trial is retained.
This is done to conserve memory. With a high number of simulated trials,
storing many model fits per trial may cause the executing machine to run
out of memory. However, you can force this method to retain all model fits
by specifying <code>return_all_fits = TRUE</code>. See Examples.
</p>


<h3>Value</h3>

<p>object of type <code><a href="#topic+simulations_collection">simulations_collection</a></code>
</p>


<h3>References</h3>

<p>Sweeting, M., Slade, D., Jackson, D., Brock, K. (2023)
Potential outcome simulation for efficient head-to-head comparison of
adaptive dose-finding designs. Preprint.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+simulations">simulations</a></code>
</p>
<p><code><a href="#topic+selector_factory">selector_factory</a></code>
</p>
<p><code><a href="#topic+get_dfcrm">get_dfcrm</a></code>
</p>
<p><code><a href="#topic+get_boin">get_boin</a></code>
</p>
<p><code><a href="#topic+get_three_plus_three">get_three_plus_three</a></code>
</p>
<p><code><a href="#topic+cohorts_of_n">cohorts_of_n</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Don't run on build because they exceed CRAN time limit

# In a five-dose scenario, we have assumed probabilities for Prob(tox):
true_prob_tox &lt;- c(0.05, 0.10, 0.15, 0.18, 0.45)
# and Prov(eff):
true_prob_eff &lt;- c(0.40, 0.50, 0.52, 0.53, 0.53)

# Let us compare two BOIN12 variants that differ in their stopping params:
designs &lt;- list(
  "BOIN12 v1" = get_boin12(num_doses = 5,
                           phi_t = 0.35, phi_e = 0.25,
                           u2 = 40, u3 = 60,
                           c_t = 0.95, c_e = 0.9) %&gt;%
    stop_at_n(n = 36),
  "BOIN12 v2" = get_boin12(num_doses = 5,
                           phi_t = 0.35, phi_e = 0.25,
                           u2 = 40, u3 = 60,
                           c_t = 0.5, c_e = 0.5) %&gt;%
    stop_at_n(n = 36)
)
# For illustration we run only 10 iterates:
x &lt;- simulate_compare(
  designs,
  num_sims = 10,
  true_prob_tox,
  true_prob_eff
)
# To compare toxicity-only designs like CRM etc, we would omit true_prob_eff.

# We might be interested in the absolute dose recommendation probabilities:
convergence_plot(x)

library(dplyr)
library(ggplot2)
# and, perhaps more importantly, how they compare:
as_tibble(x) %&gt;%
  ggplot(aes(x = n, y = delta)) +
  geom_point(size = 0.4) +
  geom_linerange(aes(ymin = delta_l, ymax = delta_u)) +
  geom_hline(yintercept = 0, linetype = "dashed", col = "red") +
  facet_grid(comparison ~ dose,
    labeller = labeller(
      .rows = label_both,
      .cols = label_both)
  )

# Simulations for each design are available by name:
sims &lt;- x$`BOIN12 v1`
# And the usual functions are available on the sims objects:
sims %&gt;% num_patients()
sims %&gt;% num_doses()
sims %&gt;% dose_indices()
sims %&gt;% n_at_dose()
# etc
# See ? simulate_trials

# As with simulate_trials, which examines one design, we also have options to
# tweak the simulation process.

# By default, dose decisions are made after each cohort of 3 patients. To
# override, specify an alternative function via the sample_patient_arrivals
# parameter. E.g. to use cohorts of 2, we run:
patient_arrivals_func &lt;- function(current_data) cohorts_of_n(n = 2)
x &lt;- simulate_compare(
  designs,
  num_sims = 10,
  true_prob_tox,
  true_prob_eff,
  sample_patient_arrivals = patient_arrivals_func
)

# To simulate the culmination of trials that are partly completed, specify
# the outcomes already observed via the previous_outcomes parameter. Imagine
# one cohort has already been evaluated, returning outcomes 1NTN. We can
# simulate the remaining part of that trial with:
x &lt;- simulate_compare(
  designs,
  num_sims = 10,
  true_prob_tox,
  true_prob_eff,
  previous_outcomes = '1NTN'
)

# Outcomes can be described by the above outcome string method or data-frame:
previous_outcomes &lt;- data.frame(
  patient = 1:3,
  cohort = c(1, 1, 1),
  tox = c(0, 1, 0),
  eff = c(1, 1, 0),
  dose = c(1, 1, 1)
)
x &lt;- simulate_compare(
  designs,
  num_sims = 10,
  true_prob_tox,
  true_prob_eff,
  previous_outcomes = previous_outcomes
)

# We can specify the immediate next dose:
x &lt;- simulate_compare(
  designs,
  num_sims = 10,
  true_prob_tox,
  true_prob_eff,
  next_dose = 5
)

# By default, the method will stop simulated trials after 30 dose selections.
# To suppress this, specify i_like_big_trials = TRUE. However, please take
# care to specify selectors that will eventually stop! Our designs above use
# stop_at_n so they will not proceed ad infinitum.
x &lt;- simulate_compare(
  designs,
  num_sims = 10,
  true_prob_tox,
  true_prob_eff,
  i_like_big_trials = TRUE
)

# By default, only the final model fit is retained for each simulated trial.
# To retain all interim model fits, specify return_all_fits = TRUE.
x &lt;- simulate_compare(
  designs,
  num_sims = 10,
  true_prob_tox,
  true_prob_eff,
  return_all_fits = TRUE
)

## End(Not run)

</code></pre>

<hr>
<h2 id='simulate_trials'>Simulate clinical trials.</h2><span id='topic+simulate_trials'></span>

<h3>Description</h3>

<p>This function takes a <code><a href="#topic+selector_factory">selector_factory</a></code>, such as
that returned by <code><a href="#topic+get_dfcrm">get_dfcrm</a></code>, <code><a href="#topic+get_boin">get_boin</a></code> or
<code><a href="#topic+get_three_plus_three">get_three_plus_three</a></code>, and conducts many notional clinical
trials. We conduct simulations to learn about the operating characteristics
of adaptive trial designs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulate_trials(
  selector_factory,
  num_sims,
  true_prob_tox,
  true_prob_eff = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simulate_trials_+3A_selector_factory">selector_factory</code></td>
<td>
<p>Object of type <code><a href="#topic+selector_factory">selector_factory</a></code>.</p>
</td></tr>
<tr><td><code id="simulate_trials_+3A_num_sims">num_sims</code></td>
<td>
<p>integer, number of trial iterations to simulate.</p>
</td></tr>
<tr><td><code id="simulate_trials_+3A_true_prob_tox">true_prob_tox</code></td>
<td>
<p>numeric vector of true but unknown toxicity
probabilities</p>
</td></tr>
<tr><td><code id="simulate_trials_+3A_true_prob_eff">true_prob_eff</code></td>
<td>
<p>numeric vector of true but unknown efficacy
probabilities. NULL if efficacy not analysed.</p>
</td></tr>
<tr><td><code id="simulate_trials_+3A_...">...</code></td>
<td>
<p>Extra args are passed onwards.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>By default, dose decisions in simulated trials are made after each
cohort of 3 patients. This can be changed by providing a function by the
<code>sample_patient_arrivals</code> parameter that simulates the arrival of new
patients. The new patients will be added to the existing patients and the
model will be fit to the set of all patients. The function that simulates
patient arrivals should take as a single parameter a data-frame with one
row for each existing patient and columns including cohort, patient, dose,
tox, time (and possibly also eff and weight, if a phase I/II or
time-to-event method is used). The provision of data on the existing
patients allows the patient sampling function to be adaptive. The function
should return a data-frame with a row for each new patient and a column for
time_delta, the time between the arrival of this patient and the previous,
as in <code><a href="#topic+cohorts_of_n">cohorts_of_n</a></code>. See Examples.
</p>
<p>This method can simulate the culmination of trials that are partly
completed. We just have to specify the outcomes already observed via the
<code>previous_outcomes</code> parameter. Each simulated trial will commence from
those outcomes seen thus far. See Examples.
</p>
<p>We can specify the immediate next dose by specifying <code>next_dose</code>. If
omitted, the next dose is calculated by invoking the model on the outcomes
seen thus far.
</p>
<p>Designs must eventually choose to stop the trial. Some designs, like 3+3,
have intrinsic stopping rules. However, some selectors like those derived
from <code><a href="#topic+get_dfcrm">get_dfcrm</a></code> offer no default stopping method. You may need
to append stopping behaviour to your selector via something like
<code><a href="#topic+stop_at_n">stop_at_n</a></code> or <code><a href="#topic+stop_when_n_at_dose">stop_when_n_at_dose</a></code>, etc. To
safeguard against simulating runaway trials that never end, the function
will halt a simulated trial after 30 invocations of the dose-selection
decision. To breach this limit, specify <code>i_like_big_trials = TRUE</code> in
the function call. However, when you forego the safety net, the onus is on
you to write selectors that will eventually stop the trial! See Examples.
</p>
<p>The model is fit to the prevailing data at each dose selection point. By
default, only the final model fit for each simulated trial is retained.
This is done to conserve memory. With a high number of simulated trials,
storing many model fits per trial may cause the executing machine to run
out of memory. However, you can force this method to retain all model fits
by specifying <code>return_all_fits = TRUE</code>. See Examples.
</p>


<h3>Value</h3>

<p>Object of type <code><a href="#topic+simulations">simulations</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+simulations">simulations</a></code>
</p>
<p><code><a href="#topic+selector_factory">selector_factory</a></code>
</p>
<p><code><a href="#topic+get_dfcrm">get_dfcrm</a></code>
</p>
<p><code><a href="#topic+get_boin">get_boin</a></code>
</p>
<p><code><a href="#topic+get_three_plus_three">get_three_plus_three</a></code>
</p>
<p><code><a href="#topic+cohorts_of_n">cohorts_of_n</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># In a five-dose scenario, we have assumed probabilities for Prob(tox):
true_prob_tox &lt;- c(0.12, 0.27, 0.44, 0.53, 0.57)

# Simulate ten 3+3 trials:
sims &lt;- get_three_plus_three(num_doses = 5) %&gt;%
  simulate_trials(num_sims = 10, true_prob_tox = true_prob_tox)
# Likewise, simulate 10 trials using a continual reassessment method:
skeleton &lt;- c(0.05, 0.1, 0.25, 0.4, 0.6)
target &lt;- 0.25
sims &lt;- get_dfcrm(skeleton = skeleton, target = target) %&gt;%
  stop_at_n(n = 12) %&gt;%
  simulate_trials(num_sims = 10, true_prob_tox = true_prob_tox)

# Lots of useful information is contained in the returned object:
sims %&gt;% num_patients()
sims %&gt;% num_doses()
sims %&gt;% dose_indices()
sims %&gt;% n_at_dose()
sims %&gt;% n_at_recommended_dose()
sims %&gt;% tox_at_dose()
sims %&gt;% num_tox()
sims %&gt;% recommended_dose()
sims %&gt;% prob_administer()
sims %&gt;% prob_recommend()
sims %&gt;% trial_duration()

# By default, dose decisions are made after each cohort of 3 patients. See
# Details. To override, specify an alternative function via the
# sample_patient_arrivals parameter. E.g. to use cohorts of 2, we run:
patient_arrivals_func &lt;- function(current_data) cohorts_of_n(n = 2)
sims &lt;- get_dfcrm(skeleton = skeleton, target = target) %&gt;%
  stop_at_n(n = 12) %&gt;%
  simulate_trials(num_sims = 10, true_prob_tox = true_prob_tox,
    sample_patient_arrivals = patient_arrivals_func)

# To simulate the culmination of trials that are partly completed, specify
# the outcomes already observed via the previous_outcomes parameter. Imagine
# one cohort has already been evaluated, returning outcomes 1NTN. We can
# simulate the remaining part of the trial with:
sims &lt;- get_dfcrm(skeleton = skeleton, target = target) %&gt;%
  stop_at_n(n = 12) %&gt;%
  simulate_trials(num_sims = 10, true_prob_tox = true_prob_tox,
                  previous_outcomes = '1NTN')
# Outcomes can be described by the above outcome string method or data-frame:
  previous_outcomes &lt;- data.frame(
    patient = 1:3,
    cohort = c(1, 1, 1),
    tox = c(0, 1, 0),
    dose = c(1, 1, 1)
  )
sims &lt;- get_dfcrm(skeleton = skeleton, target = target) %&gt;%
  stop_at_n(n = 12) %&gt;%
  simulate_trials(num_sims = 10, true_prob_tox = true_prob_tox,
                  previous_outcomes = previous_outcomes)

# We can specify the immediate next dose:
sims &lt;- get_dfcrm(skeleton = skeleton, target = target) %&gt;%
  stop_at_n(n = 12) %&gt;%
  simulate_trials(num_sims = 10, true_prob_tox = true_prob_tox,
                  next_dose = 5)

# By default, the method will stop simulated trials after 30 dose selections.
# To suppress this, specify i_like_big_trials = TRUE. However, please take
# care to specify selectors that will eventually stop!
sims &lt;- get_dfcrm(skeleton = skeleton, target = target) %&gt;%
  stop_at_n(n = 99) %&gt;%
  simulate_trials(num_sims = 1, true_prob_tox = true_prob_tox,
                  i_like_big_trials = TRUE)

# By default, only the final model fit is retained for each simulated trial.
# To retain all interim model fits, specify return_all_fits = TRUE.
sims &lt;- get_three_plus_three(num_doses = 5) %&gt;%
  simulate_trials(num_sims = 10, true_prob_tox = true_prob_tox,
                  return_all_fits = TRUE)
# Verify that there are now many analyses per trial with:
sapply(sims$fits, length)
</code></pre>

<hr>
<h2 id='simulation_function'>Get function for simulating trials.</h2><span id='topic+simulation_function'></span>

<h3>Description</h3>

<p>This function does not need to be called by users. It is used internally.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulation_function(selector_factory)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simulation_function_+3A_selector_factory">selector_factory</code></td>
<td>
<p>Object of type <code><a href="#topic+selector_factory">selector_factory</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A function.
</p>

<hr>
<h2 id='simulations'>Simulated trials.</h2><span id='topic+simulations'></span>

<h3>Description</h3>

<p>This class encapsulates that many notional or virtual trials can be
simulated. Each recommends a dose (or doses), keeps track of how many
patients have been treated at what doses, what toxicity outcomes have been
seen, and whether a trial advocates continuing, etc. We run simulations to
learn about the operating characteristics of a trial design.
</p>
<p>Computationally, the <code>simulations</code> class supports much of the same
interface as <code><a href="#topic+selector">selector</a></code>, and a little more.
Thus, many of the same generic functions are supported - see Examples.
However, compared to <code><a href="#topic+selector">selector</a></code>s, the returned objects reflect
that there are many trials instead of one, e.g. <code>num_patients(sims)</code>,
returns as an integer vector the number of patients used in the simulated
trials.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulations(fits, true_prob_tox, true_prob_eff = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simulations_+3A_fits">fits</code></td>
<td>
<p>Simulated model fits, arranged as list of lists.</p>
</td></tr>
<tr><td><code id="simulations_+3A_true_prob_tox">true_prob_tox</code></td>
<td>
<p>vector of true toxicity probabilities</p>
</td></tr>
<tr><td><code id="simulations_+3A_true_prob_eff">true_prob_eff</code></td>
<td>
<p>vector of true efficacy probabilities, optionally NULL
if efficacy not analysed.</p>
</td></tr>
<tr><td><code id="simulations_+3A_...">...</code></td>
<td>
<p>Extra args</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>simulations</code> object implements the following functions:
</p>

<ul>
<li> <p><code><a href="#topic+num_patients">num_patients</a></code>
</p>
</li>
<li> <p><code><a href="#topic+num_doses">num_doses</a></code>
</p>
</li>
<li> <p><code><a href="#topic+dose_indices">dose_indices</a></code>
</p>
</li>
<li> <p><code><a href="#topic+n_at_dose">n_at_dose</a></code>
</p>
</li>
<li> <p><code><a href="#topic+tox_at_dose">tox_at_dose</a></code>
</p>
</li>
<li> <p><code><a href="#topic+num_tox">num_tox</a></code>
</p>
</li>
<li> <p><code><a href="#topic+recommended_dose">recommended_dose</a></code>
</p>
</li>
<li> <p><code><a href="#topic+prob_administer">prob_administer</a></code>
</p>
</li>
<li> <p><code><a href="#topic+prob_recommend">prob_recommend</a></code>
</p>
</li>
<li> <p><code><a href="#topic+trial_duration">trial_duration</a></code>
</p>
</li></ul>



<h3>Value</h3>

<p>list with slots: <code>fits</code> containing model fits;
and <code>true_prob_tox</code>, contianing the assumed true probability of
toxicity.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+selector">selector</a></code>
</p>
<p><code><a href="#topic+simulate_trials">simulate_trials</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Simulate performance of the 3+3 design:
true_prob_tox &lt;- c(0.12, 0.27, 0.44, 0.53, 0.57)
sims &lt;- get_three_plus_three(num_doses = 5) %&gt;%
  simulate_trials(num_sims = 10, true_prob_tox = true_prob_tox)
# The returned object has type 'simulations'. The supported interface is:
sims %&gt;% num_patients()
sims %&gt;% num_doses()
sims %&gt;% dose_indices()
sims %&gt;% n_at_dose()
sims %&gt;% tox_at_dose()
sims %&gt;% num_tox()
sims %&gt;% recommended_dose()
sims %&gt;% prob_administer()
sims %&gt;% prob_recommend()
sims %&gt;% trial_duration()

# Access the list of model fits for the ith simulated trial using:
i &lt;- 1
sims$fits[[i]]
# and the jth model fit for the ith simulated trial using:
j &lt;- 1
sims$fits[[i]][[j]]
# and so on.
</code></pre>

<hr>
<h2 id='simulations_collection'>Make an instance of type <code>simulations_collection</code></h2><span id='topic+simulations_collection'></span>

<h3>Description</h3>

<p>This object can be cast to a tibble with <code>as_tibble</code> to generate useful
pairwise comparisons of the probability of recommending each dose for each
pair of designs investigated. See
<code><a href="#topic+as_tibble.simulations_collection">as_tibble.simulations_collection</a></code> for a description.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulations_collection(sim_map)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simulations_collection_+3A_sim_map">sim_map</code></td>
<td>
<p>list, character -&gt; <code><a href="#topic+simulations">simulations</a></code> object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>object of class <code>simulations_collection</code>, inheriting from list
</p>


<h3>References</h3>

<p>Sweeting, M., Slade, D., Jackson, D., &amp; Brock, K. (2023).
Potential outcome simulation for efficient head-to-head comparison of
adaptive dose-finding designs. Preprint.
</p>

<hr>
<h2 id='spread_paths'>Spread the information in dose_finding_paths object to a wide data.frame format.</h2><span id='topic+spread_paths'></span>

<h3>Description</h3>

<p>Spread the information in dose_finding_paths object to a wide data.frame format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spread_paths(df = NULL, dose_finding_paths = NULL, max_depth = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spread_paths_+3A_df">df</code></td>
<td>
<p>Optional <code>data.frame</code> like that returned by
as_tibble(dose_finding_paths). Columns .depth, .node, .parent are required.
All other columns are spread with a suffix reflecting depth.</p>
</td></tr>
<tr><td><code id="spread_paths_+3A_dose_finding_paths">dose_finding_paths</code></td>
<td>
<p>Optional instance of dose_finding_paths. Required
if 'df' is null.</p>
</td></tr>
<tr><td><code id="spread_paths_+3A_max_depth">max_depth</code></td>
<td>
<p>integer, maximum depth of paths to traverse.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Calculate paths for the first two cohorts of three patients a CRM trial
skeleton &lt;- c(0.05, 0.1, 0.25, 0.4, 0.6)
target &lt;- 0.25
cohort_sizes &lt;- c(3, 3)
paths &lt;- get_dfcrm(skeleton = skeleton, target = target) %&gt;%
  get_dose_paths(cohort_sizes = cohort_sizes)

## End(Not run)
</code></pre>

<hr>
<h2 id='stack_sims_vert'>Stack <code><a href="#topic+simulations_collection">simulations_collection</a></code> results vertically</h2><span id='topic+stack_sims_vert'></span>

<h3>Description</h3>

<p>Stack <code><a href="#topic+simulations_collection">simulations_collection</a></code> results vertically
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stack_sims_vert(sim_map, target_dose = NULL, alpha = 0.05)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stack_sims_vert_+3A_sim_map">sim_map</code></td>
<td>
<p>object of type <code><a href="#topic+simulations_collection">simulations_collection</a></code></p>
</td></tr>
<tr><td><code id="stack_sims_vert_+3A_target_dose">target_dose</code></td>
<td>
<p>optional integer vector, the dose of interest. All doses
are analysed if omitted, which is the default.</p>
</td></tr>
<tr><td><code id="stack_sims_vert_+3A_alpha">alpha</code></td>
<td>
<p>confidence level for asymptotic normal confidence intervals. The
default value is 0.05 to get 95 percent confidence intervals.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data.frame
</p>


<h3>Examples</h3>

<pre><code class='language-R'># In a five-dose scenario, we have assumed probabilities for Prob(tox):
true_prob_tox &lt;- c(0.05, 0.10, 0.15, 0.18, 0.45)
# and Prov(eff):
true_prob_eff &lt;- c(0.40, 0.50, 0.52, 0.53, 0.53)

# Let us compare two BOIN12 variants that differ in their stopping params:
designs &lt;- list(
  "BOIN12 v1" = get_boin12(num_doses = 5,
                           phi_t = 0.35, phi_e = 0.25,
                           u2 = 40, u3 = 60,
                           c_t = 0.95, c_e = 0.9) %&gt;%
    stop_at_n(n = 36),
  "BOIN12 v2" = get_boin12(num_doses = 5,
                           phi_t = 0.35, phi_e = 0.25,
                           u2 = 40, u3 = 60,
                           c_t = 0.5, c_e = 0.5) %&gt;%
    stop_at_n(n = 36)
)
# For illustration we run only 10 iterates:
x &lt;- simulate_compare(
  designs,
  num_sims = 10,
  true_prob_tox,
  true_prob_eff
)
stack_sims_vert(x)
</code></pre>

<hr>
<h2 id='stop_at_n'>Stop when there are n patients in total.</h2><span id='topic+stop_at_n'></span>

<h3>Description</h3>

<p>This function adds a restriction to stop a trial when n patients have been
evaluated. It does this by adding together the number of patients treated at
all doses and stopping when that total exceeds n.
</p>
<p>Dose selectors are designed to be daisy-chained together to achieve different
behaviours. This class is a **greedy** selector, meaning that it prioritises
its own behaviour over the behaviour of other selectors in the chain. That
is, it will advocate stopping when the condition has been met, even if the
selectors further up the chain would advocate to keep going. In can be
interpreted as an overriding selector. This allows the decision to stop to
be executed as soon as it is warranted. Be aware though, that there are other
selectors that can be placed after this class that will override the stopping
behaviour. See Examples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stop_at_n(parent_selector_factory, n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stop_at_n_+3A_parent_selector_factory">parent_selector_factory</code></td>
<td>
<p>Object of type <code><a href="#topic+selector_factory">selector_factory</a></code>.</p>
</td></tr>
<tr><td><code id="stop_at_n_+3A_n">n</code></td>
<td>
<p>Stop when there are this many patients.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of type <code><a href="#topic+selector_factory">selector_factory</a></code> that can fit a
dose-finding model to outcomes.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>skeleton &lt;- c(0.05, 0.1, 0.25, 0.4, 0.6)
target &lt;- 0.25

# Create CRM model that will stop when 15 patients are evaluated:
model1 &lt;- get_dfcrm(skeleton = skeleton, target = target) %&gt;%
  stop_at_n(n = 15)

# With 12 patients, this trial should not stop:
fit1 &lt;- model1 %&gt;% fit('1NNN 2NTN 2TNN 2NNN')
fit1 %&gt;% recommended_dose()
fit1 %&gt;% continue()

# With 15 patients, this trial should stop:
fit2 &lt;- model1 %&gt;% fit('1NNN 2NTN 2TNN 2NNN 2NTT')
fit2 %&gt;% recommended_dose()
fit2 %&gt;% continue()

# The stopping behaviour can be overruled by the order of selectors.
# In model2, demanding 9 at recommended dose will trump stopping at 12:
model2 &lt;- get_dfcrm(skeleton = skeleton, target = target) %&gt;%
  stop_at_n(n = 12) %&gt;%
  demand_n_at_dose(dose = 'recommended', n = 9)

# In model3, stopping at 12 will trump demanding 9 at recommended dose:
model3 &lt;- get_dfcrm(skeleton = skeleton, target = target) %&gt;%
  demand_n_at_dose(dose = 'recommended', n = 9) %&gt;%
  stop_at_n(n = 12)

# This model will continue because 9 have not been seen at recommended dose.
fit3 &lt;- model2 %&gt;% fit('1NNN 2NNN 2NNN 3NNN')
fit3 %&gt;% recommended_dose()
fit3 %&gt;% continue()

# This model will stop because 12 have been seen.
fit4 &lt;- model3 %&gt;% fit('1NNN 2NNN 2NNN 3NNN')
fit4 %&gt;% recommended_dose()
fit4 %&gt;% continue()

# With enough observations though, both models will advise stopping because
# both conditions have been met:
fit5 &lt;- model2 %&gt;% fit('1NNN 2NNN 2NNN 5NNN 5NNN 5NNN')
fit5 %&gt;% recommended_dose()
fit5 %&gt;% continue()

fit6 &lt;- model3 %&gt;% fit('1NNN 2NNN 2NNN 5NNN 5NNN 5NNN')
fit6 %&gt;% recommended_dose()
fit6 %&gt;% continue()

</code></pre>

<hr>
<h2 id='stop_when_n_at_dose'>Stop when there are n patients at a dose.</h2><span id='topic+stop_when_n_at_dose'></span>

<h3>Description</h3>

<p>This method stops a dose-finding trial when there are n patients at a dose.
It can stop when the rule is triggered at the recommended dose, at a
particular dose, or at any dose.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stop_when_n_at_dose(parent_selector_factory, n, dose)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stop_when_n_at_dose_+3A_parent_selector_factory">parent_selector_factory</code></td>
<td>
<p>Object of type <code><a href="#topic+selector_factory">selector_factory</a></code>.</p>
</td></tr>
<tr><td><code id="stop_when_n_at_dose_+3A_n">n</code></td>
<td>
<p>Stop when there are n at a dose.</p>
</td></tr>
<tr><td><code id="stop_when_n_at_dose_+3A_dose">dose</code></td>
<td>
<p><code>'any'</code> to stop when there are n at any dose;
<code>'recommended'</code> to stop when there are n at the recommended dose; or an
integer to stop when there are n at a particular dose-level.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of type <code><a href="#topic+selector_factory">selector_factory</a></code> that can fit a
dose-finding model to outcomes.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>skeleton &lt;- c(0.05, 0.1, 0.25, 0.4, 0.6)
target &lt;- 0.25

# This model will stop when 12 are seen at any dose:
model1 &lt;- get_dfcrm(skeleton = skeleton, target = target) %&gt;%
  stop_when_n_at_dose(n = 12, dose = 'any')

# This model fit will not stop:
model1 %&gt;% fit('1NNN 2NTN 2TNN 2NNN') %&gt;% continue()
# But this model fit will stop:
model1 %&gt;% fit('1NNN 2NTN 2TNN 2NNN 2NTT') %&gt;% continue()

# This model will stop when 12 are seen at the recommended dose:
model2 &lt;- get_dfcrm(skeleton = skeleton, target = target) %&gt;%
  stop_when_n_at_dose(n = 12, dose = 'recommended')

# This model fit will not stop:
fit2 &lt;- model2 %&gt;% fit('1NNN 2NTN 2TNN 2NNN')
fit2 %&gt;% recommended_dose()
fit2 %&gt;% continue()
# But this model fit will stop:
fit3 &lt;- model2 %&gt;% fit('1NNN 2NTN 2TNN 2NNN 2NNT')
fit3 %&gt;% recommended_dose()
fit3 %&gt;% continue()
</code></pre>

<hr>
<h2 id='stop_when_too_toxic'>Stop trial and recommend no dose when a dose is too toxic.</h2><span id='topic+stop_when_too_toxic'></span>

<h3>Description</h3>

<p>This method stops a dose-finding trial and recommends no dose when sufficient
probabilistic confidence is reached that the rate of toxicity at a dose
exceeds some threshold. In other words, it stops when it is likely that a
dose is too toxic. It can stop when the rule is triggered at the recommended
dose, at a particular dose, or at any dose. See Details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stop_when_too_toxic(parent_selector_factory, dose, tox_threshold, confidence)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stop_when_too_toxic_+3A_parent_selector_factory">parent_selector_factory</code></td>
<td>
<p>Object of type <code><a href="#topic+selector_factory">selector_factory</a></code>.</p>
</td></tr>
<tr><td><code id="stop_when_too_toxic_+3A_dose">dose</code></td>
<td>
<p><code>'any'</code> to stop when any dose is too toxic;
<code>'recommended'</code> to stop when the recommended dose is too toxic; or an
integer to stop when a particular dose-level is too toxic.</p>
</td></tr>
<tr><td><code id="stop_when_too_toxic_+3A_tox_threshold">tox_threshold</code></td>
<td>
<p>We are interested in toxicity probabilities greater than
this threshold.</p>
</td></tr>
<tr><td><code id="stop_when_too_toxic_+3A_confidence">confidence</code></td>
<td>
<p>Stop when there is this much total probability mass
supporting that the toxicity rate exceeds the threshold.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The method for calculating probability mass for toxicity rates will
ultimately be determined by the dose-finding model used and the attendant
inferential mechanism. For instance, the <code><a href="dfcrm.html#topic+crm">crm</a></code> function in
the dfcrm package calculates the posterior expected mean and variance of the
slope parameter in a CRM model. It does not use MCMC to draw samples from the
posterior distribution. Thus, to perform inference on the posterior
probability of toxicity, this package assumes the dfcrm slope parameter
follows a normal distribution with the mean and variance calculated by dfcrm.
In contrast, the <code>stan_crm</code> function in the <code>trialr</code> package needs
no such assumption because it samples from the posterior parameter
distribution and uses those samples to infer on the posterior probability of
toxicity at each dose, dependent on the chosen model for the dose-toxicity
curve.
</p>


<h3>Value</h3>

<p>an object of type <code><a href="#topic+selector_factory">selector_factory</a></code> that can fit a
dose-finding model to outcomes.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>skeleton &lt;- c(0.05, 0.1, 0.25, 0.4, 0.6)
target &lt;- 0.25

# We compare a CRM model without a toxicity stopping rule to one with it:
model1 &lt;- get_dfcrm(skeleton = skeleton, target = target)
model2 &lt;- get_dfcrm(skeleton = skeleton, target = target) %&gt;%
  stop_when_too_toxic(dose = 'any', tox_threshold = 0.5, confidence = 0.7)

outcomes &lt;- '1NNN 2NNN 3NNT 3NNN 3TNT 2NNN'
fit1 &lt;- model1 %&gt;% fit(outcomes)
fit2 &lt;- model2 %&gt;% fit(outcomes)

# Naturally the first does not advocate stopping:
fit1 %&gt;% recommended_dose()
fit1 %&gt;% continue()

# However, after the material toxicity at dose 3, ithe rule is fired:
fit2 %&gt;% recommended_dose()
fit2 %&gt;% continue()
# To verify the requirement to stop, let's calculate the probability that the
# toxicity rate exceeds 50%
fit2 %&gt;% prob_tox_exceeds(0.5)
</code></pre>

<hr>
<h2 id='stop_when_tox_ci_covered'>Stop when uncertainty interval of prob tox is covered.</h2><span id='topic+stop_when_tox_ci_covered'></span>

<h3>Description</h3>

<p>This method stops a dose-finding trial when the symmetric uncertainty
interval for the probability of toxicity falls within a range. This allows
trials to be stopped when sufficient precision on the pobability of toxicity
has been achieved. See Details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stop_when_tox_ci_covered(
  parent_selector_factory,
  dose,
  lower,
  upper,
  width = 0.9
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stop_when_tox_ci_covered_+3A_parent_selector_factory">parent_selector_factory</code></td>
<td>
<p>Object of type <code><a href="#topic+selector_factory">selector_factory</a></code>.</p>
</td></tr>
<tr><td><code id="stop_when_tox_ci_covered_+3A_dose">dose</code></td>
<td>
<p><code>'any'</code> to stop when the interval for any dose is covered;
<code>'recommended'</code> to stop when the interval for the recommended dose is
covered ; or an integer to stop when the interval for a particular dose-level
is covered.</p>
</td></tr>
<tr><td><code id="stop_when_tox_ci_covered_+3A_lower">lower</code></td>
<td>
<p>Stop when lower interval bound exceeds this value</p>
</td></tr>
<tr><td><code id="stop_when_tox_ci_covered_+3A_upper">upper</code></td>
<td>
<p>Stop when upper interval bound is less than this value</p>
</td></tr>
<tr><td><code id="stop_when_tox_ci_covered_+3A_width">width</code></td>
<td>
<p>Width of the uncertainty interval. Default is 0.9, i.e. a range
from the 5th to the 95th percentiles.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The method for calculating probability mass for toxicity rates will
ultimately be determined by the dose-finding model used and the attendant
inferential mechanism. For instance, the <code><a href="dfcrm.html#topic+crm">crm</a></code> function in
the dfcrm package calculates the posterior expected mean and variance of the
slope parameter in a CRM model. It does not use MCMC to draw samples from the
posterior distribution. Thus, to perform inference on the posterior
probability of toxicity, this package assumes the dfcrm slope parameter
follows a normal distribution with the mean and variance calculated by dfcrm.
In contrast, the <code>stan_crm</code> function in the <code>trialr</code>
package needs no such assumption because it samples from the posterior
parameter distribution and uses those samples to infer on the posterior
probability of toxicity at each dose, dependent on the chosen model for the
dose-toxicity curve.
</p>


<h3>Value</h3>

<p>an object of type <code><a href="#topic+selector_factory">selector_factory</a></code> that can fit a
dose-finding model to outcomes.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>skeleton &lt;- c(0.05, 0.1, 0.25, 0.4, 0.6)
target &lt;- 0.25

# We compare a CRM model without this stopping rule:
model1 &lt;- get_dfcrm(skeleton = skeleton, target = target)
# To two with it, the first demanding a relatively tight CI:
model2 &lt;- get_dfcrm(skeleton = skeleton, target = target) %&gt;%
  stop_when_tox_ci_covered(dose = 'recommended', lower = 0.15, upper = 0.35)
# and the second demanding a relatively loose CI:
model3 &lt;- get_dfcrm(skeleton = skeleton, target = target) %&gt;%
  stop_when_tox_ci_covered(dose = 'recommended', lower = 0.05, upper = 0.45)

outcomes &lt;- '1NNN 2NNN 3NNT 3NNN 3TNT 2NNN'
fit1 &lt;- model1 %&gt;% fit(outcomes)
fit2 &lt;- model2 %&gt;% fit(outcomes)
fit3 &lt;- model3 %&gt;% fit(outcomes)

# Naturally the first does not advocate stopping:
fit1 %&gt;% recommended_dose()
fit1 %&gt;% continue()

# The second does not advocate stopping either:
fit2 %&gt;% recommended_dose()
fit2 %&gt;% continue()
# This is because the CI is too wide:
fit2 %&gt;% prob_tox_quantile(p = 0.05)
fit2 %&gt;% prob_tox_quantile(p = 0.95)

# However, the third design advocates stopping because the CI at the
# recommended dose is covered:
fit3 %&gt;% recommended_dose()
fit3 %&gt;% continue()
# To verify the veracity, inspect the quantiles:
fit3 %&gt;% prob_tox_quantile(p = 0.05)
fit3 %&gt;% prob_tox_quantile(p = 0.95)
</code></pre>

<hr>
<h2 id='supports_sampling'>Does this selector support sampling of outcomes?</h2><span id='topic+supports_sampling'></span>

<h3>Description</h3>

<p>Learn whether this selector supports sampling of outcomes. For instance, is
it possible to get posterior samples of the probability of toxicity at each
dose? If true, prob_tox_samples will return a data-frame of samples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>supports_sampling(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="supports_sampling_+3A_x">x</code></td>
<td>
<p>Object of type <code><a href="#topic+selector">selector</a></code></p>
</td></tr>
<tr><td><code id="supports_sampling_+3A_...">...</code></td>
<td>
<p>arguments passed to other methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>logical
</p>


<h3>Examples</h3>

<pre><code class='language-R'># CRM example
skeleton &lt;- c(0.05, 0.1, 0.25, 0.4, 0.6)
target &lt;- 0.25
outcomes &lt;- '1NNN 2NTN'
fit &lt;- get_dfcrm(skeleton = skeleton, target = target) %&gt;% fit(outcomes)
fit %&gt;% supports_sampling()
</code></pre>

<hr>
<h2 id='three_plus_three'>Fit the 3+3 model to some outcomes.</h2><span id='topic+three_plus_three'></span>

<h3>Description</h3>

<p>Fit the 3+3 model to some outcomes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>three_plus_three(
  outcomes,
  num_doses,
  allow_deescalate = FALSE,
  strict_mode = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="three_plus_three_+3A_outcomes">outcomes</code></td>
<td>
<p>Outcomes observed. See <code><a href="#topic+parse_phase1_outcomes">parse_phase1_outcomes</a></code>.</p>
</td></tr>
<tr><td><code id="three_plus_three_+3A_num_doses">num_doses</code></td>
<td>
<p>Number of doses under investigation.</p>
</td></tr>
<tr><td><code id="three_plus_three_+3A_allow_deescalate">allow_deescalate</code></td>
<td>
<p>TRUE to allow de-escalation, as described by Korn et
al. Default is FALSE.</p>
</td></tr>
<tr><td><code id="three_plus_three_+3A_strict_mode">strict_mode</code></td>
<td>
<p>TRUE to raise errors if it is detected that the 3+3
algorithm has not been followed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>lits containing recommended_dose and a logical value continue saying
whether the trial should continue.
</p>


<h3>References</h3>

<p>Storer BE. Design and Analysis of Phase I Clinical Trials. Biometrics.
1989;45(3):925-937. doi:10.2307/2531693
</p>
<p>Korn EL, Midthune D, Chen TT, Rubinstein LV, Christian MC, Simon RM.
A comparison of two phase I trial designs. Statistics in Medicine.
1994;13(18):1799-1806. doi:10.1002/sim.4780131802
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
three_plus_three('2NNN 3NNT', num_doses = 7)

</code></pre>

<hr>
<h2 id='tox'>Binary toxicity outcomes.</h2><span id='topic+tox'></span>

<h3>Description</h3>

<p>Get a vector of the binary toxicity outcomes for evaluated patients.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tox(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tox_+3A_x">x</code></td>
<td>
<p>Object of type <code><a href="#topic+selector">selector</a></code>.</p>
</td></tr>
<tr><td><code id="tox_+3A_...">...</code></td>
<td>
<p>Extra args are passed onwards.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an integer vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'>skeleton &lt;- c(0.05, 0.1, 0.25, 0.4, 0.6)
target &lt;- 0.25
model &lt;- get_dfcrm(skeleton = skeleton, target = target)
fit &lt;- model %&gt;% fit('1NNN 2NTN')
fit %&gt;% tox()
</code></pre>

<hr>
<h2 id='tox_at_dose'>Number of toxicities seen at each dose.</h2><span id='topic+tox_at_dose'></span>

<h3>Description</h3>

<p>Get the number of toxicities seen at each dose under investigation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tox_at_dose(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tox_at_dose_+3A_x">x</code></td>
<td>
<p>Object of class <code><a href="#topic+selector">selector</a></code></p>
</td></tr>
<tr><td><code id="tox_at_dose_+3A_...">...</code></td>
<td>
<p>arguments passed to other methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an integer vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'># CRM example
skeleton &lt;- c(0.05, 0.1, 0.25, 0.4, 0.6)
target &lt;- 0.25
outcomes &lt;- '1NNN 2NTN'
fit &lt;- get_dfcrm(skeleton = skeleton, target = target) %&gt;% fit(outcomes)
fit %&gt;% tox_at_dose()
</code></pre>

<hr>
<h2 id='tox_limit'>Toxicity rate limit</h2><span id='topic+tox_limit'></span>

<h3>Description</h3>

<p>Get the maximum permissible toxicity rate, if supported. NULL if not.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tox_limit(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tox_limit_+3A_x">x</code></td>
<td>
<p>Object of type <code><a href="#topic+selector">selector</a></code>.</p>
</td></tr>
<tr><td><code id="tox_limit_+3A_...">...</code></td>
<td>
<p>Extra args are passed onwards.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric
</p>


<h3>Examples</h3>

<pre><code class='language-R'>efftox_priors &lt;- trialr::efftox_priors
p &lt;- efftox_priors(alpha_mean = -7.9593, alpha_sd = 3.5487,
                   beta_mean = 1.5482, beta_sd = 3.5018,
                   gamma_mean = 0.7367, gamma_sd = 2.5423,
                   zeta_mean = 3.4181, zeta_sd = 2.4406,
                   eta_mean = 0, eta_sd = 0.2,
                   psi_mean = 0, psi_sd = 1)
real_doses = c(1.0, 2.0, 4.0, 6.6, 10.0)
model &lt;- get_trialr_efftox(real_doses = real_doses,
                           efficacy_hurdle = 0.5, toxicity_hurdle = 0.3,
                           p_e = 0.1, p_t = 0.1,
                           eff0 = 0.5, tox1 = 0.65,
                           eff_star = 0.7, tox_star = 0.25,
                           priors = p, iter = 1000, chains = 1, seed = 2020)
x &lt;- model %&gt;% fit('1N 2E 3B')
tox_limit(x)
</code></pre>

<hr>
<h2 id='tox_target'>Target toxicity rate</h2><span id='topic+tox_target'></span>

<h3>Description</h3>

<p>Get the target toxicity rate, if supported. NULL if not.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tox_target(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tox_target_+3A_x">x</code></td>
<td>
<p>Object of type <code><a href="#topic+selector">selector</a></code>.</p>
</td></tr>
<tr><td><code id="tox_target_+3A_...">...</code></td>
<td>
<p>Extra args are passed onwards.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric
</p>


<h3>Examples</h3>

<pre><code class='language-R'>skeleton &lt;- c(0.05, 0.1, 0.25, 0.4, 0.6)
target &lt;- 0.25
model &lt;- get_dfcrm(skeleton = skeleton, target = target)
fit &lt;- model %&gt;% fit('1NNN 2NTN')
fit %&gt;% tox_target()
</code></pre>

<hr>
<h2 id='trial_duration'>Duration of trials.</h2><span id='topic+trial_duration'></span>

<h3>Description</h3>

<p>Get the length of time that trials take to recruit all patients.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>trial_duration(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="trial_duration_+3A_x">x</code></td>
<td>
<p>Object of type <code><a href="#topic+simulations">simulations</a></code>.</p>
</td></tr>
<tr><td><code id="trial_duration_+3A_...">...</code></td>
<td>
<p>arguments passed to other methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector of numerical times
</p>


<h3>Examples</h3>

<pre><code class='language-R'>true_prob_tox &lt;- c(0.12, 0.27, 0.44, 0.53, 0.57)
sims &lt;- get_three_plus_three(num_doses = 5) %&gt;%
  simulate_trials(num_sims = 50, true_prob_tox = true_prob_tox)
sims %&gt;% trial_duration
</code></pre>

<hr>
<h2 id='try_rescue_dose'>Demand that a rescue dose is tried before stopping is permitted.</h2><span id='topic+try_rescue_dose'></span>

<h3>Description</h3>

<p>This method continues a dose-finding trial until a safety dose has been given
to n patients. Once that condition is met, it delegates dose selelcting and
stopping responsibility to its parent dose selector, whatever that might be.
This class is greedy in that it meets its own needs before asking any other
selectors higher in the chain what they want. Thus, different behaviours may
be achieved by nesting dose selectors in different orders. See examples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>try_rescue_dose(parent_selector_factory, n, dose)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="try_rescue_dose_+3A_parent_selector_factory">parent_selector_factory</code></td>
<td>
<p>Object of type <code><a href="#topic+selector_factory">selector_factory</a></code>.</p>
</td></tr>
<tr><td><code id="try_rescue_dose_+3A_n">n</code></td>
<td>
<p>Continue at least until there are n at a dose.</p>
</td></tr>
<tr><td><code id="try_rescue_dose_+3A_dose">dose</code></td>
<td>
<p>an integer to identify the sought rescue dose-level.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of type <code><a href="#topic+selector_factory">selector_factory</a></code> that can fit a
dose-finding model to outcomes.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>skeleton &lt;- c(0.05, 0.1, 0.25, 0.4, 0.6)
target &lt;- 0.25

# This model will demand the lowest dose is tried in at least two patients
# before the trial is stopped for excess toxicity
model1 &lt;- get_dfcrm(skeleton = skeleton, target = target) %&gt;%
  stop_when_too_toxic(dose = 1, tox_threshold = 0.35, confidence = 0.8) %&gt;%
  try_rescue_dose(dose = 1, n = 2)

# In contrast, this model will stop for excess toxicity without trying dose 1
model2 &lt;- get_dfcrm(skeleton = skeleton, target = target) %&gt;%
  stop_when_too_toxic(dose = 1, tox_threshold = 0.35, confidence = 0.8)

# For non-toxic outcomes, both designs will continue at sensible doses:
fit1 &lt;- model1 %&gt;% fit('2NNN')
fit1 %&gt;% recommended_dose()
fit1 %&gt;% continue()

fit2 &lt;- model2 %&gt;% fit('2NNN')
fit2 %&gt;% recommended_dose()
fit2 %&gt;% continue()

# For toxic outcomes, the design 1 will use dose 1 before stopping is allowed
fit1 &lt;- model1 %&gt;% fit('2TTT')
fit1 %&gt;% recommended_dose()
fit1 %&gt;% continue()

# For toxic outcomes, however, design 2 will stop despite dose 1 being
# untested:
fit2 &lt;- model2 %&gt;% fit('2TTT')
fit2 %&gt;% recommended_dose()
fit2 %&gt;% continue()

# After dose 1 is given the requisite number of times, dose recommendation
# and stopping revert to being determined by the underlying dose selector:
fit1 &lt;- model1 %&gt;% fit('2TTT 1T')
fit1 %&gt;% recommended_dose()
fit1 %&gt;% continue()

fit1 &lt;- model1 %&gt;% fit('2TTT 1TT')
fit1 %&gt;% recommended_dose()
fit1 %&gt;% continue()
</code></pre>

<hr>
<h2 id='utility'>Utility score of each dose.</h2><span id='topic+utility'></span>

<h3>Description</h3>

<p>Get the derived utility score of each dose under investigation. Some models,
particularly phase I/II models or efficacy-toxicity designs, specify
algorithms to calculate utility. If no utility algorithm is specified for a
design, this function will return a vector of NAs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>utility(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="utility_+3A_x">x</code></td>
<td>
<p>Object of class <code><a href="#topic+selector">selector</a></code></p>
</td></tr>
<tr><td><code id="utility_+3A_...">...</code></td>
<td>
<p>arguments passed to other methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a numerical vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'>efftox_priors &lt;- trialr::efftox_priors
p &lt;- efftox_priors(alpha_mean = -7.9593, alpha_sd = 3.5487,
                   beta_mean = 1.5482, beta_sd = 3.5018,
                   gamma_mean = 0.7367, gamma_sd = 2.5423,
                   zeta_mean = 3.4181, zeta_sd = 2.4406,
                   eta_mean = 0, eta_sd = 0.2,
                   psi_mean = 0, psi_sd = 1)
real_doses = c(1.0, 2.0, 4.0, 6.6, 10.0)
model &lt;- get_trialr_efftox(real_doses = real_doses,
                           efficacy_hurdle = 0.5, toxicity_hurdle = 0.3,
                           p_e = 0.1, p_t = 0.1,
                           eff0 = 0.5, tox1 = 0.65,
                           eff_star = 0.7, tox_star = 0.25,
                           priors = p, iter = 1000, chains = 1, seed = 2020)
x &lt;- model %&gt;% fit('1N 2E 3B')
utility(x)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
