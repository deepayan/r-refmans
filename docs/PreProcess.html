<!DOCTYPE html><html lang="en"><head><title>Help for package PreProcess</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {PreProcess}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#Channel-class'><p>Class &quot;Channel&quot;</p></a></li>
<li><a href='#channelize-method'><p>Method &quot;channelize&quot;</p></a></li>
<li><a href='#ChannelType-class'><p>Class &quot;ChannelType&quot;</p></a></li>
<li><a href='#CompleteChannel-class'><p>Class &quot;CompleteChannel&quot;</p></a></li>
<li><a href='#generics'><p>Methods &quot;process&quot; and &quot;analyze&quot;</p></a></li>
<li><a href='#graph.utility'><p>OOMPA graphical utility functions</p></a></li>
<li><a href='#matrix.utility'><p>OOMPA Matrix Utility Functions</p></a></li>
<li><a href='#Pipeline-class'><p>Class &quot;Pipeline&quot;</p></a></li>
<li><a href='#Processor-class'><p>Class &quot;Processor&quot;</p></a></li>
<li><a href='#stat.utility'><p>OOMPA Statistical Utility Functions</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Version:</td>
<td>3.1.7</td>
</tr>
<tr>
<td>Date:</td>
<td>2019-05-01</td>
</tr>
<tr>
<td>Title:</td>
<td>Basic Functions for Pre-Processing Microarrays</td>
</tr>
<tr>
<td>Author:</td>
<td>Kevin R. Coombes</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Kevin R. Coombes &lt;krc@silicovore.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides classes to pre-process microarray gene
  expression data as part of the OOMPA collection of packages
  described at <a href="http://oompa.r-forge.r-project.org/">http://oompa.r-forge.r-project.org/</a>.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0), methods, graphics, stats, oompaBase (&ge; 3.0)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.apache.org/licenses/LICENSE-2.0">Apache License (== 2.0)</a></td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>biocViews:</td>
<td>Microarray, PreProcessing</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="http://oompa.r-forge.r-project.org/">http://oompa.r-forge.r-project.org/</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2019-05-06 12:38:02 UTC; Kevin Coombes</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2019-05-06 16:30:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='Channel-class'>Class &quot;Channel&quot;</h2><span id='topic+Channel-class'></span><span id='topic+Channel'></span><span id='topic+plot+2CChannel+2Cmissing-method'></span><span id='topic+hist+2CChannel-method'></span><span id='topic+summary+2CChannel-method'></span><span id='topic+print+2CChannel-method'></span><span id='topic+show+2CChannel-method'></span><span id='topic+image+2CChannel-method'></span>

<h3>Description</h3>

<p>An object of the <code>Channel</code> class represents a single kind of
measurement performed at all spots of a microarray channel. These
objects are essentially just vectors of data, with length equal to the
number of spots on the microarray, with some extra metadata attached.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Channel(parent, name, type, vec)
## S4 method for signature 'Channel,missing'
plot(x, y, ...)
## S4 method for signature 'Channel'
hist(x, breaks=67, xlab=x@name, main=x@parent, ...)
## S4 method for signature 'Channel'
summary(object, ...)
## S4 method for signature 'Channel'
print(x, ...)
## S4 method for signature 'Channel'
show(object)
## S4 method for signature 'Channel'
image(x, main=x@name, sub=NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Channel-class_+3A_parent">parent</code></td>
<td>
<p>character string representing the name of a parent object from
which this object was derived</p>
</td></tr>
<tr><td><code id="Channel-class_+3A_name">name</code></td>
<td>
<p>character string with a displayable name for this object</p>
</td></tr>
<tr><td><code id="Channel-class_+3A_type">type</code></td>
<td>
<p>object of class <code><a href="#topic+ChannelType">ChannelType</a></code></p>
</td></tr>
<tr><td><code id="Channel-class_+3A_vec">vec</code></td>
<td>
<p>numeric vector</p>
</td></tr>
<tr><td><code id="Channel-class_+3A_x">x</code></td>
<td>
<p>object of class <code>Channel</code></p>
</td></tr>
<tr><td><code id="Channel-class_+3A_y">y</code></td>
<td>
<p>nothing; the new Rd format requires documenting missing parameters</p>
</td></tr>
<tr><td><code id="Channel-class_+3A_breaks">breaks</code></td>
<td>
<p>see the documentation for the default <code><a href="graphics.html#topic+hist">hist</a></code></p>
</td></tr>
<tr><td><code id="Channel-class_+3A_xlab">xlab</code></td>
<td>
<p>character string specifying the label for x axis</p>
</td></tr>
<tr><td><code id="Channel-class_+3A_main">main</code></td>
<td>
<p>character string specifying the main title for the plot</p>
</td></tr>
<tr><td><code id="Channel-class_+3A_sub">sub</code></td>
<td>
<p>character string specifying subtitle for the plot</p>
</td></tr>
<tr><td><code id="Channel-class_+3A_object">object</code></td>
<td>
<p>object of class <code>Channel</code></p>
</td></tr>
<tr><td><code id="Channel-class_+3A_...">...</code></td>
<td>
<p>extra arguments for generic or plotting routines</p>
</td></tr>
</table>


<h3>Details</h3>

<p>As described in the help pages for <code><a href="#topic+ChannelType">ChannelType</a></code>, each
microarray hybridization experiment produces one or more channels of
data. <code>Channel</code> objects represent a single measurement performed
at spots in one microarray channel. The raw data from a full experiment
typically contains multiple measurements in multiple channels.
</p>
<p>The full set of measurements is often highly processed (by, for example,
background subtraction, normalization, log transformation, etc.) before it
becomes useful. We have added a <code>history</code> slot that keeps track of how
a <code>Channel</code> was produced. By allowing each object to maintain a record
of its history, it becomes easier to document the processing when writing up
the methods for reports or papers. The <code>history</code> slot of the object is
updated using the generic function <code><a href="#topic+process">process</a></code> together with a
<code><a href="#topic+Processor">Processor</a></code> object.
</p>


<h3>Value</h3>

<p>The <code>print</code>, <code>hist</code>, and <code>image</code> methods all invisibly
return the <code>Channel</code> object on which they were invoked.
</p>
<p>The <code>print</code> and <code>summary</code> methods return nothing.
</p>


<h3>Slots</h3>


<dl>
<dt><code>parent</code>:</dt><dd><p>character string representing the name of a parent
object from which this object was derived.
</p>
</dd>
<dt><code>name</code>:</dt><dd><p>character string with a displayable name for this
object</p>
</dd>
<dt><code>type</code>:</dt><dd><p>object of class <code><a href="#topic+ChannelType">ChannelType</a></code></p>
</dd>
<dt><code>x</code>:</dt><dd><p>numeric vector</p>
</dd>
<dt><code>history</code>:</dt><dd><p>list that keeps a record of the calls used
to produce this object</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>print(object, ...)</dt><dd><p>Print all the data on the object. Since
this includes the entire data vector, you rarely want to do this.</p>
</dd>
<dt>show(object)</dt><dd><p>Print all the data on the object. Since
this includes the entire data vector, you rarely want to do this.</p>
</dd>
<dt>summary(object, ...)</dt><dd><p>Write out a summary of the object.</p>
</dd>
<dt>plot(object, ...)</dt><dd><p>Produce a scatter plot of the measurement
values in the slot <code>x</code> of the <code>object</code> against their
index , which serves as a surrogate for the position on the
microarray. Additional graphical parameters are passed along.</p>
</dd>
<dt>hist(object, ...)</dt><dd><p>Produce a histogram of the data values in slot
<code>x</code> of the <code>object</code>. Additional graphical parameters are
passed along.</p>
</dd>
<dt>image(object, ...)</dt><dd><p>This method produces a two-dimensional
&quot;cartoon&quot; image of the measurement values, with the position in
the cartoon corresponding to the two-dimensional arrangement of
spots on the actual microarray. Additional graphical parameters
are passed along.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Kevin R. Coombes <a href="mailto:krc@silicovore.com">krc@silicovore.com</a>,
P. Roebuck <a href="mailto:proebuck@mdanderson.org">proebuck@mdanderson.org</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ChannelType">ChannelType</a></code>,
<code><a href="#topic+process">process</a></code>,
<code><a href="#topic+Processor">Processor</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>showClass("Channel")

## simulate a moderately realistic looking microarray
nc &lt;- 100			# number of rows
nr &lt;- 100			# number of columns
v &lt;- rexp(nc*nr, 1/1000)	# "true" signal intensity (vol)
b &lt;- rnorm(nc*nr, 80, 10)	# background noise
s &lt;- sapply(v-b, max, 1)	# corrected signal intensity (svol)
ct &lt;- ChannelType('user', 'random', nc, nr,  'fake')
raw &lt;- Channel(name='fraud', type=ct, parent='', vec=v)
subbed &lt;- Channel(name='fraud', parent='', type=ct, vec=s)
rm(nc, nr, v, b, s)		# clean some stuff

summary(subbed)
summary(raw)

par(mfrow=c(2,1))
plot(raw)
hist(raw)

par(mfrow=c(1,1))
image(raw)

## finish the cleanup
rm(ct, raw, subbed)
</code></pre>

<hr>
<h2 id='channelize-method'>Method &quot;channelize&quot;</h2><span id='topic+channelize'></span><span id='topic+channelize-method'></span><span id='topic+channelize+2CANY-method'></span>

<h3>Description</h3>

<p><code>channelize</code> is a generic function used to propagate the class of
derived objects through a processing pipeline.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'ANY'
channelize(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="channelize-method_+3A_object">object</code></td>
<td>
<p>an object for which pipeline propagation is desired</p>
</td></tr>
<tr><td><code id="channelize-method_+3A_...">...</code></td>
<td>
<p>additional arguments affecting the elapsed time produced</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Having abstracted away the notion of extracting a particular
measurement from a <code><a href="#topic+CompleteChannel">CompleteChannel</a></code> object and producing 
a simple <code>Channel</code>, we need a way to allow object-oriented
programming and derived classes to work with our
<code><a href="#topic+Processor">Processor</a></code> and <code><a href="#topic+Pipeline">Pipeline</a></code> routines. The
underlying idea is that specific kinds of microarrays or specific
software to quantify microarrays might have special properties that
should be exploited in processing. For example, the first few
generations of microarrays printed at M.D. Anderson spotted every cDNA
clone in duplicate. The analysis of such arrays should exploit this
additional structure. In order to do so, we must derive classes from
<code>CompleteChannel</code> and <code>Channel</code> and ensure that the classes
of extracted objects are propagated correctly through the processing
pipeline. The <code>channelize</code> method achieves this goal.
</p>


<h3>Value</h3>

<p>Returns a string, which represents the name of a class (suitable for
passing to the <code>new</code> constructor) extracted from an object
belonging to a class derived from <code><a href="#topic+CompleteChannel">CompleteChannel</a></code>.
</p>


<h3>Note</h3>

<p>The sections above document the method's usage by OOMPA's pipeline,
not the actual intent of the generic itself.
</p>


<h3>Author(s)</h3>

<p>Kevin R. Coombes <a href="mailto:krc@silicovore.com">krc@silicovore.com</a>,
P. Roebuck <a href="mailto:proebuck@mdanderson.org">proebuck@mdanderson.org</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Channel">Channel</a></code>,
<code><a href="#topic+CompleteChannel">CompleteChannel</a></code>,
<code><a href="#topic+Pipeline">Pipeline</a></code>,
<code><a href="#topic+Processor">Processor</a></code>
</p>

<hr>
<h2 id='ChannelType-class'>Class &quot;ChannelType&quot;</h2><span id='topic+ChannelType-class'></span><span id='topic+ChannelType'></span><span id='topic+print+2CChannelType-method'></span><span id='topic+show+2CChannelType-method'></span><span id='topic+summary+2CChannelType-method'></span><span id='topic+setDesign'></span><span id='topic+getDesign'></span>

<h3>Description</h3>

<p>This class represents the &quot;type&quot; of a microarray channel. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ChannelType(mk, md, nc, nr, gl, design="")
setDesign(object, design)
getDesign(object)
## S4 method for signature 'ChannelType'
print(x, ...)
## S4 method for signature 'ChannelType'
show(object)
## S4 method for signature 'ChannelType'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ChannelType-class_+3A_mk">mk</code></td>
<td>
<p>character string specifying the name of the manufacturer of the
microarray (e.g., 'Affymetrix') </p>
</td></tr>
<tr><td><code id="ChannelType-class_+3A_md">md</code></td>
<td>
<p>character string specifying the model of the microarray
(e.g., 'Hu95A')</p>
</td></tr>
<tr><td><code id="ChannelType-class_+3A_nc">nc</code></td>
<td>
<p>scalar integer specifying the number of columns in the array</p>
</td></tr>
<tr><td><code id="ChannelType-class_+3A_nr">nr</code></td>
<td>
<p>scalar integer specifying the number of rows in the array</p>
</td></tr>
<tr><td><code id="ChannelType-class_+3A_gl">gl</code></td>
<td>
<p>character string specifying the material used to label samples</p>
</td></tr>
<tr><td><code id="ChannelType-class_+3A_design">design</code></td>
<td>
<p>character string containing the name of an object describing
details about the design of the microarray</p>
</td></tr>
<tr><td><code id="ChannelType-class_+3A_object">object</code></td>
<td>
<p>object of class <code>ChannelType</code></p>
</td></tr>
<tr><td><code id="ChannelType-class_+3A_x">x</code></td>
<td>
<p>object of class <code>ChannelType</code></p>
</td></tr>
<tr><td><code id="ChannelType-class_+3A_...">...</code></td>
<td>
<p>extra arguments for generic or plotting routines</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Microarrays come in numerous flavors. At present, the two most common
types are the synthesized oligonucleotide arrays produced by
Affymetrix and the printed cDNA arrays on glass, which started in Pat
Brown's lab at Stanford. In earlier days, it was also common to find
nylon microarrays, with the samples labeled using a radioactive
isotope. The glass arrays are distinguished from other kinds of
arrays in that they typically cohybridize two different samples
simultaneously, using two different fluorescent dyes. The fluorescence
from each dye is scanned separately, producing two images and thus two
related sets of data from the same microarray. We refer to these
parallel data sets within an array as &ldquo;channels&rdquo;.
</p>
<p>An object of the <code>ChannelType</code> class represents a combination of
the kind of microarray along with the kind of labeling procedure.
These objects are intended to be passed around as part of more complex
objects representing the actual gene expression data collected from
particular experiments, in order to be able to eventually tie back into
the description of what spots were laid down when the array was produced.
</p>
<p>The <code>ChannelType</code> object only contains a high level description
of the microarray, however. Detailed information about what
biological material was laid down at each spot on the microarray is
stored elsewhere, in a &ldquo;design&rdquo; object. Within a <code>ChannelType</code>
object, the design is represented simply by a character string. This
string should be the name of a separate object containing the detailed
design information. This implementation allows us to defer the design
details until later. It also saves space by putting the details in a
single object instead of copying them into every microarray. Finally,
it allows that single object to be updated when better biological
annotations are available, with the benefits spreading immediately to
all the microarray projects that use that design.
</p>


<h3>Value</h3>

<p>The <code>ChannelType</code> constructor returns a valid object of the
class.
</p>
<p>The <code>setDesign</code> function invisibly returns the <code>ChannelType</code>
object on which it was invoked.
</p>
<p>The <code>getDesign</code> function returns the design object referred to by
the <code>design</code> slot in the <code>ChannelType</code> object. If this string
does not evaluate to the name of an object, then <code>getDesign</code> returns
a <code>NULL</code> value.
</p>


<h3>Slots</h3>


<dl>
<dt><code>maker</code>:</dt><dd><p>character string specifying the name of the
manufacturer of the microarray</p>
</dd>
<dt><code>model</code>:</dt><dd><p>character string specifying the model of the
microarray</p>
</dd> 
<dt><code>nCol</code>:</dt><dd><p>scalar integer specifying number of columns in the array</p>
</dd>
<dt><code>nRow</code>:</dt><dd><p>scalar integer specifying number of rows in the array</p>
</dd>
<dt><code>glow</code>:</dt><dd><p>character string specifying the material used to label
samples</p>
</dd>
<dt><code>design</code>:</dt><dd><p>character string containing the name of an object
describing details about the design of the microarray</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>print(x, ...)</dt><dd><p>Prints all the information in the object</p>
</dd>
<dt>show(object)</dt><dd><p>Prints all the information in the object</p>
</dd>
<dt>summary(object, ...)</dt><dd><p>Writes out a summary of the object</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Kevin R. Coombes <a href="mailto:krc@silicovore.com">krc@silicovore.com</a>,
P. Roebuck <a href="mailto:proebuck@mdanderson.org">proebuck@mdanderson.org</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Channel">Channel</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>showClass("ChannelType")

x &lt;- ChannelType('Affymetrix', 'oligo', 100, 100, 'fluor')
x
print(x)
summary(x)

y &lt;- setDesign(x, 'fake.design')
print(y)
summary(y)
d &lt;- getDesign(y)
d

rm(d, x, y) # cleanup
</code></pre>

<hr>
<h2 id='CompleteChannel-class'>Class &quot;CompleteChannel&quot;</h2><span id='topic+CompleteChannel-class'></span><span id='topic+CompleteChannel'></span><span id='topic+print+2CCompleteChannel-method'></span><span id='topic+show+2CCompleteChannel-method'></span><span id='topic+summary+2CCompleteChannel-method'></span><span id='topic+channelize+2CCompleteChannel-method'></span><span id='topic+plot+2CCompleteChannel+2Cmissing-method'></span><span id='topic+image+2CCompleteChannel-method'></span><span id='topic+as.data.frame+2CCompleteChannel-method'></span><span id='topic+analyze+2CCompleteChannel-method'></span><span id='topic+process+2CCompleteChannel+2CProcessor-method'></span><span id='topic+PROC.BACKGROUND'></span><span id='topic+PROC.SIGNAL'></span><span id='topic+PROC.CORRECTED.SIGNAL'></span><span id='topic+PROC.NEG.CORRECTED.SIGNAL'></span><span id='topic+PROC.SD.SIGNAL'></span><span id='topic+PROC.SIGNAL.TO.NOISE'></span>

<h3>Description</h3>

<p>An object of the <code>CompleteChannel</code> class represents one channel (red or
green) of a two-color fluorescence microarray experiment. Alternatively,
it can also represent the entirety of a radioactive microarray experiment.
Affymetrix experiments produce data with a somewhat different structure
because they use multiple probes for each target gene.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CompleteChannel(name, type, data)
## S4 method for signature 'CompleteChannel'
print(x, ...)
## S4 method for signature 'CompleteChannel'
show(object)
## S4 method for signature 'CompleteChannel'
summary(object, ...)
## S4 method for signature 'CompleteChannel'
as.data.frame(x, row.names=NULL, optional=FALSE)
## S4 method for signature 'CompleteChannel,missing'
plot(x, main=x@name, useLog=FALSE, ...)
## S4 method for signature 'CompleteChannel'
image(x, ...)
## S4 method for signature 'CompleteChannel'
analyze(object, useLog=FALSE, ...)
## S4 method for signature 'CompleteChannel,Processor'
process(object, action, parameter)
## S4 method for signature 'CompleteChannel'
channelize(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CompleteChannel-class_+3A_name">name</code></td>
<td>
<p>character string specifying the name of the object</p>
</td></tr>
<tr><td><code id="CompleteChannel-class_+3A_type">type</code></td>
<td>
<p>object of class <code><a href="#topic+ChannelType">ChannelType</a></code></p>
</td></tr>
<tr><td><code id="CompleteChannel-class_+3A_data">data</code></td>
<td>
<p>data frame. For the pre-defined &ldquo;extraction&rdquo;
processors to work correctly, this should include columns called
<code>vol</code>, <code>bkgd</code>, <code>svol</code>, <code>SD</code>, and <code>SN</code>.</p>
</td></tr>
<tr><td><code id="CompleteChannel-class_+3A_x">x</code></td>
<td>
<p>object of class <code>CompleteChannel</code></p>
</td></tr>
<tr><td><code id="CompleteChannel-class_+3A_object">object</code></td>
<td>
<p>object of class <code>CompleteChannel</code></p>
</td></tr>
<tr><td><code id="CompleteChannel-class_+3A_main">main</code></td>
<td>
<p>character string specifying the title for the plot</p>
</td></tr>
<tr><td><code id="CompleteChannel-class_+3A_uselog">useLog</code></td>
<td>
<p>logical scalar. If <code>TRUE</code>, convert to logarithmic values.</p>
</td></tr>
<tr><td><code id="CompleteChannel-class_+3A_action">action</code></td>
<td>
<p>object of class <code>Processor</code> used to process a
<code>CompleteChannel</code></p>
</td></tr>
<tr><td><code id="CompleteChannel-class_+3A_parameter">parameter</code></td>
<td>
<p>any object that makes sense as a parameter to the
function represented by the <code>Processor</code> <code>action</code></p>
</td></tr>
<tr><td><code id="CompleteChannel-class_+3A_row.names">row.names</code></td>
<td>
<p>See <code><a href="base.html#topic+as.data.frame">as.data.frame</a></code></p>
</td></tr>
<tr><td><code id="CompleteChannel-class_+3A_optional">optional</code></td>
<td>
<p>See <code><a href="base.html#topic+as.data.frame">as.data.frame</a></code></p>
</td></tr>
<tr><td><code id="CompleteChannel-class_+3A_...">...</code></td>
<td>
<p>extra arguments for generic or plotting routines</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The names come from the default column names in the ArrayVision software
package used at M.D. Anderson for quantifying glass or nylon microarrays.
Column names used by other software packages should be mapped to these.
</p>


<h3>Value</h3>

<p>The <code>analyze</code> method returns a list of three density functions.
</p>
<p>The return value of the <code>process</code> function depends on the
<code><a href="#topic+Processor">Processor</a></code> performing the action, but is typically a
<code><a href="#topic+Channel">Channel</a></code> object.
</p>
<p>Graphical methods invisibly return the object on which they were
invoked. 
</p>


<h3>Slots</h3>


<dl>
<dt><code>name</code>:</dt><dd><p>character string containing the name of the object</p>
</dd>
<dt><code>type</code>:</dt><dd><p>object of class <code><a href="#topic+ChannelType">ChannelType</a></code></p>
</dd>
<dt><code>data</code>:</dt><dd><p>data frame</p>
</dd>
<dt><code>history</code>:</dt><dd><p>list that keeps a record of the calls used
to produce this object</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>print(x, ...)</dt><dd><p>Print all the data on the object. Since
this includes the data frame, you rarely want to do this.</p>
</dd>
<dt>show(object)</dt><dd><p>Print all the data on the object. Since
this includes the data frame, you rarely want to do this.</p>
</dd>
<dt>summary(object, ...)</dt><dd><p>Write out a summary of the object.</p>
</dd>
<dt>as.data.frame(x,row.names=NULL, optional=FALSE)</dt><dd><p>Convert the
<code>CompleteChannel</code> object into a data frame. As you might
expect, this simply returns the data frame in the <code>data</code> slot
of the object.</p>
</dd>
<dt>plot(x, useLog=FALSE, ...)</dt><dd><p>Produces three estimated density
plots: one for the signal, one for the background, and one for
the background-corrected signal. Additional graphical parameters
are passed along. The logical flag <code>useLog</code> determines
whether the data are log-transformed before estimating and
plotting densities.</p>
</dd> 
<dt>analyze(object, useLog=FALSE, ...)</dt><dd><p>This method computes the
estimated probability density functions for the three data
components (signal, background, and background-corrected signal),
and returns them as a list. </p>
</dd>
<dt>image(object, ...)</dt><dd><p>Uses the image method for
<code><a href="#topic+Channel">Channel</a></code> objects to produce geographically aligned
images of the log-transformed intensity and background estimates.</p>
</dd>
<dt>channelize(object, ...)</dt><dd><p>character string giving the name of the
class of a channel that is produced when you process a
<code>CompleteChannel</code> object.</p>
</dd>
<dt>process(object, action, parameter=NULL)</dt><dd><p>Use the
<code>Processor</code> <code>action</code> to process the
<code>CompleteChannel</code> <code>object</code>. Returns an object of the
class described by <code>channelize</code>, which defaults to
<code>Channel</code>.</p>
</dd>
</dl>



<h3>Pre-defined Processors</h3>

<p>The library comes with several <code>Processor</code> objects already
defined; each one takes a <code>CompleteChannel</code> as input, extracts a
single value per spot, and produces a <code>Channel</code> as output.
</p>

<dl>
<dt><code>PROC.BACKGROUND</code></dt><dd><p>Extract the vector of local
background measurements.</p>
</dd>
<dt><code>PROC.SIGNAL</code></dt><dd><p>Extract the vector of foreground signal
intensity measurements. </p>
</dd>
<dt><code>PROC.CORRECTED.SIGNAL</code></dt><dd><p>Extract the vector of
background-corrected signal measurements. Note that many software
packages automatically truncate these value below at zero, so this
need not be the same as SIGNAL - BACKGROUND.</p>
</dd>
<dt><code>PROC.NEG.CORRECTED.SIGNAL</code></dt><dd><p>Extract the vector of
background-corrected signal intensities by subtracting the local
background from the observed foreground, without truncation.</p>
</dd>
<dt><code>PROC.SD.SIGNAL</code></dt><dd><p>Extract the vector of pixel standard
deviations of the signal intensity.</p>
</dd>
<dt><code>PROC.SIGNAL.TO.NOISE</code></dt><dd><p>Extract the vector of
signal-to-noise ratios, defined as CORRECTED.SIGNAL divided by the
standard deviation of the background pixels.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Kevin R. Coombes <a href="mailto:krc@silicovore.com">krc@silicovore.com</a>,
P. Roebuck <a href="mailto:proebuck@mdanderson.org">proebuck@mdanderson.org</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+process">process</a></code>,
<code><a href="#topic+Processor">Processor</a></code>,
<code><a href="#topic+Pipeline">Pipeline</a></code>,
<code><a href="#topic+Channel">Channel</a></code>,
<code><a href="base.html#topic+as.data.frame">as.data.frame</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>showClass("CompleteChannel")

## simulate a complete channel object
v &lt;- rexp(10000, 1/1000)
b &lt;- rnorm(10000, 60, 6)
s &lt;- sapply(v-b, function(x) {max(0, x)})
ct &lt;- ChannelType('user', 'random', 100, 100, 'fake')
x &lt;- CompleteChannel(name='fraud', type=ct,
                      data=data.frame(vol=v, bkgd=b, svol=s))
rm(v, b, s, ct)

summary(x)

opar &lt;- par(mfrow=c(2,3))
plot(x)
plot(x, main='Log Scale', useLog=TRUE)
par(opar)

opar &lt;- par(mfrow=c(2,1))
image(x)
par(opar)

b &lt;- process(x, PROC.NEG.CORRECTED.SIGNAL)
summary(b)

q &lt;- process(b, PIPELINE.STANDARD)
summary(q)

q &lt;- process(x, PIPELINE.MDACC.DEFAULT)
summary(q)

## cleanup
rm(x, b, q, opar)
</code></pre>

<hr>
<h2 id='generics'>Methods &quot;process&quot; and &quot;analyze&quot;</h2><span id='topic+process'></span><span id='topic+process+2CANY-method'></span><span id='topic+analyze'></span><span id='topic+analyze+2CANY-method'></span>

<h3>Description</h3>

<p>New generic functions for processing and analyzing microarrays.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'ANY'
process(object, action, parameter=NULL)
## S4 method for signature 'ANY'
analyze(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="generics_+3A_object">object</code></td>
<td>
<p>any OOMPA class representing a microarrays or a set of
microarrays</p>
</td></tr> 
<tr><td><code id="generics_+3A_action">action</code></td>
<td>
<p>the action to process the class</p>
</td></tr>
<tr><td><code id="generics_+3A_parameter">parameter</code></td>
<td>
<p>any parameters needed to execute the process</p>
</td></tr>
<tr><td><code id="generics_+3A_...">...</code></td>
<td>
<p>extra arguments for generic routines</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In general, the <code>analyze</code> method represents an expensive computational
step carried out in preparation for a graphical display, but the semantics
may differ from class to class. The default implementation of the method
performs the null analysis; that is, the return value is identical to the
object that is passed in as the first argument.
</p>
<p>The <code>process</code> method represents a function that acts on the data
of some object to process it in some way. For example, normalizing a
set of microarray data is typically one processing step in a long series
that is required to take the raw data and turn it into something useful.
</p>


<h3>Value</h3>

<p>The form of the value returned by either <code>process</code> or <code>analyze</code>
depends on the class of its argument. See the documentation of the particular
methods for details of what is produced by that method.
</p>


<h3>Author(s)</h3>

<p>Kevin R. Coombes <a href="mailto:krc@silicovore.com">krc@silicovore.com</a>,
P. Roebuck <a href="mailto:proebuck@mdanderson.org">proebuck@mdanderson.org</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Pipeline">Pipeline</a></code>,
<code><a href="#topic+Processor">Processor</a></code>
</p>

<hr>
<h2 id='graph.utility'>OOMPA graphical utility functions</h2><span id='topic+ellipse'></span><span id='topic+f.qq'></span><span id='topic+f.qt'></span>

<h3>Description</h3>

<p>Utility functions for graphics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ellipse(a, b, x0=0, y0=0, ...)
f.qq(x, main="", cut=0, ...)
f.qt(x, df, main="", cut=0, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="graph.utility_+3A_a">a</code></td>
<td>
<p> Half the length of the elliptical axis in the x-direction </p>
</td></tr>
<tr><td><code id="graph.utility_+3A_b">b</code></td>
<td>
<p> Half the length of the elliptical axis in the y-direction </p>
</td></tr>
<tr><td><code id="graph.utility_+3A_x0">x0</code></td>
<td>
<p> X-coordinate of the center of the ellipse</p>
</td></tr>
<tr><td><code id="graph.utility_+3A_y0">y0</code></td>
<td>
<p> Y-coordinate of the center of the ellipse</p>
</td></tr>
<tr><td><code id="graph.utility_+3A_main">main</code></td>
<td>
<p> A text string</p>
</td></tr>
<tr><td><code id="graph.utility_+3A_cut">cut</code></td>
<td>
<p> A real number</p>
</td></tr>
<tr><td><code id="graph.utility_+3A_df">df</code></td>
<td>
<p> An integer; the number of degrees of freedom in the t-test </p>
</td></tr>
<tr><td><code id="graph.utility_+3A_...">...</code></td>
<td>
<p> Additional graphical parameters passed on to lower-level
functions </p>
</td></tr>
<tr><td><code id="graph.utility_+3A_x">x</code></td>
<td>
<p>A numeric vector</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>ellipse</code> function draws an ellipse on an existing plots.
The ellipses produced by this function are oriented with their major
and minor axes parallel to the coordinate axes. The current
implementation uses <code><a href="graphics.html#topic+points">points</a></code> internally.
</p>
<p>The function <code>f.qq</code> is a wrapper that combines <code>qqnorm</code> and
<code>qqline</code> into a single function call.
</p>
<p>The function <code>f.qt</code> is a wrapper that produces quantile-quantile
plots comparing the observed vector <code>x</code> with a T-distribution.
</p>


<h3>Author(s)</h3>

<p>Kevin R. Coombes <a href="mailto:krc@silicovore.com">krc@silicovore.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="graphics.html#topic+points">points</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rnorm(1000, 1, 2)
y &lt;- rnorm(1000, 1, 2)
plot(x,y)
ellipse(1, 1, col=6, type='l', lwd=2)
ellipse(3, 2, col=6, type='l', lwd=2)
f.qq(x, main='Demo', col='blue')
f.qq(x, cut=3)
f.qt(x, df=3)
f.qt(x, df=40)
</code></pre>

<hr>
<h2 id='matrix.utility'>OOMPA Matrix Utility Functions</h2><span id='topic+flipud'></span><span id='topic+fliplr'></span>

<h3>Description</h3>

<p>Utility functions for manipulating matrices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>flipud(x)
fliplr(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="matrix.utility_+3A_x">x</code></td>
<td>
<p>a matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The <code>flipud</code> function returns a matrix the same size as <code>x</code>,
with the order of the rows reversed, so the matrix has been flipped
vertically. The <code>fliplr</code> function returns a matrix the same size
as <code>x</code> but flipped horizontally, with the order of the columns
reversed. 
</p>


<h3>Author(s)</h3>

<p>Kevin R. Coombes <a href="mailto:krc@silicovore.com">krc@silicovore.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mat &lt;- matrix(1:6, 2, 3)
mat
flipud(mat)
fliplr(mat)
</code></pre>

<hr>
<h2 id='Pipeline-class'>Class &quot;Pipeline&quot;</h2><span id='topic+Pipeline'></span><span id='topic+Pipeline-class'></span><span id='topic+process+2CANY+2CPipeline-method'></span><span id='topic+summary+2CPipeline-method'></span><span id='topic+PIPELINE.STANDARD'></span><span id='topic+PIPELINE.MDACC.DEFAULT'></span><span id='topic+makeDefaultPipeline'></span>

<h3>Description</h3>

<p>A <code>Pipeline</code> represents a standard multi-step procedure for
processing microarray data.  A <code>Pipeline</code> represents a series of
<code><a href="#topic+Processor">Processor</a></code>s that should be applied in order. You can
think of a pipeline as a completely defined (and reusable) set of
transformations that is applied uniformly to every microarray in a
data set.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'ANY,Pipeline'
process(object, action, parameter=NULL)
## S4 method for signature 'Pipeline'
summary(object, ...)
makeDefaultPipeline(ef = PROC.SIGNAL, ep = 0,
                    nf = PROC.GLOBAL.NORMALIZATION, np = 0,
                    tf = PROC.THRESHOLD, tp = 25,
                    lf = PROC.LOG.TRANSFORM, lp = 2,
                    name = "standard pipe",
                    description = "my method")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Pipeline-class_+3A_object">object</code></td>
<td>
<p>In the <code>process</code> method, any object appropriate for
the input to the <code>Pipeline</code>. In the <code>summary</code> method, a
<code>Pipeline</code> object. </p>
</td></tr> 
<tr><td><code id="Pipeline-class_+3A_action">action</code></td>
<td>
<p> A <code>Pipeline</code> object used to process an object. </p>
</td></tr>
<tr><td><code id="Pipeline-class_+3A_parameter">parameter</code></td>
<td>
<p>Irrelevant, since the <code>Pipeline</code> ignores the
parameter when <code>process</code> is invoked.</p>
</td></tr>
<tr><td><code id="Pipeline-class_+3A_...">...</code></td>
<td>
<p>Additional arguments are as in the underlying generic methods.</p>
</td></tr>
<tr><td><code id="Pipeline-class_+3A_ef">ef</code></td>
<td>
<p> &ldquo;Extractor function&rdquo;: First <code><a href="#topic+Processor">Processor</a></code> in
the <code>Pipeline</code>, typically a method that extracts a single kind
of raw measurement from a microarray</p>
</td></tr>
<tr><td><code id="Pipeline-class_+3A_ep">ep</code></td>
<td>
<p> Default parameter value for <code>ef</code></p>
</td></tr>
<tr><td><code id="Pipeline-class_+3A_nf">nf</code></td>
<td>
<p> &ldquo;Normalization function&rdquo; : Second <code><a href="#topic+Processor">Processor</a></code> in
the <code>Pipeline</code>, typically a normalization step. </p>
</td></tr>
<tr><td><code id="Pipeline-class_+3A_np">np</code></td>
<td>
<p> Default parameter value for <code>nf</code></p>
</td></tr>
<tr><td><code id="Pipeline-class_+3A_tf">tf</code></td>
<td>
<p> &ldquo;Threshold function&rdquo; : Third <code><a href="#topic+Processor">Processor</a></code> in
the <code>Pipeline</code>, typically a step that truncates data below at
some threshold. </p>
</td></tr>
<tr><td><code id="Pipeline-class_+3A_tp">tp</code></td>
<td>
<p> Default parameter value for <code>tf</code></p>
</td></tr>
<tr><td><code id="Pipeline-class_+3A_lf">lf</code></td>
<td>
<p> &ldquo;Log function&rdquo; : Fourth <code><a href="#topic+Processor">Processor</a></code> in
the <code>Pipeline</code>, typically a log transformation. </p>
</td></tr>
<tr><td><code id="Pipeline-class_+3A_lp">lp</code></td>
<td>
<p> Default parameter value for <code>lf</code></p>
</td></tr>
<tr><td><code id="Pipeline-class_+3A_name">name</code></td>
<td>
<p>A string; the name of the pipeline</p>
</td></tr>
<tr><td><code id="Pipeline-class_+3A_description">description</code></td>
<td>
<p>A string; a longer description of the pipeline</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A key feature of a <code>Pipeline</code> is that it is supposed to represent
a standard algorithm that is applied to all objects when processing a
microarray data set. For that reason, the <code>parameter</code> that can be
passed to the <code>process</code> function is ignored, ensuring that the
same parameter values are used to process all objects. By contrast,
each <code><a href="#topic+Processor">Processor</a></code> that is inserted into a <code>Pipeline</code>
allows the user to supply a parameter that overrides its default
value.
</p>
<p>We provide a single constructor, <code>makeDefaultPipeline</code> to build a
specialized kind of <code>Pipeline</code>, tailored to the analysis of
fluorescently labeled single channels in a microarray experiment. More
general <code>Pipeline</code>s can be constructed using <code>new</code>.
</p>


<h3>Value</h3>

<p>The return value of the generic function <code>process</code> is always
an object related to its input, which keeps a record of its
history. The precise class of the result depends on the functions used
to create the <code>Pipeline</code>. 
</p>


<h3>Slots</h3>


<dl>
<dt><code>proclist</code>:</dt><dd><p>A list of <code><a href="#topic+Processor">Processor</a></code> objects.</p>
</dd>
<dt><code>name</code>:</dt><dd><p>A string containing the name of the object</p>
</dd>
<dt><code>description</code>:</dt><dd><p>A string containing a longer description
of the object</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>process(object, action, parameter)</dt><dd><p>Apply the series of
functions represented by the <code>Pipeline</code> <code>action</code> to the
object, updating its history appropriately. The <code>parameter</code>
is ignored, since the <code>Pipeline</code> always uses its default
values.
</p>
</dd>
<dt>summary(object, ...)</dt><dd><p>Write out a summary of the object.</p>
</dd>
</dl>



<h3>Pre-defined Pipelines</h3>

<p>The library comes with two <code>Pipeline</code> objects already defined
</p>

<dl>
<dt><code>PIPELINE.STANDARD</code></dt><dd><p>Takes a <code><a href="#topic+Channel">Channel</a></code> object
as input. Performs global normalization by rescaling the 75th
percentile to 1000, truncates below at 25, then performs log
(base-two) transformation.
</p>
</dd>
<dt><code>PIPELINE.MDACC.DEFAULT</code></dt><dd><p>Takes a
<code><a href="#topic+CompleteChannel">CompleteChannel</a></code> as input, extracts the raw signal
intensity, and then performs the same processing as
<code>PIPELINE.STANDARD</code>. 
</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Kevin R. Coombes <a href="mailto:krc@silicovore.com">krc@silicovore.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Channel">Channel</a></code>,
<code><a href="#topic+CompleteChannel">CompleteChannel</a></code>,
<code><a href="#topic+process">process</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>showClass("Pipeline")

## simulate a moderately realistic looking microarray
nc &lt;- 100
nr &lt;- 100
v &lt;- rexp(nc*nr, 1/1000)
b &lt;- rnorm(nc*nr, 80, 10)
s &lt;- sapply(v-b, max, 1)
ct &lt;- ChannelType('user', 'random', nc, nr,  'fake')
subbed &lt;- Channel(name='fraud', parent='', type=ct, vec=s)
rm(ct, nc, nr, v, b, s)		# clean some stuff

## example of standard data processing
processed &lt;- process(subbed, PIPELINE.STANDARD)

summary(processed)

par(mfrow=c(2,1))
plot(processed)
hist(processed)

par(mfrow=c(1,1))
image(processed)

rm(subbed, processed)
</code></pre>

<hr>
<h2 id='Processor-class'>Class &quot;Processor&quot;</h2><span id='topic+Processor'></span><span id='topic+Processor-class'></span><span id='topic+summary+2CProcessor-method'></span><span id='topic+process+2CProcessor-method'></span><span id='topic+process+2CChannel+2CProcessor-method'></span><span id='topic+PROC.SUBTRACTOR'></span><span id='topic+PROC.THRESHOLD'></span><span id='topic+PROC.GLOBAL.NORMALIZATION'></span><span id='topic+PROC.LOG.TRANSFORM'></span><span id='topic+PROC.MEDIAN.EXPRESSED.NORMALIZATION'></span><span id='topic+PROC.SUBSET.NORMALIZATION'></span><span id='topic+PROC.SUBSET.MEAN.NORMALIZATION'></span>

<h3>Description</h3>

<p>A <code>Processor</code> represents a function that acts on the data of a some
object to process it in some way. The result is always another related
object, which should record some history about exactly how it was processed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Channel,Processor'
process(object, action, parameter=NULL)
## S4 method for signature 'Processor'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Processor-class_+3A_object">object</code></td>
<td>
<p>In the <code>process</code> method, a <code>Channel</code>
object. In the <code>summary</code> method, a <code>Processor</code> object</p>
</td></tr>
<tr><td><code id="Processor-class_+3A_action">action</code></td>
<td>
<p> A <code>Processor</code> object used to process a
<code>Channel</code>. </p>
</td></tr>
<tr><td><code id="Processor-class_+3A_parameter">parameter</code></td>
<td>
<p> Any object that makes sense as a parameter to the
function represented by the <code>Processor</code> <code>action</code></p>
</td></tr>
<tr><td><code id="Processor-class_+3A_...">...</code></td>
<td>
<p>Additional arguments are as in the underlying generic methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The return value of the generic function <code>process</code> is always
an object related to its <code>Channel</code> input, which keeps a record
of its history. The precise class of the result depends on the
function used to create the <code>Processor</code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>f</code>:</dt><dd><p>A function that will be used to process
microarray-related object</p>
</dd>
<dt><code>default</code>:</dt><dd><p>The default value of the parameters to the
function <code>f</code> </p>
</dd>
<dt><code>name</code>:</dt><dd><p>A string containing the name of the object</p>
</dd>
<dt><code>description</code>:</dt><dd><p>A string containing a longer description
of the object</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>process(object, action, parameter)</dt><dd><p>Apply the function
represented by <code>action</code> to the <code>Channel</code> object, updating
the history appropriately. If the <code>parameter</code> is <code>NULL</code>,
then use the default value.
</p>
</dd>
<dt>summary(object, ...)</dt><dd><p>Write out a summary of the object.</p>
</dd>
</dl>



<h3>Pre-defined Processors</h3>

<p>The library comes with several <code>Processor</code> objects already
defined; each one takes a <code>Channel</code> as input and produces a
modified <code>Channel</code> as output.
</p>

<dl>
<dt><code>PROC.SUBTRACTOR</code></dt><dd><p>Subtracts a global constant (default:
0) from the data vector in the <code>Channel</code>.</p>
</dd>
<dt><code>PROC.THRESHOLD</code></dt><dd><p>Truncates the data vector below,
replacing the values below a threshold (default: 0) with the
threshold value.</p>
</dd>
<dt><code>PROC.GLOBAL.NORMALIZATION</code></dt><dd><p>Normalizes the data vector
in the <code>Channel</code> by dividing by a global constant.  If the
parameter takes on its default value of 0, then divide by the 75th
percentile.
</p>
</dd>
<dt><code>PROC.LOG.TRANSFORM</code></dt><dd><p>Performs a log transformation of
the data vector. The parameter specifies the base of the logarithm
(default: 2).
</p>
</dd>
<dt><code>PROC.MEDIAN.EXPRESSED.NORMALIZATION</code></dt><dd><p>Normalizes the
data vector by dividing by the median of the expressed genes, where
&ldquo;expressed&rdquo; is taken to mean &ldquo;greater than zero&rdquo;.
</p>
</dd>
<dt><code>PROC.SUBSET.NORMALIZATION</code></dt><dd><p>Normalizes the data vector
by dividing by the median of a subset of genes.  When the
parameter has a default value of 0, then this method uses the
global median. Otherwise, the parameter should be set to a logical
or numerical vector that selects the subset of genes to be used
for normalization.
</p>
</dd>
<dt><code>PROC.SUBSET.MEAN.NORMALIZATION</code></dt><dd><p>Normalizes the data vector
by dividing by the mean of a subset of genes.  When the
parameter has a default value of 0, then this method uses the
global mean. Otherwise, the parameter should be set to a logical
or numerical vector that selects the subset of genes to be used
for normalization.
</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Kevin R. Coombes <a href="mailto:krc@silicovore.com">krc@silicovore.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Channel">Channel</a></code>,
<code><a href="#topic+CompleteChannel">CompleteChannel</a></code>,
<code><a href="#topic+process">process</a></code>,
<code><a href="#topic+Pipeline">Pipeline</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>showClass("Processor")

## simulate a moderately realistic looking microarray
nc &lt;- 100
nr &lt;- 100
v &lt;- rexp(nc*nr, 1/1000)
b &lt;- rnorm(nc*nr, 80, 10)
s &lt;- sapply(v-b, max, 1)
ct &lt;- ChannelType('user', 'random', nc, nr,  'fake')
subbed &lt;- Channel(name='fraud', parent='', type=ct, vec=s)
rm(ct, nc, nr, v, b, s)		# clean some stuff

## example of standard data processing
nor &lt;- process(subbed, PROC.GLOBAL.NORMALIZATION)
thr &lt;- process(nor, PROC.THRESHOLD, 25)
processed &lt;- process(thr, PROC.LOG.TRANSFORM, 2)

summary(processed)

par(mfrow=c(2,1))
plot(processed)
hist(processed)

par(mfrow=c(1,1))
image(processed)

rm(nor, thr, subbed, processed)
</code></pre>

<hr>
<h2 id='stat.utility'>OOMPA Statistical Utility Functions</h2><span id='topic+f.above.thresh'></span><span id='topic+f.cord'></span><span id='topic+f.oneway.rankings'></span>

<h3>Description</h3>

<p>Utility functions for statistical computations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>f.above.thresh(a, t)
f.cord(x, y, inf.rm)
f.oneway.rankings(r, s)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="stat.utility_+3A_a">a</code></td>
<td>
<p>a vector</p>
</td></tr>
<tr><td><code id="stat.utility_+3A_t">t</code></td>
<td>
<p>a real number</p>
</td></tr>
<tr><td><code id="stat.utility_+3A_x">x</code></td>
<td>
<p>a vector</p>
</td></tr>
<tr><td><code id="stat.utility_+3A_y">y</code></td>
<td>
<p>a vector</p>
</td></tr>
<tr><td><code id="stat.utility_+3A_inf.rm">inf.rm</code></td>
<td>
<p>a logical value</p>
</td></tr>
<tr><td><code id="stat.utility_+3A_r">r</code></td>
<td>
<p>vector</p>
</td></tr>
<tr><td><code id="stat.utility_+3A_s">s</code></td>
<td>
<p>vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>f.above.thresh</code> returns the fraction of elements in the vector
<code>a</code> that are greater than the threshold <code>t</code>.
</p>
<p><code>f.cord</code> returns the concordance coefficient between the two
input vectors <code>x</code> and <code>y</code>. If <code>inf.rm</code> is true, then
infinite values are removed before computing the concordance; missing
values are always removed.
</p>
<p><code>f.oneway.rankings</code> is implemented as <code>order(s)[r]</code> and I
cannot recall why we defined it or where we used it.
</p>


<h3>Author(s)</h3>

<p>Kevin R. Coombes <a href="mailto:krc@silicovore.com">krc@silicovore.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rnorm(1000, 1, 2)
y &lt;- rnorm(1000, 1, 2)
f.above.thresh(x, 0)
f.above.thresh(y, 0)
f.cord(x, y)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
