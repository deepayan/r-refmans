<!DOCTYPE html><html lang="en-US"><head><title>Help for package TIMP</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {TIMP}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#TIMP-package'><p>a problem solving environment for fitting separable nonlinear models in physics and chemistry applications</p></a></li>
<li><a href='#amp-class'><p>Class &quot;amp&quot; for diagonal matrix model specification.</p></a></li>
<li><a href='#baseIRF'><p>Baseline subtraction from a vector, usually representing an IRF.</p></a></li>
<li><a href='#dat-class'><p>Class &quot;dat&quot; for model and data storage</p></a></li>
<li><a href='#denS4'><p>Time-resolved absorption data</p></a></li>
<li><a href='#divergeZimage'><p>Plots a matrix with a diverging palette, with the center value of</p>
the palette possible to set</a></li>
<li><a href='#donorAcceptorTagged'><p>Fluorescent lifetime imaging microscopy (FLIM) data</p></a></li>
<li><a href='#donorTagged'><p>Fluorescent lifetime imaging microscopy (FLIM) data</p></a></li>
<li><a href='#efit2file'><p>Convert 'tim' FORTRAN efit files to plain matrices in ASCII files</p></a></li>
<li><a href='#examineFit'><p>Examines the results of a call to  fitModel</p></a></li>
<li><a href='#fit-class'><p>Class &quot;fit&quot; to store the results of model fitting associated with</p>
all datasets analyzed.</a></li>
<li><a href='#fitModel'><p>Performs optimization of (possibly multidataset) models.</p></a></li>
<li><a href='#FLIMplots'><p>Functions to plot FLIM results.</p></a></li>
<li><a href='#getClpindepX-methods'><p>Generic function getClpindepX in Package &lsquo;TIMP&rsquo;</p></a></li>
<li><a href='#getResid'><p>For data correction, fits a model (but ignores</p>
plotting commands) in order to obtain the SVD of the residuals, which
then can be used in data-correction.</a></li>
<li><a href='#getResults'><p>Functions to print and return parts of the object returned</p>
by the fitting routines.</a></li>
<li><a href='#initModel'><p>Defines the model to be used in analysis.</p></a></li>
<li><a href='#Internals'><p>TIMP function used internally</p></a></li>
<li><a href='#kin-class'><p>Class &quot;kin&quot; for kinetic model storage.</p></a></li>
<li><a href='#kinopt-class'><p>Class &quot;kinopt&quot; stores options for fitting and plotting kinetic models</p></a></li>
<li><a href='#mass-class'><p>Class &quot;mass&quot; for mass spectrometry model storage.</p></a></li>
<li><a href='#massopt-class'><p>Class &quot;massopt&quot; stores options for fitting and plotting models</p>
for mass spectrometry data</a></li>
<li><a href='#mea_IRF'><p>Instrument response for fluorescent lifetime imaging microscopy (FLIM) data</p></a></li>
<li><a href='#modifyModel'><p>Allows the starting values for parameters associated with a model</p>
to be updated with the values found in fitting the model.</a></li>
<li><a href='#multimodel-class'><p>Class &quot;multimodel&quot; for storage of multidataset models, data and the</p>
results of fitting.</a></li>
<li><a href='#multitheta-class'><p>Class &quot;multitheta&quot; that stores a list with one element of class</p>
&quot;theta&quot; for each dataset modeled.</a></li>
<li><a href='#opt-class'><p>Class &quot;opt&quot; stores options for fitting and plotting</p></a></li>
<li><a href='#outlierCorr'><p>Finds and removes outliers from a datasets</p></a></li>
<li><a href='#plotter-methods'><p>Generic function plotter in Package &lsquo;TIMP&rsquo;</p></a></li>
<li><a href='#preProcess'><p>Performs preprocessing on data stored as an objects of class dat.</p></a></li>
<li><a href='#readclp0'><p>This function reads in a specification of constraints to</p>
zero on the clp.</a></li>
<li><a href='#readData'><p>This function reads in data the ivo file format</p></a></li>
<li><a href='#res-class'><p>Class &quot;res&quot; to store the results of model fitting associated with</p>
a single dataset.</a></li>
<li><a href='#residPart-methods'><p>Generic function residPart in Package &lsquo;TIMP&rsquo;</p></a></li>
<li><a href='#spec-class'><p>Class &quot;spec&quot; for the storage of spectral models.</p></a></li>
<li><a href='#specopt-class'><p>Class &quot;specopt&quot; stores options for fitting and plotting spectral models</p></a></li>
<li><a href='#sumKinSpecEst'><p>Makes a summary plot of spectra associated with kinetic components</p>
alongside a plot showing parameter estimates</a></li>
<li><a href='#target'><p>Ultrafast time-resolved fluorescence data</p></a></li>
<li><a href='#theta-class'><p>Class &quot;theta&quot; for storage of nonlinear parameter estimates</p></a></li>
<li><a href='#writeAverage'><p>Writes the average of scans stored in a file to a new file in the</p>
'ivo' format</a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Fitting Separable Nonlinear Models in Spectroscopy and
Microscopy</td>
</tr>
<tr>
<td>Version:</td>
<td>1.13.6</td>
</tr>
<tr>
<td>Description:</td>
<td>A problem solving environment (PSE) for fitting separable
    nonlinear models to measurements arising in physics and chemistry
    experiments, as described by Mullen &amp; van Stokkum (2007)
    &lt;<a href="https://doi.org/10.18637%2Fjss.v018.i03">doi:10.18637/jss.v018.i03</a>&gt; for its use in fitting time resolved
    spectroscopy data, and as described by Laptenok et al. (2007)
    &lt;<a href="https://doi.org/10.18637%2Fjss.v018.i08">doi:10.18637/jss.v018.i08</a>&gt; for its use in fitting Fluorescence
    Lifetime Imaging Microscopy (FLIM) data, in the study of FÃ¶rster
    Resonance Energy Transfer (FRET).  'TIMP' also serves as the
    computation backend for the 'GloTarAn' software, a graphical user
    interface for the package, as described in Snellenburg et al. (2012)
    &lt;<a href="https://doi.org/10.18637%2Fjss.v049.i03">doi:10.18637/jss.v049.i03</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/glotaran/TIMP">https://github.com/glotaran/TIMP</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/glotaran/TIMP/issues">https://github.com/glotaran/TIMP/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>fields (&ge; 4.1), methods, R (&ge; 2.10.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>colorspace, deSolve, gclus, gplots, graphics, grDevices,
minpack.lm (&ge; 1.1-1), nnls (&ge; 1.1), splines, stats, utils</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-12-12 02:47:02 UTC; jsnel</td>
</tr>
<tr>
<td>Author:</td>
<td>Katharine M. Mullen [aut] (Original package creator),
  Joris Snellenburg <a href="https://orcid.org/0000-0002-1428-0221"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [cre, ctb],
  Sergey P. Laptenok [ctb],
  David Nicolaides [ctb],
  Ivo H.M. van Stokkum
    <a href="https://orcid.org/0000-0002-6143-2021"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Joris Snellenburg &lt;j.snellenburg@vu.nl&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-12-12 13:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='TIMP-package'>a problem solving environment for fitting separable nonlinear models in physics and chemistry applications</h2><span id='topic+TIMP-package'></span><span id='topic+TIMP'></span>

<h3>Description</h3>

<p>TIMP is a problem solving environment for fitting separable nonlinear models to measurements arising in physics and chemistry experiments, and has been extensively applied to time-resolved spectroscopy and FLIM-FRET data.
</p>


<h3>Author(s)</h3>

<p>Katharine M. Mullen, Ivo H. M. van Stokkum
Maintainer: Joris J. Snellenburg <a href="mailto:j.snellenburg@vu.nl">j.snellenburg@vu.nl</a>
</p>


<h3>References</h3>

<p>Mullen KM, van Stokkum IHM (2007). &ldquo;TIMP: An R Package for Modeling
Multi-way Spectroscopic Measurements.&rdquo; Journal of Statistical
Software, 18(3). <a href="https://doi.org/10.18637/jss.v018.i03">doi:10.18637/jss.v018.i03</a>.
</p>
<p>Laptenok S, Mullen KM, Borst JW, van Stokkum IHM, Apanasovich VV,
Visser AJWG (2007). &ldquo;Fluorescence Lifetime Imaging Microscopy (FLIM)
Data Analysis with TIMP.&rdquo;  Journal of Statistical Software,
18(8). <a href="https://doi.org/10.18637/jss.v018.i08">doi:10.18637/jss.v018.i08</a>.
</p>
<p>See <a href="https://glotaran.github.io/TIMP/">https://glotaran.github.io/TIMP/</a> for further documentation.
</p>

<hr>
<h2 id='amp-class'>Class &quot;amp&quot; for diagonal matrix model specification.</h2><span id='topic+amp-class'></span><span id='topic+amp'></span>

<h3>Description</h3>

 
<p><code>amp</code> is the class for diagonal matrix model specification;
such models are internally initialized when a tri-linear-type 
model is fit to the data via passing the argument <code>opt</code>
to <code>fitModel</code> as an object of class <code>opt</code> in which
the slot <code>trilinear</code> has the value <code>TRUE</code>.
All objects of class <code>amp</code> are sub-classes of 
class <code>dat</code>; see documentation for <code>dat</code> 
for a description of 
these slots.  </p>


<h3>Details</h3>

<p>See <code><a href="#topic+kin-class">kin-class</a></code> for an 
example of the initialization of a 
<code>kin</code> object via the <code>initModel</code> function. </p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("amp", ...)</code> or 
<code>amp(...)</code>.
</p>


<h3>Slots</h3>


<dl>
<dt>amps</dt><dd><p> list of vectors of starting values for the parameters
of the amplitudes for each dataset; one vector of values is
used to parameterize the values corresponding to each dataset. 
</p>
</dd>
<dt>autoclp0</dt><dd></dd>
<dt>C2</dt><dd></dd>
<dt>chinde</dt><dd></dd>
<dt>clinde</dt><dd></dd>
<dt>clp0</dt><dd></dd>
<dt>clpCon</dt><dd></dd>
<dt>clpdep</dt><dd></dd>
<dt>clpequ</dt><dd></dd>
<dt>clpequspec</dt><dd></dd>
<dt>clpequspecBD</dt><dd></dd>
<dt>clpType</dt><dd></dd>
<dt>cohcol</dt><dd></dd>
<dt>compnames</dt><dd></dd>
<dt>constrained</dt><dd></dd>
<dt>datafile</dt><dd></dd>
<dt>datCall</dt><dd></dd>
<dt>drel</dt><dd></dd>
<dt>dscalspec</dt><dd></dd>
<dt>E2</dt><dd></dd>
<dt>fixed</dt><dd></dd>
<dt>free</dt><dd></dd>
<dt>fvecind</dt><dd></dd>
<dt>getX</dt><dd></dd>
<dt>getXsuper</dt><dd></dd>
<dt>highcon</dt><dd></dd>
<dt>inten</dt><dd></dd>
<dt>iter</dt><dd></dd>
<dt>lclp0</dt><dd></dd>
<dt>lclpequ</dt><dd></dd>
<dt>lowcon</dt><dd></dd>
<dt>makeps</dt><dd></dd>
<dt>mhist</dt><dd></dd>
<dt>mod_type</dt><dd></dd>
<dt>mvecind</dt><dd></dd>
<dt>ncomp</dt><dd></dd>
<dt>nl</dt><dd></dd>
<dt>nt</dt><dd></dd>
<dt>nvecind</dt><dd></dd>
<dt>outMat</dt><dd></dd>
<dt>parnames</dt><dd></dd>
<dt>positivepar</dt><dd></dd>
<dt>prel</dt><dd></dd>
<dt>prelspec</dt><dd></dd>
<dt>psi.df</dt><dd></dd>
<dt>psi.weight</dt><dd></dd>
<dt>pvecind</dt><dd></dd>
<dt>satMat</dt><dd></dd>
<dt>scalx</dt><dd></dd>
<dt>sigma</dt><dd></dd>
<dt>simdata</dt><dd></dd>
<dt>title</dt><dd></dd>
<dt>usecompnames0</dt><dd></dd>
<dt>usecompnamesequ</dt><dd></dd>
<dt>weight</dt><dd></dd>
<dt>weightList</dt><dd></dd>
<dt>weightM</dt><dd></dd>
<dt>weightpar</dt><dd></dd>
<dt>weightsmooth</dt><dd></dd>
<dt>x</dt><dd></dd>
<dt>x2</dt><dd></dd>
</dl>



<h3>Extends</h3>

<p>Class <code><a href="#topic+kin-class">kin-class</a></code>, directly.
</p>


<h3>Author(s)</h3>

<p>Katharine M. Mullen, Ivo H. M. van Stokkum</p>


<h3>See Also</h3>

<p><code><a href="#topic+kin-class">kin-class</a></code>, <code><a href="#topic+spec-class">spec-class</a></code>, <code><a href="#topic+opt-class">opt-class</a></code>
</p>

<hr>
<h2 id='baseIRF'>Baseline subtraction from a vector, usually representing an IRF.</h2><span id='topic+baseIRF'></span>

<h3>Description</h3>

<p>Baseline subtraction from a vector, usually representing an IRF.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>baseIRF(irfvec, indexlow, indexhigh, removeNeg = FALSE) 
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="baseIRF_+3A_irfvec">irfvec</code></td>
<td>
<p>Vector to subtract a baseline from</p>
</td></tr>
<tr><td><code id="baseIRF_+3A_indexlow">indexlow</code></td>
<td>
<p>Lowest index to base the baseline estimation on</p>
</td></tr>
<tr><td><code id="baseIRF_+3A_indexhigh">indexhigh</code></td>
<td>
<p>Highest index to base the baseline estimation on</p>
</td></tr>
<tr><td><code id="baseIRF_+3A_removeneg">removeNeg</code></td>
<td>
<p>Whether negative values should be replaced with 0.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Currently estimates the baseline as the mean of data between 
indexlow and indexhigh, and subtracts the result from the 
entire vector.
</p>


<h3>Value</h3>

<p>vector</p>


<h3>Author(s)</h3>

<p>Katharine M. Mullen, Ivo H. M. van Stokkum</p>


<h3>Examples</h3>

<pre><code class='language-R'> 
irfvec &lt;- rnorm(128, mean=1) 
plot(irfvec,type="l") 
irfvec_corrected &lt;- baseIRF(irfvec, 1, 10)
lines(irfvec_corrected, col=2)
</code></pre>

<hr>
<h2 id='dat-class'>Class &quot;dat&quot; for model and data storage </h2><span id='topic+dat-class'></span><span id='topic+dat'></span>

<h3>Description</h3>

<p><code>dat</code> is the super-class of other classes representing models and data, so
that other model/data classes (e.g., <code>kin</code> and <code>spec</code>
for kinetic and spectral
models respectively) also have the slots defined here.  Slots whose
description are marked with *** may
be specified in the <code>...</code>
argument of the  <code><a href="#topic+initModel">initModel</a></code> function.
</p>


<h3>Objects from the Class</h3>

<p>Objects from the class
can be created by calls of the form <code>new("dat", ...)</code> or
<code>dat(...)</code>, but
most are most often made by invoking another function such as
<code>readData</code> or <code>initModel</code>.
</p>


<h3>Slots</h3>


<dl>
<dt>chinde</dt><dd></dd>
<dt>clinde</dt><dd></dd>
<dt>clpequspecBD</dt><dd></dd>
<dt>cohcol</dt><dd></dd>
<dt>compnames</dt><dd></dd>
<dt>highcon</dt><dd></dd>
<dt>lowcon</dt><dd></dd>
<dt>lscalpar</dt><dd></dd>
<dt><code>thetascal</code>:</dt><dd><p>*** Object of class <code>"vector"</code>  vector of values to scale the parameter vector with. </p>
</dd>
<dt>mvecind</dt><dd></dd>
<dt>nvecind</dt><dd></dd>
<dt>outMat</dt><dd></dd>
<dt>satMat</dt><dd></dd>
<dt>usecompnames0</dt><dd></dd>
<dt>usecompnamesequ</dt><dd></dd>
<dt>weightList</dt><dd></dd>
<dt>getX</dt><dd></dd>
<dt>getXsuper</dt><dd></dd>
<dt><code>weightpar</code>:</dt><dd><p>*** Object of class <code>"list"</code>  list of vectors
<code>c(first_x, last_x, first_x2, last_x2, weight)</code>,
where each vector is of length 5 and
specifies an interval in which to weight the data.
</p>

<ul>
<li><p>first_x: first(absolute, not an index) <code>x</code> to weight
</p>
</li>
<li><p>last_x: last (absolute, not an index) <code>x</code> to weight
</p>
</li>
<li><p>first_x2: first (absolute, not an index)  <code>x2</code> to weight
</p>
</li>
<li><p>last_x2: last (absolute, not an index)  <code>x2</code> to weight
</p>
</li>
<li><p>weight: numeric by which to weight data
</p>
</li></ul>

<p>Note that if vector elements 1-4 are <code>NA</code> (not a number), the firstmost
point of the data is taken for elements 1 and 3, and the lastmost points
are taken for 2 and 4.
For example, <code> weightpar = list(c(40, 1500, 400, 600, .9),
  c(NA, NA, 700, 800, .1))</code>  will weight data between times 40 and 1500
picoseconds and 700 and 800 wavelengths by .9, and will weight data at
all times between wavelength 700 and 800 by .1.
Note also that for single photon counting data
<code>weightpar = list(poisson = TRUE)</code> will apply poisson weighting to all
non-zero elements of the data. </p>
</dd>
<dt><code>mod_type</code>:</dt><dd><p>*** Object of class <code>"character"</code> character string defining the model type, e.g.,
<code>"kin"</code> or <code>"spec"</code></p>
</dd>
<dt><code>fixed</code>:</dt><dd><p>*** Object of class <code>"list"</code> list of lists or vectors giving the parameter values
to fix (at their starting values) during optimization. </p>
</dd>
<dt><code>free</code>:</dt><dd><p>*** Object of class <code>"list"</code> list of lists or vectors giving the parameter values
to free during optimization; if this list is present then all parameters
not specified in it are fixed, e.g., <code>free = list(irfpar = 2)</code> will fix
every parameter at its starting value except for the 2nd <code>irfpar</code>.  If
<code>fix = list(none=TRUE)</code>  (or if the element <code>none</code>  has length
greater than 0) then all parameters in the model are fixed.  Note that this
option only should be applied to multiexperiment models in which at least one
parameter applying to some other dataset is optimized (<code>nls</code> always must
have at least one parameter to optimize).      </p>
</dd>
<dt><code>constrained</code>:</dt><dd><p>*** Object of class <code>"list"</code> list whose elements
are lists containing a character vector <code>what</code>, a vector <code>ind</code>, and
either (but not both) a character vector <code>low</code> and <code>high</code>.
<code>what</code> should specify the parameter type to constrain.  <code>ind</code>
should give the index of the parameter to be constrained, e.g., <code>1</code> if
indexing into a vector, and <code>c(1,2)</code> if indexing into a list.
<code>low</code> gives a number that the parameter should always remain lower
than and <code>high</code> gives a number that the parameter should always remain
higher than (so that <code>low</code> bounds the parameter value from above and
<code>high</code> bounds the parameter value from below).  It is not now possible to
specify both <code>low</code> and <code>high</code> for a single parameter value.  An
example of a complete <code>constrained</code> specification is
<code>constrained = list(list(what = "kinpar", ind = 2, low = .3),
list(what = "parmu", ind = c(1,1), high = .002))</code>
</p>
</dd>
<dt><code>clp0</code>:</dt><dd><p>*** Object of class <code>"list"</code>  list of lists with elements <code>low</code>, <code>high</code> and
<code>comp</code>, specifying the least value in  <code>x2</code> to constrain
to zero, the greatest value in  <code>x2</code> to
constrain to zero, and the component to which to apply the zero constraint,
respectively.  e.g., <code>clp0 = list(list(low=400, high = 600, comp=2),
  list(low = 600, high = 650, comp=4))</code> applies zero constraints to the spectra
associated with components 2 and 4. </p>
</dd>
<dt><code>autoclp0</code>:</dt><dd><p>*** Object of class <code>"list"</code> that has two
elements; <code>oldRes</code>,
the output of <code>fitModel</code> and an index <code>ind</code> representing the
index of the dataset to use in <code>oldRes</code>; <code>ind</code> defaults to
one.   The clp that are negative in <code>oldRes</code> are constrained to
zero in the new model; this is primarily useful when fitting a model,
finding some negative clp, and constraining them to zero by fitting
again with this option.  See  also the help page for <code>opt</code> for
other ways to constrain the clp to non-negativity.
</p>
</dd>
<dt><code>clpequspec</code>:</dt><dd><p>*** Object of class <code>"list"</code> list of lists each of which has elements <code>to,
  from, low, high</code>, and optional element <code>dataset</code> to specify the dataset
from which to get the reference clp (that is, a spectrum for kinetic
models).  <code>to</code> is the component to be fixed in relation to some other
component; from is the reference component.  <code>low</code> and <code>high</code>
are the
least and greatest absolute values of the <code>clp</code> vector to constrain.
e.g.,
<code>clpequspec = list(list(low = 400, high = 600, to = 1, from = 2))</code>
will constrain the first component to equality to the second component
between wavelengths 400 and 600.  Note that equality constraints are
actually constraints to a linear relationship.  For each of the equality
constraints specified as a list in the <code>clpequspec</code> list, specify a
starting value parameterizing this linear relation in the vector
<code>clpequ</code>; if true equality is desired then fix the corresponding
parameter in <code>clpequ</code> to 1.  Note that if multiple components are
constrained, the <code>from</code> in the sublists should be increasing order,
(i.e., <code>(list(to=2, from=1, low=100, high=10000),
list(to=3, from=1, low=10000, high=100))</code>, not <code>list(to=3, from=1, low=10000, high=100),
list(to=2, from=1, low=10000, high=100)</code>)</p>
</dd>
<dt><code>clpequ</code>:</dt><dd><p>***Object of class <code>"vector"</code>  describes the
parameters governing the clp equality constraints specified in <code>clpequspec</code></p>
</dd>
<dt><code>prelspec</code>:</dt><dd><p>*** Object of class <code>"list"</code>  list of lists to specify the functional
relationship between parameters, each of which has elements
</p>

<ul>
<li><p>what1character string describing the parameter type to relate,
e.g., <code>"kinpar"</code>
</p>
</li>
<li><p>what2the parameter type on which the relation is based; usually
the same as <code>what1</code>
</p>
</li>
<li><p>ind1index into <code>what1</code>
</p>
</li>
<li><p>ind2index into <code>what2</code>
</p>
</li>
<li><p>relcharacter string,
optional argument to specify functional relation type,
by default linear </p>
</li></ul>

<p>e.g.,
<code>prelspec = list(list(what1 = "kinpar", what2 = "kinpar", ind1 = 1,
  ind2 = 5))</code>  relates the 1st element of <code>kinpar</code> to the 5th element of
<code>kinpar</code>.  The starting values parameterizing the relationship are
given in the <code>prel</code> vector</p>
</dd>
<dt><code>positivepar</code>:</dt><dd><p>*** Object of class <code>"vector"</code>  containing
character strings of those parameter vectors to constrain to positivity,
e.g., <code>positivepar=c("kinpar")</code></p>
</dd>
<dt><code>weight</code>:</dt><dd><p>Object of class <code>"logical"</code> <code>TRUE</code> when the specification in
<code>weightpar</code> is to be applied and <code>FALSE</code> otherwise</p>
</dd>
<dt><code>psi.df</code>:</dt><dd><p> Object of class <code>"matrix"</code>  dataset from 1 experiment</p>
</dd>
<dt><code>psi.weight</code>:</dt><dd><p>Object of class <code>"matrix"</code> weighted  dataset from 1 experiment</p>
</dd>
<dt><code>x</code>:</dt><dd><p>Object of class <code>"vector"</code> time or other independent
variable.  </p>
</dd>
<dt><code>nt</code>:</dt><dd><p>Object of class <code>"integer"</code> length <code>x</code></p>
</dd>
<dt><code>x2</code>:</dt><dd><p>Object of class <code>"vector"</code>  vector of points in
2nd independent dimension, such as wavelengths of wavenumbers</p>
</dd>
<dt><code>nl</code>:</dt><dd><p>Object of class <code>"integer"</code>  length <code>x2</code> </p>
</dd>
<dt><code>C2</code>:</dt><dd><p>Object of class <code>"matrix"</code> concentration matrix for
simulated data</p>
</dd>
<dt><code>E2</code>:</dt><dd><p>Object of class <code>"matrix"</code> matrix of spectra for
simulated data</p>
</dd>
<dt><code>sigma</code>:</dt><dd><p>Object of class <code>"numeric"</code> noise level in
simulated data </p>
</dd>
<dt><code>parnames</code>:</dt><dd><p>Object of class <code>"vector"</code> vector of
parameter names, used internally</p>
</dd>
<dt><code>simdata</code>:</dt><dd><p> Object of class <code>"logical"</code>  logical that is <code>TRUE</code> if the data is simulated,
<code>FALSE</code> otherwise; will determine whether values in <code>C2</code> and
<code>E2</code> are plotted with results</p>
</dd>
<dt><code>weightM</code>:</dt><dd><p>Object of class <code>"matrix"</code> weights </p>
</dd>
<dt><code>weightsmooth</code>:</dt><dd><p>Object of class <code>"list"</code> type of smoothing to apply with weighting; not currently
used</p>
</dd>
<dt><code>makeps</code>:</dt><dd><p> Object of class <code>"character"</code>
specifies the prefix of files written to
postscript
</p>
</dd>
<dt><code>lclp0</code>:</dt><dd><p>Object of class <code>"logical"</code> <code>TRUE</code> if specification in <code>clp0</code>
is to be applied and <code>FALSE</code> otherwise </p>
</dd>
<dt><code>lclpequ</code>:</dt><dd><p>Object of class <code>"logical"</code> <code>TRUE</code> if specification in clpequspec
is to be applied and <code>FALSE</code> otherwise</p>
</dd>
<dt><code>title</code>:</dt><dd><p> Object of class <code>"character"</code> displayed on output plots</p>
</dd>
<dt><code>mhist</code>:</dt><dd><p>Object of class <code>"list"</code>  list describing fitting history</p>
</dd>
<dt><code>datCall</code>:</dt><dd><p>Object of class <code>"list"</code> list of calls to functions</p>
</dd>
<dt><code>dscal</code>:</dt><dd><p> Object of class <code>"list"</code> </p>
</dd>
<dt><code>dscalspec</code>:</dt><dd><p> Object of class <code>"list"</code> </p>
</dd>
<dt><code>dummy</code>:</dt><dd><p> Object of class <code>"list"</code> containing dummy parameters</p>
</dd>
<dt><code>drel</code>:</dt><dd><p> Object of class <code>"vector"</code>  vector of starting parameters for dataset scaling relations</p>
</dd>
<dt><code>scalx</code>:</dt><dd><p> Object of class <code>"numeric"</code>  numeric by which to scale the <code>x</code> axis in plotting</p>
</dd>
<dt>prel</dt><dd><p>vector of starting values for the relations described in
prelspec</p>
</dd>
<dt><code>fvecind</code>:</dt><dd><p>Object of class <code>"vector"</code>  vector containing indices of fixed parameters</p>
</dd>
<dt><code>pvecind</code>:</dt><dd><p>Object of class <code>"vector"</code>  used internally to
store indices of related parameters. </p>
</dd>
<dt><code>iter</code>:</dt><dd><p>Object of class <code>"numeric"</code>  describing the
number of iterations that is run; this is sometimes
stored after fitting, but has not effect as an argument to
<code><a href="#topic+initModel">initModel</a></code></p>
</dd>
<dt><code>clpCon</code>:</dt><dd><p>Object of class <code>"list"</code>  used internally to enforce constraints on the clp</p>
</dd>
<dt><code>ncomp</code>:</dt><dd><p>Object of class <code>"numeric"</code>  describing the number of components in a model</p>
</dd>
<dt><code>clpdep</code>:</dt><dd><p>Object of class <code>"logical"</code>  describing whether a model is dependent on the index
of <code>x2</code></p>
</dd>
<dt><code>inten</code>:</dt><dd><p>Object of class <code>"matrix"</code>  for use with FLIM data; represents the number of photons
per pixel measured over the course of all
times $t$ represented by the dataset.  See the help for the <code>readData</code>
function for more information. </p>
</dd>
<dt><code>datafile</code>:</dt><dd><p>Object of class <code>"character"</code>
containing the name of a datafile associated with the <code>psi.df</code> </p>
</dd>
<dt><code>clpType</code>:</dt><dd><p>Object of class <code>"character"</code>
that is &quot;nt&quot; if the model has clp in the &quot;x&quot; dimension and &quot;nl&quot; otherwise
(so that, e.g., if <code>mod\_type = "kin"</code>, then <code>clpType = "nl"</code>).</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Katharine M. Mullen, Ivo H. M. van Stokkum, Joris J. Snellenburg, Sergey P. Laptenok</p>


<h3>See Also</h3>

<p><code><a href="#topic+kin-class">kin-class</a></code>, <code><a href="#topic+spec-class">spec-class</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># simulate data

 C &lt;- matrix(nrow = 51, ncol = 2)
 k &lt;- c(.5, 1)
 t &lt;- seq(0, 2, by = 2/50)
 C[, 1] &lt;- exp( - k[1] * t)
 C[, 2] &lt;- exp( - k[2] * t)
 E &lt;- matrix(nrow = 51, ncol = 2)
 wavenum &lt;- seq(18000, 28000, by=200)
 location &lt;- c(25000, 20000)
 delta &lt;- c(5000, 7000)
 amp &lt;- c(1, 2)
 E[, 1] &lt;- amp[1] * exp( - log(2) * (2 * (wavenum - location[1])/delta[1])^2)
 E[, 2] &lt;- amp[2] * exp( - log(2) * (2 * (wavenum - location[2])/delta[2])^2)
 sigma &lt;- .001
 Psi_q  &lt;- C %*% t(E) + sigma * rnorm(nrow(C) * nrow(E))

 # initialize an object of class dat
 Psi_q_data &lt;- dat(psi.df = Psi_q, x = t, nt = length(t),
 x2 = wavenum, nl = length(wavenum))

 # initialize an object of class dat via initModel
 # this dat object is also a kin object
 kinetic_model &lt;- initModel(mod_type = "kin", seqmod = FALSE,
 kinpar = c(.1, 2))
</code></pre>

<hr>
<h2 id='denS4'>Time-resolved absorption data</h2><span id='topic+denS4'></span><span id='topic+denS5'></span>

<h3>Description</h3>

<p>Time-resolved absorption data measured at two different
laser intensities</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("denS4")
data("denS5")
</code></pre>


<h3>Format</h3>

<p><code>denS4</code> is an object of class <code>dat</code> representing absorption
data.
<code>denS5</code> is an object of class <code>dat</code> representing absorption
data measured at half the laser intensity as compared to the
intensity used to measure <code>denS4</code>.
</p>


<h3>References</h3>

<p>This data was described in
Mullen KM, van Stokkum IHM (2007).
TIMP: An R Package for Modeling Multi-way Spectroscopic
Measurements. <em>Journal of Statistical Software</em>, <b>18</b>(3),
<a href="https://doi.org/10.18637/jss.v018.i03">doi:10.18637/jss.v018.i03</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("denS4")
image.plot(denS4@x, denS4@x2, denS4@psi.df)
</code></pre>

<hr>
<h2 id='divergeZimage'>Plots a matrix with a diverging palette, with the center value of
the palette possible to set</h2><span id='topic+divergeZimage'></span>

<h3>Description</h3>

<p>An image plot of a matrix is a way of visualizing data;
when the data represents a quantity like transient absorption, where
negative values represent a different phenomena than positive values,
it can be useful to set values at zero in the image plot to grey,
whereas positive values are assigned to red, and negative
values are assigned to blue.  Alternately, when comparing image plots
of several matrices, it may be useful to set the value assigned to grey
uniformly, with values above this threshold assigned to red, and below
this threshold assigned to blue.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>divergeZimage(ob, out=FALSE, file="divergeZimage.pdf",
                            lin = 1, title = "", center = 0,
                            x2 = vector(), x= vector(),
                            plainmat = FALSE, ylab="wavelength (nm)",
                            xlab = "time (ns)")

</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="divergeZimage_+3A_ob">ob</code></td>
<td>
<p>either an object of class <code>dat</code> or a numeric matrix; if a
numeric matrix is given then set <code>plainmat=TRUE</code> and specify labels
for the columns of matrix in <code>x2</code> and for the rows of the matrix in
<code>x</code> </p>
</td></tr>
<tr><td><code id="divergeZimage_+3A_out">out</code></td>
<td>
<p>a logical indicating whether to write to the screen in the
case that this is possible or to a file; if <code>TRUE</code>, writes to a pdf
file</p>
</td></tr>
<tr><td><code id="divergeZimage_+3A_file">file</code></td>
<td>
<p>a character vector giving a filename to write to in the case
that <code>out=TRUE</code></p>
</td></tr>
<tr><td><code id="divergeZimage_+3A_lin">lin</code></td>
<td>
<p>range of <code>x</code> to plot linearly; values not
between <code>-lin</code> and <code>lin</code> are plotted on a log scale</p>
</td></tr>
<tr><td><code id="divergeZimage_+3A_title">title</code></td>
<td>
<p>character vector giving a title for the plot</p>
</td></tr>
<tr><td><code id="divergeZimage_+3A_center">center</code></td>
<td>
<p>point assigned to grey in the diverging palette.</p>
</td></tr>
<tr><td><code id="divergeZimage_+3A_x2">x2</code></td>
<td>
<p>vector of labels for the columns of the matrix; used only if
<code>plainmat=TRUE</code></p>
</td></tr>
<tr><td><code id="divergeZimage_+3A_x">x</code></td>
<td>
<p>vector of labels for the rows of the matrix; used only if
<code>plainmat=TRUE</code></p>
</td></tr>
<tr><td><code id="divergeZimage_+3A_plainmat">plainmat</code></td>
<td>
<p>logical indicating whether <code>ob</code> is a matrix, as
opposed to an object of class <code>dat</code> </p>
</td></tr>
<tr><td><code id="divergeZimage_+3A_ylab">ylab</code></td>
<td>
<p>character vector giving a label to put on the y-axis</p>
</td></tr>
<tr><td><code id="divergeZimage_+3A_xlab">xlab</code></td>
<td>
<p>character vector giving a label to put on the x-axis</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, called for side effects</p>


<h3>Author(s)</h3>

<p>Katharine M. Mullen, Ivo H. M. van Stokkum</p>


<h3>See Also</h3>

 <p><code><a href="#topic+dat">dat</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>
exd &lt;- dat(psi.df=matrix(rnorm(1000), ncol=100, nrow=100),
x=1:100,x2=1:100, nl=as.integer(100), nt=as.integer(100))

## by default linear range until 1 is used, logarithmic thereafter
divergeZimage(exd)

## can change this as desired
divergeZimage(exd, lin=10, title="plot linearly to 10")

</code></pre>

<hr>
<h2 id='donorAcceptorTagged'>Fluorescent lifetime imaging microscopy (FLIM) data</h2><span id='topic+donorAcceptorTagged'></span><span id='topic+cy005c'></span><span id='topic+cy006'></span>

<h3>Description</h3>

<p>Donor-and-acceptor tagged fluorescent lifetime
imaging microscopy (FLIM) data.  </p>


<h3>Usage</h3>

<pre><code class='language-R'>data("donorAcceptorTagged")
</code></pre>


<h3>Format</h3>

<p><code>cy005c</code> and <code>cy006</code> are objects of class <code>dat</code>
representing donor-and-acceptor tagged data.
</p>


<h3>Details</h3>

<p>See <code><a href="#topic+FLIMplots">FLIMplots</a></code> for examples using this data.
</p>


<h3>References</h3>

<p>This data was described in
</p>
<p>Mullen KM, van Stokkum IHM (2008).
The variable projection algorithm in time-resolved spectroscopy,
microscopy and mass-spectroscopy applications,
<em>Numerical Algorithms</em>, <b>in press</b>,
<a href="https://doi.org/10.1007/s11075-008-9235-2">doi:10.1007/s11075-008-9235-2</a>.
</p>

<hr>
<h2 id='donorTagged'>Fluorescent lifetime imaging microscopy (FLIM) data</h2><span id='topic+donorTagged'></span><span id='topic+c001'></span><span id='topic+c003'></span>

<h3>Description</h3>

<p>Donor-only tagged fluorescent lifetime
imaging microscopy (FLIM) data.  </p>


<h3>Usage</h3>

<pre><code class='language-R'>data("donorTagged")
</code></pre>


<h3>Format</h3>

<p><code>c001</code> and <code>c003</code> are objects of class <code>dat</code>
representing donor-only data.
</p>


<h3>Details</h3>

<p>See <code><a href="#topic+FLIMplots">FLIMplots</a></code> for examples using this data.
</p>


<h3>References</h3>

<p>This data was described in
</p>
<p>Mullen KM, van Stokkum IHM (2008).
The variable projection algorithm in time-resolved spectroscopy,
microscopy and mass-spectroscopy applications,
<em>Numerical Algorithms</em>, <b>in press</b>,
<a href="https://doi.org/10.1007/s11075-008-9235-2">doi:10.1007/s11075-008-9235-2</a>.
</p>

<hr>
<h2 id='efit2file'>Convert 'tim' FORTRAN efit files to plain matrices in ASCII files</h2><span id='topic+efit2file'></span>

<h3>Description</h3>

<p>'tim' efit files sometimes represent spectra associated
with multiple datasets; for each matrix of spectra stored in such a
file, this function writes a plain text file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>efit2file(filename, skip = 2, numcol, nrows=vector())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="efit2file_+3A_filename">filename</code></td>
<td>
<p>This is the path to the file to read in, as a quoted string. </p>
</td></tr>
<tr><td><code id="efit2file_+3A_skip">skip</code></td>
<td>
<p>number of lines at the top of the file before the data begins</p>
</td></tr>
<tr><td><code id="efit2file_+3A_numcol">numcol</code></td>
<td>
<p>number of columns the data</p>
</td></tr>
<tr><td><code id="efit2file_+3A_nrows">nrows</code></td>
<td>
<p>a vector saying how many rows are in each of the matrices
of spectra in the file; for instance <code>nrows = c(256,256,256)</code>
would indicate that the file stores spectra associated with 3
datasets, each of which contains 256 wavelengths.  If <code>nrows</code> is
not given, then a single file containing all data is written. </p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, called for side effects</p>


<h3>Author(s)</h3>

<p>Katharine M. Mullen, Ivo H. M. van Stokkum</p>


<h3>See Also</h3>

 <p><code><a href="#topic+readData">readData</a></code> </p>

<hr>
<h2 id='examineFit'>Examines the results of a call to  fitModel</h2><span id='topic+examineFit'></span>

<h3>Description</h3>

<p>Examine the results of a call to  <code><a href="#topic+fitModel">fitModel</a></code>
by a call to plotting functions; call this function with argument
an object returned from <code>fitModel</code>.  Possibly also supply a new
specification of plots to be generated. </p>


<h3>Usage</h3>

<pre><code class='language-R'>examineFit(resultfitModel, opt=vector())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="examineFit_+3A_resultfitmodel">resultfitModel</code></td>
<td>
<p>list returned by a call to  <code><a href="#topic+fitModel">fitModel</a></code></p>
</td></tr>
<tr><td><code id="examineFit_+3A_opt">opt</code></td>
<td>
<p>possibly an object of class <code>opt</code> giving options for
plotting; if <code>opt</code> has length zero (the default) then the plotting
options given in the <code>opt</code> list of <code>resultFitModel</code> are
applied</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The  <code><a href="#topic+fitModel">fitModel</a></code> function returns a list of results,
and initiates plotting
functions.  Given the <code>resultfitModel</code> list  <code><a href="#topic+fitModel">fitModel</a></code>
returns,
<code>examineFit</code> initiates the plotting functions, and thus may be
used to examine results.
</p>


<h3>Value</h3>

<p>No return value, called for side effects</p>


<h3>Author(s)</h3>

<p>Katharine M. Mullen, Ivo H. M. van Stokkum</p>


<h3>See Also</h3>

 <p><code><a href="#topic+fitModel">fitModel</a></code>, <code><a href="#topic+opt">opt</a> </code></p>

<hr>
<h2 id='fit-class'>Class &quot;fit&quot; to store the results of model fitting associated with 
all datasets analyzed. </h2><span id='topic+fit-class'></span><span id='topic+fit'></span>

<h3>Description</h3>

<p>Class to store results of model fitting associated with 
all datasets in a single call to the <code>fitModel</code> function.  
An object of class <code>fit</code> is stored in 
the slot <code>fit</code> of objects of class <code>multimodel</code>.
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("fit", ...)</code>.
</p>


<h3>Slots</h3>


<dl>
<dt>rss</dt><dd></dd>
<dt><code>resultlist</code>:</dt><dd><p> Object of class <code>"list"</code> that contains 
an object of class <code>res</code> for each dataset modeled, in the order 
that they were specified. </p>
</dd>
<dt><code>nlsres</code>:</dt><dd><p>Object of class <code>"list"</code> containing 
named elements 
</p>
 
<ul>
<li><p>onlsoutput of the call to <code>nls</code> used in model optimization. 
</p>
</li>
<li><p>sumonlsresult of call <code>summary(onls)</code>  
</p>
</li></ul>

</dd>
</dl>



<h3>Author(s)</h3>

<p>Katharine M. Mullen, Ivo H. M. van Stokkum</p>


<h3>See Also</h3>

<p><code><a href="#topic+res-class">res-class</a></code>, <code><a href="#topic+multimodel-class">multimodel-class</a></code>
</p>

<hr>
<h2 id='fitModel'>Performs optimization of (possibly multidataset) models.</h2><span id='topic+fitModel'></span>

<h3>Description</h3>

<p>Performs optimization of (possibly multidataset) models and
outputs plots and files representing the fit of the model to the data. </p>


<h3>Usage</h3>

<pre><code class='language-R'>fitModel(data, modspec=list(), datasetind = vector(),
modeldiffs = list(), opt = opt(),lprogress=FALSE )
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fitModel_+3A_data">data</code></td>
<td>
<p>list of objects of class <code>dat</code> containing the data
to be modeled</p>
</td></tr>
<tr><td><code id="fitModel_+3A_modspec">modspec</code></td>
<td>
<p>list whose elements are models of class <code>dat</code>
describing the models as results from a
call to the function <code>initModel</code> </p>
</td></tr>
<tr><td><code id="fitModel_+3A_datasetind">datasetind</code></td>
<td>
<p>vector that has the same length as <code>data</code>;
for each dataset in <code>data</code> specify the model it should have as
an index into <code>modspec</code>; default mapping is that all datasets
use the first model given in <code>modspec</code>  </p>
</td></tr>
<tr><td><code id="fitModel_+3A_modeldiffs">modeldiffs</code></td>
<td>
<p> list whose elements specify any dataset-specific
model differences.
</p>

<ul>
<li><p>linkclp list of vectors containing the indices of datasets.  If the
two dataset indices are in the same vector, their conditionally linear
parameters will be equated if they represent the same condition (e.g., a
wavelength) within <code>thresh</code>.  For example,
<code>linkclp = list(1:10, 11:15)</code> will let datasets 1-10 and 11-15
have the same clp.  Note that if <code>linkclp</code> is not given, it will
default to <code>list{1:length(data)}</code>, so that the clp from all datasets
are equated when they represent conditions within <code>thresh</code> of each
other.
</p>
<p>Consider the situation where the clp from many different datasets are
equated.  <b>
Then it is important to note that the specification of constraints
applicable to the clp will also be equated, and will be read from the model
assigned to the first dataset in the group. </b>
</p>

</li>
<li><p>dscal list of lists specifying linear scaling relations between
datasets; each list has elements <code>to, from, value</code>.  The index of the
dataset to be scaled is given in <code>to</code>; the index of the dataset on
which the scaling is to be based is given in <code>from</code>.  The starting
value parameterizing the relationship is given as <code>value</code>. For
example, <code>dscal = list(list(to=2,from=1,value=.457))</code>. 
</p>
</li>
<li><p>thresh numeric describing the tolerance with which clp from
different datasets are to be considered as equal.
For instance, for
two datasets containing data at 750 and 751 nm, respectively,
<code>thresh=1.5</code> will equate the clp at 750 and 751 between datasets.
Specify a negative
value of <code>thresh</code> to estimate clp per-dataset.
See Section 2.2 of the paper in the references for the model equations. 
</p>
</li>
<li><p>free list of lists specifying individual
parameters to free for a given dataset. each sublist has
named elements
</p>

<dl>
<dt>what</dt><dd><p>character string naming parameter type, e.g., &quot;kinpar&quot;</p>
</dd>
<dt>ind</dt><dd><p>vector of indices into parameter vector or list, e.g.,
<code>c(2,3)</code> or <code>4</code></p>
</dd>
<dt>dataset</dt><dd><p>dataset index in which parameter is to be freed</p>
</dd>
<dt>start</dt><dd><p>starting value for freed parameter</p>
</dd>
</dl>

<p>For example, <code>free = list(
list(what = "irfpar", ind = 1, dataset = 2, start=-.1932),
list(what = "kinpar", ind = 5, dataset = 2, start=.0004),
list(what = "kinpar", ind = 4, dataset = 2, start= .0159))</code>.

</p>
</li>
<li><p>remove list of lists specifying individual
parameters to remove from
parameter groups for a given dataset. each sublist has
named elements
</p>

<ul>
<li><p>what character string naming parameter type, e.g., &quot;kinpar&quot;
</p>
</li>
<li><p>dataset dataset index in which parameter group is to be removed
</p>
</li>
<li><p>ind vector of indices into parameter vector or list, e.g.,
<code>c(2,3)</code> or <code>4</code> where parameter should be removed 
</p>
</li></ul>


</li>
<li><p>add list of lists specifying individual
parameters to add to parameter groups for a given dataset. each sublist has
named elements
</p>

<ul>
<li><p>what character string naming parameter type, e.g., &quot;kinpar&quot;
</p>
</li>
<li><p>dataset dataset index in which parameter group is to change
</p>
</li>
<li><p>start starting value for added parameter
</p>
</li>
<li><p>ind vector of indices into parameter vector or list, e.g.,
<code>c(2,3)</code> or <code>4</code> where parameter should be added. 
</p>
</li></ul>


</li>
<li><p>changelist of lists specifying entire parameter groups to change
for a given dataset.
each sublist has named elements
</p>

<ul>
<li><p>what character string naming parameter type, e.g., &quot;kinpar&quot;
</p>
</li>
<li><p>dataset dataset index in which parameter group is to change
</p>
</li>
<li><p>spec new specification that in initModel would follow &quot;what&quot;,
e.g., for <code>c(.1, .3)</code> if what=&quot;kinpar&quot;
</p>
</li></ul>

</li>
<li><p>rel
list of lists specifying parameters to relate between datasets
each sublist has named elements
</p>

<ul>
<li><p>what1 character string naming parameter type to be determined in
relation to some other parameter type , e.g., &quot;kinpar&quot;
</p>
</li>
<li><p>what2 character string naming parameter type on which another
parameter type is to depend, e.g., &quot;kinpar&quot;
</p>
</li>
<li><p>ind1 vector of indices into parameter vector or
list, e.g., <code>c(2,3)</code> or <code>4</code> of the dependent parameter. 
</p>
</li>
<li><p>ind2 vector or numeric of indices into parameter vector or
list, e.g., <code>c(2,3)</code> or <code>4</code> of the parameter on which another
parameter will depend 
</p>
</li>
<li><p>dataset1 dataset index of the dependent parameter
</p>
</li>
<li><p>dataset2 dataset index of the parameter on which another parameter
will depend
</p>
</li>
<li><p>rel optional character string describing functional relationship
between parameters; defaults to &quot;lin&quot; for linear relationship 
</p>
</li>
<li><p>start starting value or vector of values parameterizing
relationship between parameters  
</p>
</li></ul>

</li>
<li><p>weightlist List of new weights for the datasets returned
by the function <code>outlierCorrs</code> (as the element
<code>weightList</code> of the list that is the return value of this function).

</p>
</li></ul>

</td></tr>
<tr><td><code id="fitModel_+3A_opt">opt</code></td>
<td>
<p>Object of class <code>kinopt</code> or <code>specopt</code> specifying
fitting and plotting options. </p>
</td></tr>
<tr><td><code id="fitModel_+3A_lprogress">lprogress</code></td>
<td>
<p>Logical specifying
whether textual output of fitting progress is returned </p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function applies the <code><a href="stats.html#topic+nls">nls</a></code> function internally to
optimize nonlinear parameters and to solve for conditionally linear parameters
(clp) via the partitioned variable projection algorithm.
</p>


<h3>Value</h3>

<p> A list is returned containing the following elements:
</p>

<ul>
<li><p>currTheta is a list of objects
of class <code>theta</code> whose elements contain the parameter estimates
associated with each dataset modeled.
</p>
</li>
<li><p>currModel is an object of class <code>multimodel</code>
containing the results of fitting as well as the model
specification
</p>
</li>
<li><p>toPlotter is a list containing all arguments used by the plotting
function; it is used to regenerate plots and other output by the
<code>examineFit</code>  function
</p>
</li>
<li><p>nlsprogress if lprogress = TRUE textual output of the fitting progress
is returned as an array of strings
</p>
</li></ul>


<h3>Author(s)</h3>

<p>Katharine M. Mullen, Ivo H. M. van Stokkum</p>


<h3>References</h3>

<p>Mullen KM, van Stokkum IHM (2007).
&ldquo;TIMP: an R package for modeling
multi-way spectroscopic measurements.&rdquo; Journal of Statistical Software,
18(3). <a href="https://doi.org/10.18637/jss.v018.i03">doi:10.18637/jss.v018.i03</a></p>


<h3>See Also</h3>

 <p><code><a href="#topic+readData">readData</a></code>, <code><a href="#topic+initModel">initModel</a></code>,
<code><a href="#topic+examineFit">examineFit</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>
## 2 simulated concentration profiles in time
C &lt;- matrix(nrow = 51, ncol = 2)
k &lt;- c(.5, 1)
t &lt;- seq(0, 2, by = 2/50)
C[, 1] &lt;- exp( - k[1] * t)
C[, 2] &lt;- exp( - k[2] * t)

## 2 simulated spectra in wavelength
E &lt;- matrix(nrow = 51, ncol = 2)
wavenum &lt;- seq(18000,28000, by=200)
location &lt;- c(25000, 20000)
delta &lt;- c(5000, 7000)
amp &lt;- c(1, 2)
E[, 1] &lt;- amp[1] * exp( - log(2) * (2 * (wavenum - location[1])/delta[1])^2)
E[, 2] &lt;- amp[2] * exp( - log(2) * (2 * (wavenum - location[2])/delta[2])^2)

## simulated time-resolved spectra
sigma &lt;- .001
Psi_q  &lt;- C %*% t(E) + sigma * rnorm(nrow(C) * nrow(E))

## as an object of class dat
Psi_q_data &lt;- dat(psi.df = Psi_q, x = t, nt = length(t), x2 = wavenum, nl =
length(wavenum))

## model for the data in the time-domain
kinetic_model &lt;- initModel(mod_type = "kin", seqmod = FALSE,
kinpar = c(.1, 2))

## fit the model
kinetic_fit &lt;- fitModel(data = list(Psi_q_data),
modspec = list(kinetic_model), opt = kinopt(iter=4, plot=FALSE))
</code></pre>

<hr>
<h2 id='FLIMplots'>Functions to plot FLIM results. </h2><span id='topic+FLIMplots'></span><span id='topic+plotHistAmp'></span><span id='topic+plotHistNormComp'></span><span id='topic+plotIntenImage'></span><span id='topic+plotSelIntenImage'></span><span id='topic+plotNormComp'></span><span id='topic+plotTau'></span>

<h3>Description</h3>

<p>Functions to plot FLIM results. </p>


<h3>Usage</h3>

<pre><code class='language-R'>    plotHistAmp(multimodel, t, i=1)
    plotHistNormComp(multimodel, t, i=1)
    plotIntenImage(multimodel, t, i=1,  tit=c("Intensity Image"))
    plotSelIntenImage(multimodel, t, i=1, tit=c("Region of Interest"),
     cex=1)
    plotTau(multimodel, t, i=1, tit=" &lt; tau &gt; ", plotoptions=kinopt(),
     lifetimes=TRUE)
    plotNormComp(multimodel, t, i=1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="FLIMplots_+3A_multimodel">multimodel</code></td>
<td>
<p>the <code>currModel</code> element of the list
returned by <code>fitModel</code> </p>
</td></tr>
<tr><td><code id="FLIMplots_+3A_t">t</code></td>
<td>
<p>the <code>currTheta</code> element of the list
returned by <code>fitModel</code> </p>
</td></tr>
<tr><td><code id="FLIMplots_+3A_i">i</code></td>
<td>
<p>dataset index to make plot for</p>
</td></tr>
<tr><td><code id="FLIMplots_+3A_tit">tit</code></td>
<td>
<p>Character vector giving the title</p>
</td></tr>
<tr><td><code id="FLIMplots_+3A_plotoptions">plotoptions</code></td>
<td>
<p>object of class <code>kinopt</code> giving the plotting
options</p>
</td></tr>
<tr><td><code id="FLIMplots_+3A_cex">cex</code></td>
<td>
<p>A numerical value giving the amount by which plotting text
and symbols should be magnified relative to the default</p>
</td></tr>
<tr><td><code id="FLIMplots_+3A_lifetimes">lifetimes</code></td>
<td>
<p>A logical value indicating whether the averages
per-pixel should be for lifetimes or their inverse, decay rates.  </p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, called for side effects</p>


<h3>Author(s)</h3>

<p>Katharine M. Mullen, Sergey Laptenok, Ivo H. M. van Stokkum</p>


<h3>See Also</h3>

 <p><code><a href="#topic+fitModel">fitModel</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>
##############################
## READ IN DATA,  PREPROCESS DATA
##############################

## data representing only donor tagged

data("donorTagged")

D1 &lt;- preProcess(c001, sel_time=c(25,230))
D2 &lt;- preProcess(c003, sel_time=c(25,230))

## data representing donor-acceptor tagged

data("donorAcceptorTagged")

DA1 &lt;- preProcess(cy005c, sel_time=c(25,230))
DA2 &lt;- preProcess(cy006, sel_time=c(25,230))

##############################
## READ IN MEASURED IRF,  PREPROCESS IRF
##############################

data("mea_IRF")
mea_IRF &lt;- baseIRF(mea_IRF, 100, 150)[25:230]

##############################
## SPECIFY INITIAL MODEL
##############################

modelC &lt;- initModel(mod_type = "kin",
## starting values for decays
kinpar=c(1.52, 0.36),
## numerical convolution algorithm to use
convalg = 2,
## measured IRF
measured_irf = mea_IRF,
lambdac = 650,
## shift of the irf is fixed
parmu = list(0), fixed = list(parmu=1),
## one component represents a pulse-following with the IRF shape
cohspec = list(type = "irf"),
## parallel kinetics
seqmod=FALSE,
## decay parameters are non-negative
positivepar=c("kinpar"),
title="Global CFP bi-exp model with pulse-follower")

##############################
## FIT MODEL FOR DONOR ONLY DATA
##############################

fitD &lt;- fitModel(list(D1,D2),
                 list(modelC),
                 ## estimate the linear coeefficients per-dataset
                 modeldiffs = list(linkclp=list(1,2)),
                 opt=kinopt(iter=1, linrange = 10,
                   addfilename = TRUE,
                   output = "pdf",
                   makeps = "globalD",
                   notraces = TRUE,
                   selectedtraces = seq(1, length(c001@x2), by=11),
                   summaryplotcol = 4, summaryplotrow = 4,
                   ylimspec = c(1, 2.5),
                   xlab = "time (ns)", ylab = "pixel number",
                   FLIM=TRUE))

##############################
## FIT MODEL FOR DONOR-ACCEPTOR DATA
##############################

fitDA &lt;- fitModel(list(DA1,DA2),
                  list(modelC),
                  ## estimate the linear coeefficients per-dataset
                 modeldiffs = list(linkclp=list(1,2)),
                 opt=kinopt(iter=1, linrange = 10,
                   addfilename = TRUE,
                   output = "pdf",
                   makeps = "globalDA",
                   notraces = TRUE,
                   selectedtraces = seq(1, length(c001@x2), by=11),
                   summaryplotcol = 4, summaryplotrow = 4,
                   ylimspec = c(1, 2.5),
                   xlab = "time (ns)", ylab = "pixel number",
                   FLIM=TRUE))

##############################
## COMPARE THE DECAY RATES
##############################

parEst(fitD)

parEst(fitDA)

##############################
## ADDITIONAL FIGURES
##############################
oldpar &lt;- par(no.readonly = TRUE)

par(mfrow=c(2,2), mar=c(1,3,1,12))

par(cex=1.5)
plotIntenImage(fitD$currModel, fitD$currTheta, 1, tit="")

par(cex=1.5)
plotIntenImage(fitDA$currModel, fitD$currTheta, 1, tit="")

par(cex=1.5)
plotIntenImage(fitD$currModel, fitD$currTheta, 2, tit="")

par(cex=1.5)
plotIntenImage(fitDA$currModel, fitD$currTheta, 2, tit="")

par(oldpar)
###############

plo &lt;- kinopt(ylimspec = c(.25,1.1), imagepal=grey(seq(1,0,length=100)))

par(mfrow=c(2,2), mar=c(1,3,1,12))

par(cex=1.5)
plotTau(fitD$currModel, fitD$currTheta, 1, tit="",plotoptions=plo,
        lifetimes=FALSE)

par(cex=1.5)
plotTau(fitDA$currModel, fitD$currTheta, 1, tit="",plotoptions=plo,
        lifetimes=FALSE)

par(cex=1.5)
plotTau(fitD$currModel, fitD$currTheta, 2, tit="",plotoptions=plo,
        lifetimes=FALSE)

par(cex=1.5)
plotTau(fitDA$currModel, fitD$currTheta, 2, tit="", plotoptions=plo,
        lifetimes=FALSE)

par(oldpar)
 # end donttest

##############################
## CLEANUP GENERATED FILES
##############################
# This removes the files that were generated in this example
# (do not run this code if you wish to inspect the output)
file_list_cleanup = c('globalDA_paramEst.txt', 'globalDA_spec_dataset_1.txt',
  'globalDA_spec_dataset_2.txt', 'globalD_paramEst.txt',
  'globalD_spec_dataset_1.txt', 'globalD_spec_dataset_2.txt',
  Sys.glob("*paramEst.txt"), Sys.glob("*.ps"), Sys.glob("Rplots*.pdf"))

# Iterate over the files and delete them if they exist
for (f in file_list_cleanup) {
  if (file.exists(f)) {
    unlink(f)
  }
}


</code></pre>

<hr>
<h2 id='getClpindepX-methods'>Generic function getClpindepX in Package &lsquo;TIMP&rsquo;</h2><span id='topic+getClpindepX-methods'></span><span id='topic+getClpindepX+2Ckin-method'></span><span id='topic+getClpindepX+2Cspec-method'></span><span id='topic+getClpindepX+2Cmass-method'></span><span id='topic+getClpindepX+2Camp-method'></span><span id='topic+getClpindepX'></span>

<h3>Description</h3>

<p>Gets the matrix associated with nonlinear parameter estimates for the
case that this matrix is not re-calculated per conditionally linear
parameter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getClpindepX(model, multimodel, theta, returnX, rawtheta, dind)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getClpindepX-methods_+3A_model">model</code></td>
<td>
<p>Object of class <code>dat</code>; function switches on this
argument.
</p>
</td></tr>
<tr><td><code id="getClpindepX-methods_+3A_multimodel">multimodel</code></td>
<td>
<p>Object of class <code>multimodel</code> used in standard error
determination</p>
</td></tr>
<tr><td><code id="getClpindepX-methods_+3A_theta">theta</code></td>
<td>
<p>Vector of nonlinear parameter estimates.</p>
</td></tr>
<tr><td><code id="getClpindepX-methods_+3A_returnx">returnX</code></td>
<td>
<p>logical indicating whether to return a vectorized version of
the <code>X</code> matrix</p>
</td></tr>
<tr><td><code id="getClpindepX-methods_+3A_rawtheta">rawtheta</code></td>
<td>
<p>vector of nonlinear parameters; used in standard error
determination</p>
</td></tr>
<tr><td><code id="getClpindepX-methods_+3A_dind">dind</code></td>
<td>
<p>numeric indicating the dataset index; used in standard error
determination</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Katharine M. Mullen, Ivo H. M. van Stokkum</p>


<h3>See Also</h3>

 <p><code><a href="#topic+dat-class">dat-class</a></code></p>

<hr>
<h2 id='getResid'>For data correction, fits a model (but ignores 
plotting commands) in order to obtain the SVD of the residuals, which 
then can be used in data-correction. </h2><span id='topic+getResid'></span>

<h3>Description</h3>

<p>For data correction, fits a model exactly as does 
<code>fitModel</code> (but ignores 
plotting commands) in order to obtain the SVD of the residuals.  These 
residuals can then be subtracted away from the original data to some
extent with the <code>preProcess</code> function. </p>


<h3>Usage</h3>

<pre><code class='language-R'>getResid(data, modspec=list(), datasetind = vector(),
     modeldiffs = list(), opt = opt() )
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getResid_+3A_data">data</code></td>
<td>
<p>As in the <code>fitModel</code> function </p>
</td></tr>
<tr><td><code id="getResid_+3A_modspec">modspec</code></td>
<td>
<p> As in the <code>fitModel</code> function</p>
</td></tr>
<tr><td><code id="getResid_+3A_datasetind">datasetind</code></td>
<td>
<p> As in the <code>fitModel</code> function</p>
</td></tr>
<tr><td><code id="getResid_+3A_modeldiffs">modeldiffs</code></td>
<td>
<p> As in the <code>fitModel</code> function</p>
</td></tr>
<tr><td><code id="getResid_+3A_opt">opt</code></td>
<td>
<p> As in the <code>fitModel</code> function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list containing the first five left and right singular vectors of the 
residuals, as well as the first five singular values.  A weight matrix 
(if used) is also included in this list. 
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+fitModel">fitModel</a></code>, <code><a href="#topic+preProcess">preProcess</a></code></p>

<hr>
<h2 id='getResults'>Functions to print and return parts of the object returned
by the fitting routines. </h2><span id='topic+getResults'></span><span id='topic+onls'></span><span id='topic+sumnls'></span><span id='topic+parEst'></span><span id='topic+getCLPList'></span><span id='topic+getData'></span><span id='topic+getSVDData'></span><span id='topic+getSVDResiduals'></span><span id='topic+getTraces'></span><span id='topic+getdim1'></span><span id='topic+getdim2'></span><span id='topic+getResiduals'></span><span id='topic+getXList'></span><span id='topic+getX'></span><span id='topic+getC'></span><span id='topic+getCLP'></span><span id='topic+getDAS'></span>

<h3>Description</h3>

<p>Functions to print and return parts of the object returned
by <code>fitModel</code>.  <code>onls</code> returns the output of the
<code>nls</code>
function.  <code>sumonls</code> returns the result of calling <code>summary</code>
on <code>onls</code> function.  <code>parEst</code> returns a summary of model
parameter estimates.  The remaining functions return lists
representing various aspects of the results returned by the function
fitModel.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>onls(result)
sumnls(result)
parEst(result, param = "", dataset = NA, verbose = TRUE, file="",
 stderr=TRUE)
getXList(result, group = vector(), file="")
getCLPList(result, getclperr = FALSE, file="")
getX(result, group = vector(), dataset=1, file="", lreturnA = FALSE, lreturnC = FALSE)
getC(result, dataset=1, file="")
getCLP(result, getclperr = FALSE, dataset=1, file="")
getDAS(result, getclperr = FALSE, dataset=1, file="")
getData(result, dataset = 1, weighted = FALSE)
getResiduals(result, dataset = 1)
getSVDResiduals(result, numsing = 2, dataset = 1)
getTraces(result, dataset = 1, file="")
getdim1(result, dataset = 1)
getdim2(result, dataset = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getResults_+3A_result">result</code></td>
<td>
<p>return value of <code>fitModel</code></p>
</td></tr>
<tr><td><code id="getResults_+3A_param">param</code></td>
<td>
<p>character vector of the particular parameters to return;
if <code>param==""</code> then all parameters are given. </p>
</td></tr>
<tr><td><code id="getResults_+3A_dataset">dataset</code></td>
<td>
<p>index of the dataset from which to return results; by
default <code>dataset=NA</code> in which case results from all datasets
are returned</p>
</td></tr>
<tr><td><code id="getResults_+3A_verbose">verbose</code></td>
<td>
<p>logical that defaults to <code>TRUE</code> that determines
whether <code>parEst</code> just returns a list invisibly or prints as well. </p>
</td></tr>
<tr><td><code id="getResults_+3A_getclperr">getclperr</code></td>
<td>
<p>logical that defaults to <code>FALSE</code> that determines
whether a list containing the standard error estimates associated with
the conditionally linear parameters, as opposed to the conditionally
linear parameters themselves</p>
</td></tr>
<tr><td><code id="getResults_+3A_numsing">numsing</code></td>
<td>
<p>integer that defaults to 2; determines the number of
singular vectors to return</p>
</td></tr>
<tr><td><code id="getResults_+3A_weighted">weighted</code></td>
<td>
<p>logical indicating whether to return weighted or
unweighted data</p>
</td></tr>
<tr><td><code id="getResults_+3A_lreturna">lreturnA</code></td>
<td>
<p>logical indicating whether to return an A matrix instead</p>
</td></tr>
<tr><td><code id="getResults_+3A_lreturnc">lreturnC</code></td>
<td>
<p>logical indicating whether to return a C matrix instead</p>
</td></tr>
<tr><td><code id="getResults_+3A_file">file</code></td>
<td>
<p>character vector; if not <code>""</code> writes the results to a
file with name <code>file</code>. </p>
</td></tr>
<tr><td><code id="getResults_+3A_group">group</code></td>
<td>
<p>The value at which to determine the X matrix (maybe a
wavelength index, for example)</p>
</td></tr>
<tr><td><code id="getResults_+3A_stderr">stderr</code></td>
<td>
<p>Whether to return standard error estimates on parameters,
if they were calculated in fitting.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>sumnls</code> returns an object of class <code>"summary.nls"</code>.
</p>
<p><code>onls</code> returns an object of class <code>"nls"</code>.
</p>
<p><code>parEst</code> returns an object of class <code>"list"</code> representing
the parameter estimates and the standard errors if <code>stderr=TRUE</code>
and they have been calculated.
</p>
<p><code>getXList</code> returns a <code>"list"</code> of length equal to the number of
datasets modeled, where each element represents the matrix determined
by the nonlinear parameters (under a kinetic model, the concentrations).
</p>
<p><code>getCLPList</code> returns a <code>"list"</code> of length equal to the number of
datasets modeled, where each element represents the matrix determined
as conditionally linear parameters (under a kinetic model, the spectra).
</p>
<p><code>getX</code> returns a numeric <code>"matrix"</code>
that represents the matrix determined
by the nonlinear parameters (under a kinetic model, the concentrations).
However, in case lreturnC = TRUE it returns the C matrix, and in case
lreturnA = TRUE it returns the A matrix that is used to compute
the C matrix in case the kinetic model differs from parallel decays.
</p>
<p><code>getC</code> returns (under a kinetic model) a numeric <code>"matrix"</code>
that represents the raw matrix of concentrations of the dataset determined
by the nonlinear parameters.
</p>
<p><code>getDAS</code> returns (under a kinetic model) a numeric <code>"matrix"</code>
that represents the Decay Associated Spectra (DAS).
</p>
<p><code>getCLPList</code> returns a numeric <code>"matrix"</code>
that represents the matrix determined
as conditionally linear parameters (under a kinetic model, the spectra).
</p>
<p><code>getSVDData</code>
returns a <code>"list"</code> of length 3 with named elements
<code>values</code>, <code>left</code> and <code>right</code>, where  <code>values</code>
contains the singular values, <code>left</code> contains <code>numsing</code>
left singular vectors, and  <code>right</code> contains <code>numsing</code>
right singular vectors, all of the unweighted data. The number of singular
vectors returned is determined by <code>numsing</code>.
</p>
<p><code>getData</code> returns the dataset specified by the
argument <code>dataset</code> (weighted data in the case
that <code>weighted=TRUE</code>) as a <code>"matrix"</code>
</p>
<p><code>getResiduals</code> returns a <code>"matrix"</code> of residuals for the
dataset with index given by the argument <code>dataset</code>; the matrix
returned has the dimension of the dataset itself.
</p>
<p><code>getSVDResiduals</code>
returns a <code>"list"</code> of length 3 with named elements
<code>values</code>, <code>left</code> and <code>right</code>, where  <code>values</code>
contains the singular values, <code>left</code> contains <code>numsing</code>
left singular vectors, and  <code>right</code> contains <code>numsing</code>
right singular vectors, all of the residuals. The number of singular
vectors returned is determined by <code>numsing</code>.
</p>
<p><code>getTraces</code>  returns a <code>"matrix"</code> of model estimates for the
dataset with index given by the argument <code>dataset</code>; the matrix
returned has the dimension of the dataset itself.
</p>
<p><code>getdim1</code>  returns a <code>"vector"</code> of
<code>x</code> values in the dataset (times for kinetic models).
</p>
<p><code>getdim2</code>  returns a  <code>"vector"</code> of
<code>x2</code> values (wavelengths for kinetic models).
</p>


<h3>Author(s)</h3>

<p>Katharine M. Mullen, Ivo H. M. van Stokkum</p>


<h3>See Also</h3>

 <p><code><a href="#topic+fitModel">fitModel</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>


## Example showing the addition of non-negativity constraints to
## conditionally linear parameters (here the spectra associated with
## a kinetic model)

## For the 1st simulated dataset, the constraints offer a modest improvement
## in the estimated spectra, whereas for the 2nd simulated dataset, they
## prevent a catastrophe in which the estimated components are hugely
## compensating.

##############################
## load TIMP
##############################

require(TIMP)

##############################
## set random seed for reproducability of noise
##############################

set.seed(80)

##############################
## SIMULATE DATA, noise realization 1
##############################

 dt4 &lt;- simndecay_gen(kinpar = c(.4, .8, 2), seqmod = FALSE, tmax
     = 2, deltat = .04, specpar = list(c(25000, 3000, .01), c(22000,
     3000, .01), c(18000, 3000, .01)), lmin=350, lmax=550, deltal = 2,
     sigma=.01)

##############################
## SPECIFY INITIAL MODEL
##############################

mod1 &lt;- initModel(mod_type = "kin", kinpar = c(.4, .8, 2),
seqmod=FALSE)

##############################
## FIT INITIAL MODEL
##############################

sT &lt;- fitModel(list(dt4), list(mod1), opt=kinopt(iter=50, plot=FALSE))

##############################
## EXTRACT ESTIMATED SPECTRA
## these spectra have some negative values
##############################

sTcp &lt;- getCLP(sT)

## plot the estimated spectra with the values used in
## simulation  (before adding noise) for comparison
 matplot(dt4@x2, sTcp, xlab = "wavelength (nm)", col = 2:4, type="l",
        ylab="",lty=1, main =
        paste("Estimated spectra, adding no constraints\n"))
 matplot(dt4@x2,dt4@E2, add=TRUE, type="l", col=1, lty=2)
 abline(0,0)


##############################
## FIT INITIAL MODEL
## adding constraints to non-negativity of the
## spectra via the opt option nnls=TRUE
##############################

sV &lt;- fitModel(list(dt4), list(mod1), opt=kinopt(iter=50, nnls=TRUE,
                                        plot=FALSE))

##############################
## EXTRACT ESTIMATED SPECTRA
## these spectra have no negative values
##############################

sVcp &lt;- getCLP(sV)

## plot the estimated spectra with the values used in
## simulation  (before adding noise) for comparison
 matplot(dt4@x2, sVcp, xlab = "wavelength (nm)", col = 2:4, type="l",
 ylab="",lty=1,
         main = paste("Estimated spectra, with non-negativity constraints\n"))
 matplot(dt4@x2,dt4@E2, add=TRUE, type="l", col=1, lty=2)
 abline(0,0)

##############################
## SIMULATE DATA, noise realization 2
##############################

 dt4_2 &lt;- simndecay_gen(kinpar = c(.4, .8, 2), seqmod = FALSE, tmax
     = 2, deltat = .04, specpar = list(c(25000, 3000, .01), c(22000,
     3000, .01), c(18000, 3000, .01)), lmin=350, lmax=550, deltal = 2,
     sigma=.01)

##############################
## SPECIFY INITIAL MODEL
##############################

mod1 &lt;- initModel(mod_type = "kin", kinpar = c(.4, .8, 2),
seqmod=FALSE)

##############################
## FIT INITIAL MODEL
##############################

sT &lt;- fitModel(list(dt4_2), list(mod1), opt=kinopt(iter=50,plot=FALSE))

##############################
## EXTRACT ESTIMATED SPECTRA
## these spectra have some negative values
##############################

sTcp &lt;- getCLP(sT)

## plot the estimated spectra with the values used in
## simulation (before adding noise) for comparison
 matplot(dt4@x2, sTcp, xlab = "wavelength (nm)", col = 2:4, type="l",
        ylab="",lty=1, main =
        paste("Estimated spectra, adding no constraints\n"))
 matplot(dt4@x2,dt4@E2, add=TRUE, type="l", col=1, lty=2)
 abline(0,0)

##############################
## FIT INITIAL MODEL
## adding constraints to non-negativity of the
## spectra via the opt option nnls=TRUE
##############################

sV &lt;- fitModel(list(dt4_2), list(mod1), opt=kinopt(iter=50, nnls=TRUE,
                                          plot=FALSE))

##############################
## EXTRACT ESTIMATED SPECTRA
## these spectra have no negative values
##############################

sVcp &lt;- getCLP(sV)

## plot the estimated spectra with the values used in
## simulation (before adding noise) for comparison
 matplot(dt4@x2, sVcp, xlab = "wavelength (nm)", col = 2:4, type="l",
 ylab="",lty=1,
         main = paste("Estimated spectra, with non-negativity constraints\n"))
 matplot(dt4@x2,dt4@E2, add=TRUE, type="l", col=1, lty=2)
 abline(0,0)

 # end donttest

##############################
## CLEANUP GENERATED FILES
##############################
# This removes the files that were generated in this example
# (do not run this code if you wish to inspect the output)
file_list_cleanup = c(Sys.glob("*paramEst.txt"), Sys.glob("*.ps"), Sys.glob("Rplots*.pdf"))

# Iterate over the files and delete them if they exist
for (f in file_list_cleanup) {
  if (file.exists(f)) {
    unlink(f)
  }
}


</code></pre>

<hr>
<h2 id='initModel'>Defines the model to be used in analysis.</h2><span id='topic+initModel'></span>

<h3>Description</h3>

<p>Allows definition of a model of class &quot;dat&quot; to be used
in analysis.  The arguments specify the model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>initModel(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="initModel_+3A_...">...</code></td>
<td>
<p>specify the model class via the character string
e.g., <code><a href="#topic+kin-class">kin-class</a></code> or <code><a href="#topic+spec">spec</a></code> and
any of the slots associated with that model type (which is
a subclass of class <code>dat</code>, so that all slots in <code>dat</code>
may also be specified),
e.g., <code>mod_type = "kin"</code> will initialize a model with
class <code>kin</code>, for a kinetic model.  </p>
</td></tr>
</table>


<h3>Details</h3>

<p>For examples, see the help files for <code><a href="#topic+dat-class">dat-class</a></code> and
<code><a href="#topic+fitModel">fitModel</a></code></p>


<h3>Value</h3>

<p>an object of class <code>dat</code> with the sub-class given by the value of
the <code>mod_type</code> input.
</p>


<h3>Author(s)</h3>

<p>Katharine M. Mullen, Ivo H. M. van Stokkum</p>


<h3>See Also</h3>

 <p><code><a href="#topic+dat-class">dat-class</a></code>, <code><a href="#topic+kin-class">kin-class</a></code>,
<code><a href="#topic+spec-class">spec-class</a></code>,
<code><a href="#topic+fitModel">fitModel</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
##############################
## READ IN PSI 1
##############################

data(denS4)

##############################
## PREPROCESS PSI 1
##############################

denS4&lt;-preProcess(data = denS4, scalx2 = c(3.78, 643.5))

##############################
## READ IN PSI 2
##############################

data(denS5)

##############################
## PREPROCESS PSI 2
##############################

denS5&lt;-preProcess(data = denS5, scalx2 = c(3.78, 643.5))

##############################
## DEFINE INITIAL MODEL
##############################

model1&lt;- initModel(mod_type = "kin",
kinpar= c(7.9, 1.08, 0.129, .0225, .00156) ,
irfpar=c( -.1018, 0.0434),
disptau=FALSE, dispmu=TRUE, parmu = list(c(.230)),
lambdac = 650,
seqmod=TRUE,
positivepar=c("kinpar"),
title="S4",
cohspec = list( type = "irf"))



##############################
## FIT INITIAL MODEL
##############################

denRes1 &lt;- fitModel(data=list(denS4, denS5), list(model1),
opt=kinopt(iter=5, divdrel = TRUE, linrange = .2,
makeps = "den1", selectedtraces = c(1,5,10), plotkinspec =TRUE,
output="pdf", xlab = "time (ps)", ylab = "wavelength"))

##############################
## REFINE INITIAL MODEL, RE-FIT
## adding some per-dataset parameters
##############################

denRes2 &lt;- fitModel(data = list(denS4, denS5), modspec = list(model1),
modeldiffs = list(dscal = list(list(to=2,from=1,value=.457)),
free = list(
list(what = "irfpar", ind = 1, dataset = 2, start=-.1932),
list(what = "kinpar", ind = 5, dataset = 2, start=.0004),
list(what = "kinpar", ind = 4, dataset = 2, start= .0159)
)),
opt=kinopt(iter=5, divdrel = TRUE, linrange = .2,
xlab = "time (ps)", ylab = "wavelength", output="pdf",
makeps = "den2", selectedtraces = c(1,5,10)))

##############################
## REFINE MODEL FURTHER AS NEW MODEL OBJECT
##############################

model2 &lt;- initModel(mod_type = "kin",
kinpar= c(7.9, 1.08, 0.129, .0225, .00156),
irfpar=c( -.1018, 0.0434),
parmu = list(c(.230)),
lambdac = 650,
positivepar=c("kinpar", "coh"),
cohspec = list( type = "seq", start = c(8000, 1800)))

##############################
## FIT NEW MODEL OBJECT
##############################

denRes3 &lt;- fitModel(data = list(denS4, denS5), list(model2),
modeldiffs = list(dscal = list(list(to=2,from=1,value=.457)),
free = list(
list(what = "irfpar", ind = 1, dataset = 2, start=-.1932),
list(what = "kinpar", ind = 5, dataset = 2, start=.0004),
list(what = "kinpar", ind = 4, dataset = 2, start= .0159)
)),
opt=kinopt(iter=5, divdrel = TRUE, linrange = .2,
makeps = "den3", selectedtraces = c(1,5,10), plotkinspec =TRUE,
stderrclp = TRUE, kinspecerr=TRUE, output="pdf",
xlab = "time (ps)", ylab = "wavelength",
breakdown = list(plot=c(643.50, 658.62, 677.5))))

 # end donttest

##############################
## CLEANUP GENERATED FILES
##############################
# This removes the files that were generated in this example
# (do not run this code if you wish to inspect the output)
file_list_cleanup = c('den1_paramEst.txt', 'den2_paramEst.txt', 'den3_paramEst.txt',
  Sys.glob("*paramEst.txt"), Sys.glob("*.ps"), Sys.glob("Rplots*.pdf"))

# Iterate over the files and delete them if they exist
for (f in file_list_cleanup) {
  if (file.exists(f)) {
    unlink(f)
  }
}

</code></pre>

<hr>
<h2 id='Internals'>TIMP function used internally</h2><span id='topic+Internals'></span><span id='topic+addDscal'></span><span id='topic+addPrel'></span><span id='topic+addPrelCl'></span><span id='topic+applyWeighting'></span><span id='topic+applyWeightingModel'></span><span id='topic+baseCorlambda'></span><span id='topic+baseCortime'></span><span id='topic+calcB'></span><span id='topic+calcC'></span><span id='topic+calcCirf'></span><span id='topic+calcEbspline'></span><span id='topic+calcEhiergaus'></span><span id='topic+compCoh'></span><span id='topic+compModel'></span><span id='topic+compOsc'></span><span id='topic+convGausExp'></span><span id='topic+diffAdd'></span><span id='topic+diffChange'></span><span id='topic+diffFree'></span><span id='topic+diffRel'></span><span id='topic+diffRemove'></span><span id='topic+displayEst'></span><span id='topic+doClpConstr'></span><span id='topic+doSVD'></span><span id='topic+fillK'></span><span id='topic+fullKF'></span><span id='topic+gaus'></span><span id='topic+getClpConstr'></span><span id='topic+getClpList'></span><span id='topic+getCoh'></span><span id='topic+getCohToPlot'></span><span id='topic+getConToPlot'></span><span id='topic+getDiffTheta'></span><span id='topic+getDiffThetaChange'></span><span id='topic+getDiffThetaCl'></span><span id='topic+getDiffThetaClChange'></span><span id='topic+getFixed'></span><span id='topic+getGroups'></span><span id='topic+getModel'></span><span id='topic+getOsc'></span><span id='topic+getPar'></span><span id='topic+getPrel'></span><span id='topic+getPrelTheta'></span><span id='topic+getSpecList'></span><span id='topic+getSpecToPlot'></span><span id='topic+getTheta'></span><span id='topic+getThetaCl'></span><span id='topic+initModellist'></span><span id='topic+irfparF'></span><span id='topic+l2nu'></span><span id='topic+linloglines'></span><span id='topic+linlogplot'></span><span id='topic+matlinlogplot'></span><span id='topic+normdat'></span><span id='topic+plotFLIM'></span><span id='topic+plotKinBreakDown'></span><span id='topic+plotClp'></span><span id='topic+plotSelectedSpectra'></span><span id='topic+plotSelectedTraces'></span><span id='topic+plotSelectedTracesSuper'></span><span id='topic+plotTraces'></span><span id='topic+plotTracesSuper'></span><span id='topic+rescomp'></span><span id='topic+sample_sel'></span><span id='topic+simndecay_gen'></span><span id='topic+simpExp'></span><span id='topic+simpPol'></span><span id='topic+skew'></span><span id='topic+specModel'></span><span id='topic+specparF'></span><span id='topic+timpErrors'></span><span id='topic+weightNL'></span><span id='topic+weightPsi'></span><span id='topic+weightSM'></span><span id='topic+writeEst'></span><span id='topic+writeFit'></span><span id='topic+plotKinSpecEst'></span><span id='topic+plotEst'></span><span id='topic+fillResult'></span><span id='topic+processOrder'></span><span id='topic+multiLin'></span><span id='topic+scaleConList'></span><span id='topic+getXsuper'></span><span id='topic+getKinConcen'></span><span id='topic+doConstrSuper'></span><span id='topic+compModelMass'></span><span id='topic+barplot3'></span><span id='topic+getAutoClp0'></span><span id='topic+getResidRet'></span><span id='topic+linlogtics'></span><span id='topic+unitstep'></span><span id='topic+getSelectedTracesMax'></span><span id='topic+calcD'></span>

<h3>Description</h3>

<p>TIMP function used internally</p>


<h3>Arguments</h3>

<p>Arguments specified per function</p>


<h3>Value</h3>

<p>No return value, register alias for all internally used functions</p>


<h3>Author(s)</h3>

<p>Katharine M. Mullen and Joris J. Snellenburg and Ivo H. M. van Stokkum</p>


<h3>See Also</h3>

<p><code><a href="#topic+baseIRF">baseIRF</a></code>,<code><a href="#topic+readData">readData</a></code>,
<code><a href="#topic+preProcess">preProcess</a></code>,<code><a href="#topic+initModel">initModel</a></code>,
<code><a href="#topic+fitModel">fitModel</a></code>,<code><a href="#topic+examineFit">examineFit</a></code>,
<code><a href="#topic+sumKinSpecEst">sumKinSpecEst</a></code>
</p>

<hr>
<h2 id='kin-class'>Class &quot;kin&quot; for kinetic model storage.</h2><span id='topic+kin-class'></span><span id='topic+kin'></span>

<h3>Description</h3>

<p><code>kin</code> is the class for kinetic models;
an object
of class &quot;kin&quot; is initialized if
<code>mod_type = "kin"</code> is an
argument of <code>initModel</code>.
All objects of class <code>kin</code> are sub-classes of
class <code>dat</code>; see documentation for <code>dat</code>
for a description of
these slots.  </p>


<h3>Details</h3>

<p>See <code><a href="#topic+dat-class">dat-class</a></code> for an
example of the initialization of a
<code>kin</code> object via the <code>initModel</code> function. </p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("kin", ...)</code> or
<code>kin(...)</code>.  Slots whose
description are marked with *** may
be specified in the <code>...</code>
argument of the  <code><a href="#topic+initModel">initModel</a></code> function.
</p>


<h3>Slots</h3>


<dl>
<dt>anipar</dt><dd></dd>
<dt>anispec</dt><dd></dd>
<dt>autoclp0</dt><dd></dd>
<dt>C2</dt><dd></dd>
<dt>chinde</dt><dd></dd>
<dt>clinde</dt><dd></dd>
<dt>clp0</dt><dd></dd>
<dt>clpCon</dt><dd></dd>
<dt>clpdep</dt><dd></dd>
<dt>clpequ</dt><dd></dd>
<dt>clpequspecBD</dt><dd></dd>
<dt>clpType</dt><dd></dd>
<dt>cohcol</dt><dd></dd>
<dt>cohirf</dt><dd></dd>
<dt>datafile</dt><dd></dd>
<dt>datCall</dt><dd></dd>
<dt>drel</dt><dd></dd>
<dt>dscal</dt><dd></dd>
<dt>dscalspec</dt><dd></dd>
<dt><code>dummy</code>:</dt><dd><p>Object of class <code>"list"</code> of dummy parameters which can be used in complex relations</p>
</dd>
<dt>E2</dt><dd></dd>
<dt>fixed</dt><dd></dd>
<dt>fixedkmat</dt><dd></dd>
<dt>free</dt><dd></dd>
<dt>fvecind</dt><dd></dd>
<dt>getX</dt><dd></dd>
<dt>getXsuper</dt><dd></dd>
<dt>highcon</dt><dd></dd>
<dt>inten</dt><dd></dd>
<dt>kin2scal</dt><dd></dd>
<dt>kinpar2</dt><dd></dd>
<dt>kinscalspecial</dt><dd></dd>
<dt>kinscalspecialspec</dt><dd></dd>
<dt>lclp0</dt><dd></dd>
<dt>lclpequ</dt><dd></dd>
<dt>title</dt><dd></dd>
<dt>parnames</dt><dd></dd>
<dt>prel</dt><dd></dd>
<dt>prelspec</dt><dd></dd>
<dt>psi.df</dt><dd></dd>
<dt>psi.weight</dt><dd></dd>
<dt>pvecind</dt><dd></dd>
<dt>satMat</dt><dd></dd>
<dt>scalx</dt><dd></dd>
<dt>usecompnames0</dt><dd></dd>
<dt>usecompnamesequ</dt><dd></dd>
<dt>usekin2</dt><dd></dd>
<dt>weight</dt><dd></dd>
<dt>weightList</dt><dd></dd>
<dt>weightM</dt><dd></dd>
<dt>weightpar</dt><dd></dd>
<dt>weightsmooth</dt><dd></dd>
<dt>x</dt><dd></dd>
<dt>x2</dt><dd></dd>
<dt>clpequspec</dt><dd></dd>
<dt>compnames</dt><dd></dd>
<dt>constrained</dt><dd></dd>
<dt>iter</dt><dd></dd>
<dt>lightregimespec</dt><dd></dd>
<dt>lowcon</dt><dd></dd>
<dt>makeps</dt><dd></dd>
<dt>mhist</dt><dd></dd>
<dt>mod_type</dt><dd></dd>
<dt>mvecind</dt><dd></dd>
<dt>ncomp</dt><dd></dd>
<dt>nl</dt><dd></dd>
<dt>nt</dt><dd></dd>
<dt>nvecind</dt><dd></dd>
<dt>outMat</dt><dd></dd>
<dt>positivepar</dt><dd></dd>
<dt>sigma</dt><dd></dd>
<dt>simdata</dt><dd></dd>
<dt>speckin2</dt><dd></dd>
<dt>kinpar</dt><dd><p>*** vector of rate constants to be used as starting
values for the exponential decay of components; the length of this
vector determines the number of components of the kinetic
model. </p>
</dd>
<dt><code>specpar</code>:</dt><dd><p>*** Object of class <code>"list"</code>  parameters for
spectral constraints</p>
</dd>
<dt><code>seqmod</code>:</dt><dd><p>*** Object of class <code>"logical"</code>  that is <code>TRUE</code> if a sequential model is to be applied
and <code>FALSE</code> otherwise</p>
</dd>
<dt><code>irf</code>:</dt><dd><p>Object of class <code>"logical"</code>   that is <code>TRUE</code> is an IRF is modeled and <code>FALSE</code> otherwise</p>
</dd>
<dt><code>mirf</code>:</dt><dd><p>Object of class <code>"logical"</code>  that is <code>TRUE</code> if a measured IRF is modeled and <code>FALSE</code>
otherwise</p>
</dd>
<dt><code>measured_irf</code>:</dt><dd><p>*** Object of class <code>"vector"</code>  containing a measured IRF</p>
</dd>
<dt><code>convalg</code>:</dt><dd><p>*** Object of class <code>"numeric"</code>  1-3 determining the numerical convolution algorithm
used in the case of modeling a measured IRF; if <code>3</code> then supply a
reference lifetime in the slot <code>reftau</code>.</p>
</dd>
<dt><code>reftau</code>:</dt><dd><p>*** Object of class <code>"numeric"</code>  containing a
reference lifetime to be used when <code>convalg=3</code></p>
</dd>
<dt><code>irffun</code>:</dt><dd><p>*** Object of class <code>"character"</code>  describing the
function to use to describe the IRF, by default &quot;gaus&quot;</p>
</dd>
<dt><code>irfpar</code>:</dt><dd><p>*** Object of class <code>"vector"</code>  of IRF parameters; for the common Gaussian IRF this
vector is ordered <code>c(location, width)</code></p>
</dd>
<dt><code>dispmu</code>:</dt><dd><p>Object of class <code>"logical"</code>   that is <code>TRUE</code> if dispersion of the parameter for IRF
location is to be modeled and <code>FALSE</code> otherwise</p>
</dd>
<dt><code>dispmufun</code>:</dt><dd><p>***Object of class <code>"character"</code>  describing the functional form of the
dispersion of the IRF location parameter; if equal to &quot;discrete&quot; then the
IRF location is shifted per element of <code>x2</code> and <code>parmu</code> should have the same
length as <code>x2</code>.  defaults to a polynomial description</p>
</dd>
<dt><code>parmu</code>:</dt><dd><p>*** Object of class <code>"list"</code>   of starting values for the dispersion model for the
IRF location</p>
</dd>
<dt><code>disptau</code>:</dt><dd><p>Object of class <code>"logical"</code>  that is <code>TRUE</code> if dispersion of the parameter for
IRF width is to be modeled and <code>FALSE</code> otherwise</p>
</dd>
<dt><code>disptaufun</code>:</dt><dd><p>*** Object of class <code>"character"</code>  describing the functional form of the
dispersion of the IRF width parameter; if equal to <code>"discrete"</code> then the
IRF width is parameterized per element of <code>x2</code> and <code>partau</code> should have the same
length as <code>x2</code>.  defaults to a polynomial description</p>
</dd>
<dt><code>partau</code>:</dt><dd><p>*** Object of class <code>"vector"</code>  of starting values for the dispersion model for the
IRF FWHM </p>
</dd>
<dt><code>fullk</code>:</dt><dd><p>Object of class <code>"logical"</code>  that is <code>TRUE</code> if the data are to be modeled using a
compartmental model defined in a K matrix and <code>FALSE</code> otherwise</p>
</dd>
<dt><code>kmat</code>:</dt><dd><p>*** Object of class <code>"array"</code>  containing the K matrix descriptive of  a compartmental
model</p>
</dd>
<dt><code>jvec</code>:</dt><dd><p>*** Object of class <code>"vector"</code>  containing the J vector descriptive of the inputs to a
compartmental model</p>
</dd>
<dt><code>ncolc</code>:</dt><dd><p>Object of class <code>"vector"</code>  describing the number of columns of the C matrix for
each clp in <code>x2</code></p>
</dd>
<dt><code>kinscal</code>:</dt><dd><p>*** Object of class <code>"vector"</code>   of starting values for branching parameters in a
compartmental model</p>
</dd>
<dt><code>kmatfit</code>:</dt><dd><p>Object of class <code>"array"</code>  of fitted values for a compartmental model</p>
</dd>
<dt><code>cohspec</code>:</dt><dd><p>*** Object of class <code>"list"</code>   describing the model for
coherent artifact/scatter component(s) containing the element  <code>type</code>
and optionally the element <code>numdatasets</code>.  The element
<code>type</code> can be set as follows:
</p>

<dl>
<dt><code>"irf"</code>:</dt><dd><p>if <code>type="irf"</code>, the coherent artifact/scatter has the
time profile of  the IRF.</p>
</dd>
<dt><code>"freeirfdisp"</code>:</dt><dd><p>if <code>type="freeirfdisp"</code>, the  coherent
artifact/scatter has  a
Gaussian time profile whose location and width are parameterized in the
vector <code>coh</code>.  </p>
</dd>
<dt><code>"irfmulti"</code>:</dt><dd><p>if <code>type="irfmulti"</code> the time profile of
the IRF is used for
the coherent artifact/scatter model, but the IRF parameters are taken per
dataset (for the multidataset case), and the integer argument
<code>numdatasets</code> must be equal to the
number of datasets modeled.</p>
</dd>
<dt><code>"seq"</code>:</dt><dd><p>if <code>type="seq"</code> a sequential exponential decay
model is applied, whose starting value are contained in an additional
list element <code>start</code>. This
often models oscillating behavior well, where the number of
oscillations is the number of parameter starting values given in
<code>start</code>.  The starting values after optimization will be found in
the slot <code>coh</code> of the object of class <code>theta</code> corresponding
to each dataset modeled. </p>
</dd>
<dt><code>"mix"</code>:</dt><dd><p>if <code>type="mix"</code> if <code>type="mix"</code> a sequential exponential decay
model is applied along with a model that follows the time profile of the IRF;
the coherent artifact/scatter is then a linear superposition of these two
models; see the above description of <code>seq</code> for how to supply the
starting values. </p>
</dd></dl>
</dd>
<dt><code>coh</code>:</dt><dd><p>*** Object of class <code>"vector"</code>  of starting values for the parameterization of a
coherent artifact</p>
</dd>
<dt><code>oscspec</code>:</dt><dd><p>*** Object of class <code>"list"</code> describing the model for
additional oscillation component(s) containing the element  <code>type</code>
and optionally the element <code>start</code>. The element <code>start</code> can be used to specify the starting values for the oscillation function. The element <code>type</code> can be set as follows:
</p>

<dl>
<dt><code>"harmonic"</code>:</dt><dd><p>if <code>type="harmonic"</code>, the oscillation function is a damped harmonic oscillator.</p>
</dd> </dl>

</dd>
<dt><code>oscpar</code>:</dt><dd><p>*** Object of class <code>"vector"</code>  of starting values for the oscillation parameters</p>
</dd>
<dt><code>wavedep</code>:</dt><dd><p>Object of class <code>"logical"</code>  describing whether the kinetic model is dependent on
<code>x2</code> index (i.e., whether there is clp-dependence)</p>
</dd>
<dt><code>lambdac</code>:</dt><dd><p>*** Object of class <code>"numeric"</code>  for the center wavelength to be used in a polynomial
description of <code>x2</code>-dependence </p>
</dd>
<dt><code>amplitudes</code>:</dt><dd><p>*** Object of class <code>"vector"</code>
that may be used to multiply the concentrations by a square diagonal
matrix with the number of columns that the concentration matrix has;
the diagonal is given in <code>amplitudes</code> and these values will be
treated as parameters to be optimized.
</p>
</dd>
<dt><code>streak</code>:</dt><dd><p>*** Object of class <code>"logical"</code>
that defaults to <code>FALSE</code>; if <code>streak=TRUE</code> then
the period of the laser is expected via <code>streakT</code>.</p>
</dd>
<dt><code>streakT</code>:</dt><dd><p>*** Object of class <code>"numeric"</code>
the period of the laser; this will be used to add a
backsweep term to the concentration matrix and should be
set in conjunction <code>streak=TRUE</code>.</p>
</dd>
<dt><code>doublegaus</code>:</dt><dd><p>*** Object of class <code>"logical"</code>
that defaults to <code>FALSE</code> and determines whether a double
Gaussian should be used to model the IRF. If   <code>doublegaus=TRUE</code>
then <code>irfpar</code> should contain four numeric values corresponding to
the location (mean) of the IRF, the FWHM of the first Gaussian, the
FWHM of the second Gaussian, and the relative amplitude of the
second Gaussian, respectively.
</p>
</dd>
<dt><code>multiplegaus</code>:</dt><dd><p>*** Object of class <code>"logical"</code>
that defaults to <code>FALSE</code> and determines whether multiple
Gaussians should be used to model the IRF. If <code>multiplegaus=TRUE</code>
then <code>irfpar</code> should contain: two numeric values corresponding to
the location (mean) and the FWHM of the first Gaussian of the IRF, and
three numeric values for <b>each</b> additional gaussian modeled, corresponding to
the relative scaling to the first gaussian, the shift (in time) relative to the
first gaussian and the FWHM of the additional Gaussian, respectively.
</p>
</dd>
<dt><code>numericalintegration</code>:</dt><dd><p>*** Object of class <code>"logical"</code>
that defaults to <code>FALSE</code> and determines whether a kinetic theory
model of a reaction mechanism should be numerically integrated (using
<span class="pkg">deSolve</span>) to find the concentrations.
If <code>numericalintegration=TRUE</code> then
<code>initialvals</code> should specify the initial concentrations and
<code>reactantstoichiometrymatrix</code> and
<code>stoichiometrymatrix</code> should specify the reaction mechanism,
as per Puxty et. al. (2006).
</p>
</dd>
<dt><code>initialvals</code>:</dt><dd><p>*** Object of class <code>"vector"</code>
giving the concentrations at the initial time step.
</p>
</dd>
<dt><code>reactantstoichiometrymatrix</code>:</dt><dd><p>*** Object of class <code>"vector"</code>
giving the (integer) <dfn>stoichiometric coefficients</dfn> for the reactants; this
is the matrix <b>X</b>r of Puxty et. al. (2006) with <code>dim=NULL</code>.
</p>
</dd>
<dt><code>stoichiometrymatrix</code>:</dt><dd><p>*** Object of class <code>"vector"</code>
giving the (integer) stoichiometric coefficients for the reactions; this
is the matrix <b>X</b> of Puxty et. al. (2006) with <code>dim=NULL</code>.
</p>
</dd>
</dl>


<h3>Extends</h3>

<p>Class <code><a href="#topic+dat-class">dat-class</a></code>, directly.
</p>


<h3>Author(s)</h3>

<p>Katharine M. Mullen, David Nicolaides, Ivo H. M. van Stokkum</p>


<h3>References</h3>

<p>Puxty, G., Maeder, M., and Hungerbuhler, K. (2006) Tutorial on the fitting of
kinetics models to multivariate spectroscopic measurements
with non-linear least-squares regression, <em>Chemometrics and Intelligent
Laboratory Systems</em> <b>81</b>, 149-164.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dat-class">dat-class</a></code>, <code><a href="#topic+spec-class">spec-class</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Example in modeling second order kinetics, by
## David Nicolaides.

## On simulated data.

##############################
## load TIMP
##############################

library("TIMP")

##############################
## SIMULATE DATA
##############################

## set up the Example problem, a la in-situ UV-Vis spectroscopy of a simple
## reaction.
## A + 2B -&gt; C + D, 2C -&gt; E

cstart &lt;- c(A = 1.0, B = 0.8, C = 0.0, D = 0.0, E = 0.0)
times &lt;- c(seq(0,2, length=21), seq(3,10, length=8))
k &lt;- c(kA = 0.5, k2C = 1)

## stoichiometry matrices

rsmatrix &lt;- c(1,2,0,0,0,0,0,2,0,0)
smatrix &lt;- c(-1,-2,1,1,0,0,0,-2,0,1)
concentrations &lt;- calcD(k, times, cstart, rsmatrix, smatrix)

wavelengths &lt;- seq(500, 700, by=2)
spectra &lt;- matrix(nrow = length(wavelengths), ncol = length(cstart))
location &lt;- c(550, 575, 625, 650, 675)
delta &lt;- c(10, 10, 10, 10, 10)
spectra[, 1] &lt;- exp( - log(2) *
(2 * (wavelengths - location[1])/delta[1])^2)
spectra[, 2] &lt;- exp( - log(2) *
(2 * (wavelengths - location[2])/delta[2])^2)
spectra[, 3] &lt;- exp( - log(2) *
(2 * (wavelengths - location[3])/delta[3])^2)
spectra[, 4] &lt;- exp( - log(2) *
(2 * (wavelengths - location[4])/delta[4])^2)
spectra[, 5] &lt;- exp( - log(2) *
(2 * (wavelengths - location[5])/delta[5])^2)

sigma &lt;- .001
Psi_q &lt;- concentrations %*% t(spectra) + sigma *
  rnorm(dim(concentrations)[1] * dim(spectra)[1])

## store the simulated data in an object of class "dat"
kinetic_data &lt;- dat(psi.df=Psi_q , x = times, nt = length(times),
 x2 = wavelengths, nl = length(wavelengths))

##############################
## DEFINE MODEL
##############################

## starting values
kstart &lt;- c(kA = 1, k2C = 0.5)

## model definition for 2nd order kinetics
kinetic_model &lt;- initModel(mod_type = "kin", seqmod = FALSE,
                           kinpar = kstart,
                           numericalintegration = TRUE,
                           initialvals = cstart,
                           reactantstoichiometrymatrix = rsmatrix,
                           stoichiometrymatrix = smatrix )

##############################
## FIT INITIAL MODEL
## adding constraints to non-negativity of the
## spectra via the opt option nnls=TRUE
##############################

kinetic_fit &lt;- fitModel(data=list(kinetic_data),
                        modspec = list(kinetic_model),
                        opt = kinopt(nnls = TRUE, iter=80,
                        selectedtraces = seq(1,kinetic_data@nl,by=2)))

## look at estimated parameters

parEst(kinetic_fit)

## various results

## concentrations

conRes &lt;- getX(kinetic_fit)

matplot(times, conRes, type="b", col=1,pch=21, bg=1:5, xlab="time (sec)",
        ylab="concentrations", main="Concentrations (2nd order kinetics)")


## spectra

specRes &lt;- getCLP(kinetic_fit)

matplot(wavelengths, specRes, type="b", col=1,pch=21, bg=1:5,
        xlab="wavelength (nm)",
        ylab="amplitude", main="Spectra")

## see help(getResults) for how to get more results information from
## kinetic_fit

##############################
## CLEANUP GENERATED FILES
##############################
# This removes the files that were generated in this example
# (do not run this code if you wish to inspect the output)
file_list_cleanup = c(Sys.glob("*paramEst.txt"), Sys.glob("*.ps"), Sys.glob("Rplots*.pdf"))
# Iterate over the files and delete them if they exist
for (f in file_list_cleanup) {
  if (file.exists(f)) {
    unlink(f)
  }
}

</code></pre>

<hr>
<h2 id='kinopt-class'>Class &quot;kinopt&quot; stores options for fitting and plotting kinetic models</h2><span id='topic+kinopt-class'></span><span id='topic+kinopt'></span>

<h3>Description</h3>

<p>Class &quot;kinopt&quot; stores options for fitting and plotting kinetic
models in particular; this is a subclass of class <code>opt</code></p>


<h3>Details</h3>

<p>See <code><a href="#topic+opt-class">opt-class</a></code> for
the specification of fitting/plotting options that are not specific to the
class type.</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("kinopt", ...)</code> or
<code>kinopt(...)</code>
</p>


<h3>Slots</h3>


<dl>
<dt><code>notraces</code>:</dt><dd><p>Object of class <code>"logical"</code> that defaults
to <code>FALSE</code>; if <code>TRUE</code>, do not plot traces</p>
</dd>
<dt><code>selectedtraces</code>:</dt><dd><p>Object of class <code>"vector"</code> containing
<code>x</code> indices for which plots of
traces are desired under a kinetic model </p>
</dd>
<dt><code>breakdown</code>:</dt><dd><p>Object of class <code>"list"</code> with the
following elements:
</p>

<ul>
<li><p>plotvector of <code>x2</code> values to plot the breakdown for.
These values be specified in
a fuzzy way:  an <code>x2</code> value within <code>abs(x2[1] - x2[2])/100</code>
a value given in <code>plot</code> means that a plot for that <code>x2</code> value
will be generated, where
the reference <code>x2[1]</code> and <code>x2[2]</code> are from the first dataset
modeled.

</p>
</li>
<li><p>tolnumeric giving a tolerance by which
the values in <code>plot</code> are compared to <code>x2</code> values
for near-equality. The default is defined as
<code>abs(x2[1] - x2[2])/100</code>. 
</p>
</li>
<li><p>superimposevector of dataset indices for which results should
be superimposed if the dataset has an <code>x2</code> value at a value in
<code>plot</code>.
</p>
</li></ul>

</dd>
<dt>FLIM</dt><dd><p>Object of class <code>"logical"</code> that defaults to
<code>FALSE</code>; if <code>TRUE</code>, the data represent a FLIM experiment and
special plots are generated. </p>
</dd>
<dt>FLIMresidimag</dt><dd><p>Object of class <code>"logical"</code> that defaults to
<code>TRUE</code>; if <code>FALSE</code> and a FLIM image is analyzed, the residuals
are not plotted as an image.</p>
</dd>
<dt>noFLIMsummary</dt><dd><p>Object of class <code>"logical"</code> that defaults to
<code>FALSE</code>; if <code>TRUE</code> and a FLIM image is analyzed, only other
plots requested by the user (such as traces or residuals) are generated, and
no summary plot in made.</p>
</dd>
<dt>kinspecest</dt><dd><p>Object of class <code>"logical"</code> that defaults to
<code>FALSE</code>; if <code>TRUE</code>, make a plot of the spectra associated with
the kinetic components as well as the lifetime estimates. </p>
</dd>
<dt>writeplaincon</dt><dd><p>Object of class <code>"list"</code>; if length is greater
than 0, then the concentration model will be evaluated at the vector of
<code>x</code> values supplied as the element <code>"x"</code> of <code>writeplaincon</code>
and the result will be written to file for each dataset.
</p>
</dd>
<dt>writerawcon</dt><dd><p>Object of class <code>"logical"</code>
that defaults to <code>FALSE</code>; if <code>TRUE</code>, then the representation of
the concentration profiles before the application of constraints (to
account for the equality of spectra, etc.) is written to file for each
dataset.
</p>
</dd>
<dt>plotcohcolspec</dt><dd><p>Object of class <code>"logical"</code>
that defaults to <code>TRUE</code>; if <code>FALSE</code> then the spectra associated
with the coherent artifact (pulse-follower) are not included in the summary
plots
</p>
</dd>
<dt><code>plotpulsefol</code>:</dt><dd><p>Object of class <code>"logical"</code> defaults to
<code>FALSE</code>; if <code>TRUE</code> adding imageplots of pulsefolower amplitudes in summary plot (only with FLIM plots).</p>
</dd>
<dt>ylimcomp</dt><dd><p>Object of class <code>"vector"</code> that defaults to
<code>vector()</code>; Works In the case of plotting the results of FLIM image
analysis, <code>ylimspec</code> can be used to determine the range used in the
image plot of normalized amplitudes.</p>
</dd>
<dt>addfilename</dt><dd></dd>
<dt>addest </dt><dd></dd>
<dt>adddataimage</dt><dd></dd>
<dt>algorithm</dt><dd></dd>
<dt>coldata</dt><dd></dd>
<dt>colfit</dt><dd></dd>
<dt>divdrel</dt><dd></dd>
<dt>getStartTri</dt><dd></dd>
<dt>imagepal</dt><dd></dd>
<dt>iter</dt><dd></dd>
<dt>kinspecerr</dt><dd></dd>
<dt>linrange</dt><dd></dd>
<dt>ltydata</dt><dd></dd>
<dt>ltyfit</dt><dd></dd>
<dt>makeps</dt><dd></dd>
<dt>maxfev</dt><dd></dd>
<dt>minFactor</dt><dd></dd>
<dt>nlsalgorithm</dt><dd></dd>
<dt>nnls</dt><dd></dd>
<dt>nnlscrit</dt><dd></dd>
<dt>noplotest</dt><dd></dd>
<dt>normspec</dt><dd></dd>
<dt>optimmethod</dt><dd></dd>
<dt>output</dt><dd></dd>
<dt>paropt</dt><dd></dd>
<dt>parscale</dt><dd></dd>
<dt>plot</dt><dd></dd>
<dt>plotkinspec</dt><dd></dd>
<dt>residplot</dt><dd></dd>
<dt>residtraces</dt><dd></dd>
<dt>samespecline</dt><dd></dd>
<dt>specinterpol</dt><dd></dd>
<dt>specinterpolbspline</dt><dd></dd>
<dt>specinterpolpoints</dt><dd></dd>
<dt>specinterpolseg</dt><dd></dd>
<dt>stderrclp</dt><dd></dd>
<dt>summaryplotcol</dt><dd></dd>
<dt>summaryplotrow</dt><dd></dd>
<dt>sumnls</dt><dd></dd>
<dt>superimpose</dt><dd></dd>
<dt>title</dt><dd></dd>
<dt>trilinear</dt><dd></dd>
<dt>triStart</dt><dd></dd>
<dt>writeclperr</dt><dd></dd>
<dt>writecon</dt><dd></dd>
<dt>writedata</dt><dd></dd>
<dt>writefit</dt><dd></dd>
<dt>writefitivo</dt><dd></dd>
<dt>writenormspec</dt><dd></dd>
<dt>writespec</dt><dd></dd>
<dt>writespecinterpol</dt><dd></dd>
<dt>xlab</dt><dd></dd>
<dt>xlim</dt><dd></dd>
<dt>xlimspec</dt><dd></dd>
<dt>ylab</dt><dd></dd>
<dt>ylimspec</dt><dd></dd>
<dt>ylimspecplus</dt><dd></dd>
</dl>



<h3>Author(s)</h3>

<p>Katharine M. Mullen, Ivo H. M. van Stokkum</p>


<h3>See Also</h3>

<p><code><a href="#topic+examineFit">examineFit</a></code>, <code><a href="#topic+fitModel">fitModel</a></code>, <code><a href="#topic+opt-class">opt-class</a></code>, <code><a href="#topic+specopt-class">specopt-class</a></code>
</p>

<hr>
<h2 id='mass-class'>Class &quot;mass&quot; for mass spectrometry model storage.</h2><span id='topic+mass-class'></span><span id='topic+mass'></span>

<h3>Description</h3>

 
<p><code>mass</code> is the class for mass spectrometry models; an object 
of class &quot;mass&quot; is initialized if 
<code>mod_type = "mass"</code> is an 
argument of <code>initModel</code>.
All objects of class <code>mass</code> are sub-classes of 
class <code>kin</code>; see documentation for <code>kin</code> 
for a description of 
these slots.  </p>


<h3>Details</h3>

<p>See <code><a href="#topic+kin-class">kin-class</a></code> for an 
example of the initialization of a 
<code>kin</code> object via the <code>initModel</code> function. </p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("mass", ...)</code> or 
<code>kin(...)</code>.
</p>


<h3>Slots</h3>


<dl>
<dt>peakpar</dt><dd><p> list of vectors of starting values for the parameters
of components; one vector of values is used to parameterize 
each component. 
</p>
</dd>
<dt><code>peakfunct</code>:</dt><dd><p> Object of class <code>"character"</code>  
that specifies the function by which components are parameterized in time; 
this is by default &quot;expmodgaus&quot; for the exponentially modified Gaussian 
function.</p>
</dd>
<dt><code>lzerofile</code>:</dt><dd><p> Object of class <code>"character"</code>  that 
specifies the filename of the lzero specification to read in from file.  This
file has the format: 1st line not read; lines thereafter 
are the space-delimited index of the component to constrain, the 
lower bound of the constraint, and the upper bound of the 
constraint, e.g., <code>1 218.80 220.09</code>
</p>
</dd>
<dt><code>extracomp</code>:</dt><dd><p> Object of class <code>"logical"</code>  that
defaults to <code>TRUE</code> and determines whether a component with 
constant concentration in time is added to the model to represent 
a baseline.</p>
</dd>  
<dt><code>shift</code>:</dt><dd><p> Object of class <code>"vector"</code> that represents
a shift of the location of each elution profile peak; this can be
specified per-component, in which case <code>length(shift)</code> is the 
number of components (not including a baseline component) or for
all components, in which case <code>length(shift == 1)</code>. 
</p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code><a href="#topic+kin-class">kin-class</a></code>, directly.
</p>


<h3>Author(s)</h3>

<p>Katharine M. Mullen, Ivo H. M. van Stokkum</p>


<h3>See Also</h3>

<p><code><a href="#topic+kin-class">kin-class</a></code>, <code><a href="#topic+spec-class">spec-class</a></code>
</p>

<hr>
<h2 id='massopt-class'>Class &quot;massopt&quot; stores options for fitting and plotting models
for mass spectrometry data</h2><span id='topic+massopt-class'></span><span id='topic+massopt'></span>

<h3>Description</h3>

<p>Class &quot;massopt&quot; stores options for fitting and plotting models
models for mass spectrometry data
in particular; this is a subclass of class <code>opt</code> that contains 
options applicable to all model types </p>


<h3>Details</h3>

<p>See <code><a href="#topic+opt-class">opt-class</a></code> and
for 
the specification of fitting/plotting options that are not specific to the 
<code>mass</code> class type.</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("massopt", ...)</code> or
<code>massopt(...)</code>
</p>


<h3>Slots</h3>


<dl>
<dt><code>axis.by</code>:</dt><dd><p>Object of class <code>"numeric"</code> that
allows labels on the bars representing the mass spectra to
to skipped, e.g., <code>axis.by=2</code> will add a label to
every second bar</p>
</dd>
<dt><code>scale.concen</code>:</dt><dd><p>Object of class <code>"logical"</code> that
scales the concentration matrix using the algorithm found
in the function <code>scaleConList</code>.
</p>
</dd>
<dt><code>nummaxtraces</code>:</dt><dd><p>Object of class
<code>"nummaxtraces"</code> that defaults to zero; if greater
than zero then this number of the traces with the maximum
amplitude are plotted</p>
</dd>
</dl>


<h3>Author(s)</h3>

<p>Katharine M. Mullen, Ivo H. M. van Stokkum</p>


<h3>See Also</h3>

<p><code><a href="#topic+examineFit">examineFit</a></code>, <code><a href="#topic+fitModel">fitModel</a></code>, <code><a href="#topic+opt-class">opt-class</a></code>, <code><a href="#topic+specopt-class">specopt-class</a></code>
</p>

<hr>
<h2 id='mea_IRF'>Instrument response for fluorescent lifetime imaging microscopy (FLIM) data</h2><span id='topic+mea_IRF'></span>

<h3>Description</h3>

<p>A measured instrument response over 256 time channels for a
set of fluorescent lifetime imaging microscopy (FLIM) datasets.</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("mea_IRF")
</code></pre>


<h3>Format</h3>

<p><code>mea_IRF</code> represents a measured instrument response as a numeric
vector over 256 time channels.
</p>


<h3>Details</h3>

<p>See <code><a href="#topic+FLIMplots">FLIMplots</a></code> for examples using this data.
</p>


<h3>References</h3>

<p>This data was described in
</p>
<p>Mullen KM, van Stokkum IHM (2008).
The variable projection algorithm in time-resolved spectroscopy,
microscopy and mass-spectroscopy applications,
<em>Numerical Algorithms</em>, <b>in press</b>,
<a href="https://doi.org/10.1007/s11075-008-9235-2">doi:10.1007/s11075-008-9235-2</a>.
</p>

<hr>
<h2 id='modifyModel'>Allows the starting values for parameters associated with a model
to be updated with the values found in fitting the model. </h2><span id='topic+modifyModel'></span>

<h3>Description</h3>

<p>  Allows the starting values for parameters associated with
a model to be updated with the values found in fitting the model.  That
is, a model is specified with <code>initModel</code>.  Then <code>fitModel</code>
is used to optimize the starting values for parameters.  <code>modifyModel</code>
allows modification of the starting values in the model specification
with the optimized values found via <code>fitModel</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>modifyModel(model = list(), newest = list(), exceptslots = vector() )
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="modifyModel_+3A_model">model</code></td>
<td>
<p>an object of class <code>dat</code> returned by <code>initModel</code>;
if this argument is of <code>length(0)</code>, which is the default, then the
last model fit is used (which is found in the global variable
<code>.currModel@model</code>)</p>
</td></tr>
<tr><td><code id="modifyModel_+3A_newest">newest</code></td>
<td>
<p> an object of class <code>theta</code> containing new parameter
estimates;    if this argument is of <code>length(0)</code>, which is the default,
then the parameter estimates associated with dataset 1 in the last model fit
are used (which are found in
the global variable <code>.currTheta[[1]]</code>)</p>
</td></tr>
<tr><td><code id="modifyModel_+3A_exceptslots">exceptslots</code></td>
<td>
<p>a vector of character vector of slot names whose
corresponding slots are to be left out of the update</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class <code>dat</code> that returns the results of
calling <code>initModel</code> with the new starting values.
</p>


<h3>Author(s)</h3>

<p>Katharine M. Mullen, Ivo H. M. van Stokkum</p>


<h3>See Also</h3>

 <p><code><a href="#topic+initModel">initModel</a></code>, <code><a href="#topic+fitModel">fitModel</a></code></p>

<hr>
<h2 id='multimodel-class'>Class &quot;multimodel&quot; for storage of multidataset models, data and the 
results of fitting. </h2><span id='topic+multimodel-class'></span><span id='topic+multimodel'></span>

<h3>Description</h3>

 
<p><code>multimodel</code> is the class to store data, a generally applicable model, a
list of per-data models, a specification of per-dataset model differences, and 
results for the analysis of possibly many datasets.  After a call to 
<code>fitModel</code>
an object is initialized of the <code>multimodel</code> class. </p>


<h3>Details</h3>

<p>after a call to <code><a href="#topic+fitModel">fitModel</a></code>, an object of class 
<code>multimodel</code> exists in the global environment as the variable 
<code>currModel</code> </p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("multimodel", ...)</code> or 
<code>multimodel(...)</code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>data</code>:</dt><dd><p>Object of class <code>"list"</code>  of objects of class <code>dat</code> containing data</p>
</dd>
<dt><code>modellist</code>:</dt><dd><p>Object of class <code>"list"</code>  of length n where n is the number of datasets given in
<code>data</code>, and each element i is an object of class <code>dat</code> giving 
the dataset-specific model applicable to <code>data[[i]]</code></p>
</dd>
<dt><code>modeldiffs</code>:</dt><dd><p>Object of class <code>"list"</code>  of per-dataset model differences input as an argument 
to the <code><a href="#topic+fitModel">fitModel</a></code> function</p>
</dd>
<dt><code>fit</code>:</dt><dd><p>Object of class <code>"fit"</code>  containing a list of
results per-dataset as well as the output of optimization returned by the
<code>nls</code> function.</p>
</dd>
<dt><code>groups</code>:</dt><dd><p>Object of class <code>"list"</code>  containing a list of
lists of the groups of clp to link across datasets. Each component list 
contains vectors of form (clp condition index, dataset index), and 
such vectors in the same component list are linked between datasets. See
<code>fitModel</code> for more details on the linking possibilities.  
</p>
</dd>
<dt><code>stderrclp</code>:</dt><dd><p>Object of class <code>"logical"</code>  
describing whether standard error estimates on conditionally linear 
parameters should be calculated; this is determined by the <code>opt</code> 
argument of <code>fitModel</code> and defaults to <code>FALSE</code>
</p>
</dd>
<dt>algorithm</dt><dd></dd>
<dt>datasetind</dt><dd></dd>
<dt>finished</dt><dd></dd>
<dt>getXsuper</dt><dd></dd>
<dt>modelspec</dt><dd></dd>
<dt>nclp</dt><dd></dd>
<dt>nnls</dt><dd></dd>
<dt>nnlscrit</dt><dd></dd>
<dt>optlist</dt><dd></dd>
<dt>parorder</dt><dd></dd>
<dt>parorderchange</dt><dd></dd>
<dt>parorderdiff</dt><dd></dd>
<dt>trilinear</dt><dd></dd>
</dl>



<h3>Author(s)</h3>

<p>Katharine M. Mullen, Ivo H. M. van Stokkum</p>


<h3>See Also</h3>

 <p><code><a href="#topic+fitModel">fitModel</a> </code></p>

<hr>
<h2 id='multitheta-class'>Class &quot;multitheta&quot; that stores a list with one element of class 
&quot;theta&quot; for each dataset modeled. </h2><span id='topic+multitheta-class'></span><span id='topic+multitheta'></span>

<h3>Description</h3>

	 
<p>Class <code>multitheta</code> stores a list with one element of class 
<code>theta</code> for each dataset modeled, corresponding to the parameter 
estimates associated with that dataset. 
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("multitheta", ...)</code> or
<code>multitheta(...)</code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>th</code>:</dt><dd><p>Object of class <code>"list"</code>  with element i
corresponding to the <code>theta</code> object for the ith dataset modeled. 
</p>
</dd>
</dl>
 

<h3>Author(s)</h3>

<p>Katharine M. Mullen, Ivo H. M. van Stokkum</p>


<h3>See Also</h3>

<p><code><a href="#topic+theta-class">theta-class</a></code>, <code><a href="#topic+dat-class">dat-class</a></code> 
</p>

<hr>
<h2 id='opt-class'>Class &quot;opt&quot; stores options for fitting and plotting</h2><span id='topic+opt-class'></span><span id='topic+opt'></span>

<h3>Description</h3>

<p>Class &quot;opt&quot; stores options for fitting and plotting applicable to
all model types</p>


<h3>Details</h3>

<p>See <code><a href="#topic+kinopt-class">kinopt-class</a></code>, <code><a href="#topic+specopt-class">specopt-class</a></code> and
<code><a href="#topic+massopt-class">massopt-class</a></code> for
the specification of fitting/plotting options that are specific to the
class type. </p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("opt", ...)</code> or
<code>opt(...)</code>.
</p>


<h3>Slots</h3>


<dl>
<dt>getStartTri</dt><dd></dd>
<dt>imagepal</dt><dd></dd>
<dt>maxfev</dt><dd></dd></dl>

<dl>
<dt>minFactor</dt><dd></dd>
<dt>nnlscrit</dt><dd></dd>
<dt>noplotest</dt><dd></dd>
<dt>notraces</dt><dd></dd>
<dt>optimmethod</dt><dd></dd>
<dt>parscale</dt><dd></dd>
<dt>residtraces</dt><dd></dd>
<dt>selectedtraces</dt><dd></dd>
<dt>sumnls</dt><dd></dd>
<dt>trilinear</dt><dd></dd>
<dt>triStart</dt><dd></dd>
<dt>writedata</dt><dd></dd>
<dt>writefitivo</dt><dd></dd>
<dt>xlim</dt><dd></dd>
<dt><code>algorithm</code>:</dt><dd><p>Object of class <code>"character"</code>  that defaults to
<code>algorithm="nls"</code>, so that the function <code>nls</code> is used to
optimize nonlinear parameters under least squares criteria.
Other options are
</p>

<dl>
<dt><code>nls.lm</code>:</dt><dd><p>optimize nonlinear parameters under least
squares criteria using <code>nls.lm</code> </p>
</dd>
<dt><code>optim</code>:</dt><dd><p>optimize nonlinear parameters under poisson
regression criteria with the Nelder-Mead algorithm in
<code>optim</code>; if this option is used then it MUST be used in
conjunction with <code>nnls=TRUE</code>. Currently, it must also be
used with <code>stderrclp=FALSE</code>. </p>
</dd>
</dl>
</dd>
<dt><code>nnls</code>:</dt><dd><p>Object of class <code>"logical"</code>  that defaults to
<code>FALSE</code>.  If <code>nnls=TRUE</code>,
constrain the conditionally linear parameters
to nonnegativity via a nonnegative least squares algorithm as
implemented via the function <code>nnls</code> from the package by the same
name.</p>
</dd>
<dt><code>writecon</code>:</dt><dd><p>Object of class <code>"logical"</code>  that defaults to
<code>FALSE</code>; if true then
concentrations are written to a txt file; row labels are <code>x</code></p>
</dd>
<dt><code>writespec</code>:</dt><dd><p>Object of class <code>"logical"</code> that defaults to
<code>FALSE</code>; if <code>TRUE</code> then
spectra are written to a txt file; row labels are <code>x2</code></p>
</dd>
<dt><code>writenormspec</code>:</dt><dd><p>Object of class <code>"logical"</code> that
defaults to <code>FALSE</code>; if <code>TRUE</code> then normalized spectra are
written to a txt file; row labels are <code>x2</code></p>
</dd>
<dt><code>writefit</code>:</dt><dd><p>Object of class
<code>"logical"</code> that defaults to <code>FALSE</code>; if <code>TRUE</code> then fit
is written to a txt file; row and column labels are <code>x</code> and
<code>x2</code></p>
</dd>
<dt><code>writeclperr</code>:</dt><dd><p>Object of class <code>"logical"</code>
that defaults to
FALSE; if true then
the error bars for clp are written to a txt file.  This option is only
sensible with <code>stderrclp=TRUE</code>.</p>
</dd>
<dt><code>output</code>:</dt><dd><p>Object of class
<code>"character"</code> that defaults to <code>"ps"</code>, which means that
plots written to file are postscript.  Alternatively, specify
<code>output = "pdf"</code>, and plots are written as pdf files</p>
</dd>
<dt><code>addfilename</code>:</dt><dd><p>Object of class
<code>"logical"</code> that, for each data file, tries to add the
filename to plots associated with output for that data. </p>
</dd>
<dt><code>residplot</code>:</dt><dd><p>Object of class <code>"logical"</code> defaults to
<code>FALSE</code>; if <code>TRUE</code> generate a plot of residuals in a
separate window.</p>
</dd>
<dt><code>adddataimage</code>:</dt><dd><p>Object of class <code>"logical"</code> defaults to
<code>FALSE</code>; if <code>TRUE</code> adding imageplot of data in summary plot.</p>
</dd>
<dt><code>plot</code>:</dt><dd><p>Object of class <code>"logical"</code> that defaults to
<code>TRUE</code>; if <code>FALSE</code> then do not write output in the form of
plots and other windows to the screen. </p>
</dd>
<dt><code>divdrel</code>:</dt><dd><p>Object of class <code>"logical"</code> that defaults to
<code>FALSE</code>; if <code>TRUE</code>, plot traces and concentration
profiles divided by the dataset scaling parameters where they apply; this
allows for the fit of datasets having different intensities on the same
scale.</p>
</dd>
<dt><code>plotkinspec</code>:</dt><dd><p>Object of class <code>"logical"</code> that defaults
to <code>FALSE</code>; if <code>TRUE</code>, generates a separate plot of the spectra
associated with the components that are not a part of a coherent
artifact/scatter model. </p>
</dd>
<dt><code>superimpose</code>:</dt><dd><p>Object of class <code>"vector"</code> containing
dataset indices whose results should be superimposed in plots</p>
</dd>
<dt><code>xlab</code>:</dt><dd><p>Object of class <code>"character"</code> containing
label for x-axis, e.g., <code>"nanoseconds"</code>
or <code>"picoseconds"</code></p>
</dd>
<dt><code>ylab</code>:</dt><dd><p>Object of class <code>"character"</code> containing label
for y-axis, e.g., <code>"wavelength"</code></p>
</dd>
<dt><code>title</code>:</dt><dd><p>Object of class <code>"character"</code> containing title
to write at the top of plots.</p>
</dd>
<dt><code>makeps</code>:</dt><dd><p>Object of class <code>"character"</code> containing
prefix to plot files written to postscript;
if present postscript will be written. Note that this string is also
used as the preffix of txt output files </p>
</dd>
<dt><code>linrange</code>:</dt><dd><p>Object of class <code>"numeric"</code> giving linear
range of time axis for plotting; time will be plotted linearly from
-linrange to linrange and plotted on a logarithmic (base 10) axis elsewhere</p>
</dd>
<dt><code>summaryplotrow</code>:</dt><dd><p>Object of class <code>"numeric"</code> giving
number of rows in summary plot; defaults to <code>4</code></p>
</dd>
<dt><code>summaryplotcol</code>:</dt><dd><p>Object of class <code>"numeric"</code> giving
number of columns in summary plot; defaults to <code>4</code></p>
</dd>
<dt><code>iter</code>:</dt><dd><p>Object of class <code>"numeric"</code> giving
number of iterations to optimize model parameters; if
<code>nls=FALSE</code> so that the Levenberg-Marquardt algorithm is
applied, then <code>iter</code> is interpreted as the
maximum number of residual function evaluations (see the help
page of the function <code>nls.lm</code> for details)</p>
</dd>
<dt><code>paropt</code>:</dt><dd><p>Object of class <code>"list"</code>
of graphical parameters in format <code>par(...)</code>
to apply to plots. </p>
</dd>
<dt><code>stderrclp</code>:</dt><dd><p>Object of class <code>"logical"</code> that defaults
to <code>FALSE</code>; if <code>TRUE</code>, estimates of the standard error of
conditionally linear parameters are made</p>
</dd>
<dt><code>addest</code>:</dt><dd><p>Object of class <code>"vector"</code> containing
character strings of which parameter estimates should be added to the
summary plot, e.g., <code>addest = c("kinpar", "irfpar")</code></p>
</dd>
<dt>kinspecerr</dt><dd><p>Object of class <code>"logical"</code> that defaults to
<code>FALSE</code>; if <code>TRUE</code>, add standard error estimates to the clp
a plot generated with <code>kinspecest=TRUE</code> or
<code>plotkinspec=TRUE</code>.  This option can only be
used if the estimates were generated during fitting via the option
<code>stderrclp=TRUE</code></p>
</dd>
<dt>xlimspec</dt><dd><p>Object of class <code>"vector"</code> that defaults to
<code>vector()</code>; if changed, it should specify the desired x-limits of
the plot of clp</p>
</dd>
<dt>ylimspec</dt><dd><p>Object of class <code>"vector"</code> that defaults to
<code>vector()</code>; if changed, it should specify the desired y-limits of
the plot of clp. In the case of plotting the results of FLIM image
analysis, <code>ylimspec</code> can be used to determine the range used in the
image plot of lifetimes.  </p>
</dd>
<dt>ylimspecplus</dt><dd><p>Object of class <code>"vector"</code> that defaults to
<code>vector()</code>; if changed, the first value should specify a vector to
add to the y-limits of the plot of clp</p>
</dd>
<dt>samespecline</dt><dd><p>Object of class <code>"logical"</code> that defaults to
<code>FALSE</code>; if <code>TRUE</code>, then the line-type for clp is the same
for all datasets
</p>
</dd>
<dt>specinterpol</dt><dd><p>Object of class <code>"logical"</code> that defaults to
<code>FALSE</code>; if <code>TRUE</code>, use spline instead of lines between
the points representing estimated clp</p>
</dd>
<dt>specinterpolpoints</dt><dd><p>Object of class <code>"logical"</code> that defaults to
<code>TRUE</code>; if <code>TRUE</code>, add points representing the actual estimates
for clp to plots of the curves representing smoothed clp</p>
</dd>
<dt>specinterpolseg</dt><dd><p>Object of class <code>"numeric"</code> that defaults to
<code>50</code>; represents the number of segments used in a spline-based
representation of clp</p>
</dd>
<dt>specinterpolbspline</dt><dd><p>Object of class <code>"logical"</code> that defaults
to <code>FALSE</code>; determines whether a B-spline based representation of
clp is used (when <code>specinterpol=TRUE</code>) or a piecewise polynomial
representation</p>
</dd>
<dt>normspec</dt><dd><p>Object of class <code>"logical"</code> that determines whether
clp are normalized in plots</p>
</dd>
<dt>writespecinterpol</dt><dd><p>Object of class <code>"logical"</code> that defaults to
<code>FALSE</code>; if <code>TRUE</code>, a spline-based representation of clp
is written to ASCII files</p>
</dd>
<dt>nlsalgorithm</dt><dd><p>Object of class <code>"character"</code> that defaults to
<code>"default"</code> and determines the algorithm used by <code>nls</code>, if
<code>nls</code> is used in optimization.  See <code>help(nls)</code> for other
possibilities, such as <code>"port"</code>, which is more stable with
respect to starting values but requires more time.  </p>
</dd>
<dt>ltyfit</dt><dd><p>Object of class <code>"numeric"</code> if given, sets the line
type of the fit in plots of the fit/data; see <code>lty</code> in
<code>help(par)</code> for options. </p>
</dd>
<dt>ltydata</dt><dd><p>Object of class <code>"numeric"</code> if given, sets the line
type of the data in plots of the fit/data; see <code>lty</code> in
<code>help(par)</code> for options. </p>
</dd>
<dt>colfit</dt><dd><p>Object of class <code>"vector"</code> if given, sets the color
of the fit corresponding to each dataset
in plots of the fit/data; see <code>col</code> in
<code>help(par)</code> for options.  If given
<code>length(colfit)</code> must be equal to
the number of datasets in the analysis</p>
</dd>
<dt>coldata</dt><dd><p>Object of class <code>"vector"</code> if given, sets the color
of the data for each dataset
in plots of the fit/data; see <code>col</code> in
<code>help(par)</code> for options. If given,
<code>length(coldata)</code> must be equal to
the number of datasets in the analysis</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Katharine M. Mullen, Ivo H. M. van Stokkum</p>


<h3>See Also</h3>

<p><code><a href="#topic+kinopt-class">kinopt-class</a></code>, <code><a href="#topic+specopt-class">specopt-class</a></code>
</p>

<hr>
<h2 id='outlierCorr'>Finds and removes outliers from a datasets</h2><span id='topic+outlierCorr'></span>

<h3>Description</h3>

<p>Finds and removes outliers from datasets
given the
results of fitting as returned by <code>fitModel</code>.  Uses the
residuals in the fitted results to return a list of corrected
datasets to be used in place of the datasets used in the call
to <code>fitModel</code> as well as a list of weights.  The data returned
contains the fitted values at pointed that are outliers and will be
assigned zero weight in subsequent fits.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>outlierCorr(oldRes, fence=3, saturCorr=FALSE, saturThresh=.05,
                          saturMin=NA, saturDivMax=3, outlierCorr=TRUE,
                          newM = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="outlierCorr_+3A_oldres">oldRes</code></td>
<td>
<p>Object returned by <code>fitModel</code> function </p>
</td></tr>
<tr><td><code id="outlierCorr_+3A_fence">fence</code></td>
<td>
<p>Object of class <code>"numeric"</code> determining what
points to consider outliers.  </p>
</td></tr>
<tr><td><code id="outlierCorr_+3A_saturcorr">saturCorr</code></td>
<td>
<p>whether to correct for saturation</p>
</td></tr>
<tr><td><code id="outlierCorr_+3A_saturthresh">saturThresh</code></td>
<td>
<p>See code.</p>
</td></tr>
<tr><td><code id="outlierCorr_+3A_saturmin">saturMin</code></td>
<td>
<p>See code.</p>
</td></tr>
<tr><td><code id="outlierCorr_+3A_saturdivmax">saturDivMax</code></td>
<td>
<p>See code.</p>
</td></tr>
<tr><td><code id="outlierCorr_+3A_outliercorr">outlierCorr</code></td>
<td>
<p>whether to perform outlier correction</p>
</td></tr>
<tr><td><code id="outlierCorr_+3A_newm">newM</code></td>
<td>
<p>whether to add to the outliers and saturation points
detected previously</p>
</td></tr>
</table>


<h3>Details</h3>

<p>We calculate the fourth spread at a given value of
<code>x2</code> in a dataset.  Those points that are less than the
first quartile minus the fourth spread times <code>fence</code> are outliers,
as are those points that are more than the third quartile plus the
fourth spread times <code>fence</code>.  Outliers are assigned a weight of
zero and are assigned the values found in fitting for the purpose of
generating smooth-looking plots. </p>


<h3>Value</h3>

<p>list containing the elements <code>dt</code>, a list of
corrected datasets, and <code>weightList</code>, a list of new weight
matrices.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+fitModel">fitModel</a></code>, <code><a href="#topic+preProcess">preProcess</a></code></p>

<hr>
<h2 id='plotter-methods'>Generic function plotter in Package &lsquo;TIMP&rsquo;</h2><span id='topic+plotter-methods'></span><span id='topic+plotter'></span><span id='topic+plotter+2Ckin-method'></span><span id='topic+plotter+2Cspec-method'></span><span id='topic+plotter+2Cmass-method'></span>

<h3>Description</h3>

<p>Methods for function <code>plotter</code> in Package &lsquo;TIMP&rsquo; that 
call plotting and output functions. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotter(model, multimodel, multitheta, plotoptions)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plotter-methods_+3A_model">model</code></td>
<td>
<p>Object of class <code>dat</code>; function switches on this 
argument. </p>
</td></tr>
<tr><td><code id="plotter-methods_+3A_multimodel">multimodel</code></td>
<td>
<p>Object of class <code>multimodel</code></p>
</td></tr>
<tr><td><code id="plotter-methods_+3A_multitheta">multitheta</code></td>
<td>
<p>Object of class <code>multitheta</code></p>
</td></tr>
<tr><td><code id="plotter-methods_+3A_plotoptions">plotoptions</code></td>
<td>
<p>list of output options 
input to <code>fitModel</code> as the argument <code>opt</code></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Katharine M. Mullen, Ivo H. M. van Stokkum</p>


<h3>See Also</h3>

<p><code><a href="#topic+dat-class">dat-class</a></code></p>

<hr>
<h2 id='preProcess'>Performs preprocessing on data stored as an objects of class dat.</h2><span id='topic+preProcess'></span>

<h3>Description</h3>

<p>Performs data sampling, selection, baseline correction,
scaling, and data correction on an object of class <code>dat</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>preProcess(data, sample = 1, sample_time = 1, sample_lambda = 1,
    sel_time = vector(), sel_lambda = vector(), baselinetime = vector(),
    baselinelambda = vector(), scalx = NULL, scalx2 = NULL,
    sel_lambda_ab = vector(), sel_time_ab = vector(), rm_x2=vector(),
    rm_x = vector(), svdResid = list(), numV = 0, sel_special = list(),
    doubleDiff = FALSE, doubleDiffFile = "doubleDiff.txt")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="preProcess_+3A_data">data</code></td>
<td>
<p>Object of class <code>dat</code></p>
</td></tr>
<tr><td><code id="preProcess_+3A_sample">sample</code></td>
<td>
<p>integer describing sampling interval to take in both time and
<code>x2</code>; e.g., <code>sample=2</code>
will sample every 2nd time and every 2nd point in
<code>x2</code>.</p>
</td></tr>
<tr><td><code id="preProcess_+3A_sample_time">sample_time</code></td>
<td>
<p>integer describing sampling interval in time; e.g.,
<code>sample_time=2</code> will sample every 2nd element of the time vector. </p>
</td></tr>
<tr><td><code id="preProcess_+3A_sample_lambda">sample_lambda</code></td>
<td>
<p> integer describing sampling interval in <code>x2</code>;
e.g., <code>sample_lambda=2</code> will sample every 2nd element in the
<code>x2</code> vector. </p>
</td></tr>
<tr><td><code id="preProcess_+3A_sel_time">sel_time</code></td>
<td>
<p>vector of length 2 describing the first and last time
index of data to select; e.g., <code>sel_time=c(5,120)</code> will select
data at times indexed 5-120. </p>
</td></tr>
<tr><td><code id="preProcess_+3A_sel_lambda">sel_lambda</code></td>
<td>
<p>vector of length 2 describing the first and last <code>x2</code>
index of data to select; e.g., <code>sel_lambda=c(5,120)</code>
will select data at <code>x2</code>
indexed 5-120. </p>
</td></tr>
<tr><td><code id="preProcess_+3A_baselinetime">baselinetime</code></td>
<td>
<p>a vector of form <code>c(timeIndexmin, timeIndexmax,
  lambdaIndexmin, lambdaIndexmax)</code>.  The average of data between
<code>x2</code> indexes
<code>lambdaIndexmin</code> and <code>lambdaIndexmax</code>
is subtracted from data with
time index between <code>timeIndexmin</code> and <code>timeIndexmax</code>.  </p>
</td></tr>
<tr><td><code id="preProcess_+3A_baselinelambda">baselinelambda</code></td>
<td>
<p>  a vector of form <code>c(timeIndexmin, timeIndexmax,
  lambdaIndexmin, lambdaIndexmax)</code>.  The average of data between time indexes
<code>timeIndexmin</code> and <code>timeIndexmax</code>
is subtracted from data with <code>x2</code> index
between <code>lambdaIndexmin</code> and <code>lambdaIndexmax</code>.</p>
</td></tr>
<tr><td><code id="preProcess_+3A_scalx">scalx</code></td>
<td>
<p>numeric by which to linearly scale the <code>x</code> axis
(which often represents time), so that newx = oldx * scalx </p>
</td></tr>
<tr><td><code id="preProcess_+3A_scalx2">scalx2</code></td>
<td>
<p> vector of length 2 by which to linearly scale the
<code>x2</code> axis, so that newx2 = oldx2 * scalx2[1] + scalx2[2]</p>
</td></tr>
<tr><td><code id="preProcess_+3A_sel_lambda_ab">sel_lambda_ab</code></td>
<td>
<p>vector of length 2 describing the absolute values
(e.g., wavelengths, wavenumbers, etc.) between which data should be
selected.   e.g., <code>sel_lambda_ab = c(400, 600)</code> will select data
associated with <code>x2</code> values between 400 and 600. </p>
</td></tr>
<tr><td><code id="preProcess_+3A_sel_time_ab">sel_time_ab</code></td>
<td>
<p> vector of length 2 describing the absolute times
between which data should be
selected.   e.g., <code>sel_time_ab = c(50, 5000)</code> will select data
associated with time values between 50 and 5000 picoseconds.</p>
</td></tr>
<tr><td><code id="preProcess_+3A_rm_x2">rm_x2</code></td>
<td>
<p>vector of <code>x2</code> indices to remove from the data</p>
</td></tr>
<tr><td><code id="preProcess_+3A_rm_x">rm_x</code></td>
<td>
<p>vector of <code>x</code> indices to remove from the data</p>
</td></tr>
<tr><td><code id="preProcess_+3A_svdresid">svdResid</code></td>
<td>
<p>list returned from the <code>getResid</code> function, containing
residuals to be used in data correction. </p>
</td></tr>
<tr><td><code id="preProcess_+3A_numv">numV</code></td>
<td>
<p>numeric specifying how many singular vectors to use in data
correction.  Maximum is five. </p>
</td></tr>
<tr><td><code id="preProcess_+3A_sel_special">sel_special</code></td>
<td>
<p>list of lists specifying <code>x</code> indices to remove
from individual wavelength ranges, e.g.,
<code>sel_special = list(c(400,600,10,12),c(600,800,11,13))</code>
indicates that between wavelength 400 and 600, time indices between 10
and 12 should be removed from the data, and between wavelengths 600 and
800, time indices between 11 and 13 should be removed from the data.
Note that the number of time indices to remove should be the same in
each wavelength interval specified.  Also note that the time vector
associated with the data after the first set of indices is removed will
be associated with the resulting dataset. </p>
</td></tr>
<tr><td><code id="preProcess_+3A_doublediff">doubleDiff</code></td>
<td>
<p>logical indicating whether the data should be
converted to represent differences between times. </p>
</td></tr>
<tr><td><code id="preProcess_+3A_doubledifffile">doubleDiffFile</code></td>
<td>
<p>character string indicating the file name of
time difference data to create in the case that <code>doubleDiff=TRUE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>object of class <code>dat</code>.
</p>


<h3>Author(s)</h3>

<p>Katharine M. Mullen, Ivo H. M. van Stokkum</p>


<h3>See Also</h3>

 <p><code><a href="#topic+readData">readData</a></code>, <code><a href="#topic+getResid">getResid</a> </code></p>


<h3>Examples</h3>

<pre><code class='language-R'>##############################
## READ DATA
##############################

data("target")

##############################
## PREPROCESS DATA
##############################

# select certain wavelengths for modeling

C1_1 &lt;- preProcess(data = C1, baselinelambda = c(1,12,1,32) )
C1_1 &lt;- preProcess(data = C1_1, sel_lambda = c(8, 27))
C1_1 &lt;- preProcess(data = C1_1, rm_x = c(40, 41, 101, 116))
C1_1 &lt;- preProcess(data = C1_1, sel_time_ab = c(-10, 100000))

C2_1 &lt;- preProcess(data = C2, sel_lambda = c(2, 32))
C2_1 &lt;- preProcess(data = C2_1, baselinelambda = c(1,12,1,32) )
C2_1 &lt;- preProcess(data = C2_1, sel_time_ab = c(-10, 100000))

C3_1 &lt;- preProcess(data = C3, sel_lambda = c(1, 25))
C3_1 &lt;- preProcess(data = C3_1, baselinelambda = c(1,12,1,32) )



##############################
## SPECIFY K Matrix and J vector
##############################


## initialize 2 7x7 arrays to 0

delK &lt;- array(0, dim=c(7,7,2))

## the matrix is indexed:
## delK[ ROW K MATRIX, COL K MATRIX, matrix number]

## in the first matrix, put the index of compartments
## that are non-zero
## the transfer rate of the compartment is governed by
## kinpar[index]

delK[1,1,1] &lt;- 4
delK[5,1,1] &lt;- 1
delK[2,2,1] &lt;- 4
delK[5,2,1] &lt;- 2
delK[3,3,1] &lt;- 4
delK[5,3,1] &lt;- 3
delK[4,4,1] &lt;- 4
delK[6,5,1] &lt;- 5
delK[7,6,1] &lt;- 6
delK[7,7,1] &lt;- 7

## print out the resulting array to make sure it's right

delK

jvector &lt;- c(.48443195136500550341, .28740782363398824522,
.13749071230100625137, 0.9066953510E-01, 0, 0, 0)

datalist &lt;- list(C1, C2, C3)
## for plotting selected traces, get a vector of all the wavenumbers
allx2 &lt;- vector()
for(i in 1:length(datalist))
	allx2 &lt;- append(allx2,datalist[[i]]@x2)
allx2 &lt;- sort(unique(allx2))

##############################
## SPECIFY INITIAL MODEL
## note that low is the larger wavenumber in the clpequ spec!
##############################

model1 &lt;- initModel(mod_type = "kin",
kinpar=c( 0.13698630, 0.3448275849E-01, 0.1020408142E-01, 0.2941176528E-02,
0.17000,  0.015,  0.1074082902E-03),
fixed = list(prel = 1:6, clpequ=1:3, kinpar=1:7, irfpar=1, parmu=1),
irfpar=c(0.4211619198, 0.6299000233E-01),
prelspec = list(
list(what1="kinpar", ind1=1, what2 = "kinpar", ind2=4,
start=c(-1,0.1369863003)),
list(what1="kinpar", ind1=2, what2 = "kinpar", ind2=4,
start=c(-1,0.3448275849E-01)),
list(what1="kinpar", ind1=3, what2 = "kinpar", ind2=4,
start=c(-1,0.1020408142E-01))
),
parmu = list(c(-0.1411073953)),
lambdac = 1290,
kmat = delK,
jvec = jvector,
positivepar="kinpar",
weightpar=list( c(-20,1.4,1,2000,.2)),
clpequspec =list(
list(to=2, from=1, low=100, high=10000),
list(to=3, from=1, low=100, high=10000),
list(to=4, from=1, low=100, high=10000)),
clpequ = c(1,1,1),
cohspec = list( type = "irf"))

##############################
## GET RESID
## same format as call to fitModel, but does not plot
##############################

serResid &lt;- getResid(list(C1_1, C2_1, C3_1), list(model1),
modeldiffs = list(thresh =  0.00005,
dscal = list(list(to=2,from=1,value=4),
list(to=3,from=1,value=0.8000000119)),
free = list(
list(what="irfpar", ind=1, start= c(0.1231127158), dataset=2),
list(what="parmu", ind=c(1,1), start= c(0.1219962388), dataset=2),
list(what="irfpar", ind=1, start= c(0.3724052608), dataset=3),
list(what="parmu", ind=c(1,1), start= c(0.8844097704E-01), dataset=3)),
change  = list(
list(what="fixed", spec=list(clpequ=1:3, kinpar=1:7, irfpar=1:2,
parmu=1, drel = 1, prel=1:6), dataset=2:3))),
opt=kinopt(iter=0, title="Cosimo Spectra, Not Normalized, with Error",
stderrclp=TRUE, kinspecerr=TRUE, writespec = TRUE,
plotkinspec = TRUE,plotcohcolspec=FALSE,
selectedtraces = seq(1, length(allx2), by=2),
specinterpol = TRUE, specinterpolpoints=FALSE,
divdrel=TRUE, xlab="wavenumber",writeclperr = TRUE,
makeps = "err", linrange = 1, superimpose=1:3))

##############################
## MAKE CORRECTED DATASETS USING RESID INFO
##############################

C1_3 &lt;- preProcess(data = C1_1, svdResid = serResid[[1]], numV = 2)
C2_3 &lt;- preProcess(data = C2_1, svdResid = serResid[[2]], numV = 2)
C3_3 &lt;- preProcess(data = C3_1, svdResid = serResid[[3]], numV = 2)

##############################
## FIT MODEL
##############################

serRes&lt;-fitModel(list(C1_3, C2_3, C3_3), list(model1),
modeldiffs = list(thresh =  0.00005,
dscal = list(list(to=2,from=1,value=4),
list(to=3,from=1,value=0.8000000119)),
free = list(
list(what="irfpar", ind=1, start= c(0.1231127158), dataset=2),
list(what="parmu", ind=c(1,1), start= c(0.1219962388), dataset=2),
list(what="irfpar", ind=1, start= c(0.3724052608), dataset=3),
list(what="parmu", ind=c(1,1), start= c(0.8844097704E-01), dataset=3)),
change  = list(
list(what="fixed", spec=list(clpequ=1:3, kinpar=1:7, irfpar=1:2,
parmu=1, drel = 1, prel=1:6), dataset=2:3))),
opt=kinopt(iter=0, title="Cosimo Spectra, Not Normalized, with Error",
stderrclp=TRUE, kinspecerr=TRUE, writespec = TRUE,
plotkinspec = TRUE,plotcohcolspec=FALSE, writerawcon = TRUE,
selectedtraces = seq(1, length(allx2), by=2),
specinterpol = TRUE, specinterpolpoints=FALSE,
divdrel=TRUE, xlab="wavenumber",writeclperr = TRUE,
makeps = "h20", linrange = 1, superimpose=1:3))

 # end donttest
##############################
## CLEANUP GENERATED FILES
##############################
# This removes the files that were generated in this example
# (do not run this code if you wish to inspect the output)
file_list_cleanup = c('h20_paramEst.txt', 'h20_rawconcen_dataset_1.txt',
  'h20_rawconcen_dataset_2.txt', 'h20_rawconcen_dataset_3.txt',
  'h20_spec_dataset_1.txt', 'h20_spec_dataset_2.txt',
  'h20_spec_dataset_3.txt', 'h20_std_err_clp_1.txt',
  'h20_std_err_clp_2.txt', 'h20_std_err_clp_3.txt',
  'err_paramEst.txt', 'err_spec_dataset_1.txt', 'err_spec_dataset_2.txt',
  'err_spec_dataset_3.txt', 'err_std_err_clp_1.txt',
  'err_std_err_clp_2.txt', 'err_std_err_clp_3.txt',
  Sys.glob("*paramEst.txt"), Sys.glob("*.ps"), Sys.glob("Rplots*.pdf"))

# Iterate over the files and delete them if they exist
for (f in file_list_cleanup) {
  if (file.exists(f)) {
    unlink(f)
  }
}

</code></pre>

<hr>
<h2 id='readclp0'>This function reads in a specification of constraints to 
zero on the clp. </h2><span id='topic+readclp0'></span>

<h3>Description</h3>

<p>This function is useful for the case that there are 
many constraints to zero in the model, as is the case for some mass
spectrometry models. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>readclp0(filenm)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="readclp0_+3A_filenm">filenm</code></td>
<td>
<p>Object of class <code>"character"</code> that gives 
is the path to the file to read in. </p>
</td></tr> 
</table>


<h3>Details</h3>

<p>The file to be read in should have the following format: 
1st line is not read.  Lines thereafter are 
the space-delimited index of the component to constrain, the 
lower bound of the constraint, and the upper bound of the 
constraint, e.g., <code>1 218.800000000000011 220.099999999999994</code>.
</p>


<h3>Value</h3>

<p>The constraints to zero in the format documented in the help
file for the <code>"dat"</code> class.  Therefore a call to 
<code>"readclp0"</code> may be used inside a call to <code>"initModel"</code>, 
as in <code>clp0 = readclp0("filename")</code>.
</p>


<h3>Author(s)</h3>

<p>Katharine M. Mullen, Ivo H. M. van Stokkum</p>


<h3>See Also</h3>

 <p><code><a href="#topic+initModel">initModel</a></code> </p>

<hr>
<h2 id='readData'>This function reads in data the ivo file format</h2><span id='topic+readData'></span>

<h3>Description</h3>

<p>Data in the formats described at
<a href="https://glotaran.github.io/legacy/file_formats">https://glotaran.github.io/legacy/file_formats</a>
may be read from file into an R object for analysis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>readData(filenm, typ="", sep = "")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="readData_+3A_filenm">filenm</code></td>
<td>
<p> This is the path to the file to read in, as a quoted
string. </p>
</td></tr>
<tr><td><code id="readData_+3A_typ">typ</code></td>
<td>
<p>if <code>typ="plain"</code> the the file being read in stores
data as a plain matrix, with <code>x</code> values as the first element of
each row except the first and <code>x2</code> values as the first row. </p>
</td></tr>
<tr><td><code id="readData_+3A_sep">sep</code></td>
<td>
<p>This is an optional argument describing how the data is
delimited; defaults to <code>""</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class <code>dat</code>
</p>


<h3>Author(s)</h3>

<p>Katharine M. Mullen, Ivo H. M. van Stokkum</p>


<h3>See Also</h3>

 <p><code><a href="#topic+preProcess">preProcess</a></code> </p>

<hr>
<h2 id='res-class'>Class &quot;res&quot; to store the results of model fitting associated with 
a single dataset. </h2><span id='topic+res-class'></span><span id='topic+res'></span>

<h3>Description</h3>

<p>	 Class to store results of model fitting associated with 
a single dataset.  A list containing objects of class <code>res</code> is 
a slot in class <code>fit</code>.  An object of class <code>fit</code> is stored in 
the slot <code>fit</code> of objects of class <code>multimodel</code>.
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("res", ...)</code>.
A <code>res</code> object is created after model fitting
via the residual function <code>residPart</code>.  
</p>


<h3>Slots</h3>


<dl>
<dt><code>cp</code>:</dt><dd><p>Object of class <code>"list"</code> that contains the
estimates for conditionally linear parameters. </p>
</dd>
<dt><code>resid</code>:</dt><dd><p>Object of class <code>"list"</code> of residuals, with one
element for each dataset modeled. </p>
</dd>
<dt><code>fitted</code>:</dt><dd><p>Object of class <code>"list"</code> of fits, with one
element for each dataset modeled. </p>
</dd>
<dt><code>irfvec</code>:</dt><dd><p>Object of class <code>"list"</code> with a vector of
elements for each element of the clp <code>x2</code></p>
</dd>
<dt>cohirf</dt><dd></dd>
<dt>std_err_clp</dt><dd></dd>
</dl>



<h3>Author(s)</h3>

<p>Katharine M. Mullen, Ivo H. M. van Stokkum</p>


<h3>See Also</h3>

<p><code><a href="#topic+fit-class">fit-class</a></code>, <code><a href="#topic+multimodel-class">multimodel-class</a></code>
</p>

<hr>
<h2 id='residPart-methods'>Generic function residPart in Package &lsquo;TIMP&rsquo; </h2><span id='topic+residPart-methods'></span><span id='topic+residPart'></span><span id='topic+residPart+2Ckin-method'></span><span id='topic+residPart+2Cspec-method'></span><span id='topic+residPart+2Cmass-method'></span><span id='topic+residPart+2Camp-method'></span>

<h3>Description</h3>

<p>Methods for function <code>residPart</code> in Package &lsquo;TIMP&rsquo; determine the 
part of the residual vector associated with a single &lsquo;part&rsquo; of the
dataset(s). 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>residPart(model, group, multimodel, thetalist, clpindepX, finished,
returnX, rawtheta)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="residPart-methods_+3A_model">model</code></td>
<td>
<p>Object of class <code>dat</code>; switches on this 
argument. </p>
</td></tr>
<tr><td><code id="residPart-methods_+3A_group">group</code></td>
<td>
<p>list of vector pairs (x2 index, dataset index) for which 
the part of the residual vector is to be determined</p>
</td></tr>
<tr><td><code id="residPart-methods_+3A_multimodel">multimodel</code></td>
<td>
<p>Object of class <code>multimodel</code></p>
</td></tr> 
<tr><td><code id="residPart-methods_+3A_thetalist">thetalist</code></td>
<td>
<p>Object of class <code>multitheta</code></p>
</td></tr> 
<tr><td><code id="residPart-methods_+3A_clpindepx">clpindepX</code></td>
<td>
<p>Object of class <code>matrix</code> containing the matrix
determined directly by the nonlinear parameters (e.g., a concentration matrix
in the case of a kinetic model) in the case that this matrix does not depend
on the <code>x2</code> index</p>
</td></tr> 
<tr><td><code id="residPart-methods_+3A_finished">finished</code></td>
<td>
<p>logical determining whether fitting is finished that
triggers the storage of results</p>
</td></tr> 
<tr><td><code id="residPart-methods_+3A_returnx">returnX</code></td>
<td>
<p>logical determining whether to just return the matrix 
<code>X</code> directly dependent on nonlinear parameters; this is used in the finite
difference derivative of <code>X</code> used to get standard error estimates on the 
conditionally linear parameters. </p>
</td></tr>
<tr><td><code id="residPart-methods_+3A_rawtheta">rawtheta</code></td>
<td>
<p>numeric vector of nonlinear parameters to be optimized 
by <code>nls</code>; this is used in the finite
difference derivative of <code>X</code> used to get standard error estimates on the 
conditionally linear parameters.
</p>
</td></tr> 
</table>


<h3>See Also</h3>

 <p><code><a href="#topic+dat-class">dat-class</a></code>, <code><a href="#topic+spec-class">spec-class</a></code>,
<code><a href="#topic+kin-class">kin-class</a></code> </p>

<hr>
<h2 id='spec-class'>Class &quot;spec&quot; for the storage of spectral models. </h2><span id='topic+spec-class'></span><span id='topic+spec'></span>

<h3>Description</h3>

<p><code>spec</code> is the class for spectral models;
an object
of class &quot;mass&quot; is initialized if
<code>mod_type = "spec"</code> is an
argument of <code>initModel</code>.
All objects of class
<code>spec</code> are
also of class <code>dat</code>; see documentation for <code>dat</code>
for a description of
these slots.  Note that here <code>x2</code>
will refer to the independent variable in
which traces are resolved, e.g., wavelength or wavenumber.
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("spec", ...)</code> or
<code>spec(...)</code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>clpequ</code>:</dt><dd><p> Object of class <code>"vector"</code>  of starting values for linear relationships between
clp</p>
</dd>
<dt><code>specpar</code>:</dt><dd><p> Object of class <code>"list"</code>  of vectors of
starting values for spectral parameters; the number of vectors gives the
number of components in the resulting spectral model;
each vector contains the parameters
associated with a component.  e.g.,
<code>specpar = list(c(20000, 3000, .3, 21000, 2000, .4), c(18000, 1000, .2))</code>;
the parameters in each vector are grouped
<code>c(location_spectra, width_spectra, skew_spectra)</code>.
the location and width parameters are given in wavenumbers.
</p>
</dd>
<dt><code>specfun</code>:</dt><dd><p> Object of class <code>"character"</code>,  <code>"gaus"</code> for a spectral model of a
superposition of skewed Gaussians; <code>"bspline"</code> for a
bspline-based model.  </p>
</dd>
<dt><code>specref</code>:</dt><dd><p> Object of class <code>"numeric"</code>  index defining the center value of the
<code>x2</code> variable.</p>
</dd>
<dt><code>specCon</code>:</dt><dd><p> Object of class <code>"list"</code>  used internally to
store constraints. </p>
</dd>
<dt><code>specdisp</code>:</dt><dd><p>Object of class <code>"logical"</code>  <code>TRUE</code> if time-dependence of the spectral parameters
is to be taken into account and <code>FALSE</code> otherwise</p>
</dd>
<dt><code>specdisppar</code>:</dt><dd><p> Object of class <code>"list"</code>  </p>
</dd>
<dt><code>specdispindex</code>:</dt><dd><p> Object of class <code>"list"</code>  of vectors defining those indexes of specpar whose
time-dependence is to be modeled.  e.g., <code>specdispindex = list(c(1,1),
c(1,2), c(1,3))</code> says that parameters 1-3 of spectra 1 are to be modeled as
time-dependent.</p>
</dd>
<dt><code>nupow</code>:</dt><dd><p> Object of class <code>"numeric"</code>   describing the power to which wavenumbers are raised in
the model equation; see Equation 30 of the paper in the references section
for a complete description</p>
</dd>
<dt><code>timedep</code>:</dt><dd><p>Object of class <code>"logical"</code> describing whether the model for spectra E is dependent
on x-index (i.e., whether it is clp-dependent). </p>
</dd>
<dt><code>parmufunc</code>:</dt><dd><p> Object of class <code>"character"</code>  describing the function form of the
time-dependence of spectral parameters; options are <code>"exp"</code>
for exponential time
dependence, <code>"multiexp"</code> for multiexponential time dependence, and
<code>"poly"</code> for
polynomial time dependence. defaults to polynomial time dependence. </p>
</dd>
<dt> ncole </dt><dd><p>vector describing the number of columns of the E matrix for
each value in the <code>x</code> vector</p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code><a href="#topic+dat-class">dat-class</a></code>, directly.
</p>


<h3>Author(s)</h3>

<p>Katharine M. Mullen, Ivo H. M. van Stokkum</p>


<h3>References</h3>

<p>Ivo H. M. van Stokkum,
&quot;Global and target analysis of time-resolved spectra, Lecture notes
for the Troisieme Cycle de la Physique en Suisse Romande&quot;,
Department of Physics and Astronomy, Faculty of Sciences, Vrije Universiteit,
Amsterdam, The Netherlands, 2005,
<a href="https://www.nat.vu.nl/~ivo/pub/2005/lecturenotes3cycle.pdf">https://www.nat.vu.nl/~ivo/pub/2005/lecturenotes3cycle.pdf</a>
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+kin-class">kin-class</a></code>,
<code><a href="#topic+dat-class">dat-class</a></code> </p>

<hr>
<h2 id='specopt-class'>Class &quot;specopt&quot; stores options for fitting and plotting spectral models</h2><span id='topic+specopt-class'></span><span id='topic+specopt'></span>

<h3>Description</h3>

<p>Class &quot;specopt&quot; stores options for fitting and plotting spectral
models in particular; this is a subclass of class <code>opt</code>.</p>


<h3>Details</h3>

<p>See <code><a href="#topic+opt-class">opt-class</a></code> for 
the specification of fitting/plotting options that are not specific to the 
class type.</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("specopt", ...)</code>.
or <code>specopt(...)</code></p>


<h3>Slots</h3>


<dl>
<dt><code>nospectra</code>:</dt><dd><p>Object of class <code>"logical"</code> 
that defaults
to <code>FALSE</code>; if <code>TRUE</code>, do not plot time-resolved spectra</p>
</dd>
<dt><code>selectedspectra</code>:</dt><dd><p>Object of class <code>"vector"</code> 
containing
<code>x</code> indices for which plots of 
time-resolved spectra are desired under a spectral model</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Katharine M. Mullen, Ivo H. M. van Stokkum</p>


<h3>See Also</h3>

<p><code><a href="#topic+opt-class">opt-class</a></code>, <code><a href="#topic+kinopt-class">kinopt-class</a></code>
</p>

<hr>
<h2 id='sumKinSpecEst'>Makes a summary plot of spectra associated with kinetic components
alongside a plot showing parameter estimates</h2><span id='topic+sumKinSpecEst'></span>

<h3>Description</h3>

<p>Makes a summary plot of spectra associated with kinetic components
alongside a plot showing parameter estimates for, by default, kinetic
parameters.  If the analysis had more parameters in the <code>addEst</code> slot
of the argument <code>opt</code>, then more parameters are displayed.
Note that this summary leaves out the spectra associated with coherent
artifact or scatter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sumKinSpecEst(listFits, addtitle = TRUE, customtitle = "", preps = "",
ylimlist=list(), kinspecerr=TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sumKinSpecEst_+3A_listfits">listFits</code></td>
<td>
<p>list of objects returned by the <code>fitModel</code> function</p>
</td></tr>
<tr><td><code id="sumKinSpecEst_+3A_addtitle">addtitle</code></td>
<td>
<p>logical regarding whether to add a title; if TRUE and
<code>customtitle</code> is not given then the title is
<code> "Summary of EADS for: "</code> plus the analysis titles</p>
</td></tr>
<tr><td><code id="sumKinSpecEst_+3A_customtitle">customtitle</code></td>
<td>
<p>character vector containing a title</p>
</td></tr>
<tr><td><code id="sumKinSpecEst_+3A_preps">preps</code></td>
<td>
<p>character vector describing the prefix of the postscript
filename given as output</p>
</td></tr>
<tr><td><code id="sumKinSpecEst_+3A_ylimlist">ylimlist</code></td>
<td>
<p>list with elements <code>list(ind, ylim)</code>.  <code>ind</code> is
an index into <code>listFits</code>; <code>ylim</code> is the desired <code>ylim</code> for
the plot for that analysis</p>
</td></tr>
<tr><td><code id="sumKinSpecEst_+3A_kinspecerr">kinspecerr</code></td>
<td>
<p>logical regarding whether to add error bars for to the
estimated spectra.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This looks best with less than five objects in <code>listFits</code>.
</p>


<h3>Value</h3>

<p>No return value, called for side effects</p>


<h3>Author(s)</h3>

<p>Katharine M. Mullen, Ivo H. M. van Stokkum</p>


<h3>See Also</h3>

 <p><code><a href="#topic+fitModel">fitModel</a></code>, <code><a href="#topic+examineFit">examineFit</a></code> </p>

<hr>
<h2 id='target'>Ultrafast time-resolved fluorescence data</h2><span id='topic+target'></span><span id='topic+C1'></span><span id='topic+C2'></span><span id='topic+C3'></span>

<h3>Description</h3>

<p>Ultrafast time-resolved absorption data</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("target")
</code></pre>


<h3>Format</h3>

<p><code>C1</code>, <code>C2</code> and <code>C3</code> are objects of class <code>dat</code>.
</p>


<h3>Details</h3>

<p>See <code><a href="#topic+preProcess">preProcess</a></code> for examples using this data.
</p>


<h3>References</h3>

<p>This data was described in
Bonetti C, Mathes T, van Stokkum IHM,
Mullen KM, Groot ML and
van Grondelle R, Hegemann P and Kennis, JTM (2008),
The variable projection algorithm in time-resolved spectroscopy,
microscopy and mass-spectroscopy applications,
Hydrogen bond switching among flavin and amino acid side
chains in the BLUF photoreceptor observed by ultrafast infrared spectroscopy,
<em>Biophysical Journal</em>, <b>in press</b>,
<a href="https://doi.org/10.1529/biophysj.108.139246">doi:10.1529/biophysj.108.139246</a>.
</p>

<hr>
<h2 id='theta-class'>Class &quot;theta&quot; for storage of nonlinear parameter estimates</h2><span id='topic+theta-class'></span><span id='topic+theta'></span>

<h3>Description</h3>

<p><code>theta</code> is the class to store parameter estimates associated with
possibly 
many datasets; after a call to <code>fitModel</code>
a list containing <code>theta</code> objects 
for each of the n datasets analyzed in the call to <code>fitModel</code> is
created.   To see the parameter estimates 
associated with the datasets, examine the object <code>currTheta</code>
in the list returned by <code>fitModel</code></p>


<h3>Details</h3>

<p>after a call to <code><a href="#topic+fitModel">fitModel</a></code>, an object of class 
<code>theta</code> exists in the global environment as the variable 
<code>currTheta</code>  </p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("theta", ...)</code> or 
<code>theta(...)</code>. 
</p>


<h3>Slots</h3>


<dl>
<dt><code>kinpar</code>:</dt><dd><p>Object of class <code>"vector"</code> of rate constant estimates </p>
</dd>
<dt><code>specpar</code>:</dt><dd><p>Object of class <code>"list"</code>   of spectral shape parameter estimates</p>
</dd>
<dt><code>irfpar</code>:</dt><dd><p>Object of class <code>"vector"</code>  of IRF parameter estimates</p>
</dd>
<dt><code>parmu</code>:</dt><dd><p>Object of class <code>"list"</code>   of parameter estimates describing dispersion of the location
of other parameters (in time, temp., etc.)</p>
</dd>
<dt><code>partau</code>:</dt><dd><p>Object of class <code>"vector"</code>  of parameter estimates describing dispersion of the 
width of other parameters (in time)</p>
</dd>
<dt><code>clpequ</code>:</dt><dd><p>Object of class <code>"vector"</code>  of parameter estimates describing conditionally linear
parameters (spectra, in a kinetic model) relations</p>
</dd>
<dt><code>specdisppar</code>:</dt><dd><p>Object of class <code>"list"</code>  of parameter estimates describing dispersion of
spectra</p>
</dd>
<dt><code>kinscal</code>:</dt><dd><p>Object of class <code>"vector"</code>  of parameters describing kinetic relations in
the context of a compartmental scheme</p>
</dd>
<dt><code>prel</code>:</dt><dd><p>Object of class <code>"vector"</code>  of parameters describing relations between
parameters (which may be linear, exponential, etc.)</p>
</dd>
<dt><code>dummy</code>:</dt><dd><p>Object of class <code>"list"</code> of dummy parameters which can be used in complex relations</p>
</dd>
<dt><code>eigenvaluesK</code>:</dt><dd><p>Object of class <code>"vector"</code>  containing the eigenvalues of the kinetic transfer matrix K</p>
</dd>
<dt><code>coh</code>:</dt><dd><p>Object of class <code>"vector"</code>  of parameters
describing a coherent artifact or pulse follower. </p>
</dd>
<dt><code>drel</code>:</dt><dd><p>Object of class <code>"vector"</code>  of parameters describing relations between
datasets (linear, and possibly per-wavelength or, in general, per-clp)</p>
</dd>
<dt>amplitudes</dt><dd></dd>
<dt>amps</dt><dd></dd>
<dt>anipar</dt><dd></dd>
<dt>cohirf</dt><dd></dd>
<dt>jvec</dt><dd></dd>
<dt>kin2scal</dt><dd></dd>
<dt>kinpar2</dt><dd></dd>
<dt>kinscalspecial</dt><dd></dd>
<dt><code>oscpar</code>:</dt><dd><p>Object of class <code>"vector"</code>  of parameters
describing oscillation parameters. The length depends on the type of oscillation and the number of oscillations. </p>
</dd>
<dt>peakpar</dt><dd></dd>
<dt>shift</dt><dd></dd>
</dl>



<h3>Author(s)</h3>

<p>Katharine M. Mullen, Ivo H. M. van Stokkum, Joris J. Snellenburg, Sergey P. Laptenok</p>


<h3>See Also</h3>

 <p><code><a href="#topic+fitModel">fitModel</a> </code>, <code><a href="#topic+multitheta-class">multitheta-class</a></code></p>

<hr>
<h2 id='writeAverage'>Writes the average of scans stored in a file to a new file in the
'ivo' format</h2><span id='topic+writeAverage'></span>

<h3>Description</h3>

<p>Some measurement set-ups dump a set of matrices stacked on
top of each other to a file; each matrix represents a scan.  This
function writes the average of the scans to a file in the '.ivo'
format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>writeAverage(filename, ntimes, nwave, scans,
             fileout = paste(filename, "Average.ivo", sep=""),
             calibration = 1:nwave, wexplicit=FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="writeAverage_+3A_filename">filename</code></td>
<td>
<p>This is the path to the file to read in, as a quoted string. </p>
</td></tr>
<tr><td><code id="writeAverage_+3A_ntimes">ntimes</code></td>
<td>
<p>number of times in each scan</p>
</td></tr>
<tr><td><code id="writeAverage_+3A_nwave">nwave</code></td>
<td>
<p>number of wavelengths in each scan</p>
</td></tr>
<tr><td><code id="writeAverage_+3A_scans">scans</code></td>
<td>
<p>number of full scans to read</p>
</td></tr>
<tr><td><code id="writeAverage_+3A_fileout">fileout</code></td>
<td>
<p>a character vector specifying the filename to write
the averaged data to; the default is to write a file
named &quot;filenameAverage.ivo&quot;</p>
</td></tr>
<tr><td><code id="writeAverage_+3A_calibration">calibration</code></td>
<td>
<p>a numeric vector representing the wavelength labels; by
default the labels &quot;1, 2, ..., nwave&quot; are used</p>
</td></tr>
<tr><td><code id="writeAverage_+3A_wexplicit">wexplicit</code></td>
<td>
<p>logical whether the file is written in the
'wavelength explicit' format, with each column of the
matrix written representing a wavelength, as opposed to the
'time explicit' format, where each column represents a timepoint.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, called for side effects</p>


<h3>Author(s)</h3>

<p>Katharine M. Mullen, Ivo H. M. van Stokkum</p>


<h3>See Also</h3>

 <p><code><a href="#topic+readData">readData</a></code> </p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
