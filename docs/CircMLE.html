<!DOCTYPE html><html><head><title>Help for package CircMLE</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {CircMLE}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#check_data'><p>Data Checking Function</p></a></li>
<li><a href='#ci_circmle'><p>ci_circmle</p></a></li>
<li><a href='#circ_mle'><p>circ_mle</p></a></li>
<li><a href='#dcor.circular'><p>circular distance correlation function</p></a></li>
<li><a href='#HR_test'><p>Hermans-Rasson test function</p></a></li>
<li><a href='#lr_test'><p>Likelihood ratio test for nested models</p></a></li>
<li><a href='#M1'><p>Model M1 MLE function</p></a></li>
<li><a href='#M2A'><p>Model M2A MLE function</p></a></li>
<li><a href='#M2B'><p>Model M2B MLE function</p></a></li>
<li><a href='#M2C'><p>Model M2C MLE function</p></a></li>
<li><a href='#M3A'><p>Model M3A MLE function</p></a></li>
<li><a href='#M3B'><p>Model M3B MLE function</p></a></li>
<li><a href='#M4A'><p>Model M4A MLE function</p></a></li>
<li><a href='#M4B'><p>Model M4B MLE function</p></a></li>
<li><a href='#M5A'><p>Model M5A MLE function</p></a></li>
<li><a href='#M5B'><p>Model M5B MLE function</p></a></li>
<li><a href='#plot_circMLE'><p>plot_circMLE</p></a></li>
<li><a href='#pycke_test'><p>Pycke test function</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Maximum Likelihood Analysis of Circular Data</td>
</tr>
<tr>
<td>Version:</td>
<td>0.3.0</td>
</tr>
<tr>
<td>Description:</td>
<td>A series of wrapper functions to
    implement the 10 maximum likelihood models of animal orientation
    described by Schnute and Groot (1992) &lt;<a href="https://doi.org/10.1016%2FS0003-3472%2805%2980068-5">doi:10.1016/S0003-3472(05)80068-5</a>&gt;. The
    functions also include the ability to use different optimizer
    methods and calculate various model selection metrics (i.e., AIC,
    AICc, BIC).  The ability to perform variants of the Hermans-Rasson test and
    Pycke test is also included as described in Landler et al. (2019) 
    &lt;<a href="https://doi.org/10.1186%2Fs12898-019-0246-8">doi:10.1186/s12898-019-0246-8</a>&gt;. The latest version also includes a new
    method to calculate circular-circular and circular-linear distance correlations. </td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Robert Fitak &lt;rfitak9@gmail.com&gt;</td>
</tr>
<tr>
<td>Author:</td>
<td>Robert Fitak [aut, cre],
  Sönke Johnsen [aut]</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.2.2)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://www.r-project.org">https://www.r-project.org</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Date:</td>
<td>2020-8-31</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Imports:</td>
<td>circular (&ge; 0.4-7), stats, energy (&ge; 1.7-7)</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2020-09-01 20:58:54 UTC; rfitak</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2020-09-01 21:30:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='check_data'>Data Checking Function</h2><span id='topic+check_data'></span>

<h3>Description</h3>

<p>Make sure data is in the right format.  Datasets are coerced into class 'circular'
of type = angles, units = radians, and modulo = 2pi.  It is recommended to set
these atributes ahead of time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_data(data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_data_+3A_data">data</code></td>
<td>
<p>A vector, class 'circular' is recommended but not required</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>testdata = circular::rvonmises(100, mu = circular::circular(pi), kappa = 3,
   control.circular = list(units = "degrees"))
check_data(testdata)
</code></pre>

<hr>
<h2 id='ci_circmle'>ci_circmle</h2><span id='topic+ci_circmle'></span>

<h3>Description</h3>

<p>Calculate the 95% confidence interval for estimated model parameters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ci_circmle(circmle, model)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ci_circmle_+3A_circmle">circmle</code></td>
<td>
<p>A list consisting of the output from function 'circ_mle'</p>
</td></tr>
<tr><td><code id="ci_circmle_+3A_model">model</code></td>
<td>
<p>character string indicating the model to be used to estimate parameter uncertainty.
Must be one of c(&quot;M2A&quot;, &quot;M2B&quot;, &quot;M2C&quot;, &quot;M3A&quot;, &quot;M3B&quot;, &quot;M4A&quot;, &quot;M4B&quot;,
&quot;M5A&quot;, &quot;M5B&quot;). Default = the $bestmodel from the circmle object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with a column for the parameter name, the maximum likelihood estimate (MLE),
standard error (SE), and 95% confidence interval (CI) for each estimated model parameter.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>testdata = circular::rvonmises(100, mu = circular::circular(pi), kappa = 3)
fit &lt;- circ_mle(testdata)
ci_circmle(fit)
</code></pre>

<hr>
<h2 id='circ_mle'>circ_mle</h2><span id='topic+circ_mle'></span>

<h3>Description</h3>

<p>Run all 10 maximum likelihood models of circular orientation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>circ_mle(
  data,
  criterion = "AIC",
  nchains = 5,
  BadStart = 10^9,
  niter = 5000,
  method = "BFGS",
  lambda.min = 0.25,
  q.diff,
  exclude = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="circ_mle_+3A_data">data</code></td>
<td>
<p>A vector of class 'circular'</p>
</td></tr>
<tr><td><code id="circ_mle_+3A_criterion">criterion</code></td>
<td>
<p>chose from either &quot;AIC&quot;, &quot;AICc&quot;, or &quot;BIC&quot; for the
model comparison information criterion. (default = &quot;AIC&quot;)</p>
</td></tr>
<tr><td><code id="circ_mle_+3A_nchains">nchains</code></td>
<td>
<p>A positive integer indicating the number of chains to run.
Only the chain with the lowest log likelihood is returned (default = 5)</p>
</td></tr>
<tr><td><code id="circ_mle_+3A_badstart">BadStart</code></td>
<td>
<p>An integer to replace the log likelihood when starting
parameters of the optimizer fall outside the preset bounds.  This is
usually set to a large number. Can also be set to Inf, but will
result in an error if a method other than &quot;Nelder-Mead&quot; is chosen. (default = 10^9)</p>
</td></tr>
<tr><td><code id="circ_mle_+3A_niter">niter</code></td>
<td>
<p>The maximum number of iterations for the optimizing
algorithm.  Equivalent to the 'maxit' control parameter of the
optim() function.  See ?optim for more details. (default = 5000)</p>
</td></tr>
<tr><td><code id="circ_mle_+3A_method">method</code></td>
<td>
<p>A character string indicating the optimizing algorithm
to use.  Either &quot;BFGS&quot; or &quot;Nelder-Mead&quot; are recommended. See ?optim
for more details. (default = &quot;BFGS&quot;)</p>
</td></tr>
<tr><td><code id="circ_mle_+3A_lambda.min">lambda.min</code></td>
<td>
<p>The minimum proportional size of the first distribution.
Must be between 0 and 1. (default = 0.25)</p>
</td></tr>
<tr><td><code id="circ_mle_+3A_q.diff">q.diff</code></td>
<td>
<p>The minimum difference (in radians) in preferred direction
for bimodal models. Must be set between 0 and pi. (default = pi/4)</p>
</td></tr>
<tr><td><code id="circ_mle_+3A_exclude">exclude</code></td>
<td>
<p>A character vector of the models to be excluded from the calculations.
(The default is to include all 10 models). For example, exclude = c(&quot;M1&quot;, &quot;M3A&quot;, &quot;M5B&quot;).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with 4 elements:
</p>
<p>$results: A data frame consisting of a row for each model (rownames) with the columns:
1 = number of free parameters, 2 = mu1, 3 = kappa1, 4 = lamda, 5 = mu2, 6 = kappa2,
7 = negative log likelihood, 8 = Counts.function, 9 = Counts.Gradient,
10 = convergence, 11 = message, 12 = AIC, 13 = AICc, 14 = BIC, 15 = delta AIC, 16 = delta AICc,
17 = delta BIC, 18 = relative likelihoods of criterion chosen, 19 = model weights (probabilities)
for criterion chosen, 20 = evidence ratios for the best model selected by the criterion. See ?optim
for details on columns 8-11.
</p>
<p>$bestmodel:  The best model according to the criterion chosen
</p>
<p>$rt:  A two-element vector giving the test statistic and p-value for the Rayleigh Test
</p>
<p>$hessians:  A list with each element containing the hessian matrix for each model. Used for calculating connfidence intervals of parameters.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>testdata = circular::rvonmises(100, mu = circular::circular(pi), kappa = 3)
circ_mle(testdata)
</code></pre>

<hr>
<h2 id='dcor.circular'>circular distance correlation function</h2><span id='topic+dcor.circular'></span>

<h3>Description</h3>

<p>Perform a distance correlation between circular datasets or between circular and linear datasets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dcor.circular(x, y, method = "chord", type = "c-c", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dcor.circular_+3A_x">x</code></td>
<td>
<p>A vector of class 'circular', or numeric vector of angles measured in radians</p>
</td></tr>
<tr><td><code id="dcor.circular_+3A_y">y</code></td>
<td>
<p>A vector of class 'circular', numeric vector of angles measured in radians, or numeric vector</p>
</td></tr>
<tr><td><code id="dcor.circular_+3A_method">method</code></td>
<td>
<p>the distance measure to be used. This must be one of the following functions:
‘&quot;angularseparation&quot;’, ‘&quot;chord&quot;’, '&quot;geodesic&quot;’, or '&quot;circ.range&quot;' (default = &quot;chord&quot;).
see ?dist.circular for additional details.</p>
</td></tr>
<tr><td><code id="dcor.circular_+3A_type">type</code></td>
<td>
<p>if ‘type == &quot;c-c&quot;’ then perform a circular-circular distance
corellation, else if ‘type == &quot;c-l&quot;’ then perform a circular-linear distance
corellation (default = &quot;c-c&quot;).</p>
</td></tr>
<tr><td><code id="dcor.circular_+3A_...">...</code></td>
<td>
<p>additional parameters passed to the dcor.test function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Same as from the <code><a href="energy.html#topic+dcor.test">dcor.test</a></code> function:
a list with class ‘htest’containing
</p>
<p>method: description of test
</p>
<p>statistic: observed value of the test statistic
</p>
<p>estimate: dCov(x,y) or dCor(x,y)
</p>
<p>estimates: a vector: [dCov(x,y), dCor(x,y), dVar(x), dVar(y)]
</p>
<p>replicates: replicates of the test statistic
</p>
<p>p.value: approximate p-value of the test
</p>
<p>n: sample size
</p>
<p>data.name: description of data
</p>


<h3>See Also</h3>

<p><code><a href="energy.html#topic+dcor">dcor</a></code>
<code><a href="energy.html#topic+dcov">dcov</a></code>
<code><a href="energy.html#topic+DCOR">DCOR</a></code>
<code><a href="energy.html#topic+dcor.test">dcor.test</a></code>
<code><a href="circular.html#topic+dist.circular">dist.circular</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Circular-circular distance corellation
x &lt;- circular::rvonmises(n = 50, mu = circular::circular(0), kappa = 3)
y &lt;- x + circular::rvonmises(n = 50, mu = circular::circular(pi), kappa = 10)
dcor.circular(x, y)

# Run permutation test with 9999 iterations
dcor.circular(x, y, R = 9999)

# Circular-linear distance corellation
x &lt;- circular::rvonmises(n = 50, mu = circular::circular(0), kappa = 3)
y &lt;- as.numeric(x) + rnorm(50, mean = 5, sd = 2)
dcor.circular(x, y, type = "c-l", R = 9999)
</code></pre>

<hr>
<h2 id='HR_test'>Hermans-Rasson test function</h2><span id='topic+HR_test'></span>

<h3>Description</h3>

<p>Perform variants of the Hermans-Rasson test.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>HR_test(data, original = F, iter = 9999)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="HR_test_+3A_data">data</code></td>
<td>
<p>A vector of class 'circular', or numeric vector of 
angles measured in radians</p>
</td></tr>
<tr><td><code id="HR_test_+3A_original">original</code></td>
<td>
<p>A logical of whether or not to run the original 
version of the Hermans-Rasson test or the newer version described
in Landler et al. (2019) doi: 10.1186/s12898-019-0246-8 (default = F)</p>
</td></tr>
<tr><td><code id="HR_test_+3A_iter">iter</code></td>
<td>
<p>The number of bootstrap replicates to perform in order 
to estimate the p-value of the test. (default = 9999)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector of the test statistic (T) and associated p-value
</p>


<h3>Examples</h3>

<pre><code class='language-R'>testdata = circular::rvonmises(20, mu = circular::circular(pi), kappa = 3)
HR_test(testdata, iter = 999)
</code></pre>

<hr>
<h2 id='lr_test'>Likelihood ratio test for nested models</h2><span id='topic+lr_test'></span>

<h3>Description</h3>

<p>Statistically test nested models for the rejection of the null model
in favor of the alternative model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lr_test(data, null_model, alt_model)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lr_test_+3A_data">data</code></td>
<td>
<p>A vector of class 'circular'</p>
</td></tr>
<tr><td><code id="lr_test_+3A_null_model">null_model</code></td>
<td>
<p>character string indicating the null model to be used.
Must be one of c(&quot;M1&quot;, &quot;M2A&quot;, &quot;M2B&quot;, &quot;M2C&quot;, &quot;M3A&quot;, &quot;M3B&quot;, &quot;M4A&quot;, &quot;M4B&quot;,
&quot;M5A&quot;, &quot;M5B&quot;).</p>
</td></tr>
<tr><td><code id="lr_test_+3A_alt_model">alt_model</code></td>
<td>
<p>character string indicating the alternative model to be used.
Must be one of c(&quot;M1&quot;, &quot;M2A&quot;, &quot;M2B&quot;, &quot;M2C&quot;, &quot;M3A&quot;, &quot;M3B&quot;, &quot;M4A&quot;, &quot;M4B&quot;,
&quot;M5A&quot;, &quot;M5B&quot;).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with elements:
</p>
<p>$null_model: Vector with the model name and number of free parameters
</p>
<p>$alt_model: Vector with the model name and number of free parameters
</p>
<p>$lr: likelihood ratio test statistic 2 * (-log(L1) - -log(L2))
</p>
<p>$df: degrees of freedom (difference in number of parameters between models)
</p>
<p>$p_val: probability of rejecting null model in favor of alternative
model due to chance (e.g, if &lt;0.05, data favors alternative model).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>testdata = circular::rvonmises(100, mu = circular::circular(pi), kappa = 3)
lr_test(testdata, "M1", "M2A")
</code></pre>

<hr>
<h2 id='M1'>Model M1 MLE function</h2><span id='topic+M1'></span>

<h3>Description</h3>

<p>Run Maximum likelihood estimation for model M1.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>M1(data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="M1_+3A_data">data</code></td>
<td>
<p>A vector of class 'circular'</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the elements:
</p>
<p>$lik: The negative log likelihood of data for model M1
</p>


<h3>Examples</h3>

<pre><code class='language-R'>testdata = circular::rvonmises(100, mu = circular::circular(pi), kappa = 3)
M1(testdata)
</code></pre>

<hr>
<h2 id='M2A'>Model M2A MLE function</h2><span id='topic+M2A'></span>

<h3>Description</h3>

<p>Run Maximum likelihood estimation for model M2A.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>M2A(data, BadStart, nchains, method, niter)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="M2A_+3A_data">data</code></td>
<td>
<p>A vector of class 'circular'</p>
</td></tr>
<tr><td><code id="M2A_+3A_badstart">BadStart</code></td>
<td>
<p>An integer to replace the log likelihood when starting
parameters of the optimizer fall outside the preset bounds.  This is
usually set to a large number. Can also be set to Inf, but will
result in an error if a method other than &quot;Nelder-Mead&quot; is chosen. (default = 10^9)</p>
</td></tr>
<tr><td><code id="M2A_+3A_nchains">nchains</code></td>
<td>
<p>A positive integer indicating the number of chains to run.
Only the chain with the lowest log likelihood is returned (default = 5)</p>
</td></tr>
<tr><td><code id="M2A_+3A_method">method</code></td>
<td>
<p>A character string indicating the optimizing algorithm
to use.  Either &quot;BFGS&quot; or &quot;Nelder-Mead&quot; are recommended. See ?optim
for more details. (default = &quot;BFGS&quot;)</p>
</td></tr>
<tr><td><code id="M2A_+3A_niter">niter</code></td>
<td>
<p>The maximum number of iterations for the optimizing
algorithm.  Equivalent to the 'maxit' control parameter of the
optim() function.  See ?optim for more details. (default = 5000)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with elements (same as for function optim()):
</p>
<p>$par:  Vector with the optimized mean angle (mu1) and concentration parameter (kappa1)
</p>
<p>$lik:  The negative log likelihood
</p>
<p>$counts:  A two-element integer vector giving the number of calls to
‘fn’ and ‘gr’ respectively. See ?optim() for details.
</p>
<p>$convergence:  An integer code. ‘0’ indicates successful completion
(which is always the case for ‘&quot;SANN&quot;’ and ‘&quot;Brent&quot;’). Possible error codes are:
</p>
<p>‘1’ indicates that the iteration limit ‘maxit’ had been reached.
</p>
<p>‘10’ indicates degeneracy of the Nelder-Mead simplex.
</p>
<p>‘51’ indicates a warning from the ‘&quot;L-BFGS-B&quot;’ method; see
component ‘message’ for further details.
</p>
<p>‘52’ indicates an error from the ‘&quot;L-BFGS-B&quot;’ method; see
component ‘message’ for further details.
</p>
<p>$message:  A character string giving any additional information returned
by the optimizer, or ‘NULL’.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>testdata = circular::rvonmises(100, mu = circular::circular(pi), kappa = 3)
M2A(testdata)
</code></pre>

<hr>
<h2 id='M2B'>Model M2B MLE function</h2><span id='topic+M2B'></span>

<h3>Description</h3>

<p>Run Maximum likelihood estimation for model M2B.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>M2B(data, BadStart, nchains, method, niter)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="M2B_+3A_data">data</code></td>
<td>
<p>A vector of class 'circular'</p>
</td></tr>
<tr><td><code id="M2B_+3A_badstart">BadStart</code></td>
<td>
<p>An integer to replace the log likelihood when starting
parameters of the optimizer fall outside the preset bounds.  This is
usually set to a large number. Can also be set to Inf, but will
result in an error if a method other than &quot;Nelder-Mead&quot; is chosen. (default = 10^9)</p>
</td></tr>
<tr><td><code id="M2B_+3A_nchains">nchains</code></td>
<td>
<p>A positive integer indicating the number of chains to run.
Only the chain with the lowest log likelihood is returned (default = 5)</p>
</td></tr>
<tr><td><code id="M2B_+3A_method">method</code></td>
<td>
<p>A character string indicating the optimizing algorithm
to use.  Either &quot;BFGS&quot; or &quot;Nelder-Mead&quot; are recommended. See ?optim
for more details. (default = &quot;BFGS&quot;)</p>
</td></tr>
<tr><td><code id="M2B_+3A_niter">niter</code></td>
<td>
<p>The maximum number of iterations for the optimizing
algorithm.  Equivalent to the 'maxit' control parameter of the
optim() function.  See ?optim for more details. (default = 5000)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with elements (same as for function optim()):
</p>
<p>$par:  Vector with the optimized mean angle (mu1) and concentration parameter (kappa1)
</p>
<p>$lik:  The negative log likelihood
</p>
<p>$counts:  A two-element integer vector giving the number of calls to
‘fn’ and ‘gr’ respectively. See ?optim() for details.
</p>
<p>$convergence:  An integer code. ‘0’ indicates successful completion
(which is always the case for ‘&quot;SANN&quot;’ and ‘&quot;Brent&quot;’). Possible error codes are:
</p>
<p>‘1’ indicates that the iteration limit ‘maxit’ had been reached.
</p>
<p>‘10’ indicates degeneracy of the Nelder-Mead simplex.
</p>
<p>‘51’ indicates a warning from the ‘&quot;L-BFGS-B&quot;’ method; see
component ‘message’ for further details.
</p>
<p>‘52’ indicates an error from the ‘&quot;L-BFGS-B&quot;’ method; see
component ‘message’ for further details.
</p>
<p>$message:  A character string giving any additional information returned
by the optimizer, or ‘NULL’.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>testdata = circular::rvonmises(100, mu = circular::circular(pi), kappa = 3)
M2B(testdata)
</code></pre>

<hr>
<h2 id='M2C'>Model M2C MLE function</h2><span id='topic+M2C'></span>

<h3>Description</h3>

<p>Run Maximum likelihood estimation for model M2C.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>M2C(data, BadStart, nchains, method, niter, lambda.min)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="M2C_+3A_data">data</code></td>
<td>
<p>A vector of class 'circular'</p>
</td></tr>
<tr><td><code id="M2C_+3A_badstart">BadStart</code></td>
<td>
<p>An integer to replace the log likelihood when starting
parameters of the optimizer fall outside the preset bounds.  This is
usually set to a large number. Can also be set to Inf, but will
result in an error if a method other than &quot;Nelder-Mead&quot; is chosen. (default = 10^9)</p>
</td></tr>
<tr><td><code id="M2C_+3A_nchains">nchains</code></td>
<td>
<p>A positive integer indicating the number of chains to run.
Only the chain with the lowest log likelihood is returned (default = 5)</p>
</td></tr>
<tr><td><code id="M2C_+3A_method">method</code></td>
<td>
<p>A character string indicating the optimizing algorithm
to use.  Either &quot;BFGS&quot; or &quot;Nelder-Mead&quot; are recommended. See ?optim
for more details. (default = &quot;BFGS&quot;)</p>
</td></tr>
<tr><td><code id="M2C_+3A_niter">niter</code></td>
<td>
<p>The maximum number of iterations for the optimizing
algorithm.  Equivalent to the 'maxit' control parameter of the
optim() function.  See ?optim for more details. (default = 5000)</p>
</td></tr>
<tr><td><code id="M2C_+3A_lambda.min">lambda.min</code></td>
<td>
<p>The minimum proportional size of the first distribution.
Must be between 0 and 1. (default = 0.25)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with elements (same as for function optim()):
</p>
<p>$par:  Vector with the optimized mean angle (mu1), concentration parameter (kappa1)
and proportional size (lambda) of the first distribution (mu1 and kappa1).
</p>
<p>$lik:  The negative log likelihood
</p>
<p>$counts:  A two-element integer vector giving the number of calls to
‘fn’ and ‘gr’ respectively. See ?optim() for details.
</p>
<p>$convergence:  An integer code. ‘0’ indicates successful completion
(which is always the case for ‘&quot;SANN&quot;’ and ‘&quot;Brent&quot;’). Possible error codes are:
</p>
<p>‘1’ indicates that the iteration limit ‘maxit’ had been reached.
</p>
<p>‘10’ indicates degeneracy of the Nelder-Mead simplex.
</p>
<p>‘51’ indicates a warning from the ‘&quot;L-BFGS-B&quot;’ method; see
component ‘message’ for further details.
</p>
<p>‘52’ indicates an error from the ‘&quot;L-BFGS-B&quot;’ method; see
component ‘message’ for further details.
</p>
<p>$message:  A character string giving any additional information returned
by the optimizer, or ‘NULL’.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>testdata = circular::rvonmises(100, mu = circular::circular(pi), kappa = 3)
M2C(testdata)
</code></pre>

<hr>
<h2 id='M3A'>Model M3A MLE function</h2><span id='topic+M3A'></span>

<h3>Description</h3>

<p>Run Maximum likelihood estimation for model M3A.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>M3A(data, BadStart, nchains, method, niter)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="M3A_+3A_data">data</code></td>
<td>
<p>A vector of class 'circular'</p>
</td></tr>
<tr><td><code id="M3A_+3A_badstart">BadStart</code></td>
<td>
<p>An integer to replace the log likelihood when starting
parameters of the optimizer fall outside the preset bounds.  This is
usually set to a large number. Can also be set to Inf, but will
result in an error if a method other than &quot;Nelder-Mead&quot; is chosen. (default = 10^9)</p>
</td></tr>
<tr><td><code id="M3A_+3A_nchains">nchains</code></td>
<td>
<p>A positive integer indicating the number of chains to run.
Only the chain with the lowest log likelihood is returned (default = 5)</p>
</td></tr>
<tr><td><code id="M3A_+3A_method">method</code></td>
<td>
<p>A character string indicating the optimizing algorithm
to use.  Either &quot;BFGS&quot; or &quot;Nelder-Mead&quot; are recommended. See ?optim
for more details. (default = &quot;BFGS&quot;)</p>
</td></tr>
<tr><td><code id="M3A_+3A_niter">niter</code></td>
<td>
<p>The maximum number of iterations for the optimizing
algorithm.  Equivalent to the 'maxit' control parameter of the
optim() function.  See ?optim for more details. (default = 5000)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with elements (same as for function optim()):
</p>
<p>$par:  Vector with the optimized mean angle (mu1) and concentration parameter (kappa1).
</p>
<p>$lik:  The negative log likelihood
</p>
<p>$counts:  A two-element integer vector giving the number of calls to
‘fn’ and ‘gr’ respectively. See ?optim() for details.
</p>
<p>$convergence:  An integer code. ‘0’ indicates successful completion
(which is always the case for ‘&quot;SANN&quot;’ and ‘&quot;Brent&quot;’). Possible error codes are:
</p>
<p>‘1’ indicates that the iteration limit ‘maxit’ had been reached.
</p>
<p>‘10’ indicates degeneracy of the Nelder-Mead simplex.
</p>
<p>‘51’ indicates a warning from the ‘&quot;L-BFGS-B&quot;’ method; see
component ‘message’ for further details.
</p>
<p>‘52’ indicates an error from the ‘&quot;L-BFGS-B&quot;’ method; see
component ‘message’ for further details.
</p>
<p>$message:  A character string giving any additional information returned
by the optimizer, or ‘NULL’.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>testdata = circular::rvonmises(100, mu = circular::circular(pi), kappa = 3)
M3A(testdata)
</code></pre>

<hr>
<h2 id='M3B'>Model M3B MLE function</h2><span id='topic+M3B'></span>

<h3>Description</h3>

<p>Run Maximum likelihood estimation for model M3B.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>M3B(data, BadStart, nchains, method, niter)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="M3B_+3A_data">data</code></td>
<td>
<p>A vector of class 'circular'</p>
</td></tr>
<tr><td><code id="M3B_+3A_badstart">BadStart</code></td>
<td>
<p>An integer to replace the log likelihood when starting
parameters of the optimizer fall outside the preset bounds.  This is
usually set to a large number. Can also be set to Inf, but will
result in an error if a method other than &quot;Nelder-Mead&quot; is chosen. (default = 10^9)</p>
</td></tr>
<tr><td><code id="M3B_+3A_nchains">nchains</code></td>
<td>
<p>A positive integer indicating the number of chains to run.
Only the chain with the lowest log likelihood is returned (default = 5)</p>
</td></tr>
<tr><td><code id="M3B_+3A_method">method</code></td>
<td>
<p>A character string indicating the optimizing algorithm
to use.  Either &quot;BFGS&quot; or &quot;Nelder-Mead&quot; are recommended. See ?optim
for more details. (default = &quot;BFGS&quot;)</p>
</td></tr>
<tr><td><code id="M3B_+3A_niter">niter</code></td>
<td>
<p>The maximum number of iterations for the optimizing
algorithm.  Equivalent to the 'maxit' control parameter of the
optim() function.  See ?optim for more details. (default = 5000)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with elements (same as for function optim()):
</p>
<p>$par:  Vector with the optimized mean angle (mu1),
concentration parameter (kappa1), and concentration parameter (kappa2).
</p>
<p>$lik:  The negative log likelihood
</p>
<p>$counts:  A two-element integer vector giving the number of calls to
‘fn’ and ‘gr’ respectively. See ?optim() for details.
</p>
<p>$convergence:  An integer code. ‘0’ indicates successful completion
(which is always the case for ‘&quot;SANN&quot;’ and ‘&quot;Brent&quot;’). Possible error codes are:
</p>
<p>‘1’ indicates that the iteration limit ‘maxit’ had been reached.
</p>
<p>‘10’ indicates degeneracy of the Nelder-Mead simplex.
</p>
<p>‘51’ indicates a warning from the ‘&quot;L-BFGS-B&quot;’ method; see
component ‘message’ for further details.
</p>
<p>‘52’ indicates an error from the ‘&quot;L-BFGS-B&quot;’ method; see
component ‘message’ for further details.
</p>
<p>$message:  A character string giving any additional information returned
by the optimizer, or ‘NULL’.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>testdata = circular::rvonmises(100, mu = circular::circular(pi), kappa = 3)
M3B(testdata)
</code></pre>

<hr>
<h2 id='M4A'>Model M4A MLE function</h2><span id='topic+M4A'></span>

<h3>Description</h3>

<p>Run Maximum likelihood estimation for model M4A.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>M4A(data, BadStart, nchains, method, niter, lambda.min)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="M4A_+3A_data">data</code></td>
<td>
<p>A vector of class 'circular'</p>
</td></tr>
<tr><td><code id="M4A_+3A_badstart">BadStart</code></td>
<td>
<p>An integer to replace the log likelihood when starting
parameters of the optimizer fall outside the preset bounds.  This is
usually set to a large number. Can also be set to Inf, but will
result in an error if a method other than &quot;Nelder-Mead&quot; is chosen. (default = 10^9)</p>
</td></tr>
<tr><td><code id="M4A_+3A_nchains">nchains</code></td>
<td>
<p>A positive integer indicating the number of chains to run.
Only the chain with the lowest log likelihood is returned (default = 5)</p>
</td></tr>
<tr><td><code id="M4A_+3A_method">method</code></td>
<td>
<p>A character string indicating the optimizing algorithm
to use.  Either &quot;BFGS&quot; or &quot;Nelder-Mead&quot; are recommended. See ?optim
for more details. (default = &quot;BFGS&quot;)</p>
</td></tr>
<tr><td><code id="M4A_+3A_niter">niter</code></td>
<td>
<p>The maximum number of iterations for the optimizing
algorithm.  Equivalent to the 'maxit' control parameter of the
optim() function.  See ?optim for more details. (default = 5000)</p>
</td></tr>
<tr><td><code id="M4A_+3A_lambda.min">lambda.min</code></td>
<td>
<p>The minimum proportional size of the first distribution.
Must be between 0 and 1. (default = 0.25)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with elements (same as for function optim()):
</p>
<p>$par:  Vector with the optimized mean angle (mu1),
concentration parameter (kappa1), and proportional size (lambda) of the first distribution.
</p>
<p>$lik:  The negative log likelihood
</p>
<p>$counts:  A two-element integer vector giving the number of calls to
‘fn’ and ‘gr’ respectively. See ?optim() for details.
</p>
<p>$convergence:  An integer code. ‘0’ indicates successful completion
(which is always the case for ‘&quot;SANN&quot;’ and ‘&quot;Brent&quot;’). Possible error codes are:
</p>
<p>‘1’ indicates that the iteration limit ‘maxit’ had been reached.
</p>
<p>‘10’ indicates degeneracy of the Nelder-Mead simplex.
</p>
<p>‘51’ indicates a warning from the ‘&quot;L-BFGS-B&quot;’ method; see
component ‘message’ for further details.
</p>
<p>‘52’ indicates an error from the ‘&quot;L-BFGS-B&quot;’ method; see
component ‘message’ for further details.
</p>
<p>$message:  A character string giving any additional information returned
by the optimizer, or ‘NULL’.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>testdata = circular::rvonmises(100, mu = circular::circular(pi), kappa = 3)
M4A(testdata)
</code></pre>

<hr>
<h2 id='M4B'>Model M4B MLE function</h2><span id='topic+M4B'></span>

<h3>Description</h3>

<p>Run Maximum likelihood estimation for model M4B.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>M4B(data, BadStart, nchains, method, niter, lambda.min)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="M4B_+3A_data">data</code></td>
<td>
<p>A vector of class 'circular'</p>
</td></tr>
<tr><td><code id="M4B_+3A_badstart">BadStart</code></td>
<td>
<p>An integer to replace the log likelihood when starting
parameters of the optimizer fall outside the preset bounds.  This is
usually set to a large number. Can also be set to Inf, but will
result in an error if a method other than &quot;Nelder-Mead&quot; is chosen. (default = 10^9)</p>
</td></tr>
<tr><td><code id="M4B_+3A_nchains">nchains</code></td>
<td>
<p>A positive integer indicating the number of chains to run.
Only the chain with the lowest log likelihood is returned (default = 5)</p>
</td></tr>
<tr><td><code id="M4B_+3A_method">method</code></td>
<td>
<p>A character string indicating the optimizing algorithm
to use.  Either &quot;BFGS&quot; or &quot;Nelder-Mead&quot; are recommended. See ?optim
for more details. (default = &quot;BFGS&quot;)</p>
</td></tr>
<tr><td><code id="M4B_+3A_niter">niter</code></td>
<td>
<p>The maximum number of iterations for the optimizing
algorithm.  Equivalent to the 'maxit' control parameter of the
optim() function.  See ?optim for more details. (default = 5000)</p>
</td></tr>
<tr><td><code id="M4B_+3A_lambda.min">lambda.min</code></td>
<td>
<p>The minimum proportional size of the first distribution.
Must be between 0 and 1. (default = 0.25)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with elements (same as for function optim()):
</p>
<p>$par:  Vector with the optimized mean angle (mu1),
concentration parameter (kappa1), concentration parameter (kappa2),
and proportional size (lambda) of the first distribution.
</p>
<p>$lik:  The negative log likelihood
</p>
<p>$counts:  A two-element integer vector giving the number of calls to
‘fn’ and ‘gr’ respectively. See ?optim() for details.
</p>
<p>$convergence:  An integer code. ‘0’ indicates successful completion
(which is always the case for ‘&quot;SANN&quot;’ and ‘&quot;Brent&quot;’). Possible error codes are:
</p>
<p>‘1’ indicates that the iteration limit ‘maxit’ had been reached.
</p>
<p>‘10’ indicates degeneracy of the Nelder-Mead simplex.
</p>
<p>‘51’ indicates a warning from the ‘&quot;L-BFGS-B&quot;’ method; see
component ‘message’ for further details.
</p>
<p>‘52’ indicates an error from the ‘&quot;L-BFGS-B&quot;’ method; see
component ‘message’ for further details.
</p>
<p>$message:  A character string giving any additional information returned
by the optimizer, or ‘NULL’.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>testdata = circular::rvonmises(100, mu = circular::circular(pi), kappa = 3)
M4B(testdata)
</code></pre>

<hr>
<h2 id='M5A'>Model M5A MLE function</h2><span id='topic+M5A'></span>

<h3>Description</h3>

<p>Run Maximum likelihood estimation for model M5A.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>M5A(data, BadStart, nchains, method, niter, lambda.min, q.diff)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="M5A_+3A_data">data</code></td>
<td>
<p>A vector of class 'circular'</p>
</td></tr>
<tr><td><code id="M5A_+3A_badstart">BadStart</code></td>
<td>
<p>An integer to replace the log likelihood when starting
parameters of the optimizer fall outside the preset bounds.  This is
usually set to a large number. Can also be set to Inf, but will
result in an error if a method other than &quot;Nelder-Mead&quot; is chosen. (default = 10^9)</p>
</td></tr>
<tr><td><code id="M5A_+3A_nchains">nchains</code></td>
<td>
<p>A positive integer indicating the number of chains to run.
Only the chain with the lowest log likelihood is returned (default = 5)</p>
</td></tr>
<tr><td><code id="M5A_+3A_method">method</code></td>
<td>
<p>A character string indicating the optimizing algorithm
to use.  Either &quot;BFGS&quot; or &quot;Nelder-Mead&quot; are recommended. See ?optim
for more details. (default = &quot;BFGS&quot;)</p>
</td></tr>
<tr><td><code id="M5A_+3A_niter">niter</code></td>
<td>
<p>The maximum number of iterations for the optimizing
algorithm.  Equivalent to the 'maxit' control parameter of the
optim() function.  See ?optim for more details. (default = 5000)</p>
</td></tr>
<tr><td><code id="M5A_+3A_lambda.min">lambda.min</code></td>
<td>
<p>The minimum proportional size of the first distribution.
Must be between 0 and 1. (default = 0.25)</p>
</td></tr>
<tr><td><code id="M5A_+3A_q.diff">q.diff</code></td>
<td>
<p>The minimum difference (in radians) in preferred direction
for bimodal models. Must be set between 0 and pi. (default = pi/4)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with elements (same as for function optim()):
</p>
<p>$par:  Vector with the optimized mean angle (mu1),
concentration parameter (kappa1), mean angle (mu2),
and proportional size (lambda) of the first distribution.
</p>
<p>$lik:  The negative log likelihood
</p>
<p>$counts:  A two-element integer vector giving the number of calls to
‘fn’ and ‘gr’ respectively. See ?optim() for details.
</p>
<p>$convergence:  An integer code. ‘0’ indicates successful completion
(which is always the case for ‘&quot;SANN&quot;’ and ‘&quot;Brent&quot;’). Possible error codes are:
</p>
<p>‘1’ indicates that the iteration limit ‘maxit’ had been reached.
</p>
<p>‘10’ indicates degeneracy of the Nelder-Mead simplex.
</p>
<p>‘51’ indicates a warning from the ‘&quot;L-BFGS-B&quot;’ method; see
component ‘message’ for further details.
</p>
<p>‘52’ indicates an error from the ‘&quot;L-BFGS-B&quot;’ method; see
component ‘message’ for further details.
</p>
<p>$message:  A character string giving any additional information returned
by the optimizer, or ‘NULL’.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>testdata = circular::rvonmises(100, mu = circular::circular(pi), kappa = 3)
M5A(testdata)
</code></pre>

<hr>
<h2 id='M5B'>Model M5B MLE function</h2><span id='topic+M5B'></span>

<h3>Description</h3>

<p>Run Maximum likelihood estimation for model M5B.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>M5B(data, BadStart, nchains, method, niter, lambda.min, q.diff)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="M5B_+3A_data">data</code></td>
<td>
<p>A vector of class 'circular'</p>
</td></tr>
<tr><td><code id="M5B_+3A_badstart">BadStart</code></td>
<td>
<p>An integer to replace the log likelihood when starting
parameters of the optimizer fall outside the preset bounds.  This is
usually set to a large number. Can also be set to Inf, but will
result in an error if a method other than &quot;Nelder-Mead&quot; is chosen. (default = 10^9)</p>
</td></tr>
<tr><td><code id="M5B_+3A_nchains">nchains</code></td>
<td>
<p>A positive integer indicating the number of chains to run.
Only the chain with the lowest log likelihood is returned (default = 5)</p>
</td></tr>
<tr><td><code id="M5B_+3A_method">method</code></td>
<td>
<p>A character string indicating the optimizing algorithm
to use.  Either &quot;BFGS&quot; or &quot;Nelder-Mead&quot; are recommended. See ?optim
for more details. (default = &quot;BFGS&quot;)</p>
</td></tr>
<tr><td><code id="M5B_+3A_niter">niter</code></td>
<td>
<p>The maximum number of iterations for the optimizing
algorithm.  Equivalent to the 'maxit' control parameter of the
optim() function.  See ?optim for more details. (default = 5000)</p>
</td></tr>
<tr><td><code id="M5B_+3A_lambda.min">lambda.min</code></td>
<td>
<p>The minimum proportional size of the first distribution.
Must be between 0 and 1. (default = 0.25)</p>
</td></tr>
<tr><td><code id="M5B_+3A_q.diff">q.diff</code></td>
<td>
<p>The minimum difference (in radians) in preferred direction
for bimodal models. Must be set between 0 and pi. (default = pi/4)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with elements (same as for function optim()):
</p>
<p>$par:  Vector with the optimized mean angle (mu1),
concentration parameter (kappa1), mean angle (mu2), concentration
parameter (kappa2), and proportional size (lambda) of the first distribution.
</p>
<p>$lik:  The negative log likelihood
</p>
<p>$counts:  A two-element integer vector giving the number of calls to
‘fn’ and ‘gr’ respectively. See ?optim() for details.
</p>
<p>$convergence:  An integer code. ‘0’ indicates successful completion
(which is always the case for ‘&quot;SANN&quot;’ and ‘&quot;Brent&quot;’). Possible error codes are:
</p>
<p>‘1’ indicates that the iteration limit ‘maxit’ had been reached.
</p>
<p>‘10’ indicates degeneracy of the Nelder-Mead simplex.
</p>
<p>‘51’ indicates a warning from the ‘&quot;L-BFGS-B&quot;’ method; see
component ‘message’ for further details.
</p>
<p>‘52’ indicates an error from the ‘&quot;L-BFGS-B&quot;’ method; see
component ‘message’ for further details.
</p>
<p>$message:  A character string giving any additional information returned
by the optimizer, or ‘NULL’.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>testdata = circular::rvonmises(100, mu = circular::circular(pi), kappa = 3)
M5B(testdata)
</code></pre>

<hr>
<h2 id='plot_circMLE'>plot_circMLE</h2><span id='topic+plot_circMLE'></span>

<h3>Description</h3>

<p>Plot the observed data and specific model from circ_mle output
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_circMLE(data, table, model, bins, shrink, col, lwd, lty)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_circMLE_+3A_data">data</code></td>
<td>
<p>A vector of class 'circular'</p>
</td></tr>
<tr><td><code id="plot_circMLE_+3A_table">table</code></td>
<td>
<p>A list containing the output from the circ_mle function</p>
</td></tr>
<tr><td><code id="plot_circMLE_+3A_model">model</code></td>
<td>
<p>The name of the model to be plotted. (default = first model of &quot;table&quot;)</p>
</td></tr>
<tr><td><code id="plot_circMLE_+3A_bins">bins</code></td>
<td>
<p>The number of bins for the circular histogram. (defualt = 18)</p>
</td></tr>
<tr><td><code id="plot_circMLE_+3A_shrink">shrink</code></td>
<td>
<p>The value by which to shrink the size of the plotted circle.
Larger numbers shrink the circle, smaller numbers expand the circle.
(default = 1.5)</p>
</td></tr>
<tr><td><code id="plot_circMLE_+3A_col">col</code></td>
<td>
<p>Vector of colors used for plotting, up to four colors can be specified.
The order is: histogram color, mean vector color, model density color, predicted
mean direction(s) color(s). (default = c(&quot;grey&quot;, &quot;red&quot;, &quot;black&quot;, &quot;black&quot;))</p>
</td></tr>
<tr><td><code id="plot_circMLE_+3A_lwd">lwd</code></td>
<td>
<p>Vector of line weights used for plotting, up to 3 weights can be
specified. The order is: mean vector weight, model density weight, predicted
mean direction(s) weight(s). (default = c(2, 2, 2))</p>
</td></tr>
<tr><td><code id="plot_circMLE_+3A_lty">lty</code></td>
<td>
<p>Vector of line weights used for plotting, up to 3 weights can be
specified. The order is: mean vector weight, model density weight, predicted
mean direction(s) weight(s). (default = c(&quot;solid&quot;, &quot;dashed&quot;, &quot;dashed&quot;))</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plot is returned to the default image device.
</p>


<h3>Note</h3>

<p>In the resulting plot, the observed vector length is equal to rho
(vector strength). However, the predicted direction(s) from the model are
drawn with vector length of 1. Also, if the model &quot;M1&quot; is selected, by
definition no predicted direction is plotted.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>testdata = circular::rvonmises(100, mu = circular::circular(pi), kappa = 3)
out = circ_mle(testdata)
plot_circMLE(testdata, out)
plot_circMLE(testdata, out, model = "M4A")
</code></pre>

<hr>
<h2 id='pycke_test'>Pycke test function</h2><span id='topic+pycke_test'></span>

<h3>Description</h3>

<p>Perform the Pycke test.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pycke_test(data, iter = 9999)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pycke_test_+3A_data">data</code></td>
<td>
<p>A vector of class 'circular', or numeric vector of 
angles measured in radians</p>
</td></tr>
<tr><td><code id="pycke_test_+3A_iter">iter</code></td>
<td>
<p>The number of bootstrap replicates to perform in order 
to estimate the p-value of the test. (default = 9999)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector of the test statistic (T) and associated p-value
</p>


<h3>Examples</h3>

<pre><code class='language-R'>testdata = circular::rvonmises(20, mu = circular::circular(pi), kappa = 3)
pycke_test(testdata, iter = 999)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
