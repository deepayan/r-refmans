<!DOCTYPE html><html><head><title>Help for package DCCA</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {DCCA}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#covF2dfa'><p>Autocovariance function of the detrended variance</p></a></li>
<li><a href='#covFdcca'><p>Autocovariance function of the detrended cross-covariance</p></a></li>
<li><a href='#EF2dfa'><p>Expected value of the detrended variance</p></a></li>
<li><a href='#EFdcca'><p>Expected value of the detrended cross-covariance</p></a></li>
<li><a href='#F2dfa'><p>Detrended Variance</p></a></li>
<li><a href='#Fdcca'><p>Detrended Cross-covariance</p></a></li>
<li><a href='#Jn'><p>Matrix J</p></a></li>
<li><a href='#Kkronm'><p>The product of Kronecker Product of some Arrays</p></a></li>
<li><a href='#Km'><p>Matrix K</p></a></li>
<li><a href='#Pm'><p>Projection Matrix P</p></a></li>
<li><a href='#Qm'><p>Projection Matrix Q</p></a></li>
<li><a href='#rhodcca'><p>Detrended Cross-correlation coefficient</p></a></li>
<li><a href='#rhoE'><p>The limit value of the detrended cross-covariance</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>0.1.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2019-12-18</td>
</tr>
<tr>
<td>Title:</td>
<td>Detrended Fluctuation and Detrended Cross-Correlation Analysis</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>checkmate</td>
</tr>
<tr>
<td>Suggests:</td>
<td>lattice</td>
</tr>
<tr>
<td>Description:</td>
<td>A collection of functions to perform Detrended Fluctuation Analysis (DFA) and Detrended Cross-Correlation Analysis (DCCA). 
    This package implements the results presented in Prass, T.S. and Pumi, G. (2019). "On the behavior of the DFA and DCCA in trend-stationary processes" &lt;<a href="https://arxiv.org/abs/1910.10589">arXiv:1910.10589</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2019-12-19 00:11:21 UTC; Taiane</td>
</tr>
<tr>
<td>Author:</td>
<td>Taiane Schaedler Prass
    <a href="https://orcid.org/0000-0003-3136-909X"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre],
  Guilherme Pumi <a href="https://orcid.org/0000-0002-6256-3170"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Taiane Schaedler Prass &lt;taianeprass@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2020-01-01 15:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='covF2dfa'>Autocovariance function of the detrended variance</h2><span id='topic+covF2dfa'></span>

<h3>Description</h3>

<p>Calculates the autocovariance of the detrended variance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>covF2dfa(m = 3, nu = 0, h = 0, overlap = TRUE, G, Cumulants = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="covF2dfa_+3A_m">m</code></td>
<td>
<p>an integer or integer valued vector indicating the size of the window for the polinomial fit. <code class="reqn">min(m)</code> must be greater or equal than <code class="reqn">nu</code> or else it will return an error.</p>
</td></tr>
<tr><td><code id="covF2dfa_+3A_nu">nu</code></td>
<td>
<p>a non-negative integer denoting the degree of the polinomial fit applied on the integrated series.</p>
</td></tr>
<tr><td><code id="covF2dfa_+3A_h">h</code></td>
<td>
<p>an integer or integer valued vector indicating the lags for which the autocovariance function is to be calculated.</p>
</td></tr>
<tr><td><code id="covF2dfa_+3A_overlap">overlap</code></td>
<td>
<p>logical: if true (the default), overlapping boxes are used for calculations. Otherwise, non-overlapping boxes are applied.</p>
</td></tr>
<tr><td><code id="covF2dfa_+3A_g">G</code></td>
<td>
<p>the autocovariance matrix for the original time series. The dimension of <code class="reqn">G</code> must be <code class="reqn">(max(m)+max(h)+1)</code> by <code class="reqn">(max(m)+max(h)+1)</code> if overlap = TRUE and <code class="reqn">(max(m)+max(h))(max(h)+1)</code> by <code class="reqn">(max(m)+max(h))(max(h)+1)</code> otherwise.</p>
</td></tr>
<tr><td><code id="covF2dfa_+3A_cumulants">Cumulants</code></td>
<td>
<p>The matrix containing the joint cumulants for lags. Dimension must be <code class="reqn">(max(m)+1)*nrow(G)</code>. If not provided, it is assumed that the cumulants are all zero.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with the autocovariance of lag <code class="reqn">h</code>, for each value of <code class="reqn">m</code> provided. This matrix is obtained from expressions (21) for <code class="reqn">h = 0</code> and (22) for <code class="reqn">h &gt; 0</code> in Prass and Pumi (2019).
</p>


<h3>Author(s)</h3>

<p>Taiane Schaedler Prass</p>


<h3>References</h3>

<p>Prass, T.S. and Pumi, G. (2019). On the behavior of the DFA and DCCA in trend-stationary
processes &lt;arXiv:1910.10589&gt;.</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
ms = seq(3,100,1)
hs = seq(0,50,1)
overlap = TRUE
nu = 0
m_max = (max(ms)+1)*(max(hs)+1) - max(ms)*max(hs)*as.integer(overlap)

theta = c(c(1,(20:1)/10), rep(0, m_max - 20))
Gamma1 = diag(m_max+1)
Gamma2 = matrix(0, ncol = m_max+1, nrow = m_max+1)
Gamma12 = matrix(0, ncol = m_max+1, nrow = m_max+1)
for(t in 1:(m_max+1)){
    for(h in 0:(m_max+1-t)){
        Gamma2[t,t+h] = sum(theta[1:(length(theta)-h)]*theta[(1+h):length(theta)])
        Gamma2[t+h,t] = Gamma2[t,t+h]
        Gamma12[t,t+h] = theta[h+1]
    }
}

covdfa1 = covF2dfa(m = ms, nu = 0, h = hs,
                   overlap = TRUE, G = Gamma1, Cumulants = NULL)

covdfa2 = covF2dfa(m = ms, nu = 0, h = hs,
                  overlap = TRUE, G = Gamma2, Cumulants = NULL)

cr = rainbow(100)
plot(ms, covdfa1[,1], type = "l", ylim = c(0,20),
    xlab = "m", ylab = expression(gamma[DFA](h)), col = cr[1])
for(i in 2:ncol(covdfa1)){
  points(ms, covdfa1[,i],  type = "l", col = cr[i])
}

lattice::wireframe(covdfa1, drape = TRUE,
    col.regions = rev(rainbow(150))[50:150],
    zlab = expression(gamma[DFA]), xlab = "m", ylab = "h")

## End(Not run)
</code></pre>

<hr>
<h2 id='covFdcca'>Autocovariance function of the detrended cross-covariance</h2><span id='topic+covFdcca'></span>

<h3>Description</h3>

<p>Calculates the autocovariance of the detrended cross-covariance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>covFdcca(m = 3, nu = 0, h = 0, overlap = TRUE, G1, G2, G12, Cumulants = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="covFdcca_+3A_m">m</code></td>
<td>
<p>an integer or integer valued vector indicating the size of the window for the polinomial fit. <code class="reqn">min(m)</code> must be greater or equal than <code class="reqn">nu</code> or else it will return an error.</p>
</td></tr>
<tr><td><code id="covFdcca_+3A_nu">nu</code></td>
<td>
<p>a non-negative integer denoting the degree of the polinomial fit applied on the integrated series.</p>
</td></tr>
<tr><td><code id="covFdcca_+3A_h">h</code></td>
<td>
<p>an integer or integer valued vector indicating the lags for which the autocovariance function is to be calculated. Negative values are not allowed.</p>
</td></tr>
<tr><td><code id="covFdcca_+3A_overlap">overlap</code></td>
<td>
<p>logical: if true (the default), overlapping boxes are used for calculations. Otherwise, non-overlapping boxes are applied.</p>
</td></tr>
<tr><td><code id="covFdcca_+3A_g1">G1</code>, <code id="covFdcca_+3A_g2">G2</code></td>
<td>
<p>the autocovariance matrices for the original time series. The dimension of <code class="reqn">G1</code> and <code class="reqn">G2</code> must be compatible with the highest values in  vectors <code class="reqn">m</code> and <code class="reqn">h</code>. More specifically, the dimension of <code class="reqn">G1</code> and <code class="reqn">G2</code> is <code class="reqn">(max(m)+max(h)+1)</code> by <code class="reqn">(max(m)+max(h)+1)</code> if overlap = TRUE and <code class="reqn">dim(G1) = dim(G2) = (max(m)+max(h))(max(h)+1)</code> by <code class="reqn">(max(m)+max(h))(max(h)+1)</code> otherwise.  </p>
</td></tr>
<tr><td><code id="covFdcca_+3A_g12">G12</code></td>
<td>
<p>the cross-covariance matrix for the original time series. The dimension of <code class="reqn">G12</code>  must be compatible with the highest values in  vectors <code class="reqn">m</code> and <code class="reqn">h</code>. If overlap = TRUE, <code class="reqn">dim(G12) = [(max(m)+1)*(max(h)+1) - max(m)*max(h)]</code> by <code class="reqn">[(max(m)+1)*(max(h)+1) - max(m)*max(h)]</code> and <code class="reqn">dim(G12) = [(max(m)+1)*(max(h)+1)]</code> by <code class="reqn">[max(m)+1)*(max(h)+1)]</code>, otherwise</p>
</td></tr>
<tr><td><code id="covFdcca_+3A_cumulants">Cumulants</code></td>
<td>
<p>The matrix of cumulants. If not provided, it is assumed that the cumulants are all zero.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of dimension <code class="reqn">lenght(h)</code> by <code class="reqn">length(m)</code> with the autocovariance of lag <code class="reqn">h</code> (rows), for each value of <code class="reqn">m</code> (columns) provided. This matrix is obtained from expressions (24) for <code class="reqn">h = 0</code> and (25) for <code class="reqn">h &gt; 0</code> in Prass and Pumi (2019).
</p>


<h3>Author(s)</h3>

<p>Taiane Schaedler Prass</p>


<h3>References</h3>

<p>Prass, T.S. and Pumi, G. (2019). On the behavior of the DFA and DCCA in trend-stationary
processes &lt;arXiv:1910.10589&gt;.</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
ms = seq(3,100,1)
hs = seq(0,50,1)
overlap = TRUE
nu = 0
m_max = (max(ms)+1)*(max(hs)+1) - max(ms)*max(hs)*as.integer(overlap)

theta = c(c(1,(20:1)/10), rep(0, m_max - 20))
Gamma1 = diag(m_max+1)
Gamma2 = matrix(0, ncol = m_max+1, nrow = m_max+1)
Gamma12 = matrix(0, ncol = m_max+1, nrow = m_max+1)
for(t in 1:(m_max+1)){
    for(h in 0:(m_max+1-t)){
        Gamma2[t,t+h] = sum(theta[1:(length(theta)-h)]*theta[(1+h):length(theta)])
        Gamma2[t+h,t] = Gamma2[t,t+h]
        Gamma12[t,t+h] = theta[h+1]
    }
}

covdcca = covFdcca(m = ms, nu = 0, h = hs,
                   G1 = Gamma1, G2 = Gamma2, G12 = Gamma12)
                   
## End(Not run)
</code></pre>

<hr>
<h2 id='EF2dfa'>Expected value of the detrended variance</h2><span id='topic+EF2dfa'></span>

<h3>Description</h3>

<p>Calculates the expected value of the detrended variance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EF2dfa(m = 3, nu = 0, G, K = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="EF2dfa_+3A_m">m</code></td>
<td>
<p>an integer or integer valued vector indicating the size of the window for the polinomial fit. <code class="reqn">min(m)</code> must be greater or equal than <code class="reqn">nu</code> or else it will return an error.</p>
</td></tr>
<tr><td><code id="EF2dfa_+3A_nu">nu</code></td>
<td>
<p>a non-negative integer denoting the degree of the polinomial fit applied on the integrated series.</p>
</td></tr>
<tr><td><code id="EF2dfa_+3A_g">G</code></td>
<td>
<p>the autocovariance matrix for the original time series. The dimension of <code class="reqn">G</code> must be <code class="reqn">(max(m)+1)</code> by <code class="reqn">(max(m)+1)</code>.</p>
</td></tr>
<tr><td><code id="EF2dfa_+3A_k">K</code></td>
<td>
<p>optional: the matrix <code class="reqn">K</code>. If this matrix is provided and <code class="reqn">m</code> is an integer, then <code class="reqn">nu</code> is ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of size <code class="reqn">length(m)</code> containing the expected values of the detrended variance corresponding to the values of <code class="reqn">m</code> provided. This is expression (20) in Prass and Pumi (2019).
</p>


<h3>Author(s)</h3>

<p>Taiane Schaedler Prass</p>


<h3>References</h3>

<p>Prass, T.S. and Pumi, G. (2019). On the behavior of the DFA and DCCA in trend-stationary
processes &lt;arXiv:1910.10589&gt;.</p>


<h3>Examples</h3>

<pre><code class='language-R'>m = 3
K = Km(m = m, nu = 0)
G = diag(m+1)
EF2dfa(G = G, K = K)
# same as
EF2dfa(m = 3, nu = 0, G = G)

# An AR(1) example
phi = 0.4
n = 500
burn.in = 50
eps = rnorm(n + burn.in)
z.temp = numeric(n + burn.in)
z.temp[1] = eps[1]
for(i in 2:(n + burn.in)){
  z.temp[i] = phi*z.temp[i-1] + eps[i]
}
z = z.temp[(burn.in + 1):(n + burn.in)]

F2.dfa = F2dfa(z, m = 3:100, nu = 0, overlap = TRUE)
plot(3:100, F2.dfa, type="o", xlab = "m")

</code></pre>

<hr>
<h2 id='EFdcca'>Expected value of the detrended cross-covariance</h2><span id='topic+EFdcca'></span>

<h3>Description</h3>

<p>Calculates the expected value of the detrended cross-covariance given a cross-covariance matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EFdcca(m = 3, nu = 0, G, K = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="EFdcca_+3A_m">m</code></td>
<td>
<p>an integer or integer valued vector indicating the size of the window for the polinomial fit. <code class="reqn">min(m)</code> must be greater or equal than <code class="reqn">nu</code> or else it will result in an error.</p>
</td></tr>
<tr><td><code id="EFdcca_+3A_nu">nu</code></td>
<td>
<p>a non-negative integer denoting the degree of the polinomial fit applied on the integrated series.</p>
</td></tr>
<tr><td><code id="EFdcca_+3A_g">G</code></td>
<td>
<p>the cross-covariance matrix for the original time series. The dimension of <code class="reqn">G</code> must be <code class="reqn">(max(m)+1)</code> by <code class="reqn">(max(m)+1)</code>.</p>
</td></tr>
<tr><td><code id="EFdcca_+3A_k">K</code></td>
<td>
<p>optional: the matrix <code class="reqn">K</code>. If this matrix and <code class="reqn">m</code> are provided, then <code class="reqn">nu</code> is ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a size <code class="reqn">length(m)</code> vector containing the expected values of the detrended cross-covariance corresponding to the values of <code class="reqn">m</code> provided. This is expression (23) in Prass and Pumi (2019).
</p>


<h3>Author(s)</h3>

<p>Taiane Schaedler Prass</p>


<h3>References</h3>

<p>Prass, T.S. and Pumi, G. (2019). On the behavior of the DFA and DCCA in trend-stationary
processes &lt;arXiv:1910.10589&gt;.</p>


<h3>Examples</h3>

<pre><code class='language-R'>m = 3
K = Km(m = m, nu = 0)
G = diag(m+1)
EFdcca(G = G, K = K)
# same as
EFdcca(m = 3, nu = 0, G = G)


</code></pre>

<hr>
<h2 id='F2dfa'>Detrended Variance</h2><span id='topic+F2dfa'></span>

<h3>Description</h3>

<p>Calculates the detrended variance based on a given time series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>F2dfa(y, m = 3, nu = 0, overlap = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="F2dfa_+3A_y">y</code></td>
<td>
<p>vector corresponding to the time series data.</p>
</td></tr>
<tr><td><code id="F2dfa_+3A_m">m</code></td>
<td>
<p>an integer or integer valued vector indicating the size (or sizes) of the window for the polinomial fit. <code class="reqn">min(m)</code> must be greater or equal than <code class="reqn">nu</code> or else it will return an error.</p>
</td></tr>
<tr><td><code id="F2dfa_+3A_nu">nu</code></td>
<td>
<p>a non-negative integer denoting the degree of the polinomial fit applied on the integrated series.</p>
</td></tr>
<tr><td><code id="F2dfa_+3A_overlap">overlap</code></td>
<td>
<p>logical: if true (the default), uses overlapping windows. Otherwise, non-overlapping boxes are applied.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of size <code class="reqn">length(m)</code> containing the detrended variance considering windows of size <code class="reqn">m+1</code>, for each <code class="reqn">m</code> supplied.
</p>


<h3>Author(s)</h3>

<p>Taiane Schaedler Prass</p>


<h3>References</h3>

<p>Prass, T.S. and Pumi, G. (2019). On the behavior of the DFA and DCCA in trend-stationary
processes &lt;arXiv:1910.10589&gt;.</p>


<h3>Examples</h3>

<pre><code class='language-R'># Simple usage
y = rnorm(100)
F2.dfa = F2dfa(y, m = 3, nu = 0, overlap = TRUE)
F2.dfa

vF2.dfa = F2dfa(y, m = 3:5, nu = 0, overlap = TRUE)
vF2.dfa


###################################################
# AR(1) example showing how the DFA varies with phi

phi = (1:8)/10
n = 300
z = matrix(nrow = n, ncol = length(phi))
for(i in 1:length(phi)){
  z[,i] = arima.sim(model = list(ar = phi[i]), n)
}

ms = 3:50
F2.dfa = matrix(ncol = length(phi), nrow = length(ms))

for(j in 1:length(phi)){
  F2.dfa[,j] = F2dfa(z[,j], m = ms  , nu = 0, overlap = TRUE)
}

cr = rainbow(length(phi))
plot(ms, F2.dfa[,1], type = "o", xlab = "m", col = cr[1],
    ylim = c(0,max(F2.dfa)), ylab = "F2.dfa")
for(j in 2:length(phi)){
  points(ms, F2.dfa[,j], type = "o", col = cr[j])
}
legend("topleft", lty = 1, legend = phi, col = cr, bty = "n", title = expression(phi), pch=1)


##############################################################################
# An MA(2) example showcasing why overlapping windows are usually advantageous
n = 300
ms = 3:50
theta = c(0.4,0.5)

# Calculating the expected value of the DFA in this scenario
m_max = max(ms)
vtheta = c(c(1,theta, rep(0, m_max - length(theta))))
G = matrix(0, ncol = m_max+1, nrow = m_max+1)
for(t in 1:(m_max+1)){
  for(h in 0:(m_max+1-t)){
    G[t,t+h] = sum(vtheta[1:(length(vtheta)-h)]*vtheta[(1+h):length(vtheta)])
    G[t+h,t] = G[t,t+h]
  }
}

EF2.dfa = EF2dfa(m = ms, nu = 0, G = G)

z = arima.sim(model = list(ma = theta), n)

ms = 3:50
OF2.dfa = F2dfa(z, m = ms, nu = 0, overlap = TRUE)
NOF2.dfa = F2dfa(z, m = ms, nu = 0, overlap = FALSE)

plot(ms, OF2.dfa, type = "o", xlab = "m", col = "blue",
    ylim = c(0,max(OF2.dfa,NOF2.dfa,EF2.dfa)), ylab = "F2.dfa")
points(ms, NOF2.dfa, type = "o", col = "darkgreen")
points(ms, EF2.dfa, type = "o", col = "red")
legend("bottomright", legend = c("overlapping","non-overlapping","expected"),
            col = c("blue", "darkgreen","red"), lty= 1, bty = "n", pch=1)

</code></pre>

<hr>
<h2 id='Fdcca'>Detrended Cross-covariance</h2><span id='topic+Fdcca'></span>

<h3>Description</h3>

<p>Calculates the detrended cross-covariance between two time series <code class="reqn">y1</code> and <code class="reqn">y2</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Fdcca(y1, y2, m = 3, nu = 0, overlap = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Fdcca_+3A_y1">y1</code>, <code id="Fdcca_+3A_y2">y2</code></td>
<td>
<p>vectors corresponding to the time series data. If <code class="reqn">length(y1)</code> and <code class="reqn">length(y2)</code> differ, the longer time series is coerced to match the lenght of the shorter.</p>
</td></tr>
<tr><td><code id="Fdcca_+3A_m">m</code></td>
<td>
<p>an integer or integer valued vector indicating the size (or sizes) of the window for the polinomial fit. <code class="reqn">min(m)</code> must be greater or equal than <code class="reqn">nu</code> or else it will return an error.</p>
</td></tr>
<tr><td><code id="Fdcca_+3A_nu">nu</code></td>
<td>
<p>a non-negative integer denoting the degree of the polinomial fit applied on the integrated series.</p>
</td></tr>
<tr><td><code id="Fdcca_+3A_overlap">overlap</code></td>
<td>
<p>logical: if true (the default), uses overlapping windows. Otherwise, non-overlapping boxes are applied.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of size <code class="reqn">length(m)</code> containing the detrended cross-covariance considering windows of size <code class="reqn">m+1</code>, for each <code class="reqn">m</code> supplied.
</p>


<h3>Author(s)</h3>

<p>Taiane Schaedler Prass</p>


<h3>References</h3>

<p>Prass, T.S. and Pumi, G. (2019). On the behavior of the DFA and DCCA in trend-stationary
processes &lt;arXiv:1910.10589&gt;.</p>


<h3>Examples</h3>

<pre><code class='language-R'># Simple usage
y1 = rnorm(100)
y2 = rnorm(100)
F.dcca = Fdcca(y1, y2, m = 3, nu = 0, overlap = TRUE)
F.dcca

# A simple example where y1 and y2 are independent.

ms = 3:50
F.dcca1 = Fdcca(y1, y2, m = ms, nu = 0, overlap = TRUE)
F.dcca2 = Fdcca(y1, y2, m = ms, nu = 0, overlap = FALSE)

plot(ms, F.dcca1, type = "o", xlab = "m", col = "blue",
     ylim = c(min(F.dcca1,F.dcca2),max(F.dcca1,F.dcca2)),
     ylab = expression(F[DCCA]))
points(ms, F.dcca2, type = "o", col = "red")
legend("bottomright", legend = c("overlapping","non-overlapping"),
       col = c("blue", "red"), lty= 1, bty = "n", pch=1)


# A more elaborated example where y1 and y2 display cross-correlation for non-null lags.
# This example also showcases why overlapping windows are usually advantageous.
# The data generating process is the following:
# y1 is i.i.d. Gaussian while y2 is an MA(2) generated from y1.

n = 500
ms = 3:50
theta = c(0.4,0.5)

# Calculating the expected value of the DCCA in this scenario
m_max = max(ms)
vtheta = c(1,theta, rep(0, m_max - length(theta)))
G12 = matrix(0, ncol = m_max+1, nrow = m_max+1)
for(t in 1:(m_max+1)){
  for(h in 0:(m_max+1-t)){
    G12[t,t+h] = vtheta[h+1]
  }
}

EF.dcca = EFdcca(m = ms, nu = 0, G = G12)

# generating the series and calculating the DCCA
burn.in = 100
eps = rnorm(burn.in)

y1 = rnorm(n)
y2 = arima.sim(model = list(ma = theta), n, n.start = burn.in, innov = y1, start.innov = eps)

ms = 3:50
OF.dcca = Fdcca(y1, y2, m = ms, nu = 0, overlap = TRUE)
NOF.dcca = Fdcca(y1, y2, m = ms, nu = 0, overlap = FALSE)

plot(ms, OF.dcca, type = "o", xlab = "m", col = "blue",
     ylim = c(min(NOF.dcca,OF.dcca,EF.dcca),max(NOF.dcca,OF.dcca,EF.dcca)),
     ylab = expression(F[DCCA]))
points(ms, NOF.dcca, type = "o", col = "darkgreen")
points(ms, EF.dcca, type = "o", col = "red")
legend("bottomright", legend = c("overlapping","non-overlapping","expected"),
       col = c("blue", "darkgreen","red"), lty= 1, bty = "n", pch=1)

</code></pre>

<hr>
<h2 id='Jn'>Matrix J</h2><span id='topic+Jn'></span>

<h3>Description</h3>

<p>Creates a <code class="reqn">n</code> by <code class="reqn">n</code> lower triangular matrix with all non-zero entries equal to one.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Jn(n = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Jn_+3A_n">n</code></td>
<td>
<p>number of rows and columns in the J matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an <code class="reqn">n</code> by <code class="reqn">n</code> lower triangular matrix with all non-zero entries equal to one. This is an auxiliary function.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>J = Jn(n = 3)
J
</code></pre>

<hr>
<h2 id='Kkronm'>The product of Kronecker Product of some Arrays</h2><span id='topic+Kkronm'></span>

<h3>Description</h3>

<p>This is an auxiliary function and requires some context to be used adequadely. It computes equation (19) in Prass and Pumi (2019), returning a square matrix defined by </p>
<p style="text-align: center;"><code class="reqn">K* = (Jm \%x\%  J*)'(Q \%x\%  Q)(Jm \%x\%  J*)</code>
</p>
<p> where:
</p>

<ul>
<li> <p><code class="reqn">J</code> is an <code class="reqn">(m+1)*(h+1) - m*h*s</code> by <code class="reqn">(m+1)*(h+1) - m*h*s</code> lower triangular matrix with all non-zero entries equal to one,  with <code class="reqn">s = 1</code> if overlap = TRUE and <code class="reqn">s = 0</code>, otherwise;
</p>
</li>
<li> <p><code class="reqn">Jm</code> corresponds to the first <code class="reqn">m+1</code> rows and columns of <code class="reqn">J</code>;
</p>
</li>
<li> <p><code class="reqn">J*</code> corresponds to the last <code class="reqn">m+1</code> rows of <code class="reqn">J</code>;
</p>
</li>
<li> <p><code class="reqn">Q = I-P</code>, where <code class="reqn">P</code> is the <code class="reqn">m+1</code> by <code class="reqn">m+1</code> projection matrix into the subspace generated by degree <code class="reqn">nu+1</code> polynomials.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>Kkronm(m = 3, nu = 0, h = 0, overlap = TRUE, K = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Kkronm_+3A_m">m</code></td>
<td>
<p>a positive integer indicating the size of the window for the polinomial fit.</p>
</td></tr>
<tr><td><code id="Kkronm_+3A_nu">nu</code></td>
<td>
<p>a non-negative integer denoting the degree of the polinomial fit applied on the integrated series.</p>
</td></tr>
<tr><td><code id="Kkronm_+3A_h">h</code></td>
<td>
<p>an integer indicating the lag.</p>
</td></tr>
<tr><td><code id="Kkronm_+3A_overlap">overlap</code></td>
<td>
<p>logical: if true (the default), overlapping boxes are used for calculations. Otherwise, non-overlapping boxes are applied.</p>
</td></tr>
<tr><td><code id="Kkronm_+3A_k">K</code></td>
<td>
<p>optional: the matrix defined by <code class="reqn">K = J'QJ</code>. This is used to  calculate <code class="reqn">K* = (Jm \%x\%  J*)'(Q \%x\%  Q)(Jm \%x\%  J*)</code>. For details see (19) in Prass and Pumi (2019). If this matrix is provided <code class="reqn">mu</code> is ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an <code class="reqn">(m+1)[(m+1)*(h+1) - m*h*s]</code> by <code class="reqn">(m+1)[(m+1)*(h+1) - m*h*s]</code> matrix, where <code class="reqn">s = 1</code> if overlap = TRUE and <code class="reqn">s = 0</code>, otherwise. This matrix corresponds to equation (19) in Prass and Pumi (2019).
</p>


<h3>Author(s)</h3>

<p>Taiane Schaedler Prass</p>


<h3>References</h3>

<p>Prass, T.S. and Pumi, G. (2019). On the behavior of the DFA and DCCA in trend-stationary
processes &lt;arXiv:1910.10589&gt;.</p>


<h3>See Also</h3>

<p><code><a href="#topic+Jn">Jn</a></code> which creates the matrix <code class="reqn">J</code>, <code><a href="#topic+Qm">Qm</a></code> which creates <code class="reqn">Q</code> and <code><a href="#topic+Km">Km</a></code> which creates <code class="reqn">K</code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>m = 3
h = 1
J = Jn(n = m+1+h)
Q = Qm(m = m, nu = 0)

# using K
K = Km(J = J[1:(m+1),1:(m+1)], Q = Q)
Kkron0 = Kkronm(K = K, h = h)

# using m and nu
Kkron = Kkronm(m = m, nu = 0, h = h)

# using  kronecker product from R
K = Km(J = J[1:(m+1),1:(m+1)], Q = Q)
Kh = rbind(matrix(0, nrow = h, ncol = m+1+h),
           cbind(matrix(0, nrow = m+1, ncol = h), K))
KkronR = K %x% Kh

# using  the definition K* = (Jm %x%  J)'(Q %x%  Q)(Jm %x%  J)
J_m = J[1:(m+1),1:(m+1)]
J_h = J[(h+1):(m+1+h),1:(m+1+h)]
KkronD = t(J_m %x%  J_h)%*%(Q %x%  Q)%*%(J_m %x%  J_h)


# comparing the results
sum(abs(Kkron0 - Kkron))
sum(abs(Kkron0 - KkronR))
sum(abs(Kkron0 - KkronD))  # difference due to rounding error

## Not run: 
# Function Kkronm is computationaly faster than a pure implementation in R:

m = 100
h = 1
J = Jn(n = m+1)
Q = Qm(m = m, nu = 0)

# using Kkronm
t1 = proc.time()
Kkron = Kkronm(m = m, nu = 0, h = 1)
t2 = proc.time()
# elapsed time:
t2-t1

# Pure R implementation:
K = Km(J = J, Q = Q)
Kh = rbind(matrix(0, nrow = h, ncol = m+1+h),
           cbind(matrix(0, nrow = m+1, ncol = h), K))
t3 = proc.time()
KkronR = K %x% Kh
t4 = proc.time()
# elapsed time
t4-t3


## End(Not run)
</code></pre>

<hr>
<h2 id='Km'>Matrix K</h2><span id='topic+Km'></span>

<h3>Description</h3>

<p>This is an auxiliary function which computes expression (18) in Prass and Pumi (2019). It creates an <code class="reqn">m+1</code> by <code class="reqn">m+1</code>  matrix defined by <code class="reqn">K = J'QJ</code> where <code class="reqn">J</code> is a <code class="reqn">m+1</code> by <code class="reqn">m+1</code> lower triangular matrix with all non-zero entries equal to one and <code class="reqn">Q</code> is a <code class="reqn">m+1</code> by <code class="reqn">m+1</code> given by <code class="reqn">Q = I - P</code> where <code class="reqn">P</code> is the projection matrix into the subspace generated by degree <code class="reqn">nu+1</code> polynomials and <code class="reqn">I</code> is the <code class="reqn">m+1</code> by <code class="reqn">m+1</code>  identity matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Km(m = 3, nu = 0, J = NULL, Q = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Km_+3A_m">m</code></td>
<td>
<p>a positive integer greater or equal than <code class="reqn">nu</code> indicating the size of the window for the polinomial fit.</p>
</td></tr>
<tr><td><code id="Km_+3A_nu">nu</code></td>
<td>
<p>a non-negative integer denoting the degree of the polinomial fit applied on the integrated series.</p>
</td></tr>
<tr><td><code id="Km_+3A_j">J</code>, <code id="Km_+3A_q">Q</code></td>
<td>
<p>optional: the matrices such that <code class="reqn">K = J'QJ</code>. If both matrices are provided, <code class="reqn">m</code> and <code class="reqn">nu</code> are ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an <code class="reqn">m+1</code> by <code class="reqn">m+1</code> matrix corresponding to expression (18) in Prass and Pumi (2019).
</p>


<h3>Author(s)</h3>

<p>Taiane Schaedler Prass</p>


<h3>References</h3>

<p>Prass, T.S. and Pumi, G. (2019). On the behavior of the DFA and DCCA in trend-stationary
processes &lt;arXiv:1910.10589&gt;.</p>


<h3>See Also</h3>

<p><code><a href="#topic+Jn">Jn</a></code> which creates the matrix <code class="reqn">J</code>, <code><a href="#topic+Qm">Qm</a></code> which creates <code class="reqn">Q</code> and <code><a href="#topic+Pm">Pm</a></code> which creates <code class="reqn">P</code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>K = Km(m = 3, nu = 0)
K
# same as
m = 3
J = Jn(n = m+1)
Q = Qm(m = m, nu = 0)
K = Km(J = J, Q = Q)
K

</code></pre>

<hr>
<h2 id='Pm'>Projection Matrix P</h2><span id='topic+Pm'></span>

<h3>Description</h3>

<p>Creates the <code class="reqn">m+1</code> by <code class="reqn">m+1</code> projection matrix defined by <code class="reqn">P = D(D'D)^{-1}D'</code> where <code class="reqn">D</code> is the design matrix associated to a polynomial regression of degree nu + 1.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Pm(m = 2, nu = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Pm_+3A_nu">nu</code></td>
<td>
<p>the degree of the polinomial fit.</p>
</td></tr>
<tr><td><code id="Pm_+3A_m">m</code></td>
<td>
<p>a positive integer satisfying <code class="reqn">m &gt;= nu</code> indicating the size of the window for the polinomial fit.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>To perform matrix inversion, the code makes use of the routine DGETRI in LAPACK, which applies an LU decomposition approach to obtain the inverse matrix. See the LAPACK documentation available at <a href="http://www.netlib.org/lapack">http://www.netlib.org/lapack</a>.
</p>


<h3>Value</h3>

<p>an <code class="reqn">m+1</code> by <code class="reqn">m+1</code> matrix.
</p>


<h3>Author(s)</h3>

<p>Taiane Schaedler Prass</p>


<h3>Examples</h3>

<pre><code class='language-R'>P = Pm(m = 5, nu = 0)
P

n = 10
t = 1:n
D = cbind(rep(1,n),t,t^2)

# Calculating in R
PR = D%*%solve(t(D)%*%D)%*%t(D)
# Using the provided function
P = Pm(m = n-1, nu = 1)

# Difference:
sum(abs(P-PR))

</code></pre>

<hr>
<h2 id='Qm'>Projection Matrix Q</h2><span id='topic+Qm'></span>

<h3>Description</h3>

<p>Creates the <code class="reqn">m+1</code> by <code class="reqn">m+1</code> projection matrix defined by <code class="reqn">Q = I-P</code> where <code class="reqn">I</code> is the the <code class="reqn">m+1</code> by <code class="reqn">m+1</code> identity matrix and <code class="reqn">P</code> is the <code class="reqn">m+1</code> by <code class="reqn">m+1</code> projection matrix into the space generated by polynomials of degree <code class="reqn">nu + 1</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Qm(m = 2, nu = 0, P = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Qm_+3A_nu">nu</code></td>
<td>
<p>the degree of the polinomial fit.</p>
</td></tr>
<tr><td><code id="Qm_+3A_m">m</code></td>
<td>
<p>a positive integer satisfying <code class="reqn">m &gt;= nu</code> indicating the size of the window for the polinomial fit.</p>
</td></tr>
<tr><td><code id="Qm_+3A_p">P</code></td>
<td>
<p>optional: the projection matrix such that <code class="reqn">Q = I - P</code> (see function <code><a href="#topic+Pm">Pm</a></code>). If this matrix is provided <code class="reqn">m</code> and <code class="reqn">nu</code> are ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an <code class="reqn">m+1</code> by <code class="reqn">m+1</code> matrix.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Pm">Pm</a></code> which generates the projection matrix <code class="reqn">P</code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>Q = Qm(m = 3, nu = 0)
Q
# same as
P = Pm(m = 3, nu = 0)
Q = Qm(P = P)
Q
</code></pre>

<hr>
<h2 id='rhodcca'>Detrended Cross-correlation coefficient</h2><span id='topic+rhodcca'></span>

<h3>Description</h3>

<p>Calculates the detrended cross-correlation coefficient for two time series <code class="reqn">y1</code> and <code class="reqn">y2</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rhodcca(y1, y2, m = 3, nu = 0, overlap = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rhodcca_+3A_y1">y1</code>, <code id="rhodcca_+3A_y2">y2</code></td>
<td>
<p>vectors corresponding to the time series data. If <code class="reqn">length(y1)</code> and <code class="reqn">length(y2)</code> differ, the longer time series is coerced to match the lenght of the shorter.</p>
</td></tr>
<tr><td><code id="rhodcca_+3A_m">m</code></td>
<td>
<p>an integer value or a vector of integer values indicating the size of the window for the polinomial fit. <code class="reqn">min(m)</code> must be greater or equal than <code class="reqn">nu</code> or else it will return an error.</p>
</td></tr>
<tr><td><code id="rhodcca_+3A_nu">nu</code></td>
<td>
<p>the degree of the polynomial fit</p>
</td></tr>
<tr><td><code id="rhodcca_+3A_overlap">overlap</code></td>
<td>
<p>logical: if true (the default), uses overlapping windows. Otherwise, non-overlapping boxes are applied.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the following elements, calculated considering windows of size <code class="reqn">m+1</code>, for each <code class="reqn">m</code> supplied:
</p>
<table>
<tr><td><code>F2dfa1</code>, <code>F2dfa2</code></td>
<td>
<p>The detrended variances for <code class="reqn">y1</code> and <code class="reqn">y2</code>, respectively.</p>
</td></tr>
<tr><td><code>Fdcca</code></td>
<td>
<p>The detrended cross-covariance.</p>
</td></tr>
<tr><td><code>rhodcca</code></td>
<td>
<p>The detrended cross-correlation coefficient.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>The time series <code class="reqn">y1</code> and <code class="reqn">y2</code> must have the same sample size.</p>


<h3>Author(s)</h3>

<p>Taiane Schaedler Prass</p>


<h3>References</h3>

<p>Prass, T.S. and Pumi, G. (2019). On the behavior of the DFA and DCCA in trend-stationary
processes &lt;arXiv:1910.10589&gt;.</p>


<h3>See Also</h3>

<p><code><a href="#topic+F2dfa">F2dfa</a></code> which calculated the DFA and <code><a href="#topic+Fdcca">Fdcca</a></code> which calculated the DCCA of two given time series.</p>


<h3>Examples</h3>

<pre><code class='language-R'>y1 = rnorm(100)
y2 = rnorm(100)
rho.dccam1 = rhodcca(y1, y2, m = 3, nu = 0, overlap = TRUE)
rho.dccam1

rho.dccam2 = rhodcca(y1, y2, m = c(3,6,8), nu = 0, overlap = TRUE)
rho.dccam2
</code></pre>

<hr>
<h2 id='rhoE'>The limit value of the detrended cross-covariance</h2><span id='topic+rhoE'></span>

<h3>Description</h3>

<p>Calculates the theoretical counterpart of the cross-correlation coefficient. This is expression (11) in Prass and Pumi (2019). For trend-stationary processes under mild assumptions, this is equivalent to the limit of the detrended cross correlation coefficient calculated with window of size <code class="reqn">m+1</code> as <code class="reqn">m</code> tends to infinity (see theorem 3.2 in Prass and Pumi, 2019).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rhoE(m = 3, nu = 0, G1, G2, G12, K = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rhoE_+3A_m">m</code></td>
<td>
<p>an integer or integer valued vector indicating the size (or sizes) of the window for the polinomial fit. <code class="reqn">min(m)</code> must be greater or equal than <code class="reqn">nu</code> or else it will return an error.</p>
</td></tr>
<tr><td><code id="rhoE_+3A_nu">nu</code></td>
<td>
<p>a non-negative integer denoting the degree of the polinomial fit applied on the integrated series.</p>
</td></tr>
<tr><td><code id="rhoE_+3A_g1">G1</code>, <code id="rhoE_+3A_g2">G2</code></td>
<td>
<p>the autocovariance matrices for the original time series. Both are <code class="reqn">max(m)+1</code> by <code class="reqn">max(m)+1</code> matrices.  </p>
</td></tr>
<tr><td><code id="rhoE_+3A_g12">G12</code></td>
<td>
<p>the cross-covariance matrix for the original time series. The dimension of <code class="reqn">G12</code> must be <code class="reqn">max(m)+1)</code> by <code class="reqn">max(m)+1)</code>.</p>
</td></tr>
<tr><td><code id="rhoE_+3A_k">K</code></td>
<td>
<p>optional: the matrix <code class="reqn">K</code>. See the details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The optional argument <code class="reqn">K</code> is an <code class="reqn">m+1</code> by <code class="reqn">m+1</code>  matrix defined by <code class="reqn">K = J'QJ</code>, where <code class="reqn">J</code> is a <code class="reqn">m+1</code> by <code class="reqn">m+1</code> lower triangular matrix with all non-zero entries equal to one and <code class="reqn">Q</code> is a <code class="reqn">m+1</code> by <code class="reqn">m+1</code> given by <code class="reqn">Q = I - P</code> where <code class="reqn">P</code> is the projection matrix into the subspace generated by degree <code class="reqn">nu+1</code> polynomials and <code class="reqn">I</code> is the <code class="reqn">m+1</code> by <code class="reqn">m+1</code>  identity matrix. <code class="reqn">K</code> is equivalent to expression (18) in Prass and Pumi (2019).
If this matrix is provided and <code class="reqn">m</code> is an integer, then <code class="reqn">nu</code> are ignored.
</p>


<h3>Value</h3>

<p>A list containing the following elements, calculated  considering windows of size <code class="reqn">m+1</code>, for each <code class="reqn">m</code> supplied:
</p>
<table>
<tr><td><code>EF2dfa1</code>, <code>EF2dfa2</code></td>
<td>
<p>the expected values of the detrended variances.</p>
</td></tr>
<tr><td><code>EFdcca</code></td>
<td>
<p>the expected value of the detrended cross-covariance.</p>
</td></tr>
<tr><td><code>rhoE</code></td>
<td>
<p>the vector with the theoretical counterpart of the cross-correlation coefficient.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Taiane Schaedler Prass</p>


<h3>References</h3>

<p>Prass, T.S. and Pumi, G. (2019). On the behavior of the DFA and DCCA in trend-stationary
processes &lt;arXiv:1910.10589&gt;.</p>


<h3>See Also</h3>

<p><code><a href="#topic+Km">Km</a></code> which creates the matrix <code class="reqn">K</code>, <code><a href="#topic+Jn">Jn</a></code> which creates the matrix <code class="reqn">J</code>, <code><a href="#topic+Qm">Qm</a></code> which creates <code class="reqn">Q</code> and <code><a href="#topic+Pm">Pm</a></code> which creates <code class="reqn">P</code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>m = 3
K = Km(m = m, nu = 0)
G1 = G2 =  diag(m+1)
G12 = matrix(0,ncol = m+1, nrow = m+1)
rhoE(G1 = G1, G2 = G2, G12 = G12, K = K)
# same as
rhoE(m = 3, nu = 0, G1 = G1, G2 = G2, G12 = G12)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
