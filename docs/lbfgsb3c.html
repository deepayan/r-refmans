<!DOCTYPE html><html lang="en"><head><title>Help for package lbfgsb3c</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {lbfgsb3c}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#.lbfgsb3cPtr'><p>Get the lbfgsb3c pointer</p></a></li>
<li><a href='#lbfgsb3c'><p>Interfacing wrapper for the Nocedal - Morales LBFGSB3 (Fortran) limited memory BFGS solver.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Limited Memory BFGS Minimizer with Bounds on Parameters with
optim() 'C' Interface</td>
</tr>
<tr>
<td>Version:</td>
<td>2024-3.5</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Matthew L Fidler &lt;matthew.fidler@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Interfacing to Nocedal et al. L-BFGS-B.3.0
        (See <a href="http://users.iems.northwestern.edu/~nocedal/lbfgsb.html">http://users.iems.northwestern.edu/~nocedal/lbfgsb.html</a>)
        limited memory BFGS minimizer with bounds on parameters.
        This is a fork of 'lbfgsb3'.
	This registers a 'R' compatible 'C' interface to L-BFGS-B.3.0 that uses the same
	function types and optimization as the optim() function (see writing 'R' extensions
        and source for details).  This package also adds more stopping criteria as well
        as allowing the adjustment of more tolerances.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.6)</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 0.12.3), numDeriv, methods</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, microbenchmark, optimx, pkgbuild, RcppArmadillo,
rmarkdown, testthat (&ge; 3.0.0), adagio</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp (&ge; 0.12.3), RcppArmadillo</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-09-17 21:53:50 UTC; matt</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://nlmixr2.github.io/lbfgsb3c/">https://nlmixr2.github.io/lbfgsb3c/</a>,
<a href="https://github.com/nlmixr2/lbfgsb3c">https://github.com/nlmixr2/lbfgsb3c</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/nlmixr2/lbfgsb3c/issues">https://github.com/nlmixr2/lbfgsb3c/issues</a></td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Author:</td>
<td>Matthew L Fidler <a href="https://orcid.org/0000-0001-8538-6691"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  John C Nash [aut],
  Ciyou Zhu [aut],
  Richard Byrd [aut],
  Jorge Nocedal [aut],
  Jose Luis Morales [aut]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-09-17 22:30:06 UTC</td>
</tr>
</table>
<hr>
<h2 id='.lbfgsb3cPtr'>Get the lbfgsb3c pointer</h2><span id='topic+.lbfgsb3cPtr'></span>

<h3>Description</h3>

<p>Get the lbfgsb3c pointer
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.lbfgsb3cPtr()
</code></pre>


<h3>Value</h3>

<p>lbfgsb3c function pointer
</p>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
.lbfgsb3cPtr()
</code></pre>

<hr>
<h2 id='lbfgsb3c'>Interfacing wrapper for the Nocedal - Morales LBFGSB3 (Fortran) limited memory BFGS solver.</h2><span id='topic+lbfgsb3c'></span><span id='topic+lbfgsb3'></span><span id='topic+lbfgsb3f'></span><span id='topic+lbfgsb3x'></span>

<h3>Description</h3>

<p>Interfacing wrapper for the Nocedal - Morales LBFGSB3 (Fortran) limited memory BFGS solver.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lbfgsb3c(
  par,
  fn,
  gr = NULL,
  lower = -Inf,
  upper = Inf,
  control = list(),
  ...,
  rho = NULL
)

lbfgsb3(
  par,
  fn,
  gr = NULL,
  lower = -Inf,
  upper = Inf,
  control = list(),
  ...,
  rho = NULL
)

lbfgsb3f(
  par,
  fn,
  gr = NULL,
  lower = -Inf,
  upper = Inf,
  control = list(),
  ...,
  rho = NULL
)

lbfgsb3x(
  par,
  fn,
  gr = NULL,
  lower = -Inf,
  upper = Inf,
  control = list(),
  ...,
  rho = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lbfgsb3c_+3A_par">par</code></td>
<td>
<p>A parameter vector which gives the initial guesses to
the parameters that will minimize <code>fn</code>. This can be
named, for example, we could use par=c(b1=1, b2=2.345,
b3=0.123)</p>
</td></tr>
<tr><td><code id="lbfgsb3c_+3A_fn">fn</code></td>
<td>
<p>A function that evaluates the objective function to be
minimized.  This can be a R function or a Rcpp function
pointer.</p>
</td></tr>
<tr><td><code id="lbfgsb3c_+3A_gr">gr</code></td>
<td>
<p>If present, a function that evaluates the gradient
vector for the objective function at the given parameters
computing the elements of the sum of squares function at the
set of parameters <code>start</code>. This can be a R function or a
Rcpp function pointer.</p>
</td></tr>
<tr><td><code id="lbfgsb3c_+3A_lower">lower</code></td>
<td>
<p>Lower bounds on the parameters. If a single number,
this will be applied to all parameters. Default -Inf.</p>
</td></tr>
<tr><td><code id="lbfgsb3c_+3A_upper">upper</code></td>
<td>
<p>Upper bounds on the parameters. If a single number,
this will be applied to all parameters. Default Inf.</p>
</td></tr>
<tr><td><code id="lbfgsb3c_+3A_control">control</code></td>
<td>
<p>An optional list of control settings. See below in
details.</p>
</td></tr>
<tr><td><code id="lbfgsb3c_+3A_...">...</code></td>
<td>
<p>Any data needed for computation of the objective
function and gradient.</p>
</td></tr>
<tr><td><code id="lbfgsb3c_+3A_rho">rho</code></td>
<td>
<p>An Environment to use for function evaluation.  If
present the arguments in ... are ignored.  Otherwise the
... are converted to an environment for evaluation.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See the notes below for a general appreciation of this package.
</p>
<p>The control list can contain:
</p>

<ul>
<li><p>trace If positive, tracing information on the progress of the optimization is produced. Higher values may produce more tracing information: for method &quot;L-BFGS-B&quot; there are six levels of tracing. (To understand exactly what these do see the source code: higher levels give more detail.)
</p>
</li>
<li><p>factr controls the convergence of the &quot;L-BFGS-B&quot; method. Convergence occurs when the reduction in the objective is within this factor of the machine tolerance. Default is 1e7, that is a tolerance of about 1e-8.
</p>
</li>
<li><p>pgtol helps control the convergence of the &quot;L-BFGS-B&quot; method. It is a tolerance on the projected gradient in the current search direction. This defaults to zero, when the check is suppressed.
</p>
</li>
<li><p>abstol helps control the convergence of the &quot;L-BFGS-B&quot; method. It is an absolute tolerance difference in x values. This defaults to zero, when the check is suppressed.
</p>
</li>
<li><p>reltol helps control the convergence of the &quot;L-BFGS-B&quot; method. It is an relative tolerance difference in x values. This defaults to zero, when the check is suppressed.
</p>
</li>
<li><p>lmm is an integer giving the number of BFGS updates retained in the &quot;L-BFGS-B&quot; method, It defaults to 5.
</p>
</li>
<li><p>maxit maximum number of iterations.
</p>
</li>
<li><p>iprint Provided only for compatibility with older codes. This control is no longer active.)
</p>
</li>
<li><p>info a boolean to indicate if more optimization information is captured and output in a $info list
</p>
</li></ul>



<h3>Value</h3>

<p>A list of the following items
</p>

<ul>
<li><p>par The best set of parameters found.
</p>
</li>
<li><p>value The value of fn corresponding to par.
</p>
</li>
<li><p>counts A two-element integer vector giving the number of calls to fn and gr respectively. This excludes any calls to fn to compute a finite-difference approximation to the gradient.
</p>
</li>
<li><p>convergence An integer code. 0 indicates successful completion
</p>
</li></ul>



<h3>Note</h3>

<p>This package is a wrapper to the Fortran code released by Nocedal and Morales.
This poses several difficulties for an R package. While the <code>.Fortran()</code>
tool exists for the interfacing, we must be very careful to align the arguments
with those of the Fortran subroutine, especially in type and storage.
</p>
<p>A more annoying task for interfacing the Fortran code is that Fortran WRITE or
PRINT statements must all be replaced with calls to special R-friendly output
routines. Unfortunately, the Fortran is full of output statements. Worse, we may
wish to be able to suppress such output, and there are thus many modifications
to be made. This means that an update of the original code cannot be simply
plugged into the R package <code>src</code> directory.
</p>
<p>Finally, and likely because L-BFGS-B has a long history, the Fortran code is far
from well-structured. For example, the number of function and gradient evaluations
used is returned as the 34'th element of an integer vector. There does not appear
to be an easy way to stop the program after some maximum number of such evaluations
have been performed.
</p>
<p>On the other hand, the version of L-BFGS-B in <code>optim()</code> is a <code>C</code> translation
of a now-lost Fortran code. It does not implement the improvements Nocedal and
Morales published in 2011. Hence, despite its deficiencies, this wrapper has been
prepared.
</p>
<p>In addition to the above reasons for the original lbfgsb3 package,
this additional package allows C calling of L-BFGS-B 3.0 by a
program as well as adjustments to the tolerances that were not
present in the original CRAN package.  Also adjustments were made
to have outputs conform with R's optim routine.
</p>


<h3>Author(s)</h3>

<p>Matthew Fidler (move to C and add more options for adjustments),
John C Nash &lt;nashjc@uottawa.ca&gt; (of the wrapper and edits to Fortran code to allow R output)
Ciyou Zhu, Richard Byrd, Jorge Nocedal, Jose Luis Morales (original Fortran packages)
</p>


<h3>References</h3>

<p>Morales, J. L.; Nocedal, J. (2011). &quot;Remark on 'algorithm 778: L-BFGS-B:
Fortran subroutines for large-scale bound constrained optimization' &quot;.
ACM Transactions on Mathematical Software 38: 1.
</p>
<p>Byrd, R. H.; Lu, P.; Nocedal, J.; Zhu, C. (1995). &quot;A Limited Memory Algorithm
for Bound Constrained Optimization&quot;. SIAM J. Sci. Comput. 16 (5): 1190-1208.
</p>
<p>Zhu, C.; Byrd, Richard H.; Lu, Peihuang; Nocedal, Jorge (1997). &quot;L-BFGS-B:
Algorithm 778: L-BFGS-B, FORTRAN routines for large scale bound constrained
optimization&quot;. ACM Transactions on Mathematical Software 23 (4): 550-560.
</p>


<h3>See Also</h3>

<p>Packages <code><a href="stats.html#topic+optim">optim</a></code> and <code>optimx</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Rosenbrock's banana function
n=3; p=100

fr = function(x)
{
    f=1.0
    for(i in 2:n) {
        f=f+p*(x[i]-x[i-1]**2)**2+(1.0-x[i])**2
    }
    f
}

grr = function(x)
{
    g = double(n)
    g[1]=-4.0*p*(x[2]-x[1]**2)*x[1]
    if(n&gt;2) {
        for(i in 2:(n-1)) {
            g[i]=2.0*p*(x[i]-x[i-1]**2)-4.0*p*(x[i+1]-x[i]**2)*x[i]-2.0*(1.0-x[i])
        }
    }
    g[n]=2.0*p*(x[n]-x[n-1]**2)-2.0*(1.0-x[n])
    g
}
x = c(a=1.02, b=1.02, c=1.02)
(opc &lt;- lbfgsb3c(x,fr, grr))
(op &lt;- lbfgsb3(x,fr, grr, control=list(trace=1)))
(opx &lt;- lbfgsb3x(x,fr, grr))
(opf &lt;- lbfgsb3f(x,fr, grr))
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
