<!DOCTYPE html><html lang="en"><head><title>Help for package MEGENA</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {MEGENA}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#MEGENA-package'>
<p>co-expression network analysis</p></a></li>
<li><a href='#calculate.correlation'>
<p>correlation calculation</p></a></li>
<li><a href='#calculate.PFN'>
<p>PFN calculation</p></a></li>
<li><a href='#compute.PFN.par'>
<p>Parallelized PFN computation</p></a></li>
<li><a href='#datExpr'>
<p>Toy example data</p></a></li>
<li><a href='#do.MEGENA'>
<p>MEGENA clustering + MHA</p></a></li>
<li><a href='#draw_sunburst_wt_fill'>
<p>Draw sunburst plot showing MEGENA module hierarchy.</p></a></li>
<li><a href='#get.DegreeHubStatistic'>
<p>calculate module degree statistics based on random triangulation model via T1 and T2 moves.</p></a></li>
<li><a href='#get.hub.summary'>
<p>summarize hub information.</p></a></li>
<li><a href='#get.union.cut'>
<p>Scale-thresholding of multiscale modules.</p></a></li>
<li><a href='#MEGENA.ModuleSummary'>
<p>MEGENA module summary</p></a></li>
<li><a href='#module_convert_to_table'>
<p>conversion of module list object to a data.frame table format</p></a></li>
<li><a href='#output.geneSet.file'>
<p>output gene signatures into .gmt file format</p></a></li>
<li><a href='#planaritytest'>
<p>Boyer-Myvold Planarity test of a network</p></a></li>
<li><a href='#plot_module'>
<p>Module plotting function.</p></a></li>
<li><a href='#plot_module_hierarchy'>
<p>Plot module hierarchy</p></a></li>
<li><a href='#plot_subgraph'>
<p>subnetwork plotting functionality.</p></a></li>
<li><a href='#read.geneSet'>
<p>.gmt file reader function</p></a></li>
<li><a href='#Sample_Expression'>
<p>Toy example data</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Multiscale Clustering of Geometrical Network</td>
</tr>
<tr>
<td>Version:</td>
<td>1.3.7</td>
</tr>
<tr>
<td>Date:</td>
<td>2018-08-30</td>
</tr>
<tr>
<td>Author:</td>
<td>Won-Min Song, Bin Zhang</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Won-Min Song &lt;wonmin1984@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Co-Expression Network Analysis by adopting network embedding technique. Song W.-M., Zhang B. (2015) Multiscale Embedded Gene Co-expression Network Analysis. PLoS Comput Biol 11(11): e1004574. &lt;<a href="https://doi.org/10.1371%2Fjournal.pcbi.1004574">doi:10.1371/journal.pcbi.1004574</a>&gt;.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/songw01/MEGENA">https://github.com/songw01/MEGENA</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 0.11.3),Matrix (&ge; 1.1-5),ggplot2 (&ge; 1.0.0),reshape
(&ge; 0.8.5),fpc (&ge; 2.1-11),cluster (&ge; 2.0.7-1),ggrepel (&ge;
0.5), ggraph (&ge; 1.0.1)</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.4.0),doParallel (&ge; 1.0.11),foreach (&ge; 1.4.4),igraph
(&ge; 1.2.1)</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp,BH</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2018-09-10 15:10:45 UTC; songw01</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2018-09-10 19:00:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='MEGENA-package'>
co-expression network analysis
</h2><span id='topic+MEGENA-package'></span><span id='topic+MEGENA'></span>

<h3>Description</h3>

<p>construction of gene-gene interaction network and dissection into multi-scale functional modules, and network key drivers. 
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> MEGENA</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 1.3</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2015-12-18</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL (&gt;= 2)</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>Multiscale Embedded Gene Co-expression Network Analysis (MEGENA)
</p>


<h3>Author(s)</h3>

<p>Won-Min Song
</p>
<p>Maintainer: Won-Min Song &lt;won-min.song@mssm.edu&gt;
</p>


<h3>References</h3>

<p>Song W-M, Zhang B (2015) Multiscale Embedded Gene Co-expression Network Analysis. PLoS Comput Biol 11(11): e1004574. doi: 10.1371/journal.pcbi.1004574 
</p>

<hr>
<h2 id='calculate.correlation'>
correlation calculation
</h2><span id='topic+calculate.correlation'></span>

<h3>Description</h3>

<p>correlation analysis with FDR calculation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculate.correlation(datExpr,doPerm = 100,doPar = FALSE,num.cores = 8,method = "pearson",
FDR.cutoff = 0.05,n.increment = 100,is.signed = FALSE,
output.permFDR = TRUE,output.corTable = TRUE,saveto = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calculate.correlation_+3A_datexpr">datExpr</code></td>
<td>
<p>gene expression data matrix</p>
</td></tr>
<tr><td><code id="calculate.correlation_+3A_doperm">doPerm</code></td>
<td>
<p>Number of permutations to perform. If <code>doPerm = NULL</code>, calculates BH FDR p-values instead of permutation based FDR.</p>
</td></tr>
<tr><td><code id="calculate.correlation_+3A_dopar">doPar</code></td>
<td>
<p>TRUE/FALSE logical variable to choose parallelization. Parallelization is utilized when BH FDR p-values are calculated for all pairs.</p>
</td></tr>
<tr><td><code id="calculate.correlation_+3A_num.cores">num.cores</code></td>
<td>
<p>number of cores to use in parallelization.</p>
</td></tr>
<tr><td><code id="calculate.correlation_+3A_method">method</code></td>
<td>
<p>correlation method to be passed to <code>cor</code> for <code>method</code> argument.</p>
</td></tr>
<tr><td><code id="calculate.correlation_+3A_fdr.cutoff">FDR.cutoff</code></td>
<td>
<p>FDR threshold to output final results of significant correlations.</p>
</td></tr>
<tr><td><code id="calculate.correlation_+3A_n.increment">n.increment</code></td>
<td>
<p>When permutation is utilized, 0 &lt;= |rho| &lt;= 1 is broken down into n.increment to map each |rho| cutoff to respective FDR.</p>
</td></tr>
<tr><td><code id="calculate.correlation_+3A_is.signed">is.signed</code></td>
<td>
<p>TRUE/FALSE to indicate using signed/unsigned correlation.</p>
</td></tr>
<tr><td><code id="calculate.correlation_+3A_output.permfdr">output.permFDR</code>, <code id="calculate.correlation_+3A_output.cortable">output.corTable</code></td>
<td>
<p>TRUE/FALSE to choose to output permutation indices and FDR table.</p>
</td></tr>
<tr><td><code id="calculate.correlation_+3A_saveto">saveto</code></td>
<td>
<p>folder to output results.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>doPar = TRUE</code>, then num.cores are registered for PCP. 
</p>


<h3>Value</h3>

<p>output is three column edgelist data.frame, third column being the weight.
</p>


<h3>Author(s)</h3>

<p>Won-Min Song
</p>


<h3>Examples</h3>

<pre><code class='language-R'># test simplest case of planar network (a 3-clique).
data(Sample_Expression)
calculate.correlation(datExpr[1:100,],doPerm = 5)
</code></pre>

<hr>
<h2 id='calculate.PFN'>
PFN calculation
</h2><span id='topic+calculate.PFN'></span>

<h3>Description</h3>

<p>main function to calculate PFN a ranked list of edge pairs
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculate.PFN(edgelist,max.skipEdges = NULL,maxENum = NULL,doPar = FALSE,
num.cores = NULL,keep.track = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calculate.PFN_+3A_edgelist">edgelist</code></td>
<td>
<p>three column edgelist: first two columns are topological edges, and the third column is the weight. Must be a data.frame object.</p>
</td></tr>
<tr><td><code id="calculate.PFN_+3A_max.skipedges">max.skipEdges</code></td>
<td>
<p>Maximum number of edges to be searched by planarity test without any inclusion to PFN. 
If set NULL, it will be automatically set to number of cores x 1000. 
It acts as a threhold to quicken PFN construction termination during PCP.</p>
</td></tr>
<tr><td><code id="calculate.PFN_+3A_maxenum">maxENum</code></td>
<td>
<p>maximum number of edges to include in final PFN. Default value is NULL, 
which invokes maximal number of edges allowed in planar network.</p>
</td></tr>
<tr><td><code id="calculate.PFN_+3A_dopar">doPar</code></td>
<td>
<p>TRUE/FALSE logical variable to choose parallelization.</p>
</td></tr>
<tr><td><code id="calculate.PFN_+3A_num.cores">num.cores</code></td>
<td>
<p>number of cores to use in parallelization.</p>
</td></tr>
<tr><td><code id="calculate.PFN_+3A_keep.track">keep.track</code></td>
<td>
<p>If TRUE, pfg_el.RData will be created in working folder. This file can be used later for restart in case PFN construction did not finish successfully.
Default is TRUE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>doPar = TRUE</code>, then num.cores are registered for PCP. 
</p>


<h3>Value</h3>

<p>output is three column edgelist data.frame, third column being the weight.
</p>


<h3>Author(s)</h3>

<p>Won-Min Song
</p>


<h3>Examples</h3>

<pre><code class='language-R'># test simplest case of planar network (a 3-clique).
a &lt;- c(1,1,2);b &lt;- c(2,3,3);w &lt;- runif(3,0,1);
el &lt;- cbind(a,b,w);el &lt;- as.data.frame(el[order(el[,3],decreasing = TRUE),])
calculate.PFN(edgelist = el,max.skipEdges = Inf,doPar = FALSE,num.cores = NULL)
</code></pre>

<hr>
<h2 id='compute.PFN.par'>
Parallelized PFN computation
</h2><span id='topic+compute.PFN.par'></span>

<h3>Description</h3>

<p>PFN construction by parallelized edge screening. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute.PFN.par(sortedEdge,Ng,maxENum,Njob,Ncore,max.skipEdges = NULL,
keep.track = TRUE,initial.links = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="compute.PFN.par_+3A_sortededge">sortedEdge</code></td>
<td>
<p>3-column matrix for the input edgelist (e.g. - correlation pair list). Must be sorted by third column, which is usually weight vector.</p>
</td></tr>
<tr><td><code id="compute.PFN.par_+3A_ng">Ng</code></td>
<td>
<p>integer. number of genes included in sortedEdge.</p>
</td></tr>
<tr><td><code id="compute.PFN.par_+3A_maxenum">maxENum</code></td>
<td>
<p>Maximum number of edges to include in final PFN. The theoretical maximal number enforced by Euler's formula is 3(Ng-2).</p>
</td></tr>
<tr><td><code id="compute.PFN.par_+3A_max.skipedges">max.skipEdges</code></td>
<td>
<p>Maximum number of edges to be counted before any valid edge to be included in PFN. This works as a termination condition to avoid exhaustive 
planarity testing over all edges provided in sortedEdge.</p>
</td></tr>
<tr><td><code id="compute.PFN.par_+3A_njob">Njob</code></td>
<td>
<p>Number of edges to be passed to each core for parallelized edge screening.</p>
</td></tr>
<tr><td><code id="compute.PFN.par_+3A_ncore">Ncore</code></td>
<td>
<p>Number of cores to utilize.</p>
</td></tr>
<tr><td><code id="compute.PFN.par_+3A_keep.track">keep.track</code></td>
<td>
<p>TRUE/FALSE logical. Indicate if the record of PFN construction is saved in temporary file &quot;pfg_el.RData&quot;. Default is TRUE.</p>
</td></tr>
<tr><td><code id="compute.PFN.par_+3A_initial.links">initial.links</code></td>
<td>
<p>If provided, PFN construction will restart by regarding these initial.links as already-built PFN.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is parallelized implementation of PFN construction, where it is possible to re-capture PFN construction by providing already computed edgelist into initial.links. 
Although provivded, this function itself may require careful caution and users are encouraged to use more user-friendly &quot;calculate.PFN()&quot; instead. 
</p>


<h3>Value</h3>

<p>A 3-column matrices, where first two columns are integer indices for vertices, and third is the weight vector.
</p>


<h3>Author(s)</h3>

<p>Won-Min Song
</p>

<hr>
<h2 id='datExpr'>
Toy example data
</h2><span id='topic+datExpr'></span>

<h3>Description</h3>

<p>A portion of TCGA breast cancer data to test run MEGENA. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Sample_Expression.RData
</code></pre>


<h3>Format</h3>

<p>Contains a matrix object, &quot;datExpr&quot;. Use data(Sample_Expression) to load.
</p>


<h3>Details</h3>

<p>a gene expression matrix.
</p>


<h3>References</h3>

<p>1.	Song, W.M. and B. Zhang, Multiscale Embedded Gene Co-expression Network Analysis. PLoS Comput Biol, 2015. 11(11): p. e1004574.
</p>

<hr>
<h2 id='do.MEGENA'>
MEGENA clustering + MHA
</h2><span id='topic+do.MEGENA'></span>

<h3>Description</h3>

<p>multiscale clustering analysis (MCA) and multiscale hub analysis (MHA) pipeline
</p>


<h3>Usage</h3>

<pre><code class='language-R'>do.MEGENA(g,
do.hubAnalysis = TRUE,
mod.pval = 0.05,hub.pval = 0.05,remove.unsig = TRUE,
min.size = 10,max.size = 2500,
doPar = FALSE,num.cores = 4,n.perm = 100,singleton.size = 3,
save.output = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="do.MEGENA_+3A_g">g</code></td>
<td>
<p>igraph object of PFN.</p>
</td></tr>
<tr><td><code id="do.MEGENA_+3A_do.hubanalysis">do.hubAnalysis</code></td>
<td>
<p>TRUE/FALSE indicating to perform multiscale hub analysis (MHA) in downstream. Default is TRUE.</p>
</td></tr>
<tr><td><code id="do.MEGENA_+3A_mod.pval">mod.pval</code></td>
<td>
<p>cluster significance p-value threshold w.r.t random planar networks</p>
</td></tr>
<tr><td><code id="do.MEGENA_+3A_hub.pval">hub.pval</code></td>
<td>
<p>hub significance p-value threshold w.r.t random planar networks</p>
</td></tr>
<tr><td><code id="do.MEGENA_+3A_remove.unsig">remove.unsig</code></td>
<td>
<p>TRUE/FALSE indicating to remove insignificant clusters in MHA.</p>
</td></tr>
<tr><td><code id="do.MEGENA_+3A_min.size">min.size</code></td>
<td>
<p>minimum cluster size</p>
</td></tr>
<tr><td><code id="do.MEGENA_+3A_max.size">max.size</code></td>
<td>
<p>maximum cluster size</p>
</td></tr>
<tr><td><code id="do.MEGENA_+3A_dopar">doPar</code></td>
<td>
<p>TRUE/FALSE indicating parallelization usage</p>
</td></tr>
<tr><td><code id="do.MEGENA_+3A_num.cores">num.cores</code></td>
<td>
<p>number of cores to use in parallelization.</p>
</td></tr>
<tr><td><code id="do.MEGENA_+3A_n.perm">n.perm</code></td>
<td>
<p>number of permutations to calculate hub significance p-values/cluster significance p-values.</p>
</td></tr>
<tr><td><code id="do.MEGENA_+3A_singleton.size">singleton.size</code></td>
<td>
<p>Minimum module size to regard as non-singleton module. Default is 3.</p>
</td></tr>
<tr><td><code id="do.MEGENA_+3A_save.output">save.output</code></td>
<td>
<p>TRUE/FALSE to save outputs from each step of analysis</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Performs MCA and MHA by taking PFN as input. Returns a list object containing clustering outputs, hub analysis outputs, and node summary table. 
</p>


<h3>Value</h3>

<p>A series of output files are written in wkdir. Major outputs are,
</p>
<table role = "presentation">
<tr><td><code>module.output</code></td>
<td>
<p>outputs from MCA</p>
</td></tr>
<tr><td><code>hub.output</code></td>
<td>
<p>outputs from MHA</p>
</td></tr>
<tr><td><code>node.summary</code></td>
<td>
<p>node table summarizing clustering results.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Won-Min Song
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
rm(list = ls())
data(Sample_Expression)
ijw &lt;- calculate.correlation(datExpr[1:100,],doPerm = 2)
el &lt;- calculate.PFN(ijw[,1:3])
g &lt;- graph.data.frame(el,directed = FALSE)
MEGENA.output &lt;- do.MEGENA(g = g,remove.unsig = FALSE,doPar = FALSE,n.perm = 10)

## End(Not run)
</code></pre>

<hr>
<h2 id='draw_sunburst_wt_fill'>
Draw sunburst plot showing MEGENA module hierarchy.
</h2><span id='topic+draw_sunburst_wt_fill'></span>

<h3>Description</h3>

<p>Sunburst plot and colored heatmaps 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  draw_sunburst_wt_fill(module.df,
                        parent.col = "module.parent",id.col = "id",
                        min.angle = 5,
                        feat.col,
                        fill.type = "continuous",log.transform = TRUE,
                        fill.scale = NULL,
                        theme.adjust = NULL
                        )
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="draw_sunburst_wt_fill_+3A_module.df">module.df</code></td>
<td>
<p>A data.frame table summarizing module information. Must contain module parent and child relation for hierarchy visualization.</p>
</td></tr>
<tr><td><code id="draw_sunburst_wt_fill_+3A_parent.col">parent.col</code></td>
<td>
<p>Character object, name for the parent module column in module.df.</p>
</td></tr>
<tr><td><code id="draw_sunburst_wt_fill_+3A_id.col">id.col</code></td>
<td>
<p>Character object for the module id column in module df.</p>
</td></tr>
<tr><td><code id="draw_sunburst_wt_fill_+3A_min.angle">min.angle</code></td>
<td>
<p>Minimum angle that rectangles in the sunburst are labeled with respective module id.</p>
</td></tr>
<tr><td><code id="draw_sunburst_wt_fill_+3A_feat.col">feat.col</code></td>
<td>
<p>Chracter object, for the feature column in module.df to color the heatmaps.</p>
</td></tr>
<tr><td><code id="draw_sunburst_wt_fill_+3A_fill.type">fill.type</code></td>
<td>
<p>continuous/discrete, is the variable numeric (continuous) or factor (discrete)?</p>
</td></tr>
<tr><td><code id="draw_sunburst_wt_fill_+3A_log.transform">log.transform</code></td>
<td>
<p>TRUE/FALSE. do log10 transform for p-values?</p>
</td></tr>
<tr><td><code id="draw_sunburst_wt_fill_+3A_fill.scale">fill.scale</code></td>
<td>
<p>A ggplot object to specify heatmap coloring scheme. Permissible functions are: scale_fill_gradient,scale_fill_gradient2,scale_fill_gradientn,scale_fill_manual.</p>
</td></tr>
<tr><td><code id="draw_sunburst_wt_fill_+3A_theme.adjust">theme.adjust</code></td>
<td>
<p>A ggplot object to specify theme for plotting.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>makes use of ggraph scheme to manipulate and draw sunburst plot in ggplot2 framework. fill.scale and theme.adjust provide flexibility to designate heatmap coloring schemes and figure aesthetics. 
</p>


<h3>Value</h3>

<p>ggplot object for the figure
</p>


<h3>Author(s)</h3>

<p>Won-Min Song
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  ## Not run: 
    rm(list = ls())
    data(Sample_Expression)
    ijw &lt;- calculate.correlation(datExpr[1:100,],doPerm = 2)
    el &lt;- calculate.PFN(ijw[,1:3])
    g &lt;- graph.data.frame(el,directed = FALSE)
    MEGENA.output &lt;- do.MEGENA(g = g,remove.unsig = FALSE,doPar = FALSE,n.perm = 10)
    output.summary &lt;- MEGENA.ModuleSummary(MEGENA.output,
    mod.pvalue = 0.05,hub.pvalue = 0.05,
    min.size = 10,max.size = 5000,
    annot.table = NULL,id.col = NULL,symbol.col = NULL,
    output.sig = TRUE)
    
    # no coloring 
    sbobj = draw_sunburst_wt_fill(module.df = output.summary$module.table,
    feat.col = NULL,id.col = "module.id",parent.col = "module.parent")
    sbobj
    
    # get some coloring (with log transform option)
    mdf= output.summary$module.table
    mdf$heat.pvalue = runif(nrow(mdf),0,0.1)
    
    sbobj = draw_sunburst_wt_fill(module.df = mdf,feat.col = "heat.pvalue",log.transform = TRUE,
    fill.type = "continuous",
    fill.scale = scale_fill_gradient2(low = "white",mid = "white",high = "red",
    midpoint = -log10(0.05),na.value = "white"), 
    id.col = "module.id",parent.col = "module.parent")
    sbobj
    
    # get discrete coloring done
    mdf$category = factor(sample(x = c("A","B"),size = nrow(mdf),replace = TRUE))
    sbobj = draw_sunburst_wt_fill(module.df = mdf,feat.col = "category",
    fill.type = "discrete",
    fill.scale = scale_fill_manual(values = c("A" = "red","B" = "blue")), 
    id.col = "module.id",parent.col = "module.parent")
    sbobj
  
## End(Not run)
</code></pre>

<hr>
<h2 id='get.DegreeHubStatistic'>
calculate module degree statistics based on random triangulation model via T1 and T2 moves. 
</h2><span id='topic+get.DegreeHubStatistic'></span>

<h3>Description</h3>

<p>calculation of module p-values. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.DegreeHubStatistic(subnetwork,n.perm = 100,doPar = FALSE,n.core = 4)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get.DegreeHubStatistic_+3A_subnetwork">subnetwork</code></td>
<td>
<p>a planar network as an igraph object.</p>
</td></tr>
<tr><td><code id="get.DegreeHubStatistic_+3A_n.perm">n.perm</code></td>
<td>
<p>number of random networks generated, constraint with number of links and nodes same to &quot;subnetwork&quot;.</p>
</td></tr>
<tr><td><code id="get.DegreeHubStatistic_+3A_dopar">doPar</code></td>
<td>
<p>TRUE/FALSE to parallelize.</p>
</td></tr>
<tr><td><code id="get.DegreeHubStatistic_+3A_n.core">n.core</code></td>
<td>
<p>number of cores/threads to use.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Hub significance calculation functionality. Make sure that, if doPar = TRUE, register cores using registerDoParallel() from doParallel package.
</p>


<h3>Value</h3>

<p>a data.frame table showing node-wise statistics. 
</p>


<h3>Author(s)</h3>

<p>Won-Min Song
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
	rm(list = ls())
	data(Sample_Expression)
	ijw &lt;- calculate.correlation(datExpr[1:100,],doPerm = 2)
	el &lt;- calculate.PFN(ijw[,1:3])
	g &lt;- graph.data.frame(el,directed = FALSE)

	out &lt;- get.DegreeHubStatistic(subnetwork = g,n.perm = 100,doPar = FALSE,n.core = 4)

## End(Not run)
</code></pre>

<hr>
<h2 id='get.hub.summary'>
summarize hub information.
</h2><span id='topic+get.hub.summary'></span>

<h3>Description</h3>

<p>hubs in different scales are summarized. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.hub.summary(MEGENA.output)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get.hub.summary_+3A_megena.output">MEGENA.output</code></td>
<td>
<p>A list object. The output from &quot;do.MEGENA()&quot;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>returns a data.frame object  
</p>


<h3>Value</h3>

<p>A data.frame object with columns:
</p>
<table role = "presentation">
<tr><td><code>node</code></td>
<td>
<p>hub gene node names</p>
</td></tr>
<tr><td><code>S1</code>, <code>...</code></td>
<td>
<p>binary vector indicating hubs in each scale</p>
</td></tr>
<tr><td><code>frequency</code></td>
<td>
<p>number of scales that respective gene emerges as hub.</p>
</td></tr>
<tr><td><code>scale.summary</code></td>
<td>
<p>list of scales that respective gene as hub.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Won-Min Song
</p>

<hr>
<h2 id='get.union.cut'>
Scale-thresholding of multiscale modules.
</h2><span id='topic+get.union.cut'></span>

<h3>Description</h3>

<p>obtain a discrete, disjoint clustering results from multiscale MEGENA modules for a given alpha value. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.union.cut(module.output,alpha.cut,output.plot = T,
plotfname = "validModules_alpha",module.pval = 0.05,remove.unsig = T)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get.union.cut_+3A_module.output">module.output</code></td>
<td>
<p>A direct output from &quot;do.MEGENA&quot;. (i.e. MEGENA.output$module.output).</p>
</td></tr>
<tr><td><code id="get.union.cut_+3A_alpha.cut">alpha.cut</code></td>
<td>
<p>Resolution parameter cut-off (i.e. alpha) value. alpha.cut = 1 corresponds to classical definition of &quot;small-world&quot; compactness.</p>
</td></tr>
<tr><td><code id="get.union.cut_+3A_output.plot">output.plot</code></td>
<td>
<p>TRUE/FALSE to indicate outputting a .png file showing hierarchical structure with final outputted modules highlighted in red.</p>
</td></tr>
<tr><td><code id="get.union.cut_+3A_plotfname">plotfname</code></td>
<td>
<p>.png file outputname.</p>
</td></tr>
<tr><td><code id="get.union.cut_+3A_module.pval">module.pval</code></td>
<td>
<p>module significance p-value.</p>
</td></tr>
<tr><td><code id="get.union.cut_+3A_remove.unsig">remove.unsig</code></td>
<td>
<p>TRUE/FALSE indicating to remove insignificant clusters.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Returns a list object where each entry is a module.
</p>


<h3>Author(s)</h3>

<p>Won-Min Song
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
rm(list = ls())
data(Sample_Expression)
ijw &lt;- calculate.correlation(datExpr[1:100,],doPerm = 2)
el &lt;- calculate.PFN(ijw[,1:3])
g &lt;- graph.data.frame(el,directed = FALSE)
MEGENA.output &lt;- do.MEGENA(g = g,remove.unsig = FALSE,doPar = FALSE,n.perm = 10)
get.union.cut(module.output = MEGENA.output$module.output,alpha.cut = 1,
output.plot = FALSE,plotfname = NULL,module.pval = 0.05,remove.unsig = TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='MEGENA.ModuleSummary'>
MEGENA module summary
</h2><span id='topic+MEGENA.ModuleSummary'></span>

<h3>Description</h3>

<p>Summarizes modules into a table. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MEGENA.ModuleSummary(MEGENA.output,
mod.pvalue = 0.05,hub.pvalue = 0.05,
min.size = 10,max.size = 2500,
annot.table = NULL,symbol.col = NULL,id.col = NULL, 
output.sig = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MEGENA.ModuleSummary_+3A_megena.output">MEGENA.output</code></td>
<td>
<p>A list object. The output from &quot;do.MEGENA()&quot;.</p>
</td></tr>
<tr><td><code id="MEGENA.ModuleSummary_+3A_mod.pvalue">mod.pvalue</code></td>
<td>
<p>module compactness significance p-value, to identify modules with significant compactness.</p>
</td></tr>
<tr><td><code id="MEGENA.ModuleSummary_+3A_hub.pvalue">hub.pvalue</code></td>
<td>
<p>node degree significance p-value to identify nodes with significantly high degree.</p>
</td></tr>
<tr><td><code id="MEGENA.ModuleSummary_+3A_min.size">min.size</code></td>
<td>
<p>minimum module size allowed to finalize in the summary output.</p>
</td></tr>
<tr><td><code id="MEGENA.ModuleSummary_+3A_max.size">max.size</code></td>
<td>
<p>maximum module size allowed to finalize in the summary output.</p>
</td></tr>
<tr><td><code id="MEGENA.ModuleSummary_+3A_annot.table">annot.table</code></td>
<td>
<p>Default value is NULL, indicating no mapping is provided between node names to gene symbols. 
If provided, the mapping between node names (id.col) and gene symbol (symbol.col) are used.</p>
</td></tr>
<tr><td><code id="MEGENA.ModuleSummary_+3A_id.col">id.col</code></td>
<td>
<p>column index of annot.table for node names.</p>
</td></tr>
<tr><td><code id="MEGENA.ModuleSummary_+3A_symbol.col">symbol.col</code></td>
<td>
<p>column index of annot.table for gene symbols.</p>
</td></tr>
<tr><td><code id="MEGENA.ModuleSummary_+3A_output.sig">output.sig</code></td>
<td>
<p>Default value is TRUE, indicating significant modules are outputted.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>output$module.table contains many important information including module hierarchy, as indicated by 
</p>


<h3>Value</h3>

<p>A list object with the components:
</p>
<table role = "presentation">
<tr><td><code>modules</code></td>
<td>
<p>Final set of modules obtained upon apply mod.pvalue for significance, min.size and max.size for module size thresholding.</p>
</td></tr>
<tr><td><code>mapped.modules</code></td>
<td>
<p>gene symbol mapped modules when &quot;annot.table&quot; is provided.</p>
</td></tr>
<tr><td><code>module.table</code></td>
<td>
<p>data.frame object for module summary table. Columns include: id, module.size, module.parent, module.hub, module.scale and module.pvalue.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Won-Min Song
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
rm(list = ls())
data(Sample_Expression)
ijw &lt;- calculate.correlation(datExpr[1:100,],doPerm = 2)
el &lt;- calculate.PFN(ijw[,1:3])
g &lt;- graph.data.frame(el,directed = FALSE)
MEGENA.output &lt;- do.MEGENA(g = g,remove.unsig = FALSE,doPar = FALSE,n.perm = 10)
output.summary &lt;- MEGENA.ModuleSummary(MEGENA.output,
mod.pvalue = 0.05,hub.pvalue = 0.05,
min.size = 10,max.size = 5000,
annot.table = NULL,id.col = NULL,symbol.col = NULL,
output.sig = TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='module_convert_to_table'>
conversion of module list object to a data.frame table format
</h2><span id='topic+module_convert_to_table'></span>

<h3>Description</h3>

<p>Summarizes module hub/hierarchy/membership into a data.frame table format. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>module_convert_to_table(MEGENA.output,mod.pval = 0.05,
hub.pval = 0.05,min.size = 10,max.size)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="module_convert_to_table_+3A_megena.output">MEGENA.output</code></td>
<td>
<p>A list object. The output from &quot;do.MEGENA()&quot;.</p>
</td></tr>
<tr><td><code id="module_convert_to_table_+3A_mod.pval">mod.pval</code></td>
<td>
<p>module compactness significance p-value, to identify modules with significant compactness.</p>
</td></tr>
<tr><td><code id="module_convert_to_table_+3A_hub.pval">hub.pval</code></td>
<td>
<p>node degree significance p-value to identify nodes with significantly high degree.</p>
</td></tr>
<tr><td><code id="module_convert_to_table_+3A_min.size">min.size</code></td>
<td>
<p>minimum module size allowed to finalize in the summary output.</p>
</td></tr>
<tr><td><code id="module_convert_to_table_+3A_max.size">max.size</code></td>
<td>
<p>maximum module size allowed to finalize in the summary output.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>the resulting data.frame contains the following essential columns: id, module.parent and module. 
If the co-expression network bears significant hubs, it will additionally have node.degree (connectivity), node.strength (sum of edge weights) and is.hub column to supplement hub information. 
</p>


<h3>Value</h3>

<p>A data.frame with the columns:
</p>
<table role = "presentation">
<tr><td><code>id</code></td>
<td>
<p>gene name</p>
</td></tr>
<tr><td><code>module.parent</code></td>
<td>
<p>parent module id</p>
</td></tr>
<tr><td><code>module</code></td>
<td>
<p>module name.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Won-Min Song
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
rm(list = ls())
data(Sample_Expression)
ijw &lt;- calculate.correlation(datExpr[1:100,],doPerm = 2)
el &lt;- calculate.PFN(ijw[,1:3])
g &lt;- graph.data.frame(el,directed = FALSE)
MEGENA.output &lt;- do.MEGENA(g = g,remove.unsig = FALSE,doPar = FALSE,n.perm = 10)
output.summary &lt;- MEGENA.ModuleSummary(MEGENA.output,
mod.pvalue = 0.05,hub.pvalue = 0.05,
min.size = 10,max.size = 5000,
annot.table = NULL,id.col = NULL,symbol.col = NULL,
output.sig = TRUE)
module.df = module_convert_to_table(MEGENA.output,mod.pval = 0.05,
hub.pval = 0.05,min.size = 10,max.size)
head(module.df)

## End(Not run)
</code></pre>

<hr>
<h2 id='output.geneSet.file'>
output gene signatures into .gmt file format
</h2><span id='topic+output.geneSet.file'></span>

<h3>Description</h3>

<p>An interface function to output .gmt format gene signature file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>output.geneSet.file(geneSet,outputfname)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="output.geneSet.file_+3A_geneset">geneSet</code></td>
<td>
<p>a list object</p>
</td></tr>
<tr><td><code id="output.geneSet.file_+3A_outputfname">outputfname</code></td>
<td>
<p>output file name</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Outputs each signature into a single line of lists in <code>outputfname</code>. 
</p>


<h3>Author(s)</h3>

<p>Won-Min Song
</p>

<hr>
<h2 id='planaritytest'>
Boyer-Myvold Planarity test of a network
</h2><span id='topic+planaritytest'></span>

<h3>Description</h3>

<p>wrapper function of _MEGENA_planaritytest. imports from Boost graph library, and test planarity of a network
</p>


<h3>Usage</h3>

<pre><code class='language-R'>planaritytest(N, rows, cols)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="planaritytest_+3A_n">N</code></td>
<td>
<p>must be an integer. number of nodes in the network.</p>
</td></tr>
<tr><td><code id="planaritytest_+3A_rows">rows</code></td>
<td>
<p>first column of edgelist. a vector of integers.</p>
</td></tr>
<tr><td><code id="planaritytest_+3A_cols">cols</code></td>
<td>
<p>second column of edgelist. a vector of integers.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>cbind(rows,cols) is equivalent to the two column edge list of the network. We assume that the network is undirected. 
</p>


<h3>Value</h3>

<p>TRUE/FALSE is returned to indicate planarity. (TRUE -&gt; network is planar). 
</p>


<h3>Author(s)</h3>

<p>Won-Min Song
</p>


<h3>Examples</h3>

<pre><code class='language-R'># test simplest case of planar network (a 3-clique).
planaritytest(as.integer(3),c(1,1,2),c(2,3,3))
</code></pre>

<hr>
<h2 id='plot_module'>
Module plotting function.
</h2><span id='topic+plot_module'></span>

<h3>Description</h3>

<p>Extract subnetworks for modules and plot. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_module(output.summary,PFN,subset.module = NULL,col.names,
gene.set = NULL,color.code = "logFC",show.legend = TRUE,
label.hubs.only = TRUE,hubLabel.col = "red",hubLabel.sizeProp = 0.5,show.topn.hubs = 10,
node.sizeProp = 13,label.sizeProp = 13,label.scaleFactor = 10,label.alpha = 0.5,
layout = "kamada.kawai",output.plot = TRUE,out.dir = "modulePlot")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_module_+3A_output.summary">output.summary</code></td>
<td>
<p>output from summary function, &quot;MEGENA.ModuleSummary&quot;.</p>
</td></tr>
<tr><td><code id="plot_module_+3A_pfn">PFN</code></td>
<td>
<p>igraph object retaining PFN topology.</p>
</td></tr>
<tr><td><code id="plot_module_+3A_subset.module">subset.module</code></td>
<td>
<p>A character vector for list of module names to plot. Default = NULL plots all modules in output.summary.</p>
</td></tr>
<tr><td><code id="plot_module_+3A_col.names">col.names</code></td>
<td>
<p>a character vector for list of colors to be used for coloring children modules.</p>
</td></tr>
<tr><td><code id="plot_module_+3A_gene.set">gene.set</code></td>
<td>
<p>A list object containing signatures for customized coloring of nodes in resulting network plot.</p>
</td></tr>
<tr><td><code id="plot_module_+3A_color.code">color.code</code></td>
<td>
<p>A character vector with matched length to &quot;gene.set&quot;, to specify colors for each signature.</p>
</td></tr>
<tr><td><code id="plot_module_+3A_label.hubs.only">label.hubs.only</code></td>
<td>
<p>TRUE/FALSE to show labels for significant hub genes only, or all genes. Defauly is TRUE.</p>
</td></tr>
<tr><td><code id="plot_module_+3A_hublabel.col">hubLabel.col</code></td>
<td>
<p>Label color for hubs. Default is &quot;red&quot;</p>
</td></tr>
<tr><td><code id="plot_module_+3A_show.legend">show.legend</code></td>
<td>
<p>TRUE/FALSE for showing node legend on the bottom of the figure.</p>
</td></tr>
<tr><td><code id="plot_module_+3A_hublabel.sizeprop">hubLabel.sizeProp</code></td>
<td>
<p>A multiplicative factor to adjust hub label sizes with respect to node size values. Default is 0.5</p>
</td></tr>
<tr><td><code id="plot_module_+3A_show.topn.hubs">show.topn.hubs</code></td>
<td>
<p>Maximal number of hubs to label on module subnetwork. Default is 10.</p>
</td></tr>
<tr><td><code id="plot_module_+3A_node.sizeprop">node.sizeProp</code></td>
<td>
<p>A multiplicative factor to adjust node sizes with respect to 90th percentile degree node size. Default is 13</p>
</td></tr>
<tr><td><code id="plot_module_+3A_label.sizeprop">label.sizeProp</code></td>
<td>
<p>A multiplicative factor to adjust node label sizes with respect to 90th percentile degree node size. Default is 13</p>
</td></tr>
<tr><td><code id="plot_module_+3A_label.scalefactor">label.scaleFactor</code></td>
<td>
<p>Overall scale factor to control the final size of node labels appearing in figure. Default is 10.</p>
</td></tr>
<tr><td><code id="plot_module_+3A_label.alpha">label.alpha</code></td>
<td>
<p>Transparency value ranging from 0 (transparent) to 1 (solid). Default is 0.5.</p>
</td></tr>
<tr><td><code id="plot_module_+3A_layout">layout</code></td>
<td>
<p>Network layout algorithm to apply. Options are: &quot;kamada.kawai&quot;, &quot;fruchterman.reingold&quot;.</p>
</td></tr>
<tr><td><code id="plot_module_+3A_output.plot">output.plot</code></td>
<td>
<p>logical value. output.plot = TRUE generates figure files under folder, &quot;modulePlot&quot;.</p>
</td></tr>
<tr><td><code id="plot_module_+3A_out.dir">out.dir</code></td>
<td>
<p>if output.plot = TRUE, then out.dir is created and resulting figures are exported to .png files to the folder.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Subnetwork plot functionality with application of &quot;ggrepel&quot; package for node labeling. The most effective way to control overall node label size is through label.scaleFactor. 
</p>


<h3>Value</h3>

<p>A list object holding ggplot objects for plotted modules. 
</p>


<h3>Author(s)</h3>

<p>Won-Min Song
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
rm(list = ls())
library(MEGENA)

data(Sample_Expression)
ijw &lt;- calculate.correlation(datExpr[1:100,],doPerm = 2)
el &lt;- calculate.PFN(ijw[,1:3])
g &lt;- graph.data.frame(el,directed = FALSE)
MEGENA.output &lt;- do.MEGENA(g = g,remove.unsig = FALSE,doPar = FALSE,n.perm = 10)
output.summary &lt;- MEGENA.ModuleSummary(MEGENA.output,
mod.pvalue = 0.05,hub.pvalue = 0.05,
min.size = 10,max.size = 5000,
annot.table = NULL,id.col = NULL,symbol.col = NULL,
output.sig = TRUE)

pnet.obj &lt;- plot_module(output = output.summary,PFN = g,subset.module = "comp1_2",
	layout = "kamada.kawai",label.hubs.only = FALSE,
	gene.set = list("hub.set" = c("CD3E","CD2")),color.code =  c("red"),
	output.plot = FALSE,out.dir = "modulePlot",col.names = c("grey","grey","grey"),
	hubLabel.col = "black",hubLabel.sizeProp = 1,show.topn.hubs = Inf,show.legend = TRUE)
	
pnet.obj

## End(Not run)
</code></pre>

<hr>
<h2 id='plot_module_hierarchy'>
Plot module hierarchy
</h2><span id='topic+plot_module_hierarchy'></span>

<h3>Description</h3>

<p>visualized module hierarchical structure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_module_hierarchy(module.table,plot.coord = NULL,
edge.color = "grey",node.color = "black",node.label.color = "black",
label.scaleFactor = 0.5,node.scaleFactor = 0.2,arrow.size = 0.015,
data.col = NULL,low.color = "blue",mid.color = "white",
high.color = "red",mid.value = 0.05)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_module_hierarchy_+3A_module.table">module.table</code></td>
<td>
<p>output from MEGENA.ModuleSummary. Specifically $module.table component of the output.</p>
</td></tr>
<tr><td><code id="plot_module_hierarchy_+3A_plot.coord">plot.coord</code></td>
<td>
<p>Two column coordinate matrix. rownames must be labelled according to module.table$id.</p>
</td></tr>
<tr><td><code id="plot_module_hierarchy_+3A_edge.color">edge.color</code></td>
<td>
<p>Edge color to be shown.</p>
</td></tr>
<tr><td><code id="plot_module_hierarchy_+3A_node.color">node.color</code></td>
<td>
<p>If data.col = NULL, node.color is used to color nodes in figure.</p>
</td></tr>
<tr><td><code id="plot_module_hierarchy_+3A_node.label.color">node.label.color</code></td>
<td>
<p>Node label color.</p>
</td></tr>
<tr><td><code id="plot_module_hierarchy_+3A_label.scalefactor">label.scaleFactor</code></td>
<td>
<p>scale number to adjust node label sizes.</p>
</td></tr>
<tr><td><code id="plot_module_hierarchy_+3A_node.scalefactor">node.scaleFactor</code></td>
<td>
<p>scale number to adjust node sizes.</p>
</td></tr>
<tr><td><code id="plot_module_hierarchy_+3A_arrow.size">arrow.size</code></td>
<td>
<p>scale number to arrow size.</p>
</td></tr>
<tr><td><code id="plot_module_hierarchy_+3A_data.col">data.col</code></td>
<td>
<p>A character to specify data vector to color nodes in module.table.</p>
</td></tr>
<tr><td><code id="plot_module_hierarchy_+3A_low.color">low.color</code></td>
<td>
<p>If data.col != NULL, color to be used in lower value spectrum.</p>
</td></tr>
<tr><td><code id="plot_module_hierarchy_+3A_mid.color">mid.color</code></td>
<td>
<p>If data.col != NULL, color to be used in middle value spectrum.</p>
</td></tr>
<tr><td><code id="plot_module_hierarchy_+3A_high.color">high.color</code></td>
<td>
<p>If data.col != NULL, color to be used in high value spectrum.</p>
</td></tr>
<tr><td><code id="plot_module_hierarchy_+3A_mid.value">mid.value</code></td>
<td>
<p>If data.col != NULL, value to define middle value spectrum.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Module hierarchy plotting functionality using ggplot2. 
</p>


<h3>Value</h3>

<p>A list containing output$hierarchy.obj = ggplot2 object, output$node.data = node attributes, output$edge.data = edge attributes.
</p>


<h3>Author(s)</h3>

<p>Won-Min Song
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
	rm(list = ls())
	data(Sample_Expression)
	ijw &lt;- calculate.correlation(datExpr,doPerm = 2)
	el &lt;- calculate.PFN(ijw[,1:3])
	g &lt;- graph.data.frame(el,directed = FALSE)
	MEGENA.output &lt;- do.MEGENA(g = g,remove.unsig = FALSE,doPar = FALSE,n.perm = 10)
	output.summary &lt;- MEGENA.ModuleSummary(MEGENA.output,
	mod.pvalue = 0.05,hub.pvalue = 0.05,
	min.size = 10,max.size = 5000,
	annot.table = NULL,id.col = NULL,symbol.col = NULL,
	output.sig = TRUE)

	module.table = output.summary$module.table
	colnames(module.table)[1] &lt;- "id"
	output.obj &lt;- plot_module_hierarchy(module.table = module.table,
	label.scaleFactor = 0.15,arrow.size = 0.005,node.label.color = "blue")

	print(output.obj[[1]])

## End(Not run)
</code></pre>

<hr>
<h2 id='plot_subgraph'>
subnetwork plotting functionality. 
</h2><span id='topic+plot_subgraph'></span>

<h3>Description</h3>

<p>A modification of plot_module() function for more general subnetwork plotting purpose.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_subgraph(module,hub = NULL,PFN,node.default.color = "black",
gene.set = NULL,color.code = "grey",show.legend = TRUE,
label.hubs.only = TRUE,hubLabel.col = "red",hubLabel.sizeProp = 0.5,show.topn.hubs = 10,
node.sizeProp = 13,label.sizeProp = 13,label.scaleFactor = 10,layout = "kamada.kawai")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_subgraph_+3A_module">module</code></td>
<td>
<p>A character vector containing gene names to be subsetted.</p>
</td></tr>
<tr><td><code id="plot_subgraph_+3A_hub">hub</code></td>
<td>
<p>If provided, genes in hub will be highlighted as triangles in resulting figure.</p>
</td></tr>
<tr><td><code id="plot_subgraph_+3A_pfn">PFN</code></td>
<td>
<p>igraph object retaining PFN topology.</p>
</td></tr>
<tr><td><code id="plot_subgraph_+3A_node.default.color">node.default.color</code></td>
<td>
<p>Default node colors for those that do not intersect with signatures in gene.set.</p>
</td></tr>
<tr><td><code id="plot_subgraph_+3A_gene.set">gene.set</code></td>
<td>
<p>A list object containing signatures for customized coloring of nodes in resulting network plot.</p>
</td></tr>
<tr><td><code id="plot_subgraph_+3A_color.code">color.code</code></td>
<td>
<p>A character vector with matched length to &quot;gene.set&quot;, to specify colors for each signature.</p>
</td></tr>
<tr><td><code id="plot_subgraph_+3A_show.legend">show.legend</code></td>
<td>
<p>TRUE/FALSE for showing node legend on the bottom of the figure.</p>
</td></tr>
<tr><td><code id="plot_subgraph_+3A_label.hubs.only">label.hubs.only</code></td>
<td>
<p>TRUE/FALSE to show labels for significant hub genes only, or all genes. Defauly is TRUE.</p>
</td></tr>
<tr><td><code id="plot_subgraph_+3A_hublabel.col">hubLabel.col</code></td>
<td>
<p>Label color for hubs. Default is &quot;red&quot;</p>
</td></tr>
<tr><td><code id="plot_subgraph_+3A_hublabel.sizeprop">hubLabel.sizeProp</code></td>
<td>
<p>A multiplicative factor to adjust hub label sizes with respect to node size values. Default is 0.5</p>
</td></tr>
<tr><td><code id="plot_subgraph_+3A_show.topn.hubs">show.topn.hubs</code></td>
<td>
<p>Maximal number of hubs to label on module subnetwork. Default is 10.</p>
</td></tr>
<tr><td><code id="plot_subgraph_+3A_node.sizeprop">node.sizeProp</code></td>
<td>
<p>A multiplicative factor to adjust node sizes with respect to 90th percentile degree node size. Default is 13</p>
</td></tr>
<tr><td><code id="plot_subgraph_+3A_label.sizeprop">label.sizeProp</code></td>
<td>
<p>A multiplicative factor to adjust node label sizes with respect to 90th percentile degree node size. Default is 13</p>
</td></tr>
<tr><td><code id="plot_subgraph_+3A_label.scalefactor">label.scaleFactor</code></td>
<td>
<p>Overall scale factor to control the final size of node labels appearing in figure. Default is 10.</p>
</td></tr>
<tr><td><code id="plot_subgraph_+3A_layout">layout</code></td>
<td>
<p>Network layout algorithm to apply. Options are: &quot;kamada.kawai&quot;, &quot;fruchterman.reingold&quot;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Subnetwork plot functionality with application of &quot;ggrepel&quot; package for node labeling. The most effective way to control overall node label size is through label.scaleFactor. 
</p>


<h3>Value</h3>

<p>A list object holding ggplot object and node annotation table.
</p>


<h3>Author(s)</h3>

<p>Won-Min Song
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
rm(list = ls())
library(MEGENA)

data(Sample_Expression)
ijw &lt;- calculate.correlation(datExpr[1:100,],doPerm = 2)
el &lt;- calculate.PFN(ijw[,1:3])
g &lt;- graph.data.frame(el,directed = FALSE)
MEGENA.output &lt;- do.MEGENA(g = g,remove.unsig = FALSE,doPar = FALSE,n.perm = 10)
output.summary &lt;- MEGENA.ModuleSummary(MEGENA.output,
mod.pvalue = 0.05,hub.pvalue = 0.05,
min.size = 10,max.size = 5000,
annot.table = NULL,id.col = NULL,symbol.col = NULL,
output.sig = TRUE)

pnet.obj &lt;- plot_subgraph(module = output.summary$modules[[1]],
hub = c("CD3E","CD2"),PFN = g,node.default.color = "black",
gene.set = NULL,color.code = c("grey"),show.legend = TRUE,
label.hubs.only = TRUE,hubLabel.col = "red",hubLabel.sizeProp = 0.5,
show.topn.hubs = 10,node.sizeProp = 13,label.sizeProp = 13,
label.scaleFactor = 10,layout = "kamada.kawai")

# the plot	
pnet.obj[[1]]

# the annotation
pnet.obj[[2]]

## End(Not run)
</code></pre>

<hr>
<h2 id='read.geneSet'>
.gmt file reader function
</h2><span id='topic+read.geneSet'></span>

<h3>Description</h3>

<p>An interface function to read-in .gmt format gene signature file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.geneSet(geneSet.file)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="read.geneSet_+3A_geneset.file">geneSet.file</code></td>
<td>
<p>text file containing gene signatures in .gmt format</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Each line of lists in <code>geneset.file</code> is a single set of signature. 
</p>


<h3>Value</h3>

<p>loads signatures into a list object. 
</p>


<h3>Author(s)</h3>

<p>Won-Min Song
</p>

<hr>
<h2 id='Sample_Expression'>
Toy example data
</h2><span id='topic+Sample_Expression.RData'></span>

<h3>Description</h3>

<p>A portion of TCGA breast cancer data to test run MEGENA. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(Sample_Expression)
</code></pre>


<h3>Format</h3>

<p>Contains a matrix object, &quot;datExpr&quot;. Use data(Sample_Expression) to load.
</p>


<h3>Details</h3>

<p>a gene expression matrix.
</p>


<h3>References</h3>

<p>1.	Song, W.M. and B. Zhang, Multiscale Embedded Gene Co-expression Network Analysis. PLoS Comput Biol, 2015. 11(11): p. e1004574.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
