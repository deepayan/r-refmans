<!DOCTYPE html><html lang="en"><head><title>Help for package micsr</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {micsr}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#micsr-package'><p><strong>micsr</strong> : Microeconometrics with R</p></a></li>
<li><a href='#apples'><p>Apple production</p></a></li>
<li><a href='#binmeans'><p>Compute the mean of a variable for bins of another variable</p></a></li>
<li><a href='#binomreg'><p>Binomial regression</p></a></li>
<li><a href='#birthwt'><p>Cigarette smoking and birth weight</p></a></li>
<li><a href='#bivprobit'><p>Bivariate probit</p></a></li>
<li><a href='#charitable'><p>Intergenerational transmission of charitable giving</p></a></li>
<li><a href='#cigmales'><p>Cigarette smoking behaviour</p></a></li>
<li><a href='#clm'><p>Constrained least squares</p></a></li>
<li><a href='#cmtest'><p>Conditional moments test</p></a></li>
<li><a href='#drinks'><p>Physician advice on alcohol consumption</p></a></li>
<li><a href='#dummy'><p>Transform a factor in a set of dummy variables</p></a></li>
<li><a href='#escount'><p>Endogenous switching and sample selection models for count data</p></a></li>
<li><a href='#expreg'><p>Instrumental variable estimation for exponential conditional mean</p>
models</a></li>
<li><a href='#federiv'><p>Foreign exchange derivatives use by large US bank holding companies</p></a></li>
<li><a href='#fin_reform'><p>Political economy of financial reforms</p></a></li>
<li><a href='#ftest'><p>F statistic</p></a></li>
<li><a href='#gaze'><p>Short print of the summary of an object</p></a></li>
<li><a href='#hausman'><p>Hausman test</p></a></li>
<li><a href='#housprod'><p>Household Production</p></a></li>
<li><a href='#ivldv'><p>Instrumental variable estimators for limited dependent variable</p></a></li>
<li><a href='#loglm'><p>Log-linear model</p></a></li>
<li><a href='#micsr'><p><code>micsr</code> class</p></a></li>
<li><a href='#mills'><p>Compute the inverse Mills ratio and its first two derivatives</p></a></li>
<li><a href='#mode_choice'><p>Choice between car and transit</p></a></li>
<li><a href='#ndvuong'><p>Non-degenerate Vuong test</p></a></li>
<li><a href='#newton'><p>Newton-Raphson  method for numerical optimization</p></a></li>
<li><a href='#npar'><p>Number of parameters of a fitted model</p></a></li>
<li><a href='#ordreg'><p>Ordered regression</p></a></li>
<li><a href='#poisreg'><p>Poisson regression</p></a></li>
<li><a href='#pscore'><p>Propensity scores</p></a></li>
<li><a href='#reexports'><p>Objects exported from other packages</p></a></li>
<li><a href='#rsq'><p>Coefficient of determination</p></a></li>
<li><a href='#sargan'><p>Sargan test for GMM models</p></a></li>
<li><a href='#scoretest'><p>Score test</p></a></li>
<li><a href='#stder'><p>Extract the standard errors of estimated coefficients</p></a></li>
<li><a href='#tobit1'><p>Truncated response model</p></a></li>
<li><a href='#trade_protection'><p>Lobying from Capitalists and Unions and Trade Protection</p></a></li>
<li><a href='#trips'><p>Determinants of household trip taking</p></a></li>
<li><a href='#turnout'><p>Turnout</p></a></li>
<li><a href='#twa'><p>Temporary help jobs and permanent employment</p></a></li>
<li><a href='#vuong_sim'><p>Simulated pdfs for the Vuong statistics using linear models</p></a></li>
<li><a href='#zellner_revankar'><p>Generalized production function</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Version:</td>
<td>0.1-1</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-02-12</td>
</tr>
<tr>
<td>Title:</td>
<td>Microeconometrics with R</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.0.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>Formula, Rdpack, sandwich, generics, tibble, ggplot2, rlang,
dplyr, tidyr, purrr, knitr, magrittr, tidyselect</td>
</tr>
<tr>
<td>Suggests:</td>
<td>rmarkdown, modelsummary, bookdown, AER, censReg,
sampleSelection, mlogit, MASS, lmtest</td>
</tr>
<tr>
<td>Description:</td>
<td>Functions, data sets and examples for the book: Yves Croissant (2024) "Microeconometrics with R", Chapman and Hall/CRC The R Series. The package includes a set of estimators for models used in microeconometrics, especially for count data and limited dependent variables. Test functions include score test, Hausman test, Vuong test, Sargan test and conditional moment test. A small subset of the data set used in the book is also included.</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://www.r-project.org">https://www.r-project.org</a></td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RdMacros:</td>
<td>Rdpack</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-02-16 02:38:57 UTC; yves</td>
</tr>
<tr>
<td>Author:</td>
<td>Yves Croissant <a href="https://orcid.org/0000-0002-4857-7736"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Yves Croissant &lt;yves.croissant@univ-reunion.fr&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-02-17 20:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='micsr-package'><strong>micsr</strong> : Microeconometrics with R</h2><span id='topic+micsr-package'></span>

<h3>Description</h3>

<p>The micsr package is the companion package to the book
&quot;Microeconometrics with R&quot; (Chapman and Hall/CRC The R Series). It
includes function to estimate and to test models, miscellanous
tools and data sets:
</p>


<h3>Details</h3>


<ul>
<li><p> functions to estimate models:
</p>

<ul>
<li> <p><code>binomreg</code>: binomial regression models, Rivers and Vuong (1988),
</p>
</li>
<li> <p><code>bivprobit</code>: bivariate probit model
</p>
</li>
<li> <p><code>clm</code>: constrained linear models,
</p>
</li>
<li> <p><code>escount</code>: endogenous switching and selection model for count data, Terza (1998),
</p>
</li>
<li> <p><code>expreg</code>: exponential conditional mean models, Mullahy (1997),
</p>
</li>
<li> <p><code>loglm</code>: log-linear models,
</p>
</li>
<li> <p><code>ordreg</code>: ordered regression models,
</p>
</li>
<li> <p><code>poisreg</code>: poisson models,
</p>
</li>
<li> <p><code>pscore</code>: matching, Dehejia and Wahba (2002),
</p>
</li>
<li> <p><code>tobit1</code>: tobit-1 model, Tobin (1958), Smith and Blundel (1986), Powel (1986).
</p>
</li></ul>

</li>
<li><p> functions for statistical tests and diagnostic:
</p>

<ul>
<li> <p><code>cmtest</code>: conditional moment tests, Newey (1985), Tauchen (1985),
</p>
</li>
<li> <p><code>ftest</code>: F statistic,
</p>
</li>
<li> <p><code>hausman</code>: Hausman's test, Hausman (1978),
</p>
</li>
<li> <p><code>ndvuong</code>: non-degenerate Vuong test, Vuong (1989), Shi (2015),
</p>
</li>
<li> <p><code>rsq</code>: different flavors of R squared,
</p>
</li>
<li> <p><code>sargan</code>: Sargan's test, Sargan (1958),
</p>
</li>
<li> <p><code>scoretest</code>: score, or Lagrange multiplier test.
</p>
</li></ul>

</li>
<li><p> miscellanous tools
</p>

<ul>
<li> <p><code>gaze</code>: print a short summary of an object,
</p>
</li>
<li> <p><code>dummy</code>: generate a set of dummy variables from a factor,
</p>
</li>
<li> <p><code>newton</code>: Newton-Raphson optimization method, using the analytical gradient and hessian,
</p>
</li>
<li> <p><code>mills</code>: compute the inverse mills ratio and its first two derivatives,
</p>
</li>
<li> <p><code>stder</code>: extract the standard errors of a fitted model,
</p>
</li>
<li> <p><code>npar</code>: extract the number of parameters in a fitted model.
</p>
</li></ul>

</li>
<li><p> data sets:
</p>

<ul>
<li> <p><code>apples</code>: Apple production, Ivaldi and al. (1996), constrained
linear model,
</p>
</li>
<li> <p><code>birthwt</code>: Cigarette smoking and birth weigth, Mullahy
(1997), exponentional conditional mean regression model,
</p>
</li>
<li> <p><code>charitable</code>: Intergenerational transmission of charitable
giving, Wilhem (2008), Tobit-1 model,
</p>
</li>
<li> <p><code>cigmales</code>: Cigarettes consumption and smoking habits,
Mullahy (1997), exponentional conditional mean regression mdodel,
</p>
</li>
<li> <p><code>drinks</code>: Physician advice on alcohol consumption, Kenkel and
Terza (2001), endogenous switching model for count data,
</p>
</li>
<li> <p><code>ferediv</code>: Foreign exchange derivatives use by large US bank
holding companies, Adkins (2012), instrumental variable probit
model,
</p>
</li>
<li> <p><code>fin_reform</code>: Political economy of financial reforms, Abiad and
Mody (2005), ordered regression model,
</p>
</li>
<li> <p><code>housprod</code>: Household production, Kerkhofs and Kooreman (2003),
bivariate probit model,
</p>
</li>
<li> <p><code>mode_choice</code>: Choice between car and transit, Horowitz (1993),
probit model,
</p>
</li>
<li> <p><code>trade_protection</code>: Lobying and trade protection, Atschke and
Sherlund (2006), instrumental variable Tobit-1 model,
</p>
</li>
<li> <p><code>trips</code>: Determinants of household trip taking, Terza (1998),
endogenous switching model for count data,
</p>
</li>
<li> <p><code>turnout</code>: Turnout in Texas liquor referenda, Coate and Conlin
(2004), non-degenerate Vuong test,
</p>
</li>
<li> <p><code>twa</code>: Temporary help jobs and permanent employment, Ichino,
Mealli and Nannicini (2008), matching.
</p>
</li></ul>

</li>
<li><p> vignettes:
</p>

<ul>
<li><p> charitable: Estimating the Tobit-1 model with the charitable
data set
</p>
</li>
<li><p> escount: Endogenous switching or sample selection models for
count data
</p>
</li>
<li><p> expreg: Exponentional conditional mean models with endogeneity
</p>
</li>
<li><p> ndvvuong: Implementation of Shi's non-degeranate Vuong test
</p>
</li></ul>

</li></ul>

<p>We tried to keep the sets of package on which <strong>micsr</strong> depends on
as small as possible. <strong>micsr</strong> depends on <strong>Formula</strong>,
<strong>generics</strong>, <strong>Rdpack</strong>, <strong>knitr</strong>, <strong>sandwich</strong> and on a subset
of the <strong>tidyverse</strong> metapackage (<strong>ggplot2</strong>, <strong>dplyr</strong>,
<strong>purrr</strong>, <strong>tidyselect</strong>, <strong>magrittr</strong>, <strong>tibble</strong>, <strong>rlang</strong>). We
borrowed the gaussian quadrature function from the <strong>statmod</strong>
package (Smyth and al., 2023), and the distribution function of
quadratic forms in normal variables from the <strong>CompQuadForm</strong>
package (Duchesne and Lafaye, 2010).
</p>


<h3>References</h3>

<p>Abiad A, Mody A (2005).
&ldquo;Financial Reform: What Shakes It? What Shapes It?&rdquo;
<em>American Economic Review</em>, <b>95</b>(1), 66-88.
</p>
<p>Adkins LC (2012).
&ldquo;Testing parameter significance in instrumental variables probit estimators: some simulation.&rdquo;
<em>Journal of Statistical Computation and Simulation</em>, <b>82</b>(10), 1415-1436.
</p>
<p>Coate S, Conlin M (2004).
&ldquo;A Group Rule-Utilitarian Approach to Voter Turnout: Theory and Evidence.&rdquo;
<em>American Economic Review</em>, <b>94</b>(5), 1476-1504.
</p>
<p>Dehejia RH, Wahba S (2002).
&ldquo;Propensity Score-Matching Methods for Nonexperimental Causal Studies.&rdquo;
<em>The Review of Economics and Statistics</em>, <b>84</b>(1), 151-161.
ISSN 0034-6535, <a href="https://doi.org/10.1162/003465302317331982">doi:10.1162/003465302317331982</a>.
</p>
<p>Duchesne P, de Micheaux PL (2010).
&ldquo;Computing the distribution of quadratic forms: Further comparisons between the Liu-Tang-Zhang approximation and exact methods.&rdquo;
<em>Computational Statistics and Data Analysis</em>, <b>54</b>, 858-862.
</p>
<p>Hausman JA (1978).
&ldquo;Specification Tests in Econometrics.&rdquo;
<em>Econometrica</em>, <b>46</b>(6), 1251&ndash;1271.
</p>
<p>Ichino A, Mealli F, Nannicini T (2008).
&ldquo;From Temporary Help Jobs to Permanent Employment: What Can We Learn from Matching Estimators and Their Sensitivity?&rdquo;
<em>Journal of Applied Econometrics</em>, <b>23</b>(3), 305&ndash;327.
</p>
<p>Ivaldi M, Ladoux N, Ossard H, Simioni M (1996).
&ldquo;Comparing Fourier and translog specifications of multiproduct technology: Evidence from an incomplete panel of French farmers.&rdquo;
<em>Journal of Applied Econometrics</em>, <b>11</b>(6), 649&ndash;667.
<a href="https://doi.org/10.1002/%28sici%291099-1255%28199611%2911%3A6%3C649%3A%3Aaid-jae416%3E3.0.co%3B2-4">doi:10.1002/(sici)1099-1255(199611)11:6&lt;649::aid-jae416&gt;3.0.co;2-4</a>, <a href="http://dx.doi.org/10.1002/(sici)1099-1255(199611)11:6%3C649::aid-jae416%3E3.0.co;2-4">http://dx.doi.org/10.1002/(sici)1099-1255(199611)11:6&lt;649::aid-jae416&gt;3.0.co;2-4</a>.
</p>
<p>Kenkel DS, Terza JV (2001).
&ldquo;The effect of physician advice on alcohol consumption: count regression with an endogenous treatment effect.&rdquo;
<em>Journal of Applied Econometrics</em>, <b>16</b>(2), 165-184.
</p>
<p>Kerkhofs M, Kooreman P (2003).
&ldquo;Identification and Estimation of a Class of Household Production Models.&rdquo;
<em>Journal of Applied Econometrics</em>, <b>18</b>(3), 337&ndash;369.
</p>
<p>Matschke X, Sherlund SM (2006).
&ldquo;Do Labor Issues Matter in the Determination of U.S. Trade Policy? An Empirical Reevaluation.&rdquo;
<em>American Economic Review</em>, <b>96</b>(1), 405-421.
</p>
<p>Mullahy J (1997).
&ldquo;Instrumental-Variable Estimation of Count Data Models: Applications to Models of Cigarette Smoking Behavior.&rdquo;
<em>The Review of Economics and Statistics</em>, <b>79</b>(4), 586-593.
</p>
<p>Newey WK (1985).
&ldquo;Maximum Likelihood Specification Testing and Conditional Moment Tests.&rdquo;
<em>Econometrica</em>, <b>53</b>(5), 1047&ndash;1070.
</p>
<p>Powell J (1986).
&ldquo;Symmetrically trimed least squares estimators for tobit models.&rdquo;
<em>Econometrica</em>, <b>54</b>, 1435&ndash;1460.
</p>
<p>Rivers D, Vuong QH (1988).
&ldquo;Limited information estimators and exogeneity tests for simultaneous probit models.&rdquo;
<em>Journal of Econometrics</em>, <b>39</b>(3), 347-366.
</p>
<p>Sargan JD (1958).
&ldquo;The Estimation of Economic Relationships using Instrumental Variables.&rdquo;
<em>Econometrica</em>, <b>26</b>(3), 393&ndash;415.
</p>
<p>Shi X (2015).
&ldquo;A nondegenerate Vuong test.&rdquo;
<em>Quantitative Economics</em>, 85-121.
</p>
<p>Smith R, Blundell R (1986).
&ldquo;An Exogeneity Test for a Simultaneous Equation Tobit Model with an Application to Labor Supply.&rdquo;
<em>Econometrica</em>, <b>54</b>(3), 679-85.
</p>
<p>Smyth G, Chen L, Hu Y, Dunn P, Phipson B, Chen Y (2023).
<em>statmod: Statistical Modeling</em>.
R package version 1.5.0, <a href="https://CRAN.R-project.org/package=statmod">https://CRAN.R-project.org/package=statmod</a>.
</p>
<p>Tauchen G (1985).
&ldquo;Diagnostic testing and evaluation of maximum likelihood models.&rdquo;
<em>Journal of Econometrics</em>, <b>30</b>(1), 415-443.
</p>
<p>Terza JV (1998).
&ldquo;Estimating count data models with endogenous switching: Sample selection and endogenous treatment effects.&rdquo;
<em>Journal of Econometrics</em>, <b>84</b>(1), 129-154.
</p>
<p>Tobin J (1958).
&ldquo;Estimation of Relationships for Limited Dependent Variables.&rdquo;
<em>Econometrica</em>, <b>26</b>(1), 24-36.
</p>
<p>Vuong QH (1989).
&ldquo;Likelihood Ratio Tests for Selection and Non-Nested Hypotheses.&rdquo;
<em>Econometrica</em>, <b>57</b>(2), 397-333.
</p>
<p>Wilhelm MO (2008).
&ldquo;Practical Considerations for Choosing Between Tobit and SCLS or CLAD Estimators for Censored Regression Models with an Application to Charitable Giving.&rdquo;
<em>Oxford Bulletin of Economics and Statistics</em>, <b>70</b>(4), 559-582.
</p>

<hr>
<h2 id='apples'>Apple production</h2><span id='topic+apples'></span>

<h3>Description</h3>

<p>yearly observations of 173 farms from 1984 to 1986
</p>


<h3>Format</h3>

<p>a tibble containing:
</p>

<ul>
<li><p> id: farm's id
</p>
</li>
<li><p> year: year
</p>
</li>
<li><p> capital: capital stock
</p>
</li>
<li><p> labor: quantity of labor
</p>
</li>
<li><p> materials: quantity of materials
</p>
</li>
<li><p> apples: production of apples
</p>
</li>
<li><p> otherprod: other productions
</p>
</li>
<li><p> pc: price of capital
</p>
</li>
<li><p> pl: price of labor
</p>
</li>
<li><p> pm: price of materials
</p>
</li></ul>



<h3>Source</h3>

<p>Journal of Applied Econometrics Data Archive : <a href="http://qed.econ.queensu.ca/jae/">http://qed.econ.queensu.ca/jae/</a>
</p>


<h3>References</h3>

<p>Ivaldi M, Ladoux N, Ossard H, Simioni M (1996).
&ldquo;Comparing Fourier and translog specifications of multiproduct technology: Evidence from an incomplete panel of French farmers.&rdquo;
<em>Journal of Applied Econometrics</em>, <b>11</b>(6), 649&ndash;667.
<a href="https://doi.org/10.1002/%28sici%291099-1255%28199611%2911%3A6%3C649%3A%3Aaid-jae416%3E3.0.co%3B2-4">doi:10.1002/(sici)1099-1255(199611)11:6&lt;649::aid-jae416&gt;3.0.co;2-4</a>, <a href="http://dx.doi.org/10.1002/(sici)1099-1255(199611)11:6%3C649::aid-jae416%3E3.0.co;2-4">http://dx.doi.org/10.1002/(sici)1099-1255(199611)11:6&lt;649::aid-jae416&gt;3.0.co;2-4</a>.
</p>

<hr>
<h2 id='binmeans'>Compute the mean of a variable for bins of another variable</h2><span id='topic+binmeans'></span><span id='topic+binmeans.default'></span><span id='topic+binmeans.formula'></span><span id='topic+StatBinmeans'></span><span id='topic+geom_binmeans'></span>

<h3>Description</h3>

<p>Plot average values of the outcome for bins of the forcing
variable, a common plot in regression discontinuity analysis
</p>


<h3>Usage</h3>

<pre><code class='language-R'>binmeans(x, y, width = NULL, center = NULL, g = NULL, ...)

## Default S3 method:
binmeans(x, y, width = NULL, center = NULL, g = NULL, ..., name_g = "colour")

## S3 method for class 'formula'
binmeans(x, y, width = NULL, center = NULL, ...)

StatBinmeans

geom_binmeans(
  mapping = NULL,
  data = NULL,
  stat = "binmeans",
  position = "identity",
  ...,
  center = NULL,
  width = NULL,
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="binmeans_+3A_x">x</code>, <code id="binmeans_+3A_y">y</code></td>
<td>
<p>either two numeric vector for the default method, or a
formula and a data frame for the formula method</p>
</td></tr>
<tr><td><code id="binmeans_+3A_width">width</code></td>
<td>
<p>the width of the bins</p>
</td></tr>
<tr><td><code id="binmeans_+3A_center">center</code></td>
<td>
<p>the cuting value of the forcing variable</p>
</td></tr>
<tr><td><code id="binmeans_+3A_g">g</code></td>
<td>
<p>a grouping variable</p>
</td></tr>
<tr><td><code id="binmeans_+3A_...">...</code></td>
<td>
<p>further arguments</p>
</td></tr>
<tr><td><code id="binmeans_+3A_name_g">name_g</code></td>
<td>
<p>internally used by the geom</p>
</td></tr>
<tr><td><code id="binmeans_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code><a href="ggplot2.html#topic+aes">aes()</a></code>. If specified and
<code>inherit.aes = TRUE</code> (the default), it is combined with the default mapping
at the top level of the plot. You must supply <code>mapping</code> if there is no plot
mapping.</p>
</td></tr>
<tr><td><code id="binmeans_+3A_data">data</code></td>
<td>
<p>The data to be displayed in this layer. There are three
options:
</p>
<p>If <code>NULL</code>, the default, the data is inherited from the plot
data as specified in the call to <code><a href="ggplot2.html#topic+ggplot">ggplot()</a></code>.
</p>
<p>A <code>data.frame</code>, or other object, will override the plot
data. All objects will be fortified to produce a data frame. See
<code><a href="ggplot2.html#topic+fortify">fortify()</a></code> for which variables will be created.
</p>
<p>A <code>function</code> will be called with a single argument,
the plot data. The return value must be a <code>data.frame</code>, and
will be used as the layer data. A <code>function</code> can be created
from a <code>formula</code> (e.g. <code>~ head(.x, 10)</code>).</p>
</td></tr>
<tr><td><code id="binmeans_+3A_stat">stat</code></td>
<td>
<p>The statistical transformation to use on the data for this
layer, either as a <code>ggproto</code> <code>Geom</code> subclass or as a string naming the
stat stripped of the <code>stat_</code> prefix (e.g. <code>"count"</code> rather than
<code>"stat_count"</code>)</p>
</td></tr>
<tr><td><code id="binmeans_+3A_position">position</code></td>
<td>
<p>Position adjustment, either as a string naming the adjustment
(e.g. <code>"jitter"</code> to use <code>position_jitter</code>), or the result of a call to a
position adjustment function. Use the latter if you need to change the
settings of the adjustment.</p>
</td></tr>
<tr><td><code id="binmeans_+3A_na.rm">na.rm</code></td>
<td>
<p>If <code>FALSE</code>, the default, missing values are removed with
a warning. If <code>TRUE</code>, missing values are silently removed.</p>
</td></tr>
<tr><td><code id="binmeans_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped.
<code>FALSE</code> never includes, and <code>TRUE</code> always includes.
It can also be a named logical vector to finely select the aesthetics to
display.</p>
</td></tr>
<tr><td><code id="binmeans_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics,
rather than combining with them. This is most useful for helper functions
that define both data and aesthetics and shouldn't inherit behaviour from
the default plot specification, e.g. <code><a href="ggplot2.html#topic+borders">borders()</a></code>.</p>
</td></tr>
</table>


<h3>Format</h3>

<p>An object of class <code>StatBinmeans</code> (inherits from <code>Stat</code>, <code>ggproto</code>, <code>gg</code>) of length 4.
</p>

<hr>
<h2 id='binomreg'>Binomial regression</h2><span id='topic+binomreg'></span><span id='topic+residuals.binomreg'></span><span id='topic+glance.binomreg'></span><span id='topic+predict.binomreg'></span>

<h3>Description</h3>

<p>A unified interface for binomial regression models, including
linear probability, probit and logit models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>binomreg(
  formula,
  data,
  weights,
  subset,
  na.action,
  offset,
  contrasts = NULL,
  link = c("identity", "probit", "logit"),
  method = c("ml", "twosteps", "minchisq", "test"),
  start = NULL,
  ...
)

## S3 method for class 'binomreg'
residuals(object, ..., type = c("deviance", "pearson", "response"))

## S3 method for class 'binomreg'
glance(x, ...)

## S3 method for class 'binomreg'
predict(object, ..., type = c("response", "link"), newdata = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="binomreg_+3A_formula">formula</code></td>
<td>
<p>a symbolic description of the model</p>
</td></tr>
<tr><td><code id="binomreg_+3A_data">data</code></td>
<td>
<p>a data frame,</p>
</td></tr>
<tr><td><code id="binomreg_+3A_subset">subset</code>, <code id="binomreg_+3A_weights">weights</code>, <code id="binomreg_+3A_na.action">na.action</code>, <code id="binomreg_+3A_offset">offset</code>, <code id="binomreg_+3A_contrasts">contrasts</code></td>
<td>
<p>see <code>stats::lm</code>,</p>
</td></tr>
<tr><td><code id="binomreg_+3A_link">link</code></td>
<td>
<p>one of <code>"identity"</code>, <code>"probit"</code> and &quot;<code>logit</code>&quot; to fit
respectively the linear probability, the probit and the logit
model</p>
</td></tr>
<tr><td><code id="binomreg_+3A_method">method</code></td>
<td>
<p><code>"ml"</code> for maximum likelihood (the only relevant
method for a regression without instrumental variables),
<code>"twosteps"</code> for two-steps estimator, <code>"minchisq"</code> for minimum
chi-squared estimator and <code>"test"</code> to get the exogeneity test</p>
</td></tr>
<tr><td><code id="binomreg_+3A_start">start</code></td>
<td>
<p>a vector of starting values</p>
</td></tr>
<tr><td><code id="binomreg_+3A_...">...</code></td>
<td>
<p>further arguments</p>
</td></tr>
<tr><td><code id="binomreg_+3A_object">object</code>, <code id="binomreg_+3A_x">x</code>, <code id="binomreg_+3A_type">type</code></td>
<td>
<p>a <code>binomreg</code> object and the type of residuals
for the <code>residuals</code> method</p>
</td></tr>
<tr><td><code id="binomreg_+3A_newdata">newdata</code></td>
<td>
<p>a new data frame for the <code>predict</code> method</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class <code>c("binomreg", "micsr")</code>, see
<code>micsr::micsr</code> for further details
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pbt &lt;- binomreg(mode ~ cost + ivtime + ovtime, data = mode_choice, link = 'probit')
lpm &lt;- binomreg(mode ~ cost + ivtime + ovtime, data = mode_choice, link = 'identity')
summary(pbt, vcov = "opg")
</code></pre>

<hr>
<h2 id='birthwt'>Cigarette smoking and birth weight</h2><span id='topic+birthwt'></span>

<h3>Description</h3>

<p>a cross-section of 1388 individuals from 1988
</p>


<h3>Format</h3>

<p>a tibble containing:
</p>

<ul>
<li><p> birthwt: birth weight
</p>
</li>
<li><p> cigarettes: number of cigarettes smoked per day during pregnancy
</p>
</li>
<li><p> parity: birth order
</p>
</li>
<li><p> race: a factor with levels <code>"other"</code> and <code>"white"</code>
</p>
</li>
<li><p> sex: a factor with levels <code>"female"</code> and <code>"male"</code>
</p>
</li>
<li><p> edmother: number of years of education of the mother
</p>
</li>
<li><p> edfather: number of years of education of the father
</p>
</li>
<li><p> faminc: family income
</p>
</li>
<li><p> cigtax: per-pack state excise tax on cigarettes
</p>
</li></ul>



<h3>Source</h3>

<p>kindly provided by John Mullahy
</p>


<h3>References</h3>

<p>Mullahy J (1997).
&ldquo;Instrumental-Variable Estimation of Count Data Models: Applications to Models of Cigarette Smoking Behavior.&rdquo;
<em>The Review of Economics and Statistics</em>, <b>79</b>(4), 586-593.
</p>

<hr>
<h2 id='bivprobit'>Bivariate probit</h2><span id='topic+bivprobit'></span><span id='topic+logLik.bivprobit'></span>

<h3>Description</h3>

<p>Estimation of bivariate probit models by maximum likelihood
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bivprobit(
  formula,
  data,
  weights,
  subset,
  na.action,
  offset,
  method = c("newton", "bfgs"),
  ...
)

## S3 method for class 'bivprobit'
logLik(object, ..., type = c("model", "null"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bivprobit_+3A_formula">formula</code></td>
<td>
<p>a symbolic description of the model, a two-part left
and right hand side formula</p>
</td></tr>
<tr><td><code id="bivprobit_+3A_data">data</code></td>
<td>
<p>a data frame,</p>
</td></tr>
<tr><td><code id="bivprobit_+3A_subset">subset</code>, <code id="bivprobit_+3A_weights">weights</code>, <code id="bivprobit_+3A_na.action">na.action</code>, <code id="bivprobit_+3A_offset">offset</code></td>
<td>
<p>see <code>stats::lm</code>,</p>
</td></tr>
<tr><td><code id="bivprobit_+3A_method">method</code></td>
<td>
<p>the optimization method, one of <code>"newton"</code> and
<code>"bfgs"</code></p>
</td></tr>
<tr><td><code id="bivprobit_+3A_...">...</code></td>
<td>
<p>further arguments</p>
</td></tr>
<tr><td><code id="bivprobit_+3A_object">object</code></td>
<td>
<p>a <code>bivprobit</code> object</p>
</td></tr>
<tr><td><code id="bivprobit_+3A_type">type</code></td>
<td>
<p>for the <code>logLik</code> method</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class <code>micsr</code>, see <code>micsr::micsr</code> for further
details
</p>


<h3>Examples</h3>

<pre><code class='language-R'>bivprobit(mjob | fjob ~ meduc + ychild + owner | feduc + ychild + owner , housprod)
</code></pre>

<hr>
<h2 id='charitable'>Intergenerational transmission of charitable giving</h2><span id='topic+charitable'></span>

<h3>Description</h3>

<p>a cross-section of 2384 households from 2001
</p>


<h3>Format</h3>

<p>a tibble containing:
</p>

<ul>
<li><p> donation: the amount of charitable giving
</p>
</li>
<li><p> donparents: the amount of charitable giving of the parents
</p>
</li>
<li><p> education: the level of education of household's head, a factor with levels <code>"less_high_school"</code>, <code>"high_school"</code>, <code>"some_college"</code>, <code>"college"</code>, <code>"post_college"</code>
</p>
</li>
<li><p> religion: a factor with levels <code>"none"</code>, <code>"catholic"</code>, <code>"protestant"</code>, <code>"jewish"</code> and <code>"other"</code>
</p>
</li>
<li><p> income: income
</p>
</li>
<li><p> married: a dummy for married couples
</p>
</li>
<li><p> south: a dummy for households living in the south
</p>
</li></ul>



<h3>Source</h3>

<p>kindly provided by Mark Ottoni Wilhelm.
</p>


<h3>References</h3>

<p>Wilhelm MO (2008).
&ldquo;Practical Considerations for Choosing Between Tobit and SCLS or CLAD Estimators for Censored Regression Models with an Application to Charitable Giving.&rdquo;
<em>Oxford Bulletin of Economics and Statistics</em>, <b>70</b>(4), 559-582.
</p>

<hr>
<h2 id='cigmales'>Cigarette smoking behaviour</h2><span id='topic+cigmales'></span>

<h3>Description</h3>

<p>a cross-section of 6160 individuals from 1979 to 1980
</p>


<h3>Format</h3>

<p>a tibble containing:
</p>

<ul>
<li><p> cigarettes: number of daily cigarettes smoked
</p>
</li>
<li><p> habit: smoking habit stock measure
</p>
</li>
<li><p> price: state-level average per-pack price of cigarettes in 1979
</p>
</li>
<li><p> restaurant: an indicator of whether the individual's state of residence had restrictions on smoking in restaurants in place in 1979
</p>
</li>
<li><p> income: family income in thousands
</p>
</li>
<li><p> age: age in years
</p>
</li>
<li><p> educ: schooling in years
</p>
</li>
<li><p> famsize: number of family members
</p>
</li>
<li><p> race: a factor with levels <code>"other"</code> and <code>"white"</code>
</p>
</li>
<li><p> reslgth: number of years the state's restaurant smoking restrictions had been in place in 1979
</p>
</li>
<li><p> lagprice: one-year lag of cigarette price
</p>
</li></ul>



<h3>Source</h3>

<p>kindly provided by John Mullahy
</p>


<h3>References</h3>

<p>Mullahy J (1997).
&ldquo;Instrumental-Variable Estimation of Count Data Models: Applications to Models of Cigarette Smoking Behavior.&rdquo;
<em>The Review of Economics and Statistics</em>, <b>79</b>(4), 586-593.
</p>

<hr>
<h2 id='clm'>Constrained least squares</h2><span id='topic+clm'></span><span id='topic+vcov.clm'></span><span id='topic+summary.clm'></span>

<h3>Description</h3>

<p>Compute the least squares estimator using linear constrains on the
coefficients.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clm(x, R, q = NULL)

## S3 method for class 'clm'
vcov(object, ...)

## S3 method for class 'clm'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="clm_+3A_x">x</code></td>
<td>
<p>a linear model fitted by <code>lm</code>,</p>
</td></tr>
<tr><td><code id="clm_+3A_r">R</code></td>
<td>
<p>a matrix of constrains (one line for each constrain, one
column for each coefficient),</p>
</td></tr>
<tr><td><code id="clm_+3A_q">q</code></td>
<td>
<p>an optional vector of rhs values (by default a vector of
0)</p>
</td></tr>
<tr><td><code id="clm_+3A_object">object</code></td>
<td>
<p>a <code>clm</code> object for the <code>summary</code> and the <code>vcov</code>
methods</p>
</td></tr>
<tr><td><code id="clm_+3A_...">...</code></td>
<td>
<p>further arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class <code>clm</code> which inherits from class <code>lm</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Cobb-Douglas production function for the apple data set
# First compute the total production
apples &lt;- apples %&gt;% mutate(prod = apples + otherprod)
# unconstrained linear model
cd &lt;- lm(log(prod) ~ log(capital) + log(labor) +
         log(materials), apples)
# constrained linear model imposing constant
# return to scales
crs &lt;- clm(cd, R = matrix(c(0, 1, 1, 1), nrow = 1),
               q = 1)
</code></pre>

<hr>
<h2 id='cmtest'>Conditional moments test</h2><span id='topic+cmtest'></span><span id='topic+cmtest.tobit'></span><span id='topic+cmtest.micsr'></span><span id='topic+cmtest.censReg'></span><span id='topic+cmtest.glm'></span>

<h3>Description</h3>

<p>Conditional moments tests for maximum likelihood estimators,
particularly convenient for the probit and the tobit model to test
relevance of functional form, omitted variables, heteroscedasticity and
normality.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cmtest(
  x,
  test = c("normality", "reset", "heterosc", "skewness", "kurtosis"),
  powers = 2:3,
  heter_cov = NULL,
  opg = FALSE
)

## S3 method for class 'tobit'
cmtest(
  x,
  test = c("normality", "reset", "heterosc", "skewness", "kurtosis"),
  powers = 2:3,
  heter_cov = NULL,
  opg = FALSE
)

## S3 method for class 'micsr'
cmtest(
  x,
  test = c("normality", "reset", "heterosc", "skewness", "kurtosis"),
  powers = 2:3,
  heter_cov = NULL,
  opg = FALSE
)

## S3 method for class 'censReg'
cmtest(
  x,
  test = c("normality", "reset", "heterosc", "skewness", "kurtosis"),
  powers = 2:3,
  heter_cov = NULL,
  opg = FALSE
)

## S3 method for class 'glm'
cmtest(
  x,
  test = c("normality", "reset", "heterosc", "skewness", "kurtosis"),
  powers = 2:3,
  heter_cov = NULL,
  opg = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cmtest_+3A_x">x</code></td>
<td>
<p>a fitted model, currently a tobit model either fitted by
<code>AER::tobit</code>, <code>censReg::censReg</code> or <code>micsr::tobit1</code> or a probit model fitted by
<code>glm</code> with <code>family = binomial(link = "probit")</code> or by <code>micsr::binomreg</code> with <code>link = "probit"</code></p>
</td></tr>
<tr><td><code id="cmtest_+3A_test">test</code></td>
<td>
<p>the kind of test to be performed, either a normality
test (or separately a test that the skewness or kurtosis
are 0 and 3), a heteroscedasticity test or a reset
test,</p>
</td></tr>
<tr><td><code id="cmtest_+3A_powers">powers</code></td>
<td>
<p>the powers of the fitted values that should be used
in the reset test,</p>
</td></tr>
<tr><td><code id="cmtest_+3A_heter_cov">heter_cov</code></td>
<td>
<p>a one side formula that indicates the covariates
that should be used for the heteroscedasticity test (by default
all the covariates used in the regression are used),</p>
</td></tr>
<tr><td><code id="cmtest_+3A_opg">opg</code></td>
<td>
<p>a boolean, if <code>FALSE</code> (the default), the analytic
derivatives are used, otherwise the outer product of the
gradient formula is used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class <code>"htest"</code> containing the following components:
</p>

<ul>
<li><p> data.mane: a character string describing the fitted model
</p>
</li>
<li><p> statistic: the value of the test statistic
</p>
</li>
<li><p> parameter: degrees of freedom
</p>
</li>
<li><p> p.value: the p.value of the test
</p>
</li>
<li><p> method: a character indicating what type of test is performed
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Yves Croissant
</p>


<h3>References</h3>

<p>Newey WK (1985).
&ldquo;Maximum Likelihood Specification Testing and Conditional Moment Tests.&rdquo;
<em>Econometrica</em>, <b>53</b>(5), 1047&ndash;1070.
</p>
<p>Pagan A, Vella F (1989).
&ldquo;Diagnostic Tests for Models Based on Individual Data: A Survey.&rdquo;
<em>Journal of Applied Econometrics</em>, <b>4</b>, S29&ndash;S59.
</p>
<p>Tauchen G (1985).
&ldquo;Diagnostic testing and evaluation of maximum likelihood models.&rdquo;
<em>Journal of Econometrics</em>, <b>30</b>(1), 415-443.
</p>
<p>Wells C (2003).
&ldquo;Retesting Fair's (1978) Model on Infidelity.&rdquo;
<em>Journal of Applied Econometrics</em>, <b>18</b>(2), 237&ndash;239.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>charitable$logdon &lt;- with(charitable, log(donation) - log(25))
ml &lt;- tobit1(logdon ~ log(donparents) + log(income) + education +
             religion + married + south, data = charitable)
cmtest(ml, test = "heterosc")
cmtest(ml, test = "normality", opg = TRUE)
</code></pre>

<hr>
<h2 id='drinks'>Physician advice on alcohol consumption</h2><span id='topic+drinks'></span>

<h3>Description</h3>

<p>a cross-section of 2467 individuals from 1990
</p>


<h3>Format</h3>

<p>a tibble containing:
</p>

<ul>
<li><p> drinks: number of drinks in the past 2 weeks
</p>
</li>
<li><p> advice: 1 if reveived a drining advice
</p>
</li>
<li><p> age: age in 10 years cathegories
</p>
</li>
<li><p> race: a factor with levels <code>"white"</code>, <code>"black"</code> and <code>"other"</code>
</p>
</li>
<li><p> marital: marital status, one of <code>"single"</code>, <code>"married"</code>, <code>"widow"</code>, <code>"separated"</code>
</p>
</li>
<li><p> region: one of <code>"west"</code>, <code>"northeast"</code>, <code>"midwest"</code> and <code>"south"</code>
</p>
</li>
<li><p> empstatus: one of <code>"other"</code>, <code>"emp"</code> and <code>"unemp"</code>
</p>
</li>
<li><p> limits: limits on daily activities, one of <code>"none"</code>, <code>"some"</code> and <code>"major"</code>
</p>
</li>
<li><p> income: monthly income ($1000)
</p>
</li>
<li><p> educ: education in years
</p>
</li>
<li><p> medicare: insurance through medicare
</p>
</li>
<li><p> medicaid: insurance through medicaid
</p>
</li>
<li><p> champus: military insurance
</p>
</li>
<li><p> hlthins: health insurance
</p>
</li>
<li><p> regmed: regoular source of care
</p>
</li>
<li><p> dri: see same doctor
</p>
</li>
<li><p> diabete: have diabetes
</p>
</li>
<li><p> hearthcond: have heart condition
</p>
</li>
<li><p> stroke: have stroke
</p>
</li></ul>



<h3>Source</h3>

<p>JAE data archive
</p>


<h3>References</h3>

<p>Kenkel DS, Terza JV (2001).
&ldquo;The effect of physician advice on alcohol consumption: count regression with an endogenous treatment effect.&rdquo;
<em>Journal of Applied Econometrics</em>, <b>16</b>(2), 165-184.
</p>

<hr>
<h2 id='dummy'>Transform a factor in a set of dummy variables</h2><span id='topic+dummy'></span>

<h3>Description</h3>

<p>The normal way to store cathegorical variables in R is to use
factors, each modality being a level of this factor. Sometimes
however, is is more convenient to use a set of dummy variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dummy(x, ..., keep = FALSE, prefix = NULL, ref = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dummy_+3A_x">x</code></td>
<td>
<p>a data frame</p>
</td></tr>
<tr><td><code id="dummy_+3A_...">...</code></td>
<td>
<p>series of the data frame, should be factors</p>
</td></tr>
<tr><td><code id="dummy_+3A_keep">keep</code></td>
<td>
<p>a boolean, if <code>TRUE</code>, the original series is kept in
the data frame,</p>
</td></tr>
<tr><td><code id="dummy_+3A_prefix">prefix</code></td>
<td>
<p>an optional prefix for the names of the computed
dummies,</p>
</td></tr>
<tr><td><code id="dummy_+3A_ref">ref</code></td>
<td>
<p>a boolean, if <code>TRUE</code>, a dummy is created for all the
levels, including the reference level</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data frame
</p>


<h3>Examples</h3>

<pre><code class='language-R'>charitable %&gt;% dummy(religion, education)
</code></pre>

<hr>
<h2 id='escount'>Endogenous switching and sample selection models for count data</h2><span id='topic+escount'></span>

<h3>Description</h3>

<p>Heckman's like estimator for count data, using either
maximum likelihood or a two-steps estimator
</p>


<h3>Usage</h3>

<pre><code class='language-R'>escount(
  formula,
  data,
  subset,
  weights,
  na.action,
  offset,
  start = NULL,
  R = 16,
  hessian = FALSE,
  method = c("twosteps", "ml"),
  model = c("es", "ss")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="escount_+3A_formula">formula</code></td>
<td>
<p>a <code>Formula</code> object which includes two responses (the
count and the binomial variables) and two sets of covariates
(for the count component and for the selection equation)</p>
</td></tr>
<tr><td><code id="escount_+3A_data">data</code></td>
<td>
<p>a data frame,</p>
</td></tr>
<tr><td><code id="escount_+3A_subset">subset</code>, <code id="escount_+3A_weights">weights</code>, <code id="escount_+3A_na.action">na.action</code>, <code id="escount_+3A_offset">offset</code></td>
<td>
<p>see <code>stats::lm</code></p>
</td></tr>
<tr><td><code id="escount_+3A_start">start</code></td>
<td>
<p>an optional vector of starting values,</p>
</td></tr>
<tr><td><code id="escount_+3A_r">R</code></td>
<td>
<p>the number of points for the Gauss-Hermite quadrature</p>
</td></tr>
<tr><td><code id="escount_+3A_hessian">hessian</code></td>
<td>
<p>if <code>TRUE</code>, the numerical hessian is computed,
otherwise the covariance matrix of the coefficients is computed
using the outer product of the gradient</p>
</td></tr>
<tr><td><code id="escount_+3A_method">method</code></td>
<td>
<p>one of <code>'ML'</code> for maximum likelihood estimation (the
default) or <code>'twosteps'</code> for the two-steps NLS method</p>
</td></tr>
<tr><td><code id="escount_+3A_model">model</code></td>
<td>
<p>one of <code>'es'</code> for endogenous switching (the default)
or <code>'ss'</code> for sample selection</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class <code style="white-space: pre;">&#8288;c("escount,micsr)"&#8288;</code>, see <code>micsr::micsr</code> for further details.
</p>


<h3>Author(s)</h3>

<p>Yves Croissant
</p>


<h3>References</h3>

<p>Terza JV (1998).
&ldquo;Estimating count data models with endogenous switching: Sample selection and endogenous treatment effects.&rdquo;
<em>Journal of Econometrics</em>, <b>84</b>(1), 129-154.
</p>
<p>Greene WH (2001).
&ldquo;Fiml Estimation of Sample Selection Models for Count Data.&rdquo;
In Negishi T, Ramachandran RV, Mino K (eds.), <em>Economic Theory, Dynamics and Markets: Essays in Honor of Ryuzo Sato</em>, chapter 6, 73&ndash;91.
Springer US, Boston, MA.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>trips_2s &lt;- escount(trips | car ~ workschl + size + dist + smsa + fulltime + distnod +
realinc + weekend + car | . - car - weekend + adults, data = trips, method = "twosteps")
trips_ml &lt;- update(trips_2s, method = "ml")
</code></pre>

<hr>
<h2 id='expreg'>Instrumental variable estimation for exponential conditional mean
models</h2><span id='topic+expreg'></span>

<h3>Description</h3>

<p>Exponential conditional mean models are particularly useful for
non-negative responses (including count data). Least squares and one or two steps
IV estimators are available
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expreg(
  formula,
  data,
  subset,
  weights,
  na.action,
  offset,
  method = c("iv", "gmm", "ls"),
  error = c("mult", "add"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="expreg_+3A_formula">formula</code></td>
<td>
<p>a two-part right hand side formula, the first part
describing the covariates and the second part the instruments</p>
</td></tr>
<tr><td><code id="expreg_+3A_data">data</code></td>
<td>
<p>a data frame,</p>
</td></tr>
<tr><td><code id="expreg_+3A_subset">subset</code>, <code id="expreg_+3A_weights">weights</code>, <code id="expreg_+3A_na.action">na.action</code>, <code id="expreg_+3A_offset">offset</code></td>
<td>
<p>see <code>stats::lm</code></p>
</td></tr>
<tr><td><code id="expreg_+3A_method">method</code></td>
<td>
<p>one of <code>"gmm"</code> (the default), <code>"iv"</code> or <code>ls</code>.</p>
</td></tr>
<tr><td><code id="expreg_+3A_error">error</code></td>
<td>
<p>one of <code>"mult"</code> (the default) or <code>"add"</code> in order to
get a model with respectively a multiplicative or an additive
error</p>
</td></tr>
<tr><td><code id="expreg_+3A_...">...</code></td>
<td>
<p>further arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class <code>"micsr"</code>, see <code>micsr::micsr</code> for further details.
</p>


<h3>Author(s)</h3>

<p>Yves Croissant
</p>


<h3>References</h3>

<p>Mullahy J (1997).
&ldquo;Instrumental-Variable Estimation of Count Data Models: Applications to Models of Cigarette Smoking Behavior.&rdquo;
<em>The Review of Economics and Statistics</em>, <b>79</b>(4), 586-593.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cigmales &lt;- dplyr::mutate(cigmales,
                          age2 = age ^ 2, educ2 = educ ^ 2, educage = educ * age,
                          age3 = age ^ 3, educ3 = educ ^ 3)
expreg(cigarettes ~ habit + price + restaurant + income + age + age2 + educ + educ2 +
                     famsize + race | . - habit + reslgth + lagprice + age3 + educ3 + educage,
                     data = cigmales)
expreg(birthwt ~ cigarettes + parity + race + sex | parity + race + sex +
                  edmother + edfather + faminc + cigtax, data = birthwt)
</code></pre>

<hr>
<h2 id='federiv'>Foreign exchange derivatives use by large US bank holding companies</h2><span id='topic+federiv'></span>

<h3>Description</h3>

<p>a cross-section of 794 banks from 1996 to 2000
</p>


<h3>Format</h3>

<p>a tibble containing:
</p>

<ul>
<li><p> federiv: foreign exchange derivatives use, a dummy
</p>
</li>
<li><p> optval: option awards
</p>
</li>
<li><p> eqrat: leverage
</p>
</li>
<li><p> bonus: bonus
</p>
</li>
<li><p> ltass: logarithm of total assets
</p>
</li>
<li><p> linsown: logarithm of the percentage of the total shares outstanding that are owned by officers and directors
</p>
</li>
<li><p> linstown: logarithm of the percentage of the total shares outstanding that are owned by all institutional investors
</p>
</li>
<li><p> roe: return on equity
</p>
</li>
<li><p> mktbk: market to book ratio
</p>
</li>
<li><p> perfor: foreign to total interest income ratio
</p>
</li>
<li><p> dealdum: derivative dealer activity dummy
</p>
</li>
<li><p> div: dividends paid
</p>
</li>
<li><p> year: year, from 1996 to 2000
</p>
</li>
<li><p> no_emp: number of employees
</p>
</li>
<li><p> no_subs: number of subsidiaries
</p>
</li>
<li><p> no_off: number of offices
</p>
</li>
<li><p> ceo_age: CEO age
</p>
</li>
<li><p> gap: 12 month maturity mismatch
</p>
</li>
<li><p> cfa: ratio of cash flow to total assets
</p>
</li></ul>



<h3>Source</h3>

<p>Lee Adkin's home page <a href="https://learneconometrics.com/">https://learneconometrics.com/</a>
</p>


<h3>References</h3>

<p>Adkins LC (2012).
&ldquo;Testing parameter significance in instrumental variables probit estimators: some simulation.&rdquo;
<em>Journal of Statistical Computation and Simulation</em>, <b>82</b>(10), 1415-1436.
</p>
<p>Adkins LC, Carter DA, Simpson WG (2007).
&ldquo;Managerial Incentives And The Use Of Foreign‐Exchange Derivatives By Banks.&rdquo;
<em>Journal of Financial Research</em>, <b>30</b>(3), 399-413.
</p>

<hr>
<h2 id='fin_reform'>Political economy of financial reforms</h2><span id='topic+fin_reform'></span>

<h3>Description</h3>

<p>a pseudo-panel of 35 countries from 1973 to 1996
</p>


<h3>Format</h3>

<p>a tibble containing:
</p>

<ul>
<li><p> country: the country id
</p>
</li>
<li><p> year: the year
</p>
</li>
<li><p> region: the region
</p>
</li>
<li><p> pol: political orientation of the government
</p>
</li>
<li><p> fli: degree of policy liberalization index (from 0 to 18)
</p>
</li>
<li><p> yofc: year of office
</p>
</li>
<li><p> gdpg: growth rate of the gdp
</p>
</li>
<li><p> infl: inflation rate
</p>
</li>
<li><p> bop: balance of payments crises
</p>
</li>
<li><p> bank: banking crises
</p>
</li>
<li><p> imf: IMF program dummy
</p>
</li>
<li><p> usint: international interest rates
</p>
</li>
<li><p> open: trade openess
</p>
</li>
<li><p> dindx: difference of the inflation rate
</p>
</li>
<li><p> indx: inflation rate divided by 18
</p>
</li>
<li><p> indxl: lag value of indx
</p>
</li>
<li><p> rhs1: indxl * (1 - indxl)
</p>
</li>
<li><p> max_indxl: maximumum value of indxl by year and region
</p>
</li>
<li><p> catchup: difference between max_indxl and indxl
</p>
</li>
<li><p> dum_bop: balance of paiement crisis in the first two previous years
</p>
</li>
<li><p> dum_bank: bank crises in the first two previous years
</p>
</li>
<li><p> dum_1yofc: dummy for first year of office
</p>
</li>
<li><p> recession: dummy for recessions
</p>
</li>
<li><p> hinfl: dummy for inflation rate greater than 50 percent
</p>
</li></ul>



<h3>Source</h3>

<p>AEA website
</p>


<h3>References</h3>

<p>Abiad A, Mody A (2005).
&ldquo;Financial Reform: What Shakes It? What Shapes It?&rdquo;
<em>American Economic Review</em>, <b>95</b>(1), 66-88.
</p>

<hr>
<h2 id='ftest'>F statistic</h2><span id='topic+ftest'></span><span id='topic+ftest.lm'></span><span id='topic+ftest.ivreg'></span>

<h3>Description</h3>

<p>Extract the F statistic that all the parameters except the
intercept are zero. Currently implemented only for models fitted by <code>lm</code> or <code>ivreg::ivreg</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ftest(x, ...)

## S3 method for class 'lm'
ftest(x, ...)

## S3 method for class 'ivreg'
ftest(x, ..., covariate = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ftest_+3A_x">x</code></td>
<td>
<p>a fitted object</p>
</td></tr>
<tr><td><code id="ftest_+3A_...">...</code></td>
<td>
<p>further arguments</p>
</td></tr>
<tr><td><code id="ftest_+3A_covariate">covariate</code></td>
<td>
<p>the covariate for which the test should be performed for the <code>ivreg</code> method</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class <code>"htest"</code>.
</p>

<hr>
<h2 id='gaze'>Short print of the summary of an object</h2><span id='topic+gaze'></span><span id='topic+gaze.lm'></span><span id='topic+gaze.micsr'></span><span id='topic+gaze.ivreg'></span><span id='topic+gaze.rdrobust'></span><span id='topic+gaze.CJMrddensity'></span><span id='topic+gaze.htest'></span><span id='topic+gaze.anova'></span><span id='topic+gaze.LMtestlist'></span>

<h3>Description</h3>

<p><code>print</code> and <code>print.summary</code> methods often returns long input, which
is suitable for the console, but too verbal for a printed output
like a book or an article written using quarto. <code>gaze</code> is a generic
function which prints a short output
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gaze(x, ...)

## S3 method for class 'lm'
gaze(
  x,
  ...,
  coef = NULL,
  digits = max(3L, getOption("digits") - 3L),
  signif.stars = FALSE
)

## S3 method for class 'micsr'
gaze(
  x,
  ...,
  coef = NULL,
  digits = max(3L, getOption("digits") - 3L),
  signif.stars = FALSE
)

## S3 method for class 'ivreg'
gaze(
  x,
  ...,
  coef,
  digits = max(3L, getOption("digits") - 3L),
  signif.stars = getOption("show.signif.stars")
)

## S3 method for class 'rdrobust'
gaze(x, ..., first_stage = FALSE)

## S3 method for class 'CJMrddensity'
gaze(x, ...)

## S3 method for class 'htest'
gaze(x, ..., digits = 3)

## S3 method for class 'anova'
gaze(x, ..., digits = 3)

## S3 method for class 'LMtestlist'
gaze(x, ..., digits = 3)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gaze_+3A_x">x</code></td>
<td>
<p>an object,</p>
</td></tr>
<tr><td><code id="gaze_+3A_...">...</code></td>
<td>
<p>further arguments for the different methods,</p>
</td></tr>
<tr><td><code id="gaze_+3A_coef">coef</code></td>
<td>
<p>the coefficients to be printed</p>
</td></tr>
<tr><td><code id="gaze_+3A_digits">digits</code></td>
<td>
<p>the number of digits for the <code>lm</code> and the <code>ivreg</code>
methods</p>
</td></tr>
<tr><td><code id="gaze_+3A_signif.stars">signif.stars</code></td>
<td>
<p>a boolean indicating whether the stars should
be printed</p>
</td></tr>
<tr><td><code id="gaze_+3A_first_stage">first_stage</code></td>
<td>
<p>a boolean for the <code>rdrobust::rdrobust</code> method,
if <code>TRUE</code> the results of the first stage estimation are printed</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns invisibly its first argument
</p>


<h3>Examples</h3>

<pre><code class='language-R'>t.test(extra ~ group, sleep) %&gt;% gaze
lm(dist ~ poly(speed, 2), cars) %&gt;% gaze
lm(dist ~ poly(speed, 2), cars) %&gt;% gaze(coef = "poly(speed, 2)2")
</code></pre>

<hr>
<h2 id='hausman'>Hausman test</h2><span id='topic+hausman'></span><span id='topic+hausman.ivreg'></span><span id='topic+hausman.micsr'></span>

<h3>Description</h3>

<p>Hausman test; under the null both models are consistent but one of
them is more efficient, under the alternative, only one model is
consistent
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hausman(x, y, omit = FALSE, ...)

## S3 method for class 'ivreg'
hausman(x, y, omit = FALSE, ...)

## S3 method for class 'micsr'
hausman(x, y, omit = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hausman_+3A_x">x</code></td>
<td>
<p>the first model,</p>
</td></tr>
<tr><td><code id="hausman_+3A_y">y</code></td>
<td>
<p>the second model</p>
</td></tr>
<tr><td><code id="hausman_+3A_omit">omit</code></td>
<td>
<p>a character containing the effects that are removed from the test</p>
</td></tr>
<tr><td><code id="hausman_+3A_...">...</code></td>
<td>
<p>further arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class <code>"htest"</code>.
</p>


<h3>Author(s)</h3>

<p>Yves Croissant
</p>


<h3>References</h3>

<p>Hausman JA (1978).
&ldquo;Specification Tests in Econometrics.&rdquo;
<em>Econometrica</em>, <b>46</b>(6), 1251&ndash;1271.
</p>

<hr>
<h2 id='housprod'>Household Production</h2><span id='topic+housprod'></span>

<h3>Description</h3>

<p>a cross-section of 819 households from 1984
</p>


<h3>Format</h3>

<p>a tibble containing:
</p>

<ul>
<li><p> mjob: dummy, 1 if male has paid job
</p>
</li>
<li><p> fjob: dummy, 1 if female has paid job
</p>
</li>
<li><p> mtime: home production time male (minutes per day)
</p>
</li>
<li><p> ftime: home production time female (minutes per day)
</p>
</li>
<li><p> mwage: net hourly wage rate male (estimate imputed if mjob=0)
</p>
</li>
<li><p> fwage: net hourly wage rate female (estimate imputed if fjob=0)
</p>
</li>
<li><p> mage: age male
</p>
</li>
<li><p> meduc: years of schooling male
</p>
</li>
<li><p> fage: age female
</p>
</li>
<li><p> feduc: years of schooling female
</p>
</li>
<li><p> owner: dummy, 1 if houseownwers
</p>
</li>
<li><p> fsize: family size
</p>
</li>
<li><p> ychild: number of children younger than 7 years old in the household
</p>
</li>
<li><p> cars: number of cars in the household
</p>
</li>
<li><p> nonlabinc: non-labour income (in units of 1000 Swedish Kronor)
</p>
</li></ul>



<h3>Source</h3>

<p>JAE data archive
</p>


<h3>References</h3>

<p>Kerkhofs M, Kooreman P (2003).
&ldquo;Identification and Estimation of a Class of Household Production Models.&rdquo;
<em>Journal of Applied Econometrics</em>, <b>18</b>(3), 337&ndash;369.
</p>

<hr>
<h2 id='ivldv'>Instrumental variable estimators for limited dependent variable</h2><span id='topic+ivldv'></span><span id='topic+endogtest'></span><span id='topic+endogtest.formula'></span><span id='topic+endogtest.ivldv'></span>

<h3>Description</h3>

<p>Estimation of simultaneous-equation models when the response is
binomial or censored
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ivldv(
  formula,
  data,
  subset = NULL,
  weights = NULL,
  na.action,
  offset,
  method = c("twosteps", "minchisq", "ml", "test"),
  model = c("probit", "tobit"),
  robust = TRUE,
  left = 0,
  right = Inf,
  trace = 0,
  ...
)

endogtest(x, ...)

## S3 method for class 'formula'
endogtest(x, ..., data, model = c("probit", "tobit"))

## S3 method for class 'ivldv'
endogtest(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ivldv_+3A_formula">formula</code></td>
<td>
<p>a symbolic description of the model,</p>
</td></tr>
<tr><td><code id="ivldv_+3A_data">data</code></td>
<td>
<p>a data frame,</p>
</td></tr>
<tr><td><code id="ivldv_+3A_subset">subset</code>, <code id="ivldv_+3A_weights">weights</code>, <code id="ivldv_+3A_na.action">na.action</code>, <code id="ivldv_+3A_offset">offset</code></td>
<td>
<p>see <code>lm</code>,</p>
</td></tr>
<tr><td><code id="ivldv_+3A_method">method</code></td>
<td>
<p>one of <code>"ml"</code> for maximum likelihood, &quot;twosteps&quot;<code>and</code>&quot;minchisq&quot;'</p>
</td></tr>
<tr><td><code id="ivldv_+3A_model">model</code></td>
<td>
<p>one of <code>"probit"</code> or <code>"tobit"</code>,</p>
</td></tr>
<tr><td><code id="ivldv_+3A_robust">robust</code></td>
<td>
<p>a boolean, if <code>TRUE</code>, a consistent estimation of the
covariance of the coefficients is used for the 2-steps method,</p>
</td></tr>
<tr><td><code id="ivldv_+3A_left">left</code>, <code id="ivldv_+3A_right">right</code></td>
<td>
<p>left and right limits of the dependent
variable. The default is respectively 0 and +Inf which
corresponds to the most classic (left-zero truncated) tobit
model,</p>
</td></tr>
<tr><td><code id="ivldv_+3A_trace">trace</code></td>
<td>
<p>a boolean (the default if <code>FALSE</code>) if <code>TRUE</code> some
information about the optimization process is printed,</p>
</td></tr>
<tr><td><code id="ivldv_+3A_...">...</code></td>
<td>
<p>further arguments</p>
</td></tr>
<tr><td><code id="ivldv_+3A_x">x</code></td>
<td>
<p>on object returned by <code>ivldv</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>c('ivldv', 'lm')</code>
</p>


<h3>Author(s)</h3>

<p>Yves Croissant
</p>


<h3>References</h3>

<p>Smith R, Blundell R (1986).
&ldquo;An Exogeneity Test for a Simultaneous Equation Tobit Model with an Application to Labor Supply.&rdquo;
<em>Econometrica</em>, <b>54</b>(3), 679-85.
</p>
<p>Rivers D, Vuong QH (1988).
&ldquo;Limited information estimators and exogeneity tests for simultaneous probit models.&rdquo;
<em>Journal of Econometrics</em>, <b>39</b>(3), 347-366.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>inst &lt;- ~ sic3 + k_serv + inv + engsci + whitecol + skill + semskill + cropland + 
    pasture + forest + coal + petro + minerals + scrconc + bcrconc + scrcomp +
    bcrcomp + meps + kstock + puni + geog2 + tenure + klratio + bunion
trade_protection &lt;- dplyr::mutate(micsr::trade_protection,
                                 y = ntb / (1 + ntb),
                                 x1 = vshipped / imports / elast,
                                 x2 = cap * x1,
                                 x3 = labvar)
GH &lt;- ivldv(Formula::as.Formula(y  ~  x1 + x2, inst), trade_protection,
            method = "twosteps", model = "tobit") 
Full &lt;- ivldv(Formula::as.Formula(y ~ x1 + x2 + labvar, inst), trade_protection,
              method = "twosteps", model = "tobit") 
Short &lt;- ivldv(Formula::as.Formula(y ~ x1 + I(x2 + labvar), inst),
                 trade_protection, method = "twosteps", model = "tobit")
bank_msq &lt;- ivldv(federiv ~ eqrat + optval + bonus + ltass + linsown + linstown +
                  roe + mktbk + perfor + dealdum + div + year | . - eqrat - bonus -
                  optval + no_emp + no_subs + no_off + ceo_age + gap + cfa,
                  data = federiv, method = "minchisq")
bank_ml &lt;- update(bank_msq, method = "ml")
bank_2st &lt;- update(bank_msq, method = "twosteps")
</code></pre>

<hr>
<h2 id='loglm'>Log-linear model</h2><span id='topic+loglm'></span>

<h3>Description</h3>

<p>Estimation of log-linear model; the estimation is done by <code>lm</code>, but
the correct log-likelihood related quantities are returned
</p>


<h3>Usage</h3>

<pre><code class='language-R'>loglm(formula, data)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="loglm_+3A_formula">formula</code>, <code id="loglm_+3A_data">data</code></td>
<td>
<p>see <code>lm</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>"micsr"</code>, see <code>micsr::micsr</code> for further details.
</p>


<h3>Author(s)</h3>

<p>Yves Croissant
</p>


<h3>Examples</h3>

<pre><code class='language-R'>lm_model &lt;- lm(log(dist) ~ log(speed), cars)
log_model &lt;- loglm(dist ~ log(speed), cars)
coef(lm_model)
coef(log_model)
# same coefficients, supplementary sigma coefficient for `loglm`
logLik(lm_model)
logLik(log_model)
# log_model returns the correct value for the log-likelihood
</code></pre>

<hr>
<h2 id='micsr'><code>micsr</code> class</h2><span id='topic+micsr'></span><span id='topic+llobs'></span><span id='topic+coef.micsr'></span><span id='topic+vcov.micsr'></span><span id='topic+summary.micsr'></span><span id='topic+coef.summary.micsr'></span><span id='topic+print.micsr'></span><span id='topic+print.summary.micsr'></span><span id='topic+logLik.micsr'></span><span id='topic+BIC.micsr'></span><span id='topic+AIC.micsr'></span><span id='topic+deviance.micsr'></span><span id='topic+predict.micsr'></span><span id='topic+model.part.micsr'></span><span id='topic+model.matrix.micsr'></span><span id='topic+estfun.micsr'></span><span id='topic+vcovHC.micsr'></span><span id='topic+bread.micsr'></span><span id='topic+nobs.micsr'></span><span id='topic+llobs.micsr'></span><span id='topic+llobs.mlogit'></span><span id='topic+tidy.micsr'></span><span id='topic+glance.micsr'></span>

<h3>Description</h3>

<p>The <code>micsr</code> class is intend to deal with a lot of different models
that are estimated in the <code>micsr</code> package. More specifically, some
models may be estimated using different estimation methods, like
maximum likelihood, GMM or two-steps estimators. Objects of class
<code>micsr</code> have an <code>est_method</code> item which is used by the different
methods in order to have a relevent behaviour for the different
methods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>llobs(x, ...)

## S3 method for class 'micsr'
coef(object, ..., subset = NA)

## S3 method for class 'micsr'
vcov(object, ..., vcov = c("info", "hessian", "opg"), subset = NA)

## S3 method for class 'micsr'
summary(object, ..., vcov = c("hessian", "info", "opg"), subset = NA)

## S3 method for class 'summary.micsr'
coef(object, ...)

## S3 method for class 'micsr'
print(x, digits = max(3L, getOption("digits") - 3L), ...)

## S3 method for class 'summary.micsr'
print(
  x,
  digits = max(3, getOption("digits") - 2),
  width = getOption("width"),
  ...
)

## S3 method for class 'micsr'
logLik(object, ..., type = c("model", "null", "saturated"))

## S3 method for class 'micsr'
BIC(object, ..., type = c("model", "null"))

## S3 method for class 'micsr'
AIC(object, ..., k = 2, type = c("model", "null"))

## S3 method for class 'micsr'
deviance(object, ..., type = c("model", "null"))

## S3 method for class 'micsr'
predict(object, ..., newdata = NULL)

## S3 method for class 'micsr'
model.part(object, ..., lhs = 1)

## S3 method for class 'micsr'
model.matrix(object, formula = NULL, ..., rhs = 1)

## S3 method for class 'micsr'
estfun(x, ...)

## S3 method for class 'micsr'
vcovHC(x, type, omega = NULL, sandwich = TRUE, ...)

## S3 method for class 'micsr'
bread(x, ...)

## S3 method for class 'micsr'
nobs(object, ...)

## S3 method for class 'micsr'
llobs(x, ...)

## S3 method for class 'mlogit'
llobs(x, ...)

## S3 method for class 'micsr'
tidy(x, conf.int = FALSE, conf.level = 0.95, ...)

## S3 method for class 'micsr'
glance(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="micsr_+3A_x">x</code>, <code id="micsr_+3A_object">object</code></td>
<td>
<p>an object which inherits the <code>micsr</code> class</p>
</td></tr>
<tr><td><code id="micsr_+3A_...">...</code></td>
<td>
<p>further arguments</p>
</td></tr>
<tr><td><code id="micsr_+3A_subset">subset</code></td>
<td>
<p>a character which indicates which subset of
coefficients should be extracted: one of <code>noinst</code> (all the
coefficients except those corresponding to instrumental
variables), <code>all</code>, <code>covar</code> (only the coefficients of the
covariates), <code>inst</code> (only the coefficients of the instrumental
variables) and <code>misc</code> (ony the &quot;miscelanous&quot; coefficients,
typicaly a standard deviation or a coefficient of correlation)</p>
</td></tr>
<tr><td><code id="micsr_+3A_vcov">vcov</code></td>
<td>
<p>the method used to compute the covariance matrix of the
estimators (only for the ML estimator), one of <code>hessian</code> (the
opposite of the inverse of the hessian), <code>info</code> (the inverse of
the opposite of the expected value of the hessian), <code>opg</code> (the
outer product of the gradient)</p>
</td></tr>
<tr><td><code id="micsr_+3A_digits">digits</code>, <code id="micsr_+3A_width">width</code></td>
<td>
<p>see <code>print</code></p>
</td></tr>
<tr><td><code id="micsr_+3A_type">type</code>, <code id="micsr_+3A_omega">omega</code>, <code id="micsr_+3A_sandwich">sandwich</code></td>
<td>
<p>see <code>sandwich::sandwich</code></p>
</td></tr>
<tr><td><code id="micsr_+3A_k">k</code></td>
<td>
<p>see <code>AIC</code></p>
</td></tr>
<tr><td><code id="micsr_+3A_newdata">newdata</code></td>
<td>
<p>a new data frame to compute the predictions</p>
</td></tr>
<tr><td><code id="micsr_+3A_lhs">lhs</code>, <code id="micsr_+3A_rhs">rhs</code></td>
<td>
<p>see <code>Formula::model.frame.Formula</code></p>
</td></tr>
<tr><td><code id="micsr_+3A_formula">formula</code></td>
<td>
<p>a formula</p>
</td></tr>
<tr><td><code id="micsr_+3A_conf.int">conf.int</code>, <code id="micsr_+3A_conf.level">conf.level</code></td>
<td>
<p>see <code>broom:tidy.lm</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Objects of class <code>micsr</code> share a lot of common elements with <code>lm</code>:
<code>coefficients</code>, <code>residuals</code>, <code>fitted.values</code>, <code>model</code>, <code>terms</code>,
<code>df.residual</code>, <code>xlevels</code>, <code>na.action</code>, and <code>call</code>. <code>npar</code> is a
named vector containing the index of subset of coefficients, it is
used to print a subset of the results.  It also has a <code>est_method</code>
element and, depending of its value, contains further elements. In
particular, for model fitted by maximum likelihood, <code>value</code>
contains the individual contribution to the log-likelihood
function, <code>gradient</code> the individual contribution to the gradient,
<code>hessian</code> the hessian and <code>information</code> the information
matrix. <code>logLik</code> contains the log-likelihood values of the
proposed, null and saturated models. <code>tests</code> contains the values of
the test that all the coefficients of the covariates are 0, using
the three classical tests.
</p>
<p>The <code>llobs</code> function is provided as a generic to extract the
individual contributions to the log-likelihood
</p>
<p>Specific methods have been writen for <code>micsr</code> objects: <code>nobs</code>,
<code>generics::tidy</code>, <code>generics::glance</code>, <code>sandwich::meat</code>,
<code>sandwich::estfun</code>, <code>predict</code>, <code>model.matrix</code>,
<code>Formula::model.part</code>.
</p>
<p><code>logLik</code>, <code>BIC</code>, <code>AIC</code> and <code>deviance</code> methods have a <code>type</code>
argument to select theproposed, null or saturated model.
</p>
<p><code>vcov</code> and <code>summary</code> methods have a <code>vcov</code> argument to select the
estimator of the covariance matrix, which can be either based on
the hessian, the gradient or the information.
</p>
<p><code>vcov</code>, <code>summary</code> and <code>coef</code> have a subset argument to select only
a subset of the coefficients
</p>

<hr>
<h2 id='mills'>Compute the inverse Mills ratio and its first two derivatives</h2><span id='topic+mills'></span>

<h3>Description</h3>

<p>The inverse Mills ratio is used in several econometric models,
especially different flavours of tobit model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mills(x, deriv = 0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mills_+3A_x">x</code></td>
<td>
<p>a numeric</p>
</td></tr>
<tr><td><code id="mills_+3A_deriv">deriv</code></td>
<td>
<p>one of 0 (the default, returns the inverse Mills
ratio), 1 (the first derivative) and 2 (the second derivative)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a numeric.
</p>

<hr>
<h2 id='mode_choice'>Choice between car and transit</h2><span id='topic+mode_choice'></span>

<h3>Description</h3>

<p>a cross-section of 842 individuals
</p>


<h3>Format</h3>

<p>a tibble containing:
</p>

<ul>
<li><p> mode: 1 for car, 0 for transit
</p>
</li>
<li><p> cost: transit fare minus automobile travel cost in US$
</p>
</li>
<li><p> ivtime: transit in-vehicule travel time minus in-vehicule travel time (minutes)
</p>
</li>
<li><p> ovtime: transit out-of vehicule time minus out-of vehicule travel time (minutes)
</p>
</li>
<li><p> cars: number of cars owned by the traveler's household
</p>
</li></ul>



<h3>Source</h3>

<p>GAMS's website <a href="https://www.gams.com/latest/gamslib_ml/libhtml/gamslib_mws.html">https://www.gams.com/latest/gamslib_ml/libhtml/gamslib_mws.html</a>
</p>


<h3>References</h3>

<p>Horowitz JL (1993).
&ldquo;Semiparametric estimation of a work-trip mode choice model.&rdquo;
<em>Journal of econometrics</em>, <b>58</b>(1-2), 49-70.
</p>

<hr>
<h2 id='ndvuong'>Non-degenerate Vuong test</h2><span id='topic+ndvuong'></span>

<h3>Description</h3>

<p>An unhanced version of the Vuong test with a small-sample bias
correction
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ndvuong(
  x,
  y,
  size = 0.05,
  pval = TRUE,
  nested = FALSE,
  vartest = FALSE,
  ndraws = 10000,
  diffnorm = 0.1,
  seed = 1,
  numbers = NULL,
  nd = TRUE,
  print.level = 0
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ndvuong_+3A_x">x</code></td>
<td>
<p>a first fitted model</p>
</td></tr>
<tr><td><code id="ndvuong_+3A_y">y</code></td>
<td>
<p>a second fitted model</p>
</td></tr>
<tr><td><code id="ndvuong_+3A_size">size</code></td>
<td>
<p>the size of the test</p>
</td></tr>
<tr><td><code id="ndvuong_+3A_pval">pval</code></td>
<td>
<p>should the p-value be computed ?</p>
</td></tr>
<tr><td><code id="ndvuong_+3A_nested">nested</code></td>
<td>
<p>a boolean, <code>TRUE</code> for nested models</p>
</td></tr>
<tr><td><code id="ndvuong_+3A_vartest">vartest</code></td>
<td>
<p>a boolean, if <code>TRUE</code>, the variance test is computed</p>
</td></tr>
<tr><td><code id="ndvuong_+3A_ndraws">ndraws</code></td>
<td>
<p>the number of draws for the simulations</p>
</td></tr>
<tr><td><code id="ndvuong_+3A_diffnorm">diffnorm</code></td>
<td>
<p>a creuser</p>
</td></tr>
<tr><td><code id="ndvuong_+3A_seed">seed</code></td>
<td>
<p>the seed</p>
</td></tr>
<tr><td><code id="ndvuong_+3A_numbers">numbers</code></td>
<td>
<p>a user provided matrix of random numbers</p>
</td></tr>
<tr><td><code id="ndvuong_+3A_nd">nd</code></td>
<td>
<p>a boolean, if <code>TRUE</code> (the default) the non-degenarate Vuong test is computed</p>
</td></tr>
<tr><td><code id="ndvuong_+3A_print.level">print.level</code></td>
<td>
<p>the level of details to be printed</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class <code>"htest"</code>.
</p>


<h3>References</h3>

<p>Vuong QH (1989).
&ldquo;Likelihood Ratio Tests for Selection and Non-Nested Hypotheses.&rdquo;
<em>Econometrica</em>, <b>57</b>(2), 397-333.
</p>
<p>Shi X (2015).
&ldquo;A nondegenerate Vuong test.&rdquo;
<em>Quantitative Economics</em>, 85-121.
</p>


<h3>See Also</h3>

<p>the classical Vuong test is implemented in <code>pscl::vuong</code> and <code>nonnest2::vuongtest</code>.
</p>

<hr>
<h2 id='newton'>Newton-Raphson  method for numerical optimization</h2><span id='topic+newton'></span>

<h3>Description</h3>

<p>The Newton-Raphson method use the gradient and the hessian of a
function. For well behaved functions, it is extremely accurate.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>newton(
  fun,
  coefs,
  trace = 0,
  direction = c("min", "max"),
  tol = sqrt(.Machine$double.eps),
  maxit = 500,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="newton_+3A_fun">fun</code></td>
<td>
<p>the function to optimize</p>
</td></tr>
<tr><td><code id="newton_+3A_coefs">coefs</code></td>
<td>
<p>a vector of starting values</p>
</td></tr>
<tr><td><code id="newton_+3A_trace">trace</code></td>
<td>
<p>if positive or true, some information about the
computation is printed</p>
</td></tr>
<tr><td><code id="newton_+3A_direction">direction</code></td>
<td>
<p>either <code>"min"</code> or <code>"max"</code></p>
</td></tr>
<tr><td><code id="newton_+3A_tol">tol</code></td>
<td>
<p>the tolerance</p>
</td></tr>
<tr><td><code id="newton_+3A_maxit">maxit</code></td>
<td>
<p>maximum number of iterations</p>
</td></tr>
<tr><td><code id="newton_+3A_...">...</code></td>
<td>
<p>further arguments, passed to fun</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a numeric vector, the parameters at the optimum of the
function.
</p>

<hr>
<h2 id='npar'>Number of parameters of a fitted model</h2><span id='topic+npar'></span><span id='topic+npar.default'></span><span id='topic+npar.micsr'></span>

<h3>Description</h3>

<p>The number of observation of a fitted model is typically obtained
using the <code>nobs</code> method. There is no such generics to extract the
same information about the number of parameters. <code>npar</code> is such a
generic and has a special method for <code>micsr</code> objects with a
<code>subset</code> argument that enables to compute the number of parameters
for a subset of coefficients. The default method returns the length
of the vector of coefficients extracted using the <code>coef</code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>npar(x, subset = NULL)

## Default S3 method:
npar(x, subset = NULL)

## S3 method for class 'micsr'
npar(x, subset = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="npar_+3A_x">x</code></td>
<td>
<p>a fitted model</p>
</td></tr>
<tr><td><code id="npar_+3A_subset">subset</code></td>
<td>
<p>a character indicating the subset of coefficients
(only relevant for <code>micsr</code> models).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an integer.
</p>


<h3>Author(s)</h3>

<p>Yves Croissant
</p>

<hr>
<h2 id='ordreg'>Ordered regression</h2><span id='topic+ordreg'></span>

<h3>Description</h3>

<p>Maximum-likelihood estimation of a model for which the response is
ordinal
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ordreg(
  formula,
  data,
  weights,
  subset,
  na.action,
  offset,
  link = c("probit", "logit"),
  start = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ordreg_+3A_formula">formula</code></td>
<td>
<p>a symbolic description of the model</p>
</td></tr>
<tr><td><code id="ordreg_+3A_data">data</code></td>
<td>
<p>a data frame</p>
</td></tr>
<tr><td><code id="ordreg_+3A_subset">subset</code>, <code id="ordreg_+3A_weights">weights</code>, <code id="ordreg_+3A_na.action">na.action</code>, <code id="ordreg_+3A_offset">offset</code></td>
<td>
<p>see <code>lm</code></p>
</td></tr>
<tr><td><code id="ordreg_+3A_link">link</code></td>
<td>
<p>one of <code>probit</code> and <code>logit</code></p>
</td></tr>
<tr><td><code id="ordreg_+3A_start">start</code></td>
<td>
<p>a vector of starting values, in this case, no
estimation</p>
</td></tr>
<tr><td><code id="ordreg_+3A_...">...</code></td>
<td>
<p>further arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class <code>micsr</code>, see <code>micsr::micsr</code> for further
details.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mod1 &lt;- ordreg(factor(dindx) ~ rhs1 + catchup, fin_reform, link = "logit")
</code></pre>

<hr>
<h2 id='poisreg'>Poisson regression</h2><span id='topic+poisreg'></span>

<h3>Description</h3>

<p>A unified interface to perform Poisson, Negbin and log-normal Poisson models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>poisreg(
  formula,
  data,
  weights,
  subset,
  na.action,
  offset,
  start = NULL,
  mixing = c("none", "gamma", "lognorm"),
  method = c("bfgs", "newton"),
  vlink = c("nb1", "nb2"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="poisreg_+3A_formula">formula</code></td>
<td>
<p>a symbolic description of the model, (for the count
component and for the selection equation)</p>
</td></tr>
<tr><td><code id="poisreg_+3A_data">data</code></td>
<td>
<p>a data frame</p>
</td></tr>
<tr><td><code id="poisreg_+3A_subset">subset</code>, <code id="poisreg_+3A_weights">weights</code>, <code id="poisreg_+3A_na.action">na.action</code>, <code id="poisreg_+3A_offset">offset</code></td>
<td>
<p>see <code>stats::lm</code>,</p>
</td></tr>
<tr><td><code id="poisreg_+3A_start">start</code></td>
<td>
<p>a vector of starting values</p>
</td></tr>
<tr><td><code id="poisreg_+3A_mixing">mixing</code></td>
<td>
<p>the mixing distribution, one of <code>"none"</code>, <code>"gamma"</code>
and <code>"lognorm"</code></p>
</td></tr>
<tr><td><code id="poisreg_+3A_method">method</code></td>
<td>
<p>the optimization method, one of <code>"newton"</code> and <code>"bfgs"</code></p>
</td></tr>
<tr><td><code id="poisreg_+3A_vlink">vlink</code></td>
<td>
<p>one of <code>"nb1"</code> and <code>"nb2"</code></p>
</td></tr>
<tr><td><code id="poisreg_+3A_...">...</code></td>
<td>
<p>further arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class <code>c("poisreg", "micsr")</code>, see
<code>micsr::micsr</code> for further details.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>nb1 &lt;- poisreg(trips ~ workschl + size + dist + smsa + fulltime + distnod +
               realinc + weekend + car, trips, mixing = "gamma", vlink = "nb1")
</code></pre>

<hr>
<h2 id='pscore'>Propensity scores</h2><span id='topic+pscore'></span><span id='topic+summary.pscore'></span><span id='topic+print.pscore'></span><span id='topic+print.summary.pscore'></span><span id='topic+nobs.pscore'></span><span id='topic+nobs.summary.pscore'></span><span id='topic+rg'></span><span id='topic+rg.pscore'></span><span id='topic+rg.summary.pscore'></span><span id='topic+stdev'></span><span id='topic+mean.pscore'></span><span id='topic+mean.summary.pscore'></span><span id='topic+stdev.pscore'></span><span id='topic+stdev.summary.pscore'></span>

<h3>Description</h3>

<p>Propensity scores estimation, using an algorithm that checks the
balancing hypothesis using strata and enable the estimation of the
treatment effect using stratification methods
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pscore(formula, data, maxiter = 4, tol = 0.005, link = c("logit", "probit"))

## S3 method for class 'pscore'
summary(object, ...)

## S3 method for class 'pscore'
print(
  x,
  ...,
  digits = getOption("digits"),
  var_equal = c("none", "strata", "group", "both")
)

## S3 method for class 'summary.pscore'
print(
  x,
  ...,
  digits = getOption("digits"),
  format = c("rst", "pipe", "simple"),
  step = c("all", "strata", "covariates", "atet")
)

## S3 method for class 'pscore'
nobs(object, ..., smpl = c("total", "cs"))

## S3 method for class 'summary.pscore'
nobs(object, ..., smpl = c("total", "cs"))

rg(object, ...)

## S3 method for class 'pscore'
rg(object, ..., smpl = c("total", "cs"))

## S3 method for class 'summary.pscore'
rg(object, ..., smpl = c("total", "cs"))

stdev(object, ...)

## S3 method for class 'pscore'
mean(x, ..., var_equal = c("none", "strat", "group", "both"))

## S3 method for class 'summary.pscore'
mean(x, ...)

## S3 method for class 'pscore'
stdev(object, ..., var_equal = c("none", "strata", "group", "both"))

## S3 method for class 'summary.pscore'
stdev(object, ..., var_equal = c("none", "strata", "group", "both"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pscore_+3A_formula">formula</code></td>
<td>
<p>a Formula object; the left-hand side should contain
two variables (<code>x1 + x2</code>), where x1 is the group variable and
x2 the outcome. The group variable can be either a dummy for
treated individuals or a factor with levels <code>"treated"</code> and
<code>"control"</code></p>
</td></tr>
<tr><td><code id="pscore_+3A_data">data</code></td>
<td>
<p>a data frame</p>
</td></tr>
<tr><td><code id="pscore_+3A_maxiter">maxiter</code></td>
<td>
<p>the maximum number of iterations</p>
</td></tr>
<tr><td><code id="pscore_+3A_tol">tol</code></td>
<td>
<p>stratas are cut in halves as long as the hypothesis of
equal means is rejected at the <code>tol</code> level,</p>
</td></tr>
<tr><td><code id="pscore_+3A_link">link</code></td>
<td>
<p>the link for the binomial glm estimation, either
<code>"logit"</code> or <code>"probit"</code></p>
</td></tr>
<tr><td><code id="pscore_+3A_...">...</code></td>
<td>
<p>further arguments</p>
</td></tr>
<tr><td><code id="pscore_+3A_x">x</code>, <code id="pscore_+3A_object">object</code></td>
<td>
<p>a <code>"pscore"</code> or a <code>"summary.pscore"</code> object</p>
</td></tr>
<tr><td><code id="pscore_+3A_digits">digits</code></td>
<td>
<p>number of digits for the <code>print</code> methods</p>
</td></tr>
<tr><td><code id="pscore_+3A_var_equal">var_equal</code></td>
<td>
<p>to compute the variance of the ATET, variances can
be computed at the class/group level (<code>var_equal = "none"</code>), at
the class level (<code>var_equal = "group"</code>), at the group level
(<code>var_equal = "strata"</code>) or globally (<code>var_equal = "both"</code>)</p>
</td></tr>
<tr><td><code id="pscore_+3A_format">format</code></td>
<td>
<p>one of <code>"rst"</code> <code>"pipe"</code> and <code>"simple"</code>, this argument
is passed to <code>knitr::kable</code></p>
</td></tr>
<tr><td><code id="pscore_+3A_step">step</code></td>
<td>
<p>for the <code>print.summary</code> method, the step of the test to
be printed: one of <code>"all"</code> (the default), <code>strata</code>,
<code>covariates</code> and <code>atet</code></p>
</td></tr>
<tr><td><code id="pscore_+3A_smpl">smpl</code></td>
<td>
<p>the sample to use, either the whole sample (<code>smpl = "total"</code>) or the sample with common support (<code>smpl = "cs"</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class <code>"pscore"</code>, with the following elements:
</p>

<ul>
<li> <p><code>strata</code>: a tibble containing the stratas, the frequencies, the
means and the variances of the propensity scores for treated and
controled observations
</p>
</li>
<li> <p><code>cov_balance</code>: a tibble containing the results of the balancing
tests for every covariate; the results for the class with the
lowest p-value is reported
</p>
</li>
<li> <p><code>unchecked_cov</code>: a character vector containing the names of the
covariates for which the balancing test could be computed
</p>
</li>
<li> <p><code>model</code>: a tibble containing the original data, with
supplementary columns: <code>gp_</code> for the groups, <code>resp_</code> for the
outcome and <code>cls_</code> for the stratas
</p>
</li>
<li> <p><code>pscore</code>: the glm model fitted to compute the propensity scores
</p>
</li></ul>



<h3>References</h3>

<p>Dehejia RH, Wahba S (2002).
&ldquo;Propensity Score-Matching Methods for Nonexperimental Causal Studies.&rdquo;
<em>The Review of Economics and Statistics</em>, <b>84</b>(1), 151-161.
ISSN 0034-6535, <a href="https://doi.org/10.1162/003465302317331982">doi:10.1162/003465302317331982</a>.
</p>
<p>Becker SO, Ichino A (2002).
&ldquo;Estimation of average treatment effects based on propensity scores.&rdquo;
<em>Stata Journal</em>, <b>2</b>(4), 358-377(20).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data_tuscany &lt;- dplyr::mutate(dplyr::filter(twa, region == "Tuscany"),
  dist2 = dist ^ 2, livselfemp = I((city == "livorno") * (occup == "selfemp")),
  perm = ifelse(outcome == "perm", 1, 0))
formula_tuscany &lt;- group | perm ~ city + sex + marital + age +
   loc + children + educ + pvoto + training +
   empstat + occup + sector + wage + hour + feduc + femp + fbluecol +
   dist + dist2 + livselfemp
pscore(formula_tuscany, data_tuscany)
</code></pre>

<hr>
<h2 id='reexports'>Objects exported from other packages</h2><span id='topic+reexports'></span><span id='topic+mutate'></span><span id='topic++25+3E+25'></span><span id='topic+glance'></span><span id='topic+tidy'></span><span id='topic+bread'></span><span id='topic+estfun'></span><span id='topic+vcovHC'></span><span id='topic+model.part'></span><span id='topic+meat'></span>

<h3>Description</h3>

<p>These objects are imported from other packages. Follow the links
below to see their documentation.
</p>

<dl>
<dt>dplyr</dt><dd><p><code><a href="dplyr.html#topic+mutate">mutate</a></code></p>
</dd>
<dt>Formula</dt><dd><p><code><a href="Formula.html#topic+model.frame.Formula">model.part</a></code></p>
</dd>
<dt>generics</dt><dd><p><code><a href="generics.html#topic+glance">glance</a></code>, <code><a href="generics.html#topic+tidy">tidy</a></code></p>
</dd>
<dt>magrittr</dt><dd><p><code><a href="magrittr.html#topic+pipe">%&gt;%</a></code></p>
</dd>
<dt>sandwich</dt><dd><p><code><a href="sandwich.html#topic+bread">bread</a></code>, <code><a href="sandwich.html#topic+bread">bread</a></code>, <code><a href="sandwich.html#topic+estfun">estfun</a></code>, <code><a href="sandwich.html#topic+estfun">estfun</a></code>, <code><a href="sandwich.html#topic+meat">meat</a></code>, <code><a href="sandwich.html#topic+vcovHC">vcovHC</a></code></p>
</dd>
</dl>

<hr>
<h2 id='rsq'>Coefficient of determination</h2><span id='topic+rsq'></span><span id='topic+rsq.lm'></span><span id='topic+rsq.micsr'></span>

<h3>Description</h3>

<p>A generic function to compute different flavors of coefficients of determination
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rsq(x, type)

## S3 method for class 'lm'
rsq(x, type = c("raw", "adj"))

## S3 method for class 'micsr'
rsq(
  x,
  type = c("mcfadden", "cox_snell", "cragg_uhler", "aldrich_nelson", "veall_zimm",
    "estrella", "cor", "ess", "rss", "tjur", "mckel_zavo", "w", "lm", "lr")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rsq_+3A_x">x</code></td>
<td>
<p>fitted model</p>
</td></tr>
<tr><td><code id="rsq_+3A_type">type</code></td>
<td>
<p>the type of coefficient of determination</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a numeric scalar.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pbt &lt;- binomreg(mode ~ cost + ivtime + ovtime, data = mode_choice, link = 'probit')
rsq(pbt)
rsq(pbt, "estrella")
rsq(pbt, "veall_zimm")
</code></pre>

<hr>
<h2 id='sargan'>Sargan test for GMM models</h2><span id='topic+sargan'></span><span id='topic+sargan.ivreg'></span><span id='topic+sargan.micsr'></span>

<h3>Description</h3>

<p>When a IV model is over-identified, the set of all the empirical
moment conditions can't be exactly 0. The test of the validity of
the instruments is based on a quadratic form of the vector of the
empirical moments
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sargan(object, ...)

## S3 method for class 'ivreg'
sargan(object, ...)

## S3 method for class 'micsr'
sargan(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sargan_+3A_object">object</code></td>
<td>
<p>a model fitted by GMM</p>
</td></tr>
<tr><td><code id="sargan_+3A_...">...</code></td>
<td>
<p>further arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class <code>"htest"</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cigmales &lt;- cigmales %&gt;%
       mutate(age2 = age ^ 2, educ2 = educ ^ 2,
              age3 = age ^ 3, educ3 = educ ^ 3,
              educage = educ * age)
gmm_cig &lt;- expreg(cigarettes ~ habit + price + restaurant + income + age + age2 +
                 educ + educ2 + famsize + race | . - habit + age3 + educ3 +
                 educage + lagprice + reslgth, data = cigmales,
                 twosteps = FALSE)
sargan(gmm_cig)
</code></pre>

<hr>
<h2 id='scoretest'>Score test</h2><span id='topic+scoretest'></span><span id='topic+scoretest.micsr'></span>

<h3>Description</h3>

<p>Score test, also knowned as Lagrange multiplier tests
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scoretest(x, y, ...)

## S3 method for class 'micsr'
scoretest(x, y, ..., vcov = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="scoretest_+3A_x">x</code></td>
<td>
<p>the first model,</p>
</td></tr>
<tr><td><code id="scoretest_+3A_y">y</code></td>
<td>
<p>the second model</p>
</td></tr>
<tr><td><code id="scoretest_+3A_...">...</code></td>
<td>
<p>further arguments</p>
</td></tr>
<tr><td><code id="scoretest_+3A_vcov">vcov</code></td>
<td>
<p>omit a character containing the effects that are
removed from the test</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class <code>"htest"</code>.
</p>


<h3>Author(s)</h3>

<p>Yves Croissant
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mode_choice &lt;- mode_choice %&gt;%
   mutate(cost = cost * 8.42,
          gcost = (ivtime + ovtime) * 8 + cost)
pbt_unconst &lt;- binomreg(mode ~ cost + ivtime + ovtime, data = mode_choice, link = "probit")
pbt_const &lt;- binomreg(mode ~ gcost, data = mode_choice, link = "logit")
scoretest(pbt_const , . ~ . + ivtime + ovtime)
</code></pre>

<hr>
<h2 id='stder'>Extract the standard errors of estimated coefficients</h2><span id='topic+stder'></span><span id='topic+stder.default'></span>

<h3>Description</h3>

<p>The standard errors are a key element while presenting the results
of a model. They are the second column of the table of coefficient
and are used to compute the t/z-value. <code>stderr</code> enables to retrieve
easily the vector of standard errors, either from a fitted model or
from a matrix of covariance
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stder(x, .vcov, ...)

## Default S3 method:
stder(x, .vcov = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="stder_+3A_x">x</code></td>
<td>
<p>a fitted model or a matrix of covariance</p>
</td></tr>
<tr><td><code id="stder_+3A_.vcov">.vcov</code></td>
<td>
<p>a function that computes a covariance matrix, or a character</p>
</td></tr>
<tr><td><code id="stder_+3A_...">...</code></td>
<td>
<p>further arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a numeric vector
</p>

<hr>
<h2 id='tobit1'>Truncated response model</h2><span id='topic+tobit1'></span>

<h3>Description</h3>

<p>Estimation of models for which the response is truncated, either on
censored or truncated samples using OLS, NLS, maximum
likelihood, two-steps estimators or trimmed estimators
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tobit1(
  formula,
  data,
  subset = NULL,
  weights = NULL,
  start = NULL,
  left = 0,
  right = Inf,
  scedas = NULL,
  sample = c("censored", "truncated"),
  method = c("ml", "lm", "twosteps", "trimmed", "nls", "minchisq", "test"),
  trace = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tobit1_+3A_formula">formula</code></td>
<td>
<p>a symbolic description of the model; if two right
hand sides are provided, the second one described the set of
instruments if <code>scedas</code> is <code>NULL</code>, which is the
default. Otherwise, the second part indicates the set of
covariates for the variance function</p>
</td></tr>
<tr><td><code id="tobit1_+3A_data">data</code>, <code id="tobit1_+3A_subset">subset</code>, <code id="tobit1_+3A_weights">weights</code></td>
<td>
<p>see <code>lm</code></p>
</td></tr>
<tr><td><code id="tobit1_+3A_start">start</code></td>
<td>
<p>an optional vector of starting values</p>
</td></tr>
<tr><td><code id="tobit1_+3A_left">left</code>, <code id="tobit1_+3A_right">right</code></td>
<td>
<p>left and right truncation points for the response
The default is respectively 0 and +Inf which corresponds to the
most classic (left-zero truncated) tobit model</p>
</td></tr>
<tr><td><code id="tobit1_+3A_scedas">scedas</code></td>
<td>
<p>the functional form used to specify the conditional
variance, either <code>"exp"</code> or <code>"pnorm"</code></p>
</td></tr>
<tr><td><code id="tobit1_+3A_sample">sample</code></td>
<td>
<p>either <code>"censored"</code> (the default) to estimate the
censored (tobit) regression model or <code>"truncated"</code> to estimated
the truncated regression model</p>
</td></tr>
<tr><td><code id="tobit1_+3A_method">method</code></td>
<td>
<p>one of <code>"ml"</code> for maximum likelihood, <code>"lm"</code> for
(biased) least squares estimators, <code>"twosteps"</code> for two-steps
consistent estimators, <code>"trimmed"</code> for symetrically censored
estimator, <code>"minchisq"</code> and <code>"test"</code>. The last two are only
relevant for instrumental variable estimation (when the formula
is a two-parts formula and <code>scedas</code> is <code>NULL</code>)</p>
</td></tr>
<tr><td><code id="tobit1_+3A_trace">trace</code></td>
<td>
<p>a boolean (the default if <code>FALSE</code>) if <code>TRUE</code> some
information about the optimization process is printed</p>
</td></tr>
<tr><td><code id="tobit1_+3A_...">...</code></td>
<td>
<p>further arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>c("tobit1", "micsr")</code>, see
<code>micsr::micsr</code> for further details.
</p>


<h3>Author(s)</h3>

<p>Yves Croissant
</p>


<h3>References</h3>

<p>Powell J (1986).
&ldquo;Symmetrically trimed least squares estimators for tobit models.&rdquo;
<em>Econometrica</em>, <b>54</b>, 1435&ndash;1460.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>charitable$logdon &lt;- with(charitable, log(donation) - log(25))
ml &lt;- tobit1(logdon ~ log(donparents) + log(income) + education +
             religion + married + south, data = charitable)
scls &lt;- update(ml, method = "trimmed")
tr &lt;- update(ml, sample = "truncated")
nls &lt;- update(tr, method = "nls")
</code></pre>

<hr>
<h2 id='trade_protection'>Lobying from Capitalists and Unions and Trade Protection</h2><span id='topic+trade_protection'></span>

<h3>Description</h3>

<p>a cross-section of 194 United States
</p>


<h3>Format</h3>

<p>a tibble containing:
</p>

<ul>
<li><p> ntb: nontariff barrier coverage ratio
</p>
</li>
<li><p> vshipped: value of shipments
</p>
</li>
<li><p> imports: importations
</p>
</li>
<li><p> elast: demand elasticity
</p>
</li>
<li><p> cap: lobying
</p>
</li>
<li><p> labvar: labor market covariate
</p>
</li>
<li><p> sic3: 3-digit SIC industry classification
</p>
</li>
<li><p> k_serv: physical capital, factor share
</p>
</li>
<li><p> inv: Inventories, factor share
</p>
</li>
<li><p> engsci: engineers and scientists, factor share
</p>
</li>
<li><p> whitecol: white collar, factor share
</p>
</li>
<li><p> skill: skilled, factor share
</p>
</li>
<li><p> semskill: semi-skilled, factor share
</p>
</li>
<li><p> cropland: cropland, factor shaer
</p>
</li>
<li><p> pasture: pasture, factor share
</p>
</li>
<li><p> forest: forest, factor share
</p>
</li>
<li><p> coal: coal, factor share
</p>
</li>
<li><p> petro: petroleum, factor share
</p>
</li>
<li><p> minerals: minerals, factor share
</p>
</li>
<li><p> scrconc: seller concentration
</p>
</li>
<li><p> bcrconc: buyer concentration
</p>
</li>
<li><p> scrcomp: seller number of firms
</p>
</li>
<li><p> bcrcomp: buyer number of firms
</p>
</li>
<li><p> meps: scale
</p>
</li>
<li><p> kstock: capital stock
</p>
</li>
<li><p> puni: proportion of workers union
</p>
</li>
<li><p> geog2: geographic concentration
</p>
</li>
<li><p> tenure: average worker tenure, years
</p>
</li>
<li><p> klratio: capital-labor ratio
</p>
</li>
<li><p> bunion:
</p>
</li></ul>



<h3>Source</h3>

<p>American Economic Association Data Archive : <a href="https://www.aeaweb.org/aer/">https://www.aeaweb.org/aer/</a>
</p>


<h3>References</h3>

<p>Matschke X, Sherlund SM (2006).
&ldquo;Do Labor Issues Matter in the Determination of U.S. Trade Policy? An Empirical Reevaluation.&rdquo;
<em>American Economic Review</em>, <b>96</b>(1), 405-421.
</p>

<hr>
<h2 id='trips'>Determinants of household trip taking</h2><span id='topic+trips'></span>

<h3>Description</h3>

<p>a cross-section of 577 households from 1978
</p>


<h3>Format</h3>

<p>a tibble containing:
</p>

<ul>
<li><p> trips: number of trips taken by a member of a household the day prior the survey interview
</p>
</li>
<li><p> car: 1 if household owns at least one motorized vehicule
</p>
</li>
<li><p> workschl: share of trips for work or school vs personal business or pleasure
</p>
</li>
<li><p> size: number of individuals in the household
</p>
</li>
<li><p> dist: distance to central business district in kilometers
</p>
</li>
<li><p> smsa: a factor with levels <code>"small"</code> (less than 2.5 million population) and <code>"large"</code> (more than 2.5 million population)
</p>
</li>
<li><p> fulltime: number of fulltime workers in household
</p>
</li>
<li><p> adults: number of adults in household
</p>
</li>
<li><p> distnod: distace from home to nearest transit node, in blocks
</p>
</li>
<li><p> realinc: household income divided by median income of census tract in which household resides
</p>
</li>
<li><p> weekend: 1 if the survey period is either saturday or sunday
</p>
</li></ul>



<h3>Source</h3>

<p>kindly provided by Joseph Terza
</p>


<h3>References</h3>

<p>Terza JV (1998).
&ldquo;Estimating count data models with endogenous switching: Sample selection and endogenous treatment effects.&rdquo;
<em>Journal of Econometrics</em>, <b>84</b>(1), 129-154.
</p>
<p>Terza JV, Wilson PW (1990).
&ldquo;Analyzing Frequencies of Several Types of Events: A Mixed Multinomial-Poisson Approach.&rdquo;
<em>The Review of Economics and Statistics</em>, <b>72</b>(1), 108-115.
</p>

<hr>
<h2 id='turnout'>Turnout</h2><span id='topic+turnout'></span>

<h3>Description</h3>

<p>these three models are replication in R of stata's
code available on the web site of the American Economic
Association. The estimation is complicated by the fact that
some linear constraints are imposed.
</p>


<h3>Format</h3>

<p>a list of three fitted models:
</p>

<ul>
<li><p> group: the group-rule-utilitarian model
</p>
</li>
<li><p> intens: the intensity model
</p>
</li>
<li><p> sur: the reduced form SUR model
</p>
</li></ul>



<h3>Details</h3>

<p>Turnout in Texas liquor referenda
</p>


<h3>Source</h3>

<p><a href="https://www.aeaweb.org/aer/">American Economic Association data archive</a>.
</p>


<h3>References</h3>

<p>Coate S, Conlin M (2004).
&ldquo;A Group Rule-Utilitarian Approach to Voter Turnout: Theory and Evidence.&rdquo;
<em>American Economic Review</em>, <b>94</b>(5), 1476-1504.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ndvuong(turnout$group, turnout$intens)
ndvuong(turnout$group, turnout$sur)
ndvuong(turnout$intens, turnout$sur)
</code></pre>

<hr>
<h2 id='twa'>Temporary help jobs and permanent employment</h2><span id='topic+twa'></span>

<h3>Description</h3>

<p>a cross-section of 2030 individuals
</p>


<h3>Format</h3>

<p>a tibble containing:
</p>

<ul>
<li><p> id: identification code
</p>
</li>
<li><p> age: age
</p>
</li>
<li><p> sex: a factor with levels <code>"female"</code> and <code>"male"</code>
</p>
</li>
<li><p> marital: marital status, <code>"married"</code> or <code>"single"</code>
</p>
</li>
<li><p> children: number of children
</p>
</li>
<li><p> feduc: father's education
</p>
</li>
<li><p> fbluecol: father blue-color
</p>
</li>
<li><p> femp: father employed at time 1
</p>
</li>
<li><p> educ: years of education
</p>
</li>
<li><p> pvoto: mark in last degree as fraction of max mark
</p>
</li>
<li><p> training: received professional training before treatment
</p>
</li>
<li><p> dist: distance from nearest agency
</p>
</li>
<li><p> nyu: fraction of school-to-work without employment
</p>
</li>
<li><p> hour: weekly hours of work
</p>
</li>
<li><p> wage: monthly wage
</p>
</li>
<li><p> hwage: hourly wage at time 1
</p>
</li>
<li><p> contact: contacted a temporary work agency
</p>
</li>
<li><p> region: one of  <code>"Tuscany"</code> and <code>"Sicily"</code>
</p>
</li>
<li><p> city: the city
</p>
</li>
<li><p> group: one of <code>"control"</code> and <code>"treated"</code>
</p>
</li>
<li><p> sector: the sector
</p>
</li>
<li><p> occup: occupation, one of <code>"nojob"</code>, <code>"selfemp"</code>, <code>"bluecol"</code> and <code>"whitecol"</code>
</p>
</li>
<li><p> empstat: employment status, one of <code>"empl"</code>, <code>"unemp"</code> and <code>"olf"</code> (out of labor force)
</p>
</li>
<li><p> contract: job contract, one of <code>"nojob"</code>, <code>"atyp"</code> (atypical) and <code>"perm"</code> (permanent)
</p>
</li>
<li><p> loc: localisation, one of <code>"nord"</code>, <code>"centro"</code>, <code>"sud"</code> and <code>"estero"</code>
</p>
</li>
<li><p> outcome: one of <code>"none"</code>, <code>"other"</code>, <code>"fterm"</code> and <code>"perm"</code>
</p>
</li></ul>



<h3>Source</h3>

<p>Journal of Applied Econometrics Data Archive : <a href="http://qed.econ.queensu.ca/jae/">http://qed.econ.queensu.ca/jae/</a>
</p>


<h3>References</h3>

<p>Ichino A, Mealli F, Nannicini T (2008).
&ldquo;From Temporary Help Jobs to Permanent Employment: What Can We Learn from Matching Estimators and Their Sensitivity?&rdquo;
<em>Journal of Applied Econometrics</em>, <b>23</b>(3), 305&ndash;327.
</p>

<hr>
<h2 id='vuong_sim'>Simulated pdfs for the Vuong statistics using linear models</h2><span id='topic+vuong_sim'></span>

<h3>Description</h3>

<p>This function can be used to reproduce the examples given by Shi
(2015) which illustrate the fact that the distribution of the Vuong
statistic may be very different from a standard normal
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vuong_sim(N = 1000, R = 1000, Kf = 15, Kg = 1, a = 0.125)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vuong_sim_+3A_n">N</code></td>
<td>
<p>sample size</p>
</td></tr>
<tr><td><code id="vuong_sim_+3A_r">R</code></td>
<td>
<p>the number of replications</p>
</td></tr>
<tr><td><code id="vuong_sim_+3A_kf">Kf</code></td>
<td>
<p>the number of covariates for the first model</p>
</td></tr>
<tr><td><code id="vuong_sim_+3A_kg">Kg</code></td>
<td>
<p>the number of covariates for the second model</p>
</td></tr>
<tr><td><code id="vuong_sim_+3A_a">a</code></td>
<td>
<p>the share of the variance of <code>y</code> explained by the two
competing models</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a numeric of length <code>N</code> containing the values of the Vuong statistic
</p>


<h3>References</h3>

<p>Shi X (2015).
&ldquo;A nondegenerate Vuong test.&rdquo;
<em>Quantitative Economics</em>, 85-121.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>vuong_sim(N = 100, R = 10, Kf = 10, Kg = 2, a = 0.5)
</code></pre>

<hr>
<h2 id='zellner_revankar'>Generalized production function</h2><span id='topic+zellner_revankar'></span>

<h3>Description</h3>

<p>Log-likelihood function for the generalized production function of
Zellner and Revankar (1969)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>zellner_revankar(
  theta,
  y,
  Z,
  sum = FALSE,
  gradient = TRUE,
  hessian = TRUE,
  repar = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="zellner_revankar_+3A_theta">theta</code></td>
<td>
<p>the vector of parameters</p>
</td></tr>
<tr><td><code id="zellner_revankar_+3A_y">y</code></td>
<td>
<p>the vector of response</p>
</td></tr>
<tr><td><code id="zellner_revankar_+3A_z">Z</code></td>
<td>
<p>the matrix of covariates</p>
</td></tr>
<tr><td><code id="zellner_revankar_+3A_sum">sum</code></td>
<td>
<p>if <code>FALSE</code>, a vector of individual contributions to the
likelihood and the matrix of individual contributions to the
gradient are returned, if <code>TRUE</code> a log-likelihood scalar and a
gradient vector are returned</p>
</td></tr>
<tr><td><code id="zellner_revankar_+3A_gradient">gradient</code></td>
<td>
<p>if <code>TRUE</code>, the gradient is returned as an attribute</p>
</td></tr>
<tr><td><code id="zellner_revankar_+3A_hessian">hessian</code></td>
<td>
<p>if <code>TRUE</code>, the hessian is returned as an attrubute</p>
</td></tr>
<tr><td><code id="zellner_revankar_+3A_repar">repar</code></td>
<td>
<p>if <code>TRUE</code>, the likelihood is parametrized such that
the constant return to scale hypothesis implies that two
coefficients are 0</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a function.
</p>


<h3>Author(s)</h3>

<p>Yves Croissant
</p>


<h3>References</h3>

<p>Zellner A, Revankar NS (1969).
&ldquo;Generalized Production Functions.&rdquo;
<em>Review of Economic Studies</em>, <b>36</b>(2), 241-250.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
