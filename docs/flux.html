<!DOCTYPE html><html><head><title>Help for package flux</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {flux}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#amc'>
<p>Climate station data from 2009 to 2011 in the Ahlenmoor peat bog, Northeast Germany</p></a></li>
<li><a href='#amd'>
<p>Closed chamber fluxes from 2009 to 2011 in the Ahlenmoor peat bog, Northeast Germany</p></a></li>
<li><a href='#append.df'>
<p>Append a data.frame to another including consistency checks</p></a></li>
<li><a href='#auc'>
<p>Calculate the area under a line(curve).</p></a></li>
<li><a href='#budget.ie'>
<p>Estimate interpolation errors for GPP and Reco budgets</p></a></li>
<li><a href='#budget.reco'>
<p>Predict fluxes from GPP and Reco models and prepare for summing them up to budgets.</p></a></li>
<li><a href='#checkm'>
<p>Bring modelled and measured values together based on timestamp</p></a></li>
<li><a href='#chop'>
<p>Prepare data for flux rate estimation with <code>flux</code> or GPP/Reco modelling.</p></a></li>
<li><a href='#export'>
<p>simple export wrapper</p></a></li>
<li><a href='#flux'>
<p>Estimate gas flux rates using non-steady-state closed chamber data</p></a></li>
<li><a href='#flux-internal'><p> Internal functions of the package flux that are usually not called (or only implicitly) by the user</p></a></li>
<li><a href='#flux-package'>
<p>Flux rate estimation with dynamic closed chamber data</p></a></li>
<li><a href='#flux.calib'>
<p>Determine calibration measurement ranges according to the dates of real measurements</p></a></li>
<li><a href='#fluxx'>
<p>Estimate (ghg) flux rates from online dynamic closed chamber measurements in through-flow mode.</p></a></li>
<li><a href='#gflux'>
<p>Calculate gas flux rate from two concentrations</p></a></li>
<li><a href='#gpp'>
<p>Model GPP from CO2 closed chamber flux data</p></a></li>
<li><a href='#inspect'>
<p>Inspect and alter prepared ghg concentration data</p></a></li>
<li><a href='#lips'>
<p>Linear interpolation between data points similar to approx.</p></a></li>
<li><a href='#modjust'>
<p>Adjust Reco models</p></a></li>
<li><a href='#plot.fluss'>
<p>Functions for bulk plotting of concentration change with time as kind of</p>
diagnostic plots for flux rate calculations</a></li>
<li><a href='#plot.gpp'>
<p>Plot diagnostic plots for GPP (NEE) models derived with reco and gpp.</p></a></li>
<li><a href='#plot.reco'>
<p>Plot diagnostic plots for Reco models.</p></a></li>
<li><a href='#reco'>
<p>Model R_eco from CO2 exchange closed chamber data.</p></a></li>
<li><a href='#reco.bulk'>
<p>Bulk fitting of Reco and GPP models</p></a></li>
<li><a href='#round.POSIXlt'>
<p>Round times.</p></a></li>
<li><a href='#tbl8'>
<p>Extract the relevant data of a bulk model object to a data.frame</p></a></li>
<li><a href='#tt.nee'>
<p>Medium frequency concentration data and fluxes from non-steady state closed chamber measurements</p></a></li>
<li><a href='#tt.pre'>
<p>One day data from closed chamber measurements in the Trebeltal</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Flux Rate Calculation from Dynamic Closed Chamber Measurements</td>
</tr>
<tr>
<td>Version:</td>
<td>0.3-0.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2014-04-23</td>
</tr>
<tr>
<td>Author:</td>
<td>Gerald Jurasinski, Franziska Koebsch, Anke Guenther, Sascha Beetz</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Gerald Jurasinski &lt;gerald.jurasinski@uni-rostock.de&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.12.0), caTools</td>
</tr>
<tr>
<td>Description:</td>
<td>Functions for the calculation of greenhouse gas flux rates 
	from closed chamber concentration measurements. The package follows 
	a modular concept: Fluxes can be calculated in just two simple steps 
	or in several steps if more control in details is wanted. Additionally 
	plot and preparation functions as well as functions for modelling
	gpp and reco are provided.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-06-26 06:52:26 UTC; hornik</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-06-26 06:58:11 UTC</td>
</tr>
</table>
<hr>
<h2 id='amc'>
Climate station data from 2009 to 2011 in the Ahlenmoor peat bog, Northeast Germany 
</h2><span id='topic+amc'></span>

<h3>Description</h3>

<p>Climatic variables measured from 2009 to 2011 in the Ahlenmoor peat bog, Northeast Germany as part of a closed chamber measurement study on GHG exchange.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(amc)</code></pre>


<h3>Format</h3>

<p>A data frame with 43197 observations on the following 8 variables.
</p>

<dl>
<dt><code>date</code></dt><dd><p>Factor giving the date of field sampling, format is &quot;%Y-%m-%d&quot;.</p>
</dd>
<dt><code>time</code></dt><dd><p>Factor giving the time of measurement in the field, format is &quot;%H:%M:%S&quot;.</p>
</dd>
<dt><code>t.air</code></dt><dd><p>Numeric. Average air temperatures in °C</p>
</dd>
<dt><code>t.soil2</code></dt><dd><p>Numeric. Average soil temperatures in 2cm depth in °C</p>
</dd>
<dt><code>t.soil5</code></dt><dd><p>Numeric. Average soil temperatures in 5cm depth in °C</p>
</dd>
<dt><code>t.soil10</code></dt><dd><p>Numeric. Average soil temperatures in 10cm depth in °C</p>
</dd>
<dt><code>PAR</code></dt><dd><p>Numeric. Average half hourly photosynthetically active radiation during the flux measurement. Actually represents PPFD (photon flux density) in micromole per sqm and second</p>
</dd>
<dt><code>timestamp</code></dt><dd><p>POSIXlt representing the date and time for the measurements</p>
</dd>
</dl>



<h3>Source</h3>

<p>Diss Sascha
</p>


<h3>References</h3>

<p>Beetz (2014) ...
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(amc)
</code></pre>

<hr>
<h2 id='amd'>
Closed chamber fluxes from 2009 to 2011 in the Ahlenmoor peat bog, Northeast Germany 
</h2><span id='topic+amd'></span>

<h3>Description</h3>

<p>CO2 exchange rates determined with closed chamber measurements and cooresponding measurements of temperatures, photosynthetically actiove radiation, and other variables in the Ahlen-Falkenberger Moor peat bog complex from 2009 to 2011 on one specific plot (3 replicates) ....
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(amd)</code></pre>


<h3>Format</h3>

<p>A data frame with 559 observations on the following 14 variables.
</p>

<dl>
<dt><code>timestamp</code></dt><dd><p>POSIXlt representing the date and time for the measurements</p>
</dd>
<dt><code>campaign</code></dt><dd><p>Numeric. Representing IDs of the measurement campaigns, i.e. data sharing on campaign were acquired within short time period (typically one day but sometimes also two consecutive days)</p>
</dd>
<dt><code>plot</code></dt><dd><p>Numeric. Representing the field plot numbers</p>
</dd>
<dt><code>kind</code></dt><dd><p>Character vector giving the kind of chamber measurements. Either &quot;D&quot; for dark (opaque) chamber measurements (i.e., <code class="reqn">R_{eco}</code> measurements) or &quot;T&quot; for transparent chamber measurements (i.e., NEE measurements)</p>
</dd>
<dt><code>flux</code></dt><dd><p>Numeric. The estimated flux rate. CO2 exchange in micromole per sqm and second</p>
</dd>
<dt><code>PAR</code></dt><dd><p>Numeric. Average photosynthetically active radiation during the flux measurement. Actually represents PPFD (photon flux density) in micromole per sqm and second</p>
</dd>
<dt><code>t.air</code></dt><dd><p>Numeric. Average air temperature during chamber measurement in °C</p>
</dd>
<dt><code>t.soil2</code></dt><dd><p>Numeric. Average soil temperature in 2cm depth during chamber measurement in °C</p>
</dd>
<dt><code>t.soil5</code></dt><dd><p>Numeric. Average soil temperature in 5cm depth during chamber measurement in °C</p>
</dd>
<dt><code>t.soil10</code></dt><dd><p>Numeric. Average soil temperature in 10cm depth during chamber measurement in °C</p>
</dd>
<dt><code>n.meas</code></dt><dd><p>Numeric giving the number of concentration measurements that were available to estimate the flux</p>
</dd>
<dt><code>duration</code></dt><dd><p>Factor with 282 levels giving the duration of measurement in the field, format is &quot;%H:%M&quot;</p>
</dd>
<dt><code>r.squared</code></dt><dd><p>Numeric. The R2s of the linear regression models that were fit to the concentration data to estimate the fluxes (with <code><a href="#topic+fluxx">fluxx</a></code>)</p>
</dd>
<dt><code>sigmif</code></dt><dd><p>Numeric. The significance of the linear regression models</p>
</dd>
</dl>



<h3>Source</h3>

<p>Saschas Doktorarbeit
</p>


<h3>References</h3>

<p>Beetz S (2014) ???
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(amd)
</code></pre>

<hr>
<h2 id='append.df'>
Append a data.frame to another including consistency checks
</h2><span id='topic+append.df'></span>

<h3>Description</h3>

<p>Often ghg concentration data come in chunks. This function provides a wrapper for appending data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>append.df(orig, add)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="append.df_+3A_orig">orig</code></td>
<td>

<p>A data.frame
</p>
</td></tr>
<tr><td><code id="append.df_+3A_add">add</code></td>
<td>

<p>Another data.frame
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The two data.frames are appended based on common columns. A warning is issued if some column names do not match. New columns are silently added.
</p>


<h3>Value</h3>

<p>Data.frame 
</p>


<h3>Author(s)</h3>

<p>Gerald Jurasinski &lt;gerald.jurasinski@uni-rostock.de&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## add later
</code></pre>

<hr>
<h2 id='auc'>
Calculate the area under a line(curve).
</h2><span id='topic+auc'></span><span id='topic+auc.mc'></span>

<h3>Description</h3>

<p>Calculates the <strong>a</strong>rea <strong>u</strong>nder a <strong>c</strong>urve (integral) following the trapezoid rule. With <code>auc.mc</code> several Monte Carlo methods can be applied to obtain error terms for estimating the interpolation error for the integration.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>auc(x, y, thresh = NULL, dens = 100, sort.x = TRUE)

auc.mc(x, y, method = "leave out", lo = 2, it = 100, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="auc_+3A_x">x</code></td>
<td>
<p> Numerical vector giving the x cordinates of the points of the line (curve). </p>
</td></tr>
<tr><td><code id="auc_+3A_y">y</code></td>
<td>
<p> Numerical vector giving the y cordinates of the points of the line (curve). One can calculate the integral of a fitted line through giving a vector to <code>x</code> that spans <code>xlim</code> with small intervals and predicting the y coordinates with <code><a href="stats.html#topic+predict">predict</a></code> and that <code>x</code>-vector as <code>newdata</code>. See example. </p>
</td></tr>
<tr><td><code id="auc_+3A_thresh">thresh</code></td>
<td>
<p> Threshold below which area is not calculated. Can be used to deal with unrealistically low flux data. By default <code>thresh</code> is set to <code>NULL</code> and therefore the complete area below the zero line is subtracted from the area above the zero line to integrate the area under the curve. When data below a certain value make no sense for your question, you are able to set <code>thresh</code>. Then, all y-values below <code>thresh</code> are set to the value of <code>thresh</code> and the regarding areas below <code>thresh</code> are not subtracted from the total area. </p>
</td></tr>
<tr><td><code id="auc_+3A_dens">dens</code></td>
<td>
<p> By default the data density is artificially increased by adding 100 data points between given adjacent data points. These additional data points are calculated by linear interpolation along x and y. When a threshold is set, this procedure increases the accuracy of the result. Setting <code>dens</code> has no effect on the result when <code>thresh</code> is set to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="auc_+3A_sort.x">sort.x</code></td>
<td>
<p> By default the vectors in <code>x</code> and <code>y</code> are ordered along increasing <code>x</code> because integration makes no sense with unordered data. You can override this by setting <code>sort.x</code> = <code>FALSE</code>
</p>
</td></tr>
<tr><td><code id="auc_+3A_method">method</code></td>
<td>

<p>Specify how interpolation error should be estimated. Available methods include <code>"leave out"</code>, <code>"bootstrap"</code>, <code>"sorted bootstrap"</code>, <code>"constrained bootstrap"</code>, <code>"jackknife"</code>, <code>"jack-validate"</code>. True bootstrap is only effective when <code>sort.x</code> = <code>FALSE</code>. See details.
</p>
</td></tr>
<tr><td><code id="auc_+3A_lo">lo</code></td>
<td>

<p>When estimating interpolation error with <code>"leave out"</code> or <code>"jack-validate"</code>, how many data points should be left out randomly? Defaults to 2. See <code>method</code> and details.
</p>
</td></tr>
<tr><td><code id="auc_+3A_it">it</code></td>
<td>

<p>How many iterations should be run when using <code>auc.mc</code> to estimate the interpolation error. Defaults to 100.
</p>
</td></tr>
<tr><td><code id="auc_+3A_...">...</code></td>
<td>

<p>Any arguments passed through to <code>auc</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>During integration the underlying assumption is that values can be interpolated linearly between adjacent data points. In many cases this is questionable. For estimating the linear interpolation error from the data at hand one may use Monte Carlo resampling methods. In <code>auc.mc</code> the following approaches are available:
</p>

<ul>
<li> <p><code>leave out</code>: In each run <code>lo</code> data points are randomly omitted. This is quite straightforward, but the number of data points left out (<code>lo</code>) is arbitrary and thus the error terms estimated with this approach may be hardly defensible.
</p>
</li>
<li> <p><code>bootstrap</code>: Data are bootstrapped (sampling with replacement). Thus, some data points may repeat whereas others may be omitted. Due to the random sampling the order of data points is changed which may be unwanted with times series and may produce largely exaggerated error terms. This is only effective if <code>sort.x = FALSE</code>.
</p>
</li>
<li> <p><code>sorted bootstrap</code>: Same as before but ordering along <code>x</code> after bootstrapping may cure some problems of changed order. However, due to repeated data points time series spreading seasons but having data showing distinct seasonality may still be misrepresented.
</p>
</li>
<li> <p><code>constrained bootstrap</code>: Same as before but after ordering repeated data points are omitted. Thus, this equals leaving some measurements out at each run with a random number of leave outs. Numbers of leave outs typically show normal distribution around 3/4n.
</p>
</li>
<li> <p><code>jackknife</code>: <code>auc</code> is calculated for all possible combinations of <code>length(x)-1</code> data points. Depending on <code>length(x)</code> the number of combinations can be quite low.
</p>
</li>
<li> <p><code>jack-validate</code>: <code>auc</code> is calculated for all possible combinations of <code>(length(x)-lo)</code> : <code>(length(x)-1)</code> data points. Partly cures the &quot;arbitrarity&quot; problem of the <code>leave out</code> approach and produces stable summary statistics.
</p>
</li></ul>



<h3>Value</h3>

<p><code>auc</code> returns a numeric value that expresses the area under the curve. The unit depends from the input.
</p>
<p><code>auc.mc</code> returns a numeric vector containing the <code>auc</code> values of the <code>it</code> permutations. Just calculate summary statistics from this as you like. Due to the sampling approaches means and medians are not stable for most of the methods. <code>jackknife</code> and  <code>jack-validate</code> produce repeatable results, in the case of <code>leave out</code> it depends on n (<code>length(x)</code>) and <code>it</code>.
</p>


<h3>Author(s)</h3>

<p>Gerald Jurasinski, <a href="mailto:gerald.jurasinski@uni-rostock.de">gerald.jurasinski@uni-rostock.de</a>
</p>


<h3>See Also</h3>

 <p><code><a href="caTools.html#topic+trapz">trapz</a></code>, <code><a href="stats.html#topic+integrate">integrate</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Construct a data set (Imagine 2-hourly ghg emission data
## (methane) measured during a day).
## The emission vector (data in mg CH4 / m2*h) as a time series.
ghg &lt;- ts(c(12.3, 14.7, 17.3, 13.2, 8.5, 7.7, 6.4, 3.2, 19.8, 
22.3, 24.7, 15.6, 17.4), start=0, end=24, frequency=0.5)
## Have a look at the emission development.
plot(ghg)
## Calculate what has been emitted that day
## Assuming that emissions develop linearly between
## measurements
auc(time(ghg), ghg)

## Test some of the auc.mc approaches
## "leave out" as default
auc.rep &lt;- auc.mc(time(ghg), ghg)
## mean and median are well below the original value
summary(auc.rep)
## results for "bootstrap" are unstable (run several times)
auc.rep &lt;- auc.mc(time(ghg), ghg, "boot")
summary(auc.rep)
## results for "jack-validate" are stable (run several times)
auc.rep &lt;- auc.mc(time(ghg), ghg, "jack-val", lo=3)
summary(auc.rep)

## The effect of below.zero:
## Shift data, so that we have negative emissions (immissions)
ghg &lt;- ghg-10
## See the difference
plot(ghg)
abline(h=0)
## With thresh = NULL the negative emissions are subtracted
## from the positive emissions
auc(time(ghg), ghg)
## With thresh = -0.5 the negative emissions are set to -0.5
## and only the emissions &gt;= -0.5 count.
auc(time(ghg), ghg, thresh = -0.5)

</code></pre>

<hr>
<h2 id='budget.ie'>
Estimate interpolation errors for GPP and Reco budgets
</h2><span id='topic+budget.ie'></span>

<h3>Description</h3>

<p>Use several MC methods to estimate the uncertainty associated with the interpolation of fluxes between models when preparing time series data for budgeting <code class="reqn">R_{eco}</code>, GPP (and finally NEE) with <code><a href="#topic+budget.reco">budget.reco</a></code> and <code><a href="#topic+budget.gpp">budget.gpp</a></code>. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>budget.ie(bdgt, method = "leave out", lo = 2, it = 100)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="budget.ie_+3A_bdgt">bdgt</code></td>
<td>

<p>An object deriving from running <code><a href="#topic+budget.reco">budget.reco</a></code> or <code><a href="#topic+budget.gpp">budget.gpp</a></code>. The budget should cover a reasonable time span, e.g. a year or even better, a calender year and must have been derived with <code>return.models</code> = <code>TRUE</code> and with a <code>set.back</code> that only defines start and end dates. See example at <code><a href="#topic+budget.reco">budget.reco</a></code>.
</p>
</td></tr>
<tr><td><code id="budget.ie_+3A_method">method</code></td>
<td>

<p>Specify how interpolation error should be estimated. Available methods include <code>"leave out"</code>, <code>"bootstrap"</code>, <code>"sorted bootstrap"</code>, <code>"constrained bootstrap"</code>, <code>"jackknife"</code>, <code>"jack-validate"</code>. True bootstrap is only effective when <code>sort.x</code> = <code>FALSE</code>. See <code><a href="#topic+auc.mc">auc.mc</a></code> for details.
</p>
</td></tr>
<tr><td><code id="budget.ie_+3A_lo">lo</code></td>
<td>

<p>When estimating interpolation error with <code>"leave out"</code> or <code>"jack-validate"</code>, how many data points should be left out randomly? Defaults to 2. See <code>method</code> and details.
</p>
</td></tr>
<tr><td><code id="budget.ie_+3A_it">it</code></td>
<td>

<p>How many iterations should be run? Defaults to 100. Not effective for methods <code>"jackknife"</code>, and <code>"jack-validate"</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>ATTENTION: It takes a while. How long one budget run takes depends on the length of the <code>bdgt</code> but typically takes about 5 seconds. So if you run with defaults (<code>it</code> = 100) it may take some minutes. Progress is shown in the console with numbers representing the runs separated by colons.
</p>
<p>The approaches are quite similar to the ones in <code><a href="#topic+auc.mc">auc.mc</a></code>. However, the function randomly samples from a list of models and then runs the complete budgeting via <code><a href="#topic+budget.reco">budget.reco</a></code> or <code><a href="#topic+budget.gpp">budget.gpp</a></code>. This is done either <code>it</code> times or as often as needed to get all combinations that are possible (for methods <code>"jackknife"</code>, and <code>"jack-validate"</code>).
</p>


<h3>Value</h3>

<p>A vector of budgets. 
</p>


<h3>Author(s)</h3>

<p>Gerald Jurasinski, <a href="mailto:gerald.jurasinski@uni-rostock.de">gerald.jurasinski@uni-rostock.de</a>,
</p>


<h3>References</h3>

<p>Beetz S, Liebersbach H, Glatzel S, Jurasinski G, Buczko U, Hoper H (2013) Effects of land use intensity on the full greenhouse gas balance in an Atlantic peat bog. Biogeosciences 10:1067-1082
</p>


<h3>See Also</h3>

<p><code><a href="#topic+reco.bulk">reco.bulk</a></code>, <code><a href="#topic+gpp.bulk">gpp.bulk</a></code>, <code><a href="#topic+modjust">modjust</a></code>, <code><a href="#topic+budget.reco">budget.reco</a></code>, <code><a href="#topic+budget.gpp">budget.gpp</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## See examples at budget.reco

</code></pre>

<hr>
<h2 id='budget.reco'>
Predict fluxes from GPP and Reco models and prepare for summing them up to budgets.
</h2><span id='topic+budget.reco'></span><span id='topic+budget.gpp'></span>

<h3>Description</h3>

<p>The functions predict fluxes from GPP and <code class="reqn">R_{eco}</code> models and prepare the data for summing them up to budgets including feeding in set.back positions and values (e.g. to truncate the output or to acknowledge the harvesting of biomass) and several adjustments and corrections.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>budget.reco(models, new.data, set.back = NULL, time.unit = "extract", 
adjust = TRUE, correct = list(thresh = "get", cvrm = TRUE, wndw = 12, 
intvl = 0.95), return.models = FALSE)

budget.gpp(models, new.data, set.back = NULL, time.unit = "extract", 
adjust = FALSE, correct = list(thresh = "get", cvrm = TRUE, wndw = 12, 
intvl = 0.95), PAR.correct = 100, return.models = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="budget.reco_+3A_models">models</code></td>
<td>

<p>List model objects of class <code>"breco"</code> or <code>"bgpp"</code>
</p>
</td></tr>
<tr><td><code id="budget.reco_+3A_new.data">new.data</code></td>
<td>

<p>Data from a climate station or other logging facility including timestamps. For <code class="reqn">R_{eco}</code>  all temperature variables that have been used to construct the models are needed. For GPP PAR values are needed and the respective column must be named &quot;PAR&quot;. The timestamp column (<code>POSIXt</code>) must be named &quot;timestamp&quot;.
</p>
</td></tr>
<tr><td><code id="budget.reco_+3A_set.back">set.back</code></td>
<td>

<p>Data.frame with two columns, the first a <code>timestamp</code> and the second either a <code>value</code> of <code class="reqn">R_{eco}</code> or GPP, to which fluxes should be set at the date and time in timestamp. Additionally, the second column can contain a value of <code>-999</code> or <code>-9999</code> for the start or end of the data series during budgeting.
</p>
</td></tr>
<tr><td><code id="budget.reco_+3A_time.unit">time.unit</code></td>
<td>

<p>By default the time intervals between data points in <code>new.data</code> are extracted from the <code>timestamp</code> vector. However, by setting <code>time.unit</code> you can additionally give a number that represents the interval in seconds. The function uses this information to linearly interpolate values via <code><a href="#topic+lips">lips</a></code> when some are missing.
</p>
</td></tr>
<tr><td><code id="budget.reco_+3A_adjust">adjust</code></td>
<td>

<p>Logical. When <code>TRUE</code>, predicted fluxes are adjusted by fitting a linear model to the relationship of predicted to measured fluxes and extracting the slope. This  slope value is then used to adjust all predicted fluxes by calculating <code>flux</code> / <code>slope</code>. This is applied to the finished time series of fluxes. For <code>budget.reco</code> default is <code>TRUE</code> whereas for <code>budget.gpp</code> default is <code>FALSE</code>. See details.
</p>
</td></tr>
<tr><td><code id="budget.reco_+3A_correct">correct</code></td>
<td>

<p>This triggers a further correction: Unreasonably high fluxes or spikes are identified and eliminated. This is applied to the finished time series of fluxes. The argument requires a named list with the entries <code>thresh</code>, <code>cvrm</code> (logical), <code>wndw</code>, and <code>intvl</code>. When no correction is wanted set <code>correct</code> = <code>NULL</code>. See details.
</p>
</td></tr>
<tr><td><code id="budget.reco_+3A_par.correct">PAR.correct</code></td>
<td>

<p>Numeric representing the value of PAR (e.g. PPFD in micromole per squaremeter per second) below which GPP is assumed to be 0. This is applied to the finished time series of fluxes. All predicted GPP fluxes are corrected to 0 according to this value. See details.
</p>
</td></tr>
<tr><td><code id="budget.reco_+3A_return.models">return.models</code></td>
<td>

<p>Logical. Shall models be returned?
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><b>How does it work?</b> Both functions take a list of model objects (of class <code>"breco"</code> for <code class="reqn">R_{eco}</code> models and of class <code>"bgpp"</code> for GPP) and predict fluxes via <code><a href="stats.html#topic+predict.nls">predict.nls</a></code>. The required variables are taken from <code>new.data</code>. Fluxes are predicted for each model either for the whole time interval in <code>new.data</code> or when <code>set.back</code> is given with start and end configuration (values <code>-999</code> and <code>-9999</code>) for the defined time period. If the integration period is defined with <code>set.back</code>, the models that are temporally closest to the start and end times are duplicated and get the respective timestamps. With all models, fluxes are predicted forward from the date and time the models are hooked onto (argument <code>hook</code> in <code><a href="#topic+reco.bulk">reco.bulk</a></code> and <code><a href="#topic+gpp.bulk">gpp.bulk</a></code>) up to the next model's date and time as well as backward down to the previous model's date and time. The resulting two flux vectors for the time period between two consecutive models (one based on the first, the other based on the second model) are linearly interpolated (see below). The same is done for the model errors. Errors are extracted from the model objects and assigned to each interpolated flux from one model to the next and to the previous. Then they are linearly interpolated (see  below).
</p>
<p>Further, IDs are assigned to the weighted fluxes to identify the periods between two models. This is needed later for model error propagation. The fluxes in the time series between the first and the second model in the whole list get ID = 1, the fluxes in the time series between the second and the third model in the whole list get ID = 2, and so on.
</p>
<p><b>How does interpolation work?</b> Linear interpolation of the two vectors (one based on the first model, the other based on the second model) is achieved by calculating weighted means of the integrated fluxes for each date and time with the weights the distances in time to the corresponding model timestamp. Thus, close to the one model timestamp the weighted mean of the two fluxes is almost entirely determined by that model, in the middle of the time series between two model dates both fluxes contribute equally to the mean and close to the other model timestamp the weighted mean of the two fluxes is almost entirely determined by that other model.
</p>
<p><b>Why <code>adjust</code>?</b> It may happen that in sum the various models in a seasonal, annual or even bigger dat set tend to over- or underestimate the measured fluxes. To correct for this, the predicted fluxes can be adjusted as explained above. This typically leads to better overall modelling performance.
</p>
<p><b>Why <code>correct</code>?</b> Especially with locally fitted <code class="reqn">R_{eco}</code> models it happens - most often with winter data - that predicted fluxes are much higher than supported by the measurements because of the exponential element in fitting <code class="reqn">R_{eco}</code> models. The model itself is fine but may have been fitted to temperature data spanning a relatively small range. If the temperatures in <code>new.data</code> are much higher (in relative terms), then unreasonable high fluxes may result. Such fluxes are identified and eliminated by <code>correct</code>. 
</p>
<p><b>How is <code>correct</code>ed?</b> <code>thresh</code> specifies a maximum predicted flux allowed. When set to &quot;get&quot; (default) it is determined based on the data that were used to construct the models and represents the highest flux ever measured across all campaigns of the series. <code>cvrm</code> (logical) triggers whether further despiking should be done with <code>wndw</code> the width of the moving window in which the coefficient of variation (cv) is calculated and <code>intvl</code> the probability of the <code><a href="stats.html#topic+quantile">quantile</a></code> against which cv should be tested. All fluxes with corresponding cv &gt; <code>quantile(cv, intvl)</code> are eliminated.
</p>
<p><b>Why <code>PAR.correct</code>?</b> Because the function not only predicts with all the provided models using <code>new.data</code> but also interpolates linearly between models, it happens that unreasonable GPP values are predicted reflecting photosynthesis under no or very low light conditions. These are just set to plant physiologically sensible 0. <code>PAR.correct</code>ion is done after inserting <code>set.back</code>(s) for cutting(s).
</p>
<p>All data gaps resulting from corrections are then filled with linear interpolation from the values adjacent to the gap via <code><a href="#topic+lips">lips</a></code>.
</p>
<p><b>How <code>set.back</code> is used to factor in cut dates or the like:</b>. When further <code>set.back</code> values are given in addition to the definition of the start and end dates, e.g. to acknowledge for biomass removal when predicting GPP fluxes, two things happen. First, the time series of fluxes resulting from all of the above is changed like this: At the date and time of a cut the flux  is set to the value given in <code>set.back</code> and then fluxes are linearly interpolated to the next proper model date by weighted means in the same manner as described above. Second, cut models are defined as linear models and integrated into the model list according to their timestamp. Thus, when run with <code>return.models = TRUE</code>, the updated model list can be used with <code>tbl8</code> to extract the relevant model parameters.
</p>


<h3>Value</h3>

<p>Both functions return a <code>data.frame</code> (called <code>tbl</code>) containing the predicted values, timestamps, etc. and optionally an object of class <code>"breco"</code> or <code>"bgpp"</code> (called <code>models</code>) containing the final models including the start and end models and any <code>set.back</code> models when <code>set.back</code>s were specified.
</p>
<p>For <code>budget.reco</code> <code>tbl</code> has 4 columns
</p>
<table>
<tr><td><code>reco.flux</code></td>
<td>
<p> Predicted and interpolated fluxes</p>
</td></tr>
<tr><td><code>reco.se</code></td>
<td>
<p> Model errors spawned across predicted and interpolated fluxes</p>
</td></tr>
<tr><td><code>reco.id</code></td>
<td>
<p> ID that identifies the model periods</p>
</td></tr>
<tr><td><code>timestamp</code></td>
<td>
<p> Timestamps</p>
</td></tr>
</table>
<p>For <code>budget.gpp</code> <code>tbl</code> has 4 columns
</p>
<table>
<tr><td><code>gpp.flux</code></td>
<td>
<p> Predicted and interpolated fluxes</p>
</td></tr>
<tr><td><code>gpp.se</code></td>
<td>
<p> Model errors spawned across predicted and interpolated fluxes</p>
</td></tr>
<tr><td><code>gpp.id</code></td>
<td>
<p> ID that identifies the model periods</p>
</td></tr>
<tr><td><code>timestamp</code></td>
<td>
<p> Timestamps</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Gerald Jurasinski, <a href="mailto:gerald.jurasinski@uni-rostock.de">gerald.jurasinski@uni-rostock.de</a>,
</p>
<p>with ideas by Sascha Beetz, <a href="mailto:sascha.beetz@uni-rostock.de">sascha.beetz@uni-rostock.de</a>
</p>


<h3>References</h3>

<p>Beetz S, Liebersbach H, Glatzel S, Jurasinski G, Buczko U, Hoper H (2013) Effects of land use intensity on the full greenhouse gas balance in an Atlantic peat bog. Biogeosciences 10:1067-1082
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fluxx">fluxx</a></code>, <code><a href="#topic+reco">reco</a></code>, <code><a href="#topic+gpp">gpp</a></code>, <code><a href="#topic+gpp2">gpp2</a></code>, <code><a href="#topic+reco.bulk">reco.bulk</a></code>, <code><a href="#topic+gpp.bulk">gpp.bulk</a></code>, <code><a href="#topic+modjust">modjust</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### The examples are consecutive and are a suggestion
### how to run the whole process from bulk modelling
### over corrections and checks to full budgets including
### propagated model and interpolation error terms.

## The whole examples section is marked as
## not run because parts take longer than
## accepted by CRAN incoming checks.
## Remove first hash in each line to run them.

## Not run ##
## load data
#data(amd)
#data(amc)
## set global conversion factor
## All fluxes are in micromole * m-2 * s-1,
## thus they are transformed to g CO2-C * m-2 *1/2h
#uf &lt;- 12*60*30/1000000
#
#### Reco ### (for details see reco.bulk)
## extract opaque (dark) chamber measurements 
#amr &lt;- amd[amd$kind=="D",]
## fit reco models
#r.models &lt;- reco.bulk(flux ~ t.air + t.soil2 + t.soil5 + 
#t.soil10 + timestamp, amr, amr$campaign, window=3, 
#remove.outliers=TRUE, method="arr", min.dp=2)
## adjust models
#r.models &lt;- modjust(r.models, alpha=0.1, min.dp=3)
#
### prepare Reco budget (predict half hourly values for two years)
## define set.back with start and end dates only
## (typically you would take this from read in table)
#set.back &lt;- data.frame(timestamp = c("2010-01-01 00:30", "2011-12-31 23:30"), 
#value = c(-999, -9999))
#set.back$timestamp &lt;- strptime(set.back$timestamp, format="%Y-%m-%d %H:%M", tz="GMT")
## run budget function with defaults
#r.bdgt &lt;- budget.reco(r.models, amc, set.back)
## prepare for quality check (global model of predicted ~ measured)
#r.check &lt;- checkm(r.bdgt, amr)
## have a look
#par(pty="s")
#lims &lt;- range(r.check$reco.flux, r.check$flux)
#plot(reco.flux ~ flux, data=r.check, xlim=lims, ylim=lims)
#abline(coef=c(0,1), lty=3)
#mf1 &lt;- lm(reco.flux ~ flux, r.check)
#abline(mf1)
#summary(mf1)
## calculate daily values (better for plotting)
#r.bdgt$day &lt;- format(r.bdgt$timestamp, format="%Y-%m-%d")
#r.daily &lt;- data.frame(day = unique(r.bdgt$day))
#r.daily$day &lt;- as.POSIXct(strptime(r.daily$day, format="%Y-%m-%d", 
#tz="GMT"), tz="GMT")
## in addition to summing up per day, change unit
#r.daily$reco &lt;- tapply(r.bdgt$reco.flux*uf, r.bdgt$day, sum)
## same for the model error terms
#r.daily$se &lt;- tapply(r.bdgt$reco.se*uf, r.bdgt$day, sum)
#
#
#### GPP ### (for details see gpp.bulk)
#g.models &lt;- gpp.bulk(flux ~ PAR + timestamp + kind, amd, amd$campaign, 
#method="Falge", min.dp=5)
#
### prepare GPP budget (predict half hourly values for two years)
## define set.back with start, end, and cut dates
## (typically you would take this from read in table)
#set.back &lt;- data.frame(timestamp = c("2010-01-01 00:30", "2011-12-31 23:30", 
#"2010-07-22 12:00", "2010-09-03 12:00", "2010-10-13 12:00", "2011-06-29 12:00", 
#"2011-08-11 12:00", "2011-10-21 12:00"), value = c(-999, -9999, rep(-0.0001, 6)))
#set.back$timestamp &lt;- strptime(set.back$timestamp, format="%Y-%m-%d %H:%M", tz="GMT")
## have a look at the resulting data.frame
#set.back
## run budget function with correct = NULL and return the models
#g.bdgt &lt;- budget.gpp(g.models, amc, set.back, correct=NULL, return.models=TRUE)
## the cut models are also returned:
#tbl8(g.bdgt$models)
## extract the half hourly values to proceed
#g.bdgt &lt;- g.bdgt$tbl
## make daily values (better for plotting)
#g.bdgt$day &lt;- format(g.bdgt$timestamp, format="%Y-%m-%d")
#g.daily &lt;- data.frame(day = unique(g.bdgt$day))
#g.daily$day &lt;- as.POSIXct(strptime(g.daily$day, format="%Y-%m-%d", tz="GMT"), tz="GMT")
## in addition to summing up per day, change unit
#g.daily$gpp &lt;- tapply(g.bdgt$gpp.flux*uf, g.bdgt$day, sum)
## same for the model error terms
#g.daily$se &lt;- tapply(g.bdgt$gpp.se*uf, g.bdgt$day, sum)
#
#
#### Budgets ###
### doing the actual budgeting
## first bring Reco and GPP budget data together
## because of different handling data sets
## may be of different length, therefore use merge
#r.bdgt$ts &lt;- as.character(r.bdgt$timestamp)
#g.bdgt$ts &lt;- as.character(g.bdgt$timestamp)
#bdgt &lt;- merge(r.bdgt, g.bdgt[, -c(ncol(g.bdgt)-2, ncol(g.bdgt)-1)], 
#by.x="ts", by.y="ts", all.x=TRUE)
## calculate NEE
#bdgt$nee.flux &lt;- bdgt$reco.flux + bdgt$gpp.flux
## error propagation 
#bdgt$nee.se &lt;- sqrt(bdgt$reco.se^2 + bdgt$gpp.se^2)/sqrt(2)
## define unique id that spans across reco and gpp ids
#bdgt$nee.id &lt;- paste(bdgt$reco.id, bdgt$gpp.id, sep=".")
## do budgets of fluxes (sum and use global conversion factor, see above) and error terms
## the model errors are summed up per model id and resulting
## sums are combined following error propagation
#with(bdgt, {c(
#  reco = sum(reco.flux*uf, na.rm=TRUE), 
#	reco.me = sqrt(sum(tapply(reco.se, reco.id, sum)^2))*uf, 
#	gpp = sum(gpp.flux*uf, na.rm=TRUE), 
#	gpp.me = sqrt(sum(tapply(gpp.se, gpp.id, sum)^2))*uf, 
#	nee = sum(nee.flux*uf, na.rm=TRUE), 
#	nee.me = sqrt(sum(tapply(nee.se, nee.id, sum, na.rm=TRUE)^2))*uf
#)})
#
### annual budget incl. interpolation error
#set.back &lt;- data.frame(timestamp = c("2010-01-01 00:30", 
#"2010-12-31 23:30"), value = c(-999, -9999))
#set.back$timestamp &lt;- strptime(set.back$timestamp, format="%Y-%m-%d %H:%M", tz="GMT")
### reco.ie
## redoing budget with annual bounds
#r.bdgt.2010 &lt;- budget.reco(r.models, amc, set.back, return.models=TRUE)
## run budget.ie with lo = 3 and it = 10 (default of 100 is advisable but slow)
#r.ie2010 &lt;- budget.ie(r.bdgt.2010, lo=3, it=10) 
## summary statistic and factor in the uf
#r.ie2010 &lt;- sd(r.ie2010*uf) 
## gpp.ie
## redoing budget with annual bounds
#g.bdgt.2010 &lt;- budget.gpp(g.models, amc, set.back, correct=NULL, return.models=TRUE)
#g.ie2010 &lt;- budget.ie(g.bdgt.2010, lo=3, it=10) 
#g.ie2010 &lt;- sd(g.ie2010*uf) 
#
## do the actual budgeting
#tmp &lt;- bdgt[(bdgt$timestamp &gt;= set.back$timestamp[1]) &amp; 
#(bdgt$timestamp &lt;= set.back$timestamp[2]),]
#with(tmp, {c(
#  reco = sum(reco.flux*uf, na.rm=TRUE), 
#	reco.me = sqrt(sum(tapply(reco.se, reco.id, sum)^2))*uf,
#	reco.ie = r.ie2010,
#	gpp = sum(gpp.flux*uf, na.rm=TRUE), 
#	gpp.me = sqrt(sum(tapply(gpp.se, gpp.id, sum)^2))*uf,
#	gpp.ie = g.ie2010, 
#	nee = sum(nee.flux*uf, na.rm=TRUE), 
#	nee.me = sqrt(sum(tapply(nee.se, nee.id, sum, na.rm=TRUE)^2))*uf,
#	nee.ie = sqrt(r.ie2010^2 + g.ie2010^2)
#)})
#
## End not run ##
</code></pre>

<hr>
<h2 id='checkm'>
Bring modelled and measured values together based on timestamp
</h2><span id='topic+checkm'></span>

<h3>Description</h3>

<p>Trivial function that is a simple wrapper for frequent task: Bringing together the measured and modelled values, for instance to do a posteriori analyses of model performance. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>checkm(modelled, measured, t.unit = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="checkm_+3A_modelled">modelled</code></td>
<td>

<p>A <code>data.frame</code> with the modelled fluxes and all additional data reported. For instance resulting from doing <code><a href="#topic+budget.reco">budget.reco</a></code> on a &quot;<code>breco</code>&quot; object. One variable has to be the timestamp and it should be named exactly like this.
</p>
</td></tr>
<tr><td><code id="checkm_+3A_measured">measured</code></td>
<td>

<p>A <code>data.frame</code> with the originally measured fluxes and additional data. One variable has to be the timestamp and it should be named exactly like this.
</p>
</td></tr>
<tr><td><code id="checkm_+3A_t.unit">t.unit</code></td>
<td>

<p>If NULL, data in <code>modelled</code> and <code>measured</code> are merged based on their timestamp by calculating the minimum difference in time between all entries (see Details). If !NULL, character string specifying to which time interval the timestamps in <code>measured</code> should be rounded using <code><a href="#topic+round.POSIXlt">round.POSIXlt</a></code>. May be one of <code>"mins"</code>, <code>"5mins"</code>, <code>"10mins"</code>, <code>"15mins"</code>, <code>"quarter hours"</code>, <code>"30mins"</code>, <code>"half hours"</code>, <code>"hours"</code>. Alternatively, a numeric specifying the minutes to round to. To go to seconds just use values &lt; 1, to go beyond the hour just use values &gt; 60.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><b>Case 1 (t.unit = NULL)</b> Data are merged by calculating the difference in time between all timestamps in <code>modelled</code> and all timestamps in <code>measured</code> and identifying the minimum difference to each measured flux. If minimum difference between measured and modelled flux &gt; 1h, no modelled flux is assigned. This approach is a bit slower but it is not necessary to give a correct <code>t.unit</code>, which makes it less error prone.
</p>
<p><b>Case 2 (t.unit != NULL)</b> After rounding the timestamps in <code>measured</code> according to <code>t.unit</code> and transforming both timestamnps to character vectors <code>modelled</code> and <code>measured</code> are merged based on these  timestamps and only data rows that are present in both are retained. Therefore <code>t.unit</code> has to be specified according to the interval of the timestamps in <code>modelled</code>.
</p>


<h3>Value</h3>

<p>Data.frame containing the corresponding rows of <code>modelled</code> and <code>measured</code>
</p>


<h3>Author(s)</h3>

<p>Gerald Jurasinski, <a href="mailto:gerald.jurasinski@uni-rostock.de">gerald.jurasinski@uni-rostock.de</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## See examples at reco.bulk
</code></pre>

<hr>
<h2 id='chop'>
Prepare data for flux rate estimation with <code><a href="#topic+flux">flux</a></code> or GPP/Reco modelling.
</h2><span id='topic+chop'></span>

<h3>Description</h3>

<p>The function simply constructs a list of <code><a href="base.html#topic+data.frame">data.frame</a></code>s that each contains the data for one closed chamber measurement or for one NEE/GPP or <code class="reqn">R_{eco}</code> model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>chop(dat, factors, nmes = NULL, min.cm = 3)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="chop_+3A_dat">dat</code></td>
<td>

<p><code><a href="base.html#topic+data.frame">data.frame</a></code> containing static closed chamber data for several chamber measurements. See columns and example for details.
</p>
</td></tr>
<tr><td><code id="chop_+3A_factors">factors</code></td>
<td>

<p>A character vector giving the names of the columns that are used to partition the data in <code>dat</code> into chunks that each contains the data for one chamber placement. <code>factors</code> <code class="reqn">\subset</code> <code>columns</code>! See example.
</p>
</td></tr>
<tr><td><code id="chop_+3A_nmes">nmes</code></td>
<td>

<p>A character vector giving the names of the columns that are used to name the data chunks. <code>nmes</code> <code class="reqn">\subset</code> <code>columns</code>! See example.
</p>
</td></tr>
<tr><td><code id="chop_+3A_min.cm">min.cm</code></td>
<td>

<p>Integer giving the minimum number of concentration measurements allowed per chamber measurement. Defaults to 3 because a linear fit to 2 points does not make any sense. Attention: Chamber placements with less than <code>min.cm</code> measurements are quietly skipped.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This could easily be hand scripted (e.g. with <code><a href="base.html#topic+split">split</a></code>) but the function shall provide a simple way to obtain the structure needed for <code><a href="#topic+flux">flux</a></code> and it also carries naming information.
</p>


<h3>Value</h3>

<p>Returns a list with 2 entries. The first is itself a list of <code><a href="base.html#topic+data.frame">data.frame</a></code>s containing the concentration measurements that result from the field sampling during one chamber placement (if <code>factors</code> was specified correctly) and the columns specified in <code>columns</code>. The entries in the list are named according to <code>nmes</code>. However, the second part of the upper level list is a table with the naming information. This is handed over to <code><a href="#topic+flux">flux</a></code> and <code><a href="#topic+plot.fluss">plot.fluss</a></code>. See example.
</p>


<h3>Author(s)</h3>

<p>Gerald Jurasinski &lt;gerald.jurasinski@uni-rostock.de&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+flux">flux</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## load example data
data(tt.pre)

## extract field concentration measurements
gcd &lt;- tt.pre[tt.pre$sampletype_a=="P",]

## partition the data into data tables per chamber measurement
gcd.parts &lt;- chop(gcd, factors = c("date", "spot", "veg"), 
nmes = c("date", "veg", "spot"))
# have a look at the first three tables
gcd.parts$tables[1:3]
# have a look at the names part of the returned object
gcd.parts$nmes
# use inspect to have a look at (a) specific data table(s)
inspect(gcd.parts, c("2011-03-15.c.3", "2011-03-15.c.6", "2011-03-15.p.6"))
# inspect the same tables using their indices
inspect(gcd.parts, c(3,6,12))
inspect(gcd.parts, c("c.3", "c.6", "p.6"))
</code></pre>

<hr>
<h2 id='export'>
simple export wrapper
</h2><span id='topic+export'></span>

<h3>Description</h3>

<p>Export your flux estimations easily
</p>


<h3>Usage</h3>

<pre><code class='language-R'>export(x, digits = 4, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="export_+3A_x">x</code></td>
<td>

<p>A fluxes object.
</p>
</td></tr>
<tr><td><code id="export_+3A_digits">digits</code></td>
<td>

<p>The number of digits that all numeric values in the output table shall have. Defaults to 4.
</p>
</td></tr>
<tr><td><code id="export_+3A_...">...</code></td>
<td>

<p>Further arguments to <code><a href="utils.html#topic+write.table">write.table</a></code>. For instance to specify another field separator (defaults to tab delimited output files) and a file where to write the results to.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It's really very simple.
</p>


<h3>Value</h3>

<p>The function is called for its side effects. Nothing is returned.
</p>


<h3>Author(s)</h3>

<p>Gerald Jurasinski &lt;gerald.jurasinski@uni-rostock.de&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+flux">flux</a></code>, <code><a href="#topic+chop">chop</a></code>, 
(also for examples)
</p>

<hr>
<h2 id='flux'>
Estimate gas flux rates using non-steady-state closed chamber data
</h2><span id='topic+flux'></span><span id='topic+flux.odae'></span><span id='topic+flux.conv'></span>

<h3>Description</h3>

<p><code>flux</code> is a convenience wrapper for the other two functions that should be suitable for most users. It can be used to estimate gas fluxes for all three commonly measured greenhouse gases (<code class="reqn">CO_2</code>, <code class="reqn">CH_4</code>, <code class="reqn">N_2O</code>) at once or separately.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>flux(x, var.par, co2ntrol = list(leak = TRUE, relay = FALSE), 
min.allowed = 3, max.nrmse = 0.1, nrmse.lim = 0.2, r2.qual = 0.8, 
range.lim = 30, out.unit = "auto", elementar = FALSE, 
hardflag = list(range = TRUE), asterisks = TRUE)

flux.odae(dat, var.par, min.allowed = 3, max.nrmse = 0.1, rl = NULL)

flux.conv(fl.dat, ghg = "CH4", r2.qual = 0.8, nrmse.lim = 0.2, 
out.unit = "auto", elementar = FALSE, hardflag = list(range = TRUE))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="flux_+3A_x">x</code></td>
<td>

<p>A list of data tables as returned by <code>chop</code>. Each table contains data for one chamber measurement. Required are at least the columns specified in the argument <code>var.par</code> (see also Example).
</p>
</td></tr>
<tr><td><code id="flux_+3A_var.par">var.par</code></td>
<td>

<p>A named list specifying the variables and parameters that are used in the estimation process and variables that should be handed through the function so that they are easily available for further analysis. Some of the names are obligatory (<code>time</code>, <code>volume</code>, <code>area</code>, <code>t.air</code>, <code>p.air</code>, and two or more that specify the gas column and the gas quality column), others are optional. See details and examples.
</p>
</td></tr>
<tr><td><code id="flux_+3A_ghg">ghg</code></td>
<td>

<p>Character string identifying the greenhouse gas for which concentration measurements are handled. Can be <code>"CH4"</code>, <code>"N2O"</code> or <code>"CO2"</code>. Defaults to <code>"CH4"</code>. This argument determines the molar weight that is used in the flux calculation with <code><a href="#topic+gflux">gflux</a></code>, the input unit (ppb or ppm), and the ambient concentration of the gas that is added to the diagnostic plots plotted with <code><a href="#topic+plot.fluss">plot.fluss</a></code> and used for the determination of the number of measurements below ambient (<code>nomba</code>).
</p>
</td></tr>
<tr><td><code id="flux_+3A_co2ntrol">co2ntrol</code></td>
<td>

<p>Options for estimating fluxes with <code class="reqn">CO_2</code> control. In this case outliers and the slope of the <code class="reqn">CO_2</code> concentration measurements influence the estimated flux rate of the other greenhouse gases (<code class="reqn">N_2O</code> and <code class="reqn">CH_4</code>; see Details). By default, <code class="reqn">CO_2</code> correction is switched off.
</p>
</td></tr>
<tr><td><code id="flux_+3A_min.allowed">min.allowed</code></td>
<td>

<p>Integer giving the minimum number of concentration measurements allowed during the estimation of one single flux. Can be any number between 3 and the number of concentration measurements during one chamber placement.
</p>
</td></tr>
<tr><td><code id="flux_+3A_max.nrmse">max.nrmse</code></td>
<td>

<p>Numeric giving the maximum acceptable normalized root mean square error for configurations with higher numbers of concentration measurements than specified in <code>min.allowed</code>. Numeric value between 0 and 1. Defaults to 0.1. Above that value lower numbers of concentration measurements down to <code>min.allowed</code> are considered. See details. In <code>flux</code> <code>max.nrmse</code> can also be given as a named list with three items giving the maximum acceptable nrmse per gas. See examples.
</p>
</td></tr>
<tr><td><code id="flux_+3A_nrmse.lim">nrmse.lim</code></td>
<td>

<p>Numeric between 0 and 1 (defaults to 0.2) giving the main quality parameter for the model fit, the maximum acceptable normalized root mean square error. If the best fit for one chamber measurement exceeds this value, the function reports <code>FALSE</code> in the <code>nrmse.f</code> quality flag. See details and value. In <code>flux</code> <code>nrmse.lim</code> can also be given as a named list with three items giving the <code>nrmse.lim</code> per gas. See examples.
</p>
</td></tr>
<tr><td><code id="flux_+3A_range.lim">range.lim</code></td>
<td>

<p>The minimum detectable range of the concentration measurements during one chamber placement. Has to be either a single numerical value, a numeric vector with the same length as <code>x</code> giving different range limits for each chamber placement (for instance obtained by <code><a href="#topic+flux.calib">flux.calib</a></code>) or a character string naming the column in <code>x</code> that contains range limit data. If this column is named &quot;rl&quot; (the default when the range limits are attached to the data by <code><a href="#topic+flux.calib">flux.calib</a></code>)  <code>flux</code> automatically detects it. Note, that setting <code>range.lim != NULL</code> overrides the auto detected range limits.
</p>
<p>The acceptable range limit depends on the accuracy of the concentration measurements. When the range of the concentration measurements is smaller than the repeatability range of the measurement device (e.g., a gas chromatograph) one cannot tell real increase in concentration from random fluctuation. Therefore, if the range of the concentration measurements during one chamber placement is &lt; <code>range.lim</code>, the range.flag is set to FALSE (0). See details. In <code>flux</code> <code>range.lim</code> can also be given as a named list with three items giving the maximum acceptable range limits per gas. See examples.
</p>
</td></tr>
<tr><td><code id="flux_+3A_r2.qual">r2.qual</code></td>
<td>

<p>Numeric giving the limit of minimum acceptable r2 as an alternative quality parameter describing the model fit. Can be between 0 and 1 (0.8 by default). If a model r2 is below the setting the r2 quality flag is reported FALSE (0). In <code>flux</code> <code>r2.qual</code> can also be given as a named list with three items giving the acceptable <code>r2.qual</code>ities per gas. See examples.
</p>
</td></tr>
<tr><td><code id="flux_+3A_out.unit">out.unit</code></td>
<td>

<p>Character string determining the output unit of the flux rate mass part. Character string. The default &quot;auto&quot; tries to find a unit that ranges the output value between 0.01 and 10. Possible output units are &quot;ng&quot;, &quot;mug&quot;, &quot;mg&quot;, or &quot;g&quot;. &quot;mug&quot; stands for &quot;<code class="reqn">\mu</code>g&quot; because non-ascii characters are not allowed in functions.
</p>
</td></tr>
<tr><td><code id="flux_+3A_elementar">elementar</code></td>
<td>

<p>When the fluxes are wanted as element values set <code>elementar = TRUE</code>. Defaults to FALSE.
</p>
</td></tr>  	
<tr><td><code id="flux_+3A_hardflag">hardflag</code></td>
<td>

<p>Named list that controls which of the quality flags are to be hard flagged (the value is changed according to the quality flag). <code>range.lim</code> is hard flagged by default. So when the range of the actual concentration values for a chamber measurement is smaller than the set range limit a zero flux is returned. When a flux estimation does not meet the quality requirements of any other hard-flagged quality parameter <code>flux</code> returns NA. For changing a quality parameter to a hard flag just provide its name (without quotation marks) and set it to TRUE. Possible parameters to chose as hard or soft flag are <code>nrmse</code>, <code>range</code>, and <code>r2</code>. Further the number of measurements below ambient (<code>nomba</code>) can be hardflagged by setting <code>nomba = [0…nc]</code> with <code>nc</code> = number of concentration measurements during one chamber placement. See examples.
</p>
</td></tr>
<tr><td><code id="flux_+3A_asterisks">asterisks</code></td>
<td>

<p>Logical. If <code>TRUE</code>, p-values are given as asterisks.
</p>
</td></tr>
<tr><td><code id="flux_+3A_dat">dat</code></td>
<td>

<p>One data table for one chamber placement. See <code>x</code> and <code>var.par</code> for details.
</p>
</td></tr>
<tr><td><code id="flux_+3A_rl">rl</code></td>
<td>

<p>Specifies <code>range.lim</code> in the low level function <code>flux.odae</code>. As with <code>range.lim</code> several options are allowed. Defaults to NULL. In this case, the function looks for a column <code>rl</code> in <code>dat</code>. If it can't find a column <code>rl</code>, the value is set to 0 and a warning is returned; if it does exist <code>dat$rl</code> is always taken. If <code>rl</code> is a character string the function looks for a column of that name in <code>dat</code>, if <code>rl</code> is a numeric value, this value is taken as the range limit. See examples.
</p>
</td></tr>
<tr><td><code id="flux_+3A_fl.dat">fl.dat</code></td>
<td>

<p>An object with the same structure as returned by <code><a href="#topic+flux.odae">flux.odae</a></code>. See details and value.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Typically it will be most convenient to use <code>flux</code> on objects returned by <code><a href="#topic+chop">chop</a></code> (i.e. on lists of data tables that contain all necessary data per chamber measurement including supporting information). <code>flux</code> simply wraps <code>flux.odae</code> and <code>flux.conv</code> applied on lists of chamber measurement data tables into one function. Thus, the data of a one day field campaign or a year of chamber measurements can easily be handled by simply running two functions (<code>chop</code> and <code>flux</code>) consecutively to estimate ghg fluxes for all three common ghg gases. See example.
</p>
<p>Probably the most important argument is <code>var.par</code>. It specifies the variables (by referring to the names of the data columns) from <code>x</code>  and  parameters (fixed values that are constant for all chamber placements) that are used for the flux estimations. For simple handling it is expecting a named list. 
</p>
<p>For <code>flux</code> the obligatory list items are: One item that refers to a column in <code>x</code> containing ghg concentrations (see next paragraph for details); <code>time</code> – chamber closing time in minutes; <code>volume</code> – chamber volume during placement (in cbm); <code>area</code> – chamber area (in sqm); <code>t.air</code> – air temperature inside chamber during concentration measurements (in °C); <code>p.air</code> – air pressure during concentration measurements (in Pa). 
</p>
<p>The list items that are used to specify the ghg for which flux estimation is carried out have to be specified by using the named list items <code>CH4</code> – <code class="reqn">CH_4</code> concentrations; <code>CH4.gcq</code> – <code class="reqn">CH_4</code> GC quality flag; <code>CO2</code> – <code class="reqn">CO_2</code> concentrations; <code>CO2.gcq</code> – <code class="reqn">CO_2</code> GC quality flag; <code>N2O</code> – <code class="reqn">N_2O</code> concentrations; <code>N2O.gcq</code> – <code class="reqn">N_2O</code> GC quality flag. Fluxes are estimated for all ghg for which concentration data are given. Thus, at least one ghg should be specified. GC quality flags are optional. If you don't provide a reference to a column in <code>x</code> the function assumes that all GC measurements were OK.
</p>
<p>All these list items can either be given as a variable (name of a column in <code>x</code>) or as a fixed parameter (a numeric value). This makes no sense for the <code>ghg</code>s and <code>time</code>, but in many cases chamber <code>volume</code> and <code>area</code> will be constant across measurements. Another likely candidate for a fixed parameter is <code>p.air</code> because air pressure is often not logged during chamber measurements. All additional list items should be of type ‘variable‘ and refer to further columns in <code>x</code> if you want those data handed through the function and be part of the result tables (for having all data in one place for further analyses). You are free to choose appropriate names. Fixed parameters will not be relayed.
</p>
<p>If the flux estimation is carried out in two steps it will typically be carried out on a list structure as returned by <code><a href="#topic+chop">chop</a></code>. Therefore, it is used within a <code><a href="base.html#topic+lapply">lapply</a></code> call. For details see examples. However, the functions <code>flux.odae</code> and <code>flux.conv</code> are  designed to be carried out on single data tables (<code><a href="base.html#topic+data.frame">data.frame</a></code>) per chamber measurement. 
</p>
<p>First <code>flux.odae</code> is run. It simply tries to find the best model fit for the series of concentration measurements that are given in <code>dat</code>. This <code><a href="base.html#topic+data.frame">data.frame</a></code> has to consist of five columns that give (in that order): gas concentration, closing time of the chamber in minutes, gas concentration quality flag, chamber volume, temperature within the chamber headspace during measurements (may change during chamber placement). See example data. 
</p>
<p>At the moment the optimization bases on linear regression. All possible models with n (= total number of concentration measurements per chamber placement) to <code>min.allowed</code> number of concentration measurements are fitted and the best fit is evaluated in a stepwise procedure. The normalized root mean square error is used as the quality criterion for the outlier detection and elimination procedure. All model fits with a nrmse &lt;= <code>max.nrmse</code> are extracted and ranked according to the number of concentration measurements (decreasing) and to the nrmse (increasing). The first ranked model is stored along with the original data table and some other information. Therefore a model with e.g. a nrmse of 0.081 constructed from 5 concentration measurements wins against a model with a nrmse of 0.07 with only 4 concentration measurements. This reflects the idea that models with nrmse &lt;= <code>max.nrmse</code> already represent a sufficient fit and do not have &quot;outliers&quot; that must be eliminated. 
</p>
<p>In case no model has a nrmse &lt;= <code>max.nrmse</code>, the models are simply ranked according to their nrmse and the model with the lowest nrmse wins and is stored. In that way outliers are detected and exluded. <code>flux.odae</code> returns a complex object that contains most of the necessary information for the <code>flux.conv</code> function and also carries information that is later needed for the plot functions (<code>plot.flux</code> and <code>plot.fluss</code>). 
</p>
<p>The flux calculation is then carried out with the function <code>flux.conv</code>. It takes the object returned by <code>flux.odae</code> and additional information (chamber area, gas species, several quality settings and in- as well as output units) and calculates the flux rates. Further several quality checks (r2 check, range check, nrmse check, nomba check; for details see Value) are carried out and quality flags are reported along with the fluxes in the output. It is best when all quality flags are returned <code>TRUE</code>. Depending on the application quality requirements might vary. Therefore, per default the function reports soft quality flags (despite for range). However, this can be changed via <code>hardflag</code>.
</p>
<p>The idea behind <code>co2ntrol</code> in <code><a href="#topic+flux">flux</a></code> is that the <code class="reqn">CO_2</code> concentration measurements might serve as a further check on the integrity of the chamber measuremnt in the field. When <code>co2ntrol</code> is set, the function first carries out an outlier procedure on the <code class="reqn">CO_2</code> concentration data (the respective columns have to be in <code>x</code> of course). Further, the slope of the <code class="reqn">CO_2</code> concentration change over time is checked. When it is negative, chamber leakage is assumed and a respective quality flag (<code>leak.flag</code>) is reported FALSE. The <code>leak.flag</code> cannot be hard flagged.
</p>


<h3>Value</h3>

<p><code>flux</code> returns a complex object of class <code>fluxes</code> that is a 3 entry list. When the object is printed to the console only the second entry is displayed in a modified form that is meant to maximize information display with small footprint for easy inspection. A table is printed to the console with three columns per gas. The first contains the quality flags (e.g. &quot;111.02&quot;). The order is: <code>nrmse.f</code>, <code>r2.f</code>, <code>range.f</code>, <code>nomba.f</code>, <code>leak.f</code>. The first three are considered more important, and if they are '1' everything is fine. The first flag behind the full stop just gives the number of measurements below ambient, while the second is '2' when <code>co2ntrol</code> was switched off, '0' when leaking occurred, and '1' when no leaking occurred.
</p>
<p>The <code><a href="base.html#topic+data.frame">data.frame</a></code> with the estimated flux rates contains all data needed for further analysis. The columns represent the entries in <code>fluss</code> of the single chamber measurements (including quality flags, see below) plus naming information according to the settings in the <code>nmes</code> argument of <code><a href="#topic+chop">chop</a></code>. <code><a href="#topic+export">export</a></code> provides a simple way to export the results. The first entry is itself a list of lists and data tables. It is called <code>flux.res</code> and is comprised of objects that are returned by <code>flux.conv</code> per ghg. Each first level entry in these lists contains the information for one chamber measurement. It is named according to the <code>nmes</code>-setting in <code><a href="#topic+chop">chop</a></code> and contains the elements <code>fluss</code> (which is itself a list with the elements given below), <code>fl.dat</code> (equals the object returned by <code>flux.odae</code>; see below), and <code>unit</code> which provides information on the output mass unit of the flux rate that is handed over to the function <code><a href="#topic+plot.fluss">plot.fluss</a></code> and to the table output.
</p>
<p>The elements of <code>fluss</code>:
</p>
<table>
<tr><td><code>ghg</code></td>
<td>
<p>Character. The gas species for which the flux has been estimated.</p>
</td></tr>
<tr><td><code>flux</code></td>
<td>
<p>Numeric. Calculated flux rate in mass unit per m2 and hour.</p>
</td></tr>
<tr><td><code>r2</code></td>
<td>
<p>The <code class="reqn">R^2</code> of the best fitted model that has been used for flux caclulation.</p>
</td></tr>
<tr><td><code>nrmse</code></td>
<td>
<p>The NRMSE of the best fitted model that has been used for flux caclulation.</p>
</td></tr>
<tr><td><code>r2.f</code></td>
<td>
<p>Logical. <code class="reqn">R^2</code> quality flag telling whether the <code class="reqn">R^2</code> quality setting given in <code>r2.qual</code> is fulfilled.</p>
</td></tr>
<tr><td><code>range.f</code></td>
<td>
<p>Logical. Range quality flag telling whether the range of the concentration measurements exceeded the quality range of the measurement device that has been specified in <code>range.lim</code>.</p>
</td></tr>
<tr><td><code>nrmse.f</code></td>
<td>
<p>Logical. NRMSE quality flag telling whether the NRMSE quality setting given in <code>nrmse.lim</code> is fulfilled (i.e. if the NRMSE of the best model &lt;= <code>nrmse.lim</code>).</p>
</td></tr>
<tr><td><code>nomba.f</code></td>
<td>
<p>Integer. Reports the <strong>n</strong>umber <strong>o</strong>f <strong>m</strong>easurements <strong>b</strong>elow <strong>a</strong>mbient. The ambient concentrations are set to be 392.6 ppm (<code class="reqn">CO_2</code>), 1874 ppb (<code class="reqn">CH_4</code>),  and 324 ppb (<code class="reqn">N_2O</code>) (taken from Mace Head Ireland (<code class="reqn">N_2O</code>, <code class="reqn">CH_4</code>) and global average (<code class="reqn">CO_2</code>) obtained from http://cdiac.ornl.gov/pns/current_ghg.html as of August 16th, 2013).</p>
</td></tr>
<tr><td><code>leak.f</code></td>
<td>
<p>Logical. When <code>co2ntrol</code> was applied with <code>leak = TRUE</code>, possible chamber leakage as represented by decreasing <code class="reqn">CO_2</code> concentrations over time is shown by a <code>FALSE (0)</code>.</p>
</td></tr>
</table>
<p>The elements of <code>fl.dat</code> that is also the object returned by <code>flux.odae</code> are:
</p>
<table>
<tr><td><code>lm4flux</code></td>
<td>
<p>Complex object. The best fitting model as reported by <code><a href="stats.html#topic+lm">lm</a></code>. It builds the basis for the calculation of the flux rate via <code>flux.conv</code>.</p>
</td></tr>
<tr><td><code>row.select</code></td>
<td>
<p>Integer vector giving the indices of the rows of the data table that have been used to construct the best fitting model. This information is later used in the plotting functions <code><a href="#topic+plot.flux">plot.flux</a></code> and <code><a href="#topic+plot.fluss">plot.fluss</a></code>. </p>
</td></tr>
<tr><td><code>orig.dat</code></td>
<td>
<p><code><a href="base.html#topic+data.frame">data.frame</a></code> with the original data provided according to arguments <code>x</code> and <code>columns</code>. </p>
</td></tr>
<tr><td><code>out.dat</code></td>
<td>
<p>Data to be handed through. Per default <code>area</code> and <code>volume</code> of the chamber are relayed but these values are not part of the table output whereas all additionally relayed data are part of the table output. </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p> Gerald Jurasinski &lt;gerald.jurasinski@uni-rostock.de&gt;, Franziska Koebsch &lt;franziska.koebsch@uni-rostock.de&gt;, Ulrike Hagemann &lt;ulrike.hagemann@zalf.de&gt;, Anke Günther &lt;anke.guenther@uni-rostock.de&gt;
</p>


<h3>References</h3>

<p>Nakano T (2004) A comparison of regression methods for estimating 
soil-atmosphere diffusion gas fluxes by a closed-chamber technique. 
Soil Biology and Biochemistry 36: 107-113.
</p>
<p>Forbrich I, Kutzbach L, Hormann A, Wilmking M (2010) A comparison of 
linear and exponential regression for estimating diffusive CH4 fluxes by 
closed-chambers in peatlands. Soil Biology and Biochemistry 42: 507-515.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+chop">chop</a></code>, <code><a href="#topic+flux.calib">flux.calib</a></code>, <code><a href="#topic+gflux">gflux</a></code>, <code><a href="#topic+plot.fluss">plot.fluss</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## load example data
data(tt.pre)

## extract field concentration measurements
gcd &lt;- tt.pre[tt.pre$sampletype_a=="P",]

## partition the data into data tables per chamber measurement
# then do the partitioning
gcd.parts &lt;- chop(gcd, factors = c("date", "spot", "veg"), 
nmes = c("date", "veg", "spot"))

## calculate flux rates for methane
# first define a global CH4 range limit
CH4.lim &lt;- 30
# do the flux rate estimation (it will often be best to define
# var.par separately, note that p.air is given as a parameter)
vp.CH4 &lt;- list(CH4 = "CH4ppb", time = "time_min", CH4.gcq = "CH4Code", 
volume = "cham_vol", t.air = "temp_dC", area = "cham_area", p.air = 101325)
flux.CH4 &lt;- flux(gcd.parts, var.par = vp.CH4)
# look at the results table
flux.CH4

# extracting range limits from the calibration gas measurements
# and attaching them to gcd.parts. first get the calibration gas
# measurements from tt.pre (changing the date because it is in 
# a strange format and has to be the same as the dates in gcd.parts)
cgm &lt;- tt.pre[tt.pre$sampletype_a=="E",c("date_gc", "CH4ppb", "CH4Code", 
"CO2ppm", "CO2Code", "N2Oppb", "N2OCode")]
names(cgm)[1] &lt;- "date"
cgm$date &lt;- "2011-03-16"
# now we can do the flux.calib
gcd.parts.cal &lt;- flux.calib(gcd.parts, columns = c("date", "CH4ppb"), 
calib = cgm, format="%Y-%m-%d", window=48, buffer=1100, attach=TRUE)
# do the flux rate estimation (we use the same var.par as before)
flux.CH4 &lt;- flux(gcd.parts.cal, var.par=vp.CH4, co2ntrol = NULL, 
range.lim=NULL)
# look at the results table
flux.CH4
# export the results to the working directory
wd &lt;- getwd()
export(flux.CH4, file=paste(wd, "/flux.CH4.txt", sep=""))

## plot the concentration-change-with-time-plots as kind of diagnostic
plot(flux.CH4, dims = c(3,6))

## do the flux rate estimation whilst using CO2 concentrations to
## control for possible chamber leakage
flux.CH4.b &lt;- flux(gcd.parts, var.par=vp.CH4)
# look at the results table
flux.CH4.b
# plot the concentration-change-with-time-plots as kind of diagnostic
plot(flux.CH4.b, dims = c(3,6))

## do the flux rate estimation whilst using CO2 concentrations to
## control for outliers and possible chamber leakage
flux.CH4.c &lt;- flux(gcd.parts, var.par=vp.CH4, co2ntrol = list(leak = TRUE, 
relay = FALSE))
# look at the results table
flux.CH4.c
# plot the concentration-change-with-time-plots as kind of diagnostic
plot(flux.CH4.c, dims = c(3,6))

</code></pre>

<hr>
<h2 id='flux-internal'> Internal functions of the package flux that are usually not called (or only implicitly) by the user </h2><span id='topic+print.fluss'></span><span id='topic+print.fluxes'></span><span id='topic+print.fluxxes'></span>

<h3>Description</h3>

<p>Mainly print functions for giving nice output.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fluss'
print(x, digits = max(3, getOption("digits") - 3), ...)
## S3 method for class 'fluxes'
print(x, digits = max(3, getOption("digits") - 3), ...)
## S3 method for class 'fluxxes'
print(x, digits = max(3, getOption("digits") - 3), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="flux-internal_+3A_x">x</code></td>
<td>
<p> object to be printed </p>
</td></tr>
<tr><td><code id="flux-internal_+3A_digits">digits</code></td>
<td>
<p> number of digits </p>
</td></tr>
<tr><td><code id="flux-internal_+3A_...">...</code></td>
<td>
<p> Further arguments. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>These are just printing methods to give nice output. Usually they are not to be called by the user.
</p>


<h3>Value</h3>

<p>prints the output of a function and invisibly gives back the original object
</p>


<h3>Author(s)</h3>

<p> Gerald Jurasinski </p>

<hr>
<h2 id='flux-package'>
Flux rate estimation with dynamic closed chamber data
</h2><span id='topic+flux-package'></span>

<h3>Description</h3>

<p>Several functions for the estimation of greenhouse gas (GHG) flux rates using closed chamber concentration measurements. The package follows a modular concept: Fluxes can be calculated in just two simple steps or in several steps if more control is wanted. Functions for further analyses (GPP and Reco model fitting and prediction for budgets including error terms) are also available.
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> flux</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 0.3-0</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2014-04-23</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL-2</td>
</tr>
<tr>
 <td style="text-align: left;">
LazyLoad: </td><td style="text-align: left;"> yes</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>Obtain flux rates from many chamber measurements within minutes. After 
preparing the read in data (Field or device measured concentration data on 
the three most prominent greenhouse gases) with <code><a href="#topic+chop">chop</a></code> just 
run <code><a href="#topic+flux">flux</a></code> or <code><a href="#topic+fluxx">fluxx</a></code> (for medium frequency data)
on the result returned by <code><a href="#topic+chop">chop</a></code> and get flux rates in an 
easy to interpret table including quality flags. 
Plot diagnostic plots as pdf per factor level to a folder or simply to 
the screen. Use <code><a href="#topic+gpp">gpp</a></code> to model GPP and <code><a href="#topic+reco">reco</a></code> to 
model ecosystem respiration or use <code><a href="#topic+gpp.bulk">gpp.bulk</a></code> to bulk model
GPP and <code><a href="#topic+reco.bulk">reco.bulk</a></code> to bulk model <code class="reqn">R_{eco}</code> and 
use the resulting objects with <code><a href="#topic+budget.gpp">budget.gpp</a></code> and 
<code><a href="#topic+budget.reco">budget.reco</a></code>, respectively, to predict fluxes using 
continuously logged data. Use <code><a href="#topic+budget.ie">budget.ie</a></code> to estimate the 
uncertainty associated with the interpolation between models. 
Several helper functions for ghg analysis are also provided.
</p>


<h3>Author(s)</h3>

<p>Gerald Jurasinski &lt;gerald.jurasinski@uni-rostock.de&gt;, Franziska Koebsch &lt;franziska.koebsch@uni-rostock.de&gt;, Ulrike Hagemann &lt;ulrike.hagemann@zalf.de&gt;, Anke Günther &lt;anke.guenther@uni-rostock.de&gt;
</p>
<p>Maintainer: Gerald Jurasinski &lt;gerald.jurasinski@uni-rostock.de&gt;
</p>


<h3>References</h3>

<p>Nakano T (2004) A comparison of regression methods for estimating soil-
atmosphere diffusion gas fluxes by a closed-chamber technique. Soil Biology 
and Biochemistry 36: 107-113.
</p>
<p>Forbrich I, Kutzbach L, Hormann A, Wilmking M (2010) A comparison of linear 
and exponential regression for estimating diffusive CH4 fluxes by closed-
chambers in peatlands. Soil Biology and Biochemistry 42: 507-515.
</p>
<p>Beetz S, Liebersbach H, Glatzel S, Jurasinski G, Buczko U, Hoper H (2013) Effects of land use intensity on the full greenhouse gas balance in an Atlantic peat bog. Biogeosciences 10:1067-1082.
</p>
<p>Koebsch F, Glatzel S, Jurasinski G (2013) Vegetation controls methane emissions in a coastal brackish fen. Wetlands Ecology and Management 21:323–337.
</p>


<h3>See Also</h3>

<p><code><a href="HMR.html#topic+HMR">HMR</a></code> for a different approach to flux rate estimation from chamber data.
</p>

<hr>
<h2 id='flux.calib'>
Determine calibration measurement ranges according to the dates of real measurements
</h2><span id='topic+flux.calib'></span>

<h3>Description</h3>

<p>The function basically takes calibration gas measurements and extracts the calibration gas measurements that have been carried out temporally close to a real data measurement and calculates the standard deviation of the calibration gas measurements. The obtained range limits can be used in <code><a href="#topic+flux">flux</a></code> as a quality parameter (via <code>range.lim</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>flux.calib(dat, columns, calib, format = "%Y-%m-%d %H:%M:%S", 
window = 3, buffer = 1000, n.cg = 4, rl.backup = 20, attach = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="flux.calib_+3A_dat">dat</code></td>
<td>

<p>Object returned by <code><a href="#topic+chop">chop</a></code> containing gas concentration measurements for several chamber measurements.
</p>
</td></tr>
<tr><td><code id="flux.calib_+3A_columns">columns</code></td>
<td>

<p>Character vector giving the names of the two columns that shall be taken from <code>dat</code> and from <code>calib</code> for extracting the calibration measurements. Typically one date and one concentration column. This also implies that they carry the same names in <code>dat</code> and <code>calib</code>. 
</p>
</td></tr>
<tr><td><code id="flux.calib_+3A_calib">calib</code></td>
<td>

<p><code><a href="base.html#topic+data.frame">data.frame</a></code> with concentration measurements of calibration gases that have been carried out at least in part during the time the concentration measurements in <code>dat</code> have been achieved.
</p>
</td></tr>
<tr><td><code id="flux.calib_+3A_format">format</code></td>
<td>

<p>Character string specifying the format of dates in <code>dat</code> as well as in <code>calib</code>. Internally dates are converted to a date format R can handle (see <code><a href="base.html#topic+strptime">strptime</a></code> for details and format options).
</p>
</td></tr>
<tr><td><code id="flux.calib_+3A_window">window</code></td>
<td>

<p>Integer value. Hours. Window around the date and time (if available) of measurement of the field greenhouse gas concentrations at the measurement device (e.g. a GC) that shall be considered for the inclusion of calibration gas measurements. If no times are given <code>window</code>s = 48 includes the day after the measurement date and <code>window</code>s &gt;48 include the day before and the day after the measurement date.
</p>
</td></tr>
<tr><td><code id="flux.calib_+3A_buffer">buffer</code></td>
<td>

<p>Numeric. Concentration buffer around the range of concentration measurements in <code>dat</code> in which the function searches for calibration gas measurements. Defaults to 1000 (ppm or ppb, depends on gas). When only the closest calibration gas concentration shall be considered one can decrease the buffer. When real concentrations are far different from available calibration gas concentrations one might need to increase the buffer to have enough data.
</p>
</td></tr>
<tr><td><code id="flux.calib_+3A_n.cg">n.cg</code></td>
<td>

<p>Integer. Number of calibration gas concentrations in <code>calib</code>.
</p>
</td></tr>
<tr><td><code id="flux.calib_+3A_rl.backup">rl.backup</code></td>
<td>

<p>Numeric value. Range limit backup value that is used in situations where no range limit can be derived from the calibration measurements. See details. Defaults to a quite reasonable 20. Deprecated.
</p>
</td></tr>
<tr><td><code id="flux.calib_+3A_attach">attach</code></td>
<td>

<p>Logical. If TRUE the range limits are attached to the original data.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function automatically detects the single species of calibration gases that have been measured. It calculates the standard deviations of the measurements per calibration gas species and than gives back an average of the calculated range limit values if there are more than one calibration gas concentrations covered by the range within the field concentration measurements per chamber placement. However, this is rather academic because a chamber measurement for which concentrations develop over the range of two or more calibration concentrations will typically not have a range limit problem.
</p>
<p>In its actual form it is possible that there are no valid calibration measurements found for certain chamber data because the range of the chamber data (even with range extension) does not cover any of the calibration gas concentrations. In this case, the minimum range limit is assigned if <code>rl.backup</code> = NULL.
</p>


<h3>Value</h3>

<p>Returns a named vector with the range limits of the measurement device (as needed within <code><a href="#topic+flux">flux</a></code>) per chamber measurement or attaches the range limits to the original data tables that are in <code>x</code> and returns the altered <code>x</code>.
</p>


<h3>Author(s)</h3>

<p>Gerald Jurasinski &lt;gerald.jurasinski@uni-rostock.de&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+chop">chop</a></code>, <code><a href="#topic+flux">flux</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## load example data
data(tt.pre)

## extract field concentration measurements
gcd &lt;- tt.pre[tt.pre$sampletype_a=="P",]

## partition the data into data tables per chamber measurement
gcd.parts &lt;- chop(gcd, factors = c("date", "spot", "veg"), 
nmes = c("date", "veg", "spot"))

## calculate range limits according to the data and the accompanying 
## calibration gas measurements
# extract and prepare calibration measurements
cal &lt;- tt.pre[tt.pre$sampletype_a=="E",c("date_gc", "CH4ppb", "CH4Code", 
"CO2ppm", "CO2Code", "N2Oppb", "N2OCode")]
names(cal)[1] &lt;- "date"
cal$date &lt;- "2011-03-16"
# calculate the range limits per gas (makes no real sense with such
# a small dataset).
# CH4 range limits 
CH4.lims &lt;- flux.calib(gcd.parts, columns = c("date", "CH4ppb"), 
calib = cal, format="%Y-%m-%d", window=48, attach=FALSE, buffer=1100)
# N2O range limits 
N2O.lims &lt;- flux.calib(gcd.parts, columns = c("date", "N2Oppb"), 
calib = cal, format="%Y-%m-%d", window=48, attach=FALSE, buffer=1100)
# CO2 range limits 
CO2.lims &lt;- flux.calib(gcd.parts, columns = c("date", "CO2ppm"), 
calib = cal, format="%Y-%m-%d", window=48, attach=FALSE, buffer=1100)

## attach the range limits to the original data
gcd.parts.cal &lt;- flux.calib(gcd.parts, columns = c("date", "CH4ppb"), 
calib = cal, format = "%Y-%m-%d", attach = TRUE, window=48, buffer=1100)

</code></pre>

<hr>
<h2 id='fluxx'>
Estimate (ghg) flux rates from online dynamic closed chamber measurements in through-flow mode.
</h2><span id='topic+fluxx'></span><span id='topic+mf.flux'></span>

<h3>Description</h3>

<p>(Bulk) estimates of (ghg) fluxes from online concentration measurements with non-steady-state closed chambers. The function tries to find stable linear conditions in concentration change by fitting many regressions to the data and automatically detects and excludes rapid concentration fluctations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fluxx(x, var.par, subset, asterisks = FALSE, loop = "auto", ...)

mf.flux(x, var.par, method = "r2", time.unit = "S", all.through = TRUE, iv = 1, 
wndw = 0.1, pdk = 0.5, min.dp = 20, nrmse.lim = 0.1, r2.qual = 0.9, 
range.lim = 5, out.unit = "auto", elementar = FALSE, 
hardflag = list(range = TRUE), consecutive = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fluxx_+3A_x">x</code></td>
<td>

<p>A list of data tables as returned by <code>chop</code> or alternatively one data table (for <code>mf.flux</code> which will rarely be called directly by the user). Each table contains data for one chamber measurement. Minimum requirements are the columns specified in <code>var.par</code>.
</p>
</td></tr>
<tr><td><code id="fluxx_+3A_var.par">var.par</code></td>
<td>

<p>A named list specifying the variables and parameters that are used in the estimation process and variables that should be handed through the function so that they are easily available for further analysis. Some of the names are obligatory (e.g. <code>time</code>, <code>volume</code>, <code>area</code>, <code>t.air</code>, <code>p.air</code>, and two or more that specify the gas column and the gas quality column), others are optional. See details and examples.
</p>
</td></tr>
<tr><td><code id="fluxx_+3A_subset">subset</code></td>
<td>

<p>An optional vector specifying a subset of concentration measurements to be used in the estimation process.
</p>
</td></tr>
<tr><td><code id="fluxx_+3A_asterisks">asterisks</code></td>
<td>

<p>Logical. If TRUE p-values are given as asterisks and other symbols (p&lt;.001 = &quot;***&quot;, .001&lt;p&lt;.01 = &quot;**&quot;, .01&lt;p&lt;.05 = &quot;*&quot;, .05&lt;p&lt;.1 = &quot;.&quot;, p&gt;=.1 == &quot; &quot;).
</p>
</td></tr>
<tr><td><code id="fluxx_+3A_loop">loop</code></td>
<td>

<p>Can be <code>TRUE</code>, <code>FALSE</code> or &quot;auto&quot;. Determines how bulk flux estimations are done. If <code>TRUE</code> a <code>for</code>-loop is used, if <code>FALSE</code> <code>lapply</code> is used, and if &quot;auto&quot; the approach is switched automatically depending on the number of data tables: If <code>x</code> contains more than 100 data tables (chamber placements) the approach is switched from <code>lapply</code> to <code>for</code>-loop because <code>lapply</code> may be slow on large <code>x</code>.
</p>
</td></tr>
<tr><td><code id="fluxx_+3A_...">...</code></td>
<td>

<p>Further arguments passed to <code>mf.flux</code>.
</p>
</td></tr>
<tr><td><code id="fluxx_+3A_method">method</code></td>
<td>

<p>Character string specifying the statistic used for finding the linear part. Partial match to <code>"r2"</code>, <code>"rmse"</code>, <code>"AIC"</code>. Defaults to <code>"r2"</code>. See Details.
</p>
</td></tr>
<tr><td><code id="fluxx_+3A_time.unit">time.unit</code></td>
<td>

<p>Single character giving the appropriate unit of time elapsed between two concentration measurements. Will typically be seconds, thus default is <code>"S"</code>. Other options are <code>"M"</code> for minutes and <code>"H"</code> for hours. ATTENTION: Setting the time unit to the wrong value will result in incorrect fluxes.
</p>
</td></tr>
<tr><td><code id="fluxx_+3A_all.through">all.through</code></td>
<td>

<p>Logical. When <code>TRUE</code>, all data columns in <code>x</code> other than the ones needed for flux calculation are also handed through the function so that they can be used in later steps of analysis. You may also specify one or several columns that are handed through using <code>var.par</code>. The <code>all.through</code> setting overruns the <code>var.par</code> settings.
</p>
</td></tr>
<tr><td><code id="fluxx_+3A_iv">iv</code></td>
<td>

<p>Numeric. Sometimes there is no time information at all but the rows in <code>x</code> are just numbered consecutively. The correct temporal spread is calculated inside the function when the measurement interval is specified here. Defaults to 1 which expects times to be correctly given in <code>x</code>.
</p>
</td></tr>
<tr><td><code id="fluxx_+3A_wndw">wndw</code></td>
<td>

<p>Numeric between 0 and 1. Relative width of a moving window in which the standard deviation of the concentrations is calculated to identify high frequency fluctuations. See details and next.
</p>
</td></tr>
<tr><td><code id="fluxx_+3A_pdk">pdk</code></td>
<td>

<p>Numeric between 0 and 1. Minimum proportion of data points to be kept. See details. In case one single concentration value occurs more than <code>pdk * n</code> times in the data (may happen under zero to very low flux conditions), all other data is assumed to represent high frequency fluctuations and flux is set to zero.
</p>
</td></tr>
<tr><td><code id="fluxx_+3A_min.dp">min.dp</code></td>
<td>

<p>Numeric. The minimum number of data points. Defaults to 20. If there are less rows the estimation is run anyway but a warning is issued and <code>min.dp</code> is automatically adjustet to n-1.
</p>
</td></tr>
<tr><td><code id="fluxx_+3A_nrmse.lim">nrmse.lim</code></td>
<td>

<p>The maximum acceptable normalized root mean square error. Numeric value between 0 and 1. Defaults to 0.1. If the final best solution has a higher nrmse it is flagged accordingly.
</p>
</td></tr>
<tr><td><code id="fluxx_+3A_r2.qual">r2.qual</code></td>
<td>

<p>Numeric between 0 and 1. Quality parameter for the model fit. The minimum acceptable <code class="reqn">R^2</code> of the best fitted model. Defaults to 0.8. When the value is below quality setting a quality flag is reported.
</p>
</td></tr>
<tr><td><code id="fluxx_+3A_range.lim">range.lim</code></td>
<td>

<p>Numeric. The minimum range of the concentration measurements during one chamber placement. The acceptable range limit depends on the accuracy of the concentration measurements. When the range of the concentration measurements is smaller than the repeatability range of the measurement device one cannot tell real increase in concentration from random fluctuation. Therefore, if the range of the concentration measurements during one chamber placement is &lt; <code>range.lim</code>, the range.flag is set to FALSE (0). See details.
</p>
</td></tr>
<tr><td><code id="fluxx_+3A_out.unit">out.unit</code></td>
<td>

<p>Character string determining the output unit of the flux rate mass part. The default &quot;auto&quot; tries to find a unit that ranges the output value between 0.01 and 10. Possible output units are &quot;ng&quot;, &quot;mug&quot;, &quot;mg&quot;, or &quot;g&quot;. &quot;mug&quot; stands for &quot;<code class="reqn">\mu</code>g&quot; because non-ascii characters are not allowed in functions. Beware of varying mass units in your output when running in auto mode.
</p>
</td></tr>
<tr><td><code id="fluxx_+3A_elementar">elementar</code></td>
<td>

<p>When the fluxes are wanted as element values set <code>elementar = TRUE</code>. Defaults to FALSE.
</p>
</td></tr>
<tr><td><code id="fluxx_+3A_hardflag">hardflag</code></td>
<td>

<p>Named list that controls which of the quality flags are to be hard flagged (the value is changed according to the quality flag). Only <code>range.lim</code> is hard flagged by default. So when the range of concentration values for a chamber measurement is smaller than the set range limit a zero flux is returned. When a flux estimation does not meet the quality requirements of any other hard-flagged quality parameter fluxx returns NA. For changing a quality flag to a hard flag just provide its name (without quotation marks) and set it to TRUE. Possible parameters to choose as hard or soft flag are <code>nrmse</code>, <code>range</code>, and <code>r2</code>. Further the number of measurements below ambient (<code>nomba</code>) can be hardflagged by setting <code>nomba = [0…nc]</code> with <code>nc</code> = number of concentration measurements for one chamber placement.
</p>
</td></tr>
<tr><td><code id="fluxx_+3A_consecutive">consecutive</code></td>
<td>

<p>Shall the most linear part be found by a consecutive approach starting at the first concentration reading. As soon as a stable flux is detected, it is stored. Strictly experimental.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function is similar to <code><a href="#topic+flux">flux</a></code> but uses a different algorithm to identify the most linear part of the concentration development. First high frequency fluctations are omitted. Then all possible <code>pdk</code> * n : n consecutive concentration measurements are regressed against the corresponding times. The model with the highest r2 is chosen.
</p>
<p><code>var.par</code> specifies the variables within <code>x</code>  and  fixed parameters for all chamber placements that are used for the flux estimations. For obligatory <code>var.par</code> items see <code><a href="#topic+flux">flux</a></code> and examples. In contrast to <code><a href="#topic+flux">flux</a></code> there is just one workhorse function doing the actual estimation (<code>mf.flux</code>) per data table. Especially when there are many data tables in <code>x</code> and/or many data points per data table it takes some time. Progress is shown in the console. Each dot represents one finalized data table.
</p>


<h3>Value</h3>

<p><code>fluxx</code> returns a complex object of class <code>fluxxes</code> that is a 2 entry list. When the object is printed to the console only the second entry is displayed in a modified form that is meant to maximize information display with small footprint for easy inspection. A table is printed to the console with three columns per gas. The first contains the quality flags (e.g. 111.9). The order is: <code>r2.f</code>, <code>range.f</code>,<code>nrmse.f</code>, <code>nomba.f</code>. The first three are considered more important, and if they are '1' everything is fine. The last number digit following the full stop gives the number of concentration readings below ambient.
</p>
<p>The <code><a href="base.html#topic+data.frame">data.frame</a></code> with the estimated flux rates contains all data needed for further analysis. The columns represent the entries in <code>fluss</code> of the single chamber measurements (including quality flags, see below) plus naming information according to the settings in the <code>nmes</code> argument of <code><a href="#topic+chop">chop</a></code>. <code><a href="#topic+export">export</a></code> provides a simple way to export the results.
</p>
<p>The first entry is itself a list of lists and data tables. It is called <code>flux.res</code>. The only one first level entry in this list contains the information for one gas which is itself a list. In this list each first level entry contains the information for one chamber measurement. It is named according to the <code>nmes</code>-setting in <code><a href="#topic+chop">chop</a></code> and contains the elements <code>fluss</code> (which is itself a list with the elements given below), <code>mod</code>, <code>out</code> (a list with hand through data, list items according to columns in <code>x</code> that have been handed trough via <code>all.through</code> or <code>var.par</code>), and <code>inn</code> - a data.frame with the input data that were relevant for estimating the flux (the obligatory part of <code>var.par</code>).
</p>
<p>The elements of <code>fluss</code>:
</p>
<table>
<tr><td><code>ghg</code></td>
<td>
<p>Character. The gas species for which the flux has been estimated.</p>
</td></tr>
<tr><td><code>flux</code></td>
<td>
<p>Numeric. Calculated flux rate in mass unit per m2 and hour.</p>
</td></tr>
<tr><td><code>r2</code></td>
<td>
<p>r2 of the best fitted model that has been used for flux caclulation.</p>
</td></tr>
<tr><td><code>nrmse</code></td>
<td>
<p>nrmse of the best fitted model that has been used for flux calculation.</p>
</td></tr>
<tr><td><code>r2.f</code></td>
<td>
<p>Logical. r2 quality flag telling whether the r2 quality setting given in <code>r2.qual</code> is fulfilled.</p>
</td></tr>
<tr><td><code>range.f</code></td>
<td>
<p>Logical. Range quality flag telling whether the range of the concentration measurements exceeded the quality range of the measurement device that has been specified in <code>range.lim</code>.</p>
</td></tr>
<tr><td><code>nrmse.f</code></td>
<td>
<p>Logical. nrmse quality flag telling whether the nrmse quality setting given in <code>nrmse.lim</code> is fulfilled (i.e. if the nrmse of the best model &lt;= <code>nrmse.lim</code>).</p>
</td></tr>
<tr><td><code>nomba.f</code></td>
<td>
<p>Integer. Reports the <strong>n</strong>umber <strong>o</strong>f <strong>m</strong>easurements <strong>b</strong>elow <strong>a</strong>mbient. When one observes concentrations below ambient that might make the measurements unstable, it is possible to filter the results later and allow only a maximum acceptable number of measurements below ambient. The ambient concentration is build into the function with data from Mace Head Ireland (N2O, CH4) and global average (CO2) obtained from http://cdiac.ornl.gov/pns/current_ghg.html as of August 1st, 2011.</p>
</td></tr>
<tr><td><code>unit</code></td>
<td>
<p> The mass unit assigned. </p>
</td></tr>
<tr><td><code>podpu</code></td>
<td>
<p> Proportion (expressed as a number between 0 and 1) of data points used for constructing the linear model for estimating the flux rate. The higher the less disturbed the measurements. </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Gerald Jurasinski, <a href="mailto:gerald.jurasinski@uni-rostock.de">gerald.jurasinski@uni-rostock.de</a>
</p>


<h3>References</h3>

<p>Nakano T (2004) A comparison of regression methods for estimating 
soil-atmosphere diffusion gas fluxes by a closed-chamber technique. 
Soil Biology and Biochemistry 36: 107-113.
</p>
<p>Forbrich I, Kutzbach L, Hormann A, Wilmking M (2010) A comparison of 
linear and exponential regression for estimating diffusive CH4 fluxes by 
closed-chambers in peatlands. Soil Biology and Biochemistry 42: 507-515.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gpp">gpp</a></code> and <code><a href="#topic+reco">reco</a></code> for further processing of the results.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## load data
data(tt.nee)

## prepare flux estimation
# make parts with chop
tt.parts &lt;- chop(tt.nee, factors=c("session", "spot"), 
nmes=c("spot", "date", "session"), min.cm=40)
# prepare var.par list (like with flux)
vp &lt;- list(CO2 = "NEE", time = "datetime", area = "area", 
volume = "volume", t.air = "t.cham", p.air = 101325)

## do the flux estimation
# run fluxx. with lots of data it may take a while 
# (approx. 10 sec per chamber)
tt.flux &lt;- fluxx(tt.parts, subset=c(1:30), vp, pdk=0.5, 
range.lim=3, out.unit="mg")
# inspect results table
tt.flux
# plot diagnostic plots
plot(tt.flux, dims=c(4,4), subs="spot")
# run fluxx with alternative method
tt.fluxa &lt;- fluxx(tt.parts, subset=c(1:30), vp, pdk=0.5, 
range.lim=3, out.unit="mg", method="rmse")
# inspect results
tt.fluxa

## End(Not run)
</code></pre>

<hr>
<h2 id='gflux'>
Calculate gas flux rate from two concentrations
</h2><span id='topic+gflux'></span>

<h3>Description</h3>

<p>Calculate gas flux rate from two concentrations using the ideal gas law to obtain a mass flow from an area per time. Therefore, besides the two concentrations ct and c0 the temperature within and the volume of the closed chamber are needed. For areal reference the area from which the gases are emitted has to be given. Without any further unit transformation the input unit directly gives the output unit: When concentration is coming in ppm the calculated flux rate is in <code class="reqn">\mu</code>g/m2*h, when concentration is in ppb the flux rate will be in ng/m2*h
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gflux(ct, c0 = NULL, T, V, A = 1, M = 44, t = 1/60, p = 101325)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gflux_+3A_ct">ct</code></td>
<td>

<p>Concentration of the gas at time t. When the function is used internally the concentration is automatically derived from a regression model. May also be the concentration change in time dc/dt. In this case <code>c0</code> must not be specified.
</p>
</td></tr>
<tr><td><code id="gflux_+3A_c0">c0</code></td>
<td>

<p>Concentration of the gas at time 0. When the function is used internally the concentration is automatically derived from a regression model.
</p>
</td></tr>
<tr><td><code id="gflux_+3A_t">T</code></td>
<td>

<p>Temperature within the chamber during the measurement in <code class="reqn">^{\circ}</code>C (it is converted automatically to Kelvin). When it is changing during the measurement typically the average temperature is used. However, if there is too much change in temperature during the chamber closing time (more than 5 <code class="reqn">^{\circ}</code>K) the ideal gas law might not longer be appropriate.
</p>
</td></tr>
<tr><td><code id="gflux_+3A_v">V</code></td>
<td>

<p>Chamber headspace volume. Because concentrations are typically small volume matters and should therefore be determined as exactly as possible.
</p>
</td></tr>
<tr><td><code id="gflux_+3A_a">A</code></td>
<td>

<p>Area covered by the measurement chamber. Defaults to 1. For dimensionless sampling just leave the default. As with the volume it matters a lot for the end value, therefore it should be determined as exactly as possible.
</p>
</td></tr>
<tr><td><code id="gflux_+3A_m">M</code></td>
<td>

<p>Molar weight of the gas for wich concentration data is given. Defaults to 44 because two of the three most commonly considered greenhouse gases share this molar weight (<code class="reqn">N_2O</code> and <code class="reqn">CO_2</code>). When calculating the flux rate from methane concentrations change accordingly (16 g/mol).
</p>
</td></tr>
<tr><td><code id="gflux_+3A_t">t</code></td>
<td>

<p>Chamber closing time or more exactly the time span between the measurement of c0 and ct. When derived from a regression model this might not be the whole chamber closing time.
</p>
</td></tr>
<tr><td><code id="gflux_+3A_p">p</code></td>
<td>

<p>The air pressure at earth surface during measurements. Default is given by the standard value at sea level of 101325 Pa. Should be OK for most lowland measurements. However, if the measurements took place on higher altitudes, it might be reasonable to adapt the air pressure value to local conditions.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Typically the function will not be called separately. However, for checking single chamber measurements or for testing purposes it might be useful to have this as a separate function.
</p>
<p>The flux rate is calculated using
</p>
<p>flux.rate = ((ct-c0) * V * M * p) / (t * R * (T + 273.15) * A)
</p>
<p>The gas constant R is used with its standard value 8.314 Pa/K*mol.
</p>


<h3>Value</h3>

<p>Returns one numeric value that represents the flux rate in mass unit (depending on input concentration) per <code class="reqn">m^2</code> and hour.
</p>


<h3>Author(s)</h3>

<p>Gerald Jurasinski &lt;gerald.jurasinski@uni-rostock.de&gt;, 
Franziska Koebsch &lt;franziska.koebsch@uni-rostock.de&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+flux">flux</a></code>, <code><a href="#topic+flux.conv">flux.conv</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## see examples for function flux
</code></pre>

<hr>
<h2 id='gpp'>
Model GPP from CO2 closed chamber flux data
</h2><span id='topic+gpp'></span><span id='topic+gpp2'></span>

<h3>Description</h3>

<p>Model GPP from <code class="reqn">CO_2</code> closed chamber flux data under consideration of ecosystem respiration. Four different methods are available: Providing one global Reco model, providing several Reco models, providing estimated Reco fluxes via function <code>gpp</code> or extracting Reco fluxes from real measurements via <code>gpp2</code>. Timestamps are used to assign Reco data to the respective NEE data. In the latter case they have to be provided alongside the Reco fluxes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gpp(NEE, PAR, ts.NEE, PAR.Temp, Reco.m, ts.Reco = NULL, 
method = "Michaelis-Menten", units = "30mins", allow.offset = FALSE, 
virtual = FALSE, start.par = max(PAR), ...)

gpp2(NEE, PAR, ts.NEE, oot, oot.id = c("D", "T"), 
method = "Michaelis-Menten", allow.offset = FALSE, 
virtual = FALSE, start.par = max(PAR), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gpp_+3A_nee">NEE</code></td>
<td>

<p>Numeric vector with <code class="reqn">CO_2</code> fluxes from measurements of <code class="reqn">CO_2</code> net ecosystem exchange (NEE).
</p>
</td></tr>
<tr><td><code id="gpp_+3A_par">PAR</code></td>
<td>

<p>Numeric vector of mean irradiation during <code class="reqn">CO_2</code> flux measurements. Can be supplied as photosynthetically active radiation (PAR) or photosynthetic photon flux density (PPFD).
</p>
</td></tr>
<tr><td><code id="gpp_+3A_ts.nee">ts.NEE</code></td>
<td>

<p>POSIXlt vector holding the timestamp of the <code>NEE</code> values. NEE and Reco values are linked to each other based on their timestamps specified in <code>ts.NEE</code> and <code>ts.Reco</code> or elsewhere (depending on method). The two timestamps don't have to match exactly. In that case, the function links NEE and Reco values based on the time interval given in <code>units</code>.
</p>
</td></tr>
<tr><td><code id="gpp_+3A_par.temp">PAR.Temp</code></td>
<td>

<p>Either numeric vector of mean recorded temperature readings during <code class="reqn">CO_2</code> flux measurements or data.frame with several temperature records (if Reco.m is provided as an object resulting from running <code><a href="#topic+reco.bulk">reco.bulk</a></code>). In case of the latter, appropriate temperatures are extracted based on the <code>which.Temp</code> parameter that is stored to the model structure that is returned by <code><a href="#topic+reco.bulk">reco.bulk</a></code>. Therefore names have to correspond with the particular temperature variable names used in <code class="reqn">R_{eco}</code> modeling (e.g., air, soil in -2cm/-5cm/-10cm depth). See details.
</p>
</td></tr>
<tr><td><code id="gpp_+3A_reco.m">Reco.m</code></td>
<td>

<p>Model structure obtained from running <code><a href="#topic+reco.bulk">reco.bulk</a></code> or <code><a href="#topic+reco">reco</a></code> or vector with estimated Reco values. The latter has to contain (at least) the values that are valid at the times of the NEE measurements. Typically the data will result from estimating hourly or half-hourly <code class="reqn">R_{eco}</code> values using <code><a href="#topic+budget.reco">budget.reco</a></code> on objects of class <code>"breco"</code> derived from running <code><a href="#topic+reco.bulk">reco.bulk</a></code>. See details.
</p>
</td></tr>
<tr><td><code id="gpp_+3A_ts.reco">ts.Reco</code></td>
<td>

<p>POSIXlt vector holding the timestamp of the <code class="reqn">R_{eco}</code> values. Has to be specified if <code class="reqn">R_{eco}</code> values instead of an <code class="reqn">R_{eco}</code> model are given in <code>Reco.m</code>. The function assumes that this is the case if <code>ts.Reco != NULL</code>. See details.
</p>
</td></tr>
<tr><td><code id="gpp_+3A_method">method</code></td>
<td>

<p>The function knows several equations to model the relationship between gpp and irradiation. At the moment <code>"Michaelis-Menten"</code>, <code>"Falge"</code>, <code>"Smith"</code>, and <code>"Misterlich"</code> are implemented which are all discussed in Falge et al. 2001. Partial matching is applied. Defaults to <code>"Michaelis-Menten"</code>. See details for equations.
</p>
</td></tr>
<tr><td><code id="gpp_+3A_units">units</code></td>
<td>

<p>Character string specifying how <code>ts.NEE</code> shall be rounded. If <code>Reco.m</code> holds values instead of an <code class="reqn">R_{eco}</code> model structure the NEE and <code class="reqn">R_{eco}</code> values are matched based on their timestamp after <code>ts.NEE</code> has been rounded according to <code>units</code>.
</p>
</td></tr>
<tr><td><code id="gpp_+3A_allow.offset">allow.offset</code></td>
<td>

<p>Logical. Shall GPP values other than 0 be allowed at zero irradiation? See details.
</p>
</td></tr>
<tr><td><code id="gpp_+3A_virtual">virtual</code></td>
<td>

<p>Logical. If <code>TRUE</code>, virtual NEE data are generated that show a typical saturation curve with saturation at mean <code>NEE</code>. Can be used in bulk gpp modeling to allow falling back to a mean model.
</p>
</td></tr>
<tr><td><code id="gpp_+3A_start.par">start.par</code></td>
<td>

<p>Numeric between 0 and <code>max(PAR)</code>. All data points with <code>PAR &lt;= start.par</code> are used to obtain a start value for alpha via linear regression. Defaults to <code>max(PAR)</code>. See details.
</p>
</td></tr>
<tr><td><code id="gpp_+3A_...">...</code></td>
<td>

<p>Any arguments passed to <code><a href="stats.html#topic+nls">nls</a></code> which is used internally to do the model fitting.
</p>
</td></tr>
<tr><td><code id="gpp_+3A_oot">oot</code></td>
<td>

<p>Vector of length = <code>length(NEE)</code> specifying which of the measured fluxes derive from opaque (<code class="reqn">R_{eco}</code>) and which derive from transparent (NEE) chamber measurements. <code>gpp2</code> uses this to extract corresponding <code class="reqn">R_{eco}</code> values for calculating GPP from NEE before fitting the models (Approach 1, see details.)
</p>
</td></tr>
<tr><td><code id="gpp_+3A_oot.id">oot.id</code></td>
<td>

<p>Vector of length 2 that specifies which of the flux values derive from opaque (first value, i.e. <code class="reqn">R_{eco}</code> measurements) and which derive from transparent (second value, i.e. NEE measurements) chamber measurements when <code>data</code> contains both. May be character, factor, or numeric. See details.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function models the relationship between <code class="reqn">CO_2</code> uptake by plants (gross primary production, GPP) and irradiation using one out of 4 methods (Falge et al. 2001). Per default the Michaelis-Menten kinetic (e.g., Schmitt et al. 2010) is used. The following models can be fitted to the data:
</p>
<p><code class="reqn">GPP = \frac{GPmax * alpha * PAR}{alpha * PAR + GPmax}</code> (Michaelis-Menten)
</p>
<p><code class="reqn">GPP = \frac{alpha * PAR}{1 - \frac{PAR}{2000} + \frac{alpha*PAR}{GPmax}}</code> (Falge)
</p>
<p><code class="reqn">GPP = \frac{GPmax * alpha * PAR}{\sqrt{GPmax^2 + (alpha*par)^2}}</code> (Smith)
</p>
<p><code class="reqn">GPP = GPmax * (1 - e^{\frac{alpha * PAR}{GPmax})}</code> (Misterlich)
</p>
<p>with <code>PAR</code> the incoming light (irradiation). Note, that irradiation can be given in <code>PAR</code> or in PPFD although the equation states <code>PAR</code>. <code>GPmax</code> and <code>alpha</code> are the parameters that are fitted. <code>GPmax</code> refers to the maximum gross primary production at saturating or optimum light whereas alpha refers to the ecosystem quantum yield and gives the starting slope of the model.
</p>
<p>Transparent closed chamber measurements in the field typically capture net ecosystem exchange (<code>NEE</code>), which is the sum of the two opposing processes ecosystem respiration (<code class="reqn">R_{eco}</code>) and GPP. Therefore, it is necessary to subtract modeled <code class="reqn">R_{eco}</code> from the measured <code>NEE</code> to obtain GPP that can be used for the modelling against irradiance.
</p>
<p>Real <code class="reqn">R_{eco}</code> at the time of the <code>NEE</code> measurement is typically unkown because dark and light measurements cannot be taken at the same spot at the same time. Therefore, <code class="reqn">R_{eco}</code> has to be modelled based on dark chamber or nighttime measurements (see <code><a href="#topic+reco">reco</a></code>). For modelling GPP from <code>NEE</code> chamber measurements, <code>gpp</code> just needs measured <code>NEE</code>, the associated irradiance (<code>PAR</code>) and temperature (<code>PAR.Temp</code>) values and the <code class="reqn">R_{eco}</code> model(s) (<code>Reco.m</code>). The <code class="reqn">R_{eco}</code> model(s) can derive from a longer period of time than the <code>NEE</code> data, which is often better to get more reliable models. In contrast, <code>gpp2</code> extracts <code class="reqn">R_{eco}</code> fluxes from actual measurements.
</p>
<p>Approaches to assigning <code class="reqn">R_{eco}</code> values: 
</p>
<p><b>Approach 1:</b> Extract corresponding <code class="reqn">R_{eco}</code> fluxes from the provided data that are assigned to corresponding NEE values via their timestamp: For this approach <code>NEE</code> has to contain both NEE and <code class="reqn">R_{eco}</code> fluxes. <code>oot</code> has to be specified as a vector that indicates whether the respective fluxes were measured as <code>NEE</code> (transparent chamber) or <code>Reco</code> (opaque chamber or low PAR). In addition <code>oot.id</code> may have to be changed accordingly. <code><a href="#topic+gpp2">gpp2</a></code> is used for fitting the models.
</p>
<p><b>Approach 2:</b> If <code>Reco.m</code> is specified as a vector containing modelled <code class="reqn">R_{eco}</code> values these are used to calculate GPP = NEE + Reco. The correct <code class="reqn">R_{eco}</code> values are assigned to the appropriate <code>NEE</code> values by rounding the timestamp of the latter (given in <code>ts.NEE</code>) according to the time lapse of the <code class="reqn">R_{eco}</code> values and then merging both on the respective timestamps. Therefore <code>ts.Reco</code> has to be specified while <code>PAR.Temp</code> is ignored.
</p>
<p><b>Approach 3:</b> If just one <code class="reqn">R_{eco}</code> model is provided as an object of class <code>"reco"</code> resulting from running <code><a href="#topic+reco">reco</a></code> this is used to predict <code class="reqn">R_{eco}</code> at the times of the <code>NEE</code> measurements with the temperatures provided in <code>PAR.Temp</code> as <code>new.data</code>. <code>PAR.Temp</code> has to be specified as a vector of length = length(NEE). <code>ts.Reco</code> must not be specified.
</p>
<p><b>Approach 4:</b> If several <code class="reqn">R_{eco}</code> models are provided as an object of class <code>"breco"</code> resulting from running <code><a href="#topic+reco.bulk">reco.bulk</a></code> these are used to predict <code class="reqn">R_{eco}</code> at the times of the <code>NEE</code> measurements with the temperatures provided in <code>PAR.Temp</code> as <code>new.data</code>. <code>PAR.Temp</code> has to be provided as a data.frame with all temperature variables that were used when obtaining the <code class="reqn">R_{eco}</code> models via <code><a href="#topic+reco.bulk">reco.bulk</a></code> with <code>ncol(PAR.Temp)</code> = <code>length(NEE)</code>. The appropriate temperatures are assigned using the parameter <code>which.Temp</code> that is reported with each model in an object of class <code>"breco"</code>. <code>ts.Reco</code> must not be specified.
</p>
<p>The Michaelis Menten fit to the <code>GPP</code>/<code>PAR</code> relationship presumes that plants (at least C3 plants) do not take up <code class="reqn">CO_2</code> when there is no irradiance. However, sometimes the <code class="reqn">R_{eco}</code> model gives quite unrealistic <code class="reqn">R_{eco}</code> estimates for the times of NEE measurements leading to an alleged considerable uptake of <code class="reqn">CO_2</code> under no or very low light conditions. This in turn leads to unrealistic and not well fitted GPP models. Therefore, it is possible to correct the model by not allowing an offset: <code>allow.offset = FALSE</code> (default). The offset is determined automatically by constructing a linear model using the data points until <code>PAR</code> = <code>start.par</code> and predicting GPP at <code>PAR</code> = 0. The offset is then subtracted from all GPP values and is later automatically added when doing the diagnostic plots.
</p>
<p>The start parameters for the non-linear fit (via <code><a href="stats.html#topic+nls">nls</a></code>) are derived from the data itself. For alpha (initial slope of the model) the slope of the linear model of GPP against <code>PAR</code> constructed from  the data points until <code>PAR</code> = <code>start.par</code> is used. For <code>GPmax</code> the mean of the five highest GPP values is taken.
</p>
<p>It is advisable to test various configurations regarding the <code class="reqn">R_{eco}</code> model and testing the effect of allowing the offset. ATTENTION: The offset is not added back to the predicted GPP data but it is returned as part of the output (see value section). Therefore, if the model parameters and model formula are used to predict GPP fluxes, the offset has to be added manually.
</p>


<h3>Value</h3>

<p>The function returns an object of class <code>gpp</code> (for <code>ts.Reco</code> != <code>NULL</code>) or of class <code>gpp2</code> (for <code>ts.Reco</code> = <code>NULL</code>). It is a list with the following components.
</p>
<table>
<tr><td><code>mg</code></td>
<td>
<p> The gpp model. A <code><a href="stats.html#topic+nls">nls</a></code> model structure. </p>
</td></tr>
<tr><td><code>mr</code></td>
<td>
<p> The Reco model used. A <code><a href="stats.html#topic+nls">nls</a></code> model structure. </p>
</td></tr>
<tr><td><code>data</code></td>
<td>
<p> Either a three entry list (with <code>ts.Reco != NULL</code>) or a 4 entry list (with <code>ts.Reco = NULL</code>) </p>
</td></tr>
<tr><td><code>dat</code></td>
<td>
 <p><code>data.frame</code> (see below for more). </p>
</td></tr>
<tr><td><code>offset</code></td>
<td>
<p> Numeric value giving the offset. </p>
</td></tr>
<tr><td><code>start</code></td>
<td>
<p> List with the start values for the <code>gpp</code> modelling. </p>
</td></tr>
<tr><td><code>PAR.Temp</code></td>
<td>
<p> Numeric vector with the <code>PAR.Temp</code> values specified in the function call. Only reported if <code>ts.Reco = NULL</code>. </p>
</td></tr>
</table>
<p>The <code>data.frame</code> in <code>dat</code> contains the following columns:
</p>
<table>
<tr><td><code>NEE</code></td>
<td>
 <p><code>NEE</code> values. </p>
</td></tr>
<tr><td><code>GPP</code></td>
<td>
<p> Corresponding <code>GPP</code> values. </p>
</td></tr>
<tr><td><code>Reco</code></td>
<td>
<p> Corresponding <code class="reqn">R_{eco}</code> values. </p>
</td></tr>
<tr><td><code>PAR</code></td>
<td>
<p> Corresponding <code>PAR</code> values. </p>
</td></tr>
<tr><td><code>timestamp</code></td>
<td>
<p> Corresponding timestamps. </p>
</td></tr>
<tr><td><code>mins</code></td>
<td>
<p> Temporal distance to next reco value. Always 0 but reported for consistency with <code><a href="#topic+gpp2">gpp2</a></code>. </p>
</td></tr>
<tr><td><code>Reco</code></td>
<td>
<p> Numeric vector of corresponding <code class="reqn">R_{eco}</code> values estimated with the <code class="reqn">R_{eco}</code> model (<code>Reco.m</code>). </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Gerald Jurasinski, <a href="mailto:gerald.jurasinski@uni-rostock.de">gerald.jurasinski@uni-rostock.de</a>
</p>


<h3>References</h3>

<p>Falge E, Baldocchi D, Olson R, Anthoni R, et al. 2001. Gap filling strategies for defensible annual sums of net ecosystem exchange. Agricultural and Forest Meteorology, 107:43-69.
</p>
<p>Schmitt M, Bahn M, Wohlfahrt G, Tappeiner U, Cernusca A. 2010. Land use affects the net ecosystem CO2 exchange and its components in mountain grasslands. Biogeosciences, 7:2297-2309.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+reco">reco</a></code>, <code><a href="#topic+fluxx">fluxx</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## load data
data(tt.flux)

## make timestamp
tt.flux$timestamp &lt;- strptime(paste(tt.flux$date, tt.flux$time), 
format="%Y-%m-%d %H:%M:%S")

## model reco with Arrhenius type model
# extract data and omit estimated fluxes with both the nrmse 
# and the r2 flag set to 0
ttf &lt;- tt.flux[!(tt.flux$CO2.r2.f + tt.flux$CO2.nrmse.f) == 0, ]

# extract table with flux data for reco modeling
ttf4reco &lt;- subset(ttf, kind &gt; 4)

# omit CO2 fluxes below zero
ttf4reco &lt;- ttf4reco[ttf4reco$CO2.flux &gt;= 0,]

# plot reco data
plot(CO2.flux ~ t.air, data=ttf4reco)

# check for the best temperature for reco modelling
temps &lt;- c("t.air", "t.soil2", "t.soil5", "t.soil10")
sapply(temps, function(x) lapply(reco(ttf4reco$CO2.flux, 
ttf4reco[,x], method="arr"), AIC))

# take the temperature in soil 2 cm
reco.m &lt;- reco(ttf4reco$CO2.flux, ttf4reco$t.soil2, method="arr")

# inspect
reco.m

## model gpp
# extract table with flux data for gpp modeling
ttf4gpp &lt;- subset(ttf, kind &lt; 4)

# do a single gpp model for a measurement day using data of spot 2
tmp &lt;- ttf4gpp[(ttf4gpp$date=="2011-05-11") &amp; (ttf4gpp$spot==2),]
gpp.m1 &lt;- gpp(tmp$CO2.flux, tmp$PAR, tmp$timestamp, tmp$t.soil2, 
reco.m[[1]])
# check diagnostic plot
plot(gpp.m1)

# same for spot 3
tmp &lt;- ttf4gpp[(ttf4gpp$date=="2011-05-11") &amp; (ttf4gpp$spot==3),]
gpp.m2 &lt;- gpp(tmp$CO2.flux, tmp$PAR, tmp$timestamp, tmp$t.soil2, 
reco.m[[1]])
# check diagnostic plot
plot(gpp.m2)

# same with all three spots
tmp &lt;- ttf4gpp[(ttf4gpp$date=="2011-05-11"),]
gpp.m3 &lt;- gpp(tmp$CO2.flux, tmp$PAR, tmp$timestamp, tmp$t.soil2, 
reco.m[[1]])
# check diagnostic plot
plot(gpp.m3)

</code></pre>

<hr>
<h2 id='inspect'>
Inspect and alter prepared ghg concentration data
</h2><span id='topic+inspect'></span>

<h3>Description</h3>

<p>The function allows straightforward inspection and alteration of ghg concentration data that have been prepared using <code><a href="#topic+chop">chop</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inspect(x, what, retain = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="inspect_+3A_x">x</code></td>
<td>

<p>Object returned by <code><a href="#topic+chop">chop</a></code> containing tables with chamber measurement data.
</p>
</td></tr>
<tr><td><code id="inspect_+3A_what">what</code></td>
<td>

<p>Specifies the concentration measurement tables in <code>x</code> that ought to be inspected/altered. For inspection either give a numeric vector with the indices of the tables or a character vector with the names of the entries in <code>x</code>. For altering data tables (i.e. deleting some values) use a named list. The names refer to the names of the tables and the entries are either numeric values or vectors that specify the concentration measurements that shall be skipped. The function allows lazy naming so it is possible to provide just the parts of the names that identify a certain measurement unambiguously and checks for consistency. 
</p>
</td></tr>
<tr><td><code id="inspect_+3A_retain">retain</code></td>
<td>

<p>Logical. When you alter <code>x</code> by giving a list structure to <code>what</code>, shall the original data tables be returned as well? Defaults to FALSE.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The typical workflow is to look at the diagnostic plots of the results of the <code><a href="#topic+flux">flux</a></code> estimation and then turn to <code>inspect</code> for having a closer look at the data or to delete some concentration measurements for further estimations.
</p>


<h3>Value</h3>

<p>Either the data tables to inspect are returned in a list or the altered <code>x</code>. In case <code>retain = TRUE</code> the original tables are appended to <code>x</code>. The respective list item is <code>tables.orig</code>.
</p>


<h3>Author(s)</h3>

<p>Gerald Jurasinski &lt;gerald.jurasinski@uni-rostock.de&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+flux">flux</a></code>, <code><a href="#topic+chop">chop</a></code>, 
(also for examples)
</p>

<hr>
<h2 id='lips'>
Linear interpolation between data points similar to approx.
</h2><span id='topic+lips'></span>

<h3>Description</h3>

<p>Linear interpolation between data points similar to approx. x may be a time vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lips(x, y, x.step = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lips_+3A_x">x</code></td>
<td>

<p>Numeric vector or one that could be coerced to numeric along which interpolation shall take place. May be a time vector (POSIXlt or POSIXct).
</p>
</td></tr>
<tr><td><code id="lips_+3A_y">y</code></td>
<td>

<p>Numeric vector of values which shall be interpolated.
</p>
</td></tr>
<tr><td><code id="lips_+3A_x.step">x.step</code></td>
<td>

<p>Numeric giving at what time interval interpolation shall be done. In seconds! Thus half hourly interpolation is achieved with <code>x.step = 1800</code>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Data.frame containing the interpolated x (<code>x.out</code>) and y (<code>x.out</code>) values.
</p>


<h3>Author(s)</h3>

<p>Gerald Jurasinski, <a href="mailto:gerald.jurasinski@uni-rostock.de">gerald.jurasinski@uni-rostock.de</a>
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+approx">approx</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## has to be added
</code></pre>

<hr>
<h2 id='modjust'>
Adjust Reco models
</h2><span id='topic+modjust'></span>

<h3>Description</h3>

<p>The function allows to adjust fitted <code class="reqn">R_{eco}</code> models by eliminating the maximum <code class="reqn">R_{eco}</code> flux as long as the p.value of the linear model of the residuals regressed against original fluxes is above a given threshold. In addition models with parameters that went astray may be skipped. The default is that <code class="reqn">R_{eco}</code> models with t1 &gt; 20 are omitted.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>modjust(models, alpha = 0.1, minimum = 0.8, prmtrs = list(t1 = 20), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="modjust_+3A_models">models</code></td>
<td>

<p>Object of class &quot;<code>breco</code>&quot;.
</p>
</td></tr>
<tr><td><code id="modjust_+3A_alpha">alpha</code></td>
<td>

<p>Alpha level against which the p.value of the linear model of the residuals against original fluxes shall be tested.
</p>
</td></tr>
<tr><td><code id="modjust_+3A_minimum">minimum</code></td>
<td>

<p>The minimum proportion of data points that should be kept. The optimisation runs in a <code>while</code> loop until the p.value is below <code>alpha</code>. It may happen - especially when the number of data points was already low from beginning - that many data points are skipped before a solution is reached. This is prevented by this argument which acts as a brute force to the process and stops it. 
</p>
</td></tr>
<tr><td><code id="modjust_+3A_prmtrs">prmtrs</code></td>
<td>

<p>List object that allows to skip models according to thresholds set for coefficients of the fitted regression models. The list has to be set up according to the actual method used in <code><a href="#topic+reco">reco</a></code> an the names refer to the names of the corresponding coefficients. The default is that <code class="reqn">R_{eco}</code> models with t1 &gt; 20 are omitted.
</p>
</td></tr>
<tr><td><code id="modjust_+3A_...">...</code></td>
<td>

<p>Arguments passed through to <code><a href="#topic+reco">reco</a></code> which is used to fit the models again based on the adjusted data.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When fitting <code class="reqn">R_{eco}</code> models based on one or few measurement campaigns in the field it may happen that outliers in the extremes of the temperature gradient have a very high influence on the fit. Although the model could be fit in the first place this often leads to unrealistic predicted fluxes. The adjustment via <code>modjust</code> leads to better overall performance and reliability of the bulk modelling.
</p>


<h3>Value</h3>

<p>Returns a &quot;<code>breco</code>&quot; object with the possibly adjusted models. All returned models gain a list entry within the <code>mod</code> object (see <code><a href="#topic+reco">reco</a></code> and <code><a href="#topic+reco.bulk">reco.bulk</a></code>) named <code>n.out.adj</code> giving the number of omitted data points. Fall.back models (see <code><a href="#topic+reco.bulk">reco.bulk</a></code>) in <code>models</code> are left untouched.
</p>


<h3>Author(s)</h3>

<p>Gerald Jurasinski, <a href="mailto:gerald.jurasinski@uni-rostock.de">gerald.jurasinski@uni-rostock.de</a>,
</p>
<p>based on ideas by Sascha Beetz, <a href="mailto:sascha.beetz@uni-rostock.de">sascha.beetz@uni-rostock.de</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+reco">reco</a></code>, <code><a href="#topic+reco.bulk">reco.bulk</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## See axamples at reco.bulk
</code></pre>

<hr>
<h2 id='plot.fluss'>
Functions for bulk plotting of concentration change with time as kind of 
diagnostic plots for flux rate calculations
</h2><span id='topic+plot.fluss'></span><span id='topic+plot.flux'></span><span id='topic+plot.fluxes'></span><span id='topic+plot.fluxx'></span><span id='topic+plot.fluxxes'></span>

<h3>Description</h3>

<p>Bulk plotting of concentration change with time adding color and symboling  
for acting as a diagnostic plot for the flux rate estimation functions 
(<code><a href="#topic+flux">flux</a></code>, <code><a href="#topic+flux.odae">flux.odae</a></code>, <code><a href="#topic+flux.conv">flux.conv</a></code>) in 
this package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fluss'
plot(x, subs, dims, folder = getwd(), xlims = NULL, ...)

## S3 method for class 'flux'
plot(x, zero.line, note = "", margin = 0.2, xlims = NULL, ...)

## S3 method for class 'fluxes'
plot(x, dims, ghg = "all", subs = NULL, folder = getwd(), 
xlims = NULL, ask = TRUE, ...)

## S3 method for class 'fluxx'
plot(x, ...)

## S3 method for class 'fluxxes'
plot(x, dims, subs = NULL, folder = getwd(), ask = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.fluss_+3A_x">x</code></td>
<td>

<p>Object of class <code>fluss</code> that is returned by <code><a href="#topic+flux">flux</a></code> or object of class <code>flux</code> that is returned by <code><a href="#topic+flux.conv">flux.conv</a></code>. In case of the latter, the function has to be applied to a list of flux extimation results via <code><a href="base.html#topic+lapply">lapply</a></code> or the like.
</p>
</td></tr>
<tr><td><code id="plot.fluss_+3A_subs">subs</code></td>
<td>

<p>Single character value or character value specifying the factors that shall be used for subsetting the plots into plates (that are stored as pdf files to a folder specified in <code>folder</code>). Must be names of columns of the original data that have been used to partition the data into chunks and that are part of the naming of the data chunks (see <code><a href="#topic+flux">flux</a></code> for details.). When there are only few chamber measurements that shall be plotted to the screen set <code>subs</code> to NULL. This is default behaviour for <code>plot.fluxes</code>
</p>
</td></tr>
<tr><td><code id="plot.fluss_+3A_dims">dims</code></td>
<td>

<p>Integer vector with two elements that specify the mfrow setting (see <code><a href="graphics.html#topic+par">par</a></code> for details) during the plotting of the single plates into pdf files. For all single plots to fit on the plate the product of the two entries has to be equal or higher the number of chamber measurements that are in the data in each partition according to <code>subs</code>.
</p>
</td></tr>
<tr><td><code id="plot.fluss_+3A_folder">folder</code></td>
<td>

<p>Character string giving the path to the folder were the files have to be stored. The names of the pdf files are generated automatically.
</p>
</td></tr>
<tr><td><code id="plot.fluss_+3A_xlims">xlims</code></td>
<td>

<p>Two entry numeric vector specifying the x-axes limits for all plots. Defaults to NULL in which case it is derived from the data itself. The y-axes limits are always set according to the range of the concentration data <code class="reqn">\pm</code> 20
</p>
</td></tr>
<tr><td><code id="plot.fluss_+3A_...">...</code></td>
<td>

<p>further arguments passed through to <code>plot.flux</code> (see below) or to <code><a href="graphics.html#topic+plot.default">plot.default</a></code>.
</p>
</td></tr>
<tr><td><code id="plot.fluss_+3A_zero.line">zero.line</code></td>
<td>

<p>The y-axes position of a horizontal line that reflects the ambient concentration of the plotted gas species. When using <code>plot.fluss</code> this is determined automatically from <code>x</code>.
</p>
</td></tr>
<tr><td><code id="plot.fluss_+3A_note">note</code></td>
<td>

<p>A note that shall appear in the plots. Typically not a fixed value but a value that changes from plot to plot. See example.
</p>
</td></tr>
<tr><td><code id="plot.fluss_+3A_margin">margin</code></td>
<td>

<p>Numeric between 0 and 1. Specifies the empty space within the diagnostic plots on the y-axis. 
</p>
</td></tr>
<tr><td><code id="plot.fluss_+3A_ghg">ghg</code></td>
<td>

<p>Character value or an up to three entry vector specifying which ghg should be plotted. Note that only ghg fluxes that were estimated can be plotted.
</p>
</td></tr>
<tr><td><code id="plot.fluss_+3A_ask">ask</code></td>
<td>

<p>Logical; if TRUE, the user is asked before starting to plot the concentration data for the next ghg, see <code><a href="graphics.html#topic+par">par</a></code>(ask=.) and examples.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Typically <code>plot.fluss</code> will be used. However, for lower level plotting the function <code>plot.flux</code> that also does the plotting within <code>plot.fluss</code> is provided as a separate function.
</p>


<h3>Value</h3>

<p>The function is invoked for its side effects and does not return anything.
</p>


<h3>Author(s)</h3>

<p>Gerald Jurasinski &lt;gerald.jurasinski@uni-rostock.de&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+chop">chop</a></code>, <code><a href="#topic+flux">flux</a></code>, <code><a href="#topic+flux.odae">flux.odae</a></code>, <code><a href="#topic+flux.conv">flux.conv</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## load example data
data(tt.pre)

## extract field concentration measurements
gcd &lt;- tt.pre[tt.pre$sampletype_a=="P",]

## partition the data into data tables per chamber measurement
# then do the partitioning
gcd.parts &lt;- chop(gcd, factors = c("date", "spot", "veg"), 
nmes = c("date", "veg", "spot"))

## calculate flux rates for methane
# first define CH4 range limit (alternatively use flux.calib)
CH4.lim &lt;- 30
# do the flux rate estimation
vp.CH4 &lt;- list(CH4 = "CH4ppb", time = "time_min", CH4.gcq = "CH4Code", 
volume = "cham_vol", t.air = "temp_dC", area = "cham_area", p.air = 101325)
flux.CH4 &lt;- flux(gcd.parts, var.par = vp.CH4, co2ntrol = NULL, 
range.lim=CH4.lim)

## look at the results table
flux.CH4

## plot the concentration-change-with-time-plots as kind of diagnostic
plot(flux.CH4, dims = c(3,6))
</code></pre>

<hr>
<h2 id='plot.gpp'>
Plot diagnostic plots for GPP (NEE) models derived with reco and gpp.
</h2><span id='topic+plot.gpp'></span>

<h3>Description</h3>

<p>Plot diagnostic plots for GPP (NEE) models derived with reco and gpp.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gpp'
plot(x, nm = "", single.pane = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.gpp_+3A_x">x</code></td>
<td>

<p>Object of class <code>gpp</code> that is returned by <code><a href="#topic+gpp">gpp</a></code>.
</p>
</td></tr>
<tr><td><code id="plot.gpp_+3A_nm">nm</code></td>
<td>

<p>The three panels of the resulting plot are already named. However, if you'd like to add something you can do it here.
</p>
</td></tr>
<tr><td><code id="plot.gpp_+3A_single.pane">single.pane</code></td>
<td>

<p>For bulk plotting of several models to one device it is necessary to <code>FALSE</code> <code>single.pane</code>. See example at <code><a href="#topic+gpp">gpp</a></code>
</p>
</td></tr>
<tr><td><code id="plot.gpp_+3A_...">...</code></td>
<td>

<p>Further arguments passed to <code><a href="graphics.html#topic+plot.default">plot.default</a></code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function produces a three panel plot representing in this order from left to right: (1) <code class="reqn">R_{eco}</code> plot and the used <code class="reqn">R_{eco}</code> model. (2) Combined plot of the NEE/GPP data with the measured NEE vs PAR, the derived GPP and the modelled <code class="reqn">R_{eco}</code>. (3) Diagnostic plot of <code class="reqn">NEE_{measured}</code> vs <code class="reqn">NEE_{predicted}</code>
</p>


<h3>Value</h3>

<p>The function is invoked for its side effects and does not return anything.
</p>


<h3>Author(s)</h3>

<p>Gerald Jurasinski &lt;gerald.jurasinski@uni-rostock.de&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+chop">chop</a></code>, <code><a href="#topic+fluxx">fluxx</a></code>, <code><a href="#topic+gpp">gpp</a></code>, <code><a href="#topic+reco">reco</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## see examples at gpp
</code></pre>

<hr>
<h2 id='plot.reco'>
Plot diagnostic plots for Reco models.
</h2><span id='topic+plot.reco'></span>

<h3>Description</h3>

<p>Plot diagnostic plots for <code class="reqn">R_{eco}</code> models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'reco'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.reco_+3A_x">x</code></td>
<td>

<p>Object of class <code>reco</code> that is returned by <code><a href="#topic+reco">reco</a></code>.
</p>
</td></tr>
<tr><td><code id="plot.reco_+3A_...">...</code></td>
<td>

<p>Further arguments passed to <code><a href="graphics.html#topic+plot.default">plot.default</a></code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function produces a plot of the reco model.
</p>


<h3>Value</h3>

<p>The function is invoked for its side effects and does not return anything.
</p>


<h3>Author(s)</h3>

<p>Gerald Jurasinski, <a href="mailto:gerald.jurasinski@uni-rostock.de">gerald.jurasinski@uni-rostock.de</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+chop">chop</a></code>, <code><a href="#topic+fluxx">fluxx</a></code>, <code><a href="#topic+gpp">gpp</a></code>, <code><a href="#topic+reco">reco</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## see examples at gpp
</code></pre>

<hr>
<h2 id='reco'>
Model R_eco from CO2 exchange closed chamber data.
</h2><span id='topic+reco'></span>

<h3>Description</h3>

<p>Model <code class="reqn">R_{eco}</code> from CO2 exchange closed chamber data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reco(R, Temp, Tref = 10, T0 = -46.02, method = "all", min.dp = 6)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reco_+3A_r">R</code></td>
<td>

<p>Numeric vector with ecosystem respiration (<code class="reqn">R_{eco}</code>) flux rates.
</p>
</td></tr>
<tr><td><code id="reco_+3A_temp">Temp</code></td>
<td>

<p>Numeric vector with corresponding temperature values.
</p>
</td></tr>
<tr><td><code id="reco_+3A_tref">Tref</code></td>
<td>

<p>Numeric value giving the reference temperature used in the Arrhenius type model. Defaults to 10 (°C).
</p>
</td></tr>
<tr><td><code id="reco_+3A_t0">T0</code></td>
<td>

<p>Numeric value giving the activation temperature used in the Arrhenius type model. Defaults to -46.02 (°C).
</p>
</td></tr>
<tr><td><code id="reco_+3A_method">method</code></td>
<td>

<p>Specifies the model to be used. Partial match is possible. One can either check all included models (<code>"all"</code>), select the best performing model (according to <code><a href="stats.html#topic+AIC">AIC</a></code>; <code>"best"</code>), or do all models that do not fail in fitting (<code>"not.failed"</code>) or specify one particular model: <code>"linear"</code>, <code>"arrhenius"</code>, <code>"Q10"</code>, <code>"lt"</code> (Lloyd &amp; Taylor), <code>"ltr"</code> (Lloyd &amp; Taylor restricted), <code>"logistic"</code>. See details.
</p>
</td></tr>
<tr><td><code id="reco_+3A_min.dp">min.dp</code></td>
<td>

<p>Integer. Minimum number of data points accepted. If number is below function execution is stopped and a warning is issued.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Respiration is controlled by both biological and physical factors. Work by Arrhenius and van’t Hoff in the late-19th century on the temperature dependence of chemical reactions lead to the insight that there is a certain relationship between temperature and respiration (see review by Lloyd and Taylor, 1994). The most prominent models that have been used extenively in the literature can be fitted with this function. For an in-depth review, even more models and references see Richardson et al. 2006.
</p>
<p>Models (T = <code>Temp</code>erature):
</p>

<table>
<tr>
 <td style="text-align: left;">
    <code>linear</code>
    </td><td style="text-align: left;"> <code class="reqn"> R = \theta_1 + \theta_2*T </code>
    </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>arrhenius</code>
    </td><td style="text-align: left;"> <code class="reqn"> R = \theta_1 + exp\left[E_0 \left( \frac{1}{T_{Ref}-T_0} - \frac{1}{T-T_0} \right) \right]</code>
    </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>Q10</code>
    </td><td style="text-align: left;"> <code class="reqn"> R = \theta_1 \theta_2 ^{(T-T_{Ref})/10} </code>
    </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>lt</code>
    </td><td style="text-align: left;"> <code class="reqn"> R = \theta_1 exp \left( \frac{-\theta_2}{T + 273.15 - \theta_3} \right) </code>
    </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>ltr</code>
    </td><td style="text-align: left;"> <code class="reqn"> R = \theta_1 exp \left( \frac{-308.56}{T + 46.02} \right) </code>
    </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>logistic</code>
    </td><td style="text-align: left;"> <code class="reqn"> R = \frac{\theta_1}{1 + exp(\theta_2-\theta_3T)} </code>
    </td>
</tr>
<tr>
 <td style="text-align: left;">    
 </td>
</tr>

</table>



<h3>Value</h3>

<p>Either returns a list of <code class="reqn">R_{eco}</code> models or the specified model structure. The wanted or resultant model can be fed into <code><a href="#topic+gpp">gpp</a></code> or used on its own to predict Reco values.
</p>


<h3>Note</h3>

<p>In its current implementation the <code>lt</code> and <code>logistic</code> models are easily over parameterized and therefore find singular gradients and provide no fit.
</p>


<h3>Author(s)</h3>

<p>Gerald Jurasinski, <a href="mailto:gerald.jurasinski@uni-rostock.de">gerald.jurasinski@uni-rostock.de</a>
</p>


<h3>References</h3>

<p>Lloyd J, Taylor JA, 1994. On the temperature dependence of soil respiration. Functional Ecology 8:315–323.
</p>
<p>Richardson et al. 2006. Comparing simple respiration models for eddy flux and dynamic chamber data. Agricultural and Forest Meteorology 141:219–234.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gpp">gpp</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## see examples at gpp
</code></pre>

<hr>
<h2 id='reco.bulk'>
Bulk fitting of Reco and GPP models
</h2><span id='topic+reco.bulk'></span><span id='topic+gpp.bulk'></span>

<h3>Description</h3>

<p>The function allows for bulk fitting of <code class="reqn">R_{eco}</code> and GPP models with the respective functions <code><a href="#topic+reco">reco</a></code> and <code><a href="#topic+gpp">gpp</a></code>. This is often appropriate because data are gathered over a season, a year or longer...
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reco.bulk(formula, data, INDEX, window = 1, hook = "mean", remove.outliers = FALSE, 
fall.back = TRUE, ...)

gpp.bulk(formula, data, INDEX, window = 1, hook = "mean", oot.id = c("D", "T"), 
min.dp = 5, Reco.m = NULL, ts.Reco = NULL, fall.back = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reco.bulk_+3A_formula">formula</code></td>
<td>

<p>An object of class &quot;<code><a href="stats.html#topic+formula">formula</a></code>&quot; (or one that can be coerced to that class): a symbolic description of the terms that are used in bulk <code class="reqn">R_{eco}</code> and GPP model fitting. Choices of terms are more restricted than typically (see details). For instance, a timestamp always has to be provided. Also, temperature variables are required for <code>gpp.bulk</code> if <code class="reqn">R_{eco}</code> values are predicted from models.
</p>
</td></tr>
<tr><td><code id="reco.bulk_+3A_data">data</code></td>
<td>

<p>A data frame (or an object that can be coerced to that class by <code>as.data.frame</code>) containing at least all the 'model' terms specified in <code>formula</code>.
</p>
</td></tr>
<tr><td><code id="reco.bulk_+3A_index">INDEX</code></td>
<td>

<p>A vector of length <code>nrow(data)</code> that is used to extract and compile data, for instance according to measurement campaign in the field. Internally <code><a href="base.html#topic+split">split</a></code> is used with <code>f = INDEX</code> to create a list of <code>data.frame</code>s of which each contains all flux measurements for one model.
</p>
</td></tr>
<tr><td><code id="reco.bulk_+3A_window">window</code></td>
<td>

<p>Both functions can fit the respective models across a moving window of adjacent <code>INDEX</code> values. Not advisable for GPP while <code class="reqn">R_{eco}</code> modelling can really profit because more data points often lead to better models.
</p>
</td></tr>
<tr><td><code id="reco.bulk_+3A_hook">hook</code></td>
<td>

<p>Character string specifiying the kind of summary statistics used to fix a date and time to which  the fitted model shall refer. Up to now this is simply achieved by doing one of these summary statistics on the timestamp: <code><a href="base.html#topic+mean">mean</a></code>, <code><a href="base.html#topic+min">min</a></code>, <code><a href="base.html#topic+max">max</a></code> or <code><a href="stats.html#topic+median">median</a></code>.
</p>
</td></tr>
<tr><td><code id="reco.bulk_+3A_remove.outliers">remove.outliers</code></td>
<td>

<p>Logical. If <code>TRUE</code> the function searches for outliers in the data points of the <code class="reqn">R_{eco}</code> models and eliminates them. Per model the <code><a href="grDevices.html#topic+boxplot.stats">boxplot.stats</a></code> of the residuals are obtained and if outliers are present they are eliminated and the model is fitted again. This is done twice. If the function fails in fitting the model to the new data set it falls back to the original data.
</p>
</td></tr>
<tr><td><code id="reco.bulk_+3A_oot.id">oot.id</code></td>
<td>

<p>Vector of length 2 that specifies which of the flux values derive from opaque (first value, i.e. <code class="reqn">R_{eco}</code> measurements) and which derive from transparent (second value, i.e. NEE measurements) chamber measurements when <code>data</code> contains both. This is one of several approaches to GPP modeling here. See details.
</p>
</td></tr>
<tr><td><code id="reco.bulk_+3A_min.dp">min.dp</code></td>
<td>

<p>Numeric. Specifies the minimum number of data points that are accepted per model. Defaults to 5 which is already quite a small number.
</p>
</td></tr>
<tr><td><code id="reco.bulk_+3A_reco.m">Reco.m</code></td>
<td>

<p>Either an object of class &quot;<code>reco</code>&quot; resulting from <code><a href="#topic+reco">reco</a></code> with one <code class="reqn">R_{eco}</code> model or an object of class &quot;<code>breco</code>&quot; resulting from <code><a href="#topic+reco.bulk">reco.bulk</a></code> with several <code class="reqn">R_{eco}</code> models or a vector with estimated half hourly or hourly (or whatever interval you have) <code class="reqn">R_{eco}</code> values. In case of the latter <code>ts.Reco</code> has to be specified as well because it is also used as a switch between internal <code class="reqn">R_{eco}</code> modeling and assigning existing <code class="reqn">R_{eco}</code> values. See details.
</p>
</td></tr>
<tr><td><code id="reco.bulk_+3A_ts.reco">ts.Reco</code></td>
<td>

<p>POSIXlt or POSIXct vector with timestamps of the fluxes in <code>Reco.m</code>. Further, the default (<code>ts.Reco</code> = NULL) lets the function expect model object(s) in <code>Reco.m</code>.
</p>
</td></tr>
<tr><td><code id="reco.bulk_+3A_fall.back">fall.back</code></td>
<td>

<p>Logical. When TRUE the function falls back to linear mean models when the non linear approach did not work out (for <code>reco.bulk</code>: the slope of the linear relationship between Reco and temperature is &lt; 0; for <code>gpp.bulk</code>: either no model could be fit or the starting slope parameter <code>alpha</code> is &gt; 0). To do so a virtual data set is created with 50 random <code>GPP</code> values that have the same mean and sd as the original data and with a sequence of 50 <code>PAR</code> values spanning from 0 to 2000. A linear model is fit to these data with <code>lm(GPP ~ PAR)</code>.
</p>
</td></tr>
<tr><td><code id="reco.bulk_+3A_...">...</code></td>
<td>

<p>Further arguments passed to <code><a href="#topic+reco">reco</a></code> or <code><a href="#topic+gpp">gpp</a></code> e.g., the method for fitting the model when not using the respective defaults.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Models are - comparable to regression models - specified symbolically. Accordingly, the basic form is <code>response ~ terms</code> with <code>response</code> always referring to <code class="reqn">CO_2</code> exchange rates. For <code>terms</code> requirements differ between the two methods. In contrast to other <code>formula</code>e the <code>response</code> and all <code>terms</code> have to be in <code>data</code>.
</p>
<p><code>reco.bulk</code> expects a <code>formula</code> of the form <code>Reco</code> ~ <code>T1</code> +  <code>...</code> + <code>timestamp</code> with <code>Reco</code> referring to <code class="reqn">CO_2</code> fluxes estimated based on opaque chamber measurements (for instance with <code><a href="#topic+flux">flux</a></code>), <code>T1</code> referring to temperature readings relevant for <code>Reco</code> (e.g. air temperature) and taken during the corresponding chamber measurements. The <code>...</code> symbolizes that several more temperature readings can be specified if available (e.g. temperature in soil at 2cm), as many as you want. When more than one temperature is specified models are fit for each temperature and the best one is determined via <code><a href="stats.html#topic+AIC">AIC</a></code> and reported together with the name of the corresponding temperature variable. Finally, <code>timestamp</code> is referring to the <code>POSIXt</code> timestamps that represent the dates and times of the corresponding measurements. <code>timestamp</code> always has to be specified as the last term of the <code>formula</code>. Models are fit using <code><a href="#topic+reco">reco</a></code>.
</p>
<p><code>gpp.bulk</code> expects a <code>formula</code> of the form <code>NEE</code> ~ <code>PAR</code> +  <code>timestamp</code> + <code>...</code> with <code>NEE</code> referring to <code class="reqn">CO_2</code> fluxes estimated based on transparent chamber measurements (for instance with <code><a href="#topic+flux">flux</a></code>), <code>PAR</code> referring to readings of the photosynthetically active radiation relevant for <code>NEE</code> and taken during the corresponding chamber measurements. The <code>...</code> symbolizes that several more terms can or have to be specified. This depends on the approach to the <code class="reqn">R_{eco}</code> part of the GPP modeling (see <code><a href="#topic+gpp">gpp</a></code>).
</p>
<p>Approaches to estimate GPP values from measured NEE data using corresponding <code class="reqn">R_{eco}</code> values:
</p>
<p><b>Approach 1:</b> Extract corresponding <code class="reqn">R_{eco}</code> fluxes from the provided data that are assigned to corresponding NEE values via their timestamp: For this approach <code>data</code> has to contain both NEE and <code class="reqn">R_{eco}</code> fluxes and the model formula is specified as <code>NEE</code> ~ <code>PAR</code> +  <code>timestamp</code> + <code>oot</code> with the latter referring to a variable that indicates whether the respective fluxes were measured as <code>NEE</code> (transparent chamber) or <code>Reco</code> (opaque chamber or low PAR). In addition <code>oot.id</code> may have to be changed accordingly. <code><a href="#topic+gpp2">gpp2</a></code> is used for fitting the models. 
</p>
<p><b>Approach 2:</b> Provide measured <code class="reqn">R_{eco}</code> fluxes that are assigned to corresponding NEE values via their timestamp: To do this set <code>ts.Reco</code> != <code>NULL</code> and <code>Reco.m</code> a vector of <code class="reqn">R_{eco}</code> fluxes and specifiy model with: <code>NEE</code> ~ <code>PAR</code> +  <code>timestamp</code>. <code><a href="#topic+gpp">gpp</a></code> is used for fitting the models.
</p>
<p><b>Approach 3:</b> Provide one <code class="reqn">R_{eco}</code> model to predict <code class="reqn">R_{eco}</code> fluxes at the time of the NEE measurements using the same temperature variable that was used to construct the model (with <code><a href="#topic+reco">reco</a></code>). Specify model with: <code>NEE</code> ~ <code>PAR</code> +  <code>timestamp</code> + <code>temperature</code>. <code><a href="#topic+gpp">gpp</a></code> is used for fitting the models.
</p>
<p><b>Approach 4:</b> Provide several <code class="reqn">R_{eco}</code> models to predict <code class="reqn">R_{eco}</code> fluxes at the time of the NEE measurements using the same temperature variables that were used to construct the models (with <code><a href="#topic+reco.bulk">reco.bulk</a></code>). The corresponding models are assigned to the NEE data via the timestamps that they carry. Specify model with: <code>NEE</code> ~ <code>PAR</code> +  <code>timestamp</code> + <code>temperature1</code> + <code>temperature2</code> + <code>temperature3</code> + <code>...</code>. All temperatures that may have been used for fitting the <code class="reqn">R_{eco}</code> models (see above) should be given. <code><a href="#topic+gpp">gpp</a></code> is used for fitting the models.
</p>
<p><code>remove.outliers</code> may result in better <code class="reqn">R_{eco}</code> models. One should be careful with this and watch out for cases in which too many data points are eliminated. The function returns the number of skipped outliers per model to do just that.
</p>
<p>If <code>fall.back</code> = <code>TRUE</code> no failed model fits are reported. That's quite useful when further bulk methods like <code><a href="#topic+budget.reco">budget.reco</a></code> or <code><a href="#topic+budget.gpp">budget.gpp</a></code> are used to get annual or seasonal budgets.
</p>


<h3>Value</h3>

<p>Both functions return complex list structures with models. 
</p>
<p>Output of <code>reco.bulk</code>:
Object of class &quot;<code>breco</code>&quot;, a list with <code>length(unique(INDEX))</code> elements, each containing 3 elements:
</p>
<table>
<tr><td><code>ts</code></td>
<td>
<p> Timestamp of the model.</p>
</td></tr>
<tr><td><code>mod</code></td>
<td>
<p> Has itself two elements. The first contains the model object as returned by <code>reco</code> and is named according to the method used. The second, <code>n.out</code>, is optional (only reported when <code>remove.outliers = TRUE</code> and there were indeed outliers identified and skipped) and gives the number of omitted data points.</p>
</td></tr>
<tr><td><code>which.Temp</code></td>
<td>
<p> Character string that identifies the temperature variable that was finally used for constructing the best model</p>
</td></tr>
</table>
<p>Output of <code>gpp.bulk</code>:
Object of class &quot;<code>bgpp</code>&quot;, a list with <code>length(unique(INDEX))</code> elements each containing itself 2 entries:
</p>
<table>
<tr><td><code>ts</code></td>
<td>
<p> Timestamp of the model</p>
</td></tr>
<tr><td><code>mod</code></td>
<td>
<p> Either an object of class &quot;<code>gpp</code>&quot; or of class &quot;<code>gpp2</code>&quot; depending on the approach used. Approaches 1 and 2 return &quot;<code>gpp2</code>&quot; objects, Approaches 3 and 4 return &quot;<code>gpp</code>&quot; objects. See <code><a href="#topic+gpp">gpp</a></code> and <code><a href="#topic+gpp2">gpp2</a></code> for details.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Gerald Jurasinski, <a href="mailto:gerald.jurasinski@uni-rostock.de">gerald.jurasinski@uni-rostock.de</a>,
</p>
<p>with suggestions by Sascha Beetz, <a href="mailto:sascha.beetz@uni-rostock.de">sascha.beetz@uni-rostock.de</a>
</p>


<h3>References</h3>

<p>Beetz S, Liebersbach H, Glatzel S, Jurasinski G, Buczko U, Hoper H (2013) Effects of land use intensity on the full greenhouse gas balance in an Atlantic peat bog. Biogeosciences 10:1067-1082
</p>


<h3>See Also</h3>

<p><code><a href="#topic+reco">reco</a></code>, <code><a href="#topic+gpp">gpp</a></code>, <code><a href="#topic+gpp2">gpp2</a></code>, <code><a href="#topic+fluxx">fluxx</a></code>, <code><a href="#topic+modjust">modjust</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Whole example is consecutive and largely marked as
## not run because parts take longer than
## accepted by CRAN incoming checks.
## Remove first hash in each line to run them.
data(amd)
data(amc)

### Reco ###
## do reco models with 3 campaign wide window and 
## outlier removal (outliers according to models)
# first extract opaque (dark) chamber measurements 
amr &lt;- amd[amd$kind=="D",]

## Nor run ##
## do bulk fitting of reco models (all specified temperatures 
## are tested and the best model (per campaign) is finally stored)
#r.models &lt;- reco.bulk(flux ~ t.air + t.soil2 + t.soil5 + 
#t.soil10 + timestamp, amr, amr$campaign, window=3, 
#remove.outliers=TRUE, method="arr", min.dp=2)
#
## adjust models (BEWARE: stupid models with t1 &gt;= 20 are skipped 
## within the function, this can be changed)
#r.models &lt;- modjust(r.models, alpha=0.1, min.dp=3)
#
## make data.frame (table) for overview of model parameters
## the temperature with which the best model could be fit is reported
## this information also resides in the model objects in r.models
#tbl8(r.models)
#
#### GPP ###
### fit GPP models using method = Falge and min.dp = 5
### and take opaque (dark, i.e. reco) measurements from data
## the function issues a warning because some campaigns have
## not enough data points
#g.models &lt;- gpp.bulk(flux ~ PAR + timestamp + kind, amd, amd$campaign, 
#method="Falge", min.dp=5)
#tbl8(g.models)
#
### alternative approaches to acknowledge reco when fitting GPP models
## we need only fluxes based on transparent chamber measurements (NEE)
#amg &lt;- amd[amd$kind=="T",]
## fit gpp models and predict reco from models
#g.models.a1 &lt;- gpp.bulk(flux ~ PAR + timestamp + t.air + t.soil2 + 
#t.soil5 + t.soil10, amg, amg$campaign, method="Falge", min.dp=5, 
#Reco.m=r.models)
#tbl8(g.models.a1)
## have a look the model fits (first 10)
#par(mfrow=c(5,6))
## select only non linear fits
#sel &lt;- sapply(g.models.a1, function(x) class(x$mod$mg)=="nls")
#lapply(g.models.a1[sel][1:10], function(x) plot(x$mod, single.pane=FALSE))
#
## fit gpp models with providing reco data
## to do so, rerun budget.reco with other start and end points
#set.back &lt;- data.frame(timestamp = c("2009-09-01 00:30", "2011-12-31 23:30"), 
#value = c(-999, -9999))
#set.back$timestamp &lt;- strptime(set.back$timestamp, format="%Y-%m-%d %H:%M")
#r.bdgt.a2 &lt;- budget.reco(r.models, amc, set.back)
## now fit the models
#g.models.a2 &lt;- gpp.bulk(flux ~ PAR + timestamp, amg, amg$campaign, 
#method="Falge", units = "30mins", min.dp=5, Reco.m=r.bdgt.a2$reco.flux, 
#ts.Reco = r.bdgt.a2$timestamp)
#tbl8(g.models.a2)
#
## End not run ##

</code></pre>

<hr>
<h2 id='round.POSIXlt'>
Round times.
</h2><span id='topic+round.POSIXlt'></span><span id='topic+round.POSIXct'></span>

<h3>Description</h3>

<p>There are <code><a href="base.html#topic+round">round</a></code> methods in base for objects of <code><a href="base.html#topic+DateTimeClasses">DateTimeClasses</a></code>. However, they can only round to full second, minutes, hours, and days. These functions offer some more options.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'POSIXlt'
round(x, digits = c("mins", "5mins", "10mins", "15mins", "quarter hours", 
"30mins", "half hours", "hours"))

## S3 method for class 'POSIXct'
round(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="round.POSIXlt_+3A_x">x</code></td>
<td>

<p>A <code><a href="base.html#topic+DateTimeClasses">DateTimeClasses</a></code> object to be rounded. Needs to carry a timezone specification.
</p>
</td></tr>
<tr><td><code id="round.POSIXlt_+3A_digits">digits</code></td>
<td>

<p>Either a character string specifying the time units to round to (see choices above) or a numeric specifying the minutes to round to. To go to seconds just use values &lt; 1, to go beyond the hour just use values &gt; 60.
</p>
</td></tr>
<tr><td><code id="round.POSIXlt_+3A_...">...</code></td>
<td>

<p>Further arguments to methods.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>POSIXct</code> object with rounded, not truncated date times.
</p>


<h3>Author(s)</h3>

<p>Gerald Jurasinski, <a href="mailto:gerald.jurasinski@uni-rostock.de">gerald.jurasinski@uni-rostock.de</a>,
</p>
<p>borrowing heavily from https://stat.ethz.ch/pipermail/r-help/2012-June/315336.html
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Current time in GMT and as class "POSIXlt"
zlt &lt;- as.POSIXlt(Sys.time(), "GMT") 

# Same time as class POSIXct
zct &lt;- as.POSIXct(zlt)

# round to minute
round(zct)

# round to half hour
round(zct, "30mins")
round(zct, "half hour")
round(zct, 30)

# round to 20 minutes
round(zlt, 20)

# round to 30 seconds
round(zlt, 0.5)
</code></pre>

<hr>
<h2 id='tbl8'>
Extract the relevant data of a bulk model object to a data.frame
</h2><span id='topic+tbl8'></span>

<h3>Description</h3>

<p>Extract the relevant data of an object of class &quot;<code>breco</code>&quot; to a <code>data.frame</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tbl8(models)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tbl8_+3A_models">models</code></td>
<td>

<p>An object of class &quot;<code>breco</code>&quot; returned by <code>reco.bulk</code> or an object of class &quot;<code>bgpp</code>&quot; returned by <code>gpp.bulk</code>. 
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a <code>data.frame</code> with the model coefficients, brute force R2s (not reliable because non linear responses are fitted), timestamps and the <code>which.Temp</code> string or the <code>offset</code> for <code class="reqn">R_{eco}</code> models and GPP models, respectively.
</p>


<h3>Author(s)</h3>

<p>Gerald Jurasinski, <a href="mailto:gerald.jurasinski@uni-rostock.de">gerald.jurasinski@uni-rostock.de</a>,
based on an idea by Sascha Beetz, <a href="mailto:sascha.beetz@uni-rostock.de">sascha.beetz@uni-rostock.de</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+reco">reco</a></code>, <code><a href="#topic+reco.bulk">reco.bulk</a></code>, <code><a href="#topic+gpp">gpp</a></code>, <code><a href="#topic+gpp.bulk">gpp.bulk</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## see examples at reco.bulk
</code></pre>

<hr>
<h2 id='tt.nee'>
Medium frequency concentration data and fluxes from non-steady state closed chamber measurements
</h2><span id='topic+tt.nee'></span><span id='topic+tt.flux'></span>

<h3>Description</h3>

<p>The data comes from the Trebeltal / Northeastern Germany and has been recorded with flexible transparent and opaque non-steady state closed chambers in 2011. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(tt.nee)
data(tt.flux)
</code></pre>


<h3>Format</h3>

<p><code>tt.nee</code> is a <code><a href="base.html#topic+data.frame">data.frame</a></code> with 18 variables representing 14388 CO2 concentration measurements from 104 chamber placements.
</p>
<p><code>tt.flux</code> is a results table representing fluxes estimated with <code><a href="#topic+fluxx">fluxx</a></code> from <code>tt.nee</code> with 28 columns and 104 rows (= number of chamber placements in <code>tt.nee</code>). Contains many variables from <code>tt.nee</code>.
</p>

<dl>
<dt><code>date</code></dt><dd><p>Factor giving the date of field sampling, format is &quot;%Y-%m-%d&quot;.</p>
</dd>
<dt><code>time</code></dt><dd><p>Factor giving the time of measurement in the field, format is &quot;%H:%M:%S&quot;.</p>
</dd>
<dt><code>session</code></dt><dd><p>(Unique) Session number identifying one chamber placement. Integer.</p>
</dd>
<dt><code>record</code></dt><dd><p>Integer, running number of concentration measurement within one <code>session</code>. </p>
</dd>  
<dt><code>spot</code></dt><dd><p>Factor identifying the field measurement location.</p>
</dd>
<dt><code>PAR</code></dt><dd><p>Numeric. Photosynthetic photon flux density (PPFD).</p>
</dd>
<dt><code>t.cham</code></dt><dd><p>Numeric. Temperature logged inside chamber during concentration measurements</p>
</dd>
<dt><code>NEE</code></dt><dd><p>Numeric. CO2 concentration in chamber headspace.</p>
</dd>
<dt><code>t.air</code></dt><dd><p>Numeric. Air temperature outside chamber.</p>
</dd>
<dt><code>t.soil2</code></dt><dd><p>Numeric. Soil temperature at 2cm depth.</p>
</dd>
<dt><code>t.soil5</code></dt><dd><p>Numeric. Soil temperature at 5cm depth.</p>
</dd>
<dt><code>t.soil10</code></dt><dd><p>Numeric. Soil temperature at 10cm depth.</p>
</dd>
<dt><code>area</code></dt><dd><p>Numeric. Chamber area.</p>
</dd>
<dt><code>height</code></dt><dd><p>Numeric. Chamber height.</p>
</dd>
<dt><code>kind</code></dt><dd><p>Integer. Chamber kind. 1 = transparent chamber, 3 = transparent chamber with measurement before sun rise, 5 = opaque chamber</p>
</dd>
<dt><code>volume</code></dt><dd><p>Numeric. Chamber volume.</p>
</dd>
<dt><code>datetime</code></dt><dd><p>POSIXlt. Time stamp.</p>
</dd>
<dt><code>plot</code></dt><dd><p>Factor identifying the field plot (all TY1).</p>
</dd>
<dt><code>all</code></dt><dd><p>Factor. Combined unique identifier for chamber placement.</p>
</dd>
<dt><code>CO2.pv</code></dt><dd><p>Numeric. p.value of the fitted regression for the flux estimation.</p>
</dd>
<dt><code>CO2.r2.f</code></dt><dd><p>Logical numeric (0 | 1) giving the r2 flag. See <code><a href="#topic+fluxx">fluxx</a></code> for details.</p>
</dd>
<dt><code>CO2.range.f</code></dt><dd><p>Logical numeric (0 | 1) giving the range flag. See <code><a href="#topic+fluxx">fluxx</a></code> for details.</p>
</dd>
<dt><code>CO2.nrmse.f</code></dt><dd><p>Logical numeric (0 | 1) giving the nrmse flag. See <code><a href="#topic+fluxx">fluxx</a></code> for details.</p>
</dd>
<dt><code>CO2.ghg</code></dt><dd><p>Character. Greenhouse gas as submitted to <code><a href="#topic+fluxx">fluxx</a></code> via <code>var.par</code>.</p>
</dd>
<dt><code>CO2.unit</code></dt><dd><p>Character. Ouput unit of the flux as specified via <code>out.unit</code> in <code><a href="#topic+fluxx">fluxx</a></code>.</p>
</dd>
<dt><code>CO2.flux</code></dt><dd><p>Numeric. Flux</p>
</dd>
<dt><code>CO2.r2</code></dt><dd><p>Numeric. R2 of the model that has been used for flux estimation.</p>
</dd>
<dt><code>CO2.nrmse</code></dt><dd><p>Numeric. NRMSE of the model that has been used for flux estimation.</p>
</dd>
<dt><code>CO2.nomba.f</code></dt><dd><p>Numeric. Number of concentration measurements below ambient.</p>
</dd>
<dt><code>CO2.podpu</code></dt><dd><p>Numeric between 0 and 1. Propórtion of data points used.</p>
</dd>
</dl>



<h3>Details</h3>

<p><code>tt.nee</code> contains medium frequency (measured online) CO2 concentration data from 3 spots with <em>Typha angustifolia</em> and includes data needed for modelling <code><a href="#topic+gpp">gpp</a></code>/nne measured with transparent chamber and <code><a href="#topic+reco">reco</a></code> measured with opaque chamber. <code>tt.flux</code> contains fluxes estimated from <code>tt.nee</code> using <code><a href="#topic+fluxx">fluxx</a></code>. 
</p>


<h3>Source</h3>

<p>unpublished preliminary data
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## see examples at fluxx and gpp.
</code></pre>

<hr>
<h2 id='tt.pre'>
One day data from closed chamber measurements in the Trebeltal
</h2><span id='topic+tt.pre'></span>

<h3>Description</h3>

<p>The data comes from the Trebeltal / Northeastern Germany and has been recorded with flexible non-steady state closed chambers in March 2011. It contains concentration data from 18 chamber measurements including calibration gas measurements that have been carried out alternatingly on the GC.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(tt.pre)</code></pre>


<h3>Format</h3>

<p>A data frame with 118 observations on the following 17 variables.
</p>

<dl>
<dt><code>year</code></dt><dd><p>numeric vector giving the year of measurement</p>
</dd>
<dt><code>date</code></dt><dd><p>factor giving the date of field sampling, format is &quot;%Y-%m-%d&quot;</p>
</dd>
<dt><code>time</code></dt><dd><p>factor giving the time of measurement in the field, format is &quot;%H:%M&quot;</p>
</dd>
<dt><code>veg</code></dt><dd><p>factor with levels <code>c</code> <code>p</code> <code>t</code></p>
</dd>
<dt><code>spot</code></dt><dd><p>numeric vector, but it is a factor giving the number of the field measurement location. The combination of <code>veg</code> and <code>spot</code> uniquely identifies the measurement locations in the site</p>
</dd>
<dt><code>time_min</code></dt><dd><p>numeric vector, time in minutes during the chamber placement. starts with 0 from placing the chamber</p>
</dd>
<dt><code>sampletype_a</code></dt><dd><p>factor with levels <code>E</code> <code>P</code> determining whether its a field concentration measurement or a calibration gas measurement</p>
</dd>
<dt><code>temp_dC</code></dt><dd><p>numeric vector, air temperature within chamber during measurements, taken at the same times as the concentration samples</p>
</dd>
<dt><code>cham_vol</code></dt><dd><p>numeric vector, chamber volume per chamber placement. Varies from chamber placement to chamber placement depending on the chamber used</p>
</dd>
<dt><code>cham_area</code></dt><dd><p>numeric vector giving the chamber area</p>
</dd>
<dt><code>date_gc</code></dt><dd><p>factor giving the date of the gc measurement, format is &quot;%Y-%m-%d&quot;</p>
</dd>
<dt><code>CO2Code</code></dt><dd><p>numeric vector, quality parameter from the GC</p>
</dd>
<dt><code>CO2ppm</code></dt><dd><p>numeric vector, concentration of CH4 in air sample / calibration gas sample</p>
</dd>
<dt><code>N2OCode</code></dt><dd><p>numeric vector, quality parameter from the GC</p>
</dd>
<dt><code>N2Oppb</code></dt><dd><p>numeric vector, concentration of N2O in air sample / calibration gas sample</p>
</dd>
<dt><code>CH4Code</code></dt><dd><p>numeric vector, quality parameter from the GC</p>
</dd>
<dt><code>CH4ppb</code></dt><dd><p>numeric vector, concentration of CO2 in air sample / calibration gas sample</p>
</dd>
</dl>



<h3>Details</h3>

<p>The 18 chamber measurements are carried out on three vegetation types (<em>Phragmites</em>, <em>Typha</em>, <em>Carex</em>).
</p>


<h3>Source</h3>

<p>unpublished preliminary data, whole data set in
</p>
<p>Günther A, Huth V, Jurasinski G, Glatzel S (2013a) Scale-dependent temporal variation during the determination of the methane balance of a temperate fen. Greenhouse Gas Measurement &amp; Management DOI: 10.1080/20430779.2013.850395
</p>
<p>Huth V, Günther A, Jurasinski G, Glatzel S (2013) The impact of an extraordinarily wet summer on methane emissions from a 15-year re-wetted fen in north-east Germany. Mires &amp; Peat 13.2:1–7
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## load data
data(tt.pre)
## see their structure
str(tt.pre)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
