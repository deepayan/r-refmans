<!DOCTYPE html><html><head><title>Help for package CovRegRF</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {CovRegRF}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#CovRegRF-package'><p>CovRegRF: A package for estimating covariance matrix of a multivariate</p>
response given a set of covariates with random forests</a></li>
<li><a href='#covregrf'><p>Covariance Regression with Random Forests</p></a></li>
<li><a href='#data'><p>Generated example data</p></a></li>
<li><a href='#plot.vimp.covregrf'><p>Plot variable importance measures for covregrf objects</p></a></li>
<li><a href='#predict.covregrf'><p>Predict method for covregrf objects</p></a></li>
<li><a href='#print.covregrf'><p>Print summary output of a CovRegRF analysis</p></a></li>
<li><a href='#significance.test'><p>Significance test</p></a></li>
<li><a href='#vimp.covregrf'><p>Variable importance for covregrf objects</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Covariance Regression with Random Forests</td>
</tr>
<tr>
<td>Version:</td>
<td>2.0.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Covariance Regression with Random Forests (CovRegRF) is a
    random forest method for estimating the covariance matrix of a
    multivariate response given a set of covariates. Random forest trees
    are built with a new splitting rule which is designed to maximize the
    distance between the sample covariance matrix estimates of the child
    nodes. The method is described in Alakus et al. (2023)
    &lt;<a href="https://doi.org/10.1186%2Fs12859-023-05377-y">doi:10.1186/s12859-023-05377-y</a>&gt;. 'CovRegRF' uses 'randomForestSRC' package
    (Ishwaran and Kogalur, 2022) 
    <a href="https://cran.r-project.org/package=randomForestSRC">https://cran.r-project.org/package=randomForestSRC</a> by freezing at the
    version 3.1.0. The custom splitting rule feature is utilised to apply the
    proposed splitting rule. The 'randomForestSRC' package implements 'OpenMP' 
    by default, contingent upon the support provided by the target architecture 
    and operating system. In this package, 'LAPACK' and 'BLAS' libraries are 
    used for matrix decompositions.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.6.0)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.0</td>
</tr>
<tr>
<td>Imports:</td>
<td>data.table, data.tree, DiagrammeR</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-02-12 19:18:36 UTC; cansualakus</td>
</tr>
<tr>
<td>Author:</td>
<td>Cansu Alakus [aut, cre],
  Denis Larocque [aut],
  Aurelie Labbe [aut],
  Hemant Ishwaran [ctb] (Author of included 'randomForestSRC' codes),
  Udaya B. Kogalur [ctb] (Author of included 'randomForestSRC' codes),
  Intel Corporation [cph] (Copyright holder of included LAPACKE codes),
  Keita Teranishi [ctb] (Author of included cblas_dgemm.c codes)</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Cansu Alakus &lt;cansu.alakus@hec.ca&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-02-13 17:12:47 UTC</td>
</tr>
</table>
<hr>
<h2 id='CovRegRF-package'>CovRegRF: A package for estimating covariance matrix of a multivariate
response given a set of covariates with random forests</h2><span id='topic+CovRegRF-package'></span>

<h3>Description</h3>

<p>Covariance Regression with Random Forests (CovRegRF) is a random forest
method for estimating the covariance matrix of a multivariate response given
a set of covariates. Random forest trees are built with a new splitting rule
which is designed to maximize the distance between the sample covariance
matrix estimates of the child nodes. The method is described in Alakus et al.
(2023). CovRegRF uses 'randomForestSRC' package (Ishwaran and Kogalur, 2022)
by freezing at the version 3.1.0. The custom splitting rule feature is
utilised to apply the proposed splitting rule.
</p>


<h3>CovRegRF functions</h3>

<p><code><a href="#topic+covregrf">covregrf</a></code>
<code><a href="#topic+predict.covregrf">predict.covregrf</a></code>
<code><a href="#topic+significance.test">significance.test</a></code>
<code><a href="#topic+vimp.covregrf">vimp.covregrf</a></code>
<code><a href="#topic+plot.vimp.covregrf">plot.vimp.covregrf</a></code>
<code><a href="#topic+print.covregrf">print.covregrf</a></code>
</p>


<h3>References</h3>

<p>Alakus, C., Larocque, D., and Labbe, A. (2023). Covariance
regression with random forests. BMC Bioinformatics 24, 258.
</p>
<p>Ishwaran H., Kogalur U. (2022). Fast Unified Random Forests for
Survival, Regression, and Classification (RF-SRC). R package version 3.1.0,
<a href="https://cran.r-project.org/package=randomForestSRC">https://cran.r-project.org/package=randomForestSRC</a>.
</p>

<hr>
<h2 id='covregrf'>Covariance Regression with Random Forests</h2><span id='topic+covregrf'></span>

<h3>Description</h3>

<p>Estimates the covariance matrix of a multivariate response given a set of
covariates using a random forest framework.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>covregrf(
  formula,
  data,
  params.rfsrc = list(ntree = 1000, mtry = ceiling(px/3), nsplit = max(round(n/50),
    10)),
  nodesize.set = round(0.5^(1:100) * sampsize)[round(0.5^(1:100) * sampsize) &gt; py],
  importance = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="covregrf_+3A_formula">formula</code></td>
<td>
<p>Object of class <code>formula</code> or <code>character</code> describing
the model to fit. Interaction terms are not supported.</p>
</td></tr>
<tr><td><code id="covregrf_+3A_data">data</code></td>
<td>
<p>The multivariate data set which has <code class="reqn">n</code> observations and
<code class="reqn">px+py</code> variables where <code class="reqn">px</code> and <code class="reqn">py</code> are the number of
covariates (<code class="reqn">X</code>) and response variables (<code class="reqn">Y</code>), respectively. Should
be a data.frame.</p>
</td></tr>
<tr><td><code id="covregrf_+3A_params.rfsrc">params.rfsrc</code></td>
<td>
<p>List of parameters that should be passed to
<code>randomForestSRC</code>. In the default parameter set, <code>ntree</code> = 1000,
<code>mtry</code> = <code class="reqn">px/3</code>  (rounded up), <code>nsplit</code> =
<code class="reqn">max(round(n/50), 10)</code>. See <code>randomForestSRC</code> for possible
parameters.</p>
</td></tr>
<tr><td><code id="covregrf_+3A_nodesize.set">nodesize.set</code></td>
<td>
<p>The set of <code>nodesize</code> levels for tuning. Default set
includes the power of two times the sub-sample size (<code class="reqn">.632n</code>) greater
than the number of response variables (<code class="reqn">py</code>). See below for details of
the <code>nodesize</code> tuning.</p>
</td></tr>
<tr><td><code id="covregrf_+3A_importance">importance</code></td>
<td>
<p>Should variable importance of covariates be assessed? The
default is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>(covregrf, grow)</code> which is a list with the
following components:
</p>
<table>
<tr><td><code>predicted.oob</code></td>
<td>
<p>OOB predicted covariance matrices for training
observations.</p>
</td></tr>
<tr><td><code>importance</code></td>
<td>
<p>Variable importance measures (VIMP) for covariates.</p>
</td></tr>
<tr><td><code>best.nodesize</code></td>
<td>
<p>Best <code>nodesize</code> value selected with the proposed
tuning method.</p>
</td></tr>
<tr><td><code>params.rfsrc</code></td>
<td>
<p>List of parameters that was used to fit random forest
with <code>randomForestSRC</code>.</p>
</td></tr>
<tr><td><code>n</code></td>
<td>
<p>Sample size of the data (<code>NA</code>'s are omitted).</p>
</td></tr>
<tr><td><code>xvar.names</code></td>
<td>
<p>A character vector of the covariate names.</p>
</td></tr>
<tr><td><code>yvar.names</code></td>
<td>
<p>A character vector of the response variable names.</p>
</td></tr>
<tr><td><code>xvar</code></td>
<td>
<p>Data frame of covariates.</p>
</td></tr>
<tr><td><code>yvar</code></td>
<td>
<p>Data frame of responses.</p>
</td></tr>
<tr><td><code>rf.grow</code></td>
<td>
<p>Fitted random forest object. This object is used for
prediction with training or new data.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For mean regression problems, random forests search for the optimal level
of the <code>nodesize</code> parameter by using out-of-bag (OOB) prediction
errors computed as the difference between the true responses and OOB
predictions. The <code>nodesize</code> value having the smallest OOB prediction
error is chosen. However, the covariance regression problem is
unsupervised by nature. Therefore, we tune <code>nodesize</code> parameter with a
heuristic method. We use OOB covariance matrix estimates. The general idea
of the proposed tuning method is to find the <code>nodesize</code> level where
the OOB covariance matrix predictions converge. The steps are as follows.
Firstly, we train separate random forests for a set of <code>nodesize</code>
values. Secondly, we compute the OOB covariance matrix estimates for each
random forest. Next, we compute the mean absolute difference (MAD) between
the upper triangular OOB covariance matrix estimates of two consecutive
<code>nodesize</code> levels over all observations. Finally, we take the pair of
<code>nodesize</code> levels having the smallest MAD. Among these two
<code>nodesize</code> levels, we select the smaller since in general deeper trees
are desired in random forests.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+predict.covregrf">predict.covregrf</a></code>
<code><a href="#topic+significance.test">significance.test</a></code>
<code><a href="#topic+vimp.covregrf">vimp.covregrf</a></code>
<code><a href="#topic+print.covregrf">print.covregrf</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>options(rf.cores=2, mc.cores=2)

## load generated example data
data(data, package = "CovRegRF")
xvar.names &lt;- colnames(data$X)
yvar.names &lt;- colnames(data$Y)
data1 &lt;- data.frame(data$X, data$Y)

## define train/test split
set.seed(2345)
smp &lt;- sample(1:nrow(data1), size = round(nrow(data1)*0.6), replace = FALSE)
traindata &lt;- data1[smp,,drop=FALSE]
testdata &lt;- data1[-smp, xvar.names, drop=FALSE]

## formula object
formula &lt;- as.formula(paste(paste(yvar.names, collapse="+"), ".", sep=" ~ "))

## train covregrf
covregrf.obj &lt;- covregrf(formula, traindata, params.rfsrc = list(ntree = 50),
  importance = TRUE)

## get the OOB predictions
pred.oob &lt;- covregrf.obj$predicted.oob

## predict with new test data
pred.obj &lt;- predict(covregrf.obj, newdata = testdata)
pred &lt;- pred.obj$predicted

## get the variable importance measures
vimp &lt;- covregrf.obj$importance


</code></pre>

<hr>
<h2 id='data'>Generated example data</h2><span id='topic+data'></span>

<h3>Description</h3>

<p>A generated data set containing two multivariate data sets: X and Y, which
represent the set of covariates and responses, respectively. The covariance
matrix of Y has a compound symmetry structure with heterogeneous variances.
Both variances and correlations are functions of the covariates. X variables
are generated from the standard normal distribution. The correlations are
generated with a logit model and the variances are functions of these
generated correlations. The sample size is 200. There are 3 covariates and 3
response variables. x1 and x2 are the importantvariables for the varying
covariance matrix of Y. x3 is the noise variable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data
</code></pre>


<h3>Format</h3>

<p>A list with two elements namely X and Y. Each element has 200 rows.
X has 3 columns and Y has 3 columns.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## load generated example data
data(data, package = "CovRegRF")

</code></pre>

<hr>
<h2 id='plot.vimp.covregrf'>Plot variable importance measures for covregrf objects</h2><span id='topic+plot.vimp.covregrf'></span><span id='topic+plot.vimp'></span>

<h3>Description</h3>

<p>Plots variable importance measures (VIMP) for covariates for training data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'covregrf'
plot.vimp(x, sort = TRUE, ndisp = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.vimp.covregrf_+3A_x">x</code></td>
<td>
<p>An object of class (covregrf, grow) or (covregrf, vimp).</p>
</td></tr>
<tr><td><code id="plot.vimp.covregrf_+3A_sort">sort</code></td>
<td>
<p>Should the covariates be sorted according to their variable
importance measures in the plot? The default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="plot.vimp.covregrf_+3A_ndisp">ndisp</code></td>
<td>
<p>Number of covariates to display in the plot. If <code>sort</code>=
<code>TRUE</code>, the most important <code>ndisp</code> covariates will be plotted.
Otherwise, the first <code>ndisp</code> covariates in the original call will be
plotted. The default value is <code>NULL</code> which will plot all covariates.</p>
</td></tr>
<tr><td><code id="plot.vimp.covregrf_+3A_...">...</code></td>
<td>
<p>Optional arguments to be passed to other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Invisibly, the variable importance measures that were plotted.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+vimp.covregrf">vimp.covregrf</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>options(rf.cores=2, mc.cores=2)

## load generated example data
data(data, package = "CovRegRF")
xvar.names &lt;- colnames(data$X)
yvar.names &lt;- colnames(data$Y)
data1 &lt;- data.frame(data$X, data$Y)

## define train/test split
set.seed(2345)
smp &lt;- sample(1:nrow(data1), size = round(nrow(data1)*0.6), replace = FALSE)
traindata &lt;- data1[smp,,drop=FALSE]
testdata &lt;- data1[-smp, xvar.names, drop=FALSE]

## formula object
formula &lt;- as.formula(paste(paste(yvar.names, collapse="+"), ".", sep=" ~ "))

## train covregrf
covregrf.obj &lt;- covregrf(formula, traindata, params.rfsrc = list(ntree = 50),
  importance = TRUE)

## plot vimp
plot.vimp(covregrf.obj)


</code></pre>

<hr>
<h2 id='predict.covregrf'>Predict method for covregrf objects</h2><span id='topic+predict.covregrf'></span>

<h3>Description</h3>

<p>Obtain predicted covariance matrices using a covregrf forest for training or
new data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'covregrf'
predict(object, newdata, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.covregrf_+3A_object">object</code></td>
<td>
<p>An object of class <code>(covregrf, grow)</code> created by the
function <code>covregrf</code>.</p>
</td></tr>
<tr><td><code id="predict.covregrf_+3A_newdata">newdata</code></td>
<td>
<p>Test data of the set of covariates. A data.frame with numeric
values and factors. If missing, the out-of-bag predictions in <code>object</code>
is returned.</p>
</td></tr>
<tr><td><code id="predict.covregrf_+3A_...">...</code></td>
<td>
<p>Optional arguments to be passed to other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>(covregrf, predict)</code> which is a list with the
following components:
</p>
<table>
<tr><td><code>predicted</code></td>
<td>
<p>Predicted covariance matrices for test data. If
<code>newdata</code> is missing, OOB predictions for training observations.</p>
</td></tr>
<tr><td><code>bop</code></td>
<td>
<p>Bag of Observations for Prediction. An <code class="reqn">nxn</code> matrix of
counts.</p>
</td></tr>
<tr><td><code>n</code></td>
<td>
<p>Sample size of the test data (<code>NA</code>'s are omitted). If
<code>newdata</code> is missing, sample size of the training set.</p>
</td></tr>
<tr><td><code>xvar.names</code></td>
<td>
<p>A character vector of the covariate names.</p>
</td></tr>
<tr><td><code>yvar.names</code></td>
<td>
<p>A character vector of the response variable names.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+covregrf">covregrf</a></code>
<code><a href="#topic+vimp.covregrf">vimp.covregrf</a></code>
<code><a href="#topic+print.covregrf">print.covregrf</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>options(rf.cores=2, mc.cores=2)

## load generated example data
data(data, package = "CovRegRF")
xvar.names &lt;- colnames(data$X)
yvar.names &lt;- colnames(data$Y)
data1 &lt;- data.frame(data$X, data$Y)

## define train/test split
set.seed(2345)
smp &lt;- sample(1:nrow(data1), size = round(nrow(data1)*0.6), replace = FALSE)
traindata &lt;- data1[smp,,drop=FALSE]
testdata &lt;- data1[-smp, xvar.names, drop=FALSE]

## formula object
formula &lt;- as.formula(paste(paste(yvar.names, collapse="+"), ".", sep=" ~ "))

## train covregrf
covregrf.obj &lt;- covregrf(formula, traindata, params.rfsrc = list(ntree = 50))

## predict without new data (OOB predictions will be returned)
pred.obj &lt;- predict(covregrf.obj)
pred.oob &lt;- pred.obj$predicted

## predict with new test data
pred.obj2 &lt;- predict(covregrf.obj, newdata = testdata)
pred &lt;- pred.obj2$predicted


</code></pre>

<hr>
<h2 id='print.covregrf'>Print summary output of a CovRegRF analysis</h2><span id='topic+print.covregrf'></span>

<h3>Description</h3>

<p>Print summary output of a CovRegRF analysis. This is the default print method
for the package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'covregrf'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.covregrf_+3A_x">x</code></td>
<td>
<p>An object of class <code>(covregrf, grow)</code>, <code>(covregrf, predict)</code>
or <code>(covregrf, significancetest)</code>.</p>
</td></tr>
<tr><td><code id="print.covregrf_+3A_...">...</code></td>
<td>
<p>Optional arguments to be passed to other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a <code>character</code> string for the summary of CovRegRF
analysis.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>options(rf.cores=2, mc.cores=2)

## load generated example data
data(data, package = "CovRegRF")
xvar.names &lt;- colnames(data$X)
yvar.names &lt;- colnames(data$Y)
data1 &lt;- data.frame(data$X, data$Y)

## define train/test split
set.seed(2345)
smp &lt;- sample(1:nrow(data1), size = round(nrow(data1)*0.6), replace = FALSE)
traindata &lt;- data1[smp,,drop=FALSE]
testdata &lt;- data1[-smp, xvar.names, drop=FALSE]

## formula object
formula &lt;- as.formula(paste(paste(yvar.names, collapse="+"), ".", sep=" ~ "))

## train covregrf
covregrf.obj &lt;- covregrf(formula, traindata, params.rfsrc = list(ntree = 50))

## print the grow object
print(covregrf.obj)

## predict with new test data
pred.obj &lt;- predict(covregrf.obj, newdata = testdata)

## print the predict object
print(pred.obj)

</code></pre>

<hr>
<h2 id='significance.test'>Significance test</h2><span id='topic+significance.test'></span>

<h3>Description</h3>

<p>This function runs a permutation test to evaluate the effect of a subset of
covariates on the covariance matrix estimates. Returns an estimated
<em>p</em>-value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>significance.test(
  formula,
  data,
  params.rfsrc = list(ntree = 1000, mtry = ceiling(px/3), nsplit = max(round(n/50),
    10)),
  nodesize.set = round(0.5^(1:100) * round(0.632 * n))[round(0.5^(1:100) * round(0.632
    * n)) &gt; py],
  nperm = 500,
  test.vars = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="significance.test_+3A_formula">formula</code></td>
<td>
<p>Object of class <code>formula</code> or <code>character</code> describing
the model to fit. Interaction terms are not supported.</p>
</td></tr>
<tr><td><code id="significance.test_+3A_data">data</code></td>
<td>
<p>The multivariate data set which has <code class="reqn">n</code> observations and
<code class="reqn">px+py</code> variables where <code class="reqn">px</code> and <code class="reqn">py</code> are the number of
covariates (<code class="reqn">X</code>) and response variables (<code class="reqn">Y</code>), respectively. Should
be a data.frame.</p>
</td></tr>
<tr><td><code id="significance.test_+3A_params.rfsrc">params.rfsrc</code></td>
<td>
<p>List of parameters that should be passed to
<code>randomForestSRC</code>. In the default parameter set, <code>ntree</code> = 1000,
<code>mtry</code> = <code class="reqn">px/3</code>  (rounded up), <code>nsplit</code> =
<code class="reqn">max(round(n/50), 10)</code>. See <code>randomForestSRC</code> for possible
parameters.</p>
</td></tr>
<tr><td><code id="significance.test_+3A_nodesize.set">nodesize.set</code></td>
<td>
<p>The set of <code>nodesize</code> levels for tuning. Default set
includes the power of two times the sub-sample size (<code class="reqn">.632n</code>) greater
than the number of response variables (<code class="reqn">py</code>).</p>
</td></tr>
<tr><td><code id="significance.test_+3A_nperm">nperm</code></td>
<td>
<p>Number of permutations.</p>
</td></tr>
<tr><td><code id="significance.test_+3A_test.vars">test.vars</code></td>
<td>
<p>Subset of covariates whose effect on the covariance matrix
estimates will be evaluated. A character vector defining the names of the
covariates. The default is <code>NULL</code>, which tests for the global effect
of the whole set of covariates.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>(covregrf, significancetest)</code> which is a list
with the following components:
</p>
<table>
<tr><td><code>pvalue</code></td>
<td>
<p>Estimated *p*-value, see below for details.</p>
</td></tr>
<tr><td><code>best.nodesize</code></td>
<td>
<p>Best <code>nodesize</code> value selected with the proposed
tuning method using all covariates including the <code>test.vars</code>.</p>
</td></tr>
<tr><td><code>best.nodesize.control</code></td>
<td>
<p>Best <code>nodesize</code> value selected with the
proposed tuning method using only the set of controlling covariates. If
<code>test.vars</code> is <code>NULL</code>, returns <code>NULL</code>.</p>
</td></tr>
<tr><td><code>test.vars</code></td>
<td>
<p>Covariates whose effect on the covariance matrix estimates
is evaluated.</p>
</td></tr>
<tr><td><code>control.vars</code></td>
<td>
<p>Controlling set of covariates.</p>
</td></tr>
<tr><td><code>predicted.oob</code></td>
<td>
<p>OOB predicted covariance matrices for training
observations using all covariates including the <code>test.vars</code>.</p>
</td></tr>
<tr><td><code>predicted.perm</code></td>
<td>
<p>Predicted covariance matrices for the permutations
using all covariates including the <code>test.vars</code>. A list of
predictions for each permutation.</p>
</td></tr>
<tr><td><code>predicted.oob.control</code></td>
<td>
<p>OOB predicted covariance matrices for training
observations using only the set of controlling covariates. If
<code>test.vars</code> is <code>NULL</code>, returns <code>NULL</code>.</p>
</td></tr>
<tr><td><code>predicted.perm.control</code></td>
<td>
<p>Predicted covariance matrices for the
permutations using only the set of controlling covariates. If
<code>test.vars</code> is <code>NULL</code>, returns <code>NULL</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>We perform a hypothesis test to evaluate the effect of a subset of covariates
on the covariance matrix estimates, while controlling for the rest of the
covariates. Define the conditional covariance matrix of <code class="reqn">Y</code> given all
<code class="reqn">X</code> variables as <code class="reqn">\Sigma_{X}</code>, and the conditional covariance
matrix of <code class="reqn">Y</code> given only the set of controlling <code class="reqn">X</code> variables as
<code class="reqn">\Sigma_{X}^{c}</code>. If a subset of covariates has an effect on the
covariance matrix estimates obtained with the proposed method, then
<code class="reqn">\Sigma_{X}</code> should be significantly different from <code class="reqn">\Sigma_{X}^{c}</code>.
We conduct a permutation test for the null hypothesis
</p>
<p style="text-align: center;"><code class="reqn">H_0 : \Sigma_{X} = \Sigma_{X}^{c}</code>
</p>
<p> We estimate a
<code class="reqn">p</code>-value with the permutation test. If the <code class="reqn">p</code>-value is less than the
pre-specified significance level <code class="reqn">\alpha</code>, we reject the null
hypothesis.
</p>
<p>Testing the global effect of the covariates on the conditional covariance
estimates is a particular case of the proposed significance test. Define
the unconditional covariance matrix estimate of <code class="reqn">Y</code> as
<code class="reqn">\Sigma_{root}</code> which is computed as the sample covariance matrix of
<code class="reqn">Y</code>, and the conditional covariance matrix of <code class="reqn">Y</code> given <code class="reqn">X</code> as
<code class="reqn">\Sigma_{X}</code> which is obtained with <code>covregrf()</code>. If there is a
global effect of <code class="reqn">X</code> on the covariance matrix estimates, the
<code class="reqn">\Sigma_{X}</code> should be significantly different from <code class="reqn">\Sigma_{root}</code>.
The null hypothesis for this particular case is
</p>
<p style="text-align: center;"><code class="reqn">H_0 : \Sigma_{X} = \Sigma_{root}</code>
</p>



<h3>See Also</h3>

<p><code><a href="#topic+covregrf">covregrf</a></code>
<code><a href="#topic+predict.covregrf">predict.covregrf</a></code>
<code><a href="#topic+print.covregrf">print.covregrf</a></code>
</p>

<hr>
<h2 id='vimp.covregrf'>Variable importance for covregrf objects</h2><span id='topic+vimp.covregrf'></span><span id='topic+vimp'></span>

<h3>Description</h3>

<p>Calculates variable importance measures (VIMP) for covariates for training
data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'covregrf'
vimp(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vimp.covregrf_+3A_object">object</code></td>
<td>
<p>An object of class (covregrf, grow).</p>
</td></tr>
<tr><td><code id="vimp.covregrf_+3A_...">...</code></td>
<td>
<p>Optional arguments to be passed to other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>(covregrf, vimp)</code> which is a list with the
following component:
</p>
<table>
<tr><td><code>importance</code></td>
<td>
<p>Variable importance measures (VIMP) for covariates.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+plot.vimp.covregrf">plot.vimp.covregrf</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>options(rf.cores=2, mc.cores=2)

## load generated example data
data(data, package = "CovRegRF")
xvar.names &lt;- colnames(data$X)
yvar.names &lt;- colnames(data$Y)
data1 &lt;- data.frame(data$X, data$Y)

## define train/test split
set.seed(2345)
smp &lt;- sample(1:nrow(data1), size = round(nrow(data1)*0.6), replace = FALSE)
traindata &lt;- data1[smp,,drop=FALSE]
testdata &lt;- data1[-smp, xvar.names, drop=FALSE]

## formula object
formula &lt;- as.formula(paste(paste(yvar.names, collapse="+"), ".", sep=" ~ "))

## train covregrf
covregrf.obj &lt;- covregrf(formula, traindata, params.rfsrc = list(ntree = 50),
  importance = TRUE)

## get the variable importance measures
vimp &lt;- covregrf.obj$importance
vimp2 &lt;- vimp(covregrf.obj)$importance


</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
