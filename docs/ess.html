<!DOCTYPE html><html><head><title>Help for package ess</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {ess}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#ess-package'><p>ess: Eficient Stepwise Selection in Decomposable Models</p></a></li>
<li><a href='#adj_lst'><p>Adjacency List</p></a></li>
<li><a href='#adj_mat'><p>Adjacency Matrix</p></a></li>
<li><a href='#as_adj_lst'><p>Converts an adjacency matrix to an adjacency list</p></a></li>
<li><a href='#as_adj_mat'><p>Converts an adjacency list to an adjacency matrix</p></a></li>
<li><a href='#as_igraph'><p>Gengraph as igraph</p></a></li>
<li><a href='#components'><p>Finds the components of a graph</p></a></li>
<li><a href='#derma'><p>Dermatology Database</p></a></li>
<li><a href='#dfs'><p>Depth First Search</p></a></li>
<li><a href='#dgm_sim_from_graph'><p>Simulate observations from a decomposable graphical model</p></a></li>
<li><a href='#entropy'><p>Joint Entropy</p></a></li>
<li><a href='#fit_components'><p>Fit a decomposable graphical model on each component</p></a></li>
<li><a href='#fit_graph'><p>Fit a decomposable graphical model</p></a></li>
<li><a href='#gengraph'><p>A generic and extendable structure for decomposable graphical models</p></a></li>
<li><a href='#is_decomposable'><p>A test for decomposability in undirected graphs</p></a></li>
<li><a href='#make_complete_graph'><p>Make a complete graph</p></a></li>
<li><a href='#make_null_graph'><p>Make a null graph</p></a></li>
<li><a href='#mcs'><p>Maximum Cardinality Search</p></a></li>
<li><a href='#plot.gengraph'><p>Plot</p></a></li>
<li><a href='#print.gengraph'><p>Print</p></a></li>
<li><a href='#print.tree'><p>Print</p></a></li>
<li><a href='#rip'><p>Runnining Intersection Property</p></a></li>
<li><a href='#subgraph'><p>Subgraph</p></a></li>
<li><a href='#walk'><p>Stepwise model selection</p></a></li>
<li><a href='#walk.bwd'><p>Stepwise backward selection</p></a></li>
<li><a href='#walk.fwd'><p>Stepwise efficient forward selection in decomposable graphical models</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Efficient Stepwise Selection in Decomposable Models</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1.2</td>
</tr>
<tr>
<td>Description:</td>
<td>An implementation of the ESS algorithm following Amol Deshpande, Minos Garofalakis,
	     Michael I Jordan (2013) &lt;<a href="https://doi.org/10.48550/arXiv.1301.2267">doi:10.48550/arXiv.1301.2267</a>&gt;. The ESS algorithm
	     is used for model selection in decomposable graphical models.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/mlindsk/ess">https://github.com/mlindsk/ess</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp, igraph</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>Suggests:</td>
<td>tinytest</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/mlindsk/ess/issues">https://github.com/mlindsk/ess/issues</a></td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>C++11</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-05-31 07:07:42 UTC; mads</td>
</tr>
<tr>
<td>Author:</td>
<td>Mads Lindskou [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Mads Lindskou &lt;mads@math.aau.dk&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-05-31 07:40:08 UTC</td>
</tr>
</table>
<hr>
<h2 id='ess-package'>ess: Eficient Stepwise Selection in Decomposable Models</h2><span id='topic+ess'></span><span id='topic+ess-package'></span>

<h3>Description</h3>

<p>The class of graphical models is a family of probability
distributions for which conditional dependencies can be read off
from a graph. If the graph is decomposable, the maximum
likelihood estimates of the parameters in the model can be shown
to be on exact form. This is what enables ESS to be fast and
efficient for model selection in decomposable graphical models.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Mads Lindskou <a href="mailto:mads@math.aau.dk">mads@math.aau.dk</a>
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/mlindsk/ess">https://github.com/mlindsk/ess</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/mlindsk/ess/issues">https://github.com/mlindsk/ess/issues</a>
</p>
</li></ul>


<hr>
<h2 id='adj_lst'>Adjacency List</h2><span id='topic+adj_lst'></span><span id='topic+adj_lst.gengraph'></span>

<h3>Description</h3>

<p>Extracts the adjacency list of a <code>gengraph</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>adj_lst(x)

## S3 method for class 'gengraph'
adj_lst(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="adj_lst_+3A_x">x</code></td>
<td>
<p><code>gengraph</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>An adjacency list
</p>

<hr>
<h2 id='adj_mat'>Adjacency Matrix</h2><span id='topic+adj_mat'></span><span id='topic+adj_mat.gengraph'></span>

<h3>Description</h3>

<p>Extracts the adjacency matrix of a <code>gengraph</code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>adj_mat(x)

## S3 method for class 'gengraph'
adj_mat(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="adj_mat_+3A_x">x</code></td>
<td>
<p><code>gengraph</code> object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An adjacency matrix
</p>

<hr>
<h2 id='as_adj_lst'>Converts an adjacency matrix to an adjacency list</h2><span id='topic+as_adj_lst'></span>

<h3>Description</h3>

<p>Converts an adjacency matrix to an adjacency list
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_adj_lst(A)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as_adj_lst_+3A_a">A</code></td>
<td>
<p>Adjacency matrix</p>
</td></tr>
</table>

<hr>
<h2 id='as_adj_mat'>Converts an adjacency list to an adjacency matrix</h2><span id='topic+as_adj_mat'></span>

<h3>Description</h3>

<p>Converts an adjacency list to an adjacency matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_adj_mat(adj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as_adj_mat_+3A_adj">adj</code></td>
<td>
<p>Adjacency list</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An adjacency matrix
</p>


<h3>Examples</h3>

<pre><code class='language-R'>adj &lt;- list(a = c("b", "d"), b = c("a", "c", "d"), c = c("b", "d"), d = c("a", "c", "b"))
as_adj_mat(adj)
</code></pre>

<hr>
<h2 id='as_igraph'>Gengraph as igraph</h2><span id='topic+as_igraph'></span><span id='topic+as_igraph.gengraph'></span>

<h3>Description</h3>

<p>Convert a <code>gengraph</code> object to an <code>igraph</code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_igraph(x)

## S3 method for class 'gengraph'
as_igraph(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as_igraph_+3A_x">x</code></td>
<td>
<p><code>gengraph</code> object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code>igraph</code> object
</p>

<hr>
<h2 id='components'>Finds the components of a graph</h2><span id='topic+components'></span>

<h3>Description</h3>

<p>Finds the components of a graph
</p>


<h3>Usage</h3>

<pre><code class='language-R'>components(adj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="components_+3A_adj">adj</code></td>
<td>
<p>Adjacency list or <code>gengraph</code> object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list where the elements are the components of the graph
</p>

<hr>
<h2 id='derma'>Dermatology Database</h2><span id='topic+derma'></span>

<h3>Description</h3>

<p>This data set contains 358 observations (we have removed 8 with missing values).
It contains 12 clinical attributes and 21 histopathological attributes. The age
attribute has been discretized. The class variable &quot;ES&quot; has six levels; each
describing a skin disease.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>derma
</code></pre>


<h3>Format</h3>

<p>An object of class <code>tbl_df</code> (inherits from <code>tbl</code>, <code>data.frame</code>) with 358 rows and 35 columns.
</p>


<h3>References</h3>

<p><a href="https://archive.ics.uci.edu/ml/datasets/dermatology">Dermatology Data Set</a>
</p>

<hr>
<h2 id='dfs'>Depth First Search</h2><span id='topic+dfs'></span>

<h3>Description</h3>

<p>Finds the elements in the component of <code>root</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dfs(adj, root)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dfs_+3A_adj">adj</code></td>
<td>
<p>A named adjacency list of a decomposable grah</p>
</td></tr>
<tr><td><code id="dfs_+3A_root">root</code></td>
<td>
<p>The node from which the component should be found</p>
</td></tr>
</table>


<h3>Value</h3>

<p>All nodes connected to <code>root</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- list(a = c("b", "d"), b = c("a", "d"), c = c("b", "a"),
          d = c("e", "f"), e = c("d", "f"), f = c("d", "e"))
dfs(x, "a")
</code></pre>

<hr>
<h2 id='dgm_sim_from_graph'>Simulate observations from a decomposable graphical model</h2><span id='topic+dgm_sim_from_graph'></span>

<h3>Description</h3>

<p>Simulate observations from a decomposable graphical model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dgm_sim_from_graph(g, lvls, nsim = 1000, cell_rate = 0.5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dgm_sim_from_graph_+3A_g">g</code></td>
<td>
<p>An adjacency list</p>
</td></tr>
<tr><td><code id="dgm_sim_from_graph_+3A_lvls">lvls</code></td>
<td>
<p>Named list with levels of the discrete variables</p>
</td></tr>
<tr><td><code id="dgm_sim_from_graph_+3A_nsim">nsim</code></td>
<td>
<p>Number of simulations</p>
</td></tr>
<tr><td><code id="dgm_sim_from_graph_+3A_cell_rate">cell_rate</code></td>
<td>
<p>Control discrete cell probabilities</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a matrix of dimension where each row correspond
to a simulated observation from a DGM represented by <code>g</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
g = list(
  A = c("B", "X", "Y"),
  B = c("A", "Y"),
  X = c("A", "Y"),
  Y = c("A", "X", "B")
)

lvls &lt;- list(
  A = c("0", "1"),
  B = c("0", "1"),
  X = c("a", "b", "c"),
  Y = c("0", "1", "2")
)

dgm_sim_from_graph(g, lvls, nsim = 10)
#'
</code></pre>

<hr>
<h2 id='entropy'>Joint Entropy</h2><span id='topic+entropy'></span>

<h3>Description</h3>

<p>Calculates the joint entropy over discrete variables in <code>df</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>entropy(df, thres = 5, npc = new.env())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="entropy_+3A_df">df</code></td>
<td>
<p>data.frame</p>
</td></tr>
<tr><td><code id="entropy_+3A_thres">thres</code></td>
<td>
<p>A threshold mechanism for choosing between two different ways of
calculating the entropy. Can Speed up the procedure with the &quot;correct&quot; value.</p>
</td></tr>
<tr><td><code id="entropy_+3A_npc">npc</code></td>
<td>
<p>An environment. If supplied, the number of positive cells
in the underlying pmf will be stored in the environment with the name
<code>value</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A number representing the entropy of the variables in <code>df</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>entropy(derma[1:100, 1:3])

</code></pre>

<hr>
<h2 id='fit_components'>Fit a decomposable graphical model on each component</h2><span id='topic+fit_components'></span>

<h3>Description</h3>

<p>Structure learning in decomposable graphical models on
several components
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit_components(
  df,
  comp,
  type = "fwd",
  q = 0.5,
  trace = FALSE,
  thres = 5,
  wrap = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fit_components_+3A_df">df</code></td>
<td>
<p>Character data.frame</p>
</td></tr>
<tr><td><code id="fit_components_+3A_comp">comp</code></td>
<td>
<p>A list with character vectors. Each element in the list is a
component in the graph (using expert knowledge)</p>
</td></tr>
<tr><td><code id="fit_components_+3A_type">type</code></td>
<td>
<p>Character (&quot;fwd&quot;, &quot;bwd&quot;, &quot;tree&quot; or &quot;tfwd&quot;)</p>
</td></tr>
<tr><td><code id="fit_components_+3A_q">q</code></td>
<td>
<p>Penalty term in the stopping criterion
where <code>0</code> = AIC and <code>1</code> = BIC. Anything in between is
referred to as <code>qic</code></p>
</td></tr>
<tr><td><code id="fit_components_+3A_trace">trace</code></td>
<td>
<p>Logical indicating whether or not to trace the procedure</p>
</td></tr>
<tr><td><code id="fit_components_+3A_thres">thres</code></td>
<td>
<p>A threshold mechanism for choosing between two different ways of
calculating the entropy.</p>
</td></tr>
<tr><td><code id="fit_components_+3A_wrap">wrap</code></td>
<td>
<p>logical specifying if the result of a run with type = &quot;tree&quot;
should be converted to a &quot;fwd&quot; object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An adjacency list object
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fit_graph">fit_graph</a></code>, <code><a href="#topic+adj_lst.gengraph">adj_lst.gengraph</a></code>,
<code><a href="#topic+adj_mat.gengraph">adj_mat.gengraph</a></code>, <code><a href="#topic+walk.fwd">walk.fwd</a></code>,
<code><a href="#topic+walk.bwd">walk.bwd</a></code>, <code><a href="#topic+gengraph">gengraph</a></code>
</p>

<hr>
<h2 id='fit_graph'>Fit a decomposable graphical model</h2><span id='topic+fit_graph'></span>

<h3>Description</h3>

<p>A generic method for structure learning in decomposable
graphical models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit_graph(
  df,
  type = "fwd",
  q = 0.5,
  trace = FALSE,
  sparse_qic = FALSE,
  thres = 5,
  wrap = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fit_graph_+3A_df">df</code></td>
<td>
<p>Character data.frame</p>
</td></tr>
<tr><td><code id="fit_graph_+3A_type">type</code></td>
<td>
<p>Character (&quot;fwd&quot;, &quot;bwd&quot;, &quot;tree&quot; or &quot;tfwd&quot;)</p>
</td></tr>
<tr><td><code id="fit_graph_+3A_q">q</code></td>
<td>
<p>Penalty term in the stopping criterion
where <code>0</code> = AIC and <code>1</code> = BIC. Anything in between is
referred to as <code>qic</code></p>
</td></tr>
<tr><td><code id="fit_graph_+3A_trace">trace</code></td>
<td>
<p>Logical indicating whether or not to trace the procedure</p>
</td></tr>
<tr><td><code id="fit_graph_+3A_sparse_qic">sparse_qic</code></td>
<td>
<p>Logical. If <code>nrow(df)</code> is small, the tables
tends to be sparse. In these cases the usual penalty term of AIC and
BIC is often too restrictive. If <code>sparse_qic</code> is <code>TRUE</code>
this penality is computed according to a sparse criteria. The criteria
resembles the usual penalty as <code>nrow(df)</code> grows.</p>
</td></tr>
<tr><td><code id="fit_graph_+3A_thres">thres</code></td>
<td>
<p>A threshold mechanism for choosing between two different ways of
calculating the entropy.</p>
</td></tr>
<tr><td><code id="fit_graph_+3A_wrap">wrap</code></td>
<td>
<p>logical specifying if the result of a run with type = &quot;tree&quot;
should be converted to a &quot;fwd&quot; object</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The types are
</p>

<ul>
<li><p> &quot;fwd&quot;: forward selection
</p>
</li>
<li><p> &quot;bwd&quot;: backward selection
</p>
</li>
<li><p> &quot;tree&quot;: Chow-Liu tree (first order interactions only)
</p>
</li>
<li><p> &quot;tfwd&quot;: A combination of &quot;tree&quot; and &quot;fwd&quot;. This can speed up runtime considerably in high dimensions.
</p>
</li></ul>

<p>Using <code>adj_lst</code> on an object returned by <code>fit_graph</code> gives the
adjacency list corresponding to the graph. Similarly one can use <code>adj_mat</code>
to obtain an adjacency matrix. Applying the <code>rip</code> function on an
adjacency list returns the cliques and separators of the graph.
</p>


<h3>Value</h3>

<p>A <code>gengraph</code> object representing a decomposable graph.
</p>


<h3>References</h3>

<p><a href="https://arxiv.org/abs/1301.2267">https://arxiv.org/abs/1301.2267</a>, doi: <a href="https://doi.org/10.1109/ictai.2004.100">10.1109/ictai.2004.100</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+adj_lst">adj_lst</a></code>, <code><a href="#topic+adj_mat">adj_mat</a></code>,
<code><a href="#topic+as_igraph">as_igraph</a></code>, <code><a href="#topic+gengraph">gengraph</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
g &lt;- fit_graph(derma)
print(g)
plot(g)

# Adjacency matrix and adjacency list
adjm &lt;- adj_mat(g)
adjl &lt;- adj_lst(g)

</code></pre>

<hr>
<h2 id='gengraph'>A generic and extendable structure for decomposable graphical models</h2><span id='topic+gengraph'></span>

<h3>Description</h3>

<p>A generic structure for decomposable graphical models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gengraph(df, type = "fwd", q = 0.5, sparse_qic = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gengraph_+3A_df">df</code></td>
<td>
<p>Character data.frame</p>
</td></tr>
<tr><td><code id="gengraph_+3A_type">type</code></td>
<td>
<p>Character (&quot;fwd&quot;, &quot;bwd&quot;, &quot;tree&quot; or &quot;tfwd&quot;)</p>
</td></tr>
<tr><td><code id="gengraph_+3A_q">q</code></td>
<td>
<p>Penalty term in the stopping criterion
where <code>0</code> = AIC and <code>1</code> = BIC. Anything in between is
referred to as <code>qic</code></p>
</td></tr>
<tr><td><code id="gengraph_+3A_sparse_qic">sparse_qic</code></td>
<td>
<p>Logical. If <code>nrow(df)</code> is small, the tables
tends to be sparse. In these cases the usual penalty term of AIC and
BIC is often too restrictive. If <code>sparse_qic</code> is <code>TRUE</code>
this penality is computed according to a sparse criteria. The criteria
resembles the usual penalty as <code>nrow(df)</code> grows.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>gengraph</code> object with child class <code>type</code> used for model selection.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+adj_lst.gengraph">adj_lst.gengraph</a></code>, <code><a href="#topic+adj_mat.gengraph">adj_mat.gengraph</a></code>, <code><a href="#topic+fit_graph">fit_graph</a></code>, <code><a href="#topic+walk.fwd">walk.fwd</a></code>, <code><a href="#topic+walk.bwd">walk.bwd</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
gengraph(derma, type = "fwd")
gengraph(derma, type = "bwd")

</code></pre>

<hr>
<h2 id='is_decomposable'>A test for decomposability in undirected graphs</h2><span id='topic+is_decomposable'></span>

<h3>Description</h3>

<p>This function returns <code>TRUE</code> if the graph is decomposable and <code>FALSE</code> otherwise
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_decomposable(adj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_decomposable_+3A_adj">adj</code></td>
<td>
<p>Adjacency list of an undirected graph</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Logial describing whether or not <code>adj</code> is decomposable
</p>


<h3>Examples</h3>

<pre><code class='language-R'># 4-cycle:
adj &lt;- list(a = c("b", "d"), b = c("a", "c"), c = c("b", "d"), d = c("a", "c"))
is_decomposable(adj) # FALSE
# Two triangles:
adj2 &lt;- list(a = c("b", "d"), b = c("a", "c", "d"), c = c("b", "d"), d = c("a", "c", "b"))
is_decomposable(adj2) # TRUE
</code></pre>

<hr>
<h2 id='make_complete_graph'>Make a complete graph</h2><span id='topic+make_complete_graph'></span>

<h3>Description</h3>

<p>A helper function to make an adjacency list corresponding to a complete graph
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_complete_graph(nodes)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_complete_graph_+3A_nodes">nodes</code></td>
<td>
<p>A character vector containing the nodes to be used in the graph</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An adjacency list of a complete graph
</p>


<h3>Examples</h3>

<pre><code class='language-R'>d  &lt;- derma[, 5:8]
cg &lt;- make_complete_graph(colnames(d))
</code></pre>

<hr>
<h2 id='make_null_graph'>Make a null graph</h2><span id='topic+make_null_graph'></span>

<h3>Description</h3>

<p>A helper function to make an adjacency list corresponding to a null graph (no edges)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_null_graph(nodes)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_null_graph_+3A_nodes">nodes</code></td>
<td>
<p>A character vector containing the nodes to be used in the graph</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An adjacency list the null graph with no edges
</p>


<h3>Examples</h3>

<pre><code class='language-R'>d  &lt;- derma[, 5:8]
ng &lt;- make_null_graph(colnames(d))
</code></pre>

<hr>
<h2 id='mcs'>Maximum Cardinality Search</h2><span id='topic+mcs'></span>

<h3>Description</h3>

<p>Maximum Cardinality Search
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mcs(adj, check = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mcs_+3A_adj">adj</code></td>
<td>
<p>A named adjacency list of a decomposable graph</p>
</td></tr>
<tr><td><code id="mcs_+3A_check">check</code></td>
<td>
<p>Boolean: check if adj is decomposable</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If adj is not the adjacency list of a decomposable graph an error is raised
</p>


<h3>Value</h3>

<p>A list with a perfect numbering of the nodes and a perfect sequence of sets
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- list(a = c("b", "d"), b = c("a", "c", "d"), c = c("b", "d"), d = c("a", "c", "b"))
mcs(x)
</code></pre>

<hr>
<h2 id='plot.gengraph'>Plot</h2><span id='topic+plot.gengraph'></span>

<h3>Description</h3>

<p>A wrapper around igraphs plot method for <code>gengraph</code> objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gengraph'
plot(x, vc = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.gengraph_+3A_x">x</code></td>
<td>
<p>A <code>gengraph</code> object</p>
</td></tr>
<tr><td><code id="plot.gengraph_+3A_vc">vc</code></td>
<td>
<p>Named character vector; the names are the vertices and
the elements are the colors of the nodes</p>
</td></tr>
<tr><td><code id="plot.gengraph_+3A_...">...</code></td>
<td>
<p>Extra arguments. See the igraph package</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, called for side effects
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
d &lt;- derma[, 10:25]
g &lt;- fit_graph(d)
vs &lt;- colnames(d)
vcol &lt;- structure(vector("character", length(vs)), names = vs)
vcol[1:4]  &lt;- "lightsteelblue2"
vcol[5:7]  &lt;- "orange"
vcol[8:16] &lt;- "pink"
plot(g, vcol)
</code></pre>

<hr>
<h2 id='print.gengraph'>Print</h2><span id='topic+print.gengraph'></span>

<h3>Description</h3>

<p>A print method for <code>gengraph</code> objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gengraph'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.gengraph_+3A_x">x</code></td>
<td>
<p>A <code>gengraph</code> object</p>
</td></tr>
<tr><td><code id="print.gengraph_+3A_...">...</code></td>
<td>
<p>Not used (for S3 compatability)</p>
</td></tr>
</table>

<hr>
<h2 id='print.tree'>Print</h2><span id='topic+print.tree'></span>

<h3>Description</h3>

<p>A print method for <code>tree</code> objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'tree'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.tree_+3A_x">x</code></td>
<td>
<p>A <code>tree</code> object</p>
</td></tr>
<tr><td><code id="print.tree_+3A_...">...</code></td>
<td>
<p>Not used (for S3 compatability)</p>
</td></tr>
</table>

<hr>
<h2 id='rip'>Runnining Intersection Property</h2><span id='topic+rip'></span>

<h3>Description</h3>

<p>Given a decomposable graph, this functions finds a perfect numbering on the vertices using maximum cardinality search, and hereafter returns a list with two elements: &quot;C&quot; - A RIP-ordering of the cliques and &quot;S&quot; - A RIP ordering of the separators.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rip(adj, check = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rip_+3A_adj">adj</code></td>
<td>
<p>A named adjacency list of a decomposable graph</p>
</td></tr>
<tr><td><code id="rip_+3A_check">check</code></td>
<td>
<p>Boolean: check if adj is decomposable</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with cliques and separators of <code>adj</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mcs">mcs</a></code>, <code><a href="#topic+is_decomposable">is_decomposable</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- list(a = c("b", "d"), b = c("a", "c", "d"), c = c("b", "d"), d = c("a", "c", "b"))
y &lt;- rip(x)
# Cliques:
y$C
# Separators:
y$S
</code></pre>

<hr>
<h2 id='subgraph'>Subgraph</h2><span id='topic+subgraph'></span>

<h3>Description</h3>

<p>Construct a subgraph with a given set of nodes removed
</p>


<h3>Usage</h3>

<pre><code class='language-R'>subgraph(x, g)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="subgraph_+3A_x">x</code></td>
<td>
<p>Character vector of nodes</p>
</td></tr>
<tr><td><code id="subgraph_+3A_g">g</code></td>
<td>
<p>Adjacency list (named) or a adjacency matrix with dimnames given as the nodes</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An adjacency list or adjacency matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>adj &lt;- list(a = c("b", "d"), b = c("a", "c", "d"), c = c("b", "d"), d = c("a", "c", "b"))
d &lt;- data.frame(a = "", b = "", c ="", d = "") # Toy data so we can plot the graph
subgraph(c("c", "b"), adj)
subgraph(c("b", "d"), as_adj_mat(adj))
</code></pre>

<hr>
<h2 id='walk'>Stepwise model selection</h2><span id='topic+walk'></span>

<h3>Description</h3>

<p>Stepwise model selection in decomposable graphical models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>walk(x, df, q, thres)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="walk_+3A_x">x</code></td>
<td>
<p><code>fwd</code> or <code>bwd</code> objects</p>
</td></tr>
<tr><td><code id="walk_+3A_df">df</code></td>
<td>
<p>data.frame</p>
</td></tr>
<tr><td><code id="walk_+3A_q">q</code></td>
<td>
<p>Penalty term in the stopping criterion  (<code>0</code> = AIC and <code>1</code> = BIC)</p>
</td></tr>
<tr><td><code id="walk_+3A_thres">thres</code></td>
<td>
<p>A threshold mechanism for choosing between two different ways of calculating the entropy. Can Speed up the procedure with the &quot;correct&quot; value.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A <code>fwd</code> (or <code>bwd</code>) object can be created using the <code>gengraph</code> constructor with <code>type = "fwd"</code>.
</p>


<h3>Value</h3>

<p>A <code>fwd</code> or <code>bwd</code> object with one additional edge than the input object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fit_graph">fit_graph</a></code>, <code><a href="#topic+walk.fwd">walk.fwd</a></code>, <code><a href="#topic+gengraph">gengraph</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
d &lt;- derma[, 10:25]

g &lt;- gengraph(d, type = "fwd")
s &lt;- walk(g, d)
print(s)
plot(s)
adj_lst(s)
adj_mat(s)

</code></pre>

<hr>
<h2 id='walk.bwd'>Stepwise backward selection</h2><span id='topic+walk.bwd'></span>

<h3>Description</h3>

<p>Stepwise backward selection in decomposable graphical models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bwd'
walk(x, df, q = 0.5, thres = 5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="walk.bwd_+3A_x">x</code></td>
<td>
<p><code>gengraph</code></p>
</td></tr>
<tr><td><code id="walk.bwd_+3A_df">df</code></td>
<td>
<p>data.frame</p>
</td></tr>
<tr><td><code id="walk.bwd_+3A_q">q</code></td>
<td>
<p>Penalty term in the stopping criterion  (<code>0</code> = AIC and <code>1</code> = BIC)</p>
</td></tr>
<tr><td><code id="walk.bwd_+3A_thres">thres</code></td>
<td>
<p>A threshold mechanism for choosing between two different ways of calculating
the entropy. Can Speed up the procedure with the &quot;correct&quot; value.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A <code>bwd</code> object can be created using the <code>gengraph</code> constructor with <code>type = "bwd"</code>
</p>


<h3>Value</h3>

<p>A <code>bwd</code> object; a subclass of <code>gengraph</code>) used for backward selection.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fit_graph">fit_graph</a></code>, <code><a href="#topic+walk.fwd">walk.fwd</a></code>, <code><a href="#topic+gengraph">gengraph</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
d &lt;- derma[, 10:25]

g &lt;- gengraph(d, type = "bwd")
s &lt;- walk(g, d)
print(s)
plot(s)
adj_lst(s)
adj_mat(s)

</code></pre>

<hr>
<h2 id='walk.fwd'>Stepwise efficient forward selection in decomposable graphical models</h2><span id='topic+walk.fwd'></span>

<h3>Description</h3>

<p>Stepwise efficient forward selection in decomposable graphical models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fwd'
walk(x, df, q = 0.5, thres = 5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="walk.fwd_+3A_x">x</code></td>
<td>
<p>A <code>fwd</code> object</p>
</td></tr>
<tr><td><code id="walk.fwd_+3A_df">df</code></td>
<td>
<p>data.frame</p>
</td></tr>
<tr><td><code id="walk.fwd_+3A_q">q</code></td>
<td>
<p>Penalty term in the stopping criterion  (<code>0</code> = AIC and <code>1</code> = BIC)</p>
</td></tr>
<tr><td><code id="walk.fwd_+3A_thres">thres</code></td>
<td>
<p>A threshold mechanism for choosing between two different ways of calculating the entropy. Can Speed up the procedure with the &quot;correct&quot; value.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A <code>fwd</code> object can be created using the <code>gengraph</code> constructor with <code>type = "fwd"</code>
</p>


<h3>Value</h3>

<p>A <code>fwd</code> object; a subclass of <code>gengraph</code>) used for forward selection.
</p>


<h3>References</h3>

<p><a href="https://arxiv.org/abs/1301.2267">https://arxiv.org/abs/1301.2267</a>, doi: <a href="https://doi.org/10.1109/ictai.2004.100">10.1109/ictai.2004.100</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fit_graph">fit_graph</a></code>, <code><a href="#topic+walk.bwd">walk.bwd</a></code>, <code><a href="#topic+gengraph">gengraph</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
d &lt;- derma[, 10:25]

g &lt;- gengraph(d, type = "fwd")
s &lt;- walk(g, d)
print(s)
plot(s)
adj_lst(s)
adj_mat(s)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
