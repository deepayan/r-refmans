<!DOCTYPE html><html><head><title>Help for package sharpshootR</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {sharpshootR}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#sharpshootR-package'><p>A collection of functions to support soil survey</p></a></li>
<li><a href='#aggregateColorPlot'><p>Plot aggregate soil color data</p></a></li>
<li><a href='#amador'><p>SSURGO Data Associated with the Amador Soil Series</p></a></li>
<li><a href='#aspect.plot'><p>Plot Aspect Data</p></a></li>
<li><a href='#CDEC_StationInfo'><p>CDEC Sensor Details (by Station)</p></a></li>
<li><a href='#CDEC.snow.courses'><p>CDEC Snow Course List</p></a></li>
<li><a href='#CDECquery'><p>Easy Access to the CDEC API</p></a></li>
<li><a href='#CDECsnowQuery'><p>Get snow survey data (California only) from the CDEC website.</p></a></li>
<li><a href='#colorMixtureVenn'><p>Create a Venn Diagram of Simulated Color Mixtures</p></a></li>
<li><a href='#component.adj.matrix'><p>Create an adjacency matrix from a data.frame of component data</p></a></li>
<li><a href='#constantDensitySampling'><p>Constant Density Sampling</p></a></li>
<li><a href='#dailyWB'><p>Simple Daily Water Balance</p></a></li>
<li><a href='#dailyWB_SSURGO'><p>Perform daily water balance modeling using SSURGO and DAYMET</p></a></li>
<li><a href='#diagnosticPropertyPlot'><p>Diagnostic Property Plot (base graphics)</p></a></li>
<li><a href='#diagnosticPropertyPlot2'><p>Diagnostic Property Plot (lattice)</p></a></li>
<li><a href='#dist.along.grad'><p>Compute Euclidean distance along a gradient.</p></a></li>
<li><a href='#dueling.dendrograms'><p>Dueling Dendrograms</p></a></li>
<li><a href='#ESS_by_Moran_I'><p>Estimate Effective Sample Size</p></a></li>
<li><a href='#estimateSoilMoistureState'><p>A very simple estimation of soil moisture state based on volumetric water content</p></a></li>
<li><a href='#FFD'><p>Frost-Free Day Evaluation</p></a></li>
<li><a href='#FFDplot'><p>Plot output from FFD()</p></a></li>
<li><a href='#formatPLSS'><p>formatPLSS</p></a></li>
<li><a href='#generateLineHash'><p>Generate a unique ID for line segments</p></a></li>
<li><a href='#geomorphBySoilSeries-SSURGO'><p>Geomorphic Position Probability via SDA</p></a></li>
<li><a href='#HenryTimeLine'><p>Sensor Data Timeline from Henry Mount Soil and Water DB</p></a></li>
<li><a href='#HHM'><p>Highland Meadows</p></a></li>
<li><a href='#huePositionPlot'><p>Hue Position Chart</p></a></li>
<li><a href='#hydOrder'><p>Hydrologic Ordering of a Geomorphic Proportion Matrix</p></a></li>
<li><a href='#isMineralSoilMaterial'><p>Mineral Soil Material Criteria from 12th Ed. of KST</p></a></li>
<li><a href='#iterateHydOrder'><p>Iteratively Attempt Hydrologic Ordering of Geomorphic Proportion Matrix</p></a></li>
<li><a href='#joinAdjacency'><p>Join Document Adjacency</p></a></li>
<li><a href='#LL2PLSS'><p>LL2PLSS</p></a></li>
<li><a href='#moistureStateProportions'><p>Compute moisture state proportions</p></a></li>
<li><a href='#moistureStateStats'><p>Statistics on Soil Moisture State</p></a></li>
<li><a href='#moistureStateThreshold'><p>Apply a threshold to soil moisture states</p></a></li>
<li><a href='#monthlyWB'><p>Monthly Water Balances</p></a></li>
<li><a href='#monthlyWB_summary'><p>Water Balance Summaries</p></a></li>
<li><a href='#Moran_I_ByRaster'><p>Compute Moran's I for a raster sampled from a mapunit extent</p></a></li>
<li><a href='#multinominal2logical'><p>Convert Multinominal to Logical Matrix</p></a></li>
<li><a href='#OSDexamples'><p>Example output from soilDB::fetchOSD()</p></a></li>
<li><a href='#PCP_plot'><p>Percentiles of Cumulative Precipitation</p></a></li>
<li><a href='#percentileDemo'><p>Demonstration of Percentiles vs. Mean / SD</p></a></li>
<li><a href='#plotAvailWater'><p>Visual Demonstration of Available Soil Water</p></a></li>
<li><a href='#plotGeomorphCrossSection'><p>Present a <code>SoilProfileCollection</code> aligned to a geomorphic summary as cross-section.</p></a></li>
<li><a href='#plotProfileDendrogram'><p>Plot soil profiles below a dendrogram</p></a></li>
<li><a href='#plotSoilRelationChordGraph'><p>Visualize Soil Relationships via Chord Diagram</p></a></li>
<li><a href='#plotSoilRelationGraph'><p>Plot a component relation graph</p></a></li>
<li><a href='#plotTransect'><p>Arrange Profiles along a Transect</p></a></li>
<li><a href='#plotWB'><p>Visualize Monthly Water Balance</p></a></li>
<li><a href='#plotWB_lines'><p>Line / Area Visualization for Monthly Water Balance</p></a></li>
<li><a href='#PLSS2LL'><p>PLSS2LL</p></a></li>
<li><a href='#polygonAdjacency'><p>Summarize Spatial Adjacency of Polygon Fabric</p></a></li>
<li><a href='#prepare_SSURGO_hydro_data'><p>Get and prepare basic soil hydraulic parameters from SSURGO via SDA</p></a></li>
<li><a href='#prepareDailyClimateData'><p>Prepare daily climate data (DAYMET) for a single point</p></a></li>
<li><a href='#reconcileOSDGeomorph'><p>Reconcile IDs between a SPC and associated geomorphic proportion table</p></a></li>
<li><a href='#sample.by.poly'><p>Sample a Polygon at Fixed Density</p></a></li>
<li><a href='#sampleRasterStackByMU'><p>Sample a Raster Stack</p></a></li>
<li><a href='#samplingStability'><p>Estimate Sampling Stability</p></a></li>
<li><a href='#simpleWB'><p>Simple interface to the hydromad &quot;leaky bucket&quot; soil moisture model</p></a></li>
<li><a href='#site_photos_kml'><p>site_photos_kml</p></a></li>
<li><a href='#SoilTaxonomyDendrogram'><p>Soil Taxonomy Dendrogram</p></a></li>
<li><a href='#table5.2'><p>Table 5.2 from Hole and Campbell, 1985.</p></a></li>
<li><a href='#vizAnnualClimate'><p>Annual Climate Summaries for Soil Series Data</p></a></li>
<li><a href='#vizFlatsPosition'><p>Visual Summary of Flat Landform Positions</p></a></li>
<li><a href='#vizGeomorphicComponent'><p>Visual Summary of Hill Landform Positions</p></a></li>
<li><a href='#vizHillslopePosition'><p>Visual Summary of Hillslope Position</p></a></li>
<li><a href='#vizMountainPosition'><p>Visual Summary of Mountain Slope Positions</p></a></li>
<li><a href='#vizSurfaceShape'><p>Visual Summary of Surface Shape</p></a></li>
<li><a href='#vizTerracePosition'><p>Visual Summary of Terraced Landform Positions</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Title:</td>
<td>A Soil Survey Toolkit</td>
</tr>
<tr>
<td>Description:</td>
<td>Miscellaneous soil data management, summary, visualization, and conversion utilities to support soil survey.</td>
</tr>
<tr>
<td>Version:</td>
<td>2.3</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-04-08</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Dylan Beaudette &lt;dylan.beaudette@usda.gov&gt;</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/ncss-tech/sharpshootR">https://github.com/ncss-tech/sharpshootR</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/ncss-tech/sharpshootR/issues">https://github.com/ncss-tech/sharpshootR/issues</a></td>
</tr>
<tr>
<td>Suggests:</td>
<td>MASS, spdep, circlize, rvest, xml2, terra, raster,
exactextractr, httr, jsonlite, igraph, dendextend, testthat,
hydromad (&ge; 0.9.27), latticeExtra, farver, venn, gower,
daymetr, elevatr, Evapotranspiration, zoo, SoilTaxonomy, sf,
Hmisc, knitr</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>grDevices, graphics, methods, stats, utils, aqp, ape, soilDB,
cluster, lattice, vegan, reshape2, scales, circular,
RColorBrewer, plyr, digest, e1071, stringi, parallel, curl,
grid</td>
</tr>
<tr>
<td>Additional_repositories:</td>
<td><a href="https://hydromad.github.io">https://hydromad.github.io</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-04-08 19:03:46 UTC; Dylan.Beaudette</td>
</tr>
<tr>
<td>Author:</td>
<td>Dylan Beaudette [cre, aut],
  Jay Skovlin [aut],
  Stephen Roecker [aut],
  Andrew Brown [aut],
  USDA-NRCS Soil Survey Staff [ctb]</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-04-08 19:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='sharpshootR-package'>A collection of functions to support soil survey</h2><span id='topic+sharpshootR-package'></span><span id='topic+sharpshootR'></span>

<h3>Description</h3>

<p>This package contains mish-mash of functionality and sample data related to the daily business of soil survey operations with the USDA-NRCS. Many of the functions are highly specialized and inherit default arguments from the names used by the various NCSS (National Cooperative Soil Survey) databases. A detailed description of this package with links to associated tutorials can be found at the <a href="https://github.com/ncss-tech/sharpshootR">project website</a>.</p>

<hr>
<h2 id='aggregateColorPlot'>Plot aggregate soil color data</h2><span id='topic+aggregateColorPlot'></span>

<h3>Description</h3>

<p>Generate a plot from summaries generated by <code>aqp::aggregateColor()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>aggregateColorPlot(
  x,
  print.label = TRUE,
  label.font = 1,
  label.cex = 0.65,
  label.orientation = c("v", "h"),
  buffer.pct = 0.02,
  print.n.hz = FALSE,
  rect.border = "black",
  horizontal.borders = FALSE,
  horizontal.border.lwd = 2,
  x.axis = TRUE,
  y.axis = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="aggregateColorPlot_+3A_x">x</code></td>
<td>
<p>a <code>list</code>, results from <code>aqp::aggregateColor()</code></p>
</td></tr>
<tr><td><code id="aggregateColorPlot_+3A_print.label">print.label</code></td>
<td>
<p>logical, print Munsell color labels inside of rectangles, only if they fit</p>
</td></tr>
<tr><td><code id="aggregateColorPlot_+3A_label.font">label.font</code></td>
<td>
<p>font specification for color labels</p>
</td></tr>
<tr><td><code id="aggregateColorPlot_+3A_label.cex">label.cex</code></td>
<td>
<p>font size for color labels</p>
</td></tr>
<tr><td><code id="aggregateColorPlot_+3A_label.orientation">label.orientation</code></td>
<td>
<p>label orientation, <code>v</code> for vertical or <code>h</code> for horizontal</p>
</td></tr>
<tr><td><code id="aggregateColorPlot_+3A_buffer.pct">buffer.pct</code></td>
<td>
<p>extra space between labels and color rectangles</p>
</td></tr>
<tr><td><code id="aggregateColorPlot_+3A_print.n.hz">print.n.hz</code></td>
<td>
<p>optionally print the number of horizons below Munsell color labels</p>
</td></tr>
<tr><td><code id="aggregateColorPlot_+3A_rect.border">rect.border</code></td>
<td>
<p>color for rectangle border</p>
</td></tr>
<tr><td><code id="aggregateColorPlot_+3A_horizontal.borders">horizontal.borders</code></td>
<td>
<p>optionally add horizontal borders between bands of color</p>
</td></tr>
<tr><td><code id="aggregateColorPlot_+3A_horizontal.border.lwd">horizontal.border.lwd</code></td>
<td>
<p>line width for horizontal borders</p>
</td></tr>
<tr><td><code id="aggregateColorPlot_+3A_x.axis">x.axis</code></td>
<td>
<p>logical, add a scale and label to x-axis?</p>
</td></tr>
<tr><td><code id="aggregateColorPlot_+3A_y.axis">y.axis</code></td>
<td>
<p>logical, add group labels to y-axis?</p>
</td></tr>
<tr><td><code id="aggregateColorPlot_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code>plot</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Tutorial at <a href="http://ncss-tech.github.io/AQP/sharpshootR/aggregate-soil-color.html">http://ncss-tech.github.io/AQP/sharpshootR/aggregate-soil-color.html</a>.
</p>


<h3>Value</h3>

<p>nothing, function called for graphical output
</p>


<h3>Author(s)</h3>

<p>D.E. Beaudette
</p>


<h3>Examples</h3>

<pre><code class='language-R'>


if(require(aqp) &amp;
   require(soilDB)) {
  
  data(loafercreek, package = 'soilDB')
  
  # generalize horizon names using REGEX rules
  n &lt;- c('Oi', 'A', 'BA','Bt1','Bt2','Bt3','Cr','R')
  p &lt;- c('O', '^A$|Ad|Ap|AB','BA$|Bw', 
         'Bt1$|^B$','^Bt$|^Bt2$','^Bt3|^Bt4|CBt$|BCt$|2Bt|2CB$|^C$','Cr','R')
  loafercreek$genhz &lt;- generalize.hz(loafercreek$hzname, n, p)
  
  # remove non-matching generalized horizon names
  loafercreek$genhz[loafercreek$genhz == 'not-used'] &lt;- NA
  loafercreek$genhz &lt;- factor(loafercreek$genhz)
  
  # aggregate color data, this function is from the `aqp` package
  a &lt;- aggregateColor(loafercreek, 'genhz')
  
  # plot
  op &lt;- par(no.readonly = TRUE)
  
  par(mar=c(4,4,1,1))
  
  # vertical labels, the default
  aggregateColorPlot(a, print.n.hz = TRUE)
  
  # horizontal labels
  aggregateColorPlot(a, print.n.hz = TRUE, label.orientation = 'h')
  
  par(op)
  
}


</code></pre>

<hr>
<h2 id='amador'>SSURGO Data Associated with the Amador Soil Series</h2><span id='topic+amador'></span>

<h3>Description</h3>

<p>SSURGO Data Associated with the Amador Soil Series</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(amador)</code></pre>


<h3>Format</h3>

<p>A subset of data taken from the &quot;component&quot; table of SSURGO
</p>

<dl>
<dt><code>mukey</code></dt><dd><p>map unit key</p>
</dd>
<dt><code>compname</code></dt><dd><p>component name</p>
</dd>
<dt><code>comppct_r</code></dt><dd><p>component percentage</p>
</dd>
</dl>



<h3>Source</h3>

<p>USDA-NRCS SSURGO Database</p>

<hr>
<h2 id='aspect.plot'>Plot Aspect Data</h2><span id='topic+aspect.plot'></span>

<h3>Description</h3>

<p>Plot a graphical summary of multiple aspect measurements on a circular diagram.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>aspect.plot(
  p,
  q = c(0.05, 0.5, 0.95),
  p.bins = 60,
  p.bw = 30,
  stack = TRUE,
  p.axis = seq(0, 350, by = 10),
  plot.title = NULL,
  line.col = "RoyalBlue",
  line.lwd = 1,
  line.lty = 2,
  arrow.col = line.col,
  arrow.lwd = 1,
  arrow.lty = 1,
  arrow.length = 0.15,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="aspect.plot_+3A_p">p</code></td>
<td>
<p>a vector of aspect angles in degrees, measured clock-wise from North</p>
</td></tr>
<tr><td><code id="aspect.plot_+3A_q">q</code></td>
<td>
<p>a vector of desired quantiles</p>
</td></tr>
<tr><td><code id="aspect.plot_+3A_p.bins">p.bins</code></td>
<td>
<p>number of bins to use for circular histogram</p>
</td></tr>
<tr><td><code id="aspect.plot_+3A_p.bw">p.bw</code></td>
<td>
<p>bandwidth used for circular density estimation</p>
</td></tr>
<tr><td><code id="aspect.plot_+3A_stack">stack</code></td>
<td>
<p><code>logical</code>, should the individual points be stacked into <code>p.bins</code> number of bins and plotted</p>
</td></tr>
<tr><td><code id="aspect.plot_+3A_p.axis">p.axis</code></td>
<td>
<p>a sequence of integers (degrees) describing the circular axis</p>
</td></tr>
<tr><td><code id="aspect.plot_+3A_plot.title">plot.title</code></td>
<td>
<p>an informative title</p>
</td></tr>
<tr><td><code id="aspect.plot_+3A_line.col">line.col</code></td>
<td>
<p>density line color</p>
</td></tr>
<tr><td><code id="aspect.plot_+3A_line.lwd">line.lwd</code></td>
<td>
<p>density line width</p>
</td></tr>
<tr><td><code id="aspect.plot_+3A_line.lty">line.lty</code></td>
<td>
<p>density line line style</p>
</td></tr>
<tr><td><code id="aspect.plot_+3A_arrow.col">arrow.col</code></td>
<td>
<p>arrow color</p>
</td></tr>
<tr><td><code id="aspect.plot_+3A_arrow.lwd">arrow.lwd</code></td>
<td>
<p>arrow line width</p>
</td></tr>
<tr><td><code id="aspect.plot_+3A_arrow.lty">arrow.lty</code></td>
<td>
<p>arrow line style</p>
</td></tr>
<tr><td><code id="aspect.plot_+3A_arrow.length">arrow.length</code></td>
<td>
<p>arrow head length</p>
</td></tr>
<tr><td><code id="aspect.plot_+3A_...">...</code></td>
<td>
<p>further arguments passed to <code>circular::plot.circular</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Spread and central tendency are depicted with a combination of circular histogram and kernel density estimate. The circular mean, and relative confidence in that mean are depicted with an arrow: longer arrow lengths correspond to greater confidence in the mean.
</p>


<h3>Value</h3>

<p>invisibly returns circular stats
</p>


<h3>Note</h3>

<p>Manual adjustment of <code>p.bw</code> may be required in order to get an optimal circular density plot. This function requires the package <code>circular</code>, version 0.4-7 or later.
</p>


<h3>Author(s)</h3>

<p>D.E. Beaudette
</p>


<h3>Examples</h3>

<pre><code class='language-R'># simulate some data
p.narrow &lt;- runif(n=25, min=215, max=280)
p.wide &lt;- runif(n=25, min=0, max=270)

# set figure margins to 0, 2-column plot
op &lt;- par(no.readonly = TRUE)
par(mar = c(0,0,0,0), mfcol = c(1,2))

# plot, save circular stats 
x &lt;- aspect.plot(p.narrow, p.bw=10, plot.title='Soil A', pch=21, col='black', bg='RoyalBlue')
y &lt;- aspect.plot(p.wide, p.bw=10, plot.title='Soil B', pch=21, col='black', bg='RoyalBlue')

# reset output device options
par(op) 

x


</code></pre>

<hr>
<h2 id='CDEC_StationInfo'>CDEC Sensor Details (by Station)</h2><span id='topic+CDEC_StationInfo'></span>

<h3>Description</h3>

<p>Query CDEC Website for Sensor Details
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CDEC_StationInfo(s)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CDEC_StationInfo_+3A_s">s</code></td>
<td>
<p>character, a single CDEC station ID (e.g. 'HHM')</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function requires the <code>rvest</code> package.
</p>


<h3>Value</h3>

<p>A <code>list</code> object containing site metadata, sensor metadata, and possibly comments about the site.
</p>


<h3>Author(s)</h3>

<p>D.E. Beaudette
</p>


<h3>See Also</h3>

<p><code style="white-space: pre;">&#8288;[CDECquery]&#8288;</code>
</p>

<hr>
<h2 id='CDEC.snow.courses'>CDEC Snow Course List</h2><span id='topic+CDEC.snow.courses'></span>

<h3>Description</h3>

<p>The CDEC snow course list, updated September 2019</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(CDEC.snow.courses)</code></pre>


<h3>Format</h3>

<p>A data frame with 259 observations on the following 9 variables.
</p>

<dl>
<dt><code>course_number</code></dt><dd><p>course number</p>
</dd>
<dt><code>name</code></dt><dd><p>connotative course label</p>
</dd>
<dt><code>id</code></dt><dd><p>course ID</p>
</dd>
<dt><code>elev_feet</code></dt><dd><p>course elevation in feet</p>
</dd>
<dt><code>latitude</code></dt><dd><p>latitude</p>
</dd>
<dt><code>longitude</code></dt><dd><p>longitude</p>
</dd>
<dt><code>april.1.Avg.inches</code></dt><dd><p>average inches of snow as of April 1st</p>
</dd>
<dt><code>agency</code></dt><dd><p>responsible agency</p>
</dd>
<dt><code>watershed</code></dt><dd><p>watershed label</p>
</dd>
</dl>



<h3>Source</h3>

<p>Data were scraped from <a href="http://cdec.water.ca.gov/misc/SnowCourses.html">http://cdec.water.ca.gov/misc/SnowCourses.html</a>, 2019.</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(CDEC.snow.courses)
head(CDEC.snow.courses)
</code></pre>

<hr>
<h2 id='CDECquery'>Easy Access to the CDEC API</h2><span id='topic+CDECquery'></span>

<h3>Description</h3>

<p>A (relatively) simple interface to the CDEC website.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CDECquery(id, sensor, interval = "D", start, end)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CDECquery_+3A_id">id</code></td>
<td>
<p>station ID (e.g. 'spw'), single value or vector of station IDs, see details</p>
</td></tr>
<tr><td><code id="CDECquery_+3A_sensor">sensor</code></td>
<td>
<p>the sensor ID, single value or vector of sensor numbers, see details</p>
</td></tr>
<tr><td><code id="CDECquery_+3A_interval">interval</code></td>
<td>
<p>character, 'D' for daily, 'H' for hourly, 'M' for monthly, 'E' for event: see Details.</p>
</td></tr>
<tr><td><code id="CDECquery_+3A_start">start</code></td>
<td>
<p>starting date, in the format 'YYYY-MM-DD'</p>
</td></tr>
<tr><td><code id="CDECquery_+3A_end">end</code></td>
<td>
<p>ending date, in the format 'YYYY-MM-DD'</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Sensors that report data on an <code>interval</code> other than monthly ('M'), daily ('D'), or hourly ('H') can be queried with an <code>event</code> interval ('E'). Soil moisture and temperature sensors are an example of this type of reporting. See examples below.
</p>

<dl>
<dt>1.</dt><dd><p>Station IDs can be found here: <a href="http://cdec.water.ca.gov/staInfo.html">http://cdec.water.ca.gov/staInfo.html</a></p>
</dd>
<dt>2a.</dt><dd><p>Sensor IDs can be found using this URL: <a href="http://cdec.water.ca.gov/dynamicapp/staMeta?station_id=">http://cdec.water.ca.gov/dynamicapp/staMeta?station_id=</a>, followed by the station ID.</p>
</dd>
<dt>2b.</dt><dd><p>Sensor details can be accessed using <code><a href="#topic+CDEC_StationInfo">CDEC_StationInfo</a> with the station ID.</code></p>
</dd>
<dt>3.</dt><dd><p>Reservoir capacities can be found here: <a href="http://cdec.water.ca.gov/misc/resinfo.html">http://cdec.water.ca.gov/misc/resinfo.html</a></p>
</dd>
<dt>4.</dt><dd><p>A new interactive map of CDEC stations can be found here: <a href="http://cdec.water.ca.gov">http://cdec.water.ca.gov</a></p>
</dd>
</dl>



<h3>Value</h3>

<p>A <code>data.frame</code> object with the following fields: <code>datetime</code>, <code>year</code>, <code>month</code>, <code>value</code>.
</p>


<h3>Author(s)</h3>

<p>D.E. Beaudette
</p>


<h3>References</h3>

<p><a href="http://cdec.water.ca.gov/queryCSV.html">http://cdec.water.ca.gov/queryCSV.html</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+CDECsnowQuery">CDECsnowQuery</a></code> <code><a href="#topic+CDEC_StationInfo">CDEC_StationInfo</a></code>
</p>

<hr>
<h2 id='CDECsnowQuery'>Get snow survey data (California only) from the CDEC website.</h2><span id='topic+CDECsnowQuery'></span>

<h3>Description</h3>

<p>Get snow survey data (California only) from the CDEC website.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CDECsnowQuery(course, start_yr, end_yr)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CDECsnowQuery_+3A_course">course</code></td>
<td>
<p>integer, course number (e.g. 129)</p>
</td></tr>
<tr><td><code id="CDECsnowQuery_+3A_start_yr">start_yr</code></td>
<td>
<p>integer, the starting year (e.g. 2010)</p>
</td></tr>
<tr><td><code id="CDECsnowQuery_+3A_end_yr">end_yr</code></td>
<td>
<p>integer, the ending year (e.g. 2013)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function downloads data from the CDEC website, therefore an internet connection is required. The <code>SWE</code> column contains adjusted SWE if available (<code>Adjusted</code> column), otherwise the reported SWE is used (<code>Water</code> column). See the <a href="http://ncss-tech.github.io/AQP/sharpshootR/CA-snow-survey.html">tutorial</a> for examples.
</p>


<h3>Value</h3>

<p>a <code>data.frame</code> object, see examples
</p>


<h3>Note</h3>

<p>Snow course locations, ID numbers, and other information can be found here: <a href="http://cdec.water.ca.gov/misc/SnowCourses.html">http://cdec.water.ca.gov/misc/SnowCourses.html</a>
</p>


<h3>Author(s)</h3>

<p>D.E. Beaudette
</p>


<h3>References</h3>

<p><a href="http://cdec.water.ca.gov/cgi-progs/snowQuery">http://cdec.water.ca.gov/cgi-progs/snowQuery</a>
</p>

<hr>
<h2 id='colorMixtureVenn'>Create a Venn Diagram of Simulated Color Mixtures</h2><span id='topic+colorMixtureVenn'></span>

<h3>Description</h3>

<p>Create a Venn Diagram of Simulated Color Mixtures
</p>


<h3>Usage</h3>

<pre><code class='language-R'>colorMixtureVenn(
  chips,
  w = rep(1, times = length(chips))/length(chips),
  mixingMethod = "exact",
  ellipse = FALSE,
  labels = TRUE,
  names = FALSE,
  sncs = 0.85
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="colorMixtureVenn_+3A_chips">chips</code></td>
<td>
<p>character vector of standard Munsell color notation (e.g. &quot;10YR 3/4&quot;)</p>
</td></tr>
<tr><td><code id="colorMixtureVenn_+3A_w">w</code></td>
<td>
<p>vector of proportions, can sum to any number, must be same length as <code>chips</code></p>
</td></tr>
<tr><td><code id="colorMixtureVenn_+3A_mixingmethod">mixingMethod</code></td>
<td>
<p>approach used to simulate a mixture: see <code><a href="aqp.html#topic+mixMunsell">aqp::mixMunsell()</a></code> for details</p>
</td></tr>
<tr><td><code id="colorMixtureVenn_+3A_ellipse">ellipse</code></td>
<td>
<p>logical, use alternative ellipse-style (4 or 5 colors only)</p>
</td></tr>
<tr><td><code id="colorMixtureVenn_+3A_labels">labels</code></td>
<td>
<p>logical, print mixture labels</p>
</td></tr>
<tr><td><code id="colorMixtureVenn_+3A_names">names</code></td>
<td>
<p>logical, print names outside of the &quot;sets&quot;</p>
</td></tr>
<tr><td><code id="colorMixtureVenn_+3A_sncs">sncs</code></td>
<td>
<p>scaling factor for set names</p>
</td></tr>
</table>


<h3>Value</h3>

<p>nothing returned, function is called to create graphical output
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
if(requireNamespace("venn") &amp; requireNamespace("gower")) {

chips &lt;- c('10YR 8/1', '2.5YR 3/6', '10YR 2/2')
names(chips) &lt;- c("tan", "dark red", "dark brown")

colorMixtureVenn(chips)
colorMixtureVenn(chips, names = TRUE)

colorMixtureVenn(chips, w = c(1, 1, 1), names = TRUE)
colorMixtureVenn(chips, w = c(10, 5, 1), names = TRUE)

}

## End(Not run)


</code></pre>

<hr>
<h2 id='component.adj.matrix'>Create an adjacency matrix from a data.frame of component data</h2><span id='topic+component.adj.matrix'></span>

<h3>Description</h3>

<p>Create an adjacency matrix from SSURGO component data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>component.adj.matrix(
  d,
  mu = "mukey",
  co = "compname",
  wt = "comppct_r",
  method = c("community.matrix", "occurrence"),
  standardization = "max",
  metric = "jaccard",
  rm.orphans = TRUE,
  similarity = TRUE,
  return.comm.matrix = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="component.adj.matrix_+3A_d">d</code></td>
<td>
<p><code>data.frame</code>, typically of SSURGO data</p>
</td></tr>
<tr><td><code id="component.adj.matrix_+3A_mu">mu</code></td>
<td>
<p>name of the column containing the map unit ID (typically 'mukey')</p>
</td></tr>
<tr><td><code id="component.adj.matrix_+3A_co">co</code></td>
<td>
<p>name of the column containing the component ID (typically 'compname')</p>
</td></tr>
<tr><td><code id="component.adj.matrix_+3A_wt">wt</code></td>
<td>
<p>name of the column containing the component weight percent (typically 'comppct_r')</p>
</td></tr>
<tr><td><code id="component.adj.matrix_+3A_method">method</code></td>
<td>
<p>one of either: <code>community.matrix</code>, or <code>occurrence</code>; see details</p>
</td></tr>
<tr><td><code id="component.adj.matrix_+3A_standardization">standardization</code></td>
<td>
<p>community matrix standardization method, passed to <code>vegan::decostand</code></p>
</td></tr>
<tr><td><code id="component.adj.matrix_+3A_metric">metric</code></td>
<td>
<p>community matrix dissimilarity metric, passed to <code>vegan::vegdist</code></p>
</td></tr>
<tr><td><code id="component.adj.matrix_+3A_rm.orphans">rm.orphans</code></td>
<td>
<p><code>logical</code>, should map units with a single component be omitted? (typically yes)</p>
</td></tr>
<tr><td><code id="component.adj.matrix_+3A_similarity">similarity</code></td>
<td>
<p>logical, return a similarity matrix? (if <code>FALSE</code>, a distance matrix is returned)</p>
</td></tr>
<tr><td><code id="component.adj.matrix_+3A_return.comm.matrix">return.comm.matrix</code></td>
<td>
<p>logical, return pseudo-community matrix? (if <code>TRUE</code> no adjacency matrix is created)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a similarity matrix / adjacency matrix suitable for use with <code>igraph</code> functions or anything else that can accommodate a <em>similarity</em> matrix.
</p>


<h3>Author(s)</h3>

<p>D.E. Beaudette
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (requireNamespace("igraph")) {
  # load sample data set
  data(amador)

  # convert into adjacency matrix
  m &lt;- component.adj.matrix(amador)

  # plot network diagram, with Amador soil highlighted
  plotSoilRelationGraph(m, s = 'amador')
}
</code></pre>

<hr>
<h2 id='constantDensitySampling'>Constant Density Sampling</h2><span id='topic+constantDensitySampling'></span>

<h3>Description</h3>

<p>Perform sampling at a constant density over all polygons within a SpatialPolygonsDataFrame object.</p>


<h3>Usage</h3>

<pre><code class='language-R'>constantDensitySampling(x, polygon.id='pID', parallel=FALSE, cores=NULL, 
n.pts.per.ac=1, min.samples=5, sampling.type='regular')
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="constantDensitySampling_+3A_x">x</code></td>
<td>
<p>a <code>SpatialPolygonsDataFrame</code> object in a projected CRS with units of meters</p>
</td></tr>
<tr><td><code id="constantDensitySampling_+3A_polygon.id">polygon.id</code></td>
<td>
<p>name of attribute in <code>x</code> that contains a unique ID for each polygon</p>
</td></tr>
<tr><td><code id="constantDensitySampling_+3A_parallel">parallel</code></td>
<td>
<p>invoke parallel back-end</p>
</td></tr>
<tr><td><code id="constantDensitySampling_+3A_cores">cores</code></td>
<td>
<p>number of CPU cores to use for parallel operation</p>
</td></tr>
<tr><td><code id="constantDensitySampling_+3A_n.pts.per.ac">n.pts.per.ac</code></td>
<td>
<p>requested sampling density in points per acre (results will be close)</p>
</td></tr>
<tr><td><code id="constantDensitySampling_+3A_min.samples">min.samples</code></td>
<td>
<p>minimum requested number of samples per polygon</p>
</td></tr>
<tr><td><code id="constantDensitySampling_+3A_sampling.type">sampling.type</code></td>
<td>
<p>sampling type</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>SpatialPointsDataFrame</code> object</p>


<h3>Note</h3>

<p>This function expects that <code>x</code> has coordinates associated with a projected CRS and units of meters.</p>


<h3>Author(s)</h3>

<p>D.E. Beaudette</p>


<h3>See Also</h3>

<p><code><a href="#topic+sample.by.poly">sample.by.poly</a></code></p>

<hr>
<h2 id='dailyWB'>Simple Daily Water Balance</h2><span id='topic+dailyWB'></span>

<h3>Description</h3>

<p>Simple interface to the hydromad &quot;leaky bucket&quot; soil moisture model, with accommodation for typical inputs from common soil data and climate sources. Critical points along the water retention curve are specified using volumetric water content (VWC): satiation (saturation), field capacity (typically 1/3 bar suction), and permanent wilting point (typically 15 bar suction).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dailyWB(x, daily.data, id, MS.style = "default", S_0 = 0.5, M = 0, etmult = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dailyWB_+3A_x">x</code></td>
<td>
<p><code>data.frame</code>, required columns include:
</p>

<ul>
<li> <p><code>sat</code>: VWC at satiation
</p>
</li>
<li> <p><code>fc</code>: VWC at field capacity
</p>
</li>
<li> <p><code>pwp</code>: VWC at permanent wilting point
</p>
</li>
<li> <p><code>thickness</code>: soil material thickness in cm
</p>
</li>
<li> <p><code>a.ss</code>: recession coefficients for subsurface flow from saturated zone, should be &gt; 0 (range: 0-1)
</p>
</li>
<li><p> &quot;id&quot;
</p>
</li></ul>
</td></tr>
<tr><td><code id="dailyWB_+3A_daily.data">daily.data</code></td>
<td>
<p><code>data.frame</code>, required columns include:
</p>

<ul>
<li> <p><code>date</code>: <code>Date</code> class representation of dates
</p>
</li>
<li> <p><code>PPT</code>: daily total, precipitation in mm
</p>
</li>
<li> <p><code>PET</code>: daily total, potential ET in mm
</p>
</li></ul>
</td></tr>
<tr><td><code id="dailyWB_+3A_id">id</code></td>
<td>
<p>character, name of column in <code>x</code> that is used to identify records</p>
</td></tr>
<tr><td><code id="dailyWB_+3A_ms.style">MS.style</code></td>
<td>
<p>moisture state classification style, see <code><a href="#topic+estimateSoilMoistureState">estimateSoilMoistureState</a></code></p>
</td></tr>
<tr><td><code id="dailyWB_+3A_s_0">S_0</code></td>
<td>
<p>fraction of water storage filled at time = 0 (range: 0-1)</p>
</td></tr>
<tr><td><code id="dailyWB_+3A_m">M</code></td>
<td>
<p>fraction of area covered by deep-rooted vegetation</p>
</td></tr>
<tr><td><code id="dailyWB_+3A_etmult">etmult</code></td>
<td>
<p>multiplier for PET</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>data.frame</code>
</p>


<h3>References</h3>

<p>Farmer, D., M. Sivapalan, Farmer, D. (2003). Climate, soil and vegetation controls upon the variability of water balance in temperate and semiarid landscapes: downward approach to water balance analysis. Water Resources Research 39(2), p 1035.
</p>
<p>Bai, Y., T. Wagener, P. Reed (2009). A top-down framework for watershed model evaluation and selection under uncertainty. Environmental Modelling and Software 24(8), pp. 901-916.
</p>

<hr>
<h2 id='dailyWB_SSURGO'>Perform daily water balance modeling using SSURGO and DAYMET</h2><span id='topic+dailyWB_SSURGO'></span>

<h3>Description</h3>

<p>Pending.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dailyWB_SSURGO(
  x,
  cokeys = NULL,
  start = 1988,
  end = 2018,
  modelDepth = 100,
  MS.style = "default",
  a.ss = 0.1,
  S_0 = 0.5,
  bufferRadiusMeters = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dailyWB_SSURGO_+3A_x">x</code></td>
<td>
<p><code>sf</code> object representing a single point</p>
</td></tr>
<tr><td><code id="dailyWB_SSURGO_+3A_cokeys">cokeys</code></td>
<td>
<p>vector of component keys to use</p>
</td></tr>
<tr><td><code id="dailyWB_SSURGO_+3A_start">start</code></td>
<td>
<p>starting year (limited to DAYMET holdings)</p>
</td></tr>
<tr><td><code id="dailyWB_SSURGO_+3A_end">end</code></td>
<td>
<p>ending year (limited to DAYMET holdings)</p>
</td></tr>
<tr><td><code id="dailyWB_SSURGO_+3A_modeldepth">modelDepth</code></td>
<td>
<p>soil depth used for water balance, see details</p>
</td></tr>
<tr><td><code id="dailyWB_SSURGO_+3A_ms.style">MS.style</code></td>
<td>
<p>moisture state classification style, see <code><a href="#topic+estimateSoilMoistureState">estimateSoilMoistureState</a></code></p>
</td></tr>
<tr><td><code id="dailyWB_SSURGO_+3A_a.ss">a.ss</code></td>
<td>
<p>recession coefficients for subsurface flow from saturated zone, should be &gt; 0 (range: 0-1)</p>
</td></tr>
<tr><td><code id="dailyWB_SSURGO_+3A_s_0">S_0</code></td>
<td>
<p>fraction of water storage filled at time = 0 (range: 0-1)</p>
</td></tr>
<tr><td><code id="dailyWB_SSURGO_+3A_bufferradiusmeters">bufferRadiusMeters</code></td>
<td>
<p>spatial buffer (meters) applied to <code>x</code> for the look-up of SSURGO data</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>data.frame</code> of daily water balance results
</p>


<h3>Author(s)</h3>

<p>D.E. Beaudette
</p>


<h3>References</h3>

<p>Farmer, D., M. Sivapalan, Farmer, D. (2003). Climate, soil and vegetation controls upon the variability of water balance in temperate and semiarid landscapes: downward approach to water balance analysis. Water Resources Research 39(2), p 1035.
</p>

<hr>
<h2 id='diagnosticPropertyPlot'>Diagnostic Property Plot (base graphics)</h2><span id='topic+diagnosticPropertyPlot'></span>

<h3>Description</h3>

<p>Generate a graphical description of the presence/absence of soil diagnostic properties.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>diagnosticPropertyPlot(
  f,
  v,
  k,
  grid.label = "pedon_id",
  dend.label = "pedon_id",
  sort.vars = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="diagnosticPropertyPlot_+3A_f">f</code></td>
<td>
<p><code>SoilProfileCollection</code> object</p>
</td></tr>
<tr><td><code id="diagnosticPropertyPlot_+3A_v">v</code></td>
<td>
<p>character vector of site-level attribute names of <code>logical</code> type</p>
</td></tr>
<tr><td><code id="diagnosticPropertyPlot_+3A_k">k</code></td>
<td>
<p>an integer, number of groups to highlight</p>
</td></tr>
<tr><td><code id="diagnosticPropertyPlot_+3A_grid.label">grid.label</code></td>
<td>
<p>the name of a site-level attribute (usually unique) annotating the y-axis of the grid</p>
</td></tr>
<tr><td><code id="diagnosticPropertyPlot_+3A_dend.label">dend.label</code></td>
<td>
<p>the name of a site-level attribute (usually unique) annotating dendrogram terminal leaves</p>
</td></tr>
<tr><td><code id="diagnosticPropertyPlot_+3A_sort.vars">sort.vars</code></td>
<td>
<p>sort variables according to natural clustering (<code>TRUE</code>), or use supplied ordering in <code>v</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function attempts to display several pieces of information within a single figure. First, soil profiles are sorted according to the presence/absence of diagnostic features named in <code>v</code>. Second, these diagnostic features are sorted according to their distribution among soil profiles. Third, a binary grid is established with row-ordering of profiles based on step 1 and column-ordering based on step 2. Blue cells represent the presence of a diagnostic feature. Soils with similar diagnostic features should 'clump' together. See examples below.
</p>


<h3>Value</h3>

<p>a <code>list</code> is silently returned by this function, containing:
</p>

<dl>
<dt><code>rd</code></dt><dd><p>a <code>data.frame</code> containing IDs and grouping code</p>
</dd>
<dt><code>profile.order</code></dt><dd><p>a vector containing the order of soil profiles (row-order in figure), according to diagnostic property values</p>
</dd>
<dt><code>var.order</code></dt><dd><p>a vector containing the order of variables (column-order in figure), according to their distribution among profiles</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>D.E. Beaudette and J.M. Skovlin
</p>


<h3>See Also</h3>

<p><code><a href="#topic+multinominal2logical">multinominal2logical</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>


if(require(aqp) &amp;
   require(soilDB) &amp;
   require(latticeExtra)
) {
  
  # sample data, an SPC
  data(gopheridge, package='soilDB')
  
  # get depth class
  sdc &lt;- getSoilDepthClass(gopheridge, name = 'hzname')
  site(gopheridge) &lt;- sdc
  
  # diagnostic properties to consider, no need to convert to factors
  v &lt;- c('lithic.contact', 'paralithic.contact', 'argillic.horizon', 
         'cambic.horizon', 'ochric.epipedon', 'mollic.epipedon', 'very.shallow',
         'shallow', 'mod.deep', 'deep', 'very.deep')
  
  # base graphics
  x &lt;- diagnosticPropertyPlot(gopheridge, v, k=5)
  
  # lattice graphics
  x &lt;- diagnosticPropertyPlot2(gopheridge, v, k=3)
  
  # check output
  str(x)
  
}


</code></pre>

<hr>
<h2 id='diagnosticPropertyPlot2'>Diagnostic Property Plot (lattice)</h2><span id='topic+diagnosticPropertyPlot2'></span>

<h3>Description</h3>

<p>Generate a graphical description of the presence/absence of soil diagnostic properties.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>diagnosticPropertyPlot2(f, v, k, grid.label = "pedon_id", sort.vars = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="diagnosticPropertyPlot2_+3A_f">f</code></td>
<td>
<p><code>SoilProfileCollection</code> object</p>
</td></tr>
<tr><td><code id="diagnosticPropertyPlot2_+3A_v">v</code></td>
<td>
<p>character vector of site-level attribute names of <code>logical</code> type</p>
</td></tr>
<tr><td><code id="diagnosticPropertyPlot2_+3A_k">k</code></td>
<td>
<p>an integer, number of groups to highlight</p>
</td></tr>
<tr><td><code id="diagnosticPropertyPlot2_+3A_grid.label">grid.label</code></td>
<td>
<p>the name of a site-level attribute (usually unique) annotating the y-axis of the grid</p>
</td></tr>
<tr><td><code id="diagnosticPropertyPlot2_+3A_sort.vars">sort.vars</code></td>
<td>
<p>sort variables according to natural clustering (<code>TRUE</code>), or use supplied ordering in <code>v</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function attempts to display several pieces of information within a single figure. First, soil profiles are sorted according to the presence/absence of diagnostic features named in <code>v</code>. Second, these diagnostic features are sorted according to their distribution among soil profiles. Third, a binary grid is established with row-ordering of profiles based on step 1 and column-ordering based on step 2. Blue cells represent the presence of a diagnostic feature. Soils with similar diagnostic features should 'clump' together. See examples below.
</p>


<h3>Value</h3>

<p>a <code>list</code> is silently returned by this function, containing:
</p>

<dl>
<dt><code>rd</code></dt><dd><p>a <code>data.frame</code> containing IDs and grouping code</p>
</dd>
<dt><code>profile.order</code></dt><dd><p>a vector containing the order of soil profiles (row-order in figure), according to diagnostic property values</p>
</dd>
<dt><code>var.order</code></dt><dd><p>a vector containing the order of variables (column-order in figure), according to their distribution among profiles</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>D.E. Beaudette and J.M. Skovlin
</p>


<h3>See Also</h3>

<p><code><a href="#topic+multinominal2logical">multinominal2logical</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>


if(require(aqp) &amp;
   require(soilDB) &amp;
   require(latticeExtra)
) {
  
  # sample data, an SPC
  data(gopheridge, package = 'soilDB')
  
  # get depth class
  sdc &lt;- getSoilDepthClass(gopheridge, name = 'hzname')
  site(gopheridge) &lt;- sdc
  
  # diagnostic properties to consider, no need to convert to factors
  v &lt;- c('lithic.contact', 'paralithic.contact', 'argillic.horizon', 
         'cambic.horizon', 'ochric.epipedon', 'mollic.epipedon', 'very.shallow',
         'shallow', 'mod.deep', 'deep', 'very.deep')
  
  # base graphics
  x &lt;- diagnosticPropertyPlot(gopheridge, v, k=5)
  
  # lattice graphics
  x &lt;- diagnosticPropertyPlot2(gopheridge, v, k=3)
  
  # check output
  str(x)
  
}



</code></pre>

<hr>
<h2 id='dist.along.grad'>Compute Euclidean distance along a gradient.</h2><span id='topic+dist.along.grad'></span>

<h3>Description</h3>

<p>This function computes Euclidean distance along points aligned to a given gradient (e.g. elevation).</p>


<h3>Usage</h3>

<pre><code class='language-R'>dist.along.grad(coords, var, grad.order, grad.scaled.min, grad.scaled.max)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dist.along.grad_+3A_coords">coords</code></td>
<td>
<p>a matrix of x and y coordinates in some projected coordinate system</p>
</td></tr>
<tr><td><code id="dist.along.grad_+3A_var">var</code></td>
<td>
<p>a vector of the same length as <code>coords</code>, describing the gradient of interest</p>
</td></tr>
<tr><td><code id="dist.along.grad_+3A_grad.order">grad.order</code></td>
<td>
<p>vector of integers that define ordering of coordinates along gradient</p>
</td></tr>
<tr><td><code id="dist.along.grad_+3A_grad.scaled.min">grad.scaled.min</code></td>
<td>
<p>min value of rescaled gradient values</p>
</td></tr>
<tr><td><code id="dist.along.grad_+3A_grad.scaled.max">grad.scaled.max</code></td>
<td>
<p>max value of rescaled gradient values</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is primarily intended for use within <code><a href="#topic+plotTransect">plotTransect</a></code>.</p>


<h3>Value</h3>

<p>A <code>data.frame</code> object:
</p>

<dl>
<dt>scaled.grad</dt><dd><p>scaled gradient values</p>
</dd>
<dt>scaled.distance</dt><dd><p>cumulative distance, scaled to the interval of <code>0.5, nrow(coords) + 0.5</code></p>
</dd>
<dt>distance</dt><dd><p>cumulative distance computed along gradient, e.g. transect distance</p>
</dd>
<dt>variable</dt><dd><p>sorted gradient values</p>
</dd>
<dt>x</dt><dd><p>x coordinates, ordered by gradient values</p>
</dd>
<dt>y</dt><dd><p>y coordinate, ordered by gradient values</p>
</dd>
<dt>grad.order</dt><dd><p>a vector index describing the sort order defined by gradient values</p>
</dd>
</dl>



<h3>Note</h3>

<p>This function is very much a work in progress, ideas welcome.</p>


<h3>Author(s)</h3>

<p>D.E. Beaudette</p>


<h3>See Also</h3>

<p><code><a href="#topic+plotTransect">plotTransect</a></code></p>

<hr>
<h2 id='dueling.dendrograms'>Dueling Dendrograms</h2><span id='topic+dueling.dendrograms'></span>

<h3>Description</h3>

<p>Graphically compare two related dendrograms
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dueling.dendrograms(
  p.1,
  p.2,
  lab.1 = "D1",
  lab.2 = "D2",
  cex.nodelabels = 0.75,
  arrow.length = 0.05
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dueling.dendrograms_+3A_p.1">p.1</code></td>
<td>
<p>left-hand phylo-class dendrogram</p>
</td></tr>
<tr><td><code id="dueling.dendrograms_+3A_p.2">p.2</code></td>
<td>
<p>right-hand phylo-class dendrogram</p>
</td></tr>
<tr><td><code id="dueling.dendrograms_+3A_lab.1">lab.1</code></td>
<td>
<p>left-hand title</p>
</td></tr>
<tr><td><code id="dueling.dendrograms_+3A_lab.2">lab.2</code></td>
<td>
<p>right-hand title</p>
</td></tr>
<tr><td><code id="dueling.dendrograms_+3A_cex.nodelabels">cex.nodelabels</code></td>
<td>
<p>character expansion size for node labels</p>
</td></tr>
<tr><td><code id="dueling.dendrograms_+3A_arrow.length">arrow.length</code></td>
<td>
<p>arrow head size</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Connector arrows are used to link nodes from the left-hand dendrogram to the right-hand dendrogram.
</p>


<h3>Value</h3>

<p>nothing is returned, function is called to generate graphical output
</p>


<h3>Author(s)</h3>

<p>D.E. Beaudette
</p>

<hr>
<h2 id='ESS_by_Moran_I'>Estimate Effective Sample Size</h2><span id='topic+ESS_by_Moran_I'></span>

<h3>Description</h3>

<p>Estimation of effective sample size (ESS). See Fortin &amp; Dale 2005, p. 223, Equation 5.15 using global Moran's I as 'rho'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ESS_by_Moran_I(n, rho)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ESS_by_Moran_I_+3A_n">n</code></td>
<td>
<p>sample size</p>
</td></tr>
<tr><td><code id="ESS_by_Moran_I_+3A_rho">rho</code></td>
<td>
<p>Global Moran's I</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric; estimated Effective Sample Size
</p>


<h3>Author(s)</h3>

<p>D.E. Beaudette
</p>


<h3>References</h3>

<p>Fortin, M.J. and Dale, M.R.T. (2005) Spatial Analysis: A Guide for Ecologists. Cambridge University Press, Cambridge, 1-30.
</p>

<hr>
<h2 id='estimateSoilMoistureState'>A very simple estimation of soil moisture state based on volumetric water content</h2><span id='topic+estimateSoilMoistureState'></span>

<h3>Description</h3>

<p>This is a very simple classification of volumetric water content (VWC) into 5 &quot;moisture states&quot;, based on an interpretation of water retention thresholds. Classification is performed using VWC at satiation, field capacity (typically 1/3 bar suction), permanent wilting point (typically 15 bar suction), and water surplus in mm. The inputs to this function are closely aligned with the assumptions and output from <code>hydromad::hydromad(sma = 'bucket', ...)</code>.
</p>
<p>Soil moisture classification rules are as follows:
</p>

<ul>
<li><p> VWC &lt;= <code>pwp</code>: &quot;very dry&quot;
</p>
</li>
<li><p> VWC &gt; <code>pwp</code> AND &lt;= (mid-point between <code>fc</code> and <code>pwp</code>): &quot;dry&quot;
</p>
</li>
<li><p> VWC &gt; (mid-point between <code>fc</code> and <code>pwp</code>) AND &lt;= <code>fc</code>: &quot;moist&quot;
</p>
</li>
<li><p> VWC &gt; <code>fc</code>: &quot;very moist&quot;
</p>
</li>
<li><p> VWC &gt; <code>fc</code> AND <code>U</code> (surplus) &gt; 4mm: &quot;wet&quot;
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>estimateSoilMoistureState(
  VWC,
  U,
  sat,
  fc,
  pwp,
  style = c("default", "newhall")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estimateSoilMoistureState_+3A_vwc">VWC</code></td>
<td>
<p>vector of volumetric water content (VWC), range is 0-1</p>
</td></tr>
<tr><td><code id="estimateSoilMoistureState_+3A_u">U</code></td>
<td>
<p>vector of surplus water (mm)</p>
</td></tr>
<tr><td><code id="estimateSoilMoistureState_+3A_sat">sat</code></td>
<td>
<p>satiation water content, range is 0-1</p>
</td></tr>
<tr><td><code id="estimateSoilMoistureState_+3A_fc">fc</code></td>
<td>
<p>field capacity water content, range is 0-1</p>
</td></tr>
<tr><td><code id="estimateSoilMoistureState_+3A_pwp">pwp</code></td>
<td>
<p>permanent wilting point water content, range is 0-1</p>
</td></tr>
<tr><td><code id="estimateSoilMoistureState_+3A_style">style</code></td>
<td>
<p>VWC classification style</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector of moisture states (ordered factor)
</p>


<h3>Author(s)</h3>

<p>D.E. Beaudette
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# "very moist"
estimateSoilMoistureState(VWC = 0.3, U = 0, sat = 0.35, fc = 0.25, pwp = 0.15)
estimateSoilMoistureState(VWC = 0.3, U = 2, sat = 0.35, fc = 0.25, pwp = 0.15)

"wet"
estimateSoilMoistureState(VWC = 0.3, U = 5, sat = 0.35, fc = 0.25, pwp = 0.15)

# "very dry"
estimateSoilMoistureState(VWC = 0.15, U = 0, sat = 0.35, fc = 0.25, pwp = 0.15)

# "dry" 
estimateSoilMoistureState(VWC = 0.18, U = 0, sat = 0.35, fc = 0.25, pwp = 0.15)

</code></pre>

<hr>
<h2 id='FFD'>Frost-Free Day Evaluation</h2><span id='topic+FFD'></span>

<h3>Description</h3>

<p>Evaluation frost-free days and related metrics from daily climate records.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FFD(
  d,
  returnDailyPr = TRUE,
  minDays = 165,
  frostTemp = 32,
  endSpringDOY = 182,
  startFallDOY = 213
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="FFD_+3A_d">d</code></td>
<td>
<p><code>data.frame</code> with columns 'datetime' 'year', and 'value'; 'value' being daily minimum temperature, see details</p>
</td></tr>
<tr><td><code id="FFD_+3A_returndailypr">returnDailyPr</code></td>
<td>
<p>optionally return <code>list</code> with daily summaries</p>
</td></tr>
<tr><td><code id="FFD_+3A_mindays">minDays</code></td>
<td>
<p>min number of days of non-NA data in spring | fall, required for a reasonable estimate of FFD</p>
</td></tr>
<tr><td><code id="FFD_+3A_frosttemp">frostTemp</code></td>
<td>
<p>critical temperature that defines &quot;frost&quot; (same units as <code>d$value</code>)</p>
</td></tr>
<tr><td><code id="FFD_+3A_endspringdoy">endSpringDOY</code></td>
<td>
<p>day of year that marks end of &quot;spring&quot; (typically Jan 1 &ndash; June 30)</p>
</td></tr>
<tr><td><code id="FFD_+3A_startfalldoy">startFallDOY</code></td>
<td>
<p>day of year that marks start of &quot;fall&quot; (typically Aug 1 &ndash; Dec 31)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The default <code>frostTemp=32</code> is suitable for use with minimum daily temperatures in degrees Fahrenheit. Use <code>frostTemp = 0</code> for temperatures in degrees Celsius.
</p>
<p><a href="http://ncss-tech.github.io/AQP/sharpshootR/FFD-estimates.html">FFD tutorial</a>
</p>


<h3>Value</h3>

<p>a <code>data.frame</code> when a <code>returnDailyPr=FALSE</code>, otherwise a <code>list</code> with the following elements:
</p>

<ul>
<li><p> summary: FFD summary statistics as a <code>data.frame</code>
</p>
</li>
<li><p> fm: frost matrix
</p>
</li>
<li><p> Pr.frost: Pr(frost|day): daily probability of frost
</p>
</li></ul>



<h3>Author(s)</h3>

<p>D.E. Beaudette
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# 11 years of data from highland meadows
data('HHM', package = 'sharpshootR')
x.ffd &lt;- FFD(HHM, returnDailyPr = FALSE, frostTemp = 32)

str(x.ffd)

</code></pre>

<hr>
<h2 id='FFDplot'>Plot output from FFD()</h2><span id='topic+FFDplot'></span>

<h3>Description</h3>

<p>Plot output from FFD()
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FFDplot(s, sub.title = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="FFDplot_+3A_s">s</code></td>
<td>
<p>output from <code><a href="#topic+FFD">FFD</a></code>, with <code>returnDailyPr = TRUE</code></p>
</td></tr>
<tr><td><code id="FFDplot_+3A_sub.title">sub.title</code></td>
<td>
<p>figure subtitle</p>
</td></tr>
</table>


<h3>Value</h3>

<p>nothing, function is called to generate graphical output
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# 11 years of data from highland meadows
data('HHM', package = 'sharpshootR')
x.ffd &lt;- FFD(HHM, returnDailyPr = TRUE, frostTemp=32)

FFDplot(x.ffd)

</code></pre>

<hr>
<h2 id='formatPLSS'>formatPLSS</h2><span id='topic+formatPLSS'></span>

<h3>Description</h3>

<p>Format PLSS information into a coded format that can be digested by PLSS web service.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>formatPLSS(p, type = "SN")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="formatPLSS_+3A_p">p</code></td>
<td>
<p>data.frame with chunks of PLSS coordinates</p>
</td></tr>
<tr><td><code id="formatPLSS_+3A_type">type</code></td>
<td>
<p>an option to format protracted blocks 'PB', unprotracted blocks 'UP', or standard section number 'SN' (default).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is typically accessed as a helper function to prepare data for use within <code><a href="#topic+PLSS2LL">PLSS2LL</a></code> function.
</p>


<h3>Value</h3>

<p>A vector of PLSS codes.
</p>


<h3>Note</h3>

<p>This function expects that the <code>Polygon</code> object has coordinates associated with a projected CRS&ndash; e.g. units of meters.
</p>
<p>This function requires the following packages: <code>stringi</code>.
</p>


<h3>Author(s)</h3>

<p>D.E. Beaudette, Jay Skovlin, A.G. Brown
</p>


<h3>See Also</h3>

<p><code><a href="#topic+PLSS2LL">PLSS2LL</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create some data
d &lt;- data.frame(
  id = 1:3,
  qq = c('SW', 'SW', 'SE'),
  q = c('NE', 'NW', 'SE'),
  s = c(17, 32, 30),
  t = c('T36N', 'T35N', 'T35N'),
  r = c('R29W', 'R28W', 'R28W'),
  type = 'SN',
  m = 'MT20',
  stringsAsFactors = FALSE
)
# add column names

names(d) &lt;- c('id', 'qq', 'q', 's', 't', 'r', 'type', 'm')
# generate formatted PLSS codes
formatPLSS(d, type='SN')

</code></pre>

<hr>
<h2 id='generateLineHash'>Generate a unique ID for line segments</h2><span id='topic+generateLineHash'></span>

<h3>Description</h3>

<p>Generate a unique ID for a line segment, based on the non-cryptographic murmur32 hash.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generateLineHash(x, precision = -1, algo = "murmur32")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generateLineHash_+3A_x">x</code></td>
<td>
<p>an <code>sf</code> object, with 1 line segment per feature</p>
</td></tr>
<tr><td><code id="generateLineHash_+3A_precision">precision</code></td>
<td>
<p>digits are rounded to this many places to the right (negative) or left (positive) of the decimal place</p>
</td></tr>
<tr><td><code id="generateLineHash_+3A_algo">algo</code></td>
<td>
<p>hash function algorithm, passed to <code><a href="digest.html#topic+digest">digest::digest()</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The input <code>sf</code> object must NOT contain multi-part features. The precision specified should be tailored to the coordinate system in use and the snapping tolerance used to create join decision line segments. A <code>precision</code> of 4 is reasonable for geographic coordinates (snapping tolerance of 0.0001 degrees or ~ 10 meters). A <code>precision</code> of -1 (snapping tolerance of 10 meters) is reasonable for projected coordinate systems with units in meters.
</p>


<h3>Value</h3>

<p>A vector of unique IDs created from the hash of line segment start and end vertex coordinates. Unique IDs are returned in the order of records of <code>x</code> and can therefore be saved into a new column of the associated attribute table. <code>NA</code> is returned for empty geometries.
</p>


<h3>Note</h3>

<p>An error is issued if any non-unique IDs are generated. This could be caused by using coordinates that do not contain enough precision for unique hashing.
</p>


<h3>Author(s)</h3>

<p>D.E. Beaudette
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if(requireNamespace("sf")) {

# 10 random line segments
# shared end vertices
.x &lt;- runif(n = 11, min = 0, max = 100)
.y &lt;- runif(n = 11, min = 0, max = 100)
m &lt;- matrix(c(.x, .y), ncol = 2, byrow = TRUE)

# init LINESTRING geometries
a &lt;- lapply(1:(nrow(m) - 1), function(i) {
  .idx &lt;- c(i, i+1)
  geom &lt;- sf::st_sfc(sf::st_linestring(m[.idx, ]))
  a &lt;- sf::st_sf(geom)
  
})

# flatten list -&gt; 10 feature sf object
a &lt;- do.call('rbind', a)

# line hashes
a$id &lt;- generateLineHash(a, precision = 0)

# graphical check
plot(a, lwd = 2, key.width = lcm(4), axes = TRUE, las = 1)


# simulate empty geometry
a$geom[2] &lt;- sf::st_sfc(sf::st_linestring())

# NA returned for empty geometry
generateLineHash(a, precision = 0)

}


</code></pre>

<hr>
<h2 id='geomorphBySoilSeries-SSURGO'>Geomorphic Position Probability via SDA</h2><span id='topic+hillslope.probability'></span><span id='topic+hillslopeProbability'></span><span id='topic+surfaceShapeProbability'></span><span id='topic+geomPosHillProbability'></span><span id='topic+geomPosMountainProbability'></span>

<h3>Description</h3>

<p>Hillslope position probability estimates from the SDA query service (SSURGO)</p>


<h3>Usage</h3>

<pre><code class='language-R'>hillslopeProbability(s, replaceNA=TRUE)
surfaceShapeProbability(s, replaceNA=TRUE)
geomPosHillProbability(s, replaceNA=TRUE)
geomPosMountainProbability(s, replaceNA=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geomorphBySoilSeries-SSURGO_+3A_s">s</code></td>
<td>
<p>a character vector of soil series names, automatically normalized to upper case</p>
</td></tr>
<tr><td><code id="geomorphBySoilSeries-SSURGO_+3A_replacena">replaceNA</code></td>
<td>
<p>boolean: should missing classes be converted to probabilities of 0?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions send a query to the <a href="http://sdmdataaccess.nrcs.usda.gov">SDA</a> webservice. Further information on the SDA webservice and query examples can be found at <a href="http://sdmdataaccess.nrcs.usda.gov/QueryHelp.aspx">http://sdmdataaccess.nrcs.usda.gov/QueryHelp.aspx</a></p>


<h3>Value</h3>

<p>A <code>data.frame</code> object with rows representing soil series, and columns representing probability estimates of that series occurring at specified geomorphic positions or associated with a surface shape.</p>


<h3>Note</h3>

<p>Probability values are computed from SSURGO data.</p>


<h3>Author(s)</h3>

<p>D.E. Beaudette</p>

<hr>
<h2 id='HenryTimeLine'>Sensor Data Timeline from Henry Mount Soil and Water DB</h2><span id='topic+HenryTimeLine'></span>

<h3>Description</h3>

<p>This function generates a simple chart of start/end dates for non-NA sensor data returned by <code>soilDB::fetchHenry()</code>. Data are organized according to sensor name + sensor depth.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>HenryTimeLine(sensor_data, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="HenryTimeLine_+3A_sensor_data">sensor_data</code></td>
<td>
<p><code>soiltemp</code>, <code>soilVWC</code>, or related data returned by <code>soilDB::fetchHenry()</code></p>
</td></tr>
<tr><td><code id="HenryTimeLine_+3A_...">...</code></td>
<td>
<p>additional arguments to <code>latticeExtra::segplot</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>lattice</code> graphics object
</p>


<h3>Author(s)</h3>

<p>D.E. Beaudette
</p>

<hr>
<h2 id='HHM'>Highland Meadows</h2><span id='topic+HHM'></span>

<h3>Description</h3>

<p>11 years of climate data from the Highland Meadows weather station, as maintained by CA DWR.</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("HHM")</code></pre>


<h3>Format</h3>

<p>A data frame with 3469 observations on the following 12 variables.
</p>

<dl>
<dt><code>station_id</code></dt><dd><p>a character vector</p>
</dd>
<dt><code>dur_code</code></dt><dd><p>a character vector</p>
</dd>
<dt><code>sensor_num</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>sensor_type</code></dt><dd><p>a character vector</p>
</dd>
<dt><code>value</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>flag</code></dt><dd><p>a character vector</p>
</dd>
<dt><code>units</code></dt><dd><p>a character vector</p>
</dd>
<dt><code>datetime</code></dt><dd><p>a POSIXct</p>
</dd>
<dt><code>year</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>month</code></dt><dd><p>a factor with levels <code>January</code> <code>February</code> <code>March</code> <code>April</code> <code>May</code> <code>June</code> <code>July</code> <code>August</code> <code>September</code> <code>October</code> <code>November</code> <code>December</code></p>
</dd>
<dt><code>water_year</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>water_day</code></dt><dd><p>a numeric vector</p>
</dd>
</dl>


<hr>
<h2 id='huePositionPlot'>Hue Position Chart</h2><span id='topic+huePositionPlot'></span>

<h3>Description</h3>

<p>A simple visualization of the hue positions for a given Munsell value/chroma according to Soil Survey Technical Note 2.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>huePositionPlot(
  value = 6,
  chroma = 6,
  chip.cex = 4.5,
  label.cex = 0.75,
  contour.dE00 = FALSE,
  origin = NULL,
  origin.cex = 0.75,
  grid.res = 2,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="huePositionPlot_+3A_value">value</code></td>
<td>
<p>a single Munsell value</p>
</td></tr>
<tr><td><code id="huePositionPlot_+3A_chroma">chroma</code></td>
<td>
<p>a single Munsell chroma</p>
</td></tr>
<tr><td><code id="huePositionPlot_+3A_chip.cex">chip.cex</code></td>
<td>
<p>scaling for color chip rectangle</p>
</td></tr>
<tr><td><code id="huePositionPlot_+3A_label.cex">label.cex</code></td>
<td>
<p>scaling for color chip</p>
</td></tr>
<tr><td><code id="huePositionPlot_+3A_contour.de00">contour.dE00</code></td>
<td>
<p>logical, add dE00 contours from <code>origin</code>, imlpicitly <code>TRUE</code> when <code>origin</code> is not <code>NULL</code></p>
</td></tr>
<tr><td><code id="huePositionPlot_+3A_origin">origin</code></td>
<td>
<p>point used for distance comparisons can be either single row matrix of CIELAB coordinates, a character vector specifying a Munsell color. By default (<code>NULL</code>) represents CIELAB coordinates (L,0,0), where L is a constant value determined by <code>value</code> and <code>chroma</code>. See examples.</p>
</td></tr>
<tr><td><code id="huePositionPlot_+3A_origin.cex">origin.cex</code></td>
<td>
<p>scaling for origin point</p>
</td></tr>
<tr><td><code id="huePositionPlot_+3A_grid.res">grid.res</code></td>
<td>
<p>grid resolution for contours, units are CIELAB A/B coordinates. Caution, small values result in many pair-wise distances which could take a very long time.</p>
</td></tr>
<tr><td><code id="huePositionPlot_+3A_...">...</code></td>
<td>
<p>additional arguments to <code><a href="graphics.html#topic+contour">contour()</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>nothing, function is called to generate graphical output
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
huePositionPlot(value = 4, chroma = 4)

huePositionPlot(value = 6, chroma = 6)

huePositionPlot(value = 8, chroma = 8)

huePositionPlot(value = 6, chroma = 6, contour.dE00 = TRUE, grid.res = 2)

# shift origin to arbitrary CIELAB coordinates or Munsell color
huePositionPlot(origin = cbind(40, 5, 15), origin.cex = 0.5)

huePositionPlot(origin = '5G 6/4', origin.cex = 0.5)

huePositionPlot(origin = '10YR 3/4', origin.cex = 0.5)

huePositionPlot(value = 3, chroma = 4, origin = '10YR 3/4', origin.cex = 0.5)


## End(Not run)

</code></pre>

<hr>
<h2 id='hydOrder'>Hydrologic Ordering of a Geomorphic Proportion Matrix</h2><span id='topic+hydOrder'></span>

<h3>Description</h3>

<p>Hydrologic Ordering of a Geomorphic Proportion Matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hydOrder(x, g, clust = TRUE, j.amount = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hydOrder_+3A_x">x</code></td>
<td>
<p>x <code>data.frame</code>, geomorphic proportion matrix, as created by <code>soilDB::fetchOSD(..., extended=TRUE)</code></p>
</td></tr>
<tr><td><code id="hydOrder_+3A_g">g</code></td>
<td>
<p>character, name of geomorphic summary table, one of: <code>c('geomcomp', 'hillpos', 'flats', 'terrace', 'mtnpos', 'shape')</code></p>
</td></tr>
<tr><td><code id="hydOrder_+3A_clust">clust</code></td>
<td>
<p>logical, perform clustering of geomorphic proportion matrix</p>
</td></tr>
<tr><td><code id="hydOrder_+3A_j.amount">j.amount</code></td>
<td>
<p>amount of noise applied to rows having a duplicate proportion vector, passed to <code>jitter()</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>when <code>clust = FALSE</code> a vector of series names, in hydrologic ordering, otherwise a <code>list</code> with the following elements:
</p>

<ul>
<li> <p><code>clust</code>: rotated <code>hclust</code> object
</p>
</li>
<li> <p><code>hyd.order</code>: vector of series names, in hydrologic ordering
</p>
</li>
<li> <p><code>clust.hyd.order</code>: vector of series names, after clustering + rotation, approximate hydrologic ordering
</p>
</li>
<li> <p><code>match.rate</code>: fraction of series matching target hydrologic ordering, after clustering + rotation
</p>
</li>
<li> <p><code>obj</code>: objective function value (sum of squared rank differences), used by <code><a href="#topic+iterateHydOrder">iterateHydOrder()</a></code>
</p>
</li></ul>



<h3>Author(s)</h3>

<p>D.E. Beaudette
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# example data, similar to results from soilDB::fetchOSD(..., extended = TRUE)
data("OSDexamples")

# no clustering of the geomorphic proportion matrix
h &lt;- hydOrder(OSDexamples$hillpos, g = 'hillpos', clust = FALSE)

# compare with original order

data.frame(
original = OSDexamples$hillpos$series,
ordered = h
)

# cluster results
h &lt;- hydOrder(OSDexamples$hillpos, g = 'hillpos', clust = TRUE)
str(h)
</code></pre>

<hr>
<h2 id='isMineralSoilMaterial'>Mineral Soil Material Criteria from 12th Ed. of KST</h2><span id='topic+isMineralSoilMaterial'></span>

<h3>Description</h3>

<p>Evaluate mineral soil material criteria based on soil organic carbon, clay content, and length of saturation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>isMineralSoilMaterial(soc, clay, saturation = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="isMineralSoilMaterial_+3A_soc">soc</code></td>
<td>
<p>soil organic carbon percent by mass</p>
</td></tr>
<tr><td><code id="isMineralSoilMaterial_+3A_clay">clay</code></td>
<td>
<p>clay content percent by mass</p>
</td></tr>
<tr><td><code id="isMineralSoilMaterial_+3A_saturation">saturation</code></td>
<td>
<p>logical, cumulative saturation 30+ days</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>data.frame</code> of criteria test results
</p>

<hr>
<h2 id='iterateHydOrder'>Iteratively Attempt Hydrologic Ordering of Geomorphic Proportion Matrix</h2><span id='topic+iterateHydOrder'></span>

<h3>Description</h3>

<p>Iteratively Attempt Hydrologic Ordering of Geomorphic Proportion Matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>iterateHydOrder(
  x,
  g,
  target = 0.9,
  maxIter = 20,
  j.amount = 0.05,
  verbose = FALSE,
  trace = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="iterateHydOrder_+3A_x">x</code></td>
<td>
<p><code>data.frame</code> geomorphic proportion matrix, as created by <code>soilDB::fetchOSD(..., extended=TRUE)</code></p>
</td></tr>
<tr><td><code id="iterateHydOrder_+3A_g">g</code></td>
<td>
<p>name of geomorphic summary table, one of: <code>c('geomcomp', 'hillpos', 'flats', 'terrace', 'mtnpos', 'shape')</code></p>
</td></tr>
<tr><td><code id="iterateHydOrder_+3A_target">target</code></td>
<td>
<p>numeric, target match rate</p>
</td></tr>
<tr><td><code id="iterateHydOrder_+3A_maxiter">maxIter</code></td>
<td>
<p>integer, maximum number of perturbations of geomorphic probability matrix</p>
</td></tr>
<tr><td><code id="iterateHydOrder_+3A_j.amount">j.amount</code></td>
<td>
<p>numeric, amount of noise applied to rows with too few unique values, passed to <code>jitter()</code></p>
</td></tr>
<tr><td><code id="iterateHydOrder_+3A_verbose">verbose</code></td>
<td>
<p>logical, additional output printed via message</p>
</td></tr>
<tr><td><code id="iterateHydOrder_+3A_trace">trace</code></td>
<td>
<p>logical, additional list of results for each iteration</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is used by the suite of geomorphic proportion visualization functions (<code style="white-space: pre;">&#8288;viz*&#8288;</code>) to attempt rotation of a dendrogram according to &quot;hydrologic ordering&quot; rules. A perfect rotation is not always possible, and reported as a match rate in the returned <code>score</code> value
</p>


<h3>Value</h3>

<p>A <code>list</code> with the following elements:
</p>

<ul>
<li> <p><code>clust</code>: rotated <code>hclust</code> object
</p>
</li>
<li> <p><code>hyd.order</code>: vector of series names, in hydrologic ordering
</p>
</li>
<li> <p><code>clust.hyd.order</code>: vector of series names, after clustering + rotation, approximate hydrologic ordering
</p>
</li>
<li> <p><code>match.rate</code>: fraction of series matching target hydrologic ordering, after clustering + rotation
</p>
</li>
<li> <p><code>obj</code>: objective function value (sum of squared rank differences), used by <code><a href="#topic+iterateHydOrder">iterateHydOrder()</a></code>
</p>
</li>
<li> <p><code>niter</code>: number of iterations
</p>
</li>
<li> <p><code>trace</code>: list of results by iteration, only when <code>trace = TRUE</code>
</p>
</li></ul>



<h3>Author(s)</h3>

<p>D.E. Beaudette
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# example data, similar to results from soilDB::fetchOSD(..., extended = TRUE)
data("OSDexamples")

# single iteration of hydrologic ordering
h1 &lt;- hydOrder(OSDexamples$hillpos, g = 'hillpos', clust = TRUE)

# perform several iterations, keep the best one
h2 &lt;- iterateHydOrder(OSDexamples$hillpos, 'hillpos', verbose = TRUE)

# compare: only slightly better match rate achieved
h1$match.rate
h2$match.rate

# return trace log for eval of objective function
# increase max iterations
h2 &lt;- iterateHydOrder(OSDexamples$hillpos, 'hillpos', maxIter = 100, verbose = TRUE, trace = TRUE)

# inspect objective function evolution
tr &lt;- h2$trace
obj &lt;- sapply(tr, '[[', 'obj')

plot(obj, type = 'b')
hist(obj)

# in this case the clustering of hillpos proportions has only two possible configurations

</code></pre>

<hr>
<h2 id='joinAdjacency'>Join Document Adjacency</h2><span id='topic+joinAdjacency'></span>

<h3>Description</h3>

<p>Convert a set of line segment &quot;join decisions&quot; into a weighted adjacency matrix describing which map unit symbols touch.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>joinAdjacency(x, vars = c("l_musym", "r_musym"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="joinAdjacency_+3A_x">x</code></td>
<td>
<p><code>data.frame</code> or similar object, each row represents a single shared edge (typically <code>sf</code> LINESTRING feature)</p>
</td></tr>
<tr><td><code id="joinAdjacency_+3A_vars">vars</code></td>
<td>
<p>a vector of two characters naming columns containing &quot;left&quot;, and &quot;right&quot; map unit symbols</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A weighted adjacency matrix is returned, suitable for plotting directly with <code>plotSoilRelationGraph()</code>.
</p>


<h3>Author(s)</h3>

<p>D.E. Beaudette
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plotSoilRelationGraph">plotSoilRelationGraph()</a></code>
</p>

<hr>
<h2 id='LL2PLSS'>LL2PLSS</h2><span id='topic+LL2PLSS'></span><span id='topic+plssMeridians'></span>

<h3>Description</h3>

<p>Uses latitude and longitude coordinates to return the PLSS section geometry from the BLM PLSS web service.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LL2PLSS(x, y, returnlevel = c("I", "S"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="LL2PLSS_+3A_x">x</code></td>
<td>
<p>longitude coordinates (WGS84)</p>
</td></tr>
<tr><td><code id="LL2PLSS_+3A_y">y</code></td>
<td>
<p>latitude coordinates (WGS84)</p>
</td></tr>
<tr><td><code id="LL2PLSS_+3A_returnlevel">returnlevel</code></td>
<td>
<p>'S' for &quot;Section&quot; or 'I' for &quot;Intersection&quot; (subsections)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function accepts geographic coordinates and returns the PLSS fabric geometry to the quarter-quarter section. <code>returnlevel</code> defaults to 'I' which returns smallest intersected sectional aliquot geometry, 'S' will return the section geometry of the coordinates. See https://gis.blm.gov/arcgis/rest/services/Cadastral/BLM_Natl_PLSS_CadNSDI/MapServer for details.
</p>


<h3>Value</h3>

<p><code>sf</code> object with geometry and PLSS definition.
</p>


<h3>Note</h3>

<p>This function requires the following packages: <code>httr</code>, <code>jsonlite</code>, and <code>sp</code>.
</p>


<h3>Author(s)</h3>

<p>D.E. Beaudette, Jay Skovlin, A.G. Brown
</p>


<h3>See Also</h3>

<p><code><a href="#topic+PLSS2LL">PLSS2LL</a></code>, <code><a href="#topic+formatPLSS">formatPLSS</a></code>
</p>

<hr>
<h2 id='moistureStateProportions'>Compute moisture state proportions</h2><span id='topic+moistureStateProportions'></span>

<h3>Description</h3>

<p>Compute moisture state proportions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>moistureStateProportions(x, id = "compname", step = c("month", "week", "doy"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="moistureStateProportions_+3A_x">x</code></td>
<td>
<p><code>data.frame</code> created by <code><a href="#topic+dailyWB">dailyWB()</a></code> or <code><a href="#topic+dailyWB_SSURGO">dailyWB_SSURGO()</a></code></p>
</td></tr>
<tr><td><code id="moistureStateProportions_+3A_id">id</code></td>
<td>
<p>character, column name identifying sites, components, or soil series</p>
</td></tr>
<tr><td><code id="moistureStateProportions_+3A_step">step</code></td>
<td>
<p>time step, one of 'month', 'week', or 'doy'</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>data.frame</code>
</p>

<hr>
<h2 id='moistureStateStats'>Statistics on Soil Moisture State</h2><span id='topic+moistureStateStats'></span>

<h3>Description</h3>

<p>Statistics on Soil Moisture State
</p>


<h3>Usage</h3>

<pre><code class='language-R'>moistureStateStats(x, id = "compname")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="moistureStateStats_+3A_x">x</code></td>
<td>
<p><code>data.frame</code>, created by <code><a href="#topic+moistureStateProportions">moistureStateProportions()</a></code></p>
</td></tr>
<tr><td><code id="moistureStateStats_+3A_id">id</code></td>
<td>
<p>name of ID column</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>data.frame</code> containing the most-likely moisture state and Shannon entropy.
</p>

<hr>
<h2 id='moistureStateThreshold'>Apply a threshold to soil moisture states</h2><span id='topic+moistureStateThreshold'></span>

<h3>Description</h3>

<p>Apply a threshold to soil moisture states
</p>


<h3>Usage</h3>

<pre><code class='language-R'>moistureStateThreshold(
  x,
  id = "compname",
  threshold = "moist",
  operator = c("&lt;", "&gt;", "==", "&lt;=", "&gt;=")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="moistureStateThreshold_+3A_x">x</code></td>
<td>
<p>a <code>data.frame</code> created by <code><a href="#topic+dailyWB">dailyWB()</a></code> or <code><a href="#topic+dailyWB_SSURGO">dailyWB_SSURGO()</a></code></p>
</td></tr>
<tr><td><code id="moistureStateThreshold_+3A_id">id</code></td>
<td>
<p>character, column name identifying sites, soils, or soil series</p>
</td></tr>
<tr><td><code id="moistureStateThreshold_+3A_threshold">threshold</code></td>
<td>
<p>moisture state threshold, see <code><a href="#topic+estimateSoilMoistureState">estimateSoilMoistureState</a></code></p>
</td></tr>
<tr><td><code id="moistureStateThreshold_+3A_operator">operator</code></td>
<td>
<p>one of &quot;&lt;&quot;, &quot;&gt;&quot;, &quot;==&quot;, &quot;&lt;=&quot;, or &quot;&gt;=&quot;</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>data.frame</code>
</p>


<h3>Author(s)</h3>

<p>D.E. Beaudette
</p>

<hr>
<h2 id='monthlyWB'>Monthly Water Balances</h2><span id='topic+monthlyWB'></span>

<h3>Description</h3>

<p>Perform a monthly water balance by &quot;leaky bucket&quot; model, inspired by code from <code>bucket.sim</code> of <code>hydromad</code> package, as defined in Bai et al., (2009) (model &quot;SMA_S1&quot;). The plant available water-holding storage (soil thickness * awc) is used as the &quot;bucket capacity&quot;. All water in excess of this capacity is lumped into a single &quot;surplus&quot; term.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>monthlyWB(
  AWC,
  PPT,
  PET,
  S_init = 1,
  starting_month = 1,
  rep = 1,
  keep_last = FALSE,
  distribute = FALSE,
  method = c("equal", "random", "gaussian"),
  k = 10
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="monthlyWB_+3A_awc">AWC</code></td>
<td>
<p>numeric, available water-holding capacity (mm), typically thickness (mm) * awc (fraction)</p>
</td></tr>
<tr><td><code id="monthlyWB_+3A_ppt">PPT</code></td>
<td>
<p>numeric, time-series of monthly PPT (mm), calendar year ordering</p>
</td></tr>
<tr><td><code id="monthlyWB_+3A_pet">PET</code></td>
<td>
<p>numeric, time-series of monthly PET (mm), calendar year ordering</p>
</td></tr>
<tr><td><code id="monthlyWB_+3A_s_init">S_init</code></td>
<td>
<p>numeric, initial fraction of <code>AWC</code> filled with water (values 0-1)</p>
</td></tr>
<tr><td><code id="monthlyWB_+3A_starting_month">starting_month</code></td>
<td>
<p>integer, starting month index, 1=January, 9=September</p>
</td></tr>
<tr><td><code id="monthlyWB_+3A_rep">rep</code></td>
<td>
<p>integer, number of cycles to run water balance</p>
</td></tr>
<tr><td><code id="monthlyWB_+3A_keep_last">keep_last</code></td>
<td>
<p>logical, keep only the last iteration of the water balance</p>
</td></tr>
<tr><td><code id="monthlyWB_+3A_distribute">distribute</code></td>
<td>
<p>logical, distribute monthly data into <code>k</code> divisions within each month</p>
</td></tr>
<tr><td><code id="monthlyWB_+3A_method">method</code></td>
<td>
<p>method for distributing PPT and PET into <code>k</code> divisions:
</p>

<ul>
<li><p> 'equal' divides PPT and PET into <code>k</code> equal amounts
</p>
</li>
<li><p> 'random' divides PPT and PET into random proportions generated via multinominal simulation
</p>
</li>
<li><p> 'gaussian' divides PPT and PET according to a bell-shaped curve centered in the middle of each month
</p>
</li></ul>
</td></tr>
<tr><td><code id="monthlyWB_+3A_k">k</code></td>
<td>
<p>integer, number of divisions</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See the <a href="http://ncss-tech.github.io/AQP/sharpshootR/monthly-WB.html">monthly water balance tutorial</a> for further examples and discussion.
</p>
<p>A number of important assumptions are made by this style of water balance modeling:
</p>

<ul>
<li><p> the concept of field capacity is built into the specified bucket size
</p>
</li>
<li><p> the influence of aquitards or local terrain cannot be integrated into this model
</p>
</li>
<li><p> interception is not used in this model
</p>
</li></ul>



<h3>Value</h3>

<p>a <code>data.frame</code> with the following elements:
</p>

<ul>
<li><p> PPT: monthly PPT (mm)
</p>
</li>
<li><p> PET: monthly PET (mm)
</p>
</li>
<li><p> U:   monthly surplus (mm)
</p>
</li>
<li><p> S:   monthly soil moisture storage (mm)
</p>
</li>
<li><p> ET:  monthly AET (mm)
</p>
</li>
<li><p> D:   monthly deficit (mm)
</p>
</li>
<li><p> month: month number
</p>
</li>
<li><p> mo:  month label
</p>
</li></ul>



<h3>References</h3>

<p>Arkley R, Ulrich R. 1962. The use of calculated actual and potential evapotranspiration for estimating potential plant growth. Hilgardia 32(10):443-469.
</p>
<p>Bai, Y., T. Wagener, P. Reed (2009). A top-down framework for watershed model evaluation and selection under uncertainty. Environmental Modelling and Software 24(8), pp. 901-916.
</p>
<p>Farmer, D., M. Sivapalan, Farmer, D. (2003). Climate, soil and vegetation controls upon the variability of water balance in temperate and semiarid landscapes: downward approach to water balance analysis. Water Resources Research 39(2), p 1035.
</p>

<hr>
<h2 id='monthlyWB_summary'>Water Balance Summaries</h2><span id='topic+monthlyWB_summary'></span>

<h3>Description</h3>

<p>A summary of a monthly water balance, including estimates of total and consecutive &quot;dry&quot;, &quot;moist&quot;, &quot;wet&quot; conditions, total surplus, deficit, and AET, and annual AET/PET ratio.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>monthlyWB_summary(w, AWC = NULL, PWP = NULL, FC = NULL, SAT = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="monthlyWB_summary_+3A_w">w</code></td>
<td>
<p>used for for <code>monthlyWB_summary()</code>: a data.frame, such as result of <code>monthlyWB()</code>;</p>
</td></tr>
<tr><td><code id="monthlyWB_summary_+3A_awc">AWC</code></td>
<td>
<p>numeric, optional plant-available water storage (mm)</p>
</td></tr>
<tr><td><code id="monthlyWB_summary_+3A_pwp">PWP</code></td>
<td>
<p>numeric, optional permanent wilting point (volumetric water content)</p>
</td></tr>
<tr><td><code id="monthlyWB_summary_+3A_fc">FC</code></td>
<td>
<p>numeric, optional field capacity (volumetric water content)</p>
</td></tr>
<tr><td><code id="monthlyWB_summary_+3A_sat">SAT</code></td>
<td>
<p>numeric, optional saturation capacity (volumetric water content)</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>monthlyWB_summary()</code>: a <code>data.frame</code> containing:
</p>

<ul>
<li><p> cumulative (<code>dry</code>, <code>moist</code>, <code>wet</code>) days
</p>
</li>
<li><p> consecutive (<code>dry_con</code>, <code>moist_con</code>, <code>wet_con</code>) days
</p>
</li>
<li><p> total deficit (<code>total_deficit</code>) in mm
</p>
</li>
<li><p> total surplus (<code>total_surplus</code>) in mm
</p>
</li>
<li><p> total actual evapotranspiration (<code>total_AET</code>) in mm
</p>
</li>
<li><p> annual actual evapotranspiration to potential evapotranspiration ratio (<code>annual_AET_PET_ratio</code>)
</p>
</li></ul>



<h3>Note</h3>

<p>Work in progress: AWC, PWP, FC, and SAT arguments are currently ignored!
</p>

<hr>
<h2 id='Moran_I_ByRaster'>Compute Moran's I for a raster sampled from a mapunit extent</h2><span id='topic+Moran_I_ByRaster'></span>

<h3>Description</h3>

<p>Compute Moran's I using a subset of sample collected within the extent of a mapunit. This is likely an under-estimate of SA because we are including pixels both inside/outside MU delineations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Moran_I_ByRaster(
  r,
  mu.extent = NULL,
  n = NULL,
  k = NULL,
  do.correlogram = FALSE,
  cor.order = 5,
  crop.raster = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Moran_I_ByRaster_+3A_r">r</code></td>
<td>
<p>single <code>SpatRaster</code></p>
</td></tr>
<tr><td><code id="Moran_I_ByRaster_+3A_mu.extent">mu.extent</code></td>
<td>
<p><code>SpatVector</code> representation of mapunit polygons bounding box (via <code>terra::ext()</code>)</p>
</td></tr>
<tr><td><code id="Moran_I_ByRaster_+3A_n">n</code></td>
<td>
<p>number of regular samples (what is a reasonable value?)</p>
</td></tr>
<tr><td><code id="Moran_I_ByRaster_+3A_k">k</code></td>
<td>
<p>number of neighbors used for weights matrix</p>
</td></tr>
<tr><td><code id="Moran_I_ByRaster_+3A_do.correlogram">do.correlogram</code></td>
<td>
<p>compute correlogram?</p>
</td></tr>
<tr><td><code id="Moran_I_ByRaster_+3A_cor.order">cor.order</code></td>
<td>
<p>order of correlogram</p>
</td></tr>
<tr><td><code id="Moran_I_ByRaster_+3A_crop.raster">crop.raster</code></td>
<td>
<p>optionally disable cropping of the raster layer</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function uses the <code>spdep::moran.test()</code> function
</p>


<h3>Value</h3>

<p>If <code>do.correlogram</code> is <code>TRUE</code> a list with estimated Moran's I (<code style="white-space: pre;">&#8288;$I&#8288;</code>) and the correlogram (<code style="white-space: pre;">&#8288;$correlogram&#8288;</code>), otherwise the estimated Moran's I value.
</p>


<h3>Author(s)</h3>

<p>D.E. Beaudette
</p>

<hr>
<h2 id='multinominal2logical'>Convert Multinominal to Logical Matrix</h2><span id='topic+multinominal2logical'></span>

<h3>Description</h3>

<p>Convert a single multinominal, site-level attribute from a <code>SoilProfileCollection</code> into a matrix of corresponding logical values. The result contains IDs from the <code>SoilProfileCollection</code> and can easily be joined to the original site-level data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>multinominal2logical(x, v)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="multinominal2logical_+3A_x">x</code></td>
<td>
<p>a <code>SoilProfileCollection</code> object</p>
</td></tr>
<tr><td><code id="multinominal2logical_+3A_v">v</code></td>
<td>
<p>the name of a site-level attribute that is a factor, or can be coerced to a factor, with more than 2 levels</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code> with IDs in the first column, and as many columns of logical vectors as there were levels in <code>v</code>. See examples.
</p>


<h3>Author(s)</h3>

<p>D.E. Beaudette
</p>


<h3>See Also</h3>

<p><code><a href="#topic+diagnosticPropertyPlot">diagnosticPropertyPlot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>


if(require(soilDB) &amp;
   require(aqp) &amp;
   require(latticeExtra)) {
  
  
  # sample data, an SPC
  data(loafercreek, package='soilDB')
  
  # convert to logical matrix
  hp &lt;- multinominal2logical(loafercreek, 'hillslopeprof')
  
  # join-in to site data
  site(loafercreek) &lt;- hp
  
  # variable names
  v &lt;- c('lithic.contact', 'paralithic.contact', 
         'argillic.horizon', 'toeslope', 'footslope', 
         'backslope', 'shoulder', 'summit')
  
  # visualize with some other diagnostic features
  x &lt;- diagnosticPropertyPlot(loafercreek, v, k = 5, 
                              grid.label = 'bedrckkind', dend.label = 'pedon_id')  
}



</code></pre>

<hr>
<h2 id='OSDexamples'>Example output from soilDB::fetchOSD()</h2><span id='topic+OSDexamples'></span>

<h3>Description</h3>

<p>These example data are used to test various functions in this package when network access may be limited.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(OSDexamples)
</code></pre>


<h3>Format</h3>

<p>An object of class <code>list</code> of length 17.
</p>

<hr>
<h2 id='PCP_plot'>Percentiles of Cumulative Precipitation</h2><span id='topic+PCP_plot'></span>

<h3>Description</h3>

<p>Generate a plot representing percentiles of cumulative precipitation, given a historic record, and criteria for selecting a year of data for comparison.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PCP_plot(
  x,
  this.year,
  this.day = NULL,
  method = "exemplar",
  q.color = "RoyalBlue",
  c.color = "firebrick",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PCP_plot_+3A_x">x</code></td>
<td>
<p>result from <code>CDECquery</code> for now, will need to generalize to other sources</p>
</td></tr>
<tr><td><code id="PCP_plot_+3A_this.year">this.year</code></td>
<td>
<p>a single water year, e.g. 2020</p>
</td></tr>
<tr><td><code id="PCP_plot_+3A_this.day">this.day</code></td>
<td>
<p>optional integer representing days since start of selected water year</p>
</td></tr>
<tr><td><code id="PCP_plot_+3A_method">method</code></td>
<td>
<p>'exemplar' or 'daily', currently 'exemplar' is the only method available</p>
</td></tr>
<tr><td><code id="PCP_plot_+3A_q.color">q.color</code></td>
<td>
<p>color of percentiles cumulative precipitation</p>
</td></tr>
<tr><td><code id="PCP_plot_+3A_c.color">c.color</code></td>
<td>
<p>color of selected year</p>
</td></tr>
<tr><td><code id="PCP_plot_+3A_...">...</code></td>
<td>
<p>additional arguments to <code>plot</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is very much a work in progress. Further examples at <a href="https://ncss-tech.github.io/AQP/sharpshootR/CDEC.html">https://ncss-tech.github.io/AQP/sharpshootR/CDEC.html</a>, and <a href="https://ncss-tech.github.io/AQP/sharpshootR/cumulative-PPT.html">https://ncss-tech.github.io/AQP/sharpshootR/cumulative-PPT.html</a>.
</p>


<h3>Value</h3>

<p>nothing, this function is called to create graphical output
</p>


<h3>Author(s)</h3>

<p>D.E. Beaudette
</p>


<h3>See Also</h3>

<p><a href="soilDB.html#topic+waterDayYear">waterDayYear</a>
</p>

<hr>
<h2 id='percentileDemo'>Demonstration of Percentiles vs. Mean / SD</h2><span id='topic+percentileDemo'></span>

<h3>Description</h3>

<p>This function can be used to graphically demonstrate the relationship between distribution shape, an idealized normal distribution (based on sample mean and sd) shape, and measures of central tendency / spread.</p>


<h3>Usage</h3>

<pre><code class='language-R'>percentileDemo(x, labels.signif = 3, pctile.color = "RoyalBlue", 
mean.color = "Orange", range.color = "DarkRed", 
hist.breaks = 30, boxp = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="percentileDemo_+3A_x">x</code></td>
<td>
<p>vector of values to summarize</p>
</td></tr>
<tr><td><code id="percentileDemo_+3A_labels.signif">labels.signif</code></td>
<td>
<p>integer, number of significant digits to be used in figure annotation</p>
</td></tr>
<tr><td><code id="percentileDemo_+3A_pctile.color">pctile.color</code></td>
<td>
<p>color used to demonstrate range from 10th to 90th percentiles</p>
</td></tr>
<tr><td><code id="percentileDemo_+3A_mean.color">mean.color</code></td>
<td>
<p>color used to specify mean +/- 2SD</p>
</td></tr>
<tr><td><code id="percentileDemo_+3A_range.color">range.color</code></td>
<td>
<p>color used to specify data range</p>
</td></tr>
<tr><td><code id="percentileDemo_+3A_hist.breaks">hist.breaks</code></td>
<td>
<p>integer, number of suggested breaks to <code>hist</code></p>
</td></tr>
<tr><td><code id="percentileDemo_+3A_boxp">boxp</code></td>
<td>
<p>logical, add a box and whisker plot?</p>
</td></tr>
<tr><td><code id="percentileDemo_+3A_...">...</code></td>
<td>
<p>further arguments to <code>plot</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A 1-row matrix of summary stats is invisibly returned.</p>


<h3>Note</h3>

<p>This function is mainly for educational purposes.
</p>


<h3>Author(s)</h3>

<p>D.E. Beaudette</p>


<h3>References</h3>

<p><a href="https://ncss-tech.github.io/soil-range-in-characteristics/why-percentiles.html">https://ncss-tech.github.io/soil-range-in-characteristics/why-percentiles.html</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (requireNamespace("Hmisc")) {
  x &lt;- rnorm(100)
  percentileDemo(x)
  
  x &lt;- rlnorm(100)
  percentileDemo(x)
}
</code></pre>

<hr>
<h2 id='plotAvailWater'>Visual Demonstration of Available Soil Water</h2><span id='topic+plotAvailWater'></span>

<h3>Description</h3>

<p>Generate a simplistic diagram of the various fractions of water held within soil pore-space. Largely inspired by <a href="https://www.nature.com/scitable/knowledge/library/soil-water-dynamics-103089121/">Figure 2 from O'Geen (2013)</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotAvailWater(
  x,
  width = 0.25,
  cols = c(grey(0.5), "DarkGreen", "LightBlue", "RoyalBlue"),
  name.cex = 0.8,
  annotate = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotAvailWater_+3A_x">x</code></td>
<td>
<p>a <code>data.frame</code> containing sample names and water retention data, see examples below</p>
</td></tr>
<tr><td><code id="plotAvailWater_+3A_width">width</code></td>
<td>
<p>vertical width of each bar graph</p>
</td></tr>
<tr><td><code id="plotAvailWater_+3A_cols">cols</code></td>
<td>
<p>a vector of colors used to symbolize 'solid phase', 'unavailable water', 'available water', and 'gravitational water'</p>
</td></tr>
<tr><td><code id="plotAvailWater_+3A_name.cex">name.cex</code></td>
<td>
<p>character scaling of horizon names, printed on left-hand side of figure</p>
</td></tr>
<tr><td><code id="plotAvailWater_+3A_annotate">annotate</code></td>
<td>
<p>logical, annotate AWC</p>
</td></tr>
</table>


<h3>Value</h3>

<p>nothing, function is called to generate graphical output
</p>


<h3>Author(s)</h3>

<p>D.E. Beaudette
</p>


<h3>References</h3>

<p>O'Geen, A. T. (2013) Soil Water Dynamics. Nature Education Knowledge 4(5):9.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# demonstration
s &lt;- data.frame(
  name = c('loamy sand', 'sandy loam', 'silt loam', 'clay loam'), 
  pwp = c(0.05, 0.1, 0.18, 0.2), 
  fc = c(0.1, 0.2, 0.38, 0.35), 
  sat = c(0.25, 0.3, 0.45, 0.4))
s$solid &lt;- with(s, 1-sat)

par(mar=c(5, 6, 0.5, 0.5))
plotAvailWater(s, name.cex=1.25)



  
  if(requireNamespace("aqp")) {
    
    # demonstration using idealized AWC by soil texture
    data("ROSETTA.centroids", package = "aqp")
    
    # subset columns
    x &lt;- ROSETTA.centroids[, c('texture', 'pwp', 'fc', 'sat', 'awc')]
    
    # adjust to expected names / additional data required by plotAvailWater
    names(x)[1] &lt;- 'name'
    x$solid &lt;- with(x, 1 - sat)
    
    # re-order based on approximate AWC
    x &lt;- x[order(x$awc), ]
    
    op &lt;- par(no.readonly = TRUE)
    
    par(mar=c(5, 6.5, 0.5, 0.5))
    plotAvailWater(x, name.cex = 1)
    
    par(op)
    
  }
  
  
  # use some real data from SSURGO
  if(requireNamespace("curl") &amp;
     curl::has_internet() &amp;
     require(soilDB)) {
    
    q &lt;- "SELECT hzdept_r as hztop, hzdepb_r as hzbottom, 
hzname as name, wsatiated_r/100.0 as sat, 
wthirdbar_r/100.0 as fc, wfifteenbar_r/100.0 as pwp, awc_r as awc
FROM chorizon 
WHERE cokey IN (SELECT cokey from component where compname = 'dunstone') 
AND wsatiated_r IS NOT NULL 
ORDER BY cokey, hzdept_r ASC;"
    
    x &lt;- SDA_query(q)
    x &lt;- unique(x)
    x &lt;- x[order(x$name), ]
    x$solid &lt;- with(x, 1-sat)
    
    op &lt;- par(no.readonly = TRUE)
    
    par(mar=c(5, 5, 0.5, 0.5))
    plotAvailWater(x)
    
    par(op)
  }
  


</code></pre>

<hr>
<h2 id='plotGeomorphCrossSection'>Present a <code>SoilProfileCollection</code> aligned to a geomorphic summary as cross-section.</h2><span id='topic+plotGeomorphCrossSection'></span>

<h3>Description</h3>

<p>Present a <code>SoilProfileCollection</code> aligned to a geomorphic summary as cross-section.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotGeomorphCrossSection(
  x,
  type = c("line", "bar"),
  g = "hillpos",
  clust = TRUE,
  col = c("#377EB8", "#4DAF4A", "#984EA3", "#FF7F00", "#E41A1C"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotGeomorphCrossSection_+3A_x">x</code></td>
<td>
<p>resulting list from <code>soilDB::fetchOSD(..., extended = TRUE)</code></p>
</td></tr>
<tr><td><code id="plotGeomorphCrossSection_+3A_type">type</code></td>
<td>
<p>character, 'line' for line plot or 'bar' for barplot of geomorphic proportions</p>
</td></tr>
<tr><td><code id="plotGeomorphCrossSection_+3A_g">g</code></td>
<td>
<p>character, select a geomorphic summary. Currently 'hillpos' (2D hillslope position) is the only supported choice.</p>
</td></tr>
<tr><td><code id="plotGeomorphCrossSection_+3A_clust">clust</code></td>
<td>
<p>logical, use clustering order of geomorphic proportions (<code>TRUE</code>) or exact hydrologic ordering (<code>FALSE</code>), see <code><a href="#topic+hydOrder">hydOrder()</a></code></p>
</td></tr>
<tr><td><code id="plotGeomorphCrossSection_+3A_col">col</code></td>
<td>
<p>character vector of colors</p>
</td></tr>
<tr><td><code id="plotGeomorphCrossSection_+3A_...">...</code></td>
<td>
<p>additional arguments to <code><a href="#topic+iterateHydOrder">iterateHydOrder()</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Additional arguments to <code><a href="aqp.html#topic+SoilProfileCollection-plotting-methods">aqp::plotSPC()</a></code> can be provided using <code>options(.aqp.plotSPC.args = list(...))</code>. For example, adjustments to maximum depth and profile width can be set via: <code style="white-space: pre;">&#8288;options(.aqp.plotSPC.args = list(max.depth = 150, width = 0.35)&#8288;</code>. Default arguments can be reset with <code style="white-space: pre;">&#8288;options(.aqp.plotSPC.args = NULL&#8288;</code>).
</p>
<p>When <code>clust = TRUE</code>, especially for <code>SoilProfileCollections</code> with a wide range in depth, it may be necessary to adjust the <code>scaling.factor</code> argument to <code><a href="aqp.html#topic+SoilProfileCollection-plotting-methods">aqp::plotSPC()</a></code> via: <code>options(.aqp.plotSPC.args = list(scaling.factor = 0.01))</code>. Larger values will increase the height of profile sketches.
</p>


<h3>Author(s)</h3>

<p>D.E. Beaudette
</p>

<hr>
<h2 id='plotProfileDendrogram'>Plot soil profiles below a dendrogram</h2><span id='topic+plotProfileDendrogram'></span>

<h3>Description</h3>

<p>Plot soil profiles below a dendrogram
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotProfileDendrogram(
  x,
  clust,
  rotateToProfileID = FALSE,
  scaling.factor = 0.01,
  width = 0.1,
  y.offset = 0.1,
  dend.y.scale = max(clust$height * 2, na.rm = TRUE),
  dend.color = par("fg"),
  dend.width = 1,
  dend.type = c("phylogram", "cladogram"),
  debug = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotProfileDendrogram_+3A_x">x</code></td>
<td>
<p>a <code>SoilProfileCollection</code> object</p>
</td></tr>
<tr><td><code id="plotProfileDendrogram_+3A_clust">clust</code></td>
<td>
<p>a hierarchical clustering object generated by <code>hclust</code>, <code>cluster::agnes</code>, or <code>cluster::diana</code></p>
</td></tr>
<tr><td><code id="plotProfileDendrogram_+3A_rotatetoprofileid">rotateToProfileID</code></td>
<td>
<p>logical, attempt rotation of dendrogram according to original profile IDs, requires <code>dendExtend</code> package</p>
</td></tr>
<tr><td><code id="plotProfileDendrogram_+3A_scaling.factor">scaling.factor</code></td>
<td>
<p>vertical scaling of the profile heights (may have to tinker with this)</p>
</td></tr>
<tr><td><code id="plotProfileDendrogram_+3A_width">width</code></td>
<td>
<p>scaling of profile widths</p>
</td></tr>
<tr><td><code id="plotProfileDendrogram_+3A_y.offset">y.offset</code></td>
<td>
<p>vertical offset for top of profiles</p>
</td></tr>
<tr><td><code id="plotProfileDendrogram_+3A_dend.y.scale">dend.y.scale</code></td>
<td>
<p>extent of y-axis (may have to tinker with this)</p>
</td></tr>
<tr><td><code id="plotProfileDendrogram_+3A_dend.color">dend.color</code></td>
<td>
<p>dendrogram line color</p>
</td></tr>
<tr><td><code id="plotProfileDendrogram_+3A_dend.width">dend.width</code></td>
<td>
<p>dendrogram line width</p>
</td></tr>
<tr><td><code id="plotProfileDendrogram_+3A_dend.type">dend.type</code></td>
<td>
<p>dendrogram type, passed to <code>plot.phylo()</code>, either &quot;phylogram&quot; or &quot;cladogram&quot;</p>
</td></tr>
<tr><td><code id="plotProfileDendrogram_+3A_debug">debug</code></td>
<td>
<p>logical,optionally print debugging data</p>
</td></tr>
<tr><td><code id="plotProfileDendrogram_+3A_...">...</code></td>
<td>
<p>additional arguments to <code>plotSPC</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function places soil profile sketches below a dendrogram.
</p>


<h3>Value</h3>

<p>a <code>data.frame</code> of IDs and linking structure
</p>


<h3>Note</h3>

<p>You may have to tinker with some of the arguments to get optimal arrangement and scaling of soil profiles.
</p>


<h3>Author(s)</h3>

<p>D.E. Beaudette
</p>

<hr>
<h2 id='plotSoilRelationChordGraph'>Visualize Soil Relationships via Chord Diagram</h2><span id='topic+plotSoilRelationChordGraph'></span>

<h3>Description</h3>

<p>Visualize Soil Relationships via Chord Diagram
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotSoilRelationChordGraph(
  m,
  s,
  mult = 2,
  base.color = "grey",
  highlight.colors = c("RoyalBlue", "DarkOrange", "DarkGreen"),
  add.legend = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotSoilRelationChordGraph_+3A_m">m</code></td>
<td>
<p>an adjacency matrix, no <code>NA</code> allowed</p>
</td></tr>
<tr><td><code id="plotSoilRelationChordGraph_+3A_s">s</code></td>
<td>
<p>soil of interest, must exist in the column or row names of <code>m</code></p>
</td></tr>
<tr><td><code id="plotSoilRelationChordGraph_+3A_mult">mult</code></td>
<td>
<p>multiplier used to re-scale data in <code>m</code> associated with <code>s</code></p>
</td></tr>
<tr><td><code id="plotSoilRelationChordGraph_+3A_base.color">base.color</code></td>
<td>
<p>color for all soils other than <code>s</code> and 1st and 2nd most commonly co-occurring soils</p>
</td></tr>
<tr><td><code id="plotSoilRelationChordGraph_+3A_highlight.colors">highlight.colors</code></td>
<td>
<p>vector of 3 colors: soil of interest, 1st most common, 2nd most common</p>
</td></tr>
<tr><td><code id="plotSoilRelationChordGraph_+3A_add.legend">add.legend</code></td>
<td>
<p><code>logical</code>, add a legend</p>
</td></tr>
<tr><td><code id="plotSoilRelationChordGraph_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code>circlize::chordDiagramFromMatrix</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is experimental. Documentation pending. See <a href="http://jokergoo.github.io/circlize/">http://jokergoo.github.io/circlize/</a> for ideas.
</p>


<h3>Value</h3>

<p>nothing, function is called to generate graphical output
</p>


<h3>Author(s)</h3>

<p>D.E. Beaudette
</p>

<hr>
<h2 id='plotSoilRelationGraph'>Plot a component relation graph</h2><span id='topic+plotSoilRelationGraph'></span>

<h3>Description</h3>

<p>Plot a component relation graph based on an adjacency or similarity matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotSoilRelationGraph(
  m,
  s = "",
  plot.style = c("network", "dendrogram", "none"),
  graph.mode = "upper",
  spanning.tree = NULL,
  del.edges = NULL,
  vertex.scaling.method = "degree",
  vertex.scaling.factor = 2,
  edge.scaling.factor = 1,
  vertex.alpha = 0.65,
  edge.transparency = 1,
  edge.col = grey(0.5),
  edge.highlight.col = "royalblue",
  g.layout = igraph::layout_with_fr,
  vertex.label.color = "black",
  delete.singletons = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotSoilRelationGraph_+3A_m">m</code></td>
<td>
<p>adjacency matrix</p>
</td></tr>
<tr><td><code id="plotSoilRelationGraph_+3A_s">s</code></td>
<td>
<p>central component; an empty character string is interpreted as no central component</p>
</td></tr>
<tr><td><code id="plotSoilRelationGraph_+3A_plot.style">plot.style</code></td>
<td>
<p>plot style ('network', or 'dendrogram'), or 'none' for no graphical output</p>
</td></tr>
<tr><td><code id="plotSoilRelationGraph_+3A_graph.mode">graph.mode</code></td>
<td>
<p>interpretation of adjacency matrix: 'upper' or 'directed', see details</p>
</td></tr>
<tr><td><code id="plotSoilRelationGraph_+3A_spanning.tree">spanning.tree</code></td>
<td>
<p>plot the minimum or maximum spanning tree ('min', 'max'), or, max spanning tree plus edges with weight greater than the n-th quantile specified in <code>spanning.tree</code>. See details and examples.</p>
</td></tr>
<tr><td><code id="plotSoilRelationGraph_+3A_del.edges">del.edges</code></td>
<td>
<p>optionally delete edges with weights less than the specified quantile (0-1)</p>
</td></tr>
<tr><td><code id="plotSoilRelationGraph_+3A_vertex.scaling.method">vertex.scaling.method</code></td>
<td>
<p>'degree' (default) or 'distance', see details</p>
</td></tr>
<tr><td><code id="plotSoilRelationGraph_+3A_vertex.scaling.factor">vertex.scaling.factor</code></td>
<td>
<p>scaling factor applied to vertex size</p>
</td></tr>
<tr><td><code id="plotSoilRelationGraph_+3A_edge.scaling.factor">edge.scaling.factor</code></td>
<td>
<p>optional scaling factor applied to edge width</p>
</td></tr>
<tr><td><code id="plotSoilRelationGraph_+3A_vertex.alpha">vertex.alpha</code></td>
<td>
<p>optional transparency setting for vertices (0-1)</p>
</td></tr>
<tr><td><code id="plotSoilRelationGraph_+3A_edge.transparency">edge.transparency</code></td>
<td>
<p>optional transparency setting for edges (0-1)</p>
</td></tr>
<tr><td><code id="plotSoilRelationGraph_+3A_edge.col">edge.col</code></td>
<td>
<p>edge color, applied to all edges</p>
</td></tr>
<tr><td><code id="plotSoilRelationGraph_+3A_edge.highlight.col">edge.highlight.col</code></td>
<td>
<p>edge color applied to all edges connecting to component named in <code>s</code></p>
</td></tr>
<tr><td><code id="plotSoilRelationGraph_+3A_g.layout">g.layout</code></td>
<td>
<p>an igraph layout function, defaults to <code>igraph::layout_with_fr</code></p>
</td></tr>
<tr><td><code id="plotSoilRelationGraph_+3A_vertex.label.color">vertex.label.color</code></td>
<td>
<p>vertex label color</p>
</td></tr>
<tr><td><code id="plotSoilRelationGraph_+3A_delete.singletons">delete.singletons</code></td>
<td>
<p>optionally delete vertices with no edges (<code>degree == 0</code>)</p>
</td></tr>
<tr><td><code id="plotSoilRelationGraph_+3A_...">...</code></td>
<td>
<p>further arguments passed to plotting function</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Vertex size is based on a normalized index of connectivity:
</p>

<ul>
<li><p> &quot;degree&quot; size = <code>sqrt(igraph::degree(g) / max(igraph::degree(g))) * scaling.factor</code>
</p>
</li>
<li><p> &quot;distance&quot; size = <code>sqrt(igraph::distance(V -&gt; s) / max(igraph::distance(V -&gt; s))) * scaling.factor</code>, where distance(V-&gt;s) is the distance from all nodes to the named series, <code>s</code>.
</p>
</li></ul>

<p>Edge width can be optionally scaled by edge weight by specifying an <code>edge.scaling.factor</code> value. The maximum spanning tree represents a sub-graph where the sum of edge weights are maximized. The minimum spanning tree represents a sub-graph where the sum of edge weights are minimized. The maximum spanning tree is likely a more useful simplification of the full graph, in which only the strongest relationships (e.g. most common co-occurrences) are preserved.
</p>
<p>The maximum spanning tree + edges with weights &gt; n-th quantile is an experimental hybrid. The 'backbone' of the graph is created by the maximum spanning tree, and augmented by 'strong' auxiliary edges&ndash;defined by a value between 0 and 1.
</p>
<p>The <code>graph.mode</code> argument is passed to <code>igraph::graph_from_adjacency_matrix()</code> and determines how vertex relationships are coded in the adjacency matrix <code>m</code>. Typically, the default value of 'upper' (the upper triangle of <code>m</code> contains adjacency information) is the desired mode. If <code>m</code> contains directional information, set <code>graph.mode</code> to 'directed'. This has the side-effect of altering the default community detection algorithm from <code>igraph::cluster_fast_greedy</code> to <code>igraph::cluster_walktrap</code>.
</p>


<h3>Value</h3>

<p>an igraph <code>graph</code> object is invisibly returned
</p>


<h3>Note</h3>

<p>This function is a work in progress, ideas welcome.
</p>


<h3>Author(s)</h3>

<p>D.E. Beaudette
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (requireNamespace("igraph")) {
  # load sample data set
  data(amador)

  # create weighted adjacency matrix (see ?component.adj.matrix for details)
  m &lt;- component.adj.matrix(amador)

  # plot network diagram, with Amador soil highlighted
  plotSoilRelationGraph(m, s='amador')

  # dendrogram representation
  plotSoilRelationGraph(m, s='amador', plot.style='dendrogram')

  # compare methods
  m.o &lt;- component.adj.matrix(amador, method='occurrence')

  op &lt;- par(no.readonly = TRUE)

  par(mfcol=c(1,2))
  plotSoilRelationGraph(m, s='amador', plot.style='dendrogram')
  title('community matrix')
  plotSoilRelationGraph(m.o, s='amador', plot.style='dendrogram')
  title('occurence')

  # investigate max spanning tree
  plotSoilRelationGraph(m, spanning.tree='max')

  # investigate max spanning tree + edges with weights &gt; 75-th pctile
  plotSoilRelationGraph(m, spanning.tree=0.75)

  par(op)

  
  
    if(requireNamespace("curl") &amp;
       curl::has_internet() &amp;
       require(soilDB)) {
    
      # get similar data from soilweb, for the Pardee series
      s &lt;- 'pardee'
      d &lt;- siblings(s, component.data = TRUE)
    
      # normalize component names
      d$sib.data$compname &lt;- tolower(d$sib.data$compname)
    
      # keep only major components
      d$sib.data &lt;- subset(d$sib.data, subset=compkind == 'Series')
    
      # build adj. matrix and plot
      m &lt;- component.adj.matrix(d$sib.data)
      plotSoilRelationGraph(m, s=s, plot.style='dendrogram')
    
      # alter plotting style, see ?plot.phylo
      plotSoilRelationGraph(m, s=s, plot.style='dendrogram', type='fan')
      plotSoilRelationGraph(m, s=s, plot.style='dendrogram', 
                            type='unrooted', use.edge.length=FALSE) 
    
    }
  
}
</code></pre>

<hr>
<h2 id='plotTransect'>Arrange Profiles along a Transect</h2><span id='topic+plotTransect'></span>

<h3>Description</h3>

<p>Plot a collection of Soil Profiles linked to their position along some gradient (e.g. transect).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotTransect(
  s,
  xy,
  grad.var.name,
  grad.var.order = order(site(s)[[grad.var.name]]),
  transect.col = "RoyalBlue",
  tick.number = 7,
  y.offset = 100,
  scaling.factor = 0.5,
  distance.axis.title = "Distance Along Transect (km)",
  grad.axis.title = NULL,
  dist.scaling.factor = 1000,
  spacing = c("regular", "relative"),
  fix.relative.pos = list(thresh = 0.6, maxIter = 5000),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotTransect_+3A_s">s</code></td>
<td>
<p><code>SoilProfileCollection</code> object</p>
</td></tr>
<tr><td><code id="plotTransect_+3A_xy">xy</code></td>
<td>
<p><code>sf</code> object, defining point coordinates of soil profiles, must be in same order as <code>s</code>, must be a projected coordinate reference system (UTM, AEA, etc.)</p>
</td></tr>
<tr><td><code id="plotTransect_+3A_grad.var.name">grad.var.name</code></td>
<td>
<p>the name of a site-level attribute containing gradient values</p>
</td></tr>
<tr><td><code id="plotTransect_+3A_grad.var.order">grad.var.order</code></td>
<td>
<p>optional indexing vector used to override sorting along <code>grad.var.name</code></p>
</td></tr>
<tr><td><code id="plotTransect_+3A_transect.col">transect.col</code></td>
<td>
<p>color used to plot gradient (transect) values</p>
</td></tr>
<tr><td><code id="plotTransect_+3A_tick.number">tick.number</code></td>
<td>
<p>number of desired ticks and labels on the gradient axis</p>
</td></tr>
<tr><td><code id="plotTransect_+3A_y.offset">y.offset</code></td>
<td>
<p>vertical offset used to position profile sketches</p>
</td></tr>
<tr><td><code id="plotTransect_+3A_scaling.factor">scaling.factor</code></td>
<td>
<p>scaling factor applied to profile sketches</p>
</td></tr>
<tr><td><code id="plotTransect_+3A_distance.axis.title">distance.axis.title</code></td>
<td>
<p>a title for the along-transect distances</p>
</td></tr>
<tr><td><code id="plotTransect_+3A_grad.axis.title">grad.axis.title</code></td>
<td>
<p>a title for the gradient axis</p>
</td></tr>
<tr><td><code id="plotTransect_+3A_dist.scaling.factor">dist.scaling.factor</code></td>
<td>
<p>scaling factor (divisor) applied to linear distance units, default is conversion from m to km (1000)</p>
</td></tr>
<tr><td><code id="plotTransect_+3A_spacing">spacing</code></td>
<td>
<p>profile sketch spacing style: &quot;regular&quot; (profiles aligned to an integer grid) or &quot;relative&quot; (relative distance along transect)</p>
</td></tr>
<tr><td><code id="plotTransect_+3A_fix.relative.pos">fix.relative.pos</code></td>
<td>
<p>adjust relative positions in the presence of overlap, <code>FALSE</code> to suppress, otherwise list of arguments to <code>aqp::fixOverlap</code></p>
</td></tr>
<tr><td><code id="plotTransect_+3A_...">...</code></td>
<td>
<p>further arguments passed to <code>aqp::plotSPC</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Depending on the nature of your <code>SoilProfileCollection</code> and associated gradient values, it may be necessary to tinker with figure margins, <code>y.offset</code> and <code>scaling.factor</code>.
</p>


<h3>Value</h3>

<p>An invisibly-returned <code>data.frame</code> object:
</p>

<ul>
<li><p> scaled.grad: scaled gradient values
</p>
</li>
<li><p> scaled.distance: cumulative distance, scaled to the interval of <code style="white-space: pre;">&#8288;0.5, nrow(coords) + 0.5&#8288;</code>
</p>
</li>
<li><p> distance: cumulative distance computed along gradient, e.g. transect distance
</p>
</li>
<li><p> variable: sorted gradient values
</p>
</li>
<li><p> x: x coordinates, ordered by gradient values
</p>
</li>
<li><p> y: y coordinate, ordered by gradient values
</p>
</li>
<li><p> grad.order: a vector index describing the sort order defined by gradient values
</p>
</li></ul>



<h3>Note</h3>

<p>This function is very much a work in progress, ideas welcome!
</p>


<h3>Author(s)</h3>

<p>D.E. Beaudette
</p>


<h3>Examples</h3>

<pre><code class='language-R'>


if(require(aqp) &amp; 
require(sf) &amp;
  require(soilDB)
) {
   
library(aqp)
library(soilDB)
library(sf)


# sample data
data("mineralKing", package = "soilDB")

# device options are modified locally, reset when done
op &lt;- par(no.readonly = TRUE)

# quick overview
par(mar=c(1,1,2,1))
groupedProfilePlot(mineralKing, groups='taxonname', print.id=FALSE)

# setup point locations
s &lt;- site(mineralKing)
xy &lt;- st_as_sf(s, coords = c('x_std', 'y_std'))
st_crs(xy) &lt;- 4326

# convert to suitable projected cRS
# projected CRS, UTM z11 NAD83 (https://epsg.io/26911)
xy &lt;- st_transform(xy, 26911) 

# adjust margins
par(mar = c(4.5, 4, 4, 1))

# standard transect plot, profile sketches arranged along integer sequence
plotTransect(mineralKing, xy, grad.var.name = 'elev_field',
             grad.axis.title = 'Elevation (m)', label = 'pedon_id', name = 'hzname')

# default behavior, attempt adjustments to prevent over-plot and preserve relative spacing
# use set.seed() to fix outcome
plotTransect(mineralKing, xy, grad.var.name = 'elev_field',
             grad.axis.title = 'Elevation (m)', label = 'pedon_id',
             name = 'hzname', width = 0.15, spacing = 'relative')

# attempt relative positioning based on scaled distances, no corrections for overlap
# profiles are clustered in space and therefore over-plot
plotTransect(mineralKing, xy, grad.var.name = 'elev_field',
             grad.axis.title = 'Elevation (m)', label = 'pedon_id', name = 'hzname',
             width = 0.15, spacing = 'relative', fix.relative.pos = FALSE)

# customize arguments to aqp::fixOverlap()
plotTransect(mineralKing, xy, grad.var.name = 'elev_field', crs = crs.utm,
             grad.axis.title = 'Elevation (m)', label = 'pedon_id', name = 'hzname',
             width = 0.15, spacing = 'relative',
             fix.relative.pos = list(maxIter=6000, adj=0.2, thresh=0.7))

plotTransect(mineralKing, xy, grad.var.name = 'elev_field', crs = crs.utm,
             grad.axis.title = 'Elevation (m)', label = 'pedon_id', name = 'hzname',
             width = 0.2, spacing = 'relative',
             fix.relative.pos = list(maxIter = 6000, adj = 0.2, thresh = 0.6),
             name.style = 'center-center')

par(op)
  
}



</code></pre>

<hr>
<h2 id='plotWB'>Visualize Monthly Water Balance</h2><span id='topic+plotWB'></span>

<h3>Description</h3>

<p>This function offers one possible visualization for the results of <code>monthlyWB()</code>. Note that &quot;surplus&quot; water is stacked on top of &quot;actual ET&quot;, and &quot;deficit&quot; water is stacked below &quot;storage&quot;. Calculate actual values for &quot;surplus&quot; and &quot;deficit&quot; from the figure like this:
</p>

<ul>
<li><p> surplus value = surplus - AET
</p>
</li>
<li><p> deficit value = deficit - storage
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>plotWB(
  WB,
  AWC = attr(WB, "AWC"),
  sw.col = "#377EB8",
  surplus.col = "#4DAF4A",
  et.col = "#E41A1C",
  deficit.col = "#FF7F00",
  pch = c(21, 21),
  pt.cex = 1,
  pt.col = par("bg"),
  pt.bg = par("fg"),
  lty = c(1, 2),
  lwd = 2,
  n.ticks = 8,
  grid.col = grey(0.65),
  month.cex = 1,
  legend.cex = 0.9,
  ylim
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotWB_+3A_wb">WB</code></td>
<td>
<p>output from <code>monthlyWB()</code></p>
</td></tr>
<tr><td><code id="plotWB_+3A_awc">AWC</code></td>
<td>
<p>available water-holding capacity (mm), typically the value used in <code>monthlyWB()</code> and stored as an attribute of <code>WB</code></p>
</td></tr>
<tr><td><code id="plotWB_+3A_sw.col">sw.col</code></td>
<td>
<p>color for soil water (&quot;storage)</p>
</td></tr>
<tr><td><code id="plotWB_+3A_surplus.col">surplus.col</code></td>
<td>
<p>color for surplus water</p>
</td></tr>
<tr><td><code id="plotWB_+3A_et.col">et.col</code></td>
<td>
<p>color for ET</p>
</td></tr>
<tr><td><code id="plotWB_+3A_deficit.col">deficit.col</code></td>
<td>
<p>color for deficit</p>
</td></tr>
<tr><td><code id="plotWB_+3A_pch">pch</code></td>
<td>
<p>plotting character for PPT and PET points</p>
</td></tr>
<tr><td><code id="plotWB_+3A_pt.cex">pt.cex</code></td>
<td>
<p>character expansion factor for PPT and PET points</p>
</td></tr>
<tr><td><code id="plotWB_+3A_pt.col">pt.col</code></td>
<td>
<p>point symbol color for PPT and PET points</p>
</td></tr>
<tr><td><code id="plotWB_+3A_pt.bg">pt.bg</code></td>
<td>
<p>point symbol background color for PPT and PET points</p>
</td></tr>
<tr><td><code id="plotWB_+3A_lty">lty</code></td>
<td>
<p>line type for PPT and PET lines (<code>c(1, 2)</code>)</p>
</td></tr>
<tr><td><code id="plotWB_+3A_lwd">lwd</code></td>
<td>
<p>line width for PPT and PET curves</p>
</td></tr>
<tr><td><code id="plotWB_+3A_n.ticks">n.ticks</code></td>
<td>
<p>approximate number of tick marks on positive and negative y-axis</p>
</td></tr>
<tr><td><code id="plotWB_+3A_grid.col">grid.col</code></td>
<td>
<p>horizontal grid line color</p>
</td></tr>
<tr><td><code id="plotWB_+3A_month.cex">month.cex</code></td>
<td>
<p>scaling factor for month labels (x-axis)</p>
</td></tr>
<tr><td><code id="plotWB_+3A_legend.cex">legend.cex</code></td>
<td>
<p>scaling factor for legend</p>
</td></tr>
<tr><td><code id="plotWB_+3A_ylim">ylim</code></td>
<td>
<p>optional vector of y-axis limits, <code>c(-min, max)</code>, typically used when comparing drastically different water balances in the same figure. Default limits are usually best for a single water balance plot.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>nothing, function is called to generate graphical output
</p>


<h3>Note</h3>

<p>You may have to adjust figure margins and size to get all of the elements to &quot;look right&quot;.
</p>


<h3>Author(s)</h3>

<p>D.E. Beaudette and J.M. Skovlin
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if(requireNamespace('hydromad')) {

## A shallow / droughty soil near Sonora CA 
# 100mm (4") AWC
AWC &lt;- 100
PPT &lt;- c(171, 151, 138, 71, 36, 7, 1, 2, 11, 48, 102, 145)
PET &lt;- c(15.17, 18.26, 30.57, 42.95, 75.37, 108.05, 139.74, 128.9, 93.99, 59.84, 26.95, 14.2)

# water-year
# three years
x.wb &lt;- monthlyWB(AWC, PPT, PET, S_init = 0, starting_month = 9, rep = 3)
x.wb[x.wb$mo == 'Sep', ]

# plot all three years
plotWB(x.wb)

# water-year / last iteration
x.wb &lt;- monthlyWB(AWC, PPT, PET, S_init = 0, 
                  starting_month = 9, rep = 3, 
                  keep_last = TRUE
)

# plot
plotWB(x.wb)


## Drummer series (Fine-silty, mixed, superactive, mesic Typic Endoaquolls), southern IL

AWC &lt;- 244
PPT &lt;- c(36, 37, 54, 82, 98, 96, 92, 75, 69, 70, 65, 50)
PET &lt;- c(0, 0, 12, 46, 90, 130, 145, 128, 88, 46, 14, 0)

# using calendar year
x.wb &lt;- monthlyWB(AWC, PPT, PET, S_init = 0,
                  starting_month = 1, rep = 3,
                  keep_last = TRUE
)

plotWB(x.wb)

}

</code></pre>

<hr>
<h2 id='plotWB_lines'>Line / Area Visualization for Monthly Water Balance</h2><span id='topic+plotWB_lines'></span>

<h3>Description</h3>

<p>Pending.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotWB_lines(
  WB,
  cols = c("#759CC9", "#EB6D6E", "#7FC47D"),
  line.col = "black",
  line.lty = c(1, 2, 3),
  interpolator = c("spline", "linear"),
  spline.method = c("natural", "periodic"),
  month.cex = 1,
  legend.cex = 0.9
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotWB_lines_+3A_wb">WB</code></td>
<td>
<p>output from <code><a href="#topic+monthlyWB">monthlyWB()</a></code></p>
</td></tr>
<tr><td><code id="plotWB_lines_+3A_cols">cols</code></td>
<td>
<p>vector of three colors used for area under PPT, PET, and AET curves</p>
</td></tr>
<tr><td><code id="plotWB_lines_+3A_line.col">line.col</code></td>
<td>
<p>single color used for PPT, PET, and AET lines</p>
</td></tr>
<tr><td><code id="plotWB_lines_+3A_line.lty">line.lty</code></td>
<td>
<p>vector of three line styles used for PPT, PET, AET curves</p>
</td></tr>
<tr><td><code id="plotWB_lines_+3A_interpolator">interpolator</code></td>
<td>
<p>spline or linear interpolation of monthly values, use of <code>spline</code> may lead to minor smoothing artifacts in shaded areas</p>
</td></tr>
<tr><td><code id="plotWB_lines_+3A_spline.method">spline.method</code></td>
<td>
<p>when <code>interpolator = 'spline'</code>, argument passed to <code>splinefun(..., method = spline.method)</code></p>
</td></tr>
<tr><td><code id="plotWB_lines_+3A_month.cex">month.cex</code></td>
<td>
<p>scaling factor for month labels</p>
</td></tr>
<tr><td><code id="plotWB_lines_+3A_legend.cex">legend.cex</code></td>
<td>
<p>scaling factor for legend</p>
</td></tr>
</table>


<h3>Value</h3>

<p>nothing, function is called to generate graphical output
</p>


<h3>Author(s)</h3>

<p>J.M. Skovlin and D.E. Beaudette
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if(requireNamespace('hydromad')) {

## A shallow / droughty soil near Sonora CA 
# 100mm (4") AWC
AWC &lt;- 100
PPT &lt;- c(171, 151, 138, 71, 36, 7, 1, 2, 11, 48, 102, 145)
PET &lt;- c(15.17, 18.26, 30.57, 42.95, 75.37, 108.05, 139.74, 128.9, 93.99, 59.84, 26.95, 14.2)

# calendar-year
# three year warm-up
x.wb &lt;- monthlyWB(AWC, PPT, PET, S_init = 0, starting_month = 1, rep = 3, keep_last = TRUE)
 
# plot
plotWB_lines(x.wb)

}

</code></pre>

<hr>
<h2 id='PLSS2LL'>PLSS2LL</h2><span id='topic+PLSS2LL'></span>

<h3>Description</h3>

<p>Fetch latitude and longitude (centroid) coordinates for coded PLSS information from the BLM PLSS web service.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PLSS2LL(p, plssid = "plssid")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PLSS2LL_+3A_p">p</code></td>
<td>
<p><code>data.frame</code> with chunks of PLSS definition</p>
</td></tr>
<tr><td><code id="PLSS2LL_+3A_plssid">plssid</code></td>
<td>
<p>column name containing PLSS ID</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code> of PLSS codes and coordinates.
</p>


<h3>Note</h3>

<p>This function expects that the dataframe will have a 'plssid' column generated by the <code>formatPLSS</code> function. Requires the following packages: <code>httr</code>, and <code>jsonlite</code>.
</p>


<h3>Author(s)</h3>

<p>D.E. Beaudette, Jay Skovlin, A.G. Brown
</p>


<h3>See Also</h3>

<p><code><a href="#topic+LL2PLSS">LL2PLSS</a></code>, <code><a href="#topic+formatPLSS">formatPLSS</a></code>
</p>

<hr>
<h2 id='polygonAdjacency'>Summarize Spatial Adjacency of Polygon Fabric</h2><span id='topic+polygonAdjacency'></span>

<h3>Description</h3>

<p>This function utilizes the <code>spdep</code> and <code>igraph</code> packages to evaluate several measures of spatial connectivity.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>polygonAdjacency(x, v = "MUSYM", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="polygonAdjacency_+3A_x">x</code></td>
<td>
<p><code>sf</code> object containing simple polygon features, some of which should share edges</p>
</td></tr>
<tr><td><code id="polygonAdjacency_+3A_v">v</code></td>
<td>
<p>character, name of column in attribute table describing map unit labels</p>
</td></tr>
<tr><td><code id="polygonAdjacency_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code><a href="spdep.html#topic+poly2nb">spdep::poly2nb()</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Examples are presented in <a href="http://ncss-tech.github.io/AQP/sharpshootR/common-soil-lines.html">this tutorial</a>.
</p>


<h3>Value</h3>

<p>a <code>list</code> containing:
</p>

<ul>
<li> <p><code>commonLines</code>: an integer vector of feature IDs, describing polygons sharing edges and values of <code>v</code> (map unit labels)
</p>
</li>
<li> <p><code>adjMat</code>: weighted adjacency matrix, suitable for visualization with  <code><a href="#topic+plotSoilRelationGraph">plotSoilRelationGraph()</a></code>
</p>
</li></ul>



<h3>Author(s)</h3>

<p>D.E. Beaudette
</p>

<hr>
<h2 id='prepare_SSURGO_hydro_data'>Get and prepare basic soil hydraulic parameters from SSURGO via SDA</h2><span id='topic+prepare_SSURGO_hydro_data'></span>

<h3>Description</h3>

<p>Get and prepare basic soil hydraulic parameters from SSURGO via SDA
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prepare_SSURGO_hydro_data(cokeys, max.depth)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prepare_SSURGO_hydro_data_+3A_cokeys">cokeys</code></td>
<td>
<p>vector of component keys (cokey) in current SSURGO snapshot</p>
</td></tr>
<tr><td><code id="prepare_SSURGO_hydro_data_+3A_max.depth">max.depth</code></td>
<td>
<p>target depth of aggregation (cm), corrected later by real soil depth as reported by <code>slab()</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Weighted mean soil hydraulic parameters are returned over the interval of <code>0-max.depth</code>, calculated by <code>aqp::slab()</code>.
</p>


<h3>Value</h3>

<p>a <code>list</code> containing:
</p>

<ul>
<li> <p><code>SPC</code>: <code>SoilProfileCollection</code>
</p>
</li>
<li> <p><code>agg</code>: aggregate representation of hydraulic parameters, by cokey
</p>
</li></ul>

<p>The following soil hydraulic properties are included:</p>

<table>
<tr>
 <td style="text-align: left;">
   variable </td><td style="text-align: left;"> description </td>
</tr>
<tr>
 <td style="text-align: left;">
   cokey </td><td style="text-align: left;"> component key </td>
</tr>
<tr>
 <td style="text-align: left;">
   hzname </td><td style="text-align: left;"> horizon name </td>
</tr>
<tr>
 <td style="text-align: left;">
   hz_top </td><td style="text-align: left;"> horizon top depth (cm) </td>
</tr>
<tr>
 <td style="text-align: left;">
   hz_bottom </td><td style="text-align: left;"> horizon bottom depth (cm) </td>
</tr>
<tr>
 <td style="text-align: left;">
   thick </td><td style="text-align: left;"> horizon thickness (cm) </td>
</tr>
<tr>
 <td style="text-align: left;">
   sat </td><td style="text-align: left;"> VWC at saturation (cm/cm) </td>
</tr>
<tr>
 <td style="text-align: left;">
   fc </td><td style="text-align: left;"> VWC at field capacity defined by 1/3rd bar tension (cm/cm) </td>
</tr>
<tr>
 <td style="text-align: left;">
   fc_tenthbar </td><td style="text-align: left;"> VWC at field capacity defined by 1/3rd bar tension (cm/cm) </td>
</tr>
<tr>
 <td style="text-align: left;">
   pwp </td><td style="text-align: left;"> VWC at permanent wilting point or 15 bar tension (cm/cm) </td>
</tr>
<tr>
 <td style="text-align: left;">
   awc </td><td style="text-align: left;"> total sand content (&lt;2mm fraction, mass %) </td>
</tr>
<tr>
 <td style="text-align: left;">
   sand </td><td style="text-align: left;"> total silt content (&lt;2mm fraction, mass %) </td>
</tr>
<tr>
 <td style="text-align: left;">
   silt </td><td style="text-align: left;"> total clay content (&lt;2mm fraction, mass %) </td>
</tr>
<tr>
 <td style="text-align: left;">
   clay </td><td style="text-align: left;"> total sand content (&lt;2mm fraction, mass %) </td>
</tr>
<tr>
 <td style="text-align: left;">
   dbthirdbar </td><td style="text-align: left;"> bulk density at 1/3 bar tension (g/cm^3) </td>
</tr>
<tr>
 <td style="text-align: left;">
   ksat </td><td style="text-align: left;"> Ksat (um/second) </td>
</tr>
<tr>
 <td style="text-align: left;">
   soil_fraction </td><td style="text-align: left;"> volume fraction of soil (1 - coarse fragment volume fraction) </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Author(s)</h3>

<p>D.E. Beaudette
</p>

<hr>
<h2 id='prepareDailyClimateData'>Prepare daily climate data (DAYMET) for a single point</h2><span id='topic+prepareDailyClimateData'></span>

<h3>Description</h3>

<p>This function returns daily climate data required for a simple water balance (and more), using three packages:
</p>

<ul>
<li> <p><code>elevatr</code>: elevation data at <code>x</code>
</p>
</li>
<li> <p><code>daymetr</code>: DAYMET data at <code>x</code> for years <code>start</code> through <code>end</code>
</p>
</li>
<li> <p><code>Evapotranspiration</code>: Makkink formulation for estimating reference crop evapotranspiration
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>prepareDailyClimateData(x, start, end, onlyWB = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prepareDailyClimateData_+3A_x">x</code></td>
<td>
<p><code>sf</code> object representing a single point</p>
</td></tr>
<tr><td><code id="prepareDailyClimateData_+3A_start">start</code></td>
<td>
<p>start year (1998)</p>
</td></tr>
<tr><td><code id="prepareDailyClimateData_+3A_end">end</code></td>
<td>
<p>end year (2018)</p>
</td></tr>
<tr><td><code id="prepareDailyClimateData_+3A_onlywb">onlyWB</code></td>
<td>
<p>logical, return just those date required by <code>dailyWB</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>data.frame</code>
</p>

<hr>
<h2 id='reconcileOSDGeomorph'>Reconcile IDs between a SPC and associated geomorphic proportion table</h2><span id='topic+reconcileOSDGeomorph'></span>

<h3>Description</h3>

<p>This function can assist with linked visualizations that include soil morphology data stored in a <code>SoilProfileCollection</code> and geomorphic proportions stored in a <code>data.frame</code>, as returned by <code>soilDB::fetchOSD()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reconcileOSDGeomorph(
  x,
  selection = c("hillpos", "geomcomp", "flats", "mtnpos", "terrace", "shape_across",
    "shape_down")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reconcileOSDGeomorph_+3A_x">x</code></td>
<td>
<p>resulting list from <code>soilDB::fetchOSD(..., extended = TRUE)</code></p>
</td></tr>
<tr><td><code id="reconcileOSDGeomorph_+3A_selection">selection</code></td>
<td>
<p>character, name of geomorphic proportion table</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>list</code> with subset <code>SoilProfileCollection</code> and <code>data.frame</code> of geomorphic proportions, <code>selection</code> is preserved as an attribute.
</p>


<h3>Author(s)</h3>

<p>D.E. Beaudette
</p>

<hr>
<h2 id='sample.by.poly'>Sample a Polygon at Fixed Density</h2><span id='topic+sample.by.poly'></span>

<h3>Description</h3>

<p>Generate sampling points within a SpatialPolygon object, according to a specified sampling density.</p>


<h3>Usage</h3>

<pre><code class='language-R'>sample.by.poly(p, n.pts.per.ac=1, min.samples=5, 
sampling.type='regular', p4s=NULL)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sample.by.poly_+3A_p">p</code></td>
<td>
<p>a Polygon object, with coordinates in a projected CRS with units of meters</p>
</td></tr>
<tr><td><code id="sample.by.poly_+3A_n.pts.per.ac">n.pts.per.ac</code></td>
<td>
<p>requested sampling density in points per acre (results will be close)</p>
</td></tr>
<tr><td><code id="sample.by.poly_+3A_min.samples">min.samples</code></td>
<td>
<p>minimum requested number of samples per polygon</p>
</td></tr>
<tr><td><code id="sample.by.poly_+3A_sampling.type">sampling.type</code></td>
<td>
<p>sampling type</p>
</td></tr>
<tr><td><code id="sample.by.poly_+3A_p4s">p4s</code></td>
<td>
<p>a qualified proj4string that will be assigned to sampling points</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is typically accessed via some kind of helper function such as <code><a href="#topic+constantDensitySampling">constantDensitySampling</a></code>.</p>


<h3>Value</h3>

<p>A <code>SpatialPoints</code> object.</p>


<h3>Note</h3>

<p>This function expects that the <code>Polygon</code> object has coordinates associated with a projected CRS&ndash; e.g. units of meters. Invalid geometries may cause errors or yield incorrect sample sizes.</p>


<h3>Author(s)</h3>

<p>D.E. Beaudette</p>


<h3>See Also</h3>

<p><code><a href="#topic+constantDensitySampling">constantDensitySampling</a></code></p>

<hr>
<h2 id='sampleRasterStackByMU'>Sample a Raster Stack</h2><span id='topic+sampleRasterStackByMU'></span>

<h3>Description</h3>

<p>Sample a raster stack by map unit polygons, at a constant density.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sampleRasterStackByMU(
  mu,
  mu.set,
  mu.col,
  raster.list,
  pts.per.acre,
  p = c(0, 0.05, 0.25, 0.5, 0.75, 0.95, 1),
  progress = TRUE,
  estimateEffectiveSampleSize = TRUE,
  polygon.id = "pID"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sampleRasterStackByMU_+3A_mu">mu</code></td>
<td>
<p>a <code>SpatialPolygonsDataFrame</code> object in a projected coordinate reference system (CRS)</p>
</td></tr>
<tr><td><code id="sampleRasterStackByMU_+3A_mu.set">mu.set</code></td>
<td>
<p>character vector of map unit labels to be sampled</p>
</td></tr>
<tr><td><code id="sampleRasterStackByMU_+3A_mu.col">mu.col</code></td>
<td>
<p>column name in attribute table containing map unit labels</p>
</td></tr>
<tr><td><code id="sampleRasterStackByMU_+3A_raster.list">raster.list</code></td>
<td>
<p>a <code>list</code> containing raster names and paths, see details below</p>
</td></tr>
<tr><td><code id="sampleRasterStackByMU_+3A_pts.per.acre">pts.per.acre</code></td>
<td>
<p>target sampling density in <code style="white-space: pre;">&#8288;points per acre&#8288;</code></p>
</td></tr>
<tr><td><code id="sampleRasterStackByMU_+3A_p">p</code></td>
<td>
<p>percentiles for polygon area stats, e.g. <code>c(0.05, 0.25, 0.5, 0.75, 0.95)</code></p>
</td></tr>
<tr><td><code id="sampleRasterStackByMU_+3A_progress">progress</code></td>
<td>
<p>logical, print a progress bar while sampling?</p>
</td></tr>
<tr><td><code id="sampleRasterStackByMU_+3A_estimateeffectivesamplesize">estimateEffectiveSampleSize</code></td>
<td>
<p>estimate an effective sample size via Moran's I?</p>
</td></tr>
<tr><td><code id="sampleRasterStackByMU_+3A_polygon.id">polygon.id</code></td>
<td>
<p>Column name containing unique polygon IDs; default: <code>"pID"</code>; calculated if missing</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is used by various NRCS reports that summarize or compare concepts defined by collections of polygons using raster data sampled from within each polygon, at a constant sampling density. Even though the function name includes &quot;RasterStack&quot;, this function doesn't actually operate on the &quot;stack&quot; object as defined in the raster package. The collection of raster data defined in <code>raster.list</code> do not have to share a common coordinate reference system, grid spacing, or extent. Point samples generated from <code>mu</code> are automatically converted to the CRS of each raster before extracting values. The extent of each raster in <code>raster.list</code> must completely contain the extent of <code>mu</code>.
</p>


<h3>Value</h3>

<p>A <code>list</code> containing:
</p>

<dl>
<dt><code>raster.samples</code></dt><dd><p>a <code>data.frame</code> containing samples from all rasters in the stack</p>
</dd>
<dt><code>area.stats</code></dt><dd><p>a <code>data.frame</code> containing area statistics for all map units in the collection</p>
</dd>
<dt><code>unsampled.ids</code></dt><dd><p>an index to rows in the original SPDF associated with polygons not sampled</p>
</dd>
<dt><code>raster.summary</code></dt><dd><p>a <code>data.frame</code> containing information on sampled rasters</p>
</dd>
<dt><code>Moran_I</code></dt><dd><p>a <code>data.frame</code> containing estimates Moran's I (index of spatial autocorrelation)</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>D.E. Beaudette
</p>


<h3>See Also</h3>

<p><code><a href="#topic+constantDensitySampling">constantDensitySampling</a></code>, <code><a href="#topic+sample.by.poly">sample.by.poly</a></code>
</p>

<hr>
<h2 id='samplingStability'>Estimate Sampling Stability</h2><span id='topic+samplingStability'></span>

<h3>Description</h3>

<p>Stability is defined as the width of the 5th-95th percentile range, over n.reps replications of median estimates associated with sampling events. The resulting width is scaled by the population median and returned as a fraction.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>samplingStability(
  mu,
  r,
  n.set = c(0.01, 0.1, 0.5, 1, 2),
  n.reps = 10,
  p.id = "pID"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="samplingStability_+3A_mu">mu</code></td>
<td>
<p>map unit polygons, must have polygon ID, must be in CRS with units of meters</p>
</td></tr>
<tr><td><code id="samplingStability_+3A_r">r</code></td>
<td>
<p>SpatRaster</p>
</td></tr>
<tr><td><code id="samplingStability_+3A_n.set">n.set</code></td>
<td>
<p>set of sampling density values to try</p>
</td></tr>
<tr><td><code id="samplingStability_+3A_n.reps">n.reps</code></td>
<td>
<p>number of replications</p>
</td></tr>
<tr><td><code id="samplingStability_+3A_p.id">p.id</code></td>
<td>
<p>polygon ID column name</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.frame with median stability values as percentage of population median, range: <code style="white-space: pre;">&#8288;[0,1]&#8288;</code>
</p>


<h3>Author(s)</h3>

<p>D.E. Beaudette
</p>

<hr>
<h2 id='simpleWB'>Simple interface to the hydromad &quot;leaky bucket&quot; soil moisture model</h2><span id='topic+simpleWB'></span>

<h3>Description</h3>

<p>Simple interface to the hydromad &quot;leaky bucket&quot; soil moisture model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simpleWB(
  PPT,
  PET,
  D,
  thickness,
  sat,
  fc,
  pwp,
  S_0 = 0.5,
  a.ss = 0.05,
  M = 0,
  etmult = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simpleWB_+3A_ppt">PPT</code></td>
<td>
<p>precipitation series (mm)</p>
</td></tr>
<tr><td><code id="simpleWB_+3A_pet">PET</code></td>
<td>
<p>potential ET series (mm)</p>
</td></tr>
<tr><td><code id="simpleWB_+3A_d">D</code></td>
<td>
<p>dates</p>
</td></tr>
<tr><td><code id="simpleWB_+3A_thickness">thickness</code></td>
<td>
<p>soil thickness (cm)</p>
</td></tr>
<tr><td><code id="simpleWB_+3A_sat">sat</code></td>
<td>
<p>volumetric water content at saturation (satiated water content)</p>
</td></tr>
<tr><td><code id="simpleWB_+3A_fc">fc</code></td>
<td>
<p>volumetric water content at field capacity (typically 1/3 bar suction)</p>
</td></tr>
<tr><td><code id="simpleWB_+3A_pwp">pwp</code></td>
<td>
<p>volumetric water content at permanent wilting point (typically 15 bar suction)</p>
</td></tr>
<tr><td><code id="simpleWB_+3A_s_0">S_0</code></td>
<td>
<p>initial soil moisture as a fraction of total water storage (mm)</p>
</td></tr>
<tr><td><code id="simpleWB_+3A_a.ss">a.ss</code></td>
<td>
<p>recession coefficients for subsurface flow from saturated zone, should be &gt; 0</p>
</td></tr>
<tr><td><code id="simpleWB_+3A_m">M</code></td>
<td>
<p>fraction of area covered by deep-rooted vegetation</p>
</td></tr>
<tr><td><code id="simpleWB_+3A_etmult">etmult</code></td>
<td>
<p>multiplier for PET</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Adjustments for coarse fragments should be made by reducing <code>thickness</code>.
</p>


<h3>Value</h3>

<p>a <code>data.frame</code>
</p>


<h3>References</h3>

<p>Farmer, D., M. Sivapalan, Farmer, D. (2003). Climate, soil and vegetation controls upon the variability of water balance in temperate and semiarid landscapes: downward approach to water balance analysis. Water Resources Research 39(2), p 1035.
</p>
<p>Bai, Y., T. Wagener, P. Reed (2009). A top-down framework for watershed model evaluation and selection under uncertainty. Environmental Modelling and Software 24(8), pp. 901-916.
</p>

<hr>
<h2 id='site_photos_kml'>site_photos_kml</h2><span id='topic+site_photos_kml'></span>

<h3>Description</h3>

<p>Generates a KML file of site locations with associated site photos and a link to a pedon description report.</p>


<h3>Usage</h3>

<pre><code class='language-R'>site_photos_kml(data, 
filename='photos.kml', make.image.grid=FALSE, 
file.source = c('local', 'relative')
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="site_photos_kml_+3A_data">data</code></td>
<td>
<p>a dataframe</p>
</td></tr>
<tr><td><code id="site_photos_kml_+3A_filename">filename</code></td>
<td>
<p>full file path and name with .kml extension</p>
</td></tr>
<tr><td><code id="site_photos_kml_+3A_make.image.grid">make.image.grid</code></td>
<td>
<p>logical, include linked site images, default is FALSE</p>
</td></tr>
<tr><td><code id="site_photos_kml_+3A_file.source">file.source</code></td>
<td>
<p>'local' sources the image files to a specific system path, 'relative' sources the image files to files folder that can be included and referenced within a .kmz file</p>
</td></tr>			
</table>


<h3>Details</h3>

<p>This function simplifies writing a kml file of site and/or sites with linked photos. Further documentation is provided in <a href="https://ncss-tech.github.io/AQP/sharpshootR/site-photo-kml.html">this tutorial</a>.</p>


<h3>Value</h3>

<p>A KML file of of sites with embedded associated site photos.</p>


<h3>Author(s)</h3>

<p>Jay Skovlin, D.E. Beaudette</p>

<hr>
<h2 id='SoilTaxonomyDendrogram'>Soil Taxonomy Dendrogram</h2><span id='topic+SoilTaxonomyDendrogram'></span>

<h3>Description</h3>

<p>Plot a dendrogram based on the first 4 levels of Soil Taxonomy, with soil profiles hanging below. A dissimilarity matrix is computed using Gower's distance metric for nominal (<code>KST.order = FALSE</code>) or ordinal (<code>KST.order = TRUE</code>) scale variables, based on soil order, suborder, greatgroup, and subgroup taxa.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SoilTaxonomyDendrogram(
  spc,
  KST.order = TRUE,
  rotationOrder = NULL,
  level = c(soilorder = "soilorder", suborder = "suborder", greatgroup = "greatgroup",
    subgroup = "subgroup"),
  cluster.method = c("divisive", "agglomerative"),
  cluster.args = list(),
  name = "hzname",
  name.style = "center-center",
  id.style = "side",
  n.depth.ticks = 6,
  scaling.factor = 0.015,
  cex.names = 0.75,
  cex.id = 0.75,
  width = 0.25,
  y.offset = 0.5,
  shrink = FALSE,
  font.id = 2,
  cex.taxon.labels = 0.66,
  font.taxon.labels = 3,
  dend.color = par("fg"),
  dend.width = 1,
  dend.type = c("phylogram", "cladogram"),
  max.depth = ifelse(is.infinite(max(spc)), 200, max(spc)),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SoilTaxonomyDendrogram_+3A_spc">spc</code></td>
<td>
<p>a <code>SoilProfileCollection</code> object, typically returned by <code>soilDB::fetchOSD</code></p>
</td></tr>
<tr><td><code id="SoilTaxonomyDendrogram_+3A_kst.order">KST.order</code></td>
<td>
<p>logical, encode / cluster taxa via ordinal factors, based on ordering within Keys to Soil Taxonomy</p>
</td></tr>
<tr><td><code id="SoilTaxonomyDendrogram_+3A_rotationorder">rotationOrder</code></td>
<td>
<p>character vector of profile IDs with desired ordering of leaves in the dendrogram from left to right; exact ordering is not always possible</p>
</td></tr>
<tr><td><code id="SoilTaxonomyDendrogram_+3A_level">level</code></td>
<td>
<p>character. One or more site-level columns in <code>spc</code>. Default: <code>"soilorder"</code>, <code>"suborder"</code>, <code>"greatgroup"</code> and <code>"subgroup"</code></p>
</td></tr>
<tr><td><code id="SoilTaxonomyDendrogram_+3A_cluster.method">cluster.method</code></td>
<td>
<p>Either &quot;divisive&quot; (<code>cluster::diana()</code>; default) or &quot;agglomerative&quot; (<code>cluster::agnes()</code>)</p>
</td></tr>
<tr><td><code id="SoilTaxonomyDendrogram_+3A_cluster.args">cluster.args</code></td>
<td>
<p>Optional: additional arguments for <code>cluster::diana()</code> or <code>cluster::agnes()</code> cluster methods</p>
</td></tr>
<tr><td><code id="SoilTaxonomyDendrogram_+3A_name">name</code></td>
<td>
<p>column name containing horizon names</p>
</td></tr>
<tr><td><code id="SoilTaxonomyDendrogram_+3A_name.style">name.style</code></td>
<td>
<p>passed to <code>aqp::plotSPC</code></p>
</td></tr>
<tr><td><code id="SoilTaxonomyDendrogram_+3A_id.style">id.style</code></td>
<td>
<p>passed to <code>aqp::plotSPC</code></p>
</td></tr>
<tr><td><code id="SoilTaxonomyDendrogram_+3A_n.depth.ticks">n.depth.ticks</code></td>
<td>
<p>suggested number of ticks on the depth axis</p>
</td></tr>
<tr><td><code id="SoilTaxonomyDendrogram_+3A_scaling.factor">scaling.factor</code></td>
<td>
<p>scaling factor used to convert depth units into plotting units</p>
</td></tr>
<tr><td><code id="SoilTaxonomyDendrogram_+3A_cex.names">cex.names</code></td>
<td>
<p>character scaling for horizon names</p>
</td></tr>
<tr><td><code id="SoilTaxonomyDendrogram_+3A_cex.id">cex.id</code></td>
<td>
<p>character scaling for profile IDs</p>
</td></tr>
<tr><td><code id="SoilTaxonomyDendrogram_+3A_width">width</code></td>
<td>
<p>width of profiles</p>
</td></tr>
<tr><td><code id="SoilTaxonomyDendrogram_+3A_y.offset">y.offset</code></td>
<td>
<p>vertical offset between dendrogram and profiles</p>
</td></tr>
<tr><td><code id="SoilTaxonomyDendrogram_+3A_shrink">shrink</code></td>
<td>
<p>logical, should long horizon names be shrunk by 80% ?</p>
</td></tr>
<tr><td><code id="SoilTaxonomyDendrogram_+3A_font.id">font.id</code></td>
<td>
<p>integer, font style applied to profile id, default is 2 (bold)</p>
</td></tr>
<tr><td><code id="SoilTaxonomyDendrogram_+3A_cex.taxon.labels">cex.taxon.labels</code></td>
<td>
<p>numeric, character scaling for taxonomic information</p>
</td></tr>
<tr><td><code id="SoilTaxonomyDendrogram_+3A_font.taxon.labels">font.taxon.labels</code></td>
<td>
<p>integer, font style applied to taxa labels, default is 3 (italic)</p>
</td></tr>
<tr><td><code id="SoilTaxonomyDendrogram_+3A_dend.color">dend.color</code></td>
<td>
<p>dendrogram line color</p>
</td></tr>
<tr><td><code id="SoilTaxonomyDendrogram_+3A_dend.width">dend.width</code></td>
<td>
<p>dendrogram line width</p>
</td></tr>
<tr><td><code id="SoilTaxonomyDendrogram_+3A_dend.type">dend.type</code></td>
<td>
<p>dendrogram type, passed to <code>plot.phylo()</code>, either &quot;phylogram&quot; or &quot;cladogram&quot;</p>
</td></tr>
<tr><td><code id="SoilTaxonomyDendrogram_+3A_max.depth">max.depth</code></td>
<td>
<p>depth at which profiles are truncated for plotting</p>
</td></tr>
<tr><td><code id="SoilTaxonomyDendrogram_+3A_...">...</code></td>
<td>
<p>additional arguments to <code>aqp::plotSPC</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function looks for specific site-level attributes named: <code>"soilorder"</code>, <code>"suborder"</code>, <code>"greatgroup"</code>, and <code>"subgroup"</code>, or their NASIS physical column name analogues <code>"taxorder"</code>, <code>"taxsuborder"</code>, <code>"taxgrtgroup"</code>, and <code>"taxsubgrp"</code>. See <a href="https://github.com/ncss-tech/sharpshootR/blob/master/misc/soilTaxonomyDendrogram-examples.R">https://github.com/ncss-tech/sharpshootR/blob/master/misc/soilTaxonomyDendrogram-examples.R</a> for some examples.
</p>
<p>The <code>rotationOrder</code> argument uses <code>ape::rotateConstr()</code> to reorder leaves within the <code>hclust</code> representation of the ST hierarchy. Perfect sorting is not always possible.
</p>


<h3>Value</h3>

<p>An invisibly-returned list containing:
</p>

<ul>
<li> <p><code>dist</code>: pair-wise dissimilarity matrix
</p>
</li>
<li> <p><code>order</code>: final ordering of <code>hclust</code> leaves
</p>
</li></ul>



<h3>Author(s)</h3>

<p>D.E. Beaudette
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# built-in data, same as results from soilDB::fetchOSD()
data("OSDexamples")

# examples using first 8 profiles

# KST-style ordering
SoilTaxonomyDendrogram(
  OSDexamples$SPC[1:8, ], width = 0.3, name.style = 'center-center',
  KST.order = TRUE, axis.line.offset = -4, scaling.factor = 0.014
)

# classic ordering, based on nominal scale variables (un-ordered factors)
SoilTaxonomyDendrogram(
  OSDexamples$SPC[1:8, ], width = 0.3, name.style = 'center-center',
  KST.order = FALSE, axis.line.offset = -4, scaling.factor = 0.014
)

# adjust taxon label font and font size
SoilTaxonomyDendrogram(
  OSDexamples$SPC[1:15, ], width = 0.3, name.style = 'center-center',
  KST.order = FALSE, axis.line.offset = -4, scaling.factor = 0.014,
  font.taxon.labels = 2, cex.taxon.labels = 0.55
)

# cladogram vs. dendrogram
# truncate profiles at 150cm
SoilTaxonomyDendrogram(
  OSDexamples$SPC[1:16, ], width = 0.3, name.style = 'center-center',
  KST.order = TRUE, axis.line.offset = -4, scaling.factor = 0.02,
  font.taxon.labels = 1, cex.taxon.labels = 0.55,
  dend.type = 'cladogram', max.depth = 150
)

</code></pre>

<hr>
<h2 id='table5.2'>Table 5.2 from Hole and Campbell, 1985.</h2><span id='topic+table5.2'></span>

<h3>Description</h3>

<p>An adjacency matrix describing shared soil map boundary segments from the Soil Survey of Shawnee county, KS. This is table 5.2 from Hole and Campbell, 1985.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(table5.2)
</code></pre>


<h3>Format</h3>

<p>An object of class <code>matrix</code> (inherits from <code>array</code>) with 18 rows and 18 columns.
</p>


<h3>References</h3>

<p>Hole, F.D. and J.B. Campbell. Soil Landscape Analysis. Rowman and Allanheld, 1985.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data("table5.2")

if(requireNamespace("igraph")) {
  
  # note special incantation to get the "correct" graph structure
  g &lt;- igraph::graph_from_adjacency_matrix(table5.2, mode = 'upper', diag = FALSE, weighted = TRUE)
  
  # visualize
  op &lt;- par(no.readonly = TRUE)
  
  par(mar = c(0,0,0,0))
  plot(g)
  
  plot(g, vertex.size = sqrt(igraph::degree(g) * 25), vertex.label.family = 'sans')
  
  # find communities
  cm &lt;- igraph::cluster_walktrap(g)
  plot(cm, g, vertex.label.family = 'sans')
  
  par(op)
}

</code></pre>

<hr>
<h2 id='vizAnnualClimate'>Annual Climate Summaries for Soil Series Data</h2><span id='topic+vizAnnualClimate'></span>

<h3>Description</h3>

<p>Annual climate summaries for soil series, based on <code>latticeExtra::segplot</code>, based on 5th, 25th, 50th, 75th, and 95th percentiles. Input data should be from <code>soilDB::fetchOSD</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vizAnnualClimate(climate.data, IQR.cex = 1, s = NULL, s.col = "firebrick", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vizAnnualClimate_+3A_climate.data">climate.data</code></td>
<td>
<p>Annual climate summaries, as returned from <code>soilDB::fetchOSD(..., extended=TRUE)</code></p>
</td></tr>
<tr><td><code id="vizAnnualClimate_+3A_iqr.cex">IQR.cex</code></td>
<td>
<p>scaling factor for bar representing interquartile range</p>
</td></tr>
<tr><td><code id="vizAnnualClimate_+3A_s">s</code></td>
<td>
<p>a soil series name, e.g. &quot;LUCY&quot;, to highlight</p>
</td></tr>
<tr><td><code id="vizAnnualClimate_+3A_s.col">s.col</code></td>
<td>
<p>color for highlighted soil series</p>
</td></tr>
<tr><td><code id="vizAnnualClimate_+3A_...">...</code></td>
<td>
<p>further arguments passed to <code>latticeExtra::segplot</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function was designed for use with <code>soilDB::fetchOSD</code>. It might be possible to use with other sources of data but your mileage may vary. See the <a href="http://ncss-tech.github.io/AQP/soilDB/soil-series-query-functions.html">Soil Series Query Functions</a> tutorial for more information.
</p>


<h3>Value</h3>

<p>A <code>list</code> with the following elements:
</p>

<ul>
<li> <p><code>fig</code>: lattice object (the figure)
</p>
</li>
<li> <p><code>clust</code>: clustering object returned by <code>cluster::diana</code>
</p>
</li></ul>



<h3>Author(s)</h3>

<p>D.E. Beaudette
</p>


<h3>See Also</h3>

<p><code>vizHillslopePosition</code>
</p>

<hr>
<h2 id='vizFlatsPosition'>Visual Summary of Flat Landform Positions</h2><span id='topic+vizFlatsPosition'></span>

<h3>Description</h3>

<p>A unique display of landform position probability.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vizFlatsPosition(
  x,
  s = NULL,
  annotations = TRUE,
  annotation.cex = 0.75,
  cols = c("#2B83BA", "#ABDDA4", "#FFFFBF", "#FDAE61", "#D7191C"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vizFlatsPosition_+3A_x">x</code></td>
<td>
<p><code>data.frame</code> as created by <code>soilDB::fetchOSD(..., extended=TRUE)</code>, see details</p>
</td></tr>
<tr><td><code id="vizFlatsPosition_+3A_s">s</code></td>
<td>
<p>an optional soil series name, highlighted in the figure</p>
</td></tr>
<tr><td><code id="vizFlatsPosition_+3A_annotations">annotations</code></td>
<td>
<p>logical, add number of record and normalized Shannon entropy values</p>
</td></tr>
<tr><td><code id="vizFlatsPosition_+3A_annotation.cex">annotation.cex</code></td>
<td>
<p>annotation label scaling factor</p>
</td></tr>
<tr><td><code id="vizFlatsPosition_+3A_cols">cols</code></td>
<td>
<p>vector of colors</p>
</td></tr>
<tr><td><code id="vizFlatsPosition_+3A_...">...</code></td>
<td>
<p>additional arguments to <code style="white-space: pre;">&#8288;[iterateHydOrder]&#8288;</code>: <code style="white-space: pre;">&#8288;target = 0.9, maxIter = 20, j.amount = 0.05, verbose = FALSE&#8288;</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>See the <a href="http://ncss-tech.github.io/AQP/soilDB/soil-series-query-functions.html">Soil Series Query Functions</a> tutorial for more information.
</p>


<h3>Value</h3>

<p>A <code>list</code> with the following elements:
</p>

<ul>
<li> <p><code>fig</code>: lattice object (the figure)
</p>
</li>
<li> <p><code>order</code>: 1D ordering from <code>cluster::diana</code>
</p>
</li>
<li> <p><code>clust</code>: <code>hclust</code> object
</p>
</li>
<li> <p><code>match.rate</code>: fraction of series matching target hydrologic ordering, after clustering + rotation
</p>
</li></ul>



<h3>Author(s)</h3>

<p>D.E. Beaudette
</p>

<hr>
<h2 id='vizGeomorphicComponent'>Visual Summary of Hill Landform Positions</h2><span id='topic+vizGeomorphicComponent'></span>

<h3>Description</h3>

<p>A unique display of landform position probability.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vizGeomorphicComponent(
  x,
  s = NULL,
  annotations = TRUE,
  annotation.cex = 0.75,
  cols = c("#D53E4F", "#FC8D59", "#FEE08B", "#E6F598", "#99D594", "#3288BD"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vizGeomorphicComponent_+3A_x">x</code></td>
<td>
<p><code>data.frame</code> as created by <code>soilDB::fetchOSD(..., extended=TRUE)</code>, see details</p>
</td></tr>
<tr><td><code id="vizGeomorphicComponent_+3A_s">s</code></td>
<td>
<p>an optional soil series name, highlighted in the figure</p>
</td></tr>
<tr><td><code id="vizGeomorphicComponent_+3A_annotations">annotations</code></td>
<td>
<p>logical, add number of record and normalized Shannon entropy values</p>
</td></tr>
<tr><td><code id="vizGeomorphicComponent_+3A_annotation.cex">annotation.cex</code></td>
<td>
<p>annotation label scaling factor</p>
</td></tr>
<tr><td><code id="vizGeomorphicComponent_+3A_cols">cols</code></td>
<td>
<p>vector of colors</p>
</td></tr>
<tr><td><code id="vizGeomorphicComponent_+3A_...">...</code></td>
<td>
<p>additional arguments to <code style="white-space: pre;">&#8288;[iterateHydOrder]&#8288;</code>: <code style="white-space: pre;">&#8288;target = 0.9, maxIter = 20, j.amount = 0.05, verbose = FALSE&#8288;</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>See the <a href="http://ncss-tech.github.io/AQP/soilDB/soil-series-query-functions.html">Soil Series Query Functions</a> tutorial for more information.
</p>


<h3>Value</h3>

<p>A <code>list</code> with the following elements:
</p>

<ul>
<li> <p><code>fig</code>: lattice object (the figure)
</p>
</li>
<li> <p><code>order</code>: 1D ordering from <code>cluster::diana</code>
</p>
</li>
<li> <p><code>clust</code>: <code>hclust</code> object
</p>
</li>
<li> <p><code>match.rate</code>: fraction of series matching target hydrologic ordering, after clustering + rotation
</p>
</li></ul>



<h3>Author(s)</h3>

<p>D.E. Beaudette
</p>

<hr>
<h2 id='vizHillslopePosition'>Visual Summary of Hillslope Position</h2><span id='topic+vizHillslopePosition'></span>

<h3>Description</h3>

<p>A unique display of hillslope position probability.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vizHillslopePosition(
  x,
  s = NULL,
  annotations = TRUE,
  annotation.cex = 0.75,
  cols = c("#2B83BA", "#ABDDA4", "#FFFFBF", "#FDAE61", "#D7191C"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vizHillslopePosition_+3A_x">x</code></td>
<td>
<p><code>data.frame</code> as created by <code>soilDB::fetchOSD(..., extended = TRUE)</code></p>
</td></tr>
<tr><td><code id="vizHillslopePosition_+3A_s">s</code></td>
<td>
<p>an optional soil series name, highlighted in the figure</p>
</td></tr>
<tr><td><code id="vizHillslopePosition_+3A_annotations">annotations</code></td>
<td>
<p>logical, add number of record and normalized Shannon entropy values</p>
</td></tr>
<tr><td><code id="vizHillslopePosition_+3A_annotation.cex">annotation.cex</code></td>
<td>
<p>annotation label scaling factor</p>
</td></tr>
<tr><td><code id="vizHillslopePosition_+3A_cols">cols</code></td>
<td>
<p>vector of colors</p>
</td></tr>
<tr><td><code id="vizHillslopePosition_+3A_...">...</code></td>
<td>
<p>additional arguments to <code style="white-space: pre;">&#8288;[iterateHydOrder]&#8288;</code>: <code style="white-space: pre;">&#8288;target = 0.9, maxIter = 20, j.amount = 0.05, verbose = FALSE&#8288;</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>See the <a href="http://ncss-tech.github.io/AQP/soilDB/soil-series-query-functions.html">Soil Series Query Functions</a> tutorial for more information.
</p>


<h3>Value</h3>

<p>A <code>list</code> with the following elements:
</p>

<ul>
<li> <p><code>fig</code>: lattice object (the figure)
</p>
</li>
<li> <p><code>order</code>: 1D ordering from <code>cluster::diana</code>
</p>
</li>
<li> <p><code>clust</code>: <code>hclust</code> object
</p>
</li>
<li> <p><code>match.rate</code>: fraction of series matching target hydrologic ordering, after clustering + rotation
</p>
</li></ul>



<h3>Author(s)</h3>

<p>D.E. Beaudette
</p>

<hr>
<h2 id='vizMountainPosition'>Visual Summary of Mountain Slope Positions</h2><span id='topic+vizMountainPosition'></span>

<h3>Description</h3>

<p>A unique display of mountain slope position probability.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vizMountainPosition(
  x,
  s = NULL,
  annotations = TRUE,
  annotation.cex = 0.75,
  cols = c("#D53E4F", "#FC8D59", "#FEE08B", "#E6F598", "#99D594", "#3288BD"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vizMountainPosition_+3A_x">x</code></td>
<td>
<p><code>data.frame</code> as created by <code>soilDB::fetchOSD(..., extended=TRUE)</code>, see details</p>
</td></tr>
<tr><td><code id="vizMountainPosition_+3A_s">s</code></td>
<td>
<p>an optional soil series name, highlighted in the figure</p>
</td></tr>
<tr><td><code id="vizMountainPosition_+3A_annotations">annotations</code></td>
<td>
<p>logical, add number of record and normalized Shannon entropy values</p>
</td></tr>
<tr><td><code id="vizMountainPosition_+3A_annotation.cex">annotation.cex</code></td>
<td>
<p>annotation label scaling factor</p>
</td></tr>
<tr><td><code id="vizMountainPosition_+3A_cols">cols</code></td>
<td>
<p>vector of colors</p>
</td></tr>
<tr><td><code id="vizMountainPosition_+3A_...">...</code></td>
<td>
<p>additional arguments to <code style="white-space: pre;">&#8288;[iterateHydOrder]&#8288;</code>: <code style="white-space: pre;">&#8288;target = 0.9, maxIter = 20, j.amount = 0.05, verbose = FALSE&#8288;</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>See the <a href="http://ncss-tech.github.io/AQP/soilDB/soil-series-query-functions.html">Soil Series Query Functions</a> tutorial for more information.
</p>


<h3>Value</h3>

<p>A <code>list</code> with the following elements:
</p>

<ul>
<li> <p><code>fig</code>: lattice object (the figure)
</p>
</li>
<li> <p><code>order</code>: 1D ordering from <code>cluster::diana</code>
</p>
</li>
<li> <p><code>clust</code>: <code>hclust</code> object
</p>
</li>
<li> <p><code>match.rate</code>: fraction of series matching target hydrologic ordering, after clustering + rotation
</p>
</li></ul>



<h3>Author(s)</h3>

<p>D.E. Beaudette
</p>

<hr>
<h2 id='vizSurfaceShape'>Visual Summary of Surface Shape</h2><span id='topic+vizSurfaceShape'></span>

<h3>Description</h3>

<p>A unique display of surface shape (typically curvature) probability, suitable for across-slope or down-slope shape. Use the <code>title</code> argument to make this clear.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vizSurfaceShape(
  x,
  title = "Surface Shape",
  s = NULL,
  annotations = TRUE,
  annotation.cex = 0.75,
  cols = c("#2B83BA", "#FFFFBF", "#D7191C", "#808080", "darkgreen"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vizSurfaceShape_+3A_x">x</code></td>
<td>
<p><code>data.frame</code> as created by <code>soilDB::fetchOSD(..., extended=TRUE)</code>, see details</p>
</td></tr>
<tr><td><code id="vizSurfaceShape_+3A_title">title</code></td>
<td>
<p>a reasonable title for the figure</p>
</td></tr>
<tr><td><code id="vizSurfaceShape_+3A_s">s</code></td>
<td>
<p>an optional soil series name, highlighted in the figure</p>
</td></tr>
<tr><td><code id="vizSurfaceShape_+3A_annotations">annotations</code></td>
<td>
<p>logical, add number of record and normalized Shannon entropy values</p>
</td></tr>
<tr><td><code id="vizSurfaceShape_+3A_annotation.cex">annotation.cex</code></td>
<td>
<p>annotation label scaling factor</p>
</td></tr>
<tr><td><code id="vizSurfaceShape_+3A_cols">cols</code></td>
<td>
<p>vector of colors</p>
</td></tr>
<tr><td><code id="vizSurfaceShape_+3A_...">...</code></td>
<td>
<p>additional arguments to <code style="white-space: pre;">&#8288;[iterateHydOrder]&#8288;</code>: <code style="white-space: pre;">&#8288;target = 0.9, maxIter = 20, j.amount = 0.05, verbose = FALSE&#8288;</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>See the <a href="http://ncss-tech.github.io/AQP/soilDB/soil-series-query-functions.html">Soil Series Query Functions</a> tutorial for more information.
</p>


<h3>Value</h3>

<p>A <code>list</code> with the following elements:
</p>

<ul>
<li> <p><code>fig</code>: lattice object (the figure)
</p>
</li>
<li> <p><code>order</code>: 1D ordering from <code>cluster::diana</code>
</p>
</li>
<li> <p><code>clust</code>: <code>hclust</code> object
</p>
</li>
<li> <p><code>match.rate</code>: fraction of series matching target hydrologic ordering, after clustering + rotation
</p>
</li></ul>



<h3>Author(s)</h3>

<p>D.E. Beaudette
</p>

<hr>
<h2 id='vizTerracePosition'>Visual Summary of Terraced Landform Positions</h2><span id='topic+vizTerracePosition'></span>

<h3>Description</h3>

<p>A unique display of terraced landform position probability.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vizTerracePosition(
  x,
  s = NULL,
  annotations = TRUE,
  annotation.cex = 0.75,
  cols = c("#2B83BA", "#FDAE61"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vizTerracePosition_+3A_x">x</code></td>
<td>
<p><code>data.frame</code> as created by <code>soilDB::fetchOSD(..., extended=TRUE)</code>, see details</p>
</td></tr>
<tr><td><code id="vizTerracePosition_+3A_s">s</code></td>
<td>
<p>an optional soil series name, highlighted in the figure</p>
</td></tr>
<tr><td><code id="vizTerracePosition_+3A_annotations">annotations</code></td>
<td>
<p>logical, add number of record and normalized Shannon entropy values</p>
</td></tr>
<tr><td><code id="vizTerracePosition_+3A_annotation.cex">annotation.cex</code></td>
<td>
<p>annotation label scaling factor</p>
</td></tr>
<tr><td><code id="vizTerracePosition_+3A_cols">cols</code></td>
<td>
<p>vector of colors</p>
</td></tr>
<tr><td><code id="vizTerracePosition_+3A_...">...</code></td>
<td>
<p>additional arguments to <code style="white-space: pre;">&#8288;[iterateHydOrder]&#8288;</code>: <code style="white-space: pre;">&#8288;target = 0.9, maxIter = 20, j.amount = 0.05, verbose = FALSE&#8288;</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>See the <a href="http://ncss-tech.github.io/AQP/soilDB/soil-series-query-functions.html">Soil Series Query Functions</a> tutorial for more information.
</p>


<h3>Value</h3>

<p>A <code>list</code> with the following elements:
</p>

<ul>
<li> <p><code>fig</code>: lattice object (the figure)
</p>
</li>
<li> <p><code>order</code>: 1D ordering from <code>cluster::diana</code>
</p>
</li>
<li> <p><code>clust</code>: <code>hclust</code> object
</p>
</li>
<li> <p><code>match.rate</code>: fraction of series matching target hydrologic ordering, after clustering + rotation
</p>
</li></ul>



<h3>Author(s)</h3>

<p>D.E. Beaudette
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
