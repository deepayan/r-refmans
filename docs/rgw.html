<!DOCTYPE html><html><head><title>Help for package rgw</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {rgw}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#rgw-package'>
<p>Goodman-Weare Affine-Invariant Sampling</p></a></li>
<li><a href='#GoodmanWeare'>
<p>Goodman-Weare Affine-Invariant Sampling</p></a></li>
<li><a href='#GoodmanWeare.rem'>
<p>Goodman-Weare Affine-Invariant Sampling</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Goodman-Weare Affine-Invariant Sampling</td>
</tr>
<tr>
<td>Version:</td>
<td>0.3.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2020-08-10</td>
</tr>
<tr>
<td>Author:</td>
<td>Adam Mantz</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Adam Mantz &lt;amantz@slac.stanford.edu&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Implementation of the affine-invariant method of Goodman &amp; Weare (2010) &lt;<a href="https://doi.org/10.2140%2Fcamcos.2010.5.65">doi:10.2140/camcos.2010.5.65</a>&gt;, a method of producing Monte-Carlo samples from a target distribution.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>Imports:</td>
<td>parallel</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/abmantz/rgw">https://github.com/abmantz/rgw</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2020-08-10 22:11:23 UTC; amantz</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2020-08-11 04:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='rgw-package'>
Goodman-Weare Affine-Invariant Sampling
</h2><span id='topic+rgw-package'></span><span id='topic+rgw'></span>

<h3>Description</h3>

<p>This package implements the affine-invariant method of Goodman &amp; Weare (2010) &lt;DOI:10.2140/camcos.2010.5.65&gt;, a method of producing Monte-Carlo samples from a target distribution. The implementation is based on the description of the &lsquo;emcee&rsquo; python package (implementing the same method) written by Forman-Mackey et al. (2012) &lt;DOI:10.1086/670067&gt;. See &lsquo;References&rsquo; in the documentation of the GoodmanWeare function for full citation details.
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> rgw</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 0.3.0</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2017-08-11</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> MIT</td>
</tr>
<tr>
 <td style="text-align: left;">
LazyLoad: </td><td style="text-align: left;"> yes</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Author(s)</h3>

<p>Adam Mantz &lt;amantz@slac.stanford.edu&gt;
</p>

<hr>
<h2 id='GoodmanWeare'>
Goodman-Weare Affine-Invariant Sampling
</h2><span id='topic+GoodmanWeare'></span>

<h3>Description</h3>

<p>Produces a Monte-Carlo Markov ensemble using the affine-invariant method of Goodman &amp; Weare.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GoodmanWeare(ensemble, lnpost, Nsteps, current.lnP=NULL,
 mc.cores=getOption("mc.cores", 1L), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GoodmanWeare_+3A_ensemble">ensemble</code></td>
<td>

<p>an Nparam*Nwalkers array holding the initial state of the sampler. Nparam is the dimensionality of the parameter space and Nwalkers is the number of positions in the parameter space comprising the ensemble. Nwalkers must be even, and in practice should be *at minimum* twice Nparam.
</p>
</td></tr>
<tr><td><code id="GoodmanWeare_+3A_lnpost">lnpost</code></td>
<td>

<p>function taking a vector of parameter values as input, and returning the log-posterior density.
</p>
</td></tr>
<tr><td><code id="GoodmanWeare_+3A_nsteps">Nsteps</code></td>
<td>

<p>number of iterations to run the sampler.
</p>
</td></tr>
<tr><td><code id="GoodmanWeare_+3A_current.lnp">current.lnP</code></td>
<td>

<p>vector holding the log-posterior value corresponding to the initial position of each walker. If not provided, this will be calculated internally.
</p>
</td></tr>
<tr><td><code id="GoodmanWeare_+3A_mc.cores">mc.cores</code></td>
<td>

<p>number of cores to use for parallelism.
</p>
</td></tr>
<tr><td><code id="GoodmanWeare_+3A_...">...</code></td>
<td>

<p>additional arguments to pass to lnpost.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing $ensemble: an array of the same dimensionality as ensemble, containing the position of the walkers after Nsteps iterations of the sampler; and $current.lnP: the  log-posterior density for each walker.
</p>


<h3>Note</h3>

<p>By default, the code will attempt to run in parallel (see the &lsquo;parallel&rsquo; package). To prevent this, pass mc.cores=1.
</p>


<h3>Author(s)</h3>

<p>Adam Mantz
</p>


<h3>References</h3>

<p>Goodman, J. &amp; Weare, J. (2010, Comm. App. Math. Comp. Sci., 5:6) &lt;DOI:10.2140/camcos.2010.5.65&gt;. This implementation is based on the description given by Foreman-Mackey et al. (2012, arXiv:1202.3665) &lt;DOI:10.1086/670067&gt;.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># In this example, we'll sample from a simple 2D Gaussian

# Define the log-posterior function
lnP = function(x) sum( dnorm(x, c(0,1), c(pi, exp(0.5)), log=TRUE) )

# Initialize an ensemble of 100 walkers
nwalk = 100
ensemble = array(dim=c(2, nwalk))
ensemble[1,] = rnorm(nwalk, 0, 0.1)
ensemble[2,] = rnorm(nwalk, 1, 0.1)

# Run for a bit
ens2 = GoodmanWeare(ensemble, lnP, 100, mc.cores=1)

# Plot the resulting ensemble
plot(t(ens2$ensemble))
# Compare to a direct draw from the posterior distribution
points(rnorm(nwalk, 0, pi), rnorm(nwalk, 1, exp(0.5)), col=2, pch=3)
</code></pre>

<hr>
<h2 id='GoodmanWeare.rem'>
Goodman-Weare Affine-Invariant Sampling
</h2><span id='topic+GoodmanWeare.rem'></span>

<h3>Description</h3>

<p>Produces a Monte-Carlo Markov ensemble using the affine-invariant method of Goodman &amp; Weare, saving progress periodically.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GoodmanWeare.rem(post, lnpost, thin=1, mention.every=NA,
 save.every=NA, save.file=NA, show.every=NA,
 show.params=1:dim(post)[1], show.walkers=min(dim(post)[2],8),
 show.pch1=1, show.pch2='.', show.pch.switch=500,
 return.lnpost=FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GoodmanWeare.rem_+3A_post">post</code></td>
<td>

<p>an Nparam*Nwalkers*Nsteps array. post[,,1] should hold the initial state of the sampler (see help for GoodmanWeare). Checkpoints and the return value will have the same shape, with subsequent layers post[,,i] holding the ensemble state at later iterations.
</p>
</td></tr>
<tr><td><code id="GoodmanWeare.rem_+3A_lnpost">lnpost</code></td>
<td>

<p>function taking a vector of parameter values as input, and returning the log-posterior density.
</p>
</td></tr>
<tr><td><code id="GoodmanWeare.rem_+3A_thin">thin</code></td>
<td>

<p>thinning factor for saving the results.
</p>
</td></tr>
<tr><td><code id="GoodmanWeare.rem_+3A_mention.every">mention.every</code></td>
<td>

<p>print a message to the console every time this many iterations are completed.
</p>
</td></tr>
<tr><td><code id="GoodmanWeare.rem_+3A_save.every">save.every</code></td>
<td>

<p>save the accumulated Markov ensemble to disk every time this many iterations are completed.
</p>
</td></tr>
<tr><td><code id="GoodmanWeare.rem_+3A_save.file">save.file</code></td>
<td>

<p>filename for saving progress.
</p>
</td></tr>
<tr><td><code id="GoodmanWeare.rem_+3A_show.every">show.every</code></td>
<td>

<p>plot parameter traces so far to the active graphics device periodically.
</p>
</td></tr>
<tr><td><code id="GoodmanWeare.rem_+3A_show.params">show.params</code></td>
<td>

<p>(sub)set of parameter traces to plot (default is to show all).
</p>
</td></tr>
<tr><td><code id="GoodmanWeare.rem_+3A_show.walkers">show.walkers</code></td>
<td>

<p>which walkers to plot traces of (default is first 8).
</p>
</td></tr>
<tr><td><code id="GoodmanWeare.rem_+3A_show.pch1">show.pch1</code></td>
<td>

<p>plot symbol to use for short chains.
</p>
</td></tr>
<tr><td><code id="GoodmanWeare.rem_+3A_show.pch2">show.pch2</code></td>
<td>

<p>plot symbol to use for long chains.
</p>
</td></tr>
<tr><td><code id="GoodmanWeare.rem_+3A_show.pch.switch">show.pch.switch</code></td>
<td>

<p>chain length that distinguishes &quot;short&quot; and &quot;long&quot; chains for plotting purposes.
</p>
</td></tr>
<tr><td><code id="GoodmanWeare.rem_+3A_return.lnpost">return.lnpost</code></td>
<td>

<p>whether to return log-posterior values for each sample; see Value.
</p>
</td></tr>
<tr><td><code id="GoodmanWeare.rem_+3A_...">...</code></td>
<td>

<p>additional named arguments to pass to GoodmanWeare or lnpost.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If return.lnpost==FALSE, an array of the same dimensionality as post, storing the position of the walkers in post[,,i] every thin iterations. Otherwise, a list containing that array as $post, as well as an Nwalkers*Nsteps array storing the corresponding log-posterior values as $lnP. The log-posterior values $lnP[,1], corresponding with the starting ensemble positions $post[,,1], will always be NA.
</p>


<h3>Note</h3>

<p>By default, the code will attempt to run in parallel (see the &lsquo;parallel&rsquo;
package). To prevent this, pass mc.cores=1.
</p>
<p>If traces are being plotted (show.every not NA),
par(mfrow=c(length(show.params), 1)) is called on the current graphics
device.
</p>


<h3>Author(s)</h3>

<p>Adam Mantz
</p>


<h3>References</h3>

<p>See also help for rgw::GoodmanWeare.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># In this example, we'll sample from a simple 2D Gaussian.
# (This is the same example as used in GoodmanWeare.)

# Define the log-posterior function
lnP = function(x) sum( dnorm(x, c(0,1), c(pi, exp(0.5)), log=TRUE) )

# Initialize an ensemble of 100 walkers. We'll take 100 steps, saving the
# ensemble after each.
nwalk = 100
post = array(NA, dim=c(2, nwalk, 101))
post[1,,1] = rnorm(nwalk, 0, 0.1)
post[2,,1] = rnorm(nwalk, 1, 0.1)

# Run
post = GoodmanWeare.rem(post, lnP, mc.cores=1)

# Plot the final ensemble
plot(post[1,,101], post[2,,101])
# Look at the trace of each parameter for one of the walkers.
plot(post[1,1,])
plot(post[2,1,])
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
