<!DOCTYPE html><html lang="en"><head><title>Help for package nonlinearTseries</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {nonlinearTseries}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#buildTakens'><p>Build the Takens' vectors</p></a></li>
<li><a href='#cliffordMap'><p>Clifford map</p></a></li>
<li><a href='#contourLines'><p>Obtain the contour lines of the space time plot.</p></a></li>
<li><a href='#corrDim'><p>Correlation sum, correlation dimension and generalized correlation dimension</p>
(order q &gt;1).</a></li>
<li><a href='#corrMatrix'><p>Returns the correlation sums stored in the <em>corrDim</em> object</p></a></li>
<li><a href='#dfa'><p>Detrended Fluctuation Analysis</p></a></li>
<li><a href='#divergence'><p>Returns the rate of divergence of close trajectories needed for the maximum</p>
Lyapunov exponent estimation.</a></li>
<li><a href='#divTime'><p>Returns the time in which the divergence of close trajectories was computed</p>
in order to estimate the maximum Lyapunov exponent.</a></li>
<li><a href='#embeddingDims'><p>Get the embedding dimensions used for compute a chaotic invariant.</p></a></li>
<li><a href='#estimate'><p>Estimate several chaotic invariants using linear regression</p></a></li>
<li><a href='#estimateEmbeddingDim'><p>Estimate the embedding dimension</p></a></li>
<li><a href='#FFTsurrogate'><p>Generate surrogate data using the Fourier transform</p></a></li>
<li><a href='#findAllNeighbours'><p>neighbour search</p></a></li>
<li><a href='#fixedMass'><p>fixed mass</p></a></li>
<li><a href='#fluctuationFunction'><p>Returns the fluctuation function obtained in a DFA and represented by a</p>
<em>dfa</em> object.</a></li>
<li><a href='#gaussMap'><p>Gauss map</p></a></li>
<li><a href='#getContourLines'><p>Obtain the contour lines of the space time plot.</p></a></li>
<li><a href='#henon'><p>Henon map</p></a></li>
<li><a href='#ikedaMap'><p>Ikeda map</p></a></li>
<li><a href='#infDim'><p>Information dimension</p></a></li>
<li><a href='#keenanTest'><p>Keenan's test</p></a></li>
<li><a href='#logisticMap'><p>Logistic map</p></a></li>
<li><a href='#logRadius'><p>Obtain the the average log(radius) computed</p>
on the information dimension algorithm.</a></li>
<li><a href='#lorenz'><p>Lorenz system</p></a></li>
<li><a href='#maxLyapunov'><p>Maximum lyapunov exponent</p></a></li>
<li><a href='#mcleodLiTest'><p>McLeod-Li test</p></a></li>
<li><a href='#mutualInformation'><p>Average Mutual Information (AMI)</p></a></li>
<li><a href='#neighbourSearch'><p>neighbour search</p></a></li>
<li><a href='#nlOrder'><p>Get the order of the nonlinear chaotic invariant.</p></a></li>
<li><a href='#nonlinearityTest'><p>Nonlinearity test</p></a></li>
<li><a href='#nonLinearNoiseReduction'><p>Nonlinear noise reduction</p></a></li>
<li><a href='#nonLinearPrediction'><p>Nonlinear time series prediction</p></a></li>
<li><a href='#plotLocalScalingExp'><p>Plot local scaling exponents</p></a></li>
<li><a href='#poincareMap'><p>Poincare map</p></a></li>
<li><a href='#radius'><p>Get the radius of the neighborhoods used for the  computations of</p>
a chaotic invariant.</a></li>
<li><a href='#recurrencePlot'><p>Recurrence Plot</p></a></li>
<li><a href='#rossler'><p>Rossler system</p></a></li>
<li><a href='#rqa'><p>Recurrence Quantification Analysis (RQA)</p></a></li>
<li><a href='#sampleEntropy'><p>Sample Entropy (also known as Kolgomorov-Sinai Entropy)</p></a></li>
<li><a href='#sampleEntropyFunction'><p>Returns the sample entropy function <code class="reqn">h_q(m,r)</code> used for the computations</p>
of the sample entropy.</a></li>
<li><a href='#sinaiMap'><p>Sinai map</p></a></li>
<li><a href='#spaceTimePlot'><p>Space Time plot</p></a></li>
<li><a href='#surrogateTest'><p>Surrogate data testing</p></a></li>
<li><a href='#thresholdTest'><p>Threshold nonlinearity test</p></a></li>
<li><a href='#timeAsymmetry'><p>Time Reversibility statistic</p></a></li>
<li><a href='#timeAsymmetry2'><p>Time Reversibility statistic</p></a></li>
<li><a href='#timeLag'><p>Estimate an appropiate time lag for the Takens' vectors</p></a></li>
<li><a href='#tsayTest'><p>Tsay's test</p></a></li>
<li><a href='#windowSizes'><p>Returns the window sizes used for DFA in a <em>dfa</em> object.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Nonlinear Time Series Analysis</td>
</tr>
<tr>
<td>Version:</td>
<td>0.3.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-9-23</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Constantino A. Garcia &lt;constantino.garciama@ceu.es&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Functions for nonlinear time series analysis. This package permits
    the computation of the  most-used nonlinear statistics/algorithms
    including generalized correlation dimension, information dimension,
    largest Lyapunov exponent, sample entropy and Recurrence
    Quantification Analysis (RQA), among others. Basic routines
    for surrogate data testing are also included. Part of this work
    was based on the  book "Nonlinear time series analysis" by
    Holger Kantz and Thomas Schreiber (ISBN: 9780521529020).</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/constantino-garcia/nonlinearTseries">https://github.com/constantino-garcia/nonlinearTseries</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/constantino-garcia/nonlinearTseries/issues">https://github.com/constantino-garcia/nonlinearTseries/issues</a></td>
</tr>
<tr>
<td>Copyright:</td>
<td>ANN library is copyright University of Maryland and Sunil
Arya and David Mount. R wrapper is based on the ANN library,
copyright Samuel Kemp 2005-9 and Gregory Jefferis 2009-2013.
See file COPYRIGHT for details</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.3.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>Matrix, tseries, zoo, Rcpp (&ge; 0.12.12), graphics, stats,
lifecycle</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>Suggests:</td>
<td>rgl, plot3D, knitr, rmarkdown, testthat</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-09-23 10:35:54 UTC; gaussllego</td>
</tr>
<tr>
<td>Author:</td>
<td>Constantino A. Garcia [aut, cre],
  Gunther Sawitzki [ctb]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-09-23 11:50:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='buildTakens'>Build the Takens' vectors</h2><span id='topic+buildTakens'></span>

<h3>Description</h3>

<p>This function builds the Takens' vectors from a given time series. The set
of Takens' vectors is the result of embedding the time series in a 
m-dimensional space. That is, the <code class="reqn">n^{th}</code> Takens' vector is defined as 
</p>
<p style="text-align: center;"><code class="reqn">T[n]=\{time.series[n], time.series[n+ timeLag],...time.series[n+m*timeLag]\}.</code>
</p>

<p>Taken's theorem states that we can then reconstruct an equivalent dynamical 
system to the original one (the 
dynamical system that generated the observed time series) by using the 
Takens' vectors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>buildTakens(time.series, embedding.dim, time.lag)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="buildTakens_+3A_time.series">time.series</code></td>
<td>
<p>The original time series.</p>
</td></tr>
<tr><td><code id="buildTakens_+3A_embedding.dim">embedding.dim</code></td>
<td>
<p>Integer denoting the dimension in which we shall embed
the time.series.</p>
</td></tr>
<tr><td><code id="buildTakens_+3A_time.lag">time.lag</code></td>
<td>
<p>Integer denoting the number of time steps that will be use
to construct the  Takens' vectors.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix containing the Takens' vectors (one per row). The resulting
matrix also contains information about the time lag and the embedding
dimension used (as attributes).
</p>


<h3>Author(s)</h3>

<p>Constantino A. Garcia and Gunther Sawitzki.
</p>


<h3>References</h3>

<p>H. Kantz  and T. Schreiber: Nonlinear Time series Analysis 
(Cambridge university press)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Build the Takens vector for the Henon map using the x-coordinate time series
h = henon(n.sample=  3000,n.transient= 100, a = 1.4, b = 0.3, 
start = c(0.73954883, 0.04772637), do.plot = FALSE)
takens = buildTakens(h$x,embedding.dim=2,time.lag=1)
# using the x-coordinate time series we are able to reconstruct
# the state space of the Henon map
plot(takens)
## End(Not run)
</code></pre>

<hr>
<h2 id='cliffordMap'>Clifford map</h2><span id='topic+cliffordMap'></span>

<h3>Description</h3>

<p>Generates a 2-dimensional time series using the Clifford map.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cliffordMap(
  a = -1.4,
  b = 1.6,
  cc = 1,
  d = 0.7,
  start = runif(2),
  n.sample = 5000,
  n.transient = 500,
  do.plot = deprecated()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cliffordMap_+3A_a">a</code></td>
<td>
<p>The <em>a</em> parameter. Default: -1.4</p>
</td></tr>
<tr><td><code id="cliffordMap_+3A_b">b</code></td>
<td>
<p>The <em>b</em> parameter. Default: 1.6</p>
</td></tr>
<tr><td><code id="cliffordMap_+3A_cc">cc</code></td>
<td>
<p>The <em>c</em> parameter. Default: 1.0</p>
</td></tr>
<tr><td><code id="cliffordMap_+3A_d">d</code></td>
<td>
<p>The <em>d</em> parameter. Default: 0.7</p>
</td></tr>
<tr><td><code id="cliffordMap_+3A_start">start</code></td>
<td>
<p>a 2-dimensional vector indicating the starting values for the 
x and y Clifford coordinates. 
If the starting point is not specified, it is generated randomly.</p>
</td></tr>
<tr><td><code id="cliffordMap_+3A_n.sample">n.sample</code></td>
<td>
<p>Length of the generated time series. Default: 5000 samples.</p>
</td></tr>
<tr><td><code id="cliffordMap_+3A_n.transient">n.transient</code></td>
<td>
<p>Number of transient samples that will be discarded. 
Default: 500 samples.</p>
</td></tr>
<tr><td><code id="cliffordMap_+3A_do.plot">do.plot</code></td>
<td>
<p>Logical value. If TRUE, a plot of the 
generated Clifford system is shown. Before version 0.2.11, default value was
TRUE; versions 0.2.11 and later use FALSE as default.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Clifford map is defined as follows:
</p>
<p style="text-align: center;"><code class="reqn">x_{n+1} = sin(a \cdot y_n) + c \cdot cos(a \cdot x_n)</code>
</p>

<p style="text-align: center;"><code class="reqn">y_{n+1} = sin(b \cdot x_n) + d \cdot cos(b \cdot y_n)</code>
</p>

<p>The default selection for the <em>a</em> <em>b</em> <em>c</em> and <em>d</em> 
parameters is known to produce a deterministic chaotic time series.
</p>


<h3>Value</h3>

<p>A list with two vectors named x and y containing the x-components 
and the y-components of the Clifford map, respectively.
</p>


<h3>Note</h3>

<p>Some initial values may lead to an unstable system that will tend to 
infinity.
</p>


<h3>Author(s)</h3>

<p>Constantino A. Garcia
</p>


<h3>See Also</h3>

<p><code><a href="#topic+henon">henon</a>, <a href="#topic+logisticMap">logisticMap</a>, <a href="#topic+lorenz">lorenz</a>, 
<a href="#topic+rossler">rossler</a>, <a href="#topic+ikedaMap">ikedaMap</a>, <a href="#topic+sinaiMap">sinaiMap</a>, <a href="#topic+gaussMap">gaussMap</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
clifford.map=cliffordMap(n.sample = 1000, n.transient=10,do.plot=TRUE)
# accessing the x coordinate and plotting it
plot(ts(clifford.map$x))
## End(Not run)
</code></pre>

<hr>
<h2 id='contourLines'>Obtain the contour lines of the space time plot.</h2><span id='topic+contourLines'></span>

<h3>Description</h3>

<p>Obtain the contour lines of the space time plot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>contourLines(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="contourLines_+3A_x">x</code></td>
<td>
<p>A <em>spaceTimePlot</em> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a matrix representing the contour lines of the
space time plot.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+spaceTimePlot">spaceTimePlot</a></code>
</p>

<hr>
<h2 id='corrDim'>Correlation sum, correlation dimension and generalized correlation dimension 
(order q &gt;1).</h2><span id='topic+corrDim'></span><span id='topic+nlOrder.corrDim'></span><span id='topic+corrMatrix.corrDim'></span><span id='topic+radius.corrDim'></span><span id='topic+embeddingDims.corrDim'></span><span id='topic+plot.corrDim'></span><span id='topic+plotLocalScalingExp.corrDim'></span><span id='topic+estimate.corrDim'></span>

<h3>Description</h3>

<p>Functions for estimating the correlation sum and the correlation dimension 
of a dynamical system from 1-dimensional time series using Takens' vectors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>corrDim(
  time.series,
  min.embedding.dim = 2,
  max.embedding.dim = 5,
  time.lag = 1,
  min.radius,
  max.radius,
  corr.order = 2,
  n.points.radius = 5,
  theiler.window = 100,
  do.plot = TRUE,
  number.boxes = NULL,
  ...
)

## S3 method for class 'corrDim'
nlOrder(x)

## S3 method for class 'corrDim'
corrMatrix(x)

## S3 method for class 'corrDim'
radius(x)

## S3 method for class 'corrDim'
embeddingDims(x)

## S3 method for class 'corrDim'
plot(
  x,
  main = "Correlation Sum C(r)",
  xlab = NULL,
  ylab = "C(r)",
  type = "b",
  log = "xy",
  ylim = NULL,
  col = NULL,
  pch = NULL,
  localScalingExp = T,
  add.legend = T,
  cex.legend = 1,
  ...
)

## S3 method for class 'corrDim'
plotLocalScalingExp(
  x,
  main = "Correlation Dimension C(r)",
  xlab = NULL,
  ylab = "Local scaling exponents",
  type = "b",
  log = "x",
  ylim = NULL,
  col = NULL,
  pch = NULL,
  add.legend = T,
  ...
)

## S3 method for class 'corrDim'
estimate(
  x,
  regression.range = NULL,
  do.plot = FALSE,
  use.embeddings = NULL,
  col = NULL,
  pch = NULL,
  fit.col = NULL,
  fit.lty = 2,
  fit.lwd = 2,
  add.legend = T,
  lty = 1,
  lwd = 1,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="corrDim_+3A_time.series">time.series</code></td>
<td>
<p>The original time series from which the correlation sum 
will be estimated.</p>
</td></tr>
<tr><td><code id="corrDim_+3A_min.embedding.dim">min.embedding.dim</code></td>
<td>
<p>Integer denoting the minimum dimension in which we 
shall embed the time.series (see <a href="#topic+buildTakens">buildTakens</a>).</p>
</td></tr>
<tr><td><code id="corrDim_+3A_max.embedding.dim">max.embedding.dim</code></td>
<td>
<p>Integer denoting the maximum dimension in which we 
shall embed the time.series (see <a href="#topic+buildTakens">buildTakens</a>).Thus,
we shall estimate the correlation dimension between <em>min.embedding.dim</em> 
and <em>max.embedding.dim</em>.</p>
</td></tr>
<tr><td><code id="corrDim_+3A_time.lag">time.lag</code></td>
<td>
<p>Integer denoting the number of time steps that will be use 
to construct the Takens' vectors (see <a href="#topic+buildTakens">buildTakens</a>).</p>
</td></tr>
<tr><td><code id="corrDim_+3A_min.radius">min.radius</code></td>
<td>
<p>Minimum distance used to compute the correlation sum C(r).</p>
</td></tr>
<tr><td><code id="corrDim_+3A_max.radius">max.radius</code></td>
<td>
<p>Maximum distance used to compute the correlation sum C(r).</p>
</td></tr>
<tr><td><code id="corrDim_+3A_corr.order">corr.order</code></td>
<td>
<p>Order of the generalized correlation Dimension q. It must 
be greater than 1 (corr.order&gt;1). Default, corr.order=2.</p>
</td></tr>
<tr><td><code id="corrDim_+3A_n.points.radius">n.points.radius</code></td>
<td>
<p>The number of different radius where we shall estimate.
C(r). Thus,  we will estimate C(r) in n.points.radius between min.radius and 
max.radius.</p>
</td></tr>
<tr><td><code id="corrDim_+3A_theiler.window">theiler.window</code></td>
<td>
<p>Integer denoting the Theiler window:  Two Takens' 
vectors must be separated by more than theiler.window time steps in order to 
be considered neighbours. By using a Theiler window, we exclude temporally 
correlated vectors from our estimations.</p>
</td></tr>
<tr><td><code id="corrDim_+3A_do.plot">do.plot</code></td>
<td>
<p>Logical value. If TRUE (default value), a plot of the 
correlation sum is shown.</p>
</td></tr>
<tr><td><code id="corrDim_+3A_number.boxes">number.boxes</code></td>
<td>
<p>Number of boxes that will be used in the box assisted 
algorithm (see <a href="#topic+neighbourSearch">neighbourSearch</a>). If the user does not specify it, the 
function uses a proper number of boxes.</p>
</td></tr>
<tr><td><code id="corrDim_+3A_...">...</code></td>
<td>
<p>Additional plotting parameters.</p>
</td></tr>
<tr><td><code id="corrDim_+3A_x">x</code></td>
<td>
<p>A <em>corrDim</em> object.</p>
</td></tr>
<tr><td><code id="corrDim_+3A_main">main</code></td>
<td>
<p>A title for the plot.</p>
</td></tr>
<tr><td><code id="corrDim_+3A_xlab">xlab</code></td>
<td>
<p>A title for the x axis.</p>
</td></tr>
<tr><td><code id="corrDim_+3A_ylab">ylab</code></td>
<td>
<p>A title for the y axis.</p>
</td></tr>
<tr><td><code id="corrDim_+3A_type">type</code></td>
<td>
<p>Type of plot (see <code>?plot</code>).</p>
</td></tr>
<tr><td><code id="corrDim_+3A_log">log</code></td>
<td>
<p>A character string which contains &quot;x&quot; if the x axis is to be 
logarithmic, &quot;y&quot; if the y axis is to be logarithmic and &quot;xy&quot; or &quot;yx&quot; if both 
axes are to be logarithmic.</p>
</td></tr>
<tr><td><code id="corrDim_+3A_ylim">ylim</code></td>
<td>
<p>Numeric vector of length 2, giving the y coordinates range.</p>
</td></tr>
<tr><td><code id="corrDim_+3A_col">col</code></td>
<td>
<p>Vector of colors for each of the dimensions of the plot.</p>
</td></tr>
<tr><td><code id="corrDim_+3A_pch">pch</code></td>
<td>
<p>Vector of symbols for each of the dimensions of the plot.</p>
</td></tr>
<tr><td><code id="corrDim_+3A_localscalingexp">localScalingExp</code></td>
<td>
<p>add a plot of the local scaling exponents of the 
correlation sum.</p>
</td></tr>
<tr><td><code id="corrDim_+3A_add.legend">add.legend</code></td>
<td>
<p>add a legend to the plot?</p>
</td></tr>
<tr><td><code id="corrDim_+3A_cex.legend">cex.legend</code></td>
<td>
<p>Magnification value for the legend.</p>
</td></tr>
<tr><td><code id="corrDim_+3A_regression.range">regression.range</code></td>
<td>
<p>Vector with 2 components denoting the range where 
the function will perform linear regression.</p>
</td></tr>
<tr><td><code id="corrDim_+3A_use.embeddings">use.embeddings</code></td>
<td>
<p>A numeric vector specifying which embedding dimensions 
should the <em>estimate</em> function use to compute the correlation dimension.</p>
</td></tr>
<tr><td><code id="corrDim_+3A_fit.col">fit.col</code></td>
<td>
<p>A vector of colors to plot the regression lines.</p>
</td></tr>
<tr><td><code id="corrDim_+3A_fit.lty">fit.lty</code></td>
<td>
<p>The type of line to plot the regression lines.</p>
</td></tr>
<tr><td><code id="corrDim_+3A_fit.lwd">fit.lwd</code></td>
<td>
<p>The width of the line for the regression lines.</p>
</td></tr>
<tr><td><code id="corrDim_+3A_lty">lty</code></td>
<td>
<p>The line type of the correlation sums.</p>
</td></tr>
<tr><td><code id="corrDim_+3A_lwd">lwd</code></td>
<td>
<p>The line width of the correlation sums.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The correlation dimension is the most common measure of the fractal 
dimensionality of a geometrical object embedded in a phase space. In 
order to estimate the correlation dimension, the correlation sum is defined 
over the points from the phase space:
</p>
<p style="text-align: center;"><code class="reqn">C(r) = \{(number\;of\;points\;(x_i,x_j)\;verifying\;that\;distance\;(x_i,x_j)&lt;r\})/N^2</code>
</p>

<p>However, this estimator is biased when the pairs in the sum are not 
statistically independent. For example, Taken's vectors that are close in 
time, are usually close in the phase space due to the non-zero 
autocorrelation of the original time series. This is solved by using the 
so-called Theiler window: two Takens' vectors must be separated by, at least, 
the time steps specified with this window in order to be considered 
neighbours. By using a Theiler window, we exclude temporally correlated 
vectors from our estimations. 
</p>
<p>The correlation dimension is estimated using the slope obtained by 
performing a linear regression of 
<code class="reqn">\log10(C(r))\;Vs.\;\log10(r)</code>. Since this 
dimension is supposed to be an invariant of the system, it should not
depend on the dimension of the Taken's vectors used to estimate it. Thus, 
the user should plot <code class="reqn">\log10(C(r))\;Vs.\;\log10(r)</code> for several embedding
dimensions when looking for the correlation dimension and, if for some range
<code class="reqn">\log10(C(r))</code> shows a similar linear behaviour in 
different embedding dimensions (i.e. parallel slopes), these slopes are an 
estimate of the correlation dimension. The <em>estimate</em> routine 
allows the user to get always an estimate of the correlation dimension, but 
the user must check that there is a linear region in the correlation sum 
over different dimensions. If such a region does not exist, the estimation
should be discarded.
</p>
<p>Note that the correlation sum  C(r) may be interpreted as:
<code class="reqn">C(r) = &lt;p(r)&gt;,</code>
that is: the mean probability of finding a neighbour in a ball of radius r 
surrounding a point in the phase space. Thus, it is possible to define a 
generalization of the correlation dimension by writing:
</p>
<p style="text-align: center;"><code class="reqn">C_q(r) = &lt;p(r)^{(q-1)}&gt;</code>
</p>

<p>Note that the correlation sum </p>
<p style="text-align: center;"><code class="reqn">C(r) = C_2(r)</code>
</p>

<p>It is possible to determine generalized dimensions Dq using the slope 
obtained by performing a linear regression of 
<code class="reqn">log10(Cq(r))\;Vs.\;(q-1)log10(r)</code>. The case q=1 leads to the 
information dimension, that is treated separately in this package 
(<a href="#topic+infDim">infDim</a>). The considerations discussed for the correlation dimension 
estimate are also valid for these generalized dimensions.
</p>


<h3>Value</h3>

<p>A <em>corrDim</em> object that consist of a list with four 
components named <em>radius</em>, <em>embedding.dims</em>, <em>order</em> and 
<em>corr.matrix</em>. <em>radius</em> is a vector containing the different radius 
where we have evaluated C(r). <em>embedding.dims</em> is a vector containing
all the embedding dimensions in which we have estimated C(r). <em>order</em> 
stores the order of the generalized correlation dimension
that has been used. Finally, <em>corr.matrix</em> stores all the correlation
sums that have been computed. Each row stores the correlation sum for a 
concrete embedding dimension whereas each colum stores the correlation sum 
for a specific radius.
</p>
<p>The <em>nlOrder</em> function returns the order of the correlation sum.
</p>
<p>The <em>corrMatrix</em> function returns the correlations matrix 
storing the correlation sums that have been computed for all the embedding 
dimensions.
</p>
<p>The <em>radius</em> function returns the radius on which the 
correlation sum function has been evaluated.
</p>
<p>The <em>embeddingDims</em> function returns the embedding dimensions 
on which the correlation sum function has been evaluated.
</p>
<p>The <em>plot</em> function plots the correlation sum. It is possible to
plot the the correlation sum Vs the radius and also the local scaling 
exponents of the correlation  sum Vs radius.
</p>
<p>The <em>plotLocalScalingExp</em> function plots the local scaling 
exponents of  the  correlation sum.
</p>
<p>The <em>estimate</em> function estimates the correlation dimension of 
the <em>corr.dim</em> object by averaging the slopes of the embedding 
dimensions specified in the <em>use.embeddings</em> parameter. The slopes 
are determined by performing a linear regression over the radius' range 
specified in <em>regression.range</em>.If <em>do.plot</em> is TRUE, a graphic of 
the regression over the data is shown.
</p>


<h3>Author(s)</h3>

<p>Constantino A. Garcia
</p>


<h3>References</h3>

<p>H. Kantz  and T. Schreiber: Nonlinear Time series Analysis 
(Cambridge university press)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
x=lorenz(sigma=10, rho = 28, beta =8/3, start = c(-10, -11, 47),
time =  seq(0, 70, by = 0.01), do.plot = FALSE)$x
cd=corrDim(time.series=x,min.embedding.dim=3,max.embedding.dim=6,
           time.lag=10,min.radius=1e-3,max.radius=50,
           n.points.radius=100,theiler.window=100,
           number.boxes=100,do.plot=F)

plot(cd,type="l")
plotLocalScalingExp(cd,cex=0.5,xlim=c(1e-1,5))
cd.est = estimate(cd,regression.range=c(0.2,2))
cat("expected: 2.05  --- estimate: ",cd.est,"\n")

## End(Not run)
</code></pre>

<hr>
<h2 id='corrMatrix'>Returns the correlation sums stored in the <em>corrDim</em> object</h2><span id='topic+corrMatrix'></span>

<h3>Description</h3>

<p>Returns the correlation sums stored in the <em>corrDim</em> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>corrMatrix(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="corrMatrix_+3A_x">x</code></td>
<td>
<p>A <em>corrDim</em> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The <em>corrMatrix</em> function returns the correlations matrix 
storing the correlation sums that have been computed for all the embedding 
dimensions.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+corrDim">corrDim</a></code>
</p>

<hr>
<h2 id='dfa'>Detrended Fluctuation Analysis</h2><span id='topic+dfa'></span><span id='topic+windowSizes.dfa'></span><span id='topic+fluctuationFunction.dfa'></span><span id='topic+plot.dfa'></span><span id='topic+estimate.dfa'></span>

<h3>Description</h3>

<p>Functions for performing Detrended Fluctuation Analysis (DFA), a widely used
technique for detecting long range correlations in time series. These 
functions are able to estimate several scaling exponents from the time series 
being analyzed. 
These scaling exponents  characterize short or long-term fluctuations, 
depending of the range used for regression (see  details).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dfa(
  time.series,
  window.size.range = c(10, 300),
  npoints = 20,
  do.plot = TRUE,
  ...
)

## S3 method for class 'dfa'
windowSizes(x)

## S3 method for class 'dfa'
fluctuationFunction(x)

## S3 method for class 'dfa'
plot(
  x,
  main = "Detrended Fluctuation Analysis",
  xlab = "Window size: t",
  ylab = "Fluctuation function: F(t)",
  log = "xy",
  ...
)

## S3 method for class 'dfa'
estimate(
  x,
  regression.range = NULL,
  do.plot = FALSE,
  fit.col = 2,
  fit.lty = 1,
  fit.lwd = 1,
  add.legend = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dfa_+3A_time.series">time.series</code></td>
<td>
<p>The original time series to be analyzed.</p>
</td></tr>
<tr><td><code id="dfa_+3A_window.size.range">window.size.range</code></td>
<td>
<p>Range of values for the windows size that will be 
used to estimate the fluctuation function. Default: c(10,300).</p>
</td></tr>
<tr><td><code id="dfa_+3A_npoints">npoints</code></td>
<td>
<p>The number of different window sizes that will be used to 
estimate the Fluctuation function in each zone.</p>
</td></tr>
<tr><td><code id="dfa_+3A_do.plot">do.plot</code></td>
<td>
<p>logical value. If TRUE (default value), a plot of the 
Fluctuation function is shown.</p>
</td></tr>
<tr><td><code id="dfa_+3A_...">...</code></td>
<td>
<p>Additional graphical parameters.</p>
</td></tr>
<tr><td><code id="dfa_+3A_x">x</code></td>
<td>
<p>A <em>dfa</em> object.</p>
</td></tr>
<tr><td><code id="dfa_+3A_main">main</code></td>
<td>
<p>A title for the plot.</p>
</td></tr>
<tr><td><code id="dfa_+3A_xlab">xlab</code></td>
<td>
<p>A title for the x axis.</p>
</td></tr>
<tr><td><code id="dfa_+3A_ylab">ylab</code></td>
<td>
<p>A title for the y axis.</p>
</td></tr>
<tr><td><code id="dfa_+3A_log">log</code></td>
<td>
<p>A character string which contains &quot;x&quot; if the x axis is to be 
logarithmic, &quot;y&quot; if the y axis is to be logarithmic and &quot;xy&quot; or &quot;yx&quot; if 
both axes are to be logarithmic.</p>
</td></tr>
<tr><td><code id="dfa_+3A_regression.range">regression.range</code></td>
<td>
<p>Vector with 2 components denoting the range where 
the function will perform linear regression.</p>
</td></tr>
<tr><td><code id="dfa_+3A_fit.col">fit.col</code></td>
<td>
<p>A colors to plot the regression line.</p>
</td></tr>
<tr><td><code id="dfa_+3A_fit.lty">fit.lty</code></td>
<td>
<p>The type of line to plot the regression line.</p>
</td></tr>
<tr><td><code id="dfa_+3A_fit.lwd">fit.lwd</code></td>
<td>
<p>The width of the line for the regression line.</p>
</td></tr>
<tr><td><code id="dfa_+3A_add.legend">add.legend</code></td>
<td>
<p>add a legend with the resulting estmation to the plot?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Detrended Fluctuation Analysis (DFA) has become a widely used
technique for detecting long range correlations in time series. The DFA 
procedure may be summarized as follows:
</p>

<ol>
<li><p> Integrate the time series to be analyzed. The time series resulting 
from the  integration will be referred to as the profile.
</p>
</li>
<li><p> Divide the profile into N non-overlapping segments.
</p>
</li>
<li><p>  Calculate the local trend for each of the segments using least-square
regression. Compute the total error for each ofi the segments.
</p>
</li>
<li><p> Compute the average of the total error over all segments and take its 
root square. By repeating the previous steps for several segment sizes 
(let's denote it by t), we obtain the so-called Fluctuation function 
<code class="reqn">F(t)</code>.
</p>
</li>
<li><p>  If the data presents long-range power law correlations:  
<code class="reqn">F(t) \sim t^\alpha</code> and we may estimate 
using regression.
</p>
</li>
<li><p>  Usually, when plotting 
<code class="reqn">\log(F(t))\;Vs\;log(t)</code> 
we may distinguish two linear regions.
By regressing them separately, we obtain two scaling exponents, 
<em><code class="reqn">\alpha_1</code></em> (characterizing short-term fluctuations) and 
<em><code class="reqn">\alpha_2</code></em> (characterizing long-term fluctuations). 
</p>
</li></ol>

<p>Steps 1-4 are performed using the <em>dfa</em> function. In order to obtain a 
estimate of some scaling exponent, the user must use the  <em>estimate</em> 
function specifying the regression range (window sizes used to detrend the 
series).
</p>


<h3>Value</h3>

<p>A <em>dfa</em>  object.
</p>
<p>The <em>windowSizes</em> function returns the windows sizes used
to detrend the time series.
</p>
<p>The <em>fluctuationFunction</em> function returns the fluctuation 
function obtained in the DFA represented by the <em>dfa</em> object.
</p>


<h3>Author(s)</h3>

<p>Constantino A. Garcia
</p>


<h3>References</h3>

<p>Penzel, Thomas, et al. &quot;Comparison of detrended fluctuation 
analysis and spectral analysis for heart rate variability in sleep and 
sleep apnea.&quot; Biomedical Engineering, IEEE Transactions on 50.10 (2003): 
1143-1151.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
 white.noise = rnorm(5000)
dfa.analysis = dfa(time.series = white.noise, npoints = 10, 
                 window.size.range=c(10,1000), do.plot=FALSE)
white.estimation = estimate(dfa.analysis,do.plot=TRUE)
cat("Theorical: 0.5---Estimated: ",white.estimation ,"\n")


library(fArma)
fgn = as.numeric(fArma::fgnSim(n = 2000, H = 0.75))
dfa.analysis = dfa(time.series = fgn, npoints = 30, 
                   window.size.range=c(10,1000), 
                   do.plot=FALSE)
fgn.estimation = estimate(dfa.analysis, do.plot = TRUE,
                          fit.col="blue",fit.lwd=2,fit.lty=2,
                          main="Fitting DFA to fGn")
cat("Theorical: 0.75---Estimated: ",fgn.estimation ,"\n")


fbm = as.numeric(fArma::fbmSim(n = 2000, H = 0.25))
dfa.analysis = dfa(time.series = fbm, npoints = 50, 
                   window.size.range=c(10,300), 
                   do.plot=FALSE)
fbm.estimation = estimate(dfa.analysis,do.plot = TRUE,
                          add.legend=F, main="DFA of fBm")
cat("Theorical: 1.25 ---Estimated: ",fbm.estimation ,"\n")


## End(Not run)
</code></pre>

<hr>
<h2 id='divergence'>Returns the rate of divergence of close trajectories needed for the maximum 
Lyapunov exponent estimation.</h2><span id='topic+divergence'></span>

<h3>Description</h3>

<p>Returns the rate of divergence of close trajectories needed for the maximum 
Lyapunov exponent estimation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>divergence(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="divergence_+3A_x">x</code></td>
<td>
<p>A <em>maxLyapunov</em> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric matrix representing the time in which the divergence of
close trajectories was computed. Each row represents an embedding dimension
whereas that each column represents an specific moment of time.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+maxLyapunov">maxLyapunov</a></code>
</p>

<hr>
<h2 id='divTime'>Returns the time in which the divergence of close trajectories was computed 
in order to estimate the maximum Lyapunov exponent.</h2><span id='topic+divTime'></span>

<h3>Description</h3>

<p>Returns the time in which the divergence of close trajectories was computed 
in order to estimate the maximum Lyapunov exponent.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>divTime(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="divTime_+3A_x">x</code></td>
<td>
<p>A <em>maxLyapunov</em> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector representing the time in which the divergence of
close trajectories was computed.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+maxLyapunov">maxLyapunov</a></code>
</p>

<hr>
<h2 id='embeddingDims'>Get the embedding dimensions used for compute a chaotic invariant.</h2><span id='topic+embeddingDims'></span>

<h3>Description</h3>

<p>Get the embedding dimensions used for compute a chaotic invariant.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>embeddingDims(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="embeddingDims_+3A_x">x</code></td>
<td>
<p>An object containing all the information needed for the estimate.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector with the embedding dimensions used for compute a
chaotic invariant.
</p>


<h3>Author(s)</h3>

<p>Constantino A. Garcia
</p>


<h3>References</h3>

<p>H. Kantz  and T. Schreiber: Nonlinear Time series Analysis 
(Cambridge university press)
</p>

<hr>
<h2 id='estimate'>Estimate several chaotic invariants using linear regression</h2><span id='topic+estimate'></span>

<h3>Description</h3>

<p>Several chaotic invariants are estimated by using linear regression. This
function provides a common interface for the estimate of all these parameters
(see <code><a href="#topic+corrDim">corrDim</a></code>, <code><a href="#topic+dfa">dfa</a></code> and <code><a href="#topic+maxLyapunov">maxLyapunov</a></code> 
for examples).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimate(x, regression.range, do.plot, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="estimate_+3A_x">x</code></td>
<td>
<p>An object containing all the information needed for the estimate.</p>
</td></tr>
<tr><td><code id="estimate_+3A_regression.range">regression.range</code></td>
<td>
<p>Range of values on the x-axis on which the regression
is performed.</p>
</td></tr>
<tr><td><code id="estimate_+3A_do.plot">do.plot</code></td>
<td>
<p>Logical value. If TRUE (default value), a plot of the 
regression is shown.</p>
</td></tr>
<tr><td><code id="estimate_+3A_...">...</code></td>
<td>
<p>Additional parameters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An estimate of the proper chaotic invariant.
</p>


<h3>Author(s)</h3>

<p>Constantino A. Garcia
</p>


<h3>References</h3>

<p>H. Kantz  and T. Schreiber: Nonlinear Time series Analysis 
(Cambridge university press)
</p>

<hr>
<h2 id='estimateEmbeddingDim'>Estimate the embedding dimension</h2><span id='topic+estimateEmbeddingDim'></span>

<h3>Description</h3>

<p>This function determines the minimum embedding dimension from a scalar time 
series using the algorithm proposed by L. Cao (see references).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimateEmbeddingDim(
  time.series,
  number.points = length(time.series),
  time.lag = 1,
  max.embedding.dim = 15,
  threshold = 0.95,
  max.relative.change = 0.1,
  do.plot = TRUE,
  main = "Computing the embedding dimension",
  xlab = "dimension (d)",
  ylab = "E1(d) &amp; E2(d)",
  ylim = NULL,
  xlim = NULL,
  std.noise
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="estimateEmbeddingDim_+3A_time.series">time.series</code></td>
<td>
<p>The original time series.</p>
</td></tr>
<tr><td><code id="estimateEmbeddingDim_+3A_number.points">number.points</code></td>
<td>
<p>Number of points from the time series that will be used 
to estimate the embedding dimension. By default, all the points in the time 
series are used.</p>
</td></tr>
<tr><td><code id="estimateEmbeddingDim_+3A_time.lag">time.lag</code></td>
<td>
<p>Time lag used to build the Takens' vectors needed to 
estimate the embedding dimension (see <a href="#topic+buildTakens">buildTakens</a>). Default: 1.</p>
</td></tr>
<tr><td><code id="estimateEmbeddingDim_+3A_max.embedding.dim">max.embedding.dim</code></td>
<td>
<p>Maximum possible embedding dimension for the time 
series. Default: 15.</p>
</td></tr>
<tr><td><code id="estimateEmbeddingDim_+3A_threshold">threshold</code></td>
<td>
<p>Numerical value between 0 and 1. The embedding dimension is 
estimated using the E1(d) function. E1(d) stops changing when d is greater 
than or equal to embedding dimension, staying close to 1. This value 
establishes a threshold for considering that E1(d) is close to 1. 
Default: 0.95</p>
</td></tr>
<tr><td><code id="estimateEmbeddingDim_+3A_max.relative.change">max.relative.change</code></td>
<td>
<p>Maximum relative change in E1(d) with respect to 
E1(d-1) in order to consider that the E1 function has been stabilized and it 
will stop changing. Default: 0.01.</p>
</td></tr>
<tr><td><code id="estimateEmbeddingDim_+3A_do.plot">do.plot</code></td>
<td>
<p>Logical value. If TRUE (default value), a plot of E1(d) and 
E2(d) is shown.</p>
</td></tr>
<tr><td><code id="estimateEmbeddingDim_+3A_main">main</code></td>
<td>
<p>Title for the plot.</p>
</td></tr>
<tr><td><code id="estimateEmbeddingDim_+3A_xlab">xlab</code></td>
<td>
<p>Title for the x axis.</p>
</td></tr>
<tr><td><code id="estimateEmbeddingDim_+3A_ylab">ylab</code></td>
<td>
<p>Title for the y axis.</p>
</td></tr>
<tr><td><code id="estimateEmbeddingDim_+3A_ylim">ylim</code></td>
<td>
<p>numeric vectors of length 2, giving the y coordinates range.</p>
</td></tr>
<tr><td><code id="estimateEmbeddingDim_+3A_xlim">xlim</code></td>
<td>
<p>numeric vectors of length 2, giving the x coordinates range.</p>
</td></tr>
<tr><td><code id="estimateEmbeddingDim_+3A_std.noise">std.noise</code></td>
<td>
<p>numeric value that permits to add a small amount of noise
to the original series to avoid the appearance of false neighbours due to 
discretizacion errors. This also prevents the method to fail with periodic
signals (in which neighbours at a distance of 0 appear). By default, a small
amount of noise is always added. Use 0 not to add noise.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Cao's algorithm uses 2 functions in order to estimate the embedding 
dimension from a time series: the E1(d) and the E2(d) functions, where d 
denotes the dimension.
</p>
<p>E1(d) stops changing when d is greater than or equal to the embedding 
dimension, staying close to 1. On the other hand, E2(d) is used to 
distinguish deterministic signals from stochastic signals. For 
deterministic signals, there exist some d such that E2(d)!=1. For stochastic 
signals, E2(d) is approximately 1 for all the values. 
</p>
<p>This function uses the Arya and Mount's C++ ANN library for nearest neighbour
search (For more information on the ANN library please visit 
<a href="http://www.cs.umd.edu/~mount/ANN/">http://www.cs.umd.edu/~mount/ANN/</a>). The R wrapper is a modified 
version of the RANN package code by Samuel E. Kemp and Gregory Jefferis.
</p>
<p>If no suitable embedding dimension can be found within the provided range,
the function will return NA.
</p>


<h3>Note</h3>

<p>In the current version of the package, the automatic detection of stochastic 
signals has not been implemented yet.
</p>


<h3>Author(s)</h3>

<p>Constantino A. Garcia
</p>


<h3>References</h3>

<p>Cao, L. Practical method for determining the minimum embedding dimension of
a scalar time series. Physica D: Nonlinear Phenomena, 110,1, 
pp. 43-50 (1997).
</p>
<p>Arya S. and Mount D. M. (1993), Approximate nearest neighbor searching, 
Proc. 4th Ann. ACM-SIAM Symposium on Discrete Algorithms (SODA'93), 271-280.
</p>
<p>Arya S., Mount D. M., Netanyahu N. S., Silverman R. and Wu A. Y (1998), 
An optimal algorithm for approximate nearest neighbor searching, 
Journal of the ACM, 45, 891-923.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
h = henon(do.plot=FALSE) 
dimension = estimateEmbeddingDim(h$x, time.lag=1, max.embedding.dim=6,
             threshold=0.9, do.plot=TRUE)
             
## End(Not run)
</code></pre>

<hr>
<h2 id='FFTsurrogate'>Generate surrogate data using the Fourier transform</h2><span id='topic+FFTsurrogate'></span>

<h3>Description</h3>

<p>Generates surrogate samples from the original time series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FFTsurrogate(time.series, n.samples = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="FFTsurrogate_+3A_time.series">time.series</code></td>
<td>
<p>The original time.series from which the surrogate data 
is generated.</p>
</td></tr>
<tr><td><code id="FFTsurrogate_+3A_n.samples">n.samples</code></td>
<td>
<p>The number of surrogate data sets to generate,</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function uses the phase randomization procedure for 
generating the surrogated data. This algorithm generates surrogate data with
the same mean and autocorrelation function (and thus, the same power 
spectrum because of the Wiener-Khinchin theorem) as the original time 
series.
</p>
<p>The phase randomization algorithm is often used when the null hypothesis 
being tested consist on the assumption that the time.series data comes from 
a stationary linear stochastic process with Gaussian inputs. The phase 
randomization preserves the Gaussian distribution.
</p>


<h3>Value</h3>

<p>A matrix containing the generated surrogate data (one time series 
per row).
</p>


<h3>Author(s)</h3>

<p>Constantino A. Garcia
</p>


<h3>References</h3>

<p>H. Kantz  and T. Schreiber: Nonlinear Time series Analysis 
(Cambridge university press)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# generate 20 surrogate sets using as original time series
# an arma(1,1) simulation
time.series = arima.sim(list(order = c(1,0,1), ar = 0.6, ma = 0.5), n = 200)
surrogate = FFTsurrogate(time.series, 20)

## End(Not run)
</code></pre>

<hr>
<h2 id='findAllNeighbours'>neighbour search</h2><span id='topic+findAllNeighbours'></span>

<h3>Description</h3>

<p>This function finds all the neighbours of all the vectors from Takens'
vector array. The neighbours are found using a box assisted algorithm that
creates a wrapped grid of a given number of boxes per dimension.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>findAllNeighbours(takens, radius, number.boxes = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="findAllNeighbours_+3A_takens">takens</code></td>
<td>
<p>The matrix containing all the Takens' vectors 
(see <a href="#topic+buildTakens">buildTakens</a>).</p>
</td></tr>
<tr><td><code id="findAllNeighbours_+3A_radius">radius</code></td>
<td>
<p>Distance in which the algorithm will search for neighbours.</p>
</td></tr>
<tr><td><code id="findAllNeighbours_+3A_number.boxes">number.boxes</code></td>
<td>
<p>Integer denoting the number of boxes per dimension that 
will be used to construct a wrapped grid (see Schreiber). If the user does 
not specify a number of boxes, this function estimates a proper number.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list in which the n-th position contains another list with all 
the neighbours of the n-th Takens' vector. If the list is empty, that means 
that there is no neighbour of the n-th Takens' vector in the given radius.
</p>


<h3>Author(s)</h3>

<p>Constantino A. Garcia
</p>


<h3>References</h3>

<p>Schreiber, T. Efficient neighbor searching in nonlinear time 
series analysis. Int. J. Bifurcation and Chaos, 5, p. 349, (1995).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+neighbourSearch">neighbourSearch</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Find all the neighbours Takens' vectors build from the Henon time
# series. The size of the neighbourhood is set to 0.1.
h=henon(start = c(0.63954883, 0.04772637), do.plot = FALSE)
takens = buildTakens(h$x,embedding.dim=2,time.lag=1)
neighbours=findAllNeighbours(takens,0.1)

## End(Not run)
</code></pre>

<hr>
<h2 id='fixedMass'>fixed mass</h2><span id='topic+fixedMass'></span>

<h3>Description</h3>

<p>fixed mass
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fixedMass(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fixedMass_+3A_x">x</code></td>
<td>
<p>A <em>infDim</em> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector representing the fixed mass vector used
in the information dimension algorithm represented by the <em>infDim</em> 
object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+infDim">infDim</a></code>
</p>

<hr>
<h2 id='fluctuationFunction'>Returns the fluctuation function obtained in a DFA and represented by a
<em>dfa</em> object.</h2><span id='topic+fluctuationFunction'></span>

<h3>Description</h3>

<p>Returns the fluctuation function obtained in a DFA and represented by a
<em>dfa</em> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fluctuationFunction(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fluctuationFunction_+3A_x">x</code></td>
<td>
<p>A <em>dfa</em> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The <em>fluctuationFunction</em> function returns the fluctuation 
function used obtained in the DFA.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dfa">dfa</a></code>
</p>

<hr>
<h2 id='gaussMap'>Gauss map</h2><span id='topic+gaussMap'></span>

<h3>Description</h3>

<p>Generates a 1-dimensional time series using the Gauss map
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gaussMap(
  a = 4.9,
  b = -0.58,
  start = runif(1, min = -0.5, max = 0.5),
  n.sample = 5000,
  n.transient = 500,
  do.plot = deprecated()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gaussMap_+3A_a">a</code></td>
<td>
<p>The <em>a</em> parameter. Default: 4.9</p>
</td></tr>
<tr><td><code id="gaussMap_+3A_b">b</code></td>
<td>
<p>The <em>b</em> parameter. Default: -0.58</p>
</td></tr>
<tr><td><code id="gaussMap_+3A_start">start</code></td>
<td>
<p>A numeric value indicating the starting value for the time series.
If the starting point is not specified, it is generated randomly.</p>
</td></tr>
<tr><td><code id="gaussMap_+3A_n.sample">n.sample</code></td>
<td>
<p>Length of the generated time series. Default: 5000 samples.</p>
</td></tr>
<tr><td><code id="gaussMap_+3A_n.transient">n.transient</code></td>
<td>
<p>Number of transient samples that will be discarded. 
Default: 500 samples.</p>
</td></tr>
<tr><td><code id="gaussMap_+3A_do.plot">do.plot</code></td>
<td>
<p>Logical value. If TRUE, a plot of the 
generated Gauss system is shown. Before version 0.2.11, default value was
TRUE; versions 0.2.11 and later use FALSE as default.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Gauss map is defined as follows:
</p>
<p style="text-align: center;"><code class="reqn">x_{n+1}= exp(-a \cdot (x_n)^2) + b</code>
</p>

<p>The default selection for both <em>a</em> and <em>b</em> parameters is known to 
produce a deterministic chaotic time series.
</p>


<h3>Value</h3>

<p>A vector containing the values of the time series that has been 
generated.
</p>


<h3>Note</h3>

<p>Some initial values may lead to an unstable system that will tend to 
infinity.
</p>


<h3>Author(s)</h3>

<p>Constantino A. Garcia
</p>


<h3>References</h3>

<p>Chaos and nonlinear dynamics: an introduction for scientists and engineers, 
by Robert C. Hilborn, 2nd Ed., Oxford, Univ. Press, New York, 2004.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+henon">henon</a>, <a href="#topic+logisticMap">logisticMap</a>, <a href="#topic+lorenz">lorenz</a>, 
<a href="#topic+rossler">rossler</a>, <a href="#topic+ikedaMap">ikedaMap</a>, <a href="#topic+cliffordMap">cliffordMap</a>, <a href="#topic+sinaiMap">sinaiMap</a></code>
</p>

<hr>
<h2 id='getContourLines'>Obtain the contour lines of the space time plot.</h2><span id='topic+getContourLines'></span>

<h3>Description</h3>

<p>Obtain the contour lines of the space time plot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getContourLines(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getContourLines_+3A_x">x</code></td>
<td>
<p>A <em>spaceTimePlot</em> object.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+spaceTimePlot">spaceTimePlot</a></code>
</p>

<hr>
<h2 id='henon'>Henon map</h2><span id='topic+henon'></span>

<h3>Description</h3>

<p>Generates a 2-dimensional time series using the Henon map.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>henon(
  start = runif(min = -0.5, max = 0.5, n = 2),
  a = 1.4,
  b = 0.3,
  n.sample = 5000,
  n.transient = 500,
  do.plot = deprecated()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="henon_+3A_start">start</code></td>
<td>
<p>A 2-dimensional vector indicating the starting values for the 
x and y Henon coordinates. If the starting point is not specified, it is 
generated randomly.</p>
</td></tr>
<tr><td><code id="henon_+3A_a">a</code></td>
<td>
<p>The <em>a</em> parameter. Default: 1.4.</p>
</td></tr>
<tr><td><code id="henon_+3A_b">b</code></td>
<td>
<p>The <em>b</em> parameter. Default: 0.3.</p>
</td></tr>
<tr><td><code id="henon_+3A_n.sample">n.sample</code></td>
<td>
<p>Length of the generated time series. Default: 5000 samples.</p>
</td></tr>
<tr><td><code id="henon_+3A_n.transient">n.transient</code></td>
<td>
<p>Number of transient samples that will be discarded. 
Default: 500 samples.</p>
</td></tr>
<tr><td><code id="henon_+3A_do.plot">do.plot</code></td>
<td>
<p>Logical value. If TRUE, a plot of the 
generated Henon system is shown. Before version 0.2.11, default value was
TRUE; versions 0.2.11 and later use FALSE as default.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Henon map is defined as follows:
</p>
<p style="text-align: center;"><code class="reqn"> x_n = 1 - a \cdot x_{n - 1}^2 + y_{n - 1}</code>
</p>

<p style="text-align: center;"><code class="reqn"> y_n = b \cdot x_{n - 1}</code>
</p>

<p>The default selection for both <em>a</em> and <em>b</em> parameters 
(<em>a</em>=1.4 and <em>b</em>=0.3) is known to produce a deterministic chaotic 
time series.
</p>


<h3>Value</h3>

<p>A list with two vectors named <em>x</em> and <em>y</em> containing the 
x-components and the y-components of the Henon map, respectively.
</p>


<h3>Note</h3>

<p>Some initial values may lead to an unstable system that will tend to 
infinity.
</p>


<h3>Author(s)</h3>

<p>Constantino A. Garcia
</p>


<h3>References</h3>

<p>Strogatz, S.: Nonlinear dynamics and chaos: with applications 
to physics, biology, chemistry and engineering (Studies in Nonlinearity)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+logisticMap">logisticMap</a>, <a href="#topic+lorenz">lorenz</a>, <a href="#topic+rossler">rossler</a>, 
<a href="#topic+ikedaMap">ikedaMap</a>, <a href="#topic+cliffordMap">cliffordMap</a>, <a href="#topic+sinaiMap">sinaiMap</a>, <a href="#topic+gaussMap">gaussMap</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
henon.map=henon(n.sample = 1000, n.transient=10,do.plot=TRUE,
               start=c(-0.006423277,-0.473545134))
# accessing the x coordinate and plotting it
plot(ts(henon.map$x))

## End(Not run)
</code></pre>

<hr>
<h2 id='ikedaMap'>Ikeda map</h2><span id='topic+ikedaMap'></span>

<h3>Description</h3>

<p>Generates a time series using the Ikeda map
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ikedaMap(
  a = 0.85,
  b = 0.9,
  cc = 7.7,
  k = 0.4,
  start = runif(2),
  n.sample = 5000,
  n.transient = 500,
  do.plot = deprecated()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ikedaMap_+3A_a">a</code></td>
<td>
<p>The <em>a</em> parameter. Default: 0.85.</p>
</td></tr>
<tr><td><code id="ikedaMap_+3A_b">b</code></td>
<td>
<p>The <em>b</em> parameter. Default: 0.9.</p>
</td></tr>
<tr><td><code id="ikedaMap_+3A_cc">cc</code></td>
<td>
<p>The <em>c</em> parameter. Default: 7.7.</p>
</td></tr>
<tr><td><code id="ikedaMap_+3A_k">k</code></td>
<td>
<p>The <em>k</em> parameter. Default: 0.4.</p>
</td></tr>
<tr><td><code id="ikedaMap_+3A_start">start</code></td>
<td>
<p>a 2-dimensional numeric vector indicating the starting value for the time series.
If the starting point is not specified, it is generated randomly.</p>
</td></tr>
<tr><td><code id="ikedaMap_+3A_n.sample">n.sample</code></td>
<td>
<p>Length of the generated time series. Default: 5000 samples.</p>
</td></tr>
<tr><td><code id="ikedaMap_+3A_n.transient">n.transient</code></td>
<td>
<p>Number of transient samples that will be discarded. 
Default: 500 samples.</p>
</td></tr>
<tr><td><code id="ikedaMap_+3A_do.plot">do.plot</code></td>
<td>
<p>Logical value. If TRUE, a plot of the 
generated ikeda system is shown. Before version 0.2.11, default value was
TRUE; versions 0.2.11 and later use FALSE as default.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Ikeda map is defined as follows:
</p>
<p style="text-align: center;"><code class="reqn">z_{n+1} = a + b \cdot z_n \cdot exp( ik-\frac{ic}{( 1+ |z_{n-1}|^2  )} )</code>
</p>

<p>The default selection for the <em>a</em>, <em>b</em>, <em>c</em> and <em>k</em> parameters is known to
produce a deterministic chaotic time series.
</p>


<h3>Value</h3>

<p>a list with 2 vectors named <em>x</em> and <em>y</em> the x-components 
and the y-components of the Ikeda map, respectively.
</p>


<h3>Note</h3>

<p>Some initial values may lead to an unstable system that will tend to 
infinity.
</p>


<h3>Author(s)</h3>

<p>Constantino A. Garcia
</p>


<h3>References</h3>

<p>Strogatz, S.: Nonlinear dynamics and chaos: with applications 
to physics, biology, chemistry and engineering (Studies in Nonlinearity)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+henon">henon</a>, <a href="#topic+logisticMap">logisticMap</a>, <a href="#topic+lorenz">lorenz</a>, 
<a href="#topic+rossler">rossler</a>, <a href="#topic+cliffordMap">cliffordMap</a>, <a href="#topic+sinaiMap">sinaiMap</a>, <a href="#topic+gaussMap">gaussMap</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
ikeda.map=ikedaMap(n.sample = 1000, n.transient=10, do.plot=TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='infDim'>Information dimension</h2><span id='topic+infDim'></span><span id='topic+fixedMass.infDim'></span><span id='topic+logRadius.infDim'></span><span id='topic+embeddingDims.infDim'></span><span id='topic+estimate.infDim'></span><span id='topic+plot.infDim'></span><span id='topic+plotLocalScalingExp.infDim'></span>

<h3>Description</h3>

<p>Functions for estimating the information dimension of a dynamical 
system from 1-dimensional time series using Takens' vectors
</p>


<h3>Usage</h3>

<pre><code class='language-R'>infDim(
  time.series,
  min.embedding.dim = 2,
  max.embedding.dim = min.embedding.dim,
  time.lag = 1,
  min.fixed.mass,
  max.fixed.mass,
  number.fixed.mass.points = 10,
  radius,
  increasing.radius.factor = sqrt(2),
  number.boxes = NULL,
  number.reference.vectors = 5000,
  theiler.window = 1,
  kMax = 1000,
  do.plot = TRUE,
  ...
)

## S3 method for class 'infDim'
fixedMass(x)

## S3 method for class 'infDim'
logRadius(x)

## S3 method for class 'infDim'
embeddingDims(x)

## S3 method for class 'infDim'
estimate(
  x,
  regression.range = NULL,
  do.plot = TRUE,
  use.embeddings = NULL,
  col = NULL,
  pch = NULL,
  fit.col = NULL,
  fit.lty = 2,
  fit.lwd = 2,
  add.legend = T,
  lty = 1,
  lwd = 1,
  ...
)

## S3 method for class 'infDim'
plot(
  x,
  main = "Information Dimension",
  xlab = "fixed mass (p)",
  ylab = "&lt;log10(radius)&gt;",
  type = "b",
  log = "x",
  ylim = NULL,
  col = NULL,
  pch = NULL,
  localScalingExp = T,
  add.legend = T,
  ...
)

## S3 method for class 'infDim'
plotLocalScalingExp(
  x,
  main = "Local scaling exponents d1(p)",
  xlab = "fixed mass p",
  ylab = "1/d1(p)",
  type = "b",
  log = "x",
  ylim = NULL,
  col = NULL,
  pch = NULL,
  add.legend = T,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="infDim_+3A_time.series">time.series</code></td>
<td>
<p>The original time series from which the information 
dimension will be estimated.</p>
</td></tr>
<tr><td><code id="infDim_+3A_min.embedding.dim">min.embedding.dim</code></td>
<td>
<p>Integer denoting the minimum dimension in which we 
shall embed the time.series (see <a href="#topic+buildTakens">buildTakens</a>).</p>
</td></tr>
<tr><td><code id="infDim_+3A_max.embedding.dim">max.embedding.dim</code></td>
<td>
<p>Integer denoting the maximum dimension in which we 
shall embed the time.series (see <a href="#topic+buildTakens">buildTakens</a>).Thus,
we shall estimate the information dimension between <em>min.embedding.dim</em> 
and <em>max.embedding.dim</em>.</p>
</td></tr>
<tr><td><code id="infDim_+3A_time.lag">time.lag</code></td>
<td>
<p>Integer denoting the number of time steps that will be use 
to construct the Takens' vectors (see <code><a href="#topic+buildTakens">buildTakens</a></code>).</p>
</td></tr>
<tr><td><code id="infDim_+3A_min.fixed.mass">min.fixed.mass</code></td>
<td>
<p>Minimum percentage of the total points that the 
algorithm shall use for the estimation.</p>
</td></tr>
<tr><td><code id="infDim_+3A_max.fixed.mass">max.fixed.mass</code></td>
<td>
<p>Maximum percentage of the total points that the 
algorithm shall use for the estimation.</p>
</td></tr>
<tr><td><code id="infDim_+3A_number.fixed.mass.points">number.fixed.mass.points</code></td>
<td>
<p>The number of different <em>fixed mass</em> 
fractions between <em>min.fixed.mass</em>
and <em>max.fixed.mass</em> that the algorithm will use for estimation.</p>
</td></tr>
<tr><td><code id="infDim_+3A_radius">radius</code></td>
<td>
<p>Initial radius for searching neighbour points in the phase 
space. Ideally, it should be small
enough so that the fixed mass contained in this radius is slightly greater 
than the <em>min.fixed.mass</em>. However, whereas the radius is not too 
large (so that the performance decreases) the choice is not critical.</p>
</td></tr>
<tr><td><code id="infDim_+3A_increasing.radius.factor">increasing.radius.factor</code></td>
<td>
<p>Numeric value. If no enough neighbours are 
found within <em>radius</em>, the radius is increased by a factor 
<em>increasing.radius.factor</em> until succesful. Default: sqrt(2) = 1.414214.</p>
</td></tr>
<tr><td><code id="infDim_+3A_number.boxes">number.boxes</code></td>
<td>
<p>Number of boxes that will be used in the box assisted 
algorithm (see <a href="#topic+neighbourSearch">neighbourSearch</a>).</p>
</td></tr>
<tr><td><code id="infDim_+3A_number.reference.vectors">number.reference.vectors</code></td>
<td>
<p>Number of reference points that the routine 
will try to use, saving computation time.</p>
</td></tr>
<tr><td><code id="infDim_+3A_theiler.window">theiler.window</code></td>
<td>
<p>Integer denoting the Theiler window:  Two Takens' 
vectors must be separated by more than theiler.window time steps in order to 
be considered neighbours. By using a Theiler window, we exclude temporally 
correlated vectors from our estimations.</p>
</td></tr>
<tr><td><code id="infDim_+3A_kmax">kMax</code></td>
<td>
<p>Maximum number of neighbours used for achieving p with all the 
points from the time series (see Details).</p>
</td></tr>
<tr><td><code id="infDim_+3A_do.plot">do.plot</code></td>
<td>
<p>Logical value. If TRUE (default value), a plot of the 
correlation sum is shown.</p>
</td></tr>
<tr><td><code id="infDim_+3A_...">...</code></td>
<td>
<p>Additional graphical parameters.</p>
</td></tr>
<tr><td><code id="infDim_+3A_x">x</code></td>
<td>
<p>A <em>infDim</em> object.</p>
</td></tr>
<tr><td><code id="infDim_+3A_regression.range">regression.range</code></td>
<td>
<p>Vector with 2 components denoting the range where 
the function will perform linear regression.</p>
</td></tr>
<tr><td><code id="infDim_+3A_use.embeddings">use.embeddings</code></td>
<td>
<p>A numeric vector specifying which embedding dimensions 
should be used to compute the information dimension.</p>
</td></tr>
<tr><td><code id="infDim_+3A_col">col</code></td>
<td>
<p>Vector of colors for each of the dimensions of the plot.</p>
</td></tr>
<tr><td><code id="infDim_+3A_pch">pch</code></td>
<td>
<p>Vector of symbols for each of the dimensions of the plot.</p>
</td></tr>
<tr><td><code id="infDim_+3A_fit.col">fit.col</code></td>
<td>
<p>A vector of colors to plot the regression lines.</p>
</td></tr>
<tr><td><code id="infDim_+3A_fit.lty">fit.lty</code></td>
<td>
<p>The type of line to plot the regression lines.</p>
</td></tr>
<tr><td><code id="infDim_+3A_fit.lwd">fit.lwd</code></td>
<td>
<p>The width of the line for the regression lines.</p>
</td></tr>
<tr><td><code id="infDim_+3A_add.legend">add.legend</code></td>
<td>
<p>add a legend to the plot?</p>
</td></tr>
<tr><td><code id="infDim_+3A_lty">lty</code></td>
<td>
<p>The line type of the &lt;log10(radius)&gt; functions.</p>
</td></tr>
<tr><td><code id="infDim_+3A_lwd">lwd</code></td>
<td>
<p>The line width of the &lt;log10(radius)&gt; functions.</p>
</td></tr>
<tr><td><code id="infDim_+3A_main">main</code></td>
<td>
<p>A title for the plot.</p>
</td></tr>
<tr><td><code id="infDim_+3A_xlab">xlab</code></td>
<td>
<p>A title for the x axis.</p>
</td></tr>
<tr><td><code id="infDim_+3A_ylab">ylab</code></td>
<td>
<p>A title for the y axis.</p>
</td></tr>
<tr><td><code id="infDim_+3A_type">type</code></td>
<td>
<p>Type of plot (see <code>?plot</code>).</p>
</td></tr>
<tr><td><code id="infDim_+3A_log">log</code></td>
<td>
<p>A character string which contains &quot;x&quot; if the x axis is to be 
logarithmic, &quot;y&quot; if the y axis is to be logarithmic and &quot;xy&quot; or &quot;yx&quot; if both
axes are to be logarithmic.</p>
</td></tr>
<tr><td><code id="infDim_+3A_ylim">ylim</code></td>
<td>
<p>Numeric vector of length 2, giving the y coordinates range.</p>
</td></tr>
<tr><td><code id="infDim_+3A_localscalingexp">localScalingExp</code></td>
<td>
<p>add a plot of the local information dimension 
scaling exponents?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The information dimension is a particular case of the generalized 
correlation dimension when setting the order q = 1. It is possible to 
demonstrate that the information dimension <code class="reqn">D_1</code> may be defined as:
<code class="reqn">D_1=lim_{r \rightarrow 0} &lt;\log p(r)&gt;/\log(r)</code>.
Here, <code class="reqn">p(r)</code> is the probability of finding a neighbour in a 
neighbourhood of size <code class="reqn">r</code> and &lt;&gt; is the mean value. Thus, the 
information dimension specifies how the average Shannon information scales 
with the radius <code class="reqn">r</code>. The user should compute the information dimension 
for different embedding dimensions for checking if <code class="reqn">D_1</code> saturates.
</p>
<p>In order to estimate <code class="reqn">D_1</code>, the algorithm looks for the scaling 
behaviour of the the average radius that contains a given portion 
(a &quot;fixed-mass&quot;) of the total points in the phase space. By performing
a linear regression of <code class="reqn">\log(p)\;Vs.\;\log(&lt;r&gt;)</code> (being
<code class="reqn">p</code> the fixed-mass of the total points), an estimate of <code class="reqn">D_1</code> is
obtained. 
</p>
<p>The algorithm also introduces a variation of <code class="reqn">p</code> for achieving a better 
performance: for small values of <code class="reqn">p</code>, all the points in the time 
series (<code class="reqn">N</code>) are considered for obtaining <code class="reqn">p=n/N</code>. Above a maximum 
number of neighbours <code class="reqn">kMax</code>, the algorithm obtains <code class="reqn">p</code> by decreasing 
the number of points considerd  from the time series  <code class="reqn">M&lt;N</code>. 
Thus <code class="reqn">p = kMax/M</code>.
</p>
<p>Even with these improvements, the calculations for the information 
dimension are heavier than those needed for the correlation dimension.
</p>


<h3>Value</h3>

<p>A <em>infDim</em> object that consist of a list with two components: 
<em>log.radius</em> and <em>fixed.mass</em>. <em>log.radius</em> contains
the average log10(radius) in which the <em>fixed.mass</em> can be found.
</p>
<p>The <em>fixedMass</em> function returns the fixed mass vector used
in the information dimension algorithm.
</p>
<p>The <em>logRadius</em> function returns the average log(radius) 
computed on the information dimension algorithm.
</p>
<p>The <em>embeddingDims</em> function returns the 
embeddings in which the information dimension was computed
</p>
<p>The 'estimate' function estimates the information dimension of the 
'infDim' object by by averaging the slopes of the
embedding dimensions specified in the <em>use.embeddings</em> parameter. The
slopes are determined  by performing a linear regression
over the fixed mass' range specified in 'regression.range'. If do.plot is 
TRUE, a graphic of the regression over the data is shown.
</p>
<p>The 'plot' function plots the computations performed for the 
information dimension estimate:  a graphic of &lt;log10(radius)&gt; Vs fixed mass.
Additionally, the inverse of the local scaling exponents can be plotted.
</p>
<p>The <em>plotLocalScalingExp</em> function plots the inverse of the 
local scaling exponentes of the information dimension 
(for reasons of numerical stability).
</p>


<h3>Author(s)</h3>

<p>Constantino A. Garcia
</p>


<h3>References</h3>

<p>H. Kantz  and T. Schreiber: Nonlinear Time series Analysis 
(Cambridge university press)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+corrDim">corrDim</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
x=henon(n.sample=  3000,n.transient= 100, a = 1.4, b = 0.3, 
        start =  c(0.8253681, 0.6955566), do.plot = FALSE)$x

leps = infDim(x,min.embedding.dim=2,max.embedding.dim = 5,
              time.lag=1, min.fixed.mass=0.04, max.fixed.mass=0.2,
              number.fixed.mass.points=100, radius =0.001, 
              increasing.radius.factor = sqrt(2), number.boxes=100, 
              number.reference.vectors=100, theiler.window = 10, 
              kMax = 100,do.plot=FALSE)

plot(leps,type="l")
colors2=c("#999999", "#E69F00", "#56B4E9", "#009E73", 
          "#F0E442", "#0072B2", "#D55E00")
id.estimation = estimate(leps,do.plot=TRUE,use.embeddings = 3:5,
                         fit.lwd=2,fit.col=1,
                         col=colors2)
cat("Henon---&gt; expected: 1.24    predicted: ", id.estimation ,"\n")

## End(Not run)
</code></pre>

<hr>
<h2 id='keenanTest'>Keenan's test</h2><span id='topic+keenanTest'></span>

<h3>Description</h3>

<p>Keenan's test: test for nonlinearity against the null hypothesis that the time
series follows some AR process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>keenanTest(time.series, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="keenanTest_+3A_time.series">time.series</code></td>
<td>
<p>The original time.series.</p>
</td></tr>
<tr><td><code id="keenanTest_+3A_...">...</code></td>
<td>
<p>Additional arguments for the <code><a href="stats.html#topic+ar">ar</a></code> function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the results of the test, including:
</p>

<ul>
<li><p> test.stat: the F-squared test statistic
</p>
</li>
<li><p> df1 and df2: the degrees of freedom of the test statistic.
</p>
</li>
<li><p> p.value.
</p>
</li>
<li><p> order: order of the AR process used for testing.
</p>
</li></ul>



<h3>References</h3>

<p>Keenan, D. M. (1985), A Tukey nonadditivity-type test for 
time series Nonlinearity, Biometrika, 72, 39-44.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+nonlinearityTest">nonlinearityTest</a></code>, <code><a href="#topic+tsayTest">tsayTest</a></code>, 
<code><a href="#topic+mcleodLiTest">mcleodLiTest</a></code>,<code><a href="#topic+thresholdTest">thresholdTest</a></code>
</p>

<hr>
<h2 id='logisticMap'>Logistic map</h2><span id='topic+logisticMap'></span>

<h3>Description</h3>

<p>Generates a time series using the logistic map.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>logisticMap(
  r = 4,
  start = runif(n = 1, min = 0, max = 1),
  n.sample = 5000,
  n.transient = 500,
  do.plot = deprecated()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="logisticMap_+3A_r">r</code></td>
<td>
<p>The <em>r</em> parameter. Default: 4</p>
</td></tr>
<tr><td><code id="logisticMap_+3A_start">start</code></td>
<td>
<p>A numeric value indicating the starting value for the time 
series. If the starting point is not specified, it is generated randomly.</p>
</td></tr>
<tr><td><code id="logisticMap_+3A_n.sample">n.sample</code></td>
<td>
<p>Length of the generated time series. Default: 5000 samples.</p>
</td></tr>
<tr><td><code id="logisticMap_+3A_n.transient">n.transient</code></td>
<td>
<p>Number of transient samples that will be discarded. 
Default: 500 samples.</p>
</td></tr>
<tr><td><code id="logisticMap_+3A_do.plot">do.plot</code></td>
<td>
<p>Logical value. If TRUE, a plot of the 
generated logistic system is shown. Before version 0.2.11, default value was
TRUE; versions 0.2.11 and later use FALSE as default.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The logistic map is defined as follows:
</p>
<p style="text-align: center;"><code class="reqn">x_n = r  \cdot  x_{n-1}   \cdot  (1 - x_{n-1})</code>
</p>

<p>The default selection for the <em>r</em> parameter is known to
produce a deterministic chaotic time series.
</p>


<h3>Value</h3>

<p>A vector containing the values of the time series that has been 
generated.
</p>


<h3>Note</h3>

<p>Some initial values may lead to an unstable system that will tend to 
infinity.
</p>


<h3>Author(s)</h3>

<p>Constantino A. Garcia
</p>


<h3>References</h3>

<p>Strogatz, S.: Nonlinear dynamics and chaos: with applications 
to physics, biology, chemistry and engineering (Studies in Nonlinearity)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+henon">henon</a>, <a href="#topic+lorenz">lorenz</a>, <a href="#topic+rossler">rossler</a>, <a href="#topic+ikedaMap">ikedaMap</a>, 
<a href="#topic+cliffordMap">cliffordMap</a>, <a href="#topic+sinaiMap">sinaiMap</a>, <a href="#topic+gaussMap">gaussMap</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
log.map=logisticMap(n.sample = 1000, n.transient=10,do.plot=TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='logRadius'>Obtain the the average log(radius) computed
on the information dimension algorithm.</h2><span id='topic+logRadius'></span>

<h3>Description</h3>

<p>Obtain the the average log(radius) computed
on the information dimension algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>logRadius(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="logRadius_+3A_x">x</code></td>
<td>
<p>A <em>infDim</em> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector representing the average log(radius) computed
on the information dimension algorithm represented by the <em>infDim</em> 
object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+infDim">infDim</a></code>
</p>

<hr>
<h2 id='lorenz'>Lorenz system</h2><span id='topic+lorenz'></span>

<h3>Description</h3>

<p>Generates a 3-dimensional time series using the Lorenz equations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lorenz(
  sigma = 10,
  beta = 8/3,
  rho = 28,
  start = c(-13, -14, 47),
  time = seq(0, 50, by = 0.01),
  do.plot = deprecated()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lorenz_+3A_sigma">sigma</code></td>
<td>
<p>The <code class="reqn">\sigma</code> parameter. Default: 10.</p>
</td></tr>
<tr><td><code id="lorenz_+3A_beta">beta</code></td>
<td>
<p>The <code class="reqn">\beta</code> parameter. Default: 8/3.</p>
</td></tr>
<tr><td><code id="lorenz_+3A_rho">rho</code></td>
<td>
<p>The <code class="reqn">\rho</code> parameter. Default: 28.</p>
</td></tr>
<tr><td><code id="lorenz_+3A_start">start</code></td>
<td>
<p>A 3-dimensional numeric vector indicating the starting point for the time series.
Default: c(-13, -14, 47).</p>
</td></tr>
<tr><td><code id="lorenz_+3A_time">time</code></td>
<td>
<p>The temporal interval at which the system will be generated. 
Default: time=seq(0,50,by = 0.01).</p>
</td></tr>
<tr><td><code id="lorenz_+3A_do.plot">do.plot</code></td>
<td>
<p>Logical value. If TRUE, a plot of the 
generated Lorenz system is shown. Before version 0.2.11, default value was
TRUE; versions 0.2.11 and later use FALSE as default.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Lorenz system is a system of ordinary differential equations defined as:
</p>
<p style="text-align: center;"><code class="reqn">\dot{x} = \sigma(y-x)</code>
</p>

<p style="text-align: center;"><code class="reqn">\dot{y} = \rho x-y-xz</code>
</p>

<p style="text-align: center;"><code class="reqn">\dot{z} = -\beta z + xy</code>
</p>

<p>The default selection for the system parameters (<code class="reqn">\sigma=10, \rho=28, \beta=8/3</code>) is known to
produce a deterministic chaotic time series.
</p>


<h3>Value</h3>

<p>A list with four vectors named <em>time</em>, <em>x</em>, <em>y</em> 
and <em>z</em> containing the time, the x-components, the 
y-components and the z-components of the Lorenz system, respectively.
</p>


<h3>Note</h3>

<p>Some initial values may lead to an unstable system that will tend to 
infinity.
</p>


<h3>Author(s)</h3>

<p>Constantino A. Garcia
</p>


<h3>References</h3>

<p>Strogatz, S.: Nonlinear dynamics and chaos: with applications 
to physics, biology, chemistry and engineering (Studies in Nonlinearity)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+henon">henon</a>, <a href="#topic+logisticMap">logisticMap</a>, <a href="#topic+rossler">rossler</a>, 
<a href="#topic+ikedaMap">ikedaMap</a>, <a href="#topic+cliffordMap">cliffordMap</a>, <a href="#topic+sinaiMap">sinaiMap</a>, <a href="#topic+gaussMap">gaussMap</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
lor=lorenz(time=seq(0,30,by = 0.01))
# plotting the x-component 
plot(lor$time,lor$x,type="l")

## End(Not run)
</code></pre>

<hr>
<h2 id='maxLyapunov'>Maximum lyapunov exponent</h2><span id='topic+maxLyapunov'></span><span id='topic+divTime.maxLyapunov'></span><span id='topic+embeddingDims.maxLyapunov'></span><span id='topic+divergence.maxLyapunov'></span><span id='topic+plot.maxLyapunov'></span><span id='topic+estimate.maxLyapunov'></span>

<h3>Description</h3>

<p>Functions for estimating the maximal Lyapunov exponent of a dynamical system
from 1-dimensional time series using Takens' vectors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>maxLyapunov(
  time.series,
  min.embedding.dim = 2,
  max.embedding.dim = min.embedding.dim,
  time.lag = 1,
  radius,
  theiler.window = 1,
  min.neighs = 5,
  min.ref.points = 500,
  max.time.steps = 10,
  number.boxes = NULL,
  sampling.period = 1,
  do.plot = TRUE,
  ...
)

## S3 method for class 'maxLyapunov'
divTime(x)

## S3 method for class 'maxLyapunov'
embeddingDims(x)

## S3 method for class 'maxLyapunov'
divergence(x)

## S3 method for class 'maxLyapunov'
plot(
  x,
  main = "Estimating maximal Lyapunov exponent",
  xlab = "time t",
  ylab = "S(t)",
  type = "p",
  col = NULL,
  pch = NULL,
  add.legend = T,
  ...
)

## S3 method for class 'maxLyapunov'
estimate(
  x,
  regression.range = NULL,
  do.plot = FALSE,
  use.embeddings = NULL,
  main = "Estimating maximal Lyapunov exponent",
  xlab = "time t",
  ylab = "S(t)",
  type = "p",
  col = NULL,
  pch = NULL,
  ylim = NULL,
  fit.col = NULL,
  fit.lty = 2,
  fit.lwd = 2,
  add.legend = T,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="maxLyapunov_+3A_time.series">time.series</code></td>
<td>
<p>The original time series from which the maximal Lyapunov 
exponent will be estimated.</p>
</td></tr>
<tr><td><code id="maxLyapunov_+3A_min.embedding.dim">min.embedding.dim</code></td>
<td>
<p>Integer denoting the minimum dimension in which we 
shall embed the time.series (see <a href="#topic+buildTakens">buildTakens</a>).</p>
</td></tr>
<tr><td><code id="maxLyapunov_+3A_max.embedding.dim">max.embedding.dim</code></td>
<td>
<p>Integer denoting the maximum dimension in which we 
shall embed the time.series (see <a href="#topic+buildTakens">buildTakens</a>).Thus,
we shall estimate the Lyapunov exponent between <em>min.embedding.dim</em> 
and <em>max.embedding.dim</em>.</p>
</td></tr>
<tr><td><code id="maxLyapunov_+3A_time.lag">time.lag</code></td>
<td>
<p>Integer denoting the number of time steps that will be use 
to construct the Takens' vectors (see <a href="#topic+buildTakens">buildTakens</a>).</p>
</td></tr>
<tr><td><code id="maxLyapunov_+3A_radius">radius</code></td>
<td>
<p>Maximum distance in which will look for nearby trajectories.</p>
</td></tr>
<tr><td><code id="maxLyapunov_+3A_theiler.window">theiler.window</code></td>
<td>
<p>Integer denoting the Theiler window:  Two Takens' 
vectors must be separated by more than <em>theiler.window</em> time steps in 
order to be considered neighbours. By using a Theiler window, we exclude 
temporally correlated vectors from our estimations.</p>
</td></tr>
<tr><td><code id="maxLyapunov_+3A_min.neighs">min.neighs</code></td>
<td>
<p>Minimum number of neighbours that a Takens' vector must 
have to be considered a reference point.</p>
</td></tr>
<tr><td><code id="maxLyapunov_+3A_min.ref.points">min.ref.points</code></td>
<td>
<p>Number of reference points that the routine will try 
to use. The routine stops when it finds <em>min.ref.points</em> reference 
points, saving computation time.</p>
</td></tr>
<tr><td><code id="maxLyapunov_+3A_max.time.steps">max.time.steps</code></td>
<td>
<p>Integer denoting the number of time steps marking the 
end of the linear region.</p>
</td></tr>
<tr><td><code id="maxLyapunov_+3A_number.boxes">number.boxes</code></td>
<td>
<p>Number of boxes that will be used in the box assisted 
algorithm (see <a href="#topic+neighbourSearch">neighbourSearch</a>).</p>
</td></tr>
<tr><td><code id="maxLyapunov_+3A_sampling.period">sampling.period</code></td>
<td>
<p>Sampling period of the time series. When dealing 
with a discrete system, the <em>sampling.period</em> should be set to 1.</p>
</td></tr>
<tr><td><code id="maxLyapunov_+3A_do.plot">do.plot</code></td>
<td>
<p>Logical value. If TRUE (default value), a plot of <code class="reqn">S(t)</code> 
Vs  <code class="reqn">t</code> is shown.</p>
</td></tr>
<tr><td><code id="maxLyapunov_+3A_...">...</code></td>
<td>
<p>Additional plotting parameters.</p>
</td></tr>
<tr><td><code id="maxLyapunov_+3A_x">x</code></td>
<td>
<p>A <em>maxLyapunov</em> object.</p>
</td></tr>
<tr><td><code id="maxLyapunov_+3A_main">main</code></td>
<td>
<p>A title for the plot.</p>
</td></tr>
<tr><td><code id="maxLyapunov_+3A_xlab">xlab</code></td>
<td>
<p>A title for the x axis.</p>
</td></tr>
<tr><td><code id="maxLyapunov_+3A_ylab">ylab</code></td>
<td>
<p>A title for the y axis.</p>
</td></tr>
<tr><td><code id="maxLyapunov_+3A_type">type</code></td>
<td>
<p>Type of plot (see <code>?plot</code>).</p>
</td></tr>
<tr><td><code id="maxLyapunov_+3A_col">col</code></td>
<td>
<p>Vector of colors for each of the dimensions of the plot.</p>
</td></tr>
<tr><td><code id="maxLyapunov_+3A_pch">pch</code></td>
<td>
<p>Vector of symbols for each of the dimensions of the plot.</p>
</td></tr>
<tr><td><code id="maxLyapunov_+3A_add.legend">add.legend</code></td>
<td>
<p>add a legend to the plot?</p>
</td></tr>
<tr><td><code id="maxLyapunov_+3A_regression.range">regression.range</code></td>
<td>
<p>Vector with 2 components denoting the range where 
the function will perform linear regression.</p>
</td></tr>
<tr><td><code id="maxLyapunov_+3A_use.embeddings">use.embeddings</code></td>
<td>
<p>A numeric vector specifying which embedding dimensions 
should the <em>estimate</em> function use to compute the Lyapunov exponent.</p>
</td></tr>
<tr><td><code id="maxLyapunov_+3A_ylim">ylim</code></td>
<td>
<p>Numeric vector of length 2, giving the y coordinates range.</p>
</td></tr>
<tr><td><code id="maxLyapunov_+3A_fit.col">fit.col</code></td>
<td>
<p>A vector of colors to plot the regression lines.</p>
</td></tr>
<tr><td><code id="maxLyapunov_+3A_fit.lty">fit.lty</code></td>
<td>
<p>The type of line to plot the regression lines.</p>
</td></tr>
<tr><td><code id="maxLyapunov_+3A_fit.lwd">fit.lwd</code></td>
<td>
<p>The width of the line for the regression lines.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It is a well-known fact that close trajectories diverge 
exponentially fast in a chaotic system. The averaged exponent that determines 
the divergence rate is called the Lyapunov exponent (usually denoted with 
<code class="reqn">\lambda</code>). If <code class="reqn">\delta(0)</code> is the distance between 
two Takens' vectors in the embedding.dim-dimensional space, we expect that 
the distance after a time <code class="reqn">t</code> between the two trajectories arising 
from this two vectors fulfills:
</p>
<p style="text-align: center;"><code class="reqn">\delta (n) \sim \delta (0)\cdot exp(\lambda \cdot t)</code>
</p>

<p>The lyapunov exponent is estimated using the slope obtained by performing a 
linear regression of 
<code class="reqn">S(t)=\lambda \cdot t \sim log(\delta (t)/\delta (0))</code> 
on <code class="reqn">t</code>. <code class="reqn">S(t)</code> will be estimated by averaging the divergence of 
several reference points.
</p>
<p>The user should plot <code class="reqn">S(t) Vs t</code> when looking for the maximal lyapunov 
exponent and, if for some temporal range <code class="reqn">S(t)</code> shows a linear 
behaviour, its slope is an estimate of the maximal Lyapunov exponent per 
unit of time. The estimate routine allows the user to get always an 
estimate of the maximal Lyapunov exponent, but the user must check that 
there is a linear region in the <code class="reqn">S(t) Vs t</code>. If such a region does 
not exist, the estimation should be discarded. The computations should be 
performed for several embedding dimensions in order to check that the 
Lyapunov exponent does not depend on the embedding dimension.
</p>


<h3>Value</h3>

<p>A list with three components named  <code class="reqn">time</code> and <code class="reqn">s.function</code>.
<code class="reqn">time</code> is a vector containing the temporal interval where the system 
evolves. It ranges from 0 to 
<em><code class="reqn">max.time.steps \cdot sampling.period</code></em>.
<code class="reqn">s.function</code> is a matrix containing the 
values of the <code class="reqn">S(t)</code> for each t in the time vector(the columns) and each 
embedding dimension (the rows).
</p>
<p>The <em>divTime</em> function returns the 
time in which the divergence of close trajectories was computed.
</p>
<p>The <em>embeddingDims</em> function returns the 
embeddings in which the divergence of close trajectories was computed
</p>
<p>The <em>divergence</em> function returns the 
rate of divergence of close trajectories needed for the maximum Lyapunov
exponent estimation.
</p>
<p>In order to obtain an estimation of the Lyapunov exponent the user 
can use the <em>estimate</em> function. The  <code class="reqn">estimate</code> function allows 
the user to obtain an estimation of the maximal Lyapunov exponent by 
averaging the slopes of the embedding dimensions specified in the 
<em>use.embeddings</em> parameter. The slopes are determined by performing a 
linear regression over the radius' range specified in <em>regression.range</em>
</p>


<h3>Author(s)</h3>

<p>Constantino A. Garcia
</p>


<h3>References</h3>

<p>Eckmann, Jean-Pierre and Kamphorst, S Oliffson and Ruelle, David and 
Ciliberto, S and others. Liapunov exponents from time series.
Physical Review A, 34-6, 4971&ndash;4979, (1986).
</p>
<p>Rosenstein, Michael T and Collins, James J and De Luca, Carlo J.A practical 
method for calculating largest Lyapunov exponents from small data sets.
Physica D: Nonlinear Phenomena, 65-1, 117&ndash;134, (1993).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## Henon System
h=henon(n.sample=  5000,n.transient= 100, a = 1.4, b = 0.3, 
        start = c(0.63954883, 0.04772637), do.plot = FALSE) 
my.ts=h$x 
ml=maxLyapunov(time.series=my.ts,
               min.embedding.dim=2,
               max.embedding.dim=5,
               time.lag=1,
               radius=0.001,theiler.window=4,
               min.neighs=2,min.ref.points=500,
               max.time.steps=40,do.plot=FALSE)
plot(ml)
ml.estimation = estimate(ml,regression.range = c(0,15),
                         use.embeddings=4:5,
                         do.plot = TRUE)
# The max Lyapunov exponent of the Henon system is 0.41
cat("expected: ",0.41," calculated: ",ml.estimation,"\n")

## Rossler system
r=rossler(a=0.15,b=0.2,w=10,start=c(0,0,0), time=seq(0,1000,0.1), 
          do.plot=FALSE)
my.ts=r$x
use.cols = c("#999999","#E69F00","#56B4E9")
ml=maxLyapunov(time.series=my.ts,min.embedding.dim=5,max.embedding.dim = 7,
               time.lag=12,radius=0.1,theiler.window=50,
               min.neighs=5,min.ref.points=length(r),
               max.time.steps=300,number.boxes=NULL,
               sampling.period=0.1,do.plot=TRUE,
               col=use.cols)
#  The max Lyapunov exponent of the Rossler system is 0.09
ml.est=estimate(ml,col=use.cols,do.plot=T,
                fit.lty=1,
                fit.lwd=5)
cat("expected: ",0.090," calculated: ",ml.est,"\n")

## End(Not run)
</code></pre>

<hr>
<h2 id='mcleodLiTest'>McLeod-Li test</h2><span id='topic+mcleodLiTest'></span>

<h3>Description</h3>

<p>McLeod-Li test for conditional heteroscedascity (ARCH).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mcleodLiTest(time.series, lag.max)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mcleodLiTest_+3A_time.series">time.series</code></td>
<td>
<p>The original time.series.</p>
</td></tr>
<tr><td><code id="mcleodLiTest_+3A_lag.max">lag.max</code></td>
<td>
<p>Maximum number of lags for which to test for 
conditional heteroscedascity.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the <em>p.values</em> for each of the 
Ljung-Box tests computed using lags ranging from 1 to <em>lag.max</em>.
</p>


<h3>References</h3>

<p>Tsay, Ruey S., and Rong Chen. Nonlinear time series analysis. 
Vol. 891. John Wiley &amp; Sons, 2018.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+nonlinearityTest">nonlinearityTest</a></code>, <code><a href="#topic+keenanTest">keenanTest</a></code>,
<code><a href="#topic+tsayTest">tsayTest</a></code>, <code><a href="#topic+thresholdTest">thresholdTest</a></code>
</p>

<hr>
<h2 id='mutualInformation'>Average Mutual Information (AMI)</h2><span id='topic+mutualInformation'></span><span id='topic+plot.mutualInf'></span><span id='topic+as.numeric.mutualInf'></span><span id='topic++5B.mutualInf'></span><span id='topic++5B+5B.mutualInf'></span>

<h3>Description</h3>

<p>Functions for estimating the Average Mutual Information (AMI) of a time
series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mutualInformation(
  time.series,
  lag.max = NULL,
  n.partitions = NULL,
  units = c("Nats", "Bits", "Bans"),
  do.plot = TRUE,
  ...
)

## S3 method for class 'mutualInf'
plot(
  x,
  main = "Average Mutual Information (AMI)",
  xlab = "Time lag",
  ylab = NULL,
  type = "h",
  ...
)

## S3 method for class 'mutualInf'
as.numeric(x, ...)

## S3 method for class 'mutualInf'
x[i]

## S3 method for class 'mutualInf'
x[[i]]
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mutualInformation_+3A_time.series">time.series</code></td>
<td>
<p>The observed time series.</p>
</td></tr>
<tr><td><code id="mutualInformation_+3A_lag.max">lag.max</code></td>
<td>
<p>Largest lag at which to calculate the AMI.</p>
</td></tr>
<tr><td><code id="mutualInformation_+3A_n.partitions">n.partitions</code></td>
<td>
<p>Number of bins used to compute the probability 
distribution of the time series.</p>
</td></tr>
<tr><td><code id="mutualInformation_+3A_units">units</code></td>
<td>
<p>The units for the mutual information. Allowed units are
&quot;Nats&quot;, &quot;Bits&quot; or &quot;Bans&quot; (somethings called Hartleys). Default is &quot;Nats&quot;.</p>
</td></tr>
<tr><td><code id="mutualInformation_+3A_do.plot">do.plot</code></td>
<td>
<p>Logical value. If TRUE, the AMI is plotted</p>
</td></tr>
<tr><td><code id="mutualInformation_+3A_...">...</code></td>
<td>
<p>Further arguments for the plotting function.</p>
</td></tr>
<tr><td><code id="mutualInformation_+3A_x">x</code></td>
<td>
<p>A <em>mutualInf</em> object.</p>
</td></tr>
<tr><td><code id="mutualInformation_+3A_main">main</code></td>
<td>
<p>Title for the plot.</p>
</td></tr>
<tr><td><code id="mutualInformation_+3A_xlab">xlab</code></td>
<td>
<p>Title for the x axis.</p>
</td></tr>
<tr><td><code id="mutualInformation_+3A_ylab">ylab</code></td>
<td>
<p>Title for the y axis.</p>
</td></tr>
<tr><td><code id="mutualInformation_+3A_type">type</code></td>
<td>
<p>Type of plot to be drawn.</p>
</td></tr>
<tr><td><code id="mutualInformation_+3A_i">i</code></td>
<td>
<p>Indices specifying elements to extract.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Average Mutual Information (AMI) measures how much one random variable
tells us about another. In the context of time series analysis, AMI
helps to quantify the amount of knowledge gained about the value
of <code class="reqn">x(t+\tau)</code> when observing <code class="reqn">x(t)</code>.
</p>
<p>To measure the AMI iof a time series, we create a histogram of the data
using bins. Let <code class="reqn">p_i</code> the probability that the signal has a 
value inside the ith bin, and let  <code class="reqn">p_{ij}(\tau)</code> be
the probability that <code class="reqn">x(t)</code> is in bin i ans <code class="reqn">x(t+\tau)</code>
is in bin j. Then, AMI for time delay <code class="reqn">\tau</code> is defined as
</p>
<p style="text-align: center;"><code class="reqn">AMI(\tau) = \sum_{i,j} p_{ij} log(\frac{p_{ij}}{p_i p_j})</code>
</p>

<p>Depending on the base of the logarithm used to define AMI, the AMI
is measured in bits (base 2, also called shannons), nats (base e) or
bans (base 10, also called hartleys).
</p>


<h3>Value</h3>

<p>A <em>mutualInf</em> object that consist of a list containing all 
the relevant information of the AMI computation: 
<em>time.lag</em>, <em>mutual.information</em>, <em>units</em> and 
<em>n.partitions</em>.
</p>


<h3>Author(s)</h3>

<p>Constantino A. Garcia
</p>


<h3>References</h3>

<p>H. Kantz  and T. Schreiber: Nonlinear Time series Analysis 
(Cambridge university press)
H. Abarbanel: Analysis of observed chaotic data (Springer, 1996).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+timeLag">timeLag</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
sx = sinaiMap(a=0.3,n.sample=5000,start=c(0.23489,0.8923),do.plot=FALSE)$x
mutinf = mutualInformation(sx, n.partitions = 20, units = "Bits") 
## End(Not run)
</code></pre>

<hr>
<h2 id='neighbourSearch'>neighbour search</h2><span id='topic+neighbourSearch'></span>

<h3>Description</h3>

<p>This function finds all the neighbours of a given Takens' vector. The 
neighbours are found using a box assisted algorithm that creates a wrapped 
grid with a given number of  boxes per dimension.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>neighbourSearch(takens, positionTakens, radius, number.boxes = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="neighbourSearch_+3A_takens">takens</code></td>
<td>
<p>The matrix containing all the Takens' vectors (see 
<a href="#topic+buildTakens">buildTakens</a>).</p>
</td></tr>
<tr><td><code id="neighbourSearch_+3A_positiontakens">positionTakens</code></td>
<td>
<p>Integer denoting the Takens' vector whose neighbours 
will be searched.</p>
</td></tr>
<tr><td><code id="neighbourSearch_+3A_radius">radius</code></td>
<td>
<p>Distance in which the algorithm will search for neighbours.</p>
</td></tr>
<tr><td><code id="neighbourSearch_+3A_number.boxes">number.boxes</code></td>
<td>
<p>Integer denoting the number of boxes per dimension that 
will be used to construct a wrapped grid (see Schreiber). If the user does 
not specify a number of boxes, this function estimates a proper number.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A containing all the neighbours of the 
<em>positionTakens-th</em> Takens' vector. If the list is empty, that means 
that there is no neighbour of the <em>positionTakens-th</em> Takens' vector 
in the given radius.
</p>


<h3>Author(s)</h3>

<p>Constantino A. Garcia
</p>


<h3>References</h3>

<p>Schreiber, T. Efficient neighbor searching in nonlinear time 
series analysis. Int. J. Bifurcation and Chaos, 5, p. 349, (1995).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+findAllNeighbours">findAllNeighbours</a></code>.
</p>

<hr>
<h2 id='nlOrder'>Get the order of the nonlinear chaotic invariant.</h2><span id='topic+nlOrder'></span>

<h3>Description</h3>

<p>Get the order of the nonlinear chaotic invariant.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nlOrder(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nlOrder_+3A_x">x</code></td>
<td>
<p>An object containing all the information needed for the estimate of 
the chaotic invariant.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector with the radius of the neighborhoods used for the 
computations of a chaotic invariant.
</p>


<h3>Author(s)</h3>

<p>Constantino A. Garcia
</p>


<h3>References</h3>

<p>H. Kantz  and T. Schreiber: Nonlinear Time series Analysis 
(Cambridge university press)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+corrDim">corrDim</a></code>, <code><a href="#topic+sampleEntropy">sampleEntropy</a></code>
</p>

<hr>
<h2 id='nonlinearityTest'>Nonlinearity test</h2><span id='topic+nonlinearityTest'></span>

<h3>Description</h3>

<p>Nonlinearity test
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nonlinearityTest(time.series, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nonlinearityTest_+3A_time.series">time.series</code></td>
<td>
<p>The original time.series from which the surrogate data is generated.</p>
</td></tr>
<tr><td><code id="nonlinearityTest_+3A_verbose">verbose</code></td>
<td>
<p>Logical value. If TRUE, a summary of each of the tests is shown.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function runs a set of nonlinearity tests implemented by this and other 
R packages, including:
</p>

<ul>
<li><p> Teraesvirta's neural metwork test for nonlinearity (<code><a href="tseries.html#topic+terasvirta.test">terasvirta.test</a></code>).
</p>
</li>
<li><p> White neural metwork test for nonlinearity (<code><a href="tseries.html#topic+white.test">white.test</a></code>).
</p>
</li>
<li><p> Keenan's one-degree test for nonlinearity (<code><a href="#topic+keenanTest">keenanTest</a></code>).
</p>
</li>
<li><p> Perform the McLeod-Li test for conditional heteroscedascity (ARCH). (<code><a href="#topic+mcleodLiTest">mcleodLiTest</a></code>).
</p>
</li>
<li><p> Perform the Tsay's test for quadratic nonlinearity in a time series. (<code><a href="#topic+tsayTest">tsayTest</a></code>).
</p>
</li>
<li><p> Perform the Likelihood ratio test for threshold nonlinearity. (<code><a href="#topic+thresholdTest">thresholdTest</a></code>).
</p>
</li></ul>



<h3>Value</h3>

<p>A list containing the results of each of the tests.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+keenanTest">keenanTest</a></code>, <code><a href="#topic+tsayTest">tsayTest</a></code>, 
<code><a href="#topic+mcleodLiTest">mcleodLiTest</a></code>,<code><a href="#topic+thresholdTest">thresholdTest</a></code>
</p>

<hr>
<h2 id='nonLinearNoiseReduction'>Nonlinear noise reduction</h2><span id='topic+nonLinearNoiseReduction'></span>

<h3>Description</h3>

<p>Function for denoising a given time series using nonlinear analysis 
techniques.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nonLinearNoiseReduction(time.series, embedding.dim, radius)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nonLinearNoiseReduction_+3A_time.series">time.series</code></td>
<td>
<p>The original time series to denoise.</p>
</td></tr>
<tr><td><code id="nonLinearNoiseReduction_+3A_embedding.dim">embedding.dim</code></td>
<td>
<p>Integer denoting the dimension in which we shall embed 
the <em>time.series</em>.</p>
</td></tr>
<tr><td><code id="nonLinearNoiseReduction_+3A_radius">radius</code></td>
<td>
<p>The radius used to looking for neighbours in the phase space 
(see details).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function takes a given time series and denoises it. The denoising
is achieved by averaging each Takens' vector in an m-dimensional space
with his neighbours (time lag=1). Each neighbourhood is specified with balls 
of a given radius
(max norm is used).
</p>


<h3>Value</h3>

<p>A vector containing the denoised time series.
</p>


<h3>Author(s)</h3>

<p>Constantino A. Garcia
</p>


<h3>References</h3>

<p>H. Kantz  and T. Schreiber: Nonlinear Time series Analysis 
(Cambridge university press)
</p>

<hr>
<h2 id='nonLinearPrediction'>Nonlinear time series prediction</h2><span id='topic+nonLinearPrediction'></span>

<h3>Description</h3>

<p>Function for predicting futures values of a given time series using previous 
values and  nonlinear analysis techniques.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nonLinearPrediction(
  time.series,
  embedding.dim,
  time.lag,
  prediction.step,
  radius,
  radius.increment
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nonLinearPrediction_+3A_time.series">time.series</code></td>
<td>
<p>Previous values of the time series that the algorithm 
will use to make the prediction.</p>
</td></tr>
<tr><td><code id="nonLinearPrediction_+3A_embedding.dim">embedding.dim</code></td>
<td>
<p>Integer denoting the dimension in which we shall embed 
the <em>time.series</em>.</p>
</td></tr>
<tr><td><code id="nonLinearPrediction_+3A_time.lag">time.lag</code></td>
<td>
<p>Integer denoting the number of time steps that will be use 
to construct the  Takens' vectors.</p>
</td></tr>
<tr><td><code id="nonLinearPrediction_+3A_prediction.step">prediction.step</code></td>
<td>
<p>Integer denoting the number of time steps ahead for 
the forecasting.</p>
</td></tr>
<tr><td><code id="nonLinearPrediction_+3A_radius">radius</code></td>
<td>
<p>The radius used to looking for neighbours in the phase space 
(see details).</p>
</td></tr>
<tr><td><code id="nonLinearPrediction_+3A_radius.increment">radius.increment</code></td>
<td>
<p>The increment used when no neighbours are found 
(see details).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Using <em>time.series</em> measurements, an embedding in 
<em>embedding.dim</em>-dimensional phase space with time lag <em>time.lag</em> 
is used to predict the value following the given time series after 
<em>prediction.steps</em> sample steps. This is done by finding all the 
neighbours of the last Takens' vector in a  radius of size <em>radius</em>  
(the max norm is used). If no neighbours are found within a distance radius, 
the neighbourhood size is increased until succesful using 
<em>radius.increment</em>(<em>radius</em> = <em>radius</em> + 
<em>radius.increment</em>).
</p>


<h3>Value</h3>

<p>The predicted value <em>prediction.step</em> time steps ahead.
</p>


<h3>Author(s)</h3>

<p>Constantino A. Garcia
</p>


<h3>References</h3>

<p>H. Kantz  and T. Schreiber: Nonlinear Time series Analysis 
(Cambridge university press)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
h=henon(n.sample=5000,start=c(0.324,-0.8233))
predic=nonLinearPrediction(time.series=h$x[10:2000],embedding.dim=2,
                           time.lag=1,
                           prediction.step=3,radius=0.03,
                           radius.increment=0.03/2)
cat("real value: ",h$x[2003],"Vs Forecast:",predic)

## End(Not run)
</code></pre>

<hr>
<h2 id='plotLocalScalingExp'>Plot local scaling exponents</h2><span id='topic+plotLocalScalingExp'></span>

<h3>Description</h3>

<p>Plots the local scaling exponents of the correlation sum or 
the average Shannon  information (when computing information dimension).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotLocalScalingExp(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plotLocalScalingExp_+3A_x">x</code></td>
<td>
<p>An object containing all the information needed for the estimate of
the chaotic invariant.</p>
</td></tr>
<tr><td><code id="plotLocalScalingExp_+3A_...">...</code></td>
<td>
<p>Additional graphical parameters.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Constantino A. Garcia
</p>


<h3>References</h3>

<p>H. Kantz  and T. Schreiber: Nonlinear Time series Analysis 
(Cambridge university press)
</p>

<hr>
<h2 id='poincareMap'>Poincare map</h2><span id='topic+poincareMap'></span>

<h3>Description</h3>

<p>Computes the Poincare map of the reconstructed trajectories in the 
phase-space.
</p>
<p>The Poincare map is a classical dynamical system technique that replaces the 
n-th dimensional trajectory in the phase space with an (n-1)-th order 
discrete-time called the Poincare map. The points of the Poincare map are 
the intersection of the trajectories in the phase-space with a certain 
Hyper-plane.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>poincareMap(
  time.series = NULL,
  embedding.dim = 2,
  time.lag = 1,
  takens = NULL,
  normal.hiperplane.vector = NULL,
  hiperplane.point
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="poincareMap_+3A_time.series">time.series</code></td>
<td>
<p>The original time series from which the phase-space 
reconstruction is done.</p>
</td></tr>
<tr><td><code id="poincareMap_+3A_embedding.dim">embedding.dim</code></td>
<td>
<p>Integer denoting the dimension in which we shall 
embed the <em>time.series</em>.</p>
</td></tr>
<tr><td><code id="poincareMap_+3A_time.lag">time.lag</code></td>
<td>
<p>Integer denoting the number of time steps that will be 
use to construct the  Takens' vectors.</p>
</td></tr>
<tr><td><code id="poincareMap_+3A_takens">takens</code></td>
<td>
<p>Instead of specifying the <em>time.series</em>, the 
<em>embedding.dim</em> and the <em>time.lag</em>, the user
may specify directly the Takens' vectors.</p>
</td></tr>
<tr><td><code id="poincareMap_+3A_normal.hiperplane.vector">normal.hiperplane.vector</code></td>
<td>
<p>The normal vector of the hyperplane that 
will be used to compute the Poincare map. If the vector is not specifyed 
the program choses the vector (0,0,...,1).</p>
</td></tr>
<tr><td><code id="poincareMap_+3A_hiperplane.point">hiperplane.point</code></td>
<td>
<p>A point on the hyperplane (an hyperplane is 
defined with a point and a normal vector).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function computes the Poincare map taking the Takens' vectors as the 
continuous trajectory in the phase space. The  <em>takens</em> param has been 
included so that the user may specify the real phase-space instead of using 
the phase-space reconstruction (see examples).
</p>


<h3>Value</h3>

<p>Since there are three different Poincare maps, an R list is returned 
storing all the information related which all of these maps:
</p>

<ul>
<li><p> The positive Poincare map is formed by all the intersections with
the hyperplane in positive direction (defined by the normal vector). The 
<em>pm.pos</em> returns the points of the map whereas that 
<em>pm.pos.time</em> returns the number of time steps since the beginning
where the intersections occurred. Note that these time steps probably 
won't be integers since the algorithm uses an interpolation procedure 
for calculating the intersection with the hyperplane.
</p>
</li>
<li><p> Similarly we define a negative Poincare map (<em>pm.neg</em> and 
<em>pm.neg.time</em>).
</p>
</li>
<li><p>  Finally, we may define a two-side Poincare map that stores all the
intersections (no matter the direction of the intersection) (<em>pm</em>
and <em>pm.time</em>).
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Constantino A. Garcia
</p>


<h3>References</h3>

<p>Parker, T. S., L. O. Chua, and T. S. Parker (1989). Practical
numerical algorithms for chaotic systems. Springer New York
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
r=rossler(a = 0.2, b = 0.2, w = 5.7, start=c(-2, -10, 0.2),
time=seq(0,300,by = 0.01), do.plot=FALSE)
takens=cbind(r$x,r$y,r$z)
# calculate poincare sections
pm=poincareMap(takens = takens,normal.hiperplane.vector = c(0,1,0), 
 hiperplane.point=c(0,0,0) )
if (requireNamespace("rgl", quietly = TRUE)) {
   rgl::plot3d(takens,size=0.7)
   rgl::points3d(pm$pm,col="red")
}

## End(Not run)
</code></pre>

<hr>
<h2 id='radius'>Get the radius of the neighborhoods used for the  computations of 
a chaotic invariant.</h2><span id='topic+radius'></span>

<h3>Description</h3>

<p>Get the radius of the neighborhoods used for the  computations of 
a chaotic invariant.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>radius(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="radius_+3A_x">x</code></td>
<td>
<p>An object containing all the information needed for the estimate of
the chaotic invariant.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector with the radius of the neighborhoods used for the 
computations of a chaotic invariant.
</p>


<h3>Author(s)</h3>

<p>Constantino A. Garcia
</p>


<h3>References</h3>

<p>H. Kantz  and T. Schreiber: Nonlinear Time series Analysis 
(Cambridge university press)
</p>

<hr>
<h2 id='recurrencePlot'>Recurrence Plot</h2><span id='topic+recurrencePlot'></span>

<h3>Description</h3>

<p>Plot the recurrence matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>recurrencePlot(
  takens = NULL,
  time.series,
  embedding.dim,
  time.lag,
  radius,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="recurrencePlot_+3A_takens">takens</code></td>
<td>
<p>Instead of specifying the <em>time.series</em>, the 
<em>embedding.dim</em> and the <em>time.lag</em>, the user may specify directly 
the Takens' vectors.</p>
</td></tr>
<tr><td><code id="recurrencePlot_+3A_time.series">time.series</code></td>
<td>
<p>The original time series from which the phase-space 
reconstruction is performed.</p>
</td></tr>
<tr><td><code id="recurrencePlot_+3A_embedding.dim">embedding.dim</code></td>
<td>
<p>Integer denoting the dimension in which we shall embed 
the <em>time.series</em>.</p>
</td></tr>
<tr><td><code id="recurrencePlot_+3A_time.lag">time.lag</code></td>
<td>
<p>Integer denoting the number of time steps that will be use 
to construct the  Takens' vectors.</p>
</td></tr>
<tr><td><code id="recurrencePlot_+3A_radius">radius</code></td>
<td>
<p>Maximum distance between two phase-space points to be 
considered a recurrence.</p>
</td></tr>
<tr><td><code id="recurrencePlot_+3A_...">...</code></td>
<td>
<p>Additional plotting parameters.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>WARNING: This function is computationally very expensive. Use with caution.
</p>


<h3>Author(s)</h3>

<p>Constantino A. Garcia
</p>


<h3>References</h3>

<p>Zbilut, J. P. and C. L. Webber. Recurrence quantification 
analysis. Wiley Encyclopedia of Biomedical Engineering  (2006).
</p>

<hr>
<h2 id='rossler'>Rossler system</h2><span id='topic+rossler'></span>

<h3>Description</h3>

<p>Generates a 3-dimensional time series using the Rossler equations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rossler(
  a = 0.2,
  b = 0.2,
  w = 5.7,
  start = c(-2, -10, 0.2),
  time = seq(0, 50, by = 0.01),
  do.plot = deprecated()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rossler_+3A_a">a</code></td>
<td>
<p>The <em>a</em> parameter. Default:0.2.</p>
</td></tr>
<tr><td><code id="rossler_+3A_b">b</code></td>
<td>
<p>The <em>b</em> parameter. Default: 0.2.</p>
</td></tr>
<tr><td><code id="rossler_+3A_w">w</code></td>
<td>
<p>The <em>w</em> parameter. Default: 5.7.</p>
</td></tr>
<tr><td><code id="rossler_+3A_start">start</code></td>
<td>
<p>A 3-dimensional numeric vector indicating the starting point for the time series.
Default: c(-2, -10, 0.2).</p>
</td></tr>
<tr><td><code id="rossler_+3A_time">time</code></td>
<td>
<p>The temporal interval at which the system will be generated. 
Default: time=seq(0,50,by = 0.01).</p>
</td></tr>
<tr><td><code id="rossler_+3A_do.plot">do.plot</code></td>
<td>
<p>Logical value. If TRUE, a plot of the 
generated Lorenz system is shown. Before version 0.2.11, default value was
TRUE; versions 0.2.11 and later use FALSE as default.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Rossler system is a system of ordinary differential equations defined as:
</p>
<p style="text-align: center;"><code class="reqn">\dot{x} = -(y + z)</code>
</p>

<p style="text-align: center;"><code class="reqn">\dot{y} = x+a \cdot y</code>
</p>

<p style="text-align: center;"><code class="reqn">\dot{z} = b + z*(x-w)</code>
</p>

<p>The default selection for the system parameters (<em>a</em> = 0.2, <em>b</em> = 0.2, <em>w</em> = 5.7) is known to
produce a deterministic chaotic time series.
</p>


<h3>Value</h3>

<p>A list with four vectors named <em>time</em>, <em>x</em>, <em>y</em> 
and <em>z</em> containing the time, the x-components, the 
y-components and the z-components of the Rossler system, respectively.
</p>


<h3>Note</h3>

<p>Some initial values may lead to an unstable system that will tend to 
infinity.
</p>


<h3>Author(s)</h3>

<p>Constantino A. Garcia
</p>


<h3>References</h3>

<p>Strogatz, S.: Nonlinear dynamics and chaos: with applications 
to physics, biology, chemistry and engineering (Studies in Nonlinearity)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+henon">henon</a>, <a href="#topic+logisticMap">logisticMap</a>, <a href="#topic+rossler">rossler</a>, 
<a href="#topic+ikedaMap">ikedaMap</a>, <a href="#topic+cliffordMap">cliffordMap</a>, <a href="#topic+sinaiMap">sinaiMap</a>, <a href="#topic+gaussMap">gaussMap</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
r.ts = rossler(time=seq(0,30,by = 0.01))

## End(Not run)
</code></pre>

<hr>
<h2 id='rqa'>Recurrence Quantification Analysis (RQA)</h2><span id='topic+rqa'></span>

<h3>Description</h3>

<p>The Recurrence Quantification Analysis (RQA) is an advanced technique for the 
nonlinear analysis that allows to quantify the number and duration of the 
recurrences in the phase space.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rqa(
  takens = NULL,
  time.series = NULL,
  embedding.dim = 2,
  time.lag = 1,
  radius,
  lmin = 2,
  vmin = 2,
  distanceToBorder = 2,
  save.RM = TRUE,
  do.plot = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rqa_+3A_takens">takens</code></td>
<td>
<p>Instead of specifying the <em>time.series</em>, 
the <em>embedding.dim</em> and the <em>time.lag</em>, the user may specify 
directly the Takens' vectors.</p>
</td></tr>
<tr><td><code id="rqa_+3A_time.series">time.series</code></td>
<td>
<p>The original time series from which the phase-space 
reconstruction is performed.</p>
</td></tr>
<tr><td><code id="rqa_+3A_embedding.dim">embedding.dim</code></td>
<td>
<p>Integer denoting the dimension in which we shall 
embed the <em>time.series</em>.</p>
</td></tr>
<tr><td><code id="rqa_+3A_time.lag">time.lag</code></td>
<td>
<p>Integer denoting the number of time steps that will be use 
to construct the  Takens' vectors.</p>
</td></tr>
<tr><td><code id="rqa_+3A_radius">radius</code></td>
<td>
<p>Maximum distance between two phase-space points to be 
considered a recurrence.</p>
</td></tr>
<tr><td><code id="rqa_+3A_lmin">lmin</code></td>
<td>
<p>Minimal length of a diagonal line to be considered in the RQA. 
Default <em>lmin</em> = 2.</p>
</td></tr>
<tr><td><code id="rqa_+3A_vmin">vmin</code></td>
<td>
<p>Minimal length of a vertical line to be considered in the RQA. 
Default <em>vmin</em> = 2.</p>
</td></tr>
<tr><td><code id="rqa_+3A_distancetoborder">distanceToBorder</code></td>
<td>
<p>In order to avoid border effects, the 
<em>distanceToBorder</em> points near the border of the recurrence matrix 
are ignored when computing the RQA parameters. Default, 
<em>distanceToBorder</em> = 2.</p>
</td></tr>
<tr><td><code id="rqa_+3A_save.rm">save.RM</code></td>
<td>
<p>Logical value. If TRUE, the recurrence matrix is stored as a 
sparse matrix. Note that computing the recurrences in matrix form can be 
computationally expensive.</p>
</td></tr>
<tr><td><code id="rqa_+3A_do.plot">do.plot</code></td>
<td>
<p>Logical. If TRUE, the recurrence plot is shown. However, 
plotting the recurrence matrix is computationally expensive. Use with 
caution.</p>
</td></tr>
<tr><td><code id="rqa_+3A_...">...</code></td>
<td>
<p>Additional plotting parameters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <em>rqa</em>  object that consist of a list with the most important 
RQA parameters:
</p>

<ul>
<li> <p><em>recurrence.matrix</em>: A sparse symmetric matrix containing the 
recurrences of the phase space.
</p>
</li>
<li> <p><em>REC</em>: Recurrence. Percentage of recurrence points in a 
Recurrence Plot.
</p>
</li>
<li> <p><em>DET</em>: Determinism. Percentage of recurrence points that form 
diagonal lines.
</p>
</li>
<li> <p><em>LAM</em>: Percentage of recurrent points that form vertical lines.
</p>
</li>
<li> <p><em>RATIO</em>: Ratio between <em>DET</em> and <em>RR</em>.
</p>
</li>
<li> <p><em>Lmax</em>: Length of the longest diagonal line.
</p>
</li>
<li> <p><em>Lmean</em>: Mean length of the diagonal lines. The main diagonal is
not taken into account.
</p>
</li>
<li> <p><em>DIV</em>: Inverse of <em>Lmax</em>.
</p>
</li>
<li> <p><em>Vmax</em>: Longest vertical line.
</p>
</li>
<li> <p><em>Vmean</em>: Average length of the vertical lines. This parameter is 
also referred to as the Trapping time.
</p>
</li>
<li> <p><em>ENTR</em>: Shannon entropy of the diagonal line lengths distribution
</p>
</li>
<li> <p><em>TREND</em>: Trend of the number of recurrent points depending on the
distance to the main diagonal
</p>
</li>
<li> <p><em>diagonalHistogram</em>: Histogram of the length of the diagonals.
</p>
</li>
<li> <p><em>recurrenceRate</em>: Number of recurrent points depending on the 
distance to the main diagonal.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Constantino A. Garcia and Gunther Sawitzki
</p>


<h3>References</h3>

<p>Zbilut, J. P. and C. L. Webber. Recurrence quantification 
analysis. Wiley Encyclopedia of Biomedical Engineering  (2006).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
rossler.ts =  rossler(time=seq(0, 10, by = 0.01),do.plot=FALSE)$x
rqa.analysis=rqa(time.series = rossler.ts, embedding.dim=2, time.lag=1,
               radius=1.2,lmin=2,do.plot=FALSE,distanceToBorder=2)
plot(rqa.analysis)

## End(Not run)
</code></pre>

<hr>
<h2 id='sampleEntropy'>Sample Entropy (also known as Kolgomorov-Sinai Entropy)</h2><span id='topic+sampleEntropy'></span><span id='topic+sampleEntropyFunction.sampleEntropy'></span><span id='topic+nlOrder.sampleEntropy'></span><span id='topic+radius.sampleEntropy'></span><span id='topic+embeddingDims.sampleEntropy'></span><span id='topic+plot.sampleEntropy'></span><span id='topic+estimate.sampleEntropy'></span>

<h3>Description</h3>

<p>The Sample Entropy measures the complexity of a time series. Large values of 
the Sample Entropy indicate high complexity whereas that smaller values 
characterize more regular signals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sampleEntropy(corrDim.object, do.plot = TRUE, ...)

## S3 method for class 'sampleEntropy'
sampleEntropyFunction(x)

## S3 method for class 'sampleEntropy'
nlOrder(x)

## S3 method for class 'sampleEntropy'
radius(x)

## S3 method for class 'sampleEntropy'
embeddingDims(x)

## S3 method for class 'sampleEntropy'
plot(
  x,
  main = NULL,
  xlab = NULL,
  ylab = NULL,
  type = "l",
  col = NULL,
  pch = NULL,
  ylim = NULL,
  log = "x",
  add.legend = T,
  ...
)

## S3 method for class 'sampleEntropy'
estimate(
  x,
  regression.range = NULL,
  do.plot = TRUE,
  use.embeddings = NULL,
  fit.col = NULL,
  fit.lty = 2,
  fit.lwd = 2,
  add.legend = T,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sampleEntropy_+3A_corrdim.object">corrDim.object</code></td>
<td>
<p>A <em>corrDim</em> object from which the Sample Entropy
of the time series characterized by <em>corrDim</em> shall be estimated.</p>
</td></tr>
<tr><td><code id="sampleEntropy_+3A_do.plot">do.plot</code></td>
<td>
<p>do.plot Logical value. If TRUE (default value), a plot of the 
sample entropy is shown.</p>
</td></tr>
<tr><td><code id="sampleEntropy_+3A_...">...</code></td>
<td>
<p>Additional plotting arguments.</p>
</td></tr>
<tr><td><code id="sampleEntropy_+3A_x">x</code></td>
<td>
<p>A <em>sampleEntropy</em> object.</p>
</td></tr>
<tr><td><code id="sampleEntropy_+3A_main">main</code></td>
<td>
<p>A title for the plot.</p>
</td></tr>
<tr><td><code id="sampleEntropy_+3A_xlab">xlab</code></td>
<td>
<p>A title for the x axis.</p>
</td></tr>
<tr><td><code id="sampleEntropy_+3A_ylab">ylab</code></td>
<td>
<p>A title for the y axis.</p>
</td></tr>
<tr><td><code id="sampleEntropy_+3A_type">type</code></td>
<td>
<p>Type of plot (see <code>?plot</code>).</p>
</td></tr>
<tr><td><code id="sampleEntropy_+3A_col">col</code></td>
<td>
<p>Vector of colors for each of the dimensions of the plot.</p>
</td></tr>
<tr><td><code id="sampleEntropy_+3A_pch">pch</code></td>
<td>
<p>Vector of symbols for each of the dimensions of the plot</p>
</td></tr>
<tr><td><code id="sampleEntropy_+3A_ylim">ylim</code></td>
<td>
<p>Numeric vector of length 2, giving the y coordinates range..</p>
</td></tr>
<tr><td><code id="sampleEntropy_+3A_log">log</code></td>
<td>
<p>A character string which contains &quot;x&quot; if the x axis is to be 
logarithmic, &quot;y&quot; if the y axis is to be logarithmic and &quot;xy&quot; or &quot;yx&quot; if 
both axes are to be logarithmic.</p>
</td></tr>
<tr><td><code id="sampleEntropy_+3A_add.legend">add.legend</code></td>
<td>
<p>add a legend to the plot?</p>
</td></tr>
<tr><td><code id="sampleEntropy_+3A_regression.range">regression.range</code></td>
<td>
<p>Vector with 2 components denoting the range where the
function will perform linear regression.</p>
</td></tr>
<tr><td><code id="sampleEntropy_+3A_use.embeddings">use.embeddings</code></td>
<td>
<p>A numeric vector specifying which embedding dimensions 
should the <em>estimate</em> function use to compute
the sample entropy.</p>
</td></tr>
<tr><td><code id="sampleEntropy_+3A_fit.col">fit.col</code></td>
<td>
<p>A vector of colors to plot the regression lines.</p>
</td></tr>
<tr><td><code id="sampleEntropy_+3A_fit.lty">fit.lty</code></td>
<td>
<p>The type of line to plot the regression lines.</p>
</td></tr>
<tr><td><code id="sampleEntropy_+3A_fit.lwd">fit.lwd</code></td>
<td>
<p>The width of the line for the regression lines.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The sample entropy is computed using:
</p>
<p style="text-align: center;"><code class="reqn">h_q(m,r) = log(C_q(m,r)/C_{q}(m+1,r))</code>
</p>

<p>where <em>m</em> is the embedding dimension and <em>r</em> is the radius of the 
neighbourhood. When computing the correlation dimensions we use the linear 
regions from the correlation sums in order to do the estimates. Similarly, 
the sample entropy <code class="reqn">h_q(m,r)</code> should not change for both 
various <em>m</em> and <em>r</em>.
</p>
<p>For each embedding dimension the sample
entropy is estimated by averaging  </p>
<p style="text-align: center;"><code class="reqn">h_q(m,r) = log(C_q(m,r)/C_{q}(m+1,r))</code>
</p>

<p>over the range specified by <em>regression range</em> in the <em>estimate</em> 
function.
</p>


<h3>Value</h3>

<p>A <em>sampleEntropy</em> object that contains a list storing the 
sample entropy (<em>sample.entropy</em>), the embedding dimensions 
(<em>embedding.dims</em>) and radius (<em>radius</em>) for which the sample 
entropy has been computed, and the order of the sample entropy 
(<em>entr.order</em>). The sample entropy is stored as a matrix in which 
each row contains the computations for a given embedding dimension and 
each column stores the computations for a given radius.
</p>
<p>The <em>sampleEntropyFunction</em> returns the sample entropy function
<code class="reqn">h_q(m,r)</code> used for the computations. The sample
entropy function is represented by a matrix. Each row represents a given
embedding dimension whereas that each column representes a different radius.
</p>
<p>The <em>nlOrder</em> function returns the order of the sample entropy.
</p>
<p>The <em>radius</em> function returns the radius on which the sample 
entropy function has been evaluated.
</p>
<p>The <em>embeddingDims</em> function returns the embedding dimensions 
on which the sample entropy function has been evaluated.
</p>
<p>The <em>plot</em> function shows the graphics for the sample entropy.
</p>
<p>The  <em>estimate</em> function returns a vector storing the sample 
entropy estimate for each embedding dimension.
</p>


<h3>Author(s)</h3>

<p>Constantino A. Garcia
</p>


<h3>References</h3>

<p>H. Kantz  and T. Schreiber: Nonlinear Time series Analysis 
(Cambridge university press)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
x=henon(n.sample = 15000, n.transient = 100, a = 1.4, b = 0.3, 
        start = c(0.78,0.8165), do.plot = FALSE)$x

cd=corrDim(time.series=x,
           min.embedding.dim=2,max.embedding.dim=9,
           corr.order=2,time.lag=1,
           min.radius=0.05,max.radius=1,
           n.points.radius=100,
           theiler.window=20,
           do.plot=TRUE)

use.col = c("#999999", "#E69F00", "#56B4E9", "#009E73", 
            "#F0E442", "#0072B2", "#D55E00", "#CC79A7")
se=sampleEntropy(cd,do.plot=TRUE,col=use.col,
                 type="l",xlim=c(0.1,1),
                 add.legend=T)
se.est = estimate(se,
                  regression.range = c(0.4,0.6),
                  use.embeddings = 6:9,col=use.col,type="b")
print(se.est)
cat("Expected K2 = ",0.325," Estimated = ",mean(se.est),"\n")

## End(Not run)
</code></pre>

<hr>
<h2 id='sampleEntropyFunction'>Returns the sample entropy function <code class="reqn">h_q(m,r)</code> used for the computations
of the sample entropy.</h2><span id='topic+sampleEntropyFunction'></span>

<h3>Description</h3>

<p>Returns the sample entropy function <code class="reqn">h_q(m,r)</code> used for the computations
of the sample entropy.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sampleEntropyFunction(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sampleEntropyFunction_+3A_x">x</code></td>
<td>
<p>A <em>sampleEntropy</em> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric matrix representing the sample entropy function
<code class="reqn">h_q(m,r)</code> obtained in #' the sample entropy computations represented
by the <em>sampleEntropy</em> object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sampleEntropy">sampleEntropy</a></code>
</p>

<hr>
<h2 id='sinaiMap'>Sinai map</h2><span id='topic+sinaiMap'></span>

<h3>Description</h3>

<p>Generates a 2-dimensional time series using the Sinai map.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sinaiMap(
  a = 0.1,
  start = runif(2),
  n.sample = 5000,
  n.transient = 500,
  do.plot = deprecated()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sinaiMap_+3A_a">a</code></td>
<td>
<p>The <em>a</em> parameter. Default: 0.1</p>
</td></tr>
<tr><td><code id="sinaiMap_+3A_start">start</code></td>
<td>
<p>A 2-dimensional vector indicating the starting values for the 
x and y Sinai coordinates. 
If the starting point is not specified, it is generated randomly.</p>
</td></tr>
<tr><td><code id="sinaiMap_+3A_n.sample">n.sample</code></td>
<td>
<p>Length of the generated time series. Default: 5000 samples.</p>
</td></tr>
<tr><td><code id="sinaiMap_+3A_n.transient">n.transient</code></td>
<td>
<p>Number of transient samples that will be discarded. 
Default: 500 samples.</p>
</td></tr>
<tr><td><code id="sinaiMap_+3A_do.plot">do.plot</code></td>
<td>
<p>Logical value. If TRUE, a plot of the 
generated Sinai system is shown. Before version 0.2.11, default value was
TRUE; versions 0.2.11 and later use FALSE as default.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Sinai map is defined as follows:
</p>
<p style="text-align: center;"><code class="reqn">x_{n+1} = (x_{n} + y_{n} + a \cdot cos(2 \cdot pi \cdot y_{n}) )mod 1</code>
</p>

<p style="text-align: center;"><code class="reqn">y_{n+1} = (x_{n} + 2 \cdot y_n)mod 1</code>
</p>

<p>The default selection for the <em>a</em> parameter is known to produce a deterministic chaotic time series.
</p>


<h3>Value</h3>

<p>A list with two vectors named x and y containing the x-components 
and the  y-components of the Sinai map, respectively.
</p>


<h3>Note</h3>

<p>Some initial values may lead to an unstable system that will tend to 
infinity.
</p>


<h3>Author(s)</h3>

<p>Constantino A. Garcia
</p>


<h3>References</h3>

<p>Mcsharry, P. E. and P. R. Ruffino (2003). Asymptotic angular stability 
in nonlinear systems: rotation numbers and winding numbers. Dynamical 
Systems 18(3), 191-200.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+henon">henon</a>, <a href="#topic+logisticMap">logisticMap</a>, <a href="#topic+lorenz">lorenz</a>, 
<a href="#topic+rossler">rossler</a>, <a href="#topic+ikedaMap">ikedaMap</a>, <a href="#topic+cliffordMap">cliffordMap</a>, <a href="#topic+gaussMap">gaussMap</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
sinai.map = sinaiMap(n.sample = 1000, n.transient=10,do.plot=TRUE)
# accessing the x coordinate and plotting it
plot(ts(sinai.map$x))

## End(Not run)
</code></pre>

<hr>
<h2 id='spaceTimePlot'>Space Time plot</h2><span id='topic+spaceTimePlot'></span><span id='topic+contourLines.spaceTimePlot'></span><span id='topic+getContourLines.spaceTimePlot'></span><span id='topic+plot.spaceTimePlot'></span>

<h3>Description</h3>

<p>The space time separation is a broadly-used method of detecting 
non-stationarity and temporal correlations in the time series being analyzed.
The space time separation plot is also used to select a proper Theiler 
window by selecting a temporal separation enough to saturate the contour 
lines.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spaceTimePlot(
  takens = NULL,
  time.series = NULL,
  embedding.dim = 2,
  time.lag = 1,
  max.radius = NULL,
  time.step = 1,
  number.time.steps = NULL,
  numberPercentages = 10,
  do.plot = TRUE,
  ...
)

## S3 method for class 'spaceTimePlot'
contourLines(x)

## S3 method for class 'spaceTimePlot'
getContourLines(x)

## S3 method for class 'spaceTimePlot'
plot(
  x,
  main = "Space time separation plot",
  xlab = NULL,
  ylab = NULL,
  type = "l",
  ylim = NULL,
  col = NULL,
  pch = NULL,
  add.legend = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="spaceTimePlot_+3A_takens">takens</code></td>
<td>
<p>Instead of specifying the <em>time.series</em>, the 
<em>embedding.dim</em> and the <em>time.lag</em>, the user may specify directly
the Takens' vectors.</p>
</td></tr>
<tr><td><code id="spaceTimePlot_+3A_time.series">time.series</code></td>
<td>
<p>The original time series being analyzed.</p>
</td></tr>
<tr><td><code id="spaceTimePlot_+3A_embedding.dim">embedding.dim</code></td>
<td>
<p>Integer denoting the dimension in which we shall embed 
the time series.</p>
</td></tr>
<tr><td><code id="spaceTimePlot_+3A_time.lag">time.lag</code></td>
<td>
<p>Integer denoting the number of time steps that will be use 
to construct the 
Takens' vectors.</p>
</td></tr>
<tr><td><code id="spaceTimePlot_+3A_max.radius">max.radius</code></td>
<td>
<p>Maximum neighbourhood radius in which the algorithm will 
look for finding neighbours. This
parameter may be used to avoid heavy computations. If the user does not 
specify a radius, the algorithm estimates it.</p>
</td></tr>
<tr><td><code id="spaceTimePlot_+3A_time.step">time.step</code></td>
<td>
<p>Integer denoting the number of discrete steps between two 
calculations of the space time plot.</p>
</td></tr>
<tr><td><code id="spaceTimePlot_+3A_number.time.steps">number.time.steps</code></td>
<td>
<p>Integer denoting the number of temporal jumps in 
steps of <em>time.step</em> in which we want to compute the space time plot.</p>
</td></tr>
<tr><td><code id="spaceTimePlot_+3A_numberpercentages">numberPercentages</code></td>
<td>
<p>Number of contour lines to be computed. Each 
contour line represent a concrete percentage of points (see Details).</p>
</td></tr>
<tr><td><code id="spaceTimePlot_+3A_do.plot">do.plot</code></td>
<td>
<p>Logical. If TRUE, the time space plot is shown.</p>
</td></tr>
<tr><td><code id="spaceTimePlot_+3A_...">...</code></td>
<td>
<p>Additional plotting parameters.</p>
</td></tr>
<tr><td><code id="spaceTimePlot_+3A_x">x</code></td>
<td>
<p>A <em>spaceTimePlot</em> object.</p>
</td></tr>
<tr><td><code id="spaceTimePlot_+3A_main">main</code></td>
<td>
<p>A title for the plot.</p>
</td></tr>
<tr><td><code id="spaceTimePlot_+3A_xlab">xlab</code></td>
<td>
<p>A title for the x axis.</p>
</td></tr>
<tr><td><code id="spaceTimePlot_+3A_ylab">ylab</code></td>
<td>
<p>A title for the y axis.</p>
</td></tr>
<tr><td><code id="spaceTimePlot_+3A_type">type</code></td>
<td>
<p>Type of plot (see <code>?plot</code>).</p>
</td></tr>
<tr><td><code id="spaceTimePlot_+3A_ylim">ylim</code></td>
<td>
<p>Numeric vector of length 2, giving the y coordinates range.</p>
</td></tr>
<tr><td><code id="spaceTimePlot_+3A_col">col</code></td>
<td>
<p>Vector of colors for each of the percentages of the plot.</p>
</td></tr>
<tr><td><code id="spaceTimePlot_+3A_pch">pch</code></td>
<td>
<p>Vector of symbols for each of the percentages of the plot.</p>
</td></tr>
<tr><td><code id="spaceTimePlot_+3A_add.legend">add.legend</code></td>
<td>
<p>add a legend to the plot?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Each contour line of the space time plot indicate the distance you have to 
go (y-axis) to find a given fraction of neighbour pairs, depending on their 
temporal separation (x-axis).
</p>
<p>WARNING: The parameter <em>number.time.steps</em> should be used with caution 
since this 
method performs heavy computations.
</p>


<h3>Value</h3>

<p>A <em>timeSpacePlot</em> object that consist, essentially, of a 
matrix storing the values for each contour line.
Each row stores the value for a given percentage of points. Each column 
stores the value of the radius you have to go to find a given fraction of 
neighbour pairs (the rows), depending on their temporal separation 
(the colums). This matrix can be accessed by using the <em>contourlines</em>
method.
</p>
<p>The <em>contourLines</em> function returns the contour lines of the 
space time plot.
</p>


<h3>Author(s)</h3>

<p>Constantino A. Garcia
</p>


<h3>References</h3>

<p>H. Kantz  and T. Schreiber: Nonlinear Time series Analysis 
(Cambridge university press)
</p>


<h3>Examples</h3>

<pre><code class='language-R'> ## Not run: 
 tak = buildTakens(sin(2*pi*0.005*(0:5000)),2,1)
 stp.test = spaceTimePlot(takens=tak,number.time.steps=400,do.plot=TRUE)
 
## End(Not run)
</code></pre>

<hr>
<h2 id='surrogateTest'>Surrogate data testing</h2><span id='topic+surrogateTest'></span>

<h3>Description</h3>

<p>Surrogate data testing
</p>


<h3>Usage</h3>

<pre><code class='language-R'>surrogateTest(
  time.series,
  significance = 0.05,
  one.sided = FALSE,
  alternative = c("smaller", "larger"),
  K = 1,
  FUN,
  verbose = TRUE,
  do.plot = TRUE,
  xlab = "Values of the statistic",
  ylab = "",
  main = "Surrogate data testing",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="surrogateTest_+3A_time.series">time.series</code></td>
<td>
<p>The original time.series from which the surrogate data is
generated.</p>
</td></tr>
<tr><td><code id="surrogateTest_+3A_significance">significance</code></td>
<td>
<p>Significance of the test</p>
</td></tr>
<tr><td><code id="surrogateTest_+3A_one.sided">one.sided</code></td>
<td>
<p>Logical value. If <em>TRUE</em>, the routine runs a one-side
test. If <em>FALSE</em>, a two-side test is applied (default).</p>
</td></tr>
<tr><td><code id="surrogateTest_+3A_alternative">alternative</code></td>
<td>
<p>Specifies the concrete type of one-side test that should be 
performed: If the the user wants to test if the statistic from the original
data is smaller (<em>alternative=&quot;smaller&quot;</em>) or larger 
(<em>alternative=&quot;larger&quot;</em>) than the expected value under the
null hypothesis.</p>
</td></tr>
<tr><td><code id="surrogateTest_+3A_k">K</code></td>
<td>
<p>Integer controlling the number of surrogates to be generated (see
details).</p>
</td></tr>
<tr><td><code id="surrogateTest_+3A_fun">FUN</code></td>
<td>
<p>The function that computes the discriminating statistic that shall
be used for testing.</p>
</td></tr>
<tr><td><code id="surrogateTest_+3A_verbose">verbose</code></td>
<td>
<p>Logical value. If TRUE, a brief summary of the test is shown.</p>
</td></tr>
<tr><td><code id="surrogateTest_+3A_do.plot">do.plot</code></td>
<td>
<p>Logical value. If TRUE, a graphical representation of the 
statistic value for  both surrogates and original data is shown.</p>
</td></tr>
<tr><td><code id="surrogateTest_+3A_xlab">xlab</code></td>
<td>
<p>a title for the x axis.</p>
</td></tr>
<tr><td><code id="surrogateTest_+3A_ylab">ylab</code></td>
<td>
<p>a title for the y axis.</p>
</td></tr>
<tr><td><code id="surrogateTest_+3A_main">main</code></td>
<td>
<p>an overall title for the plot.</p>
</td></tr>
<tr><td><code id="surrogateTest_+3A_...">...</code></td>
<td>
<p>Additional arguments for the FUN function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function tests the null hypothesis (H0) stating that the series 
is a gaussian linear process. The test is performed by generating several 
surrogate data according to H0 and comparing the values of a discriminating
statistic between both original data and the surrogate data. If the value of 
the statistic is significantly different for the original series than for the
surrogate set, the null hypothesis is rejected and nonlinearity assumed.  
</p>
<p>To test with a significance level of <code class="reqn">\alpha</code> if the statistic
from the original data is smaller than the expected  value under the null
hypothesis (a one-side test),  <code class="reqn">K/\alpha - 1</code> surrogates
are generated. The null hypothesis is then rejected if the statistic from
the data has one of the K smallest values. For a two-sided test, 
<code class="reqn">2K/\alpha - 1</code> surrogates are generated. The null 
hypothesis is rejected if the statistic from the data gives one of the K 
smallest or largest values.
</p>
<p>The  surrogate data is generated by using a phase randomization procedure.
</p>


<h3>Value</h3>

<p>A list containing the values of the statistic for the surrogates 
(<em>surrogates.statistics</em> field) and the value for the original time 
series (<em>data.statistic</em>)
</p>


<h3>Author(s)</h3>

<p>Constantino A. Garcia
</p>


<h3>References</h3>

<p>SCHREIBER, Thomas; SCHMITZ, Andreas. Surrogate time series. 
Physica D: Nonlinear Phenomena, 2000, vol. 142, no 3, p. 346-382.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
 lx = lorenz(do.plot=F)$x 
 sdt = surrogateTest(time.series = lx,significance = 0.05,
                     K=5, one.sided = FALSE, FUN=timeAsymmetry) 

## End(Not run)
</code></pre>

<hr>
<h2 id='thresholdTest'>Threshold nonlinearity test</h2><span id='topic+thresholdTest'></span>

<h3>Description</h3>

<p>Computes the likelihood ratio test for threshold nonlinearity 
with H0 being an AR process and H1 a TAR model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>thresholdTest(
  time.series,
  p,
  d = 1,
  lower.percent = 0.25,
  upper.percent = 0.75
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="thresholdTest_+3A_time.series">time.series</code></td>
<td>
<p>The original time.series.</p>
</td></tr>
<tr><td><code id="thresholdTest_+3A_p">p</code></td>
<td>
<p>The order of the AR process.</p>
</td></tr>
<tr><td><code id="thresholdTest_+3A_d">d</code></td>
<td>
<p>Delay used for the threshold value in the TAR process.</p>
</td></tr>
<tr><td><code id="thresholdTest_+3A_lower.percent">lower.percent</code></td>
<td>
<p>The threshold value is searched over an interval 
defined by <em>lower.percent</em> and <em>upper.percent</em> of the time series
values. This defines the lower percent.</p>
</td></tr>
<tr><td><code id="thresholdTest_+3A_upper.percent">upper.percent</code></td>
<td>
<p>The threshold value is searched over an interval 
defined by <em>lower.percent</em> and <em>upper.percent</em> of the time series
values. This defines the upper percent.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing
</p>

<ul>
<li><p> p.value: p-value of the test
</p>
</li>
<li><p> test.statistic: Likelihood ratio test statistic.
</p>
</li>
<li><p> percentiles: Since the search for the threshold parameter may 
occur in a narrower interval than the one specified by the user, the
effective lower and upper percents are returned here.
</p>
</li></ul>



<h3>Note</h3>

<p>Adapted from the <em>tlrt</em> function of the <em>TSA</em> package.
</p>


<h3>Author(s)</h3>

<p>Kung-Sik Chan
</p>


<h3>References</h3>

<p>Chan, K.S. (1990). Percentage points of likelihood ratio tests 
for threshold autoregression. Journal of Royal Statistical Society,
B 53, 3, 691-696.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+nonlinearityTest">nonlinearityTest</a></code>, <code><a href="#topic+keenanTest">keenanTest</a></code>,
<code><a href="#topic+tsayTest">tsayTest</a></code>, <code><a href="#topic+mcleodLiTest">mcleodLiTest</a></code>
</p>

<hr>
<h2 id='timeAsymmetry'>Time Reversibility statistic</h2><span id='topic+timeAsymmetry'></span>

<h3>Description</h3>

<p>Time Reversibility statistic
</p>


<h3>Usage</h3>

<pre><code class='language-R'>timeAsymmetry(time.series)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="timeAsymmetry_+3A_time.series">time.series</code></td>
<td>
<p>The time series used to compute the statistic.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The time simmetry statistic  measures the asymmetry of a time series 
under time reversal by calculating:
</p>
<p style="text-align: center;"><code class="reqn">E[s_n\cdot s_{n+1}^2] - E[s_n^2\cdot s_{n+1}] </code>
</p>
<p>.
Since linear stochastic series are symmetric under time reversal, this 
statistic may be used for testing the assertion that the data was generated
from a stationary linear stochastic process or not.
</p>


<h3>Value</h3>

<p>The time simmetry statistic.
</p>


<h3>Author(s)</h3>

<p>Constantino A. Garcia
</p>


<h3>References</h3>

<p>H. Kantz  and T. Schreiber: Nonlinear Time series Analysis 
(Cambridge university press, second edition, section 7.1.3)
</p>

<hr>
<h2 id='timeAsymmetry2'>Time Reversibility statistic</h2><span id='topic+timeAsymmetry2'></span>

<h3>Description</h3>

<p>Time Reversibility statistic
</p>


<h3>Usage</h3>

<pre><code class='language-R'>timeAsymmetry2(time.series, tau)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="timeAsymmetry2_+3A_time.series">time.series</code></td>
<td>
<p>The time series used to compute the statistic</p>
</td></tr>
<tr><td><code id="timeAsymmetry2_+3A_tau">tau</code></td>
<td>
<p>Time delay used to compute the third order statistic.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The time simmetry statistic  measures the asymmetry of a time 
series under time reversal by implementing the third order statistic:
</p>
<p style="text-align: center;"><code class="reqn">E[s_n - s_{n-\tau})^3] </code>
</p>
<p>.
Since linear stochastic series are symmetric under time reversal, this 
statistic may be used for testing the assertion that the data was generated
from a stationary linear stochastic process or not.
</p>


<h3>Value</h3>

<p>The time simmetry statistic for the delays specified with
<em>tau</em>.
</p>


<h3>Author(s)</h3>

<p>Constantino A. Garcia
</p>


<h3>See Also</h3>

<p><code><a href="#topic+timeAsymmetry">timeAsymmetry</a></code>
</p>

<hr>
<h2 id='timeLag'>Estimate an appropiate time lag for the Takens' vectors</h2><span id='topic+timeLag'></span>

<h3>Description</h3>

<p>Given a time series (time.series), an embedding dimension (m) and a 
time lag (timeLag), the <code class="reqn">n^{th}</code> 
Takens' vector is defined as 
</p>
<p style="text-align: center;"><code class="reqn">T[n]=\{time.series[n], time.series[n+ timeLag],...time.series[n+m*timeLag]\}.</code>
</p>

<p>This function estimates an appropiate time lag by using the autocorrelation 
function or the average mutual information .
</p>


<h3>Usage</h3>

<pre><code class='language-R'>timeLag(
  time.series,
  technique = c("acf", "ami"),
  selection.method = c("first.e.decay", "first.zero", "first.minimum", "first.value"),
  value = 1/exp(1),
  lag.max = NULL,
  do.plot = TRUE,
  main = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="timeLag_+3A_time.series">time.series</code></td>
<td>
<p>The original time series.</p>
</td></tr>
<tr><td><code id="timeLag_+3A_technique">technique</code></td>
<td>
<p>The technique that we shall use to estimate the time lag 
(see the Details section). Allowed values are <em>&quot;acf&quot;</em> and <em>&quot;ami&quot;</em>.</p>
</td></tr>
<tr><td><code id="timeLag_+3A_selection.method">selection.method</code></td>
<td>
<p>Method used for selecting a concrete time lag. 
Available methods are <em>&quot;first.zero&quot;</em>, <em>&quot;first.e.decay&quot;</em> (default),
<em>&quot;first.minimum&quot;</em> and <em>&quot;first.value&quot;</em>.</p>
</td></tr>
<tr><td><code id="timeLag_+3A_value">value</code></td>
<td>
<p>Numeric value indicating the value that the autocorrelation/AMI 
function must cross in order to select the time lag. It is used only with
the &quot;first.value&quot; selection method.</p>
</td></tr>
<tr><td><code id="timeLag_+3A_lag.max">lag.max</code></td>
<td>
<p>Maximum lag at which to calculate the acf/AMI.</p>
</td></tr>
<tr><td><code id="timeLag_+3A_do.plot">do.plot</code></td>
<td>
<p>Logical value. If TRUE (default value), a plot of the 
autocorrelation/AMI function is shown.</p>
</td></tr>
<tr><td><code id="timeLag_+3A_main">main</code></td>
<td>
<p>A title for the plot.</p>
</td></tr>
<tr><td><code id="timeLag_+3A_...">...</code></td>
<td>
<p>Additional parameters for the <em>acf</em> or the 
<em>mutualInformation</em>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A basic criteria for estimating a proper time lag is based on the following 
reasoning: if the time lag used to build the Takens' vectors is too small,
the coordinates will be too highly temporally correlated and the embedding
will tend to cluster around the diagonal in the phase space. If the time lag
is chosen too large, the resulting coordinates may be almost uncorrelated and
the resulting embedding will be very complicated. Thus, the autocorrelation 
function can be used for  estimating an appropiate time lag of a time series. 
However, it must be noted that the autocorrelation is a linear statistic,
and thus it does not take into account nonlinear dynamical correlations. To 
take into account nonlinear correlations the average mutual information (AMI)
can be used. Independently of the technique used to compute the correlation, 
the time lag can be selected in a variety of ways:   
</p>

<ul>
<li><p> Select the time lag where the autocorrelation/AMI function decays to 0 
(<em>first.zero</em> selection method). This
method is not appropriate for the AMI function, since it only takes 
positive values.
</p>
</li>
<li><p> Select the time lag where the autocorrelation/AMI function decays to 
1/e of its value at zero (<em>first.e.decay</em> selection method).
</p>
</li>
<li><p> Select the time lag where the autocorrelation/AMI function reaches 
its first minimum (<em>first.minimum</em> selection method).
</p>
</li>
<li><p> Select the time lag where the autocorrelation/AMI function decays to
the value specified by the user (<em>first.value</em> selection method and 
<em>value</em> parameter).
</p>
</li></ul>



<h3>Value</h3>

<p>The estimated time lag.
</p>


<h3>Note</h3>

<p>If the autocorrelation/AMI function does not cross the specifiged value, 
an error is thrown. This may be solved by increasing the <em>lag.max</em> or 
selecting a higher value to which the autocorrelation/AMI function may decay.
</p>


<h3>Author(s)</h3>

<p>Constantino A. Garcia
</p>


<h3>References</h3>

<p>H. Kantz  and T. Schreiber: Nonlinear Time series Analysis
(Cambridge university press)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mutualInformation">mutualInformation</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
sx = sinaiMap(a=0.3,n.sample=5000,start=c(0.23489,0.8923),do.plot=FALSE)$x
timeLag(sx, technique="ami",  
        n.partitions = 20, units = "Bits")
timeLag(sx, technique="acf") 
## End(Not run)
</code></pre>

<hr>
<h2 id='tsayTest'>Tsay's test</h2><span id='topic+tsayTest'></span>

<h3>Description</h3>

<p>Tsay's test: test for nonlinearity against the null hypothesis that the time
series follows some AR process. This is a generalization of Keenan's test.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tsayTest(time.series, order)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tsayTest_+3A_time.series">time.series</code></td>
<td>
<p>The original time.series.</p>
</td></tr>
<tr><td><code id="tsayTest_+3A_order">order</code></td>
<td>
<p>Order used for the AR model.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the results of the test, including:
</p>

<ul>
<li><p> test.stat: the F-squared test statistic
</p>
</li>
<li><p> p.value.
</p>
</li>
<li><p> order: order of the AR process used for testing.
</p>
</li></ul>



<h3>References</h3>

<p>Tsay, R. S. (1986), Nonlinearity test for time series, Biometrika,
73, 461-466.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+nonlinearityTest">nonlinearityTest</a></code>, <code><a href="#topic+keenanTest">keenanTest</a></code>,
<code><a href="#topic+mcleodLiTest">mcleodLiTest</a></code>,<code><a href="#topic+thresholdTest">thresholdTest</a></code>
</p>

<hr>
<h2 id='windowSizes'>Returns the window sizes used for DFA in a <em>dfa</em> object.</h2><span id='topic+windowSizes'></span>

<h3>Description</h3>

<p>Returns the window sizes used for DFA in a <em>dfa</em> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>windowSizes(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="windowSizes_+3A_x">x</code></td>
<td>
<p>A <em>dfa</em> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The <em>windowSizes</em> function returns the windows sizes used
to detrend the time series in the DFA.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dfa">dfa</a></code>
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
