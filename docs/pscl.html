<!DOCTYPE html><html><head><title>Help for package pscl</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {pscl}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#absentee'><p>Absentee and Machine Ballots in Pennsylvania State Senate Races</p></a></li>
<li><a href='#admit'><p>Applications to a Political Science PhD Program</p></a></li>
<li><a href='#AustralianElectionPolling'>
<p>Political opinion polls in Australia, 2004-07</p></a></li>
<li><a href='#AustralianElections'><p>elections to Australian House of</p>
Representatives, 1949-2016</a></li>
<li><a href='#betaHPD'><p>compute and optionally plot beta HDRs</p></a></li>
<li><a href='#bioChemists'><p>article production by graduate students in biochemistry Ph.D. programs</p></a></li>
<li><a href='#ca2006'><p>California Congressional Districts in 2006</p></a></li>
<li><a href='#computeMargins'><p>add information about voting outcomes to a rollcall</p>
object</a></li>
<li><a href='#constrain.items'><p>constrain item parameters in analysis of roll call data</p></a></li>
<li><a href='#constrain.legis'><p>constrain legislators' ideal points in analysis of roll call data</p></a></li>
<li><a href='#convertCodes'><p>convert entries in a rollcall matrix to binary form</p></a></li>
<li><a href='#dropRollCall'><p>drop user-specified elements from a rollcall object</p></a></li>
<li><a href='#dropUnanimous'><p>drop unanimous votes from rollcall objects and matrices</p></a></li>
<li><a href='#EfronMorris'><p>Batting Averages for 18 major league baseball players, 1970</p></a></li>
<li><a href='#extractRollCallObject'><p>return the roll call object used in fitting an ideal model</p></a></li>
<li><a href='#hitmiss'><p>Table of Actual Outcomes against Predicted Outcomes for discrete</p>
data models</a></li>
<li><a href='#hurdle'><p>Hurdle Models for Count Data Regression</p></a></li>
<li><a href='#hurdle.control'><p>Control Parameters for Hurdle Count Data Regression</p></a></li>
<li><a href='#hurdletest'><p>Testing for the Presence of a Zero Hurdle</p></a></li>
<li><a href='#ideal'><p>analysis of educational testing data and roll call data with IRT models, via Markov</p>
chain Monte Carlo methods</a></li>
<li><a href='#idealToMCMC'><p>convert an object of class ideal to a coda MCMC object</p></a></li>
<li><a href='#igamma'><p>inverse-Gamma distribution</p></a></li>
<li><a href='#iraqVote'>
<p>U.S. Senate vote on the use of force against Iraq, 2002.</p></a></li>
<li><a href='#nj07'><p>rollcall object, National Journal key votes of 2007</p></a></li>
<li><a href='#ntable'><p>nicely formatted tables</p></a></li>
<li><a href='#odTest'><p>likelihood ratio test for over-dispersion in count data</p></a></li>
<li><a href='#partycodes'><p>political parties appearing in the U.S. Congress</p></a></li>
<li><a href='#plot.ideal'><p>plots an ideal object</p></a></li>
<li><a href='#plot.predict.ideal'><p>plot methods for predictions from ideal objects</p></a></li>
<li><a href='#plot.seatsVotes'><p>plot seats-votes curves</p></a></li>
<li><a href='#politicalInformation'><p>Interviewer ratings of respondent levels of political information</p></a></li>
<li><a href='#postProcess'><p>remap MCMC output via affine transformations</p></a></li>
<li><a href='#pR2'><p>compute various pseudo-R2 measures</p></a></li>
<li><a href='#predict.hurdle'><p>Methods for hurdle Objects</p></a></li>
<li><a href='#predict.ideal'><p>predicted probabilities from an ideal object</p></a></li>
<li><a href='#predict.zeroinfl'><p>Methods for zeroinfl Objects</p></a></li>
<li><a href='#predprob'><p>compute predicted probabilities from fitted models</p></a></li>
<li><a href='#predprob.glm'><p>Predicted Probabilities for GLM Fits</p></a></li>
<li><a href='#predprob.ideal'><p>predicted probabilities from fitting ideal to rollcall data</p></a></li>
<li><a href='#presidentialElections'><p>elections for U.S. President, 1932-2016, by state</p></a></li>
<li><a href='#prussian'><p>Prussian army horse kick data</p></a></li>
<li><a href='#readKH'><p>read roll call data in Poole-Rosenthal KH format</p></a></li>
<li><a href='#RockTheVote'><p>Voter turnout experiment, using Rock The Vote ads</p></a></li>
<li><a href='#rollcall'><p>create an object of class rollcall</p></a></li>
<li><a href='#s109'><p>rollcall object, 109th U.S. Senate (2005-06).</p></a></li>
<li><a href='#sc9497'><p>votes from the United States Supreme Court, from 1994-1997</p></a></li>
<li><a href='#seatsVotes'><p>A class for creating seats-votes curves</p></a></li>
<li><a href='#simpi'><p>Monte Carlo estimate of pi (3.14159265...)</p></a></li>
<li><a href='#state.info'><p>information about the American states needed for U.S. Congress</p></a></li>
<li><a href='#summary.ideal'><p>summary of an ideal object</p></a></li>
<li><a href='#summary.rollcall'><p>summarize a rollcall object</p></a></li>
<li><a href='#tracex'><p>trace plot of MCMC iterates, posterior density of legislators'</p>
ideal points</a></li>
<li><a href='#UKHouseOfCommons'><p>1992 United Kingdom electoral returns</p></a></li>
<li><a href='#unionDensity'><p>cross national rates of trade union density</p></a></li>
<li><a href='#vectorRepresentation'><p>convert roll call matrix to series of vectors</p></a></li>
<li><a href='#vote92'>
<p>Reports of voting in the 1992 U.S. Presidential election.</p></a></li>
<li><a href='#vuong'><p>Vuong's non-nested hypothesis test</p></a></li>
<li><a href='#zeroinfl'><p>Zero-inflated Count Data Regression</p></a></li>
<li><a href='#zeroinfl.control'><p>Control Parameters for Zero-inflated Count Data Regression</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>1.5.9</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-01-14</td>
</tr>
<tr>
<td>Title:</td>
<td>Political Science Computational Laboratory</td>
</tr>
<tr>
<td>Imports:</td>
<td>MASS, datasets, grDevices, graphics, stats, utils</td>
</tr>
<tr>
<td>Suggests:</td>
<td>lattice, MCMCpack, car, lmtest, sandwich, zoo, coda, vcd,
mvtnorm, mgcv</td>
</tr>
<tr>
<td>Description:</td>
<td>Bayesian analysis of item-response theory (IRT) models,
  roll call analysis; computing highest density regions; 
  maximum likelihood estimation of zero-inflated and hurdle models for count data;
  goodness-of-fit measures for GLMs;
  data sets used in writing	and teaching; seats-votes curves.</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/atahk/pscl">https://github.com/atahk/pscl</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.0</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-01-16 06:19:34 UTC; jackman</td>
</tr>
<tr>
<td>Author:</td>
<td>Simon Jackman <a href="https://orcid.org/0000-0001-7421-4034"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Alex Tahk <a href="https://orcid.org/0000-0001-7895-9420"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [ctb],
  Achim Zeileis <a href="https://orcid.org/0000-0003-0918-3766"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb],
  Christina Maimone <a href="https://orcid.org/0000-0002-0402-6297"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb],
  James Fearon [ctb],
  Zoe Meers <a href="https://orcid.org/0000-0001-8045-6531"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Simon Jackman &lt;simon.jackman@sydney.edu.au&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-01-31 08:00:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='absentee'>Absentee and Machine Ballots in Pennsylvania State Senate Races</h2><span id='topic+absentee'></span>

<h3>Description</h3>

<p>Absentee ballot outcomes contrasted with machine ballots, cast
in Pennsylvania State Senate elections, selected districts,
1982-1993.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(absentee)</code></pre>


<h3>Format</h3>

<p>A data frame with 22 observations on the following 8 variables.
</p>

<dl>
<dt><code>year</code></dt><dd><p>a numeric vector, year of election, 19xx</p>
</dd>
<dt><code>district</code></dt><dd><p>a numeric vector, Pennsylvania State Senate district</p>
</dd>
<dt><code>absdem</code></dt><dd><p>a numeric vector, absentee ballots cast for the
Democratic candidate</p>
</dd>
<dt><code>absrep</code></dt><dd><p>a numeric vector, absentee ballots cast for the
Republican candidate</p>
</dd>
<dt><code>machdem</code></dt><dd><p>a numeric vector, votes cast on voting
machines for the Democratic candidate</p>
</dd>
<dt><code>machrep</code></dt><dd><p>a numeric vector, votes cast on voting
machines for the Republican candidate</p>
</dd>
<dt><code>dabs</code></dt><dd><p>a numeric vector, Democratic margin among
absentee ballots</p>
</dd>
<dt><code>dmach</code></dt><dd><p>a numeric vector, Democratic margin among
ballots case on voting machines</p>
</dd>
</dl>



<h3>Details</h3>

<p>In November 1993, the state of Pennsylvania conducted
elections for its state legislature. The result in the Senate election
in the 2nd district (based in Philadelphia) was challenged in court,
and ultimately overturned. The Democratic candidate won 19,127 of
the votes cast by voting machine, while the Republican won 19,691
votes cast by voting machine, giving the Republican a lead of 564
votes. However, the Democrat won 1,396 absentee ballots, while the
Republican won just 371 absentee ballots, more than offsetting the
Republican lead based on the votes recorded by machines on election
day. The Republican candidate sued, claiming that many of the absentee
ballots were fraudulent. The judge in the case solicited expert
analysis from Orley Ashenfelter, an economist at Princeton
University. Ashenfelter examined the relationship between absentee
vote margins and machine vote margins in 21 previous Pennsylvania
Senate elections in seven districts in the Philadelphia area over the
preceding decade.</p>


<h3>Source</h3>

<p>Ashenfelter, Orley.  1994.  Report on Expected Absentee Ballots.
Typescript.  Department of Economics, Princeton University.
</p>


<h3>References</h3>

<p>Ashenfelter, Orley, Phillip Levine and David Zimmerman.  2003.
<em>Statistics and Econometrics: Methods and Applications</em>.  New
York: John Wiley and Sons.
</p>
<p>Jackman, Simon.  2009.  <em>Bayesian Analysis for the Social Sciences</em>. 
Wiley: Hoboken, New Jersey.  Examples 2.13, 2.14, 2.15.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(absentee)
summary(absentee)

denom &lt;- absentee$absdem + absentee$absrep
y &lt;- (absentee$absdem - absentee$absrep)/denom * 100
denom &lt;- absentee$machdem + absentee$machrep
x &lt;- (absentee$machdem - absentee$machrep)/denom *100

ols &lt;- lm(y ~ x,
          subset=c(rep(TRUE,21),FALSE)  ## drop data point 22
          )

## predictions for disputed absentee point
yhat22 &lt;- predict(ols,
                  newdata=list(x=x[22]),
                  se.fit=TRUE,
                  interval="prediction")
tstat &lt;- (y[22]-yhat22$fit[,"fit"])/yhat22$se.fit
cat("tstat on actual outcome for obs 22:",tstat,"\n")
cat(paste("Pr(t&gt;",round(tstat,2),") i.e., one-sided:\n",sep=""))
cat(1-pt(tstat,df=yhat22$df),"\n")

## make a picture
xseq &lt;- seq(min(x)-.1*diff(range(x)),
            max(x)+.1*diff(range(x)),
            length=100)
yhat &lt;- predict(ols,interval="prediction",
                newdata=list(x=xseq))
plot(y~x,
     type="n",
     axes=FALSE,
     ylim=range(yhat,y),
     xlim=range(xseq),xaxs="i",
     xlab="Democratic Margin, Machine Ballots (Percentage Points)",
     ylab="Democratic Margin, Absentee Ballots (Percentage Points)")
polygon(x=c(xseq,rev(xseq)),  ## overlay 95% prediction CI
        y=c(yhat[,"lwr"],rev(yhat[,"upr"])),
        border=FALSE,
        col=gray(.85))
abline(ols,lwd=2)           ## overlay ols
points(x[-22],y[-22],pch=1) ## data
points(x[22],y[22],pch=16)  ## disputed data point

text(x[22],y[22],
     "Disputed\nElection",
     cex=.75,
     adj=1.25)
axis(1)
axis(2)

</code></pre>

<hr>
<h2 id='admit'>Applications to a Political Science PhD Program</h2><span id='topic+admit'></span>

<h3>Description</h3>

<p>Ordinal ratings (faculty evaluations) of applicants to a Political Science PhD
Program.</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(admit)</code></pre>


<h3>Format</h3>

<p>A data frame with 106 observations on the following 6 variables.
</p>

<dl>
<dt><code>score</code></dt><dd><p>an ordered factor with levels <code>1</code> &lt; <code>2</code> &lt; <code>3</code> &lt; <code>4</code> &lt; <code>5</code></p>
</dd>
<dt><code>gre.quant</code></dt><dd><p>applicant's score on the quantitative
section of the GRE; the maximum score is 800</p>
</dd>
<dt><code>gre.verbal</code></dt><dd><p>applicant's score on the verbal section of
the GRE; the maximum score is 800</p>
</dd>
<dt><code>ap</code></dt><dd><p>1 if the applicant indicated an interest in
American politics; 0 otherwise</p>
</dd>
<dt><code>pt</code></dt><dd><p>1 if the applicant indicated an interest in
Political Theory; 0 otherwise</p>
</dd>
<dt><code>female</code></dt><dd><p>1 for female applicants; 0 otherwise</p>
</dd>
</dl>



<h3>References</h3>

<p>Jackman, Simon.  2004.  &quot;What Do We Learn From Graduate
Admissions Committees?: A Multiple-Rater, Latent Variable Model, with
Incomplete Discrete and Continuous Indicators.&quot;  <em>Political
Analysis</em>.  12(4):400-424.  </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(admit)
summary(admit)
## ordered probit model
op1 &lt;- MASS::polr(score ~ gre.quant + gre.verbal + ap + pt + female,
            Hess=TRUE,
            data=admit,
            method="probit")
summary(op1)
hitmiss(op1)
logLik(op1)
pR2(op1)   
</code></pre>

<hr>
<h2 id='AustralianElectionPolling'>
Political opinion polls in Australia, 2004-07
</h2><span id='topic+AustralianElectionPolling'></span>

<h3>Description</h3>

<p>The results of 239 published opinion polls measuring vote intentions (1st preference vote intention in a House of Representatives election) between the 2004 and 2007 Australian Federal elections, from 4 survey houses.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(AustralianElectionPolling)</code></pre>


<h3>Format</h3>

<p>A data frame with 239 observations on the following 14 variables.
</p>

<dl>
<dt><code>ALP</code></dt><dd><p>a numeric vector, percentage of respondents reported as intending to vote for the Australian Labor Party</p>
</dd>
<dt><code>Lib</code></dt><dd><p>a numeric vector, percentage of respondents reported as intending to vote for the Liberal Party</p>
</dd>
<dt><code>Nat</code></dt><dd><p>a numeric vector, percentage of respondents reported as intending to vote for the National Party</p>
</dd>
<dt><code>Green</code></dt><dd><p>a numeric vector, percentage of respondents reported as intending to vote for the Greens</p>
</dd>
<dt><code>FamilyFirst</code></dt><dd><p>a numeric vector, percentage of respondents reported as intending to vote for the Family First party</p>
</dd>
<dt><code>Dems</code></dt><dd><p>a numeric vector, percentage of respondents reported as intending to vote for the Australian Democrats</p>
</dd>
<dt><code>OneNation</code></dt><dd><p>a numeric vector, percentage of respondents reported as intending to vote for One Nation</p>
</dd>
<dt><code>DK</code></dt><dd><p>a numeric vector, percentage of respondents reported as expressing no preference or a &ldquo;don't know&rdquo; response</p>
</dd>
<dt><code>sampleSize</code></dt><dd><p>a numeric vector, reported sample size of the poll</p>
</dd>
<dt><code>org</code></dt><dd><p>a factor with levels <code>Galaxy</code>, <code>Morgan, F2F</code>, <code>Newspoll</code>, <code>Nielsen</code> and <code>Morgan, Phone</code>, indicating the survey house and/or mode of the poll</p>
</dd>
<dt><code>startDate</code></dt><dd><p>a Date, reported start of the field period</p>
</dd>
<dt><code>endDate</code></dt><dd><p>a Date, reported end of the field period</p>
</dd>
<dt><code>source</code></dt><dd><p>a character vector, source of the poll report</p>
</dd>
<dt><code>remark</code></dt><dd><p>a character vector, remarks noted by author and/or research assistant coders</p>
</dd>
</dl>



<h3>Details</h3>

<p>Morgan uses two modes: phone and face-to-face.  
</p>
<p>The 2004 Australian election was on October 9; the ALP won 37.6% of the 1st preferences cast in elections for the House of Representatives.  The ALP won the 2007 election (November 24) with 43.4% of 1st preferences.  
</p>
<p>The ALP changed leaders twice in the 2004-07 inter-election period spanned by these data: (1) Mark Latham resigned the ALP leadership on January 18 2005 and was replaced by Kim Beazley; (2) Beazley lost the ALP leadership to Kevin Rudd on December 4, 2006.  
</p>
<p>The then Prime Minister, John Howard, announced the November 2007 election on October 14, 2007.     
</p>


<h3>Source</h3>

<p>See the <code>source</code> variable.  Andrea Abel assisted with the data collection.
</p>


<h3>References</h3>

<p>Jackman, Simon. 2009.  <em>Bayesian Analysis for the Social Sciences</em>.  Wiley: Hoboken, New Jersey.  Example 9.3.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(AustralianElectionPolling)
if(require(lattice)) {
    lattice::xyplot(ALP ~ startDate | org, 
       data=AustralianElectionPolling,
       layout=c(1,5),
       type="b",
       xlab="Start Date",
       ylab="ALP")
}

## test for house effects
y &lt;- AustralianElectionPolling$ALP/100
v &lt;- y*(1-y)/AustralianElectionPolling$sampleSize
w &lt;- 1/v
m1 &lt;- mgcv::gam(y ~ s(as.numeric(startDate)),
          weight=w,	      
          data=AustralianElectionPolling)
m2 &lt;- update(m1, ~ . + org)
anova(m1,m2)
</code></pre>

<hr>
<h2 id='AustralianElections'>elections to Australian House of
Representatives, 1949-2016</h2><span id='topic+AustralianElections'></span>

<h3>Description</h3>

<p>Aggregate data on the 24 elections to Australia's House of
Representatives, 1949 to 2016. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(AustralianElections)</code></pre>


<h3>Format</h3>

<p>A data frame with the following variables:	
</p>

<dl>
<dt><code>date</code></dt><dd><p>date of election, stored using the
<code><a href="base.html#topic+Date">Date</a></code> class</p>
</dd>
<dt><code>Seats</code></dt><dd><p>numeric, number of seats in the House of
Representatives</p>
</dd> 
<dt><code>Uncontested</code></dt><dd><p>numeric, number of uncontested seats</p>
</dd>
<dt><code>ALPSeats</code></dt><dd><p>numeric, number of seats won by the
Australian Labor Party</p>
</dd>
<dt><code>LPSeats</code></dt><dd><p>numeric, number of seats won by the Liberal Party</p>
</dd> 
<dt><code>NPSeats</code></dt><dd><p>numeric, number of seats won by the National
Party (previously known as the Country Party)</p>
</dd>
<dt><code>OtherSeats</code></dt><dd><p>numeric, number of seats won by other
parties and/or independent candidates</p>
</dd>
<dt><code>ALP</code></dt><dd><p>numeric, percentage of first preference votes cast for
Australian Labor Party candidates</p>
</dd>
<dt><code>ALP2PP</code></dt><dd><p>numeric, percentage of the two-party preferred
vote won by Australian Labor Party candidates</p>
</dd>
<dt><code>LP</code></dt><dd><p>numeric, percent of first preference votes cast for
Liberal Party candidates</p>
</dd>
<dt><code>NP</code></dt><dd><p>numeric, percent of first preference votes cast for
National Party (Country Party) candidates</p>
</dd>
<dt><code>DLP</code></dt><dd><p>numeric, percent of first preference votes cast
for Democratic Labor Party candidates</p>
</dd>
<dt><code>Dem</code></dt><dd><p>numeric, percent of first preference votes cast
for Australian Democrat candidates</p>
</dd>
<dt><code>Green</code></dt><dd><p>numeric, percent of first preference votes cast
for Green Party candidates</p>
</dd>
<dt><code>Hanson</code></dt><dd><p>numeric, percent of first preference votes cast
for candidates from Pauline Hanson's One Nation party</p>
</dd>
<dt><code>Com</code></dt><dd><p>numeric, percent of first preference votes cast
for Communist Party candidates</p>
</dd>
<dt><code>AP</code></dt><dd><p>numeric, percent of first preference votes cast for
Australia Party candidates</p>
</dd>
<dt><code>Informal</code></dt><dd><p>numeric, percent of ballots cast that are
spoiled, blank, or otherwise uncountable (usually because of
errors in enumerating preferences)</p>
</dd>
<dt><code>Turnout</code></dt><dd><p>numeric, percent of enrolled voters recorded
as having turned out to vote (Australia has compulsory voting)</p>
</dd>
</dl>



<h3>Note</h3>

<p>The Liberal National Party of Queensland formed in 2008 after a merger of the Liberal Party and the National Party. In all elections following 2008, they have been categorised under <code>LP</code>.</p>


<h3>Source</h3>

<p>Australian Electoral Commission. <a href="https://www.aec.gov.au">https://www.aec.gov.au</a>.
</p>


<h3>References</h3>

<p>Jackman, Simon. 2009. <em>Bayesian Analysis for the Social Sciences</em>.  Wiley: Hoboken, New Jersey.  Example 3.5.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(AustralianElections)
attach(AustralianElections)
alpSeatShare &lt;- ALPSeats/Seats
alpVoteShare &lt;- ALP2PP/100

## log-odds transforms
x &lt;- log(alpVoteShare/(1-alpVoteShare))
y &lt;- log(alpSeatShare/(1-alpSeatShare))

ols &lt;- lm(y~x)   ## Tufte-style seats-votes regression

xseq &lt;- seq(-4.5,4.5,length=500)
yhat &lt;- coef(ols)[1] + coef(ols)[2]*xseq
yhat &lt;- exp(yhat)/(1+exp(yhat))
xseq &lt;- exp(xseq)/(1+exp(xseq))

## seats vote curve
plot(x=alpVoteShare,
     y=alpSeatShare,
     xlab="ALP Vote Share",
     ylab="ALP Seat Share")
lines(xseq,yhat,lwd=2)
abline(h=.5,lty=2)
abline(v=.5,lty=2)
</code></pre>

<hr>
<h2 id='betaHPD'>compute and optionally plot beta HDRs</h2><span id='topic+betaHPD'></span>

<h3>Description</h3>

<p>Compute and optionally plot highest density regions for the Beta
distribution.</p>


<h3>Usage</h3>

<pre><code class='language-R'>   betaHPD(alpha,beta,p=.95,plot=FALSE,xlim=NULL,debug=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="betaHPD_+3A_alpha">alpha</code></td>
<td>
<p>scalar, first shape parameter of the Beta density.  Must be
greater than 1, see details</p>
</td></tr>
<tr><td><code id="betaHPD_+3A_beta">beta</code></td>
<td>
<p>scalar, second shape parameter of the Beta density.  Must be
greater than 1, see details</p>
</td></tr>
<tr><td><code id="betaHPD_+3A_p">p</code></td>
<td>
<p>scalar, content of HPD, must lie between 0 and 1</p>
</td></tr>
<tr><td><code id="betaHPD_+3A_plot">plot</code></td>
<td>
<p>logical flag, if <code>TRUE</code> then plot the density and
show the HDR</p>
</td></tr>
<tr><td><code id="betaHPD_+3A_xlim">xlim</code></td>
<td>
<p>numeric vector of length 2, the limits of the density's
support to show when plotting; the default is <code>NULL</code>, in which
case the function will confine plotting to where the density is
non-negligible</p>
</td></tr> 
<tr><td><code id="betaHPD_+3A_debug">debug</code></td>
<td>
<p>logical flag, if <code>TRUE</code> produce messages to the
console</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Beta density arises frequently in Bayesian models of
binary events, rates, and proportions, which take on values in the
open unit interval.  For instance, the Beta density is a conjugate prior
for the unknown success probability in binomial trials.  With shape
parameters <code class="reqn">\alpha &gt; 1</code> and <code class="reqn">\beta &gt; 1</code>, the Beta density is
unimodal.
</p>
<p>In general, suppose <code class="reqn">\theta \in \Theta \subseteq R^k</code>
is a random variable with density <code class="reqn">f(\theta)</code>.  A highest
density region (HDR) of <code class="reqn">f(\theta)</code> with content <code class="reqn">p \in
  (0,1]</code> is a set <code class="reqn">\mathcal{Q} \subseteq \Theta</code> with the
following properties:
</p>
<p style="text-align: center;"><code class="reqn">\int_\mathcal{Q} f(\theta) d\theta = p</code>
</p>

<p>and
</p>
<p style="text-align: center;"><code class="reqn">f(\theta) &gt; f(\theta^*) \, \forall\
    \theta \in \mathcal{Q},
    \theta^* \not\in \mathcal{Q}.</code>
</p>

<p>For a unimodal
Beta density (the class of Beta densities handled by this function),
a HDR of content <code class="reqn">0 &lt; p &lt; 1</code> is simply an interval <code class="reqn">\mathcal{Q} \in (0,1)</code>.
</p>
<p>This function uses numerical methods to solve for the
end points of a HDR for a Beta density with user-specified shape
parameters, via repeated calls to the functions <code><a href="stats.html#topic+dbeta">dbeta</a></code>,
<code><a href="stats.html#topic+pbeta">pbeta</a></code> and <code><a href="stats.html#topic+qbeta">qbeta</a></code>. The function
<code><a href="stats.html#topic+optimize">optimize</a></code> is used to find points <code class="reqn">v</code> and <code class="reqn">w</code>
such that </p>
<p style="text-align: center;"><code class="reqn">f(v) = f(w)</code>
</p>
<p> subject to the constraint
</p>
<p style="text-align: center;"><code class="reqn">\int_v^w f(\theta; \alpha, \beta) d\theta = p,</code>
</p>

<p>where <code class="reqn">f(\theta; \alpha, \beta)</code> is a Beta density with shape
parameters <code class="reqn">\alpha</code> and <code class="reqn">\beta</code>. 
</p>
<p>In the special case of <code class="reqn">\alpha = \beta &gt; 1</code>, the end points
of a HDR  with content <code class="reqn">p</code> are given by the <code class="reqn">(1 \pm p)/2</code>
quantiles of the Beta density, and are computed with the
<code><a href="stats.html#topic+qbeta">qbeta</a></code> function. 
</p>
<p>Again note that the function will only compute a HDR for a unimodal
Beta density, and exit with an error if <code>alpha&lt;=1 | beta &lt;=1</code>.
Note that the uniform density results with <code class="reqn">\alpha = \beta = 1</code>,
which does not have a unique HDR with content <code class="reqn">0 &lt; p &lt;
  1</code>.  With shape parameters <code class="reqn">\alpha&lt;1</code> and <code class="reqn">\beta&gt;1</code> (or
vice-versa, respectively), the Beta density is infinite at 0 (or 1,
respectively), but still integrates to one, and so a HDR is still
well-defined (but not implemented here, at least not yet).
Similarly, with <code class="reqn">0 &lt; \alpha, \beta &lt; 1</code> the Beta density is
infinite at both 0 and 1, but integrates to one, and again a HDR of
content <code class="reqn">p&lt;1</code> is well-defined in this case, but will be a set of
two disjoint intervals (again, at present, this function does not
cover this case).
</p>


<h3>Value</h3>

<p>If the numerical optimization is successful an vector of length 2,
containing <code class="reqn">v</code> and <code class="reqn">w</code>, defined above.    If the optimization
fails for whatever reason, a vector of <code>NAs</code> is returned.
</p>
<p>The function will also produce a plot of the density with area under
the density supported by the HDR shaded, if the user calls the
function with <code>plot=TRUE</code>; the plot will appear on the current
graphics device.
</p>
<p>Debugging messages are printed to the console if the <code>debug</code>
logical flag is set to <code>TRUE</code>.  
</p>


<h3>Author(s)</h3>

<p>Simon Jackman <a href="mailto:simon.jackman@sydney.edu.au">simon.jackman@sydney.edu.au</a>.  Thanks to John
Bullock who discovered a bug in an earlier version.</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+pbeta">pbeta</a></code>, <code><a href="stats.html#topic+qbeta">qbeta</a></code>,
<code><a href="stats.html#topic+dbeta">dbeta</a></code>, <code><a href="stats.html#topic+uniroot">uniroot</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>betaHPD(4,5)
betaHPD(2,120)
betaHPD(120,45,p=.75,xlim=c(0,1))
</code></pre>

<hr>
<h2 id='bioChemists'>article production by graduate students in biochemistry Ph.D. programs</h2><span id='topic+bioChemists'></span>

<h3>Description</h3>

<p>A sample of 915 biochemistry graduate students.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(bioChemists)</code></pre>


<h3>Format</h3>


<dl>
<dt><code>art</code></dt><dd><p>count of articles produced during last 3 years of Ph.D.</p>
</dd>
<dt><code>fem</code></dt><dd><p>factor indicating gender of student, with levels Men and Women</p>
</dd>
<dt><code>mar</code></dt><dd><p>factor indicating marital status of student, with levels
Single and Married</p>
</dd>
<dt><code>kid5</code></dt><dd><p>number of children aged 5 or younger</p>
</dd>
<dt><code>phd</code></dt><dd><p>prestige of Ph.D. department</p>
</dd>
<dt><code>ment</code></dt><dd><p>count of articles produced by Ph.D. mentor during last 3 years</p>
</dd>
</dl>



<h3>References</h3>

<p>Long, J. Scott. 1990.  The origins of sex differences in
science. <em>Social Forces</em>. 68(3):1297-1316.
</p>
<p>Long, J. Scott. 1997.  <em>Regression Models for Categorical and
Limited Dependent Variables</em>. Thousand Oaks, California: Sage.
</p>

<hr>
<h2 id='ca2006'>California Congressional Districts in 2006</h2><span id='topic+ca2006'></span>

<h3>Description</h3>

<p>Election returns and identifying information, California's 53
congressional districts in the 2006 Congressional elections.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(ca2006)</code></pre>


<h3>Format</h3>

<p>A data frame with 53 observations on the following 11 variables.
</p>

<dl>
<dt><code>district</code></dt><dd><p>numeric, number of Congressional district</p>
</dd>
<dt><code>D</code></dt><dd><p>numeric, number of votes for the Democratic candidate</p>
</dd>
<dt><code>R</code></dt><dd><p>numeric, votes for the Republican candidate</p>
</dd>
<dt><code>Other</code></dt><dd><p>numeric, votes for other candidates</p>
</dd>
<dt><code>IncParty</code></dt><dd><p>character, party of the incumbent (or retiring member),
<code>D</code> or <code>R</code></p>
</dd>
<dt><code>IncName</code></dt><dd><p>character, last name of the incumbent, character
<code>NA</code> if no incumbent running</p>
</dd>
<dt><code>open</code></dt><dd><p>logical, <code>TRUE</code> if no incumbent running</p>
</dd>
<dt><code>contested</code></dt><dd><p>logical, <code>TRUE</code> if both major parties
ran candidates</p>
</dd>
<dt><code>Bush2004</code></dt><dd><p>numeric, votes for George W. Bush (R) in the district in
the 2004 presidential election</p>
</dd>
<dt><code>Kerry2004</code></dt><dd><p>numeric, votes for John Kerry (D) in 2004</p>
</dd>
<dt><code>Other2004</code></dt><dd><p>numeric votes for other candidates in 2004</p>
</dd>
<dt><code>Bush2000</code></dt><dd><p>numeric, votes for George W. Bush in 2000</p>
</dd>
<dt><code>Gore2000</code></dt><dd><p>numeric, votes for Al Gore (D) in 2000</p>
</dd>
</dl>



<h3>Source</h3>

<p>2006 data from the California Secretary of State's web site,
<a href="https://www.sos.ca.gov/elections/prior-elections/statewide-election-results/general-election-november-7-2006/statement-vote">https://www.sos.ca.gov/elections/prior-elections/statewide-election-results/general-election-november-7-2006/statement-vote</a>. 

2004 and 2000 presidential vote in congressional districts from the 2006 <em>Almanac of American Politics</em>.
</p>
<p>Thanks to Arthur Aguirre for the updated links, above.
</p>


<h3>References</h3>

<p>Michael Baraon and Richard E. Cohen.  2006. <em>The Almanac of American
Politics, 2006.</em> National Journal Group: Washington, D.C.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ca2006)

## 2006 CA congressional vote against 2004 pvote
y &lt;- ca2006$D/(ca2006$D+ca2006$R)
x &lt;- ca2006$Kerry2004/(ca2006$Kerry2004+ca2006$Bush2004)

pch &lt;- rep(19,length(y))
pch[ca2006$open] &lt;- 1
col &lt;- rep("black",length(y))
col[11] &lt;- "red"    ## Pembo (R) loses to McNerney (D)
plot(y~x,pch=pch,
     col=col,
     xlim=range(x,y,na.rm=TRUE),
     ylim=range(x,y,na.rm=TRUE),
     xlab="Kerry Two-Party Vote, 2004",
     ylab="Democratic Two-Party Vote Share, 2006")
abline(0,1)
abline(h=.5,lty=2)
abline(v=.5,lty=2)
legend(x="topleft",
       bty="n",
       col=c("red","black","black"),
       pch=c(19,19,1),
       legend=c("Seat Changing Hands",
         "Seat Retained by Incumbent Party",
         "Open Seat (no incumbent running)")
       )
</code></pre>

<hr>
<h2 id='computeMargins'>add information about voting outcomes to a rollcall
object</h2><span id='topic+computeMargins'></span>

<h3>Description</h3>

<p>Add summaries of each roll call vote to a <code><a href="#topic+rollcall">rollcall</a></code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>computeMargins(object, dropList = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="computeMargins_+3A_object">object</code></td>
<td>
<p>an object of class <code><a href="#topic+rollcall">rollcall</a></code></p>
</td></tr>
<tr><td><code id="computeMargins_+3A_droplist">dropList</code></td>
<td>
<p>a <code><a href="base.html#topic+list">list</a></code> (or <code><a href="base.html#topic+alist">alist</a></code>)
listing voting decisions, legislators and/or votes to be dropped
from the analysis; see <code><a href="#topic+dropRollCall">dropRollCall</a></code> for details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p> The subsetting implied by the <code>dropList</code> is first applied
to the <code><a href="#topic+rollcall">rollcall</a></code> object, via <code><a href="#topic+dropRollCall">dropRollCall</a></code>.
Then, for each remaining roll call vote, the number of legislators
voting &ldquo;Yea&rdquo;, &ldquo;Nay&rdquo;, and not voting are computed, using
the encoding information in the <code>codes</code> component of the
<code><a href="#topic+rollcall">rollcall</a></code> object via the <code><a href="#topic+convertCodes">convertCodes</a></code>
function.  The matrix of vote counts are added to the <code><a href="#topic+rollcall">rollcall</a></code>
object as a component <code>voteMargins</code>.
</p>


<h3>Value</h3>

<p>An object of class <code><a href="#topic+rollcall">rollcall</a></code>, with a component
<code>voteMargins</code> that is a matrix with four columns: 
</p>
<table>
<tr><td><code>Yea</code></td>
<td>
<p>number of legislators voting &ldquo;Yea&rdquo;</p>
</td></tr>
<tr><td><code>Nay</code></td>
<td>
<p>number of legislators voting &ldquo;Nay&rdquo;</p>
</td></tr>
<tr><td><code>NA</code></td>
<td>
<p>number of legislators not voting &ldquo;Nay&rdquo;</p>
</td></tr>
<tr><td><code>Min</code></td>
<td>
<p>the number of legislators voting on the losing side of the
roll call</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Simon Jackman <a href="mailto:simon.jackman@sydney.edu.au">simon.jackman@sydney.edu.au</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+dropRollCall">dropRollCall</a></code> on specifying a <code>dropList</code>.
The vote-specific marginals produced by this function are used by as
<code><a href="#topic+dropRollCall">dropRollCall</a></code>, <code><a href="#topic+summary.ideal">summary.ideal</a></code> and
<code><a href="#topic+predict.ideal">predict.ideal</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(s109)
tmp &lt;- computeMargins(s109)
dim(tmp$voteMargins)   ## 645 by 4

tmp &lt;- computeMargins(s109,
                     dropList=list(codes="notInLegis",lop=0))
dim(tmp$voteMargins)   ## 544 by 4
</code></pre>

<hr>
<h2 id='constrain.items'>constrain item parameters in analysis of roll call data</h2><span id='topic+constrain.items'></span>

<h3>Description</h3>

<p>Sets constraints on specified item parameters in Bayesian analysis of
roll call data by generating appropriate priors and start values for
Markov chain Monte Carlo iterations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>constrain.items(obj, dropList = list(codes = "notInLegis", lop = 0),
                x, d = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="constrain.items_+3A_obj">obj</code></td>
<td>
<p>an object of class <code><a href="#topic+rollcall">rollcall</a></code>.</p>
</td></tr>
<tr><td><code id="constrain.items_+3A_droplist">dropList</code></td>
<td>
<p>a <code><a href="base.html#topic+list">list</a></code> (or <code><a href="base.html#topic+alist">alist</a></code>)
indicating which voting decisions, legislators and/or roll calls are
to be excluded from the subsequent analysis; see
<code><a href="#topic+dropRollCall">dropRollCall</a></code> for details.</p>
</td></tr>
<tr><td><code id="constrain.items_+3A_x">x</code></td>
<td>
<p>a <code><a href="base.html#topic+list">list</a></code> containing elements with names matching
votes found in <code>dimnames(object$votes)[[2]]</code> (but after any
subsetting specified by <code>dropList</code>).  Each component of the
list must be a vector containing <code>d</code> elements, specifying the
value to which the item discrimination parameters should be
constrained, in each of the <code>d</code> dimensions.  The intercept or
item difficultly parameter will not be constrained.</p>
</td></tr>
<tr><td><code id="constrain.items_+3A_d">d</code></td>
<td>
<p>numeric, positive integer, the number of dimensions for which
to set up the priors and start values.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>constrain.items</code> and its cousin,
<code><a href="#topic+constrain.legis">constrain.legis</a></code> are usefully thought of as
&ldquo;pre-processor&rdquo; functions, generating priors <em>and</em> start
values for both the item parameters and the ideal points.  For the
items specified in <code>x</code>, the prior mean for each dimension is set
to the value given in <code>x</code>, and the prior precision for each
dimension is set to <code>1e12</code> (i.e., a near-degenerate
&ldquo;spike&rdquo; prior).  For the other items, the priors are set to a
mean of 0 and precision 0.01.  All of the ideal points are given
normal priors with mean 0, precision 1.
</p>
<p>Start values are also generated for both ideal points and item
parameters.  The start values for the items specified in <code>x</code> are
set to the values specified in <code>x</code>.  The list resulting from
<code>constrain.items</code> can then be given as the value for the
parameters <code>priors</code> and <code>startvals</code> when <code><a href="#topic+ideal">ideal</a></code>
is run. The user is responsible for ensuring that a sufficient number
of items are constrained such that when <code><a href="#topic+ideal">ideal</a></code> is run,
the model parameters are identified.
</p>
<p><code><a href="#topic+dropRollCall">dropRollCall</a></code> is first called to generate the desired
roll call matrix.  The entries of the roll call matrix are mapped to
<code>c(0,1,NA)</code> using the <code>codes</code> component of the
<code><a href="#topic+rollcall">rollcall</a></code> <code>object</code>.  See the discussion in the
documentation of <code><a href="#topic+ideal">ideal</a></code> for details on the generation of
start values.
</p>


<h3>Value</h3>

<p>a list with elements:
</p>
<table>
<tr><td><code>xp</code></td>
<td>
<p>prior means for ideal points.  A matrix of dimensions number
of legislators in <code>obj</code> by <code>d</code>.</p>
</td></tr>
<tr><td><code>xpv</code></td>
<td>
<p>prior meansprecisions for ideal points.  A matrix of dimensions number
of legislators in <code>obj</code> by <code>d</code>.</p>
</td></tr>
<tr><td><code>bp</code></td>
<td>
<p>prior means for item parameters.  A matrix of dimensions number
of items or votes in <code>obj</code> by <code>d+1</code>.</p>
</td></tr>
<tr><td><code>bpv</code></td>
<td>
<p>prior meansprecisions for item parameters.  A matrix of dimensions number
of items or votes in <code>obj</code> by <code>d+1</code>.</p>
</td></tr>
<tr><td><code>xstart</code></td>
<td>
<p>start values for ideal points.  A matrix of dimensions number
of legislators in <code>obj</code> by <code>d</code>.</p>
</td></tr>
<tr><td><code>bstart</code></td>
<td>
<p>start values for ideal points.  A matrix of dimensions number
of items or votes in <code>obj</code> by <code>d+1</code>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+rollcall">rollcall</a></code>, <code><a href="#topic+ideal">ideal</a></code>,
<code><a href="#topic+constrain.legis">constrain.legis</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(s109)
f &lt;- system.file("extdata","id1.rda",package="pscl")
load(f)
id1sum &lt;- summary(id1,include.beta=TRUE)
suspect1 &lt;- id1sum$bSig[[1]]=="95
close60 &lt;- id1sum$bResults[[1]][,"Yea"] &lt; 60
close40 &lt;- id1sum$bResults[[1]][,"Yea"] &gt; 40
suspect &lt;- suspect1 &amp; close60 &amp; close40
id1sum$bResults[[1]][suspect,]
suspectVotes &lt;- dimnames(id1sum$bResults[[1]][suspect,])[[1]]


## constraints on 2d model,
## close rollcall poorly fit by 1d model
## serves as reference item for 2nd dimension

cl &lt;- constrain.items(s109,
                      x=list("2-150"=c(0,7),
                        "2-169"=c(7,0)),
                      d=2)

id1Constrained &lt;- ideal(s109,
                        d=2,
                        meanzero=TRUE,
                        priors=cl,
                        startvals=cl,
                        maxiter=1e5,
                        burnin=1e3,
                        thin=1e2)
summary(id1Constrained,include.beta=TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='constrain.legis'>constrain legislators' ideal points in analysis of roll call data</h2><span id='topic+constrain.legis'></span>

<h3>Description</h3>

<p>Sets constraints on specified legislators for ideal
point estimation by generating appropriate priors and start values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>constrain.legis(obj, dropList = list(codes = "notInLegis", lop = 0),
                 x, d = 1)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="constrain.legis_+3A_obj">obj</code></td>
<td>
<p>an object of class <code><a href="#topic+rollcall">rollcall</a></code>.</p>
</td></tr>
<tr><td><code id="constrain.legis_+3A_droplist">dropList</code></td>
<td>
<p>a <code><a href="base.html#topic+list">list</a></code> (or <code><a href="base.html#topic+alist">alist</a></code>)
indicating which voting decisions, legislators and/or roll calls are
to be excluded from the subsequent analysis; see
<code><a href="#topic+dropRollCall">dropRollCall</a></code> for details.</p>
</td></tr>
<tr><td><code id="constrain.legis_+3A_x">x</code></td>
<td>
<p>a <code><a href="base.html#topic+list">list</a></code> containing elements with names partially
matching legislators found in <code>dimnames(object$votes)[[1]]</code> (but after
any sub-setting specified by <code>dropList</code>).  Each element must be a
vector containing <code>d</code> elements, specifying the value to which
the ideal point should be constrained in each of <code>d</code>
dimensions. <code>x</code> must have at least <code>d+1</code> components; i.e.,
supplying a necessary (but not sufficient) set of constraints for
global identification of the parameters of a <code>d</code>-dimensional
item-response model, see Details.</p>
</td></tr>
<tr><td><code id="constrain.legis_+3A_d">d</code></td>
<td>
<p>the number of dimensions for which to set up the priors and
start values.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>constrain.items</code> and its cousin,
<code><a href="#topic+constrain.legis">constrain.legis</a></code> are usefully thought of as
&ldquo;pre-processor&rdquo; functions, implementing identification
constraints for the ideal point model by generating priors <em>and</em> start
values for both the item parameters and the ideal points.
</p>
<p>For the legislators specified in <code>x</code>, the prior mean for each
dimension is set to the specified value and the prior precision for
each dimension is set to <code>1e12</code> (i.e., a near-degenerate
&ldquo;spike&rdquo; prior, and, for all practical purposes, constraining
that parameter to a fixed value).  For the other legislators, the
priors on their ideal points are set to a mean of 0 and a small
precision of .01, corresponding to a prior variance of 100, or a prior
95 percent confidence interval of -20 to 20.  All of the item
parameter priors are set to mean 0, precision 0.01.
</p>
<p>Start values are also generated for both ideal points and item
parameters.  The start values for the legislators named in
<code>x</code> are set to the values specified in <code>x</code>.  The list
resulting from <code>constrain.legis</code> can then be given as the value
for the parameters <code>priors</code> and <code>startvals</code> when
<code><a href="#topic+ideal">ideal</a></code> is run. <code>constrain.legis</code> requires that
<code>d+1</code> constraints be specified; if the constrained ideal points
points are linearly independent, then the parameters of the
item-response model are (at least locally) identified.  For instance,
when fitting a 1 dimensional model, constraining the ideal points of
two legislators is sufficient to globally identify the model
parameters.
</p>
<p><code><a href="#topic+dropRollCall">dropRollCall</a></code> is first called to generate the desired
roll call matrix.  The entries of the roll call matrix are mapped to
<code>c(0,1,NA)</code> using the <code>codes</code> component of the
<code><a href="#topic+rollcall">rollcall</a></code> <code>object</code>.  See the discussion in the
documentation of <code><a href="#topic+ideal">ideal</a></code> for details on the generation of
start values.
</p>


<h3>Value</h3>

<p> a list with elements:
</p>
<table>
<tr><td><code>xp</code></td>
<td>
<p>prior means for ideal points.  A matrix of dimensions number
of legislators in <code>rc</code> by <code>d</code>.</p>
</td></tr>
<tr><td><code>xpv</code></td>
<td>
<p>prior meansprecisions for ideal points.  A matrix of
dimensions number of legislators in <code>rc</code> by <code>d</code>.</p>
</td></tr>
<tr><td><code>bp</code></td>
<td>
<p>prior means for item parameters.  A matrix of
dimensions number of items or votes in <code>rc</code> by <code>d+1</code>.</p>
</td></tr>
<tr><td><code>bpv</code></td>
<td>
<p>prior meansprecisions for item parameters.  A matrix of
dimensions number of items or votes in <code>rc</code> by <code>d+1</code>.</p>
</td></tr>
<tr><td><code>x</code></td>
<td>
<p>start values for ideal points.  A matrix of dimensions
number of legislators in <code>rc</code> by <code>d</code>.</p>
</td></tr>
<tr><td><code>b</code></td>
<td>
<p>start values for ideal points.  A matrix of dimensions
number of items or votes in <code>rc</code> by <code>d+1</code>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+rollcall">rollcall</a></code>, <code><a href="#topic+ideal">ideal</a></code>,
<code><a href="#topic+constrain.items">constrain.items</a></code>.
See <code><a href="base.html#topic+pmatch">pmatch</a></code> on how supplied names are matched against the
names in the <code><a href="#topic+rollcall">rollcall</a></code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(s109)
cl &lt;- constrain.legis(s109,
                      x=list("KENNEDY"=-1,
                        "ENZI"=1),
                      d=1)

## Not run: 
## too long for examples
id1Constrained &lt;- ideal(s109,
                       d=1,
                       priors=cl,      ## use cl
                       startvals=cl,   ## use cl
                       maxiter=5000,
                       burnin=500,
                       thin=25)
summary(id1Constrained)

cl2 &lt;- constrain.legis(s109,
                       x=list("KENNEDY"=c(-1,0),
                         "ENZI"=c(1,0),
                         "CHAFEE"=c(0,-.5)),
                       d=2)


id2Constrained &lt;- ideal(s109,
                        d=2,
                        priors=cl2,      ## priors (w constraints)
                        startvals=cl2,   ## start value (w constraints)
                        store.item=TRUE,
                        maxiter=5000,
                        burnin=500,
                        thin=25)
summary(id2Constrained,include.items=TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='convertCodes'>convert entries in a rollcall matrix to binary form</h2><span id='topic+convertCodes'></span>

<h3>Description</h3>

<p>Convert roll call matrix to binary form using encoding information.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convertCodes(object, codes = object$codes)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="convertCodes_+3A_object">object</code></td>
<td>
<p><code><a href="#topic+rollcall">rollcall</a></code> object</p>
</td></tr>
<tr><td><code id="convertCodes_+3A_codes">codes</code></td>
<td>
<p>list, mapping entries in the <code>votes</code> component of
<code>rollcall</code> object to 0 (&lsquo;Nay&rsquo;), 1 (&lsquo;Yea&rsquo;) and
<code>NA</code> (missing, abstentions, etc). Defaults to the <code>codes</code>
component of the <code>rollcall</code> object.</p>
</td></tr> 
</table>


<h3>Details</h3>

<p>See <code><a href="#topic+rollcall">rollcall</a></code> for details on the form of the
<code>codes</code> list.
</p>


<h3>Value</h3>

<p>a <code><a href="base.html#topic+matrix">matrix</a></code> with dimensions equal to the dimensions of
the <code>votes</code> component of the <code>rollcall</code> object.</p>


<h3>Note</h3>

<p>Any entries in the <code>votes</code> matrix that can
not be mapped into <code>c(0,1,NA)</code> using the information in
<code>codes</code> are mapped to <code>NA</code>, with an informative message
sent to the console.
</p>


<h3>Author(s)</h3>

<p>Simon Jackman <a href="mailto:simon.jackman@sydney.edu.au">simon.jackman@sydney.edu.au</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+rollcall">rollcall</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>  data(s109)
  mat &lt;- convertCodes(s109)
  table(mat,exclude=NULL)
</code></pre>

<hr>
<h2 id='dropRollCall'>drop user-specified elements from a rollcall object</h2><span id='topic+dropRollCall'></span>

<h3>Description</h3>

<p>Drop user-specified elements of rollcall object, returning a roll
call object. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dropRollCall(object, dropList,debug=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dropRollCall_+3A_object">object</code></td>
<td>
<p>an object of class <code><a href="#topic+rollcall">rollcall</a></code></p>
</td></tr>
<tr><td><code id="dropRollCall_+3A_droplist">dropList</code></td>
<td>
<p>a <code><a href="base.html#topic+list">list</a></code> (or <code><a href="base.html#topic+alist">alist</a></code>) with
some (or all) of the following components:
</p>

<dl>
<dt>codes</dt><dd><p>character or numeric, possibly a vector.  If
character, it should match the names of <code>object$codes</code>,
indicating the set of entries in <code>object$votes</code> to be set to
<code>NA</code>.  If numeric, then <code>codes</code> indicates the entries in
<code>object$votes</code> that will be set to <code>NA</code>.</p>
</dd>
<dt>lop</dt><dd><p>numeric, non-negative integer, less than number of
legislators represented in <code>object</code>.  Roll calls with <code>lop</code>
or fewer legislators voting in the minority are dropped.</p>
</dd>
<dt>legisMin</dt><dd><p>numeric, non-negative integer, less than
number of roll calls represented in <code>object</code>.  Legislators with
<code>legisMin</code> or fewer votes are dropped.</p>
</dd>
<dt>dropLegis</dt><dd><p>an <code><a href="base.html#topic+expression">expression</a></code> that evaluates to
mode <code>logical</code>, vector of length equal to the number of
legislators represented in <code>object</code>.  The expression is evaluated
in the <code>legis.data</code> component of the rollcall <code>object</code>.
Legislators for whom the expression evaluates to <code>TRUE</code> are
dropped.</p>
</dd>
<dt>dropVotes</dt><dd><p>an <code><a href="base.html#topic+expression">expression</a></code> that evaluates to
mode <code>logical</code>, vector of length equal to the number of
rollcalls represented in <code>object</code>.  The expression is evaluated
in the <code>vote.data</code> component of the rollcall <code>object</code>.
Rollcalls for which the expression evaluates to <code>TRUE</code> are
dropped.</p>
</dd>
</dl>

</td></tr>
<tr><td><code id="dropRollCall_+3A_debug">debug</code></td>
<td>
<p><code>logical</code>, set to <code>TRUE</code> to see messages
printed to the console as inspection and subsetting of the
<code>rollcall</code> object takes place</p>
</td></tr>  
</table>


<h3>Details</h3>

<p>It is often desirable to restrict the analysis of roll call
data in various ways.  For one thing, unanimous votes provide no
information discriminating among legislators: hence, 
summary and analysis should almost always use <code>dropList=list(lop=0)</code>.
See the examples for other possibilities, limited only by the
information supplied in <code>legis.data</code> and <code>votes.data</code>.
</p>


<h3>Value</h3>

<p>An object of class <code><a href="#topic+rollcall">rollcall</a></code> with components modified/added by
the subsetting indicated in the <code>dropList</code>.
</p>


<h3>Note</h3>

<p>With the exception of <code>codes</code>, each component of
<code>dropList</code> generates a vector of mode <code><a href="base.html#topic+logical">logical</a></code>,
either with respect to legislators or votes.  These logical
vectors are then combined element-wise, such that if any one of
the subsetting restrictions is <code>TRUE</code> for a particular
legislator or vote, then that legislator or vote is dropped.  Some
summaries are reported to the console along the way if <code>debug=TRUE</code>.
</p>
<p><code>dropRollCall</code> adds a component
named <code>dropInfo</code> to the <code>rollcall</code> object it returns.  This
component is itself a list containing named components
</p>

<dl>
<dt>legislators</dt><dd><p>a vector of mode <code>logical</code>, with each
element <code>TRUE</code> if the legislator is retained in the returned
<code>rollcall</code> object.</p>
</dd>
<dt>votes</dt><dd><p>a vector of mode <code>logical</code>, with each element
<code>TRUE</code> if the corresponding is retained in the returned
<code>rollcall</code> object.</p>
</dd>
<dt>dropList</dt><dd><p>the <code>dropList</code> supplied as input to
<code>dropRollCall</code>.</p>
</dd> 
</dl>

<p>If the input <code>rollcall</code> object is itself the product of a call to
<code>dropRollCall</code>, the <code>dropInfo</code> component on output is a list
with named components 
</p>

<dl>
<dt>previous</dt><dd><p>the <code>dropInfo</code> component of the input
<code>rollcall</code> object.</p>
</dd>
<dt>new</dt><dd><p>the <code>dropInfo</code> list created by the current call to
<code>dropRollCall</code>.</p>
</dd>
</dl>

<p>Functions like <code>summary.rollcall</code> try to handle this information
sensibly.
</p>
<p>When <code>dropList</code> uses the <code>dropLegis</code> or <code>dropVotes</code>
components then <code>dropList</code> should be constructed via the
<code><a href="base.html#topic+alist">alist</a></code> command; this ensures that the
<code>dropLegis</code> and <code>dropVotes</code> components of
<code>dropList</code> are objects of mode <code><a href="base.html#topic+expression">expression</a></code>, and
<code><a href="base.html#topic+eval">eval</a></code>uated to mode <code><a href="base.html#topic+logical">logical</a></code> in the
<code>legis.data</code> and <code>vote.data</code> <code><a href="base.html#topic+environment">environment</a>s</code> by
the function, if possible (rather than being evaluated immediately in
the environment calling <code>dropRollCall</code> or constructing
<code>dropList</code>).  See the examples.  This is not entirely
satisfactory, and behavior more like the <code>subset</code> argument in
function <code><a href="stats.html#topic+lm">lm</a></code> would be preferable.
</p>


<h3>Author(s)</h3>

<p>Simon Jackman <a href="mailto:simon.jackman@sydney.edu.au">simon.jackman@sydney.edu.au</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+dropUnanimous">dropUnanimous</a></code>, <code><a href="#topic+summary.rollcall">summary.rollcall</a></code>,
<code><a href="#topic+ideal">ideal</a></code>, <code><a href="base.html#topic+alist">alist</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(s109)
s109.working &lt;- dropRollCall(s109,
                             dropList=list(lop=0))
summary(s109.working)

s109.working &lt;- dropRollCall(s109,
                             dropList=list(lop=0,
                               code="notInLegis"))
summary(s109.working)

s109.working &lt;- dropRollCall(s109,
                             dropList=list(lop=3,
                               code="notInLegis"))
summary(s109.working)

## note use of alist, since dropLegis is an expression
dropList &lt;- alist(lop=3,
                 dropLegis=party!="D",
                 code="notInLegis")
s109.working &lt;- dropRollCall(s109,dropList=dropList,debug=TRUE)
summary(s109.working)

s109.working &lt;- dropRollCall(s109.working,dropList=list(legisMin=25))
summary(s109.working)


## Not run: 
## read 102nd House from Poole web site
h102 &lt;- readKH("ftp://voteview.ucsd.edu/dtaord/hou102kh.ord")

## drop President from roll call matrix
h102 &lt;- dropRollCall(h102,
                     dropList=alist(dropLegis=state=="USA"))
summary(h102)

## End(Not run)
</code></pre>

<hr>
<h2 id='dropUnanimous'>drop unanimous votes from rollcall objects and matrices</h2><span id='topic+dropUnanimous'></span>

<h3>Description</h3>

<p>Drop unanimous votes from rollcall objects and rollcall matrices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dropUnanimous(obj, lop = 0)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dropUnanimous_+3A_obj">obj</code></td>
<td>
<p>object, either of class <code><a href="#topic+rollcall">rollcall</a></code> or
<code><a href="base.html#topic+matrix">matrix</a></code></p>
</td></tr> 
<tr><td><code id="dropUnanimous_+3A_lop">lop</code></td>
<td>
<p>numeric, non-negative integer, less than number of
legislators represented in <code>obj</code>.  Roll calls with <code>lop</code>
or fewer legislators voting in the minority are dropped.  Default is
0, meaning that unanimous votes are dropped.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Unanimous votes are the
equivalent of test items that all subjects score &ldquo;correct&rdquo; (or
all subjects scores &ldquo;incorrect&rdquo;); since there is no variation
among the legislators/subjects, these votes/items provide no
information as to latent traits (ideology, preferences, ability).  A
reasonably large number of rollcalls in any contemporary U.S. Congress
are unanimous.
</p>
<p>Specific methods are provided for objects of class
<code><a href="#topic+rollcall">rollcall</a></code> or <code><a href="base.html#topic+matrix">matrix</a></code>.
</p>


<h3>Value</h3>

<p>A <code><a href="#topic+rollcall">rollcall</a></code> object or a <code><a href="base.html#topic+matrix">matrix</a></code> depending on
the class of <code>object</code>.
</p>


<h3>Author(s)</h3>

<p>Simon Jackman <a href="mailto:simon.jackman@sydney.edu.au">simon.jackman@sydney.edu.au</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+dropRollCall">dropRollCall</a></code>,
<code><a href="#topic+rollcall">rollcall</a></code>, <code><a href="#topic+summary.rollcall">summary.rollcall</a></code>, <code><a href="#topic+ideal">ideal</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(s109)
s109.working &lt;- dropUnanimous(s109)
summary(s109.working)
</code></pre>

<hr>
<h2 id='EfronMorris'>Batting Averages for 18 major league baseball players, 1970</h2><span id='topic+EfronMorris'></span>

<h3>Description</h3>

<p>Batting averages for 18 major league baseball players,
first 45 at bats of the 1970 season.</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(EfronMorris)</code></pre>


<h3>Format</h3>


<dl>
<dt><code>name</code></dt><dd><p>character, name of player</p>
</dd>
<dt><code>team</code></dt><dd><p>character, team of player, abbreviated</p>
</dd>
<dt><code>league</code></dt><dd><p>character, National League or American League</p>
</dd>
<dt><code>r</code></dt><dd><p>numeric, hits in 1st 45 at bats</p>
</dd>
<dt><code>y</code></dt><dd><p>numeric, <code>r</code>/45, batting average over 1st
45 at bats</p>
</dd>
<dt><code>n</code></dt><dd><p>numeric, number of at bats, remainder of 1970
season</p>
</dd>
<dt><code>p</code></dt><dd><p>numeric, batting average over remainder of 1970 season</p>
</dd>
</dl>



<h3>Source</h3>

<p>Efron, Bradley and Carl Morris. 1975. Data Analysis Using
Stein's Estimator and Its Generalizations.  <em>Journal of the American
Statistical Association</em>. 70:311-319.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(EfronMorris)
attach(EfronMorris)
plot(p~y,
     xlim=range(p,y),
     ylim=range(p,y),
     xlab="Batting Average, 1st 45 at bats",
     ylab="Batting Average, Remainder of Season")
abline(0,1)
</code></pre>

<hr>
<h2 id='extractRollCallObject'>return the roll call object used in fitting an ideal model</h2><span id='topic+extractRollCallObject'></span>

<h3>Description</h3>

<p>Given a fitted model of class <code><a href="#topic+ideal">ideal</a></code>, return the
<code><a href="#topic+rollcall">rollcall</a></code> object that was used in the model fitting
(i.e., apply all subsetting and recoding implied by the <code>dropList</code>
passed to <code><a href="#topic+ideal">ideal</a></code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extractRollCallObject(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extractRollCallObject_+3A_object">object</code></td>
<td>
<p>an object of class <code><a href="#topic+ideal">ideal</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is used by many post-estimation commands that operate on
objects of class <code><a href="#topic+ideal">ideal</a></code>.  The function inspects the
<code>call</code> attribute of the 
<code><a href="#topic+ideal">ideal</a></code> object, extracting the name of the
<code><a href="#topic+rollcall">rollcall</a></code> object and the <code>dropList</code>, then hands them
over to <code><a href="#topic+dropRollCall">dropRollCall</a></code>.
</p>


<h3>Value</h3>

<p>An object of class <code><a href="#topic+rollcall">rollcall</a></code>
</p>


<h3>Author(s)</h3>

<p>Simon Jackman <a href="mailto:simon.jackman@sydney.edu.au">simon.jackman@sydney.edu.au</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+rollcall">rollcall</a></code>; see <code><a href="#topic+dropRollCall">dropRollCall</a></code> for
details on the form of a <code>dropList</code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(s109)
f = system.file("extdata","id1.rda",package="pscl")
load(f)
tmp &lt;- extractRollCallObject(id1)
summary(tmp)
v &lt;- convertCodes(tmp)         ## roll call matrix per se  
</code></pre>

<hr>
<h2 id='hitmiss'>Table of Actual Outcomes against Predicted Outcomes for discrete
data models</h2><span id='topic+hitmiss'></span><span id='topic+hitmiss.glm'></span>

<h3>Description</h3>

<p> Cross-tabulations of actual outcomes against predicted
outcomes for discrete data models, with summary statistics such as
percent correctly predicted (PCP) under fitted and null models.  For
models with binary responses (generalized linear models with
<code>family=binomial</code>), the user can specific a classification
threshold for the predicted probabilities.  </p>


<h3>Usage</h3>

<pre><code class='language-R'>hitmiss(obj, digits = max(3, getOption("digits") - 3), ...)

## S3 method for class 'glm'
hitmiss(obj,digits=max(3,getOption("digits")-3),
            ...,
            k=.5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hitmiss_+3A_obj">obj</code></td>
<td>
<p>a fitted model object, such as a <code>glm</code> with
<code>family=binomial</code>, a <code>polr</code> model for ordinal responses,
or a <code>multinom</code> model for unordered/multinomial outcomes</p>
</td></tr> 
<tr><td><code id="hitmiss_+3A_digits">digits</code></td>
<td>
<p>number of digits to display in on-screen output</p>
</td></tr>
<tr><td><code id="hitmiss_+3A_...">...</code></td>
<td>
<p>additional arguments passed to or from other functions</p>
</td></tr>
<tr><td><code id="hitmiss_+3A_k">k</code></td>
<td>
<p>classification threshold for binary models</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For models with binary responses, the user can specify a
parameter 0 &lt; <code>k</code> &lt; 1; if the predicted probabilities exceed this
threshold then the model is deemed to have predicted y=1, and
otherwise to have predicted y=0.  Measures like percent correctly
predicted are crude summaries of model fit; the cross-tabulation of
actual against predicted is somewhat more informative, providing a
little more insight as to where the model fits less well.
</p>


<h3>Value</h3>

<p>For <code>hitmiss.glm</code>, a vector of length 3:
</p>
<table>
<tr><td><code>pcp</code></td>
<td>
<p>Percent Correctly Predicted</p>
</td></tr>
<tr><td><code>pcp0</code></td>
<td>
<p>Percent Correctly Predicted among y=0</p>
</td></tr>
<tr><td><code>pcp1</code></td>
<td>
<p>Percent Correctly Predicted among y=1</p>
</td></tr>
</table>


<h3>Note</h3>

<p>To-do: The <code>glm</code> method should also handle binomial data presented
as two-vector success/failures counts; and count data with
<code>family=poisson</code>, the <code>glm.nb</code> models and <code>zeroinfl</code>
and <code>hurdle</code> etc.   We should also make the output a class with
prettier print methods, i.e., save the cross-tabulation in the
returned object etc.
</p>


<h3>Author(s)</h3>

<p>Simon Jackman <a href="mailto:simon.jackman@sydney.edu.au">simon.jackman@sydney.edu.au</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+pR2">pR2</a></code> for pseudo r-squared;  <code><a href="stats.html#topic+predict">predict</a></code>;
<code><a href="stats.html#topic+extractAIC">extractAIC</a></code>.  See also the <span class="pkg">ROCR</span> package and the <code>lroc</code>  function in the <span class="pkg">epicalc</span> package for ROC computations for assessing binary classifications.</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(admit)
## ordered probit model
op1 &lt;- MASS::polr(score ~ gre.quant + gre.verbal + ap + pt + female,
            Hess=TRUE,
            data=admit,
            method="probit")
hitmiss(op1)
</code></pre>

<hr>
<h2 id='hurdle'>Hurdle Models for Count Data Regression</h2><span id='topic+hurdle'></span><span id='topic+print.hurdle'></span>

<h3>Description</h3>

<p>Fit hurdle regression models for count data via maximum likelihood. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hurdle(formula, data, subset, na.action, weights, offset,
  dist = c("poisson", "negbin", "geometric"),
  zero.dist = c("binomial", "poisson", "negbin", "geometric"),
  link = c("logit", "probit", "cloglog", "cauchit", "log"),
  control = hurdle.control(...),
  model = TRUE, y = TRUE, x = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hurdle_+3A_formula">formula</code></td>
<td>
<p>symbolic description of the model, see details.</p>
</td></tr>
<tr><td><code id="hurdle_+3A_data">data</code>, <code id="hurdle_+3A_subset">subset</code>, <code id="hurdle_+3A_na.action">na.action</code></td>
<td>
<p>arguments controlling formula processing
via <code><a href="stats.html#topic+model.frame">model.frame</a></code>.</p>
</td></tr>
<tr><td><code id="hurdle_+3A_weights">weights</code></td>
<td>
<p>optional numeric vector of weights.</p>
</td></tr>
<tr><td><code id="hurdle_+3A_offset">offset</code></td>
<td>
<p>optional numeric vector with an a priori known component to be
included in the linear predictor of the count model. See below for more
information on offsets.</p>
</td></tr>
<tr><td><code id="hurdle_+3A_dist">dist</code></td>
<td>
<p>character specification of count model family.</p>
</td></tr>
<tr><td><code id="hurdle_+3A_zero.dist">zero.dist</code></td>
<td>
<p>character specification of the zero hurdle model family.</p>
</td></tr>
<tr><td><code id="hurdle_+3A_link">link</code></td>
<td>
<p>character specification of link function in the binomial
zero hurdle (only used if <code>zero.dist = "binomial"</code>.</p>
</td></tr>
<tr><td><code id="hurdle_+3A_control">control</code></td>
<td>
<p>a list of control arguments specified via
<code><a href="#topic+hurdle.control">hurdle.control</a></code>.</p>
</td></tr>
<tr><td><code id="hurdle_+3A_model">model</code>, <code id="hurdle_+3A_y">y</code>, <code id="hurdle_+3A_x">x</code></td>
<td>
<p>logicals. If <code>TRUE</code> the corresponding components
of the fit (model frame, response, model matrix) are returned.</p>
</td></tr>
<tr><td><code id="hurdle_+3A_...">...</code></td>
<td>
<p>arguments passed to <code><a href="#topic+hurdle.control">hurdle.control</a></code> in the
default setup.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Hurdle count models are two-component models with a truncated count
component for positive counts and a hurdle component that models the
zero counts. Thus, unlike zero-inflation models, there are <em>not</em> two
sources of zeros: the count model is only employed if the hurdle for
modeling the occurrence of zeros is exceeded. The count model is typically
a truncated Poisson or negative binomial regression (with log link).
The geometric distribution is a special case of the negative binomial with
size parameter equal to 1. For modeling the hurdle, either a binomial model
can be employed or a censored count distribution. The outcome of the hurdle
component of the model is the occurrence of a non-zero (positive) count.
Thus, for most models, positive coefficients in the hurdle component indicate
that an increase in the regressor increases the probability of a non-zero count.
Binomial logit and censored geometric models as the hurdle part both lead to 
the same likelihood function and thus to the same coefficient estimates.
A censored negative binomial model for the zero hurdle is only identified
if there is at least one non-constant regressor with (true) coefficient different
from zero (and if all coefficients are close to zero the model can be poorly
conditioned).
</p>
<p>The <code>formula</code> can be used to specify both components of the model:
If a <code>formula</code> of type <code>y ~ x1 + x2</code> is supplied, then the same
regressors are employed in both components. This is equivalent to
<code>y ~ x1 + x2 | x1 + x2</code>. Of course, a different set of regressors
could be specified for the zero hurdle component, e.g.,
<code>y ~ x1 + x2 | z1 + z2 + z3</code> giving the count data model <code>y ~ x1 + x2</code>
conditional on (<code>|</code>) the zero hurdle model <code>y ~ z1 + z2 + z3</code>.
</p>
<p>Offsets can be specified in both parts of the model pertaining to count and
zero hurdle model: <code>y ~ x1 + offset(x2) | z1 + z2 + offset(z3)</code>, where
<code>x2</code> is used as an offset (i.e., with coefficient fixed to 1) in the
count part and <code>z3</code> analogously in the zero hurdle part. By the rule
stated above <code>y ~ x1 + offset(x2)</code> is expanded to
<code>y ~ x1 + offset(x2) | x1 + offset(x2)</code>. Instead of using the
<code>offset()</code> wrapper within the <code>formula</code>, the <code>offset</code> argument
can also be employed which sets an offset only for the count model. Thus,
<code>formula = y ~ x1</code> and <code>offset = x2</code> is equivalent to
<code>formula = y ~ x1 + offset(x2) | x1</code>.
</p>
<p>All parameters are estimated by maximum likelihood using <code><a href="stats.html#topic+optim">optim</a></code>,
with control options set in <code><a href="#topic+hurdle.control">hurdle.control</a></code>.
Starting values can be supplied, otherwise they are estimated by <code><a href="stats.html#topic+glm.fit">glm.fit</a></code>
(the default). By default, the two components of the model are estimated separately
using two <code>optim</code> calls. Standard errors are derived numerically using
the Hessian matrix returned by <code><a href="stats.html#topic+optim">optim</a></code>. See
<code><a href="#topic+hurdle.control">hurdle.control</a></code> for details.
</p>
<p>The returned fitted model object is of class <code>"hurdle"</code> and is similar
to fitted <code>"glm"</code> objects. For elements such as <code>"coefficients"</code> or
<code>"terms"</code> a list is returned with elements for the zero and count components,
respectively. For details see below.
</p>
<p>A set of standard extractor functions for fitted model objects is available for
objects of class <code>"hurdle"</code>, including methods to the generic functions
<code><a href="base.html#topic+print">print</a></code>, <code><a href="base.html#topic+summary">summary</a></code>, <code><a href="stats.html#topic+coef">coef</a></code>, 
<code><a href="stats.html#topic+vcov">vcov</a></code>, <code><a href="stats.html#topic+logLik">logLik</a></code>, <code><a href="stats.html#topic+residuals">residuals</a></code>, 
<code><a href="stats.html#topic+predict">predict</a></code>, <code><a href="stats.html#topic+fitted">fitted</a></code>, <code><a href="stats.html#topic+terms">terms</a></code>,
<code><a href="stats.html#topic+model.matrix">model.matrix</a></code>. See <code><a href="#topic+predict.hurdle">predict.hurdle</a></code> for more details
on all methods.
</p>


<h3>Value</h3>

<p>An object of class <code>"hurdle"</code>, i.e., a list with components including
</p>
<table>
<tr><td><code>coefficients</code></td>
<td>
<p>a list with elements <code>"count"</code> and <code>"zero"</code>
containing the coefficients from the respective models,</p>
</td></tr>
<tr><td><code>residuals</code></td>
<td>
<p>a vector of raw residuals (observed - fitted),</p>
</td></tr>
<tr><td><code>fitted.values</code></td>
<td>
<p>a vector of fitted means,</p>
</td></tr>
<tr><td><code>optim</code></td>
<td>
<p>a list (of lists) with the output(s) from the <code>optim</code> call(s) for
minimizing the negative log-likelihood(s),</p>
</td></tr>
<tr><td><code>control</code></td>
<td>
<p>the control arguments passed to the <code>optim</code> call,</p>
</td></tr>
<tr><td><code>start</code></td>
<td>
<p>the starting values for the parameters passed to the <code>optim</code> call(s),</p>
</td></tr>
<tr><td><code>weights</code></td>
<td>
<p>the case weights used,</p>
</td></tr>
<tr><td><code>offset</code></td>
<td>
<p>a list with elements <code>"count"</code> and <code>"zero"</code>
containing the offset vectors (if any) from the respective models,</p>
</td></tr>
<tr><td><code>n</code></td>
<td>
<p>number of observations (with weights &gt; 0),</p>
</td></tr>
<tr><td><code>df.null</code></td>
<td>
<p>residual degrees of freedom for the null model (= <code>n - 2</code>),</p>
</td></tr>
<tr><td><code>df.residual</code></td>
<td>
<p>residual degrees of freedom for fitted model,</p>
</td></tr>
<tr><td><code>terms</code></td>
<td>
<p>a list with elements <code>"count"</code>, <code>"zero"</code> and
<code>"full"</code> containing the terms objects for the respective models,</p>
</td></tr>
<tr><td><code>theta</code></td>
<td>
<p>estimate of the additional <code class="reqn">\theta</code> parameter of the
negative binomial model(s) (if negative binomial component is used),</p>
</td></tr>
<tr><td><code>SE.logtheta</code></td>
<td>
<p>standard error(s) for <code class="reqn">\log(\theta)</code>,</p>
</td></tr>
<tr><td><code>loglik</code></td>
<td>
<p>log-likelihood of the fitted model,</p>
</td></tr>
<tr><td><code>vcov</code></td>
<td>
<p>covariance matrix of all coefficients in the model (derived from the
Hessian of the <code>optim</code> output(s)),</p>
</td></tr>
<tr><td><code>dist</code></td>
<td>
<p>a list with elements <code>"count"</code> and <code>"zero"</code> with character
strings describing the respective distributions used,</p>
</td></tr>
<tr><td><code>link</code></td>
<td>
<p>character string describing the link if a binomial zero hurdle model
is used,</p>
</td></tr>
<tr><td><code>linkinv</code></td>
<td>
<p>the inverse link function corresponding to <code>link</code>,</p>
</td></tr>
<tr><td><code>converged</code></td>
<td>
<p>logical indicating successful convergence of <code>optim</code>,</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>the original function call,</p>
</td></tr>
<tr><td><code>formula</code></td>
<td>
<p>the original formula,</p>
</td></tr>
<tr><td><code>levels</code></td>
<td>
<p>levels of the categorical regressors,</p>
</td></tr>
<tr><td><code>contrasts</code></td>
<td>
<p>a list with elements <code>"count"</code> and <code>"zero"</code>
containing the contrasts corresponding to <code>levels</code> from the
respective models,</p>
</td></tr>
<tr><td><code>model</code></td>
<td>
<p>the full model frame (if <code>model = TRUE</code>),</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>the response count vector (if <code>y = TRUE</code>),</p>
</td></tr>
<tr><td><code>x</code></td>
<td>
<p>a list with elements <code>"count"</code> and <code>"zero"</code>
containing the model matrices from the respective models
(if <code>x = TRUE</code>).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Achim Zeileis &lt;Achim.Zeileis@R-project.org&gt;</p>


<h3>References</h3>

<p>Cameron, A. Colin and Pravin K. Trivedi. 1998. <em>Regression Analysis of Count 
Data</em>. New York: Cambridge University Press.
</p>
<p>Cameron, A. Colin and Pravin K. Trivedi 2005. <em>Microeconometrics: Methods and Applications</em>.
Cambridge: Cambridge University Press.
</p>
<p>Mullahy, J. 1986. Specification and Testing of Some Modified Count Data Models.
<em>Journal of Econometrics</em>. <b>33</b>:341&ndash;365.
</p>
<p>Zeileis, Achim, Christian Kleiber and Simon Jackman 2008.
&ldquo;Regression Models for Count Data in R.&rdquo; 
<em>Journal of Statistical Software</em>, <b>27</b>(8).
URL <a href="https://www.jstatsoft.org/v27/i08/">https://www.jstatsoft.org/v27/i08/</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+hurdle.control">hurdle.control</a></code>, <code><a href="stats.html#topic+glm">glm</a></code>,
<code><a href="stats.html#topic+glm.fit">glm.fit</a></code>, <code><a href="MASS.html#topic+glm.nb">glm.nb</a></code>,
<code><a href="#topic+zeroinfl">zeroinfl</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## data
data("bioChemists", package = "pscl")

## logit-poisson
## "art ~ ." is the same as "art ~ . | .", i.e.
## "art ~ fem + mar + kid5 + phd + ment | fem + mar + kid5 + phd + ment"
fm_hp1 &lt;- hurdle(art ~ ., data = bioChemists)
summary(fm_hp1)

## geometric-poisson
fm_hp2 &lt;- hurdle(art ~ ., data = bioChemists, zero = "geometric")
summary(fm_hp2)

## logit and geometric model are equivalent
coef(fm_hp1, model = "zero") - coef(fm_hp2, model = "zero")

## logit-negbin
fm_hnb1 &lt;- hurdle(art ~ ., data = bioChemists, dist = "negbin")
summary(fm_hnb1)

## negbin-negbin
## (poorly conditioned zero hurdle, note the standard errors)
fm_hnb2 &lt;- hurdle(art ~ ., data = bioChemists, dist = "negbin", zero = "negbin")
summary(fm_hnb2)
</code></pre>

<hr>
<h2 id='hurdle.control'>Control Parameters for Hurdle Count Data Regression</h2><span id='topic+hurdle.control'></span>

<h3>Description</h3>

<p>Various parameters that control fitting of hurdle regression models
using <code><a href="#topic+hurdle">hurdle</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hurdle.control(method = "BFGS", maxit = 10000, trace = FALSE,
  separate = TRUE, start = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hurdle.control_+3A_method">method</code></td>
<td>
<p>characters string specifying the <code>method</code> argument
passed to <code><a href="stats.html#topic+optim">optim</a></code>.</p>
</td></tr>
<tr><td><code id="hurdle.control_+3A_maxit">maxit</code></td>
<td>
<p>integer specifying the <code>maxit</code> argument (maximal number
of iterations) passed to <code><a href="stats.html#topic+optim">optim</a></code>.</p>
</td></tr>
<tr><td><code id="hurdle.control_+3A_trace">trace</code></td>
<td>
<p>logical or integer controlling whether tracing information on  
the progress of the optimization should be produced (passed to <code><a href="stats.html#topic+optim">optim</a></code>).</p>
</td></tr>
<tr><td><code id="hurdle.control_+3A_separate">separate</code></td>
<td>
<p>logical. Should the estimation of the parameters in the truncated
count component and hurdle zero component be carried out separately? See details.</p>
</td></tr>
<tr><td><code id="hurdle.control_+3A_start">start</code></td>
<td>
<p>an optional list with elements <code>"count"</code> and <code>"zero"</code>
(and potentially <code>"theta"</code>) containing the coefficients for the corresponding component.</p>
</td></tr>
<tr><td><code id="hurdle.control_+3A_...">...</code></td>
<td>
<p>arguments passed to <code><a href="stats.html#topic+optim">optim</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>All parameters in <code><a href="#topic+hurdle">hurdle</a></code> are estimated by maximum likelihood
using <code><a href="stats.html#topic+optim">optim</a></code> with control options set in <code><a href="#topic+hurdle.control">hurdle.control</a></code>.
Most arguments are passed on directly to <code>optim</code>, only <code>trace</code> is also
used within <code>hurdle</code> and <code>separate</code>/<code>start</code> control how <code>optim</code>
is called.
</p>
<p>Starting values can be supplied via <code>start</code> or estimated by
<code><a href="stats.html#topic+glm.fit">glm.fit</a></code> (default).
If <code>separate = TRUE</code> (default) the likelihoods of the truncated count component and the
hurdle zero component will be maximized separately, otherwise the joint likelihood is
set up and maximized. Standard errors are derived numerically using
the Hessian matrix returned by <code><a href="stats.html#topic+optim">optim</a></code>. To supply starting 
values, <code>start</code> should be a list with elements <code>"count"</code> and <code>"zero"</code>
and potentially <code>"theta"</code> (a named vector, for models with negative binomial components 
only) containing the starting values for the coefficients of the corresponding component 
of the model.
</p>


<h3>Value</h3>

<p>A list with the arguments specified.
</p>


<h3>Author(s)</h3>

<p>Achim Zeileis &lt;Achim.Zeileis@R-project.org&gt;</p>


<h3>See Also</h3>

<p><code><a href="#topic+hurdle">hurdle</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data("bioChemists", package = "pscl")

## default start values
fm1 &lt;- hurdle(art ~ fem + ment, data = bioChemists,
              dist = "negbin", zero = "negbin")

## user-supplied start values and other options
fm2 &lt;- hurdle(art ~ fem + ment, data = bioChemists,
              dist = "negbin",
              zero = "negbin",
              trace=TRUE,
              separate=FALSE,
              start = list(count = c(0.3, -0.2, 0),
                           zero = c(4, -2, 0.8),
                           theta = c(count = 2, zero = 0.1)))

</code></pre>

<hr>
<h2 id='hurdletest'>Testing for the Presence of a Zero Hurdle</h2><span id='topic+hurdletest'></span>

<h3>Description</h3>

<p>Wald test of the null hypothesis that no zero hurdle
is required in hurdle regression models for count data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hurdletest(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hurdletest_+3A_object">object</code></td>
<td>
<p>A fitted model object of class <code>"hurdle"</code>
as returned by <code><a href="#topic+hurdle">hurdle</a></code>, see details for more information.</p>
</td></tr>
<tr><td><code id="hurdletest_+3A_...">...</code></td>
<td>
<p>arguments passed to <code><a href="car.html#topic+linearHypothesis">linearHypothesis</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the same count distribution and the same set of regressors is used in
the hurdle model for both, the count component and the zero hurdle component,
then a test of pairwise equality between all coefficients from the two
components assesses the null hypothesis that no hurdle is needed in the
model.
</p>
<p>The function <code>hurdletest</code> is a simple convenience interface to
the function <code><a href="car.html#topic+linearHypothesis">linearHypothesis</a></code> from the <span class="pkg">car</span>
packages that can be employed to carry out a Wald test for this 
hypothesis.
</p>


<h3>Value</h3>

<p>An object of class <code>"anova"</code> as returned by <code><a href="car.html#topic+linearHypothesis">linearHypothesis</a></code>.
</p>


<h3>Author(s)</h3>

<p>Achim Zeileis &lt;Achim.Zeileis@R-project.org&gt;</p>


<h3>References</h3>

<p>Cameron, A. Colin and Pravin K. Trivedi. 1998. <em>Regression Analysis of Count 
Data</em>. New York: Cambridge University Press.
</p>
<p>Cameron, A. Colin and Pravin K. Trivedi 2005. <em>Microeconometrics: Methods and Applications</em>.
Cambridge: Cambridge University Press.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+hurdle">hurdle</a></code>, <code><a href="car.html#topic+linearHypothesis">linearHypothesis</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data("bioChemists", package = "pscl")
fm &lt;- hurdle(art ~ ., data = bioChemists, dist = "negbin", zero = "negbin")
hurdletest(fm)
</code></pre>

<hr>
<h2 id='ideal'>analysis of educational testing data and roll call data with IRT models, via Markov
chain Monte Carlo methods</h2><span id='topic+ideal'></span>

<h3>Description</h3>

<p>Analysis of <code>rollcall</code> data via the spatial voting model;
equivalent to a 2 parameter item-response model to educational testing data.  Model fitting via Markov chain Monte Carlo (MCMC).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ideal(object, codes = object$codes,
      dropList = list(codes = "notInLegis", lop = 0),
      d = 1, maxiter = 10000, thin = 100, burnin = 5000,
      impute = FALSE,
      normalize = FALSE,
      meanzero = normalize,
      priors = NULL, startvals = "eigen",
      store.item = FALSE, file = NULL,
      verbose=FALSE, use.voter=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ideal_+3A_object">object</code></td>
<td>
<p>an object of class <code><a href="#topic+rollcall">rollcall</a></code></p>
</td></tr>
<tr><td><code id="ideal_+3A_codes">codes</code></td>
<td>
<p>a <code><a href="base.html#topic+list">list</a></code> describing the types of voting
decisions in the roll call matrix (the <code>votes</code> component of the
<code><a href="#topic+rollcall">rollcall</a></code> <code>object</code>); defaults to 
<code>object$codes</code>, the codes in the rollcall object.</p>
</td></tr> 
<tr><td><code id="ideal_+3A_droplist">dropList</code></td>
<td>
<p>a <code><a href="base.html#topic+list">list</a></code> (or <code><a href="base.html#topic+alist">alist</a></code>)
listing voting decisions, legislators and/or votes to be dropped
from the analysis; see <code><a href="#topic+dropRollCall">dropRollCall</a></code> for details.</p>
</td></tr>
<tr><td><code id="ideal_+3A_d">d</code></td>
<td>
<p>numeric, (small) positive integer (default = 1), dimensionality of the ability space (or &quot;policy space&quot; in the rollcall context).</p>
</td></tr>
<tr><td><code id="ideal_+3A_maxiter">maxiter</code></td>
<td>
<p>numeric, positive integer, multiple of <code>thin</code>, number of MCMC iterations</p>
</td></tr>
<tr><td><code id="ideal_+3A_thin">thin</code></td>
<td>
<p>numeric, positive integer, thinning interval used for
recording MCMC iterations.</p>
</td></tr>
<tr><td><code id="ideal_+3A_burnin">burnin</code></td>
<td>
<p>number of MCMC iterations to run before recording.  The
iteration numbered <code>burnin</code> will be recorded.  Must be a
multiple of <code>thin</code>.</p>
</td></tr>
<tr><td><code id="ideal_+3A_impute">impute</code></td>
<td>
<p><code><a href="base.html#topic+logical">logical</a></code>, whether to treat missing entries
of the rollcall matrix as missing at random, sampling from the
predictive density of the missing entries at each MCMC iteration.</p>
</td></tr>
<tr><td><code id="ideal_+3A_normalize">normalize</code></td>
<td>
<p><code><a href="base.html#topic+logical">logical</a></code>, impose identification with
the constraint that the ideal points have mean zero and
standard deviation one, in each dimension.  For one dimensional models this option is sufficient to
locally identify the model parameters.
See Details.</p>
</td></tr>
<tr><td><code id="ideal_+3A_meanzero">meanzero</code></td>
<td>
<p>to be deprecated/ignored; use <code>normalize</code> instead.</p>
</td></tr>
<tr><td><code id="ideal_+3A_priors">priors</code></td>
<td>
<p>a <code>list</code> of parameters (means and variances)
specifying normal priors for the legislators' ideal points. The
default is <code>NULL</code>, in which case the normal priors used have mean zero and
precision 1 for the ideal points (ability parameters) and mean zero and
precision .04 (variance 25) for the bill parameters (item discrimination and difficulty parameters).  If not <code>NULL</code>, <code>priors</code> must be a
<code>list</code> with as many as four named components <code>xp, xpv, bp,
      bpv</code>:
</p>

<dl>
<dt><code>xp</code></dt><dd><p>a <code>n</code> by <code>d</code> matrix
of prior <em>means</em> for the legislators' ideal points;
or alternatively, a scalar, which will be replicated to fill a <code>n</code> by <code>d</code> matrix.</p>
</dd>
<dt><code>xpv</code></dt><dd><p>a <code>n</code> by <code>d</code> matrix of prior
<em>precisions</em> (inverse variances);
or alternatively, a scalar, which will be replicated to fill a <code>n</code>
by <code>d</code> matrix.</p>
</dd> 
<dt><code>bp</code></dt><dd><p>a <code>m</code> by <code>d+1</code> matrix of prior means for the
item parameters (with the item difficulty parameter coming last);
or alternatively, a scalar, which will be replicated to fill a <code>m</code>
by <code>d+1</code> matrix.</p>
</dd>
<dt><code>bpv</code></dt><dd><p>a <code>m</code> by <code>d+1</code> matrix of prior
precisions for the item parameters;
or alternatively, a scalar, which will be replicated to fill a <code>m</code>
by <code>d+1</code> matrix.</p>
</dd>
</dl>

<p>None of the components should contain <code>NA</code>.  If any
of the four possible components are not provided, then the
corresponding component of <code>priors</code> is assigned using the default
values described above.</p>
</td></tr>
<tr><td><code id="ideal_+3A_startvals">startvals</code></td>
<td>
<p>either a string naming a method for generating start
values, valid options are <code>"eigen"</code> (the default),
<code>"random"</code> or a <code>list</code> containing start values for
legislators' ideal points and item parameters.  See Details.</p>
</td></tr>
<tr><td><code id="ideal_+3A_store.item">store.item</code></td>
<td>
<p><code><a href="base.html#topic+logical">logical</a></code>, whether item discrimination
parameters should be stored.  Storing item discrimination parameters
can consume a large amount of memory.  These need to be stored for
prediction; see <code><a href="#topic+predict.ideal">predict.ideal</a></code>.</p>
</td></tr>
<tr><td><code id="ideal_+3A_file">file</code></td>
<td>
<p>string, file to write MCMC output.  Default is
<code>NULL</code>, in which case MCMC output is stored in memory.  Note
that post-estimation commands like <code>plot</code> will not work unless
MCMC output is stored in memory.</p>
</td></tr>
<tr><td><code id="ideal_+3A_verbose">verbose</code></td>
<td>
<p>logical, default
is <code>FALSE</code>, which generates relatively little output to the R
console during execution.</p>
</td></tr>
<tr><td><code id="ideal_+3A_use.voter">use.voter</code></td>
<td>
<p>A vector of logicals of length <code>n</code> controlling
which legislators' vote data informs item parameter
estimates. Legislators corresponding to <code>FALSE</code> entries will
not have their voting data included in updates of the item
parameters. The default value of <code>NULL</code> will run the standard
ideal-point model, which uses all legislators in updating item
parameters. See Jessee (2016).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function fits a <code>d</code>+1 parameter item-response model to
the roll call data object, so in one dimension the model reduces
to the two-parameter item-response model popular in educational testing.
See References.
</p>
<p><strong>Identification</strong>: The model parameters are <strong>not
identified</strong> without the user supplying some restrictions on the
model parameters; i.e., translations, rotations and re-scalings of
the ideal points are observationally equivalent, via offsetting
transformations of the item parameters.  It is the user's
responsibility to impose these identifying restrictions if
desired. The following brief discussion provides some guidance.
</p>
<p>For one-dimensional models (i.e., <code>d=1</code>), a simple route to
identification is the <code>normalize</code> option, by imposing the restriction that the means of the posterior densities of the ideal points (ability parameters) have mean zero and standard deviation one, across legislators (test-takers).  This normalization supplies
<em>local</em> identification (that is, identification up to a 180 degree rotation of
the recovered dimension). 
</p>
<p>Near-degenerate &ldquo;spike&rdquo; priors
(priors with arbitrarily large precisions) or the
<code>constrain.legis</code> option on any two legislators' ideal points
ensures <em>global</em> identification in one dimension.
</p>
<p>Identification in higher dimensions can be obtained by supplying
fixed values for <code>d+1</code> legislators' ideal points, provided the
supplied fixed points span a <code>d</code>-dimensional space (e.g., three
supplied ideal points form a triangle in <code>d=2</code> dimensions), via
the <code><a href="#topic+constrain.legis">constrain.legis</a></code> option. In this case the function
defaults to vague normal priors on the unconstrained ideal points, but at each iteration the sampled
ideal points are transformed back into the space of identified
parameters, applying the linear transformation that maps the
<code>d+1</code> fixed ideal points from their sampled values to their
fixed values.  Alternatively, one can impose
restrictions on the item parameters via
<code><a href="#topic+constrain.items">constrain.items</a></code>. See the examples in the documentation
for the <code><a href="#topic+constrain.legis">constrain.legis</a></code> and
<code><a href="#topic+constrain.items">constrain.items</a></code>.
</p>
<p>Another route to identification is via <em>post-processing</em>.  That
is, the user can run <code>ideal</code> without any identification
constraints. This does not pose any formal/technical problem in a
Bayesian analysis.  The fact that the posterior density may have
multiple modes doesn't imply that the posterior is improper or that
it can't be explored via MCMC methods. &ndash; but then use the function
<code><a href="#topic+postProcess">postProcess</a></code> to map the MCMC output from the space of
unidentified parameters into the subspace of identified parameters.
See the example in the documentation for the
<code><a href="#topic+postProcess">postProcess</a></code> function.
</p>
<p>When the <code>normalize</code> option is set to <code>TRUE</code>, an
unidentified model is run, and the <code>ideal</code> object is
post-processed with the <code>normalize</code> option, and then returned
to the user (but again, note that the <code>normalize</code> option is
only implemented for unidimensional models).
</p>
<p><strong>Start values</strong>.  Start values can be supplied by the user, or
generated by the function itself. 
</p>
<p>The default method, corresponding to <code>startvals="eigen"</code>, first
forms a <code>n</code>-by-<code>n</code> correlation matrix from the
double-centered roll call matrix (subtracting row means, and column
means, adding in the grand mean), and then extracts the first
<code>d</code> principal components (eigenvectors), scaling the
eigenvectors by the square root of their corresponding eigenvector.
If the user is imposing constraints on ideal points (via
<code><a href="#topic+constrain.legis">constrain.legis</a></code>), these constraints are applied to the
corresponding elements of the start values generated from the
eigen-decomposition.  Then, to generate start 
values for the rollcall/item parameters, a series of
<code><a href="stats.html#topic+family">binomial</a></code> <code><a href="stats.html#topic+glm">glms</a></code> are
estimated (with a probit <code><a href="stats.html#topic+make.link">link</a></code>), one for
each rollcall/item, <code class="reqn">j = 1, \ldots, m</code>.  The votes on the
<code class="reqn">j</code>-th rollcall/item are binary responses (presumed to be
conditionally independent given each legislator's latent
preference), and the (constrained or unconstrained) start values for
legislators are used as predictors. The estimated coefficients from
these probit models are used as start values for the item
discrimination and difficulty parameters (with the intercepts from
the probit GLMs multiplied by -1 so as to make those coefficients
difficulty parameters).
</p>
<p>The default <code>eigen</code> method generates extremely good start
values for low-dimensional models fit to recent U.S. congresses,
where high rates of party line voting result in excellent fits from
low dimensional models.  The <code>eigen</code> method may be
computationally expensive or lead to memory errors for
<code>rollcall</code> objects with large numbers of legislators.
</p>
<p>The <code>random</code> method generates start values via iid sampling
from a N(0,1) density, via <code><a href="stats.html#topic+rnorm">rnorm</a></code>, imposing any
constraints that may have been supplied via
<code><a href="#topic+constrain.legis">constrain.legis</a></code>, and then uses the probit method
described above to get start values for the rollcall/item
parameters.
</p>
<p>If <code>startvals</code> is a <code>list</code>, it must contain the named
components <code>x</code> and/or <code>b</code>, or named components that
(uniquely) begin with the letters <code>x</code> and/or <code>b</code>.  The
component <code>x</code> must be a vector or a matrix of dimensions equal to
the number of individuals (legislators) by <code>d</code>.  If supplied,
<code>startvals$b</code> must be a matrix with dimension number of items
(votes) by <code>d</code>+1.  The <code>x</code> and <code>b</code> components cannot
contain <code>NA</code>.  If <code>x</code> is not supplied when <code>startvals</code>
is a list, then start values are generated using the default
<code>eiegn</code> method described above, and start values for the
rollcall/item parameters are regenerated using the probit method,
ignoring any user-supplied values in <code>startvals$b</code>.  That is,
user-supplied values in <code>startvals$b</code> are only used when
accompanied by a valid set of start values for the ideal points in
<code>startvals$x</code>.
</p>
<p><strong>Implementation via Data Augmentation</strong>.  The MCMC algorithm
for this problem consists of a Gibbs sampler for the ideal points
(latent traits)
and item parameters, conditional on latent data <code class="reqn">y^*</code>, generated
via a data augmentation (DA) step.  That is, following Albert (1992) and
Albert and Chib (1993), if <code class="reqn">y_{ij} = 1</code> we sample from the
truncated normal density
</p>
<p style="text-align: center;"><code class="reqn">y_{ij}^* \sim N(x_i' \beta_j - \alpha_j, 1)\mathcal{I}(y_{ij}^* \geq 0)</code>
</p>

<p>and for <code class="reqn">y_{ij}=0</code> we sample 
</p>
<p style="text-align: center;"><code class="reqn">y_{ij}^* \sim N(x_i' \beta_j - \alpha_j, 1)\mathcal{I}(y_{ij}^* &lt; 0)</code>
</p>

<p>where <code class="reqn">\mathcal{I}</code> is an indicator function evaluating to one
if its argument is true and zero otherwise.  Given the
latent <code class="reqn">y^*</code>, the conditional distributions for <code class="reqn">x</code> and
<code class="reqn">(\beta,\alpha)</code> are extremely simple to sample from; see the
references for details.  
</p>
<p>This data-augmented Gibbs sampling strategy is easily implemented,
but can sometimes require many thousands of samples in order to
generate tolerable explorations of the posterior densities of the
latent traits, particularly for legislators with short and/or
extreme voting histories (the equivalent in the educational testing
setting is a test-taker who gets almost every item right or wrong).
</p>





















<h3>Value</h3>

<p>a <code><a href="base.html#topic+list">list</a></code> of class <code>ideal</code> with named components
</p>
<table>
<tr><td><code>n</code></td>
<td>
<p><code><a href="base.html#topic+numeric">numeric</a></code>, integer, number of legislators in the
analysis, after any subsetting via processing the <code>dropList</code>.</p>
</td></tr>
<tr><td><code>m</code></td>
<td>
<p><code><a href="base.html#topic+numeric">numeric</a></code>, integer, number of rollcalls in roll
call matrix, after any subsetting via processing the <code>dropList</code>.</p>
</td></tr>
<tr><td><code>d</code></td>
<td>
<p><code><a href="base.html#topic+numeric">numeric</a></code>, integer, number of dimensions
fitted.</p>
</td></tr>
<tr><td><code>x</code></td>
<td>
<p>a three-dimensional <code><a href="base.html#topic+array">array</a></code> containing the MCMC
output with respect to the 
the ideal point of each legislator in each dimension.
The three-dimensional array is in iteration-legislator-dimension
order.  The iterations run from <code>burnin</code> to <code>maxiter</code>, at
an interval of <code>thin</code>.</p>
</td></tr>
<tr><td><code>beta</code></td>
<td>
<p>a three-dimensional <code><a href="base.html#topic+array">array</a></code> containing the
MCMC output for the item parameters.  The three-dimensional array
is in iteration-rollcall-parameter order.  The iterations run from
<code>burnin</code> to <code>maxiter</code>, at an interval of <code>thin</code>.
Each rollcall has <code>d+1</code> parameters, with the
item-discrimination parameters stored first, in the first <code>d</code>
components of the 3rd dimension of the <code>beta</code> array; the
item-difficulty parameter follows in the final <code>d+1</code>
component of the 3rd dimension of the <code>beta</code> array.</p>
</td></tr>
<tr><td><code>xbar</code></td>
<td>
<p>a <code>n</code> by <code>d</code> <code><a href="base.html#topic+matrix">matrix</a></code> containing the means of the
MCMC samples for the ideal point of each legislator in each dimension,
using iterations <code>burnin</code> to <code>maxiter</code>, at an interval of
<code>thin</code>.</p>
</td></tr>
<tr><td><code>betabar</code></td>
<td>
<p>a <code>m</code> by <code>d+1</code> <code><a href="base.html#topic+matrix">matrix</a></code> containing the means of
the MCMC samples for the item-specific parameters, using iterations
<code>burnin</code> to <code>maxiter</code>, at an interval of <code>thin</code>.</p>
</td></tr>
<tr><td><code>args</code></td>
<td>
<p>calling arguments, evaluated in the frame calling <code>ideal</code>.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>an object of class <code><a href="base.html#topic+call">call</a></code>, containing
the arguments passed to <code>ideal</code> as unevaluated expressions or values (for functions arguments that evaluate to scalar integer or logical such as <code>maxiter</code>, <code>burnin</code>, etc).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Simon Jackman <a href="mailto:simon.jackman@sydney.edu.au">simon.jackman@sydney.edu.au</a>, with help from Christina
Maimone and Alex Tahk.</p>


<h3>References</h3>

<p>Albert, James. 1992. Bayesian Estimation of normal ogive item
response curves using Gibbs sampling. <em>Journal of Educational
Statistics</em>. 17:251-269.
</p>
<p>Albert, James H. and Siddhartha Chib.  1993.  Bayesian Analysis of
Binary and Polychotomous Response Data.  <em>Journal of the
American Statistical Association</em>. 88:669-679.
</p>
<p>Clinton, Joshua, Simon Jackman and Douglas Rivers. 2004. The
Statistical Analysis of Roll Call Data.  <em>American Political
Science Review</em>.  98:335-370.
</p>
<p>Jackman, Simon. 2009.  <em>Bayesian Analysis for the Social
Sciences</em>.  Wiley: Hoboken, New Jersey.
</p>
<p>Jessee, Stephen. 2016. (How) Can We Estimate the Ideology
of Citizens and Political Elites on the Same Scale?
<em>American Journal of Political Science</em>.
</p>
<p>Patz, Richard J. and Brian W. Junker. 1999.  A Straightforward
Approach to Markov Chain Monte Carlo Methods for Item Response
Models. <em>Journal of Education and Behavioral
Statistics</em>. 24:146-178.
</p>
<p>Rivers, Douglas. 2003.  &ldquo;Identification of Multidimensional
Item-Response Models.&rdquo; Typescript.  Department of Political Science,
Stanford University.
</p>
<p>van Dyk, David A and Xiao-Li Meng.  2001.  The art of data
augmentation (with discussion).  <em>Journal of Computational and
Graphical Statistics</em>. 10(1):1-111.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rollcall">rollcall</a></code>, <code><a href="#topic+summary.ideal">summary.ideal</a></code>,
<code><a href="#topic+plot.ideal">plot.ideal</a></code>, <code><a href="#topic+predict.ideal">predict.ideal</a></code>.
<code><a href="#topic+tracex">tracex</a></code> for graphical display of MCMC iterative
history.
</p>
<p><code><a href="#topic+idealToMCMC">idealToMCMC</a></code> converts the MCMC iterates in an
<code>ideal</code> object to a form that can be used by the <code>coda</code> library.
</p>
<p><code><a href="#topic+constrain.items">constrain.items</a></code> and
<code><a href="#topic+constrain.legis">constrain.legis</a></code> for implementing identifying
restrictions.
</p>
<p><code><a href="#topic+postProcess">postProcess</a></code> for imposing identifying restrictions
<em>ex post</em>.
</p>
<p><code><a href="MCMCpack.html#topic+MCMCirt1d">MCMCirt1d</a></code> and 
<code><a href="MCMCpack.html#topic+MCMCirtKd">MCMCirtKd</a></code> in the <span class="pkg">MCMCpack</span>
package provide similar functionality to <code>ideal</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## long run, many iterations
data(s109)
n &lt;- dim(s109$legis.data)[1]
x0 &lt;- rep(0,n)
x0[s109$legis.data$party=="D"] &lt;- -1
x0[s109$legis.data$party=="R"] &lt;- 1

id1 &lt;- ideal(s109,
             d=1,
             startvals=list(x=x0),
             normalize=TRUE,
             store.item=TRUE,
             maxiter=260E3,
             burnin=10E3,
             thin=100)  

## End(Not run)
</code></pre>

<hr>
<h2 id='idealToMCMC'>convert an object of class ideal to a coda MCMC object</h2><span id='topic+idealToMCMC'></span>

<h3>Description</h3>

<p>Converts the x element of an <code>ideal</code> object to an MCMC object,
as used in the <span class="pkg">coda</span> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>idealToMCMC(object, burnin=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="idealToMCMC_+3A_object">object</code></td>
<td>
<p>an object of class <code><a href="#topic+ideal">ideal</a></code>.</p>
</td></tr>
<tr><td><code id="idealToMCMC_+3A_burnin">burnin</code></td>
<td>
<p>of the recorded MCMC samples, how many to discard as
burnin?  Default is <code>NULL</code>, in which case the value of
<code>burnin</code> in the <code><a href="#topic+ideal">ideal</a></code> object is used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="coda.html#topic+mcmc">mcmc</a></code> object as used by the
<span class="pkg">coda</span> package, starting at
iteration <code>start</code>, drawn from the <code>x</code> component of the
<code><a href="#topic+ideal">ideal</a></code> object.</p>


<h3>Note</h3>

<p>When specifying a value of <code>burnin</code> different from that used
in fitting the <code><a href="#topic+ideal">ideal</a></code> object, note a distinction
between the iteration numbers of the stored iterations, and the
number of stored iterations.  That is, the <code>n</code>-th iteration
stored in an <code><a href="#topic+ideal">ideal</a></code> object will not be iteration
<code>n</code> if the user specified <code>thin&gt;1</code> in the call to
<code><a href="#topic+ideal">ideal</a></code>.  Here, iterations are tagged with their
iteration number.  Thus, if the user called <code><a href="#topic+ideal">ideal</a></code> with
<code>thin=10</code> and <code>burnin=100</code> then the stored iterations are
numbered <code>100, 110, 120, ...</code>.  Any future subsetting via a
<code>burnin</code> refers to this iteration number.</p>


<h3>See Also</h3>

<p><code><a href="#topic+ideal">ideal</a></code>, <code><a href="coda.html#topic+mcmc">mcmc</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(s109)
f = system.file("extdata",package="pscl","id1.rda")
load(f)
id1coda &lt;- idealToMCMC(id1)
summary(id1coda)  
</code></pre>

<hr>
<h2 id='igamma'>inverse-Gamma distribution</h2><span id='topic+igamma'></span><span id='topic+densigamma'></span><span id='topic+pigamma'></span><span id='topic+qigamma'></span><span id='topic+rigamma'></span><span id='topic+igammaHDR'></span>

<h3>Description</h3>

<p>Density, distribution function, quantile function, and highest density region calculation for the inverse-Gamma distribution with parameters <code>alpha</code> and <code>beta</code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>	densigamma(x,alpha,beta)
  	pigamma(q,alpha,beta)
	qigamma(p,alpha,beta)
	rigamma(n,alpha,beta)
	igammaHDR(alpha,beta,content=.95,debug=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="igamma_+3A_x">x</code>, <code id="igamma_+3A_q">q</code></td>
<td>
<p>vector of quantiles</p>
</td></tr>
<tr><td><code id="igamma_+3A_p">p</code></td>
<td>
<p>vector of probabilities</p>
</td></tr>
<tr><td><code id="igamma_+3A_n">n</code></td>
<td>
<p>number of random samples in <code>rigamma</code></p>
</td></tr> 
<tr><td><code id="igamma_+3A_alpha">alpha</code>, <code id="igamma_+3A_beta">beta</code></td>
<td>
<p>rate and shape parameters of the
inverse-Gamma density, both positive</p>
</td></tr>
<tr><td><code id="igamma_+3A_content">content</code></td>
<td>
<p>scalar, 0 &lt; <code>content</code> &lt; 1, volume of
highest density region</p>
</td></tr>
<tr><td><code id="igamma_+3A_debug">debug</code></td>
<td>
<p>logical; if TRUE, debugging information from the
search for the HDR is printed</p>
</td></tr> 
</table>


<h3>Details</h3>

<p>The inverse-Gamma density arises frequently in Bayesian
analysis of normal data, as the (marginal) conjugate prior for
the unknown variance parameter.  The inverse-Gamma density
for <code class="reqn">x&gt;0</code> with parameters <code class="reqn">\alpha&gt;0</code> and <code class="reqn">\beta&gt;0</code>
is
</p>
<p style="text-align: center;"><code class="reqn">f(x) = \frac{\beta^\alpha}{\Gamma(\alpha)} x^{-\alpha-1}
    \exp(-\beta/x)</code>
</p>

<p>where <code class="reqn">\Gamma(x)</code> is the <code><a href="base.html#topic+gamma">gamma</a></code> function
</p>
<p style="text-align: center;"><code class="reqn">\Gamma(a) = \int_0^\infty t^{a-1} \exp(-t) dt</code>
</p>

<p>and so ensures <code class="reqn">f(x)</code> integrates to one.  The
inverse-Gamma density has a mean at <code class="reqn">\beta/(\alpha-1)</code> for
<code class="reqn">\alpha&gt;1</code> and has variance <code class="reqn">\beta^2/((\alpha-1)^2
    (\alpha-2))</code> for
<code class="reqn">\alpha&gt;2</code>.  The inverse-Gamma density has a unique mode at
<code class="reqn">\beta/(\alpha+1)</code>.  
</p>
<p>The evaluation of the density,
cumulative distribution function and quantiles is done by
calls to the <code>dgamma</code>, <code>pgamma</code> and <code>igamma</code>
functions, with the arguments appropriately transformed.  That
is, note
that if <code class="reqn">x \sim IG(\alpha,\beta)</code> then <code class="reqn">1/x \sim
    G(\alpha,\beta)</code>.  
</p>
<p><em>Highest Density Regions</em>. In general, suppose <code class="reqn">x</code>
has a density <code class="reqn">f(x)</code>, where <code class="reqn">x \in \Theta</code>.  Then a
highest density region (HDR) for <code class="reqn">x</code> with content <code class="reqn">p
    \in (0,1]</code> is a region (or set of regions) <code class="reqn">\mathcal{Q}
    \subseteq \Theta</code> such that:
</p>
<p style="text-align: center;"><code class="reqn">\int_\mathcal{Q} f(x) dx = p</code>
</p>

<p>and
</p>
<p style="text-align: center;"><code class="reqn">f(x) &gt; f(x^*) \, \forall\ x \in \mathcal{Q},
    x^* \not\in \mathcal{Q}.</code>
</p>

<p>For a continuous, unimodal
density defined with respect to a single parameter (like the
inverse-Gamma case considered here with parameters <code class="reqn">0 &lt;
    \alpha &lt; \infty, \,\, 0 &lt; \beta &lt; \infty</code>), a HDR region <code class="reqn">Q</code>
of content <code class="reqn">p</code> (with <code class="reqn">0 &lt; p &lt; 1</code>) is a unique, closed
interval on the real half-line.
</p>
<p>This function uses numerical methods to solve for the
boundaries of a HDR with <code>content</code> <code class="reqn">p</code> for the
inverse-Gamma density, via repeated calls the functions
<code>densigamma</code>, <code>pigamma</code> and
<code>qigamma</code>. In particular, the function <code><a href="stats.html#topic+uniroot">uniroot</a></code> is used to
find points <code class="reqn">v</code> and <code class="reqn">w</code> such that </p>
<p style="text-align: center;"><code class="reqn">f(v) = f(w)</code>
</p>
<p> subject
to the constraint
</p>
<p style="text-align: center;"><code class="reqn">\int_v^w f(x; \alpha, \beta) d\theta = p.</code>
</p>



<h3>Value</h3>

<p><code>densigamma</code> gives the density, <code>pigamma</code> the
distribution function, <code>qigamma</code> the quantile function,
<code>rigamma</code> generates random samples, and <code>igammaHDR</code> gives
the lower and upper limits of the HDR, as defined above (<code>NA</code>s if
the optimization is not successful).
</p>


<h3>Note</h3>

<p>The <code>densigamma</code> is named so as not to conflict with the
<code><a href="base.html#topic+digamma">digamma</a></code> function in the R <code><a href="base.html#topic+base">base</a></code> package
(the derivative of the <code>gamma</code> function).
</p>


<h3>Author(s)</h3>

<p>Simon Jackman <a href="mailto:simon.jackman@sydney.edu.au">simon.jackman@sydney.edu.au</a></p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+gamma">gamma</a></code>, <code><a href="stats.html#topic+dgamma">dgamma</a></code>,
<code><a href="stats.html#topic+pgamma">pgamma</a></code>, <code><a href="stats.html#topic+qgamma">qgamma</a></code>, <code><a href="stats.html#topic+uniroot">uniroot</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>alpha &lt;- 4
beta &lt;- 30
summary(rigamma(n=1000,alpha,beta))

xseq &lt;- seq(.1,30,by=.1)
fx &lt;- densigamma(xseq,alpha,beta)
plot(xseq,fx,type="n",
     xlab="x",
     ylab="f(x)",
     ylim=c(0,1.01*max(fx)),
     yaxs="i",
     axes=FALSE)
axis(1)
title(substitute(list(alpha==a,beta==b),list(a=alpha,b=beta)))
q &lt;- igammaHDR(alpha,beta,debug=TRUE)
xlo &lt;- which.min(abs(q[1]-xseq))
xup &lt;- which.min(abs(q[2]-xseq))
plotZero &lt;- par()$usr[3]
polygon(x=xseq[c(xlo,xlo:xup,xup:xlo)],
        y=c(plotZero,
          fx[xlo:xup],
          rep(plotZero,length(xlo:xup))),
        border=FALSE,
        col=gray(.45))
lines(xseq,fx,lwd=1.25)


## Not run: 
alpha &lt;- beta &lt;- .1
xseq &lt;- exp(seq(-7,30,length=1001))
fx &lt;- densigamma(xseq,alpha,beta)
plot(xseq,fx,
     log="xy",
     type="l",
     ylim=c(min(fx),1.01*max(fx)),
     yaxs="i",
     xlab="x, log scale",
     ylab="f(x), log scale",
     axes=FALSE)
axis(1)

title(substitute(list(alpha==a,beta==b),list(a=alpha,b=beta)))
q &lt;- igammaHDR(alpha,beta,debug=TRUE)
xlo &lt;- which.min(abs(q[1]-xseq))
xup &lt;- which.min(abs(q[2]-xseq))
plotZero &lt;- min(fx)
polygon(x=xseq[c(xlo,xlo:xup,xup:xlo)],
        y=c(plotZero,
          fx[xlo:xup],
          rep(plotZero,length(xlo:xup))),
        border=FALSE,
        col=gray(.45))
lines(xseq,fx,lwd=1.25)

## End(Not run)
</code></pre>

<hr>
<h2 id='iraqVote'>
U.S. Senate vote on the use of force against Iraq, 2002.	
</h2><span id='topic+iraqVote'></span>

<h3>Description</h3>

<p>On October 11, 2002, the United States Senate
voted 77-23 to authorize the use of military force against Iraq.  This data set lists the &ldquo;Ayes&rdquo; and &ldquo;Nays&rdquo; for each Senator and some covariates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(iraqVote)</code></pre>


<h3>Format</h3>

<p>A data frame with 100 observations on the following 6 variables.
</p>

<dl>
<dt><code>y</code></dt><dd><p>a numeric vector, the recorded vote (1 if Aye, 0 if Nay)</p>
</dd>
<dt><code>state.abb</code></dt><dd><p>two letter abbreviation for each state</p>
</dd>
<dt><code>name</code></dt><dd><p>senator name, party and state, e.g., <code>AKAKA (D HI)</code></p>
</dd>
<dt><code>rep</code></dt><dd><p>logical, <code>TRUE</code> for Republican senators</p>
</dd>
<dt><code>state.name</code></dt><dd><p>name of state</p>
</dd>
<dt><code>gorevote</code></dt><dd><p>numeric, the vote share recorded by Al Gore in the corresponding state in the 2000 Presidential election</p>
</dd>
</dl>



<h3>Details</h3>

<p>The only Republican to vote against the resolution was Lincoln
Chafee (Rhode Island); Democrats split 29-22 in favor of the
resolution.
</p>


<h3>Source</h3>

<p>Keith Poole, 107th Senate Roll Call Data. <a href="https://voteview.com/static/data/out/votes/S107_votes.ord">https://voteview.com/static/data/out/votes/S107_votes.ord</a>  The Iraq vote is vote number 617.
</p>
<p>David Leip's Atlas of U.S. Presidential Elections.  <a href="https://uselectionatlas.org">https://uselectionatlas.org</a> 
</p>


<h3>References</h3>

<p>Jackman, Simon. 2009.  <em>Bayesian Analysis for the Social Sciences</em>.  Wiley: Chichester.  Example 8.3.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(iraqVote)
## probit model
glm1 &lt;- glm(y ~ gorevote + rep,
            data=iraqVote,
            family=binomial(link=probit))
</code></pre>

<hr>
<h2 id='nj07'>rollcall object, National Journal key votes of 2007</h2><span id='topic+nj07'></span>

<h3>Description</h3>

<p>A rollcall object containing 99 rollcalls from the 2nd session of the 110th U.S. Senate,  
designated by <em>National Journal</em> as the &quot;key votes&quot; of 2007.  These data were used to by <em>National Journal</em> to rate (then Senator) Barack Obama was the &quot;most liberal senator&quot; in 2007.</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(nj07)</code></pre>


<h3>Format</h3>

<p>A <code><a href="#topic+rollcall">rollcall</a></code> object containing the recorded votes,
plus information identifying the legislators and the
rollcalls.
</p>


<h3>Details</h3>

<p>Note the coding scheme used by Poole and Rosenthal; Yea (1,2,3),
Nay (4,5,6) etc.</p>


<h3>Source</h3>

<p>Keith Poole's web site:
<a href="https://legacy.voteview.com/senate110.htm">https://legacy.voteview.com/senate110.htm</a>
</p>
<p>Originally scraped from the Senate's web site by Jeff Lewis.
</p>
<p>Josh Clinton compiled the list of <em>National Journal</em> key votes.  
</p>


<h3>References</h3>

<p>Clinton, Joshua and Simon Jackman.  2009. To Simulate or NOMINATE?  
<em>Legislative Studies Quarterly</em>. V34(4):593-621.
</p>
<p>Jackman, Simon.  2009. <em>Bayesian Analysis for the Social Sciences</em>. Wiley: Hoboken, New Jersey. Example 9.2. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(pscl)
data(nj07)
is(nj07,"rollcall")    ## TRUE
nj07                   ## print method for class rollcall
names(nj07)
names(nj07$vote.data)
table(nj07$vote.data$policyArea)
summary(nj07)          ## summary method
summary(nj07,verbose=TRUE)
</code></pre>

<hr>
<h2 id='ntable'>nicely formatted tables</h2><span id='topic+ntable'></span>

<h3>Description</h3>

<p>Nicely formatted tables, with row or column marginals etc.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ntable(x,y=NULL,
       percent=1,digits=2,
       row=FALSE,col=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ntable_+3A_x">x</code></td>
<td>
<p>vector or <code><a href="base.html#topic+factor">factor</a></code></p>
</td></tr>
<tr><td><code id="ntable_+3A_y">y</code></td>
<td>
<p>vector of <code><a href="base.html#topic+factor">factor</a></code></p>
</td></tr>
<tr><td><code id="ntable_+3A_percent">percent</code></td>
<td>
<p>integer, 1 for row percentages (default), 2 for column
percentages</p>
</td></tr>
<tr><td><code id="ntable_+3A_digits">digits</code></td>
<td>
<p>integer, digits to print after decimal place (default is 2)</p>
</td></tr>
<tr><td><code id="ntable_+3A_row">row</code></td>
<td>
<p>logical, if <code>TRUE</code>, print row marginals</p>
</td></tr>
<tr><td><code id="ntable_+3A_col">col</code></td>
<td>
<p>logical, if <code>TRUE</code>, print column marginals</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A wrapper function to <code><a href="base.html#topic+prop.table">prop.table</a></code> that produces prettier
looking results.
</p>


<h3>Value</h3>

<p>nothing returned; the function prints the table and
exits silently.
</p>


<h3>Author(s)</h3>

<p>Jim Fearon <a href="mailto:jfearon@stanford.edu">jfearon@stanford.edu</a></p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+prop.table">prop.table</a></code>, <code><a href="base.html#topic+table">table</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(bioChemists)
attach(bioChemists)
ntable(fem)
ntable(fem,mar,row=TRUE)
ntable(fem,mar,per=2,col=TRUE)
ntable(fem,mar,per=2,row=TRUE,col=TRUE)
</code></pre>

<hr>
<h2 id='odTest'>likelihood ratio test for over-dispersion in count data</h2><span id='topic+odTest'></span>

<h3>Description</h3>

<p>Compares the log-likelihoods of a negative binomial regression model
and a Poisson regression model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>odTest(glmobj, alpha=.05, digits = max(3, getOption("digits") - 3))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="odTest_+3A_glmobj">glmobj</code></td>
<td>
<p>an object of class <code>negbin</code> produced by
<code><a href="MASS.html#topic+glm.nb">glm.nb</a></code></p>
</td></tr>  
<tr><td><code id="odTest_+3A_alpha">alpha</code></td>
<td>
<p>significance level of over-dispersion test</p>
</td></tr>
<tr><td><code id="odTest_+3A_digits">digits</code></td>
<td>
<p> number of digits in printed output</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The negative binomial model relaxes the assumption in the
Poisson model that the (conditional) variance equals the (conditional)
mean, by estimating one extra parameter.  A likelihood ratio (LR) test
can be used to test the null hypothesis that the restriction implicit
in the Poisson model is true. The LR test-statistic has a non-standard
distribution, even asymptotically, since the negative binomial
over-dispersion parameter (called <code>theta</code> in <code>glm.nb</code>) is
restricted to be positive.  The asymptotic distribution of the LR
(likelihood ratio) test-statistic has probability mass of one half at
zero, and a half <code class="reqn">\chi^2_1</code> distribution above
zero.  This means that if testing at the <code class="reqn">\alpha</code> = .05
level, one should not reject the null unless the LR test statistic
exceeds the critical value associated with the <code class="reqn">2\alpha</code>
= .10 level; this LR test involves just one parameter restriction, so
the critical value of the test statistic at the <code class="reqn">p</code> = .05 level
is 2.7, instead of the usual 3.8 (i.e., the .90 quantile of the
<code class="reqn">\chi^2_1</code> distribution, versus the .95 quantile).
</p>
<p>A Poisson model is run using <code><a href="stats.html#topic+glm">glm</a></code> with family set to
<code>link{poisson}</code>, using the <code><a href="stats.html#topic+formula">formula</a></code> in the negbin
model object passed as input.  The <code><a href="stats.html#topic+logLik">logLik</a></code> functions are
used to extract the log-likelihood for each model.
</p>


<h3>Value</h3>

<p>None; prints results and returns silently</p>


<h3>Author(s)</h3>

<p>Simon Jackman <a href="mailto:simon.jackman@sydney.edu.au">simon.jackman@sydney.edu.au</a>.  John Fox noted an
error in an earlier version.</p>


<h3>References</h3>

<p>A. Colin Cameron and Pravin K. Trivedi (1998) <em>Regression
analysis of count data</em>. New York: Cambridge University Press.
</p>
<p>Lawless, J. F. (1987) Negative Binomial and Mixed Poisson
Regressions. <em>The Canadian Journal of Statistics</em>. 15:209-225.
</p>


<h3>See Also</h3>

<p><code><a href="MASS.html#topic+glm.nb">glm.nb</a></code>, <code><a href="stats.html#topic+logLik">logLik</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(bioChemists)
modelnb &lt;- MASS::glm.nb(art ~ .,
                 data=bioChemists,
                 trace=TRUE)
odTest(modelnb)
</code></pre>

<hr>
<h2 id='partycodes'>political parties appearing in the U.S. Congress</h2><span id='topic+partycodes'></span>

<h3>Description</h3>

<p>Numeric codes and names of 85 political parties appearing in Poole
and Rosenthal's collection of U.S. Congressional roll calls.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(partycodes)</code></pre>


<h3>Format</h3>


<dl>
<dt><code>code</code></dt><dd><p>integer, numeric code for legislator appearing in Poole and
Rosenthal rollcall data files</p>
</dd>
<dt><code>party</code></dt><dd><p>character, name of party</p>
</dd>
</dl>



<h3>Details</h3>

<p>The function <code><a href="#topic+readKH">readKH</a></code> converts the integer codes
into strings, via a table lookup in this data frame.</p>


<h3>Source</h3>

<p>Keith Poole's website: <a href="https://legacy.voteview.com/PARTY3.HTM">https://legacy.voteview.com/PARTY3.HTM</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+readKH">readKH</a></code>
</p>

<hr>
<h2 id='plot.ideal'>plots an ideal object</h2><span id='topic+plot.ideal'></span><span id='topic+plot1d'></span><span id='topic+plot2d'></span>

<h3>Description</h3>

<p>Plot of the results of an ideal point estimation contained
in an object of class <code>ideal</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ideal'
plot(x, conf.int=0.95, burnin=NULL, ...)

plot1d(x, d=1, conf.int=0.95, burnin=NULL,
       showAllNames = FALSE, ...)

plot2d(x, d1=1, d2=2, burnin=NULL,
       overlayCuttingPlanes=FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.ideal_+3A_x">x</code></td>
<td>
<p>an object of class <code><a href="#topic+ideal">ideal</a></code></p>
</td></tr>
<tr><td><code id="plot.ideal_+3A_conf.int">conf.int</code></td>
<td>
<p>for &quot;ideal&quot; objects with 1 dimension estimated, the
level of the confidence interval to plot around the
posterior mean for each legislator.  If 2 or more dimensions were
estimated, <code>conf.int</code> is ignored.</p>
</td></tr>
<tr><td><code id="plot.ideal_+3A_d">d</code></td>
<td>
<p>integer, which dimension to display in a 1d plot, if the
object is a multidimensional ideal object</p>
</td></tr></table>
<p>.
</p>
<table>
<tr><td><code id="plot.ideal_+3A_burnin">burnin</code></td>
<td>
<p>of the recorded MCMC samples, how many to discard as
burnin?  Default is <code>NULL</code>, in which case the value of
<code>burnin</code> in the <code><a href="#topic+ideal">ideal</a></code> object is used.</p>
</td></tr>
<tr><td><code id="plot.ideal_+3A_showallnames">showAllNames</code></td>
<td>
<p><code><a href="base.html#topic+logical">logical</a></code>, if <code>TRUE</code>, the
vertical axis will the names of all legislators. Default is
<code>FALSE</code> to reduce clutter on typical-sized graph.</p>
</td></tr>
<tr><td><code id="plot.ideal_+3A_d1">d1</code></td>
<td>
<p>integer, the number of the first dimension to plot when
plotting multi-dimensional <code><a href="#topic+ideal">ideal</a></code> objects.  This
dimension will appear on the horizontal (x) axis.</p>
</td></tr>
<tr><td><code id="plot.ideal_+3A_d2">d2</code></td>
<td>
<p>integer, the number of the second dimension to plot when
plotting multi-dimensional <code><a href="#topic+ideal">ideal</a></code> objects.  This dimension
will appear on the vertical (y) axis.</p>
</td></tr>
<tr><td><code id="plot.ideal_+3A_overlaycuttingplanes">overlayCuttingPlanes</code></td>
<td>
<p>logical, if <code>TRUE</code>, overlay the
estimated bill-specific cutting planes</p>
</td></tr>
<tr><td><code id="plot.ideal_+3A_...">...</code></td>
<td>
<p>other parameters to be passed through to plotting functions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p> If the <code>ideal</code> object comes from fitting a <code>d=1</code>
dimensional model, then <code>plot.ideal</code> plots the mean of the
posterior density over each legislator's ideal point, accompanied by a
<code>conf.int</code> confidence interval.  In this case, <code>plot.ideal</code>
is simply a wrapper function to <code><a href="#topic+plot1d">plot1d</a></code>.
</p>
<p>If the <code>ideal</code> object has <code>d=2</code> dimensions, then
<code><a href="#topic+plot2d">plot2d</a></code> is called, which plots the (estimated) mean of
the posterior density of each legislator's ideal point (i.e., the
ideal point/latent trait is a point in 2-dimensional Euclidean space,
and the posterior density for each ideal point is a bivariate
density).  Single dimension summaries of the estimated ideal points
(latent traits) can be obtained for multidimensional
<code><a href="#topic+ideal">ideal</a></code> objects by passing the <code><a href="#topic+ideal">ideal</a></code> object
directly to <code>plot1d</code> with <code>d</code> set appropriately.
</p>
<p>If the <code><a href="#topic+ideal">ideal</a></code> object has <code>d&gt;2</code> dimensions, a
scatterplot matrix is produced via <code><a href="graphics.html#topic+pairs">pairs</a></code>, with the
posterior means of the ideal points (latent traits) plotted against
one another, dimension by dimension.
</p>
<p>For unidimensional and two-dimensional models, if party information is
available in the <code>rollcall</code> object contained in the <code>ideal</code>
object, legislators from different parties are plotted in different
colors.  If the <code>ideal</code> object has more than 2 dimensions,
<code>plot.ideal()</code> produces a matrix of plots of the mean ideal
points of each dimension against the posterior mean ideal points of
the other dimensions.
</p>


<h3>Note</h3>

<p>When specifying a value of <code>burnin</code> different from that used
in fitting the <code><a href="#topic+ideal">ideal</a></code> object, note a distinction
between the iteration numbers of the stored iterations, and the
number of stored iterations.  That is, the <code>n</code>-th iteration
stored in an <code><a href="#topic+ideal">ideal</a></code> object will not be iteration
<code>n</code> if the user specified <code>thin&gt;1</code> in the call to
<code><a href="#topic+ideal">ideal</a></code>.  Here, iterations are tagged with their
iteration number.  Thus, if the user called <code><a href="#topic+ideal">ideal</a></code> with
<code>thin=10</code> and <code>burnin=100</code> then the stored iterations are
numbered <code>100, 110, 120, ...</code>.  Any future subsetting via a
<code>burnin</code> refers to this iteration number.</p>


<h3>See Also</h3>

<p><code><a href="#topic+ideal">ideal</a></code>;  
<code><a href="#topic+tracex">tracex</a></code> for trace plots, a graphical aid useful in
diagnosing convergence of the MCMC algorithms.</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(s109)
id1 &lt;- ideal(s109,
             d=1,
             normalize=TRUE,
             store.item=TRUE,
             maxiter=500,   ## short run for examples
             burnin=100,
             thin=10)  

plot(id1)


id2 &lt;- ideal(s109,
             d=2,
             store.item=TRUE,
             maxiter=11e2,
             burnin=1e2,
             verbose=TRUE,
             thin=25)

plot(id2,overlayCuttingPlanes=TRUE)

id2pp &lt;- postProcess(id2,
                     constraints=list(BOXER=c(-1,0),
                       INHOFE=c(1,0),
                       CHAFEE=c(0,.25)))

plot(id2pp,overlayCuttingPlanes=TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='plot.predict.ideal'>plot methods for predictions from ideal objects</h2><span id='topic+plot.predict.ideal'></span>

<h3>Description</h3>

<p>Plot classification success rates by legislators, or by roll calls,
using predictions from ideal.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'predict.ideal'
plot(x, type = c("legis", "votes"),...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.predict.ideal_+3A_x">x</code></td>
<td>
<p>an object of class <code><a href="#topic+predict.ideal">predict.ideal</a></code>.</p>
</td></tr>
<tr><td><code id="plot.predict.ideal_+3A_type">type</code></td>
<td>
<p>string; one of <code>legis</code> or <code>votes</code>.</p>
</td></tr>
<tr><td><code id="plot.predict.ideal_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>type="legis"</code> produces a plot of the &ldquo;percent correctly
predicted&rdquo; for each legislator/subject
(using the classification threshold set in
<code><a href="#topic+predict.ideal">predict.ideal</a></code>) against the estimated ideal point of each
legislator/subject (the estimated mean of the posterior density of the
ideal point), dimension at
a time.  If the legislators' party affiliations are available in the
<code><a href="#topic+rollcall">rollcall</a></code> object that was passed to <code><a href="#topic+ideal">ideal</a></code>,
then legislators from the same party are plotted with a unique color.
</p>
<p><code>type="votes"</code> produces a plot of classification rates for each
roll call, by the percentage of legislators voting for the losing
side.  The <code>x</code>-ordinate is jittered for clarity.
</p>


<h3>Value</h3>

<p>After drawing plots on the current device, exits silently returning <code>invisible(NULL)</code>.
</p>


<h3>Author(s)</h3>

<p>Simon Jackman <a href="mailto:simon.jackman@sydney.edu.au">simon.jackman@sydney.edu.au</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+predict.ideal">predict.ideal</a></code> <code><a href="#topic+ideal">ideal</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(s109)
f = system.file("extdata","id1.rda",package="pscl")
load(f)
phat &lt;- predict(id1)
plot(phat,type="legis")
plot(phat,type="votes")
</code></pre>

<hr>
<h2 id='plot.seatsVotes'>plot seats-votes curves</h2><span id='topic+plot.seatsVotes'></span>

<h3>Description</h3>

<p>Plot seats-votes curves produced by <code>seatsVotes</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'seatsVotes'
plot(x, type = c("seatsVotes", "density"),
                legend = "bottomright", transform=FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.seatsVotes_+3A_x">x</code></td>
<td>
<p>an object of class <code><a href="#topic+seatsVotes">seatsVotes</a></code></p>
</td></tr>
<tr><td><code id="plot.seatsVotes_+3A_type">type</code></td>
<td>
<p>character, partially matching the options above; see details</p>
</td></tr>
<tr><td><code id="plot.seatsVotes_+3A_legend">legend</code></td>
<td>
<p>where to put the legend when plotting with
<code>type="seatsVotes"</code></p>
</td></tr>
<tr><td><code id="plot.seatsVotes_+3A_transform">transform</code></td>
<td>
<p>logical, whether to transform the vote shares for
<code>type="density"</code>; see Details</p>
</td></tr> 
<tr><td><code id="plot.seatsVotes_+3A_...">...</code></td>
<td>
<p>arguments passed to or from other functions (e.g.,
options for the <code><a href="stats.html#topic+density">density</a></code> function, when
<code>type="density"</code>)</p>
</td></tr>  
</table>


<h3>Details</h3>

<p>A seats-votes curve (with various annotations) is produced
with option <code>type="seatsVotes"</code>.
</p>
<p>A density plot of the vote shares is
produced with <code>type="density"</code>. A bimodal density corresponds to
an electoral system with a proliferation of safe seats for both
parties, and a seats-votes curve that is relatively flat (or
&ldquo;unresponsive&rdquo;) in the neighborhood of average district-level
vote shares of 50 percent.  The density is fitted using the defaults
in the <code><a href="stats.html#topic+density">density</a></code> function, but with the density constrained
to fall to zero at the extremes of the data, via the <code>from</code> and
<code>to</code> options to density.  A <code><a href="graphics.html#topic+rug">rug</a></code> is added to the
density plot.
</p>
<p>If <code>transform=TRUE</code>, the vote shares are transformed prior to
plotting, so as to reduce the extent to which extreme vote shares
close to zero or 1 determine the shape of the density (i.e., this
option is available only for plots of <code>type="density"</code>).  The
transformation is a sinusoidal function, a scaled
&ldquo;log-odds/inverse-log-odds&rdquo; function mapping from (0,1) to
(0,1): i.e., <code class="reqn">f(x) = g(k\cdot h(x))</code> where
<code class="reqn">h(x)</code> is the log-odds transformation <code class="reqn">h(x) =
  \log(x/(1-x))</code>, <code class="reqn">k</code> is a scaling parameter
set to <code class="reqn">\sqrt{3}</code>, and <code class="reqn">g(x)</code> is the inverse-log-odds
transformation <code class="reqn">g(x) = \exp(x)/(1+\exp(x))</code>.  Note that this transformation is cosmetic, with
the effect of assigning more of the graphing region to be devoted to
marginal seats.
</p>


<h3>Value</h3>

<p>The function performs the requested plots and exits silently with
<code>invisible{NULL}</code>.
</p>


<h3>Author(s)</h3>

<p>Simon Jackman <a href="mailto:simon.jackman@sydney.edu.au">simon.jackman@sydney.edu.au</a></p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+density">density</a></code>, <code><a href="graphics.html#topic+rug">rug</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ca2006)
x &lt;- ca2006$D/(ca2006$D+ca2006$R)
sv &lt;- seatsVotes(x,
                 desc="Democratic Vote Shares, California 2006 congressional elections")

plot(sv)
plot(sv,type="density")
plot(sv,type="density",transform=TRUE)
</code></pre>

<hr>
<h2 id='politicalInformation'>Interviewer ratings of respondent levels of political information</h2><span id='topic+politicalInformation'></span>

<h3>Description</h3>

<p>Interviewers administering the 2000 American National Election Studies
assigned an ordinal rating to each respondent's &quot;general
level of information&quot; about politics and public affairs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(politicalInformation)</code></pre>


<h3>Format</h3>

<p>A data frame with 1807 observations on the following 8 variables.
</p>

<dl>
<dt><code>y</code></dt><dd><p>interviewer rating, a factor with levels <code>Very Low</code> <code>Fairly Low</code> <code>Average</code> <code>Fairly High</code> <code>Very High</code></p>
</dd>
<dt><code>collegeDegree</code></dt><dd><p>a factor with levels <code>No</code> <code>Yes</code></p>
</dd>
<dt><code>female</code></dt><dd><p>a factor with levels <code>No</code> <code>Yes</code></p>
</dd>
<dt><code>age</code></dt><dd><p>a numeric vector, respondent age in years</p>
</dd>
<dt><code>homeOwn</code></dt><dd><p>a factor with levels <code>No</code> <code>Yes</code></p>
</dd>
<dt><code>govt</code></dt><dd><p>a factor with levels <code>No</code> <code>Yes</code></p>
</dd>
<dt><code>length</code></dt><dd><p>a numeric vector, length of ANES pre-election
interview in minutes</p>
</dd>
<dt><code>id</code></dt><dd><p>a factor, unique identifier for each interviewer</p>
</dd>
</dl>



<h3>Details</h3>

<p>Seven respondents have missing data on the ordinal interviewer rating.
The covariates <code>age</code> and <code>length</code> also have some missing data.
</p>


<h3>Source</h3>

<p>The National Election Studies (www.electionstudies.org). THE 2000
NATIONAL ELECTION STUDY [dataset]. Ann Arbor, MI: University of
Michigan, Center for Political Studies [producer and distributor].  
</p>


<h3>References</h3>

<p>Jackman, Simon. 2009.  <em>Bayesian Analysis for the Social
Sciences</em>.  Wiley: Hoboken, New Jersey.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(politicalInformation)

table(politicalInformation$y,exclude=NULL)

op &lt;- MASS::polr(y ~ collegeDegree + female + log(age) + homeOwn + govt + log(length),
           data=politicalInformation,
           Hess=TRUE,
           method="probit")
</code></pre>

<hr>
<h2 id='postProcess'>remap MCMC output via affine transformations</h2><span id='topic+postProcess'></span>

<h3>Description</h3>

<p>Remap the MCMC iterates in an <code><a href="#topic+ideal">ideal</a></code> object via an affine
transformation, imposing identifying restrictions ex post (aka
post-processing).</p>


<h3>Usage</h3>

<pre><code class='language-R'>postProcess(object, constraints="normalize", debug = FALSE)
</code></pre>


<h3>Arguments</h3>

 <table>
<tr><td><code id="postProcess_+3A_object">object</code></td>
<td>
<p>an object of class <code><a href="#topic+ideal">ideal</a></code></p>
</td></tr>
<tr><td><code id="postProcess_+3A_constraints">constraints</code></td>
<td>
<p>list of length <code>d+1</code>, each component providing
a set of <code>d</code> restrictions, where <code>d</code> is the dimension of the
fitted <code><a href="#topic+ideal">ideal</a></code> model; or the character string
<code>normalize</code> (default).  If a list, the name of each component should
uniquely match a legislator/subject's name.  See Details.</p>
</td></tr>
<tr><td><code id="postProcess_+3A_debug">debug</code></td>
<td>
<p>logical flag for verbose output, used for debugging</p>
</td></tr> </table>


<h3>Details</h3>

<p>Item-response models are unidentified without restrictions on the
underlying parameters.  Consider the <code>d=1</code> dimensional case. The
model is
</p>
<p style="text-align: center;"><code class="reqn">P(y_{ij} = 1) = F(x_i \beta_j - \alpha_j)</code>
</p>

<p>Any
linear transformation of the latent traits, say,
</p>
<p style="text-align: center;"><code class="reqn">x^* = mx + c</code>
</p>

<p>can be exactly offset by applying the appropriate linear
transformations to the item/bill parameters, meaning that there is no
unique set of values for the model parameters that will maximize the
likelihood function.  In higher dimensions,
the latent traits can also be transformed via any arbitrary rotation,
dilation and translation, with offsetting transformations applied to
the item/bill parameters.
</p>
<p>One strategy in MCMC is to ignore the lack of identification at run
time, but apply identifying restrictions ex post,
&ldquo;post-processing&rdquo; the MCMC output, iteration-by-iteration.  In
a <code>d</code>-dimensional IRT model, a sufficient condition for global
identification is to fix <code>d+1</code> latent traits, provided the
constrained latent traits span the <code>d</code> dimensional latent space.
This function implements this strategy.  The user supplies a set of
constrained ideal points in the <code>constraints</code> list.  The function
then processes the MCMC output in the <code><a href="#topic+ideal">ideal</a></code>
<code>object</code>, finding the transformation that maps the current
iteration's sampled values for <code>x</code> (latent traits/ideal points)
into the sub-space of identified parameters defined by the fixed
points in <code>constraints</code>; i.e., what is the affine transformation
that maps the unconstrained ideal points into the constraints?  Aside
from minuscule numerical inaccuracies resulting from matrix inversion
etc, this transformation is exact: after post-processing, the
<code>d+1</code> constrained points do not vary over the MCMC iterations.
The remaining <code>n-d-1</code> ideal points are subject to (posterior)
uncertainty; the &ldquo;random tour&rdquo; of the joint parameter space of
these parameters produced by the MCMC algorithm has been mapped into a
subspace in which the parameters are globally identified.
</p>
<p>If the <code><a href="#topic+ideal">ideal</a></code> object was produced with <code>store.item</code>
set to <code>TRUE</code>, then the item parameters are also post-processed,
applying the inverse transformation.  Specifically, recall that the
IRT model is </p>
<p style="text-align: center;"><code class="reqn">P(y_{ij} = 1) = F(x_i'\beta_j)</code>
</p>

<p>where in this formulation <code class="reqn">x_i</code> is a vector of
length <code>d+1</code>, including a <code>-1</code> to put a constant term into
the model (i.e., the intercept or difficulty parameter
is part of <code class="reqn">\beta_j</code>).  Let <code class="reqn">A</code> denote the
non-singular, <code>d+1</code>-by-<code>d+1</code> matrix that maps the <code class="reqn">x</code>
into the space of identified parameters.  Recall that this
transformation is computed iteration by iteration.  Then each
<code class="reqn">x_i</code> is transformed to <code class="reqn">x^*_i = Ax_i</code> and
<code class="reqn">\beta_j</code> is transformed to <code class="reqn">\beta_j^* = A^{-1}
    \beta_j</code>, <code class="reqn">i = 1, \ldots, n; j = 1,
    \ldots, m</code>.
</p>
<p>Local identification can be obtained for a one-dimensional model by
simply imposing a normalizing restriction on the ideal points: this
normalization (mean zero, standard deviation one) is the default
behavior, but (a) is only sufficient for local identification when
the <code>rollcall</code> object was fit with <code>d=1</code>; (b) is not
sufficient for even local identification when <code>d&gt;1</code>, with
further restrictions required so as to rule out other forms of
invariance (e.g., translation, or &quot;dimension-switching&quot;, a
phenomenon akin to label-switching in mixture modeling).
</p>
<p>The default is to impose dimension-by-dimension normalization with
respect to the means of the marginal posterior densities of the
ideal points, such that the these means (the usual Bayes estimates
of the ideal points) have mean zero and standard deviation one
across legislators.  An offsetting transformation is applied to the
items parameters as well, if they are saved in the <code>ideal</code> object.  
</p>
<p>Specifically, in one-dimension, the
two-parameter IRT model is </p>
<p style="text-align: center;"><code class="reqn">P(y_{ij} = 1) = F(x_i \beta_j -
  \alpha_j).</code>
</p>
<p>  If we normalize the
<code class="reqn">x_i</code> to <code class="reqn">x*_i = (x_i - c)/m</code> then the offsetting
transformations for the item/bill parameters are <code class="reqn">\beta_j^* =
  \beta_j m</code> and <code class="reqn">\alpha_j^* = \alpha_j -
  c\beta_j</code>.
</p>


<h3>Value</h3>

<p>An object of class <code><a href="#topic+ideal">ideal</a></code>, with components suitably
transformed and recomputed (i.e., <code>x</code> is transformed and
<code>xbar</code> recomputed, and if the
<code><a href="#topic+ideal">ideal</a></code> object was fit with <code>store.item=TRUE</code>,
<code>beta</code> is transformed and <code>betabar</code> is recomputed).
</p>


<h3>Note</h3>

<p>Applying transformations to obtain identification can
sometimes lead to surprising results.  Each data point makes the same
likelihood contributions with either the identified or unidentified
parameters.  But, in general, predictions generated with the
parameters set to their posterior means will differ depending on
whether one uses the identified subset of parameters or the
unidentified parameters.  For this reason, caution should be used when
using a function such as <code><a href="stats.html#topic+predict">predict</a></code> after post-processing
output from <code><a href="#topic+ideal">ideal</a></code>.  A better strategy is to compute the
estimand of interest at each iteration and then take averages over
iterations.
</p>
<p>When specifying a value of <code>burnin</code> different from that used in
fitting the <code><a href="#topic+ideal">ideal</a></code> object, note a distinction between
the iteration numbers of the stored iterations, and the number of
stored iterations.  That is, the <code>n</code>-th iteration stored in an
<code><a href="#topic+ideal">ideal</a></code> object will not be iteration <code>n</code> if the
user specified <code>thin&gt;1</code> in the call to <code><a href="#topic+ideal">ideal</a></code>.
Here, iterations are tagged with their iteration number.  Thus, if
the user called <code><a href="#topic+ideal">ideal</a></code> with <code>thin=10</code> and
<code>burnin=100</code> then the stored iterations are numbered <code>100,
    110, 120, ...</code>.  Any future subsetting via a <code>burnin</code> refers to
this iteration number.
</p>


<h3>Author(s)</h3>

<p>Simon Jackman <a href="mailto:simon.jackman@sydney.edu.au">simon.jackman@sydney.edu.au</a></p>


<h3>References</h3>

<p>Hoff, Peter, Adrian E. Raftery and Mark S. Handcock. 2002.
Latent Space Approaches to Social Network Analysis. <em>Journal
of the American Statistical Association</em> 97:1090&ndash;1098.
</p>
<p>Edwards, Yancy D. and Greg M. Allenby. 2003.
Multivariate Analysis of Multiple Response Data. <em>Journal of
Marketing Research</em> 40:321&ndash;334.
</p>
<p>Rivers, Douglas. 2003.  &ldquo;Identification of Multidimensional
Item-Response Models.&rdquo; Typescript.  Department of Political Science,
Stanford University.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(s109)
f = system.file("extdata",package="pscl","id1.rda")
load(f)

id1Local &lt;- postProcess(id1)    ## default is to normalize
summary(id1Local)

id1pp &lt;- postProcess(id1,
                     constraints=list(BOXER=-1,INHOFE=1))
summary(id1pp)

## two-dimensional fit
f = system.file("extdata",package="pscl","id2.rda")
load(f)

id2pp &lt;- postProcess(id2,
                     constraints=list(BOXER=c(-1,0),
                       INHOFE=c(1,0),
                       CHAFEE=c(0,.25)))

tracex(id2pp,d=1:2,
       legis=c("BOXER","INHOFE","COLLINS","FEINGOLD","COLEMAN",
         "CHAFEE","MCCAIN","KYL"))
</code></pre>

<hr>
<h2 id='pR2'>compute various pseudo-R2 measures</h2><span id='topic+pR2'></span>

<h3>Description</h3>

<p>compute various pseudo-R2 measures for various GLMs
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pR2(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pR2_+3A_object">object</code></td>
<td>
<p>a fitted model object for which <code>logLik</code>,
<code>update</code>, and <code>model.frame</code> methods exist (e.g.,
an object of class <code>glm</code>, <code>polr</code>, or <code>multinom</code>)</p>
</td></tr>
<tr><td><code id="pR2_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to or from functions</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Numerous pseudo r-squared measures have been proposed for
generalized linear models, involving a comparison of the
log-likelihood for the fitted model against the log-likelihood of a
null/restricted model with no predictors, normalized to run from zero
to one as the fitted model provides a better fit to the data
(providing a rough analogue to the computation of r-squared in a
linear regression).  </p>


<h3>Value</h3>

<p>A vector of length 6 containing
</p>
<table>
<tr><td><code>llh</code></td>
<td>
<p>The log-likelihood from the fitted model</p>
</td></tr>
<tr><td><code>llhNull</code></td>
<td>
<p>The log-likelihood from the intercept-only restricted
model</p>
</td></tr>
<tr><td><code>G2</code></td>
<td>
<p>Minus two times the difference in the log-likelihoods</p>
</td></tr>
<tr><td><code>McFadden</code></td>
<td>
<p>McFadden's pseudo r-squared</p>
</td></tr>
<tr><td><code>r2ML</code></td>
<td>
<p>Maximum likelihood pseudo r-squared</p>
</td></tr>
<tr><td><code>r2CU</code></td>
<td>
<p>Cragg and Uhler's pseudo r-squared</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Simon Jackman <a href="mailto:simon.jackman@sydney.edu.au">simon.jackman@sydney.edu.au</a></p>


<h3>References</h3>

<p>Long, J. Scott. 1997. <em>Regression Models for Categorical and
Limited Dependent Variables</em>.  Sage.  pp104-106.</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+extractAIC">extractAIC</a></code>, <code><a href="stats.html#topic+logLik">logLik</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(admit)
## ordered probit model
op1 &lt;- MASS::polr(score ~ gre.quant + gre.verbal + ap + pt + female,
            Hess=TRUE,
            data=admit,
            method="probit")
pR2(op1)   
</code></pre>

<hr>
<h2 id='predict.hurdle'>Methods for hurdle Objects</h2><span id='topic+predict.hurdle'></span><span id='topic+residuals.hurdle'></span><span id='topic+terms.hurdle'></span><span id='topic+model.matrix.hurdle'></span><span id='topic+coef.hurdle'></span><span id='topic+vcov.hurdle'></span><span id='topic+summary.hurdle'></span><span id='topic+print.summary.hurdle'></span><span id='topic+logLik.hurdle'></span><span id='topic+fitted.hurdle'></span><span id='topic+predprob.hurdle'></span><span id='topic+extractAIC.hurdle'></span>

<h3>Description</h3>

<p>Methods for extracting information from fitted hurdle
regression model objects of class <code>"hurdle"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'hurdle'
predict(object, newdata,
  type = c("response", "prob", "count", "zero"), na.action = na.pass,
  at = NULL, ...)
## S3 method for class 'hurdle'
residuals(object, type = c("pearson", "response"), ...)

## S3 method for class 'hurdle'
coef(object, model = c("full", "count", "zero"), ...)
## S3 method for class 'hurdle'
vcov(object, model = c("full", "count", "zero"), ...)

## S3 method for class 'hurdle'
terms(x, model = c("count", "zero"), ...)
## S3 method for class 'hurdle'
model.matrix(object, model = c("count", "zero"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.hurdle_+3A_object">object</code>, <code id="predict.hurdle_+3A_x">x</code></td>
<td>
<p>an object of class <code>"hurdle"</code> as returned by
<code><a href="#topic+hurdle">hurdle</a></code>.</p>
</td></tr>
<tr><td><code id="predict.hurdle_+3A_newdata">newdata</code></td>
<td>
<p>optionally, a data frame in which to look for variables with
which to predict. If omitted, the original observations are used.</p>
</td></tr>
<tr><td><code id="predict.hurdle_+3A_type">type</code></td>
<td>
<p>character specifying the type of predictions or residuals,
respectively. For details see below.</p>
</td></tr>
<tr><td><code id="predict.hurdle_+3A_na.action">na.action</code></td>
<td>
<p>function determining what should be done with missing values
in <code>newdata</code>. The default is to predict <code>NA</code>.</p>
</td></tr>
<tr><td><code id="predict.hurdle_+3A_at">at</code></td>
<td>
<p>optionally, if <code>type = "prob"</code>, a numeric vector at which
the probabilities are evaluated. By default <code>0:max(y)</code> is used
where <code>y</code> is the original observed response.</p>
</td></tr>
<tr><td><code id="predict.hurdle_+3A_model">model</code></td>
<td>
<p>character specifying for which component of the model the
terms or model matrix should be extracted.</p>
</td></tr>
<tr><td><code id="predict.hurdle_+3A_...">...</code></td>
<td>
<p>currently not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A set of standard extractor functions for fitted model objects is available for
objects of class <code>"hurdle"</code>, including methods to the generic functions
<code><a href="base.html#topic+print">print</a></code> and <code><a href="base.html#topic+summary">summary</a></code> which print the estimated
coefficients along with some further information. The <code>summary</code> in particular
supplies partial Wald tests based on the coefficients and the covariance matrix
(estimated from the Hessian in the numerical optimization of the log-likelihood).
As usual, the <code>summary</code> method returns an object of class <code>"summary.hurdle"</code>
containing the relevant summary statistics which can subsequently be printed
using the associated <code>print</code> method.
</p>
<p>The methods for <code><a href="stats.html#topic+coef">coef</a></code> and <code><a href="stats.html#topic+vcov">vcov</a></code> by default
return a single vector of coefficients and their associated covariance matrix,
respectively, i.e., all coefficients are concatenated. By setting the <code>model</code>
argument, the estimates for the corresponding model component can be extracted.
</p>
<p>Both the <code><a href="stats.html#topic+fitted">fitted</a></code> and <code><a href="stats.html#topic+predict">predict</a></code> methods can
compute fitted responses. The latter additionally provides the predicted density
(i.e., probabilities for the observed counts), the predicted mean from the count
component (without zero hurdle) and the predicted ratio of probabilities for
observing a non-zero count. The latter is the ratio of probabilities for a non-zero
implied by the zero hurdle component and a non-zero count in the non-truncated
count distribution. See also Appendix C in Zeileis et al. (2008).
</p>
<p>The <code><a href="stats.html#topic+residuals">residuals</a></code> method can compute raw residuals
(observed - fitted) and Pearson residuals (raw residuals scaled by
square root of variance function).
</p>
<p>The <code><a href="stats.html#topic+terms">terms</a></code> and <code><a href="stats.html#topic+model.matrix">model.matrix</a></code> extractors can
be used to extract the relevant information for either component of the model.
</p>
<p>A <code><a href="stats.html#topic+logLik">logLik</a></code> method is provided, hence <code><a href="stats.html#topic+AIC">AIC</a></code>
can be called to compute information criteria.
</p>


<h3>Author(s)</h3>

<p>Achim Zeileis &lt;Achim.Zeileis@R-project.org&gt;</p>


<h3>References</h3>

<p>Zeileis, Achim, Christian Kleiber and Simon Jackman 2008.
&ldquo;Regression Models for Count Data in R.&rdquo; 
<em>Journal of Statistical Software</em>, <b>27</b>(8).
URL <a href="https://www.jstatsoft.org/v27/i08/">https://www.jstatsoft.org/v27/i08/</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+hurdle">hurdle</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data("bioChemists", package = "pscl")
fm &lt;- hurdle(art ~ ., data = bioChemists)

plot(residuals(fm) ~ fitted(fm))

coef(fm)
coef(fm, model = "zero")

summary(fm)
logLik(fm)
</code></pre>

<hr>
<h2 id='predict.ideal'>predicted probabilities from an ideal object</h2><span id='topic+predict.ideal'></span><span id='topic+print.predict.ideal'></span>

<h3>Description</h3>

<p>Compute predicted probabilities from an <code><a href="#topic+ideal">ideal</a></code>
object.  This predict method uses the posterior mean values of <code class="reqn">x</code>
and <code class="reqn">\beta</code> to make predictions.</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ideal'
predict(object,
                        cutoff=.5,
                        burnin=NULL,
                        ...)

## S3 method for class 'predict.ideal'
print(x,digits=2,...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.ideal_+3A_object">object</code></td>
<td>
<p>an object of class <code>ideal</code> (produced by
<code><a href="#topic+ideal">ideal</a></code>) with item parameters (beta) stored; i.e.,
<code>store.item=TRUE</code> was set when the <code>ideal</code> object was
fitted</p>
</td></tr> 
<tr><td><code id="predict.ideal_+3A_cutoff">cutoff</code></td>
<td>
<p>numeric, a value between 0 and 1, the threshold to be
used for classifying predicted probabilities of a Yea 
votes as predicted Yea and Nay votes.</p>
</td></tr>
<tr><td><code id="predict.ideal_+3A_burnin">burnin</code></td>
<td>
<p>of the recorded MCMC samples, how many to discard as
burnin?  Default is <code>NULL</code>, in which case the value of
<code>burnin</code> in the <code><a href="#topic+ideal">ideal</a></code> object is used.</p>
</td></tr>
<tr><td><code id="predict.ideal_+3A_x">x</code></td>
<td>
<p>object of class <code>predict.ideal</code></p>
</td></tr>
<tr><td><code id="predict.ideal_+3A_digits">digits</code></td>
<td>
<p>number of digits in printed object</p>
</td></tr>
<tr><td><code id="predict.ideal_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>  
</table>


<h3>Details</h3>

<p>Predicted probabilities are computed using the mean of the posterior
density of
of <code class="reqn">x</code> (ideal points, or latent ability) and <code class="reqn">\beta</code> (bill or
item parameters).  The percentage correctly predicted
are determined by counting the percentages of votes with predicted
probabilities of a Yea vote greater than or equal to the <code>cutoff</code> as the
threshold.
</p>


<h3>Value</h3>

<p>An object of class <code>predict.ideal</code>, containing:
</p>
<table>
<tr><td><code>pred.probs</code></td>
<td>
<p>the calculated predicted probability for each
legislator for each vote.</p>
</td></tr>
<tr><td><code>prediction</code></td>
<td>
<p>the calculated prediction (0 or 1) for each
legislator for each vote.</p>
</td></tr>
<tr><td><code>correct</code></td>
<td>
<p>for each legislator for each vote, whether the
prediction was correct.</p>
</td></tr>
<tr><td><code>legis.percent</code></td>
<td>
<p>for each legislator, the percent of votes
correctly predicted.</p>
</td></tr>
<tr><td><code>vote.percent</code></td>
<td>
<p>for each vote, the percent correctly predicted.</p>
</td></tr>
<tr><td><code>yea.percent</code></td>
<td>
<p>the percent of yea votes correctly predicted.</p>
</td></tr>
<tr><td><code>nay.percent</code></td>
<td>
<p>the percent of nay votes correctly predicted.</p>
</td></tr>
<tr><td><code>party.percent</code></td>
<td>
<p>the average value of the percent correctly
predicted by legislator, separated by party, if party information
exists in the <code>rollcall</code> object used for <code>ideal</code>.  If no
party information is available, <code>party.percent = NULL</code>.</p>
</td></tr>
<tr><td><code>overall.percent</code></td>
<td>
<p>the total percent of votes correctly
predicted.</p>
</td></tr>
<tr><td><code>ideal</code></td>
<td>
<p>the name of the <code><a href="#topic+ideal">ideal</a></code> object, which can be
later <code><a href="base.html#topic+eval">eval</a></code>uated</p>
</td></tr>
<tr><td><code>desc</code></td>
<td>
<p>string, the descriptive text from the
<code><a href="#topic+rollcall">rollcall</a></code> object passed to <code><a href="#topic+ideal">ideal</a></code></p>
</td></tr>
</table>


<h3>Note</h3>

<p>When specifying a value of <code>burnin</code> different from that used
in fitting the <code><a href="#topic+ideal">ideal</a></code> object, note a distinction
between the iteration numbers of the stored iterations, and the
number of stored iterations.  That is, the <code>n</code>-th iteration
stored in an <code><a href="#topic+ideal">ideal</a></code> object will not be iteration
<code>n</code> if the user specified <code>thin&gt;1</code> in the call to
<code><a href="#topic+ideal">ideal</a></code>.  Here, iterations are tagged with their
iteration number.  Thus, if the user called <code><a href="#topic+ideal">ideal</a></code> with
<code>thin=10</code> and <code>burnin=100</code> then the stored iterations are
numbered <code>100, 110, 120, ...</code>.  Any future subsetting via a
<code>burnin</code> refers to this iteration number.</p>


<h3>See Also</h3>

<p><code><a href="#topic+ideal">ideal</a></code>, <code><a href="#topic+summary.ideal">summary.ideal</a></code>, <code><a href="#topic+plot.predict.ideal">plot.predict.ideal</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(s109)

f &lt;- system.file("extdata","id1.rda",package="pscl")
load(f)
phat &lt;- predict(id1)
phat         ## print method
</code></pre>

<hr>
<h2 id='predict.zeroinfl'>Methods for zeroinfl Objects</h2><span id='topic+predict.zeroinfl'></span><span id='topic+residuals.zeroinfl'></span><span id='topic+terms.zeroinfl'></span><span id='topic+model.matrix.zeroinfl'></span><span id='topic+coef.zeroinfl'></span><span id='topic+vcov.zeroinfl'></span><span id='topic+summary.zeroinfl'></span><span id='topic+print.summary.zeroinfl'></span><span id='topic+logLik.zeroinfl'></span><span id='topic+fitted.zeroinfl'></span><span id='topic+predprob.zeroinfl'></span><span id='topic+extractAIC.zeroinfl'></span>

<h3>Description</h3>

<p>Methods for extracting information from fitted zero-inflated
regression model objects of class <code>"zeroinfl"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'zeroinfl'
predict(object, newdata,
  type = c("response", "prob", "count", "zero"), na.action = na.pass,
  at = NULL, ...)
## S3 method for class 'zeroinfl'
residuals(object, type = c("pearson", "response"), ...)

## S3 method for class 'zeroinfl'
coef(object, model = c("full", "count", "zero"), ...)
## S3 method for class 'zeroinfl'
vcov(object, model = c("full", "count", "zero"), ...)

## S3 method for class 'zeroinfl'
terms(x, model = c("count", "zero"), ...)
## S3 method for class 'zeroinfl'
model.matrix(object, model = c("count", "zero"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.zeroinfl_+3A_object">object</code>, <code id="predict.zeroinfl_+3A_x">x</code></td>
<td>
<p>an object of class <code>"zeroinfl"</code> as returned by
<code><a href="#topic+zeroinfl">zeroinfl</a></code>.</p>
</td></tr>
<tr><td><code id="predict.zeroinfl_+3A_newdata">newdata</code></td>
<td>
<p>optionally, a data frame in which to look for variables with
which to predict. If omitted, the original observations are used.</p>
</td></tr>
<tr><td><code id="predict.zeroinfl_+3A_type">type</code></td>
<td>
<p>character specifying the type of predictions or residuals,
respectively. For details see below.</p>
</td></tr>
<tr><td><code id="predict.zeroinfl_+3A_na.action">na.action</code></td>
<td>
<p>function determining what should be done with missing values
in <code>newdata</code>. The default is to predict <code>NA</code>.</p>
</td></tr>
<tr><td><code id="predict.zeroinfl_+3A_at">at</code></td>
<td>
<p>optionally, if <code>type = "prob"</code>, a numeric vector at which
the probabilities are evaluated. By default <code>0:max(y)</code> is used
where <code>y</code> is the original observed response.</p>
</td></tr>
<tr><td><code id="predict.zeroinfl_+3A_model">model</code></td>
<td>
<p>character specifying for which component of the model the
terms or model matrix should be extracted.</p>
</td></tr>
<tr><td><code id="predict.zeroinfl_+3A_...">...</code></td>
<td>
<p>currently not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A set of standard extractor functions for fitted model objects is available for
objects of class <code>"zeroinfl"</code>, including methods to the generic functions
<code><a href="base.html#topic+print">print</a></code> and <code><a href="base.html#topic+summary">summary</a></code> which print the estimated
coefficients along with some further information. The <code>summary</code> in particular
supplies partial Wald tests based on the coefficients and the covariance matrix
(estimated from the Hessian in the numerical optimization of the log-likelihood).
As usual, the <code>summary</code> method returns an object of class <code>"summary.zeroinfl"</code>
containing the relevant summary statistics which can subsequently be printed
using the associated <code>print</code> method.
</p>
<p>The methods for <code><a href="stats.html#topic+coef">coef</a></code> and <code><a href="stats.html#topic+vcov">vcov</a></code> by default
return a single vector of coefficients and their associated covariance matrix,
respectively, i.e., all coefficients are concatenated. By setting the <code>model</code>
argument, the estimates for the corresponding model components can be extracted.
</p>
<p>Both the <code><a href="stats.html#topic+fitted">fitted</a></code> and <code><a href="stats.html#topic+predict">predict</a></code> methods can
compute fitted responses. The latter additionally provides the predicted density
(i.e., probabilities for the observed counts), the predicted mean from the count
component (without zero inflation) and the predicted probability for the zero
component. The <code><a href="stats.html#topic+residuals">residuals</a></code> method can compute
raw residuals (observed - fitted) and Pearson residuals (raw residuals scaled by
square root of variance function).
</p>
<p>The <code><a href="stats.html#topic+terms">terms</a></code> and <code><a href="stats.html#topic+model.matrix">model.matrix</a></code> extractors can
be used to extract the relevant information for either component of the model.
</p>
<p>A <code><a href="stats.html#topic+logLik">logLik</a></code> method is provided, hence <code><a href="stats.html#topic+AIC">AIC</a></code>
can be called to compute information criteria.
</p>


<h3>Author(s)</h3>

<p>Achim Zeileis &lt;Achim.Zeileis@R-project.org&gt;</p>


<h3>See Also</h3>

<p><code><a href="#topic+zeroinfl">zeroinfl</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data("bioChemists", package = "pscl")

fm_zip &lt;- zeroinfl(art ~ ., data = bioChemists)
plot(residuals(fm_zip) ~ fitted(fm_zip))

coef(fm_zip)
coef(fm_zip, model = "count")

summary(fm_zip)
logLik(fm_zip)
</code></pre>

<hr>
<h2 id='predprob'>compute predicted probabilities from fitted models</h2><span id='topic+predprob'></span>

<h3>Description</h3>

<p>Compute predicted probabilities from fitted models, optionally at new
covariate values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>predprob(obj, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predprob_+3A_obj">obj</code></td>
<td>
<p>fitted model object</p>
</td></tr>
<tr><td><code id="predprob_+3A_...">...</code></td>
<td>
<p>other arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See documentation for specific methods.
</p>


<h3>Value</h3>

<p>A matrix of predicted probabilities, each row a vector of
predicted probabilities over the range of responses seen in the data
(i.e., <code>min(y):max(y)</code>), conditional on the values of covariates. 
</p>


<h3>Author(s)</h3>

<p>Simon Jackman <a href="mailto:simon.jackman@sydney.edu.au">simon.jackman@sydney.edu.au</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+predprob.glm">predprob.glm</a></code>, <code><a href="#topic+predprob.zeroinfl">predprob.zeroinfl</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data("bioChemists")
zip &lt;- zeroinfl(art ~ . | ., data = bioChemists, EM = TRUE)
phat &lt;- predprob(zip)

newdata &lt;- expand.grid(list(fem="Men",mar="Married",
                            kid5=1,phd=3.103,
                            ment=0:77))
phat &lt;- predprob(zip, newdata = newdata)

## End(Not run)
</code></pre>

<hr>
<h2 id='predprob.glm'>Predicted Probabilities for GLM Fits</h2><span id='topic+predprob.glm'></span>

<h3>Description</h3>

<p>Obtains predicted probabilities from a fitted generalized linear model
object. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'glm'
predprob(obj, newdata = NULL, at = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predprob.glm_+3A_obj">obj</code></td>
<td>
<p>a fitted object of class inheriting from <code>"glm"</code></p>
</td></tr>
<tr><td><code id="predprob.glm_+3A_newdata">newdata</code></td>
<td>
<p>optionally, a data frame in which to look for variables
with which to predict.  If omitted, the fitted linear predictors are
used.</p>
</td></tr>
<tr><td><code id="predprob.glm_+3A_at">at</code></td>
<td>
<p>an optional numeric vector at which the probabilities are
evaluated. By default <code>0:max(y)</code> where <code>y</code> is the original
observed response.</p>
</td></tr>
<tr><td><code id="predprob.glm_+3A_...">...</code></td>
<td>
<p>arguments passed to or from other methods</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This method is only defined for glm objects with
<code>family=<a href="stats.html#topic+binomial">binomial</a></code> or <code>family=<a href="stats.html#topic+poisson">poisson</a></code>, or negative
binomial count models fit with the <code><a href="MASS.html#topic+glm.nb">glm.nb</a></code> function in <code>library(MASS)</code>.
</p>


<h3>Value</h3>

<p>A matrix of predicted probabilities.  Each row in the matrix is a
vector of probabilities, assigning predicted probabilities over the range of
responses actually observed in the data.  For instance, for models
with <code>family=binomial</code>, the matrix has two columns for the &quot;zero&quot;
(or failure) and &quot;one&quot; (success) outcomes, respectively, and
trivially, each row in the matrix sums to 1.0. 
For counts fit with <code>family=poisson</code> or via <code>glm.nb</code>, the
matrix has <code>length(0:max(y))</code> columns.  Each observation
used in fitting the model generates a row to the returned matrix; alternatively, if
<code>newdata</code> is supplied, the returned matrix will have as many rows
as in <code>newdata</code>.
</p>


<h3>Author(s)</h3>

<p>Simon Jackman <a href="mailto:simon.jackman@sydney.edu.au">simon.jackman@sydney.edu.au</a></p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+predict.glm">predict.glm</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(bioChemists)
glm1 &lt;- glm(art ~ .,
            data=bioChemists,
            family=poisson,
            trace=TRUE)  ## poisson GLM
phat &lt;- predprob(glm1)
apply(phat,1,sum)                    ## almost all 1.0
</code></pre>

<hr>
<h2 id='predprob.ideal'>predicted probabilities from fitting ideal to rollcall data</h2><span id='topic+predprob.ideal'></span>

<h3>Description</h3>

<p>Computes predicted probabilities of a &ldquo;Yea&rdquo; vote conditional on
the posterior means of the legislators' ideal points and
vote-specific parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ideal'
predprob(obj, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predprob.ideal_+3A_obj">obj</code></td>
<td>
<p>An object of class <code><a href="#topic+ideal">ideal</a></code></p>
</td></tr>
<tr><td><code id="predprob.ideal_+3A_...">...</code></td>
<td>
<p>Arguments to be passed to other functions</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a wrapper function to <code><a href="#topic+predict.ideal">predict.ideal</a></code>, extracting
just the predicted probabilities component of the object returned by
that function.  Predicted probabilities can and are generated for each
voting decision, irrespective of whether the legislator actually voted
on any particular roll call.
</p>


<h3>Value</h3>

<p>A <code><a href="base.html#topic+matrix">matrix</a></code> of dimension <code>n</code> (number of legislators)
by <code>m</code> (number of roll call votes).
</p>


<h3>Author(s)</h3>

<p>Simon Jackman <a href="mailto:simon.jackman@sydney.edu.au">simon.jackman@sydney.edu.au</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+ideal">ideal</a></code>, <code><a href="#topic+predprob">predprob</a></code>, <code><a href="#topic+predict.ideal">predict.ideal</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>f &lt;- system.file("extdata","id1.rda",package="pscl")
load(f)
phat &lt;- predprob(id1)
dim(phat)
</code></pre>

<hr>
<h2 id='presidentialElections'>elections for U.S. President, 1932-2016, by state</h2><span id='topic+presidentialElections'></span>

<h3>Description</h3>

<p>Democratic share of the
presidential vote, 1932-2016, in each state and the District of Columbia.</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(presidentialElections)</code></pre>


<h3>Format</h3>


<dl>
<dt><code>state</code></dt><dd><p>character, name of state</p>
</dd>
<dt><code>demVote</code></dt><dd><p>numeric, percent of the vote for president won by the
Democratic candidate</p>
</dd>
<dt><code>year</code></dt><dd><p>numeric, integer</p>
</dd>
<dt><code>south</code></dt><dd><p>logical, <code>TRUE</code> if state is one of the 11 states
of the former Confederacy</p>
</dd>
</dl>



<h3>Note</h3>

<p>1,047 observations, unbalanced panel data in long format. Hawaii and Alaska contribute data
from 1960 onwards the District of Columbia contributes data
from 1964 onward; Alabama has missing data for 1948 and
1964.</p>


<h3>Source</h3>

<p>David Leip's Atlas of U.S. Presidential Elections <a href="https://uselectionatlas.org">https://uselectionatlas.org</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(presidentialElections)
if(require(lattice)) {
    lattice::xyplot(demVote ~ year | state,
       panel=lattice::panel.lines,
       ylab="Democratic Vote for President (percent)",
       xlab="Year",
       data=presidentialElections,
       scales=list(y=list(cex=.6),x=list(cex=.35)),
       strip=strip.custom(par.strip.text=list(cex=.6)))
}

## Obama vs Kerry, except DC
y08 &lt;- presidentialElections$year==2008
y04 &lt;- presidentialElections$year==2004
tmpData &lt;- merge(y=presidentialElections[y08,],
	         x=presidentialElections[y04,],
                 by="state")
tmpData &lt;- tmpData[tmpData$state!="DC",]
xlim &lt;- range(tmpData$demVote.x,tmpData$demVote.y)
col &lt;- rep("black",dim(tmpData)[1])
col[tmpData$south.x] &lt;- "red"

plot(demVote.y ~ demVote.x,
     xlab="Kerry Vote Share, 2004 (percent)",
     ylab="Obama Vote Share, 2008 (percent)",
     xlim=xlim,
     ylim=xlim,
     type="n",
     las=1,
     data=tmpData)
abline(0,1,lwd=2,col=gray(.65))
ols &lt;- lm(demVote.y ~ demVote.x,
          data=tmpData)
abline(ols,lwd=2)	

text(tmpData$demVote.x,
     tmpData$demVote.y,
     tmpData$state,
     col=col,
     cex=.65)
legend(x="topleft",
       bty="n",
       lwd=c(2,2),
       col=c(gray(.65),"black"),
       legend=c("No Change from 2004","Regression"))
legend(x="bottomright",
       bty="n",
       text.col=c("red","black"),
       legend=c("South","Non-South"))

</code></pre>

<hr>
<h2 id='prussian'>Prussian army horse kick data</h2><span id='topic+prussian'></span>

<h3>Description</h3>

<p>Deaths by year, by corp, from horse kicks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(prussian)</code></pre>


<h3>Format</h3>

<p>A data frame with 280 observations on the following 3 variables.
</p>

<dl>
<dt><code>y</code></dt><dd><p>a numeric vector, count of deaths</p>
</dd>
<dt><code>year</code></dt><dd><p>a numeric vector, 18XX, year of observation</p>
</dd>
<dt><code>corp</code></dt><dd><p>a <code><a href="base.html#topic+factor">factor</a></code>, corp of Prussian Army generating
observation</p>
</dd>
</dl>



<h3>Source</h3>

<p>von Bortkiewicz, L. 1898. <em>Das Gesetz der Kleinen Zahlen.</em> Leipzig: Teubner. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(prussian)
corpP &lt;- glm(y ~ corp, family=poisson,data=prussian)
summary(corpP)
</code></pre>

<hr>
<h2 id='readKH'>read roll call data in Poole-Rosenthal KH format</h2><span id='topic+readKH'></span>

<h3>Description</h3>

<p>Creates a <code>rollcall</code> object from the flat file format for roll
call data used by
Keith Poole and Howard Rosenthal.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>readKH(file,
       dtl=NULL,
       yea=c(1,2,3),
       nay=c(4,5,6),
       missing=c(7,8,9),
       notInLegis=0,
       desc=NULL,
       debug=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="readKH_+3A_file">file</code></td>
<td>
<p>string, name of a file or URL holding KH data</p>
</td></tr>
<tr><td><code id="readKH_+3A_dtl">dtl</code></td>
<td>
<p>string, name of a file or URL holding KH <code>dtl</code> file
(information about votes); default is <code>NULL</code>, indicating no
<code>dtl</code> file</p>
</td></tr> 
<tr><td><code id="readKH_+3A_yea">yea</code></td>
<td>
<p>numeric, possibly a vector, code(s) for a Yea vote in the
rollcall context (or a correct answer in the educational testing
context). Default is <code>c(1,2,3)</code>, which corresponds to Yea,
Paired Yea, and Announced Yea in Poole/Rosenthal data files.</p>
</td></tr>
<tr><td><code id="readKH_+3A_nay">nay</code></td>
<td>
<p>numeric, possibly a vector, code(s) for a Nay vote in the
rollcall context (or an incorrect answer in the educational testing
context).  Default is <code>c(4,5,6)</code>, which corresponds to
Announced Nay, Paired Nay, and Nay in Poole/Rosenthal data files.</p>
</td></tr>
<tr><td><code id="readKH_+3A_missing">missing</code></td>
<td>
<p>numeric and/or <code>NA</code>, possible a vector, code(s)
for missing data.  Default is <code>c(0,7,8,9,NA)</code>; the first four
codes correspond to Not Yet a Member, Present (some Congresses),
Present (some Congresses), and Not Voting.</p>
</td></tr>
<tr><td><code id="readKH_+3A_notinlegis">notInLegis</code></td>
<td>
<p>numeric or <code>NA</code>, possibly a vector, code(s) for
the legislator not being in the legislature when a particular roll
call was recorded (e.g., deceased, retired, yet to be
elected). Default is <code>0</code> for Poole/Rosenthal data files.</p>
</td></tr>
<tr><td><code id="readKH_+3A_desc">desc</code></td>
<td>
<p>string, describing the data, e.g., <code>82nd U.S. House
      of Representatives</code>; default is <code>NULL</code></p>
</td></tr>
<tr><td><code id="readKH_+3A_debug">debug</code></td>
<td>
<p>logical, print debugging information for net connection</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Keith Poole and Howard Rosenthal have gathered an impressive
collection of roll call data, spanning every roll call cast in
the United States Congress.  This effort continues now as a real-time
exercise, via a collaboration with Jeff Lewis (109th Congress
onwards).  Nolan McCarty collaborated on the compilation of roll call
data for the 102nd through 108th Congress.
</p>
<p>This function relies on some hard-coded features of Poole-Rosenthal
flat files, and assumes that the <code>file</code> being supplied has the following
structure (variable, start-end columns):
</p>

<dl>
<dt>ICPSR legislator unique ID</dt><dd><p>4-8</p>
</dd>
<dt>ICPSR state ID</dt><dd><p>9-10</p>
</dd>
<dt>Congressional District</dt><dd><p>11-12</p>
</dd>
<dt>state name</dt><dd><p>13-20</p>
</dd>
<dt>party code</dt><dd><p>21-23</p>
</dd>
<dt>legislator name</dt><dd><p>26-36</p>
</dd>
<dt>roll-call voting record</dt><dd><p>37 to end-of-record</p>
</dd>
</dl>

<p>This function reads data files in that format, and creates a
<code><a href="#topic+rollcall">rollcall</a></code>, for which there are useful methods such as
<code><a href="#topic+summary.rollcall">summary.rollcall</a></code>.  The <code>legis.data</code> component of the
<code><a href="#topic+rollcall">rollcall</a></code> object is a <code><a href="base.html#topic+data.frame">data.frame</a></code> which
contains:
</p>

<dl>
<dt><code>state</code></dt><dd><p>a 2-character string abbreviation of each
legislator' state</p>
</dd>
<dt><code>icpsrState</code></dt><dd><p>a 2-digit numeric code for each
legislator's state, as used by the Inter-university Consortium for
Political and Social Research (ICPSR)</p>
</dd>
<dt><code>cd</code></dt><dd><p>numeric, the number of each legislator's
congressional district within each state; this is always 0 for
members of the Senate</p>
</dd>    
<dt><code>icpsrLegis</code></dt><dd><p>a unique numeric identifier for each
legislator assigned by the ICPSR, as corrected by Poole and
Rosenthal.</p>
</dd>
<dt><code>partyName</code></dt><dd><p>character string, the name of each legislator's
political party</p>
</dd>
<dt><code>party</code></dt><dd><p>numeric, code for each legislator's political
party; see <a href="https://legacy.voteview.com/PARTY3.HTM">https://legacy.voteview.com/PARTY3.HTM</a></p>
</dd>
</dl>

<p>The <code><a href="base.html#topic+rownames">rownames</a></code> attribute of this data frame is a
concatenation of the legislators' names, party abbreviations (for
Democrats and Republicans) and state, and (where appropriate), a
district number; e.g., <code>Bonner (R AL-1)</code>.  This tag is also
provided in the <code>legis.name</code> component of the returned rollcall
object.
</p>
<p>Poole and Rosenthal also make <code>dtl</code> files available for
Congresses 1 through 106. These files contain information about the
votes themselves, in a multiple-line per vote <code>ascii</code> format, and
reside in the <code>dtl</code> director of Poole's web site, e.g.,
<a href="https://legacy.voteview.com/k7ftp/dtl/102s.dtl">https://legacy.voteview.com/k7ftp/dtl/102s.dtl</a> is the <code>dtl</code>
file for the 102nd Senate.  The default is to presume that no such
file exists.  When a <code>dtl</code> file is available, and is read, the
<code>votes.data</code> attribute of the resulting <code><a href="#topic+rollcall">rollcall</a></code>
object is a <code><a href="base.html#topic+data.frame">data.frame</a></code> with one record per vote, with
the following variables:
</p>

<dl>
<dt><code>date</code></dt><dd><p>vector of class <code><a href="base.html#topic+Date">Date</a></code>, date of the
rollcall, if available; otherwise <code>NULL</code></p>
</dd>
<dt><code>description</code></dt><dd><p>vector of mode <code>character</code>, descriptive
text</p>
</dd>
</dl>

<p>The <code>dtl</code> files are presumed to have the date of the rollcall in
the first line of text for each roll call, and lines 3 onwards contain
descriptive text.
</p>
<p>Finally, note also that the Poole/Rosenthal data sets often include
the U.S. President as a pseudo-legislator, adding the announced
positions of a president or the administration to the roll call
matrix. This adds an extra &ldquo;legislator&rdquo; to the data set and can
sometimes produce surprising results (e.g., a U.S. Senate of 101
senators), and a &ldquo;legislator&rdquo; with a surprisingly low party loyalty
score (since the President/administration only announces positions on
a relatively small fraction of all Congressional roll calls).   
</p>


<h3>Value</h3>

<p>an object of class <code><a href="#topic+rollcall">rollcall</a></code>, with components created
using the identifying information in the Poole/Rosenthal files.  If
the function can not read the file (e.g., the user specified a URL and
the machine is not connected to the Internet), the function fails with
an error message (set <code>debug=TRUE</code> to help resolve these issues).
</p>


<h3>Author(s)</h3>

<p>Simon Jackman <a href="mailto:simon.jackman@sydney.edu.au">simon.jackman@sydney.edu.au</a></p>


<h3>References</h3>

<p>Poole, Keith and Howard Rosenthal.  1997.  <em>Congress: A
Political-Economic History of Roll Call Voting</em>.  New York: Oxford
University Press.  
</p>
<p>Poole, Keith.  <a href="https://legacy.voteview.com">https://legacy.voteview.com</a>
</p>
<p>Rosenthal, Howard L. and Keith T. Poole.  <em>United States Congressional
Roll Call Voting Records, 1789-1990: Reformatted Data [computer
file].</em> 2nd ICPSR release. Pittsburgh, PA: Howard L. Rosenthal and Keith
T. Poole, Carnegie Mellon University, Graduate School of Industrial
Administration [producers], 1991. Ann Arbor, MI: Inter-university
Consortium for Political and Social Research [distributor], 2000.  
<a href="https://www.icpsr.umich.edu/icpsrweb/ICPSR/studies/09822">https://www.icpsr.umich.edu/icpsrweb/ICPSR/studies/09822</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rollcall">rollcall</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
h107 &lt;- readKH("https://voteview.com/static/data/out/votes/H107_votes.ord",
                desc="107th U.S. House of Representatives")

s107 &lt;- readKH("https://voteview.com/static/data/out/votes/S107_votes.ord",
                desc="107th U.S. Senate")

## End(Not run)
</code></pre>

<hr>
<h2 id='RockTheVote'>Voter turnout experiment, using Rock The Vote ads</h2><span id='topic+RockTheVote'></span>

<h3>Description</h3>

<p>Voter turnout data spanning 85 cable TV systems, randomly allocated to
a voter mobilization experiment targeting 18-19 year olds with &quot;Rock
the Vote&quot; television advertisements 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(RockTheVote)</code></pre>


<h3>Format</h3>

<p>A data frame with 85 observations on the following 6 variables.
</p>

<dl>
<dt><code>strata</code></dt><dd><p>numeric, experimental strata</p>
</dd>
<dt><code>treated</code></dt><dd><p>numeric, 1 if a treated cable system, 0 otherwise</p>
</dd>
<dt><code>r</code></dt><dd><p>numeric, number of 18 and 19 year olds turning out</p>
</dd>
<dt><code>n</code></dt><dd><p>numeric, number of 19 and 19 year olds registered</p>
</dd>
<dt><code>p</code></dt><dd><p>numeric, proportion of 18 and 19 year olds turning out</p>
</dd>
<dt><code>treatedIndex</code></dt><dd><p>numeric, a counter indexing the 42 treated units</p>
</dd>
</dl>



<h3>Details</h3>

<p>Green and Vavreck (2008) implemented a cluster-randomized
experimental design in assessing the effects of a voter mobilization
treatment in the 2004 U.S. Presidential election.  The clusters in this
design are geographic areas served by a single cable television system.
So as to facilitate analysis, the researchers restricted their
attention to small cable systems whose reach is limited to a single zip
code.  Further, since the experiment was fielded during the last week
of the presidential election, the researchers restricted their search
to cable systems that were not in the 16 hotly-contested
&ldquo;battleground&rdquo; states (as designated by the <em>Los Angeles
Times</em>).
</p>
<p>Eighty-five cable systems were available for randomization and were
assigned to treatment after stratification on previous turnout levels
in presidential elections (as determined from analysis of the
corresponding states' voter registration files).  Each cable system was
matched with one or sometimes two other cable systems in the same
state, yielding 40 strata.  Then within each strata, cable systems were
randomly assigned to treatment and control conditions.  Strata 3, 8 and
25 have two control cable systems and 1 treated system each, while
strata 6 and 20 have two treated cable systems and one control system.
The remaining 35 strata have 1 treated cable system and 1 control
system.  In this way there are 38 + 4 = 42 treated systems, spanning 40
experiment strata.
</p>
<p>The treatment involved researchers purchasing prime-time advertising
spots on four channels in the respective cable system in which the
researchers aired voter mobilization ads.  The ads were produced by
<em>Rock the Vote</em>, targeted at younger voters, and aired four times
per night, per channel, over the last eight days of the election
campaign.  After the election, public records were consulted to
assemble data on turnout levels in the treated and control cable
systems.  In the analysis reported in Green and Vavreck (2008), the
researchers focused on turnout among registered voters aged 18 and 19
years old.
</p>


<h3>References</h3>

<p>Green, Donald P. and Lynn Vavreck. 2008. Analysis of
Cluster-Randomized Experiments: A Comparison of Alternative Estimation
Approaches. <em>Political Analysis</em> 16:138-152.
</p>
<p>Jackman, Simon, 2009. <em>Bayesian Analysis for the Social Sciences</em>.  
Wiley: Hoboken, New Jersey.  Example 7.9.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(RockTheVote)
## estimate MLEs of treatment effects
deltaFunction &lt;- function(data){
  model &lt;- glm(cbind(r,n-r)~treated,
               data=data,
               family=binomial)
  c(coef(model)[2],
    confint(model)[2,])
}


tmp &lt;- by(RockTheVote,
          as.factor(RockTheVote$strata),
          deltaFunction)

tmp &lt;- matrix(unlist(tmp),ncol=3,byrow=TRUE)

indx &lt;- order(tmp[,1])

plot(y=1:40,
     x=tmp[indx,1],
     pch=16,cex=1.25,
     xlim=range(tmp),
     ylab="",
     axes=FALSE,
     xlab="Estimated Treatment Effect (MLEs, Logit Scale)")
text(y=1:40,
     x=par()$usr[1],
     pos=4,
     as.character((1:40)[indx]),
     cex=.5)
segments(x0=tmp[indx,2],
         x1=tmp[indx,3],
         y0=1:40,
         y1=1:40)
axis(1)
axis(3)
abline(v=0)
</code></pre>

<hr>
<h2 id='rollcall'>create an object of class rollcall</h2><span id='topic+rollcall'></span>

<h3>Description</h3>

<p>Create a <code>rollcall</code> object, used for the analysis of legislative
voting or, equivalently, item-response modeling of binary data
produced by standardized tests, etc.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rollcall(data,
         yea=1, nay=0, missing=NA, notInLegis=9,
         legis.names=NULL, vote.names=NULL,
         legis.data=NULL, vote.data=NULL,
         desc=NULL, source=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rollcall_+3A_data">data</code></td>
<td>
<p>voting decisions (for roll calls), or test results (for
IRT).  Can be in one of two forms.  First, <code>data</code> may be a
<code><a href="base.html#topic+matrix">matrix</a></code>, with rows corresponding to legislators
(subjects) and columns to roll calls (test items).  <code>data</code> can
also be a <code><a href="base.html#topic+list">list</a></code> with an element named <code>votes</code>
containing the matrix described above.</p>
</td></tr>
<tr><td><code id="rollcall_+3A_yea">yea</code></td>
<td>
<p>numeric, possibly a vector, code(s) for a Yea vote in the
rollcall context, or a correct answer in the educational testing
context. Default is 1.</p>
</td></tr>
<tr><td><code id="rollcall_+3A_nay">nay</code></td>
<td>
<p>numeric, possibly a vector, code(s) for a Nay vote in the
rollcall context, or an incorrect answer in the educational testing
context.  Default is 0.</p>
</td></tr>
<tr><td><code id="rollcall_+3A_missing">missing</code></td>
<td>
<p>numeric or <code>NA</code>, possibly a vector, code(s) for
missing data.  Default is <code>NA</code>.</p>
</td></tr>
<tr><td><code id="rollcall_+3A_notinlegis">notInLegis</code></td>
<td>
<p>numeric or <code>NA</code>, possibly a vector, code(s) for
the legislator not being in the legislature when a particular roll
call was recorded (e.g., deceased, retired, yet to be elected).</p>
</td></tr>
<tr><td><code id="rollcall_+3A_legis.names">legis.names</code></td>
<td>
<p>a vector of names of the legislators or
individuals.  If <code>data</code> is a <code>list</code> or <code>data.frame</code>
and has a component named <code>legis.names</code>, then this will be
used.  Names will be generated if not supplied, or if there are
fewer unique names supplied than legislators/subjects (rows of the
roll call matrix).</p>
</td></tr>
<tr><td><code id="rollcall_+3A_vote.names">vote.names</code></td>
<td>
<p>a vector of names or labels for the votes or items.
If <code>data</code> is a <code>list</code> or <code>data.frame</code> and has a
component named <code>vote.names</code>, then this will be used.  Names
will be generated if not supplied, or if there are fewer unique
names supplied than votes/test-items (columns of the roll call
matrix).</p>
</td></tr>
<tr><td><code id="rollcall_+3A_legis.data">legis.data</code></td>
<td>
<p>a <code><a href="base.html#topic+matrix">matrix</a></code> or <code><a href="base.html#topic+data.frame">data.frame</a></code>
containing covariates specific to each legislator/test-taker; e.g.,
party affiliation, district-level covariates.  If this object does
not have the same number of rows as <code>data</code>, an error is
returned.</p>
</td></tr>
<tr><td><code id="rollcall_+3A_vote.data">vote.data</code></td>
<td>
<p>a <code><a href="base.html#topic+matrix">matrix</a></code> or <code><a href="base.html#topic+data.frame">data.frame</a></code>
containing covariates specific to each roll call vote or test item;
e.g., a timestamp, the bill sponsor, descriptive text indicating
the type of vote.  If this object does not have the same number of
row as the number of columns in <code>data</code>, an error is returned.</p>
</td></tr>
<tr><td><code id="rollcall_+3A_desc">desc</code></td>
<td>
<p>character, a string providing an (optional) description of
the data being used.  If <code>data</code> is a list and contains an
element named <code>desc</code>, then this will be used.</p>
</td></tr>
<tr><td><code id="rollcall_+3A_source">source</code></td>
<td>
<p>character, a string providing an (optional) description
of where the roll call data originated (e.g., a URL or a short-form
reference).  Used in print and summary methods.</p>
</td></tr> 
</table>


<h3>Details</h3>

<p>See below for methods that operate on objects of class
<code>rollcall</code>.</p>


<h3>Value</h3>

<p>An object of class <code>rollcall</code>, a list with the following components:
</p>
<table>
<tr><td><code>votes</code></td>
<td>
<p>a <code><a href="base.html#topic+matrix">matrix</a></code> containing voting decisions, with
rows corresponding to legislators (test subjects) and columns to
roll call votes (test items). Legislators (test subjects)
and items (or votes) have been labeled in the
<code><a href="base.html#topic+dimnames">dimnames</a></code> attribute of this matrix, using
the <code>legis.names</code> and/or <code>vote.names</code> arguments, respectively.</p>
</td></tr>
<tr><td><code>codes</code></td>
<td>
<p>a <code><a href="base.html#topic+list">list</a></code> with named components <code>yea</code>,
<code>nay</code>, <code>notInLegis</code> and <code>missing</code>, each component a
numeric vector (possibly of length 1 and possibly <code>NA</code>),
indicating how entries in the <code>votes</code> component of the
<code>rollcall</code> object should be considered.  This list simply gathers
up the values in the <code>yea</code>, <code>nay</code>, <code>notInLegis</code> and
<code>missing</code> arguments passed to the function.</p>
</td></tr>
<tr><td><code>n</code></td>
<td>
<p>numeric, number of legislators, equal to <code>dim(votes)[1]</code></p>
</td></tr>
<tr><td><code>m</code></td>
<td>
<p>numeric, number of votes, equal to <code>dim(votes)[2]</code></p>
</td></tr>
<tr><td><code>legis.data</code></td>
<td>
<p>user-supplied data on legislators/test-subjects.</p>
</td></tr>
<tr><td><code>vote.data</code></td>
<td>
<p>user-supplied data on rollcall votes/test-items.</p>
</td></tr>
<tr><td><code>desc</code></td>
<td>
<p>any user-supplied description.  If no description was provided,
defaults <code>desc</code> defaults to <code>NULL</code>.</p>
</td></tr>
<tr><td><code>source</code></td>
<td>
<p>any user-supplied source information (e.g., a url or a
short-form reference).  If no description is provided, <code>source</code>
defaults to <code>NULL</code>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+readKH">readKH</a></code> for creating objects from files (possibly over
the web), in the format used for data from the United States Congress
used by Keith Poole and Howard Rosenthal (and others).
</p>
<p><code><a href="#topic+summary.rollcall">summary.rollcall</a></code>, <code><a href="#topic+ideal">ideal</a></code> for model fitting.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## generate some fake roll call data
set.seed(314159265)
fakeData &lt;- matrix(sample(x=c(0,1),size=5000,replace=TRUE),
                   50,100)
rc &lt;- rollcall(fakeData)
is(rc,"rollcall")        ## TRUE
rc                       ## print the rollcall object on screen

data(sc9497)             ## Supreme Court example data
rc &lt;- rollcall(data=sc9497$votes,
               legis.names=sc9497$legis.names,
               desc=sc9497$desc)
summary(rc,verbose=TRUE)                      

## Not run: 
## s107
## could use readKH for this
dat &lt;- readLines("sen107kh.ord")
dat &lt;- substring(dat,37)
mat &lt;- matrix(NA,ncol=nchar(dat[1]),nrow=length(dat))
for(i in 1:103){
  mat[i,] &lt;- as.numeric(unlist(strsplit(dat[i],
                                        split=character(0))))
}

s107 &lt;- rollcall(mat,
                 yea=c(1,2,3),
                 nay=c(4,5,6),
                 missing=c(7,8,9),
                 notInLegis=0,
                 desc="107th U.S. Senate",
                 source="http://voteview.ucsd.edu")
summary(s107)

## End(Not run)
</code></pre>

<hr>
<h2 id='s109'>rollcall object, 109th U.S. Senate (2005-06).</h2><span id='topic+s109'></span>

<h3>Description</h3>

<p>A sample rollcall object, generated using a
collection of the rollcalls of the 109th U.S. Senate (2005-2006).</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(s109)</code></pre>


<h3>Format</h3>

<p>A <code><a href="#topic+rollcall">rollcall</a></code> object containing the recorded votes of the 109th
U.S. Senate, plus information identifying the legislators and the
rollcalls.
</p>


<h3>Details</h3>

<p>Note the coding scheme used by Poole and Rosenthal; Yea (1),
Nay (6) etc.</p>


<h3>Source</h3>

<p>Keith Poole's web site:
<a href="https://legacy.voteview.com/senate109.htm">https://legacy.voteview.com/senate109.htm</a>
</p>
<p>Originally scraped from the Senate's web site by Jeff Lewis (UCLA).
</p>
<p>Information identifying the votes is available at
<a href="https://voteview.com/static/data/out/rollcalls/S109_rollcalls.csv">https://voteview.com/static/data/out/rollcalls/S109_rollcalls.csv</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(pscl)
data(s109)
is(s109,"rollcall")    ## TRUE
s109                   ## print method for class rollcall
summary(s109)          ## summary method
summary(s109,verbose=TRUE)
## Not run: 
## how s109 was created
require(pscl)
s109 &lt;- readKH("https://voteview.com/static/data/out/votes/S109_votes.ord",
               desc="109th U.S. Senate",
               debug=TRUE)
url &lt;- "https://voteview.com/static/data/out/rollcalls/S109_rollcalls.csv"

s109$vote.data &lt;- data.frame(read.csv(file=url,header=TRUE))
s109$vote.data$date &lt;- as.Date(s109$vote.data$date,
                               format="
dimnames(s109$votes)[[2]] &lt;- paste(s109$vote.data$session,
                                   s109$vote.data$number,sep="-")

## End(Not run)
</code></pre>

<hr>
<h2 id='sc9497'>votes from the United States Supreme Court, from 1994-1997</h2><span id='topic+sc9497'></span>

<h3>Description</h3>

<p>This data set provides information on the United States Supreme Court
from 1994-1997.  Votes included are non-unanimous.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(sc9497)</code></pre>


<h3>Format</h3>

<p>A list containing the elements:
</p>

<dl>
<dt>votes</dt><dd><p>a matrix of the votes, 0=Nay, 1=Yea,
<code>NA</code>=Abstained or missing data.  The matrix columns are labeled with
<code>vote.names</code> and the rows are labeled with <code>legis.names</code>.</p>
</dd>
<dt>legis.names</dt><dd><p>a vector of the names of the nine Justices
sitting on the court at this time.</p>
</dd>
<dt>party</dt><dd><p>NULL; exists for consistency with House and Senate data sets.</p>
</dd>
<dt>state</dt><dd><p>NULL; exists for consistency with House and Senate data
sets.</p>
</dd>
<dt>district</dt><dd><p>NULL; exists for consistency with House data sets.</p>
</dd>
<dt>id</dt><dd><p>NULL; exists for consistency with House and Senate data sets.</p>
</dd>
<dt>vote.names</dt><dd><p>a vector of strings numbering the cases simply to
distinguish them from one another.</p>
</dd>
<dt>desc</dt><dd><p>a description of the data set.</p>
</dd>
</dl>



<h3>Source</h3>

<p>Harold J. Spaeth (1999). <em>United States Supreme Court Judicial
Database, 1953-1997 Terms</em>.  Ninth edition.  Inter-university Consortium for Political and Social Research.  Ann Arbor, Michigan.  <a href="https://doi.org/10.3886/ICPSR09422.v9">doi:10.3886/ICPSR09422.v9</a></p>

<hr>
<h2 id='seatsVotes'>A class for creating seats-votes curves</h2><span id='topic+seatsVotes'></span>

<h3>Description</h3>

<p>Convert a vector of vote shares into a seats-vote curve object,
providing estimates of partisan bias.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>seatsVotes(x, desc = NULL, method = "uniformSwing")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="seatsVotes_+3A_x">x</code></td>
<td>
<p>a vector of vote shares for a specific party (either
proportions or percentages)</p>
</td></tr>
<tr><td><code id="seatsVotes_+3A_desc">desc</code></td>
<td>
<p>descriptive text</p>
</td></tr>
<tr><td><code id="seatsVotes_+3A_method">method</code></td>
<td>
<p>how to simulate a seats-vote curve; the only supported
method at this stage is <code>uniformSwing</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Simulation methods are required to induce a seats-votes curve
given a vector of vote shares from one election.  The uniform swing
method simply slides the empirical distribution function of the vote
shares &ldquo;up&rdquo; and &ldquo;down&rdquo;, computing the proportion of
the vote shares that lie above .5 (by construction, the winning
percentage in a two-party election) for each new location of the
vector of vote shares.  That is, as the empirical CDF of the
observed vote shares slides up or down, more or less seats cross the
.5 threshold.  A seats-votes curve is formed by plotting the seat
share above .5 as a function of the average district-level vote
share (a weakly monotone function, since the empirical CDF
constitutes a set of sufficient statistics for this problem).  The
simulation is run so as to ensure that average district-level vote
shares range between 0 and 1.
</p>
<p>The extent to which the seats-votes curve departs from symmetry is
known as bias.  More specifically, the vertical displacement of the
seats-votes curve from .5 when average district-level vote share is .5
is conventionally reported as an estimate of the bias of the electoral
system.  
</p>
<p>Different methods produce different estimates of seats-votes curves
and summary estimands such as bias.  The
uniform swing method is completely deterministic and does not
produce any uncertainty assessment (e.g., confidence intervals etc).
</p>


<h3>Value</h3>

<p>An object of class <code>seatsVotes</code>, with components
</p>
<table>
<tr><td><code>s</code></td>
<td>
<p>Estimated seat shares over the range of simulated average,
district-level vote shares</p>
</td></tr>
<tr><td><code>v</code></td>
<td>
<p>Simulated average district-level vote shares</p>
</td></tr>
<tr><td><code>x</code></td>
<td>
<p>observed seat shares, with missing data removed</p>
</td></tr>
<tr><td><code>desc</code></td>
<td>
<p>user-supplied descriptive character string</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>a list of class <code><a href="base.html#topic+call">call</a></code>, the call to the function</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Additional methods to come later.</p>


<h3>Author(s)</h3>

<p>Simon Jackman <a href="mailto:simon.jackman@sydney.edu.au">simon.jackman@sydney.edu.au</a></p>


<h3>References</h3>

<p>Tufte, Edward R. 1973. The Relationship Between Seats and Votes in
Two-Party Systems. <em>American Political Science
Review</em>. 67(2):540-554.
</p>
<p>Gelman, Andrew and Gary King.  1990.  Estimating the Consequences of
Electoral Redistricting.  <em>Journal of the American Statistical
Association</em>. 85:274-282.
</p>
<p>Jackman, Simon. 1994.  Measuring Electoral Bias: Australia,
1949-93. <em>British Journal of Political Science</em>. 24(3):319-357.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.seatsVotes">plot.seatsVotes</a></code> for plotting methods.</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ca2006)
x &lt;- ca2006$D/(ca2006$D+ca2006$R)
sv &lt;- seatsVotes(x,
                 desc="Democratic Vote Shares, California 2006 congressional elections")
</code></pre>

<hr>
<h2 id='simpi'>Monte Carlo estimate of pi (3.14159265...)</h2><span id='topic+simpi'></span>

<h3>Description</h3>

<p>Monte Carlo estimation of pi
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simpi(n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simpi_+3A_n">n</code></td>
<td>
<p>integer, number of Monte Carlo samples, defaults to 1000</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A crude Monte Carlo estimate of <code class="reqn">\pi</code> can be formed as
follows.  Sample from the unit square many times (i.e., each sample is
formed with two independent draws from a uniform density on the unit
interval).  Compute the proportion <code class="reqn">p</code> of sampled points that
lie inside a unit circle centered on the origin; such points
<code class="reqn">(x,y)</code> have distance from the origin <code class="reqn">d = \sqrt{x^2 +
  y^2}</code> less than 1.  Four times <code class="reqn">p</code> is a
Monte Carlo estimate of <code class="reqn">\pi</code>.  This function is a wrapper to
a simple C function, bringing noticeable speed gains and memory
efficiencies over implementations in native R.
</p>
<p>Contrast this Monte Carlo method with Buffon's needle and refinements thereof (see
the discussion in Ripley (1987, 193ff). 
</p>


<h3>Value</h3>

<p>the Monte Carlo estimate of <code class="reqn">\pi</code></p>


<h3>Author(s)</h3>

<p>Simon Jackman <a href="mailto:simon.jackman@sydney.edu.au">simon.jackman@sydney.edu.au</a></p>


<h3>References</h3>

<p>Ripley, Brain D. 1987 [2006].  <em>Stochastic Simulation</em>.
Wiley: Hoboken, New Jersey.</p>


<h3>Examples</h3>

<pre><code class='language-R'>seed &lt;- round(pi*10000)  ## hah hah hah
m &lt;- 6
z &lt;- rep(NA,m)
lim &lt;- rep(NA,m)
for(i in 1:m){
  cat(paste("simulation for ",i,"\n"))
  set.seed(seed)
  timings &lt;- system.time(z[i] &lt;- simpi(10^i))
  print(timings)
  cat("\n")
  lim[i] &lt;- qbinom(prob=pi/4,size=10^i,.975)/10^i * 4
}

## convert to squared error
z &lt;-(z - pi)^2
lim &lt;- (lim - pi)^2

plot(x=1:m,
     y=z,
     type="b",
     pch=16,
     log="y",
     axes=FALSE,
     ylim=range(z,lim),
     xlab="Monte Carlo Samples",
     ylab="Log Squared Error")
lines(1:m,lim,col="blue",type="b",pch=1)
legend(x="topright",
       legend=c("95% bound",
         "Realized"),
       pch=c(1,16),
       lty=c(1,1),
       col=c("blue","black"),
       bty="n")
axis(1,at=1:m,
     labels=c(expression(10^{1}),
       expression(10^{2}),
       expression(10^{3}),
       expression(10^{4}),
       expression(10^{5}),
       expression(10^{6})))
axis(2)

</code></pre>

<hr>
<h2 id='state.info'>information about the American states needed for U.S. Congress</h2><span id='topic+state.info'></span>

<h3>Description</h3>

<p>Numeric codes and names of 50 states and the District of Columbia,
required to parse Keith Poole
and Howard Rosenthal's collections of U.S. Congressional roll calls.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(state.info)
</code></pre>


<h3>Format</h3>


<dl>
<dt><code>icpsr</code></dt><dd><p>integer, numeric code for state used by the
Inter-university Consortium for Political and Social Research</p>
</dd>
<dt><code>state</code></dt><dd><p>character, name of state or <code>Washington
	D.C.</code></p>
</dd>
<dt><code>year</code></dt><dd><p>numeric or <code>NA</code>, year of statehood</p>
</dd>
</dl>



<h3>Details</h3>

<p>The function <code><a href="#topic+readKH">readKH</a></code> converts the integer ICPSR codes
into strings, via a table lookup in this data frame.  Another table
lookup in <code><a href="datasets.html#topic+state.abb">state.abb</a></code> provides the 2-letter abbreviation
commonly used in identifying American legislators, e.g.,
<code>KENNEDY, E (D-MA)</code>.</p>


<h3>Source</h3>

<p>Various ICPSR codebooks. e.g., <a href="https://doi.org/10.3886/ICPSR00002.v5">doi:10.3886/ICPSR00002.v5</a></p>


<h3>See Also</h3>

<p><code><a href="datasets.html#topic+state">state</a></code>
</p>

<hr>
<h2 id='summary.ideal'>summary of an ideal object</h2><span id='topic+summary.ideal'></span>

<h3>Description</h3>

<p>Provides a summary of the output from ideal point estimation contained
in an object of class <code>ideal</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ideal'
summary(object, prob=.95,
              burnin=NULL,
              sort=TRUE,
              include.beta=FALSE,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.ideal_+3A_object">object</code></td>
<td>
<p>an object of class <code><a href="#topic+ideal">ideal</a></code>.</p>
</td></tr>
<tr><td><code id="summary.ideal_+3A_prob">prob</code></td>
<td>
<p>scalar, a proportion between 0 and 1, the content of the highest posterior density (HPD) interval to compute for the parameters</p>
</td></tr>
<tr><td><code id="summary.ideal_+3A_burnin">burnin</code></td>
<td>
<p>of the recorded MCMC samples, how many to discard as
burnin?  Default is <code>NULL</code>, in which case the value of
<code>burnin</code> in the <code><a href="#topic+ideal">ideal</a></code> object is used.</p>
</td></tr>
<tr><td><code id="summary.ideal_+3A_sort">sort</code></td>
<td>
<p>logical, default is <code>TRUE</code>, indicating that the
summary of the ideal points be sorted by the estimated posterior means
(lowest to highest)</p>
</td></tr>
<tr><td><code id="summary.ideal_+3A_include.beta">include.beta</code></td>
<td>
<p>whether or not to calculate summary statistics of
beta, if beta is available.  If the item parameters were not stored
in the <code>ideal</code> object, then <code>include.beta</code> is ignored.</p>
</td></tr>
<tr><td><code id="summary.ideal_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other functions</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The test of whether a given discrimination parameter is
distinguishable from zero first checks to see if the two most extreme
<code>quantiles</code> are symmetric around .5 (e.g., as are the default
value of .025 and .975).  If so, the corresponding quantiles of the
MCMC samples for each discrimination parameter are inspected to see if
they have the same sign. If they do, then the corresponding
discrimination parameter is flagged as distinguishable from zero;
otherwise not.
</p>


<h3>Value</h3>

<p>An item of class <code>summary.ideal</code> with elements:
</p>
<table>
<tr><td><code>object</code></td>
<td>
<p>the name of the ideal object as an
<code><a href="base.html#topic+eval">unevaluated</a></code> <code><a href="base.html#topic+expression">expression</a></code>, produced
by <code>match.call()$object</code></p>
</td></tr>
<tr><td><code>xm</code></td>
<td>
<p><code>n</code> by <code>d</code> matrix of posterior means for the ideal points</p>
</td></tr>
<tr><td><code>xsd</code></td>
<td>
<p><code>n</code> by <code>d</code> matrix of posterior means for the ideal points</p>
</td></tr>
<tr><td><code>xHDR</code></td>
<td>
<p><code>n</code> by 2 by <code>d</code> array of HDRs for the ideal points</p>
</td></tr>  
<tr><td><code>bm</code></td>
<td>
<p><code>m</code> by <code>d+1</code> matrix of posterior means for the
item parameters</p>
</td></tr>
<tr><td><code>bsd</code></td>
<td>
<p><code>m</code> by <code>d+1</code> matrix of posterior standard deviation for the
item parameters</p>
</td></tr>
<tr><td><code>bHDR</code></td>
<td>
<p><code>m</code> by 2 by <code>d+1</code> array of HDRs for the item parameters</p>
</td></tr>  
<tr><td><code>bSig</code></td>
<td>
<p>a <code><a href="base.html#topic+list">list</a></code> of length <code>d</code>, each component a
vector of length <code>m</code>, of mode <code>logical</code>, equal to
<code>TRUE</code> if the corresponding discrimination parameter is
distinguishable from zero; see Details.  If <code>store.item</code> was
set to <code>FALSE</code> when <code><a href="#topic+ideal">ideal</a></code> was invoked, then
<code>bSig</code> is a list of length zero.</p>
</td></tr>   
<tr><td><code>party.quant</code></td>
<td>
<p>if party information is available through the
<code>rollcall</code> object that was used to run <code>ideal</code>, then
<code>party.quant</code> gives the posterior mean of the legislators'
ideal points by party, by dimension.  If no party information is
available, then <code>party.quant=NULL</code>.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>When specifying a value of <code>burnin</code> different from that used
in fitting the <code><a href="#topic+ideal">ideal</a></code> object, note a distinction
between the iteration numbers of the stored iterations, and the
number of stored iterations.  That is, the <code>n</code>-th iteration
stored in an <code><a href="#topic+ideal">ideal</a></code> object will not be iteration
<code>n</code> if the user specified <code>thin&gt;1</code> in the call to
<code><a href="#topic+ideal">ideal</a></code>.  Here, iterations are tagged with their
iteration number.  Thus, if the user called <code><a href="#topic+ideal">ideal</a></code> with
<code>thin=10</code> and <code>burnin=100</code> then the stored iterations are
numbered <code>100, 110, 120, ...</code>.  Any future subsetting via a
<code>burnin</code> refers to this iteration number.</p>


<h3>Author(s)</h3>

<p>Simon Jackman <a href="mailto:simon.jackman@sydney.edu.au">simon.jackman@sydney.edu.au</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+ideal">ideal</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>f &lt;- system.file("extdata","id1.rda",package="pscl")
load(f)
summary(id1)

## Not run: 
data(s109)
cl2 &lt;- constrain.legis(s109,
                       x=list("KENNEDY (D MA)"=c(-1,0),
                         "ENZI (R WY)"=c(1,0),
                         "CHAFEE (R RI)"=c(0,-.5)),
                       d=2)
id2Constrained &lt;- ideal(s109,
                        d=2,
                        priors=cl2,      ## priors (w constraints)
                        startvals=cl2,   ## start value (w constraints)
                        store.item=TRUE,
                        maxiter=5000,
                        burnin=500,
                        thin=25)

summary(id2Constrained,
        include.items=TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='summary.rollcall'>summarize a rollcall object</h2><span id='topic+summary.rollcall'></span><span id='topic+print.summary.rollcall'></span>

<h3>Description</h3>

<p>Provides a summary of the information about votes, legislators, etc in
a <code><a href="#topic+rollcall">rollcall</a></code> object. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'rollcall'
summary(object,
                 dropList=NULL,  
                 verbose=FALSE,debug=FALSE,...)

## S3 method for class 'summary.rollcall'
print(x, digits=1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.rollcall_+3A_object">object</code></td>
<td>
<p>an <code><a href="#topic+rollcall">rollcall</a></code> object.</p>
</td></tr>
<tr><td><code id="summary.rollcall_+3A_droplist">dropList</code></td>
<td>
<p>a <code><a href="base.html#topic+list">list</a></code> or <code><a href="base.html#topic+alist">alist</a></code>, listing voting
decisions, legislators and/or votes to be dropped 
from the summary; see <code><a href="#topic+dropRollCall">dropRollCall</a></code> for details.</p>
</td></tr>
<tr><td><code id="summary.rollcall_+3A_verbose">verbose</code></td>
<td>
<p>logical, if <code>TRUE</code>, compute legislator-specific
and vote-specific Yea/Nay/<code>NA</code> summaries</p>
</td></tr>
<tr><td><code id="summary.rollcall_+3A_debug">debug</code></td>
<td>
<p>logical, if <code>TRUE</code>, print messages to console during
processing of the <code>rollcall</code> object</p>
</td></tr>
<tr><td><code id="summary.rollcall_+3A_x">x</code></td>
<td>
<p>an object of class <code>summary.rollcall</code></p>
</td></tr>
<tr><td><code id="summary.rollcall_+3A_digits">digits</code></td>
<td>
<p>number of decimal places in printed display</p>
</td></tr>
<tr><td><code id="summary.rollcall_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>summary.rollcall</code> with the following elements
(depending on the logical flag <code>verbose</code>):
</p>
<table>
<tr><td><code>n</code></td>
<td>
<p>number of legislators in the <code><a href="#topic+rollcall">rollcall</a></code> object,
after processing the <code>dropList</code></p>
</td></tr>
<tr><td><code>m</code></td>
<td>
<p>number of roll call votes in the <code><a href="#topic+rollcall">rollcall</a></code>
object, after processing the <code>dropList</code></p>
</td></tr>
<tr><td><code>codes</code></td>
<td>
<p>a <code><a href="base.html#topic+list">list</a></code> that describes how the voting
decisions in the <code><a href="#topic+rollcall">rollcall</a></code> matrix (<code>object$votes</code>)
map into &ldquo;Yea&rdquo; and &ldquo;Nay&rdquo; etc, after processing the
<code>dropList</code>; see <code><a href="#topic+rollcall">rollcall</a></code> for more details</p>
</td></tr>
<tr><td><code>allVotes</code></td>
<td>
<p>a matrix containing a tabular breakdown of all votes
in the <code><a href="#topic+rollcall">rollcall</a></code> matrix (<code>object$votes</code>), after
processing the <code>dropList</code></p>
</td></tr>
<tr><td><code>partyTab</code></td>
<td>
<p>a tabular breakdown of the legislators' party
affiliations, after processing the <code>dropList</code>, and only if
party affiliations are supplied as<code>object$legis.data$party</code>;
see <code><a href="#topic+rollcall">rollcall</a></code> for details</p>
</td></tr>
<tr><td><code>lopSided</code></td>
<td>
<p>a tabular summary of the frequency of lop-sided roll
call votes in the <code><a href="#topic+rollcall">rollcall</a></code> object, again, after
processing the <code>dropList</code></p>
</td></tr>
<tr><td><code>legisTab</code></td>
<td>
<p>a tabular summary of each legislators' voting
history</p>
</td></tr>
<tr><td><code>partyLoyalty</code></td>
<td>
<p>the proportion of times that each legislator
votes the way that a majority of his or her fellow partisans did,
provided party affiliations are available</p>
</td></tr>
<tr><td><code>voteTab</code></td>
<td>
<p>a tabular summary of each rollcall's votes</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>the <code><a href="base.html#topic+match.call">matched call</a></code> used to invoke
<code>summary.rollcall</code></p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+rollcall">rollcall</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(314159265)
fakeData &lt;- matrix(sample(x=c(0,1),size=1000,replace=TRUE),
                   10,100)
rc &lt;- rollcall(fakeData)
rc

data(sc9497)
rc &lt;- rollcall(sc9497)
summary(rc)

data(s109)
summary(s109)
summary(s109,verbose=TRUE)
</code></pre>

<hr>
<h2 id='tracex'>trace plot of MCMC iterates, posterior density of legislators'
ideal points</h2><span id='topic+tracex'></span>

<h3>Description</h3>

<p>Produces a trace plot of the MCMC samples from the posterior density of
legislators' <code><a href="#topic+ideal">ideal</a></code> points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tracex(object, legis=NULL, d=1, conf.int=0.95,
       multi = FALSE, burnin=NULL,span=.25,
       legendLoc="topright")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tracex_+3A_object">object</code></td>
<td>
<p>an object of class <code>ideal</code>.</p>
</td></tr>
<tr><td><code id="tracex_+3A_legis">legis</code></td>
<td>
<p>a vector of either the names of legislators (or
<code><a href="base.html#topic+pmatch">partial matches</a></code> of the names as given in the
<code><a href="base.html#topic+dimnames">dimnames</a></code> of <code>object$x</code>.</p>
</td></tr>
<tr><td><code id="tracex_+3A_d">d</code></td>
<td>
<p>numeric, either a scalar or a vector of length two, the
dimension(s) to be traced.</p>
</td></tr> 
<tr><td><code id="tracex_+3A_conf.int">conf.int</code></td>
<td>
<p>numeric, the level of the confidence interval on the
posterior mean to be plotted.</p>
</td></tr>
<tr><td><code id="tracex_+3A_multi">multi</code></td>
<td>
<p>logical, multiple plotting panels, one per legislators? If <code>FALSE</code> (default) and <code>length(d)==2</code>,
display traces for all selected legislators' ideal points on
the one plot.</p>
</td></tr>
<tr><td><code id="tracex_+3A_burnin">burnin</code></td>
<td>
<p>of the recorded MCMC samples, how many to discard as
burnin?  Default is <code>NULL</code>, in which case the value of
<code>burnin</code> in the <code><a href="#topic+ideal">ideal</a></code> object is used.</p>
</td></tr>
<tr><td><code id="tracex_+3A_span">span</code></td>
<td>
<p>numeric, a proportion, the <code>span</code> to be used when
calling <code>loess</code> to generate a moving average for trace plots when
<code>d=1</code></p>
</td></tr>
<tr><td><code id="tracex_+3A_legendloc">legendLoc</code></td>
<td>
<p>numeric or character, and possibly a vector,
specifying where to place the legend when <code>d=1</code>; setting
<code>legendLoc=NULL</code> will suppress the legend for all requested trace
plots</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Produces a trace plot showing the history of the MCMC
iterations for the ideal point of each of the legislators (partially)
named in <code>legis</code>.  For <code>d=1</code>, each trace plot includes a
trace over iterations, the cumulative mean, a moving average, the
MCMC-based estimate of the mean of the posterior, and a confidence
interval (specified by <code>conf.int</code>) around the mean of the
posterior (using the estimated <code><a href="stats.html#topic+quantile">quantiles</a></code>) of
the respective MCMC iterates).  All of these values are calculated
discarding the initial <code>burnin</code> iterations.
</p>
<p>When <code>d</code> is a vector of length two, a 2-dimensional trace plot is
displayed, with the <code>d[1]</code> dimension on the horizontal axis, and
the <code>d[2]</code> dimension on the vertical axis.
</p>
<p>When <code>d=1</code>, a legend will be placed on the plot; the option
<code>legendLoc</code> controls the placing of the legend.  <code>legendLoc</code>
may be a vector, specifying a unique legend location for each
requested trace plots.  If
<code>legendLoc</code> is of length 1, it will be <code><a href="base.html#topic+rep">rep</a></code>licated
to have length equal to the number of requested trace plots.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ideal">ideal</a></code>; <code><a href="base.html#topic+pmatch">pmatch</a></code> for matching
legislators' names.  See <code><a href="graphics.html#topic+legend">legend</a></code> for valid options to
<code>legendLoc</code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(s109)
f &lt;- system.file("extdata","id1.rda",package="pscl")
load(f)
tracex(id1,legis="KENN")

## n.b., no such legislator named Thomas Bayes
tracex(id1,legis=c("KENN","BOX","KYL","Thomas Bayes"))


f &lt;- system.file("extdata","id2.rda",package="pscl")
load(f)

tracex(id2,d=1,legis=c("KENNEDY","BOXER","KYL","Thomas Bayes"))
tracex(id2,d=2,legis=c("KENNEDY","BOXER","KYL","Thomas Bayes"))
tracex(id2,d=1:2,
       legis=c("KENNEDY","BOXER","KYL","Thomas Bayes"))

## partial matching
tracex(id2,d=1:2,
       legis=c("KENN","BOX","BID","SNO","SPEC","MCCA","KYL",
               "Thomas Bayes"),
       multi=TRUE)
</code></pre>

<hr>
<h2 id='UKHouseOfCommons'>1992 United Kingdom electoral returns</h2><span id='topic+UKHouseOfCommons'></span>

<h3>Description</h3>

<p>Electoral returns, selected constituencies, 1992 general
election for the British House of Commons</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(UKHouseOfCommons)</code></pre>


<h3>Format</h3>

<p>A data frame with 521 observations on the following 12 variables.
</p>

<dl>
<dt><code>constituency</code></dt><dd><p>a character vector, name of the House of Commons constituency</p>
</dd>
<dt><code>county</code></dt><dd><p>a character vector, county of the House of Commons constituency</p>
</dd>
<dt><code>y1</code></dt><dd><p>a numeric vector, log-odds of Conservative to LibDem vote share</p>
</dd>
<dt><code>y2</code></dt><dd><p>a numeric vector, log-odds of Labor to LibDem vote share</p>
</dd>
<dt><code>y1lag</code></dt><dd><p>a numeric vector, <code>y1</code> from previous election</p>
</dd>
<dt><code>y2lag</code></dt><dd><p>a numeric vector, <code>y2</code> from previous election</p>
</dd>
<dt><code>coninc</code></dt><dd><p>a numeric vector, 1 if the incumbent is a
Conservative, 0 otherwise</p>
</dd>
<dt><code>labinc</code></dt><dd><p>a numeric vector, 1 if the incumbent is from
the Labor Party, 0 otherwise</p>
</dd>
<dt><code>libinc</code></dt><dd><p>a numeric vector, 1 if the incumbent is from
the LibDems, 0 otherwise</p>
</dd>
<dt><code>v1</code></dt><dd><p>a numeric vector, Conservative vote share
(proportion of 3 party vote)</p>
</dd>
<dt><code>v2</code></dt><dd><p>a numeric vector, Labor vote share  (proportion of 3 party vote)</p>
</dd>
<dt><code>v3</code></dt><dd><p>a numeric vector, LibDem vote share (proportion of 3 party vote)</p>
</dd>
</dl>



<h3>Details</h3>

<p>These data span only 521 of the 621 seats in the House of
Commons at the time of 1992 election.  Seats missing either a Conservative,
Labor, or a LibDem candidate appear to have been dropped.   
</p>
<p>The original Katz and King data set does not have case labels.  I
used matches to an additional data source to recover a set of constituency labels for
these data; labels could not recovered for two of the constituencies.
</p>


<h3>Source</h3>

<p>Jonathan Katz; Gary King. 1999. &quot;Replication data for: A Statistical Model of Multiparty Electoral Data&quot;, <a href="http://hdl.handle.net/1902.1/QIGTWZYTLZ">http://hdl.handle.net/1902.1/QIGTWZYTLZ</a>
</p>



<h3>References</h3>

<p>Katz, Jonathan and Gary King. 1999. &ldquo;A Statistical Model for
Multiparty Electoral Data&rdquo;. <em>American Political Science
Review</em>. 93(1): 15-32.
</p>
<p>Jackman, Simon. 2009.  <em>Bayesian Analysis for the Social
Sciences</em>.  Wiley: Chichester.  Example 6.9.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(UKHouseOfCommons)
tmp &lt;- UKHouseOfCommons[,c("v1","v2","v3")] 
summary(apply(tmp,1,sum))

col &lt;- rep("black",dim(tmp)[1])
col[UKHouseOfCommons$coninc==1] &lt;- "blue"
col[UKHouseOfCommons$labinc==1] &lt;- "red"
col[UKHouseOfCommons$libinc==1] &lt;- "orange"

library(vcd)
vcd::ternaryplot(tmp,
                 dimnames=c("Cons","Lab","Lib-Dem"),
                 labels="outside",
                 col=col,
                 pch=1,
                 main="1992 UK House of Commons Election",
                 cex=.75)
</code></pre>

<hr>
<h2 id='unionDensity'>cross national rates of trade union density</h2><span id='topic+unionDensity'></span>

<h3>Description</h3>

<p>Cross-national data on relative size of the trade unions and
predictors, in 20 countries.  Two of the predictors are highly
collinear, and are the source of a debate between Stephens and
Wallerstein (1991), later reviewed by Western and Jackman (1994).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(unionDensity)
</code></pre>


<h3>Format</h3>


<dl>
<dt><code>union</code></dt><dd><p>numeric, percentage of the total number of wage
and salary earners plus the unemployed who are union members,
measured between 1975 and 1980, with most of the data drawn from 1979</p>
</dd>
<dt><code>left</code></dt><dd><p>numeric, an index tapping the extent to which
parties of the left have controlled governments since 1919, due to
Wilensky (1981).</p>
</dd>
<dt><code>size</code></dt><dd><p>numeric, log of labor force size, defined as the
number of wage and salary earners, plus the unemployed</p>
</dd>
<dt><code>concen</code></dt><dd><p>numeric, percentage of employment, shipments, or
production accounted for by the four largest enterprises in a
particular industry, averaged over industries (with weights
proportional to the size of the industry) and the resulting measure
is normalized such that the United States scores a 1.0, and is due
to Pryor (1973). Some of the scores on this variable are imputed
using procedures described in Stephens and Wallerstein (1991, 945).</p>
</dd>
</dl>



<h3>Source</h3>

<p>Pryor, Frederic. 1973. <em>Property and Industrial
Organization in Communist and Capitalist Countries</em>. Bloomington:
Indiana University Press.  
</p>
<p>Stephens, John and Michael Wallerstein. 1991. Industrial
Concentration, Country Size and Trade Union Membership.
<em>American Political Science Review</em> 85:941-953.
</p>
<p>Western, Bruce and Simon Jackman. 1994. Bayesian Inference for
Comparative Research.  <em>American Political Science Review</em>
88:412-423. 
</p>
<p>Wilensky, Harold L. 1981. Leftism, Catholicism, Democratic
Corporatism: The Role of Political Parties in Recent Welfare State
Development. In <em>The Development of Welfare States in Europe
and America</em>, ed. Peter Flora and Arnold J. Heidenheimer. New
Brunswick: Transaction Books. 
</p>


<h3>References</h3>

<p>Jackman, Simon. 2009.  <em>Bayesian Analysis for the Social Sciences</em>. Wiley: Hoboken, New Jersey.</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(unionDensity)
summary(unionDensity)
pairs(unionDensity,
      labels=c("Union\nDensity",
        "Left\nGovernment",
        "log Size of\nLabor Force",
        "Economic\nConcentration"),
      lower.panel=function(x,y,digits=2){
        r &lt;- cor(x,y)
        par(usr=c(0,1,0,1))
        text(.5,.5,
             format(c(r,0.123456789),digits=digits)[1],
             cex=1.5)
      }
      )
ols &lt;- lm(union ~ left + size + concen,
          data=unionDensity)
summary(ols)
</code></pre>

<hr>
<h2 id='vectorRepresentation'>convert roll call matrix to series of vectors</h2><span id='topic+vectorRepresentation'></span>

<h3>Description</h3>

<p>Extract the information in a roll call matrix as a series of vectors
with voting decision, a unique identifier for the legislator and a
unique identifier for the roll call.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vectorRepresentation(object, dropList = list(codes = c("missing", "notInLegis")))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vectorRepresentation_+3A_object">object</code></td>
<td>
<p>an object of class <code><a href="#topic+rollcall">rollcall</a></code></p>
</td></tr>
<tr><td><code id="vectorRepresentation_+3A_droplist">dropList</code></td>
<td>
<p>a <code>dropList</code>; see <code><a href="#topic+dropRollCall">dropRollCall</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p> It is often the case that roll call matrices are sparse, say,
when the roll call matrix has an &ldquo;overlapping generations&rdquo;
structure; e.g., consider forming data by pooling across a long
temporal sequence of legislatures such that relatively few of the
legislators in the data set actually vote on any given roll call.  In
such a case, representing the data as a roll call matrix is not
particularly helpful nor efficient, either for data summaries or modeling.
</p>


<h3>Value</h3>

<p>A <code><a href="base.html#topic+matrix">matrix</a></code> with <code>z</code> rows, where <code>z</code> is the
number of non-missing entries in <code>object$votes</code>, with
&lsquo;missingness&rsquo; defined by the <code>codes</code> component of the
<code>dropList</code>.  The matrix has 3 columns:
</p>
<table>
<tr><td><code>vote</code></td>
<td>
<p>the voting decision, either a <code>1</code> if the
corresponding element of the roll call matrix <code>object$votes</code>
is in the <code>yea</code> component of <code>object$codes</code>, or a <code>0</code>
if the corresponding element of the roll call matrix is in the
<code>nay</code> component of <code>object$codes</code>.  Non-missing entries of
the roll call matrix are not stored.</p>
</td></tr>
<tr><td><code>i</code></td>
<td>
<p>the row of the roll call matrix <code>object$votes</code> that
supplied the voting decision; i.e., a unique identifier for the
legislator generating this <code>vote</code></p>
</td></tr>
<tr><td><code>j</code></td>
<td>
<p>the column of the roll call matrix <code>object$votes</code> that
supplied the <code>vote</code>; i.e., a unique identifier for the vote.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Simon Jackman <a href="mailto:simon.jackman@sydney.edu.au">simon.jackman@sydney.edu.au</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+rollcall">rollcall</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(s109)
y &lt;- vectorRepresentation(s109)
apply(y,2,table,exclude=NULL)
</code></pre>

<hr>
<h2 id='vote92'>
Reports of voting in the 1992 U.S. Presidential election.
</h2><span id='topic+vote92'></span>

<h3>Description</h3>

<p>Survey data containing self-reports of vote choice in the 1992 U.S. Presidential election, with numerous covariates, from the 1992 American National Election Studies.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(vote92)</code></pre>


<h3>Format</h3>

<p>A data frame with 909 observations on the following 10 variables.
</p>

<dl>
<dt><code>vote</code></dt><dd><p>a factor with levels <code>Perot</code> <code>Clinton</code> <code>Bush</code></p>
</dd>
<dt><code>dem</code></dt><dd><p>a numeric vector, 1 if the respondent reports identifying with the Democratic party, 0 otherwise.</p>
</dd>
<dt><code>rep</code></dt><dd><p>a numeric vector, 1 if the respondent reports identifying with the Republican party, 0 otherwise</p>
</dd>
<dt><code>female</code></dt><dd><p>a numeric vector, 1 if the respondent is female, 0 otherwise</p>
</dd>
<dt><code>persfinance</code></dt><dd><p>a numeric vector, -1 if the respondent reports that their personal financial situation has gotten worse over the last 12 months, 0 for no change, 1 if better</p>
</dd>
<dt><code>natlecon</code></dt><dd><p>a numeric vector, -1 if the respondent reports that national economic conditions have gotten worse over the last 12 months, 0 for no change, 1 if better</p>
</dd>
<dt><code>clintondis</code></dt><dd><p>a numeric vector, squared difference between respondent's self-placement on a scale measure of political ideology and the respondent's placement of the Democratic candidate, Bill Clinton</p>
</dd>
<dt><code>bushdis</code></dt><dd><p>a numeric vector, squared ideological distance of the respondent from the Republican candidate, President George H.W. Bush</p>
</dd>
<dt><code>perotdis</code></dt><dd><p>a numeric vector, squared ideological distance of the respondent from the Reform Party candidate, Ross Perot</p>
</dd>
</dl>



<h3>Details</h3>

<p>These data are unweighted.  Refer to the original data source for weights that purport to correct for non-representativeness and non-response.</p>


<h3>Source</h3>

<p>Alvarez, R. Michael and Jonathan Nagler. 1995. Economics, issues and the Perot candidacy: Voter choice in the 1992 Presidential election.  <em>American Journal of Political Science</em>. 39:714-44.
</p>
<p>Miller, Warren E., Donald R. Kinder, Steven J. Rosenstone and the National Election Studies.  1999.  <em>National Election Studies, 1992: Pre-/Post-Election Study</em>.  Center for Political Studies, University of Michigan: Ann Arbor, Michigan.
</p>
<p>Inter-University Consortium for Political and Social Research.  Study Number 1112.  <a href="https://doi.org/10.3886/ICPSR01112">doi:10.3886/ICPSR01112</a>.   	
</p>


<h3>References</h3>

<p>Jackman, Simon. 2009.  <em>Bayesian Analysis for the Social Sciences</em>.
Wiley: Hoboken, New Jersey.  Examples 8.7 and 8.8.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(vote92)
summary(vote92)
</code></pre>

<hr>
<h2 id='vuong'>Vuong's non-nested hypothesis test</h2><span id='topic+vuong'></span>

<h3>Description</h3>

<p>Compares two models fit to the same data that do not nest via Vuong's
non-nested test.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vuong(m1, m2, digits = getOption("digits"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vuong_+3A_m1">m1</code></td>
<td>
<p>model 1, an object inheriting from class <code>glm</code>,
<code>negbin</code> or <code>zeroinfl</code></p>
</td></tr>
<tr><td><code id="vuong_+3A_m2">m2</code></td>
<td>
<p>model 2, as for model 1</p>
</td></tr>
<tr><td><code id="vuong_+3A_digits">digits</code></td>
<td>
<p>significant digits in printed result</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Vuong non-nested test is based on a comparison of the predicted
probabilities of two models that do not nest.  Examples include
comparisons of zero-inflated count models with their non-zero-inflated
analogs (e.g., zero-inflated Poisson versus ordinary Poisson, or
zero-inflated negative-binomial versus ordinary negative-binomial).  A
large, positive test statistic provides evidence of
the superiority of model 1 over model 2, while a large, negative test statistic is
evidence of the superiority of model 2 over model 1.  Under the null
that the models are indistinguishable, the test
statistic is asymptotically distributed standard normal.
</p>
<p>Let <code class="reqn">p_i = \hat{Pr}(y_i | M_1)</code> be the predicted probabilities from model 1, evaluated conditional on the estimated MLEs.   Let <code class="reqn">q_i</code> be the corresponding probabilities from model 2.   Then the Vuong statistic is <code class="reqn">\sqrt{N} \bar{m}/s_m</code> where <code class="reqn">m_i = log(p_i) - log(q_i)</code> and <code class="reqn">s_m</code> is the sample standard deviation of <code class="reqn">m_i</code>.
</p>
<p>Two finite sample corrections are often considered, based on the Akaike (AIC) and Schwarz (BIC) penalty terms, based on the complexity of the two models. These corrections sometimes generate conflicting conclusions. 
</p>
<p>The function will fail if the models do not contain identical values
in their respective components named <code>y</code> (the value of the
response being modeled).
</p>


<h3>Value</h3>

<p>nothing returned, prints 3 test statistics and <code class="reqn">p</code> values and
exits silently.
</p>


<h3>Author(s)</h3>

<p>Simon Jackman <a href="mailto:simon.jackman@sydney.edu.au">simon.jackman@sydney.edu.au</a></p>


<h3>References</h3>

<p>Vuong, Q.H. 1989. Likelihood ratio tests for model
selection and non-nested hypotheses. <em>Econometrica</em>. 57:307-333.</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data("bioChemists")
## compare Poisson GLM and ZIP
glm1 &lt;- glm(art ~ ., data = bioChemists, family = poisson)
zip &lt;- zeroinfl(art ~ . | ., data = bioChemists, EM = TRUE)
vuong(glm1, zip)


## compare negbin with zero-inflated negbin
nb1 &lt;- MASS::glm.nb(art ~ ., data=bioChemists)
zinb &lt;- zeroinfl(art ~ . | ., data = bioChemists, dist = "negbin", EM = TRUE)
vuong(nb1, zinb)

## End(Not run)
</code></pre>

<hr>
<h2 id='zeroinfl'>Zero-inflated Count Data Regression</h2><span id='topic+zeroinfl'></span><span id='topic+print.zeroinfl'></span>

<h3>Description</h3>

<p>Fit zero-inflated regression models for count data via maximum likelihood.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>zeroinfl(formula, data, subset, na.action, weights, offset,
  dist = c("poisson", "negbin", "geometric"),
  link = c("logit", "probit", "cloglog", "cauchit", "log"),
  control = zeroinfl.control(...),
  model = TRUE, y = TRUE, x = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="zeroinfl_+3A_formula">formula</code></td>
<td>
<p>symbolic description of the model, see details.</p>
</td></tr>
<tr><td><code id="zeroinfl_+3A_data">data</code>, <code id="zeroinfl_+3A_subset">subset</code>, <code id="zeroinfl_+3A_na.action">na.action</code></td>
<td>
<p>arguments controlling formula processing
via <code><a href="stats.html#topic+model.frame">model.frame</a></code>.</p>
</td></tr>
<tr><td><code id="zeroinfl_+3A_weights">weights</code></td>
<td>
<p>optional numeric vector of weights.</p>
</td></tr>
<tr><td><code id="zeroinfl_+3A_offset">offset</code></td>
<td>
<p>optional numeric vector with an a priori known component to be
included in the linear predictor of the count model. See below for more
information on offsets.</p>
</td></tr>
<tr><td><code id="zeroinfl_+3A_dist">dist</code></td>
<td>
<p>character specification of count model family (a log link is 
always used).</p>
</td></tr>
<tr><td><code id="zeroinfl_+3A_link">link</code></td>
<td>
<p>character specification of link function in the binary
zero-inflation model (a binomial family is always used).</p>
</td></tr>
<tr><td><code id="zeroinfl_+3A_control">control</code></td>
<td>
<p>a list of control arguments specified via
<code><a href="#topic+zeroinfl.control">zeroinfl.control</a></code>.</p>
</td></tr>
<tr><td><code id="zeroinfl_+3A_model">model</code>, <code id="zeroinfl_+3A_y">y</code>, <code id="zeroinfl_+3A_x">x</code></td>
<td>
<p>logicals. If <code>TRUE</code> the corresponding components
of the fit (model frame, response, model matrix) are returned.</p>
</td></tr>
<tr><td><code id="zeroinfl_+3A_...">...</code></td>
<td>
<p>arguments passed to <code><a href="#topic+zeroinfl.control">zeroinfl.control</a></code> in the
default setup.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Zero-inflated count models are two-component mixture models
combining a point mass at zero with a proper count distribution.
Thus, there are two sources of zeros: zeros may come from 
both the point mass and from the count component. Usually the count model 
is a Poisson or negative binomial regression (with log link). 
The geometric distribution is a special case of the negative binomial
with size parameter equal to 1.
For modeling the unobserved state (zero vs. count), a binary model is used
that captures the probability of zero inflation.
in the simplest case only with an intercept but potentially containing regressors.
For this zero-inflation model, a binomial model with different links can be
used, typically logit or probit.
</p>
<p>The <code>formula</code> can be used to specify both components of the model:
If a <code>formula</code> of type <code>y ~ x1 + x2</code> is supplied, then the same
regressors are employed in both components. This is equivalent to
<code>y ~ x1 + x2 | x1 + x2</code>. Of course, a different set of regressors
could be specified for the count and zero-inflation component, e.g.,
<code>y ~ x1 + x2 | z1 + z2 + z3</code> giving the count data model <code>y ~ x1 + x2</code>
conditional on (<code>|</code>) the zero-inflation model <code>y ~ z1 + z2 + z3</code>.
A simple inflation model where all zero counts have the same
probability of belonging to the zero component can by specified by the formula
<code>y ~ x1 + x2 | 1</code>.
</p>
<p>Offsets can be specified in both components of the model pertaining to count and
zero-inflation model: <code>y ~ x1 + offset(x2) | z1 + z2 + offset(z3)</code>, where
<code>x2</code> is used as an offset (i.e., with coefficient fixed to 1) in the
count component and <code>z3</code> analogously in the zero-inflation component. By the rule
stated above <code>y ~ x1 + offset(x2)</code> is expanded to
<code>y ~ x1 + offset(x2) | x1 + offset(x2)</code>. Instead of using the
<code>offset()</code> wrapper within the <code>formula</code>, the <code>offset</code> argument
can also be employed which sets an offset only for the count model. Thus,
<code>formula = y ~ x1</code> and <code>offset = x2</code> is equivalent to
<code>formula = y ~ x1 + offset(x2) | x1</code>.  
</p>
<p>All parameters are estimated by maximum likelihood using <code><a href="stats.html#topic+optim">optim</a></code>,
with control options set in <code><a href="#topic+zeroinfl.control">zeroinfl.control</a></code>.
Starting values can be supplied, estimated by the EM (expectation maximization)
algorithm, or by <code><a href="stats.html#topic+glm.fit">glm.fit</a></code> (the default). Standard errors
are derived numerically using the Hessian matrix returned by <code><a href="stats.html#topic+optim">optim</a></code>.
See <code><a href="#topic+zeroinfl.control">zeroinfl.control</a></code> for details.
</p>
<p>The returned fitted model object is of class <code>"zeroinfl"</code> and is similar
to fitted <code>"glm"</code> objects. For elements such as <code>"coefficients"</code> or
<code>"terms"</code> a list is returned with elements for the zero and count component,
respectively. For details see below.
</p>
<p>A set of standard extractor functions for fitted model objects is available for
objects of class <code>"zeroinfl"</code>, including methods to the generic functions
<code><a href="base.html#topic+print">print</a></code>, <code><a href="base.html#topic+summary">summary</a></code>, <code><a href="stats.html#topic+coef">coef</a></code>, 
<code><a href="stats.html#topic+vcov">vcov</a></code>, <code><a href="stats.html#topic+logLik">logLik</a></code>, <code><a href="stats.html#topic+residuals">residuals</a></code>, 
<code><a href="stats.html#topic+predict">predict</a></code>, <code><a href="stats.html#topic+fitted">fitted</a></code>, <code><a href="stats.html#topic+terms">terms</a></code>,
<code><a href="stats.html#topic+model.matrix">model.matrix</a></code>. See <code><a href="#topic+predict.zeroinfl">predict.zeroinfl</a></code> for more details
on all methods.
</p>


<h3>Value</h3>

<p>An object of class <code>"zeroinfl"</code>, i.e., a list with components including
</p>
<table>
<tr><td><code>coefficients</code></td>
<td>
<p>a list with elements <code>"count"</code> and <code>"zero"</code>
containing the coefficients from the respective models,</p>
</td></tr>
<tr><td><code>residuals</code></td>
<td>
<p>a vector of raw residuals (observed - fitted),</p>
</td></tr>
<tr><td><code>fitted.values</code></td>
<td>
<p>a vector of fitted means,</p>
</td></tr>
<tr><td><code>optim</code></td>
<td>
<p>a list with the output from the <code>optim</code> call for
minimizing the negative log-likelihood,</p>
</td></tr>
<tr><td><code>control</code></td>
<td>
<p>the control arguments passed to the <code>optim</code> call,</p>
</td></tr>
<tr><td><code>start</code></td>
<td>
<p>the starting values for the parameters passed to the <code>optim</code> call,</p>
</td></tr>
<tr><td><code>weights</code></td>
<td>
<p>the case weights used,</p>
</td></tr>
<tr><td><code>offset</code></td>
<td>
<p>a list with elements <code>"count"</code> and <code>"zero"</code>
containing the offset vectors (if any) from the respective models,</p>
</td></tr>
<tr><td><code>n</code></td>
<td>
<p>number of observations (with weights &gt; 0),</p>
</td></tr>
<tr><td><code>df.null</code></td>
<td>
<p>residual degrees of freedom for the null model (= <code>n - 2</code>),</p>
</td></tr>
<tr><td><code>df.residual</code></td>
<td>
<p>residual degrees of freedom for fitted model,</p>
</td></tr>
<tr><td><code>terms</code></td>
<td>
<p>a list with elements <code>"count"</code>, <code>"zero"</code> and
<code>"full"</code> containing the terms objects for the respective models,</p>
</td></tr>
<tr><td><code>theta</code></td>
<td>
<p>estimate of the additional <code class="reqn">\theta</code> parameter of the
negative binomial model (if a negative binomial regression is used),</p>
</td></tr>
<tr><td><code>SE.logtheta</code></td>
<td>
<p>standard error for <code class="reqn">\log(\theta)</code>,</p>
</td></tr>
<tr><td><code>loglik</code></td>
<td>
<p>log-likelihood of the fitted model,</p>
</td></tr>
<tr><td><code>vcov</code></td>
<td>
<p>covariance matrix of all coefficients in the model (derived from the
Hessian of the <code>optim</code> output),</p>
</td></tr>
<tr><td><code>dist</code></td>
<td>
<p>character string describing the count distribution used,</p>
</td></tr>
<tr><td><code>link</code></td>
<td>
<p>character string describing the link of the zero-inflation model,</p>
</td></tr>
<tr><td><code>linkinv</code></td>
<td>
<p>the inverse link function corresponding to <code>link</code>,</p>
</td></tr>
<tr><td><code>converged</code></td>
<td>
<p>logical indicating successful convergence of <code>optim</code>,</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>the original function call,</p>
</td></tr>
<tr><td><code>formula</code></td>
<td>
<p>the original formula,</p>
</td></tr>
<tr><td><code>levels</code></td>
<td>
<p>levels of the categorical regressors,</p>
</td></tr>
<tr><td><code>contrasts</code></td>
<td>
<p>a list with elements <code>"count"</code> and <code>"zero"</code>
containing the contrasts corresponding to <code>levels</code> from the
respective models,</p>
</td></tr>
<tr><td><code>model</code></td>
<td>
<p>the full model frame (if <code>model = TRUE</code>),</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>the response count vector (if <code>y = TRUE</code>),</p>
</td></tr>
<tr><td><code>x</code></td>
<td>
<p>a list with elements <code>"count"</code> and <code>"zero"</code>
containing the model matrices from the respective models
(if <code>x = TRUE</code>),</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Achim Zeileis &lt;Achim.Zeileis@R-project.org&gt;</p>


<h3>References</h3>

<p>Cameron, A. Colin and Pravin K. Trevedi. 1998. <em>Regression Analysis of Count 
Data.</em> New York: Cambridge University Press.
</p>
<p>Cameron, A. Colin and Pravin K. Trivedi. 2005. <em>Microeconometrics: Methods and Applications</em>.
Cambridge: Cambridge University Press.
</p>
<p>Lambert, Diane. 1992. &ldquo;Zero-Inflated Poisson Regression,
with an Application to Defects in Manufacturing.&rdquo; <em>Technometrics</em>. <b>34</b>(1):1-14. <a href="https://doi.org/10.2307/1269547">doi:10.2307/1269547</a> 
</p>
<p>Zeileis, Achim, Christian Kleiber and Simon Jackman 2008.
&ldquo;Regression Models for Count Data in R.&rdquo; 
<em>Journal of Statistical Software</em>, <b>27</b>(8).
URL <a href="https://www.jstatsoft.org/v27/i08/">https://www.jstatsoft.org/v27/i08/</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+zeroinfl.control">zeroinfl.control</a></code>, <code><a href="stats.html#topic+glm">glm</a></code>,
<code><a href="stats.html#topic+glm.fit">glm.fit</a></code>, <code><a href="MASS.html#topic+glm.nb">glm.nb</a></code>,
<code><a href="#topic+hurdle">hurdle</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## data
data("bioChemists", package = "pscl")

## without inflation
## ("art ~ ." is "art ~ fem + mar + kid5 + phd + ment")
fm_pois &lt;- glm(art ~ ., data = bioChemists, family = poisson)
fm_qpois &lt;- glm(art ~ ., data = bioChemists, family = quasipoisson)
fm_nb &lt;- MASS::glm.nb(art ~ ., data = bioChemists)

## with simple inflation (no regressors for zero component)
fm_zip &lt;- zeroinfl(art ~ . | 1, data = bioChemists)
fm_zinb &lt;- zeroinfl(art ~ . | 1, data = bioChemists, dist = "negbin")

## inflation with regressors
## ("art ~ . | ." is "art ~ fem + mar + kid5 + phd + ment | fem + mar + kid5 + phd + ment")
fm_zip2 &lt;- zeroinfl(art ~ . | ., data = bioChemists)
fm_zinb2 &lt;- zeroinfl(art ~ . | ., data = bioChemists, dist = "negbin")
</code></pre>

<hr>
<h2 id='zeroinfl.control'>Control Parameters for Zero-inflated Count Data Regression</h2><span id='topic+zeroinfl.control'></span>

<h3>Description</h3>

<p>Various parameters that control fitting of zero-inflated regression models
using <code><a href="#topic+zeroinfl">zeroinfl</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>zeroinfl.control(method = "BFGS", maxit = 10000, trace = FALSE,
  EM = FALSE, start = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="zeroinfl.control_+3A_method">method</code></td>
<td>
<p>characters string specifying the <code>method</code> argument
passed to <code><a href="stats.html#topic+optim">optim</a></code>.</p>
</td></tr>
<tr><td><code id="zeroinfl.control_+3A_maxit">maxit</code></td>
<td>
<p>integer specifying the <code>maxit</code> argument (maximal number
of iterations) passed to <code><a href="stats.html#topic+optim">optim</a></code>.</p>
</td></tr>
<tr><td><code id="zeroinfl.control_+3A_trace">trace</code></td>
<td>
<p>logical or integer controlling whether tracing information on 
the progress of the optimization should be produced (passed to <code><a href="stats.html#topic+optim">optim</a></code>).</p>
</td></tr>
<tr><td><code id="zeroinfl.control_+3A_em">EM</code></td>
<td>
<p>logical. Should starting values be estimated by the EM (expectation
maximization) algorithm? See details.</p>
</td></tr>
<tr><td><code id="zeroinfl.control_+3A_start">start</code></td>
<td>
<p>an optional list with elements <code>"count"</code> and <code>"zero"</code>
(and potentially <code>"theta"</code>) containing the coefficients for the corresponding component.</p>
</td></tr>
<tr><td><code id="zeroinfl.control_+3A_...">...</code></td>
<td>
<p>arguments passed to <code><a href="stats.html#topic+optim">optim</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>All parameters in <code><a href="#topic+zeroinfl">zeroinfl</a></code> are estimated by maximum likelihood
using <code><a href="stats.html#topic+optim">optim</a></code> with control options set in <code><a href="#topic+zeroinfl.control">zeroinfl.control</a></code>.
Most arguments are passed on directly to <code>optim</code>, only <code>trace</code> is also
used within <code>zeroinfl</code> and <code>EM</code>/<code>start</code> control the choice
of starting values for calling <code>optim</code>.
</p>
<p>Starting values can be supplied, estimated by the EM (expectation maximization)
algorithm, or by <code><a href="stats.html#topic+glm.fit">glm.fit</a></code> (the default). Standard errors are
derived numerically using
the Hessian matrix returned by <code><a href="stats.html#topic+optim">optim</a></code>. To supply starting 
values, <code>start</code> should be a list with elements <code>"count"</code> and <code>"zero"</code>
and potentially <code>"theta"</code> (for negative binomial components only) containing
the starting values for the coefficients of the corresponding component of the
model.
</p>


<h3>Value</h3>

<p>A list with the arguments specified.
</p>


<h3>Author(s)</h3>

<p>Achim Zeileis &lt;Achim.Zeileis@R-project.org&gt;</p>


<h3>See Also</h3>

<p><code><a href="#topic+zeroinfl">zeroinfl</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data("bioChemists", package = "pscl")

## default start values
fm1 &lt;- zeroinfl(art ~ ., data = bioChemists)

## use EM algorithm for start values
fm2 &lt;- zeroinfl(art ~ ., data = bioChemists, EM = TRUE)

## user-supplied start values
fm3 &lt;- zeroinfl(art ~ ., data = bioChemists,
  start = list(count = c(0.7, -0.2, 0.1, -0.2, 0, 0), zero = -1.7))

## End(Not run)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
