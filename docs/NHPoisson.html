<!DOCTYPE html><html><head><title>Help for package NHPoisson</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {NHPoisson}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#addAIC.fun'><p>Calculate the AIC  for all one-covariate additions to  the current model</p></a></li>
<li><a href='#BarTxTn'><p>Barcelona temperature data</p></a></li>
<li><a href='#CalcRes.fun'><p>Calculate NHPP residuals on overlapping intervals</p></a></li>
<li><a href='#CalcResD.fun'><p>Calculate NHPP residuals on disjoint intervals</p></a></li>
<li><a href='#CIdelta.fun'><p>Confidence intervals  for   <code class="reqn">\lambda(t)</code> using delta method</p></a></li>
<li><a href='#CItran.fun'><p>Confidence intervals for  <code class="reqn">\lambda(t)</code> based on transformation</p></a></li>
<li><a href='#confintAsin.fun'><p>Compute confidence intervals for  the  <code class="reqn">\beta</code> parameters</p></a></li>
<li><a href='#dropAIC.fun'><p>Calculate the AIC for all one-covariate deletions from the  current model</p></a></li>
<li><a href='#emplambda.fun'><p>Empirical occurrence rates of a NHPP on overlapping intervals</p></a></li>
<li><a href='#emplambdaD.fun'><p>Empirical occurrence rates of a NHPP on disjoint intervals</p></a></li>
<li><a href='#extractAIC-methods'><p> Method  <code>mle</code> for Function <code>extractAIC</code></p></a></li>
<li><a href='#fitPP.fun'><p>Fit  a non homogeneous Poisson Process</p></a></li>
<li><a href='#GenEnv.fun'><p>Calculation of simulated envelopes</p></a></li>
<li><a href='#globalval.fun'><p>Perform a global validation analysis for a NHPP</p></a></li>
<li><a href='#graphrate.fun'><p>Plot fitted and  empirical  PP occurrence rates</p></a></li>
<li><a href='#graphres.fun'><p>Plot NHPP residuals versus time or  monotonous variables</p></a></li>
<li><a href='#graphResCov.fun'><p>Perform lurking variable plots for a set of variables</p></a></li>
<li><a href='#graphresU.fun'><p>Validation analysis of PP uniform (generalized) residuals</p></a></li>
<li><a href='#graphResX.fun'><p>Perform a lurking  variable plot</p></a></li>
<li><a href='#LRTpv.fun'><p>Calculate the p-value of a likelihood ratio test for each covariate in the model</p></a></li>
<li><a href='#mlePP-class'><p>Class <code>"mlePP"</code> for results of maximum likelihood estimation of Poisson processes with covariates</p></a></li>
<li><a href='#NHPoisson-package'><p>Statistical modelling of non homogeneous Poisson processes</p></a></li>
<li><a href='#POTevents.fun'><p>Calculate extreme events using a POT approach</p></a></li>
<li><a href='#profile-methods'><p> Method <code>mlePP</code> for Function <code>profile</code></p></a></li>
<li><a href='#resQQplot.fun'><p>Perform a qqplot for the residuals of a NHPP</p></a></li>
<li><a href='#simNHP.fun'><p>Generate the occurrence points of a NHPP</p></a></li>
<li><a href='#stepAICmle.fun'><p>Choose  the best PP model by AIC in a stepwise algorithm</p></a></li>
<li><a href='#testlik.fun'><p>Likelihood ratio test to compare two nested models</p></a></li>
<li><a href='#transfH.fun'><p>Transform  a NHPP into a HPP</p></a></li>
<li><a href='#unifres.fun'><p>Calculate exponential and uniform (generalized) residuals of a HPP</p></a></li>
<li><a href='#VARbeta.fun'><p>Calculate the covariance matrix of the <code class="reqn">\hat \beta</code> vector.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Modelling and Validation of Non Homogeneous Poisson Processes</td>
</tr>
<tr>
<td>Version:</td>
<td>3.3</td>
</tr>
<tr>
<td>Date:</td>
<td>2020-02-18</td>
</tr>
<tr>
<td>Author:</td>
<td>Ana C. Cebrian &lt;acebrian@unizar.es&gt;</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Ana C. Cebrian &lt;acebrian@unizar.es&gt;</td>
</tr>
<tr>
<td>Imports:</td>
<td>parallel, car</td>
</tr>
<tr>
<td>Depends:</td>
<td>methods, stats4</td>
</tr>
<tr>
<td>Description:</td>
<td>Tools for modelling, ML estimation, validation analysis and simulation of non homogeneous Poisson processes in time. </td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2020-02-19 10:52:48 UTC; acebrian</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2020-02-19 11:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='addAIC.fun'>Calculate the AIC  for all one-covariate additions to  the current model</h2><span id='topic+addAIC.fun'></span>

<h3>Description</h3>

<p> This function fits all models that differ from the current model by adding a single covariate from 
those supplied,  and calculates their AIC value. It selects the best covariate to be added to the model, 
according to the AIC.</p>


<h3>Usage</h3>

<pre><code class='language-R'>addAIC.fun(mlePP, covariatesAdd, startAdd = NULL, modSim = FALSE,...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="addAIC.fun_+3A_mlepp">mlePP</code></td>
<td>
<p>A <code>"<a href="#topic+mlePP-class">mlePP</a>"</code>-class object; usually the output from <code><a href="#topic+fitPP.fun">fitPP.fun</a></code>. 
It defines the current model.  The fitted model cannot include fixed parameters.</p>
</td></tr>
<tr><td><code id="addAIC.fun_+3A_covariatesadd">covariatesAdd</code></td>
<td>
<p>Matrix   of the potential covariates to be added to the model; each column  must 
contain a covariate.</p>
</td></tr>
<tr><td><code id="addAIC.fun_+3A_startadd">startAdd</code></td>
<td>
<p>Optional. The vector of initial values  for the estimation  algorithm of  the coefficients 
of each potential covariate. If it  is NULL,  initial values  equal to 0 are used. Remark
that in contrast to argument <code>start</code> of <code><a href="#topic+fitPP.fun">fitPP.fun</a></code>, <code>startAdd</code> is a  numeric vector not a list.</p>
</td></tr>
<tr><td><code id="addAIC.fun_+3A_modsim">modSim</code></td>
<td>
<p>Logical flag. If it is FALSE, information about the process is shown on the screen.
For automatic selection processes, the option TRUE should be preferred.</p>
</td></tr>
<tr><td><code id="addAIC.fun_+3A_...">...</code></td>
<td>
<p>Further arguments to pass to <code><a href="stats.html#topic+AIC">AIC</a></code>, for example the constant k for the AIC calculation.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The definition of AIC uses constant k=2, but  a different value  k can be passed as
an additional argument. The best covariate to be added  is the one which leads to  the model with the lowest AIC value
and it  improves the current model if the new AIC is lower than the current one. </p>


<h3>Value</h3>

<p> A list with the following components
</p>
<table>
<tr><td><code>AICadd</code></td>
<td>
<p>Vector of the AIC values obtained from  adding to the current model each covariate in  <code>covariatesAdd</code>.</p>
</td></tr>
<tr><td><code>posminAIC</code></td>
<td>
<p>An integer indicating the number of the column  of covariatesAdd with the covariate leading to the minimum AIC.</p>
</td></tr>
<tr><td><code>namecov</code></td>
<td>
<p>Name of the covariate leading to the minimum AIC.</p>
</td></tr>
<tr><td><code>AICcurrent</code></td>
<td>
<p>AIC value of the current (initial) model.</p>
</td></tr>
<tr><td><code>newCoef</code></td>
<td>
<p>A (named) list with   the  initial value for the coefficient
of the best covariate to be added. It is used in <code><a href="#topic+stepAICmle.fun">stepAICmle.fun</a></code>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+dropAIC.fun">dropAIC.fun</a></code>, <code><a href="#topic+stepAICmle.fun">stepAICmle.fun</a></code>, <code><a href="#topic+LRTpv.fun">LRTpv.fun</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(BarTxTn)

BarEv&lt;-POTevents.fun(T=BarTxTn$Tx,thres=318, 
	date=cbind(BarTxTn$ano,BarTxTn$mes,BarTxTn$dia))

#The initial model contains only the intercept
 mod1Bind&lt;-fitPP.fun(covariates=NULL, posE=BarEv$Px, inddat=BarEv$inddat,
	tit='BAR  Intercept ', 	start=list(b0=1))
#the potential covariates
covB&lt;-cbind(cos(2*pi*BarTxTn$dia/365), sin(2*pi*BarTxTn$dia/365), 
	BarTxTn$TTx,BarTxTn$Txm31,BarTxTn$Txm31**2)
dimnames(covB)&lt;-list(NULL,c('cos','sin','TTx','Txm31', 'Txm31**2'))

aux&lt;-addAIC.fun(mod1Bind, covariatesAdd=covB)
</code></pre>

<hr>
<h2 id='BarTxTn'>Barcelona temperature data</h2><span id='topic+BarTxTn'></span>

<h3>Description</h3>

<p>Barcelona daily temperature series during the summer months (May, June, July, 
August and September) from  1951 to 2004.</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(BarTxTn)</code></pre>


<h3>Details</h3>

<p>Variables
</p>
<p>dia: Postion of the day in the year, from 121 (1st of May) to 253 (30th of September).
</p>
<p>mes: Month of the year, from 5 to 9.
</p>
<p>ano: Year, from 1951 to 2004.
</p>
<p>diames: Position of the day in the month, from 1 to 30 or 31.
</p>
<p>Tx: Daily maximum temperature.
</p>
<p>Tn: Daily minimum temperature.
</p>
<p>Txm31: Local maximum temperature signal. Lowess of Tx with a centered window of 31 days.
</p>
<p>Txm15: Local maximum temperature signal. Lowess of Tx with a centered window of 15 days.
</p>
<p>Tnm31: Local minimum temperature signal. Lowess of Tn with a centered window of 31 days.
</p>
<p>Tnm15: Local minimum temperature signal. Lowess of Tn with a centered window of 15 days.
</p>
<p>TTx: Long term maximum temperature signal. Lowess of Tx with a centered 40% window.
</p>
<p>TTn: Long term minimum temperature signal. Lowess of Tn with a centered 40% window.
</p>


<h3>References</h3>

<p>Cebrian, A.C., Abaurrea, J. and Asin, J. (2015). NHPoisson: An R Package for 
Fitting and Validating Nonhomogeneous Poisson Processes. 
<em>Journal of Statistical Software</em>, 64(6), 1-24.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(BarTxTn)
</code></pre>

<hr>
<h2 id='CalcRes.fun'>Calculate NHPP residuals on overlapping intervals</h2><span id='topic+CalcRes.fun'></span>

<h3>Description</h3>

<p>This function calculates raw and scaled residuals of a NHPP based on 
overlapping intervals. The scaled residuals can be Pearson or any other type of scaled residuals
defined by the function <code class="reqn">h(t)</code>. </p>


<h3>Usage</h3>

<pre><code class='language-R'>CalcRes.fun(mlePP, lint, h = NULL, typeRes = NULL)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CalcRes.fun_+3A_mlepp">mlePP</code></td>
<td>
<p>An object of class <code><a href="#topic+mlePP-class">mlePP-class</a></code>; usually,
the output  from <code><a href="#topic+fitPP.fun">fitPP.fun</a></code>.</p>
</td></tr>
<tr><td><code id="CalcRes.fun_+3A_lint">lint</code></td>
<td>
<p>Length of the  intervals to calculate the residuals.</p>
</td></tr>
<tr><td><code id="CalcRes.fun_+3A_h">h</code></td>
<td>
<p>Optional. Weight function to calculate the scaled residuals. By default,  
Pearson residuals with <code class="reqn">h(t)=1/\sqrt{\hat \lambda(t)}</code> are calculated.</p>
</td></tr>
<tr><td><code id="CalcRes.fun_+3A_typeres">typeRes</code></td>
<td>
<p>Optional. Label indicating the type of scaled residuals. By default,  
Pearson residuals  are calculated and label is 'Pearson'.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The raw residuals are  based on the increments of 
the raw process <code class="reqn">R(t)=N_t-\int_0^t\hat\lambda(u)du</code> 
in  overlapping  intervals  <code class="reqn">(l_1, l_2)</code> centered on t:
</p>
<p style="text-align: center;"><code class="reqn">r'(l_1, l_2)=R(l_2)-R(l_1)=\sum_{t_i \in (l_1,l_2)}I_{t_i}-\int_{l_1}^{l_2} \hat \lambda(u)du.</code>
</p>

<p>Residuals <code class="reqn">r'(l_1, l_2)</code> are made 'instantaneous' dividing by the
length of the intervals (specified by the argument lint),
<code class="reqn">r(l_1, l_2)=r'(l_1,l_2)/(l_2-l_1)</code>. A residual is calculated
for each time in the observation period.  
</p>
<p>The function also calculates  the residuals scaled  with  the function <code class="reqn">h(t)</code>
</p>
<p style="text-align: center;"><code class="reqn">r_{sca}(l_1, l_2)=\sum_{t_i \in (l_1,l_2)}h(t_i)-\int_{l_1}^{l_2}  h(u)\hat \lambda(u)du.</code>
</p>

<p>By default,  Pearson residuals with <code class="reqn">h(t)=1/\sqrt{\hat \lambda(t)}</code> are calculated.</p>


<h3>Value</h3>

<p>A list with elements
</p>
<table>
<tr><td><code>RawRes</code></td>
<td>
<p>Numeric vector of the raw residuals.</p>
</td></tr>
<tr><td><code>ScaRes</code></td>
<td>
<p>A list with elements ScaRes (vector of the scaled residuals) 
and typeRes (name of the type of scaled residuals).</p>
</td></tr>
<tr><td><code>emplambda</code></td>
<td>
<p>Numeric vector of the empirical estimator of the PP intensity  on the 
considered intervals.</p>
</td></tr>
<tr><td><code>fittedlambda</code></td>
<td>
<p>Numeric vector of the   sum  of the intensities 
<code class="reqn">\hat \lambda(t)</code>  on the considered intervals, divided by the length of the interval.</p>
</td></tr>
<tr><td><code>lintV</code></td>
<td>
<p>Numeric vector of the  exact length of each interval. 
The exact length is defined as the number of observations  in each interval used in the 
estimation (observations with inddat=1).</p>
</td></tr>
<tr><td><code>lint</code></td>
<td>
<p>Input argument.</p>
</td></tr>
<tr><td><code>typeI</code></td>
<td>
<p>Label indicating  the type  of intervals
used to calculate the residuals, 'Overlapping'.</p>
</td></tr>
<tr><td><code>h</code></td>
<td>
<p>Input argument.</p>
</td></tr>
<tr><td><code>mlePP</code></td>
<td>
<p>Input argument.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Abaurrea, J., Asin, J., Cebrian, A.C. and Centelles, A.
(2007). Modeling and forecasting extreme heat events in the central
Ebro valley, a continental-Mediterranean area. <em>Global and
Planetary Change</em>, 57(1-2), 43-58.
</p>
<p>Baddeley, A., Turner, R., Moller, J. and Hazelton, M. (2005).
Residual analysis for spatial point processes.
<em>Journal of the Royal Statistical Society</em>, Series B 67,617-666.
</p>
<p>Brillinger, D. (1994). Time series, point processes and hybrids. <em>Can. J. Statist.</em>,
22, 177-206.
</p>
<p>Cebrian, A.C., Abaurrea, J. and Asin, J. (2015). NHPoisson: An R Package for 
Fitting and Validating Nonhomogeneous Poisson Processes. 
<em>Journal of Statistical Software</em>, 64(6), 1-24.
</p>
<p>Lewis, P. (1972). Recent  results in the statistical analysis of univariate point
processes. In <em>Stochastic point processes</em> (Ed. P. Lewis), 1-54. Wiley.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+unifres.fun">unifres.fun</a></code>, <code><a href="#topic+graphres.fun">graphres.fun</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
X1&lt;-rnorm(1000)
X2&lt;-rnorm(1000)

modE&lt;-fitPP.fun(tind=TRUE,covariates=cbind(X1,X2), 
	posE=round(runif(40,1,1000)), inddat=rep(1,1000),
	tim=c(1:1000), tit="Simulated example",start=list(b0=1,b1=0,b2=0),
	dplot=FALSE,modCI=FALSE,modSim=TRUE)


#Residuals, based on overlapping intervals of length 50, from the fitted NHPP modE  

ResE&lt;-CalcRes.fun(mlePP=modE, lint=50)


</code></pre>

<hr>
<h2 id='CalcResD.fun'>Calculate NHPP residuals on disjoint intervals</h2><span id='topic+CalcResD.fun'></span>

<h3>Description</h3>

<p>This function calculates raw and scaled  residuals of a NHPP based on 
disjoint intervals. The scaled residuals can be Pearson or any other type of scaled residuals
defined by the function <code class="reqn">h(t)</code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>CalcResD.fun(mlePP, h = NULL, nint = NULL, lint = NULL, typeRes = NULL,
 modSim = "FALSE")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CalcResD.fun_+3A_mlepp">mlePP</code></td>
<td>
<p>An object of class <code><a href="#topic+mlePP-class">mlePP-class</a></code>; usually,
the output  from <code><a href="#topic+fitPP.fun">fitPP.fun</a></code>.</p>
</td></tr>
<tr><td><code id="CalcResD.fun_+3A_lint">lint</code></td>
<td>
<p>Optional. Length of the  intervals to calculate 
the residuals.</p>
</td></tr>
<tr><td><code id="CalcResD.fun_+3A_h">h</code></td>
<td>
<p>Optional. Weight function to calculate the scaled residuals. By default,  
Pearson residuals with <code class="reqn">h(t)=1/\sqrt{\hat \lambda(t)}</code> are calculated.</p>
</td></tr>
<tr><td><code id="CalcResD.fun_+3A_typeres">typeRes</code></td>
<td>
<p>Optional. Label indicating the type of scaled residuals. By default,  
Pearson residuals  are calculated and label is 'Pearson'.</p>
</td></tr>
<tr><td><code id="CalcResD.fun_+3A_modsim">modSim</code></td>
<td>
<p>Logical flag. If it is FALSE, some 
information on the intervals is shown on the screen.</p>
</td></tr>
<tr><td><code id="CalcResD.fun_+3A_nint">nint</code></td>
<td>
<p>Number of intervals used to calculate the residuals. Intervals with 
the same length are considered. Only one of 
lint or nint must be specified.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The  intervals used to calculate the residuals can be specified either
by  nint or lint; only one of the arguments must be provided. If nint is specified,
intervals of equal length are calculated.
</p>
<p>The raw residuals are  based on the increments of 
the raw process <code class="reqn">R(t)=N_t-\int_0^t\hat\lambda(u)du</code> 
in   disjoint intervals  <code class="reqn">(l_1, l_2)</code> centered on t:
</p>
<p style="text-align: center;"><code class="reqn">r'(l_1, l_2)=R(l_2)-R(l_1)=\sum_{t_i \in (l_1,l_2)}I_{t_i}-\int_{l_1}^{l_2} \hat \lambda(u)du.</code>
</p>

<p>Residuals <code class="reqn">r'(l_1, l_2)</code> are made 'instantaneous' dividing by the
length of the intervals (specified by the argument lint),
<code class="reqn">r(l_1, l_2)=r'(l_1,l_2)/(l_2-l_1)</code>.
</p>
<p>The function also calculates  the residuals scaled  with  the function <code class="reqn">h(t)</code>
</p>
<p style="text-align: center;"><code class="reqn">r_{sca}(l_1, l_2)=\sum_{t_i \in (l_1,l_2)}h_{t_i}-\int_{l_1}^{l_2} h(u) \hat \lambda(u)du.</code>
</p>

<p>By default,  Pearson residuals with <code class="reqn">h(t)=1/\sqrt{\hat \lambda(t)}</code> are calculated.</p>


<h3>Value</h3>

<p>A list with elements
</p>
<table>
<tr><td><code>RawRes</code></td>
<td>
<p>Numeric vector of the raw residuals.</p>
</td></tr>
<tr><td><code>ScaRes</code></td>
<td>
<p>A list with elements ScaRes (vector of the scaled residuals) 
and typeRes (name of the type of scaled residuals).</p>
</td></tr>
<tr><td><code>emplambda</code></td>
<td>
<p>Numeric vector of the empirical estimator of the PP intensity   on the 
considered intervals.</p>
</td></tr>
<tr><td><code>fittedlambda</code></td>
<td>
<p>Numeric vector of the   sum  of the intensities 
<code class="reqn">\hat \lambda(t)</code>  on the considered intervals, divided by the length of the interval.</p>
</td></tr>
<tr><td><code>lintV</code></td>
<td>
<p>Numeric vector of the  exact length of each interval. 
The exact length is defined as the number of observations  in each interval used in the 
estimation (observations with inddat=1).</p>
</td></tr>
<tr><td><code>lint</code></td>
<td>
<p>Input argument.</p>
</td></tr>
<tr><td><code>nint</code></td>
<td>
<p>Input argument.</p>
</td></tr>
<tr><td><code>pm</code></td>
<td>
<p>Numeric vector of the mean point of the intervals.</p>
</td></tr>
<tr><td><code>typeI</code></td>
<td>
<p>Label indicating  the type  of intervals
used to calculate the residuals, 'Disjoint' .</p>
</td></tr>
<tr><td><code>h</code></td>
<td>
<p>Input argument.</p>
</td></tr>
<tr><td><code>mlePP</code></td>
<td>
<p>Input argument.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Abaurrea, J., Asin, J., Cebrian, A.C. and Centelles, A.
(2007). Modeling and forecasting extreme heat events in the central
Ebro valley, a continental-Mediterranean area. <em>Global and
Planetary Change</em>, 57(1-2), 43-58.
</p>
<p>Baddeley, A., Turner, R., Moller, J. and Hazelton, M. (2005).
Residual analysis for spatial point processes.
<em>Journal of the Royal Statistical Society</em>, Series B 67,617-666.
</p>
<p>Brillinger, D. (1994). Time series, point processes and hybrids. <em>Can. J. Statist.</em>,
22, 177-206.
</p>
<p>Cebrian, A.C., Abaurrea, J. and Asin, J. (2015). NHPoisson: An R Package for 
Fitting and Validating Nonhomogeneous Poisson Processes. 
<em>Journal of Statistical Software</em>, 64(6), 1-24.
</p>
<p>Lewis, P. (1972). Recent  results in the statistical analysis of univariate point
processes. In <em>Stochastic point processes</em> (Ed. P. Lewis), 1-54. Wiley.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+CalcRes.fun">CalcRes.fun</a></code>,  <code><a href="#topic+unifres.fun">unifres.fun</a></code>, 
<code><a href="#topic+graphres.fun">graphres.fun</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
X1&lt;-rnorm(1000)
X2&lt;-rnorm(1000)


modE&lt;-fitPP.fun(tind=TRUE,covariates=cbind(X1,X2), 
	posE=round(runif(40,1,1000)), inddat=rep(1,1000),
	tim=c(1:1000), tit="Simulated example",start=list(b0=1,b1=0,b2=0),
	dplot=FALSE,modCI=FALSE,modSim=TRUE)

#Residuals, based on 20 disjoint intervals of length 50, from the fitted NHPP modE  

ResDE&lt;-CalcResD.fun(mlePP=modE,lint=50)



</code></pre>

<hr>
<h2 id='CIdelta.fun'>Confidence intervals  for   <code class="reqn">\lambda(t)</code> using delta method</h2><span id='topic+CIdelta.fun'></span>

<h3>Description</h3>

<p>Given the  <code class="reqn">\hat \beta</code> covariance matrix (or its estimation),  an approximate
confidence interval for
each <code class="reqn">\lambda(t)</code> is calculated using  the  delta
method. </p>


<h3>Usage</h3>

<pre><code class='language-R'>CIdelta.fun(VARbeta, lambdafit, covariates, clevel = 0.95)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CIdelta.fun_+3A_varbeta">VARbeta</code></td>
<td>
<p>(Estimated) Covariance matrix of the <code class="reqn">\hat \beta</code>  parameter vector.</p>
</td></tr>
<tr><td><code id="CIdelta.fun_+3A_lambdafit">lambdafit</code></td>
<td>
<p>Numeric vector of fitted values of the PP intensity  
<code class="reqn">\hat \lambda(t)</code>.</p>
</td></tr>
<tr><td><code id="CIdelta.fun_+3A_covariates">covariates</code></td>
<td>
<p>Matrix of covariates to estimate the  PP intensity.</p>
</td></tr>
<tr><td><code id="CIdelta.fun_+3A_clevel">clevel</code></td>
<td>
<p>Confidence level of  the confidence intervals. A value in  the interval 
(0,1).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with  elements
</p>
<table>
<tr><td><code>LIlambda</code></td>
<td>
<p>Numeric vector of the lower values of the intervals.</p>
</td></tr>
<tr><td><code>UIlambda</code></td>
<td>
<p>Numeric vector of the upper values of the intervals.</p>
</td></tr>
<tr><td><code>lambdafit</code></td>
<td>
<p>Input argument.</p>
</td></tr>
</table>


<h3>Note</h3>

<p><code>fitPP.fun</code> calls <code>CIdelta.fun</code> when the argument is <em>CIty='Delta'</em>.</p>


<h3>References</h3>

<p>Casella, G. and Berger, R.L., (2002). <em>Statistical inference.</em> Brooks/Cole.
</p>
<p>Cebrian, A.C., Abaurrea, J. and Asin, J. (2015). NHPoisson: An R Package for 
Fitting and Validating Nonhomogeneous Poisson Processes. 
<em>Journal of Statistical Software</em>, 64(6), 1-24.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+CItran.fun">CItran.fun</a></code>, <code><a href="#topic+fitPP.fun">fitPP.fun</a></code>, <code><a href="#topic+VARbeta.fun">VARbeta.fun</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>aux&lt;-CIdelta.fun(VARbeta=0.01, lambdafit=exp(rnorm(100)), covariates=matrix(rep(1,100)),
	 clevel=0.95)

</code></pre>

<hr>
<h2 id='CItran.fun'>Confidence intervals for  <code class="reqn">\lambda(t)</code> based on transformation </h2><span id='topic+CItran.fun'></span>

<h3>Description</h3>

<p>Given the  <code class="reqn">\hat \beta</code> covariance matrix (or its estimation),  an approximate
confidence interval for each <code class="reqn">\lambda(t)=\exp(\nu(t))</code> is calculated using a transformation of 
the confidence interval for the linear
predictor <code class="reqn">\nu(t)=\textbf{X(t)} \beta</code>. The transformation is <code class="reqn">\exp(I_i)</code>, 
where <code class="reqn">I_i</code> are the confidence limits of <code class="reqn">\nu(t)</code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>CItran.fun(VARbeta, lambdafit, covariates, clevel = 0.95)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CItran.fun_+3A_varbeta">VARbeta</code></td>
<td>
<p>(Estimated) Coariance matrix of the <code class="reqn">\hat \beta</code>  parameter vector.</p>
</td></tr>
<tr><td><code id="CItran.fun_+3A_lambdafit">lambdafit</code></td>
<td>
<p>Numeric vector of fitted values of the PP intensity  
<code class="reqn">\hat \lambda(t)</code>.</p>
</td></tr>
<tr><td><code id="CItran.fun_+3A_covariates">covariates</code></td>
<td>
<p>Matrix of covariates to estimate the  PP intensity.</p>
</td></tr>
<tr><td><code id="CItran.fun_+3A_clevel">clevel</code></td>
<td>
<p>Confidence level of  the confidence intervals. A value in  the interval 
(0,1).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with  elements
</p>
<table>
<tr><td><code>LIlambda</code></td>
<td>
<p>Numeric vector of the lower values of the intervals.</p>
</td></tr>
<tr><td><code>UIlambda</code></td>
<td>
<p>Numeric vector of the upper values of the intervals.</p>
</td></tr>
<tr><td><code>lambdafit</code></td>
<td>
<p>Input argument.</p>
</td></tr>
</table>


<h3>Note</h3>

<p><code>fitPP.fun</code> calls <code>CItran.fun</code>  when  the argument is <em>CIty='Transf'</em>.</p>


<h3>References</h3>

<p>Casella, G. and Berger, R.L., (2002). <em>Statistical inference.</em> Brooks/Cole.
</p>
<p>Cebrian, A.C., Abaurrea, J. and Asin, J. (2015). NHPoisson: An R Package for 
Fitting and Validating Nonhomogeneous Poisson Processes. 
<em>Journal of Statistical Software</em>, 64(6), 1-24.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+CIdelta.fun">CIdelta.fun</a></code>, <code><a href="#topic+fitPP.fun">fitPP.fun</a></code>, <code><a href="#topic+VARbeta.fun">VARbeta.fun</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>aux&lt;-CItran.fun(VARbeta=0.01, lambdafit=exp(rnorm(100)), covariates=matrix(rep(1,100)),
	 clevel=0.95)
</code></pre>

<hr>
<h2 id='confintAsin.fun'>Compute confidence intervals for  the  <code class="reqn">\beta</code> parameters</h2><span id='topic+confintAsin.fun'></span>

<h3>Description</h3>

<p> This function computes confidence intervals for  the  <code class="reqn">\beta</code> parameters.</p>


<h3>Usage</h3>

<pre><code class='language-R'>confintAsin.fun(mlePP, level = 0.95)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="confintAsin.fun_+3A_mlepp">mlePP</code></td>
<td>
<p>A <code>"<a href="#topic+mlePP-class">mlePP</a>"</code>-class object; usually the output from <code><a href="#topic+fitPP.fun">fitPP.fun</a></code>.</p>
</td></tr>
<tr><td><code id="confintAsin.fun_+3A_level">level</code></td>
<td>
<p>The confidence level required for the intervals.</p>
</td></tr>
</table>


<h3>Details</h3>

<p> The confidence intervals  calculated by this function are based on the asymptotic normal 
approximation of th MLE of the <code class="reqn">\beta</code> parameters, that is
<code class="reqn">( \hat \beta -z_{(1-\alpha/2)}s.e.(\hat \beta ),  \hat \beta +z_{(1-\alpha/2)} s.e.(\hat \beta ) )</code>
with <code class="reqn">\alpha=1-level</code>
</p>


<h3>Value</h3>

<p>A matrix with two columns, the first contains the lower limits of the confidence intervals 
of all the parameters and the second the upper limits.</p>


<h3>References</h3>

<p>Casella, G. and Berger, R.L., (2002). <em>Statistical inference.</em> Brooks/Cole.
</p>
<p>Cebrian, A.C., Abaurrea, J. and Asin, J. (2015). NHPoisson: An R Package for 
Fitting and Validating Nonhomogeneous Poisson Processes. 
<em>Journal of Statistical Software</em>, 64(6), 1-24.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+confint">confint</a></code>, <code><a href="#topic+VARbeta.fun">VARbeta.fun</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(BarTxTn)

covB&lt;-cbind(cos(2*pi*BarTxTn$dia/365), sin(2*pi*BarTxTn$dia/365), 
	BarTxTn$TTx,BarTxTn$Txm31,BarTxTn$Txm31**2)

BarEv&lt;-POTevents.fun(T=BarTxTn$Tx,thres=318, 
	date=cbind(BarTxTn$ano,BarTxTn$mes,BarTxTn$dia))

mod1B&lt;-fitPP.fun(covariates=covB, 
	posE=BarEv$Px, inddat=BarEv$inddat,
	tit="BAR Tx; cos, sin, TTx, Txm31, Txm31**2", 
	start=list(b0=-100,b1=1,b2=-1,b3=0,b4=0,b5=0))

confintAsin.fun(mod1B)

</code></pre>

<hr>
<h2 id='dropAIC.fun'>Calculate the AIC for all one-covariate deletions from the  current model</h2><span id='topic+dropAIC.fun'></span>

<h3>Description</h3>

<p> This function fits all models  obtained from the current model by deleting one covariate 
(except the intercept),  and calculates their AIC value. 
It selects the best covariate to be deleted, according to the AIC value.</p>


<h3>Usage</h3>

<pre><code class='language-R'>dropAIC.fun(mlePP, modSim = FALSE,...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dropAIC.fun_+3A_mlepp">mlePP</code></td>
<td>
<p>A <code>"<a href="#topic+mlePP-class">mlePP</a>"</code>-class object; usually the output from <code><a href="#topic+fitPP.fun">fitPP.fun</a></code>. 
It defines the current model.  The fitted model cannot include fixed parameters.</p>
</td></tr>
<tr><td><code id="dropAIC.fun_+3A_modsim">modSim</code></td>
<td>
<p>Logical flag. If it is FALSE, information about the process is shown on the screen.
For automatic selection processes, the option TRUE should be preferred.</p>
</td></tr>
<tr><td><code id="dropAIC.fun_+3A_...">...</code></td>
<td>
<p>Further arguments to pass to <code><a href="stats.html#topic+AIC">AIC</a></code>, for example the constant k for the AIC calculation.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The definition of AIC uses constant k=2, but  a different value  k can be passed as
an additional argument. The best covariate to be deleted  is the one  whose deletion leads to  the model with the lowest AIC value
and it  improves the current model if the new AIC  is lower than the current one. </p>


<h3>Value</h3>

<p> A list with the following components
</p>
<table>
<tr><td><code>AICadd</code></td>
<td>
<p>Vector of the AIC values obtained from deleting each covariate  of the current model.</p>
</td></tr>
<tr><td><code>posminAIC</code></td>
<td>
<p>An integer indicating the number of the column  of the covariates matrix with the covariate leading to the minimum AIC.</p>
</td></tr>
<tr><td><code>namecov</code></td>
<td>
<p>Name of the covariate leading to the minimum AIC.</p>
</td></tr>
<tr><td><code>AICcurrent</code></td>
<td>
<p>AIC value of the current (initial) model.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Casella, G. and Berger, R.L., (2002). <em>Statistical inference.</em> Brooks/Cole.
</p>
<p>Cebrian, A.C., Abaurrea, J. and Asin, J. (2015). NHPoisson: An R Package for 
Fitting and Validating Nonhomogeneous Poisson Processes. 
<em>Journal of Statistical Software</em>, 64(6), 1-24.
</p>
<p>Venables, W. N. and Ripley, B. D. (2002). <em>Modern Applied Statistics with S.</em> Fourth edition. Springer.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+addAIC.fun">addAIC.fun</a></code>, <code><a href="#topic+stepAICmle.fun">stepAICmle.fun</a></code>, <code><a href="#topic+LRTpv.fun">LRTpv.fun</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(BarTxTn)

BarEv&lt;-POTevents.fun(T=BarTxTn$Tx,thres=318, 
	date=cbind(BarTxTn$ano,BarTxTn$mes,BarTxTn$dia))

covB&lt;-cbind(cos(2*pi*BarTxTn$dia/365), sin(2*pi*BarTxTn$dia/365), 
	BarTxTn$TTx,BarTxTn$Txm31,BarTxTn$Txm31**2)

dimnames(covB)&lt;-list(NULL,c('cos','sin','TTx','Txm31', 'Txm31**2'))

mod1B&lt;-fitPP.fun(covariates=covB, posE=BarEv$Px, inddat=BarEv$inddat,
	tit="BAR Tx; cos, sin, TTx, Txm31, Txm31**2", 
	start=list(b0=-100,b1=1,b2=10,b3=0,b4=0,b5=0))


aux&lt;-dropAIC.fun(mod1B)
</code></pre>

<hr>
<h2 id='emplambda.fun'>Empirical occurrence rates of a NHPP on overlapping intervals</h2><span id='topic+emplambda.fun'></span>

<h3>Description</h3>

<p>This function calculates the empirical  occurrence  rates
of a point process on overlapping intervals.  The empirical rate centered in each
time of the observation period is calculated using intervals of a given length. A plot of the empirical 
rate over time can be performed optionally. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>emplambda.fun(posE, t, lint, plotEmp = TRUE, inddat = NULL, tit ="", 
scax = NULL, scay = NULL)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="emplambda.fun_+3A_pose">posE</code></td>
<td>
<p>Numeric vector of the  position of the occurrence points of 
the NHPP (or any point process in time).</p>
</td></tr>
<tr><td><code id="emplambda.fun_+3A_t">t</code></td>
<td>
<p>Time index of the observation period. The simplest option is  1,...,n with 
n the length of the period.</p>
</td></tr>
<tr><td><code id="emplambda.fun_+3A_lint">lint</code></td>
<td>
<p>Length of the intervals used to calculate the rates.</p>
</td></tr>
<tr><td><code id="emplambda.fun_+3A_plotemp">plotEmp</code></td>
<td>
<p>Logical flag. If it is TRUE, a plot of the empirical rate 
is carried out.</p>
</td></tr>
<tr><td><code id="emplambda.fun_+3A_inddat">inddat</code></td>
<td>
<p>Optional. Index vector equal to 1 for the observations used in the estimation process
By default, all the observations are considered, see <code><a href="#topic+POTevents.fun">POTevents.fun</a></code>.</p>
</td></tr>
<tr><td><code id="emplambda.fun_+3A_tit">tit</code></td>
<td>
<p>Character string. A  title  for the plot.</p>
</td></tr>
<tr><td><code id="emplambda.fun_+3A_scax">scax</code></td>
<td>
<p>Optional.  A two element vector indicating the x-scale for the plot.</p>
</td></tr>
<tr><td><code id="emplambda.fun_+3A_scay">scay</code></td>
<td>
<p>Optional.  A two element vector indicating the y-scale for the plot.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with elements
</p>
<table>
<tr><td><code>emplambda</code></td>
<td>
<p>Vector of the empirical rates.</p>
</td></tr>
<tr><td><code>lint</code></td>
<td>
<p>Input argument.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+emplambdaD.fun">emplambdaD.fun</a></code>, <code><a href="#topic+fitPP.fun">fitPP.fun</a></code>, <code><a href="#topic+POTevents.fun">POTevents.fun</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(BarTxTn)

BarEv&lt;-POTevents.fun(T=BarTxTn$Tx,thres=318, 
	date=cbind(BarTxTn$ano,BarTxTn$mes,BarTxTn$dia))

# empirical rate based on overlapping intervals
emplambdaB&lt;-emplambda.fun(posE=BarEv$Px,inddat=BarEv$inddat, t=c(1:8415), 
	lint=153,  tit="Barcelona")


</code></pre>

<hr>
<h2 id='emplambdaD.fun'>Empirical occurrence rates of a NHPP on disjoint intervals</h2><span id='topic+emplambdaD.fun'></span>

<h3>Description</h3>

<p>This function calculates the empirical  occurrence  rates
of a point process using  disjoint intervals.  The rate is
assigned to the mean point of the  interval. A plot of the empirical 
rate over time can be performed optionally. </p>


<h3>Usage</h3>

<pre><code class='language-R'>emplambdaD.fun(posE, t, lint=NULL, nint = NULL, plotEmp = TRUE, inddat = NULL, 
tit = "", scax = NULL, scay = NULL)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="emplambdaD.fun_+3A_pose">posE</code></td>
<td>
<p>Numeric vector of the  position of the occurrence points of 
the NHPP (or any point process in time).</p>
</td></tr>
<tr><td><code id="emplambdaD.fun_+3A_t">t</code></td>
<td>
<p>Time index of the observation period. The simplest option is  1,...,n with 
n the length of the period.</p>
</td></tr>
<tr><td><code id="emplambdaD.fun_+3A_lint">lint</code></td>
<td>
<p>Optional (alternative argument to nint). Length of the intervals used to calculate 
the rates.</p>
</td></tr>
<tr><td><code id="emplambdaD.fun_+3A_nint">nint</code></td>
<td>
<p>Optional (alternative argument to lint). Number of intervals 
(of equal length) used to to calculate the rates.
It is an alternative way  to lint for identifying the	intervals. </p>
</td></tr>
<tr><td><code id="emplambdaD.fun_+3A_plotemp">plotEmp</code></td>
<td>
<p>Logical flag. If it is TRUE, a plot of the empirical rate 
is carried out.</p>
</td></tr>
<tr><td><code id="emplambdaD.fun_+3A_inddat">inddat</code></td>
<td>
<p>Optional. Index vector equal to 1 for the observations used in the 
estimation process. By default, all the observations are considered, 
see <code><a href="#topic+POTevents.fun">POTevents.fun</a></code>.</p>
</td></tr>
<tr><td><code id="emplambdaD.fun_+3A_tit">tit</code></td>
<td>
<p>Character string. A  title  for the plot.</p>
</td></tr>
<tr><td><code id="emplambdaD.fun_+3A_scax">scax</code></td>
<td>
<p>Optional.  A two element vector indicating the x-scale for the plot.</p>
</td></tr>
<tr><td><code id="emplambdaD.fun_+3A_scay">scay</code></td>
<td>
<p>Optional.  A two element vector indicating the y-scale for the plot.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The  intervals  can be specified either
by  nint or lint; only one of the arguments must be provided.</p>


<h3>Value</h3>

<p>A list with elements
</p>
<table>
<tr><td><code>emplambda</code></td>
<td>
<p>Vector of the empirical rates.</p>
</td></tr>
<tr><td><code>lint</code></td>
<td>
<p>Input argument.</p>
</td></tr>
<tr><td><code>nint</code></td>
<td>
<p>Input  argument.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+emplambda.fun">emplambda.fun</a></code>, <code><a href="#topic+fitPP.fun">fitPP.fun</a></code>, 
<code><a href="#topic+POTevents.fun">POTevents.fun</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(BarTxTn)

BarEv&lt;-POTevents.fun(T=BarTxTn$Tx,thres=318, 
	date=cbind(BarTxTn$ano,BarTxTn$mes,BarTxTn$dia))


# empirical rate based on disjoint intervals using nint to specify the intervals
emplambdaDB&lt;-emplambdaD.fun(posE=BarEv$Px,inddat=BarEv$inddat, t=c(1:8415), 
	nint=55)

# empirical rate based on disjoint intervals using lint to specify the intervals
emplambdaDB&lt;-emplambdaD.fun(posE=BarEv$Px,inddat=BarEv$inddat, t=c(1:8415), 
	lint=153)
</code></pre>

<hr>
<h2 id='extractAIC-methods'> Method  <code>mle</code> for Function <code>extractAIC</code></h2><span id='topic+extractAIC-methods'></span><span id='topic+extractAIC+2CANY-method'></span><span id='topic+extractAIC+2Cmle-method'></span>

<h3>Description</h3>

<p>Method for  generic function <code><a href="stats.html#topic+extractAIC">extractAIC</a></code> for  objects of the S4-class <code><a href="stats4.html#topic+mle-class">mle</a></code> or 
<code><a href="#topic+mlePP-class">mlePP</a></code>.  It   is the same method as in 
<span class="pkg">stats4</span> (that method is not available outside that package).</p>


<h3>Methods</h3>


<dl>
<dt><code>signature(fit = "ANY")</code></dt><dd></dd>
<dt><code>signature(fit = "mle")</code></dt><dd></dd>
</dl>

<hr>
<h2 id='fitPP.fun'>Fit  a non homogeneous Poisson Process</h2><span id='topic+fitPP.fun'></span>

<h3>Description</h3>

<p>This function fits by maximum likelihood a NHPP where the  intensity <code class="reqn">\lambda(t)</code>  
is formulated  as a function of covariates.  It also calculates and plots 
approximate confidence intervals for <code class="reqn">\lambda(t)</code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>fitPP.fun(covariates = NULL, start, fixed=list(), posE = NULL, inddat = NULL, 
POTob = NULL,  nobs = NULL, tind = TRUE, tim = NULL, minfun="nlminb",
 modCI = "TRUE", CIty = "Transf", clevel = 0.95,
 tit = "", modSim = "FALSE", dplot = TRUE, xlegend = "topleft",
lambdaxlim=NULL,lambdaylim=NULL,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitPP.fun_+3A_covariates">covariates</code></td>
<td>
<p>Matrix of the covariates to be included in the 
linear predictor of the PP intensity (each column is a covariate). It is advisable to give 
names to the columns of this matrix
(using <code><a href="base.html#topic+dimnames">dimnames</a></code>), since they  will be used in the output.  
Otherwise the default names 'Covariate i' are used.
The offset covariates must be included in this matrix.  A maximum of 50 covariates are allowed.</p>
</td></tr>
<tr><td><code id="fitPP.fun_+3A_start">start</code></td>
<td>
<p>Named list of the initial values  for the estimation of 
the <code class="reqn">\beta</code> parameters (including fixed parameters).
The names of the list  must be (compulsory): b0 (for the intercept), b1 (for the first column in <code>covariates</code>), b2 (for the second column), 
b3 (for the third column), etc.</p>
</td></tr>
<tr><td><code id="fitPP.fun_+3A_fixed">fixed</code></td>
<td>
<p>Named list of the fixed <code class="reqn">\beta</code> parameters. The elements of this list  must be elements 
of the list <code>start</code>. </p>
</td></tr>
<tr><td><code id="fitPP.fun_+3A_pose">posE</code></td>
<td>
<p>Optional (see Details section). Numeric vector of the position of the PP occurrence points.</p>
</td></tr>
<tr><td><code id="fitPP.fun_+3A_inddat">inddat</code></td>
<td>
<p>Optional (see Details section). Index vector equal to 1 for the observations  used in the estimation process
By default, all the observations are considered.</p>
</td></tr>
<tr><td><code id="fitPP.fun_+3A_potob">POTob</code></td>
<td>
<p>Optional (see Details section). List with  elements T and thres 
that defines the PP resulting from a POT approach; 
see <code><a href="#topic+POTevents.fun">POTevents.fun</a></code> for more details.</p>
</td></tr>
<tr><td><code id="fitPP.fun_+3A_nobs">nobs</code></td>
<td>
<p>Optional. Number of observations  in the observation period; 
it is only neccessary if POTob, inddat and covariates are NULL.</p>
</td></tr>
<tr><td><code id="fitPP.fun_+3A_tind">tind</code></td>
<td>
<p>Logical flag. If it is TRUE, an independent term is fitted in the 
linear predictor. It cannot be a character string, so TRUE and not'TRUE' should be used.</p>
</td></tr>
<tr><td><code id="fitPP.fun_+3A_tim">tim</code></td>
<td>
<p>Optional. Time vector  of  the observation period.
By default, a vector 1,...n is considered.</p>
</td></tr>
<tr><td><code id="fitPP.fun_+3A_minfun">minfun</code></td>
<td>
<p>Label indicating  the function to minimize the negative of the loglikelihood function.
There are two possible values: &quot;nlminb&quot;  (the default option) and  &quot;optim&quot;. In the last case, 
the method of optimization can be chosen with an additional method argument.</p>
</td></tr>
<tr><td><code id="fitPP.fun_+3A_modci">modCI</code></td>
<td>
<p>Logical flag. If it is TRUE, confidence intervals  
for <code class="reqn">\lambda(t)</code> values are calculated.</p>
</td></tr>
<tr><td><code id="fitPP.fun_+3A_city">CIty</code></td>
<td>
<p>Label indicating  the method to calculate the approximate
confidence intervals  for <code class="reqn">\lambda(t)</code>. It can be &quot;Transf&quot; for transformed asymptotic intervals (default) or 
&quot;Delta&quot; for the delta method; see <code><a href="#topic+CItran.fun">CItran.fun</a></code>  and <code><a href="#topic+CIdelta.fun">CIdelta.fun</a></code> for details.</p>
</td></tr>
<tr><td><code id="fitPP.fun_+3A_clevel">clevel</code></td>
<td>
<p>Confidence level of the  confidence intervals.</p>
</td></tr>
<tr><td><code id="fitPP.fun_+3A_tit">tit</code></td>
<td>
<p>Character string. A title for the plot.</p>
</td></tr>
<tr><td><code id="fitPP.fun_+3A_modsim">modSim</code></td>
<td>
<p>Logical flag. If it is FALSE, information on the  
estimation process is shown on the screen.
For simulation process, the option TRUE should be preferred.</p>
</td></tr>
<tr><td><code id="fitPP.fun_+3A_dplot">dplot</code></td>
<td>
<p>Logical flag. If it is TRUE,  the fitted intensity is plotted.</p>
</td></tr>
<tr><td><code id="fitPP.fun_+3A_xlegend">xlegend</code></td>
<td>
<p>Label indicating the position where the legend on 
the graph will be located. </p>
</td></tr>
<tr><td><code id="fitPP.fun_+3A_lambdaxlim">lambdaxlim</code></td>
<td>
<p>Optional. Numeric vector of length 2, giving the  lowest and highest values which determine the x  range.</p>
</td></tr>
<tr><td><code id="fitPP.fun_+3A_lambdaylim">lambdaylim</code></td>
<td>
<p>Optional. Numeric vector of length 2, giving the  lowest and highest values which determine the y  range.</p>
</td></tr>
<tr><td><code id="fitPP.fun_+3A_...">...</code></td>
<td>
<p>Further arguments to pass to <code><a href="stats.html#topic+optim">optim</a></code> or to <code><a href="stats.html#topic+nlminb">nlminb</a></code> (depending on the value of  the 
<code>minfun</code> argument).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A Poisson process (PP)  is usually specified by a vector containing the  occurrence 
points of the process <code class="reqn">(t_i)_{i=1}^k</code>,  (argument posE). 
Since PP are often used in the framework of POT models, <code><a href="#topic+fitPP.fun">fitPP.fun</a></code> also 
provides the possibility of 
using as input the  series of the observed values  in a POT model 
<code class="reqn">(x_i)_{i=1}^n</code> and the threshold used to define the  extreme events 
(argument POTob). 
</p>
<p>In the case of PP defined by a POT approach, 
the observations of the extreme events which are 
not defined as the occurrence point are not considered in the estimation. This is done
through the argument inddat, see <code><a href="#topic+POTevents.fun">POTevents.fun</a></code>. If  the input is provided via argument POTob, index inddat
is calculated automatically. See <cite>Coles (2001)</cite> for more details on the POT approach.
</p>
<p>The maximization of the loglikelihood function can be done using  two different optimization  routines, 
<code><a href="stats.html#topic+optim">optim</a></code> or <code><a href="stats.html#topic+nlminb">nlminb</a></code>, selected in the argument <code>minfun</code>. Depending on 
the covariates included in the function, one routine can  succeed to converge when the other fails.
</p>
<p>This function allows  us to  keep fixed some <code class="reqn">\beta</code> parameters  (offset terms).  This can be 
used to specify an a priori known component to be included in the linear predictor during fitting. The fixed parameters
must be specified in the <code>fixed</code>  argument (and also   in <code>start</code>); 
the fixed covariates must be included as columns of <code>covariates</code>.
</p>
<p>The estimation of the <code class="reqn">\hat \beta</code> covariance matrix is based on the 
asymptotic distribution of the MLE <code class="reqn">\hat \beta</code>, and calculated as the inverse of the negative of the  hessian matrix.
Confidence intervals for <code class="reqn">\lambda(t)</code> can be calculated using  two approaches
specified in the argument <code>CIty</code>. See <cite>Casella (2002)</cite> for more details on ML theory and delta method.</p>


<h3>Value</h3>

<p>An object of class  <code><a href="#topic+mlePP-class">mlePP</a></code>, which is a subclass of <code><a href="stats4.html#topic+mle-class">mle</a></code>. 
Consequently, many of the generic functions with <code>mle</code> methods, such as 
<code><a href="stats.html#topic+logLik">logLik</a></code> or <code><a href="base.html#topic+summary">summary</a></code>, can be applied to the output of this function.  Some other generic 
functions related to fitted models, such as <code>AIC</code> or <code>BIC</code>, can  also  be applied to <code>mlePP</code> objects. 
</p>


<h3>Note</h3>

<p>A homogeneous Poisson process (HPP) can be fitted as a particular case,  
using  an intensity defined by  only an intercept  and no covariate.</p>


<h3>References</h3>

<p>Cebrian, A.C., Abaurrea, J. and Asin, J. (2015). NHPoisson: An R Package for 
Fitting and Validating Nonhomogeneous Poisson Processes. 
<em>Journal of Statistical Software</em>, 64(6), 1-24.
</p>
<p>Coles, S. (2001). <em>An introduction to statistical modelling of extreme
values.</em> Springer.
</p>
<p>Casella, G. and Berger, R.L., (2002). <em>Statistical inference.</em> Brooks/Cole.
</p>
<p>Kutoyants Y.A. (1998).<em>Statistical inference for spatial Poisson processes.</em> 
Lecture notes in Statistics 134. Springer.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+POTevents.fun">POTevents.fun</a></code>, <code><a href="#topic+globalval.fun">globalval.fun</a></code>,
<code><a href="#topic+VARbeta.fun">VARbeta.fun</a></code>, <code><a href="#topic+CItran.fun">CItran.fun</a></code>, <code><a href="#topic+CIdelta.fun">CIdelta.fun</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>#model fitted  using as input posE and inddat and  no confidence intervals 

data(BarTxTn)
covB&lt;-cbind(cos(2*pi*BarTxTn$dia/365), sin(2*pi*BarTxTn$dia/365), 
	BarTxTn$TTx,BarTxTn$Txm31,BarTxTn$Txm31**2)
BarEv&lt;-POTevents.fun(T=BarTxTn$Tx,thres=318, 
	date=cbind(BarTxTn$ano,BarTxTn$mes,BarTxTn$dia))


mod1B&lt;-fitPP.fun(covariates=covB, 
	posE=BarEv$Px, inddat=BarEv$inddat,
	tit="BAR Tx; cos, sin, TTx, Txm31, Txm31**2", 
	start=list(b0=-100,b1=1,b2=-1,b3=0,b4=0,b5=0))

#model fitted  using as input  a list from POTevents.fun and with  confidence intervals 

tiempoB&lt;-BarTxTn$ano+rep(c(0:152)/153,55)

mod2B&lt;-fitPP.fun(covariates=covB, 
	POTob=list(T=BarTxTn$Tx, thres=318),
	tim=tiempoB, tit="BAR Tx; cos, sin, TTx, Txm31, Txm31**2", 
	start=list(b0=-100,b1=1,b2=-1,b3=0,b4=0,b5=0),CIty="Delta",modCI=TRUE,
	modSim=TRUE)

#model  with a fixed parameter (b0)

mod1BF&lt;-fitPP.fun(covariates=covB, 
	posE=BarEv$Px, inddat=BarEv$inddat,
	tit="BAR Tx; cos, sin, TTx, Txm31, Txm31**2", 
	start=list(b0=-89,b1=1,b2=10,b3=0,b4=0,b5=0), 
	fixed=list(b0=-100))
</code></pre>

<hr>
<h2 id='GenEnv.fun'>Calculation of simulated envelopes</h2><span id='topic+GenEnv.fun'></span><span id='topic+funSim.fun'></span><span id='topic+posk.fun'></span>

<h3>Description</h3>

<p>This function calculates a  point estimation and an envelope
for a  given statistic using a Monte Carlo approach. The statistic must be a function 
of the occurrence points of a NHPP.
</p>
<p>It calls the auxiliary function <code>funSim.fun</code> (not intended
for the users), see Details section.</p>


<h3>Usage</h3>

<pre><code class='language-R'>GenEnv.fun(nsim, lambda, fun.name, fun.args = NULL, clevel = 0.95, 
cores = 1, fixed.seed=NULL)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GenEnv.fun_+3A_nsim">nsim</code></td>
<td>
<p>Number of simulations for the calculations.</p>
</td></tr>
<tr><td><code id="GenEnv.fun_+3A_lambda">lambda</code></td>
<td>
<p>Numeric vector of the intensity <code class="reqn">\lambda(t)</code>
(or <code class="reqn">\hat \lambda(t)</code>) of the NHPP.</p>
</td></tr>
<tr><td><code id="GenEnv.fun_+3A_fun.name">fun.name</code></td>
<td>
<p>Name of the function defining the statistic to be estimated.</p>
</td></tr>
<tr><td><code id="GenEnv.fun_+3A_fun.args">fun.args</code></td>
<td>
<p>Additional arguments for the function fun.name.</p>
</td></tr>
<tr><td><code id="GenEnv.fun_+3A_clevel">clevel</code></td>
<td>
<p>Confidence level of the envelope.</p>
</td></tr>
<tr><td><code id="GenEnv.fun_+3A_cores">cores</code></td>
<td>
<p>Optional.  Number of cores of the computer
to be used in the calculations. Default: one core is used.</p>
</td></tr>
<tr><td><code id="GenEnv.fun_+3A_fixed.seed">fixed.seed</code></td>
<td>
<p>An integer or NULL. If it is an integer, that is the value  used to set the seed 
in  random  generation processes. It it is NULL, a random seed is used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The auxiliary function <code>funSim.fun</code> 
generates a  simulated sample  of the occurrence points in a NHPP
and  calculates the corresponding statistic using the simulated points.</p>


<h3>Value</h3>

<p> A list with elements
</p>
<table>
<tr><td><code>valmed</code></td>
<td>
<p>Point estimation (mean value) of the statistic  to be calculated.</p>
</td></tr>
<tr><td><code>valinf</code></td>
<td>
<p>Lower value of the simulated CI.</p>
</td></tr>
<tr><td><code>valsup</code></td>
<td>
<p>Upper value of the simulated CI.</p>
</td></tr>
<tr><td><code>lambda</code></td>
<td>
<p>Input argument.</p>
</td></tr>
<tr><td><code>nsim</code></td>
<td>
<p>Input argument.</p>
</td></tr>
<tr><td><code>nsimval</code></td>
<td>
<p>Number of valid simulations (used in the calculation of the CI and the point estimation).</p>
</td></tr>
<tr><td><code>fixed.seed</code></td>
<td>
<p>Input argument.</p>
</td></tr>	
</table>


<h3>See Also</h3>

 <p><code><a href="#topic+simNHP.fun">simNHP.fun</a></code>, <code><a href="#topic+resQQplot.fun">resQQplot.fun</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'># Calculation of the point estimation and a 95% CI based on 100 simulations 
#for the second occurrence time of a NHPP with intensity lambdat.
#posk.fun(x, k) is a function that returns the value in the row k of vector x.

lambdat&lt;-runif(1000,0.01,0.02)
aux&lt;-GenEnv.fun(lambda=lambdat,fun.name="posk.fun",fun.args=2,nsim=100)

#if we want reproducible results, we can fixed the seed in the generation process
#(the number of cores used in the calculations must also be the same to reproduce 
#the result)

aux&lt;-GenEnv.fun(lambda=lambdat,fun.name="posk.fun",fun.args=2,nsim=100,fixed.seed=123)

#the result (with 1 core): Lower interval:  25.55; Mean value:  136.06; Upper interval:  288

</code></pre>

<hr>
<h2 id='globalval.fun'>Perform a global validation analysis for a NHPP</h2><span id='topic+globalval.fun'></span>

<h3>Description</h3>

<p>This function performs a thorough validation analysis for a fitted NHPP. 
It calculates
the (generalized) uniform  and the raw (or scaled) residuals, performs residual plots
for the uniform  residuals, and time residual and lurking variable plots for the 
raw  or scaled residuals.
It also  plots the fitted and  empirical estimations of the NHPP intensity.
Optionally, it also performs a  residual QQplot.</p>


<h3>Usage</h3>

<pre><code class='language-R'>globalval.fun(mlePP, lint = NULL, nint = NULL, Xvar = NULL, 
namXvar = NULL, Xvart = NULL, namXvart = NULL,  h = NULL, typeRes = NULL,
typeResLV="Pearson",typeI = "Disjoint", nsim = 100, clevel = 0.95, 
resqqplot = FALSE, nintLP = 100, tit = "", flow = 0.5, addlow = FALSE, 
histWgraph=TRUE,plotDisp=c(2,2), indgraph = FALSE, scax = NULL, scay = NULL, 
legcex = 0.5, cores = 1, xlegend = "topleft", fixed.seed=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="globalval.fun_+3A_mlepp">mlePP</code></td>
<td>
<p>An object of class <code><a href="#topic+mlePP-class">mlePP-class</a></code>; usually,
the output  from <code><a href="#topic+fitPP.fun">fitPP.fun</a></code>.</p>
</td></tr>
<tr><td><code id="globalval.fun_+3A_lint">lint</code></td>
<td>
<p>Length of the  intervals  used to calculate the residuals.</p>
</td></tr>
<tr><td><code id="globalval.fun_+3A_nint">nint</code></td>
<td>
<p>Number of intervals  used to calculate the residuals. 
Intervals of equal length are considered.  Only used if typeI=&quot;Disjoint&quot;.
In that case, only one of  the arguments lint or nint must be specified.</p>
</td></tr>
<tr><td><code id="globalval.fun_+3A_xvar">Xvar</code></td>
<td>
<p>Optional. Matrix of the lurking variables (each column is a variable).</p>
</td></tr>
<tr><td><code id="globalval.fun_+3A_namxvar">namXvar</code></td>
<td>
<p>Optional. Vector of names of the variables in Xvar.</p>
</td></tr>
<tr><td><code id="globalval.fun_+3A_xvart">Xvart</code></td>
<td>
<p>Optional. Matrix of the variables for the 
residual plots (each column is a variable). A time  plot is performed in all the cases.</p>
</td></tr>
<tr><td><code id="globalval.fun_+3A_namxvart">namXvart</code></td>
<td>
<p>Optional. Vector of names of the variables in Xvart.</p>
</td></tr>
<tr><td><code id="globalval.fun_+3A_h">h</code></td>
<td>
<p>Optional. Weight function  to calculate the scaled residuals.
By default,  Pearson residuals with </p>
<p style="text-align: center;"><code class="reqn">h(t)=1/\sqrt{\hat \lambda(t)}</code>
</p>
<p> are calculated.
This function is used to calculate both the  scaled residuals and the residuals 
for the lurking variables (except if typeResLV=&quot;Raw&quot;).</p>
</td></tr>
<tr><td><code id="globalval.fun_+3A_typeres">typeRes</code></td>
<td>
<p>Optional. Label indicating the type of scaled residuals. By default,  
Pearson residuals  are calculated and label is &quot;Pearson&quot;.</p>
</td></tr>
<tr><td><code id="globalval.fun_+3A_typereslv">typeResLV</code></td>
<td>
<p>Label indicating the type of residuals (&quot;Raw&quot; or any type of 
scaled residuals such as &quot;Pearson&quot;) to calculate the residuals for the lurking variable
plots.</p>
</td></tr>
<tr><td><code id="globalval.fun_+3A_typei">typeI</code></td>
<td>
<p>Label indicating  the type (&quot;Overlapping&quot; or &quot;Disjoint&quot;) of intervals
used to calculate the residuals.</p>
</td></tr>
<tr><td><code id="globalval.fun_+3A_clevel">clevel</code></td>
<td>
<p>Confidence level of the  residual envelopes.</p>
</td></tr> 
<tr><td><code id="globalval.fun_+3A_resqqplot">resqqplot</code></td>
<td>
<p>Logical  flag. It is is TRUE, a residual qqplot is carried out.</p>
</td></tr>
<tr><td><code id="globalval.fun_+3A_nsim">nsim</code></td>
<td>
<p>Number of simulations  for the  residual qqplot.</p>
</td></tr>
<tr><td><code id="globalval.fun_+3A_nintlp">nintLP</code></td>
<td>
<p>Number of levels considered in the lurking variables. It is used as argument
nint in the call of the function <code><a href="#topic+graphResCov.fun">graphResCov.fun</a></code>.</p>
</td></tr>
<tr><td><code id="globalval.fun_+3A_tit">tit</code></td>
<td>
<p>Character string. A title for the plot.</p>
</td></tr>
<tr><td><code id="globalval.fun_+3A_flow">flow</code></td>
<td>
<p>Argument f for the lowess smoother of the raw (or scaled) residual 
plots, see <code><a href="stats.html#topic+lowess">lowess</a></code>.</p>
</td></tr>
<tr><td><code id="globalval.fun_+3A_addlow">addlow</code></td>
<td>
<p>Logical flag. If it is TRUE, a lowess is added in the residual plots.</p>
</td></tr>
<tr><td><code id="globalval.fun_+3A_histwgraph">histWgraph</code></td>
<td>
<p> Logical flag.   If it is TRUE,  a new graphical device is opened
with the option <code>record=TRUE</code>, so that the history of all plots is recorded in the new device. 
This option may not work on some platforms; for example, RStudio does not allow the user to open
new  graphical devices.</p>
</td></tr>
<tr><td><code id="globalval.fun_+3A_plotdisp">plotDisp</code></td>
<td>
<p> A vector of the form <code>c(nr, nc)</code>.  The residual plots  in <code><a href="#topic+graphresU.fun">graphresU.fun</a></code>, 
<code><a href="#topic+graphres.fun">graphres.fun</a></code> and <code><a href="#topic+graphResCov.fun">graphResCov.fun</a></code>
will be drawn in a nr<code class="reqn">\times</code>nc layout. It is used as argument <code>mfrow</code> in <code><a href="graphics.html#topic+par">par</a></code>. By default,  
a 2 <code class="reqn">\times</code> 2 layout is used.</p>
</td></tr>
<tr><td><code id="globalval.fun_+3A_indgraph">indgraph</code></td>
<td>
<p>Logical flag. If it is TRUE, the validation plots (except the residual versus variables plots) in 
<code><a href="#topic+graphresU.fun">graphresU.fun</a></code> are carried out in four
1 <code class="reqn">\times</code> 1 layouts. By default,  a 2 <code class="reqn">\times</code> 2 layout is used.</p>
</td></tr>
<tr><td><code id="globalval.fun_+3A_scax">scax</code></td>
<td>
<p>Optional. Vector of two values indicating  the range of values for the x-axis 
in the fitted and empirical  rate plot. An adequate range is selected by default.</p>
</td></tr>
<tr><td><code id="globalval.fun_+3A_scay">scay</code></td>
<td>
<p>Optional. Vector of two values indicating  the range of values for the x-axis
in the fitted and empirical  rate plot. An adequate range is selected by default.</p>
</td></tr>
<tr><td><code id="globalval.fun_+3A_legcex">legcex</code></td>
<td>
<p>cex argument  for the legend in the  residual time plots 
(see <code><a href="graphics.html#topic+par">par</a></code> for details).</p>
</td></tr>
<tr><td><code id="globalval.fun_+3A_cores">cores</code></td>
<td>
<p>Optional. Number of cores of the computer
to be used in the calculations. Default: one core is used.</p>
</td></tr>
<tr><td><code id="globalval.fun_+3A_xlegend">xlegend</code></td>
<td>
<p>Argument xlegend used in the call of the function 
<code><a href="#topic+graphrate.fun">graphrate.fun</a></code>; see that function for details.</p>
</td></tr>
<tr><td><code id="globalval.fun_+3A_fixed.seed">fixed.seed</code></td>
<td>
<p>An integer or NULL. It is the argument for <code><a href="#topic+resQQplot.fun">resQQplot.fun</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If typeI=&quot;Overlapping&quot;, argument lint is compulsory. If 
typeI=&quot;Disjoint&quot;, only one of the arguments lint or  nlint must be specified.</p>


<h3>Value</h3>

<p>A list with the same elements that <code><a href="#topic+CalcRes.fun">CalcRes.fun</a></code> or 
<code><a href="#topic+CalcResD.fun">CalcResD.fun</a></code>
(depending on the value of the argument typeI).</p>


<h3>References</h3>

<p>Cebrian, A.C., Abaurrea, J. and Asin, J. (2015). NHPoisson: An R Package for 
Fitting and Validating Nonhomogeneous Poisson Processes. 
<em>Journal of Statistical Software</em>, 64(6), 1-24.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+graphres.fun">graphres.fun</a></code>, <code><a href="#topic+graphrate.fun">graphrate.fun</a></code>, <code><a href="#topic+resQQplot.fun">resQQplot.fun</a></code>,
<code><a href="#topic+graphResCov.fun">graphResCov.fun</a></code>, <code><a href="#topic+graphresU.fun">graphresU.fun</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(BarTxTn)

covB&lt;-cbind(cos(2*pi*BarTxTn$dia/365), sin(2*pi*BarTxTn$dia/365), 
	BarTxTn$TTx,BarTxTn$Txm31,BarTxTn$Txm31**2)


modB&lt;-fitPP.fun(tind=TRUE,covariates=covB, 
	POTob=list(T=BarTxTn$Tx, thres=318),
	tit="BAR Tx; cos, sin, TTx, Txm31, Txm31**2", 
	start=list(b0=-100,b1=1,b2=10,b3=0,b4=0,b5=0),CIty="Transf",modCI=TRUE,
	modSim=TRUE,dplot=FALSE)

#Since  only one graphical device is opened  and  the argument histWgraph is TRUE 
#by default, the different plots can be scrolled up and down with the "Page Up" 
#and "Page Down" keys.

aux&lt;-globalval.fun(mlePP=modB,lint=153,	typeI="Disjoint", 
	typeRes="Raw",typeResLV="Raw",	resqqplot=FALSE)

#If typeRes and typeResLV are not specified, Pearson residuals are calculated
#by default.

aux&lt;-globalval.fun(mlePP=modB,lint=153,	typeI="Disjoint", 
	resqqplot=FALSE)


</code></pre>

<hr>
<h2 id='graphrate.fun'>Plot fitted and  empirical  PP occurrence rates</h2><span id='topic+graphrate.fun'></span>

<h3>Description</h3>

<p>This function calculates the empirical  and the cumulative fitted occurrence rate
of a PP  on overlapping or disjoint intervals and plot them versus time.</p>


<h3>Usage</h3>

<pre><code class='language-R'>graphrate.fun(objres = NULL, fittedlambda = NULL, emplambda = NULL, t = NULL, 
lint = NULL, typeI = "Disjoint", tit = "", scax = NULL, scay = NULL, 
xlegend = "topleft",histWgraph=TRUE)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="graphrate.fun_+3A_objres">objres</code></td>
<td>
<p>Optional. A list with (at least) elements fittedlambda, emplambda, t, 
and typeI. 
For example, the output from <code><a href="#topic+CalcRes.fun">CalcRes.fun</a></code> or <code><a href="#topic+CalcResD.fun">CalcResD.fun</a></code>; 
see those functions for details.</p>
</td></tr>
<tr><td><code id="graphrate.fun_+3A_fittedlambda">fittedlambda</code></td>
<td>
<p>Optional. Numeric vector of the  cumulative  
fitted intensities <code class="reqn">\hat \lambda(t)</code> over the considered intervals
(and usually divided by the length of the interval).</p>
</td></tr>
<tr><td><code id="graphrate.fun_+3A_emplambda">emplambda</code></td>
<td>
<p>Optional. Numeric vector of the  empirical PP 
occurrence rates estimated  over the considered intervals (usually divided by the
length of the interval).</p>
</td></tr>
<tr><td><code id="graphrate.fun_+3A_t">t</code></td>
<td>
<p>Optional. Time vector of the  PP observation period.</p>
</td></tr>
<tr><td><code id="graphrate.fun_+3A_lint">lint</code></td>
<td>
<p>Optional. Length of the  intervals used to calculate 
the empirical and the (cumulative) fitted occurrence intensities.</p>
</td></tr>
<tr><td><code id="graphrate.fun_+3A_typei">typeI</code></td>
<td>
<p>Label indicating  the type ('Overlapping' or 'Disjoint') of  
the intervals.</p>
</td></tr>
<tr><td><code id="graphrate.fun_+3A_tit">tit</code></td>
<td>
<p>Character string. A title for the plot.</p>
</td></tr>
<tr><td><code id="graphrate.fun_+3A_scax">scax</code></td>
<td>
<p>Optional. Vector of two values giving  the range of values for 
the x-axis. An adequate range is selected by default.</p>
</td></tr>
<tr><td><code id="graphrate.fun_+3A_scay">scay</code></td>
<td>
<p>Optional. Vector of two values giving  the range of values for the 
y-axis. An adequate range is selected by default.</p>
</td></tr>
<tr><td><code id="graphrate.fun_+3A_xlegend">xlegend</code></td>
<td>
<p>Label indicating the position where the legend on 
the graph will be located.</p>
</td></tr>
<tr><td><code id="graphrate.fun_+3A_histwgraph">histWgraph</code></td>
<td>
<p> Logical flag.  If it is TRUE,  a new graphical device is opened
with the option <code>record=TRUE</code>. This option may not work on some platforms; 
for example, RStudio does not allow  the user to open new  graphical devices.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Either the argument objres or the set of arguments (fittedlambda, emplambda, t) 
must be specified. If objres is provided, fittedlambda, emplambda, t,lint and typeI  
are ignored.
</p>
<p>In order to make comparable the empirical and the fitted occurrence rates,
a cumulative fitted rate must be used. That means that argument fittedlambda 
must be the  sum of the
intensities fitted by the model  over  the same interval where the 
empirical rates have been calculated.</p>


<h3>See Also</h3>

 <p><code><a href="#topic+CalcRes.fun">CalcRes.fun</a></code>, <code><a href="#topic+CalcResD.fun">CalcResD.fun</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>##plot of rates based on overlapping intervals
graphrate.fun(emplambda=runif(500,0,1), fittedlambda=runif(500,0,1), 
	t=c(1:500), lint=100, tit="Example", typeI="Overlapping")

#plot of rates based on disjoint intervals
graphrate.fun(emplambda=runif(50,0,1), fittedlambda=runif(50,0,1), 
	t=c(1:50), lint=10, tit="Example", typeI="Disjoint")

#Example using objres as input. In this example X1 has no influence on the rate;
#consequently the fitted rate is almost a constant.

X1&lt;-rnorm(1000)

modE&lt;-fitPP.fun(tind=TRUE,covariates=cbind(X1), 
	posE=round(runif(40,1,1000)), inddat=rep(1,1000),
	tim=c(1:1000), tit="Simulated example", start=list(b0=1,b1=0),
	modCI=FALSE,modSim=TRUE,dplot=FALSE)

ResDE&lt;-CalcResD.fun(mlePP=modE,lint=50)

graphrate.fun(ResDE, tit="Example")



</code></pre>

<hr>
<h2 id='graphres.fun'>Plot NHPP residuals versus time or  monotonous variables</h2><span id='topic+graphres.fun'></span>

<h3>Description</h3>

<p>This function plots residuals of a NHPP (raw or scaled, 
overlapping or disjoint) 
versus time or other variables which are monotonous functions.</p>


<h3>Usage</h3>

<pre><code class='language-R'>graphres.fun(objres = NULL, typeRes = "Raw", t = NULL, res = NULL, lint = NULL, 
posE = NULL, fittedlambda = NULL, typeI = "Disjoint", Xvariables = NULL, 
namXv = NULL, histWgraph=TRUE, plotDisp=c(2,2), addlow = FALSE, lwd = 2, 
tit = "", flow = 0.5, xlegend = "topleft", legcex = 0.5)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="graphres.fun_+3A_objres">objres</code></td>
<td>
<p>Optional. A list with (at least) elements t, typeI and Rawres  and/or ScaRes, depending on 
the value of typeRes. For example, the output list from the functions 
<code><a href="#topic+CalcRes.fun">CalcRes.fun</a></code> or <code><a href="#topic+CalcResD.fun">CalcResD.fun</a></code>; see those functions for details.</p>
</td></tr>
<tr><td><code id="graphres.fun_+3A_typeres">typeRes</code></td>
<td>
<p>Label indicating the type of residuals (&quot;Raw&quot; or any type of scaled 
residuals such as &quot;Pearson&quot;).</p>
</td></tr>
<tr><td><code id="graphres.fun_+3A_t">t</code></td>
<td>
<p>Optional. Time vector of the PP observation period.</p>
</td></tr>
<tr><td><code id="graphres.fun_+3A_res">res</code></td>
<td>
<p>Optional. Vector of residuals.</p>
</td></tr>
<tr><td><code id="graphres.fun_+3A_lint">lint</code></td>
<td>
<p>Optional. Length of the  intervals used to calculate the residuals.</p>
</td></tr>
<tr><td><code id="graphres.fun_+3A_pose">posE</code></td>
<td>
<p>Optional. Numeric vector of the PP occurrence times. 
Only used when typeI = &quot;Overlapping&quot;.</p>
</td></tr>
<tr><td><code id="graphres.fun_+3A_fittedlambda">fittedlambda</code></td>
<td>
<p>Optional. Vector of the cumulative  fitted PP intensity 
over the intervals. Used  to calculate the envelopes when typeRes=&quot;Raw&quot;.</p>
</td></tr>
<tr><td><code id="graphres.fun_+3A_typei">typeI</code></td>
<td>
<p>Label indicating  the type (&quot;Overlapping&quot; or &quot;Disjoint&quot;) of intervals.</p>
</td></tr>
<tr><td><code id="graphres.fun_+3A_xvariables">Xvariables</code></td>
<td>
<p>Optional. Matrix  of the variables for
the residual plots (each column is a variable).</p>
</td></tr>
<tr><td><code id="graphres.fun_+3A_namxv">namXv</code></td>
<td>
<p>Optional. Vector of the  names of the variables in Xvariables.</p>
</td></tr>
<tr><td><code id="graphres.fun_+3A_histwgraph">histWgraph</code></td>
<td>
<p> Logical flag.   If it is TRUE,  a new graphical device is opened
with the option <code>record=TRUE</code>, so that the history of all plots is recorded in the new device. 
This option may not work on some platforms; for example, RStudio does not allow the user to open
new  graphical devices.</p>
</td></tr>
<tr><td><code id="graphres.fun_+3A_plotdisp">plotDisp</code></td>
<td>
<p> A vector of the form <code>c(nr, nc)</code>.  The residual plots will be drawn in 
a nr<code class="reqn">\times</code>nc array. It is used as argument <code>mfrow</code> in <code><a href="graphics.html#topic+par">par</a></code>. By default,  
a 2 <code class="reqn">\times</code> 2 window is used.</p>
</td></tr>
<tr><td><code id="graphres.fun_+3A_tit">tit</code></td>
<td>
<p>Character string. A title for the plots.</p>
</td></tr>
<tr><td><code id="graphres.fun_+3A_addlow">addlow</code></td>
<td>
<p>Logical flag. If it is TRUE, a lowess is added to the residual plots.</p>
</td></tr>
<tr><td><code id="graphres.fun_+3A_lwd">lwd</code></td>
<td>
<p>Argument lwd   for plotting the lowess lines, see <code><a href="graphics.html#topic+par">par</a></code>
for details.</p>
</td></tr>
<tr><td><code id="graphres.fun_+3A_flow">flow</code></td>
<td>
<p>Argument f for the lowess, see <code><a href="stats.html#topic+lowess">lowess</a></code> for details.</p>
</td></tr>
<tr><td><code id="graphres.fun_+3A_xlegend">xlegend</code></td>
<td>
<p>Label giving the position of the graph where the legend will 
be located.</p>
</td></tr>
<tr><td><code id="graphres.fun_+3A_legcex">legcex</code></td>
<td>
<p>Argument cex for the legend, see <code><a href="graphics.html#topic+par">par</a></code> for details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Either argument objres or pair of arguments (t,res) must be specified. 
If objres is provided, arguments t,res, typeRes, typeI, posE and  fittedlambda
are ignored.  
</p>
<p>A residual plot versus time is always performed. 
These plots are intended for time or variables which are monotonous functions,
since residuals are  calculated over a given time interval and plotted versus the
value of the variables in the mean point of the interval.
</p>
<p>A smoother (lowess) of the residuals can be optionally added to the plots. 
In the case of overlapping intervals,
the residuals of the occurrence points   are  marked differently from the rest.
In the case typeRes=&quot;Raw&quot; (if argument fittedlambda is available) or 
typeRes=&quot;Pearson&quot;,  envelopes for the residuals are also plotted.
The envelopes are based on an  approach analogous to the one shown in
Baddeley et al. (2005) for spatial  Poisson processes.  
The envelopes for raw residuals are,
</p>
<p style="text-align: center;"><code class="reqn">\pm {2 \over l_2-l_1} \sqrt{\sum_{ i \in (l_1,l_2)} \hat \lambda(i)} </code>
</p>

<p>where index i  runs over  the integers in the interval <code class="reqn">(l_1,l_2)</code>. 
The envelopes for the Pearson residuals are,
</p>
<p style="text-align: center;"><code class="reqn">\pm 2/\sqrt{l_2-l_1}.</code>
</p>
  
<p>These plots  allow us to analyze the effect on the intensity, of the covariates included
in the model or other potentially influent variables. They 
show  if the mean or the dispersion of the residuals vary sistematically, see  for 
example  residual analysis in Atkinson (1985) or Collett (1994).</p>


<h3>References</h3>

<p>Atkinson, A. (1985). <em>Plots, transformations and regression.</em> Oxford 
University Press.
</p>
<p>Baddeley, A., Turner, R., Moller, J. and Hazelton, M. (2005).
Residual analysis for spatial point processes.
<em>Journal of the Royal Statistical Society, Series B</em>, 67, 617-666.
</p>
<p>Cebrian, A.C., Abaurrea, J. and Asin, J. (2015). NHPoisson: An R Package for 
Fitting and Validating Nonhomogeneous Poisson Processes. 
<em>Journal of Statistical Software</em>, 64(6), 1-24.
</p>
<p>Collett, D. (1994). Modelling survival data in medical research. Chapman &amp; Hall.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+graphrate.fun">graphrate.fun</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
#Example using objres as input

X1&lt;-c(1:1000)**0.5

modE&lt;-fitPP.fun(tind=TRUE,covariates=cbind(X1), 
	posE=round(runif(40,1,1000)), inddat=rep(1,1000),
	tim=c(1:1000), tit="Simulated example", start=list(b0=1,b1=0),
	modSim = TRUE, dplot = FALSE)

ResDE&lt;-CalcResD.fun(mlePP=modE,lint=50)
graphres.fun(objres=ResDE, typeRes="Raw", Xvariables=cbind(X1),
	namXv=c("X1"), plotDisp=c(2,1), addlow=TRUE,tit="Example")


#Example using the set of arguments res, t and fittedlambda as input
#In this case, with typeI="Disjoint", only values of t, fittedlambda and Xvariables 
#in the midpoint of the intervals must be provided.

#Since   a 1X1 layout is  specified in plotDisp and only one  
#graphical device is opened by default, the two  resulting plots can be scrolled  
#up and down  with the "Page Up" and "Page Down" keys.

X1&lt;-c(1:500)**0.5
graphres.fun(res=rnorm(50),posE=round(runif(50,1,500)),
	fittedlambda=runif(500,0,1)[seq(5,495,10)],
	t=seq(5,495,10), typeRes="Raw", typeI="Disjoint",Xvariables=X1[seq(5,495,10)],
	namXv=c("X1"), plotDisp=c(1,1), tit="Example 2",lint=10)
</code></pre>

<hr>
<h2 id='graphResCov.fun'>Perform lurking variable plots for a set of variables</h2><span id='topic+graphResCov.fun'></span>

<h3>Description</h3>

<p>This function performs  lurking variable plots 
for a set of variables. The function 
<code><a href="#topic+graphResX.fun">graphResX.fun</a></code>  performs the lurking  variable plot for one variable and
<code>graphResCov.fun</code>  calls this function for a set of variables;
see <code><a href="#topic+graphResX.fun">graphResX.fun</a></code> for details.</p>


<h3>Usage</h3>

<pre><code class='language-R'>graphResCov.fun(Xvar, nint, mlePP, h = NULL, typeRes = "Pearson", namX = NULL, 
 histWgraph=TRUE, plotDisp=c(2,2), tit = "")</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="graphResCov.fun_+3A_xvar">Xvar</code></td>
<td>
<p>Matrix of variables (each column is a variable).</p>
</td></tr>
<tr><td><code id="graphResCov.fun_+3A_nint">nint</code></td>
<td>
<p>Number of intervals each  covariate  is divided into to perform
the lurking variable plot.</p>
</td></tr>
<tr><td><code id="graphResCov.fun_+3A_mlepp">mlePP</code></td>
<td>
<p>An object of class <code><a href="#topic+mlePP-class">mlePP-class</a></code>; usually,
the output  from <code><a href="#topic+fitPP.fun">fitPP.fun</a></code>.</p>
</td></tr>
<tr><td><code id="graphResCov.fun_+3A_typeres">typeRes</code></td>
<td>
<p>Label indicating the type of residuals (&quot;Raw&quot; or any type of 
scaled residuals such as &quot;Pearson&quot;) used in the plots.</p>
</td></tr>
<tr><td><code id="graphResCov.fun_+3A_h">h</code></td>
<td>
<p>Optional. Weight function  used to calculate the scaled residuals (if
typeRes is not equal to &quot;Raw&quot;). By default,  Pearson residuals with 
<code class="reqn">h(t)=1/\sqrt{\hat \lambda(t)}</code> are calculated. <code class="reqn">\hat \lambda(t)</code> is provided
by element lambdafit in mlePP.</p>
</td></tr>
<tr><td><code id="graphResCov.fun_+3A_namx">namX</code></td>
<td>
<p>Optional. Vector of  the names of the variables in Xvar.</p>
</td></tr>
<tr><td><code id="graphResCov.fun_+3A_histwgraph">histWgraph</code></td>
<td>
<p> Logical flag.   If it is TRUE,  a new graphical device is opened
with the option <code>record=TRUE</code>, so that the history of all plots is recorded in the new device. 
This option may not work on some platforms; for example, RStudio does not allow the user to open
new  graphical devices.</p>
</td></tr>
<tr><td><code id="graphResCov.fun_+3A_plotdisp">plotDisp</code></td>
<td>
<p> A vector of the form <code>c(nr, nc)</code>.  The lurking variable plots will be drawn in 
a nr<code class="reqn">\times</code>nc array. It is used as argument <code>mfrow</code> in <code><a href="graphics.html#topic+par">par</a></code>. By default,  
a 2 <code class="reqn">\times</code> 2 window is used.</p>
</td></tr>
<tr><td><code id="graphResCov.fun_+3A_tit">tit</code></td>
<td>
<p>Character string. A title for the plot.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with elements
</p>
<table>
<tr><td><code>mXres</code></td>
<td>
<p>Matrix of  residuals (each column contains the  residuals of a variable).</p>
</td></tr>
<tr><td><code>mXm</code></td>
<td>
<p>Matrix of   mean values (each column contains
the  mean values of a variable in each interval).</p>
</td></tr>
<tr><td><code>mXpc</code></td>
<td>
<p>Matrix of the quantiles that define the intervals of each variable
(each column contains the  quantiles of one variable).</p>
</td></tr>
<tr><td><code>nint</code></td>
<td>
<p>Input argument.</p>
</td></tr>
<tr><td><code>mlePP</code></td>
<td>
<p>Input argument.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Atkinson, A. (1985). <em>Plots, transformations and regression.</em> Oxford 
University Press.
</p>
<p>Baddeley, A., Turner, R., Moller, J. and Hazelton, M. (2005).
Residual analysis for spatial point processes.
<em>Journal of the Royal Statistical Society</em>, Series B 67,617-666.
</p>
<p>Cebrian, A.C., Abaurrea, J. and Asin, J. (2015). NHPoisson: An R Package for 
Fitting and Validating Nonhomogeneous Poisson Processes. 
<em>Journal of Statistical Software</em>, 64(6), 1-24.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+graphResX.fun">graphResX.fun</a></code>, <code><a href="#topic+graphres.fun">graphres.fun</a></code>  </p>


<h3>Examples</h3>

<pre><code class='language-R'>


#Simulated process without any relationship with variables Y1 and Y2
#The plots are performed dividing the  variables into  50 intervals
#Raw residuals. 

X1&lt;-rnorm(500)
X2&lt;-rnorm(500)
auxmlePP&lt;-fitPP.fun(posE=round(runif(50,1,500)), inddat=rep(1,500),
	covariates=cbind(X1,X2),start=list(b0=1,b1=0,b2=0))

Y1&lt;-rnorm(500)
Y2&lt;-rnorm(500)
res&lt;-graphResCov.fun(mlePP=auxmlePP, Xvar=cbind(Y1,Y2), nint=50,  
	typeRes="Raw",namX=c("Y1","Y2"),plotDisp=c(2,1))

#If more variables were specified in the argument Xvar, with
#the same 2X1 layout specified in plotDisp, the resulting plots could be 
#scrolled up and down with the "Page Up" and "Page Down" keys.

</code></pre>

<hr>
<h2 id='graphresU.fun'>Validation analysis of PP uniform (generalized) residuals</h2><span id='topic+graphresU.fun'></span>

<h3>Description</h3>

<p>This function checks the properties that must
be fulfilled  by the uniform (generalized) residuals of a PP: uniform
character and uncorrelation. Optionally, the existence of patterns
versus covariates or potentially influent variables can be graphically analyzed.</p>


<h3>Usage</h3>

<pre><code class='language-R'>graphresU.fun(unires, posE,  Xvariables = NULL, namXv = NULL, flow = 0.5,
 tit = "", addlow = TRUE, histWgraph=TRUE, plotDisp=c(2,2), indgraph = FALSE)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="graphresU.fun_+3A_unires">unires</code></td>
<td>
<p>Numeric vector of the uniform residuals.</p>
</td></tr>
<tr><td><code id="graphresU.fun_+3A_pose">posE</code></td>
<td>
<p>Numeric vector of the occurrence times of the PP.</p>
</td></tr>
<tr><td><code id="graphresU.fun_+3A_xvariables">Xvariables</code></td>
<td>
<p>Matrix of variables to perform the residual plots (each column
is a variable).</p>
</td></tr>
<tr><td><code id="graphresU.fun_+3A_namxv">namXv</code></td>
<td>
<p>Optional. Vector of names of the variables in Xvariables.</p>
</td></tr>
<tr><td><code id="graphresU.fun_+3A_tit">tit</code></td>
<td>
<p>Character string. A title for the plot.</p>
</td></tr>
<tr><td><code id="graphresU.fun_+3A_addlow">addlow</code></td>
<td>
<p>Logical flag. If it is TRUE, a lowess is added to the plots.</p>
</td></tr>
<tr><td><code id="graphresU.fun_+3A_flow">flow</code></td>
<td>
<p>Argument f for the lowess smoother; see <code><a href="stats.html#topic+lowess">lowess</a></code> 
for details.</p>
</td></tr>
<tr><td><code id="graphresU.fun_+3A_histwgraph">histWgraph</code></td>
<td>
<p> Logical flag.   If it is TRUE,  a new graphical device is opened
with the option <code>record=TRUE</code>, so that the history of all plots is recorded in the new device. 
This option may not work on some platforms; for example, RStudio does not allow the user to open
new  graphical devices.</p>
</td></tr>
<tr><td><code id="graphresU.fun_+3A_plotdisp">plotDisp</code></td>
<td>
<p> A vector of the form <code>c(nr, nc)</code>.  The residual versus variables plots will be drawn in 
a nr<code class="reqn">\times</code>nc array. It is used as argument <code>mfrow</code> in <code><a href="graphics.html#topic+par">par</a></code>. By default,  
a 2 <code class="reqn">\times</code> 2 layout is used.</p>
</td></tr>
<tr><td><code id="graphresU.fun_+3A_indgraph">indgraph</code></td>
<td>
<p>Logical flag. If it is TRUE, the validation plots (except the residuals versus variables
plots) are carried out in four1 <code class="reqn">\times</code> 1 layouts. By default,  a 2 <code class="reqn">\times</code> 2 layout is used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The validation analysis  of the uniform
character consists in a  uniform Kolmogorov-Smirnov test and 
a qqplot with a 95%  confidence band based on a beta distribution. 
The analysis of the serial correlation is based on the Pearson correlation 
coefficient, Ljung-Box  tests and a lagged  serial correlation plot. 
An index plot of the residuals and residual plots  versus the variables 
in argument Xvariables are performed to analyze the effect of
covariates   or  other potentially influent variables. These  plots
will show  if the mean or dispersion of the residuals vary sistematically, see model
diagnostic of Cox-Snell residuals in Collett (1994) for more details.</p>


<h3>References</h3>

<p>Abaurrea, J., Asin, J., Cebrian, A.C. and Centelles, A.
(2007). Modeling and forecasting extreme heat events in the central
Ebro valley, a continental-Mediterranean area. <em>Global and
Planetary Change</em>, 57(1-2), 43-58.
</p>
<p>Baddeley, A., Turner, R., Moller, J. and Hazelton, M. (2005).
Residual analysis for spatial point processes.
<em>Journal of the Royal Statistical Society, Series B</em>, 67, 617-666.
</p>
<p>Cebrian, A.C., Abaurrea, J. and Asin, J. (2015). NHPoisson: An R Package for 
Fitting and Validating Nonhomogeneous Poisson Processes. 
<em>Journal of Statistical Software</em>, 64(6), 1-24.
</p>
<p>Collett, D. (1994). Modelling survival data in medical research. Chapman \&amp; Hall.
</p>
<p>Ogata, Y. (1988). Statistical models for earthquake occurrences and residual
analysis for point processes. <em>Journal of  the American Statistical Association</em>,
83(401), 9-27.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+unifres.fun">unifres.fun</a></code>, <code><a href="#topic+transfH.fun">transfH.fun</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#Since  only one graphical device is opened  and the argument histWgraph 
#is TRUE by default, the resulting residual plots  (three pages with the 
#considered 1X2 layout for the residual versus variables plot)   
#can be scrolled up and down with the "Page Up" and "Page Down" keys.

X1&lt;-rnorm(500)
X2&lt;-rnorm(500)

graphresU.fun(unires=runif(30,0,1),posE=round(runif(30,0,500)), 
  Xvariables=cbind(X1,X2), namXv=c("X1","X2"),tit="Example",flow=0.7,plotDisp=c(1,2))

</code></pre>

<hr>
<h2 id='graphResX.fun'>Perform a lurking  variable plot</h2><span id='topic+graphResX.fun'></span>

<h3>Description</h3>

<p>This function performs a lurking  variable plot to analyze the residuals  in terms
of different levels of the variable. </p>


<h3>Usage</h3>

<pre><code class='language-R'>graphResX.fun(X, nint, mlePP, typeRes = "Pearson", h = NULL, namX = NULL)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="graphResX.fun_+3A_x">X</code></td>
<td>
<p>Numeric vector, the variable for the lurking variable plot.</p>
</td></tr>
<tr><td><code id="graphResX.fun_+3A_nint">nint</code></td>
<td>
<p>Number of intervals or levels the variable  is divided into.</p>
</td></tr>
<tr><td><code id="graphResX.fun_+3A_mlepp">mlePP</code></td>
<td>
<p>An object of class <code><a href="#topic+mlePP-class">mlePP-class</a></code>; usually,
the output  from <code><a href="#topic+fitPP.fun">fitPP.fun</a></code>.</p>
</td></tr>
<tr><td><code id="graphResX.fun_+3A_typeres">typeRes</code></td>
<td>
<p>Label indicating the type of residuals ('Raw' or any type of 
scaled residuals such as 'Pearson').</p>
</td></tr>
<tr><td><code id="graphResX.fun_+3A_h">h</code></td>
<td>
<p>Optional. Weight function  used to calculate the scaled residuals (if
typeRes is not equal to 'Raw'). By default,  Pearson residuals with 
<code class="reqn">h(t)=1/\sqrt{\hat \lambda(t)}</code> are calculated. <code class="reqn">\hat \lambda(t)</code> is provided
by  the lambdafit  slot in mlePP.</p>
</td></tr>
<tr><td><code id="graphResX.fun_+3A_namx">namX</code></td>
<td>
<p>Optional. Name of variable X.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The residuals for different levels of the variable are analyzed.
For a variable <code class="reqn">X(t)</code>, the considered levels are
</p>
<p style="text-align: center;"><code class="reqn">W(P_{X,j}, P_{X,j+1})=\{ t:  P_{X,j} \le X(t) &lt; P_{X,j+1} \}</code>
</p>

<p>where  <code class="reqn">P_{X,i}</code> is the sample j-percentile of  X. This type of plot is 
specially useful for variables which are not a  monotonous function of time.
</p>
<p>In the case typeRes='Raw'  or typeRes='Pearson',  envelopes for the residuals 
are also plotted.
The envelopes are based on an  approach analogous to the one  in
Baddeley et al. (2005) for spatial  Poisson processes.   
The envelopes for raw residuals are
</p>
<p style="text-align: center;"><code class="reqn">\pm {2 \over l_W} \sqrt{\sum_i \hat \lambda(i)}</code>
</p>

<p>where index i  runs over  the integers in the level <code class="reqn">W(P_{X,j}, P_{X,j+1})</code>,
and <code class="reqn">l_W</code> is its length (number of observations in <code class="reqn">W</code>). 
The envelopes for the Pearson residuals are,
</p>
<p style="text-align: center;"><code class="reqn">\pm 2/\sqrt{l_W}.</code>
</p>



<h3>Value</h3>

<p>A list with elements
</p>
<table>
<tr><td><code>Xres</code></td>
<td>
<p>Vector of  residuals. </p>
</td></tr>
<tr><td><code>xm</code></td>
<td>
<p>Vector of the  mean value  of the variable in each interval.</p>
</td></tr>
<tr><td><code>pc</code></td>
<td>
<p>Vector of the quantiles that define the levels of the variable.</p>
</td></tr>
<tr><td><code>typeRes</code></td>
<td>
<p>Input argument.</p>
</td></tr>
<tr><td><code>namX</code></td>
<td>
<p>Input argument.</p>
</td></tr>
<tr><td><code>lambdafit</code></td>
<td>
<p>Input argument.</p>
</td></tr>
<tr><td><code>posE</code></td>
<td>
<p>Input argument.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Atkinson, A. (1985). <em>Plots, transformations and regression.</em> Oxford 
University Press.
</p>
<p>Baddeley, A., Turner, R., Moller, J. and Hazelton, M. (2005).
Residual analysis for spatial point processes.
<em>Journal of the Royal Statistical Society</em>, Series B 67, 617-666.
</p>
<p>Cebrian, A.C., Abaurrea, J. and Asin, J. (2015). NHPoisson: An R Package for 
Fitting and Validating Nonhomogeneous Poisson Processes. 
<em>Journal of Statistical Software</em>, 64(6), 1-24.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+graphResCov.fun">graphResCov.fun</a></code>, <code><a href="#topic+graphres.fun">graphres.fun</a></code>  </p>


<h3>Examples</h3>

<pre><code class='language-R'>
##Simulated process not related to variable X
##Plots dividing the  variable into  50 levels

X1&lt;-rnorm(500)
X2&lt;-rnorm(500)
auxmlePP&lt;-fitPP.fun(posE=round(runif(50,1,500)), inddat=rep(1,500),
	covariates=cbind(X1,X2),start=list(b0=1,b1=0,b2=0))



##Raw residuals
res&lt;-graphResX.fun(X=rnorm(500),nint=50,mlePP=auxmlePP,typeRes="Raw")

##Pearson residuals
res&lt;-graphResX.fun(X=rnorm(500),nint=50,mlePP=auxmlePP,typeRes="Pearson")


</code></pre>

<hr>
<h2 id='LRTpv.fun'>Calculate the p-value of a likelihood ratio test for each covariate in the model</h2><span id='topic+LRTpv.fun'></span>

<h3>Description</h3>

<p>This function calculates, for each covariate in the model (except the intercept),  the p-value 
of a likelihood  ratio test comparing  the  original fitted NHPP with the model excluding 
that covariate from the linear predictor.</p>


<h3>Usage</h3>

<pre><code class='language-R'>LRTpv.fun(mlePP)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="LRTpv.fun_+3A_mlepp">mlePP</code></td>
<td>
<p>An object of class <code><a href="#topic+mlePP-class">mlePP-class</a></code>; usually,
the output  from <code><a href="#topic+fitPP.fun">fitPP.fun</a></code>. The fitted model cannot include fixed parameters.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A LRT is  carried for all the covariates  in the linear predictor
except the intercept. If the model has not an intercept and there is only one covariate, no test can be carried out.
</p>


<h3>Value</h3>

<p>A matrix with one column, which contains the LRT p-values for all the covariates in the model (except the intercept)
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+fitPP.fun">fitPP.fun</a></code>, <code><a href="#topic+testlik.fun">testlik.fun</a></code>, <code><a href="#topic+dropAIC.fun">dropAIC.fun</a></code>, <code><a href="#topic+addAIC.fun">addAIC.fun</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(BarTxTn)
covB&lt;-cbind(cos(2*pi*BarTxTn$dia/365), sin(2*pi*BarTxTn$dia/365), 
	BarTxTn$TTx,BarTxTn$Txm31,BarTxTn$Txm31**2)
BarEv&lt;-POTevents.fun(T=BarTxTn$Tx,thres=318, 
	date=cbind(BarTxTn$ano,BarTxTn$mes,BarTxTn$dia))

mod1B&lt;-fitPP.fun(tind=TRUE,covariates=covB, 
	posE=BarEv$Px, inddat=BarEv$inddat,
	tit="BAR Tx; cos, sin, TTx, Txm31, Txm31**2", 
	start=list(b0=-100,b1=1,b2=10,b3=0,b4=0,b5=0),dplot=FALSE, modCI=FALSE)

LRTpv.fun(mod1B)
</code></pre>

<hr>
<h2 id='mlePP-class'>Class <code>"mlePP"</code> for results of maximum likelihood estimation of Poisson processes with covariates</h2><span id='topic+mlePP-class'></span>

<h3>Description</h3>

<p>This class encapsulates  the output from the  maximum likelihood  estimation of  a Poisson process where the 
intensity is modeled as a linear function of  covariates.</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form  <code>new("mlePP", ...)</code>, but most often as the 
result of a call to <code><a href="#topic+fitPP.fun">fitPP.fun</a></code>.  </p>


<h3>Slots</h3>


<dl>
<dt><code>call</code>:</dt><dd><p>Object of class <code>"language"</code>.  The call to <code><a href="#topic+fitPP.fun">fitPP.fun</a></code>.</p>
</dd>
<dt><code>coef</code>:</dt><dd><p>Object of class <code>"numeric"</code>. The estimated coefficientes of the model. </p>
</dd>
<dt><code>fullcoef</code>:</dt><dd><p>Object of class <code>"numeric"</code>. The  full coefficient vector, including the fixed 
parameters of the model. It has an attribute, called 'TypeCoeff' which shows  the names of the fixed parameters.</p>
</dd>
<dt><code>vcov</code>:</dt><dd><p>Object of class <code>"matrix"</code>. Approximate variance-covariance matrix of the estimated coefficients.
It has an attribute, called 'CalMethod' which shows the method  used to calcualte the  inverse of the information matrix: 
'Solve function', 'Cholesky', 'Not possible' or 'Not required' if  <code>modCI=FALSE</code>.</p>
</dd>
<dt><code>min</code>:</dt><dd><p>Object of class <code>"numeric"</code>. Minimum value of objective function, that is the 
negative of the loglikelihood function. </p>
</dd>
<dt><code>details</code>:</dt><dd><p>Object of class <code>"list"</code>. The output returned from <code><a href="stats.html#topic+optim">optim</a></code>. 
If  <code><a href="stats.html#topic+nlminb">nlminb</a></code> is used to minimize the function, it is NULL.</p>
</dd>
<dt><code>minuslogl</code>:</dt><dd><p>Object of class <code>"function"</code>.  The negative  of the loglikelihood function.</p>
</dd>
<dt><code>nobs</code>:</dt><dd><p>Object of class <code>"integer"</code>.  The number of observations.</p>
</dd>
<dt><code>method</code>:</dt><dd><p>Object of class <code>"character"</code>.  It is a bit different from the slot in  the extended 
class 	<code><a href="stats4.html#topic+mle-class">mle</a></code>: here,
it is the input argument <code>minfun</code> of <code><a href="#topic+fitPP.fun">fitPP.fun</a></code> instead of the  method used 
in <code><a href="stats.html#topic+optim">optim</a></code> (this information already appears in <code>details</code>).</p>
</dd>
<dt><code>detailsb</code>:</dt><dd><p>Object of class <code>"list"</code>.The output returned from <code><a href="stats.html#topic+nlminb">nlminb</a></code>. 
If  <code><a href="stats.html#topic+optim">optim</a></code> is used to minimize the function, it is NULL.</p>
</dd>
<dt><code>npar</code>:</dt><dd><p>Object of class <code>"integer"</code>. Number of estimated parameters.</p>
</dd>
<dt><code>inddat</code>:</dt><dd><p>Object of class <code>"numeric"</code>.  Input argument  of <code><a href="#topic+fitPP.fun">fitPP.fun</a></code>.</p>
</dd>
<dt><code>lambdafit</code>:</dt><dd><p>Object of class <code>"numeric"</code>. Vector of the fitted intensity <code class="reqn">\hat \lambda(t)</code>.</p>
</dd>
<dt><code>LIlambda</code>:</dt><dd><p>Object of class <code>"numeric"</code>. Vector of lower limits of the CI.</p>
</dd>
<dt><code>UIlambda</code>:</dt><dd><p>Object of class <code>"numeric"</code>. Vector of upper limits of the CI.</p>
</dd>
<dt><code>convergence</code>:</dt><dd><p>Object of class <code>"integer"</code>. A code of convergence. 0 indicates successful convergence. </p>
</dd>
<dt><code>posE</code>:</dt><dd><p>Object of class <code>"numeric"</code>. Input argument  of <code><a href="#topic+fitPP.fun">fitPP.fun</a></code>.</p>
</dd>
<dt><code>covariates</code>:</dt><dd><p>Object of class <code>"matrix"</code>. Input argument  of <code><a href="#topic+fitPP.fun">fitPP.fun</a></code>.</p>
</dd> 
<dt><code>tit</code>:</dt><dd><p>Object of class <code>"character"</code>. Input argument of <code><a href="#topic+fitPP.fun">fitPP.fun</a></code>.</p>
</dd> 
<dt><code>tind</code>:</dt><dd><p>Object of class <code>"logical"</code>. Input argument of <code><a href="#topic+fitPP.fun">fitPP.fun</a></code>.</p>
</dd>
<dt><code>t</code>:</dt><dd><p>Object of class <code>"numeric"</code>. Input argument of <code><a href="#topic+fitPP.fun">fitPP.fun</a></code>.</p>
</dd> 
</dl>



<h3>Extends</h3>

<p>Class <code>"<a href="stats4.html#topic+mle-class">mle</a>"</code>, directly.</p>


<h3>Methods</h3>

<p>Most of the  S4 methods in <span class="pkg">stats4</span>  for the S4-class <code>mle</code> can be used.  Also  a  <code>mle</code> method 
for  the generic function <code><a href="stats.html#topic+extractAIC">extractAIC</a></code> and a version of the <code><a href="stats.html#topic+profile">profile</a></code>  
<code><a href="stats4.html#topic+mle-class">mle</a></code>  method adapted to the  <code><a href="#topic+mlePP-class">mlePP</a></code> objects are available:
</p>

<dl>
<dt>coef</dt><dd><p><code>signature(object = "mle")</code></p>
</dd>
<dt>logLik</dt><dd><p><code>signature(object = "mle")</code></p>
</dd>
<dt>nobs</dt><dd><p><code>signature(object = "mle")</code></p>
</dd>
<dt>show</dt><dd><p><code>signature(object = "mle")</code></p>
</dd>
<dt>summary</dt><dd><p><code>signature(object = "mle")</code></p>
</dd>
<dt>update</dt><dd><p><code>signature(object = "mle")</code></p>
</dd>
<dt>vcov</dt><dd><p><code>signature(object = "mle")</code></p>
</dd>
<dt>confint</dt><dd><p><code>signature(object = "mle")</code></p>
</dd>
<dt>extractAIC</dt><dd><p><code>signature(object = "mle")</code></p>
</dd>
<dt>profile</dt><dd><p><code>signature(fitted = "mlePP")</code></p>
</dd>
</dl>

<p>Some other generic functions related to fitted models, such as <code>AIC</code> or <code>BIC</code>, can  also  
be applied to <code>mlePP</code> objects. 
</p>


<h3>Note</h3>

<p>Let us remind that, as in all the S4-classes,  the symbol @  must be used instead of $ to name the slots: mlePP@covariates, 
mlepp@lambdafit, etc.</p>


<h3>See Also</h3>

<p><code><a href="#topic+fitPP.fun">fitPP.fun</a></code>,  <code><a href="stats4.html#topic+mle-class">mle</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>showClass("mlePP")
</code></pre>

<hr>
<h2 id='NHPoisson-package'>Statistical modelling of non homogeneous Poisson processes</h2><span id='topic+NHPoisson-package'></span><span id='topic+NHPoisson'></span>

<h3>Description</h3>

<p><span class="pkg">NHPoisson</span> provides  tools for the modelling and maximum likelihood estimation 
of non homogeneous Poisson processes (NHPP) in time, where the 
intensity is formulated as a function of  (time-dependent) covariates. 
A comprehensive toolkit for  model selection,
residual analysis and diagnostic of the fitted model is also provided.  Finally, it  
permits random generation of NHPP.</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> NHPoisson</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 3.0</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2014-05-21</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL (&gt;=2)  </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>


<h3>Author(s)</h3>

<p>Ana C. Cebrian &lt;acebrian@unizar.es&gt;</p>


<h3>See Also</h3>

<p><span class="pkg">evir</span>, <span class="pkg">extRemes</span>, <span class="pkg">POT</span>, <span class="pkg">ppstat</span>, <span class="pkg">spatstat</span>, <span class="pkg">yuima</span></p>

<hr>
<h2 id='POTevents.fun'>Calculate extreme events using a POT approach</h2><span id='topic+POTevents.fun'></span>

<h3>Description</h3>

<p>This function calculates the characteristics of the extreme events
of a series  <code class="reqn">(x_i)</code>  defined using a peak over threshold (POT) method
with an extreme threshold. The initial  and the maximum intensity positions,  
the mean excess, the maximum excess  and the length of each event are calculated. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>POTevents.fun(T, thres, date = NULL)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="POTevents.fun_+3A_t">T</code></td>
<td>
<p>Numeric vector, the series <code class="reqn">(x_i)</code> to calculate the
extreme events.</p>
</td></tr>
<tr><td><code id="POTevents.fun_+3A_thres">thres</code></td>
<td>
<p>Threshold value  used to define the extreme events.</p>
</td></tr>
<tr><td><code id="POTevents.fun_+3A_date">date</code></td>
<td>
<p>Optional. A vector or matrix indicating the date of each observation.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>One of the elements of the output from this function is  a vector (inddat)
which marks the observations  that should be used in the estimation of a point  process,
resulting from a POT approach. The  observations  to be considered in the estimation
are marked with 1 and correspond to the non occurrence  observations and to
a single occurrence point per event. The occurence point is defined as the point 
where maximum intensity of the event  occurs.The 
observations in an extreme event which are not the occurrence point are marked with 0
and treated as non observed. </p>


<h3>Value</h3>

<p>A list with components
</p>
<table>
<tr><td><code>Pi</code></td>
<td>
<p>Vector of  the initial points of the extreme events.</p>
</td></tr>
<tr><td><code>datePi</code></td>
<td>
<p>Date of the initial points Pi.</p>
</td></tr>
<tr><td><code>Px</code></td>
<td>
<p>Vector of the points of  maximum excess of the extreme events.</p>
</td></tr>
<tr><td><code>datePx</code></td>
<td>
<p>Vector of the date of the maximum excess points Px.</p>
</td></tr>
<tr><td><code>Im</code></td>
<td>
<p>Vector of the mean excesses (over the threshold) of the extreme events.</p>
</td></tr>
<tr><td><code>Ix</code></td>
<td>
<p>Vector of the maximum excesses (over the threshold) of the extreme events.</p>
</td></tr>
<tr><td><code>L</code></td>
<td>
<p>Vector of the lengths of the extreme events.</p>
</td></tr>
<tr><td><code>inddat</code></td>
<td>
<p>Index equal to 1 in the observations used in the estimation process 
and  to 0  in the others.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+fitPP.fun">fitPP.fun</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(BarTxTn)
dateB&lt;-cbind(BarTxTn$ano,BarTxTn$mes,BarTxTn$diames)
BarEv&lt;-POTevents.fun(T=BarTxTn$Tx,thres=318, date=dateB)
</code></pre>

<hr>
<h2 id='profile-methods'> Method <code>mlePP</code> for Function <code>profile</code></h2><span id='topic+profile-methods'></span><span id='topic+profile+2CmlePP-method'></span>

<h3>Description</h3>

<p> Method for  generic function <code><a href="stats.html#topic+profile">profile</a></code> for  objects of the S4-class 
<code><a href="#topic+mlePP-class">mlePP</a></code>. It is almost  identical to the method <code><a href="stats4.html#topic+mle-class">mle</a></code> for this function in <span class="pkg">stats4</span>, 
but  small changes  have to be done due to the differences  in the arguments of  the functions
<code>mle</code>  and <code>fitPP.fun</code>.  In order to profile an <code>mlePP</code> object,  its <code>vcov</code> slot cannot be missing. 
That means that if the function <code>fitPP.fun</code> is used to create the object, the argument <code>modCI=TRUE</code> must be used.
</p>


<h3>Methods</h3>


<dl>
<dt><code>signature(fitted = "mlePP")</code></dt><dd></dd>
</dl>

<hr>
<h2 id='resQQplot.fun'>Perform a qqplot for the residuals of a NHPP</h2><span id='topic+resQQplot.fun'></span><span id='topic+resSim.fun'></span>

<h3>Description</h3>

<p>This function  performs a qqplot comparing the empirical quantiles of the 
residuals with the expected quantiles under the fitted NHPP,
calculated by a Monte Carlo approach.
</p>
<p>It calls the auxiliary function <code>resSim.fun</code> 
(not intended for the users), see Details section.</p>


<h3>Usage</h3>

<pre><code class='language-R'>resQQplot.fun(nsim, objres, covariates, clevel = 0.95, cores = 1, 
tit ="", fixed.seed=NULL, histWgraph=TRUE)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="resQQplot.fun_+3A_nsim">nsim</code></td>
<td>
<p>Number of simulations for the calculations.</p>
</td></tr>
<tr><td><code id="resQQplot.fun_+3A_objres">objres</code></td>
<td>
<p>A list with the same elements of the output list from the
function <code><a href="#topic+CalcRes.fun">CalcRes.fun</a></code> or <code><a href="#topic+CalcResD.fun">CalcResD.fun</a></code>.</p>
</td></tr>
<tr><td><code id="resQQplot.fun_+3A_covariates">covariates</code></td>
<td>
<p>Matrix of covariates to fit the NHPP (each column is a covariate).</p>
</td></tr>
<tr><td><code id="resQQplot.fun_+3A_clevel">clevel</code></td>
<td>
<p>Confidence level of the  residual envelope.</p>
</td></tr>
<tr><td><code id="resQQplot.fun_+3A_cores">cores</code></td>
<td>
<p>Optional. Number of cores of the computer to be used in the 
calculations. Default: one core is used.</p>
</td></tr>
<tr><td><code id="resQQplot.fun_+3A_tit">tit</code></td>
<td>
<p>Character string. A title for the plot.</p>
</td></tr>
<tr><td><code id="resQQplot.fun_+3A_fixed.seed">fixed.seed</code></td>
<td>
<p>An integer or NULL. If it is an integer, that is the value  used to set the seed 
in  random  generation processes. It it is NULL, a random seed is used.</p>
</td></tr>
<tr><td><code id="resQQplot.fun_+3A_histwgraph">histWgraph</code></td>
<td>
<p> Logical flag.  Only used in Windows platforms. If it is TRUE,  a new graphical device is opened
with the option <code>record=TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The expected quantiles are calculated as the median values  of the simulated samples. 
Confidence intervals for each quantile <code class="reqn">r_{(i)}</code> with pointwise  significance level 
<code>clevel</code>  are calculated as quantiles of probability 1-clevel /2 and clevel/2 
of the simulated sample for each residual. 
</p>
<p>All type of residuals (disjoint or overlapping and Pearson or raw residuals) are 
supported by this function. However, the  qqplot for overlapping residuals can  be
a high time consuming process. So,  disjoint
residuals should be prefered in this function.
</p>
<p>The  auxiliary function <code>resSim.fun</code> generates a NHPP with intensity <code class="reqn">\lambda(t)</code>,
fits the model using the covariate matrix  and calculates the residuals.</p>


<h3>Value</h3>

<p>A list with elements
</p>
<table>
<tr><td><code>resmed</code></td>
<td>
<p>Numeric vector containing the mean of the simulated residuals 
in each point.</p>
</td></tr>
<tr><td><code>ressup</code></td>
<td>
<p>Numeric vector of the upper values of the simulated envelopes.</p>
</td></tr>
<tr><td><code>resinf</code></td>
<td>
<p>Numeric vector of the lower values of the simulated envelopes.</p>
</td></tr>
<tr><td><code>objres</code></td>
<td>
<p>Input argument.</p>
</td></tr>
<tr><td><code>nsim</code></td>
<td>
<p>Input argument.</p>
</td></tr>
<tr><td><code>fixed.seed</code></td>
<td>
<p>Input argument.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Cebrian, A.C., Abaurrea, J. and Asin, J. (2015). NHPoisson: An R Package for 
Fitting and Validating Nonhomogeneous Poisson Processes. 
<em>Journal of Statistical Software</em>, 64(6), 1-24.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+simNHP.fun">simNHP.fun</a></code>, <code><a href="#topic+GenEnv.fun">GenEnv.fun</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
X1&lt;-rnorm(500)
X2&lt;-rnorm(500)

aux&lt;-fitPP.fun(tind=TRUE,covariates=cbind(X1,X2), 
	posE=round(runif(40,1,500)), inddat=rep(1,500),
	tim=c(1:500), tit="Simulated example", start=list(b0=1,b1=0,b2=0),dplot=FALSE)

auxRes&lt;-CalcResD.fun(mlePP=aux,lint=50)


#if we want reproducible results, we can fixed the seed in the generation process
#(the number of cores used in the calculations must also be the same to reproduce
# the result)

auxqq&lt;-resQQplot.fun(nsim=50,objres=auxRes, covariates=cbind(X1,X2), fixed.seed=123)

</code></pre>

<hr>
<h2 id='simNHP.fun'>Generate the occurrence points of a NHPP</h2><span id='topic+simNHP.fun'></span><span id='topic+buscar'></span>

<h3>Description</h3>

<p>This function generates the occurrence times of the points  
of a NHPP with  a given  time-varying intensity <code class="reqn">\lambda(t)</code>, 
in a period (0, T). The length of argument lambda determines T,
the length of the observation period.
</p>
<p>It calls the auxiliary function <code>buscar</code> (not intended
for the users), see Details section.</p>


<h3>Usage</h3>

<pre><code class='language-R'>simNHP.fun(lambda, fixed.seed=NULL)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simNHP.fun_+3A_lambda">lambda</code></td>
<td>
<p>Numeric vector, the time varying intensity <code class="reqn">\lambda(t)</code>
to generate the NHPP.</p>
</td></tr>
<tr><td><code id="simNHP.fun_+3A_fixed.seed">fixed.seed</code></td>
<td>
<p>An integer or NULL. If it is an integer, that is the value  used to set the seed 
in  random  generation processes. It it is NULL, a random seed is used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The generation of the NHPP points consists in two steps. 
First,  the points of a homogeneous PP  of intensity 1 are generated using 
independent exponentials. Then, the  homogeneous occurrence times are transformed into 
the points  of a  non homogeneous process with intensity <code class="reqn">\lambda(t)</code>.
This transformation is performed by the auxiliary function <code>buscar</code> 
(not intended for the user).</p>


<h3>Value</h3>

<p>A list with elements
</p>
<table>
<tr><td><code>posNH</code></td>
<td>
<p>Numeric vector of the occurrences times of the NHPP generated in 
the observation period (0,T).</p>
</td></tr>
<tr><td><code>lambda</code></td>
<td>
<p>Input argument.</p>
</td></tr>
<tr><td><code>fixed.seed</code></td>
<td>
<p>Input argument.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Cebrian, A.C., Abaurrea, J. and Asin, J. (2015). NHPoisson: An R Package for 
Fitting and Validating Nonhomogeneous Poisson Processes. 
<em>Journal of Statistical Software</em>, 64(6), 1-24.
</p>
<p>Ross, S.M. (2006). <em>Simulation.</em> Academic Press.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+GenEnv.fun">GenEnv.fun</a></code>, <code><a href="#topic+resQQplot.fun">resQQplot.fun</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>#Generation of the occurrence times of a homogeneours PP with  constant intensity 
#0.01 in a period  of time of length 1000

aux&lt;-simNHP.fun(lambda=rep(0.01,1000))
aux$posNH

#if we want reproducible results, we can fixed the seed in the generation process
aux&lt;-simNHP.fun(lambda=rep(0.01,1000),fixed.seed=123)
aux$posNH

#and the result is:
#  [1]  85 143 275 279 284 316 347 362 634 637 738 786 814 852 870 955


#Generation of  the occurrence times of a NHPP with  time-varying intensity t in 
#a period  of time of length 500

t&lt;-runif(500, 0.01,0.1)
aux&lt;-simNHP.fun(lambda=t)
aux$posNH
</code></pre>

<hr>
<h2 id='stepAICmle.fun'>Choose  the best PP model by AIC in a stepwise algorithm</h2><span id='topic+stepAICmle.fun'></span><span id='topic+checkdim'></span>

<h3>Description</h3>

<p>Performs stepwise model selection by AIC for Poisson proces models 
estimated by maximum likelihood. 
</p>
<p>It calls the auxiliary function <code>checkdim</code> (not intended
for the users).</p>


<h3>Usage</h3>

<pre><code class='language-R'>stepAICmle.fun(ImlePP, covariatesAdd = NULL, startAdd = NULL, 
direction = "forward", ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stepAICmle.fun_+3A_imlepp">ImlePP</code></td>
<td>
<p>A <code><a href="#topic+mlePP-class">mlePP</a></code>-class object; usually the output from <code><a href="#topic+fitPP.fun">fitPP.fun</a></code>. 
It defines the initial model of the stepwise algorithm.  The fitted model cannot include fixed parameters.</p>
</td></tr>
<tr><td><code id="stepAICmle.fun_+3A_covariatesadd">covariatesAdd</code></td>
<td>
<p>Matrix   of the potential covariates to be added to the model; each column  must 
contain a covariate. In the 'forward'  and the 'both' directions, it is compulsory to assign a matrix to this argument.  
It is advisable to give names to the columns of 
this matrix (using <code><a href="base.html#topic+dimnames">dimnames</a></code>) since,   they will be used  in the output. 
Otherwise the default names 'New Covariate i' are used.</p>
</td></tr>
<tr><td><code id="stepAICmle.fun_+3A_startadd">startAdd</code></td>
<td>
<p>Optional. The vector of initial values  for the estimation  of  the coefficients 
of each potential covariate. If it  is NULL,  initial values  equal to 0 are used.</p>
</td></tr>
<tr><td><code id="stepAICmle.fun_+3A_direction">direction</code></td>
<td>
<p>Label indicating the direction of the algortihm: 'forward' (the default), 'backward' or 'both'.</p>
</td></tr>
<tr><td><code id="stepAICmle.fun_+3A_...">...</code></td>
<td>
<p>Further arguments to pass to <code><a href="#topic+addAIC.fun">addAIC.fun</a></code> and <code><a href="#topic+dropAIC.fun">dropAIC.fun</a></code>, 
for example the constant k for the AIC calculation</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Three directions, forward, backward and both, are implemented. The initial model is given by 
<code>ImlePP</code> and the algorithm stops 
when none of the covariates eliminated from the model 
or  added from the potential covariates set (argument <code>covariatesAdd</code> ) improves the model 
fitted in the  previous step, according to the AIC.  For the  'both'  and 'forward' directions, the argument <code>covariatesADD</code>
is compulsary, and the default NULL leads to an error.
</p>
<p>In the 'both' direction,   'forward' and 'backward' steps are carried out alternatively. In the 'forward' direction, 
the initial model usually contains only the intercept.
</p>


<h3>Value</h3>

<p>A <code><a href="#topic+mlePP-class">mlePP</a></code>-class object,  the fit of the final PP model selectecd by the algorithm.</p>


<h3>References</h3>

<p>Casella, G. and Berger, R.L., (2002). <em>Statistical inference.</em> Brooks/Cole.
</p>
<p>Cebrian, A.C., Abaurrea, J. and Asin, J. (2015). NHPoisson: An R Package for 
Fitting and Validating Nonhomogeneous Poisson Processes. 
<em>Journal of Statistical Software</em>, 64(6), 1-24.
</p>
<p>Venables, W. N. and Ripley, B. D. (2002). <em>Modern Applied Statistics with S.</em> Fourth edition. Springer.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+addAIC.fun">addAIC.fun</a></code>, <code><a href="#topic+dropAIC.fun">dropAIC.fun</a></code>, <code><a href="#topic+testlik.fun">testlik.fun</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>

data(BarTxTn)

BarEv&lt;-POTevents.fun(T=BarTxTn$Tx,thres=318, 
	date=cbind(BarTxTn$ano,BarTxTn$mes,BarTxTn$dia))

#The initial model contains only the inercept
 mod1Bind&lt;-fitPP.fun(covariates=NULL, posE=BarEv$Px, inddat=BarEv$inddat,
	tit='BAR  Intercept ', 	start=list(b0=1))
#the potential covariates
covB&lt;-cbind(cos(2*pi*BarTxTn$dia/365), sin(2*pi*BarTxTn$dia/365), 
	BarTxTn$TTx,BarTxTn$Txm31,BarTxTn$Txm31**2)
dimnames(covB)&lt;-list(NULL,c('cos','sin','TTx','Txm31', 'Txm31**2'))

bb&lt;-stepAICmle.fun(ImlePP=mod1Bind, covariates=covB, startAdd=c(1,-1,0,0,0), 
direction='both')

</code></pre>

<hr>
<h2 id='testlik.fun'>Likelihood ratio test to compare two nested models</h2><span id='topic+testlik.fun'></span>

<h3>Description</h3>

<p>This function performs a likelihood ratio test, a test to compare 
the fit of two models, where the first one (the null model ModR) is a particular case of the 
other (the alternative model ModG).</p>


<h3>Usage</h3>

<pre><code class='language-R'> testlik.fun(ModG, ModR) </code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="testlik.fun_+3A_modg">ModG</code></td>
<td>
<p>An object of class <code><a href="#topic+mlePP-class">mlePP-class</a></code>; usually,
the output  from <code><a href="#topic+fitPP.fun">fitPP.fun</a></code>.</p>
</td></tr>
<tr><td><code id="testlik.fun_+3A_modr">ModR</code></td>
<td>
<p>An object of class <code><a href="#topic+mlePP-class">mlePP-class</a></code>; usually,
the output  from <code><a href="#topic+fitPP.fun">fitPP.fun</a></code>.</p>
</td></tr></table>


<h3>Details</h3>

<p>The test statistic is twice the difference in the log-likelihoods 
of the models.
Under the null, the  statistic follows a <code class="reqn">\chi^2</code> distribution with degrees 
of freedom df2-df1,the number of parameters of modG and modR respectively.</p>


<h3>Value</h3>

<p> A list with elements
</p>
<table>
<tr><td><code>pv</code></td>
<td>
<p>P-value of the likelihood ratio test.</p>
</td></tr>
<tr><td><code>ModG</code></td>
<td>
<p>Input argument.</p>
</td></tr>
<tr><td><code>ModR</code></td>
<td>
<p>Input argument.</p>
</td></tr> </table>


<h3>References</h3>

<p>Casella, G. and Berger, R.L., (2002). <em>Statistical inference.</em> Brooks/Cole.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+fitPP.fun">fitPP.fun</a></code>,<code><a href="#topic+LRTpv.fun">LRTpv.fun</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
##The alternative model modB is specified  by the output fitPP.fun
##The null model modBR is specified  by a list with elments llik and npar


data(BarTxTn)

covB&lt;-cbind(cos(2*pi*BarTxTn$dia/365), sin(2*pi*BarTxTn$dia/365), 
	BarTxTn$TTx,BarTxTn$Txm31,BarTxTn$Txm31**2)


modB&lt;-fitPP.fun(tind=TRUE,covariates=covB, 
	POTob=list(T=BarTxTn$Tx, thres=318),
	tim=c(1:8415), tit="BAR Tx; cos, sin, TTx, Txm31, Txm31**2", 
	start=list(b0=-100,b1=1,b2=10,b3=0,b4=0,b5=0),dplot=FALSE,modCI=TRUE,	modSim=TRUE)



modBR&lt;-fitPP.fun(tind=TRUE,covariates=covB[,1:4], 
	POTob=list(T=BarTxTn$Tx, thres=318),
	tim=c(1:8415), tit="BAR Tx; cos, sin, TTx, Txm31", 
	start=list(b0=-100,b1=1,b2=10,b3=0,b4=0),dplot=FALSE,modCI=TRUE,	modSim=TRUE)


aux&lt;-testlik.fun(ModG=modB,ModR=modBR)


</code></pre>

<hr>
<h2 id='transfH.fun'>Transform  a NHPP into a HPP</h2><span id='topic+transfH.fun'></span>

<h3>Description</h3>

<p>This function transforms the  points <code class="reqn">t^{NH}_i</code> of a NHPP into 
the occurrence points  
<code class="reqn">t^{H}_i</code> of a HPP  of rate 1.</p>


<h3>Usage</h3>

<pre><code class='language-R'>transfH.fun(mlePP)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="transfH.fun_+3A_mlepp">mlePP</code></td>
<td>
<p>An object of class <code><a href="#topic+mlePP-class">mlePP-class</a></code>; usually,
the output  from <code><a href="#topic+fitPP.fun">fitPP.fun</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Transformation of the NHPP points <code class="reqn">t^{NH}_i</code>  into 
the HPP points <code class="reqn">t^{H}_i</code>  is based on
the time scale transformation,  
</p>
<p style="text-align: center;"><code class="reqn">t^H_i=\int_0^{t^{NH}_i}\lambda(t)dt.</code>
</p>

<p>(usually the estimated value <code class="reqn">\hat \lambda(t)</code> is used in the transformation.)</p>


<h3>Value</h3>

<p>A list with elements
</p>
<table>
<tr><td><code>posEH</code></td>
<td>
<p>Numeric vector of the transformed occurrence times 
of the HPP.</p>
</td></tr>
<tr><td><code>posE</code></td>
<td>
<p>Slot of the  input argument mlePP.</p>
</td></tr>
<tr><td><code>lambdafit</code></td>
<td>
<p>Slot of the  input argument mlePP.</p>
</td></tr>
<tr><td><code>inddat</code></td>
<td>
<p>Slot of the  input argument mlePP.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Cebrian, A.C., Abaurrea, J. and Asin, J. (2015). NHPoisson: An R Package for 
Fitting and Validating Nonhomogeneous Poisson Processes. 
<em>Journal of Statistical Software</em>, 64(6), 1-24.
</p>
<p>Cox, D.R., Isham, V., 1980. <em>Point Processes</em>. Chapman and Hall.
</p>
<p>Daley, D. and D. Vere-Jones (2003). 
<em>An Introduction to the Theory of Point Processes</em>. Springer.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+simNHP.fun">simNHP.fun</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
X1&lt;-rnorm(500)
X2&lt;-rnorm(500)
auxmlePP&lt;-fitPP.fun(posE=round(runif(50,1,500)), inddat=rep(1,500),
	covariates=cbind(X1,X2),start=list(b0=1,b1=0,b2=0))


posEH&lt;-transfH.fun(auxmlePP)
</code></pre>

<hr>
<h2 id='unifres.fun'>Calculate exponential and uniform (generalized) residuals of a HPP</h2><span id='topic+unifres.fun'></span>

<h3>Description</h3>

<p>This function calculates the exponential <code class="reqn">d_i</code> and the uniform (generalized)
residuals <code class="reqn">u_i</code> of a 
HPP, using the occurrence points <code class="reqn">t_i</code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>unifres.fun(posEH)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unifres.fun_+3A_poseh">posEH</code></td>
<td>
<p>Numeric vector, the occurrence points of a HPP.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The exponential residuals of a HPP are defined as the inter-event distances
<code class="reqn">d_i=t_i-t_{i-1}</code>, that are an i.i.d. exponential sample. The series
<code class="reqn">d_i</code> is  an example of the generalized residuals proposed by Cox and Snell (1968).
The uniform residuals, defined as the function  <code class="reqn">\exp(-d_i)</code>
of the exponential residuals, are an i.i.d. uniform sample, see Ogata (1988).</p>


<h3>Value</h3>

<p>A list with elements
</p>
<table>
<tr><td><code>expres</code></td>
<td>
<p>Numeric vector of the exponential residuals.</p>
</td></tr>
<tr><td><code>unires</code></td>
<td>
<p>Numeric vector of the uniform residuals.</p>
</td></tr>
<tr><td><code>posEH</code></td>
<td>
<p>Input argument.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Abaurrea, J., Asin, J., Cebrian, A.C. and Centelles, A.
(2007). Modeling and forecasting extreme heat events in the central
Ebro valley, a continental-Mediterranean area. <em>Global and
Planetary Change</em>, 57(1-2), 43-58.
</p>
<p>Cebrian, A.C., Abaurrea, J. and Asin, J. (2015). NHPoisson: An R Package for 
Fitting and Validating Nonhomogeneous Poisson Processes. 
<em>Journal of Statistical Software</em>, 64(6), 1-24.
</p>
<p>Cox, D. R. and Snell, E. J. (1968). A general definition of residuals.
<em>Journal of  the Royal Statistical Society, series B</em>, 30(2), 248-275.
83(401), 9-27.
</p>
<p>Ogata, Y. (1988). Statistical models for earthquake occurrences and residual
analysis for point processes.<em>Journal of  the American Statistical Association</em>,
83(401), 9-27.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+transfH.fun">transfH.fun</a></code>, <code><a href="#topic+graphresU.fun">graphresU.fun</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## generates the occurrence times of a homogeneours PP with  constant intensity 0.01 
## and calculates de residuals

aux&lt;-simNHP.fun(lambda=rep(0.01,1000))

res&lt;-unifres.fun(aux$posNH)
</code></pre>

<hr>
<h2 id='VARbeta.fun'>Calculate the covariance matrix of the <code class="reqn">\hat \beta</code> vector.</h2><span id='topic+VARbeta.fun'></span>

<h3>Description</h3>

<p>This function estimates  the covariance matrix of the ML estimators of the  
<code class="reqn">\beta</code> parameters, using the asymptotic distribution and properties of the ML estimators.</p>


<h3>Usage</h3>

<pre><code class='language-R'>VARbeta.fun(covariates, lambdafit)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="VARbeta.fun_+3A_covariates">covariates</code></td>
<td>
<p>Matrix of covariates (each column is a covariate).</p>
</td></tr>
<tr><td><code id="VARbeta.fun_+3A_lambdafit">lambdafit</code></td>
<td>
<p>Numeric vector, the fitted PP intensity <code class="reqn">\hat \lambda(t)</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The covariance matrix is calculated as the inverse of the  negative of the hessian matrix. The inverse of the matrix
is calculated using the  solve function. If this function  leads to an error in the calculation, the
inverse is calculated via its Cholesky decomposition. If this option also fails, 
the covariance matrix is not estimated and a  matrix  of dimension <code class="reqn">0 \times 0</code> is returned. </p>


<h3>Value</h3>

<table>
<tr><td><code>VARbeta</code></td>
<td>
<p>Coariance matrix of the <code class="reqn">\hat \beta</code> vector.  It has
an attribute, called 'CalMethod' which shows the method  used to calculate the  inverse of the matrix: 
'Solve function', 'Cholesky' or 'Not possible'.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>The function <code><a href="#topic+fitPP.fun">fitPP.fun</a></code> calls this function.</p>


<h3>References</h3>

<p>Casella, G. and Berger, R.L., (2002). <em>Statistical inference.</em> Brooks/Cole.
</p>
<p>Cebrian, A.C., Abaurrea, J. and Asin, J. (2015). NHPoisson: An R Package for 
Fitting and Validating Nonhomogeneous Poisson Processes. 
<em>Journal of Statistical Software</em>, 64(6), 1-24.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+CItran.fun">CItran.fun</a></code>, <code><a href="#topic+CIdelta.fun">CIdelta.fun</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
lambdafit&lt;-runif(100,0,1)
X&lt;-cbind(rep(1,100),rnorm(100),rnorm(100))

aux&lt;-VARbeta.fun(covariates=X, lambdafit=lambdafit)


</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
