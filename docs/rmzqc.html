<!DOCTYPE html><html><head><title>Help for package rmzqc</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {rmzqc}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#rmzqc-package'><p>rmzqc: Creation, Reading and Validation of 'mzqc' Files</p></a></li>
<li><a href='#check_type'><p>Checks the value's class type, which should match at least of the types given in</p>
any_expected_class_types.</a></li>
<li><a href='#CV_'><p>CV_</p></a></li>
<li><a href='#filenameToCV'><p>For a given filename (e.g. &quot;test.mzML&quot;), check the suffix and translate it to an PSI-MS CV term, e.g. 'MS:1000584'</p></a></li>
<li><a href='#fromDatatoMzQC'><p>Allow conversion of plain named lists of R objects (from jSON) to mzQC objects</p></a></li>
<li><a href='#fromDatatoMzQCobj'><p>Allow conversion of a plain R object (obtained from jSON) to an mzQC object</p></a></li>
<li><a href='#getCVDictionary'><p>Fetch and parse the 'psi-ms.obo' and some metadata from the usual sources to use as ontology.</p></a></li>
<li><a href='#getCVInfo'><p>Returns an MzQCcontrolledVocabulary for the currently used CV (see <code>getCVSingleton</code>)</p></a></li>
<li><a href='#getCVSingleton'><p>Returns the CV singleton. See <code>CV_</code>.</p></a></li>
<li><a href='#getCVTemplate'><p>Fills a MzQCcvParameter object with id(accession) and name.</p>
The value (if any) needs to be set afterwards.</a></li>
<li><a href='#getDefaultCV'><p>Returns an MzQCcontrolledVocabulary for the currently used CV (see <code>getCVSingleton</code>)</p></a></li>
<li><a href='#getLatest_PSICV_URL'><p>Get the latest PSI-MS CV release URL</p></a></li>
<li><a href='#getLocal_CV_Version'><p>Obtains the 'data-version' from a local (i.e. non-url) PSI-MS-CV</p></a></li>
<li><a href='#getQualityMetricTemplate'><p>Fills a MzQCqualityMetric object with id(accession) and name.</p>
The value (if any) and unit (if any) need to be set afterwards.</a></li>
<li><a href='#getSyntaxValidator'><p>Get a syntax validator for mzQC</p></a></li>
<li><a href='#hasFileSuffix'><p>Checks if filepath ends in suffix (ignoring lower/upper case differences). If suffix does not start with a '.' it is prepended automatically.</p></a></li>
<li><a href='#isUndefined'><p>Tell if a string is undefined (NA or NULL); If yes, and its required by the mzQC standard,</p>
we can raise an error.</a></li>
<li><a href='#isValidMzQC'><p>Checks validity (= completeness) of mzQC objects - or lists (JSON arrays) thereof</p></a></li>
<li><a href='#localFileToURI'><p>Convert a local filename, e.g. &quot;./myData/test.mzML&quot; to a proper URI (e.g. &quot;file:///user/bielow/myData/test.mzML&quot;)</p></a></li>
<li><a href='#MzQCanalysisSoftware-class'><p>Details of the software used to create the QC metrics</p></a></li>
<li><a href='#MzQCbaseQuality-class'><p>Base class of runQuality/setQuality</p></a></li>
<li><a href='#MzQCcontrolledVocabulary-class'><p>A controlled vocabulary document, usually pointing to an .obo file</p></a></li>
<li><a href='#MzQCcvParameter-class'><p>A controlled vocabulary parameter, as detailed in the OBO file</p></a></li>
<li><a href='#MzQCDateTime-class'><p>An mzQC-formatted date+time in ISO8601 format, as required by the mzQC spec doc.</p></a></li>
<li><a href='#MzQCinputFile-class'><p>An inputfile within metadata for a run/setQuality</p></a></li>
<li><a href='#MzQCmetadata-class'><p>The metadata for a run/setQuality</p></a></li>
<li><a href='#MzQCmzQC-class'><p>Root element of an mzQC document</p></a></li>
<li><a href='#MzQCqualityMetric-class'><p>The central class to store QC information</p></a></li>
<li><a href='#MzQCrunQuality-class'><p>A runQuality object. Use to report metrics for individual runs which are independent of other runs.</p></a></li>
<li><a href='#MzQCsetQuality-class'><p>A setQuality object. Use it for metrics which are specific to sets, i.e. only for values which</p>
only make sense in the set context and cannot be stored as runQuality (see mzQC spec doc).</a></li>
<li><a href='#NULL_to_charNA'><p>Converts a NULL to NA_character_; or returns the argument unchanged otherwise</p></a></li>
<li><a href='#NULL_to_NA'><p>Converts a NULL to NA; or returns the argument unchanged otherwise</p></a></li>
<li><a href='#parseOBO'><p>Get the information of each CV term from an obo file.</p></a></li>
<li><a href='#readMZQC'><p>Read a JSON file in mzQC format into an MzQCmzQC root object</p></a></li>
<li><a href='#removeFileSuffix'><p>Removes the last suffix (including the last dot) from a filename.</p>
If no dot exists, the full string is returned.</a></li>
<li><a href='#removeIfExists'><p>Remove a file, if it exists (useful for temporary files which may or may not have been created)</p></a></li>
<li><a href='#toAnalysisSoftware'><p>From an ID, e.g. &quot;MS:1003162&quot; (for PTX-QC), and some additional information,</p>
create an 'analysisSoftware' node for mzQC</a></li>
<li><a href='#toQCMetric'><p>Create an 'MzQCqualityMetric' object from two inputs</p></a></li>
<li><a href='#validateFromFile'><p>Syntactically validates an mzQC document which is present as a file.</p></a></li>
<li><a href='#validateFromObj'><p>Syntactically validates an mzQC document which is already in memory as mzQC root object, as obtained by, e.g. readMZQC().</p></a></li>
<li><a href='#validateFromString'><p>Syntactically validates an mzQC document which is already in memory as JSON string.</p>
e.g. the string &quot; mzQC : &quot;</a></li>
<li><a href='#writeMZQC'><p>Writes a full mzQC object to disk.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Creation, Reading and Validation of 'mzqc' Files</td>
</tr>
<tr>
<td>Version:</td>
<td>0.5.3</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-08-24</td>
</tr>
<tr>
<td>Description:</td>
<td>Reads, writes and validates 'mzQC' files. The 'mzQC' format is a 
  standardized file format for the exchange, transmission, and archiving of 
  quality metrics derived from biological mass spectrometry data, as defined 
  by the HUPO-PSI (Human Proteome Organisation - Proteomics Standards Initiative) 
  Quality Control working group. 
  See <a href="https://hupo-psi.github.io/mzQC/">https://hupo-psi.github.io/mzQC/</a> for details.</td>
</tr>
<tr>
<td>Imports:</td>
<td>jsonlite, jsonvalidate, knitr, methods, ontologyIndex,
rmarkdown, R6, R6P, testthat, tools</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/MS-Quality-hub/rmzqc">https://github.com/MS-Quality-hub/rmzqc</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/MS-Quality-hub/rmzqc/issues">https://github.com/MS-Quality-hub/rmzqc/issues</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-08-25 12:34:25 UTC; bielow</td>
</tr>
<tr>
<td>Author:</td>
<td>Chris Bielow <a href="https://orcid.org/0000-0001-5756-3988"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  David Jimenez-Morales
    <a href="https://orcid.org/0000-0003-4356-6461"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [rev, ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Chris Bielow &lt;chris.bielow@bsc.fu-berlin.de&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-08-25 13:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='rmzqc-package'>rmzqc: Creation, Reading and Validation of 'mzqc' Files</h2><span id='topic+rmzqc'></span><span id='topic+rmzqc-package'></span>

<h3>Description</h3>

<p>Reads, writes and validates 'mzQC' files. The 'mzQC' format is a standardized file format for the exchange, transmission, and archiving of quality metrics derived from biological mass spectrometry data, as defined by the HUPO-PSI (Human Proteome Organisation - Proteomics Standards Initiative) Quality Control working group. See <a href="https://hupo-psi.github.io/mzQC/">https://hupo-psi.github.io/mzQC/</a> for details.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Chris Bielow <a href="mailto:chris.bielow@bsc.fu-berlin.de">chris.bielow@bsc.fu-berlin.de</a> (<a href="https://orcid.org/0000-0001-5756-3988">ORCID</a>)
</p>
<p>Other contributors:
</p>

<ul>
<li><p> David Jimenez-Morales <a href="mailto:biodavidjm@gmail.com">biodavidjm@gmail.com</a> (<a href="https://orcid.org/0000-0003-4356-6461">ORCID</a>) [reviewer, contributor]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/MS-Quality-hub/rmzqc">https://github.com/MS-Quality-hub/rmzqc</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/MS-Quality-hub/rmzqc/issues">https://github.com/MS-Quality-hub/rmzqc/issues</a>
</p>
</li></ul>


<hr>
<h2 id='check_type'>Checks the value's class type, which should match at least of the types given in
any_expected_class_types.</h2><span id='topic+check_type'></span>

<h3>Description</h3>

<p>Checks the value's class type, which should match at least of the types given in
any_expected_class_types.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_type(value, any_expected_class_types, expected_length = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_type_+3A_value">value</code></td>
<td>
<p>A certain value (e.g. a single value, data.frame etc)</p>
</td></tr>
<tr><td><code id="check_type_+3A_any_expected_class_types">any_expected_class_types</code></td>
<td>
<p>A vector of valid class types, any of which the @p value should have</p>
</td></tr>
<tr><td><code id="check_type_+3A_expected_length">expected_length</code></td>
<td>
<p>The expected length of value (usually to check if its a single value); 0 (default) indicates that length can be ignored</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>  check_type(1, "numeric", 1)   # TRUE
  check_type("1", "numeric", 1) # FALSE
  check_type(1, "numeric", 2)   # FALSE
  check_type("ABC", "character", 1)             # TRUE
  check_type("ABC", "character")                # TRUE
  check_type("ABC", "character", 2)             # FALSE
  check_type(c("ABC", "DEF"), "character", 2)   # TRUE
  check_type(1.1, c("numeric", "double"))    # TRUE
  check_type(1.1, c("numeric", "double"), 1) # TRUE
  check_type(matrix(1:9, nrow=3), "matrix")   # TRUE
  check_type(data.frame(a=1:3, b=4:6), c("something", "data.frame"))   # TRUE

</code></pre>

<hr>
<h2 id='CV_'>CV_</h2><span id='topic+CV_'></span>

<h3>Description</h3>

<p>Define a Singleton class which can hold a CV dictionary (so we do not have to load the .obo files over and over again)
</p>


<h3>Details</h3>

<p>Get the full data by calling the 'getData()' function (which returns a list containing a 'CV', 'URI' and 'version'),
or 'getCV()' which is a shorthand for 'getData()$CV'.
You can set your own custom CV by calling 'setData()'. By default, the latest release of the PSI-MS-CV (see <code><a href="#topic+getCVDictionary">getCVDictionary</a></code>).
Wherever you need this data, simply re-grab the singleton using 'CV_$new()' (or use the convenience function getCVSingleton() from outside the package)
</p>


<h3>Super class</h3>

<p><code><a href="R6P.html#topic+Singleton">R6P::Singleton</a></code> -&gt; <code>CV_</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-CV_-ensureHasData"><code>CV_$ensureHasData()</code></a>
</p>
</li>
<li> <p><a href="#method-CV_-byID"><code>CV_$byID()</code></a>
</p>
</li>
<li> <p><a href="#method-CV_-setData"><code>CV_$setData()</code></a>
</p>
</li>
<li> <p><a href="#method-CV_-getData"><code>CV_$getData()</code></a>
</p>
</li>
<li> <p><a href="#method-CV_-getCV"><code>CV_$getCV()</code></a>
</p>
</li>
<li> <p><a href="#method-CV_-clone"><code>CV_$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="R6P" data-topic="Singleton" data-id="initialize"><a href='../../R6P/html/Singleton.html#method-Singleton-initialize'><code>R6P::Singleton$initialize()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-CV_-ensureHasData"></a>



<h4>Method <code>ensureHasData()</code></h4>

<p>Make sure that the CV data is loaded
</p>


<h5>Usage</h5>

<div class="r"><pre>CV_$ensureHasData()</pre></div>


<hr>
<a id="method-CV_-byID"></a>



<h4>Method <code>byID()</code></h4>

<p>A function to retrieve a CV entry using its ID
</p>


<h5>Usage</h5>

<div class="r"><pre>CV_$byID(id)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>id</code></dt><dd><p>A CV accession, e.g. 'MS:1000560'</p>
</dd>
</dl>

</div>


<hr>
<a id="method-CV_-setData"></a>



<h4>Method <code>setData()</code></h4>

<p>Set a user-defined object (= a list of 'CV', 'URI' and 'version'), as obtained from <code><a href="#topic+getCVDictionary">getCVDictionary</a></code>
</p>


<h5>Usage</h5>

<div class="r"><pre>CV_$setData(cv_data)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>cv_data</code></dt><dd><p>The result of a call to <code><a href="#topic+getCVDictionary">getCVDictionary</a></code></p>
</dd>
</dl>

</div>


<hr>
<a id="method-CV_-getData"></a>



<h4>Method <code>getData()</code></h4>

<p>Gets the underlying data (CV, URI and version)
</p>


<h5>Usage</h5>

<div class="r"><pre>CV_$getData()</pre></div>


<hr>
<a id="method-CV_-getCV"></a>



<h4>Method <code>getCV()</code></h4>

<p>A shorthand for 'getData()$CV', i.e. the CV data.frame.
</p>


<h5>Usage</h5>

<div class="r"><pre>CV_$getCV()</pre></div>


<hr>
<a id="method-CV_-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>CV_$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
  cv_dict = CV_$new() ## uses 'getCVDictionary()' to populate the singleton
  cv_2 = CV_$new() ## uses the same data without parsing again
  cv_2$setData(getCVDictionary("custom", "https://my.com/custom.obo"))

## End(Not run)

</code></pre>

<hr>
<h2 id='filenameToCV'>For a given filename (e.g. &quot;test.mzML&quot;), check the suffix and translate it to an PSI-MS CV term, e.g. 'MS:1000584'</h2><span id='topic+filenameToCV'></span>

<h3>Description</h3>

<p>The following mapping is currently known:
.raw    : MS:1000563 ! Thermo RAW format
.mzML   : MS:1000584 ! mzML format
.mzData : MS:1000564 ! PSI mzData format
.wiff   : MS:1000562 ! ABI WIFF format
.pkl    : MS:1000565 ! Micromass PKL format
.mzXML  : MS:1000566 ! ISB mzXML format
.yep    : MS:1000567 ! Bruker/Agilent YEP format
.dta    : MS:1000613 ! Sequest DTA format
.mzMLb  : MS:1002838 ! mzMLb format
</p>


<h3>Usage</h3>

<pre><code class='language-R'>filenameToCV(filepath)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="filenameToCV_+3A_filepath">filepath</code></td>
<td>
<p>A filename (with optional path)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Falls back to 'MS:1000560 ! mass spectrometer file format' if no match could be found.
</p>
<p>Upper/lowercase is ignored, i.e. &quot;mzML == mzml&quot;.
</p>


<h3>Value</h3>

<p>A CV term accession as string, e.g. 'MS:1000584'
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  filenameToCV("test.mZmL")  # MS:1000584
  filenameToCV("test.raw")  # MS:1000563
  filenameToCV(c("test.raw", "bla.mzML"))

</code></pre>

<hr>
<h2 id='fromDatatoMzQC'>Allow conversion of plain named lists of R objects (from jSON) to mzQC objects</h2><span id='topic+fromDatatoMzQC'></span>

<h3>Description</h3>

<p>Allow conversion of plain named lists of R objects (from jSON) to mzQC objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fromDatatoMzQC(mzqc_class, data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fromDatatoMzQC_+3A_mzqc_class">mzqc_class</code></td>
<td>
<p>Prototype of the class to convert 'data' into</p>
</td></tr>
<tr><td><code id="fromDatatoMzQC_+3A_data">data</code></td>
<td>
<p>A list of: A datastructure of R lists/arrays as obtained by 'jsonlite::fromJSON()'</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>    data = rmzqc::MzQCcvParameter$new("acc", "myName", "value")
    data_recovered = rmzqc::fromDatatoMzQC(rmzqc::MzQCcvParameter,
                         list(jsonlite::fromJSON(jsonlite::toJSON(data))))

</code></pre>

<hr>
<h2 id='fromDatatoMzQCobj'>Allow conversion of a plain R object (obtained from jSON) to an mzQC object</h2><span id='topic+fromDatatoMzQCobj'></span>

<h3>Description</h3>

<p>If you have a list of elements, call fromDatatoMzQC.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fromDatatoMzQCobj(mzqc_class, data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fromDatatoMzQCobj_+3A_mzqc_class">mzqc_class</code></td>
<td>
<p>Prototype of the class to convert 'data' into</p>
</td></tr>
<tr><td><code id="fromDatatoMzQCobj_+3A_data">data</code></td>
<td>
<p>A datastructure of R lists/arrays as obtained by 'jsonlite::fromJSON()'</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'> data = MzQCcvParameter$new("acc", "myName", "value")
 data_recovered = fromDatatoMzQCobj(MzQCcvParameter, jsonlite::fromJSON(jsonlite::toJSON(data)))
 data_recovered

</code></pre>

<hr>
<h2 id='getCVDictionary'>Fetch and parse the 'psi-ms.obo' and some metadata from the usual sources to use as ontology.</h2><span id='topic+getCVDictionary'></span>

<h3>Description</h3>

<p>A 'pato.obo', and 'uo.obo' from the 'rmzqc/cv/' folder are automatically merged in as well.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getCVDictionary(
  source = c("latest", "local", "custom"),
  custom_uri = NULL,
  use_local_fallback = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getCVDictionary_+3A_source">source</code></td>
<td>
<p>Where to get the PSI-MS CV from:
- 'latest' will download 'psi-ms.obo' from https://api.github.com/repos/HUPO-PSI/psi-ms-CV/releases/latest
- 'local' will use rmzqc/cv/psi-ms.obo' (which might be outdated, if you need the latest terms)
- 'custom' uses a user-defined URI in 'custom_uri'</p>
</td></tr>
<tr><td><code id="getCVDictionary_+3A_custom_uri">custom_uri</code></td>
<td>
<p>Used when 'source' is set to 'custom'. The URI can be local or remote, e.g. 'c:/obo/my.obo' or 'https://www.abc.com/my.obo'</p>
</td></tr>
<tr><td><code id="getCVDictionary_+3A_use_local_fallback">use_local_fallback</code></td>
<td>
<p>When downloading a file from a URI fails, should we fall back to the local psi-ms.obo shipped with rmzqc?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See CV_ class to use this function efficiently.
</p>


<h3>Value</h3>

<p>A list with 'CV', 'URI' and 'version', where 'CV' is a data.frame with columns 'id', 'name', 'def', 'parents', 'children' (and many more) which contains the CV entries
</p>

<hr>
<h2 id='getCVInfo'>Returns an MzQCcontrolledVocabulary for the currently used CV (see <code><a href="#topic+getCVSingleton">getCVSingleton</a></code>)</h2><span id='topic+getCVInfo'></span>

<h3>Description</h3>

<p>Returns an MzQCcontrolledVocabulary for the currently used CV (see <code><a href="#topic+getCVSingleton">getCVSingleton</a></code>)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getCVInfo()
</code></pre>

<hr>
<h2 id='getCVSingleton'>Returns the CV singleton. See <code><a href="#topic+CV_">CV_</a></code>.</h2><span id='topic+getCVSingleton'></span>

<h3>Description</h3>

<p>Returns the CV singleton. See <code><a href="#topic+CV_">CV_</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getCVSingleton()
</code></pre>

<hr>
<h2 id='getCVTemplate'>Fills a MzQCcvParameter object with id(accession) and name.
The value (if any) needs to be set afterwards.</h2><span id='topic+getCVTemplate'></span>

<h3>Description</h3>

<p>Fills a MzQCcvParameter object with id(accession) and name.
The value (if any) needs to be set afterwards.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getCVTemplate(accession, CV = getCVSingleton())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getCVTemplate_+3A_accession">accession</code></td>
<td>
<p>The ID (=accession) of the term in the CV</p>
</td></tr>
<tr><td><code id="getCVTemplate_+3A_cv">CV</code></td>
<td>
<p>A CV dictionary, as obtained by getCVDictionary(); defaults to the global singleton, which is populated automatically</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An instance of MzQCcvParameter
</p>

<hr>
<h2 id='getDefaultCV'>Returns an MzQCcontrolledVocabulary for the currently used CV (see <code><a href="#topic+getCVSingleton">getCVSingleton</a></code>)</h2><span id='topic+getDefaultCV'></span>

<h3>Description</h3>

<p>Returns an MzQCcontrolledVocabulary for the currently used CV (see <code><a href="#topic+getCVSingleton">getCVSingleton</a></code>)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getDefaultCV()
</code></pre>


<h3>Note</h3>

<p>This function will be deprecated soon. Use <code><a href="#topic+getCVInfo">getCVInfo</a></code> instead.
</p>

<hr>
<h2 id='getLatest_PSICV_URL'>Get the latest PSI-MS CV release URL</h2><span id='topic+getLatest_PSICV_URL'></span>

<h3>Description</h3>

<p>This may fail (e.g. if no internet connection is available) will return NULL instead of an URL.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getLatest_PSICV_URL()
</code></pre>

<hr>
<h2 id='getLocal_CV_Version'>Obtains the 'data-version' from a local (i.e. non-url) PSI-MS-CV</h2><span id='topic+getLocal_CV_Version'></span>

<h3>Description</h3>

<p>Obtains the 'data-version' from a local (i.e. non-url) PSI-MS-CV
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getLocal_CV_Version(local_PSIMS_obo_file)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getLocal_CV_Version_+3A_local_psims_obo_file">local_PSIMS_obo_file</code></td>
<td>
<p>A path to a local file, e.g. 'c:/temp/my.obo'</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'> getLocal_CV_Version(system.file("./cv/psi-ms.obo", package="rmzqc")) # "4.1.95"

</code></pre>

<hr>
<h2 id='getQualityMetricTemplate'>Fills a MzQCqualityMetric object with id(accession) and name.
The value (if any) and unit (if any) need to be set afterwards.</h2><span id='topic+getQualityMetricTemplate'></span>

<h3>Description</h3>

<p>Fills a MzQCqualityMetric object with id(accession) and name.
The value (if any) and unit (if any) need to be set afterwards.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getQualityMetricTemplate(accession, CV = getCVSingleton())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getQualityMetricTemplate_+3A_accession">accession</code></td>
<td>
<p>The ID (=accession) of the term in the CV</p>
</td></tr>
<tr><td><code id="getQualityMetricTemplate_+3A_cv">CV</code></td>
<td>
<p>A CV dictionary, as obtained by getCVDictionary(); defaults to the global singleton, which is populated automatically</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An instance of MzQCqualityMetric
</p>

<hr>
<h2 id='getSyntaxValidator'>Get a syntax validator for mzQC</h2><span id='topic+getSyntaxValidator'></span>

<h3>Description</h3>

<p>Get a syntax validator for mzQC
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getSyntaxValidator()
</code></pre>

<hr>
<h2 id='hasFileSuffix'>Checks if filepath ends in suffix (ignoring lower/upper case differences). If suffix does not start with a '.' it is prepended automatically.</h2><span id='topic+hasFileSuffix'></span>

<h3>Description</h3>

<p>Checks if filepath ends in suffix (ignoring lower/upper case differences). If suffix does not start with a '.' it is prepended automatically.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hasFileSuffix(filepath, suffix)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hasFileSuffix_+3A_filepath">filepath</code></td>
<td>
<p>A relative or absolute path to a file, whose suffix is checked</p>
</td></tr>
<tr><td><code id="hasFileSuffix_+3A_suffix">suffix</code></td>
<td>
<p>This is the suffix we expect (the '.' is prepended internally if missing)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>TRUE if yes, FALSE otherwise
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  hasFileSuffix("bla.txt", "txt")    # TRUE
  hasFileSuffix("bla.txt", ".txt")   # TRUE
  hasFileSuffix("bla.txt", ".TXT")   # TRUE
  hasFileSuffix("foo", "")           # TRUE
  hasFileSuffix("", "")              # TRUE
  hasFileSuffix("bla.txt", "doc")    # FALSE
  hasFileSuffix("bla.txt", ".doc")   # FALSE
  hasFileSuffix("fo", ".doc")        # FALSE
  hasFileSuffix("", ".doc")          # FALSE

</code></pre>

<hr>
<h2 id='isUndefined'>Tell if a string is undefined (NA or NULL); If yes, and its required by the mzQC standard,
we can raise an error.</h2><span id='topic+isUndefined'></span>

<h3>Description</h3>

<p>You can pass multiple strings, which are all checked.
If <strong>any</strong> of them is undefined, the function returns TRUE
</p>


<h3>Usage</h3>

<pre><code class='language-R'>isUndefined(s, ..., verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="isUndefined_+3A_s">s</code></td>
<td>
<p>A string to be checked for NA/NULL</p>
</td></tr>
<tr><td><code id="isUndefined_+3A_...">...</code></td>
<td>
<p>More strings to be checked</p>
</td></tr>
<tr><td><code id="isUndefined_+3A_verbose">verbose</code></td>
<td>
<p>If TRUE and 's' is NULL/NA, will print the name of the variable which was passed in</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>isUndefined(NA)       ## TRUE
isUndefined(NULL)     ## TRUE
isUndefined(NA, NULL) ## TRUE
isUndefined("")       ## FALSE
isUndefined("", NA)   ## TRUE
isUndefined(NA, "")   ## TRUE
isUndefined(1)        ## FALSE
myVar = NA
isUndefined(myVar)    ## TRUE, with warning "Variable 'myVar' is NA/NULL!"

</code></pre>

<hr>
<h2 id='isValidMzQC'>Checks validity (= completeness) of mzQC objects - or lists (JSON arrays) thereof</h2><span id='topic+isValidMzQC'></span>

<h3>Description</h3>

<p>Note: Returns TRUE for empty lists!
</p>


<h3>Usage</h3>

<pre><code class='language-R'>isValidMzQC(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="isValidMzQC_+3A_x">x</code></td>
<td>
<p>An mzQC refclass (or list of them), each will be subjected to <code>isValidMzQC()</code></p>
</td></tr>
<tr><td><code id="isValidMzQC_+3A_...">...</code></td>
<td>
<p>Ellipsis, for recursive argument splitting</p>
</td></tr>
</table>


<h3>Details</h3>

<p>You can pass multiple arguments, which are all checked individually.
All of them need to be valid, for TRUE to be returned.
The reason for combining both list support for arguments and ellipsis (...) into this function is that
JSON arrays are represented as lists and you can simply pass them as a single argument
(without the need for do.call()) and get the indices of invalid objects (if any).
The ellipsis is useful to avoid clutter,
i.e.
if (!isValidMzQC(a) || !isValidMzQC(b)) doStuff()
is harder to read than
if (!isValidMzQC(a,b)) doStuff()
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  isValidMzQC(MzQCcvParameter$new("MS:4000059"))       # FALSE
  isValidMzQC(MzQCcvParameter$new("MS:4000059", "Number of MS1 spectra")) # TRUE
  isValidMzQC(list(MzQCcvParameter$new("MS:4000059"))) # FALSE
  isValidMzQC(list(MzQCcvParameter$new("MS:4000059", "Number of MS1 spectra"))) # TRUE
  isValidMzQC(list(MzQCcvParameter$new("MS:4000059", "Number of MS1 spectra")),
              MzQCcvParameter$new()) # FALSE

</code></pre>

<hr>
<h2 id='localFileToURI'>Convert a local filename, e.g. &quot;./myData/test.mzML&quot; to a proper URI (e.g. &quot;file:///user/bielow/myData/test.mzML&quot;)</h2><span id='topic+localFileToURI'></span>

<h3>Description</h3>

<p>Relative filenames are made absolute.
Backslashes as path separators are replaced by forward slashes (as commonly seen on Windows).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>localFileToURI(local_filename, must_exist = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="localFileToURI_+3A_local_filename">local_filename</code></td>
<td>
<p>Path to a file (can be relative to current getwd(); or absolute)</p>
</td></tr>
<tr><td><code id="localFileToURI_+3A_must_exist">must_exist</code></td>
<td>
<p>Require the file to exist</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A URI starting with &quot;file:///&quot; followed by an absolute path
</p>

<hr>
<h2 id='MzQCanalysisSoftware-class'>Details of the software used to create the QC metrics</h2><span id='topic+MzQCanalysisSoftware-class'></span><span id='topic+MzQCanalysisSoftware'></span>

<h3>Description</h3>

<p>Details of the software used to create the QC metrics
</p>


<h3>Fields</h3>


<dl>
<dt><code>accession</code></dt><dd><p>Accession number identifying the term within its controlled vocabulary.</p>
</dd>
<dt><code>name</code></dt><dd><p>Name of the controlled vocabulary term describing the software tool.</p>
</dd>
<dt><code>version</code></dt><dd><p>Version number of the software tool.</p>
</dd>
<dt><code>uri</code></dt><dd><p>Publicly accessible URI of the software tool or documentation.</p>
</dd>
<dt><code>description</code></dt><dd><p>(optional) Definition of the controlled vocabulary term.</p>
</dd>
<dt><code>value</code></dt><dd><p>(optional) Name of the software tool.</p>
</dd>
</dl>

<hr>
<h2 id='MzQCbaseQuality-class'>Base class of runQuality/setQuality</h2><span id='topic+MzQCbaseQuality-class'></span><span id='topic+MzQCbaseQuality'></span>

<h3>Description</h3>

<p>Base class of runQuality/setQuality
</p>


<h3>Fields</h3>


<dl>
<dt><code>metadata</code></dt><dd><p>The metadata for this run/setQuality</p>
</dd>
<dt><code>qualityMetrics</code></dt><dd><p>Array of MzQCqualityMetric objects</p>
</dd>
</dl>

<hr>
<h2 id='MzQCcontrolledVocabulary-class'>A controlled vocabulary document, usually pointing to an .obo file</h2><span id='topic+MzQCcontrolledVocabulary-class'></span><span id='topic+MzQCcontrolledVocabulary'></span>

<h3>Description</h3>

<p>A controlled vocabulary document, usually pointing to an .obo file
</p>


<h3>Fields</h3>


<dl>
<dt><code>name</code></dt><dd><p>Full name of the controlled vocabulary.</p>
</dd>
<dt><code>uri</code></dt><dd><p>Publicly accessible URI of the controlled vocabulary.</p>
</dd>
<dt><code>version</code></dt><dd><p>(optional) Version of the controlled vocabulary.</p>
</dd>
</dl>


<h3>Examples</h3>

<pre><code class='language-R'>  MzQCcontrolledVocabulary$new(
    "Proteomics Standards Initiative Quality Control Ontology",
    "https://github.com/HUPO-PSI/psi-ms-CV/releases/download/v4.1.129/psi-ms.obo",
    "4.1.129")

</code></pre>

<hr>
<h2 id='MzQCcvParameter-class'>A controlled vocabulary parameter, as detailed in the OBO file</h2><span id='topic+MzQCcvParameter-class'></span><span id='topic+MzQCcvParameter'></span>

<h3>Description</h3>

<p>A controlled vocabulary parameter, as detailed in the OBO file
</p>


<h3>Fields</h3>


<dl>
<dt><code>accession</code></dt><dd><p>Accession number identifying the term within its controlled vocabulary.</p>
</dd>
<dt><code>name</code></dt><dd><p>Name of the controlled vocabulary term describing the parameter.</p>
</dd>
<dt><code>value</code></dt><dd><p>(optional) Value of the parameter.</p>
</dd>
<dt><code>description</code></dt><dd><p>(optional) Definition of the controlled vocabulary term.</p>
</dd>
</dl>


<h3>Examples</h3>

<pre><code class='language-R'>  MzQCcvParameter$new("MS:4000070",
                      "retention time acquisition range",
                      c(0.2959, 5969.8172))
  isValidMzQC(MzQCcvParameter$new("MS:0000000"))

</code></pre>

<hr>
<h2 id='MzQCDateTime-class'>An mzQC-formatted date+time in ISO8601 format, as required by the mzQC spec doc.</h2><span id='topic+MzQCDateTime-class'></span><span id='topic+MzQCDateTime'></span>

<h3>Description</h3>

<p>The format is &quot;%Y-%m-%dT%H:%M:%S&quot;.
</p>


<h3>Fields</h3>


<dl>
<dt><code>datetime</code></dt><dd><p>A correctly formatted date time (use as read-only)</p>
</dd>
</dl>


<h3>Examples</h3>

<pre><code class='language-R'>   dt1 = MzQCDateTime$new("1900-01-01")  ## yields "1900-01-01T00:00:00"
   dt2 = MzQCDateTime$new(Sys.time())
   ## test faulty input
   ## errors with 'character string is not in a standard unambiguous format'
   try(MzQCDateTime$new('lala'), silent=TRUE)
   ## test roundtrip conversion from/to JSON
   dt2$fromData(jsonlite::fromJSON(jsonlite::toJSON(dt1)))

</code></pre>

<hr>
<h2 id='MzQCinputFile-class'>An inputfile within metadata for a run/setQuality</h2><span id='topic+MzQCinputFile-class'></span><span id='topic+MzQCinputFile'></span>

<h3>Description</h3>

<p>An inputfile within metadata for a run/setQuality
</p>


<h3>Fields</h3>


<dl>
<dt><code>name</code></dt><dd><p>The name MUST uniquely match to a location (specified below) listed in the mzQC file.</p>
</dd>
<dt><code>location</code></dt><dd><p>Unique file location, REQUIRED to be specified as a URI. The file URI is RECOMMENDED to be publicly accessible.</p>
</dd>
<dt><code>fileFormat</code></dt><dd><p>An MzQCcvParameter with 'accession' and 'name'.</p>
</dd>
<dt><code>fileProperties</code></dt><dd><p>An array of MzQCcvParameter, usually with 'accession', 'name' and 'value'. Recommended are at least two entries:
a) Completion time of the input file (MS:1000747) and b) Checksum of the input file (any child of: MS:1000561 ! data file checksum type).</p>
</dd>
</dl>

<hr>
<h2 id='MzQCmetadata-class'>The metadata for a run/setQuality</h2><span id='topic+MzQCmetadata-class'></span><span id='topic+MzQCmetadata'></span>

<h3>Description</h3>

<p>The metadata for a run/setQuality
</p>


<h3>Fields</h3>


<dl>
<dt><code>label</code></dt><dd><p>Unique name for the run (for runQuality) or set (for setQuality).</p>
</dd>
<dt><code>inputFiles</code></dt><dd><p>Array/list of MzQCinputFile objects</p>
</dd>
<dt><code>analysisSoftware</code></dt><dd><p>Array/list of MzQCanalysisSoftware objects</p>
</dd>
<dt><code>cvParameters</code></dt><dd><p>(optional) Array of cvParameters objects</p>
</dd>
</dl>

<hr>
<h2 id='MzQCmzQC-class'>Root element of an mzQC document</h2><span id='topic+MzQCmzQC-class'></span><span id='topic+MzQCmzQC'></span>

<h3>Description</h3>

<p>At least one of runQualities or setQualities MUST be present.
</p>


<h3>Fields</h3>


<dl>
<dt><code>version</code></dt><dd><p>Version of the mzQC format.</p>
</dd>
<dt><code>creationDate</code></dt><dd><p>Creation date of the mzQC file.</p>
</dd>
<dt><code>contactName</code></dt><dd><p>Name of the operator/creator of this mzQC file.</p>
</dd>
<dt><code>contactAddress</code></dt><dd><p>Contact address (mail/e-mail or phone)</p>
</dd>
<dt><code>description</code></dt><dd><p>Description and comments about the mzQC file contents.</p>
</dd>
<dt><code>runQualities</code></dt><dd><p>Array of MzQCrunQuality;</p>
</dd>
<dt><code>setQualities</code></dt><dd><p>Array of MzQCsetQuality</p>
</dd>
<dt><code>controlledVocabularies</code></dt><dd><p>Array of CV domains used (obo files)</p>
</dd>
</dl>

<hr>
<h2 id='MzQCqualityMetric-class'>The central class to store QC information</h2><span id='topic+MzQCqualityMetric-class'></span><span id='topic+MzQCqualityMetric'></span>

<h3>Description</h3>

<p>The central class to store QC information
</p>


<h3>Fields</h3>


<dl>
<dt><code>accession</code></dt><dd><p>Accession number identifying the term within its controlled vocabulary.</p>
</dd>
<dt><code>name</code></dt><dd><p>Name of the controlled vocabulary element describing the metric.</p>
</dd>
<dt><code>description</code></dt><dd><p>(optional) Definition of the controlled vocabulary term.</p>
</dd>
<dt><code>value</code></dt><dd><p>(optional) Value of the metric (single value, n-tuple, table, matrix).
The structure is not checked by our mzQC implementation and must be handled by the caller, see <code><a href="#topic+toQCMetric">toQCMetric</a></code>.</p>
</dd>
<dt><code>unit</code></dt><dd><p>(optional) Array of unit(s), stored as MzQcvParameter</p>
</dd>
</dl>

<hr>
<h2 id='MzQCrunQuality-class'>A runQuality object. Use to report metrics for individual runs which are independent of other runs.</h2><span id='topic+MzQCrunQuality-class'></span><span id='topic+MzQCrunQuality'></span>

<h3>Description</h3>

<p>The object is an alias for MzQCbaseQuality.
</p>

<hr>
<h2 id='MzQCsetQuality-class'>A setQuality object. Use it for metrics which are specific to sets, i.e. only for values which
only make sense in the set context and cannot be stored as runQuality (see mzQC spec doc).</h2><span id='topic+MzQCsetQuality-class'></span><span id='topic+MzQCsetQuality'></span>

<h3>Description</h3>

<p>The object is an alias for MzQCbaseQuality.
</p>

<hr>
<h2 id='NULL_to_charNA'>Converts a NULL to NA_character_; or returns the argument unchanged otherwise</h2><span id='topic+NULL_to_charNA'></span>

<h3>Description</h3>

<p>This is useful for missing list elements (which returns NULL),
but when the missing element in refClass should be NA_character_ (and NULL would return an error)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NULL_to_charNA(char_or_NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NULL_to_charNA_+3A_char_or_null">char_or_NULL</code></td>
<td>
<p>A string or NULL</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>  NULL_to_charNA(NA)   ## NA
  NULL_to_charNA(NULL) ## NA_character_
  NULL_to_charNA("hi") ## "hi"

</code></pre>

<hr>
<h2 id='NULL_to_NA'>Converts a NULL to NA; or returns the argument unchanged otherwise</h2><span id='topic+NULL_to_NA'></span>

<h3>Description</h3>

<p>This is useful for missing list elements (which returns NULL),
but when the missing element in refClass should be NA (and NULL would return an error)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NULL_to_NA(var_or_NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NULL_to_NA_+3A_var_or_null">var_or_NULL</code></td>
<td>
<p>A variable of any kind or NULL</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>  NULL_to_NA(NA)   ## NA
  NULL_to_NA(NULL) ## NA
  NULL_to_NA("hi") ## "hi"

</code></pre>

<hr>
<h2 id='parseOBO'>Get the information of each CV term from an obo file.</h2><span id='topic+parseOBO'></span>

<h3>Description</h3>

<p>Get the information of each CV term from an obo file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parseOBO(cv_obo_file)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="parseOBO_+3A_cv_obo_file">cv_obo_file</code></td>
<td>
<p>A local path to an .obo file</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame containing CV term information
</p>

<hr>
<h2 id='readMZQC'>Read a JSON file in mzQC format into an MzQCmzQC root object</h2><span id='topic+readMZQC'></span>

<h3>Description</h3>

<p>Read a JSON file in mzQC format into an MzQCmzQC root object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>readMZQC(filepath)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="readMZQC_+3A_filepath">filepath</code></td>
<td>
<p>A filename (with path) to read from.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An MzQCmzQC root object from which all the data can be extracted/manipulated
</p>

<hr>
<h2 id='removeFileSuffix'>Removes the last suffix (including the last dot) from a filename.
If no dot exists, the full string is returned.</h2><span id='topic+removeFileSuffix'></span>

<h3>Description</h3>

<p>Removes the last suffix (including the last dot) from a filename.
If no dot exists, the full string is returned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>removeFileSuffix(filepath)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="removeFileSuffix_+3A_filepath">filepath</code></td>
<td>
<p>A filename (with optional path &ndash; which is retained)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The input with removed suffix
</p>


<h3>Examples</h3>

<pre><code class='language-R'> removeFileSuffix("test.tar.gz")  # --&gt; 'test.tar'
 removeFileSuffix("test.mzML")  # --&gt; 'test'
 removeFileSuffix("/path/to/test.mzML")  # --&gt; '/path/to/test'
 removeFileSuffix("test_no_dot")  # --&gt; 'test_no_dot'

</code></pre>

<hr>
<h2 id='removeIfExists'>Remove a file, if it exists (useful for temporary files which may or may not have been created)</h2><span id='topic+removeIfExists'></span>

<h3>Description</h3>

<p>Remove a file, if it exists (useful for temporary files which may or may not have been created)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>removeIfExists(tmp_filename)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="removeIfExists_+3A_tmp_filename">tmp_filename</code></td>
<td>
<p>A path to a local file</p>
</td></tr>
</table>


<h3>Value</h3>

<p>NULL if file is missing, otherwise TRUE/FALSE depening on successful removal
</p>

<hr>
<h2 id='toAnalysisSoftware'>From an ID, e.g. &quot;MS:1003162&quot; (for PTX-QC), and some additional information,
create an 'analysisSoftware' node for mzQC</h2><span id='topic+toAnalysisSoftware'></span>

<h3>Description</h3>

<p>From an ID, e.g. &quot;MS:1003162&quot; (for PTX-QC), and some additional information,
create an 'analysisSoftware' node for mzQC
</p>


<h3>Usage</h3>

<pre><code class='language-R'>toAnalysisSoftware(id, version = "unknown", uri = NULL, value = NA_character_)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="toAnalysisSoftware_+3A_id">id</code></td>
<td>
<p>The CV accession</p>
</td></tr>
<tr><td><code id="toAnalysisSoftware_+3A_version">version</code></td>
<td>
<p>The version of the tool which created the metric/mzQC</p>
</td></tr>
<tr><td><code id="toAnalysisSoftware_+3A_uri">uri</code></td>
<td>
<p>URI to the homepage, or if NULL (default), will be extracted from the definition in the PSI MS-CV (if possible)</p>
</td></tr>
<tr><td><code id="toAnalysisSoftware_+3A_value">value</code></td>
<td>
<p>An optional name for the software (if different from the CV's name)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An MzQCanalysisSoftware object
</p>


<h3>Examples</h3>

<pre><code class='language-R'> # use 'version = packageVersion("PTXQC")' if the package is installed
 toAnalysisSoftware(id = "MS:1003162", version = "1.0.12")

</code></pre>

<hr>
<h2 id='toQCMetric'>Create an 'MzQCqualityMetric' object from two inputs</h2><span id='topic+toQCMetric'></span>

<h3>Description</h3>

<p>Create an 'MzQCqualityMetric' object from two inputs
</p>


<h3>Usage</h3>

<pre><code class='language-R'>toQCMetric(id, value, on_violation = c("error", "warn"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="toQCMetric_+3A_id">id</code></td>
<td>
<p>The CV accession</p>
</td></tr>
<tr><td><code id="toQCMetric_+3A_value">value</code></td>
<td>
<p>The data, as computed by some QC software in the required format.</p>
</td></tr>
<tr><td><code id="toQCMetric_+3A_on_violation">on_violation</code></td>
<td>
<p>What to do when 'value' is not of the correct type (according to the given 'id')? Default: &quot;error&quot;; or &quot;warn&quot;</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The inputs are:
</p>

<ul>
<li><p> an ID of a QC metric, e.g. &quot;MS:4000059&quot; (number of MS1 spectra)
</p>
</li>
<li><p> a value
</p>
</li></ul>

<p>The value must be in the correct format depending on the metric. The value type (see below) is checked (a warning/error is given if mismatching):
The following requirements for values apply:
</p>

<ul>
<li><p> single value: R single value; the unit is obtained from the CVs 'has_units'
</p>
</li>
<li><p> n-tuple: an R vector, e.g. using c(1,2,3), i.e. all values have the same type; the unit is obtained from the CVs 'has_units'
</p>
</li>
<li><p> table:  an R data.frame(); all columns defined using CVs 'has_column' must be present (a warning/error is given otherwise)
</p>
</li>
<li><p> matrix: an R matrix, i.e. all values have the same type; the unit is obtained from the CVs 'has_units'
</p>
</li></ul>

<p>Upon violation, an error (default) or a warning is emitted:
</p>
<pre>
   toQCMetric(id = "MS:4000059", value = data.frame(n = 1)) # errors: wrong value format
 </pre>


<h3>Value</h3>

<p>An MzQCanalysisSoftware object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   toQCMetric(id = "MS:4000059", value = 13405) # number of MS1 spectra

</code></pre>

<hr>
<h2 id='validateFromFile'>Syntactically validates an mzQC document which is present as a file.</h2><span id='topic+validateFromFile'></span>

<h3>Description</h3>

<p>The returned TRUE/FALSE has additional attributes in case of errors.
Use attributes(result) to access them.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>validateFromFile(filepath, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="validateFromFile_+3A_filepath">filepath</code></td>
<td>
<p>A path to a file (e.g. &quot;c:/my.mzQC&quot;, or &quot;test.mzQC&quot;)</p>
</td></tr>
<tr><td><code id="validateFromFile_+3A_verbose">verbose</code></td>
<td>
<p>Show extra information if validation fails</p>
</td></tr>
</table>


<h3>Value</h3>

<p>TRUE/FALSE if validation was successful/failed
</p>

<hr>
<h2 id='validateFromObj'>Syntactically validates an mzQC document which is already in memory as mzQC root object, as obtained by, e.g. readMZQC().</h2><span id='topic+validateFromObj'></span>

<h3>Description</h3>

<p>This method is less performant than validateFromString,
because it needs to convert the R object to
a JSON string first.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>validateFromObj(mzqc_root, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="validateFromObj_+3A_mzqc_root">mzqc_root</code></td>
<td>
<p>An mzQC root object</p>
</td></tr>
<tr><td><code id="validateFromObj_+3A_verbose">verbose</code></td>
<td>
<p>Show extra information if validation fails</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The returned TRUE/FALSE has additional attributes in case of errors.
Use attributes(result) to access them.
</p>


<h3>Value</h3>

<p>TRUE/FALSE if validation was successful/failed
</p>

<hr>
<h2 id='validateFromString'>Syntactically validates an mzQC document which is already in memory as JSON string.
e.g. the string &quot; mzQC : &quot;</h2><span id='topic+validateFromString'></span>

<h3>Description</h3>

<p>If the string object passed into this function contains multiple elements (length &gt; 1).
then they will be concatenated using '\n' before validation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>validateFromString(JSON_string, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="validateFromString_+3A_json_string">JSON_string</code></td>
<td>
<p>A string which contains JSON (multiple lines allowed)</p>
</td></tr>
<tr><td><code id="validateFromString_+3A_verbose">verbose</code></td>
<td>
<p>Show extra information if validation fails</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The returned TRUE/FALSE has additional attributes in case of errors.
Use attributes(result) to access them.
</p>


<h3>Value</h3>

<p>TRUE/FALSE if validation was successful/failed
</p>

<hr>
<h2 id='writeMZQC'>Writes a full mzQC object to disk.</h2><span id='topic+writeMZQC'></span>

<h3>Description</h3>

<p>You can in theory also provide any mzQC subelement,
but the resulting mzQC file will not validate since its incomplete.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>writeMZQC(filepath, mzqc_obj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="writeMZQC_+3A_filepath">filepath</code></td>
<td>
<p>A filename (with optional path) to write to.</p>
</td></tr>
<tr><td><code id="writeMZQC_+3A_mzqc_obj">mzqc_obj</code></td>
<td>
<p>An MzQCmzQC root object, which is serialized to JSON and then written to disk</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The filename should have '.mzQC' (case sensitive) as suffix. There will be a warning otherwise.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
