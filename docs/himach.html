<!DOCTYPE html><html><head><title>Help for package himach</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {himach}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#himach-package'><p>himach: High Mach Finds Routes for Supersonic Aircraft</p></a></li>
<li><a href='#crs_120E'><p>Asia-centred coordinate reference system</p></a></li>
<li><a href='#crs_Atlantic'><p>Atlantic-centred coordinate reference system</p></a></li>
<li><a href='#crs_longlat'><p>Lat-long coordinate reference system</p></a></li>
<li><a href='#crs_N'><p>Arctic-centred coordinate reference system</p></a></li>
<li><a href='#crs_Pacific'><p>Pacific-centred coordinate reference system</p></a></li>
<li><a href='#crs_S'><p>Antarctic-centred coordinate reference system</p></a></li>
<li><a href='#find_leg'><p>Find best non-stop route between 2 airports</p></a></li>
<li><a href='#find_route'><p>Find best route between 2 airports</p></a></li>
<li><a href='#find_routes'><p>Find best routes between airport-pair &amp; aircraft combinations</p></a></li>
<li><a href='#GridLat-class'><p>A grid and lattice combination</p></a></li>
<li><a href='#hm_clean_cache'><p>Clean the route and SID-STAR cache.</p></a></li>
<li><a href='#hm_get_test'><p>Get test data</p></a></li>
<li><a href='#hm_load_cache'><p>Load route and SID/STAR cache</p></a></li>
<li><a href='#hm_save_cache'><p>Save route and SID/STAR cache to file</p></a></li>
<li><a href='#mach_kph'><p>Speed of sound, for Mach to km conversion</p></a></li>
<li><a href='#make_aircraft'><p>Make aircraft data from minimum dataset</p></a></li>
<li><a href='#make_airports'><p>Make or load airport data</p></a></li>
<li><a href='#make_AP2'><p>Make airport-pair dataset</p></a></li>
<li><a href='#make_route_envelope'><p>Make range-constrained envelope between 2 airports</p></a></li>
<li><a href='#make_route_grid'><p>Make lat-long grid for route finding</p></a></li>
<li><a href='#map_routes'><p>Map a set of routes</p></a></li>
<li><a href='#profile_routes'><p>Profile a set of routes</p></a></li>
<li><a href='#st_window'><p>Version of <code>st_transform</code> with view window to avoid dateline</p></a></li>
<li><a href='#summarise_routes'><p>Summarise a set of routes</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>High Mach Finds Routes for Supersonic Aircraft</td>
</tr>
<tr>
<td>Version:</td>
<td>0.3.2</td>
</tr>
<tr>
<td>Description:</td>
<td>For supersonic aircraft, flying subsonic over land,
    find the best route between airports. Allow for coastal buffer and
    potentially closed regions. Use a minimal model of aircraft
    performance: the focus is on time saved versus subsonic flight, rather
    than on vertical flight profile. For modelling and forecasting, not for planning your
    flight!</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/david6marsh/himach">https://github.com/david6marsh/himach</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/david6marsh/himach/issues">https://github.com/david6marsh/himach/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>cppRouting, data.table, dplyr (&ge; 1.0.0), geosphere, ggplot2,
lwgeom, methods, purrr, s2, sf (&ge; 1.0), tidyr</td>
</tr>
<tr>
<td>Suggests:</td>
<td>airportr, cowplot, knitr, progress, rmarkdown,
rnaturalearthdata, scales, stringr, testthat (&ge; 3.0), units,
utils, viridis, covr, spelling</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Language:</td>
<td>en-GB</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-09-20 07:24:16 UTC; david</td>
</tr>
<tr>
<td>Author:</td>
<td>David Marsh [aut, cre],
  Enrico Spinielli [ctb],
  EUROCONTROL [fnd, cph]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>David Marsh &lt;david6marsh@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-09-20 07:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='himach-package'>himach: High Mach Finds Routes for Supersonic Aircraft</h2><span id='topic+himach'></span><span id='topic+himach-package'></span>

<h3>Description</h3>

<p>For supersonic aircraft, flying subsonic over land, find the best route between airports. Allow for coastal buffer and potentially closed regions. Use a minimal model of aircraft performance: the focus is on time saved versus subsonic flight, rather than on vertical flight profile. For modelling and forecasting, not for planning your flight!
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: David Marsh <a href="mailto:david6marsh@gmail.com">david6marsh@gmail.com</a>
</p>
<p>Other contributors:
</p>

<ul>
<li><p> Enrico Spinielli <a href="mailto:enrico.spinielli@eurocontrol.int">enrico.spinielli@eurocontrol.int</a> [contributor]
</p>
</li>
<li><p>  EUROCONTROL [funder, copyright holder]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/david6marsh/himach">https://github.com/david6marsh/himach</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/david6marsh/himach/issues">https://github.com/david6marsh/himach/issues</a>
</p>
</li></ul>


<hr>
<h2 id='crs_120E'>Asia-centred coordinate reference system</h2><span id='topic+crs_120E'></span>

<h3>Description</h3>

<p>Coordinate reference system (CRS) for plotting and analysing maps. Centred on
East Asia (120E).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>crs_120E
</code></pre>


<h3>Format</h3>

<p>CRS
</p>


<h3>Details</h3>

<p>&quot;+proj=robin +lon_0=120 +x_0=0 +y_0=0 +ellps=WGS84 +datum=WGS84 +units=m
+no_defs&quot;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+crs_Atlantic">crs_Atlantic</a></code>, <code><a href="#topic+crs_Pacific">crs_Pacific</a></code>,
<code><a href="#topic+crs_N">crs_N</a></code>, <code><a href="#topic+crs_S">crs_S</a></code>
</p>

<hr>
<h2 id='crs_Atlantic'>Atlantic-centred coordinate reference system</h2><span id='topic+crs_Atlantic'></span>

<h3>Description</h3>

<p>Coordinate reference system (CRS) for plotting and analysing maps.
Atlantic-centred. Works for most analysis, but not recommended for N-region
(eg New Zealand and Fiji), instead use <code><a href="#topic+crs_Pacific">crs_Pacific</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>crs_Atlantic
</code></pre>


<h3>Format</h3>

<p>CRS
</p>


<h3>Details</h3>

<p>crs_Atlantic is &quot;+proj=robin +lon_0=0 +x_0=0 +y_0=0 +ellps=WGS84 +datum=WGS84
+units=m +no_defs&quot;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+crs_Pacific">crs_Pacific</a></code>, <code><a href="#topic+crs_120E">crs_120E</a></code>,
<code><a href="#topic+crs_N">crs_N</a></code>, <code><a href="#topic+crs_S">crs_S</a></code>
</p>

<hr>
<h2 id='crs_longlat'>Lat-long coordinate reference system</h2><span id='topic+crs_longlat'></span>

<h3>Description</h3>

<p>Coordinate reference system (CRS) for creating maps from
longitude-latitude coordinates. Used in analysis, but
not recommended for plots.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>crs_longlat
</code></pre>


<h3>Format</h3>

<p>CRS
</p>


<h3>Details</h3>

<p><code>crs_longlat</code> is EPSG4326
</p>


<h3>See Also</h3>

<p><code><a href="#topic+crs_Atlantic">crs_Atlantic</a></code>, <code><a href="#topic+crs_Pacific">crs_Pacific</a></code>,
<code><a href="#topic+crs_S">crs_S</a></code>, <code><a href="#topic+crs_N">crs_N</a></code>
</p>

<hr>
<h2 id='crs_N'>Arctic-centred coordinate reference system</h2><span id='topic+crs_N'></span>

<h3>Description</h3>

<p>Coordinate reference system (CRS) for plotting and analysing maps.
WGS 84 / Arctic Polar Stereographic. Used in analysis, but
not recommended for plots.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>crs_N
</code></pre>


<h3>Format</h3>

<p>CRS
</p>


<h3>Details</h3>

<p>crs_N is EPSG3995
</p>


<h3>See Also</h3>

<p><code><a href="#topic+crs_Atlantic">crs_Atlantic</a></code>, <code><a href="#topic+crs_Pacific">crs_Pacific</a></code>,
<code><a href="#topic+crs_120E">crs_120E</a></code>, <code><a href="#topic+crs_longlat">crs_longlat</a></code>, <code><a href="#topic+crs_S">crs_S</a></code>
</p>

<hr>
<h2 id='crs_Pacific'>Pacific-centred coordinate reference system</h2><span id='topic+crs_Pacific'></span>

<h3>Description</h3>

<p>Coordinate reference system (CRS) for plotting and analysing maps.
Pacific-centred.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>crs_Pacific
</code></pre>


<h3>Format</h3>

<p>CRS
</p>


<h3>Details</h3>

<p>&quot;+proj=robin +lon_0=180 +x_0=0 +y_0=0 +ellps=WGS84 +datum=WGS84 +units=m
+no_defs&quot;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+crs_Atlantic">crs_Atlantic</a></code>, <code><a href="#topic+crs_120E">crs_120E</a></code>,
<code><a href="#topic+crs_N">crs_N</a></code>, <code><a href="#topic+crs_S">crs_S</a></code>
</p>

<hr>
<h2 id='crs_S'>Antarctic-centred coordinate reference system</h2><span id='topic+crs_S'></span>

<h3>Description</h3>

<p>Coordinate reference system (CRS) for plotting and analysing maps.
WGS 84 / Antarctic Polar Stereographic. Used in analysis, but
not recommended for plots.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>crs_S
</code></pre>


<h3>Format</h3>

<p>CRS
</p>


<h3>Details</h3>

<p>crs_N is EPSG 3031
</p>


<h3>See Also</h3>

<p><code><a href="#topic+crs_Atlantic">crs_Atlantic</a></code>, <code><a href="#topic+crs_Pacific">crs_Pacific</a></code>,
<code><a href="#topic+crs_120E">crs_120E</a></code>, <code><a href="#topic+crs_longlat">crs_longlat</a></code>, <code><a href="#topic+crs_N">crs_N</a></code>
</p>

<hr>
<h2 id='find_leg'>Find best non-stop route between 2 airports</h2><span id='topic+find_leg'></span>

<h3>Description</h3>

<p><code>find_leg</code> finds the quickest non-stop route for <code>ac</code> between
two airports <code>ap2</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find_leg(
  ac,
  ap2,
  route_grid,
  fat_map,
  ap_loc,
  avoid = NA,
  enforce_range = TRUE,
  best_by_time = TRUE,
  grace_km = NA,
  shortcuts = TRUE,
  ad_dist_m = 100 * 1000,
  ad_nearest = 12,
  max_leg_circuity = 1.4,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="find_leg_+3A_ac">ac</code>, <code id="find_leg_+3A_ap2">ap2</code>, <code id="find_leg_+3A_route_grid">route_grid</code>, <code id="find_leg_+3A_fat_map">fat_map</code>, <code id="find_leg_+3A_ap_loc">ap_loc</code>, <code id="find_leg_+3A_avoid">avoid</code></td>
<td>
<p>See <code><a href="#topic+find_route">find_route</a></code></p>
</td></tr>
<tr><td><code id="find_leg_+3A_enforce_range">enforce_range</code></td>
<td>
<p>If TRUE (default) then leg is constrained to aircraft range,
otherwise routes of excess range can be found.</p>
</td></tr>
<tr><td><code id="find_leg_+3A_best_by_time">best_by_time</code></td>
<td>
<p>If TRUE (default) then the quickest route is found,
else the shortest distance.</p>
</td></tr>
<tr><td><code id="find_leg_+3A_grace_km">grace_km</code></td>
<td>
<p>Default NA. Otherwise, if great circle distance is within
3pct of aircraft range, then add <code>grace_km</code>km to the range.</p>
</td></tr>
<tr><td><code id="find_leg_+3A_shortcuts">shortcuts</code></td>
<td>
<p>If TRUE (default) then path will be checked for great circle shortcuts.</p>
</td></tr>
<tr><td><code id="find_leg_+3A_ad_dist_m">ad_dist_m</code></td>
<td>
<p>The length of arrival/departure links, in m. (Default 100,000=100km)</p>
</td></tr>
<tr><td><code id="find_leg_+3A_ad_nearest">ad_nearest</code></td>
<td>
<p>The number of arrival/departure links to create (Default 12)</p>
</td></tr>
<tr><td><code id="find_leg_+3A_max_leg_circuity">max_leg_circuity</code></td>
<td>
<p>The maximum detour over great circle distance that
can be flown to find a quick over-sea route. Default 1.4.</p>
</td></tr>
<tr><td><code id="find_leg_+3A_...">...</code></td>
<td>
<p>Other parameters, passed to <code><a href="#topic+make_route_envelope">make_route_envelope</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function finds the quickest non-stop route between two airports. A
'route' is made up of one or two 'legs' (airport to airport without
intermediate stop). <code><a href="#topic+find_route">find_route</a></code> makes one or more calls to
<code>find_leg</code> as required.
</p>
<p>It assumes that the routing grid, <code>route_grid</code>, has already been classified as
land or sea using the map <code>fat_map</code>. The map is further used when
converting the grid-based route to one of great-circle segments.
</p>
<p>In fact <code>find_leg</code> finds up to 4 versions of the path:
</p>

<ol>
<li><p> A great circle, direct between the airports
</p>
</li>
<li><p> A grid path, consisting of segments of the routing grid, plus departure
and arrival routes from the airports
</p>
</li>
<li><p> A simplification of the grid path to great circle segments
</p>
</li>
<li> <p><code>shortcuts</code> defaults to TRUE. Without this, you see near-raw
Dijkstra results, which are _not_ shortest great circle.
</p>
</li></ol>

<p>Legs are automatically saved in <code>route_cache</code> and retrieved from here if
available rather than re-calculated. See
<a href="../doc/Supersonic_routes_in_depth.html#cache">vignette on caching</a> for cache
management.
</p>


<h3>Value</h3>

<p>Dataframe with details of the leg
</p>


<h3>Examples</h3>

<pre><code class='language-R'># need to load some of the built-in data (not run)
## Not run: 
aircraft &lt;- make_aircraft(warn = FALSE)
airports &lt;- make_airports(crs = crs_Pacific)
# get test datasets
NZ_buffer30 &lt;- hm_get_test("buffer")
NZ_grid &lt;- hm_get_test("grid")

options("quiet" = 4) #for heavy reporting
# from Auckland to Christchurch
ap2 &lt;- make_AP2("NZAA","NZCH",airports)
routes &lt;- find_leg(aircraft[4,],
                    ap2,
                    fat_map = NZ_buffer30,
                    route_grid = NZ_grid,
                    ap_loc = airports)

## End(Not run)
</code></pre>

<hr>
<h2 id='find_route'>Find best route between 2 airports</h2><span id='topic+find_route'></span>

<h3>Description</h3>

<p><code>find_route</code> finds the quickest route between two airports, refuelling
if necessary
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find_route(
  ac,
  ap2,
  fat_map,
  avoid = NA,
  route_grid,
  cf_subsonic = NA,
  refuel = NA,
  refuel_h = 1,
  refuel_only_if = TRUE,
  refuel_topN = 1,
  max_circuity = 2,
  ap_loc,
  margin_km = 200,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="find_route_+3A_ac">ac</code></td>
<td>
<p>One aircraft, as from <code><a href="#topic+make_aircraft">make_aircraft</a></code></p>
</td></tr>
<tr><td><code id="find_route_+3A_ap2">ap2</code></td>
<td>
<p>One airport pair, as from <code><a href="#topic+make_AP2">make_AP2</a></code></p>
</td></tr>
<tr><td><code id="find_route_+3A_fat_map">fat_map</code></td>
<td>
<p><code>sf::MULTIPOLYGON</code> map of land, including buffer</p>
</td></tr>
<tr><td><code id="find_route_+3A_avoid">avoid</code></td>
<td>
<p><code>sf::MULTIPOLYGON</code> map of areas not to fly over</p>
</td></tr>
<tr><td><code id="find_route_+3A_route_grid">route_grid</code></td>
<td>
<p><code>GridLat</code> routing grid as from
<code><a href="#topic+make_route_grid">make_route_grid</a></code></p>
</td></tr>
<tr><td><code id="find_route_+3A_cf_subsonic">cf_subsonic</code></td>
<td>
<p>Further aircraft to use as comparator, default NA. (use is
not recommended)</p>
</td></tr>
<tr><td><code id="find_route_+3A_refuel">refuel</code></td>
<td>
<p>Airports available for refuelling, dataframe with <code>APICAO,
long, lat</code></p>
</td></tr>
<tr><td><code id="find_route_+3A_refuel_h">refuel_h</code></td>
<td>
<p>Duration of refuelling stop, in hours</p>
</td></tr>
<tr><td><code id="find_route_+3A_refuel_only_if">refuel_only_if</code></td>
<td>
<p>If TRUE (default) only test refuel options if necessary
because the great circle distance is too far for the aircraft range</p>
</td></tr>
<tr><td><code id="find_route_+3A_refuel_topn">refuel_topN</code></td>
<td>
<p>Return the best N (default 1) refuelling options</p>
</td></tr>
<tr><td><code id="find_route_+3A_max_circuity">max_circuity</code></td>
<td>
<p>Threshold for excluding refuelling stops (default 2.0)</p>
</td></tr>
<tr><td><code id="find_route_+3A_ap_loc">ap_loc</code></td>
<td>
<p>Airport locations as from <code><a href="#topic+make_airports">make_airports</a></code></p>
</td></tr>
<tr><td><code id="find_route_+3A_margin_km">margin_km</code></td>
<td>
<p>Great circle distance between airports must be less than
aircraft range minus this operating margin (default 200km), to give
a margin for arrival and departure.</p>
</td></tr>
<tr><td><code id="find_route_+3A_...">...</code></td>
<td>
<p>Other parameters, passed to <code><a href="#topic+find_leg">find_leg</a></code> and thence to
to <code><a href="#topic+make_route_envelope">make_route_envelope</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function finds the quickest route between two airports. A 'route' is
made up of one or two 'legs' (airport to airport without intermediate stop).
<code>find_route</code> makes one or more calls to <code>find_leg</code> as required.
</p>
<p>It assumes that the routing grid, <code>route_grid</code>, has already been
classified as land or sea using the map <code>fat_map</code>. The map is further
used when converting the grid-based route to one of great circles segments.
</p>


<h3>Value</h3>

<p>Dataframe with details of the route
</p>


<h3>Refuelling</h3>

<p>If either necessary, because the great circle distance is greater than the
aircraft range, or because <code>refuel_only_if</code> is FALSE,
<code>find_route</code> searches through a list of refuelling airports and
chooses the quickest one (or <code>refuel_topN</code>).
</p>
<p>Circuitous refuelling is avoided, tested against total distance &lt;
<code>max_circuity</code> * great circle distance. This is separate to the limits
placed on circuity of individual legs in <code><a href="#topic+find_leg">find_leg</a></code>.
</p>
<p>If no refuel option is found, a message is displayed. The route with 'NA'
for 'time_h' is returned.
</p>
<p>Each refuelling stop costs <code>refuel_h</code> in addition to the time to
descend to the airport and then to climb out again.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># need to load some of the built-in data
aircraft &lt;- make_aircraft(warn = FALSE)
# get test datasets
NZ_buffer30 &lt;- hm_get_test("buffer")
NZ_grid &lt;- hm_get_test("grid")
airports &lt;- make_airports(crs = sf::st_crs(NZ_buffer30))

options("quiet" = 4) #for heavy reporting
# from Auckland to Christchurch
ap2 &lt;- make_AP2("NZAA","NZCH",airports)
# on some CRAN machines even this takes too long, so not run
## Not run: 
routes &lt;- find_route(aircraft[4,],
                    ap2,
                    fat_map = NZ_buffer30,
                    route_grid = NZ_grid,
                    ap_loc = airports)

## End(Not run)

</code></pre>

<hr>
<h2 id='find_routes'>Find best routes between airport-pair &amp; aircraft combinations</h2><span id='topic+find_routes'></span>

<h3>Description</h3>

<p><code>find_routes</code> combines an aircraft and airport-pair list and finds the
best routes between them, refuelling if necessary
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find_routes(ac_ids, ap2_ids, aircraft, airports, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="find_routes_+3A_ac_ids">ac_ids</code></td>
<td>
<p>A vector of aircraft IDs, as in column 'id' from
<code><a href="#topic+make_aircraft">make_aircraft</a></code></p>
</td></tr>
<tr><td><code id="find_routes_+3A_ap2_ids">ap2_ids</code></td>
<td>
<p>A 2-column matrix or dataframe of airport pair text IDs</p>
</td></tr>
<tr><td><code id="find_routes_+3A_aircraft">aircraft</code></td>
<td>
<p>Specification of the aircraft, see
<code><a href="#topic+make_aircraft">make_aircraft</a></code></p>
</td></tr>
<tr><td><code id="find_routes_+3A_airports">airports</code></td>
<td>
<p>Airport locations as from <code><a href="#topic+make_airports">make_airports</a></code></p>
</td></tr>
<tr><td><code id="find_routes_+3A_...">...</code></td>
<td>
<p>Other parameters, passed to <code><a href="#topic+find_route">find_route</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function finds is a wrapper for the single-case function
<code>find_route</code>. It takes (text) lists of aircraft and airport codes,
combines them, then finds routes for all of these. A 'route' is made up
of one or two 'legs' (airport to airport without intermediate stop).
</p>
<p>For more details see <code><a href="#topic+find_route">find_route</a></code>
</p>


<h3>Value</h3>

<p>Dataframe with details of the routes
</p>


<h3>Examples</h3>

<pre><code class='language-R'># need to load some of the built-in data
aircraft &lt;- make_aircraft(warn = FALSE)
airports &lt;- make_airports(crs = crs_Pacific)
# get test datasets
NZ_buffer30 &lt;- hm_get_test("buffer")
NZ_grid &lt;- hm_get_test("grid")

options("quiet" = 4) #for heavy reporting
# from Auckland to Christchurch
ap2 &lt;- make_AP2("NZAA","NZCH",airports)
## Not run: 
routes &lt;- find_route(aircraft[4,],
                    ap2,
                    fat_map = NZ_buffer30,
                    route_grid = NZ_grid,
                    ap_loc = airports)

## End(Not run)

</code></pre>

<hr>
<h2 id='GridLat-class'>A grid and lattice combination</h2><span id='topic+GridLat-class'></span>

<h3>Description</h3>

<p>A <code>GridLat</code> keeps together a grid of points and a
lattice of links between those points.
</p>
<p>It has 3 components:
</p>
<p>* A character name, which isn't used much in anger but might help you remember what's gone into it.
* A dataframe containing the points of the lattice (the vertices), which each have an ID, a longitude and latitude.
* A dataframe containing the edges of the lattice, joining the points.
</p>

<hr>
<h2 id='hm_clean_cache'>Clean the route and SID-STAR cache.</h2><span id='topic+hm_clean_cache'></span>

<h3>Description</h3>

<p>Empties the cache.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hm_clean_cache(cache = c("route", "star"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hm_clean_cache_+3A_cache">cache</code></td>
<td>
<p>Which caches to clear. Default is both <code>c("route",
"star")</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>TRUE silently
</p>


<h3>See Also</h3>

<p>For more details see the cache section in the vignette:
<code>vignette("Supersonic_Routes_in_depth", package = "himach")</code>. or
<a href="../doc/Supersonic_Routes_in_depth.html#cache">Vignette on caching</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>hm_clean_cache("route")

hm_clean_cache()

</code></pre>

<hr>
<h2 id='hm_get_test'>Get test data</h2><span id='topic+hm_get_test'></span>

<h3>Description</h3>

<p>Access 5 datasets that are used in vignettes and in testing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hm_get_test(item = c("coast", "buffer", "nofly", "grid", "route"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hm_get_test_+3A_item">item</code></td>
<td>
<p>Any one of <code>"coast", "buffer", "nofly", "grid", "route"</code>. See details.</p>
</td></tr>
</table>


<h3>Details</h3>


<dl>
<dt><code>"coast"</code></dt><dd><p>A dataset containing sf::MULTIPOLYGONS for New Zealand. Simplified
version of Stats NZ data, at 1km resolution.</p>
</dd>
<dt><code>"buffer"</code></dt><dd><p>As <code>"coast"</code> but with an added 30km buffer to keep supersonic
flight away from the coast.</p>
</dd>
<dt><code>"nofly"</code></dt><dd><p>As <code>"buffer"</code>, but limited to Buller district with a 40km buffer.
To test additional no-fly zones.</p>
</dd>
<dt><code>"grid"</code></dt><dd><p>Latitude-longitude-based routing grid around New Zealand at 30km target
distance, as generated by <code><a href="#topic+make_route_grid">make_route_grid</a></code>, so format is <a href="#topic+GridLat-class">GridLat</a></p>
</dd>
<dt><code>"route"</code></dt><dd><p>Some very unlikely supersonic routes around New Zealand using the test
aircraft that was given a very short range and slow subsonic cruise to get
the example to 'work'. Includes one refuelling stop (!) in Wellington. [Not for operational use!]
Returns a dataframe.</p>
</dd>
</dl>

<p>This is not the normal way to access package test data. But the usual, direct, way fails on
some machines that have some older software (a known feature of the 'sf' package). This is a
least-ugly workaround.
</p>


<h3>Value</h3>

<p>See list above
</p>


<h3>Source</h3>

<p><a href="https://datafinder.stats.govt.nz/layer/104266-territorial-authority-2020-clipped-generalised/">https://datafinder.stats.govt.nz/layer/104266-territorial-authority-2020-clipped-generalised/</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>NZ_coast &lt;- hm_get_test("coast")

</code></pre>

<hr>
<h2 id='hm_load_cache'>Load route and SID/STAR cache</h2><span id='topic+hm_load_cache'></span>

<h3>Description</h3>

<p>This silently overwrites any existing values in the cache.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hm_load_cache(file)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hm_load_cache_+3A_file">file</code></td>
<td>
<p>Including the path.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Invisible true
</p>


<h3>See Also</h3>

<p>For more details see the cache section in the vignette:
<code>vignette("Supersonic_Routes_in_depth", package = "himach")</code>. or
<a href="../doc/Supersonic_Routes_in_depth.html#cache">Vignette on caching</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># not run
# hm_load_cache(file="") #load from this file

</code></pre>

<hr>
<h2 id='hm_save_cache'>Save route and SID/STAR cache to file</h2><span id='topic+hm_save_cache'></span>

<h3>Description</h3>

<p>Filename is <code>"route_star_cache_id_XXX.rda"</code> where &quot;id&quot; is the id
parameter and XXX is made up from the name of the grid (which identifies the
map used) and the 'aircraftSet' attribute of the aircraft dataset (which
identifies the source). This is because the cache should be for a unique
combination of these (and you must have these available, because they were
needed to generate the routes).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hm_save_cache(id, grid, aircraft, path = "data/")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hm_save_cache_+3A_id">id</code></td>
<td>
<p>Identifying text, see above. Recommended to use a version number
or date.</p>
</td></tr>
<tr><td><code id="hm_save_cache_+3A_grid">grid</code></td>
<td>
<p>Your route grid dataset. The <code>grid@name</code> will be added to
the filename.</p>
</td></tr>
<tr><td><code id="hm_save_cache_+3A_aircraft">aircraft</code></td>
<td>
<p>Your aircraft dataset. The <code>attr(aircraft,
"aircraftSet")</code> will be added to the filename.</p>
</td></tr>
<tr><td><code id="hm_save_cache_+3A_path">path</code></td>
<td>
<p>By default <code>"data/"</code>, where the file will be saved.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Invisible true
</p>


<h3>See Also</h3>

<p>For more details see the cache section in the vignette:
<code>vignette("Supersonic_Routes_in_depth", package = "himach")</code>. or
<a href="../doc/Supersonic_Routes_in_depth.html#cache">Vignette on caching</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># not run
# hm_save_cache("v2", grid, ac) #save here


</code></pre>

<hr>
<h2 id='mach_kph'>Speed of sound, for Mach to km conversion</h2><span id='topic+mach_kph'></span>

<h3>Description</h3>

<p>1 Mach is approximately 1062kph in standard met conditions at the altitude
for supersonic flight (approx 50,000 feet).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mach_kph
</code></pre>


<h3>Format</h3>

<p>double
</p>

<hr>
<h2 id='make_aircraft'>Make aircraft data from minimum dataset</h2><span id='topic+make_aircraft'></span>

<h3>Description</h3>

<p><code>make_aircraft</code> ensures a minimum set of variables describing aircraft
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_aircraft(ac = NA, sound_kph = himach::mach_kph, warn = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_aircraft_+3A_ac">ac</code></td>
<td>
<p>Dataframe containing the minimum fields, or NA (default)</p>
</td></tr>
<tr><td><code id="make_aircraft_+3A_sound_kph">sound_kph</code></td>
<td>
<p>Speed of sound used to convert from Mach to kph, default
<code>mach_kph</code>=1062 at a suitable altitude.</p>
</td></tr>
<tr><td><code id="make_aircraft_+3A_warn">warn</code></td>
<td>
<p>Warn if no <code>ac</code> supplied, so default set is used. Default TRUE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function provides a test set of aircraft if necessary and adds variables
to a minimal set of data to give all the information that will be needed.
</p>
<p>This minimal set needs to have the following fields:
</p>

<ul>
<li> <p><code>id, type</code>: a very short, and longer text identifier for this aircraft
</p>
</li>
<li> <p><code>over_sea_M, over_land_M</code>: the eponymous two speeds, given as a Mach number
</p>
</li>
<li> <p><code>accel_Mpm</code>: acceleration in Mach per minute between these two
</p>
</li>
<li> <p><code>arrdep_kph</code>: the speed on arrival and departure from airports, given in km per hour
</p>
</li>
<li> <p><code>range_km</code>: range in km
</p>
</li></ul>

<p>An attribute is set to help keep track of where the aircraft data came from
(and whether a new cache is needed). If the <code>aircraftSet</code> attribute of
the <code>ac</code> parameter is not set, the set is treated as 'disposable'.
</p>
<p>For more details see the help vignette:
<code>vignette("SupersonicRouting", package = "himach")</code>
</p>


<h3>Value</h3>

<p>Dataframe with at least 11 variables describing the performance of one or
more aircraft
</p>


<h3>Examples</h3>

<pre><code class='language-R'># do minimal version (we know it will use the default so turn off warning)
ac &lt;- make_aircraft(warn = FALSE)

# on-the-fly example
ac &lt;- data.frame(id = "test", type = "test aircraft",
                 over_sea_M = 2.0, over_land_M = 0.9, accel_Mpm = 0.2,
                 arrdep_kph = 300, range_km = 6000, stringsAsFactors=FALSE)
ac &lt;- make_aircraft(ac, warn = FALSE)

## Not run: 
# example for your own data
aircraft &lt;- utils::read.csv("data/aircraft.csv", stringsAsFactors = FALSE)
aircraft &lt;- make_aircraft(aircraft)
# strongly recommended to record the file name for later reference
attr(aircraft, "aircraftSet") &lt;- "aircraft.csv"

## End(Not run)

</code></pre>

<hr>
<h2 id='make_airports'>Make or load airport data</h2><span id='topic+make_airports'></span>

<h3>Description</h3>

<p><code>make_airports</code> ensures a minimum set of variables describing airports
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_airports(ap = NA, crs = crs_longlat, warn = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_airports_+3A_ap">ap</code></td>
<td>
<p>Dataframe containing the minimum fields, or NA (default)</p>
</td></tr>
<tr><td><code id="make_airports_+3A_crs">crs</code></td>
<td>
<p>Coordinate reference system for the coded lat-longs.
Default 4326.</p>
</td></tr>
<tr><td><code id="make_airports_+3A_warn">warn</code></td>
<td>
<p>warn if default set is used (default = TRUE)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function provides a test set of airports if necessary from
<code>airportr::airports</code> and geocodes the lat-long of this or the dataset
provide as <code>ap</code>.
</p>
<p>This minimal set needs to have the following fields:
</p>

<ul>
<li> <p><code>APICAO</code>: the 4-letter ICAO code for the airport (though there is no
validity check applied, so 'TEST', or 'ZZZZ' could be used, for example)
</p>
</li>
<li> <p><code>lat, long</code>: latitude and longitude in decimal degrees
</p>
</li></ul>



<h3>Value</h3>

<p>Dataframe with, in addition, a geocoded lat-long.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># do minimal version
airports &lt;- make_airports()

# on-the-fly example
airports &lt;- data.frame(APICAO = "TEST", lat = 10, long = 10, stringsAsFactors = FALSE)
airports &lt;- make_airports(airports)

## Not run: 
# example for your own data
airports &lt;- utils::read.csv("data/airports.csv", stringsAsFactors = FALSE)
airports &lt;- make_airports(airports)

## End(Not run)

</code></pre>

<hr>
<h2 id='make_AP2'>Make airport-pair dataset</h2><span id='topic+make_AP2'></span>

<h3>Description</h3>

<p><code>make_AP2</code> creates an airport-pair set from two sets of airports
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_AP2(adep, ades, ap = make_airports())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_AP2_+3A_adep">adep</code>, <code id="make_AP2_+3A_ades">ades</code></td>
<td>
<p>Identical-length lists of airport codes</p>
</td></tr>
<tr><td><code id="make_AP2_+3A_ap">ap</code></td>
<td>
<p>List of locations of airports, defaults to the output
of <code><a href="#topic+make_airports">make_airports</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function takes two lists of airports (of the same length), specified
as 4-letter codes and combines them, adding the fields:
</p>

<ul>
<li> <p><code>from_long, from_lat, to_long, to_lat</code>: the airport lat-longs
with adep first
</p>
</li>
<li> <p><code>AP2</code>: a name for the route in a specific order
</p>
</li>
<li> <p><code>gcdist_km</code>: the great circle distance in km
</p>
</li></ul>

<p>In <code>AP2</code> European airports (crudely, from starting letter = 'E' or 'L')
are listed first, otherwise in alphabetical order. If unidirectional is TRUE,
then &quot;&gt;&quot; is the separator, otherwise &quot;&lt;&gt;&quot;.
(Unidirectional not currently supported)
</p>
<p>For more details see the <a href="../doc/Supersonic_Routes.html">introductory vignette</a>.
</p>


<h3>Value</h3>

<p>Dataframe with additional variables as described above.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
airports &lt;- make_airports() #get a default set of lat-longs
ap2 &lt;- make_AP2("NZAA","NZCH", airports)

</code></pre>

<hr>
<h2 id='make_route_envelope'>Make range-constrained envelope between 2 airports</h2><span id='topic+make_route_envelope'></span>

<h3>Description</h3>

<p><code>make_route_envelope</code> finds the range envelope for a given route
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_route_envelope(ac, ap2, envelope_points = 200, fuzz = 0.005)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_route_envelope_+3A_ac">ac</code>, <code id="make_route_envelope_+3A_ap2">ap2</code></td>
<td>
<p>See <code><a href="#topic+find_route">find_route</a></code></p>
</td></tr>
<tr><td><code id="make_route_envelope_+3A_envelope_points">envelope_points</code></td>
<td>
<p>How many points are used to define the ellipse? Default
200.</p>
</td></tr>
<tr><td><code id="make_route_envelope_+3A_fuzz">fuzz</code></td>
<td>
<p>Add a little margin to the range, to allow the longest range to
be flown, rather than be cut off at the boundary. (Default 0.005)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The 'route envelope' is the region within which a route from A to B must
remain. This is an ellipse.
</p>
<p>It differs from the pure 'range envelope' which is the points which an
aircraft can reach from a given airport.
</p>


<h3>Value</h3>

<p><code>sf POLYGON</code> with ad hoc coordinate reference system.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Need aircraft and airport datasets
ac &lt;- make_aircraft(warn = FALSE)
ap &lt;- make_airports()
z &lt;- make_route_envelope(ac[1,], make_AP2("EGLL","KJFK",ap))

</code></pre>

<hr>
<h2 id='make_route_grid'>Make lat-long grid for route finding</h2><span id='topic+make_route_grid'></span>

<h3>Description</h3>

<p><code>make_route_grid</code> creates, and optionally classifies, a lat-long route grid
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_route_grid(
  fat_map,
  name,
  target_km = 800,
  lat_min = -60,
  lat_max = 86,
  long_min = -180,
  long_max = 179.95,
  classify = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_route_grid_+3A_fat_map">fat_map</code></td>
<td>
<p>MULTIPOLYGON map defining land regions</p>
</td></tr>
<tr><td><code id="make_route_grid_+3A_name">name</code></td>
<td>
<p>String assigned to the name slot of the result</p>
</td></tr>
<tr><td><code id="make_route_grid_+3A_target_km">target_km</code></td>
<td>
<p>Target length. Default 800km
only to avoid accidentally starting heavy compute.
30-50km would be more useful.</p>
</td></tr>
<tr><td><code id="make_route_grid_+3A_lat_min">lat_min</code>, <code id="make_route_grid_+3A_lat_max">lat_max</code></td>
<td>
<p>Latitude extent of grid</p>
</td></tr>
<tr><td><code id="make_route_grid_+3A_long_min">long_min</code>, <code id="make_route_grid_+3A_long_max">long_max</code></td>
<td>
<p>Longitude extend of grid.
Two allow small grids crossing the 180 boundary, the function
accepts values outside [-180,180), then rounds to within this
range.</p>
</td></tr>
<tr><td><code id="make_route_grid_+3A_classify">classify</code></td>
<td>
<p>Whether to classify each link. Defaults to
FALSE only to avoid accidentally starting heavy compute.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function creates a <a href="#topic+GridLat-class">GridLat</a> object that contains
a set of point on a lat long grid (ie all the points are on
lines of latitude). It also joins these points into a lattice.
Optionally, but required later, it classifies each link as land, sea,
or transition, with reference to a given map (typically including a
coastal buffer).
</p>
<p>The definitions are
</p>

<ul>
<li><p> land: both ends of the link are on land
</p>
</li>
<li><p> sea: both ends are on sea, and the link does not intersect the land
</p>
</li>
<li><p> transition: otherwise
</p>
</li></ul>

<p>The length of the links will be around <code>target_km</code> or 50pct longer
for the diagonal links.
</p>
<p>For more details see the help vignette:
<code>vignette("Supersonic Routing", package = "himach")</code>
</p>


<h3>Value</h3>

<p><code>gridLat</code> object containing points and lattice.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>NZ_buffer &lt;- hm_get_test("buffer")
system.time(
  p_grid &lt;- make_route_grid(NZ_buffer,"NZ lat-long at 300km",
                           target_km = 300, classify = TRUE,
                           lat_min = -49, lat_max = -32,
                           long_min = 162, long_max = 182)
)

</code></pre>

<hr>
<h2 id='map_routes'>Map a set of routes</h2><span id='topic+map_routes'></span>

<h3>Description</h3>

<p><code>map_routes</code> plots routes, with many options
</p>


<h3>Usage</h3>

<pre><code class='language-R'>map_routes(
  thin_map,
  routes = NA,
  crs = himach::crs_Atlantic,
  show_route = c("speed", "aircraft", "time", "circuity", "acceleration", "traffic"),
  fat_map = NA,
  avoid_map = NA,
  ap_loc = NA,
  ap_col = "darkblue",
  ap_size = 0.4,
  forecast = NA,
  fc_var = NA_character_,
  fc_text = NA_character_,
  crow = FALSE,
  crow_col = "grey70",
  crow_size = 0.2,
  route_envelope = FALSE,
  bound = TRUE,
  bound_margin_km = 200,
  simplify_km = 8,
  land_f = "grey90",
  buffer_f = "grey60",
  land_c = "grey85",
  land_s = 0.2,
  avoid_f = "grey80",
  avoid_c = "grey95",
  avoid_s = 0.3,
  l_alpha = 0.8,
  l_size = 0.5,
  e_alpha = 0.4,
  e_size = 0.6,
  e_col = "grey70",
  refuel_airports = ap_loc,
  rap_col = "red",
  rap_size = 0.4,
  scale_direction = -1,
  title = "",
  subtitle = "",
  warn = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="map_routes_+3A_thin_map">thin_map</code></td>
<td>
<p>The minimum is a <code>MULTIPOLYGON</code> map, 'thin' in that it
is without buffer, so a normal coastline map.</p>
</td></tr>
<tr><td><code id="map_routes_+3A_routes">routes</code></td>
<td>
<p>as generated by <code><a href="#topic+find_route">find_route</a></code></p>
</td></tr>
<tr><td><code id="map_routes_+3A_crs">crs</code></td>
<td>
<p>Coordinate reference system, default <code>crs_Atlantic</code>.</p>
</td></tr>
<tr><td><code id="map_routes_+3A_show_route">show_route</code></td>
<td>
<p>one of &quot;speed&quot;, &quot;aircraft&quot;, &quot;time&quot;, &quot;circuity&quot;, &quot;accel&quot;,
&quot;traffic&quot; to indicate what goes in the legend.</p>
</td></tr>
<tr><td><code id="map_routes_+3A_fat_map">fat_map</code></td>
<td>
<p>optional coast + buffer map, default NA.</p>
</td></tr>
<tr><td><code id="map_routes_+3A_avoid_map">avoid_map</code></td>
<td>
<p>optional map of no-fly zones, default NA.</p>
</td></tr>
<tr><td><code id="map_routes_+3A_ap_loc">ap_loc</code></td>
<td>
<p>Show used origin and destination airports if this is a set of
airports from <code><a href="#topic+make_airports">make_airports</a></code>, or not if NA (default). This
dataset can be all airports, and is filtered to those used by
<code>routes</code>.</p>
</td></tr>
<tr><td><code id="map_routes_+3A_ap_col">ap_col</code>, <code id="map_routes_+3A_ap_size">ap_size</code></td>
<td>
<p>Colour and size of used airport markers (dark blue,
0.4)</p>
</td></tr>
<tr><td><code id="map_routes_+3A_forecast">forecast</code>, <code id="map_routes_+3A_fc_var">fc_var</code>, <code id="map_routes_+3A_fc_text">fc_text</code></td>
<td>
<p>Forecast set and two strings. See details,
default NA.</p>
</td></tr>
<tr><td><code id="map_routes_+3A_crow">crow</code>, <code id="map_routes_+3A_crow_col">crow_col</code>, <code id="map_routes_+3A_crow_size">crow_size</code></td>
<td>
<p>If TRUE, show the 'crow-flies' direct great
circle, in colour <code>crow_col</code> and thickness <code>crow_size</code>. Default
FALSE, &quot;grey70&quot;, 0.2</p>
</td></tr>
<tr><td><code id="map_routes_+3A_route_envelope">route_envelope</code></td>
<td>
<p>show the route envelope (default FALSE).</p>
</td></tr>
<tr><td><code id="map_routes_+3A_bound">bound</code>, <code id="map_routes_+3A_bound_margin_km">bound_margin_km</code></td>
<td>
<p>If bound=TRUE (default) crop to bounding box of
the <code>routes</code>, with additional <code>bound_margin_km</code> in km (default
200)</p>
</td></tr>
<tr><td><code id="map_routes_+3A_simplify_km">simplify_km</code></td>
<td>
<p>Simplify the two maps to this scale before plotting
(default 10).</p>
</td></tr>
<tr><td><code id="map_routes_+3A_land_f">land_f</code>, <code id="map_routes_+3A_buffer_f">buffer_f</code>, <code id="map_routes_+3A_avoid_f">avoid_f</code></td>
<td>
<p>fill colours for thin, fat and no-fly maps,
default grey 90, 70 and 80, respectively</p>
</td></tr>
<tr><td><code id="map_routes_+3A_land_c">land_c</code>, <code id="map_routes_+3A_land_s">land_s</code></td>
<td>
<p>boundary colour and size for land areas (countries),
default grey 85 and 0.2, respectively (use NA to turn off)</p>
</td></tr>
<tr><td><code id="map_routes_+3A_avoid_c">avoid_c</code>, <code id="map_routes_+3A_avoid_s">avoid_s</code></td>
<td>
<p>boundary colour and size for avoid areas, default grey
95 and 0.3, respectively</p>
</td></tr>
<tr><td><code id="map_routes_+3A_l_alpha">l_alpha</code>, <code id="map_routes_+3A_l_size">l_size</code></td>
<td>
<p>line (route) settings for alpha (transparency) and
width, defaults 0.6 and 0.4.</p>
</td></tr>
<tr><td><code id="map_routes_+3A_e_col">e_col</code>, <code id="map_routes_+3A_e_alpha">e_alpha</code>, <code id="map_routes_+3A_e_size">e_size</code></td>
<td>
<p>colour, alpha and width for the range envelope.
Default &quot;grey70&quot;, 0.4, 0.6</p>
</td></tr>
<tr><td><code id="map_routes_+3A_refuel_airports">refuel_airports</code></td>
<td>
<p>Show the used refuel airports using these locations,
or nothing if NA. (Defaults to same as <code>ap_loc</code>.)</p>
</td></tr>
<tr><td><code id="map_routes_+3A_rap_col">rap_col</code>, <code id="map_routes_+3A_rap_size">rap_size</code></td>
<td>
<p>Colour and size of refuel airport markers (red, 0.4)</p>
</td></tr>
<tr><td><code id="map_routes_+3A_scale_direction">scale_direction</code></td>
<td>
<p>Passed to scale_colour_viridis, either -1 (default) or
or 1.</p>
</td></tr>
<tr><td><code id="map_routes_+3A_title">title</code>, <code id="map_routes_+3A_subtitle">subtitle</code></td>
<td>
<p>Passed to ggplot.</p>
</td></tr>
<tr><td><code id="map_routes_+3A_warn">warn</code></td>
<td>
<p>if TRUE show some warnings (when defaults loaded) (default FALSE)</p>
</td></tr>
<tr><td><code id="map_routes_+3A_...">...</code></td>
<td>
<p>further parameters passed to <code>scale_colour_viridis_b</code> (or _c,
_d), such as <code>breaks = </code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function plots the routes, with options for additional layers. Multiple
routes are expected, and they can be coloured by time advantage, by speed
along each segment, or by aircraft type.
</p>
<p>The option <code>show_route</code> &quot;time&quot; requires 'advantage_h' to have been added
to the routes set, from the route summary. If it hasn't then this is done in
a local version, then discarded. Running <code>summarise_routes</code> to do this
requires an airport dataset; if <code>is.na(ap_loc)</code> then this is not
available, so a default set is used. You can turn on <code>warn</code> to see if
this is happening, but by default it is silent.
</p>
<p>For <code>show_route = </code> &quot;speed&quot;, &quot;aircraft&quot;, &quot;time&quot;, &quot;circuity&quot; or &quot;accel&quot;,
the information is already available in the <code>routes</code> dataset. For
<code>show_route = "traffic"</code> you need to provide a forecast dataset that
contains at least the <code>fullRouteID and acID</code> fields which are normal in
the <code>routes</code> dataset, and a field giving the volume of the forecast
<code>fc_var</code>. This could be flights, seats, or something else: use
<code>fc_text</code> for the legend title to show the units of <code>fc_var</code>.
Combinations of <code>fullRouteID and acID</code> must be unique, which probably
means you must filter by forecast year and forecast scenario before passing
to <code>map_routes</code>.
</p>
<p>The time to compute the map may not be very different with <code>simplify_km</code>
varying between 2km and 20km, but the time to plot on the screen, or
<code>ggsave</code> to a file, is longer than the compute time. It is this latter
time that's reduced by simplifying the maps. For single, or short routes, you
can probably see the difference between 2km and 10km, so it's your choice to
prefer speed or beauty.
</p>


<h3>Value</h3>

<p>A <code>ggplot</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#see introductory vignette

</code></pre>

<hr>
<h2 id='profile_routes'>Profile a set of routes</h2><span id='topic+profile_routes'></span>

<h3>Description</h3>

<p>Profile a set of routes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>profile_routes(
  routes,
  yvar = c("hours", "longitude"),
  ap_loc = make_airports(warn = FALSE),
  n_max = 2
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="profile_routes_+3A_routes">routes</code></td>
<td>
<p>as generated by <code><a href="#topic+find_route">find_route</a></code></p>
</td></tr>
<tr><td><code id="profile_routes_+3A_yvar">yvar</code></td>
<td>
<p>horizontal axis is hours or longitude</p>
</td></tr>
<tr><td><code id="profile_routes_+3A_ap_loc">ap_loc</code></td>
<td>
<p>Airports and coordinates, by (silent) default from <code><a href="#topic+make_airports">make_airports</a></code></p>
</td></tr>
<tr><td><code id="profile_routes_+3A_n_max">n_max</code></td>
<td>
<p>maximum number of routes to plot (default 2)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of named list pairs of plots, which can be displayed using eg <code>result[1]</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># not run ---
# plot_list &lt;- profile_routes(routes, n_max = 3)
# plot_list # to display them all

</code></pre>

<hr>
<h2 id='st_window'>Version of <code>st_transform</code> with view window to avoid dateline</h2><span id='topic+st_window'></span>

<h3>Description</h3>

<p><code>st_window</code> does a <code>st_transform</code> but first cuts the data to an
appropriate view window and so avoids problems with objects wrapping around
the back of the globe
</p>


<h3>Usage</h3>

<pre><code class='language-R'>st_window(m, crs = himach::crs_Atlantic, longit_margin = 0.1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="st_window_+3A_m">m</code></td>
<td>
<p>A map dataframe, ie of class <code>sf</code> and <code>data.frame</code>, or an
<code>sfc_MULTIPOLYGON</code></p>
</td></tr>
<tr><td><code id="st_window_+3A_crs">crs</code></td>
<td>
<p>Destination coordinate reference system, as in <code>st_tranform</code></p>
</td></tr>
<tr><td><code id="st_window_+3A_longit_margin">longit_margin</code></td>
<td>
<p>Amount trimmed off the 'far side' of the projection in
degrees.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code><a href="sf.html#topic+st_transform">st_wrap_dateline</a></code> _should_ handle the break in
a map projections but uses 'GDAL' for this. Given persistent issues in
installing GDAL, <code>st_window</code> achieves the same using <code>s2</code> instead.
</p>
<p>It works for any 'simple' projection, in the sense of one that has a dateline
that is a single line of longitude: ie the proj4string contains either
&quot;longitude_of_center&quot;, so the dateline is that +180; or not, in which case it
assumes the &quot;longitude_of_center&quot; is 0.
</p>


<h3>Value</h3>

<p><code>sf</code> dataframe, same as the parameter <code>m</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>world &lt;- sf::st_as_sf(rnaturalearthdata::coastline110)
w_pacific &lt;- st_window(world, crs_Pacific)
ggplot2::ggplot(w_pacific) + ggplot2::geom_sf()

# bad - not run - dateline problem example
# ggplot2::ggplot(st_transform(world, crs_Pacific)) +
#   ggplot2::geom_sf()

</code></pre>

<hr>
<h2 id='summarise_routes'>Summarise a set of routes</h2><span id='topic+summarise_routes'></span>

<h3>Description</h3>

<p>Reduce a set of routes to a one-line per route summary
</p>


<h3>Usage</h3>

<pre><code class='language-R'>summarise_routes(routes, ap_loc, arrdep_h = 0.5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summarise_routes_+3A_routes">routes</code></td>
<td>
<p>Each segment in each route, as produced by
<code><a href="#topic+find_route">find_route</a></code> or <code><a href="#topic+find_leg">find_leg</a></code></p>
</td></tr>
<tr><td><code id="summarise_routes_+3A_ap_loc">ap_loc</code></td>
<td>
<p>List of airport locations, output of
<code><a href="#topic+make_airports">make_airports</a></code></p>
</td></tr>
<tr><td><code id="summarise_routes_+3A_arrdep_h">arrdep_h</code></td>
<td>
<p>Total time for the M084 comparator aircraft to arrive &amp;
depart in hours. Default 0.5.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function takes the output of <code><a href="#topic+find_route">find_route</a></code> and summarises to
one line per (full) route.
</p>
<p>With refuelling, there can be multiple 'full routes' for each 'route'. The
<code>best</code> column indicates the best route for each <code>routeID</code>.
</p>
<p>The results are rounded to a reasonable number of significant figures. After
all this is just an approximate model. The <code>arrdep_h</code> has been checked
against actual and is reasonable (observed range roughly 0.3-0.5).
</p>


<h3>Value</h3>

<p>Dataframe with summary of the route, sorted in ascending order of <code>advantage_h</code>
so that the best route are plotted on top. The fields are:
</p>

<ul>
<li> <p><code>timestamp</code>: when the leg was originally generated (it may have been cached)
</p>
</li>
<li> <p><code>fullRouteID</code>: including the refuel stop if any
</p>
</li>
<li> <p><code>routeID</code>: origin and destination airport, in <code><a href="#topic+make_AP2">make_AP2</a></code> order
</p>
</li>
<li> <p><code>refuel_ap</code>: code for the refuelling airport, or NA
</p>
</li>
<li> <p><code>acID, acType</code>: aircraft identifiers taken from the aircraft set
</p>
</li>
<li> <p><code>M084_h</code>: flight time for a Mach 0.84 comparator aircraft (including <code>2*arrdep_h</code>)
</p>
</li>
<li> <p><code>gcdist_km</code>: great circle distance between the origin and destination airports
</p>
</li>
<li> <p><code>sea_time_frac</code>: Fraction of <code>time_h</code> time spent over sea, hence at supersonic speed,
or accelerating to, or decelerating from supersonic speed
</p>
</li>
<li> <p><code>sea_dist_frac</code>: as sea_time_frac, but fraction of <code>dist_km</code>
</p>
</li>
<li> <p><code>dist_km</code>: total length of the route, in km
</p>
</li>
<li> <p><code>time_h</code>: total time, in hours
</p>
</li>
<li> <p><code>n_phases</code>: number of distinct phases: arr/dep, transition, land, sea, refuel.
</p>
</li>
<li> <p><code>advantage_h</code>: <code>M084_h - time_h</code>
</p>
</li>
<li> <p><code>circuity</code>: the route distance extension (1 = perfect) <code>dist_km / gcdist_km</code>
</p>
</li>
<li> <p><code>best</code>: for each <code>routeID</code>, the <code>fullrouteID</code> with maximum <code>advantage_h</code>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># here we use a built-in set of routes
# see vignette for more details of how to obtain it
airports &lt;- make_airports(crs = crs_Pacific)
NZ_routes &lt;- hm_get_test("route")
sumy &lt;- summarise_routes(NZ_routes, airports)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
