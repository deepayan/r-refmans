<!DOCTYPE html><html><head><title>Help for package BRISC</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {BRISC}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#BRISC_bootstrap'><p>Function for performing bootstrap with BRISC</p></a></li>
<li><a href='#BRISC_correlation'><p>Function for simulating correlated data with BRISC</p></a></li>
<li><a href='#BRISC_decorrelation'><p>Function for decorrelating data with BRISC</p></a></li>
<li><a href='#BRISC_estimation'><p>Function for estimation with BRISC</p></a></li>
<li><a href='#BRISC_neighbor'><p>Function for finding set of nearest neighbors for BRISC</p></a></li>
<li><a href='#BRISC_order'><p>Function for ordering coordinates with BRISC</p></a></li>
<li><a href='#BRISC_prediction'><p>Function for performing prediction with BRISC</p></a></li>
<li><a href='#BRISC_simulation'><p>Function to simulate data with BRISC</p></a></li>
<li><a href='#BRISC_variogram.ci'><p>Function for plotting estimated Variogram and confidence region</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Fast Inference for Large Spatial Datasets using BRISC</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.5</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Arkajyoti Saha &lt;arkajyotisaha93@gmail.com&gt;</td>
</tr>
<tr>
<td>Author:</td>
<td>Arkajyoti Saha [aut, cre],
  Abhirup Datta [aut],
  Jorge Nocedal [ctb],
  Naoaki Okazaki [ctb],
  Lukas M. Weber [ctb]</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.3.0), RANN, parallel, stats, rdist, matrixStats,
pbapply, graphics</td>
</tr>
<tr>
<td>Description:</td>
<td>Fits bootstrap with univariate spatial regression models using Bootstrap for Rapid Inference on Spatial Covariances (BRISC) for large datasets using nearest neighbor Gaussian processes detailed in Saha and Datta (2018) &lt;<a href="https://doi.org/10.1002%2Fsta4.184">doi:10.1002/sta4.184</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/ArkajyotiSaha/BRISC">https://github.com/ArkajyotiSaha/BRISC</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/ArkajyotiSaha/BRISC/issues">https://github.com/ArkajyotiSaha/BRISC/issues</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>6.1.1</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-04-28 06:25:59 UTC; asaha</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-04-29 23:20:17 UTC</td>
</tr>
</table>
<hr>
<h2 id='BRISC_bootstrap'>Function for performing bootstrap with BRISC</h2><span id='topic+BRISC_bootstrap'></span>

<h3>Description</h3>

<p>The function <code>BRISC_bootstrap</code> performs bootstrap to provide confidence intervals for parameters of univariate spatial
regression models using outputs of <code>BRISC_estimation</code>. The details of the bootstrap method can be found in BRISC
(Saha &amp; Datta, 2018). The optimization is performed with C library of limited-memory BFGS libLBFGS: a library of
Limited-memory Broyden-Fletcher-Goldfarb-Shanno (L-BFGS), http://www.chokkan.org/software/liblbfgs/ (Naoaki Okazaki).
For user convenience the soure codes of the package libLBFGS are provided in the package. Some code blocks are borrowed
from the R package: spNNGP: Spatial Regression Models for Large Datasets using Nearest Neighbor Gaussian Processes <br />
https://CRAN.R-project.org/package=spNNGP .
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BRISC_bootstrap(BRISC_Out, n_boot = 100, h = 1, n_omp = 1,
                init = "Initial", verbose = TRUE,
                nugget_status = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BRISC_bootstrap_+3A_brisc_out">BRISC_Out</code></td>
<td>
<p>an object of class <code>BRISC_Out</code>, obtained as an output of <br /> <code>BRISC_estimation</code>. </p>
</td></tr>
<tr><td><code id="BRISC_bootstrap_+3A_n_boot">n_boot</code></td>
<td>
<p>number of bootstrap samples. Default value is 100. </p>
</td></tr>
<tr><td><code id="BRISC_bootstrap_+3A_h">h</code></td>
<td>
<p>number of core to be used in parallel computing setup for bootstrap samples. If <code>h = 1</code>, there is no parallelization.
Default value is 1. </p>
</td></tr>
<tr><td><code id="BRISC_bootstrap_+3A_n_omp">n_omp</code></td>
<td>
<p>number of threads to be used, value can be more than 1 if source code is compiled with OpenMP support.
Default is 1. </p>
</td></tr>
<tr><td><code id="BRISC_bootstrap_+3A_init">init</code></td>
<td>
<p>keyword that specifies initialization scheme to be used. Supported keywords are: <code>"Initial"</code> and <code>"Estimate"</code>
for initialization of parameter values for bootstrap samples with initial values used in <code>BRISC_estimate</code>
and estimated values of parameters in <code>BRISC_estimate</code> respectively. </p>
</td></tr>
<tr><td><code id="BRISC_bootstrap_+3A_verbose">verbose</code></td>
<td>
<p>if <code>TRUE</code>, model specifications along with information regarding OpenMP support and progress of the algorithm is
printed to the screen. Otherwise, nothing is printed to the screen. Default value is <code>TRUE</code>. </p>
</td></tr>
<tr><td><code id="BRISC_bootstrap_+3A_nugget_status">nugget_status</code></td>
<td>
<p>if <code>nugget_status = 0</code>, <code>tau.sq</code> is fixed to 0, if <code>nugget_status = 1</code> <code>tau.sq</code> is estimated. Default value is 1. </p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list comprising of the following:
</p>
<table>
<tr><td><code>boot.Theta</code></td>
<td>
<p>estimates of spatial covariance parameters corresponding to bootstrap samples. </p>
</td></tr>
<tr><td><code>boot.Beta</code></td>
<td>
<p>estimates of beta corresponding to bootstrap samples. </p>
</td></tr>
<tr><td><code>confidence.interval</code></td>
<td>
<p>confidence intervals corresponding to the parameters. </p>
</td></tr>
<tr><td><code>boot.time</code></td>
<td>
<p>time (in seconds) required to perform the bootstrapping after preprocessing data in <code>R</code>, reported using
<code>proc.time()</code>. </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Arkajyoti Saha <a href="mailto:arkajyotisaha93@gmail.com">arkajyotisaha93@gmail.com</a>, <br />
Abhirup Datta <a href="mailto:abhidatta@jhu.edu">abhidatta@jhu.edu</a>
</p>


<h3>References</h3>

<p>Saha, A., &amp; Datta, A. (2018). BRISC: bootstrap for rapid inference on spatial
covariances. Stat, e184, DOI: 10.1002/sta4.184.
</p>
<p>Okazaki N. libLBFGS: a library of Limited-memory Broyden-Fletcher-Goldfarb-Shanno
(L-BFGS), <br /> http://www.chokkan.org/software/liblbfgs/ .
</p>
<p>Andrew Finley, Abhirup Datta and Sudipto Banerjee (2017). spNNGP: Spatial Regression Models for Large
Datasets using Nearest Neighbor Gaussian Processes. R package version 0.1.1.
https://CRAN.R-project.org/package=spNNGP
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
rmvn &lt;- function(n, mu = 0, V = matrix(1)){
  p &lt;- length(mu)
  if(any(is.na(match(dim(V),p))))
    stop("Dimension not right!")
  D &lt;- chol(V)
  t(matrix(rnorm(n*p), ncol=p)%*%D + rep(mu,rep(n,p)))
}

set.seed(1)
n &lt;- 300
coords &lt;- cbind(runif(n,0,1), runif(n,0,1))

beta &lt;- c(1,5)
x &lt;- cbind(rnorm(n), rnorm(n))

sigma.sq = 1
phi = 5
tau.sq = 0.1

B &lt;- as.matrix(beta)
D &lt;- as.matrix(dist(coords))
R &lt;- exp(-phi*D)
w &lt;- rmvn(1, rep(0,n), sigma.sq*R)

y &lt;- rnorm(n, x%*%B + w, sqrt(tau.sq))

estimation_result &lt;- BRISC_estimation(coords, y, x)
bootstrap_result &lt;- BRISC_bootstrap(estimation_result, n_boot = 10)

</code></pre>

<hr>
<h2 id='BRISC_correlation'>Function for simulating correlated data with BRISC</h2><span id='topic+BRISC_correlation'></span>

<h3>Description</h3>

<p>The function <code>BRISC_correlation</code> creates correlated data (known structure) using Nearest Neighbor
Gaussian Processes (NNGP). <code>BRISC_correlation</code> uses the sparse Cholesky representation of Vecchiaâ€™s
likelihood developed in Datta et al., 2016. Some code blocks are borrowed from the R package: spNNGP:
Spatial Regression Models for Large Datasets using Nearest Neighbor Gaussian Processes
https://CRAN.R-project.org/package=spNNGP .
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BRISC_correlation(coords, sim, sigma.sq = 1, tau.sq = 0, phi = 1,
                  nu = 1.5, n.neighbors = NULL, n_omp = 1,
                  cov.model = "exponential",
                  search.type = "tree", stabilization = NULL,
                  verbose = TRUE, tol = 12)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BRISC_correlation_+3A_coords">coords</code></td>
<td>
<p>an <code class="reqn">n \times 2</code> matrix of the observation
coordinates in <code class="reqn">R^2</code> (e.g., easting and northing). </p>
</td></tr>
<tr><td><code id="BRISC_correlation_+3A_sim">sim</code></td>
<td>
<p>an <code class="reqn">n \times k</code> matrix of the <code class="reqn">k</code> many <code class="reqn">n \times 1</code> vectors
from which the correlated data are calculated (see Details below). </p>
</td></tr>
<tr><td><code id="BRISC_correlation_+3A_sigma.sq">sigma.sq</code></td>
<td>
<p>value of sigma square. Default value is 1. </p>
</td></tr>
<tr><td><code id="BRISC_correlation_+3A_tau.sq">tau.sq</code></td>
<td>
<p>value of tau square. Default value is 0.1. </p>
</td></tr>
<tr><td><code id="BRISC_correlation_+3A_phi">phi</code></td>
<td>
<p>value of phi. Default value is 1. </p>
</td></tr>
<tr><td><code id="BRISC_correlation_+3A_nu">nu</code></td>
<td>
<p>value of nu, only required for matern covariance model. Default value is 1.5. </p>
</td></tr>
<tr><td><code id="BRISC_correlation_+3A_n.neighbors">n.neighbors</code></td>
<td>
<p>number of neighbors used in the NNGP. Default value is <code class="reqn">max(100, n -1)</code>. We suggest a high value of
<code>n.neighbors</code> for lower value of phi. </p>
</td></tr>
<tr><td><code id="BRISC_correlation_+3A_n_omp">n_omp</code></td>
<td>
<p>number of threads to be used, value can be more than 1 if source code is compiled with OpenMP support.
Default is 1. </p>
</td></tr>
<tr><td><code id="BRISC_correlation_+3A_cov.model">cov.model</code></td>
<td>
<p>keyword that specifies the covariance function to be used in modelling the spatial dependence structure
among the observations. Supported keywords are: <code>"exponential"</code>, <code>"matern"</code>, <code>"spherical"</code>, and <code>"gaussian"</code>
for exponential, Matern, spherical and Gaussian covariance function respectively. Default value is <code>"exponential"</code>. </p>
</td></tr>
<tr><td><code id="BRISC_correlation_+3A_search.type">search.type</code></td>
<td>
<p>keyword that specifies type of nearest neighbor search algorithm to be used. Supported keywords are:
<code>"brute"</code>, <code>"tree"</code> and <code>"cb"</code>. <br /> <code>"brute"</code> and <code>"tree"</code> provide the same result, though
<code>"tree"</code> should be faster. <code>"cb"</code> implements fast code book search described in Ra and Kim (1993)
modified for NNGP. If locations do not have identical coordinate values on the axis used for the nearest neighbor
determination, then <code>"cb"</code> and <code>"brute"</code> should produce identical neighbor sets. However, if there are
identical coordinate values on the axis used for nearest neighbor determination, then <code>"cb"</code> and <code>"brute"</code>
might produce different, but equally valid neighbor sets, e.g., if data are on a grid. Default value is <code>"tree"</code>. </p>
</td></tr>
<tr><td><code id="BRISC_correlation_+3A_stabilization">stabilization</code></td>
<td>
<p>when we use a very smooth covarince model (lower values of phi for spherical and Gaussian
covariance and low phi and high nu for Matern covarinace) in absence of a non-negligble nugget, the correlation process may fail
due to computational instability. If <code>stabilization = TRUE</code>, performs stabilization by setting <code>tau.sq = </code> <code class="reqn">max{\code{tau
                      .sq}, \code{sigma.sq} * 1e-06}</code>. Default value is <code>TRUE</code> for <code>cov.model = "expoenential"</code> and <code>FALSE</code> otherwise. </p>
</td></tr>
<tr><td><code id="BRISC_correlation_+3A_verbose">verbose</code></td>
<td>
<p>if <code>TRUE</code>, model specifications along with information regarding OpenMP support and progress of the algorithm
is printed to the screen. Otherwise, nothing is printed to the screen. Default value is <code>TRUE</code>. </p>
</td></tr>
<tr><td><code id="BRISC_correlation_+3A_tol">tol</code></td>
<td>
<p>the input observation coordinates are rounded to this many places after the decimal. The default value is 12. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Denote <code class="reqn">g</code> be the input <code>sim</code>. Let <code class="reqn">\Sigma</code> be the precision matrix associated with the covariance model determined by the <code class="reqn">cov.model</code> and model parameters. Then <code>BRISC_correlation</code> calculates <code class="reqn">h</code>, where <code class="reqn">h</code> is given as follows:
</p>
<p style="text-align: center;"><code class="reqn">
S ^{-0.5} h = g
</code>
</p>

<p>where, <code class="reqn">S ^{-0.5}</code> is a sparse approximation of the cholesky factor <code class="reqn">\Sigma ^{-0.5}</code> of the precision matrix <code class="reqn">\Sigma ^{-1}</code>, obtained from NNGP.
</p>


<h3>Value</h3>

<p>A list comprising of the following:
</p>
<table>
<tr><td><code>coords</code></td>
<td>
<p>the matrix <code>coords</code>. </p>
</td></tr>
<tr><td><code>n.neighbors</code></td>
<td>
<p>the used value of <code>n.neighbors</code>. </p>
</td></tr>
<tr><td><code>cov.model</code></td>
<td>
<p>the used covariance model. </p>
</td></tr>
<tr><td><code>Theta</code></td>
<td>
<p>parameters of covarinace model; accounts for <code>stabilization</code>. </p>
</td></tr>
<tr><td><code>input.data</code></td>
<td>
<p>the matrix <code>sim</code>. </p>
</td></tr>
<tr><td><code>output.data</code></td>
<td>
<p>the output matrix <code class="reqn">h</code> in Details. </p>
</td></tr>
<tr><td><code>time</code></td>
<td>
<p>time (in seconds) required after preprocessing data in R, <br /> reported using,
<code>proc.time()</code>. </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Arkajyoti Saha <a href="mailto:arkajyotisaha93@gmail.com">arkajyotisaha93@gmail.com</a>, <br />
Abhirup Datta <a href="mailto:abhidatta@jhu.edu">abhidatta@jhu.edu</a>
</p>


<h3>References</h3>

<p>Datta, A., S. Banerjee, A.O. Finley, and A.E. Gelfand. (2016)
Hierarchical Nearest-Neighbor Gaussian process models for large
geostatistical datasets. Journal of the American Statistical
Association, 111:800-812.
</p>
<p>Andrew Finley, Abhirup Datta and Sudipto Banerjee (2017). spNNGP: Spatial Regression Models for Large
Datasets using Nearest Neighbor Gaussian Processes. R package version 0.1.1.
https://CRAN.R-project.org/package=spNNGP
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(1)
n &lt;- 1000
coords &lt;- cbind(runif(n,0,1), runif(n,0,1))

sigma.sq = 1
phi = 1

set.seed(1)
sim &lt;- matrix(rnorm(3*n),n, 3)
correlation_result &lt;- BRISC_correlation(coords, sigma.sq = sigma.sq,
                                        phi = phi, sim = sim)
</code></pre>

<hr>
<h2 id='BRISC_decorrelation'>Function for decorrelating data with BRISC</h2><span id='topic+BRISC_decorrelation'></span>

<h3>Description</h3>

<p>The function <code>BRISC_decorrelation</code> is used to decorrelate data (known structure) using Nearest Neighbor
Gaussian Processes (NNGP). <code>BRISC_decorrelation</code> uses the sparse Cholesky representation of Vecchiaâ€™s
likelihood developed in Datta et al., 2016. Some code blocks are borrowed from the R package: spNNGP:
Spatial Regression Models for Large Datasets using Nearest Neighbor Gaussian Processes
https://CRAN.R-project.org/package=spNNGP .
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BRISC_decorrelation(coords, sim, sigma.sq = 1, tau.sq = 0,
                    phi = 1, nu = 1.5, n.neighbors = NULL,
                    n_omp = 1, cov.model = "exponential",
                    search.type = "tree",
                    stabilization = NULL, verbose = TRUE,
                    tol = 12)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BRISC_decorrelation_+3A_coords">coords</code></td>
<td>
<p>an <code class="reqn">n \times 2</code> matrix of the observation
coordinates in <code class="reqn">R^2</code> (e.g., easting and northing). </p>
</td></tr>
<tr><td><code id="BRISC_decorrelation_+3A_sim">sim</code></td>
<td>
<p>an <code class="reqn">n \times k</code> matrix of the <code class="reqn">k</code> many <code class="reqn">n \times 1</code> vectors
from which the decorrelated data are calculated (see Details below). </p>
</td></tr>
<tr><td><code id="BRISC_decorrelation_+3A_sigma.sq">sigma.sq</code></td>
<td>
<p>value of sigma square. Default value is 1. </p>
</td></tr>
<tr><td><code id="BRISC_decorrelation_+3A_tau.sq">tau.sq</code></td>
<td>
<p>value of tau square. Default value is 0.1. </p>
</td></tr>
<tr><td><code id="BRISC_decorrelation_+3A_phi">phi</code></td>
<td>
<p>value of phi. Default value is 1. </p>
</td></tr>
<tr><td><code id="BRISC_decorrelation_+3A_nu">nu</code></td>
<td>
<p>value of nu, only required for Matern covariance model. Default value is 1.5. </p>
</td></tr>
<tr><td><code id="BRISC_decorrelation_+3A_n.neighbors">n.neighbors</code></td>
<td>
<p>number of neighbors used in the NNGP. Default value is <code class="reqn">max(100, n -1)</code>. We suggest a high value of
n.neighbors for lower value of phi. </p>
</td></tr>
<tr><td><code id="BRISC_decorrelation_+3A_n_omp">n_omp</code></td>
<td>
<p>number of threads to be used, value can be more than 1 if source code is compiled with OpenMP support.
Default is 1. </p>
</td></tr>
<tr><td><code id="BRISC_decorrelation_+3A_cov.model">cov.model</code></td>
<td>
<p>keyword that specifies the covariance function to be used in modelling the spatial dependence structure
among the observations. Supported keywords are: <code>"exponential"</code>, <code>"matern"</code>, <code>"spherical"</code>, and <code>"gaussian"</code>
for exponential, Matern, spherical and Gaussian covariance function respectively. Default value is <code>"exponential"</code>. </p>
</td></tr>
<tr><td><code id="BRISC_decorrelation_+3A_search.type">search.type</code></td>
<td>
<p>keyword that specifies type of nearest neighbor search algorithm to be used. Supported keywords are:
<code>"brute"</code>, <code>"tree"</code> and <code>"cb"</code>. <br /> <code>"brute"</code> and <code>"tree"</code> provide the same result, though
<code>"tree"</code> should be faster. <code>"cb"</code> implements fast code book search described in Ra and Kim (1993)
modified for NNGP. If locations do not have identical coordinate values on the axis used for the nearest neighbor
determination, then <code>"cb"</code> and <code>"brute"</code> should produce identical neighbor sets. However, if there are
identical coordinate values on the axis used for nearest neighbor determination, then <code>"cb"</code> and <code>"brute"</code>
might produce different, but equally valid neighbor sets, e.g., if data are on a grid. Default value is <code>"tree"</code>. </p>
</td></tr>
<tr><td><code id="BRISC_decorrelation_+3A_stabilization">stabilization</code></td>
<td>
<p>when the correlated data are generated from a very smooth covarince model (lower values of phi for spherical and Gaussian
covariance and low phi and high nu for Matern covarinace), the decorrelation process may fail due to computational
instability. If <code>stabilization = TRUE</code>, performs stabilization by adding a white noise to the data with
nugget <code>tau.sq = </code> <code>sigma.sq</code> * 1e-06. Default value is <code>TRUE</code> for <code>cov.model = "expoenential"</code> and <code>FALSE</code> otherwise. </p>
</td></tr>
<tr><td><code id="BRISC_decorrelation_+3A_verbose">verbose</code></td>
<td>
<p>if <code>TRUE</code>, model specifications along with information regarding OpenMP support and progress of the algorithm
is printed to the screen. Otherwise, nothing is printed to the screen. Default value is <code>TRUE</code>. </p>
</td></tr>
<tr><td><code id="BRISC_decorrelation_+3A_tol">tol</code></td>
<td>
<p>the input observation coordinates are rounded to this many places after the decimal. The default value is 12. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Denote <code class="reqn">h</code> be the input <code>sim</code>. Let <code class="reqn">\Sigma</code> be the covariance matrix associated with the covariance model determined by the <code class="reqn">cov.model</code> and model parameters. Then <code>BRISC_decorrelation</code> calculates <code class="reqn">g</code>, where <code class="reqn">g</code> is given as follows:
</p>
<p style="text-align: center;"><code class="reqn">
S ^{-0.5} h = g
</code>
</p>

<p>where, <code class="reqn">S ^{-0.5}</code> is a sparse approximation of the cholesky factor <code class="reqn">\Sigma ^{-0.5}</code> of the precision matrix <code class="reqn">\Sigma ^{-1}</code>, obtained from NNGP.
</p>


<h3>Value</h3>

<p>A list comprising of the following:
</p>
<table>
<tr><td><code>coords</code></td>
<td>
<p>the matrix <code>coords</code>. </p>
</td></tr>
<tr><td><code>n.neighbors</code></td>
<td>
<p>the used value of <code>n.neighbors</code>. </p>
</td></tr>
<tr><td><code>cov.model</code></td>
<td>
<p>the used covariance model. </p>
</td></tr>
<tr><td><code>Theta</code></td>
<td>
<p>parameters of covarinace model; accounts for <code>stabilization</code>. </p>
</td></tr>
<tr><td><code>input.data</code></td>
<td>
<p>if <code>stabilization = FALSE</code>, return the matrix <code>sim</code>. If <code>stabilization = TRUE</code>, returns <code>sim</code> + used white noise in stabilization process. </p>
</td></tr>
<tr><td><code>output.data</code></td>
<td>
<p>the output matrix <code class="reqn">g</code> in Details. </p>
</td></tr>
<tr><td><code>time</code></td>
<td>
<p>time (in seconds) required after preprocessing data in <code>R</code>, <br /> reported using,
<code>proc.time()</code>. </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Arkajyoti Saha <a href="mailto:arkajyotisaha93@gmail.com">arkajyotisaha93@gmail.com</a>, <br />
Abhirup Datta <a href="mailto:abhidatta@jhu.edu">abhidatta@jhu.edu</a>
</p>


<h3>References</h3>

<p>Datta, A., S. Banerjee, A.O. Finley, and A.E. Gelfand. (2016)
Hierarchical Nearest-Neighbor Gaussian process models for large
geostatistical datasets. Journal of the American Statistical
Association, 111:800-812.
</p>
<p>Andrew Finley, Abhirup Datta and Sudipto Banerjee (2017). spNNGP: Spatial Regression Models for Large
Datasets using Nearest Neighbor Gaussian Processes. R package version 0.1.1.
https://CRAN.R-project.org/package=spNNGP
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rmvn &lt;- function(n, mu = 0, V = matrix(1)){
  p &lt;- length(mu)
  if(any(is.na(match(dim(V),p))))
    stop("Dimension not right!")
  D &lt;- chol(V)
  t(matrix(rnorm(n*p), ncol=p)%*%D + rep(mu,rep(n,p)))
}

set.seed(1)
n &lt;- 1000
coords &lt;- cbind(runif(n,0,1), runif(n,0,1))

sigma.sq = 1
phi = 1

set.seed(1)
D &lt;- as.matrix(dist(coords))
R &lt;- exp(-phi*D)
sim &lt;- rmvn(3, rep(0,n), sigma.sq*R)
decorrelation_result &lt;- BRISC_decorrelation(coords, sim = sim)
</code></pre>

<hr>
<h2 id='BRISC_estimation'>Function for estimation with BRISC</h2><span id='topic+BRISC_estimation'></span>

<h3>Description</h3>

<p>The function <code>BRISC_estimation</code> fits univariate spatial regression models for large
spatial data using Vecchia's approximate likelihood (Vecchia, 1988). <code>BRISC_estimation</code>
uses the sparse Cholesky representation of Vecchiaâ€™s likelihood developed in Datta et al., 2016.
The Maximum Likelihood Estimates (MLE) of the parameters are used later for calculating the
confidence interval via the <code>BRISC_bootstrap</code> (BRISC, Saha &amp; Datta, 2018). <br /> We recommend
using <code>BRISC_estimation</code> followed by <code>BRISC_bootstrap</code> to obtain the confidence
intervals for the model parameters.
</p>
<p>The optimization is performed with C library of limited-memory BFGS
libLBFGS: a library of Limited-memory Broyden-Fletcher-Goldfarb-Shanno (L-BFGS), <br />
http://www.chokkan.org/software/liblbfgs/ (Naoaki Okazaki). For user convenience
the source codes of the package libLBFGS are provided in the package. The code for
the coordinate ordering method, approximate Maximum Minimum Distance (Guinness, 2018)
is available in <br /> https://github.com/joeguinness/gp_reorder/tree/master/R and is adopted
with minor modification. Some code blocks are borrowed from the R package: spNNGP:
Spatial Regression Models for Large Datasets using Nearest Neighbor Gaussian Processes
https://CRAN.R-project.org/package=spNNGP .
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BRISC_estimation(coords, y, x = NULL, sigma.sq = 1,
                 tau.sq = 0.1, phi = 1,
                 nu = 1.5, n.neighbors = 15,
                 n_omp = 1, order = "Sum_coords",
                 cov.model = "exponential",
                 search.type = "tree",
                 stabilization = NULL,
                 pred.stabilization = 1e-8,
                 verbose = TRUE, eps = 2e-05,
                 nugget_status = 1, ordering = NULL,
                 neighbor = NULL, tol = 12)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BRISC_estimation_+3A_coords">coords</code></td>
<td>
<p>an <code class="reqn">n \times 2</code> matrix of the observation
coordinates in <code class="reqn">R^2</code> (e.g., easting and northing). </p>
</td></tr>
<tr><td><code id="BRISC_estimation_+3A_y">y</code></td>
<td>
<p>an <code class="reqn">n</code> length vector of response at the observed coordinates. </p>
</td></tr>
<tr><td><code id="BRISC_estimation_+3A_x">x</code></td>
<td>
<p>an <code class="reqn">n \times p</code> matrix of the covariates in the observation coordinates. Default value is
<code class="reqn">n \times 1</code> matrix of <code class="reqn">1</code> to adjust for the mean(intercept). </p>
</td></tr>
<tr><td><code id="BRISC_estimation_+3A_sigma.sq">sigma.sq</code></td>
<td>
<p>starting value of sigma square. Default value is 1. </p>
</td></tr>
<tr><td><code id="BRISC_estimation_+3A_tau.sq">tau.sq</code></td>
<td>
<p>starting value of tau square. Default value is 0.1. </p>
</td></tr>
<tr><td><code id="BRISC_estimation_+3A_phi">phi</code></td>
<td>
<p>starting value of phi. Default value is 1. </p>
</td></tr>
<tr><td><code id="BRISC_estimation_+3A_nu">nu</code></td>
<td>
<p>starting value of nu, only required for matern covariance model. Default value is 1.5. </p>
</td></tr>
<tr><td><code id="BRISC_estimation_+3A_n.neighbors">n.neighbors</code></td>
<td>
<p>number of neighbors used in the NNGP. Default value is 15. </p>
</td></tr>
<tr><td><code id="BRISC_estimation_+3A_n_omp">n_omp</code></td>
<td>
<p>number of threads to be used, value can be more than 1 if source code is compiled with OpenMP support.
Default is 1. </p>
</td></tr>
<tr><td><code id="BRISC_estimation_+3A_order">order</code></td>
<td>
<p>keyword that specifies the ordering scheme to be used in ordering the observations. Supported keywords are:
<code>"AMMD"</code> and <code>"Sum_coords"</code> for approximate Maximum Minimum Distance and sum of coordinate based ordering,
respectively. Default value is <code>"Sum_coords"</code>. <code class="reqn">n &gt; 65</code> is required for <code>"AMMD"</code>. Ignored, if <code>"ordering"</code> in not <code>NULL</code>. </p>
</td></tr>
<tr><td><code id="BRISC_estimation_+3A_cov.model">cov.model</code></td>
<td>
<p>keyword that specifies the covariance function to be used in modelling the spatial dependence structure
among the observations. Supported keywords are: <code>"exponential"</code>, <code>"matern"</code>, <code>"spherical"</code>, and <code>"gaussian"</code>
for exponential, Matern, spherical and Gaussian covariance function respectively. Default value is &quot;exponential&quot;. </p>
</td></tr>
<tr><td><code id="BRISC_estimation_+3A_search.type">search.type</code></td>
<td>
<p>keyword that specifies type of nearest neighbor search algorithm to be used. Supported keywords are:
<code>"brute"</code>, <code>"tree"</code> and <code>"cb"</code>. <br /> <code>"brute"</code> and <code>"tree"</code> provide the same result, though
<code>"tree"</code> should be faster. <code>"cb"</code> implements fast code book search described in Ra and Kim (1993)
modified for NNGP. If locations do not have identical coordinate values on the axis used for the nearest neighbor
ordering (see <code>order</code> argument) then <code>"cb"</code> and <code>"brute"</code> should produce identical neighbor sets.
However, if there are identical coordinate values on the axis used for nearest neighbor ordering, then <code>"cb"</code>
and <code>"brute"</code> might produce different, but equally valid, neighbor sets, e.g., if data are on a grid.
Default value is <code>"tree"</code>. Ignored, if <code>"neighbor"</code> in not <code>NULL</code>. </p>
</td></tr>
<tr><td><code id="BRISC_estimation_+3A_stabilization">stabilization</code></td>
<td>
<p>when the spatial errors are generated from a very smooth covarince model (lower values of phi for spherical and Gaussian
covariance and low phi and high nu for Matern covarinace), the estimation process may fail due to computational
instability. If <code>stabilization = TRUE</code>, performs stabilization by adding a white noise to the reordered data with
nugget <code>tau.sq = </code> <code>sigma.sq</code> * 1e-06. Estimation is performed on this new data with <code>nugget_status = 1</code>
(see <code>nugget_status</code> argument below). Default value is <code>TRUE</code> for <code>cov.model = "expoenential"</code> and <code>FALSE</code> otherwise. </p>
</td></tr>
<tr><td><code id="BRISC_estimation_+3A_pred.stabilization">pred.stabilization</code></td>
<td>
<p>if not <code>NULL</code>, will truncate the estimated tau square to <code>pred.stabilization</code> * estimated sigma square.
This provides additional stability in <br /> <code>BRISC_prediction</code>. Default value is <code class="reqn">1e-8</code>. </p>
</td></tr>
<tr><td><code id="BRISC_estimation_+3A_verbose">verbose</code></td>
<td>
<p>if <code>TRUE</code>, model specifications along with information regarding OpenMP support and progress of the algorithm
is printed to the screen. Otherwise, nothing is printed to the screen. Default value is <code>TRUE</code>. </p>
</td></tr>
<tr><td><code id="BRISC_estimation_+3A_eps">eps</code></td>
<td>
<p>tolerance to be used in centred finite difference approximation of derivatives. Default value is 2e-05. </p>
</td></tr>
<tr><td><code id="BRISC_estimation_+3A_nugget_status">nugget_status</code></td>
<td>
<p>if <code>nugget_status = 0</code>, <code>tau.sq</code> is fixed to 0, if <code>nugget_status = 1</code> <code>tau.sq</code> is estimated. Default value is 1. </p>
</td></tr>
<tr><td><code id="BRISC_estimation_+3A_ordering">ordering</code></td>
<td>
<p>if <code>NULL</code>, the observed locations will be ordered following the scheme in <code>"order"</code>. If not <code>NULL</code>, the ordering step is bypassed and the input must denote the <code class="reqn">n</code> length integer vector of ordering of the input coordinates that is to be used as the ordering of the coordinates for determination of the set of nearest neighbors. Output from <code>BRISC_order</code> can be used here. </p>
</td></tr>
<tr><td><code id="BRISC_estimation_+3A_neighbor">neighbor</code></td>
<td>
<p>if <code>NULL</code>, neighbor set and corresponding information are created using the search type specified in <code>"search.type"</code>. If not <code>NULL</code>, the step of searching the neighbors is bypassed and the input must be an output from <code>BRISC_neighbor</code> with identical input in <code>"order"</code>, <code>"ordering"</code> and <code>"search.type"</code>. </p>
</td></tr>
<tr><td><code id="BRISC_estimation_+3A_tol">tol</code></td>
<td>
<p>the input observation coordinates, response and the covariates are rounded to this many places after the decimal. The default value is 12. </p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>BRISC_Out</code>, which is a list comprising:
</p>
<table>
<tr><td><code>ord</code></td>
<td>
<p>the vector of indices used to order data necessary for fitting the NNGP
model.</p>
</td></tr>
<tr><td><code>coords</code></td>
<td>
<p>the matrix <code>coords[ord,]</code>. </p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>If <code>stabilization = FALSE</code>, returns the vector <code>y[ord]</code>. <br /> If <code>stabilization = TRUE</code>, returns <code>y[ord]</code> + used white noise in stabilization process. </p>
</td></tr>
<tr><td><code>X</code></td>
<td>
<p>the matrix <code>x[ord,,drop=FALSE]</code>. </p>
</td></tr>
<tr><td><code>n.neighbors</code></td>
<td>
<p>the used value of <code>n.neighbors</code>. </p>
</td></tr>
<tr><td><code>cov.model</code></td>
<td>
<p>the used covariance model. </p>
</td></tr>
<tr><td><code>eps</code></td>
<td>
<p>value of used <code>eps</code> for approximate derivation. Default value is 2e-05. </p>
</td></tr>
<tr><td><code>init</code></td>
<td>
<p>initial values of the parameters of the covariance model; <br /> accounts for <code>stabilization</code>. </p>
</td></tr>
<tr><td><code>Beta</code></td>
<td>
<p>estimate of beta. </p>
</td></tr>
<tr><td><code>Theta</code></td>
<td>
<p>estimate of parameters of covarinace model. </p>
</td></tr>
<tr><td><code>log_likelihood</code></td>
<td>
<p>value of Vecchiaâ€™s approximate log likelihood with parameter estimates. </p>
</td></tr>
<tr><td><code>estimation.time</code></td>
<td>
<p>time (in seconds) required to perform the model fitting after ordering and preprocessing data in <code>R</code>,
reported using <code>proc.time()</code>. </p>
</td></tr>
<tr><td><code>BRISC_Object</code></td>
<td>
<p>object required for bootstrap and prediction. </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Arkajyoti Saha <a href="mailto:arkajyotisaha93@gmail.com">arkajyotisaha93@gmail.com</a>, <br />
Abhirup Datta <a href="mailto:abhidatta@jhu.edu">abhidatta@jhu.edu</a>
</p>


<h3>References</h3>

<p>Saha, A., &amp; Datta, A. (2018). BRISC: bootstrap for rapid inference on spatial
covariances. Stat, e184, DOI: 10.1002/sta4.184.
</p>
<p>Datta, A., S. Banerjee, A.O. Finley, and A.E. Gelfand. (2016)
Hierarchical Nearest-Neighbor Gaussian process models for large
geostatistical datasets. Journal of the American Statistical
Association, 111:800-812.
</p>
<p>Guinness, J. (2018) Permutation and Grouping Methods for
Sharpening Gaussian Process Approximations, Technometrics,
DOI: 10.1080/00401706.2018.1437476, <br />
https://github.com/joeguinness/gp_reorder/tree/master/R .
</p>
<p>Vecchia, A. V. (1988) Estimation and model identification for
continuous spatial processes. Journal of the Royal Statistical
Society. Series B (Methodological), 297-312.
</p>
<p>Okazaki N. libLBFGS: a library of Limited-memory Broyden-Fletcher-Goldfarb-Shanno
(L-BFGS), <br /> http://www.chokkan.org/software/liblbfgs/ .
</p>
<p>Andrew Finley, Abhirup Datta and Sudipto Banerjee (2020). spNNGP: Spatial Regression
Models for Large Datasets using Nearest Neighbor Gaussian Processes. R package version 0.1.4.
https://CRAN.R-project.org/package=spNNGP
</p>
<p>Ra, S. W., &amp; Kim, J. K. (1993). A fast mean-distance-ordered partial codebook search algorithm
for image vector quantization. IEEE Transactions on Circuits and Systems II: Analog and Digital
Signal Processing, 40(9), 576-579.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
rmvn &lt;- function(n, mu = 0, V = matrix(1)){
  p &lt;- length(mu)
  if(any(is.na(match(dim(V),p))))
    stop("Dimension not right!")
  D &lt;- chol(V)
  t(matrix(rnorm(n*p), ncol=p)%*%D + rep(mu,rep(n,p)))
}

set.seed(1)
n &lt;- 1000
coords &lt;- cbind(runif(n,0,1), runif(n,0,1))

beta &lt;- c(1,5)
x &lt;- cbind(rnorm(n), rnorm(n))

sigma.sq = 1
phi = 1
tau.sq = 0.1

B &lt;- as.matrix(beta)
D &lt;- as.matrix(dist(coords))
R &lt;- exp(-phi*D)
w &lt;- rmvn(1, rep(0,n), sigma.sq*R)

y &lt;- rnorm(n, x%*%B + w, sqrt(tau.sq))

estimation_result &lt;- BRISC_estimation(coords, y, x)
estimation_result$Theta ##Estimates of covariance model parameters.
estimation_result$Beta ##Estimates of Beta

</code></pre>

<hr>
<h2 id='BRISC_neighbor'>Function for finding set of nearest neighbors for BRISC</h2><span id='topic+BRISC_neighbor'></span>

<h3>Description</h3>

<p>The function <code>BRISC_neighbor</code> creates the set of nearest neighbors for a given set of coordinates, which can be used as an input
for <code>"neighbor"</code> argument in <code>BRISC_estimation</code>. This is especially useful for avoiding often computationally
intensive nearest neighbor finding scheme in case of multiple application of <code>BRISC_estimation</code> on a fixed set of
coordinates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BRISC_neighbor(coords, n.neighbors = 15, n_omp = 1,
               order = "Sum_coords", search.type = "tree",
               verbose = TRUE, ordering = NULL, tol = 12
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BRISC_neighbor_+3A_coords">coords</code></td>
<td>
<p>an <code class="reqn">n \times 2</code> matrix of the observation
coordinates in <code class="reqn">R^2</code> (e.g., easting and northing). </p>
</td></tr>
<tr><td><code id="BRISC_neighbor_+3A_n.neighbors">n.neighbors</code></td>
<td>
<p>number of neighbors used in the NNGP. Default value is 15. </p>
</td></tr>
<tr><td><code id="BRISC_neighbor_+3A_n_omp">n_omp</code></td>
<td>
<p>number of threads to be used, value can be more than 1 if source code is compiled with OpenMP support.
Default is 1. </p>
</td></tr>
<tr><td><code id="BRISC_neighbor_+3A_order">order</code></td>
<td>
<p>keyword that specifies the ordering scheme to be used in ordering the observations. Supported keywords are:
<code>"AMMD"</code> and <code>"Sum_coords"</code> for approximate Maximum Minimum Distance and sum of coordinate based ordering,
respectively. Default value is <code>"Sum_coords"</code>. <code class="reqn">n &gt; 65</code> is required for <code>"AMMD"</code>. Ignored, if <code>ordering</code> in not <code>NULL</code>. </p>
</td></tr>
<tr><td><code id="BRISC_neighbor_+3A_search.type">search.type</code></td>
<td>
<p>keyword that specifies type of nearest neighbor search algorithm to be used. Supported keywords are:
<code>"brute"</code>, <code>"tree"</code> and <code>"cb"</code>. <br /> <code>"brute"</code> and <code>"tree"</code> provide the same result, though
<code>"tree"</code> should be faster. <code>"cb"</code> implements fast code book search described in Ra and Kim (1993)
modified for NNGP. If locations do not have identical coordinate values on the axis used for the nearest neighbor
ordering (see <code>order</code> argument) then <code>"cb"</code> and <code>"brute"</code> should produce identical neighbor sets.
However, if there are identical coordinate values on the axis used for nearest neighbor ordering, then <code>"cb"</code>
and <code>"brute"</code> might produce different, but equally valid, neighbor sets, e.g., if data are on a grid.
Default value is <code>"tree"</code>. </p>
</td></tr>
<tr><td><code id="BRISC_neighbor_+3A_verbose">verbose</code></td>
<td>
<p>if <code>TRUE</code>, information regarding OpenMP support and progress of the algorithm
is printed to the screen. Otherwise, nothing is printed to the screen. Default value is <code>TRUE</code>. </p>
</td></tr>
<tr><td><code id="BRISC_neighbor_+3A_ordering">ordering</code></td>
<td>
<p>if not <code>NULL</code>, denotes the <code class="reqn">n</code> length integer vector of ordering of the input coordinates and is used as the ordering of the coordinates for determination of the set of nearest neighbors. </p>
</td></tr>
<tr><td><code id="BRISC_neighbor_+3A_tol">tol</code></td>
<td>
<p>the input observation coordinates, response and the covariates are rounded to this many places after the decimal. The default value is 12. </p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing information regarding nearest neighbors which can be used as an input
for <code>"neighbor"</code> argument in <code>BRISC_estimation</code>.
</p>


<h3>Author(s)</h3>

<p>Arkajyoti Saha <a href="mailto:arkajyotisaha93@gmail.com">arkajyotisaha93@gmail.com</a>, <br />
Abhirup Datta <a href="mailto:abhidatta@jhu.edu">abhidatta@jhu.edu</a>
</p>


<h3>References</h3>

<p>Saha, A., &amp; Datta, A. (2018). BRISC: bootstrap for rapid inference on spatial
covariances. Stat, e184, DOI: 10.1002/sta4.184.
</p>
<p>Datta, A., S. Banerjee, A.O. Finley, and A.E. Gelfand. (2016)
Hierarchical Nearest-Neighbor Gaussian process models for large
geostatistical datasets. Journal of the American Statistical
Association, 111:800-812.
</p>
<p>Guinness, J. (2018) Permutation and Grouping Methods for
Sharpening Gaussian Process Approximations, Technometrics,
DOI: 10.1080/00401706.2018.1437476, <br />
https://github.com/joeguinness/gp_reorder/tree/master/R .
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(1)
n &lt;- 1000
coords &lt;- cbind(runif(n,0,1), runif(n,0,1))


ordering_result &lt;- BRISC_order(coords)
</code></pre>

<hr>
<h2 id='BRISC_order'>Function for ordering coordinates with BRISC</h2><span id='topic+BRISC_order'></span>

<h3>Description</h3>

<p>The function <code>BRISC_order</code> outputs the ordering for a set of coordinates, which can be used as an input for
<code>"ordering"</code> argument in <code>BRISC_estimation</code>. This is especially useful for avoiding often computationally
intensive location ordering scheme in case of multiple application of <code>BRISC_estimation</code> on a fixed set of
coordinates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BRISC_order(coords, order = "Sum_coords", verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BRISC_order_+3A_coords">coords</code></td>
<td>
<p>an <code class="reqn">n \times 2</code> matrix of the observation
coordinates in <code class="reqn">R^2</code> (e.g., easting and northing). </p>
</td></tr>
<tr><td><code id="BRISC_order_+3A_order">order</code></td>
<td>
<p>keyword that specifies the ordering scheme to be used in ordering the observations. Supported keywords are:
<code>"AMMD"</code> and <code>"Sum_coords"</code> for approximate Maximum Minimum Distance and sum of coordinate based ordering,
respectively. Default value is <code>"Sum_coords"</code>. <code class="reqn">n &gt; 65</code> is required for <code>"AMMD"</code>.</p>
</td></tr>
<tr><td><code id="BRISC_order_+3A_verbose">verbose</code></td>
<td>
<p>if <code>TRUE</code>, progress of the algorithm is printed to the screen. Otherwise, nothing is printed to the screen.
Default value is <code>TRUE</code>. </p>
</td></tr>
</table>


<h3>Value</h3>

<p>An integer vector of ordering of the input coordinates which can be used as an input for
<code>"ordering"</code> argument in <code>BRISC_estimation</code>.
</p>


<h3>Author(s)</h3>

<p>Arkajyoti Saha <a href="mailto:arkajyotisaha93@gmail.com">arkajyotisaha93@gmail.com</a>, <br />
Abhirup Datta <a href="mailto:abhidatta@jhu.edu">abhidatta@jhu.edu</a>
</p>


<h3>References</h3>

<p>Saha, A., &amp; Datta, A. (2018). BRISC: bootstrap for rapid inference on spatial
covariances. Stat, e184, DOI: 10.1002/sta4.184.
</p>
<p>Datta, A., S. Banerjee, A.O. Finley, and A.E. Gelfand. (2016)
Hierarchical Nearest-Neighbor Gaussian process models for large
geostatistical datasets. Journal of the American Statistical
Association, 111:800-812.
</p>
<p>Guinness, J. (2018) Permutation and Grouping Methods for
Sharpening Gaussian Process Approximations, Technometrics,
DOI: 10.1080/00401706.2018.1437476, <br />
https://github.com/joeguinness/gp_reorder/tree/master/R .
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(1)
n &lt;- 1000
coords &lt;- cbind(runif(n,0,1), runif(n,0,1))


ordering_result &lt;- BRISC_order(coords)
</code></pre>

<hr>
<h2 id='BRISC_prediction'>Function for performing prediction with BRISC</h2><span id='topic+BRISC_prediction'></span>

<h3>Description</h3>

<p>The function <code>BRISC_prediction</code> performs fast prediction on a set of new locations with univariate
spatial regression models using Nearest Neighbor Gaussian Processes (NNGP) (Datta et al., 2016).
BRISC_prediction  uses the parameter estimates from <code>BRISC_estimation</code> for the prediction. Some
code blocks are borrowed from the R package: spNNGP: Spatial Regression Models for Large Datasets
using Nearest Neighbor Gaussian Processes <br /> https://CRAN.R-project.org/package=spNNGP .
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BRISC_prediction(BRISC_Out, coords.0, X.0 = NULL, n_omp = 1,
                 verbose = TRUE, tol = 12)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BRISC_prediction_+3A_brisc_out">BRISC_Out</code></td>
<td>
<p>an object of class <code>BRISC_Out</code>, obtained as an output of <br /> <code>BRISC_estimation</code>. </p>
</td></tr>
<tr><td><code id="BRISC_prediction_+3A_coords.0">coords.0</code></td>
<td>
<p>the spatial coordinates corresponding to prediction locations. Its structure should be same as that of coords
in <code>BRISC_estimation</code>. Default value is a column of <code class="reqn">1</code> to adjust for the mean (intercept). </p>
</td></tr>
<tr><td><code id="BRISC_prediction_+3A_x.0">X.0</code></td>
<td>
<p>the covariates for prediction locations. Its Structure should be identical (including intercept) with that of
covariates provided for estimation purpose in <code>BRISC_estimation</code>. </p>
</td></tr>
<tr><td><code id="BRISC_prediction_+3A_n_omp">n_omp</code></td>
<td>
<p>number of threads to be used, value can be more than 1 if source code is compiled with OpenMP support.
Default is 1. </p>
</td></tr>
<tr><td><code id="BRISC_prediction_+3A_verbose">verbose</code></td>
<td>
<p>if <code>TRUE</code>, model specifications along with information regarding OpenMP support and progress of the
algorithm is printed to the screen. Otherwise, nothing is printed to the screen. Default value is <code>TRUE</code>. </p>
</td></tr>
<tr><td><code id="BRISC_prediction_+3A_tol">tol</code></td>
<td>
<p>the coordinates and the covariates corresponding to the prediction locations are rounded to this many places after the decimal.
The default value is 12. </p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list comprising of the following:
</p>
<table>
<tr><td><code>prediction</code></td>
<td>
<p>predicted response corresponding to X.0 and coords.0. </p>
</td></tr>
<tr><td><code>prediction.ci</code></td>
<td>
<p>confidence intervals corresponding to the predictions. </p>
</td></tr>
<tr><td><code>prediction.time</code></td>
<td>
<p>time (in seconds) required to perform the prediction after preprocessing data in <code>R</code>, reported using
<code>proc.time()</code>. </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Arkajyoti Saha <a href="mailto:arkajyotisaha93@gmail.com">arkajyotisaha93@gmail.com</a>, <br />
Abhirup Datta <a href="mailto:abhidatta@jhu.edu">abhidatta@jhu.edu</a>
</p>


<h3>References</h3>

<p>Datta, A., S. Banerjee, A.O. Finley, and A.E. Gelfand. (2016)
Hierarchical Nearest-Neighbor Gaussian process models for large
geostatistical datasets. Journal of the American Statistical
Association, 111:800-812.
</p>
<p>Andrew Finley, Abhirup Datta and Sudipto Banerjee (2017). spNNGP: Spatial Regression Models for Large
Datasets using Nearest Neighbor Gaussian Processes. R package version 0.1.1.
https://CRAN.R-project.org/package=spNNGP
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
rmvn &lt;- function(n, mu = 0, V = matrix(1)){
  p &lt;- length(mu)
  if(any(is.na(match(dim(V),p))))
    stop("Dimension not right!")
  D &lt;- chol(V)
  t(matrix(rnorm(n*p), ncol=p)%*%D + rep(mu,rep(n,p)))
}

set.seed(1)
n &lt;- 500
coords &lt;- cbind(runif(n,0,1), runif(n,0,1))

beta &lt;- c(1,5)
x &lt;- cbind(rnorm(n), rnorm(n))

sigma.sq = 1
phi = 1
tau.sq = 0.1

B &lt;- as.matrix(beta)
D &lt;- as.matrix(dist(coords))
R &lt;- exp(-phi*D)
w &lt;- rmvn(1, rep(0,n), sigma.sq*R)

y &lt;- rnorm(n, x%*%B + w, sqrt(tau.sq))

estimation_result &lt;- BRISC_estimation(coords[1:400,], y[1:400], x[1:400,])
prediction_result &lt;- BRISC_prediction(estimation_result,
                                      coords[401:500,], x[401:500,])

</code></pre>

<hr>
<h2 id='BRISC_simulation'>Function to simulate data with BRISC</h2><span id='topic+BRISC_simulation'></span>

<h3>Description</h3>

<p>The function <code>BRISC_simulation</code> simulates correlated data (known structure) using Nearest Neighbor
Gaussian Processes (NNGP). <code>BRISC_simulation</code> uses the sparse Cholesky representation of Vecchiaâ€™s
likelihood developed in Datta et al., 2016. <code>BRISC_simulation</code> uses <code><a href="#topic+BRISC_correlation">BRISC_correlation</a></code>
for this purpose.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BRISC_simulation(coords, sim_number = 1,
                 seeds =  NULL, sigma.sq = 1,
                 tau.sq = 0, phi = 1, nu = 1.5,
                 n.neighbors = NULL, n_omp = 1,
                 cov.model = "exponential",
                 search.type = "tree",
                 stabilization = NULL,
                 verbose = TRUE, tol = 12)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BRISC_simulation_+3A_coords">coords</code></td>
<td>
<p>an <code class="reqn">n \times 2</code> matrix of the observation
coordinates in <code class="reqn">R^2</code> (e.g., easting and northing). </p>
</td></tr>
<tr><td><code id="BRISC_simulation_+3A_sim_number">sim_number</code></td>
<td>
<p>number of simulations. Default value is 1. </p>
</td></tr>
<tr><td><code id="BRISC_simulation_+3A_seeds">seeds</code></td>
<td>
<p>seeds which are used in generation of the initial independent data. Default value is <code>NULL</code>.
If non-null, the number of seeds must be equal to <code>sim_number</code>. </p>
</td></tr>
<tr><td><code id="BRISC_simulation_+3A_sigma.sq">sigma.sq</code></td>
<td>
<p>value of sigma square. Default value is 1. </p>
</td></tr>
<tr><td><code id="BRISC_simulation_+3A_tau.sq">tau.sq</code></td>
<td>
<p>value of tau square. Default value is 0.1. </p>
</td></tr>
<tr><td><code id="BRISC_simulation_+3A_phi">phi</code></td>
<td>
<p>value of phi. Default value is 1. </p>
</td></tr>
<tr><td><code id="BRISC_simulation_+3A_nu">nu</code></td>
<td>
<p>starting value of nu, only required for matern covariance model. Default value is 1.5. </p>
</td></tr>
<tr><td><code id="BRISC_simulation_+3A_n.neighbors">n.neighbors</code></td>
<td>
<p>number of neighbors used in the NNGP. Default value is 15. </p>
</td></tr>
<tr><td><code id="BRISC_simulation_+3A_n_omp">n_omp</code></td>
<td>
<p>number of threads to be used, value can be more than 1 if source code is compiled with OpenMP support.
Default is 1. </p>
</td></tr>
<tr><td><code id="BRISC_simulation_+3A_cov.model">cov.model</code></td>
<td>
<p>keyword that specifies the covariance function to be used in modelling the spatial dependence structure
among the observations. Supported keywords are: <code>"exponential"</code>, <code>"matern"</code>, <code>"spherical"</code>, and <code>"gaussian"</code>
for exponential, Matern, spherical and Gaussian covariance function respectively. Default value is <code>"exponential"</code>. </p>
</td></tr>
<tr><td><code id="BRISC_simulation_+3A_search.type">search.type</code></td>
<td>
<p>keyword that specifies type of nearest neighbor search algorithm to be used. Supported keywords are:
<code>"brute"</code>, <code>"tree"</code> and <code>"cb"</code>. <br /> <code>"brute"</code> and <code>"tree"</code> provide the same result, though
<code>"tree"</code> should be faster. <code>"cb"</code> implements fast code book search described in Ra and Kim (1993)
modified for NNGP. If locations do not have identical coordinate values on the axis used for the nearest neighbor
ordering (see <code>order</code> argument) then <code>"cb"</code> and <code>"brute"</code> should produce identical neighbor sets.
However, if there are identical coordinate values on the axis used for nearest neighbor ordering, then <code>"cb"</code>
and <code>"brute"</code> might produce different, but equally valid, neighbor sets, e.g., if data are on a grid.
Default value is <code>"tree"</code>. </p>
</td></tr>
<tr><td><code id="BRISC_simulation_+3A_stabilization">stabilization</code></td>
<td>
<p>when we use a very smooth covarince model (lower values of phi for spherical and Gaussian
covariance and low phi and high nu for Matern covarinace) in absence of a non-negligble nugget, the correlation process may fail
due to computational instability. If <code>stabilization = TRUE</code>, performs stabilization by setting <code>tau.sq = </code> <code class="reqn">max{\code{tau
                      .sq}, \code{sigma.sq} * 1e-06}</code>. Default value is <code>TRUE</code> for <code>cov.model = "expoenential"</code> and <code>FALSE</code> otherwise. </p>
</td></tr>
<tr><td><code id="BRISC_simulation_+3A_verbose">verbose</code></td>
<td>
<p>if <code>TRUE</code>, model specifications along with information regarding OpenMP support and progress of the algorithm
is printed to the screen. Otherwise, nothing is printed to the screen. Default value is <code>TRUE</code>. </p>
</td></tr>
<tr><td><code id="BRISC_simulation_+3A_tol">tol</code></td>
<td>
<p>the input observation coordinates are rounded to this many places after the decimal. The default value is 12. </p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list comprising of the following:
</p>
<table>
<tr><td><code>coords</code></td>
<td>
<p>the matrix <code>coords</code>. </p>
</td></tr>
<tr><td><code>n.neighbors</code></td>
<td>
<p>the used value of <code>n.neighbors</code>. </p>
</td></tr>
<tr><td><code>cov.model</code></td>
<td>
<p>the used covariance model. </p>
</td></tr>
<tr><td><code>Theta</code></td>
<td>
<p>parameters of covarinace model; accounts for <code>stabilization</code>. </p>
</td></tr>
<tr><td><code>input.data</code></td>
<td>
<p>the <code class="reqn">n \times sim_number</code> matrix of generated independent data. Here <code class="reqn">i^{th}</code> column
denotes the data corresponding to the <code class="reqn">i^{th}</code> simulation.  </p>
</td></tr>
<tr><td><code>output.data</code></td>
<td>
<p>the <code class="reqn">n \times sim_number</code> matrix of generated correlated data. Here <code class="reqn">i^{th}</code> column
denotes the data corresponding to the <code class="reqn">i^{th}</code> simulation.  </p>
</td></tr>
<tr><td><code>time</code></td>
<td>
<p>time (in seconds) required after preprocessing data in <code>R</code>, <br /> reported using,
<code>proc.time()</code>. </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Arkajyoti Saha <a href="mailto:arkajyotisaha93@gmail.com">arkajyotisaha93@gmail.com</a>, <br />
Abhirup Datta <a href="mailto:abhidatta@jhu.edu">abhidatta@jhu.edu</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(1)
n &lt;- 1000
coords &lt;- cbind(runif(n,0,1), runif(n,0,1))

sigma.sq = 1
phi = 1

simulation_result &lt;- BRISC_simulation(coords, sim_number = 3)

</code></pre>

<hr>
<h2 id='BRISC_variogram.ci'>Function for plotting estimated Variogram and confidence region</h2><span id='topic+BRISC_variogram.ci'></span>

<h3>Description</h3>

<p>The function <code>BRISC_variogram.ci</code> plots estimated Variogram and associated confience region.
<code>BRISC_variogram.ci</code> uses the parameter estimates from <code>BRISC_estimation</code> and associated confidence interval from <code>BRISC_bootstrap</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BRISC_variogram.ci(BRISC_Out, confidence_est,
                   plot.variogram = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BRISC_variogram.ci_+3A_brisc_out">BRISC_Out</code></td>
<td>
<p>an object of class <code>BRISC_Out</code>, obtained as an output of <br /> <code>BRISC_estimation</code>. </p>
</td></tr>
<tr><td><code id="BRISC_variogram.ci_+3A_confidence_est">confidence_est</code></td>
<td>
<p>bootstrp sample of the Theta parameters, obtained from <code>BRISC_bootstrap</code>. </p>
</td></tr>
<tr><td><code id="BRISC_variogram.ci_+3A_plot.variogram">plot.variogram</code></td>
<td>
<p>if <code>TRUE</code>, plots the variogram and the associated confidence region. Default is <code>FALSE</code>. </p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list comprising of the following:
</p>
<table>
<tr><td><code>variogram</code></td>
<td>
<p>variogram and associated confidence region corresponding to lag ranging from 0 to 20, evaluated at 0.01 frequency. </p>
</td></tr>
<tr><td><code>Plot</code></td>
<td>
<p>plots the Variogram and associated confidence region with legends. </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Arkajyoti Saha <a href="mailto:arkajyotisaha93@gmail.com">arkajyotisaha93@gmail.com</a>, <br />
Abhirup Datta <a href="mailto:abhidatta@jhu.edu">abhidatta@jhu.edu</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
rmvn &lt;- function(n, mu = 0, V = matrix(1)){
  p &lt;- length(mu)
  if(any(is.na(match(dim(V),p))))
    stop("Dimension not right!")
  D &lt;- chol(V)
  t(matrix(rnorm(n*p), ncol=p)%*%D + rep(mu,rep(n,p)))
}

set.seed(1)
n &lt;- 300
coords &lt;- cbind(runif(n,0,1), runif(n,0,1))

beta &lt;- c(1,5)
x &lt;- cbind(rnorm(n), rnorm(n))

sigma.sq = 1
phi = 5
tau.sq = 0.1

B &lt;- as.matrix(beta)
D &lt;- as.matrix(dist(coords))
R &lt;- exp(-phi*D)
w &lt;- rmvn(1, rep(0,n), sigma.sq*R)

y &lt;- rnorm(n, x%*%B + w, sqrt(tau.sq))

estimation_result &lt;- BRISC_estimation(coords, y, x)
bootstrap_result &lt;- BRISC_bootstrap(estimation_result, n_boot = 10)
varg &lt;- BRISC_variogram.ci(estimation_result,
                           bootstrap_result$boot.Theta,
                           plot.variogram = TRUE)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
