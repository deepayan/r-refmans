<!DOCTYPE html><html lang="en"><head><title>Help for package lme4breeding</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {lme4breeding}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#A.mat'>
<p>Additive relationship matrix</p></a></li>
<li><a href='#add.diallel.vars'><p>add.diallel.vars</p></a></li>
<li><a href='#adjBeta'><p>Adjusting fixed effects for intercept</p></a></li>
<li><a href='#atcg1234'>
<p>Letter to number converter</p></a></li>
<li><a href='#bbasis'><p>Function for creating B-spline basis functions (Eilers &amp; Marx, 2010)</p></a></li>
<li><a href='#build.HMM'>
<p>Build a hybrid marker matrix using parental genotypes from inbred individuals</p></a></li>
<li><a href='#DT_augment'>
<p>DT_augment design example.</p></a></li>
<li><a href='#DT_btdata'>
<p>Blue Tit Data for a Quantitative Genetic Experiment</p></a></li>
<li><a href='#DT_cornhybrids'>
<p>Corn crosses and markers</p></a></li>
<li><a href='#DT_cpdata'>
<p>Genotypic and Phenotypic data for a CP population</p></a></li>
<li><a href='#DT_example'>
<p>Broad sense heritability calculation.</p></a></li>
<li><a href='#DT_expdesigns'>
<p>Data for different experimental designs</p></a></li>
<li><a href='#DT_fulldiallel'>
<p>Full diallel data for corn hybrids</p></a></li>
<li><a href='#DT_gryphon'>
<p>Gryphon data from the Journal of Animal Ecology</p></a></li>
<li><a href='#DT_h2'>
<p>Broad sense heritability calculation.</p></a></li>
<li><a href='#DT_halfdiallel'>
<p>half diallel data for corn hybrids</p></a></li>
<li><a href='#DT_ige'>
<p>Data to fit indirect genetic effects.</p></a></li>
<li><a href='#DT_legendre'>
<p>Simulated data for random regression</p></a></li>
<li><a href='#DT_mohring'>
<p>Full diallel data for corn hybrids</p></a></li>
<li><a href='#DT_polyploid'>
<p>Genotypic and Phenotypic data for a potato polyploid population</p></a></li>
<li><a href='#DT_rice'><p>Rice lines dataset</p></a></li>
<li><a href='#DT_sleepstudy'>
<p>Reaction times in a sleep deprivation study</p></a></li>
<li><a href='#DT_technow'>
<p>Genotypic and Phenotypic data from single cross hybrids (Technow et al.,2014)</p></a></li>
<li><a href='#DT_wheat'><p>wheat lines dataset</p></a></li>
<li><a href='#DT_yatesoats'>
<p>Yield of oats in a split-block experiment</p></a></li>
<li><a href='#fillData'><p>Filling gaps for a dataset to balance</p></a></li>
<li><a href='#getMME'>
<p>Build the mixed model equations from a lmebreed object</p></a></li>
<li><a href='#imputev'><p>Imputing a numeric or character vector</p></a></li>
<li><a href='#leg'><p>Legendre polynomial matrix</p></a></li>
<li><a href='#lme4breeding-package'>
<p><strong>L</strong>inear <strong>m</strong>ixed <strong>e</strong>quations <strong>4</strong> <strong>B</strong>reeding</p>
<br />
</p></a></li>
<li><a href='#lmebreed'><p>Fit mixed-effects models incorporating relationships</p></a></li>
<li><a href='#lmebreed-class'><p>Relationship-based mixed-effects model fits</p></a></li>
<li><a href='#overlay'><p>Overlay Matrix</p></a></li>
<li><a href='#redmm'><p>Reduced Model Matrix</p></a></li>
<li><a href='#rrm'><p>reduced rank matrix</p></a></li>
<li><a href='#simage'><p>Image of sparsity between two variables</p></a></li>
<li><a href='#smm'><p>sparse model matrix</p></a></li>
<li><a href='#stackTrait'><p>Stacking traits in a dataset</p></a></li>
<li><a href='#tps'><p>Get Tensor Product Spline Mixed Model Incidence Matrices</p></a></li>
<li><a href='#umat'><p>Rotation matrix UDU' decomposition</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Version:</td>
<td>1.0.50</td>
</tr>
<tr>
<td>Date:</td>
<td>2025-01-16</td>
</tr>
<tr>
<td>Title:</td>
<td>Relationship-Based Mixed-Effects Models</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Giovanny Covarrubias-Pazaran &lt;cova_ruber@live.com.mx&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Fit relationship-based and customized mixed-effects models with complex variance-covariance structures using the 'lme4' machinery. The core computational algorithms are implemented using the
    'Eigen' 'C++' library for numerical linear algebra and 'RcppEigen' 'glue'.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R(&ge; 3.0.0), lme4 (&ge; 1.0), Matrix (&ge; 1.0), methods, crayon</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>LazyData:</td>
<td>yes</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Author:</td>
<td>Giovanny Covarrubias-Pazaran
    <a href="https://orcid.org/0000-0002-7194-3837"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Suggests:</td>
<td>rmarkdown, knitr, orthopolynom, RSpectra</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-01-18 00:16:58 UTC; giovannycovarrubias</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-01-18 00:00:06 UTC</td>
</tr>
</table>
<hr>
<h2 id='A.mat'>
Additive relationship matrix
</h2><span id='topic+A.mat'></span>

<h3>Description</h3>

<p>Calculates the realized additive relationship matrix. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>A.mat(X,min.MAF=NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="A.mat_+3A_x">X</code></td>
<td>

<p>Matrix (<code class="reqn">n \times m</code>) of unphased genotypes for <code class="reqn">n</code> lines and <code class="reqn">m</code> biallelic markers, 
coded as {-1,0,1}. Fractional (imputed) and missing values (NA) are allowed.
</p>
</td></tr>
<tr><td><code id="A.mat_+3A_min.maf">min.MAF</code></td>
<td>

<p>Minimum minor allele frequency. The A matrix is not sensitive to rare alleles, so by default only monomorphic markers are removed.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For vanraden method: the marker matrix is centered by subtracting column means <code class="reqn">M= X - ms</code> where ms is the coumn means. Then <code class="reqn">A=M M'/c</code>, where <code class="reqn">c = \sum_k{d_k}/k</code>, the mean value of the diagonal values of the <code class="reqn">M M'</code> portion.
</p>


<h3>Value</h3>

<p>If return.imputed = FALSE, the <code class="reqn">n \times n</code> additive relationship matrix is returned.
</p>
<p>If return.imputed = TRUE, the function returns a list containing
</p>

<dl>
<dt>$A</dt><dd><p>the A matrix</p>
</dd>
</dl>



<h3>References</h3>

<p>Giovanny Covarrubias-Pazaran (2024).  lme4breeding: enabling genetic evaluation in the age of genomic data. To be submitted to Bioinformatics.
</p>
<p>Douglas Bates, Martin Maechler, Ben Bolker, Steve Walker (2015). Fitting Linear Mixed-Effects Models Using lme4. Journal of Statistical Software, 67(1), 1-48.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lmebreed">lmebreed</a></code> &ndash; the core function of the package </p>


<h3>Examples</h3>

<pre><code class='language-R'>
## random population of 200 lines with 1000 markers
X &lt;- matrix(rep(0,200*1000),200,1000)
for (i in 1:200) {
  X[i,] &lt;- ifelse(runif(1000)&lt;0.5,-1,1)
}

A &lt;- A.mat(X)

 
## take a look at the Genomic relationship matrix 
 colfunc &lt;- colorRampPalette(c("steelblue4","springgreen","yellow"))
 hv &lt;- heatmap(A[1:15,1:15], col = colfunc(100),Colv = "Rowv")
 str(hv)
 

</code></pre>

<hr>
<h2 id='add.diallel.vars'>add.diallel.vars</h2><span id='topic+add.diallel.vars'></span>

<h3>Description</h3>

<p>'add.diallel.vars' adds 4 columns to the provided diallel dataset. Specifically, the user provides a dataset with indicator variables for who is the male and female parent and the function returns the same dataset with 4 new dummy variables to allow the model fit of diallel models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  add.diallel.vars(df, par1="Par1", par2="Par2",sep.cross="-")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="add.diallel.vars_+3A_df">df</code></td>
<td>
<p>a dataset with the two indicator variables for who is the male and female parent.</p>
</td></tr>
<tr><td><code id="add.diallel.vars_+3A_par1">par1</code></td>
<td>
<p>the name of the column indicating who is the first parent (e.g. male).</p>
</td></tr>
<tr><td><code id="add.diallel.vars_+3A_par2">par2</code></td>
<td>
<p>the name of the column indicating who is the second parent (e.g. female).</p>
</td></tr>
<tr><td><code id="add.diallel.vars_+3A_sep.cross">sep.cross</code></td>
<td>
<p>the character that should be used when creating the column for cross.id. A simple paste of the columns par1 and par2.</p>
</td></tr>
</table>


<h3>Value</h3>


<p>A new data set with the following 4 new dummy variables to allow the fit of complex diallel models:
</p>
<dl>
<dt>is.cross</dt><dd><p>returns a 0 if is a self and a 1 for a cross.</p>
</dd>
<dt>is.self</dt><dd><p>returns a 0 if is a cross and a 1 is is a self.</p>
</dd>
<dt>cross.type</dt><dd><p>returns a -1 for a direct cross, a 0 for a self and a 1 for a reciprocal cross.</p>
</dd>
<dt>cross.id</dt><dd><p>returns a column psting the par1 and par2 columns.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Giovanny Covarrubias-Pazaran
</p>


<h3>References</h3>

<p>Giovanny Covarrubias-Pazaran (2024).  lme4breeding: enabling genetic evaluation in the age of genomic data. To be submitted to Bioinformatics.
</p>
<p>Douglas Bates, Martin Maechler, Ben Bolker, Steve Walker (2015). Fitting Linear Mixed-Effects Models Using lme4. Journal of Statistical Software, 67(1), 1-48.
</p>


<h3>See Also</h3>

<p>The core function of the package <code><a href="#topic+lmebreed">lmebreed</a></code> function and the <code><a href="#topic+DT_mohring">DT_mohring</a></code> example. </p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(DT_mohring)
DT &lt;- DT_mohring
head(DT)
DT2 &lt;- add.diallel.vars(DT,par1="Par1", par2="Par2")
head(DT2)
## see ?DT_mohring for an example on how to use the data to fit diallel models.

</code></pre>

<hr>
<h2 id='adjBeta'>Adjusting fixed effects for intercept</h2><span id='topic+adjBeta'></span>

<h3>Description</h3>

<p>This function is a very simple function to add the intercept to all fixed effects except for the first term.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>adjBeta(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="adjBeta_+3A_x">x</code></td>
<td>
<p>a numeric vector with fixed effects extracted by the fixef function.</p>
</td></tr>
</table>


<h3>Value</h3>


<dl>
<dt>$x</dt><dd><p>a numeric vector with the intercept added to all fixed effects except for the first term which corresponds to the intercept.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Giovanny Covarrubias-Pazaran
</p>


<h3>References</h3>

<p>Giovanny Covarrubias-Pazaran (2024).  lme4breeding: enabling genetic evaluation in the age of genomic data. To be submitted to Bioinformatics.
</p>
<p>Douglas Bates, Martin Maechler, Ben Bolker, Steve Walker (2015). Fitting Linear Mixed-Effects Models Using lme4. Journal of Statistical Software, 67(1), 1-48.
</p>


<h3>See Also</h3>

<p>The core function of the package <code><a href="#topic+lmebreed">lmebreed</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(DT_example)
DT &lt;- DT_example
A &lt;- A_example

ansMain &lt;- lmebreed(Yield ~ Env + (1|Name),
                    relmat = list(Name = Matrix::chol(A) ),
                    data=DT)

fixef(ansMain)
adjBeta(fixef(ansMain))
</code></pre>

<hr>
<h2 id='atcg1234'>
Letter to number converter
</h2><span id='topic+atcg1234'></span>

<h3>Description</h3>

<p>This function was designed to help users to transform their data in letter format to numeric format. Details in the format are not complex, just a dataframe with markers in columns and individuals in rows. Only markers, NO extra columns of plant names etc (names of plants can be stored as rownames). The function expects a matrix of only polymorphic markers, please make sure you clean your data before using this function. The apply function can help you identify and separate monomorphic from polymorphic markers. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>atcg1234(data, ploidy=2, format="ATCG", maf=0, multi=TRUE, 
        silent=FALSE, by.allele=FALSE, imp=TRUE, ref.alleles=NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="atcg1234_+3A_data">data</code></td>
<td>
<p>a dataframe with markers in columns and individuals in rows. Preferable the rownames are the ID of the plants so you don't lose track of what is what.</p>
</td></tr>
<tr><td><code id="atcg1234_+3A_ploidy">ploidy</code></td>
<td>
<p>a numeric value indicating the ploidy level of the specie. The default is 2 which means diploid.</p>
</td></tr>
<tr><td><code id="atcg1234_+3A_format">format</code></td>
<td>
<p>one of the two possible values allowed by the program &quot;ATCG&quot;, which means your calls are in base-pair-letter code, i.e. &quot;AT&quot; in a diploid call, &quot;AATT&quot; tetraploid etc (just example). Therefore possible codes can be &quot;A&quot;, &quot;T&quot;, &quot;C&quot;, &quot;G&quot;, &quot;-&quot; (deletion), &quot;+&quot; (insertion). Alternatively &quot;AB&quot; format can be used as well. Commonly this depends from the genotyping technologies used, such as GBS or microarrays. In addition, we have enabled also the use of single-letter code used by Cornell, i.e. A=AA, C=CC, T=TT, G=GG, R=AG, Y=CT, S=CG, W=AT, K=GT, M=AC. In the case of GBS code please make sure that you set the N codes to regular NAs handled by R. The &quot;ATCG&quot; format also works for the bi-allelic marker codes from join map such as &quot;lm&quot;, &quot;ll&quot;,&quot;nn&quot;, &quot;np&quot;,&quot;hh&quot;,&quot;hk&quot;,&quot;kk&quot;</p>
</td></tr>
<tr><td><code id="atcg1234_+3A_maf">maf</code></td>
<td>
<p>minor allele frequency used to filter the SNP markers, the default is zero which means all markers are returned in numeric format.</p>
</td></tr>
<tr><td><code id="atcg1234_+3A_multi">multi</code></td>
<td>
<p>a TRUE/FALSE statement indicating if the function should get rid of the markers with more than 2 alleles. If FALSE, which indicates that if markers with multiple alleles are found, the alternate and reference alleles will be the first 2 alleles found. This could be risky since some alleles will be masked, i.e. AA AG AT would take only A and G as reference and alternate alleles, converting to numeric format 2 1 1, giving the same effect to AG and AT which could be a wrong assumption. The default is TRUE, removes markers with more than two alleles. </p>
</td></tr>
<tr><td><code id="atcg1234_+3A_silent">silent</code></td>
<td>
<p>a TRUE/FALSE value indicating if a progress bar should be drawn for each step of the conversion. The default is silent=FALSE, which means that we want progress bar to be drawn.</p>
</td></tr>
<tr><td><code id="atcg1234_+3A_by.allele">by.allele</code></td>
<td>
<p>a TRUE/FALSE value indicating if the program should transform the data in a zero/one matrix of presence/absense per allele. For example, a marker with 3 alleles A,T,C in a diploid organism will yield 6 possible configurations; AA, AT, AC, TT, TC, CC. Therefore, the program would create 3 columns for this marker indicating the presence/absence of each allele for each genotype. </p>
</td></tr>
<tr><td><code id="atcg1234_+3A_imp">imp</code></td>
<td>
<p>a TRUE/FALSE value indicating if the function should impute the missing data using the median for each marker. If FALSE, then the program will not impute.</p>
</td></tr>
<tr><td><code id="atcg1234_+3A_ref.alleles">ref.alleles</code></td>
<td>
<p>a matrix with reference alleles to be used for the conversion. The matrix should have as many columns as markers with reference alleles and with 2 rows, being the first row the alternate allele (Alt) and the second row the reference allele (Ref). Rownames should be &quot;Alt&quot; and &quot;Ref&quot; respectively. If not provided the program will decide the reference allele.</p>
</td></tr>
</table>


<h3>Value</h3>


<dl>
<dt>$data</dt><dd><p> a new dataframe of markers in numeric format with markers in columns and individuals in rows.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Giovanny Covarrubias-Pazaran
</p>


<h3>See Also</h3>

<p>The core function of the package <code><a href="#topic+lmebreed">lmebreed</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(DT_polyploid)
genotypes &lt;- GT_polyploid
genotypes[1:5,1:5] # look the original format


## convert markers to numeric format polyploid potatoes
numo &lt;- atcg1234(data=genotypes, ploidy=4)
numo$M[1:5,1:5]

## convert markers to numeric format diploid rice lines
## single letter code for inbred lines from GBS pipeline
## A=AA, T=TT, C=CC, G=GG 

data(DT_rice)
X &lt;- GT_rice; X[1:5,1:5]; dim(X)
numo2 &lt;- atcg1234(data=X, ploidy=2)
numo2$M[1:5,1:5]


</code></pre>

<hr>
<h2 id='bbasis'>Function for creating B-spline basis functions (Eilers &amp; Marx, 2010)</h2><span id='topic+bbasis'></span>

<h3>Description</h3>

<p>Construct a B-spline basis of degree <code>deg</code>
with <code>ndx-</code>1 equally-spaced internal knots (<code>ndx</code> segments) on range [<code>x1</code>,<code>xr</code>].
Code copied from Eilers &amp; Marx 2010, WIR: Comp Stat 2, 637-653.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bbasis(x, xl, xr, ndx, deg)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bbasis_+3A_x">x</code></td>
<td>
<p>A vector. Data values for spline.</p>
</td></tr>
<tr><td><code id="bbasis_+3A_xl">xl</code></td>
<td>
<p>A numeric value. Lower bound for data (lower external knot).</p>
</td></tr>
<tr><td><code id="bbasis_+3A_xr">xr</code></td>
<td>
<p>A numeric value. Upper bound for data (upper external knot).</p>
</td></tr>
<tr><td><code id="bbasis_+3A_ndx">ndx</code></td>
<td>
<p>A numeric value. Number of divisions for x range
(equal to number of segments = number of internal knots + 1)</p>
</td></tr>
<tr><td><code id="bbasis_+3A_deg">deg</code></td>
<td>
<p>A numeric value. Degree of the polynomial spline.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Not yet amended to coerce values that should be zero to zero!
</p>


<h3>Value</h3>

<p>A matrix with columns holding the P-spline for each value of x.
Matrix has <code>ndx+deg</code> columns and <code>length(x)</code> rows.
</p>

<hr>
<h2 id='build.HMM'>
Build a hybrid marker matrix using parental genotypes from inbred individuals
</h2><span id='topic+build.HMM'></span>

<h3>Description</h3>

<p>Uses the 2 marker matrices from both sets of inbred or partially inbred parents and creates all possible combinations unless the user specifies which hybrid genotypes to build (custom.hyb argument). It returns the additive and dominance marker matrices (-1,0,1; homo,het,homo in additive and 0,1,0; homo,het,homo for dominance).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>build.HMM(M1,M2, custom.hyb=NULL, return.combos.only=FALSE,separator=":")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="build.HMM_+3A_m1">M1</code></td>
<td>

<p>Matrix (<code class="reqn">n \times m</code>) of unphased genotypes for <code class="reqn">n</code> inbreds and <code class="reqn">m</code> biallelic markers, 
coded as {-1,0,1}. Fractional (imputed) and missing values (NA) are not allowed.
</p>
</td></tr>
<tr><td><code id="build.HMM_+3A_m2">M2</code></td>
<td>

<p>Matrix (<code class="reqn">n \times m</code>) of unphased genotypes for <code class="reqn">n</code> inbreds and <code class="reqn">m</code> biallelic markers, 
coded as {-1,0,1}. Fractional (imputed) and missing values (NA) are not allowed.
</p>
</td></tr>
<tr><td><code id="build.HMM_+3A_custom.hyb">custom.hyb</code></td>
<td>

<p>A data frame with columns 'Var1' 'Var2', 'hybrid' which specifies which hybrids should be built using the M1 and M2 matrices provided.
</p>
</td></tr>
<tr><td><code id="build.HMM_+3A_return.combos.only">return.combos.only</code></td>
<td>

<p>A TRUE/FALSE statement inicating if the function should skip building the geotype matrix for hybrids and only return the data frame with all possible combinations to be build. In case the user wants to subset the hybrids before building the marker matrix.
</p>
</td></tr>
<tr><td><code id="build.HMM_+3A_separator">separator</code></td>
<td>

<p>Any desired character to be used when pasting the male and female columns to assign the name to the hybrids.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It returns the marker matrix for hybrids coded as additive (-1,0,1; homo,het,homo) and dominance (0,1,0; homo,het,homo). This function is deviced for building marker matrices for hybrids coming from inbreds. If the parents are close to inbred &gt;F5 you can try deleting the heterozygote calls (0's) and imputing those cells with the most common genotype (1 or -1). The expectation is that for mostly inbred individuals this may not change drastically the result but will make the results more interpretable. For non-inbred parents (F1 to F3) the cross of an F1 x F1 has many possibilities and is not the intention of this function to build genotypes for heterzygote x heterozygote crosses.
</p>


<h3>Value</h3>

<p>It returns the marker matrix for hybrids coded as additive (-1,0,1; homo,het,homo) and dominance (0,1,0; homo,het,homo).
</p>

<dl>
<dt>$HMM.add</dt><dd><p>marker matrix for hybrids coded as additive (-1,0,1; homo,het,homo)</p>
</dd>
<dt>$HMM.dom</dt><dd><p>marker matrix for hybrids coded as dominance (0,1,0; homo,het,homo)</p>
</dd>
<dt>$data.used</dt><dd><p>the data frame used to build the hybrid genotypes</p>
</dd>
</dl>



<h3>References</h3>

<p>Giovanny Covarrubias-Pazaran (2024).  lme4breeding: enabling genetic evaluation in the age of genomic data. To be submitted to Bioinformatics.
</p>
<p>Douglas Bates, Martin Maechler, Ben Bolker, Steve Walker (2015). Fitting Linear Mixed-Effects Models Using lme4. Journal of Statistical Software, 67(1), 1-48.
</p>
<p>Nishio M and Satoh M. 2014. Including Dominance Effects in the Genomic BLUP Method for Genomic Evaluation. Plos One 9(1), doi:10.1371/journal.pone.0085792
</p>
<p>Su G, Christensen OF, Ostersen T, Henryon M, Lund MS. 2012. Estimating Additive and Non-Additive Genetic Variances and Predicting Genetic Merits Using Genome-Wide Dense Single Nucleotide Polymorphism Markers. PLoS ONE 7(9): e45293. doi:10.1371/journal.pone.0045293
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lmebreed">lmebreed</a></code>&ndash; the core function of the package </p>


<h3>Examples</h3>

<pre><code class='language-R'>
## use Technow data as example
data(DT_technow)
DT &lt;- DT_technow
Md &lt;- (Md_technow * 2) - 1
Mf &lt;- (Mf_technow * 2) - 1

## first get all possible hybrids
res1 &lt;- build.HMM(Md, Mf, 
                  return.combos.only = TRUE)
head(res1$data.used)
use &lt;- which(res1$data.used$hybrid %in% DT$hy)
## build the marker matrix for the first 50 hybrids
res2 &lt;- build.HMM(Md, Mf,
                 custom.hyb = res1$data.used[use[1:10],]
                 )
res2$HMM.add[1:5,1:5]
res2$HMM.dom[1:5,1:5]


## now you can use the A.mat()
M &lt;- res2$HMM.add
A &lt;- A.mat(M)


</code></pre>

<hr>
<h2 id='DT_augment'>
DT_augment design example.
</h2><span id='topic+DT_augment'></span>

<h3>Description</h3>

<p>This dataset contains phenotpic data for one trait evaluated in the experimental design known as augmented design. This model allows to obtain BLUPs for genotypes that are unreplicated by dividing the field in blocks and replicating 'check genotypes' in the blocks and unreplicated genotypes randomly within the blocks. The presence of check genotypes (usually cultivars) allows the adjustment of unreplicated genotypes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("DT_augment")</code></pre>


<h3>Format</h3>

<p>The format is:
chr &quot;DT_augment&quot;
</p>


<h3>Source</h3>

<p>This data was generated by a potato study.
</p>


<h3>References</h3>

<p>Giovanny Covarrubias-Pazaran (2024).  lme4breeding: enabling genetic evaluation in the age of genomic data. To be submitted to Bioinformatics.
</p>
<p>Douglas Bates, Martin Maechler, Ben Bolker, Steve Walker (2015). Fitting Linear Mixed-Effects Models Using lme4. Journal of Statistical Software, 67(1), 1-48.
</p>


<h3>See Also</h3>

<p>The core functions of the package <code><a href="#topic+lmebreed">lmebreed</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>
## AUGMENTED DESIGN EXAMPLE
data(DT_augment)
DT &lt;- DT_augment
head(DT)

## fit the mixed model and check summary
mix1 &lt;- lmebreed(TSW ~ Check.Gen + (1|Block) + (1|Genotype:Check),
             data=DT)
vc &lt;- VarCorr(mix1); print(vc,comp=c("Variance"))


</code></pre>

<hr>
<h2 id='DT_btdata'>
Blue Tit Data for a Quantitative Genetic Experiment
</h2><span id='topic+DT_btdata'></span>

<h3>Description</h3>

<p>a data frame with 828 rows and 7 columns, with variables tarsus length (tarsus) and colour (back) measured on 828 individuals (animal). The mother of each is also recorded (dam) together with the foster nest (fosternest) in which the chicks were reared. The date on which the first egg in each nest hatched (hatchdate) is recorded together with the sex (sex) of the individuals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("DT_btdata")</code></pre>


<h3>Format</h3>

<p>The format is:
chr &quot;DT_btdata&quot;
</p>


<h3>References</h3>

<p>Giovanny Covarrubias-Pazaran (2024).  lme4breeding: enabling genetic evaluation in the age of genomic data. To be submitted to Bioinformatics.
</p>
<p>Douglas Bates, Martin Maechler, Ben Bolker, Steve Walker (2015). Fitting Linear Mixed-Effects Models Using lme4. Journal of Statistical Software, 67(1), 1-48.
</p>


<h3>See Also</h3>

<p>The core function of the package <code><a href="#topic+lmebreed">lmebreed</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(DT_btdata)
DT &lt;- DT_btdata
head(DT)



mix4 &lt;- lmebreed(tarsus ~ sex + (1|dam) + (1|fosternest),
             data = DT)
vc &lt;- VarCorr(mix4); print(vc,comp=c("Variance"))



</code></pre>

<hr>
<h2 id='DT_cornhybrids'>
Corn crosses and markers
</h2><span id='topic+DT_cornhybrids'></span><span id='topic+DTi_cornhybrids'></span><span id='topic+GT_cornhybrids'></span>

<h3>Description</h3>

<p>This dataset contains phenotpic data for plant height and grain yield for 100 out of 400 possible hybrids originated from 40 inbred lines belonging to 2 heterotic groups, 20 lines in each, 1600 rows exist for the 400 possible hybrids evaluated in 4 locations but only 100 crosses have phenotypic information.  The purpose of this data is to show how to predict the other 300 crosses.
</p>
<p>The data contains 3 elements. The first is the phenotypic data and the parent information for each cross evaluated in the 4 locations. 1200 rows should have missing data but the 100 crosses performed were chosen to be able to estimate the GCA and SCA effects of everything.
</p>
<p>The second element of the data set is the phenotypic data and other relevant information for the 40.
</p>
<p>The third element is the genomic relationship matrix for the 40 inbred lines originated from 511 SNP markers and calculated using the A.mat function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("DT_cornhybrids")</code></pre>


<h3>Format</h3>

<p>The format is:
chr &quot;DT_cornhybrids&quot;
</p>


<h3>Source</h3>

<p>This data was generated by a corn study.
</p>


<h3>References</h3>

<p>Giovanny Covarrubias-Pazaran (2024).  lme4breeding: enabling genetic evaluation in the age of genomic data. To be submitted to Bioinformatics.
</p>
<p>Douglas Bates, Martin Maechler, Ben Bolker, Steve Walker (2015). Fitting Linear Mixed-Effects Models Using lme4. Journal of Statistical Software, 67(1), 1-48.
</p>


<h3>See Also</h3>

<p>The core function of the package <code><a href="#topic+lmebreed">lmebreed</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(DT_cornhybrids)
DT &lt;- DT_cornhybrids
GT &lt;- GT_cornhybrids
A &lt;- GT
K1 &lt;- A[levels(DT$GCA1), levels(DT$GCA1)]; dim(K1)
K2 &lt;- A[levels(DT$GCA2), levels(DT$GCA2)]; dim(K2)


S &lt;- kronecker(K1, K2) ; dim(S)
rownames(S) &lt;- colnames(S) &lt;- levels(DT$SCA)

ans &lt;- lmebreed(Yield ~ Location + (1| GCA1) + (1|GCA2),
                relmat = list(GCA1=K1,
                              GCA2=K2),
                data=DT)
vc &lt;- VarCorr(ans); print(vc,comp=c("Variance"))



</code></pre>

<hr>
<h2 id='DT_cpdata'>
Genotypic and Phenotypic data for a CP population
</h2><span id='topic+DT_cpdata'></span><span id='topic+GT_cpdata'></span><span id='topic+MP_cpdata'></span>

<h3>Description</h3>

<p>A CP population or F1 cross is the designation for a cross between 2 highly heterozygote individuals; i.e. humans, fruit crops, bredding populations in recurrent selection.
</p>
<p>This dataset contains phenotpic data for 363 siblings for an F1 cross. These are averages over 2 environments evaluated for 4 traits; color, yield, fruit average weight, and firmness. The columns in the CPgeno file are the markers whereas the rows are the individuals. The CPpheno data frame contains the measurements for the 363 siblings, and as mentioned before are averages over 2 environments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("DT_cpdata")</code></pre>


<h3>Format</h3>

<p>The format is:
chr &quot;DT_cpdata&quot;
</p>


<h3>Source</h3>

<p>This data was simulated for fruit breeding applications.
</p>


<h3>References</h3>

<p>Giovanny Covarrubias-Pazaran (2024).  lme4breeding: enabling genetic evaluation in the age of genomic data. To be submitted to Bioinformatics.
</p>
<p>Douglas Bates, Martin Maechler, Ben Bolker, Steve Walker (2015). Fitting Linear Mixed-Effects Models Using lme4. Journal of Statistical Software, 67(1), 1-48.
</p>


<h3>See Also</h3>

<p>The core function of the package <code><a href="#topic+lmebreed">lmebreed</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(DT_cpdata)
DT &lt;- DT_cpdata
GT &lt;- GT_cpdata
MP &lt;- MP_cpdata
## create the variance-covariance matrix
A &lt;- A.mat(GT) # additive relationship matrix
A &lt;- A + diag(1e-4, ncol(A), ncol(A))
## look at the data and fit the model
head(DT)



mix1 &lt;- lmebreed(Yield~ (1|id) + (1|Rowf) + (1|Colf),
                 relmat=list(id=A),
                 control = lmerControl(
                   check.nobs.vs.nlev = "ignore",
                   check.nobs.vs.rankZ = "ignore",
                   check.nobs.vs.nRE="ignore"
                 ),
                 data=DT)
vc &lt;- VarCorr(mix1); print(vc,comp=c("Variance"))
# run one last iteration with imputed data
# to make sure you get predictions for everyone
DT2 &lt;- DT
DT2$Yield &lt;- imputev(DT2$Yield)
mix1b &lt;- update(mix1, data=DT2,
                control=lmerControl(
  check.nobs.vs.nlev = "ignore",
  check.nobs.vs.rankZ = "ignore",
  check.nobs.vs.nRE="ignore",
  optCtrl=list(maxfun=1)
))
rex &lt;- ranef(mix1b)



</code></pre>

<hr>
<h2 id='DT_example'>
Broad sense heritability calculation.
</h2><span id='topic+DT_example'></span><span id='topic+A_example'></span>

<h3>Description</h3>

<p>This dataset contains phenotpic data for 41 potato lines evaluated in 3 environments in an RCBD design. The phenotypic trait is tuber quality and we show how to obtain an estimate of DT_example for the trait.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("DT_example")</code></pre>


<h3>Format</h3>

<p>The format is:
chr &quot;DT_example&quot;
</p>


<h3>Source</h3>

<p>This data was generated by a potato study.
</p>


<h3>References</h3>

<p>Giovanny Covarrubias-Pazaran (2024).  lme4breeding: enabling genetic evaluation in the age of genomic data. To be submitted to Bioinformatics.
</p>
<p>Douglas Bates, Martin Maechler, Ben Bolker, Steve Walker (2015). Fitting Linear Mixed-Effects Models Using lme4. Journal of Statistical Software, 67(1), 1-48.
</p>


<h3>See Also</h3>

<p>The core functions of the package <code><a href="#topic+lmebreed">lmebreed</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(DT_example)
DT &lt;- DT_example
A &lt;- A_example
head(DT)

## Compound simmetry (CS) model
ans1 &lt;- lmebreed(Yield~Env + (1|Name) + (1|Env:Name),
             data=DT)
vc &lt;- VarCorr(ans1); print(vc,comp=c("Variance"))

BLUP &lt;- ranef(ans1, condVar=TRUE)$Name
SEs &lt;- attr(BLUP, which="postVar")[,,]



## Compound simmetry (CS) + Diagonal (DIAG) model
## with relationship matrix
Z &lt;- with(DT, smm(Env))
csdiagFormula &lt;- paste0( "Yield ~ Env + (", paste(colnames(Z), collapse = "+"), "|| Name)")
for(i in 1:ncol(Z)){DT[,colnames(Z)[i]] &lt;- Z[,i]}
ansCSDG &lt;- lmebreed(as.formula(csdiagFormula),
                    relmat = list(Name = A ),
                    data=DT)
vc &lt;- VarCorr(ansCSDG); print(vc,comp=c("Variance"))

## Compound simmetry (CS) + Diagonal (DIAG) model
## with diagonal residuals
## with relationship matrix
Z &lt;- with(DT, smm(Env))
DT$units &lt;- as.factor(1:nrow(DT))
csdiagFormula &lt;- paste0( "Yield ~ Env",
                        "+(", paste(colnames(Z), collapse = "+"), "|| Name)",
                        "+(0+ ",paste(colnames(Z), collapse = "+"), "|| units)")
for(i in 1:ncol(Z)){DT[,colnames(Z)[i]] &lt;- Z[,i]}
ansCSDG &lt;- lmebreed(as.formula(csdiagFormula),
                    relmat = list(Name = A ),
                    control = lmerControl(
                      check.nobs.vs.nlev = "ignore",
                      check.nobs.vs.rankZ = "ignore",
                      check.nobs.vs.nRE="ignore"
                    ),
                    data=DT)
vc &lt;- VarCorr(ansCSDG); print(vc,comp=c("Variance"))



</code></pre>

<hr>
<h2 id='DT_expdesigns'>
Data for different experimental designs
</h2><span id='topic+DT_expdesigns'></span>

<h3>Description</h3>

<p>The following data is a list containing data frames for different type of experimental designs relevant in plant breeding:
</p>
<p>1) Augmented designs (2 examples)
</p>
<p>2) Incomplete block designs (1 example)
</p>
<p>3) Split plot design (2 examples)
</p>
<p>4) Latin square designs (1 example)
</p>
<p>5) North Carolina designs I,II and III
</p>
<p>How to fit each is shown at the Examples section. This may help you get introduced to experimental designs relevant to plant breeding. Good luck.
</p>


<h3>Format</h3>

<p>Different based on the design.
</p>


<h3>Source</h3>

<p>Datasets and more detail about them can be found in the agricolae package. Here we just show the datasets and how to analyze them using the <code><a href="#topic+lme4breeding">lme4breeding</a></code> package.
</p>


<h3>References</h3>

<p>Giovanny Covarrubias-Pazaran (2024).  lme4breeding: enabling genetic evaluation in the age of genomic data. To be submitted to Bioinformatics.
</p>
<p>Douglas Bates, Martin Maechler, Ben Bolker, Steve Walker (2015). Fitting Linear Mixed-Effects Models Using lme4. Journal of Statistical Software, 67(1), 1-48.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(DT_expdesigns)
DT &lt;- DT_expdesigns
names(DT)
data1 &lt;- DT$au1
head(data1)
## response variable: "yield"
## check indicator: "entryc" ('nc' for all unreplicated, but personal.name for checks)
## blocking factor: "block"
## treatments, personal names for replicated and non-replicated: "trt"
## check no check indicator: "new"
mix1 &lt;- lmebreed(yield~entryc + (1|block)+(1|trt),
             data=data1)
vc &lt;- VarCorr(mix1); print(vc,comp=c("Variance"))

</code></pre>

<hr>
<h2 id='DT_fulldiallel'>
Full diallel data for corn hybrids
</h2><span id='topic+DT_fulldiallel'></span>

<h3>Description</h3>

<p>This dataset contains phenotpic data for 36 winter bean hybrids, coming from a full diallel design and evaluated for 9 traits. The column male and female origin columns are included as well. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("DT_fulldiallel")</code></pre>


<h3>Format</h3>

<p>The format is:
chr &quot;DT_fulldiallel&quot;
</p>


<h3>Source</h3>

<p>This data was generated by a winter bean study and originally included in the agridat package.
</p>


<h3>References</h3>

<p>Giovanny Covarrubias-Pazaran (2024).  lme4breeding: enabling genetic evaluation in the age of genomic data. To be submitted to Bioinformatics.
</p>
<p>Douglas Bates, Martin Maechler, Ben Bolker, Steve Walker (2015). Fitting Linear Mixed-Effects Models Using lme4. Journal of Statistical Software, 67(1), 1-48.
</p>


<h3>See Also</h3>

<p>The core function of the package <code><a href="#topic+lmebreed">lmebreed</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(DT_fulldiallel)
DT &lt;- DT_fulldiallel
head(DT)
mix &lt;- lmebreed(stems~1 + (1|female)+(1|male), data=DT)
vc &lt;- VarCorr(mix); print(vc,comp=c("Variance"))


</code></pre>

<hr>
<h2 id='DT_gryphon'>
Gryphon data from the Journal of Animal Ecology
</h2><span id='topic+DT_gryphon'></span><span id='topic+A_gryphon'></span><span id='topic+P_gryphon'></span>

<h3>Description</h3>

<p>This is a dataset that was included in the Journal of animal ecology by Wilson et al. (2010; see references) to help users understand how to use mixed models with animal datasets with pedigree data. 
</p>
<p>The dataset contains 3 elements:
</p>
<p>gryphon; variables indicating the animal, the mother of the animal, sex of the animal, and two quantitative traits named 'BWT' and 'TARSUS'.
</p>
<p>pedi; dataset with 2 columns indicating the sire and the dam of the animals contained in the gryphon dataset.
</p>
<p>A; additive relationship matrix formed using the 'getA()' function used over the pedi dataframe.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("DT_gryphon")</code></pre>


<h3>Format</h3>

<p>The format is:
chr &quot;DT_gryphon&quot;
</p>


<h3>Source</h3>

<p>This data comes from the Journal of Animal Ecology. Please, if using this data cite Wilson et al. publication. If using our mixed model solver please cite Covarrubias' publication.
</p>


<h3>References</h3>

<p>Wilson AJ, et al. (2010) An ecologist's guide to the animal model. Journal of Animal Ecology 79(1): 13-26.
</p>
<p>Giovanny Covarrubias-Pazaran (2024).  lme4breeding: enabling genetic evaluation in the age of genomic data. To be submitted to Bioinformatics.
</p>
<p>Douglas Bates, Martin Maechler, Ben Bolker, Steve Walker (2015). Fitting Linear Mixed-Effects Models Using lme4. Journal of Statistical Software, 67(1), 1-48.
</p>


<h3>See Also</h3>

<p>The core function of the package <code><a href="#topic+lmebreed">lmebreed</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(DT_gryphon)
DT &lt;- DT_gryphon
A &lt;- A_gryphon
P &lt;- P_gryphon
#### look at the data
head(DT)



## fit the model with no fixed effects (intercept only)
mix1 &lt;- lmebreed(BWT~ (1|ANIMAL),
                 relmat = list(ANIMAL=A),
                 control = lmerControl(
                   check.nobs.vs.nlev = "ignore",
                   check.nobs.vs.rankZ = "ignore",
                   check.nobs.vs.nRE="ignore"
                 ),
                 data=DT)
vc &lt;- VarCorr(mix1); print(vc,comp=c("Variance"))



</code></pre>

<hr>
<h2 id='DT_h2'>
Broad sense heritability calculation.
</h2><span id='topic+DT_h2'></span>

<h3>Description</h3>

<p>This dataset contains phenotpic data for 41 potato lines evaluated in 5 locations across 3 years in an RCBD design. The phenotypic trait is tuber quality and we show how to obtain an estimate of DT_h2 for the trait.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("DT_h2")</code></pre>


<h3>Format</h3>

<p>The format is:
chr &quot;DT_h2&quot;
</p>


<h3>Source</h3>

<p>This data was generated by a potato study.
</p>


<h3>References</h3>

<p>Giovanny Covarrubias-Pazaran (2024).  lme4breeding: enabling genetic evaluation in the age of genomic data. To be submitted to Bioinformatics.
</p>
<p>Douglas Bates, Martin Maechler, Ben Bolker, Steve Walker (2015). Fitting Linear Mixed-Effects Models Using lme4. Journal of Statistical Software, 67(1), 1-48.
</p>


<h3>See Also</h3>

<p>The core function of the package <code><a href="#topic+lmebreed">lmebreed</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(DT_h2)
DT &lt;- DT_h2
head(DT)



DT=DT[with(DT, order(Env)), ]

Z &lt;- with(DT, smm(Env))
for(i in 1:ncol(Z)){DT[,colnames(Z)[i]] &lt;- Z[,i]}
csdiagFormula &lt;- paste0( "y ~ Env + (", paste(colnames(Z), collapse = "+"), "|| Name)")
blockFormula &lt;- paste0( "(0+", paste(colnames(Z), collapse = "+"), "|| Block)")
form &lt;- paste(csdiagFormula , blockFormula, sep="+")

ans1b &lt;- lmebreed(as.formula(form),
                  data=DT)
vc &lt;- VarCorr(ans1b); print(vc,comp=c("Variance"))




</code></pre>

<hr>
<h2 id='DT_halfdiallel'>
half diallel data for corn hybrids
</h2><span id='topic+DT_halfdiallel'></span>

<h3>Description</h3>

<p>This dataset contains phenotpic data for 21 corn hybrids, with 2 technical repetitions, coming from a half diallel design and evaluated for sugar content. The column geno indicates the hybrid and male and female origin columns are included as well.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("DT_halfdiallel")</code></pre>


<h3>Format</h3>

<p>The format is:
chr &quot;DT_halfdiallel&quot;
</p>


<h3>Source</h3>

<p>This data was generated by a corn study.
</p>


<h3>References</h3>

<p>Giovanny Covarrubias-Pazaran (2024).  lme4breeding: enabling genetic evaluation in the age of genomic data. To be submitted to Bioinformatics.
</p>
<p>Douglas Bates, Martin Maechler, Ben Bolker, Steve Walker (2015). Fitting Linear Mixed-Effects Models Using lme4. Journal of Statistical Software, 67(1), 1-48.
</p>


<h3>See Also</h3>

<p>The core function of the package <code><a href="#topic+lmebreed">lmebreed</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>
data("DT_halfdiallel")
DT &lt;- DT_halfdiallel
head(DT)
DT$femalef &lt;- as.factor(DT$female)
DT$malef &lt;- as.factor(DT$male)
DT$genof &lt;- as.factor(DT$geno)
# overlay matrix to be added to the addmat argument
Z &lt;- with(DT, overlay(femalef,malef) )
## inital values for incidence matrix but irrelevant
## since these will be replaced by admat argument
fema &lt;- (rep(colnames(Z), nrow(DT)))[1:nrow(DT)]
## model using overlay without relationship matrix
modh &lt;- lmebreed(sugar ~ (1|genof) + (1|fema),
                 addmat = list(fema=Z),
             data=DT)
vc &lt;- VarCorr(modh); print(vc,comp=c("Variance"))



## model using overlay with relationship matrix
## relationship matrix to be added to the relmat argument
A &lt;- diag(7); colnames(A) &lt;- rownames(A) &lt;- 1:7;A
modh &lt;- lmebreed(sugar ~ (1|genof) + (1|fema),
                 addmat = list(fema=Z),
                 relmat = list(fema=A),
                 data=DT)
vc &lt;- VarCorr(modh); print(vc,comp=c("Variance"))



</code></pre>

<hr>
<h2 id='DT_ige'>
Data to fit indirect genetic effects.
</h2><span id='topic+DT_ige'></span><span id='topic+A_ige'></span>

<h3>Description</h3>

<p>This dataset contains phenotpic data for 98 individuals where they are measured with the purpose of identifying the effect of the neighbour in a focal individual. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("DT_ige")</code></pre>


<h3>Format</h3>

<p>The format is:
chr &quot;DT_ige&quot;
</p>


<h3>Source</h3>

<p>This data was masked from a shared study.
</p>


<h3>References</h3>

<p>Giovanny Covarrubias-Pazaran (2024).  lme4breeding: enabling genetic evaluation in the age of genomic data. To be submitted to Bioinformatics.
</p>
<p>Douglas Bates, Martin Maechler, Ben Bolker, Steve Walker (2015). Fitting Linear Mixed-Effects Models Using lme4. Journal of Statistical Software, 67(1), 1-48.
</p>


<h3>See Also</h3>

<p>The core function of the package <code><a href="#topic+lmebreed">lmebreed</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(DT_ige)
DT &lt;- DT_ige
# Indirect genetic effects model without covariance between DGE and IGE
modIGE &lt;- lmebreed(trait ~ block + (1|focal) + (1|neighbour),
              data = DT)
vc &lt;- VarCorr(modIGE); print(vc,comp=c("Variance"))




## Add relationship matrices
A_ige &lt;- A_ige + diag(1e-4, ncol(A_ige), ncol(A_ige) )
modIGE &lt;- lmebreed(trait ~ block + (1|focal) + (1|neighbour),
                   relmat = list(focal=A_ige,
                                 neighbour=A_ige),
                   data = DT)
vc &lt;- VarCorr(modIGE); print(vc,comp=c("Variance"))

## Indirect genetic effects model with covariance between DGE and IGE using relationship matrices
## Relationship matrix
A_ige &lt;- A_ige + diag(1e-4, ncol(A_ige), ncol(A_ige) )
## Define 2 dummy variables to make a fake covariance
## for two different random effects
DT$fn &lt;- DT$nn &lt;- 1
## Create the incidence matrix for the first random effect
Zf &lt;- Matrix::sparse.model.matrix( ~ focal-1, data=DT )
colnames(Zf) &lt;- gsub("focal","", colnames(Zf))
## Create the incidence matrix for the second random effect
Zn &lt;- Matrix::sparse.model.matrix( ~ neighbour-1, data=DT )
colnames(Zn) &lt;- gsub("neighbour","", colnames(Zn))
## Make inital values for incidence matrix but irrelevant
## since these will be replaced by the addmat argument
both &lt;- (rep(colnames(Zf), nrow(DT)))[1:nrow(DT)]
## Fit the model
modIGE &lt;- lmebreed(trait ~ block + (0+fn+nn|both),
                   addmat = list(both=list(Zf,Zn)),
                   relmat = list(both=A_ige),
                   data = DT)
vc &lt;- VarCorr(modIGE); print(vc,comp=c("Variance"))

blups &lt;- ranef(modIGE)
pairs(blups$both)
cov2cor(vc$both)




</code></pre>

<hr>
<h2 id='DT_legendre'>
Simulated data for random regression
</h2><span id='topic+DT_legendre'></span>

<h3>Description</h3>

<p>A data frame with 4 columns; SUBJECT, X, Xf and Y to show how to use the Legendre polynomials in the lmebreed function using a numeric variable X and a response variable Y. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("DT_legendre")</code></pre>


<h3>Format</h3>

<p>The format is:
chr &quot;DT_legendre&quot;
</p>


<h3>Source</h3>

<p>This data was simulated for fruit breeding applications.
</p>


<h3>References</h3>

<p>Giovanny Covarrubias-Pazaran (2024).  lme4breeding: enabling genetic evaluation in the age of genomic data. To be submitted to Bioinformatics.
</p>
<p>Douglas Bates, Martin Maechler, Ben Bolker, Steve Walker (2015). Fitting Linear Mixed-Effects Models Using lme4. Journal of Statistical Software, 67(1), 1-48.
</p>


<h3>See Also</h3>

<p>The core function of the package <code><a href="#topic+lmebreed">lmebreed</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(DT_legendre)
DT &lt;- DT_legendre
head(DT)



library(orthopolynom)
Z &lt;- with(DT, smm(leg(X,1)) )
## diagonal random regression
form &lt;- paste0( "Y ~ Xf + (0+", paste(colnames(Z), collapse = "+"), "|| SUBJECT)")
## unstructured random regression
form &lt;- paste0( "Y ~ Xf + (0+", paste(colnames(Z), collapse = "+"), "| SUBJECT)")
for(i in 1:ncol(Z)){DT[,colnames(Z)[i]] &lt;- Z[,i]}
mRR2b&lt;-lmebreed(as.formula(form),
           , data=DT)
vc &lt;- VarCorr(mRR2b); print(vc,comp=c("Variance"))




</code></pre>

<hr>
<h2 id='DT_mohring'>
Full diallel data for corn hybrids
</h2><span id='topic+DT_mohring'></span>

<h3>Description</h3>

<p>This dataset contains phenotpic data for 36 winter bean hybrids, coming from a full diallel design and evaluated for 9 traits. The column male and female origin columns are included as well.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("DT_mohring")</code></pre>


<h3>Format</h3>

<p>The format is:
chr &quot;DT_mohring&quot;
</p>


<h3>Source</h3>

<p>This data was generated by a winter bean study and originally included in the agridat package.
</p>


<h3>References</h3>

<p>Giovanny Covarrubias-Pazaran (2024).  lme4breeding: enabling genetic evaluation in the age of genomic data. To be submitted to Bioinformatics.
</p>
<p>Douglas Bates, Martin Maechler, Ben Bolker, Steve Walker (2015). Fitting Linear Mixed-Effects Models Using lme4. Journal of Statistical Software, 67(1), 1-48.
</p>


<h3>See Also</h3>

<p>The core function of the package <code><a href="#topic+lmebreed">lmebreed</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>

data(DT_mohring)
DT &lt;- DT_mohring
head(DT)
DT2 &lt;- add.diallel.vars(DT,par1="Par1", par2="Par2")
head(DT2)
## is.cross denotes a hybrid (1)
## is.self denotes an inbred (1)
## cross.type denotes one way (-1, e.g. AxB) and reciprocal (1, e.g., BxA) and no cross (0)
## cross.id denotes the name of the cross (same name for direct &amp; reciprocal)

## GRIFFING MODEL 2 with reciprocal effects ###########################
## overlay matrix to be added to the addmat argument
Z &lt;- with(DT, overlay(Par1, Par2) )
fema &lt;- (rep(colnames(Z), nrow(Z)))[1:nrow(Z)]
mod1h &lt;- lmebreed(Ftime ~ 1 + (1|Block) +
                    ## GCA male &amp; female overlayed
                    (1|fema) +
                    ## SCA effects (includes cross and selfs)
                    (cross.type||cross.id),
                  addmat=list(fema=Z),
                  data=DT2 )
vc &lt;- VarCorr(mod1h); print(vc,comp=c("Variance"))

##                                    VarComp VarCompSE   Zratio
## Block.Ftime-Ftime                  0.00000   9.32181 0.000000
## overlay(Par1, Par2).Ftime-Ftime 1276.73089 750.17269 1.701916
## cross.id.Ftime-Ftime            1110.99090 330.16921 3.364914
## cross.id:cross.type.Ftime-Ftime   66.02295  49.26876 1.340057
## units.Ftime-Ftime                418.47949  74.56442 5.612321
##



## GRIFFING MODEL 2, no reciprocal effects ##############################
mod1h &lt;- lmebreed(Ftime ~ Block + is.cross +
                    ## GCA male &amp; female overlayed main and rr
                    ## GCA effect (calculated only in hybrids; remaining variance)
                    (is.cross||fema) +
                    ## SCA effect (calculated in hybrids only)
                    (0+is.cross||cross.id),
                  addmat=list(fema=Z),
                  data=DT2 )
vc &lt;- VarCorr(mod1h); print(vc,comp=c("Variance"))

##                                           VarComp  VarCompSE   Zratio
## overlay(Par1, Par2).Ftime-Ftime          2304.1781 1261.63193 1.826347
## overlay(Par1, Par2):is.cross.Ftime-Ftime  613.6040  402.74347 1.523560
## cross.id:is.cross.Ftime-Ftime             340.7030  148.56225 2.293335
## units.Ftime-Ftime                         501.6275   74.36075 6.745864
##
## GRIFFING MODEL 3, no reciprocal effects ###############################
mod1h &lt;- lmebreed(Ftime ~ Block + is.cross +
                    ## GCAC (only for hybrids)
                    (0+is.cross||fema) +
                    ## male GCA (only for inbreds)
                    (0+is.self||Par1) +
                    ## SCA (for hybrids only)
                    (0+is.cross||cross.id),
                  addmat=list(fema=Z),
                  data=DT2 )
vc &lt;- VarCorr(mod1h); print(vc,comp=c("Variance"))

##                                           VarComp  VarCompSE   Zratio
## overlay(Par1, Par2):is.cross.Ftime-Ftime  927.7895  537.91218 1.724797
## Par1:is.self.Ftime-Ftime                 9960.9247 5456.58188 1.825488
## cross.id:is.cross.Ftime-Ftime             341.4567  148.53667 2.298804
## units.Ftime-Ftime                         498.5974   73.92066 6.745035
##
## GRIFFING MODEL 2, with reciprocal effects #############################
## In Mohring: mixed model 3 reduced
mod1h &lt;- lmebreed(Ftime ~ Block + is.cross +
                    ## GCAC (for hybrids only)
                    (0+is.cross||fema) +
                    ## male GCA (for selfs only)
                    (0+is.self||Par1) +
                    ## SCA (for hybrids only)
                    (0+is.cross||cross.id)+
                    ## SCAR reciprocal effects (remaning SCA variance)
                    (0+cross.type||cross.id),
                  addmat=list(fema=Z),
                  data=DT2 )
vc &lt;- VarCorr(mod1h); print(vc,comp=c("Variance"))

##                                             VarComp  VarCompSE   Zratio
## overlay(Par1, Par2):is.cross.Ftime-Ftime   927.78742  537.89981 1.724833
## Par1:is.self.Ftime-Ftime                 10001.78854 5456.47578 1.833013
## cross.id:is.cross.Ftime-Ftime              361.89712  148.54264 2.436318
## cross.id:cross.type.Ftime-Ftime             66.43695   49.24492 1.349113
## units.Ftime-Ftime                          416.82960   74.27202 5.612203
##
## GRIFFING MODEL 3, with RGCA + RSCA ####################################
## In Mohring: mixed model 3
mod1h &lt;- lmebreed(Ftime ~ Block + is.cross +
                    ## GCAC (for hybrids only)
                    (0+is.cross||fema) +
                    ## RGCA: exclude selfs (to identify reciprocal GCA effects)
                    (0+cross.type||fema) +
                    ## male GCA (for selfs only)
                    (0+is.self||Par1) +
                    ## SCA (for hybrids only)
                    (0+is.cross||cross.id)+
                    ## SCAR reciprocal effects (remaning SCA variance)
                    (0+cross.type||cross.id),
                  addmat=list(fema=Z),
                  data=DT2 )
vc &lt;- VarCorr(mod1h); print(vc,comp=c("Variance"))

##                                            VarComp  VarCompSE    Zratio
## overlay(Par1, Par2):is.cross.Ftime-Ftime   927.7843  537.88164 1.7248857
## Par1:is.self.Ftime-Ftime                 10001.7570 5456.30125 1.8330654
## cross.id:is.cross.Ftime-Ftime              361.8958  148.53670 2.4364068
## overlay(Par1, Par2):cross.type.Ftime-Ftime  17.9799   19.92428 0.9024114
## cross.id:cross.type.Ftime-Ftime             30.9519   46.43908 0.6665054
## units.Ftime-Ftime                         416.09922  447.2101 0.93043333




</code></pre>

<hr>
<h2 id='DT_polyploid'>
Genotypic and Phenotypic data for a potato polyploid population
</h2><span id='topic+DT_polyploid'></span><span id='topic+GT_polyploid'></span><span id='topic+MP_polyploid'></span>

<h3>Description</h3>

<p>This dataset contains phenotpic data for 18 traits measured in 187 individuals from a potato diversity panel. In addition contains genotypic data for 221 individuals genotyped with 3522 SNP markers. Please if using this data for your own research make sure you cite Rosyara's (2015) publication (see References).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("DT_polyploid")</code></pre>


<h3>Format</h3>

<p>The format is:
chr &quot;DT_polyploid&quot;
</p>


<h3>Source</h3>

<p>This data was extracted from Rosyara (2016).
</p>


<h3>References</h3>

<p>If using this data for your own research please cite:
</p>
<p>Rosyara Umesh R., Walter S. De Jong, David S. Douches, Jeffrey B. Endelman. Software for genome-wide association studies in autopolyploids and its application to potato. The Plant Genome 2015.
</p>
<p>Giovanny Covarrubias-Pazaran (2024).  lme4breeding: enabling genetic evaluation in the age of genomic data. To be submitted to Bioinformatics.
</p>
<p>Douglas Bates, Martin Maechler, Ben Bolker, Steve Walker (2015). Fitting Linear Mixed-Effects Models Using lme4. Journal of Statistical Software, 67(1), 1-48.
</p>


<h3>See Also</h3>

<p>The core functions of the package <code><a href="#topic+lmebreed">lmebreed</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(DT_polyploid)
DT &lt;- DT_polyploid
GT &lt;- GT_polyploid
MP &lt;- MP_polyploid
## convert markers to numeric format
numo &lt;- atcg1234(data=GT[,1:100], ploidy=4);
numo$M[1:5,1:5];
numo$ref.allele[,1:5]



## plants with both genotypes and phenotypes
common &lt;- intersect(DT$Name,rownames(numo$M))

## get the markers and phenotypes for such inds
marks &lt;- numo$M[common,]; marks[1:5,1:5]
DT2 &lt;- DT[match(common,DT$Name),];
DT2 &lt;- as.data.frame(DT2)
DT2[1:5,]

## Additive relationship matrix, specify ploidy
A &lt;- A.mat(marks)

## run as mixed model
A &lt;- A + diag(1e-4,ncol(A),ncol(A))
ans &lt;- lmebreed(tuber_shape~ (1|Name),
                relmat = list(Name=A),
                control = lmerControl(
                  check.nobs.vs.nlev = "ignore",
                  check.nobs.vs.rankZ = "ignore",
                  check.nobs.vs.nRE="ignore"
                ),
                data=DT2)
vc &lt;- VarCorr(ans); print(vc,comp=c("Variance"))



</code></pre>

<hr>
<h2 id='DT_rice'>Rice lines dataset</h2><span id='topic+DT_rice'></span><span id='topic+GT_rice'></span><span id='topic+GTn_rice'></span>

<h3>Description</h3>

<p>Information from a collection of 413 rice lines.  The DT_rice data set is from 
Rice Diversity Org. Program. The lines are genotyped with 36,901 SNP markers and phenotyped for more than 30 traits. This data set was included in the package to play with it. If using it for your research make sure you cite the original publication from Zhao et al.(2011).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  data(DT_rice)
</code></pre>


<h3>Format</h3>

<p>RicePheno contains the phenotypes
RiceGeno contains genotypes letter code
RiceGenoN contains the genotypes in numerical code using atcg1234 converter function
</p>


<h3>Source</h3>

<p>Rice Diversity Organization
http://www.ricediversity.org/data/index.cfm.
</p>


<h3>References</h3>

<p>Keyan Zhao, Chih-Wei Tung, Georgia C. Eizenga, Mark H. Wright, M. Liakat Ali, Adam H. Price, Gareth J. Norton, M. Rafiqul Islam, Andy Reynolds, Jason Mezey, Anna M. McClung, Carlos D. Bustamante &amp; Susan R. McCouch (2011). Genome-wide association mapping reveals a rich genetic architecture of complex traits in Oryza sativa. Nat Comm 2:467 DOI: 10.1038/ncomms1467, Published Online 13 Sep 2011.
</p>
<p>Giovanny Covarrubias-Pazaran (2024).  lme4breeding: enabling genetic evaluation in the age of genomic data. To be submitted to Bioinformatics.
</p>
<p>Douglas Bates, Martin Maechler, Ben Bolker, Steve Walker (2015). Fitting Linear Mixed-Effects Models Using lme4. Journal of Statistical Software, 67(1), 1-48.
</p>


<h3>See Also</h3>

<p>The core function of the package <code><a href="#topic+lmebreed">lmebreed</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(DT_rice)
DT &lt;- DT_rice
GT &lt;- GT_rice
GTn &lt;- GTn_rice
head(DT)
M &lt;- atcg1234(GT)



### univariate model
A &lt;- A.mat(M$M)
A &lt;- A + diag(1e-4, ncol(A), ncol(A))
mix &lt;- lmebreed(Protein.content ~ (1|geno),
                relmat = list(geno=A),
                control = lmerControl(
                  check.nobs.vs.nlev = "ignore",
                  check.nobs.vs.rankZ = "ignore",
                  check.nobs.vs.nRE="ignore"
                ),
                data=DT)
vc &lt;- VarCorr(mix); print(vc,comp=c("Variance"))

### multi-trait model
DT2 &lt;- stackTrait(data=DT, traits = colnames(DT)[3:12])$long
DT2$trait &lt;- as.factor(DT2$trait)
head(DT2)
system.time(
  mix &lt;- lmebreed(valueS ~ (0+trait|geno),
                  relmat = list(geno=A),
                  control = lmerControl(
                    check.nobs.vs.nlev = "ignore",
                    check.nobs.vs.rankZ = "ignore",
                    check.nobs.vs.nRE="ignore"
                  ), rotation = TRUE,
                  data=DT2)
)
vc &lt;- VarCorr(mix); print(vc,comp=c("Variance"))
vc$geno




</code></pre>

<hr>
<h2 id='DT_sleepstudy'>
Reaction times in a sleep deprivation study
</h2><span id='topic+DT_sleepstudy'></span>

<h3>Description</h3>

<p>The average reaction time per day for subjects in a sleep deprivation study. On day 0 the subjects had their normal amount of sleep. Starting that night they were restricted to 3 hours of sleep per night. The observations represent the average reaction time on a series of tests given each day to each subject. Data from sleepstudy to see how lme4 models can be translated in sommer.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("DT_sleepstudy")</code></pre>


<h3>Format</h3>

<p>The format is:
chr &quot;DT_sleepstudy&quot;
</p>


<h3>Source</h3>

<p>These data are from the study described in Belenky et al. (2003), for the sleep deprived group and for the first 10 days of the study, up to the recovery period.
</p>


<h3>References</h3>

<p>Giovanny Covarrubias-Pazaran (2024).  lme4breeding: enabling genetic evaluation in the age of genomic data. To be submitted to Bioinformatics.
</p>
<p>Douglas Bates, Martin Maechler, Ben Bolker, Steve Walker (2015). Fitting Linear Mixed-Effects Models Using lme4. Journal of Statistical Software, 67(1), 1-48.
</p>
<p>Gregory Belenky et al. (2003) Patterns of performance degradation and restoration during sleep restrictions and subsequent recovery: a sleep dose-response study. Journal of Sleep Research 12, 1-12.
</p>


<h3>See Also</h3>

<p>The core function of the package <code><a href="#topic+lmebreed">lmebreed</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(DT_sleepstudy)
DT &lt;- DT_sleepstudy
head(DT)
##################################
fm1 &lt;- lmebreed(Reaction ~ Days + (1 | Subject), data=DT)
vc &lt;- VarCorr(fm1); print(vc,comp=c("Variance"))




##################################
fm1 &lt;- lmebreed(Reaction ~ Days + (Days || Subject), data=DT)
vc &lt;- VarCorr(fm1); print(vc,comp=c("Variance"))

##################################
fm1 &lt;- lmebreed(Reaction ~ Days + (Days | Subject), data=DT)
vc &lt;- VarCorr(fm1); print(vc,comp=c("Variance"))

##################################
fm1 &lt;- lmebreed(Reaction ~ Days + (0 + Days | Subject), data=DT)
vc &lt;- VarCorr(fm1); print(vc,comp=c("Variance"))





</code></pre>

<hr>
<h2 id='DT_technow'>
Genotypic and Phenotypic data from single cross hybrids (Technow et al.,2014)
</h2><span id='topic+DT_technow'></span><span id='topic+Ad_technow'></span><span id='topic+Af_technow'></span><span id='topic+Md_technow'></span><span id='topic+Mf_technow'></span>

<h3>Description</h3>

<p>This dataset contains phenotpic data for 2 traits measured in 1254 single cross hybrids coming from the cross of Flint x Dent heterotic groups. In addition contains the genotipic data (35,478 markers) for each of the 123 Dent lines and 86 Flint lines. The purpose of this data is to demosntrate the prediction of unrealized crosses (9324 unrealized crosses, 1254 evaluated, total 10578 single crosses). We have added the additive relationship matrix (A) but can be easily obtained using the A.mat function on the marker data. Please if using this data for your own research cite Technow et al. (2014) publication (see References).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("DT_technow")</code></pre>


<h3>Format</h3>

<p>The format is:
chr &quot;DT_technow&quot;
</p>


<h3>Source</h3>

<p>This data was extracted from Technow et al. (2014).
</p>


<h3>References</h3>

<p>If using this data for your own research please cite:
</p>
<p>Technow et al. 2014. Genome properties and prospects of genomic predictions of hybrid performance in a Breeding program of maize. Genetics 197:1343-1355.
</p>
<p>Giovanny Covarrubias-Pazaran (2024).  lme4breeding: enabling genetic evaluation in the age of genomic data. To be submitted to Bioinformatics.
</p>
<p>Douglas Bates, Martin Maechler, Ben Bolker, Steve Walker (2015). Fitting Linear Mixed-Effects Models Using lme4. Journal of Statistical Software, 67(1), 1-48.
</p>


<h3>See Also</h3>

<p>The core function of the package <code><a href="#topic+lmebreed">lmebreed</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(DT_technow)
DT &lt;- DT_technow
Md &lt;- (Md_technow*2) - 1
Mf &lt;- (Mf_technow*2) - 1
Ad &lt;- A.mat(Md)
Af &lt;- A.mat(Mf)
Ad &lt;- Ad + diag(1e-4, ncol(Ad), ncol(Ad))
Af &lt;- Af + diag(1e-4, ncol(Af), ncol(Af))
## simple model
ans2 &lt;- lmebreed(GY ~ (1|dent) + (1|flint),
                 data=DT)
vc &lt;- VarCorr(ans2); print(vc,comp=c("Variance"))



### with relationship matrices
ans2 &lt;- lmebreed(GY ~ (1|dent) + (1|flint),
             relmat = list(dent=Ad,
                           flint=Af),
             data=DT)
vc &lt;- VarCorr(ans2); print(vc,comp=c("Variance"))

### overlayed model
M &lt;- rbind(Md,Mf)
A &lt;- A.mat(M)
A &lt;- A + diag(1e-4,ncol(A), ncol(A))
Z &lt;- with(DT, overlay(dent,flint) )
Z = Z[which(!is.na(DT$GY)),]
# inital values for incidence matrix but irrelevant
# since these will be replaced by admat argument
fema &lt;- (rep(colnames(Z), nrow(DT)))[1:nrow(DT)]
#### model using overlay without relationship matrix
ans2 &lt;- lmebreed(GY ~ (1|fema),
                 addmat = list(fema=Z),
                 relmat = list(fema=A),
                 data=DT)
vc &lt;- VarCorr(ans2); print(vc,comp=c("Variance"))



</code></pre>

<hr>
<h2 id='DT_wheat'>wheat lines dataset</h2><span id='topic+DT_wheat'></span><span id='topic+GT_wheat'></span>

<h3>Description</h3>

<p>Information from a collection of 599 historical CIMMYT wheat lines.  The wheat data set is from 
CIMMYT's Global Wheat Program. Historically, this program has conducted numerous international 
trials across a wide variety of wheat-producing environments. The environments represented in 
these trials were grouped into four basic target sets of environments comprising four 
main agroclimatic regions previously defined and widely used by CIMMYT's Global Wheat Breeding Program. 
The phenotypic trait considered here was the average grain yield (GY) of the 599 wheat lines evaluated 
in each of these four mega-environments. 
</p>
<p>A pedigree tracing back many generations was available, and the Browse application of 
the International Crop Information System (ICIS), as described in  (McLaren <em>et al.</em> 2000, 2005) was used 
for deriving the relationship matrix A among the 599 lines; it accounts for selection and inbreeding.
</p>
<p>Wheat lines were recently genotyped using 1447 Diversity Array Technology (DArT) generated by 
Triticarte Pty. Ltd. (Canberra, Australia; http://www.triticarte.com.au). The DArT markers 
may take on two values, denoted by their presence or absence. Markers with a minor allele frequency 
lower than 0.05 were removed, and missing genotypes were imputed with samples from the marginal 
distribution of marker genotypes, that is, <code class="reqn">x_{ij}=Bernoulli(\hat p_j)</code>, where  <code class="reqn">\hat p_j</code>  
is the estimated allele frequency computed from the non-missing genotypes. The number of DArT 
MMs after edition was 1279.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  data(DT_wheat)
</code></pre>


<h3>Format</h3>

<p>Matrix Y contains the average grain yield, column 1: Grain yield for environment 1 and so on. 
</p>


<h3>Source</h3>

<p>International Maize and Wheat Improvement Center (CIMMYT), Mexico.
</p>


<h3>References</h3>

<p>Giovanny Covarrubias-Pazaran (2024).  lme4breeding: enabling genetic evaluation in the age of genomic data. To be submitted to Bioinformatics.
</p>
<p>Douglas Bates, Martin Maechler, Ben Bolker, Steve Walker (2015). Fitting Linear Mixed-Effects Models Using lme4. Journal of Statistical Software, 67(1), 1-48.
</p>
<p>McLaren, C. G., L. Ramos, C. Lopez, and W. Eusebio. 2000. &ldquo;Applications of the geneaology manegment system.&rdquo; 
In <em>International Crop Information System. Technical  Development Manual, version VI</em>, edited by McLaren, C. G., J.W. White 
and P.N. Fox. pp. 5.8-5.13. CIMMyT, Mexico: CIMMyT and IRRI. 
</p>
<p>McLaren, C. G., R. Bruskiewich, A.M. Portugal, and A.B. Cosico. 2005. The International Rice Information System. 
A platform for meta-analysis of rice crop data. <em>Plant Physiology</em> <b>139</b>: 637-642.
</p>


<h3>See Also</h3>

<p>The core function of the package <code><a href="#topic+lmebreed">lmebreed</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(DT_wheat)
DT &lt;- DT_wheat
GT &lt;- GT_wheat
DT &lt;- data.frame(pheno=as.vector(DT),
                 env=as.factor(paste0("e", sort(rep(1:4,nrow(DT))))),
                 id=rep(rownames(DT),4))

rownames(GT) &lt;-  rownames(DT_wheat)
K &lt;- A.mat(GT) # additive relationship matrix
K[1:4,1:4]
##
head(DT)



#### main effect model
system.time(
mix0 &lt;- lmebreed(pheno ~ (1|id),
                 relmat = list(id=K),
                 control = lmerControl(
                   check.nobs.vs.nlev = "ignore",
                   check.nobs.vs.rankZ = "ignore",
                   check.nobs.vs.nRE="ignore"
                 ),
                 data=DT)
                 )
vc &lt;- VarCorr(mix0); print(vc,comp=c("Variance"))

#### unstructured model
Z &lt;- with(DT, smm(env))
for(i in 1:ncol(Z)){DT[,colnames(Z)[i]] &lt;- Z[,i]}
system.time(
mix1 &lt;- lmebreed(pheno ~ (0 + e1 + e2 + e3 + e4 | id),
                 relmat = list(id=K),
                 control = lmerControl(
                   check.nobs.vs.nlev = "ignore",
                   check.nobs.vs.rankZ = "ignore",
                   check.nobs.vs.nRE="ignore"
                 ), rotation = TRUE,
                 data=DT)
)
vc &lt;- VarCorr(mix1); print(vc,comp=c("Variance"))



</code></pre>

<hr>
<h2 id='DT_yatesoats'>
Yield of oats in a split-block experiment
</h2><span id='topic+DT_yatesoats'></span>

<h3>Description</h3>

<p>The yield of oats from a split-plot field trial using three varieties
and four levels of manurial treatment. The experiment was laid out in
6 blocks of 3 main plots, each split into 4 sub-plots. The varieties
were applied to the main plots and the manurial (nitrogen) treatments
to the sub-plots.
</p>


<h3>Format</h3>


<dl>
<dt><code>block</code></dt><dd><p>block factor with 6 levels</p>
</dd>
<dt><code>nitro</code></dt><dd><p>nitrogen treatment in hundredweight per acre</p>
</dd>
<dt><code>Variety</code></dt><dd><p>genotype factor, 3 levels</p>
</dd>
<dt><code>yield</code></dt><dd><p>yield in 1/4 lbs per sub-plot, each 1/80 acre.</p>
</dd>
<dt><code>row</code></dt><dd><p>row location</p>
</dd>
<dt><code>column</code></dt><dd><p>column location</p>
</dd>
</dl>



<h3>Source</h3>

<p>Yates, Frank (1935) Complex experiments,
<em>Journal of the Royal Statistical Society Suppl</em>. 2, 181&ndash;247.
</p>


<h3>References</h3>

<p>Venables, W. N. and Ripley, B. D. (2002)
<em>Modern Applied Statistics with S</em>. Fourth edition. Springer.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(DT_yatesoats)
DT &lt;- DT_yatesoats
head(DT)
m3 &lt;- lmebreed(Y ~ V + N + V:N +
             (1|B) + (1|B:MP),
           data = DT)
vc &lt;- VarCorr(m3); print(vc,comp=c("Variance"))

</code></pre>

<hr>
<h2 id='fillData'>Filling gaps for a dataset to balance</h2><span id='topic+fillData'></span>

<h3>Description</h3>

<p><code>fillData</code> creates a balanced dataset in the long format to be used with the <code><a href="#topic+lmebreed">lmebreed</a></code> solver for multi-trait models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  fillData(data, toBalanceSplit=NULL, toBalanceFill=NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fillData_+3A_data">data</code></td>
<td>
<p>a data frame with traits in wide format.</p>
</td></tr>
<tr><td><code id="fillData_+3A_tobalancesplit">toBalanceSplit</code></td>
<td>
<p>variable to split the dataset for balancing.</p>
</td></tr>
<tr><td><code id="fillData_+3A_tobalancefill">toBalanceFill</code></td>
<td>
<p>variable of the factor to balance across the levels of the toBalanceSplit variable.</p>
</td></tr>
</table>


<h3>Value</h3>


<dl>
<dt>$res</dt><dd><p> a data frame with traits in long format.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Giovanny Covarrubias-Pazaran
</p>


<h3>References</h3>

<p>Giovanny Covarrubias-Pazaran (2024).  lme4breeding: enabling genetic evaluation in the age of genomic data. To be submitted to Bioinformatics.
</p>
<p>Douglas Bates, Martin Maechler, Ben Bolker, Steve Walker (2015). Fitting Linear Mixed-Effects Models Using lme4. Journal of Statistical Software, 67(1), 1-48.
</p>


<h3>See Also</h3>

<p>The function for the <code><a href="#topic+lmebreed">lmebreed</a></code> solver.</p>


<h3>Examples</h3>

<pre><code class='language-R'>
DT &lt;- DT_example
A &lt;- A_example
DT2 &lt;- fillData(DT , toBalanceSplit="Env", toBalanceFill="Name" )
head(DT2)



## Compound simmetry (CS) model
ans2 &lt;- lmebreed(Yield~Env+ (0+Env|Name),
                 relmat = list(Name=A),
                 rotation = TRUE,
                 data=DT2)
vc &lt;- VarCorr(ans2); print(vc,comp=c("Variance"))

BLUP &lt;- ranef(ans2, condVar=TRUE)$Name
SEs &lt;- attr(BLUP, which="postVar")[,,]



</code></pre>

<hr>
<h2 id='getMME'>
Build the mixed model equations from a lmebreed object
</h2><span id='topic+getMME'></span>

<h3>Description</h3>

<p>Uses the lmebreed object and builds the coefficient matrix (C) and returns its inverse and the solutions to the mixed model equations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getMME(object, vc=NULL, recordsToKeep=NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getMME_+3A_object">object</code></td>
<td>

<p>an object of class lmebreed.
</p>
</td></tr>
<tr><td><code id="getMME_+3A_vc">vc</code></td>
<td>

<p>optional variance components to force in the mixed model equations. This this to be the outpur of the <code><a href="lme4.html#topic+VarCorr">VarCorr</a></code> function.
</p>
</td></tr>
<tr><td><code id="getMME_+3A_recordstokeep">recordsToKeep</code></td>
<td>

<p>a numeric vector of indices to say which records should be kept for forming the mixed model equations and get solutions. This is particularly useful when we want to predict new individuals.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Uses the lmebreed object and builds the coefficient matrix (C) and returns its inverse and the solutions to the mixed model equations. It is internally used by the ranef function when the user wants standard errors for the BLUPs.
</p>


<h3>Value</h3>


<dl>
<dt>$Ci</dt><dd><p>inverse of the coefficient matrix.</p>
</dd>
<dt>$bu</dt><dd><p>solutions to the mixed model equations</p>
</dd>
</dl>



<h3>References</h3>

<p>Giovanny Covarrubias-Pazaran (2024).  lme4breeding: enabling genetic evaluation in the age of genomic data. To be submitted to Bioinformatics.
</p>
<p>Douglas Bates, Martin Maechler, Ben Bolker, Steve Walker (2015). Fitting Linear Mixed-Effects Models Using lme4. Journal of Statistical Software, 67(1), 1-48.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lmebreed">lmebreed</a></code>&ndash; the core function of the package </p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(DT_example)
DT &lt;- DT_example
A &lt;- A_example

ansMain &lt;- lmebreed(Yield ~ Env + (1|Name),
                    relmat = list(Name = A ),
                    data=DT)
mme &lt;- getMME(ansMain)



##########################################
## showing how to predict the individuals
## that didn't have records in the dataset
##########################################
data(DT_cpdata)
DT &lt;- DT_cpdata
GT &lt;- GT_cpdata
MP &lt;- MP_cpdata
#### create the variance-covariance matrix
A &lt;- A.mat(GT) # additive relationship matrix
A &lt;- A + diag(1e-4, ncol(A), ncol(A))
#### look at the data and fit the model
head(DT)
mix1 &lt;- lmebreed(Yield~ (1|id) + (1|Rowf) + (1|Colf),
                 relmat=list(id=A),
                 control = lmerControl(
                   check.nobs.vs.nlev = "ignore",
                   check.nobs.vs.rankZ = "ignore",
                   check.nobs.vs.nRE="ignore"
                 ),
                 data=DT)

vc &lt;- VarCorr(mix1); print(vc,comp=c("Variance"))
# the new dataset includes more individuals
DT2 &lt;- DT
DT2$Yield &lt;- imputev(DT2$Yield)
mix1expanded &lt;- lmebreed(Yield~ (1|id) + (1|Rowf) + (1|Colf),
                 relmat=list(id=A),
                 control = lmerControl(
                   check.nobs.vs.nlev = "ignore",
                   check.nobs.vs.rankZ = "ignore",
                   check.nobs.vs.nRE="ignore",
                   calc.derivs=TRUE,
                   optCtrl=list(maxeval=1)
                 ),
                 data=DT2)

vc &lt;- VarCorr(mix1expanded); print(vc,comp=c("Variance"))
# predict the individuals that didn't have records in the dataset
res &lt;- getMME(object=mix1expanded, vc=VarCorr(mix1), recordsToKeep = which(!is.na(DT$Yield)) )





</code></pre>

<hr>
<h2 id='imputev'>Imputing a numeric or character vector</h2><span id='topic+imputev'></span>

<h3>Description</h3>

<p>This function is a very simple function to impute a numeric or character vector with the mean or median value of the vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>imputev(x, method="median",by=NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="imputev_+3A_x">x</code></td>
<td>
<p>a numeric or character vector.</p>
</td></tr>
<tr><td><code id="imputev_+3A_method">method</code></td>
<td>
<p>the method to choose between mean or median.</p>
</td></tr>
<tr><td><code id="imputev_+3A_by">by</code></td>
<td>
<p>the level at which imputation will be done.</p>
</td></tr>
</table>


<h3>Value</h3>


<dl>
<dt>$x</dt><dd><p>a numeric or character vector imputed with the method selected.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Giovanny Covarrubias-Pazaran
</p>


<h3>References</h3>

<p>Giovanny Covarrubias-Pazaran (2024).  lme4breeding: enabling genetic evaluation in the age of genomic data. To be submitted to Bioinformatics.
</p>
<p>Douglas Bates, Martin Maechler, Ben Bolker, Steve Walker (2015). Fitting Linear Mixed-Effects Models Using lme4. Journal of Statistical Software, 67(1), 1-48.
</p>


<h3>See Also</h3>

<p>The core function of the package <code><a href="#topic+lmebreed">lmebreed</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1253)
x &lt;- rnorm(100)
x[sample(1:100,10)] &lt;- NA
imputev(x)
</code></pre>

<hr>
<h2 id='leg'>Legendre polynomial matrix</h2><span id='topic+leg'></span>

<h3>Description</h3>

<p>Legendre polynomials of order 'n' are created given a vector 'x' and normalized to lay between values u and v.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  leg(x,n=1,u=-1,v=1, intercept=TRUE, intercept1=FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="leg_+3A_x">x</code></td>
<td>
<p>numeric vector to be used for the polynomial.</p>
</td></tr>
<tr><td><code id="leg_+3A_n">n</code></td>
<td>
<p>order of the Legendre polynomials.</p>
</td></tr>
<tr><td><code id="leg_+3A_u">u</code></td>
<td>
<p>lower bound for the polynomial.</p>
</td></tr>
<tr><td><code id="leg_+3A_v">v</code></td>
<td>
<p>upper bound for the polynomial.</p>
</td></tr>
<tr><td><code id="leg_+3A_intercept">intercept</code></td>
<td>
<p>a TRUE/FALSE value indicating if the intercept should be included.</p>
</td></tr>
<tr><td><code id="leg_+3A_intercept1">intercept1</code></td>
<td>
<p>a TRUE/FALSE value indicating if the intercept should have value 1 (is multiplied by sqrt(2)).</p>
</td></tr>
</table>


<h3>Value</h3>


<dl>
<dt>$S3</dt><dd><p> an Legendre polynomial matrix of order n.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Giovanny Covarrubias-Pazaran
</p>


<h3>References</h3>

<p>Giovanny Covarrubias-Pazaran (2024).  lme4breeding: enabling genetic evaluation in the age of genomic data. To be submitted to Bioinformatics.
</p>
<p>Douglas Bates, Martin Maechler, Ben Bolker, Steve Walker (2015). Fitting Linear Mixed-Effects Models Using lme4. Journal of Statistical Software, 67(1), 1-48.
</p>


<h3>See Also</h3>

<p>The core function of the package <code><a href="#topic+lmebreed">lmebreed</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- sort(rep(1:3,100))



library(orthopolynom)
 leg(x, n=1)
 leg(x, n=2)

## see dataset data(DT_legendre) for a random regression modeling example

</code></pre>

<hr>
<h2 id='lme4breeding-package'>
<strong>L</strong>inear <strong>m</strong>ixed <strong>e</strong>quations <strong>4</strong> <strong>B</strong>reeding
<br />
</h2><span id='topic+lme4breeding'></span>

<h3>Description</h3>

<p>lme4breeding is nice wrapper of the lme4 package that enables the use of especialized plant and animal breeding models that include relationship matrices among individuals (e.g., genomic relationship matrices) and complex covariance structures between factors (e.g., factor analytic structures) accelerated by the use of the eigen decomposition of relationship matrices. It uses all the lme4 machinery for linear and non-linear models, for different response distributions opening a world of possibilities.
</p>
<p>It took me several years to develop a package named sommer that allowed many of the desired models. In May of 2024 I realized that few lines of code (exactly 100 lines) would allow to tweak all the lme4 machinery to fit most plant and animal models popular today at a great speed enabled by the lme4 development team. I will not stop the development of the sommer package since it allows to fit certain models at a greater speed than lme4breeding and other popular packages. The major advantage to use lme4breeding will be when you have balanced data for multiple traits or environments (not very likely) which will make this machinery extremely fast! if you have unbalanced data you may want to stick to the use of mmec until I discover how to adapt the eigen decomposition to unbalanced data. I hope you enjoy it.
</p>
<p>The <code><a href="#topic+lmebreed">lmebreed</a></code> function is the core function of the package which is exactly the same function than lmer or glmer but with few added arguments <code>relmat</code> and <code>addmat</code> that allow the user to provide relationship matrices and customized incidence matrices respectively. Also the argument <code>rotation</code> speeds up highly complex models. The lme4 machinery is designed to deal with a big number of records (r) since it works in the r &gt; c problem and inverts a c x c matrix (being c the number of coefficients). There are <code><a href="lme4.html#topic+ranef">ranef</a></code>, <code><a href="lme4.html#topic+fixef">fixef</a></code>, <code><a href="lme4.html#topic+VarCorr">VarCorr</a></code> functions to obtain variance-covariance components, BLUPs, BLUEs, residuals, fitted values, variances-covariances for fixed and random effects, etc.
</p>


<h3>Functions for genetic analysis</h3>

<p>The package provides kernels to the estimate additive (<code><a href="#topic+A.mat">A.mat</a></code>) relationship matrix for diploid and polyploid organisms. A good converter from letter code to numeric format is implemented in the function <code><a href="#topic+atcg1234">atcg1234</a></code>, which supports higher ploidy levels than diploid. Additional functions for genetic analysis have been included such as build a genotypic hybrid marker matrix (<code><a href="#topic+build.HMM">build.HMM</a></code>). If you need to use pedigree you need to convert your pedigree into a relationship matrix (use the 'getA' function from the pedigreemm package).
</p>


<h3>Functions for trial analysis</h3>

<p>Recently, spatial modeling has been added added to lme4breeding using the two-dimensional spline <code><a href="#topic+tps">tps</a></code> function.
</p>


<h3>Keeping lme4breeding updated</h3>

<p>The lme4breeding package is updated on CRAN every 4-months due to CRAN policies but you can find the latest source at https://github.com/covaruber/lme4breeding. This can be easily installed typing the following in the R console:
</p>
<p>library(devtools)
</p>
<p>install_github(&quot;covaruber/lme4breeding&quot;)
</p>
<p>This is recommended if you reported a bug, was fixed and was immediately pushed to GitHub but not in CRAN until the next update.
</p>


<h3>Tutorials</h3>

<p>For tutorials on how to perform different analysis with lme4breeding please look at the vignettes by typing in the terminal:
</p>
<p><strong>vignette(&quot;lme4breeding.qg&quot;)</strong>
</p>
<p><strong>vignette(&quot;lme4breeding.gxe&quot;)</strong>
</p>


<h3>Getting started</h3>

<p>The package has been equiped with several datasets to learn how to use the lme4breeding package (and almost to learn all sort of quantitative genetic analysis): 
</p>
<p>* <code><a href="#topic+DT_halfdiallel">DT_halfdiallel</a></code>, <code><a href="#topic+DT_fulldiallel">DT_fulldiallel</a></code> and <code><a href="#topic+DT_mohring">DT_mohring</a></code> datasets have examples to fit half and full diallel designs. 
</p>
<p>* <code><a href="#topic+DT_h2">DT_h2</a></code> to calculate heritability
</p>
<p>* <code><a href="#topic+DT_cornhybrids">DT_cornhybrids</a></code> and <code><a href="#topic+DT_technow">DT_technow</a></code> datasets to perform genomic prediction in hybrid single crosses 
</p>
<p>* <code><a href="#topic+DT_wheat">DT_wheat</a></code> dataset to do genomic prediction in single crosses in species displaying only additive effects.
</p>
<p>* <code><a href="#topic+DT_cpdata">DT_cpdata</a></code> dataset to fit genomic prediction models within a biparental population coming from 2 highly heterozygous parents including additive, dominance and epistatic effects. 
</p>
<p>* <code><a href="#topic+DT_polyploid">DT_polyploid</a></code> to fit genomic prediction and GWAS analysis in polyploids. 
</p>
<p>* <code><a href="#topic+DT_gryphon">DT_gryphon</a></code> data contains an example of an animal model including pedigree information.
</p>
<p>* <code><a href="#topic+DT_btdata">DT_btdata</a></code> dataset contains an animal (birds) model.
</p>
<p>* <code><a href="#topic+DT_legendre">DT_legendre</a></code> simulated dataset for random regression model.
</p>
<p>* <code><a href="#topic+DT_sleepstudy">DT_sleepstudy</a></code> dataset to know how to translate lme4 models to lme4breeding models.
</p>


<h3>Models Enabled</h3>

<p>The machinery behind the scenes is lme4.
</p>


<h3>Bug report and contact</h3>

<p>If you have any questions or suggestions please post it in https://stackoverflow.com or https://stats.stackexchange.com
</p>
<p>I'll be glad to help or answer any question. I have spent a valuable amount of time developing this package. Please cite this package in your publication. Type 'citation(&quot;lme4breeding&quot;)' to know how to cite it.
</p>


<h3>Author(s)</h3>

<p>Giovanny Covarrubias-Pazaran
</p>


<h3>References</h3>

<p>Giovanny Covarrubias-Pazaran (2024).  lme4breeding: enabling genetic evaluation in the age of genomic data. To be submitted to Bioinformatics.
</p>
<p>Douglas Bates, Martin Maechler, Ben Bolker, Steve Walker (2015). Fitting Linear Mixed-Effects Models Using lme4. Journal of Statistical Software, 67(1), 1-48.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(DT_example)
DT &lt;- DT_example
A &lt;- A_example

ansMain &lt;- lmebreed(Yield ~ Env + (1|Name),
                        relmat = list(Name = A ),
                        data=DT)
vc &lt;- VarCorr(ansMain); print(vc,comp=c("Variance"))

</code></pre>

<hr>
<h2 id='lmebreed'>Fit mixed-effects models incorporating relationships</h2><span id='topic+lmebreed'></span>

<h3>Description</h3>

<p>Fit linear or generalized linear mixed models incorporating the
effects of relationships.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lmebreed(formula, data, family = NULL, REML = TRUE,
           relmat = list(), addmat = list(), control = list(),
           start = NULL, verbose = TRUE, subset, weights,
           na.action, offset, contrasts = NULL, model = TRUE,
           x = TRUE, dateWarning=TRUE, returnParams=FALSE,
           rotation=FALSE, coefOutRotation=8, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lmebreed_+3A_relmat">relmat</code></td>
<td>
<p>an optional named list of relationship matrices (not the inverse). 
Internally the Cholesky decomposition of those matrices will be computed.
The names of the elements must correspond to the names of grouping factors for
random-effects terms in the <code>formula</code> argument.</p>
</td></tr>
<tr><td><code id="lmebreed_+3A_addmat">addmat</code></td>
<td>
<p>an optional named list of customized incidence matrices.
The names of the elements must correspond to the names of grouping factors for
random-effects terms in the <code>formula</code> argument. Depending on the use-case
the element in the list may be a single matrix or a list of matrices. Please see
examples and vignettes to learn how to use it.</p>
</td></tr>
<tr><td><code id="lmebreed_+3A_datewarning">dateWarning</code></td>
<td>
<p>an logical value indicating if you want to be warned when a new 
version of lme4breeding is available on CRAN.</p>
</td></tr>
<tr><td><code id="lmebreed_+3A_returnparams">returnParams</code></td>
<td>
<p>an logical value indicating if you want to only get the incidence 
matrices of the model.</p>
</td></tr>
<tr><td><code id="lmebreed_+3A_rotation">rotation</code></td>
<td>
<p>an logical value indicating if you want to compute the eigen decomposition 
of the relationship matrix to rotate y and X and accelerate the computation. See details.</p>
</td></tr>
<tr><td><code id="lmebreed_+3A_coefoutrotation">coefOutRotation</code></td>
<td>
<p>a numeric value denoting the inter-quantile outlier coefficient to
be used in the rotation of the response when using the eigen decomposition to avoid 
overshooting.</p>
</td></tr>
<tr><td><code id="lmebreed_+3A_formula">formula</code></td>
<td>
<p>as in <code><a href="lme4.html#topic+lmer">lmer</a></code></p>
</td></tr>
<tr><td><code id="lmebreed_+3A_data">data</code></td>
<td>
<p>as in <code><a href="lme4.html#topic+lmer">lmer</a></code></p>
</td></tr>
<tr><td><code id="lmebreed_+3A_family">family</code></td>
<td>
<p>as in <code><a href="lme4.html#topic+glmer">glmer</a></code></p>
</td></tr>
<tr><td><code id="lmebreed_+3A_reml">REML</code></td>
<td>
<p>as in <code><a href="lme4.html#topic+lmer">lmer</a></code></p>
</td></tr>
<tr><td><code id="lmebreed_+3A_control">control</code></td>
<td>
<p>as in <code><a href="lme4.html#topic+lmer">lmer</a></code></p>
</td></tr>
<tr><td><code id="lmebreed_+3A_start">start</code></td>
<td>
<p>as in <code><a href="lme4.html#topic+lmer">lmer</a></code></p>
</td></tr>
<tr><td><code id="lmebreed_+3A_verbose">verbose</code></td>
<td>
<p>as in <code><a href="lme4.html#topic+lmer">lmer</a></code></p>
</td></tr>
<tr><td><code id="lmebreed_+3A_subset">subset</code></td>
<td>
<p>as in <code><a href="lme4.html#topic+lmer">lmer</a></code></p>
</td></tr>
<tr><td><code id="lmebreed_+3A_weights">weights</code></td>
<td>
<p>as in <code><a href="lme4.html#topic+lmer">lmer</a></code></p>
</td></tr>
<tr><td><code id="lmebreed_+3A_na.action">na.action</code></td>
<td>
<p>as in <code><a href="lme4.html#topic+lmer">lmer</a></code></p>
</td></tr>
<tr><td><code id="lmebreed_+3A_offset">offset</code></td>
<td>
<p>as in <code><a href="lme4.html#topic+lmer">lmer</a></code></p>
</td></tr>
<tr><td><code id="lmebreed_+3A_contrasts">contrasts</code></td>
<td>
<p>as in <code><a href="lme4.html#topic+lmer">lmer</a></code></p>
</td></tr>
<tr><td><code id="lmebreed_+3A_model">model</code></td>
<td>
<p>as in <code><a href="lme4.html#topic+lmer">lmer</a></code></p>
</td></tr>
<tr><td><code id="lmebreed_+3A_x">x</code></td>
<td>
<p>as in <code><a href="lme4.html#topic+lmer">lmer</a></code></p>
</td></tr>
<tr><td><code id="lmebreed_+3A_...">...</code></td>
<td>
<p>as in <code><a href="lme4.html#topic+lmer">lmer</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>All arguments to this function are the same as those to the function
<code><a href="lme4.html#topic+lmer">lmer</a></code> except <code>relmat</code> and <code>addmat</code> which must be 
named lists.  Each name must correspond to the name of a grouping factor in a
random-effects term in the <code>formula</code>.  The observed levels
of that factor must be contained in the rownames and columnames of the relmat.  
Each relmat is the relationship matrix restricted 
to the observed levels and applied to the model matrix for that term. The incidence
matrices in the addmat argument must match the dimensions of the final fit (pay 
attention to missing data in responses).
</p>
<p>It is important to remember that when you use the <code>relmat</code> argument you are providing
the square root of the relationship matrix and to recover the correct BLUPs for those effects
you need to use the <code><a href="lme4.html#topic+ranef">ranef</a></code> function which internally multiple those BLUPs the 
square root of the relationship matrix one more time to recover the correct BLUPs.
</p>
<p>The argument <code>rotation</code> applies the eigen decomposition proposed by Lee and Van der Werf in 2016
and makes the genetic evaluation totally sparse leading to incredible gains in speed compared 
to the classical approach. Internally, the eigen decomposition UDU' is carried in the relationship 
matrix. The U matrix is then taken to the n x n level (n being the number of records), and post-multiplied
by a matrix of records presence (n x n) using the element-wise multiplication of two matrices (Schur product). 
By default is not activated since this may not provide the exact same variance components than other software due to
numerical reasons. If you would like to obtain the exact same variance components than other software you will
have to keep <code>rotation=FALSE</code>. This will slow down considerably the speed. Normally when the rotation is 
activated and variance components differ slightly with other software they will still provide highly similar 
estimates at the speed of hundreds or thousands of times faster. Please consider this.
</p>
<p>Additional useful functions are; <code><a href="#topic+tps">tps</a></code> for spatial kernels, <code><a href="#topic+rrm">rrm</a></code> for reduced rank matrices, <code><a href="#topic+atcg1234">atcg1234</a></code> for conversion of genetic markers, <code><a href="#topic+overlay">overlay</a></code> for overlay matrices, <code><a href="#topic+stackTrait">stackTrait</a></code> for moving wide format multi-trait datasets into long format, <code><a href="#topic+fillData">fillData</a></code> for balancing datasets for two variables.
</p>
<p>When using the optimizer argument inside the <code><a href="lme4.html#topic+lmerControl">lmerControl</a></code> keep in mind that the number of iterations is called differently depending on the optimizer. For <code><a href="lme4.html#topic+Nelder_Mead">Nelder_Mead</a></code>, bobyqa and <code><a href="lme4.html#topic+nlminbwrap">nlminbwrap</a></code> is called &quot;maxfun&quot; whereas for <code><a href="lme4.html#topic+nloptwrap">nloptwrap</a></code> is called &quot;maxeval&quot;. This should be passed inside a list in the <code>optCtrl</code> argument. For example:
</p>
<p><code>lmebreed(... , 
         control = lmerControl(
           optimizer="Nelder_Mead",
           optCtrl=list(maxfun=100)
         ), ...
        )</code>
</p>
<p><strong>Example Datasets</strong>
</p>
<p>The package has been equiped with several datasets to learn how to use the lme4breeding package:
</p>
<p>* <code><a href="#topic+DT_halfdiallel">DT_halfdiallel</a></code>, <code><a href="#topic+DT_fulldiallel">DT_fulldiallel</a></code> and <code><a href="#topic+DT_mohring">DT_mohring</a></code> datasets have examples to fit half and full diallel designs.
</p>
<p>* <code><a href="#topic+DT_h2">DT_h2</a></code> to calculate heritability
</p>
<p>* <code><a href="#topic+DT_cornhybrids">DT_cornhybrids</a></code> and <code><a href="#topic+DT_technow">DT_technow</a></code> datasets to perform genomic prediction in hybrid single crosses
</p>
<p>* <code><a href="#topic+DT_wheat">DT_wheat</a></code> dataset to do genomic prediction in single crosses in species displaying only additive effects.
</p>
<p>* <code><a href="#topic+DT_cpdata">DT_cpdata</a></code> dataset to fit genomic prediction models within a biparental population coming from 2 highly heterozygous parents including additive, dominance and epistatic effects.
</p>
<p>* <code><a href="#topic+DT_polyploid">DT_polyploid</a></code> to fit genomic prediction and GWAS analysis in polyploids.
</p>
<p>* <code><a href="#topic+DT_gryphon">DT_gryphon</a></code> data contains an example of an animal model including pedigree information.
</p>
<p>* <code><a href="#topic+DT_btdata">DT_btdata</a></code> dataset contains an animal (birds) model.
</p>
<p>* <code><a href="#topic+DT_legendre">DT_legendre</a></code> simulated dataset for random regression model.
</p>
<p>* <code><a href="#topic+DT_sleepstudy">DT_sleepstudy</a></code> dataset to know how to translate lme4 models to sommer models.
</p>
<p>* <code><a href="#topic+DT_ige">DT_ige</a></code> dataset to show how to fit indirect genetic effect models.
</p>


<h3>Value</h3>

<p>a <code><a href="#topic+lmebreed-class">lmebreed</a></code> object.
</p>


<h3>Author(s)</h3>

<p>Giovanny Covarrubias-Pazaran
</p>


<h3>References</h3>

<p>Giovanny Covarrubias-Pazaran (2024).  lme4breeding: enabling genetic evaluation in the age of genomic data. To be submitted to Bioinformatics.
</p>
<p>Douglas Bates, Martin Maechler, Ben Bolker, Steve Walker (2015). Fitting Linear Mixed-Effects Models Using lme4. Journal of Statistical Software, 67(1), 1-48.
</p>
<p>Lee &amp; Van der Werf (2016). MTG2: an efficient algorithm for multivariate linear mixed model analysis based on genomic information. Bioinformatics, 32(9), 1420-1422.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(DT_example)
DT &lt;- DT_example
A &lt;- A_example

ansMain &lt;- lmebreed(Yield ~ Env + (1|Name),
                        relmat = list(Name = A ),
                        data=DT)
vc &lt;- VarCorr(ansMain); print(vc,comp=c("Variance"))

BLUP &lt;- ranef(ansMain, condVar=TRUE)$Name
SEs &lt;- attr(BLUP, which="postVar")[,,]

</code></pre>

<hr>
<h2 id='lmebreed-class'>Relationship-based mixed-effects model fits</h2><span id='topic+lmebreed-class'></span><span id='topic+fitted+2Clmebreed-method'></span><span id='topic+ranef+2Clmebreed-method'></span><span id='topic+residuals+2Clmebreed-method'></span>

<h3>Description</h3>

<p>A mixed-effects model fit by <code><a href="#topic+lmebreed">lmebreed</a></code>.
This class extends class <code>"<a href="lme4.html#topic+merMod-class">merMod</a>"</code> class and includes one
additional slot, <code>relfac</code>, which is a list of (left) Cholesky
factors of the relationship matrices derived from 
<code>"<a href="#topic+lmebreed-class">lmebreed</a>"</code> objects.</p>


<h3>Objects from the Class</h3>

<p>Objects are created by calls to the
<code><a href="#topic+lmebreed">lmebreed</a></code> function.</p>


<h3>Slots</h3>


<dl>
<dt><code>relfac</code>:</dt><dd><p>A list of relationship matrix factors.  All
other slots are inherited from class <code>"<a href="lme4.html#topic+merMod-class">merMod</a>"</code>.</p>
</dd>
<dt><code>udd</code>:</dt><dd><p>A list of eigen decomposition elements.  All
other slots are inherited from class <code>"<a href="lme4.html#topic+merMod-class">merMod</a>"</code>.</p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"<a href="lme4.html#topic+merMod-class">merMod</a>"</code>, directly.
</p>


<h3>Methods</h3>


<dl>
<dt>fitted</dt><dd><p><code>signature(object = "lmebreed")</code>: actually a
non-method in that <code>fitted</code> doesn't apply to such objects
because of the pre-whitening.</p>
</dd>
<dt>ranef</dt><dd><p><code>signature(object = "lmebreed")</code>: incorporates
the relationship into the random effects as returned for the object
viewed as a <code>"<a href="lme4.html#topic+merMod-class">merMod</a>)"</code> object.</p>
</dd>
<dt>residuals</dt><dd><p><code>signature(object = "lmebreed")</code>: also a
non-method for the same reason as <code>fitted</code></p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+lmebreed">lmebreed</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>showClass("lmebreed")
</code></pre>

<hr>
<h2 id='overlay'>Overlay Matrix</h2><span id='topic+overlay'></span>

<h3>Description</h3>

<p>'overlay' adds r times the design matrix for model term t to the existing design matrix. Specifically, if the model up to this point has p effects and t has a effects, the a columns of the design matrix for t are multiplied by the scalar r (default value 1.0). This can be used to force a correlation of 1 between two terms as in a diallel analysis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  overlay(..., rlist=NULL, prefix=NULL, sparse=FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="overlay_+3A_...">...</code></td>
<td>
<p>as many vectors as desired to overlay.</p>
</td></tr>
<tr><td><code id="overlay_+3A_rlist">rlist</code></td>
<td>
<p>a list of scalar values indicating the times that each incidence matrix overlayed should be multiplied by. By default r=1.</p>
</td></tr>
<tr><td><code id="overlay_+3A_prefix">prefix</code></td>
<td>
<p>a character name to be added before the column names of the final overlay matrix. This may be useful if you have entries with names starting with numbers which programs such as asreml doesn't like, or for posterior extraction of parameters, that way 'grep'ing is easier.</p>
</td></tr>
<tr><td><code id="overlay_+3A_sparse">sparse</code></td>
<td>
<p>a TRUE/FALSE statement specifying if the matrices should be built as sparse or regular matrices.</p>
</td></tr>
</table>


<h3>Value</h3>


<dl>
<dt>$S3</dt><dd><p> an incidence matrix with as many columns levels in the vectors provided to build the incidence matrix.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Giovanny Covarrubias-Pazaran
</p>


<h3>References</h3>

<p>Fikret Isik. 2009. Analysis of Diallel Mating Designs. North Carolina State University, Raleigh, USA.
</p>
<p>Giovanny Covarrubias-Pazaran (2024).  lme4breeding: enabling genetic evaluation in the age of genomic data. To be submitted to Bioinformatics.
</p>
<p>Douglas Bates, Martin Maechler, Ben Bolker, Steve Walker (2015). Fitting Linear Mixed-Effects Models Using lme4. Journal of Statistical Software, 67(1), 1-48.
</p>


<h3>See Also</h3>

<p>The core function of the package <code><a href="#topic+lmebreed">lmebreed</a></code> and a function for creating dummy variables for diallel models named <code><a href="#topic+add.diallel.vars">add.diallel.vars</a></code>. </p>


<h3>Examples</h3>

<pre><code class='language-R'>  
####=========================================####
#### For CRAN time limitations most lines in the 
#### examples are silenced with one '#' mark, 
#### remove them and run the examples
####=========================================####
data("DT_halfdiallel")
DT &lt;- DT_halfdiallel
head(DT)
DT$femalef &lt;- as.factor(DT$female)
DT$malef &lt;- as.factor(DT$male)
DT$genof &lt;- as.factor(DT$geno)

with(DT, overlay(femalef,malef, sparse = TRUE))
with(DT, overlay(femalef,malef, sparse = FALSE))

</code></pre>

<hr>
<h2 id='redmm'>Reduced Model Matrix</h2><span id='topic+redmm'></span>

<h3>Description</h3>

<p>'redmm' reduces a model matrix by performing a singular value decomposition or Cholesky on an incidence matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  redmm(x, M = NULL, Lam=NULL, nPC=50, cholD=FALSE, returnLam=FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="redmm_+3A_x">x</code></td>
<td>
<p>as vector with values to form a model matrix or the complete incidence matrix itself for an effect of interest.</p>
</td></tr>
<tr><td><code id="redmm_+3A_m">M</code></td>
<td>
<p>an optional matrix of features explaining the levels of x. If not provided is assumed that the entire incidence matrix has been provided in x. But if provided, the decomposition occurs in the matrix M. </p>
</td></tr>
<tr><td><code id="redmm_+3A_lam">Lam</code></td>
<td>
<p>a matrix of loadings in case is already available to avoid recomputing it.</p>
</td></tr>
<tr><td><code id="redmm_+3A_npc">nPC</code></td>
<td>
<p>number of principal components to keep from the matrix of loadings to form the model matrix.</p>
</td></tr>
<tr><td><code id="redmm_+3A_chold">cholD</code></td>
<td>
<p>should a Cholesky or a Singular value decomposition should be used. The default is the SVD.</p>
</td></tr>
<tr><td><code id="redmm_+3A_returnlam">returnLam</code></td>
<td>
<p>should the function return the loading matrix in addition to the incidence matrix. Default is FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>


<dl>
<dt>$S3</dt><dd><p> A list with 3 elements:
</p>
<p>1) The model matrix to be used in the mixed modeling.
</p>
<p>2) The reduced matrix of loadings (nPC columns).
</p>
<p>3) The full matrix of loadings.
</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Giovanny Covarrubias-Pazaran
</p>


<h3>References</h3>

<p>Giovanny Covarrubias-Pazaran (2024).  lme4breeding: enabling genetic evaluation in the age of genomic data. To be submitted to Bioinformatics.
</p>
<p>Douglas Bates, Martin Maechler, Ben Bolker, Steve Walker (2015). Fitting Linear Mixed-Effects Models Using lme4. Journal of Statistical Software, 67(1), 1-48.
</p>


<h3>See Also</h3>

<p>The core function of the package <code><a href="#topic+lmebreed">lmebreed</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>  
data(DT_technow)
DT &lt;- DT_technow
Md &lt;- Md_technow

M &lt;- tcrossprod(Md)
Z = with(DT, redmm(x=dent, M=M, nPC=10))
custom &lt;- (rep(colnames(Z), nrow(DT)))[1:nrow(DT)]
ans &lt;- lmebreed(GY ~ (1|custom),
                addmat = list(custom=Z),
            data=DT)
vc &lt;- VarCorr(ans); print(vc,comp=c("Variance"))

xx &lt;- with(DT, redmm(x=dent, M=M, nPC=10, returnLam = TRUE))
u = tcrossprod(xx$Lam, t(as.matrix( ranef(ans)[[1]] ) ))


</code></pre>

<hr>
<h2 id='rrm'>reduced rank matrix</h2><span id='topic+rrm'></span>

<h3>Description</h3>

<p><code>rrm</code> creates a reduced rank factor analytic matrix by selecting the n vectors of the L matrix of the Cholesky decomposition or the U vectors of the SVD decomposition (loadings or latent covariates) to create a new incidence matrix of latent covariates that can be used with the <code><a href="#topic+lmebreed">lmebreed</a></code> solver to fit random regressions on the latent covariates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  rrm(x=NULL, H=NULL, nPC=2, returnGamma=FALSE, cholD=TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rrm_+3A_x">x</code></td>
<td>
<p>vector of the dataset containing the variable to be used to form the incidence matrix.</p>
</td></tr>
<tr><td><code id="rrm_+3A_h">H</code></td>
<td>
<p>two-way table of identifiers (rows; e.g., genotypes) by features (columns; e.g., environments) effects. Row names and column names are required. No missing data is allowed.</p>
</td></tr>
<tr><td><code id="rrm_+3A_npc">nPC</code></td>
<td>
<p>number of principal components to keep from the loadings matrix.</p>
</td></tr>
<tr><td><code id="rrm_+3A_returngamma">returnGamma</code></td>
<td>
<p>a TRUE/FALSE argument specifying if the function should return the matrix of loadings used to build the incidence matrix for the model. The default is FALSE so it returns only the incidence matrix.</p>
</td></tr>
<tr><td><code id="rrm_+3A_chold">cholD</code></td>
<td>
<p>a TRUE/FALSE argument specifying if the Cholesky decomposition should be calculated or the singular value decomposition should be used instead.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This implementation of a version of the reduced rank factor analytic models uses the so-called principal component (PC) models (Meyer, 2009) which assumes specific effects (psi) are equal to 0. The model is as follows:
</p>
<p>y = Xb + Zu + e
</p>
<p>where the variance of u ~ MVN(0, Sigma)
</p>
<p>Sigma = (Gamma_t Gamma) + Psi
</p>
<p><strong>Extended factor analytic model</strong>:
</p>
<p>y = Xb + Z(I Gamma)c + Zs + e = Xb + Z*c + Zs + e
</p>
<p>where <code>y</code> is the response variable, <code>X</code> and <code>Z</code> are incidence matrices for fixed and random effects respectively, <code>I</code> is a diagonal matrix, <code>Gamma</code> are the factor loadings for <code>c</code> common factor scores, and <code>s</code> are the specific effects, <code>e</code> is the vector of residuals.   
</p>
<p><strong>Reduced rank model:</strong>
</p>
<p>y = Xb + Z(I Gamma)c + e = Xb + Z*c + e
</p>
<p>which is equal to the one above but assumes specific effects = 0. 
</p>
<p><strong>The algorithm in rrm is the following:</strong>
</p>
<p>1) uses a wide-format table of timevar (m columns) by idvar (q rows) named H to form the initial variance-covariance matrix (Sigma) which is calculated as Sigma = H'H of dimensions m x m (column dimensions, e.g., environments x environments). 
</p>
<p>2) The Sigma matrix is then center and scaled. 
</p>
<p>3) A Cholesky (L matrix) or SVD decomposition (U D V') is performed in the Sigma matrix.
</p>
<p>4) n vectors from L (when Cholesky is used) or U sqrt(D) (when SVD is used) are kept to form Gamma. Gamma = L[,1:nPc] or Gamma = U[,1:nPC]. These are the so-called loadings (L for all loadings, Gamma for the subset of loadings).
</p>
<p>4) Gamma is used to form a new incidence matrix as Z* = Z Gamma
</p>
<p>5) This matrix is later used for the REML machinery to be used with the usc (unstructured) or smm (diagonal) structures to estimate variance components and factor scores. The resulting BLUPs from the mixed model are the optimized factor scores. Pretty much as a random regression over latent covariates.
</p>
<p>This implementation does not update the loadings (latent covariates) during the REML process, only estimates the REML factor scores for fixed loadings. This is different to other software (e.g., asreml) where the loadings are updated during the REML process as well. 
</p>
<p>BLUPs for genotypes in all locations can be recovered as:
</p>
<p>u = Gamma * u_scores
</p>
<p>The resulting loadings (Gamma) and factor scores can be thought as an equivalent to the classical factor analysis.
</p>
<p>As an additional information, notice that we calculate the factor loadings from BLUPs and the mixed model only calculates the factor scores. This is different to the asreml software where loadings are calculated as variance components through REML. Despite the difference we have run multiple examples and simulations and the BLUPs from both approaches are on average &gt;0.98 correlated so you can be confident that our approach is robust. 
</p>


<h3>Value</h3>


<dl>
<dt>$Z</dt><dd><p> a incidence matrix Z* = Z Gamma which is the original incidence matrix for the timevar multiplied by the loadings.</p>
</dd>
<dt>$Gamma</dt><dd><p> a matrix of loadings or latent covariates.</p>
</dd>
<dt>$Sigma</dt><dd><p> the covariance matrix used to calculate Gamma.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Giovanny Covarrubias-Pazaran
</p>


<h3>References</h3>

<p>Giovanny Covarrubias-Pazaran (2024).  lme4breeding: enabling genetic evaluation in the age of genomic data. To be submitted to Bioinformatics.
</p>
<p>Douglas Bates, Martin Maechler, Ben Bolker, Steve Walker (2015). Fitting Linear Mixed-Effects Models Using lme4. Journal of Statistical Software, 67(1), 1-48.
</p>
<p>Meyer K (2009) Factor analytic models for genotype by environment type problems and structured covariance matrices. Genetics Selection Evolution, 41:21
</p>


<h3>See Also</h3>

<p>The <code><a href="#topic+lmebreed">lmebreed</a></code> solver.</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(DT_h2)
DT &lt;- DT_h2
DT=DT[with(DT, order(Env)), ]
indNames &lt;- na.omit(unique(DT$Name))
A &lt;- diag(length(indNames))
rownames(A) &lt;- colnames(A) &lt;- indNames


  
# fit diagonal model first to produce H matrix
Z &lt;- with(DT, smm(Env))
diagFormula &lt;- paste0( "y ~ Env + (0+", paste(colnames(Z), collapse = "+"), 
                       "|| Name)")
for(i in 1:ncol(Z)){DT[,colnames(Z)[i]] &lt;- Z[,i]}
print(as.formula(diagFormula))
ans1a &lt;- lmebreed(as.formula(diagFormula),
                  relmat = list(Name=A),
                  data=DT)
vc &lt;- VarCorr(ans1a); print(vc,comp=c("Variance"))
H0 &lt;- ranef(ans1a)$Name # GxE table

# reduced rank model
Z &lt;- with(DT,  rrm(Env, H = H0, nPC = 3))
Zd &lt;- with(DT, smm(Env))
faFormula &lt;- paste0( "y ~ Env + (0+", paste(colnames(Z), collapse = "+"),
                     "| Name) + (0+",paste(colnames(Zd), collapse = "+"), 
                     "|| Name)")
for(i in 1:ncol(Z)){DT[,colnames(Z)[i]] &lt;- Z[,i]}
print(as.formula(faFormula))
ansFA &lt;- lmebreed(as.formula(faFormula),
                  relmat = list(Name=A),
                  data=DT)
vc &lt;- VarCorr(ansFA); print(vc,comp=c("Variance"))
ve &lt;- attr(vc, "sc")^2; ve

loadings=with(DT, rrm(Env, nPC = 3, H = H0, returnGamma = TRUE) )$Gamma
Gint &lt;- loadings %*% vc$Name %*% t(loadings)
Gspec &lt;- diag( unlist(lapply(vc[2:16], function(x){x[[1]]})) )
G &lt;- Gint + Gspec
# lattice::levelplot(cov2cor(G))
# colfunc &lt;- colorRampPalette(c("steelblue4","springgreen","yellow"))
# hv &lt;- heatmap(cov2cor(G), col = colfunc(100), symm = TRUE)

u &lt;- ranef(ansFA)$Name
uInter &lt;- as.matrix(u[,1:3]) %*% t(as.matrix(loadings))
uSpec &lt;- as.matrix(u[,-c(1:3)])
u &lt;- uSpec + uInter
  



</code></pre>

<hr>
<h2 id='simage'>Image of sparsity between two variables</h2><span id='topic+simage'></span>

<h3>Description</h3>

<p><code>image</code> for sparsity.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simage(data, Var1=NULL, Var2=NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="simage_+3A_data">data</code></td>
<td>
<p>model data of class <code>"data.frame"</code></p>
</td></tr>
<tr><td><code id="simage_+3A_var1">Var1</code></td>
<td>
<p>variable to set in the x axis</p>
</td></tr>
<tr><td><code id="simage_+3A_var2">Var2</code></td>
<td>
<p>variable to set in the y axis</p>
</td></tr>
<tr><td><code id="simage_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed to the image function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector of image
</p>


<h3>Author(s)</h3>

<p>Giovanny Covarrubias</p>


<h3>See Also</h3>

<p><code><a href="graphics.html#topic+image">image</a></code>, <code><a href="#topic+lmebreed">lmebreed</a></code></p>

<hr>
<h2 id='smm'>sparse model matrix</h2><span id='topic+smm'></span>

<h3>Description</h3>

<p><code>smm</code> creates a sparse model matrix for the levels of the random effect  to be used with the <code><a href="#topic+lmebreed">lmebreed</a></code> solver.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  smm(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="smm_+3A_x">x</code></td>
<td>
<p>vector of observations for the random effect.</p>
</td></tr>
</table>


<h3>Value</h3>


<dl>
<dt>$res</dt><dd><p> a model matrix for a given factor.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Giovanny Covarrubias-Pazaran
</p>


<h3>References</h3>

<p>Giovanny Covarrubias-Pazaran (2024).  lme4breeding: enabling genetic evaluation in the age of genomic data. To be submitted to Bioinformatics.
</p>
<p>Douglas Bates, Martin Maechler, Ben Bolker, Steve Walker (2015). Fitting Linear Mixed-Effects Models Using lme4. Journal of Statistical Software, 67(1), 1-48.
</p>


<h3>See Also</h3>

<p>The <code><a href="#topic+lmebreed">lmebreed</a></code> solver.</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- as.factor(c(1:5,1:5,1:5));x
smm(x)

</code></pre>

<hr>
<h2 id='stackTrait'>Stacking traits in a dataset</h2><span id='topic+stackTrait'></span>

<h3>Description</h3>

<p><code>stackTrait</code> creates a dataset stacking traits in the long format to be used with the <code><a href="#topic+lmebreed">lmebreed</a></code> solver for multi-trait models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  stackTrait(data, traits)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="stackTrait_+3A_data">data</code></td>
<td>
<p>a data frame with traits in wide format.</p>
</td></tr>
<tr><td><code id="stackTrait_+3A_traits">traits</code></td>
<td>
<p>variable names corresponding to the traits that should be in the long format.</p>
</td></tr>
</table>


<h3>Value</h3>


<dl>
<dt>$res</dt><dd><p> a data frame with traits in long format.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Giovanny Covarrubias-Pazaran
</p>


<h3>References</h3>

<p>Giovanny Covarrubias-Pazaran (2024).  lme4breeding: enabling genetic evaluation in the age of genomic data. To be submitted to Bioinformatics.
</p>
<p>Douglas Bates, Martin Maechler, Ben Bolker, Steve Walker (2015). Fitting Linear Mixed-Effects Models Using lme4. Journal of Statistical Software, 67(1), 1-48.
</p>


<h3>See Also</h3>

<p>The function for the <code><a href="#topic+lmebreed">lmebreed</a></code> solver.</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(DT_cpdata)
DT &lt;- DT_cpdata
GT &lt;- GT_cpdata
MP &lt;- MP_cpdata
## create the variance-covariance matrix
A &lt;- A.mat(GT) # additive relationship matrix
A &lt;- A + diag(1e-4, ncol(A), ncol(A))
## look at the data and fit the model
head(DT)
DT2 &lt;- stackTrait(data=DT, traits = c("Yield","color"))
head(DT2$long)



mix1 &lt;- lmebreed(valueS~ (0+trait|id),
                 relmat=list(id=A),
                 control = lmerControl(
                   check.nobs.vs.nlev = "ignore",
                   check.nobs.vs.rankZ = "ignore",
                   check.nobs.vs.nRE="ignore"
                 ),
                 data=DT2$long)
vc &lt;- VarCorr(mix1); print(vc,comp=c("Variance"))
cov2cor(vc$id)



</code></pre>

<hr>
<h2 id='tps'>Get Tensor Product Spline Mixed Model Incidence Matrices</h2><span id='topic+tps'></span>

<h3>Description</h3>

<p><code>tps</code> is a wrapper of tpsmmb function from the TPSbits package to avoid version dependencies but if you're using this function for your research please cite the TPSbits package. To be used with <code>lme4breeding</code> and its main function <code>lmebreed</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tps(
  columncoordinates,
  rowcoordinates,
  nsegments=NULL,
  minbound=NULL,
  maxbound=NULL,
  degree = c(3, 3),
  penaltyord = c(2, 2),
  nestorder = c(1, 1),
  asreml = "grp",
  eigenvalues = "include",
  method = "Lee",
  stub = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tps_+3A_columncoordinates">columncoordinates</code></td>
<td>
<p>A string. Gives the name of <code>data</code> element
holding column locations.</p>
</td></tr>
<tr><td><code id="tps_+3A_rowcoordinates">rowcoordinates</code></td>
<td>
<p>A string. Gives the name of <code>data</code> element
holding row locations.</p>
</td></tr>
<tr><td><code id="tps_+3A_nsegments">nsegments</code></td>
<td>
<p>A list of length 2. Number of segments to split column and
row ranges into, respectively (= number of internal knots + 1). If only
one number is specified, that value is used in both dimensions. If not
specified, (number of unique values - 1) is used in each dimension;
for a grid layout (equal spacing) this gives a knot at each data value.</p>
</td></tr>
<tr><td><code id="tps_+3A_minbound">minbound</code></td>
<td>
<p>A list of length 2. The lower bound to be used for column
and row dimensions respectively; default calculated as the minimum value
for each dimension.</p>
</td></tr>
<tr><td><code id="tps_+3A_maxbound">maxbound</code></td>
<td>
<p>A list of length 2. The upper bound to be used for column
and row dimensions respectively; default calculated as the maximum value
for each dimension.</p>
</td></tr>
<tr><td><code id="tps_+3A_degree">degree</code></td>
<td>
<p>A list of length 2. The degree of polynomial spline to be used
for column and row dimensions respectively; default=3.</p>
</td></tr>
<tr><td><code id="tps_+3A_penaltyord">penaltyord</code></td>
<td>
<p>A list of length 2. The order of differencing for column
and row dimensions, respectively; default=2.</p>
</td></tr>
<tr><td><code id="tps_+3A_nestorder">nestorder</code></td>
<td>
<p>A list of length 2. The order of nesting for column and row
dimensions, respectively; default=1 (no nesting). A value of 2 generates
a spline with half the number of segments in that dimension, etc. The
number of segments in each direction must be a multiple of the order
of nesting.</p>
</td></tr>
<tr><td><code id="tps_+3A_asreml">asreml</code></td>
<td>
<p>A string. Indicates the types of structures to be generated
for use in asreml models; default <code>"mbf"</code>. The
appropriate eigenvalue scaling is included within the Z matrices unless
setting <code>scaling="none"</code> is used, and then the scaling factors are
supplied separately in the returned object.
</p>

<ul>
<li> <p><code>asreml="mbf"</code> indicates the function should put the
spline design matrices into structures for use with <code>"mbf"</code>;
</p>
</li>
<li> <p><code>asreml="grp"</code> indicates the function should add the
composite spline design matrices (eg. for second-order differencing,
matrices Xr1:Zc, Xr2:Zc, Zr:Xc1, Zr:Xc2 and Zc:Zr) into the data frame
and provide a group list structure for each term;
</p>
</li>
<li> <p><code>asreml="sepgrp"</code> indicates the function should generate the
individual X and Z spline design matrices separately (ie. Xc, Xr, Zc and
Zr), plus the smooth x smooth interaction term as a whole (ie. Zc:Zr),
and provide a group list structure for each term.
</p>
</li>
<li> <p><code>asreml="own"</code> indicates the function should generate the
composite matrix ( Xr:Zc | Zr:Xc | Zc:Zr ) as a single set of columns.
</p>
</li></ul>
</td></tr>
<tr><td><code id="tps_+3A_eigenvalues">eigenvalues</code></td>
<td>
<p>A string. Indicates whether eigenvalues should be
included within the Z design matrices <code>eigenvalues="include"</code>, or
whether this scaling should be omitted (<code>eigenvalues="omit"</code>);
default <code>eigenvalues="include"</code>. If the eigenvalue scaling is
omitted from the Z design matrices, then it should instead be included in
the model as a variance structure to obtain the correct TPspline model.</p>
</td></tr>
<tr><td><code id="tps_+3A_method">method</code></td>
<td>
<p>A string. Method for forming the  penalty; default=<code>"Lee"</code>
ie the penalty from Lee, Durban &amp; Eilers (2013, CSDA 61, 22-37). The
alternative method is <code>"Wood"</code> ie. the method from Wood et al (2012,
Stat Comp 23, 341-360).
This option is a research tool and requires further investigation.</p>
</td></tr>
<tr><td><code id="tps_+3A_stub">stub</code></td>
<td>
<p>A string. Stub to be attached to names in the <code>mbf</code> list to
avoid over-writing structures and general confusion.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List of length 7, 8 or 9 (according to the <code>asreml</code> and
<code>eigenvalues</code> parameter settings).
</p>

<ol>
<li> <p><code>data</code> = the input data frame augmented with structures required
to fit tensor product splines in <code>asreml-R</code>. This data frame can be used
to fit the TPS model.
</p>
<p>Added columns:
</p>

<ul>
<li> <p><code>TP.col</code>, <code>TP.row</code> = column and row coordinates
</p>
</li>
<li> <p><code>TP.CxR</code> = combined index for use with smooth x smooth term
</p>
</li>
<li> <p><code>TP.C.n</code> for n=1:(diff.c) = X parts of column spline for use
in random model (where diff.c is the order of column differencing)
</p>
</li>
<li> <p><code>TP.R.n</code> for n=1:(diff.r) = X parts of row spline for use in
random model (where diff.r is the order of row differencing)
</p>
</li>
<li> <p><code>TP.CR.n</code> for n=1:((diff.c*diff.r)) = interaction between the
two X parts for use in fixed model. The first variate is
a constant term which should be omitted from the model when the constant
(1) is present. If all elements are
included in the model then the constant term should be omitted,
eg. <code>y ~ -1 + TP.CR.1 + TP.CR.2 + TP.CR.3 + TP.CR.4 + other terms...</code>
</p>
</li>
<li><p> when <code>asreml="grp"</code> or <code>"sepgrp"</code>, the spline basis
functions are also added into the data frame. Column numbers for each
term are given in the <code>grp</code> list structure.
</p>
</li></ul>

</li>
<li> <p><code>mbflist</code> = list that can be used in call to asreml (so long as Z
matrix data frames extracted with right names, eg BcZ&lt;stub&gt;.df)
</p>
</li>
<li> <p><code>BcZ.df</code> = mbf data frame mapping onto smooth part of column
spline, last column (labelled <code>TP.col</code>) gives column index
</p>
</li>
<li> <p><code>BrZ.df</code> = mbf data frame mapping onto smooth part of row spline,
last column (labelled <code>TP.row</code>) gives row index
</p>
</li>
<li> <p><code>BcrZ.df</code> = mbf data frame mapping onto smooth x smooth term, last
column (labelled <code>TP.CxR</code>) maps onto col x row combined index
</p>
</li>
<li> <p><code>dim</code> = list structure, holding dimension values relating to the
model:
</p>

<ol>
<li> <p><code>"diff.c"</code> = order of differencing used in column dimension
</p>
</li>
<li> <p><code>"nbc"</code> = number of random basis functions in column dimension
</p>
</li>
<li> <p><code>"nbcn"</code> = number of nested random basis functions in column dimension
used in smooth x smooth term
</p>
</li>
<li> <p><code>"diff.r"</code> = order of differencing used in column dimension
</p>
</li>
<li> <p><code>"nbr"</code> = number of random basis functions in column dimension
</p>
</li>
<li> <p><code>"nbrn"</code> = number of nested random basis functions in column dimension
used in smooth x smooth term
</p>
</li></ol>

</li>
<li> <p><code>trace</code> = list of trace values for ZGZ' for the random TPspline
terms, where Z is the design matrix and G
is the known diagonal variance matrix derived from eigenvalues. This can
be used to rescale the spline design matrix (or equivalently variance
components).
</p>
</li>
<li> <p><code>grp</code> = list structure, only added for settings
<code>asreml="grp"</code>,  <code>asreml="sepgrp"</code> or <code>asreml="own"</code>.
For <code>asreml="grp"</code>, provides column indexes for each of the 5
random components of the 2D splines.
For <code>asreml="sepgrp"</code>, provides column indexes for each of the X and
Z component matrices for the 1D splines, plus the composite smooth x
smooth interaction term. For <code>asreml="own"</code>, provides column indexes
for the composite random model.
Dimensions of the components can be derived from the values in the
<code>dim</code> item.  The Z terms are scaled by the associated
eigenvalues when <code>eigenvalues="include"</code>, but not when
<code>eigenvalues="omit"</code>.
</p>
</li>
<li> <p><code>eigen</code> = list structure, only added for option setting
<code>eigenvalues="omit"</code>. Holds the diagonal elements of the inverse
variance matrix for the terms Xc:Zr (called <code>diagr</code>), Zc:Xr
(called <code>diagc</code>) and Zc:Zr (called <code>diagcr</code>).
</p>
</li></ol>



<h3>Examples</h3>

<pre><code class='language-R'>
data(DT_cpdata)
DT &lt;- DT_cpdata
# add the units column
DT$units &lt;- as.factor(1:nrow(DT))
# get spatial incidence matrix
Zs &lt;- with(DT, tps(Row, Col))$All
rownames(Zs) &lt;- DT$units
# reduce the matrix to its PCs
Z = with(DT, redmm(x=units, M=Zs, nPC=100))
# create dummy variable
spatial &lt;- (rep(colnames(Z), nrow(DT)))[1:nrow(DT)]



# fit model
mix1 &lt;- lmebreed(Yield~ (1|Rowf) + (1|Colf) + (1|spatial),
                 addmat =list(spatial=Z),
                 control = lmerControl(
                   check.nobs.vs.nlev = "ignore",
                   check.nobs.vs.rankZ = "ignore",
                   check.nobs.vs.nRE="ignore"
                 ),
                 data=DT)
vc &lt;- VarCorr(mix1); print(vc,comp=c("Variance"))



</code></pre>

<hr>
<h2 id='umat'>Rotation matrix UDU' decomposition</h2><span id='topic+umat'></span>

<h3>Description</h3>

<p>'umat' creates the equivalent of a U matrix from the eigen decomposition of a relationship matrix of dimensions equal to the number of records equivalent to Lee and Van der Werf (2016).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  umat(formula, relmat, data, addmat)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="umat_+3A_formula">formula</code></td>
<td>
<p>a formula expressing the factor to decompose.</p>
</td></tr>
<tr><td><code id="umat_+3A_relmat">relmat</code></td>
<td>
<p>an optional matrix of features explaining the levels of x. If not provided is assumed that the entire incidence matrix has been provided in x. But if provided, the decomposition occurs in the matrix M. </p>
</td></tr>
<tr><td><code id="umat_+3A_data">data</code></td>
<td>
<p>a dataset to be used for modeling.</p>
</td></tr>
<tr><td><code id="umat_+3A_addmat">addmat</code></td>
<td>
<p>additional matrices.</p>
</td></tr>
</table>


<h3>Value</h3>


<dl>
<dt>$S3</dt><dd><p> A list with 3 elements:
</p>
<p>1) The U' matrix of dimensions n x n (eigen vectors), n being the number of records.
</p>
<p>2) The original U matrix of dimensions m x m (eigen vectors), m being the number of coefficients or levels in relmat.
</p>
<p>3) The D matrix of dimensions m x m (eigen values), m being the number of coefficients or levels in relmat.
</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Giovanny Covarrubias-Pazaran
</p>


<h3>References</h3>

<p>Giovanny Covarrubias-Pazaran (2024).  lme4breeding: enabling genetic evaluation in the age of genomic data. To be submitted to Bioinformatics.
</p>
<p>Douglas Bates, Martin Maechler, Ben Bolker, Steve Walker (2015). Fitting Linear Mixed-Effects Models Using lme4. Journal of Statistical Software, 67(1), 1-48. 
</p>


<h3>See Also</h3>

<p>The core function of the package <code><a href="#topic+lmebreed">lmebreed</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>  
data(DT_cpdata)
DT &lt;- DT_cpdata
GT &lt;- GT_cpdata
## create the variance-covariance matrix
A &lt;- A.mat(GT) # additive relationship matrix
A &lt;- A + diag(1e-4, ncol(A), ncol(A))
## look at the data and fit the model
head(DT)
xx &lt;- umat(~id, relmat = list(id=A), data=DT)


</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
