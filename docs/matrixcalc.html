<!DOCTYPE html><html><head><title>Help for package matrixcalc</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {matrixcalc}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#+25s+25'><p> Direct sum of two arrays</p></a></li>
<li><a href='#commutation.matrix'><p> Commutation matrix for r by c numeric matrices</p></a></li>
<li><a href='#creation.matrix'><p> Creation Matrix</p></a></li>
<li><a href='#D.matrix'><p> Duplication matrix</p></a></li>
<li><a href='#direct.prod'><p> Direct prod of two arrays</p></a></li>
<li><a href='#direct.sum'><p> Direct sum of two arrays</p></a></li>
<li><a href='#duplication.matrix'><p> Duplication matrix for n by n matrices</p></a></li>
<li><a href='#E.matrices'><p> List of E Matrices</p></a></li>
<li><a href='#elimination.matrix'><p> Elimination matrix for lower triangular matrices</p></a></li>
<li><a href='#entrywise.norm'><p> Compute the entrywise norm of a matrix</p></a></li>
<li><a href='#fibonacci.matrix'><p> Fibonacci Matrix</p></a></li>
<li><a href='#frobenius.matrix'><p> Frobenius Matrix</p></a></li>
<li><a href='#frobenius.norm'><p> Compute the Frobenius norm of a matrix</p></a></li>
<li><a href='#frobenius.prod'><p> Frobenius innter product of matrices</p></a></li>
<li><a href='#H.matrices'><p> List of H Matrices</p></a></li>
<li><a href='#hadamard.prod'><p> Hadamard product of two matrices</p></a></li>
<li><a href='#hankel.matrix'><p> Hankel Matrix</p></a></li>
<li><a href='#hilbert.matrix'><p> Hilbert matrices</p></a></li>
<li><a href='#hilbert.schmidt.norm'><p> Compute the Hilbert-Schmidt norm of a matrix</p></a></li>
<li><a href='#inf.norm'><p> Compute the infinitity norm of a matrix</p></a></li>
<li><a href='#is.diagonal.matrix'><p> Test for diagonal square matrix</p></a></li>
<li><a href='#is.idempotent.matrix'><p> Test for idempotent square matrix</p></a></li>
<li><a href='#is.indefinite'><p> Test matrix for positive indefiniteness</p></a></li>
<li><a href='#is.negative.definite'><p> Test matrix for negative definiteness</p></a></li>
<li><a href='#is.negative.semi.definite'><p> Test matrix for negative semi definiteness</p></a></li>
<li><a href='#is.non.singular.matrix'><p> Test if matrix is non-singular</p></a></li>
<li><a href='#is.positive.definite'><p> Test matrix for positive definiteness</p></a></li>
<li><a href='#is.positive.semi.definite'><p> Test matrix for positive semi-definiteness</p></a></li>
<li><a href='#is.singular.matrix'><p>  Test for singular square matrix</p></a></li>
<li><a href='#is.skew.symmetric.matrix'><p> Test for a skew-symmetric matrix</p></a></li>
<li><a href='#is.square.matrix'><p> Test for square matrix</p></a></li>
<li><a href='#is.symmetric.matrix'><p> Test for symmetric numeric matrix</p></a></li>
<li><a href='#K.matrix'><p> K Matrix</p></a></li>
<li><a href='#L.matrix'><p> Construct L Matrix</p></a></li>
<li><a href='#lower.triangle'><p> Lower triangle portion of a matrix</p></a></li>
<li><a href='#lu.decomposition'><p> LU Decomposition of Square Matrix</p></a></li>
<li><a href='#matrix.inverse'><p> Inverse of a square matrix</p></a></li>
<li><a href='#matrix.power'><p> Matrix Raised to a Power</p></a></li>
<li><a href='#matrix.rank'><p> Rank of a square matrix</p></a></li>
<li><a href='#matrix.trace'><p> The trace of a matrix</p></a></li>
<li><a href='#maximum.norm'><p> Maximum norm of  matrix</p></a></li>
<li><a href='#N.matrix'><p> Construct N Matrix</p></a></li>
<li><a href='#one.norm'><p> Compute the one norm of a matrix</p></a></li>
<li><a href='#pascal.matrix'><p> Pascal matrix</p></a></li>
<li><a href='#set.submatrix'><p> Store matrix inside another matrix</p></a></li>
<li><a href='#shift.down'><p> Shift matrix m rows down</p></a></li>
<li><a href='#shift.left'><p> Shift a matrix n columns to the left</p></a></li>
<li><a href='#shift.right'><p>Shift matrix n columns to the right</p></a></li>
<li><a href='#shift.up'><p> Shift matrix m rows up</p></a></li>
<li><a href='#spectral.norm'><p> Spectral norm of  matrix</p></a></li>
<li><a href='#stirling.matrix'><p> Stirling Matrix</p></a></li>
<li><a href='#svd.inverse'><p> SVD Inverse of a square matrix</p></a></li>
<li><a href='#symmetric.pascal.matrix'><p> Symmetric Pascal matrix</p></a></li>
<li><a href='#T.matrices'><p> List of T Matrices</p></a></li>
<li><a href='#toeplitz.matrix'><p> Toeplitz Matrix</p></a></li>
<li><a href='#u.vectors'><p> u vectors of an identity matrix</p></a></li>
<li><a href='#upper.triangle'><p> Upper triangle portion of a matrix</p></a></li>
<li><a href='#vandermonde.matrix'><p> Vandermonde matrix</p></a></li>
<li><a href='#vec'><p> Vectorize a matrix</p></a></li>
<li><a href='#vech'><p> Vectorize a matrix</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>1.0-6</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-09-10</td>
</tr>
<tr>
<td>Title:</td>
<td>Collection of Functions for Matrix Calculations</td>
</tr>
<tr>
<td>Author:</td>
<td>Frederick Novomestky &lt;fnovomes@poly.edu&gt;</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>S. Thomas Kelly &lt;tomkellygenetics@gmail.com&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.0.1)</td>
</tr>
<tr>
<td>Description:</td>
<td>A collection of functions to support matrix calculations
        for probability, econometric and numerical analysis. There are
        additional functions that are comparable to APL functions which
        are useful for actuarial models such as pension mathematics.
        This package is used for teaching and research purposes at the
        Department of Finance and Risk Engineering, New York
        University, Polytechnic Institute, Brooklyn, NY 11201.
        Horn, R.A. (1990) Matrix Analysis. ISBN 978-0521386326.
        Lancaster, P. (1969) Theory of Matrices. ISBN 978-0124355507.
        Lay, D.C. (1995) Linear Algebra: And Its Applications. ISBN 978-0201845563.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/TomKellyGenetics/matrixcalc/issues">https://github.com/TomKellyGenetics/matrixcalc/issues</a></td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-09-14 20:41:38 UTC; tom</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-09-14 21:20:02 UTC</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.2</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
</table>
<hr>
<h2 id='+25s+25'> Direct sum of two arrays </h2><span id='topic++25s+25'></span>

<h3>Description</h3>

<p>This function computes the direct sum of two arrays.  The arrays can be
numerical vectors or matrices.  The result ia the block diagonal matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>x%s%y
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B25s+2B25_+3A_x">x</code></td>
<td>
<p> a numeric matrix or vector </p>
</td></tr>
<tr><td><code id="+2B25s+2B25_+3A_y">y</code></td>
<td>
<p> a numeric matrix or vector </p>
</td></tr>
</table>


<h3>Details</h3>

<p>If either <code class="reqn">\bf{x}</code> or y is a vector, it is converted to a matrix.  The result
is a block diagonal matrix <code class="reqn">\left\lbrack {\begin{array}{cc}
   {\bf{x}} &amp; {\bf{0}}  \\
   {\bf{0}} &amp; {\bf{y}}  \\
\end{array}} \right\rbrack</code>.
</p>


<h3>Value</h3>

<p>A numeric matrix.
</p>


<h3>Author(s)</h3>

<p> Frederick Novomestky <a href="mailto:fnovomes@poly.edu">fnovomes@poly.edu</a>, Kurt Hornik <a href="mailto:Kurt.Hornik@wu-wien.ac.at">Kurt.Hornik@wu-wien.ac.at</a> </p>


<h3>References</h3>

<p>Magnus, J. R. and H. Neudecker (1999) <em>Matrix Differential Calculus with Applications in Statistics and Econometrics</em>,
Second Edition, John Wiley.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- matrix( seq( 1, 4 ) )
y &lt;- matrix( seq( 5, 8 ) )
print( x %s% y )
</code></pre>

<hr>
<h2 id='commutation.matrix'> Commutation matrix for r by c numeric matrices </h2><span id='topic+commutation.matrix'></span>

<h3>Description</h3>

<p>This function returns a square matrix of order p = r * c that, 
for an r by c matrix A, transforms
vec(A) to vec(A') where prime denotes transpose.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>commutation.matrix(r, c=r)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="commutation.matrix_+3A_r">r</code></td>
<td>
<p> a positive integer integer row dimension </p>
</td></tr>
<tr><td><code id="commutation.matrix_+3A_c">c</code></td>
<td>
<p> a positive integer integer column dimension </p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is a wrapper function that uses the function <code>K.matrix</code> to do the actual work.
The <code class="reqn">r \times c</code> matrices <code class="reqn">{\bf{H}}{}_{i,j}</code> constructed
by the function <code>H.matrices</code> are combined using direct product
to generate the commutation product with the following formula
<code class="reqn">{{\bf{K}}_{r,c}} = \sum\limits_{i = 1}^r {\sum\limits_{j = 1}^c {\left( {{{\bf{H}}_{i,j}} \otimes {{{\bf{H'}}}_{i,j}}} \right)} }</code>
</p>


<h3>Value</h3>

<p>An order <code class="reqn">\left( {r\;c} \right)</code> matrix.
</p>


<h3>Note</h3>

<p>If either argument is less than 2, then the function stops and displays an appropriate error mesage.
If either argument is not an integer, then the function stops and displays an appropriate error mesage
</p>


<h3>Author(s)</h3>

<p> Frederick Novomestky <a href="mailto:fnovomes@poly.edu">fnovomes@poly.edu</a> </p>


<h3>References</h3>

<p>Magnus, J. R. and H. Neudecker (1979). The commutation matrix: some properties and applications,
<em>The Annals of Statistics</em>, 7(2), 381-394.
</p>
<p>Magnus, J. R. and H. Neudecker (1999) <em>Matrix Differential Calculus with Applications in Statistics and Econometrics</em>,
Second Edition, John Wiley.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+H.matrices">H.matrices</a></code>,
<code><a href="#topic+K.matrix">K.matrix</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>K &lt;- commutation.matrix( 3, 4 )
A &lt;- matrix( seq( 1, 12, 1 ), nrow=3, byrow=TRUE )
vecA &lt;- vec( A )
vecAt &lt;- vec( t( A ) )
print( K %*% vecA )
print( vecAt )
</code></pre>

<hr>
<h2 id='creation.matrix'> Creation Matrix </h2><span id='topic+creation.matrix'></span>

<h3>Description</h3>

<p>This function returns the order n creation matrix, a square matrix with the
sequence 1, 2, ..., n - 1 on the sub-diagonal below the principal diagonal.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>creation.matrix(n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="creation.matrix_+3A_n">n</code></td>
<td>
<p> a positive integer greater than 1 </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The order <code class="reqn">n</code> creation matrix is also called the derivation matrix and is
used in numerical mathematics and physics. It arises in the solution of linear
dynamical systems.  The form of the matrix is 
<code class="reqn">\left\lbrack {\begin{array}{cccccc}
0&amp;0&amp;0&amp; \cdots &amp;0&amp;0\\
1&amp;0&amp;0&amp; \cdots &amp;0&amp;0\\
0&amp;2&amp;0&amp; \cdots &amp;0&amp;0\\
0&amp;0&amp;3&amp; \ddots &amp;0&amp;0\\
 \vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \ddots &amp;{}\\
0&amp;0&amp;0&amp; \cdots &amp;{n - 1}&amp;0
\end{array}} \right\rbrack</code>.
</p>


<h3>Value</h3>

<p>An order <code class="reqn">n</code> matrix.
</p>


<h3>Note</h3>

<p>If the argument n is not an integer that is greater than 1, 
the function presents an error message and stops.
</p>


<h3>Author(s)</h3>

<p> Frederick Novomestky <a href="mailto:fnovomes@poly.edu">fnovomes@poly.edu</a> </p>


<h3>References</h3>

<p>Aceto, L. and D. Trigiante (2001). Matrices of Pascal and Other Greats,
<em>American Mathematical Monthly</em>, March 2001, 108(3), 232-245.
</p>
<p>Weinberg, S. (1995). <em>The Quantum Theory of Fields</em>, Cambridge
University Press.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>H &lt;- creation.matrix( 10 )
print( H )
</code></pre>

<hr>
<h2 id='D.matrix'> Duplication matrix </h2><span id='topic+D.matrix'></span>

<h3>Description</h3>

<p>This function constructs the linear transformation D that maps
vech(A) to vec(A) when A is a symmetric matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>D.matrix(n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="D.matrix_+3A_n">n</code></td>
<td>
<p> a positive integer value for the order of the underlying matrix </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Let <code class="reqn">{\bf{T}}_{i,j}</code> be an <code class="reqn">n \times n</code> matrix with 1 in its <code class="reqn">\left( {i,j} \right)</code> element <code class="reqn">1 \le i,j \le n</code>.
and zeroes elsewhere. These matrices are constructed by the function <code>T.matrices</code>.  The formula for the
transpose of matrix <code class="reqn">\bf{D}</code> is <code class="reqn">{\bf{D'}} = \sum\limits_{j = 1}^n {\sum\limits_{i = j}^n {{{\bf{u}}_{i,j}}\;{{\left( {vec\;{{\bf{T}}_{i,j}}} \right)}^\prime }} } </code>
where <code class="reqn">{{{\bf{u}}_{i,j}}}</code> is the column vector in the order <code class="reqn">\frac{1}{2}n\left( {n + 1} \right)</code> identity
matrix for column <code class="reqn">k = \left( {j - 1} \right)n + i - \frac{1}{2}j\left( {j - 1} \right)</code>.  The function
<code>u.vectors</code> generates these vectors.
</p>


<h3>Value</h3>

<p>It returns an <code class="reqn">{n^2}\; \times \;\frac{1}{2}n\left( {n + 1} \right)</code> matrix.
</p>


<h3>Author(s)</h3>

<p> Frederick Novomestky <a href="mailto:fnovomes@poly.edu">fnovomes@poly.edu</a> </p>


<h3>References</h3>

<p>Magnus, J. R. and H. Neudecker (1980). The elimination matrix, some lemmas and applications,
<em>SIAM Journal on Algebraic Discrete Methods</em>, 1(4), December 1980, 422-449.
</p>
<p>Magnus, J. R. and H. Neudecker (1999). <em>Matrix Differential Calculus with Applications in Statistics and Econometrics</em>,
Second Edition, John Wiley.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+T.matrices">T.matrices</a></code>,
<code><a href="#topic+u.vectors">u.vectors</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>D &lt;- D.matrix( 3 )
A &lt;- matrix( c( 1, 2, 3,
                2, 3, 4,
                3, 4, 5), nrow=3, byrow=TRUE )
vecA &lt;- vec( A )
vechA&lt;- vech( A )
y &lt;- D %*% vechA
print( y )
print( vecA )
</code></pre>

<hr>
<h2 id='direct.prod'> Direct prod of two arrays </h2><span id='topic+direct.prod'></span>

<h3>Description</h3>

<p>This function computes the direct product of two arrays.  The arrays can be
numerical vectors or matrices.  The result is a matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>direct.prod( x, y )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="direct.prod_+3A_x">x</code></td>
<td>
<p> a numeric matrix or vector </p>
</td></tr>
<tr><td><code id="direct.prod_+3A_y">y</code></td>
<td>
<p> a numeric matrix or vector </p>
</td></tr>
</table>


<h3>Details</h3>

<p>If either <code class="reqn">\bf{x}</code> or <code class="reqn">\bf{y}</code> is a vector, it is converted to a matrix.
Suppose that <code class="reqn">\bf{x}</code> is an <code class="reqn">m \times n</code> matrix and <code class="reqn">\bf{y}</code> is an <code class="reqn"> p \times q</code>
matrix. Then, the function returns the matrix <code class="reqn">\left\lbrack {\begin{array}{cccc}
{{x_{1,1}}\;{\bf{y}}}&amp;{{x_{1,2}}\;{\bf{y}}}&amp; \cdots &amp;{{x_{1,n}}\;{\bf{y}}}\\
{{x_{2,1}}\;{\bf{y}}}&amp;{{x_{2,2}}\;{\bf{y}}}&amp; \cdots &amp;{{x_{2,n}}\;{\bf{y}}}\\
 \cdots &amp; \cdots &amp; \cdots &amp; \cdots \\
{{x_{m,1}}\;{\bf{y}}}&amp;{{x_{m,2}}\;{\bf{y}}}&amp; \cdots &amp;{{x_{m,n}}\;{\bf{y}}}
\end{array}} \right\rbrack</code>.
</p>


<h3>Value</h3>

<p>A numeric matrix.
</p>


<h3>Author(s)</h3>

<p> Frederick Novomestky <a href="mailto:fnovomes@poly.edu">fnovomes@poly.edu</a>, Kurt Hornik <a href="mailto:Kurt.Hornik@wu-wien.ac.at">Kurt.Hornik@wu-wien.ac.at</a> </p>


<h3>References</h3>

<p>Magnus, J. R. and H. Neudecker (1999) <em>Matrix Differential Calculus with Applications in Statistics and Econometrics</em>,
Second Edition, John Wiley.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- matrix( seq( 1, 4 ) )
y &lt;- matrix( seq( 5, 8 ) )
print( direct.prod( x, y ) )
</code></pre>

<hr>
<h2 id='direct.sum'> Direct sum of two arrays </h2><span id='topic+direct.sum'></span>

<h3>Description</h3>

<p>This function computes the direct sum of two arrays.  The arrays can be
numerical vectors or matrices.  The result ia the block diagonal matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>direct.sum( x, y )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="direct.sum_+3A_x">x</code></td>
<td>
<p> a numeric matrix or vector </p>
</td></tr>
<tr><td><code id="direct.sum_+3A_y">y</code></td>
<td>
<p> a numeric matrix or vector </p>
</td></tr>
</table>


<h3>Details</h3>

<p>If either <code class="reqn">\bf{x}</code> or y is a vector, it is converted to a matrix.  The result
is a block diagonal matrix <code class="reqn">\left\lbrack {\begin{array}{cc}
   {\bf{x}} &amp; {\bf{0}}  \\
   {\bf{0}} &amp; {\bf{y}}  \\
\end{array}} \right\rbrack</code>.
</p>


<h3>Value</h3>

<p>A numeric matrix.
</p>


<h3>Author(s)</h3>

<p> Frederick Novomestky <a href="mailto:fnovomes@poly.edu">fnovomes@poly.edu</a>, Kurt Hornik <a href="mailto:Kurt.Hornik@wu-wien.ac.at">Kurt.Hornik@wu-wien.ac.at</a> </p>


<h3>References</h3>

<p>Magnus, J. R. and H. Neudecker (1999) <em>Matrix Differential Calculus with Applications in Statistics and Econometrics</em>,
Second Edition, John Wiley.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- matrix( seq( 1, 4 ) )
y &lt;- matrix( seq( 5, 8 ) )
print( direct.sum( x, y ) )
</code></pre>

<hr>
<h2 id='duplication.matrix'> Duplication matrix for n by n matrices </h2><span id='topic+duplication.matrix'></span>

<h3>Description</h3>

<p>This function returns a matrix with n * n rows and n * ( n + 1 ) / 2 columns
that transforms vech(A) to vec(A) where A is a symmetric n by n matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>duplication.matrix(n=1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="duplication.matrix_+3A_n">n</code></td>
<td>
<p> Row and column dimension </p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is a wrapper function for the function <code>D.matrix</code>.
Let <code class="reqn">{\bf{T}}_{i,j}</code> be an <code class="reqn">n \times n</code> matrix with 1 in its <code class="reqn">\left( {i,j} \right)</code> element <code class="reqn">1 \le i,j \le n</code>.
and zeroes elsewhere. These matrices are constructed by the function <code>T.matrices</code>.  The formula for the
transpose of matrix <code class="reqn">\bf{D}</code> is <code class="reqn">{\bf{D'}} = \sum\limits_{j = 1}^n {\sum\limits_{i = j}^n {{{\bf{u}}_{i,j}}\;{{\left( {vec\;{{\bf{T}}_{i,j}}} \right)}^\prime }} } </code>
where <code class="reqn">{{{\bf{u}}_{i,j}}}</code> is the column vector in the order <code class="reqn">\frac{1}{2}n\left( {n + 1} \right)</code> identity
matrix for column <code class="reqn">k = \left( {j - 1} \right)n + i - \frac{1}{2}j\left( {j - 1} \right)</code>.  The function
<code>u.vectors</code> generates these vectors.
</p>


<h3>Value</h3>

<p>It returns an <code class="reqn">{n^2}\; \times \;\frac{1}{2}n\left( {n + 1} \right)</code> matrix.
</p>


<h3>Author(s)</h3>

<p> Frederick Novomestky <a href="mailto:fnovomes@poly.edu">fnovomes@poly.edu</a>, Kurt Hornik <a href="mailto:Kurt.Hornik@wu-wien.ac.at">Kurt.Hornik@wu-wien.ac.at</a> </p>


<h3>References</h3>

<p>Magnus, J. R. and H. Neudecker (1980). The elimination matrix, some lemmas and applications,
<em>SIAM Journal on Algebraic Discrete Methods</em>, 1(4), December 1980, 422-449.
</p>
<p>Magnus, J. R. and H. Neudecker (1999) <em>Matrix Differential Calculus with Applications in Statistics and Econometrics</em>,
Second Edition, John Wiley.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+D.matrix">D.matrix</a></code>,
<code><a href="#topic+vec">vec</a></code>,
<code><a href="#topic+vech">vech</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>D &lt;- duplication.matrix( 3 )
A &lt;- matrix( c( 1, 2, 3,
                2, 3, 4,
                3, 4, 5), nrow=3, byrow=TRUE )
vecA &lt;- vec( A )
vechA&lt;- vech( A )
y &lt;- D %*% vechA
print( y )
print( vecA )
</code></pre>

<hr>
<h2 id='E.matrices'> List of E Matrices </h2><span id='topic+E.matrices'></span>

<h3>Description</h3>

<p>This function constructs and returns a list of lists. The component of
each sublist is a square matrix derived from the column vectors of
an order n identity matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>E.matrices(n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="E.matrices_+3A_n">n</code></td>
<td>
<p> a positive integer for the order of the identity matrix
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Let <code class="reqn">{{\bf{I}}_n} = \lbrack {\begin{array}{cccc}
  {{{\bf{e}}_1}}&amp;{{{\bf{e}}_2}}&amp; \cdots &amp;{{{\bf{e}}_n}}
  \end{array}} \rbrack</code> be the order <code class="reqn">n</code> identity matrix
with corresponding unit vectors <code class="reqn">{{{\bf{e}}_i}}</code> with one in
its <code class="reqn">i</code>th position and zeros elsewhere.  
The <code class="reqn">n \times n</code> matrix <code class="reqn">{{\bf{E}}_{i,j}}</code> is computed
from the unit vectors <code class="reqn">{{{\bf{e}}_i}}</code> and <code class="reqn">{{{\bf{e}}_j}}</code>
as <code class="reqn">{{\bf{E}}_{i,j}} = {{\bf{e}}_i}\;{{\bf{e'}}_j}</code>.  These matrices
are stored as components in a list of lists.
</p>


<h3>Value</h3>

<p>A list with <code class="reqn">n</code> components
</p>
<table>
<tr><td><code>1</code></td>
<td>
<p>A sublist of <code class="reqn">n</code> components</p>
</td></tr>
<tr><td><code>2</code></td>
<td>
<p>A sublist of <code class="reqn">n</code> components</p>
</td></tr>
</table>
<p>...
</p>
<table>
<tr><td><code>n</code></td>
<td>
<p>A sublist of <code class="reqn">n</code> components</p>
</td></tr>
</table>
<p>Each component <code class="reqn">j</code> of sublist <code class="reqn">i</code> is a matrix <code class="reqn">{\bf{E}}_{i,j}</code>
</p>


<h3>Note</h3>

<p>The argument n must be an integer value greater than or equal to 2.
</p>


<h3>Author(s)</h3>

<p> Frederick Novomestky <a href="mailto:fnovomes@poly.edu">fnovomes@poly.edu</a> </p>


<h3>References</h3>

<p>Magnus, J. R. and H. Neudecker (1980). The elimination matrix, some lemmas and applications,
<em>SIAM Journal on Algebraic Discrete Methods</em>, 1(4), December 1980, 422-449.
</p>
<p>Magnus, J. R. and H. Neudecker (1999). <em>Matrix Differential Calculus with Applications in Statistics and Econometrics</em>,
Second Edition, John Wiley.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>E &lt;- E.matrices( 3 )
</code></pre>

<hr>
<h2 id='elimination.matrix'> Elimination matrix for lower triangular matrices </h2><span id='topic+elimination.matrix'></span>

<h3>Description</h3>

<p>This function returns a matrix with n * ( n + 1 ) / 2 rows and N * n columns which
for any lower triangular matrix A transforms vec( A ) into vech(A)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>elimination.matrix(n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="elimination.matrix_+3A_n">n</code></td>
<td>
<p> row or column dimension </p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is a wrapper function to the function <code>L.matrix</code>.
The formula used to compute the L matrix which is also called the elimination matrix is  <code class="reqn">{\bf{L}} = \sum\limits_{j = 1}^n {\sum\limits_{i = j}^n {{{\bf{u}}_{i,j}}{{\left( {vec\;{{\bf{E}}_{i,j}}} \right)}^\prime }} } </code>
<code class="reqn">{{{\bf{u}}_{i,j}}}</code> are the order <code class="reqn">n\left( {n + 1} \right)/2</code> vectors constructed by the function <code>u.vectors</code>.
<code class="reqn">{{{\bf{E}}_{i,j}}}</code> are the <code class="reqn"> n \times n</code> matrices constructed by the function <code>E.matrices</code>.
</p>


<h3>Value</h3>

<p>An <code class="reqn">\left[ {\frac{1}{2}n\left( {n + 1} \right)} \right] \times {n^2}</code> matrix.
</p>


<h3>Note</h3>

<p>If the argument is not an integer, the function displays an error message and stops.
If the argument is less than two, the function displays an error message and stops.
</p>


<h3>Author(s)</h3>

<p> Frederick Novomestky <a href="mailto:fnovomes@poly.edu">fnovomes@poly.edu</a> </p>


<h3>References</h3>

<p>Magnus, J. R. and H. Neudecker (1980). The elimination matrix, some lemmas and applications,
<em>SIAM Journal on Algebraic Discrete Methods</em>, 1(4), December 1980, 422-449.
</p>
<p>Magnus, J. R. and H. Neudecker (1999) <em>Matrix Differential Calculus with Applications in Statistics and Econometrics</em>,
Second Edition, John Wiley.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+E.matrices">E.matrices</a></code>,
<code><a href="#topic+L.matrix">L.matrix</a></code>,
<code><a href="#topic+u.vectors">u.vectors</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>L &lt;- elimination.matrix( 4 )
A &lt;- lower.triangle( matrix( seq( 1, 16, 1 ), nrow=4, byrow=TRUE ) )
vecA &lt;- vec( A )
vechA &lt;- vech( A )
y &lt;- L %*% vecA
print( y )
print( vechA )
</code></pre>

<hr>
<h2 id='entrywise.norm'> Compute the entrywise norm of a matrix </h2><span id='topic+entrywise.norm'></span>

<h3>Description</h3>

<p>This function returns the <code class="reqn">\left\| {\bf{x}} \right\|_p </code> norm of the matrix <code class="reqn">{\mathbf{x}}</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>entrywise.norm(x,p)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="entrywise.norm_+3A_x">x</code></td>
<td>
<p>  a numeric vector or matrix </p>
</td></tr>
<tr><td><code id="entrywise.norm_+3A_p">p</code></td>
<td>
<p>  a real value for the power </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Let <code class="reqn">{\bf{x}}</code> be an <code class="reqn">m \times n</code> numeric matrix.
The formula used to compute the norm is <code class="reqn">\left\| {\bf{x}} \right\|_p  = \left( {\sum\limits_{i = 1}^m {\sum\limits_{j = 1}^n {\left| {x_{i,j} } \right|^p } } } \right)^{{1 \mathord{\left/
 {\vphantom {1 p}} \right.
 } p}}</code>.
</p>


<h3>Value</h3>

<p>A numeric value.
</p>


<h3>Note</h3>

<p>If argument x is not numeric, the function displays an error message and terminates.
If argument x is neither a matrix nor a vector, the function displays an error message and terminates.
If argument p is zero, the function displays an error message and terminates.
</p>


<h3>Author(s)</h3>

<p> Frederick Novomestky <a href="mailto:fnovomes@poly.edu">fnovomes@poly.edu</a> </p>


<h3>References</h3>

<p>Bellman, R. (1987). <em>Matrix Analysis</em>, Second edition, Classics in Applied Mathematics,
Society for Industrial and Applied Mathematics.
</p>
<p>Golub, G. H. and C. F. Van Loan (1996).  <em>Matrix Computations</em>, Third Edition, The John
Hopkins University Press.
</p>
<p>Horn, R. A. and C. R. Johnson (1985). <em>Matrix Analysis</em>, Cambridge University Press.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+one.norm">one.norm</a></code>,
<code><a href="#topic+inf.norm">inf.norm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>A &lt;- matrix( c( 3, 5, 7, 2, 6, 4, 0, 2, 8 ), nrow=3, ncol=3, byrow=TRUE )
print( entrywise.norm( A, 2 ) )
</code></pre>

<hr>
<h2 id='fibonacci.matrix'> Fibonacci Matrix </h2><span id='topic+fibonacci.matrix'></span>

<h3>Description</h3>

<p>This function constructs the order n + 1 square Fibonacci matrix
which is derived from a Fibonacci sequence.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fibonacci.matrix(n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fibonacci.matrix_+3A_n">n</code></td>
<td>
<p> a positive integer value </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Let <code class="reqn">\left\{ {{f_0},\;{f_1},\; \ldots ,\;{f_n}} \right\}</code> be the
set of <code class="reqn"> n + 1</code> Fibonacci numbers where <code class="reqn">{f_0} = {f_1} = 1</code>
and <code class="reqn">{f_j} = {f_{j - 1}} + {f_{j - 2}},\quad 2 \le j \le n</code>.  The
order <code class="reqn">n + 1</code> Fibonacci matrix <code class="reqn">{\bf{F}}</code> has as typical element
<code class="reqn">{F_{i,j}} = \left\{ {\begin{array}{cc}
{{f_{i - j + 1}}}&amp;{i - j + 1 \ge 0}\\
0&amp;{i - j + 1 &lt; 0}
\end{array}} \right.</code>.
</p>


<h3>Value</h3>

<p>An order <code class="reqn">n + 1</code> matrix
</p>


<h3>Note</h3>

<p>If the argument n is not a positive integer, the function presents an error message and stops.
</p>


<h3>Author(s)</h3>

<p> Frederick Novomestky <a href="mailto:fnovomes@poly.edu">fnovomes@poly.edu</a> </p>


<h3>References</h3>

<p>Zhang, Z. and J. Wang (2006). Bernoulli matrix and its algebraic properties,
<em>Discrete Applied Nathematics</em>, 154, 1622-1632.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>F &lt;- fibonacci.matrix( 10 )
print( F )
</code></pre>

<hr>
<h2 id='frobenius.matrix'> Frobenius Matrix </h2><span id='topic+frobenius.matrix'></span>

<h3>Description</h3>

<p>This function returns an order n Frobenius matrix that is useful
in numerical mathematics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>frobenius.matrix(n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="frobenius.matrix_+3A_n">n</code></td>
<td>
<p>  a positive integer value greater than 1</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Frobenius matrix is also called the companion matrix.  It arises
in the solution of systems of linear first order differential equations.
The formula for the order <code class="reqn">n</code> Frobenius matrix is <code class="reqn">{\bf{F}} = 
\left\lbrack {\begin{array}{ccccc}0&amp;0&amp; \cdots &amp;0&amp;{{{\left( { - 1} \right)}^{n - 1}}
\left( {\begin{array}{ccccc}n\\0\end{array}} \right)}\\1&amp;0&amp; \cdots &amp;0&amp;{{{\left( { - 1} \right)}^{n - 2}}
\left( {\begin{array}{ccccc}n\\1\end{array}} \right)}\\0&amp;1&amp; \ddots &amp;0&amp;{{{\left( { - 1} \right)}^{n - 3}}
\left( {\begin{array}{ccccc}n\\2\end{array}} \right)}\\ \vdots &amp; \vdots &amp; \ddots &amp; \vdots &amp; \vdots \\0&amp;0&amp; \cdots &amp;1&amp;{{{\left( { - 1} \right)}^0}
\left( {\begin{array}{ccccc}n\\{n - 1}\end{array}} 
\right)}\end{array}} 
\right\rbrack</code>.
</p>


<h3>Value</h3>

<p>An order <code class="reqn">n</code> matrix
</p>


<h3>Note</h3>

<p>If the argument n is not a positive integer that is greater than 1, 
the function presents an error message and stops.
</p>


<h3>Author(s)</h3>

<p> Frederick Novomestky <a href="mailto:fnovomes@poly.edu">fnovomes@poly.edu</a> </p>


<h3>References</h3>

<p>Aceto, L. and D. Trigiante (2001). Matrices of Pascal and Other Greats,
<em>American Mathematical Monthly</em>, March 2001, 108(3), 232-245.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>F &lt;- frobenius.matrix( 10 )
print( F )
</code></pre>

<hr>
<h2 id='frobenius.norm'> Compute the Frobenius norm of a matrix </h2><span id='topic+frobenius.norm'></span>

<h3>Description</h3>

<p>This function returns the Frobenius norm of the matrix <code class="reqn">{\mathbf{x}}</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>frobenius.norm(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="frobenius.norm_+3A_x">x</code></td>
<td>
<p>  a numeric vector or matrix </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The formula used to compute the norm is <code class="reqn">\left\| {\bf{x}} \right\|_2</code>.
Note that this is the entrywise norm with exponent 2.
</p>


<h3>Value</h3>

<p>A numeric value.
</p>


<h3>Author(s)</h3>

<p> Frederick Novomestky <a href="mailto:fnovomes@poly.edu">fnovomes@poly.edu</a> </p>


<h3>References</h3>

<p>Bellman, R. (1987). <em>Matrix Analysis</em>, Second edition, Classics in Applied Mathematics,
Society for Industrial and Applied Mathematics.
</p>
<p>Golub, G. H. and C. F. Van Loan (1996).  <em>Matrix Computations</em>, Third Edition, The John
Hopkins University Press.
</p>
<p>Horn, R. A. and C. R. Johnson (1985). <em>Matrix Analysis</em>, Cambridge University Press.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+entrywise.norm">entrywise.norm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>A &lt;- matrix( c( 3, 5, 7, 2, 6, 4, 0, 2, 8 ), nrow=3, ncol=3, byrow=TRUE )
print( frobenius.norm( A ) )
</code></pre>

<hr>
<h2 id='frobenius.prod'> Frobenius innter product of matrices </h2><span id='topic+frobenius.prod'></span>

<h3>Description</h3>

<p>This function returns the Fronbenius inner product of two matrices, x and y, with the same row and column dimensions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>frobenius.prod(x, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="frobenius.prod_+3A_x">x</code></td>
<td>
<p> a numeric matrix or vector object </p>
</td></tr>
<tr><td><code id="frobenius.prod_+3A_y">y</code></td>
<td>
<p> a numeric matrix or vector object </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Frobenius inner product is the element-by-element sum of 
the Hadamard or Shur product of two numeric matrices.  Let <code class="reqn">{\bf{x}}</code> and
<code class="reqn">{\bf{y}}</code> be two <code class="reqn">m \times n</code> matrices.  Then Frobenious inner product
is computed as <code class="reqn">\sum\limits_{i = 1}^m {\sum\limits_{j = 1}^n {x_{i,j} \;y_{i,j} } } </code>.
</p>


<h3>Value</h3>

<p>A numeric value.
</p>


<h3>Note</h3>

<p>The function converts vectors to matrices if necessary.
The function stops running if x or y is not numeric and an error message is displayed.
The function also stops running if x and y do not have the same row and column dimensions and an error mesage
is displayed.
</p>


<h3>Author(s)</h3>

<p> Frederick Novomestky <a href="mailto:fnovomes@poly.edu">fnovomes@poly.edu</a> </p>


<h3>References</h3>

<p>Styan, G. P. H. (1973). Hadamard Products and Multivariate Statistical Analysis,
<em>Linear Algebra and Its Applications</em>, Elsevier, 6, 217-240.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+hadamard.prod">hadamard.prod</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- matrix( c( 1, 2, 3, 4 ), nrow=2, byrow=TRUE )
y &lt;- matrix( c( 2, 4, 6, 8 ), nrow=2, byrow=TRUE )
z &lt;- frobenius.prod( x, y )
print( z )
</code></pre>

<hr>
<h2 id='H.matrices'> List of H Matrices </h2><span id='topic+H.matrices'></span>

<h3>Description</h3>

<p>This function constructs and returns a list of lists. The component of
each sublist is derived from column vectors in an order r and order c identity matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>H.matrices(r, c = r)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="H.matrices_+3A_r">r</code></td>
<td>
<p> a positive integer value for an order r identity matrix </p>
</td></tr>
<tr><td><code id="H.matrices_+3A_c">c</code></td>
<td>
<p> a positive integer value for an order c identify matrix </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Let <code class="reqn">{{\bf{I}}_r} = \lbrack {\begin{array}{cccc}
  {{{\bf{a}}_1}}&amp;{{{\bf{a}}_2}}&amp; \cdots &amp;{{{\bf{a}}_r}}
  \end{array}} \rbrack</code> be the order <code class="reqn">r</code> identity matrix
with corresponding unit vectors <code class="reqn">{{{\bf{a}}_i}}</code> with one in
its <code class="reqn">i</code>th position and zeros elsewhere.  
Let <code class="reqn">{{\bf{I}}_c} = \lbrack {\begin{array}{cccc}
  {{{\bf{b}}_1}}&amp;{{{\bf{b}}_2}}&amp; \cdots &amp;{{{\bf{b}}_c}}
  \end{array}} \rbrack</code> be the order <code class="reqn">c</code> identity matrix
with corresponding unit vectors <code class="reqn">{{{\bf{b}}_i}}</code> with one in
its <code class="reqn">i</code>th position and zeros elsewhere.
The <code class="reqn">r \times c</code> matrix <code class="reqn">{\bf{H}}{}_{i,j} = {{\bf{a}}_i}\;{{\bf{b'}}_j}</code>
is used in the computation of the commutation matrix.
</p>


<h3>Value</h3>

<p>A list with <code class="reqn">r</code> components
</p>
<table>
<tr><td><code>1</code></td>
<td>
<p>A sublist of <code class="reqn">c</code> components</p>
</td></tr>
<tr><td><code>2</code></td>
<td>
<p>A sublist of <code class="reqn">c</code> components</p>
</td></tr>
</table>
<p>...
</p>
<table>
<tr><td><code>r</code></td>
<td>
<p>A sublist of c components</p>
</td></tr>
</table>
<p>Each component <code class="reqn">j</code> of sublist <code class="reqn">i</code> is a matrix <code class="reqn">{\bf{H}}_{i,j}</code>
</p>


<h3>Note</h3>

<p>The argument n must be an integer value greater than or equal to two.
</p>


<h3>Author(s)</h3>

<p> Frederick Novomestky <a href="mailto:fnovomes@poly.edu">fnovomes@poly.edu</a> </p>


<h3>References</h3>

<p>Magnus, J. R. and H. Neudecker (1979). The commutation matrix: some properties and
applications, <em>The Annals of Statistics</em>, 7(2), 381-394.
</p>
<p>Magnus, J. R. and H. Neudecker (1980). The elimination matrix, some lemmas and applications,
<em>SIAM Journal on Algebraic Discrete Methods</em>, 1(4), December 1980, 422-449.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>H.2.3 &lt;- H.matrices( 2, 3 )
H.3 &lt;- H.matrices( 3 )
</code></pre>

<hr>
<h2 id='hadamard.prod'> Hadamard product of two matrices </h2><span id='topic+hadamard.prod'></span>

<h3>Description</h3>

<p>This function returns the Hadamard or Shur product of two matrices, x and y, that have the same row and
column dimensions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hadamard.prod(x, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hadamard.prod_+3A_x">x</code></td>
<td>
<p> a numeric matrix or vector object </p>
</td></tr>
<tr><td><code id="hadamard.prod_+3A_y">y</code></td>
<td>
<p> a numeric matrix or vector object </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Hadamard product is an element-by-element product of the two matrices. Let <code class="reqn">{\bf{x}}</code> 
and <code class="reqn">{\bf{x}}</code> be two <code class="reqn">m \times n</code> numeric matrices.  The Hadamard product is <code class="reqn">{\bf{x}}\, \circ \,{\bf{y}} = \left\lbrack {\begin{array}{cccc}
{{x_{1,1}}\,{y_{1,1}}}&amp;{{x_{1,2}}\,{y_{1,2}}}&amp; \cdots &amp;{{x_{1,n}}\,{y_{1,n}}}\\
{{x_{2,1}}\,{y_{121}}}&amp;{{x_{2,2}}\,{y_{2,2}}}&amp; \cdots &amp;{{x_{2,n}}\,{y_{2,n}}}\\
 \cdots &amp; \cdots &amp; \cdots &amp; \cdots \\
{{x_{m,1}}\,{y_{m,1}}}&amp;{{x_{m,2}}\,{y_{m,2}}}&amp; \cdots &amp;{{x_{m,n}}\,{y_{m,n}}}
\end{array}} \right\rbrack</code>.
It uses the * operation in R.
</p>


<h3>Value</h3>

<p>A matrix.
</p>


<h3>Note</h3>

<p>The function converts vectors to matrices if necessary.
The function stops running if x or y is not numeric and an error message is displayed.
The function also stops running if x and y do not have the same row and column dimensions and an error mesage
is displayed.
</p>


<h3>Author(s)</h3>

<p> Frederick Novomestky <a href="mailto:fnovomes@poly.edu">fnovomes@poly.edu</a> </p>


<h3>References</h3>

<p>Hadamard, J (1983). Resolution d'une question relative aux determinants, <em>Bulletin des Sciences
Mathematiques</em>, 17, 240-246.
</p>
<p>Styan, G. P. H. (1973). Hadamard Products and Multivariate Statistical Analysis,
<em>Linear Algebra and Its Applications</em>, Elsevier, 6, 217-240.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- matrix( c( 1, 2, 3, 4 ), nrow=2, byrow=TRUE )
y &lt;- matrix( c( 2, 4, 6, 8 ), nrow=2, byrow=TRUE )
z &lt;- hadamard.prod( x, y )
print( z )
</code></pre>

<hr>
<h2 id='hankel.matrix'> Hankel Matrix </h2><span id='topic+hankel.matrix'></span>

<h3>Description</h3>

<p>This function constructs an order n Hankel matrix from the values in
the order n vector x.  Each row of the matrix is a circular shift of
the values in the previous row.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hankel.matrix(n, x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hankel.matrix_+3A_n">n</code></td>
<td>
<p> a positive integer value for order of matrix greater than 1 </p>
</td></tr>
<tr><td><code id="hankel.matrix_+3A_x">x</code></td>
<td>
<p> a vector of values used to construct the matrix </p>
</td></tr>
</table>


<h3>Details</h3>

<p>A Hankel matrix is a square matrix with constant skew diagonals.
The determinant of a Hankel matrix is called a catalecticant.
Hankel matrices are formed when the hidden Mark model is sought
from a given sequence of data.
</p>


<h3>Value</h3>

<p>An order <code class="reqn">n</code> matrix.
</p>


<h3>Note</h3>

<p>If the argument n is not a positive integer, the function presents an error message and stops.
If the length of x is less than n, the function presents an error message and stops.
</p>


<h3>Author(s)</h3>

<p> Frederick Novomestky <a href="mailto:fnovomes@poly.edu">fnovomes@poly.edu</a> </p>


<h3>References</h3>

<p>Power, S. C. (1982). <em>Hankel Operators on Hilbert Spaces</em>, Research
notes in mathematics, Series 64, Pitman Publishing.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>H &lt;- hankel.matrix( 4, seq( 1, 7 ) )
print( H )
</code></pre>

<hr>
<h2 id='hilbert.matrix'> Hilbert matrices </h2><span id='topic+hilbert.matrix'></span>

<h3>Description</h3>

<p>This function returns an n by n Hilbert matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hilbert.matrix(n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hilbert.matrix_+3A_n">n</code></td>
<td>
<p> Order of the Hilbert matrix </p>
</td></tr>
</table>


<h3>Details</h3>

<p>A Hilbert matrix is an order <code class="reqn">n</code> square matrix of unit fractions with elements 
defined as <code class="reqn">H_{i,j}  = {1 \mathord{\left/
 {\vphantom {1 {\left( {i + j - 1} \right)}}} \right.
 } {\left( {i + j - 1} \right)}}</code>.
</p>


<h3>Value</h3>

<p>A matrix.
</p>


<h3>Note</h3>

<p>If the argument is less than or equal to zero, the function displays an error message and stops.
If the argument is not an integer, the function displays an error message and stops.
</p>


<h3>Author(s)</h3>

<p> Frederick Novomestky <a href="mailto:fnovomes@poly.edu">fnovomes@poly.edu</a> </p>


<h3>References</h3>

<p>Hilbert, David (1894). Ein Beitrag zur Theorie des Legendre schen Polynoms,
<em>Acta Mathematica</em>, Springer, Netherlands, 18, 155-159.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>H &lt;- hilbert.matrix( 4 )
print( H )
</code></pre>

<hr>
<h2 id='hilbert.schmidt.norm'> Compute the Hilbert-Schmidt norm of a matrix </h2><span id='topic+hilbert.schmidt.norm'></span>

<h3>Description</h3>

<p>This function returns the Hilbert-Schmidt norm of the matrix <code class="reqn">{\mathbf{x}}</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hilbert.schmidt.norm(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hilbert.schmidt.norm_+3A_x">x</code></td>
<td>
<p>  a numeric vector or matrix </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The formula used to compute the norm is <code class="reqn">\left\| {\bf{x}} \right\|_2</code>.
This is merely the entrywise norm with exponent 2.
</p>


<h3>Value</h3>

<p>A numeric value.
</p>


<h3>Author(s)</h3>

<p> Frederick Novomestky <a href="mailto:fnovomes@poly.edu">fnovomes@poly.edu</a> </p>


<h3>References</h3>

<p>Bellman, R. (1987). <em>Matrix Analysis</em>, Second edition, Classics in Applied Mathematics,
Society for Industrial and Applied Mathematics.
</p>
<p>Golub, G. H. and C. F. Van Loan (1996).  <em>Matrix Computations</em>, Third Edition, The John
Hopkins University Press.
</p>
<p>Horn, R. A. and C. R. Johnson (1985). <em>Matrix Analysis</em>, Cambridge University Press.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+entrywise.norm">entrywise.norm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>A &lt;- matrix( c( 3, 5, 7, 2, 6, 4, 0, 2, 8 ), nrow=3, ncol=3, byrow=TRUE )
print( hilbert.schmidt.norm( A ) )
</code></pre>

<hr>
<h2 id='inf.norm'> Compute the infinitity norm of a matrix </h2><span id='topic+inf.norm'></span>

<h3>Description</h3>

<p>This function returns the <code class="reqn">\left\| {\mathbf{x}} \right\|_\infty </code> norm of the matrix <code class="reqn">{\mathbf{x}}</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inf.norm(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="inf.norm_+3A_x">x</code></td>
<td>
<p>  a numeric vector or matrix </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Let <code class="reqn">{\bf{x}}</code> be an <code class="reqn">m \times n</code> numeric matrix.
The formula used to compute the norm is 
<code class="reqn">\left\| {\bf{x}} \right\|_\infty   = \mathop {\max }\limits_{1 \le i \le m} \sum\limits_{j = 1}^n {\left| {x_{i,j} } \right|} </code>.
This is merely the maximum absolute row sum of the <code class="reqn">m \times n</code> maxtris.
</p>


<h3>Value</h3>

<p>A numeric value.
</p>


<h3>Author(s)</h3>

<p> Frederick Novomestky <a href="mailto:fnovomes@poly.edu">fnovomes@poly.edu</a> </p>


<h3>References</h3>

<p>Bellman, R. (1987). <em>Matrix Analysis</em>, Second edition, Classics in Applied Mathematics,
Society for Industrial and Applied Mathematics.
</p>
<p>Golub, G. H. and C. F. Van Loan (1996).  <em>Matrix Computations</em>, Third Edition, The John
Hopkins University Press.
</p>
<p>Horn, R. A. and C. R. Johnson (1985). <em>Matrix Analysis</em>, Cambridge University Press.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+one.norm">one.norm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>A &lt;- matrix( c( 3, 5, 7, 2, 6, 4, 0, 2, 8 ), nrow=3, ncol=3, byrow=TRUE )
print( inf.norm( A ) )
</code></pre>

<hr>
<h2 id='is.diagonal.matrix'> Test for diagonal square matrix </h2><span id='topic+is.diagonal.matrix'></span>

<h3>Description</h3>

<p>This function returns <code>TRUE</code> if the given matrix argument x
is a square numeric matrix and that the off-diagonal elements are close
to zero in absolute value to within the given tolerance level. Otherwise,
a <code>FALSE</code> value is returned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.diagonal.matrix(x, tol = 1e-08)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.diagonal.matrix_+3A_x">x</code></td>
<td>
<p> a numeric square matrix </p>
</td></tr>
<tr><td><code id="is.diagonal.matrix_+3A_tol">tol</code></td>
<td>
<p> a numeric tolerance level usually left out </p>
</td></tr>
</table>


<h3>Value</h3>

<p>A TRUE or FALSE value.
</p>


<h3>Author(s)</h3>

<p> Frederick Novomestky <a href="mailto:fnovomes@poly.edu">fnovomes@poly.edu</a> </p>


<h3>References</h3>

<p>Bellman, R. (1987). <em>Matrix Analysis</em>, Second edition, Classics in Applied Mathematics,
Society for Industrial and Applied Mathematics.
</p>
<p>Horn, R. A. and C. R. Johnson (1990). <em>Matrix Analysis</em>, Cambridge University Press.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>A &lt;- diag( 1, 3 )
is.diagonal.matrix( A )
B &lt;- matrix( c( 1, 2, 3, 4 ), nrow=2, byrow=TRUE )
is.diagonal.matrix( B )
C &lt;- matrix( c( 1, 0, 0, 0 ), nrow=2, byrow=TRUE )
is.diagonal.matrix( C )
</code></pre>

<hr>
<h2 id='is.idempotent.matrix'> Test for idempotent square matrix </h2><span id='topic+is.idempotent.matrix'></span>

<h3>Description</h3>

<p>This function returns a <code>TRUE</code> value if the square matrix argument x
is idempotent, that is, the product of the matrix with itself is the matrix.
The equality test is performed to within the specified tolerance level.  If
the matrix is not idempotent, then a <code>FALSE</code> value is returned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.idempotent.matrix(x, tol = 1e-08)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.idempotent.matrix_+3A_x">x</code></td>
<td>
<p> a numeric square matrix </p>
</td></tr>
<tr><td><code id="is.idempotent.matrix_+3A_tol">tol</code></td>
<td>
<p> a numeric tolerance level usually left out </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Idempotent matrices are used in econometric analysis.  Consider the problem of
estimating the regression parameters of a standard linear model 
<code class="reqn">{\bf{y}} = {\bf{X}}\;{\bf{\beta }} + {\bf{e}}</code> using the method of least squares.
<code class="reqn">{\bf{y}}</code> is an order <code class="reqn">m</code> random vector of dependent variables. 
<code class="reqn">{\bf{X}}</code> is an <code class="reqn">m \times n</code> matrix whose columns are columns of
observations on one of the <code class="reqn"> n - 1</code> independent variables.  The first column
contains <code class="reqn">m</code> ones.  <code class="reqn">{\bf{e}}</code> is an order <code class="reqn">m</code> random vector of zero
mean residual values.  <code class="reqn">{\bf{\beta }}</code> is the order <code class="reqn">n</code> vector of regression
parameters.  The objective function that is minimized in the method of least squares is
<code class="reqn">\left( {{\bf{y}} - {\bf{X}}\;{\bf{\beta }}} \right)^\prime  \left( {{\bf{y}} - {\bf{X}}\;{\bf{\beta }}} \right)</code>.
The solution to ths quadratic programming problem is
<code class="reqn">{\bf{\hat \beta }} = \left[ {\left( {{\bf{X'}}\;{\bf{X}}} \right)^{ - 1} \;{\bf{X'}}} \right]\;{\bf{y}}</code>
The corresponding estimator for the residual vector is
<code class="reqn">{\bf{\hat e}} = {\bf{y}} - {\bf{X}}\;{\bf{\hat \beta }} = \left[ {{\bf{I}} - {\bf{X}}\;\left( {{\bf{X'}}\;{\bf{X}}} \right)^{ - 1} {\bf{X'}}} \right]{\bf{y}} = {\bf{M}}\;{\bf{y}}</code>.
<code class="reqn">{\bf{M}}</code> and <code class="reqn">{{\bf{X}}\;\left( {{\bf{X'}}\;{\bf{X}}} \right)^{ - 1} {\bf{X'}}}</code> are idempotent.
Idempotency of <code class="reqn">{\bf{M}}</code> enters into the estimation of the variance of the estimator.
</p>


<h3>Value</h3>

<p>A TRUE or FALSE value.
</p>


<h3>Author(s)</h3>

<p> Frederick Novomestky <a href="mailto:fnovomes@poly.edu">fnovomes@poly.edu</a> </p>


<h3>References</h3>

<p>Bellman, R. (1987). <em>Matrix Analysis</em>, Second edition, Classics in Applied Mathematics,
Society for Industrial and Applied Mathematics.
</p>
<p>Chang, A. C., (1984). <em>Fundamental Methods of Mathematical Economics</em>,
Third edition, McGraw-Hill.
</p>
<p>Green, W. H. (2003). <em>Econometric Analysis</em>, Fifth edition, Prentice-Hall.
</p>
<p>Horn, R. A. and C. R. Johnson (1990). <em>Matrix Analysis</em>, Cambridge University Press.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>A &lt;- diag( 1, 3 )
is.idempotent.matrix( A )
B &lt;- matrix( c( 1, 2, 3, 4 ), nrow=2, byrow=TRUE )
is.idempotent.matrix( B )
C &lt;- matrix( c( 1, 0, 0, 0 ), nrow=2, byrow=TRUE )
is.idempotent.matrix( C )
</code></pre>

<hr>
<h2 id='is.indefinite'> Test matrix for positive indefiniteness </h2><span id='topic+is.indefinite'></span>

<h3>Description</h3>

<p>This function returns TRUE if the argument, a square symmetric real matrix x, is indefinite.
That is, the matrix has both positive and negative eigenvalues.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.indefinite(x, tol=1e-8)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.indefinite_+3A_x">x</code></td>
<td>
<p> a matrix </p>
</td></tr>
<tr><td><code id="is.indefinite_+3A_tol">tol</code></td>
<td>
<p> a numeric tolerance level </p>
</td></tr>
</table>


<h3>Details</h3>

<p>For an indefinite matrix, the matrix should positive and negative eigenvalues. The R function <code>eigen</code>
is used to compute the eigenvalues. If any of the eigenvalues is absolute value is less than the
given tolerance, that eigenvalue is replaced with zero. If the matrix has both positive and
negative eigenvalues, it is declared to be indefinite.
</p>


<h3>Value</h3>

<p>TRUE or FALSE.
</p>


<h3>Author(s)</h3>

<p> Frederick Novomestky <a href="mailto:fnovomes@poly.edu">fnovomes@poly.edu</a> </p>


<h3>References</h3>

<p>Bellman, R. (1987). <em>Matrix Analysis</em>, Second edition, Classics in Applied Mathematics,
Society for Industrial and Applied Mathematics.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+is.positive.definite">is.positive.definite</a></code>, 
<code><a href="#topic+is.positive.semi.definite">is.positive.semi.definite</a></code>, 
<code><a href="#topic+is.negative.definite">is.negative.definite</a></code>, 
<code><a href="#topic+is.negative.semi.definite">is.negative.semi.definite</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>###
### identity matrix is always positive definite
###
I &lt;- diag( 1, 3 )
is.indefinite( I )
###
### positive definite matrix
### eigenvalues are 3.4142136 2.0000000 0.585786
###
A &lt;- matrix( c( 2, -1, 0, -1, 2, -1, 0, -1, 2 ), nrow=3, byrow=TRUE )
is.indefinite( A )
###
### positive semi-defnite matrix
### eigenvalues are 4.732051 1.267949 8.881784e-16
###
B &lt;- matrix( c( 2, -1, 2, -1, 2, -1, 2, -1, 2 ), nrow=3, byrow=TRUE )
is.indefinite( B )
###
### negative definite matrix
### eigenvalues are -0.5857864 -2.0000000 -3.4142136
###
C &lt;- matrix( c( -2, 1, 0, 1, -2, 1, 0, 1, -2 ), nrow=3, byrow=TRUE )
is.indefinite( C )
###
### negative semi-definite matrix
### eigenvalues are 1.894210e-16 -1.267949 -4.732051
###
D &lt;- matrix( c( -2, 1, -2, 1, -2, 1, -2, 1, -2 ), nrow=3, byrow=TRUE )
is.indefinite( D )
###
### indefinite matrix
### eigenvalues are 3.828427  1.000000 -1.828427
###
E &lt;- matrix( c( 1, 2, 0, 2, 1, 2, 0, 2, 1 ), nrow=3, byrow=TRUE )
is.indefinite( E )
</code></pre>

<hr>
<h2 id='is.negative.definite'> Test matrix for negative definiteness </h2><span id='topic+is.negative.definite'></span>

<h3>Description</h3>

<p>This function returns TRUE if the argument, a square symmetric real matrix x, is negative definite.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.negative.definite(x, tol=1e-8)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.negative.definite_+3A_x">x</code></td>
<td>
<p> a matrix </p>
</td></tr>
<tr><td><code id="is.negative.definite_+3A_tol">tol</code></td>
<td>
<p> a numeric tolerance level </p>
</td></tr>
</table>


<h3>Details</h3>

<p>For a negative definite matrix, the eigenvalues should be negative. The R function <code>eigen</code>
is used to compute the eigenvalues. If any of the eigenvalues in absolute value is less than
the given tolerance, that eigenvalue is replaced with zero. If any of the eigenvalues is greater than or equal to zero,
then the matrix is not negative definite.   Otherwise, the matrix is declared to be negative definite.
</p>


<h3>Value</h3>

<p>TRUE or FALSE.
</p>


<h3>Author(s)</h3>

<p> Frederick Novomestky <a href="mailto:fnovomes@poly.edu">fnovomes@poly.edu</a> </p>


<h3>References</h3>

<p>Bellman, R. (1987). <em>Matrix Analysis</em>, Second edition, Classics in Applied Mathematics,
Society for Industrial and Applied Mathematics.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+is.positive.definite">is.positive.definite</a></code>, 
<code><a href="#topic+is.positive.semi.definite">is.positive.semi.definite</a></code>, 
<code><a href="#topic+is.negative.semi.definite">is.negative.semi.definite</a></code>, 
<code><a href="#topic+is.indefinite">is.indefinite</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>###
### identity matrix is always positive definite
I &lt;- diag( 1, 3 )
is.negative.definite( I )
###
### positive definite matrix
### eigenvalues are 3.4142136 2.0000000 0.585786
###
A &lt;- matrix( c( 2, -1, 0, -1, 2, -1, 0, -1, 2 ), nrow=3, byrow=TRUE )
is.negative.definite( A )
###
### positive semi-defnite matrix
### eigenvalues are 4.732051 1.267949 8.881784e-16
###
B &lt;- matrix( c( 2, -1, 2, -1, 2, -1, 2, -1, 2 ), nrow=3, byrow=TRUE )
is.negative.definite( B )
###
### negative definite matrix
### eigenvalues are -0.5857864 -2.0000000 -3.4142136
###
C &lt;- matrix( c( -2, 1, 0, 1, -2, 1, 0, 1, -2 ), nrow=3, byrow=TRUE )
is.negative.definite( C )
###
### negative semi-definite matrix
### eigenvalues are 1.894210e-16 -1.267949 -4.732051
###
D &lt;- matrix( c( -2, 1, -2, 1, -2, 1, -2, 1, -2 ), nrow=3, byrow=TRUE )
is.negative.definite( D )
###
### indefinite matrix
### eigenvalues are 3.828427  1.000000 -1.828427
###
E &lt;- matrix( c( 1, 2, 0, 2, 1, 2, 0, 2, 1 ), nrow=3, byrow=TRUE )
is.negative.definite( E )
</code></pre>

<hr>
<h2 id='is.negative.semi.definite'> Test matrix for negative semi definiteness </h2><span id='topic+is.negative.semi.definite'></span>

<h3>Description</h3>

<p>This function returns TRUE if the argument, a square symmetric real matrix x, is negative semi-negative.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.negative.semi.definite(x, tol=1e-8)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.negative.semi.definite_+3A_x">x</code></td>
<td>
<p> a matrix </p>
</td></tr>
<tr><td><code id="is.negative.semi.definite_+3A_tol">tol</code></td>
<td>
<p> a numeric tolerance level </p>
</td></tr>
</table>


<h3>Details</h3>

<p>For a negative semi-definite matrix, the eigenvalues should be non-positive. 
The R function <code>eigen</code> is used to compute the eigenvalues. 
If any of the eigenvalues in absolute value is less than the given tolerance, that eigenvalue
is replaced with zero.  Then, if any of the eigenvalues is greater than zero, the matrix
is not negative semi-definite.  Otherwise, the matrix is declared to be negative semi-definite.
</p>


<h3>Value</h3>

<p>TRUE or FALSE.
</p>


<h3>Author(s)</h3>

<p> Frederick Novomestky <a href="mailto:fnovomes@poly.edu">fnovomes@poly.edu</a> </p>


<h3>References</h3>

<p>Bellman, R. (1987). <em>Matrix Analysis</em>, Second edition, Classics in Applied Mathematics,
Society for Industrial and Applied Mathematics.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+is.positive.definite">is.positive.definite</a></code>, 
<code><a href="#topic+is.positive.semi.definite">is.positive.semi.definite</a></code>, 
<code><a href="#topic+is.negative.definite">is.negative.definite</a></code>, 
<code><a href="#topic+is.indefinite">is.indefinite</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>###
### identity matrix is always positive definite
I &lt;- diag( 1, 3 )
is.negative.semi.definite( I )
###
### positive definite matrix
### eigenvalues are 3.4142136 2.0000000 0.585786
###
A &lt;- matrix( c( 2, -1, 0, -1, 2, -1, 0, -1, 2 ), nrow=3, byrow=TRUE )
is.negative.semi.definite( A )
###
### positive semi-defnite matrix
### eigenvalues are 4.732051 1.267949 8.881784e-16
###
B &lt;- matrix( c( 2, -1, 2, -1, 2, -1, 2, -1, 2 ), nrow=3, byrow=TRUE )
is.negative.semi.definite( B )
###
### negative definite matrix
### eigenvalues are -0.5857864 -2.0000000 -3.4142136
###
C &lt;- matrix( c( -2, 1, 0, 1, -2, 1, 0, 1, -2 ), nrow=3, byrow=TRUE )
is.negative.semi.definite( C )
###
### negative semi-definite matrix
### eigenvalues are 1.894210e-16 -1.267949 -4.732051
###
D &lt;- matrix( c( -2, 1, -2, 1, -2, 1, -2, 1, -2 ), nrow=3, byrow=TRUE )
is.negative.semi.definite( D )
###
### indefinite matrix
### eigenvalues are 3.828427  1.000000 -1.828427
###
E &lt;- matrix( c( 1, 2, 0, 2, 1, 2, 0, 2, 1 ), nrow=3, byrow=TRUE )
is.negative.semi.definite( E )
</code></pre>

<hr>
<h2 id='is.non.singular.matrix'> Test if matrix is non-singular </h2><span id='topic+is.non.singular.matrix'></span>

<h3>Description</h3>

<p>This function returns <code>TRUE</code> is the matrix argument is non-singular
and <code>FALSE</code> otherwise.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.non.singular.matrix(x, tol = 1e-08)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.non.singular.matrix_+3A_x">x</code></td>
<td>
<p> a numeric square matrix </p>
</td></tr>
<tr><td><code id="is.non.singular.matrix_+3A_tol">tol</code></td>
<td>
<p> a numeric tolerance level usually left out </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The determinant of the matrix <code>x</code> is first computed.
If the absolute value of the determinant is greater than or equal to the given
tolerance level, then a <code>TRUE</code> value is returned.
Otherwise, a <code>FALSE</code> value is returned.
</p>


<h3>Value</h3>

<p>TRUE or FALSE value.
</p>


<h3>Author(s)</h3>

<p> Frederick Novomestky <a href="mailto:fnovomes@poly.edu">fnovomes@poly.edu</a> </p>


<h3>References</h3>

<p>Bellman, R. (1987). <em>Matrix Analysis</em>, Second edition, Classics in Applied Mathematics,
Society for Industrial and Applied Mathematics.
</p>
<p>Horn, R. A. and C. R. Johnson (1990). <em>Matrix Analysis</em>, Cambridge University Press.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+is.singular.matrix">is.singular.matrix</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>A &lt;- diag( 1, 3 )
is.non.singular.matrix( A )
B &lt;- matrix( c( 0, 0, 3, 4 ), nrow=2, byrow=TRUE )
is.non.singular.matrix( B )
</code></pre>

<hr>
<h2 id='is.positive.definite'> Test matrix for positive definiteness </h2><span id='topic+is.positive.definite'></span>

<h3>Description</h3>

<p>This function returns TRUE if the argument, a square symmetric real matrix x, is positive definite.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.positive.definite(x, tol=1e-8)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.positive.definite_+3A_x">x</code></td>
<td>
<p> a matrix </p>
</td></tr>
<tr><td><code id="is.positive.definite_+3A_tol">tol</code></td>
<td>
<p> a numeric tolerance level </p>
</td></tr>
</table>


<h3>Details</h3>

<p>For a positive definite matrix, the eigenvalues should be positive. The R function <code>eigen</code>
is used to compute the eigenvalues. If any of the eigenvalues in absolute value is less than the
given tolerance, that eigenvalue is replaced with zero. If any of the eigenvalues is less than or equal to zero,
then the matrix is not positive definite.  Otherwise, the matrix is declared to be positive definite.
</p>


<h3>Value</h3>

<p>TRUE or FALSE.
</p>


<h3>Author(s)</h3>

<p> Frederick Novomestky <a href="mailto:fnovomes@poly.edu">fnovomes@poly.edu</a> </p>


<h3>References</h3>

<p>Bellman, R. (1987). <em>Matrix Analysis</em>, Second edition, Classics in Applied Mathematics,
Society for Industrial and Applied Mathematics.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+is.positive.semi.definite">is.positive.semi.definite</a></code>, 
<code><a href="#topic+is.negative.definite">is.negative.definite</a></code>, 
<code><a href="#topic+is.negative.semi.definite">is.negative.semi.definite</a></code>, 
<code><a href="#topic+is.indefinite">is.indefinite</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>###
### identity matrix is always positive definite
I &lt;- diag( 1, 3 )
is.positive.definite( I )
###
### positive definite matrix
### eigenvalues are 3.4142136 2.0000000 0.585786
###
A &lt;- matrix( c( 2, -1, 0, -1, 2, -1, 0, -1, 2 ), nrow=3, byrow=TRUE )
is.positive.definite( A )
###
### positive semi-defnite matrix
### eigenvalues are 4.732051 1.267949 8.881784e-16
###
B &lt;- matrix( c( 2, -1, 2, -1, 2, -1, 2, -1, 2 ), nrow=3, byrow=TRUE )
is.positive.definite( B )
###
### negative definite matrix
### eigenvalues are -0.5857864 -2.0000000 -3.4142136
###
C &lt;- matrix( c( -2, 1, 0, 1, -2, 1, 0, 1, -2 ), nrow=3, byrow=TRUE )
is.positive.definite( C )
###
### negative semi-definite matrix
### eigenvalues are 1.894210e-16 -1.267949 -4.732051
###
D &lt;- matrix( c( -2, 1, -2, 1, -2, 1, -2, 1, -2 ), nrow=3, byrow=TRUE )
is.positive.definite( D )
###
### indefinite matrix
### eigenvalues are 3.828427  1.000000 -1.828427
###
E &lt;- matrix( c( 1, 2, 0, 2, 1, 2, 0, 2, 1 ), nrow=3, byrow=TRUE )
is.positive.definite( E )
</code></pre>

<hr>
<h2 id='is.positive.semi.definite'> Test matrix for positive semi-definiteness </h2><span id='topic+is.positive.semi.definite'></span>

<h3>Description</h3>

<p>This function returns TRUE if the argument, a square symmetric real matrix x, is positive  semi-definite.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.positive.semi.definite(x, tol=1e-8)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.positive.semi.definite_+3A_x">x</code></td>
<td>
<p> a matrix </p>
</td></tr>
<tr><td><code id="is.positive.semi.definite_+3A_tol">tol</code></td>
<td>
<p> a numeric tolerance level </p>
</td></tr>
</table>


<h3>Details</h3>

<p>For a positive semi-definite matrix, the eigenvalues should be non-negative. The R function <code>eigen</code>
is used to compute the eigenvalues. If any of the eigenvalues is less than zero,
then the matrix is not positive semi-definite.  Otherwise, the matrix is declared
to be positive semi-definite.
</p>


<h3>Value</h3>

<p>TRUE or FALSE.
</p>


<h3>Author(s)</h3>

<p> Frederick Novomestky <a href="mailto:fnovomes@poly.edu">fnovomes@poly.edu</a> </p>


<h3>References</h3>

<p>Bellman, R. (1987). <em>Matrix Analysis</em>, Second edition, Classics in Applied Mathematics,
Society for Industrial and Applied Mathematics.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+is.positive.definite">is.positive.definite</a></code>, 
<code><a href="#topic+is.negative.definite">is.negative.definite</a></code>, 
<code><a href="#topic+is.negative.semi.definite">is.negative.semi.definite</a></code>, 
<code><a href="#topic+is.indefinite">is.indefinite</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>###
### identity matrix is always positive definite
I &lt;- diag( 1, 3 )
is.positive.semi.definite( I )
###
### positive definite matrix
### eigenvalues are 3.4142136 2.0000000 0.585786
###
A &lt;- matrix( c( 2, -1, 0, -1, 2, -1, 0, -1, 2 ), nrow=3, byrow=TRUE )
is.positive.semi.definite( A )
###
### positive semi-defnite matrix
### eigenvalues are 4.732051 1.267949 8.881784e-16
###
B &lt;- matrix( c( 2, -1, 2, -1, 2, -1, 2, -1, 2 ), nrow=3, byrow=TRUE )
is.positive.semi.definite( B )
###
### negative definite matrix
### eigenvalues are -0.5857864 -2.0000000 -3.4142136
###
C &lt;- matrix( c( -2, 1, 0, 1, -2, 1, 0, 1, -2 ), nrow=3, byrow=TRUE )
is.positive.semi.definite( C )
###
### negative semi-definite matrix
### eigenvalues are 1.894210e-16 -1.267949 -4.732051
###
D &lt;- matrix( c( -2, 1, -2, 1, -2, 1, -2, 1, -2 ), nrow=3, byrow=TRUE )
is.positive.semi.definite( D )
###
### indefinite matrix
### eigenvalues are 3.828427  1.000000 -1.828427
###
E &lt;- matrix( c( 1, 2, 0, 2, 1, 2, 0, 2, 1 ), nrow=3, byrow=TRUE )
is.positive.semi.definite( E )
</code></pre>

<hr>
<h2 id='is.singular.matrix'>  Test for singular square matrix </h2><span id='topic+is.singular.matrix'></span>

<h3>Description</h3>

<p>This function returns <code>TRUE</code> is the matrix argument is singular
and <code>FALSE</code> otherwise.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.singular.matrix(x, tol = 1e-08)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.singular.matrix_+3A_x">x</code></td>
<td>
<p> a numeric square matrix </p>
</td></tr>
<tr><td><code id="is.singular.matrix_+3A_tol">tol</code></td>
<td>
<p> a numeric tolerance level usually left out </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The determinant of the matrix <code>x</code> is first computed.
If the absolute value of the determinant is less than the given
tolerance level, then a <code>TRUE</code> value is returned.
Otherwise, a <code>FALSE</code> value is returned.
</p>


<h3>Value</h3>

<p>A TRUE or FALSE value.
</p>


<h3>Author(s)</h3>

<p> Frederick Novomestky <a href="mailto:fnovomes@poly.edu">fnovomes@poly.edu</a> </p>


<h3>References</h3>

<p>Bellman, R. (1987). <em>Matrix Analysis</em>, Second edition, Classics in Applied Mathematics,
Society for Industrial and Applied Mathematics.
</p>
<p>Horn, R. A. and C. R. Johnson (1990). <em>Matrix Analysis</em>, Cambridge University Press.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+is.non.singular.matrix">is.non.singular.matrix</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>A &lt;- diag( 1, 3 )
is.singular.matrix( A )
B &lt;- matrix( c( 0, 0, 3, 4 ), nrow=2, byrow=TRUE )
is.singular.matrix( B )
</code></pre>

<hr>
<h2 id='is.skew.symmetric.matrix'> Test for a skew-symmetric matrix </h2><span id='topic+is.skew.symmetric.matrix'></span>

<h3>Description</h3>

<p>This function returns <code>TRUE</code> if the matrix argument x is
a skew symmetric matrix, i.e., the transpose of the matrix is
the negative of the matrix.  Otherwise, <code>FALSE</code> is returned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.skew.symmetric.matrix(x, tol = 1e-08)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.skew.symmetric.matrix_+3A_x">x</code></td>
<td>
<p> a numeric square matrix </p>
</td></tr>
<tr><td><code id="is.skew.symmetric.matrix_+3A_tol">tol</code></td>
<td>
<p> a numeric tolerance level usually left out </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Let <code class="reqn">{\bf{x}}</code> be an order <code class="reqn">n</code> matrix.  If every element
of the matrix <code class="reqn">{\bf{x}} + {\bf{x'}}</code> in absolute value is less
than the given tolerance, then the matrix argument is declared to be
skew symmetric.
</p>


<h3>Value</h3>

<p>A TRUE or FALSE value.
</p>


<h3>Author(s)</h3>

<p> Frederick Novomestky <a href="mailto:fnovomes@poly.edu">fnovomes@poly.edu</a> </p>


<h3>References</h3>

<p>Bellman, R. (1987). <em>Matrix Analysis</em>, Second edition, Classics in Applied Mathematics,
Society for Industrial and Applied Mathematics.
</p>
<p>Horn, R. A. and C. R. Johnson (1990). <em>Matrix Analysis</em>, Cambridge University Press.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>A &lt;- diag( 1, 3 )
is.skew.symmetric.matrix( A )
B &lt;- matrix( c( 0, -2, -1, -2, 0, -4, 1, 4, 0 ), nrow=3, byrow=TRUE )
is.skew.symmetric.matrix( B )
C &lt;- matrix( c( 0, 2, 1, 2, 0, 4, 1, 4, 0 ), nrow=3, byrow=TRUE )
is.skew.symmetric.matrix( C )
</code></pre>

<hr>
<h2 id='is.square.matrix'> Test for square matrix </h2><span id='topic+is.square.matrix'></span>

<h3>Description</h3>

<p>The function returns TRUE if the argument is a square matrix and FALSE otherwise.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.square.matrix(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.square.matrix_+3A_x">x</code></td>
<td>
<p> a matrix </p>
</td></tr>
</table>


<h3>Value</h3>

<p>TRUE or FALSE
</p>


<h3>Author(s)</h3>

<p> Frederick Novomestky <a href="mailto:fnovomes@poly.edu">fnovomes@poly.edu</a> </p>


<h3>References</h3>

<p>Bellman, R. (1987). <em>Matrix Analysis</em>, Second edition, Classics in Applied Mathematics,
Society for Industrial and Applied Mathematics.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>A &lt;- matrix( seq( 1, 12, 1 ), nrow=3, byrow=TRUE )
is.square.matrix( A )
B &lt;- matrix( seq( 1, 16, 1 ), nrow=4, byrow=TRUE )
is.square.matrix( B )
</code></pre>

<hr>
<h2 id='is.symmetric.matrix'> Test for symmetric numeric matrix </h2><span id='topic+is.symmetric.matrix'></span>

<h3>Description</h3>

<p>This function returns TRUE if the argument is a numeric symmetric square matrix and FALSE otherwise.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.symmetric.matrix(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.symmetric.matrix_+3A_x">x</code></td>
<td>
<p> an R object </p>
</td></tr>
</table>


<h3>Value</h3>

<p>TRUE or FALSE.
</p>


<h3>Note</h3>

 
<p>If the argument is not a numeric matrix, the function displays an error message and stops.
If the argument is not a square matrix, the function displays an error message and stops.
</p>


<h3>Author(s)</h3>

<p> Frederick Novomestky <a href="mailto:fnovomes@poly.edu">fnovomes@poly.edu</a> </p>


<h3>References</h3>

<p>Bellman, R. (1987). <em>Matrix Analysis</em>, Second edition, Classics in Applied Mathematics,
Society for Industrial and Applied Mathematics.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+is.square.matrix">is.square.matrix</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>A &lt;- matrix( c( 1, 2, 3, 4 ), nrow=2, byrow=TRUE )
is.symmetric.matrix( A )
B &lt;- matrix( c( 1, 2, 2, 1 ), nrow=2, byrow=TRUE )
is.symmetric.matrix( B )
</code></pre>

<hr>
<h2 id='K.matrix'> K Matrix </h2><span id='topic+K.matrix'></span>

<h3>Description</h3>

<p>This function returns a square matrix of order p = r * c that, 
for an r by c matrix A, transforms vec(A) to vec(A') where 
prime denotes transpose.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>K.matrix(r, c = r)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="K.matrix_+3A_r">r</code></td>
<td>
<p> a positive integer row dimension </p>
</td></tr>
<tr><td><code id="K.matrix_+3A_c">c</code></td>
<td>
<p> a positive integer column dimension </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code class="reqn">r \times c</code> matrices <code class="reqn">{\bf{H}}{}_{i,j}</code> constructed
by the function <code>H.matrices</code> are combined using direct product
to generate the commutation product with the formula  <code class="reqn">{{\bf{K}}_{r,c}} = \sum\limits_{i = 1}^r {\sum\limits_{j = 1}^c {\left( {{{\bf{H}}_{i,j}} \otimes {{{\bf{H'}}}_{i,j}}} \right)} }</code>
</p>


<h3>Value</h3>

<p>An order <code class="reqn">\left( {r\;c} \right)</code> matrix.
</p>


<h3>Note</h3>

<p>If either argument is less than 2, then the function stops and displays an appropriate error mesage.
If either argument is not an integer, then the function stops and displays an appropriate error mesage
</p>


<h3>Author(s)</h3>

<p> Frederick Novomestky <a href="mailto:fnovomes@poly.edu">fnovomes@poly.edu</a> </p>


<h3>References</h3>

<p>Magnus, J. R. and H. Neudecker (1979). The commutation matrix: some properties and applications,
<em>The Annals of Statistics</em>, 7(2), 381-394.
</p>
<p>Magnus, J. R. and H. Neudecker (1999) <em>Matrix Differential Calculus with Applications in Statistics and Econometrics</em>,
Second Edition, John Wiley.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+H.matrices">H.matrices</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>K &lt;- K.matrix( 3, 4 )
A &lt;- matrix( seq( 1, 12, 1 ), nrow=3, byrow=TRUE )
vecA &lt;- vec( A )
vecAt &lt;- vec( t( A ) )
y &lt;- K %*% vecA
print( y )
print( vecAt )
</code></pre>

<hr>
<h2 id='L.matrix'> Construct L Matrix </h2><span id='topic+L.matrix'></span>

<h3>Description</h3>

<p>This function returns a matrix with n * ( n + 1 ) / 2 rows and N * n columns which
for any lower triangular matrix A transforms vec( A ) into vech(A)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>L.matrix(n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="L.matrix_+3A_n">n</code></td>
<td>
<p> a positive integer order for the associated matrix A </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The formula used to compute the L matrix which is also called the elimination matrix is  <code class="reqn">{\bf{L}} = \sum\limits_{j = 1}^n {\sum\limits_{i = j}^n {{{\bf{u}}_{i,j}}{{\left( {vec\;{{\bf{E}}_{i,j}}} \right)}^\prime }} } </code>
<code class="reqn">{{{\bf{u}}_{i,j}}}</code> are the <code class="reqn">n \times 1</code> vectors constructed by the function <code>u.vectors</code>.
<code class="reqn">{{{\bf{E}}_{i,j}}}</code> are the <code class="reqn"> n \times n</code> matrices constructed by the function <code>E.matrices</code>.
</p>


<h3>Value</h3>

<p>An <code class="reqn">\left[ {\frac{1}{2}n\left( {n + 1} \right)} \right] \times {n^2}</code> matrix.
</p>


<h3>Note</h3>

<p>If the argument is not an integer, the function displays an error message and stops.
If the argument is less than two, the function displays an error message and stops.
</p>


<h3>Author(s)</h3>

<p> Frederick Novomestky <a href="mailto:fnovomes@poly.edu">fnovomes@poly.edu</a> </p>


<h3>References</h3>

<p>Magnus, J. R. and H. Neudecker (1980). The elimination matrix, some lemmas and applications,
<em>SIAM Journal on Algebraic Discrete Methods</em>, 1(4), December 1980, 422-449.
</p>
<p>Magnus, J. R. and H. Neudecker (1999) <em>Matrix Differential Calculus with Applications in Statistics and Econometrics</em>,
Second Edition, John Wiley.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+elimination.matrix">elimination.matrix</a></code>,
<code><a href="#topic+E.matrices">E.matrices</a></code>,
<code><a href="#topic+u.vectors">u.vectors</a></code>, 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>L &lt;- L.matrix( 4 )
A &lt;- lower.triangle( matrix( seq( 1, 16, 1 ), nrow=4, byrow=TRUE ) )
vecA &lt;- vec( A )
vechA &lt;- vech( A )
y &lt;- L %*% vecA
print( y )
print( vechA )
</code></pre>

<hr>
<h2 id='lower.triangle'> Lower triangle portion of a matrix </h2><span id='topic+lower.triangle'></span>

<h3>Description</h3>

<p>Returns the lower triangle including the diagonal of a square numeric matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lower.triangle(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lower.triangle_+3A_x">x</code></td>
<td>
<p> a matrix </p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix.
</p>


<h3>Author(s)</h3>

<p> Frederick Novomestky <a href="mailto:fnovomes@poly.edu">fnovomes@poly.edu</a> </p>


<h3>References</h3>

<p>Bellman, R. (1987). <em>Matrix Analysis</em>, Second edition, Classics in Applied Mathematics,
Society for Industrial and Applied Mathematics.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+is.square.matrix">is.square.matrix</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>B &lt;- matrix( seq( 1, 16, 1 ), nrow=4, byrow=TRUE )
lower.triangle( B )
</code></pre>

<hr>
<h2 id='lu.decomposition'> LU Decomposition of Square Matrix </h2><span id='topic+lu.decomposition'></span>

<h3>Description</h3>

<p>This function performs an LU decomposition of the given square matrix argument
the results are returned in a list of named components.  The Doolittle decomposition
method is used to obtain the lower and upper triangular matrices
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lu.decomposition(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lu.decomposition_+3A_x">x</code></td>
<td>
<p> a numeric square matrix </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Doolittle decomposition without row exchanges is performed generating
the lower and upper triangular matrices separately rather than in one matrix.
</p>


<h3>Value</h3>

<p>A list with two named components.
</p>
<table>
<tr><td><code>L</code></td>
<td>
<p>The numeric lower triangular matrix</p>
</td></tr>
<tr><td><code>U</code></td>
<td>
<p>The number upper triangular matrix</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p> Frederick Novomestky <a href="mailto:fnovomes@poly.edu">fnovomes@poly.edu</a> </p>


<h3>References</h3>

<p>Bellman, R. (1987). <em>Matrix Analysis</em>, Second edition, Classics in Applied Mathematics,
Society for Industrial and Applied Mathematics.
</p>
<p>Golub, G. H. and C. F. Van Loan (1996). <em>Matrix Computations</em>, Third Edition,
John Hopkins University Press
</p>
<p>Horn, R. A. and C. R. Johnson (1985). <em>Matrix Analysis</em>, Cambridge University Press.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>A &lt;- matrix( c ( 1, 2, 2, 1 ), nrow=2, byrow=TRUE)
luA &lt;- lu.decomposition( A )
L &lt;- luA$L
U &lt;- luA$U
print( L )
print( U )
print( L %*% U )
print( A )
B &lt;- matrix( c( 2, -1, -2, -4, 6, 3, -4, -2, 8 ), nrow=3, byrow=TRUE )
luB &lt;- lu.decomposition( B )
L &lt;- luB$L
U &lt;- luB$U
print( L )
print( U )
print( L %*% U )
print( B )
</code></pre>

<hr>
<h2 id='matrix.inverse'> Inverse of a square matrix </h2><span id='topic+matrix.inverse'></span>

<h3>Description</h3>

<p>This function returns the inverse of a square matrix computed using the R function solve.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>matrix.inverse(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="matrix.inverse_+3A_x">x</code></td>
<td>
<p> a square numeric matrix </p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix.
</p>


<h3>Author(s)</h3>

<p> Frederick Novomestky <a href="mailto:fnovomes@poly.edu">fnovomes@poly.edu</a> </p>


<h3>References</h3>

<p>Bellman, R. (1987). <em>Matrix Analysis</em>, Second edition, Classics in Applied Mathematics,
Society for Industrial and Applied Mathematics.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>A &lt;- matrix( c ( 1, 2, 2, 1 ), nrow=2, byrow=TRUE)
print( A )
invA &lt;- matrix.inverse( A )
print( invA )
print( A %*% invA )
print( invA %*% A )
</code></pre>

<hr>
<h2 id='matrix.power'> Matrix Raised to a Power </h2><span id='topic+matrix.power'></span>

<h3>Description</h3>

<p>This function computes the k-th power of order n square matrix x
If k is zero, the order n identity matrix is returned.  argument k
must be an integer.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>matrix.power(x, k)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="matrix.power_+3A_x">x</code></td>
<td>
<p> a numeric square matrix </p>
</td></tr>
<tr><td><code id="matrix.power_+3A_k">k</code></td>
<td>
<p> a numeric exponent </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The matrix power is computed by successive matrix multiplications.  If the
exponent is zero, the order n identity matrix is returned.  If the exponent
is negative, the inverse of the matrix is raised to the given power.
</p>


<h3>Value</h3>

<p>An order <code class="reqn">n</code> matrix.
</p>


<h3>Author(s)</h3>

<p> Frederick Novomestky <a href="mailto:fnovomes@poly.edu">fnovomes@poly.edu</a> </p>


<h3>References</h3>

<p>Bellman, R. (1987). <em>Matrix Analysis</em>, Second edition, Classics in Applied Mathematics,
Society for Industrial and Applied Mathematics.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>A &lt;- matrix( c ( 1, 2, 2, 1 ), nrow=2, byrow=TRUE)
matrix.power( A, -2 )
matrix.power( A, -1 )
matrix.power( A, 0 )
matrix.power( A, 1 )
matrix.power( A, 2 )
</code></pre>

<hr>
<h2 id='matrix.rank'> Rank of a square matrix </h2><span id='topic+matrix.rank'></span>

<h3>Description</h3>

<p>This function returns the rank of a square numeric matrix based on the selected method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>matrix.rank(x, method = c("qr", "chol"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="matrix.rank_+3A_x">x</code></td>
<td>
<p> a matrix </p>
</td></tr>
<tr><td><code id="matrix.rank_+3A_method">method</code></td>
<td>
<p> a character string that specifies the method to be used </p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the user specifies &quot;qr&quot; as the method, then the QR decomposition function is used to obtain the rank.
If the user specifies &quot;chol&quot; as the method, the rank is obtained from the attributes of the value returned.
</p>


<h3>Value</h3>

<p>An integer.
</p>


<h3>Note</h3>

<p>If the argument is not a square numeric matrix, then the function presents an error message and stops.
</p>


<h3>Author(s)</h3>

<p> Frederick Novomestky <a href="mailto:fnovomes@poly.edu">fnovomes@poly.edu</a> </p>


<h3>References</h3>

<p>Bellman, R. (1987). <em>Matrix Analysis</em>, Second edition, Classics in Applied Mathematics,
Society for Industrial and Applied Mathematics.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+is.square.matrix">is.square.matrix</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>A &lt;- diag( seq( 1, 4, 1 ) )
matrix.rank( A )
B &lt;- matrix( seq( 1, 16, 1 ), nrow=4, byrow=TRUE )
matrix.rank( B )
</code></pre>

<hr>
<h2 id='matrix.trace'> The trace of a matrix </h2><span id='topic+matrix.trace'></span>

<h3>Description</h3>

<p>This function returns the trace of a given square numeric matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>matrix.trace(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="matrix.trace_+3A_x">x</code></td>
<td>
<p> a matrix </p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric value which is the sum of the values on the diagonal.
</p>


<h3>Note</h3>

<p>If the argument x is not numeric, the function presents and error message and terminates.
If the argument x is not a square matrix, the function presents an error message and terminates.
</p>


<h3>Author(s)</h3>

<p> Frederick Novomestky <a href="mailto:fnovomes@poly.edu">fnovomes@poly.edu</a> </p>


<h3>References</h3>

<p>Bellman, R. (1987). <em>Matrix Analysis</em>, Second edition, Classics in Applied Mathematics,
Society for Industrial and Applied Mathematics.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>A &lt;- matrix( seq( 1, 16, 1 ), nrow=4, byrow=TRUE )
matrix.trace( A )
</code></pre>

<hr>
<h2 id='maximum.norm'> Maximum norm of  matrix </h2><span id='topic+maximum.norm'></span>

<h3>Description</h3>

<p>This function returns the max norm of a real matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>maximum.norm(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="maximum.norm_+3A_x">x</code></td>
<td>
<p> a numeric matrix or vector </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Let <code class="reqn">{\bf{x}}</code> be an <code class="reqn">m \times n</code> real matrix. The max norm returned
is <code class="reqn">\left\| {\bf{x}} \right\|_{\max }  = \mathop {\max }\limits_{i,j} \left| {x_{i,j} } \right|</code>. 
</p>


<h3>Value</h3>

<p>A numeric value.
</p>


<h3>Author(s)</h3>

<p> Frederick Novomestky <a href="mailto:fnovomes@poly.edu">fnovomes@poly.edu</a> </p>


<h3>References</h3>

<p>Bellman, R. (1987). <em>Matrix Analysis</em>, Second edition, Classics in Applied Mathematics,
Society for Industrial and Applied Mathematics.
</p>
<p>Golub, G. H. and C. F. Van Loan (1996).  <em>Matrix Computations</em>, Third Edition, The John
Hopkins University Press.
</p>
<p>Horn, R. A. and C. R. Johnson (1985). <em>Matrix Analysis</em>, Cambridge University Press.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+inf.norm">inf.norm</a></code>,
<code><a href="#topic+one.norm">one.norm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>A &lt;- matrix( c( 3, 5, 7, 2, 6, 4, 0, 2, 8 ), nrow=3, ncol=3, byrow=TRUE )
maximum.norm( A )
</code></pre>

<hr>
<h2 id='N.matrix'> Construct N Matrix </h2><span id='topic+N.matrix'></span>

<h3>Description</h3>

<p>This function returns the order n square matrix that is the sum of
an implicit commutation matrix and the order n identity matrix
quantity divided by two
</p>


<h3>Usage</h3>

<pre><code class='language-R'>N.matrix(n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="N.matrix_+3A_n">n</code></td>
<td>
<p> A positive integer matrix order </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Let <code class="reqn">{\bf{K}_n}</code> be the order <code class="reqn">n</code> implicit commutation matrix (i.e., <code class="reqn">{{\bf{K}}_{n,n}}</code> ).
and <code class="reqn">{{\bf{I}}_n}</code> the order <code class="reqn">n</code> identity matrix.  The formula for the matrix is <code class="reqn">{\bf{N}} = \frac{1}{2}\left( {{{\bf{K}}_n} + {{\bf{I}}_n}} \right)</code>.
</p>


<h3>Value</h3>

<p>An order <code class="reqn">n</code> matrix.
</p>


<h3>Note</h3>

<p>If the argument is not an integer, the function displays an error message and stops.
If the argument is less than two, the function displays an error message and stops.
</p>


<h3>Author(s)</h3>

<p> Frederick Novomestky <a href="mailto:fnovomes@poly.edu">fnovomes@poly.edu</a> </p>


<h3>References</h3>

<p>Magnus, J. R. and H. Neudecker (1980). The elimination matrix, some lemmas and applications,
<em>SIAM Journal on Algebraic Discrete Methods</em>, 1(4), December 1980, 422-449.
</p>
<p>Magnus, J. R. and H. Neudecker (1999) <em>Matrix Differential Calculus with Applications in Statistics and Econometrics</em>,
Second Edition, John Wiley.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+K.matrix">K.matrix</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>N &lt;- N.matrix( 3 )
print( N )
</code></pre>

<hr>
<h2 id='one.norm'> Compute the one norm of a matrix </h2><span id='topic+one.norm'></span>

<h3>Description</h3>

<p>This function returns the <code class="reqn">\left\| {\bf{x}} \right\|_1 </code> norm of the matrix <code class="reqn">{\mathbf{x}}</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>one.norm(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="one.norm_+3A_x">x</code></td>
<td>
<p>  a numeric vector or matrix </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Let <code class="reqn">{\bf{x}}</code> be an <code class="reqn">m \times n</code> matrix. 
The formula used to compute the norm is <code class="reqn">\left\| {\bf{x}} \right\|_1  = \mathop {\max }\limits_{1 \le j \le n} \sum\limits_{i = 1}^m {\left| {x_{i,j} } \right|} </code>.
This is merely the maximum absolute column sum of the <code class="reqn">m \times n</code> maxtris.
</p>


<h3>Value</h3>

<p>A numeric value.
</p>


<h3>Author(s)</h3>

<p> Frederick Novomestky <a href="mailto:fnovomes@poly.edu">fnovomes@poly.edu</a> </p>


<h3>References</h3>

<p>Bellman, R. (1987). <em>Matrix Analysis</em>, Second edition, Classics in Applied Mathematics,
Society for Industrial and Applied Mathematics.
</p>
<p>Golub, G. H. and C. F. Van Loan (1996).  <em>Matrix Computations</em>, Third Edition, The John
Hopkins University Press.
</p>
<p>Horn, R. A. and C. R. Johnson (1985). <em>Matrix Analysis</em>, Cambridge University Press.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+inf.norm">inf.norm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>A &lt;- matrix( c( 3, 5, 7, 2, 6, 4, 0, 2, 8 ), nrow=3, ncol=3, byrow=TRUE )
one.norm( A )
</code></pre>

<hr>
<h2 id='pascal.matrix'> Pascal matrix </h2><span id='topic+pascal.matrix'></span>

<h3>Description</h3>

<p>This function returns an n by n Pascal matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pascal.matrix(n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pascal.matrix_+3A_n">n</code></td>
<td>
<p> Order of the matrix </p>
</td></tr>
</table>


<h3>Details</h3>

<p>In mathematics, particularly matrix theory and combinatorics, the Pascal matrix is a lower triangular matrix
with binomial coefficients in the rows.  It is easily obtained by performing an LU decomposition on 
the symmetric Pascal matrix of the same order and returning the lower triangular matrix.
</p>


<h3>Value</h3>

<p>An order <code class="reqn">n</code> matrix.
</p>


<h3>Note</h3>

<p>If the argument n is not a positive integer, the function presents an error message and stops.
</p>


<h3>Author(s)</h3>

<p> Frederick Novomestky <a href="mailto:fnovomes@poly.edu">fnovomes@poly.edu</a> </p>


<h3>References</h3>

<p>Aceto, L. and D. Trigiante, (2001). Matrices of Pascal and Other Greats, <em>American
Mathematical Monthly</em>, March 2001, 232-245.
</p>
<p>Call, G. S. and D. J. Velleman, (1993). Pascal's matrices, <em>American Mathematical Monthly</em>,
April 1993, 100, 372-376.
</p>
<p>Edelman, A. and G. Strang, (2004). Pascal Matrices, <em>American Mathematical Monthly</em>,
111(3), 361-385.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lu.decomposition">lu.decomposition</a></code>,
<code><a href="#topic+symmetric.pascal.matrix">symmetric.pascal.matrix</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>P &lt;- pascal.matrix( 4 )
print( P )
</code></pre>

<hr>
<h2 id='set.submatrix'> Store matrix inside another matrix </h2><span id='topic+set.submatrix'></span>

<h3>Description</h3>

<p>This function returns a matrix which is a copy of matrix x into which the contents of matrix y
have been inserted at the given row and column.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set.submatrix(x, y, row, col)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="set.submatrix_+3A_x">x</code></td>
<td>
<p> a matrix </p>
</td></tr>
<tr><td><code id="set.submatrix_+3A_y">y</code></td>
<td>
<p> a matrix </p>
</td></tr>
<tr><td><code id="set.submatrix_+3A_row">row</code></td>
<td>
<p> an integer row number </p>
</td></tr>
<tr><td><code id="set.submatrix_+3A_col">col</code></td>
<td>
<p> an integer column number </p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix.
</p>


<h3>Note</h3>

<p>If the argument x is not a numeric matrix, then the function presents an error message and stops.
If the argument y is not a numeric matrix, then the function presents an error message and stops.
If the argument row is not a positive integer, then the function presents an error message and stops.
If the argument col is not a positive integer, then the function presents an error message and stops.
If the target row range does not overlap with the row range of argument x, then the function presents an error message and stops.
If the target col range does not overlap with the col range of argument x, then the function presents an error message and stops.
</p>


<h3>Author(s)</h3>

<p> Frederick Novomestky <a href="mailto:fnovomes@poly.edu">fnovomes@poly.edu</a> </p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- matrix( seq( 1, 16, 1 ), nrow=4, byrow=TRUE )
y &lt;- matrix( seq( 1, 4, 1 ), nrow=2, byrow=TRUE )
z &lt;- set.submatrix( x, y, 3, 3 )
</code></pre>

<hr>
<h2 id='shift.down'> Shift matrix m rows down </h2><span id='topic+shift.down'></span>

<h3>Description</h3>

<p>This function returns a matrix that has had its rows shifted downwards filling the above rows
with the given fill value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>shift.down(A, rows = 1, fill = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="shift.down_+3A_a">A</code></td>
<td>
<p> a matrix </p>
</td></tr>
<tr><td><code id="shift.down_+3A_rows">rows</code></td>
<td>
<p> the number of rows to be shifted </p>
</td></tr>
<tr><td><code id="shift.down_+3A_fill">fill</code></td>
<td>
<p> the fill value which as a default is zero </p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix.
</p>


<h3>Note</h3>

<p>If the argument A is not a numeric matrix, then the function presents an error message and stops.
If the argument rows is not a positive integer, then the function presents an error message and stops.
</p>


<h3>Author(s)</h3>

<p> Frederick Novomestky <a href="mailto:fnovomes@poly.edu">fnovomes@poly.edu</a> </p>


<h3>Examples</h3>

<pre><code class='language-R'>A &lt;- matrix( seq( 1, 16, 1 ), nrow=4, byrow=TRUE )
shift.down( A, 1 )
shift.down( A, 3 )
</code></pre>

<hr>
<h2 id='shift.left'> Shift a matrix n columns to the left </h2><span id='topic+shift.left'></span>

<h3>Description</h3>

<p>This function returns a matrix that has been shifted n columns to the left
filling the subsqeuent columns with the given fill value
</p>


<h3>Usage</h3>

<pre><code class='language-R'>shift.left(A, cols = 1, fill = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="shift.left_+3A_a">A</code></td>
<td>
<p> a matrix </p>
</td></tr>
<tr><td><code id="shift.left_+3A_cols">cols</code></td>
<td>
<p> integer number of columns to be shifted to the left </p>
</td></tr>
<tr><td><code id="shift.left_+3A_fill">fill</code></td>
<td>
<p> the fill value which as as a default zero </p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix.
</p>


<h3>Note</h3>

<p>If the argument A is not a numeric matrix, then the function presents an error message and stops.
If the argument cols is not a positive integer, then the function presents an error message and stops.
</p>


<h3>Author(s)</h3>

<p> Frederick Novomestky <a href="mailto:fnovomes@poly.edu">fnovomes@poly.edu</a> </p>


<h3>Examples</h3>

<pre><code class='language-R'>A &lt;- matrix( seq( 1, 12, 1 ), nrow=3, byrow=TRUE )
shift.left( A, 1 )
shift.left( A, 2 )
</code></pre>

<hr>
<h2 id='shift.right'>Shift matrix n columns to the right </h2><span id='topic+shift.right'></span>

<h3>Description</h3>

<p>This function returns a matrix that has been shifted to the right n columns
filling the previous columns with the given fill value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>shift.right(A, cols = 1, fill = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="shift.right_+3A_a">A</code></td>
<td>
<p> a matrix </p>
</td></tr>
<tr><td><code id="shift.right_+3A_cols">cols</code></td>
<td>
<p> integer number of columns to be shifted to the right </p>
</td></tr>
<tr><td><code id="shift.right_+3A_fill">fill</code></td>
<td>
<p> the fill which as default value zero </p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix.
</p>


<h3>Note</h3>

<p>If the argument A is not a numeric matrix, then the function presents an error message and stops.
If the argument rows is not a positive integer, then the function presents an error message and stops.
</p>


<h3>Author(s)</h3>

<p> Frederick Novomestky <a href="mailto:fnovomes@poly.edu">fnovomes@poly.edu</a> </p>


<h3>Examples</h3>

<pre><code class='language-R'>A &lt;- matrix( seq( 1, 16, 1 ), nrow=4, byrow=TRUE )
shift.right( A, 1 )
shift.right( A, 2 )
</code></pre>

<hr>
<h2 id='shift.up'> Shift matrix m rows up </h2><span id='topic+shift.up'></span>

<h3>Description</h3>

<p>This function returns a matrix where the argument as been shifted up the given number of rows filling
the bottom rows with the given fill value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>shift.up(A, rows = 1, fill = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="shift.up_+3A_a">A</code></td>
<td>
<p> a matrix </p>
</td></tr>
<tr><td><code id="shift.up_+3A_rows">rows</code></td>
<td>
<p> integer number of rows</p>
</td></tr>
<tr><td><code id="shift.up_+3A_fill">fill</code></td>
<td>
<p> fill value which as the default value of zero </p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix.
</p>


<h3>Note</h3>

<p>If the argument A is not a numeric matrix, then the function presents an error message and stops.
If the argument rows is not a positive integer, then the function presents an error message and stops.
</p>


<h3>Author(s)</h3>

<p> Frederick Novomestky <a href="mailto:fnovomes@poly.edu">fnovomes@poly.edu</a> </p>


<h3>Examples</h3>

<pre><code class='language-R'>A &lt;- matrix( seq( 1, 16, 1 ), nrow=4, byrow=TRUE )
shift.up( A, 1 )
shift.up( A, 3 )
</code></pre>

<hr>
<h2 id='spectral.norm'> Spectral norm of  matrix </h2><span id='topic+spectral.norm'></span>

<h3>Description</h3>

<p>This function returns the spectral norm of a real matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spectral.norm(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spectral.norm_+3A_x">x</code></td>
<td>
<p> a numeric matrix or vector </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Let <code class="reqn">{\bf{x}}</code> be an <code class="reqn">m \times n</code> real matrix.  The
function computes the order <code class="reqn">n</code> square matrixmatrix <code class="reqn">{\bf{A}} = {\bf{x'}}\;{\bf{x}}</code>.
The R function <code>eigen</code> is applied to this matrix to obtain the vector
of eigenvalues <code class="reqn">{\bf{\lambda }} = \left\lbrack {\begin{array}{cccc}
   {\lambda _1 } &amp; {\lambda _2 } &amp;  \cdots  &amp; {\lambda _n }  \\
\end{array}} \right\rbrack</code>.  By construction the eigenvalues are in descending
order of value so that the largest eigenvalue is <code class="reqn">\lambda _1</code>.  Then
the spectral norm is <code class="reqn">\left\| {\bf{x}} \right\|_2  = \sqrt {\lambda _1 }</code>.
If <code class="reqn">{\bf{x}}</code> is a vector, then  <code class="reqn">{\bf{L}}_2  = \sqrt {\bf{A}}</code> is returned.
</p>


<h3>Value</h3>

<p>A numeric value.
</p>


<h3>Note</h3>

<p>If the argument x is not numeric, an error message is displayed and the function terminates.
If the argument is neither a matrix nor a vector, an error message is displayed and the 
function terminates.
If the product matrix <code class="reqn">{\bf{x'}}\;{\bf{x}}</code> is negative definite, an error message
displayed and the function terminates.
</p>


<h3>Author(s)</h3>

<p> Frederick Novomestky <a href="mailto:fnovomes@poly.edu">fnovomes@poly.edu</a> </p>


<h3>References</h3>

<p>Bellman, R. (1987). <em>Matrix Analysis</em>, Second edition, Classics in Applied Mathematics,
Society for Industrial and Applied Mathematics.
</p>
<p>Golub, G. H. and C. F. Van Loan (1996).  <em>Matrix Computations</em>, Third Edition, The John
Hopkins University Press.
</p>
<p>Horn, R. A. and C. R. Johnson (1985). <em>Matrix Analysis</em>, Cambridge University Press.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- matrix( c( 2, 4, 2, 1, 3, 1, 5, 2, 1, 2, 3, 3 ), nrow=3, ncol=4, byrow=TRUE )
spectral.norm( x )
</code></pre>

<hr>
<h2 id='stirling.matrix'> Stirling Matrix </h2><span id='topic+stirling.matrix'></span>

<h3>Description</h3>

<p>This function constructs and returns a Stirling matrix which is
a lower triangular matrix containing the Stirling numbers of
the second kind.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stirling.matrix(n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stirling.matrix_+3A_n">n</code></td>
<td>
<p>  A positive integer value </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Stirling numbers of the second kind, <code class="reqn">S_i^j</code>, are used
in combinatorics to compute the number of ways a set of <code class="reqn">i</code> objects
can be partitioned into <code class="reqn">j</code> non-empty subsets <code class="reqn">j \le i</code>.  The numbers are also
denoted by 
<code class="reqn">\left\{ {\begin{array}{c}i\\j\end{array}} \right\}</code>.  Stirling numbers of
the second kind can be computed recursively with the equation
<code class="reqn">S_j^{i + 1} = S_{j - 1}^i + j\;S_j^i,\quad 1 \le i \le n - 1,\;1 \le j \le i</code>.
The initial conditions for the recursion are
<code class="reqn">S_i^i = 1,\quad 0 \le i \le n</code> and
<code class="reqn">S_j^0 = S_0^j = 0,\quad 0 \le j \le n</code>.  The resultant numbers are organized
in an order <code class="reqn">n + 1</code> matrix
<code class="reqn">\left\lbrack {\begin{array}{ccccc}
{S_0^0}&amp;0&amp;0&amp; \cdots &amp;0\\
0&amp;{S_1^1}&amp;0&amp; \cdots &amp;0\\
0&amp;{S_1^2}&amp;{S_2^2}&amp; \cdots &amp;0\\
 \cdots &amp; \cdots &amp; \cdots &amp; \cdots &amp; \cdots \\
0&amp;{S_1^n}&amp;{S_2^n}&amp; \cdots &amp;{S_n^n}
\end{array}} \right\rbrack</code>.
</p>


<h3>Value</h3>

<p>An order <code class="reqn">n + 1</code> lower triangular matrix.
</p>


<h3>Note</h3>

<p>If the argument n is not a positive integer, the function presents an error message and stops.
</p>


<h3>Author(s)</h3>

<p> Frederick Novomestky <a href="mailto:fnovomes@poly.edu">fnovomes@poly.edu</a> </p>


<h3>References</h3>

<p>Aceto, L. and D. Trigiante (2001). Matrices of Pascal and Other Greats,
<em>American Mathematical Monthly</em>, March 2001, 108(3), 232-245.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>S &lt;- stirling.matrix( 10 )
print( S )
</code></pre>

<hr>
<h2 id='svd.inverse'> SVD Inverse of a square matrix </h2><span id='topic+svd.inverse'></span>

<h3>Description</h3>

<p>This function returns the inverse of a matrix using singular value
decomposition.  If the matrix is a square matrix, this should be equivalent
to using the <code>solve</code> function.  If the matrix is not a square matrix,
then the result is the Moore-Penrose pseudo inverse.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>svd.inverse(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="svd.inverse_+3A_x">x</code></td>
<td>
<p> a numeric matrix </p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix.
</p>


<h3>Author(s)</h3>

<p> Frederick Novomestky <a href="mailto:fnovomes@poly.edu">fnovomes@poly.edu</a> </p>


<h3>References</h3>

<p>Bellman, R. (1987). <em>Matrix Analysis</em>, Second edition, Classics in Applied Mathematics,
Society for Industrial and Applied Mathematics.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>A &lt;- matrix( c ( 1, 2, 2, 1 ), nrow=2, byrow=TRUE)
invA &lt;- svd.inverse( A )
print( A )
print( invA )
print( A %*% invA )
B &lt;- matrix( c( -1, 2, 2 ), nrow=1, byrow=TRUE )
invB &lt;- svd.inverse( B )
print( B )
print( invB )
print( B %*% invB )
</code></pre>

<hr>
<h2 id='symmetric.pascal.matrix'> Symmetric Pascal matrix </h2><span id='topic+symmetric.pascal.matrix'></span>

<h3>Description</h3>

<p>This function returns an n by n symmetric Pascal matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>symmetric.pascal.matrix(n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="symmetric.pascal.matrix_+3A_n">n</code></td>
<td>
<p> Order of the matrix </p>
</td></tr>
</table>


<h3>Details</h3>

<p>In mathematics, particularly matrix theory and combinatorics, the symmetric Pascal matrix is a square matrix
from which you can derive binomial coefficients.  The matrix is an order <code class="reqn">n</code> symmetric
matrix with typical element given by <code class="reqn">{S_{i,j}} = {{n!} \mathord{\left/
 {\vphantom {{n!} {\left[ {r!\;\left( {n - r} \right)!} \right]}}} \right.
 } {\left[ {r!\;\left( {n - r} \right)!} \right]}}</code> where
<code class="reqn">n = i + j - 2</code> and <code class="reqn">r = i - 1</code>.  The binomial coefficients are elegantly recovered from the
symmetric Pascal matrix by performing an <code class="reqn">LU</code> decomposition as <code class="reqn">{\bf{S}} = {\bf{L}}\;{\bf{U}}</code>.
</p>


<h3>Value</h3>

<p>An order <code class="reqn">n</code> matrix.
</p>


<h3>Note</h3>

<p>If the argument n is not a positive integer, the function presents an error message and stops.
</p>


<h3>Author(s)</h3>

<p> Frederick Novomestky <a href="mailto:fnovomes@poly.edu">fnovomes@poly.edu</a> </p>


<h3>References</h3>

<p>Call, G. S. and D. J. Velleman, (1993). Pascal's matrices, <em>American Mathematical Monthly</em>,
April 1993, 100, 372-376.
</p>
<p>Edelman, A. and G. Strang, (2004). Pascal Matrices, <em>American Mathematical Monthly</em>,
111(3), 361-385.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>S &lt;- symmetric.pascal.matrix( 4 )
print( S )
</code></pre>

<hr>
<h2 id='T.matrices'> List of T Matrices </h2><span id='topic+T.matrices'></span>

<h3>Description</h3>

<p>This function constructs a list of lists.  The number of components in
the high level list is n.  Each of the n components is also a list.
Each sub-list has n components each of which is an order n square matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>T.matrices(n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="T.matrices_+3A_n">n</code></td>
<td>
<p> a positive integer value for the order of the matrices </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Let <code class="reqn">{{\bf{E}}_{i,j}}\;i = 1, \ldots ,n\;;\;j = 1, \ldots ,n</code> 
be a representative order <code class="reqn">n</code> matrix created with function <code>E.matrices</code>.
The order <code class="reqn">n</code> matrix <code class="reqn">{{\bf{T}}_{i,j}}</code> is defined as follows
<code class="reqn">{{\bf{T}}_{i,j}} = \left\{ {\begin{array}{cc}
{{{\bf{E}}_{i,j}}}&amp;{i = j}\\
{{{\bf{E}}_{i,j}} + {{\bf{E}}_{j,i}}}&amp;{i \ne j}
\end{array}} \right.</code>
</p>


<h3>Value</h3>

<p>A list of <code class="reqn">n</code> components.
</p>
<table>
<tr><td><code>1</code></td>
<td>
<p>A list of <code class="reqn">n</code> components</p>
</td></tr>
<tr><td><code>2</code></td>
<td>
<p>A list of <code class="reqn">n</code> components</p>
</td></tr>
</table>
<p>...
</p>
<table>
<tr><td><code>n</code></td>
<td>
<p>A list of <code class="reqn">n</code> components</p>
</td></tr>
</table>
<p>Each component <code class="reqn">j</code> of sublist <code class="reqn">i</code> is a matrix <code class="reqn">{\bf{T}}_{i,j}</code>
</p>


<h3>Note</h3>

<p>The argument n must be an integer value greater than or equal to 2.
</p>


<h3>Author(s)</h3>

<p> Frederick Novomestky <a href="mailto:fnovomes@poly.edu">fnovomes@poly.edu</a> </p>


<h3>References</h3>

<p>Magnus, J. R. and H. Neudecker (1980). The elimination matrix, some lemmas and applications,
<em>SIAM Journal on Algebraic Discrete Methods</em>, 1(4), December 1980, 422-449.
</p>
<p>Magnus, J. R. and H. Neudecker (1999) <em>Matrix Differential Calculus with Applications in Statistics and Econometrics</em>,
Second Edition, John Wiley.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+E.matrices">E.matrices</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>T &lt;- T.matrices( 3 )
</code></pre>

<hr>
<h2 id='toeplitz.matrix'> Toeplitz Matrix </h2><span id='topic+toeplitz.matrix'></span>

<h3>Description</h3>

<p>This function constructs an order n Toeplitz matrix from the values in
the order 2 * n - 1 vector x.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>toeplitz.matrix(n, x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="toeplitz.matrix_+3A_n">n</code></td>
<td>
<p> a positive integer value for order of matrix greater than 1 </p>
</td></tr>
<tr><td><code id="toeplitz.matrix_+3A_x">x</code></td>
<td>
<p> a vector of values used to construct the matrix </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The element <code>T[i,j]</code> in the Toeplitz matrix is <code>x[i-j+n]</code>.
</p>


<h3>Value</h3>

<p>An order n matrix.
</p>


<h3>Note</h3>

<p>If the argument n is not a positive integer, the function presents an error message and stops.
If the length of x is not equal to 2 * n - 1, the function presents an error message and stops.
</p>


<h3>Author(s)</h3>

<p> Frederick Novomestky <a href="mailto:fnovomes@poly.edu">fnovomes@poly.edu</a> </p>


<h3>References</h3>

<p>Monahan, J. F. (2011). <em>Numerical Methods of Statistics</em>, Cambridge
University Press.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>T &lt;- toeplitz.matrix( 4, seq( 1, 7 ) )
print( T )
</code></pre>

<hr>
<h2 id='u.vectors'> u vectors of an identity matrix </h2><span id='topic+u.vectors'></span>

<h3>Description</h3>

<p>This function constructs an order n * ( n + 1 ) / 2 identity matrix
and an order matrix u that that maps the ordered pair of indices
(i,j) i=j, ..., n; j=1, ..., n to a column in this identity matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>u.vectors(n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="u.vectors_+3A_n">n</code></td>
<td>
<p> a positive integer value for the order of underlying matrices </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function firsts constructs an identity matrix of order <code class="reqn">\frac{1}{2}n\left( {n + 1} \right)</code>.
<code class="reqn">{{{\bf{u}}_{i,j}}}</code> is the column vector in the order <code class="reqn">\frac{1}{2}n\left( {n + 1} \right)</code> identity
matrix for column <code class="reqn">k = \left( {j - 1} \right)n + i - \frac{1}{2}j\left( {j - 1} \right)</code>.
</p>


<h3>Value</h3>

<p>A list with two named components
</p>
<table>
<tr><td><code>k</code></td>
<td>
<p>order <code class="reqn">n</code> square matrix that maps each ordered pair (i,j) to a column in the identity matrix</p>
</td></tr>
<tr><td><code>I</code></td>
<td>
<p>order <code class="reqn">\frac{1}{2}n\left( {n + 1} \right)</code> identity matrix</p>
</td></tr>
</table>


<h3>Note</h3>

<p>If the argument is not an integer, the function displays an error message and stops.
If the argument is less than two, the function displays an error message and stops.
</p>


<h3>Author(s)</h3>

<p> Frederick Novomestky <a href="mailto:fnovomes@poly.edu">fnovomes@poly.edu</a> </p>


<h3>References</h3>

<p>Magnus, J. R. and H. Neudecker (1980). The elimination matrix, some lemmas and applications,
<em>SIAM Journal on Algebraic Discrete Methods</em>, 1(4), December 1980, 422-449.
</p>
<p>Magnus, J. R. and H. Neudecker (1999) <em>Matrix Differential Calculus with Applications in Statistics and Econometrics</em>,
Second Edition, John Wiley.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>u &lt;- u.vectors( 3 )
</code></pre>

<hr>
<h2 id='upper.triangle'> Upper triangle portion of a matrix </h2><span id='topic+upper.triangle'></span>

<h3>Description</h3>

<p>Returns the lower triangle including the diagonal of a square numeric matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>upper.triangle(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="upper.triangle_+3A_x">x</code></td>
<td>
<p> a matrix </p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix.
</p>


<h3>Author(s)</h3>

<p> Frederick Novomestky <a href="mailto:fnovomes@poly.edu">fnovomes@poly.edu</a> </p>


<h3>References</h3>

<p>Bellman, R. (1987). <em>Matrix Analysis</em>, Second edition, Classics in Applied Mathematics,
Society for Industrial and Applied Mathematics.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+is.square.matrix">is.square.matrix</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>A &lt;- matrix( seq( 1, 9, 1 ), nrow=3, byrow=TRUE )
upper.triangle( A )
</code></pre>

<hr>
<h2 id='vandermonde.matrix'> Vandermonde matrix </h2><span id='topic+vandermonde.matrix'></span>

<h3>Description</h3>

<p>This function returns an m by n matrix of the powers of the alpha vector
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vandermonde.matrix(alpha, n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vandermonde.matrix_+3A_alpha">alpha</code></td>
<td>
<p> A numerical vector of values </p>
</td></tr>
<tr><td><code id="vandermonde.matrix_+3A_n">n</code></td>
<td>
<p> The column dimension of the Vandermonde matrix </p>
</td></tr>
</table>


<h3>Details</h3>

<p>In linear algebra, a Vandermonde matrix is an <code class="reqn">m \times n</code> matrix with terms
of a geometric progression of an <code class="reqn">m \times 1</code> parameter vector <code class="reqn">{\bf{\alpha }} = {\left\lbrack {\begin{array}{cccc}
{{\alpha _1}}&amp;{{\alpha _2}}&amp; \cdots &amp;{{\alpha _m}}
\end{array}} \right\rbrack^\prime }</code>
</p>
<p>such that <code class="reqn">V\left( {\bf{\alpha }} \right) = \left\lbrack {\begin{array}{ccccc}
1&amp;{{\alpha _1}}&amp;{\alpha _1^2}&amp; \cdots &amp;{\alpha _1^{n - 1}}\\
1&amp;{{\alpha _2}}&amp;{\alpha _2^2}&amp; \cdots &amp;{\alpha _2^{n - 1}}\\
1&amp;{{\alpha _3}}&amp;{\alpha _3^2}&amp; \cdots &amp;{\alpha _3^{n - 1}}\\
 \cdots &amp; \cdots &amp; \cdots &amp; \cdots &amp; \cdots \\
1&amp;{{\alpha _m}}&amp;{\alpha _m^2}&amp; \cdots &amp;{\alpha _m^{n - 1}}
\end{array}} \right\rbrack</code>.
</p>


<h3>Value</h3>

<p>A matrix.
</p>


<h3>Author(s)</h3>

<p> Frederick Novomestky <a href="mailto:fnovomes@poly.edu">fnovomes@poly.edu</a> </p>


<h3>References</h3>

<p>Horn, R. A. and C. R. Johnson (1991). <em>Topics in matrix analysis</em>, Cambridge
University Press.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>alpha &lt;- c( .1, .2, .3, .4 )
V &lt;- vandermonde.matrix( alpha, 4 )
print( V )
</code></pre>

<hr>
<h2 id='vec'> Vectorize a matrix </h2><span id='topic+vec'></span>

<h3>Description</h3>

<p>This function returns a column vector that is a stack of the columns of x, an m by n matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vec(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vec_+3A_x">x</code></td>
<td>
<p> a matrix </p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with <code class="reqn">m\;n</code> rows and one column.
</p>


<h3>Author(s)</h3>

<p> Frederick Novomestky <a href="mailto:fnovomes@poly.edu">fnovomes@poly.edu</a> </p>


<h3>References</h3>

<p>Magnus, J. R. and H. Neudecker (1999) <em>Matrix Differential Calculus with Applications in Statistics and Econometrics</em>,
Second Edition, John Wiley.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- matrix( seq( 1, 16, 1 ), nrow=4, byrow=TRUE )
print( x )
vecx &lt;- vec( x )
print( vecx )
</code></pre>

<hr>
<h2 id='vech'> Vectorize a matrix </h2><span id='topic+vech'></span>

<h3>Description</h3>

<p>This function returns a stack of the lower triangular matrix of a square matrix as a matrix with 1 column
and n * ( n + 1 ) / 2 rows
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vech(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vech_+3A_x">x</code></td>
<td>
<p> a matrix </p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with <code class="reqn">\frac{1}{2}n\left( {n + 1} \right)</code> rows and one column.
</p>


<h3>Author(s)</h3>

<p> Frederick Novomestky <a href="mailto:fnovomes@poly.edu">fnovomes@poly.edu</a> </p>


<h3>References</h3>

<p>Magnus, J. R. and H. Neudecker (1999) <em>Matrix Differential Calculus with Applications in Statistics and Econometrics</em>,
Second Edition, John Wiley.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+is.square.matrix">is.square.matrix</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- matrix( seq( 1, 16, 1 ), nrow=4, byrow=TRUE )
print( x )
y &lt;- vech( x )
print( y )
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
