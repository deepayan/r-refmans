<!DOCTYPE html><html><head><title>Help for package santaR</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {santaR}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#acuteInflammation'><p>Measurement of 22 inflammatory mediators across time</p></a></li>
<li><a href='#AIC_smooth_spline'><p>Calculate the Akaike Information Criterion for a smooth.spline</p></a></li>
<li><a href='#AICc_smooth_spline'><p>Calculate the Akaike Information Criterion Corrected for small observation numbers for a smooth.spline</p></a></li>
<li><a href='#BIC_smooth_spline'><p>Calculate the Bayesian Information Criterion for a smooth.spline</p></a></li>
<li><a href='#get_eigen_DF'><p>Compute the optimal df and weighted-df using 5 spline fitting metric</p></a></li>
<li><a href='#get_eigen_DFoverlay_list'><p>Plot for each eigenSpline the automatically fitted spline, splines for all df and a spline at a chosen df</p></a></li>
<li><a href='#get_eigen_spline'><p>Compute eigenSplines across a dataset</p></a></li>
<li><a href='#get_eigen_spline_matrix'><p>Generate a Ind x Time + Var data.frame concatenating all variables from input variable</p></a></li>
<li><a href='#get_grouping'><p>Generate a matrix of group membership for all individuals</p></a></li>
<li><a href='#get_ind_time_matrix'><p>Generate a Ind x Time DataFrame from input data</p></a></li>
<li><a href='#get_param_evolution'><p>Compute the value of different fitting metrics over all possible df for each eigenSpline</p></a></li>
<li><a href='#loglik_smooth_spline'><p>Calculate the penalised loglikelihood of a smooth.spline</p></a></li>
<li><a href='#plot_nbTP_histogram'><p>Plot an histogram of the number of time-trajectories with a given number of time-points</p></a></li>
<li><a href='#plot_param_evolution'><p>Plot the evolution of different fitting parameters across all possible df for each eigenSpline</p></a></li>
<li><a href='#santaR'><p>santaR: A package for Short AsyNchronous Time-series Analysis in R</p></a></li>
<li><a href='#santaR_auto_fit'><p>Automate all steps of santaR fitting, Confidence bands estimation and p-values calculation for one or multiple variables</p></a></li>
<li><a href='#santaR_auto_summary'><p>Summarise, report and save the results of a santaR analysis</p></a></li>
<li><a href='#santaR_CBand'><p>Compute Group Mean Curve Confidence Bands</p></a></li>
<li><a href='#santaR_fit'><p>Generate a SANTAObj for a variable</p></a></li>
<li><a href='#santaR_plot'><p>Plot a SANTAObj</p></a></li>
<li><a href='#santaR_pvalue_dist'><p>Evaluate difference in group trajectories based on the comparison of distance between group mean curves</p></a></li>
<li><a href='#santaR_pvalue_dist_within'><p>Evaluate difference between a group mean curve and a constant model</p></a></li>
<li><a href='#santaR_pvalue_fit'><p>Evaluate difference in group trajectories based on the comparison of model fit (F-test) between one and two groups</p></a></li>
<li><a href='#santaR_pvalue_fit_within'><p>Evaluate difference between a group mean curve and a constant model using the comparison of model fit (F-test)</p></a></li>
<li><a href='#santaR_start_GUI'><p>santaR Graphical User Interface</p></a></li>
<li><a href='#scaling_mean'><p>Mean scaling of each column</p></a></li>
<li><a href='#scaling_UV'><p>Unit-Variance scaling of each column</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Short Asynchronous Time-Series Analysis</td>
</tr>
<tr>
<td>Version:</td>
<td>1.2.4</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-02-26</td>
</tr>
<tr>
<td>Description:</td>
<td>A graphical and automated pipeline for the analysis 
		of short time-series in R ('santaR'). This approach is designed to accommodate asynchronous 
		time sampling (i.e. different time points for different individuals), 
		inter-individual variability, noisy measurements and large numbers of variables. 
		Based on a smoothing splines functional model, 'santaR' is able to detect variables
		highlighting significantly different temporal trajectories between study groups.
		Designed initially for metabolic phenotyping, 'santaR' is also suited for other Systems Biology 
		disciplines. Command line and graphical analysis (via a 'shiny' application) enable fast and
		parallel automated analysis and reporting, intuitive visualisation and comprehensive plotting
		options for non-specialist users.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.2)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/adwolfer/santaR/issues/new">https://github.com/adwolfer/santaR/issues/new</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/adwolfer/santaR">https://github.com/adwolfer/santaR</a>,
<a href="https://adwolfer.github.io/santaR/">https://adwolfer.github.io/santaR/</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Imports:</td>
<td>plyr (&ge; 1.8.9), foreach (&ge; 1.5.2), doParallel (&ge; 1.0.17),
pcaMethods (&ge; 1.92.0), ggplot2 (&ge; 3.5.0), gridExtra (&ge; 2.3),
reshape2 (&ge; 1.4.3), iterators (&ge; 1.0.9), shiny (&ge; 1.8.0),
bslib, DT (&ge; 0.9)</td>
</tr>
<tr>
<td>biocViews:</td>
<td>pcaMethods (&gt;= 1.92.0)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, pander, R.rsp, testthat</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr, R.rsp</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-03-06 23:42:13 UTC; Arnaud</td>
</tr>
<tr>
<td>Author:</td>
<td>Arnaud Wolfer <a href="https://orcid.org/0000-0001-5856-3218"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Timothy Ebbels [ctb],
  Joe Cheng [ctb] (Shiny javascript custom-input control)</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Arnaud Wolfer &lt;adwolfer@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-03-07 00:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='acuteInflammation'>Measurement of 22 inflammatory mediators across time</h2><span id='topic+acuteInflammation'></span>

<h3>Description</h3>

<p>A dataset containing the concentrations of 22 mediators of inflammation over an episode of acute inflammation. The mediators have been measured at 7 time-points on 8 subjects, concentration values have been unit-variance scaled for each variable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>acuteInflammation
</code></pre>


<h3>Format</h3>

<p>List of 2 data frames of 56 rows each, containing the 22 measured variables (data) and the corresponding sampling metadata (meta):
</p>

<dl>
<dt>data: var</dt><dd><p>mediator concentration, unit-variance scaled</p>
</dd>
<dt>meta: time</dt><dd><p>time of the measurement, in hour</p>
</dd>
<dt>meta: ind</dt><dd><p>subject ID for the measurement</p>
</dd>
<dt>meta: group</dt><dd><p>group membership of the subject/measurement</p>
</dd>
</dl>


<hr>
<h2 id='AIC_smooth_spline'>Calculate the Akaike Information Criterion for a smooth.spline</h2><span id='topic+AIC_smooth_spline'></span>

<h3>Description</h3>

<p>Calculate the Akaike Information Criterion (<em>AIC</em>) for a fitted <code><a href="stats.html#topic+smooth.spline">smooth.spline</a></code>. The smaller the AIC, the better the spline fit.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>AIC_smooth_spline(fittedSmoothSpline)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="AIC_smooth_spline_+3A_fittedsmoothspline">fittedSmoothSpline</code></td>
<td>
<p>A fitted <code><a href="stats.html#topic+smooth.spline">smooth.spline</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>The AIC value.
</p>

<hr>
<h2 id='AICc_smooth_spline'>Calculate the Akaike Information Criterion Corrected for small observation numbers for a smooth.spline</h2><span id='topic+AICc_smooth_spline'></span>

<h3>Description</h3>

<p>Calculate the Akaike Information Criterion Corrected for small observation numbers (<em>AICc</em>) for a fitted <code><a href="stats.html#topic+smooth.spline">smooth.spline</a></code>. The smaller the AICc, the better the spline fit.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>AICc_smooth_spline(fittedSmoothSpline)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="AICc_smooth_spline_+3A_fittedsmoothspline">fittedSmoothSpline</code></td>
<td>
<p>A fitted <code><a href="stats.html#topic+smooth.spline">smooth.spline</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>The AICc value.
</p>

<hr>
<h2 id='BIC_smooth_spline'>Calculate the Bayesian Information Criterion for a smooth.spline</h2><span id='topic+BIC_smooth_spline'></span>

<h3>Description</h3>

<p>Calculate the Bayesian Information Criterion (<em>BIC</em>) for a fitted <code><a href="stats.html#topic+smooth.spline">smooth.spline</a></code>. The smaller the BIC, the better the spline fit.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BIC_smooth_spline(fittedSmoothSpline)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BIC_smooth_spline_+3A_fittedsmoothspline">fittedSmoothSpline</code></td>
<td>
<p>A fitted <code><a href="stats.html#topic+smooth.spline">smooth.spline</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>The BIC value.
</p>

<hr>
<h2 id='get_eigen_DF'>Compute the optimal df and weighted-df using 5 spline fitting metric</h2><span id='topic+get_eigen_DF'></span>

<h3>Description</h3>

<p>Compute the optimal degree of freedom (<em>df</em>) and weighted degree of freedom (<em>wdf</em>) using 5 fitting metrics (<em><strong>CV</strong>: Cross-Validation, <strong>GCV</strong>: Generalised Cross-Validation, <strong>AIC</strong>: Akaike Information Criterion, <strong>BIC</strong>: Bayesian Information Criterion, <strong>AICc</strong>: Akaike Information Criterion Corrected for small sample size</em>) over all eigenSplines generated by <code><a href="#topic+get_eigen_spline">get_eigen_spline</a></code>.
The degree of freedom (<em>df</em>) is obtained by averaging the optimal <em>df</em> across each eigenSpline.
The weighted degree of freedom (<em>wdf</em>) is obtained by weighting the optimal <em>df</em> in each eigenSpline by the percentage of variance explained by each eigenSpline, before summing the optimal <em>df</em>s (variance sums to 100%).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_eigen_DF(eigen)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_eigen_DF_+3A_eigen">eigen</code></td>
<td>
<p>A list of eigenSpline parameters as generated by <code><a href="#topic+get_eigen_spline">get_eigen_spline</a></code>, containing <code>eigen$matrix</code>, <code>eigen$variance</code>, <code>eigen$model</code> and <code>eigen$countTP</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list: <code>answer$df</code> a vector of optimum <em>df</em> by CV, GCV, AIC, BIC, AICc. <code>answer$wdf</code> a vector of weighted optimum <em>df</em> by CV, GCV, AIC, BIC, AICc.
</p>


<h3>See Also</h3>

<p>Graphical implementation with <code><a href="#topic+santaR_start_GUI">santaR_start_GUI</a></code>
</p>
<p>Other DFsearch: 
<code><a href="#topic+get_eigen_DFoverlay_list">get_eigen_DFoverlay_list</a>()</code>,
<code><a href="#topic+get_eigen_spline">get_eigen_spline</a>()</code>,
<code><a href="#topic+get_param_evolution">get_param_evolution</a>()</code>,
<code><a href="#topic+plot_nbTP_histogram">plot_nbTP_histogram</a>()</code>,
<code><a href="#topic+plot_param_evolution">plot_param_evolution</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## 8 subjects, 8 time-points, 3 variables
inputData &lt;- acuteInflammation$data[,1:3]
ind       &lt;- acuteInflammation$meta$ind
time      &lt;- acuteInflammation$meta$time
eigen     &lt;- get_eigen_spline(inputData, ind, time, nPC=NA, scaling="scaling_UV",
                              method="nipals", verbose=TRUE, centering=TRUE, ncores=0)
# nipals calculated PCA
# Importance of component(s):
#                  PC1    PC2     PC3      PC4    PC5      PC6
# R2            0.8924 0.0848 0.01055 0.006084 0.0038 0.002362
# Cumulative R2 0.8924 0.9772 0.98775 0.993838 0.9976 1.000000
get_eigen_DF(eigen)
# $df
#       CV      GCV      AIC      BIC     AICc 
# 3.362581 4.255487 3.031260 2.919159 2.172547 
# $wdf
#       CV      GCV      AIC      BIC     AICc 
# 2.293130 2.085212 6.675608 6.671545 4.467724 

</code></pre>

<hr>
<h2 id='get_eigen_DFoverlay_list'>Plot for each eigenSpline the automatically fitted spline, splines for all df and a spline at a chosen df</h2><span id='topic+get_eigen_DFoverlay_list'></span>

<h3>Description</h3>

<p>Plot for each eigenSpline the automatically fitted spline (red), splines for all possible <em>df</em> (grey) and a spline at a manually chosen <em>df</em> (blue).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_eigen_DFoverlay_list(
  eigen,
  manualDf = 5,
  nPC = NA,
  step = NA,
  showPt = TRUE,
  autofit = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_eigen_DFoverlay_list_+3A_eigen">eigen</code></td>
<td>
<p>A list of eigenSpline parameters as generated by <code><a href="#topic+get_eigen_spline">get_eigen_spline</a></code>, containing <code>eigen$matrix</code>, <code>eigen$variance</code>, <code>eigen$model</code> and <code>eigen$countTP</code>.</p>
</td></tr>
<tr><td><code id="get_eigen_DFoverlay_list_+3A_manualdf">manualDf</code></td>
<td>
<p>(int) A manually selected <em>df</em>. Default is 5.</p>
</td></tr>
<tr><td><code id="get_eigen_DFoverlay_list_+3A_npc">nPC</code></td>
<td>
<p>(int) The first <em>n</em> eigenSplines to plot. Default is NA, plot all eigenSplines.</p>
</td></tr>
<tr><td><code id="get_eigen_DFoverlay_list_+3A_step">step</code></td>
<td>
<p>(float) The <em>df</em> increment employed to plot splines over the range of <em>df</em>.</p>
</td></tr>
<tr><td><code id="get_eigen_DFoverlay_list_+3A_showpt">showPt</code></td>
<td>
<p>(bool) If True the eigenSpline data points are plotted. Default is TRUE.</p>
</td></tr>
<tr><td><code id="get_eigen_DFoverlay_list_+3A_autofit">autofit</code></td>
<td>
<p>(bool) If True the automatically fitted splines <em>(using CV)</em> are plotted. Default is TRUE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of <code>ggplot2</code> plotObjects, one plot per eigenSpline. All results can be plotted using <code>do.call(grid.arrange, returnedResult)</code>.
</p>


<h3>See Also</h3>

<p>Graphical implementation with <code><a href="#topic+santaR_start_GUI">santaR_start_GUI</a></code>
</p>
<p>Other DFsearch: 
<code><a href="#topic+get_eigen_DF">get_eigen_DF</a>()</code>,
<code><a href="#topic+get_eigen_spline">get_eigen_spline</a>()</code>,
<code><a href="#topic+get_param_evolution">get_param_evolution</a>()</code>,
<code><a href="#topic+plot_nbTP_histogram">plot_nbTP_histogram</a>()</code>,
<code><a href="#topic+plot_param_evolution">plot_param_evolution</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## 8 subjects, 4 time-points, 3 variables
inputData  &lt;- acuteInflammation$data[0:32,1:3]
ind        &lt;- acuteInflammation$meta$ind[0:32]
time       &lt;- acuteInflammation$meta$time[0:32]
eigen      &lt;- get_eigen_spline(inputData, ind, time, nPC=NA, scaling="scaling_UV",
                               method="nipals", verbose=TRUE, centering=TRUE, ncores=0)
paramSpace &lt;- get_param_evolution(eigen, step=1)
plotList   &lt;- get_eigen_DFoverlay_list(eigen,manualDf=3,step=0.5,showPt=TRUE,autofit=TRUE)
plotList[1]
# do.call(grid.arrange, plotList)

</code></pre>

<hr>
<h2 id='get_eigen_spline'>Compute eigenSplines across a dataset</h2><span id='topic+get_eigen_spline'></span>

<h3>Description</h3>

<p>Compute &quot;eigenSplines&quot; across a dataset to discover the best <em>df</em> for spline fitting.  
</p>


<h4>Steps:</h4>


<ul>
<li><p> UV Scale the data.
</p>
</li>
<li><p> Turn each VAR in (IND x TIME) and group all VAR in (IND+VAR x TIME) using <code><a href="#topic+get_eigen_spline_matrix">get_eigen_spline_matrix</a></code>.
</p>
</li>
<li><p> Compute &quot;eigen.splines&quot; on the transposed table (TIME x IND+VAR).
</p>
</li>
<li><p> Returns eigen$matrix = PCprojection x TIME and eigen$variance = variance explained for each PC.
</p>
</li></ul>




<h3>Usage</h3>

<pre><code class='language-R'>get_eigen_spline(
  inputData,
  ind,
  time,
  nPC = NA,
  scaling = "scaling_UV",
  method = "nipals",
  verbose = TRUE,
  centering = TRUE,
  ncores = 0
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_eigen_spline_+3A_inputdata">inputData</code></td>
<td>
<p>Matrix of measurements with observations as rows and variables as columns.</p>
</td></tr>
<tr><td><code id="get_eigen_spline_+3A_ind">ind</code></td>
<td>
<p>Vector of subject identifier (individual) corresponding to each measurement.</p>
</td></tr>
<tr><td><code id="get_eigen_spline_+3A_time">time</code></td>
<td>
<p>Vector of time corresponding to each measurement.</p>
</td></tr>
<tr><td><code id="get_eigen_spline_+3A_npc">nPC</code></td>
<td>
<p>(int) Number of Principal Components to compute, if none given (<code>nPC=NA</code>) compute all PC (usually number TP-1 as there is 1PC less than the smallest dimension).</p>
</td></tr>
<tr><td><code id="get_eigen_spline_+3A_scaling">scaling</code></td>
<td>
<p><code>"scaling_UV"</code> or <code>"scaling_mean"</code> scaling across all samples for each variable. Default <code>"scaling_UV"</code>. Note: scaling takes place outside of the pcaMethods call, therefore <code>$model</code> will indicate &quot;Data was NOT scaled before running PCA&quot;.</p>
</td></tr>
<tr><td><code id="get_eigen_spline_+3A_method">method</code></td>
<td>
<p>PCA method <code>"svd"</code> doesn't accept missing value. <code>"nipals"</code> can handle missing values. Default <code>"nipals"</code>.</p>
</td></tr>
<tr><td><code id="get_eigen_spline_+3A_verbose">verbose</code></td>
<td>
<p>If <code>TRUE</code> print the PCA summary. Default <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="get_eigen_spline_+3A_centering">centering</code></td>
<td>
<p>If <code>TRUE</code> centering for PCA, needed to remove baseline levels of each pc (often PC1). Default <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="get_eigen_spline_+3A_ncores">ncores</code></td>
<td>
<p>(int) Number of cores to use for parallelisation of the grouping of all splines. Default 0 for no parallelisation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list eigen: <code>eigen$matrix</code> <code>data.frame</code> of eigenSplines values with PCprojection as row and TIME as column. <code>eigen$variance</code> Vector of variance explained for each PC. <code>eigen$model</code> resulting pcaMethods model. <code>eigen$countTP</code> Matrix of number of measurements for each unique timepoint (as row).
</p>


<h4>Comments:</h4>


<ul>
<li><p> CENTERING: Centering converts all the values to fluctuations around zero instead of around the mean of the variable measurements. Hereby, it adjusts for differences in the offset between high and low intensity variables. It is therefore used to focus on the fluctuating part of the data, and leaves only the relevant variation (being the variation between the observations) for analysis.
</p>
</li>
<li><p> SCALING: Scaling methods are data pretreatment approaches that divide each variable by a factor -the scaling factor- which is different for each variable. They aim to adjust for the differences in fold differences between the various variables by converting the data into differences in values relative to the scaling factor. This often results in the inflation of small values, which can have an undesirable side effect as the influence of the measurement error -that is usually relatively large for small values- is increased as well.
</p>
</li>
<li><p> UNIT VARIANCE SCALING: UV or Autoscaling, is commonly applied and uses the standard deviation as the scaling factor. After autoscaling, all variables have a standard deviation of one and therefore the data is analysed on the basis of correlations instead of covariances, as is the case with centering.
</p>
</li>
<li><p> BEFORE PCA, centering must be applied on the matrix that will be submitted to PCA to remove &quot;baseline&quot; levels.
</p>
</li></ul>




<h3>See Also</h3>

<p>Graphical implementation with <code><a href="#topic+santaR_start_GUI">santaR_start_GUI</a></code>
</p>
<p>Other DFsearch: 
<code><a href="#topic+get_eigen_DF">get_eigen_DF</a>()</code>,
<code><a href="#topic+get_eigen_DFoverlay_list">get_eigen_DFoverlay_list</a>()</code>,
<code><a href="#topic+get_param_evolution">get_param_evolution</a>()</code>,
<code><a href="#topic+plot_nbTP_histogram">plot_nbTP_histogram</a>()</code>,
<code><a href="#topic+plot_param_evolution">plot_param_evolution</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## 7 measurements, 3 subjects, 4 unique time-points, 2 variables
inputData &lt;- matrix(c(1,2,3,4,5,6,7,8,9 ,10,11,12,13,14,15,16,17,18), ncol=2)
ind  &lt;- c('ind_1','ind_1','ind_1','ind_2','ind_2','ind_2','ind_3','ind_3','ind_3')
time &lt;- c(0,5,10,0,10,15,5,10,15)
get_eigen_spline(inputData, ind, time, nPC=NA, scaling="scaling_UV", method="nipals",
                 verbose=TRUE, centering=TRUE, ncores=0)
# nipals calculated PCA
# Importance of component(s):
#                  PC1    PC2     PC3
# R2            0.7113 0.2190 0.05261
# Cumulative R2 0.7113 0.9303 0.98287
# total time: 0.12 secs
# $matrix
#              0          5        10         15
# PC1 -1.7075707 -0.7066426 0.7075708  1.7066425
# PC2 -0.3415271  0.9669724 1.0944005 -0.4297013
# PC3 -0.1764657 -0.5129981 0.5110671  0.1987611
# 
# $variance
# [1] 0.71126702 0.21899068 0.05260949
# 
# $model
# nipals calculated PCA
# Importance of component(s):
#                  PC1    PC2     PC3
# R2            0.7113 0.2190 0.05261
# Cumulative R2 0.7113 0.9303 0.98287
# 6 	Variables
# 4 	Samples
# 6 	NAs ( 25 %)
# 3 	Calculated component(s)
# Data was mean centered before running PCA 
# Data was NOT scaled before running PCA 
# Scores structure:
# [1] 4 3
# Loadings structure:
# [1] 6 3
# 
# $countTP
#   [,1]
# 3    6

</code></pre>

<hr>
<h2 id='get_eigen_spline_matrix'>Generate a Ind x Time + Var data.frame concatenating all variables from input variable</h2><span id='topic+get_eigen_spline_matrix'></span>

<h3>Description</h3>

<p>Generate Ind x Time <code>data.frame</code> for each variable using <code><a href="#topic+get_ind_time_matrix">get_ind_time_matrix</a></code> and then concatenate all variables rowise. Resulting <code>data.frame</code> contrain Time as columns and Individuals and Variables as rows. Pairs of Individual and Timepoint without a measurement are left as NA. If ncore!=0 the function is parallelised, however the parallelisation overhead cost is high if not required.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_eigen_spline_matrix(inputData, ind, time, ncores = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_eigen_spline_matrix_+3A_inputdata">inputData</code></td>
<td>
<p><code>data.frame</code> of measurements with observations as rows and variables as columns</p>
</td></tr>
<tr><td><code id="get_eigen_spline_matrix_+3A_ind">ind</code></td>
<td>
<p>Vector of subject identifier (individual) corresponding to each measurement</p>
</td></tr>
<tr><td><code id="get_eigen_spline_matrix_+3A_time">time</code></td>
<td>
<p>Vector of time corresponding to each measurement</p>
</td></tr>
<tr><td><code id="get_eigen_spline_matrix_+3A_ncores">ncores</code></td>
<td>
<p>(int) Number of cores to use for parallelisation. Default 0 for no parallelisation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>data.frame</code> of measurements for each IND x TIME + VAR. Rows are unique Individual IDs per variable, and columns unique measurement Time. Pairs of (IND,TIME+VAR) without a measurement are left as NA.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## 6 measurements, 3 subjects, 3 unique time-points, 2 variables
inputData &lt;- matrix(c(1,2,3,4,5,6, 7,8,9,10,11,12), ncol=2)
ind  &lt;- c('ind_1','ind_1','ind_1','ind_2','ind_2','ind_3')
time &lt;- c(0,5,10,0,10,5)
get_eigen_spline_matrix(inputData, ind, time, ncores=0)
#     0   5  10
# 1   1   2   3
# 2   4  NA   5
# 3  NA   6  NA
# 4   7   8   9
# 5  10  NA  11
# 6  NA  12  NA

## End(Not run)
</code></pre>

<hr>
<h2 id='get_grouping'>Generate a matrix of group membership for all individuals</h2><span id='topic+get_grouping'></span>

<h3>Description</h3>

<p>Establish the group membership of individuals based on the metadata across all observations using the vector of subject identifier and the matching vector of group membership.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_grouping(ind, group)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_grouping_+3A_ind">ind</code></td>
<td>
<p>vector of subject identifier (individual) for each observation</p>
</td></tr>
<tr><td><code id="get_grouping_+3A_group">group</code></td>
<td>
<p>vector of group membership for each observation</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>data.frame</code> with as rows each unique Individual ID and 2 columns (ind and group).
</p>


<h3>See Also</h3>

<p>Other Analysis: 
<code><a href="#topic+get_ind_time_matrix">get_ind_time_matrix</a>()</code>,
<code><a href="#topic+santaR_CBand">santaR_CBand</a>()</code>,
<code><a href="#topic+santaR_auto_fit">santaR_auto_fit</a>()</code>,
<code><a href="#topic+santaR_auto_summary">santaR_auto_summary</a>()</code>,
<code><a href="#topic+santaR_fit">santaR_fit</a>()</code>,
<code><a href="#topic+santaR_plot">santaR_plot</a>()</code>,
<code><a href="#topic+santaR_pvalue_dist">santaR_pvalue_dist</a>()</code>,
<code><a href="#topic+santaR_pvalue_fit">santaR_pvalue_fit</a>()</code>,
<code><a href="#topic+santaR_start_GUI">santaR_start_GUI</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## 3 subjets in 2 groups
ind   &lt;- c('ind_1','ind_1','ind_1','ind_2','ind_2','ind_3')
group &lt;- c('g1','g1','g1','g2','g2','g1')
get_grouping(ind, group)
#     ind group
# 1 ind_1    g1
# 2 ind_2    g2
# 3 ind_3    g1

## 8 subjects in 2 groups
ind   &lt;- acuteInflammation$meta$ind
group &lt;- acuteInflammation$meta$group
get_grouping(ind, group)
#    ind   group
# 1 ind_1 Group1
# 2 ind_2 Group2
# 3 ind_3 Group1
# 4 ind_4 Group2
# 5 ind_5 Group1
# 6 ind_6 Group2
# 7 ind_7 Group1
# 8 ind_8 Group2

</code></pre>

<hr>
<h2 id='get_ind_time_matrix'>Generate a Ind x Time DataFrame from input data</h2><span id='topic+get_ind_time_matrix'></span>

<h3>Description</h3>

<p>Convert input data with each measurement as a row, to a <code>data.frame</code> of measurements with Individual as rows and Time as columns. Pairs of Individual and Timepoint without a measurement are left as NA. The resulting <code>data.frame</code> is employed as input for <code><a href="#topic+santaR_fit">santaR_fit</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_ind_time_matrix(Yi, ind, time, orderVect)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_ind_time_matrix_+3A_yi">Yi</code></td>
<td>
<p>vector of measurements</p>
</td></tr>
<tr><td><code id="get_ind_time_matrix_+3A_ind">ind</code></td>
<td>
<p>vector of subject identifier (individual) corresponding to each measurement</p>
</td></tr>
<tr><td><code id="get_ind_time_matrix_+3A_time">time</code></td>
<td>
<p>vector of time corresponding to each measurement</p>
</td></tr>
<tr><td><code id="get_ind_time_matrix_+3A_ordervect">orderVect</code></td>
<td>
<p>if provided, a vector of unique time to be used to order the time columns (otherwise rely on <code><a href="base.html#topic+sort">sort</a></code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>data.frame</code> of measurements for each IND x TIME. Rows are unique Individual IDs and columns unique measurement Time. Pairs of (IND,TIME) without a measurement are left as NA.
</p>


<h3>See Also</h3>

<p>Other Analysis: 
<code><a href="#topic+get_grouping">get_grouping</a>()</code>,
<code><a href="#topic+santaR_CBand">santaR_CBand</a>()</code>,
<code><a href="#topic+santaR_auto_fit">santaR_auto_fit</a>()</code>,
<code><a href="#topic+santaR_auto_summary">santaR_auto_summary</a>()</code>,
<code><a href="#topic+santaR_fit">santaR_fit</a>()</code>,
<code><a href="#topic+santaR_plot">santaR_plot</a>()</code>,
<code><a href="#topic+santaR_pvalue_dist">santaR_pvalue_dist</a>()</code>,
<code><a href="#topic+santaR_pvalue_fit">santaR_pvalue_fit</a>()</code>,
<code><a href="#topic+santaR_start_GUI">santaR_start_GUI</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## 6 measurements, 3 subjects, 3 unique time-points
Yi   &lt;- c(1,2,3,4,5,6)
ind  &lt;- c('ind_1','ind_1','ind_1','ind_2','ind_2','ind_3')
time &lt;- c(0,5,10,0,10,5)
get_ind_time_matrix(Yi, ind, time)
#        0  5 10
# ind_1  1  2  3
# ind_2  4 NA  5
# ind_3 NA  6 NA

## 56 measurements, 8 subjects, 7 unique time-points
Yi   &lt;- acuteInflammation$data$var_1
ind  &lt;- acuteInflammation$meta$ind
time &lt;- acuteInflammation$meta$time
get_ind_time_matrix(Yi, ind, time)

</code></pre>

<hr>
<h2 id='get_param_evolution'>Compute the value of different fitting metrics over all possible df for each eigenSpline</h2><span id='topic+get_param_evolution'></span>

<h3>Description</h3>

<p>Compute the value of 5 fitting metrics (<em><strong>CV</strong>: Cross-Validation, <strong>GCV</strong>: Generalised Cross-Validation, <strong>AIC</strong>: Akaike Information Criterion, <strong>BIC</strong>: Bayesian Information Criterion, <strong>AICc</strong>: Akaike Information Criterion Corrected for small sample size</em>) over all possible <em>df</em> for each eigenSpline generated by <code><a href="#topic+get_eigen_spline">get_eigen_spline</a></code>. The resulting matrix of fitting parameter values can be plotted using <code><a href="#topic+plot_param_evolution">plot_param_evolution</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_param_evolution(eigen, step = 0.1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_param_evolution_+3A_eigen">eigen</code></td>
<td>
<p>A list of eigenSpline parameters as generated by <code><a href="#topic+get_eigen_spline">get_eigen_spline</a></code>, containing <code>eigen$matrix</code>, <code>eigen$variance</code>, <code>eigen$model</code> and <code>eigen$countTP</code>.</p>
</td></tr>
<tr><td><code id="get_param_evolution_+3A_step">step</code></td>
<td>
<p>(float) The <em>df</em> increment employed to cover the range of <em>df</em>. Default steps of 0.1</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of <em>n</em> matrices (<em>n</em> being the number or eigenSplines). Each matrix  of fitting parameters has as rows different fitting metrics, as columns different <em>df</em> values.
</p>


<h3>See Also</h3>

<p>Graphical implementation with <code><a href="#topic+santaR_start_GUI">santaR_start_GUI</a></code>
</p>
<p>Other DFsearch: 
<code><a href="#topic+get_eigen_DF">get_eigen_DF</a>()</code>,
<code><a href="#topic+get_eigen_DFoverlay_list">get_eigen_DFoverlay_list</a>()</code>,
<code><a href="#topic+get_eigen_spline">get_eigen_spline</a>()</code>,
<code><a href="#topic+plot_nbTP_histogram">plot_nbTP_histogram</a>()</code>,
<code><a href="#topic+plot_param_evolution">plot_param_evolution</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## 8 subjects, 4 time-points, 3 variables
inputData &lt;- acuteInflammation$data[0:32,1:3]
ind       &lt;- acuteInflammation$meta$ind[0:32]
time      &lt;- acuteInflammation$meta$time[0:32]
eigen     &lt;- get_eigen_spline(inputData, ind, time, nPC=NA, scaling="scaling_UV",
                              method="nipals", verbose=TRUE, centering=TRUE, ncores=0)
# nipals calculated PCA
# Importance of component(s):
#                  PC1     PC2      PC3
# R2            0.9272 0.06606 0.006756
# Cumulative R2 0.9272 0.99324 1.000000
# total time: 0.02 secs
get_param_evolution(eigen, step=1)
# [[1]]
#                                  2           3          4
# Penalised_residuals(CV)  103.55727   141.55548 267.197267
# Penalised_residuals(GCV)  90.84612   122.03917 198.953021
# AIC                      185.57835    67.02707   8.000000
# BIC                      184.35094    65.18611   5.545177
# AICc                     197.57835 95464.81688 -32.000000
# 
# [[2]]
#                                   2            3          4
# Penalised_residuals(CV)   0.2257652 6.401150e-01   1.512174
# Penalised_residuals(GCV)  0.3034771 6.647154e-01   1.173309
# AIC                       4.6062841 6.331849e+00   8.000000
# BIC                       3.3788728 4.490887e+00   5.545177
# AICc                     16.6062865 9.540412e+04 -32.000000
# 
# [[3]]
#                                   2            3          4
# Penalised_residuals(CV)   0.8338811 9.171538e-01   1.484069
# Penalised_residuals(GCV)  0.6607046 7.148925e-01   1.105211
# AIC                       5.3094592 6.354912e+00   8.000000
# BIC                       4.0820479 4.513949e+00   5.545177
# AICc                     17.3094616 9.540414e+04 -32.000000

</code></pre>

<hr>
<h2 id='loglik_smooth_spline'>Calculate the penalised loglikelihood of a smooth.spline</h2><span id='topic+loglik_smooth_spline'></span>

<h3>Description</h3>

<p>Calculate the penalised loglikelihood of a <code><a href="stats.html#topic+smooth.spline">smooth.spline</a></code> using the integrated second derivative. The likelihood consists of 1) the (weighted) residuals sum of squares, 2) a penalty term (integrated second derivative = total curvature). The smaller the penalised loglikelihood, the better the fit as the residuals and penalty on roughness are minimised. Adapted from <code>aroma.light::likelihood.smooth.spline</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>loglik_smooth_spline(fittedSmoothSpline)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="loglik_smooth_spline_+3A_fittedsmoothspline">fittedSmoothSpline</code></td>
<td>
<p>A fitted <code><a href="stats.html#topic+smooth.spline">smooth.spline</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>The penalised loglikelihood.
</p>

<hr>
<h2 id='plot_nbTP_histogram'>Plot an histogram of the number of time-trajectories with a given number of time-points</h2><span id='topic+plot_nbTP_histogram'></span>

<h3>Description</h3>

<p>Histogram of the number of time-trajectories with a minimum number of time-points. When the number of time-points is inferior to the <em>df</em> selected, a spline cannot be fitted. The histogram highlights the number and percentage of time-trajectories that will be rejected for a given <em>df</em>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_nbTP_histogram(eigen, dfCutOff = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_nbTP_histogram_+3A_eigen">eigen</code></td>
<td>
<p>A list of eigenSpline parameters as generated by <code><a href="#topic+get_eigen_spline">get_eigen_spline</a></code>, containing <code>eigen$matrix</code>, <code>eigen$variance</code>, <code>eigen$model</code> and <code>eigen$countTP</code>.</p>
</td></tr>
<tr><td><code id="plot_nbTP_histogram_+3A_dfcutoff">dfCutOff</code></td>
<td>
<p>(int) A number (a selected <em>df</em>) to highlight the portion of trajectories that would be rejected form the dataset (numberTP &lt; <em>df</em>). Default is NA, with no cut-off plotted.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot2 plotObject.
</p>


<h3>See Also</h3>

<p>Graphical implementation with <code><a href="#topic+santaR_start_GUI">santaR_start_GUI</a></code>
</p>
<p>Other DFsearch: 
<code><a href="#topic+get_eigen_DF">get_eigen_DF</a>()</code>,
<code><a href="#topic+get_eigen_DFoverlay_list">get_eigen_DFoverlay_list</a>()</code>,
<code><a href="#topic+get_eigen_spline">get_eigen_spline</a>()</code>,
<code><a href="#topic+get_param_evolution">get_param_evolution</a>()</code>,
<code><a href="#topic+plot_param_evolution">plot_param_evolution</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## 8 subjects, 4 time-points, 3 variables, some missing values
inputData  &lt;- acuteInflammation$data[0:32,1:3]
inputData  &lt;- inputData[-1,]
inputData  &lt;- inputData[-8,]
inputData  &lt;- inputData[-30,]
inputData  &lt;- inputData[-29,]
ind        &lt;- acuteInflammation$meta$ind[0:32]
ind        &lt;- ind[-1]
ind        &lt;- ind[-8]
ind        &lt;- ind[-30]
ind        &lt;- ind[-29]
time       &lt;- acuteInflammation$meta$time[0:32]
time       &lt;- time[-1]
time       &lt;- time[-8]
time       &lt;- time[-30]
time       &lt;- time[-29]
eigen      &lt;- get_eigen_spline(inputData, ind, time, nPC=NA, scaling="scaling_UV",
                               method="nipals", verbose=TRUE, centering=TRUE, ncores=0)
plot_nbTP_histogram(eigen, dfCutOff=3)

</code></pre>

<hr>
<h2 id='plot_param_evolution'>Plot the evolution of different fitting parameters across all possible df for each eigenSpline</h2><span id='topic+plot_param_evolution'></span>

<h3>Description</h3>

<p>Plot the evolution of 5 different fitting metrics (<em><strong>CV</strong>: Cross-Validation, <strong>GCV</strong>: Generalised Cross-Validation, <strong>AIC</strong>: Akaike Information Criterion, <strong>BIC</strong>: Bayesian Information Criterion, <strong>AICc</strong>: Akaike Information Criterion Corrected for small sample size</em>) over all possible <em>df</em> for each eigenSpline generated by <code><a href="#topic+get_param_evolution">get_param_evolution</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_param_evolution(paramSpace, scaled = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_param_evolution_+3A_paramspace">paramSpace</code></td>
<td>
<p>A list of <em>n</em> matrices (<em>n</em> being the number or eigenSplines) as generated by <code><a href="#topic+plot_param_evolution">plot_param_evolution</a></code>. Each matrix  of fitting parameters has as rows different fitting metrics, as columns different <em>df</em> values.</p>
</td></tr>
<tr><td><code id="plot_param_evolution_+3A_scaled">scaled</code></td>
<td>
<p>(bool) If TRUE, the value of each eigenSpline fitting parameter are scaled between 0 and 1. Default is TRUE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of <code>ggplot2</code> plotObjects, one plot per fitting parameters. All results can be plotted using <code>do.call(grid.arrange, returnedResult)</code>
</p>


<h3>See Also</h3>

<p>Graphical implementation with <code><a href="#topic+santaR_start_GUI">santaR_start_GUI</a></code>
</p>
<p>Other DFsearch: 
<code><a href="#topic+get_eigen_DF">get_eigen_DF</a>()</code>,
<code><a href="#topic+get_eigen_DFoverlay_list">get_eigen_DFoverlay_list</a>()</code>,
<code><a href="#topic+get_eigen_spline">get_eigen_spline</a>()</code>,
<code><a href="#topic+get_param_evolution">get_param_evolution</a>()</code>,
<code><a href="#topic+plot_nbTP_histogram">plot_nbTP_histogram</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## 8 subjects, 4 time-points, 3 variables
inputData  &lt;- acuteInflammation$data[0:32,1:3]
ind        &lt;- acuteInflammation$meta$ind[0:32]
time       &lt;- acuteInflammation$meta$time[0:32]
eigen      &lt;- get_eigen_spline(inputData, ind, time, nPC=NA, scaling="scaling_UV",
                               method="nipals", verbose=TRUE, centering=TRUE, ncores=0)
paramSpace &lt;- get_param_evolution(eigen, step=0.25)
plotList   &lt;- plot_param_evolution(paramSpace, scaled=TRUE)
plotList[1]
#do.call(grid.arrange, plotList )

</code></pre>

<hr>
<h2 id='santaR'>santaR: A package for Short AsyNchronous Time-series Analysis in R</h2><span id='topic+santaR-package'></span><span id='topic+santaR'></span><span id='topic+SANTAR'></span>

<h3>Description</h3>

<p><span class="pkg">santaR</span> provides a graphical and automated pipeline for the analysis of short time-series studies.
It enables the detection of significantly altered time trajectories between study groups, while
being resilient to missing values and unsynchronised measurements.
</p>


<h3>Details</h3>

<p>The main functions of <span class="pkg">santaR</span> are <code><a href="#topic+santaR_start_GUI">santaR_start_GUI</a></code> to start the graphical user
interface, as well as <code><a href="#topic+santaR_auto_fit">santaR_auto_fit</a></code> and <code><a href="#topic+santaR_auto_summary">santaR_auto_summary</a></code> for
automated command line analysis and reporting. Refer to the vignettes for graphical user
interface and command line tutorials.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Arnaud Wolfer <a href="mailto:adwolfer@gmail.com">adwolfer@gmail.com</a> (<a href="https://orcid.org/0000-0001-5856-3218">ORCID</a>)
</p>
<p>Other contributors:
</p>

<ul>
<li><p> Timothy Ebbels <a href="mailto:t.ebbels@imperial.ac.uk">t.ebbels@imperial.ac.uk</a> [contributor]
</p>
</li>
<li><p> Joe Cheng <a href="mailto:joe@rstudio.com">joe@rstudio.com</a> (Shiny javascript custom-input control) [contributor]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/adwolfer/santaR">https://github.com/adwolfer/santaR</a>
</p>
</li>
<li> <p><a href="https://adwolfer.github.io/santaR/">https://adwolfer.github.io/santaR/</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/adwolfer/santaR/issues/new">https://github.com/adwolfer/santaR/issues/new</a>
</p>
</li></ul>


<hr>
<h2 id='santaR_auto_fit'>Automate all steps of santaR fitting, Confidence bands estimation and p-values calculation for one or multiple variables</h2><span id='topic+santaR_auto_fit'></span>

<h3>Description</h3>

<p><code>santaR_auto_fit</code> encompasses all the analytical steps for the detection of significantly altered time trajectories (<em>input data preparation: <code><a href="#topic+get_ind_time_matrix">get_ind_time_matrix</a></code>, establishing group membership: <code><a href="#topic+get_grouping">get_grouping</a></code>, spline modelling of individual and group time evolutions: <code><a href="#topic+santaR_fit">santaR_fit</a></code>, computation of group mean curve confidence bands: <code><a href="#topic+santaR_CBand">santaR_CBand</a></code>, identification of significantly altered time trajectories: <code><a href="#topic+santaR_pvalue_dist">santaR_pvalue_dist</a></code> and/or <code><a href="#topic+santaR_pvalue_fit">santaR_pvalue_fit</a></code></em>). As <em>santaR</em> is an univariate approach, multiple variables can be processed independently, which <code>santaR_auto_fit</code> can execute in parallel over multiple CPU cores.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>santaR_auto_fit(
  inputData,
  ind,
  time,
  group = NA,
  df,
  ncores = 0,
  CBand = TRUE,
  pval.dist = TRUE,
  pval.fit = FALSE,
  nBoot = 1000,
  alpha = 0.05,
  nPerm = 1000,
  nStep = 5000,
  alphaPval = 0.05,
  forceParIndTimeMat = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="santaR_auto_fit_+3A_inputdata">inputData</code></td>
<td>
<p><code>data.frame</code> of measurements with observations as rows and variables as columns.</p>
</td></tr>
<tr><td><code id="santaR_auto_fit_+3A_ind">ind</code></td>
<td>
<p>Vector of subject identifier (individual) corresponding to each measurement.</p>
</td></tr>
<tr><td><code id="santaR_auto_fit_+3A_time">time</code></td>
<td>
<p>Vector of the time corresponding to each measurement.</p>
</td></tr>
<tr><td><code id="santaR_auto_fit_+3A_group">group</code></td>
<td>
<p>NA or vector of group membership for each measurement. Default is NA for no groups.</p>
</td></tr>
<tr><td><code id="santaR_auto_fit_+3A_df">df</code></td>
<td>
<p>(float) Degree of freedom to employ for fitting the individual and group mean <code><a href="stats.html#topic+smooth.spline">smooth.spline</a></code>.</p>
</td></tr>
<tr><td><code id="santaR_auto_fit_+3A_ncores">ncores</code></td>
<td>
<p>(int) Number of cores to use for parallelisation. Default 0 for no parallelisation.</p>
</td></tr>
<tr><td><code id="santaR_auto_fit_+3A_cband">CBand</code></td>
<td>
<p>If TRUE calculate confidence bands for group mean curves. Default is TRUE.</p>
</td></tr>
<tr><td><code id="santaR_auto_fit_+3A_pval.dist">pval.dist</code></td>
<td>
<p>If TRUE calculate <em>p</em>-value based on inter-group mean curve distance. Default is TRUE.</p>
</td></tr>
<tr><td><code id="santaR_auto_fit_+3A_pval.fit">pval.fit</code></td>
<td>
<p>If TRUE calculate <em>p</em>-value based on group mean curve improvement in fit. Default is FALSE.</p>
</td></tr>
<tr><td><code id="santaR_auto_fit_+3A_nboot">nBoot</code></td>
<td>
<p>(int) Number of bootstrapping rounds for confidence band calculation. Default 1000.</p>
</td></tr>
<tr><td><code id="santaR_auto_fit_+3A_alpha">alpha</code></td>
<td>
<p>(float) Confidence <em>(0.05 for 95% Confidence Bands)</em>. Default 0.05.</p>
</td></tr>
<tr><td><code id="santaR_auto_fit_+3A_nperm">nPerm</code></td>
<td>
<p>(int) Number of permutations for <em>p</em>-value calculation. Default 1000.</p>
</td></tr>
<tr><td><code id="santaR_auto_fit_+3A_nstep">nStep</code></td>
<td>
<p>(int) Number of steps (granularity) employed for the calculation of the area between group mean curves (<em>p-value dist</em>). Default is 5000.</p>
</td></tr>
<tr><td><code id="santaR_auto_fit_+3A_alphapval">alphaPval</code></td>
<td>
<p>(float) Confidence Interval on the permuted <em>p</em>-value <em>(0.05 for 95% Confidence Interval)</em>. Default 0.05.</p>
</td></tr>
<tr><td><code id="santaR_auto_fit_+3A_forceparindtimemat">forceParIndTimeMat</code></td>
<td>
<p>If TRUE parallelise the preparation of input data by <code><a href="#topic+get_ind_time_matrix">get_ind_time_matrix</a></code>. Default is FALSE.</p>
</td></tr>
</table>


<h3>Details</h3>



<h4>Note</h4>


<ul>
<li><p> The calculation of confidence bands accounts for approximately a third of the time taken by <code>santaR_auto_fit</code>, while the identification of significantly altered time trajectories (either <code><a href="#topic+santaR_pvalue_dist">santaR_pvalue_dist</a></code> or <code><a href="#topic+santaR_pvalue_fit">santaR_pvalue_fit</a></code>) accounts for two third of the total time. The time taken by these steps increases linearly with the increase of their respective parameters: <code>nBoot</code> for confidence bands, <code>nPerm</code> and <code>nStep</code> for identification of significantly altered trajectories using <code><a href="#topic+santaR_pvalue_dist">santaR_pvalue_dist</a></code>, <code>nPerm</code> for <code><a href="#topic+santaR_pvalue_fit">santaR_pvalue_fit</a></code>. Default values of these parameters are optimised to balance the time taken with the precision of the value estimation; increasing <code>nPerm</code> can tighten the <em>p</em>-value confidence intervals.
</p>
</li>
<li><p> If the parallelisation is activated (<em><code>ncores&gt;0</code></em>), the fit of spline models, the calculation of confidence bands on the group mean curves and the identification of altered trajectories are executed for multiple variables simultaneously. However the preparation of input data (<code><a href="#topic+get_ind_time_matrix">get_ind_time_matrix</a></code>) is not parallelised by default as the parallelisation overhead cost is superior to the time potentially gained for all but the most complex datasets. The parallelisation overhead (<em>instantiating worker nodes, duplicating and transferring inputs to the worker nodes, concatenating results</em>) typically equals around 2 seconds, while executing <code><a href="#topic+get_ind_time_matrix">get_ind_time_matrix</a></code> is usually a matter of millisecond for a single variable (<em>ex: 7 time-points, 24 individuals, 1 variable)</em>; the parallelisation overhead far exceeding the time needed to process all variables sequentially. If the number of individual trajectories (subjects), of time-points, or of variables is very large, <code>forceParIndTimeMat</code> enables the parallelisation of <code><a href="#topic+get_ind_time_matrix">get_ind_time_matrix</a></code>.
</p>
</li></ul>




<h3>Value</h3>

<p>A list of <em>SANTAObj</em> corresponding to each variable's analysis result.
</p>


<h3>See Also</h3>

<p>Other AutoProcess: 
<code><a href="#topic+santaR_auto_summary">santaR_auto_summary</a>()</code>,
<code><a href="#topic+santaR_plot">santaR_plot</a>()</code>,
<code><a href="#topic+santaR_start_GUI">santaR_start_GUI</a>()</code>
</p>
<p>Other Analysis: 
<code><a href="#topic+get_grouping">get_grouping</a>()</code>,
<code><a href="#topic+get_ind_time_matrix">get_ind_time_matrix</a>()</code>,
<code><a href="#topic+santaR_CBand">santaR_CBand</a>()</code>,
<code><a href="#topic+santaR_auto_summary">santaR_auto_summary</a>()</code>,
<code><a href="#topic+santaR_fit">santaR_fit</a>()</code>,
<code><a href="#topic+santaR_plot">santaR_plot</a>()</code>,
<code><a href="#topic+santaR_pvalue_dist">santaR_pvalue_dist</a>()</code>,
<code><a href="#topic+santaR_pvalue_fit">santaR_pvalue_fit</a>()</code>,
<code><a href="#topic+santaR_start_GUI">santaR_start_GUI</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## 2 variables, 56 measurements, 8 subjects, 7 unique time-points
## Default parameter values decreased to ensure an execution &lt; 2 seconds
inputData     &lt;- acuteInflammation$data[,1:2]
ind           &lt;- acuteInflammation$meta$ind
time          &lt;- acuteInflammation$meta$time
group         &lt;- acuteInflammation$meta$group
SANTAObjList  &lt;- santaR_auto_fit(inputData, ind, time, group, df=5, ncores=0, CBand=TRUE,
                                pval.dist=TRUE, nBoot=100, nPerm=100)
# Input data generated: 0.02 secs
# Spline fitted: 0.03 secs
# ConfBands done: 0.53 secs
# p-val dist done: 0.79 secs
# total time: 1.37 secs
length(SANTAObjList)
# [1] 2
names(SANTAObjList)
# [1] "var_1" "var_2"

</code></pre>

<hr>
<h2 id='santaR_auto_summary'>Summarise, report and save the results of a santaR analysis</h2><span id='topic+santaR_auto_summary'></span>

<h3>Description</h3>

<p>After multiple variables have been analysed using <code><a href="#topic+santaR_auto_fit">santaR_auto_fit</a></code>, <code>santaR_auto_summary</code> helps identify significant results and summarise them in an interpretable fashion. Correction for multiple testing can be applied to generate Bonferroni <cite>[1]</cite>, Benjamini-Hochberg <cite>[2]</cite> or Benjamini-Yekutieli <cite>[3]</cite> corrected <em>p</em>-values. <em>P</em>-values can be saved to disk in <code>.csv</code> files. For a given significance cut-off (<code>plotCutOff</code>), the number of variables significantly altered is reported and plots are automatically saved to disk by increasing <em>p</em>-value. The aspect of the plots can be altered such as the representation of confidence bands (<code>showConfBand</code>) or the generation of a mean curve across all samples (<code>showTotalMeanCurve</code>) to help assess difference between groups when group sizes are unbalanced.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>santaR_auto_summary(
  SANTAObjList,
  targetFolder = NA,
  summaryCSV = TRUE,
  CSVName = "summary",
  savePlot = TRUE,
  plotCutOff = 0.05,
  showTotalMeanCurve = TRUE,
  showConfBand = TRUE,
  legend = TRUE,
  fdrBH = TRUE,
  fdrBY = FALSE,
  fdrBonf = FALSE,
  CIpval = TRUE,
  plotAll = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="santaR_auto_summary_+3A_santaobjlist">SANTAObjList</code></td>
<td>
<p>A list of <em>SANTAObj</em> with <em>p</em>-values calculated, as generated by <code><a href="#topic+santaR_auto_fit">santaR_auto_fit</a></code>.</p>
</td></tr>
<tr><td><code id="santaR_auto_summary_+3A_targetfolder">targetFolder</code></td>
<td>
<p>(NA or str) NA or the path to a folder in which to save summary.xls and plots. If NA no outputs are saved to disk. If <code>targetFolder</code> does not exist, folders will be created. Default is NA.</p>
</td></tr>
<tr><td><code id="santaR_auto_summary_+3A_summarycsv">summaryCSV</code></td>
<td>
<p>If TRUE save the (<em>corrected if applicable</em>) <em>p</em>-values to <code>'CSVName'_summary.csv</code>, <code>'CSVName'_pvalue-all.csv</code>, <code>'CSVName'_pvalue-dist.csv</code>, <code>'CSVName'_pvalue-dist.csv</code> (<em>default <code>summary_summary.csv</code>,...</em>). Default is TRUE.</p>
</td></tr>
<tr><td><code id="santaR_auto_summary_+3A_csvname">CSVName</code></td>
<td>
<p>(string) Filename of the <em>csv</em> to save. Default is <code>'summary'</code>.</p>
</td></tr>
<tr><td><code id="santaR_auto_summary_+3A_saveplot">savePlot</code></td>
<td>
<p>If TRUE save to <code>targetFolder</code> all variables with <em>p</em> &lt; <code>plotCutOff</code> ordered by <em>p</em>-values. Default is TRUE.</p>
</td></tr>
<tr><td><code id="santaR_auto_summary_+3A_plotcutoff">plotCutOff</code></td>
<td>
<p>(float) <em>P</em>-value cut-off value to save summary plots to disk. Default 0.05.</p>
</td></tr>
<tr><td><code id="santaR_auto_summary_+3A_showtotalmeancurve">showTotalMeanCurve</code></td>
<td>
<p>If TRUE add the mean curve across all groups on the plots. Default is TRUE.</p>
</td></tr>
<tr><td><code id="santaR_auto_summary_+3A_showconfband">showConfBand</code></td>
<td>
<p>If TRUE plot the confidence band for each group. Default is TRUE.</p>
</td></tr>
<tr><td><code id="santaR_auto_summary_+3A_legend">legend</code></td>
<td>
<p>If TRUE add a legend to the plots. Default is TRUE.</p>
</td></tr>
<tr><td><code id="santaR_auto_summary_+3A_fdrbh">fdrBH</code></td>
<td>
<p>If TRUE add the Benjamini-Hochberg corrected <em>p</em>-value to the output. Default is TRUE.</p>
</td></tr>
<tr><td><code id="santaR_auto_summary_+3A_fdrby">fdrBY</code></td>
<td>
<p>If TRUE add the Benjamini-Yekutieli corrected <em>p</em>-value to the output. Default is FALSE.</p>
</td></tr>
<tr><td><code id="santaR_auto_summary_+3A_fdrbonf">fdrBonf</code></td>
<td>
<p>If TRUE add the Bonferroni corrected <em>p</em>-value to the output. Default is FALSE.</p>
</td></tr>
<tr><td><code id="santaR_auto_summary_+3A_cipval">CIpval</code></td>
<td>
<p>If TRUE add the upper and lower confidence interval on <em>p</em>-value to the output. Default is TRUE.</p>
</td></tr>
<tr><td><code id="santaR_auto_summary_+3A_plotall">plotAll</code></td>
<td>
<p>If TRUE override the <code>plotCutOff</code> parameter and plot all variables. Default is FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list: <code>result$pval.all</code> <code>data.frame</code> of <em>p</em>-values, with all variables as rows and different <em>p</em>-value corrections as columns. <code>result$pval.summary</code> <code>data.frame</code> of number of variables with a <em>p</em>-value inferior to a cut-off. Different metric and <em>p</em>-value correction as rows, different cut-off (<em>Inf 0.05</em>, <em>Inf 0.01</em>, <em>Inf 0.001</em>) as columns.
</p>


<h3>References</h3>

<p>[1] Bland, J. M. &amp; Altman, D. G. <em>Multiple significance tests: the Bonferroni method</em>. British Medial Journal <strong>310</strong>, 170 (1995).
</p>
<p>[2] Benjamini, Y. &amp; Hochberg, Y. <em>Controlling the False Discovery Rate: A Practical and Powerful Approach to Multiple Testing</em>. Journal of the Royal Statistical Society <strong>57</strong>, 1, 289-300 (1995).
</p>
<p>[3] Benjamini, Y. &amp; Yekutieli, D. <em>The control of the false discovery rate in multiple testing under depencency</em>. The Annals of Statistics <strong>29</strong>, 1165-1188 (2001).
</p>


<h3>See Also</h3>

<p>Other AutoProcess: 
<code><a href="#topic+santaR_auto_fit">santaR_auto_fit</a>()</code>,
<code><a href="#topic+santaR_plot">santaR_plot</a>()</code>,
<code><a href="#topic+santaR_start_GUI">santaR_start_GUI</a>()</code>
</p>
<p>Other Analysis: 
<code><a href="#topic+get_grouping">get_grouping</a>()</code>,
<code><a href="#topic+get_ind_time_matrix">get_ind_time_matrix</a>()</code>,
<code><a href="#topic+santaR_CBand">santaR_CBand</a>()</code>,
<code><a href="#topic+santaR_auto_fit">santaR_auto_fit</a>()</code>,
<code><a href="#topic+santaR_fit">santaR_fit</a>()</code>,
<code><a href="#topic+santaR_plot">santaR_plot</a>()</code>,
<code><a href="#topic+santaR_pvalue_dist">santaR_pvalue_dist</a>()</code>,
<code><a href="#topic+santaR_pvalue_fit">santaR_pvalue_fit</a>()</code>,
<code><a href="#topic+santaR_start_GUI">santaR_start_GUI</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## 2 variables, 56 measurements, 8 subjects, 7 unique time-points
## Default parameter values decreased to ensure an execution &lt; 2 seconds
inputData     &lt;- acuteInflammation$data[,1:2]
ind           &lt;- acuteInflammation$meta$ind
time          &lt;- acuteInflammation$meta$time
group         &lt;- acuteInflammation$meta$group
SANTAObjList  &lt;- santaR_auto_fit(inputData, ind, time, group, df=5, ncores=0, CBand=TRUE,
                                pval.dist=TRUE, nBoot=100, nPerm=100)
# Input data generated: 0.02 secs
# Spline fitted: 0.03 secs
# ConfBands done: 0.53 secs
# p-val dist done: 0.79 secs
# total time: 1.37 secs
result &lt;- santaR_auto_summary(SANTAObjList)
print(result)
# $pval.all
#              dist dist_upper  dist_lower     curveCorr    dist_BH
# var_1 0.03960396 0.09783202 0.015439223 -0.2429725352 0.03960396
# var_2 0.00990099 0.05432519 0.001737742  0.0006572238 0.01980198
#
# $pval.summary
#       Test Inf 0.05 Inf 0.01 Inf 0.001
# 1    dist        2        1         0
# 2 dist_BH        2        0         0

</code></pre>

<hr>
<h2 id='santaR_CBand'>Compute Group Mean Curve Confidence Bands</h2><span id='topic+santaR_CBand'></span>

<h3>Description</h3>

<p>Generate bootstrapped group mean curve Confidence Bands, by resampling of individual curves with replacement. Returns a <em>SANTAObj</em> with added Confidence Bands.
</p>

<ul>
<li><p> Resampling whole data curves assumes less of the data than resampling of residuals.
</p>
</li>
<li><p> The resampled distribution is of same size as the original distribution (same number of individuals in each group as in the input data).
</p>
</li>
<li><p> The degree of freedom for the estimator is identical to the one employed for curve fitting in <code><a href="#topic+santaR_fit">santaR_fit</a></code>.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>santaR_CBand(SANTAObj, nBoot = 1000, alpha = 0.05, subsampling = 250)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="santaR_CBand_+3A_santaobj">SANTAObj</code></td>
<td>
<p>A fitted <em>SANTAObj</em> as generated by <code><a href="#topic+santaR_fit">santaR_fit</a></code>.</p>
</td></tr>
<tr><td><code id="santaR_CBand_+3A_nboot">nBoot</code></td>
<td>
<p>(int) Number of bootstrapping rounds. Default 1000.</p>
</td></tr>
<tr><td><code id="santaR_CBand_+3A_alpha">alpha</code></td>
<td>
<p>(float) Confidence <em>(0.05 for 95% Confidence Bands)</em>. Default 0.05.</p>
</td></tr>
<tr><td><code id="santaR_CBand_+3A_subsampling">subsampling</code></td>
<td>
<p>(int) Number of points to sample in the time range (for the estimator and Confidence Bands). Default is 250.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <em>SANTAObj</em> with added Confidence Bands for each group.
</p>


<h3>See Also</h3>

<p>Other Analysis: 
<code><a href="#topic+get_grouping">get_grouping</a>()</code>,
<code><a href="#topic+get_ind_time_matrix">get_ind_time_matrix</a>()</code>,
<code><a href="#topic+santaR_auto_fit">santaR_auto_fit</a>()</code>,
<code><a href="#topic+santaR_auto_summary">santaR_auto_summary</a>()</code>,
<code><a href="#topic+santaR_fit">santaR_fit</a>()</code>,
<code><a href="#topic+santaR_plot">santaR_plot</a>()</code>,
<code><a href="#topic+santaR_pvalue_dist">santaR_pvalue_dist</a>()</code>,
<code><a href="#topic+santaR_pvalue_fit">santaR_pvalue_fit</a>()</code>,
<code><a href="#topic+santaR_start_GUI">santaR_start_GUI</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## 56 measurements, 8 subjects, 7 unique time-points
## Default parameter values decreased to ensure an execution &lt; 2 seconds
Yi          &lt;- acuteInflammation$data$var_3
ind         &lt;- acuteInflammation$meta$ind
time        &lt;- acuteInflammation$meta$time
group       &lt;- acuteInflammation$meta$group
grouping    &lt;- get_grouping(ind, group)
inputMatrix &lt;- get_ind_time_matrix(Yi, ind, time)
SANTAObj    &lt;- santaR_fit(inputMatrix, df=5, grouping=grouping, verbose=TRUE)
SANTAObj    &lt;- santaR_CBand(SANTAObj, nBoot=100)

</code></pre>

<hr>
<h2 id='santaR_fit'>Generate a SANTAObj for a variable</h2><span id='topic+santaR_fit'></span>

<h3>Description</h3>

<p>Generate a <em>SANTAObj</em> containing all the splines model for individual and group time evolutions. Once all the splines representing individual and group evolutions are fitted, all time-points are back-projected (projected) and employed in subsequent analysis in place of the input measurements (functional approach). A grouping can be provided to separate individuals and compare trajectories: any number of groups can be provided, but comparision of group trajectories can only be executed between 2 groups.
</p>

<ul>
<li><p> Individual trajectories with less than 4 time-points are rejected due to constraints on <code><a href="stats.html#topic+smooth.spline">smooth.spline</a></code> fitting <em>(number of time-points &lt; 4)</em>.
</p>
</li>
<li><p> Individual trajectories with less time-points than <em>df</em> are rejected due to constraints on <code><a href="stats.html#topic+smooth.spline">smooth.spline</a></code> fitting <em>(number of time-points &lt; df)</em>.
</p>
</li>
<li><p> Rejected individual trajectories are not taken into account for mean curves calculations.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>santaR_fit(inputMatrix, df, grouping = NA, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="santaR_fit_+3A_inputmatrix">inputMatrix</code></td>
<td>
<p><code>data.frame</code> of measurements for each IND x TIME as generated by <code><a href="#topic+get_ind_time_matrix">get_ind_time_matrix</a></code>. Rows are unique Individual IDs and columns unique measurement Time. Pairs of (IND,TIME) without a measurement are left as NA.</p>
</td></tr>
<tr><td><code id="santaR_fit_+3A_df">df</code></td>
<td>
<p>(float) Degree of freedom to employ for fitting the <code><a href="stats.html#topic+smooth.spline">smooth.spline</a></code></p>
</td></tr>
<tr><td><code id="santaR_fit_+3A_grouping">grouping</code></td>
<td>
<p>NA or a <code>data.frame</code> with 2 columns (ind and group) listing as rows each unique Individual ID and the corresponding group membership, as generated by <code><a href="#topic+get_grouping">get_grouping</a></code>. Default is NA for no groups.</p>
</td></tr>
<tr><td><code id="santaR_fit_+3A_verbose">verbose</code></td>
<td>
<p>(bool) If TRUE output the progress of fitting. Default is TRUE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <em>SANTAObj</em> containing all the spline models with individual and group time evolutions, for further analysis.
</p>


<h4>Details:</h4>

<p>The returned <em>SANTAObj</em> is structured as follow:
</p>

<table>
<tr>
 <td style="text-align: left;">
    SANTAObj </td><td style="text-align: left;"> santaR object for futher analysis</td>
</tr>
<tr>
 <td style="text-align: left;">
     </td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;">
    SANTAObj$properties$df </td><td style="text-align: left;"> input degree of freedom</td>
</tr>
<tr>
 <td style="text-align: left;">
    SANTAObj$properties$CBand$status </td><td style="text-align: left;"> Confidence Bands for group mean curve calculated <em>(TRUE or FALSE)</em></td>
</tr>
<tr>
 <td style="text-align: left;">
    SANTAObj$properties$CBand$nBoot </td><td style="text-align: left;"> parameter, number or bootstrap rounds for calculation of the group mean curve confidence bands</td>
</tr>
<tr>
 <td style="text-align: left;">
    SANTAObj$properties$CBand$alpha </td><td style="text-align: left;"> parameter, confidence of the group mean curve band</td>
</tr>
<tr>
 <td style="text-align: left;">
    SANTAObj$properties$pval.dist$status </td><td style="text-align: left;"> <em>p</em>-value distance calculated <em>(TRUE or FALSE)</em></td>
</tr>
<tr>
 <td style="text-align: left;">
    SANTAObj$properties$pval.dist$nPerm </td><td style="text-align: left;"> parameter, number of permutations for calculation of distance <em>p</em>-value</td>
</tr>
<tr>
 <td style="text-align: left;">
    SANTAObj$properties$pval.dist$alpha </td><td style="text-align: left;"> parameter, confidence on the bootstrapped <em>p</em>-value</td>
</tr>
<tr>
 <td style="text-align: left;">
    SANTAObj$properties$pval.fit$status </td><td style="text-align: left;"> <em>p</em>-value fitting calculated <em>(TRUE or FALSE)</em></td>
</tr>
<tr>
 <td style="text-align: left;">
    SANTAObj$properties$pval.fit$nPerm </td><td style="text-align: left;"> parameter, number of permutations for calculation of fitting <em>p</em>-value</td>
</tr>
<tr>
 <td style="text-align: left;">
    SANTAObj$properties$pval.fit$alpha </td><td style="text-align: left;"> parameter, confidence on the bootstrapped <em>p</em>-value</td>
</tr>
<tr>
 <td style="text-align: left;">
     </td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;">
    SANTAObj$general$inputData </td><td style="text-align: left;"> <em>inputMatrix</em></td>
</tr>
<tr>
 <td style="text-align: left;">
    SANTAObj$general$cleanData.in </td><td style="text-align: left;"> only kept individuals INPUT values <em>(equivalent to inputMatrix - rejected)</em></td>
</tr>
<tr>
 <td style="text-align: left;">
    SANTAObj$general$cleanData.pred </td><td style="text-align: left;"> only kept individuals PREDICTED values on Ind splines</td>
</tr>
<tr>
 <td style="text-align: left;">
    SANTAObj$general$grouping </td><td style="text-align: left;"> grouping vector given as input</td>
</tr>
<tr>
 <td style="text-align: left;">
    SANTAObj$general$meanCurve </td><td style="text-align: left;"> spline fit over all kept datapoint <em>(cleanData.pred)</em> | <code><a href="stats.html#topic+smooth.spline">smooth.spline</a></code> object</td>
</tr>
<tr>
 <td style="text-align: left;">
    SANTAObj$general$pval.curveCorr </td><td style="text-align: left;"> Pearson correlation coefficient between the two group curves, to detect highly correlated group shapes if required.</td>
</tr>
<tr>
 <td style="text-align: left;">
    SANTAObj$general$pval.dist </td><td style="text-align: left;"> <em>p</em>-value between groups based on distance between groupMeanCurves</td>
</tr>
<tr>
 <td style="text-align: left;">
    SANTAObj$general$pval.dist.l </td><td style="text-align: left;"> lower bound confidence interval on <em>p</em>-value</td>
</tr>
<tr>
 <td style="text-align: left;">
    SANTAObj$general$pval.dist.u </td><td style="text-align: left;"> upper bound confidence interval on <em>p</em>-value</td>
</tr>
<tr>
 <td style="text-align: left;">
    SANTAObj$general$pval.fit </td><td style="text-align: left;"> <em>p</em>-value between groups based on groupMeanCurves fitting</td>
</tr>
<tr>
 <td style="text-align: left;">
    SANTAObj$general$pval.fit.l </td><td style="text-align: left;"> lower bound confidence interval on <em>p</em>-value</td>
</tr>
<tr>
 <td style="text-align: left;">
    SANTAObj$general$pval.fit.u </td><td style="text-align: left;"> upper bound confidence interval on <em>p</em>-value</td>
</tr>
<tr>
 <td style="text-align: left;">
     </td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;">
    SANTAObj$groups </td><td style="text-align: left;"> list of group information</td>
</tr>
<tr>
 <td style="text-align: left;">
    SANTAObj$groups$rejectedInd </td><td style="text-align: left;"> list of rejected individual <em>(#tp &lt; 4 or df)</em> | data</td>
</tr>
<tr>
 <td style="text-align: left;">
    SANTAObj$groups$curveInd </td><td style="text-align: left;"> list of spline fit | <code><a href="stats.html#topic+smooth.spline">smooth.spline</a></code> object</td>
</tr>
<tr>
 <td style="text-align: left;">
    SANTAObj$groups$groupMeanCurve </td><td style="text-align: left;"> spline fit over groupData.pred | <code><a href="stats.html#topic+smooth.spline">smooth.spline</a></code> object</td>
</tr>
<tr>
 <td style="text-align: left;">
    SANTAObj$groups$point.in </td><td style="text-align: left;"> all group points INPUT values (x,y) [kept individuals]</td>
</tr>
<tr>
 <td style="text-align: left;">
    SANTAObj$groups$point.pred </td><td style="text-align: left;"> all group points PREDICTED values on Ind splines (x,y)</td>
</tr>
<tr>
 <td style="text-align: left;">
    SANTAObj$groups$groupData.in </td><td style="text-align: left;"> only individuals from this group INPUT value (IND x TIME)</td>
</tr>
<tr>
 <td style="text-align: left;">
    SANTAObj$groups$groupData.pred </td><td style="text-align: left;"> only individuals from this group PREDICTED values on Ind splines (x,y)
  </td>
</tr>

</table>




<h3>See Also</h3>

<p>Other Analysis: 
<code><a href="#topic+get_grouping">get_grouping</a>()</code>,
<code><a href="#topic+get_ind_time_matrix">get_ind_time_matrix</a>()</code>,
<code><a href="#topic+santaR_CBand">santaR_CBand</a>()</code>,
<code><a href="#topic+santaR_auto_fit">santaR_auto_fit</a>()</code>,
<code><a href="#topic+santaR_auto_summary">santaR_auto_summary</a>()</code>,
<code><a href="#topic+santaR_plot">santaR_plot</a>()</code>,
<code><a href="#topic+santaR_pvalue_dist">santaR_pvalue_dist</a>()</code>,
<code><a href="#topic+santaR_pvalue_fit">santaR_pvalue_fit</a>()</code>,
<code><a href="#topic+santaR_start_GUI">santaR_start_GUI</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## 56 measurements, 8 subjects, 7 unique time-points
Yi             &lt;- acuteInflammation$data$var_1
ind            &lt;- acuteInflammation$meta$ind
time           &lt;- acuteInflammation$meta$time
group          &lt;- acuteInflammation$meta$group
grouping       &lt;- get_grouping(ind, group)
inputMatrix    &lt;- get_ind_time_matrix(Yi, ind, time)
resultSANTAObj &lt;- santaR_fit(inputMatrix, df=5, grouping=grouping, verbose=TRUE)

</code></pre>

<hr>
<h2 id='santaR_plot'>Plot a SANTAObj</h2><span id='topic+santaR_plot'></span>

<h3>Description</h3>

<p>Plot a <em>SANTAObj</em> generated by <code><a href="#topic+santaR_fit">santaR_fit</a></code>. Returns a <code>ggplot2</code> <em>plotObject</em> that can be further modified using <code>ggplot2</code> grammar.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>santaR_plot(
  SANTAObj,
  title = "",
  legend = TRUE,
  showIndPoint = TRUE,
  showIndCurve = TRUE,
  showGroupMeanCurve = TRUE,
  showTotalMeanCurve = FALSE,
  showConfBand = TRUE,
  colorVect = NA,
  sampling = 250,
  xlab = "x",
  ylab = "y",
  shortInd = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="santaR_plot_+3A_santaobj">SANTAObj</code></td>
<td>
<p>A fitted <em>SANTAObj</em> as generated by <code><a href="#topic+santaR_fit">santaR_fit</a></code>.</p>
</td></tr>
<tr><td><code id="santaR_plot_+3A_title">title</code></td>
<td>
<p>(str) A plot title. The default title is empty.</p>
</td></tr>
<tr><td><code id="santaR_plot_+3A_legend">legend</code></td>
<td>
<p>(bool) If TRUE a legend panel is added to the right. Default is TRUE. <em>Note: the legend cannot be generated if only the Confidence Bands or the Total Mean Curve are plotted.</em></p>
</td></tr>
<tr><td><code id="santaR_plot_+3A_showindpoint">showIndPoint</code></td>
<td>
<p>(bool) If TRUE plot each input measurements (in group color). Default is TRUE.</p>
</td></tr>
<tr><td><code id="santaR_plot_+3A_showindcurve">showIndCurve</code></td>
<td>
<p>(bool) If TRUE plot each individual's curve (in group color). Default is TRUE.</p>
</td></tr>
<tr><td><code id="santaR_plot_+3A_showgroupmeancurve">showGroupMeanCurve</code></td>
<td>
<p>(bool) If TRUE plot the mean curve for each group (in group color). Default is TRUE.</p>
</td></tr>
<tr><td><code id="santaR_plot_+3A_showtotalmeancurve">showTotalMeanCurve</code></td>
<td>
<p>(bool) If TRUE plot the mean curve across all measurements and groups (in grey). Default is FALSE.</p>
</td></tr>
<tr><td><code id="santaR_plot_+3A_showconfband">showConfBand</code></td>
<td>
<p>If TRUE plot the confidence bands calculated with <code><a href="#topic+santaR_CBand">santaR_CBand</a></code>.</p>
</td></tr>
<tr><td><code id="santaR_plot_+3A_colorvect">colorVect</code></td>
<td>
<p>Vector of <code>ggplot2</code> colors. The number of colors must match the number of groups <em>(ex:<code>colorVect=c("deepskyblue","red")</code>)</em>.</p>
</td></tr>
<tr><td><code id="santaR_plot_+3A_sampling">sampling</code></td>
<td>
<p>(int) Number of data points to use when plotting each spline (sub-sampling). Default is 250.</p>
</td></tr>
<tr><td><code id="santaR_plot_+3A_xlab">xlab</code></td>
<td>
<p>(str) x-axis label. Default is 'x'.</p>
</td></tr>
<tr><td><code id="santaR_plot_+3A_ylab">ylab</code></td>
<td>
<p>(str) y-axis label. Default is 'y'.</p>
</td></tr>
<tr><td><code id="santaR_plot_+3A_shortind">shortInd</code></td>
<td>
<p>if TRUE individual trajectories are only plotted on the range on which they are defined. Default is FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>ggplot2</code> <em>plotObject</em>.
</p>


<h3>See Also</h3>

<p>Other Analysis: 
<code><a href="#topic+get_grouping">get_grouping</a>()</code>,
<code><a href="#topic+get_ind_time_matrix">get_ind_time_matrix</a>()</code>,
<code><a href="#topic+santaR_CBand">santaR_CBand</a>()</code>,
<code><a href="#topic+santaR_auto_fit">santaR_auto_fit</a>()</code>,
<code><a href="#topic+santaR_auto_summary">santaR_auto_summary</a>()</code>,
<code><a href="#topic+santaR_fit">santaR_fit</a>()</code>,
<code><a href="#topic+santaR_pvalue_dist">santaR_pvalue_dist</a>()</code>,
<code><a href="#topic+santaR_pvalue_fit">santaR_pvalue_fit</a>()</code>,
<code><a href="#topic+santaR_start_GUI">santaR_start_GUI</a>()</code>
</p>
<p>Other AutoProcess: 
<code><a href="#topic+santaR_auto_fit">santaR_auto_fit</a>()</code>,
<code><a href="#topic+santaR_auto_summary">santaR_auto_summary</a>()</code>,
<code><a href="#topic+santaR_start_GUI">santaR_start_GUI</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## 56 measurements, 8 subjects, 7 unique time-points
Yi          &lt;- acuteInflammation$data$var_3
ind         &lt;- acuteInflammation$meta$ind
time        &lt;- acuteInflammation$meta$time
group       &lt;- acuteInflammation$meta$group
grouping    &lt;- get_grouping(ind, group)
inputMatrix &lt;- get_ind_time_matrix(Yi, ind, time)
SANTAObj    &lt;- santaR_fit(inputMatrix, df=5, grouping=grouping, verbose=TRUE)
SANTAObj    &lt;- santaR_CBand(SANTAObj, nBoot=100)
p           &lt;- santaR_plot(SANTAObj, title='Example')
print(p)

</code></pre>

<hr>
<h2 id='santaR_pvalue_dist'>Evaluate difference in group trajectories based on the comparison of distance between group mean curves</h2><span id='topic+santaR_pvalue_dist'></span>

<h3>Description</h3>

<p>Evaluate the difference in group trajectories by executing a t-test based on the comparison of distance between group mean curves. Individual group membership is repeatedly randomly permuted to generate new random groups and group mean curves, then employed to compute a <em>Null</em> distribution of distance between goup mean curves. The distance between two group mean curves is defined as the area between both curves. The distance between the real group mean curves is then compared to this <em>Null</em> distribution and a <em>p</em>-value is computed.
</p>

<ul>
<li><p> The Pearson correlation coefficient between the two group mean curves is calculated to detect highly correlated group shapes if required.
</p>
</li>
<li><p> The <em>p</em>-value is calculated as <code>(b+1)/(nPerm+1)</code> as to not report a <em>p</em>-value=0 (which would give problem with FDR correction) and reduce type I error.
</p>
</li>
<li><p> The <em>p</em>-value will vary depending on the random sampling. Therefore a confidence interval can be constructed using Wilson's interval which presents good properties for small number of trials and probabilities close to 0 or 1.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>santaR_pvalue_dist(SANTAObj, nPerm = 1000, nStep = 5000, alpha = 0.05)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="santaR_pvalue_dist_+3A_santaobj">SANTAObj</code></td>
<td>
<p>A fitted <em>SANTAObj</em> as generated by <code><a href="#topic+santaR_fit">santaR_fit</a></code>.</p>
</td></tr>
<tr><td><code id="santaR_pvalue_dist_+3A_nperm">nPerm</code></td>
<td>
<p>(int) Number of permutations. Default 1000.</p>
</td></tr>
<tr><td><code id="santaR_pvalue_dist_+3A_nstep">nStep</code></td>
<td>
<p>(int) Number of steps employed for the calculation of the area between group mean curves. Default is 5000.</p>
</td></tr>
<tr><td><code id="santaR_pvalue_dist_+3A_alpha">alpha</code></td>
<td>
<p>(float) Confidence Interval on the permuted <em>p</em>-value <em>(0.05 for 95% Confidence Interval)</em>. Default 0.05.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <em>SANTAObj</em> with added <em>p</em>-value dist and confidence interval on the <em>p</em>-value.
</p>


<h3>See Also</h3>

<p>Comparison with constant model with <code><a href="#topic+santaR_pvalue_dist_within">santaR_pvalue_dist_within</a></code>
</p>
<p>Other Analysis: 
<code><a href="#topic+get_grouping">get_grouping</a>()</code>,
<code><a href="#topic+get_ind_time_matrix">get_ind_time_matrix</a>()</code>,
<code><a href="#topic+santaR_CBand">santaR_CBand</a>()</code>,
<code><a href="#topic+santaR_auto_fit">santaR_auto_fit</a>()</code>,
<code><a href="#topic+santaR_auto_summary">santaR_auto_summary</a>()</code>,
<code><a href="#topic+santaR_fit">santaR_fit</a>()</code>,
<code><a href="#topic+santaR_plot">santaR_plot</a>()</code>,
<code><a href="#topic+santaR_pvalue_fit">santaR_pvalue_fit</a>()</code>,
<code><a href="#topic+santaR_start_GUI">santaR_start_GUI</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## 56 measurements, 8 subjects, 7 unique time-points
## Default parameter values decreased to ensure an execution &lt; 2 seconds
Yi          &lt;- acuteInflammation$data$var_3
ind         &lt;- acuteInflammation$meta$ind
time        &lt;- acuteInflammation$meta$time
group       &lt;- acuteInflammation$meta$group
grouping    &lt;- get_grouping(ind, group)
inputMatrix &lt;- get_ind_time_matrix(Yi, ind, time)
SANTAObj    &lt;- santaR_fit(inputMatrix, df=5, grouping=grouping, verbose=TRUE)
SANTAObj    &lt;- santaR_pvalue_dist(SANTAObj, nPerm=100)

</code></pre>

<hr>
<h2 id='santaR_pvalue_dist_within'>Evaluate difference between a group mean curve and a constant model</h2><span id='topic+santaR_pvalue_dist_within'></span>

<h3>Description</h3>

<p>Execute a t-test based on the comparison of distance between a group mean curve and a constant linear model. Generate <em>n</em> constant linear model. The <em>Null</em> distribution is generated by permuting the <em>n</em> group individuals and the <em>n</em> constant trajectories. The real distance (area) between the group trajectory and the flat trajectory is compared to the <em>Null</em> distribution of distances, similarly to <code><a href="#topic+santaR_pvalue_dist">santaR_pvalue_dist</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>santaR_pvalue_dist_within(SANTAGroup, nPerm = 1000, nStep = 5000)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="santaR_pvalue_dist_within_+3A_santagroup">SANTAGroup</code></td>
<td>
<p>A fitted group extracted from a <em>SANTAObj</em> generated by <code><a href="#topic+santaR_fit">santaR_fit</a></code>.</p>
</td></tr>
<tr><td><code id="santaR_pvalue_dist_within_+3A_nperm">nPerm</code></td>
<td>
<p>(int) Number of permutations. Default 1000.</p>
</td></tr>
<tr><td><code id="santaR_pvalue_dist_within_+3A_nstep">nStep</code></td>
<td>
<p>(int) Number of steps employed for the calculation of the area between group mean curves. Default is 5000.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <em>p-value</em>
</p>


<h3>See Also</h3>

<p>Inter-group comparison with <code><a href="#topic+santaR_pvalue_dist">santaR_pvalue_dist</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## 56 measurements, 8 subjects, 7 unique time-points
## Default parameter values decreased to ensure an execution &lt; 2 seconds
Yi          &lt;- acuteInflammation$data$var_3
ind         &lt;- acuteInflammation$meta$ind
time        &lt;- acuteInflammation$meta$time
group       &lt;- acuteInflammation$meta$group
grouping    &lt;- get_grouping(ind, group)
inputMatrix &lt;- get_ind_time_matrix(Yi, ind, time)
SANTAObj    &lt;- santaR_fit(inputMatrix, df=5, grouping=grouping, verbose=TRUE)
SANTAGroup  &lt;- SANTAObj$groups[[2]]
#SANTAGroup &lt;- SANTAObj$groups$Group2
santaR_pvalue_dist_within(SANTAGroup, nPerm=500)
# ~0.00990099

</code></pre>

<hr>
<h2 id='santaR_pvalue_fit'>Evaluate difference in group trajectories based on the comparison of model fit (F-test) between one and two groups</h2><span id='topic+santaR_pvalue_fit'></span>

<h3>Description</h3>

<p>Evaluate the difference in group trajectories by executing a t-test based on the comparison of improvement in model fit <em>(F-test)</em> between fitting one group mean curve to all individuals and fitting two group mean curves. This between-class differential evolution test, evaluates whether fitting 2 group curves decreases the residuals compared to a single group mean curve. The statistic employed is defined as a quantification of evidence for differential evolution, with the larger the statistic the more differentially evolving the variable appears to be. Individual group membership is repeatedly randomly permuted to generate new random groups and group mean curves, then employed to compute a <em>Null</em> distribution of the statistic (improvement in model fit from one to two groups). The improvement in model fit for the real group membership is then compared to this <em>Null</em> distribution <em>(of no group difference)</em> and a <em>p</em>-value is computed. Adapted from <cite>Storey and al. 'Significance analysis of time course microarray experiments', PNAS, 2005 [1]</cite>.
</p>

<ul>
<li><p> The <em>p</em>-value is calculated as <code>(b+1)/(nPerm+1)</code> as to not report a <em>p</em>-value=0 (which would give problem with FDR correction) and reduce type I error.
</p>
</li>
<li><p> The <em>p</em>-value will vary depending on the random sampling. Therefore a confidence interval can be constructed using Wilson's interval which presents good properties for small number of trials and probabilities close to 0 or 1.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>santaR_pvalue_fit(SANTAObj, nPerm = 1000, alpha = 0.05)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="santaR_pvalue_fit_+3A_santaobj">SANTAObj</code></td>
<td>
<p>A fitted <em>SANTAObj</em> as generated by <code><a href="#topic+santaR_fit">santaR_fit</a></code>.</p>
</td></tr>
<tr><td><code id="santaR_pvalue_fit_+3A_nperm">nPerm</code></td>
<td>
<p>(int) Number of permutations. Default 1000.</p>
</td></tr>
<tr><td><code id="santaR_pvalue_fit_+3A_alpha">alpha</code></td>
<td>
<p>(float) Confidence Interval on the permuted <em>p</em>-value <em>(0.05 for 95% Confidence Interval)</em>. Default 0.05.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <em>SANTAObj</em> with added <em>p</em>-value fit and confidence interval on the <em>p</em>-value.
</p>


<h3>References</h3>

<p>[1] Storey, J. D., Xiao, W., Leek, J. T., Tompkins, R. G. &amp; Davis, R. W. Significance analysis of time course microarray experiments. <em>Proceedings of the National Academy of Sciences of the United States of America</em> <strong>102</strong>, 12837-42 (2005).
</p>


<h3>See Also</h3>

<p>Comparison with constant model with <code><a href="#topic+santaR_pvalue_fit_within">santaR_pvalue_fit_within</a></code>
</p>
<p>Other Analysis: 
<code><a href="#topic+get_grouping">get_grouping</a>()</code>,
<code><a href="#topic+get_ind_time_matrix">get_ind_time_matrix</a>()</code>,
<code><a href="#topic+santaR_CBand">santaR_CBand</a>()</code>,
<code><a href="#topic+santaR_auto_fit">santaR_auto_fit</a>()</code>,
<code><a href="#topic+santaR_auto_summary">santaR_auto_summary</a>()</code>,
<code><a href="#topic+santaR_fit">santaR_fit</a>()</code>,
<code><a href="#topic+santaR_plot">santaR_plot</a>()</code>,
<code><a href="#topic+santaR_pvalue_dist">santaR_pvalue_dist</a>()</code>,
<code><a href="#topic+santaR_start_GUI">santaR_start_GUI</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## 56 measurements, 8 subjects, 7 unique time-points
## Default parameter values decreased to ensure an execution &lt; 2 seconds
Yi          &lt;- acuteInflammation$data$var_3
ind         &lt;- acuteInflammation$meta$ind
time        &lt;- acuteInflammation$meta$time
group       &lt;- acuteInflammation$meta$group
grouping    &lt;- get_grouping(ind, group)
inputMatrix &lt;- get_ind_time_matrix(Yi, ind, time)
SANTAObj    &lt;- santaR_fit(inputMatrix, df=5, grouping=grouping, verbose=TRUE)
SANTAObj    &lt;- santaR_pvalue_fit(SANTAObj, nPerm=100)

</code></pre>

<hr>
<h2 id='santaR_pvalue_fit_within'>Evaluate difference between a group mean curve and a constant model using the comparison of model fit (F-test)</h2><span id='topic+santaR_pvalue_fit_within'></span>

<h3>Description</h3>

<p>Execute a t-test based on the comparison of improvement of model fit from a single group mean curve to the fit of both a group mean curve and a constant linear model. This statistic identifies within-class differential evolution, and test whether the population average time curve is flat or not. <em>n</em> constant linear model are generated to match the <em>n</em> individual trajetories. The <em>Null</em> distribution is generated by permuting the <em>n</em> group individuals and the <em>n</em> constant trajectories. The real improvement in model fit for the real group membership versus flat trajectories is then compared to the <em>Null</em> distribution of model fit improvement, similarly to <code><a href="#topic+santaR_pvalue_fit">santaR_pvalue_fit</a></code>. Adapted from <cite>Storey and al. 'Significance analysis of time course microarray experiments', PNAS, 2005 [1]</cite>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>santaR_pvalue_fit_within(SANTAGroup, nPerm = 1000)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="santaR_pvalue_fit_within_+3A_santagroup">SANTAGroup</code></td>
<td>
<p>A fitted group extracted from a <em>SANTAObj</em> generated by <code><a href="#topic+santaR_fit">santaR_fit</a></code>.</p>
</td></tr>
<tr><td><code id="santaR_pvalue_fit_within_+3A_nperm">nPerm</code></td>
<td>
<p>(int) Number of permutations. Default 1000.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <em>p-value</em>
</p>


<h3>References</h3>

<p>[1] Storey, J. D., Xiao, W., Leek, J. T., Tompkins, R. G. &amp; Davis, R. W. Significance analysis of time course microarray experiments. <em>Proceedings of the National Academy of Sciences of the United States of America</em> <strong>102</strong>, 12837-42 (2005).
</p>


<h3>See Also</h3>

<p>Inter-group comparison with <code><a href="#topic+santaR_pvalue_fit">santaR_pvalue_fit</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## 56 measurements, 8 subjects, 7 unique time-points
## Default parameter values decreased to ensure an execution &lt; 2 seconds
Yi          &lt;- acuteInflammation$data$var_3
ind         &lt;- acuteInflammation$meta$ind
time        &lt;- acuteInflammation$meta$time
group       &lt;- acuteInflammation$meta$group
grouping    &lt;- get_grouping(ind, group)
inputMatrix &lt;- get_ind_time_matrix(Yi, ind, time)
SANTAObj    &lt;- santaR_fit(inputMatrix, df=5, grouping=grouping, verbose=TRUE)
SANTAGroup  &lt;- SANTAObj$groups[[1]]
#SANTAGroup &lt;- SANTAObj$groups$Group1
santaR_pvalue_fit_within(SANTAGroup, nPerm=500)
# ~0.6726747

</code></pre>

<hr>
<h2 id='santaR_start_GUI'>santaR Graphical User Interface</h2><span id='topic+santaR_start_GUI'></span>

<h3>Description</h3>

<p>santaR Graphical User Interface (GUI) implements all the functions for short asynchronous time-series analysis. To exit press <code>ESC</code> in the command line. Once started, the GUI presents 4 tabs corresponding to the main steps of analysis: <em>Import</em>, <em>DF search</em>, <em>Analysis</em> and <em>Export</em>.
</p>

<ul>
<li><p> The <em>Import</em> tab manages input data in comma separated value (<em>csv</em>) format or as an <em>RData</em> file containing a <code>SANTAObj</code> previously generated with <span class="pkg">santaR</span>. Once data is imported the <em>DF search</em> and <em>Analysis</em> tabs become available.
</p>
</li>
<li> <p><em>DF search</em> implements the tools for the selection of an optimal number of degrees of freedom (<code>df</code>).
</p>
</li>
<li><p> With the data imported and a pertinent <code>df</code> selected, <em>Analysis</em> regroups the interface to visualise and identify variables significantly altered over time. All options present in the command line version of <span class="pkg">santaR</span> are available, with the added possibility to modify the class labelling of each subject (<em>group</em>). A plotting interface enables the interactive visualisation of the raw data points, individual trajectories, group mean curves and confidence bands for all variables, which subsequently can be saved. Finally, if inter-group differential trajectories have been characterised, all significance testing results (with correction for multiple testing) are presented in interactive tables.
</p>
</li>
<li><p> The <em>Export</em> tab manages the saving of results and automated reporting. Fitted data is saved as a <code>SANTAObj</code>, which contains all inputs and outputs, and can be downloaded as an <em>RData</em> file for future analysis, or reproduction of results. <em>csv</em> files containing significance testing results can also be generated and summary plot for each significantly altered variable saved for rapid evaluation.
</p>
</li></ul>

<p><span class="pkg">santaR</span>'s command line procedure is the most efficient approach for very high number of variables due to the added level of automation. However the GUI can help understand the use of the methodology, select the best parameters on a subset of the data, or to visually explore the results.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>santaR_start_GUI(browser = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="santaR_start_GUI_+3A_browser">browser</code></td>
<td>
<p>If TRUE open the graphical user interface in a web browser instead of a R window. Default is TRUE</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None, start GUI. To exit press <code>ESC</code> in the command line.
</p>


<h3>See Also</h3>

<p>Other AutoProcess: 
<code><a href="#topic+santaR_auto_fit">santaR_auto_fit</a>()</code>,
<code><a href="#topic+santaR_auto_summary">santaR_auto_summary</a>()</code>,
<code><a href="#topic+santaR_plot">santaR_plot</a>()</code>
</p>
<p>Other Analysis: 
<code><a href="#topic+get_grouping">get_grouping</a>()</code>,
<code><a href="#topic+get_ind_time_matrix">get_ind_time_matrix</a>()</code>,
<code><a href="#topic+santaR_CBand">santaR_CBand</a>()</code>,
<code><a href="#topic+santaR_auto_fit">santaR_auto_fit</a>()</code>,
<code><a href="#topic+santaR_auto_summary">santaR_auto_summary</a>()</code>,
<code><a href="#topic+santaR_fit">santaR_fit</a>()</code>,
<code><a href="#topic+santaR_plot">santaR_plot</a>()</code>,
<code><a href="#topic+santaR_pvalue_dist">santaR_pvalue_dist</a>()</code>,
<code><a href="#topic+santaR_pvalue_fit">santaR_pvalue_fit</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## Start graphical interface, press 'ESC' in the command line to stop.
santaR_start_GUI()

## End(Not run)

</code></pre>

<hr>
<h2 id='scaling_mean'>Mean scaling of each column</h2><span id='topic+scaling_mean'></span>

<h3>Description</h3>

<p>Scale each variable (column) by the mean. Mean-scaling applied as (value - mean) / mean.
As <code><a href="#topic+scaling_UV">scaling_UV</a></code> might give too much importance to flat trajectories due to the division by the standard deviation, by dividing by the mean, high intensity values will have a lower influence and the low intensity will be boosted.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scaling_mean(inputMat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scaling_mean_+3A_inputmat">inputMat</code></td>
<td>
<p>(Observation x Variable) <code>data.frame</code> of measurements, with observations as rows and different variables as columns.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Matrix of measurements mean-scaled columnwise.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
inputMat &lt;- data.frame(matrix(c(1,4,7, 8,4,0, 3,6,9), nrow=3))
scaling_mean(inputMat)
#          X1 X2  X3
# [1,] -0.75  1 -0.5
# [2,]  0.00  0  0.0
# [3,]  0.75 -1  0.5

## End(Not run)
</code></pre>

<hr>
<h2 id='scaling_UV'>Unit-Variance scaling of each column</h2><span id='topic+scaling_UV'></span>

<h3>Description</h3>

<p>Unit-Variance (UV) scale each variable (column). UV-scaling applied as (value - mean) / stdev.
Unit-Variance Scaling or Autoscaling, is commonly applied and uses the standard deviation as the scaling factor. After autoscaling, all metabolites have a standard deviation of one and therefore the data is analyzed on the basis of correlations instead of covariances.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scaling_UV(inputMat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scaling_UV_+3A_inputmat">inputMat</code></td>
<td>
<p>(Observation x Variable) <code>data.frame</code> of measurements, with observations as rows and different variables as columns.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Matrix of measurements UV-scaled columnwise.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
inputMat &lt;- data.frame(matrix(c(1,4,7, 8,4,0, 3,6,9), nrow=3))
scaling_UV(inputMat)
#       X1 X2 X3
# [1,] -1  1 -1
# [2,]  0  0  0
# [3,]  1 -1  1

## End(Not run)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
