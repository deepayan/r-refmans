<!DOCTYPE html><html lang="en-US"><head><title>Help for package misha</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {misha}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#misha-package'><p>Toolkit for analysis of genomic data</p></a></li>
<li><a href='#.misha'><p>An environment for storing the package global variables</p></a></li>
<li><a href='#+25+26gt+3B+25'><p>Pipe operator</p></a></li>
<li><a href='#gbins.quantiles'><p>Calculates quantiles of a track expression for bins</p></a></li>
<li><a href='#gbins.summary'><p>Calculates summary statistics of a track expression for bins</p></a></li>
<li><a href='#gcis_decay'><p>Calculates distribution of contact distances</p></a></li>
<li><a href='#gcluster.run'><p>Runs R commands on a cluster</p></a></li>
<li><a href='#gcompute_strands_autocorr'><p>Computes auto-correlation between the strands for a file of mapped sequences</p></a></li>
<li><a href='#gdb.create'><p>Creates a new Genomic Database</p></a></li>
<li><a href='#gdb.create_genome'><p>Create and Load a Genome Database</p></a></li>
<li><a href='#gdb.get_readonly_attrs'><p>Returns a list of read-only track attributes</p></a></li>
<li><a href='#gdb.reload'><p>Reloads database from the disk</p></a></li>
<li><a href='#gdb.set_readonly_attrs'><p>Sets read-only track attributes</p></a></li>
<li><a href='#gdir.cd'><p>Changes current working directory in Genomic Database</p></a></li>
<li><a href='#gdir.create'><p>Creates a new directory in Genomic Database</p></a></li>
<li><a href='#gdir.cwd'><p>Returns the current working directory in Genomic Database</p></a></li>
<li><a href='#gdir.rm'><p>Deletes a directory from Genomic Database</p></a></li>
<li><a href='#gdist'><p>Calculates distribution of track expressions</p></a></li>
<li><a href='#gextract'><p>Returns evaluated track expression</p></a></li>
<li><a href='#gintervals'><p>Creates a set of 1D intervals</p></a></li>
<li><a href='#gintervals.2d'><p>Creates a set of 2D intervals</p></a></li>
<li><a href='#gintervals.2d.all'><p>Returns 2D intervals that cover the whole genome</p></a></li>
<li><a href='#gintervals.2d.band_intersect'><p>Intersects two-dimensional intervals with a band</p></a></li>
<li><a href='#gintervals.all'><p>Returns 1D intervals that cover the whole genome</p></a></li>
<li><a href='#gintervals.canonic'><p>Converts intervals to canonic form</p></a></li>
<li><a href='#gintervals.chrom_sizes'><p>Returns number of intervals per chromosome</p></a></li>
<li><a href='#gintervals.diff'><p>Calculates difference of two intervals sets</p></a></li>
<li><a href='#gintervals.exists'><p>Tests for a named intervals set existence</p></a></li>
<li><a href='#gintervals.force_range'><p>Limits intervals to chromosomal range</p></a></li>
<li><a href='#gintervals.import_genes'><p>Imports genes and annotations from files</p></a></li>
<li><a href='#gintervals.intersect'><p>Calculates an intersection of two sets of intervals</p></a></li>
<li><a href='#gintervals.is.bigset'><p>Tests for big intervals set</p></a></li>
<li><a href='#gintervals.liftover'><p>Converts intervals from another assembly</p></a></li>
<li><a href='#gintervals.load'><p>Loads a named intervals set</p></a></li>
<li><a href='#gintervals.load_chain'><p>Loads assembly conversion table from a chain file</p></a></li>
<li><a href='#gintervals.ls'><p>Returns a list of named intervals sets</p></a></li>
<li><a href='#gintervals.mapply'><p>Applies a function to values of track expressions</p></a></li>
<li><a href='#gintervals.neighbors'><p>Finds neighbors between two sets of intervals</p></a></li>
<li><a href='#gintervals.quantiles'><p>Calculates quantiles of a track expression for intervals</p></a></li>
<li><a href='#gintervals.rbind'><p>Combines several sets of intervals</p></a></li>
<li><a href='#gintervals.rm'><p>Deletes a named intervals set</p></a></li>
<li><a href='#gintervals.save'><p>Creates a named intervals set</p></a></li>
<li><a href='#gintervals.summary'><p>Calculates summary statistics of track expression for intervals</p></a></li>
<li><a href='#gintervals.union'><p>Calculates a union of two sets of intervals</p></a></li>
<li><a href='#gintervals.update'><p>Updates a named intervals set</p></a></li>
<li><a href='#giterator.cartesian_grid'><p>Creates a cartesian-grid iterator</p></a></li>
<li><a href='#giterator.intervals'><p>Returns iterator intervals</p></a></li>
<li><a href='#glookup'><p>Returns values from a lookup table based on track expression</p></a></li>
<li><a href='#gpartition'><p>Partitions the values of track expression</p></a></li>
<li><a href='#gquantiles'><p>Calculates quantiles of a track expression</p></a></li>
<li><a href='#grevcomp'><p>Get reverse complement of DNA sequence</p></a></li>
<li><a href='#gsample'><p>Returns samples from the values of track expression</p></a></li>
<li><a href='#gscreen'><p>Finds intervals that match track expression</p></a></li>
<li><a href='#gsegment'><p>Divides track expression into segments</p></a></li>
<li><a href='#gseq.extract'><p>Returns DNA sequences</p></a></li>
<li><a href='#gsetroot'><p>Initializes connection with Genomic Database</p></a></li>
<li><a href='#gsummary'><p>Calculates summary statistics of track expression</p></a></li>
<li><a href='#gtrack.2d.create'><p>Creates a 'Rectangles' track from intervals and values</p></a></li>
<li><a href='#gtrack.2d.import'><p>Creates a 2D track from tab-delimited file</p></a></li>
<li><a href='#gtrack.2d.import_contacts'><p>Creates a track from a file of inter-genomic contacts</p></a></li>
<li><a href='#gtrack.array.extract'><p>Returns values from 'Array' track</p></a></li>
<li><a href='#gtrack.array.get_colnames'><p>Returns column names of array track</p></a></li>
<li><a href='#gtrack.array.import'><p>Creates an array track from array tracks or files</p></a></li>
<li><a href='#gtrack.array.set_colnames'><p>Sets column names of array track</p></a></li>
<li><a href='#gtrack.attr.export'><p>Returns track attributes values</p></a></li>
<li><a href='#gtrack.attr.get'><p>Returns value of a track attribute</p></a></li>
<li><a href='#gtrack.attr.import'><p>Imports track attributes values</p></a></li>
<li><a href='#gtrack.attr.set'><p>Assigns value to a track attribute</p></a></li>
<li><a href='#gtrack.convert'><p>Converts a track to the most current format</p></a></li>
<li><a href='#gtrack.create'><p>Creates a track from a track expression</p></a></li>
<li><a href='#gtrack.create_dirs'><p>Create directories needed for track creation</p></a></li>
<li><a href='#gtrack.create_pwm_energy'><p>Creates a new track from PSSM energy function</p></a></li>
<li><a href='#gtrack.create_sparse'><p>Creates a 'Sparse' track from intervals and values</p></a></li>
<li><a href='#gtrack.exists'><p>Tests for a track existence</p></a></li>
<li><a href='#gtrack.import'><p>Creates a track from WIG / BigWig / BedGraph / tab-delimited file</p></a></li>
<li><a href='#gtrack.import_mappedseq'><p>Creates a track from a file of mapped sequences</p></a></li>
<li><a href='#gtrack.import_set'><p>Creates one or more tracks from multiple WIG / BigWig / BedGraph /</p>
tab-delimited files on disk or FTP</a></li>
<li><a href='#gtrack.info'><p>Returns information about a track</p></a></li>
<li><a href='#gtrack.liftover'><p>Imports a track from another assembly</p></a></li>
<li><a href='#gtrack.lookup'><p>Creates a new track from a lookup table based on track expression</p></a></li>
<li><a href='#gtrack.ls'><p>Returns a list of track names</p></a></li>
<li><a href='#gtrack.modify'><p>Modifies track contents</p></a></li>
<li><a href='#gtrack.rm'><p>Deletes a track</p></a></li>
<li><a href='#gtrack.smooth'><p>Creates a new track from smoothed values of track expression</p></a></li>
<li><a href='#gtrack.var.get'><p>Returns value of a track variable</p></a></li>
<li><a href='#gtrack.var.ls'><p>Returns a list of track variables for a track</p></a></li>
<li><a href='#gtrack.var.rm'><p>Deletes a track variable</p></a></li>
<li><a href='#gtrack.var.set'><p>Assigns value to a track variable</p></a></li>
<li><a href='#gvtrack.array.slice'><p>Defines rules for a single value calculation of a virtual 'Array' track</p></a></li>
<li><a href='#gvtrack.create'><p>Creates a new virtual track</p></a></li>
<li><a href='#gvtrack.info'><p>Returns the definition of a virtual track</p></a></li>
<li><a href='#gvtrack.iterator'><p>Defines modification rules for a one-dimensional iterator in a virtual track</p></a></li>
<li><a href='#gvtrack.iterator.2d'><p>Defines modification rules for a two-dimensional iterator in a virtual track</p></a></li>
<li><a href='#gvtrack.ls'><p>Returns a list of virtual track names</p></a></li>
<li><a href='#gvtrack.rm'><p>Deletes a virtual track</p></a></li>
<li><a href='#gwget'><p>Downloads files from FTP server</p></a></li>
<li><a href='#gwilcox'><p>Calculates Wilcoxon test on sliding windows over track expression</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Toolkit for Analysis of Genomic Data</td>
</tr>
<tr>
<td>Version:</td>
<td>4.3.6</td>
</tr>
<tr>
<td>Description:</td>
<td>A toolkit for analysis of genomic data. The 'misha' package
    implements an efficient data structure for storing genomic data, and
    provides a set of functions for data extraction, manipulation and
    analysis. Some of the 2D genome algorithms were described in Yaffe and Tanay
    (2011) &lt;<a href="https://doi.org/10.1038%2Fng.947">doi:10.1038/ng.947</a>&gt;. </td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://tanaylab.github.io/misha/">https://tanaylab.github.io/misha/</a>,
<a href="https://github.com/tanaylab/misha">https://github.com/tanaylab/misha</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/tanaylab/misha/issues">https://github.com/tanaylab/misha/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>magrittr, curl, utils</td>
</tr>
<tr>
<td>Suggests:</td>
<td>dplyr, glue, knitr, readr, rmarkdown, spelling, stats,
stringr, testthat (&ge; 3.0.0), tibble, withr</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>C++14</td>
</tr>
<tr>
<td>OS_type:</td>
<td>unix</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-02-28 12:13:50 UTC; aviezerl</td>
</tr>
<tr>
<td>Author:</td>
<td>Misha Hoichman [aut],
  Aviezer Lifshitz [aut, cre],
  Eitan Yaffe [aut],
  Amos Tanay [aut],
  Weizmann Institute of Science [cph]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Aviezer Lifshitz &lt;aviezer.lifshitz@weizmann.ac.il&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-03-06 14:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='misha-package'>Toolkit for analysis of genomic data</h2><span id='topic+misha-package'></span><span id='topic+misha'></span>

<h3>Description</h3>

<p>'misha' package is intended to help users to efficiently analyze genomic
data achieved from various experiments.
</p>


<h3>Details</h3>

<p>For a complete list of help resources, use <code>library(help = "misha")</code>.
</p>
<p>The following options are available for the package. Use 'options' function
to alter the value of the options.
</p>

<table>
<tr>
 <td style="text-align: left;"> NAME </td><td style="text-align: left;"> DEFAULT </td><td style="text-align: left;"> DESCRIPTION </td>
</tr>
<tr>
 <td style="text-align: left;"> gmax.data.size </td><td style="text-align: left;">
10000000 </td><td style="text-align: left;"> Maximal number of data (intervals, ...) in large data sets
stored </td>
</tr>
<tr>
 <td style="text-align: left;"> </td><td style="text-align: left;"> </td><td style="text-align: left;"> in memory. Prevents excessive memory usage by various
functions </td>
</tr>
<tr>
 <td style="text-align: left;"> </td><td style="text-align: left;"> </td><td style="text-align: left;"> such as 'gextract', 'gscreen', etc. </td>
</tr>
<tr>
 <td style="text-align: left;">
gbig.intervals.size </td><td style="text-align: left;"> 1000000 </td><td style="text-align: left;"> Minimal number of intervals in a big
intervals set format </td>
</tr>
<tr>
 <td style="text-align: left;"> gmax.mem.usage </td><td style="text-align: left;"> 10000000 </td><td style="text-align: left;"> Maximal memory
consumption of all child processes in KB before the limiting algorithm is
invoked. </td>
</tr>
<tr>
 <td style="text-align: left;"> gmax.processes </td><td style="text-align: left;"> 16 </td><td style="text-align: left;"> Maximal number of processes for
multitasking </td>
</tr>
<tr>
 <td style="text-align: left;"> gmax.processes2core </td><td style="text-align: left;"> 2 </td><td style="text-align: left;"> Maximal number of processes
per CPU core for multitasking </td>
</tr>
<tr>
 <td style="text-align: left;"> gmin.scope4process </td><td style="text-align: left;"> 10000 </td><td style="text-align: left;"> Minimal
scope range (for 2D: surface) assigned to a </td>
</tr>
<tr>
 <td style="text-align: left;"> </td><td style="text-align: left;"> </td><td style="text-align: left;"> process in
multitasking mode. </td>
</tr>
<tr>
 <td style="text-align: left;"> gbuf.size </td><td style="text-align: left;"> 1000 </td><td style="text-align: left;"> Size of track expression
values buffer. </td>
</tr>
<tr>
 <td style="text-align: left;"> gtrack.chunk.size </td><td style="text-align: left;"> 100000 </td><td style="text-align: left;"> Chunk size in bytes of
a 2D track. If '0' chunk size is unlimited. </td>
</tr>
<tr>
 <td style="text-align: left;"> gtrack.num.chunks </td><td style="text-align: left;"> 0
</td><td style="text-align: left;"> Maximal number of 2D track chunks simultaneously stored in </td>
</tr>
<tr>
 <td style="text-align: left;"> </td><td style="text-align: left;">
</td><td style="text-align: left;"> memory.</td>
</tr>
<tr>
 <td style="text-align: left;"> </td>
</tr>

</table>

<p>More information about the options can be found in 'User manual' of the
package.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Aviezer Lifshitz <a href="mailto:aviezer.lifshitz@weizmann.ac.il">aviezer.lifshitz@weizmann.ac.il</a>
</p>
<p>Authors:
</p>

<ul>
<li><p> Misha Hoichman <a href="mailto:misha@hoichman.com">misha@hoichman.com</a>
</p>
</li>
<li><p> Eitan Yaffe <a href="mailto:eitan.yaffe@weizmann.ac.il">eitan.yaffe@weizmann.ac.il</a>
</p>
</li>
<li><p> Amos Tanay <a href="mailto:amos.tanay@weizmann.ac.il">amos.tanay@weizmann.ac.il</a>
</p>
</li></ul>

<p>Other contributors:
</p>

<ul>
<li><p> Weizmann Institute of Science [copyright holder]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://tanaylab.github.io/misha/">https://tanaylab.github.io/misha/</a>
</p>
</li>
<li> <p><a href="https://github.com/tanaylab/misha">https://github.com/tanaylab/misha</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/tanaylab/misha/issues">https://github.com/tanaylab/misha/issues</a>
</p>
</li></ul>


<hr>
<h2 id='.misha'>An environment for storing the package global variables</h2><span id='topic+.misha'></span>

<h3>Description</h3>

<p>An environment for storing the package global variables
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.misha
</code></pre>


<h3>Format</h3>

<p>An object of class <code>environment</code> of length 8.
</p>

<hr>
<h2 id='+25+26gt+3B+25'>Pipe operator</h2><span id='topic++25+3E+25'></span>

<h3>Description</h3>

<p>See <code>magrittr::<a href="magrittr.html#topic+pipe">%&gt;%</a></code> for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lhs %&gt;% rhs
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="+2B25+2B26gt+2B3B+2B25_+3A_lhs">lhs</code></td>
<td>
<p>A value or the magrittr placeholder.</p>
</td></tr>
<tr><td><code id="+2B25+2B26gt+2B3B+2B25_+3A_rhs">rhs</code></td>
<td>
<p>A function call using the magrittr semantics.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The result of calling 'rhs(lhs)'.
</p>

<hr>
<h2 id='gbins.quantiles'>Calculates quantiles of a track expression for bins</h2><span id='topic+gbins.quantiles'></span>

<h3>Description</h3>

<p>Calculates quantiles of a track expression for bins.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gbins.quantiles(
  ...,
  expr = NULL,
  percentiles = 0.5,
  intervals = get("ALLGENOME", envir = .misha),
  include.lowest = FALSE,
  iterator = NULL,
  band = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gbins.quantiles_+3A_...">...</code></td>
<td>
<p>pairs of track expressions ('bin_expr') that determines the bins and breaks that define the bins. See <code><a href="#topic+gdist">gdist</a></code>.</p>
</td></tr>
<tr><td><code id="gbins.quantiles_+3A_expr">expr</code></td>
<td>
<p>track expression for which quantiles are calculated</p>
</td></tr>
<tr><td><code id="gbins.quantiles_+3A_percentiles">percentiles</code></td>
<td>
<p>an array of percentiles of quantiles in [0, 1] range</p>
</td></tr>
<tr><td><code id="gbins.quantiles_+3A_intervals">intervals</code></td>
<td>
<p>genomic scope for which the function is applied.</p>
</td></tr>
<tr><td><code id="gbins.quantiles_+3A_include.lowest">include.lowest</code></td>
<td>
<p>if 'TRUE', the lowest value of the range determined by
breaks is included</p>
</td></tr>
<tr><td><code id="gbins.quantiles_+3A_iterator">iterator</code></td>
<td>
<p>track expression iterator. If 'NULL' iterator is determined
implicitly based on track expressions.</p>
</td></tr>
<tr><td><code id="gbins.quantiles_+3A_band">band</code></td>
<td>
<p>track expression band. If 'NULL' no band is used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is a binned version of 'gquantiles'. For each iterator
interval the value of 'bin_expr' is calculated and assigned to the
corresponding bin determined by 'breaks'. The quantiles of 'expr' are
calculated then separately for each bin.
</p>
<p>The bins can be multi-dimensional depending on the number of
'bin_expr'-'breaks' pairs.
</p>
<p>The range of bins is determined by 'breaks' argument. For example:
'breaks=c(x1, x2, x3, x4)' represents three different intervals (bins): (x1,
x2], (x2, x3], (x3, x4].
</p>
<p>If 'include.lowest' is 'TRUE' the the lowest value will be included in the
first interval, i.e. in [x1, x2].
</p>


<h3>Value</h3>

<p>Multi-dimensional array representing quantiles for each percentile
and bin.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gquantiles">gquantiles</a></code>, <code><a href="#topic+gintervals.quantiles">gintervals.quantiles</a></code>,
<code><a href="#topic+gdist">gdist</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

gdb.init_examples()
gbins.quantiles("dense_track", c(0, 0.2, 0.4, 2), "sparse_track",
    percentiles = c(0.2, 0.5),
    intervals = gintervals(1),
    iterator = "dense_track"
)

</code></pre>

<hr>
<h2 id='gbins.summary'>Calculates summary statistics of a track expression for bins</h2><span id='topic+gbins.summary'></span>

<h3>Description</h3>

<p>Calculates summary statistics of a track expression for bins.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gbins.summary(
  ...,
  expr = NULL,
  intervals = get("ALLGENOME", envir = .misha),
  include.lowest = FALSE,
  iterator = NULL,
  band = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gbins.summary_+3A_...">...</code></td>
<td>
<p>pairs of track expressions ('bin_expr') that determines the bins and breaks that define the bins. See <code><a href="#topic+gdist">gdist</a></code>.</p>
</td></tr>
<tr><td><code id="gbins.summary_+3A_expr">expr</code></td>
<td>
<p>track expression for which summary statistics is calculated</p>
</td></tr>
<tr><td><code id="gbins.summary_+3A_intervals">intervals</code></td>
<td>
<p>genomic scope for which the function is applied</p>
</td></tr>
<tr><td><code id="gbins.summary_+3A_include.lowest">include.lowest</code></td>
<td>
<p>if 'TRUE', the lowest value of the range determined by
breaks is included</p>
</td></tr>
<tr><td><code id="gbins.summary_+3A_iterator">iterator</code></td>
<td>
<p>track expression iterator. If 'NULL' iterator is determined
implicitly based on track expressions.</p>
</td></tr>
<tr><td><code id="gbins.summary_+3A_band">band</code></td>
<td>
<p>track expression band. If 'NULL' no band is used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is a binned version of 'gsummary'. For each iterator interval
the value of 'bin_expr' is calculated and assigned to the corresponding bin
determined by 'breaks'. The summary statistics of 'expr' are calculated then
separately for each bin.
</p>
<p>The bins can be multi-dimensional depending on the number of
'bin_expr'-'breaks' pairs.
</p>
<p>The range of bins is determined by 'breaks' argument. For example:
'breaks=c(x1, x2, x3, x4)' represents three different intervals (bins): (x1,
x2], (x2, x3], (x3, x4].
</p>
<p>If 'include.lowest' is 'TRUE' the the lowest value will be included in the
first interval, i.e. in [x1, x2].
</p>


<h3>Value</h3>

<p>Multi-dimensional array representing summary statistics for each
bin.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gsummary">gsummary</a></code>, <code><a href="#topic+gintervals.summary">gintervals.summary</a></code>,
<code><a href="#topic+gdist">gdist</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

gdb.init_examples()
gbins.summary("dense_track", c(0, 0.2, 0.4, 2), "sparse_track",
    intervals = gintervals(1), iterator = "dense_track"
)

</code></pre>

<hr>
<h2 id='gcis_decay'>Calculates distribution of contact distances</h2><span id='topic+gcis_decay'></span>

<h3>Description</h3>

<p>Calculates distribution of contact distances.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gcis_decay(
  expr = NULL,
  breaks = NULL,
  src = NULL,
  domain = NULL,
  intervals = NULL,
  include.lowest = FALSE,
  iterator = NULL,
  band = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gcis_decay_+3A_expr">expr</code></td>
<td>
<p>track expression</p>
</td></tr>
<tr><td><code id="gcis_decay_+3A_breaks">breaks</code></td>
<td>
<p>breaks that determine the bin</p>
</td></tr>
<tr><td><code id="gcis_decay_+3A_src">src</code></td>
<td>
<p>source intervals</p>
</td></tr>
<tr><td><code id="gcis_decay_+3A_domain">domain</code></td>
<td>
<p>domain intervals</p>
</td></tr>
<tr><td><code id="gcis_decay_+3A_intervals">intervals</code></td>
<td>
<p>genomic scope for which the function is applied</p>
</td></tr>
<tr><td><code id="gcis_decay_+3A_include.lowest">include.lowest</code></td>
<td>
<p>if 'TRUE', the lowest value of the range determined by
breaks is included</p>
</td></tr>
<tr><td><code id="gcis_decay_+3A_iterator">iterator</code></td>
<td>
<p>2D track expression iterator. If 'NULL' iterator is
determined implicitly based on track expressions.</p>
</td></tr>
<tr><td><code id="gcis_decay_+3A_band">band</code></td>
<td>
<p>track expression band. If 'NULL' no band is used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A 2D iterator interval '(chrom1, start1, end1, chrom2, start2, end2)' is
said to represent a contact between two 1D intervals I1 and I2: '(chrom1,
start1, end1)' and '(chrom2, start2, end2)'.
</p>
<p>For contacts where 'chrom1' equals to 'chrom2' and I1 is within source
intervals the function calculates the distribution of distances between I1
and I2. The distribution is calculated separately for intra-domain and
inter-domain contacts.
</p>
<p>An interval is within source intervals if the unification of all source
intervals fully overlaps it. 'src' intervals are allowed to contain
overlapping intervals.
</p>
<p>Two intervals I1 and I2 are within the same domain (intra-domain contact) if
among the domain intervals exists an interval that fully overlaps both I1
and I2. Otherwise the contact is considered to be inter-domain. 'domain'
must contain only non-overlapping intervals.
</p>
<p>The distance between I1 and I2 is the absolute distance between the centers
of these intervals, i.e.: '|(start1 + end1 - start2 - end2) / 2|'.
</p>
<p>The range of distances for which the distribution is calculated is defined
by 'breaks' argument. For example: 'breaks=c(x1, x2, x3, x4)' represents
three different intervals (bins): (x1, x2], (x2, x3], (x3, x4].
</p>
<p>If 'include.lowest' is 'TRUE' the the lowest value will be included in the
first interval, i.e. in [x1, x2]
</p>


<h3>Value</h3>

<p>2-dimensional vector representing the distribution of contact
distances for inter and intra domains.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gdist">gdist</a></code>, <code><a href="#topic+gtrack.2d.import_contacts">gtrack.2d.import_contacts</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

gdb.init_examples()

src &lt;- rbind(
    gintervals(1, 10, 100),
    gintervals(1, 200, 300),
    gintervals(1, 400, 500),
    gintervals(1, 600, 700),
    gintervals(1, 7000, 9100),
    gintervals(1, 9000, 18000),
    gintervals(1, 30000, 31000),
    gintervals(2, 1130, 15000)
)

domain &lt;- rbind(
    gintervals(1, 0, 483000),
    gintervals(2, 0, 300000)
)

gcis_decay("rects_track", 50000 * (1:10), src, domain)

</code></pre>

<hr>
<h2 id='gcluster.run'>Runs R commands on a cluster</h2><span id='topic+gcluster.run'></span>

<h3>Description</h3>

<p>Runs R commands on a cluster that supports SGE.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gcluster.run(
  ...,
  opt.flags = "",
  max.jobs = 400,
  debug = FALSE,
  R = "R",
  control_dir = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gcluster.run_+3A_...">...</code></td>
<td>
<p>R commands</p>
</td></tr>
<tr><td><code id="gcluster.run_+3A_opt.flags">opt.flags</code></td>
<td>
<p>optional flags for qsub command</p>
</td></tr>
<tr><td><code id="gcluster.run_+3A_max.jobs">max.jobs</code></td>
<td>
<p>maximal number of simultaneously submitted jobs</p>
</td></tr>
<tr><td><code id="gcluster.run_+3A_debug">debug</code></td>
<td>
<p>if 'TRUE', additional reports are printed</p>
</td></tr>
<tr><td><code id="gcluster.run_+3A_r">R</code></td>
<td>
<p>command that launches R</p>
</td></tr>
<tr><td><code id="gcluster.run_+3A_control_dir">control_dir</code></td>
<td>
<p>directory where the control files are stored. Note that this
directory should be accessible from all nodes. If 'NULL', a temporary directory
would be created under the current misha database.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function runs R commands on a cluster by distributing them among
cluster nodes. It must run on a machine that supports Sun Grid Engine (SGE).
The order in which the commands are executed can not be guaranteed,
therefore the commands must be inter-independent.
</p>
<p>Optional flags to 'qsub' command can be passed through 'opt.flags'
parameter. Users are strongly recommended to use only '-l' flag as other
flags might interfere with those that are already used (-terse, -S, -o, -e,
-V). For additional information please refer to the manual of 'qsub'.
</p>
<p>The maximal number of simultaneously submitted jobs is controlled by
'max.jobs'.
</p>
<p>Set 'debug' argument to 'TRUE to allow additional report prints.
</p>
<p>'gcluster.run' launches R on the cluster nodes to execute the commands. 'R'
argument specifies how R executable should be invoked.
</p>


<h3>Value</h3>

<p>Return value ('retv') is a list, such that 'retv[[i]]' represents
the result of the run of command number 'i'. Each result consists of 4
fields that can be accessed by 'retv[[i]]$FIELDNAME':
</p>

<table>
<tr>
 <td style="text-align: left;"> <em>FIELDNAME</em> </td><td style="text-align: left;"> <em>DESCRIPTION</em></td>
</tr>
<tr>
 <td style="text-align: left;"> exit.status </td><td style="text-align: left;">
Exit status of the command. Possible values: 'success', 'failure' or
'interrupted'.</td>
</tr>
<tr>
 <td style="text-align: left;"> retv </td><td style="text-align: left;"> Return value of the command.</td>
</tr>
<tr>
 <td style="text-align: left;"> stdout </td><td style="text-align: left;">
Standard output of the command.</td>
</tr>
<tr>
 <td style="text-align: left;"> stderr </td><td style="text-align: left;"> Standard error of the
command. </td>
</tr>

</table>



<h3>Examples</h3>

<pre><code class='language-R'>

gdb.init_examples()
# Run only on systems with Sun Grid Engine (SGE)
if (FALSE) {
    v &lt;- 17
    gcluster.run(
        gsummary("dense_track + v"),
        {
            intervs &lt;- gscreen("dense_track &gt; 0.1", gintervals(1, 2))
            gsummary("sparse_track", intervs)
        },
        gsummary("rects_track")
    )
}


</code></pre>

<hr>
<h2 id='gcompute_strands_autocorr'>Computes auto-correlation between the strands for a file of mapped sequences</h2><span id='topic+gcompute_strands_autocorr'></span>

<h3>Description</h3>

<p>Calculates auto-correlation between plus and minus strands for the given
chromosome in a file of mapped sequences.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gcompute_strands_autocorr(
  file = NULL,
  chrom = NULL,
  binsize = NULL,
  maxread = 400,
  cols.order = c(9, 11, 13, 14),
  min.coord = 0,
  max.coord = 3e+08
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gcompute_strands_autocorr_+3A_file">file</code></td>
<td>
<p>the name of the file containing mapped sequences</p>
</td></tr>
<tr><td><code id="gcompute_strands_autocorr_+3A_chrom">chrom</code></td>
<td>
<p>chromosome for which the auto-correlation is computed</p>
</td></tr>
<tr><td><code id="gcompute_strands_autocorr_+3A_binsize">binsize</code></td>
<td>
<p>calculate the auto-correlation for bins in the range of
[-maxread, maxread]</p>
</td></tr>
<tr><td><code id="gcompute_strands_autocorr_+3A_maxread">maxread</code></td>
<td>
<p>maximal length of the sequence used for statistics</p>
</td></tr>
<tr><td><code id="gcompute_strands_autocorr_+3A_cols.order">cols.order</code></td>
<td>
<p>order of sequence, chromosome, coordinate and strand
columns in file</p>
</td></tr>
<tr><td><code id="gcompute_strands_autocorr_+3A_min.coord">min.coord</code></td>
<td>
<p>minimal coordinate used for statistics</p>
</td></tr>
<tr><td><code id="gcompute_strands_autocorr_+3A_max.coord">max.coord</code></td>
<td>
<p>maximal coordinate used for statistics</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function calculates auto-correlation between plus and minus strands for
the given chromosome in a file of mapped sequences. Each line in the file
describes one read. Each column is separated by a TAB character.
</p>
<p>The following columns must be presented in the file: sequence, chromosome,
coordinate and strand. The position of these columns are controlled by
'cols.order' argument accordingly. The default value of 'cols.order' is a
vector (9,11,13,14) meaning that sequence is expected to be found at column
number 9, chromosome - at column 11, coordinate - at column 13 and strand -
at column 14. The first column should be referenced by 1 and not by 0.
</p>
<p>Coordinates that are not in [min.coord, max.coord] range are ignored.
</p>
<p>gcompute_strands_autocorr outputs the total statistics and the
auto-correlation given by bins. The size of the bin is indicated by
'binsize' parameter. Statistics is calculated for bins in the range of
[-maxread, maxread].
</p>


<h3>Value</h3>

<p>Statistics for each strand and auto-correlation by given bins.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

gdb.init_examples()
gcompute_strands_autocorr(paste(.misha$GROOT, "reads", sep = "/"),
    "chr1", 50,
    maxread = 300
)

</code></pre>

<hr>
<h2 id='gdb.create'>Creates a new Genomic Database</h2><span id='topic+gdb.create'></span>

<h3>Description</h3>

<p>Creates a new Genomic Database.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gdb.create(
  groot = NULL,
  fasta = NULL,
  genes.file = NULL,
  annots.file = NULL,
  annots.names = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gdb.create_+3A_groot">groot</code></td>
<td>
<p>path to newly created database</p>
</td></tr>
<tr><td><code id="gdb.create_+3A_fasta">fasta</code></td>
<td>
<p>an array of names or URLs of FASTA files. Can contain wildcards
for multiple files</p>
</td></tr>
<tr><td><code id="gdb.create_+3A_genes.file">genes.file</code></td>
<td>
<p>name or URL of file that contains genes. If 'NULL' no
genes are imported</p>
</td></tr>
<tr><td><code id="gdb.create_+3A_annots.file">annots.file</code></td>
<td>
<p>name of URL file that contains annotations. If 'NULL' no
annotations are imported</p>
</td></tr>
<tr><td><code id="gdb.create_+3A_annots.names">annots.names</code></td>
<td>
<p>annotations names</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function creates a new Genomic Database at the location specified by
'groot'. FASTA files are converted to 'Seq' format and appropriate
'chrom_sizes.txt' file is generated (see &quot;User Manual&quot; for more details).
</p>
<p>If 'genes.file' is not 'NULL' four sets of intervals are created in the
database: <code>tss</code>, <code>exons</code>, <code>utr3</code> and <code>utr5</code>. See
<a href="#topic+gintervals.import_genes">gintervals.import_genes</a> for more details about importing genes
intervals.
</p>
<p>'fasta', 'genes.file' and 'annots.file' can be either a file path or URL in
a form of 'ftp://[address]/[file]'. 'fasta' can also contain wildcards to
indicate multiple files. Files that these arguments point to can be zipped
or unzipped.
</p>
<p>See the 'Genomes' vignette for details on how to create a database from common
genome sources.
</p>


<h3>Value</h3>

<p>None.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gdb.init">gdb.init</a></code>, <code><a href="#topic+gdb.reload">gdb.reload</a></code>,
<code><a href="#topic+gintervals.import_genes">gintervals.import_genes</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
ftp &lt;- "ftp://hgdownload.soe.ucsc.edu/goldenPath/mm10"
mm10_dir &lt;- file.path(tempdir(), "mm10")
# only a single chromosome is loaded in this example
# see "Genomes" vignette how to download all of them and how
# to download other genomes
gdb.create(
    mm10_dir,
    paste(ftp, "chromosomes", paste0(
        "chr", c("X"),
        ".fa.gz"
    ), sep = "/"),
    paste(ftp, "database/knownGene.txt.gz", sep = "/"),
    paste(ftp, "database/kgXref.txt.gz", sep = "/"),
    c(
        "kgID", "mRNA", "spID", "spDisplayID", "geneSymbol",
        "refseq", "protAcc", "description", "rfamAcc",
        "tRnaName"
    )
)
gdb.init(mm10_dir)
gintervals.ls()
gintervals.all()


</code></pre>

<hr>
<h2 id='gdb.create_genome'>Create and Load a Genome Database</h2><span id='topic+gdb.create_genome'></span>

<h3>Description</h3>

<p>This function downloads, extracts, and loads a misha genome database for the specified genome.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gdb.create_genome(genome, path = getwd(), tmpdir = tempdir())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gdb.create_genome_+3A_genome">genome</code></td>
<td>
<p>A character string specifying the genome to download. Supported genomes are &quot;mm9&quot;, &quot;mm10&quot;, &quot;mm39&quot;, &quot;hg19&quot;, and &quot;hg38&quot;.</p>
</td></tr>
<tr><td><code id="gdb.create_genome_+3A_path">path</code></td>
<td>
<p>A character string specifying the directory where the genome will be extracted. Defaults to genome name (e.g. &quot;mm10&quot;) in the current working directory.</p>
</td></tr>
<tr><td><code id="gdb.create_genome_+3A_tmpdir">tmpdir</code></td>
<td>
<p>A character string specifying the directory for storing temporary files. This is used for storing the downloaded genome file.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function checks if the specified genome is available. If tmpdir, it constructs the download URL, downloads the genome file,
extracts it to the specified directory, and loads the genome database using <code>gsetroot</code>. The function also calls <code>gdb.reload</code> to reload the genome database.
</p>


<h3>Value</h3>

<p>None.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
mm10_dir &lt;- tempdir()
gdb.create_genome("mm10", path = mm10_dir)
list.files(file.path(mm10_dir, "mm10"))
gsetroot(file.path(mm10_dir, "mm10"))
gintervals.ls()


</code></pre>

<hr>
<h2 id='gdb.get_readonly_attrs'>Returns a list of read-only track attributes</h2><span id='topic+gdb.get_readonly_attrs'></span>

<h3>Description</h3>

<p>Returns a list of read-only track attributes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gdb.get_readonly_attrs()
</code></pre>


<h3>Details</h3>

<p>This function returns a list of read-only track attributes. These attributes
are not allowed to be modified or deleted.
</p>
<p>If no attributes are marked as read-only a 'NULL' is returned.
</p>


<h3>Value</h3>

<p>A list of read-only track attributes.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gdb.set_readonly_attrs">gdb.set_readonly_attrs</a></code>,
<code><a href="#topic+gtrack.attr.get">gtrack.attr.get</a></code>, <code><a href="#topic+gtrack.attr.set">gtrack.attr.set</a></code>
</p>

<hr>
<h2 id='gdb.reload'>Reloads database from the disk</h2><span id='topic+gdb.reload'></span>

<h3>Description</h3>

<p>Reloads database from disk: list of tracks, intervals, etc.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gdb.reload(rescan = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gdb.reload_+3A_rescan">rescan</code></td>
<td>
<p>indicates whether the file structure should be rescanned</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Reloads Genomic Database from disk: list of tracks, intervals, etc. Use this
function if you manually add tracks or if for any reason the database
becomes corrupted. If 'rescan' is 'TRUE', the list of tracks and intervals
is achieved by rescanning directory structure under the current current
working directory. Otherwise 'gdb.reload' attempts to use the cached list
that resides in 'GROOT/.db.cache' file.
</p>


<h3>Value</h3>

<p>No return value, called for side effects.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gdb.init">gdb.init</a></code>, <code><a href="#topic+gdb.create">gdb.create</a></code>,
<code><a href="#topic+gdir.cd">gdir.cd</a></code>,
</p>

<hr>
<h2 id='gdb.set_readonly_attrs'>Sets read-only track attributes</h2><span id='topic+gdb.set_readonly_attrs'></span>

<h3>Description</h3>

<p>Sets read-only track attributes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gdb.set_readonly_attrs(attrs)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gdb.set_readonly_attrs_+3A_attrs">attrs</code></td>
<td>
<p>a vector of read-only attributes names or 'NULL'</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function sets the list of read-only track attributes. The specified
attributes may or may not already exist in the tracks.
</p>
<p>If 'attrs' is 'NULL' the list of read-only attributes is emptied.
</p>


<h3>Value</h3>

<p>None.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gdb.get_readonly_attrs">gdb.get_readonly_attrs</a></code>,
<code><a href="#topic+gtrack.attr.get">gtrack.attr.get</a></code>, <code><a href="#topic+gtrack.attr.set">gtrack.attr.set</a></code>
</p>

<hr>
<h2 id='gdir.cd'>Changes current working directory in Genomic Database</h2><span id='topic+gdir.cd'></span>

<h3>Description</h3>

<p>Changes current working directory in Genomic Database.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gdir.cd(dir = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gdir.cd_+3A_dir">dir</code></td>
<td>
<p>directory path</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function changes the current working directory in Genomic Database (not
to be confused with shell's current working directory). The list of database
objects - tracks, intervals, track variables - is rescanned recursively
under 'dir'. Object names are updated with the respect to the new current
working directory. Example: a track named 'subdir.dense' will be referred as
'dense' once current working directory is set to 'subdir'. All virtual
tracks are removed.
</p>


<h3>Value</h3>

<p>None.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gdb.init">gdb.init</a></code>, <code><a href="#topic+gdir.cwd">gdir.cwd</a></code>,
<code><a href="#topic+gdir.create">gdir.create</a></code>, <code><a href="#topic+gdir.rm">gdir.rm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

gdb.init_examples()
gdir.cd("subdir")
gtrack.ls()
gdir.cd("..")
gtrack.ls()

</code></pre>

<hr>
<h2 id='gdir.create'>Creates a new directory in Genomic Database</h2><span id='topic+gdir.create'></span>

<h3>Description</h3>

<p>Creates a new directory in Genomic Database.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gdir.create(dir = NULL, showWarnings = TRUE, mode = "0777")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gdir.create_+3A_dir">dir</code></td>
<td>
<p>directory path</p>
</td></tr>
<tr><td><code id="gdir.create_+3A_showwarnings">showWarnings</code></td>
<td>
<p>see 'dir.create'</p>
</td></tr>
<tr><td><code id="gdir.create_+3A_mode">mode</code></td>
<td>
<p>see 'dir.create'</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function creates a new directory in Genomic Database. Creates only the
last element in the specified path.
</p>


<h3>Value</h3>

<p>None.
</p>


<h3>Note</h3>

<p>A new directory cannot be created within an existing track directory.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+dir.create">dir.create</a></code>, <code><a href="#topic+gdb.init">gdb.init</a></code>,
<code><a href="#topic+gdir.cwd">gdir.cwd</a></code>, <code><a href="#topic+gdir.rm">gdir.rm</a></code>
</p>

<hr>
<h2 id='gdir.cwd'>Returns the current working directory in Genomic Database</h2><span id='topic+gdir.cwd'></span>

<h3>Description</h3>

<p>Returns the absolute path of the current working directory in Genomic
Database.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gdir.cwd()
</code></pre>


<h3>Details</h3>

<p>This function returns the absolute path of the current working directory in
Genomic Database (not to be confused with shell's current working
directory).
</p>


<h3>Value</h3>

<p>A character string of the path.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gdb.init">gdb.init</a></code>, <code><a href="#topic+gdir.cd">gdir.cd</a></code>,
<code><a href="#topic+gdir.create">gdir.create</a></code>, <code><a href="#topic+gdir.rm">gdir.rm</a></code>
</p>

<hr>
<h2 id='gdir.rm'>Deletes a directory from Genomic Database</h2><span id='topic+gdir.rm'></span>

<h3>Description</h3>

<p>Deletes a directory from Genomic Database.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gdir.rm(dir = NULL, recursive = FALSE, force = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gdir.rm_+3A_dir">dir</code></td>
<td>
<p>directory path</p>
</td></tr>
<tr><td><code id="gdir.rm_+3A_recursive">recursive</code></td>
<td>
<p>if 'TRUE', the directory is deleted recursively</p>
</td></tr>
<tr><td><code id="gdir.rm_+3A_force">force</code></td>
<td>
<p>if 'TRUE', suppresses user confirmation of tracks/intervals
removal</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function deletes a directory from Genomic Database. If 'recursive' is
'TRUE', the directory is deleted with all the files/directories it contains.
If the directory contains tracks or intervals, the user is prompted to
confirm the deletion. Set 'force' to 'TRUE' to suppress the prompt.
</p>


<h3>Value</h3>

<p>None.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gdb.init">gdb.init</a></code>, <code><a href="#topic+gdir.create">gdir.create</a></code>,
<code><a href="#topic+gdir.cd">gdir.cd</a></code>, <code><a href="#topic+gdir.cwd">gdir.cwd</a></code>
</p>

<hr>
<h2 id='gdist'>Calculates distribution of track expressions</h2><span id='topic+gdist'></span>

<h3>Description</h3>

<p>Calculates distribution of track expressions' values over the given set of
bins.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gdist(
  ...,
  intervals = NULL,
  include.lowest = FALSE,
  iterator = NULL,
  band = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gdist_+3A_...">...</code></td>
<td>
<p>pairs of 'expr', 'breaks' where 'expr' is a track expression and the breaks determine the bin</p>
</td></tr>
<tr><td><code id="gdist_+3A_intervals">intervals</code></td>
<td>
<p>genomic scope for which the function is applied</p>
</td></tr>
<tr><td><code id="gdist_+3A_include.lowest">include.lowest</code></td>
<td>
<p>if 'TRUE', the lowest value of the range determined by
breaks is included</p>
</td></tr>
<tr><td><code id="gdist_+3A_iterator">iterator</code></td>
<td>
<p>track expression iterator. If 'NULL' iterator is determined
implicitly based on track expressions.</p>
</td></tr>
<tr><td><code id="gdist_+3A_band">band</code></td>
<td>
<p>track expression band. If 'NULL' no band is used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function calculates the distribution of values of the numeric track
expressions over the given set of bins.
</p>
<p>The range of bins is determined by 'breaks' argument. For example:
'breaks=c(x1, x2, x3, x4)' represents three different intervals (bins): (x1,
x2], (x2, x3], (x3, x4].
</p>
<p>If 'include.lowest' is 'TRUE' the the lowest value will be included in the
first interval, i.e. in [x1, x2]
</p>
<p>'gdist' can work with any number of dimensions. If more than one
'expr'-'breaks' pair is passed, the result is a multidimensional vector, and
an individual value can be accessed by [i1,i2,...,iN] notation, where 'i1'
is the first track and 'iN' is the last track expression.
</p>


<h3>Value</h3>

<p>N-dimensional vector where N is the number of 'expr'-'breaks' pairs.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gextract">gextract</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

gdb.init_examples()

## calculate the distribution of dense_track for bins:
## (0, 0.2], (0.2, 0.5] and (0.5, 1]
gdist("dense_track", c(0, 0.2, 0.5, 1))

## calculate two-dimensional distribution:
## dense_track vs. sparse_track
gdist("dense_track", seq(0, 1, by = 0.1), "sparse_track",
    seq(0, 2, by = 0.2),
    iterator = 100
)

</code></pre>

<hr>
<h2 id='gextract'>Returns evaluated track expression</h2><span id='topic+gextract'></span>

<h3>Description</h3>

<p>Returns the result of track expressions evaluation for each of the iterator
intervals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gextract(
  ...,
  intervals = NULL,
  colnames = NULL,
  iterator = NULL,
  band = NULL,
  file = NULL,
  intervals.set.out = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gextract_+3A_...">...</code></td>
<td>
<p>track expression</p>
</td></tr>
<tr><td><code id="gextract_+3A_intervals">intervals</code></td>
<td>
<p>genomic scope for which the function is applied</p>
</td></tr>
<tr><td><code id="gextract_+3A_colnames">colnames</code></td>
<td>
<p>sets the columns names in the returned value. If 'NULL'
names are set to track expression.</p>
</td></tr>
<tr><td><code id="gextract_+3A_iterator">iterator</code></td>
<td>
<p>track expression iterator. If 'NULL' iterator is determined
implicitly based on track expressions.</p>
</td></tr>
<tr><td><code id="gextract_+3A_band">band</code></td>
<td>
<p>track expression band. If 'NULL' no band is used.</p>
</td></tr>
<tr><td><code id="gextract_+3A_file">file</code></td>
<td>
<p>file name where the function result is optionally outputted in
tab-delimited format</p>
</td></tr>
<tr><td><code id="gextract_+3A_intervals.set.out">intervals.set.out</code></td>
<td>
<p>intervals set name where the function result is
optionally outputted</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function returns the result of track expressions evaluation for each of
the iterator intervals. The returned value is a set of intervals with an
additional column for each of the track expressions. This value can be used
as an input for any other function that accepts intervals. If the intervals
inside 'intervals' argument overlap gextract returns the overlapped
coordinate more than once.
</p>
<p>The order inside the result might not be the same as the order of intervals.
An additional column 'intervalID' is added to the return value. Use this
column to refer to the index of the original interval from the supplied
'intervals'.
</p>
<p>If 'file' parameter is not 'NULL' the result is outputted to a tab-delimited
text file (without 'intervalID' column) rather than returned to the user.
This can be especially useful when the result is too big to fit into the
physical memory.  The resulted file can be used as an input for
'gtrack.import' or 'gtrack.array.import' functions.
</p>
<p>If 'intervals.set.out' is not 'NULL' the result is saved as an intervals
set. Similarly to 'file' parameter 'intervals.set.out' can be useful to
overcome the limits of the physical memory.
</p>
<p>'colnames' parameter controls the names of the columns that contain the
evaluated expressions. By default the column names match the track
expressions.
</p>


<h3>Value</h3>

<p>If 'file' and 'intervals.set.out' are 'NULL' a set of intervals with
an additional column for each of the track expressions and 'columnID'
column.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gtrack.array.extract">gtrack.array.extract</a></code>, <code><a href="#topic+gsample">gsample</a></code>,
<code><a href="#topic+gtrack.import">gtrack.import</a></code>, <code><a href="#topic+gtrack.array.import">gtrack.array.import</a></code>,
<code><a href="#topic+glookup">glookup</a></code>, <code><a href="#topic+gpartition">gpartition</a></code>, <code><a href="#topic+gdist">gdist</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

gdb.init_examples()

## get values of 'dense_track' for [0, 400), chrom 1
gextract("dense_track", gintervals(1, 0, 400))

## get values of 'rects_track' (a 2D track) for a 2D interval
gextract(
    "rects_track",
    gintervals.2d("chr1", 0, 4000, "chr2", 2000, 5000)
)

</code></pre>

<hr>
<h2 id='gintervals'>Creates a set of 1D intervals</h2><span id='topic+gintervals'></span>

<h3>Description</h3>

<p>Creates a set of 1D intervals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gintervals(chroms = NULL, starts = 0, ends = -1, strands = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gintervals_+3A_chroms">chroms</code></td>
<td>
<p>chromosomes - an array of strings with or without &quot;chr&quot;
prefixes or an array of integers (like: '1' for &quot;chr1&quot;)</p>
</td></tr>
<tr><td><code id="gintervals_+3A_starts">starts</code></td>
<td>
<p>an array of start coordinates</p>
</td></tr>
<tr><td><code id="gintervals_+3A_ends">ends</code></td>
<td>
<p>an array of end coordinates. If '-1' chromosome size is assumed.</p>
</td></tr>
<tr><td><code id="gintervals_+3A_strands">strands</code></td>
<td>
<p>'NULL' or an array consisting of '-1', '0' or '1' values</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function returns a set of one-dimensional intervals. The returned value
can be used in all functions that accept 'intervals' argument.
</p>
<p>One-dimensional intervals is a data frame whose first three columns are
'chrom', 'start' and 'end'. Each row of the data frame represents a genomic
interval of the specified chromosome in the range of [start, end).
Additional columns can be presented in 1D intervals object yet these columns
must be added after the three obligatory ones.
</p>
<p>If 'strands' argument is not 'NULL' an additional column &quot;strand&quot; is added
to the intervals. The possible values of a strand can be '1' (plus strand),
'-1' (minus strand) or '0' (unknown).
</p>


<h3>Value</h3>

<p>A data frame representing the intervals.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gintervals.2d">gintervals.2d</a></code>, <code><a href="#topic+gintervals.force_range">gintervals.force_range</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

gdb.init_examples()

## the following 3 calls produce identical results
gintervals(1)
gintervals("1")
gintervals("chrX")

gintervals(1, 1000)
gintervals(c("chr2", "chrX"), 10, c(3000, 5000))

</code></pre>

<hr>
<h2 id='gintervals.2d'>Creates a set of 2D intervals</h2><span id='topic+gintervals.2d'></span>

<h3>Description</h3>

<p>Creates a set of 2D intervals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gintervals.2d(
  chroms1 = NULL,
  starts1 = 0,
  ends1 = -1,
  chroms2 = NULL,
  starts2 = 0,
  ends2 = -1
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gintervals.2d_+3A_chroms1">chroms1</code></td>
<td>
<p>chromosomes1 - an array of strings with or without &quot;chr&quot;
prefixes or an array of integers (like: '1' for &quot;chr1&quot;)</p>
</td></tr>
<tr><td><code id="gintervals.2d_+3A_starts1">starts1</code></td>
<td>
<p>an array of start1 coordinates</p>
</td></tr>
<tr><td><code id="gintervals.2d_+3A_ends1">ends1</code></td>
<td>
<p>an array of end1 coordinates. If '-1' chromosome size is
assumed.</p>
</td></tr>
<tr><td><code id="gintervals.2d_+3A_chroms2">chroms2</code></td>
<td>
<p>chromosomes2 - an array of strings with or without &quot;chr&quot;
prefixes or an array of integers (like: '1' for &quot;chr1&quot;). If 'NULL',
'chroms2' is assumed to be equal to 'chroms1'.</p>
</td></tr>
<tr><td><code id="gintervals.2d_+3A_starts2">starts2</code></td>
<td>
<p>an array of start2 coordinates</p>
</td></tr>
<tr><td><code id="gintervals.2d_+3A_ends2">ends2</code></td>
<td>
<p>an array of end2 coordinates. If '-1' chromosome size is
assumed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function returns a set of two-dimensional intervals. The returned value
can be used in all functions that accept 'intervals' argument.
</p>
<p>Two-dimensional intervals is a data frame whose first six columns are
'chrom1', 'start1', 'end1', 'chrom2', 'start2' and 'end2'. Each row of the
data frame represents two genomic intervals from two chromosomes in the
range of [start, end). Additional columns can be presented in 2D intervals
object yet these columns must be added after the six obligatory ones.
</p>


<h3>Value</h3>

<p>A data frame representing the intervals.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gintervals">gintervals</a></code>, <code><a href="#topic+gintervals.force_range">gintervals.force_range</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

gdb.init_examples()

## the following 3 calls produce identical results
gintervals.2d(1)
gintervals.2d("1")
gintervals.2d("chrX")

gintervals.2d(1, 1000, 2000, "chrX", 400, 800)
gintervals.2d(c("chr2", "chrX"), 10, c(3000, 5000), 1)

</code></pre>

<hr>
<h2 id='gintervals.2d.all'>Returns 2D intervals that cover the whole genome</h2><span id='topic+gintervals.2d.all'></span>

<h3>Description</h3>

<p>Returns 2D intervals that cover the whole genome.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gintervals.2d.all()
</code></pre>


<h3>Details</h3>

<p>This function returns a set of two-dimensional intervals that cover the
whole genome as it is defined by 'chrom_sizes.txt' file.
</p>


<h3>Value</h3>

<p>A data frame representing the intervals.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gintervals.2d">gintervals.2d</a></code>
</p>

<hr>
<h2 id='gintervals.2d.band_intersect'>Intersects two-dimensional intervals with a band</h2><span id='topic+gintervals.2d.band_intersect'></span>

<h3>Description</h3>

<p>Intersects two-dimensional intervals with a band.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gintervals.2d.band_intersect(
  intervals = NULL,
  band = NULL,
  intervals.set.out = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gintervals.2d.band_intersect_+3A_intervals">intervals</code></td>
<td>
<p>two-dimensional intervals</p>
</td></tr>
<tr><td><code id="gintervals.2d.band_intersect_+3A_band">band</code></td>
<td>
<p>track expression band. If 'NULL' no band is used.</p>
</td></tr>
<tr><td><code id="gintervals.2d.band_intersect_+3A_intervals.set.out">intervals.set.out</code></td>
<td>
<p>intervals set name where the function result is
optionally outputted</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function intersects each two-dimensional interval from 'intervals' with
'band'. If the intersection is not empty, the interval is shrunk to the
minimal rectangle that contains the band and added to the return value.
</p>
<p>If 'intervals.set.out' is not 'NULL' the result is saved as an intervals
set. Use this parameter if the result size exceeds the limits of the
physical memory.
</p>


<h3>Value</h3>

<p>If 'intervals.set.out' is 'NULL' a data frame representing the
intervals.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gintervals.2d">gintervals.2d</a></code>, <code><a href="#topic+gintervals.intersect">gintervals.intersect</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

gdb.init_examples()
gintervals.2d.band_intersect(gintervals.2d(1), c(10000, 20000))

</code></pre>

<hr>
<h2 id='gintervals.all'>Returns 1D intervals that cover the whole genome</h2><span id='topic+gintervals.all'></span>

<h3>Description</h3>

<p>Returns 1D intervals that cover the whole genome.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gintervals.all()
</code></pre>


<h3>Details</h3>

<p>This function returns a set of one-dimensional intervals that cover the
whole genome as it is defined by 'chrom_sizes.txt' file.
</p>


<h3>Value</h3>

<p>A data frame representing the intervals.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gintervals">gintervals</a></code>
</p>

<hr>
<h2 id='gintervals.canonic'>Converts intervals to canonic form</h2><span id='topic+gintervals.canonic'></span>

<h3>Description</h3>

<p>Converts intervals to canonic form.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gintervals.canonic(intervals = NULL, unify_touching_intervals = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gintervals.canonic_+3A_intervals">intervals</code></td>
<td>
<p>intervals to be converted</p>
</td></tr>
<tr><td><code id="gintervals.canonic_+3A_unify_touching_intervals">unify_touching_intervals</code></td>
<td>
<p>if 'TRUE', touching one-dimensional
intervals are unified</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function converts 'intervals' into a &quot;canonic&quot; form: properly sorted
with no overlaps. The result can be used later in the functions that require
the intervals to be in canonic form. Use 'unify_touching_intervals' to
control whether the intervals that touch each other (i.e. the end coordinate
of one equals to the start coordinate of the other) are unified.
'unify_touching_intervals' is ignored if two-dimensional intervals are used.
</p>
<p>Since 'gintervals.canonic' unifies overlapping or touching intervals, the
number of the returned intervals might be less than the number of the
original intervals. To allow the user to find the origin of the new interval
'mapping' attribute is attached to the result. It maps between the original
intervals and the resulted intervals. Use 'attr(retv_of_gintervals.canonic,
&quot;mapping&quot;)' to retrieve the map.
</p>


<h3>Value</h3>

<p>A data frame representing the canonic intervals and an attribute
'mapping' that maps the original intervals to the resulted ones.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gintervals">gintervals</a></code>, <code><a href="#topic+gintervals.2d">gintervals.2d</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

gdb.init_examples()

## Create intervals manually by using 'data.frame'.
## Note that we add an additional column 'data'.
## Return value:
##   chrom start   end data
## 1  chr1 11000 12000   10
## 2  chr1   100   200   20
## 3  chr1 10000 13000   30
## 4  chr1 10500 10600   40
intervs &lt;- data.frame(
    chrom = "chr1",
    start = c(11000, 100, 10000, 10500),
    end = c(12000, 200, 13000, 10600),
    data = c(10, 20, 30, 40)
)

## Convert the intervals into the canonic form.
## The function discards any columns besides chrom, start and end.
## Return value:
##  chrom start   end
## 1  chr1   100   200
## 2  chr1 10000 13000
res &lt;- gintervals.canonic(intervs)

## By inspecting mapping attribute we can see how the new
## intervals were created: "2 1 2 2" means that the first
## interval in the result was created from the second interval in
## the original set (we look for the indices in mapping where "1"
## appears). Likewise the second interval in the result was
## created from 3 intervals in the original set. Their indices are
## 1, 3 and 4 (once again we look for the indices in mapping where
## "2" appears).
## Return value:
## 2 1 2 2
attr(res, "mapping")

## Finally (and that is the most useful part of 'mapping'
## attribute): we add a new column 'data' to our result which is
## the mean value of the original data column. The trick is done
## using 'tapply' on par with 'mapping' attribute. For example,
## 20.00000 equals is a result of 'mean(intervs[2,]$data' while
## 26.66667 is a result of 'mean(intervs[c(1,3,4),]$data)'.
## 'res' after the following call:
##  chrom start   end     data
## 1  chr1   100   200 20.00000
## 2  chr1 10000 13000 26.66667
res$data &lt;- tapply(intervs$data, attr(res, "mapping"), mean)

</code></pre>

<hr>
<h2 id='gintervals.chrom_sizes'>Returns number of intervals per chromosome</h2><span id='topic+gintervals.chrom_sizes'></span>

<h3>Description</h3>

<p>Returns number of intervals per chromosome (or chromosome pair).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gintervals.chrom_sizes(intervals = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gintervals.chrom_sizes_+3A_intervals">intervals</code></td>
<td>
<p>intervals set</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function returns number of intervals per chromosome (for 1D intervals)
or chromosome pair (for 2D intervals).
</p>


<h3>Value</h3>

<p>Data frame representing number of intervals per chromosome (for 1D
intervals) or chromosome pair (for 2D intervals).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gintervals.load">gintervals.load</a></code>, <code><a href="#topic+gintervals.save">gintervals.save</a></code>,
<code><a href="#topic+gintervals.exists">gintervals.exists</a></code>, <code><a href="#topic+gintervals.ls">gintervals.ls</a></code>,
<code><a href="#topic+gintervals">gintervals</a></code>, <code><a href="#topic+gintervals.2d">gintervals.2d</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

gdb.init_examples()
gintervals.chrom_sizes("annotations")

</code></pre>

<hr>
<h2 id='gintervals.diff'>Calculates difference of two intervals sets</h2><span id='topic+gintervals.diff'></span>

<h3>Description</h3>

<p>Returns difference of two sets of intervals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gintervals.diff(intervals1 = NULL, intervals2 = NULL, intervals.set.out = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gintervals.diff_+3A_intervals1">intervals1</code>, <code id="gintervals.diff_+3A_intervals2">intervals2</code></td>
<td>
<p>set of one-dimensional intervals</p>
</td></tr>
<tr><td><code id="gintervals.diff_+3A_intervals.set.out">intervals.set.out</code></td>
<td>
<p>intervals set name where the function result is
optionally outputted</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function returns a genomic space that is covered by 'intervals1' but
not covered by 'intervals2'.
</p>
<p>If 'intervals.set.out' is not 'NULL' the result is saved as an intervals
set. Use this parameter if the result size exceeds the limits of the
physical memory.
</p>


<h3>Value</h3>

<p>If 'intervals.set.out' is 'NULL' a data frame representing the
intervals.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gintervals">gintervals</a></code>, <code><a href="#topic+gintervals.intersect">gintervals.intersect</a></code>,
<code><a href="#topic+gintervals.union">gintervals.union</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

gdb.init_examples()

intervs1 &lt;- gscreen("dense_track &gt; 0.15")
intervs2 &lt;- gscreen("dense_track &lt; 0.2")

## 'res3' equals to 'res4'
res3 &lt;- gintervals.diff(intervs1, intervs2)
res4 &lt;- gscreen("dense_track &gt;= 0.2")

</code></pre>

<hr>
<h2 id='gintervals.exists'>Tests for a named intervals set existence</h2><span id='topic+gintervals.exists'></span>

<h3>Description</h3>

<p>Tests for a named intervals set existence.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gintervals.exists(intervals.set = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gintervals.exists_+3A_intervals.set">intervals.set</code></td>
<td>
<p>name of an intervals set</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function returns 'TRUE' if a named intervals set exists in Genomic
Database.
</p>


<h3>Value</h3>

<p>'TRUE' if a named intervals set exists. Otherwise 'FALSE'.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gintervals.ls">gintervals.ls</a></code>, <code><a href="#topic+gintervals.load">gintervals.load</a></code>,
<code><a href="#topic+gintervals.rm">gintervals.rm</a></code>, <code><a href="#topic+gintervals.save">gintervals.save</a></code>,
<code><a href="#topic+gintervals">gintervals</a></code>, <code><a href="#topic+gintervals.2d">gintervals.2d</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

gdb.init_examples()
gintervals.exists("annotations")

</code></pre>

<hr>
<h2 id='gintervals.force_range'>Limits intervals to chromosomal range</h2><span id='topic+gintervals.force_range'></span>

<h3>Description</h3>

<p>Limits intervals to chromosomal range.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gintervals.force_range(intervals = NULL, intervals.set.out = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gintervals.force_range_+3A_intervals">intervals</code></td>
<td>
<p>intervals</p>
</td></tr>
<tr><td><code id="gintervals.force_range_+3A_intervals.set.out">intervals.set.out</code></td>
<td>
<p>intervals set name where the function result is
optionally outputted</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function enforces the intervals to be within the chromosomal range [0,
chrom length) by altering the intervals' boundaries. Intervals that lay
entirely outside of the chromosomal range are eliminated. The new intervals
are returned.
</p>
<p>If 'intervals.set.out' is not 'NULL' the result is saved as an intervals
set. Use this parameter if the result size exceeds the limits of the
physical memory.
</p>


<h3>Value</h3>

<p>If 'intervals.set.out' is 'NULL' a data frame representing the
intervals.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gintervals">gintervals</a></code>, <code><a href="#topic+gintervals.2d">gintervals.2d</a></code>,
<code><a href="#topic+gintervals.canonic">gintervals.canonic</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

gdb.init_examples()
intervs &lt;- data.frame(
    chrom = "chr1",
    start = c(11000, -100, 10000, 10500),
    end = c(12000, 200, 13000000, 10600)
)
gintervals.force_range(intervs)

</code></pre>

<hr>
<h2 id='gintervals.import_genes'>Imports genes and annotations from files</h2><span id='topic+gintervals.import_genes'></span>

<h3>Description</h3>

<p>Imports genes and annotations from files.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gintervals.import_genes(
  genes.file = NULL,
  annots.file = NULL,
  annots.names = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gintervals.import_genes_+3A_genes.file">genes.file</code></td>
<td>
<p>name or URL of file that contains genes</p>
</td></tr>
<tr><td><code id="gintervals.import_genes_+3A_annots.file">annots.file</code></td>
<td>
<p>name of URL file that contains annotations. If 'NULL' no
annotations are imported</p>
</td></tr>
<tr><td><code id="gintervals.import_genes_+3A_annots.names">annots.names</code></td>
<td>
<p>annotations names</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function reads a definition of genes from 'genes.file' and returns four
sets of intervals: TSS, exons, 3utr and 5utr. In addition to the regular
intervals columns 'strand' column is added. It contains '1' values for '+'
strands and '-1' values for '-' strands.
</p>
<p>If annotation file 'annots.file' is given then annotations are attached too
to the intervals. The names of the annotations as they would appear in the
return value must be specified in 'annots.names' argument.
</p>
<p>Both 'genes.file' and 'annots.file' can be either a file path or URL in a
form of 'ftp://[address]/[file]'. Files that these arguments point to can be
zipped or unzipped.
</p>
<p>Examples of 'genes.file' and 'annots.file' can be found here:
</p>
<p><code>ftp://hgdownload.soe.ucsc.edu/goldenPath/hg19/database/knownGene.txt.gz</code>
<code>ftp://hgdownload.soe.ucsc.edu/goldenPath/hg19/database/kgXref.txt.gz</code>
</p>
<p>If a few intervals overlap (for example: two TSS regions) they are all
unified to an interval that covers the whole overlapping region. 'strand'
value is set to '0' if two or more of the overlapping intervals have
different strands. The annotations of the overlapping intervals are
concatenated to a single character string separated by semicolons. Identical
values of overlapping intervals' annotation are eliminated.
</p>


<h3>Value</h3>

<p>A list of four intervals sets named 'tss', 'exons', 'utr3' and
'utr5'. 'strand' column and annotations are attached to the intevals.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gintervals">gintervals</a></code>, <code><a href="#topic+gdb.create">gdb.create</a></code>
</p>

<hr>
<h2 id='gintervals.intersect'>Calculates an intersection of two sets of intervals</h2><span id='topic+gintervals.intersect'></span>

<h3>Description</h3>

<p>Calculates an intersection of two sets of intervals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gintervals.intersect(
  intervals1 = NULL,
  intervals2 = NULL,
  intervals.set.out = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gintervals.intersect_+3A_intervals1">intervals1</code>, <code id="gintervals.intersect_+3A_intervals2">intervals2</code></td>
<td>
<p>set of intervals</p>
</td></tr>
<tr><td><code id="gintervals.intersect_+3A_intervals.set.out">intervals.set.out</code></td>
<td>
<p>intervals set name where the function result is
optionally outputted</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function returns intervals that represent a genomic space which is
achieved by intersection of 'intervals1' and 'intervals2'.
</p>
<p>If 'intervals.set.out' is not 'NULL' the result is saved as an intervals
set. Use this parameter if the result size exceeds the limits of the
physical memory.
</p>


<h3>Value</h3>

<p>If 'intervals.set.out' is 'NULL' a data frame representing the
intersection of intervals.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gintervals.2d.band_intersect">gintervals.2d.band_intersect</a></code>,
<code><a href="#topic+gintervals.diff">gintervals.diff</a></code>, <code><a href="#topic+gintervals.union">gintervals.union</a></code>,
<code><a href="#topic+gintervals">gintervals</a></code>, <code><a href="#topic+gintervals.2d">gintervals.2d</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

gdb.init_examples()

intervs1 &lt;- gscreen("dense_track &gt; 0.15")
intervs2 &lt;- gscreen("dense_track &lt; 0.2")

## 'intervs3' and 'intervs4' are identical
intervs3 &lt;- gintervals.intersect(intervs1, intervs2)
intervs4 &lt;- gscreen("dense_track &gt; 0.15 &amp; dense_track &lt; 0.2")

</code></pre>

<hr>
<h2 id='gintervals.is.bigset'>Tests for big intervals set</h2><span id='topic+gintervals.is.bigset'></span>

<h3>Description</h3>

<p>Tests for big intervals set.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gintervals.is.bigset(intervals.set = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gintervals.is.bigset_+3A_intervals.set">intervals.set</code></td>
<td>
<p>name of an intervals set</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function tests whether 'intervals.set' is a big intervals set.
Intervals set is big if it is stored in big intervals set format and given
the current limits it cannot be fully loaded into memory.
</p>
<p>Memory limit is controlled by 'gmax.data.size' option (see:
'getOption(&quot;gmax.data.size&quot;)').
</p>


<h3>Value</h3>

<p>'TRUE' if intervals set is big, otherwise 'FALSE'.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gintervals.load">gintervals.load</a></code>, <code><a href="#topic+gintervals.save">gintervals.save</a></code>,
<code><a href="#topic+gintervals.exists">gintervals.exists</a></code>, <code><a href="#topic+gintervals.ls">gintervals.ls</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

gdb.init_examples()
gintervals.is.bigset("annotations")

</code></pre>

<hr>
<h2 id='gintervals.liftover'>Converts intervals from another assembly</h2><span id='topic+gintervals.liftover'></span>

<h3>Description</h3>

<p>Converts intervals from another assembly to the current one.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gintervals.liftover(intervals = NULL, chain = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gintervals.liftover_+3A_intervals">intervals</code></td>
<td>
<p>intervals from another assembly</p>
</td></tr>
<tr><td><code id="gintervals.liftover_+3A_chain">chain</code></td>
<td>
<p>name of chain file or data frame as returned by
'gintervals.load_chain'</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function converts 'intervals' from another assembly to the current one.
Chain file instructs how the conversion of coordinates should be done. It
can be either a name of a chain file or a data frame in the same format as
returned by 'gintervals.load_chain' function.
</p>
<p>The converted intervals are returned. An additional column named
'intervalID' is added to the resulted data frame. For each interval in the
resulted intervals it indicates the index of the original interval.
</p>


<h3>Value</h3>

<p>A data frame representing the converted intervals.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gintervals.load_chain">gintervals.load_chain</a></code>, <code><a href="#topic+gtrack.liftover">gtrack.liftover</a></code>,
<code><a href="#topic+gintervals">gintervals</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

gdb.init_examples()
chainfile &lt;- paste(.misha$GROOT, "data/test.chain", sep = "/")
intervs &lt;- data.frame(
    chrom = "chr25", start = c(0, 7000),
    end = c(6000, 20000)
)
gintervals.liftover(intervs, chainfile)

</code></pre>

<hr>
<h2 id='gintervals.load'>Loads a named intervals set</h2><span id='topic+gintervals.load'></span>

<h3>Description</h3>

<p>Loads a named intervals set.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gintervals.load(
  intervals.set = NULL,
  chrom = NULL,
  chrom1 = NULL,
  chrom2 = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gintervals.load_+3A_intervals.set">intervals.set</code></td>
<td>
<p>name of an intervals set</p>
</td></tr>
<tr><td><code id="gintervals.load_+3A_chrom">chrom</code></td>
<td>
<p>chromosome for 1D intervals set</p>
</td></tr>
<tr><td><code id="gintervals.load_+3A_chrom1">chrom1</code></td>
<td>
<p>first chromosome for 2D intervals set</p>
</td></tr>
<tr><td><code id="gintervals.load_+3A_chrom2">chrom2</code></td>
<td>
<p>second chromosome for 2D intervals set</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function loads and returns intervals stored in a named intervals set.
</p>
<p>If intervals set contains 1D intervals and 'chrom' is not 'NULL' only the
intervals of the given chromosome are returned.
</p>
<p>Likewise if intervals set contains 2D intervals and 'chrom1', 'chrom2' are
not 'NULL' only the intervals of the given pair of chromosomes are returned.
</p>
<p>For big intervals sets 'chrom' parameter (1D case) / 'chrom1', 'chrom2'
parameters (2D case) must be specified. In other words: big intervals sets
can be loaded only by chromosome or chromosome pair.
</p>


<h3>Value</h3>

<p>A data frame representing the intervals.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gintervals.save">gintervals.save</a></code>, <code><a href="#topic+gintervals.is.bigset">gintervals.is.bigset</a></code>,
<code><a href="#topic+gintervals.exists">gintervals.exists</a></code>, <code><a href="#topic+gintervals.ls">gintervals.ls</a></code>,
<code><a href="#topic+gintervals">gintervals</a></code>, <code><a href="#topic+gintervals.2d">gintervals.2d</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

gdb.init_examples()
gintervals.load("annotations")

</code></pre>

<hr>
<h2 id='gintervals.load_chain'>Loads assembly conversion table from a chain file</h2><span id='topic+gintervals.load_chain'></span>

<h3>Description</h3>

<p>Loads assembly conversion table from a chain file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gintervals.load_chain(file = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gintervals.load_chain_+3A_file">file</code></td>
<td>
<p>name of chain file</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function reads a file in 'chain' format and returns assembly conversion
table that can be used in 'gtrack.liftover' and 'gintervals.liftover'.
</p>
<p>Note: chain file might map a few different source intervals into a single
target one. These ambiguous mappings are not presented in the data frame
returned by 'gintervals.load_chain'.
</p>


<h3>Value</h3>

<p>A data frame representing assembly conversion table.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gintervals.liftover">gintervals.liftover</a></code>, <code><a href="#topic+gtrack.liftover">gtrack.liftover</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

gdb.init_examples()
chainfile &lt;- paste(.misha$GROOT, "data/test.chain", sep = "/")
gintervals.load_chain(chainfile)

</code></pre>

<hr>
<h2 id='gintervals.ls'>Returns a list of named intervals sets</h2><span id='topic+gintervals.ls'></span>

<h3>Description</h3>

<p>Returns a list of named intervals sets in Genomic Database.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gintervals.ls(
  pattern = "",
  ignore.case = FALSE,
  perl = FALSE,
  fixed = FALSE,
  useBytes = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gintervals.ls_+3A_pattern">pattern</code>, <code id="gintervals.ls_+3A_ignore.case">ignore.case</code>, <code id="gintervals.ls_+3A_perl">perl</code>, <code id="gintervals.ls_+3A_fixed">fixed</code>, <code id="gintervals.ls_+3A_usebytes">useBytes</code></td>
<td>
<p>see 'grep'</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function returns a list of named intervals sets that match the pattern
(see 'grep'). If called without any arguments all named intervals sets are
returned.
</p>


<h3>Value</h3>

<p>An array that contains the names of intervals sets.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+grep">grep</a></code>, <code><a href="#topic+gintervals.exists">gintervals.exists</a></code>,
<code><a href="#topic+gintervals.load">gintervals.load</a></code>, <code><a href="#topic+gintervals.save">gintervals.save</a></code>,
<code><a href="#topic+gintervals.rm">gintervals.rm</a></code>, <code><a href="#topic+gintervals">gintervals</a></code>,
<code><a href="#topic+gintervals.2d">gintervals.2d</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

gdb.init_examples()
gintervals.ls()
gintervals.ls(pattern = "annot*")

</code></pre>

<hr>
<h2 id='gintervals.mapply'>Applies a function to values of track expressions</h2><span id='topic+gintervals.mapply'></span>

<h3>Description</h3>

<p>Applies a function to values of track expressions for each interval.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gintervals.mapply(
  FUN = NULL,
  ...,
  intervals = NULL,
  enable.gapply.intervals = FALSE,
  iterator = NULL,
  band = NULL,
  intervals.set.out = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gintervals.mapply_+3A_fun">FUN</code></td>
<td>
<p>function to apply, found via match.fun</p>
</td></tr>
<tr><td><code id="gintervals.mapply_+3A_...">...</code></td>
<td>
<p>track expressions whose values are used as arguments for 'FUN'</p>
</td></tr>
<tr><td><code id="gintervals.mapply_+3A_intervals">intervals</code></td>
<td>
<p>intervals for which track expressions are calculated</p>
</td></tr>
<tr><td><code id="gintervals.mapply_+3A_enable.gapply.intervals">enable.gapply.intervals</code></td>
<td>
<p>if 'TRUE', then a variable 'GAPPLY.INTERVALS'
is available</p>
</td></tr>
<tr><td><code id="gintervals.mapply_+3A_iterator">iterator</code></td>
<td>
<p>track expression iterator. If 'NULL' iterator is determined
implicitly based on track expressions.</p>
</td></tr>
<tr><td><code id="gintervals.mapply_+3A_band">band</code></td>
<td>
<p>track expression band. If 'NULL' no band is used.</p>
</td></tr>
<tr><td><code id="gintervals.mapply_+3A_intervals.set.out">intervals.set.out</code></td>
<td>
<p>intervals set name where the function result is
optionally outputted</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function evaluates track expressions for each interval from
'intervals'. The resulted vectors are passed then as arguments to 'FUN'.
</p>
<p>If the intervals are one-dimensional and have an additional column named
'strand' whose value is '-1', the values of the track expression are placed
to the vector in reverse order.
</p>
<p>The current interval index (1-based) is stored in 'GAPPLY.INTERVID' variable
that is available during the execution of 'gintervals.mapply'. There is no
guarantee about the order in which the intervals are processed. Do not rely
on any specific order and use 'GITERATOR.INTERVID' variable to detect the
current interval id.
</p>
<p>If 'enable.gapply.intervals' is 'TRUE', an additional variable
'GAPPLY.INTERVALS' is defined during the execution of 'gintervals.mapply'.
This variable stores the current iterator intervals prior to track
expression evaluation. Please note that setting 'enable.gapply.intervals' to
'TRUE' might severely affect the run-time of the function.
</p>
<p>Note: all the changes made in R environment by 'FUN' will be void if
multitasking mode is switched on. One should also refrain from performing
any other operations in 'FUN' that might be not &quot;thread-safe&quot; such as
updating files, etc. Please switch off multitasking ('options(gmultitasking
= FALSE)') if you wish to perform such operations.
</p>
<p>If 'intervals.set.out' is not 'NULL' the result is saved as an intervals
set. Use this parameter if the result size exceeds the limits of the
physical memory.
</p>


<h3>Value</h3>

<p>If 'intervals.set.out' is 'NULL' a data frame representing intervals
with an additional column that contains the return values of 'FUN'.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+mapply">mapply</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

gdb.init_examples()
gintervals.mapply(
    max, "dense_track",
    gintervals(c(1, 2), 0, 10000)
)
gintervals.mapply(
    function(x, y) {
        max(x + y)
    }, "dense_track",
    "sparse_track", gintervals(c(1, 2), 0, 10000),
    iterator = "sparse_track"
)

</code></pre>

<hr>
<h2 id='gintervals.neighbors'>Finds neighbors between two sets of intervals</h2><span id='topic+gintervals.neighbors'></span>

<h3>Description</h3>

<p>Finds neighbors between two sets of intervals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gintervals.neighbors(
  intervals1 = NULL,
  intervals2 = NULL,
  maxneighbors = 1,
  mindist = -1e+09,
  maxdist = 1e+09,
  mindist1 = -1e+09,
  maxdist1 = 1e+09,
  mindist2 = -1e+09,
  maxdist2 = 1e+09,
  na.if.notfound = FALSE,
  intervals.set.out = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gintervals.neighbors_+3A_intervals1">intervals1</code>, <code id="gintervals.neighbors_+3A_intervals2">intervals2</code></td>
<td>
<p>intervals</p>
</td></tr>
<tr><td><code id="gintervals.neighbors_+3A_maxneighbors">maxneighbors</code></td>
<td>
<p>maximal number of neighbors</p>
</td></tr>
<tr><td><code id="gintervals.neighbors_+3A_mindist">mindist</code>, <code id="gintervals.neighbors_+3A_maxdist">maxdist</code></td>
<td>
<p>distance range for 1D intervals</p>
</td></tr>
<tr><td><code id="gintervals.neighbors_+3A_mindist1">mindist1</code>, <code id="gintervals.neighbors_+3A_maxdist1">maxdist1</code>, <code id="gintervals.neighbors_+3A_mindist2">mindist2</code>, <code id="gintervals.neighbors_+3A_maxdist2">maxdist2</code></td>
<td>
<p>distance range for 2D intervals</p>
</td></tr>
<tr><td><code id="gintervals.neighbors_+3A_na.if.notfound">na.if.notfound</code></td>
<td>
<p>if 'TRUE' return 'NA' interval if no matching
neighbors were found, otherwise omit the interval in the answer</p>
</td></tr>
<tr><td><code id="gintervals.neighbors_+3A_intervals.set.out">intervals.set.out</code></td>
<td>
<p>intervals set name where the function result is
optionally outputted</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function finds for each interval in 'intervals1' the closest
'maxneighbors' intervals from 'intervals2'.
</p>
<p>For 1D intervals the distance must fall in the range of ['mindist',
'maxdist']. If 'intervals2' contains a 'strand' column the distance can be
positive or negative depending on the 'strand' value and the position of
interval2 relatively to interval1. If 'strand' column is missing the
distance is always positive.
</p>
<p>For 2D intervals two distances are calculated and returned for each axis.
The distances must fall in the range of ['mindist1', 'maxdist1'] for axis 1
and ['mindist2', 'maxdist2'] for axis 2. For selecting the closest
'maxneighbors' intervals Manhattan distance is used (i.e. dist1+dist2).
</p>
<p>The names of the returned columns are made unique using
<code>make.unique(colnames(df), sep = "")</code>, assuming 'df' is the result.
</p>
<p>If 'intervals.set.out' is not 'NULL' the result is saved as an intervals
set. Use this parameter if the result size exceeds the limits of the
physical memory.
</p>


<h3>Value</h3>

<p>If 'intervals.set.out' is 'NULL' a data frame containing the pairs
of intervals from 'intervals1', intervals from 'intervals2' and an
additional column named 'dist' ('dist1' and 'dist2' for 2D intervals)
representing the distance between the corresponding intervals. The intervals
from intervals2 would be changed to 'chrom1', 'start1', and 'end1' and for
2D intervals chrom11, start11, end11 and chrom22, start22, end22. If
'na.if.notfound' is 'TRUE', the data frame contains all the intervals from
'intervals1' including those for which no matching neighbor was found. For
the latter intervals an 'NA' neighboring interval is stated. If
'na.if.notfound' is 'FALSE', the data frame contains only intervals from
'intervals1' for which matching neighbor(s) was found.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gintervals">gintervals</a></code>,
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

gdb.init_examples()
intervs1 &lt;- giterator.intervals("dense_track",
    gintervals(1, 0, 4000),
    iterator = 233
)
intervs2 &lt;- giterator.intervals(
    "sparse_track",
    gintervals(1, 0, 2000)
)
gintervals.neighbors(intervs1, intervs2, 10,
    mindist = -300,
    maxdist = 500
)
intervs2$strand &lt;- c(1, 1, -1, 1)
gintervals.neighbors(intervs1, intervs2, 10,
    mindist = -300,
    maxdist = 500
)

</code></pre>

<hr>
<h2 id='gintervals.quantiles'>Calculates quantiles of a track expression for intervals</h2><span id='topic+gintervals.quantiles'></span>

<h3>Description</h3>

<p>Calculates quantiles of a track expression for intervals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gintervals.quantiles(
  expr = NULL,
  percentiles = 0.5,
  intervals = NULL,
  iterator = NULL,
  band = NULL,
  intervals.set.out = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gintervals.quantiles_+3A_expr">expr</code></td>
<td>
<p>track expression for which quantiles are calculated</p>
</td></tr>
<tr><td><code id="gintervals.quantiles_+3A_percentiles">percentiles</code></td>
<td>
<p>an array of percentiles of quantiles in [0, 1] range</p>
</td></tr>
<tr><td><code id="gintervals.quantiles_+3A_intervals">intervals</code></td>
<td>
<p>set of intervals</p>
</td></tr>
<tr><td><code id="gintervals.quantiles_+3A_iterator">iterator</code></td>
<td>
<p>track expression iterator. If 'NULL' iterator is determined
implicitly based on track expressions.</p>
</td></tr>
<tr><td><code id="gintervals.quantiles_+3A_band">band</code></td>
<td>
<p>track expression band. If 'NULL' no band is used.</p>
</td></tr>
<tr><td><code id="gintervals.quantiles_+3A_intervals.set.out">intervals.set.out</code></td>
<td>
<p>intervals set name where the function result is
optionally outputted</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function calculates quantiles of 'expr' for each interval in
'intervals'.
</p>
<p>If 'intervals.set.out' is not 'NULL' the result is saved as an intervals
set. Use this parameter if the result size exceeds the limits of the
physical memory.
</p>


<h3>Value</h3>

<p>If 'intervals.set.out' is 'NULL' a set of intervals with additional
columns representing quantiles for each percentile.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gquantiles">gquantiles</a></code>, <code><a href="#topic+gbins.quantiles">gbins.quantiles</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

gdb.init_examples()
intervs &lt;- gintervals(c(1, 2), 0, 5000)
gintervals.quantiles("dense_track",
    percentiles = c(0.5, 0.3, 0.9), intervs
)

</code></pre>

<hr>
<h2 id='gintervals.rbind'>Combines several sets of intervals</h2><span id='topic+gintervals.rbind'></span>

<h3>Description</h3>

<p>Combines several sets of intervals into one set.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gintervals.rbind(..., intervals.set.out = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gintervals.rbind_+3A_...">...</code></td>
<td>
<p>intervals sets to combine</p>
</td></tr>
<tr><td><code id="gintervals.rbind_+3A_intervals.set.out">intervals.set.out</code></td>
<td>
<p>intervals set name where the function result is
optionally outputted</p>
</td></tr>
<tr><td><code id="gintervals.rbind_+3A_intervals">intervals</code></td>
<td>
<p>intervals set</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function combines several intervals sets into one set. It works in a
similar manner as 'rbind' yet it is faster. Also it supports intervals sets
that are stored in files including the big intervals sets.
</p>
<p>If 'intervals.set.out' is not 'NULL' the result is saved as an intervals
set. If the format of the output intervals is set to be &quot;big&quot; (determined
implicitly based on the result size and options), the order of the resulted
intervals is altered as they are sorted by chromosome (or chromosomes pair -
for 2D).
</p>


<h3>Value</h3>

<p>If 'intervals.set.out' is 'NULL' a data frame combining intervals
sets.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gintervals">gintervals</a></code>, <code><a href="#topic+gintervals.2d">gintervals.2d</a></code>,
<code><a href="#topic+gintervals.canonic">gintervals.canonic</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

gdb.init_examples()

intervs1 &lt;- gextract("sparse_track", gintervals(c(1, 2), 1000, 4000))
intervs2 &lt;- gextract("sparse_track", gintervals(c(2, "X"), 2000, 5000))
gintervals.save("testintervs", intervs2)
gintervals.rbind(intervs1, "testintervs")
gintervals.rm("testintervs", force = TRUE)

</code></pre>

<hr>
<h2 id='gintervals.rm'>Deletes a named intervals set</h2><span id='topic+gintervals.rm'></span>

<h3>Description</h3>

<p>Deletes a named intervals set.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gintervals.rm(intervals.set = NULL, force = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gintervals.rm_+3A_intervals.set">intervals.set</code></td>
<td>
<p>name of an intervals set</p>
</td></tr>
<tr><td><code id="gintervals.rm_+3A_force">force</code></td>
<td>
<p>if 'TRUE', suppresses user confirmation of a named intervals set
removal</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function deletes a named intervals set from the Genomic Database. By
default 'gintervals.rm' requires the user to interactively confirm the
deletion. Set 'force' to 'TRUE' to suppress the user prompt.
</p>


<h3>Value</h3>

<p>None.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gintervals.save">gintervals.save</a></code>, <code><a href="#topic+gintervals.exists">gintervals.exists</a></code>,
<code><a href="#topic+gintervals.ls">gintervals.ls</a></code>, <code><a href="#topic+gintervals">gintervals</a></code>,
<code><a href="#topic+gintervals.2d">gintervals.2d</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

gdb.init_examples()
intervs &lt;- gintervals(c(1, 2))
gintervals.save("testintervs", intervs)
gintervals.ls()
gintervals.rm("testintervs", force = TRUE)
gintervals.ls()

</code></pre>

<hr>
<h2 id='gintervals.save'>Creates a named intervals set</h2><span id='topic+gintervals.save'></span>

<h3>Description</h3>

<p>Saves intervals to a named intervals set.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gintervals.save(intervals.set.out = NULL, intervals = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gintervals.save_+3A_intervals.set.out">intervals.set.out</code></td>
<td>
<p>name of the new intervals set</p>
</td></tr>
<tr><td><code id="gintervals.save_+3A_intervals">intervals</code></td>
<td>
<p>intervals to save</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function saves 'intervals' as a named intervals set.
</p>


<h3>Value</h3>

<p>None.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gintervals.rm">gintervals.rm</a></code>, <code><a href="#topic+gintervals.load">gintervals.load</a></code>,
<code><a href="#topic+gintervals.exists">gintervals.exists</a></code>, <code><a href="#topic+gintervals.ls">gintervals.ls</a></code>,
<code><a href="#topic+gintervals">gintervals</a></code>, <code><a href="#topic+gintervals.2d">gintervals.2d</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

gdb.init_examples()
intervs &lt;- gintervals(c(1, 2))
gintervals.save("testintervs", intervs)
gintervals.ls()
gintervals.rm("testintervs", force = TRUE)

</code></pre>

<hr>
<h2 id='gintervals.summary'>Calculates summary statistics of track expression for intervals</h2><span id='topic+gintervals.summary'></span>

<h3>Description</h3>

<p>Calculates summary statistics of track expression for intervals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gintervals.summary(
  expr = NULL,
  intervals = NULL,
  iterator = NULL,
  band = NULL,
  intervals.set.out = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gintervals.summary_+3A_expr">expr</code></td>
<td>
<p>track expression</p>
</td></tr>
<tr><td><code id="gintervals.summary_+3A_intervals">intervals</code></td>
<td>
<p>set of intervals</p>
</td></tr>
<tr><td><code id="gintervals.summary_+3A_iterator">iterator</code></td>
<td>
<p>track expression iterator. If 'NULL' iterator is determined
implicitly based on track expression.</p>
</td></tr>
<tr><td><code id="gintervals.summary_+3A_band">band</code></td>
<td>
<p>track expression band. If 'NULL' no band is used.</p>
</td></tr>
<tr><td><code id="gintervals.summary_+3A_intervals.set.out">intervals.set.out</code></td>
<td>
<p>intervals set name where the function result is
optionally outputted</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function returns summary statistics of a track expression for each
interval 'intervals': total number of bins, total number of bins whose value
is NaN, min, max, sum, mean and standard deviation of the values.
</p>
<p>If 'intervals.set.out' is not 'NULL' the result is saved as an intervals
set. Use this parameter if the result size exceeds the limits of the
physical memory.
</p>


<h3>Value</h3>

<p>If 'intervals.set.out' is 'NULL' a set of intervals with additional
columns representing summary statistics for each percentile and interval.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gsummary">gsummary</a></code>, <code><a href="#topic+gbins.summary">gbins.summary</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

gdb.init_examples()
intervs &lt;- gintervals(c(1, 2), 0, 5000)
gintervals.summary("dense_track", intervs)

</code></pre>

<hr>
<h2 id='gintervals.union'>Calculates a union of two sets of intervals</h2><span id='topic+gintervals.union'></span>

<h3>Description</h3>

<p>Calculates a union of two sets of intervals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gintervals.union(
  intervals1 = NULL,
  intervals2 = NULL,
  intervals.set.out = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gintervals.union_+3A_intervals1">intervals1</code>, <code id="gintervals.union_+3A_intervals2">intervals2</code></td>
<td>
<p>set of one-dimensional intervals</p>
</td></tr>
<tr><td><code id="gintervals.union_+3A_intervals.set.out">intervals.set.out</code></td>
<td>
<p>intervals set name where the function result is
optionally outputted</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function returns intervals that represent a genomic space covered by
either 'intervals1' or 'intervals2'.
</p>
<p>If 'intervals.set.out' is not 'NULL' the result is saved as an intervals
set. Use this parameter if the result size exceeds the limits of the
physical memory.
</p>


<h3>Value</h3>

<p>If 'intervals.set.out' is 'NULL' a data frame representing the union
of intervals.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gintervals.intersect">gintervals.intersect</a></code>, <code><a href="#topic+gintervals.diff">gintervals.diff</a></code>,
<code><a href="#topic+gintervals">gintervals</a></code>, <code><a href="#topic+gintervals.2d">gintervals.2d</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

gdb.init_examples()

intervs1 &lt;- gscreen("dense_track &gt; 0.15 &amp; dense_track &lt; 0.18")
intervs2 &lt;- gscreen("dense_track &gt;= 0.18 &amp; dense_track &lt; 0.2")

## 'intervs3' and 'intervs4' are identical
intervs3 &lt;- gintervals.union(intervs1, intervs2)
intervs4 &lt;- gscreen("dense_track &gt; 0.15 &amp; dense_track &lt; 0.2")

</code></pre>

<hr>
<h2 id='gintervals.update'>Updates a named intervals set</h2><span id='topic+gintervals.update'></span>

<h3>Description</h3>

<p>Updates a named intervals set.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gintervals.update(
  intervals.set = NULL,
  intervals = "",
  chrom = NULL,
  chrom1 = NULL,
  chrom2 = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gintervals.update_+3A_intervals.set">intervals.set</code></td>
<td>
<p>name of an intervals set</p>
</td></tr>
<tr><td><code id="gintervals.update_+3A_intervals">intervals</code></td>
<td>
<p>intervals or 'NULL'</p>
</td></tr>
<tr><td><code id="gintervals.update_+3A_chrom">chrom</code></td>
<td>
<p>chromosome for 1D intervals set</p>
</td></tr>
<tr><td><code id="gintervals.update_+3A_chrom1">chrom1</code></td>
<td>
<p>first chromosome for 2D intervals set</p>
</td></tr>
<tr><td><code id="gintervals.update_+3A_chrom2">chrom2</code></td>
<td>
<p>second chromosome for 2D intervals set</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function replaces all intervals of given chromosome (or chromosome
pair) within 'intervals.set' with 'intervals'. Chromosome is specified by
'chrom' for 1D intervals set or 'chrom1', 'chrom2' for 2D intervals set.
</p>
<p>If 'intervals' is 'NULL' all intervals of given chromosome are removed from
'intervals.set'.
</p>


<h3>Value</h3>

<p>None.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gintervals.save">gintervals.save</a></code>, <code><a href="#topic+gintervals.load">gintervals.load</a></code>,
<code><a href="#topic+gintervals.exists">gintervals.exists</a></code>, <code><a href="#topic+gintervals.ls">gintervals.ls</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

gdb.init_examples()
intervs &lt;- gscreen(
    "sparse_track &gt; 0.2",
    gintervals(c(1, 2), 0, 10000)
)
gintervals.save("testintervs", intervs)
gintervals.load("testintervs")
gintervals.update("testintervs", intervs[intervs$chrom == "chr2", ][1:5, ], chrom = 2)
gintervals.load("testintervs")
gintervals.update("testintervs", NULL, chrom = 2)
gintervals.load("testintervs")
gintervals.rm("testintervs", force = TRUE)

</code></pre>

<hr>
<h2 id='giterator.cartesian_grid'>Creates a cartesian-grid iterator</h2><span id='topic+giterator.cartesian_grid'></span>

<h3>Description</h3>

<p>Creates a cartesian grid two-dimensional iterator that can be used by any
function that accepts an iterator argument.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>giterator.cartesian_grid(
  intervals1 = NULL,
  expansion1 = NULL,
  intervals2 = NULL,
  expansion2 = NULL,
  min.band.idx = NULL,
  max.band.idx = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="giterator.cartesian_grid_+3A_intervals1">intervals1</code></td>
<td>
<p>one-dimensional intervals</p>
</td></tr>
<tr><td><code id="giterator.cartesian_grid_+3A_expansion1">expansion1</code></td>
<td>
<p>an array of integers that define expansion around
intervals1 centers</p>
</td></tr>
<tr><td><code id="giterator.cartesian_grid_+3A_intervals2">intervals2</code></td>
<td>
<p>one-dimensional intervals. If 'NULL' then 'intervals2' is
considered to be equal to 'intervals1'</p>
</td></tr>
<tr><td><code id="giterator.cartesian_grid_+3A_expansion2">expansion2</code></td>
<td>
<p>an array of integers that define expansion around
intervals2 centers. If 'NULL' then 'expansion2' is considered to be equal to
'expansion1'</p>
</td></tr>
<tr><td><code id="giterator.cartesian_grid_+3A_min.band.idx">min.band.idx</code>, <code id="giterator.cartesian_grid_+3A_max.band.idx">max.band.idx</code></td>
<td>
<p>integers that limit iterator intervals to
band</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function creates and returns a cartesian grid two-dimensional iterator
that can be used by any function that accepts an iterator argument.
</p>
<p>Assume 'centers1' and 'centers2' to be the central points of each interval
from 'intervals1' and 'intervals2', and 'C1', 'C2' to be two points from
'centers1', 'centers2' accordingly. Assume also that the values in
'expansion1' and 'expansion2' are unique and sorted.
</p>
<p>'giterator.cartesian_grid' creates a set of all possible unique and
non-overlapping two-dimensional intervals of form: '(chrom1, start1, end1,
chrom2, start2, end2)'. Each '(chrom1, start1, end1)' is created by taking a
point 'C1' - '(chrom1, coord1)' and converting it to 'start1' and 'end1'
such that 'start1 == coord1+E1[i]', 'end1 == coord1+E1[i+1]', where 'E1[i]'
is one of the sorted 'expansion1' values. Overlaps between rectangles or
expansion beyond the limits of chromosome are avoided.
</p>
<p>'min.band.idx' and 'max.band.idx' parameters control whether a pair of 'C1'
and 'C2' is skipped or not. If both of these parameters are not 'NULL' AND
if both 'C1' and 'C2' share the same chromosome AND the delta of indices of
'C1' and 'C2' ('C1 index - C2 index') lays within '[min.band.idx,
max.band.idx]' range - only then the pair will be used to create the
intervals. Otherwise 'C1-C2' pair is filtered out. Note: if 'min.band.idx'
and 'max.band.idx' are not 'NULL', i.e. band indices filtering is applied,
then 'intervals2' parameter must be set to 'NULL'.
</p>


<h3>Value</h3>

<p>A list containing the definition of cartesian iterator.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+giterator.intervals">giterator.intervals</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

gdb.init_examples()

intervs1 &lt;- gintervals(
    c(1, 1, 2), c(100, 300, 200),
    c(300, 500, 300)
)
intervs2 &lt;- gintervals(
    c(1, 2, 2), c(400, 1000, 3000),
    c(800, 2000, 4000)
)
itr &lt;- giterator.cartesian_grid(
    intervs1, c(-20, 100), intervs2,
    c(-40, -10, 50)
)
giterator.intervals(iterator = itr)

itr &lt;- giterator.cartesian_grid(intervs1, c(-20, 50, 100))
giterator.intervals(iterator = itr)

itr &lt;- giterator.cartesian_grid(intervs1, c(-20, 50, 100),
    min.band.idx = -1,
    max.band.idx = 0
)
giterator.intervals(iterator = itr)

</code></pre>

<hr>
<h2 id='giterator.intervals'>Returns iterator intervals</h2><span id='topic+giterator.intervals'></span>

<h3>Description</h3>

<p>Returns iterator intervals given track expression, scope, iterator and band.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>giterator.intervals(
  expr = NULL,
  intervals = .misha$ALLGENOME,
  iterator = NULL,
  band = NULL,
  intervals.set.out = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="giterator.intervals_+3A_expr">expr</code></td>
<td>
<p>track expression</p>
</td></tr>
<tr><td><code id="giterator.intervals_+3A_intervals">intervals</code></td>
<td>
<p>genomic scope</p>
</td></tr>
<tr><td><code id="giterator.intervals_+3A_iterator">iterator</code></td>
<td>
<p>track expression iterator. If 'NULL' iterator is determined
implicitly based on track expression.</p>
</td></tr>
<tr><td><code id="giterator.intervals_+3A_band">band</code></td>
<td>
<p>track expression band. If 'NULL' no band is used.</p>
</td></tr>
<tr><td><code id="giterator.intervals_+3A_intervals.set.out">intervals.set.out</code></td>
<td>
<p>intervals set name where the function result is
optionally outputted</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function returns a set of intervals used by the iterator intervals for
the given track expression, genomic scope, iterator and band. Some functions
accept an iterator without accepting a track expression (like
'gtrack.create_pwm_energy'). These functions generate the values for each
iterator interval by themselves. Use set 'expr' to 'NULL' to simulate the
work of these functions.
</p>
<p>If 'intervals.set.out' is not 'NULL' the result is saved as an intervals
set. Use this parameter if the result size exceeds the limits of the
physical memory.
</p>


<h3>Value</h3>

<p>If 'intervals.set.out' is 'NULL' a data frame representing iterator
intervals.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+giterator.cartesian_grid">giterator.cartesian_grid</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

gdb.init_examples()

## iterator is set implicitly to bin size of 'dense' track
giterator.intervals("dense_track", gintervals(1, 0, 200))

## iterator = 30
giterator.intervals("dense_track", gintervals(1, 0, 200), 30)

## iterator is an intervals set named 'annotations'
giterator.intervals("dense_track", .misha$ALLGENOME, "annotations")

## iterator is set implicitly to intervals of 'array_track' track
giterator.intervals("array_track", gintervals(1, 0, 200))

## iterator is a rectangle 100000 by 50000
giterator.intervals(
    "rects_track",
    gintervals.2d(chroms1 = 1, chroms2 = "chrX"),
    c(100000, 50000)
)

</code></pre>

<hr>
<h2 id='glookup'>Returns values from a lookup table based on track expression</h2><span id='topic+glookup'></span>

<h3>Description</h3>

<p>Evaluates track expression and translates the values into bin indices that
are used in turn to retrieve and return values from a lookup table.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>glookup(
  lookup_table = NULL,
  ...,
  intervals = NULL,
  include.lowest = FALSE,
  force.binning = TRUE,
  iterator = NULL,
  band = NULL,
  intervals.set.out = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="glookup_+3A_lookup_table">lookup_table</code></td>
<td>
<p>a multi-dimensional array containing the values that are
returned by the function</p>
</td></tr>
<tr><td><code id="glookup_+3A_...">...</code></td>
<td>
<p>pairs of 'expr', 'breaks' where 'expr' is a track expression and the breaks determine the bin</p>
</td></tr>
<tr><td><code id="glookup_+3A_intervals">intervals</code></td>
<td>
<p>genomic scope for which the function is applied</p>
</td></tr>
<tr><td><code id="glookup_+3A_include.lowest">include.lowest</code></td>
<td>
<p>if 'TRUE', the lowest value of the range determined by
breaks is included</p>
</td></tr>
<tr><td><code id="glookup_+3A_force.binning">force.binning</code></td>
<td>
<p>if 'TRUE', the values smaller than the minimal break
will be translated to index 1, and the values that exceed the maximal break
will be translated to index N-1 where N is the number of breaks. If 'FALSE'
the out-of-range values will produce NaN values.</p>
</td></tr>
<tr><td><code id="glookup_+3A_iterator">iterator</code></td>
<td>
<p>track expression iterator. If 'NULL' iterator is determined
implicitly based on track expressions.</p>
</td></tr>
<tr><td><code id="glookup_+3A_band">band</code></td>
<td>
<p>track expression band. If 'NULL' no band is used.</p>
</td></tr>
<tr><td><code id="glookup_+3A_intervals.set.out">intervals.set.out</code></td>
<td>
<p>intervals set name where the function result is
optionally outputted</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function evaluates the track expression for all iterator intervals and
translates this value into an index based on the breaks. This index is then
used to address the lookup table and return the according value. More than
one 'expr'-'breaks' pair can be used. In that case 'lookup_table' is
addressed in a multidimensional manner, i.e. 'lookup_table[i1, i2, ...]'.
</p>
<p>The range of bins is determined by 'breaks' argument. For example: 'breaks =
c(x1, x2, x3, x4)' represents three different intervals (bins): (x1, x2],
(x2, x3], (x3, x4].
</p>
<p>If 'include.lowest' is 'TRUE' then the lowest value is included in the first
interval, i.e. in [x1, x2].
</p>
<p>'force.binning' parameter controls what should be done when the value of
'expr' exceeds the range determined by 'breaks'. If 'force.binning' is
'TRUE' then values smaller than the minimal break will be translated to
index 1, and the values exceeding the maximal break will be translated to
index 'M-1' where 'M' is the number of breaks. If 'force.binning' is 'FALSE'
the out-of-range values will produce 'NaN' values.
</p>
<p>Regardless of 'force.binning' value if the value of 'expr' is 'NaN' then
result is 'NaN' too.
</p>
<p>The order inside the result might not be the same as the order of intervals.
Use 'intervalID' column to refer to the index of the original interval from
the supplied 'intervals'.
</p>
<p>If 'intervals.set.out' is not 'NULL' the result (without 'columnID' column)
is saved as an intervals set. Use this parameter if the result size exceeds
the limits of the physical memory.
</p>


<h3>Value</h3>

<p>If 'intervals.set.out' is 'NULL' a set of intervals with additional
'value' and 'columnID' columns.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gtrack.lookup">gtrack.lookup</a></code>, <code><a href="#topic+gextract">gextract</a></code>,
<code><a href="#topic+gpartition">gpartition</a></code>, <code><a href="#topic+gdist">gdist</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

gdb.init_examples()

## one-dimensional lookup table
breaks1 &lt;- seq(0.1, 0.2, length.out = 6)
glookup(1:5, "dense_track", breaks1, gintervals(1, 0, 200))

## two-dimensional lookup table
t &lt;- array(1:15, dim = c(5, 3))
breaks2 &lt;- seq(0.31, 0.37, length.out = 4)
glookup(
    t, "dense_track", breaks1, "2 * dense_track", breaks2,
    gintervals(1, 0, 200)
)

</code></pre>

<hr>
<h2 id='gpartition'>Partitions the values of track expression</h2><span id='topic+gpartition'></span>

<h3>Description</h3>

<p>Converts the values of track expression to intervals that match
corresponding bin.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gpartition(
  expr = NULL,
  breaks = NULL,
  intervals = NULL,
  include.lowest = FALSE,
  iterator = NULL,
  band = NULL,
  intervals.set.out = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gpartition_+3A_expr">expr</code></td>
<td>
<p>track expression</p>
</td></tr>
<tr><td><code id="gpartition_+3A_breaks">breaks</code></td>
<td>
<p>breaks that determine the bin</p>
</td></tr>
<tr><td><code id="gpartition_+3A_intervals">intervals</code></td>
<td>
<p>genomic scope for which the function is applied</p>
</td></tr>
<tr><td><code id="gpartition_+3A_include.lowest">include.lowest</code></td>
<td>
<p>if 'TRUE', the lowest value of the range determined by
breaks is included</p>
</td></tr>
<tr><td><code id="gpartition_+3A_iterator">iterator</code></td>
<td>
<p>track expression iterator. If 'NULL' iterator is determined
implicitly based on track expression.</p>
</td></tr>
<tr><td><code id="gpartition_+3A_band">band</code></td>
<td>
<p>track expression band. If 'NULL' no band is used.</p>
</td></tr>
<tr><td><code id="gpartition_+3A_intervals.set.out">intervals.set.out</code></td>
<td>
<p>intervals set name where the function result is
optionally outputted</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function converts first the values of track expression into 1-based
bin's index according 'breaks' argument. It returns then the intervals with
the corresponding bin's index.
</p>
<p>The range of bins is determined by 'breaks' argument. For example:
'breaks=c(x1, x2, x3, x4)' represents three different intervals (bins): (x1,
x2], (x2, x3], (x3, x4].
</p>
<p>If 'include.lowest' is 'TRUE' the the lowest value will be included in the
first interval, i.e. in [x1, x2].
</p>
<p>If 'intervals.set.out' is not 'NULL' the result is saved as an intervals
set. Use this parameter if the result size exceeds the limits of the
physical memory.
</p>


<h3>Value</h3>

<p>If 'intervals.set.out' is 'NULL' a set of intervals with an
additional column that indicates the corresponding bin index.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gscreen">gscreen</a></code>, <code><a href="#topic+gextract">gextract</a></code>,
<code><a href="#topic+glookup">glookup</a></code>, <code><a href="#topic+gdist">gdist</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

gdb.init_examples()
breaks &lt;- seq(0, 0.2, by = 0.05)
gpartition("dense_track", breaks, gintervals(1, 0, 5000))

</code></pre>

<hr>
<h2 id='gquantiles'>Calculates quantiles of a track expression</h2><span id='topic+gquantiles'></span>

<h3>Description</h3>

<p>Calculates the quantiles of a track expression for the given percentiles.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gquantiles(
  expr = NULL,
  percentiles = 0.5,
  intervals = get("ALLGENOME", envir = .misha),
  iterator = NULL,
  band = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gquantiles_+3A_expr">expr</code></td>
<td>
<p>track expression</p>
</td></tr>
<tr><td><code id="gquantiles_+3A_percentiles">percentiles</code></td>
<td>
<p>an array of percentiles of quantiles in [0, 1] range</p>
</td></tr>
<tr><td><code id="gquantiles_+3A_intervals">intervals</code></td>
<td>
<p>genomic scope for which the function is applied</p>
</td></tr>
<tr><td><code id="gquantiles_+3A_iterator">iterator</code></td>
<td>
<p>track expression iterator. If 'NULL' iterator is determined
implicitly based on track expression.</p>
</td></tr>
<tr><td><code id="gquantiles_+3A_band">band</code></td>
<td>
<p>track expression band. If 'NULL' no band is used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function calculates the quantiles for the given percentiles.
</p>
<p>If data size exceeds the limit (see: 'getOption(gmax.data.size)'), the data
is randomly sampled to fit the limit. A warning message is generated. The
seed of the pseudo-random generator can be controlled through 'grnd.seed'
option.
</p>
<p>Note: this function is capable to run in multitasking mode. Sampling may
vary according to the extent of multitasking. Since multitasking depends on
the number of available CPU cores, running the function on two different
machines might give different results. Please switch off multitasking if you
want to achieve identical results on any machine. For more information
regarding multitasking please refer &quot;User Manual&quot;.
</p>


<h3>Value</h3>

<p>An array that represent quantiles.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gbins.quantiles">gbins.quantiles</a></code>, <code><a href="#topic+gintervals.quantiles">gintervals.quantiles</a></code>,
<code><a href="#topic+gdist">gdist</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

gdb.init_examples()
gquantiles("dense_track", c(0.1, 0.6, 0.8), gintervals(c(1, 2)))

</code></pre>

<hr>
<h2 id='grevcomp'>Get reverse complement of DNA sequence</h2><span id='topic+grevcomp'></span>

<h3>Description</h3>

<p>Takes a DNA sequence string and returns its reverse complement.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grevcomp(seq)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="grevcomp_+3A_seq">seq</code></td>
<td>
<p>A character vector containing DNA sequences (using A,C,G,T). Ignores other characters and NA values.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector of the same length as the input, containing the reverse
complement sequences
</p>


<h3>Examples</h3>

<pre><code class='language-R'>grevcomp("ACTG") # Returns "CAGT"
grevcomp(c("ACTG", "GGCC")) # Returns c("CAGT", "GGCC")
grevcomp(c("ACTG", NA, "GGCC")) # Returns c("CAGT", NA, "GGCC")

</code></pre>

<hr>
<h2 id='gsample'>Returns samples from the values of track expression</h2><span id='topic+gsample'></span>

<h3>Description</h3>

<p>Returns a sample of the specified size from the values of track expression.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gsample(expr = NULL, n = NULL, intervals = NULL, iterator = NULL, band = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gsample_+3A_expr">expr</code></td>
<td>
<p>track expression</p>
</td></tr>
<tr><td><code id="gsample_+3A_n">n</code></td>
<td>
<p>a number of items to choose</p>
</td></tr>
<tr><td><code id="gsample_+3A_intervals">intervals</code></td>
<td>
<p>genomic scope for which the function is applied</p>
</td></tr>
<tr><td><code id="gsample_+3A_iterator">iterator</code></td>
<td>
<p>track expression iterator. If 'NULL' iterator is determined
implicitly based on track expression.</p>
</td></tr>
<tr><td><code id="gsample_+3A_band">band</code></td>
<td>
<p>track expression band. If 'NULL' no band is used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function returns a sample of the specified size from the values of
track expression. If 'n' is less than the total number of values, the data
is randomly sampled. The seed of the pseudo-random generator can be
controlled through 'grnd.seed' option.
</p>
<p>If 'n' is higher than the total number of values, all values are returned
(yet reshuffled).
</p>


<h3>Value</h3>

<p>An array that represent quantiles.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gextract">gextract</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

gdb.init_examples()
gsample("sparse_track", 10)

</code></pre>

<hr>
<h2 id='gscreen'>Finds intervals that match track expression</h2><span id='topic+gscreen'></span>

<h3>Description</h3>

<p>Finds all intervals where track expression is 'TRUE'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gscreen(
  expr = NULL,
  intervals = NULL,
  iterator = NULL,
  band = NULL,
  intervals.set.out = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gscreen_+3A_expr">expr</code></td>
<td>
<p>logical track expression</p>
</td></tr>
<tr><td><code id="gscreen_+3A_intervals">intervals</code></td>
<td>
<p>genomic scope for which the function is applied</p>
</td></tr>
<tr><td><code id="gscreen_+3A_iterator">iterator</code></td>
<td>
<p>track expression iterator. If 'NULL' iterator is determined
implicitly based on track expression.</p>
</td></tr>
<tr><td><code id="gscreen_+3A_band">band</code></td>
<td>
<p>track expression band. If 'NULL' no band is used.</p>
</td></tr>
<tr><td><code id="gscreen_+3A_intervals.set.out">intervals.set.out</code></td>
<td>
<p>intervals set name where the function result is
optionally outputted</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function finds all intervals where track expression's value is 'TRUE'.
</p>
<p>If 'intervals.set.out' is not 'NULL' the result is saved as an intervals
set. Use this parameter if the result size exceeds the limits of the
physical memory.
</p>


<h3>Value</h3>

<p>If 'intervals.set.out' is 'NULL' a set of intervals that match track
expression.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gsegment">gsegment</a></code>, <code><a href="#topic+gextract">gextract</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

gdb.init_examples()
gscreen("dense_track &gt; 0.2 &amp; sparse_track &lt; 0.4",
    iterator = "dense_track"
)

</code></pre>

<hr>
<h2 id='gsegment'>Divides track expression into segments</h2><span id='topic+gsegment'></span>

<h3>Description</h3>

<p>Divides the values of track expression into segments by using Wilcoxon test.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gsegment(
  expr = NULL,
  minsegment = NULL,
  maxpval = 0.05,
  onetailed = TRUE,
  intervals = NULL,
  iterator = NULL,
  intervals.set.out = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gsegment_+3A_expr">expr</code></td>
<td>
<p>track expression</p>
</td></tr>
<tr><td><code id="gsegment_+3A_minsegment">minsegment</code></td>
<td>
<p>minimal segment size</p>
</td></tr>
<tr><td><code id="gsegment_+3A_maxpval">maxpval</code></td>
<td>
<p>maximal P-value that separates two adjacent segments</p>
</td></tr>
<tr><td><code id="gsegment_+3A_onetailed">onetailed</code></td>
<td>
<p>if 'TRUE', Wilcoxon test is performed one tailed, otherwise
two tailed</p>
</td></tr>
<tr><td><code id="gsegment_+3A_intervals">intervals</code></td>
<td>
<p>genomic scope for which the function is applied</p>
</td></tr>
<tr><td><code id="gsegment_+3A_iterator">iterator</code></td>
<td>
<p>track expression iterator of &quot;fixed bin&quot; type. If 'NULL'
iterator is determined implicitly based on track expression.</p>
</td></tr>
<tr><td><code id="gsegment_+3A_intervals.set.out">intervals.set.out</code></td>
<td>
<p>intervals set name where the function result is
optionally outputted</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function divides the values of track expression into segments, where
each segment size is at least of 'minsegment' size and the P-value of
comparing the segment with the first 'minsegment' values from the next
segment is at most 'maxpval'. Comparison is done using Wilcoxon (also known
as Mann-Whitney) test.
</p>
<p>If 'intervals.set.out' is not 'NULL' the result is saved as an intervals
set. Use this parameter if the result size exceeds the limits of the
physical memory.
</p>


<h3>Value</h3>

<p>If 'intervals.set.out' is 'NULL' a set of intervals where each
interval represents a segment.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gscreen">gscreen</a></code>, <code><a href="#topic+gwilcox">gwilcox</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

gdb.init_examples()
gsegment("dense_track", 5000, 0.0001)

</code></pre>

<hr>
<h2 id='gseq.extract'>Returns DNA sequences</h2><span id='topic+gseq.extract'></span>

<h3>Description</h3>

<p>Returns DNA sequences for given intervals
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gseq.extract(intervals = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gseq.extract_+3A_intervals">intervals</code></td>
<td>
<p>intervals for which DNA sequence is returned</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function returns an array of sequence strings for each interval from
'intervals'. If intervals contain an additional 'strand' column and its
value is '-1', the reverse-complementary sequence is returned.
</p>


<h3>Value</h3>

<p>An array of character strings representing DNA sequence.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gextract">gextract</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

gdb.init_examples()
intervs &lt;- gintervals(c(1, 2), 10000, 10020)
gseq.extract(intervs)

</code></pre>

<hr>
<h2 id='gsetroot'>Initializes connection with Genomic Database</h2><span id='topic+gsetroot'></span><span id='topic+gdb.init'></span><span id='topic+gdb.init.examples'></span><span id='topic+gdb.init_examples'></span>

<h3>Description</h3>

<p>Initializes connection with Genomic Database: loads the list of tracks,
intervals, etc.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gsetroot(groot = NULL, dir = NULL, rescan = FALSE)

gdb.init(groot = NULL, dir = NULL, rescan = FALSE)

gdb.init_examples()
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gsetroot_+3A_groot">groot</code></td>
<td>
<p>the root directory of the Genomic Database</p>
</td></tr>
<tr><td><code id="gsetroot_+3A_dir">dir</code></td>
<td>
<p>the current working directory inside the Genomic Database</p>
</td></tr>
<tr><td><code id="gsetroot_+3A_rescan">rescan</code></td>
<td>
<p>indicates whether the file structure should be rescanned</p>
</td></tr>
</table>


<h3>Details</h3>

<p>'gdb.init' initializes the connection with the Genomic Database. It is
typically called first prior to any other function. When the package is
attached it internally calls to 'gdb.init.examples' which opens the
connection with the database located at 'PKGDIR/trackdb/test' directory,
where 'PKGDIR' is the directory where the package is installed.
</p>
<p>The current working directory inside the Genomic Database is set to 'dir'.
If 'dir' is 'NULL', the current working directory is set to 'GROOT/tracks'.
</p>
<p>If 'rescan' is 'TRUE', the list of tracks and intervals is achieved by
rescanning directory structure under the current current working directory.
Otherwise 'gdb.init' attempts to use the cached list that resides in
'groot/.db.cache' file.
</p>
<p>Upon completion the connection is established with the database. If
auto-completion mode is switched on (see 'gset_input_method') the list of
tracks and intervals sets is loaded and added as variables to the global
environment allowing auto-completion of object names with &lt;TAB&gt; key. Also a
few variables are defined at an environment called <code>.misha</code>, and can be
accessed using <code>.misha$variable</code>, e.g. <code>.misha$ALLGENOME</code>.
These variables should not be modified by user.
</p>

<table>
<tr>
 <td style="text-align: left;"> GROOT </td><td style="text-align: left;"> Root directory of Genomic Database</td>
</tr>
<tr>
 <td style="text-align: left;"> GWD </td><td style="text-align: left;">
Current working directory inside Genomic Database</td>
</tr>
<tr>
 <td style="text-align: left;"> GTRACKS </td><td style="text-align: left;"> List of
all available tracks</td>
</tr>
<tr>
 <td style="text-align: left;"> GINTERVS </td><td style="text-align: left;"> List of all available intervals</td>
</tr>
<tr>
 <td style="text-align: left;">
GVTRACKS </td><td style="text-align: left;"> List of all available virtual tracks</td>
</tr>
<tr>
 <td style="text-align: left;"> ALLGENOME </td><td style="text-align: left;"> List of
all chromosomes and their sizes</td>
</tr>
<tr>
 <td style="text-align: left;"> GITERATOR.INTERVALS </td><td style="text-align: left;"> A set of
iterator intervals for which the track expression is evaluated</td>
</tr>
<tr>
 <td style="text-align: left;"> </td>
</tr>

</table>



<h3>Value</h3>

<p>None.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gdb.reload">gdb.reload</a></code>, <code><a href="#topic+gdb.create">gdb.create</a></code>,
<code><a href="#topic+gdir.cd">gdir.cd</a></code>, <code><a href="#topic+gtrack.ls">gtrack.ls</a></code>, <code><a href="#topic+gintervals.ls">gintervals.ls</a></code>,
<code><a href="#topic+gvtrack.ls">gvtrack.ls</a></code>
</p>

<hr>
<h2 id='gsummary'>Calculates summary statistics of track expression</h2><span id='topic+gsummary'></span>

<h3>Description</h3>

<p>Calculates summary statistics of track expression.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gsummary(expr = NULL, intervals = NULL, iterator = NULL, band = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gsummary_+3A_expr">expr</code></td>
<td>
<p>track expression</p>
</td></tr>
<tr><td><code id="gsummary_+3A_intervals">intervals</code></td>
<td>
<p>genomic scope for which the function is applied</p>
</td></tr>
<tr><td><code id="gsummary_+3A_iterator">iterator</code></td>
<td>
<p>track expression iterator. If 'NULL' iterator is determined
implicitly based on track expression.</p>
</td></tr>
<tr><td><code id="gsummary_+3A_band">band</code></td>
<td>
<p>track expression band. If 'NULL' no band is used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function returns summary statistics of a track expression: total number
of bins, total number of bins whose value is NaN, min, max, sum, mean and
standard deviation of the values.
</p>


<h3>Value</h3>

<p>An array that represents summary statistics.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gintervals.summary">gintervals.summary</a></code>, <code><a href="#topic+gbins.summary">gbins.summary</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

gdb.init_examples()
gsummary("rects_track")

</code></pre>

<hr>
<h2 id='gtrack.2d.create'>Creates a 'Rectangles' track from intervals and values</h2><span id='topic+gtrack.2d.create'></span>

<h3>Description</h3>

<p>Creates a 'Rectangles' track from intervals and values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gtrack.2d.create(
  track = NULL,
  description = NULL,
  intervals = NULL,
  values = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gtrack.2d.create_+3A_track">track</code></td>
<td>
<p>track name</p>
</td></tr>
<tr><td><code id="gtrack.2d.create_+3A_description">description</code></td>
<td>
<p>a character string description</p>
</td></tr>
<tr><td><code id="gtrack.2d.create_+3A_intervals">intervals</code></td>
<td>
<p>a set of two-dimensional intervals</p>
</td></tr>
<tr><td><code id="gtrack.2d.create_+3A_values">values</code></td>
<td>
<p>an array of numeric values - one for each interval</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function creates a new 'Rectangles' (two-dimensional) track with values
at given intervals. 'description' is added as a track attribute.
</p>


<h3>Value</h3>

<p>None.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gtrack.create">gtrack.create</a></code>, <code><a href="#topic+gtrack.create_sparse">gtrack.create_sparse</a></code>,
<code><a href="#topic+gtrack.smooth">gtrack.smooth</a></code>, <code><a href="#topic+gtrack.modify">gtrack.modify</a></code>,
<code><a href="#topic+gtrack.rm">gtrack.rm</a></code>, <code><a href="#topic+gtrack.info">gtrack.info</a></code>,
<code><a href="#topic+gdir.create">gdir.create</a></code>, <code><a href="#topic+gtrack.attr.get">gtrack.attr.get</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

gdb.init_examples()
intervs1 &lt;- gintervals.2d(
    1, (1:4) * 200, (1:4) * 200 + 100,
    1, (1:4) * 300, (1:4) * 300 + 200
)
intervs2 &lt;- gintervals.2d(
    "X", (7:10) * 100, (7:10) * 100 + 50,
    2, (1:4) * 200, (1:4) * 200 + 130
)
intervs &lt;- rbind(intervs1, intervs2)
gtrack.2d.create(
    "test_rects", "Test 2d track", intervs,
    runif(dim(intervs)[1], 1, 100)
)
gextract("test_rects", .misha$ALLGENOME)
gtrack.rm("test_rects", force = TRUE)

</code></pre>

<hr>
<h2 id='gtrack.2d.import'>Creates a 2D track from tab-delimited file</h2><span id='topic+gtrack.2d.import'></span>

<h3>Description</h3>

<p>Creates a 2D track from tab-delimited file(s).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gtrack.2d.import(track = NULL, description = NULL, file = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gtrack.2d.import_+3A_track">track</code></td>
<td>
<p>track name</p>
</td></tr>
<tr><td><code id="gtrack.2d.import_+3A_description">description</code></td>
<td>
<p>a character string description</p>
</td></tr>
<tr><td><code id="gtrack.2d.import_+3A_file">file</code></td>
<td>
<p>vector of file paths</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function creates a 2D track track from one or more tab-delimited files.
Each file must start with a header describing the columns. The first 6
columns must have the following names: 'chrom1', 'start1', 'end1', 'chrom2',
'start2', 'end2'. The last column is designated for the value and it may
have an arbitrary name. The header is followed by a list of intervals and a
value for each interval. Overlapping intervals are forbidden.
</p>
<p>One can learn about the format of the tab-delimited file by running
'gextract' function on a 2D track with a 'file' parameter set to the name of
the file.
</p>
<p>If all the imported intervals represent a point (i.e. end == start + 1) a
'Points' track is created otherwise it is a 'Rectangles' track.
</p>
<p>'description' is added as a track attribute.
</p>
<p>Note: temporary files are created in the directory of the track during the
run of the function. A few of them need to be kept simultaneously open. If
the number of chromosomes and / or intervals is particularly high, a few
thousands files might be needed to be opened simultaneously. Some operating
systems limit the number of open files per user, in which case the function
might fail with &quot;Too many open files&quot; or similar error. The workaround could
be:
</p>
<p>1. Increase the limit of simultaneously opened files (the way varies
depending on your operating system). 2. Increase the value of
'gmax.data.size' option. Higher values of 'gmax.data.size' option will
increased memory usage of the function but create fewer temporary files.
</p>


<h3>Value</h3>

<p>None.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gtrack.rm">gtrack.rm</a></code>, <code><a href="#topic+gtrack.info">gtrack.info</a></code>,
<code><a href="#topic+gdir.create">gdir.create</a></code>
</p>

<hr>
<h2 id='gtrack.2d.import_contacts'>Creates a track from a file of inter-genomic contacts</h2><span id='topic+gtrack.2d.import_contacts'></span>

<h3>Description</h3>

<p>Creates a track from a file of inter-genomic contacts.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gtrack.2d.import_contacts(
  track = NULL,
  description = NULL,
  contacts = NULL,
  fends = NULL,
  allow.duplicates = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gtrack.2d.import_contacts_+3A_track">track</code></td>
<td>
<p>track name</p>
</td></tr>
<tr><td><code id="gtrack.2d.import_contacts_+3A_description">description</code></td>
<td>
<p>a character string description</p>
</td></tr>
<tr><td><code id="gtrack.2d.import_contacts_+3A_contacts">contacts</code></td>
<td>
<p>vector of contacts files</p>
</td></tr>
<tr><td><code id="gtrack.2d.import_contacts_+3A_fends">fends</code></td>
<td>
<p>name of fragment ends file</p>
</td></tr>
<tr><td><code id="gtrack.2d.import_contacts_+3A_allow.duplicates">allow.duplicates</code></td>
<td>
<p>if 'TRUE' duplicated contacts are allowed</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function creates a 'Points' (two-dimensional) track from contacts
files. If 'allow.duplicates' is 'TRUE' duplicated contacts are allowed and
summed up, otherwise an error is reported.
</p>
<p>Contacts (coord1, coord2) within the same chromosome are automatically
doubled to include also '(coord2, coord1)' unless 'coord1' equals to
'coord2'.
</p>
<p>Contacts may come in one or more files.
</p>
<p>If 'fends' is 'NULL' contacts file is expected to be in &quot;intervals-value&quot;
tab-separated format. The file starts with a header defining the column
names. The first 6 columns must have the following names: 'chrom1',
'start1', 'end1', 'chrom2', 'start2', 'end2'. The last column is designated
for the value and it may have an arbitrary name. The header is followed by a
list of intervals and a value for each interval. An interval of form
(chrom1, start1, end1, chrom2, start2, end2) is added as a point (X, Y) to
the resulted track where X = (start1 + end1) / 2 and Y = (start2 + end2) /
2.
</p>
<p>One can see an example of &quot;intervals-value&quot; format by running 'gextract'
function on a 2D track with a 'file' parameter set to the name of the file.
</p>
<p>If 'fends' is not 'NULL' contacts file is expected to be in &quot;fends-value&quot;
tab-separated format. It should start with a header containing at least 3
column names 'fend1', 'fend2' and 'count' in arbitrary order followed by
lines each defining a contact between two fragment ends.
</p>

<table>
<tr>
 <td style="text-align: left;"> COLUMN </td><td style="text-align: left;"> VALUE </td><td style="text-align: left;"> DESCRIPTION</td>
</tr>
<tr>
 <td style="text-align: left;"> fend1 </td><td style="text-align: left;"> Integer </td><td style="text-align: left;">
ID of the first fragment end </td>
</tr>
<tr>
 <td style="text-align: left;"> fend2 </td><td style="text-align: left;"> Integer </td><td style="text-align: left;"> ID of the second
fragment end </td>
</tr>
<tr>
 <td style="text-align: left;"> count </td><td style="text-align: left;"> Numeric </td><td style="text-align: left;"> Value associated with the contact
</td>
</tr>
<tr>
 <td style="text-align: left;"> </td>
</tr>

</table>

<p>A fragment ends file is also in tab-separated format. It should start with a
header containing at least 3 column names 'fend', 'chr' and 'coord' in
arbitrary order followed by lines each defining a single fragment end.
</p>

<table>
<tr>
 <td style="text-align: left;"> COLUMN </td><td style="text-align: left;"> VALUE </td><td style="text-align: left;"> DESCRIPTION</td>
</tr>
<tr>
 <td style="text-align: left;"> fend </td><td style="text-align: left;"> Unique
integer </td><td style="text-align: left;"> ID of the fragment end </td>
</tr>
<tr>
 <td style="text-align: left;"> chr </td><td style="text-align: left;"> Chromosome name </td><td style="text-align: left;"> Can be
specified with or without "chr" prefix, like: "X" or "chrX" </td>
</tr>
<tr>
 <td style="text-align: left;"> coord </td><td style="text-align: left;">
Integer </td><td style="text-align: left;"> Coordinate</td>
</tr>
<tr>
 <td style="text-align: left;"> </td>
</tr>

</table>

<p>'description' is added as a track attribute.
</p>
<p>Note: temporary files are created in the directory of the track during the
run of the function. A few of them need to be kept simultaneously open. If
the number of chromosomes and / or contacts is particularly high, a few
thousands files might be needed to be opened simultaneously. Some operating
systems limit the number of open files per user, in which case the function
might fail with &quot;Too many open files&quot; or similar error. The workaround could
be:
</p>
<p>1. Increase the limit of simultaneously opened files (the way varies
depending on your operating system). 2. Increase the value of
'gmax.data.size' option. Higher values of 'gmax.data.size' option will
increased memory usage of the function but create fewer temporary files.
</p>


<h3>Value</h3>

<p>None.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gtrack.2d.import">gtrack.2d.import</a></code>, <code><a href="#topic+gtrack.rm">gtrack.rm</a></code>,
<code><a href="#topic+gtrack.info">gtrack.info</a></code>, <code><a href="#topic+gdir.create">gdir.create</a></code>
</p>

<hr>
<h2 id='gtrack.array.extract'>Returns values from 'Array' track</h2><span id='topic+gtrack.array.extract'></span>

<h3>Description</h3>

<p>Returns values from 'Array' track.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gtrack.array.extract(
  track = NULL,
  slice = NULL,
  intervals = NULL,
  file = NULL,
  intervals.set.out = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gtrack.array.extract_+3A_track">track</code></td>
<td>
<p>track name</p>
</td></tr>
<tr><td><code id="gtrack.array.extract_+3A_slice">slice</code></td>
<td>
<p>a vector of column names or column indices or 'NULL'</p>
</td></tr>
<tr><td><code id="gtrack.array.extract_+3A_intervals">intervals</code></td>
<td>
<p>genomic scope for which the function is applied</p>
</td></tr>
<tr><td><code id="gtrack.array.extract_+3A_file">file</code></td>
<td>
<p>file name where the function result is to be saved. If 'NULL'
result is returned to the user.</p>
</td></tr>
<tr><td><code id="gtrack.array.extract_+3A_intervals.set.out">intervals.set.out</code></td>
<td>
<p>intervals set name where the function result is
optionally outputted</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function returns the column values of an 'Array' track in the genomic
scope specified by 'intervals'. 'slice' parameter determines which columns
should appear in the result. The columns can be indicated by their names or
their indices. If 'slice' is 'NULL' the values of all track columns are
returned.
</p>
<p>The order inside the result might not be the same as the order of intervals.
An additional column 'intervalID' is added to the return value. Use this
column to refer to the index of the original interval from the supplied
'intervals'.
</p>
<p>If 'file' parameter is not 'NULL' the result is saved to a tab-delimited
text file (without 'intervalID' column) rather than returned to the user.
This can be especially useful when the result is too big to fit into the
physical memory.  The resulted file can be used as an input for
'gtrack.array.import' function.
</p>
<p>If 'intervals.set.out' is not 'NULL' the result is saved as an intervals
set. Similarly to 'file' parameter 'intervals.set.out' can be useful to
overcome the limits of the physical memory.
</p>


<h3>Value</h3>

<p>If 'file' and 'intervals.set.out' are 'NULL' a set of intervals with
additional columns for 'Array' track column values and 'columnID'.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gextract">gextract</a></code>, <code><a href="#topic+gtrack.array.get_colnames">gtrack.array.get_colnames</a></code>,
<code><a href="#topic+gtrack.array.import">gtrack.array.import</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

gdb.init_examples()
gtrack.array.extract(
    "array_track", c("col3", "col5"),
    gintervals(1, 0, 2000)
)

</code></pre>

<hr>
<h2 id='gtrack.array.get_colnames'>Returns column names of array track</h2><span id='topic+gtrack.array.get_colnames'></span>

<h3>Description</h3>

<p>Returns column names of array track.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gtrack.array.get_colnames(track = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gtrack.array.get_colnames_+3A_track">track</code></td>
<td>
<p>track name</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function returns the column names of an array track.
</p>


<h3>Value</h3>

<p>A character vector with column names.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gtrack.array.set_colnames">gtrack.array.set_colnames</a></code>,
<code><a href="#topic+gtrack.array.extract">gtrack.array.extract</a></code>, <code><a href="#topic+gvtrack.array.slice">gvtrack.array.slice</a></code>,
<code><a href="#topic+gtrack.info">gtrack.info</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

gtrack.array.get_colnames("array_track")

</code></pre>

<hr>
<h2 id='gtrack.array.import'>Creates an array track from array tracks or files</h2><span id='topic+gtrack.array.import'></span>

<h3>Description</h3>

<p>Creates an array track from array tracks or files.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gtrack.array.import(track = NULL, description = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gtrack.array.import_+3A_track">track</code></td>
<td>
<p>name of the newly created track</p>
</td></tr>
<tr><td><code id="gtrack.array.import_+3A_description">description</code></td>
<td>
<p>a character string description</p>
</td></tr>
<tr><td><code id="gtrack.array.import_+3A_...">...</code></td>
<td>
<p>array track or name of a tab-delimited file</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function creates a new 'Array' track from one or more &quot;sources&quot;. Each
source can be either another 'Array' track or a tab-delimited file that
contains one-dimensional intervals and column values that should be added to
the newly created track. One can learn about the exact format of the file by
running 'gtrack.array.extract' or 'gextract' functions with a 'file'
parameter and inspecting the output file.
</p>
<p>There might be more than one source used to create the new track. In that
case the new track will contain the columns from all the sources. The
equally named columns are merged. Intervals that appear in one source but
not in the other are added and the values for the missing columns are set to
NaN. Intervals with all NaN values are not added. Partial overlaps between
two intervals from different sources are forbidden.
</p>
<p>'description' is added as a track attribute.
</p>


<h3>Value</h3>

<p>None.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gextract">gextract</a></code>, <code><a href="#topic+gtrack.array.extract">gtrack.array.extract</a></code>,
<code><a href="#topic+gtrack.array.set_colnames">gtrack.array.set_colnames</a></code>, <code><a href="#topic+gtrack.rm">gtrack.rm</a></code>,
<code><a href="#topic+gtrack.info">gtrack.info</a></code>, <code><a href="#topic+gdir.create">gdir.create</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

f1 &lt;- tempfile()
gextract("sparse_track", gintervals(1, 5000, 20000), file = f1)
f2 &lt;- tempfile()
gtrack.array.extract("array_track", c("col2", "col3", "col4"),
    gintervals(1, 0, 20000),
    file = f2
)
f3 &lt;- tempfile()
gtrack.array.extract("array_track", c("col1", "col3"),
    gintervals(1, 0, 20000),
    file = f3
)

gtrack.array.import("test_track1", "Test array track 1", f1, f2)
gtrack.array.extract("test_track1", NULL, .misha$ALLGENOME)

gtrack.array.import(
    "test_track2", "Test array track 2",
    "test_track1", f3
)
gtrack.array.extract("test_track2", NULL, .misha$ALLGENOME)

gtrack.rm("test_track1", TRUE)
gtrack.rm("test_track2", TRUE)
unlink(c(f1, f2, f3))

</code></pre>

<hr>
<h2 id='gtrack.array.set_colnames'>Sets column names of array track</h2><span id='topic+gtrack.array.set_colnames'></span>

<h3>Description</h3>

<p>Sets column names of array track.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gtrack.array.set_colnames(track = NULL, names = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gtrack.array.set_colnames_+3A_track">track</code></td>
<td>
<p>track name</p>
</td></tr>
<tr><td><code id="gtrack.array.set_colnames_+3A_names">names</code></td>
<td>
<p>vector of column names</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This sets the column names of an array track.
</p>


<h3>Value</h3>

<p>None.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gtrack.array.get_colnames">gtrack.array.get_colnames</a></code>,
<code><a href="#topic+gtrack.array.extract">gtrack.array.extract</a></code>, <code><a href="#topic+gvtrack.array.slice">gvtrack.array.slice</a></code>,
<code><a href="#topic+gtrack.info">gtrack.info</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

old.names &lt;- gtrack.array.get_colnames("array_track")
new.names &lt;- paste("modified", old.names, sep = "_")
gtrack.array.set_colnames("array_track", new.names)
gtrack.array.get_colnames("array_track")
gtrack.array.set_colnames("array_track", old.names)
gtrack.array.get_colnames("array_track")

</code></pre>

<hr>
<h2 id='gtrack.attr.export'>Returns track attributes values</h2><span id='topic+gtrack.attr.export'></span>

<h3>Description</h3>

<p>Returns track attributes values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gtrack.attr.export(tracks = NULL, attrs = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gtrack.attr.export_+3A_tracks">tracks</code></td>
<td>
<p>a vector of track names or 'NULL'</p>
</td></tr>
<tr><td><code id="gtrack.attr.export_+3A_attrs">attrs</code></td>
<td>
<p>a vector of attribute names or 'NULL'</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function returns a data frame that contains track attributes values.
Column names of the data frame consist of the attribute names, row names
contain the track names.
</p>
<p>The list of required tracks is specified by 'tracks' argument. If 'tracks'
is 'NULL' the attribute values of all existing tracks are returned.
</p>
<p>Likewise the list of required attributes is controlled by 'attrs' argument.
If 'attrs' is 'NULL' all attribute values of the specified tracks are
returned. The columns are also sorted then by &quot;popularity&quot; of an attribute,
i.e. the number of tracks containing this attribute. This sorting is not
applied if 'attrs' is not 'NULL'.
</p>
<p>Empty character string in a table cell marks a non-existing attribute.
</p>


<h3>Value</h3>

<p>A data frame containing track attributes values.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gtrack.attr.import">gtrack.attr.import</a></code>, <code><a href="#topic+gtrack.attr.get">gtrack.attr.get</a></code>,
<code><a href="#topic+gtrack.attr.set">gtrack.attr.set</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

gdb.init_examples()
gtrack.attr.export()
gtrack.attr.export(tracks = c("sparse_track", "dense_track"))
gtrack.attr.export(attrs = "created.by")

</code></pre>

<hr>
<h2 id='gtrack.attr.get'>Returns value of a track attribute</h2><span id='topic+gtrack.attr.get'></span>

<h3>Description</h3>

<p>Returns value of a track attribute.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gtrack.attr.get(track = NULL, attr = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gtrack.attr.get_+3A_track">track</code></td>
<td>
<p>track name</p>
</td></tr>
<tr><td><code id="gtrack.attr.get_+3A_attr">attr</code></td>
<td>
<p>attribute name</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function returns the value of a track attribute. If the attribute does
not exist an empty sting is returned.
</p>


<h3>Value</h3>

<p>Track attribute value.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gtrack.attr.import">gtrack.attr.import</a></code>, <code><a href="#topic+gtrack.attr.set">gtrack.attr.set</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

gdb.init_examples()
gtrack.attr.set("sparse_track", "test_attr", "value")
gtrack.attr.get("sparse_track", "test_attr")
gtrack.attr.set("sparse_track", "test_attr", "")

</code></pre>

<hr>
<h2 id='gtrack.attr.import'>Imports track attributes values</h2><span id='topic+gtrack.attr.import'></span>

<h3>Description</h3>

<p>Imports track attributes values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gtrack.attr.import(table = NULL, remove.others = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gtrack.attr.import_+3A_table">table</code></td>
<td>
<p>a data frame containing attribute values</p>
</td></tr>
<tr><td><code id="gtrack.attr.import_+3A_remove.others">remove.others</code></td>
<td>
<p>specifies what to do with the attributes that are not
in the table</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function makes imports attribute values contained in a data frame
'table'. The format of a table is similar to the one returned by
'gtrack.attr.export'. The values of the table must be character strings.
Column names of the table should specify the attribute names, while row
names should contain the track names.
</p>
<p>The specified attributes of the specified tracks are modified. If an
attribute value is an empty string this attribute is removed from the track.
</p>
<p>If 'remove.others' is 'TRUE' all non-readonly attributes that do not appear
in the table are removed, otherwise they are preserved unchanged.
</p>
<p>Error is reported on an attempt to modify a value of a read-only attribute.
</p>


<h3>Value</h3>

<p>None.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gtrack.attr.import">gtrack.attr.import</a></code>, <code><a href="#topic+gtrack.attr.set">gtrack.attr.set</a></code>,
<code><a href="#topic+gtrack.attr.get">gtrack.attr.get</a></code>, <code><a href="#topic+gdb.get_readonly_attrs">gdb.get_readonly_attrs</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

gdb.init_examples()
t &lt;- gtrack.attr.export()
t$newattr &lt;- as.character(1:dim(t)[1])
gtrack.attr.import(t)
gtrack.attr.export(attrs = "newattr")

# roll-back the changes
t$newattr &lt;- ""
gtrack.attr.import(t)

</code></pre>

<hr>
<h2 id='gtrack.attr.set'>Assigns value to a track attribute</h2><span id='topic+gtrack.attr.set'></span>

<h3>Description</h3>

<p>Assigns value to a track attribute.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gtrack.attr.set(track = NULL, attr = NULL, value = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gtrack.attr.set_+3A_track">track</code></td>
<td>
<p>track name</p>
</td></tr>
<tr><td><code id="gtrack.attr.set_+3A_attr">attr</code></td>
<td>
<p>attribute name</p>
</td></tr>
<tr><td><code id="gtrack.attr.set_+3A_value">value</code></td>
<td>
<p>value</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function creates a track attribute and assigns 'value' to it. If the
attribute already exists its value is overwritten.
</p>
<p>If 'value' is an empty string the attribute is removed.
</p>
<p>Error is reported on an attempt to modify a value of a read-only attribute.
</p>


<h3>Value</h3>

<p>None.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gtrack.attr.get">gtrack.attr.get</a></code>, <code><a href="#topic+gtrack.attr.import">gtrack.attr.import</a></code>,
<code><a href="#topic+gtrack.var.set">gtrack.var.set</a></code>, <code><a href="#topic+gdb.get_readonly_attrs">gdb.get_readonly_attrs</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

gdb.init_examples()
gtrack.attr.set("sparse_track", "test_attr", "value")
gtrack.attr.get("sparse_track", "test_attr")
gtrack.attr.set("sparse_track", "test_attr", "")

</code></pre>

<hr>
<h2 id='gtrack.convert'>Converts a track to the most current format</h2><span id='topic+gtrack.convert'></span>

<h3>Description</h3>

<p>Converts a track (if needed) to the most current format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gtrack.convert(src.track = NULL, tgt.track = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gtrack.convert_+3A_src.track">src.track</code></td>
<td>
<p>source track name</p>
</td></tr>
<tr><td><code id="gtrack.convert_+3A_tgt.track">tgt.track</code></td>
<td>
<p>target track name. If 'NULL' the source track is
overwritten.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function converts a track to the most current format. It should be used
if a track created by an old version of the library cannot be read anymore
by the newer version. The old track is given by 'src.track'. After
conversion a new track 'tgt.track' is created. If 'tgt.track' is 'NULL' the
source track is overwritten.
</p>


<h3>Value</h3>

<p>None
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gtrack.create">gtrack.create</a></code>, <code><a href="#topic+gtrack.2d.create">gtrack.2d.create</a></code>,
<code><a href="#topic+gtrack.create_sparse">gtrack.create_sparse</a></code>
</p>

<hr>
<h2 id='gtrack.create'>Creates a track from a track expression</h2><span id='topic+gtrack.create'></span>

<h3>Description</h3>

<p>Creates a track from a track expression.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gtrack.create(
  track = NULL,
  description = NULL,
  expr = NULL,
  iterator = NULL,
  band = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gtrack.create_+3A_track">track</code></td>
<td>
<p>track name</p>
</td></tr>
<tr><td><code id="gtrack.create_+3A_description">description</code></td>
<td>
<p>a character string description</p>
</td></tr>
<tr><td><code id="gtrack.create_+3A_expr">expr</code></td>
<td>
<p>track expression</p>
</td></tr>
<tr><td><code id="gtrack.create_+3A_iterator">iterator</code></td>
<td>
<p>track expression iterator. If 'NULL' iterator is determined
implicitly based on track expression.</p>
</td></tr>
<tr><td><code id="gtrack.create_+3A_band">band</code></td>
<td>
<p>track expression band. If 'NULL' no band is used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function creates a new track named track. The values of the track are
determined by evaluation of 'expr' - a numeric track expression. The type of
the new track is determined by the type of the iterator. 'Fixed bin',
'Sparse' or 'Rectangles' track can be created accordingly. 'description' is
added as a track attribute.
</p>


<h3>Value</h3>

<p>None.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gtrack.2d.create">gtrack.2d.create</a></code>, <code><a href="#topic+gtrack.create_sparse">gtrack.create_sparse</a></code>,
<code><a href="#topic+gtrack.smooth">gtrack.smooth</a></code>, <code><a href="#topic+gtrack.modify">gtrack.modify</a></code>,
<code><a href="#topic+gtrack.rm">gtrack.rm</a></code>, <code><a href="#topic+gtrack.info">gtrack.info</a></code>,
<code><a href="#topic+gdir.create">gdir.create</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

gdb.init_examples()

## Creates a new track that is a sum of values from 'dense' and
## 2 * non-nan values of 'sparse' track. The new track type is
## Dense with a bin size that equals to '70'.
gtrack.create("mixed_track", "Test track",
    "dense_track +
              replace(sparse_track, is.nan(sparse_track), 0) * 2",
    iterator = 70
)
gtrack.info("mixed_track")
gtrack.rm("mixed_track", force = TRUE)

</code></pre>

<hr>
<h2 id='gtrack.create_dirs'>Create directories needed for track creation</h2><span id='topic+gtrack.create_dirs'></span>

<h3>Description</h3>

<p>This function creates the directories needed for track creation.
For example, if the track name is 'proj.sample.my_track', this function
creates the directories 'proj' and 'sample'. Use this function with caution -
a long track name may create a deep directory structure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gtrack.create_dirs(track, mode = "0777")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gtrack.create_dirs_+3A_track">track</code></td>
<td>
<p>name of the track</p>
</td></tr>
<tr><td><code id="gtrack.create_dirs_+3A_mode">mode</code></td>
<td>
<p>see 'dir.create'</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
gdb.init_examples()

# This creates the directories 'proj' and 'sample'
gtrack.create_dirs("proj.sample.my_track")

</code></pre>

<hr>
<h2 id='gtrack.create_pwm_energy'>Creates a new track from PSSM energy function</h2><span id='topic+gtrack.create_pwm_energy'></span>

<h3>Description</h3>

<p>Creates a new track from PSSM energy function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gtrack.create_pwm_energy(
  track = NULL,
  description = NULL,
  pssmset = NULL,
  pssmid = NULL,
  prior = NULL,
  iterator = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gtrack.create_pwm_energy_+3A_track">track</code></td>
<td>
<p>track name</p>
</td></tr>
<tr><td><code id="gtrack.create_pwm_energy_+3A_description">description</code></td>
<td>
<p>a character string description</p>
</td></tr>
<tr><td><code id="gtrack.create_pwm_energy_+3A_pssmset">pssmset</code></td>
<td>
<p>name of PSSM set: 'pssmset.key' and 'pssmset.data' must be
presented in 'GROOT/pssms' directory</p>
</td></tr>
<tr><td><code id="gtrack.create_pwm_energy_+3A_pssmid">pssmid</code></td>
<td>
<p>PSSM id</p>
</td></tr>
<tr><td><code id="gtrack.create_pwm_energy_+3A_prior">prior</code></td>
<td>
<p>prior</p>
</td></tr>
<tr><td><code id="gtrack.create_pwm_energy_+3A_iterator">iterator</code></td>
<td>
<p>track expression iterator for the newly created track</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function creates a new track with values of a PSSM energy function.
PSSM parameters (nucleotide probability per position and pluralization) are
determined by 'pssmset' key and data files ('pssmset.key' and
'pssmset.data'). These two files must be located in 'GROOT/pssms' directory.
The type of the created track is determined by the type of the iterator.
'description' is added as a track attribute.
</p>


<h3>Value</h3>

<p>None.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gtrack.create">gtrack.create</a></code>, <code><a href="#topic+gtrack.2d.create">gtrack.2d.create</a></code>,
<code><a href="#topic+gtrack.create_sparse">gtrack.create_sparse</a></code>, <code><a href="#topic+gtrack.smooth">gtrack.smooth</a></code>,
<code><a href="#topic+gtrack.modify">gtrack.modify</a></code>, <code><a href="#topic+gtrack.rm">gtrack.rm</a></code>,
<code><a href="#topic+gtrack.info">gtrack.info</a></code>, <code><a href="#topic+gdir.create">gdir.create</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
gdb.init_examples()
gtrack.create_pwm_energy("pwm_energy_track", "Test track", "pssm",
    3, 0.01,
    iterator = 100
)
gextract("pwm_energy_track", gintervals(1, 0, 1000))


</code></pre>

<hr>
<h2 id='gtrack.create_sparse'>Creates a 'Sparse' track from intervals and values</h2><span id='topic+gtrack.create_sparse'></span>

<h3>Description</h3>

<p>Creates a 'Sparse' track from intervals and values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gtrack.create_sparse(
  track = NULL,
  description = NULL,
  intervals = NULL,
  values = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gtrack.create_sparse_+3A_track">track</code></td>
<td>
<p>track name</p>
</td></tr>
<tr><td><code id="gtrack.create_sparse_+3A_description">description</code></td>
<td>
<p>a character string description</p>
</td></tr>
<tr><td><code id="gtrack.create_sparse_+3A_intervals">intervals</code></td>
<td>
<p>a set of one-dimensional intervals</p>
</td></tr>
<tr><td><code id="gtrack.create_sparse_+3A_values">values</code></td>
<td>
<p>an array of numeric values - one for each interval</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function creates a new 'Sparse' track with values at given intervals.
'description' is added as a track attribute.
</p>


<h3>Value</h3>

<p>None.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gtrack.create">gtrack.create</a></code>, <code><a href="#topic+gtrack.2d.create">gtrack.2d.create</a></code>,
<code><a href="#topic+gtrack.smooth">gtrack.smooth</a></code>, <code><a href="#topic+gtrack.modify">gtrack.modify</a></code>,
<code><a href="#topic+gtrack.rm">gtrack.rm</a></code>, <code><a href="#topic+gtrack.info">gtrack.info</a></code>,
<code><a href="#topic+gdir.create">gdir.create</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

gdb.init_examples()
intervs &lt;- gintervals.load("annotations")
gtrack.create_sparse(
    "test_sparse", "Test track", intervs,
    1:dim(intervs)[1]
)
gextract("test_sparse", .misha$ALLGENOME)
gtrack.rm("test_sparse", force = TRUE)

</code></pre>

<hr>
<h2 id='gtrack.exists'>Tests for a track existence</h2><span id='topic+gtrack.exists'></span>

<h3>Description</h3>

<p>Tests for a track existence.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gtrack.exists(track = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gtrack.exists_+3A_track">track</code></td>
<td>
<p>track name</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function returns 'TRUE' if a track exists in Genomic Database.
</p>


<h3>Value</h3>

<p>'TRUE' if a track exists. Otherwise 'FALSE'.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gtrack.ls">gtrack.ls</a></code>, <code><a href="#topic+gtrack.info">gtrack.info</a></code>,
<code><a href="#topic+gtrack.create">gtrack.create</a></code>, <code><a href="#topic+gtrack.rm">gtrack.rm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

gdb.init_examples()
gtrack.exists("dense_track")

</code></pre>

<hr>
<h2 id='gtrack.import'>Creates a track from WIG / BigWig / BedGraph / tab-delimited file</h2><span id='topic+gtrack.import'></span>

<h3>Description</h3>

<p>Creates a track from WIG / BigWig / BedGraph / tab-delimited file
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gtrack.import(
  track = NULL,
  description = NULL,
  file = NULL,
  binsize = NULL,
  defval = NaN
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gtrack.import_+3A_track">track</code></td>
<td>
<p>track name</p>
</td></tr>
<tr><td><code id="gtrack.import_+3A_description">description</code></td>
<td>
<p>a character string description</p>
</td></tr>
<tr><td><code id="gtrack.import_+3A_file">file</code></td>
<td>
<p>file path</p>
</td></tr>
<tr><td><code id="gtrack.import_+3A_binsize">binsize</code></td>
<td>
<p>bin size of the newly created 'Dense' track or '0' for a
'Sparse' track</p>
</td></tr>
<tr><td><code id="gtrack.import_+3A_defval">defval</code></td>
<td>
<p>default track value</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function creates a track from WIG / BigWig / BedGraph / tab-delimited
file.  One can learn about the format of the tab-delimited file by running
'gextract' function on a 1D track with a 'file' parameter set to the name of
the file. Zipped files are supported (file name must have '.gz' or '.zip'
suffix).
</p>
<p>If 'binsize' is 0 the resulted track is created in 'Sparse' format.
Otherwise the 'Dense' format is chosen with a bin size equal to 'binsize'.
The values that were not defined in input file file are substituted by
'defval' value.
</p>
<p>'description' is added as a track attribute.
</p>


<h3>Value</h3>

<p>None.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gtrack.import_set">gtrack.import_set</a></code>, <code><a href="#topic+gtrack.rm">gtrack.rm</a></code>,
<code><a href="#topic+gtrack.info">gtrack.info</a></code>, <code><a href="#topic+gdir.create">gdir.create</a></code>, <code><a href="#topic+gextract">gextract</a></code>
</p>

<hr>
<h2 id='gtrack.import_mappedseq'>Creates a track from a file of mapped sequences</h2><span id='topic+gtrack.import_mappedseq'></span>

<h3>Description</h3>

<p>Creates a track from a file of mapped sequences.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gtrack.import_mappedseq(
  track = NULL,
  description = NULL,
  file = NULL,
  pileup = 0,
  binsize = -1,
  cols.order = c(9, 11, 13, 14),
  remove.dups = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gtrack.import_mappedseq_+3A_track">track</code></td>
<td>
<p>track name</p>
</td></tr>
<tr><td><code id="gtrack.import_mappedseq_+3A_description">description</code></td>
<td>
<p>a character string description</p>
</td></tr>
<tr><td><code id="gtrack.import_mappedseq_+3A_file">file</code></td>
<td>
<p>name of mapped sequences file</p>
</td></tr>
<tr><td><code id="gtrack.import_mappedseq_+3A_pileup">pileup</code></td>
<td>
<p>interval expansion</p>
</td></tr>
<tr><td><code id="gtrack.import_mappedseq_+3A_binsize">binsize</code></td>
<td>
<p>bin size of a dense track</p>
</td></tr>
<tr><td><code id="gtrack.import_mappedseq_+3A_cols.order">cols.order</code></td>
<td>
<p>order of sequence, chromosome, coordinate and strand
columns in mapped sequences file or NULL if SAM file is used</p>
</td></tr>
<tr><td><code id="gtrack.import_mappedseq_+3A_remove.dups">remove.dups</code></td>
<td>
<p>if 'TRUE' the duplicated coordinates are counted only
once.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function creates a track from a file of mapped sequences. The file can
be in SAM format or in a general TAB delimited text format where each line
describes a single read.
</p>
<p>For a SAM file 'cols.order' must be set to 'NULL'.
</p>
<p>For a general TAB delimited text format the following columns must be
presented in the file: sequence, chromosome, coordinate and strand. The
position of these columns should be specified in 'cols.order' argument. The
default value of 'cols.order' is an array of (9, 11, 13, 14) meaning that
sequence is expected to be found at column number 9, chromosome - at column
11, coordinate - at column 13 and strand - at column 14. The column indices
are 1-based, i.e. the first column is referenced by 1. Chromosome needs a
prefix 'chr' e.g. 'chr1'. Valid strand values are '+' or 'F' for forward
strand and '-' or 'R' for the reverse strand.
</p>
<p>Each read at given coordinate can be &quot;expanded&quot; to cover an interval rather
than a single point. The length of the interval is controlled by 'pileup'
argument. The direction of expansion depends on the strand value. If
'pileup' is '0', no expansion is performed and the read is converted to a
single point. The track is created in sparse format. If 'pileup' is greater
than zero, the output track is in dense format. 'binsize' controls the bin
size of the dense track.
</p>
<p>If 'remove.dups' is 'TRUE' the duplicated coordinates are counted only once.
</p>
<p>'description' is added as a track attribute.
</p>
<p>'gtrack.import_mappedseq' returns the statistics of the conversion process.
</p>


<h3>Value</h3>

<p>A list of conversion process statistics.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gtrack.rm">gtrack.rm</a></code>, <code><a href="#topic+gtrack.info">gtrack.info</a></code>,
<code><a href="#topic+gdir.create">gdir.create</a></code>
</p>

<hr>
<h2 id='gtrack.import_set'>Creates one or more tracks from multiple WIG / BigWig / BedGraph /
tab-delimited files on disk or FTP</h2><span id='topic+gtrack.import_set'></span>

<h3>Description</h3>

<p>Creates one or more tracks from WIG / BigWig / BedGraph / tab-delimited
files on disk or FTP.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gtrack.import_set(
  description = NULL,
  path = NULL,
  binsize = NULL,
  track.prefix = NULL,
  defval = NaN
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gtrack.import_set_+3A_description">description</code></td>
<td>
<p>a character string description</p>
</td></tr>
<tr><td><code id="gtrack.import_set_+3A_path">path</code></td>
<td>
<p>file path or URL (may contain wildcards)</p>
</td></tr>
<tr><td><code id="gtrack.import_set_+3A_binsize">binsize</code></td>
<td>
<p>bin size of the newly created 'Dense' track or '0' for a
'Sparse' track</p>
</td></tr>
<tr><td><code id="gtrack.import_set_+3A_track.prefix">track.prefix</code></td>
<td>
<p>prefix for a track name</p>
</td></tr>
<tr><td><code id="gtrack.import_set_+3A_defval">defval</code></td>
<td>
<p>default track value</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is similar to 'gtrack.import' however unlike the latter it can
create multiple tracks. Additionally the files can be fetched from an FTP
server.
</p>
<p>The files are expected to be in WIG / BigWig / BedGraph / tab-delimited
formats. One can learn about the format of the tab-delimited file by running
'gextract' function with a 'file' parameter set to the name of the file.
Zipped files are supported (file name must have '.gz' or '.zip' suffix).
</p>
<p>Files are specified by 'path' argument. 'path' can be also a URL of an FTP
server in the form of 'ftp://[address]/[files]'. If 'path' is a URL, the
files are first downloaded from FTP server to a temporary directory and then
imported to tracks. The temporary directory is created at 'GROOT/downloads'.
</p>
<p>Regardless whether 'path' is file path or to a URL, it can contain
wildcards. Hence multiple files can be imported (and downloaded) at once.
</p>
<p>If 'binsize' is 0 the resulted tracks are created in 'Sparse' format.
Otherwise the 'Dense' format is chosen with a bin size equal to 'binsize'.
The values that were not defined in input file file are substituted by
'defval' value.
</p>
<p>The name of a each created track is of '[track.prefix][filename]' form,
where 'filename' is the name of the WIG file. For example, if 'track.prefix'
equals to &quot;wigs.&quot;&quot; and an input file name is 'mydata', a track named
'wigs.mydata' is created. If 'track.prefix' is 'NULL' no prefix is appended
to the name of the created track.
</p>
<p>Existing tracks are not overwritten and no new directories are automatically
created.
</p>
<p>'description' is added to the created tracks as an attribute.
</p>
<p>'gtrack.import_set' does not stop if an error occurs while importing a file.
It rather continues importing the rest of the files.
</p>
<p>'gtrack.import_set' returns the names of the files that were successfully
imported and those that failed.
</p>


<h3>Value</h3>

<p>Names of files that were successfully imported and those that
failed.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gtrack.import">gtrack.import</a></code>, <code><a href="#topic+gwget">gwget</a></code>,
<code><a href="#topic+gtrack.rm">gtrack.rm</a></code>, <code><a href="#topic+gtrack.info">gtrack.info</a></code>,
<code><a href="#topic+gdir.create">gdir.create</a></code>, <code><a href="#topic+gextract">gextract</a></code>
</p>

<hr>
<h2 id='gtrack.info'>Returns information about a track</h2><span id='topic+gtrack.info'></span>

<h3>Description</h3>

<p>Returns information about a track.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gtrack.info(track = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gtrack.info_+3A_track">track</code></td>
<td>
<p>track name</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Returns information about the track (type, dimensions, size in bytes, etc.).
The fields in the returned value vary depending on the type of the track.
</p>


<h3>Value</h3>

<p>A list that contains track properties
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gtrack.exists">gtrack.exists</a></code>, <code><a href="#topic+gtrack.ls">gtrack.ls</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

gdb.init_examples()
gtrack.info("dense_track")
gtrack.info("rects_track")

</code></pre>

<hr>
<h2 id='gtrack.liftover'>Imports a track from another assembly</h2><span id='topic+gtrack.liftover'></span>

<h3>Description</h3>

<p>Imports a track from another assembly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gtrack.liftover(
  track = NULL,
  description = NULL,
  src.track.dir = NULL,
  chain = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gtrack.liftover_+3A_track">track</code></td>
<td>
<p>name of a created track</p>
</td></tr>
<tr><td><code id="gtrack.liftover_+3A_description">description</code></td>
<td>
<p>a character string description</p>
</td></tr>
<tr><td><code id="gtrack.liftover_+3A_src.track.dir">src.track.dir</code></td>
<td>
<p>path to the directory of the source track</p>
</td></tr>
<tr><td><code id="gtrack.liftover_+3A_chain">chain</code></td>
<td>
<p>name of chain file or data frame as returned by
'gintervals.load_chain'</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function imports a track located in 'src.track.dir' of another assembly
to the current database. Chain file instructs how the conversion of
coordinates should be done. It can be either a name of a chain file or a
data frame in the same format as returned by 'gintervals.load_chain'
function. The name of the newly created track is specified by 'track'
argument and 'description' is added as a track attribute.
</p>


<h3>Value</h3>

<p>None.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gintervals.load_chain">gintervals.load_chain</a></code>,
<code><a href="#topic+gintervals.liftover">gintervals.liftover</a></code>
</p>

<hr>
<h2 id='gtrack.lookup'>Creates a new track from a lookup table based on track expression</h2><span id='topic+gtrack.lookup'></span>

<h3>Description</h3>

<p>Evaluates track expression and translates the values into bin indices that
are used in turn to retrieve values from a lookup table and create a track.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gtrack.lookup(
  track = NULL,
  description = NULL,
  lookup_table = NULL,
  ...,
  include.lowest = FALSE,
  force.binning = TRUE,
  iterator = NULL,
  band = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gtrack.lookup_+3A_track">track</code></td>
<td>
<p>track name</p>
</td></tr>
<tr><td><code id="gtrack.lookup_+3A_description">description</code></td>
<td>
<p>a character string description</p>
</td></tr>
<tr><td><code id="gtrack.lookup_+3A_lookup_table">lookup_table</code></td>
<td>
<p>a multi-dimensional array containing the values that are
returned by the function</p>
</td></tr>
<tr><td><code id="gtrack.lookup_+3A_...">...</code></td>
<td>
<p>pairs of track expressions and breaks</p>
</td></tr>
<tr><td><code id="gtrack.lookup_+3A_include.lowest">include.lowest</code></td>
<td>
<p>if 'TRUE', the lowest value of the range determined by
breaks is included</p>
</td></tr>
<tr><td><code id="gtrack.lookup_+3A_force.binning">force.binning</code></td>
<td>
<p>if 'TRUE', the values smaller than the minimal break
will be translated to index 1, and the values that exceed the maximal break
will be translated to index N-1 where N is the number of breaks. If 'FALSE'
the out-of-range values will produce NaN values.</p>
</td></tr>
<tr><td><code id="gtrack.lookup_+3A_iterator">iterator</code></td>
<td>
<p>track expression iterator. If 'NULL' iterator is determined
implicitly based on track expressions.</p>
</td></tr>
<tr><td><code id="gtrack.lookup_+3A_band">band</code></td>
<td>
<p>track expression band. If 'NULL' no band is used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function evaluates the track expression for all iterator intervals and
translates this value into an index based on the breaks. This index is then
used to address the lookup table and create with its values a new track.
More than one 'expr'-'breaks' pair can be used. In that case 'lookup_table'
is addressed in a multidimensional manner, i.e. 'lookup_table[i1, i2, ...]'.
</p>
<p>The range of bins is determined by 'breaks' argument. For example: 'breaks =
c(x1, x2, x3, x4)' represents three different intervals (bins): (x1, x2],
(x2, x3], (x3, x4].
</p>
<p>If 'include.lowest' is 'TRUE' the the lowest value is included in the first
interval, i.e. in [x1, x2].
</p>
<p>'force.binning' parameter controls what should be done when the value of
'expr' exceeds the range determined by 'breaks'. If 'force.binning' is
'TRUE' then values smaller than the minimal break will be translated to
index 1, and the values exceeding the maximal break will be translated to
index 'M-1' where 'M' is the number of breaks. If 'force.binning' is 'FALSE'
the out-of-range values will produce 'NaN' values.
</p>
<p>Regardless of 'force.binning' value if the value of 'expr' is 'NaN' then the
value in the track would be 'NaN' too.
</p>
<p>'description' is added as a track attribute.
</p>


<h3>Value</h3>

<p>None.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+glookup">glookup</a></code>, <code><a href="#topic+gtrack.2d.create">gtrack.2d.create</a></code>,
<code><a href="#topic+gtrack.create_sparse">gtrack.create_sparse</a></code>, <code><a href="#topic+gtrack.smooth">gtrack.smooth</a></code>,
<code><a href="#topic+gtrack.modify">gtrack.modify</a></code>, <code><a href="#topic+gtrack.rm">gtrack.rm</a></code>,
<code><a href="#topic+gtrack.info">gtrack.info</a></code>, <code><a href="#topic+gdir.create">gdir.create</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

gdb.init_examples()

## one-dimensional example
breaks1 &lt;- seq(0.1, 0.2, length.out = 6)
gtrack.lookup(
    "lookup_track", "Test track", 1:5, "dense_track",
    breaks1
)
gtrack.rm("lookup_track", force = TRUE)

## two-dimensional example
t &lt;- array(1:15, dim = c(5, 3))
breaks2 &lt;- seq(0.31, 0.37, length.out = 4)
gtrack.lookup(
    "lookup_track", "Test track", t, "dense_track",
    breaks1, "2 * dense_track", breaks2
)
gtrack.rm("lookup_track", force = TRUE)

</code></pre>

<hr>
<h2 id='gtrack.ls'>Returns a list of track names</h2><span id='topic+gtrack.ls'></span>

<h3>Description</h3>

<p>Returns a list of track names in Genomic Database.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gtrack.ls(
  ...,
  ignore.case = FALSE,
  perl = FALSE,
  fixed = FALSE,
  useBytes = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gtrack.ls_+3A_...">...</code></td>
<td>
<p>these arguments are of either form 'pattern' or 'attribute =
pattern'</p>
</td></tr>
<tr><td><code id="gtrack.ls_+3A_ignore.case">ignore.case</code>, <code id="gtrack.ls_+3A_perl">perl</code>, <code id="gtrack.ls_+3A_fixed">fixed</code>, <code id="gtrack.ls_+3A_usebytes">useBytes</code></td>
<td>
<p>see 'grep'</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function returns a list of tracks whose name or track attribute value
match a pattern (see 'grep'). If called without any arguments all tracks are
returned.
</p>
<p>If pattern is specified without a track attribute (i.e. in the form of
'pattern') then filtering is applied to the track names. If pattern is
supplied with a track attribute (i.e. in the form of 'name = pattern') then
track attribute is matched against the pattern.
</p>
<p>Multiple patterns are applied one after another. The resulted list of tracks
should match all the patterns.
</p>


<h3>Value</h3>

<p>An array that contains the names of tracks that match the supplied
patterns.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+grep">grep</a></code>, <code><a href="#topic+gtrack.exists">gtrack.exists</a></code>,
<code><a href="#topic+gtrack.create">gtrack.create</a></code>, <code><a href="#topic+gtrack.rm">gtrack.rm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

gdb.init_examples()

# get all track names
gtrack.ls()

# get track names that match the pattern "den*"
gtrack.ls("den*")

# get track names whose "created.by" attribute match the pattern
# "create_sparse"
gtrack.ls(created.by = "create_sparse")

# get track names whose names match the pattern "den*" and whose
# "created.by" attribute match the pattern "track"
gtrack.ls("den*", created.by = "track")

</code></pre>

<hr>
<h2 id='gtrack.modify'>Modifies track contents</h2><span id='topic+gtrack.modify'></span>

<h3>Description</h3>

<p>Modifies 'Dense' track contents.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gtrack.modify(track = NULL, expr = NULL, intervals = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gtrack.modify_+3A_track">track</code></td>
<td>
<p>track name</p>
</td></tr>
<tr><td><code id="gtrack.modify_+3A_expr">expr</code></td>
<td>
<p>track expression</p>
</td></tr>
<tr><td><code id="gtrack.modify_+3A_intervals">intervals</code></td>
<td>
<p>genomic scope for which track is modified</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function modifies the contents of a 'Dense' track by the values of
'expr'. 'intervals' argument controls which portion of the track is
modified. The iterator policy is set internally to the bin size of the
track.
</p>


<h3>Value</h3>

<p>None.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gtrack.create">gtrack.create</a></code>, <code><a href="#topic+gtrack.rm">gtrack.rm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

gdb.init_examples()
intervs &lt;- gintervals(1, 300, 800)
gextract("dense_track", intervs)
gtrack.modify("dense_track", "dense_track * 2", intervs)
gextract("dense_track", intervs)
gtrack.modify("dense_track", "dense_track / 2", intervs)

</code></pre>

<hr>
<h2 id='gtrack.rm'>Deletes a track</h2><span id='topic+gtrack.rm'></span>

<h3>Description</h3>

<p>Deletes a track.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gtrack.rm(track = NULL, force = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gtrack.rm_+3A_track">track</code></td>
<td>
<p>track name</p>
</td></tr>
<tr><td><code id="gtrack.rm_+3A_force">force</code></td>
<td>
<p>if 'TRUE', suppresses user confirmation of a named track removal</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function deletes a track from the Genomic Database. By default
'gtrack.rm' requires the user to interactively confirm the deletion. Set
'force' to 'TRUE' to suppress the user prompt.
</p>


<h3>Value</h3>

<p>None.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gtrack.exists">gtrack.exists</a></code>, <code><a href="#topic+gtrack.ls">gtrack.ls</a></code>,
<code><a href="#topic+gtrack.create">gtrack.create</a></code>, <code><a href="#topic+gtrack.2d.create">gtrack.2d.create</a></code>,
<code><a href="#topic+gtrack.create_sparse">gtrack.create_sparse</a></code>, <code><a href="#topic+gtrack.smooth">gtrack.smooth</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

gdb.init_examples()
gtrack.create("new_track", "Test track", "2 * dense_track")
gtrack.exists("new_track")
gtrack.rm("new_track", force = TRUE)
gtrack.exists("new_track")

</code></pre>

<hr>
<h2 id='gtrack.smooth'>Creates a new track from smoothed values of track expression</h2><span id='topic+gtrack.smooth'></span>

<h3>Description</h3>

<p>Creates a new track from smoothed values of track expression.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gtrack.smooth(
  track = NULL,
  description = NULL,
  expr = NULL,
  winsize = NULL,
  weight_thr = 0,
  smooth_nans = FALSE,
  alg = "LINEAR_RAMP",
  iterator = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gtrack.smooth_+3A_track">track</code></td>
<td>
<p>track name</p>
</td></tr>
<tr><td><code id="gtrack.smooth_+3A_description">description</code></td>
<td>
<p>a character string description</p>
</td></tr>
<tr><td><code id="gtrack.smooth_+3A_expr">expr</code></td>
<td>
<p>track expression</p>
</td></tr>
<tr><td><code id="gtrack.smooth_+3A_winsize">winsize</code></td>
<td>
<p>size of smoothing window</p>
</td></tr>
<tr><td><code id="gtrack.smooth_+3A_weight_thr">weight_thr</code></td>
<td>
<p>smoothing weight threshold</p>
</td></tr>
<tr><td><code id="gtrack.smooth_+3A_smooth_nans">smooth_nans</code></td>
<td>
<p>if 'FALSE' track value is always set to 'NaN' if central
window value is 'NaN', otherwise it is calculated from the rest of non 'NaN'
values</p>
</td></tr>
<tr><td><code id="gtrack.smooth_+3A_alg">alg</code></td>
<td>
<p>smoothing algorithm - &quot;MEAN&quot; or &quot;LINEAR_RAMP&quot;</p>
</td></tr>
<tr><td><code id="gtrack.smooth_+3A_iterator">iterator</code></td>
<td>
<p>track expression iterator of 'Fixed bin' type</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function creates a new 'Dense' track named 'track'. The values of the
track are results of smoothing the values of 'expr'.
</p>
<p>Each track value at coordinate 'C' is determined by smoothing non 'NaN'
values of 'expr' over the window around 'C'. The window size is controlled
by 'winsize' and is given in coordinate units (not in number of bins),
defining the total regions to be considered when smoothing (on both sides of
the central point). Two different algorithms can be used for smoothing:
</p>
<p>&quot;MEAN&quot; - an arithmetic average.
</p>
<p>&quot;LINEAR_RAMP&quot; - a weighted arithmetic average, where the weights linearly
decrease as the distance from the center of the window increases.
</p>
<p>'weight_thr' determines the function behavior when some of the values in the
window are missing or 'NaN' (missing values may occur at the edges of each
chromosome when the window covers an area beyond chromosome boundaries).
'weight_thr' sets the weight sum threshold below which smoothing algorithm
returns 'NaN' rather than a smoothing value based on non 'NaN' values in the
window.
</p>
<p>'smooth_nans' controls what would be the smoothed value if the central value
in the window is 'NaN'. If 'smooth_nans' is 'FALSE' then the smoothed value
is set to 'NaN' regardless of 'weight_thr' parameter. Otherwise it is
calculated normally.
</p>
<p>'description' is added as a track attribute.
</p>
<p>Iterator policy must be of &quot;fixed bin&quot; type.
</p>


<h3>Value</h3>

<p>None.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gtrack.create">gtrack.create</a></code>, <code><a href="#topic+gtrack.2d.create">gtrack.2d.create</a></code>,
<code><a href="#topic+gtrack.create_sparse">gtrack.create_sparse</a></code>, <code><a href="#topic+gtrack.modify">gtrack.modify</a></code>,
<code><a href="#topic+gtrack.rm">gtrack.rm</a></code>, <code><a href="#topic+gtrack.info">gtrack.info</a></code>,
<code><a href="#topic+gdir.create">gdir.create</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

gdb.init_examples()
gtrack.smooth("smoothed_track", "Test track", "dense_track", 500)
gextract("dense_track", "smoothed_track", gintervals(1, 0, 1000))
gtrack.rm("smoothed_track", force = TRUE)

</code></pre>

<hr>
<h2 id='gtrack.var.get'>Returns value of a track variable</h2><span id='topic+gtrack.var.get'></span>

<h3>Description</h3>

<p>Returns value of a track variable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gtrack.var.get(track = NULL, var = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gtrack.var.get_+3A_track">track</code></td>
<td>
<p>track name</p>
</td></tr>
<tr><td><code id="gtrack.var.get_+3A_var">var</code></td>
<td>
<p>track variable name</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function returns the value of a track variable. If the variable does
not exist an error is reported.
</p>


<h3>Value</h3>

<p>Track variable value.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gtrack.var.set">gtrack.var.set</a></code>, <code><a href="#topic+gtrack.var.ls">gtrack.var.ls</a></code>,
<code><a href="#topic+gtrack.var.rm">gtrack.var.rm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

gdb.init_examples()
gtrack.var.set("sparse_track", "test_var", 1:10)
gtrack.var.get("sparse_track", "test_var")
gtrack.var.rm("sparse_track", "test_var")

</code></pre>

<hr>
<h2 id='gtrack.var.ls'>Returns a list of track variables for a track</h2><span id='topic+gtrack.var.ls'></span>

<h3>Description</h3>

<p>Returns a list of track variables for a track.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gtrack.var.ls(
  track = NULL,
  pattern = "",
  ignore.case = FALSE,
  perl = FALSE,
  fixed = FALSE,
  useBytes = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gtrack.var.ls_+3A_track">track</code></td>
<td>
<p>track name</p>
</td></tr>
<tr><td><code id="gtrack.var.ls_+3A_pattern">pattern</code>, <code id="gtrack.var.ls_+3A_ignore.case">ignore.case</code>, <code id="gtrack.var.ls_+3A_perl">perl</code>, <code id="gtrack.var.ls_+3A_fixed">fixed</code>, <code id="gtrack.var.ls_+3A_usebytes">useBytes</code></td>
<td>
<p>see 'grep'</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function returns a list of track variables of a track that match the
pattern (see 'grep'). If called without any arguments all track variables of
a track are returned.
</p>


<h3>Value</h3>

<p>An array that contains the names of track variables.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+grep">grep</a></code>, <code><a href="#topic+gtrack.var.get">gtrack.var.get</a></code>,
<code><a href="#topic+gtrack.var.set">gtrack.var.set</a></code>, <code><a href="#topic+gtrack.var.rm">gtrack.var.rm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

gdb.init_examples()
gtrack.var.ls("sparse_track")
gtrack.var.set("sparse_track", "test_var1", 1:10)
gtrack.var.set("sparse_track", "test_var2", "v")
gtrack.var.ls("sparse_track")
gtrack.var.ls("sparse_track", pattern = "2")
gtrack.var.rm("sparse_track", "test_var1")
gtrack.var.rm("sparse_track", "test_var2")

</code></pre>

<hr>
<h2 id='gtrack.var.rm'>Deletes a track variable</h2><span id='topic+gtrack.var.rm'></span>

<h3>Description</h3>

<p>Deletes a track variable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gtrack.var.rm(track = NULL, var = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gtrack.var.rm_+3A_track">track</code></td>
<td>
<p>track name</p>
</td></tr>
<tr><td><code id="gtrack.var.rm_+3A_var">var</code></td>
<td>
<p>track variable name</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function deletes a track variable.
</p>


<h3>Value</h3>

<p>None.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gtrack.var.get">gtrack.var.get</a></code>, <code><a href="#topic+gtrack.var.set">gtrack.var.set</a></code>,
<code><a href="#topic+gtrack.var.ls">gtrack.var.ls</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

gdb.init_examples()
gtrack.var.set("sparse_track", "test_var1", 1:10)
gtrack.var.set("sparse_track", "test_var2", "v")
gtrack.var.ls("sparse_track")
gtrack.var.rm("sparse_track", "test_var1")
gtrack.var.rm("sparse_track", "test_var2")
gtrack.var.ls("sparse_track")

</code></pre>

<hr>
<h2 id='gtrack.var.set'>Assigns value to a track variable</h2><span id='topic+gtrack.var.set'></span>

<h3>Description</h3>

<p>Assigns value to a track variable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gtrack.var.set(track = NULL, var = NULL, value = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gtrack.var.set_+3A_track">track</code></td>
<td>
<p>track name</p>
</td></tr>
<tr><td><code id="gtrack.var.set_+3A_var">var</code></td>
<td>
<p>track variable name</p>
</td></tr>
<tr><td><code id="gtrack.var.set_+3A_value">value</code></td>
<td>
<p>value</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function creates a track variable and assigns 'value' to it. If the
track variable already exists its value is overwritten.
</p>


<h3>Value</h3>

<p>None.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gtrack.var.get">gtrack.var.get</a></code>, <code><a href="#topic+gtrack.var.ls">gtrack.var.ls</a></code>,
<code><a href="#topic+gtrack.var.rm">gtrack.var.rm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

gdb.init_examples()
gtrack.var.set("sparse_track", "test_var", 1:10)
gtrack.var.get("sparse_track", "test_var")
gtrack.var.rm("sparse_track", "test_var")

</code></pre>

<hr>
<h2 id='gvtrack.array.slice'>Defines rules for a single value calculation of a virtual 'Array' track</h2><span id='topic+gvtrack.array.slice'></span>

<h3>Description</h3>

<p>Defines how a single value within an interval is achieved for a virtual
track based on 'Array' track.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gvtrack.array.slice(vtrack = NULL, slice = NULL, func = "avg", params = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gvtrack.array.slice_+3A_vtrack">vtrack</code></td>
<td>
<p>virtual track name</p>
</td></tr>
<tr><td><code id="gvtrack.array.slice_+3A_slice">slice</code></td>
<td>
<p>a vector of column names or column indices or 'NULL'</p>
</td></tr>
<tr><td><code id="gvtrack.array.slice_+3A_func">func</code>, <code id="gvtrack.array.slice_+3A_params">params</code></td>
<td>
<p>see below</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A track (regular or virtual) used in a track expression is expected to
return one value for each track interval. 'Array' tracks store multiple
values per interval (one for each 'column') and hence if used in a track
expression one must define the way of how a single value should be deduced
from several ones.
</p>
<p>By default if an 'Array' track is used in a track expressions, its interval
value would be the average of all column values that are not NaN.
'gvtrack.array.slice' allows to select specific columns and to specify the
function applied to their values.
</p>
<p>'slice' parameter allows to choose the columns. Columns can be indicated by
their names or their indices. If 'slice' is 'NULL' the non-NaN values of all
track columns are used.
</p>
<p>'func' parameter determines the function applied to the columns' values. Use
the following table for a reference of all valid functions and parameters
combinations:
</p>
<p><em>func = &quot;avg&quot;, params = NULL</em> <br /> Average of columns' values.
</p>
<p><em>func = &quot;max&quot;, params = NULL</em> <br /> Maximum of columns' values.
</p>
<p><em>func = &quot;min&quot;, params = NULL</em> <br /> Minimum of columns' values.
</p>
<p><em>func = &quot;stdev&quot;, params = NULL</em> <br /> Unbiased standard deviation of
columns' values.
</p>
<p><em>func = &quot;sum&quot;, params = NULL</em> <br /> Sum of columns' values.
</p>
<p><em>func = &quot;quantile&quot;, params = [Percentile in the range of [0, 1]]</em> <br />
Quantile of columns' values.
</p>


<h3>Value</h3>

<p>None.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gvtrack.create">gvtrack.create</a></code>,
<code><a href="#topic+gtrack.array.get_colnames">gtrack.array.get_colnames</a></code>, <code><a href="#topic+gtrack.array.extract">gtrack.array.extract</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

gdb.init_examples()
gvtrack.create("vtrack1", "array_track")
gvtrack.array.slice("vtrack1", c("col2", "col4"), "max")
gextract("vtrack1", gintervals(1, 0, 1000))

</code></pre>

<hr>
<h2 id='gvtrack.create'>Creates a new virtual track</h2><span id='topic+gvtrack.create'></span>

<h3>Description</h3>

<p>Creates a new virtual track.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gvtrack.create(vtrack = NULL, src = NULL, func = NULL, params = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gvtrack.create_+3A_vtrack">vtrack</code></td>
<td>
<p>virtual track name</p>
</td></tr>
<tr><td><code id="gvtrack.create_+3A_src">src</code></td>
<td>
<p>source (track/intervals). NULL for PWM functions</p>
</td></tr>
<tr><td><code id="gvtrack.create_+3A_func">func</code></td>
<td>
<p>function name (see above)</p>
</td></tr>
<tr><td><code id="gvtrack.create_+3A_params">params</code></td>
<td>
<p>function parameters (see above)</p>
</td></tr>
<tr><td><code id="gvtrack.create_+3A_...">...</code></td>
<td>
<p>additional PWM parameters</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function creates a new virtual track named 'vtrack' with the given
source, function and parameters. 'src' can be either a track or intervals
(1D or 2D). Use the following table for a reference of all valid source,
function and parameters combinations:
</p>
<p><em>src = [Track], func = &quot;avg&quot;, params = NULL</em> <br /> Average track value in
iterator interval.
</p>
<p><em>src = [Track], func = &quot;max&quot;, params = NULL</em> <br /> Maximal track value in
iterator interval.
</p>
<p><em>src = [Track], func = &quot;min&quot;, params = NULL</em> <br /> Minimal track value in
iterator interval.
</p>
<p><em>src = ['Dense' / 'Sparse' / 'Array' track], func = &quot;nearest&quot;, params =
NULL</em> <br /> Mean track value in iterator interval. If there are no track
values covered by an iterator interator (can occur only in 'Sparse' track),
the nearest track value is returned.
</p>
<p><em>src = ['Dense' / 'Sparse' / 'Array' track], func = &quot;stddev&quot;, params =
NULL</em> <br /> Unbiased standard deviation of track values in iterator interval.
</p>
<p><em>src = ['Dense' / 'Sparse' / 'Array' track], func = &quot;sum&quot;, params =
NULL</em> <br /> Sum of track values in iterator interval.
</p>
<p><em>src = ['Dense' / 'Sparse' / 'Array' track], func = &quot;quantile&quot;, params
= [Percentile in the range of [0, 1]]</em> <br /> Quantile of track values in
iterator interval.
</p>
<p><em>src = ['Dense' track], func = &quot;global.percentile&quot;, params = NULL</em> <br />
Percentile of an average track value in iterator interval relatively to all
values of the track.
</p>
<p><em>src = ['Dense' track], func = &quot;global.percentile.max&quot;, params = NULL</em>
<br /> Percentile of a maximal track value in iterator interval relatively to
all values of the track.
</p>
<p><em>src = ['Dense' track], func = &quot;global.percentile.min&quot;, params = NULL</em>
<br /> Percentile of a minimal track value in iterator interval relatively to
all values of the track.
</p>
<p><em>src = [2D track], func = &quot;area&quot;, params = NULL</em> <br /> Area covered by
iterator interval.
</p>
<p><em>src = [2D track], func = &quot;weighted.sum&quot;, params = NULL</em> <br /> Weighted
sum of values where each weight equals to the intersection area between the
iterator interval and the rectangle containing the value.
</p>
<p><em>src = [1D intervals], func = &quot;distance&quot;, params = [Minimal distance
from center (default: 0)]</em> <br /> Given the center 'C' of the current iterator
interval returns 'DC * X/2', where 'DC' is the normalized distance to the
center of the interval that contains 'C', and 'X' is the value of the
parameter. If no interval contains 'C' the resulted value is 'D + XXX/2'
where 'D' is the distance between 'C' and the edge of the closest interval.
Distance can be positive or negative depending on the position of the
coordinate relative to the interval and the strand (-1 or 1) of the
interval. Distance is always positive if 'strand' is '0' or if 'strand'
column is missing. Distance is 'NA' if no intervals exist for the current
chromosome.
</p>
<p><em>src = [1D intervals], func = &quot;distance.center&quot;, params = NULL</em> <br />
Given the center 'C' of the current iterator interval returns 'NaN' if 'C'
is outside of the intervals, otherwise returns the distance between 'C' and
the center of the closest interval. Distance can be positive or negative
depending on the position of the coordinate relative to the interval and the
strand (-1 or 1) of the interval. Distance is always positive if 'strand' is
'0' or if 'strand' column is missing.
</p>
<p><em>src = [1D intervals], func = &quot;coverage&quot;, params = NULL</em> <br />
For each iterator interval, calculates the fraction of its length that is covered by the
source intervals. Returns a value between 0 and 1. For example, if an iterator interval is [100,200]
and the source intervals cover positions 120-140 and 160-170, the coverage would be 0.3
((20 + 10) / 100 = 0.3). Overlapping source intervals are first unified.
</p>
<p><em>func = &quot;pwm&quot;, params = list(pssm = matrix, bidirect = TRUE,
prior = 0.01, extend = TRUE)</em> <br />
Calculates total log-likelihood score of DNA sequence against PSSM.
Uses log-sum-exp over all positions. For bidirect=TRUE, scans both
strands. Prior adds pseudocounts, extend=TRUE allows scoring at boundaries.
</p>
<p><em>func = &quot;pwm.max&quot;, params = list(pssm = matrix, bidirect = TRUE,
prior = 0.01, extend = TRUE)</em> <br />
Returns maximum log-likelihood score of best PSSM match. bidirect=TRUE
checks both strands. Prior adds pseudocounts, extend=TRUE allows boundary
scoring.
</p>
<p><em>func = &quot;pwm.max.pos&quot;, params = list(pssm = matrix, bidirect = TRUE,
prior = 0.01, extend = TRUE)</em> <br />
Returns 1-based position of best PSSM match.
If bidirect=TRUE, the position would be positive if the best hit was at the
forward strand, and negative if it was at the reverse strand. When strand is
-1 the position is still according to the forward strand, but the hit is at
the end of the match.
Prior adds pseudocounts, extend=TRUE allows boundary scoring.
</p>
<p>For all PWM functions:
</p>

<ul>
<li><p> pssm: Position-specific scoring matrix (A,C,G,T frequencies)
</p>
</li>
<li><p> bidirect: If TRUE, scans both strands; if FALSE, forward only
</p>
</li>
<li><p> prior: Pseudocount for frequencies (default: 0.01)
</p>
</li>
<li><p> extend: If TRUE, computes boundary scores
</p>
</li>
<li><p> strand: If 1, scans forward strand; if -1, scans reverse strand.
For strand == 1, the energy (and position of the best match) would be at
the beginning of the match, for strand == -1, the energy (and position of
the best match) would be at the end of the match.
</p>
</li></ul>

<p>PWM parameters are accepted as list or individual parameters (see examples).
</p>
<p><em>func = &quot;kmer.count&quot;, params = list(kmer = &quot;ACGT&quot;, extend = TRUE, strand = 0)</em> <br />
Counts occurrences of the specified kmer in each interval. The extend=TRUE
parameter (default) allows counting kmers that span interval boundaries.
The strand parameter can be 1 (forward strand), -1 (reverse strand), or 0 (both strands).
</p>
<p><em>func = &quot;kmer.frac&quot;, params = list(kmer = &quot;ACGT&quot;, extend = TRUE, strand = 0)</em> <br />
Calculates the fraction of possible positions in each interval that contain
the specified kmer. The extend=TRUE parameter (default) allows counting kmers
that span interval boundaries. The strand parameter can be 1 (forward strand), -1
(reverse strand), or 0 (both strands).
</p>
<p>For kmer functions:
</p>

<ul>
<li><p> kmer: The DNA sequence to count (case-insensitive)
</p>
</li>
<li><p> extend: If TRUE, counts kmers that span interval boundaries
</p>
</li>
<li><p> strand: If 1, counts kmers on forward strand; if -1, counts kmers on reverse strand. If
0, counts kmers on both strands. Default is 0.
</p>
</li></ul>

<p>Kmer parameters are accepted as list or individual parameters (see examples).
Note that for palindromic kmers, setting strand to 1 or -1 is recommended to avoid double counting.
</p>
<p>Modify iterator behavior with 'gvtrack.iterator' or 'gvtrack.iterator.2d'.
</p>


<h3>Value</h3>

<p>None.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gvtrack.info">gvtrack.info</a></code>, <code><a href="#topic+gvtrack.iterator">gvtrack.iterator</a></code>,
<code><a href="#topic+gvtrack.iterator.2d">gvtrack.iterator.2d</a></code>, <code><a href="#topic+gvtrack.array.slice">gvtrack.array.slice</a></code>,
<code><a href="#topic+gvtrack.ls">gvtrack.ls</a></code>, <code><a href="#topic+gvtrack.rm">gvtrack.rm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

gdb.init_examples()

gvtrack.create("vtrack1", "dense_track", "max")
gvtrack.create("vtrack2", "dense_track", "quantile", 0.5)
gextract("dense_track", "vtrack1", "vtrack2",
    gintervals(1, 0, 10000),
    iterator = 1000
)

gvtrack.create("vtrack3", "dense_track", "global.percentile")
gvtrack.create("vtrack4", "annotations", "distance")
gdist(
    "vtrack3", seq(0, 1, l = 10), "vtrack4",
    seq(-500, 500, 200)
)

gvtrack.create("cov", "annotations", "coverage")
gextract("cov", gintervals(1, 0, 1000), iterator = 100)

pssm &lt;- matrix(
    c(
        0.7, 0.1, 0.1, 0.1, # Example PSSM
        0.1, 0.7, 0.1, 0.1,
        0.1, 0.1, 0.7, 0.1,
        0.1, 0.1, 0.7, 0.1,
        0.1, 0.1, 0.7, 0.1,
        0.1, 0.1, 0.7, 0.1
    ),
    ncol = 4, byrow = TRUE
)
colnames(pssm) &lt;- c("A", "C", "G", "T")
gvtrack.create(
    "motif_score", NULL, "pwm",
    list(pssm = pssm, bidirect = TRUE, prior = 0.01)
)
gvtrack.create("max_motif_score", NULL, "pwm.max",
    pssm = pssm, bidirect = TRUE, prior = 0.01
)
gvtrack.create("max_motif_pos", NULL, "pwm.max.pos",
    pssm = pssm
)
gextract(
    c(
        "dense_track", "motif_score", "max_motif_score",
        "max_motif_pos"
    ),
    gintervals(1, 0, 10000),
    iterator = 500
)

# Kmer counting examples
gvtrack.create("cg_count", NULL, "kmer.count", kmer = "CG", strand = 1)
gvtrack.create("cg_frac", NULL, "kmer.frac", kmer = "CG", strand = 1)
gextract(c("cg_count", "cg_frac"), gintervals(1, 0, 10000), iterator = 1000)

gvtrack.create("at_pos", NULL, "kmer.count", kmer = "AT", strand = 1)
gvtrack.create("at_neg", NULL, "kmer.count", kmer = "AT", strand = -1)
gvtrack.create("at_both", NULL, "kmer.count", kmer = "AT", strand = 0)
gextract(c("at_pos", "at_neg", "at_both"), gintervals(1, 0, 10000), iterator = 1000)

# GC content
gvtrack.create("g_frac", NULL, "kmer.frac", kmer = "G")
gvtrack.create("c_frac", NULL, "kmer.frac", kmer = "C")
gextract("g_frac + c_frac", gintervals(1, 0, 10000),
    iterator = 1000,
    colnames = "gc_content"
)
</code></pre>

<hr>
<h2 id='gvtrack.info'>Returns the definition of a virtual track</h2><span id='topic+gvtrack.info'></span>

<h3>Description</h3>

<p>Returns the definition of a virtual track.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gvtrack.info(vtrack = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gvtrack.info_+3A_vtrack">vtrack</code></td>
<td>
<p>virtual track name</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function returns the internal representation of a virtual track.
</p>


<h3>Value</h3>

<p>Internal representation of a virtual track.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gvtrack.create">gvtrack.create</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

gdb.init_examples()
gvtrack.create("vtrack1", "dense_track", "max")
gvtrack.info("vtrack1")

</code></pre>

<hr>
<h2 id='gvtrack.iterator'>Defines modification rules for a one-dimensional iterator in a virtual track</h2><span id='topic+gvtrack.iterator'></span>

<h3>Description</h3>

<p>Defines modification rules for a one-dimensional iterator in a virtual
track.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gvtrack.iterator(vtrack = NULL, dim = NULL, sshift = 0, eshift = 0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gvtrack.iterator_+3A_vtrack">vtrack</code></td>
<td>
<p>virtual track name</p>
</td></tr>
<tr><td><code id="gvtrack.iterator_+3A_dim">dim</code></td>
<td>
<p>use 'NULL' or '0' for 1D iterators. '1' converts 2D iterator to
(chrom1, start1, end1) , '2' converts 2D iterator to (chrom2, start2, end2)</p>
</td></tr>
<tr><td><code id="gvtrack.iterator_+3A_sshift">sshift</code></td>
<td>
<p>shift of 'start' coordinate</p>
</td></tr>
<tr><td><code id="gvtrack.iterator_+3A_eshift">eshift</code></td>
<td>
<p>shift of 'end' coordinate</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function defines modification rules for one-dimensional iterator
intervals in a virtual track.
</p>
<p>'dim' converts a 2D iterator interval (chrom1, start1, end1, chrom2, start2,
end2) to a 1D interval. If 'dim' is '1' the interval is converted to
(chrom1, start1, end1). If 'dim' is '2' the interval is converted to
(chrom2, start2, end2). If 1D iterator is used 'dim' must be set to 'NULL'
or '0' (meaning: no conversion is made).
</p>
<p>Iterator interval's 'start' coordinate is modified by adding 'sshift'.
Similarly 'end' coordinate is altered by adding 'eshift'.
</p>


<h3>Value</h3>

<p>None.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gvtrack.create">gvtrack.create</a></code>, <code><a href="#topic+gvtrack.iterator.2d">gvtrack.iterator.2d</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

gdb.init_examples()

gvtrack.create("vtrack1", "dense_track")
gvtrack.iterator("vtrack1", sshift = 200, eshift = 200)
gextract("dense_track", "vtrack1", gintervals(1, 0, 500))

gvtrack.create("vtrack2", "dense_track")
gvtrack.iterator("vtrack2", dim = 1)
gextract("vtrack2", gintervals.2d(1, 0, 1000, 1, 0, -1),
    iterator = "rects_track"
)

</code></pre>

<hr>
<h2 id='gvtrack.iterator.2d'>Defines modification rules for a two-dimensional iterator in a virtual track</h2><span id='topic+gvtrack.iterator.2d'></span>

<h3>Description</h3>

<p>Defines modification rules for a two-dimensional iterator in a virtual
track.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gvtrack.iterator.2d(
  vtrack = NULL,
  sshift1 = 0,
  eshift1 = 0,
  sshift2 = 0,
  eshift2 = 0
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gvtrack.iterator.2d_+3A_vtrack">vtrack</code></td>
<td>
<p>virtual track name</p>
</td></tr>
<tr><td><code id="gvtrack.iterator.2d_+3A_sshift1">sshift1</code></td>
<td>
<p>shift of 'start1' coordinate</p>
</td></tr>
<tr><td><code id="gvtrack.iterator.2d_+3A_eshift1">eshift1</code></td>
<td>
<p>shift of 'end1' coordinate</p>
</td></tr>
<tr><td><code id="gvtrack.iterator.2d_+3A_sshift2">sshift2</code></td>
<td>
<p>shift of 'start2' coordinate</p>
</td></tr>
<tr><td><code id="gvtrack.iterator.2d_+3A_eshift2">eshift2</code></td>
<td>
<p>shift of 'end2' coordinate</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function defines modification rules for one-dimensional iterator
intervals in a virtual track.
</p>
<p>Iterator interval's 'start1' coordinate is modified by adding 'sshift1'.
Similarly 'end1', 'start2', 'end2' coordinates are altered by adding
'eshift1', 'sshift2' and 'eshift2' accordingly.
</p>


<h3>Value</h3>

<p>None.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gvtrack.create">gvtrack.create</a></code>, <code><a href="#topic+gvtrack.iterator">gvtrack.iterator</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

gdb.init_examples()
gvtrack.create("vtrack1", "rects_track")
gvtrack.iterator.2d("vtrack1", sshift1 = 1000, eshift1 = 2000)
gextract(
    "rects_track", "vtrack1",
    gintervals.2d(1, 0, 5000, 2, 0, 5000)
)

</code></pre>

<hr>
<h2 id='gvtrack.ls'>Returns a list of virtual track names</h2><span id='topic+gvtrack.ls'></span>

<h3>Description</h3>

<p>Returns a list of virtual track names.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gvtrack.ls(
  pattern = "",
  ignore.case = FALSE,
  perl = FALSE,
  fixed = FALSE,
  useBytes = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gvtrack.ls_+3A_pattern">pattern</code>, <code id="gvtrack.ls_+3A_ignore.case">ignore.case</code>, <code id="gvtrack.ls_+3A_perl">perl</code>, <code id="gvtrack.ls_+3A_fixed">fixed</code>, <code id="gvtrack.ls_+3A_usebytes">useBytes</code></td>
<td>
<p>see 'grep'</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function returns a list of virtual tracks that exist in current R
environment that match the pattern (see 'grep'). If called without any
arguments all virtual tracks are returned.
</p>


<h3>Value</h3>

<p>An array that contains the names of virtual tracks.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+grep">grep</a></code>, <code><a href="#topic+gvtrack.create">gvtrack.create</a></code>,
<code><a href="#topic+gvtrack.rm">gvtrack.rm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

gdb.init_examples()
gvtrack.create("vtrack1", "dense_track", "max")
gvtrack.create("vtrack2", "dense_track", "quantile", 0.5)
gvtrack.ls()
gvtrack.ls(pattern = "*2")

</code></pre>

<hr>
<h2 id='gvtrack.rm'>Deletes a virtual track</h2><span id='topic+gvtrack.rm'></span>

<h3>Description</h3>

<p>Deletes a virtual track.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gvtrack.rm(vtrack = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gvtrack.rm_+3A_vtrack">vtrack</code></td>
<td>
<p>virtual track name</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function deletes a virtual track from current R environment.
</p>


<h3>Value</h3>

<p>None.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gvtrack.create">gvtrack.create</a></code>, <code><a href="#topic+gvtrack.ls">gvtrack.ls</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

gdb.init_examples()
gvtrack.create("vtrack1", "dense_track", "max")
gvtrack.create("vtrack2", "dense_track", "quantile", 0.5)
gvtrack.ls()
gvtrack.rm("vtrack1")
gvtrack.ls()

</code></pre>

<hr>
<h2 id='gwget'>Downloads files from FTP server</h2><span id='topic+gwget'></span>

<h3>Description</h3>

<p>Downloads multiple files from FTP server
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gwget(url = NULL, path = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gwget_+3A_url">url</code></td>
<td>
<p>URL of FTP server</p>
</td></tr>
<tr><td><code id="gwget_+3A_path">path</code></td>
<td>
<p>directory path where the downloaded files are stored</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function downloads files from FTP server given by 'url'. The address in
'url' can contain wildcards to download more than one file at once. Files
are downloaded to a directory given by 'path' argument.  If 'path' is
'NULL', file are downloaded into 'GROOT/downloads'.
</p>


<h3>Value</h3>

<p>An array of file names that have been downloaded.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gtrack.import_set">gtrack.import_set</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>gdb.init_examples()

outdir &lt;- tempdir()
gwget("ftp://hgdownload.soe.ucsc.edu/goldenPath/hg19/chromosomes/md5sum.txt", path = outdir)


</code></pre>

<hr>
<h2 id='gwilcox'>Calculates Wilcoxon test on sliding windows over track expression</h2><span id='topic+gwilcox'></span>

<h3>Description</h3>

<p>Calculates Wilcoxon test on sliding windows over the values of track
expression.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gwilcox(
  expr = NULL,
  winsize1 = NULL,
  winsize2 = NULL,
  maxpval = 0.05,
  onetailed = TRUE,
  what2find = 1,
  intervals = NULL,
  iterator = NULL,
  intervals.set.out = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gwilcox_+3A_expr">expr</code></td>
<td>
<p>track expression</p>
</td></tr>
<tr><td><code id="gwilcox_+3A_winsize1">winsize1</code></td>
<td>
<p>number of values in the first sliding window</p>
</td></tr>
<tr><td><code id="gwilcox_+3A_winsize2">winsize2</code></td>
<td>
<p>number of values in the second sliding window</p>
</td></tr>
<tr><td><code id="gwilcox_+3A_maxpval">maxpval</code></td>
<td>
<p>maximal P-value</p>
</td></tr>
<tr><td><code id="gwilcox_+3A_onetailed">onetailed</code></td>
<td>
<p>if 'TRUE', Wilcoxon test is performed one tailed, otherwise
two tailed</p>
</td></tr>
<tr><td><code id="gwilcox_+3A_what2find">what2find</code></td>
<td>
<p>if '-1', lows are searched. If '1', peaks are searched. If
'0', both peaks and lows are searched</p>
</td></tr>
<tr><td><code id="gwilcox_+3A_intervals">intervals</code></td>
<td>
<p>genomic scope for which the function is applied</p>
</td></tr>
<tr><td><code id="gwilcox_+3A_iterator">iterator</code></td>
<td>
<p>track expression iterator of &quot;fixed bin&quot; type. If 'NULL'
iterator is determined implicitly based on track expression.</p>
</td></tr>
<tr><td><code id="gwilcox_+3A_intervals.set.out">intervals.set.out</code></td>
<td>
<p>intervals set name where the function result is
optionally outputted</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function runs a Wilcoxon test (also known as a Mann-Whitney test) over
the values of track expression in the two sliding windows having an
identical center. The sizes of the windows are specified by 'winsize1' and
'winsize2'. 'gwilcox' returns intervals where the smaller window tested
against a larger window gives a P-value below 'maxpval'. The test can be one
or two tailed.
</p>
<p>'what2find' argument controls what should be searched: peaks, lows or both.
</p>
<p>If 'intervals.set.out' is not 'NULL' the result is saved as an intervals
set. Use this parameter if the result size exceeds the limits of the
physical memory.
</p>


<h3>Value</h3>

<p>If 'intervals.set.out' is 'NULL' a data frame representing the
intervals with an additional 'pval' column where P-value is below 'maxpval'.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gscreen">gscreen</a></code>, <code><a href="#topic+gsegment">gsegment</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

gdb.init_examples()
gwilcox("dense_track", 100000, 1000,
    maxpval = 0.01,
    what2find = 1
)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
