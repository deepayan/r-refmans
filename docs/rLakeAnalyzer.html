<!DOCTYPE html><html><head><title>Help for package rLakeAnalyzer</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {rLakeAnalyzer}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#rLakeAnalyzer'><p>Lake Physics Tools</p></a></li>
<li><a href='#approx.bathy'><p>Estimate hypsography curve</p></a></li>
<li><a href='#buoyancy.freq'><p>Calculates buoyancy frequency.</p></a></li>
<li><a href='#center.buoyancy'><p>Calculates the center of buoyancy.</p></a></li>
<li><a href='#cline_calc'><p>Calculate cline of series of segments</p></a></li>
<li><a href='#depth.filter'><p>Data filter to remove soak, heave and upcast</p></a></li>
<li><a href='#drop.datetime'><p>Find and drop the datetime column from the datatable</p></a></li>
<li><a href='#epi.temperature'><p>Get volumetrically averaged epilimnion temp</p></a></li>
<li><a href='#get.datetime'><p>Search for and return the datetime column from a ts data.frame</p></a></li>
<li><a href='#get.offsets'><p>Gets depths from data frame containing profile info.</p></a></li>
<li><a href='#hypo.temperature'><p>Get volumetrically averaged hypolimnion temp</p></a></li>
<li><a href='#internal.energy'><p>Internal energy function (Joules)</p></a></li>
<li><a href='#lake.number'><p>Calculate Lake Number</p></a></li>
<li><a href='#lake.number.plot'><p>Plots time series of Lake Number</p></a></li>
<li><a href='#latesummer'><p>Late Summer Profile</p></a></li>
<li><a href='#layer.density'><p>Returns the average density of a layer between two depths.</p></a></li>
<li><a href='#layer.temperature'><p>Returns the average temperature of a layer between two depths.</p></a></li>
<li><a href='#load.bathy'><p>Import lake bathymetry data.</p></a></li>
<li><a href='#load.ts'><p>Load timeseries from properly formatted text file.</p></a></li>
<li><a href='#meta.depths'><p>Calculate the Top and Bottom Depths of the Metalimnion</p></a></li>
<li><a href='#schmidt.plot'><p>Creates a time series plot of Schmidt's stability</p></a></li>
<li><a href='#schmidt.stability'><p>Calculate the Schmidt stability</p></a></li>
<li><a href='#thermo.depth'><p>Calculate depth of the thermocline from a temperature profile.</p></a></li>
<li><a href='#ts.buoyancy.freq'><p>Calculate the buoyancy (Brunt-Vaisala) frequency for a temperature profile.</p></a></li>
<li><a href='#ts.center.buoyancy'><p>Calculates the center of buoyancy for multiple temperature profiles.</p></a></li>
<li><a href='#ts.internal.energy'><p>Calculate physical indices for a timeseries.</p></a></li>
<li><a href='#ts.lake.number'><p>Calculate physical indices for a timeseries.</p></a></li>
<li><a href='#ts.layer.temperature'><p>Calculate volume-weighted average water temperature across a range of depths</p>
for a timeseries.</a></li>
<li><a href='#ts.meta.depths'><p>Calculate physical indices for a timeseries.</p></a></li>
<li><a href='#ts.schmidt.stability'><p>Calculate physical indices for a timeseries.</p></a></li>
<li><a href='#ts.thermo.depth'><p>Calculate physical indices for a timeseries.</p></a></li>
<li><a href='#ts.uStar'><p>Calculate physical indices for a timeseries.</p></a></li>
<li><a href='#ts.wedderburn.number'><p>Calculate Wedderburn number for a timeseries.</p></a></li>
<li><a href='#uStar'><p>Calculates the water friction velocity, uStar</p></a></li>
<li><a href='#water.density'><p>Estimate Water Density</p></a></li>
<li><a href='#wedderburn.number'><p>Calculates Wedderburn Number for a lake.</p></a></li>
<li><a href='#whole.lake.temperature'><p>Get volumetrically averaged whole lake temperature</p></a></li>
<li><a href='#wtr.heat.map'><p>Plots a heat-map of water temperature.</p></a></li>
<li><a href='#wtr.heatmap.layers'><p>Plots water temperature heatmap with major limnetic layers indicated</p></a></li>
<li><a href='#wtr.layer'><p>Exploration of lake water column layers</p></a></li>
<li><a href='#wtr.lineseries'><p>Creates a line based plot of temperature profile time series</p></a></li>
<li><a href='#wtr.plot.temp'><p>Creates a time series plot of the thermocline and top and bottom of the</p>
metalimnion</a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Lake Physics Tools</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Luke Winslow &lt;lawinslow@gmail.com&gt;</td>
</tr>
<tr>
<td>Version:</td>
<td>1.11.4.1</td>
</tr>
<tr>
<td>Author:</td>
<td>Luke Winslow, Jordan Read, Richard Woolway, Jennifer Brentrup, Taylor
    Leach, Jake Zwart, Sam Albers, Doug Collinge</td>
</tr>
<tr>
<td>Description:</td>
<td>Standardized methods for calculating common important derived
    physical features of lakes including water density based based on
    temperature, thermal layers, thermocline depth, lake number, Wedderburn
    number, Schmidt stability and others.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10)</td>
</tr>
<tr>
<td>Imports:</td>
<td>plyr, stats, graphics, utils, grDevices</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, knitr, rmarkdown</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2019-06-09 18:33:32 UTC; hornik</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/GLEON/rLakeAnalyzer/issues">https://github.com/GLEON/rLakeAnalyzer/issues</a></td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2019-06-09 18:45:46 UTC</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>6.0.1</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
</table>
<hr>
<h2 id='rLakeAnalyzer'>Lake Physics Tools</h2><span id='topic+rLakeAnalyzer'></span><span id='topic+rLakeAnalyzer-package'></span>

<h3>Description</h3>

<p>Standardized methods for calculating common important derived 
physical features of lakes including water density based based on
temperature, thermal layers, thermocline depth, lake number, Wedderburn
number, Schmidt stability and others.
</p>

<hr>
<h2 id='approx.bathy'>Estimate hypsography curve</h2><span id='topic+approx.bathy'></span>

<h3>Description</h3>

<p>Estimates a depth-area curve for a lake using lake surface area, 
maximum depth and mean depth. Two methods for estimating the curve are available;
'cone' assumes the lake is shaped as a cone and requires only surface area and 
maximum depth; &quot;voldev&quot; uses the volume development (Vd) parameter from Hakanson (1981) 
and Johansson et al. (2007). Vd is a dimensionless parameter that describes 
lake basin shape in relation to the volume of cone whose base area and height 
equal the surface area and maximum lake depth, it is estimated as Vd = Zmean/Zmax (Hakanson et al. 2000). 
Method &quot;voldev' requires lake surface area, mean and maximum depth. Depths at 
which the area is estimated can be set by as a numeric vector or as a regularly spaced sequence.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>approx.bathy(Zmax, lkeArea, Zmean = NULL, method = "cone", zinterval = 1,
  depths = seq(0, Zmax, by = zinterval))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="approx.bathy_+3A_zmax">Zmax</code></td>
<td>
<p>a single value of the maxiumum depth of the lake (in m)</p>
</td></tr>
<tr><td><code id="approx.bathy_+3A_lkearea">lkeArea</code></td>
<td>
<p>a sinlge value of the surface area of the lake (in m^2)</p>
</td></tr>
<tr><td><code id="approx.bathy_+3A_zmean">Zmean</code></td>
<td>
<p>a single value of the mean depth of the lake (in m)</p>
</td></tr>
<tr><td><code id="approx.bathy_+3A_method">method</code></td>
<td>
<p>specifies the method used to estimate depth-area relationship, can be &quot;cone&quot;(default) or &quot;voldev&quot;. Method &quot;voldev&quot; requires Zmean. See notes for details.</p>
</td></tr>
<tr><td><code id="approx.bathy_+3A_zinterval">zinterval</code></td>
<td>
<p>a sinlge value defining the depth interval at which volumes should be calculated, default is 1 m.</p>
</td></tr>
<tr><td><code id="approx.bathy_+3A_depths">depths</code></td>
<td>
<p>a numeric vector of depths (in m) at which areas are estimated. 
If not specified depths is regularly spaced sequence of values with the interval set by zinterval.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a dataframe which defines the lake area for each depth. Columns are depths (m) and Area.at.z (m^2). Area at 0 m should equal the user entered lkeArea.
</p>


<h3>References</h3>

<p>Hakanson, L. (1981). On lake bottom dynamics - the energy- topography factor. Canadian Journal of Earth Sciences, 18, 899-909.
Johansson, H., A. A. Brolin, and L. Hakanson. 2007. New approaches to the modelling of lake basin morphometry. Environ. Model. Assess. 12: 213-228.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> 
Voldev.ex = approx.bathy(Zmax = 25, Zmean = 12, lkeArea = 39400000, method = "voldev")
Voldevshallow.ex = approx.bathy(Zmax = 25, Zmean = 6, lkeArea = 39400000, method = "voldev")
Cone.ex = approx.bathy(Zmax = 25, lkeArea = 39400000, method = "cone")

# plot depth-area curves
  plot(Cone.ex$depths ~ Cone.ex$Area.at.z, xlab = "Area (m^3)", ylab = "Depth (m)")
  points(Voldev.ex$depths ~ Voldev.ex$Area.at.z, col = "red")
  points(Voldevshallow.ex$depths ~ Voldevshallow.ex$Area.at.z, col = "blue")
 

</code></pre>

<hr>
<h2 id='buoyancy.freq'>Calculates buoyancy frequency.</h2><span id='topic+buoyancy.freq'></span>

<h3>Description</h3>

<p>Calculate the buoyancy frequency (Brunt-Vaisala frequency) for a temperature
profile.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>buoyancy.freq(wtr, depths)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="buoyancy.freq_+3A_wtr">wtr</code></td>
<td>
<p>a numeric vector of water temperature in degrees C</p>
</td></tr>
<tr><td><code id="buoyancy.freq_+3A_depths">depths</code></td>
<td>
<p>a numeric vector corresponding to the depths (in m) of the wtr
measurements</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a vector of buoyancy frequency in units <code>sec^-2</code>.
Return value has attribute &quot;depths&quot; which define buoyancy frequency depths
(which differ from supplied depths).
</p>


<h3>See Also</h3>

<p><code>thermo.depth</code>, <code>ts.buoyancy.freq</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

	# A vector of water temperatures
	wtr = c(22.51, 22.42, 22.4, 22.4, 22.4, 22.36, 22.3, 22.21, 22.11, 21.23, 16.42, 
		15.15, 14.24, 13.35, 10.94, 10.43, 10.36, 9.94, 9.45, 9.1, 8.91, 8.58, 8.43)

	#A vector defining the depths
	depths = c(0, 0.5, 1, 1.5, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 
		17, 18, 19, 20)
	
	b.f = buoyancy.freq(wtr, depths)
	
	plot(b.f, attr(b.f, 'depths'), type='b', 
		ylab='Depth', xlab='Buoyancy Frequency', ylim=c(max(depths), min(depths)))

</code></pre>

<hr>
<h2 id='center.buoyancy'>Calculates the center of buoyancy.</h2><span id='topic+center.buoyancy'></span>

<h3>Description</h3>

<p>Calculate the center of buoyancy using buoyancy frequency with a center of
mass analysis. Brunt-Vaisala frequency is used for a temperature profile.
Negative values for N2 are set to 0 (as they represent transient
instabilities or sensor calibration issues) for this calculation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>center.buoyancy(wtr, depths)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="center.buoyancy_+3A_wtr">wtr</code></td>
<td>
<p>a numeric vector of water temperature in degrees C</p>
</td></tr>
<tr><td><code id="center.buoyancy_+3A_depths">depths</code></td>
<td>
<p>a numeric vector corresponding to the depths (in m) of the wtr
measurements</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a value for the center of buoyancy.
</p>


<h3>See Also</h3>

<p><code>buoyancy.freq</code>, <code>ts.buoyancy.freq</code>,
<code>center.buoyancy</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

	# A vector of water temperatures
	wtr = c(22.51, 22.42, 22.4, 22.4, 22.4, 22.36, 22.3, 22.21, 22.11, 21.23, 16.42, 
		15.15, 14.24, 13.35, 10.94, 10.43, 10.36, 9.94, 9.45, 9.1, 8.91, 8.58, 8.43)

	#A vector defining the depths
	depths = c(0, 0.5, 1, 1.5, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 
		17, 18, 19, 20)
	
	c.b = center.buoyancy(wtr, depths)

</code></pre>

<hr>
<h2 id='cline_calc'>Calculate cline of series of segments</h2><span id='topic+cline_calc'></span>

<h3>Description</h3>

<p>Cline depth is defined as the midpoint of the segment connecting inflection
points that has the maximum slope. A cline cannot occur over a depth range
of less than 1m and also cannot be the shallowest segment. Violating both
conditions will thrown warnings though this function handles both
differently. Used mostly with <code>wtr_layer</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cline_calc(z_seg = z_seg, sigma_seg = sigma_seg)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cline_calc_+3A_z_seg">z_seg</code></td>
<td>
<p>depth in metres; should be an increasing vector</p>
</td></tr>
<tr><td><code id="cline_calc_+3A_sigma_seg">sigma_seg</code></td>
<td>
<p>parameter measured in the water column profile</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the depth of the cline
</p>


<h3>References</h3>

<p>Fiedler, Paul C. Comparison of objective descriptions of the
thermocline. Limnology and Oceanography: Methods 8.6 (2010): 313-325.
</p>


<h3>See Also</h3>

<p><code>wtr_layer()</code>
</p>

<hr>
<h2 id='depth.filter'>Data filter to remove soak, heave and upcast</h2><span id='topic+depth.filter'></span>

<h3>Description</h3>

 <ul>
<li><p> Soak period: water profiling instruments typically require a
soak period where you let the instrument rest submerged at the surface.
While it is &quot;soaking&quot; it is collecting data. We don't want that data </p>
</li>
<li>
<p>Upcast versus downcast: typically instruments are turned on before you put
them in the water and turn them off once you pull them out. The data
consequence of that is that you collect both the &quot;downcast&quot; and the
&quot;upcast&quot;. In some case the upcast is of interest but usually it isn't. And
because we would prefer increasing depth data it is better to remove an
upcast if it is present.  </p>
</li>
<li><p> Heave: when lowering the instrument in rough
weather a boat will heave side to side. Sometimes it will heave enough that
you get small data groupings where the decreases a little while the boat
heaves then go down. The overall trend is still down but those slight
upticks in depth cause problems for our algorithm. </p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>depth.filter(z0, run_length = 20, index = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="depth.filter_+3A_z0">z0</code></td>
<td>
<p>depth vector</p>
</td></tr>
<tr><td><code id="depth.filter_+3A_run_length">run_length</code></td>
<td>
<p>Length of run upon which to start the soak removal</p>
</td></tr>
<tr><td><code id="depth.filter_+3A_index">index</code></td>
<td>
<p>Logical: Should the function return an index value or actual
value?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>index values of z0 of filtered data. Will return a warning if the
function removed more than 10
</p>

<hr>
<h2 id='drop.datetime'>Find and drop the datetime column from the datatable</h2><span id='topic+drop.datetime'></span>

<h3>Description</h3>

<p>Liberally looks for a datetime column and drops it, 
returning a data.frame with only water temperature. Errors if datetime column is 
ambiguous. Warns if there is no match.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>drop.datetime(data, error = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="drop.datetime_+3A_data">data</code></td>
<td>
<p>data arg</p>
</td></tr>
<tr><td><code id="drop.datetime_+3A_error">error</code></td>
<td>
<p>defaults to FALSE</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame with only the data, after datetime has been dropped
</p>

<hr>
<h2 id='epi.temperature'>Get volumetrically averaged epilimnion temp</h2><span id='topic+epi.temperature'></span>

<h3>Description</h3>

<p>Calculates volumetrically weighted average epilimnetic temperature using the
supplied water temperature timeseries. If the lake is not stratified, the
bottom of the epilimnion is calculated as the full depth of the lake.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>epi.temperature(wtr, depths, bthA, bthD)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="epi.temperature_+3A_wtr">wtr</code></td>
<td>
<p>a numeric vector of water temperature in degrees C.</p>
</td></tr>
<tr><td><code id="epi.temperature_+3A_depths">depths</code></td>
<td>
<p>a numeric vector corresponding to the depths (in m) of the wtr
measurements</p>
</td></tr>
<tr><td><code id="epi.temperature_+3A_btha">bthA</code></td>
<td>
<p>a numeric vector of cross sectional areas (m^2) corresponding to
bthD depths</p>
</td></tr>
<tr><td><code id="epi.temperature_+3A_bthd">bthD</code></td>
<td>
<p>a numeric vector of depths (m) which correspond to areal
measures in bthA</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+hypo.temperature">hypo.temperature</a></code> <code><a href="#topic+whole.lake.temperature">whole.lake.temperature</a></code>
</p>

<hr>
<h2 id='get.datetime'>Search for and return the datetime column from a ts data.frame</h2><span id='topic+get.datetime'></span>

<h3>Description</h3>

<p>Warns if unavailable then returns NULL.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.datetime(data, error = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.datetime_+3A_data">data</code></td>
<td>
<p>data arg</p>
</td></tr>
<tr><td><code id="get.datetime_+3A_error">error</code></td>
<td>
<p>defaults to FALSE</p>
</td></tr>
</table>

<hr>
<h2 id='get.offsets'>Gets depths from data frame containing profile info.</h2><span id='topic+get.offsets'></span>

<h3>Description</h3>

<p>Extracts the depth information from a data frame containing multi-depth
observation data. Relies on the format of the header to get information and
may fail if your file format is incorrect. Please follow 'VAR_##.#' format,
where ##.# is the depth of data for that column. VAR is typically 'wtr' to
indicate water temperature.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.offsets(data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.offsets_+3A_data">data</code></td>
<td>
<p>Data frame returned from <code><a href="#topic+load.ts">load.ts</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector of depth values. Should be the <code>ncol(data) -
1</code> in length as the first column contains date/time data.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+load.ts">load.ts</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

#Get the path for the package example file included
exampleFilePath &lt;- system.file('extdata', 'Sparkling.wtr', package="rLakeAnalyzer")

#Load
sparkling.temp = load.ts(exampleFilePath)

#get the lake depths associated with each column
depths = get.offsets(sparkling.temp)

print(depths)
</code></pre>

<hr>
<h2 id='hypo.temperature'>Get volumetrically averaged hypolimnion temp</h2><span id='topic+hypo.temperature'></span>

<h3>Description</h3>

<p>Calculates volumetrically weighted average hypolimnetic temperature using
the supplied water temperature timeseries. If the lake is not stratified, an
NA value is returned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hypo.temperature(wtr, depths, bthA, bthD)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hypo.temperature_+3A_wtr">wtr</code></td>
<td>
<p>a numeric vector of water temperature in degrees C.</p>
</td></tr>
<tr><td><code id="hypo.temperature_+3A_depths">depths</code></td>
<td>
<p>a numeric vector corresponding to the depths (in m) of the wtr
measurements</p>
</td></tr>
<tr><td><code id="hypo.temperature_+3A_btha">bthA</code></td>
<td>
<p>a numeric vector of cross sectional areas (m^2) corresponding to
bthD depths</p>
</td></tr>
<tr><td><code id="hypo.temperature_+3A_bthd">bthD</code></td>
<td>
<p>a numeric vector of depths (m) which correspond to areal
measures in bthA</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+epi.temperature">epi.temperature</a></code>, <code><a href="#topic+whole.lake.temperature">whole.lake.temperature</a></code>
</p>

<hr>
<h2 id='internal.energy'>Internal energy function (Joules)</h2><span id='topic+internal.energy'></span>

<h3>Description</h3>

<p>Calculates the internal energy of the water column with temperature and
hypsography
</p>
<p>Internal energy is the thermal energy in the water column, which is
calculated by multiplying the specific heat of water (J kg-1 K-1) by the
temperature and mass of the water in the lake.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>internal.energy(wtr, depths, bthA, bthD)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="internal.energy_+3A_wtr">wtr</code></td>
<td>
<p>a numeric vector of water temperature in degrees C</p>
</td></tr>
<tr><td><code id="internal.energy_+3A_depths">depths</code></td>
<td>
<p>a numeric vector corresponding to the depths (in m) of the wtr
measurements</p>
</td></tr>
<tr><td><code id="internal.energy_+3A_btha">bthA</code></td>
<td>
<p>a numeric vector of cross sectional areas (m^2) corresponding to
bthD depths</p>
</td></tr>
<tr><td><code id="internal.energy_+3A_bthd">bthD</code></td>
<td>
<p>a numeric vector of depths (m) which correspond to areal
measures in bthA</p>
</td></tr>
</table>


<h3>Value</h3>

<p>internal energy in Joules m-2. (Currently not vectorized..)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
bthA  &lt;-	c(1000,900,864,820,200,10)
bthD	&lt;-	c(0,2.3,2.5,4.2,5.8,7)

wtr	&lt;-	c(28,27,26.4,26,25.4,24,23.3)
depths	&lt;-	c(0,1,2,3,4,5,6)

cat('Internal Energy for input is: ')
cat(internal.energy(wtr, depths, bthA, bthD))
</code></pre>

<hr>
<h2 id='lake.number'>Calculate Lake Number</h2><span id='topic+lake.number'></span>

<h3>Description</h3>

<p>The Lake Number, defined by Imberger and Patterson (1990), has been used to
describe processes relevant to the internal mixing of lakes induced by wind
forcings. Lower values of Lake Number represent a higher potential for
increased diapycnal mixing, which increases the vertical flux of mass and
energy across the metalimnion through the action of non-linear internal
waves. Lake Number is a dimensionless index.
</p>
<p>Lake Number has been used, for example, to estimate the flux of oxygen
across the thermocline in a small lake (Robertson and Imberger, 1994), and
to explain the magnitude of the vertical flux of ammonium in a lake (Romero
et al., 1998).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lake.number(bthA, bthD, uStar, St, metaT, metaB, averageHypoDense)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lake.number_+3A_btha">bthA</code></td>
<td>
<p>a numeric vector of cross sectional areas (m2) corresponding to
bthD depths, hypsographic areas</p>
</td></tr>
<tr><td><code id="lake.number_+3A_bthd">bthD</code></td>
<td>
<p>a numeric vector of depths (m) which correspond to areal
measures in bthA, hypsographic depths</p>
</td></tr>
<tr><td><code id="lake.number_+3A_ustar">uStar</code></td>
<td>
<p>a numeric array of u* (m/s), water friction velocity due to
wind stress</p>
</td></tr>
<tr><td><code id="lake.number_+3A_st">St</code></td>
<td>
<p>a numeric array of Schmidt stability (J/m2), as defined by Idso
1973</p>
</td></tr>
<tr><td><code id="lake.number_+3A_metat">metaT</code></td>
<td>
<p>a numeric array of the top of the metalimnion depth (m from the
surface)</p>
</td></tr>
<tr><td><code id="lake.number_+3A_metab">metaB</code></td>
<td>
<p>a numeric array of the bottom of the metalimnion depth (m from
the surface)</p>
</td></tr>
<tr><td><code id="lake.number_+3A_averagehypodense">averageHypoDense</code></td>
<td>
<p>a numeric array of the average density of the
hypolimnion (kg/m3)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector of Lake Number [dimensionless]
</p>


<h3>References</h3>

<p>Imberger, J., Patterson, J.C., 1990. <em>Physical limnology</em>.
Advances in Applied Mechanics 27, 303-475.
</p>
<p>Idso, S.B., 1973. <em>On the concept of lake stability</em>. Limnology and
Oceanography 18, 681-683.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ts.lake.number">ts.lake.number</a></code> <code><a href="#topic+wedderburn.number">wedderburn.number</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
	bthA	&lt;-	c(1000,900,864,820,200,10)
	bthD	&lt;-	c(0,2.3,2.5,4.2,5.8,7)
	uStar	&lt;-	c(0.0032,0.0024)
	St	&lt;-	c(140,153)
	metaT	&lt;-	c(1.34,1.54)
	metaB	&lt;-	c(4.32,4.33)
	averageHypoDense	&lt;-	c(999.3,999.32)
	cat('Lake Number for input vector is: ')
	cat(lake.number( bthA, bthD, uStar, St, metaT, metaB, averageHypoDense) )

</code></pre>

<hr>
<h2 id='lake.number.plot'>Plots time series of Lake Number</h2><span id='topic+lake.number.plot'></span>

<h3>Description</h3>

<p>Generates a time series plot of Lake Number for appropriately formatted
data.  See <code><a href="#topic+lake.number">lake.number</a></code> for more details on Lake Number and
reference.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lake.number.plot(wtr, wnd, wh, bth)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lake.number.plot_+3A_wtr">wtr</code></td>
<td>
<p>Data frame of water temperature loaded with <code><a href="#topic+load.ts">load.ts</a></code></p>
</td></tr>
<tr><td><code id="lake.number.plot_+3A_wnd">wnd</code></td>
<td>
<p>A data frame containing hypsometric data. Loaded using
<code><a href="#topic+load.bathy">load.bathy</a></code></p>
</td></tr>
<tr><td><code id="lake.number.plot_+3A_wh">wh</code></td>
<td>
<p>A value indicating the height of the anemometer above lake surface
in meters.  This value must be specified, there is no default.</p>
</td></tr>
<tr><td><code id="lake.number.plot_+3A_bth">bth</code></td>
<td>
<p>A data frame containing hypsometric data. Loaded using
<code><a href="#topic+load.bathy">load.bathy</a></code></p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+wtr.lineseries">wtr.lineseries</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
	#Get system data file paths 
	wtr.path &lt;- system.file('extdata', 'Sparkling.wtr', package="rLakeAnalyzer")
	bth.path &lt;- system.file('extdata', 'Sparkling.bth', package="rLakeAnalyzer")
	wnd.path &lt;- system.file('extdata', 'Sparkling.wnd', package="rLakeAnalyzer")

	#Load data for example lake, Sparkilng Lake, Wisconsin.
	wtr = load.ts(wtr.path)
	wnd = load.ts(wnd.path)
	bth = load.bathy(bth.path)
	wh = 1 # user specified, here as 1 m.
  ## Not run: 
  #generate default plot
	lake.number.plot(wtr,wnd,wh,bth)
	
## End(Not run)
</code></pre>

<hr>
<h2 id='latesummer'>Late Summer Profile</h2><span id='topic+latesummer'></span>

<h3>Description</h3>

<p>Late summer water profile taken from Quesnel Lake, British Columbia, Canada. Profile taken with Sea-Bird
SBE19plus.
</p>

<dl>
<dt>depth</dt><dd><p>Depth, m</p>
</dd>
<dt>temper</dt><dd><p>Temperature, degC</p>
</dd>
<dt>salinity</dt><dd><p>Salinity, PSU</p>
</dd>
<dt>oxygen</dt><dd><p>Oxygen, ml/l</p>
</dd>
<dt>oxygen.sat</dt><dd><p>Oxygen saturation, percent saturation</p>
</dd>
<dt>density</dt><dd><p>Density, kg/m^3</p>
</dd>
</dl>
<p>...

</p>


<h3>Usage</h3>

<pre><code class='language-R'>latesummer
</code></pre>


<h3>Format</h3>

<p>An object of class <code>data.frame</code> with 881 rows and 6 columns.</p>

<hr>
<h2 id='layer.density'>Returns the average density of a layer between two depths.</h2><span id='topic+layer.density'></span>

<h3>Description</h3>

<p>This function calculates the average density of a layer of water between two
depths.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>layer.density(top, bottom, wtr, depths, bthA, bthD, sal = wtr * 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="layer.density_+3A_top">top</code></td>
<td>
<p>Numeric value of the depth (m) of the top of the layer from the
water surface</p>
</td></tr>
<tr><td><code id="layer.density_+3A_bottom">bottom</code></td>
<td>
<p>Numeric value of the depth (m) of the bottom of the layer from
the water surface</p>
</td></tr>
<tr><td><code id="layer.density_+3A_wtr">wtr</code></td>
<td>
<p>Numeric vector of water temperature in degrees C</p>
</td></tr>
<tr><td><code id="layer.density_+3A_depths">depths</code></td>
<td>
<p>Numeric vector of depths (m) corresponding to water
temperature vector</p>
</td></tr>
<tr><td><code id="layer.density_+3A_btha">bthA</code></td>
<td>
<p>Numeric vector of water body cross sectional area (m2)
corresponding to bthD depths</p>
</td></tr>
<tr><td><code id="layer.density_+3A_bthd">bthD</code></td>
<td>
<p>Numeric vector of water body bathymetric depths (m)
corresponding to areal bthA values</p>
</td></tr>
<tr><td><code id="layer.density_+3A_sal">sal</code></td>
<td>
<p>Optional numeric vector of salinity in Practical Salinity Units
corresponding to water temperature vector. If left blank, salinity is set to
be zero</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric value of average water density for bounded layer in kg/m^3
</p>


<h3>See Also</h3>

<p><code>water.density</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
top     &lt;- 2
bottom  &lt;- 6
wtr     &lt;- c(25.2,25.1,24.1,22.0,19.8,15.3,12.0,11.1)
depths  &lt;- c(0,1,2,3,4,5,6,7) 
bthA    &lt;- c(10000,8900,5000,3500,2000,1000,300,10)
bthD    &lt;- c(0,1,2,3,4,5,6,7)
layer.density(top,bottom,wtr,depths,bthA,bthD)
</code></pre>

<hr>
<h2 id='layer.temperature'>Returns the average temperature of a layer between two depths.</h2><span id='topic+layer.temperature'></span>

<h3>Description</h3>

<p>This function calculates the average temperature of a layer of water between
two depths.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>layer.temperature(top, bottom, wtr, depths, bthA, bthD)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="layer.temperature_+3A_top">top</code></td>
<td>
<p>Numeric value of the depth (m) of the top of the layer from the
water surface</p>
</td></tr>
<tr><td><code id="layer.temperature_+3A_bottom">bottom</code></td>
<td>
<p>Numeric value of the depth (m) of the bottom of the layer from
the water surface</p>
</td></tr>
<tr><td><code id="layer.temperature_+3A_wtr">wtr</code></td>
<td>
<p>Numeric vector of water temperature in degrees C</p>
</td></tr>
<tr><td><code id="layer.temperature_+3A_depths">depths</code></td>
<td>
<p>Numeric vector of depths (m) corresponding to water
temperature vector</p>
</td></tr>
<tr><td><code id="layer.temperature_+3A_btha">bthA</code></td>
<td>
<p>Numeric vector of water body cross sectional area (m2)
corresponding to bthD depths</p>
</td></tr>
<tr><td><code id="layer.temperature_+3A_bthd">bthD</code></td>
<td>
<p>Numeric vector of water body bathymetric depths (m)
corresponding to areal bthA values</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric value of average water temperature
</p>


<h3>See Also</h3>

<p><code>layer.density</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
	# Supply input data
	top     &lt;- 2
	bottom  &lt;- 6
	wtr     &lt;- c(25.2,25.1,24.1,22.0,19.8,15.3,12.0,11.1)
	depths  &lt;- c(0,1,2,3,4,5,6,7) 
	bthA    &lt;- c(10000,8900,5000,3500,2000,1000,300,10)
	bthD    &lt;- c(0,1,2,3,4,5,6,7)
	
	#Return the average temperature of the water column between 2 and 6 meters.
	layer.temperature(top,bottom,wtr,depths,bthA,bthD)
</code></pre>

<hr>
<h2 id='load.bathy'>Import lake bathymetry data.</h2><span id='topic+load.bathy'></span>

<h3>Description</h3>

<p>Imports lake bathymetry data. Bathymetric data file must be a 2 column array
where depth (in meters) and area (in meters^2) information are provided in
columns with headers containing the words &quot;depths&quot; and &quot;areas&quot; respectively.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>load.bathy(fPath)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="load.bathy_+3A_fpath">fPath</code></td>
<td>
<p>File path to the bathymetry file.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.frame of depth and area for given lake.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+load.ts">load.ts</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  #Get the path for the package example file included
  exampleFilePath &lt;- system.file('extdata', 'Sparkling.bth', package="rLakeAnalyzer")
  
  #Load and plot the hypsometric curve
  sparkling.bathy = load.bathy(exampleFilePath)
  
  #If successful, there will be two colums. "depths", and "areas".
  plot(sparkling.bathy$areas, sparkling.bathy$depths, type='l', ylim=c(20,0), 
    ylab='Depths (m)', xlab='Areas (m^2)')
  
</code></pre>

<hr>
<h2 id='load.ts'>Load timeseries from properly formatted text file.</h2><span id='topic+load.ts'></span>

<h3>Description</h3>

<p>A convenience function to load timeseries data into R based on the
standardized format used by Lake Analyzer.
</p>
<p>Timeseries files must follow a common format. The first column must have the
label 'datetime' and be of the format <em>yyyy-mm-dd HH:MM:SS</em> (ISO 8601
without the &quot;T&quot; delimiter). The second can be skipped if not using
sub-minute data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>load.ts(fPath, tz = "GMT")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="load.ts_+3A_fpath">fPath</code></td>
<td>
<p>The file path as a string.</p>
</td></tr>
<tr><td><code id="load.ts_+3A_tz">tz</code></td>
<td>
<p>Timezone string to be supplied to <code><a href="base.html#topic+as.POSIXct">as.POSIXct</a></code>.
Defaults to GMT (UTC-0). This often can be left to the default unless
timezone support is specifically required.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame in the required format for use with other rLakeAnalyzer
timeseries functions.
</p>


<h3>See Also</h3>

<p>For dataloading <code><a href="#topic+ts.meta.depths">ts.meta.depths</a></code>, <br /> For analyzing
timeseries data, see <code><a href="#topic+ts.meta.depths">ts.meta.depths</a></code>,
<code><a href="#topic+ts.thermo.depth">ts.thermo.depth</a></code>, <code><a href="#topic+ts.schmidt.stability">ts.schmidt.stability</a></code>,
<code><a href="#topic+ts.lake.number">ts.lake.number</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
	#Get the path for the package example file included
	exampleFilePath &lt;- system.file('extdata', 'Sparkling.wtr', package="rLakeAnalyzer")
	
	#Load
	sparkling.temp = load.ts(exampleFilePath)
	
	#calculate and plot the thermocline depth
	t.d = ts.thermo.depth(sparkling.temp)
	
	plot(t.d$datetime, t.d$thermo.depth, type='l', ylab='Thermocline Depth (m)', xlab='Date')
</code></pre>

<hr>
<h2 id='meta.depths'>Calculate the Top and Bottom Depths of the Metalimnion</h2><span id='topic+meta.depths'></span>

<h3>Description</h3>

<p>Calculates the top and bottom depths of the metalimnion in a stratified
lake. The metalimnion is defined as the water stratum in a stratified lake
with the steepest thermal gradient and is demarcated by the bottom of the
epilimnion and top of the hypolimnion.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>meta.depths(wtr, depths, slope = 0.1, seasonal = TRUE, mixed.cutoff = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="meta.depths_+3A_wtr">wtr</code></td>
<td>
<p>a numeric vector of water temperature in degrees C</p>
</td></tr>
<tr><td><code id="meta.depths_+3A_depths">depths</code></td>
<td>
<p>a numeric vector corresponding to the depths (in m) of the wtr
measurements</p>
</td></tr>
<tr><td><code id="meta.depths_+3A_slope">slope</code></td>
<td>
<p>a numeric vector corresponding to the minimum slope</p>
</td></tr>
<tr><td><code id="meta.depths_+3A_seasonal">seasonal</code></td>
<td>
<p>a logical value indicating whether the seasonal thermocline
should be returned. This is fed to thermo.depth, which is used as the
starting point.  The seasonal thermocline is defined as the deepest density
gradient found in the profile. If <code>FALSE</code>, the depth of the maximum
density gradient is used as the starting point.</p>
</td></tr>
<tr><td><code id="meta.depths_+3A_mixed.cutoff">mixed.cutoff</code></td>
<td>
<p>A cutoff (deg C) where below this threshold,
thermo.depth and meta.depths are not calculated (NaN is returned). Defaults
to 1 deg C.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector of the top and bottom metalimnion depths in meters.
Returns the bottom depth if no distinct metalimion top and bottom found.
</p>


<h3>References</h3>

<p>Wetzel, R. G. 2001. Limnology: Lake and River Ecosystems, 3rd
ed. Academic Press.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ts.meta.depths">ts.meta.depths</a></code>, <code><a href="#topic+thermo.depth">thermo.depth</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
wtr = c(22.51, 22.42, 22.4, 22.4, 22.4, 22.36, 22.3, 22.21, 22.11, 21.23, 16.42, 
15.15, 14.24, 13.35, 10.94, 10.43, 10.36, 9.94, 9.45, 9.1, 8.91, 8.58, 8.43)

depths = c(0, 0.5, 1, 1.5, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 
			 17, 18, 19, 20)
			 
m.d = meta.depths(wtr, depths, slope=0.1, seasonal=FALSE)
cat('The top depth of the metalimnion is:', m.d[1])
cat('The bottom depth of the metalimnion is:', m.d[2])

</code></pre>

<hr>
<h2 id='schmidt.plot'>Creates a time series plot of Schmidt's stability</h2><span id='topic+schmidt.plot'></span>

<h3>Description</h3>

<p>Generates a time series of Schmidt's stability where each value represents
water column stability for each time step of data. See
<code><a href="#topic+schmidt.stability">schmidt.stability</a></code> for more details and reference.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>schmidt.plot(wtr, bth)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="schmidt.plot_+3A_wtr">wtr</code></td>
<td>
<p>Data frame of water temperature loaded with <code><a href="#topic+load.ts">load.ts</a></code></p>
</td></tr>
<tr><td><code id="schmidt.plot_+3A_bth">bth</code></td>
<td>
<p>A data frame containing hypsometric data. Loaded using
<code><a href="#topic+load.bathy">load.bathy</a></code></p>
</td></tr>
</table>


<h3>References</h3>

<p>See <code><a href="#topic+schmidt.stability">schmidt.stability</a></code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+schmidt.stability">schmidt.stability</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
	# Get system data file paths 
  wtr.path &lt;- system.file('extdata', 'Sparkling.wtr', package="rLakeAnalyzer")
	bth.path &lt;- system.file('extdata', 'Sparkling.bth', package="rLakeAnalyzer")

	# Load data for example lake, Sparkilng Lake, Wisconsin.
	wtr = load.ts(wtr.path)
	bth = load.bathy(bth.path)
	
	## Not run: 
  # Generate default plot
  schmidt.plot(wtr,bth)
  
## End(Not run)
</code></pre>

<hr>
<h2 id='schmidt.stability'>Calculate the Schmidt stability</h2><span id='topic+schmidt.stability'></span>

<h3>Description</h3>

<p>Schmidt stability, or the resistance to mechanical mixing due to the
potential energy inherent in the stratification of the water column.
</p>
<p>Schmidt stability was first defined by Schmidt (1928) and later modified by
Hutchinson (1957). This stability index was formalized by Idso (1973) to
reduce the effects of lake volume on the calculation (resulting in a mixing
energy requirement per unit area).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>schmidt.stability(wtr, depths, bthA, bthD, sal = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="schmidt.stability_+3A_wtr">wtr</code></td>
<td>
<p>a numeric vector of water temperature in degrees C</p>
</td></tr>
<tr><td><code id="schmidt.stability_+3A_depths">depths</code></td>
<td>
<p>a numeric vector corresponding to the depths (in m) of the wtr
measurements</p>
</td></tr>
<tr><td><code id="schmidt.stability_+3A_btha">bthA</code></td>
<td>
<p>a numeric vector of cross sectional areas (m^2) corresponding to
bthD depths</p>
</td></tr>
<tr><td><code id="schmidt.stability_+3A_bthd">bthD</code></td>
<td>
<p>a numeric vector of depths (m) which correspond to areal
measures in bthA</p>
</td></tr>
<tr><td><code id="schmidt.stability_+3A_sal">sal</code></td>
<td>
<p>a numeric vector of salinity in Practical Salinity Scale units</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a numeric vector of Schmidt stability (J/m^2)
</p>


<h3>References</h3>

<p>Schmidt, W., 1928. <em>Ueber Temperatur and
Stabilitaetsverhaltnisse von Seen</em>. Geo- graphiska Annaler 10, 145-177.
</p>
<p>Hutchinson, G.E., 1957. <em>A Treatise on Limnology</em>, vol. 1. John Wiley &amp;
Sons, Inc., New York.
</p>
<p>Idso, S.B., 1973. <em>On the concept of lake stability</em>. Limnology and
Oceanography 18, 681-683.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ts.schmidt.stability">ts.schmidt.stability</a></code> <code><a href="#topic+lake.number">lake.number</a></code>
<code><a href="#topic+wedderburn.number">wedderburn.number</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

	bthA	&lt;-	c(1000,900,864,820,200,10)
	bthD	&lt;-	c(0,2.3,2.5,4.2,5.8,7)
	
	wtr	&lt;-	c(28,27,26.4,26,25.4,24,23.3)
	depths	&lt;-	c(0,1,2,3,4,5,6)
	
	cat('Schmidt stability for input is: ')
	cat(schmidt.stability(wtr, depths, bthA, bthD))
</code></pre>

<hr>
<h2 id='thermo.depth'>Calculate depth of the thermocline from a temperature profile.</h2><span id='topic+thermo.depth'></span>

<h3>Description</h3>

<p>This function calculates the location of the thermocline from a temperature
profile.  It uses a special technique to estimate where the thermocline lies
even between two temperature measurement depths, giving a potentially
finer-scale estimate than usual techniques.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>thermo.depth(wtr, depths, Smin = 0.1, seasonal = TRUE, index = FALSE,
  mixed.cutoff = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="thermo.depth_+3A_wtr">wtr</code></td>
<td>
<p>a numeric vector of water temperature in degrees C</p>
</td></tr>
<tr><td><code id="thermo.depth_+3A_depths">depths</code></td>
<td>
<p>a numeric vector corresponding to the depths (in m) of the wtr
measurements</p>
</td></tr>
<tr><td><code id="thermo.depth_+3A_smin">Smin</code></td>
<td>
<p>Optional paramter defining minimum density gradient for
thermocline</p>
</td></tr>
<tr><td><code id="thermo.depth_+3A_seasonal">seasonal</code></td>
<td>
<p>a logical value indicating whether the seasonal thermocline
should be returned. This is fed to thermo.depth, which is used as the
starting point.  The seasonal thermocline is defined as the deepest density
gradient found in the profile. If <code>FALSE</code>, the depth of the maximum
density gradient is used as the starting point.</p>
</td></tr>
<tr><td><code id="thermo.depth_+3A_index">index</code></td>
<td>
<p>Boolean value indicated if index of the thermocline depth,
instead of the depth value, should be returned.</p>
</td></tr>
<tr><td><code id="thermo.depth_+3A_mixed.cutoff">mixed.cutoff</code></td>
<td>
<p>A cutoff (deg C) where below this threshold,
thermo.depth and meta.depths are not calculated (NaN is returned). Defaults
to 1 deg C.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Depth of thermocline. If no thermocline found, value is NaN.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ts.thermo.depth">ts.thermo.depth</a></code>, <code>water.density</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# A vector of water temperatures
wtr = c(22.51, 22.42, 22.4, 22.4, 22.4, 22.36, 22.3, 22.21, 22.11, 21.23, 16.42, 
		15.15, 14.24, 13.35, 10.94, 10.43, 10.36, 9.94, 9.45, 9.1, 8.91, 8.58, 8.43)

 #A vector defining the depths
 depths = c(0, 0.5, 1, 1.5, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 
     17, 18, 19, 20)

 t.d = thermo.depth(wtr, depths, seasonal=FALSE)

 cat('The thermocline depth is:', t.d)

</code></pre>

<hr>
<h2 id='ts.buoyancy.freq'>Calculate the buoyancy (Brunt-Vaisala) frequency for a temperature profile.</h2><span id='topic+ts.buoyancy.freq'></span>

<h3>Description</h3>

<p>Function for simplifying the calculation of buoyancy frequency. Can usually
be called directly on data loaded directly using <code><a href="#topic+load.ts">load.ts</a></code> and
<code><a href="#topic+load.bathy">load.bathy</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ts.buoyancy.freq(wtr, at.thermo = TRUE, na.rm = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ts.buoyancy.freq_+3A_wtr">wtr</code></td>
<td>
<p>A data frame of water temperatures (in Celsius). Loaded using
<code><a href="#topic+load.ts">load.ts</a></code></p>
</td></tr>
<tr><td><code id="ts.buoyancy.freq_+3A_at.thermo">at.thermo</code></td>
<td>
<p>Boolean indicating if only buoyancy frequency at the
thermocline should be returned. If false, full profile is returned.</p>
</td></tr>
<tr><td><code id="ts.buoyancy.freq_+3A_na.rm">na.rm</code></td>
<td>
<p>Boolean indicated if step-by-step removal of NA's should be
tried. If false, a timestep with any NA values will likely return an NA
value. If true, best effort will be made to calculate indices despite NA
values.</p>
</td></tr>
<tr><td><code id="ts.buoyancy.freq_+3A_...">...</code></td>
<td>
<p>Additional parameters will be passed on to <code>thermo.depth</code>
function when extracting buoyancy frequency at only the thermocline.  Common
parameters to supply would be <code>seasonal</code> and <code>slope</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a data frame with the timeseries of buoyancy frequency in
units <code>sec^-2</code>. Includes a &lsquo;datetime&rsquo; column.
</p>


<h3>References</h3>

<p>Imberger, J., Patterson, J.C., 1990. <em>Physical limnology</em>.
Advances in Applied Mechanics 27, 353-370.
</p>


<h3>See Also</h3>

<p><code>buoyancy.freq</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

	#Get the path for the package example file included
	wtr.path &lt;- system.file('extdata', 'Sparkling.daily.wtr', package="rLakeAnalyzer")
	
	#Load data for example lake, Sparkilng Lake, Wisconsin.
	sp.wtr = load.ts(wtr.path)
	
	N2 = ts.buoyancy.freq(sp.wtr, seasonal=FALSE)
	SN2 = ts.buoyancy.freq(sp.wtr, seasonal=TRUE)
	
	plot(N2, type='l', ylab='Buoyancy Frequency', xlab='Date')
	lines(SN2, col='red')
	
</code></pre>

<hr>
<h2 id='ts.center.buoyancy'>Calculates the center of buoyancy for multiple temperature profiles.</h2><span id='topic+ts.center.buoyancy'></span>

<h3>Description</h3>

<p>Function for simplifying the calculation of the center of buoyancy. Can
usually be called directly on data loaded directly using
<code><a href="#topic+load.ts">load.ts</a></code> and <code><a href="#topic+load.bathy">load.bathy</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ts.center.buoyancy(wtr, na.rm = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ts.center.buoyancy_+3A_wtr">wtr</code></td>
<td>
<p>A data frame of water temperatures (in Celsius). Loaded using
<code><a href="#topic+load.ts">load.ts</a></code></p>
</td></tr>
<tr><td><code id="ts.center.buoyancy_+3A_na.rm">na.rm</code></td>
<td>
<p>Boolean indicated if step-by-step removal of NA's should be
tried. If false, a timestep with any NA values will return an NA value. If
true, best effort will be made to calculate indices despite NA values.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a data frame with the timeseries of the center of buoyancy
frequency. Includes a &lsquo;datetime&rsquo; column.
</p>


<h3>References</h3>

<p>Imberger, J., Patterson, J.C., 1990. <em>Physical limnology</em>.
Advances in Applied Mechanics 27, 353-370.
</p>


<h3>See Also</h3>

<p><code>center.buoyancy</code>, <code>load.bathy</code>, <code>load.ts</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

  #Get the path for the package example file included
  wtr.path &lt;- system.file('extdata', 'Sparkling.daily.wtr', package="rLakeAnalyzer")
	
  #Load data for example lake, Sparkilng Lake, Wisconsin.
  sp.wtr = load.ts(wtr.path)
	 
  #calculate and plot the thermocline depth
  t.d = ts.thermo.depth(sp.wtr)
  
  center.N2 = ts.center.buoyancy(sp.wtr)
	
  plot(center.N2, type='l', ylab='Depth (m)', xlab='Date', ylim=c(19,0), lwd = 1.5)
  lines(t.d, type='l', col='red', lwd = 1.5)
  legend(x = t.d[3,1], y = .25,
     c('center of buoyancy','thermocline depth'),
     lty=c(1,1),
     lwd=c(1.5,1.5),col=c("black","red"), bty = "n")
	
</code></pre>

<hr>
<h2 id='ts.internal.energy'>Calculate physical indices for a timeseries.</h2><span id='topic+ts.internal.energy'></span>

<h3>Description</h3>

<p>Functions for simplifying the calculation of physical indices for a
timeseries of observation data.  Can usually be called directly on data
loaded directly using <code><a href="#topic+load.ts">load.ts</a></code> and <code><a href="#topic+load.bathy">load.bathy</a></code>.
</p>
<p>These are wrapper functions that accept a timeseries of data and call the
core physical metric functions (like <code><a href="#topic+schmidt.stability">schmidt.stability</a></code>) on
each timestep.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ts.internal.energy(wtr, bathy, na.rm = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ts.internal.energy_+3A_wtr">wtr</code></td>
<td>
<p>A data frame of water temperatures (in Celsius). Loaded using
<code><a href="#topic+load.ts">load.ts</a></code>. Must have columns <code>datetime</code>, <code>wtr_##.#</code>
where ##.# is depth in meters.</p>
</td></tr>
<tr><td><code id="ts.internal.energy_+3A_bathy">bathy</code></td>
<td>
<p>A data frame containing hypsometric data. Loaded using
<code><a href="#topic+load.bathy">load.bathy</a></code></p>
</td></tr>
<tr><td><code id="ts.internal.energy_+3A_na.rm">na.rm</code></td>
<td>
<p>Boolean indicated if step-by-step removal of NA's should be
tried. If false, a timestep with any NA values will return an NA value. If
true, best effort will be made to calculate indices despite NA values.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a data frame with the timeseries of calculated derivatives.
All include a &lsquo;datetime&rsquo; column, but derivative columns differ
between functions.
</p>


<h3>See Also</h3>

<p>For loading input data <code><a href="#topic+load.ts">load.ts</a></code>,
<code><a href="#topic+load.bathy">load.bathy</a></code>.
</p>
<p>For the underlying functions operating at each timestep
<code><a href="#topic+meta.depths">meta.depths</a></code>, <code><a href="#topic+thermo.depth">thermo.depth</a></code>,
<code><a href="#topic+schmidt.stability">schmidt.stability</a></code>, <code><a href="#topic+lake.number">lake.number</a></code>,
<code><a href="#topic+internal.energy">internal.energy</a></code>.
</p>
<p>Other Timeseries functions for r Lake Analyzer: <code><a href="#topic+ts.lake.number">ts.lake.number</a></code>,
<code><a href="#topic+ts.meta.depths">ts.meta.depths</a></code>,
<code><a href="#topic+ts.schmidt.stability">ts.schmidt.stability</a></code>,
<code><a href="#topic+ts.thermo.depth">ts.thermo.depth</a></code>, <code><a href="#topic+ts.uStar">ts.uStar</a></code>
</p>

<hr>
<h2 id='ts.lake.number'>Calculate physical indices for a timeseries.</h2><span id='topic+ts.lake.number'></span>

<h3>Description</h3>

<p>Functions for simplifying the calculation of physical indices for a
timeseries of observation data.  Can usually be called directly on data
loaded directly using <code><a href="#topic+load.ts">load.ts</a></code> and <code><a href="#topic+load.bathy">load.bathy</a></code>.
</p>
<p>These are wrapper functions that accept a timeseries of data and call the
core physical metric functions (like <code><a href="#topic+schmidt.stability">schmidt.stability</a></code>) on
each timestep.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ts.lake.number(wtr, wnd, wnd.height, bathy, seasonal = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ts.lake.number_+3A_wtr">wtr</code></td>
<td>
<p>A data frame of water temperatures (in Celsius). Loaded using
<code><a href="#topic+load.ts">load.ts</a></code>. Must have columns <code>datetime</code>, <code>wtr_##.#</code>
where ##.# is depth in meters.</p>
</td></tr>
<tr><td><code id="ts.lake.number_+3A_wnd">wnd</code></td>
<td>
<p>A data frame of wind speeds (in m/s). Loaded using
<code><a href="#topic+load.ts">load.ts</a></code></p>
</td></tr>
<tr><td><code id="ts.lake.number_+3A_wnd.height">wnd.height</code></td>
<td>
<p>Height of the anemometer above the lake surface in meters</p>
</td></tr>
<tr><td><code id="ts.lake.number_+3A_bathy">bathy</code></td>
<td>
<p>A data frame containing hypsometric data. Loaded using
<code><a href="#topic+load.bathy">load.bathy</a></code></p>
</td></tr>
<tr><td><code id="ts.lake.number_+3A_seasonal">seasonal</code></td>
<td>
<p>Boolean indicating if seasonal thermocline should be used in
calculation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a data frame with the timeseries of calculated derivatives.
All include a &lsquo;datetime&rsquo; column, but derivative columns differ
between functions.
</p>


<h3>See Also</h3>

<p>For loading input data <code><a href="#topic+load.ts">load.ts</a></code>,
<code><a href="#topic+load.bathy">load.bathy</a></code>.
</p>
<p>For the underlying functions operating at each timestep
<code><a href="#topic+meta.depths">meta.depths</a></code>, <code><a href="#topic+thermo.depth">thermo.depth</a></code>,
<code><a href="#topic+schmidt.stability">schmidt.stability</a></code>, <code><a href="#topic+lake.number">lake.number</a></code>,
<code><a href="#topic+internal.energy">internal.energy</a></code>.
</p>
<p>Other Timeseries functions for r Lake Analyzer: <code><a href="#topic+ts.internal.energy">ts.internal.energy</a></code>,
<code><a href="#topic+ts.meta.depths">ts.meta.depths</a></code>,
<code><a href="#topic+ts.schmidt.stability">ts.schmidt.stability</a></code>,
<code><a href="#topic+ts.thermo.depth">ts.thermo.depth</a></code>, <code><a href="#topic+ts.uStar">ts.uStar</a></code>
</p>

<hr>
<h2 id='ts.layer.temperature'>Calculate volume-weighted average water temperature across a range of depths
for a timeseries.</h2><span id='topic+ts.layer.temperature'></span>

<h3>Description</h3>

<p>Function for simplifying the calculation of Wedderburn Number. Can usually
be called directly on data loaded directly using <code><a href="#topic+load.ts">load.ts</a></code> and
<code><a href="#topic+load.bathy">load.bathy</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ts.layer.temperature(wtr, top, bottom, bathy, na.rm = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ts.layer.temperature_+3A_wtr">wtr</code></td>
<td>
<p>A data frame of water temperatures (in Celsius). Loaded using
<code><a href="#topic+load.ts">load.ts</a></code></p>
</td></tr>
<tr><td><code id="ts.layer.temperature_+3A_top">top</code></td>
<td>
<p>Either a single numeric depth value to be used across the entire
timeseries, or a vector of same length as the timeseries (e.g.,
<code>nrow(wtr)</code>). This is useful when calculating a time-varying layer
average, like average epilimnion temperature.</p>
</td></tr>
<tr><td><code id="ts.layer.temperature_+3A_bottom">bottom</code></td>
<td>
<p>Either a single numeric depth value to be used across the
entire timeseries, or a vector of same length as the timeseries (e.g.,
<code>nrow(wtr)</code>). This is useful when calculating a time-varying layer
average, like average epilimnion temperature.</p>
</td></tr>
<tr><td><code id="ts.layer.temperature_+3A_bathy">bathy</code></td>
<td>
<p>A data frame containing hypsometric data. Loaded using
<code><a href="#topic+load.bathy">load.bathy</a></code></p>
</td></tr>
<tr><td><code id="ts.layer.temperature_+3A_na.rm">na.rm</code></td>
<td>
<p>Boolean indicated if step-by-step removal of NA's should be
tried. If false, a timestep with any NA values will return an NA value. If
true, best effort will be made to calculate indices despite NA values.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a data frame with the timeseries of the average layer
temperature. Includes &lsquo;datetime&rsquo; and &lsquo;layer.temp&rsquo; columns.
</p>


<h3>See Also</h3>

<p><code>layer.temperature</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

	#Get the path for the package example file included
	wtr.path &lt;- system.file('extdata', 'Sparkling.daily.wtr', package="rLakeAnalyzer")
	bathy.path &lt;- system.file('extdata', 'Sparkling.bth', package="rLakeAnalyzer")
	
	#Load data for example lake, Sparkilng lake, in Wisconsin.
	sp.wtr = load.ts(wtr.path)
	sp.bathy = load.bathy(bathy.path)
	
	
    l.t = ts.layer.temperature(sp.wtr, 0, 18, sp.bathy)
	plot(l.t$datetime, l.t$layer.temp, type='l', 
        ylab='Volumetrically averaged lake temperature', xlab='Date')
	
</code></pre>

<hr>
<h2 id='ts.meta.depths'>Calculate physical indices for a timeseries.</h2><span id='topic+ts.meta.depths'></span>

<h3>Description</h3>

<p>Functions for simplifying the calculation of physical indices for a
timeseries of observation data.  Can usually be called directly on data
loaded directly using <code><a href="#topic+load.ts">load.ts</a></code> and <code><a href="#topic+load.bathy">load.bathy</a></code>.
</p>
<p>These are wrapper functions that accept a timeseries of data and call the
core physical metric functions (like <code><a href="#topic+schmidt.stability">schmidt.stability</a></code>) on
each timestep.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ts.meta.depths(wtr, slope = 0.1, na.rm = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ts.meta.depths_+3A_wtr">wtr</code></td>
<td>
<p>A data frame of water temperatures (in Celsius). Loaded using
<code><a href="#topic+load.ts">load.ts</a></code>. Must have columns <code>datetime</code>, <code>wtr_##.#</code>
where ##.# is depth in meters.</p>
</td></tr>
<tr><td><code id="ts.meta.depths_+3A_slope">slope</code></td>
<td>
<p>The minimum density gradient (kg/m^3/m) that can be called the
thermocline</p>
</td></tr>
<tr><td><code id="ts.meta.depths_+3A_na.rm">na.rm</code></td>
<td>
<p>Boolean indicated if step-by-step removal of NA's should be
tried. If false, a timestep with any NA values will return an NA value. If
true, best effort will be made to calculate indices despite NA values.</p>
</td></tr>
<tr><td><code id="ts.meta.depths_+3A_...">...</code></td>
<td>
<p>Additional parameters passed to underlying base function (e.g.,
index=TRUE for thermo.depth)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a data frame with the timeseries of calculated derivatives.
All include a &lsquo;datetime&rsquo; column, but derivative columns differ
between functions.
</p>


<h3>See Also</h3>

<p>For loading input data <code><a href="#topic+load.ts">load.ts</a></code>,
<code><a href="#topic+load.bathy">load.bathy</a></code>.
</p>
<p>For the underlying functions operating at each timestep
<code><a href="#topic+meta.depths">meta.depths</a></code>, <code><a href="#topic+thermo.depth">thermo.depth</a></code>,
<code><a href="#topic+schmidt.stability">schmidt.stability</a></code>, <code><a href="#topic+lake.number">lake.number</a></code>,
<code><a href="#topic+internal.energy">internal.energy</a></code>.
</p>
<p>Other Timeseries functions for r Lake Analyzer: <code><a href="#topic+ts.internal.energy">ts.internal.energy</a></code>,
<code><a href="#topic+ts.lake.number">ts.lake.number</a></code>,
<code><a href="#topic+ts.schmidt.stability">ts.schmidt.stability</a></code>,
<code><a href="#topic+ts.thermo.depth">ts.thermo.depth</a></code>, <code><a href="#topic+ts.uStar">ts.uStar</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
	#Get the path for the package example file included
	exampleFilePath &lt;- system.file('extdata', 'Sparkling.daily.wtr', package="rLakeAnalyzer")
	
	#Load
	sparkling.temp = load.ts(exampleFilePath)
	
	#calculate and plot the metalimnion depths
	m.d = ts.meta.depths(sparkling.temp)
	
	plot(m.d$datetime, m.d$top, type='l', ylab='Meta Depths (m)', xlab='Date', col='blue')
	lines(m.d$datetime, m.d$bottom, col='red')
  
  
</code></pre>

<hr>
<h2 id='ts.schmidt.stability'>Calculate physical indices for a timeseries.</h2><span id='topic+ts.schmidt.stability'></span>

<h3>Description</h3>

<p>Functions for simplifying the calculation of physical indices for a
timeseries of observation data.  Can usually be called directly on data
loaded directly using <code><a href="#topic+load.ts">load.ts</a></code> and <code><a href="#topic+load.bathy">load.bathy</a></code>.
</p>
<p>These are wrapper functions that accept a timeseries of data and call the
core physical metric functions (like <code><a href="#topic+schmidt.stability">schmidt.stability</a></code>) on
each timestep.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ts.schmidt.stability(wtr, bathy, na.rm = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ts.schmidt.stability_+3A_wtr">wtr</code></td>
<td>
<p>A data frame of water temperatures (in Celsius). Loaded using
<code><a href="#topic+load.ts">load.ts</a></code>. Must have columns <code>datetime</code>, <code>wtr_##.#</code>
where ##.# is depth in meters.</p>
</td></tr>
<tr><td><code id="ts.schmidt.stability_+3A_bathy">bathy</code></td>
<td>
<p>A data frame containing hypsometric data. Loaded using
<code><a href="#topic+load.bathy">load.bathy</a></code></p>
</td></tr>
<tr><td><code id="ts.schmidt.stability_+3A_na.rm">na.rm</code></td>
<td>
<p>Boolean indicated if step-by-step removal of NA's should be
tried. If false, a timestep with any NA values will return an NA value. If
true, best effort will be made to calculate indices despite NA values.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a data frame with the timeseries of calculated derivatives.
All include a &lsquo;datetime&rsquo; column, but derivative columns differ
between functions.
</p>


<h3>See Also</h3>

<p>For loading input data <code><a href="#topic+load.ts">load.ts</a></code>,
<code><a href="#topic+load.bathy">load.bathy</a></code>.
</p>
<p>For the underlying functions operating at each timestep
<code><a href="#topic+meta.depths">meta.depths</a></code>, <code><a href="#topic+thermo.depth">thermo.depth</a></code>,
<code><a href="#topic+schmidt.stability">schmidt.stability</a></code>, <code><a href="#topic+lake.number">lake.number</a></code>,
<code><a href="#topic+internal.energy">internal.energy</a></code>.
</p>
<p>Other Timeseries functions for r Lake Analyzer: <code><a href="#topic+ts.internal.energy">ts.internal.energy</a></code>,
<code><a href="#topic+ts.lake.number">ts.lake.number</a></code>,
<code><a href="#topic+ts.meta.depths">ts.meta.depths</a></code>,
<code><a href="#topic+ts.thermo.depth">ts.thermo.depth</a></code>, <code><a href="#topic+ts.uStar">ts.uStar</a></code>
</p>

<hr>
<h2 id='ts.thermo.depth'>Calculate physical indices for a timeseries.</h2><span id='topic+ts.thermo.depth'></span>

<h3>Description</h3>

<p>Functions for simplifying the calculation of physical indices for a
timeseries of observation data.  Can usually be called directly on data
loaded directly using <code><a href="#topic+load.ts">load.ts</a></code> and <code><a href="#topic+load.bathy">load.bathy</a></code>.
</p>
<p>These are wrapper functions that accept a timeseries of data and call the
core physical metric functions (like <code><a href="#topic+schmidt.stability">schmidt.stability</a></code>) on
each timestep.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ts.thermo.depth(wtr, Smin = 0.1, na.rm = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ts.thermo.depth_+3A_wtr">wtr</code></td>
<td>
<p>A data frame of water temperatures (in Celsius). Loaded using
<code><a href="#topic+load.ts">load.ts</a></code>. Must have columns <code>datetime</code>, <code>wtr_##.#</code>
where ##.# is depth in meters.</p>
</td></tr>
<tr><td><code id="ts.thermo.depth_+3A_smin">Smin</code></td>
<td>
<p>The minimum density gradient cutoff (kg/m^3/m) defining the
metalimion</p>
</td></tr>
<tr><td><code id="ts.thermo.depth_+3A_na.rm">na.rm</code></td>
<td>
<p>Boolean indicated if step-by-step removal of NA's should be
tried. If false, a timestep with any NA values will return an NA value. If
true, best effort will be made to calculate indices despite NA values.</p>
</td></tr>
<tr><td><code id="ts.thermo.depth_+3A_...">...</code></td>
<td>
<p>Additional parameters passed to underlying base function (e.g.,
index=TRUE for thermo.depth)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a data frame with the timeseries of calculated derivatives.
All include a &lsquo;datetime&rsquo; column, but derivative columns differ
between functions.
</p>


<h3>See Also</h3>

<p>For loading input data <code><a href="#topic+load.ts">load.ts</a></code>,
<code><a href="#topic+load.bathy">load.bathy</a></code>.
</p>
<p>For the underlying functions operating at each timestep
<code><a href="#topic+meta.depths">meta.depths</a></code>, <code><a href="#topic+thermo.depth">thermo.depth</a></code>,
<code><a href="#topic+schmidt.stability">schmidt.stability</a></code>, <code><a href="#topic+lake.number">lake.number</a></code>,
<code><a href="#topic+internal.energy">internal.energy</a></code>.
</p>
<p>Other Timeseries functions for r Lake Analyzer: <code><a href="#topic+ts.internal.energy">ts.internal.energy</a></code>,
<code><a href="#topic+ts.lake.number">ts.lake.number</a></code>,
<code><a href="#topic+ts.meta.depths">ts.meta.depths</a></code>,
<code><a href="#topic+ts.schmidt.stability">ts.schmidt.stability</a></code>,
<code><a href="#topic+ts.uStar">ts.uStar</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
	#Get the path for the package example file included
	exampleFilePath &lt;- system.file('extdata', 'Sparkling.daily.wtr', package="rLakeAnalyzer")
	
	#Load
	sparkling.temp = load.ts(exampleFilePath)
  
  
  #calculate and plot the thermocline depth
	t.d = ts.thermo.depth(sparkling.temp)
	
	plot(t.d$datetime, t.d$thermo.depth, type='l', ylab='Thermocline Depth (m)', xlab='Date')
  
</code></pre>

<hr>
<h2 id='ts.uStar'>Calculate physical indices for a timeseries.</h2><span id='topic+ts.uStar'></span>

<h3>Description</h3>

<p>Functions for simplifying the calculation of physical indices for a
timeseries of observation data.  Can usually be called directly on data
loaded directly using <code><a href="#topic+load.ts">load.ts</a></code> and <code><a href="#topic+load.bathy">load.bathy</a></code>.
</p>
<p>These are wrapper functions that accept a timeseries of data and call the
core physical metric functions (like <code><a href="#topic+schmidt.stability">schmidt.stability</a></code>) on
each timestep.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ts.uStar(wtr, wnd, wnd.height, bathy, seasonal = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ts.uStar_+3A_wtr">wtr</code></td>
<td>
<p>A data frame of water temperatures (in Celsius). Loaded using
<code><a href="#topic+load.ts">load.ts</a></code>. Must have columns <code>datetime</code>, <code>wtr_##.#</code>
where ##.# is depth in meters.</p>
</td></tr>
<tr><td><code id="ts.uStar_+3A_wnd">wnd</code></td>
<td>
<p>A data frame of wind speeds (in m/s). Loaded using
<code><a href="#topic+load.ts">load.ts</a></code></p>
</td></tr>
<tr><td><code id="ts.uStar_+3A_wnd.height">wnd.height</code></td>
<td>
<p>Height of the anemometer above the lake surface in meters</p>
</td></tr>
<tr><td><code id="ts.uStar_+3A_bathy">bathy</code></td>
<td>
<p>A data frame containing hypsometric data. Loaded using
<code><a href="#topic+load.bathy">load.bathy</a></code></p>
</td></tr>
<tr><td><code id="ts.uStar_+3A_seasonal">seasonal</code></td>
<td>
<p>Boolean indicating if seasonal thermocline should be used in
calculation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a data frame with the timeseries of calculated derivatives.
All include a &lsquo;datetime&rsquo; column, but derivative columns differ
between functions.
</p>


<h3>See Also</h3>

<p>For loading input data <code><a href="#topic+load.ts">load.ts</a></code>,
<code><a href="#topic+load.bathy">load.bathy</a></code>.
</p>
<p>For the underlying functions operating at each timestep
<code><a href="#topic+meta.depths">meta.depths</a></code>, <code><a href="#topic+thermo.depth">thermo.depth</a></code>,
<code><a href="#topic+schmidt.stability">schmidt.stability</a></code>, <code><a href="#topic+lake.number">lake.number</a></code>,
<code><a href="#topic+internal.energy">internal.energy</a></code>.
</p>
<p>Other Timeseries functions for r Lake Analyzer: <code><a href="#topic+ts.internal.energy">ts.internal.energy</a></code>,
<code><a href="#topic+ts.lake.number">ts.lake.number</a></code>,
<code><a href="#topic+ts.meta.depths">ts.meta.depths</a></code>,
<code><a href="#topic+ts.schmidt.stability">ts.schmidt.stability</a></code>,
<code><a href="#topic+ts.thermo.depth">ts.thermo.depth</a></code>
</p>

<hr>
<h2 id='ts.wedderburn.number'>Calculate Wedderburn number for a timeseries.</h2><span id='topic+ts.wedderburn.number'></span>

<h3>Description</h3>

<p>Function for simplifying the calculation of Wedderburn Number. Can usually
be called directly on data loaded directly using <code><a href="#topic+load.ts">load.ts</a></code> and
<code><a href="#topic+load.bathy">load.bathy</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ts.wedderburn.number(wtr, wnd, wnd.height, bathy, Ao, seasonal = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ts.wedderburn.number_+3A_wtr">wtr</code></td>
<td>
<p>A data frame of water temperatures (in Celsius). Loaded using
<code><a href="#topic+load.ts">load.ts</a></code></p>
</td></tr>
<tr><td><code id="ts.wedderburn.number_+3A_wnd">wnd</code></td>
<td>
<p>A data frame of wind speeds (in m/s). Loaded using
<code><a href="#topic+load.ts">load.ts</a></code></p>
</td></tr>
<tr><td><code id="ts.wedderburn.number_+3A_wnd.height">wnd.height</code></td>
<td>
<p>Height of the anemometer above the lake surface in meters</p>
</td></tr>
<tr><td><code id="ts.wedderburn.number_+3A_bathy">bathy</code></td>
<td>
<p>A data frame containing hypsometric data. Loaded using
<code><a href="#topic+load.bathy">load.bathy</a></code></p>
</td></tr>
<tr><td><code id="ts.wedderburn.number_+3A_ao">Ao</code></td>
<td>
<p>Numeric value for the water body surface area (m^2) at zero meters
depth</p>
</td></tr>
<tr><td><code id="ts.wedderburn.number_+3A_seasonal">seasonal</code></td>
<td>
<p>Boolean indicating if seasonal thermocline should be used in
calculation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a data frame with the timeseries of Wedderburn number.
Includes a &lsquo;datetime&rsquo; column.
</p>


<h3>References</h3>

<p>Imberger, J., Patterson, J.C., 1990. <em>Physical limnology</em>.
Advances in Applied Mechanics 27, 353-370.
</p>


<h3>See Also</h3>

<p><code>wedderburn.number</code>,<code>ts.lake.number</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

	#Get the path for the package example file included
	wtr.path &lt;- system.file('extdata', 'Sparkling.daily.wtr', package="rLakeAnalyzer")
	wnd.path &lt;- system.file('extdata', 'Sparkling.daily.wnd', package="rLakeAnalyzer")
	bathy.path &lt;- system.file('extdata', 'Sparkling.bth', package="rLakeAnalyzer")
	
	#Load data for example lake, Sparkilng lake, in Wisconsin.
	sp.wtr = load.ts(wtr.path)
	sp.wnd = load.ts(wnd.path)
	sp.bathy = load.bathy(bathy.path)
	
	sp.area = 64e4  #Area of Sparkling lake in m^2
	wnd.height = 2  #Height of Sparkling lake anemometer
	
	w.n = ts.wedderburn.number(sp.wtr, sp.wnd, wnd.height, sp.bathy, sp.area)
	plot(w.n$datetime, w.n$wedderburn.number, type='l', ylab='Wedderburn Number', xlab='Date')
	
</code></pre>

<hr>
<h2 id='uStar'>Calculates the water friction velocity, uStar</h2><span id='topic+uStar'></span>

<h3>Description</h3>

<p>uStar is the water friction velocity due to wind stress at the lake surface,
it is calculated following the methods of Imberger (1985) as a function of
the shear stress of air (Fischer et al., 1979), drag coefficient for
momentum (Hicks, 1972), and a dimensionless constant (von Karman constant)
that decribes the logarithmic velocity profile at the air-water interface
</p>


<h3>Usage</h3>

<pre><code class='language-R'>uStar(wndSpeed, wndHeight, averageEpiDense)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="uStar_+3A_wndspeed">wndSpeed</code></td>
<td>
<p>a numeric vector of wind speed in m s-1</p>
</td></tr>
<tr><td><code id="uStar_+3A_wndheight">wndHeight</code></td>
<td>
<p>a numeric vector of wind measurement height in m</p>
</td></tr>
<tr><td><code id="uStar_+3A_averageepidense">averageEpiDense</code></td>
<td>
<p>a numeric vector of epilimnion density in kg m-3</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a numeric vector of uStar
</p>


<h3>References</h3>

<p>Hicks, B.B., 1972. <em>A procedure for the formulation of bulk transfer
coefficients over water bodies of different sizes</em>. Boundary-Layer
Meterology 3: 201-213.
</p>
<p>Amorocho, J., DeVries, J.J., 1980. <em>A new evaluation of the wind stress
coefficient over water surfaces</em>. Journal of Geophysical Research 85:
433-442.
</p>
<p>Fischer, H.B., List, E.J., Koh, R.C.Y., Imberger, J., Brooks, N.H., 1979.
<em>Mixing in inland and coastal waters</em>. Academic Press.
</p>
<p>Imberger, J., 1985. <em>The diurnal mixed layer</em>. Limnology and
Oceanography 30: 737-770.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ts.uStar">ts.uStar</a></code> <code><a href="#topic+layer.density">layer.density</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

  wndSpeed  &lt;- c(5.1,6.3,6.3,5.2,7,7.2)
  wndHeight	&lt;-	2
  averageEpiDense	&lt;- c(14,15,14.2,13,12,12)

  cat('uStar for input vector is: ')
  cat(uStar(wndSpeed,wndHeight,averageEpiDense))
</code></pre>

<hr>
<h2 id='water.density'>Estimate Water Density</h2><span id='topic+water.density'></span>

<h3>Description</h3>

<p>Density of water from temperature and salinity
</p>


<h3>Usage</h3>

<pre><code class='language-R'>water.density(wtr, sal = wtr * 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="water.density_+3A_wtr">wtr</code></td>
<td>
<p>a numeric vector of water temperature in degrees Celsius</p>
</td></tr>
<tr><td><code id="water.density_+3A_sal">sal</code></td>
<td>
<p>a numeric vector of salinity in Practical Salinity Scale units</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector of water densities in kg/m^3.
</p>


<h3>References</h3>

<p>Martin, J.L., McCutcheon, S.C., 1999. <em>Hydrodynamics and
Transport for Water Quality Modeling.</em> Lewis Publications, Boca Raton, FL,
794pp.
</p>
<p>Millero, F.J., Poisson, A., 1981. <em>International one-atmosphere
equation of state of seawater.</em> UNESCO Technical Papers in Marine Science.
No. 36.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#Plot water density for water between 1 and 30 deg C
dens = water.density(1:30)
plot(1:30, dens, xlab="Temp(deg C)", ylab="Density(kg/m^3)")
</code></pre>

<hr>
<h2 id='wedderburn.number'>Calculates Wedderburn Number for a lake.</h2><span id='topic+wedderburn.number'></span>

<h3>Description</h3>

<p>Wedderburn Number (Wn) is a dimensionless parameter measuring the balance
between wind stress and bouyancy force and is used to estimate the amount of
upwelling occuring in a lake.  When Wn is much greater than 1, the bouyancy
force is much greater than the wind stress and therefore there is a strong
vertical stratification with little horizontal variation in the
stratification. When Wn is much less than 1, the wind stress is much greater
than the bouyancy force and upwelling is likely occuring at the upwind end
of the lake. When Wn is near 1, the bouyance force and wind stress are
nearly equal and horizontal mixing is considered important
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wedderburn.number(delta_rho, metaT, uSt, Ao, AvHyp_rho)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wedderburn.number_+3A_delta_rho">delta_rho</code></td>
<td>
<p>Numeric value for the water density difference between the
epilimnion and hypolimnion (kg/m^3)</p>
</td></tr>
<tr><td><code id="wedderburn.number_+3A_metat">metaT</code></td>
<td>
<p>Numeric value for the thickness of the water body's surface
layer (m)</p>
</td></tr>
<tr><td><code id="wedderburn.number_+3A_ust">uSt</code></td>
<td>
<p>Numeric value for the water friction velocity due to wind stress
(m/s)</p>
</td></tr>
<tr><td><code id="wedderburn.number_+3A_ao">Ao</code></td>
<td>
<p>Numeric value for the water body surface area (m^2) at zero meters
depth</p>
</td></tr>
<tr><td><code id="wedderburn.number_+3A_avhyp_rho">AvHyp_rho</code></td>
<td>
<p>Numeric value for the average water density of the
hypolimnion layer (kg/m^3)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The dimensionless numeric value of Wedderburn Number
</p>


<h3>References</h3>

<p>Imberger, J., Patterson, J.C., 1990. <em>Physical limnology</em>.
Advances in Applied Mechanics 27, 353-370.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ts.wedderburn.number">ts.wedderburn.number</a></code> <code><a href="#topic+lake.number">lake.number</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
delta_rho &lt;- c(3.1,1.5)
metaT &lt;- c(5.5,2.4)
uSt &lt;- c(0.0028,0.0032)
Ao &lt;- c(80300,120000)
AvHyp_rho &lt;- c(999.31,999.1)
wedderburn.number(delta_rho, metaT, uSt, Ao, AvHyp_rho)

</code></pre>

<hr>
<h2 id='whole.lake.temperature'>Get volumetrically averaged whole lake temperature</h2><span id='topic+whole.lake.temperature'></span>

<h3>Description</h3>

<p>Calculates volumetrically weighted average whole lake temperature using the
supplied water temperature timeseries.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>whole.lake.temperature(wtr, depths, bthA, bthD)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="whole.lake.temperature_+3A_wtr">wtr</code></td>
<td>
<p>a numeric vector of water temperature in degrees C.</p>
</td></tr>
<tr><td><code id="whole.lake.temperature_+3A_depths">depths</code></td>
<td>
<p>a numeric vector corresponding to the depths (in m) of the wtr
measurements</p>
</td></tr>
<tr><td><code id="whole.lake.temperature_+3A_btha">bthA</code></td>
<td>
<p>a numeric vector of cross sectional areas (m^2) corresponding to
bthD depths</p>
</td></tr>
<tr><td><code id="whole.lake.temperature_+3A_bthd">bthD</code></td>
<td>
<p>a numeric vector of depths (m) which correspond to areal
measures in bthA</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+hypo.temperature">hypo.temperature</a></code>, <code><a href="#topic+epi.temperature">epi.temperature</a></code>
</p>

<hr>
<h2 id='wtr.heat.map'>Plots a heat-map of water temperature.</h2><span id='topic+wtr.heat.map'></span>

<h3>Description</h3>

<p>This creates a simple, default heatmap of water temperature.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wtr.heat.map(wtr, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wtr.heat.map_+3A_wtr">wtr</code></td>
<td>
<p>Data frame of water temperature loaded with
<code><a href="#topic+load.ts">load.ts</a></code>.</p>
</td></tr>
<tr><td><code id="wtr.heat.map_+3A_...">...</code></td>
<td>
<p>Additional parameters supplied to <code><a href="graphics.html#topic+filled.contour">filled.contour</a></code>
to modify defaults. Common examples include <code>zlim</code> and
<code>plot.title</code>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+load.ts">load.ts</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
	#Get the path for the package example file included
	wtr.path &lt;- system.file('extdata', 'Sparkling.daily.wtr', package="rLakeAnalyzer")
	
	#Load data for example lake, Sparkilng Lake, Wisconsin.
	sp.wtr = load.ts(wtr.path)
	
	#Plot default figure
	wtr.heat.map(sp.wtr)

	#Change defaults supplied to filled.contour
	wtr.heat.map(sp.wtr, zlim=c(0,15), plot.title="Sparkling Water Temp (C)")
</code></pre>

<hr>
<h2 id='wtr.heatmap.layers'>Plots water temperature heatmap with major limnetic layers indicated</h2><span id='topic+wtr.heatmap.layers'></span>

<h3>Description</h3>

<p>This creates a heat map of water temperature similar to
<code><a href="#topic+wtr.heat.map">wtr.heat.map</a></code> with additional lines drawn to denote the
thermocline, and the top and bottom of the metalimnion as calculated using
<code><a href="#topic+ts.meta.depths">ts.meta.depths</a></code> and <code><a href="#topic+thermo.depth">thermo.depth</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wtr.heatmap.layers(wtr, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wtr.heatmap.layers_+3A_wtr">wtr</code></td>
<td>
<p>Data frame of water temperature loaded with
<code><a href="#topic+load.ts">load.ts</a></code>.</p>
</td></tr>
<tr><td><code id="wtr.heatmap.layers_+3A_...">...</code></td>
<td>
<p>Additional parameters supplied to <code><a href="graphics.html#topic+filled.contour">filled.contour</a></code>
to modify defaults.  Common examples include <code>zlim</code> and
<code>plot.title</code>.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>This plot cannot be used in customized multi-panel figures
using<code><a href="graphics.html#topic+layout">layout</a></code> as layout is already used in the filled.contour
plotting function.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+wtr.heat.map">wtr.heat.map</a></code> <code><a href="#topic+load.ts">load.ts</a></code>
<code><a href="#topic+ts.meta.depths">ts.meta.depths</a></code> <code><a href="#topic+ts.thermo.depth">ts.thermo.depth</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  #Get the path for the package example file included 
  wtr.path &lt;- system.file('extdata', 'Sparkling.wtr', package="rLakeAnalyzer")

  #Load data for example lake, Sparkilng Lake, Wisconsin.
  wtr = load.ts(wtr.path)
  
  # generate default plot
  ## Not run: 
  wtr.heatmap.layers(wtr)
  
## End(Not run)
</code></pre>

<hr>
<h2 id='wtr.layer'>Exploration of lake water column layers</h2><span id='topic+wtr.layer'></span>

<h3>Description</h3>

<p>Extract water column parameters of a given parameter from a profile using
the split-and-merge algorithm.  The cline is defined as the midpoint of the
layer of water where the physical property change in the greatest over a
small difference. The exact cline depends on the specification of measure.
For example if temperature is specified, then we can expect cline to output
the thermocline.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wtr.layer(data, depth, measure, thres = 0.1, z0 = 2.5, zmax = 150,
  nseg = "unconstrained")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wtr.layer_+3A_data">data</code></td>
<td>
<p>data supplied as a bare (unquoted) value</p>
</td></tr>
<tr><td><code id="wtr.layer_+3A_depth">depth</code></td>
<td>
<p>depth in metres; should be an increasing vector; supplied as a
bare (unquoted) value</p>
</td></tr>
<tr><td><code id="wtr.layer_+3A_measure">measure</code></td>
<td>
<p>parameter measured in the water column profile; supplied as a
bare (unquoted) value</p>
</td></tr>
<tr><td><code id="wtr.layer_+3A_thres">thres</code></td>
<td>
<p>error norm; defaults to 0.1</p>
</td></tr>
<tr><td><code id="wtr.layer_+3A_z0">z0</code></td>
<td>
<p>initial depth in metres. Defaults to 2.5m</p>
</td></tr>
<tr><td><code id="wtr.layer_+3A_zmax">zmax</code></td>
<td>
<p>maximum depth in metres: defaults to 150m</p>
</td></tr>
<tr><td><code id="wtr.layer_+3A_nseg">nseg</code></td>
<td>
<p>optional parameter to define the number of segments a priori;
defaults to an unconstrained approach whereby the algorithm determines
segmentations by minimzing the error norm over each segment</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a dataframes with a list column. This includes: nseg (number of
segments), mld (mix layer depth), cline (the midpoint of the segment
connecting inflection points that has the maximum slope; thermocline for
temperature measures) and segments calculated by the sm algorithm.
</p>


<h3>References</h3>

<p>Thomson, R. and I. Fine. 2003. Estimating Mixed Layer Depth from
Oceanic Profile Data. Journal of Atmospheric and Oceanic Technology. 20(2),
319-329.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data("latesummer")
df1 &lt;- wtr.layer(depth=latesummer$depth, measure = latesummer$temper)
df1$mld
df1$segments

wtr.layer(data = latesummer, depth=depth, measure = temper, nseg=4)


</code></pre>

<hr>
<h2 id='wtr.lineseries'>Creates a line based plot of temperature profile time series</h2><span id='topic+wtr.lineseries'></span>

<h3>Description</h3>

<p>A non-heat map approach to visualizing a water temperature profile useful
for identify temperature trends over time at discrete depths and diagnosing
issues with data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wtr.lineseries(wtr, ylab = "Temperature C", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wtr.lineseries_+3A_wtr">wtr</code></td>
<td>
<p>Data frame of water temperature loaded with
<code><a href="#topic+load.ts">load.ts</a></code>.</p>
</td></tr>
<tr><td><code id="wtr.lineseries_+3A_ylab">ylab</code></td>
<td>
<p>y axis title</p>
</td></tr>
<tr><td><code id="wtr.lineseries_+3A_...">...</code></td>
<td>
<p>Additional parameters supplied to the plot function</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>See <code><a href="#topic+load.ts">load.ts</a></code> and <code><a href="#topic+wtr.heat.map">wtr.heat.map</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
exampleFilePath &lt;- system.file('extdata', 'Sparkling.wtr', package="rLakeAnalyzer")
wtr= load.ts(exampleFilePath)
## Not run: 
wtr.lineseries(wtr, ylab = "Temperature C")

## End(Not run)
</code></pre>

<hr>
<h2 id='wtr.plot.temp'>Creates a time series plot of the thermocline and top and bottom of the
metalimnion</h2><span id='topic+wtr.plot.temp'></span>

<h3>Description</h3>

<p>A line based plot of calculated depths of the thermocline, and top and
bottom of the metalimnion from a temperature profile time series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wtr.plot.temp(wtr, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wtr.plot.temp_+3A_wtr">wtr</code></td>
<td>
<p>Data frame of water temperature loaded with
<code><a href="#topic+load.ts">load.ts</a></code>.</p>
</td></tr>
<tr><td><code id="wtr.plot.temp_+3A_...">...</code></td>
<td>
<p>Additional paramters supplied to <code><a href="#topic+ts.meta.depths">ts.meta.depths</a></code> and
<code><a href="#topic+ts.thermo.depth">ts.thermo.depth</a></code></p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+load.ts">load.ts</a></code> and <code><a href="#topic+wtr.lineseries">wtr.lineseries</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

wtr.path &lt;- system.file('extdata', 'Sparkling.wtr', package="rLakeAnalyzer")

#Load data for example lake, Sparkilng Lake, Wisconsin.
wtr = load.ts(wtr.path)

## Not run: 
wtr.plot.temp(wtr)

## End(Not run)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
