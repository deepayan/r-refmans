<!DOCTYPE html><html lang="en"><head><title>Help for package bmscstan</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {bmscstan}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#BMSC'><p>Fit Bayesian Multilevel Single Case models</p></a></li>
<li><a href='#BMSC_loo'><p>loo and waic.</p></a></li>
<li><a href='#BMSC_loo_compare'><p>bmscstan wrapper for model comparison.</p></a></li>
<li><a href='#BMSC_pareto_k_table'><p>bmscstan wrapper for diagnostics for Pareto smoothed importance</p>
sampling (PSIS)</a></li>
<li><a href='#bmscstan'><p>Bayesian Multilevel Single Case models using 'Stan'</p></a></li>
<li><a href='#data.ctrl'><p>Data from a control group of 16 participants</p></a></li>
<li><a href='#data.pt'><p>Data from a Single Case with brachial plexious lesion</p></a></li>
<li><a href='#pairwise.BMSC'><p>Pairwise contrasts</p></a></li>
<li><a href='#plot.BMSC'><p>Plot estimates from a <code>BMSC</code> object.</p></a></li>
<li><a href='#plot.pairwise.BMSC'><p>Plot estimates from a <code>pairwise.BMSC</code> object.</p></a></li>
<li><a href='#pp_check.BMSC'><p>Posterior predictive check for BMSC objects</p></a></li>
<li><a href='#print.pairwise.BMSC'><p>Print summaries of Pairwise Bayesian Multilevel Single Case objects</p></a></li>
<li><a href='#print.summary.BMSC'><p>Print summaries of Bayesian Multilevel Single Case objects</p></a></li>
<li><a href='#randomeffects'><p>Random Effects specification on</p>
Bayesian Multilevel Single Case models using 'Stan'</a></li>
<li><a href='#summary.BMSC'><p>Summarizing Bayesian Multilevel Single Case objects</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Bayesian Multilevel Single Case Models using 'Stan'</td>
</tr>
<tr>
<td>Version:</td>
<td>1.2.1.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Analyse single case analyses against a control group.
    Its purpose is to provide a flexible, with good power and
    low first type error
    approach that can manage at the same time controls' and patient's data.
    The use of Bayesian statistics allows to test both the alternative and
    null hypothesis.
    Scandola, M., &amp; Romano, D. (2020, August 3). &lt;<a href="https://doi.org/10.31234%2Fosf.io%2Fsajdq">doi:10.31234/osf.io/sajdq</a>&gt;
    Scandola, M., &amp; Romano, D. (2021). &lt;<a href="https://doi.org/10.1016%2Fj.neuropsychologia.2021.107834">doi:10.1016/j.neuropsychologia.2021.107834</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0), rstan, ggplot2, bayesplot</td>
</tr>
<tr>
<td>Imports:</td>
<td>loo, logspline, LaplacesDemon</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Suggests:</td>
<td>reshape2, gridExtra, bridgesampling, testthat, knitr,
rmarkdown, covr</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/michelescandola/bmscstan">https://github.com/michelescandola/bmscstan</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/michelescandola/bmscstan">https://github.com/michelescandola/bmscstan</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-09-04 17:40:44 UTC; miche</td>
</tr>
<tr>
<td>Author:</td>
<td>Michele Scandola <a href="https://orcid.org/0000-0003-0853-8975"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Michele Scandola &lt;michele.scandola@univr.it&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-09-04 18:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='BMSC'>Fit Bayesian Multilevel Single Case models</h2><span id='topic+BMSC'></span>

<h3>Description</h3>

<p><code>BMSC</code> fits the Bayesian Multilevel Single Case models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BMSC(
  formula,
  data_ctrl,
  data_sc,
  cores = 1,
  chains = 4,
  iter = 4000,
  warmup,
  seed = NA,
  typeprior = "normal",
  s,
  family = "gaussian",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="BMSC_+3A_formula">formula</code></td>
<td>
<p>An object of class <code>formula</code>: a symbolic description of the model to be fitted.</p>
</td></tr>
<tr><td><code id="BMSC_+3A_data_ctrl">data_ctrl</code></td>
<td>
<p>An object of class <code>data.frame</code> (or one that can be coerced to that class)
containing data of all variables used in the model for the control group.</p>
</td></tr>
<tr><td><code id="BMSC_+3A_data_sc">data_sc</code></td>
<td>
<p>An object of class <code>data.frame</code> (or one that can be coerced to that class)
containing data of all variables used in the model for the Single Case</p>
</td></tr>
<tr><td><code id="BMSC_+3A_cores">cores</code></td>
<td>
<p>The number of cores to use when executing the Markov chains in parallel. The default is 1.</p>
</td></tr>
<tr><td><code id="BMSC_+3A_chains">chains</code></td>
<td>
<p>Number of Markov chains (defaults to 4).</p>
</td></tr>
<tr><td><code id="BMSC_+3A_iter">iter</code></td>
<td>
<p>Number of total iterations per chain (including warmup; defaults to 4000).</p>
</td></tr>
<tr><td><code id="BMSC_+3A_warmup">warmup</code></td>
<td>
<p>A positive integer specifying number of warmup (aka burnin) iterations.
This also specifies the number of iterations used for stepsize adaptation,
so warmup samples should not be used for inference. The number of warmup should
not be larger than iter and the default is 2000.</p>
</td></tr>
<tr><td><code id="BMSC_+3A_seed">seed</code></td>
<td>
<p>The seed for random number generation to make results reproducible.
If NA (the default), Stan will set the seed randomly.</p>
</td></tr>
<tr><td><code id="BMSC_+3A_typeprior">typeprior</code></td>
<td>
<p>Set the desired prior distribution for the fixed effects.
</p>

<dl>
<dt>normal</dt><dd><p>a normal distribution with <code class="reqn">\mu = 0</code> and <code class="reqn">\sigma = 10</code></p>
</dd>
<dt>cauchy</dt><dd><p>a cauchy distribution with <code class="reqn">\mu = 0</code> and scale
<code class="reqn">\sqrt{2}/2</code></p>
</dd>
<dt>student</dt><dd><p>a Student's T distribution, with <code class="reqn">\mu = 0</code>, <code class="reqn">\nu = 3</code>
and <code class="reqn">\sigma = 10</code></p>
</dd>
</dl>

<p>The normal distribution is the default.
</p>
<p>The <code class="reqn">\sigma</code> or scale parameters of the prior distributions can be
modified by setting the dispersion parameter <code>s</code>.</p>
</td></tr>
<tr><td><code id="BMSC_+3A_s">s</code></td>
<td>
<p>is the dispersion parameter (standard deviation or scale) for the
prior distribution.
</p>
<p>If NULL (the default) and <code>typeprior = "normal"</code> or
<code>typeprior = "student"</code> <code>s = 10</code>, otherwise, if
<code>typeprior = "cauchy"</code> <code>s = sqrt(2)/2</code>.</p>
</td></tr>
<tr><td><code id="BMSC_+3A_family">family</code></td>
<td>
<p>a description of the response distribution to be used in
this model.
This is a character string naming the family.
By default, a linear gaussian model is applied.
</p>

<dl>
<dt>gaussian</dt><dd><p>the dependent variable is distributed along a Gaussian distribution,
with <code>identity</code> link function</p>
</dd>
<dt>binomial</dt><dd><p>the dependent variable is distributed along a Binomial distribution,
with <code>logit</code> link function</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="BMSC_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to <strong>stan</strong> function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>BMSC</code> object
</p>


<h3>Examples</h3>

<pre><code class='language-R'> 

# simulation of healthy controls data

Sigma.ctrl &lt;- matrix(cbind(1, .7,  .7, 1) ,nrow=2)

U &lt;- t(chol(Sigma.ctrl))

numobs &lt;- 100

set.seed(123)

random.normal &lt;- matrix( rnorm( n = ncol(U) * numobs, mean = 3, sd = 1),
                         nrow = ncol(U), ncol = numobs)

X = U %*% random.normal

dat.ctrl &lt;- as.data.frame(t(X))

names(dat.ctrl) &lt;- c("y","x")

cor(dat.ctrl)

# simulation of patient data

Sigma.pt &lt;- matrix(cbind(1, 0,  0, 1) ,nrow=2)

U &lt;- t(chol(Sigma.pt))

numobs &lt;- 20

set.seed(0)

random.normal &lt;- matrix( rnorm( n = ncol(U) * numobs, mean = 3, sd = 1),
                 nrow = ncol(U), ncol = numobs)

X = U %*% random.normal

dat.pt &lt;- as.data.frame(t(X))

names(dat.pt) &lt;- c("y","x")

cor(dat.pt)

# fit the single case model

mdl.reg &lt;- BMSC(y ~ x, data_ctrl = dat.ctrl, data_sc = dat.pt, seed = 10)

# posterior-predictive check of the model

pp_check(mdl.reg)

# summarize the results

summary(mdl.reg)

# plot the results

plot(mdl.reg)


</code></pre>

<hr>
<h2 id='BMSC_loo'>loo and waic.</h2><span id='topic+BMSC_loo'></span><span id='topic+BMSC_waic'></span><span id='topic+plot.loo_BMSC'></span><span id='topic+print.waic_BMSC'></span><span id='topic+print.loo_BMSC'></span>

<h3>Description</h3>

<p>bmscstan wrapper for computing approximate leave-one-out cross-validation
(loo) and Watanabe-Akaike Information Criterion or
Widely Applicable Information Criterion (WAIC)
using PSIS-LOO
for the single case and the control group
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BMSC_loo(x, cores = 1, ...)

BMSC_waic(x, ...)

## S3 method for class 'loo_BMSC'
plot(x, ...)

## S3 method for class 'waic_BMSC'
print(x, ...)

## S3 method for class 'loo_BMSC'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="BMSC_loo_+3A_x">x</code></td>
<td>
<p>An object of class <code>BMSC</code>, resulting from the
<a href="#topic+BMSC">BMSC</a> function.</p>
</td></tr>
<tr><td><code id="BMSC_loo_+3A_cores">cores</code></td>
<td>
<p>The number of cores for the
'loo::relative_eff' function</p>
</td></tr>
<tr><td><code id="BMSC_loo_+3A_...">...</code></td>
<td>
<p>for 'BMSC_loo' and 'BMSC_waic'
further arguments passed to the 'loo::extract_log_lik' function.
for 'print' and 'plot' methods further arguments to be passed to the
'print' or 'plot' functions</p>
</td></tr>
</table>


<h3>Value</h3>

<p>for 'BMSC_loo' a list with the log likelihood of the single case and the
control group,
the MCMC effective sample size divided by the total sample size,
and the leave-one-out cross-validation.
For 'BMSC_waic' a list with the log likelihood of the single
case and the control group, and the waic scores.
</p>

<hr>
<h2 id='BMSC_loo_compare'>bmscstan wrapper for model comparison.</h2><span id='topic+BMSC_loo_compare'></span><span id='topic+print.loo_compare_BMSC'></span><span id='topic+print.waic_compare_BMSC'></span>

<h3>Description</h3>

<p>bmscstan wrapper for model comparison.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BMSC_loo_compare(x, ...)

## S3 method for class 'loo_compare_BMSC'
print(x, simplify = TRUE, ...)

## S3 method for class 'waic_compare_BMSC'
print(x, simplify = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="BMSC_loo_compare_+3A_x">x</code></td>
<td>
<p>A list of <code>loo_BMSC</code> or  <code>waic_BMSC</code> objects.</p>
</td></tr>
<tr><td><code id="BMSC_loo_compare_+3A_...">...</code></td>
<td>
<p>further arguments passed to the function.</p>
</td></tr>
<tr><td><code id="BMSC_loo_compare_+3A_simplify">simplify</code></td>
<td>
<p>For the print method only, should only the essential columns
of the summary matrix be printed? The entire matrix is always returned,
but by default only the most important columns are printed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with the log likelihood of the single case and the
control group,
the MCMC effective sample size divided by the total sample size,
and the leave-one-out cross-validation.
</p>

<hr>
<h2 id='BMSC_pareto_k_table'>bmscstan wrapper for diagnostics for Pareto smoothed importance
sampling (PSIS)</h2><span id='topic+BMSC_pareto_k_table'></span><span id='topic+BMSC_pareto_k_ids'></span><span id='topic+BMSC_mcse_loo'></span><span id='topic+BMSC_pareto_k_values'></span><span id='topic+BMSC_pareto_k_influence_values'></span><span id='topic+BMSC_psis_n_eff_values'></span><span id='topic+print.pareto_k_table_BMSC'></span><span id='topic+print.pareto_k_ids_BMSC'></span><span id='topic+print.pareto_k_values_BMSC'></span><span id='topic+print.pareto_k_influence_values_BMSC'></span><span id='topic+print.psis_n_eff_values_BMSC'></span><span id='topic+print.mcse_loo_BMSC'></span>

<h3>Description</h3>

<p>bmscstan wrapper for diagnostics for Pareto smoothed importance
sampling (PSIS)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BMSC_pareto_k_table(x)

BMSC_pareto_k_ids(x, threshold = 0.5)

BMSC_mcse_loo(x, threshold = 0.7)

BMSC_pareto_k_values(x)

BMSC_pareto_k_influence_values(x)

BMSC_psis_n_eff_values(x)

## S3 method for class 'pareto_k_table_BMSC'
print(x, ...)

## S3 method for class 'pareto_k_ids_BMSC'
print(x, ...)

## S3 method for class 'pareto_k_values_BMSC'
print(x, ...)

## S3 method for class 'pareto_k_influence_values_BMSC'
print(x, ...)

## S3 method for class 'psis_n_eff_values_BMSC'
print(x, ...)

## S3 method for class 'mcse_loo_BMSC'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="BMSC_pareto_k_table_+3A_x">x</code></td>
<td>
<p>An object of class <code>loo_BMSC</code></p>
</td></tr>
<tr><td><code id="BMSC_pareto_k_table_+3A_threshold">threshold</code></td>
<td>
<p>for the 'pareto_k_ids' method is the minimum $k$ value to flag.
for the 'mcse_loo' method all the $k$ values greater than the
'threshold' will be returned as NA.</p>
</td></tr>
<tr><td><code id="BMSC_pareto_k_table_+3A_...">...</code></td>
<td>
<p>further arguments passed to the 'print' function.</p>
</td></tr>
</table>


<h3>Value</h3>


<ul>
<li><p>pareto_k_table returns an object of class &quot;pareto_k_table_BMSC&quot;,
which is a matrix with columns &quot;Count&quot;, &quot;Proportion&quot;, and &quot;Min. n_eff&quot;

</p>
</li>
<li><p>pareto_k_ids returns an integer vector indicating which observations
have Pareto k estimates above threshold

</p>
</li>
<li><p>mcse_loo returns the Monte Carlo standard error (MCSE) estimate for
PSIS-LOO.
MCSE will be NA if any Pareto kk values are above threshold.

</p>
</li>
<li><p>pareto_k_values returns a vector of the estimated Pareto k parameters.
These represent the reliability of sampling.

</p>
</li>
<li><p>pareto_k_influence_values returns a vector of the estimated Pareto
k parameters.
These represent influence of the observations on the model
posterior distribution.

</p>
</li>
<li><p>psis_k_influence_table returns a vector of the estimated PSIS
effective sample sizes.

</p>
</li></ul>


<hr>
<h2 id='bmscstan'>Bayesian Multilevel Single Case models using 'Stan'</h2><span id='topic+bmscstan'></span>

<h3>Description</h3>

<p>The <strong>bmscstan</strong> package provides an interface to fit Bayesian
Multilevel Single Case models.
These models compare the performance of a Single Case against a control
group, combining
the flexibility of multilevel models and the potentiality of Bayesian
Statistics.
</p>


<h3>Details</h3>

<p>The package is now limited to gaussian data only, but we will further expand
it to cover
binomial and ordinal (Likert scales) data.
</p>
<p>By means of <strong>bmscstan</strong> the effects of the control group and the
effects of the deviance between the
Single Case and the group will be estimated.
</p>
<p>The model to estimate the controls parameters is:
</p>
<p style="text-align:center;text-style:italic;">y~N(&beta; X + b Z, &sigma;<sup>2</sup>)</p>
<p>where <code class="reqn">y</code> is the controls' dependent variable, <code class="reqn">X</code> the contrast
matrix for Population-level (or Fixed)
Effects, and <code class="reqn">\beta</code> are the unknown coefficients to be estimate. <code class="reqn">Z</code>
is the contrast matrix for the
Varying (or Random, or Group-level) effects, and <code class="reqn">b</code> are the unknown
estimates for the varying effects.
<code class="reqn">\sigma^2</code> is the variance.
</p>
<p>In order to estimate the coefficients of the Single Case, the formula is the following:
</p>
<p style="text-align:center;text-style:italic;">y<sub>pt</sub>~N(&phi; X<sub>pt</sub>, &sigma;<sup>2</sup><sub>pt</sub>)</p>
<p>where <code class="reqn">\phi = \beta + \delta</code>.
</p>
<p>The validation of the approach can be found here:
https://www.doi.org/10.31234/osf.io/sajdq
</p>


<h3>Details</h3>

<p>The main function of <strong>bmscstan</strong> is <code><a href="#topic+BMSC">BMSC</a></code>, which uses formula syntax to
specify your model.
</p>

<hr>
<h2 id='data.ctrl'>Data from a control group of 16 participants</h2><span id='topic+data.ctrl'></span>

<h3>Description</h3>

<p>A dataset containing the results from the Body Sidednedd Task
from a control group of 16 participants
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data.ctrl
</code></pre>


<h3>Format</h3>

<p>A data frame with 4049 rows and 5 variables
</p>

<dl>
<dt>RT</dt><dd><p>Reaction times, in milliseconds</p>
</dd>
<dt>Body.District</dt><dd><p>Body district, categorial factor of
Body Sidedness Task: FOOT or HAND</p>
</dd>
<dt>Congruency</dt><dd><p>The trail was Congruent or Incongruent?</p>
</dd>
<dt>Side</dt><dd><p>The trial showed a left or right limb</p>
</dd>
<dt>ID</dt><dd><p>The participant ID</p>
</dd>
</dl>


<hr>
<h2 id='data.pt'>Data from a Single Case with brachial plexious lesion</h2><span id='topic+data.pt'></span>

<h3>Description</h3>

<p>A dataset containing the results from the Body Sidedness Task
from a single Single Case
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data.pt
</code></pre>


<h3>Format</h3>

<p>A data frame with 467 rows and 4 variables
</p>

<dl>
<dt>RT</dt><dd><p>Reaction times, in milliseconds</p>
</dd>
<dt>Body.District</dt><dd><p>Body district, categorial factor of
Body Sidedness Task: FOOT or HAND</p>
</dd>
<dt>Congruency</dt><dd><p>The trail was Congruent or Incongruent?</p>
</dd>
<dt>Side</dt><dd><p>The trial showed a left or right limb</p>
</dd>
</dl>


<hr>
<h2 id='pairwise.BMSC'>Pairwise contrasts</h2><span id='topic+pairwise.BMSC'></span>

<h3>Description</h3>

<p>Calculate pairwise comparisons between marginal posterior distributions divided by group levels
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pairwise.BMSC(mdl, contrast, covariate = NULL, who = "delta")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pairwise.BMSC_+3A_mdl">mdl</code></td>
<td>
<p>An object of class <code>BMSC</code>.</p>
</td></tr>
<tr><td><code id="pairwise.BMSC_+3A_contrast">contrast</code></td>
<td>
<p>Character value giving the name of the coefficient whose levels need to be compared.</p>
</td></tr>
<tr><td><code id="pairwise.BMSC_+3A_covariate">covariate</code></td>
<td>
<p>at the moment is silent</p>
</td></tr>
<tr><td><code id="pairwise.BMSC_+3A_who">who</code></td>
<td>
<p>parameter to choose the estimates to contrast
</p>

<dl>
<dt>control</dt><dd><p>only the controls</p>
</dd>
<dt>singlecase</dt><dd><p>only the single case <code class="reqn">(\beta + \delta)</code></p>
</dd>
<dt>delta</dt><dd><p>only the difference between the single case and controls</p>
</dd>
</dl>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>pairwise.BMSC</code> object
</p>


<h3>Examples</h3>

<pre><code class='language-R'> 

######################################
# simulation of controls' group data
######################################

# Number of levels for each condition and trials
NCond1  &lt;- 2
NCond2  &lt;- 2
Ntrials &lt;- 8
NSubjs  &lt;- 30

betas &lt;- c( 0 , 0 , 0 ,  0.2)

data.sim &lt;- expand.grid(
  trial      = 1:Ntrials,
  ID         = factor(1:NSubjs),
  Cond1      = factor(1:NCond1),
  Cond2      = factor(1:NCond2)
)

contrasts(data.sim$Cond1) &lt;- contr.sum(2)
contrasts(data.sim$Cond2) &lt;- contr.sum(2)

### d.v. generation
y &lt;- rep( times = nrow(data.sim) , NA )

# cheap simulation of individual random intercepts
set.seed(1)
rsubj &lt;- rnorm(NSubjs , sd = 0.1)

for( i in 1:length( levels( data.sim$ID ) ) ){

  sel &lt;- which( data.sim$ID == as.character(i) )

  mm  &lt;- model.matrix(~ Cond1 * Cond2 , data = data.sim[ sel , ] )

  set.seed(1 + i)
  y[sel] &lt;- mm %*% as.matrix(betas + rsubj[i]) +
    rnorm( n = Ntrials * NCond1 * NCond2 )

}

data.sim$y &lt;- y

# just checking the simulated data...
boxplot(y~Cond1*Cond2, data = data.sim)

######################################
# simulation of patient data
######################################

betas.pt &lt;- c( 0 , 0.8 , 0 ,  0)

data.pt &lt;- expand.grid(
  trial      = 1:Ntrials,
  Cond1      = factor(1:NCond1),
  Cond2      = factor(1:NCond2)
)

contrasts(data.pt$Cond1) &lt;- contr.sum(2)
contrasts(data.pt$Cond2) &lt;- contr.sum(2)

### d.v. generation
mm  &lt;- model.matrix(~ Cond1 * Cond2 , data = data.pt )

set.seed(5)
data.pt$y &lt;- (mm %*% as.matrix(betas.pt) +
                rnorm( n = Ntrials * NCond1 * NCond2 ))[,1]

# just checking the simulated data...
boxplot(y~Cond1*Cond2, data = data.pt)

mdl &lt;- BMSC(y ~ Cond1 * Cond2 + ( 1 | ID ),
            data_ctrl = data.sim, data_sc = data.pt, seed = 77,
            typeprior = "cauchy", s = 1)

summary(mdl)

pp_check(mdl)


pairwise.BMSC( mdl, contrast = "Cond11:Cond21")



</code></pre>

<hr>
<h2 id='plot.BMSC'>Plot estimates from a <code>BMSC</code> object.</h2><span id='topic+plot.BMSC'></span>

<h3>Description</h3>

<p>Plot estimates from a <code>BMSC</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'BMSC'
plot(x, who = "both", type = "interval", CI = 0.95, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.BMSC_+3A_x">x</code></td>
<td>
<p>An object of class <a href="#topic+BMSC">BMSC</a>.</p>
</td></tr>
<tr><td><code id="plot.BMSC_+3A_who">who</code></td>
<td>
<p>parameter to choose the estimates to plot
</p>

<dl>
<dt>both</dt><dd><p>plot in the same graph both controls and the Single Case</p>
</dd>
<dt>control</dt><dd><p>only the controls</p>
</dd>
<dt>single</dt><dd><p>only the Single Case <code class="reqn">(\beta + \delta)</code></p>
</dd>
<dt>delta</dt><dd><p>only the difference between the Single Case and controls</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="plot.BMSC_+3A_type">type</code></td>
<td>
<p>a parameter to select the typology of graph
</p>

<dl>
<dt>interval</dt><dd><p>the estimates will be represented by means of pointrange, with median and the boundaries of the credible interval</p>
</dd>
<dt>area</dt><dd><p>a density plot</p>
</dd>
<dt>hist</dt><dd><p>a density histogram</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="plot.BMSC_+3A_ci">CI</code></td>
<td>
<p>the dimension of the Credible Interval (or Equally Tailed Interval). Default 0.95.</p>
</td></tr>
<tr><td><code id="plot.BMSC_+3A_...">...</code></td>
<td>
<p>other arguments are ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a plot, a ggplot2 object, or a bayesplot object
</p>


<h3>Examples</h3>

<pre><code class='language-R'> 

# simulation of healthy controls data

Sigma.ctrl &lt;- matrix(cbind(1, .7,  .7, 1) ,nrow=2)

U &lt;- t(chol(Sigma.ctrl))

numobs &lt;- 100

set.seed(123)

random.normal &lt;- matrix( rnorm( n = ncol(U) * numobs, mean = 3, sd = 1),
                         nrow = ncol(U), ncol = numobs)

X = U %*% random.normal

dat.ctrl &lt;- as.data.frame(t(X))

names(dat.ctrl) &lt;- c("y","x")

cor(dat.ctrl)

# simulation of patient data

Sigma.pt &lt;- matrix(cbind(1, 0,  0, 1) ,nrow=2)

U &lt;- t(chol(Sigma.pt))

numobs &lt;- 20

set.seed(0)

random.normal &lt;- matrix( rnorm( n = ncol(U) * numobs, mean = 3, sd = 1),
                 nrow = ncol(U), ncol = numobs)

X = U %*% random.normal

dat.pt &lt;- as.data.frame(t(X))

names(dat.pt) &lt;- c("y","x")

cor(dat.pt)

# fit the single case model

mdl.reg &lt;- BMSC(y ~ x, data_ctrl = dat.ctrl, data_sc = dat.pt, seed = 10)

# summarize the data

summary(mdl.reg)

# plot the results of both patient and control group

plot(mdl.reg)

# plot the results of the patient

plot(mdl.reg, who = "single")

# plot the results of the difference between the control group and the patient

plot(mdl.reg, who = "delta")

# density plots

plot(mdl.reg, type = "area")

# histograms

plot(mdl.reg, type = "hist")


</code></pre>

<hr>
<h2 id='plot.pairwise.BMSC'>Plot estimates from a <code>pairwise.BMSC</code> object.</h2><span id='topic+plot.pairwise.BMSC'></span>

<h3>Description</h3>

<p>Plot estimates from a <code>pairwise.BMSC</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'pairwise.BMSC'
plot(x, type = "interval", CI = 0.95, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.pairwise.BMSC_+3A_x">x</code></td>
<td>
<p>An object of class <a href="#topic+pairwise.BMSC">pairwise.BMSC</a>.</p>
</td></tr>
<tr><td><code id="plot.pairwise.BMSC_+3A_type">type</code></td>
<td>
<p>a parameter to select the typology of graph
</p>

<dl>
<dt>interval</dt><dd><p>the estimates will be represented by means of pointrange, with median and the boundaries of the credible interval</p>
</dd>
<dt>area</dt><dd><p>a density plot</p>
</dd>
<dt>hist</dt><dd><p>a density histogram</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="plot.pairwise.BMSC_+3A_ci">CI</code></td>
<td>
<p>the dimension of the Credible Interval (or Equally Tailed Interval). Default 0.95.</p>
</td></tr>
<tr><td><code id="plot.pairwise.BMSC_+3A_...">...</code></td>
<td>
<p>other arguments are ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of two ggplot2 objects
</p>


<h3>Examples</h3>

<pre><code class='language-R'> 

######################################
# simulation of controls' group data
######################################

# Number of levels for each condition and trials
NCond1  &lt;- 2
NCond2  &lt;- 2
Ntrials &lt;- 8
NSubjs  &lt;- 30

betas &lt;- c( 0 , 0 , 0 ,  0.2)

data.sim &lt;- expand.grid(
  trial      = 1:Ntrials,
  ID         = factor(1:NSubjs),
  Cond1      = factor(1:NCond1),
  Cond2      = factor(1:NCond2)
)

contrasts(data.sim$Cond1) &lt;- contr.sum(2)
contrasts(data.sim$Cond2) &lt;- contr.sum(2)

### d.v. generation
y &lt;- rep( times = nrow(data.sim) , NA )

# cheap simulation of individual random intercepts
set.seed(1)
rsubj &lt;- rnorm(NSubjs , sd = 0.1)

for( i in 1:length( levels( data.sim$ID ) ) ){

  sel &lt;- which( data.sim$ID == as.character(i) )

  mm  &lt;- model.matrix(~ Cond1 * Cond2 , data = data.sim[ sel , ] )

  set.seed(1 + i)
  y[sel] &lt;- mm %*% as.matrix(betas + rsubj[i]) +
    rnorm( n = Ntrials * NCond1 * NCond2 )

}

data.sim$y &lt;- y

# just checking the simulated data...
boxplot(y~Cond1*Cond2, data = data.sim)

######################################
# simulation of patient data
######################################

betas.pt &lt;- c( 0 , 0.8 , 0 ,  0)

data.pt &lt;- expand.grid(
  trial      = 1:Ntrials,
  Cond1      = factor(1:NCond1),
  Cond2      = factor(1:NCond2)
)

contrasts(data.pt$Cond1) &lt;- contr.sum(2)
contrasts(data.pt$Cond2) &lt;- contr.sum(2)

### d.v. generation
mm  &lt;- model.matrix(~ Cond1 * Cond2 , data = data.pt )

set.seed(5)
data.pt$y &lt;- (mm %*% as.matrix(betas.pt) +
                rnorm( n = Ntrials * NCond1 * NCond2 ))[,1]

# just checking the simulated data...
boxplot(y~Cond1*Cond2, data = data.pt)

mdl &lt;- BMSC(y ~ Cond1 * Cond2 + ( 1 | ID ),
            data_ctrl = data.sim, data_sc = data.pt, seed = 77,
            typeprior = "cauchy", s = 1)

summary(mdl)

pp_check(mdl)

# compute pairwise contrasts
ph &lt;- pairwise.BMSC( mdl, contrast = "Cond11:Cond21")

ph

# plot pairwise comparisons

plot(ph)

plot(ph , type = "area")

# customization of pairiwse comparisons plot

plot(ph)[[1]]+theme_bw(base_size = 18)

plot(ph , type = "area")[[1]]+theme_bw(base_size = 18)+
   theme(strip.text.y = element_text( angle = 0))


</code></pre>

<hr>
<h2 id='pp_check.BMSC'>Posterior predictive check for BMSC objects</h2><span id='topic+pp_check.BMSC'></span>

<h3>Description</h3>

<p><code>pp_check()</code> plots the posterior predictive check for BMSC objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'BMSC'
pp_check(object, type = "dens", limited = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pp_check.BMSC_+3A_object">object</code></td>
<td>
<p>a <a href="#topic+BMSC">BMSC</a> object</p>
</td></tr>
<tr><td><code id="pp_check.BMSC_+3A_type">type</code></td>
<td>
<p>a parameter to select the typology of graph
</p>

<dl>
<dt>dens</dt><dd><p>density overlay plot</p>
</dd>
<dt>hist</dt><dd><p>histogram plot</p>
</dd>
<dt>mode</dt><dd><p>the distribution of the mode statistic, over the simulated datasets, compared to the mode of the real data</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="pp_check.BMSC_+3A_limited">limited</code></td>
<td>
<p>logical. TRUE if the output should be limited within the 95% credible interval, FALSE it should not. Default FALSE.</p>
</td></tr>
<tr><td><code id="pp_check.BMSC_+3A_...">...</code></td>
<td>
<p>other arguments are ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a ggplot2 object
</p>


<h3>Examples</h3>

<pre><code class='language-R'> 
# simulation of healthy controls data

Sigma.ctrl &lt;- matrix(cbind(1, .7,  .7, 1) ,nrow=2)

U &lt;- t(chol(Sigma.ctrl))

numobs &lt;- 100

set.seed(123)

random.normal &lt;- matrix( rnorm( n = ncol(U) * numobs, mean = 3, sd = 1),
                         nrow = ncol(U), ncol = numobs)

X = U %*% random.normal

dat.ctrl &lt;- as.data.frame(t(X))

names(dat.ctrl) &lt;- c("y","x")

cor(dat.ctrl)

# simulation of patient data

Sigma.pt &lt;- matrix(cbind(1, 0,  0, 1) ,nrow=2)

U &lt;- t(chol(Sigma.pt))

numobs &lt;- 20

set.seed(0)

random.normal &lt;- matrix( rnorm( n = ncol(U) * numobs, mean = 3, sd = 1),
                 nrow = ncol(U), ncol = numobs)

X = U %*% random.normal

dat.pt &lt;- as.data.frame(t(X))

names(dat.pt) &lt;- c("y","x")

cor(dat.pt)

# fit the single case model

mdl.reg &lt;- BMSC(y ~ x, data_ctrl = dat.ctrl, data_sc = dat.pt, seed = 10)

# summarize the data

summary(mdl.reg)

# plot the posterior predictive checks

pp_check(mdl.reg, limited = FALSE)

pp_check(mdl.reg, limited = TRUE)

pp_check(mdl.reg, type = "mode", limited = FALSE)

pp_check(mdl.reg, type = "hist", limited = FALSE)


</code></pre>

<hr>
<h2 id='print.pairwise.BMSC'>Print summaries of Pairwise Bayesian Multilevel Single Case objects</h2><span id='topic+print.pairwise.BMSC'></span>

<h3>Description</h3>

<p>Print summaries of Pairwise Bayesian Multilevel Single Case objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'pairwise.BMSC'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.pairwise.BMSC_+3A_x">x</code></td>
<td>
<p>An object of class <code>pairwise.BMSC</code>, resulting from the <a href="#topic+pairwise.BMSC">pairwise.BMSC</a> function.</p>
</td></tr>
<tr><td><code id="print.pairwise.BMSC_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>

<hr>
<h2 id='print.summary.BMSC'>Print summaries of Bayesian Multilevel Single Case objects</h2><span id='topic+print.summary.BMSC'></span>

<h3>Description</h3>

<p>Print summaries of Bayesian Multilevel Single Case objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'summary.BMSC'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.summary.BMSC_+3A_x">x</code></td>
<td>
<p>An object of class <code>summary.BMSC</code>, resulting from the <a href="#topic+summary.BMSC">summary.BMSC</a> function.</p>
</td></tr>
<tr><td><code id="print.summary.BMSC_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>

<hr>
<h2 id='randomeffects'>Random Effects specification on
Bayesian Multilevel Single Case models using 'Stan'</h2><span id='topic+randomeffect'></span>

<h3>Description</h3>

<p>The <strong>BMSC</strong> function allows the flexibility of multilevel (generalised)
linear models on single case analysis.
</p>
<p>In particular, it is possible to specify the population-level (a.k.a. mixed
effects) and the group-level (a.k.a. random effects) coefficients.
</p>
<p>The specification of the population- and group-level effects can be done
using the well-known <strong>lme4</strong> notation with specific limitations:
</p>

<ul>
<li><p> it is no possible to estimate uncorrelated group-level effects
</p>
</li>
<li><p> it is no possible to directly estimate nested effects. You need to use
a trick that is specified in the <strong>Details</strong> section.
</p>
</li></ul>



<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
  lmer formulation                                </td><td style="text-align: center;"> BMSC availability   </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>(1 | grouping_factor)</code>                    </td><td style="text-align: center;"> Yes                 </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>(1 + slope | grouping_factor)</code>            </td><td style="text-align: center;"> Yes                 </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>(0 + slope | grouping_factor)</code>            </td><td style="text-align: center;"> No                  </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>(1 | grouping_factor1 : grouping_factor2)</code></td><td style="text-align: center;"> Yes[^1]             </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>(1 | grouping_factor1 / grouping_factor2)</code></td><td style="text-align: center;"> Yes[^2]             </td>
</tr>
<tr>
 <td style="text-align: left;">
 </td>
</tr>

</table>

<p>[^1]: The <strong>BMSC</strong> function dose not allow the use of the interaction
symbol &quot;:&quot;, but this problem is easily solved by creating a new variable
within your dataframe given by the interaction of the two factors.
</p>
<p>[^2]: The <code>(1 | grouping_factor1 / grouping_factor2)  </code> syntax is the
equivalent of the explicit version
<code>(1 \| grouping_factor1:grouping_factor2) +  (1 | grouping_factor1)</code>.
</p>
<p>Therefore, you need to create a new grouping factor representing the
interaction between <code>grouping_factor1</code> and <code>grouping_factor2</code>,
and use this in the explicit version
<code>(1 | grouping_factor_interaction) +  (1 | grouping_factor1)</code>.
</p>

<hr>
<h2 id='summary.BMSC'>Summarizing Bayesian Multilevel Single Case objects</h2><span id='topic+summary.BMSC'></span>

<h3>Description</h3>

<p>summary method for class &quot;BMSC&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'BMSC'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.BMSC_+3A_object">object</code></td>
<td>
<p>An object of class <code>BMSC</code>, resulting from the <a href="#topic+BMSC">BMSC</a> function.</p>
</td></tr>
<tr><td><code id="summary.BMSC_+3A_...">...</code></td>
<td>
<p>other arguments are ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>summary.BMSC</code> object
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
