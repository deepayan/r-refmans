<!DOCTYPE html><html><head><title>Help for package chillR</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {chillR}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#chillR-package'><p><img src="../help/figures/chillR.png" width='25%' alt='chillR logo' /></p>
chillR: statistical methods for phenology analysis in temperate fruit trees</a></li>
<li><a href='#add_date'><p>Add date/time column to data.frame</p></a></li>
<li><a href='#bloom_prediction'><p>Bloom prediction from chilling and forcing requirements, assumed to be</p>
fulfilled strictly in sequence</a></li>
<li><a href='#bloom_prediction2'><p>Bloom prediction from chilling and forcing requirements, assumed to be</p>
fulfilled strictly in sequence - version 2</a></li>
<li><a href='#bloom_prediction3'><p>Bloom prediction from chilling and forcing requirements, assumed to be</p>
fulfilled strictly in sequence - version 3</a></li>
<li><a href='#bootstrap.phenologyFit'><p>bootstrap.phenologyFit</p></a></li>
<li><a href='#c.bootstrap_phenologyFit'><p>Concatenate bootstrap_phenologyfit objects</p></a></li>
<li><a href='#california_stations'><p>Weather stations in California</p></a></li>
<li><a href='#check_temperature_record'><p>Check a daily or hourly temperature record for compliance with chillR's standards</p></a></li>
<li><a href='#check_temperature_scenario'><p>Check temperature scenario for consistency</p></a></li>
<li><a href='#chifull'><p>chifull</p></a></li>
<li><a href='#chile_agromet2chillR'><p>Convert a weather file downloaded from the Chilean Agromet website to chillR</p>
format</a></li>
<li><a href='#chilling'><p>Calculation of chilling and heat from hourly temperature records</p></a></li>
<li><a href='#Chilling_Hours'><p>Calculation of cumulative chill according to the Chilling Hours Model</p></a></li>
<li><a href='#chilling_hourtable'><p>Add chilling and heat accumulation to table of hourly temperatures</p></a></li>
<li><a href='#ChuineCF'><p>ChuineCF</p></a></li>
<li><a href='#ChuineFstar'><p>ChuineFstar</p></a></li>
<li><a href='#color_bar_maker'><p>Make color scheme for bar plots in outputs of the chillR package</p></a></li>
<li><a href='#convert_scen_information'><p>Converts list of change scenarios to data.frame or vice versa</p></a></li>
<li><a href='#daily_chill'><p>Calculation of daily chill and heat accumulation</p></a></li>
<li><a href='#Date2YEARMODA'><p>Date to YEARMODA conversion</p></a></li>
<li><a href='#daylength'><p>Compute sunrise and sunset times, and daylength</p></a></li>
<li><a href='#download_baseline_cmip6_ecmwfr'><p>Download historical CMIP6 Data via the ecwfr package</p></a></li>
<li><a href='#download_cmip6_ecmwfr'><p>Download CMIP6 Data via the ecwfr package</p></a></li>
<li><a href='#Dynamic_Model'><p>Dynamic_Model</p></a></li>
<li><a href='#DynModel_driver'><p>DynModel_driver</p></a></li>
<li><a href='#Empirical_daily_temperature_curve'><p>Empirical daily temperature curve</p></a></li>
<li><a href='#Empirical_hourly_temperatures'><p>Empirical daily temperature prediction</p></a></li>
<li><a href='#extract_cmip6_data'><p>Unpacks and formats downloaded CMIP6 data</p></a></li>
<li><a href='#extract_differences_between_characters'><p>Identify shared leading or trailing character strings</p></a></li>
<li><a href='#extract_temperatures_from_grids'><p>Extract temperature information from gridded dataset</p></a></li>
<li><a href='#filter_temperatures'><p>Quality filter for temperature records</p></a></li>
<li><a href='#fix_weather'><p>Weather data fixer and quality checker</p></a></li>
<li><a href='#GDD'><p>Calculation of cumulative heat according to the Growing Degree Day Model</p></a></li>
<li><a href='#GDH'><p>Calculation of cumulative heat according to the Growing Degree Hours Model</p></a></li>
<li><a href='#GDH_model'><p>Calculation of cumulative heat according to the Growing Degree Hours Model</p>
(alternative function name)</a></li>
<li><a href='#gen_rel_change_scenario'><p>Generates relative climate change scenarios based on extracted CMIP6 data</p></a></li>
<li><a href='#genSeason'><p>Generate Seasons</p></a></li>
<li><a href='#genSeasonList'><p>genSeasonList</p></a></li>
<li><a href='#get_last_date'><p>Get the last date from a phenology record</p></a></li>
<li><a href='#get_weather'><p>Download weather data from online database</p></a></li>
<li><a href='#getClimateWizard_scenarios'><p>Extract mutltiple scenarios from the ClimateWizard database</p></a></li>
<li><a href='#getClimateWizardData'><p>Extract climate data from the ClimateWizard database</p></a></li>
<li><a href='#handle_cimis'><p>List, download or convert to chillR format data from the CIMIS database</p></a></li>
<li><a href='#handle_dwd'><p>List, download or convert to chillR format data from the Deutscher Wetterdienst database</p></a></li>
<li><a href='#handle_dwd_old'><p>List, download or convert to chillR format data from the Deutscher Wetterdienst database</p></a></li>
<li><a href='#handle_gsod'><p>List, download or convert to chillR format data from the Global Summary of</p>
the Day database</a></li>
<li><a href='#handle_gsod_old'><p>Deprecated version of handle_gsod. List, download or convert to chillR format data from the Global Summary of</p>
the Day database</a></li>
<li><a href='#handle_ucipm'><p>List, download or convert to chillR format data from the UCIPM database</p></a></li>
<li><a href='#identify_common_string'><p>Identify shared leading or trailing character strings</p></a></li>
<li><a href='#interpolate_gaps'><p>Linear gap interpolation</p></a></li>
<li><a href='#interpolate_gaps_hourly'><p>Interpolate gaps in hourly temperature records</p></a></li>
<li><a href='#JDay_count'><p>Count days between two Julian dates</p></a></li>
<li><a href='#JDay_earlier'><p>Check whether a Julian date is before or after another one</p></a></li>
<li><a href='#JDay_later'><p>Check whether a Julian date is after another one</p></a></li>
<li><a href='#KA_bloom'><p>Cherry bloom data for Klein-Altendorf, Germany</p></a></li>
<li><a href='#KA_weather'><p>Weather data for Klein-Altendorf, Germany</p></a></li>
<li><a href='#leap_year'><p>Leap year finder</p></a></li>
<li><a href='#load_ClimateWizard_scenarios'><p>Load climate wizard scenarios</p></a></li>
<li><a href='#load_temperature_scenarios'><p>Load temperature scenarios</p></a></li>
<li><a href='#make_all_day_table'><p>Fill in missing days in incomplete time series</p></a></li>
<li><a href='#make_california_UCIPM_station_list'><p>Makes a list of the UC IPM weather stations</p></a></li>
<li><a href='#make_chill_plot'><p>Plot climate metrics over time</p></a></li>
<li><a href='#make_climate_scenario'><p>Make climate scenario</p></a></li>
<li><a href='#make_climate_scenario_from_files'><p>Make climate scenario from multiple saved csv files</p></a></li>
<li><a href='#make_daily_chill_figures'><p>Produce image of daily chill and heat accumulation</p></a></li>
<li><a href='#make_daily_chill_plot'><p>Plot daily climate metric accumulation throughout the year</p></a></li>
<li><a href='#make_daily_chill_plot2'><p>Plot daily climate metric accumulation throughout the year (2)</p></a></li>
<li><a href='#make_hourly_temps'><p>Make hourly temperature record from daily data</p></a></li>
<li><a href='#make_JDay'><p>Make Julian Day in dataframe</p></a></li>
<li><a href='#make_multi_pheno_trend_plot'><p>Combine multiple phenology contour plots in one figure</p></a></li>
<li><a href='#make_pheno_trend_plot'><p>Make image showing phenology response to temperatures during two phases</p></a></li>
<li><a href='#ordered_climate_list'><p>Sort files in a folder, so that numbers are in ascending sequence</p></a></li>
<li><a href='#patch_daily_temperatures'><p>Patch gaps in daily weather records</p></a></li>
<li><a href='#patch_daily_temps'><p>Patch gaps in daily weather records - updated</p></a></li>
<li><a href='#PhenoFlex'><p>PhenoFlex</p></a></li>
<li><a href='#PhenoFlex_fixedDynModelGAUSSwrapper'><p>PhenoFlex_fixedDynModelGAUSSwrapper</p></a></li>
<li><a href='#PhenoFlex_fixedDynModelwrapper'><p>PhenoFlex_fixedDynModelwrapper</p></a></li>
<li><a href='#PhenoFlex_GAUSSwrapper'><p>PhenoFlex_GAUSSwrapper</p></a></li>
<li><a href='#PhenoFlex_GDHwrapper'><p>PhenoFlex_GDHwrapper</p></a></li>
<li><a href='#phenologyFit'><p>phenologyFit</p></a></li>
<li><a href='#phenologyFitter'><p>phenologyFitter</p></a></li>
<li><a href='#plot_climate_scenarios'><p>Plot multiple chilling scenario groups (or for other metrics)</p></a></li>
<li><a href='#plot_climateWizard_scenarios'><p>Plot mutltiple ClimateWizard scenarios obtained with getClimateWizard_scenarios</p></a></li>
<li><a href='#plot_phenology_trends'><p>Visualizing phenology responses to temperatures during two phases</p></a></li>
<li><a href='#plot_PLS'><p>Output of Partial Least Squares analysis results of phenology vs. daily mean</p>
temperatures</a></li>
<li><a href='#plot_scenarios'><p>Plot historic and future scenarios for climate-related metrics (<code>ggplot2</code> version)</p></a></li>
<li><a href='#plot.bootstrap_phenologyFit'><p>plot bootstrap_phenologyFit</p></a></li>
<li><a href='#plot.phenologyFit'><p>plot phenologyFit</p></a></li>
<li><a href='#PLS_chill_force'><p>Partial Least Squares analysis of phenology vs. accumulated daily chill and</p>
heat</a></li>
<li><a href='#PLS_pheno'><p>Partial Least Squares analysis of phenology vs. daily mean temperatures</p></a></li>
<li><a href='#predict.bootstrap_phenologyFit'><p>predict bootstrap_phenologyFit</p></a></li>
<li><a href='#predict.phenologyFit'><p>predict phenologyFit</p></a></li>
<li><a href='#print.phenologyFit'><p>print phenologyFit</p></a></li>
<li><a href='#read_tab'><p>Read csv table regardless of whether it is a true csv or the French type</p></a></li>
<li><a href='#RMSEP'><p>Root Mean Square Error of Prediction (RMSEP)</p></a></li>
<li><a href='#RPD'><p>Residual Prediction Deviation (RPD)</p></a></li>
<li><a href='#RPIQ'><p>Ratio of Performance to InterQuartile distance (RPIQ)</p></a></li>
<li><a href='#runn_mean'><p>Running mean of a vector</p></a></li>
<li><a href='#runn_mean_pred'><p>Prediction based on a running mean</p></a></li>
<li><a href='#save_temperature_scenarios'><p>Save temperature scenarios generated with temperature_generation</p></a></li>
<li><a href='#select_by_file_extension'><p>Select string that end in a particular way (e.g. a certain file extension)</p></a></li>
<li><a href='#stack_hourly_temps'><p>Stacking of hourly temperatures</p></a></li>
<li><a href='#stage_transitions'><p>Compute what it takes to advance through development stages</p></a></li>
<li><a href='#step_model'><p>Calculation of cumulative temperature metric according to a user-defined</p>
stepwise weight function</a></li>
<li><a href='#StepChill_Wrapper'><p>StepChill_Wrapper</p></a></li>
<li><a href='#summary.bootstrap_phenologyFit'><p>summary.bootstrap_phenologyFit</p></a></li>
<li><a href='#summary.phenologyFit'><p>summary phenologyFit</p></a></li>
<li><a href='#temperature_generation'><p>Generation of synthetic temperature records</p></a></li>
<li><a href='#temperature_scenario_baseline_adjustment'><p>Make temperature scenario relative to a particular baseline</p></a></li>
<li><a href='#temperature_scenario_from_records'><p>Make monthly temperature scenario from historic records</p></a></li>
<li><a href='#tempResponse'><p>Calculation of climatic metrics from hourly temperature records</p></a></li>
<li><a href='#tempResponse_daily_list'><p>Calculation of climatic metrics from lists of daily temperature records</p></a></li>
<li><a href='#tempResponse_hourtable'><p>Add metric accumulation to table of hourly temperatures</p></a></li>
<li><a href='#test_if_equal'><p>Test if all character vectors in a string are equal</p></a></li>
<li><a href='#UniChill_Wrapper'><p>UniChill_Wrapper</p></a></li>
<li><a href='#UnifiedModel_Wrapper'><p>UnifiedModel_Wrapper</p></a></li>
<li><a href='#UniForce_Wrapper'><p>UniForce_Wrapper</p></a></li>
<li><a href='#Utah_Model'><p>Calculation of cumulative chill according to the Utah Model</p></a></li>
<li><a href='#VIP'><p>Calculate VIP scores for PLS regression</p></a></li>
<li><a href='#weather2chillR'><p>Convert downloaded weather to chillR format</p></a></li>
<li><a href='#Winters_hours_gaps'><p>Hourly temperature data sample</p></a></li>
<li><a href='#YEARMODA2Date'><p>YEARMODA to Date conversion</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Statistical Methods for Phenology Analysis in Temperate Fruit
Trees</td>
</tr>
<tr>
<td>Version:</td>
<td>0.75</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-11-27</td>
</tr>
<tr>
<td>Description:</td>
<td>The phenology of plants (i.e. the timing of their annual life
    phases) depends on climatic cues. For temperate trees and many other plants,
    spring phases, such as leaf emergence and flowering, have been found to result
    from the effects of both cool (chilling) conditions and heat. Fruit tree
    scientists (pomologists) have developed some metrics to quantify chilling
    and heat (e.g. see Luedeling (2012) &lt;<a href="https://doi.org/10.1016%2Fj.scienta.2012.07.011">doi:10.1016/j.scienta.2012.07.011</a>&gt;).
    'chillR' contains functions for processing temperature records into
    chilling (Chilling Hours, Utah Chill Units and Chill Portions) and heat units
    (Growing Degree Hours). Regarding chilling metrics, Chill Portions are often
    considered the most promising, but they are difficult to calculate. This package
    makes it easy. 'chillR' also contains procedures for conducting a PLS analysis
    relating phenological dates (e.g. bloom dates) to either mean temperatures or
    mean chill and heat accumulation rates, based on long-term weather and phenology
    records (Luedeling and Gassner (2012) &lt;<a href="https://doi.org/10.1016%2Fj.agrformet.2011.10.020">doi:10.1016/j.agrformet.2011.10.020</a>&gt;).
    As of version 0.65, it also includes functions for generating weather
    scenarios with a weather generator, for conducting climate change analyses
    for temperature-based climatic metrics and for plotting results from such
    analyses. Since version 0.70, 'chillR' contains a function for interpolating
    hourly temperature records.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>assertthat, dplyr, ecmwfr, fields, GenSA, ggplot2, graphics,
grDevices, httr, jsonlite, Kendall, lubridate, magrittr, metR,
patchwork, pls, plyr, progress, purrr, R.utils, raster, Rcpp,
RCurl, readxl, reshape2, rlang, RMAWGEN, scales, stats,
stringr, tidyr, utils, XML</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, testthat</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>LazyData:</td>
<td>TRUE</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-11-27 21:53:05 UTC; Eike</td>
</tr>
<tr>
<td>Author:</td>
<td>Eike Luedeling <a href="https://orcid.org/0000-0002-7316-3631"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Lars Caspersen <a href="https://orcid.org/0009-0000-3057-7327"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Eduardo Fernandez <a href="https://orcid.org/0000-0002-6949-9685"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Eike Luedeling &lt;eike@eikeluedeling.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-11-27 22:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='chillR-package'><img src="../help/figures/chillR.png" width='25%' alt='chillR logo' />
chillR: statistical methods for phenology analysis in temperate fruit trees</h2><span id='topic+chillR-package'></span>

<h3>Description</h3>


<p><code>chillR</code> contains functions for processing temperature records into chilling (Chilling Hours, Utah Chill Units
and Chill Portions) and heat units (Growing Degree Hours). Regarding chilling metrics, Chill Portions are often
considered the most promising, but they are difficult to calculate. This package makes it easy.
<code>chillR</code> also contains procedures for conducting a Partial Least Square regression analysis relating
phenological dates (e.g. bloom dates) to either mean temperatures or mean chill and heat accumulation rates,
based on long-term weather and phenology records (Luedeling and Gassner 2012).
As of version 0.65, it also includes functions for generating weather scenarios with a weather generator,
for conducting climate change analyses for temperature-based climatic metrics and for plotting results from such
analyses. Since version 0.70, <code>chillR</code> contains a function for interpolating hourly temperature records.
As of version 0.72.6, the package contains functions to design elegant plots using the <code><a href="ggplot2.html#topic+ggplot2">ggplot2</a></code> package.
</p>


<h3>Author(s)</h3>


<table>
<tr>
 <td style="text-align: left;">
<strong>Prof. Dr. Eike Luedeling</strong> (creator)</td>
</tr>
<tr>
 <td style="text-align: left;">
<a href="mailto:eike@eikeluedeling.com">eike@eikeluedeling.com</a></td>
</tr>
<tr>
 <td style="text-align: left;">   
<a href="https://orcid.org/0000-0002-7316-3631">ORCID</a></td>
</tr>
<tr>
 <td style="text-align: left;">
<a href="https://github.com/eikeluedeling">eikeluedeling on GitHub</a></td>
</tr>
<tr>
 <td style="text-align: left;">   
 </td>
</tr>
<tr>
 <td style="text-align: left;">
<strong>Lars Caspersen</strong> (contributor)</td>
</tr>
<tr>
 <td style="text-align: left;">
<a href="mailto:lcaspers@uni-bonn.de">lcaspers@uni-bonn.de</a></td>
</tr>
<tr>
 <td style="text-align: left;">
<a href="https://orcid.org/0009-0000-3057-7327">ORCID</a></td>
</tr>
<tr>
 <td style="text-align: left;">
<a href="https://github.com/larscaspersen">larscaspersen on GitHub</a></td>
</tr>
<tr>
 <td style="text-align: left;">
 </td>
</tr>
<tr>
 <td style="text-align: left;">
<strong>Dr. Eduardo Fernández</strong> (contributor)</td>
</tr>
<tr>
 <td style="text-align: left;">
<a href="mailto:eduardo.fernandez.c@pucv.cl">eduardo.fernandez.c@pucv.cl</a></td>
</tr>
<tr>
 <td style="text-align: left;">
<a href="https://orcid.org/0000-0002-6949-9685">ORCID</a></td>
</tr>
<tr>
 <td style="text-align: left;">
<a href="https://github.com/EduardoFernandezC">EduardoFernandezC on GitHub</a>
</td>
</tr>

</table>



<h3>References</h3>

<p>Luedeling E and Gassner A, 2012. Partial Least Squares Regression for
analyzing walnut phenology in California. Agricultural and Forest
Meteorology 158, 43-52. <a href="https://doi.org/10.1016/j.agrformet.2011.10.020">doi:10.1016/j.agrformet.2011.10.020</a>
</p>

<hr>
<h2 id='add_date'>Add date/time column to data.frame</h2><span id='topic+add_date'></span>

<h3>Description</h3>

<p>Takes the &lsquo;Year', 'Month', 'Day' and, if available, 'Hour', 'Minute' and 'Second' columns of a data.frame and uses them to produce a 'Date' column that uses R&rsquo;s standard data/time format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_date(df)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_date_+3A_df">df</code></td>
<td>
<p>Data frame containing columns 'Year', 'Month', 'Day' and - optionally - 'Hour', 'Minute' and/or 'Second'</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Converts YEARMODA to R date
</p>


<h3>Value</h3>

<p>data.frame consisting of the df input and a new column 'Date'
</p>


<h3>Author(s)</h3>

<p>Eike Luedeling
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

add_date(KA_weather)
add_date(Winters_hours_gaps)

 
</code></pre>

<hr>
<h2 id='bloom_prediction'>Bloom prediction from chilling and forcing requirements, assumed to be
fulfilled strictly in sequence</h2><span id='topic+bloom_prediction'></span>

<h3>Description</h3>

<p>This is a pretty rudimentary function to predict phenological dates from
chilling and forcing requirements and hourly chilling and forcing data. Note
that there are enormous uncertainties in these predictions, which are hardly
ever acknowledged. So please use this function with caution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bloom_prediction(
  HourChillTable,
  Chill_req,
  Heat_req,
  Chill_model = "Chill_Portions",
  Heat_model = "GDH",
  Start_JDay = 305
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bloom_prediction_+3A_hourchilltable">HourChillTable</code></td>
<td>
<p>a data frame resulting from the chilling_hourtable
function.</p>
</td></tr>
<tr><td><code id="bloom_prediction_+3A_chill_req">Chill_req</code></td>
<td>
<p>numeric parameter indicating the chilling requirement of
the particular growth stage (in the unit specified by &quot;Chill_model&quot;)</p>
</td></tr>
<tr><td><code id="bloom_prediction_+3A_heat_req">Heat_req</code></td>
<td>
<p>numeric parameter indicating the heat requirement of the
particular growth stage (in Growing Degree Hours)</p>
</td></tr>
<tr><td><code id="bloom_prediction_+3A_chill_model">Chill_model</code></td>
<td>
<p>character string specifying the chill model to use. This
has to correspond to the name of the column in HourChillTable that contains
the chill accumulation (e.g &quot;Chilling_Hours&quot;, &quot;Chill_Portions&quot; and &quot;Chill_Units&quot;).</p>
</td></tr>
<tr><td><code id="bloom_prediction_+3A_heat_model">Heat_model</code></td>
<td>
<p>character string specifying the heat model to use. This
has to correspond to the name of the column in HourChillTable that contains
the heat accumulation (e.g &quot;GDH&quot;).</p>
</td></tr>
<tr><td><code id="bloom_prediction_+3A_start_jday">Start_JDay</code></td>
<td>
<p>numeric parameter indicating the day when chill
accumulation is supposed to start</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is a bit preliminary at the moment. It will hopefully be
refined later.
</p>
<p>Chill metrics are calculated as given in the references below. Chilling
Hours are all hours with temperatures between 0 and 7.2 degrees C. Units of
the Utah Model are calculated as suggested by Richardson et al. (1974)
(different weights for different temperature ranges, and negation of
chilling by warm temperatures). Chill Portions are calculated according to
Fishman et al. (1987a,b). More honestly, they are calculated according to an
Excel sheet produced by Amnon Erez and colleagues, which converts the
complex equations in the Fishman papers into relatively simple Excel
functions. These were translated into R. References to papers that include
the full functions are given below. Growing Degree Hours are calculated
according to Anderson et al. (1986), using the default values they suggest.
</p>


<h3>Value</h3>

<p>data frame containing the predicted dates of chilling requirement
fulfillment and timing of the phenological stage. Columns are Creqfull,
Creq_year, Crey_month, Creq_day and Creq_JDay (the row number, date and
Julian date of chilling requirement fulfillement), Hreqfull, Hreq_year,
Hreq_month, Hreq_day and Hreq_JDay (the row number, date and Julian date of
heat requirement fulfillment - this corresponds to the timing of the
phenological event.
</p>


<h3>Note</h3>

<p>After doing extensive model comparisons, and reviewing a lot of
relevant literature, I do not recommend using the Chilling Hours or Utah
Models, especially in warm climates! The Dynamic Model (Chill Portions),
though far from perfect, seems much more reliable.
</p>


<h3>Author(s)</h3>

<p>Eike Luedeling
</p>


<h3>References</h3>

<p>Model references:
</p>
<p>Chilling Hours:
</p>
<p>Weinberger JH (1950) Chilling requirements of peach varieties. Proc Am Soc
Hortic Sci 56, 122-128
</p>
<p>Bennett JP (1949) Temperature and bud rest period. Calif Agric 3 (11), 9+12
</p>
<p>Utah Model:
</p>
<p>Richardson EA, Seeley SD, Walker DR (1974) A model for estimating the
completion of rest for Redhaven and Elberta peach trees. HortScience 9(4),
331-332
</p>
<p>Dynamic Model:
</p>
<p>Erez A, Fishman S, Linsley-Noakes GC, Allan P (1990) The dynamic model for
rest completion in peach buds. Acta Hortic 276, 165-174
</p>
<p>Fishman S, Erez A, Couvillon GA (1987a) The temperature dependence of
dormancy breaking in plants - computer simulation of processes studied under
controlled temperatures. J Theor Biol 126(3), 309-321
</p>
<p>Fishman S, Erez A, Couvillon GA (1987b) The temperature dependence of
dormancy breaking in plants - mathematical analysis of a two-step model
involving a cooperative transition. J Theor Biol 124(4), 473-483
</p>
<p>Growing Degree Hours:
</p>
<p>Anderson JL, Richardson EA, Kesner CD (1986) Validation of chill unit and
flower bud phenology models for 'Montmorency' sour cherry. Acta Hortic 184,
71-78
</p>
<p>Model comparisons and model equations:
</p>
<p>Luedeling E, Zhang M, Luedeling V and Girvetz EH, 2009. Sensitivity of
winter chill models for fruit and nut trees to climatic changes expected in
California's Central Valley. Agriculture, Ecosystems and Environment 133,
23-31
</p>
<p>Luedeling E, Zhang M, McGranahan G and Leslie C, 2009. Validation of winter
chill models using historic records of walnut phenology. Agricultural and
Forest Meteorology 149, 1854-1864
</p>
<p>Luedeling E and Brown PH, 2011. A global analysis of the comparability of
winter chill models for fruit and nut trees. International Journal of
Biometeorology 55, 411-421
</p>
<p>Luedeling E, Kunz A and Blanke M, 2011. Mehr Chilling fuer Obstbaeume in
waermeren Wintern? (More winter chill for fruit trees in warmer winters?).
Erwerbs-Obstbau 53, 145-155
</p>
<p>Review on chilling models in a climate change context:
</p>
<p>Luedeling E, 2012. Climate change impacts on winter chill for temperate
fruit and nut production: a review. Scientia Horticulturae 144, 218-229
</p>
<p>The PLS method is described here:
</p>
<p>Luedeling E and Gassner A, 2012. Partial Least Squares Regression for
analyzing walnut phenology in California. Agricultural and Forest
Meteorology 158, 43-52.
</p>
<p>Wold S (1995) PLS for multivariate linear modeling. In: van der Waterbeemd H
(ed) Chemometric methods in molecular design: methods and principles in
medicinal chemistry, vol 2. Chemie, Weinheim, pp 195-218.
</p>
<p>Wold S, Sjostrom M, Eriksson L (2001) PLS-regression: a basic tool of
chemometrics. Chemometr Intell Lab 58(2), 109-130.
</p>
<p>Mevik B-H, Wehrens R, Liland KH (2011) PLS: Partial Least Squares and
Principal Component Regression. R package version 2.3-0.
http://CRAN.R-project.org/package0pls.
</p>
<p>Some applications of the PLS procedure:
</p>
<p>Luedeling E, Kunz A and Blanke M, 2013. Identification of chilling and heat
requirements of cherry trees - a statistical approach. International Journal
of Biometeorology 57,679-689.
</p>
<p>Yu H, Luedeling E and Xu J, 2010. Stronger winter than spring warming delays
spring phenology on the Tibetan Plateau. Proceedings of the National Academy
of Sciences (PNAS) 107 (51), 22151-22156.
</p>
<p>Yu H, Xu J, Okuto E and Luedeling E, 2012. Seasonal Response of Grasslands
to Climate Change on the Tibetan Plateau. PLoS ONE 7(11), e49230.
</p>
<p>The exact procedure was used here:
</p>
<p>Luedeling E, Guo L, Dai J, Leslie C, Blanke M, 2013. Differential responses
of trees to temperature variation during the chilling and forcing phases.
Agricultural and Forest Meteorology 181, 33-42.
</p>
<p>The chillR package:
</p>
<p>Luedeling E, Kunz A and Blanke M, 2013. Identification of chilling and heat
requirements of cherry trees - a statistical approach. International Journal
of Biometeorology 57,679-689.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
hourtemps &lt;- stack_hourly_temps(fix_weather(KA_weather[which(KA_weather$Year &gt; 2008), ]),
                                latitude=50.4)

CT &lt;- chilling_hourtable(hourtemps, Start_JDay = 305)

bloom_prediction(CT, Chill_req = 60, Heat_req = 5000, Chill_model = "Chill_Portions",
                 Heat_model = "GDH", Start_JDay = 305)


</code></pre>

<hr>
<h2 id='bloom_prediction2'>Bloom prediction from chilling and forcing requirements, assumed to be
fulfilled strictly in sequence - version 2</h2><span id='topic+bloom_prediction2'></span>

<h3>Description</h3>

<p>This is a pretty rudimentary function to predict phenological dates from
chilling and forcing requirements and hourly chilling and forcing data. Note
that there are enormous uncertainties in these predictions, which are hardly
ever acknowledged. So please use this function with caution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bloom_prediction2(
  HourChillTable,
  Chill_req,
  Heat_req,
  permutations = FALSE,
  Chill_model = "Chill_Portions",
  Heat_model = "GDH",
  Start_JDay = 305,
  infocol = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bloom_prediction2_+3A_hourchilltable">HourChillTable</code></td>
<td>
<p>a data frame resulting from the chilling_hourtable
function.</p>
</td></tr>
<tr><td><code id="bloom_prediction2_+3A_chill_req">Chill_req</code></td>
<td>
<p>numeric vector indicating one or multiple chilling
requirements of the particular growth stage (in the unit specified by
&quot;Chill_model&quot;)</p>
</td></tr>
<tr><td><code id="bloom_prediction2_+3A_heat_req">Heat_req</code></td>
<td>
<p>numeric vector indicating one or multiple heat requirements
of the particular growth stage (in Growing Degree Hours)</p>
</td></tr>
<tr><td><code id="bloom_prediction2_+3A_permutations">permutations</code></td>
<td>
<p>boolean parameter indicating whether all possible
combinations of the supplied chilling and heat requirements should be used.
Defaults to FALSE, which means that the function matches chilling and heat
requirements according to their positions in the Chill_req and Heat_req
vectors and only predicts stage occurrence dates for these combinations.</p>
</td></tr>
<tr><td><code id="bloom_prediction2_+3A_chill_model">Chill_model</code></td>
<td>
<p>character string specifying the chill model to use. This
has to correspond to the name of the column in HourChillTable that contains
the chill accumulation (default is &quot;Chill_Portions&quot; for units of the Dynamic
Model).</p>
</td></tr>
<tr><td><code id="bloom_prediction2_+3A_heat_model">Heat_model</code></td>
<td>
<p>character string specifying the heat model to use. This
has to correspond to the name of the column in HourChillTable that contains
the heat accumulation (e.g &quot;GDH&quot;).</p>
</td></tr>
<tr><td><code id="bloom_prediction2_+3A_start_jday">Start_JDay</code></td>
<td>
<p>numeric parameter indicating the day when chill
accumulation is supposed to start</p>
</td></tr>
<tr><td><code id="bloom_prediction2_+3A_infocol">infocol</code></td>
<td>
<p>a vector of length length(Chill_req) which contains additional
information for each element of the vector. This is preserved and included
in the output. This only works when permutation=FALSE, and is meant to
facilitate recognition of particular phenological events in the output.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is an update to the bloom_prediction function, which was
quite slow and didn't allow testing multiple chilling and heat requirements.
In this updated version, chilling and heat requirements can be supplied
as vectors, which are interpreted in sequence, with each pair of Chill_req
and Heat_req values matched according to their position in the vectors.
Through the permutations argument, it is also possible to compute stage
occurrence dates for all possible combinations of the requirements
specified by the Chill_req and Heat_req vectors.
</p>
<p>The model allows specifying any numeric column as the chill and heat columns,
indicated by the Chill_model and Heat_model parameters.
</p>


<h3>Value</h3>

<p>data frame containing the predicted Julian dates of chilling requirement
fulfillment and timing of the phenological stage. Columns are Season, Creq, Hreq,
Creq_full (day when the chilling requirement is fulfilled) and Pheno_date
(the predicted date of the phenological event).
</p>


<h3>Author(s)</h3>

<p>Eike Luedeling
</p>


<h3>References</h3>

<p>Model references:
</p>
<p>Dynamic Model:
</p>
<p>Erez A, Fishman S, Linsley-Noakes GC, Allan P (1990) The dynamic model for
rest completion in peach buds. Acta Hortic 276, 165-174
</p>
<p>Fishman S, Erez A, Couvillon GA (1987a) The temperature dependence of
dormancy breaking in plants - computer simulation of processes studied under
controlled temperatures. J Theor Biol 126(3), 309-321
</p>
<p>Fishman S, Erez A, Couvillon GA (1987b) The temperature dependence of
dormancy breaking in plants - mathematical analysis of a two-step model
involving a cooperative transition. J Theor Biol 124(4), 473-483
</p>
<p>Growing Degree Hours:
</p>
<p>Anderson JL, Richardson EA, Kesner CD (1986) Validation of chill unit and
flower bud phenology models for 'Montmorency' sour cherry. Acta Hortic 184,
71-78
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
hourtemps &lt;- stack_hourly_temps(fix_weather(KA_weather[which(KA_weather$Year &gt; 2008), ]),
                                latitude = 50.4)

CT &lt;- chilling_hourtable(hourtemps, Start_JDay = 305)

bloom_prediction2(CT, c(30, 40, 50), c(1000, 1500, 2000))
bloom_prediction2(CT, c(30, 40, 50), c(1000, 1500, 2000), permutations = TRUE)


</code></pre>

<hr>
<h2 id='bloom_prediction3'>Bloom prediction from chilling and forcing requirements, assumed to be
fulfilled strictly in sequence - version 3</h2><span id='topic+bloom_prediction3'></span>

<h3>Description</h3>

<p>This is a pretty rudimentary function to predict phenological dates from
chilling and forcing requirements and hourly chilling and forcing data. Note
that there are enormous uncertainties in these predictions, which are hardly
ever acknowledged. So please use this function with caution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bloom_prediction3(
  hourtemps,
  Chill_req,
  Heat_req,
  models = c(Chill_Portions = Dynamic_Model, GDH = GDH_model),
  permutations = FALSE,
  Chill_model = "Chill_Portions",
  Heat_model = "GDH",
  Start_JDay = 305,
  infocol = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bloom_prediction3_+3A_hourtemps">hourtemps</code></td>
<td>
<p>a data frame of hourly temperatures (e.g. resulting from
the stack_hourly_temps function - should have columns &quot;Year&quot;, &quot;Month&quot;,
&quot;Day&quot; and &quot;Temp&quot;).</p>
</td></tr>
<tr><td><code id="bloom_prediction3_+3A_chill_req">Chill_req</code></td>
<td>
<p>numeric vector indicating one or multiple chilling
requirements of the particular growth stage (in the unit specified by
&quot;Chill_model&quot;)</p>
</td></tr>
<tr><td><code id="bloom_prediction3_+3A_heat_req">Heat_req</code></td>
<td>
<p>numeric vector indicating one or multiple heat requirements
of the particular growth stage (in Growing Degree Hours)</p>
</td></tr>
<tr><td><code id="bloom_prediction3_+3A_models">models</code></td>
<td>
<p>named list of models that should be applied to the hourly
temperature data. These should be functions that take as input a vector of
hourly temperatures. This defaults to c(Chill_Portions = Dynamic_Model, GDH
= GDH_model), which refer to the Dynamic chill model and the Growing Degree
Hours model functions contained in chillR.</p>
</td></tr>
<tr><td><code id="bloom_prediction3_+3A_permutations">permutations</code></td>
<td>
<p>boolean parameter indicating whether all possible
combinations of the supplied chilling and heat requirements should be used.
Defaults to FALSE, which means that the function matches chilling and heat
requirements according to their positions in the Chill_req and Heat_req
vectors and only predicts stage occurrence dates for these combinations.</p>
</td></tr>
<tr><td><code id="bloom_prediction3_+3A_chill_model">Chill_model</code></td>
<td>
<p>character string specifying the chill model to use. This
has to correspond to the name of the column in HourChillTable that contains
the chill accumulation (default is &quot;Chill_Portions&quot; for units of the Dynamic
Model).</p>
</td></tr>
<tr><td><code id="bloom_prediction3_+3A_heat_model">Heat_model</code></td>
<td>
<p>character string specifying the heat model to use. This
has to correspond to the name of the column in HourChillTable that contains
the heat accumulation (e.g &quot;GDH&quot;).</p>
</td></tr>
<tr><td><code id="bloom_prediction3_+3A_start_jday">Start_JDay</code></td>
<td>
<p>numeric parameter indicating the day when chill
accumulation is supposed to start. Note that this is also the latest
acceptable bloom date.</p>
</td></tr>
<tr><td><code id="bloom_prediction3_+3A_infocol">infocol</code></td>
<td>
<p>a vector of length length(Chill_req) which contains additional
information for each element of the vector. This is preserved and included
in the output. This only works when permutation=FALSE, and is meant to
facilitate recognition of particular phenological events in the output.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is an update to the bloom_prediction and bloom_prediction2
functions. This version takes hourly temperatures as input rather than
requiring pre-calculated chill and heat records. This functionality is
now integrated in the function, so that users can now specify a list of
temperature metrics/models to be computed and used in the bloom prediction.
</p>


<h3>Value</h3>

<p>data frame containing the predicted Julian dates of chilling requirement
fulfillment and timing of the phenological stage. Columns are Season, Creq, Hreq,
Creq_full (day when the chilling requirement is fulfilled) and Pheno_date
(the predicted date of the phenological event).
</p>


<h3>Author(s)</h3>

<p>Eike Luedeling
</p>


<h3>References</h3>

<p>Model references:
</p>
<p>Dynamic Model:
</p>
<p>Erez A, Fishman S, Linsley-Noakes GC, Allan P (1990) The dynamic model for
rest completion in peach buds. Acta Hortic 276, 165-174
</p>
<p>Fishman S, Erez A, Couvillon GA (1987a) The temperature dependence of
dormancy breaking in plants - computer simulation of processes studied under
controlled temperatures. J Theor Biol 126(3), 309-321
</p>
<p>Fishman S, Erez A, Couvillon GA (1987b) The temperature dependence of
dormancy breaking in plants - mathematical analysis of a two-step model
involving a cooperative transition. J Theor Biol 124(4), 473-483
</p>
<p>Growing Degree Hours:
</p>
<p>Anderson JL, Richardson EA, Kesner CD (1986) Validation of chill unit and
flower bud phenology models for 'Montmorency' sour cherry. Acta Hortic 184,
71-78
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
hourtemps &lt;- stack_hourly_temps(fix_weather(KA_weather[which(KA_weather$Year &gt; 2007), ]),
                                latitude = 50.4)

bloom_prediction3(hourtemps, c(30, 140, 50), c(1000, 1500, 2000))

bloom_prediction3(hourtemps, c(30, 40, 50), c(1000, 1500, 2000), permutations = TRUE,
                  Start_JDay = 1)

bloom_prediction3(hourtemps, c(300, 400, 600), c(100, 150, 200), permutations = TRUE,
                  Start_JDay = 1, models = c(CH = Chilling_Hours, Heat = GDD),
                  Chill_model = "CH", Heat_model = "Heat")

</code></pre>

<hr>
<h2 id='bootstrap.phenologyFit'>bootstrap.phenologyFit</h2><span id='topic+bootstrap.phenologyFit'></span>

<h3>Description</h3>

<p>This function bootstraps the residuals of a 'phenologyFit'. It
internally calls 'phenologyFitter' on each bootstrap
replicate.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bootstrap.phenologyFit(
  object,
  boot.R = 99,
  control = list(smooth = FALSE, verbose = FALSE, maxit = 1000, nb.stop.improvement =
    250),
  lower,
  upper,
  seed = 1766588
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bootstrap.phenologyFit_+3A_object">object</code></td>
<td>
<p>class 'phenologyFit', the object to bootstrap</p>
</td></tr>
<tr><td><code id="bootstrap.phenologyFit_+3A_boot.r">boot.R</code></td>
<td>
<p>integer. The number of bootstrap replicates</p>
</td></tr>
<tr><td><code id="bootstrap.phenologyFit_+3A_control">control</code></td>
<td>
<p>control parameters to 'GenSA', see 'GenSA::GenSA'</p>
</td></tr>
<tr><td><code id="bootstrap.phenologyFit_+3A_lower">lower</code></td>
<td>
<p>Vector with length of ‘par.guess’. Lower bounds for components.</p>
</td></tr>
<tr><td><code id="bootstrap.phenologyFit_+3A_upper">upper</code></td>
<td>
<p>Vector with length of ‘par.guess’. Upper bounds for components.
If missing, 'upper' in 'object' is used.</p>
</td></tr>
<tr><td><code id="bootstrap.phenologyFit_+3A_seed">seed</code></td>
<td>
<p>integer seed for the random number generator used by 'GenSA'.
If missing, 'lower' in 'object' is used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>bootstrap an object of S3 class 'phenologyFit'
</p>


<h3>Value</h3>

<p>Invisibly returns a list with elements 'boot.R', 'object', 'seed', 'residuals',
'lower', 'upper', and 'res'. The latter list 'res' has 'boot.R' elements, which
are lists again. Each of these lists contains named elements 'par', 'value',
'bloomJDays', and 'pbloomJDays'. 'par' are the best fit parameters on the particular bootstrap 
replicate, 'value' the corresponding RSS, 'bloomJDays' the re-sampled data and 'pbloomJDays'
the predicted bloom JDays for this sample.
</p>


<h3>Author(s)</h3>

<p>Carsten Urbach &lt;urbach@hiskp.uni-bonn.de&gt;
</p>

<hr>
<h2 id='c.bootstrap_phenologyFit'>Concatenate bootstrap_phenologyfit objects</h2><span id='topic+c.bootstrap_phenologyFit'></span>

<h3>Description</h3>

<p>Concatenate bootstrap_phenologyfit objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bootstrap_phenologyFit'
c(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="c.bootstrap_phenologyFit_+3A_...">...</code></td>
<td>
<p>Zero or multiple objects of type 'bootstrap_phenologyfit'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class 'bootstrap_phenologyFit', the concatenation of the
list of input object.
</p>

<hr>
<h2 id='california_stations'>Weather stations in California</h2><span id='topic+california_stations'></span>

<h3>Description</h3>

<p>This is a list of weather stations in California that are contained in the
UC IPM database. This can also be generated with
make_california_UCIPM_station_list(), but this takes quite a while. So this
dataset is supposed to be a shortcut to this.
</p>


<h3>Format</h3>

<p>a data.frame containing stations from the California UC IPM database
(), with the columns: &quot;Name&quot;, &quot;Code&quot;, &quot;Interval&quot;, &quot;Lat&quot;, &quot;Long&quot;,
&quot;Elev&quot;.  </p>
 <dl>
<dt>list(&quot;Name&quot;)</dt><dd><p>name of the weather station</p>
</dd>
<dt>list(&quot;Code&quot;)</dt><dd><p> code of the weather station, indicating the name and
the database it comes from</p>
</dd> <dt>list(&quot;Interval&quot;)</dt><dd><p> period of available
data (as character string)</p>
</dd> <dt>list(&quot;Lat&quot;)</dt><dd><p> latitude of the station</p>
</dd>
<dt>list(&quot;Long&quot;)</dt><dd><p> longitude of the station</p>
</dd> <dt>list(&quot;Elev&quot;)</dt><dd>
<p>elevation of the station</p>
</dd> </dl>



<h3>Source</h3>

<p>UC IPM website: http://www.ipm.ucdavis.edu/WEATHER/index.html
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(california_stations)

</code></pre>

<hr>
<h2 id='check_temperature_record'>Check a daily or hourly temperature record for compliance with chillR's standards</h2><span id='topic+check_temperature_record'></span>

<h3>Description</h3>

<p>This function performs basic tests to determine whether a temperature record
complies with chillR's formatting rules. If desired, the function also checks
whether the record is complete (has rows for all time units in the interval)
and how many values are missing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_temperature_record(
  weather,
  hourly = FALSE,
  completeness_check = TRUE,
  no_variable_check = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_temperature_record_+3A_weather">weather</code></td>
<td>
<p>object to be tested for whether it contains chillR-compatible
temperature data.</p>
</td></tr>
<tr><td><code id="check_temperature_record_+3A_hourly">hourly</code></td>
<td>
<p>boolean parameter indicating whether temp_record contains hourly
data. If not, it is assumed to consist of daily records (the default).</p>
</td></tr>
<tr><td><code id="check_temperature_record_+3A_completeness_check">completeness_check</code></td>
<td>
<p>boolean parameter indicating whether the records should be
checked for completeness.</p>
</td></tr>
<tr><td><code id="check_temperature_record_+3A_no_variable_check">no_variable_check</code></td>
<td>
<p>boolean parameter to indicate whether the function should
check if the dataset contains the usual chillR temperature variables. Defaults to
TRUE, but should be set to FALSE for different data formats.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list containing the following elements: 'data_frequency' (&quot;daily or &quot;hourly),
'weather_object' (boolean, indicates whether records are in a sub-object called weather),
'chillR_compliant' (boolean, indicates whether the object was found to conform to
chillR format standards) and 'error' (contains error messages generated during the
checking procedure).
</p>


<h3>Note</h3>

<p>This function doesn't check whether there are faulty data. It only tests
whether the data is compatible with the requirements of chillR's major functions.
</p>


<h3>Author(s)</h3>

<p>Eike Luedeling
</p>


<h3>References</h3>

<p>The chillR package:
</p>
<p>Luedeling E, Kunz A and Blanke M, 2013. Identification of chilling and heat
requirements of cherry trees - a statistical approach. International Journal
of Biometeorology 57,679-689.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
check_temperature_record(KA_weather)

</code></pre>

<hr>
<h2 id='check_temperature_scenario'>Check temperature scenario for consistency</h2><span id='topic+check_temperature_scenario'></span>

<h3>Description</h3>

<p>chillR's temperature generation procedures require absolute or relative temperature scenarios.
This function checks these scenarios for consistency, regarding the data format, the reference
year, and whether they are relative or absolute scenarios (based on specified criteria).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_temperature_scenario(
  temperature_scenario,
  n_intervals = 12,
  check_scenario_type = TRUE,
  scenario_check_thresholds = c(-5, 10),
  update_scenario_type = TRUE,
  warn_me = TRUE,
  required_variables = c("Tmin", "Tmax")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_temperature_scenario_+3A_temperature_scenario">temperature_scenario</code></td>
<td>
<p>can be one of two options:
1) a data.frame with two columns Tmin and Tmax and n_intervals (default: 12) rows containing
temperature changes for all time intervals, or absolute temperatures for these intervals.
2) a temperature scenario object, consisting of the following elements: 'data' = a data frame with
n_intervals elements containing the absolute or relative temperature information (as in input option 1);
'scenario_year' = the year the scenario is representative of; 'reference_year' = the year the scenario is representative of; 'scenario_type' = the scenario type
('absolute' or 'relative' - if NA, this is assigned automatically); 'labels' = and elements
attached to the input temperature_scenario as an element names 'labels'. A subset of these elements can
also be specified, but 'data' must be present.</p>
</td></tr>
<tr><td><code id="check_temperature_scenario_+3A_n_intervals">n_intervals</code></td>
<td>
<p>the number of time intervals specified in the temperature scenarios. This
is often the number of months in a year, so the default is 12. If the temperature scenario is
specified for a different number of time intervals, this should be adjusted.</p>
</td></tr>
<tr><td><code id="check_temperature_scenario_+3A_check_scenario_type">check_scenario_type</code></td>
<td>
<p>boolean variable indicating whether the specified (or unspecified)
scenario type should be verified, i.e. whether the scenario is a relative or absolute temperature
scenario.</p>
</td></tr>
<tr><td><code id="check_temperature_scenario_+3A_scenario_check_thresholds">scenario_check_thresholds</code></td>
<td>
<p>vector with two numeric elements specifying the thresholds
for checking whether the scenario is an absolute or relative temperature scenario. These are the
minimum (first value) and maximum (second value) plausible changes in a relative temperature
scenario. The test only works in settings where either the lowest mean minimum temperature
across all time intervals is below the stated minimum threshold or the highest mean maximum
temperature across all time intervals is above the maximum threshold. With the default values
c(-5,10), this should be the case for most locations on Earth, but in extreme cases (either for
extreme change scenarios or where all monthly minimum and maximum temperatures are between -5
and 10 degrees), this may need adjustment. This is only used if check_scenario_type==TRUE.</p>
</td></tr>
<tr><td><code id="check_temperature_scenario_+3A_update_scenario_type">update_scenario_type</code></td>
<td>
<p>boolean variable stating whether, if scenario type is found to be
inconsistent with the numbers, the scenario_type should be updated. Defaults to TRUE and is only
used if check_scenario_type==TRUE.</p>
</td></tr>
<tr><td><code id="check_temperature_scenario_+3A_warn_me">warn_me</code></td>
<td>
<p>boolean variable specifying whether warnings should be shown. Defaults to TRUE.</p>
</td></tr>
<tr><td><code id="check_temperature_scenario_+3A_required_variables">required_variables</code></td>
<td>
<p>character vector containing the names of columns that are required.
This defaults to c(&quot;Tmin&quot;,&quot;Tmax&quot;).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Besides being able to validate classic temperature scenarios consisting of &quot;Tmin&quot; and &quot;Tmax&quot;
data, the function can also validate other datasets (e.g. outputs of the getClimateWizardData
function). To do this, the required variables should be provided as &quot;required_variables&quot; parameter.
If there is no column &quot;GCM&quot; in the data element of the scenario, then the check_scenario_type
parameter should be set to FALSE.
</p>


<h3>Value</h3>

<p>temperature scenario object, consisting of the following elements: 'data' = a data frame with
n_intervals elements containing the absolute or relative temperature information. 'reference_year' =
the year the scenario is representative of. 'scenario_type' = the scenario type ('absolute' or 'relative');
'labels' = and elements attached to the input temperature_scenario as an element names 'labels'.
</p>
<p>The function also returns warnings, where elements are missing or the scenario_type appears to be
wrong, and it stops with an error, if the scenario isn't specified in a format that is usable by
chillR.
</p>


<h3>Author(s)</h3>

<p>Eike Luedeling
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
temperature_scenario &lt;- list(data = data.frame(Tmin = c(-5, -2, 0, 4, 9, 12,
                                                        15, 13, 12, 9, 4, 0),
                                               Tmax = c(0, 4, 8, 12, 15, 18,
                                                        21, 19, 17, 14, 11, 5)),
                             reference_year = 1975,
                             scenario_type = "absolute",
                             labels = list(GCM = "none",
                                           RCM = "none",
                                           Time = "1950-2000"))

checked_temperature_scenario &lt;- 
        check_temperature_scenario(temperature_scenario,
                                   n_intervals = 12,
                                   check_scenario_type = FALSE,
                                   scenario_check_thresholds = c(-5, 10),
                                   update_scenario_type = FALSE)
                                            
checked_temperature_scenario &lt;-
        check_temperature_scenario(temperature_scenario,
                                   n_intervals = 12,
                                   check_scenario_type = TRUE,
                                   scenario_check_thresholds = c(-5, 10),
                                   update_scenario_type = FALSE)
                                            
checked_temperature_scenario &lt;-
        check_temperature_scenario(temperature_scenario,
                                   n_intervals = 12,
                                   check_scenario_type = TRUE,
                                   scenario_check_thresholds = c(-5, 10),
                                   update_scenario_type = TRUE)                                             
                                            
 
</code></pre>

<hr>
<h2 id='chifull'>chifull</h2><span id='topic+chifull'></span>

<h3>Description</h3>

<p>RSS to minimise by 'phenologyFitter'
</p>


<h3>Usage</h3>

<pre><code class='language-R'>chifull(par, modelfn, bloomJDays, SeasonList, na_penalty = 365, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="chifull_+3A_par">par</code></td>
<td>
<p>numeric. vector of fit parameters</p>
</td></tr>
<tr><td><code id="chifull_+3A_modelfn">modelfn</code></td>
<td>
<p>function. model function</p>
</td></tr>
<tr><td><code id="chifull_+3A_bloomjdays">bloomJDays</code></td>
<td>
<p>numeric. vector of bloom hours! per year</p>
</td></tr>
<tr><td><code id="chifull_+3A_seasonlist">SeasonList</code></td>
<td>
<p>list. list of index vectors per year.</p>
</td></tr>
<tr><td><code id="chifull_+3A_na_penalty">na_penalty</code></td>
<td>
<p>numeric. penalty value for the residual if the model returns 'NA'.</p>
</td></tr>
<tr><td><code id="chifull_+3A_...">...</code></td>
<td>
<p>further parameters to pass on to 'modelfn'.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>function to compute the RSS
</p>

<hr>
<h2 id='chile_agromet2chillR'>Convert a weather file downloaded from the Chilean Agromet website to chillR
format</h2><span id='topic+chile_agromet2chillR'></span>

<h3>Description</h3>

<p>Convert downloaded weather data into a data frame that makes running other
chillR functions easy.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>chile_agromet2chillR(downloaded_weather_file, drop_most = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="chile_agromet2chillR_+3A_downloaded_weather_file">downloaded_weather_file</code></td>
<td>
<p>full path of a weather file downloaded from
the <a href="https://agromet.inia.cl/">Chilean Agromet website</a> as an alleged Excel
file (it has some formatting issues).</p>
</td></tr>
<tr><td><code id="chile_agromet2chillR_+3A_drop_most">drop_most</code></td>
<td>
<p>boolean variable indicating if most columns should be
dropped from the file. If set to TRUE (default), only essential columns for
running chillR functions are retained.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Processing the data with this function will make the data work well with the
remainder of this package.
</p>


<h3>Value</h3>

<p>a data.frame with weather data, according to the downloaded file
provided as input. If drop_most is FALSE, all columns from the original
dataset are preserved, although some column names are adjusted to chillR's
preferences (&quot;Year&quot;,&quot;Month&quot;,&quot;Day&quot;,&quot;Tmin&quot;,&quot;Tmax&quot;,&quot;Tmean&quot;,&quot;Prec&quot;, if these
columns are present). If drop_most is TRUE, only columns likely to be of
interest to chillR users are retained.
</p>


<h3>Note</h3>

<p>Many databases have data quality flags, which may sometimes indicate
that data aren't reliable. These are not considered by this function!
</p>


<h3>Author(s)</h3>

<p>Eike Luedeling
</p>


<h3>References</h3>

<p>The chillR package:
</p>
<p>Luedeling E, Kunz A and Blanke M, 2013. Identification of chilling and heat
requirements of cherry trees - a statistical approach. International Journal
of Biometeorology 57,679-689.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
weather&lt;-fix_weather(KA_weather[which(KA_weather$Year&gt;2005),])  # this line is
#only here to make the example run, even without downloading a file

# FOLLOW THE INSTRUCTIONS IN THE LINE BELOW THIS; AND THEN  RUN THE LINE
# AFTER THAT (without the #)
# download an Excel file from the website and save it to disk (path: {X}) 
#weather&lt;-fix_weather(chile_agromet2chillR({x}))

hourtemps&lt;-stack_hourly_temps(weather, latitude=50.4)
chilling(hourtemps,305,60)

</code></pre>

<hr>
<h2 id='chilling'>Calculation of chilling and heat from hourly temperature records</h2><span id='topic+chilling'></span>

<h3>Description</h3>

<p>Function to calculate three common horticultural chill metrics and one heat
metric from stacked hourly temperatures (produced by stack_hourly_temps).
Metrics that are calculated are Chilling Hours, Chill Units according to the
Utah Model, Chill Portions according to the Dynamic Model and Growing Degree
Hours.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>chilling(
  hourtemps = NULL,
  Start_JDay = 1,
  End_JDay = 366,
  THourly = NULL,
  misstolerance = 50
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="chilling_+3A_hourtemps">hourtemps</code></td>
<td>
<p>a list of two elements, with element 'hourtemps' being a
dataframe of hourly temperatures (e.g. produced by stack_hourly_temps). This
data frame must have a column for Year, a column for JDay (Julian date, or
day of the year), a column for Hour and a column for Temp (hourly
temperature). The second (optional) element is QC, which is a data.frame
indicating completeness of the dataset. This is automatically produced by
stack_hourly_temps.</p>
</td></tr>
<tr><td><code id="chilling_+3A_start_jday">Start_JDay</code></td>
<td>
<p>the start date (in Julian date, or day of the year) of the
period, for which chill and heat should be quantified.</p>
</td></tr>
<tr><td><code id="chilling_+3A_end_jday">End_JDay</code></td>
<td>
<p>the end date (in Julian date, or day of the year) of the
period, for which chill and heat should be quantified.</p>
</td></tr>
<tr><td><code id="chilling_+3A_thourly">THourly</code></td>
<td>
<p>the same as hourtemps. This argument is only retained for
downward compatibility and can be ignored in most cases.</p>
</td></tr>
<tr><td><code id="chilling_+3A_misstolerance">misstolerance</code></td>
<td>
<p>maximum percentage of values for a given season that
can be missing without the record being removed from the output. Defaults to
50.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Chill metrics are calculated as given in the references below. Chilling
Hours are all hours with temperatures between 0 and 7.2 degrees C. Units of
the Utah Model are calculated as suggested by Richardson et al. (1974)
(different weights for different temperature ranges, and negation of
chilling by warm temperatures). Chill Portions are calculated according to
Fishman et al. (1987a,b). More honestly, they are calculated according to an
Excel sheet produced by Amnon Erez and colleagues, which converts the
complex equations in the Fishman papers into relatively simple Excel
functions. These were translated into R. References to papers that include
the full functions are given below. Growing Degree Hours are calculated
according to Anderson et al. (1986), using the default values they suggest.
</p>


<h3>Value</h3>

<p>data frame showing chilling and heat totals for the respective
periods for all seasons included in the temperature records. Columns are
Season, End_year (the year when the period ended), Days (the duration of the
period), Chilling_Hours, Utah_Model, Chill_portions and GDH. If the weather
input consisted of a list with elements hourtemps and QC, the output also
contains columns from QC that indicate the completeness of the weather
record that the calculations are based on.
</p>


<h3>Note</h3>

<p>After doing extensive model comparisons, and reviewing a lot of
relevant literature, I do not recommend using the Chilling Hours or Utah
Models, especially in warm climates! The Dynamic Model (Chill Portions),
though far from perfect, seems much more reliable.
</p>


<h3>Author(s)</h3>

<p>Eike Luedeling
</p>


<h3>References</h3>

<p>Model references:
</p>
<p>Chilling Hours:
</p>
<p>Weinberger JH (1950) Chilling requirements of peach varieties. Proc Am Soc
Hortic Sci 56, 122-128
</p>
<p>Bennett JP (1949) Temperature and bud rest period. Calif Agric 3 (11), 9+12
</p>
<p>Utah Model:
</p>
<p>Richardson EA, Seeley SD, Walker DR (1974) A model for estimating the
completion of rest for Redhaven and Elberta peach trees. HortScience 9(4),
331-332
</p>
<p>Dynamic Model:
</p>
<p>Erez A, Fishman S, Linsley-Noakes GC, Allan P (1990) The dynamic model for
rest completion in peach buds. Acta Hortic 276, 165-174
</p>
<p>Fishman S, Erez A, Couvillon GA (1987a) The temperature dependence of
dormancy breaking in plants - computer simulation of processes studied under
controlled temperatures. J Theor Biol 126(3), 309-321
</p>
<p>Fishman S, Erez A, Couvillon GA (1987b) The temperature dependence of
dormancy breaking in plants - mathematical analysis of a two-step model
involving a cooperative transition. J Theor Biol 124(4), 473-483
</p>
<p>Growing Degree Hours:
</p>
<p>Anderson JL, Richardson EA, Kesner CD (1986) Validation of chill unit and
flower bud phenology models for 'Montmorency' sour cherry. Acta Hortic 184,
71-78
</p>
<p>Model comparisons and model equations:
</p>
<p>Luedeling E, Zhang M, Luedeling V and Girvetz EH, 2009. Sensitivity of
winter chill models for fruit and nut trees to climatic changes expected in
California's Central Valley. Agriculture, Ecosystems and Environment 133,
23-31
</p>
<p>Luedeling E, Zhang M, McGranahan G and Leslie C, 2009. Validation of winter
chill models using historic records of walnut phenology. Agricultural and
Forest Meteorology 149, 1854-1864
</p>
<p>Luedeling E and Brown PH, 2011. A global analysis of the comparability of
winter chill models for fruit and nut trees. International Journal of
Biometeorology 55, 411-421
</p>
<p>Luedeling E, Kunz A and Blanke M, 2011. Mehr Chilling fuer Obstbaeume in
waermeren Wintern? (More winter chill for fruit trees in warmer winters?).
Erwerbs-Obstbau 53, 145-155
</p>
<p>Review on chilling models in a climate change context:
</p>
<p>Luedeling E, 2012. Climate change impacts on winter chill for temperate
fruit and nut production: a review. Scientia Horticulturae 144, 218-229
</p>
<p>The PLS method is described here:
</p>
<p>Luedeling E and Gassner A, 2012. Partial Least Squares Regression for
analyzing walnut phenology in California. Agricultural and Forest
Meteorology 158, 43-52.
</p>
<p>Wold S (1995) PLS for multivariate linear modeling. In: van der Waterbeemd H
(ed) Chemometric methods in molecular design: methods and principles in
medicinal chemistry, vol 2. Chemie, Weinheim, pp 195-218.
</p>
<p>Wold S, Sjostrom M, Eriksson L (2001) PLS-regression: a basic tool of
chemometrics. Chemometr Intell Lab 58(2), 109-130.
</p>
<p>Mevik B-H, Wehrens R, Liland KH (2011) PLS: Partial Least Squares and
Principal Component Regression. R package version 2.3-0.
http://CRAN.R-project.org/package0pls.
</p>
<p>Some applications of the PLS procedure:
</p>
<p>Luedeling E, Kunz A and Blanke M, 2013. Identification of chilling and heat
requirements of cherry trees - a statistical approach. International Journal
of Biometeorology 57,679-689.
</p>
<p>Yu H, Luedeling E and Xu J, 2010. Stronger winter than spring warming delays
spring phenology on the Tibetan Plateau. Proceedings of the National Academy
of Sciences (PNAS) 107 (51), 22151-22156.
</p>
<p>Yu H, Xu J, Okuto E and Luedeling E, 2012. Seasonal Response of Grasslands
to Climate Change on the Tibetan Plateau. PLoS ONE 7(11), e49230.
</p>
<p>The exact procedure was used here:
</p>
<p>Luedeling E, Guo L, Dai J, Leslie C, Blanke M, 2013. Differential responses
of trees to temperature variation during the chilling and forcing phases.
Agricultural and Forest Meteorology 181, 33-42.
</p>
<p>The chillR package:
</p>
<p>Luedeling E, Kunz A and Blanke M, 2013. Identification of chilling and heat
requirements of cherry trees - a statistical approach. International Journal
of Biometeorology 57,679-689.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# weather &lt;- fix_weather(KA_weather[which(KA_weather$Year &gt; 2006), ])
# hourtemps &lt;- stack_hourly_temps(weather, latitude = 50.4)
# chilling(hourtemps, 305, 60)

chilling(stack_hourly_temps(fix_weather(KA_weather[which(KA_weather$Year &gt; 2006), ]),
         latitude = 50.4))

</code></pre>

<hr>
<h2 id='Chilling_Hours'>Calculation of cumulative chill according to the Chilling Hours Model</h2><span id='topic+Chilling_Hours'></span>

<h3>Description</h3>

<p>This function calculates winter chill for temperate trees according to the
Chilling Hours Model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Chilling_Hours(HourTemp, summ = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Chilling_Hours_+3A_hourtemp">HourTemp</code></td>
<td>
<p>Vector of hourly temperatures.</p>
</td></tr>
<tr><td><code id="Chilling_Hours_+3A_summ">summ</code></td>
<td>
<p>Boolean parameter indicating whether calculated metrics should
be provided as cumulative values over the entire record (TRUE) or as the
actual accumulation for each hour (FALSE).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Chilling Hours are calculated as suggested by Bennett (1949) (all hours with
temperatures between 0 and 7.2 degrees C are considered as one Chilling
Hour.
</p>


<h3>Value</h3>

<p>Vector of length length(HourTemp) containing the cumulative Chilling
Hours over the entire duration of HourTemp.
</p>


<h3>Note</h3>

<p>After doing extensive model comparisons, and reviewing a lot of
relevant literature, I do not recommend using the Chilling Hours, especially
in warm climates! The Dynamic Model (Chill Portions), though far from
perfect, seems much more reliable.
</p>


<h3>Author(s)</h3>

<p>Eike Luedeling
</p>


<h3>References</h3>

<p>Chilling Hours references:
</p>
<p>Weinberger JH (1950) Chilling requirements of peach varieties. Proc Am Soc
Hortic Sci 56, 122-128
</p>
<p>Bennett JP (1949) Temperature and bud rest period. Calif Agric 3 (11), 9+12
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

weather&lt;-fix_weather(KA_weather[which(KA_weather$Year&gt;2006),])

hourtemps&lt;-stack_hourly_temps(weather,latitude=50.4)

Chilling_Hours(hourtemps$hourtemps$Temp)

</code></pre>

<hr>
<h2 id='chilling_hourtable'>Add chilling and heat accumulation to table of hourly temperatures</h2><span id='topic+chilling_hourtable'></span>

<h3>Description</h3>

<p>This function calculates cumulative values for three chill metrics and one
heat metric for every hour of an hourly temperature record. The count is
restarted on a specified date each year.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>chilling_hourtable(hourtemps, Start_JDay)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="chilling_hourtable_+3A_hourtemps">hourtemps</code></td>
<td>
<p>a dataframe of stacked hourly temperatures (e.g. produced
by stack_hourly_temps). This data frame must have a column for Year, a
column for JDay (Julian date, or day of the year), a column for Hour and a
column for Temp (hourly temperature).</p>
</td></tr>
<tr><td><code id="chilling_hourtable_+3A_start_jday">Start_JDay</code></td>
<td>
<p>the start date (in Julian date, or day of the year) of the
calculation for the four metrics. The count is restarted on this date every
year.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Chill metrics are calculated as given in the references below. Chilling
Hours are all hours with temperatures between 0 and 7.2 degrees C. Units of
the Utah Model are calculated as suggested by Richardson et al. (1974)
(different weights for different temperature ranges, and negation of
chilling by warm temperatures). Chill Portions are calculated according to
Fishman et al. (1987a,b). More honestly, they are calculated according to an
Excel sheet produced by Amnon Erez and colleagues, which converts the
complex equations in the Fishman papers into relatively simple Excel
functions. These were translated into R. References to papers that include
the full functions are given below. Growing Degree Hours are calculated
according to Anderson et al. (1986), using the default values they suggest.
</p>


<h3>Value</h3>

<p>data frame consisting of all the columns of the THourly input data
frame, plus the following additional columns: Chilling_Hours (cumulative
number of Chilling Hours since the last Start_JDay), Chill_Portions (same
for units of the Dynamic Models), Chill_Units (same for units of the Utah
Model) and GDH (same for Growing Degree Hours).
</p>


<h3>Note</h3>

<p>After doing extensive model comparisons, and reviewing a lot of
relevant literature, I do not recommend using the Chilling Hours or Utah
Models, especially in warm climates! The Dynamic Model (Chill Portions),
though far from perfect, seems much more reliable.
</p>


<h3>Author(s)</h3>

<p>Eike Luedeling
</p>


<h3>References</h3>

<p>Model references:
</p>
<p>Chilling Hours:
</p>
<p>Weinberger JH (1950) Chilling requirements of peach varieties. Proc Am Soc
Hortic Sci 56, 122-128
</p>
<p>Bennett JP (1949) Temperature and bud rest period. Calif Agric 3 (11), 9+12
</p>
<p>Utah Model:
</p>
<p>Richardson EA, Seeley SD, Walker DR (1974) A model for estimating the
completion of rest for Redhaven and Elberta peach trees. HortScience 9(4),
331-332
</p>
<p>Dynamic Model:
</p>
<p>Erez A, Fishman S, Linsley-Noakes GC, Allan P (1990) The dynamic model for
rest completion in peach buds. Acta Hortic 276, 165-174
</p>
<p>Fishman S, Erez A, Couvillon GA (1987a) The temperature dependence of
dormancy breaking in plants - computer simulation of processes studied under
controlled temperatures. J Theor Biol 126(3), 309-321
</p>
<p>Fishman S, Erez A, Couvillon GA (1987b) The temperature dependence of
dormancy breaking in plants - mathematical analysis of a two-step model
involving a cooperative transition. J Theor Biol 124(4), 473-483
</p>
<p>Growing Degree Hours:
</p>
<p>Anderson JL, Richardson EA, Kesner CD (1986) Validation of chill unit and
flower bud phenology models for 'Montmorency' sour cherry. Acta Hortic 184,
71-78
</p>
<p>Model comparisons and model equations:
</p>
<p>Luedeling E, Zhang M, Luedeling V and Girvetz EH, 2009. Sensitivity of
winter chill models for fruit and nut trees to climatic changes expected in
California's Central Valley. Agriculture, Ecosystems and Environment 133,
23-31
</p>
<p>Luedeling E, Zhang M, McGranahan G and Leslie C, 2009. Validation of winter
chill models using historic records of walnut phenology. Agricultural and
Forest Meteorology 149, 1854-1864
</p>
<p>Luedeling E and Brown PH, 2011. A global analysis of the comparability of
winter chill models for fruit and nut trees. International Journal of
Biometeorology 55, 411-421
</p>
<p>Luedeling E, Kunz A and Blanke M, 2011. Mehr Chilling fuer Obstbaeume in
waermeren Wintern? (More winter chill for fruit trees in warmer winters?).
Erwerbs-Obstbau 53, 145-155
</p>
<p>Review on chilling models in a climate change context:
</p>
<p>Luedeling E, 2012. Climate change impacts on winter chill for temperate
fruit and nut production: a review. Scientia Horticulturae 144, 218-229
</p>
<p>The PLS method is described here:
</p>
<p>Luedeling E and Gassner A, 2012. Partial Least Squares Regression for
analyzing walnut phenology in California. Agricultural and Forest
Meteorology 158, 43-52.
</p>
<p>Wold S (1995) PLS for multivariate linear modeling. In: van der Waterbeemd H
(ed) Chemometric methods in molecular design: methods and principles in
medicinal chemistry, vol 2. Chemie, Weinheim, pp 195-218.
</p>
<p>Wold S, Sjostrom M, Eriksson L (2001) PLS-regression: a basic tool of
chemometrics. Chemometr Intell Lab 58(2), 109-130.
</p>
<p>Mevik B-H, Wehrens R, Liland KH (2011) PLS: Partial Least Squares and
Principal Component Regression. R package version 2.3-0.
http://CRAN.R-project.org/package0pls.
</p>
<p>Some applications of the PLS procedure:
</p>
<p>Luedeling E, Kunz A and Blanke M, 2013. Identification of chilling and heat
requirements of cherry trees - a statistical approach. International Journal
of Biometeorology 57,679-689.
</p>
<p>Yu H, Luedeling E and Xu J, 2010. Stronger winter than spring warming delays
spring phenology on the Tibetan Plateau. Proceedings of the National Academy
of Sciences (PNAS) 107 (51), 22151-22156.
</p>
<p>Yu H, Xu J, Okuto E and Luedeling E, 2012. Seasonal Response of Grasslands
to Climate Change on the Tibetan Plateau. PLoS ONE 7(11), e49230.
</p>
<p>The exact procedure was used here:
</p>
<p>Luedeling E, Guo L, Dai J, Leslie C, Blanke M, 2013. Differential responses
of trees to temperature variation during the chilling and forcing phases.
Agricultural and Forest Meteorology 181, 33-42.
</p>
<p>The chillR package:
</p>
<p>Luedeling E, Kunz A and Blanke M, 2013. Identification of chilling and heat
requirements of cherry trees - a statistical approach. International Journal
of Biometeorology 57,679-689.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
weather&lt;-fix_weather(KA_weather[which(KA_weather$Year&gt;2008),])

hourtemps&lt;-stack_hourly_temps(weather,latitude=50.4)

cht&lt;-chilling_hourtable(hourtemps,20)

</code></pre>

<hr>
<h2 id='ChuineCF'>ChuineCF</h2><span id='topic+ChuineCF'></span>

<h3>Description</h3>

<p>chilling and forcing response function for
the unified model by Chuine
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ChuineCF(x, a, b, c)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ChuineCF_+3A_x">x</code></td>
<td>
<p>temperature</p>
</td></tr>
<tr><td><code id="ChuineCF_+3A_a">a</code></td>
<td>
<p>numeric. paramter</p>
</td></tr>
<tr><td><code id="ChuineCF_+3A_b">b</code></td>
<td>
<p>numeric. paramter</p>
</td></tr>
<tr><td><code id="ChuineCF_+3A_c">c</code></td>
<td>
<p>numeric. paramter</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a numeric vector.
</p>


<h3>References</h3>

<p>Isabelle Chuine, A Unified Model for Budburst of Trees, J. theor. Biol. (2000) 207
</p>

<hr>
<h2 id='ChuineFstar'>ChuineFstar</h2><span id='topic+ChuineFstar'></span>

<h3>Description</h3>

<p>Critical forcing value
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ChuineFstar(Ctot, w, k)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ChuineFstar_+3A_ctot">Ctot</code></td>
<td>
<p>numeric. total state of chilling</p>
</td></tr>
<tr><td><code id="ChuineFstar_+3A_w">w</code></td>
<td>
<p>numeric &gt; 0. parameter.</p>
</td></tr>
<tr><td><code id="ChuineFstar_+3A_k">k</code></td>
<td>
<p>numeric &lt; 0. parameter.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a numeric vector.
</p>


<h3>References</h3>

<p>Isabelle Chuine, A Unified Model for Budburst of Trees, J. theor. Biol. (2000) 207
</p>

<hr>
<h2 id='color_bar_maker'>Make color scheme for bar plots in outputs of the chillR package</h2><span id='topic+color_bar_maker'></span>

<h3>Description</h3>

<p>Function to make color schemes for color bar plots in the chillR package.
Colors are assigned based on values in two columns of a data frame. One
column contains a threshold, below which col3 is assigned. If values are
above the threshold, the value in the other column determines the color:
col1 if the value is negative, col2 if positive. This function is useful for
making the PLS output figures in the chillR package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>color_bar_maker(column_yn, column_quant, threshold, col1, col2, col3)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="color_bar_maker_+3A_column_yn">column_yn</code></td>
<td>
<p>numeric vector containing the data, on which the threshold
is to be applied. In the case of the PLS output, this is the data from the
VIP column.</p>
</td></tr>
<tr><td><code id="color_bar_maker_+3A_column_quant">column_quant</code></td>
<td>
<p>numeric vector containing the data that determines
whether items from column_yn that are above the threshold get assigned col1
or col2.</p>
</td></tr>
<tr><td><code id="color_bar_maker_+3A_threshold">threshold</code></td>
<td>
<p>threshold for values from column_yn to be used for deciding
which bars should get col3 and which ones should move on to the next
decision step (col1 or col2)</p>
</td></tr>
<tr><td><code id="color_bar_maker_+3A_col1">col1</code></td>
<td>
<p>a color (either a color name or a number) this is applied where
column_yn is above the threshold, and column_quant is negative</p>
</td></tr>
<tr><td><code id="color_bar_maker_+3A_col2">col2</code></td>
<td>
<p>a color (either a color name or a number) this is applied where
column_yn is above the threshold, and column_quant is positive</p>
</td></tr>
<tr><td><code id="color_bar_maker_+3A_col3">col3</code></td>
<td>
<p>a color (either a color name or a number) this is applied where
column_yn is below the threshold</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of colors, which can be used as col argument when making
plots
</p>


<h3>Author(s)</h3>

<p>Eike Luedeling
</p>


<h3>References</h3>

<p>Luedeling E, Kunz A and Blanke M, 2013. Identification of
chilling and heat requirements of cherry trees - a statistical approach.
International Journal of Biometeorology 57,679-689.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

PLS_results&lt;-PLS_pheno(
  weather_data=make_all_day_table(KA_weather),
  split_month=6,   #last month in same year
  bio_data=KA_bloom)

colbar&lt;-color_bar_maker(PLS_results$PLS_summary$VIP,PLS_results$PLS_summary$Coef,0.8,
       "RED","DARK GREEN","GREY")

</code></pre>

<hr>
<h2 id='convert_scen_information'>Converts list of change scenarios to data.frame or vice versa</h2><span id='topic+convert_scen_information'></span>

<h3>Description</h3>

<p>Allows the user to convert a list of change scenarios to a single data.frame or 
vice versa. If it converts from data.frame to list, the user can decide if the
returned list should be flat or structured. In case of a list of change scenarios, the 
list should have named elements. In case of composite names, the function assumes 
that the location is the first part of the composite name, composite elements are
seperated by dot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convert_scen_information(scenario_object, give_structure = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="convert_scen_information_+3A_scenario_object">scenario_object</code></td>
<td>
<p>can be either a data.frame or a list of change scenarios. 
If it is a data.frame, it  containing the relative change scenarios</p>
</td></tr>
<tr><td><code id="convert_scen_information_+3A_give_structure">give_structure</code></td>
<td>
<p>boolean, by default set TRUE. If set TRUE, then the output is a
nested list of the structure: 1) Location 2)SSP 3)GCM 4)Timepoint.
If set FALSE, then returns flat list with names following the scheme:
Location.SSP.GCM.Timepoint.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list / data.frame with relative change scenarios
</p>


<h3>Author(s)</h3>

<p>Lars Caspersen
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
download_cmip6_ecmwfr(scenario = 'ssp1_2_6',
                      area = c(55, 5.5, 47, 15.1),
                      user = 'write user id here',
                      key = 'write key here',
                      model = 'AWI-CM-1-1-MR',
                      frequency = 'monthly',
                      variable = c('Tmin', 'Tmax'),
                      year_start = 2015,
                      year_end = 2100)

download_baseline_cmip6_ecmwfr(
    area = c(55, 5.5, 47, 15.1),
    user = 'write user id here',
    key = 'write key here',
    model = 'AWI-CM-1-1-MR',
    frequency = 'monthly',

station &lt;- data.frame(
      station_name = c('Zaragoza', 'Klein-Altendorf', 'Sfax',
      'Cieza', 'Meknes', 'Santomera'),
      longitude = c(-0.88,  6.99, 10.75, -1.41, -5.54, -1.05),
      latitude = c(41.65, 50.61, 34.75, 38.24, 33.88, 38.06))

extracted &lt;- extract_cmip6_data(stations = station)

scenario_df &lt;- gen_rel_change_scenario(extracted)

scenario_list &lt;- convert_scen_information(scenario_df)


## End(Not run)

</code></pre>

<hr>
<h2 id='daily_chill'>Calculation of daily chill and heat accumulation</h2><span id='topic+daily_chill'></span>

<h3>Description</h3>

<p>This function calculates daily chill (with three models) and heat
accumulation for every day of an hourly temperature record (best generated
with stack_hourly_temps). It includes the option to include calculation of a
running mean, which smoothes accumulation curves. Especially for the Dynamic
Model, this may be advisable, because it does not accumulate chill smoothly,
but rather in steps.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>daily_chill(
  hourtemps = NULL,
  running_mean = 1,
  models = list(Chilling_Hours = Chilling_Hours, Utah_Chill_Units = Utah_Model,
    Chill_Portions = Dynamic_Model, GDH = GDH),
  THourly = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="daily_chill_+3A_hourtemps">hourtemps</code></td>
<td>
<p>a dataframe of stacked hourly temperatures (e.g. produced
by stack_hourly_temps). This data frame must have a column for Year, a
column for JDay (Julian date, or day of the year), a column for Hour and a
column for Temp (hourly temperature).</p>
</td></tr>
<tr><td><code id="daily_chill_+3A_running_mean">running_mean</code></td>
<td>
<p>what running mean should be applied to smooth the chill
and heat accumulation curves? This should be an odd integer. Use 1 (default)
for no smoothing.</p>
</td></tr>
<tr><td><code id="daily_chill_+3A_models">models</code></td>
<td>
<p>named list of models that should be applied to the hourly
temperature data. These should be functions that take as input a vector of
hourly temperatures. This defaults to the set of models provided by the
chilling function.</p>
</td></tr>
<tr><td><code id="daily_chill_+3A_thourly">THourly</code></td>
<td>
<p>hourtemps was called THourly in an earlier version of this
package. So in order to allow function calls written before the 0.57 update
to still work, this is included here.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Temperature metrics are calculated according to the specified models. They
are computed based on hourly temperature records and then summed to produce
daily chill accumulation rates.
</p>


<h3>Value</h3>

<p>a daily chill object consisting of the following elements
</p>
<table>
<tr><td><code>object_type</code></td>
<td>
<p>a character string &quot;daily_chill&quot; indicating that this is
a daily_chill object</p>
</td></tr> <tr><td><code>daily_chill</code></td>
<td>
<p>data frame consisting of the
columns YYMMDD, Year, Month, Day and Tmean, plus one column for each model
that is evaluated. The latter columns have the name given to the model in
the models list and they contain daily total accumulations of the computed
metrics.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>After doing extensive model comparisons, and reviewing a lot of
relevant literature, I do not recommend using the Chilling Hours or Utah
Models, especially in warm climates! The Dynamic Model (Chill Portions),
though far from perfect, seems much more reliable.
</p>


<h3>Author(s)</h3>

<p>Eike Luedeling
</p>


<h3>References</h3>

<p>Model references for the default models:
</p>
<p>Chilling Hours:
</p>
<p>Weinberger JH (1950) Chilling requirements of peach varieties. Proc Am Soc
Hortic Sci 56, 122-128
</p>
<p>Bennett JP (1949) Temperature and bud rest period. Calif Agric 3 (11), 9+12
</p>
<p>Utah Model:
</p>
<p>Richardson EA, Seeley SD, Walker DR (1974) A model for estimating the
completion of rest for Redhaven and Elberta peach trees. HortScience 9(4),
331-332
</p>
<p>Dynamic Model:
</p>
<p>Erez A, Fishman S, Linsley-Noakes GC, Allan P (1990) The dynamic model for
rest completion in peach buds. Acta Hortic 276, 165-174
</p>
<p>Fishman S, Erez A, Couvillon GA (1987a) The temperature dependence of
dormancy breaking in plants - computer simulation of processes studied under
controlled temperatures. J Theor Biol 126(3), 309-321
</p>
<p>Fishman S, Erez A, Couvillon GA (1987b) The temperature dependence of
dormancy breaking in plants - mathematical analysis of a two-step model
involving a cooperative transition. J Theor Biol 124(4), 473-483
</p>
<p>Growing Degree Hours:
</p>
<p>Anderson JL, Richardson EA, Kesner CD (1986) Validation of chill unit and
flower bud phenology models for 'Montmorency' sour cherry. Acta Hortic 184,
71-78
</p>
<p>Model comparisons and model equations:
</p>
<p>Luedeling E, Zhang M, Luedeling V and Girvetz EH, 2009. Sensitivity of
winter chill models for fruit and nut trees to climatic changes expected in
California's Central Valley. Agriculture, Ecosystems and Environment 133,
23-31
</p>
<p>Luedeling E, Zhang M, McGranahan G and Leslie C, 2009. Validation of winter
chill models using historic records of walnut phenology. Agricultural and
Forest Meteorology 149, 1854-1864
</p>
<p>Luedeling E and Brown PH, 2011. A global analysis of the comparability of
winter chill models for fruit and nut trees. International Journal of
Biometeorology 55, 411-421
</p>
<p>Luedeling E, Kunz A and Blanke M, 2011. Mehr Chilling fuer Obstbaeume in
waermeren Wintern? (More winter chill for fruit trees in warmer winters?).
Erwerbs-Obstbau 53, 145-155
</p>
<p>Review on chilling models in a climate change context:
</p>
<p>Luedeling E, 2012. Climate change impacts on winter chill for temperate
fruit and nut production: a review. Scientia Horticulturae 144, 218-229
</p>
<p>The PLS method is described here:
</p>
<p>Luedeling E and Gassner A, 2012. Partial Least Squares Regression for
analyzing walnut phenology in California. Agricultural and Forest
Meteorology 158, 43-52.
</p>
<p>Wold S (1995) PLS for multivariate linear modeling. In: van der Waterbeemd H
(ed) Chemometric methods in molecular design: methods and principles in
medicinal chemistry, vol 2. Chemie, Weinheim, pp 195-218.
</p>
<p>Wold S, Sjostrom M, Eriksson L (2001) PLS-regression: a basic tool of
chemometrics. Chemometr Intell Lab 58(2), 109-130.
</p>
<p>Mevik B-H, Wehrens R, Liland KH (2011) PLS: Partial Least Squares and
Principal Component Regression. R package version 2.3-0.
http://CRAN.R-project.org/package0pls.
</p>
<p>Some applications of the PLS procedure:
</p>
<p>Luedeling E, Kunz A and Blanke M, 2013. Identification of chilling and heat
requirements of cherry trees - a statistical approach. International Journal
of Biometeorology 57,679-689.
</p>
<p>Yu H, Luedeling E and Xu J, 2010. Stronger winter than spring warming delays
spring phenology on the Tibetan Plateau. Proceedings of the National Academy
of Sciences (PNAS) 107 (51), 22151-22156.
</p>
<p>Yu H, Xu J, Okuto E and Luedeling E, 2012. Seasonal Response of Grasslands
to Climate Change on the Tibetan Plateau. PLoS ONE 7(11), e49230.
</p>
<p>The exact procedure was used here:
</p>
<p>Luedeling E, Guo L, Dai J, Leslie C, Blanke M, 2013. Differential responses
of trees to temperature variation during the chilling and forcing phases.
Agricultural and Forest Meteorology 181, 33-42.
</p>
<p>The chillR package:
</p>
<p>Luedeling E, Kunz A and Blanke M, 2013. Identification of chilling and heat
requirements of cherry trees - a statistical approach. International Journal
of Biometeorology 57,679-689.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
models&lt;-list(CP=Dynamic_Model,CU=Utah_Model,GDH=GDH)

dc&lt;-daily_chill(stack_hourly_temps(fix_weather(KA_weather[which(KA_weather$Year&gt;2009),]),
 latitude=50.4),11,models)


</code></pre>

<hr>
<h2 id='Date2YEARMODA'>Date to YEARMODA conversion</h2><span id='topic+Date2YEARMODA'></span>

<h3>Description</h3>

<p>Converts R dates to YEARMODA format
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Date2YEARMODA(Date, hours = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Date2YEARMODA_+3A_date">Date</code></td>
<td>
<p>Date in R date format</p>
</td></tr>
<tr><td><code id="Date2YEARMODA_+3A_hours">hours</code></td>
<td>
<p>boolean variable indicating whether YEARMODAHO should be
calculated (YEARMODA + hours)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Converts R date to YEARMODA
</p>


<h3>Value</h3>

<p>YEARMODA object (e.g. 20111224 for 24th December 2011)
</p>


<h3>Author(s)</h3>

<p>Eike Luedeling
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

Date2YEARMODA(YEARMODA2Date(20001205))
Date2YEARMODA(YEARMODA2Date(19901003))

 
</code></pre>

<hr>
<h2 id='daylength'>Compute sunrise and sunset times, and daylength</h2><span id='topic+daylength'></span>

<h3>Description</h3>

<p>This function computes sunrise time, sunset time and daylength for a
particular location and day of the year (Julian day). This is done using
equations by Spencer (1971) and Almorox et al. (2005).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>daylength(latitude, JDay, notimes.as.na = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="daylength_+3A_latitude">latitude</code></td>
<td>
<p>numeric value specifying the geographic latitude
(in decimal degrees) of the location of interest</p>
</td></tr>
<tr><td><code id="daylength_+3A_jday">JDay</code></td>
<td>
<p>numeric (usually integer) value or vector specifying the
Julian day (day of the year), for which calculations should be done.</p>
</td></tr>
<tr><td><code id="daylength_+3A_notimes.as.na">notimes.as.na</code></td>
<td>
<p>parameter to determine whether for days without
sunrise or sunset, na should be returned for Sunset and Sunrise. If
left at FALSE (the default), the function returns -99 and 99 for
sunrise and sunset or polar nights and polar days, respectively.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list with three elements Sunrise, Sunset and Daylength. For days
without sunrise (polar nights), sunset and sunrise become -99 and the
daylength 0. For days without sunset, sunset and sunrise are 99 and
daylength 24.
</p>


<h3>Author(s)</h3>

<p>Eike Luedeling
</p>


<h3>References</h3>

<p>Spencer JW, 1971. Fourier series representation of the position of the Sun.
Search 2(5), 172.
</p>
<p>Almorox J, Hontoria C and Benito M, 2005. Statistical validation of
daylength definitions for estimation of global solar radiation in Toledo,
Spain. Energy Conversion and Management 46(9-10), 1465-1471)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
daylength(latitude=50,JDay=40)
plot(daylength(latitude=35,JDay=1:365)$Daylength)


</code></pre>

<hr>
<h2 id='download_baseline_cmip6_ecmwfr'>Download historical CMIP6 Data via the ecwfr package</h2><span id='topic+download_baseline_cmip6_ecmwfr'></span>

<h3>Description</h3>

<p>Accesses the CMIP6 data of the Copernicus API via the
<code><a href="ecmwfr.html#topic+wf_request_batch">ecmwfr</a></code> package. Saves the downloaded
files as .zip objects in the specified path in a subfolder with the
coordinates of the downloaded area as subfolder name. You can either specify
the GCMs by name or you can take all GCMs for which you downloaded climate 
change scenarios (model = &quot;match_downloaded&quot;).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>download_baseline_cmip6_ecmwfr(
  area,
  user,
  key,
  model = "match_downloaded",
  service = "cds",
  frequency = "monthly",
  variable = c("Tmin", "Tmax"),
  year_start = 1986,
  year_end = 2014,
  month = 1:12,
  sec_wait = 3600,
  n_try = 10,
  update_everything = FALSE,
  path_download = "cmip6_downloaded"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="download_baseline_cmip6_ecmwfr_+3A_area">area</code></td>
<td>
<p>numeric vector of length 4. Sets the spatial boundaries of the
downloaded data. Coordinates are supplied in the following format: 
c(maximum latitude, minimum longitude, minimum latitude, maximum longitude),
which corresponds to the northern extent, western extent, southern extent
and eastern extent of the area of interest.</p>
</td></tr>
<tr><td><code id="download_baseline_cmip6_ecmwfr_+3A_user">user</code></td>
<td>
<p>a character, user name from the Copernicus climate data store.
See 'Details' for more information.</p>
</td></tr>
<tr><td><code id="download_baseline_cmip6_ecmwfr_+3A_key">key</code></td>
<td>
<p>a character. Can be found just beneath the user id on the profile
when registering for the Copernicus website. Should be provided as a
character (so in quotation marks).</p>
</td></tr>
<tr><td><code id="download_baseline_cmip6_ecmwfr_+3A_model">model</code></td>
<td>
<p>character, by default &quot;match_downloaded&quot;. Looks up the already downloaded GCMs for
the climate change scenarios of the &quot;download_cmip6_ecmwfr()&quot; function. You can
also specify the models by name as a vector.</p>
</td></tr>
<tr><td><code id="download_baseline_cmip6_ecmwfr_+3A_service">service</code></td>
<td>
<p>character, by default 'cds'. Decides which database is used.
For more details see in the documentation of
<code><a href="ecmwfr.html#topic+wf_set_key">ecmwfr::wf_set_key()</a></code>.</p>
</td></tr>
<tr><td><code id="download_baseline_cmip6_ecmwfr_+3A_frequency">frequency</code></td>
<td>
<p>character, can be either 'daily' or 'monthly'. Sets
if the downloaded CMIP6 data is in daily or monthly format.</p>
</td></tr>
<tr><td><code id="download_baseline_cmip6_ecmwfr_+3A_variable">variable</code></td>
<td>
<p>vector of characters, decides which variables get downloaded. 
Currently, the options &quot;Tmin&quot; (Daily minimum temperature in degree centigrade), 
&quot;Tmax&quot; (Daily maximum temperature in degree centigrade) 
and &quot;Prec&quot; (Daily sum of precipitation in mm) are the only valid options.</p>
</td></tr>
<tr><td><code id="download_baseline_cmip6_ecmwfr_+3A_year_start">year_start</code></td>
<td>
<p>numeric, earliest year for downloaded CMIP6 data. By default set
to 1985.</p>
</td></tr>
<tr><td><code id="download_baseline_cmip6_ecmwfr_+3A_year_end">year_end</code></td>
<td>
<p>numeric, latest year for downloaded CMIP6 data. By default set
to 2014.</p>
</td></tr>
<tr><td><code id="download_baseline_cmip6_ecmwfr_+3A_month">month</code></td>
<td>
<p>numeric vector, sets for which months data should be downloaded.
By default set to 1:12.</p>
</td></tr>
<tr><td><code id="download_baseline_cmip6_ecmwfr_+3A_sec_wait">sec_wait</code></td>
<td>
<p>numeric, sets the maximum waiting time per requested file.
By default is 3600, so 1 hour.</p>
</td></tr>
<tr><td><code id="download_baseline_cmip6_ecmwfr_+3A_n_try">n_try</code></td>
<td>
<p>numeric, number of repeated calls for the API. For more
information see 'Details'.</p>
</td></tr>
<tr><td><code id="download_baseline_cmip6_ecmwfr_+3A_update_everything">update_everything</code></td>
<td>
<p>logical, by default set to FALSE. When set to FALSE,
scenarios with matching names that have already been downloaded are skipped.
If set to TRUE, then files are downloaded regardless if a file with the same
name is already present.</p>
</td></tr>
<tr><td><code id="download_baseline_cmip6_ecmwfr_+3A_path_download">path_download</code></td>
<td>
<p>character, sets the path for the download of the CMIP6
file. If not already present, then a new folder will be created. 
The path is relative to the working directory.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Registering for cds.climate.coperincus.eu:
<a href="https://cds.climate.copernicus.eu/cdsapp#!/home">https://cds.climate.copernicus.eu/cdsapp#!/home</a>
</p>


<h3>Value</h3>

<p>NULL, the downloaded files are saved in the stated directory
</p>


<h3>Author(s)</h3>

<p>Lars Caspersen
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# example with one specified GCM 
download_baseline_cmip6_ecmwfr(
    area = c(55, 5.5, 47, 15.1),
    user = 'write user id here',
    key = 'write key here',
    model = 'AWI-CM-1-1-MR',
    frequency = 'monthly', 
    variable = c('Tmin', 'Tmax'))
 
## End(Not run)
    
</code></pre>

<hr>
<h2 id='download_cmip6_ecmwfr'>Download CMIP6 Data via the ecwfr package</h2><span id='topic+download_cmip6_ecmwfr'></span>

<h3>Description</h3>

<p>Accesses the CMIP6 data of the Copernicus API via the
<code><a href="ecmwfr.html#topic+wf_request_batch">ecmwfr</a></code> package. Saves the downloaded
files as .zip objects in the specified path in a subfolder with the
coordinates of the downloaded area as subfolder name. You can either specify
the GCMs by name, take the combinations of scenario and GCM that worked in
the past (model = 'default') or you can try out all GCMs for a scenario and
take the ones for which there is data (model = 'all').
</p>


<h3>Usage</h3>

<pre><code class='language-R'>download_cmip6_ecmwfr(
  scenarios,
  area,
  user,
  key,
  model = "default",
  service = "cds",
  frequency = "monthly",
  variable = c("Tmin", "Tmax"),
  year_start = 2015,
  year_end = 2100,
  month = 1:12,
  sec_wait = 3600,
  n_try = 10,
  update_everything = FALSE,
  path_download = "cmip6_downloaded"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="download_cmip6_ecmwfr_+3A_scenarios">scenarios</code></td>
<td>
<p>vector of characters specifying the shared socioeconomic
pathway scenarios (SSP) to be downloaded. Currently the values 'ssp126',
'ssp245', 'ssp370' and 'ssp585' are the only accepted options. These are the
standard scenarios of CMIP6.</p>
</td></tr>
<tr><td><code id="download_cmip6_ecmwfr_+3A_area">area</code></td>
<td>
<p>numeric vector of length 4. Sets the spatial boundaries of the
downloaded data. Coordinates are supplied in the following format: 
c(maximum latitude, minimum longitude, minimum latitude, maximum longitude),
which corresponds to the northern extent, western extent, southern extent
and eastern extent of the area of interest.</p>
</td></tr>
<tr><td><code id="download_cmip6_ecmwfr_+3A_user">user</code></td>
<td>
<p>a character, user name from the Copernicus climate data store.
See 'Details' for more information.</p>
</td></tr>
<tr><td><code id="download_cmip6_ecmwfr_+3A_key">key</code></td>
<td>
<p>a character. Can be found just beneath the user id on the profile
when registering for the Copernicus website. Should be provided as a
character (so in quotation marks).</p>
</td></tr>
<tr><td><code id="download_cmip6_ecmwfr_+3A_model">model</code></td>
<td>
<p>character, by default &quot;default&quot;. Decides which global climate
models are requested. If set to &quot;default&quot; then depending on the scenario and
temporal resolution around 20 models are selected for which we know that
certain combinations of scenario and variables are available. If this is set
to &quot;all&quot;, then all potential models are requested. You can also hand-pick the
models you want to download as a vector of the model names.
You can check <a href="https://cds.climate.copernicus.eu/cdsapp#!/dataset/projections-cmip6?tab=form">https://cds.climate.copernicus.eu/cdsapp#!/dataset/projections-cmip6?tab=form</a>
for the list of models. In case a certain request fails because either the
model name is wrong or the requested combination of SSP, time period and
variable is not available, then the model is dropped from the requests and
the function carries on with the remaining requests. The user will get a
warning in these cases.</p>
</td></tr>
<tr><td><code id="download_cmip6_ecmwfr_+3A_service">service</code></td>
<td>
<p>character, by default 'cds'. Decides which database is used.
For more details see in the documentation of
<code><a href="ecmwfr.html#topic+wf_set_key">ecmwfr::wf_set_key()</a></code>.</p>
</td></tr>
<tr><td><code id="download_cmip6_ecmwfr_+3A_frequency">frequency</code></td>
<td>
<p>character, can be either 'daily' or 'monthly'. Sets
if the downloaded CMIP6 data is in daily or monthly format.</p>
</td></tr>
<tr><td><code id="download_cmip6_ecmwfr_+3A_variable">variable</code></td>
<td>
<p>vector of characters, decides which variables get downloaded. 
Currently, the options &quot;Tmin&quot; (Daily minimum temperature in degree centigrade), 
&quot;Tmax&quot; (Daily maximum temperature in degree centigrade) 
and &quot;Prec&quot; (Daily sum of precipitation in mm) are the only valid options.</p>
</td></tr>
<tr><td><code id="download_cmip6_ecmwfr_+3A_year_start">year_start</code></td>
<td>
<p>numeric, earliest year for downloaded CMIP6 data. By default set
to 2015.</p>
</td></tr>
<tr><td><code id="download_cmip6_ecmwfr_+3A_year_end">year_end</code></td>
<td>
<p>numeric, latest year for downloaded CMIP6 data. By default set
to 2100.</p>
</td></tr>
<tr><td><code id="download_cmip6_ecmwfr_+3A_month">month</code></td>
<td>
<p>numeric vector, sets for which months data should be downloaded.
By default set to 1:12.</p>
</td></tr>
<tr><td><code id="download_cmip6_ecmwfr_+3A_sec_wait">sec_wait</code></td>
<td>
<p>numeric, sets the maximum waiting time per requested file.
By default is 3600, so 1 hour.</p>
</td></tr>
<tr><td><code id="download_cmip6_ecmwfr_+3A_n_try">n_try</code></td>
<td>
<p>numeric, number of repeated calls for the API. For more
information see 'Details'.</p>
</td></tr>
<tr><td><code id="download_cmip6_ecmwfr_+3A_update_everything">update_everything</code></td>
<td>
<p>logical, by default set to FALSE. When set to FALSE,
scenarios with matching names that have already been downloaded are skipped.
If set to TRUE, then files are downloaded regardless if a file with the same
name is already present.</p>
</td></tr>
<tr><td><code id="download_cmip6_ecmwfr_+3A_path_download">path_download</code></td>
<td>
<p>character, sets the path for the download of the CMIP6
file. If not already present, then a new folder will be created. 
The path is relative to the working directory.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Registering for cds.climate.coperincus.eu:
<a href="https://cds.climate.copernicus.eu/cdsapp#!/home">https://cds.climate.copernicus.eu/cdsapp#!/home</a>
</p>
<p>Finding the user id and the key:
</p>
<p>On the website of the Copernicus climate data store, navigate to the user
profile and scroll to the bottom to &quot;API key&quot;. There you can find the item
&quot;UID&quot;. The user id should be provided as character (within quotation marks).
Just below, you can also find the key, which is also needed when using this
function.
</p>
<p>After successful registration some extra steps are needed in order to be
able to download CMIP6 data. In addition to the &quot;Terms of use of the
Copernicus Climate Store&quot; and the &quot;Data Protection and Privacy Agreement&quot;,
you also need to agree to the &quot;CMIP6 - Data Access - Terms of Use&quot;. 
This needs to be done after registering. You can agree to the terms via the
following link:
<a href="https://cds.climate.copernicus.eu/cdsapp/#!/terms/cmip6-wps">https://cds.climate.copernicus.eu/cdsapp/#!/terms/cmip6-wps</a>. 
</p>
<p>Alternatively, you can navigate to the terms within the Copernicus webpage.
Go to &quot;Datasets&quot;, you can find it in the upper ribbon of the main page. 
There you need to search for &quot;CMIP6&quot; using the search field
and choose the first result, which is named &quot;CMIP6 climate projections&quot;. 
There you need to click on &quot;Download data&quot; and scroll to the very bottom of
the page to the field &quot;Terms of Use&quot;. There you need to click on the button
saying &quot;Accept Terms&quot;. If you do not accept the terms the download via the
API (and consequently via this function) will not be possible!
</p>
<p>Sometimes the server is not responding in time, which can make the download
fail. In such cases, after a short waiting time of 5 seconds, the request is
started again. If the error reoccurs several times, the requested model
will be dropped from the list of requests. By default the number of allowed
repeated requests is 10. The user will get a warning if the model is dropped
from the requests.
</p>


<h3>Value</h3>

<p>NULL, the downloaded files are saved in the stated directory
</p>


<h3>Author(s)</h3>

<p>Lars Caspersen, Antonio Picornell
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# example with one specified GCM 
download_cmip6_ecmwfr(
    scenarios = 'ssp126', 
    area = c(55, 5.5, 47, 15.1),
    user = 'write user id here'
    key = 'write key here',
    model = 'AWI-CM-1-1-MR',
    frequency = 'monthly', 
    variable = c('Tmin', 'Tmax'),
    year_start = 2015, 
    year_end = 2100)

# example with default combinations of scenario and GCM
download_cmip6_ecmwfr(
    scenarios = 'ssp126', 
    area = c(55, 5.5, 47, 15.1),
    user = 'write user id here'
    key = 'write key here',
    model = 'default',
    frequency = 'monthly', 
    variable = c('Tmin', 'Tmax'),
    year_start = 2015, 
    year_end = 2100)

# example with all possible combinations of scenario and GCM
# this may take a little longer
download_cmip6_ecmwfr(
    scenarios = 'ssp126', 
    area = c(55, 5.5, 47, 15.1),
    user = 'write user id here'
    key = 'write key here',
    model = 'all',
    frequency = 'monthly', 
    variable = c('Tmin', 'Tmax'),
    year_start = 2015, 
    year_end = 2100)

## End(Not run)
</code></pre>

<hr>
<h2 id='Dynamic_Model'>Dynamic_Model</h2><span id='topic+Dynamic_Model'></span>

<h3>Description</h3>

<p>Calculation of cumulative chill according to the Dynamic Model
</p>
<p>This function calculates winter chill for temperate trees according to the
Dynamic Model.
</p>
<p>Chill Portions are calculated as suggested by Erez et al. (1990).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Dynamic_Model(
  HourTemp,
  summ = TRUE,
  E0 = 4153.5,
  E1 = 12888.8,
  A0 = 139500,
  A1 = 2.567e+18,
  slope = 1.6,
  Tf = 277
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Dynamic_Model_+3A_hourtemp">HourTemp</code></td>
<td>
<p>Vector of hourly temperatures in degree Celsius.</p>
</td></tr>
<tr><td><code id="Dynamic_Model_+3A_summ">summ</code></td>
<td>
<p>Boolean parameter indicating whether calculated metrics should
be provided as cumulative values over the entire record (TRUE) or as the
actual accumulation for each hour (FALSE).</p>
</td></tr>
<tr><td><code id="Dynamic_Model_+3A_e0">E0</code></td>
<td>
<p>numeric. Parameter <code class="reqn">E_0</code> of the dynamic model</p>
</td></tr>
<tr><td><code id="Dynamic_Model_+3A_e1">E1</code></td>
<td>
<p>numeric. Parameter <code class="reqn">E_1</code> of the dynamic model</p>
</td></tr>
<tr><td><code id="Dynamic_Model_+3A_a0">A0</code></td>
<td>
<p>numeric. Parameter <code class="reqn">A_0</code> of the dynamic model</p>
</td></tr>
<tr><td><code id="Dynamic_Model_+3A_a1">A1</code></td>
<td>
<p>numeric. Parameter <code class="reqn">A_1</code> of the dynamic model</p>
</td></tr>
<tr><td><code id="Dynamic_Model_+3A_slope">slope</code></td>
<td>
<p>numeric. Slope parameter for sigmoidal function</p>
</td></tr>
<tr><td><code id="Dynamic_Model_+3A_tf">Tf</code></td>
<td>
<p>numeric. Transition temperature (in degree Kelvin) for the
sigmoidal function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector of length length(HourTemp) containing the cumulative Chill
Portions over the entire duration of HourTemp.
</p>


<h3>Author(s)</h3>

<p>Eike Luedeling
</p>


<h3>References</h3>

<p>Dynamic Model references:
</p>
<p>Erez A, Fishman S, Linsley-Noakes GC, Allan P (1990) The dynamic model for
rest completion in peach buds. Acta Hortic 276, 165-174
</p>
<p>Fishman S, Erez A, Couvillon GA (1987a) The temperature dependence of
dormancy breaking in plants - computer simulation of processes studied under
controlled temperatures. J Theor Biol 126(3), 309-321
</p>
<p>Fishman S, Erez A, Couvillon GA (1987b) The temperature dependence of
dormancy breaking in plants - mathematical analysis of a two-step model
involving a cooperative transition. J Theor Biol 124(4), 473-483
</p>


<h3>Examples</h3>

<pre><code class='language-R'>weather&lt;-fix_weather(KA_weather[which(KA_weather$Year&gt;2006),])

hourtemps&lt;-stack_hourly_temps(weather,latitude=50.4)

res &lt;- Dynamic_Model(hourtemps$hourtemps$Temp)

</code></pre>

<hr>
<h2 id='DynModel_driver'>DynModel_driver</h2><span id='topic+DynModel_driver'></span>

<h3>Description</h3>

<p>Calculation of cumulative chill according to the Dynamic Model
</p>
<p>This function calculates winter chill for temperate trees according to the
Dynamic Model.
</p>
<p>Chill Portions are calculated as suggested by Erez et al. (1990).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DynModel_driver(
  temp,
  times,
  A0 = 139500,
  A1 = 2.567e+18,
  E0 = 4153.5,
  E1 = 12888.8,
  slope = 1.6,
  Tf = 4,
  deg_celsius = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DynModel_driver_+3A_temp">temp</code></td>
<td>
<p>Vector of temperatures.</p>
</td></tr>
<tr><td><code id="DynModel_driver_+3A_times">times</code></td>
<td>
<p>numeric vector. Optional times at which the temperatures where measured,
if not given, hourly temperatures will be assumed</p>
</td></tr>
<tr><td><code id="DynModel_driver_+3A_a0">A0</code></td>
<td>
<p>numeric. Parameter <code class="reqn">A_0</code> of the dynamic model</p>
</td></tr>
<tr><td><code id="DynModel_driver_+3A_a1">A1</code></td>
<td>
<p>numeric. Parameter <code class="reqn">A_1</code> of the dynamic model</p>
</td></tr>
<tr><td><code id="DynModel_driver_+3A_e0">E0</code></td>
<td>
<p>numeric. Parameter <code class="reqn">E_0</code> of the dynamic model</p>
</td></tr>
<tr><td><code id="DynModel_driver_+3A_e1">E1</code></td>
<td>
<p>numeric. Parameter <code class="reqn">E_1</code> of the dynamic model</p>
</td></tr>
<tr><td><code id="DynModel_driver_+3A_slope">slope</code></td>
<td>
<p>numeric. Slope parameter for sigmoidal function</p>
</td></tr>
<tr><td><code id="DynModel_driver_+3A_tf">Tf</code></td>
<td>
<p>numeric. Transition temperature (in degree Kelvin) for the
sigmoidal function</p>
</td></tr>
<tr><td><code id="DynModel_driver_+3A_deg_celsius">deg_celsius</code></td>
<td>
<p>boolean. whether or not the temperature vector
and the model temperature parameters are
in degree Celsius (Kelvin otherwise)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function gives idential results as <a href="#topic+Dynamic_Model">Dynamic_Model</a> for hourly
temperature data, returns more details but is also a bit slower in the R code
version
</p>


<h3>Value</h3>

<p>List containint four vectors of length(temp) with elements
<code>x</code> is the PDBF, <code>y</code> the accumulated chill, <code>delta</code> the
chill portions and <code>xs</code>, which is
<code class="reqn">x_s=A_0/A_1\exp(-(E_0-E_1)/T)</code>
Portions over the entire duration of HourTemp.
</p>


<h3>Author(s)</h3>

<p>Carsten Urbach &lt;urbach@hiskp.uni-bonn.de&gt;
</p>


<h3>References</h3>

<p>Dynamic Model references:
</p>
<p>Erez A, Fishman S, Linsley-Noakes GC, Allan P (1990) The dynamic model for
rest completion in peach buds. Acta Hortic 276, 165-174
</p>
<p>Fishman S, Erez A, Couvillon GA (1987a) The temperature dependence of
dormancy breaking in plants - computer simulation of processes studied under
controlled temperatures. J Theor Biol 126(3), 309-321
</p>
<p>Fishman S, Erez A, Couvillon GA (1987b) The temperature dependence of
dormancy breaking in plants - mathematical analysis of a two-step model
involving a cooperative transition. J Theor Biol 124(4), 473-483
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
weather&lt;-fix_weather(KA_weather[which(KA_weather$Year&gt;2006),])
hourtemps&lt;-stack_hourly_temps(weather,latitude=50.4)
res2 &lt;- DynModel_driver(temp=hourtemps$hourtemps$Temp)

</code></pre>

<hr>
<h2 id='Empirical_daily_temperature_curve'>Empirical daily temperature curve</h2><span id='topic+Empirical_daily_temperature_curve'></span>

<h3>Description</h3>

<p>This function derives an empirical daily temperature curve from observed hourly
temperature data. The mean temperature during each hour of the day is expressed
as a function of the daily minimum and maximum temperature. This is done
separately for each month of the year. The output is a data.frame that can then
be used with the
<code><a href="#topic+Empirical_hourly_temperatures">Empirical_hourly_temperatures</a></code>
function to generate hourly temperatures from data on daily minimum (<code>Tmin</code>)
and maximum (<code>Tmax</code>) temperatures.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Empirical_daily_temperature_curve(Thourly)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Empirical_daily_temperature_curve_+3A_thourly">Thourly</code></td>
<td>
<p>data.frame containing hourly temperatures. Must contain columns
<code>Year</code> (year of observation), <code>Month</code> (month of observation), <code>Day</code> (day of 
observation), <code>Hour</code> (hour of observation) and <code>Temp</code> (Observed temperature).
If multiple observations within an hour are available, these are averaged.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.frame containing three columns: <code>Month</code> (month for which coefficient
applies), <code>Hour</code> (hour for which coefficient applies) and <code>Prediction_coefficient</code>
(the coefficient used for empirical temperature prediction). Coefficients
indicate, by what fraction of the daily temperature range the temperature during
the specified hour is above the daily minimum temperature.
</p>


<h3>Author(s)</h3>

<p>Eike Luedeling
</p>


<h3>Examples</h3>

<pre><code class='language-R'> 
Empirical_daily_temperature_curve(Winters_hours_gaps)

</code></pre>

<hr>
<h2 id='Empirical_hourly_temperatures'>Empirical daily temperature prediction</h2><span id='topic+Empirical_hourly_temperatures'></span>

<h3>Description</h3>

<p>This function generates hourly temperatures from daily minimum and maximum
temperatures, based on an empirical relationship of these two daily 
temperature extremes with the hourly temperature. Usually, this relationship
will have been determined with the <br />
<code><a href="#topic+Empirical_daily_temperature_curve">Empirical_daily_temperature_curve</a></code>
function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Empirical_hourly_temperatures(Tdaily, empi_coeffs)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Empirical_hourly_temperatures_+3A_tdaily">Tdaily</code></td>
<td>
<p>data.frame containing daily minimum and maximum temperatures.
Must contain columns <code>Year</code> (year of observation), <code>Month</code> (month of observation),
<code>Day</code> (day of observation), <code>Tmin</code> (Minimum daily temperature) and <code>Tmax</code>
(Maximum daily temperature).</p>
</td></tr>
<tr><td><code id="Empirical_hourly_temperatures_+3A_empi_coeffs">empi_coeffs</code></td>
<td>
<p>data.frame containing coefficients for the hourly temperature
prediction, e.g. generated with the function
<code><a href="#topic+Empirical_daily_temperature_curve">Empirical_daily_temperature_curve</a></code>.
Needs to contain the following columns: <code>Month</code> (month for which coefficient
applies), <code>Hour</code> (hour for which coefficient applies) and <code>Prediction_coefficient</code>
(the coefficient used for empirical temperature prediction). Coefficients
indicate, by what fraction of the daily temperature range the temperature during
the specified hour is above the daily minimum temperature.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.frame containing all columns of the <code>Tdaily</code> dataset, but also the
columns <code>Hour</code> and <code>Temp</code>, for the hour of the day and the predicted temperature,
respectively.
</p>


<h3>Author(s)</h3>

<p>Eike Luedeling
</p>


<h3>Examples</h3>

<pre><code class='language-R'> 
coeffs&lt;-Empirical_daily_temperature_curve(Winters_hours_gaps)
Winters_daily&lt;-make_all_day_table(Winters_hours_gaps, input_timestep="hour")
Empirical_hourly_temperatures(Winters_daily,coeffs)

</code></pre>

<hr>
<h2 id='extract_cmip6_data'>Unpacks and formats downloaded CMIP6 data</h2><span id='topic+extract_cmip6_data'></span>

<h3>Description</h3>

<p>Opens the downloaded .zip files and returns the CMIP6 climate projections
for specified locations .
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract_cmip6_data(
  stations,
  variable = c("Tmin", "Tmax"),
  download_path = "cmip6_downloaded",
  keep_downloaded = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extract_cmip6_data_+3A_stations">stations</code></td>
<td>
<p>data.frame with the locations of interest, for which the
CMIP6 data should be extracted. Needs to contain the columns 'longitude',
'latitude' and 'station_name'.</p>
</td></tr>
<tr><td><code id="extract_cmip6_data_+3A_variable">variable</code></td>
<td>
<p>character, decides which variables from the downloaded files
get read. Currently, valid options are &quot;Tmin&quot;, &quot;Tmax&quot; and &quot;Prec&quot;. The value
is usually the same as in download_cmip6_ecmwfr function.</p>
</td></tr>
<tr><td><code id="extract_cmip6_data_+3A_download_path">download_path</code></td>
<td>
<p>character, sets the path for the download of the CMIP6
file. If not already present, then a new folder will be created. The path is
relative to working directory.</p>
</td></tr>
<tr><td><code id="extract_cmip6_data_+3A_keep_downloaded">keep_downloaded</code></td>
<td>
<p>Boolean, by default set to TRUE. If TRUE, the
function will not delete the downloaded .nc files. This makes sense when the
user may want to use the climate change data for other locations.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>named list of data.frames. Element names follow the syntax
'SSP'_'GCM', where SSP is the shared socioeconomic pathway and GCM is the
global climate model that generated the weather data. The data.frames contain
the extracted values for the requested locations.
</p>


<h3>Author(s)</h3>

<p>Lars Caspersen
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
scenario&lt;-c("ssp126", "ssp245", "ssp370", "ssp585")

download_cmip6_ecmwfr(scenario,
                         key = 'your-key-here'
                         user = 'your-user-name-here',
                         area =  c(52, -7, 33, 8) )


station &lt;- data.frame(
    station_name = c('Zaragoza', 'Klein-Altendorf', 'Sfax', 'Cieza',
        'Meknes', 'Santomera'),
    longitude = c(-0.88,  6.99, 10.75, -1.41, -5.54, -1.05),
    latitude = c(41.65, 50.61, 34.75, 38.24, 33.88, 38.06))

extracted &lt;- extract_cmip6_data(
    stations = station)
    
scenario &lt;- gen_rel_change_scenario(
    extracted, years_local_weather = c(1992, 2021))


## End(Not run)


</code></pre>

<hr>
<h2 id='extract_differences_between_characters'>Identify shared leading or trailing character strings</h2><span id='topic+extract_differences_between_characters'></span>

<h3>Description</h3>

<p>For a vector of character strings, identify elements between shared leading and/or trailing substrings,
e.g. for a vector such as c(&quot;XXX01YYY&quot;,XXX02YYY&quot;) extract the numbers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract_differences_between_characters(strings)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extract_differences_between_characters_+3A_strings">strings</code></td>
<td>
<p>vector of character strings for elements to be extracted from.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector of strings similar to the input vector but without shared leading and trailing characters.
</p>


<h3>Author(s)</h3>

<p>Eike Luedeling
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  extract_differences_between_characters(c("Temp_01","Temp_02","Temp_03"))
  extract_differences_between_characters(c("Temp_01_Tmin","Temp_02_Tmin","Temp_03_Tmin"))
  extract_differences_between_characters(c("a","b"))                                           
 
</code></pre>

<hr>
<h2 id='extract_temperatures_from_grids'>Extract temperature information from gridded dataset</h2><span id='topic+extract_temperatures_from_grids'></span>

<h3>Description</h3>

<p>Temperature data is often available in gridded format, and records for particular points must
be extracted for work on site-specific issues (such as chill calculation). This function
implements this, for certain types of gridded data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract_temperatures_from_grids(
  coordinates,
  grid_format,
  grid_specifications,
  scenario_year = NA,
  reference_year = NA,
  scenario_type = NA,
  labels = NA,
  temperature_check_args = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extract_temperatures_from_grids_+3A_coordinates">coordinates</code></td>
<td>
<p>numeric vector specifying coordinates for the point location of interest.
These coordinates have to use the same coordinate system as the grids, from which data are to
be extracted. The elements can be named as 'longitude' and 'latitude', or provided as unnamed
elements. In the latter case, the first element is interpreted as the x-coordinate (e.g. longitude
or Easting) and the second element as the y-coordinate (e.g. latitude or Northing).</p>
</td></tr>
<tr><td><code id="extract_temperatures_from_grids_+3A_grid_format">grid_format</code></td>
<td>
<p>character string specifying the type of raster data. See details below.</p>
</td></tr>
<tr><td><code id="extract_temperatures_from_grids_+3A_grid_specifications">grid_specifications</code></td>
<td>
<p>list of specifications that instruct the function on where to find
the temperature grids. See grid_format descriptions for what is required here.</p>
</td></tr>
<tr><td><code id="extract_temperatures_from_grids_+3A_scenario_year">scenario_year</code></td>
<td>
<p>year the temperature scenario is representative of, e.g. 2050, 2080. If the
scenario period is an interval, this should be the median of all years in this interval.</p>
</td></tr>
<tr><td><code id="extract_temperatures_from_grids_+3A_reference_year">reference_year</code></td>
<td>
<p>year of reference for the gridded climate data. This is only important
for relative temperature scenarios. If the reference period is an interval, this should be the
median of all years in this interval.</p>
</td></tr>
<tr><td><code id="extract_temperatures_from_grids_+3A_scenario_type">scenario_type</code></td>
<td>
<p>character string specifying whether the climate data contains a relative
or absolute temperature sceanario. Accordingly, this should be 'relative' or 'absolute'. Can also
be NA, which is the default, in which case the function makes a guess on which type applies. This
guess is directed by the temperature_check_args.</p>
</td></tr>
<tr><td><code id="extract_temperatures_from_grids_+3A_labels">labels</code></td>
<td>
<p>list of labels to be passed to the labels argument of the resulting temperature_scenario</p>
</td></tr>
<tr><td><code id="extract_temperatures_from_grids_+3A_temperature_check_args">temperature_check_args</code></td>
<td>
<p>list of arguments to be passed to the check_temperature_scenario function.
Check documentation of that function for details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The following climate data formats are supported: &quot;AFRICLIM&quot; - data downloaded from
https://www.york.ac.uk/environment/research/kite/resources/; &quot;CCAFS&quot; - data downloaded from
http://ccafs-climate.org/data_spatial_downscaling/; &quot;WorldClim&quot; - data downloaded from
http://www.worldclim.org/. All these databases provide separate zipped files for monthly minimum
and monthly maximum temperatures, but they differ slightly in format and structure. If you want to
see additional formats included, please send me a message.
</p>


<h3>Value</h3>

<p>temperature scenario object extracted from the grids, consisting of the following elements:
'data' = a data frame with n_intervals elements containing the absolute or relative temperature
information. 'reference_year' = the year the scenario is representative of. 'scenario_type' =
the scenario type ('absolute' or 'relative'); 'labels' = and elements attached to the input
temperature_scenario as an element names 'labels'.
</p>
<p>The function generates errors, when problems arise.
</p>


<h3>Author(s)</h3>

<p>Eike Luedeling
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  coordinates&lt;-c(10.6082,34.9411)
 # grid_specifications&lt;-list(base_folder="D:/DATA/AFRICLIM/GeoTIFF_30s/future_scenarios/",
 #                           minfile="tasmin_rcp45_2055_CCCma-CanESM2_CCCma-CanRCM4_wc30s.zip",
 #                           maxfile="tasmax_rcp45_2055_CCCma-CanESM2_CCCma-CanRCM4_wc30s.zip")
                            
 # extract_temperatures_from_grids(coordinates,grid_format="AFRICLIM",grid_specifications,
 #    scenario_type="relative",scenario_year=2055)
                 
 # grid_specifications&lt;-list(base_folder="D:/DATA/CCAFS_climate/",
 #                           minfile="bcc_csm1_1_rcp2_6_2030s_tmin_30s_r1i1p1_b4_asc.zip",
 #                           maxfile="bcc_csm1_1_rcp2_6_2030s_tmax_30s_r1i1p1_b4_asc.zip")
 #temps&lt;-extract_temperatures_from_grids(coordinates,grid_format="CCAFS",grid_specifications,
 #                                       scenario_type="relative",scenario_year=2035)
 
</code></pre>

<hr>
<h2 id='filter_temperatures'>Quality filter for temperature records</h2><span id='topic+filter_temperatures'></span>

<h3>Description</h3>

<p>This function attempts to remove erroneous temperature readings. This is
tricky because of the wide range of errors that can occur, so this isn't
necessarily sufficient for problems of particular records.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>filter_temperatures(
  temp_file,
  remove_value = NA,
  running_mean_filter = NA,
  running_mean_length = 3,
  min_extreme = NA,
  max_extreme = NA,
  max_missing_in_window = 1,
  missing_window_size = 9
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="filter_temperatures_+3A_temp_file">temp_file</code></td>
<td>
<p>file containing temperature data. Should have columns
c(&quot;Year&quot;,&quot;Month&quot;,&quot;Day&quot;,&quot;Temp&quot; - and &quot;Hour&quot; for hourly data).</p>
</td></tr>
<tr><td><code id="filter_temperatures_+3A_remove_value">remove_value</code></td>
<td>
<p>numeric value indicating 'no data'.</p>
</td></tr>
<tr><td><code id="filter_temperatures_+3A_running_mean_filter">running_mean_filter</code></td>
<td>
<p>deviation from a running mean over all temperature
data that identifies a value as an erroneous outlier.</p>
</td></tr>
<tr><td><code id="filter_temperatures_+3A_running_mean_length">running_mean_length</code></td>
<td>
<p>number of records to be included in a running mean.</p>
</td></tr>
<tr><td><code id="filter_temperatures_+3A_min_extreme">min_extreme</code></td>
<td>
<p>lowest plausible temperature on the record. All lower ones are removed.</p>
</td></tr>
<tr><td><code id="filter_temperatures_+3A_max_extreme">max_extreme</code></td>
<td>
<p>highest plausible temperature on the record. All higher ones are removed.</p>
</td></tr>
<tr><td><code id="filter_temperatures_+3A_max_missing_in_window">max_missing_in_window</code></td>
<td>
<p>maximum share of values (0..1) in a running window of size
missing_window_size around each value that can be missing. If this is exceeded, the value
is removed.</p>
</td></tr>
<tr><td><code id="filter_temperatures_+3A_missing_window_size">missing_window_size</code></td>
<td>
<p>size of the window used for checking for missing values.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>filtered temperature dataset, from which records identified as erroneous were removed.
</p>


<h3>Author(s)</h3>

<p>Eike Luedeling
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

weather&lt;-fix_weather(KA_weather[which(KA_weather$Year&gt;2009),])

hourtemps&lt;-stack_hourly_temps(weather, latitude=50.4)

filtered&lt;-filter_temperatures(hourtemps$hourtemps,remove_value=-99,
  running_mean_filter=3)

</code></pre>

<hr>
<h2 id='fix_weather'>Weather data fixer and quality checker</h2><span id='topic+fix_weather'></span>

<h3>Description</h3>

<p>This function identifies and interpolates gaps in daily weather records
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fix_weather(
  weather,
  start_year = 0,
  end_year = 3000,
  start_date = 1,
  end_date = 366,
  columns = c("Tmin", "Tmax"),
  end_at_present = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fix_weather_+3A_weather">weather</code></td>
<td>
<p>a data.frame containing a daily time series dataset. It
should have columns c(&quot;Year&quot;, &quot;Month&quot;, &quot;Day&quot;) or c(&quot;YEAR&quot;, &quot;MONTH&quot;,&quot;DAY&quot;) or
&quot;YEARMODA&quot;.</p>
</td></tr>
<tr><td><code id="fix_weather_+3A_start_year">start_year</code></td>
<td>
<p>integer marking the first year of interest. If not
specified, this is assumed to be year 0, which probably means that the
entire record will be considered.</p>
</td></tr>
<tr><td><code id="fix_weather_+3A_end_year">end_year</code></td>
<td>
<p>integer marking the last year of interest. If not specified,
this is assumed to be year 3000, which probably means that the entire record
will be considered.</p>
</td></tr>
<tr><td><code id="fix_weather_+3A_start_date">start_date</code></td>
<td>
<p>start date of the sub-annual period of interest (e.g. the
assumed chilling period), defaults to 1 (1st Jan) if not specified</p>
</td></tr>
<tr><td><code id="fix_weather_+3A_end_date">end_date</code></td>
<td>
<p>end date of the sub-annual period of interest (e.g. the
assumed chilling period), defaults to 366 (31st Dec, also in non-leap years)
if not specified</p>
</td></tr>
<tr><td><code id="fix_weather_+3A_columns">columns</code></td>
<td>
<p>character vector containing the names of columns of the
weather file that should be interpolated and quality checked. If not
specified, this defaults to &quot;Tmin&quot; and &quot;Tmax&quot;. If these columns don't exist,
the function generates an error.</p>
</td></tr>
<tr><td><code id="fix_weather_+3A_end_at_present">end_at_present</code></td>
<td>
<p>boolean variable indicating whether the interval of
interest should end on the present day, rather than extending until the end
of the year specified under time_interval[2] (if time_interval[2] is the
current year).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function produces a complete record containing all dates between the
1st day of the start year and the last day of the end year (unless the
first/last day of the record is after/before these dates - in that case the
record is not extended). The values for the columns specified by the columns
attribute are linearly interpolated. Missing values during the period
indicated by start_date and end_date are added up and summarized in a
quality control table.
</p>


<h3>Value</h3>

<p>list with two elements: weather: contains the interpolated weather
record QC: contains the quality control data.frame, which summarizes missing
days, incomplete days (days on which any value is missing), and percentage
completeness.
</p>


<h3>Author(s)</h3>

<p>Eike Luedeling
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
fix_weather(KA_weather,2000,2010)

#use a subset of the KA_weather dataset and add an additional day after a gap
KA_weather_gap&lt;-rbind(KA_weather,c(Year=2011,Month=3,Day=3,Tmax=26,Tmin=14)) 
#fill in the gaps
fix_weather(KA_weather_gap, 1990,2011,300,100)

#fix_weather(KA_weather)

 
</code></pre>

<hr>
<h2 id='GDD'>Calculation of cumulative heat according to the Growing Degree Day Model</h2><span id='topic+GDD'></span>

<h3>Description</h3>

<p>This function calculates heat for temperate trees according to the Growing
Degree Day Model. Note that the calculuation differs slightly from the original,
in which it is based on daily temperature extremes only. This equation here works
with hourly temperatures. The normal GDD equation is GDD=(Tmax-Tmin)/2-Tbase, with
Tmax=30 for Tmax&gt;30, and Tmin=10 for Tmin&lt;10. Tbase is a species-specific base
temperature.
The first part of the equation is the arithmetic mean of daily temperature extremes.
In the present equation, this is replaced by Thourly/24 for each hourly temperature
value. If chillR was using a triangular daily temperature curve, the result would
be the same for both equations. Since chillR uses a sine function for daytime
warming and a logarithmic decay function for nighttime cooling, however, there
will be a slight deviation. This could be handled by defining a function the runs
with daily weather data. chillR doesn't currently have this capability, since
its primary focus is on metrics that require hourly data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GDD(HourTemp, summ = TRUE, Tbase = 5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GDD_+3A_hourtemp">HourTemp</code></td>
<td>
<p>Vector of hourly temperatures.</p>
</td></tr>
<tr><td><code id="GDD_+3A_summ">summ</code></td>
<td>
<p>Boolean parameter indicating whether calculated metrics should
be provided as cumulative values over the entire record (TRUE) or as the
actual accumulation for each hour (FALSE).</p>
</td></tr>
<tr><td><code id="GDD_+3A_tbase">Tbase</code></td>
<td>
<p>Base temperature, above which Growing Degrees accrue.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Growing Degree Hours are calculated as suggested by Anderson et al. (1986).
</p>


<h3>Value</h3>

<p>Vector of length length(HourTemp) containing the cumulative Growing
Degree Days over the entire duration of HourTemp.
</p>


<h3>Author(s)</h3>

<p>Eike Luedeling
</p>


<h3>References</h3>

<p>Growing Degree Days reference:
</p>
<p>http://agron-www.agron.iastate.edu/Courses/agron212/Calculations/GDD.htm
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

weather&lt;-fix_weather(KA_weather[which(KA_weather$Year&gt;2006),])

hourtemps&lt;-stack_hourly_temps(weather,latitude=50.4)

GDD(hourtemps$hourtemps$Temp)

</code></pre>

<hr>
<h2 id='GDH'>Calculation of cumulative heat according to the Growing Degree Hours Model</h2><span id='topic+GDH'></span>

<h3>Description</h3>

<p>This function calculates heat for temperate trees according to the Growing
Degree Hours Model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GDH(HourTemp, summ = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GDH_+3A_hourtemp">HourTemp</code></td>
<td>
<p>Vector of hourly temperatures.</p>
</td></tr>
<tr><td><code id="GDH_+3A_summ">summ</code></td>
<td>
<p>Boolean parameter indicating whether calculated metrics should
be provided as cumulative values over the entire record (TRUE) or as the
actual accumulation for each hour (FALSE).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Growing Degree Hours are calculated as suggested by Anderson et al. (1986).
</p>


<h3>Value</h3>

<p>Vector of length length(HourTemp) containing the cumulative Growing
Degree Hours over the entire duration of HourTemp.
</p>


<h3>Author(s)</h3>

<p>Eike Luedeling
</p>


<h3>References</h3>

<p>Growing Degree Hours reference:
</p>
<p>Anderson JL, Richardson EA, Kesner CD (1986) Validation of chill unit and
flower bud phenology models for 'Montmorency' sour cherry. Acta Hortic 184,
71-78
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

weather&lt;-fix_weather(KA_weather[which(KA_weather$Year&gt;2006),])

hourtemps&lt;-stack_hourly_temps(weather,latitude=50.4)

GDH(hourtemps$hourtemps$Temp)

</code></pre>

<hr>
<h2 id='GDH_model'>Calculation of cumulative heat according to the Growing Degree Hours Model
(alternative function name)</h2><span id='topic+GDH_model'></span>

<h3>Description</h3>

<p>This function calculates heat for temperate trees according to the Growing
Degree Hours Model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GDH_model(HourTemp, summ = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GDH_model_+3A_hourtemp">HourTemp</code></td>
<td>
<p>Vector of hourly temperatures.</p>
</td></tr>
<tr><td><code id="GDH_model_+3A_summ">summ</code></td>
<td>
<p>Boolean parameter indicating whether calculated metrics should
be provided as cumulative values over the entire record (TRUE) or as the
actual accumulation for each hour (FALSE).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Growing Degree Hours are calculated as suggested by Anderson et al. (1986).
</p>


<h3>Value</h3>

<p>Vector of length length(HourTemp) containing the cumulative Growing
Degree Hours over the entire duration of HourTemp.
</p>


<h3>Author(s)</h3>

<p>Eike Luedeling
</p>


<h3>References</h3>

<p>Growing Degree Hours reference:
</p>
<p>Anderson JL, Richardson EA, Kesner CD (1986) Validation of chill unit and
flower bud phenology models for 'Montmorency' sour cherry. Acta Hortic 184,
71-78
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
weather&lt;-fix_weather(KA_weather[which(KA_weather$Year&gt;2006),])

hourtemps&lt;-stack_hourly_temps(weather,latitude=50.4)

GDH_model(hourtemps$hourtemps$Temp)

</code></pre>

<hr>
<h2 id='gen_rel_change_scenario'>Generates relative climate change scenarios based on extracted CMIP6 data</h2><span id='topic+gen_rel_change_scenario'></span>

<h3>Description</h3>

<p>Takes the extracted CMIP6 data and returns climate change scenarios, which
can then be used to generate weather data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gen_rel_change_scenario(
  downloaded_list,
  scenarios = c(2050, 2085),
  reference_period = c(1986:2014),
  future_window_width = 30
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gen_rel_change_scenario_+3A_downloaded_list">downloaded_list</code></td>
<td>
<p>list of data.frames, generated using the
extract_cmip6_data function. Elements are named after the shared socioeconomic
pathway ('SSP') and global climate model ('GCM')</p>
</td></tr>
<tr><td><code id="gen_rel_change_scenario_+3A_scenarios">scenarios</code></td>
<td>
<p>numeric vector, states the future years, for which the climate
change scenarios should be generated. By default set to c(2050, 2085).</p>
</td></tr>
<tr><td><code id="gen_rel_change_scenario_+3A_reference_period">reference_period</code></td>
<td>
<p>numeric vector specifying the years to be used as the
reference period. Defaults to c(1986:2014).</p>
</td></tr>
<tr><td><code id="gen_rel_change_scenario_+3A_future_window_width">future_window_width</code></td>
<td>
<p>numeric, sets the window width of the running mean
calculation for the mean temperatures of the years indicated by scenarios</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.frame for the calculated relative change scenarios, all locations, SSPs, timepoints, GCMs combined
</p>


<h3>Author(s)</h3>

<p>Lars Caspersen
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
download_cmip6_ecmwfr(scenario = 'ssp1_2_6', 
                      area = c(55, 5.5, 47, 15.1),
                      user = 'write user id here',
                      key = 'write key here',
                      model = 'AWI-CM-1-1-MR',
                      frequency = 'monthly', 
                      variable = c('Tmin', 'Tmax'),
                      year_start = 2015, 
                      year_end = 2100)
                      
download_baseline_cmip6_ecmwfr(
    area = c(55, 5.5, 47, 15.1),
    user = 'write user id here',
    key = 'write key here',
    model = 'AWI-CM-1-1-MR',
    frequency = 'monthly', 
   
station &lt;- data.frame(
      station_name = c('Zaragoza', 'Klein-Altendorf', 'Sfax',
      'Cieza', 'Meknes', 'Santomera'),
      longitude = c(-0.88,  6.99, 10.75, -1.41, -5.54, -1.05),
      latitude = c(41.65, 50.61, 34.75, 38.24, 33.88, 38.06))
      
extracted &lt;- extract_cmip6_data(stations = station)

gen_rel_change_scenario(extracted)


## End(Not run)

</code></pre>

<hr>
<h2 id='genSeason'>Generate Seasons</h2><span id='topic+genSeason'></span>

<h3>Description</h3>

<p>Identify the hours, days or months in a (monthly, daily or hourly) temperature dataset that belong to a particular season.
Seasons are defined according to the 'mrange' argument, which specifies the start and end month of
the season. The 'years' argument specifies the year, in which the dormancy season of interest ends.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>genSeason(temps, mrange = c(8, 6), years)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="genSeason_+3A_temps">temps</code></td>
<td>
<p>list. generated by 'chillR'</p>
</td></tr>
<tr><td><code id="genSeason_+3A_mrange">mrange</code></td>
<td>
<p>numeric. vector with two entries for the range of months (start month and end month)</p>
</td></tr>
<tr><td><code id="genSeason_+3A_years">years</code></td>
<td>
<p>numeric. vector of years to be considered (with each entry specifying the year, in which the season **ends**)</p>
</td></tr>
</table>

<hr>
<h2 id='genSeasonList'>genSeasonList</h2><span id='topic+genSeasonList'></span>

<h3>Description</h3>

<p>Generates a list with data.frame elements for each season.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>genSeasonList(temps, mrange = c(8, 6), years)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="genSeasonList_+3A_temps">temps</code></td>
<td>
<p>data.frame. Must have columns 'Temp' containing the temperatures, 'JDay'
the JDays, 'Month' the months and 'Year' the years. This
kind of data frame is for instance generated by <a href="#topic+stack_hourly_temps">stack_hourly_temps</a>, but can also
be generated by hand or using a different routine.</p>
</td></tr>
<tr><td><code id="genSeasonList_+3A_mrange">mrange</code></td>
<td>
<p>numeric. vector of length two for the range of months the season
should span. E.g. 'mrange=c(8,6)' would span a season from August to next June.
There must not be any overlap in months, i.e. mrange[1] must be larger mrange[2].</p>
</td></tr>
<tr><td><code id="genSeasonList_+3A_years">years</code></td>
<td>
<p>numeric. vector of years to be considered</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list of data frames. Each element of the list corresponds to one season. The
'data.frame' for each year has named columns 'Temp', 'JDay' and 'Year'.
</p>

<hr>
<h2 id='get_last_date'>Get the last date from a phenology record</h2><span id='topic+get_last_date'></span>

<h3>Description</h3>

<p>When looking at multi-year phenology records, it is normally obvious in
which year bloom occurred last. Determining this with an automated
procedure, however, is a bit tricky, when the range of phenological dates
spans across a calendar year transition. This function finds the latest
phenological date of the record. This is the date before the longest
phenological date gap.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_last_date(dates, first = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_last_date_+3A_dates">dates</code></td>
<td>
<p>numeric vector of Julian dates (days of the year)</p>
</td></tr>
<tr><td><code id="get_last_date_+3A_first">first</code></td>
<td>
<p>boolean variable that can be set to TRUE to get the first, not
the last, date of the phenology record.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the latest (earliest) date of the series, under the assumption that
the longest period without bloom can be interpreted as separating the
phenological seasons. This should be a reasonable assumption in most cases.
</p>


<h3>Author(s)</h3>

<p>Eike Luedeling
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

get_last_date(c(1,3,6,8,10,25))
get_last_date(c(345,356,360,365,2,5,7,10))
get_last_date(c(345,356,360,365,2,5,7,10),first=TRUE)

 
</code></pre>

<hr>
<h2 id='get_weather'>Download weather data from online database</h2><span id='topic+get_weather'></span>

<h3>Description</h3>

<p>This function retrieves either a list of nearby weather stations for a
specified point location, or it downloads weather data for a specific
weather station.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_weather(
  location,
  time_interval = NA,
  database = "UCIPM",
  station_list = NULL,
  stations_to_choose_from = 25,
  end_at_present = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_weather_+3A_location">location</code></td>
<td>
<p>either a vector of geographic coordinates, or the
'chillRcode' of a weather station in the specified database. See details.</p>
</td></tr>
<tr><td><code id="get_weather_+3A_time_interval">time_interval</code></td>
<td>
<p>numeric vector with two elements, specifying the start
and end date of the period of interest.</p>
</td></tr>
<tr><td><code id="get_weather_+3A_database">database</code></td>
<td>
<p>the database to be accessed. Must be &quot;GSOD&quot;, &quot;CIMIS&quot;
or &quot;UCIPM&quot;. Since among these, &quot;UCIPM&quot; is the most
comprehensive one for California, the initial area of interest, this is the
default.</p>
</td></tr>
<tr><td><code id="get_weather_+3A_station_list">station_list</code></td>
<td>
<p>if the list of weather stations has already been
downloaded, the list can be passed to the function through this argument.
This can save a bit of time, since it can take a bit of time to download the
list, which can have several MB.</p>
</td></tr>
<tr><td><code id="get_weather_+3A_stations_to_choose_from">stations_to_choose_from</code></td>
<td>
<p>if the location is specified by geographic
coordinates, this argument determines the number of nearby stations in the
list that is returned.</p>
</td></tr>
<tr><td><code id="get_weather_+3A_end_at_present">end_at_present</code></td>
<td>
<p>boolean variable indicating whether the interval of
interest should end on the present day, rather than extending until the end
of the year specified under time_interval[2] (if time_interval[2] is the
current year).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>weather databases, from which chillR can download data: NOAA NCDC Global
Summary of the Day - &quot;GSOD&quot;
(https://data.noaa.gov/dataset/global-surface-summary-of-the-day-gsod)
</p>
<p>California Irrigation Management Information System (CIMIS) - &quot;CIMIS&quot;
(http://www.cimis.water.ca.gov/)
</p>
<p>University of California Integrated Pest Management (UCIPM) - &quot;UCIPM&quot;
(http://ipm.ucdavis.edu/WEATHER/)
</p>
<p>several formats are possible for specifying the location vector, which can
consist of either two or three coordinates (it can include elevation).
Possible formats include c(1,2,3), c(1,2), c(x=1,y=2,z=3),
c(lat=2,long=1,elev=3). If elements of the vector are not names, they are
interpreted as c(Longitude, Latitude, Elevation).
</p>
<p>The 'chillRCode' is generated by this function, when it is run with
geographic coordinates as location inputs. In the list of nearby stations
that is returned then, the chillRCode is provided and can then be used as
input for running the function in 'downloading' mode. For downloading the
data, use the same call as before but replace the location argument with the
chillRCode.
</p>


<h3>Value</h3>

<p>The output depends on how the location is provided. If it is a
coordinate vector, the function returns a list of station_to_choose_from
weather stations that are close to the specified location. This list also
contains information about how far away these stations are (in km), how much
the elevation difference is (if elevation is specified; in m) and how much
overlap there is between the data contained in the database and the time
period specified by time_interval.
</p>


<h3>Note</h3>

<p>Many databases have data quality flags, which may sometimes indicate
that data aren't reliable. These are not considered by this function!
</p>
<p>see the documentation of the handler functions (e.g. handle_ucipm) for details.
</p>


<h3>Author(s)</h3>

<p>Eike Luedeling
</p>


<h3>References</h3>

<p>The chillR package:
</p>
<p>Luedeling E, Kunz A and Blanke M, 2013. Identification of chilling and heat
requirements of cherry trees - a statistical approach. International Journal
of Biometeorology 57,679-689.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

#stat_list&lt;-handle_gsod(action="list_stations",location=c(x=-122,y=38.5),
#  time_interval=c(2002,2002))
#the line above takes longer to run than CRAN allows for examples. The line below therefore
#generates an abbreviated stat_list that allows running the code.
stat_list&lt;-data.frame(chillR_code=c("724828_99999","724828_93241","720576_174"),
   Lat=c(38.383,38.378,38.533),Long=c(-121.967,-121.958,-121.783),
   BEGIN=c(20010811,20060101,20130101),END=c(20051231,20160110,20160109))

#gw&lt;-get_weather(location="724828_93241",time_interval=c(2012,2012),database="GSOD",
#   station_list = stat_list)

#stat_list&lt;-get_weather(location=c(lat=50,lon=10,ele=150),time_interval=c(2001,2001),
#  database="UCIPM")
#chillRcode&lt;-stat_list[which(stat_list$Perc_interval_covered==
#max(stat_list$Perc_interval_covered)),"chillR_code"][1]
  #after the first few lines here, the code should be "CEDARVIL.C"
#gw&lt;-get_weather(location="CEDARVIL.C",time_interval=c(2001,2001),database="UCIPM")
#weather&lt;-weather2chillR(gw,"GSOD")
#make_chill_plot(tempResponse(stack_hourly_temps(fix_weather(weather))),
#                "Chill_Portions",start_year=2005,end_year=2011,metriclabel="Chill Portions")

</code></pre>

<hr>
<h2 id='getClimateWizard_scenarios'>Extract mutltiple scenarios from the ClimateWizard database</h2><span id='topic+getClimateWizard_scenarios'></span>

<h3>Description</h3>

<p>This function is a wrapper for the getClimateWizardData function to access climate
scenario data for a location of interest. Climate model runs are queried
and data returned and summarized according to the specified parameters.
A number of metrics are available for several climate models, which are listed in
https://github.com/CIAT-DAPA/climate_wizard_api.
This function can download data for multiple climate scenarios, saving users the
effort to retrieve them separately.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getClimateWizard_scenarios(
  coordinates,
  scenarios,
  start_years,
  end_years,
  baseline = c(1950, 2005),
  metric = "monthly_min_max_temps",
  GCMs = "all"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getClimateWizard_scenarios_+3A_coordinates">coordinates</code></td>
<td>
<p>position of the point of interest, specified by a vector
with two elements that are called longitude and latitude (e.g. c(longitude=10,
latitude=20)).</p>
</td></tr>
<tr><td><code id="getClimateWizard_scenarios_+3A_scenarios">scenarios</code></td>
<td>
<p>vector of representative concentration pathway scenarios. Can only be
&quot;historical&quot;, &quot;rcp45&quot; or &quot;rcp85&quot;.</p>
</td></tr>
<tr><td><code id="getClimateWizard_scenarios_+3A_start_years">start_years</code></td>
<td>
<p>vector of start year of the intervals, for which data is to be summarized.
Must be of same length as scenarios.</p>
</td></tr>
<tr><td><code id="getClimateWizard_scenarios_+3A_end_years">end_years</code></td>
<td>
<p>vector of end years of the intervals, for which data is to be summarized.
Must be of same length as scenarios.</p>
</td></tr>
<tr><td><code id="getClimateWizard_scenarios_+3A_baseline">baseline</code></td>
<td>
<p>numeric vector of length 2 indicating the time interval to be used
as baseline for the climate scenario. The function then returns projected values relative
to this baseline. Defaults to c(1950,2005) for the standard
baseline of the ClimateWizard dataset. This can also assume different values, but it must
span an interval of at least 20 years within the [1950; 2005] interval. Needs
to be set to NA for the function to return absolute values.</p>
</td></tr>
<tr><td><code id="getClimateWizard_scenarios_+3A_metric">metric</code></td>
<td>
<p>vector of metrics to output, from a list specified in the reference
provided above. This can also be &quot;monthly_min_max_temps&quot;, which returns all
mean monthly minimum and maximum temperatures, or &quot;precipitation&quot; for precipitation
data for all months, or &quot;monthly_tmean&quot; for the mean monthly temperatures of all months.</p>
</td></tr>
<tr><td><code id="getClimateWizard_scenarios_+3A_gcms">GCMs</code></td>
<td>
<p>vector of GCMs to be accessed, from a list specified in the above
reference. This can also be &quot;all&quot; for all available GCMs (as of January 2018).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that this function lacks quality checks. If something goes wrong, you may
consider checking individual scenarios with the getClimateWizardData function.
</p>


<h3>Value</h3>

<p>data.frame containing the requested information.
</p>


<h3>Author(s)</h3>

<p>Eike Luedeling
</p>


<h3>References</h3>

<p>Girvetz E, Ramirez-Villegas J, Navarro C, Rodriguez C, Tarapues J, undated.
ClimateWizard REST API for querying climate change data.
https://github.com/CIAT-DAPA/climate_wizard_api
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#example is #d out, because of runtime issues.
#getC&lt;-getClimateWizard_scenarios(coordinates=c(longitude=6.99,latitude=50.62),
#                                scenarios=c("rcp85","rcp45"),
#                                start_years=c(2070,2035),
#                                end_years=c(2100,2065),
#                                metric=c("monthly_tmean"),
#                                GCMs=c("all"))


</code></pre>

<hr>
<h2 id='getClimateWizardData'>Extract climate data from the ClimateWizard database</h2><span id='topic+getClimateWizardData'></span>

<h3>Description</h3>

<p>This function makes use of an API provided by the International
Center for Tropical Agriculture (CIAT) to access climate scenario
data for a location of interest. Climate model runs are queried
and data returned and summarized according to the specified parameters.
A number of metrics are available for several climate models, which are listed in the
<a href="https://github.com/CIAT-DAPA/climate_wizard_api">API repository</a>.
Refer to this document for details on what can be downloaded. This function
provides the additional option of automatically retrieving all data referring to changes
in daily temperature extremes (by month), by setting the &ldquo;'metric&ldquo;' parameter to
&quot;monthly_min_max_temps&quot;. It also offers the option to automatically obtain data for
all climate models included in the database (as of January 2018).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getClimateWizardData(
  coordinates,
  scenario,
  start_year,
  end_year,
  baseline = c(1950, 2005),
  metric = "monthly_min_max_temps",
  GCMs = "all",
  temperature_generation_scenarios = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getClimateWizardData_+3A_coordinates">coordinates</code></td>
<td>
<p>position of the point of interest, specified by a vector
with two elements that are called longitude and latitude (e.g. <code>c(longitude = 10,
latitude = 20)</code>).</p>
</td></tr>
<tr><td><code id="getClimateWizardData_+3A_scenario">scenario</code></td>
<td>
<p>representative concentration pathway scenario. Can only be
&quot;historical&quot;, &quot;rcp45&quot; or &quot;rcp85&quot;.</p>
</td></tr>
<tr><td><code id="getClimateWizardData_+3A_start_year">start_year</code></td>
<td>
<p>start year of the interval, for which data is to be summarized.</p>
</td></tr>
<tr><td><code id="getClimateWizardData_+3A_end_year">end_year</code></td>
<td>
<p>end year of the interval, for which data is to be summarized.</p>
</td></tr>
<tr><td><code id="getClimateWizardData_+3A_baseline">baseline</code></td>
<td>
<p>numeric vector of length 2 indicating the time interval to be used
as baseline for the climate scenario. The function then returns projected values relative
to this baseline. Defaults to <code>c(1950, 2005)</code> for the standard
baseline of the ClimateWizard dataset. This can also assume different values, but it must
span an interval of at least 20 years within the [1950; 2005] interval. Needs
to be set to NA for the function to return absolute values.</p>
</td></tr>
<tr><td><code id="getClimateWizardData_+3A_metric">metric</code></td>
<td>
<p>vector of metrics to output, from a list specified in the reference
provided above. This can also be &quot;monthly_min_max_temps&quot;, which returns all
mean monthly minimum and maximum temperatures, or &quot;precipitation&quot; for precipitation
data for all months, or &quot;monthly_tmean&quot; for the mean monthly temperatures of all months.</p>
</td></tr>
<tr><td><code id="getClimateWizardData_+3A_gcms">GCMs</code></td>
<td>
<p>vector of GCMs to be accessed, from a list specified in the above
reference. This can also be &quot;all&quot; for all available GCMs (as of January 2018).</p>
</td></tr>
<tr><td><code id="getClimateWizardData_+3A_temperature_generation_scenarios">temperature_generation_scenarios</code></td>
<td>
<p>parameter to indicate whether the scenarios to be
generated should be formatted in such a way that they are directly usable by
chillR's temperature_generation function. This is only applicable, when <code>metric ==
'monthly_min_max_temps'</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.frame containing the requested information.
</p>


<h3>Author(s)</h3>

<p>Eike Luedeling
</p>


<h3>References</h3>

<p>Girvetz E, Ramirez-Villegas J, Navarro C, Rodriguez C, Tarapues J, undated.
ClimateWizard REST API for querying climate change data.
https://github.com/CIAT-DAPA/climate_wizard_api
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# the example is #d out, since the download request sometimes times out, and that
# causes problems with CRAN approval of the package

# getClimateWizardData(coordinates=c(longitude=10.613975,latitude=34.933439),
#   scenario="rcp45", start_year=2020, end_year=2050,
#   metric=c("CD18","R02"), GCMs=c("bcc-csm1-1","BNU-ESM"))


</code></pre>

<hr>
<h2 id='handle_cimis'>List, download or convert to chillR format data from the CIMIS database</h2><span id='topic+handle_cimis'></span>

<h3>Description</h3>

<p>This function can do three things related to the California Irrigation
Management Information System (&quot;CIMIS&quot;) database: 1. it can list stations
that are close to a specified position (geographic coordinates) 2. it can
retrieve weather data for a named weather station 3. it can 'clean'
downloaded data, so that they can easily be used in chillR Which of these
functions is carried out depends on the action argument.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>handle_cimis(
  action,
  location = NA,
  time_interval = NA,
  station_list = NULL,
  stations_to_choose_from = 25,
  drop_most = TRUE,
  end_at_present = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="handle_cimis_+3A_action">action</code></td>
<td>
<p>if this is the character string &quot;list_stations&quot;, the function
will return a list of the weather stations from the database that are
closest to the geographic coordinates specified by location.  if this is the
character string &quot;download_weather&quot;, the function will attempt to download
weather data from the database for the station named by the location
argument, which should then be a character string corresponding to the
chillRcode of the station (which you can get by running this function in
'list_stations mode) if this is a downloaded weather file (downloaded by
running this function in 'download weather' mode), the function cleans the
file and makes it ready for use in chillR. If the input is just a dataframe
(not a list, as produced with this function), you have to specify the
database name with the database argument</p>
</td></tr>
<tr><td><code id="handle_cimis_+3A_location">location</code></td>
<td>
<p>either a vector of geographic coordinates (for the
'list_stations' mode), or the 'chillRcode' of a weather station in the
specified database (for the 'download_weather' mode. When running this
function for data cleaning only, this is not needed.</p>
</td></tr>
<tr><td><code id="handle_cimis_+3A_time_interval">time_interval</code></td>
<td>
<p>numeric vector with two elements, specifying the start
and end date of the period of interest. Only required when running in
'list_stations' or 'download weather' mode</p>
</td></tr>
<tr><td><code id="handle_cimis_+3A_station_list">station_list</code></td>
<td>
<p>if the list of weather stations has already been
downloaded, the list can be passed to the function through this argument.
This can save a bit of time, since it can take a bit of time to download the
list, which can have several MB.</p>
</td></tr>
<tr><td><code id="handle_cimis_+3A_stations_to_choose_from">stations_to_choose_from</code></td>
<td>
<p>if the location is specified by geographic
coordinates, this argument determines the number of nearby stations in the
list that is returned.</p>
</td></tr>
<tr><td><code id="handle_cimis_+3A_drop_most">drop_most</code></td>
<td>
<p>boolean variable indicating if most columns should be
dropped from the file. If set to TRUE (default), only essential columns for
running chillR functions are retained.</p>
</td></tr>
<tr><td><code id="handle_cimis_+3A_end_at_present">end_at_present</code></td>
<td>
<p>boolean variable indicating whether the interval of
interest should end on the present day, rather than extending until the end
of the year specified under time_interval[2] (if time_interval[2] is the
current year).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function can run independently, but it is also called by the
get_weather and weather2chillR functions, which some users might find a bit
easier to handle.
</p>
<p>The CIMIS dataset is described here: http://www.cimis.water.ca.gov/
</p>
<p>Under the 'list_stations' mode, several formats are possible for specifying
the location vector, which can consist of either two or three coordinates
(it can include elevation). Possible formats include c(1,2,3), c(1,2),
c(x=1,y=2,z=3), c(lat=2,long=1,elev=3). If elements of the vector are not
names, they are interpreted as c(Longitude, Latitude, Elevation).
</p>
<p>The 'chillRCode' is generated by this function, when it is run with
geographic coordinates as location inputs. In the list of nearby stations
that is returned then, the chillRCode is provided and can then be used as
input for running the function in 'downloading' mode. For downloading the
data, use the same call as before but replace the location argument with the
chillRCode.
</p>


<h3>Value</h3>

<p>The output depends on the action argument. If it is 'list_stations',
the function returns a list of station_to_choose_from weather stations that
are close to the specified location. This list also contains information
about how far away these stations are (in km), how much the elevation
difference is (if elevation is specified; in m) and how much overlap there
is between the data contained in the database and the time period specified
by time_interval. If action is 'download_weather' the output is a list of
two elements: 1. database=&quot;CIMIS&quot; 2. the downloaded weather record, extended
to the full duration of the specified time interval. If action is a weather
data.frame or a weather record downloaded with this function (in
'download_weather' mode), the output is the same data in a format that is
easy to use in chillR. If drop_most was set to TRUE, most columns are
dropped.
</p>


<h3>Note</h3>

<p>Many databases have data quality flags, which may sometimes indicate
that data aren't reliable. These are not considered by this function!
</p>
<p>Past CIMIS data is provided to the public as compressed data files of annual
data, which contain data for all stations for the respective years. The same
strategy was followed for monthly data of the past year. This means that in
order to get to the records for one given station, it is necessary to
download data for all stations first, before extracting weather for the
station of interest. This means that downloads take a lot longer than one
might expect, and the downloaded data volume is a multiple of what is really
of interest.
</p>


<h3>Author(s)</h3>

<p>Eike Luedeling
</p>


<h3>References</h3>

<p>The chillR package:
</p>
<p>Luedeling E, Kunz A and Blanke M, 2013. Identification of chilling and heat
requirements of cherry trees - a statistical approach. International Journal
of Biometeorology 57,679-689.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# the example is #d out, since the download request sometimes times out, and that
# causes problems with CRAN approval of the package

# handle_cimis(action = "list_stations",
#              location = c(x = -122, y = 38.5),
#              time_interval = c(2012, 2012))

# stat_list &lt;- data.frame("Station Number" = c("119", "139", "6"),
#                         Latitude = c(38.49500, 38.50126, 38.53569),
#                         Longitude = c(-122.0040, -121.9785, -121.7764),
#                         Start_date =c("1993-08-21 UTC", "1998-06-15 UTC", "1982-07-17 UTC"),
#                         End_date = c("1995-01-25", "2016-03-06", "2016-03-06"))

# gw &lt;- handle_cimis(action = "download_weather",
#                    location = "6",
#                    time_interval = c(1982, 1982), 
#                    station_list = stat_list)
 
# weather &lt;- handle_cimis(gw)

# make_chill_plot(tempResponse(stack_hourly_temps(fix_weather(weather)),
#                 Start_JDay = 300, End_JDay = 50), 
#                 "Chill_Portions", start_year = 2010, end_year = 2012,
#                 metriclabel = "Chill Portions", misstolerance = 50)

</code></pre>

<hr>
<h2 id='handle_dwd'>List, download or convert to chillR format data from the Deutscher Wetterdienst database</h2><span id='topic+handle_dwd'></span>

<h3>Description</h3>

<p>This function accesses the
<a href="https://www.dwd.de/EN/climate_environment/cdc/cdc_node_en.html">Deutscher
Wetterdienst database</a> and allows to:</p>
<ul>
<li><p>1) list a number of weather
stations that are close to a specific position (geographic coordinates) </p>
</li>
<li><p>2) obtain
weather data for one or more weather stations through the station ID </p>
</li>
<li><p>3) 'clean' and
'format' downloaded data, so the records can easily be used in other chillR functions</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>handle_dwd(
  action,
  location = NA,
  time_interval = c(19160101, Date2YEARMODA(Sys.Date())),
  station_list = NULL,
  stations_to_choose_from = 25,
  drop_most = TRUE,
  end_at_present = TRUE,
  add.DATE = FALSE,
  quiet = FALSE,
  add_station_name = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="handle_dwd_+3A_action">action</code></td>
<td>
<p>is a character string to decide on 3 modes of action for the function.</p>

<ul>
<li><p><em>'list_stations'</em> returns a data frame with the information on weather stations that
are to the location defined by <code>number_of_stations</code> and <code>location</code> parameters.
</p>
</li>
<li><p><em>'download_weather'</em> retrieves the records for one or more weather stations defined
in the <code>location</code> parameter.
</p>
</li>
<li><p>If the input is a data frame previously downloaded with the mode <em>'download_weather'</em>,
the function will format the data frame using the chillR structure.</p>
</li></ul>
</td></tr>
<tr><td><code id="handle_dwd_+3A_location">location</code></td>
<td>
<p>accepts a numeric vector with two or three elements representing the longitude,
latitude, and elevation of a given place or a vector of character strings representing the ID
of the weather stations of interest.
If <code>action = 'list_stations'</code>, <code>location</code> requires the coordinates of the place and
optionally the elevation. This vector can be named or not. Valid names are:
<code>'y'</code>, <code>'Y'</code>, <code>'latitude'</code>, <code>'lat'</code>, <code>'Latitude'</code>, <code>'Lat'</code>,
<code>'LATITUDE'</code>, <code>'LAT'</code> for latitude, <code>'x'</code>,
<code>'X'</code>, <code>'longitude'</code>, <code>'long'</code>, <code>'Longitude'</code>, <code>'Long'</code>,
<code>'LONGITUDE'</code>, <code>'LONG'</code> for longitude, and <code>'z'</code>, <code>'Z'</code>, <code>'elevation'</code>,
<code>'elev'</code>, <code>'Elevation'</code>, <code>'Elev'</code>, <code>'ELEVATION'</code>,
<code>'ELEV'</code> for elevation. If <code>action = 'download_weather'</code>, <code>location</code> accepts
the ID of the station as character string.</p>
</td></tr>
<tr><td><code id="handle_dwd_+3A_time_interval">time_interval</code></td>
<td>
<p>numeric vector with two elements, specifying the start and end date
of the period of interest. Only required when running in <code>'list_stations'</code> or
<code>'download_weather'</code> mode. Unlike other functions from the handle family,
<code>handle_dwd</code> allows specifying the date in <code>YEARMODA</code> format. Default is set to
<code>19160101</code> (the earliest date on record) and the current date.</p>
</td></tr>
<tr><td><code id="handle_dwd_+3A_station_list">station_list</code></td>
<td>
<p>accepts a data frame if the list of weather stations has already been
downloaded. The list can be passed to the function through this argument. This can save a bit
of time, since it can take a bit of time to download the list, which can have several
<code>MB</code>.</p>
</td></tr>
<tr><td><code id="handle_dwd_+3A_stations_to_choose_from">stations_to_choose_from</code></td>
<td>
<p>if the location is specified by geographic coordinates,
this argument 
determines the number of nearby stations in the list that is returned.</p>
</td></tr>
<tr><td><code id="handle_dwd_+3A_drop_most">drop_most</code></td>
<td>
<p>boolean variable indicating if most columns should be dropped from the
file if a list of data frames is provided to the <code>action</code> argument. If set to
<code>TRUE</code> (the default), only essential columns for running <code>chillR</code> functions are
retained.</p>
</td></tr>
<tr><td><code id="handle_dwd_+3A_end_at_present">end_at_present</code></td>
<td>
<p>boolean variable indicating whether the interval of interest
should end on the present day, rather than extending until the end of the year specified
under <code>time_interval[2]</code> (if <code>time_interval[2]</code> is the current year).
<strong>DEPRECATED</strong> in this function since <code>time_interval</code> already allows specifying
the present day.</p>
</td></tr>
<tr><td><code id="handle_dwd_+3A_add.date">add.DATE</code></td>
<td>
<p>is a boolean parameter to be passed to <code><a href="#topic+make_all_day_table">make_all_day_table</a></code>
if <code>action</code> is a collection of outputs (in the form of list) from the function in the
downloading format.</p>
</td></tr>
<tr><td><code id="handle_dwd_+3A_quiet">quiet</code></td>
<td>
<p>is a boolean parameter to be passed to
<code><a href="utils.html#topic+download.file">download.file</a></code> if <code>action = "download_weather"</code>.</p>
</td></tr>
<tr><td><code id="handle_dwd_+3A_add_station_name">add_station_name</code></td>
<td>
<p>is a boolean parameter to include the name of the respective weather
station in the resulting data frame in case the function is used in the downloading or
formatting mode.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>action = 'list_stations'</code>, the function returns a data frame with
<code>'stations_to_choose_from'</code> rows and 9 columns. This data frame contains information
about the weather stations (Latitude, Longitude, among others). If
<code>action = 'download_weather'</code>, the function returns a list of length according to the
length of the <code>location</code> parameter. Each list elements is a data frame
containing the data downloaded from the database. If the <code>action</code> is provided
with the list generated by the function in the downloading mode, the function will
return a list of data frames structured according to the chillR format.
If <code>drop_most</code> is set to <code>TRUE</code>, the function will keep only the
most relevant variables for standard chillR analyses.
</p>


<h3>Note</h3>

<p>Many databases have data quality flags, which may sometimes indicate that data aren't reliable.
These are not considered by this function!
</p>


<h3>Author(s)</h3>

<p>Eduardo Fernandez and Eike Luedeling
</p>


<h3>References</h3>

<p>Fernandez, E., Whitney, C., and Luedeling, E. 2020. The importance of chill model selection
- A multi-site analysis. European Journal Of Agronomy 119: 126103
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# The following lines may take longer than required to pass the
# CRAN checks. Please, un-comment them to run the example

# stations &lt;- handle_dwd(action = "list_stations", 
#                        location = c(latitude = 53.5373, longitude = 9.6397),
#                        time_interval = c(20000101, 20101231),
#                        stations_to_choose_from = 25)
                     
# data &lt;- handle_dwd(action = "download_weather",
#                     location = stations[1 : 3, "Station_ID"],
#                     time_interval = c(20000101, 20020601),
#                     stations_to_choose_from = 25,
#                     station_list = stations,
#                     drop_most = TRUE, 
#                     add.DATE = FALSE,
#                     quiet = TRUE,
#                     add_station_name = FALSE)

# data_modified &lt;- handle_dwd(data, add.DATE = TRUE, drop_most = TRUE)
           
</code></pre>

<hr>
<h2 id='handle_dwd_old'>List, download or convert to chillR format data from the Deutscher Wetterdienst database</h2><span id='topic+handle_dwd_old'></span>

<h3>Description</h3>

<p><em>This function is deprecated and will disappear soon.</em> Please refer to the
<code><a href="#topic+handle_dwd">handle_dwd</a></code> function for the most current functionality.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>handle_dwd_old(
  action,
  location = NA,
  time_interval = c(19160101, Date2YEARMODA(Sys.Date())),
  station_list = NULL,
  stations_to_choose_from = 25,
  drop_most = TRUE,
  end_at_present = TRUE,
  add.DATE = FALSE,
  quiet = FALSE,
  add_station_name = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="handle_dwd_old_+3A_action">action</code></td>
<td>
<p>is a character string to decide on 3 modes of action for the function.</p>

<ul>
<li><p><em>'list_stations'</em> returns a data frame with the information on weather stations that
are to the location defined by <code>number_of_stations</code> and <code>location</code> parameters.
</p>
</li>
<li><p><em>'download_weather'</em> retrieves the records for one or more weather stations defined
in the <code>location</code> parameter.
</p>
</li>
<li><p>If the input is a data frame previously downloaded with the mode <em>'download_weather'</em>,
the function will format the data frame using the chillR structure.</p>
</li></ul>
</td></tr>
<tr><td><code id="handle_dwd_old_+3A_location">location</code></td>
<td>
<p>accepts a numeric vector with two or three elements representing the longitude,
latitude, and elevation of a given place or a vector of character strings representing the ID
of the weather stations of interest.
If <code>action = 'list_stations'</code>, <code>location</code> requires the coordinates of the place and
optionally the elevation. This vector can be named or not. Valid names are:
<code>'y'</code>, <code>'Y'</code>, <code>'latitude'</code>, <code>'lat'</code>, <code>'Latitude'</code>, <code>'Lat'</code>,
<code>'LATITUDE'</code>, <code>'LAT'</code> for latitude, <code>'x'</code>,
<code>'X'</code>, <code>'longitude'</code>, <code>'long'</code>, <code>'Longitude'</code>, <code>'Long'</code>,
<code>'LONGITUDE'</code>, <code>'LONG'</code> for longitude, and <code>'z'</code>, <code>'Z'</code>, <code>'elevation'</code>,
<code>'elev'</code>, <code>'Elevation'</code>, <code>'Elev'</code>, <code>'ELEVATION'</code>,
<code>'ELEV'</code> for elevation. If <code>action = 'download_weather'</code>, <code>location</code> accepts
the ID of the station as character string.</p>
</td></tr>
<tr><td><code id="handle_dwd_old_+3A_time_interval">time_interval</code></td>
<td>
<p>numeric vector with two elements, specifying the start and end date
of the period of interest. Only required when running in <code>'list_stations'</code> or
<code>'download_weather'</code> mode. Unlike other functions from the handle family,
<code>handle_dwd</code> allows specifying the date in <code>YEARMODA</code> format. Default is set to
<code>19160101</code> (the earliest date on record) and the current date.</p>
</td></tr>
<tr><td><code id="handle_dwd_old_+3A_station_list">station_list</code></td>
<td>
<p>accepts a data frame if the list of weather stations has already been
downloaded. The list can be passed to the function through this argument. This can save a bit
of time, since it can take a bit of time to download the list, which can have several
<code>MB</code>.</p>
</td></tr>
<tr><td><code id="handle_dwd_old_+3A_stations_to_choose_from">stations_to_choose_from</code></td>
<td>
<p>if the location is specified by geographic coordinates,
this argument 
determines the number of nearby stations in the list that is returned.</p>
</td></tr>
<tr><td><code id="handle_dwd_old_+3A_drop_most">drop_most</code></td>
<td>
<p>boolean variable indicating if most columns should be dropped from the
file if a list of data frames is provided to the <code>action</code> argument. If set to
<code>TRUE</code> (the default), only essential columns for running <code>chillR</code> functions are
retained.</p>
</td></tr>
<tr><td><code id="handle_dwd_old_+3A_end_at_present">end_at_present</code></td>
<td>
<p>boolean variable indicating whether the interval of interest
should end on the present day, rather than extending until the end of the year specified
under <code>time_interval[2]</code> (if <code>time_interval[2]</code> is the current year).
<strong>DEPRECATED</strong> in this function since <code>time_interval</code> already allows specifying
the present day.</p>
</td></tr>
<tr><td><code id="handle_dwd_old_+3A_add.date">add.DATE</code></td>
<td>
<p>is a boolean parameter to be passed to <code><a href="#topic+make_all_day_table">make_all_day_table</a></code>
if <code>action</code> is a collection of outputs (in the form of list) from the function in the
downloading format.</p>
</td></tr>
<tr><td><code id="handle_dwd_old_+3A_quiet">quiet</code></td>
<td>
<p>is a boolean parameter to be passed to
<code><a href="utils.html#topic+download.file">download.file</a></code> if <code>action = "download_weather"</code>.</p>
</td></tr>
<tr><td><code id="handle_dwd_old_+3A_add_station_name">add_station_name</code></td>
<td>
<p>is a boolean parameter to include the name of the respective weather
station in the resulting data frame in case the function is used in the downloading or
formatting mode.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function accesses the
<a href="https://www.dwd.de/EN/climate_environment/cdc/cdc_node_en.html">Deutscher
Wetterdienst database</a> and allows to:</p>
<ul>
<li><p>1) list a number of weather
stations that are close to a specific position (geographic coordinates) </p>
</li>
<li><p>2) obtain
weather data for one or more weather stations through the station ID </p>
</li>
<li><p>3) 'clean' and
'format' downloaded data, so the records can easily be used in other chillR functions</p>
</li></ul>



<h3>Value</h3>

<p>If <code>action = 'list_stations'</code>, the function returns a data frame with
<code>'stations_to_choose_from'</code> rows and 9 columns. This data frame contains information
about the weather stations (Latitude, Longitude, among others). If
<code>action = 'download_weather'</code>, the function returns a list of length according to the
length of the <code>location</code> parameter. Each list, is a list of two elements; a data frame
containing the data downloaded from the database and character string representing the
respective database ('dwd'). If the <code>action</code> is provided with the list generated by
the function in the downloading mode, the function will return a list of data frames structured
according to the chillR format. If <code>drop_most</code> is set to <code>TRUE</code>, the function will
keep only the relevant variables.
</p>


<h3>Note</h3>

<p>Many databases have data quality flags, which may sometimes indicate that data aren't reliable.
These are not considered by this function!
</p>


<h3>Author(s)</h3>

<p>Eduardo Fernandez and Eike Luedeling
</p>


<h3>References</h3>

<p>Fernandez, E., Whitney, C., and Luedeling, E. 2020. The importance of chill model selection
- A multi-site analysis. European Journal Of Agronomy 119: 126103
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# The following lines may take longer than required to pass the
# CRAN checks. Please, un-comment them to run the example

# stations &lt;- handle_dwd_old(action = "list_stations", 
#                        location = c(latitude = 53.5373, longitude = 9.6397),
#                        time_interval = c(20000101, 20101231),
#                        stations_to_choose_from = 25)
                     
# data &lt;- handle_dwd_old(action = "download_weather",
#                     location = stations[1 : 3, "Station_ID"],
#                     time_interval = c(20000101, 20020601),
#                     stations_to_choose_from = 25,
#                     station_list = stations,
#                     drop_most = TRUE, 
#                     add.DATE = FALSE,
#                     quiet = TRUE,
#                     add_station_name = FALSE)

# data_modified &lt;- handle_dwd_old(data, add.DATE = TRUE, drop_most = TRUE)
           
</code></pre>

<hr>
<h2 id='handle_gsod'>List, download or convert to chillR format data from the Global Summary of
the Day database</h2><span id='topic+handle_gsod'></span>

<h3>Description</h3>

<p>This function can do four things related to the Global Summary of the Day
(&quot;GSOD&quot;) database from the National Climatic Data Centre (NCDC) of the
National Oceanic and Atmospheric Administration (NOAA): </p>

<ul>
<li><p>1. It can list stations that are close to a specified position (geographic coordinates).
</p>
</li>
<li><p>2. It can retrieve weather data for a named weather station (or a vector of multiple stations).
For the name, the chillRcode from the list returned by the <code>list_stations</code> operation
should be used.
</p>
</li>
<li><p>3. It can 'clean' downloaded data (for one or multiple stations), so that they can easily be used in chillR
</p>
</li>
<li><p>4. It can delete the downloaded intermediate weather files from the machine
</p>
<p>Which of these functions is carried out depends on the <code>action</code> argument.
</p>
</li></ul>

<p>This function can run independently, but it is also called by the
<code><a href="#topic+get_weather">get_weather</a></code> and <code><a href="#topic+weather2chillR">weather2chillR</a></code> functions, which some users might find a bit
easier to handle.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>handle_gsod(
  action,
  location = NULL,
  time_interval = c(1950, 2020),
  stations_to_choose_from = 25,
  end_at_present = FALSE,
  add.DATE = FALSE,
  update_station_list = FALSE,
  path = "climate_data",
  update_all = FALSE,
  clean_up = NULL,
  override_confirm_delete = FALSE,
  max_distance = 150,
  min_overlap = 0,
  verbose = "normal"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="handle_gsod_+3A_action">action</code></td>
<td>
<p>accepts 4 types of inputs to decide on the mode of action for the function.</p>

<ul>
<li><p>if this is the character string <code>"list_stations"</code>, the function
will return a list of the weather stations from the database that are
closest to the geographic coordinates specified by location.
</p>
</li>
<li><p>if this is the character string <code>"download_weather"</code>, the function will attempt to download
weather data from the database for the station named by the location
argument, which should then be a character string corresponding to the
<code>chillRcode</code> of the station (which you can get by running this function in
<code>'list_stations'</code> mode).
</p>
</li>
<li><p>if this is the character string <code>"delete"</code>, the function will attempt to remove
the intermediate downloaded weather data, which was saved in the folder specified by <code>"path"</code> argument.
</p>
</li>
<li><p>if this is a collection of outputs obtained by
running this function in the <code>'download weather'</code> mode), the function cleans the
weather files and make them ready for use in <code>chillR</code>. If the input is just a dataframe
(not a list, as produced with this function), you have to specify the
database name with the database argument.</p>
</li></ul>
</td></tr>
<tr><td><code id="handle_gsod_+3A_location">location</code></td>
<td>
<p>either a vector of geographic coordinates (for the
<code>'list_stations'</code> mode), or the 'chillRcode' of a weather station in the
specified database (for the <code>'download_weather'</code> mode). When running this
function for data cleaning only, this is not needed. For the
<code>'download_weather'</code> mode, this can also be a vector of 'chillRcodes',
in which case records for all stations will be downloaded. The data cleaning
mode can also handle a list of downloaded weather datasets.</p>
</td></tr>
<tr><td><code id="handle_gsod_+3A_time_interval">time_interval</code></td>
<td>
<p>numeric vector with two elements, specifying the start
and end date of the period of interest. Only required when running in
<code>'list_stations'</code> or <code>'download_weather'</code> mode. The default is c(1950,2020).</p>
</td></tr>
<tr><td><code id="handle_gsod_+3A_stations_to_choose_from">stations_to_choose_from</code></td>
<td>
<p>if the location is specified by geographic
coordinates, this argument determines the number of nearby stations in the
list that is returned.</p>
</td></tr>
<tr><td><code id="handle_gsod_+3A_end_at_present">end_at_present</code></td>
<td>
<p>boolean variable indicating whether the interval of
interest should end on the present day, rather than extending until the end
of the year specified under <code>time_interval[2]</code> (if <code>time_interval[2]</code> is the
current year).</p>
</td></tr>
<tr><td><code id="handle_gsod_+3A_add.date">add.DATE</code></td>
<td>
<p>is a boolean parameter to be passed to <code><a href="#topic+make_all_day_table">make_all_day_table</a></code> if <code>action</code> is 
a collection of outputs (in the form of list) from the function in the downloading format.</p>
</td></tr>
<tr><td><code id="handle_gsod_+3A_update_station_list">update_station_list</code></td>
<td>
<p>boolean, by default set FALSE. Decides if the weather station list is read from the disk (if present) or if it is newly downloaded in case of action = list_stations.</p>
</td></tr>
<tr><td><code id="handle_gsod_+3A_path">path</code></td>
<td>
<p>character, by default &quot;climate_data&quot;. Specifies the folder, relative to the working directory where the weather data is downloaded to.</p>
</td></tr>
<tr><td><code id="handle_gsod_+3A_update_all">update_all</code></td>
<td>
<p>boolean, by default set to FALSE. If set TRUE, it will download every stations data, even if previously downloaded and 
still present in the temporary folder, specifief by the function argument <code>path</code>. If set FALSE, already downloaded years of a station will be skipped
when download action is carried out again.</p>
</td></tr>
<tr><td><code id="handle_gsod_+3A_clean_up">clean_up</code></td>
<td>
<p>character, by default set to NULL. In combination with 'action = delete', this can be set to 'all' to delete all weather data, or 'station' if only data from specific stations ('location') should be deleted</p>
</td></tr>
<tr><td><code id="handle_gsod_+3A_override_confirm_delete">override_confirm_delete</code></td>
<td>
<p>Boolean, request whether the delete function needs user confirmation to run. Defaults to <code>FALSE</code>, and
Should be set to <code>TRUE</code> if the function needs to be run without user intervention.</p>
</td></tr>
<tr><td><code id="handle_gsod_+3A_max_distance">max_distance</code></td>
<td>
<p>numeric, by default 150. Expresses the distance in kilometers how far away
weather stations can be located from the original location, when searching for weather stations</p>
</td></tr>
<tr><td><code id="handle_gsod_+3A_min_overlap">min_overlap</code></td>
<td>
<p>numeric, by default set to 0. Expresses in percent how much of the specified period needs to be covered by weather station to be 
included in the list, when searching for stations.</p>
</td></tr>
<tr><td><code id="handle_gsod_+3A_verbose">verbose</code></td>
<td>
<p>is a character, deciding how much information is returned while downloading
the weather data. By default set to &quot;normal&quot;. If set to &quot;detailed&quot; the function
will say how many years of data have been successfully downloaded for each station. If set &quot;quiet&quot; no
information is printed during download.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The GSOD database is described here:
<a href="https://www.ncei.noaa.gov/access/metadata/landing-page/bin/iso?id=gov.noaa.ncdc:C00516">https://www.ncei.noaa.gov/access/metadata/landing-page/bin/iso?id=gov.noaa.ncdc:C00516</a>
</p>
<p>under the <code>'list_stations'</code> mode, several formats are possible for specifying
the location vector, which can consist of either two or three coordinates
(it can include elevation). Possible formats include <code>c(1, 2, 3)</code>, <code>c(1, 2)</code>,
<code>c(x = 1, y = 2, z = 3)</code>, <code>c(lat = 2, long = 1, elev = 3)</code>. If elements of the vector are not
names, they are interpreted as c(Longitude, Latitude, Elevation).
</p>
<p>The 'chillRCode' is generated by this function, when it is run with
geographic coordinates as location inputs. In the list of nearby stations
that is returned then, the chillRCode is provided and can then be used as
input for running the function in 'downloading' mode. For downloading the
data, use the same call as before but replace the location argument with the
chillRCode.
</p>


<h3>Value</h3>

<p>The output depends on the action argument. If it is <code>'list_stations'</code>,
the function returns a list of <code>station_to_choose_from</code> weather stations that
are close to the specified location. This list also contains information
about how far away these stations are (in km), how much the elevation
difference is (if elevation is specified; in m) and how much overlap there
is between the data contained in the database and the time period specified
by <code>time_interval</code>. If action is <code>'download_weather'</code> the output is a list of
the downloaded weather record, extended
to the full duration of the specified time interval. If the <code>location</code> input
was a vector of stations, the output will be a list of such objects.
If action is a weather <code>data.frame</code> or a weather record downloaded with
this function (in <code>'download_weather'</code> mode), the data structure remains
in the same, but the data are processed for easy use with <code>chillR</code>.
If drop_most was set to <code>TRUE</code>, most columns are dropped. If the
<code>location</code> input was a list of weather datasets, all elements of the
list will be processed.
**IMPORTANT NOTE:** as of <code>chillR</code> version 0.73, the output format no
longer contains a list element that specifies the database name, because this
has been considered confusing (and annoying) by various users. This means,
however, that some earlier calls to results from the <code>handle_gsod</code> function
may produce errors now. 
Also note that a few parameters, <code>station_list</code>, <code>drop_most</code>,
<code>quiet</code>, <code>add_station_name</code> are no longer needed due to some
reworking of the function's mechanisms. After careful consideration, we
decided to drop these parameters entirely, which may lead to some downward
compatibility problems.
Apologies for any inconvenience caused by this transition. If you want to
keep using the previous function (which is much slower), feel free to adopt
the deprecated <code>handle_gsod_old</code> function - but note that this will no
longer be updated and may disappear eventually.
</p>


<h3>Note</h3>

<p>Many databases have data quality flags, which may sometimes indicate
that data aren't reliable. These are not considered by this function!
</p>
<p>For many places, the GSOD database is quite patchy, and the length of the
record indicated in the summary file isn't always very useful (e.g. there
could only be two records for the first and last date). Files are downloaded
by year, so if we specify a long interval, this may take a bit of time.
</p>


<h3>Author(s)</h3>

<p>Adrian Fülle, Lars Caspersen, Eike Luedeling
</p>


<h3>References</h3>

<p>The chillR package:
</p>
<p>Luedeling E, Kunz A and Blanke M, 2013. Identification of chilling and heat
requirements of cherry trees - a statistical approach. International Journal
of Biometeorology 57,679-689.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#coordinates of Bonn
long &lt;- 7.0871843
lat &lt;- 50.7341602

#get a list of close-by weather stations
# stationlist &lt;-
#   handle_gsod(action = "list_stations",
#               time_interval = c(1995,2000),
#               location = c(long,lat))

#download data
# test_data &lt;-
#   handle_gsod(action = "download_weather",
#               time_interval = c(1995,2000),
#               location = stationlist$chillR_code[c(1,2)])
# 
# format downloaded data
# test_data_clean &lt;- handle_gsod(action = test_data)

## data deletion on disk for clean_up

# functions will ask for confirmation in the console - 'y' for yes to
# confirm deletion, anything else cancels the deletion

# handle_gsod(action = "delete",
#             clean_up = "all",
#             override_confirm_delete = TRUE)

</code></pre>

<hr>
<h2 id='handle_gsod_old'>Deprecated version of handle_gsod. List, download or convert to chillR format data from the Global Summary of
the Day database</h2><span id='topic+handle_gsod_old'></span>

<h3>Description</h3>

<p><em>This function is deprecated, but it will be retained for a
few generations of updates.</em> Its functionality has been fully replaced by the
new version of the <code><a href="#topic+handle_gsod">handle_gsod</a></code> function, which does the same
job, but much faster. That's probably the function you really want to use.
</p>
<p>This function can do three things related to the Global Summary of the Day
(&quot;GSOD&quot;) database from the National Climatic Data Centre (NCDC) of the
National Oceanic and Atmospheric Administration (NOAA): </p>

<ul>
<li><p>1. It can list stations that are close to a specified position (geographic coordinates).
</p>
</li>
<li><p>2. It can retrieve weather data for a named weather station (or a vector of multiple stations).
For the name, the chillRcode from the list returned by the <code>list_stations</code> operation
should be used.
</p>
</li>
<li><p>3. It can 'clean' downloaded data (for one or multiple stations), so that they can easily be used in chillR
</p>
<p>Which of these functions is carried out depends on the action argument.</p>
</li></ul>

<p>This function can run independently, but it is also called by the
<code><a href="#topic+get_weather">get_weather</a></code> and <code><a href="#topic+weather2chillR">weather2chillR</a></code> functions, which some users might find a bit
easier to handle.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>handle_gsod_old(
  action,
  location = NA,
  time_interval = NA,
  station_list = NULL,
  stations_to_choose_from = 25,
  drop_most = TRUE,
  end_at_present = TRUE,
  add.DATE = TRUE,
  quiet = FALSE,
  add_station_name = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="handle_gsod_old_+3A_action">action</code></td>
<td>
<p>accepts 3 types of inputs to decide on the mode of action for the function.</p>

<ul>
<li><p>if this is the character string <code>"list_stations"</code>, the function
will return a list of the weather stations from the database that are
closest to the geographic coordinates specified by location.
</p>
</li>
<li><p>if this is the character string <code>"download_weather"</code>, the function will attempt to download
weather data from the database for the station named by the location
argument, which should then be a character string corresponding to the
<code>chillRcode</code> of the station (which you can get by running this function in
<code>'list_stations'</code> mode).
</p>
</li>
<li><p>if this is a collection of outputs obtained by
running this function in the <code>'download weather'</code> mode), the function cleans the
weather files and make them ready for use in <code>chillR</code>. If the input is just a dataframe
(not a list, as produced with this function), you have to specify the
database name with the database argument.</p>
</li></ul>
</td></tr>
<tr><td><code id="handle_gsod_old_+3A_location">location</code></td>
<td>
<p>either a vector of geographic coordinates (for the
<code>'list_stations'</code> mode), or the 'chillRcode' of a weather station in the
specified database (for the <code>'download_weather'</code> mode). When running this
function for data cleaning only, this is not needed. For the
<code>'download_weather'</code> mode, this can also be a vector of 'chillRcodes',
in which case records for all stations will be downloaded. The data cleaning
mode can also handle a list of downloaded weather datasets.</p>
</td></tr>
<tr><td><code id="handle_gsod_old_+3A_time_interval">time_interval</code></td>
<td>
<p>numeric vector with two elements, specifying the start
and end date of the period of interest. Only required when running in
<code>'list_stations'</code> or <code>'download_weather'</code> mode.</p>
</td></tr>
<tr><td><code id="handle_gsod_old_+3A_station_list">station_list</code></td>
<td>
<p>if the list of weather stations has already been
downloaded, the list can be passed to the function through this argument.
This can save a bit of time, since it can take a bit of time to download the
list, which can have several MB.</p>
</td></tr>
<tr><td><code id="handle_gsod_old_+3A_stations_to_choose_from">stations_to_choose_from</code></td>
<td>
<p>if the location is specified by geographic
coordinates, this argument determines the number of nearby stations in the
list that is returned.</p>
</td></tr>
<tr><td><code id="handle_gsod_old_+3A_drop_most">drop_most</code></td>
<td>
<p>boolean variable indicating if most columns should be
dropped from the file. If set to <code>TRUE</code> (default), only essential columns for
running chillR functions are retained.</p>
</td></tr>
<tr><td><code id="handle_gsod_old_+3A_end_at_present">end_at_present</code></td>
<td>
<p>boolean variable indicating whether the interval of
interest should end on the present day, rather than extending until the end
of the year specified under <code>time_interval[2]</code> (if <code>time_interval[2]</code> is the
current year).</p>
</td></tr>
<tr><td><code id="handle_gsod_old_+3A_add.date">add.DATE</code></td>
<td>
<p>is a boolean parameter to be passed to <code><a href="#topic+make_all_day_table">make_all_day_table</a></code> if <code>action</code> is 
a collection of outputs (in the form of list) from the function in the downloading format.</p>
</td></tr>
<tr><td><code id="handle_gsod_old_+3A_quiet">quiet</code></td>
<td>
<p>is a boolean parameter to be passed to <code><a href="utils.html#topic+download.file">download.file</a></code> if
<code>action = "download_weather"</code>.</p>
</td></tr>
<tr><td><code id="handle_gsod_old_+3A_add_station_name">add_station_name</code></td>
<td>
<p>is a boolean parameter to include the name of the respective weather station in
the resulting data frame in case the function is used in the downloading or formatting mode.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The GSOD database is described here:
<a href="https://www.ncei.noaa.gov/access/metadata/landing-page/bin/iso?id=gov.noaa.ncdc:C00516">https://www.ncei.noaa.gov/access/metadata/landing-page/bin/iso?id=gov.noaa.ncdc:C00516</a>
</p>
<p>under the <code>'list_stations'</code> mode, several formats are possible for specifying
the location vector, which can consist of either two or three coordinates
(it can include elevation). Possible formats include <code>c(1, 2, 3)</code>, <code>c(1, 2)</code>,
<code>c(x = 1, y = 2, z = 3)</code>, <code>c(lat = 2, long = 1, elev = 3)</code>. If elements of the vector are not
names, they are interpreted as c(Longitude, Latitude, Elevation).
</p>
<p>The 'chillRCode' is generated by this function, when it is run with
geographic coordinates as location inputs. In the list of nearby stations
that is returned then, the chillRCode is provided and can then be used as
input for running the function in 'downloading' mode. For downloading the
data, use the same call as before but replace the location argument with the
chillRCode.
</p>


<h3>Value</h3>

<p>The output depends on the action argument. If it is <code>'list_stations'</code>,
the function returns a list of <code>station_to_choose_from</code> weather stations that
are close to the specified location. This list also contains information
about how far away these stations are (in km), how much the elevation
difference is (if elevation is specified; in m) and how much overlap there
is between the data contained in the database and the time period specified
by <code>time_interval</code>. If action is <code>'download_weather'</code> the output is a list of
two elements: 1. <code>database="GSOD"</code> 2. the downloaded weather record, extended
to the full duration of the specified time interval. If the <code>location</code> input
was a vector of stations, the output will be a list of such objects.
If action is a weather <code>data.frame</code> or a weather record downloaded with
this function (in <code>'download_weather'</code> mode), the output is the same
data in a format that is easy to use in chillR. If drop_most was set to
<code>TRUE</code>, most columns are dropped. If the <code>location</code> input was a
list of weather datasets, all elements of the list will be processed.
</p>


<h3>Note</h3>

<p>Many databases have data quality flags, which may sometimes indicate
that data aren't reliable. These are not considered by this function!
</p>
<p>For many places, the GSOD database is quite patchy, and the length of the
record indicated in the summary file isn't always very useful (e.g. there
could only be two records for the first and last date). Files are downloaded
by year, so if we specify a long interval, this may take a bit of time.
</p>


<h3>Author(s)</h3>

<p>Eike Luedeling and Eduardo Fernandez
</p>


<h3>References</h3>

<p>The chillR package:
</p>
<p>Luedeling E, Kunz A and Blanke M, 2013. Identification of chilling and heat
requirements of cherry trees - a statistical approach. International Journal
of Biometeorology 57,679-689.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# List the near weather stations
# stat_list &lt;- handle_gsod_old(action = "list_stations",
#                          location = c(x = -122, y = 38.5),
#                          time_interval = c(2002, 2002))

# the line above takes longer to run than CRAN allows for examples.
# The line below therefore
# generates an abbreviated stat_list that allows running the code.

# stat_list &lt;- data.frame(chillR_code = c("724828_99999",
#                                         "724828_93241",
#                                         "720576_174"),
#                         STATION.NAME = c("NUT TREE",
#                                          "NUT TREE AIRPORT",
#                                          "UNIVERSITY AIRPORT"),
#                         Lat = c(38.383, 38.378, 38.533),
#                         Long = c(-121.967, -121.958, -121.783),
#                         BEGIN = c(20010811, 20060101, 20130101),
#                         END = c(20051231, 20160110, 20160109))

# gw &lt;- handle_gsod_old(action = "download_weather",
#                   location = "724828_93241",
#                   time_interval = c(2010, 2012),
#                   station_list = stat_list,
#                   quiet = TRUE)

# weather &lt;- handle_gsod_old(gw, add.DATE = FALSE)[[1]]$weather

# make_chill_plot(tempResponse(stack_hourly_temps(fix_weather(weather)),
#                              Start_JDay = 300, End_JDay = 50),
#                 "Chill_Portions", start_year = 2010,
#                 end_year = 2012, metriclabel = "Chill Portions",
#                 misstolerance = 50)

</code></pre>

<hr>
<h2 id='handle_ucipm'>List, download or convert to chillR format data from the UCIPM database</h2><span id='topic+handle_ucipm'></span>

<h3>Description</h3>

<p>This function can do three things related to the University of California
Integrated Pest Management (UCIPM) database: 1. it can list stations that
are close to a specified position (geographic coordinates) 2. it can
retrieve weather data for a named weather station 3. it can 'clean'
downloaded data, so that they can easily be used in chillR Which of these
functions is carried out depends on the action argument.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>handle_ucipm(
  action,
  location = NA,
  time_interval = NA,
  station_list = california_stations,
  stations_to_choose_from = 25,
  drop_most = TRUE,
  end_at_present = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="handle_ucipm_+3A_action">action</code></td>
<td>
<p>if this is the character string &quot;list_stations&quot;, the function
will return a list of the weather stations from the database that are
closest to the geographic coordinates specified by location.  if this is the
character string &quot;download_weather&quot;, the function will attempt to download
weather data from the database for the station named by the location
argument, which should then be a character string corresponding to the
chillRcode of the station (which you can get by running this function in
'list_stations mode) if this is a downloaded weather file (downloaded by
running this function in 'download weather' mode), the function cleans the
file and makes it ready for use in chillR. If the input is just a dataframe
(not a list, as produced with this function), you have to specify the
database name with the database argument</p>
</td></tr>
<tr><td><code id="handle_ucipm_+3A_location">location</code></td>
<td>
<p>either a vector of geographic coordinates (for the
'list_stations' mode), or the 'chillRcode' of a weather station in the
specified database (for the 'download_weather' mode. When running this
function for data cleaning only, this is not needed.</p>
</td></tr>
<tr><td><code id="handle_ucipm_+3A_time_interval">time_interval</code></td>
<td>
<p>numeric vector with two elements, specifying the start
and end date of the period of interest. Only required when running in
'list_stations' or 'download weather' mode</p>
</td></tr>
<tr><td><code id="handle_ucipm_+3A_station_list">station_list</code></td>
<td>
<p>if the list of weather stations has already been
downloaded, the list can be passed to the function through this argument.
This can save a bit of time, since it can take a bit of time to download the
list, which can have several MB.</p>
</td></tr>
<tr><td><code id="handle_ucipm_+3A_stations_to_choose_from">stations_to_choose_from</code></td>
<td>
<p>if the location is specified by geographic
coordinates, this argument determines the number of nearby stations in the
list that is returned.</p>
</td></tr>
<tr><td><code id="handle_ucipm_+3A_drop_most">drop_most</code></td>
<td>
<p>boolean variable indicating if most columns should be
dropped from the file. If set to TRUE (default), only essential columns for
running chillR functions are retained.</p>
</td></tr>
<tr><td><code id="handle_ucipm_+3A_end_at_present">end_at_present</code></td>
<td>
<p>boolean variable indicating whether the interval of
interest should end on the present day, rather than extending until the end
of the year specified under time_interval[2] (if time_interval[2] is the
current year).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function can run independently, but it is also called by the
get_weather and weather2chillR functions, which some users might find a bit
easier to handle.
</p>
<p>the UCIPM dataset is described here: http://ipm.ucdavis.edu/WEATHER/
</p>
<p>under the 'list_stations' mode, several formats are possible for specifying
the location vector, which can consist of either two or three coordinates
(it can include elevation). Possible formats include c(1,2,3), c(1,2),
c(x=1,y=2,z=3), c(lat=2,long=1,elev=3). If elements of the vector are not
names, they are interpreted as c(Longitude, Latitude, Elevation).
</p>
<p>The 'chillRCode' is generated by this function, when it is run with
geographic coordinates as location inputs. In the list of nearby stations
that is returned then, the chillRCode is provided and can then be used as
input for running the function in 'downloading' mode. For downloading the
data, use the same call as before but replace the location argument with the
chillRCode.
</p>


<h3>Value</h3>

<p>The output depends on the action argument. If it is 'list_stations',
the function returns a list of station_to_choose_from weather stations that
are close to the specified location. This list also contains information
about how far away these stations are (in km), how much the elevation
difference is (if elevation is specified; in m) and how much overlap there
is between the data contained in the database and the time period specified
by time_interval. If action is 'download_weather' the output is a list of
two elements: 1. database=&quot;CIMIS&quot; 2. the downloaded weather record, extended
to the full duration of the specified time interval. If action is a weather
data.frame or a weather record downloaded with this function (in
'download_weather' mode), the output is the same data in a format that is
easy to use in chillR. If drop_most was set to TRUE, most columns are
dropped.
</p>


<h3>Note</h3>

<p>Many databases have data quality flags, which may sometimes indicate
that data aren't reliable. These are not considered by this function!
</p>
<p>The station list provided by the UC IPM database doesn't contain geographic
positions of the stations, which can only be accessed by station-specific
websites. This function will access this information only if it was not
given on the website in early 2016. Station information based on a download
at that time is stored in the california_station dataset included in chillR.
This was done to reduce the run time for the handle_ucipm function. It will
probably be okay for the foreseeable future (stations don't change very
quickly). A new version of this table can be produces with the
make_california_UCIPM_station_list() function.
</p>


<h3>Author(s)</h3>

<p>Eike Luedeling
</p>


<h3>References</h3>

<p>The chillR package:
</p>
<p>Luedeling E, Kunz A and Blanke M, 2013. Identification of chilling and heat
requirements of cherry trees - a statistical approach. International Journal
of Biometeorology 57,679-689.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# All examples are disabled, because the database is sometimes unavailable. This then generates
# an error when R runs its package functionality checks. To run the examples, remove the # mark,
# before running the code.
#
#handle_ucipm(action="list_stations",location=c(x=-122,y=38.5),time_interval=c(2012,2012))
#gw&lt;-handle_ucipm(action="download_weather",location="WINTERS.A",time_interval=c(2012,2012))
#weather&lt;-handle_ucipm(gw)$weather
#make_chill_plot(tempResponse(stack_hourly_temps(fix_weather(weather)),Start_JDay=300,End_JDay=50),
#                "Chill_Portions",start_year=2010,end_year=2012,metriclabel="Chill Portions",
#                misstolerance = 50)

</code></pre>

<hr>
<h2 id='identify_common_string'>Identify shared leading or trailing character strings</h2><span id='topic+identify_common_string'></span>

<h3>Description</h3>

<p>Compares all elements of a vector of numbers or character strings and returns TRUE
if they are all the same, FALSE otherwise.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>identify_common_string(strings, leading = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="identify_common_string_+3A_strings">strings</code></td>
<td>
<p>vector of strings to be evaluated.</p>
</td></tr>
<tr><td><code id="identify_common_string_+3A_leading">leading</code></td>
<td>
<p>boolean variable indicating whether the function should look for common strings at the beginning
(leading==TRUE) or end (leading==FALSE) of the strings. Default is TRUE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>if there is a leading (if leading==TRUE) or trailing (if leading==FALSE) string that all elements of
strings have in common, this string is returned; NA otherwise.
</p>


<h3>Author(s)</h3>

<p>Eike Luedeling
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  identify_common_string(c("Temp_01","Temp_02","Temp_03"))
  identify_common_string(c("Temp_01","Temp_02","Temp_03"),leading=FALSE)
  identify_common_string(c("file1.csv","file2.csv","file3.csv"),leading=FALSE)
    
</code></pre>

<hr>
<h2 id='interpolate_gaps'>Linear gap interpolation</h2><span id='topic+interpolate_gaps'></span>

<h3>Description</h3>

<p>This function linearly interpolates gaps in data series, such as daily
temperature records.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>interpolate_gaps(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="interpolate_gaps_+3A_x">x</code></td>
<td>
<p>a numeric vector, or a vector that can be coerced with as.numeric.
Missing values are either NA or non-numeric values.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function returns a list with two elements: interp is a new vector, in
which all gaps in x have been linearly interpolated. missing is a second
vector, which contains information on which values were filled in by
interpolation.
</p>


<h3>Value</h3>

<table>
<tr><td><code>interp</code></td>
<td>
<p> numeric vector, in which all gaps in x have been
linearly interpolated</p>
</td></tr> <tr><td><code>missing</code></td>
<td>
<p> boolean vector of the same length as
interp and x, which marks all gaps in x as TRUE</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Eike Luedeling
</p>


<h3>References</h3>

<p>Luedeling E, Kunz A and Blanke M, 2013. Identification of
chilling and heat requirements of cherry trees - a statistical approach.
International Journal of Biometeorology 57,679-689.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
weather&lt;-make_all_day_table(KA_weather)
Tmin_int&lt;-interpolate_gaps(KA_weather[,"Tmin"])
weather[,"Tmin"]&lt;-Tmin_int$interp
weather[,"Tmin_interpolated"]&lt;-Tmin_int$missing

Tmax_int&lt;-interpolate_gaps(KA_weather[,"Tmax"])
weather[,"Tmax"]&lt;-Tmax_int$interp
weather[,"Tmax_interpolated"]&lt;-Tmax_int$missing

#this function is integrated into the fix_weather function, but it can also be run on its own.


</code></pre>

<hr>
<h2 id='interpolate_gaps_hourly'>Interpolate gaps in hourly temperature records</h2><span id='topic+interpolate_gaps_hourly'></span>

<h3>Description</h3>

<p>Using idealized temperature curves for guidance, this function interpolated hourly
temperature data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>interpolate_gaps_hourly(
  hourtemps,
  latitude = 50,
  daily_temps = NULL,
  interpolate_remaining = TRUE,
  return_extremes = FALSE,
  minimum_values_for_solving = 5,
  runn_mean_test_length = 5,
  runn_mean_test_diff = 5,
  daily_patch_max_mean_bias = NA,
  daily_patch_max_stdev_bias = NA
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="interpolate_gaps_hourly_+3A_hourtemps">hourtemps</code></td>
<td>
<p>data.frame containing hourly temperatures. This has to
contain columns c(&quot;Year&quot;,&quot;Month&quot;,&quot;Day&quot;,&quot;Hour&quot;,&quot;Temp&quot;).</p>
</td></tr>
<tr><td><code id="interpolate_gaps_hourly_+3A_latitude">latitude</code></td>
<td>
<p>the geographic latitude (in decimal degrees) of the location
of interest</p>
</td></tr>
<tr><td><code id="interpolate_gaps_hourly_+3A_daily_temps">daily_temps</code></td>
<td>
<p>list of (chillR compliant) daily temperature data sets
for patching gaps in the record.</p>
</td></tr>
<tr><td><code id="interpolate_gaps_hourly_+3A_interpolate_remaining">interpolate_remaining</code></td>
<td>
<p>boolean parameter indicating whether gaps remaining
after the daily record has been patched (or after solving temperature equations,
if (daily_temps==NULL)) should be linearly interpolated.</p>
</td></tr>
<tr><td><code id="interpolate_gaps_hourly_+3A_return_extremes">return_extremes</code></td>
<td>
<p>boolean parameters indicating whether daily minimum
and maximum temperatures used for the interpolation should be part of the
output table. Defaults to FALSE.</p>
</td></tr>
<tr><td><code id="interpolate_gaps_hourly_+3A_minimum_values_for_solving">minimum_values_for_solving</code></td>
<td>
<p>integer specifying the minimum number of hourly
temperature values that must be available for the solving function to be
applied. Must be greater than 1 (otherwise you get an error). Since according to
the idealized temperature curves used here, a given daily extreme temperature
is related to hourly temperatures of about a 12-hour period, values above 12
are not useful. Note that relatively large numbers for this parameter raise the
reliability of the interpolated values, but they restrict the number of missing
values in a day, for which the procedure produces results.</p>
</td></tr>
<tr><td><code id="interpolate_gaps_hourly_+3A_runn_mean_test_length">runn_mean_test_length</code></td>
<td>
<p>integer specifying the length of the period, for
which a running mean test for is applied to daily records after the solving
procedure. This aims to remove spurious values that can sometimes arise during
solving. This test checks for all daily minimum and maximum temperature values,
if they differ from the mean of the surrounding values by more than
runn_mean_test_diff. If this is the case, they are set to NA, and have to be
filled by other means (from proxy data or by interpolation). Defaults to 5,
which means each value is compared to the mean of the 2 previous and 2
following days.</p>
</td></tr>
<tr><td><code id="interpolate_gaps_hourly_+3A_runn_mean_test_diff">runn_mean_test_diff</code></td>
<td>
<p>integer specifying the maximum tolerable difference
between solved daily extreme temperature values and the mean for the
surrounding days. See description of runn_mean_test_length for more details.
Defaults to 5.</p>
</td></tr>
<tr><td><code id="interpolate_gaps_hourly_+3A_daily_patch_max_mean_bias">daily_patch_max_mean_bias</code></td>
<td>
<p>maximum acceptable mean difference between
the daily extreme temperatures of daily temperature records used as proxy and
daily extreme temperatures in the dataset that is to be interpolated. If the
bias between stations is greater than this, the station is not considered
a useful proxy and not used for filling gaps.</p>
</td></tr>
<tr><td><code id="interpolate_gaps_hourly_+3A_daily_patch_max_stdev_bias">daily_patch_max_stdev_bias</code></td>
<td>
<p>maximum acceptable standard deviation of
the difference between the daily extreme temperatures of daily temperature
records used as proxy and daily extreme temperatures in the dataset that is
to be interpolated. If the bias between stations is greater than this,
the station is not considered a useful proxy and not used for filling gaps.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Many agroclimatic metrics are calculated from hourly temperature data. chillR
provides functions for generating hourly data from daily records, which are
often available. Small gaps in such daily records can easily be closed
through linear interpolation, with relatively small errors, so that complete
hourly records can be generated. However, many sites have recorded actual
hourly temperatures, which allow much more accurate site-specific assessments.
Such records quite often have gaps, which need to be closed before
calculating most agroclimatic metrics (such as Chill Portions). Linear
interpolation is not a good option for this, because daily temperature curves
are not linear. Moreover, when gaps exceed a certain number of hours,
important featured would be missed (e.g. interpolating between temperatures
at 8 pm and 8 am may miss all the cool hours of the day, which would greatly
distort chill estimates).
</p>
<p>This function solves this problem by using an idealized daily temperature
curve as guide to the interpolation of hourly temperature data.
</p>
<p>These are the steps:
1) produce an idealized temperature curve for the site (which requires
site latitude as an input), assuming minimum and maximum temperatures of
0 and 1 degrees C, respectively. The calculations are based on equations published
by Spencer (1971), Almorox et al. (2005) and Linvill (1990, though I
modified these slightly to produce a smooth curve). This curve describes
the expected relationship of the temperature for the respective hour with
minimum and maximum temperatures of the same, previous or next day
(depending on the time of day), according to idealized temperature curve.
At this point, however, these daily minimum or maximum temperatures aren't
known yet.
</p>
<p>2) determine minimum and maximum temperatures for each day. For each minimum
and maximum daily temperature, the expected relationships between hourly
temperatures and daily extremes determined in step 1, combined with the
hourly temperatures that were observed can be interpreted as an
overdetermined set of equations that define these temperatures. Since few
days will follow the ideal curve precisely, and there are usually more than
two equations that define the same daily temperature extreme value, these
equations can only be solved numerically. This is implemented with the
qr.solve function, which can provide estimates of the minimum and maximum
temperatures for all days from the available hourly records.
</p>
<p>3) interpolate gaps in the record of estimated daily temperature extremes.
There can be days, when the number of recorded hourly temperatures isn't
sufficient for inferring daily minimum or maximum temperatures. The resulting
gaps are closed by linear interpolation (this may produce poor results if
gaps are really large, but this isn't currently addressed).
</p>
<p>4) compute an idealized daily temperature
curve for all days, based on estimated daily temperature extremes (using
the make_hourly_temperatures function).
</p>
<p>5) calculate deviation of recorded temperatures from idealized curve.
</p>
<p>6) linearly interpolate deviation values using the interpolate_gaps
function.
</p>
<p>7) add interpolated deviation values to idealized temperature curve.
</p>


<h3>Value</h3>

<p>data frame containing interpolated temperatures for all hours within
the interval defined by the first and last day of the hourtemps input.
</p>


<h3>Author(s)</h3>

<p>Eike Luedeling
</p>


<h3>References</h3>

<p>Linvill DE, 1990. Calculating chilling hours and chill units from daily
maximum and minimum temperature observations. HortScience 25(1), 14-16.
</p>
<p>Spencer JW, 1971. Fourier series representation of the position of the Sun.
Search 2(5), 172.
</p>
<p>Almorox J, Hontoria C and Benito M, 2005. Statistical validation of
daylength definitions for estimation of global solar radiation in Toledo,
Spain. Energy Conversion and Management 46(9-10), 1465-1471)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

Winters_gaps&lt;-make_JDay(Winters_hours_gaps[1:2000,])
colnames(Winters_gaps)[5:6]&lt;-c("Temp","original_Temp")
interp&lt;-interpolate_gaps_hourly(hourtemps=Winters_gaps,latitude=38.5)

#plot results: interpolated temperatures are shown in red, measured temperatures in black.
plot(interp$weather$Temp[1:120]~c(interp$weather$JDay[1:120]+
   interp$weather$Hour[1:120]/24),type="l",
   col="RED",lwd=2,xlab="JDay",ylab="Temperature")
lines(interp$weather$Temp_measured[1:120]~c(interp$weather$JDay[1:120]+
   interp$weather$Hour[1:120]/24),lwd=2)

</code></pre>

<hr>
<h2 id='JDay_count'>Count days between two Julian dates</h2><span id='topic+JDay_count'></span>

<h3>Description</h3>

<p>This function counts the days between two Julian dates, taking into
account whether the season extends past the end of a calender year and
whether the count is to be done for a leap year.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>JDay_count(start_date, end_date, season = NA, leap_year = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="JDay_count_+3A_start_date">start_date</code></td>
<td>
<p>integer ranging from 1 to 366, indicating a Julian date.
This is the start date of the interval of interest.</p>
</td></tr>
<tr><td><code id="JDay_count_+3A_end_date">end_date</code></td>
<td>
<p>integer ranging from 1 to 366, indicating a Julian date.
This is the end date of the interval of interest.</p>
</td></tr>
<tr><td><code id="JDay_count_+3A_season">season</code></td>
<td>
<p>integer vector of length 2, specifying the beginning and end
of the phenology season, respectivcely. If this is not specified, the
start_date and end_date are used to define the season.</p>
</td></tr>
<tr><td><code id="JDay_count_+3A_leap_year">leap_year</code></td>
<td>
<p>either a Boolean parameter indicating whether the count
should be done for a leap year, or an integer specyfing the year, for
which the calculation is to be done. The function then determines
automatically, whether this is a leap year.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Boolean result (TRUE/FALSE) of the comparison.
</p>


<h3>Author(s)</h3>

<p>Eike Luedeling
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
JDay_count(start_date=320,end_date=20,season=c(305,59),leap_year=2004)

</code></pre>

<hr>
<h2 id='JDay_earlier'>Check whether a Julian date is before or after another one</h2><span id='topic+JDay_earlier'></span>

<h3>Description</h3>

<p>For two Julian dates, this function checks whether the first date
is earlier than the second date within a user-defined phenological season.
This is particularly useful for seasons that start in one year and end
in the next, because simple &gt; or &lt; operations can produce wrong results
then.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>JDay_earlier(check_date, ref_date, season = c(1, 366))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="JDay_earlier_+3A_check_date">check_date</code></td>
<td>
<p>integer ranging from 1 to 366, indicating a Julian date.
This is the date for which to check whether it is before the reference date.
If this is a vector, all elements are checked against the reference date.</p>
</td></tr>
<tr><td><code id="JDay_earlier_+3A_ref_date">ref_date</code></td>
<td>
<p>integer ranging from 1 to 366, indicating a Julian date.
This is the reference date.</p>
</td></tr>
<tr><td><code id="JDay_earlier_+3A_season">season</code></td>
<td>
<p>integer vector of length 2, specifying the beginning and end
of the phenology season, respectivcely.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Boolean result (TRUE/FALSE) of the comparison.
</p>


<h3>Author(s)</h3>

<p>Eike Luedeling
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
JDay_earlier(check_date=10,ref_date=365,season=c(305,59))

</code></pre>

<hr>
<h2 id='JDay_later'>Check whether a Julian date is after another one</h2><span id='topic+JDay_later'></span>

<h3>Description</h3>

<p>For two Julian dates, this function checks whether the first date
is later than the second date within a user-defined phenological season.
This is particularly useful for seasons that start in one year and end
in the next, because simple &gt; or &lt; operations can produce wrong results
then.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>JDay_later(check_date, ref_date, season = c(1, 366))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="JDay_later_+3A_check_date">check_date</code></td>
<td>
<p>integer ranging from 1 to 366, indicating a Julian date.
This is the date for which to check whether it is after the reference date.
If this is a vector, all elements are checked against the reference date.</p>
</td></tr>
<tr><td><code id="JDay_later_+3A_ref_date">ref_date</code></td>
<td>
<p>integer ranging from 1 to 366, indicating a Julian date.
This is the reference date.</p>
</td></tr>
<tr><td><code id="JDay_later_+3A_season">season</code></td>
<td>
<p>integer vector of length 2, specifying the beginning and end
of the phenology season, respectivcely.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Boolean result (TRUE/FALSE) of the comparison.
</p>


<h3>Author(s)</h3>

<p>Eike Luedeling
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
JDay_later(check_date=10,ref_date=365,season=c(305,59))

</code></pre>

<hr>
<h2 id='KA_bloom'>Cherry bloom data for Klein-Altendorf, Germany</h2><span id='topic+KA_bloom'></span>

<h3>Description</h3>

<p>Bloom data of sweet cherry var. 'Schneiders spaete Knorpelkirsche' recorded
at Klein-Altendorf, Germany, the experimental station of the University of
Bonn
</p>


<h3>Format</h3>

<p>A data frame with the following 2 variables.  </p>

<dl>
<dt>Year</dt><dd><p>a numeric vector, indicating the observation year</p>
</dd>
<dt>pheno</dt><dd><p> a vector that, when coerced by as.numeric, contains
bloom data in Julian dates (day of the year)</p>
</dd> </dl>



<h3>Source</h3>

<p>data were collected by Achim Kunz and Michael Blanke, University of
Bonn
</p>


<h3>References</h3>

<p>Luedeling E, Kunz A and Blanke M, 2013. Identification of
chilling and heat requirements of cherry trees - a statistical approach.
International Journal of Biometeorology 57,679-689.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(KA_bloom)

</code></pre>

<hr>
<h2 id='KA_weather'>Weather data for Klein-Altendorf, Germany</h2><span id='topic+KA_weather'></span>

<h3>Description</h3>

<p>Daily temperature data from Klein-Altendorf, Germany, for use in combination
with the example phenology dataset KA_bloom.
</p>


<h3>Format</h3>

<p>A data frame with observations on the following 5 variables.
</p>
 <dl>
<dt>Year</dt><dd><p>a numeric vector - the observation year</p>
</dd>
<dt>Month</dt><dd><p>a numeric vector - the observation month</p>
</dd>
<dt>Day</dt><dd><p>a numeric vector - the observation day</p>
</dd>
<dt>Tmax</dt><dd><p>a numeric vector - daily maximum temperature</p>
</dd>
<dt>Tmin</dt><dd><p>a numeric vector - daily minimum temperature</p>
</dd> </dl>



<h3>Source</h3>

<p>data were collected by Achim Kunz and Michael Blanke, University of
Bonn
</p>


<h3>References</h3>

<p>Luedeling E, Kunz A and Blanke M, 2013. Identification of
chilling and heat requirements of cherry trees - a statistical approach.
International Journal of Biometeorology 57,679-689.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(KA_weather)

</code></pre>

<hr>
<h2 id='leap_year'>Leap year finder</h2><span id='topic+leap_year'></span>

<h3>Description</h3>

<p>This function determines whether a given year is a leap year
</p>


<h3>Usage</h3>

<pre><code class='language-R'>leap_year(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="leap_year_+3A_x">x</code></td>
<td>
<p>integer value, representing year number</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Takes a year number as input, and returns TRUE if this is a leap year, and
FALSE if not
</p>


<h3>Value</h3>

<p>boolean variable (TRUE or FALSE)
</p>


<h3>Author(s)</h3>

<p>Eike Luedeling, but based on pseudocode from Wikipedia
</p>


<h3>References</h3>

<p>https://en.wikipedia.org/wiki/Leap_year
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

leap_year(2015)  
leap_year(2016)

 
</code></pre>

<hr>
<h2 id='load_ClimateWizard_scenarios'>Load climate wizard scenarios</h2><span id='topic+load_ClimateWizard_scenarios'></span>

<h3>Description</h3>

<p>This is a slightly modified version of the load_temperature_scenarios function that can
load climate scenarios downloaded with the getClimateWizardData and saved with the
save_temperature_scenarios function. This separate function is necessary, because the
climate scenarios are expressed as lists, with one element being a data.frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>load_ClimateWizard_scenarios(path, prefix)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="load_ClimateWizard_scenarios_+3A_path">path</code></td>
<td>
<p>character string indicating the file path where the files are to be written.</p>
</td></tr>
<tr><td><code id="load_ClimateWizard_scenarios_+3A_prefix">prefix</code></td>
<td>
<p>character string specifying the prefix for all files.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of temperature scenarios.
</p>


<h3>Author(s)</h3>

<p>Eike Luedeling
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
temps&lt;-list(Element1=data.frame(a=1,b=2),Element2=data.frame(a=c(2,3),b=c(8,4)))
# save_temperature_scenarios(temps,path=getwd(),prefix="temperatures")
# temps_reloaded&lt;-load_temperature_scenarios(path=getwd(),prefix="temperatures")

 
</code></pre>

<hr>
<h2 id='load_temperature_scenarios'>Load temperature scenarios</h2><span id='topic+load_temperature_scenarios'></span>

<h3>Description</h3>

<p>The temperature_generation can produce synthetic temperature scenarios, but it can take a while
to run, especially for large ensembles of climate scenarios. The save_temperature_scenarios
function can then save these scenarios to disk as a series of .csv files, so that they can
later be used again, without re-running the generation function.
Conversely, the load_temperature_scenarios function allows reading the data back into R.
This function also works with any other list of data.frames.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>load_temperature_scenarios(path, prefix)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="load_temperature_scenarios_+3A_path">path</code></td>
<td>
<p>character string indicating the file path where the files are to be written.</p>
</td></tr>
<tr><td><code id="load_temperature_scenarios_+3A_prefix">prefix</code></td>
<td>
<p>character string specifying the prefix for all files.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of temperature scenarios.
</p>


<h3>Author(s)</h3>

<p>Eike Luedeling
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
temps&lt;-list(Element1=data.frame(a=1,b=2),Element2=data.frame(a=c(2,3),b=c(8,4)))
# save_temperature_scenarios(temps,path=getwd(),prefix="temperatures")
# temps_reloaded&lt;-load_temperature_scenarios(path=getwd(),prefix="temperatures")

 
</code></pre>

<hr>
<h2 id='make_all_day_table'>Fill in missing days in incomplete time series</h2><span id='topic+make_all_day_table'></span>

<h3>Description</h3>

<p>Time series often have gaps, and these are often not marked by 'no data'
values but simply missing from the dataset. This function completes the time
series by adding lines for all these missing records. For these lines, all
values are set to 'NA'. By setting timestep&lt;-&quot;hour&quot;, this function can also
process hourly data. Where data are provided at a time resolution that is finer
than timestep, values are aggregated (by calculating the mean) to timestep
resolution (e.g. when data are at 15-minute resolution, they will be aggregated
to hourly average values - at timestep==&quot;hour&quot; - or daily average values - at
timestep==&quot;day&quot;).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_all_day_table(
  tab,
  timestep = "day",
  input_timestep = timestep,
  tz = "GMT",
  add.DATE = TRUE,
  no_variable_check = FALSE,
  aggregation_hours = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_all_day_table_+3A_tab">tab</code></td>
<td>
<p>a data.frame containing a time series dataset. It should have
columns c(&quot;Year&quot;, &quot;Month&quot;, &quot;Day&quot;) or c(&quot;YEAR&quot;, &quot;MONTH&quot;,&quot;DAY&quot;) or &quot;YEARMODA&quot;.</p>
</td></tr>
<tr><td><code id="make_all_day_table_+3A_timestep">timestep</code></td>
<td>
<p>time step for the table. This defaults to 'day' but can also be 'hour'</p>
</td></tr>
<tr><td><code id="make_all_day_table_+3A_input_timestep">input_timestep</code></td>
<td>
<p>can also be 'day' or 'hour' and defaults to the value assigned
to timestep. If timestep is 'day' and input_timestep is 'hour', hourly records are
aggregated to daily Tmin, Tmean and Tmax.</p>
</td></tr>
<tr><td><code id="make_all_day_table_+3A_tz">tz</code></td>
<td>
<p>timezone. Defaults to GMT. While it isn't important in what time zone
the temperatures were recorded, the onset of daylight savings time can cause problems.
'GMT' is the correct setting in cases were the recorded times weren't adjusted
according to daylight savings time (i.e. no hours omitted or double-counted because
of such adjustment).</p>
</td></tr>
<tr><td><code id="make_all_day_table_+3A_add.date">add.DATE</code></td>
<td>
<p>boolean parameter indicating whether a column called DATE which
contains the IOSdate should be added to the output data.frame.</p>
</td></tr>
<tr><td><code id="make_all_day_table_+3A_no_variable_check">no_variable_check</code></td>
<td>
<p>boolean parameter to indicate whether the function should
check if the dataset contains the usual chillR temperature variables. Defaults to
TRUE, but should be set to FALSE for different data formats.</p>
</td></tr>
<tr><td><code id="make_all_day_table_+3A_aggregation_hours">aggregation_hours</code></td>
<td>
<p>vector or list consisting of three integers that specify how
the function should search for daily minimum and maximum temperatures in hourly
datasets, when not all hourly temperatures have been observed. This is only relevant
during conversion from hourly to daily data. Tmin and Tmax can only be derived when
temperatures have been recorded during the coldest and warmest parts of the day,
respectively. The function should therefore check if records are available for these
times. The elements of 'aggregation_hours' describe window sizes for the times (as
number of hours), during which the coldest and warmest temperature typically occurs.
The first two elements (which can be named 'min_hours' and 'max_hours')
specify the number of hours contained in these windows for the cold and warm parts
of the day, respectively. These hours are determined by computing mean hourly
temperatures over the entire weather record, disaggregated by month to account for
the impact of daylength. The third element, 'hours_needed' specifies how many
records during these windows have to have been recorded. 'aggregation_hours'
defaults to NULL, in which case the parameter is ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data frame containing all the columns of the input data frame, but
one row for each day between the start and end of the dataset. Data values
for the missing rows are filled in as 'NA'. Dates are expressed as
c(&quot;YEARMODA&quot;,&quot;DATE&quot;,&quot;Year&quot;,&quot;Month&quot;,&quot;Day&quot;). In this, 'DATE' is the date in
ISOdate format.
</p>


<h3>Author(s)</h3>

<p>Eike Luedeling
</p>


<h3>References</h3>

<p>Luedeling E, Kunz A and Blanke M, 2013. Identification of
chilling and heat requirements of cherry trees - a statistical approach.
International Journal of Biometeorology 57,679-689.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#fill in missing lines in a weather dataset (modified from KA_weather)
day_to_day&lt;-make_all_day_table(KA_weather[c(1:10,20:30),],timestep="day")

#fill in missing hours in the Winters_hours_gaps dataset
Winters_hours&lt;-subset(Winters_hours_gaps, select = -c(Temp_gaps))[1:2000,]
hour_to_hour&lt;-make_all_day_table(Winters_hours,timestep="hour",input_timestep="hour")

#convert Winters_hours_gaps dataset into daily temperature data (min, max, mean)
hour_to_day&lt;-make_all_day_table(Winters_hours,timestep="day",input_timestep="hour")
hour_to_day&lt;-make_all_day_table(Winters_hours,timestep="day",input_timestep="hour",
                               aggregation_hours=c(3,3,2))

</code></pre>

<hr>
<h2 id='make_california_UCIPM_station_list'>Makes a list of the UC IPM weather stations</h2><span id='topic+make_california_UCIPM_station_list'></span>

<h3>Description</h3>

<p>Makes a list of the weather stations contained in the UC IPM database, with
geographic coordinates. This requires parsing through quite a few websites,
because the coordinates don't seem to be stored in one central (and easily
accessible) place. Hence this is much slower than one might expect. A
shortcut is the california_stations dataset supplied with chillR, which
contains the result of running this function in February 2016. The default
in the other relevant functions will be the use of this pre-stored list, but
if the current station coverage is needed, this function can help. Having
said this, station coverage probably won't change very rapidly, so in most
cases, the california_stations dataset should be enough.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_california_UCIPM_station_list()
</code></pre>


<h3>Value</h3>

<p>a data.frame containing stations from the California UC IPM database
(), with the following columns: &quot;Name&quot;, &quot;Code&quot;, &quot;Interval&quot;, &quot;Lat&quot;, &quot;Long&quot;,
&quot;Elev&quot;.
</p>


<h3>Author(s)</h3>

<p>Eike Luedeling
</p>


<h3>References</h3>

<p>The chillR package:
</p>
<p>Luedeling E, Kunz A and Blanke M, 2013. Identification of chilling and heat
requirements of cherry trees - a statistical approach. International Journal
of Biometeorology 57,679-689.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#cali_stats&lt;-make_california_UCIPM_station_list()
</code></pre>

<hr>
<h2 id='make_chill_plot'>Plot climate metrics over time</h2><span id='topic+make_chill_plot'></span>

<h3>Description</h3>

<p>This function generates a plot of a climate metric over multiple years,
including an indication of data quality, i.e. the share of missing values.
Output can be either an R plot or a .png image
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_chill_plot(
  chill,
  model,
  start_year = NA,
  end_year = NA,
  metriclabel = NULL,
  yearlabel = "End_year",
  misstolerance = 10,
  image_type = NA,
  outpath = NA,
  filename = NA,
  fonttype = "serif",
  plotylim = NA,
  plottitle = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_chill_plot_+3A_chill">chill</code></td>
<td>
<p>a chill object generated either with the chilling function or
with tempResponse. For this function to work properly, the chill object
should have been subjected to quality control (i.e. metrics should have been
calculated from weather records with a QC element. If you prepare weather
data with fix_weather, this should work.)</p>
</td></tr>
<tr><td><code id="make_chill_plot_+3A_model">model</code></td>
<td>
<p>the name of the column of the chill object that contains the
metric to be displayed</p>
</td></tr>
<tr><td><code id="make_chill_plot_+3A_start_year">start_year</code></td>
<td>
<p>the first year shown in the diagram. Default
to NA, which means the first date on record is used as start_year.</p>
</td></tr>
<tr><td><code id="make_chill_plot_+3A_end_year">end_year</code></td>
<td>
<p>the last year shown in the diagram.  Default
to NA, which means the last date on record is used as end_year.</p>
</td></tr>
<tr><td><code id="make_chill_plot_+3A_metriclabel">metriclabel</code></td>
<td>
<p>character string that can be used for labeling the y-axis
in the plot. If this is not specified, the function will use the model
argument.</p>
</td></tr>
<tr><td><code id="make_chill_plot_+3A_yearlabel">yearlabel</code></td>
<td>
<p>character string indicating the name of the column in the chill
object that is to be used for the time axis.</p>
</td></tr>
<tr><td><code id="make_chill_plot_+3A_misstolerance">misstolerance</code></td>
<td>
<p>Percentage of missing values that leads to exclusion of
an annual value from plotting.</p>
</td></tr>
<tr><td><code id="make_chill_plot_+3A_image_type">image_type</code></td>
<td>
<p>Character string indicating the file format that should be
output. Image files are only produced for the moment, if this is &quot;png&quot;. All
other values, as well as the default NA lead to output as an R plot only.</p>
</td></tr>
<tr><td><code id="make_chill_plot_+3A_outpath">outpath</code></td>
<td>
<p>Path to the folder where the images should be saved. Should
include a trailing &quot;/&quot;.</p>
</td></tr>
<tr><td><code id="make_chill_plot_+3A_filename">filename</code></td>
<td>
<p>Suffix of the filenames for output graph files. These will
be amended by the name of the metric and by the file extension.</p>
</td></tr>
<tr><td><code id="make_chill_plot_+3A_fonttype">fonttype</code></td>
<td>
<p>The type of font to be used for the figures. Can be 'serif'
(default) for a Times New Roman like font, 'sans' for an Arial type font or
'mono' for a typewriter type font.</p>
</td></tr>
<tr><td><code id="make_chill_plot_+3A_plotylim">plotylim</code></td>
<td>
<p>numeric vector of length 2 indicating the extent of the y axis.
Defaults to NA, which means that y limits are determined automatically.</p>
</td></tr>
<tr><td><code id="make_chill_plot_+3A_plottitle">plottitle</code></td>
<td>
<p>character string indicating the plot title. Defaults to NULL for
no title.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Plots climatic metrics computed with chilling or tempResponse, indicating
the completeness of the temperature record by shades of gray.
</p>


<h3>Value</h3>

<p>only a side effect - plot of climate metric over time; bars are
color coded according to the number of missing values. Bars with numbers of
missing values above the misstolerance are not show and instead marked '*'
(to distinguish them from 0 counts)
</p>


<h3>Author(s)</h3>

<p>Eike Luedeling
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
make_chill_plot(tempResponse(stack_hourly_temps(fix_weather(KA_weather[KA_weather$Year&gt;2005,]))),
"Chill_Portions",start_year=1990,end_year=2010,metriclabel="Chill Portions")

 
</code></pre>

<hr>
<h2 id='make_climate_scenario'>Make climate scenario</h2><span id='topic+make_climate_scenario'></span>

<h3>Description</h3>

<p>Function to make climate scenarios for plotting from a list of climate metric data, e.g.
produced by <code><a href="#topic+tempResponse_daily_list">tempResponse_daily_list</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_climate_scenario(
  metric_summary,
  caption = NULL,
  labels = names(metric_summary),
  time_series = FALSE,
  historic_data = NULL,
  add_to = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_climate_scenario_+3A_metric_summary">metric_summary</code></td>
<td>
<p>character string specifying the folder holding the files, from which the 
scenario is to be built.</p>
</td></tr>
<tr><td><code id="make_climate_scenario_+3A_caption">caption</code></td>
<td>
<p>vector of up to three character strings indicating the caption to be displayed
in the respective plot panel; the elements of this vector are displayed on different lines.
If <code>caption_above == TRUE</code> in <code>plot_climate_scenario</code>, only the first element is displayed.</p>
</td></tr>
<tr><td><code id="make_climate_scenario_+3A_labels">labels</code></td>
<td>
<p>numeric vector containing labels for the scenarios. This defaults to the names
of elements in <code>metric_summary</code>.</p>
</td></tr>
<tr><td><code id="make_climate_scenario_+3A_time_series">time_series</code></td>
<td>
<p>Boolean, indicating if the scenario contains a time series.</p>
</td></tr>
<tr><td><code id="make_climate_scenario_+3A_historic_data">historic_data</code></td>
<td>
<p>a data.frame containing a dataset of historic observations that is similar
in structure to metric_summary (should have column indicating the year and the metric to be
plotted, with identical names to <code>metric_summary</code>). Defaults to <code>NULL</code>, which means that no
historic data is included.</p>
</td></tr>
<tr><td><code id="make_climate_scenario_+3A_add_to">add_to</code></td>
<td>
<p>list of climate scenarios that the newly created one is to be added to.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of climate scenario objects, which can be supplied to plot_climate_scenarios.
</p>


<h3>Author(s)</h3>

<p>Eike Luedeling
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
chill&lt;-chilling(stack_hourly_temps(fix_weather(KA_weather[which(KA_weather$Year&gt;1990),]),
   latitude=50.4))
multi_chills&lt;-list('2001'=chill,'2005'=chill,'2009'=chill)
chills_to_plot&lt;-make_climate_scenario(multi_chills,caption=c("Historic","data"),
   time_series=TRUE,historic_data=chill)
chills_to_plot&lt;-make_climate_scenario(multi_chills,caption=c("Future1"),add_to=chills_to_plot)
chills_to_plot&lt;-make_climate_scenario(multi_chills,caption=c("Future2"),add_to=chills_to_plot)
plot_climate_scenarios(chills_to_plot,metric="Chill_portions",metric_label="Chill Portions")

  
</code></pre>

<hr>
<h2 id='make_climate_scenario_from_files'>Make climate scenario from multiple saved csv files</h2><span id='topic+make_climate_scenario_from_files'></span>

<h3>Description</h3>

<p>Many climate scenarios we may want to plot consist of data stored across many files. These
files typically contain certain character strings that mark, e.g. the RCP scenario or the
point in time. This function facilitates accessing such files by allowing the specification
of search string (criteria_list), according to which files are selected. They are then
converted into climate_scenario files that can become part of a list passed to
plot_climate_scenarios for plotting.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_climate_scenario_from_files(
  metric_folder,
  criteria_list,
  caption = NULL,
  time_series = FALSE,
  labels = NULL,
  historic_data = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_climate_scenario_from_files_+3A_metric_folder">metric_folder</code></td>
<td>
<p>character string specifying the folder holding the files, from which the 
scenario is to be built.</p>
</td></tr>
<tr><td><code id="make_climate_scenario_from_files_+3A_criteria_list">criteria_list</code></td>
<td>
<p>list of character vectors that specify parts of the file names that are
common to all files of a particular scenario. These can be single strings or vectors of string.
In the latter case, occurrence of either of the elements in a file name is sufficient. The
selection criteria are applied iteratively, i.e. first all files containing the first element of
'criteria_list' are selected, then those containing the second element, and so forth.</p>
</td></tr>
<tr><td><code id="make_climate_scenario_from_files_+3A_caption">caption</code></td>
<td>
<p>vector of up to three character strings indicating the caption to be displayed
in the respective plot panel; the elements of this vector are displayed on different lines.
If caption_above==TRUE in plot_climate_scenario, only the first element is displayed.</p>
</td></tr>
<tr><td><code id="make_climate_scenario_from_files_+3A_time_series">time_series</code></td>
<td>
<p>Boolean, indicating if the scenario contains a time series.</p>
</td></tr>
<tr><td><code id="make_climate_scenario_from_files_+3A_labels">labels</code></td>
<td>
<p>numeric vector containing labels for the time scenarios - only used for time series.</p>
</td></tr>
<tr><td><code id="make_climate_scenario_from_files_+3A_historic_data">historic_data</code></td>
<td>
<p>a data.frame containing at least two columns named the same as 'metric'
and 'year_name'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a climate scenario object, which can be part of a list supplied to plot_climate_scenarios.
</p>


<h3>Author(s)</h3>

<p>Eike Luedeling
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# historic_scenario&lt;-make_climate_scenario(metric_folder=chillout_folder,
#                                          criteria_list=list(cult,c(1975,2000,2015)),
#                                          caption=c("Historic","data"),
#                                         time_series=TRUE,
#                                         labels=c(1975,2000,2015),
#                                         historic_data=historic_data)
  
</code></pre>

<hr>
<h2 id='make_daily_chill_figures'>Produce image of daily chill and heat accumulation</h2><span id='topic+make_daily_chill_figures'></span>

<h3>Description</h3>

<p>Function to make figures showing the mean rate of chill and heat
accumulation for each day of the year, as well as as the standard deviation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_daily_chill_figures(
  daily_chill,
  file_path,
  models = c("Chilling_Hours", "Utah_Chill_Units", "Chill_Portions", "GDH"),
  labels = NA
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_daily_chill_figures_+3A_daily_chill">daily_chill</code></td>
<td>
<p>a daily chill object. This should be generated with the
daily_chill function.</p>
</td></tr>
<tr><td><code id="make_daily_chill_figures_+3A_file_path">file_path</code></td>
<td>
<p>the path where data should be saved. Can either end with
'/' or include a prefix for all images that are produced.</p>
</td></tr>
<tr><td><code id="make_daily_chill_figures_+3A_models">models</code></td>
<td>
<p>column names of the data.frame stored in daily_chill's
daily_chill object that contain the metrics to be plotted. Defaults to four
standard metrics of interest in fruit tree phenology analysis.</p>
</td></tr>
<tr><td><code id="make_daily_chill_figures_+3A_labels">labels</code></td>
<td>
<p>labels to be used in the plots for the metrics listed under
models. This defaults to NA, which means that the character strings given in
models are used for the figures. If alternative labels are to be used, these
should be given as a vector of length length(models).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Chill metrics are calculated as given in the references below. Chilling
Hours are all hours with temperatures between 0 and 7.2 degrees C. Units of
the Utah Model are calculated as suggested by Richardson et al. (1974)
(different weights for different temperature ranges, and negation of
chilling by warm temperatures). Chill Portions are calculated according to
Fishman et al. (1987a,b). More honestly, they are calculated according to an
Excel sheet produced by Amnon Erez and colleagues, which converts the
complex equations in the Fishman papers into relatively simple Excel
functions. These were translated into R. References to papers that include
the full functions are given below. Growing Degree Hours are calculated
according to Anderson et al. (1986), using the default values they suggest.
This function uses the Kendall package.
</p>


<h3>Value</h3>

<p>data frame containing all information used to make the figures that
are saved. For each Julian Date, means and standard deviations of all chill
and heat metrics are saved. In addition, Mann-Kendall tests are performed
for daily accumulations of all metrics. p and tau values from this test
indicate the level of statistical significance. This non-parametric test is
reliable for time series data.
</p>


<h3>Note</h3>

<p>After doing extensive model comparisons, and reviewing a lot of
relevant literature, I do not recommend using the Chilling Hours or Utah
Models, especially in warm climates! The Dynamic Model (Chill Portions),
though far from perfect, seems much more reliable.
</p>


<h3>Author(s)</h3>

<p>Eike Luedeling
</p>


<h3>References</h3>

<p>Model references:
</p>
<p>Chilling Hours:
</p>
<p>Weinberger JH (1950) Chilling requirements of peach varieties. Proc Am Soc
Hortic Sci 56, 122-128
</p>
<p>Bennett JP (1949) Temperature and bud rest period. Calif Agric 3 (11), 9+12
</p>
<p>Utah Model:
</p>
<p>Richardson EA, Seeley SD, Walker DR (1974) A model for estimating the
completion of rest for Redhaven and Elberta peach trees. HortScience 9(4),
331-332
</p>
<p>Dynamic Model:
</p>
<p>Erez A, Fishman S, Linsley-Noakes GC, Allan P (1990) The dynamic model for
rest completion in peach buds. Acta Hortic 276, 165-174
</p>
<p>Fishman S, Erez A, Couvillon GA (1987a) The temperature dependence of
dormancy breaking in plants - computer simulation of processes studied under
controlled temperatures. J Theor Biol 126(3), 309-321
</p>
<p>Fishman S, Erez A, Couvillon GA (1987b) The temperature dependence of
dormancy breaking in plants - mathematical analysis of a two-step model
involving a cooperative transition. J Theor Biol 124(4), 473-483
</p>
<p>Growing Degree Hours:
</p>
<p>Anderson JL, Richardson EA, Kesner CD (1986) Validation of chill unit and
flower bud phenology models for 'Montmorency' sour cherry. Acta Hortic 184,
71-78
</p>
<p>Model comparisons and model equations:
</p>
<p>Luedeling E, Zhang M, Luedeling V and Girvetz EH, 2009. Sensitivity of
winter chill models for fruit and nut trees to climatic changes expected in
California's Central Valley. Agriculture, Ecosystems and Environment 133,
23-31
</p>
<p>Luedeling E, Zhang M, McGranahan G and Leslie C, 2009. Validation of winter
chill models using historic records of walnut phenology. Agricultural and
Forest Meteorology 149, 1854-1864
</p>
<p>Luedeling E and Brown PH, 2011. A global analysis of the comparability of
winter chill models for fruit and nut trees. International Journal of
Biometeorology 55, 411-421
</p>
<p>Luedeling E, Kunz A and Blanke M, 2011. Mehr Chilling fuer Obstbaeume in
waermeren Wintern? (More winter chill for fruit trees in warmer winters?).
Erwerbs-Obstbau 53, 145-155
</p>
<p>Review on chilling models in a climate change context:
</p>
<p>Luedeling E, 2012. Climate change impacts on winter chill for temperate
fruit and nut production: a review. Scientia Horticulturae 144, 218-229
</p>
<p>The PLS method is described here:
</p>
<p>Luedeling E and Gassner A, 2012. Partial Least Squares Regression for
analyzing walnut phenology in California. Agricultural and Forest
Meteorology 158, 43-52.
</p>
<p>Wold S (1995) PLS for multivariate linear modeling. In: van der Waterbeemd H
(ed) Chemometric methods in molecular design: methods and principles in
medicinal chemistry, vol 2. Chemie, Weinheim, pp 195-218.
</p>
<p>Wold S, Sjostrom M, Eriksson L (2001) PLS-regression: a basic tool of
chemometrics. Chemometr Intell Lab 58(2), 109-130.
</p>
<p>Mevik B-H, Wehrens R, Liland KH (2011) PLS: Partial Least Squares and
Principal Component Regression. R package version 2.3-0.
http://CRAN.R-project.org/package0pls.
</p>
<p>Some applications of the PLS procedure:
</p>
<p>Luedeling E, Kunz A and Blanke M, 2013. Identification of chilling and heat
requirements of cherry trees - a statistical approach. International Journal
of Biometeorology 57,679-689.
</p>
<p>Yu H, Luedeling E and Xu J, 2010. Stronger winter than spring warming delays
spring phenology on the Tibetan Plateau. Proceedings of the National Academy
of Sciences (PNAS) 107 (51), 22151-22156.
</p>
<p>Yu H, Xu J, Okuto E and Luedeling E, 2012. Seasonal Response of Grasslands
to Climate Change on the Tibetan Plateau. PLoS ONE 7(11), e49230.
</p>
<p>The exact procedure was used here:
</p>
<p>Luedeling E, Guo L, Dai J, Leslie C, Blanke M, 2013. Differential responses
of trees to temperature variation during the chilling and forcing phases.
Agricultural and Forest Meteorology 181, 33-42.
</p>
<p>The chillR package:
</p>
<p>Luedeling E, Kunz A and Blanke M, 2013. Identification of chilling and heat
requirements of cherry trees - a statistical approach. International Journal
of Biometeorology 57,679-689.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
weather&lt;-fix_weather(KA_weather[which(KA_weather$Year&gt;2005),])

dc&lt;-daily_chill(stack_hourly_temps(weather,50.4), 11,models=list(Chill_Portions=Dynamic_Model))

# md&lt;-make_daily_chill_figures(dc, paste(getwd(),"/daily_chill_",sep=""),models="Chill_Portions",
#  labels="Chill Portions")


</code></pre>

<hr>
<h2 id='make_daily_chill_plot'>Plot daily climate metric accumulation throughout the year</h2><span id='topic+make_daily_chill_plot'></span>

<h3>Description</h3>

<p>This function generates a plot of the accumulation of a climate metric
throughout the year. Its standard output are the mean daily accumulation and
the standard deviation. It is also possible to add one or several so-called
focusyears to add the daily accumulation during these years to the plots.
Plots can be produced in R or directly exported as .png files.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_daily_chill_plot(
  daily_chill,
  metrics = NA,
  startdate = 1,
  enddate = 366,
  useyears = NA,
  metriclabels = NA,
  focusyears = "none",
  cumulative = FALSE,
  image_type = NA,
  outpath = NA,
  filename = NA,
  fonttype = "serif",
  title = NA,
  plotylim = NA
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_daily_chill_plot_+3A_daily_chill">daily_chill</code></td>
<td>
<p>a daily chill object generated with the daily_chill
function, which can calculate several standard chilling metrics or be
supplied with user-written temperature models. Since the format for the
input file must meet certain requirements, I recommend that you follow the
steps shown in the example below to prepare it.</p>
</td></tr>
<tr><td><code id="make_daily_chill_plot_+3A_metrics">metrics</code></td>
<td>
<p>list of the metrics to be evaluated. This defaults to NA, in
which case the function makes a guess on what metrics you want to
calculated. This is done by choosing all column headers that are not
required for a daily_chill object.</p>
</td></tr>
<tr><td><code id="make_daily_chill_plot_+3A_startdate">startdate</code></td>
<td>
<p>the first day of the season for which the metrics are to be
summarized (as a Julian date = day of the year)</p>
</td></tr>
<tr><td><code id="make_daily_chill_plot_+3A_enddate">enddate</code></td>
<td>
<p>the last day of the season for which the metrics are to be
summarized (as a Julian date = day of the year)</p>
</td></tr>
<tr><td><code id="make_daily_chill_plot_+3A_useyears">useyears</code></td>
<td>
<p>if only certain years are to be used, these can be provided
here as a numeric vector. Defaults to NA, which means all years in the
daily_chill object are used.</p>
</td></tr>
<tr><td><code id="make_daily_chill_plot_+3A_metriclabels">metriclabels</code></td>
<td>
<p>Character vector with labels for each metric to be
analyzed. Defaults to NA, which means that the strings passed as metrics
will be used.</p>
</td></tr>
<tr><td><code id="make_daily_chill_plot_+3A_focusyears">focusyears</code></td>
<td>
<p>Numeric vector containing the years that are to be
highlighted in the plot. Years for which no data are available are
automatically removed.</p>
</td></tr>
<tr><td><code id="make_daily_chill_plot_+3A_cumulative">cumulative</code></td>
<td>
<p>Boolean argument (TRUE or FALSE) indicating whether the
climate metric should be shown as daily accumulation rates or as cumulative
accumulation.</p>
</td></tr>
<tr><td><code id="make_daily_chill_plot_+3A_image_type">image_type</code></td>
<td>
<p>Character string indicating the file format that should be
output. Image files are only produced for the moment, if this is &quot;png&quot;. All
other values, as well as the default NA lead to output as an R plot only.</p>
</td></tr>
<tr><td><code id="make_daily_chill_plot_+3A_outpath">outpath</code></td>
<td>
<p>Path to the folder where the images should be saved. Should
include a trailing &quot;/&quot;. The folder must already exists.</p>
</td></tr>
<tr><td><code id="make_daily_chill_plot_+3A_filename">filename</code></td>
<td>
<p>Suffix of the filenames for output graph files. These will
be amended by the name of the metric and by the file extension.</p>
</td></tr>
<tr><td><code id="make_daily_chill_plot_+3A_fonttype">fonttype</code></td>
<td>
<p>The type of font to be used for the figures. Can be 'serif'
(default) for a Times New Roman like font, 'sans' for an Arial type font or
'mono' for a typewriter type font.</p>
</td></tr>
<tr><td><code id="make_daily_chill_plot_+3A_title">title</code></td>
<td>
<p>title of the plot (if unhappy with the default).</p>
</td></tr>
<tr><td><code id="make_daily_chill_plot_+3A_plotylim">plotylim</code></td>
<td>
<p>numeric vector of length 2 indicating the extent of the y axis.
Defaults to NA, which means that y limits are determined automatically.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Plots daily accumulation of climatic metrics, such as winter chill, as daily
accumulation rates or as cumulative accumulation. A legend is only added,
when focusyears are also shown. Otherwise the plot is reasonably
self-explanatory.
</p>


<h3>Value</h3>

<p>The main purpose of the function is a side effect - plots of daily
climate metric accumulation. However, all the data used for making the plots
is returned as a list containing an element for each metric, which consists
of a data.table with the daily means, standard deviation and daily values
for all focusyears.
</p>


<h3>Author(s)</h3>

<p>Eike Luedeling
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
day_chill&lt;-make_daily_chill_plot(daily_chill(stack_hourly_temps(fix_weather(
  KA_weather[which(KA_weather$Year&gt;2005),])),
  running_mean=11),focusyears=c(2001,2005),cumulative=TRUE,startdate=300,enddate=30)

 
</code></pre>

<hr>
<h2 id='make_daily_chill_plot2'>Plot daily climate metric accumulation throughout the year (2)</h2><span id='topic+make_daily_chill_plot2'></span>

<h3>Description</h3>

<p>This function generates a plot of the accumulation of a climate metric
throughout the year. Its standard output are the mean daily accumulation and
the standard deviation. It is also possible to add one or several so-called
focusyears to add the daily accumulation during these years to the plots.
Plots can be produced in R or directly exported as .png files.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_daily_chill_plot2(
  daily,
  metrics = NA,
  startdate = 1,
  enddate = 366,
  useyears = NA,
  metriclabels = NA,
  focusyears = "none",
  cumulative = FALSE,
  fix_leap = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_daily_chill_plot2_+3A_daily">daily</code></td>
<td>
<p>an object generated with the daily_chill
function, which can calculate several standard chilling metrics or be
supplied with user-written temperature models. Since the format for the
input file must meet certain requirements, I recommend that you follow the
steps shown in the example below to prepare it.</p>
</td></tr>
<tr><td><code id="make_daily_chill_plot2_+3A_metrics">metrics</code></td>
<td>
<p>list of the metrics to be evaluated. This defaults to NA, in
which case the function makes a guess on what metrics you want to
calculated. This is done by choosing all column headers that are not
required for a daily_chill object.</p>
</td></tr>
<tr><td><code id="make_daily_chill_plot2_+3A_startdate">startdate</code></td>
<td>
<p>the first day of the season for which the metrics are to be
summarized (as a Julian date = day of the year)</p>
</td></tr>
<tr><td><code id="make_daily_chill_plot2_+3A_enddate">enddate</code></td>
<td>
<p>the last day of the season for which the metrics are to be
summarized (as a Julian date = day of the year)</p>
</td></tr>
<tr><td><code id="make_daily_chill_plot2_+3A_useyears">useyears</code></td>
<td>
<p>if only certain years are to be used, these can be provided
here as a numeric vector. Defaults to NA, which means all years in the
daily_chill object are used.</p>
</td></tr>
<tr><td><code id="make_daily_chill_plot2_+3A_metriclabels">metriclabels</code></td>
<td>
<p>Character vector with labels for each metric to be
analyzed. Defaults to NA, which means that the strings passed as metrics
will be used.</p>
</td></tr>
<tr><td><code id="make_daily_chill_plot2_+3A_focusyears">focusyears</code></td>
<td>
<p>Numeric vector containing the years that are to be
highlighted in the plot. Years for which no data are available are
automatically removed.</p>
</td></tr>
<tr><td><code id="make_daily_chill_plot2_+3A_cumulative">cumulative</code></td>
<td>
<p>Boolean argument (TRUE or FALSE) indicating whether the
climate metric should be shown as daily accumulation rates or as cumulative
accumulation.</p>
</td></tr>
<tr><td><code id="make_daily_chill_plot2_+3A_fix_leap">fix_leap</code></td>
<td>
<p>boolean parameter indicating whether the anomaly that can
originate when leaf years are present in the data should be smoothed by
interpolating between Dec 30 and Jan 1 in leap years.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Plots daily accumulation of climatic metrics, such as winter chill, as daily
accumulation rates or as cumulative accumulation. A legend is only added,
when focusyears are also shown. Otherwise the plot is reasonably
self-explanatory.
</p>


<h3>Value</h3>

<p>The main purpose of the function is a side effect - plots of daily
climate metric accumulation. However, all the data used for making the plots
is returned as a list containing an element for each metric, which consists
of a data.table with the daily means, standard deviation and daily values
for all focusyears.
</p>


<h3>Author(s)</h3>

<p>Eike Luedeling
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

daily&lt;-daily_chill(stack_hourly_temps(fix_weather(
  KA_weather[which(KA_weather$Year&gt;2005),])),running_mean=11)

make_daily_chill_plot2(daily,metrics=c("Chill_Portions","GDH"),cumulative=TRUE,
   startdate=300,enddate=30,focusyears=c(2009,2008))


 
</code></pre>

<hr>
<h2 id='make_hourly_temps'>Make hourly temperature record from daily data</h2><span id='topic+make_hourly_temps'></span>

<h3>Description</h3>

<p>This function generates hourly temperature records for a particular location
from daily minimum and maximum temperatures and latitude.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_hourly_temps(latitude, year_file, keep_sunrise_sunset = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_hourly_temps_+3A_latitude">latitude</code></td>
<td>
<p>the geographic latitude (in decimal degrees) of the location
of interest</p>
</td></tr>
<tr><td><code id="make_hourly_temps_+3A_year_file">year_file</code></td>
<td>
<p>a data frame containing data on daily minimum temperature
(called Tmin), daily maximum temperature (called Tmax), and date
information. Dates can either be specified by two columns called Year and
JDay, which contain the Year and Julian date (day of the year), or as three
columns called Year, Month and Day. year_file cannot have any missing
values, so it may be a good idea to process the relevant columns with
make_all_day_table and interpolate_gaps before.</p>
</td></tr>
<tr><td><code id="make_hourly_temps_+3A_keep_sunrise_sunset">keep_sunrise_sunset</code></td>
<td>
<p>boolean variable indicating whether information
on sunrise, sunset and daylength, which is calculated for producing hourly
temperature records, should be preserved in the output. Defaults to FALSE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Temperature estimates are based on an idealized daily temperature curve that
uses a sine curve for daytime warming and a logarithmic decay function for
nighttime cooling. The input data frame can have more columns, which are
preserved, but ignored in the processing. References to papers outlining the
procedures are given below.
</p>
<p>Note that this function should be able to generate hourly temperatures for
all latitudes, but it uses an algorithm designed for locations with regular
day/night behavior. It may therefore be that the curves aren't very realistic
for very short or very long days, or especially for polar days and nights.
</p>


<h3>Value</h3>

<p>data frame containing all the columns of year_file, plus 24 columns
for hourly temperatures (called Hour_1 ... Hour_24).
</p>


<h3>Author(s)</h3>

<p>Eike Luedeling
</p>


<h3>References</h3>

<p>Luedeling E, Kunz A and Blanke M, 2013. Identification of
chilling and heat requirements of cherry trees - a statistical approach.
International Journal of Biometeorology 57,679-689.
</p>
<p>Luedeling E, Girvetz EH, Semenov MA and Brown PH, 2011. Climate change
affects winter chill for temperate fruit and nut trees. PLoS ONE 6(5),
e20155.
</p>
<p>The temperature interpolation is described in
</p>
<p>Linvill DE, 1990. Calculating chilling hours and chill units from daily
maximum and minimum temperature observations. HortScience 25(1), 14-16.
</p>
<p>Calculation of sunrise, sunset and daylength was done according to
</p>
<p>Spencer JW, 1971. Fourier series representation of the position of the Sun.
Search 2(5), 172.
</p>
<p>Almorox J, Hontoria C and Benito M, 2005. Statistical validation of
daylength definitions for estimation of global solar radiation in Toledo,
Spain. Energy Conversion and Management 46(9-10), 1465-1471)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
weather&lt;-fix_weather(KA_weather)

THourly&lt;-make_hourly_temps(50.4,weather$weather)

#in most cases, you're probably better served by stack_hour_temperatures

</code></pre>

<hr>
<h2 id='make_JDay'>Make Julian Day in dataframe</h2><span id='topic+make_JDay'></span>

<h3>Description</h3>

<p>This function produced Julian Dates (days of the year) from columns &quot;Day&quot;,
&quot;Month&quot; and &quot;Year&quot; in a dataframe.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_JDay(dateframe)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_JDay_+3A_dateframe">dateframe</code></td>
<td>
<p>data.frame, which should contain date information specified
as columns &quot;Day&quot;, &quot;Month&quot; and &quot;Year&quot;</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the same data.frame, but with column &quot;JDay&quot; added. This then
contains the Julian Dates.
</p>


<h3>Author(s)</h3>

<p>Eike Luedeling
</p>


<h3>References</h3>

<p>The chillR package:
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

dates&lt;-data.frame(Year=c(1977,1980,2004,2011,2016),Month=c(11,8,3,12,8),Day=c(1,21,2,24,2)) 
make_JDay(dates)


</code></pre>

<hr>
<h2 id='make_multi_pheno_trend_plot'>Combine multiple phenology contour plots in one figure</h2><span id='topic+make_multi_pheno_trend_plot'></span>

<h3>Description</h3>

<p>For multiple datasets, this function plots surface plots relating mean
temperatures during specified periods to annually recurring variables (e.g.
flowering). It produces one panel per dataset and plots them all in one
figure. Plots can be produced in R or directly exported as .png files.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_multi_pheno_trend_plot(
  pheno_list,
  fixed_weather,
  split_month = 6,
  outpath = NA,
  file_name = NA,
  image_type = "png",
  fonttype = "serif",
  percol = 5,
  xlabel = NA,
  ylabel = NA,
  height_factor = 0.8
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_multi_pheno_trend_plot_+3A_pheno_list">pheno_list</code></td>
<td>
<p>a data.frame with the following columns: varieties
(contains a character string), Start_chill (the start of the chill period,
in Julian days), End_chill (the end of the chill period, in Julian days),
Start_heat (the start of the forcing period, in Julian days), End_heat (the
end of the forcing period, in Julian days), Link (the complete path to a csv
file that contains all the annual observations for the dataset, with columns
Year and pheno)</p>
</td></tr>
<tr><td><code id="make_multi_pheno_trend_plot_+3A_fixed_weather">fixed_weather</code></td>
<td>
<p>daily weather, as produced with the fix_weather
function</p>
</td></tr>
<tr><td><code id="make_multi_pheno_trend_plot_+3A_split_month">split_month</code></td>
<td>
<p>the month after which to start a new season. Defaults to
6, meaning the new season will start in July.</p>
</td></tr>
<tr><td><code id="make_multi_pheno_trend_plot_+3A_outpath">outpath</code></td>
<td>
<p>Path to the folder where the images should be saved. Should
include a trailing &quot;/&quot;. The folder must already exists.</p>
</td></tr>
<tr><td><code id="make_multi_pheno_trend_plot_+3A_file_name">file_name</code></td>
<td>
<p>name of the image file to be produced, if image_type='png'.</p>
</td></tr>
<tr><td><code id="make_multi_pheno_trend_plot_+3A_image_type">image_type</code></td>
<td>
<p>Character string indicating the file format that should be
output. Image files are only produced for the moment, if this is &quot;png&quot;. All
other values, as well as the default NA lead to output as an R plot only.</p>
</td></tr>
<tr><td><code id="make_multi_pheno_trend_plot_+3A_fonttype">fonttype</code></td>
<td>
<p>The type of font to be used for the figures. Can be 'serif'
(default) for a Times New Roman like font, 'sans' for an Arial type font or
'mono' for a typewriter type font.</p>
</td></tr>
<tr><td><code id="make_multi_pheno_trend_plot_+3A_percol">percol</code></td>
<td>
<p>number of plots to be placed in a column.</p>
</td></tr>
<tr><td><code id="make_multi_pheno_trend_plot_+3A_xlabel">xlabel</code></td>
<td>
<p>label for the x-axis (if unhappy with the default).</p>
</td></tr>
<tr><td><code id="make_multi_pheno_trend_plot_+3A_ylabel">ylabel</code></td>
<td>
<p>label for the y-axis (if unhappy with the default).</p>
</td></tr>
<tr><td><code id="make_multi_pheno_trend_plot_+3A_height_factor">height_factor</code></td>
<td>
<p>height of the resulting png figure (if this is a png)
relative to the width of the plot (e.g. 1 or 0.7, defaults to 0.8).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is only useful, if you want to plot several surface plots in
the same figure. These must relate to the same weather dataset. Arguably,
this function isn't quite ready to be released, but it performs some useful
functions that you may be interested in...
</p>


<h3>Value</h3>

<p>Only a side effect is produced: either a .png file or an R graphic
showing the multi-panel contour figure.
</p>


<h3>Author(s)</h3>

<p>Eike Luedeling
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#this example uses arbitrarily modified versions of the KA_bloom dataset, and the starts
#end ends of the periods are also arbitraty. So the outputs may not make a lot of sense...

weather&lt;-fix_weather(KA_weather[which(KA_weather$Year&gt;2000),])
pheno_list&lt;-data.frame(varieties=c("KA1","KA2","KA3","KA4"), Start_chill=c(270,305,315,320),
  End_chill=c(15,20,35,40), Start_heat=c(17,25,40,45),End_heat=c(90,100,110,115),
  Link=c("KA1.csv","KA2.csv","KA3.csv","KA4.csv"))
  
 # write.csv(KA_bloom,"KA1.csv",row.names=FALSE)
 KA_bloom$pheno&lt;-as.numeric(as.character(KA_bloom$pheno))+10
 # write.csv(KA_bloom,"KA2.csv",row.names=FALSE)
 KA_bloom$pheno&lt;-KA_bloom$pheno+10
 # write.csv(KA_bloom,"KA3.csv",row.names=FALSE)
 KA_bloom$pheno&lt;-KA_bloom$pheno+10
 # write.csv(KA_bloom,"KA4.csv",row.names=FALSE)

# make_multi_pheno_trend_plot(pheno_list,weather, split_month=6,
#            outpath=NA,file_name=NA,image_type="",fonttype="serif",percol=2)

 
</code></pre>

<hr>
<h2 id='make_pheno_trend_plot'>Make image showing phenology response to temperatures during two phases</h2><span id='topic+make_pheno_trend_plot'></span>

<h3>Description</h3>

<p>The timing of many developmental stages of temperate plants is understood to
depend on temperatures during two phases. This function seeks to illustrate
this dependency by plotting phenological dates as colored surface, as a
function of mean temperatures during both phases, which are indicated on the
x and y axes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_pheno_trend_plot(
  weather_data_frame,
  split_month = 6,
  pheno,
  use_Tmean = FALSE,
  Start_JDay_chill,
  End_JDay_chill,
  Start_JDay_heat,
  End_JDay_heat,
  outpath,
  file_name,
  plot_title,
  ylabel = NA,
  xlabel = NA,
  legend_label = NA,
  image_type = "png",
  colorscheme = "normal",
  fonttype = "serif"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_pheno_trend_plot_+3A_weather_data_frame">weather_data_frame</code></td>
<td>
<p>a dataframe containing daily minimum and maximum
temperature data (in columns called Tmin and Tmax, respectively), and/or
mean daily temperature (in a column called Tmean). There also has to be a
column for Year and one for JDay (the Julian date, or day of the year).
Alternatively, the date can also be given in three columns (Year, Month and
Day).</p>
</td></tr>
<tr><td><code id="make_pheno_trend_plot_+3A_split_month">split_month</code></td>
<td>
<p>the procedure analyzes data by phenological year, which
can start and end in any month during the calendar year (currently only at
the beginning of a month). This variable indicates the last month (e.g. 5
for May) that should be included in the record for a given phenological
year. All subsequent months are assigned to the following phenological year.</p>
</td></tr>
<tr><td><code id="make_pheno_trend_plot_+3A_pheno">pheno</code></td>
<td>
<p>a data frame that contains information on the timing of
phenological events by year. It should consist of two columns called Year
and pheno. Data in the pheno column should be in Julian date (day of the
year).</p>
</td></tr>
<tr><td><code id="make_pheno_trend_plot_+3A_use_tmean">use_Tmean</code></td>
<td>
<p>boolean variable indicating whether or not the column Tmean
from the weather_data_frame should be used as input for the PLS analysis. If
this is set to FALSE, Tmean is calculated as the arithmetic mean of Tmin and
Tmax.</p>
</td></tr>
<tr><td><code id="make_pheno_trend_plot_+3A_start_jday_chill">Start_JDay_chill</code></td>
<td>
<p>the Julian date, on which the first relevant period
(e.g. the chilling phase) starts</p>
</td></tr>
<tr><td><code id="make_pheno_trend_plot_+3A_end_jday_chill">End_JDay_chill</code></td>
<td>
<p>the Julian date, on which the first relevant period
(e.g. the chilling phase) ends</p>
</td></tr>
<tr><td><code id="make_pheno_trend_plot_+3A_start_jday_heat">Start_JDay_heat</code></td>
<td>
<p>the Julian date, on which the second relevant period
(e.g. the forcing phase) starts</p>
</td></tr>
<tr><td><code id="make_pheno_trend_plot_+3A_end_jday_heat">End_JDay_heat</code></td>
<td>
<p>the Julian date, on which the second relevant period
(e.g. the forcing phase) ends</p>
</td></tr>
<tr><td><code id="make_pheno_trend_plot_+3A_outpath">outpath</code></td>
<td>
<p>the output path</p>
</td></tr>
<tr><td><code id="make_pheno_trend_plot_+3A_file_name">file_name</code></td>
<td>
<p>the output file name</p>
</td></tr>
<tr><td><code id="make_pheno_trend_plot_+3A_plot_title">plot_title</code></td>
<td>
<p>the title of the plot</p>
</td></tr>
<tr><td><code id="make_pheno_trend_plot_+3A_ylabel">ylabel</code></td>
<td>
<p>the label for the y-axis. There is a default, but in many
cases, it may be desirable to customize this</p>
</td></tr>
<tr><td><code id="make_pheno_trend_plot_+3A_xlabel">xlabel</code></td>
<td>
<p>the label for the x-axis. There is a default, but in many
cases, it may be desirable to customize this</p>
</td></tr>
<tr><td><code id="make_pheno_trend_plot_+3A_legend_label">legend_label</code></td>
<td>
<p>the label for the legend (color scheme). There is a
default, but in many cases, it may be desirable to customize this</p>
</td></tr>
<tr><td><code id="make_pheno_trend_plot_+3A_image_type">image_type</code></td>
<td>
<p>the type of image to produce. This currently has only two
options: &quot;tiff&quot; or anything else (the default). If this is not &quot;tiff&quot;, a png
image is produced. The &quot;tiff&quot; option was added to produce publishable
figures that adhere to the requirements of most scientific journals.</p>
</td></tr>
<tr><td><code id="make_pheno_trend_plot_+3A_colorscheme">colorscheme</code></td>
<td>
<p>the color scheme for the figure. This currently has only
two options: &quot;bw&quot; or anythings else (the default). &quot;bw&quot; produces a grayscale
image, otherwise the figure will be in color</p>
</td></tr>
<tr><td><code id="make_pheno_trend_plot_+3A_fonttype">fonttype</code></td>
<td>
<p>font style to be used for the figure. Can be 'serif'
(default) or 'sans'.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The generation of the color surface is based on the Kriging technique, which
is typically used for interpolation of spatial data. The use for this
particular purpose is a bit experimental. The function uses the Krig
function from the fields package.
</p>


<h3>Value</h3>

<table>
<tr><td><code>pheno</code></td>
<td>
<p>data frame containing all data needed for reproducing
the plot: Year (during which the phenological event occurred - the year in
which the phenological season indicated by split_month ended), pheno (the
date on which the phenological event occurred), Chill_Tmean (mean
temperature during the first relevant phase), Heat_Tmean (mean temperature
during the second relevant phase) and Year_Tmean (mean annual temperature -
not actually used in the plot)</p>
</td></tr> <tr><td><code>ylabel</code></td>
<td>
<p>character string used for
labeling the y axis</p>
</td></tr> <tr><td><code>xlabel</code></td>
<td>
<p>character string used for labeling the x
axis</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Eike Luedeling
</p>


<h3>References</h3>

<p>Guo L, Dai J, Wang M, Xu J, Luedeling E, 2015. Responses of
spring phenology in temperate zone trees to climate warming: a case study of
apricot flowering in China. Agricultural and Forest Meteorology 201, 1-7.
</p>
<p>Guo L, Dai J, Ranjitkar S, Xu J, Luedeling E, 2013. Response of chestnut
phenology in China to climate variation and change. Agricultural and Forest
Meteorology 180, 164-172.
</p>
<p>Luedeling E, Guo L, Dai J, Leslie C, Blanke M, 2013. Differential responses
of trees to temperature variation during the chilling and forcing phases.
Agricultural and Forest Meteorology 181, 33-42.
</p>
<p>the interpolation was done according to:
</p>
<p>Furrer, R., Nychka, D. and Sain, S., 2012. Fields: Tools for spatial data. R
package version 6.7.
</p>
<p>Reference to the chillR package:
</p>
<p>Luedeling E, Kunz A and Blanke M, 2013. Identification of chilling and heat
requirements of cherry trees - a statistical approach. International Journal
of Biometeorology 57,679-689.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
weather&lt;-fix_weather(KA_weather)

#the output of the PLS function (PLS_pheno, plotted with plot_PLS) can be used to select
#phases that are likely relevant for plant phase timing. See respective examples for running
#these functions.

file_path&lt;-paste(getwd(),"/",sep="")

#mpt&lt;-make_pheno_trend_plot(weather_data_frame = weather$weather, split_month = 6,
#      pheno = KA_bloom, use_Tmean = FALSE, Start_JDay_chill = 260, 
#      End_JDay_chill = 64, Start_JDay_heat = 44, End_JDay_heat = 103,
#      outpath = file_path, file_name = "pheno_trend_plot",
#      plot_title = "Impacts of chilling and forcing temperatures on cherry phenology",
#      ylabel = NA, xlabel = NA, legend_label = NA, image_type = "png", 
#      colorscheme = "normal")

</code></pre>

<hr>
<h2 id='ordered_climate_list'>Sort files in a folder, so that numbers are in ascending sequence</h2><span id='topic+ordered_climate_list'></span>

<h3>Description</h3>

<p>Sometimes lists of strings that contain numbers aren't listed automatically in the sequence
we would expect, e.g. because numbers below ten are lacking leading zeros (as in
c(&quot;a1&quot;,&quot;a10&quot;,&quot;a100&quot;,&quot;a11&quot;...)). This function recognizes all shared leading and trailing
symbols around the numeric part of such strings and sorts the list according to the embedded
numbers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ordered_climate_list(strings, file_extension = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ordered_climate_list_+3A_strings">strings</code></td>
<td>
<p>vector of character strings to be sorted according to embedded numbers.</p>
</td></tr>
<tr><td><code id="ordered_climate_list_+3A_file_extension">file_extension</code></td>
<td>
<p>character string specifying the extension of the file type to be selected.
This can also be any other trailing string that marks all vector elements to be selected. This isn't
required for the function to run, but may be necessary if the string list of interest contains, for
instance, different file types, of which you only want to work with one.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>subset of the strings vector that only contains the elements that end on file_extension and
are sorted in ascending order according to the numeric parts of the strings.
</p>


<h3>Author(s)</h3>

<p>Eike Luedeling
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  ordered_climate_list(c("Temp1_ws30.csv","Temp1_ws30.xls",
                         "Temp10_ws30.csv","Temp10_ws30.xls",
                         "Temp2_ws30.csv","Temp2_ws30.xls"),"csv")
  ordered_climate_list(c("Tx12", "Tx2","Tx4","Tx1"))
 
</code></pre>

<hr>
<h2 id='patch_daily_temperatures'>Patch gaps in daily weather records</h2><span id='topic+patch_daily_temperatures'></span>

<h3>Description</h3>

<p>This function is deprecated. Better use <code><a href="#topic+patch_daily_temps">patch_daily_temps</a></code>!
</p>


<h3>Usage</h3>

<pre><code class='language-R'>patch_daily_temperatures(
  weather,
  patch_weather,
  vars = c("Tmin", "Tmax"),
  max_mean_bias = NA,
  max_stdev_bias = NA
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="patch_daily_temperatures_+3A_weather">weather</code></td>
<td>
<p>chillR-compatible weather record to be patched</p>
</td></tr>
<tr><td><code id="patch_daily_temperatures_+3A_patch_weather">patch_weather</code></td>
<td>
<p>list of chillR-compatible weather records to be used for
patching holes in weather. They are used sequentially, until all have been used
or until there are no holes left.</p>
</td></tr>
<tr><td><code id="patch_daily_temperatures_+3A_vars">vars</code></td>
<td>
<p>vector of column names to be considered in patching. Defaults to
c(&quot;Tmin&quot;,&quot;Tmax&quot;), the most common variables in chillR applications.</p>
</td></tr>
<tr><td><code id="patch_daily_temperatures_+3A_max_mean_bias">max_mean_bias</code></td>
<td>
<p>maximum mean bias of auxiliary data compared to the original
dataset (applied to all variables in vars). If this threshold is exceeded, the
respective variable from that particular dataset will not be used. Defaults to NA,
meaning no records are excluded.</p>
</td></tr>
<tr><td><code id="patch_daily_temperatures_+3A_max_stdev_bias">max_stdev_bias</code></td>
<td>
<p>maximum standard deviation of the bias in the auxiliary
data compared to the original dataset (applied to all variables in vars). If this
threshold is exceeded, the respective variable from that particular dataset will not
be used. Defaults to NA, meaning no records are excluded.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function uses auxiliary data sources to fill gaps in daily weather data.
It can accommodate multiple sources of auxiliary information, which are used
in the user-specified sequence. There have to be some overlapping records for
this to work, because without bias correction, this procedure could produce
erroneous records. Bias correction is done by computing the mean difference
between main and auxiliary data for each variable and adjusting for it in
filling the gaps. You can specify a maximum mean bias and a maximum standard
deviation of the bias to exclude unsuitable records that aren't similar
enough to the original data.
</p>


<h3>Value</h3>

<p>list of two elements: weather (the patched weather record, with additional
columns specifying the data source for each value) and statistics (containing
data.frames for each element of patch_weather that indicate the mean bias, the
number of values that were filled from this source and the number of missing records
that remained after exhausting this auxiliary data source.)
</p>


<h3>Author(s)</h3>

<p>Eike Luedeling
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
gap_weather&lt;-KA_weather[1:100,]
gap_weather[c(3,4,7:15,20,22:25,27:28,35:45,55,67,70:75,80:88,95:97),"Tmin"]&lt;-NA
gap_weather[c(10:25,30,36:44,50,57,65,70:80,86,91:94),"Tmax"]&lt;-NA
p1&lt;-KA_weather[65:95,]
p1$Tmin&lt;-p1$Tmin-2
p2&lt;-KA_weather[c(15:40,60:80),]
p2$Tmax&lt;-p2$Tmax+3
p3&lt;-KA_weather[12:35,]
p3$Tmax&lt;-p3$Tmax-2
p4&lt;-KA_weather
p4$Tmax&lt;-p4$Tmax+0.5
patch_weather&lt;-list(stat1=p1,st2=p2,home=p3,last=p4)

patched&lt;-patch_daily_temperatures(gap_weather,patch_weather,max_mean_bias=1)


</code></pre>

<hr>
<h2 id='patch_daily_temps'>Patch gaps in daily weather records - updated</h2><span id='topic+patch_daily_temps'></span>

<h3>Description</h3>

<p>This is the successor function of <code><a href="#topic+patch_daily_temperatures">patch_daily_temperatures</a></code>, which will no
longer be updated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>patch_daily_temps(
  weather,
  patch_weather,
  vars = c("Tmin", "Tmax"),
  max_mean_bias = NA,
  max_stdev_bias = NA,
  time_interval = "month"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="patch_daily_temps_+3A_weather">weather</code></td>
<td>
<p>chillR-compatible weather record to be patched</p>
</td></tr>
<tr><td><code id="patch_daily_temps_+3A_patch_weather">patch_weather</code></td>
<td>
<p>list of chillR-compatible weather records to be used for
patching holes in weather. They are used sequentially, until all have been used
or until there are no holes left.</p>
</td></tr>
<tr><td><code id="patch_daily_temps_+3A_vars">vars</code></td>
<td>
<p>vector of column names to be considered in patching. Defaults to
c(&quot;Tmin&quot;,&quot;Tmax&quot;), the most common variables in chillR applications.</p>
</td></tr>
<tr><td><code id="patch_daily_temps_+3A_max_mean_bias">max_mean_bias</code></td>
<td>
<p>maximum mean bias of auxiliary data compared to the original
dataset (applied to all variables in vars). If this threshold is exceeded, the
respective variable from that particular dataset will not be used. Defaults to NA,
meaning no records are excluded.</p>
</td></tr>
<tr><td><code id="patch_daily_temps_+3A_max_stdev_bias">max_stdev_bias</code></td>
<td>
<p>maximum standard deviation of the bias in the auxiliary
data compared to the original dataset (applied to all variables in vars). If this
threshold is exceeded, the respective variable from that particular dataset will not
be used. Defaults to NA, meaning no records are excluded.</p>
</td></tr>
<tr><td><code id="patch_daily_temps_+3A_time_interval">time_interval</code></td>
<td>
<p>time interval for which mean bias and standard deviation of the
bias are to be evaluated. This defaults to &quot;month&quot;, which means that the function
looks for overlapping days between weather and patch_weather for each calendar month.
Bias correction is then also done on a monthly basis. 'time_interval' can also assume
other values, such as 'week' or '2 weeks'.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The patch_daily_temps function uses auxiliary data sources to fill gaps in daily weather data.
It can accommodate multiple sources of auxiliary information, which are used
in the user-specified sequence. There have to be some overlapping records for
this to work, because without bias correction, this procedure could produce
erroneous records. Bias correction is done by computing the mean difference
between main and auxiliary data for each variable and adjusting for it in
filling the gaps. You can specify a maximum mean bias and a maximum standard
deviation of the bias to exclude unsuitable records that aren't similar
enough to the original data.
When patching records, the function breaks the calendar year down into smaller
intervals that can be specified with the 'time_interval' parameter (this was not
possible in [chillR::patch_daily_temperatures], but is recommended for accurate results).
</p>


<h3>Value</h3>

<p>list of two elements: weather (the patched weather record, with additional
columns specifying the data source for each value) and statistics (containing
data.frames for each element of patch_weather that indicate the mean bias, the
number of values that were filled from this source and the number of missing records
that remained after exhausting this auxiliary data source.)
</p>


<h3>Author(s)</h3>

<p>Eike Luedeling
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
gap_weather&lt;-KA_weather[1:100,]
gap_weather[c(3,4,7:15,20,22:25,27:28,35:45,55,67,70:75,80:88,95:97),"Tmin"]&lt;-NA
gap_weather[c(10:25,30,36:44,50,57,65,70:80,86,91:94),"Tmax"]&lt;-NA
p1&lt;-KA_weather[65:95,]
p1$Tmin&lt;-p1$Tmin-2
p2&lt;-KA_weather[c(15:40,60:80),]
p2$Tmax&lt;-p2$Tmax+3
p3&lt;-KA_weather[12:35,]
p3$Tmax&lt;-p3$Tmax-2
p4&lt;-KA_weather
p4$Tmax&lt;-p4$Tmax+0.5
patch_weather&lt;-list(stat1=p1,st2=p2,home=p3,last=p4)

patch_daily_temps(gap_weather,patch_weather)

patch_daily_temps(gap_weather,patch_weather,max_mean_bias=0.1,time_interval="2 weeks")


</code></pre>

<hr>
<h2 id='PhenoFlex'>PhenoFlex</h2><span id='topic+PhenoFlex'></span>

<h3>Description</h3>

<p>Combined model of the dynamic model for chill accumulation and the GDH model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PhenoFlex(
  temp,
  times,
  A0 = 6319.5,
  A1 = 5.939917e+13,
  E0 = 3372.8,
  E1 = 9900.3,
  slope = 1.6,
  Tf = 4,
  s1 = 0.5,
  Tu = 25,
  Tb = 4,
  Tc = 36,
  yc = 40,
  Delta = 4,
  Imodel = 0L,
  zc = 190,
  stopatzc = TRUE,
  deg_celsius = TRUE,
  basic_output = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PhenoFlex_+3A_temp">temp</code></td>
<td>
<p>Vector of temperatures.</p>
</td></tr>
<tr><td><code id="PhenoFlex_+3A_times">times</code></td>
<td>
<p>numeric vector. Optional times at which the temperatures where measured,
if not given, hourly temperatures will be assumed</p>
</td></tr>
<tr><td><code id="PhenoFlex_+3A_a0">A0</code></td>
<td>
<p>numeric. Parameter <code class="reqn">A_0</code> of the dynamic model</p>
</td></tr>
<tr><td><code id="PhenoFlex_+3A_a1">A1</code></td>
<td>
<p>numeric. Parameter <code class="reqn">A_1</code> of the dynamic model</p>
</td></tr>
<tr><td><code id="PhenoFlex_+3A_e0">E0</code></td>
<td>
<p>numeric. Parameter <code class="reqn">E_0</code> of the dynamic model</p>
</td></tr>
<tr><td><code id="PhenoFlex_+3A_e1">E1</code></td>
<td>
<p>numeric. Parameter <code class="reqn">E_1</code> of the dynamic model</p>
</td></tr>
<tr><td><code id="PhenoFlex_+3A_slope">slope</code></td>
<td>
<p>numeric. Slope parameter for sigmoidal function</p>
</td></tr>
<tr><td><code id="PhenoFlex_+3A_tf">Tf</code></td>
<td>
<p>numeric. Transition temperature (in degree Kelvin) for the
sigmoidal function</p>
</td></tr>
<tr><td><code id="PhenoFlex_+3A_s1">s1</code></td>
<td>
<p>numeric. Slope of transition from chill to heat accumulation</p>
</td></tr>
<tr><td><code id="PhenoFlex_+3A_tu">Tu</code></td>
<td>
<p>numeric. GDH optimal temperature</p>
</td></tr>
<tr><td><code id="PhenoFlex_+3A_tb">Tb</code></td>
<td>
<p>numeric. GDH base temperature (lower threshold)</p>
</td></tr>
<tr><td><code id="PhenoFlex_+3A_tc">Tc</code></td>
<td>
<p>numeric. GDH upper temperature (upper threshold)</p>
</td></tr>
<tr><td><code id="PhenoFlex_+3A_yc">yc</code></td>
<td>
<p>numeric. Critical value defining end of chill accumulation</p>
</td></tr>
<tr><td><code id="PhenoFlex_+3A_delta">Delta</code></td>
<td>
<p>numeric. Width of Gaussian heat accumulation model</p>
</td></tr>
<tr><td><code id="PhenoFlex_+3A_imodel">Imodel</code></td>
<td>
<p>integer. Heat accumulation model: 0 for GDH and 1 for Gaussian</p>
</td></tr>
<tr><td><code id="PhenoFlex_+3A_zc">zc</code></td>
<td>
<p>numeric. Critical value of z determining the end of heat accumulation</p>
</td></tr>
<tr><td><code id="PhenoFlex_+3A_stopatzc">stopatzc</code></td>
<td>
<p>boolean. If 'TRUE', the PhenoFlex is applied until the end of the temperature series. Default is to stop once the value zc has been reached.</p>
</td></tr>
<tr><td><code id="PhenoFlex_+3A_deg_celsius">deg_celsius</code></td>
<td>
<p>boolean. whether or not the temperature vector
and the model temperature parameters are
in degree Celsius (Kelvin otherwise)</p>
</td></tr>
<tr><td><code id="PhenoFlex_+3A_basic_output">basic_output</code></td>
<td>
<p>boolean. If 'TRUE', only the bloomindex is returned as a named element of the return list.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list is returned with named element 'bloomindex', which is the index at which blooming occurs. When 'basic_output=FALSE' also 'x', 'y', 'z' and 'xs' are
returned as named element of this list, which are numeric vectors of the same length as the input vector 'temp' containing the hourly temperatures.
</p>


<h3>Author(s)</h3>

<p>Carsten Urbach &lt;urbach@hiskp.uni-bonn.de&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(KA_weather)
hourtemps &lt;- stack_hourly_temps(KA_weather, latitude=50.4)
iSeason &lt;- genSeason(hourtemps, years=c(2009))
zc &lt;- 190
yc &lt;- 40
x &lt;- PhenoFlex(temp=hourtemps$hourtemps$Temp[iSeason[[1]]],
               times=c(1: length(hourtemps$hourtemps$Temp[iSeason[[1]]])),
               zc=zc, stopatzc=TRUE, yc=yc, basic_output=FALSE)
DBreakDay &lt;- x$bloomindex
ii &lt;- c(1:DBreakDay)
plot(x=ii, y=x$z[ii], xlab="Hour Index", ylab="z", col="red", type="l")
abline(h=zc, lty=2)
plot(x=ii, y=x$y[ii], xlab="Hour Index", ylab="y", col="red", type="l")
abline(h=yc, lty=2)
</code></pre>

<hr>
<h2 id='PhenoFlex_fixedDynModelGAUSSwrapper'>PhenoFlex_fixedDynModelGAUSSwrapper</h2><span id='topic+PhenoFlex_fixedDynModelGAUSSwrapper'></span>

<h3>Description</h3>

<p>PhenoFlex wrapper function for the 'phenologyFitter' function using
the GAUSS heat accumulation model and parameters of the dynamical model
fixed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PhenoFlex_fixedDynModelGAUSSwrapper(
  x,
  par,
  A0 = 139500,
  A1 = 2.567e+18,
  E0 = 4153.5,
  E1 = 12888.8,
  slope = 1.6,
  Tf = 4
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PhenoFlex_fixedDynModelGAUSSwrapper_+3A_x">x</code></td>
<td>
<p>data.frame with at least columns 'Temp' and 'JDay'</p>
</td></tr>
<tr><td><code id="PhenoFlex_fixedDynModelGAUSSwrapper_+3A_par">par</code></td>
<td>
<p>numeric vector of length 11 with the 'PhenoFlex' fit
parameters in the following order: 1. yc, 2. zc, 3. s1, 4. Tu, 5. E0,
6. E1, 7, A0, 8. A1, 9. Tf, 10. Tc, 11. Tb and 12. slope. For details see
<a href="#topic+PhenoFlex">PhenoFlex</a></p>
</td></tr>
<tr><td><code id="PhenoFlex_fixedDynModelGAUSSwrapper_+3A_a0">A0</code></td>
<td>
<p>numeric. Parameter <code class="reqn">A_0</code> of the dynamic model</p>
</td></tr>
<tr><td><code id="PhenoFlex_fixedDynModelGAUSSwrapper_+3A_a1">A1</code></td>
<td>
<p>numeric. Parameter <code class="reqn">A_1</code> of the dynamic model</p>
</td></tr>
<tr><td><code id="PhenoFlex_fixedDynModelGAUSSwrapper_+3A_e0">E0</code></td>
<td>
<p>numeric. Parameter <code class="reqn">E_0</code> of the dynamic model</p>
</td></tr>
<tr><td><code id="PhenoFlex_fixedDynModelGAUSSwrapper_+3A_e1">E1</code></td>
<td>
<p>numeric. Parameter <code class="reqn">E_1</code> of the dynamic model</p>
</td></tr>
<tr><td><code id="PhenoFlex_fixedDynModelGAUSSwrapper_+3A_slope">slope</code></td>
<td>
<p>numeric. Slope parameter for sigmoidal function</p>
</td></tr>
<tr><td><code id="PhenoFlex_fixedDynModelGAUSSwrapper_+3A_tf">Tf</code></td>
<td>
<p>numeric. Transition temperature (in degree Kelvin) for the
sigmoidal function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A single numeric value with the JDay prediction for the
temperaturs in 'x$Temp' and the <a href="#topic+PhenoFlex">PhenoFlex</a> parameters
in 'par'.
</p>

<hr>
<h2 id='PhenoFlex_fixedDynModelwrapper'>PhenoFlex_fixedDynModelwrapper</h2><span id='topic+PhenoFlex_fixedDynModelwrapper'></span>

<h3>Description</h3>

<p>PhenoFlex wrapper function for the 'phenologyFitter' function using
the GDH heat accumulation model and parameters of the dynamical model
fixed. The default values for the dynamic model parameters are from
the excel file with unknown origin.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PhenoFlex_fixedDynModelwrapper(
  x,
  par,
  A0 = 139500,
  A1 = 2.567e+18,
  E0 = 4153.5,
  E1 = 12888.8,
  slope = 1.6,
  Tf = 4
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PhenoFlex_fixedDynModelwrapper_+3A_x">x</code></td>
<td>
<p>data.frame with at least columns 'Temp' and 'JDay'</p>
</td></tr>
<tr><td><code id="PhenoFlex_fixedDynModelwrapper_+3A_par">par</code></td>
<td>
<p>numeric vector of length 11 with the 'PhenoFlex' fit
parameters in the following order: 1. yc, 2. zc, 3. s1, 4. Tu, 5. E0,
6. E1, 7, A0, 8. A1, 9. Tf, 10. Tc, 11. Tb and 12. slope. For details see
<a href="#topic+PhenoFlex">PhenoFlex</a></p>
</td></tr>
<tr><td><code id="PhenoFlex_fixedDynModelwrapper_+3A_a0">A0</code></td>
<td>
<p>numeric. Parameter <code class="reqn">A_0</code> of the dynamic model</p>
</td></tr>
<tr><td><code id="PhenoFlex_fixedDynModelwrapper_+3A_a1">A1</code></td>
<td>
<p>numeric. Parameter <code class="reqn">A_1</code> of the dynamic model</p>
</td></tr>
<tr><td><code id="PhenoFlex_fixedDynModelwrapper_+3A_e0">E0</code></td>
<td>
<p>numeric. Parameter <code class="reqn">E_0</code> of the dynamic model</p>
</td></tr>
<tr><td><code id="PhenoFlex_fixedDynModelwrapper_+3A_e1">E1</code></td>
<td>
<p>numeric. Parameter <code class="reqn">E_1</code> of the dynamic model</p>
</td></tr>
<tr><td><code id="PhenoFlex_fixedDynModelwrapper_+3A_slope">slope</code></td>
<td>
<p>numeric. Slope parameter for sigmoidal function</p>
</td></tr>
<tr><td><code id="PhenoFlex_fixedDynModelwrapper_+3A_tf">Tf</code></td>
<td>
<p>numeric. Transition temperature for the
sigmoidal function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A single numeric value with the JDay prediction for the
temperaturs in 'x$Temp' and the <a href="#topic+PhenoFlex">PhenoFlex</a> parameters
in 'par'.
</p>

<hr>
<h2 id='PhenoFlex_GAUSSwrapper'>PhenoFlex_GAUSSwrapper</h2><span id='topic+PhenoFlex_GAUSSwrapper'></span>

<h3>Description</h3>

<p>PhenoFlex wrapper function for the 'phenologyFitter' function using
the Gaussian heat accumulation model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PhenoFlex_GAUSSwrapper(x, par)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PhenoFlex_GAUSSwrapper_+3A_x">x</code></td>
<td>
<p>data.frame with at least columns 'Temp' and 'JDay'</p>
</td></tr>
<tr><td><code id="PhenoFlex_GAUSSwrapper_+3A_par">par</code></td>
<td>
<p>numeric vector of length 11 with the 'PhenoFlex' fit
parameters in the following order: 1. yc, 2. zc, 3. s1, 4. Tu, 5. E0,
6. E1, 7, A0, 8. A1, 9. Tf, 10. Delta, 11. s. For details see
<a href="#topic+PhenoFlex">PhenoFlex</a></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A single numeric value with the JDay prediction for the
temperatures in 'x$Temp' and the <a href="#topic+PhenoFlex">PhenoFlex</a> parameters
in 'par'.
</p>

<hr>
<h2 id='PhenoFlex_GDHwrapper'>PhenoFlex_GDHwrapper</h2><span id='topic+PhenoFlex_GDHwrapper'></span>

<h3>Description</h3>

<p>PhenoFlex wrapper function for the 'phenologyFitter' function using the GDH heat accumulation model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PhenoFlex_GDHwrapper(x, par)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PhenoFlex_GDHwrapper_+3A_x">x</code></td>
<td>
<p>data.frame with at least columns 'Temp' and 'JDay'</p>
</td></tr>
<tr><td><code id="PhenoFlex_GDHwrapper_+3A_par">par</code></td>
<td>
<p>numeric vector of length 11 with the 'PhenoFlex' fit
parameters in the following order: 1. yc, 2. zc, 3. s1, 4. Tu, 5. E0,
6. E1, 7, A0, 8. A1, 9. Tf, 10. Tc, 11. Tb and 12. slope. For details see
<a href="#topic+PhenoFlex">PhenoFlex</a></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A single numeric value with the JDay prediction for the
temperaturs in 'x$Temp' and the <a href="#topic+PhenoFlex">PhenoFlex</a> parameters
in 'par'.
</p>

<hr>
<h2 id='phenologyFit'>phenologyFit</h2><span id='topic+phenologyFit'></span>

<h3>Description</h3>

<p>Constructor for class 'phenologyFit'
</p>


<h3>Usage</h3>

<pre><code class='language-R'>phenologyFit()
</code></pre>


<h3>Value</h3>

<p>an empty object of class 'phenologyFit'. It contains the named elements 'model_fit' with 
the returned object from GenSA, 'par' the best fit parameters, 'pbloomJDays' the
predicted bloom JDays and the inputs
'par.guess', 'modelfn', 'bloomJDays', and 'SeasonList'. They are
all set to 'NULL' by this function.
</p>

<hr>
<h2 id='phenologyFitter'>phenologyFitter</h2><span id='topic+phenologyFitter'></span>

<h3>Description</h3>

<p>phenologyFitter
</p>


<h3>Usage</h3>

<pre><code class='language-R'>phenologyFitter(
  par.guess = NULL,
  modelfn = PhenoFlex_GDHwrapper,
  bloomJDays,
  SeasonList,
  control = list(smooth = FALSE, verbose = TRUE, maxit = 1000, nb.stop.improvement = 250),
  lower,
  upper,
  seed = 1235433,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="phenologyFitter_+3A_par.guess">par.guess</code></td>
<td>
<p>numeric vector. Initial guesses for fit parameters. This can be set to
'NULL', in which case 'GenSA' choses initial parameters.</p>
</td></tr>
<tr><td><code id="phenologyFitter_+3A_modelfn">modelfn</code></td>
<td>
<p>function. Model function which computes the index in 'temperatures' at
which blooming occures. It must have as first argument a data frame with at least the
two columns 'Temp' and 'JDays' for one season, see 'SeasonList'. It can have further
arguments which can be passed via '...'. The 'modelfn' must return a single numeric value
for the predicted bloom JDay for that season. 'NA' is an allowed return value if no blooming
occures in that season.
The default is the <a href="#topic+PhenoFlex">PhenoFlex</a> with GDH as heat accumulation. Alternative is
<a href="#topic+PhenoFlex_GAUSSwrapper">PhenoFlex_GAUSSwrapper</a> with GAUSSian heat accumulation. But this function can also be user
defined.</p>
</td></tr>
<tr><td><code id="phenologyFitter_+3A_bloomjdays">bloomJDays</code></td>
<td>
<p>integer vector. vector of observed bloom JDays per year</p>
</td></tr>
<tr><td><code id="phenologyFitter_+3A_seasonlist">SeasonList</code></td>
<td>
<p>list. Must be a list of data frames, each data frame for one season. Each data.frame
must at least have a column 'Temp' with the temperature vector and 'JDays' with the corresponding
JDay vector. Can be generated by e.g. <a href="#topic+genSeasonList">genSeasonList</a>.
'length(SeasonList)' must be equal to 'length(bloomJDays)'.</p>
</td></tr>
<tr><td><code id="phenologyFitter_+3A_control">control</code></td>
<td>
<p>control parameters to 'GenSA', see 'GenSA::GenSA'</p>
</td></tr>
<tr><td><code id="phenologyFitter_+3A_lower">lower</code></td>
<td>
<p>Vector with length of ‘par.guess’. Lower bounds for components.</p>
</td></tr>
<tr><td><code id="phenologyFitter_+3A_upper">upper</code></td>
<td>
<p>Vector with length of ‘par.guess’. Upper bounds for components.</p>
</td></tr>
<tr><td><code id="phenologyFitter_+3A_seed">seed</code></td>
<td>
<p>integer seed for the random number generator used by 'GenSA'.</p>
</td></tr>
<tr><td><code id="phenologyFitter_+3A_...">...</code></td>
<td>
<p>further parameters to be passed on to 'modelfn'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class 'phenologyFit'. It contains the named elements 'model_fit' with
the returned object from GenSA, 'par' the best fit parameters, 'pbloomJDays' the
predicted bloom JDays and the inputs
'par.guess', 'modelfn', 'bloomJDays', 'lower', 'upper', 'control', 'SeasonList' and
'...'.
</p>


<h3>Author(s)</h3>

<p>Carsten Urbach &lt;urbach@hiskp.uni-bonn.de&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## this example does not make sense as a fit, but demonstrates
## how to use `phenologyFitter`
data(KA_weather)
data(KA_bloom)
hourtemps &lt;- stack_hourly_temps(KA_weather, latitude=50.4)
SeasonList &lt;- genSeasonList(hourtemps$hourtemps, years=c(2007,2008))
par &lt;- c(40, 190, 0.5, 25, 3372.8, 9900.3, 6319.5, 5.939917e13, 4, 36, 4, 1.6)
upper &lt;- c(41, 200, 1, 30, 4000, 10000, 7000, 6.e13, 10, 40, 10, 50)
lower &lt;- c(38, 180, 0.1, 0, 3000, 9000, 6000, 5.e13, 0, 0, 0, 0.05)
X &lt;- phenologyFitter(par.guess=par, bloomJDays=KA_bloom$pheno[c(24,25)], 
  SeasonList=SeasonList, lower=lower, upper=upper,
  control=list(smooth=FALSE, verbose=TRUE, maxit=10, nb.stop.improvement=5))
summary(X)
plot(X)
</code></pre>

<hr>
<h2 id='plot_climate_scenarios'>Plot multiple chilling scenario groups (or for other metrics)</h2><span id='topic+plot_climate_scenarios'></span>

<h3>Description</h3>

<p>For quantifying climate risks, it is useful to generate many version of plausible weather for
particular climate scenarios. This can, for example, be done with the temperature_generation function.
This function facilitates illustration of these results by providing various options to show them as
boxplots. The function can plot either a single panel of climate scenarios or multiple panels
side by side.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_climate_scenarios(
  climate_scenario_list,
  metric,
  metric_label,
  year_name = "End_year",
  label_sides = "both",
  ylim = c(0, NA),
  reference_line = NULL,
  col_rect = NA,
  col_line = NA,
  hist_col = NA,
  texcex = 2,
  caption_above = FALSE,
  family = "serif",
  no_scenario_numbers = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_climate_scenarios_+3A_climate_scenario_list">climate_scenario_list</code></td>
<td>
<p>list of lists containing information about the chill scenarios.
These lists must have an element named 'data' which should contain a data.frame with a column
named the same as the 'metric' argument, which contains (numeric) information to be plotted.
Additional optional elements are 'time_series' (Boolean, indicating if a time series is to be plotted),
'labels' (vector of length 'length(data)' containing labels for the scenarios - if this is a time
series scenario, these must be numeric; if the data are not a time series, the labels aren't shown in the
plot, because there wouldn't normally be enough space - only numbers are shown there, and the legend
is provided in the value returned by this function), 'caption' (up to three character strings indicating
the caption to be displayed in the respective plot panel; the elements of this vector are displayed on
different lines. If caption_above==TRUE, only the first element is displayed) and 'historic_data'
(a data.frame containing at least two columns named the same as 'metric' and 'year_name').
documentation of 'make_chill_scenario_plot' for details on these.</p>
</td></tr>
<tr><td><code id="plot_climate_scenarios_+3A_metric">metric</code></td>
<td>
<p>character string corresponding to the name of the column that contains the data of
interest in the climate_scenario_list data.frames (and if applicable the historic_data data.frame).</p>
</td></tr>
<tr><td><code id="plot_climate_scenarios_+3A_metric_label">metric_label</code></td>
<td>
<p>character string specifying the y-axis label.</p>
</td></tr>
<tr><td><code id="plot_climate_scenarios_+3A_year_name">year_name</code></td>
<td>
<p>character string indicating the name of the time column in the historic_data data.frame.</p>
</td></tr>
<tr><td><code id="plot_climate_scenarios_+3A_label_sides">label_sides</code></td>
<td>
<p>indicates what sides of the plot y-axis labels are to be drawn. Can be &quot;left', &quot;right&quot;
or &quot;both&quot;. If label_sides assumes any other value, no labels are plotted.</p>
</td></tr>
<tr><td><code id="plot_climate_scenarios_+3A_ylim">ylim</code></td>
<td>
<p>numeric vector of length 2, specifying the lower and upper limits of the y-axis. If either of
these two values is NA, it is automatically selected based on the data range.</p>
</td></tr>
<tr><td><code id="plot_climate_scenarios_+3A_reference_line">reference_line</code></td>
<td>
<p>numeric vector of length 1, 2 or 3, specifying a horizontal reference bar to be drawn
across the plot (e.g. to indicate exceedance of a threshold). A reference_line argument of length 1 is
interpreted by drawing a line across the plot at the specified value. If length(reference_line)==2, the
values are interpreted as lower and upper limit of a rectangular threshold area. If
length(reference_line)==3, the lowest and highest values are used to draw a rectangle and the median value
to draw a line (e.g. to show a best estimate and a confidence interval around it).</p>
</td></tr>
<tr><td><code id="plot_climate_scenarios_+3A_col_rect">col_rect</code></td>
<td>
<p>color code or name for the color of the reference_line rectangle.</p>
</td></tr>
<tr><td><code id="plot_climate_scenarios_+3A_col_line">col_line</code></td>
<td>
<p>color code or name for the color of the reference_line line.</p>
</td></tr>
<tr><td><code id="plot_climate_scenarios_+3A_hist_col">hist_col</code></td>
<td>
<p>color code or name for the color of the historic data points.</p>
</td></tr>
<tr><td><code id="plot_climate_scenarios_+3A_texcex">texcex</code></td>
<td>
<p>numeric variable indicating character size (cex for all text elements in the plot).</p>
</td></tr>
<tr><td><code id="plot_climate_scenarios_+3A_caption_above">caption_above</code></td>
<td>
<p>Boolean variable indicating whether the caption should be drawn above (TRUE) or
inside the figure.</p>
</td></tr>
<tr><td><code id="plot_climate_scenarios_+3A_family">family</code></td>
<td>
<p>character string specifying the font family ('serif', 'sans' or 'mono').</p>
</td></tr>
<tr><td><code id="plot_climate_scenarios_+3A_no_scenario_numbers">no_scenario_numbers</code></td>
<td>
<p>Boolean variable indicating whether climate scenarios should be numbered
in the plot (this can clutter the figure).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List of legends for the different panels of the plot. This list reads 'time series labels'
for time series plot, 'no adequate labels provided' for unlabeled collections of boxplot, and a data.frame
explaining the number codes used as the legend in labeled collections of boxplots.
As a side effect, a plot of the climate scenarios is drawn.
</p>
<p>The function generates errors, when problems arise.
</p>


<h3>Author(s)</h3>

<p>Eike Luedeling
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  #making 3 identical objects as scenarios; let's assume these represent the
  #years 2000, 2005 and 2010. 
  
  models&lt;-list(Chilling_Hours=Chilling_Hours,Utah_Chill_Units=Utah_Model,Chill_Portions=
     Dynamic_Model,GDH=GDH)
  
  chill&lt;-tempResponse(stack_hourly_temps(
     fix_weather(KA_weather[which(KA_weather$Year&gt;2003),]),latitude=50.4),
     Start_JDay = 305,End_JDay = 60,models)
  scenario_results&lt;-list(chill,chill,chill)
  
  climate_scenario_list&lt;-list(list(data=scenario_results,
                                   caption=c("Historic","data"),
                                   time_series=TRUE,
                                   labels=c(2000,2005,2010),
                                   historic_data=chill),
                              list(data=scenario_results,
                                   caption=c("Scenario","1"),
                                   labels=c("Climate model 1",
                                            "Climate model 2",
                                            "Climate model 3")),
                              list(data=scenario_results,
                                   caption=c("Scenario","2")),
                              list(data=scenario_results,
                                   caption=c("Scenario","3")))
                                   
                                   
 plot_climate_scenarios(climate_scenario_list,metric="Chill_Portions",
                                 metric_label="Chill Portions",
                                 year_name="End_year",label_sides="both",
                                 reference_line=c(40,45,50),col_rect=NA,col_line=NA,
                                 texcex=2,caption_above=FALSE)
                                 
 plot_climate_scenarios(climate_scenario_list,"Chill_Portions","Chill Portions",
    texcex=1)

  
 
</code></pre>

<hr>
<h2 id='plot_climateWizard_scenarios'>Plot mutltiple ClimateWizard scenarios obtained with getClimateWizard_scenarios</h2><span id='topic+plot_climateWizard_scenarios'></span>

<h3>Description</h3>

<p>This function plots multiple scenarios obtained with the getClimateWizard_scenarios
function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_climateWizard_scenarios(
  getscenarios_element,
  low_filter = -1000,
  high_filter = 1000,
  color = "cadetblue"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_climateWizard_scenarios_+3A_getscenarios_element">getscenarios_element</code></td>
<td>
<p>outputs from the getClimateWizard_scenarios function</p>
</td></tr>
<tr><td><code id="plot_climateWizard_scenarios_+3A_low_filter">low_filter</code></td>
<td>
<p>numeric value specifying the lowest plausible value for the
variable of interest. This is sometimes necessary to exclude erroneous values
in the ClimateWizard database.</p>
</td></tr>
<tr><td><code id="plot_climateWizard_scenarios_+3A_high_filter">high_filter</code></td>
<td>
<p>numeric value specifying the highest plausible value for the
variable of interest. This is sometimes necessary to exclude erroneous values
in the ClimateWizard database.</p>
</td></tr>
<tr><td><code id="plot_climateWizard_scenarios_+3A_color">color</code></td>
<td>
<p>color to be used for the plots.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns nothing, but a plot is produced as a side effect.
</p>


<h3>Author(s)</h3>

<p>Eike Luedeling
</p>


<h3>References</h3>

<p>Girvetz E, Ramirez-Villegas J, Navarro C, Rodriguez C, Tarapues J, undated.
ClimateWizard REST API for querying climate change data.
https://github.com/CIAT-DAPA/climate_wizard_api
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#example is #d out, because of runtime issues.
#getC&lt;-getClimateWizard_scenarios(coordinates=c(longitude=6.99,latitude=50.62),
#                                scenarios=c("rcp45","rcp45","rcp85","rcp85"),
#                                start_years=c(2035,2070,2035,2070),
#                                end_years=c(2065,2100,2065,2100),
#                                metric=c("monthly_tmean"),
#                                GCMs=c("all"))
#plot_climateWizard_scenarios(getC,low_filter=-6,high_filter=6,color="red")

</code></pre>

<hr>
<h2 id='plot_phenology_trends'>Visualizing phenology responses to temperatures during two phases</h2><span id='topic+plot_phenology_trends'></span>

<h3>Description</h3>

<p>The timing of many development stages of temperate trees may depend on temperatures during two
phases (e.g. bloom dates depend on the temperature during both the chilling and forcing phase of dormancy).
<code>plot_phenology_trends()</code> illustrates this dependency as a colored surface with contour lines by applying an
interpolating procedure with functions in the <code><a href="fields.html#topic+fields">fields</a></code> package. The plot is implemented
through functions in the <code><a href="ggplot2.html#topic+ggplot2">ggplot2</a></code> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_phenology_trends(
  pheno_data,
  weather_data,
  split_month = 6,
  chilling_phase,
  forcing_phase,
  Krig_warn = TRUE,
  x_axis_name = NULL,
  y_axis_name = NULL,
  legend_name = NULL,
  contour_line_color = "black",
  point_color = "black",
  point_shape = 19,
  legend_colors = NULL,
  base_size = 11,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_phenology_trends_+3A_pheno_data">pheno_data</code></td>
<td>
<p>is a data frame that contains information on the timing of phenology events by year.
It should consist of two columns called <code>Year</code> and <code>pheno</code>. Data in the <code>pheno</code> column should be in
Julian date (day of the year).</p>
</td></tr>
<tr><td><code id="plot_phenology_trends_+3A_weather_data">weather_data</code></td>
<td>
<p>is a data frame containing daily minimum and maximum temperature data (in columns
called <code>Tmin</code> and <code>Tmax</code>, respectively). There also has to be a column for <code>Year</code>, one for
<code>Month</code> and one for <code>Day</code>. It can also contain a column for <code>JDay</code>
(the Julian date, or day of the year).</p>
</td></tr>
<tr><td><code id="plot_phenology_trends_+3A_split_month">split_month</code></td>
<td>
<p>is an integer representing the last month of the growing season. This procedure analyzes
data by phenology year, which can start and end in any month during the calendar year (currently only
at the beginning of a month). This variable indicates the last month (e.g. 5 for May) that should be
included in the record for a given phenology year. All subsequent months are assigned to the 
following phenology year.</p>
</td></tr>
<tr><td><code id="plot_phenology_trends_+3A_chilling_phase">chilling_phase</code></td>
<td>
<p>is a vector of integers representing the start and end for the chilling period
in temperate trees. Numbers must be provided in Julian date (day of the year).</p>
</td></tr>
<tr><td><code id="plot_phenology_trends_+3A_forcing_phase">forcing_phase</code></td>
<td>
<p>is a vector of integers representing the start and end for the forcing period
in temperate trees. Numbers must be provided in Julian date (day of the year).</p>
</td></tr>
<tr><td><code id="plot_phenology_trends_+3A_krig_warn">Krig_warn</code></td>
<td>
<p>is a boolean parameter passed to the <code><a href="fields.html#topic+Krig">Krig</a></code> function. Default is
set to <code>TRUE</code> following the recommendation of the authors of the package. For detailed information, please see the documentation
of the function.</p>
</td></tr>
<tr><td><code id="plot_phenology_trends_+3A_x_axis_name">x_axis_name</code></td>
<td>
<p>is a character string that allows the user modifying the default label used in the x axis.</p>
</td></tr>
<tr><td><code id="plot_phenology_trends_+3A_y_axis_name">y_axis_name</code></td>
<td>
<p>is a character string that allows the user modifying the default label used in the y axis.</p>
</td></tr>
<tr><td><code id="plot_phenology_trends_+3A_legend_name">legend_name</code></td>
<td>
<p>is a character string that allows the user modifying the default label used in the legend.</p>
</td></tr>
<tr><td><code id="plot_phenology_trends_+3A_contour_line_color">contour_line_color</code></td>
<td>
<p>is a character string representing the color used to draw the contour lines.
Default is set to black. If <code>NA</code> is used, the function will remove the contour lines with a warning.</p>
</td></tr>
<tr><td><code id="plot_phenology_trends_+3A_point_color">point_color</code></td>
<td>
<p>is a character string representing the color used to draw the points for actual
observations. Default is set to black. If <code>NA</code> is used, the function will remove the points with
a warning.</p>
</td></tr>
<tr><td><code id="plot_phenology_trends_+3A_point_shape">point_shape</code></td>
<td>
<p>is a numeric input representing the point shape used to draw the points for actual
observations. Default is set to 19 (filled point). If <code>NA</code> is used, the function will remove the points with
a warning.</p>
</td></tr>
<tr><td><code id="plot_phenology_trends_+3A_legend_colors">legend_colors</code></td>
<td>
<p>is a character string representing the color scale used in the surface plot.
Default is set to <code>NULL</code> to let the function use the rainbow colors.</p>
</td></tr>
<tr><td><code id="plot_phenology_trends_+3A_base_size">base_size</code></td>
<td>
<p>is a numeric input representing the relative size of the elements in plot. <code>base_size</code>
is passed to <code><a href="ggplot2.html#topic+ggtheme">ggplot2::theme_bw</a></code> as well as used to determine the size of the
points and contour lines.</p>
</td></tr>
<tr><td><code id="plot_phenology_trends_+3A_...">...</code></td>
<td>
<p>accepts arguments passed to <code><a href="ggplot2.html#topic+theme">ggplot2::theme</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The generation of the color surface is based on the Kriging technique, which is typically used for 
interpolation of spatial data. The use for this particular purpose is a bit experimental.
</p>


<h3>Value</h3>

<p><code>plot_phenology_trends()</code> is expected to return an object of class <code>gg</code> and <code>ggplot</code>. This
means that the plot can be later modified by using the syntax <code>'+'</code> from the
<code><a href="ggplot2.html#topic+ggplot2">ggplot2</a></code> package (see examples). The plot returned in the function should look as the following:
</p>
<p><img src="../help/figures/rainbowplotexample.png" width='100%' alt='rainbow\_plot example' />

</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Run a simple plot
# Code is commented out, so that it passes the CRAN incoming checks.
# Please uncomment to run the code.

# plot_phenology_trends(pheno_data = chillR::KA_bloom,
#                       weather_data = chillR::KA_weather,
#                       chilling_phase = c(306, 350),
#                       forcing_phase = c(355, 60))
             
# Customize the aspects of the plot and save it as 'plot'

# plot &lt;- plot_phenology_trends(pheno_data = chillR::KA_bloom,
#                               weather_data = chillR::KA_weather,
#                               chilling_phase = c(306, 350),
#                               forcing_phase = c(355, 60),
#                               x_axis_name = "Temperatura en el periodo de frio (Celsius)",
#                               y_axis_name = "Temperatura en el periodo de forzado (Celsius)",
#                               legend_name = "Fecha de floracion\n(dia juliano)",
#                               contour_line_color = "white",
#                               point_color = "blue4",
#                               point_shape = 4,
#                               legend_colors = NULL,
#                               base_size = 14,
#                               legend.position = "bottom",
#                               axis.title = ggplot2::element_text(family = "serif"))

# plot

# Modify the plot object with the syntax from ggplot2.
# Be aware that the following code overrides the modifications
# done by the argument '...' in the main function

# plot + ggplot2::theme_classic(base_size = 14)

</code></pre>

<hr>
<h2 id='plot_PLS'>Output of Partial Least Squares analysis results of phenology vs. daily mean
temperatures</h2><span id='topic+plot_PLS'></span>

<h3>Description</h3>

<p>This function produces figures that illustrate statistical correlations
between temperature variation during certain phases and the timing of
phenological event, based on a PLS analysis conducted with the PLS_pheno or
the PLS_chill_force function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_PLS(
  PLS_output,
  PLS_results_path,
  VIP_threshold = 0.8,
  colorscheme = "color",
  plot_bloom = TRUE,
  fonttype = "serif",
  add_chill = c(NA, NA),
  add_heat = c(NA, NA),
  plot_titles_Temp = "Mean temperature",
  plot_titles_chill_force = c("Chill Accumulation", "Heat Accumulation"),
  axis_labels_Temp = expression("Mean temperature ("^"o" * "C)"),
  axis_labels_chill_force = c("Chill Portions per day", "GDH per day"),
  chill_force_same_scale = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_PLS_+3A_pls_output">PLS_output</code></td>
<td>
<p>a PLS_output object - the output of the PLS_pheno
function. This object is a list with a list element called PLS_summary (and
an optional object called PLS_output). This element is a data.frame with the
following columns: Date, JDay, Coef, VIP, Tmean, Tstdev. Date is the day of
the year in MDD format. JDay is the Julian day (day of the year) of the year
in which the biological event is observed; since the analysis will often
start in the year before the event, this column often starts with negative
numbers. Coef is the coefficient of the PLS regression output. VIP is the
Variable Importance in the Projection, another output of the PLS regression.
Tmean is the mean observed temperature of the respective day of the year,
for the duration of the phenology record. Tstdev is the standard deviation
of temperature on a given day of the year over the length of the phenology
record.</p>
</td></tr>
<tr><td><code id="plot_PLS_+3A_pls_results_path">PLS_results_path</code></td>
<td>
<p>the path where analysis outputs should be saved.
Should include the file name, but without suffix.</p>
</td></tr>
<tr><td><code id="plot_PLS_+3A_vip_threshold">VIP_threshold</code></td>
<td>
<p>the VIP threshold, above which a variable is considered
important. Defaults to 0.8.</p>
</td></tr>
<tr><td><code id="plot_PLS_+3A_colorscheme">colorscheme</code></td>
<td>
<p>color scheme used for plotting. For grayscale image, this
should be set to &quot;bw&quot;. Otherwise a color plot is produced.</p>
</td></tr>
<tr><td><code id="plot_PLS_+3A_plot_bloom">plot_bloom</code></td>
<td>
<p>boolean variable specifying whether the range of bloom
dates should be shown in the plots. If set to TRUE, this range is shown by a
semi-transparent gray rectangle. The median bloom date is shown as a dashed
line. This only works if the full range of bloom dates is visible in the
plot, and it should be set to FALSE if anything other than Julian dates are
used as dependent variables.</p>
</td></tr>
<tr><td><code id="plot_PLS_+3A_fonttype">fonttype</code></td>
<td>
<p>font style to be used for the figure. Can be 'serif'
(default) or 'sans'.</p>
</td></tr>
<tr><td><code id="plot_PLS_+3A_add_chill">add_chill</code></td>
<td>
<p>option for indicating the chilling period in the plot. This
should be a numeric vector: c(start_chill,end_chill).</p>
</td></tr>
<tr><td><code id="plot_PLS_+3A_add_heat">add_heat</code></td>
<td>
<p>option for indicating the forcing period in the plot. This
should be a numeric vector: c(start_heat,end_heat).</p>
</td></tr>
<tr><td><code id="plot_PLS_+3A_plot_titles_temp">plot_titles_Temp</code></td>
<td>
<p>title for the bottom plot, which relates PLS outputs
to values of the input variable (temperature in the original version). Only
affects the output for PLS_Temp_pheno objects.</p>
</td></tr>
<tr><td><code id="plot_PLS_+3A_plot_titles_chill_force">plot_titles_chill_force</code></td>
<td>
<p>titles for the bottom plots, which relate PLS outputs
to values of the input variables (chill and heat accumulation). Only affects the
output for PLS_chillforce_pheno objects.</p>
</td></tr>
<tr><td><code id="plot_PLS_+3A_axis_labels_temp">axis_labels_Temp</code></td>
<td>
<p>y-axis label for the bottom plot, which relates PLS outputs
to values of the input variable (temperature in the original version). Only
affects the output for PLS_Temp_pheno objects.</p>
</td></tr>
<tr><td><code id="plot_PLS_+3A_axis_labels_chill_force">axis_labels_chill_force</code></td>
<td>
<p>y-axis labels for the bottom plots, which relate PLS outputs
to values of the input variables (chill and heat accumulation). Only affects the
output for PLS_chillforce_pheno objects.</p>
</td></tr>
<tr><td><code id="plot_PLS_+3A_chill_force_same_scale">chill_force_same_scale</code></td>
<td>
<p>Boolean parameter indicating whether the two sets of
VIP scores and model coefficients resulting from a PLS_chillforce_pheno analysis
should be shown on the same scale in the separate output diagrams. Since this
is generally advisable for comparison, this defaults to TRUE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Ths figure illustrates results from the PLS_pheno function, which uses
Partial Least Squares (or Projection to Latent Structures) regression to
examine the relationship between mean daily temperatures and the timing of
an annual biological event. It produces a plot (as a bmp image) with three
panels: the top panel shows the value of the VIP score for each day of the
year; the middle panel shows the model coefficients and the bottom panel
shows the mean temperature and its standard deviation. In the top plot, all
days with VIP scores above VIP_threshold are shown in blue. In the other two
panels, values for the same days are shown in red, which high VIP scores
coincide with negative model coefficients, and in green for positive
coefficients. This function does not produce an output, but as side effects
it produces a bmp image and a table that summarizes all data used for making
the figure in the specified folder.
</p>


<h3>Author(s)</h3>

<p>Eike Luedeling
</p>


<h3>References</h3>

<p>The method is described here:
</p>
<p>Luedeling E and Gassner A, 2012. Partial Least Squares Regression for
analyzing walnut phenology in California. Agricultural and Forest
Meteorology 158, 43-52.
</p>
<p>Wold S, 1995. PLS for multivariate linear modeling. In: van der Waterbeemd H
(ed) Chemometric methods in molecular design: methods and principles in
medicinal chemistry, vol 2. Chemie, Weinheim, pp 195-218.
</p>
<p>Wold S, Sjostrom M, Eriksson L, 2001. PLS-regression: a basic tool of
chemometrics. Chemometr Intell Lab 58(2), 109-130.
</p>
<p>Mevik B-H, Wehrens R, Liland KH, 2011. PLS: Partial Least Squares and
Principal Component Regression. R package version 2.3-0.
http://CRAN.R-project.org/package0pls.
</p>
<p>Some applications:
</p>
<p>Guo L, Dai J, Wang M, Xu J, Luedeling E, 2015. Responses of spring phenology
in temperate zone trees to climate warming: a case study of apricot
flowering in China. Agricultural and Forest Meteorology 201, 1-7.
</p>
<p>Luedeling E, Kunz A and Blanke M, 2013. Identification of chilling and heat
requirements of cherry trees - a statistical approach. International Journal
of Biometeorology 57,679-689.
</p>
<p>Yu H, Luedeling E and Xu J, 2010. Stronger winter than spring warming delays
spring phenology on the Tibetan Plateau. Proceedings of the National Academy
of Sciences (PNAS) 107 (51), 22151-22156.
</p>
<p>Yu H, Xu J, Okuto E and Luedeling E, 2012. Seasonal Response of Grasslands
to Climate Change on the Tibetan Plateau. PLoS ONE 7(11), e49230.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
weather&lt;-fix_weather(KA_weather[which(KA_weather$Year&gt;2004),])
#Plots look much better with weather&lt;-fix_weather(KA_weather)
#but that takes to long to run for passing CRAN checks

PLS_results&lt;-PLS_pheno(
  weather_data=weather$weather,
  split_month=6,   #last month in same year
  bio_data=KA_bloom)
  
PLS_results_path&lt;-paste(getwd(),"/PLS_output",sep="")
  
#plot_PLS(PLS_results,PLS_results_path)
#plot_PLS(PLS_results,PLS_results_path,add_chill=c(307,19),add_heat=c(54,109))

dc&lt;-daily_chill(stack_hourly_temps(weather,50.4), 11)
plscf&lt;-PLS_chill_force(daily_chill_obj=dc, bio_data_frame=KA_bloom, split_month=6)

#plot_PLS(plscf,PLS_results_path)
#plot_PLS(plscf,PLS_results_path,add_chill=c(307,19),add_heat=c(54,109))



</code></pre>

<hr>
<h2 id='plot_scenarios'>Plot historic and future scenarios for climate-related metrics (<code><a href="ggplot2.html#topic+ggplot2">ggplot2</a></code> version)</h2><span id='topic+plot_scenarios'></span>

<h3>Description</h3>

<p>Visualize outputs from the <code><a href="#topic+temperature_generation">temperature_generation</a></code> function used
in climate-related assessments. These outputs are usually compiled with the
<code><a href="#topic+make_climate_scenario">make_climate_scenario</a></code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_scenarios(
  scenario_list,
  metric,
  add_historic = TRUE,
  ...,
  outlier_shape = 19,
  historic_color = "white",
  group_by = c("Scenario", "Year"),
  y_axis_name = paste("Cumulative response in", metric),
  x_axis_name = "Year",
  legend_title = "Climate model",
  legend_labels = NULL,
  panel_labels = NULL,
  base_size = 11
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_scenarios_+3A_scenario_list">scenario_list</code></td>
<td>
<p>is a list of lists containing information and data about the scenarios to be plotted. These
lists must have:</p>

<ul>
<li><p>an element named <code>data</code>, which should be a list containing one or more named dataframes with a column
named the same as the <code>metric</code> argument. This column must contain (<code>numeric</code>) information to be plotted.
Dataframes of climate-related metrics can be obtained with the 
<code><a href="#topic+tempResponse_daily_list">tempResponse_daily_list</a></code> function. For
past scenarios, the names of the dataframes can be the reference years used to generate the
scenarios. These names will be recycled and used in the x-axis of the historic panel. For future 
scenarios, the names of the dataframes can be the models used in the projections. These names
will appear in the legend for future panels.
</p>
</li>
<li><p>an element named <code>caption</code> containing information about the scenario which the list
is related to.
</p>
</li>
<li><p>an element named <code>historic_data</code> which represents a data frame for 
actual observations in past scenarios. This element can be optional but is mandatory if
<code>add_historic = TRUE</code>
</p>
</li>
<li><p><code>time_series</code> is an optional argument that defines whether the scenario contains
a time series.
</p>
</li>
<li><p><code>labels</code> is an optional vector that usually contains the names of the elements used for
<code>metric_summary</code> in <code><a href="#topic+make_climate_scenario">make_climate_scenario</a></code>.</p>
</li></ul>
</td></tr>
<tr><td><code id="plot_scenarios_+3A_metric">metric</code></td>
<td>
<p>is a character string corresponding to the name of the column that contains the data of interest
in the dataframe of the <code>scenario_list</code> (and, if applicable, in the
<code>historic_data</code>).</p>
</td></tr>
<tr><td><code id="plot_scenarios_+3A_add_historic">add_historic</code></td>
<td>
<p>is a boolean parameter to define whether the plot should include the actual observations
of historic climate-related metrics.</p>
</td></tr>
<tr><td><code id="plot_scenarios_+3A_...">...</code></td>
<td>
<p>accepts arguments that can be passed to <code><a href="ggplot2.html#topic+layer">layer</a></code> and are 
commonly used outside the aesthetic function for different geoms. In this case, <code>...</code> is passed to the 
<code><a href="ggplot2.html#topic+geom_point">geom_point</a></code> function in the case that actual observations of chill or heat
are displayed. Options are <code>size</code>, <code>color</code>, among others.</p>
</td></tr>
<tr><td><code id="plot_scenarios_+3A_outlier_shape">outlier_shape</code></td>
<td>
<p>is the optional shape to replace the outliers in the boxplots. To show no oultiers
use <code>NA</code>. See <code><a href="ggplot2.html#topic+aes_linetype_size_shape">shape</a></code> for shape options.</p>
</td></tr>
<tr><td><code id="plot_scenarios_+3A_historic_color">historic_color</code></td>
<td>
<p>is a character string corresponding to the color used to fill the boxplots in simulated
historic scenarios. Supported options are those provided by <code><a href="grDevices.html#topic+colors">colors</a></code>.</p>
</td></tr>
<tr><td><code id="plot_scenarios_+3A_group_by">group_by</code></td>
<td>
<p>is a vector of character strings indicating how the plots should be grouped.
I.e. by <code>Scenario</code> and then <code>Year</code> or viceversa.</p>
</td></tr>
<tr><td><code id="plot_scenarios_+3A_y_axis_name">y_axis_name</code></td>
<td>
<p>is a character string representing the title of the y axis in the final plot. Default
is set to <code>paste('Cumulative response in', metric)</code> to let the function obtain the name based on 
the <code>metric</code> argument.</p>
</td></tr>
<tr><td><code id="plot_scenarios_+3A_x_axis_name">x_axis_name</code></td>
<td>
<p>is a character string representing the title of the x axis in the 'Historic' panel.
Default is set to <code>Year</code>.</p>
</td></tr>
<tr><td><code id="plot_scenarios_+3A_legend_title">legend_title</code></td>
<td>
<p>is a character string representing the title of the legend showing the
climate models used in the assessment.</p>
</td></tr>
<tr><td><code id="plot_scenarios_+3A_legend_labels">legend_labels</code></td>
<td>
<p>is a vector of character strings that allows the user to modify the names of the climate
models used in the projections. The length of the vector must coincide with the number of climate models.
Default is set to <code>NULL</code> to let the function use the labels generated with the
<code><a href="#topic+make_climate_scenario">make_climate_scenario</a></code> function.</p>
</td></tr>
<tr><td><code id="plot_scenarios_+3A_panel_labels">panel_labels</code></td>
<td>
<p>is a list of 3 named objects that allows the user to customize the text in the upper part
of the plot. Default is set to <code>NULL</code> to let the function use the labels generated with the
<code><a href="#topic+make_climate_scenario">make_climate_scenario</a></code> function. If provided, the
objects of the list must be:</p>

<ul>
<li><p>an element named <strong>Historic</strong> containing the name to be used in the 'Historic' panel.
</p>
</li>
<li><p>an element named <strong>Scenario</strong> containing the names of the scenarios used for the projections.
If <code>group_by = c("Year", "Scenario")</code> is used, <code>Scenario</code> must be a list of named objects 
according to the labels used in the <code>Year</code> object. See examples.
</p>
</li>
<li><p>an element named <strong>Year</strong> containing the labels to be used for the time horizons used in the
assessment. If <code>group_by = c("Scenario", "Year")</code> is used, <code>Year</code> must be a list of named objects 
according to the labels used in the <code>Scenario</code> object. See examples.</p>
</li></ul>
</td></tr>
<tr><td><code id="plot_scenarios_+3A_base_size">base_size</code></td>
<td>
<p>is an integer to define the relative size of the text in the final plot. This argument
is passed to <code><a href="ggplot2.html#topic+ggtheme">ggpplot2::theme_bw</a></code>. Default is set to 11.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>plot_scenarios</code> uses the <code><a href="ggplot2.html#topic+ggplot2">ggplot2</a></code> syntax for producing separated
plots for historic and future scenarios. Later, the plots are merged into one final figure by using the
<code><a href="patchwork.html#topic+patchwork">patchwork</a></code> library.
</p>


<h3>Value</h3>

<p>A plot of classes <code>'patchwork'</code>, <code>'gg'</code>, and <code>'ggplot'</code>. This allows the user to
continue editing some features of the plots through the syntax (i.e. <code>'&amp;'</code>,
and <code>'+'</code>) from both libraries (see examples).
</p>
<p><img src="../help/figures/plotscenariosexample.png" width='100%' alt='plot\_scenarios example' />

</p>


<h3>Author(s)</h3>

<p>Eduardo Fernandez and Eike Luedeling
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Make 3 identical objects as scenarios; let's assume these represent the
# years 2000, 2005 and 2010.

library(chillR)

# Compute chill responses for KA_weather data

chill &lt;- tempResponse(stack_hourly_temps(
                      fix_weather(KA_weather[which(KA_weather$Year &gt; 2006), ]),
                      latitude = 50.4), Start_JDay = 305, End_JDay = 60)


# Simulated scenarios labels

past_labels &lt;- c(2000, 2005, 2010)

# Models labels

models_labels &lt;- c("Climate model 1", "Climate model 2",
                   "Climate model 3")

# Add named elements to past and future scenarios

scenario_results_past &lt;- list(`2000` = chill,
                              `2005` = chill,
                              `2010` = chill)
                              
scenario_results_future &lt;- list(`Climate model 1` = chill,
                                `Climate model 2` = chill,
                                `Climate model 3` = chill)

# Define the climate scenario  

climate_scenario_list &lt;- list(list(data = scenario_results_past,
                                   caption = c("Historic", "data"),
                                   time_series = TRUE,
                                   labels = past_labels,
                                   historic_data = chill),
                              list(data = scenario_results_future,
                                   caption = c("Scenario 1", "2050"),
                                   labels = models_labels),
                              list(data = scenario_results_future,
                                   caption = c("Scenario 1", "2075"),
                                   labels = models_labels),
                              list(data = scenario_results_future,
                                   caption=c("Scenario 1", "2100"),
                                   labels = models_labels),
                              list(data = scenario_results_future,
                                   caption=c("Scenario 2", "2040"),
                                   labels = models_labels),
                              list(data = scenario_results_future,
                                   caption=c("Scenario 2", "2080"),
                                   labels = models_labels))
                                   
# Plot the climate scenarios

plot_scenarios(climate_scenario_list, metric = 'Chill_Portions',
               add_historic = TRUE, size = 2, shape = 3, color = 'blue',
               outlier_shape = 12, historic_color = 'skyblue',
               group_by = c("Year", "Scenario"))
               
## Plot scenarios modifying the whole text in the plot
## We will comment the next examples to reduce the running time in CRAN
## submissions...
# plot_scenarios(scenario_list = climate_scenario_list, metric = 'Chill_Portions',
#                add_historic = TRUE, size = 2, shape = 3, color = 'blue',
#                outlier_shape = 12, historic_color = 'skyblue',
#                group_by = c("Scenario", "Year"),
#                y_axis_name = "Acumulacion de frio en CP",
#                x_axis_name = "Tiempo",
#                legend_title = "Modelo climatico",
#                legend_labels = c("Modelo 1", "Modelo 2", "Modelo 3"),
#                panel_labels = list(Historic = "Historico",
#                                    Scenario = c("Escenario 1",
#                                                 "Escenario 2"),
#                                    Year = list(`Escenario 1` = c("Futuro cercano",
#                                                                  "Futuro medio",
#                                                                  "Future lejano"),
#                                                `Escenario 2` = c("Futuro cercano",
#                                                                  "Futuro medio"))))

## Since the output is a ggplot object, it is possible to continue
## modifying some general aspects of the plot

## Define the basic plot 
# plot &lt;- plot_scenarios(climate_scenario_list, metric = 'Chill_Portions',
#                        add_historic = TRUE, size = 2, shape = 3, color = 'blue',
#                        outlier_shape = 12, historic_color = 'skyblue')


## Example to change the color of the climate model scale

# plot &amp; ggplot2::scale_fill_brewer(type = 'qual')

## Modify the format of axis title and axis text

# plot &amp; ggplot2::theme(axis.title = ggplot2::element_text(size = 14,
#                                                          family = 'serif'),
#                       axis.text = ggplot2::element_text(face = 'bold',
#                                                         color = 'blue'))

</code></pre>

<hr>
<h2 id='plot.bootstrap_phenologyFit'>plot bootstrap_phenologyFit</h2><span id='topic+plot.bootstrap_phenologyFit'></span>

<h3>Description</h3>

<p>Generic function to plot a 'bootstrap_phenologyFit' object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bootstrap_phenologyFit'
plot(
  x,
  ylim = c(0.9 * min(c(x$object$bloomJDays, x$object$pbloomJDays)), 1.1 *
    max(c(x$object$bloomJDays, x$object$pbloomJDays))),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.bootstrap_phenologyFit_+3A_x">x</code></td>
<td>
<p>object of class 'bootstrap_phenologyFit' to plot.</p>
</td></tr>
<tr><td><code id="plot.bootstrap_phenologyFit_+3A_ylim">ylim</code></td>
<td>
<p>numeric vector of length 2 with the limit for the y-axis</p>
</td></tr>
<tr><td><code id="plot.bootstrap_phenologyFit_+3A_...">...</code></td>
<td>
<p>additional graphical parameters to pass on.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value.
</p>

<hr>
<h2 id='plot.phenologyFit'>plot phenologyFit</h2><span id='topic+plot.phenologyFit'></span>

<h3>Description</h3>

<p>Generic function to plot a 'phenologyFit' object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'phenologyFit'
plot(
  x,
  ylim = c(0.9 * min(c(x$bloomJDays, x$pbloomJDays)), 1.1 * max(c(x$bloomJDays,
    x$pbloomJDays))),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.phenologyFit_+3A_x">x</code></td>
<td>
<p>object of class 'phenologyFit' to plot.</p>
</td></tr>
<tr><td><code id="plot.phenologyFit_+3A_ylim">ylim</code></td>
<td>
<p>numeric vector of length 2 with the limit for the y-axis</p>
</td></tr>
<tr><td><code id="plot.phenologyFit_+3A_...">...</code></td>
<td>
<p>additional graphical parameters to pass on.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value.
</p>

<hr>
<h2 id='PLS_chill_force'>Partial Least Squares analysis of phenology vs. accumulated daily chill and
heat</h2><span id='topic+PLS_chill_force'></span>

<h3>Description</h3>

<p>This function conducts a Partial Least Squares (PLS) regression analysis
relating an annual biological phenomenon, e.g. fruit tree flowering or leaf
emergence, to mean daily rates of chill (with three models) and heat
accumulation of the preceding 12 months. It produces figures that illustrate
statistical correlations between temperature variation during certain phases
and the timing of phenological events.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PLS_chill_force(
  daily_chill_obj,
  bio_data_frame,
  split_month,
  expl.var = 30,
  ncomp.fix = NULL,
  return.all = FALSE,
  crossvalidate = "none",
  end_at_pheno_end = TRUE,
  chill_models = c("Chilling_Hours", "Utah_Chill_Units", "Chill_Portions"),
  heat_models = c("GDH"),
  runn_means = 1,
  metric_categories = c("Chill", "Heat")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PLS_chill_force_+3A_daily_chill_obj">daily_chill_obj</code></td>
<td>
<p>a daily chill object. This should be generated with
the daily_chill function.</p>
</td></tr>
<tr><td><code id="PLS_chill_force_+3A_bio_data_frame">bio_data_frame</code></td>
<td>
<p>a data frame that contains information on the timing
of phenological events by year. It should consist of two columns called Year
and pheno. Data in the pheno column should be in Julian date (day of the
year).</p>
</td></tr>
<tr><td><code id="PLS_chill_force_+3A_split_month">split_month</code></td>
<td>
<p>the procedure analyzes data by phenological year, which
can start and end in any month during the calendar year (currently only at
the beginning of a month). This variable indicates the last month (e.g. 5
for May) that should be included in the record for a given phenological
year. All subsequent months are assigned to the following phenological year.</p>
</td></tr>
<tr><td><code id="PLS_chill_force_+3A_expl.var">expl.var</code></td>
<td>
<p>percentage of the variation in the dependent variable that
the PLS model should explain. This is used as a threshold in finding the
appropriate number of components in the PLS regression procedure.</p>
</td></tr>
<tr><td><code id="PLS_chill_force_+3A_ncomp.fix">ncomp.fix</code></td>
<td>
<p>fixed number of components for the PLS model. Defaults to
NULL, so that the number is automatically determined, but it can also be set
by the user.</p>
</td></tr>
<tr><td><code id="PLS_chill_force_+3A_return.all">return.all</code></td>
<td>
<p>boolean variable indicating whether or not the full set of
PLS results should be returned by the function. If this is set to TRUE, the
function output is a list with two elements (besides the object_type
string): PLS_summary and PLS_output; if it is set to FALSE, only the
PLS_summary is returned.</p>
</td></tr>
<tr><td><code id="PLS_chill_force_+3A_crossvalidate">crossvalidate</code></td>
<td>
<p>character variable indicating what kind of validation
should be performed by the PLS procedure. This defaults to &quot;none&quot;, but the
plsr function (of the pls package) also takes &quot;CV&quot; and &quot;LOO&quot; as inputs. See
the documentation for the plsr function for details.</p>
</td></tr>
<tr><td><code id="PLS_chill_force_+3A_end_at_pheno_end">end_at_pheno_end</code></td>
<td>
<p>boolean variable indicating whether the analysis
should disregard temperatures after the last date included in the
bio_data_frame dataset. If set to TRUE, only temperatures up this date are
considered. Phenology data is extracted from the PLS output files. If this
parameter is assigned a numeric value, only data up to the Julian date
specified by this number are considered.</p>
</td></tr>
<tr><td><code id="PLS_chill_force_+3A_chill_models">chill_models</code></td>
<td>
<p>Character vector containing names of chill models that
should be considered in the PLS regression. These names should correspond to
column names of daily_chill. This defaults to c(&quot;Chilling_Hours&quot;,
&quot;Utah_Chill_Units&quot;, &quot;Chill_Portions&quot;).</p>
</td></tr>
<tr><td><code id="PLS_chill_force_+3A_heat_models">heat_models</code></td>
<td>
<p>Character vector containing names of heat models that
should be considered in the PLS regression. These names should correspond to
column names of daily_chill. This defaults to c(&quot;GDH&quot;).</p>
</td></tr>
<tr><td><code id="PLS_chill_force_+3A_runn_means">runn_means</code></td>
<td>
<p>numeric vector specifying whether inputs to the PLS calculation
should be processed by a running mean filter. This usually enhances the clarity of
results. This vector contains either one element (an integer), in which case the
same filter is applied to all input metrics, or one element for each model, which
allows specifying metric-specific running means. In this case the sequence of numbers
should correspond to the sequence specified in the function call, with chill models
listed first, followed by heat models.</p>
</td></tr>
<tr><td><code id="PLS_chill_force_+3A_metric_categories">metric_categories</code></td>
<td>
<p>while the original application of this function is the
calculation of tree responses to chill and heat accumulation, it can also be applied
for other variables. In this case, you may not want the outputs to be called 'Chill'
and 'Heat' (the default). Here you can specify a character vector of length 2, which
contains the labels you want to appear in the output table.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>PLS regression is useful for exploring the relationship between daily chill
and heat accumulation rates and biological phenomena that only occur once
per year. The statistical challenge is that a normally quite small number of
observations must be related to variation in a much larger number (730) of
daily chill and heat values, which are also highly autocorrelated. Most
regression approaches are not suitable for this, but PLS regression offers a
potential solution. The method is frequently used in chemometrics and
hyperspectral remote sensing, where similar statistical challenges are
encountered. The basic mechanism is that PLS first constructs latent factors
(similar to principal components) from the independent data (daily chill and
heat accumulation) and then uses these components for the regression. The
contribution of each individual variable to the PLS model is then evaluated
with two main metrics: the Variable Importance in the Projection statistic
(VIP) indicates how much variation in a given independent variable is
correlated with variation in the dependent variable. A threshold of 0.8 is
often used for determining importance. The standardized model coefficients
of the PLS model then give an indication of the direction and strength of
the effect, e.g. if coefficients are positive and high, high values for the
respective independent variable are correlated with high values of the
dependent variable (e.g. late occurrence of a phenological stage). This
procedure was inspired by the challenge of explaining variation in bloom and
leaf emergence dates of temperate fruit trees in Mediterranean climates.
These are generally understood to result from (more of less) sequential
fulfillment of a chilling and a forcing requirement. During the chilling
phase, cool temperatures are needed; during the forcing phase, trees need
heat. There is no easily visible change in tree buds that would indicate the
transition between these two phases, making it difficult to develop a good
model of these processes. Where long-term phenology data are available and
can be coupled with daily chill and heat records (derived from daily
temperature data), PLS regression allows detection of the chilling/forcing
transition. This procedure has not often been applied to biological
phenomena at the time of writing this, and there may be constraints to how
generally applicable it is. Yet is has passed the test of scientific peer
review a few times, and it has produced plausible results in a number of
settings. This package draws heavily from the pls package.
</p>
<p>Per default, chill metrics used are the ones given in the references below.
Chilling Hours are all hours with temperatures between 0 and 7.2 degrees C.
Units of the Utah Model are calculated as suggested by Richardson et al.
(1974) (different weights for different temperature ranges, and negation of
chilling by warm temperatures). Chill Portions are calculated according to
Fishman et al. (1987a,b). More honestly, they are calculated according to an
Excel sheet produced by Amnon Erez and colleagues, which converts the
complex equations in the Fishman papers into relatively simple Excel
functions. These were translated into R. References to papers that include
the full functions are given below. Growing Degree Hours are calculated
according to Anderson et al. (1986), using the default values they suggest.
</p>
<p>It is possible, however, for the user to specify other metrics to be
evaluated. These should be indicated by the chill_models and heat_models
parameters, which should contain the names of the respective columns of the
daily_chill_obj$daily_chill data frame.
</p>


<h3>Value</h3>

<table>
<tr><td><code>object_type</code></td>
<td>
<p> the character string &quot;PLS_chillforce_pheno&quot;.
This is only needed for choosing the correct method for the plot_PLS
function.</p>
</td></tr> <tr><td><code>pheno</code></td>
<td>
<p> a data frame containing the phenology data used for
the PLS regression, with columns Year and pheno.</p>
</td></tr>
<tr><td><code>&lt;chill_model&gt;$&lt;heat_model&gt;</code></td>
<td>
<p> for each combination of elements from
chill_models and heat_models, a list element is generated, which contains a
list with elements PLS_summary and (if(return.all=TRUE) PLS_output. These
contain the results of the PLS analysis that used the respective chill and
heat metrics as independent variables.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>After doing extensive model comparisons, and reviewing a lot of
relevant literature, I do not recommend using the Chilling Hours or Utah
Models, especially in warm climates! The Dynamic Model (Chill Portions),
though far from perfect, seems much more reliable.
</p>


<h3>Author(s)</h3>

<p>Eike Luedeling, with contributions from Sabine Guesewell
</p>


<h3>References</h3>

<p>Model references, for the default option:
</p>
<p>Chilling Hours:
</p>
<p>Weinberger JH (1950) Chilling requirements of peach varieties. Proc Am Soc
Hortic Sci 56, 122-128
</p>
<p>Bennett JP (1949) Temperature and bud rest period. Calif Agric 3 (11), 9+12
</p>
<p>Utah Model:
</p>
<p>Richardson EA, Seeley SD, Walker DR (1974) A model for estimating the
completion of rest for Redhaven and Elberta peach trees. HortScience 9(4),
331-332
</p>
<p>Dynamic Model:
</p>
<p>Erez A, Fishman S, Linsley-Noakes GC, Allan P (1990) The dynamic model for
rest completion in peach buds. Acta Hortic 276, 165-174
</p>
<p>Fishman S, Erez A, Couvillon GA (1987a) The temperature dependence of
dormancy breaking in plants - computer simulation of processes studied under
controlled temperatures. J Theor Biol 126(3), 309-321
</p>
<p>Fishman S, Erez A, Couvillon GA (1987b) The temperature dependence of
dormancy breaking in plants - mathematical analysis of a two-step model
involving a cooperative transition. J Theor Biol 124(4), 473-483
</p>
<p>Growing Degree Hours:
</p>
<p>Anderson JL, Richardson EA, Kesner CD (1986) Validation of chill unit and
flower bud phenology models for 'Montmorency' sour cherry. Acta Hortic 184,
71-78
</p>
<p>Model comparisons and model equations:
</p>
<p>Luedeling E, Zhang M, Luedeling V and Girvetz EH, 2009. Sensitivity of
winter chill models for fruit and nut trees to climatic changes expected in
California's Central Valley. Agriculture, Ecosystems and Environment 133,
23-31
</p>
<p>Luedeling E, Zhang M, McGranahan G and Leslie C, 2009. Validation of winter
chill models using historic records of walnut phenology. Agricultural and
Forest Meteorology 149, 1854-1864
</p>
<p>Luedeling E and Brown PH, 2011. A global analysis of the comparability of
winter chill models for fruit and nut trees. International Journal of
Biometeorology 55, 411-421
</p>
<p>Luedeling E, Kunz A and Blanke M, 2011. Mehr Chilling fuer Obstbaeume in
waermeren Wintern? (More winter chill for fruit trees in warmer winters?).
Erwerbs-Obstbau 53, 145-155
</p>
<p>Review on chilling models in a climate change context:
</p>
<p>Luedeling E, 2012. Climate change impacts on winter chill for temperate
fruit and nut production: a review. Scientia Horticulturae 144, 218-229
</p>
<p>The PLS method is described here:
</p>
<p>Luedeling E and Gassner A, 2012. Partial Least Squares Regression for
analyzing walnut phenology in California. Agricultural and Forest
Meteorology 158, 43-52.
</p>
<p>Wold S (1995) PLS for multivariate linear modeling. In: van der Waterbeemd H
(ed) Chemometric methods in molecular design: methods and principles in
medicinal chemistry, vol 2. Chemie, Weinheim, pp 195-218.
</p>
<p>Wold S, Sjostrom M, Eriksson L (2001) PLS-regression: a basic tool of
chemometrics. Chemometr Intell Lab 58(2), 109-130.
</p>
<p>Mevik B-H, Wehrens R, Liland KH (2011) PLS: Partial Least Squares and
Principal Component Regression. R package version 2.3-0.
http://CRAN.R-project.org/package0pls.
</p>
<p>Some applications of the PLS procedure:
</p>
<p>Luedeling E, Kunz A and Blanke M, 2013. Identification of chilling and heat
requirements of cherry trees - a statistical approach. International Journal
of Biometeorology 57,679-689.
</p>
<p>Yu H, Luedeling E and Xu J, 2010. Stronger winter than spring warming delays
spring phenology on the Tibetan Plateau. Proceedings of the National Academy
of Sciences (PNAS) 107 (51), 22151-22156.
</p>
<p>Yu H, Xu J, Okuto E and Luedeling E, 2012. Seasonal Response of Grasslands
to Climate Change on the Tibetan Plateau. PLoS ONE 7(11), e49230.
</p>
<p>The exact procedure was used here:
</p>
<p>Luedeling E, Guo L, Dai J, Leslie C, Blanke M, 2013. Differential responses
of trees to temperature variation during the chilling and forcing phases.
Agricultural and Forest Meteorology 181, 33-42.
</p>
<p>The chillR package:
</p>
<p>Luedeling E, Kunz A and Blanke M, 2013. Identification of chilling and heat
requirements of cherry trees - a statistical approach. International Journal
of Biometeorology 57,679-689.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
weather&lt;-fix_weather(KA_weather[which(KA_weather$Year&gt;2004),])
#Plots look much better with weather&lt;-fix_weather(KA_weather)
#but that takes too long to run for passing CRAN checks

dc&lt;-daily_chill(stack_hourly_temps(weather,50.4), 11)
plscf&lt;-PLS_chill_force(daily_chill_obj=dc, bio_data_frame=KA_bloom, split_month=6)

#PLS_results_path&lt;-paste(getwd(),"/PLS_output",sep="")
#plot_PLS(plscf,PLS_results_path)
#plot_PLS(plscf,PLS_results_path,add_chill=c(307,19),add_heat=c(54,109))




</code></pre>

<hr>
<h2 id='PLS_pheno'>Partial Least Squares analysis of phenology vs. daily mean temperatures</h2><span id='topic+PLS_pheno'></span>

<h3>Description</h3>

<p>This function conducts a Partial Least Squares (PLS) regression analysis
relating an annual biological phenomenon, e.g. fruit tree flowering or leaf
emergence, to mean daily temperatures of the preceding 12 months. It
produces figures that illustrate statistical correlations between
temperature variation during certain phases and the timing of phenological
event.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PLS_pheno(
  weather_data,
  bio_data,
  split_month = 7,
  runn_mean = 11,
  expl.var = 30,
  ncomp.fix = NULL,
  use_Tmean = FALSE,
  return.all = FALSE,
  crossvalidate = "none",
  end_at_pheno_end = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PLS_pheno_+3A_weather_data">weather_data</code></td>
<td>
<p>a dataframe containing daily minimum and maximum
temperature data (in columns called Tmin and Tmax, respectively), and/or
mean daily temperature (in a column called Tmean). There also has to be a
column for Year and one for JDay (the Julian date, or day of the year).
Alternatively, the date can also be given in three columns (Years, Month and
Day).</p>
</td></tr>
<tr><td><code id="PLS_pheno_+3A_bio_data">bio_data</code></td>
<td>
<p>a data frame that contains information on the timing of
phenological events by year. It should consist of two columns called Year
and pheno. Data in the pheno column should be in Julian date (day of the
year).</p>
</td></tr>
<tr><td><code id="PLS_pheno_+3A_split_month">split_month</code></td>
<td>
<p>the procedure analyzes data by phenological year, which
can start and end in any month during the calendar year (currently only at
the beginning of a month). This variable indicates the last month (e.g. 5
for May) that should be included in the record for a given phenological
year. All subsequent months are assigned to the following phenological year.</p>
</td></tr>
<tr><td><code id="PLS_pheno_+3A_runn_mean">runn_mean</code></td>
<td>
<p>application of a running mean function to daily mean
temperatures before running the PLS procedure substantially enhances the
clarity of outputs. runn_mean requires an odd integer value specifying how
many days should be included in this running mean. runn_mean=11 has usually
produced good results.</p>
</td></tr>
<tr><td><code id="PLS_pheno_+3A_expl.var">expl.var</code></td>
<td>
<p>percentage of the variation in the dependent variable that
the PLS model should explain. This is used as a threshold in finding the
appropriate number of components in the PLS regression procedure.</p>
</td></tr>
<tr><td><code id="PLS_pheno_+3A_ncomp.fix">ncomp.fix</code></td>
<td>
<p>fixed number of components for the PLS model. Defaults to
NULL, so that the number is automatically determined, but is can also be set
by the user.</p>
</td></tr>
<tr><td><code id="PLS_pheno_+3A_use_tmean">use_Tmean</code></td>
<td>
<p>boolean variable indicating whether or not the column Tmean
from the weather_data_frame should be used as input for the PLS analysis. If
this is set to FALSE, Tmean is calculated as the arithmetic mean of Tmin and
Tmax.</p>
</td></tr>
<tr><td><code id="PLS_pheno_+3A_return.all">return.all</code></td>
<td>
<p>boolean variable indicating whether or not the full set of
PLS results should be output from the function. If this is set to TRUE, the
function output is a list with two elements: PLS_summary and PLS_output; if
it is set to FALSE, only the PLS_summary is returned.</p>
</td></tr>
<tr><td><code id="PLS_pheno_+3A_crossvalidate">crossvalidate</code></td>
<td>
<p>character variable indicating what kind of validation
should be performed by the PLS procedure. This defaults to &quot;none&quot;, but the
plsr function (of the pls package) also takes &quot;CV&quot; and &quot;LOO&quot; as inputs. See
the documentation for the plsr function for details.</p>
</td></tr>
<tr><td><code id="PLS_pheno_+3A_end_at_pheno_end">end_at_pheno_end</code></td>
<td>
<p>boolean variable indicating whether the analysis
should disregard temperatures after the last date included in the
bio_data_frame dataset. If set to TRUE, only temperatures up this date are
considered. Phenology data is extracted from the PLS output files. If this
parameter is assigned a numeric value, only data up to the Julian date
specified by this number are considered.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>PLS regression is useful for exploring the relationship between daily
temperature data and biological phenomena that only occur once per year. The
statistical challenge is that a normally quite small number of observations
must be related to variation in a much larger number (365) of daily
temperatures, which are also highly autocorrelated. Most regression
approaches are not suitable for this, but PLS regression offers a potential
solution. The method is frequently used in chemometrics and hyperspectral
remote sensing, where similar statistical challenges are encountered. The
basic mechanism is that PLS first constructs latent factors (similar to
principal components) from the independent data (temperatures) and then uses
these components for the regression. The contribution of each individual
variable to the PLS model is then evaluated with two main metrics: the
Variable Importance in the Projection statistic (VIP) indicates how much
variation in a given independent variable is correlated with variation in
the dependent variable. A threshold of 0.8 is often used for determining
importance. The standardized model coefficients of the PLS model then give
an indication of the direction and strength of the effect, e.g. if
coefficients are positive and high, high values for the respective
independent variable are correlated with high values of the dependent
variable (e.g. late occurrence of a phenological stage). This procedure was
inspired by the challenge of explaining variation in bloom and leaf
emergence dates of temperate fruit trees in Mediterranean climates. These
are generally understood to result from (more of less) sequential
fulfillment of a chilling and a forcing requirement. During the chilling
phase, cool temperatures are needed; during the forcing phase, trees need
heat. There is no easily visible change in tree buds that would indicate the
transition between these two phases, making it difficult to develop a good
model of these processes. Where long-term phenology data are available and
can be couple with daily temperature records, PLS regression allows
detection of the chilling/forcing transition. This procedure has not often
been applied to biological phenomena at the time of writing this, and there
may be constraints to how generally applicable it is. Yet is has passed the
test of scientific peer review a few times, and it has produced plausible
results in a number of settings. This package draws heavily from the pls
package. It also incorporates very helpful comments from Sabine Guesewell of
ETH Zurich (Switzerland), who pointed out some errors in the PLS procedure
and made suggestions for improvement.
</p>


<h3>Value</h3>

<table>
<tr><td><code>object_type</code></td>
<td>
<p> the character string &quot;PLS_Temp_pheno&quot;. This is
only needed for choosing the correct method for the plot_PLS function.</p>
</td></tr>
<tr><td><code>pheno</code></td>
<td>
<p> a data frame containing the phenology data used for the PLS
regression, with columns Year and pheno.</p>
</td></tr> <tr><td><code>PLS_summary</code></td>
<td>
<p> a data frame
containing all important outputs of the PLS regression. Columns are Date (in
MMDD format), JDay (Julian date, or day of the year), Coefficient (the PLS
model coefficient for each daily temperature variable), and VIP (the
Variable Importance in the Projection score). The columns Tmean and Tstdev
contain the means and standard deviations of temperature for each day of the
year.</p>
</td></tr> <tr><td><code>PLS_output</code></td>
<td>
<p> this is the complete output of the plsr function
of the pls package. See the documentation for that package for further
details.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Eike Luedeling, with contributions from Sabine Guesewell
</p>


<h3>References</h3>

<p>The method is described here:
</p>
<p>Luedeling E and Gassner A, 2012. Partial Least Squares Regression for
analyzing walnut phenology in California. Agricultural and Forest
Meteorology 158, 43-52.
</p>
<p>Wold S (1995) PLS for multivariate linear modeling. In: van der Waterbeemd H
(ed) Chemometric methods in molecular design: methods and principles in
medicinal chemistry, vol 2. Chemie, Weinheim, pp 195-218.
</p>
<p>Wold S, Sjostrom M, Eriksson L (2001) PLS-regression: a basic tool of
chemometrics. Chemometr Intell Lab 58(2), 109-130.
</p>
<p>Mevik B-H, Wehrens R, Liland KH (2011) PLS: Partial Least Squares and
Principal Component Regression. R package version 2.3-0.
http://CRAN.R-project.org/package0pls.
</p>
<p>Some applications:
</p>
<p>Luedeling E, Kunz A and Blanke M, 2013. Identification of chilling and heat
requirements of cherry trees - a statistical approach. International Journal
of Biometeorology 57,679-689.
</p>
<p>Yu H, Luedeling E and Xu J, 2010. Stronger winter than spring warming delays
spring phenology on the Tibetan Plateau. Proceedings of the National Academy
of Sciences (PNAS) 107 (51), 22151-22156.
</p>
<p>Yu H, Xu J, Okuto E and Luedeling E, 2012. Seasonal Response of Grasslands
to Climate Change on the Tibetan Plateau. PLoS ONE 7(11), e49230.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
PLS_results&lt;-PLS_pheno(
  weather_data=KA_weather,
  split_month=6,   #last month in same year
  bio_data=KA_bloom)
  
PLS_results_path&lt;-paste(getwd(),"/PLS_output",sep="")
  
# plot_PLS(PLS_results,PLS_results_path)

</code></pre>

<hr>
<h2 id='predict.bootstrap_phenologyFit'>predict bootstrap_phenologyFit</h2><span id='topic+predict.bootstrap_phenologyFit'></span>

<h3>Description</h3>

<p>Generic function to predict a 'bootstrap_phenologyFit' object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bootstrap_phenologyFit'
predict(object, SeasonList, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.bootstrap_phenologyFit_+3A_object">object</code></td>
<td>
<p>object of class 'phenologyFit' to predict.</p>
</td></tr>
<tr><td><code id="predict.bootstrap_phenologyFit_+3A_seasonlist">SeasonList</code></td>
<td>
<p>List with data frames per season, see
<a href="#topic+phenologyFit">phenologyFit</a> for more details.</p>
</td></tr>
<tr><td><code id="predict.bootstrap_phenologyFit_+3A_...">...</code></td>
<td>
<p>additional parameters, ignored here</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame with one column 'pbloomJDays' and a second one 'Err'.
</p>

<hr>
<h2 id='predict.phenologyFit'>predict phenologyFit</h2><span id='topic+predict.phenologyFit'></span>

<h3>Description</h3>

<p>Generic function to predict a 'phenologyFit' object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'phenologyFit'
predict(object, SeasonList, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.phenologyFit_+3A_object">object</code></td>
<td>
<p>object of class 'phenologyFit' to predict.</p>
</td></tr>
<tr><td><code id="predict.phenologyFit_+3A_seasonlist">SeasonList</code></td>
<td>
<p>List with data frames per season, see
<a href="#topic+phenologyFit">phenologyFit</a> for more details.</p>
</td></tr>
<tr><td><code id="predict.phenologyFit_+3A_...">...</code></td>
<td>
<p>additional parameters, ignored here</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector is returned with a predicted bloom day per
Season in 'SeasonList'. If 'SeasonList' is missing, the
original 'SeasonList' is used for prediction.
</p>

<hr>
<h2 id='print.phenologyFit'>print phenologyFit</h2><span id='topic+print.phenologyFit'></span>

<h3>Description</h3>

<p>print phenologyFit
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'phenologyFit'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.phenologyFit_+3A_x">x</code></td>
<td>
<p>class phenologyFit. object to print</p>
</td></tr>
<tr><td><code id="print.phenologyFit_+3A_...">...</code></td>
<td>
<p>additional parameters, ignored here</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value.
</p>

<hr>
<h2 id='read_tab'>Read csv table regardless of whether it is a true csv or the French type</h2><span id='topic+read_tab'></span>

<h3>Description</h3>

<p>csv tables are widely used for storing data as 'comma-separated values'.
This doesn't work, however, when the comma is also used as a decimal symbol,
as is practiced in French or German, for example. The separator symbol for csv
files then becomes a semi-colon. This is not problematic when you only work on one
machine, but it causes problems when you collaborate with people who use different
types of csv encoding.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_tab(tab)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read_tab_+3A_tab">tab</code></td>
<td>
<p>file name of a table to be read.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function overcomes this problem by checking first, which of the two
characters occurs most frequently in the table, assuming then that this is
the separator symbol. It then opens the table accordingly.
</p>
<p>Currently limited to files that are either comma-separated with point as decimal
symbol or semicolon-separated with comma as decimal symbol. Files should also
have a header.
</p>


<h3>Value</h3>

<p>If the table is in one of the two formats described above, the stored table
is returned.
</p>


<h3>Author(s)</h3>

<p>Eike Luedeling
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
df&lt;-data.frame(Var1=c(1,2,3.2,1.2),Var2=c(1.2,6,2.6,7))
write.csv(df,"filecsv.csv",row.names=FALSE)
read_tab("filecsv.csv")
write.table(df,"filesemicolon.csv",sep=";",dec=",")
read_tab("filesemicolon.csv")
file.remove("filecsv.csv")
file.remove("filesemicolon.csv")

 
</code></pre>

<hr>
<h2 id='RMSEP'>Root Mean Square Error of Prediction (RMSEP)</h2><span id='topic+RMSEP'></span>

<h3>Description</h3>

<p>This function computes the Root Mean Square Error of Prediction (RMSEP),
a commonly used measure for the predictive capacity of a model. It
compares values predicted with a model with observed values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RMSEP(predicted, observed, na.rm = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RMSEP_+3A_predicted">predicted</code></td>
<td>
<p>a numeric vector containing predicted values.</p>
</td></tr>
<tr><td><code id="RMSEP_+3A_observed">observed</code></td>
<td>
<p>a numeric vector of the same length as &ldquo;'predicted&ldquo;'
containing observed values.</p>
</td></tr>
<tr><td><code id="RMSEP_+3A_na.rm">na.rm</code></td>
<td>
<p>Boolean parameter indicating whether NA values should be removed before the analysis</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric value of the RMSEP.
</p>


<h3>Author(s)</h3>

<p>Eike Luedeling
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
predicted&lt;-c(1,2,3,4,5,6,7,8,9,10)
observed&lt;-c(1.5,1.8,3.3,3.9,4.4,6,7.5,9,11,10)

RMSEP(predicted,observed)

</code></pre>

<hr>
<h2 id='RPD'>Residual Prediction Deviation (RPD)</h2><span id='topic+RPD'></span>

<h3>Description</h3>

<p>This function computes the Residual Prediction Deviation (RPD), which
is defined as the standard deviation of observed values divided by
the Root Mean Square Error or Prediction (RMSEP). The RDP takes both
the prediction error and the variation of observed values into 
account, providing a metric of model validity that is more objective
than the RMSEP and more easily comparable across model validation
studies. The greater the RPD, the better the model's predictive
capacity.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RPD(predicted, observed, na.rm = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RPD_+3A_predicted">predicted</code></td>
<td>
<p>a numeric vector containing predicted values.</p>
</td></tr>
<tr><td><code id="RPD_+3A_observed">observed</code></td>
<td>
<p>a numeric vector of the same length as &ldquo;'predicted&ldquo;'
containing observed values.</p>
</td></tr>
<tr><td><code id="RPD_+3A_na.rm">na.rm</code></td>
<td>
<p>Boolean parameter indicating whether NA values should be removed before the analysis</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Interpretation of the RPD is somewhat arbitrary, with different
thresholds for a good model used in the literature. Many studies
call a model *excellent*, when the RPD is above 2 (but other
classification use thresholds as high as 8 for this).
</p>


<h3>Value</h3>

<p>numeric value of the RDP.
</p>


<h3>Author(s)</h3>

<p>Eike Luedeling
</p>


<h3>References</h3>

<p>Williams PC and Sobering DC (1993) Comparison of
commercial near infrared transmittance and reflectance instruments
for analysis of whole grains and seeds. J. Near Infrared Spectrosc.
1, 25-32 (I didn't have access to this paper, but have noticed that
it is often provided as the key reference for the RPD).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
predicted&lt;-c(1,2,3,4,5,6,7,8,9,10)
observed&lt;-c(1.5,1.8,3.3,3.9,4.4,6,7.5,9,11,10)

RPD(predicted,observed)

</code></pre>

<hr>
<h2 id='RPIQ'>Ratio of Performance to InterQuartile distance (RPIQ)</h2><span id='topic+RPIQ'></span>

<h3>Description</h3>

<p>This function computes the Ratio of Performance to InterQuartile
distance (RPIQ), which
is defined as interquartile range of the observed values divided by
the Root Mean Square Error or Prediction (RMSEP). The RPIQ takes both
the prediction error and the variation of observed values into 
account, providing a metric of model validity that is more objective
than the RMSEP and more easily comparable across model validation
studies. The greater the RPIQ, the better the model's predictive
capacity. In contrast to the Residual Prediction Deviation (RPD),
the RPIQ makes no assumptions about the distribution of the
observed values (since the RDP includes a standard deviation, it
assumed normal distribution of the observed values).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RPIQ(predicted, observed, na.rm = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RPIQ_+3A_predicted">predicted</code></td>
<td>
<p>a numeric vector containing predicted values.</p>
</td></tr>
<tr><td><code id="RPIQ_+3A_observed">observed</code></td>
<td>
<p>a numeric vector of the same length as &ldquo;'predicted&ldquo;'
containing observed values.</p>
</td></tr>
<tr><td><code id="RPIQ_+3A_na.rm">na.rm</code></td>
<td>
<p>Boolean parameter indicating whether NA values should be removed before the analysis</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Interpretation of the RPIQ differs in the literature, with different
thresholds used for judging model quality.
</p>


<h3>Value</h3>

<p>numeric value of the RPIQ
</p>


<h3>Author(s)</h3>

<p>Eike Luedeling
</p>


<h3>References</h3>

<p>Bellon-Maurel V, Fernandez-Ahumada E, Palagos B,
Roger J-M, McBratney A, 2010. Critical review of chemometric
indicators commonly used for assessing the quality of the prediction
of soil attributes by NIR spectroscopy, In TrAC Trends in Analytical
Chemistry 29(9), 1073-1081.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
predicted&lt;-c(1,2,3,4,5,6,7,8,9,10)
observed&lt;-c(1.5,1.8,3.3,3.9,4.4,6,7.5,9,11,10)

RPD(predicted,observed)

</code></pre>

<hr>
<h2 id='runn_mean'>Running mean of a vector</h2><span id='topic+runn_mean'></span>

<h3>Description</h3>

<p>Function to calculate the running mean of a numeric vector
</p>


<h3>Usage</h3>

<pre><code class='language-R'>runn_mean(
  vec,
  runn_mean,
  na.rm = FALSE,
  exclude_central_value = FALSE,
  FUN = mean
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="runn_mean_+3A_vec">vec</code></td>
<td>
<p>numeric vector</p>
</td></tr>
<tr><td><code id="runn_mean_+3A_runn_mean">runn_mean</code></td>
<td>
<p>number of vector elements to use for calculating the
running mean</p>
</td></tr>
<tr><td><code id="runn_mean_+3A_na.rm">na.rm</code></td>
<td>
<p>ignore NA values when calculating means. Defaults to FALSE.</p>
</td></tr>
<tr><td><code id="runn_mean_+3A_exclude_central_value">exclude_central_value</code></td>
<td>
<p>exclude central value in calculating means.
Defaults to FALSE.</p>
</td></tr>
<tr><td><code id="runn_mean_+3A_fun">FUN</code></td>
<td>
<p>function to be applied. For a running mean, this is usually mean (the
default), but other functions can also be specified here (the na.rm parameter
won't work then, and the function has to be dependent on one numeric variable only.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric vector containing the running mean
</p>


<h3>Author(s)</h3>

<p>Eike Luedeling
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

plot(runn_mean(rnorm(1000),150))

</code></pre>

<hr>
<h2 id='runn_mean_pred'>Prediction based on a running mean</h2><span id='topic+runn_mean_pred'></span>

<h3>Description</h3>

<p>Function to predict values based on a running mean (or another function) of a numeric vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>runn_mean_pred(
  indep,
  dep,
  pred,
  runn_mean = 11,
  na.rm = FALSE,
  exclude_central_value = FALSE,
  FUN = mean
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="runn_mean_pred_+3A_indep">indep</code></td>
<td>
<p>numeric vector of independent variables, should be sequential</p>
</td></tr>
<tr><td><code id="runn_mean_pred_+3A_dep">dep</code></td>
<td>
<p>numeric vector of dependent variables</p>
</td></tr>
<tr><td><code id="runn_mean_pred_+3A_pred">pred</code></td>
<td>
<p>numeric vector of values to be predicted</p>
</td></tr>
<tr><td><code id="runn_mean_pred_+3A_runn_mean">runn_mean</code></td>
<td>
<p>number of vector elements to use for calculating the
running mean</p>
</td></tr>
<tr><td><code id="runn_mean_pred_+3A_na.rm">na.rm</code></td>
<td>
<p>ignore NA values when calculating means. Defaults to FALSE.</p>
</td></tr>
<tr><td><code id="runn_mean_pred_+3A_exclude_central_value">exclude_central_value</code></td>
<td>
<p>exclude central value in calculating means.
Defaults to FALSE.</p>
</td></tr>
<tr><td><code id="runn_mean_pred_+3A_fun">FUN</code></td>
<td>
<p>function to be applied. For a running mean, this is usually mean (the
default), but other functions can also be specified here (the na.rm parameter
won't work then, and the function has to be dependent on one numeric variable only.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The running mean calculation that underlies the prediction is based purely on the sequence of
observed values, without accounting for any variation in intervals of the independent data. This
means that the function performs best with regularly spaced independent variables. Note that the
function will return NA when asked to predict values that are outside the range of independent values
provided as input. The prediction results are computed by linearly interpolating between the running
mean values determined for the nearest neighbors of the value that is to be predicted.
</p>


<h3>Value</h3>

<p>list of two elements, with $x containing the values to be predicted and $predicted
the predicted values
</p>


<h3>Author(s)</h3>

<p>Eike Luedeling
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
indep&lt;-(1:100)
dep&lt;-sin(indep/20)+rnorm(100)/5
pred&lt;-c(12,13,51,70,90)

predicted&lt;-runn_mean_pred(indep,dep,pred,runn_mean = 25)

plot(dep~indep)
points(predicted$predicted~predicted$x,col="red",pch=15)

</code></pre>

<hr>
<h2 id='save_temperature_scenarios'>Save temperature scenarios generated with temperature_generation</h2><span id='topic+save_temperature_scenarios'></span>

<h3>Description</h3>

<p>The temperature_generation can produce synthetic temperature scenarios, but it can take a while
to run, especially for large ensembles of climate scenarios. The save_temperature_scenarios
function can then save these scenarios to disk as a series of .csv files, so that they can
later be used again, without re-running the generation function.
Conversely, the load_temperature_scenarios function allows reading the data back into R.
This function also works with any other list of data.frames.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>save_temperature_scenarios(generated_temperatures, path, prefix)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="save_temperature_scenarios_+3A_generated_temperatures">generated_temperatures</code></td>
<td>
<p>list of temperature scenarios produced with the
temperature_generation function.</p>
</td></tr>
<tr><td><code id="save_temperature_scenarios_+3A_path">path</code></td>
<td>
<p>character string indicating the file path where the files are to be written.</p>
</td></tr>
<tr><td><code id="save_temperature_scenarios_+3A_prefix">prefix</code></td>
<td>
<p>character string specifying the prefix for all files.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>no values are returned, but files are written as a side_effect.
</p>


<h3>Author(s)</h3>

<p>Eike Luedeling
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
temps&lt;-list(Element1=data.frame(a=1,b=2),Element2=data.frame(a=c(2,3),b=c(8,4)))
# save_temperature_scenarios(temps,path=getwd(),prefix="temperatures")
# temps_reloaded&lt;-load_temperature_scenarios(path=getwd(),prefix="temperatures")

 
</code></pre>

<hr>
<h2 id='select_by_file_extension'>Select string that end in a particular way (e.g. a certain file extension)</h2><span id='topic+select_by_file_extension'></span>

<h3>Description</h3>

<p>Sometimes it makes sense to apply a function to several files in a folder, but only to
those of a particular file type. This function can selects all elements in a vector of strings
that end in a particular way, e.g. on a common file extension.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>select_by_file_extension(strings, file_extension)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="select_by_file_extension_+3A_strings">strings</code></td>
<td>
<p>vector of character strings for elements to be extracted from.</p>
</td></tr>
<tr><td><code id="select_by_file_extension_+3A_file_extension">file_extension</code></td>
<td>
<p>character string specifying the extension of the file type to be selected.
This can also be any other trailing string that marks all vector elements to be selected.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>subset of the strings vector that only contains the elements that end on file_extension.
</p>


<h3>Author(s)</h3>

<p>Eike Luedeling
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  select_by_file_extension(c("Temp1.csv","Temp1.xls","Temp2.csv","Temp2.xls"),"csv")
  select_by_file_extension(c("red car","blue car","yellow duck"), "car")
 
</code></pre>

<hr>
<h2 id='stack_hourly_temps'>Stacking of hourly temperatures</h2><span id='topic+stack_hourly_temps'></span>

<h3>Description</h3>

<p>This function processes hourly temperatures generated by make_hourly_temps
for calculation of chilling and forcing. The chilling function requires
temperatures to be in a long list, and this function prepares them in this
way.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stack_hourly_temps(
  weather = NULL,
  latitude = 50,
  hour_file = NULL,
  keep_sunrise_sunset = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stack_hourly_temps_+3A_weather">weather</code></td>
<td>
<p>weather data frame containing either daily minimum (&quot;Tmin&quot;)
and maximum (&quot;Tmax&quot;) temperatures in the format generated by fix_weather, of
hourly temperatures in the format generated by make_hourly_temps (see below;
this can also be passed as hour_file).</p>
</td></tr>
<tr><td><code id="stack_hourly_temps_+3A_latitude">latitude</code></td>
<td>
<p>the geographic latitude (in decimal degrees) of the location
of interest</p>
</td></tr>
<tr><td><code id="stack_hourly_temps_+3A_hour_file">hour_file</code></td>
<td>
<p>this is a data frame of hourly temperatures, as generated
by make_hourly_temps. It has columns describing the date (Year+JDay or
Year+Month+Day) and 24 columns called Hour_1 ... Hour_24 that contain hourly
temperatures. This is no longer required, since weather can be specified by
the weather argument. This parameter is only for compatibility with earlier
versions of chillR.</p>
</td></tr>
<tr><td><code id="stack_hourly_temps_+3A_keep_sunrise_sunset">keep_sunrise_sunset</code></td>
<td>
<p>boolean variable indicating whether information
on sunrise, sunset and daylength, which is calculated for producing hourly
temperature records, should be preserved in the output. Defaults to FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list containing two elements: hourtemps: data frame containing all
the columns of the input data frame, except the hourly temperatures.
Instead, two columns are added: Hour is the hour of the day, and Temp is the
corresponding modeled mean temperature for that hour. QC: either the Quality
control attribute (&quot;QC&quot;) passed into the function within the daily
temperature record produced by fix_weather, or NA.
</p>


<h3>Author(s)</h3>

<p>Eike Luedeling
</p>


<h3>References</h3>

<p>Luedeling E, Kunz A and Blanke M, 2013. Identification of
chilling and heat requirements of cherry trees - a statistical approach.
International Journal of Biometeorology 57,679-689.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

weather&lt;-fix_weather(KA_weather[which(KA_weather$Year&gt;2004),])

hourtemps&lt;-stack_hourly_temps(weather, latitude=50.4)



</code></pre>

<hr>
<h2 id='stage_transitions'>Compute what it takes to advance through development stages</h2><span id='topic+stage_transitions'></span>

<h3>Description</h3>

<p>Function to compute the thermal requirements of transitioning
through a series of developmental stages.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stage_transitions(
  observations,
  hourtemps,
  stages,
  models = list(Chill_Portions = Dynamic_Model, GDH = GDH),
  max_steps = length(stages)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stage_transitions_+3A_observations">observations</code></td>
<td>
<p>data.frame containing observed developmental dates,
e.g. different stages of flower or leaf development. Should contain the
columns 'Stage' (containing the names of the development stages), 'Season'
(containing the 'development year' the observation belongs to, e.g. budbreak
for trees may be considered a stage of the 'dormancy year' that started
in the previous calendar year), 'Year' (the calendar year the observation
was made), 'JDay' (the Julian Date, a.k.a. day of the year, that the stage
was observed).</p>
</td></tr>
<tr><td><code id="stage_transitions_+3A_hourtemps">hourtemps</code></td>
<td>
<p>a list of two elements, with element 'hourtemps' being a
dataframe of hourly temperatures (e.g. produced by stack_hourly_temps). This
data frame must have a column for Year, a column for JDay (Julian date, or
day of the year), a column for Hour and a column for Temp (hourly
temperature). The second (optional) element is QC, which is a data.frame
indicating completeness of the dataset. This is automatically produced by
stack_hourly_temps. This also works if only the 'hourtemps' dataframe is
passed to the function.</p>
</td></tr>
<tr><td><code id="stage_transitions_+3A_stages">stages</code></td>
<td>
<p>character vector containing the relevant development stages
in their order of occurrence.</p>
</td></tr>
<tr><td><code id="stage_transitions_+3A_models">models</code></td>
<td>
<p>named list of models that should be applied to the hourly
temperature data. These should be functions that take as input a vector of
hourly temperatures. This defaults to list(Chill_Portions=Dynamic_Model,
GDH=GDH), models that are often used for describing chill and heat
accumulation in temperate fruit trees.</p>
</td></tr>
<tr><td><code id="stage_transitions_+3A_max_steps">max_steps</code></td>
<td>
<p>integer indicating the maximum number of stage steps
(i.e. transitions from one step to the next), for which thermal requirements
should be calculated. This defaults to length(stages), which is also the
maximum value. If only requirements between each stage and the following
stage are of interest, this should be set to 1.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data frame with rows for all transitions that occurred during the
observed records and the values of the metrics specified in 'models' that
accrued between the respective dates. Columns are c('Season','Stage',
'to_Stage','stage_steps') and one column for each thermal metrics.
</p>


<h3>Author(s)</h3>

<p>Eike Luedeling
</p>


<h3>Examples</h3>

<pre><code class='language-R'>hourtemps&lt;-stack_hourly_temps(KA_weather)
observations&lt;-data.frame(Stage=c("V1","V2","V3","V1","V2","V3","V1","V3"),
                        Season=c(2001,2001,2001,2002,2002,2002,2003,2003),
                        Year=c(2001,2001,2001,2002,2002,2002,2003,2003),
                        JDay=c(30,45,60,35,42,55,37,62))
stages&lt;-c("V1","V2","V3") 

stage_transitions(observations,hourtemps,stages)

</code></pre>

<hr>
<h2 id='step_model'>Calculation of cumulative temperature metric according to a user-defined
stepwise weight function</h2><span id='topic+step_model'></span>

<h3>Description</h3>

<p>This function calculates heat for temperate trees according to a stepwise
model provided by the user.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>step_model(
  HourTemp,
  df = data.frame(lower = c(-1000, 1.4, 2.4, 9.1, 12.4, 15.9, 18), upper = c(1.4, 2.4,
    9.1, 12.4, 15.9, 18, 1000), weight = c(0, 0.5, 1, 0.5, 0, -0.5, -1)),
  summ = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="step_model_+3A_hourtemp">HourTemp</code></td>
<td>
<p>Vector of hourly temperatures.</p>
</td></tr>
<tr><td><code id="step_model_+3A_df">df</code></td>
<td>
<p>data.frame with three columns: lower, upper and weight. lower
should contain the lower boundary of a chilling weight interval and upper
should contain the upper boundary. weight indicates the weighting to be
applied to the respective temperature interval.</p>
</td></tr>
<tr><td><code id="step_model_+3A_summ">summ</code></td>
<td>
<p>Boolean parameter indicating whether calculated metrics should
be provided as cumulative values over the entire record (TRUE) or as the
actual accumulation for each hour (FALSE).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Temperature-based metric calculated according to the user-defined model.
</p>


<h3>Value</h3>

<p>Vector of length length(HourTemp) containing the cumulative
temperature metric over the entire duration of HourTemp.
</p>


<h3>Author(s)</h3>

<p>Eike Luedeling
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

weather&lt;-fix_weather(KA_weather[which(KA_weather$Year&gt;2006),])

stack&lt;-stack_hourly_temps(weather,latitude=50.4)

df=data.frame(
  lower=c(-1000,1,2,3,4,5,6),
  upper=c(1,2,3,4,5,6,1000),
  weight=c(0,1,2,3,2,1,0))

custom&lt;-function(x) step_model(x,df)

custom(stack$Temp)

models&lt;-list(Chilling_Hours=Chilling_Hours,Utah_Chill_Units=Utah_Model,
Chill_Portions=Dynamic_Model,GDH=GDH,custom=custom)

tempResponse(stack,Start_JDay = 305,End_JDay = 60,models)

</code></pre>

<hr>
<h2 id='StepChill_Wrapper'>StepChill_Wrapper</h2><span id='topic+StepChill_Wrapper'></span>

<h3>Description</h3>

<p>Same as UniChill_Wrapper, but with a step function for chilling
</p>


<h3>Usage</h3>

<pre><code class='language-R'>StepChill_Wrapper(x, par)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="StepChill_Wrapper_+3A_x">x</code></td>
<td>
<p>data.frame with at least columns 'Temp' and 'JDay'</p>
</td></tr>
<tr><td><code id="StepChill_Wrapper_+3A_par">par</code></td>
<td>
<p>numeric vector of length 7 with the parameters of the
StepChill model: 1. Tc, 2. bf, 3. cf, 4. Cstar and 5. Fstar.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A single numeric value with the JDay prediction for the
temperaturs in 'x$Temp' and the model parameters
in 'par'.
</p>


<h3>Author(s)</h3>

<p>Carsten Urbach &lt;urbach@hiskp.uni-bonn.de&gt;
</p>


<h3>References</h3>

<p>Isabelle Chuine, A Unified Model for Budburst of Trees, J. theor. Biol. (2000) 207
</p>
<p>Asse et al., Process-based models outcompete correlative models in projecting spring
phenology of trees in a future warmer climate,Agricultural and Forest Meteorology (2020) 107913
</p>

<hr>
<h2 id='summary.bootstrap_phenologyFit'>summary.bootstrap_phenologyFit</h2><span id='topic+summary.bootstrap_phenologyFit'></span>

<h3>Description</h3>

<p>Summarise a 'bootstrap_phenologyFit' object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bootstrap_phenologyFit'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.bootstrap_phenologyFit_+3A_object">object</code></td>
<td>
<p>class 'bootstrap_phenologyFit' to summarise</p>
</td></tr>
<tr><td><code id="summary.bootstrap_phenologyFit_+3A_...">...</code></td>
<td>
<p>generic parameters, ignored here</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value.
</p>

<hr>
<h2 id='summary.phenologyFit'>summary phenologyFit</h2><span id='topic+summary.phenologyFit'></span>

<h3>Description</h3>

<p>summary phenologyFit
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'phenologyFit'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.phenologyFit_+3A_object">object</code></td>
<td>
<p>class phenologyFit. object to summarise</p>
</td></tr>
<tr><td><code id="summary.phenologyFit_+3A_...">...</code></td>
<td>
<p>additional parameters, ignored here</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value.
</p>

<hr>
<h2 id='temperature_generation'>Generation of synthetic temperature records</h2><span id='topic+temperature_generation'></span>

<h3>Description</h3>

<p>Function to incorporate the temperature generation function of the
RMAWGEN weather generator into chillR. The weather generator is calibrated
using the weather data.frame (years between years[1] and years[2]), and then
generates synthetic weather for a user-defined time frame (bounded by sim_years[1]
and sim_years[2]). Monthly change vectors for minimum and maximum temperatures
can be specified to allow generation of temperature change scenarios.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>temperature_generation(
  weather,
  years,
  sim_years,
  temperature_scenario = data.frame(Tmin = rep(0, 12), Tmax = rep(0, 12)),
  seed = 99,
  check_temperature_scenario_type = TRUE,
  temperature_check_args = NULL,
  max_reference_year_difference = 5,
  warn_me = TRUE,
  remove_NA_scenarios = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="temperature_generation_+3A_weather">weather</code></td>
<td>
<p>daily weather, as produced with the fix_weather
function. Can also be generated by other means, but should contain the columns
c(&quot;Month&quot;,&quot;Day&quot;,&quot;Year&quot;,&quot;Tmin&quot;,&quot;Tmax&quot;).</p>
</td></tr>
<tr><td><code id="temperature_generation_+3A_years">years</code></td>
<td>
<p>vector of length 2 indicating the start and end year of the time
interval to be used for calibrating the temperature generator.</p>
</td></tr>
<tr><td><code id="temperature_generation_+3A_sim_years">sim_years</code></td>
<td>
<p>vector of length 2 indicating the start and end year of the time
interval for which temperatures are to be generated.</p>
</td></tr>
<tr><td><code id="temperature_generation_+3A_temperature_scenario">temperature_scenario</code></td>
<td>
<p>can be one of three options:
1) a data.frame with two columns Tmin and Tmax and n_intervals (default: 12) rows containing
temperature changes for all time intervals, or absolute temperatures for these intervals.
2) a temperature scenario object, consisting of the following elements: 'data' = a data frame with
n_intervals elements containing the absolute or relative temperature information (as in input option 1);
'scenario_year' = the year the scenario is representative of; 'reference_year' = the year the scenario
is representative of; 'scenario_type' = the scenario type ('absolute' or 'relative' - if NA, this is
assigned automatically); 'labels' = and elements attached to the input temperature_scenario as an
element names 'labels'. A subset of these elements can also be specified, but 'data' must be present.
3) a (named or unnamed) list containing multiple objects of types 1 and 2. In this case, outputs are
generated for all scenarios.</p>
</td></tr>
<tr><td><code id="temperature_generation_+3A_seed">seed</code></td>
<td>
<p>integer specifying the random seed for the weather generation.</p>
</td></tr>
<tr><td><code id="temperature_generation_+3A_check_temperature_scenario_type">check_temperature_scenario_type</code></td>
<td>
<p>boolean variable specifying whether
temperature scenarios should be checked - and the scenario_type updated if necessary -
with the check_temperature_scenario function.</p>
</td></tr>
<tr><td><code id="temperature_generation_+3A_temperature_check_args">temperature_check_args</code></td>
<td>
<p>list of arguments to be passed to the check_temperature_scenario function.
Check documentation of that function for details.</p>
</td></tr>
<tr><td><code id="temperature_generation_+3A_max_reference_year_difference">max_reference_year_difference</code></td>
<td>
<p>for relative temperature scenarios, the maximum difference
between the reference years of the scenario and the weather record used for calibration (the median
of the two elements in the 'years' argument.</p>
</td></tr>
<tr><td><code id="temperature_generation_+3A_warn_me">warn_me</code></td>
<td>
<p>boolean variable specifying whether warnings should be shown. Defaults to TRUE.</p>
</td></tr>
<tr><td><code id="temperature_generation_+3A_remove_na_scenarios">remove_NA_scenarios</code></td>
<td>
<p>boolean parameter indicating whether temperature scenarios that
contain NA values should be removed. Such scenarios would generate an error.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that this function uses the temperature generation algorithms of the RMAWGEN
package. For more details, refer to the documentation of this package.
</p>


<h3>Value</h3>

<p>list of data.frames containing the simulated weather, with columns c(&quot;YEARMODA&quot;,
&quot;DATE&quot;,&quot;Year&quot;,&quot;Month&quot;,&quot;Day&quot;,&quot;Tmin&quot;,&quot;Tmax&quot;). If temperature_scenario is a list, the output
list contains simulated temperature records for all scenarios.
</p>


<h3>Author(s)</h3>

<p>Eike Luedeling
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Examples are #d out to pass CRAN checks. Remove #s to run them. 
# Temp&lt;-temperature_generation(KA_weather,years=c(1999,2001),
#    sim_years = c(2001,2002),temperature_scenario = data.frame(Tmin=c(1,3,2,1,5,7,3,2,1,5,4,3),
#    Tmax=c(1,2,3,2,1,3,2,1,2,3,4,5)))
  
# Temp&lt;-temperature_generation(weather=KA_weather,years=c(1999,2001),
#  sim_years = c(2005,2006),
#   temperature_scenario=data.frame(Tmin=c(1,3,5,8,12,15,15,15,10,8,3,1),
#    Tmax=c(6,8,10,13,17,20,20,20,15,13,8,6)))

 
</code></pre>

<hr>
<h2 id='temperature_scenario_baseline_adjustment'>Make temperature scenario relative to a particular baseline</h2><span id='topic+temperature_scenario_baseline_adjustment'></span>

<h3>Description</h3>

<p>When interpreting future (or past) temperature scenarios that provide absolute temperatures,
it is important to consider the temperature baseline, i.e. a temperature scenario produced with
similar models and methods that corresponds to the current temperature regime. Such baselines are
normally available from the same source that provided the future scenarios. This function implements
this adjustment.
The function can be used for two situations:
1) two absolute temperature scenarios: the output is the difference between the scenarios, i.e.
a relative temperature scenario describing the difference between monthly temperature extreme
means between the two scenarios.
2) two relative temperature scenarios: the output is a relative temperature scenario that describes
the difference between the scenario year of the temperature_scenario and the baseline year of the
baseline_temperature_scenario. This only works if the scenario_year of the baseline_temperature_scenario
is the same as the reference_year of the temperature_scenario.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>temperature_scenario_baseline_adjustment(
  baseline_temperature_scenario,
  temperature_scenario,
  temperature_check_args = NULL,
  warn_me = TRUE,
  required_variables = c("Tmin", "Tmax")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="temperature_scenario_baseline_adjustment_+3A_baseline_temperature_scenario">baseline_temperature_scenario</code></td>
<td>
<p>baseline temperature scenario (e.g. produced with
'extract_temperatures_from_grids'). This is a temperature scenario object, consisting of the
following elements: 'data' = data.frame with two columns Tmin and Tmax containing absolute
(normally monthly) mean minimum and maximum temperatures; 'reference_year' = the year the scenario
refers to (this is normally NA for absolute temperature scenarios, because they don't require
considering a reference scenario); 'scenario_type' = the scenario type, normally &quot;absolute&quot; (but can
also be &quot;relative&quot; or NA - then the type is automatically assigned); 'labels' = elements
attached to the input temperature_scenario. A subset of these elements can
also be specified, but 'data' must be present.</p>
</td></tr>
<tr><td><code id="temperature_scenario_baseline_adjustment_+3A_temperature_scenario">temperature_scenario</code></td>
<td>
<p>can be one of three options:
1) a data.frame with two columns Tmin and Tmax and n_intervals (default: 12) rows containing
temperature changes for all time intervals, or absolute temperatures for these intervals.
2) a temperature scenario object, consisting of the following elements: 'data' = a data frame with
n_intervals elements containing the absolute or relative temperature information (as in input option 1);
'scenario_year' = the year the scenario is representative of; 'reference_year' = the year the
scenario is representative of; 'scenario_type' = the scenario type ('absolute' or 'relative' - if
NA, this is assigned automatically); 'labels' = and elements attached to the input
temperature_scenario as an element names 'labels'. A subset of these elements can also be specified,
but 'data' must be present.
3) a list of elements of type 1 or 2. Then the adjustment is done for all elements.</p>
</td></tr>
<tr><td><code id="temperature_scenario_baseline_adjustment_+3A_temperature_check_args">temperature_check_args</code></td>
<td>
<p>list of arguments to be passed to the check_temperature_scenario function.
Check documentation of that function for details.</p>
</td></tr>
<tr><td><code id="temperature_scenario_baseline_adjustment_+3A_warn_me">warn_me</code></td>
<td>
<p>boolean variable specifying whether warnings should be shown. Defaults to TRUE.</p>
</td></tr>
<tr><td><code id="temperature_scenario_baseline_adjustment_+3A_required_variables">required_variables</code></td>
<td>
<p>character vectors containing names of variables that must be included in the
scenario.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>temperature scenario object, consisting of the following elements: 'data' = a data frame with
n_intervals elements containing the absolute or relative temperature information. 'reference_year' =
the year the scenario is representative of. 'scenario_type' = the scenario type ('absolute' or 'relative');
'labels' = and elements attached to the input temperature_scenario as an element names 'labels'.
</p>
<p>The function also returns warnings, where elements are missing or the scenario_type appears to be
wrong, and it stops with an error, if the scenario isn't specified in a format that is usable by
chillR.
</p>


<h3>Author(s)</h3>

<p>Eike Luedeling
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
baseline_temperature_scenario&lt;-list(data=data.frame(Tmin=c(1,1,1,1,1,1,1,1,1,1,1,1),
                                                    Tmax=c(1,1,1,1,1,1,1,1,1,1,1,1)),
                                                    scenario_year=1990,
                                                    reference_year=1975,
                                                    scenario_type="relative")
                                                    
temperature_scenario&lt;-list(data=data.frame(Tmin=c(4,4,4,4,4,4,4,4,4,4,4,4),
                                           Tmax=c(4,4,4,4,4,4,4,4,4,4,4,4)),
                                           scenario_year=2000,
                                           reference_year=1990,
                                           scenario_type="relative")
                                           
relative_temperature_scenario&lt;-temperature_scenario_baseline_adjustment(
                     baseline_temperature_scenario,temperature_scenario,
                     temperature_check_args=NULL)
                                                                       
baseline_temperature_scenario&lt;-list(data=data.frame(Tmin=c(-5,-2,2,5,10,12,15,15,12,10,5,1),
                                                    Tmax=c( 1, 4,7,10,15,18,22,24,17,15,11,6)),
                                                    scenario_year=1980,
                                                    reference_year=NA,
                                                    scenario_type="absolute")
                                                    
temperature_scenario&lt;-list(data=data.frame(Tmin=c(-3,0,4,7,12,14,17,17,14,12,7,3),
                                                    Tmax=c(3,6,9,12,17,20,24,26,19,17,13,8)),
                                           scenario_year=2000,
                                           reference_year=NA,
                                           scenario_type="absolute")
                                           
relative_temperature_scenario&lt;-temperature_scenario_baseline_adjustment(
                     baseline_temperature_scenario,temperature_scenario,
                     temperature_check_args=NULL)
                                            
 
</code></pre>

<hr>
<h2 id='temperature_scenario_from_records'>Make monthly temperature scenario from historic records</h2><span id='topic+temperature_scenario_from_records'></span>

<h3>Description</h3>

<p>Produces a list of scenarios containing monthly means for Tmin and Tmax that are representative
of particular years. These scenario are computed by applying linear regression to a
file containing Tmin and Tmax records, and using the regression model to calculate typical
values for the user-specified years.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>temperature_scenario_from_records(
  weather,
  year,
  weather_start = NA,
  weather_end = NA,
  scen_type = "running_mean",
  runn_mean = 15
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="temperature_scenario_from_records_+3A_weather">weather</code></td>
<td>
<p>daily weather, as produced with the fix_weather
function. Can also be generated by other means, but shouold contain the columns
c(&quot;Month&quot;,&quot;Day&quot;,&quot;Year&quot;,&quot;Tmin&quot;,&quot;Tmax&quot;).</p>
</td></tr>
<tr><td><code id="temperature_scenario_from_records_+3A_year">year</code></td>
<td>
<p>numeric vector of years, for which the scenario is to be produced.</p>
</td></tr>
<tr><td><code id="temperature_scenario_from_records_+3A_weather_start">weather_start</code></td>
<td>
<p>start year of the period to be considered in calculating the regression.
Defaults to NA, which means the first year of the record is used as start year.</p>
</td></tr>
<tr><td><code id="temperature_scenario_from_records_+3A_weather_end">weather_end</code></td>
<td>
<p>end year of the period to be considered in calculating the regression.
Defaults to NA, which means the last year of the record is used as end year.</p>
</td></tr>
<tr><td><code id="temperature_scenario_from_records_+3A_scen_type">scen_type</code></td>
<td>
<p>character string, either &quot;regression&quot; or &quot;running_mean&quot;, specifying how the
scenario should be produced. &quot;regression&quot; computed the scenario based on an assumed linear trend
in the data; &quot;running_mean&quot; uses a running mean function instead, with the length of the
running mean window determined by the runn_mean parameter. The default is a running mean function,
since the assumption of a linear trend often does not hold.</p>
</td></tr>
<tr><td><code id="temperature_scenario_from_records_+3A_runn_mean">runn_mean</code></td>
<td>
<p>number of vector elements to use for calculating the
running mean; this is reduced, if the time series is not long enough to accommodate the specified
window. Defaults to 15.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function produces outputs that can be used as input for the temperature_generation
function. Sample applications are the use of the temperature_generation function for
making replicate weather records for a given year for risk assessment purposes, or
the generation of a weather scenario that can be compared with other datasets (e.g. climate
scenarios based on the WorldClim dataset refer to a 1951-2000 baseline, so that meaningful
use of such scenarios for local contexts requires consideration of a scenario that corresponds
to temperatures in 1975, the central year of this period).
</p>


<h3>Value</h3>

<p>list of climate scenario objects, consisting of the following elements: 'data' =
a data frame with n_intervals elements containing the absolute temperature information.
'scenario_year' = the year the scenario is representative of, i.e. the specified 'year' parameter.
'reference_year' = NA (because this is an absolute temperature scenarios, not a 
relative one); 'scenario_type' = 'absolute' (because this is an absolute temperature
scenario, not a relative one); 'labels' = 'regression-based scenario'.
</p>


<h3>Author(s)</h3>

<p>Eike Luedeling
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
temperature_scenario_from_records(weather=KA_weather,year=2001,weather_start=2000,weather_end=2005)

 
</code></pre>

<hr>
<h2 id='tempResponse'>Calculation of climatic metrics from hourly temperature records</h2><span id='topic+tempResponse'></span>

<h3>Description</h3>

<p>Extension of the chilling function, which calculated four pre-defined
temperature-based metrics. This function has more flexibility, because it
allows specifying the models that should be calculated. These can be
selected from a small set of models provided with chillR, but they can also
be defined by the user. Precondition at the moment is that they require
hourly temperature only as inputs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tempResponse(
  hourtemps,
  Start_JDay = 1,
  End_JDay = 366,
  models = list(Chilling_Hours = Chilling_Hours, Utah_Chill_Units = Utah_Model,
    Chill_Portions = Dynamic_Model, GDH = GDH),
  misstolerance = 50,
  whole_record = FALSE,
  mean_out = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tempResponse_+3A_hourtemps">hourtemps</code></td>
<td>
<p>a list of two elements, with element 'hourtemps' being a
dataframe of hourly temperatures (e.g. produced by stack_hourly_temps). This
data frame must have a column for Year, a column for JDay (Julian date, or
day of the year), a column for Hour and a column for Temp (hourly
temperature). The second (optional) element is QC, which is a data.frame
indicating completeness of the dataset. This is automatically produced by
stack_hourly_temps.</p>
</td></tr>
<tr><td><code id="tempResponse_+3A_start_jday">Start_JDay</code></td>
<td>
<p>the start date (in Julian date, or day of the year) of the
period, for which chill and heat should be quantified.</p>
</td></tr>
<tr><td><code id="tempResponse_+3A_end_jday">End_JDay</code></td>
<td>
<p>the end date (in Julian date, or day of the year) of the
period, for which chill and heat should be quantified.</p>
</td></tr>
<tr><td><code id="tempResponse_+3A_models">models</code></td>
<td>
<p>named list of models that should be applied to the hourly
temperature data. These should be functions that take as input a vector of
hourly temperatures. This defaults to the set of models provided by the
chilling function.</p>
</td></tr>
<tr><td><code id="tempResponse_+3A_misstolerance">misstolerance</code></td>
<td>
<p>maximum percentage of values for a given season that
can be missing without the record being removed from the output. Defaults to
50.</p>
</td></tr>
<tr><td><code id="tempResponse_+3A_whole_record">whole_record</code></td>
<td>
<p>boolean parameter indicating whether the metrics should
be summed over the entire temperature record. If set to TRUE (default is
FALSE), then the function ignores the specified start and end dates and
simply returns the totals of each metric that accumulated over the entire
temperature record.</p>
</td></tr>
<tr><td><code id="tempResponse_+3A_mean_out">mean_out</code></td>
<td>
<p>boolean parameter indicating whether the mean of the input
metric (e.g. temperature) should be returned in a column named &quot;Input_mean&quot;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function calculates the total of user-specified temperature-based
metrics over periods delineated by Start_JDay and End_JDay. Models for
calculating these metrics are provided in the models list, whose elements
are named functions that convert hourly temperature records into a
cumulative record of the climate metric of interest. The metric is then
added up cumulatively over the entire temperature record and then summarized
by season. Examples of functions that can be used are Chilling_Hours,
Utah_Model, Dynamic_Model and GDH. The custom_model function allows
customized simply weight-based models, which assign differential weights to
temperatures within certain intervals. See custom_model documentation for
details.
</p>


<h3>Value</h3>

<p>data frame showing totals for all specified models for the
respective periods for all seasons included in the temperature records.
Columns are Season, End_year (the year when the period ended) and Days (the
duration of the period), as well as one column per model, which receives the
same name as the function in the models list. If the weather input consisted
of a list with elements stack and QC, the output also contains columns from
QC that indicate the completeness of the weather record that the
calculations are based on.
</p>


<h3>Author(s)</h3>

<p>Eike Luedeling
</p>


<h3>References</h3>

<p>The chillR package:
</p>
<p>Luedeling E, Kunz A and Blanke M, 2013. Identification of chilling and heat
requirements of cherry trees - a statistical approach. International Journal
of Biometeorology 57,679-689.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

weather&lt;-fix_weather(KA_weather[which(KA_weather$Year&gt;2006),])

hourtemps&lt;-stack_hourly_temps(weather,latitude=50.4)

df=data.frame(
  lower=c(-1000,1,2,3,4,5,6),
  upper=c(1,2,3,4,5,6,1000),
  weight=c(0,1,2,3,2,1,0))

custom&lt;-function(x) step_model(x,df)

models&lt;-list(Chilling_Hours=Chilling_Hours,Utah_Chill_Units=Utah_Model,Chill_Portions=
  Dynamic_Model,GDH=GDH,custom=custom)

tempResponse(hourtemps,Start_JDay = 305,End_JDay = 60,models)

</code></pre>

<hr>
<h2 id='tempResponse_daily_list'>Calculation of climatic metrics from lists of daily temperature records</h2><span id='topic+tempResponse_daily_list'></span>

<h3>Description</h3>

<p>Wrapper for the tempResponse function, to facilitate its use on lists
of daily temperature records, e.g. those produced by the 
<code><a href="#topic+temperature_generation">temperature_generation</a></code>
function. Daily temperature records are converted
into hourly records using either the 
<code><a href="#topic+stack_hourly_temps">stack_hourly_temps</a></code>
function or an empirical relationship between observed hourly temperatures
and daily temperature extremes (see
<code><a href="#topic+Empirical_hourly_temperatures">Empirical_hourly_temperatures</a></code>
for details). These hourly
records are then used as input into the
<code><a href="#topic+tempResponse">tempResponse</a></code> function, to which
most parameters are passed. See the documentation of
<code><a href="#topic+tempResponse">tempResponse</a></code> for
more details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tempResponse_daily_list(
  temperature_list,
  latitude,
  Start_JDay = 1,
  End_JDay = 366,
  models = list(Chilling_Hours = Chilling_Hours, Utah_Chill_Units = Utah_Model,
    Chill_Portions = Dynamic_Model, GDH = GDH),
  misstolerance = 50,
  whole_record = FALSE,
  empirical = NULL,
  mean_out = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tempResponse_daily_list_+3A_temperature_list">temperature_list</code></td>
<td>
<p>list of daily temperature records, as produced
by <code><a href="#topic+temperature_generation">temperature_generation</a></code>.</p>
</td></tr>
<tr><td><code id="tempResponse_daily_list_+3A_latitude">latitude</code></td>
<td>
<p>latitude of the location of interest (used for generating
hourly records).</p>
</td></tr>
<tr><td><code id="tempResponse_daily_list_+3A_start_jday">Start_JDay</code></td>
<td>
<p>the start date (in Julian date, or day of the year) of the
period, for which chill and heat should be quantified.</p>
</td></tr>
<tr><td><code id="tempResponse_daily_list_+3A_end_jday">End_JDay</code></td>
<td>
<p>the end date (in Julian date, or day of the year) of the
period, for which chill and heat should be quantified.</p>
</td></tr>
<tr><td><code id="tempResponse_daily_list_+3A_models">models</code></td>
<td>
<p>named list of models that should be applied to the hourly
temperature data. These should be functions that take as input a vector of
hourly temperatures. This defaults to the set of models provided by the
chilling function.</p>
</td></tr>
<tr><td><code id="tempResponse_daily_list_+3A_misstolerance">misstolerance</code></td>
<td>
<p>maximum percentage of values for a given season that
can be missing without the record being removed from the output. Defaults to
50.</p>
</td></tr>
<tr><td><code id="tempResponse_daily_list_+3A_whole_record">whole_record</code></td>
<td>
<p>boolean parameter indicating whether the metrics should
be summed over the entire temperature record. If set to <code>TRUE</code> (default is
<code>FALSE</code>), then the function ignores the specified start and end dates and
simply returns the totals of each metric that accumulated over the entire
temperature record.</p>
</td></tr>
<tr><td><code id="tempResponse_daily_list_+3A_empirical">empirical</code></td>
<td>
<p>indicates whether hourly temperatures should be generated
based on an idealized temperature curve (set to <code>NULL</code>, the default) or an
empirically derived relationship between hourly temperatures and daily
temperature extremes (see
<code><a href="#topic+Empirical_hourly_temperatures">Empirical_hourly_temperatures</a></code> and
<code><a href="#topic+Empirical_daily_temperature_curve">Empirical_daily_temperature_curve</a></code>,
also for the format of the empirical prediction coefficient data.frame). If the
latter, this parameter needs to be a data.frame including columns <code>Month</code>,
<code>Hour</code> and <code>Prediction_coefficients</code>. See
<code><a href="#topic+Empirical_daily_temperature_curve">Empirical_daily_temperature_curve</a></code>
for further details on the format.</p>
</td></tr>
<tr><td><code id="tempResponse_daily_list_+3A_mean_out">mean_out</code></td>
<td>
<p>boolean parameter indicating whether the mean of the input
metric (e.g. temperature) should be returned in a column named &quot;Input_mean&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data frame showing totals for all specified models for the
respective periods for all seasons included in the temperature records.
Columns are <code>Season</code>, <code>End_year</code> (the year when the period ended)
and <code>Days</code> (the duration of the period), as well as one column per model,
which receives the same name as the function in the models list.
If the weather input consisted of a list with elements <code>stack</code> and <code>QC</code>,
the output also contains columns from
<code>QC</code> that indicate the completeness of the weather record that the
calculations are based on.
</p>


<h3>Author(s)</h3>

<p>Eike Luedeling
</p>


<h3>References</h3>

<p>The chillR package:
</p>
<p>Luedeling E, Kunz A and Blanke M, 2013. Identification of chilling and heat
requirements of cherry trees - a statistical approach. International Journal
of Biometeorology 57,679-689.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

weather&lt;-fix_weather(KA_weather[which(KA_weather$Year&gt;2006),])
temperature_list&lt;-list(weather,weather,weather)

tempResponse_daily_list(temperature_list,latitude=50.4)


</code></pre>

<hr>
<h2 id='tempResponse_hourtable'>Add metric accumulation to table of hourly temperatures</h2><span id='topic+tempResponse_hourtable'></span>

<h3>Description</h3>

<p>This function calculates cumulative values for temperature response metrics
for every hour of an hourly temperature record. The count is
restarted on a specified date each year. The function is a generalized
version of chilling_hourtable, which only worked with three predefined
chilling one predefined heat metrics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tempResponse_hourtable(
  hourtemps,
  Start_JDay,
  models = c(Chill_Portions = Dynamic_Model, GDH = GDH_model)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tempResponse_hourtable_+3A_hourtemps">hourtemps</code></td>
<td>
<p>a dataframe of stacked hourly temperatures (e.g. produced
by stack_hourly_temps). This data frame must have a column for Year, a
column for JDay (Julian date, or day of the year), a column for Hour and a
column for Temp (hourly temperature).</p>
</td></tr>
<tr><td><code id="tempResponse_hourtable_+3A_start_jday">Start_JDay</code></td>
<td>
<p>the start date (in Julian date, or day of the year) of the
calculation for the four metrics. The count is restarted on this date every
year.</p>
</td></tr>
<tr><td><code id="tempResponse_hourtable_+3A_models">models</code></td>
<td>
<p>named list of models that should be applied to the hourly
temperature data. These should be functions that take as input a vector of
hourly temperatures. This defaults to c(Chill_Portions = Dynamic_Model, GDH
= GDH_model), which refer to the Dynamic chill model and the Growing Degree
Hours model functions contained in chillR.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data frame consisting of all the columns of the THourly input data
frame, plus one additional column for each model, which contains the
cumulative number of model metrics since the last Start_JDay).
</p>


<h3>Note</h3>

<p>After doing extensive model comparisons, and reviewing a lot of
relevant literature, I do not recommend using the Chilling Hours or Utah
Models, especially in warm climates! The Dynamic Model (Chill Portions),
though far from perfect, seems much more reliable.
</p>


<h3>Author(s)</h3>

<p>Eike Luedeling
</p>


<h3>References</h3>

<p>Model references:
</p>
<p>Dynamic Model:
</p>
<p>Erez A, Fishman S, Linsley-Noakes GC, Allan P (1990) The dynamic model for
rest completion in peach buds. Acta Hortic 276, 165-174
</p>
<p>Fishman S, Erez A, Couvillon GA (1987a) The temperature dependence of
dormancy breaking in plants - computer simulation of processes studied under
controlled temperatures. J Theor Biol 126(3), 309-321
</p>
<p>Fishman S, Erez A, Couvillon GA (1987b) The temperature dependence of
dormancy breaking in plants - mathematical analysis of a two-step model
involving a cooperative transition. J Theor Biol 124(4), 473-483
</p>
<p>Growing Degree Hours:
</p>
<p>Anderson JL, Richardson EA, Kesner CD (1986) Validation of chill unit and
flower bud phenology models for 'Montmorency' sour cherry. Acta Hortic 184,
71-78
</p>
<p>Review on chilling models in a climate change context:
</p>
<p>Luedeling E, 2012. Climate change impacts on winter chill for temperate
fruit and nut production: a review. Scientia Horticulturae 144, 218-229
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
weather&lt;-fix_weather(KA_weather[which(KA_weather$Year&gt;2008),])

hourtemps&lt;-stack_hourly_temps(weather,latitude=50.4)

cht&lt;-chilling_hourtable(hourtemps,20)

</code></pre>

<hr>
<h2 id='test_if_equal'>Test if all character vectors in a string are equal</h2><span id='topic+test_if_equal'></span>

<h3>Description</h3>

<p>Compares all elements of a vector of numbers or character strings and returns TRUE
if they are all the same, FALSE otherwise.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>test_if_equal(test_vector)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="test_if_equal_+3A_test_vector">test_vector</code></td>
<td>
<p>vector of strings or numbers to be tested.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>TRUE if all elements of the vector are the same; FALSE otherwise.
</p>


<h3>Author(s)</h3>

<p>Eike Luedeling
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  test_if_equal(c(1,3,1))
  test_if_equal(c("a","a","a"))
  test_if_equal(c("a","b","a"))                                            
 
</code></pre>

<hr>
<h2 id='UniChill_Wrapper'>UniChill_Wrapper</h2><span id='topic+UniChill_Wrapper'></span>

<h3>Description</h3>

<p>UniChill_Wrapper
</p>


<h3>Usage</h3>

<pre><code class='language-R'>UniChill_Wrapper(x, par)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="UniChill_Wrapper_+3A_x">x</code></td>
<td>
<p>data.frame with at least columns 'Temp' and 'JDay'</p>
</td></tr>
<tr><td><code id="UniChill_Wrapper_+3A_par">par</code></td>
<td>
<p>numeric vector of length 7 with the parameters of the
UniChill model: 1. ac, 2. bc, 3. cc, 4. bf, 5. cf, 6. Cstar and 7. Fstar.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A single numeric value with the JDay prediction for the
temperaturs in 'x$Temp' and the model parameters
in 'par'.
</p>


<h3>Author(s)</h3>

<p>Carsten Urbach &lt;urbach@hiskp.uni-bonn.de&gt;
</p>


<h3>References</h3>

<p>Isabelle Chuine, A Unified Model for Budburst of Trees, J. theor. Biol. (2000) 207
</p>

<hr>
<h2 id='UnifiedModel_Wrapper'>UnifiedModel_Wrapper</h2><span id='topic+UnifiedModel_Wrapper'></span>

<h3>Description</h3>

<p>UnifiedModel_Wrapper
</p>


<h3>Usage</h3>

<pre><code class='language-R'>UnifiedModel_Wrapper(x, par)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="UnifiedModel_Wrapper_+3A_x">x</code></td>
<td>
<p>data.frame with at least columns 'Temp' and 'JDay'</p>
</td></tr>
<tr><td><code id="UnifiedModel_Wrapper_+3A_par">par</code></td>
<td>
<p>numeric vector of length 9 with the parameters of the
unified model: 1. ac, 2. bc, 3. cc, 4. bf, 5. cf, 6. w, 7. k,
8. Cstar and 9. tc.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A single numeric value with the JDay prediction for the
temperaturs in 'x$Temp' and the Unified Model parameters
in 'par'.
</p>


<h3>Author(s)</h3>

<p>Carsten Urbach &lt;urbach@hiskp.uni-bonn.de&gt;
</p>


<h3>References</h3>

<p>Isabelle Chuine, A Unified Model for Budburst of Trees, J. theor. Biol. (2000) 207
</p>

<hr>
<h2 id='UniForce_Wrapper'>UniForce_Wrapper</h2><span id='topic+UniForce_Wrapper'></span>

<h3>Description</h3>

<p>UniForce_Wrapper
</p>


<h3>Usage</h3>

<pre><code class='language-R'>UniForce_Wrapper(x, par)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="UniForce_Wrapper_+3A_x">x</code></td>
<td>
<p>data.frame with at least columns 'Temp' and 'JDay'</p>
</td></tr>
<tr><td><code id="UniForce_Wrapper_+3A_par">par</code></td>
<td>
<p>numeric vector of length 4 with the parameters of the
UniForce model: 1. bf, 2. cf, 3. Fstar, 4. t1.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A single numeric value with the JDay prediction for the
temperaturs in 'x$Temp' and the Unified Model parameters
in 'par'.
</p>


<h3>Author(s)</h3>

<p>Carsten Urbach &lt;urbach@hiskp.uni-bonn.de&gt;
</p>


<h3>References</h3>

<p>Isabelle Chuine, A Unified Model for Budburst of Trees, J. theor. Biol. (2000) 207
</p>

<hr>
<h2 id='Utah_Model'>Calculation of cumulative chill according to the Utah Model</h2><span id='topic+Utah_Model'></span>

<h3>Description</h3>

<p>This function calculates winter chill for temperate trees according to the
Utah Model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Utah_Model(HourTemp, summ = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Utah_Model_+3A_hourtemp">HourTemp</code></td>
<td>
<p>Vector of hourly temperatures.</p>
</td></tr>
<tr><td><code id="Utah_Model_+3A_summ">summ</code></td>
<td>
<p>Boolean parameter indicating whether calculated metrics should
be provided as cumulative values over the entire record (TRUE) or as the
actual accumulation for each hour (FALSE).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Units of the Utah Model are calculated as suggested by Richardson et al.
(1974) (different weights for different temperature ranges, and negation of
chilling by warm temperatures).
</p>


<h3>Value</h3>

<p>Vector of length length(HourTemp) containing the cumulative Utah
Chill Units over the entire duration of HourTemp.
</p>


<h3>Note</h3>

<p>After doing extensive model comparisons, and reviewing a lot of
relevant literature, I do not recommend using the Utah Model, especially in
warm climates! The Dynamic Model (Chill Portions), though far from perfect,
seems much more reliable.
</p>


<h3>Author(s)</h3>

<p>Eike Luedeling
</p>


<h3>References</h3>

<p>Utah Model reference:
</p>
<p>Richardson EA, Seeley SD, Walker DR (1974) A model for estimating the
completion of rest for Redhaven and Elberta peach trees. HortScience 9(4),
331-332
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
weather&lt;-fix_weather(KA_weather[which(KA_weather$Year&gt;2006),])

stack&lt;-stack_hourly_temps(weather,latitude=50.4)

Utah_Model(stack$hourtemps$Temp)

</code></pre>

<hr>
<h2 id='VIP'>Calculate VIP scores for PLS regression</h2><span id='topic+VIP'></span>

<h3>Description</h3>

<p>This function calculates the Variable Importance in the Projection statistic
for the Partial Least Squares regression. It is used in the PLS function.
Executing it in isolation will probably not be useful to most users.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>VIP(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="VIP_+3A_object">object</code></td>
<td>
<p>an mvr object, as produced by the pls procedure or a range of
other functions</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is required to produce the VIP scores for the PLS procedure.
</p>


<h3>Value</h3>

<p>data frame with as many columns as independent variables are input
into the PLS analysis. The number of columns corresponds to the number of
latent components selected for the analysis. Values in the data frame are
the VIP values corresponding to each variable for the respective component.
</p>


<h3>Author(s)</h3>

<p>Eike Luedeling, but the function was mainly copied from
http://mevik.net/work/software/pls.html; the reference given there is listed
below
</p>


<h3>References</h3>

<p>the function is mostly identical to the one provided on
http://mevik.net/work/software/pls.html.
</p>
<p>Here is the reference given there:
</p>
<p>Chong, Il-Gyo &amp; Jun, Chi-Hyuck, 2005, Performance of some variable selection
methods when multicollinearity is present, Chemometrics and Intelligent
Laboratory Systems 78, 103-112
</p>
<p>This reference refers to the chillR package:
</p>
<p>Luedeling E, Kunz A and Blanke M, 2013. Identification of chilling and heat
requirements of cherry trees - a statistical approach. International Journal
of Biometeorology 57,679-689.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
PLS_results&lt;-PLS_pheno(
  weather_data=KA_weather,
  split_month=6,   #last month in same year
  bio_data=KA_bloom,return.all=TRUE)

#return.all makes the function return the whole PLS object - needed for next line to work
  
VIP(PLS_results$PLS_output)
  
 
</code></pre>

<hr>
<h2 id='weather2chillR'>Convert downloaded weather to chillR format</h2><span id='topic+weather2chillR'></span>

<h3>Description</h3>

<p>Convert downloaded weather data into a data frame that makes running other
chillR functions easy.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>weather2chillR(downloaded_weather, database = "GSOD", drop_most = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="weather2chillR_+3A_downloaded_weather">downloaded_weather</code></td>
<td>
<p>weather file downloaded with the get_weather
function. This can be a data.frame or a list with elements database and
weather as produced by get_weather</p>
</td></tr>
<tr><td><code id="weather2chillR_+3A_database">database</code></td>
<td>
<p>weather database that the file was downloaded from. Can only
be &quot;GSOD&quot; at this point.</p>
</td></tr>
<tr><td><code id="weather2chillR_+3A_drop_most">drop_most</code></td>
<td>
<p>boolean variable indicating if most columns should be
dropped from the file. If set to TRUE (default), only essential columns for
running chillR functions are retained.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>weather databases, from which chillR can download data: NOAA NCDC Global
Summary of the Day - &quot;GSOD&quot;
(https://data.noaa.gov/dataset/global-surface-summary-of-the-day-gsod)
</p>
<p>California Irrigation Management Information System (CIMIS) - &quot;CIMIS&quot;
(http://www.cimis.water.ca.gov/)
</p>
<p>University of California Integrated Pest Management (UCIPM) - &quot;UCIPM&quot;
(http://ipm.ucdavis.edu/WEATHER/)
</p>
<p>data should first be downloaded with get_weather. Then the database name is
passed to the function and can be skipped in the call. If only a data.frame
is provided, then the database name must be specified.
</p>
<p>Processing the data with this function will make the data work well with the
remainder of this package.
</p>


<h3>Value</h3>

<p>a data.frame with weather data, according to the downloaded file
provided as input. If drop_most is FALSE, all columns from the original
dataset are preserved, although some column names are adjusted to chillR's
preferences (&quot;Year&quot;,&quot;Month&quot;,&quot;Day&quot;,&quot;Tmin&quot;,&quot;Tmax&quot;,&quot;Tmean&quot;,&quot;Prec&quot;). If
drop_most is TRUE, only columns likely to be of interest to chillR users are
retained. If a list with elements database and weather is passed to this
function, this structure will be retained in the output.
</p>


<h3>Note</h3>

<p>Many databases have data quality flags, which may sometimes indicate
that data aren't reliable. These are not considered by this function!
</p>


<h3>Author(s)</h3>

<p>Eike Luedeling
</p>


<h3>References</h3>

<p>The chillR package:
</p>
<p>Luedeling E, Kunz A and Blanke M, 2013. Identification of chilling and heat
requirements of cherry trees - a statistical approach. International Journal
of Biometeorology 57,679-689.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# All examples are disabled, because the database is sometimes unavailable. This then generates
# an error when R runs its package functionality checks. To run the examples, remove the # mark,
# before running the code.

#stat_list&lt;-get_weather(location=c(lat=40,lon=-120,ele=150),time_interval=c(2015,2016),
#database="UCIPM")
#chillRcode&lt;-stat_list[which(stat_list$Perc_interval_covered==
#max(stat_list$Perc_interval_covered)),"chillR_code"][1]
#chillRcode should equal "DOYLE.C" now.
#gw&lt;-get_weather(location="DOYLE.C",time_interval=c(2002,2002),database="UCIPM")
#weather&lt;-weather2chillR(gw$weather,"GSOD")
#weather&lt;-weather2chillR(gw)

</code></pre>

<hr>
<h2 id='Winters_hours_gaps'>Hourly temperature data sample</h2><span id='topic+Winters_hours_gaps'></span>

<h3>Description</h3>

<p>Hourly temperature data recorded in a walnut orchard near the city of Winters,
California, USA for 3rd March to 11th November 2008. The dataset contains the
full record of recorded temperatures, as well as an additional dataset, in
which 500 data gaps of different length were introduced.
</p>


<h3>Format</h3>

<p>A data frame with observations on the following 5 variables.
</p>
 <dl>
<dt>Year</dt><dd><p>a numeric vector - the observation year</p>
</dd>
<dt>Month</dt><dd><p>a numeric vector - the observation month</p>
</dd>
<dt>Day</dt><dd><p>a numeric vector - the observation day</p>
</dd>
<dt>Hour</dt><dd><p>a numeric vector - the observation day</p>
</dd>
<dt>Temp_gaps</dt><dd><p>a numeric vector - daily maximum temperature</p>
</dd>
<dt>Temp</dt><dd><p>a numeric vector - daily minimum temperature</p>
</dd> </dl>



<h3>Source</h3>

<p>data were collected by Eike Luedeling, at that time at the 
University of California Davis (now University of Bonn) in a walnut orchard
near Winters, California
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(Winters_hours_gaps)

</code></pre>

<hr>
<h2 id='YEARMODA2Date'>YEARMODA to Date conversion</h2><span id='topic+YEARMODA2Date'></span>

<h3>Description</h3>

<p>Converts dates in YEARMODA format to R date format
</p>


<h3>Usage</h3>

<pre><code class='language-R'>YEARMODA2Date(YEARMODA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="YEARMODA2Date_+3A_yearmoda">YEARMODA</code></td>
<td>
<p>Date in YEARMODA format (e.g. 20160206 for 6th Feb 2016)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Converts YEARMODA to R date
</p>


<h3>Value</h3>

<p>Date object
</p>


<h3>Author(s)</h3>

<p>Eike Luedeling
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

YEARMODA2Date(20001205)
YEARMODA2Date(19901003)

 
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
