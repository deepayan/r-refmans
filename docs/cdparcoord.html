<!DOCTYPE html><html><head><title>Help for package cdparcoord</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {cdparcoord}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#cdparcoord'>
<p>Top-frequency parallel coordinates plots.</p></a></li>
<li><a href='#clsTupleFreqs'>
<p>Compute/display tuple frequency counts, and optionally account for</p>
NA values</a></li>
<li><a href='#demog'>
<p>Demographic statistics by ZIP Code.</p></a></li>
<li><a href='#discretize'>
<p>Discretize continuous data.</p></a></li>
<li><a href='#hrdata'>
<p>A human resources simulated dataset.</p></a></li>
<li><a href='#makeFactor'>
<p>Change numeric variables factors.</p></a></li>
<li><a href='#quickstart'>
<p>cdparcoord: Quick start</p></a></li>
<li><a href='#reOrder'>
<p>Re-order levels of a factor, according to some desired ordinal form.</p></a></li>
<li><a href='#showCounts'>
<p>Show tuple counts for the most recent saved counting operation.</p></a></li>
<li><a href='#smallexample'>
<p>A small dataset for showing how tupleFreqs works in cdparcoord</p></a></li>
<li><a href='#Titanic'>
<p>Titanic passengers</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>1.0.1</td>
</tr>
<tr>
<td>Author:</td>
<td>Norm Matloff &lt;normmatloff@gmail.com&gt; and 
    Vincent Yang &lt;vinyang@ucdavis.edu&gt; and Harrison Nguyen &lt;hhnguy@ucdavis.edu&gt;</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Norm Matloff &lt;normmatloff@gmail.com&gt;</td>
</tr>
<tr>
<td>Date:</td>
<td>2019-08-04</td>
</tr>
<tr>
<td>Title:</td>
<td>Top Frequency-Based Parallel Coordinates</td>
</tr>
<tr>
<td>Description:</td>
<td>Parallel coordinate plotting with resolutions for large data sets
 and missing values.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.2.0), data.table, plotly, freqparcoord, partools</td>
</tr>
<tr>
<td>Suggests:</td>
<td>rmarkdown, knitr</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>no</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2019-08-04 22:40:45 UTC; normanmatloff</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2019-08-04 23:00:02 UTC</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
</table>
<hr>
<h2 id='cdparcoord'>
Top-frequency parallel coordinates plots.
</h2><span id='topic+cdparcoord'></span>

<h3>Description</h3>

<p>A novel approach to the parallel coordinates method for 
visualization of multiple variables at once, focused on discrete 
and categorical variables.
</p>
<p>(a) Addresses the screen-clutter problem in parallel coordinates, by
only plotting the &quot;most typical&quot; cases. These are the tuples with 
the highest occurrence rates.
</p>
<p>(b) Provides a novel approach to NA values by allowing tuples 
with NA values to partially contribute to complete tuples rather 
than eliminating missing values.
</p>
<p>Type <code>?quickstart</code> for a quick start.
</p>


<h3>Author(s)</h3>

<p>Norm Matloff &lt;matloff@cs.ucdavis.edu&gt;, 
Vincent Yang &lt;vinyang@ucdavis.edu&gt;, and 
Harrison Nguyen &lt;hhnguy@ucdavis.edu&gt;
</p>

<hr>
<h2 id='clsTupleFreqs'>
Compute/display tuple frequency counts, and optionally account for 
NA values
</h2><span id='topic+tupleFreqs'></span><span id='topic+clsTupleFreqs'></span><span id='topic+discparcoord'></span>

<h3>Description</h3>

<p>The functions <code>tupleFreqs</code> and <code>discparcoord</code> are
the workhorse functions in the 
package, calculating frequency counts to be used in the graphs and
displaying them. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>    tupleFreqs(dataset,k=5,NAexp=1.0,countNAs=FALSE,saveCounts=FALSE, 
       minFreq=NULL,accentuate=NULL,accval=100) 
    clsTupleFreqs(cls=NULL, dataset, k=5, NAexp=1, countNAs=FALSE)
    discparcoord(data, k=5, grpcategory=NULL, permute=FALSE,
        interactive = TRUE, save=FALSE, name="Parcoords", labelsOff=TRUE,
        NAexp=1.0,countNAs=FALSE, accentuate=NULL, accval=100, inParallel=FALSE,
        cls=NULL, differentiate=FALSE, saveCounts=FALSE, minFreq=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="clsTupleFreqs_+3A_data">data</code></td>
<td>

<p>The data, in data frame or matrix form.
</p>
</td></tr>
<tr><td><code id="clsTupleFreqs_+3A_k">k</code></td>
<td>

<p>The number of tuples to return. These will be the <code>k</code> most
frequent tuples, unless <code>k</code> is negative, in which case the
least-frequent tuples will be returned.  The latter is useful
for hunting for outliers.
</p>
</td></tr>
<tr><td><code id="clsTupleFreqs_+3A_grpcategory">grpcategory</code></td>
<td>

<p>Grouping column/variable.
</p>
</td></tr>
<tr><td><code id="clsTupleFreqs_+3A_permute">permute</code></td>
<td>

<p>If TRUE, randomly permute the columns before plotting.
</p>
</td></tr>
<tr><td><code id="clsTupleFreqs_+3A_interactive">interactive</code></td>
<td>

<p>If TRUE, use interactive plotting, allowing for interactively
readjusting column order and scrubbing/brushing. 
</p>
</td></tr>
<tr><td><code id="clsTupleFreqs_+3A_save">save</code></td>
<td>

<p>If this is TRUE and interactive mode is on, saved plot
will be available from the browser.
</p>
</td></tr>
<tr><td><code id="clsTupleFreqs_+3A_name">name</code></td>
<td>

<p>The name for the plot.
</p>
</td></tr>
<tr><td><code id="clsTupleFreqs_+3A_labelsoff">labelsOff</code></td>
<td>

<p>If TRUE, labels are off. This only comes into
effect when interactive=FALSE.
</p>
</td></tr>
<tr><td><code id="clsTupleFreqs_+3A_naexp">NAexp</code></td>
<td>

<p>Scale for NA counts.
</p>
</td></tr>
<tr><td><code id="clsTupleFreqs_+3A_countnas">countNAs</code></td>
<td>

<p>If TRUE, count NA values.
</p>
</td></tr>
<tr><td><code id="clsTupleFreqs_+3A_accentuate">accentuate</code></td>
<td>

<p>Character expression specifying the property to accentuate.
</p>
</td></tr>
<tr><td><code id="clsTupleFreqs_+3A_accval">accval</code></td>
<td>

<p>Value to accentuate. 
</p>
</td></tr>
<tr><td><code id="clsTupleFreqs_+3A_inparallel">inParallel</code></td>
<td>

<p>If TRUE, calculate tuple frequencies in parallel. 
</p>
</td></tr>
<tr><td><code id="clsTupleFreqs_+3A_differentiate">differentiate</code></td>
<td>

<p>If TRUE, randomize coloring to differentiate overlapping
lines. 
</p>
</td></tr>
<tr><td><code id="clsTupleFreqs_+3A_savecounts">saveCounts</code></td>
<td>

<p>If TRUE, save the tuple counts to the file &lsquo;<span class="file">tupleCounts</span>&rsquo;.
</p>
</td></tr>
<tr><td><code id="clsTupleFreqs_+3A_minfreq">minFreq</code></td>
<td>

<p>The smallest frequency to be displayed.
</p>
</td></tr>
<tr><td><code id="clsTupleFreqs_+3A_dataset">dataset</code></td>
<td>

<p>The dataset to process, a data frame or data.table.
</p>
</td></tr>
<tr><td><code id="clsTupleFreqs_+3A_cls">cls</code></td>
<td>

<p>Cluster to be used if <code>inParallel</code> is TRUE.  If
<code>inParallel</code> is TRUE and <code>cls</code> is not supplied, 
it will use the sensed number of cores on the calling machine 
by default. 
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Tuple tabulation is performed by <code>tupleFreqs</code>, or in large
cases, in parallel by <code>clsTupleFreqs</code>.  The display is done by
<code>discparcoord</code>.
</p>
<p>The <code>k</code> most- or least-frequent tuples will be reported, 
with the latter specified via negative <code>k</code>.  Optionally, 
tuples with NA values will count less, but weigh toward 
everything that has existing numbers in common with it.  
</p>
<p>If continuous variables are present, then in most cases, either
convert to discrete using <code><a href="#topic+discretize">discretize</a></code> or use
<span class="pkg">freqparcoord</span>.
</p>
<p>The data will be converted into a data.table if it is not already in
that form.  For this and other reasons, it is advantageous to have the
data in that form to begin with, say by using <code>data.table::fread</code> 
to read the data.
</p>
<p>Optionally, tuples that partially match a full tuple pattern except for NA
values will add a partial count to the frequency count for the full
pattern.  If for instance the data consist of 8-tuples and a row in the
data matches a given 8-tuple pattern in 7 of 8 components, this row
would add a count of 7/8 to the frequency for that pattern.  To reduce
this weight, use a value greater than 1.0 for <code>NAexp</code>.  If that
value is 2, for example, the 7/8 increment will be 7/8 squared.
</p>


<h3>Value</h3>

<p>The functions <code>tupleFreqs</code> and <code>clsTupleFreqs</code> return an
object of class <code>c('pna','data.frame')</code>, with each row
consisting of a tuple and its count.  In addition the object will
have attributes <code>k</code> and <code>minFreq</code>.
</p>
<p>The function <code>discparcoord</code> returns an object of class
<code>c('plotly','htmlwidget')</code>.  Printing the object causes display
of the graph.
</p>


<h3>Author(s)</h3>

<p>Norm Matloff &lt;matloff@cs.ucdavis.edu&gt;, Vincent Yang &lt;vinyang@ucdavis.edu&gt;, 
and Harrison Nguyen &lt;hhnguy@ucdavis.edu&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
   ## Not run: 
       data(Titanic)
       # Find frequencies in parallel
       discparcoord(Titanic, inParallel=TRUE)
    
## End(Not run)

    ## Not run: 
       data(hrdata)
       input1 = list("name" = "average_montly_hours",
                     "partitions" = 3, "labels" = c("low", "med", "high"))
       input = list(input1)
       # this will discretize the data by partitioning average monthly 
       # hours into 3 parts called low, med, and high
       hrdata = discretize(hrdata, input)
       print('first few discretized tuples')
       # first line should be 0.38,0.53,2,low,3,0,1,00,sales,low
       head(hrdata)
       print('first few most-frequent tuples')
       # first line should be 0.40,0.46,2,...,11
       tupleFreqs(hrdata,saveCounts=FALSE)
       # account for NA values and plot with parallel coordinates
       discparcoord(hrdata)
       # same as above, but with scrambled columns
       discparcoord(hrdata, permute=TRUE)
       # same as above, but show top k values
       discparcoord(hrdata, k=8)
       # same as above, but group according to profession
       discparcoord(hrdata, grpcategory="sales")
    
## End(Not run)
</code></pre>

<hr>
<h2 id='demog'>
Demographic statistics by ZIP Code.
</h2><span id='topic+demog'></span>

<h3>Description</h3>

<p>Useful for embeddings.  Source is catalog.data.gov.
</p>

<hr>
<h2 id='discretize'>
Discretize continuous data.
</h2><span id='topic+discretize'></span>

<h3>Description</h3>

<p>Converts continuous columns to discrete.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>    discretize(dataset, input = NULL, ndigs=2, nlevels=10, presumedFactor=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="discretize_+3A_dataset">dataset</code></td>
<td>

<p>Dataset to discretize, data frame/table.
</p>
</td></tr>
<tr><td><code id="discretize_+3A_input">input</code></td>
<td>

<p>Optional specification for partitioning, giving the number of 
partitions and labels for each partition.  List of lists, one
list per column to be converted.  The outermost list indicates
the columns to be converted, and each inner list holds the name 
of the column, the number of partitions, and a list of labels 
for each partition.  
</p>
</td></tr>
<tr><td><code id="discretize_+3A_ndigs">ndigs</code></td>
<td>

<p>Number of digits to retain in forming labels/values for the
discretized data, if <code>input</code> is not supplied. E.g. if
<code>ndigs</code> is 2 and the original datum is 38.12, it becomes
38.
</p>
</td></tr>
<tr><td><code id="discretize_+3A_nlevels">nlevels</code></td>
<td>

<p>Number of partitions to form for each variable, if 
<code>input</code> is NULL.  
</p>
</td></tr>
<tr><td><code id="discretize_+3A_presumedfactor">presumedFactor</code></td>
<td>

<p>If TRUE, any variable having fewer than <code>nlevels</code>
levels will be presumed to be an
informal factor, and thus will not be discretized.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>input</code> is not specified, each numeric column in the data will
be discretized, with one exception:  If a column is numeric but has
fewer distinct values than <code>nlevels</code>, and if <code>presumedFactor</code>
is TRUE, it is presumed to be an informal R factor and will not be converted.
However, it is best to use <code><a href="#topic+makeFactor">makeFactor</a></code> on such variables.
</p>


<h3>Author(s)</h3>

<p>Norm Matloff &lt;matloff@cs.ucdavis.edu&gt;, Vincent Yang &lt;vinyang@ucdavis.edu&gt;, and Harrison Nguyen &lt;hhnguy@ucdavis.edu&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
    data(prgeng)
    pe &lt;- prgeng[,c(1,3,5,7:9)]  # extract vars of interest
    pe25 &lt;- pe[pe$wageinc &lt; 250000,]  # delete extreme values
    pe25disc &lt;- discretize(pe25)  # age, wageinc and wkswrkd discretized

    data(mlb)
    # extract the height, weight, age, and position of players
    m &lt;- mlb[,4:7]

    inp1 &lt;- list("name" = "Height",
                 "partitions"=4,
                 "labels"=c("short", "shortmid", "tallmid", "tall"))

    inp2 &lt;- list("name" = "Weight",
                 "partitions"=3,
                 "labels"=c("light", "med", "heavy"))

    inp3 &lt;- list("name" = "Age",
                 "partitions"=3,
                 "labels"=c("young", "med", "old"))

    # create one list to pass everything to discretize()
    discreteinput &lt;- list(inp1, inp2, inp3)
    head(discreteinput)

    # at this point, all of the data has been discretized
    discretizedmlb &lt;- discretize(m, discreteinput)
    head(discretizedmlb)


</code></pre>

<hr>
<h2 id='hrdata'>
A human resources simulated dataset.
</h2><span id='topic+hrdata'></span>

<h3>Description</h3>

<p>A small fictional dataset by Kaggle that includes satisfaction level,
the result of their last evaluation, number of projects, average monthly hours,
time spent at the company, whether they have had a work accident, whether
they have had a promotion in the last 5 years, their department,
salary and finally whether the employee has left the company. Each
row represents a single employee.
</p>


<h3>Author(s)</h3>

<p>Norm Matloff &lt;matloff@cs.ucdavis.edu&gt;, Vincent Yang &lt;vinyang@ucdavis.edu&gt;, and Harrison Nguyen &lt;hhnguy@ucdavis.edu&gt;
</p>

<hr>
<h2 id='makeFactor'>
Change numeric variables factors.
</h2><span id='topic+makeFactor'></span>

<h3>Description</h3>

<p>Change numeric variables that are specified in <code>varnames</code>
to factors so that <code>discretize</code> won't partition. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>    makeFactor(df, varnames)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makeFactor_+3A_df">df</code></td>
<td>

<p>Input data frame.
</p>
</td></tr>
<tr><td><code id="makeFactor_+3A_varnames">varnames</code></td>
<td>

<p>Names of variables to be converted to factors.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Norm Matloff &lt;matloff@cs.ucdavis.edu&gt;, Vincent Yang &lt;vinyang@ucdavis.edu&gt;, and Harrison Nguyen &lt;hhnguy@ucdavis.edu&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(prgeng)
pe &lt;- prgeng[,c(1,3,5,7:9)]
class(pe$educ)  # integer
pe &lt;- makeFactor(pe,c('educ','occ','sex'))
class(pe$educ)  # factor
# nice to give levels names
levels(pe$sex) &lt;- c('male','female')
head(pe$sex)
</code></pre>

<hr>
<h2 id='quickstart'>
cdparcoord: Quick start
</h2><span id='topic+quickstart'></span>

<h3>Description</h3>

<p>Quick introduction to the package.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   # programmer/engineer info from 2000 Census
   data(prgeng)
   # select some columns of interest
   pe &lt;- prgeng[,c(1,3,5,7:9)]
   # remove some extreme values
   pe25 &lt;- pe[pe$wageinc &lt; 250000,]
   # some numeric variables are really factors
   pe25 &lt;- makeFactor(pe25,c('educ','occ','sex'))
   # convert the continuous variables to discrete
   pe25disc &lt;- discretize(pe25,nlevels=5)
   ## Not run: 
      # display
      discparcoord(pe25disc,k=150)
      # then possibly brush, etc. 
   
## End(Not run)
</code></pre>

<hr>
<h2 id='reOrder'>
Re-order levels of a factor, according to some desired ordinal form.
</h2><span id='topic+reOrder'></span>

<h3>Description</h3>

<p>Use to order the levels of a factor in a desired sequence.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>    reOrder(dataset, colName, levelNames)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reOrder_+3A_dataset">dataset</code></td>
<td>

<p>Dataset to reorder.
</p>
</td></tr>
<tr><td><code id="reOrder_+3A_colname">colName</code></td>
<td>

<p>Column name.
</p>
</td></tr>
<tr><td><code id="reOrder_+3A_levelnames">levelNames</code></td>
<td>

<p>Names of the reordered levels
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Norm Matloff &lt;matloff@cs.ucdavis.edu&gt;, Vincent Yang &lt;vinyang@ucdavis.edu&gt;, and Harrison Nguyen &lt;hhnguy@ucdavis.edu&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   sl &lt;- c('primary','college','hs','middle','hs')
   z &lt;- data.frame(
          schlvl = factor(x=sl,
             levels=c('college','hs','middle','primary'))
          )
   z
   z &lt;- reOrder(z,'schlvl',c('primary','middle','hs','college'))
   str(z)  # shows the desired label order in the 'categoryorder' attribute
</code></pre>

<hr>
<h2 id='showCounts'>
Show tuple counts for the most recent saved counting operation.
</h2><span id='topic+showCounts'></span>

<h3>Description</h3>

<p>Used with <code>saveCounts</code> TRUE in <code>tupleFreqs</code> etc.
to recover the tuple counts.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>    showCounts(nshow=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="showCounts_+3A_nshow">nshow</code></td>
<td>

<p>Dataset to show.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Norm Matloff &lt;matloff@cs.ucdavis.edu&gt;, Vincent Yang &lt;vinyang@ucdavis.edu&gt;, and Harrison Nguyen &lt;hhnguy@ucdavis.edu&gt;
</p>

<hr>
<h2 id='smallexample'>
A small dataset for showing how tupleFreqs works in cdparcoord
</h2><span id='topic+smallexample'></span><span id='topic+categoricalexample'></span>

<h3>Description</h3>

<p>A small fictional dataset with different values and NA's to emphasize
tupleFreqs and frequency based calculations with cdparcoord.
</p>


<h3>Author(s)</h3>

<p>Norm Matloff &lt;matloff@cs.ucdavis.edu&gt;, Vincent Yang &lt;vinyang@ucdavis.edu&gt;, and Harrison Nguyen &lt;hhnguy@ucdavis.edu&gt;
</p>

<hr>
<h2 id='Titanic'>
Titanic passengers
</h2><span id='topic+Titanic'></span>

<h3>Description</h3>

<p>Famous dataset, source various.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
