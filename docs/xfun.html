<!DOCTYPE html><html><head><title>Help for package xfun</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {xfun}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#alnum_id'><p>Generate ID strings</p></a></li>
<li><a href='#attr'><p>Obtain an attribute of an object without partial matching</p></a></li>
<li><a href='#base_pkgs'><p>Get base R package names</p></a></li>
<li><a href='#base64_encode'><p>Encode/decode data into/from base64 encoding.</p></a></li>
<li><a href='#base64_uri'><p>Generate the Data URI for a file</p></a></li>
<li><a href='#bg_process'><p>Start a background process</p></a></li>
<li><a href='#broken_packages'><p>Find out broken packages and reinstall them</p></a></li>
<li><a href='#bump_version'><p>Bump version numbers</p></a></li>
<li><a href='#cache_exec'><p>Cache the execution of an expression in memory or on disk</p></a></li>
<li><a href='#cache_rds'><p>Cache the value of an R expression to an RDS file</p></a></li>
<li><a href='#crandalf_check'><p>Submit check jobs to crandalf</p></a></li>
<li><a href='#csv_options'><p>Parse comma-separated chunk options</p></a></li>
<li><a href='#decimal_dot'><p>Evaluate an expression after forcing the decimal point to be a dot</p></a></li>
<li><a href='#del_empty_dir'><p>Delete an empty directory</p></a></li>
<li><a href='#dir_create'><p>Create a directory recursively by default</p></a></li>
<li><a href='#dir_exists'><p>Test the existence of files and directories</p></a></li>
<li><a href='#divide_chunk'><p>Divide chunk options from the code chunk body</p></a></li>
<li><a href='#do_once'><p>Perform a task once in an R session</p></a></li>
<li><a href='#download_cache'><p>Download a file from a URL and cache it on disk</p></a></li>
<li><a href='#download_file'><p>Try various methods to download a file</p></a></li>
<li><a href='#embed_file'><p>Embed a file, multiple files, or directory on an HTML page</p></a></li>
<li><a href='#env_option'><p>Retrieve a global option from both <code>options()</code> and environment variables</p></a></li>
<li><a href='#existing_files'><p>Find file paths that exist</p></a></li>
<li><a href='#exit_call'><p>Call <code>on.exit()</code> in a parent function</p></a></li>
<li><a href='#fenced_block'><p>Create a fenced block in Markdown</p></a></li>
<li><a href='#file_ext'><p>Manipulate filename extensions</p></a></li>
<li><a href='#file_string'><p>Read a text file and concatenate the lines by <code>'\n'</code></p></a></li>
<li><a href='#format_bytes'><p>Format numbers of bytes using a specified unit</p></a></li>
<li><a href='#from_root'><p>Get the relative path of a path in a project relative to the current working</p>
directory</a></li>
<li><a href='#github_releases'><p>Get the tags of GitHub releases of a repository</p></a></li>
<li><a href='#grep_sub'><p>Perform replacement with <code>gsub()</code> on elements matched from <code>grep()</code></p></a></li>
<li><a href='#gsub_file'><p>Search and replace strings in files</p></a></li>
<li><a href='#in_dir'><p>Evaluate an expression under a specified working directory</p></a></li>
<li><a href='#install_dir'><p>Install a source package from a directory</p></a></li>
<li><a href='#install_github'><p>An alias of <code>remotes::install_github()</code></p></a></li>
<li><a href='#is_abs_path'><p>Test if paths are relative or absolute</p></a></li>
<li><a href='#is_ascii'><p>Check if a character vector consists of entirely ASCII characters</p></a></li>
<li><a href='#is_blank'><p>Test if a character vector consists of blank strings</p></a></li>
<li><a href='#is_R_CMD_check'><p>Some utility functions for checking packages</p></a></li>
<li><a href='#is_sub_path'><p>Test if a path is a subpath of a dir</p></a></li>
<li><a href='#is_web_path'><p>Test if a path is a web path</p></a></li>
<li><a href='#is_windows'><p>Test for types of operating systems</p></a></li>
<li><a href='#isFALSE'><p>Test if an object is <code>FALSE</code></p></a></li>
<li><a href='#magic_path'><p>Find a file or directory under a root directory</p></a></li>
<li><a href='#mark_dirs'><p>Mark some paths as directories</p></a></li>
<li><a href='#md_table'><p>Generate a simple Markdown pipe table</p></a></li>
<li><a href='#md5'><p>Calculate the MD5 checksums of R objects</p></a></li>
<li><a href='#msg_cat'><p>Generate a message with <code>cat()</code></p></a></li>
<li><a href='#native_encode'><p>Try to use the system native encoding to represent a character vector</p></a></li>
<li><a href='#new_app'><p>Create a local web application</p></a></li>
<li><a href='#news2md'><p>Convert package news to the Markdown format</p></a></li>
<li><a href='#normalize_path'><p>Normalize paths</p></a></li>
<li><a href='#numbers_to_words'><p>Convert numbers to English words</p></a></li>
<li><a href='#optipng'><p>Run OptiPNG on all PNG files under a directory</p></a></li>
<li><a href='#parse_only'><p>Parse R code and do not keep the source</p></a></li>
<li><a href='#pkg_attach'><p>Attach or load packages, and automatically install missing packages if</p>
requested</a></li>
<li><a href='#proc_kill'><p>Kill a process and (optionally) all its child processes</p></a></li>
<li><a href='#process_file'><p>Read a text file, process the text with a function, and write the text back</p></a></li>
<li><a href='#proj_root'><p>Return the (possible) root directory of a project</p></a></li>
<li><a href='#prose_index'><p>Find the indices of lines in Markdown that are prose (not code blocks)</p></a></li>
<li><a href='#protect_math'><p>Protect math expressions in pairs of backticks in Markdown</p></a></li>
<li><a href='#raw_string'><p>Print a character vector in its raw form</p></a></li>
<li><a href='#read_all'><p>Read all text files and concatenate their content</p></a></li>
<li><a href='#read_bin'><p>Read all records of a binary file as a raw vector by default</p></a></li>
<li><a href='#read_utf8'><p>Read / write files encoded in UTF-8</p></a></li>
<li><a href='#record'><p>Run R code and record the results</p></a></li>
<li><a href='#record_print'><p>Print methods for <code>record()</code></p></a></li>
<li><a href='#relative_path'><p>Get the relative path of a path relative to a directory</p></a></li>
<li><a href='#rename_seq'><p>Rename files with a sequential numeric prefix</p></a></li>
<li><a href='#rest_api'><p>Get data from a REST API</p></a></li>
<li><a href='#retry'><p>Retry calling a function for a number of times</p></a></li>
<li><a href='#rev_check'><p>Run <code>R CMD check</code> on the reverse dependencies of a package</p></a></li>
<li><a href='#Rscript'><p>Run the commands <code>Rscript</code> and <code>R CMD</code></p></a></li>
<li><a href='#Rscript_call'><p>Call a function in a new R session via <code>Rscript()</code></p></a></li>
<li><a href='#rstudio_type'><p>Type a character vector into the RStudio source editor</p></a></li>
<li><a href='#same_path'><p>Test if two paths are the same after they are normalized</p></a></li>
<li><a href='#session_info'><p>An alternative to sessionInfo() to print session information</p></a></li>
<li><a href='#set_envvar'><p>Set environment variables</p></a></li>
<li><a href='#shrink_images'><p>Shrink images to a maximum width</p></a></li>
<li><a href='#split_lines'><p>Split a character vector by line breaks</p></a></li>
<li><a href='#split_source'><p>Split source lines into complete expressions</p></a></li>
<li><a href='#strict_list'><p>Strict lists</p></a></li>
<li><a href='#strip_html'><p>Strip HTML tags</p></a></li>
<li><a href='#submit_cran'><p>Submit a source package to CRAN</p></a></li>
<li><a href='#system3'><p>Run <code>system2()</code> and mark its character output as UTF-8 if appropriate</p></a></li>
<li><a href='#tinify'><p>Use the Tinify API to compress PNG and JPEG images</p></a></li>
<li><a href='#tojson'><p>A simple JSON serializer</p></a></li>
<li><a href='#tree'><p>Turn the output of <code>str()</code> into a tree diagram</p></a></li>
<li><a href='#try_error'><p>Try an expression and see if it throws an error</p></a></li>
<li><a href='#try_silent'><p>Try to evaluate an expression silently</p></a></li>
<li><a href='#upload_ftp'><p>Upload to an FTP server via <code>curl</code></p></a></li>
<li><a href='#upload_imgur'><p>Upload an image to imgur.com</p></a></li>
<li><a href='#url_accessible'><p>Test if a URL is accessible</p></a></li>
<li><a href='#url_filename'><p>Extract filenames from a URLs</p></a></li>
<li><a href='#valid_syntax'><p>Check if the syntax of the code is valid</p></a></li>
<li><a href='#yaml_body'><p>Partition the YAML metadata and the body in a document</p></a></li>
<li><a href='#yaml_load'><p>Read YAML data</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Supporting Functions for Packages Maintained by 'Yihui Xie'</td>
</tr>
<tr>
<td>Version:</td>
<td>0.45</td>
</tr>
<tr>
<td>Description:</td>
<td>Miscellaneous functions commonly used in other packages maintained by 'Yihui Xie'.</td>
</tr>
<tr>
<td>Imports:</td>
<td>grDevices, stats, tools</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testit, parallel, codetools, methods, rstudioapi, tinytex (&ge;
0.30), mime, markdown (&ge; 1.5), knitr (&ge; 1.47), htmltools,
remotes, pak, rhub, renv, curl, xml2, jsonlite, magick, yaml,
qs, rmarkdown</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/yihui/xfun">https://github.com/yihui/xfun</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/yihui/xfun/issues">https://github.com/yihui/xfun/issues</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-06-16 22:23:47 UTC; yihui</td>
</tr>
<tr>
<td>Author:</td>
<td>Yihui Xie <a href="https://orcid.org/0000-0003-0645-5666"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut,
    cre, cph],
  Wush Wu [ctb],
  Daijiang Li [ctb],
  Xianying Tan [ctb],
  Salim Brüggemann <a href="https://orcid.org/0000-0002-5329-5987"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb],
  Christophe Dervieux [ctb],
  Posit Software, PBC [cph, fnd]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Yihui Xie &lt;xie@yihui.name&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-06-16 23:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='alnum_id'>Generate ID strings</h2><span id='topic+alnum_id'></span>

<h3>Description</h3>

<p>Substitute certain (by default, non-alphanumeric) characters with dashes and
remove extra dashes at both ends to generate ID strings. This function is
intended for generating IDs for HTML elements, so HTML tags in the input text
will be removed first.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>alnum_id(x, exclude = "[^[:alnum:]]+")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="alnum_id_+3A_x">x</code></td>
<td>
<p>A character vector.</p>
</td></tr>
<tr><td><code id="alnum_id_+3A_exclude">exclude</code></td>
<td>
<p>A (Perl) regular expression to detect characters to be
replaced by dashes. By default, non-alphanumeric characters are replaced.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector of IDs.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x = c("Hello world 123!", "a  &amp;b*^##c 456")
xfun::alnum_id(x)
xfun::alnum_id(x, "[^[:alpha:]]+")  # only keep alphabetical chars
# when text contains HTML tags
xfun::alnum_id("&lt;h1&gt;Hello &lt;strong&gt;world&lt;/strong&gt;!")
</code></pre>

<hr>
<h2 id='attr'>Obtain an attribute of an object without partial matching</h2><span id='topic+attr'></span>

<h3>Description</h3>

<p>An abbreviation of <code><a href="base.html#topic+attr">base::attr</a></code><code>(exact = TRUE)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>attr(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="attr_+3A_...">...</code></td>
<td>
<p>Passed to <code><a href="base.html#topic+attr">base::attr()</a></code> (without the <code>exact</code> argument).</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>z = structure(list(a = 1), foo = 2)
base::attr(z, "f")  # 2
xfun::attr(z, "f")  # NULL
xfun::attr(z, "foo")  # 2
</code></pre>

<hr>
<h2 id='base_pkgs'>Get base R package names</h2><span id='topic+base_pkgs'></span>

<h3>Description</h3>

<p>Return names of packages from <code><a href="utils.html#topic+installed.packages">installed.packages()</a></code> of which the
priority is <code>"base"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>base_pkgs()
</code></pre>


<h3>Value</h3>

<p>A character vector of base R package names.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
xfun::base_pkgs()

</code></pre>

<hr>
<h2 id='base64_encode'>Encode/decode data into/from base64 encoding.</h2><span id='topic+base64_encode'></span><span id='topic+base64_decode'></span>

<h3>Description</h3>

<p>The function <code>base64_encode()</code> encodes a file or a raw vector into the
base64 encoding. The function <code>base64_decode()</code> decodes data from the
base64 encoding.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>base64_encode(x)

base64_decode(x, from = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="base64_encode_+3A_x">x</code></td>
<td>
<p>For <code>base64_encode()</code>, a raw vector. If not raw, it is assumed
to be a file or a connection to be read via <code>readBin()</code>. For
<code>base64_decode()</code>, a string.</p>
</td></tr>
<tr><td><code id="base64_encode_+3A_from">from</code></td>
<td>
<p>If provided (and <code>x</code> is not provided), a connection or file
to be read via <code>readChar()</code>, and the result will be passed to the
argument <code>x</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>base64_encode()</code> returns a character string.
<code>base64_decode()</code> returns a raw vector.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>xfun::base64_encode(as.raw(1:10))
logo = xfun:::R_logo()
xfun::base64_encode(logo)
xfun::base64_decode("AQIDBAUGBwgJCg==")
</code></pre>

<hr>
<h2 id='base64_uri'>Generate the Data URI for a file</h2><span id='topic+base64_uri'></span>

<h3>Description</h3>

<p>Encode the file in the base64 encoding, and add the media type. The data URI
can be used to embed data in HTML documents, e.g., in the <code>src</code> attribute of
the <code style="white-space: pre;">&#8288;&lt;img /&gt;&#8288;</code> tag.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>base64_uri(x, type = mime::guess_type(x))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="base64_uri_+3A_x">x</code></td>
<td>
<p>A file path.</p>
</td></tr>
<tr><td><code id="base64_uri_+3A_type">type</code></td>
<td>
<p>The MIME type of the file, e.g., <code>"image/png"</code> for a PNG image
file.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A string of the form <code style="white-space: pre;">&#8288;data:&lt;media type&gt;;base64,&lt;data&gt;&#8288;</code>.
</p>


<h3>Note</h3>

<p>This function requires the <span class="pkg">mime</span> package to determine the MIME
type of the file except for a few common MIME types.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>logo = xfun:::R_logo()
img = htmltools::img(src = xfun::base64_uri(logo), alt = "R logo")
if (interactive()) htmltools::browsable(img)
</code></pre>

<hr>
<h2 id='bg_process'>Start a background process</h2><span id='topic+bg_process'></span>

<h3>Description</h3>

<p>Start a background process using the PowerShell cmdlet
<code>Start-Process-PassThru</code> on Windows or the ampersand <code>&amp;</code> on
Unix, and return the process ID.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bg_process(
  command,
  args = character(),
  verbose = getOption("xfun.bg_process.verbose", FALSE)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bg_process_+3A_command">command</code>, <code id="bg_process_+3A_args">args</code></td>
<td>
<p>The system command and its arguments. They do not need to
be quoted, since they will be quoted via <code><a href="base.html#topic+shQuote">shQuote()</a></code> internally.</p>
</td></tr>
<tr><td><code id="bg_process_+3A_verbose">verbose</code></td>
<td>
<p>If <code>FALSE</code>, suppress the output from <code>stdout</code> (and also
<code>stderr</code> on Windows). The default value of this argument can be set via a
global option, e.g., <code>options(xfun.bg_process.verbose = TRUE)</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The process ID as a character string.
</p>


<h3>Note</h3>

<p>On Windows, if PowerShell is not available, try to use
<code><a href="base.html#topic+system2">system2</a></code><code>(wait = FALSE)</code> to start the background process instead. The
process ID will be identified from the output of the command
<code>tasklist</code>. This method of looking for the process ID may not be
reliable. If the search is not successful in 30 seconds, it will throw an
error (timeout). If a longer time is needed, you may set
<code>options(xfun.bg_process.timeout)</code> to a larger value, but it should be very
rare that a process cannot be started in 30 seconds. When you reach the
timeout, it is more likely that the command actually failed.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+proc_kill">proc_kill()</a></code> to kill a process.
</p>

<hr>
<h2 id='broken_packages'>Find out broken packages and reinstall them</h2><span id='topic+broken_packages'></span>

<h3>Description</h3>

<p>If a package is broken (i.e., not <code><a href="#topic+loadable">loadable()</a></code>), reinstall it.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>broken_packages(reinstall = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="broken_packages_+3A_reinstall">reinstall</code></td>
<td>
<p>Whether to reinstall the broken packages, or only list their
names.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Installed R packages could be broken for several reasons. One common reason
is that you have upgraded R to a newer <code>x.y</code> version, e.g., from <code style="white-space: pre;">&#8288;4.0.5&#8288;</code> to
<code style="white-space: pre;">&#8288;4.1.0&#8288;</code>, in which case you need to reinstall previously installed packages.
</p>


<h3>Value</h3>

<p>A character vector of names of broken package.
</p>

<hr>
<h2 id='bump_version'>Bump version numbers</h2><span id='topic+bump_version'></span>

<h3>Description</h3>

<p>Increase the last digit of version numbers, e.g., from <code>0.1</code> to
<code>0.2</code>, or <code style="white-space: pre;">&#8288;7.23.9&#8288;</code> to <code style="white-space: pre;">&#8288;7.23.10&#8288;</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bump_version(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bump_version_+3A_x">x</code></td>
<td>
<p>A vector of version numbers (of the class <code>"numeric_version"</code>),
or values that can be coerced to version numbers via
<code>as.numeric_version()</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of new version numbers.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>xfun::bump_version(c("0.1", "91.2.14"))
</code></pre>

<hr>
<h2 id='cache_exec'>Cache the execution of an expression in memory or on disk</h2><span id='topic+cache_exec'></span>

<h3>Description</h3>

<p>Caching is based on the assumption that if the input does not change, the
output will not change. After an expression is executed for the first time,
its result will be saved (either in memory or on disk). The next run will be
skipped and the previously saved result will be loaded directly if all
external inputs of the expression remain the same, otherwise the cache will
be invalidated and the expression will be re-executed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cache_exec(expr, path = "cache/", id = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cache_exec_+3A_expr">expr</code></td>
<td>
<p>An R expression to be cached.</p>
</td></tr>
<tr><td><code id="cache_exec_+3A_path">path</code></td>
<td>
<p>The path to save the cache. The special value <code>":memory:"</code> means
in-memory caching. If it is intended to be a directory path, please make
sure to add a trailing slash.</p>
</td></tr>
<tr><td><code id="cache_exec_+3A_id">id</code></td>
<td>
<p>A stable and unique string identifier for the expression to be used
to identify a unique copy of cache for the current expression from all
cache files (or in-memory elements). If not provided, an MD5 digest of the
<a href="base.html#topic+deparse">deparse</a>d expression will be used, which means if the expression does not
change (changes in comments or white spaces do not matter), the <code>id</code> will
remain the same. This may not be a good default is two identical
expressions are cached under the same <code>path</code>, because they could overwrite
each other's cache when one expression's cache is invalidated, which may or
may not be what you want. If you do not want that to happen, you need to
manually provide an <code>id</code>.</p>
</td></tr>
<tr><td><code id="cache_exec_+3A_...">...</code></td>
<td>
<p>More arguments to control the behavior of caching (see
&lsquo;Details&rsquo;).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Arguments supported in <code>...</code> include:
</p>

<ul>
<li> <p><code>vars</code>: Names of local variables (which are created inside the expression).
By default, local variables are automatically detected from the expression
via <code><a href="codetools.html#topic+codetools">codetools::findLocalsList()</a></code>. Locally created variables are cached along
with the value of the expression.
</p>
</li>
<li> <p><code>hash</code> and <code>extra</code>: R objects to be used to determine if cache should be
loaded or invalidated. If (the MD5 hash of) the objects is not changed, the
cache is loaded, otherwise the cache is invalidated and rebuilt. By default,
<code>hash</code> is a list of values of global variables in the expression (i.e.,
variables created outside the expression). Global variables are automatically
detected by <code><a href="codetools.html#topic+findGlobals">codetools::findGlobals()</a></code>. You can provide a vector of names to
override the automatic detection if you want some specific global variables
to affect caching, or the automatic detection is not reliable. You can also
provide additional information via the <code>extra</code> argument. For example, if the
expression reads an external file <code>foo.csv</code>, and you want the cache to be
invalidated after the file is modified, you may use <code>extra = file.mtime("foo.csv")</code>.
</p>
</li>
<li> <p><code>keep</code>: By default, only one copy of the cache corresponding to an <code>id</code>
under <code>path</code> is kept, and all other copies for this <code>id</code> is automaitcally
purged. If <code>TRUE</code>, all copies of the cache are kept. If <code>FALSE</code>, all copies
are removed, which means the cache is <em>always</em> invalidated, and can be useful
to force re-executing the expression.
</p>
</li>
<li> <p><code>rw</code>: A list of functions to read/write the cache files. The list is of the
form <code>list(load = function(file) {}, save = function(x, file) {})</code>. By
default, <code><a href="base.html#topic+readRDS">readRDS()</a></code> and <code><a href="base.html#topic+saveRDS">saveRDS()</a></code> are used. This argument can also take a
character string to use some built-in read/write methods. Currently available
methods include <code>rds</code> (the default), <code>raw</code> (using <code><a href="base.html#topic+serialize">serialize()</a></code> and
<code><a href="base.html#topic+unserialize">unserialize()</a></code>), and <code>qs</code> (using <code><a href="qs.html#topic+qread">qs::qread()</a></code> and <code><a href="qs.html#topic+qsave">qs::qsave()</a></code>). The <code>rds</code>
and <code>raw</code> methods only use base R functions (the <code>rds</code> method generates
smaller files because it uses compression, but is often slower than the <code>raw</code>
method, which does not use compression). The <code>qs</code> method requires the
<span class="pkg">qs</span> package, which can be much faster than base R methods and also
supports compression.
</p>
</li></ul>



<h3>Value</h3>

<p>If the cache is found, the cached value of the expression will be
loaded and returned (other local variables will also be lazy-loaded into
the current environment as a side-effect). If cache does not exist, the
expression is executed and its value is returned.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># the first run takes about 1 second
y1 = xfun::cache_exec({
    x = rnorm(1e+05)
    Sys.sleep(1)
    x
}, path = ":memory:", id = "sim-norm")

# the second run takes almost no time
y2 = xfun::cache_exec({
    # comments won't affect caching
    x = rnorm(1e+05)
    Sys.sleep(1)
    x
}, path = ":memory:", id = "sim-norm")

# y1, y2, and x should be identical
stopifnot(identical(y1, y2), identical(y1, x))
</code></pre>

<hr>
<h2 id='cache_rds'>Cache the value of an R expression to an RDS file</h2><span id='topic+cache_rds'></span>

<h3>Description</h3>

<p>Save the value of an expression to a cache file (of the RDS format). Next
time the value is loaded from the file if it exists.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cache_rds(
  expr = {
 },
  rerun = FALSE,
  file = "cache.rds",
  dir = "cache/",
  hash = NULL,
  clean = getOption("xfun.cache_rds.clean", TRUE),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cache_rds_+3A_expr">expr</code></td>
<td>
<p>An R expression.</p>
</td></tr>
<tr><td><code id="cache_rds_+3A_rerun">rerun</code></td>
<td>
<p>Whether to delete the RDS file, rerun the expression, and save
the result again (i.e., invalidate the cache if it exists).</p>
</td></tr>
<tr><td><code id="cache_rds_+3A_file">file</code></td>
<td>
<p>The <em>base</em> (see Details) cache filename under the directory
specified by the <code>dir</code> argument. If not specified and this function is
called inside a code chunk of a <span class="pkg">knitr</span> document (e.g., an R Markdown
document), the default is the current chunk label plus the extension
&lsquo;<span class="file">.rds</span>&rsquo;.</p>
</td></tr>
<tr><td><code id="cache_rds_+3A_dir">dir</code></td>
<td>
<p>The path of the RDS file is partially determined by <code>paste0(dir, file)</code>. If not specified and the <span class="pkg">knitr</span> package is available, the
default value of <code>dir</code> is the <span class="pkg">knitr</span> chunk option <code>cache.path</code> (so if
you are compiling a <span class="pkg">knitr</span> document, you do not need to provide this
<code>dir</code> argument explicitly), otherwise the default is &lsquo;<span class="file">cache/</span>&rsquo;. If you
do not want to provide a <code>dir</code> but simply a valid path to the <code>file</code>
argument, you may use <code>dir = ""</code>.</p>
</td></tr>
<tr><td><code id="cache_rds_+3A_hash">hash</code></td>
<td>
<p>A <code>list</code> object that contributes to the MD5 hash of the cache
filename (see Details). It can also take a special character value
<code>"auto"</code>. Other types of objects are ignored.</p>
</td></tr>
<tr><td><code id="cache_rds_+3A_clean">clean</code></td>
<td>
<p>Whether to clean up the old cache files automatically when
<code>expr</code> has changed.</p>
</td></tr>
<tr><td><code id="cache_rds_+3A_...">...</code></td>
<td>
<p>Other arguments to be passed to <code><a href="base.html#topic+saveRDS">saveRDS()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that the <code>file</code> argument does not provide the full cache filename. The
actual name of the cache file is of the form &lsquo;<span class="file">BASENAME_HASH.rds</span>&rsquo;, where
&lsquo;<span class="file">BASENAME</span>&rsquo; is the base name provided via the &lsquo;<span class="file">file</span>&rsquo; argument (e.g.,
if <code>file = 'foo.rds'</code>, <code>BASENAME</code> would be &lsquo;<span class="file">foo</span>&rsquo;), and &lsquo;<span class="file">HASH</span>&rsquo; is
the MD5 hash (also called the &lsquo;checksum&rsquo;) calculated from the R code
provided to the <code>expr</code> argument and the value of the <code>hash</code> argument, which
means when the code or the <code>hash</code> argument changes, the &lsquo;<span class="file">HASH</span>&rsquo; string
may also change, and the old cache will be invalidated (if it exists). If you
want to find the cache file, look for &lsquo;<span class="file">.rds</span>&rsquo; files that contain 32
hexadecimal digits (consisting of 0-9 and a-z) at the end of the filename.
</p>
<p>The possible ways to invalidate the cache are: 1) change the code in <code>expr</code>
argument; 2) delete the cache file manually or automatically through the
argument <code>rerun = TRUE</code>; and 3) change the value of the <code>hash</code> argument. The
first two ways should be obvious. For the third way, it makes it possible to
automatically invalidate the cache based on changes in certain R objects. For
example, when you run <code>cache_rds({ x + y })</code>, you may want to invalidate the
cache to rerun <code>{ x + y }</code> when the value of <code>x</code> or <code>y</code> has been changed, and
you can tell <code>cache_rds()</code> to do so by <code>cache_rds({ x + y }, hash = list(x, y))</code>. The value of the argument <code>hash</code> is expected to be a list, but it can
also take a special value, <code>"auto"</code>, which means <code>cache_rds(expr)</code> will try
to automatically figure out the global variables in <code>expr</code>, return a list of
their values, and use this list as the actual value of <code>hash</code>. This behavior
is most likely to be what you really want: if the code in <code>expr</code> uses an
external global variable, you may want to invalidate the cache if the value
of the global variable has changed. Here a &ldquo;global variable&rdquo; means a
variable not created locally in <code>expr</code>, e.g., for <code>cache_rds({ x &lt;- 1; x + y })</code>, <code>x</code> is a local variable, and <code>y</code> is (most likely to be) a global
variable, so changes in <code>y</code> should invalidate the cache. However, you know
your own code the best. If you want to be completely sure when to invalidate
the cache, you can always provide a list of objects explicitly rather than
relying on <code>hash = "auto"</code>.
</p>
<p>By default (the argument <code>clean = TRUE</code>), old cache files will be
automatically cleaned up. Sometimes you may want to use <code>clean = FALSE</code> (set
the R global option <code>options(xfun.cache_rds.clean = FALSE)</code> if you want
<code>FALSE</code> to be the default). For example, you may not have decided which
version of code to use, and you can keep the cache of both versions with
<code>clean = FALSE</code>, so when you switch between the two versions of code, it will
still be fast to run the code.
</p>


<h3>Value</h3>

<p>If the cache file does not exist, run the expression and save the
result to the file, otherwise read the cache file and return the value.
</p>


<h3>Note</h3>

<p>Changes in the code in the <code>expr</code> argument do not necessarily always
invalidate the cache, if the changed code is <code><a href="base.html#topic+parse">parse</a></code><code>d</code> to the same
expression as the previous version of the code. For example, if you have
run <code>cache_rds({Sys.sleep(5);1+1})</code> before, running <code>cache_rds({ Sys.sleep( 5 ) ; 1 + 1 })</code> will use the cache, because the two expressions are
essentially the same (they only differ in white spaces). Usually you can
add/delete white spaces or comments to your code in <code>expr</code> without
invalidating the cache. See the package vignette <code>vignette('xfun', package = 'xfun')</code> for more examples.
</p>
<p>When this function is called in a code chunk of a <span class="pkg">knitr</span> document, you
may not want to provide the filename or directory of the cache file,
because they have reasonable defaults.
</p>
<p>Side-effects (such as plots or printed output) will not be cached. The
cache only stores the last value of the expression in <code>expr</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cache_exec">cache_exec()</a></code>, which is more flexible (e.g., it supports in-memory
caching and different read/write methods for cache files).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>f = tempfile()  # the cache file
compute = function(...) {
    res = xfun::cache_rds({
        Sys.sleep(1)
        1:10
    }, file = f, dir = "", ...)
    res
}
compute()  # takes one second
compute()  # returns 1:10 immediately
compute()  # fast again
compute(rerun = TRUE)  # one second to rerun
compute()
unlink(paste0(f, "_*.rds"))
</code></pre>

<hr>
<h2 id='crandalf_check'>Submit check jobs to crandalf</h2><span id='topic+crandalf_check'></span><span id='topic+crandalf_results'></span>

<h3>Description</h3>

<p>Check the reverse dependencies of a package using the crandalf service:
<a href="https://github.com/yihui/crandalf">https://github.com/yihui/crandalf</a>. If the number of reverse
dependencies is large, they will be split into batches and pushed to crandalf
one by one.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>crandalf_check(pkg, size = 400, jobs = Inf, which = "all")

crandalf_results(pkg, repo = NA, limit = 200, wait = 5 * 60)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="crandalf_check_+3A_pkg">pkg</code></td>
<td>
<p>The package name of which the reverse dependencies are to be
checked.</p>
</td></tr>
<tr><td><code id="crandalf_check_+3A_size">size</code></td>
<td>
<p>The number of reverse dependencies to be checked in each job.</p>
</td></tr>
<tr><td><code id="crandalf_check_+3A_jobs">jobs</code></td>
<td>
<p>The number of jobs to run in GitHub Actions (by default, all jobs
are submitted, but you can choose to submit the first few jobs).</p>
</td></tr>
<tr><td><code id="crandalf_check_+3A_which">which</code></td>
<td>
<p>The type of dependencies (see <code><a href="#topic+rev_check">rev_check()</a></code>).</p>
</td></tr>
<tr><td><code id="crandalf_check_+3A_repo">repo</code></td>
<td>
<p>The crandalf repo on GitHub (of the form <code>user/repo</code> such as
<code>"yihui/crandalf"</code>). Usually you do not need to specify it, unless you
are not calling this function inside the crandalf project, because
<code>gh</code> should be able to figure out the repo automatically.</p>
</td></tr>
<tr><td><code id="crandalf_check_+3A_limit">limit</code></td>
<td>
<p>The maximum of records for <code>gh run list</code> to retrieve.
You only need a larger number if the check results are very early in the
GitHub Action history.</p>
</td></tr>
<tr><td><code id="crandalf_check_+3A_wait">wait</code></td>
<td>
<p>Number of seconds to wait if not all jobs have been completed on
GitHub. By default, this function checks the status every 5 minutes until
all jobs are completed. Set <code>wait</code> to 0 to disable waiting (and throw
an error immediately when any jobs are not completed).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Due to the time limit of a single job on GitHub Actions (6 hours), you will
have to split the large number of reverse dependencies into batches and check
them sequentially on GitHub (at most 5 jobs in parallel). The function
<code>crandalf_check()</code> does this automatically when necessary. It requires
the <code>git</code> command to be available.
</p>
<p>The function <code>crandalf_results()</code> fetches check results from GitHub
after all checks are completed, merge the results, and show a full summary of
check results. It requires <code>gh</code> (GitHub CLI:
<a href="https://cli.github.com/manual/">https://cli.github.com/manual/</a>) to be installed and you also need to
authenticate with your GitHub account beforehand.
</p>

<hr>
<h2 id='csv_options'>Parse comma-separated chunk options</h2><span id='topic+csv_options'></span>

<h3>Description</h3>

<p>For <span class="pkg">knitr</span> and R Markdown documents, code chunk options can be written
using the comma-separated syntax (e.g., <code style="white-space: pre;">&#8288;opt1=value1, opt2=value2&#8288;</code>). This
function parses these options and returns a list. If an option is not named,
it will be treated as the chunk label.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>csv_options(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="csv_options_+3A_x">x</code></td>
<td>
<p>The chunk options as a string.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of chunk options.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>xfun::csv_options("foo, eval=TRUE, fig.width=5, echo=if (TRUE) FALSE")
</code></pre>

<hr>
<h2 id='decimal_dot'>Evaluate an expression after forcing the decimal point to be a dot</h2><span id='topic+decimal_dot'></span>

<h3>Description</h3>

<p>Sometimes it is necessary to use the dot character as the decimal separator.
In R, this could be affected by two settings: the global option
<code>options(OutDec)</code> and the <code>LC_NUMERIC</code> locale. This function sets the former
to <code>.</code> and the latter to <code>C</code> before evaluating an expression, such as
coercing a number to character.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>decimal_dot(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="decimal_dot_+3A_x">x</code></td>
<td>
<p>An expression.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The value of <code>x</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>opts = options(OutDec = ",")
as.character(1.234)  # using ',' as the decimal separator
print(1.234)  # same
xfun::decimal_dot(as.character(1.234))  # using dot
xfun::decimal_dot(print(1.234))  # using dot
options(opts)
</code></pre>

<hr>
<h2 id='del_empty_dir'>Delete an empty directory</h2><span id='topic+del_empty_dir'></span>

<h3>Description</h3>

<p>Use <code>list.file()</code> to check if there are any files or subdirectories
under a directory. If not, delete this empty directory.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>del_empty_dir(dir)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="del_empty_dir_+3A_dir">dir</code></td>
<td>
<p>Path to a directory. If <code>NULL</code> or the directory does not
exist, no action will be performed.</p>
</td></tr>
</table>

<hr>
<h2 id='dir_create'>Create a directory recursively by default</h2><span id='topic+dir_create'></span>

<h3>Description</h3>

<p>First check if a directory exists. If it does, return <code>TRUE</code>, otherwise
create it with <code><a href="base.html#topic+dir.create">dir.create</a></code><code>(recursive = TRUE)</code> by default.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dir_create(x, recursive = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dir_create_+3A_x">x</code></td>
<td>
<p>A path name.</p>
</td></tr>
<tr><td><code id="dir_create_+3A_recursive">recursive</code></td>
<td>
<p>Whether to create all directory components in the path.</p>
</td></tr>
<tr><td><code id="dir_create_+3A_...">...</code></td>
<td>
<p>Other arguments to be passed to <code><a href="base.html#topic+dir.create">dir.create()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical value indicating if the directory either exists or is
successfully created.
</p>

<hr>
<h2 id='dir_exists'>Test the existence of files and directories</h2><span id='topic+dir_exists'></span><span id='topic+file_exists'></span>

<h3>Description</h3>

<p>These are wrapper functions of [<code style="white-space: pre;">&#8288;utils::file_test()]&#8288;</code> to test the
existence of directories and files. Note that <code>file_exists()</code> only tests
files but not directories, which is the main difference between
<code><a href="base.html#topic+file.exists">file.exists()</a></code> in base R. If you use are using the R version
3.2.0 or above, <code>dir_exists()</code> is the same as <code><a href="base.html#topic+dir.exists">dir.exists()</a></code>
in base R.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dir_exists(x)

file_exists(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dir_exists_+3A_x">x</code></td>
<td>
<p>A vector of paths.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical vector.
</p>

<hr>
<h2 id='divide_chunk'>Divide chunk options from the code chunk body</h2><span id='topic+divide_chunk'></span>

<h3>Description</h3>

<p>Chunk options can be written in special comments (e.g., after <code style="white-space: pre;">&#8288;#|&#8288;</code> for R code
chunks) inside a code chunk. This function partitions these options from the
chunk body.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>divide_chunk(engine, code)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="divide_chunk_+3A_engine">engine</code></td>
<td>
<p>The name of the language engine (to determine the appropriate
comment character).</p>
</td></tr>
<tr><td><code id="divide_chunk_+3A_code">code</code></td>
<td>
<p>A character vector (lines of code).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following items:
</p>

<ul>
<li> <p><code>options</code>: The parsed options (if there are any) as a list.
</p>
</li>
<li> <p><code>src</code>: The part of the input that contains the options.
</p>
</li>
<li> <p><code>code</code>: The part of the input that contains the code.
</p>
</li></ul>



<h3>Note</h3>

<p>Chunk options must be written on <em>continuous</em> lines (i.e., all lines
must start with the special comment prefix such as <code style="white-space: pre;">&#8288;#|&#8288;</code>) at the beginning
of the chunk body.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># parse yaml-like items
yaml_like = c("#| label: mine", "#| echo: true", "#| fig.width: 8", "#| foo: bar",
    "1 + 1")
writeLines(yaml_like)
xfun::divide_chunk("r", yaml_like)

# parse CSV syntax
csv_like = c("#| mine, echo = TRUE, fig.width = 8, foo = 'bar'", "1 + 1")
writeLines(csv_like)
xfun::divide_chunk("r", csv_like)
</code></pre>

<hr>
<h2 id='do_once'>Perform a task once in an R session</h2><span id='topic+do_once'></span>

<h3>Description</h3>

<p>Perform a task once in an R session, e.g., emit a message or warning. Then
give users an optional hint on how not to perform this task at all.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>do_once(
  task,
  option,
  hint = c("You will not see this message again in this R session.",
    "If you never want to see this message,",
    sprintf("you may set options(%s = FALSE) in your .Rprofile.", option))
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="do_once_+3A_task">task</code></td>
<td>
<p>Any R code expression to be evaluated once to perform a task,
e.g., <code>warning('Danger!')</code> or <code>message('Today is ', Sys.Date())</code>.</p>
</td></tr>
<tr><td><code id="do_once_+3A_option">option</code></td>
<td>
<p>An R option name. This name should be as unique as possible in
<code><a href="base.html#topic+options">options()</a></code>. After the task has been successfully performed,
this option will be set to <code>FALSE</code> in the current R session, to
prevent the task from being performed again the next time when
<code>do_once()</code> is called.</p>
</td></tr>
<tr><td><code id="do_once_+3A_hint">hint</code></td>
<td>
<p>A character vector to provide a hint to users on how not to
perform the task or see the message again in the current R session. Set
<code>hint = ""</code> if you do not want to provide the hint.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The value returned by the <code>task</code>, invisibly.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>do_once(message("Today's date is ", Sys.Date()), "xfun.date.reminder")
# if you run it again, it will not emit the message again
do_once(message("Today's date is ", Sys.Date()), "xfun.date.reminder")

do_once({
    Sys.sleep(2)
    1 + 1
}, "xfun.task.1plus1")
do_once({
    Sys.sleep(2)
    1 + 1
}, "xfun.task.1plus1")
</code></pre>

<hr>
<h2 id='download_cache'>Download a file from a URL and cache it on disk</h2><span id='topic+download_cache'></span>

<h3>Description</h3>

<p>This object provides methods to download files and cache them on disk.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>download_cache
</code></pre>


<h3>Format</h3>

<p>A list of methods:
</p>

<ul>
<li> <p><code style="white-space: pre;">&#8288;$get(url, type, handler)&#8288;</code> downloads a URL, caches it, and returns the file
content according to the value of <code>type</code> (possible values: <code>"text"</code> means
the text content; <code>"base64"</code> means the base64 encoded data; <code>"raw"</code> means
the raw binary content; <code>"auto"</code> is the default and means the type is
determined by the content type in the URL headers). Optionally a <code>handler</code>
function can be applied to the content.
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;$list()&#8288;</code> gives the list of cache files.
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;$summary()&#8288;</code> gives a summary of existing cache files.
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;$remove(url, type)&#8288;</code> removes a single cache file.
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;$purge()&#8288;</code> deletes all cache files.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
# the first time it may take a few seconds
x1 = xfun::download_cache$get("https://www.r-project.org/")
head(x1)

# now you can get the cached content
x2 = xfun::download_cache$get("https://www.r-project.org/")
identical(x1, x2)  # TRUE

# a binary file
x3 = xfun::download_cache$get("https://yihui.org/images/logo.png", "raw")
length(x3)

# show a summary
xfun::download_cache$summary()
# remove a specific cache file
xfun::download_cache$remove("https://yihui.org/images/logo.png", "raw")
# remove all cache files
xfun::download_cache$purge()

</code></pre>

<hr>
<h2 id='download_file'>Try various methods to download a file</h2><span id='topic+download_file'></span>

<h3>Description</h3>

<p>Try all possible methods in <code><a href="utils.html#topic+download.file">download.file()</a></code> (e.g.,
<code>libcurl</code>, <code>curl</code>, <code>wget</code>, and <code>wininet</code>) and see if any
method can succeed. The reason to enumerate all methods is that sometimes the
default method does not work, e.g.,
<a href="https://stat.ethz.ch/pipermail/r-devel/2016-June/072852.html">https://stat.ethz.ch/pipermail/r-devel/2016-June/072852.html</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>download_file(
  url,
  output = url_filename(url),
  ...,
  .error = "No download method works (auto/wininet/wget/curl/lynx)"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="download_file_+3A_url">url</code></td>
<td>
<p>The URL of the file.</p>
</td></tr>
<tr><td><code id="download_file_+3A_output">output</code></td>
<td>
<p>Path to the output file. By default, it is determined by
<code><a href="#topic+url_filename">url_filename()</a></code>.</p>
</td></tr>
<tr><td><code id="download_file_+3A_...">...</code></td>
<td>
<p>Other arguments to be passed to <code><a href="utils.html#topic+download.file">download.file()</a></code>
(except <code>method</code>).</p>
</td></tr>
<tr><td><code id="download_file_+3A_.error">.error</code></td>
<td>
<p>An error message to signal when the download fails.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The integer code <code>0</code> for success, or an error if none of the
methods work.
</p>


<h3>Note</h3>

<p>To allow downloading large files, the <code>timeout</code> option in
<code><a href="base.html#topic+options">options()</a></code> will be temporarily set to one hour (3600 seconds)
inside this function when this option has the default value of 60 seconds.
If you want a different <code>timeout</code> value, you may set it via
<code>options(timeout = N)</code>, where <code>N</code> is the number of seconds (not
60).
</p>

<hr>
<h2 id='embed_file'>Embed a file, multiple files, or directory on an HTML page</h2><span id='topic+embed_file'></span><span id='topic+embed_dir'></span><span id='topic+embed_files'></span>

<h3>Description</h3>

<p>For a file, first encode it into base64 data (a character string). Then
generate a hyperlink of the form &lsquo;<span class="samp">&#8288;&lt;a href="base64 data"
download="filename"&gt;Download filename&lt;/a&gt;&#8288;</span>&rsquo;. The file can be downloaded when
the link is clicked in modern web browsers. For a directory, it will be
compressed as a zip archive first, and the zip file is passed to
<code>embed_file()</code>. For multiple files, they are also compressed to a zip
file first.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>embed_file(path, name = basename(path), text = paste("Download", name), ...)

embed_dir(path, name = paste0(normalize_path(path), ".zip"), ...)

embed_files(path, name = with_ext(basename(path[1]), ".zip"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="embed_file_+3A_path">path</code></td>
<td>
<p>Path to the file(s) or directory.</p>
</td></tr>
<tr><td><code id="embed_file_+3A_name">name</code></td>
<td>
<p>The default filename to use when downloading the file. Note that
for <code>embed_dir()</code>, only the base name (of the zip filename) will be
used.</p>
</td></tr>
<tr><td><code id="embed_file_+3A_text">text</code></td>
<td>
<p>The text for the hyperlink.</p>
</td></tr>
<tr><td><code id="embed_file_+3A_...">...</code></td>
<td>
<p>For <code>embed_file()</code>, additional arguments to be passed to
<code>htmltools::a()</code> (e.g., <code>class = 'foo'</code>). For <code>embed_dir()</code>
and <code>embed_files()</code>, arguments passed to <code>embed_file()</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions can be called in R code chunks in R Markdown documents with
HTML output formats. You may embed an arbitrary file or directory in the HTML
output file, so that readers of the HTML page can download it from the
browser. A common use case is to embed data files for readers to download.
</p>


<h3>Value</h3>

<p>An HTML tag &lsquo;<span class="samp">&#8288;&lt;a&gt;&#8288;</span>&rsquo; with the appropriate attributes.
</p>


<h3>Note</h3>

<p>Windows users may need to install Rtools to obtain the <code>zip</code>
command to use <code>embed_dir()</code> and <code>embed_files()</code>.
</p>
<p>These functions require R packages <span class="pkg">mime</span> and <span class="pkg">htmltools</span>. If you
have installed the <span class="pkg">rmarkdown</span> package, these packages should be
available, otherwise you need to install them separately.
</p>
<p>Currently Internet Explorer does not support downloading embedded files
(<a href="https://caniuse.com/#feat=download">https://caniuse.com/#feat=download</a>). Chrome has a 2MB limit on the
file size.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>logo = xfun:::R_logo()
link = xfun::embed_file(logo, text = "Download R logo")
link
if (interactive()) htmltools::browsable(link)
</code></pre>

<hr>
<h2 id='env_option'>Retrieve a global option from both <code>options()</code> and environment variables</h2><span id='topic+env_option'></span>

<h3>Description</h3>

<p>If the option exists in <code><a href="base.html#topic+options">options()</a></code>, use its value. If not, query the
environment variable with the name <code>R_NAME</code> where <code>NAME</code> is the capitalized
option name with dots substituted by underscores. For example, for an option
<code>xfun.foo</code>, first we try <code>getOption('xfun.foo')</code>; if it does not exist, we
check the environment variable <code>R_XFUN_FOO</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>env_option(name, default = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="env_option_+3A_name">name</code></td>
<td>
<p>The option name.</p>
</td></tr>
<tr><td><code id="env_option_+3A_default">default</code></td>
<td>
<p>The default value if the option is not found in <code><a href="base.html#topic+options">options()</a></code> or
environment variables.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This provides two possible ways, whichever is more convenient, for users to
set an option. For example, global options can be set in the <a href="base.html#topic+.Rprofile">.Rprofile</a>
file, and environment variables can be set in the <a href="base.html#topic+.Renviron">.Renviron</a> file.
</p>


<h3>Value</h3>

<p>The option value.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>xfun::env_option("xfun.test.option")  # NULL

Sys.setenv(R_XFUN_TEST_OPTION = "1234")
xfun::env_option("xfun.test.option")  # 1234

options(xfun.test.option = TRUE)
xfun::env_option("xfun.test.option")  # TRUE (from options())
options(xfun.test.option = NULL)  # reset the option
xfun::env_option("xfun.test.option")  # 1234 (from env var)

Sys.unsetenv("R_XFUN_TEST_OPTION")
xfun::env_option("xfun.test.option")  # NULL again

xfun::env_option("xfun.test.option", FALSE)  # use default
</code></pre>

<hr>
<h2 id='existing_files'>Find file paths that exist</h2><span id='topic+existing_files'></span>

<h3>Description</h3>

<p>This is a shorthand of <code>x[file.exists(x)]</code>, and optionally returns the
first existing file path.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>existing_files(x, first = FALSE, error = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="existing_files_+3A_x">x</code></td>
<td>
<p>A vector of file paths.</p>
</td></tr>
<tr><td><code id="existing_files_+3A_first">first</code></td>
<td>
<p>Whether to return the first existing path. If <code>TRUE</code> and no
specified files exist, it will signal an error unless the argument
<code>error = FALSE</code>.</p>
</td></tr>
<tr><td><code id="existing_files_+3A_error">error</code></td>
<td>
<p>Whether to throw an error when <code>first = TRUE</code> but no files
exist. It can also take a character value, which will be used as the error
message.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of existing file paths.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>xfun::existing_files(c("foo.txt", system.file("DESCRIPTION", package = "xfun")))
</code></pre>

<hr>
<h2 id='exit_call'>Call <code>on.exit()</code> in a parent function</h2><span id='topic+exit_call'></span>

<h3>Description</h3>

<p>The function <code><a href="base.html#topic+on.exit">on.exit()</a></code> is often used to perform tasks when the
current function exits. This <code>exit_call()</code> function allows calling a
function when a parent function exits (thinking of it as inserting an
<code>on.exit()</code> call into the parent function).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>exit_call(fun, n = 2, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="exit_call_+3A_fun">fun</code></td>
<td>
<p>A function to be called when the parent function exits.</p>
</td></tr>
<tr><td><code id="exit_call_+3A_n">n</code></td>
<td>
<p>The parent frame number. For <code>n = 1</code>, <code>exit_call(fun)</code> is
the same as <code>on.exit(fun())</code>; <code>n = 2</code> means adding
<code>on.exit(fun())</code> in the parent function; <code>n = 3</code> means the
grandparent, etc.</p>
</td></tr>
<tr><td><code id="exit_call_+3A_...">...</code></td>
<td>
<p>Other arguments to be passed to <code>on.exit()</code>.</p>
</td></tr>
</table>


<h3>References</h3>

<p>This function was inspired by Kevin Ushey:
<a href="https://yihui.org/en/2017/12/on-exit-parent/">https://yihui.org/en/2017/12/on-exit-parent/</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>f = function(x) {
    print(x)
    xfun::exit_call(function() print("The parent function is exiting!"))
}
g = function(y) {
    f(y)
    print("f() has been called!")
}
g("An argument of g()!")
</code></pre>

<hr>
<h2 id='fenced_block'>Create a fenced block in Markdown</h2><span id='topic+fenced_block'></span><span id='topic+fenced_div'></span><span id='topic+make_fence'></span>

<h3>Description</h3>

<p>Wrap content with fence delimiters such as backticks (code blocks) or colons
(fenced Div). Optionally the fenced block can have attributes. The function
<code>fenced_div()</code> is a shorthand of <code>fenced_block(char = ':')</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fenced_block(x, attrs = NULL, fence = make_fence(x, char), char = "`")

fenced_div(...)

make_fence(x, char = "`")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fenced_block_+3A_x">x</code></td>
<td>
<p>A character vector of the block content.</p>
</td></tr>
<tr><td><code id="fenced_block_+3A_attrs">attrs</code></td>
<td>
<p>A vector of block attributes.</p>
</td></tr>
<tr><td><code id="fenced_block_+3A_fence">fence</code></td>
<td>
<p>The fence string, e.g., <code>:::</code> or <code style="white-space: pre;">&#8288;```&#8288;</code>. This will be
generated from the <code>char</code> argument by default.</p>
</td></tr>
<tr><td><code id="fenced_block_+3A_char">char</code></td>
<td>
<p>The fence character to be used to generate the fence string by
default.</p>
</td></tr>
<tr><td><code id="fenced_block_+3A_...">...</code></td>
<td>
<p>Arguments to be passed to <code>fenced_block()</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>fenced_block()</code> returns a character vector that contains both the
fences and content.
</p>
<p><code>make_fence()</code> returns a character string. If the block content
contains <code>N</code> fence characters (e.g., backticks), use <code>N + 1</code> characters as
the fence.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># code block with class 'r' and ID 'foo'
xfun::fenced_block("1+1", c(".r", "#foo"))
# fenced Div
xfun::fenced_block("This is a **Div**.", char = ":")
# three backticks by default
xfun::make_fence("1+1")
# needs five backticks for the fences because content has four
xfun::make_fence(c("````r", "1+1", "````"))
</code></pre>

<hr>
<h2 id='file_ext'>Manipulate filename extensions</h2><span id='topic+file_ext'></span><span id='topic+sans_ext'></span><span id='topic+with_ext'></span>

<h3>Description</h3>

<p>Functions to obtain (<code>file_ext()</code>), remove (<code>sans_ext()</code>), and
change (<code>with_ext()</code>) extensions in filenames.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>file_ext(x, extra = "")

sans_ext(x, extra = "")

with_ext(x, ext, extra = "")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="file_ext_+3A_x">x</code></td>
<td>
<p>A character of file paths.</p>
</td></tr>
<tr><td><code id="file_ext_+3A_extra">extra</code></td>
<td>
<p>Extra characters to be allowed in the extensions. By default,
only alphanumeric characters are allowed (and also some special cases in
&lsquo;Details&rsquo;). If other characters should be allowed, they can be
specified in a character string, e.g., <code>"-+!_#"</code>.</p>
</td></tr>
<tr><td><code id="file_ext_+3A_ext">ext</code></td>
<td>
<p>A vector of new extensions. It must be either of length 1, or the
same length as <code>x</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>file_ext()</code> is similar to <code><a href="tools.html#topic+fileutils">tools::file_ext()</a></code>, and
<code>sans_ext()</code> is similar to <code><a href="tools.html#topic+fileutils">tools::file_path_sans_ext()</a></code>.
The main differences are that they treat <code>tar.(gz|bz2|xz)</code> and
<code>nb.html</code> as extensions (but functions in the <span class="pkg">tools</span> package
doesn't allow double extensions by default), and allow characters <code>~</code>
and <code style="white-space: pre;">&#8288;#&#8288;</code> to be present at the end of a filename.
</p>


<h3>Value</h3>

<p>A character vector of the same length as <code>x</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(xfun)
p = c("abc.doc", "def123.tex", "path/to/foo.Rmd", "backup.ppt~", "pkg.tar.xz")
file_ext(p)
sans_ext(p)
with_ext(p, ".txt")
with_ext(p, c(".ppt", ".sty", ".Rnw", "doc", "zip"))
with_ext(p, "html")

# allow for more characters in extensions
p = c("a.c++", "b.c--", "c.e##")
file_ext(p)  # -/+/# not recognized by default
file_ext(p, extra = "-+#")
</code></pre>

<hr>
<h2 id='file_string'>Read a text file and concatenate the lines by <code>'\n'</code></h2><span id='topic+file_string'></span>

<h3>Description</h3>

<p>The source code of this function should be self-explanatory.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>file_string(file)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="file_string_+3A_file">file</code></td>
<td>
<p>Path to a text file (should be encoded in UTF-8).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character string of text lines concatenated by <code>'\n'</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>xfun::file_string(system.file("DESCRIPTION", package = "xfun"))
</code></pre>

<hr>
<h2 id='format_bytes'>Format numbers of bytes using a specified unit</h2><span id='topic+format_bytes'></span>

<h3>Description</h3>

<p>Call the S3 method <code>format.object_size()</code> to format numbers of bytes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>format_bytes(x, units = "auto", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="format_bytes_+3A_x">x</code></td>
<td>
<p>A numeric vector (each element represents a number of bytes).</p>
</td></tr>
<tr><td><code id="format_bytes_+3A_units">units</code>, <code id="format_bytes_+3A_...">...</code></td>
<td>
<p>Passed to <code><a href="utils.html#topic+format.object_size">format()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>xfun::format_bytes(c(1, 1024, 2000, 1e+06, 2e+08))
xfun::format_bytes(c(1, 1024, 2000, 1e+06, 2e+08), units = "KB")
</code></pre>

<hr>
<h2 id='from_root'>Get the relative path of a path in a project relative to the current working
directory</h2><span id='topic+from_root'></span>

<h3>Description</h3>

<p>First compose an absolute path using the project root directory and the
relative path components, i.e., <code><a href="base.html#topic+file.path">file.path</a></code><code style="white-space: pre;">&#8288;(root, ...)&#8288;</code>. Then
convert it to a relative path with <code><a href="#topic+relative_path">relative_path()</a></code>, which is
relative to the current working directory.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>from_root(..., root = proj_root(), error = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="from_root_+3A_...">...</code></td>
<td>
<p>A character vector of path components <em>relative to the root
directory of the project</em>.</p>
</td></tr>
<tr><td><code id="from_root_+3A_root">root</code></td>
<td>
<p>The root directory of the project.</p>
</td></tr>
<tr><td><code id="from_root_+3A_error">error</code></td>
<td>
<p>Whether to signal an error if the path cannot be converted to a
relative path.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function was inspired by <code>here::here()</code>, and the major difference
is that it returns a relative path by default, which is more portable.
</p>


<h3>Value</h3>

<p>A relative path, or an error when the project root directory cannot
be determined or the conversion failed and <code>error = TRUE</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
xfun::from_root("data", "mtcars.csv")

## End(Not run)
</code></pre>

<hr>
<h2 id='github_releases'>Get the tags of GitHub releases of a repository</h2><span id='topic+github_releases'></span>

<h3>Description</h3>

<p>Use the GitHub API (<code><a href="#topic+github_api">github_api()</a></code>) to obtain the tags of the
releases.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>github_releases(
  repo,
  tag = "",
  pattern = "v[0-9.]+",
  use_jsonlite = loadable("jsonlite")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="github_releases_+3A_repo">repo</code></td>
<td>
<p>The repository name of the form <code>user/repo</code>, e.g.,
<code>"yihui/xfun"</code>.</p>
</td></tr>
<tr><td><code id="github_releases_+3A_tag">tag</code></td>
<td>
<p>A tag as a character string. If provided, it will be returned if
the tag exists. If <code>tag = "latest"</code>, the tag of the latest release is
returned.</p>
</td></tr>
<tr><td><code id="github_releases_+3A_pattern">pattern</code></td>
<td>
<p>A regular expression to match the tags.</p>
</td></tr>
<tr><td><code id="github_releases_+3A_use_jsonlite">use_jsonlite</code></td>
<td>
<p>Whether to use <span class="pkg">jsonlite</span> to parse the releases info.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector of (GIT) tags.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
xfun::github_releases("yihui/xfun")
xfun::github_releases("gohugoio/hugo")

</code></pre>

<hr>
<h2 id='grep_sub'>Perform replacement with <code>gsub()</code> on elements matched from <code>grep()</code></h2><span id='topic+grep_sub'></span>

<h3>Description</h3>

<p>This function is a shorthand of <code>gsub(pattern, replacement, grep(pattern, x, value = TRUE))</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grep_sub(pattern, replacement, x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="grep_sub_+3A_pattern">pattern</code>, <code id="grep_sub_+3A_replacement">replacement</code>, <code id="grep_sub_+3A_x">x</code>, <code id="grep_sub_+3A_...">...</code></td>
<td>
<p>Passed to <code><a href="base.html#topic+grep">grep()</a></code> and
<code>gsub()</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># find elements that matches 'a[b]+c' and capitalize 'b' with perl regex
xfun::grep_sub("a([b]+)c", "a\\U\\1c", c("abc", "abbbc", "addc", "123"), perl = TRUE)
</code></pre>

<hr>
<h2 id='gsub_file'>Search and replace strings in files</h2><span id='topic+gsub_file'></span><span id='topic+gsub_files'></span><span id='topic+gsub_dir'></span><span id='topic+gsub_ext'></span>

<h3>Description</h3>

<p>These functions provide the &quot;file&quot; version of <code><a href="base.html#topic+gsub">gsub()</a></code>, i.e.,
they perform searching and replacement in files via <code>gsub()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gsub_file(file, ..., rw_error = TRUE)

gsub_files(files, ...)

gsub_dir(..., dir = ".", recursive = TRUE, ext = NULL, mimetype = ".*")

gsub_ext(ext, ..., dir = ".", recursive = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gsub_file_+3A_file">file</code></td>
<td>
<p>Path of a single file.</p>
</td></tr>
<tr><td><code id="gsub_file_+3A_...">...</code></td>
<td>
<p>For <code>gsub_file()</code>, arguments passed to <code>gsub()</code>. For
other functions, arguments passed to <code>gsub_file()</code>. Note that the
argument <code>x</code> of <code>gsub()</code> is the content of the file.</p>
</td></tr>
<tr><td><code id="gsub_file_+3A_rw_error">rw_error</code></td>
<td>
<p>Whether to signal an error if the file cannot be read or
written. If <code>FALSE</code>, the file will be ignored (with a warning).</p>
</td></tr>
<tr><td><code id="gsub_file_+3A_files">files</code></td>
<td>
<p>A vector of file paths.</p>
</td></tr>
<tr><td><code id="gsub_file_+3A_dir">dir</code></td>
<td>
<p>Path to a directory (all files under this directory will be
replaced).</p>
</td></tr>
<tr><td><code id="gsub_file_+3A_recursive">recursive</code></td>
<td>
<p>Whether to find files recursively under a directory.</p>
</td></tr>
<tr><td><code id="gsub_file_+3A_ext">ext</code></td>
<td>
<p>A vector of filename extensions (without the leading periods).</p>
</td></tr>
<tr><td><code id="gsub_file_+3A_mimetype">mimetype</code></td>
<td>
<p>A regular expression to filter files based on their MIME
types, e.g., <code>'^text/'</code> for plain text files. This requires the
<span class="pkg">mime</span> package.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>These functions perform in-place replacement, i.e., the files will be
overwritten. Make sure you backup your files in advance, or use version
control!
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(xfun)
f = tempfile()
writeLines(c("hello", "world"), f)
gsub_file(f, "world", "woRld", fixed = TRUE)
readLines(f)
</code></pre>

<hr>
<h2 id='in_dir'>Evaluate an expression under a specified working directory</h2><span id='topic+in_dir'></span>

<h3>Description</h3>

<p>Change the working directory, evaluate the expression, and restore the
working directory.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>in_dir(dir, expr)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="in_dir_+3A_dir">dir</code></td>
<td>
<p>Path to a directory.</p>
</td></tr>
<tr><td><code id="in_dir_+3A_expr">expr</code></td>
<td>
<p>An R expression.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>library(xfun)
in_dir(tempdir(), {
    print(getwd())
    list.files()
})
</code></pre>

<hr>
<h2 id='install_dir'>Install a source package from a directory</h2><span id='topic+install_dir'></span>

<h3>Description</h3>

<p>Run <code>R CMD build</code> to build a tarball from a source directory, and run
<code>R CMD INSTALL</code> to install it.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>install_dir(pkg, build = TRUE, build_opts = NULL, install_opts = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="install_dir_+3A_pkg">pkg</code></td>
<td>
<p>The package source directory.</p>
</td></tr>
<tr><td><code id="install_dir_+3A_build">build</code></td>
<td>
<p>Whether to build a tarball from the source directory. If
<code>FALSE</code>, run <code>R CMD INSTALL</code> on the directory directly (note
that vignettes will not be automatically built).</p>
</td></tr>
<tr><td><code id="install_dir_+3A_build_opts">build_opts</code></td>
<td>
<p>The options for <code>R CMD build</code>.</p>
</td></tr>
<tr><td><code id="install_dir_+3A_install_opts">install_opts</code></td>
<td>
<p>The options for <code>R CMD INSTALL</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Invisible status from <code>R CMD INSTALL</code>.
</p>

<hr>
<h2 id='install_github'>An alias of <code>remotes::install_github()</code></h2><span id='topic+install_github'></span>

<h3>Description</h3>

<p>This alias is to make autocomplete faster via <code>xfun::install_github</code>, because
most <code style="white-space: pre;">&#8288;remotes::install_*&#8288;</code> functions are never what I want. I only use
<code>install_github</code> and it is inconvenient to autocomplete it, e.g.
<code>install_git</code> always comes before <code>install_github</code>, but I never use it. In
RStudio, I only need to type <code>xfun::ig</code> to get <code>xfun::install_github</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>install_github(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="install_github_+3A_...">...</code></td>
<td>
<p>Arguments to be passed to <code><a href="remotes.html#topic+install_github">remotes::install_github()</a></code>.</p>
</td></tr>
</table>

<hr>
<h2 id='is_abs_path'>Test if paths are relative or absolute</h2><span id='topic+is_abs_path'></span><span id='topic+is_rel_path'></span>

<h3>Description</h3>

<p>On Unix, check if the paths start with &lsquo;<span class="file">/</span>&rsquo; or &lsquo;<span class="file">~</span>&rsquo; (if they do, they
are absolute paths). On Windows, check if a path remains the same (via
<code><a href="#topic+same_path">same_path()</a></code>) if it is prepended with &lsquo;<span class="file">./</span>&rsquo; (if it does, it is a
relative path).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_abs_path(x)

is_rel_path(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_abs_path_+3A_x">x</code></td>
<td>
<p>A vector of paths.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical vector.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>xfun::is_abs_path(c("C:/foo", "foo.txt", "/Users/john/", tempdir()))
xfun::is_rel_path(c("C:/foo", "foo.txt", "/Users/john/", tempdir()))
</code></pre>

<hr>
<h2 id='is_ascii'>Check if a character vector consists of entirely ASCII characters</h2><span id='topic+is_ascii'></span>

<h3>Description</h3>

<p>Converts the encoding of a character vector to <code>'ascii'</code>, and check if
the result is <code>NA</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_ascii(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_ascii_+3A_x">x</code></td>
<td>
<p>A character vector.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical vector indicating whether each element of the character
vector is ASCII.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(xfun)
is_ascii(letters)  # yes
is_ascii(intToUtf8(8212))  # no
</code></pre>

<hr>
<h2 id='is_blank'>Test if a character vector consists of blank strings</h2><span id='topic+is_blank'></span>

<h3>Description</h3>

<p>Return a logical vector indicating if elements of a character vector are
blank (white spaces or empty strings).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_blank(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_blank_+3A_x">x</code></td>
<td>
<p>A character vector.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>TRUE</code> for blank elements, or <code>FALSE</code> otherwise.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>xfun::is_blank("")
xfun::is_blank("abc")
xfun::is_blank(c("", "  ", "\n\t"))
xfun::is_blank(c("", " ", "abc"))
</code></pre>

<hr>
<h2 id='is_R_CMD_check'>Some utility functions for checking packages</h2><span id='topic+is_R_CMD_check'></span><span id='topic+is_CRAN_incoming'></span><span id='topic+check_package_name'></span><span id='topic+check_old_package'></span>

<h3>Description</h3>

<p>Miscellaneous utility functions to obtain information about the package
checking environment.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_R_CMD_check()

is_CRAN_incoming()

check_package_name()

check_old_package(name, version)
</code></pre>

<hr>
<h2 id='is_sub_path'>Test if a path is a subpath of a dir</h2><span id='topic+is_sub_path'></span>

<h3>Description</h3>

<p>Check if the path starts with the dir path.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_sub_path(x, dir, n = nchar(dir))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_sub_path_+3A_x">x</code></td>
<td>
<p>A vector of paths.</p>
</td></tr>
<tr><td><code id="is_sub_path_+3A_dir">dir</code></td>
<td>
<p>A vector of directory paths.</p>
</td></tr>
<tr><td><code id="is_sub_path_+3A_n">n</code></td>
<td>
<p>The length of <code>dir</code> paths.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical vector.
</p>


<h3>Note</h3>

<p>You may want to normalize the values of the <code>x</code> and <code>dir</code> arguments
first (with <code><a href="#topic+normalize_path">normalize_path()</a></code>), to make sure the path separators
are consistent.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>xfun::is_sub_path("a/b/c.txt", "a/b")  # TRUE
xfun::is_sub_path("a/b/c.txt", "d/b")  # FALSE
xfun::is_sub_path("a/b/c.txt", "a\\b")  # FALSE (even on Windows)
</code></pre>

<hr>
<h2 id='is_web_path'>Test if a path is a web path</h2><span id='topic+is_web_path'></span>

<h3>Description</h3>

<p>Check if a path starts with &lsquo;<span class="file">http://</span>&rsquo; or &lsquo;<span class="file">https://</span>&rsquo; or
&lsquo;<span class="file">ftp://</span>&rsquo; or &lsquo;<span class="file">ftps://</span>&rsquo;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_web_path(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_web_path_+3A_x">x</code></td>
<td>
<p>A vector of paths.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical vector.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>xfun::is_web_path("https://www.r-project.org")  # TRUE
xfun::is_web_path("www.r-project.org")  # FALSE
</code></pre>

<hr>
<h2 id='is_windows'>Test for types of operating systems</h2><span id='topic+is_windows'></span><span id='topic+is_unix'></span><span id='topic+is_macos'></span><span id='topic+is_linux'></span><span id='topic+is_arm64'></span>

<h3>Description</h3>

<p>Functions based on <code>.Platform$OS.type</code> and <code>Sys.info()</code> to test if
the current operating system is Windows, macOS, Unix, or Linux.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_windows()

is_unix()

is_macos()

is_linux()

is_arm64()
</code></pre>


<h3>Examples</h3>

<pre><code class='language-R'>library(xfun)
# only one of the following statements should be true
is_windows()
is_unix() &amp;&amp; is_macos()
is_linux()
# In newer Macs, CPU can be either Intel or Apple
is_arm64()  # TRUE on Apple silicone machines
</code></pre>

<hr>
<h2 id='isFALSE'>Test if an object is <code>FALSE</code></h2><span id='topic+isFALSE'></span>

<h3>Description</h3>

<p>For R versions lower than 3.5.0, this function is a simple abbreviation of
<code>identical(x, FALSE)</code>. For higher R versions, this function calls
<code>base::isFALSE()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>isFALSE(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="isFALSE_+3A_x">x</code></td>
<td>
<p>An R object.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>This function will be deprecated in the future. We recommend that you
use <code><a href="base.html#topic+Logic">base::isFALSE()</a></code> instead. If you have to support R versions lower
than 3.5.0, you may use <code>identical(x, FALSE)</code>, but please note that it is
not equivalent to <code>base::isFALSE()</code>.
</p>

<hr>
<h2 id='magic_path'>Find a file or directory under a root directory</h2><span id='topic+magic_path'></span>

<h3>Description</h3>

<p>Given a path, try to find it recursively under a root directory. The input
path can be an incomplete path, e.g., it can be a base filename, and
<code>magic_path()</code> will try to find this file under subdirectories.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>magic_path(
  ...,
  root = proj_root(),
  relative = TRUE,
  error = TRUE,
  message = getOption("xfun.magic_path.message", TRUE),
  n_dirs = getOption("xfun.magic_path.n_dirs", 10000)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="magic_path_+3A_...">...</code></td>
<td>
<p>A character vector of path components.</p>
</td></tr>
<tr><td><code id="magic_path_+3A_root">root</code></td>
<td>
<p>The root directory under which to search for the path. If
<code>NULL</code>, the current working directory is used.</p>
</td></tr>
<tr><td><code id="magic_path_+3A_relative">relative</code></td>
<td>
<p>Whether to return a relative path.</p>
</td></tr>
<tr><td><code id="magic_path_+3A_error">error</code></td>
<td>
<p>Whether to signal an error if the path is not found, or multiple
paths are found.</p>
</td></tr>
<tr><td><code id="magic_path_+3A_message">message</code></td>
<td>
<p>Whether to emit a message when multiple paths are found and
<code>error = FALSE</code>.</p>
</td></tr>
<tr><td><code id="magic_path_+3A_n_dirs">n_dirs</code></td>
<td>
<p>The number of subdirectories to recursively search. The
recursive search may be time-consuming when there are a large number of
subdirectories under the root directory. If you really want to search for
all subdirectories, you may try <code>n_dirs = Inf</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The path found under the root directory, or an error when <code>error = TRUE</code> and the path is not found (or multiple paths are found).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
xfun::magic_path("mtcars.csv")  # find any file that has the base name mtcars.csv

## End(Not run)
</code></pre>

<hr>
<h2 id='mark_dirs'>Mark some paths as directories</h2><span id='topic+mark_dirs'></span>

<h3>Description</h3>

<p>Add a trailing backlash to a file path if this is a directory. This is useful
in messages to the console for example to quickly identify directories from
files.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mark_dirs(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mark_dirs_+3A_x">x</code></td>
<td>
<p>Character vector of paths to files and directories.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>x</code> is a vector of relative paths, directory test is done with path
relative to the current working dir. Use <code><a href="#topic+in_dir">in_dir()</a></code> or use absolute
paths.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mark_dirs(list.files(find.package("xfun"), full.names = TRUE))
</code></pre>

<hr>
<h2 id='md_table'>Generate a simple Markdown pipe table</h2><span id='topic+md_table'></span>

<h3>Description</h3>

<p>A minimal Markdown table generator using the pipe <code>|</code> as column separators.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>md_table(x, digits = NULL, na = NULL, newline = NULL, limit = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="md_table_+3A_x">x</code></td>
<td>
<p>A 2-dimensional object (e.g., a matrix or data frame).</p>
</td></tr>
<tr><td><code id="md_table_+3A_digits">digits</code></td>
<td>
<p>The number of decimal places to be passed to <code><a href="base.html#topic+round">round()</a></code>. It can
be a integer vector of the same length as the number of columns in <code>x</code> to
round columns separately. The default is <code>3</code>.</p>
</td></tr>
<tr><td><code id="md_table_+3A_na">na</code></td>
<td>
<p>A character string to represent <code>NA</code> values. The default is an
empty string.</p>
</td></tr>
<tr><td><code id="md_table_+3A_newline">newline</code></td>
<td>
<p>A character string to substitute <code style="white-space: pre;">&#8288;\n&#8288;</code> in <code>x</code> (because pipe
tables do not support line breaks in cells). The default is a space.</p>
</td></tr>
<tr><td><code id="md_table_+3A_limit">limit</code></td>
<td>
<p>The maximum number of rows to show in the table. If it is
smaller than the number of rows, the data in the middle will be omitted. If
it is of length 2, the second number will be used to limit the number of
columns. Zero and negative values are ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The default argument values can be set via global options with the prefix
<code>xfun.md_table.</code>, e.g., <code style="white-space: pre;">&#8288;options(xfun.md_table.digits 2, xfun.md_table.na = 'n/a')&#8288;</code>.
</p>


<h3>Value</h3>

<p>A character vector.
</p>


<h3>See Also</h3>

<p><code><a href="knitr.html#topic+kable">knitr::kable()</a></code> (which supports more features)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>xfun::md_table(head(iris))
xfun::md_table(mtcars, limit = c(10, 6))
</code></pre>

<hr>
<h2 id='md5'>Calculate the MD5 checksums of R objects</h2><span id='topic+md5'></span>

<h3>Description</h3>

<p><a href="base.html#topic+serialize">Serialize</a> an object to a temporary file, calculate the
checksum via <code><a href="tools.html#topic+md5sum">tools::md5sum()</a></code>, and delete the file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>md5(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="md5_+3A_...">...</code></td>
<td>
<p>Any number of R objects.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector of the checksums of objects passed to <code>md5()</code>. If
the arguments are named, the results will also be named.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x1 = 1
x2 = 1:10
x3 = seq(1, 10)
x4 = iris
x5 = paste
(m = xfun::md5(x1, x2, x3, x4, x5))
stopifnot(m[2] == m[3])  # x2 and x3 should be identical

xfun::md5(x1 = x1, x2 = x2)  # named arguments
</code></pre>

<hr>
<h2 id='msg_cat'>Generate a message with <code>cat()</code></h2><span id='topic+msg_cat'></span>

<h3>Description</h3>

<p>This function is similar to <code><a href="base.html#topic+message">message()</a></code>, and the difference is
that <code>msg_cat()</code> uses <code><a href="base.html#topic+cat">cat()</a></code> to write out the message,
which is sent to <code><a href="base.html#topic+stdout">stdout()</a></code> instead of <code><a href="base.html#topic+stderr">stderr()</a></code>. The
message can be suppressed by <code><a href="base.html#topic+suppressMessages">suppressMessages()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>msg_cat(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="msg_cat_+3A_...">...</code></td>
<td>
<p>Character strings of messages, which will be concatenated into one
string via <code>paste(c(...), collapse = '')</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Invisible <code>NULL</code>, with the side-effect of printing the message.
</p>


<h3>Note</h3>

<p>By default, a newline will not be appended to the message. If you need
a newline, you have to explicitly add it to the message (see
&lsquo;Examples&rsquo;).
</p>


<h3>See Also</h3>

<p>This function was inspired by <code>rlang::inform()</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>{
    # a message without a newline at the end
    xfun::msg_cat("Hello world!")
    # add a newline at the end
    xfun::msg_cat(" This message appears right after the previous one.\n")
}
suppressMessages(xfun::msg_cat("Hello world!"))
</code></pre>

<hr>
<h2 id='native_encode'>Try to use the system native encoding to represent a character vector</h2><span id='topic+native_encode'></span>

<h3>Description</h3>

<p>Apply <code>enc2native()</code> to the character vector, and check if <code>enc2utf8()</code> can
convert it back without a loss. If it does, return <code>enc2native(x)</code>, otherwise
return the original vector with a warning.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>native_encode(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="native_encode_+3A_x">x</code></td>
<td>
<p>A character vector.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>On platforms that supports UTF-8 as the native encoding
(<code><a href="base.html#topic+l10n_info">l10n_info()</a></code><code style="white-space: pre;">&#8288;[['UTF-8']]&#8288;</code> returns <code>TRUE</code>), the conversion will be
skipped.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(xfun)
s = intToUtf8(c(20320, 22909))
Encoding(s)

s2 = native_encode(s)
Encoding(s2)
</code></pre>

<hr>
<h2 id='new_app'>Create a local web application</h2><span id='topic+new_app'></span>

<h3>Description</h3>

<p>An experimental function to create a local web application based on R's
internal <code>httpd</code> server (which is primarily for running R's dynamic help
system).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>new_app(name, handler, open = interactive(), ports = 4321 + 1:10)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="new_app_+3A_name">name</code></td>
<td>
<p>The app name (a character string, and each app should have a
unique name).</p>
</td></tr>
<tr><td><code id="new_app_+3A_handler">handler</code></td>
<td>
<p>A function that takes the HTTP request information (the first
argument is the requested path) and returns a response.</p>
</td></tr>
<tr><td><code id="new_app_+3A_open">open</code></td>
<td>
<p>Whether to open the app, or a function to open the app URL.</p>
</td></tr>
<tr><td><code id="new_app_+3A_ports">ports</code></td>
<td>
<p>A vector of ports to try for starting the server.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The app URL of the form <code style="white-space: pre;">&#8288;http://127.0.0.1:port/custom/name/&#8288;</code>.
</p>


<h3>Note</h3>

<p>This function is not based on base R's public API, and is possible to
break in the future, which is also why the documentation here is terse.
Please avoid creating public-facing web apps with it. You may consider
packages like <span class="pkg">httpuv</span> and <span class="pkg">Rserve</span> for production web apps.
</p>

<hr>
<h2 id='news2md'>Convert package news to the Markdown format</h2><span id='topic+news2md'></span>

<h3>Description</h3>

<p>Read the package news with <code><a href="utils.html#topic+news">news()</a></code>, convert the result to
Markdown, and write to an output file (e.g., &lsquo;<span class="file">NEWS.md</span>&rsquo;). Each package
version appears in a first-level header, each category (e.g., &lsquo;<span class="samp">&#8288;NEW
FEATURES&#8288;</span>&rsquo; or &lsquo;<span class="samp">&#8288;BUG FIXES&#8288;</span>&rsquo;) is in a second-level header, and the news
items are written into bullet lists.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>news2md(package, ..., output = "NEWS.md", category = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="news2md_+3A_package">package</code>, <code id="news2md_+3A_...">...</code></td>
<td>
<p>Arguments to be passed to <code><a href="utils.html#topic+news">news()</a></code>.</p>
</td></tr>
<tr><td><code id="news2md_+3A_output">output</code></td>
<td>
<p>The output file path.</p>
</td></tr>
<tr><td><code id="news2md_+3A_category">category</code></td>
<td>
<p>Whether to keep the category names.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>output = NA</code>, returns the Markdown content as a character
vector, otherwise the content is written to the output file.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# news for the current version of R
xfun::news2md("R", Version == getRversion(), output = NA)

</code></pre>

<hr>
<h2 id='normalize_path'>Normalize paths</h2><span id='topic+normalize_path'></span>

<h3>Description</h3>

<p>A wrapper function of <code>normalizePath()</code> with different defaults.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>normalize_path(x, winslash = "/", must_work = FALSE, resolve_symlink = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="normalize_path_+3A_x">x</code>, <code id="normalize_path_+3A_winslash">winslash</code>, <code id="normalize_path_+3A_must_work">must_work</code></td>
<td>
<p>Arguments passed to
<code><a href="base.html#topic+normalizePath">normalizePath()</a></code>.</p>
</td></tr>
<tr><td><code id="normalize_path_+3A_resolve_symlink">resolve_symlink</code></td>
<td>
<p>Whether to resolve symbolic links.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>library(xfun)
normalize_path("~")
</code></pre>

<hr>
<h2 id='numbers_to_words'>Convert numbers to English words</h2><span id='topic+numbers_to_words'></span><span id='topic+n2w'></span>

<h3>Description</h3>

<p>This can be helpful when writing reports with <span class="pkg">knitr</span>/<span class="pkg">rmarkdown</span> if
we want to print numbers as English words in the output. The function <code>n2w()</code>
is an alias of <code>numbers_to_words()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>numbers_to_words(x, cap = FALSE, hyphen = TRUE, and = FALSE)

n2w(x, cap = FALSE, hyphen = TRUE, and = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="numbers_to_words_+3A_x">x</code></td>
<td>
<p>A numeric vector. The absolute values should be less than <code>1e15</code>.</p>
</td></tr>
<tr><td><code id="numbers_to_words_+3A_cap">cap</code></td>
<td>
<p>Whether to capitalize the first letter of the word. This can be
useful when the word is at the beginning of a sentence. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="numbers_to_words_+3A_hyphen">hyphen</code></td>
<td>
<p>Whether to insert hyphen (-) when the number is between 21 and
99 (except 30, 40, etc.).</p>
</td></tr>
<tr><td><code id="numbers_to_words_+3A_and">and</code></td>
<td>
<p>Whether to insert <code>and</code> between hundreds and tens, e.g., write 110
as &ldquo;one hundred and ten&rdquo; if <code>TRUE</code> instead of &ldquo;one hundred
ten&rdquo;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector.
</p>


<h3>Author(s)</h3>

<p>Daijiang Li
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(xfun)
n2w(0, cap = TRUE)
n2w(0:121, and = TRUE)
n2w(1e+06)
n2w(1e+11 + 12345678)
n2w(-987654321)
n2w(1e+15 - 1)
n2w(123.456)
n2w(123.45678901)
n2w(123.456789098765)
</code></pre>

<hr>
<h2 id='optipng'>Run OptiPNG on all PNG files under a directory</h2><span id='topic+optipng'></span>

<h3>Description</h3>

<p>Call the command <code>optipng</code> via <code>system2()</code> to optimize all PNG
files under a directory.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>optipng(dir = ".", files = all_files("[.]png$", dir), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="optipng_+3A_dir">dir</code></td>
<td>
<p>Path to a directory.</p>
</td></tr>
<tr><td><code id="optipng_+3A_files">files</code></td>
<td>
<p>Alternatively, you can choose the specific files to optimize.</p>
</td></tr>
<tr><td><code id="optipng_+3A_...">...</code></td>
<td>
<p>Arguments to be passed to <code>system2()</code>.</p>
</td></tr>
</table>


<h3>References</h3>

<p>OptiPNG: <a href="https://optipng.sourceforge.net">https://optipng.sourceforge.net</a>.
</p>

<hr>
<h2 id='parse_only'>Parse R code and do not keep the source</h2><span id='topic+parse_only'></span>

<h3>Description</h3>

<p>An abbreviation of <code>parse(keep.source = FALSE)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parse_only(code)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="parse_only_+3A_code">code</code></td>
<td>
<p>A character vector of the R source code.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>R <code><a href="base.html#topic+expression">expression()</a></code>s.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(xfun)
parse_only("1+1")
parse_only(c("y~x", "1:5 # a comment"))
parse_only(character(0))
</code></pre>

<hr>
<h2 id='pkg_attach'>Attach or load packages, and automatically install missing packages if
requested</h2><span id='topic+pkg_attach'></span><span id='topic+pkg_load'></span><span id='topic+loadable'></span><span id='topic+pkg_available'></span><span id='topic+pkg_attach2'></span><span id='topic+pkg_load2'></span>

<h3>Description</h3>

<p><code>pkg_attach()</code> is a vectorized version of <code><a href="base.html#topic+library">library()</a></code> over
the <code>package</code> argument to attach multiple packages in a single function
call. <code>pkg_load()</code> is a vectorized version of
<code><a href="base.html#topic+requireNamespace">requireNamespace()</a></code> to load packages (without attaching them).
The functions <code>pkg_attach2()</code> and <code>pkg_load2()</code> are wrappers of
<code>pkg_attach(install = TRUE)</code> and <code>pkg_load(install = TRUE)</code>,
respectively. <code>loadable()</code> is an abbreviation of
<code>requireNamespace(quietly = TRUE)</code>. <code>pkg_available()</code> tests if a
package with a minimal version is available.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pkg_attach(
  ...,
  install = FALSE,
  message = getOption("xfun.pkg_attach.message", TRUE)
)

pkg_load(..., error = TRUE, install = FALSE)

loadable(pkg, strict = TRUE, new_session = FALSE)

pkg_available(pkg, version = NULL)

pkg_attach2(...)

pkg_load2(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pkg_attach_+3A_...">...</code></td>
<td>
<p>Package names (character vectors, and must always be quoted).</p>
</td></tr>
<tr><td><code id="pkg_attach_+3A_install">install</code></td>
<td>
<p>Whether to automatically install packages that are not
available using <code><a href="utils.html#topic+install.packages">install.packages()</a></code>. Besides <code>TRUE</code> and
<code>FALSE</code>, the value of this argument can also be a function to install
packages (<code>install = TRUE</code> is equivalent to <code>install = install.packages</code>), or a character string <code>"pak"</code> (equivalent to
<code>install = pak::pkg_install</code>, which requires the <span class="pkg">pak</span> package).
You are recommended to set a CRAN mirror in the global option <code>repos</code>
via <code><a href="base.html#topic+options">options()</a></code> if you want to automatically install packages.</p>
</td></tr>
<tr><td><code id="pkg_attach_+3A_message">message</code></td>
<td>
<p>Whether to show the package startup messages (if any startup
messages are provided in a package).</p>
</td></tr>
<tr><td><code id="pkg_attach_+3A_error">error</code></td>
<td>
<p>Whether to signal an error when certain packages cannot be loaded.</p>
</td></tr>
<tr><td><code id="pkg_attach_+3A_pkg">pkg</code></td>
<td>
<p>A single package name.</p>
</td></tr>
<tr><td><code id="pkg_attach_+3A_strict">strict</code></td>
<td>
<p>If <code>TRUE</code>, use <code><a href="base.html#topic+requireNamespace">requireNamespace()</a></code> to test if
a package is loadable; otherwise only check if the package is in
<code><a href="base.html#topic+.packages">.packages</a></code><code>(TRUE)</code> (this does not really load the package, so it
is less rigorous but on the other hand, it can keep the current R session
clean).</p>
</td></tr>
<tr><td><code id="pkg_attach_+3A_new_session">new_session</code></td>
<td>
<p>Whether to test if a package is loadable in a new R
session. Note that <code>new_session = TRUE</code> implies <code>strict = TRUE</code>.</p>
</td></tr>
<tr><td><code id="pkg_attach_+3A_version">version</code></td>
<td>
<p>A minimal version number. If <code>NULL</code>, only test if a
package is available and do not check its version.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These are convenience functions that aim to solve these common problems: (1)
We often need to attach or load multiple packages, and it is tedious to type
several <code>library()</code> calls; (2) We are likely to want to install the
packages when attaching/loading them but they have not been installed.
</p>


<h3>Value</h3>

<p><code>pkg_attach()</code> returns <code>NULL</code> invisibly. <code>pkg_load()</code>
returns a logical vector, indicating whether the packages can be loaded.
</p>


<h3>See Also</h3>

<p><code>pkg_attach2()</code> is similar to <code>pacman::p_load()</code>, but does
not allow non-standard evaluation (NSE) of the <code>...</code> argument, i.e.,
you must pass a real character vector of package names to it, and all names
must be quoted. Allowing NSE adds too much complexity with too little gain
(the only gain is that it saves your effort in typing two quotes).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(xfun)
pkg_attach("stats", "graphics")
# pkg_attach2('servr') # automatically install servr if it is not installed

(pkg_load("stats", "graphics"))
</code></pre>

<hr>
<h2 id='proc_kill'>Kill a process and (optionally) all its child processes</h2><span id='topic+proc_kill'></span>

<h3>Description</h3>

<p>Run the command <code>taskkill /f /pid</code> on Windows and <code>kill</code> on
Unix, respectively, to kill a process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>proc_kill(pid, recursive = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="proc_kill_+3A_pid">pid</code></td>
<td>
<p>The process ID.</p>
</td></tr>
<tr><td><code id="proc_kill_+3A_recursive">recursive</code></td>
<td>
<p>Whether to kill the child processes of the process.</p>
</td></tr>
<tr><td><code id="proc_kill_+3A_...">...</code></td>
<td>
<p>Arguments to be passed to <code><a href="base.html#topic+system2">system2()</a></code> to run the
command to kill the process.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The status code returned from <code>system2()</code>.
</p>

<hr>
<h2 id='process_file'>Read a text file, process the text with a function, and write the text back</h2><span id='topic+process_file'></span><span id='topic+sort_file'></span>

<h3>Description</h3>

<p>Read a text file with the UTF-8 encoding, apply a function to the text, and
write back to the original file if the processed text is different with the
original input.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>process_file(file, fun = identity, x = read_utf8(file))

sort_file(..., fun = sort)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="process_file_+3A_file">file</code></td>
<td>
<p>Path to a text file.</p>
</td></tr>
<tr><td><code id="process_file_+3A_fun">fun</code></td>
<td>
<p>A function to process the text.</p>
</td></tr>
<tr><td><code id="process_file_+3A_x">x</code></td>
<td>
<p>The content of the file.</p>
</td></tr>
<tr><td><code id="process_file_+3A_...">...</code></td>
<td>
<p>Arguments to be passed to <code>process_file()</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>sort_file()</code> is an application of <code>process_file()</code>, with the processing
function being <code><a href="base.html#topic+sort">sort()</a></code>, i.e., it sorts the text lines in a file and write
back the sorted text.
</p>


<h3>Value</h3>

<p>If <code>file</code> is provided, invisible <code>NULL</code> (the file is updated as a
side effect), otherwise the processed content (as a character vector).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>f = tempfile()
xfun::write_utf8("Hello World", f)
xfun::process_file(f, function(x) gsub("World", "woRld", x))
xfun::read_utf8(f)  # see if it has been updated
file.remove(f)
</code></pre>

<hr>
<h2 id='proj_root'>Return the (possible) root directory of a project</h2><span id='topic+proj_root'></span><span id='topic+root_rules'></span>

<h3>Description</h3>

<p>Given a path of a file (or dir) in a potential project (e.g., an R package or
an RStudio project), return the path to the project root directory.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>proj_root(path = "./", rules = root_rules)

root_rules
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="proj_root_+3A_path">path</code></td>
<td>
<p>The initial path to start the search. If it is a file path, its
parent directory will be used.</p>
</td></tr>
<tr><td><code id="proj_root_+3A_rules">rules</code></td>
<td>
<p>A matrix of character strings of two columns: the first column
contains regular expressions to look for filenames that match the patterns,
and the second column contains regular expressions to match the content of
the matched files. The regular expression can be an empty string, meaning
that it will match anything.</p>
</td></tr>
</table>


<h3>Format</h3>

<p>An object of class <code>matrix</code> (inherits from <code>array</code>) with 2 rows and 2 columns.
</p>


<h3>Details</h3>

<p>The search for the root directory is performed by a series of tests,
currently including looking for a &lsquo;<span class="file">DESCRIPTION</span>&rsquo; file that contains
<code style="white-space: pre;">&#8288;Package: *&#8288;</code> (which usually indicates an R package), and a
&lsquo;<span class="file">*.Rproj</span>&rsquo; file that contains <code style="white-space: pre;">&#8288;Version: *&#8288;</code> (which usually indicates
an RStudio project). If files with the expected patterns are not found in the
initial directory, the search will be performed recursively in upper-level
directories.
</p>


<h3>Value</h3>

<p>Path to the root directory if found, otherwise <code>NULL</code>.
</p>


<h3>Note</h3>

<p>This function was inspired by the <span class="pkg">rprojroot</span> package, but is much
less sophisticated. It is a rather simple function designed to be used in
some of packages that I maintain, and may not meet the need of general
users until this note is removed in the future (which should be unlikely).
If you are sure that you are working on the types of projects mentioned in
the &lsquo;Details&rsquo; section, this function may be helpful to you,
otherwise please consider using <span class="pkg">rprojroot</span> instead.
</p>

<hr>
<h2 id='prose_index'>Find the indices of lines in Markdown that are prose (not code blocks)</h2><span id='topic+prose_index'></span>

<h3>Description</h3>

<p>Filter out the indices of lines between code block fences such as <code style="white-space: pre;">&#8288;```&#8288;</code>
(could be three or four or more backticks).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prose_index(x, warn = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prose_index_+3A_x">x</code></td>
<td>
<p>A character vector of text in Markdown.</p>
</td></tr>
<tr><td><code id="prose_index_+3A_warn">warn</code></td>
<td>
<p>Whether to emit a warning when code fences are not balanced.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An integer vector of indices of lines that are prose in Markdown.
</p>


<h3>Note</h3>

<p>If the code fences are not balanced (e.g., a starting fence without an
ending fence), this function will treat all lines as prose.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(xfun)
prose_index(c("a", "```", "b", "```", "c"))
prose_index(c("a", "````", "```r", "1+1", "```", "````", "c"))
</code></pre>

<hr>
<h2 id='protect_math'>Protect math expressions in pairs of backticks in Markdown</h2><span id='topic+protect_math'></span>

<h3>Description</h3>

<p>For Markdown renderers that do not support LaTeX math, we need to protect
math expressions as verbatim code (in a pair of backticks), because some
characters in the math expressions may be interpreted as Markdown syntax
(e.g., a pair of underscores may make text italic). This function detects
math expressions in Markdown (by heuristics), and wrap them in backticks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>protect_math(x, token = "")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="protect_math_+3A_x">x</code></td>
<td>
<p>A character vector of text in Markdown.</p>
</td></tr>
<tr><td><code id="protect_math_+3A_token">token</code></td>
<td>
<p>A character string to wrap math expressions at both ends. This
can be a unique token so that math expressions can be reliably identified
and restored after the Markdown text is converted.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Expressions in pairs of dollar signs or double dollar signs are treated as
math, if there are no spaces after the starting dollar sign, or before the
ending dollar sign. There should be spaces before the starting dollar sign,
unless the math expression starts from the very beginning of a line. For a
pair of single dollar signs, the ending dollar sign should not be followed by
a number. With these assumptions, there should not be too many false
positives when detecing math expressions.
</p>
<p>Besides, LaTeX environments (<code style="white-space: pre;">&#8288;\begin{*}&#8288;</code> and <code style="white-space: pre;">&#8288;\end{*}&#8288;</code>) are also
protected in backticks.
</p>


<h3>Value</h3>

<p>A character vector with math expressions in backticks.
</p>


<h3>Note</h3>

<p>If you are using Pandoc or the <span class="pkg">rmarkdown</span> package, there is no
need to use this function, because Pandoc's Markdown can recognize math
expressions.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(xfun)
protect_math(c("hi $a+b$", "hello $$\\alpha$$", "no math here: $x is $10 dollars"))
protect_math(c("hi $$", "\\begin{equation}", "x + y = z", "\\end{equation}"))
protect_math("$a+b$", "===")
</code></pre>

<hr>
<h2 id='raw_string'>Print a character vector in its raw form</h2><span id='topic+raw_string'></span><span id='topic+print.xfun_raw_string'></span>

<h3>Description</h3>

<p>The function <code>raw_string()</code> assigns the class <code>xfun_raw_string</code> to
the character vector, and the corresponding printing function
<code>print.xfun_raw_string()</code> uses <code>cat(x, sep = '\n')</code> to write the
character vector to the console, which will suppress the leading indices
(such as <code style="white-space: pre;">&#8288;[1]&#8288;</code>) and double quotes, and it may be easier to read the
characters in the raw form (especially when there are escape sequences).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>raw_string(x)

## S3 method for class 'xfun_raw_string'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="raw_string_+3A_x">x</code></td>
<td>
<p>For <code>raw_string()</code>, a character vector. For the print method,
the <code>raw_string()</code> object.</p>
</td></tr>
<tr><td><code id="raw_string_+3A_...">...</code></td>
<td>
<p>Other arguments (currently ignored).</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>library(xfun)
raw_string(head(LETTERS))
raw_string(c("a \"b\"", "hello\tworld!"))
</code></pre>

<hr>
<h2 id='read_all'>Read all text files and concatenate their content</h2><span id='topic+read_all'></span>

<h3>Description</h3>

<p>Read files one by one, and optionally add text before/after the content. Then
combine all content into one character vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_all(files, before = function(f) NULL, after = function(f) NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read_all_+3A_files">files</code></td>
<td>
<p>A vector of file paths.</p>
</td></tr>
<tr><td><code id="read_all_+3A_before">before</code>, <code id="read_all_+3A_after">after</code></td>
<td>
<p>A function that takes one file path as the input and
returns values to be added before or after the content of the file.
Alternatively, they can be constant values to be added.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># two files in this package
fs = system.file("scripts", c("call-fun.R", "child-pids.sh"), package = "xfun")
xfun::read_all(fs)

# add file paths before file content and an empty line after content
xfun::read_all(fs, before = function(f) paste("#-----", f, "-----"), after = "")

# add constants
xfun::read_all(fs, before = "/*", after = c("*/", ""))
</code></pre>

<hr>
<h2 id='read_bin'>Read all records of a binary file as a raw vector by default</h2><span id='topic+read_bin'></span>

<h3>Description</h3>

<p>This is a wrapper function of <code><a href="base.html#topic+readBin">readBin()</a></code> with default arguments
<code>what = "raw"</code> and <code style="white-space: pre;">&#8288;n = &#8288;</code><code><a href="base.html#topic+file.size">file.size</a></code><code>(file)</code>, which means it
will read the full content of a binary file as a raw vector by default.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_bin(file, what = "raw", n = file.info(file)$size, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read_bin_+3A_file">file</code>, <code id="read_bin_+3A_what">what</code>, <code id="read_bin_+3A_n">n</code>, <code id="read_bin_+3A_...">...</code></td>
<td>
<p>Arguments to be passed to <code>readBin()</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector returned from <code>readBin()</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>f = tempfile()
cat("abc", file = f)
xfun::read_bin(f)
unlink(f)
</code></pre>

<hr>
<h2 id='read_utf8'>Read / write files encoded in UTF-8</h2><span id='topic+read_utf8'></span><span id='topic+write_utf8'></span><span id='topic+append_utf8'></span><span id='topic+append_unique'></span>

<h3>Description</h3>

<p>Read or write files, assuming they are encoded in UTF-8. <code>read_utf8()</code> is
roughly <code>readLines(encoding = 'UTF-8')</code> (a warning will be issued if non-UTF8
lines are found), and <code>write_utf8()</code> calls <code>writeLines(enc2utf8(text), useBytes = TRUE)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_utf8(con, error = FALSE)

write_utf8(text, con, ...)

append_utf8(text, con, sort = TRUE)

append_unique(text, con, sort = function(x) base::sort(unique(x)))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read_utf8_+3A_con">con</code></td>
<td>
<p>A connection or a file path.</p>
</td></tr>
<tr><td><code id="read_utf8_+3A_error">error</code></td>
<td>
<p>Whether to signal an error when non-UTF8 characters are detected
(if <code>FALSE</code>, only a warning message is issued).</p>
</td></tr>
<tr><td><code id="read_utf8_+3A_text">text</code></td>
<td>
<p>A character vector (will be converted to UTF-8 via <code><a href="base.html#topic+enc2utf8">enc2utf8()</a></code>).</p>
</td></tr>
<tr><td><code id="read_utf8_+3A_...">...</code></td>
<td>
<p>Other arguments passed to <code><a href="base.html#topic+writeLines">writeLines()</a></code> (except <code>useBytes</code>, which
is <code>TRUE</code> in <code>write_utf8()</code>).</p>
</td></tr>
<tr><td><code id="read_utf8_+3A_sort">sort</code></td>
<td>
<p>Logical (<code>FALSE</code> means not to sort the content) or a
function to sort the content; <code>TRUE</code> is equivalent to
<code>base::sort</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>append_utf8()</code> appends UTF-8 content to a file or connection
based on <code>read_utf8()</code> and <code>write_utf8()</code>, and optionally sort the content.
The function <code>append_unique()</code> appends unique lines to a file or connection.
</p>


<h3>Value</h3>

<p><code>read_utf8()</code> returns a character vector of the file content;
<code>write_utf8()</code> returns the <code>con</code> argument (invisibly).
</p>

<hr>
<h2 id='record'>Run R code and record the results</h2><span id='topic+record'></span><span id='topic+format.xfun_record_results'></span><span id='topic+print.xfun_record_results'></span>

<h3>Description</h3>

<p>Run R code and capture various types of output, including text output, plots,
messages, warnings, and errors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>record(
  code = NULL,
  dev = "png",
  dev.path = "xfun-record",
  dev.ext = dev_ext(dev),
  dev.args = list(),
  message = TRUE,
  warning = TRUE,
  error = NA,
  cache = list(),
  print = record_print,
  print.args = list(),
  verbose = getOption("xfun.record.verbose", 0),
  envir = parent.frame()
)

## S3 method for class 'xfun_record_results'
format(x, to = c("text", "html"), encode = FALSE, template = FALSE, ...)

## S3 method for class 'xfun_record_results'
print(
  x,
  browse = interactive(),
  to = if (browse) "html" else "text",
  template = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="record_+3A_code">code</code></td>
<td>
<p>A character vector of R source code.</p>
</td></tr>
<tr><td><code id="record_+3A_dev">dev</code></td>
<td>
<p>A graphics device. It can be a function name, a function, or a
character string that can be evaluated to a function to open a graphics
device.</p>
</td></tr>
<tr><td><code id="record_+3A_dev.path">dev.path</code></td>
<td>
<p>A base file path for plots. Actual plot filenames will be
this base path plus incremental suffixes. For example, if <code>dev.path = "foo"</code>, the plot files will be <code style="white-space: pre;">&#8288;foo-1.png&#8288;</code>, <code style="white-space: pre;">&#8288;foo-2.png&#8288;</code>, and so on. If
<code>dev.path</code> is not character (e.g., <code>FALSE</code>), plots will not be recorded.</p>
</td></tr>
<tr><td><code id="record_+3A_dev.ext">dev.ext</code></td>
<td>
<p>The file extension for plot files. By default, it will be
inferred from the first argument of the device function if possible.</p>
</td></tr>
<tr><td><code id="record_+3A_dev.args">dev.args</code></td>
<td>
<p>Extra arguments to be passed to the device. The default
arguments are <code>list(units = 'in', onefile = FALSE, width = 7, height = 7, res = 96)</code>. If any of these arguments is not present in the device
function, it will be dropped.</p>
</td></tr>
<tr><td><code id="record_+3A_message">message</code>, <code id="record_+3A_warning">warning</code>, <code id="record_+3A_error">error</code></td>
<td>
<p>If <code>TRUE</code>, record and store messages / warnings
/ errors in the output. If <code>FALSE</code>, suppress them. If <code>NA</code>, do not process
them (messages will be emitted to the console, and errors will halt the
execution).</p>
</td></tr>
<tr><td><code id="record_+3A_cache">cache</code></td>
<td>
<p>A list of options for caching. See the <code>path</code>, <code>id</code>, and <code>...</code>
arguments of <code><a href="#topic+cache_exec">cache_exec()</a></code>.</p>
</td></tr>
<tr><td><code id="record_+3A_print">print</code></td>
<td>
<p>A (typically S3) function that takes the value of an expression
in the code as input and returns output. The default is <code><a href="#topic+record_print">record_print()</a></code>.</p>
</td></tr>
<tr><td><code id="record_+3A_print.args">print.args</code></td>
<td>
<p>A list of arguments for the <code>print</code> function. By default,
the whole list is not passed directly to the function, but only an element
in the list with a name identical to the first class name of the returned
value of the expression, e.g., <code>list(data.frame = list(digits = 3), matrix = list())</code>. This makes it possible to apply different print arguments to
objects of different classes. If the whole list is intended to be passed to
the print function directly, wrap the list in <code><a href="base.html#topic+I">I()</a></code>.</p>
</td></tr>
<tr><td><code id="record_+3A_verbose">verbose</code></td>
<td>
<p><code>2</code> means to always print the value of each expression in the
code, no matter if the value is <code><a href="base.html#topic+invisible">invisible()</a></code> or not; <code>1</code> means to always
print the value of the last expression; <code>0</code> means no special handling
(i.e., print only when the value is visible).</p>
</td></tr>
<tr><td><code id="record_+3A_envir">envir</code></td>
<td>
<p>An environment in which the code is evaluated.</p>
</td></tr>
<tr><td><code id="record_+3A_x">x</code></td>
<td>
<p>An object returned by <code>record()</code>.</p>
</td></tr>
<tr><td><code id="record_+3A_to">to</code></td>
<td>
<p>The output format (text or html).</p>
</td></tr>
<tr><td><code id="record_+3A_encode">encode</code></td>
<td>
<p>For HTML output, whether to base64 encode plots.</p>
</td></tr>
<tr><td><code id="record_+3A_template">template</code></td>
<td>
<p>For HTML output, whether to embed the formatted results in an
HTML template. Alternatively, this argument can take a file path, i.e.,
path to an HTML template that contains the variable <code style="white-space: pre;">&#8288;$body$&#8288;</code>. If <code>TRUE</code>,
the default template in this package will be used
(<code>xfun:::pkg_file('resources', 'record.html')</code>).</p>
</td></tr>
<tr><td><code id="record_+3A_...">...</code></td>
<td>
<p>Currently ignored.</p>
</td></tr>
<tr><td><code id="record_+3A_browse">browse</code></td>
<td>
<p>Whether to browse the results on an HTML page.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>record()</code> returns a list of the class <code>xfun_record_results</code> that
contains elements with these possible classes: <code>record_source</code> (source
code), <code>record_output</code> (text output), <code>record_plot</code> (plot file paths),
<code>record_message</code> (messages), <code>record_warning</code> (warnings), and
<code>record_error</code> (errors, only when the argument <code>error = TRUE</code>).
</p>
<p>The <code>format()</code> method returns a character vector of plain-text output
or HTML code for displaying the results.
</p>
<p>The <code>print()</code> method prints the results as plain text or HTML to the
console or displays the HTML page.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>code = c("# a warning test", "1:2 + 1:3", "par(mar = c(4, 4, 1, .2))",
    "barplot(5:1, col = 2:6, horiz = TRUE)", "head(iris)",
    "sunflowerplot(iris[, 3:4], seg.col = 'purple')",
    "if (TRUE) {\n  message('Hello, xfun::record()!')\n}",
    "# throw an error", "1 + 'a'")
res = xfun::record(code, dev.args = list(width = 9, height = 6.75),
    error = TRUE)
xfun::tree(res)
format(res)
# find and clean up plot files
plots = Filter(function(x) inherits(x, "record_plot"),
    res)
file.remove(unlist(plots))
</code></pre>

<hr>
<h2 id='record_print'>Print methods for <code>record()</code></h2><span id='topic+record_print'></span><span id='topic+record_print.default'></span><span id='topic+new_record'></span>

<h3>Description</h3>

<p>An S3 generic function to be called to print visible values in code when the
code is recorded by <code><a href="#topic+record">record()</a></code>. It is similar to <code><a href="knitr.html#topic+knit_print">knitr::knit_print()</a></code>. By
default, it captures the normal <code><a href="base.html#topic+print">print()</a></code> output and returns the result as a
character vector. The <code>knitr_kable</code> method is for printing <code><a href="knitr.html#topic+kable">knitr::kable()</a></code>
output. Users and package authors can define other S3 methods to extend this
function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>record_print(x, ...)

## Default S3 method:
record_print(x, ...)

new_record(x, class)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="record_print_+3A_x">x</code></td>
<td>
<p>For <code>record_print()</code>, the value to be printed. For <code>new_record()</code>, a
character vector to be included in the printed results.</p>
</td></tr>
<tr><td><code id="record_print_+3A_...">...</code></td>
<td>
<p>Other arguments to be passed to <code>record_print()</code> methods.</p>
</td></tr>
<tr><td><code id="record_print_+3A_class">class</code></td>
<td>
<p>A class name. Possible values are <code>xfun:::.record_cls</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>record_print()</code> method should return a character vector or a list
of character vectors. The original classes of the vector will be discarded,
and the vector will be treated as console output by default (i.e.,
<code>new_record(class = "output")</code>). If it should be another type of output,
wrap the vector in <code><a href="#topic+new_record">new_record()</a></code> and specify a class name.
</p>

<hr>
<h2 id='relative_path'>Get the relative path of a path relative to a directory</h2><span id='topic+relative_path'></span>

<h3>Description</h3>

<p>Given a directory, return the relative path that is relative to this
directory. For example, the path &lsquo;<span class="file">foo/bar.txt</span>&rsquo; relative to the directory
&lsquo;<span class="file">foo/</span>&rsquo; is &lsquo;<span class="file">bar.txt</span>&rsquo;, and the path &lsquo;<span class="file">/a/b/c.txt</span>&rsquo; relative to
&lsquo;<span class="file">/d/e/</span>&rsquo; is &lsquo;<span class="file">../../a/b/c.txt</span>&rsquo;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>relative_path(x, dir = ".", use.. = TRUE, error = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="relative_path_+3A_x">x</code></td>
<td>
<p>A vector of paths to be converted to relative paths.</p>
</td></tr>
<tr><td><code id="relative_path_+3A_dir">dir</code></td>
<td>
<p>Path to a directory.</p>
</td></tr>
<tr><td><code id="relative_path_+3A_use..">use..</code></td>
<td>
<p>Whether to use double-dots (&lsquo;<span class="file">..</span>&rsquo;) in the relative path. A
double-dot indicates the parent directory (starting from the directory
provided by the <code>dir</code> argument).</p>
</td></tr>
<tr><td><code id="relative_path_+3A_error">error</code></td>
<td>
<p>Whether to signal an error if a path cannot be converted to a
relative path.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of relative paths if the conversion succeeded; otherwise the
original paths when <code>error = FALSE</code>, and an error when <code>error = TRUE</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>xfun::relative_path("foo/bar.txt", "foo/")
xfun::relative_path("foo/bar/a.txt", "foo/haha/")
xfun::relative_path(getwd())
</code></pre>

<hr>
<h2 id='rename_seq'>Rename files with a sequential numeric prefix</h2><span id='topic+rename_seq'></span>

<h3>Description</h3>

<p>Rename a series of files and add an incremental numeric prefix to the
filenames. For example, files &lsquo;<span class="file">a.txt</span>&rsquo;, &lsquo;<span class="file">b.txt</span>&rsquo;, and &lsquo;<span class="file">c.txt</span>&rsquo;
can be renamed to &lsquo;<span class="file">1-a.txt</span>&rsquo;, &lsquo;<span class="file">2-b.txt</span>&rsquo;, and &lsquo;<span class="file">3-c.txt</span>&rsquo;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rename_seq(
  pattern = "^[0-9]+-.+[.]Rmd$",
  format = "auto",
  replace = TRUE,
  start = 1,
  dry_run = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rename_seq_+3A_pattern">pattern</code></td>
<td>
<p>A regular expression for <code><a href="base.html#topic+list.files">list.files()</a></code> to obtain
the files to be renamed. For example, to rename <code>.jpeg</code> files, use
<code>pattern = "[.]jpeg$"</code>.</p>
</td></tr>
<tr><td><code id="rename_seq_+3A_format">format</code></td>
<td>
<p>The format for the numeric prefix. This is passed to
<code><a href="base.html#topic+sprintf">sprintf()</a></code>. The default format is <code>"\%0Nd"</code> where <code>N = floor(log10(n)) + 1</code> and <code>n</code> is the number of files, which means the
prefix may be padded with zeros. For example, if there are 150 files to be
renamed, the format will be <code>"\%03d"</code> and the prefixes will be
<code>001</code>, <code>002</code>, ..., <code>150</code>.</p>
</td></tr>
<tr><td><code id="rename_seq_+3A_replace">replace</code></td>
<td>
<p>Whether to remove existing numeric prefixes in filenames.</p>
</td></tr>
<tr><td><code id="rename_seq_+3A_start">start</code></td>
<td>
<p>The starting number for the prefix (it can start from 0).</p>
</td></tr>
<tr><td><code id="rename_seq_+3A_dry_run">dry_run</code></td>
<td>
<p>Whether to not really rename files. To be safe, the default is
<code>TRUE</code>. If you have looked at the new filenames and are sure the new
names are what you want, you may rerun <code>rename_seq()</code> with
<code>dry_run = FALSE</code> to actually rename files.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named character vector. The names are original filenames, and the
vector itself is the new filenames.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>xfun::rename_seq()
xfun::rename_seq("[.](jpeg|png)$", format = "%04d")
</code></pre>

<hr>
<h2 id='rest_api'>Get data from a REST API</h2><span id='topic+rest_api'></span><span id='topic+rest_api_raw'></span><span id='topic+github_api'></span>

<h3>Description</h3>

<p>Read data from a REST API and optionally with an authorization token in the
request header. The function <code>rest_api_raw()</code> returns the raw text of
the response, and <code>rest_api()</code> will parse the response with
<code>jsonlite::fromJSON()</code> (assuming that the response is in the JSON
format).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rest_api(...)

rest_api_raw(root, endpoint, token = "", params = list(), headers = NULL)

github_api(
  endpoint,
  token = "",
  params = list(),
  headers = NULL,
  raw = !loadable("jsonlite")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rest_api_+3A_...">...</code></td>
<td>
<p>Arguments to be passed to <code>rest_api_raw()</code>.</p>
</td></tr>
<tr><td><code id="rest_api_+3A_root">root</code></td>
<td>
<p>The API root URL.</p>
</td></tr>
<tr><td><code id="rest_api_+3A_endpoint">endpoint</code></td>
<td>
<p>The API endpoint.</p>
</td></tr>
<tr><td><code id="rest_api_+3A_token">token</code></td>
<td>
<p>A named character string (e.g., <code>c(token = "xxxx")</code>), which
will be used to create an authorization header of the form
&lsquo;<span class="samp">&#8288;Authorization: NAME TOKEN&#8288;</span>&rsquo; for the API call, where &lsquo;<span class="samp">&#8288;NAME&#8288;</span>&rsquo; is the
name of the string and &lsquo;<span class="samp">&#8288;TOKEN&#8288;</span>&rsquo; is the string. If the string does not
have a name, &lsquo;<span class="samp">&#8288;Basic&#8288;</span>&rsquo; will be used as the default name.</p>
</td></tr>
<tr><td><code id="rest_api_+3A_params">params</code></td>
<td>
<p>A list of query parameters to be sent with the API call.</p>
</td></tr>
<tr><td><code id="rest_api_+3A_headers">headers</code></td>
<td>
<p>A named character vector of HTTP headers, e.g., <code>c(Accept = "application/vnd.github.v3+json")</code>.</p>
</td></tr>
<tr><td><code id="rest_api_+3A_raw">raw</code></td>
<td>
<p>Whether to return the raw response or parse the response with
<span class="pkg">jsonlite</span>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions are simple wrappers based on <code><a href="base.html#topic+url">url()</a></code> and
<code><a href="#topic+read_utf8">read_utf8()</a></code>. Specifically, the <code>headers</code> argument is
passed to <code>url()</code>, and <code>read_utf8()</code> will send a &lsquo;<span class="samp">&#8288;GET&#8288;</span>&rsquo; request
to the API server. This means these functions only support the &lsquo;<span class="samp">&#8288;GET&#8288;</span>&rsquo;
method. If you need to use other HTTP methods (such as &lsquo;<span class="samp">&#8288;POST&#8288;</span>&rsquo;), you have
to use other packages such as <span class="pkg">curl</span> and <span class="pkg">httr</span>.
</p>
<p><code>github_api()</code> is a wrapper function based on
<code>rest_api_raw()</code> to obtain data from the GitHub API:
<a href="https://docs.github.com/en/rest">https://docs.github.com/en/rest</a>. You can provide a personal access
token (PAT) via the <code>token</code> argument, or via one of the environment
variables <var>GITHUB_PAT</var>, <var>GITHUB_TOKEN</var>, <var>GH_TOKEN</var>. A PAT
allows for a much higher rate limit in API calls. Without a token, you can
only make 60 calls in an hour.
</p>


<h3>Value</h3>

<p>A character vector (the raw JSON response) or an R object parsed from
the JSON text.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# a normal GET request
xfun::rest_api("https://httpbin.org", "/get")
xfun::rest_api_raw("https://httpbin.org", "/get")

# send the request with an auth header
xfun::rest_api("https://httpbin.org", "/headers", "OPEN SESAME!")

# with query parameters
xfun::rest_api("https://httpbin.org", "/response-headers", params = list(foo = "bar"))

# get the rate limit info from GitHub
xfun::github_api("/rate_limit")

</code></pre>

<hr>
<h2 id='retry'>Retry calling a function for a number of times</h2><span id='topic+retry'></span>

<h3>Description</h3>

<p>If the function returns an error, retry it for the specified number of
times, with a pause between attempts.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>retry(fun, ..., .times = 3, .pause = 5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="retry_+3A_fun">fun</code></td>
<td>
<p>A function.</p>
</td></tr>
<tr><td><code id="retry_+3A_...">...</code></td>
<td>
<p>Arguments to be passed to the function.</p>
</td></tr>
<tr><td><code id="retry_+3A_.times">.times</code></td>
<td>
<p>The number of times.</p>
</td></tr>
<tr><td><code id="retry_+3A_.pause">.pause</code></td>
<td>
<p>The number of seconds to wait before the next attempt.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>One application of this function is to download a web resource. Since the
download might fail sometimes, you may want to retry it for a few more times.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# read the GitHub releases info of the repo yihui/xfun
xfun::retry(xfun::github_releases, "yihui/xfun")

</code></pre>

<hr>
<h2 id='rev_check'>Run <code>R CMD check</code> on the reverse dependencies of a package</h2><span id='topic+rev_check'></span><span id='topic+compare_Rcheck'></span>

<h3>Description</h3>

<p>Install the source package, figure out the reverse dependencies on CRAN,
download all of their source packages, and run <code>R CMD check</code> on them
in parallel.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rev_check(
  pkg,
  which = "all",
  recheck = NULL,
  ignore = NULL,
  update = TRUE,
  timeout = getOption("xfun.rev_check.timeout", 15 * 60),
  src = file.path(src_dir, pkg),
  src_dir = getOption("xfun.rev_check.src_dir")
)

compare_Rcheck(status_only = TRUE, output = "00check_diffs.md")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rev_check_+3A_pkg">pkg</code></td>
<td>
<p>The package name.</p>
</td></tr>
<tr><td><code id="rev_check_+3A_which">which</code></td>
<td>
<p>Which types of reverse dependencies to check. See
<code><a href="tools.html#topic+package_dependencies">tools::package_dependencies()</a></code> for possible values. The
special value <code>'hard'</code> means the hard dependencies, i.e.,
<code>c('Depends', 'Imports', 'LinkingTo')</code>.</p>
</td></tr>
<tr><td><code id="rev_check_+3A_recheck">recheck</code></td>
<td>
<p>A vector of package names to be (re)checked. If not provided
and there are any &lsquo;<span class="file">*.Rcheck</span>&rsquo; directories left by certain packages
(this often means these packages failed the last time), <code>recheck</code> will
be these packages; if there are no &lsquo;<span class="file">*.Rcheck</span>&rsquo; directories but a text
file &lsquo;<span class="file">recheck</span>&rsquo; exists, <code>recheck</code> will be the character vector
read from this file. This provides a way for you to manually specify the
packages to be checked. If there are no packages to be rechecked, all
reverse dependencies will be checked.</p>
</td></tr>
<tr><td><code id="rev_check_+3A_ignore">ignore</code></td>
<td>
<p>A vector of package names to be ignored in <code>R CMD
  check</code>. If this argument is missing and a file &lsquo;<span class="file">00ignore</span>&rsquo; exists, the
file will be read as a character vector and passed to this argument.</p>
</td></tr>
<tr><td><code id="rev_check_+3A_update">update</code></td>
<td>
<p>Whether to update all packages before the check.</p>
</td></tr>
<tr><td><code id="rev_check_+3A_timeout">timeout</code></td>
<td>
<p>Timeout in seconds for <code>R CMD check</code> to check each
package. The (approximate) total time can be limited by the global option
<code>xfun.rev_check.timeout_total</code>.</p>
</td></tr>
<tr><td><code id="rev_check_+3A_src">src</code></td>
<td>
<p>The path of the source package directory.</p>
</td></tr>
<tr><td><code id="rev_check_+3A_src_dir">src_dir</code></td>
<td>
<p>The parent directory of the source package directory. This can
be set in a global option if all your source packages are under a common
parent directory.</p>
</td></tr>
<tr><td><code id="rev_check_+3A_status_only">status_only</code></td>
<td>
<p>If <code>TRUE</code>, only compare the final statuses of the
checks (the last line of &lsquo;<span class="file">00check.log</span>&rsquo;), and delete &lsquo;<span class="file">*.Rcheck</span>&rsquo;
and &lsquo;<span class="file">*.Rcheck2</span>&rsquo; if the statuses are identical, otherwise write out the
full diffs of the logs. If <code>FALSE</code>, compare the full logs under
&lsquo;<span class="file">*.Rcheck</span>&rsquo; and &lsquo;<span class="file">*.Rcheck2</span>&rsquo;.</p>
</td></tr>
<tr><td><code id="rev_check_+3A_output">output</code></td>
<td>
<p>The output Markdown file to which the diffs in check logs will
be written. If the <span class="pkg">markdown</span> package is available, the Markdown file
will be converted to HTML, so you can see the diffs more clearly.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Everything occurs under the current working directory, and you are
recommended to call this function under a designated directory, especially
when the number of reverse dependencies is large, because all source packages
will be downloaded to this directory, and all &lsquo;<span class="file">*.Rcheck</span>&rsquo; directories
will be generated under this directory, too.
</p>
<p>If a source tarball of the expected version has been downloaded before (under
the &lsquo;<span class="file">tarball</span>&rsquo; directory), it will not be downloaded again (to save time
and bandwidth).
</p>
<p>After a package has been checked, the associated &lsquo;<span class="file">*.Rcheck</span>&rsquo; directory
will be deleted if the check was successful (no warnings or errors or notes),
which means if you see a &lsquo;<span class="file">*.Rcheck</span>&rsquo; directory, it means the check
failed, and you need to take a look at the log files under that directory.
</p>
<p>The time to finish the check is recorded for each package. As the check goes
on, the total remaining time will be roughly estimated via <code>n * mean(times)</code>, where <code>n</code> is the number of packages remaining to be
checked, and <code>times</code> is a vector of elapsed time of packages that have
been checked.
</p>
<p>If a check on a reverse dependency failed, its &lsquo;<span class="file">*.Rcheck</span>&rsquo; directory will
be renamed to &lsquo;<span class="file">*.Rcheck2</span>&rsquo;, and another check will be run against the
CRAN version of the package unless <code>options(xfun.rev_check.compare = FALSE)</code> is set. If the logs of the two checks are the same, it means no new
problems were introduced in the package, and you can probably ignore this
particular reverse dependency. The function <code>compare_Rcheck()</code> can be
used to create a summary of all the differences in the check logs under
&lsquo;<span class="file">*.Rcheck</span>&rsquo; and &lsquo;<span class="file">*.Rcheck2</span>&rsquo;. This will be done automatically if
<code>options(xfun.rev_check.summary = TRUE)</code> has been set.
</p>
<p>A recommended workflow is to use a special directory to run
<code>rev_check()</code>, set the global <code><a href="base.html#topic+options">options()</a></code>
<code>xfun.rev_check.src_dir</code> and <code>repos</code> in the R startup (see
<code style="white-space: pre;">&#8288;?&#8288;</code><code><a href="base.html#topic+Startup">Startup</a></code>) profile file <code>.Rprofile</code> under this directory,
and (optionally) set <code>R_LIBS_USER</code> in &lsquo;<span class="file">.Renviron</span>&rsquo; to use a special
library path (so that your usual library will not be cluttered). Then run
<code>xfun::rev_check(pkg)</code> once, investigate and fix the problems or (if you
believe it was not your fault) ignore broken packages in the file
&lsquo;<span class="file">00ignore</span>&rsquo;, and run <code>xfun::rev_check(pkg)</code> again to recheck the
failed packages. Repeat this process until all &lsquo;<span class="file">*.Rcheck</span>&rsquo; directories
are gone.
</p>
<p>As an example, I set <code>options(repos = c(CRAN = 'https://cran.rstudio.com'), xfun.rev_check.src_dir = '~/Dropbox/repo')</code> in
&lsquo;<span class="file">.Rprofile</span>&rsquo;, and <code style="white-space: pre;">&#8288;R_LIBS_USER=~/R-tmp&#8288;</code> in &lsquo;<span class="file">.Renviron</span>&rsquo;. Then I
can run, for example, <code>xfun::rev_check('knitr')</code> repeatedly under a
special directory &lsquo;<span class="file">~/Downloads/revcheck</span>&rsquo;. Reverse dependencies and their
dependencies will be installed to &lsquo;<span class="file">~/R-tmp</span>&rsquo;, and <span class="pkg">knitr</span> will be
installed from &lsquo;<span class="file">~/Dropbox/repo/kintr</span>&rsquo;.
</p>


<h3>Value</h3>

<p>A named numeric vector with the names being package names of reverse
dependencies; <code>0</code> indicates check success, <code>1</code> indicates failure,
and <code>2</code> indicates that a package was not checked due to global
timeout.
</p>


<h3>See Also</h3>

<p><code>devtools::revdep_check()</code> is more sophisticated, but currently
has a few major issues that affect me: (1) It always deletes the
&lsquo;<span class="file">*.Rcheck</span>&rsquo; directories
(<a href="https://github.com/r-lib/devtools/issues/1395">https://github.com/r-lib/devtools/issues/1395</a>), which makes it
difficult to know more information about the failures; (2) It does not
fully install the source package before checking its reverse dependencies
(<a href="https://github.com/r-lib/devtools/pull/1397">https://github.com/r-lib/devtools/pull/1397</a>); (3) I feel it is
fairly difficult to iterate the check (ignore the successful packages and
only check the failed packages); by comparison, <code>xfun::rev_check()</code>
only requires you to run a short command repeatedly (failed packages are
indicated by the existing &lsquo;<span class="file">*.Rcheck</span>&rsquo; directories, and automatically
checked again the next time).
</p>
<p><code>xfun::rev_check()</code> borrowed a very nice feature from
<code>devtools::revdep_check()</code>: estimating and displaying the remaining
time. This is particularly useful for packages with huge numbers of reverse
dependencies.
</p>

<hr>
<h2 id='Rscript'>Run the commands <code>Rscript</code> and <code>R CMD</code></h2><span id='topic+Rscript'></span><span id='topic+Rcmd'></span>

<h3>Description</h3>

<p>Wrapper functions to run the commands <code>Rscript</code> and <code>R CMD</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Rscript(args, ...)

Rcmd(args, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Rscript_+3A_args">args</code></td>
<td>
<p>A character vector of command-line arguments.</p>
</td></tr>
<tr><td><code id="Rscript_+3A_...">...</code></td>
<td>
<p>Other arguments to be passed to <code><a href="base.html#topic+system2">system2()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A value returned by <code>system2()</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(xfun)
Rscript(c("-e", "1+1"))
Rcmd(c("build", "--help"))
</code></pre>

<hr>
<h2 id='Rscript_call'>Call a function in a new R session via <code>Rscript()</code></h2><span id='topic+Rscript_call'></span>

<h3>Description</h3>

<p>Save the argument values of a function in a temporary RDS file, open a new R
session via <code><a href="#topic+Rscript">Rscript()</a></code>, read the argument values, call the function, and
read the returned value back to the current R session.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Rscript_call(
  fun,
  args = list(),
  options = NULL,
  ...,
  wait = TRUE,
  fail = sprintf("Failed to run '%s' in a new R session", deparse(substitute(fun))[1])
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Rscript_call_+3A_fun">fun</code></td>
<td>
<p>A function, or a character string that can be parsed and evaluated
to a function.</p>
</td></tr>
<tr><td><code id="Rscript_call_+3A_args">args</code></td>
<td>
<p>A list of argument values.</p>
</td></tr>
<tr><td><code id="Rscript_call_+3A_options">options</code></td>
<td>
<p>A character vector of options to passed to <code><a href="#topic+Rscript">Rscript()</a></code>, e.g.,
<code>"--vanilla"</code>.</p>
</td></tr>
<tr><td><code id="Rscript_call_+3A_...">...</code>, <code id="Rscript_call_+3A_wait">wait</code></td>
<td>
<p>Arguments to be passed to <code><a href="base.html#topic+system2">system2()</a></code>.</p>
</td></tr>
<tr><td><code id="Rscript_call_+3A_fail">fail</code></td>
<td>
<p>The desired error message when an error occurred in calling the
function. If the actual error message during running the function is
available, it will be appended to this message.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>wait = TRUE</code>, the returned value of the function in the new R
session. If <code>wait = FALSE</code>, three file paths will be returned: the first
one stores <code>fun</code> and <code>args</code> (as a list), the second one is supposed to
store the returned value of the function, and the third one stores the
possible error message.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>factorial(10)
# should return the same value
xfun::Rscript_call("factorial", list(10))

# the first argument can be either a character string or a function
xfun::Rscript_call(factorial, list(10))

# Run Rscript starting a vanilla R session
xfun::Rscript_call(factorial, list(10), options = c("--vanilla"))
</code></pre>

<hr>
<h2 id='rstudio_type'>Type a character vector into the RStudio source editor</h2><span id='topic+rstudio_type'></span>

<h3>Description</h3>

<p>Use the <span class="pkg">rstudioapi</span> package to insert characters one by one into the
RStudio source editor, as if they were typed by a human.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rstudio_type(x, pause = function() 0.1, mistake = 0, save = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rstudio_type_+3A_x">x</code></td>
<td>
<p>A character vector.</p>
</td></tr>
<tr><td><code id="rstudio_type_+3A_pause">pause</code></td>
<td>
<p>A function to return a number in seconds to pause after typing
each character.</p>
</td></tr>
<tr><td><code id="rstudio_type_+3A_mistake">mistake</code></td>
<td>
<p>The probability of making random mistakes when typing the next
character. A random mistake is a random string typed into the editor and
deleted immediately.</p>
</td></tr>
<tr><td><code id="rstudio_type_+3A_save">save</code></td>
<td>
<p>The probability of saving the document after typing each
character. Note that If a document is not opened from a file, it will never
be saved.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>library(xfun)
if (loadable("rstudioapi") &amp;&amp; rstudioapi::isAvailable()) {
    rstudio_type("Hello, RStudio! xfun::rstudio_type() looks pretty cool!",
        pause = function() runif(1, 0, 0.5), mistake = 0.1)
}
</code></pre>

<hr>
<h2 id='same_path'>Test if two paths are the same after they are normalized</h2><span id='topic+same_path'></span>

<h3>Description</h3>

<p>Compare two paths after normalizing them with the same separator (<code>/</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>same_path(p1, p2, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="same_path_+3A_p1">p1</code>, <code id="same_path_+3A_p2">p2</code></td>
<td>
<p>Two vectors of paths.</p>
</td></tr>
<tr><td><code id="same_path_+3A_...">...</code></td>
<td>
<p>Arguments to be passed to <code><a href="#topic+normalize_path">normalize_path()</a></code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>library(xfun)
same_path("~/foo", file.path(Sys.getenv("HOME"), "foo"))
</code></pre>

<hr>
<h2 id='session_info'>An alternative to sessionInfo() to print session information</h2><span id='topic+session_info'></span>

<h3>Description</h3>

<p>This function tweaks the output of <code><a href="utils.html#topic+sessionInfo">sessionInfo()</a></code>: (1) It adds
the RStudio version information if running in the RStudio IDE; (2) It removes
the information about matrix products, BLAS, and LAPACK; (3) It removes the
names of base R packages; (4) It prints out package versions in a single
group, and does not differentiate between loaded and attached packages.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>session_info(packages = NULL, dependencies = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="session_info_+3A_packages">packages</code></td>
<td>
<p>A character vector of package names, of which the versions
will be printed. If not specified, it means all loaded and attached
packages in the current R session.</p>
</td></tr>
<tr><td><code id="session_info_+3A_dependencies">dependencies</code></td>
<td>
<p>Whether to print out the versions of the recursive
dependencies of packages.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It also allows you to only print out the versions of specified packages (via
the <code>packages</code> argument) and optionally their recursive dependencies.
For these specified packages (if provided), if a function
<code>xfun_session_info()</code> exists in a package, it will be called and
expected to return a character vector to be appended to the output of
<code>session_info()</code>. This provides a mechanism for other packages to inject
more information into the <code>session_info</code> output. For example,
<span class="pkg">rmarkdown</span> (&gt;= 1.20.2) has a function <code>xfun_session_info()</code> that
returns the version of Pandoc, which can be very useful information for
diagnostics.
</p>


<h3>Value</h3>

<p>A character vector of the session information marked as
<code><a href="#topic+raw_string">raw_string()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
xfun::session_info()
if (xfun::loadable("MASS")) xfun::session_info("MASS")

</code></pre>

<hr>
<h2 id='set_envvar'>Set environment variables</h2><span id='topic+set_envvar'></span>

<h3>Description</h3>

<p>Set environment variables from a named character vector, and return the old
values of the variables, so they could be restored later.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_envvar(vars)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="set_envvar_+3A_vars">vars</code></td>
<td>
<p>A named character vector of the form <code>c(VARIABLE = VALUE)</code>.
If any value is <code>NA</code>, this function will try to unset the variable.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The motivation of this function is that <code><a href="base.html#topic+Sys.setenv">Sys.setenv()</a></code> does not
return the old values of the environment variables, so it is not
straightforward to restore the variables later.
</p>


<h3>Value</h3>

<p>Old values of the variables (if not set, <code>NA</code>).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>vars = xfun::set_envvar(c(FOO = "1234"))
Sys.getenv("FOO")
xfun::set_envvar(vars)
Sys.getenv("FOO")
</code></pre>

<hr>
<h2 id='shrink_images'>Shrink images to a maximum width</h2><span id='topic+shrink_images'></span>

<h3>Description</h3>

<p>Use <code><a href="magick.html#topic+transform">magick::image_resize()</a></code> to shrink an
image if its width is larger than the value specified by the argument
<code>width</code>, and optionally call <code><a href="#topic+tinify">tinify()</a></code> to compress it.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>shrink_images(
  width = 800,
  dir = ".",
  files = all_files("[.](png|jpe?g|webp)$", dir),
  tinify = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="shrink_images_+3A_width">width</code></td>
<td>
<p>The desired maximum width of images.</p>
</td></tr>
<tr><td><code id="shrink_images_+3A_dir">dir</code></td>
<td>
<p>The directory of images.</p>
</td></tr>
<tr><td><code id="shrink_images_+3A_files">files</code></td>
<td>
<p>A vector of image file paths. By default, this is all
&lsquo;<span class="file">.png</span>&rsquo;, &lsquo;<span class="file">.jpeg</span>&rsquo;, and &lsquo;<span class="file">.webp</span>&rsquo; images under <code>dir</code>.</p>
</td></tr>
<tr><td><code id="shrink_images_+3A_tinify">tinify</code></td>
<td>
<p>Whether to compress images using <code><a href="#topic+tinify">tinify()</a></code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>f = xfun:::all_files("[.](png|jpe?g)$", R.home("doc"))
file.copy(f, tempdir())
f = file.path(tempdir(), basename(f))
magick::image_info(magick::image_read(f))  # some widths are larger than 300
xfun::shrink_images(300, files = f)
magick::image_info(magick::image_read(f))  # all widths &lt;= 300 now
file.remove(f)
</code></pre>

<hr>
<h2 id='split_lines'>Split a character vector by line breaks</h2><span id='topic+split_lines'></span>

<h3>Description</h3>

<p>Call <code>unlist(strsplit(x, '\n'))</code> on the character vector <code>x</code> and
make sure it works in a few edge cases: <code>split_lines('')</code> returns
<code>''</code> instead of <code>character(0)</code> (which is the returned value of
<code>strsplit('', '\n')</code>); <code>split_lines('a\n')</code> returns <code>c('a', '')</code> instead of <code>c('a')</code> (which is the returned value of
<code>strsplit('a\n', '\n')</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>split_lines(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="split_lines_+3A_x">x</code></td>
<td>
<p>A character vector.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>All elements of the character vector are split by <code>'\n'</code> into
lines.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>xfun::split_lines(c("a", "b\nc"))
</code></pre>

<hr>
<h2 id='split_source'>Split source lines into complete expressions</h2><span id='topic+split_source'></span>

<h3>Description</h3>

<p>Parse the lines of code one by one to find complete expressions in the code,
and put them in a list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>split_source(x, merge_comments = FALSE, line_number = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="split_source_+3A_x">x</code></td>
<td>
<p>A character vector of R source code.</p>
</td></tr>
<tr><td><code id="split_source_+3A_merge_comments">merge_comments</code></td>
<td>
<p>Whether to merge consecutive lines of comments as a
single expression to be combined with the next non-comment expression (if
any).</p>
</td></tr>
<tr><td><code id="split_source_+3A_line_number">line_number</code></td>
<td>
<p>Whether to store the line numbers of each expression in
the returned value.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of character vectors, and each vector contains a complete R
expression, with an attribute <code>lines</code> indicating the starting and ending
line numbers of the expression if the argument <code>line_number = TRUE</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>code = c("# comment 1", "# comment 2", "if (TRUE) {", "1 + 1", "}", "print(1:5)")
xfun::split_source(code)
xfun::split_source(code, merge_comments = TRUE)
</code></pre>

<hr>
<h2 id='strict_list'>Strict lists</h2><span id='topic+strict_list'></span><span id='topic+as_strict_list'></span><span id='topic++24.xfun_strict_list'></span><span id='topic+print.xfun_strict_list'></span>

<h3>Description</h3>

<p>A strict list is essentially a normal <code><a href="base.html#topic+list">list()</a></code> but it does not
allow partial matching with <code>$</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>strict_list(...)

as_strict_list(x)

## S3 method for class 'xfun_strict_list'
x$name

## S3 method for class 'xfun_strict_list'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="strict_list_+3A_...">...</code></td>
<td>
<p>Objects (list elements), possibly named. Ignored in the
<code>print()</code> method.</p>
</td></tr>
<tr><td><code id="strict_list_+3A_x">x</code></td>
<td>
<p>For <code>as_strict_list()</code>, the object to be coerced to a strict
list.
</p>
<p>For <code>print()</code>, a strict list.</p>
</td></tr>
<tr><td><code id="strict_list_+3A_name">name</code></td>
<td>
<p>The name (a character string) of the list element.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>To me, partial matching is often more annoying and surprising than
convenient. It can lead to bugs that are very hard to discover, and I have
been bitten by it many times. When I write <code>x$name</code>, I always mean
precisely <code>name</code>. You should use a modern code editor to autocomplete
the <code>name</code> if it is too long to type, instead of using partial names.
</p>


<h3>Value</h3>

<p>Both <code>strict_list()</code> and <code>as_strict_list()</code> return a list
with the class <code>xfun_strict_list</code>. Whereas <code>as_strict_list()</code>
attempts to coerce its argument <code>x</code> to a list if necessary,
<code>strict_list()</code> just wraps its argument <code>...</code> in a list, i.e., it
will add another list level regardless if <code>...</code> already is of type
list.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(xfun)
(z = strict_list(aaa = "I am aaa", b = 1:5))
z$a  # NULL!
z$aaa  # I am aaa
z$b
z$c = "create a new element"

z2 = unclass(z)  # a normal list
z2$a  # partial matching

z3 = as_strict_list(z2)  # a strict list again
z3$a  # NULL again!
</code></pre>

<hr>
<h2 id='strip_html'>Strip HTML tags</h2><span id='topic+strip_html'></span>

<h3>Description</h3>

<p>Remove HTML tags and comments from text.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>strip_html(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="strip_html_+3A_x">x</code></td>
<td>
<p>A character vector.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector with HTML tags and comments stripped off.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>xfun::strip_html("&lt;a href=\"#\"&gt;Hello &lt;!-- comment --&gt;world!&lt;/a&gt;")
</code></pre>

<hr>
<h2 id='submit_cran'>Submit a source package to CRAN</h2><span id='topic+submit_cran'></span>

<h3>Description</h3>

<p>Build a source package and submit it to CRAN with the <span class="pkg">curl</span> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>submit_cran(file = pkg_build(), comment = "")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="submit_cran_+3A_file">file</code></td>
<td>
<p>The path to the source package tarball. By default, the current
working directory is treated as the package root directory, and
automatically built into a tarball, which is deleted after submission. This
means you should run <code>xfun::submit_cran()</code> in the root directory of a
package project, unless you want to pass a path explicitly to the
<code>file</code> argument.</p>
</td></tr>
<tr><td><code id="submit_cran_+3A_comment">comment</code></td>
<td>
<p>Submission comments for CRAN. By default, if a file
&lsquo;<span class="file">cran-comments.md</span>&rsquo; exists, its content will be read and used as the
comment.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code>devtools::submit_cran()</code> does the same job, with a few more
dependencies in addition to <span class="pkg">curl</span> (such as <span class="pkg">cli</span>);
<code>xfun::submit_cran()</code> only depends on <span class="pkg">curl</span>.
</p>

<hr>
<h2 id='system3'>Run <code>system2()</code> and mark its character output as UTF-8 if appropriate</h2><span id='topic+system3'></span>

<h3>Description</h3>

<p>This is a wrapper function based on <code>system2()</code>. If <code>system2()</code>
returns character output (e.g., with the argument <code>stdout = TRUE</code>),
check if the output is encoded in UTF-8. If it is, mark it with UTF-8
explicitly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>system3(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="system3_+3A_...">...</code></td>
<td>
<p>Passed to <code><a href="base.html#topic+system2">system2()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The value returned by <code>system2()</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
a = shQuote(c("-e", "print(intToUtf8(c(20320, 22909)))"))
x2 = system2("Rscript", a, stdout = TRUE)
Encoding(x2)  # unknown

x3 = xfun::system3("Rscript", a, stdout = TRUE)
# encoding of x3 should be UTF-8 if the current locale is UTF-8
!l10n_info()[["UTF-8"]] || Encoding(x3) == "UTF-8"  # should be TRUE

</code></pre>

<hr>
<h2 id='tinify'>Use the Tinify API to compress PNG and JPEG images</h2><span id='topic+tinify'></span><span id='topic+tinify_dir'></span>

<h3>Description</h3>

<p>Compress PNG/JPEG images with &lsquo;<span class="samp">&#8288;api.tinify.com&#8288;</span>&rsquo;, and download the
compressed images. These functions require R packages <span class="pkg">curl</span> and
<span class="pkg">jsonlite</span>. <code>tinify_dir()</code> is a wrapper function of <code>tinify()</code> to
compress images under a directory.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tinify(
  input,
  output,
  quiet = FALSE,
  force = FALSE,
  key = env_option("xfun.tinify.key"),
  history = env_option("xfun.tinify.history")
)

tinify_dir(dir = ".", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tinify_+3A_input">input</code></td>
<td>
<p>A vector of input paths of images.</p>
</td></tr>
<tr><td><code id="tinify_+3A_output">output</code></td>
<td>
<p>A vector of output paths or a function that takes <code>input</code> and
returns a vector of output paths (e.g., <code style="white-space: pre;">&#8288;output = &#8288;</code><code><a href="base.html#topic+identity">identity</a></code> means
<code>output = input</code>). By default, if the <code>history</code> argument is not a provided,
<code>output</code> is <code>input</code> with a suffix <code>-min</code> (e.g., when <code>input = 'foo.png'</code>,
<code>output = 'foo-min.png'</code>), otherwise <code>output</code> is the same as <code>input</code>, which
means the original image files will be overwritten.</p>
</td></tr>
<tr><td><code id="tinify_+3A_quiet">quiet</code></td>
<td>
<p>Whether to suppress detailed information about the compression,
which is of the form &lsquo;<span class="samp">&#8288;input.png (10 Kb) ==&gt; output.png (5 Kb, 50%);
  compression count: 42&#8288;</span>&rsquo;. The percentage after <code>output.png</code> stands for
the compression ratio, and the compression count shows the number of
compressions used for the current month.</p>
</td></tr>
<tr><td><code id="tinify_+3A_force">force</code></td>
<td>
<p>Whether to compress an image again when it appears to have been
compressed before. This argument only makes sense when the <code>history</code>
argument is provided.</p>
</td></tr>
<tr><td><code id="tinify_+3A_key">key</code></td>
<td>
<p>The Tinify API key. It can be set via either the global option
<code>xfun.tinify.key</code> or the environment variable <code>R_XFUN_TINIFY_KEY</code> (see
<code><a href="#topic+env_option">env_option()</a></code>).</p>
</td></tr>
<tr><td><code id="tinify_+3A_history">history</code></td>
<td>
<p>Path to a history file to record the MD5 checksum of
compressed images. If the checksum of an expected output image exists in
this file and <code>force = FALSE</code>, the compression will be skipped. This can
help you avoid unnecessary API calls.</p>
</td></tr>
<tr><td><code id="tinify_+3A_dir">dir</code></td>
<td>
<p>A directory under which all &lsquo;<span class="file">.png</span>&rsquo;, &lsquo;<span class="file">.jpeg</span>&rsquo;, and
&lsquo;<span class="file">.webp</span>&rsquo; files are to be compressed.</p>
</td></tr>
<tr><td><code id="tinify_+3A_...">...</code></td>
<td>
<p>Arguments passed to <code><a href="#topic+tinify">tinify()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>You are recommended to set the API key in &lsquo;<span class="file">.Rprofile</span>&rsquo; or
&lsquo;<span class="file">.Renviron</span>&rsquo;. After that, the only required argument of this function is
<code>input</code>. If the original images can be overwritten by the compressed images,
you may either use <code>output = identity</code>, or set the value of the <code>history</code>
argument in &lsquo;<span class="file">.Rprofile</span>&rsquo; or &lsquo;<span class="file">.Renviron</span>&rsquo;.
</p>


<h3>Value</h3>

<p>The output file paths.
</p>


<h3>References</h3>

<p>Tinify API: <a href="https://tinypng.com/developers">https://tinypng.com/developers</a>.
</p>


<h3>See Also</h3>

<p>The <span class="pkg">tinieR</span> package (<a href="https://github.com/jmablog/tinieR/">https://github.com/jmablog/tinieR/</a>) is a
more comprehensive implementation of the Tinify API, whereas
<code>xfun::tinify()</code> has only implemented the feature of shrinking images.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
f = xfun:::R_logo("jpg$")
xfun::tinify(f)  # remember to set the API key before trying this

</code></pre>

<hr>
<h2 id='tojson'>A simple JSON serializer</h2><span id='topic+tojson'></span><span id='topic+json_vector'></span>

<h3>Description</h3>

<p>A JSON serializer that only works on a limited types of R data (<code>NULL</code>,
lists, logical scalars, character/numeric vectors). A character string of the
class <code>JS_EVAL</code> is treated as raw JavaScript, so will not be quoted. The
function <code>json_vector()</code> converts an atomic R vector to JSON.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tojson(x)

json_vector(x, to_array = FALSE, quote = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tojson_+3A_x">x</code></td>
<td>
<p>An R object.</p>
</td></tr>
<tr><td><code id="tojson_+3A_to_array">to_array</code></td>
<td>
<p>Whether to convert a vector to a JSON array (use <code style="white-space: pre;">&#8288;[]&#8288;</code>).</p>
</td></tr>
<tr><td><code id="tojson_+3A_quote">quote</code></td>
<td>
<p>Whether to double quote the elements.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character string.
</p>


<h3>See Also</h3>

<p>The <span class="pkg">jsonlite</span> package provides a full JSON serializer.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(xfun)
tojson(NULL)
tojson(1:10)
tojson(TRUE)
tojson(FALSE)
cat(tojson(list(a = 1, b = list(c = 1:3, d = "abc"))))
cat(tojson(list(c("a", "b"), 1:5, TRUE)))

# the class JS_EVAL is originally from htmlwidgets::JS()
JS = function(x) structure(x, class = "JS_EVAL")
cat(tojson(list(a = 1:5, b = JS("function() {return true;}"))))
</code></pre>

<hr>
<h2 id='tree'>Turn the output of <code><a href="utils.html#topic+str">str()</a></code> into a tree diagram</h2><span id='topic+tree'></span>

<h3>Description</h3>

<p>The super useful function <code>str()</code> uses <code style="white-space: pre;">&#8288;..&#8288;</code> to indicate the level
of sub-elements of an object, which may be difficult to read. This function
uses vertical pipes to connect all sub-elements on the same level, so it is
clearer which elements belong to the same parent element in an object with a
nested structure (such as a nested list).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tree(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tree_+3A_...">...</code></td>
<td>
<p>Arguments to be passed to <code><a href="utils.html#topic+str">str()</a></code> (note that the
<code>comp.str</code> is hardcoded inside this function, and it is the only
argument that you cannot customize).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character string as a <code><a href="#topic+raw_string">raw_string()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fit = lsfit(1:9, 1:9)
str(fit)
xfun::tree(fit)

fit = lm(dist ~ speed, data = cars)
str(fit)
xfun::tree(fit)

# some trivial examples
xfun::tree(1:10)
xfun::tree(iris)
</code></pre>

<hr>
<h2 id='try_error'>Try an expression and see if it throws an error</h2><span id='topic+try_error'></span>

<h3>Description</h3>

<p>Use <code><a href="base.html#topic+tryCatch">tryCatch()</a></code> to check if an expression throws an error.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>try_error(expr)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="try_error_+3A_expr">expr</code></td>
<td>
<p>An R expression.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>TRUE</code> (error) or <code>FALSE</code> (success).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>xfun::try_error(stop("foo"))  # TRUE
xfun::try_error(1:10)  # FALSE
</code></pre>

<hr>
<h2 id='try_silent'>Try to evaluate an expression silently</h2><span id='topic+try_silent'></span>

<h3>Description</h3>

<p>An abbreviation of <code>try(silent = TRUE)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>try_silent(expr)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="try_silent_+3A_expr">expr</code></td>
<td>
<p>An R expression.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>library(xfun)
z = try_silent(stop("Wrong!"))
inherits(z, "try-error")
</code></pre>

<hr>
<h2 id='upload_ftp'>Upload to an FTP server via <code>curl</code></h2><span id='topic+upload_ftp'></span><span id='topic+upload_win_builder'></span>

<h3>Description</h3>

<p>The function <code>upload_ftp()</code> runs the command <code>curl -T file
server</code> to upload a file to an FTP server if the system command
<code>curl</code> is available, otherwise it uses the R package <span class="pkg">curl</span>. The
function <code>upload_win_builder()</code> uses <code>upload_ftp()</code> to upload
packages to the win-builder server.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>upload_ftp(file, server, dir = "")

upload_win_builder(
  file = pkg_build(),
  version = c("R-devel", "R-release", "R-oldrelease"),
  server = c("ftp", "https"),
  solaris = pkg_available("rhub")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="upload_ftp_+3A_file">file</code></td>
<td>
<p>Path to a local file.</p>
</td></tr>
<tr><td><code id="upload_ftp_+3A_server">server</code></td>
<td>
<p>The address of the FTP server. For <code>upload_win_builder()</code>,
<code>server = 'https'</code> means uploading to
<code>'https://win-builder.r-project.org/upload.aspx'</code>.</p>
</td></tr>
<tr><td><code id="upload_ftp_+3A_dir">dir</code></td>
<td>
<p>The remote directory to which the file should be uploaded.</p>
</td></tr>
<tr><td><code id="upload_ftp_+3A_version">version</code></td>
<td>
<p>The R version(s) on win-builder.</p>
</td></tr>
<tr><td><code id="upload_ftp_+3A_solaris">solaris</code></td>
<td>
<p>Whether to also upload the package to the Rhub server to check
it on Solaris.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions were written mainly to save package developers the trouble of
going to the win-builder web page and uploading packages there manually.
</p>


<h3>Value</h3>

<p>Status code returned from <code><a href="base.html#topic+system2">system2()</a></code> or
<code>curl::curl_fetch_memory()</code>.
</p>

<hr>
<h2 id='upload_imgur'>Upload an image to imgur.com</h2><span id='topic+upload_imgur'></span>

<h3>Description</h3>

<p>This function uses the <span class="pkg">curl</span> package or the system command <code>curl</code>
(whichever is available) to upload a image to <a href="https://imgur.com">https://imgur.com</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>upload_imgur(
  file,
  key = env_option("xfun.upload_imgur.key", "9f3460e67f308f6"),
  use_curl = loadable("curl"),
  include_xml = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="upload_imgur_+3A_file">file</code></td>
<td>
<p>Path to the image file to be uploaded.</p>
</td></tr>
<tr><td><code id="upload_imgur_+3A_key">key</code></td>
<td>
<p>Client ID for Imgur. It can be set via either the global option
<code>xfun.upload_imgur.key</code> or the environment variable
<code>R_XFUN_UPLOAD_IMGUR_KEY</code> (see <code><a href="#topic+env_option">env_option()</a></code>). If neither is set,
this uses a client ID registered by Yihui Xie.</p>
</td></tr>
<tr><td><code id="upload_imgur_+3A_use_curl">use_curl</code></td>
<td>
<p>Whether to use the R package <span class="pkg">curl</span> to upload the image.
If <code>FALSE</code>, the system command <code>curl</code> will be used.</p>
</td></tr>
<tr><td><code id="upload_imgur_+3A_include_xml">include_xml</code></td>
<td>
<p>Whether to include the XML response in the returned value.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>One application is to upload local image files to Imgur when knitting a
document with <span class="pkg">knitr</span>: you can set the <code style="white-space: pre;">&#8288;knitr::opts_knit$set(upload.fun = xfun::upload_imgur&#8288;</code>, so the output document does not need local image files
any more, and it is ready to be published online.
</p>


<h3>Value</h3>

<p>A character string of the link to the image. If <code>include_xml = TRUE</code>,
this string carries an attribute named <code>XML</code>, which is the XML response
from Imgur (it will be parsed by <span class="pkg">xml2</span> if available). See Imgur API in
the references.
</p>


<h3>Note</h3>

<p>Please register your own Imgur application to get your client ID; you
can certainly use mine, but this ID is in the public domain so everyone has
access to all images associated to it.
</p>


<h3>Author(s)</h3>

<p>Yihui Xie, adapted from the <span class="pkg">imguR</span> package by Aaron Statham
</p>


<h3>References</h3>

<p>A demo: <a href="https://yihui.org/knitr/demo/upload/">https://yihui.org/knitr/demo/upload/</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
f = tempfile(fileext = ".png")
png(f)
plot(rnorm(100), main = R.version.string)
dev.off()

res = imgur_upload(f, include_xml = TRUE)
res  # link to original URL of the image
attr(res, "XML")  # all information
if (interactive())
    browseURL(res)

# to use your own key
options(xfun.upload_imgur.key = "your imgur key")

## End(Not run)
</code></pre>

<hr>
<h2 id='url_accessible'>Test if a URL is accessible</h2><span id='topic+url_accessible'></span>

<h3>Description</h3>

<p>Try to send a <code>HEAD</code> request to a URL using
<code><a href="base.html#topic+curlGetHeaders">curlGetHeaders()</a></code> or the <span class="pkg">curl</span> package, and see if it
returns a successful status code.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>url_accessible(x, use_curl = !capabilities("libcurl"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="url_accessible_+3A_x">x</code></td>
<td>
<p>A URL as a character string.</p>
</td></tr>
<tr><td><code id="url_accessible_+3A_use_curl">use_curl</code></td>
<td>
<p>Whether to use the <span class="pkg">curl</span> package or the
<code>curlGetHeaders()</code> function in base R to send the request to the URL.
By default, <span class="pkg">curl</span> will be used when base R does not have the
<code>libcurl</code> capability (which should be rare).</p>
</td></tr>
<tr><td><code id="url_accessible_+3A_...">...</code></td>
<td>
<p>Arguments to be passed to <code>curlGetHeaders()</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>TRUE</code> or <code>FALSE</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>xfun::url_accessible("https://yihui.org")
</code></pre>

<hr>
<h2 id='url_filename'>Extract filenames from a URLs</h2><span id='topic+url_filename'></span>

<h3>Description</h3>

<p>Get the base names of URLs via <code><a href="base.html#topic+basename">basename()</a></code>, and remove the
possible query parameters or hash from the names.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>url_filename(x, default = "index.html")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="url_filename_+3A_x">x</code></td>
<td>
<p>A character vector of URLs.</p>
</td></tr>
<tr><td><code id="url_filename_+3A_default">default</code></td>
<td>
<p>The default filename when it cannot be determined from the
URL, e.g., when the URL ends with a slash.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector of filenames at the end of URLs.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>xfun::url_filename("https://yihui.org/images/logo.png")
xfun::url_filename("https://yihui.org/index.html")
xfun::url_filename("https://yihui.org/index.html?foo=bar")
xfun::url_filename("https://yihui.org/index.html#about")
xfun::url_filename("https://yihui.org")
xfun::url_filename("https://yihui.org/")
</code></pre>

<hr>
<h2 id='valid_syntax'>Check if the syntax of the code is valid</h2><span id='topic+valid_syntax'></span>

<h3>Description</h3>

<p>Try to <code><a href="base.html#topic+parse">parse()</a></code> the code and see if an error occurs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>valid_syntax(code, silent = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="valid_syntax_+3A_code">code</code></td>
<td>
<p>A character vector of R source code.</p>
</td></tr>
<tr><td><code id="valid_syntax_+3A_silent">silent</code></td>
<td>
<p>Whether to suppress the error message when the code is not
valid.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>TRUE</code> if the code could be parsed, otherwise <code>FALSE</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>xfun::valid_syntax("1+1")
xfun::valid_syntax("1+")
xfun::valid_syntax(c("if(T){1+1}", "else {2+2}"), silent = FALSE)
</code></pre>

<hr>
<h2 id='yaml_body'>Partition the YAML metadata and the body in a document</h2><span id='topic+yaml_body'></span>

<h3>Description</h3>

<p>Split a document into the YAML metadata (which starts with <code style="white-space: pre;">&#8288;---&#8288;</code> in the
beginning of the document) and the body. The YAML metadata will be parsed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>yaml_body(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="yaml_body_+3A_x">x</code></td>
<td>
<p>A character vector of the document content.</p>
</td></tr>
<tr><td><code id="yaml_body_+3A_...">...</code></td>
<td>
<p>Arguments to be passed to <code>yaml_load()</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of components <code>yaml</code> (the parsed YAML data), <code>lines</code> (starting
and ending line numbers of YAML), and <code>body</code> (a character vector of the
body text). If YAML metadata does not exist in the document, the components
<code>yaml</code> and <code>lines</code> will be missing.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>xfun::yaml_body(c("---", "title: Hello", "output: markdown::html_document", "---",
    "", "Content."))
</code></pre>

<hr>
<h2 id='yaml_load'>Read YAML data</h2><span id='topic+yaml_load'></span>

<h3>Description</h3>

<p>If the <span class="pkg">yaml</span> package is installed, use <code><a href="yaml.html#topic+yaml.load">yaml::yaml.load()</a></code> to read the
data. If not, use a simple parser instead, which only supports a limited
number of data types (see &ldquo;Examples&rdquo;). In particular, it does not
support values that span across multiple lines (such as multi-line text).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>yaml_load(
  x,
  ...,
  handlers = NULL,
  envir = parent.frame(),
  use_yaml = loadable("yaml")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="yaml_load_+3A_x">x</code></td>
<td>
<p>A character vector of YAML data.</p>
</td></tr>
<tr><td><code id="yaml_load_+3A_...">...</code>, <code id="yaml_load_+3A_handlers">handlers</code></td>
<td>
<p>Arguments to be passed to <code><a href="yaml.html#topic+yaml.load">yaml::yaml.load()</a></code>.</p>
</td></tr>
<tr><td><code id="yaml_load_+3A_envir">envir</code></td>
<td>
<p>The environment in which R expressions in YAML are evaluated. To
disable the evaluation, use <code>envir = FALSE</code>.</p>
</td></tr>
<tr><td><code id="yaml_load_+3A_use_yaml">use_yaml</code></td>
<td>
<p>Whether to use the <span class="pkg">yaml</span> package.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An R object (typically a list).
</p>


<h3>Note</h3>

<p>R expressions in YAML will be returned as <a href="base.html#topic+expression">expression</a>s when they are
not evaluated. This is different with <code><a href="yaml.html#topic+yaml.load">yaml::yaml.load()</a></code>, which returns
character strings for expressions.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># test the simple parser without using the yaml package
read_yaml = function(...) xfun::yaml_load(..., use_yaml = FALSE)
read_yaml("a: 1")
read_yaml("a: 1\nb: \"foo\"\nc: null")
read_yaml("a:\n  b: false\n  c: true\n  d: 1.234\ne: bar")
read_yaml("a: !expr paste(1:10, collapse = \", \")")
read_yaml("a: [1, 3, 4, 2]")
read_yaml("a: [1, \"abc\", 4, 2]")
read_yaml("a: [\"foo\", \"bar\"]")
read_yaml("a: [true, false, true]")
# the other form of array is not supported
read_yaml("a:\n  - b\n  - c")
# and you must use the yaml package
if (loadable("yaml")) yaml_load("a:\n  - b\n  - c")
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
