<!DOCTYPE html><html><head><title>Help for package svines</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {svines}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#returns'><p>Stock returns of 20 companies</p></a></li>
<li><a href='#svine'><p>Stationary vine distribution models</p></a></li>
<li><a href='#svine_bootstrap_models'><p>Bootstrap S-vine models</p></a></li>
<li><a href='#svine_dist'><p>Custom S-vine distribution models</p></a></li>
<li><a href='#svine_hessian'><p>Expected hessian of a parametric S-vine models</p></a></li>
<li><a href='#svine_loglik'><p>Log-likelihood for S-vine models</p></a></li>
<li><a href='#svine_pseudo_residuals'><p>Pseudo-residuals of S-vine models</p></a></li>
<li><a href='#svine_scores'><p>Score function of parametric S-vine models</p></a></li>
<li><a href='#svine_sim'><p>Simulate from a S-vine model</p></a></li>
<li><a href='#svinecop'><p>Stationary vine copula models</p></a></li>
<li><a href='#svinecop_dist'><p>Custom S-vine models</p></a></li>
<li><a href='#svinecop_hessian'><p>Expected hessian for S-vine copula models</p></a></li>
<li><a href='#svinecop_loglik'><p>Log-likelihood for S-vine copula models</p></a></li>
<li><a href='#svinecop_pseudo_residuals'><p>Pseudo-residuals of S-vine copula models</p></a></li>
<li><a href='#svinecop_scores'><p>Log-likelihood scores for S-vine copula models</p></a></li>
<li><a href='#svinecop_sim'><p>Simulate from a S-vine copula model</p></a></li>
<li><a href='#svines-package'><p>svines: Stationary Vine Copula Models</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Stationary Vine Copula Models</td>
</tr>
<tr>
<td>Version:</td>
<td>0.2.3</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides functionality to fit and simulate from stationary vine 
  copula models for time series, see Nagler et al. (2022) 
  &lt;<a href="https://doi.org/10.1016%2Fj.jeconom.2021.11.015">doi:10.1016/j.jeconom.2021.11.015</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/tnagler/svines">https://github.com/tnagler/svines</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/tnagler/svines/issues">https://github.com/tnagler/svines/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.0.0), rvinecopulib (&ge; 0.6.1.1.2)</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp, assertthat, univariateML, wdm, fGarch</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>RcppEigen, Rcpp, RcppThread, BH, wdm, rvinecopulib</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, ggraph, covr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-01-18 16:53:50 UTC; n5</td>
</tr>
<tr>
<td>Author:</td>
<td>Thomas Nagler [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Thomas Nagler &lt;mail@tnagler.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-01-18 17:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='returns'>Stock returns of 20 companies</h2><span id='topic+returns'></span>

<h3>Description</h3>

<p>A dataset containing the log-returns of daily returns of 20 companies. The
observation period is from 2015-01-01 to 2019-12-31.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>returns
</code></pre>


<h3>Format</h3>

<p>A data frame with 1296 rows and 20 variables:
</p>


<h3>Source</h3>

<p>Yahoo finance.
</p>

<hr>
<h2 id='svine'>Stationary vine distribution models</h2><span id='topic+svine'></span>

<h3>Description</h3>

<p>Automated fitting or creation of custom S-vine distribution models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>svine(
  data,
  p,
  margin_families = univariateML::univariateML_models,
  selcrit = "aic",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="svine_+3A_data">data</code></td>
<td>
<p>a matrix or data.frame of data.</p>
</td></tr>
<tr><td><code id="svine_+3A_p">p</code></td>
<td>
<p>the Markov order.</p>
</td></tr>
<tr><td><code id="svine_+3A_margin_families">margin_families</code></td>
<td>
<p>either a vector of <a href="univariateML.html#topic+univariateML">univariateML</a> families to select
from (used for every margin) or a list with one entry for every variable.
Can also be <code>"empirical"</code> for empirical cdfs.</p>
</td></tr>
<tr><td><code id="svine_+3A_selcrit">selcrit</code></td>
<td>
<p>criterion for family selection, either <code>"loglik"</code>, <code>"aic"</code>,
<code>"bic"</code>, <code>"mbicv"</code>.</p>
</td></tr>
<tr><td><code id="svine_+3A_...">...</code></td>
<td>
<p>arguments passed to <code>svinecop()</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the fitted model as an object with classes
<code>svine</code> and <a href="#topic+svine_dist">svine_dist</a>. A list with entries
</p>

<ul>
<li> <p><code style="white-space: pre;">&#8288;$margins&#8288;</code>: list of marginal models from <a href="univariateML.html#topic+univariateML">univariateML</a>,
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;$copula&#8288;</code>: an object of <code>svinecop_dist</code>.
</p>
</li></ul>



<h3>See Also</h3>

<p><a href="#topic+svine_dist">svine_dist</a>, <a href="#topic+svine_loglik">svine_loglik</a>, <a href="#topic+svine_sim">svine_sim</a>, <a href="#topic+svine_bootstrap_models">svine_bootstrap_models</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load data set
data(returns)  

# fit parametric S-vine model with Markov order 1
fit &lt;- svine(returns[1:100, 1:3], p = 1, family_set = "parametric")
fit 
summary(fit)
plot(fit$copula)
contour(fit$copula)
logLik(fit)

pairs(svine_sim(500, rep = 1, fit))
</code></pre>

<hr>
<h2 id='svine_bootstrap_models'>Bootstrap S-vine models</h2><span id='topic+svine_bootstrap_models'></span>

<h3>Description</h3>

<p>Computes bootstrap replicates of a given model using the one-step block
multiplier bootstrap of Nagler et. al (2022).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>svine_bootstrap_models(n_models, model)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="svine_bootstrap_models_+3A_n_models">n_models</code></td>
<td>
<p>number of bootstrap replicates.</p>
</td></tr>
<tr><td><code id="svine_bootstrap_models_+3A_model">model</code></td>
<td>
<p>the initial fitted model</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of length <code>n_models</code>, with each entry representing one
bootstrapped model as object of class <a href="#topic+svine">svine</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(returns)
dat &lt;- returns[1:100, 1:2]

# fit parametric S-vine model with Markov order 1
model &lt;- svine(dat, p = 1, family_set = "parametric")

# compute 10 bootstrap replicates of the model
boot_models &lt;- svine_bootstrap_models(10, model)

# compute bootstrap replicates of 90%-quantile of X_1 + X_2.
mu_boot &lt;- sapply(
  boot_models,
  function(m) {
    xx &lt;- rowSums(t(svine_sim(1, 10^2, m, past = dat)[1, ,]))
    quantile(xx, 0.9)
  }
) 
</code></pre>

<hr>
<h2 id='svine_dist'>Custom S-vine distribution models</h2><span id='topic+svine_dist'></span>

<h3>Description</h3>

<p>Custom S-vine distribution models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>svine_dist(margins, copula)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="svine_dist_+3A_margins">margins</code></td>
<td>
<p>A list of length <code>d</code> containing <code>univariateML</code> objects.</p>
</td></tr>
<tr><td><code id="svine_dist_+3A_copula">copula</code></td>
<td>
<p>the copula model; an object of class <code>svinecop_dist</code> with
cross-sectional dimension <code>d</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the model as an object with class  <code>svine_dist</code>.
A list with entries
</p>

<ul>
<li> <p><code style="white-space: pre;">&#8288;$margins&#8288;</code>: list of marginal models from <a href="univariateML.html#topic+univariateML">univariateML</a>,
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;$copula&#8288;</code>: an object of <code>svinecop_dist</code>.
</p>
</li></ul>



<h3>See Also</h3>

<p><a href="#topic+svine_dist">svine_dist</a>, <a href="#topic+svine_loglik">svine_loglik</a>, <a href="#topic+svine_sim">svine_sim</a>, <a href="#topic+svine_bootstrap_models">svine_bootstrap_models</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## marginal objects
# create dummy univariateML models
univ1 &lt;- univ2 &lt;- univariateML::mlnorm(rnorm(10))

# modify the parameters to N(5, 10) and N(0, 2) distributions
univ1[] &lt;- c(5, 10)
univ2[] &lt;- c(0, 2)

## copula Ã³bject
cs_struct &lt;- cvine_structure(1:2)
pcs &lt;- list(
  list(  # first tree
    bicop_dist("clayton", 0, 3), # cross sectional copula
    bicop_dist("gaussian", 0, -0.1)  # serial copula
  ),
  list(  # second tree
    bicop_dist("gaussian", 0, 0.2), bicop_dist("indep")  
  ),
  list( # third tree
    bicop_dist("indep")
  )
)

cop &lt;- svinecop_dist(
  pcs, cs_struct, p = 1, out_vertices = 1:2, in_vertices = 1:2)
    
model &lt;- svine_dist(margins = list(univ1, univ2), copula = cop)
summary(model)

</code></pre>

<hr>
<h2 id='svine_hessian'>Expected hessian of a parametric S-vine models</h2><span id='topic+svine_hessian'></span>

<h3>Description</h3>

<p>Expected hessian of a parametric S-vine models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>svine_hessian(x, model, cores = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="svine_hessian_+3A_x">x</code></td>
<td>
<p>the data.</p>
</td></tr>
<tr><td><code id="svine_hessian_+3A_model">model</code></td>
<td>
<p>S-vine model (inheriting from <a href="#topic+svine_dist">svine_dist</a>).</p>
</td></tr>
<tr><td><code id="svine_hessian_+3A_cores">cores</code></td>
<td>
<p>number of cores to use.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A returns a <code>k</code>-by-<code>k</code> matrix, where <code>k</code> is the
total number of parameters in the
model. Parameters are ordered as follows:
marginal parameters, copula parameters of first tree, copula parameters of
second tree, etc. Duplicated parameters in the copula model are omitted.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(returns)
dat &lt;- returns[1:100, 1:2]

# fit parametric S-vine model with Markov order 1
model &lt;- svine(dat, p = 1, family_set = "parametric")

# Implementation of asymptotic variances
I &lt;- cov(svine_scores(dat, model))
H &lt;- svine_hessian(dat, model)
Hi &lt;- solve(H)
Hi %*% I %*% t(Hi) / nrow(dat)
</code></pre>

<hr>
<h2 id='svine_loglik'>Log-likelihood for S-vine models</h2><span id='topic+svine_loglik'></span>

<h3>Description</h3>

<p>Log-likelihood for S-vine models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>svine_loglik(x, model, cores = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="svine_loglik_+3A_x">x</code></td>
<td>
<p>the data.</p>
</td></tr>
<tr><td><code id="svine_loglik_+3A_model">model</code></td>
<td>
<p>model inheriting from class <a href="#topic+svine_dist">svine_dist</a>.</p>
</td></tr>
<tr><td><code id="svine_loglik_+3A_cores">cores</code></td>
<td>
<p>number of cores to use; if larger than one, computations are
done in parallel on <code>cores</code> batches .</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the log-likelihood of the data for the model.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load data set
data(returns)  

# fit parametric S-vine model with Markov order 1
fit &lt;- svine(returns[1:100, 1:3], p = 1, family_set = "parametric")

svine_loglik(returns[1:100, 1:3], fit)
</code></pre>

<hr>
<h2 id='svine_pseudo_residuals'>Pseudo-residuals of S-vine models</h2><span id='topic+svine_pseudo_residuals'></span>

<h3>Description</h3>

<p>Pseudo-residuals are defined as the Rosenblatt transform of the data,
conditional on the past. Under a correctly specified model, they are
approximately <em>iid</em> uniform on <code class="reqn">[0, 1]^d</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>svine_pseudo_residuals(x, model, cores = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="svine_pseudo_residuals_+3A_x">x</code></td>
<td>
<p>the data.</p>
</td></tr>
<tr><td><code id="svine_pseudo_residuals_+3A_model">model</code></td>
<td>
<p>model inheriting from class <a href="#topic+svine_dist">svine_dist</a>.</p>
</td></tr>
<tr><td><code id="svine_pseudo_residuals_+3A_cores">cores</code></td>
<td>
<p>number of cores to use; if larger than one, computations are
done in parallel on <code>cores</code> batches .</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a multivariate time series of pseudo-residuals
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load data set
data(returns)  

# convert to pseudo observations with empirical cdf for marginal distributions
u &lt;- pseudo_obs(returns[1:100, 1:3]) 

# fit parametric S-vine copula model with Markov order 1
fit &lt;- svinecop(u, p = 1, family_set = "parametric")

# compute pseudo-residuals
# (should be independent uniform across variables and time)
v &lt;- svinecop_pseudo_residuals(u, fit)
pairs(cbind(v[-1, ], v[-nrow(v), ]))

</code></pre>

<hr>
<h2 id='svine_scores'>Score function of parametric S-vine models</h2><span id='topic+svine_scores'></span>

<h3>Description</h3>

<p>Score function of parametric S-vine models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>svine_scores(x, model, cores = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="svine_scores_+3A_x">x</code></td>
<td>
<p>the data.</p>
</td></tr>
<tr><td><code id="svine_scores_+3A_model">model</code></td>
<td>
<p>S-vine model (inheriting from <a href="#topic+svine_dist">svine_dist</a>).</p>
</td></tr>
<tr><td><code id="svine_scores_+3A_cores">cores</code></td>
<td>
<p>number of cores to use.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A returns a <code>n</code>-by-<code>k</code> matrix, where <code>n = NROW(x)</code> and <code>k</code> is the
total number of parameters in the
model. Parameters are ordered as follows:
marginal parameters, copula parameters of first tree, copula parameters of
second tree, etc. Duplicated parameters in the copula model are omitted.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(returns)
dat &lt;- returns[1:100, 1:2]

# fit parametric S-vine model with Markov order 1
model &lt;- svine(dat, p = 1, family_set = "parametric")

# Implementation of asymptotic variances
I &lt;- cov(svine_scores(dat, model))
H &lt;- svine_hessian(dat, model)
Hi &lt;- solve(H)
Hi %*% I %*% t(Hi) / nrow(dat)
</code></pre>

<hr>
<h2 id='svine_sim'>Simulate from a S-vine model</h2><span id='topic+svine_sim'></span>

<h3>Description</h3>

<p>Simulate from a S-vine model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>svine_sim(n, rep, model, past = NULL, qrng = FALSE, cores = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="svine_sim_+3A_n">n</code></td>
<td>
<p>how many steps of the time series to simulate.</p>
</td></tr>
<tr><td><code id="svine_sim_+3A_rep">rep</code></td>
<td>
<p>number of replications; <code>rep</code> time series of length <code>n</code> are
generated.</p>
</td></tr>
<tr><td><code id="svine_sim_+3A_model">model</code></td>
<td>
<p>a S-vine copula model object (inheriting from <a href="#topic+svinecop_dist">svinecop_dist</a>).</p>
</td></tr>
<tr><td><code id="svine_sim_+3A_past">past</code></td>
<td>
<p>(optional) matrix of past observations. If provided, time series
are simulated conditional on the past.</p>
</td></tr>
<tr><td><code id="svine_sim_+3A_qrng">qrng</code></td>
<td>
<p>if <code>TRUE</code>, generates quasi-random numbers using the multivariate
Generalized Halton sequence up to dimension 300 and the Generalized Sobol
sequence in higher dimensions (default <code>qrng = FALSE</code>).</p>
</td></tr>
<tr><td><code id="svine_sim_+3A_cores">cores</code></td>
<td>
<p>number of cores to use; if larger than one, computations are
done parallel over replications.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code>n</code>-by-<code>d</code>-by<code>rep</code> array, where <code>d</code> is the cross-sectional
dimension of the model. This reduces to an <code>n</code>-by-<code>d</code> matrix if <code>rep == 1</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load data set
data(returns)  
returns &lt;- returns[1:100, 1:3]

# fit parametric S-vine model with Markov order 1
fit &lt;- svine(returns, p = 1, family_set = "parametric")

pairs(returns)  # original data
pairs(svine_sim(100, rep = 1, model = fit))   # simulated data

# simulate the next day conditionally on the past 500 times
pairs(t(svine_sim(1, rep = 100, model = fit, past = returns)[1, , ]))
</code></pre>

<hr>
<h2 id='svinecop'>Stationary vine copula models</h2><span id='topic+svinecop'></span>

<h3>Description</h3>

<p>Automated fitting or creation of custom S-vine copula models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>svinecop(
  data,
  p,
  var_types = rep("c", NCOL(data)),
  family_set = "all",
  cs_structure = NA,
  out_vertices = NA,
  in_vertices = NA,
  type = "S",
  par_method = "mle",
  nonpar_method = "constant",
  mult = 1,
  selcrit = "aic",
  weights = numeric(),
  psi0 = 0.9,
  presel = TRUE,
  trunc_lvl = Inf,
  tree_crit = "tau",
  threshold = 0,
  keep_data = FALSE,
  show_trace = FALSE,
  cores = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="svinecop_+3A_data">data</code></td>
<td>
<p>a matrix or data.frame (copula data should have approximately
uniform margins).</p>
</td></tr>
<tr><td><code id="svinecop_+3A_p">p</code></td>
<td>
<p>the Markov order.</p>
</td></tr>
<tr><td><code id="svinecop_+3A_var_types">var_types</code></td>
<td>
<p>variable types; discrete variables not (yet) allowed.</p>
</td></tr>
<tr><td><code id="svinecop_+3A_family_set">family_set</code></td>
<td>
<p>a character vector of families; see <code><a href="rvinecopulib.html#topic+bicop">rvinecopulib::bicop()</a></code>
for additional options.</p>
</td></tr>
<tr><td><code id="svinecop_+3A_cs_structure">cs_structure</code></td>
<td>
<p>the cross-sectional vine structure (see
<code><a href="rvinecopulib.html#topic+rvine_structure">rvinecopulib::rvine_structure()</a></code>; <code>cs_structure = NA</code> performs automatic
structure selection.</p>
</td></tr>
<tr><td><code id="svinecop_+3A_out_vertices">out_vertices</code></td>
<td>
<p>the out-vertex; if <code>NA</code>, the out-vertex is selected
automatically if no structure is provided, and is equivalent to 1 if a
structure is provided.</p>
</td></tr>
<tr><td><code id="svinecop_+3A_in_vertices">in_vertices</code></td>
<td>
<p>the in-vertex; if <code>NA</code>, the in-vertex is selected
automatically if no structure is provided, and is equivalent to 1 if a
structure is provided.</p>
</td></tr>
<tr><td><code id="svinecop_+3A_type">type</code></td>
<td>
<p>type of stationary vine; <code>"S"</code> (default) for general S-vines,
<code>"D"</code> for Smith's long D-vine, <code>"M"</code> for Beare and Seo's M-vine.</p>
</td></tr>
<tr><td><code id="svinecop_+3A_par_method">par_method</code></td>
<td>
<p>the estimation method for parametric models, either <code>"mle"</code>
for sequential maximum likelihood, <code>"itau"</code> for inversion of Kendall's tau
(only available for one-parameter families and <code>"t"</code>.</p>
</td></tr>
<tr><td><code id="svinecop_+3A_nonpar_method">nonpar_method</code></td>
<td>
<p>the estimation method for nonparametric models, either
<code>"constant"</code> for the standard transformation estimator, or
<code>"linear"</code>/<code>"quadratic"</code> for the local-likelihood approximations of order
one/two.</p>
</td></tr>
<tr><td><code id="svinecop_+3A_mult">mult</code></td>
<td>
<p>multiplier for the smoothing parameters of nonparametric
families. Values larger than 1 make the estimate more smooth, values less
than 1 less smooth.</p>
</td></tr>
<tr><td><code id="svinecop_+3A_selcrit">selcrit</code></td>
<td>
<p>criterion for family selection, either <code>"loglik"</code>, <code>"aic"</code>,
<code>"bic"</code>, <code>"mbic"</code>. For <code>vinecop()</code> there is the additional option
<code>"mbicv"</code>.</p>
</td></tr>
<tr><td><code id="svinecop_+3A_weights">weights</code></td>
<td>
<p>optional vector of weights for each observation.</p>
</td></tr>
<tr><td><code id="svinecop_+3A_psi0">psi0</code></td>
<td>
<p>prior probability of a non-independence copula (only used for
<code>selcrit = "mbic"</code> and <code>selcrit = "mbicv"</code>).</p>
</td></tr>
<tr><td><code id="svinecop_+3A_presel">presel</code></td>
<td>
<p>whether the family set should be thinned out according to
symmetry characteristics of the data.</p>
</td></tr>
<tr><td><code id="svinecop_+3A_trunc_lvl">trunc_lvl</code></td>
<td>
<p>currently unsupported.</p>
</td></tr>
<tr><td><code id="svinecop_+3A_tree_crit">tree_crit</code></td>
<td>
<p>the criterion for tree selection, one of <code>"tau"</code>, <code>"rho"</code>,
<code>"hoeffd"</code>, or <code>"mcor"</code> for Kendall's <code class="reqn">\tau</code>, Spearman's <code class="reqn">\rho</code>,
Hoeffding's <code class="reqn">D</code>, and maximum correlation, respectively.</p>
</td></tr>
<tr><td><code id="svinecop_+3A_threshold">threshold</code></td>
<td>
<p>for thresholded vine copulas; <code>NA</code> indicates that the
threshold should be selected automatically by <code><a href="rvinecopulib.html#topic+mBICV">rvinecopulib::mBICV()</a></code>.</p>
</td></tr>
<tr><td><code id="svinecop_+3A_keep_data">keep_data</code></td>
<td>
<p>whether the data should be stored (necessary for using
<code><a href="stats.html#topic+fitted">fitted()</a></code>).</p>
</td></tr>
<tr><td><code id="svinecop_+3A_show_trace">show_trace</code></td>
<td>
<p>logical; whether a trace of the fitting progress should be
printed.</p>
</td></tr>
<tr><td><code id="svinecop_+3A_cores">cores</code></td>
<td>
<p>number of cores to use; if more than 1, estimation of pair
copulas within a tree is done in parallel.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the fitted model as an object with classes
<code>svinecop</code> and <code>svinecop_dist</code>. Also inherits from <code>vinecop</code>, <code>vinecop_dist</code>
such that many functions from <a href="rvinecopulib.html#topic+rvinecopulib">rvinecopulib</a> can be called.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load data set
data(returns)  

# convert to pseudo observations with empirical cdf for marginal distributions
u &lt;- pseudo_obs(returns[1:100, 1:3]) 

# fit parametric S-vine copula model with Markov order 1
fit &lt;- svinecop(u, p = 1, family_set = "parametric")
fit 
summary(fit)
plot(fit)
contour(fit)
logLik(fit)

pairs(svinecop_sim(500, rep = 1, fit))
</code></pre>

<hr>
<h2 id='svinecop_dist'>Custom S-vine models</h2><span id='topic+svinecop_dist'></span>

<h3>Description</h3>

<p>Custom S-vine models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>svinecop_dist(
  pair_copulas,
  cs_structure,
  p,
  out_vertices,
  in_vertices,
  var_types = rep("c", dim(cs_structure)[1])
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="svinecop_dist_+3A_pair_copulas">pair_copulas</code></td>
<td>
<p>A nested list of 'bicop_dist' objects, where
<code>pair_copulas[[t]][[e]]</code> corresponds to the pair-copula at edge <code>e</code> in tree
<code>t</code>. Only the most-left unique pair copulas are used, others can be omitted.</p>
</td></tr>
<tr><td><code id="svinecop_dist_+3A_cs_structure">cs_structure</code></td>
<td>
<p>The cross-sectional structure. Either a matrix, or an
<code>rvine_structure</code> object; see <code>rvinecopulib::rvine_structure()</code></p>
</td></tr>
<tr><td><code id="svinecop_dist_+3A_p">p</code></td>
<td>
<p>the Markov order.</p>
</td></tr>
<tr><td><code id="svinecop_dist_+3A_out_vertices">out_vertices</code></td>
<td>
<p>the out-vertex; if <code>NA</code>, the out-vertex is selected
automatically if no structure is provided, and is equivalent to 1 if a
structure is provided.</p>
</td></tr>
<tr><td><code id="svinecop_dist_+3A_in_vertices">in_vertices</code></td>
<td>
<p>the in-vertex; if <code>NA</code>, the in-vertex is selected
automatically if no structure is provided, and is equivalent to 1 if a
structure is provided.</p>
</td></tr>
<tr><td><code id="svinecop_dist_+3A_var_types">var_types</code></td>
<td>
<p>variable types; discrete variables not (yet) allowed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the model as an object with classes
<code>svinecop_dist</code>. Also inherits from <code>vinecop_dist</code>
such that many functions from <a href="rvinecopulib.html#topic+rvinecopulib">rvinecopulib</a> can be called.
</p>


<h3>See Also</h3>

<p><a href="#topic+svinecop_loglik">svinecop_loglik</a>, <a href="#topic+svinecop_sim">svinecop_sim</a>, <a href="#topic+svinecop_hessian">svinecop_hessian</a>,
<a href="#topic+svinecop_scores">svinecop_scores</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cs_struct &lt;- cvine_structure(1:2)
pcs &lt;- list(
  list(  # first tree
    bicop_dist("clayton", 0, 3), # cross sectional copula
    bicop_dist("gaussian", 0, -0.1)  # serial copula
  ),
  list(  # second tree
    bicop_dist("gaussian", 0, 0.2), bicop_dist("indep")  
  ),
  list( # third tree
    bicop_dist("indep")
  )
)

cop &lt;- svinecop_dist(
  pcs, cs_struct, p = 1, out_vertices = 1:2, in_vertices = 1:2)
</code></pre>

<hr>
<h2 id='svinecop_hessian'>Expected hessian for S-vine copula models</h2><span id='topic+svinecop_hessian'></span>

<h3>Description</h3>

<p>Expected hessian for S-vine copula models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>svinecop_hessian(u, model, cores = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="svinecop_hessian_+3A_u">u</code></td>
<td>
<p>the data; should have approximately uniform margins..</p>
</td></tr>
<tr><td><code id="svinecop_hessian_+3A_model">model</code></td>
<td>
<p>model inheriting from class <a href="#topic+svinecop_dist">svinecop_dist</a>.</p>
</td></tr>
<tr><td><code id="svinecop_hessian_+3A_cores">cores</code></td>
<td>
<p>number of cores to use; if larger than one, computations are
done in parallel on <code>cores</code> batches .</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the observed Hessian matrix. Rows/columns correspond to to
model parameters in the order: copula parameters of first tree, copula
parameters of second tree, etc. Duplicated parameters in the copula model
are omitted.
</p>


<h3>See Also</h3>

<p><a href="#topic+svinecop_scores">svinecop_scores</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load data set
data(returns)

# convert to uniform margins
u &lt;- pseudo_obs(returns[1:100, 1:3])

# fit parametric S-vine copula model with Markov order 1
fit &lt;- svinecop(u, p = 1, family_set = "parametric")

svinecop_loglik(u, fit)
svinecop_scores(u, fit)
svinecop_hessian(u, fit)
</code></pre>

<hr>
<h2 id='svinecop_loglik'>Log-likelihood for S-vine copula models</h2><span id='topic+svinecop_loglik'></span>

<h3>Description</h3>

<p>Log-likelihood for S-vine copula models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>svinecop_loglik(u, model, cores = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="svinecop_loglik_+3A_u">u</code></td>
<td>
<p>the data; should have approximately uniform margins.</p>
</td></tr>
<tr><td><code id="svinecop_loglik_+3A_model">model</code></td>
<td>
<p>model inheriting from class <a href="#topic+svinecop_dist">svinecop_dist</a>.</p>
</td></tr>
<tr><td><code id="svinecop_loglik_+3A_cores">cores</code></td>
<td>
<p>number of cores to use; if larger than one, computations are
done in parallel on <code>cores</code> batches .</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the log-likelihood of the data for the model.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load data set
data(returns)  

# convert to uniform margins
u &lt;- pseudo_obs(returns[1:100, 1:3])

# fit parametric S-vine copula model with Markov order 1
fit &lt;- svinecop(u, p = 1, family_set = "parametric")

svinecop_loglik(u, fit)
svinecop_scores(u, fit)
svinecop_hessian(u, fit)
</code></pre>

<hr>
<h2 id='svinecop_pseudo_residuals'>Pseudo-residuals of S-vine copula models</h2><span id='topic+svinecop_pseudo_residuals'></span>

<h3>Description</h3>

<p>Pseudo-residuals are defined as the Rosenblatt transform of the data,
conditional on the past. Under a correctly specified model, they are
approximately <em>iid</em> uniform on <code class="reqn">[0, 1]^d</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>svinecop_pseudo_residuals(u, model, cores = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="svinecop_pseudo_residuals_+3A_u">u</code></td>
<td>
<p>the data; should have approximately uniform margins.</p>
</td></tr>
<tr><td><code id="svinecop_pseudo_residuals_+3A_model">model</code></td>
<td>
<p>model inheriting from class <a href="#topic+svinecop_dist">svinecop_dist</a>.</p>
</td></tr>
<tr><td><code id="svinecop_pseudo_residuals_+3A_cores">cores</code></td>
<td>
<p>number of cores to use; if larger than one, computations are
done in parallel on <code>cores</code> batches .</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a multivariate time series of pseudo-residuals
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load data set
data(returns)  

# convert to pseudo observations with empirical cdf for marginal distributions
u &lt;- pseudo_obs(returns[1:100, 1:3]) 

# fit parametric S-vine copula model with Markov order 1
fit &lt;- svinecop(u, p = 1, family_set = "parametric")

# compute pseudo-residuals
# (should be independent uniform across variables and time)
v &lt;- svinecop_pseudo_residuals(u, fit)
pairs(cbind(v[-1, ], v[-nrow(v), ]))

</code></pre>

<hr>
<h2 id='svinecop_scores'>Log-likelihood scores for S-vine copula models</h2><span id='topic+svinecop_scores'></span>

<h3>Description</h3>

<p>Log-likelihood scores for S-vine copula models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>svinecop_scores(u, model, cores = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="svinecop_scores_+3A_u">u</code></td>
<td>
<p>the data; should have approximately uniform margins..</p>
</td></tr>
<tr><td><code id="svinecop_scores_+3A_model">model</code></td>
<td>
<p>model inheriting from class <a href="#topic+svinecop_dist">svinecop_dist</a>.</p>
</td></tr>
<tr><td><code id="svinecop_scores_+3A_cores">cores</code></td>
<td>
<p>number of cores to use; if larger than one, computations are
done in parallel on <code>cores</code> batches .</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix containing the score vectors in its rows, where each
row corresponds to one observation (row in <code>u</code>). The columns correspond
to model parameters in the order:
copula parameters of first tree, copula parameters of
second tree, etc. Duplicated parameters in the copula model are omitted.
</p>


<h3>See Also</h3>

<p><a href="#topic+svinecop_hessian">svinecop_hessian</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load data set
data(returns)  

# convert to uniform margins
u &lt;- pseudo_obs(returns[1:100, 1:3])

# fit parametric S-vine copula model with Markov order 1
fit &lt;- svinecop(u, p = 1, family_set = "parametric")

svinecop_loglik(u, fit)
svinecop_scores(u, fit)
svinecop_hessian(u, fit)
</code></pre>

<hr>
<h2 id='svinecop_sim'>Simulate from a S-vine copula model</h2><span id='topic+svinecop_sim'></span>

<h3>Description</h3>

<p>Simulate from a S-vine copula model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>svinecop_sim(n, rep, model, past = NULL, qrng = FALSE, cores = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="svinecop_sim_+3A_n">n</code></td>
<td>
<p>how many steps of the time series to simulate.</p>
</td></tr>
<tr><td><code id="svinecop_sim_+3A_rep">rep</code></td>
<td>
<p>number of replications; <code>rep</code> time series of length <code>n</code> are
generated.</p>
</td></tr>
<tr><td><code id="svinecop_sim_+3A_model">model</code></td>
<td>
<p>a S-vine copula model object (inheriting from <a href="#topic+svinecop_dist">svinecop_dist</a>).</p>
</td></tr>
<tr><td><code id="svinecop_sim_+3A_past">past</code></td>
<td>
<p>(optional) matrix of past observations. If provided, time series
are simulated conditional on the past.</p>
</td></tr>
<tr><td><code id="svinecop_sim_+3A_qrng">qrng</code></td>
<td>
<p>if <code>TRUE</code>, generates quasi-random numbers using the multivariate
Generalized Halton sequence up to dimension 300 and the Generalized Sobol
sequence in higher dimensions (default <code>qrng = FALSE</code>).</p>
</td></tr>
<tr><td><code id="svinecop_sim_+3A_cores">cores</code></td>
<td>
<p>number of cores to use; if larger than one, computations are
done parallel over replications.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code>n</code>-by-<code>d</code>-by-<code>rep</code> array, where <code>d</code> is the cross-sectional
dimension of the model. This reduces to an <code>n</code>-by-<code>d</code> matrix if <code>rep == 1</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load data set
data(returns)  

# convert to uniform margins
u &lt;- pseudo_obs(returns[1:100, 1:3])

# fit parametric S-vine copula model with Markov order 1
fit &lt;- svinecop(u, p = 1, family_set = "parametric")

pairs(u)   # original data
pairs(svinecop_sim(100, rep = 1, model = fit))   # simulated data

# simulate the next day conditionally on the past 500 times
pairs(t(svinecop_sim(1, rep = 100, model = fit, past = u)[1, , ]))
</code></pre>

<hr>
<h2 id='svines-package'>svines: Stationary Vine Copula Models</h2><span id='topic+svines'></span><span id='topic+svines-package'></span>

<h3>Description</h3>

<p>Provides functionality to fit and simulate from stationary vine copula models for time series, see Nagler et al. (2022) <a href="https://doi.org/10.1016/j.jeconom.2021.11.015">doi:10.1016/j.jeconom.2021.11.015</a>.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Thomas Nagler <a href="mailto:mail@tnagler.com">mail@tnagler.com</a>
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/tnagler/svines">https://github.com/tnagler/svines</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/tnagler/svines/issues">https://github.com/tnagler/svines/issues</a>
</p>
</li></ul>


</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
