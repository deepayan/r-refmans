<!DOCTYPE html><html lang="en"><head><title>Help for package cbcTools</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {cbcTools}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#cbc_balance'><p>Counts of attribute balance</p></a></li>
<li><a href='#cbc_choices'><p>Simulate choices for a survey design</p></a></li>
<li><a href='#cbc_design'><p>Make a choice-based conjoint survey design</p></a></li>
<li><a href='#cbc_overlap'><p>Counts of attribute overlap</p></a></li>
<li><a href='#cbc_power'><p>Estimate the same model on different size subsets of data</p></a></li>
<li><a href='#cbc_profiles'><p>Make a data frame of all combinations of attribute levels</p></a></li>
<li><a href='#cbc_restrict'><p>Obtain a restricted set of profiles</p></a></li>
<li><a href='#miscmethods.cbc_errors'><p>Methods for cbc_errors objects</p></a></li>
<li><a href='#miscmethods.cbc_models'><p>Methods for cbc_models objects</p></a></li>
<li><a href='#plot_compare_power'><p>Plot a comparison of different design powers</p></a></li>
<li><a href='#randLN'><p>Define prior (assumed) model parameter as log-normally-distributed.</p></a></li>
<li><a href='#randN'><p>Define a prior (assumed) model parameter as normally-distributed.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Choice-Based Conjoint Experiment Design Generation and Power
Evaluation in R</td>
</tr>
<tr>
<td>Version:</td>
<td>0.5.0</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>John Helveston &lt;john.helveston@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Design and evaluate choice-based conjoint survey experiments. Generate a variety of survey designs, including random designs, full factorial designs, orthogonal designs, D-optimal designs, and Bayesian D-efficient designs as well as designs with "no choice" options and "labeled" (also known as "alternative specific") designs. Conveniently inspect the design balance and overlap, and simulate choice data for a survey design either randomly or according to a multinomial or mixed logit utility model defined by user-provided prior parameters. Conduct a power analysis for a given survey design by estimating the same model on different subsets of the data to simulate different sample sizes. Full factorial and orthogonal designs are obtained using the 'DoE.base' package (Grömping, 2018) &lt;<a href="https://doi.org/10.18637%2Fjss.v085.i05">doi:10.18637/jss.v085.i05</a>&gt;. D-optimal designs are obtained using the 'AlgDesign' package (Wheeler, 2022) <a href="https://CRAN.R-project.org/package=AlgDesign">https://CRAN.R-project.org/package=AlgDesign</a>. Bayesian D-efficient designs are obtained using the 'idefix' package (Traets et al, 2020) &lt;<a href="https://doi.org/10.18637%2Fjss.v096.i03">doi:10.18637/jss.v096.i03</a>&gt;. Choice simulation and model estimation in power analyses are handled using the 'logitr' package (Helveston, 2023) &lt;<a href="https://doi.org/10.18637%2Fjss.v105.i10">doi:10.18637/jss.v105.i10</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>here, knitr, testthat, tibble</td>
</tr>
<tr>
<td>Imports:</td>
<td>AlgDesign, DoE.base, fastDummies, ggplot2, idefix, logitr (&ge;
1.0.1), MASS, parallel, randtoolbox, rlang, stats, utils</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/jhelvy/cbcTools">https://github.com/jhelvy/cbcTools</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/jhelvy/cbcTools/issues">https://github.com/jhelvy/cbcTools/issues</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-07-11 10:06:34 UTC; jhelvy</td>
</tr>
<tr>
<td>Author:</td>
<td>John Helveston <a href="https://orcid.org/0000-0002-2657-9191"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [cre, aut, cph]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-07-12 22:30:15 UTC</td>
</tr>
</table>
<hr>
<h2 id='cbc_balance'>Counts of attribute balance</h2><span id='topic+cbc_balance'></span>

<h3>Description</h3>

<p>This function prints out a summary of the individual and pairwise counts of
each level for each attribute across all choice questions in the design.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cbc_balance(design)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cbc_balance_+3A_design">design</code></td>
<td>
<p>A data frame of a survey design.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Prints the individual and pairwise counts of the number of times
each attribute levels in shown in the design.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(cbcTools)

# A simple conjoint experiment about apples

# Generate all possible profiles
profiles &lt;- cbc_profiles(
  price     = c(1, 1.5, 2, 2.5, 3, 3.5, 4, 4.5, 5),
  type      = c("Fuji", "Gala", "Honeycrisp"),
  freshness = c('Poor', 'Average', 'Excellent')
)

# Make a survey design from all possible profiles
# (This is the default setting where method = 'full' for "full factorial")
design &lt;- cbc_design(
  profiles = profiles,
  n_resp   = 300, # Number of respondents
  n_alts   = 3,   # Number of alternatives per question
  n_q      = 6    # Number of questions per respondent
)

# Inspect the design balance
cbc_balance(design)

# Inspect the design overlap
cbc_overlap(design)
</code></pre>

<hr>
<h2 id='cbc_choices'>Simulate choices for a survey design</h2><span id='topic+cbc_choices'></span>

<h3>Description</h3>

<p>Simulate choices for a survey design, either randomly or according to a
utility model defined by user-provided prior parameters. All choices are
simulated using the 'logitr' package. For more details see the JSS article
on the 'logitr' package (Helveston, 2023).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cbc_choices(design, obsID = "obsID", priors = NULL, n_draws = 100)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cbc_choices_+3A_design">design</code></td>
<td>
<p>A data frame of a survey design.</p>
</td></tr>
<tr><td><code id="cbc_choices_+3A_obsid">obsID</code></td>
<td>
<p>The name of the column in <code>design</code> that identifies each choice
observation. Defaults to <code>"obsID"</code>.</p>
</td></tr>
<tr><td><code id="cbc_choices_+3A_priors">priors</code></td>
<td>
<p>A list of one or more prior parameters that define a prior
(assumed) utility model used to simulate choices for the <code>survey</code> data frame.
If <code>NULL</code> (the default), choices will be randomly assigned.</p>
</td></tr>
<tr><td><code id="cbc_choices_+3A_n_draws">n_draws</code></td>
<td>
<p>The number of Halton draws to use for simulated choices
for mixed logit models. Defaults to <code>100</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the <code>design</code> data frame with an additional <code>choice</code> column
identifying the simulated choices.
</p>


<h3>References</h3>

<p>Helveston, J. P. (2023). logitr: Fast Estimation of Multinomial and Mixed Logit Models with Preference Space and Willingness-to-Pay Space Utility Parameterizations. Journal of Statistical Software, 105(10), 1–37,
<a href="https://doi.org/10.18637/jss.v105.i10">doi:10.18637/jss.v105.i10</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(cbcTools)

# A simple conjoint experiment about apples

# Generate all possible profiles
profiles &lt;- cbc_profiles(
  price     = c(1, 1.5, 2, 2.5, 3, 3.5, 4, 4.5, 5),
  type      = c("Fuji", "Gala", "Honeycrisp"),
  freshness = c('Poor', 'Average', 'Excellent')
)

# Make a survey design from all possible profiles
# (This is the default setting where method = 'full' for "full factorial")
design &lt;- cbc_design(
  profiles = profiles,
  n_resp   = 300, # Number of respondents
  n_alts   = 3,   # Number of alternatives per question
  n_q      = 6    # Number of questions per respondent
)

# Simulate random choices
data &lt;- cbc_choices(
  design = design,
  obsID  = "obsID"
)

# Simulate choices according to a prior utility model
data &lt;- cbc_choices(
  design = design,
  obsID = "obsID",
  priors = list(
    price     = 0.1,
    type      = c(0.1, 0.2),
    freshness = c(0.1, 0.2)
  )
)

# Simulate choices according to a prior model with interactions
data &lt;- cbc_choices(
  design = design,
  obsID = "obsID",
  priors = list(
    price     = 0.1,
    type      = c(0.1, 0.2),
    freshness = c(0.1, 0.2),
    `price*type` = c(0.1, 0.5)
  )
)

# Simulate choices according to a prior utility model with random parameters
data &lt;- cbc_choices(
  design = design,
  obsID = "obsID",
  priors = list(
    price = 0.1,
    type = randN(mean = c(0.1, 0.2), sd = c(1, 2)),
    freshness = c(0.1, 0.2)
  )
)
</code></pre>

<hr>
<h2 id='cbc_design'>Make a choice-based conjoint survey design</h2><span id='topic+cbc_design'></span>

<h3>Description</h3>

<p>This function creates a data frame containing a choice-based conjoint survey
design where each row is an alternative. Generate a variety of survey
designs, including full factorial designs, orthogonal designs, and Bayesian
D-efficient designs as well as designs with &quot;no choice&quot; options and &quot;labeled&quot;
(also known as &quot;alternative specific&quot;) designs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cbc_design(
  profiles,
  n_resp,
  n_alts,
  n_q,
  n_blocks = 1,
  n_draws = 50,
  n_start = 5,
  no_choice = FALSE,
  label = NULL,
  method = "random",
  priors = NULL,
  prior_no_choice = NULL,
  probs = FALSE,
  keep_d_eff = FALSE,
  keep_db_error = FALSE,
  max_iter = 50,
  parallel = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cbc_design_+3A_profiles">profiles</code></td>
<td>
<p>A data frame in which each row is a possible profile. This
can be generated using the <code>cbc_profiles()</code> function.</p>
</td></tr>
<tr><td><code id="cbc_design_+3A_n_resp">n_resp</code></td>
<td>
<p>Number of survey respondents.</p>
</td></tr>
<tr><td><code id="cbc_design_+3A_n_alts">n_alts</code></td>
<td>
<p>Number of alternatives per choice question.</p>
</td></tr>
<tr><td><code id="cbc_design_+3A_n_q">n_q</code></td>
<td>
<p>Number of questions per respondent.</p>
</td></tr>
<tr><td><code id="cbc_design_+3A_n_blocks">n_blocks</code></td>
<td>
<p>Number of blocks used in Orthogonal or Bayesian D-efficient
designs. Max allowable is one block per respondent. Defaults to <code>1</code>,
meaning every respondent sees the same choice set.</p>
</td></tr>
<tr><td><code id="cbc_design_+3A_n_draws">n_draws</code></td>
<td>
<p>Number of draws used in simulating the prior distribution used
in Bayesian D-efficient designs. Defaults to <code>50</code>.</p>
</td></tr>
<tr><td><code id="cbc_design_+3A_n_start">n_start</code></td>
<td>
<p>A numeric value indicating the number of random start designs
to use in obtaining a Bayesian D-efficient design. The default is <code>5</code>.
Increasing <code>n_start</code> can result in a more efficient design at the expense
of increased computational time.</p>
</td></tr>
<tr><td><code id="cbc_design_+3A_no_choice">no_choice</code></td>
<td>
<p>Include a &quot;no choice&quot; option in the choice sets? Defaults to
<code>FALSE</code>. If <code>TRUE</code>, the total number of alternatives per question will be
one more than the provided <code>n_alts</code> argument.</p>
</td></tr>
<tr><td><code id="cbc_design_+3A_label">label</code></td>
<td>
<p>The name of the variable to use in a &quot;labeled&quot; design (also
called an &quot;alternative-specific design&quot;) such that each set of alternatives
contains one of each of the levels in the <code>label</code> attribute. Currently not
compatible with Bayesian D-efficient designs. If used, the <code>n_alts</code>
argument will be ignored as its value is defined by the unique number of
levels in the <code>label</code> variable. Defaults to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="cbc_design_+3A_method">method</code></td>
<td>
<p>Choose the design method to use: <code>"random"</code>, <code>"full"</code>,
<code>"orthogonal"</code>, <code>"dopt"</code>, <code>"CEA"</code>, or <code>"Modfed"</code>. Defaults to <code>"random"</code>.
See details below for complete description of each method.</p>
</td></tr>
<tr><td><code id="cbc_design_+3A_priors">priors</code></td>
<td>
<p>A list of one or more assumed prior parameters used to generate
a Bayesian D-efficient design. Defaults to <code>NULL</code></p>
</td></tr>
<tr><td><code id="cbc_design_+3A_prior_no_choice">prior_no_choice</code></td>
<td>
<p>Prior utility value for the &quot;no choice&quot; alternative.
Only required if <code>no_choice = TRUE</code>. Defaults to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="cbc_design_+3A_probs">probs</code></td>
<td>
<p>If <code>TRUE</code>, for Bayesian D-efficient designs the resulting design
includes average predicted probabilities for each alternative in each
choice set given the sample from the prior preference distribution.
Defaults to <code>FALSE</code>.'</p>
</td></tr>
<tr><td><code id="cbc_design_+3A_keep_d_eff">keep_d_eff</code></td>
<td>
<p>If <code>TRUE</code>, for D-optimal designs (<code>method = "dopt"</code>) the
returned object will be a list containing the design and the D-efficiency
score. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="cbc_design_+3A_keep_db_error">keep_db_error</code></td>
<td>
<p>If <code>TRUE</code>, for Bayesian D-efficient designs the
returned object will be a list containing the design and the DB-error
score. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="cbc_design_+3A_max_iter">max_iter</code></td>
<td>
<p>A numeric value indicating the maximum number allowed
iterations when searching for a Bayesian D-efficient design. The default is
50.</p>
</td></tr>
<tr><td><code id="cbc_design_+3A_parallel">parallel</code></td>
<td>
<p>Logical value indicating whether computations should be done
over multiple cores. The default is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>method</code> argument determines the design method used. Options
are:
</p>

<ul>
<li> <p><code>"random"</code>
</p>
</li>
<li> <p><code>"full"</code>
</p>
</li>
<li> <p><code>"orthogonal"</code>
</p>
</li>
<li> <p><code>"dopt"</code>
</p>
</li>
<li> <p><code>"CEA"</code>
</p>
</li>
<li> <p><code>"Modfed"</code>
</p>
<p>All methods ensure that the two following criteria are met:
</p>

<ol>
<li><p> No two profiles are the same within any one choice set.
</p>
</li>
<li><p> No two choice sets are the same within any one respondent.
</p>
</li></ol>

<p>The table below summarizes method compatibility with other design options,
including the ability to include a &quot;no choice&quot; option, the creation of a
&quot;labeled&quot; design (also called a &quot;alternative-specific&quot; design), the use
of restricted profile, and the use of blocking.</p>

<table>
<tr>
 <td style="text-align: left;">
   Method </td><td style="text-align: left;"> Include "no choice"? </td><td style="text-align: left;"> Labeled designs? </td><td style="text-align: left;"> Restricted profiles? </td><td style="text-align: left;"> Blocking? </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>"random"</code> </td><td style="text-align: left;"> Yes </td><td style="text-align: left;"> Yes </td><td style="text-align: left;"> Yes </td><td style="text-align: left;"> No </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>"full"</code> </td><td style="text-align: left;"> Yes </td><td style="text-align: left;"> Yes </td><td style="text-align: left;"> Yes </td><td style="text-align: left;"> Yes </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>"orthogonal"</code> </td><td style="text-align: left;"> Yes </td><td style="text-align: left;"> No </td><td style="text-align: left;"> No </td><td style="text-align: left;"> Yes </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>"dopt"</code> </td><td style="text-align: left;"> Yes </td><td style="text-align: left;"> No </td><td style="text-align: left;"> Yes </td><td style="text-align: left;"> Yes </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>"CEA"</code> </td><td style="text-align: left;"> Yes </td><td style="text-align: left;"> No </td><td style="text-align: left;"> No </td><td style="text-align: left;"> Yes </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>"Modfed"</code> </td><td style="text-align: left;"> Yes </td><td style="text-align: left;"> No </td><td style="text-align: left;"> Yes </td><td style="text-align: left;"> Yes </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>The <code>"random"</code> method (the default) creates a design where choice sets are
created by randomly sampling from the full set of <code>profiles</code> *with
*replacement. This means that few (if any) respondents will see the same
sets of choice sets. This method is less efficient than other approaches
and may lead to a deficient experiment in smaller sample sizes, though it
guarantees equal ability to estimate main and interaction effects.
</p>
<p>The <code>"full"</code> method for (&quot;full factorial&quot;) creates a design where choice
sets are created by randomly sampling from the full set of <code>profiles</code>
<em>without replacement</em>. The choice sets are then repeated to meet the
desired number of survey respondents (determined by <code>n_resp</code>). If blocking
is used, choice set blocks are created using mutually exclusive subsets of
<code>profiles</code> within each block. This method produces a design with similar
performance with that of the <code>"random"</code> method, except the choice sets are
repeated and thus there will be many more opportunities for different
respondents to see the same choice sets. This method is less efficient than
other approaches and may lead to a deficient experiment in smaller sample
sizes, though it guarantees equal ability to estimate main and interaction
effects. For more information about blocking with full factorial designs,
see <code>?DoE.base::fac.design</code> as well as the JSS article on the DoE.base
package (Grömping, 2018).
</p>
<p>The <code>"orthogonal"</code> method creates a design where an orthogonal array from
the full set of <code>profiles</code> is found and then choice sets are created by
randomly sampling from this orthogonal array <em>without replacement</em>. The
choice sets are then repeated to meet the desired number of survey
respondents (determined by <code>n_resp</code>). If blocking is used, choice set
blocks are created using mutually exclusive subsets of the orthogonal array
within each block. For cases where an orthogonal array cannot be found, a
full factorial design is used. This approach is also sometimes called a
&quot;main effects&quot; design since orthogonal arrays focus the information on the
main effects at the expense of information about interaction effects. For
more information about orthogonal designs, see <code>?DoE.base::oa.design</code> as
well as the JSS article on the DoE.base package (Grömping, 2018).
</p>
<p>The <code>"dopt"</code> method creates a &quot;D-optimal&quot; design where an array from
<code>profiles</code> is found that maximizes the D-efficiency of a linear model
using the Federov algorithm, with the total number of unique choice sets
determined by <code>n_q*n_blocks</code>. Choice sets are then created by randomly
sampling from this array <em>without replacement</em>. The choice sets are then
repeated to meet the desired number of survey respondents (determined by
<code>n_resp</code>). If blocking is used, choice set blocks are created from the
D-optimal array. For more information about the underlying algorithm
for this method, see <code>?AlgDesign::optFederov</code>.
</p>
<p>The <code>"CEA"</code> and <code>"Modfed"</code> methods use the specified <code>priors</code> to create a
Bayesian D-efficient design for the choice sets, with the total number of
unique choice sets determined by <code>n_q*n_blocks</code>. The choice sets are then
repeated to meet the desired number of survey respondents (determined by
<code>n_resp</code>). If <code>"CEA"</code> or <code>"Modfed"</code> is used without specifying <code>priors</code>, a
prior of all <code>0</code>s will be used and a warning message stating this will be
shown. In the opposite case, if <code>priors</code> are specified but neither Bayesian
method is used, the <code>"CEA"</code> method will be used and a warning stating this
will be shown. Restricted sets of <code>profiles</code> can only be used with
<code>"Modfed"</code>. For more details on Bayesian D-efficient designs, see
<code>?idefix::CEA</code> and <code>?idefix::Modfed</code> as well as the JSS article on the
idefix package (Traets et al, 2020).
</p>
</li></ul>



<h3>Value</h3>

<p>The returned <code>design</code> data frame contains a choice-based conjoint
survey design where each row is an alternative. It includes the following
columns:
</p>

<ul>
<li> <p><code>profileID</code>: Identifies the profile in <code>profiles</code>.
</p>
</li>
<li> <p><code>respID</code>: Identifies each survey respondent.
</p>
</li>
<li> <p><code>qID</code>: Identifies the choice question answered by the respondent.
</p>
</li>
<li> <p><code>altID</code>:Identifies the alternative in any one choice observation.
</p>
</li>
<li> <p><code>obsID</code>: Identifies each unique choice observation across all respondents.
</p>
</li>
<li> <p><code>blockID</code>: If blocking is used, identifies each unique block.
</p>
</li></ul>



<h3>References</h3>

<p>Grömping, U. (2018). R Package DoE.base for Factorial Experiments. Journal of Statistical Software, 85(5), 1–41
<a href="https://doi.org/10.18637/jss.v085.i05">doi:10.18637/jss.v085.i05</a>
</p>
<p>Traets, F., Sanchez, D. G., &amp; Vandebroek, M. (2020). Generating Optimal Designs for Discrete Choice Experiments in R: The idefix Package. Journal of Statistical Software, 96(3), 1–41,
<a href="https://doi.org/10.18637/jss.v096.i03">doi:10.18637/jss.v096.i03</a>
</p>
<p>Wheeler B (2022)._AlgDesign: Algorithmic Experimental Design. R package version 1.2.1,
<a href="https://CRAN.R-project.org/package=AlgDesign">https://CRAN.R-project.org/package=AlgDesign</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(cbcTools)

# A simple conjoint experiment about apples

# Generate all possible profiles
profiles &lt;- cbc_profiles(
  price     = c(1, 1.5, 2, 2.5, 3, 3.5, 4, 4.5, 5),
  type      = c("Fuji", "Gala", "Honeycrisp"),
  freshness = c('Poor', 'Average', 'Excellent')
)

# Make a survey by randomly sampling from all possible profiles
# (This is the default setting where method = 'random')
design_random &lt;- cbc_design(
  profiles = profiles,
  n_resp   = 100, # Number of respondents
  n_alts   = 3,   # Number of alternatives per question
  n_q      = 6    # Number of questions per respondent
)

# Make a survey using a full factorial design and include a "no choice" option
design_full &lt;- cbc_design(
  profiles = profiles,
  n_resp   = 100, # Number of respondents
  n_alts   = 3,   # Number of alternatives per question
  n_q      = 6,   # Number of questions per respondent
  method   = 'full', # Change this to use a different method, e.g. 'orthogonal', or 'dopt'
  no_choice = TRUE
)

# Make a survey by randomly sampling from all possible profiles
# with each level of the "type" attribute appearing as an alternative
design_random_labeled &lt;- cbc_design(
  profiles = profiles,
  n_resp   = 100, # Number of respondents
  n_alts   = 3,   # Number of alternatives per question
  n_q      = 6,   # Number of questions per respondent
  label    = "type"
)

# Make a Bayesian D-efficient design with a prior model specified
# Note that by speed can be improved by setting parallel = TRUE
design_bayesian &lt;- cbc_design(
    profiles  = profiles,
    n_resp    = 100, # Number of respondents
    n_alts    = 3,   # Number of alternatives per question
    n_q       = 6,   # Number of questions per respondent
    n_start   = 1,   # Defaults to 5, set to 1 here for a quick example
    priors = list(
        price     = -0.1,
        type      = c(0.1, 0.2),
        freshness = c(0.1, 0.2)
    ),
    method = "CEA",
    parallel = FALSE
)
</code></pre>

<hr>
<h2 id='cbc_overlap'>Counts of attribute overlap</h2><span id='topic+cbc_overlap'></span>

<h3>Description</h3>

<p>This function prints out a summary of the amount of &quot;overlap&quot; across
attributes within the choice questions. For example, for each attribute, the
count under <code>"1"</code> is the number of choice questions in which the same level
was shown across all alternatives for that attribute (because there was only
one level shown). Likewise, the count under <code>"2"</code> is the number of choice
questions in which only two unique levels of that attribute were shown, and
so on.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cbc_overlap(design)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cbc_overlap_+3A_design">design</code></td>
<td>
<p>A data frame of a survey design.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Prints the counts of the number of choice questions that contain
the unique number of levels for each attribute.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(cbcTools)

# A simple conjoint experiment about apples

# Generate all possible profiles
profiles &lt;- cbc_profiles(
  price     = c(1, 1.5, 2, 2.5, 3, 3.5, 4, 4.5, 5),
  freshness = c("Excellent", "Average", "Poor"),
  type      = c("Fuji", "Gala", "Honeycrisp")
)

# Make a randomized survey design
design &lt;- cbc_design(
  profiles = profiles,
  n_resp   = 300, # Number of respondents
  n_alts   = 3, # Number of alternatives per question
  n_q      = 6 # Number of questions per respondent
)

# Inspect the design balance
cbc_balance(design)

# Inspect the design overlap
cbc_overlap(design)
</code></pre>

<hr>
<h2 id='cbc_power'>Estimate the same model on different size subsets of data</h2><span id='topic+cbc_power'></span>

<h3>Description</h3>

<p>This function estimates the same model multiple times using different size
subsets of a set of choice data and then returns a data frame of the
estimated model coefficients and standard errors for each sample size. This
is useful for determining the required sample size for obtaining a desired
level of statistical power on each coefficient. The number of models to
estimate is set by the <code>nbreaks</code> argument, which breaks up the data into
groups of increasing sample sizes. All models are estimated models using
the 'logitr' package. For more details see the JSS article on the 'logitr'
package (Helveston, 2023).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cbc_power(
  data,
  outcome,
  obsID,
  pars,
  randPars = NULL,
  nbreaks = 10,
  n_q = 1,
  return_models = FALSE,
  panelID = NULL,
  clusterID = NULL,
  robust = FALSE,
  predict = FALSE,
  n_cores = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cbc_power_+3A_data">data</code></td>
<td>
<p>The data, formatted as a <code>data.frame</code> object.</p>
</td></tr>
<tr><td><code id="cbc_power_+3A_outcome">outcome</code></td>
<td>
<p>The name of the column that identifies the outcome variable,
which should be coded with a <code>1</code> for <code>TRUE</code> and <code>0</code> for <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="cbc_power_+3A_obsid">obsID</code></td>
<td>
<p>The name of the column that identifies each observation.</p>
</td></tr>
<tr><td><code id="cbc_power_+3A_pars">pars</code></td>
<td>
<p>The names of the parameters to be estimated in the model.
Must be the same as the column names in the <code>data</code> argument.</p>
</td></tr>
<tr><td><code id="cbc_power_+3A_randpars">randPars</code></td>
<td>
<p>A named vector whose names are the random parameters and
values the distribution: <code>'n'</code> for normal or <code>'ln'</code> for log-normal.
Defaults to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="cbc_power_+3A_nbreaks">nbreaks</code></td>
<td>
<p>The number of different sample size groups.</p>
</td></tr>
<tr><td><code id="cbc_power_+3A_n_q">n_q</code></td>
<td>
<p>Number of questions per respondent. Defaults to <code>1</code> if not
specified.</p>
</td></tr>
<tr><td><code id="cbc_power_+3A_return_models">return_models</code></td>
<td>
<p>If <code>TRUE</code>, a list of all estimated models is returned.
This can be useful if you want to extract other outputs from each model,
such as the variance-covariance matrix, etc. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="cbc_power_+3A_panelid">panelID</code></td>
<td>
<p>The name of the column that identifies the individual (for
panel data where multiple observations are recorded for each individual).
Defaults to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="cbc_power_+3A_clusterid">clusterID</code></td>
<td>
<p>The name of the column that identifies the cluster
groups to be used in model estimation. Defaults to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="cbc_power_+3A_robust">robust</code></td>
<td>
<p>Determines whether or not a robust covariance matrix is
estimated. Defaults to <code>FALSE</code>. Specification of a <code>clusterID</code> will override
the user setting and set this to &lsquo;TRUE&rsquo; (a warning will be displayed in this
case). Replicates the functionality of Stata's cmcmmixlogit.</p>
</td></tr>
<tr><td><code id="cbc_power_+3A_predict">predict</code></td>
<td>
<p>If <code>TRUE</code>, predicted probabilities, fitted values, and
residuals are also included in the returned model objects. Defaults to
<code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="cbc_power_+3A_n_cores">n_cores</code></td>
<td>
<p>The number of cores to use for parallel processing.
Set to <code>1</code> to run serially Defaults to <code>NULL</code>, in which case the number of
cores is set to <code>parallel::detectCores() - 1</code>. Max cores allowed is capped
at <code>parallel::detectCores()</code>.</p>
</td></tr>
<tr><td><code id="cbc_power_+3A_...">...</code></td>
<td>
<p>Other arguments that are passed to <code>logitr::logitr()</code> for model
estimation. See the logitr documentation for details about other
available arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a data frame of estimated model coefficients and standard
errors for the same model estimated on subsets of the <code>data</code> with increasing
sample sizes.
</p>


<h3>References</h3>

<p>Helveston, J. P. (2023). logitr: Fast Estimation of Multinomial and Mixed Logit Models with Preference Space and Willingness-to-Pay Space Utility Parameterizations. Journal of Statistical Software, 105(10), 1–37,
<a href="https://doi.org/10.18637/jss.v105.i10">doi:10.18637/jss.v105.i10</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(cbcTools)

# A simple conjoint experiment about apples

# Generate all possible profiles
profiles &lt;- cbc_profiles(
  price     = c(1, 1.5, 2, 2.5, 3, 3.5, 4, 4.5, 5),
  type      = c("Fuji", "Gala", "Honeycrisp"),
  freshness = c('Poor', 'Average', 'Excellent')
)

# Make a survey design from all possible profiles
# (This is the default setting where method = 'full' for "full factorial")
design &lt;- cbc_design(
  profiles = profiles,
  n_resp   = 300, # Number of respondents
  n_alts   = 3,   # Number of alternatives per question
  n_q      = 6    # Number of questions per respondent
)

# Simulate random choices
data &lt;- cbc_choices(
  design = design,
  obsID  = "obsID"
)

# Conduct a power analysis
power &lt;- cbc_power(
  data    = data,
  pars    = c("price", "type", "freshness"),
  outcome = "choice",
  obsID   = "obsID",
  nbreaks = 10,
  n_q     = 6,
  n_cores = 2
)
</code></pre>

<hr>
<h2 id='cbc_profiles'>Make a data frame of all combinations of attribute levels</h2><span id='topic+cbc_profiles'></span>

<h3>Description</h3>

<p>This function creates a data frame of of all possible combinations of
attribute levels.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cbc_profiles(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cbc_profiles_+3A_...">...</code></td>
<td>
<p>Any number of named vectors defining each attribute and their levels,
e.g. <code>price = c(1, 2, 3)</code>. Separate each vector by a comma.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame of all possible combinations of attribute levels.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(cbcTools)

# Generate all profiles for a simple conjoint experiment about apples
profiles &lt;- cbc_profiles(
  price     = c(1, 1.5, 2, 2.5, 3, 3.5, 4, 4.5, 5),
  type      = c("Fuji", "Gala", "Honeycrisp"),
  freshness = c('Poor', 'Average', 'Excellent')
)
</code></pre>

<hr>
<h2 id='cbc_restrict'>Obtain a restricted set of profiles</h2><span id='topic+cbc_restrict'></span>

<h3>Description</h3>

<p>This function returns a restricted set of profiles as a data frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cbc_restrict(profiles, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cbc_restrict_+3A_profiles">profiles</code></td>
<td>
<p>A data frame in which each row is a possible profile.
This can be generated using the <code>cbc_profiles()</code> function.</p>
</td></tr>
<tr><td><code id="cbc_restrict_+3A_...">...</code></td>
<td>
<p>Any number of restricted pairs of attribute levels, defined as
pairs of logical expressions separated by commas. For example, the
restriction <code>type == 'Fuji' &amp; freshness == 'Poor'</code> will eliminate profiles
such that <code>"Fuji"</code> type apples will never be shown with <code>"Poor"</code> freshness.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A restricted set of profiles as a data frame.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(cbcTools)

# Generate all profiles for a simple conjoint experiment about apples
profiles &lt;- cbc_profiles(
  price     = c(1, 1.5, 2, 2.5, 3, 3.5, 4, 4.5, 5),
  type      = c("Fuji", "Gala", "Honeycrisp"),
  freshness = c('Poor', 'Average', 'Excellent')
)

# Obtain a restricted subset of profiles based on pairs of logical
# expressions. The example below contains the following restrictions:

# - `"Gala"` apples will not be shown with the prices `1.5`, `2.5`, &amp; `3.5`.
# - `"Honeycrisp"` apples will not be shown with prices less than `2`.
# - `"Honeycrisp"` apples will not be shown with the `"Poor"` freshness.
# - `"Fuji"` apples will not be shown with the `"Excellent"` freshness.

profiles_restricted &lt;- cbc_restrict(
    profiles,
    type == "Gala" &amp; price %in% c(1.5, 2.5, 3.5),
    type == "Honeycrisp" &amp; price &gt; 2,
    type == "Honeycrisp" &amp; freshness == "Poor",
    type == "Fuji" &amp; freshness == "Excellent"
)
</code></pre>

<hr>
<h2 id='miscmethods.cbc_errors'>Methods for cbc_errors objects</h2><span id='topic+miscmethods.cbc_errors'></span><span id='topic+plot.cbc_errors'></span>

<h3>Description</h3>

<p>Miscellaneous methods for <code>cbc_errors</code> class objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cbc_errors'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="miscmethods.cbc_errors_+3A_x">x</code></td>
<td>
<p>is an object of class <code>cbc_errors</code>.</p>
</td></tr>
<tr><td><code id="miscmethods.cbc_errors_+3A_...">...</code></td>
<td>
<p>further arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a ggplot2 object plotting standard errors versus sample
size.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(cbcTools)

# A simple conjoint experiment about apples

# Generate all possible profiles
profiles &lt;- cbc_profiles(
  price     = c(1, 1.5, 2, 2.5, 3, 3.5, 4, 4.5, 5),
  type      = c("Fuji", "Gala", "Honeycrisp"),
  freshness = c('Poor', 'Average', 'Excellent')
)

# Make a survey design from all possible profiles
# (This is the default setting where method = 'full' for "full factorial")
design &lt;- cbc_design(
  profiles = profiles,
  n_resp   = 300, # Number of respondents
  n_alts   = 3,   # Number of alternatives per question
  n_q      = 6    # Number of questions per respondent
)

# Simulate random choices
data &lt;- cbc_choices(
  design = design,
  obsID  = "obsID"
)

# Conduct a power analysis
power &lt;- cbc_power(
  data    = data,
  pars    = c("price", "type", "freshness"),
  outcome = "choice",
  obsID   = "obsID",
  nbreaks = 10,
  n_q     = 6
)

# Visualize the results
plot(power)
</code></pre>

<hr>
<h2 id='miscmethods.cbc_models'>Methods for cbc_models objects</h2><span id='topic+miscmethods.cbc_models'></span><span id='topic+print.cbc_models'></span>

<h3>Description</h3>

<p>Miscellaneous methods for <code>cbc_models</code> class objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cbc_models'
print(
  x,
  digits = max(3, getOption("digits") - 2),
  width = getOption("width"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="miscmethods.cbc_models_+3A_x">x</code></td>
<td>
<p>is an object of class <code>cbc_models</code>.</p>
</td></tr>
<tr><td><code id="miscmethods.cbc_models_+3A_digits">digits</code></td>
<td>
<p>the number of digits for printing, defaults to <code>3</code>.</p>
</td></tr>
<tr><td><code id="miscmethods.cbc_models_+3A_width">width</code></td>
<td>
<p>the width of the printing.</p>
</td></tr>
<tr><td><code id="miscmethods.cbc_models_+3A_...">...</code></td>
<td>
<p>further arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, prints a summary of estimated models.
</p>

<hr>
<h2 id='plot_compare_power'>Plot a comparison of different design powers</h2><span id='topic+plot_compare_power'></span>

<h3>Description</h3>

<p>This function creates a ggplot2 object comparing the power curves of
different designs. Each design is color coded and each facet (sub plot)
is a model coefficient.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_compare_power(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_compare_power_+3A_...">...</code></td>
<td>
<p>Any number of data frame containing power results obtained from
the <code>cbc_power()</code> function, separated by commas.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plot comparing the power curves of different designs.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(cbcTools)

# Generate all possible profiles
profiles &lt;- cbc_profiles(
  price     = c(1, 1.5, 2, 2.5, 3),
  type      = c("Fuji", "Gala", "Honeycrisp"),
  freshness = c('Poor', 'Average', 'Excellent')
)

# Make designs to compare: full factorial vs bayesian d-efficient
design_random &lt;- cbc_design(
  profiles = profiles,
  n_resp = 100, n_alts = 3, n_q = 6
)
# Same priors will be used in bayesian design and simulated choices
priors &lt;- list(
  price     = -0.1,
  type      = c(0.1, 0.2),
  freshness = c(0.1, 0.2)
)
design_bayesian &lt;- cbc_design(
  profiles  = profiles,
  n_resp = 100, n_alts = 3, n_q = 6, n_start = 1, method = "CEA",
  priors = priors, parallel = FALSE
)

# Obtain power for each design by simulating choices
power_random &lt;- design_random |&gt;
cbc_choices(obsID = "obsID", priors = priors) |&gt;
  cbc_power(
    pars = c("price", "type", "freshness"),
    outcome = "choice", obsID = "obsID", nbreaks = 5, n_q = 6, n_cores = 2
  )
power_bayesian &lt;- design_bayesian |&gt;
  cbc_choices(obsID = "obsID", priors = priors) |&gt;
  cbc_power(
    pars = c("price", "type", "freshness"),
    outcome = "choice", obsID = "obsID", nbreaks = 5, n_q = 6, n_cores = 2
  )

# Compare power of each design
plot_compare_power(power_bayesian, power_random)

## End(Not run)
</code></pre>

<hr>
<h2 id='randLN'>Define prior (assumed) model parameter as log-normally-distributed.</h2><span id='topic+randLN'></span>

<h3>Description</h3>

<p>Define prior (assumed) model parameter as log-normally-distributed.
Used in the <code>cbc_choices()</code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>randLN(mean = 0, sd = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="randLN_+3A_mean">mean</code></td>
<td>
<p>Mean of the distribution on the log scale, defaults to <code>0</code>.</p>
</td></tr>
<tr><td><code id="randLN_+3A_sd">sd</code></td>
<td>
<p>Standard deviation of the distribution on the log scale,
defaults to <code>1</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list defining log-normally-distributed parameters of the prior
(assumed) utility model used to simulate choices in the <code>cbc_choices()</code>
function.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Insert example
</code></pre>

<hr>
<h2 id='randN'>Define a prior (assumed) model parameter as normally-distributed.</h2><span id='topic+randN'></span>

<h3>Description</h3>

<p>Define a prior (assumed) model parameter as normally-distributed.
Used in the <code>cbc_choices()</code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>randN(mean = 0, sd = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="randN_+3A_mean">mean</code></td>
<td>
<p>Vector of means, defaults to <code>0</code>.</p>
</td></tr>
<tr><td><code id="randN_+3A_sd">sd</code></td>
<td>
<p>Vector of standard deviations, defaults to <code>1</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list defining normally-distributed parameters of the prior
(assumed) utility model used to simulate choices in the <code>cbc_choices()</code>
function.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Insert example
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
