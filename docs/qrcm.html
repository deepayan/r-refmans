<!DOCTYPE html><html><head><title>Help for package qrcm</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {qrcm}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#qrcm-package'>
<p>Quantile Regression Coefficients Modeling</p></a></li>
<li><a href='#diagnose.qc'>
<p>Diagnose Quantile Crossing</p></a></li>
<li><a href='#internals'><p>Internal Functions</p></a></li>
<li><a href='#iqr'>
<p>Quantile Regression Coefficients Modeling</p></a></li>
<li><a href='#iqrL'>
<p>Quantile Regression Coefficients Modeling with Longitudinal Data</p></a></li>
<li><a href='#plf'>
<p>Basis of a Piecewise Linear Function</p></a></li>
<li><a href='#plot.iqr'>
<p>Plot Quantile Regression Coefficients</p></a></li>
<li><a href='#plot.iqrL'>
<p>Plot Quantile Regression Coefficients with Longitudinal Data</p></a></li>
<li><a href='#predict.iqr'>
<p>Prediction After Quantile Regression Coefficients Modeling</p></a></li>
<li><a href='#predict.iqrL'>
<p>Prediction After Quantile Regression Coefficients Modeling with Longitudinal Data</p></a></li>
<li><a href='#qc.control'>
<p>Estimate Non-Crossing Quantile Functions</p></a></li>
<li><a href='#slp'>
<p>Shifted Legendre Polynomials</p></a></li>
<li><a href='#summary.iqr'>
<p>Summary After Quantile Regression Coefficients Modeling</p></a></li>
<li><a href='#summary.iqrL'>
<p>Summary After Quantile Regression Coefficients Modeling With Longitudinal Data</p></a></li>
<li><a href='#test.fit'>
<p>Goodness-of-Fit Test</p></a></li>
<li><a href='#test.fit.iqr'>
<p>Goodness-of-Fit Test</p></a></li>
<li><a href='#test.fit.iqrL'>
<p>Goodness-of-Fit Test</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Quantile Regression Coefficients Modeling</td>
</tr>
<tr>
<td>Version:</td>
<td>3.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-02-13</td>
</tr>
<tr>
<td>Author:</td>
<td>Paolo Frumento &lt;paolo.frumento@unipi.it&gt;</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Paolo Frumento &lt;paolo.frumento@unipi.it&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Parametric modeling of quantile regression coefficient functions.</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, utils, graphics</td>
</tr>
<tr>
<td>Depends:</td>
<td>survival (&ge; 2.4.1), pch (&ge; 2.1), icenReg (&ge; 2.0.15)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-02-13 10:13:51 UTC; a020554</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-02-13 11:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='qrcm-package'>
Quantile Regression Coefficients Modeling
</h2><span id='topic+qrcm-package'></span>

<h3>Description</h3>

<p>This package implements quantile regression coefficient modeling (qrcm), in which the coefficients of a quantile regression model are described by (flexible) parametric functions. The method is described in Frumento and Bottai (2016, 2017); Frumento and Salvati (2021); Frumento, Bottai, and Fernandez-Val (2021); and Hsu, Wen, and Chen (2021). Special functions can be used to diagnose and eliminate quantile crossing (Sottile and Frumento, 2023).
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> qrcm</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 3.1</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2024-02-13</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL-2</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>The function <code><a href="#topic+iqr">iqr</a></code> permits specifying regression models for cross-sectional data, allowing for censored and truncated outcomes. The function <code><a href="#topic+iqrL">iqrL</a></code> can be used to analyze longitudinal data in which the same individuals are observed repeatedly.
</p>
<p>Two special functions, <code><a href="#topic+slp">slp</a></code> and <code><a href="#topic+plf">plf</a></code>, can be used for model building. Auxiliary functions for model summary, prediction, and plotting are provided.
The generic function <code><a href="#topic+test.fit">test.fit</a></code> is used to assess the model fit.
</p>
<p>The function <code><a href="#topic+diagnose.qc">diagnose.qc</a></code> can be applied to
<code>iqr</code> objects to diagnose quantile crossing, and the option <kbd>remove.qc</kbd>
can be used to remove it, using the algorithm described in <code><a href="#topic+qc.control">qc.control</a></code>.
</p>


<h3>Author(s)</h3>

<p>Paolo Frumento
</p>
<p>Maintainer: Paolo Frumento &lt;paolo.frumento@unipi.it&gt;
</p>


<h3>References</h3>

<p>Frumento, P., and Bottai, M. (2016). <em>Parametric modeling of quantile regression coefficient functions</em>. Biometrics, 72 (1), 74-84.
</p>
<p>Frumento, P., and Bottai, M. (2017). <em>Parametric modeling of quantile regression coefficient functions with censored and truncated data</em>. Biometrics, 73 (4), 1179-1188.
</p>
<p>Frumento, P., and Salvati, N. (2021). <em>Parametric modeling of quantile regression coefficient functions with count data</em>. Statistical Methods and Applications, 30, 1237-1258.
</p>
<p>Frumento, P., Bottai, M., and Fernandez-Val, I. (2021). <em>Parametric modeling of quantile regression coefficient functions with longitudinal data</em>. Journal of the American Statistical Association, 116 (534), 783-797.
</p>
<p>Hsu, C.Y., Wen, C.C., and Chen, Y.H. (2021). <em>Quantile function regression analysis for interval censored data, with application to salary survey data</em>. Japanese Journal of Statistics and Data Science, 4, 999-1018.
</p>
<p>Sottile, G., and Frumento, P. (2023). <em>Parametric estimation of non-crossing quantile functions</em>. Statistical Modelling, 23 (2), 173-195.
</p>
<p>Frumento, P., and Corsini, L. (2024). <em>Using parametric quantile regression
to investigate determinants of unemployment duration</em>. Unpublished manuscript.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
 # iqr(y ~ x) # cross-sectional observations
 # iqr(Surv(time, event) ~ x) # right-censored data
 # iqr(Surv(start, stop, event) ~ x) # right-censored and left-truncated data
 # iqr(Surv(time1, time2, type = "interval") ~ x) # interval-censored data
 # iqrL(y ~ x, id = id) # repeated measures
 
 # diagnose.qc(model) # diagnose quantile crossing
 # Use iqr(..., remove.qc = TRUE) to remove crossing

</code></pre>

<hr>
<h2 id='diagnose.qc'>
Diagnose Quantile Crossing
</h2><span id='topic+diagnose.qc'></span>

<h3>Description</h3>

<p>Diagnose quantile crossing in a model estimated with <code><a href="#topic+iqr">iqr</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>diagnose.qc(obj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="diagnose.qc_+3A_obj">obj</code></td>
<td>

<p>an object created with <code><a href="#topic+iqr">iqr</a></code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function determines if quantile crossing occurs in your fitted model, and provides a number of diagnostic tools.
</p>
<p><em>Local</em> quantile crossing is defined by <code>obj$PDF &lt; 0</code>, and is obtained when the quantile function, say <code class="reqn">Q(p | x)</code>, has negative first derivatives at the values of <code class="reqn">p</code> that correspond to the observed data.
<em>Global</em> quantile crossing occurs when the conditional quantile function has negative first derivatives at <em>some</em> values of <code class="reqn">p</code>. To assess global crossing, a grid of approximately 1000 quantiles is used. Note that local crossing is a special case of global crossing.
</p>
<p>The function will assess local and global crossing, and return a summary <kbd>pcross</kbd> of the quantiles at which <em>global</em> crossing occurs. It is important to understand that crossing at extremely low or high quantiles is very common, but may be considered irrelevant in practice. For example, if <em>all</em> observations have crossing quantiles, implying that global crossing is 100%, but crossing only occurs at quantile above  0.999, the fitted model can be safely used for prediction. Very frequently, crossing occurs at extreme quantiles that do not correspond to any observation in the data. 
</p>
<p>This command will also compute a <kbd>crossIndex</kbd>, that represents the average length, across observations, of the sub-intervals <code class="reqn">p*</code> such that <code class="reqn">Q'(p* | x) &lt; 0</code>. For example, if <code class="reqn">Q'(p | x) &lt; 0</code> in the interval <code class="reqn">p* = (0.3,0.5)</code>, the contribution to the <kbd>crossIndex</kbd> is <kbd>0.5 - 0.3 = 0.2</kbd>. If crossing is detected at a single quantile, the interval is assumed to have length <kbd>1e-6</kbd>. In principle, the <kbd>crossIndex</kbd> is always between <kbd>0</kbd> (no quantile crossing) and <kbd>1</kbd> (<em>all</em> observations crossing at <em>all</em> quantiles, which is clearly impossible). In practice, values of <kbd>crossIndex</kbd> greater than 0.05 are relatively rare.
</p>


<h3>Value</h3>

<p>A list with the following items:
</p>
<table>
<tr><td><code>qc</code></td>
<td>
<p>a data frame with two columns <kbd>(qc.local, qc.global)</kbd> containing logical indicators of local and global quantile crossing for each observation in the data.</p>
</td></tr>
<tr><td><code>qc.local</code>, <code>qc.global</code></td>
<td>
<p>the absolute number of observations for which local/global quantile crossing was detected.</p>
</td></tr>
<tr><td><code>pcross</code></td>
<td>
<p>a frequency table of the values of <code class="reqn">p</code> at which global quantile crossing was detected.</p>
</td></tr>
<tr><td><code>crossIndex</code></td>
<td>
<p>the estimated index of crossing described above.</p>
</td></tr>
</table>
<p>If no quantile crossing is detected, <code>pcross = NULL</code>, and <code>crossIndex = 0</code>. 
</p>


<h3>Author(s)</h3>

<p>Paolo Frumento <a href="mailto:paolo.frumento@unipi.it">paolo.frumento@unipi.it</a>
</p>


<h3>References</h3>

<p>Sottile, G., and Frumento, P. (2023). <em>Parametric estimation of non-crossing quantile functions</em>. Statistical Modelling, 23(2), 173-195.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+iqr">iqr</a></code>, <code><a href="#topic+qc.control">qc.control</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> # Using simulated data

 n &lt;- 1000
 x1 &lt;- runif(n,0,3)
 x2 &lt;- rbinom(n,1,0.5)

 u &lt;- runif(n)
 y &lt;- 1*qexp(u) + (2 + 3*u)*x1 + 5*x2
 m &lt;- iqr(y ~ x1 + x2, formula.p = ~ slp(p,7))
 diagnose.qc(m)
</code></pre>

<hr>
<h2 id='internals'>Internal Functions</h2><span id='topic+internals'></span><span id='topic+check.in.iqr'></span><span id='topic+check.in0.iqrL'></span><span id='topic+check.in.iqrL'></span><span id='topic+check.out'></span><span id='topic+start.iqr'></span><span id='topic+start.iqrL'></span><span id='topic+ctiqr.internal'></span><span id='topic+iqrL.internal'></span><span id='topic+iqrL.fit'></span><span id='topic+iqr.ee'></span><span id='topic+ciqr.ee'></span><span id='topic+ctiqr.ee'></span><span id='topic+iciqr.ee'></span><span id='topic+iobjfun'></span><span id='topic+iobjfun.ct'></span><span id='topic+iobjfun.ic'></span><span id='topic+cov.fun.iqr'></span><span id='topic+iqrL.ee'></span><span id='topic+cov.fun.iqrL'></span><span id='topic+iqr.newton'></span><span id='topic+divide.et.impera'></span><span id='topic+iqrL.newton'></span><span id='topic+pmax0'></span><span id='topic+maxind'></span><span id='topic+num.fun'></span><span id='topic+make.bfun'></span><span id='topic+apply_bfun'></span><span id='topic+p.bisec'></span><span id='topic+p.bisec.internal'></span><span id='topic+slp.basis'></span><span id='topic+is.slp'></span><span id='topic+safesolve'></span><span id='topic+middlepoint'></span><span id='topic+iqr.waldtest'></span><span id='topic+extract.p'></span><span id='topic+pred.beta'></span><span id='topic+km'></span><span id='topic+alpha'></span><span id='topic+test.unif.ct'></span><span id='topic+findagoodestimator'></span><span id='topic+quickpred'></span><span id='topic+trans'></span><span id='topic+fitgamma'></span><span id='topic+alpha.bisec'></span><span id='topic+alpha.bisec.out'></span><span id='topic+ks'></span><span id='topic+print.iqr'></span><span id='topic+print.summary.iqr'></span><span id='topic+terms.iqr'></span><span id='topic+model.matrix.iqr'></span><span id='topic+vcov.iqr'></span><span id='topic+nobs.iqr'></span><span id='topic+predict_iqrL.internal'></span><span id='topic+print.iqrL'></span><span id='topic+print.summary.iqrL'></span><span id='topic+terms.iqrL'></span><span id='topic+model.matrix.iqrL'></span><span id='topic+vcov.iqrL'></span><span id='topic+nobs.iqrL'></span><span id='topic+qc.penalty'></span><span id='topic+fixqc'></span><span id='topic+print.qc.iqr'></span>

<h3>Description</h3>

<p>Functions for internal use only, or not yet documented.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
check.in.iqr(mf, formula.p, s)
check.in0.iqrL(mf1, mf2)
check.in.iqrL(mf, y,w,formula.p, s)
check.out(theta, S, covar)
start.iqr(y,z,d, x, weights, bfun, df, yy, zz, s, type = "ctiqr")
start.iqrL(y,x,z,id, w1,w2, bfun1,bfun2, s.theta,s.phi, S1,S2)

ctiqr.internal(mf, cl, formula.p, tol = 1e-06, maxit, s, remove.qc)
iqrL.internal(mf1, mf2, cl, fu,fv, s.theta, s.phi, tol = 1e-5, maxit)
iqrL.fit(theta,phi, y,alpha, x,xw,z,zw, id, w1,w2, bfun1,bfun2, s.theta, s.phi, 
	maxit.theta, safeit.theta, maxit.phi, safeit.phi, eps, tol, maxit)

iqr.ee(theta, y, z, d, X, Xw, bfun, p.star.y, p.star.z, 
  J = TRUE, G, i = FALSE, lambda = 0)
ciqr.ee(theta, y, z, d, X, Xw, bfun, p.star.y, p.star.z, 
  J = TRUE, G, i = FALSE, lambda = 0)
ctiqr.ee(theta, y, z, d, X, Xw, bfun, p.star.y, p.star.z, 
  J = TRUE, G, i = FALSE, lambda = 0)
iciqr.ee(theta, y, z, d, X, Xw, bfun, p.star.y, p.star.z, 
  J = TRUE, G, i = FALSE, lambda = 0)
  
iobjfun(theta, y, X, weights, bfun, p.star)
iobjfun.ct(theta, z,y,d,X,weights, bfun, py, pz, type)
iobjfun.ic(fit, V, bfun)

cov.fun.iqr(theta, y, z, d, X, Xw, weights, bfun, p.star.y, p.star.z, type, s)

iqrL.ee(par, x,xw, bfun, p, g = TRUE, H = TRUE, i = FALSE)
cov.fun.iqrL(fit, x,xw,z,zw, id, w1,w2, bfun1,bfun2, s.theta, s.phi)

iqr.newton(theta, y,z,d,X,Xw, bfun, s, type, tol, maxit, safeit, eps0, lambda = 0)
divide.et.impera(fit, V, bfun, s, type, tol, maxit, safeit, eps0, lambda = 0)
iqrL.newton(par, y,x,xw, bfun, s, tol, maxit, safeit, eps)

pmax0(x)
maxind(A)
num.fun(dx,fx, op = c("int", "der"))
make.bfun(p, x)
apply_bfun(bfun, p, fun = c("bfun", "b1fun"))
p.bisec(theta, y, X, bfun, n.it = 20)
p.bisec.internal(theta, y,X,bp)
slp.basis(k, intercept)
is.slp(f)
safesolve(A,B,lambda)
middlepoint(y)

iqr.waldtest(obj)
extract.p(model, p, cov = FALSE)
pred.beta(model, p, se = FALSE)


km(z,y,d,w, type, exclude = NULL)
alpha(obj, mz, mc, k = 98, zcmodel, Tc, Tz)
test.unif.ct(z,y,d,w, type, exclude = 0.05)
findagoodestimator(dat, w, type = "ctiqr")
quickpred(obj, y, type = c("PDF", "SF"))
trans(z,y,d,w,type)
fitgamma(y,X,w)

alpha.bisec(theta,phi,y,x,z,id,w1,w2,bfun1,bfun2, long = FALSE)
alpha.bisec.out(A, theta,phi,y,x,z,id,w1,w2,bfun1,bfun2, long = FALSE)
ks(u,v,id,w1,w2, K = 25)

## S3 method for class 'iqr'
print(x, digits = max(3L, getOption("digits") - 3L), ...)
## S3 method for class 'summary.iqr'
print(x, digits = max(3L, getOption("digits") - 3L), ...)
## S3 method for class 'iqr'
terms(x, ...)
## S3 method for class 'iqr'
model.matrix(object, ...)
## S3 method for class 'iqr'
vcov(object, ...)
## S3 method for class 'iqr'
nobs(object, ...)


predict_iqrL.internal(object, level, type = c("coef", "CDF", "QF", "sim"), 
  newdata, p, se = FALSE, ...)
## S3 method for class 'iqrL'
print(x, digits = max(3L, getOption("digits") - 3L), ...)
## S3 method for class 'summary.iqrL'
print(x, digits = max(3L, getOption("digits") - 3L), ...)
## S3 method for class 'iqrL'
terms(x, ...)
## S3 method for class 'iqrL'
model.matrix(object, ...)
## S3 method for class 'iqrL'
vcov(object, ...)
## S3 method for class 'iqrL'
nobs(object, ...)

qc.penalty(theta, X, bfun, lambda, pen, H)
fixqc(fit, V, bfun, s, type, tol, maxit, safeit, eps0, 
  lambda, r, maxTry, trace, count, pcross = NULL)
## S3 method for class 'qc.iqr'
print(x, ...)
</code></pre>

<hr>
<h2 id='iqr'>
Quantile Regression Coefficients Modeling
</h2><span id='topic+iqr'></span>

<h3>Description</h3>

<p>This function implements Frumento and Bottai's (2016, 2017) and Hsu, Wen, and Chen's (2021) methods for quantile regression coefficients modeling (qrcm). Quantile regression coefficients are described by (flexible) parametric functions of the order of the quantile. Quantile crossing can be eliminated using the method described in Sottile and Frumento (2023).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>iqr(formula, formula.p = ~ slp(p,3), weights, data, s, 
    tol = 1e-6, maxit, remove.qc = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="iqr_+3A_formula">formula</code></td>
<td>

<p>a two-sided formula of the form <code>y ~ x1 + x2 + ...</code>: 
a symbolic description of the quantile regression model. The left side of the formula
is <code>Surv(time,event)</code> if the data are right-censored; <code>Surv(time,time2,event)</code>
if the data are right-censored and left-truncated (<code>time &lt; time2</code>, <code>time</code> can be <kbd>-Inf</kbd>);
and <code>Surv(time1, time2, type = "interval2")</code> for interval-censored data (use <code>time1 = time2</code> 
for exact observations, <code>time1 = -Inf</code> or <code>NA</code> for left-censored, 
and <code>time2 = Inf</code> or <code>NA</code> for right-censored).
</p>
</td></tr>
<tr><td><code id="iqr_+3A_formula.p">formula.p</code></td>
<td>

<p>a one-sided formula of the form <code>~ b1(p, ...) + b2(p, ...) + ...</code>, describing how 
quantile regression coefficients depend on <kbd>p</kbd>, the order of the quantile.
</p>
</td></tr>
<tr><td><code id="iqr_+3A_weights">weights</code></td>
<td>

<p>an optional vector of weights to be used in the fitting process. The weights will always be normalized
to sum to the sample size. This implies that, for example, using double weights will <em>not</em> halve the standard errors.</p>
</td></tr>
<tr><td><code id="iqr_+3A_data">data</code></td>
<td>

<p>an optional data frame, list or environment containing the variables in <code>formula</code>.
</p>
</td></tr>
<tr><td><code id="iqr_+3A_s">s</code></td>
<td>
<p>an optional 0/1 matrix that permits excluding some model coefficients
(see &lsquo;Examples&rsquo;).</p>
</td></tr>
<tr><td><code id="iqr_+3A_tol">tol</code></td>
<td>

<p>convergence criterion for numerical optimization.
</p>
</td></tr>
<tr><td><code id="iqr_+3A_maxit">maxit</code></td>
<td>

<p>maximum number of iterations.
</p>
</td></tr>
<tr><td><code id="iqr_+3A_remove.qc">remove.qc</code></td>
<td>

<p>either a logical value, or a list created with <code><a href="#topic+qc.control">qc.control</a></code>. See &lsquo;Details&rsquo;.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Quantile regression permits modeling conditional quantiles of a response variabile,
given a set of covariates. A linear model is used to describe the conditional
quantile function:
</p>
<p style="text-align: center;"><code class="reqn">Q(p | x) = \beta_0(p) + \beta_1(p)x_1 + \beta_2(p)x_2 + \ldots.</code>
</p>

<p>The model coefficients <code class="reqn">\beta(p)</code> describe the effect of covariates on the <code class="reqn">p</code>-th
quantile of the response variable. Usually, one or more
quantiles  are estimated, corresponding to different values of <code class="reqn">p</code>.
</p>
<p>Assume that each coefficient can be expressed as a parametric function of <code class="reqn">p</code> of the form:
</p>
<p style="text-align: center;"><code class="reqn">\beta(p | \theta) = \theta_{0} + \theta_1 b_1(p) + \theta_2 b_2(p) + \ldots</code>
</p>

<p>where <code class="reqn">b_1(p), b_2(p, \ldots)</code> are known functions of <code class="reqn">p</code>. 
If <code class="reqn">q</code> is the dimension of 
<code class="reqn">x = (1, x_1, x_2, \ldots)</code> 
and <code class="reqn">k</code> is that of  
<code class="reqn">b(p) = (1, b_1(p), b_2(p), \ldots)</code>, 
the entire conditional quantile function is described by a 
<code class="reqn">q \times k</code> matrix <code class="reqn">\theta</code> of model parameters. 
</p>
<p>Users are required to specify two formulas: <code>formula</code> describes the regression model,
while <code>formula.p</code> identifies the 'basis' <code class="reqn">b(p)</code>. 
By default, <code>formula.p = ~ slp(p, k = 3)</code>, a 3rd-degree shifted 
Legendre polynomial (see <code><a href="#topic+slp">slp</a></code>). Any user-defined function <code class="reqn">b(p, \ldots)</code>
can be used, see &lsquo;Examples&rsquo;.
</p>
<p>If no censoring and truncation are present, estimation of <code class="reqn">\theta</code> is carried out 
by minimizing an objective function that corresponds 
to the integral, with respect to <code class="reqn">p</code>, of the loss function of standard quantile regression. 
Details are in Frumento and Bottai (2016). If the data are censored or truncated, instead,
<code class="reqn">\theta</code> is estimated by solving the estimating equations described in Frumento and Bottai (2017)
and Hsu, Wen, and Chen (2021).
</p>
<p>The option <code>remove.qc</code> applies the method described by Sottile and Frumento (2023) 
to remove quantile crossing. You can either choose <code>remove.qc = TRUE</code>, or use
<code>remove.qc = qc.control(...)</code>, which allows to specify the operational parameters
of the algorithm. Please read <code><a href="#topic+qc.control">qc.control</a></code> for more details on the method,
and use <code><a href="#topic+diagnose.qc">diagnose.qc</a></code> to diagnose quantile crossing.
</p>


<h3>Value</h3>

<p>An object of class &ldquo;<code>iqr</code>&rdquo;, a list containing the following items:
</p>
<table>
<tr><td><code>coefficients</code></td>
<td>
<p>a matrix of estimated model parameters describing the fitted quantile function.</p>
</td></tr>
<tr><td><code>converged</code></td>
<td>
<p>logical. The convergence status.</p>
</td></tr>
<tr><td><code>n.it</code></td>
<td>
<p>the number of iterations.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>the matched call.</p>
</td></tr>
<tr><td><code>obj.function</code></td>
<td>
<p>if the data are neither censored nor truncated, the value of the minimized loss function; otherwise, a meaningful loss function which, however, is not the objective function of the model (see note 3). The number of model parameter is returned as an attribute.</p>
</td></tr>
<tr><td><code>mf</code></td>
<td>
<p>the model frame used.</p>
</td></tr>
<tr><td><code>PDF</code>, <code>CDF</code></td>
<td>
<p>the fitted values of the conditional probability density function (<abbr><span class="acronym">PDF</span></abbr>)
and cumulative distribution function (<abbr><span class="acronym">CDF</span></abbr>). See note 1 for details.</p>
</td></tr>
<tr><td><code>covar</code></td>
<td>
<p>the estimated covariance matrix.</p>
</td></tr>
<tr><td><code>s</code></td>
<td>
<p>the used &lsquo;<kbd>s</kbd>&rsquo; matrix.</p>
</td></tr>
</table>
<p>Use <code><a href="#topic+summary.iqr">summary.iqr</a></code>, <code><a href="#topic+plot.iqr">plot.iqr</a></code>, and <code><a href="#topic+predict.iqr">predict.iqr</a></code>
for summary information, plotting, and predictions from the fitted model. The function
<code><a href="#topic+test.fit">test.fit</a></code> can be used for goodness-of-fit assessment.
The generic accessory functions <code>coefficients</code>, <code>formula</code>, <code>terms</code>, <code>model.matrix</code>, 
<code>vcov</code> are available to extract information from the fitted model. The special function
<code><a href="#topic+diagnose.qc">diagnose.qc</a></code> can be used to diagnose quantile crossing.
</p>


<h3>Note</h3>

<p><strong>NOTE 1 (<kbd>PDF</kbd>, <kbd>CDF</kbd>, quantile crossing, and goodness-of-fit).</strong> 
By expressing quantile regression coefficients as functions of <code class="reqn">p</code>, you practically specify 
a parametric model for the entire conditional distribution. The induced <kbd>CDF</kbd> is the value <code class="reqn">p^*</code>
such that <code class="reqn">y = Q(p^* | x)</code>. The corresponding <kbd>PDF</kbd> is given by <code class="reqn">1/Q'(p^* | x)</code>.
Negative values of <code>PDF</code> indicate quantile crossing, occurring when the estimated quantile function is not
monotonically increasing. If negative <code>PDF</code> values occur for a relatively large proportion of data, 
the model is probably misspecified or ill-defined.
If the model is correct, the fitted <code>CDF</code> should approximately follow a Uniform(0,1) distribution.
This idea is used to implement a goodness-of-fit test, see <code><a href="#topic+test.fit">test.fit</a></code>.
</p>
<p><strong>NOTE 2 (model intercept).</strong> 
The intercept can be excluded from <code>formula</code>, e.g., 
<code>iqr(y ~ -1 + x)</code>. This, however, implies that when <code>x = 0</code>,
<code>y</code> is zero at all quantiles. See example 5 in &lsquo;Examples&rsquo;.
The intercept can also be removed from <code>formula.p</code>. 
This is recommended if the data are bounded. For example, for strictly positive data,
use <code>iqr(y ~ 1, formula.p = -1 + slp(p,3))</code> to force the smallest quantile
to be zero. See example 6 in &lsquo;Examples&rsquo;.
</p>
<p><strong>NOTE 3 (censoring, truncation, and loss function).</strong> 
Data are right-censored when, instead of a response variable <code class="reqn">T</code>, one can only observe
<code class="reqn">Y = min(T,C)</code> and <code class="reqn">d = I(T \le C)</code>. Here, <code class="reqn">C</code> is a censoring variable
that is assumed to be conditionally independent of <code class="reqn">T</code>. Additionally, left truncation occurs if
<code class="reqn">Y</code> can only be observed when it exceeds another random variable <code class="reqn">Z</code>. For example,
in the prevalent sampling design, subjects with a disease are enrolled; those who died
before enrollment are not observed. 
</p>
<p>Ordinary quantile regression minimizes <code class="reqn">L(\beta(p)) = \sum (p - \omega)(t - x'\beta(p))</code>
where <code class="reqn">\omega = I(t \le x'\beta(p))</code>. Equivalently, it solves its first derivative,
<code class="reqn">S(\beta(p)) = \sum x(\omega - p)</code>. The objective function of <code>iqr</code>
is simply the integral of <code class="reqn">L(\beta(p | \theta))</code> with respect to <code class="reqn">p</code>.
</p>
<p>If the data are censored and truncated, <code class="reqn">\omega</code> is replaced by
</p>
<p style="text-align: center;"><code class="reqn">\omega^* = \omega.y + (1 - d)\omega.y(p - 1)/S.y - \omega.z - \omega.z(p - 1)/S.z + p</code>
</p>

<p>where <code class="reqn">\omega.y = I(y \le x'\beta(p))</code>, <code class="reqn">\omega.z = I(z \le x'\beta(p))</code>, <code class="reqn">S.y = P(T &gt; y)</code>,
and <code class="reqn">S.z = P(T &gt; z)</code>. 
The above formula can be obtained from equation (7) of Frumento and Bottai, 2017. 
Replacing <code class="reqn">\omega</code> with <code class="reqn">\omega^*</code> in <code class="reqn">L(\beta(p))</code> is <strong>NOT</strong> equivalent 
to replacing <code class="reqn">\omega</code> with <code class="reqn">\omega^*</code> in <code class="reqn">S(\beta(p))</code>.


The latter option leads to a much simpler computation, and generates the estimating 
equation used by <code>iqr</code>. This means that, if the data are censored or truncated, 
the <kbd>obj.function</kbd> returned by <code>iqr</code> is <strong>NOT</strong> the objective function being
minimized, and should not be used to compare models. However, if one of two models has a much larger
value of the <kbd>obj.function</kbd>, this may be a sign of severe misspecification or poor convergence.
</p>
<p>If the data are interval-censored, the loss function is obtained as the average between the loss calculated on the lower end of the interval, and that calculated on the upper end. The presence of right- or left-censored observations is handled as described above.
</p>


<h3>Author(s)</h3>

<p>Paolo Frumento <a href="mailto:paolo.frumento@unipi.it">paolo.frumento@unipi.it</a>
</p>


<h3>References</h3>

<p>Frumento, P., and Bottai, M. (2016). <em>Parametric modeling of quantile regression coefficient functions</em>. Biometrics, 72 (1), 74-84.
</p>
<p>Frumento, P., and Bottai, M. (2017). <em>Parametric modeling of quantile regression coefficient functions with censored and truncated data</em>. Biometrics, 73 (4), 1179-1188.
</p>
<p>Frumento, P., and Salvati, N. (2021). <em>Parametric modeling of quantile regression coefficient functions with count data</em>. Statistical Methods and Applications, 30, 1237-1258.
</p>
<p>Hsu, C.Y., Wen, C.C., and Chen, Y.H. (2021). <em>Quantile function regression analysis for interval censored data, with application to salary survey data</em>. Japanese Journal of Statistics and Data Science, 4, 999-1018.
</p>
<p>Sottile, G., and Frumento, P. (2023). <em>Parametric estimation of non-crossing quantile functions</em>. Statistical Modelling, 23 (2), 173-195.
</p>
<p>Frumento, P., and Corsini, L. (2024). <em>Using parametric quantile regression
to investigate determinants of unemployment duration</em>. Unpublished manuscript.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+summary.iqr">summary.iqr</a></code>, <code><a href="#topic+plot.iqr">plot.iqr</a></code>, <code><a href="#topic+predict.iqr">predict.iqr</a></code>,
for summary, plotting, and prediction, and <code><a href="#topic+test.fit.iqr">test.fit.iqr</a></code> for goodness-of-fit assessment;
<code><a href="#topic+plf">plf</a></code> and <code><a href="#topic+slp">slp</a></code> to define <code class="reqn">b(p)</code>
to be a piecewise linear function and a shifted Legendre polynomial basis, respectively;
<code><a href="#topic+diagnose.qc">diagnose.qc</a></code> to diagnose quantile crossing.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  ##### Using simulated data in all examples


  ##### Example 1
  
  n &lt;- 1000
  x &lt;- runif(n)
  y &lt;- rnorm(n, 1 + x, 1 + x)
  # true quantile function: Q(p | x) = beta0(p) + beta1(p)*x, with 
    # beta0(p) = beta1(p) = 1 + qnorm(p)
                              
  # fit the true model: b(p) = (1 , qnorm(p))
  m1 &lt;- iqr(y ~ x, formula.p = ~ I(qnorm(p)))
  # the fitted quantile regression coefficient functions are
    # beta0(p) = m1$coef[1,1] + m1$coef[1,2]*qnorm(p)
    # beta1(p) = m1$coef[2,1] + m1$coef[2,2]*qnorm(p)
  
  # a basis b(p) = (1, p), i.e., beta(p) is assumed to be a linear function of p
  m2 &lt;- iqr(y ~ x, formula.p = ~ p)

  # a 'rich' basis b(p) = (1, p, p^2, log(p), log(1 - p))
  m3 &lt;- iqr(y ~ x, formula.p = ~ p + I(p^2) + I(log(p)) + I(log(1 - p)))

  # 'slp' creates an orthogonal spline basis using shifted Legendre polynomials
  m4 &lt;- iqr(y ~ x, formula.p = ~ slp(p, k = 3)) # note that this is the default
  
  # 'plf' creates the basis of a piecewise linear function
  m5 &lt;- iqr(y ~ x, formula.p = ~ plf(p, knots = c(0.1,0.9)))

  
  summary(m1)
  summary(m1, p = c(0.25,0.5,0.75))
  test.fit(m1)
  par(mfrow = c(1,2)); plot(m1, ask = FALSE)
  # see the documentation for 'summary.iqr', 'test.fit.iqr', and 'plot.iqr'
  



  ##### Example 2 ### excluding coefficients
  
  n &lt;- 1000
  x &lt;- runif(n)
  qy &lt;- function(p,x){(1 + qnorm(p)) + (1 + log(p))*x}
  # true quantile function: Q(p | x) = beta0(p) + beta1(p)*x, with
    # beta0(p) = 1 + qnorm(p) 
    # beta1(p) = 1 + log(p)
  
  y &lt;- qy(runif(n), x) # to generate y, plug uniform p in qy(p,x) 
  iqr(y ~ x, formula.p = ~ I(qnorm(p)) + I(log(p)))

  # I would like to exclude log(p) from beta0(p), and qnorm(p) from beta1(p)
  # I set to 0 the corresponding entries of 's'

  s &lt;- matrix(1,2,3); s[1,3] &lt;- s[2,2] &lt;- 0
  iqr(y ~ x, formula.p = ~ I(qnorm(p)) + I(log(p)), s = s)


  

  ##### Example 3 ### excluding coefficients when b(p) is singular
  
  n &lt;- 1000
  x &lt;- runif(n)
  qy &lt;- function(p,x){(1 + log(p) - 2*log(1 - p)) + (1 + log(p/(1 - p)))*x} 
  # true quantile function: Q(p | x) = beta0(p) + beta1(p)*x, with
    # beta0(p) = 1 + log(p) - 2*log(1 - p)
    # beta1(p) = 1 + log(p/(1 - p))

  y &lt;- qy(runif(n), x) # to generate y, plug uniform p in qy(p,x)

  iqr(y ~ x, formula.p = ~ I(log(p)) + I(log(1 - p)) + I(log(p/(1 - p))))
  # log(p/(1 - p)) is dropped due to singularity
  
  # I want beta0(p) to be a function of log(p) and log(1 - p),
  # and beta1(p) to depend on log(p/(1 - p)) alone

  s &lt;- matrix(1,2,4); s[2,2:3] &lt;- 0
  iqr(y ~ x, formula.p = ~ I(log(p)) + I(log(1 - p)) + I(log(p/(1 - p))), s = s)
  # log(p/(1 - p)) is not dropped




  ##### Example 4 ### using slp to test deviations from normality
  
  n &lt;- 1000
  x &lt;- runif(n)
  y &lt;- rnorm(n, 2 + x) 
  # the true model is normal, i.e., b(p) = (1, qnorm(p))
  
  summary(iqr(y ~ x, formula.p = ~ I(qnorm(p)) + slp(p,3))) 
  # if slp(p,3) is not significant, no deviation from normality




  ##### Example 5 ### formula without intercept
  
  n &lt;- 1000
  x &lt;- runif(n)
  y &lt;- runif(n, 0,x) 

  # True quantile function: Q(p | x) = p*x, i.e., beta0(p) = 0, beta1(p) = p
  # When x = 0, all quantiles of y are 0, i.e., the distribution is degenerated
  # To explicitly model this, remove the intercept from 'formula'
  
  iqr(y ~ -1 + x, formula.p = ~ p)
  
  # the true model does not have intercept in b(p) either:

  iqr(y ~ -1 + x, formula.p = ~ -1 + p)




  ##### Example 6 ### no covariates, strictly positive outcome
  
  n &lt;- 1000
  y &lt;- rgamma(n, 3,1) 

  # you know that Q(0) = 0
  # remove intercept from 'formula.p', and use b(p) such that b(0) = 0
  
  summary(iqr(y ~ 1, formula.p = ~ -1 + slp(p,5))) # shifted Legendre polynomials
  summary(iqr(y ~ 1, formula.p = ~ -1 + sin(p*pi/2) + I(qbeta(p,2,4)))) # unusual basis
  summary(iqr(y ~ 1, formula.p = ~ -1 + I(sqrt(p))*I(log(1 - p)))) # you can include interactions




  ##### Example 7 ### revisiting the classical linear model
  
  n &lt;- 1000
  x &lt;- runif(n)
  y &lt;- 2 + 3*x + rnorm(n,0,1) # beta0 = 2, beta1 = 3
  
  iqr(y ~ x, formula.p = ~ I(qnorm(p)), s = matrix(c(1,1,1,0),2))
  # first column of coefficients: (beta0, beta1)
  # top-right coefficient: residual standard deviation
  
  




  ##### Example 8 ### censored data
  
  n &lt;- 1000
  x &lt;- runif(n,0,5)
	
  u &lt;- runif(n)
  beta0 &lt;- -log(1 - u)
  beta1 &lt;- 0.2*log(1 - u)
  t &lt;- beta0 + beta1*x  # time variable
  c &lt;- rexp(n,2)        # censoring variable
  y &lt;- pmin(t,c)        # observed events
  d &lt;- (t &lt;= c)         # 1 = event, 0 = censored
  
  iqr(Surv(y,d) ~ x, formula.p = ~ I(log(1 - p)))
  
  ##### Example 8 (cont.) ### censored and truncated data

  z &lt;- rexp(n,10)   # truncation variable
  w &lt;- which(y &gt; z) # only observe z,y,d,x when y &gt; z
  z &lt;- z[w]; y &lt;- y[w]; d &lt;- d[w]; x &lt;- x[w]

  iqr(Surv(z,y,d) ~ x, formula.p = ~ I(log(1 - p)))
  
  
  
  
  ##### Example 9 ### interval-censored data
  # (with a very naif data-generating process)
  
  n &lt;- 1000
  x &lt;- runif(n,0,5)
	
  u &lt;- runif(n)
  beta0 &lt;- 10*u + 20*u^2
  beta1 &lt;- 10*u
  t &lt;- beta0 + beta1*x  # time variable
  time1 &lt;- floor(t)     # lower bound
  time2 &lt;- ceiling(t)    # upper bound
  iqr(Surv(time1, time2, type = "interval2") ~ x, formula.p = ~ -1 + p + I(p^2))
  
</code></pre>

<hr>
<h2 id='iqrL'>
Quantile Regression Coefficients Modeling with Longitudinal Data
</h2><span id='topic+iqrL'></span>

<h3>Description</h3>

<p>This function implements Frumento et al's (2021) method for quantile regression
coefficients modeling with longitudinal data. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>iqrL(fx, fu = ~ slp(u,3), fz = ~ 1, fv = ~ -1 + I(qnorm(v)), 
   id, weights, s.theta, s.phi, data, tol = 1e-5, maxit)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="iqrL_+3A_fx">fx</code>, <code id="iqrL_+3A_fu">fu</code>, <code id="iqrL_+3A_fz">fz</code>, <code id="iqrL_+3A_fv">fv</code></td>
<td>
<p>formulas that describe the model (see &lsquo;Details&rsquo;).</p>
</td></tr>
<tr><td><code id="iqrL_+3A_id">id</code></td>
<td>
<p>a vector of cluster identifiers.</p>
</td></tr>
<tr><td><code id="iqrL_+3A_weights">weights</code></td>
<td>
<p>an optional vector of weights to be used in the fitting process.</p>
</td></tr>
<tr><td><code id="iqrL_+3A_s.theta">s.theta</code>, <code id="iqrL_+3A_s.phi">s.phi</code></td>
<td>
<p>optional 0/1 matrices that permit excluding some model coefficients.</p>
</td></tr>
<tr><td><code id="iqrL_+3A_data">data</code></td>
<td>
<p>an optional data frame, list or environment containing the variables in <code>fx</code> and <code>fz</code>.</p>
</td></tr>
<tr><td><code id="iqrL_+3A_tol">tol</code></td>
<td>
<p>convergence criterion for numerical optimization.</p>
</td></tr>
<tr><td><code id="iqrL_+3A_maxit">maxit</code></td>
<td>
<p>maximum number of iterations. If missing, a default is computed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>New users are recommended to read Frumento and Bottai's (2016) paper for details
on notation and modeling, and to have some familiarity with the 
<code><a href="#topic+iqr">iqr</a></code> command, of which <code>iqrL</code> is a natural expansion.
</p>
<p>The following data-generating process is assumed:
</p>
<p style="text-align: center;"><code class="reqn">Y_{it} = x_{it}\beta(U_{it}) + z_i\gamma(V_i)</code>
</p>

<p>where <code class="reqn">x_{it}</code> are level-1 covariates, <code class="reqn">z_i</code> are level-2 covariates,
and <code class="reqn">(U_{it}, V_i)</code> are independent <code class="reqn">U(0,1)</code> random variables.
This model implies that <code class="reqn">\alpha_i = z_i\gamma(V_i)</code> are cluster-level
effects with quantile function <code class="reqn">z_i\gamma(v)</code>, while <code class="reqn">x_{it}\beta(u)</code>
is the quantile function of <code class="reqn">Y_{it} - \alpha_i</code>.
</p>
<p>Both <code class="reqn">\beta(u)</code> and <code class="reqn">\gamma(v)</code>
are modeled parametrically, using a linear combination of known &ldquo;basis&rdquo;
functions <code class="reqn">b(u)</code> and <code class="reqn">c(v)</code> such that
</p>
<p style="text-align: center;"><code class="reqn">\beta(u) = \beta(u | \theta) = \theta b(u),</code>
</p>

<p style="text-align: center;"><code class="reqn">\gamma(u) = \gamma(u | \phi) = \phi c(v),</code>
</p>

<p>where <code class="reqn">\theta</code> and <code class="reqn">\phi</code> are matrices of model parameters.
</p>
<p>Model specification is implemented as follows.
</p>

<ul>
<li> <p><kbd>fx</kbd> is a two-sided formula of the form <kbd>y ~ x</kbd>.
</p>
</li>
<li> <p><kbd>fu</kbd> is a one-sided formula that describes <code class="reqn">b(u)</code>.
</p>
</li>
<li> <p><kbd>fz</kbd> is a one-sided formula of the form <kbd>~ z</kbd>.
</p>
</li>
<li> <p><kbd>fv</kbd> is a one-sided formula that describes <code class="reqn">c(v)</code>.
</p>
</li></ul>
  
<p>By default, <kbd>fu = ~ slp(u,3)</kbd>, a shifted Legendre's polynomial (see <code><a href="#topic+slp">slp</a></code>),
and the distribution of <code class="reqn">\alpha_i</code> is assumed to be Normal (<kbd>fv = ~ -1 + I(qnorm(v))</kbd>)
and to not depend on covariates (<kbd>fz = ~ 1</kbd>).
</p>
<p>Restrictions on <code class="reqn">\theta</code> and <code class="reqn">\phi</code> are imposed by setting to zero the corresponding elements
of <kbd>s.theta</kbd> and <kbd>s.phi</kbd>. 
</p>


<h3>Value</h3>

<p>An object of class &ldquo;<code>iqrL</code>&rdquo;, a list containing the following items:
</p>
<table>
<tr><td><code>theta</code>, <code>phi</code></td>
<td>
<p>estimates of <code class="reqn">\theta</code> and <code class="reqn">\phi</code>.</p>
</td></tr>
<tr><td><code>obj.function</code></td>
<td>
<p>the value of the minimized loss function, and, separately, the level-1 and the level-2 loss. The number of model parameters (excluding the individual effects) is returned as an attribute.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>the matched call.</p>
</td></tr>
<tr><td><code>converged</code></td>
<td>
<p>logical. The convergence status.</p>
</td></tr>
<tr><td><code>n.it</code></td>
<td>
<p>the number of iterations.</p>
</td></tr>
<tr><td><code>covar.theta</code>, <code>covar.phi</code></td>
<td>
<p>the estimated covariance matrices.</p>
</td></tr>
<tr><td><code>mf.theta</code>, <code>mf.phi</code></td>
<td>
<p>the model frames used to fit <code class="reqn">\theta</code> and <code class="reqn">\phi</code>, respectively. Note that <code>mf.theta</code> is sorted by increasing <kbd>id</kbd> and, within each <kbd>id</kbd>, by increasing values of the response variable <kbd>y</kbd>, while <code>mf.phi</code> is sorted by increasing <kbd>id</kbd>.</p>
</td></tr>
<tr><td><code>s.theta</code>, <code>s.phi</code></td>
<td>
<p>the used &lsquo;<kbd>s.theta</kbd>&rsquo; and &lsquo;<kbd>s.phi</kbd>&rsquo; matrices.</p>
</td></tr>
<tr><td><code>fit</code></td>
<td>

<p>a data.frame with the following variables:
</p>

<ul>
<li> <p><kbd>id</kbd> the cluster identifier.
</p>
</li>
<li> <p><kbd>y</kbd> the response variable.
</p>
</li>
<li> <p><kbd>alpha</kbd> the estimated individual effects.
</p>
</li>
<li> <p><kbd>y_alpha</kbd> = <kbd>y - alpha[id]</kbd>, the estimated responses purged of the individual effects.
</p>
</li>
<li> <p><kbd>v</kbd> estimates of <code class="reqn">V_i</code>.
</p>
</li>
<li> <p><kbd>u</kbd> estimates of <code class="reqn">U_{it}</code>.
</p>
</li></ul>

<p>Observations are sorted by increasing <kbd>id</kbd> and, within each <kbd>id</kbd>, by increasing <kbd>y</kbd>.
</p>
</td></tr>
</table>
<p>Use <code><a href="#topic+summary.iqrL">summary.iqrL</a></code>, <code><a href="#topic+plot.iqrL">plot.iqrL</a></code>, and <code><a href="#topic+predict.iqrL">predict.iqrL</a></code>
for summary information, plotting, and predictions from the fitted model. The function
<code><a href="#topic+test.fit.iqrL">test.fit.iqrL</a></code> can be used for goodness-of-fit assessment.
The generic accessory functions <code>coefficients</code>, <code>formula</code>, <code>terms</code>, <code>model.matrix</code>, <code>vcov</code> are available to extract information from the fitted model.
</p>


<h3>Author(s)</h3>

<p>Paolo Frumento <a href="mailto:paolo.frumento@unipi.it">paolo.frumento@unipi.it</a>
</p>


<h3>References</h3>

<p>Frumento, P., and Bottai, M. (2016). <em>Parametric modeling of quantile regression coefficient functions</em>. Biometrics, 72 (1), 74-84.
</p>
<p>Frumento, P., Bottai, M., and Fernandez-Val, I. (2021). <em>Parametric modeling of quantile regression coefficient functions with longitudinal data</em>. Journal of the American Statistical Association, 116 (534), 783-797.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+summary.iqrL">summary.iqrL</a></code>, <code><a href="#topic+plot.iqrL">plot.iqrL</a></code>, <code><a href="#topic+predict.iqrL">predict.iqrL</a></code>,
for summary, plotting, and prediction, and <code><a href="#topic+test.fit.iqrL">test.fit.iqrL</a></code> for goodness-of-fit assessment.
<code><a href="#topic+plf">plf</a></code> and <code><a href="#topic+slp">slp</a></code> to define <code class="reqn">b(u)</code> or <code class="reqn">c(v)</code>
to be piecewise linear functions and shifted Legendre polynomials, respectively.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  ##### Also see ?iqr for a tutorial on modeling
  ##### Using simulated data in all examples
  

  ##### Example 1

  n &lt;- 1000 # n. of observations
  n.id &lt;- 100 # n. of clusters
  id &lt;- rep(1:n.id, each = n/n.id) # cluster id

  x1 &lt;- runif(n) # a level-1 covariate
  z1 &lt;- rbinom(n,1,0.5)[id] # a level-2 covariate

  V &lt;- runif(n.id) # V_i
  U &lt;- runif(n) # U_it

  alpha &lt;- (0.5 + z1)*qnorm(V) # or alpha = rnorm(n.id, 0, 0.5 + z1)
  y_alpha &lt;- qexp(U) + 3*x1 # or y_alpha = 3*x1 + rexp(n)
  y &lt;- y_alpha + alpha[id] # observed outcome
  mydata &lt;- data.frame(id = id, y = y, x1 = x1, z1 = z1[id])

  # true quantile function: beta0(u) + beta1(u)*x1 + gamma0(v) + gamma1(v)*z1
  # beta0(u) = qexp(u)
  # beta1(u) = 3
  # gamma0(v) = 0.5*qnorm(v)
  # gamma1(v) = qnorm(v)


  ##### Example 1 (cont.) fitting the model

  model1 &lt;- iqrL(fx = y ~ x1, fu = ~ I(qexp(u)), fz = ~ z1, fv = ~ -1 + I(qnorm(v)), 
    id = id, data = mydata)
  summary(model1) # theta, phi
  summary(model1, level = 1, p = c(0.1,0.9)) # beta
  summary(model1, level = 2, p = c(0.1,0.9)) # gamma
  par(mfrow = c(2,2)); plot(model1, ask = FALSE)


  ##### Example 1 (cont.) - excluding coefficients

  s.theta &lt;- rbind(0:1,1:0) # beta0(u) has no intercept, and beta1(u) does not depend on u.
  model2 &lt;- iqrL(fx = y ~ x1, fu = ~ I(qexp(u)), fz = ~ z1, fv = ~ -1 + I(qnorm(v)), 
    id = id, s.theta = s.theta, data = mydata)
  summary(model2)
  test.fit(model2) # testing goodness-of-fit


  ##### Example 1 (cont.) - flexible modeling using slp for lev. 1, asymm. logistic for lev. 2
  
  model3 &lt;- iqrL(fx = y ~ x1, fu = ~ slp(u,3), 
    fz = ~ z1, fv = ~ -1 + I(log(2*v)) + I(-log(2*(1 - v))), 
    id = id, data = mydata)
  par(mfrow = c(2,2)); plot(model3, ask = FALSE)


  ##### Example 2 - revisiting the classical linear random-effects model

  n &lt;- 1000 # n. of observations
  n.id &lt;- 100 # n. of clusters
  id &lt;- rep(1:n.id, each = n/n.id) # id

  x1 &lt;- runif(n,0,5)
  E &lt;- rnorm(n) # level-1 error
  W &lt;- rnorm(n.id, 0, 0.5) # level-2 error
  y &lt;- 2 + 3*x1 + E + W[id] # linear random-intercept model

  s.theta &lt;- rbind(1, 1:0)
  linmod &lt;- iqrL(fx = y ~ x1, fu = ~ I(qnorm(u)), id = id, s.theta = s.theta)
  summary(linmod)
  
</code></pre>

<hr>
<h2 id='plf'>
Basis of a Piecewise Linear Function
</h2><span id='topic+plf'></span>

<h3>Description</h3>

<p>Generates <code class="reqn">b_1(p), b_2(p), \ldots</code> such that, for <kbd>0 &lt; p &lt; 1</kbd>,
</p>
<p style="text-align: center;"><code class="reqn">\theta_1*b_1(p) + \theta_2*b_2(p) + \ldots</code>
</p>

<p>is a piecewise linear function with slopes 
<code class="reqn">(\theta_1, \theta_2, \ldots)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plf(p, knots)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plf_+3A_p">p</code></td>
<td>

<p>a numeric vector of values between <kbd>0</kbd> and <kbd>1</kbd>.
</p>
</td></tr>
<tr><td><code id="plf_+3A_knots">knots</code></td>
<td>

<p>a set of <em>internal</em> knots between <kbd>0</kbd> and <kbd>1</kbd>.
It can be <kbd>NULL</kbd> for no internal knots. 
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function permits computing a piecewise linear function on the unit interval. 
A different slope holds between each pair of knots, and the function
is continuous at the knots.
</p>


<h3>Value</h3>

<p>A matrix with one row for each element of <kbd>p</kbd>, and <code>length(knots) + 1</code> columns. 
The knots are returned as <code>attr(, "knots")</code>.
Any linear combination of the basis matrix is a piecewise linear function where
each coefficient represents the slope in the corresponding sub-interval (see &lsquo;Examples&rsquo;). 
</p>


<h3>Note</h3>

<p>This function is typically used within a call to <code><a href="#topic+iqr">iqr</a></code>.
A piecewise linear function can be used to describe how quantile regression coefficients
depend on the order of the quantile.
</p>


<h3>Author(s)</h3>

<p>Paolo Frumento <a href="mailto:paolo.frumento@unipi.it">paolo.frumento@unipi.it</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+slp">slp</a></code>, for shifted Legendre polynomials.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  p &lt;- seq(0,1, 0.1)

  a1 &lt;- plf(p, knots = NULL) # returns p

  a2 &lt;- plf(p, knots = c(0.2,0.7))
  plot(p, 3 + 1*a2[,1] - 1*a2[,2] + 2*a2[,3], type = "l") 
    # intercept = 3; slopes = (1,-1,2)
</code></pre>

<hr>
<h2 id='plot.iqr'>
Plot Quantile Regression Coefficients
</h2><span id='topic+plot.iqr'></span>

<h3>Description</h3>

<p>Plots quantile regression coefficients 
<code class="reqn">\beta(p)</code> as a function of <code class="reqn">p</code>,
based on a fitted model of class &ldquo;<code>iqr</code>&rdquo;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'iqr'
plot(x, conf.int = TRUE, polygon = TRUE, which = NULL, ask = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.iqr_+3A_x">x</code></td>
<td>

<p>an object of class &ldquo;<code>iqr</code>&rdquo;, typically the result of a call to <code><a href="#topic+iqr">iqr</a></code>.
</p>
</td></tr>
<tr><td><code id="plot.iqr_+3A_conf.int">conf.int</code></td>
<td>

<p>logical. If <kbd>TRUE</kbd>, asymptotic 95% confidence intervals are added to the plot.
</p>
</td></tr>
<tr><td><code id="plot.iqr_+3A_polygon">polygon</code></td>
<td>

<p>logical. If <kbd>TRUE</kbd>, confidence intervals are represented by shaded areas via <code>polygon</code>.
Otherwise, dashed lines are used.
</p>
</td></tr>
<tr><td><code id="plot.iqr_+3A_which">which</code></td>
<td>

<p>an optional numerical vector indicating which coefficient(s) to plot. If <kbd>which = NULL</kbd>, 
all coefficients are plotted.
</p>
</td></tr>
<tr><td><code id="plot.iqr_+3A_ask">ask</code></td>
<td>
<p>logical. If <kbd>which = NULL</kbd> and <kbd>ask = TRUE</kbd> (the default), you will be asked
interactively which coefficients to plot.</p>
</td></tr>
<tr><td><code id="plot.iqr_+3A_...">...</code></td>
<td>
<p>additional graphical parameters, that can include <kbd>xlim, ylim, xlab, ylab, col, lwd, cex.lab, cex.axis, axes, frame.plot</kbd>. 
See <code><a href="graphics.html#topic+par">par</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Using <code>iqr</code>, each quantile regression coefficient <code class="reqn">\beta(p)</code> is described by a linear
combination of known parametric functions of <code class="reqn">p</code>. With this command, a plot of
<code class="reqn">\beta(p)</code> versus <code class="reqn">p</code> is created. If <kbd>ask = TRUE</kbd>, an additional option permits
plotting a Q-Q plot of the fitted cumulative distribution function (<abbr><span class="acronym">CDF</span></abbr>), that should follow
a U(0,1) distribution if the model is correctly specified. If the data are censored or truncated,
this is assessed applying the Kaplan-Meier estimator to the fitted <abbr><span class="acronym">CDF</span></abbr> values.
See also <code><a href="#topic+test.fit">test.fit</a></code> for a formal test of uniformity.
</p>


<h3>Author(s)</h3>

<p>Paolo Frumento <a href="mailto:paolo.frumento@unipi.it">paolo.frumento@unipi.it</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+iqr">iqr</a></code> for model fitting; <code><a href="#topic+summary.iqr">summary.iqr</a></code> and <code><a href="#topic+predict.iqr">predict.iqr</a></code>
for model summary and prediction.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  
  # using simulated data
  
  n &lt;- 1000
  x &lt;- runif(n)
  qy &lt;- function(p,x){p^2 + x*log(p)}
  # true quantile function: Q(p | x) = beta0(p) + beta1(p)*x, with
     # beta0(p) = p^2
     # beta1(p) = log(p)
  y &lt;- qy(runif(n), x) # to generate y, plug uniform p in qy(p,x)
  
  par(mfrow = c(1,2))
  plot(iqr(y ~ x, formula.p = ~ slp(p,3)), ask = FALSE) 
  # flexible fit with shifted Legendre polynomials
</code></pre>

<hr>
<h2 id='plot.iqrL'>
Plot Quantile Regression Coefficients with Longitudinal Data
</h2><span id='topic+plot.iqrL'></span>

<h3>Description</h3>

<p>Plots quantile regression coefficients 
<code class="reqn">\beta(u)</code> and <code class="reqn">\gamma(v)</code>,
based on a fitted model of class &ldquo;<code>iqrL</code>&rdquo;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'iqrL'
plot(x, conf.int = TRUE, polygon = TRUE, which = NULL, ask = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.iqrL_+3A_x">x</code></td>
<td>

<p>an object of class &ldquo;<code>iqrL</code>&rdquo;, the result of a call to <code><a href="#topic+iqrL">iqrL</a></code>.
</p>
</td></tr>
<tr><td><code id="plot.iqrL_+3A_conf.int">conf.int</code></td>
<td>

<p>logical. If <kbd>TRUE</kbd>, asymptotic 95% confidence intervals are added to the plot.
</p>
</td></tr>
<tr><td><code id="plot.iqrL_+3A_polygon">polygon</code></td>
<td>

<p>logical. If <kbd>TRUE</kbd>, confidence intervals are represented by shaded areas via <code>polygon</code>.
Otherwise, dashed lines are used.
</p>
</td></tr>
<tr><td><code id="plot.iqrL_+3A_which">which</code></td>
<td>

<p>an optional numerical vector indicating which coefficient(s) to plot. If <kbd>which = NULL</kbd>, 
all coefficients are plotted.
</p>
</td></tr>
<tr><td><code id="plot.iqrL_+3A_ask">ask</code></td>
<td>
<p>logical. If <kbd>which = NULL</kbd> and <kbd>ask = TRUE</kbd> (the default), you will be asked
interactively which coefficients to plot. Additional options will permit
creating Q-Q plots of <code>u</code> or <code>v</code>, which should be independently distributed according to a Uniform(0,1) 
distribution. The option <code>ppplot(u,v)</code> will generate a P-P plot that compares
the empirical distribution of <code>(u,v)</code> with its theoretical
value, <code>F(u,v) = uv</code>, at a discrete grid of points.</p>
</td></tr>
<tr><td><code id="plot.iqrL_+3A_...">...</code></td>
<td>
<p>additional graphical parameters, that can include <kbd>xlim, ylim, xlab, ylab, col, lwd, cex.lab, cex.axis, axes, frame.plot</kbd>. 
See <code><a href="graphics.html#topic+par">par</a></code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Paolo Frumento <a href="mailto:paolo.frumento@unipi.it">paolo.frumento@unipi.it</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+iqrL">iqrL</a></code> for model fitting; <code><a href="#topic+summary.iqrL">summary.iqrL</a></code> and <code><a href="#topic+predict.iqrL">predict.iqrL</a></code>
for model summary and prediction.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  
  # using simulated data
  
  n &lt;- 1000 # n. of observations
  n.id &lt;- 100 # n. of clusters
  id &lt;- rep(1:n.id, each = n/n.id) # cluster id

  x1 &lt;- runif(n) # a level-1 covariate
  z1 &lt;- rnorm(n.id) # a level-2 covariate

  V &lt;- runif(n.id) # V_i
  U &lt;- runif(n) # U_it

  alpha &lt;- 2*(V - 1) + z1 # alpha
  y_alpha &lt;- 1 + 2*qnorm(U) + 3*U*x1 # y - alpha
  y &lt;- y_alpha + alpha[id] # observed outcome
  mydata &lt;- data.frame(id = id, y = y, x1 = x1, z1 = z1[id])

  model &lt;- iqrL(fx = y ~ x1, fu = ~ I(qnorm(u)) + u, 
    fz = ~ z1, fv = ~ -1 + I(qnorm(v)), id = id, data = mydata)
  par(mfrow = c(2,2))
  plot(model, ask = FALSE) 
</code></pre>

<hr>
<h2 id='predict.iqr'>
Prediction After Quantile Regression Coefficients Modeling
</h2><span id='topic+predict.iqr'></span>

<h3>Description</h3>

<p>Predictions from an object of class &ldquo;<code>iqr</code>&rdquo;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'iqr'
predict(object, type = c("beta", "CDF", "QF", "sim"), newdata, p, se = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.iqr_+3A_object">object</code></td>
<td>

<p>an object of class &ldquo;<code>iqr</code>&rdquo;, the result of a call to <code><a href="#topic+iqr">iqr</a></code>.
</p>
</td></tr>
<tr><td><code id="predict.iqr_+3A_type">type</code></td>
<td>

<p>a character string specifying the type of prediction. See &lsquo;Details&rsquo;.
</p>
</td></tr>
<tr><td><code id="predict.iqr_+3A_newdata">newdata</code></td>
<td>

<p>an optional data frame in which to look for variables with which to predict. 
If omitted, the data are used. For <kbd>type = "CDF"</kbd>, it must include the response variable.
Ignored if <kbd>type = "beta"</kbd>.
</p>
</td></tr>
<tr><td><code id="predict.iqr_+3A_p">p</code></td>
<td>

<p>a numeric vector indicating the order(s) of the quantile to predict. Only used if 
<kbd>type = "beta"</kbd> or <kbd>type = "QF"</kbd>.
</p>
</td></tr>
<tr><td><code id="predict.iqr_+3A_se">se</code></td>
<td>

<p>logical. If <kbd>TRUE</kbd> (the default), standard errors of the prediction will be computed. Only used if <kbd>type = "beta"</kbd> or <kbd>type = "QF"</kbd>.
</p>
</td></tr>
<tr><td><code id="predict.iqr_+3A_...">...</code></td>
<td>
<p>for future methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Using <code><a href="#topic+iqr">iqr</a></code>, quantile regression coefficients 
<code class="reqn">\beta(p)</code> are modeled as parametric functions of <code class="reqn">p</code>, the order of the quantile.
This implies that the model parameter is <em>not</em> <code class="reqn">\beta(p)</code> itself.
The function <code>predict.iqr</code> permits computing <code class="reqn">\beta(p)</code> and other
quantities of interest, as detailed below.
</p>

<ul>
<li><p> if <kbd>type = "beta"</kbd> (the default), <code class="reqn">\beta(p)</code> is returned at 
the supplied value(s) of <kbd>p</kbd>. If <kbd>p</kbd> is missing, a default <kbd>p = (0.01, ..., 0.99)</kbd> is used. 
</p>
</li>
<li><p> if <kbd>type = "CDF"</kbd>, the value of the fitted <abbr><span class="acronym">CDF</span></abbr> (cumulative distribution function)
and <abbr><span class="acronym">PDF</span></abbr> (probability density function) are computed.
</p>
</li>
<li><p> if <kbd>type = "QF"</kbd>, the fitted values <code class="reqn">x'\beta(p)</code>, corresponding to the 
conditional quantile function, are computed at the supplied values of <kbd>p</kbd>. 
</p>
</li>
<li><p> if <kbd>type = "sim"</kbd>, data are simulated from the fitted model. 
To simulate the data, the fitted conditional quantile function is computed
at randomly generated <kbd>p</kbd> following a Uniform(0,1) distribution.
</p>
</li></ul>



<h3>Value</h3>


<ul>
<li><p> if <kbd>type = "beta"</kbd> a list with one item for each covariate in the model. 
Each element of the list is a data frame with columns (<kbd>p, beta, se, low, up</kbd>) reporting <code class="reqn">\beta(p)</code>, its estimated standard error, and the corresponding 95% confidence interval. If <kbd>se = FALSE</kbd>, the last three columns are not computed.
</p>
</li>
<li><p> if <kbd>type = "CDF"</kbd>, a two-columns data frame <kbd>(CDF,PDF)</kbd>.
</p>
</li>
<li><p> if <kbd>type = "QF"</kbd> and <kbd>se = FALSE</kbd>, a data frame with one row
for each observation, and one column for each value of <kbd>p</kbd>. If <kbd>se = TRUE</kbd>,
a list of two data frames, <kbd>fit</kbd> (predictions) and <kbd>se.fit</kbd> (standard errors).
</p>
</li>
<li><p> if <kbd>type = "sim"</kbd>, a vector of simulated data.
</p>
</li></ul>


<h3>Note</h3>

<p>Prediction may generate quantile crossing
if the support of the new covariates values supplied in <code>newdata</code> 
is different from that of the observed data.
</p>


<h3>Author(s)</h3>

<p>Paolo Frumento <a href="mailto:paolo.frumento@unipi.it">paolo.frumento@unipi.it</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+iqr">iqr</a></code>, for model fitting; <code><a href="#topic+summary.iqr">summary.iqr</a></code> and <code><a href="#topic+plot.iqr">plot.iqr</a></code>,
for summarizing and plotting <code>iqr</code> objects.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  # using simulated data
  
  n &lt;- 1000
  x &lt;- runif(n)
  y &lt;- rlogis(n, 1 + x, 1 + x)
  # true quantile function: Q(p | x) = beta0(p) + beta1(p)*x, with
    # beta0(p) = beta1(p) = 1 + log(p/(1 - p))
  
  model &lt;- iqr(y ~ x, formula.p = ~ I(log(p)) + I(log(1 - p))) 
  # (fit asymmetric logistic distribution)
  
  
  # predict beta(0.25), beta(0.5), beta(0.75)
  predict(model, type = "beta", p = c(0.25,0.5, 0.75))
  
  # predict the CDF and the PDF at new values of x and y
  predict(model, type = "CDF", newdata = data.frame(x = c(.1,.2,.3), y = c(1,2,3)))
  
  # computes the quantile function at new x, for p = (0.25,0.5,0.75)
  predict(model, type = "QF", p = c(0.25,0.5,0.75), newdata = data.frame(x = c(.1,.2,.3)))

  # simulate data from the fitted model
  ysim &lt;- predict(model, type = "sim") # 'newdata' can be supplied

  # if the model is correct, the distribution of y and that of ysim should be similar
  qy &lt;- quantile(y, prob = seq(.1,.9,.1))
  qsim &lt;- quantile(ysim, prob = seq(.1,.9,.1))
  plot(qy, qsim); abline(0,1)
</code></pre>

<hr>
<h2 id='predict.iqrL'>
Prediction After Quantile Regression Coefficients Modeling with Longitudinal Data
</h2><span id='topic+predict.iqrL'></span>

<h3>Description</h3>

<p>Predictions from an object of class &ldquo;<code>iqrL</code>&rdquo;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'iqrL'
predict(object, level, type = c("coef", "CDF", "QF", "sim"), newdata, p, se = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.iqrL_+3A_object">object</code></td>
<td>

<p>an object of class &ldquo;<code>iqrL</code>&rdquo;, the result of a call to <code><a href="#topic+iqrL">iqrL</a></code>.
</p>
</td></tr>
<tr><td><code id="predict.iqrL_+3A_level">level</code></td>
<td>

<p>a numeric scalar. Use <code>level = 1</code> to predict <code class="reqn">y_{it} - \alpha_i</code>, and 
<code>level = 2</code> to predict <code class="reqn">\alpha_i</code> (see <code><a href="#topic+iqrL">iqrL</a></code> for the notation).
</p>
</td></tr>
<tr><td><code id="predict.iqrL_+3A_type">type</code></td>
<td>

<p>a character string specifying the type of prediction. See &lsquo;Details&rsquo;.
</p>
</td></tr>
<tr><td><code id="predict.iqrL_+3A_newdata">newdata</code></td>
<td>

<p>an optional data frame in which to look for variables with which to predict (ignored if <kbd>type = "coef"</kbd>).
For <kbd>type = "CDF"</kbd>, <code>newdata</code> must include a response variable named &lsquo;<kbd>y_alpha</kbd>&rsquo;, 
if <kbd>level = 1</kbd>, and &lsquo;<kbd>alpha</kbd>&rsquo; if <kbd>level = 2</kbd>. If <code>newdata</code> is omitted, 
the observed data will be used, and <kbd>y_alpha</kbd> and <kbd>alpha</kbd> will be taken from
<kbd>object$fit</kbd>. 
</p>
</td></tr>
<tr><td><code id="predict.iqrL_+3A_p">p</code></td>
<td>

<p>a numeric vector indicating the order(s) of the quantile to predict. Only used if 
<kbd>type = "coef"</kbd> or <kbd>type = "QF"</kbd>.
</p>
</td></tr>
<tr><td><code id="predict.iqrL_+3A_se">se</code></td>
<td>

<p>logical. If <kbd>TRUE</kbd> (the default), standard errors of the prediction will be computed. Only used if <kbd>type = "coef"</kbd> or <kbd>type = "QF"</kbd>.
</p>
</td></tr>
<tr><td><code id="predict.iqrL_+3A_...">...</code></td>
<td>
<p>for future methods.</p>
</td></tr>
</table>


<h3>Details</h3>


<ul>
<li><p> if <kbd>type = "coef"</kbd> (the default), quantile regression coefficients are returned:
if <kbd>level = 1</kbd>, <code class="reqn">\beta(p)</code>; and if <kbd>level = 2</kbd>, <code class="reqn">\gamma(p)</code>. 
If <kbd>p</kbd> is missing, a default <kbd>p = (0.01, ..., 0.99)</kbd> is used. 
</p>
</li>
<li><p> if <kbd>type = "CDF"</kbd>, the value of the fitted <abbr><span class="acronym">CDF</span></abbr> (cumulative distribution function)
and <abbr><span class="acronym">PDF</span></abbr> (probability density function) are computed. If <kbd>level = 1</kbd>,
these refer to the distribution of <code class="reqn">Y_{it} - \alpha_i = x_{it}\beta(U_{it})</code>,
and the <abbr><span class="acronym">CDF</span></abbr> is an estimate of <code class="reqn">U_{it}</code>. If <kbd>level = 2</kbd>,
they refer to the distribution of <code class="reqn">\alpha_i = z_i\gamma(V_i)</code>,
and the <abbr><span class="acronym">CDF</span></abbr> is an estimate of <code class="reqn">V_i</code>.
</p>
</li>
<li><p> if <kbd>type = "QF"</kbd>, the fitted values <code class="reqn">x\beta(p)</code> (if <kbd>level = 1</kbd>),
or <code class="reqn">z\gamma(p)</code> (if <kbd>level = 2</kbd>). 
</p>
</li>
<li><p> if <kbd>type = "sim"</kbd>, data are simulated from the fitted model. 
If <kbd>level = 1</kbd>, simulated values are from the distribution of <code class="reqn">Y_{it} - \alpha_i</code>,
while if <kbd>level = 2</kbd>, they are from the distribution of <code class="reqn">\alpha_i</code>.
</p>
</li></ul>



<h3>Value</h3>


<ul>
<li><p> if <kbd>type = "coef"</kbd> a list with one item for each covariate. 
Each element of the list is a data frame with columns (<kbd>u, beta, se, low, up</kbd>),
if <kbd>level = 1</kbd>, and (<kbd>v, gamma, se, low, up</kbd>), if <kbd>level = 2</kbd>.
If <kbd>se = FALSE</kbd>, the last three columns are not computed.
</p>
</li>
<li><p> if <kbd>type = "CDF"</kbd>, a two-columns data frame <kbd>(CDF,PDF)</kbd>.
</p>
</li>
<li><p> if <kbd>type = "QF"</kbd> and <kbd>se = FALSE</kbd>, a data frame with one row
for each observation, and one column for each value of <kbd>p</kbd>. If <kbd>se = TRUE</kbd>,
a list of two data frames, <kbd>fit</kbd> (predictions) and <kbd>se.fit</kbd> (standard errors).
</p>
</li>
<li><p> if <kbd>type = "sim"</kbd>, a vector of simulated data.
</p>
</li></ul>


<h3>Note</h3>

<p>If no <kbd>newdata</kbd> are supplied, the observed data are used and predictions are ordered as follows:
</p>

<ul>
<li><p> if <kbd>level = 1</kbd>, by increasing <kbd>id</kbd> and, within each <kbd>id</kbd>,
by increasing values of the response variable <kbd>y</kbd>. Rownames will indicate
the position in the original data frame.
</p>
</li>
<li><p> if <kbd>level = 2</kbd>, by increasing <kbd>id</kbd>.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Paolo Frumento <a href="mailto:paolo.frumento@unipi.it">paolo.frumento@unipi.it</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+iqrL">iqrL</a></code>, for model fitting; <code><a href="#topic+summary.iqrL">summary.iqrL</a></code> and <code><a href="#topic+plot.iqrL">plot.iqrL</a></code>,
for summarizing and plotting <code>iqrL</code> objects.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  # using simulated data
  
  n &lt;- 1000 # n. of observations
  n.id &lt;- 100 # n. of clusters
  id &lt;- rep(1:n.id, each = n/n.id) # cluster id

  x1 &lt;- runif(n) # a level-1 covariate
  z1 &lt;- rbinom(n.id,1,0.5) # a level-2 covariate

  V &lt;- runif(n.id) # V_i
  U &lt;- runif(n) # U_it

  alpha &lt;- qlogis(V)*(0.5 + z1) # alpha
  y_alpha &lt;- 1 + 2*qexp(U) + 3*x1 # y - alpha
  y &lt;- y_alpha + alpha[id] # observed outcome
  mydata &lt;- data.frame(id = id, y = y, x1 = x1, z1 = z1[id])

  # true model: Y_it = beta0(U_it) + beta1(U_it)*x1 + gamma0(V_i) + gamma1(V_i)*z1
  # beta0(u) = 1 + 2*pexp(u)
  # beta1(u) = 3
  # gamma0(v) = 0.5*qlogis(v)
  # gamma1(v) = qlogis(V)
  
  model &lt;- iqrL(fx = y ~ x1, fu = ~ I(qexp(u)), fz = ~ z1, fv = ~ -1 + I(qlogis(v)), 
    id = id, data = mydata) 
  
  # predict beta(0.25), beta(0.5), beta(0.75)
  predict(model, level = 1, type = "coef", p = c(0.25,0.5,0.75))
 
  # predict gamma(0.1), gamma(0.9)
  predict(model, level = 2, type = "coef", p = c(0.1,0.9))

  # predict the CDF (u) and the PDF of (y - alpha), at new values of x1
  predict(model, level = 1, type = "CDF", 
    newdata = data.frame(x1 = c(.1,.2,.3), y_alpha = c(1,2,3)))
 
  # predict the CDF (v) and the PDF of alpha, at new values of z1
  predict(model, level = 2, type = "CDF", 
    newdata = data.frame(z1 = c(0,1), alpha = c(-1,1)))
 
  # computes the quantile function of (y - alpha) at new x1, for u = (0.25,0.5,0.75)
  predict(model, level = 1, type = "QF", p = c(0.25,0.5,0.75), 
    newdata = data.frame(x1 = c(.1,.2,.3)))

  # computes the quantile function of alpha at new z1, for v = (0.25,0.5,0.75)
  predict(model, level = 2, type = "QF", p = c(0.25,0.5,0.75), 
    newdata = data.frame(z1 = c(.1,.2,.3)))


  # simulate data from the fitted model
  y_alpha_sim &lt;- predict(model, level = 1, type = "sim")
  alpha_sim &lt;- predict(model, level = 2, type = "sim")
  y_sim = y_alpha_sim + alpha_sim[id]
</code></pre>

<hr>
<h2 id='qc.control'>
Estimate Non-Crossing Quantile Functions
</h2><span id='topic+qc.control'></span>

<h3>Description</h3>

<p>This function generates a list of arguments to be used as operational parameters for <code>remove.qc</code> within a call to <code><a href="#topic+iqr">iqr</a></code>. Additionally, this R documentation page contains a short description of the algorithm, which is presented in details in Sottile and Frumento (2023). 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qc.control(maxTry = 25, trace = FALSE, lambda = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="qc.control_+3A_maxtry">maxTry</code></td>
<td>

<p>maximum number of attempts of the algorithm.
</p>
</td></tr>
<tr><td><code id="qc.control_+3A_trace">trace</code></td>
<td>

<p>logical: should the progress be printed on screen?
</p>
</td></tr>
<tr><td><code id="qc.control_+3A_lambda">lambda</code></td>
<td>

<p>an optional positive scalar to be used as tuning parameter (see &ldquo;Details&rdquo;). By default, <kbd>lambda = NULL</kbd>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Quantile crossing occurs when the first derivative of the estimated quantile function is negative at some value of <code class="reqn">p</code>. The argument <code>remove.qc</code> of the <code>iqr</code> function can be used to eliminate quantile crossing. 
</p>
<p>The algorithm proceeds as follows. A penalization that reflects the severity of crossing is added to the loss function. The weight of the penalty term is determined by a tuning parameter <code class="reqn">\lambda</code>. If <code class="reqn">\lambda</code> is too small, the penalization has no effect. However, if <code class="reqn">\lambda</code> is too large, the objective function may lose its convexity, causing a malfunctioning of the algorithm. In general, the value of <code class="reqn">\lambda</code> is <em>not</em> user-defined. The algorithm starts with an initial guess for the tuning parameter, and proceeds adaptively until it finds a suitable value. The maximum number of iterations is determined by the <kbd>maxTry</kbd> argument of this function (default <kbd>maxTry = 25</kbd>). The algorithm stops automatically when the <kbd>crossIndex</kbd> of the model (see <code><a href="#topic+diagnose.qc">diagnose.qc</a></code>) is zero, or when no further progress is possible.
</p>
<p>It is possible to supply a user-defined value of <code class="reqn">\lambda</code>, e.g., <kbd>lambda = 7.5</kbd>. If this happens, the model is estimated <strong>once</strong>, using the requested <kbd>lambda</kbd>, while the <kbd>maxTry</kbd> argument is ignored.
</p>
<p>This method allows for censored or truncated data, that are supported by <code>iqr</code>. Full details are provided in Sottile and Frumento (2021).
</p>


<h3>Value</h3>

<p>The function performs a sanity check and returns its arguments.
</p>


<h3>Note</h3>

<p>Occasionally, the loss of the penalized model is smaller than that of the unconstrained fit. This is either an artifact due to numerical approximations or lack of convergence, or is explained by the fact that, if the quantile function is ill-defined, so is the loss function of the model. With censored or truncated data, however, it can also be explained by the fact that the <kbd>obj.function</kbd> of the model is <strong>NOT</strong> the function being minimized (see note 3 in the documentation of <code>iqr</code>).
</p>


<h3>Author(s)</h3>

<p>Paolo Frumento <a href="mailto:paolo.frumento@unipi.it">paolo.frumento@unipi.it</a>
</p>


<h3>References</h3>

<p>Sottile, G., and Frumento, P. (2023). <em>Parametric estimation of non-crossing quantile functions</em>. Statistical Modelling, 23(2), 173-195.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+iqr">iqr</a></code>, <code><a href="#topic+diagnose.qc">diagnose.qc</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
 # Using simulated data

 set.seed(1111)
 n &lt;- 1000
 x1 &lt;- runif(n,0,3)
 x2 &lt;- rbinom(n,1,0.5)

 u &lt;- runif(n)
 y &lt;- 1*qexp(u) + (2 + 3*u)*x1 + 5*x2

 # This model is likely to suffer from quantile crossing
 m &lt;- iqr(y ~ x1 + x2, formula.p = ~ slp(p,7))
 diagnose.qc(m)

 # Repeat estimation with remove.qc = TRUE
 m2 &lt;- iqr(y ~ x1 + x2, formula.p = ~ slp(p,7), remove.qc = TRUE)
 diagnose.qc(m2)

 # Use remove.qc = qc.control(trace = TRUE) to see what is going on!
 # You can set a larger 'maxTry', if the algorithm failed to remove 
 # quantile crossing entirely, or a smaller one, if you want to stop
 # the procedure before it becomes 'too expensive' in terms of loss.
 

</code></pre>

<hr>
<h2 id='slp'>
Shifted Legendre Polynomials
</h2><span id='topic+slp'></span>

<h3>Description</h3>

<p>Computes shifted Legendre polynomials.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>slp(p, k = 3, intercept = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="slp_+3A_p">p</code></td>
<td>

<p>the variable for which to compute the polynomials. Must be <kbd>0 &lt;= p &lt;= 1</kbd>.
</p>
</td></tr>
<tr><td><code id="slp_+3A_k">k</code></td>
<td>

<p>the degree of the polynomial.
</p>
</td></tr>
<tr><td><code id="slp_+3A_intercept">intercept</code></td>
<td>

<p>logical. If <kbd>TRUE</kbd>, the polynomials include the constant term.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Shifted Legendre polynomials (<abbr><span class="acronym">SLP</span></abbr>) are orthogonal polynomial functions in (0,1) that can be used
to build a spline basis, typically within a call to <code><a href="#topic+iqr">iqr</a></code>.
The constant term is omitted unless <kbd>intercept = TRUE</kbd>: for example,
the first two <abbr><span class="acronym">SLP</span></abbr> are <code>(2*p - 1, 6*p^2 - 6*p + 1)</code>, 
but <code>slp(p, k = 2)</code> will only return <code>(2*p, 6*p^2 - 6*p)</code>.
</p>


<h3>Value</h3>

<p>An object of class &ldquo;<code>slp</code>&rdquo;, i.e., 
a matrix with the same number of rows as <kbd>p</kbd>, and with <kbd>k</kbd> columns
named <code>slp1, slp2, ...</code> containing the <abbr><span class="acronym">SLP</span></abbr> of the corresponding orders.
The value of <kbd>k</kbd> is reported as attribute.
</p>


<h3>Note</h3>

<p>The estimation algorithm of <code>iqr</code> is optimized for objects of class &ldquo;slp&rdquo;,
which means that using <code>formula.p = ~ slp(p, k)</code> instead of 
<code>formula.p = ~ p + I(p^2) + ... + I(p^k)</code> will result in a quicker
computation, even with <kbd>k = 1</kbd>, with equivalent results. 
The default for <code>iqr</code> is <code>formula.p = ~ slp(p, k = 3)</code>.
</p>


<h3>Author(s)</h3>

<p>Paolo Frumento <a href="mailto:paolo.frumento@unipi.it">paolo.frumento@unipi.it</a>
</p>


<h3>References</h3>

<p>Refaat El Attar (2009), <em>Legendre Polynomials and Functions</em>, CreateSpace, ISBN 978-1-4414-9012-4.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plf">plf</a></code>, for piecewise linear functions in the unit interval.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  p &lt;- seq(0,1,0.1)
  slp(p, k = 1) # = 2*p
  slp(p, k = 1, intercept = TRUE) # = 2*p - 1 (this is the true SLP of order 1)
  slp(p, k = 3) # a linear combination of (p, p^2, p^3), with slp(0,k) = 0
</code></pre>

<hr>
<h2 id='summary.iqr'>
Summary After Quantile Regression Coefficients Modeling
</h2><span id='topic+summary.iqr'></span>

<h3>Description</h3>

<p>Summary of an object of class &ldquo;<code>iqr</code>&rdquo;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'iqr'
summary(object, p, cov = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.iqr_+3A_object">object</code></td>
<td>

<p>an object of class &ldquo;<code>iqr</code>&rdquo;, the result of a call to <code><a href="#topic+iqr">iqr</a></code>.
</p>
</td></tr>
<tr><td><code id="summary.iqr_+3A_p">p</code></td>
<td>

<p>an optional vector of quantiles.
</p>
</td></tr>
<tr><td><code id="summary.iqr_+3A_cov">cov</code></td>
<td>

<p>logical. If <kbd>TRUE</kbd>, the covariance matrix of <code class="reqn">\beta(p)</code> is reported.
Ignored if <kbd>p</kbd> is missing.
</p>
</td></tr>
<tr><td><code id="summary.iqr_+3A_...">...</code></td>
<td>
<p>for future methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <kbd>p</kbd> is missing, a summary of the fitted model is reported. This includes the
estimated coefficients, their standard errors, and other summaries (see &lsquo;Value&rsquo;).
If <kbd>p</kbd> is supplied, the quantile regression coefficients of order <kbd>p</kbd> are extrapolated
and summarized.
</p>


<h3>Value</h3>

<p>If <kbd>p</kbd> is supplied, 
a standard summary of the estimated quantile regression coefficients 
is returned for each value of <kbd>p</kbd>. If <kbd>cov = TRUE</kbd>, the covariance
matrix is also reported.
</p>
<p>If <kbd>p</kbd> is missing (the default), a list with the following items:
</p>
<table>
<tr><td><code>converged</code></td>
<td>
<p>logical value indicating the convergence status.</p>
</td></tr>
<tr><td><code>n.it</code></td>
<td>
<p>the number of iterations.</p>
</td></tr>
<tr><td><code>n</code></td>
<td>
<p>the number of observations.</p>
</td></tr>
<tr><td><code>free.par</code></td>
<td>
<p>the number of free parameters in the model.</p>
</td></tr>
<tr><td><code>coefficients</code></td>
<td>
<p>the matrix of estimated coefficients. Each row corresponds to 
a covariate, while each column corresponds to an element of <code class="reqn">b(p)</code>,
the set of functions that describe how quantile regression coefficients vary with the 
order of the quantile. See &lsquo;Examples&rsquo;.</p>
</td></tr>
<tr><td><code>se</code></td>
<td>
<p>the estimated standard errors.</p>
</td></tr>
<tr><td><code>test.x</code></td>
<td>
<p>Wald test for the covariates. Each <em>row</em> of <code>coefficients</code> is tested for nullity.</p>
</td></tr>
<tr><td><code>test.p</code></td>
<td>
<p>Wald test for the building blocks of the quantile function. Each <em>column</em> of <code>coefficients</code> is tested for nullity.</p>
</td></tr>
<tr><td><code>obj.function</code></td>
<td>
<p>the minimized loss function (<kbd>NULL</kbd> if the data are censored or truncated).</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>the matched call.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>In version 1.0 of the package, a chi-squared goodness-of-fit test was provided.
The test appeared to be unreliable and has been removed from the subsequent versions. Use <code>test.fit</code>.
</p>


<h3>Author(s)</h3>

<p>Paolo Frumento <a href="mailto:paolo.frumento@unipi.it">paolo.frumento@unipi.it</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+iqr">iqr</a></code>, for model fitting; <code><a href="#topic+predict.iqr">predict.iqr</a></code> and <code><a href="#topic+plot.iqr">plot.iqr</a></code>,
for predicting and plotting objects of class &ldquo;<code>iqr</code>&rdquo;. <code><a href="#topic+test.fit.iqr">test.fit.iqr</a></code>
for a goodness-of-fit test.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# using simulated data

set.seed(1234); n &lt;- 1000
x1 &lt;- rexp(n)
x2 &lt;- runif(n)
qy &lt;- function(p,x){qnorm(p)*(1 + x)}
# true quantile function: Q(p | x) = beta0(p) + beta1(p)*x, with
   # beta0(p) = beta1(p) = qnorm(p)

y &lt;- qy(runif(n), x1) # to generate y, plug uniform p in qy(p,x)
                      # note that x2 does not enter

model &lt;- iqr(y ~ x1 + x2, formula.p = ~ I(qnorm(p)) + p + I(p^2))
# beta(p) is modeled by linear combinations of b(p) = (1, qnorm(p),p,p^2)

summary(model)
# interpretation: 
  # beta0(p) = model$coef[1,]*b(p)
  # beta1(p) = model$coef[2,]*b(p); etc.
# x2 and (p, p^2) are not significant


summary(model, p = c(0.25, 0.75)) # summary of beta(p) at selected quantiles
</code></pre>

<hr>
<h2 id='summary.iqrL'>
Summary After Quantile Regression Coefficients Modeling With Longitudinal Data
</h2><span id='topic+summary.iqrL'></span>

<h3>Description</h3>

<p>Summary of an object of class &ldquo;<code>iqrL</code>&rdquo;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'iqrL'
summary(object, p, level, cov = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.iqrL_+3A_object">object</code></td>
<td>

<p>an object of class &ldquo;<code>iqrL</code>&rdquo;, the result of a call to <code><a href="#topic+iqrL">iqrL</a></code>.
</p>
</td></tr>
<tr><td><code id="summary.iqrL_+3A_p">p</code></td>
<td>

<p>an optional vector of quantiles.
</p>
</td></tr>
<tr><td><code id="summary.iqrL_+3A_level">level</code></td>
<td>

<p>a numeric scalar. Use <code>level = 1</code> to summarize <code class="reqn">\beta(u)</code>, and 
<code>level = 2</code> to summarize <code class="reqn">\gamma(v)</code>. Ignored if <kbd>p</kbd> is missing.
</p>
</td></tr>
<tr><td><code id="summary.iqrL_+3A_cov">cov</code></td>
<td>

<p>logical. If <kbd>TRUE</kbd>, the covariance matrix of the coefficients or is reported.
Ignored if <kbd>p</kbd> is missing.
</p>
</td></tr>
<tr><td><code id="summary.iqrL_+3A_...">...</code></td>
<td>
<p>for future methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <kbd>p</kbd> is supplied, 
a standard summary of the estimated quantile regression coefficients 
is returned for each value of <kbd>p</kbd>: if <kbd>level = 1</kbd>,
a summary of <code>beta(p)</code>, and if <kbd>level = 2</kbd>, a summary of <code>gamma(p)</code>.
If <kbd>cov = TRUE</kbd>, the covariance matrix is also reported.
</p>
<p>If <kbd>p</kbd> is missing (the default), a list with the following items:
</p>
<table>
<tr><td><code>converged</code></td>
<td>
<p>logical value indicating the convergence status.</p>
</td></tr>
<tr><td><code>n.it</code></td>
<td>
<p>the number of iterations.</p>
</td></tr>
<tr><td><code>n</code></td>
<td>
<p>the number of observations.</p>
</td></tr>
<tr><td><code>n.id</code></td>
<td>
<p>the number of unique <kbd>id</kbd>s.</p>
</td></tr>
<tr><td><code>free.par</code></td>
<td>
<p>the number of free parameters in the model, excluding fixed effects.</p>
</td></tr>
<tr><td><code>theta</code></td>
<td>
<p>the estimate of <code class="reqn">\theta</code>.</p>
</td></tr>
<tr><td><code>se.theta</code></td>
<td>
<p>the estimated standard errors associated with <kbd>theta</kbd>.</p>
</td></tr>
<tr><td><code>phi</code></td>
<td>
<p>the estimate of <code class="reqn">\phi</code>.</p>
</td></tr>
<tr><td><code>se.phi</code></td>
<td>
<p>the estimated standard errors associated with <kbd>phi</kbd>.</p>
</td></tr>
<tr><td><code>test.row.theta</code>, <code>test.row.phi</code></td>
<td>
<p>Wald test for the covariates. Each <em>row</em> of <code>theta</code> and <code>phi</code> is tested for nullity.</p>
</td></tr>
<tr><td><code>test.col.theta</code>, <code>test.col.phi</code></td>
<td>
<p>Wald test for the building blocks of the quantile function. Each <em>column</em> of <code>theta</code> and <code>phi</code> is tested for nullity.</p>
</td></tr>
<tr><td><code>obj.function</code></td>
<td>
<p>the minimized loss function.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>the matched call.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Paolo Frumento <a href="mailto:paolo.frumento@unipi.it">paolo.frumento@unipi.it</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+iqrL">iqrL</a></code>, for model fitting; <code><a href="#topic+predict.iqrL">predict.iqrL</a></code> and <code><a href="#topic+plot.iqrL">plot.iqrL</a></code>,
for predicting and plotting objects of class &ldquo;<code>iqrL</code>&rdquo;; <code><a href="#topic+test.fit.iqrL">test.fit.iqrL</a></code>
for a goodness-of-fit test.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# using simulated data

n &lt;- 1000 # n. of observations
n.id &lt;- 100 # n. of clusters
id &lt;- rep(1:n.id, each = n/n.id) # cluster id

x &lt;- rexp(n) # a covariate

V &lt;- runif(n.id) # V_i
U &lt;- runif(n) # U_it
y &lt;- 1 + 2*log(U) + 3*x + 0.5*qnorm(V)

# true quantile function: Q(u,v | x) = beta0(u) + beta1(u)*x + gamma0(v), with
   # beta0(u) = 1 + 2*log(u)
   # beta1(u) = 3
   # gamma0(v) = 0.5*qnorm(v)

model &lt;- iqrL(fx = y ~ x, fu = ~ 1 + I(log(u)), fz = ~ 1, fv = ~ -1 + I(qnorm(v)), id = id)
summary(model)
summary(model, level = 1, p = c(0.25, 0.75)) # summary of beta(u) at selected quantiles
summary(model, level = 2, p = c(0.1, 0.9)) # summary of gamma(v) at selected quantiles
</code></pre>

<hr>
<h2 id='test.fit'>
Goodness-of-Fit Test
</h2><span id='topic+test.fit'></span>

<h3>Description</h3>

<p>Generic method for goodness-of-fit test. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>test.fit(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="test.fit_+3A_object">object</code></td>
<td>

<p>an object of class &ldquo;<code>iqr</code>&rdquo; or &ldquo;<code>iqrL</code>&rdquo;.
</p>
</td></tr>
<tr><td><code id="test.fit_+3A_...">...</code></td>
<td>

<p>additional arguments to be supplied to <code><a href="#topic+test.fit.iqr">test.fit.iqr</a></code> or <code><a href="#topic+test.fit.iqrL">test.fit.iqrL</a></code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function will simply call <code>test.fit.iqr</code> or <code>test.fit.iqrL</code> depending on <code>class(object)</code>.
</p>


<h3>Value</h3>

<p>The test statistic(s) and the associated p-values evaluated with Monte Carlo.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+test.fit.iqr">test.fit.iqr</a></code>, <code><a href="#topic+test.fit.iqrL">test.fit.iqrL</a></code>
</p>

<hr>
<h2 id='test.fit.iqr'>
Goodness-of-Fit Test
</h2><span id='topic+test.fit.iqr'></span>

<h3>Description</h3>

<p>Goodness-of-fit test for a model
fitted with <code><a href="#topic+iqr">iqr</a></code>. The Kolmogorov-Smirnov statistic and the Cramer-Von Mises statistic
are computed. Their distribution under the null hypothesis is evaluated
with Monte Carlo.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'iqr'
test.fit(object, R = 100, zcmodel, icmodel, trace = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="test.fit.iqr_+3A_object">object</code></td>
<td>

<p>an object of class &ldquo;<code>iqr</code>&rdquo;.
</p>
</td></tr>
<tr><td><code id="test.fit.iqr_+3A_r">R</code></td>
<td>

<p>number of Monte Carlo replications. If <kbd>R = 0</kbd>, the function only returns the test statistics.
</p>
</td></tr>
<tr><td><code id="test.fit.iqr_+3A_zcmodel">zcmodel</code></td>
<td>
<p>a numeric value indicating how to model the joint distribution of censoring 
(<code class="reqn">C</code>) and truncation (<code class="reqn">Z</code>). See &lsquo;Details&rsquo;.
</p>
</td></tr>
<tr><td><code id="test.fit.iqr_+3A_icmodel">icmodel</code></td>
<td>
<p>a list of operational parameters to simulate interval-censored data. See &lsquo;Details&rsquo;.
</p>
</td></tr>
<tr><td><code id="test.fit.iqr_+3A_trace">trace</code></td>
<td>
<p>logical. If <kbd>TRUE</kbd>, the progress will be printed.</p>
</td></tr>
<tr><td><code id="test.fit.iqr_+3A_...">...</code></td>
<td>
<p>for future arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function permits assessing goodness of fit by testing the null hypothesis
that the <abbr><span class="acronym">CDF</span></abbr> values follow a <code class="reqn">U(0,1)</code> distribution, indicating that
the model is correctly specified.
Since the fitted <abbr><span class="acronym">CDF</span></abbr> values depend on estimated parameters, the distribution of 
the test statistic is not known. To evaluate it, the model is fitted on <kbd>R</kbd> simulated datasets 
generated under the null hypothesis. 
</p>
<p>The testing procedures are described in details by Frumento and Bottai (2016, 2017) and Frumento and Corsini (2024).
</p>
<p><b>Right-censored and left-truncated data</b>. If the data are censored and truncated, <code>object$CDF</code> is as well a censored and truncated outcome, and its quantiles must be computed by using a suitable version of Kaplan-Meier product-limit estimator. The fitted survival curve is then compared with that of a <code class="reqn">U(0,1)</code> distribution. 
</p>
<p>To run Monte Carlo simulations when data are censored or truncated, it is necessary to estimate
the distribution of the censoring and that of the truncation variable. To this goal,
the function <code>pchreg</code> from the <span class="pkg">pch</span> package is used, with default settings.
</p>
<p>The joint distribution of the censoring variable (<code class="reqn">C</code>) and the truncation variable (<code class="reqn">Z</code>) 
can be specified in two ways:
</p>

<ul>
<li><p> If <kbd>zcmodel = 1</kbd>, it is assumed that <code class="reqn">C = Z + U</code>,
where <code class="reqn">U</code> is a positive variable and is independent of <code class="reqn">Z</code>, given covariates. This is the most
common situation, and is verified when censoring occurs at the end of the follow-up. Under this scenario,
<code class="reqn">C</code> and <code class="reqn">Z</code> are correlated with <code class="reqn">P(C &gt; Z) = 1</code>. 
</p>
</li>
<li><p> If <kbd>zcmodel = 2</kbd>, it is assumed that <code class="reqn">C</code> and <code class="reqn">Z</code> are conditionally independent.
This situation is more plausible when all censoring is due to drop-out.
</p>
</li></ul>

<p><b>Interval-censored data</b>. 
</p>
<p>If the data are interval-censored, <code>object$CDF</code> is composed of two columns, <code>left</code> and <code>right</code>. A nonparametric estimator is applied to the interval-censored pair <code>(left, right)</code> using the <span class="pkg">icenReg</span> R package. The fitted quantiles are then compared with those of a <code class="reqn">U(0,1)</code> distribution.
</p>
<p>To simulate interval-censored data, additional information is required about the censoring mechanism. This testing procedure assumes that interval censoring occurs because each individual is only examined at discrete time points, say <code>t[1], t[2], t[3],</code>... If this is not the mechanism that generated your data, you should not use this function.
</p>
<p>In the ideal situation, one can use <code>t[1], t[2], t[3],</code>... to estimate the distribution of the time between visits, <code>t[j + 1] - t[j]</code>. If, however, one only knows <code>time1</code> and <code>time2</code>, the two endpoints of the interval, things are more complicated. The empirical distribution of <code>time2 - time1</code> is NOT a good estimator of the distribution of <code>t[j + 1] - t[j]</code>, because the events are likely contained in longer intervals, a fact that obviously generates selection bias. There are two common situations: either <code>t[j + 1] - t[j]</code> is a constant (e.g., one month), or it is random. If <code>t[j + 1] - t[j]</code> is random and has an Exponential distribution with scale <code>lambda</code>, then <code>time2 - time1</code> has a <code>Gamma(shape = 2, scale = lambda)</code> distribution. This is due to the property of memoryless of the Exponential distribution, and may only be an approximation if there is a floor effect (i.e., if <code>lambda</code> is larger than the low quantiles of the time-to-event).
</p>
<p>The <code>icmodel</code> argument must be a list with four elements, <code>model</code>, <code>lambda</code> (optional), <code>t0</code>, and <code>logscale</code>:
</p>

<ul>
<li> <p><code>model</code>. A character string, either <code>'constant'</code> or <code>'exponential'</code>.
</p>
</li>
<li> <p><code>lambda</code>. If <code>model = 'constant'</code>, <code>lambda</code> will be interpreted as a constant time between visits. If <code>model = 'exponential'</code>, instead, it will be interpreted as the <em>mean</em> (not the rate) of the Exponential distribution that is assumed to describe the time between visits.
</p>
<p>If you either <em>know</em> <code>lambda</code>, or you can estimate it by using additional information (e.g., individual data on <em>all</em> visit times <code>t[1], t[2], t[3], </code>...), you can supply a scalar value, that will be used for all individuals, or a vector, allowing <code>lambda</code> to differ across individuals.
</p>
<p>If, instead, <code>lambda</code> is not supplied or is <code>NULL</code>, the algorithm proceeds as follows. If <code>model = 'constant'</code>, the time between visits is assumed to be constant and equal to <code>lambda = mean(time2 - time1)</code>. If <code>model = 'exponential'</code>, times between visits are generated from an Exponential distribution in which the mean, <code>lambda</code>, is allowed to depend on covariates according to a log-linear model, and is estimated by fitting a Gamma model on <code>time2 - time1</code> as described earlier. 
</p>
</li>
<li> <p><code>t0</code>. If <code>t0 = 0</code>, data will be simulated assuming that the first visit occurs at time = 0 (the &ldquo;onset&rdquo;), i.e., when the individual enters the risk set. This mechanism cannot generate left censoring. If <code>t0 = 1</code>, instead, the first visit occurs <em>after</em> time zero. This mechanism generates left censoring whenever the event occurs before the first visit. Finally, if <code>t0 = -1</code>, visits start <em>before</em> time 0. Under this scenario, it is assumed that not only the time at the event, but also the time at onset is interval-censored. If the event occurs in the interval <code>(time1, time2)</code>, and the onset is in <code>(t01, t02)</code>, then the total duration is in the interval <code>(time1 - t02, time2 - t01)</code>.
</p>
</li>
<li> <p><code>logscale</code>. Logical: is the response variable on the log scale? If this is the case, the Monte Carlo procedure will act accordingly. Note that <code>lambda</code> will always be assumed to describe the time between visits on the <em>natural</em> scale.
</p>
</li></ul>

<p>The mechanism described above can automatically account for the presence of left censoring.
In order to simulate right-censored observations (if present in the data), the distribution of the censoring variable is estimated with the function <code>pchreg</code> from the <span class="pkg">pch</span> package.
</p>


<h3>Value</h3>

<p>a matrix with columns <code>statistic</code> and <code>p.value</code>, 
reporting the Kolmogorov-Smirnov and Cramer-Von Mises statistic and the associated
p-values evaluated with Monte Carlo.
</p>


<h3>Author(s)</h3>

<p>Paolo Frumento <a href="mailto:paolo.frumento@unipi.it">paolo.frumento@unipi.it</a>
</p>


<h3>References</h3>

<p>Frumento, P., and Bottai, M. (2016). <em>Parametric modeling of quantile regression coefficient functions</em>. Biometrics, 72 (1), pp 74-84, doi: 10.1111/biom.12410.
</p>
<p>Frumento, P., and Bottai, M. (2017). <em>Parametric modeling of quantile regression coefficient functions with censored and truncated data</em>. Biometrics, doi: 10.1111/biom.12675.
</p>
<p>Frumento, P., and Corsini, L. (2024). <em>Using parametric quantile regression
to investigate determinants of unemployment duration</em>. Unpublished manuscript.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>y &lt;- rnorm(1000)
m1 &lt;- iqr(y ~ 1, formula.p = ~ I(qnorm(p))) # correct
m2 &lt;- iqr(y ~ 1, formula.p = ~ p)  # misspecified

test.fit(m1)
test.fit(m2)

</code></pre>

<hr>
<h2 id='test.fit.iqrL'>
Goodness-of-Fit Test
</h2><span id='topic+test.fit.iqrL'></span>

<h3>Description</h3>

<p>Goodness-of-fit test for a model
fitted with <code><a href="#topic+iqrL">iqrL</a></code>. The Kolmogorov-Smirnov statistic is computed and its
distribution under the null hypothesis is evaluated with Monte Carlo.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'iqrL'
test.fit(object, R = 100, trace = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="test.fit.iqrL_+3A_object">object</code></td>
<td>

<p>an object of class &ldquo;<code>iqrL</code>&rdquo;.
</p>
</td></tr>
<tr><td><code id="test.fit.iqrL_+3A_r">R</code></td>
<td>

<p>number of Monte Carlo replications. If <kbd>R = 0</kbd>, the function only returns the test statistic.
</p>
</td></tr>
<tr><td><code id="test.fit.iqrL_+3A_trace">trace</code></td>
<td>
<p>logical. If <kbd>TRUE</kbd>, the progress will be printed.</p>
</td></tr>
<tr><td><code id="test.fit.iqrL_+3A_...">...</code></td>
<td>
<p>for future arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function permits assessing goodness of fit by testing the null hypothesis
that the estimated <code>(u,v)</code> values are independent uniform variables. 
To evaluate the distribution of the test statistic under the true model, a Monte Carlo
method is used (Frumento et al, 2021).
</p>


<h3>Value</h3>

<p>a vector with entries <code>statistic</code> and <code>p.value</code>, 
reporting the Kolmogorov-Smirnov statistic (evaluated on a grid)
and the associated p-value.
</p>


<h3>Author(s)</h3>

<p>Paolo Frumento <a href="mailto:paolo.frumento@unipi.it">paolo.frumento@unipi.it</a>
</p>


<h3>References</h3>

<p>Frumento, P., Bottai, M., and Fernandez-Val, I. (2021). <em>Parametric modeling of quantile regression coefficient functions with longitudinal data</em>. Journal of the American Statistical Association, 116 (534), 783-797.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>id &lt;- rep(1:50, each = 10)
y &lt;- rnorm(500) + rnorm(50)[id]
m1 &lt;- iqrL(fx = y ~ 1, fu = ~ I(qnorm(u)), id = id) # correct
m2 &lt;- iqrL(fx = y ~ 1, fu = ~ u, id = id)  # misspecified

test.fit(m1, R = 20)
test.fit(m2, R = 20)

# Warning: this procedure may be time-consuming.
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
