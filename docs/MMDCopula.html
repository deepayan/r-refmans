<!DOCTYPE html><html lang="en"><head><title>Help for package MMDCopula</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {MMDCopula}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#BiCopConfIntMMD'><p>Confidence intervals for the estimated parameter</p>
of a bivariate parametric copula using MMD estimation</a></li>
<li><a href='#BiCopEst.MO'><p>Estimation of Marshall-Olkin copulas</p></a></li>
<li><a href='#BiCopEstMMD'><p>Estimation of parametric bivariate copulas using</p>
stochastic gradient descent on the MMD criteria</a></li>
<li><a href='#BiCopGradMMD'><p>Computation of the gradient of the MMD criterion</p>
for parametric bivariate copulas models</a></li>
<li><a href='#BiCopPar2Tau.MO'><p>Convert between parameter and Kendall's tau for Marshall-Olkin copulas</p></a></li>
<li><a href='#BiCopParamDistLp'><p>Compute the distance between 2 parametric copulas</p></a></li>
<li><a href='#BiCopSim.MO'><p>Simulation of Marshall-Olkin copula</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Robust Estimation of Copulas by Maximum Mean Discrepancy</td>
</tr>
<tr>
<td>Version:</td>
<td>0.2.1</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides functions for the robust estimation of 
	parametric families of copulas using minimization of 
	the Maximum Mean Discrepancy, following the article
	Alquier, Chérief-Abdellatif, Derumigny and Fermanian (2022)
	&lt;<a href="https://doi.org/10.1080%2F01621459.2021.2024836">doi:10.1080/01621459.2021.2024836</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.2</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.6.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>VineCopula, cubature, randtoolbox, pbapply, wdm</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/AlexisDerumigny/MMDCopula/issues">https://github.com/AlexisDerumigny/MMDCopula/issues</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-04-25 09:09:56 UTC; Alexis</td>
</tr>
<tr>
<td>Author:</td>
<td>Alexis Derumigny <a href="https://orcid.org/0000-0002-6163-8097"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Pierre Alquier <a href="https://orcid.org/0000-0003-4249-7337"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Jean-David Fermanian
    <a href="https://orcid.org/0000-0001-5960-5555"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  Badr-Eddine Chérief-Abdellatif [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Alexis Derumigny &lt;a.f.f.derumigny@tudelft.nl&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-04-25 09:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='BiCopConfIntMMD'>Confidence intervals for the estimated parameter
of a bivariate parametric copula using MMD estimation</h2><span id='topic+BiCopConfIntMMD'></span>

<h3>Description</h3>

<p>Confidence intervals for the estimated parameter
of a bivariate parametric copula using MMD estimation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BiCopConfIntMMD(
  x1,
  x2,
  family,
  nResampling = 100,
  subsamplingSize = length(x1),
  corrSubSampling = TRUE,
  level = 0.95,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="BiCopConfIntMMD_+3A_x1">x1</code></td>
<td>
<p>vector of observations of the first coordinate.</p>
</td></tr>
<tr><td><code id="BiCopConfIntMMD_+3A_x2">x2</code></td>
<td>
<p>vector of observations of the second coordinate.</p>
</td></tr>
<tr><td><code id="BiCopConfIntMMD_+3A_family">family</code></td>
<td>
<p>parametric family of copulas.
Supported families are: </p>

<ul>
<li> <p><code>1</code>: Gaussian copulas
</p>
</li>
<li> <p><code>3</code>: Clayton copulas
</p>
</li>
<li> <p><code>4</code>: Gumbel copulas
</p>
</li>
<li> <p><code>5</code>: Frank copulas
</p>
</li>
<li> <p><code>MO</code>: Marshall-Olkin copulas
</p>
</li></ul>
</td></tr>
<tr><td><code id="BiCopConfIntMMD_+3A_nresampling">nResampling</code></td>
<td>
<p>number of resampling times.</p>
</td></tr>
<tr><td><code id="BiCopConfIntMMD_+3A_subsamplingsize">subsamplingSize</code></td>
<td>
<p>size of the subsample.
By default it is <code>length(u1)</code>,
i.e. this corresponds to the nonparametric boostrap.</p>
</td></tr>
<tr><td><code id="BiCopConfIntMMD_+3A_corrsubsampling">corrSubSampling</code></td>
<td>
<p>this parameter is only used for subsampling-based confidence intervals.
If <code>TRUE</code>, the confidence interval uses the corrected subsample empirical process.</p>
</td></tr>
<tr><td><code id="BiCopConfIntMMD_+3A_level">level</code></td>
<td>
<p>the nominal confidence level.</p>
</td></tr>
<tr><td><code id="BiCopConfIntMMD_+3A_...">...</code></td>
<td>
<p>other parameters to be given to <code><a href="#topic+BiCopEstMMD">BiCopEstMMD</a></code>
or <code><a href="#topic+BiCopEst.MO">BiCopEst.MO</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with the confidence intervals CI.Tau for Kendall's tau
and CI.Par for the corresponding parameter.
</p>


<h3>References</h3>

<p>Alquier, P., Chérief-Abdellatif, B.-E., Derumigny, A., and Fermanian, J.D. (2022).
Estimation of copulas via Maximum Mean Discrepancy.
Journal of the American Statistical Association, <a href="https://doi.org/10.1080/01621459.2021.2024836">doi:10.1080/01621459.2021.2024836</a>.
</p>
<p>Kojadinovic I., and Stemikovskaya, K. (2019)
Subsampling (weighted smooth) empirical copula processes.
Journal of Multivariate Analysis, 173, 704-723,
<a href="https://doi.org/10.1016/j.jmva.2019.05.007">doi:10.1016/j.jmva.2019.05.007</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data = VineCopula::BiCopSim(N = 50, family = 1, par = 0.3)
result = BiCopConfIntMMD(x1 = data[,1], x2 = data[,2], family = 1,
  nResampling = 2, subsamplingSize = 10, niter = 10)

data_ = VineCopula::BiCopSim(N = 1000, family = 1, par = 0.3)
result_ = BiCopConfIntMMD(x1 = data_[,1], x2 = data_[,2], family = 1)
result_$CI.Tau
result_$CI.Par


</code></pre>

<hr>
<h2 id='BiCopEst.MO'>Estimation of Marshall-Olkin copulas</h2><span id='topic+BiCopEst.MO'></span>

<h3>Description</h3>

<p>Estimation of Marshall-Olkin copulas
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BiCopEst.MO(
  u1,
  u2,
  method,
  par.start = 0.5,
  kernel = "gaussian.Phi",
  gamma = 0.95,
  alpha = 1,
  niter = 100,
  C_eta = 1,
  ndrawings = 10,
  naveraging = 1
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="BiCopEst.MO_+3A_u1">u1</code></td>
<td>
<p>vector of observations of the first coordinate, in <code class="reqn">[0,1]</code>.</p>
</td></tr>
<tr><td><code id="BiCopEst.MO_+3A_u2">u2</code></td>
<td>
<p>vector of observations of the second coordinate, in <code class="reqn">[0,1]</code>.</p>
</td></tr>
<tr><td><code id="BiCopEst.MO_+3A_method">method</code></td>
<td>
<p>a character giving the name of the estimation method, among:
</p>

<ul>
<li> <p><code>curve</code>: <code class="reqn">\alpha</code> is estimated by inversion of
the probability measure of the diagonal
<code class="reqn">\{(u,v): u = v\}</code>
</p>
</li>
<li> <p><code>itau</code>: <code class="reqn">\alpha</code> is estimated by inversion of Kendall's tau
</p>
</li>
<li> <p><code>MMD</code>: <code class="reqn">\alpha</code> is estimated by MMD optimization
</p>
</li></ul>
</td></tr>
<tr><td><code id="BiCopEst.MO_+3A_par.start">par.start</code></td>
<td>
<p>starting parameter of the gradient descent.
(only used for <code>method = "MMD"</code>)</p>
</td></tr>
<tr><td><code id="BiCopEst.MO_+3A_kernel">kernel</code></td>
<td>
<p>the kernel used in the MMD distance
(only used for <code>method = "MMD"</code>) :
it can be a function taking in parameter <code>(u1, u2, v1, v2, gamma, alpha)</code>
or a name giving the kernel to use in the list:
</p>

<ul>
<li> <p><code>"gaussian"</code>: Gaussian kernel <code class="reqn">k(x,y) = \exp(-\|\frac{x-y}{\gamma}\|_2^2)
    </code>
</p>
</li>
<li> <p><code>"exp-l2"</code>: <code class="reqn">k(x,y) = \exp(-\|\frac{x-y}{\gamma}\|_2)
    </code>
</p>
</li>
<li> <p><code>"exp-l1"</code>: <code class="reqn">k(x,y) = \exp(-\|\frac{x-y}{\gamma}\|_1)
    </code>
</p>
</li>
<li> <p><code>"inv-l2"</code>: <code class="reqn">k(x,y) = 1/(1+\|\frac{x-y}{\gamma}\|_2)^\alpha
    </code>
</p>
</li>
<li> <p><code>"inv-l1"</code>: <code class="reqn">k(x,y) = 1/(1+\|\frac{x-y}{\gamma}\|_1)^\alpha
    </code>
</p>
</li></ul>

<p>Each of these names can receive the suffix <code>".Phi"</code>, such as <code>"gaussian.Phi"</code>
to indicates that the kernel <code class="reqn">k(x,y)</code> is replaced by
<code class="reqn">k(\Phi^{-1}(x) , \Phi^{-1}(y))</code> where <code class="reqn">\Phi^{-1}</code> denotes the quantile
function of the standard Normal distribution.</p>
</td></tr>
<tr><td><code id="BiCopEst.MO_+3A_gamma">gamma</code></td>
<td>
<p>parameter <code class="reqn">\gamma</code> to be used in the kernel.
(only used for <code>method = "MMD"</code>)</p>
</td></tr>
<tr><td><code id="BiCopEst.MO_+3A_alpha">alpha</code></td>
<td>
<p>parameter <code class="reqn">\alpha</code> to be used in the kernel, if any.
(only used for <code>method = "MMD"</code>)</p>
</td></tr>
<tr><td><code id="BiCopEst.MO_+3A_niter">niter</code></td>
<td>
<p>the stochastic gradient algorithm is composed of two phases:
a first &quot;burn-in&quot; phase and a second &quot;averaging&quot; phase.
If <code>niter</code> is of size <code>1</code>, the same number of iterations is used for
both phases of the stochastic gradient algorithm. If <code>niter</code> is of size <code>2</code>,
then <code>niter[1]</code> iterations are done for the burn-in phase and <code>niter[2]</code>
for the averaging phase.
(only used for <code>method = "MMD"</code>)</p>
</td></tr>
<tr><td><code id="BiCopEst.MO_+3A_c_eta">C_eta</code></td>
<td>
<p>a multiplicative constant controlling for the size of the gradient descent step.
The step size is then computed as <code>C_eta / sqrt(i_iter)</code>
where <code>i_iter</code> is the index of the current iteration of the stochastic gradient algorithm.
(only used for <code>method = "MMD"</code>)</p>
</td></tr>
<tr><td><code id="BiCopEst.MO_+3A_ndrawings">ndrawings</code></td>
<td>
<p>number of replicas of the stochastic estimate of the gradient
drawn at each step. The gradient is computed using the average of these replicas.
(only used for <code>method = "MMD"</code>)</p>
</td></tr>
<tr><td><code id="BiCopEst.MO_+3A_naveraging">naveraging</code></td>
<td>
<p>number of full run of the stochastic gradient algorithm
that are averaged at the end to give the final estimated parameter.
(only used for <code>method = "MMD"</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the estimated parameter (<code>alpha</code>) of the Marshall-Olkin copula.
</p>


<h3>References</h3>

<p>Alquier, P., Chérief-Abdellatif, B.-E., Derumigny, A., and Fermanian, J.D. (2022).
Estimation of copulas via Maximum Mean Discrepancy.
Journal of the American Statistical Association, <a href="https://doi.org/10.1080/01621459.2021.2024836">doi:10.1080/01621459.2021.2024836</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+BiCopSim.MO">BiCopSim.MO</a></code> for the estimation of
Marshall-Olkin copulas.
<code><a href="#topic+BiCopEstMMD">BiCopEstMMD</a></code> for the estimation of other parametric copula families by MMD.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>U &lt;- BiCopSim.MO(n = 1000, alpha = 0.2)
estimatedPar &lt;- BiCopEst.MO(u1 = U[,1], u2 = U[,2], method = "MMD", niter = 1, ndrawings = 1)

estimatedPar &lt;- BiCopEst.MO(u1 = U[,1], u2 = U[,2], method = "MMD")


</code></pre>

<hr>
<h2 id='BiCopEstMMD'>Estimation of parametric bivariate copulas using
stochastic gradient descent on the MMD criteria</h2><span id='topic+BiCopEstMMD'></span>

<h3>Description</h3>

<p>This function uses computes the MMD-estimator of a bivariate copula family.
This computation is done through a stochastic gradient algorithm,
that is itself computed by the function <code><a href="#topic+BiCopGradMMD">BiCopGradMMD</a>()</code>.
The main arguments are the two vectors of observations, and the copula family.
The bidimensional copula families are indexed in the same way as
in <code>VineCopula::<a href="VineCopula.html#topic+BiCop">BiCop</a>()</code> (which computes the MLE estimator).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BiCopEstMMD(
  u1,
  u2,
  family,
  tau = NULL,
  par = NULL,
  par2 = NULL,
  kernel = "gaussian",
  gamma = "default",
  alpha = 1,
  niter = 100,
  C_eta = 1,
  epsilon = 1e-04,
  method = "QMCV",
  quasiRNG = "sobol",
  ndrawings = 10
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="BiCopEstMMD_+3A_u1">u1</code></td>
<td>
<p>vector of observations of the first coordinate, in <code class="reqn">[0,1]</code>.</p>
</td></tr>
<tr><td><code id="BiCopEstMMD_+3A_u2">u2</code></td>
<td>
<p>vector of observations of the second coordinate, in <code class="reqn">[0,1]</code>.</p>
</td></tr>
<tr><td><code id="BiCopEstMMD_+3A_family">family</code></td>
<td>
<p>the chosen family of copulas
(see the documentation of the class <code>VineCopula::<a href="VineCopula.html#topic+BiCop">BiCop</a>()</code>
for the available families).</p>
</td></tr>
<tr><td><code id="BiCopEstMMD_+3A_tau">tau</code></td>
<td>
<p>the copula family can be parametrized by the parameter <code>par</code>
or by Kendall's tau.
Here, the user can choose the initial value of tau for the stochastic gradient algorithm.
If <code>NULL</code>, a random value is chosen instead.</p>
</td></tr>
<tr><td><code id="BiCopEstMMD_+3A_par">par</code></td>
<td>
<p>if different from <code>NULL</code>, the parameter <code>tau</code> is ignored,
and the initial parameter must be given here.
The initial Kendall's tau is then computed thanks to
<code>VineCopula::<a href="VineCopula.html#topic+BiCopPar2Tau">BiCopPar2Tau</a>()</code>.</p>
</td></tr>
<tr><td><code id="BiCopEstMMD_+3A_par2">par2</code></td>
<td>
<p>initial value for the second parameter, if any. (Works only for Student copula).</p>
</td></tr>
<tr><td><code id="BiCopEstMMD_+3A_kernel">kernel</code></td>
<td>
<p>the kernel used in the MMD distance:
it can be a function taking in parameter <code>(u1, u2, v1, v2, gamma, alpha)</code>
or a name giving the kernel to use in the list:
</p>

<ul>
<li> <p><code>"gaussian"</code>: Gaussian kernel <code class="reqn">k(x,y) = \exp(-\|\frac{x-y}{\gamma}\|_2^2)
   </code>
</p>
</li>
<li> <p><code>"exp-l2"</code>: <code class="reqn">k(x,y) = \exp(-\|\frac{x-y}{\gamma}\|_2)
   </code>
</p>
</li>
<li> <p><code>"exp-l1"</code>: <code class="reqn">k(x,y) = \exp(-\|\frac{x-y}{\gamma}\|_1)
   </code>
</p>
</li>
<li> <p><code>"inv-l2"</code>: <code class="reqn">k(x,y) = 1/(1+\|\frac{x-y}{\gamma}\|_2)^\alpha
   </code>
</p>
</li>
<li> <p><code>"inv-l1"</code>: <code class="reqn">k(x,y) = 1/(1+\|\frac{x-y}{\gamma}\|_1)^\alpha
   </code>
</p>
</li></ul>

<p>Each of these names can receive the suffix <code>".Phi"</code>, such as <code>"gaussian.Phi"</code>
to indicates that the kernel <code class="reqn">k(x,y)</code> is replaced by
<code class="reqn">k(\Phi^{-1}(x) , \Phi^{-1}(y))</code> where <code class="reqn">\Phi^{-1}</code> denotes the quantile
function of the standard Normal distribution.</p>
</td></tr>
<tr><td><code id="BiCopEstMMD_+3A_gamma">gamma</code></td>
<td>
<p>parameter <code class="reqn">\gamma</code> to be used in the kernel.
If <code>gamma="default"</code>, a default value is used.</p>
</td></tr>
<tr><td><code id="BiCopEstMMD_+3A_alpha">alpha</code></td>
<td>
<p>parameter <code class="reqn">\alpha</code> to be used in the kernel, if any.</p>
</td></tr>
<tr><td><code id="BiCopEstMMD_+3A_niter">niter</code></td>
<td>
<p>the stochastic gradient algorithm is composed of two phases:
a first &quot;burn-in&quot; phase and a second &quot;averaging&quot; phase.
If <code>niter</code> is of size <code>1</code>, the same number of iterations is used for
both phases of the stochastic gradient algorithm. If <code>niter</code> is of size <code>2</code>,
then <code>niter[1]</code> iterations are done for the burn-in phase and <code>niter[2]</code>
for the averaging phase.</p>
</td></tr>
<tr><td><code id="BiCopEstMMD_+3A_c_eta">C_eta</code></td>
<td>
<p>a multiplicative constant controlling for the size of the gradient descent step.
The step size is then computed as <code>C_eta / sqrt(i_iter)</code>
where <code>i_iter</code> is the index of the current iteration of the stochastic gradient algorithm.</p>
</td></tr>
<tr><td><code id="BiCopEstMMD_+3A_epsilon">epsilon</code></td>
<td>
<p>the differential of <code>VineCopula::<a href="VineCopula.html#topic+BiCopTau2Par">BiCopTau2Par</a>()</code>
is computed thanks to a finite difference with increment <code>epsilon</code>.</p>
</td></tr>
<tr><td><code id="BiCopEstMMD_+3A_method">method</code></td>
<td>
<p>the method of computing the stochastic gradient:
</p>

<ul>
<li> <p><code>MC</code>: classical Monte-Carlo with <code>ndrawings</code> replications.
</p>
</li>
<li> <p><code>QMCV</code>: usual Monte-Carlo on U with <code>ndrawings</code> replications,
quasi Monte-Carlo on V.
</p>
</li></ul>
</td></tr>
<tr><td><code id="BiCopEstMMD_+3A_quasirng">quasiRNG</code></td>
<td>
<p>a function giving the quasi-random points in <code class="reqn">[0,1]^2</code> or a name giving
the method to use in the list: </p>

<ul>
<li> <p><code>sobol</code>: use of the Sobol sequence
implemented in <code>randtoolbox::<a href="randtoolbox.html#topic+quasiRNG">sobol</a></code>
</p>
</li>
<li> <p><code>halton</code>: use of the Halton sequence
implemented in <code>randtoolbox::<a href="randtoolbox.html#topic+quasiRNG">halton</a></code>
</p>
</li>
<li> <p><code>torus</code>: use of the Torus sequence
implemented in <code>randtoolbox::<a href="randtoolbox.html#topic+quasiRNG">torus</a></code>
</p>
</li></ul>
</td></tr>
<tr><td><code id="BiCopEstMMD_+3A_ndrawings">ndrawings</code></td>
<td>
<p>number of replicas of the stochastic estimate of the gradient drawn
at each step. The gradient is computed using the average of these replicas.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class <code>VineCopula::<a href="VineCopula.html#topic+BiCop">BiCop</a>()</code>
containing the estimated copula.
</p>


<h3>References</h3>

<p>Alquier, P., Chérief-Abdellatif, B.-E., Derumigny, A., and Fermanian, J.D. (2022).
Estimation of copulas via Maximum Mean Discrepancy.
Journal of the American Statistical Association, <a href="https://doi.org/10.1080/01621459.2021.2024836">doi:10.1080/01621459.2021.2024836</a>.
</p>


<h3>See Also</h3>

<p><code>VineCopula::<a href="VineCopula.html#topic+BiCopEst">BiCopEst</a>()</code> for other methods of estimation
such as Maximum Likelihood Estimation or Inversion of Kendall's tau.
<code><a href="#topic+BiCopGradMMD">BiCopGradMMD</a>()</code> for the computation of the stochastic gradient.
<code><a href="#topic+BiCopEst.MO">BiCopEst.MO</a></code> for the estimation of Marshall-Olkin copulas by MMD.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Estimation of a bivariate Gaussian copula with correlation 0.5.
dataSampled = VineCopula::BiCopSim(N = 500, family = 1, par = 0.5)
estimator = BiCopEstMMD(u1 = dataSampled[,1], u2 = dataSampled[,2], family = 1, niter = 10)
estimator$par


# Estimation of a bivariate Student copula with correlation 0.5 and 5 degrees of freedom
dataSampled = VineCopula::BiCopSim(N = 1000, family = 2, par = 0.5, par2 = 5)
estimator = BiCopEstMMD(u1 = dataSampled[,1], u2 = dataSampled[,2], family = 2)
estimator$par
estimator$par2


# Comparison with maximum likelihood estimation with and without outliers
dataSampled = VineCopula::BiCopSim(N = 500, family = 1, par = 0.5)
estimatorMMD = BiCopEstMMD(u1 = dataSampled[,1], u2 = dataSampled[,2], family = 1)
estimatorMMD$par
estimatorMLE = VineCopula::BiCopEst(u1 = dataSampled[,1], u2 = dataSampled[,2],
  family = 1, method = "mle")
estimatorMLE$par

dataSampled[1:10,1] = 0.999
dataSampled[1:10,2] = 0.001
estimatorMMD = BiCopEstMMD(u1 = dataSampled[,1], u2 = dataSampled[,2], family = 1)
estimatorMMD$par
estimatorMLE = VineCopula::BiCopEst(u1 = dataSampled[,1], u2 = dataSampled[,2],
  family = 1, method = "mle")
estimatorMLE$par


# Estimation of a bivariate Gaussian copula with real data
data("daxreturns", package = "VineCopula")
BiCopEstMMD(u1 = daxreturns[,1], u2 = daxreturns[,2], family = 1)
estimator$par



</code></pre>

<hr>
<h2 id='BiCopGradMMD'>Computation of the gradient of the MMD criterion
for parametric bivariate copulas models</h2><span id='topic+BiCopGradMMD'></span>

<h3>Description</h3>

<p>This function computes a stochastic estimate of the gradient of the MMD criterion
for parametric estimation of bidimensional copula family.
The main arguments are the two vectors of observations, and the copula family.
The family is parametrized as in <code>VineCopula::<a href="VineCopula.html#topic+BiCop">BiCop</a>()</code>,
using the Kendall's tau instead of the first parameter.
This function is used by <code><a href="#topic+BiCopEstMMD">BiCopEstMMD</a>()</code> to perform parameter estimation
via MMD minimization.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BiCopGradMMD(
  u1,
  u2,
  family,
  tau,
  par = NULL,
  par2 = 0,
  kernel = "gaussian.Phi",
  gamma = 0.95,
  alpha = 1,
  epsilon = 1e-04,
  method = "QMCV",
  quasiRNG = "sobol",
  ndrawings = 10
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="BiCopGradMMD_+3A_u1">u1</code></td>
<td>
<p>vector of observations of the first coordinate, in <code class="reqn">[0,1]</code>.</p>
</td></tr>
<tr><td><code id="BiCopGradMMD_+3A_u2">u2</code></td>
<td>
<p>vector of observations of the second coordinate, in <code class="reqn">[0,1]</code>.</p>
</td></tr>
<tr><td><code id="BiCopGradMMD_+3A_family">family</code></td>
<td>
<p>the chosen family of copulas
(see the documentation of the class <code>VineCopula::<a href="VineCopula.html#topic+BiCop">BiCop</a>()</code>
for the available families).</p>
</td></tr>
<tr><td><code id="BiCopGradMMD_+3A_tau">tau</code></td>
<td>
<p>the copula family can be parametrized by the parameter <code>par</code>
or by Kendall's tau. This function assumes a Kendall tau parametrization.
Thus, the user can choose the value of Kendall tau at
which the stochastic gradient should be computed.</p>
</td></tr>
<tr><td><code id="BiCopGradMMD_+3A_par">par</code></td>
<td>
<p>if different from <code>NULL</code>,
the user must instead of <code>tau</code> specify the corresponding parameter <code>par</code>.
The value of <code>tau</code> is then ignored.</p>
</td></tr>
<tr><td><code id="BiCopGradMMD_+3A_par2">par2</code></td>
<td>
<p>value for the second parameter, if any. (Works only for Student copula).</p>
</td></tr>
<tr><td><code id="BiCopGradMMD_+3A_kernel">kernel</code></td>
<td>
<p>the kernel used in the MMD distance:
it can be a function taking in parameter <code>(u1, u2, v1, v2, gamma, alpha)</code>
or a name giving the kernel to use in the list:
</p>

<ul>
<li> <p><code>"gaussian"</code>: Gaussian kernel <code class="reqn">k(x,y) = \exp(-\|\frac{x-y}{\gamma}\|_2^2)
   </code>
</p>
</li>
<li> <p><code>"exp-l2"</code>: <code class="reqn">k(x,y) = \exp(-\|\frac{x-y}{\gamma}\|_2)
   </code>
</p>
</li>
<li> <p><code>"exp-l1"</code>: <code class="reqn">k(x,y) = \exp(-\|\frac{x-y}{\gamma}\|_1)
   </code>
</p>
</li>
<li> <p><code>"inv-l2"</code>: <code class="reqn">k(x,y) = 1/(1+\|\frac{x-y}{\gamma}\|_2)^\alpha
   </code>
</p>
</li>
<li> <p><code>"inv-l1"</code>: <code class="reqn">k(x,y) = 1/(1+\|\frac{x-y}{\gamma}\|_1)^\alpha
   </code>
</p>
</li></ul>

<p>Each of these names can receive the suffix <code>".Phi"</code>, such as <code>"gaussian.Phi"</code>
to indicates that the kernel <code class="reqn">k(x,y)</code> is replaced by
<code class="reqn">k(\Phi^{-1}(x) , \Phi^{-1}(y))</code> where <code class="reqn">\Phi^{-1}</code> denotes the quantile
function of the standard Normal distribution.</p>
</td></tr>
<tr><td><code id="BiCopGradMMD_+3A_gamma">gamma</code></td>
<td>
<p>parameter <code class="reqn">\gamma</code> to be used in the kernel.</p>
</td></tr>
<tr><td><code id="BiCopGradMMD_+3A_alpha">alpha</code></td>
<td>
<p>parameter <code class="reqn">\alpha</code> to be used in the kernel, if any.</p>
</td></tr>
<tr><td><code id="BiCopGradMMD_+3A_epsilon">epsilon</code></td>
<td>
<p>the differential of <code>VineCopula::<a href="VineCopula.html#topic+BiCopTau2Par">BiCopTau2Par</a>()</code>
is computed thanks to a finite difference with increment <code>epsilon</code>.</p>
</td></tr>
<tr><td><code id="BiCopGradMMD_+3A_method">method</code></td>
<td>
<p>the method of computing the stochastic gradient:
</p>

<ul>
<li> <p><code>MC</code>: classical Monte-Carlo with <code>ndrawings</code> replications.
</p>
</li>
<li> <p><code>QMCV</code>: usual Monte-Carlo on U with <code>ndrawings</code> replications,
quasi Monte-Carlo on V.
</p>
</li></ul>
</td></tr>
<tr><td><code id="BiCopGradMMD_+3A_quasirng">quasiRNG</code></td>
<td>
<p>a function giving the quasi-random points in <code class="reqn">[0,1]^2</code> or a name giving
the method to use in the list: </p>

<ul>
<li> <p><code>sobol</code>: use of the Sobol sequence
implemented in <code>randtoolbox::<a href="randtoolbox.html#topic+quasiRNG">sobol</a></code>
</p>
</li>
<li> <p><code>halton</code>: use of the Halton sequence
implemented in <code>randtoolbox::<a href="randtoolbox.html#topic+quasiRNG">halton</a></code>
</p>
</li>
<li> <p><code>torus</code>: use of the Torus sequence
implemented in <code>randtoolbox::<a href="randtoolbox.html#topic+quasiRNG">torus</a></code>
</p>
</li></ul>
</td></tr>
<tr><td><code id="BiCopGradMMD_+3A_ndrawings">ndrawings</code></td>
<td>
<p>number of replicas of the stochastic estimate of the gradient drawn
at each step. The gradient is computed using the average of these replicas.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the value of the gradient.
</p>


<h3>References</h3>

<p>Alquier, P., Chérief-Abdellatif, B.-E., Derumigny, A., and Fermanian, J.D. (2022).
Estimation of copulas via Maximum Mean Discrepancy.
Journal of the American Statistical Association, <a href="https://doi.org/10.1080/01621459.2021.2024836">doi:10.1080/01621459.2021.2024836</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+BiCopEstMMD">BiCopEstMMD</a>()</code> for the estimation of parametric bivariate copulas by
stochastic gradient descent on the MMD criteria.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Simulation from a bivariate Gaussian copula with correlation 0.5.
dataSampled = VineCopula::BiCopSim(N = 500, family = 1, par = 0.5)

# computation of the gradient of the MMD criteria at different points
# Gradient is small at the true parameter
BiCopGradMMD(dataSampled[,1], dataSampled[,2], family = 1, par = 0.5)
# Gradient is negative when below the parameter
BiCopGradMMD(dataSampled[,1], dataSampled[,2], family = 1, par = 0.1)
# and positive when above
BiCopGradMMD(dataSampled[,1], dataSampled[,2], family = 1, par = 0.8)

</code></pre>

<hr>
<h2 id='BiCopPar2Tau.MO'>Convert between parameter and Kendall's tau for Marshall-Olkin copulas</h2><span id='topic+BiCopPar2Tau.MO'></span><span id='topic+BiCopTau2Par.MO'></span>

<h3>Description</h3>

<p>Convert between parameter and Kendall's tau for Marshall-Olkin copulas
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BiCopPar2Tau.MO(par)

BiCopTau2Par.MO(tau)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="BiCopPar2Tau.MO_+3A_par">par</code></td>
<td>
<p>the parameter of the Marshall-Olkin copula</p>
</td></tr>
<tr><td><code id="BiCopPar2Tau.MO_+3A_tau">tau</code></td>
<td>
<p>the Kendall's tau of the Marshall-Olkin copula</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Either the Kendall's tau or the parameter of the Marshall-Olkin copula.
</p>


<h3>References</h3>

<p>Nelsen, R. B. (2007). An introduction to copulas. Springer Science &amp; Business Media.
(Example 5.5)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>BiCopPar2Tau.MO(par = 0.5)
BiCopTau2Par.MO(tau = 1/3)

</code></pre>

<hr>
<h2 id='BiCopParamDistLp'>Compute the distance between 2 parametric copulas</h2><span id='topic+BiCopParamDistLp'></span>

<h3>Description</h3>

<p>This function uses the numerical integration procedure
<code>cubature::<a href="cubature.html#topic+hcubature">hcubature</a>()</code> to numerical integrate the distance between
the distribution or between the densities of two bivariate copulas.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BiCopParamDistLp(
  family,
  par,
  par_p,
  par2 = par,
  par2_p = par_p,
  family_p = family,
  p,
  type,
  maxEval = 0,
  truncVal = 0
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="BiCopParamDistLp_+3A_family">family</code></td>
<td>
<p>family of the first copula.</p>
</td></tr>
<tr><td><code id="BiCopParamDistLp_+3A_par">par</code></td>
<td>
<p>first parameter of the first copula.</p>
</td></tr>
<tr><td><code id="BiCopParamDistLp_+3A_par_p">par_p</code></td>
<td>
<p>first parameter of the second copula.</p>
</td></tr>
<tr><td><code id="BiCopParamDistLp_+3A_par2">par2</code></td>
<td>
<p>second parameter of the first copula
(only useful for two-parameter families of copulas).</p>
</td></tr>
<tr><td><code id="BiCopParamDistLp_+3A_par2_p">par2_p</code></td>
<td>
<p>second parameter of the first copula
(only useful for two-parameter families of copulas).</p>
</td></tr>
<tr><td><code id="BiCopParamDistLp_+3A_family_p">family_p</code></td>
<td>
<p>family of the second copula.</p>
</td></tr>
<tr><td><code id="BiCopParamDistLp_+3A_p">p</code></td>
<td>
<p>determines the <code class="reqn">L_p</code> distance that is used.</p>
</td></tr>
<tr><td><code id="BiCopParamDistLp_+3A_type">type</code></td>
<td>
<p>type of the functions considered.
Can be <code>"cdf"</code> for the distance between the two cumulative distribution functions
or <code>"pdf"</code> for the distance between the two probability density functions.</p>
</td></tr>
<tr><td><code id="BiCopParamDistLp_+3A_maxeval">maxEval</code></td>
<td>
<p>maximum number of evaluation of the function to be integrated.
If 0, then no maximum limit is given. (Only used if <code>p &lt; Inf</code>).</p>
</td></tr>
<tr><td><code id="BiCopParamDistLp_+3A_truncval">truncVal</code></td>
<td>
<p>the distance is computed using the supremum or the integral
of the function on <code class="reqn">[truncVal, 1 - truncVal]^2</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>p &lt; Inf</code>, it returns a list of four items
</p>

<ul>
<li> <p><code>distance</code> the value of the distance
</p>
</li>
<li> <p><code>integral</code> the value of the integral, which is
the <code class="reqn">p</code>-th power of the distance.
</p>
</li>
<li> <p><code>error</code> the estimated relative error of the integral
</p>
</li>
<li> <p><code>returnCode</code> the integer return code of the C routine
called by <code>cubature::<a href="cubature.html#topic+hcubature">hcubature</a>()</code>.
This should be 0 if there is no error.
</p>
</li></ul>

<p>If <code>p = Inf</code>, it returns a list of two items
</p>

<ul>
<li> <p><code>distance</code> the maximum difference between the two copulas
(respectively, between the two copula densities).
</p>
</li>
<li> <p><code>u_max</code> the point at which this difference is attained.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># Distance between the densities of a Gaussian copula with correlation 0.5
# and a Gaussian copula with correlation 0.2
BiCopParamDistLp(family = 1, par = 0.5, par_p = 0.2, p = 2, type = "cdf", maxEval = 10)
BiCopParamDistLp(family = 1, par = 0.5, par_p = 0.2, p = Inf, type = "cdf")

# Distance between the cdf of a Student copula
# with correlation 0.5 and 4 degrees of freedom
# and a Student copula with the same correlation but 20 degrees of freedom
BiCopParamDistLp(family = 2, par = 0.5, par_p = 0.5,
par2 = 5, par2_p = 20, p = 2, type = "pdf", maxEval = 10)

# Distance between the densities of a Gaussian copula with correlation 0.5
# and of a Student copula with correlation 0.5 and 15 degrees of freedom
BiCopParamDistLp(family = 1, par = 0.5, par_p = 0.5, par2_p = 15,
family_p = 2, p = 2, type = "pdf", maxEval = 10)

</code></pre>

<hr>
<h2 id='BiCopSim.MO'>Simulation of Marshall-Olkin copula</h2><span id='topic+BiCopSim.MO'></span>

<h3>Description</h3>

<p>This functions simulates independent realizations
from the Marshall-Olkin copula.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BiCopSim.MO(n, alpha)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="BiCopSim.MO_+3A_n">n</code></td>
<td>
<p>number of samples</p>
</td></tr>
<tr><td><code id="BiCopSim.MO_+3A_alpha">alpha</code></td>
<td>
<p>parameter of the Marshall-Olkin copula</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an <code class="reqn">n \times 2</code> matrix containing the samples
</p>


<h3>See Also</h3>

<p><code><a href="#topic+BiCopEst.MO">BiCopEst.MO</a></code> for the estimation of
Marshall-Olkin copulas.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Simulation from a Marshall-Olkin copula with parameter alpha = 0.5
BiCopSim.MO(n = 100, alpha = 0.5)


</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
