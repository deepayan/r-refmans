<!DOCTYPE html><html lang="en"><head><title>Help for package bspcov</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {bspcov}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#bandPPP'><p>Bayesian Estimation of a Banded Covariance Matrix</p></a></li>
<li><a href='#bmspcov'><p>Bayesian Sparse Covariance Estimation</p></a></li>
<li><a href='#colon'><p>colon dataset</p></a></li>
<li><a href='#cv.bandPPP'><p>CV for Bayesian Estimation of a Banded Covariance Matrix</p></a></li>
<li><a href='#cv.thresPPP'><p>CV for Bayesian Estimation of a Sparse Covariance Matrix</p></a></li>
<li><a href='#estimate'><p>Point-estimate of posterior distribution</p></a></li>
<li><a href='#plot.bspcov'><p>Plot Diagnostics of Posterior Samples and Cross-Validation</p></a></li>
<li><a href='#plot.postmean.bspcov'><p>Draw a Heat Map for Point Estimate of Covariance Matrix</p></a></li>
<li><a href='#sbmspcov'><p>Bayesian Sparse Covariance Estimation using Sure Screening</p></a></li>
<li><a href='#SP500_idioerr'><p>SP500 dataset</p></a></li>
<li><a href='#summary.bspcov'><p>Summary of Posterior Distribution</p></a></li>
<li><a href='#thresPPP'><p>Bayesian Estimation of a Sparse Covariance Matrix</p></a></li>
<li><a href='#tissues'><p>tissues dataset</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Bayesian Sparse Estimation of a Covariance Matrix</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-11-13</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5)</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides functions which perform Bayesian estimations of 
        a covariance matrix for multivariate normal data. Assumes that
        the covariance matrix is sparse or band matrix and positive-definite. 
        This software has been developed using funding supported by
        Basic Science Research Program through the National Research
        Foundation of Korea ('NRF') funded by the Ministry of Education
        ('RS-2023-00211979', 'NRF-2022R1A5A7033499', 'NRF-2020R1A4A1018207' 
        and 'NRF-2020R1C1C1A01013338').</td>
</tr>
<tr>
<td>Imports:</td>
<td>GIGrvg, coda, progress, BayesFactor, MASS, mvnfast,
matrixcalc, matrixStats, purrr, dplyr, RSpectra, Matrix, plyr,
CholWishart, magrittr, future, furrr, ks, ggplot2, ggmcmc,
caret, FinCovRegularization, mvtnorm</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/statjs/bspcov">https://github.com/statjs/bspcov</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-11-13 19:22:29 UTC; runner</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Author:</td>
<td>Kwangmin Lee [aut],
  Kyeongwon Lee [aut, cre],
  Kyoungjae Lee [aut],
  Seongil Jo [aut],
  Jaeyong Lee [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Kyeongwon Lee &lt;kwlee1718@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-11-13 20:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='bandPPP'>Bayesian Estimation of a Banded Covariance Matrix</h2><span id='topic+bandPPP'></span>

<h3>Description</h3>

<p>Provides a post-processed posterior for Bayesian inference of a banded covariance matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bandPPP(X, k, eps, prior = list(), nsample = 2000)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bandPPP_+3A_x">X</code></td>
<td>
<p>a n <code class="reqn">\times</code> p data matrix with column mean zero.</p>
</td></tr>
<tr><td><code id="bandPPP_+3A_k">k</code></td>
<td>
<p>a scalar value (natural number) specifying the bandwidth of covariance matrix.</p>
</td></tr>
<tr><td><code id="bandPPP_+3A_eps">eps</code></td>
<td>
<p>a small positive number decreasing to <code class="reqn">0</code> with default value <code class="reqn">(log(k))^2 * (k + log(p))/n</code>.</p>
</td></tr>
<tr><td><code id="bandPPP_+3A_prior">prior</code></td>
<td>
<p>a list giving the prior information.
The list includes the following parameters (with default values in parentheses):
<code>A (I)</code> giving the positive definite scale matrix for the inverse-Wishart prior,
<code>nu (p + k)</code> giving the degree of freedom of the inverse-Wishar prior.</p>
</td></tr>
<tr><td><code id="bandPPP_+3A_nsample">nsample</code></td>
<td>
<p>a scalar value giving the number of the post-processed posterior samples.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Lee, Lee, and Lee (2023+) proposed a two-step procedure generating samples from the post-processed posterior for Bayesian inference of a banded covariance matrix:
</p>

<ul>
<li><p> Initial posterior computing step: Generate random samples from the following initial posterior obtained by using the inverse-Wishart prior <code class="reqn">IW_p(B_0, \nu_0)</code>
</p>
<p style="text-align: center;"><code class="reqn">
 \Sigma \mid X_1, \ldots, X_n \sim IW_p(B_0 + nS_n, \nu_0 + n),
 </code>
</p>

<p>where <code class="reqn">S_n = n^{-1}\sum_{i=1}^{n}X_iX_i^\top</code>.
</p>
</li>
<li><p> Post-processing step: Post-process the samples generated from the initial samples
</p>
<p style="text-align: center;"><code class="reqn">
 \Sigma_{(i)} := \left\{\begin{array}{ll}B_{k}(\Sigma^{(i)}) + \left[\epsilon_n - \lambda_{\min}\{B_{k}(\Sigma^{(i)})\}\right]I_p, &amp;
 \mbox{ if } \lambda_{\min}\{B_{k}(\Sigma^{(i)})\} &lt; \epsilon_n, \\
 B_{k}(\Sigma^{(i)}), &amp; \mbox{ otherwise },
 \end{array}\right.
 </code>
</p>

</li></ul>

<p>where <code class="reqn">\Sigma^{(1)}, \ldots, \Sigma^{(N)}</code> are the initial posterior samples,
<code class="reqn">\epsilon_n</code> is a small positive number decreasing to <code class="reqn">0</code> as <code class="reqn">n \rightarrow \infty</code>,
and <code class="reqn">B_k(B)</code> denotes the <code class="reqn">k</code>-band operation given as
</p>
<p style="text-align: center;"><code class="reqn">
B_{k}(B) = \{b_{ij}I(|i - j| \le k)\} \mbox{ for any } B = (b_{ij}) \in R^{p \times p}.
</code>
</p>

<p>For more details, see Lee, Lee and Lee (2023+).
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>Sigma</code></td>
<td>
<p>a nsample <code class="reqn">\times</code> p(p+1)/2 matrix including lower triangular elements of covariance matrix.</p>
</td></tr>
<tr><td><code>p</code></td>
<td>
<p>dimension of covariance matrix.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Kwangmin Lee
</p>


<h3>References</h3>

<p>Lee, K., Lee, K., and Lee, J. (2023+), &quot;Post-processes posteriors for banded covariances&quot;,
<em>Bayesian Analysis</em>, DOI: 10.1214/22-BA1333.
</p>


<h3>See Also</h3>

<p>cv.bandPPP estimate
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
n &lt;- 25
p &lt;- 50
Sigma0 &lt;- diag(1, p)
X &lt;- MASS::mvrnorm(n = n, mu = rep(0, p), Sigma = Sigma0)
res &lt;- bspcov::bandPPP(X,2,0.01,nsample=100)

</code></pre>

<hr>
<h2 id='bmspcov'>Bayesian Sparse Covariance Estimation</h2><span id='topic+bmspcov'></span>

<h3>Description</h3>

<p>Provides a Bayesian sparse and positive definite estimate of a covariance matrix via the beta-mixture shrinkage prior.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bmspcov(X, Sigma, prior = list(), nsample = list())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bmspcov_+3A_x">X</code></td>
<td>
<p>a n <code class="reqn">\times</code> p data matrix with column mean zero.</p>
</td></tr>
<tr><td><code id="bmspcov_+3A_sigma">Sigma</code></td>
<td>
<p>an initial guess for Sigma.</p>
</td></tr>
<tr><td><code id="bmspcov_+3A_prior">prior</code></td>
<td>
<p>a list giving the prior information.
The list includes the following parameters (with default values in parentheses):
<code>a (1/2)</code> and <code>b (1/2)</code> giving the shape parameters for beta distribution,
<code>lambda (1)</code> giving the hyperparameter for the diagonal elements,
<code>tau1sq (10000/(n*p^4))</code> giving the hyperparameter for the shrinkage prior of covariance.</p>
</td></tr>
<tr><td><code id="bmspcov_+3A_nsample">nsample</code></td>
<td>
<p>a list giving the MCMC parameters.
The list includes the following integers (with default values in parentheses):
<code>burnin (1000)</code> giving the number of MCMC samples in transition period,
<code>nmc (1000)</code> giving the number of MCMC samples for analysis.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Lee, Jo and Lee (2022) proposed the beta-mixture shrinkage prior for estimating a sparse and positive definite covariance matrix.
The beta-mixture shrinkage prior for <code class="reqn">\Sigma = (\sigma_{jk})</code> is defined as
</p>
<p style="text-align: center;"><code class="reqn">
 \pi(\Sigma) = \frac{\pi^{u}(\Sigma)I(\Sigma \in C_p)}{\pi^{u}(\Sigma \in C_p)}, ~ C_p = \{\mbox{ all } p \times p \mbox{ positive definite matrices }\},
</code>
</p>

<p>where <code class="reqn">\pi^{u}(\cdot)</code> is the unconstrained prior given by
</p>
<p style="text-align: center;"><code class="reqn">
\pi^{u}(\sigma_{jk} \mid \rho_{jk}) = N\left(\sigma_{jk} \mid 0, \frac{\rho_{jk}}{1 - \rho_{jk}}\tau_1^2\right)</code>
</p>

<p style="text-align: center;"><code class="reqn">
\pi^{u}(\rho_{jk}) = Beta(\rho_{jk} \mid a, b), ~ \rho_{jk} = 1 - 1/(1 + \phi_{jk})</code>
</p>

<p style="text-align: center;"><code class="reqn">
\pi^{u}(\sigma_{jj}) = Exp(\sigma_{jj} \mid \lambda).
</code>
</p>

<p>For more details, see Lee, Jo and Lee (2022).
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>Sigma</code></td>
<td>
<p>a nmc <code class="reqn">\times</code> p(p+1)/2 matrix including lower triangular elements of covariance matrix.</p>
</td></tr>
<tr><td><code>Phi</code></td>
<td>
<p>a nmc <code class="reqn">\times</code> p(p+1)/2 matrix including shrinkage parameters corresponding to lower triangular elements of covariance matrix.</p>
</td></tr>
<tr><td><code>p</code></td>
<td>
<p>dimension of covariance matrix.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Kyoungjae Lee and Seongil Jo
</p>


<h3>References</h3>

<p>Lee, K., Jo, S., and Lee, J. (2022), &quot;The beta-mixture shrinkage prior for sparse covariances with near-minimax posterior convergence rate&quot;,
<em>Journal of Multivariate Analysis</em>, 192, 105067.
</p>


<h3>See Also</h3>

<p>sbmspcov
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(1)
n &lt;- 20
p &lt;- 5

# generate a sparse covariance matrix:
True.Sigma &lt;- matrix(0, nrow = p, ncol = p)
diag(True.Sigma) &lt;- 1
Values &lt;- -runif(n = p*(p-1)/2, min = 0.2, max = 0.8)
nonzeroIND &lt;- which(rbinom(n=p*(p-1)/2,1,prob=1/p)==1)
zeroIND = (1:(p*(p-1)/2))[-nonzeroIND]
Values[zeroIND] &lt;- 0
True.Sigma[lower.tri(True.Sigma)] &lt;- Values
True.Sigma[upper.tri(True.Sigma)] &lt;- t(True.Sigma)[upper.tri(True.Sigma)]
if(min(eigen(True.Sigma)$values) &lt;= 0){
  delta &lt;- -min(eigen(True.Sigma)$values) + 1.0e-5
  True.Sigma &lt;- True.Sigma + delta*diag(p)
}

# generate a data
X &lt;- MASS::mvrnorm(n = n, mu = rep(0, p), Sigma = True.Sigma)

# compute sparse, positive covariance estimator:
fout &lt;- bspcov::bmspcov(X = X, Sigma = diag(diag(cov(X))))
post.est.m &lt;- bspcov::estimate(fout)
sqrt(mean((post.est.m - True.Sigma)^2))
sqrt(mean((cov(X) - True.Sigma)^2))

</code></pre>

<hr>
<h2 id='colon'>colon dataset</h2><span id='topic+colon'></span>

<h3>Description</h3>

<p>The colon cancer dataset, which includes gene expression values from 22 colon tumor tissues and 40 non-tumor tissues.
</p>


<h3>Format</h3>

<p>'data.frame'
</p>


<h3>Source</h3>

<p>http://genomics-pubs.princeton.edu/oncology/affydata/.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data("colon")
head(colon)

</code></pre>

<hr>
<h2 id='cv.bandPPP'>CV for Bayesian Estimation of a Banded Covariance Matrix</h2><span id='topic+cv.bandPPP'></span>

<h3>Description</h3>

<p>Performs leave-one-out cross-validation (LOOCV) to calculate the predictive log-likelihood for a post-processed posterior of a banded covariance matrix and selects the optimal parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cv.bandPPP(X, kvec, epsvec, prior = list(), nsample = 2000, ncores = 2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cv.bandPPP_+3A_x">X</code></td>
<td>
<p>a n <code class="reqn">\times</code> p data matrix with column mean zero.</p>
</td></tr>
<tr><td><code id="cv.bandPPP_+3A_kvec">kvec</code></td>
<td>
<p>a vector of natural numbers specifying the bandwidth of covariance matrix.</p>
</td></tr>
<tr><td><code id="cv.bandPPP_+3A_epsvec">epsvec</code></td>
<td>
<p>a vector of small positive numbers decreasing to <code class="reqn">0</code>.</p>
</td></tr>
<tr><td><code id="cv.bandPPP_+3A_prior">prior</code></td>
<td>
<p>a list giving the prior information.
The list includes the following parameters (with default values in parentheses):
<code>A (I)</code> giving the positive definite scale matrix for the inverse-Wishart prior,
<code>nu (p + k)</code> giving the degree of freedom of the inverse-Wishar prior.</p>
</td></tr>
<tr><td><code id="cv.bandPPP_+3A_nsample">nsample</code></td>
<td>
<p>a scalar value giving the number of the post-processed posterior samples.</p>
</td></tr>
<tr><td><code id="cv.bandPPP_+3A_ncores">ncores</code></td>
<td>
<p>a scalar value giving the number of CPU cores.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The predictive log-likelihood for each <code class="reqn">k</code> and <code class="reqn">\epsilon_n</code> is estimated as follows:
</p>
<p style="text-align: center;"><code class="reqn">
 \sum_{i=1}^n \log S^{-1} \sum_{s=1}^S p(X_i \mid B_k^{(\epsilon_n)}(\Sigma_{i,s})),
 </code>
</p>

<p>where <code class="reqn">X_i</code> is the ith observation, <code class="reqn">\Sigma_{i,s}</code> is the sth posterior sample based on <code class="reqn">(X_1,\ldots,X_{i-1},X_{i+1},\ldots,X_n)</code>, and <code class="reqn">B_k^{(\epsilon_n)}</code> represents the banding post-processing function.
For more details, see (3) in Lee, Lee and Lee (2023+).
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>elpd</code></td>
<td>
<p>a M <code class="reqn">\times</code> 3 dataframe having the expected log predictive density (ELPD) for each k and eps, where M = length(kvec) * length(epsvec).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Kwangmin Lee
</p>


<h3>References</h3>

<p>Lee, K., Lee, K., and Lee, J. (2023+), &quot;Post-processes posteriors for banded covariances&quot;,
<em>Bayesian Analysis</em>, DOI: 10.1214/22-BA1333.
</p>
<p>Gelman, A., Hwang, J., and Vehtari, A. (2014). &quot;Understanding predictive information criteria for Bayesian models.&quot; <em>Statistics and computing</em>,
24(6), 997-1016.
</p>


<h3>See Also</h3>

<p>bandPPP
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

Sigma0 &lt;- diag(1,50)
X &lt;- mvtnorm::rmvnorm(25,sigma = Sigma0)
kvec &lt;- 1:2
epsvec &lt;- c(0.01,0.05)
res &lt;- bspcov::cv.bandPPP(X,kvec,epsvec,nsample=10,ncores=4)
plot(res)


</code></pre>

<hr>
<h2 id='cv.thresPPP'>CV for Bayesian Estimation of a Sparse Covariance Matrix</h2><span id='topic+cv.thresPPP'></span>

<h3>Description</h3>

<p>Performs cross-validation to estimate spectral norm error for a post-processed posterior of a sparse covariance matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cv.thresPPP(
  X,
  thresvec,
  epsvec,
  prior = NULL,
  thresfun = "hard",
  nsample = 2000,
  ncores = 2
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cv.thresPPP_+3A_x">X</code></td>
<td>
<p>a n <code class="reqn">\times</code> p data matrix with column mean zero.</p>
</td></tr>
<tr><td><code id="cv.thresPPP_+3A_thresvec">thresvec</code></td>
<td>
<p>a vector of real numbers specifying the parameter of the threshold function.</p>
</td></tr>
<tr><td><code id="cv.thresPPP_+3A_epsvec">epsvec</code></td>
<td>
<p>a vector of small positive numbers decreasing to <code class="reqn">0</code>.</p>
</td></tr>
<tr><td><code id="cv.thresPPP_+3A_prior">prior</code></td>
<td>
<p>a list giving the prior information.
The list includes the following parameters (with default values in parentheses):
<code>A (I)</code> giving the positive definite scale matrix for the inverse-Wishart prior,
<code>nu (p + k)</code> giving the degree of freedom of the inverse-Wishar prior.</p>
</td></tr>
<tr><td><code id="cv.thresPPP_+3A_thresfun">thresfun</code></td>
<td>
<p>a string to specify the type of threshold function. <code>fun ('hard')</code> giving the thresholding function ('hard' or 'soft') for the thresholding PPP procedure.</p>
</td></tr>
<tr><td><code id="cv.thresPPP_+3A_nsample">nsample</code></td>
<td>
<p>a scalar value giving the number of the post-processed posterior samples.</p>
</td></tr>
<tr><td><code id="cv.thresPPP_+3A_ncores">ncores</code></td>
<td>
<p>a scalar value giving the number of CPU cores.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given a set of train data and validation data, the spectral norm error for each <code class="reqn">\gamma</code> and <code class="reqn">\epsilon_n</code> is estimated as follows:
</p>
<p style="text-align: center;"><code class="reqn">
 ||\hat{\Sigma}(\gamma,\epsilon_n)^{(train)} - S^{(val)}||_2
 </code>
</p>

<p>where <code class="reqn">\hat{\Sigma}(\gamma,\epsilon_n)^{(train)}</code> is the estimate for the covariance based on the train data and <code class="reqn">S^{(val)}</code> is the sample covariance matrix based on the validation data.
The spectral norm error is estimated by the <code class="reqn">10</code>-fold cross-validation.
For more details, see the first paragraph on page 9 in Lee and Lee (2023).
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>CVdf</code></td>
<td>
<p>a M <code class="reqn">\times</code> 3 dataframe having the estimated spectral norm error for each thres and eps, where M = length(thresvec) * length(epsvec)</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Kwangmin Lee
</p>


<h3>References</h3>

<p>Lee, K. and Lee, J. (2023), &quot;Post-processes posteriors for sparse covariances&quot;, <em>Journal of Econometrics</em>, 236(3), 105475.
</p>


<h3>See Also</h3>

<p>thresPPP
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

Sigma0 &lt;- diag(1,50)
X &lt;- mvtnorm::rmvnorm(25,sigma = Sigma0)
thresvec &lt;- c(0.01,0.1)
epsvec &lt;- c(0.01,0.1)
res &lt;- bspcov::cv.thresPPP(X,thresvec,epsvec,nsample=100)
plot(res)


</code></pre>

<hr>
<h2 id='estimate'>Point-estimate of posterior distribution</h2><span id='topic+estimate'></span><span id='topic+estimate.bspcov'></span>

<h3>Description</h3>

<p>Compute the point estimate (mean) to describe posterior distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimate(object, ...)

## S3 method for class 'bspcov'
estimate(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="estimate_+3A_object">object</code></td>
<td>
<p>an object from <strong>bandPPP</strong>, <strong>bmspcov</strong>, <strong>sbmspcov</strong>, and <strong>thresPPP</strong>.</p>
</td></tr>
<tr><td><code id="estimate_+3A_...">...</code></td>
<td>
<p>additional arguments for estimate.</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>Sigma</code></td>
<td>
<p>the point estimate (mean) of covariance matrix.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Seongil Jo
</p>


<h3>See Also</h3>

<p>plot.postmean.bspcov
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
n &lt;- 25
p &lt;- 50
Sigma0 &lt;- diag(1, p)
X &lt;- MASS::mvrnorm(n = n, mu = rep(0, p), Sigma = Sigma0)
res &lt;- bspcov::bandPPP(X,2,0.01,nsample=100)
est &lt;- bspcov::estimate(res)

</code></pre>

<hr>
<h2 id='plot.bspcov'>Plot Diagnostics of Posterior Samples and Cross-Validation</h2><span id='topic+plot.bspcov'></span>

<h3>Description</h3>

<p>Provides a trace plot of posterior samples and a plot of a learning curve for cross-validation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bspcov'
plot(x, ..., cols, rows)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.bspcov_+3A_x">x</code></td>
<td>
<p>an object from <strong>bmspcov</strong>, <strong>sbmspcov</strong>, <strong>cv.bandPPP</strong>, and <strong>cv.thresPPP</strong>.</p>
</td></tr>
<tr><td><code id="plot.bspcov_+3A_...">...</code></td>
<td>
<p>additional arguments for ggplot2.</p>
</td></tr>
<tr><td><code id="plot.bspcov_+3A_cols">cols</code></td>
<td>
<p>a scalar or a vector including specific column indices for the trace plot.</p>
</td></tr>
<tr><td><code id="plot.bspcov_+3A_rows">rows</code></td>
<td>
<p>a scalar or a vector including specific row indices greater than or equal to columns indices for the trace plot.</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>plot</code></td>
<td>
<p>a plot for diagnostics of posterior samples <strong>x</strong>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Seongil Jo
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

set.seed(1)
n &lt;- 100
p &lt;- 20

# generate a sparse covariance matrix:
True.Sigma &lt;- matrix(0, nrow = p, ncol = p)
diag(True.Sigma) &lt;- 1
Values &lt;- -runif(n = p*(p-1)/2, min = 0.2, max = 0.8)
nonzeroIND &lt;- which(rbinom(n=p*(p-1)/2,1,prob=1/p)==1)
zeroIND = (1:(p*(p-1)/2))[-nonzeroIND]
Values[zeroIND] &lt;- 0
True.Sigma[lower.tri(True.Sigma)] &lt;- Values
True.Sigma[upper.tri(True.Sigma)] &lt;- t(True.Sigma)[upper.tri(True.Sigma)]
if(min(eigen(True.Sigma)$values) &lt;= 0){
  delta &lt;- -min(eigen(True.Sigma)$values) + 1.0e-5
  True.Sigma &lt;- True.Sigma + delta*diag(p)
}

# generate a data
X &lt;- MASS::mvrnorm(n = n, mu = rep(0, p), Sigma = True.Sigma)

# compute sparse, positive covariance estimator:
fout &lt;- bspcov::sbmspcov(X = X, Sigma = diag(diag(cov(X))))
plot(fout, cols = c(1, 3, 4), rows = c(1, 3, 4))
plot(fout, cols = 1, rows = 1:3)

# Cross-Validation for Banded Structure
Sigma0 &lt;- diag(1,50)
X &lt;- mvtnorm::rmvnorm(25,sigma = Sigma0)
kvec &lt;- 1:2
epsvec &lt;- c(0.01,0.05)
res &lt;- bspcov::cv.bandPPP(X,kvec,epsvec,nsample=10,ncores=4)
plot(res)


</code></pre>

<hr>
<h2 id='plot.postmean.bspcov'>Draw a Heat Map for Point Estimate of Covariance Matrix</h2><span id='topic+plot.postmean.bspcov'></span>

<h3>Description</h3>

<p>Provides a heat map for posterior mean estimate of sparse covariance matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'postmean.bspcov'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.postmean.bspcov_+3A_x">x</code></td>
<td>
<p>an object from <strong>estimate</strong>.</p>
</td></tr>
<tr><td><code id="plot.postmean.bspcov_+3A_...">...</code></td>
<td>
<p>additional arguments for ggplot2.</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>plot</code></td>
<td>
<p>a heatmap for point estimate of covariance matrix <strong>x</strong>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Seongil Jo
</p>


<h3>See Also</h3>

<p>estimate
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
n &lt;- 25
p &lt;- 50
Sigma0 &lt;- diag(1, p)
X &lt;- MASS::mvrnorm(n = n, mu = rep(0, p), Sigma = Sigma0)
res &lt;- bspcov::thresPPP(X, eps=0.01, thres=list(value=0.5,fun='hard'), nsample=100)
est &lt;- bspcov::estimate(res)
plot(est)

</code></pre>

<hr>
<h2 id='sbmspcov'>Bayesian Sparse Covariance Estimation using Sure Screening</h2><span id='topic+sbmspcov'></span>

<h3>Description</h3>

<p>Provides a Bayesian sparse and positive definite estimate of a covariance matrix via screened beta-mixture prior.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sbmspcov(X, Sigma, cutoff = list(), prior = list(), nsample = list())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sbmspcov_+3A_x">X</code></td>
<td>
<p>a n <code class="reqn">\times</code> p data matrix with column mean zero.</p>
</td></tr>
<tr><td><code id="sbmspcov_+3A_sigma">Sigma</code></td>
<td>
<p>an initial guess for Sigma.</p>
</td></tr>
<tr><td><code id="sbmspcov_+3A_cutoff">cutoff</code></td>
<td>
<p>a list giving the information for the threshold.
The list includes the following parameters (with default values in parentheses):
<code>method ('FNR')</code> giving the method for determining the threshold value
(method='FNR' uses the false negative rate (FNR)-based approach, method='corr' chooses the threshold value by sample correlations),
<code>rho</code> a lower bound of meaningfully large correlations whose the defaults values are 0.25 and 0.2 for method = 'FNR' and method = 'corr', respectively.
Note. If method='corr', <code>rho</code> is used as the threshold value.
<code>FNR (0.05)</code> giving the prespecified FNR level when method = 'FNR'.
<code>nsimdata (1000)</code> giving the number of simulated datasets for calculating Jeffreys’ default Bayes factors when method = 'FNR'.</p>
</td></tr>
<tr><td><code id="sbmspcov_+3A_prior">prior</code></td>
<td>
<p>a list giving the prior information.
The list includes the following parameters (with default values in parentheses):
<code>a (1/2)</code> and <code>b (1/2)</code> giving the shape parameters for beta distribution,
<code>lambda (1)</code> giving the hyperparameter for the diagonal elements,
<code>tau1sq (log(p)/(p^2*n))</code> giving the hyperparameter for the shrinkage prior of covariance.</p>
</td></tr>
<tr><td><code id="sbmspcov_+3A_nsample">nsample</code></td>
<td>
<p>a list giving the MCMC parameters.
The list includes the following integers (with default values in parentheses):
<code>burnin (1000)</code> giving the number of MCMC samples in transition period,
<code>nmc (1000)</code> giving the number of MCMC samples for analysis.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Lee, Jo, Lee, and Lee (2023+) proposed the screened beta-mixture shrinkage prior for estimating a sparse and positive definite covariance matrix.
The screened beta-mixture shrinkage prior for <code class="reqn">\Sigma = (\sigma_{jk})</code> is defined as
</p>
<p style="text-align: center;"><code class="reqn">
 \pi(\Sigma) = \frac{\pi^{u}(\Sigma)I(\Sigma \in C_p)}{\pi^{u}(\Sigma \in C_p)}, ~ C_p = \{\mbox{ all } p \times p \mbox{ positive definite matrices }\},
</code>
</p>

<p>where <code class="reqn">\pi^{u}(\cdot)</code> is the unconstrained prior given by
</p>
<p style="text-align: center;"><code class="reqn">
\pi^{u}(\sigma_{jk} \mid \psi_{jk}) = N\left(\sigma_{jk} \mid 0, \frac{\psi_{jk}}{1 - \psi_{jk}}\tau_1^2\right), ~ \psi_{jk} = 1 - 1/(1 + \phi_{jk})</code>
</p>

<p style="text-align: center;"><code class="reqn">
\pi^{u}(\psi_{jk}) = Beta(\psi_{jk} \mid a, b) ~ \mbox{for } (j, k) \in S_r(\hat{R})</code>
</p>

<p style="text-align: center;"><code class="reqn">
\pi^{u}(\sigma_{jj}) = Exp(\sigma_{jj} \mid \lambda),
</code>
</p>

<p>where <code class="reqn">S_r(\hat{R}) = \{(j,k) : 1 &lt; j &lt; k \le p, |\hat{\rho}_{jk}| &gt; r\}</code>, <code class="reqn">\hat{\rho}_{jk}</code> are sample correlations, and <code class="reqn">r</code> is a threshold given by user.
</p>
<p>For more details, see Lee, Jo, Lee and Lee (2022+).
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>Sigma</code></td>
<td>
<p>a nmc <code class="reqn">\times</code> p(p+1)/2 matrix including lower triangular elements of covariance matrix.</p>
</td></tr>
<tr><td><code>p</code></td>
<td>
<p>dimension of covariance matrix.</p>
</td></tr>
<tr><td><code>Phi</code></td>
<td>
<p>a nmc <code class="reqn">\times</code> p(p+1)/2 matrix including shrinkage parameters corresponding to lower triangular elements of covariance matrix.</p>
</td></tr>
<tr><td><code>INDzero</code></td>
<td>
<p>a list including indices of off-diagonal elements screened by sure screening.</p>
</td></tr>
<tr><td><code>cutoff</code></td>
<td>
<p>the cutoff value specified by FNR-approach.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Kyoungjae Lee and Seongil Jo
</p>


<h3>References</h3>

<p>Lee, K., Jo, S., Lee, K., and Lee, J. (2023+), &quot;Scalable and optimal Bayesian inference for sparse covariance matrices via screened beta-mixture prior&quot;,
arXiv:2206.12773.
</p>


<h3>See Also</h3>

<p>bmspcov
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(1)
n &lt;- 20
p &lt;- 5

# generate a sparse covariance matrix:
True.Sigma &lt;- matrix(0, nrow = p, ncol = p)
diag(True.Sigma) &lt;- 1
Values &lt;- -runif(n = p*(p-1)/2, min = 0.2, max = 0.8)
nonzeroIND &lt;- which(rbinom(n=p*(p-1)/2,1,prob=1/p)==1)
zeroIND = (1:(p*(p-1)/2))[-nonzeroIND]
Values[zeroIND] &lt;- 0
True.Sigma[lower.tri(True.Sigma)] &lt;- Values
True.Sigma[upper.tri(True.Sigma)] &lt;- t(True.Sigma)[upper.tri(True.Sigma)]
if(min(eigen(True.Sigma)$values) &lt;= 0){
  delta &lt;- -min(eigen(True.Sigma)$values) + 1.0e-5
  True.Sigma &lt;- True.Sigma + delta*diag(p)
}

# generate a data
X &lt;- MASS::mvrnorm(n = n, mu = rep(0, p), Sigma = True.Sigma)

# compute sparse, positive covariance estimator:
fout &lt;- bspcov::sbmspcov(X = X, Sigma = diag(diag(cov(X))))
post.est.m &lt;- bspcov::estimate(fout)
sqrt(mean((post.est.m - True.Sigma)^2))
sqrt(mean((cov(X) - True.Sigma)^2))

</code></pre>

<hr>
<h2 id='SP500_idioerr'>SP500 dataset</h2><span id='topic+SP500_idioerr'></span>

<h3>Description</h3>

<p>The idiosyncratic error of S&amp;P 500 data
</p>


<h3>Format</h3>

<p>'list'
</p>


<h3>Source</h3>

<p>State Street Global Advisors (2022).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data("SP500_idioerr")
names(SP500_idioerr)

</code></pre>

<hr>
<h2 id='summary.bspcov'>Summary of Posterior Distribution</h2><span id='topic+summary.bspcov'></span>

<h3>Description</h3>

<p>Provides the summary statistics for posterior samples of covariance matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bspcov'
summary(object, cols, rows, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.bspcov_+3A_object">object</code></td>
<td>
<p>an object from <strong>bandPPP</strong>, <strong>bmspcov</strong>, <strong>sbmspcov</strong>, and <strong>thresPPP</strong>.</p>
</td></tr>
<tr><td><code id="summary.bspcov_+3A_cols">cols</code></td>
<td>
<p>a scalar or a vector including specific column indices.</p>
</td></tr>
<tr><td><code id="summary.bspcov_+3A_rows">rows</code></td>
<td>
<p>a scalar or a vector including specific row indices greater than or equal to columns indices.</p>
</td></tr>
<tr><td><code id="summary.bspcov_+3A_...">...</code></td>
<td>
<p>additional arguments for the summary function.</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>summary</code></td>
<td>
<p>a table of summary statistics including empirical mean, standard deviation, and quantiles for posterior samples</p>
</td></tr>
</table>


<h3>Note</h3>

<p>If both <code>cols</code> and <code>rows</code> are vectors, they must have the same length.
</p>


<h3>Author(s)</h3>

<p>Seongil Jo
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(1)
n &lt;- 20
p &lt;- 5

# generate a sparse covariance matrix:
True.Sigma &lt;- matrix(0, nrow = p, ncol = p)
diag(True.Sigma) &lt;- 1
Values &lt;- -runif(n = p*(p-1)/2, min = 0.2, max = 0.8)
nonzeroIND &lt;- which(rbinom(n=p*(p-1)/2,1,prob=1/p)==1)
zeroIND = (1:(p*(p-1)/2))[-nonzeroIND]
Values[zeroIND] &lt;- 0
True.Sigma[lower.tri(True.Sigma)] &lt;- Values
True.Sigma[upper.tri(True.Sigma)] &lt;- t(True.Sigma)[upper.tri(True.Sigma)]
if(min(eigen(True.Sigma)$values) &lt;= 0){
  delta &lt;- -min(eigen(True.Sigma)$values) + 1.0e-5
  True.Sigma &lt;- True.Sigma + delta*diag(p)
}

# generate a data
X &lt;- MASS::mvrnorm(n = n, mu = rep(0, p), Sigma = True.Sigma)

# compute sparse, positive covariance estimator:
fout &lt;- bspcov::sbmspcov(X = X, Sigma = diag(diag(cov(X))))
summary(fout, cols = c(1, 3, 4), rows = c(1, 3, 4))
summary(fout, cols = 1, rows = 1:p)

</code></pre>

<hr>
<h2 id='thresPPP'>Bayesian Estimation of a Sparse Covariance Matrix</h2><span id='topic+thresPPP'></span>

<h3>Description</h3>

<p>Provides a post-processed posterior (PPP) for Bayesian inference of a sparse covariance matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>thresPPP(X, eps, thres = list(), prior = list(), nsample = 2000)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="thresPPP_+3A_x">X</code></td>
<td>
<p>a n <code class="reqn">\times</code> p data matrix with column mean zero.</p>
</td></tr>
<tr><td><code id="thresPPP_+3A_eps">eps</code></td>
<td>
<p>a small positive number decreasing to <code class="reqn">0</code>.</p>
</td></tr>
<tr><td><code id="thresPPP_+3A_thres">thres</code></td>
<td>
<p>a list giving the information for thresholding PPP procedure.
The list includes the following parameters (with default values in parentheses):
<code>value (0.1)</code> giving the positive real number for the thresholding PPP procedure,
<code>fun ('hard')</code> giving the thresholding function ('hard' or 'soft') for the thresholding PPP procedure.</p>
</td></tr>
<tr><td><code id="thresPPP_+3A_prior">prior</code></td>
<td>
<p>a list giving the prior information.
The list includes the following parameters (with default values in parentheses):
<code>A (I)</code> giving the positive definite scale matrix for the inverse-Wishart prior,
<code>nu (p + 1)</code> giving the degree of freedom of the inverse-Wishar prior.</p>
</td></tr>
<tr><td><code id="thresPPP_+3A_nsample">nsample</code></td>
<td>
<p>a scalar value giving the number of the post-processed posterior samples.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Lee and Lee (2023) proposed a two-step procedure generating samples from the post-processed posterior for Bayesian inference of a sparse covariance matrix:
</p>

<ul>
<li><p> Initial posterior computing step: Generate random samples from the following initial posterior obtained by using the inverse-Wishart prior <code class="reqn">IW_p(B_0, \nu_0)</code>
</p>
<p style="text-align: center;"><code class="reqn">
 \Sigma \mid X_1, \ldots, X_n \sim IW_p(B_0 + nS_n, \nu_0 + n),
 </code>
</p>

<p>where <code class="reqn">S_n = n^{-1}\sum_{i=1}^{n}X_iX_i^\top</code>.
</p>
</li>
<li><p> Post-processing step: Post-process the samples generated from the initial samples
</p>
<p style="text-align: center;"><code class="reqn">
 \Sigma_{(i)} := \left\{\begin{array}{ll}H_{\gamma_n}(\Sigma^{(i)}) + \left[\epsilon_n - \lambda_{\min}\{H_{\gamma_n}(\Sigma^{(i)})\}\right]I_p, &amp;
 \mbox{ if } \lambda_{\min}\{H_{\gamma_n}(\Sigma^{(i)})\} &lt; \epsilon_n, \\
 H_{\gamma_n}(\Sigma^{(i)}), &amp; \mbox{ otherwise },
 \end{array}\right.
 </code>
</p>

</li></ul>

<p>where <code class="reqn">\Sigma^{(1)}, \ldots, \Sigma^{(N)}</code> are the initial posterior samples,
<code class="reqn">\epsilon_n</code> is a positive real number, and <code class="reqn">H_{\gamma_n}(\Sigma)</code> denotes the generalized threshodling operator given as
</p>
<p style="text-align: center;"><code class="reqn">
(H_{\gamma_n}(\Sigma))_{ij} = \left\{\begin{array}{ll}\sigma_{ij}, &amp; \mbox{ if } i = j, \\
h_{\gamma_n}(\sigma_{ij}), &amp; \mbox{ if } i \neq j, \end{array}\right.
</code>
</p>

<p>where <code class="reqn">\sigma_{ij}</code> is the <code class="reqn">(i,j)</code> element of <code class="reqn">\Sigma</code> and <code class="reqn">h_{\gamma_n}(\cdot)</code> is a generalized thresholding function.
</p>
<p>For more details, see Lee and Lee (2023).
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>Sigma</code></td>
<td>
<p>a nsample <code class="reqn">\times</code> p(p+1)/2 matrix including lower triangular elements of covariance matrix.</p>
</td></tr>
<tr><td><code>p</code></td>
<td>
<p>dimension of covariance matrix.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Kwangmin Lee
</p>


<h3>References</h3>

<p>Lee, K. and Lee, J. (2023), &quot;Post-processes posteriors for sparse covariances&quot;, <em>Journal of Econometrics</em>.
</p>


<h3>See Also</h3>

<p>cv.thresPPP
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
n &lt;- 25
p &lt;- 50
Sigma0 &lt;- diag(1, p)
X &lt;- MASS::mvrnorm(n = n, mu = rep(0, p), Sigma = Sigma0)
res &lt;- bspcov::thresPPP(X, eps=0.01, thres=list(value=0.5,fun='hard'), nsample=100)
est &lt;- bspcov::estimate(res)

</code></pre>

<hr>
<h2 id='tissues'>tissues dataset</h2><span id='topic+tissues'></span>

<h3>Description</h3>

<p>The tissues data of colon cancer dataset,
which includes gene expression values from 22 colon tumor tissues and 40 non-tumor tissues.
</p>


<h3>Format</h3>

<p>'numeric'
</p>


<h3>Source</h3>

<p>http://genomics-pubs.princeton.edu/oncology/affydata/.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

data("tissues")
head(tissues)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
