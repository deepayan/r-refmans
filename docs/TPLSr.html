<!DOCTYPE html><html><head><title>Help for package TPLSr</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {TPLSr}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#evalTuningParam'><p>Evaluating cross-validation performance of a TPLS_cv model at compvec and threshvec</p></a></li>
<li><a href='#makePredictor'><p>Method for extracting the T-PLS predictor at a given compval and threshval</p></a></li>
<li><a href='#plotTuningSurface'><p>Plots the tuning surface of TPLS</p></a></li>
<li><a href='#TPLS'><p>Constructor method for fitting a T-PLS model with given data X and Y.</p></a></li>
<li><a href='#TPLS_cv'><p>Constructor method for fitting a cross-validation T-PLS model</p></a></li>
<li><a href='#TPLSdat'><p>Sample participant data from a left-right button press task</p></a></li>
<li><a href='#TPLSpredict'><p>Method for making predictions on a testing dataset testX</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Thresholded Partial Least Squares Model for Neuroimaging Data</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.4</td>
</tr>
<tr>
<td>Description:</td>
<td>Uses thresholded partial least squares algorithm to create a regression or classification model. For more information, see Lee, Bradlow, and Kable &lt;<a href="https://doi.org/10.1016%2Fj.crmeth.2022.100227">doi:10.1016/j.crmeth.2022.100227</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5), plotly (&ge; 4.9.2.1)</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.0</td>
</tr>
<tr>
<td>LazyDataCompression:</td>
<td>xz</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-06-10 21:09:04 UTC; sangil</td>
</tr>
<tr>
<td>Author:</td>
<td>Sangil Lee [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Sangil Lee &lt;sangillee3rd@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-06-10 21:20:23 UTC</td>
</tr>
</table>
<hr>
<h2 id='evalTuningParam'>Evaluating cross-validation performance of a TPLS_cv model at compvec and threshvec</h2><span id='topic+evalTuningParam'></span>

<h3>Description</h3>

<p>Evaluating cross-validation performance of a TPLS_cv model at compvec and threshvec
</p>


<h3>Usage</h3>

<pre><code class='language-R'>evalTuningParam(
  TPLScvmdl,
  type = c("Pearson", "negMSE", "ACC", "AUC", "LLbinary", "Spearman"),
  X,
  Y,
  compvec,
  threshvec,
  subfold = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="evalTuningParam_+3A_tplscvmdl">TPLScvmdl</code></td>
<td>
<p>TPLS_cv model created from <code>TPLS_cv</code></p>
</td></tr>
<tr><td><code id="evalTuningParam_+3A_type">type</code></td>
<td>
<p>CV performance metric type. One of LLbinary, negMSE, Pearson, Spearman, AUC, ACC.</p>
</td></tr>
<tr><td><code id="evalTuningParam_+3A_x">X</code></td>
<td>
<p>The same X as used in <code>TPLScvmdl</code>.</p>
</td></tr>
<tr><td><code id="evalTuningParam_+3A_y">Y</code></td>
<td>
<p>The SAME Y as used in <code>TPLScvmdl</code>.</p>
</td></tr>
<tr><td><code id="evalTuningParam_+3A_compvec">compvec</code></td>
<td>
<p>Vector of number of components to test in cross-validation.</p>
</td></tr>
<tr><td><code id="evalTuningParam_+3A_threshvec">threshvec</code></td>
<td>
<p>Vector of threshold level (0 ~ 1) to test in cross-validation.</p>
</td></tr>
<tr><td><code id="evalTuningParam_+3A_subfold">subfold</code></td>
<td>
<p>(Optional) vector of subdivision within testing fold to calculate performance. For example scan run division within subject.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A evalTuningParam object that contains the following attributes.
</p>

<ul>
<li> <p><code>type</code>: Cross validation performance measure type, as specified in the input
</p>
</li>
<li> <p><code>threshval</code>: Same as the input threshvec
</p>
</li>
<li> <p><code>compval</code>: Same as the input compvec
</p>
</li>
<li> <p><code>perfmat</code>: Performance measure 3D matrix: length(compvec)-by-length(threshvec)-by-numfold
</p>
</li>
<li> <p><code>perf_best</code>: Best CV performance out of all combinations of compvec and threshvec
</p>
</li>
<li> <p><code>compval_best</code>: Number of components that gave the best performance (i.e., perf_best)
</p>
</li>
<li> <p><code>threshval_best</code>: Threshold level that gave the best performance (i.e., perf_best)
</p>
</li>
<li> <p><code>perf_1se</code> : Performance of the most parsimonious model (least number of coefficients) that is within 1 standard error of perf_best.
</p>
</li>
<li> <p><code>compval_1se</code> : Number of components that gave perf_1se
</p>
</li>
<li> <p><code>threshval_1se</code> : Threshold level that gave perf_1se
</p>
</li>
<li> <p><code>best_at_threshold</code> : a 3-column matrix; first column is max performance at threshold, second column is threshold values, third column is number of components for the best model at threshold
</p>
</li></ul>


<hr>
<h2 id='makePredictor'>Method for extracting the T-PLS predictor at a given compval and threshval</h2><span id='topic+makePredictor'></span>

<h3>Description</h3>

<p>Method for extracting the T-PLS predictor at a given compval and threshval
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makePredictor(TPLSmdl, compval, threshval)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makePredictor_+3A_tplsmdl">TPLSmdl</code></td>
<td>
<p>A TPLS object created from using function <code>TPLS</code></p>
</td></tr>
<tr><td><code id="makePredictor_+3A_compval">compval</code></td>
<td>
<p>Vector of number of components to use in final predictor. Providing a vector will provide multiple betamaps (e.g., c(3,4,5) will provide three betamaps each with 3, 4, and 5 PLS components)</p>
</td></tr>
<tr><td><code id="makePredictor_+3A_threshval">threshval</code></td>
<td>
<p>Threshold number between 0 and 1 (inclusive) for thresholding the betamap. This must be a scalar.</p>
</td></tr>
</table>


<h3>Value</h3>


<ul>
<li> <p><code>bias</code>: The intercept of the extracted model. Vector of intercepts if compval is a vector.
</p>
</li>
<li> <p><code>betamap</code>: Column vector of betamap. Matrix of betamaps if compval is a vector.
</p>
</li></ul>


<hr>
<h2 id='plotTuningSurface'>Plots the tuning surface of TPLS</h2><span id='topic+plotTuningSurface'></span>

<h3>Description</h3>

<p>Plots the tuning surface of TPLS
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotTuningSurface(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotTuningSurface_+3A_object">object</code></td>
<td>
<p>: evalTuningParam object</p>
</td></tr>
</table>

<hr>
<h2 id='TPLS'>Constructor method for fitting a T-PLS model with given data X and Y.</h2><span id='topic+TPLS'></span>

<h3>Description</h3>

<p>Constructor method for fitting a T-PLS model with given data X and Y.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TPLS(X, Y, NComp = 25, W = NULL, nmc = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="TPLS_+3A_x">X</code></td>
<td>
<p>Numerical matrix of predictors. Typically single-trial betas where each column is a voxel and row is observation</p>
</td></tr>
<tr><td><code id="TPLS_+3A_y">Y</code></td>
<td>
<p>Variable to predict. Binary 0 and 1 in case of classification, continuous variable in case of regression</p>
</td></tr>
<tr><td><code id="TPLS_+3A_ncomp">NComp</code></td>
<td>
<p>(Optional) Number of PLS components to compute. Default is 25.</p>
</td></tr>
<tr><td><code id="TPLS_+3A_w">W</code></td>
<td>
<p>(Optional) Observation weights. By default, all observations have equal weight.</p>
</td></tr>
<tr><td><code id="TPLS_+3A_nmc">nmc</code></td>
<td>
<p>(Optional) 'no mean centering'. Default is 0. If 1, T-PLS will skip mean-centering. This option is only provided in case you already mean-centered the data and want to save some memory usage.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A TPLS object that contains the following attributes. Most of the time, you won't need to access the attributes.
</p>

<ul>
<li> <p><code>NComp</code>: The number of components you specified in the input
</p>
</li>
<li> <p><code>W</code>: Normalized version of the observation weights (i.e., they sum to 1)
</p>
</li>
<li> <p><code>MtrainX</code>: Column mean of X. Weighted mean if W is given.
</p>
</li>
<li> <p><code>MtrainY</code>: Mean of Y. Weighted mean if W is given.
</p>
</li>
<li> <p><code>scoreCorr</code>: Correlation between Y and each PLS component. Weighted correlation if W is given.
</p>
</li>
<li> <p><code>pctVar</code>: Proportion of variance of Y that each component explains.
</p>
</li>
<li> <p><code>betamap</code>: v-by-NComp matrix of TPLS coefficients for each of the v variables, provided at each model with NComp components.
</p>
</li>
<li> <p><code>threshmap</code> : v-by-NComp matrix of TPLS threshold values (0~1) for each of the v variables, provided at each model with NComp components.
</p>
</li></ul>

<p>See vignettes for tutorial
</p>

<hr>
<h2 id='TPLS_cv'>Constructor method for fitting a cross-validation T-PLS model</h2><span id='topic+TPLS_cv'></span>

<h3>Description</h3>

<p>Constructor method for fitting a cross-validation T-PLS model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TPLS_cv(X, Y, CVfold, NComp = 25, W = NULL, nmc = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="TPLS_cv_+3A_x">X</code></td>
<td>
<p>Numerical matrix of predictors. Typically single-trial betas where each column is a voxel and row is observation</p>
</td></tr>
<tr><td><code id="TPLS_cv_+3A_y">Y</code></td>
<td>
<p>Variable to predict. Binary 0 and 1 in case of classification, continuous variable in case of regression</p>
</td></tr>
<tr><td><code id="TPLS_cv_+3A_cvfold">CVfold</code></td>
<td>
<p>Cross-validation testing fold information. Can either be a vector or a matrix, the latter being more general.
Vector: n-by-1 vector. Each element is a number ranging from 1 ~ numfold to identify which testing fold each observation belongs to
Matrix: n-by-numfold matrix. Each column indicates the testing data with 1 and training data as 0.
Example: For leave-one-out CV, Vector would be 1:n, Matrix form would be eye(n)
Matrix form is more general as it can have same trial be in multiple test folds</p>
</td></tr>
<tr><td><code id="TPLS_cv_+3A_ncomp">NComp</code></td>
<td>
<p>(Optional) Number of PLS components to compute. Default is 25.</p>
</td></tr>
<tr><td><code id="TPLS_cv_+3A_w">W</code></td>
<td>
<p>(Optional) Observation weights. Optional input. By default, all observations have equal weight.
Can either be a n-by-1 vector or a n-by-nfold matrix where each column is observation weights in that CV fold</p>
</td></tr>
<tr><td><code id="TPLS_cv_+3A_nmc">nmc</code></td>
<td>
<p>(Optional) 'no mean centering'. See TPLS for more detail.
Turning this on will skip mean centering on all cross validation folds, so they should all be mean-centered already</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A TPLS_cv object that contains the following attributes. Most of the time, you won't need to access the attributes.
</p>

<ul>
<li> <p><code>NComp</code>: The number of components you specified in the input
</p>
</li>
<li> <p><code>numfold</code>: Total number of cross-validation folds
</p>
</li>
<li> <p><code>CVfold</code>: A matrix of indicators for testing data for each cross validation fold in each column
</p>
</li>
<li> <p><code>cvMdls</code> : A vector of TPLS models, one for each fold.
</p>
</li></ul>

<p>See vignettes for tutorial
</p>

<hr>
<h2 id='TPLSdat'>Sample participant data from a left-right button press task</h2><span id='topic+TPLSdat'></span>

<h3>Description</h3>

<p>A dataset containing five sample participant's binary button presses inside the scanner (left/right).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TPLSdat
</code></pre>


<h3>Format</h3>

<p>A data frame with following variables
</p>

<dl>
<dt>X</dt><dd><p>Brain image single trial coefficients. N-by-v matrix</p>
</dd>
<dt>Y</dt><dd><p>Left = 0, Right = 1, binary indicator of participant choice</p>
</dd>
<dt>subj</dt><dd><p>Subject number (i.e., 1, 2, 3)</p>
</dd>
<dt>run</dt><dd><p>Run number (i.e., 1, 2, 3, 4, 5, 6, 7, 8)</p>
</dd>
<dt>mask</dt><dd><p>Binary 3D brain image that indexes where the variables in X came from.</p>
</dd>
</dl>



<h3>Source</h3>

<p>Kable, J. W., Caulfield, M. K., Falcone, M., McConnell, M., Bernardo, L., Parthasarathi, T., ... &amp; Diefenbach, P. (2017). No effect of commercial cognitive training on brain activity, choice behavior, or cognitive performance. Journal of Neuroscience, 37(31), 7390-7402.
</p>

<hr>
<h2 id='TPLSpredict'>Method for making predictions on a testing dataset testX</h2><span id='topic+TPLSpredict'></span>

<h3>Description</h3>

<p>Method for making predictions on a testing dataset testX
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TPLSpredict(TPLSmdl, compval, threshval, testX)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="TPLSpredict_+3A_tplsmdl">TPLSmdl</code></td>
<td>
<p>A TPLS object created from using function <code>TPLS</code></p>
</td></tr>
<tr><td><code id="TPLSpredict_+3A_compval">compval</code></td>
<td>
<p>Vector of number of components to use in final predictor. Providing a vector will provide multiple predictions (e.g., c(3,4,5) will provide three prediction columns each with 3, 4, and 5 PLS components)</p>
</td></tr>
<tr><td><code id="TPLSpredict_+3A_threshval">threshval</code></td>
<td>
<p>Threshold number between 0 and 1 (inclusive) for thresholding the betamap. This must be a scalar.</p>
</td></tr>
<tr><td><code id="TPLSpredict_+3A_testx">testX</code></td>
<td>
<p>Data that you want to predict the Y of</p>
</td></tr>
</table>


<h3>Value</h3>


<ul>
<li> <p><code>score</code>: Column vector of prediction scores. Matrix of scores if compval is a vector.
</p>
</li></ul>


</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
