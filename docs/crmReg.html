<!DOCTYPE html><html><head><title>Help for package crmReg</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {crmReg}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#crmReg-package'>
<p>Cellwise Robust M-regression and SPADIMO</p></a></li>
<li><a href='#cellwiseheatmap'><p>Heatmap of cellwise outliers</p></a></li>
<li><a href='#crm'><p>Cellwise Robust M-regression</p></a></li>
<li><a href='#daprpr'><p>Data Preprocessing</p></a></li>
<li><a href='#predict.crm'><p>Predict method for CRM fits</p></a></li>
<li><a href='#spadimo'><p>SPArse DIrections of Maximal Outlyingness</p></a></li>
<li><a href='#topgear'><p>Top Gear car data</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Cellwise Robust M-Regression and SPADIMO</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.2</td>
</tr>
<tr>
<td>Description:</td>
<td>Method for fitting a cellwise robust linear M-regression model (CRM, Filzmoser et al. (2020) &lt;<a href="https://doi.org/10.1016%2Fj.csda.2020.106944">doi:10.1016/j.csda.2020.106944</a>&gt;) that yields both a map of cellwise outliers consistent with the linear model, and a vector of regression coefficients that is robust against vertical outliers and leverage points. As a by-product, the method yields an imputed data set that contains estimates of what the values in cellwise outliers would need to amount to if they had fit the model. The package also provides diagnostic tools for analyzing casewise and cellwise outliers using sparse directions of maximal outlyingness (SPADIMO, Debruyne et al. (2019) &lt;<a href="https://doi.org/10.1007%2Fs11222-018-9831-5">doi:10.1007/s11222-018-9831-5</a>&gt;).</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>FNN, ggplot2, gplots, pcaPP, plyr, robustbase, rrcov</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Author:</td>
<td>Peter Filzmoser [aut],
  Sebastiaan Hoppner [aut, cre],
  Irene Ortner [aut],
  Sven Serneels [aut],
  Tim Verdonck [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Sebastiaan Hoppner &lt;sebastiaan.hoppner@gmail.com&gt;</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>false</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>6.1.1</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2020-09-23 07:49:59 UTC; Sebastiaan</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2020-09-23 08:40:11 UTC</td>
</tr>
</table>
<hr>
<h2 id='crmReg-package'>
Cellwise Robust M-regression and SPADIMO
</h2><span id='topic+crmReg-package'></span><span id='topic+crmReg'></span>

<h3>Description</h3>

<p>Method for fitting a cellwise robust linear M-regression model (CRM, Filzmoser et al. (2020) &lt;DOI:10.1016/j.csda.2020.106944&gt;) that yields both
a map of cellwise outliers consistent with the linear model, and a vector of regression coefficients
that is robust against vertical outliers and leverage points. As a by-product, the method yields an
imputed data set that contains estimates of what the values in cellwise outliers would need to
amount to if they had fit the model. The package also provides diagnostic tools for analyzing
casewise and cellwise outliers using sparse directions of maximal outlyingness (SPADIMO, Debruyne et al. (2019) &lt;DOI:10.1007/s11222-018-9831-5&gt;).
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> crmReg </td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package </td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 1.0.1 </td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2020-03-26 </td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL (&gt;=2) </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>The crmReg package provides the implementation of the Cellwise Robust M-regression (CRM) algorithm
(Filzmoser et al., 2020) and the SPArse DIrections of Maximal Outlyingness (SPADIMO) algorithm
(Debruyne et al., 2019). The package also includes a predict function for fitted CRM regression
models, a function for creating heatmaps of cellwise outliers, and a data preprocessing function
for centering and scaling the data as used by CRM.
</p>
<p>Given an observation that has been detected as an outlier, SPADIMO (Debruyne et al., 2019) finds
the subset of variables contributing most the outlier’s outlyingness. Here, the outlyingness of a
data point is defined as its robust Mahalanobis distance. The relevant variables are found by
checking the direction in which the observation is most outlying. SPADIMO estimates this direction
of maximal outlyingness in a sparse manner. Thereby, the method helps to understand in which way
an outlier lies out.
</p>
<p>The SPADIMO algorithm allows us to introduce the cellwise robust M-regression (CRM) estimator
(Filzmoser et al., 2020) as a linear regression estimator that intrinsically yields both a map of
cellwise outliers consistent with the linear model, and a vector of regression coefficients that
is robust against vertical outliers and leverage points.
As a by-product, the method yields a weighted and imputed data set that
contains estimates of what the values in cellwise outliers would need to amount to if they had fit
the model. The CRM method consists of an iteratively reweighted least squares procedure where
SPADIMO is applied at each iteration to detect the cells that contribute most to outlyingness.
As such, CRM detects deviating data cells consistent with a linear model.
</p>
<p>The package contains five main functions.
</p>
<p>The function <code><a href="#topic+spadimo">spadimo</a></code> computes the sparse directions of maximal outlyings of a given
observation and shows diagnostic plots for analyzing that observation.
</p>
<p>The function <code><a href="#topic+crm">crm</a></code> fits a cellwise robust M-regression estimator. Besides a vector of
regression coefficients, the function returns an imputed data set that contains estimates of what
the values in cellwise outliers would need to amount to if they had fit the model. The output of
<code>crm</code> is a list object of class &quot;<code>crm</code>&quot;.
</p>
<p>The function <code><a href="#topic+predict.crm">predict.crm</a></code> obtains predictions from a fitted object of class &quot;<code>crm</code>&quot;.
</p>
<p>The function <code><a href="#topic+cellwiseheatmap">cellwiseheatmap</a></code> makes a heatmap of cellwise outliers which are typically
the result of a call to the <code>crm</code> function.
</p>
<p>The function <code><a href="#topic+daprpr">daprpr</a></code> preprocesses the data by classical or robust centering and scaling.
</p>


<h3>Author(s)</h3>

<p>Peter Filzmoser, Sebastiaan Hoppner, Irene Ortner, Sven Serneels, and Tim Verdonck
</p>
<p>Maintainer: Sebastiaan Hoppner &lt;sebastiaan.hoppner@kuleuven.be&gt;
</p>


<h3>References</h3>

<p>Debruyne, M., Hoppner, S., Serneels, S., and Verdonck, T. (2019). Outlyingness: Which variables contribute most?
<em>Statistics and Computing</em>, 29 (4), 707–723.
<em>DOI:10.1007/s11222-018-9831-5</em>
</p>
<p>Filzmoser, P., Hoppner, S., Ortner, I., Serneels, S., and Verdonck, T. (2020). Cellwise Robust M regression.
<em>Computational Statistics and Data Analysis</em>, 147, 106944.
<em>DOI:10.1016/j.csda.2020.106944</em>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+crm">crm</a></code>, <code><a href="#topic+spadimo">spadimo</a></code>, <code><a href="#topic+predict.crm">predict.crm</a></code>, <code><a href="#topic+cellwiseheatmap">cellwiseheatmap</a></code>, <code><a href="#topic+daprpr">daprpr</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(crmReg)
data(topgear)

# get case weights from a robust estimator (covMCD function in robustbase package):
MCD &lt;- robustbase::covMcd(topgear, alpha = 0.5)

# SPADIMO with diagnostic plots:
# Example 1:
Peugeot &lt;- spadimo(data = topgear,
                   weights = MCD$mcd.wt,
                   obs = which(rownames(topgear) == "Peugeot 107"))
# check the plots!
# individual variable names contributing most to Peugeot 107's outlyingness:
print(Peugeot$outlvars)
# sparse direction of maximal outlyingness with eta = Peugeot$eta:
print(Peugeot$a)
# default SPADIMO control parameters:
print(Peugeot$control)

# Example 2:
Bugatti &lt;- spadimo(data = topgear,
                   weights = MCD$mcd.wt,
                   obs = which(rownames(topgear) == "Bugatti Veyron"),
                   control = list(stopearly = TRUE, trace = TRUE, plot = TRUE))
# check the plots!
# individual variable names contributing most to Bugatti Veyron's outlyingness:
print(Bugatti$outlvars)
# sparse direction of maximal outlyingness with eta = Bugatti$eta:
print(Bugatti$a)

# fit Cellwise Robust M-regression:
crmfit &lt;- crm(formula = MPG ~ ., data = topgear)

# estimated regression coefficients and detected casewise outliers:
print(crmfit$coefficients)
print(rownames(topgear)[which(crmfit$casewiseoutliers)])

# fitted response values (MPG) versus true response values:
plot(topgear$MPG, crmfit$fitted.values, xlab = "True MPG", ylab = "Fitted MPG")
abline(a = 0, b = 1)

# residuals:
plot(crmfit$residuals, ylab = "Residuals")
text(x = which(crmfit$residuals &gt; 30), y = crmfit$residuals[which(crmfit$residuals &gt; 30)],
     labels = rownames(topgear)[which(crmfit$residuals &gt; 30)], pos = 2)

print(cbind.data.frame(car = rownames(topgear),
                       MPG = topgear$MPG)[which(crmfit$residuals &gt; 30), ])

# cellwise heatmap of casewise outliers:
cellwiseheatmap(cellwiseoutliers = crmfit$cellwiseoutliers[which(crmfit$casewiseoutliers), ],
                data = round(topgear[which(crmfit$casewiseoutliers), -7], 2),
                col.scale.factor = 1/4)
# check the plotted heatmap!
</code></pre>

<hr>
<h2 id='cellwiseheatmap'>Heatmap of cellwise outliers</h2><span id='topic+cellwiseheatmap'></span>

<h3>Description</h3>

<p>Makes a heatmap of cellwise outliers.</p>


<h3>Usage</h3>

<pre><code class='language-R'>cellwiseheatmap(cellwiseoutliers, data,
                col = c("blue", "lightgray", "red"), col.scale.factor = 1,
                notecol.outlier = "white", notecol.clean = "black", notecex = 1,
                margins = c(9.5, 14), lhei = c(0.5, 15), lwid = c(0.1, 3.5),
                sepcolor = "white", sepwidth = c(0.01, 0.01))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cellwiseheatmap_+3A_cellwiseoutliers">cellwiseoutliers</code></td>
<td>
<p>a matrix that indicates the cellwise outliers as the (scaled) difference between the original data and imputed data, both scaled and centered. Typically the result of a call to the <code><a href="#topic+crm">crm</a></code> function.</p>
</td></tr>
<tr><td><code id="cellwiseheatmap_+3A_data">data</code></td>
<td>
<p>the data as a data frame that is shown in the cells, including row and column names.</p>
</td></tr>
<tr><td><code id="cellwiseheatmap_+3A_col">col</code></td>
<td>
<p>vector of colors used for downward outliers, clean cells and upward outliers respectively (default is <code>c("blue", "lightgray", "red")</code>).</p>
</td></tr>
<tr><td><code id="cellwiseheatmap_+3A_col.scale.factor">col.scale.factor</code></td>
<td>
<p>numeric factor for scaling the colors of the cells (default is <code>1</code>). Usually a value between 0 and 1, e.g. 1/2, 1/3, etc.</p>
</td></tr>
<tr><td><code id="cellwiseheatmap_+3A_notecol.outlier">notecol.outlier</code></td>
<td>
<p>character string specifying the color for cellnote text of cellwise outliers (default is <code>"white"</code>).</p>
</td></tr>
<tr><td><code id="cellwiseheatmap_+3A_notecol.clean">notecol.clean</code></td>
<td>
<p>character string specifying the color for cellnote text of clean cells (default is <code>"black"</code>).</p>
</td></tr>
<tr><td><code id="cellwiseheatmap_+3A_notecex">notecex</code></td>
<td>
<p>numeric scaling factor for cellnotes (default is <code>1</code>).</p>
</td></tr>
<tr><td><code id="cellwiseheatmap_+3A_margins">margins</code></td>
<td>
<p>numeric vector of length 2 containing the margins (see <code><a href="graphics.html#topic+par">par</a>(mar= *)</code>) for column and row names, respectively (default is <code>c(9.5, 14)</code>).</p>
</td></tr>
<tr><td><code id="cellwiseheatmap_+3A_lhei">lhei</code></td>
<td>
<p>numeric vector of length 2 containing the row height (default is <code>c(1, 15)</code>).</p>
</td></tr>
<tr><td><code id="cellwiseheatmap_+3A_lwid">lwid</code></td>
<td>
<p>numeric vector of length 2 containing the row width (default is <code>c(0.7, 3.5)</code>).</p>
</td></tr>
<tr><td><code id="cellwiseheatmap_+3A_sepcolor">sepcolor</code></td>
<td>
<p>character string specifying the color between the cells (default is <code>"white"</code>).</p>
</td></tr>
<tr><td><code id="cellwiseheatmap_+3A_sepwidth">sepwidth</code></td>
<td>
<p>vector of length 2 giving the width and height of the separator box drawn between the cells (default is <code>c(0.01, 0.01)</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>cellwiseheatmap</code> plots a heatmap of cellwise outliers which are typically
the result of a call to the <code><a href="#topic+crm">crm</a></code> function.</p>


<h3>Author(s)</h3>

<p>Peter Filzmoser, Sebastiaan Hoppner, Irene Ortner, Sven Serneels, and Tim Verdonck</p>


<h3>References</h3>

<p>Filzmoser, P., Hoppner, S., Ortner, I., Serneels, S., and Verdonck, T. (2020). Cellwise Robust M regression.
<em>Computational Statistics and Data Analysis</em>, 147, 106944.
<em>DOI:10.1016/j.csda.2020.106944</em>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+crm">crm</a></code>, <code><a href="#topic+spadimo">spadimo</a></code>, <code><a href="#topic+predict.crm">predict.crm</a></code>, <code><a href="#topic+daprpr">daprpr</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>library(crmReg)
data(topgear)

# fit Cellwise Robust M-regression:
crmfit &lt;- crm(formula = MPG ~ ., data = topgear)

# cellwise heatmap of casewise outliers:
cellwiseheatmap(cellwiseoutliers = crmfit$cellwiseoutliers[which(crmfit$casewiseoutliers), ],
                data = round(topgear[which(crmfit$casewiseoutliers), -7], 2),
                col.scale.factor = 1/4)
# check the plotted heatmap!
</code></pre>

<hr>
<h2 id='crm'>Cellwise Robust M-regression</h2><span id='topic+crm'></span>

<h3>Description</h3>

<p>Fits a cellwise robust M-regression estimator. Besides a vector of
regression coefficients, the function returns an imputed data set that contains estimates of what
the values in cellwise outliers would need to amount to if they had fit the model.</p>


<h3>Usage</h3>

<pre><code class='language-R'>crm(formula, data, maxiter = 100, tolerance = 0.01, outlyingness.factor = 1,
    spadieta = seq(0.9, 0.1, -0.1), center = "median", scale = "qn",
    regtype = "MM", alphaLTS = NULL, seed = NULL, verbose = TRUE)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="crm_+3A_formula">formula</code></td>
<td>
<p>an lm-style formula object specifying which relationship to estimate.</p>
</td></tr>
<tr><td><code id="crm_+3A_data">data</code></td>
<td>
<p>the data as a data frame.</p>
</td></tr>
<tr><td><code id="crm_+3A_maxiter">maxiter</code></td>
<td>
<p>maximum number of iterations (default is <code>100</code>).</p>
</td></tr>
<tr><td><code id="crm_+3A_tolerance">tolerance</code></td>
<td>
<p>obtain optimal regression coefficients to within a certain tolerance (default is <code>0.01</code>).</p>
</td></tr>
<tr><td><code id="crm_+3A_outlyingness.factor">outlyingness.factor</code></td>
<td>
<p>numeric value, larger or equal to 1 (default). Only cells are altered of
cases for which the original outlyingness (before SPADIMO) is larger than
outlyingness.factor * outlyingness AFTER SPADIMO. The larger this factor, the fewer cells are imputed.</p>
</td></tr>
<tr><td><code id="crm_+3A_spadieta">spadieta</code></td>
<td>
<p>the sparsity parameter to start internal outlying cell detection with, must be in the range [0,1] (default is <code>seq(0.9, 0.1, -0.1)</code>).</p>
</td></tr>
<tr><td><code id="crm_+3A_center">center</code></td>
<td>
<p>how to center the data. A string that matches the R function to be used for centering (default is <code>"median"</code>).</p>
</td></tr>
<tr><td><code id="crm_+3A_scale">scale</code></td>
<td>
<p>how to scale the data. Choices are &quot;no&quot; (no scaling) or a string matching the R function to be used for scaling (default is <code>"qn"</code>).</p>
</td></tr>
<tr><td><code id="crm_+3A_regtype">regtype</code></td>
<td>
<p>type of robust regression. Choices are <code>"MM"</code> (default) or <code>"LTS"</code>.</p>
</td></tr>
<tr><td><code id="crm_+3A_alphalts">alphaLTS</code></td>
<td>
<p>parameter used by LTS regression. The percentage (roughly) of squared residuals whose sum will be minimized (default is <code>0.5</code>).</p>
</td></tr>
<tr><td><code id="crm_+3A_seed">seed</code></td>
<td>
<p>initial seed for random generator, like <a href="base.html#topic+.Random.seed">.Random.seed</a> (default is <code>NULL</code>).</p>
</td></tr>
<tr><td><code id="crm_+3A_verbose">verbose</code></td>
<td>
<p>should output be shown during the process (default is <code>TRUE</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The cellwise robust M-regression (CRM) estimator (Filzmoser et al., 2020) is a linear
regression estimator that intrinsically yields both a map of cellwise outliers consistent with the
linear model, and a vector of regression coefficients that is robust against vertical outliers and leverage points.
As a by-product, the method yields a weighted and imputed data set that contains estimates of what
the values in cellwise outliers would need to amount to if they had fit the model. The CRM method
consists of an iteratively reweighted least squares procedure where SPADIMO is applied at each
iteration to detect the cells that contribute most to outlyingness. As such, CRM detects deviating
data cells consistent with a linear model.</p>


<h3>Value</h3>

<p><code>crm</code> returns a list object of class &quot;<code>crm</code>&quot; containing the following elements:
</p>
<table>
<tr><td><code>coefficients</code></td>
<td>
<p>a named vector of fitted coefficients.</p>
</td></tr>
<tr><td><code>fitted.values</code></td>
<td>
<p>the fitted response values.</p>
</td></tr>
<tr><td><code>residuals</code></td>
<td>
<p>the residuals, that is response minus fitted values.</p>
</td></tr>
<tr><td><code>weights</code></td>
<td>
<p>the (case) weights of the residuals.</p>
</td></tr>
<tr><td><code>data.imputed</code></td>
<td>
<p>the data as imputed by CRM.</p>
</td></tr>
<tr><td><code>casewiseoutliers</code></td>
<td>
<p>a vector that indicates the casewise outliers with <code>TRUE</code> or <code>FALSE</code>.</p>
</td></tr>
<tr><td><code>cellwiseoutliers</code></td>
<td>
<p>a matrix that indicates the cellwise outliers as the (scaled) difference between the original data and imputed data, both scaled and centered.</p>
</td></tr>
<tr><td><code>terms</code></td>
<td>
<p>the terms object used.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>the matched call.</p>
</td></tr>
<tr><td><code>inputs</code></td>
<td>
<p>the list of supplied input arguments.</p>
</td></tr>
<tr><td><code>numloops</code></td>
<td>
<p>the number of iterations.</p>
</td></tr>
<tr><td><code>time</code></td>
<td>
<p>the number of seconds passed to execute the CRM algorithm.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Peter Filzmoser, Sebastiaan Hoppner, Irene Ortner, Sven Serneels, and Tim Verdonck</p>


<h3>References</h3>

<p>Filzmoser, P., Hoppner, S., Ortner, I., Serneels, S., and Verdonck, T. (2020). Cellwise Robust M regression.
<em>Computational Statistics and Data Analysis</em>, 147, 106944.
<em>DOI:10.1016/j.csda.2020.106944</em>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+spadimo">spadimo</a></code>, <code><a href="#topic+predict.crm">predict.crm</a></code>, <code><a href="#topic+cellwiseheatmap">cellwiseheatmap</a></code>, <code><a href="#topic+daprpr">daprpr</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>library(crmReg)
data(topgear)

# fit Cellwise Robust M-regression:
crmfit &lt;- crm(formula = MPG ~ ., data = topgear)

# estimated regression coefficients and detected casewise outliers:
print(crmfit$coefficients)
print(rownames(topgear)[which(crmfit$casewiseoutliers)])

# fitted response values (MPG) versus true response values:
plot(topgear$MPG, crmfit$fitted.values, xlab = "True MPG", ylab = "Fitted MPG")
abline(a = 0, b = 1)

# residuals:
plot(crmfit$residuals, ylab = "Residuals")
text(x = which(crmfit$residuals &gt; 30), y = crmfit$residuals[which(crmfit$residuals &gt; 30)],
     labels = rownames(topgear)[which(crmfit$residuals &gt; 30)], pos = 2)

print(cbind.data.frame(car = rownames(topgear),
                       MPG = topgear$MPG)[which(crmfit$residuals &gt; 30), ])

# cellwise heatmap of casewise outliers:
cellwiseheatmap(cellwiseoutliers = crmfit$cellwiseoutliers[which(crmfit$casewiseoutliers), ],
                data = round(topgear[which(crmfit$casewiseoutliers), -7], 2),
                col.scale.factor = 1/4)
# check the plotted heatmap!
</code></pre>

<hr>
<h2 id='daprpr'>Data Preprocessing</h2><span id='topic+daprpr'></span>

<h3>Description</h3>

<p>Data preprocessing, classical and robust centering and scaling.</p>


<h3>Usage</h3>

<pre><code class='language-R'>daprpr(Data, center.type, scale.type)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="daprpr_+3A_data">Data</code></td>
<td>
<p>the data.</p>
</td></tr>
<tr><td><code id="daprpr_+3A_center.type">center.type</code></td>
<td>
<p>type of centering as R function name (e.g. <code>"mean"</code>, <code>"median"</code>, <code>"l1median"</code>).</p>
</td></tr>
<tr><td><code id="daprpr_+3A_scale.type">scale.type</code></td>
<td>
<p>type of scaling as R function name (e.g. <code>"sd"</code>, <code>"qn"</code>, <code>"Sn"</code>, <code>"scaleTau2"</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>daprpr</code> preprocesses the data by classical or robust centering and scaling.
Given <code>center.type = "mean"</code> and <code>scale.type = "sd"</code>, function <code>daprpr</code> is
equivalent to <code>scale(Data, center = TRUE, scale = TRUE)</code>.</p>


<h3>Value</h3>

<p><code>daprpr</code> returns the scaled data with attributes <code>"Center"</code>, <code>"Scale"</code> and <code>"Type"</code>.</p>


<h3>Author(s)</h3>

<p>Sven Serneels</p>


<h3>See Also</h3>

<p><code><a href="#topic+crm">crm</a></code>, <code><a href="#topic+spadimo">spadimo</a></code>, <code><a href="#topic+predict.crm">predict.crm</a></code>, <code><a href="#topic+cellwiseheatmap">cellwiseheatmap</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>library(crmReg)
data(topgear)

topgear_centered_scaled &lt;- daprpr(topgear, center.type = "median", scale.type = "qn")

boxplot(topgear_centered_scaled)
attributes(topgear_centered_scaled)$Type
attributes(topgear_centered_scaled)$Center
attributes(topgear_centered_scaled)$Scale
</code></pre>

<hr>
<h2 id='predict.crm'>Predict method for CRM fits</h2><span id='topic+predict.crm'></span>

<h3>Description</h3>

<p>Obtains predictions from a fitted <code>crm</code> object.</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'crm'
predict(object, newdata = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.crm_+3A_object">object</code></td>
<td>
<p>a fitted object of class &quot;<code>crm</code>&quot;.</p>
</td></tr>
<tr><td><code id="predict.crm_+3A_newdata">newdata</code></td>
<td>
<p>optionally, a data frame in which to look for variables with which to predict.
If omitted, the fitted coefficients are used.</p>
</td></tr>
<tr><td><code id="predict.crm_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>predict.crm</code> produces predicted values, obtained by evaluating the fitted
<code><a href="#topic+crm">crm</a></code> object on the data frame <code>newdata</code>.</p>


<h3>Value</h3>

<p><code>predict.crm</code> returns a vector of predicted response values.
</p>


<h3>Author(s)</h3>

<p>Peter Filzmoser, Sebastiaan Hoppner, Irene Ortner, Sven Serneels, and Tim Verdonck</p>


<h3>References</h3>

<p>Filzmoser, P., Hoppner, S., Ortner, I., Serneels, S., and Verdonck, T. (2020). Cellwise Robust M regression.
<em>Computational Statistics and Data Analysis</em>, 147, 106944.
<em>DOI:10.1016/j.csda.2020.106944</em>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+crm">crm</a></code>, <code><a href="#topic+spadimo">spadimo</a></code>, <code><a href="#topic+cellwiseheatmap">cellwiseheatmap</a></code>, <code><a href="#topic+daprpr">daprpr</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>library(crmReg)
data(topgear)

train &lt;- topgear[1:200, ]
test &lt;- topgear[201:245, ]

crmfit &lt;- crm(formula = MPG ~ ., data = train, seed = 2020)

estimated_MPG_test &lt;- predict(crmfit, newdata = test)

plot(test$MPG, estimated_MPG_test, xlab = "True MPG", ylab = "Estimated MPG")
abline(a = 0, b = 1)
</code></pre>

<hr>
<h2 id='spadimo'>SPArse DIrections of Maximal Outlyingness</h2><span id='topic+spadimo'></span>

<h3>Description</h3>

<p>Computes the sparse directions of maximal outlyings of a given
observation and shows diagnostic plots for analyzing that observation.</p>


<h3>Usage</h3>

<pre><code class='language-R'>spadimo(data, weights, obs,
        control = list(scaleFun = Qn, nlatent = 1, etas = NULL, csqcritv  = 0.975,
                       stopearly = FALSE, trace = FALSE, plot = TRUE))</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spadimo_+3A_data">data</code></td>
<td>
<p>the data as a data frame.</p>
</td></tr>
<tr><td><code id="spadimo_+3A_weights">weights</code></td>
<td>
<p>a numeric vector containing the case weights from a robust estimator.</p>
</td></tr>
<tr><td><code id="spadimo_+3A_obs">obs</code></td>
<td>
<p>the (integer) case number under consideration.</p>
</td></tr>
<tr><td><code id="spadimo_+3A_control">control</code></td>
<td>
<p>a list of options that control details of the <code>crm</code> algorithm. The following options are available:
</p>

<ul>
<li><p><code>scaleFun</code> <br />
function used for robust scaling the variables (e.g. <code>Qn</code>, <code>mad</code>, etc.).
</p>
</li>
<li><p><code>nlatent</code> <br />
integer number of latent variables for sparse PLS regression (via SNIPLS) (default is <code>1</code>).
</p>
</li>
<li><p><code>etas</code> <br />
vector of decreasing sparsity parameters (default is <code>NULL</code> in which case <code>etas = seq(0.9, 0.1, -0.05)</code> if n &gt; p, otherwise <code>etas = seq(0.6, 0.1, -0.05)</code>).
</p>
</li>
<li><p><code>csqcritv</code> <br />
probability level for internal chi-squared quantile (used when n &gt; p) (default is <code>0.975</code>).
</p>
</li>
<li><p><code>stopearly</code> <br />
if <code>TRUE</code>, method stops as soon as the reduced case is no longer outlying, else if <code>FALSE</code> (default) it loops through all values of eta.
</p>
</li>
<li><p><code>trace</code> <br />
should intermediate results be printed (default is <code>FALSE</code>).
</p>
</li>
<li><p><code>plot</code> <br />
should heatmaps and graph of the results be shown (default is <code>TRUE</code>).
</p>
</li></ul>

</td></tr>
</table>


<h3>Details</h3>

<p>Given an observation that has been detected as an outlier, SPADIMO (Debruyne et al., 2019) finds
the subset of variables contributing most the outlier’s outlyingness. Here, the outlyingness of a
data point is defined as its robust Mahalanobis distance. The relevant variables are found by
checking the direction in which the observation is most outlying. SPADIMO estimates this direction
of maximal outlyingness in a sparse manner. Thereby, the method helps to understand in which way
an outlier lies out.
</p>


<h3>Value</h3>

<p><code>spadimo</code> returns a list containing the following elements:
</p>
<table>
<tr><td><code>outlvars</code></td>
<td>
<p>vector containing individual variable names contributing most to <code>obs</code>'s outlyingness.</p>
</td></tr>
<tr><td><code>outlvarslist</code></td>
<td>
<p>list of variables contributing to <code>obs</code>'s outlyingness for different values of <code>eta</code>.</p>
</td></tr>
<tr><td><code>a</code></td>
<td>
<p>vector, the sparse direction of maximal outlyingness.</p>
</td></tr>
<tr><td><code>alist</code></td>
<td>
<p>list of sparse directions of maximal outlyingness for different values of <code>eta</code>.</p>
</td></tr>
<tr><td><code>o.before</code></td>
<td>
<p>outlyingness of original case (n &lt; p) or PCA outlier flag (n &gt;= p) before removing outlying variables.</p>
</td></tr>
<tr><td><code>o.after</code></td>
<td>
<p>outlyingness of reduced case (n &gt; p) or PCA outlier flag (n &gt;= p) after removing outlying variables.</p>
</td></tr>
<tr><td><code>eta</code></td>
<td>
<p>cutoff where <code>obs</code> is no longer outlying.</p>
</td></tr>
<tr><td><code>time</code></td>
<td>
<p>time to execute the SPADIMO algorithm.</p>
</td></tr>
<tr><td><code>control</code></td>
<td>
<p>a list with control parameters that are used.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Michiel Debruyne, Sebastiaan Hoppner, Sven Serneels, and Tim Verdonck</p>


<h3>References</h3>

<p>Debruyne, M., Hoppner, S., Serneels, S., and Verdonck, T. (2019). Outlyingness: Which variables contribute most?
<em>Statistics and Computing</em>, 29 (4), 707–723.
<em>DOI:10.1007/s11222-018-9831-5</em>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+crm">crm</a></code>, <code><a href="#topic+predict.crm">predict.crm</a></code>, <code><a href="#topic+cellwiseheatmap">cellwiseheatmap</a></code>, <code><a href="#topic+daprpr">daprpr</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>library(crmReg)
data(topgear)

# get case weights from a robust estimator (covMCD function in robustbase package):
MCD &lt;- robustbase::covMcd(topgear, alpha = 0.5)

# SPADIMO with diagnostic plots:
# Example 1:
Peugeot &lt;- spadimo(data = topgear,
                   weights = MCD$mcd.wt,
                   obs = which(rownames(topgear) == "Peugeot 107"))
# check the plots!
# individual variable names contributing most to Peugeot 107's outlyingness:
print(Peugeot$outlvars)
# sparse direction of maximal outlyingness with eta = Peugeot$eta:
print(Peugeot$a)
# default SPADIMO control parameters:
print(Peugeot$control)

# Example 2:
Bugatti &lt;- spadimo(data = topgear,
                   weights = MCD$mcd.wt,
                   obs = which(rownames(topgear) == "Bugatti Veyron"),
                   control = list(stopearly = TRUE, trace = TRUE, plot = TRUE))
# check the plots!
# individual variable names contributing most to Bugatti Veyron's outlyingness:
print(Bugatti$outlvars)
# sparse direction of maximal outlyingness with eta = Bugatti$eta:
print(Bugatti$a)
</code></pre>

<hr>
<h2 id='topgear'>Top Gear car data</h2><span id='topic+topgear'></span>

<h3>Description</h3>

<p>The data set contains information on cars featured on the website of the popular BBC television
show <em>Top Gear</em>. The original, full data set is available in the package <code>robustHD</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(topgear)</code></pre>


<h3>Format</h3>

<p>A data frame containing 245 observations and 11 variables.
</p>

<dl>
<dt><code>log(Price)</code></dt><dd><p>the natural logarithm of the list price (in UK pounds)</p>
</dd>
<dt><code>log(Displacement)</code></dt><dd><p>the natural logarithm of the displacement of the engine (in cc).</p>
</dd>
<dt><code>log(BHP)</code></dt><dd><p>the natural logrithm of the power of the engine (in bhp).</p>
</dd>
<dt><code>log(Torque)</code></dt><dd><p>the natural logarithm of the torque of the engine (in lb/ft).</p>
</dd>
<dt><code>Acceleration</code></dt><dd><p>the time it takes the car to get from 0 to 62 mph (in seconds).</p>
</dd>
<dt><code>log(TopSpeed)</code></dt><dd><p>the natural logarithm of the car's top speed (in mph).</p>
</dd>
<dt><code>MPG</code></dt><dd><p>the combined fuel consuption (urban + extra urban; in miles per gallon).</p>
</dd>
<dt><code>Weight</code></dt><dd><p>the car's curb weight (in kg).</p>
</dd>
<dt><code>Length</code></dt><dd><p>the car's length (in mm).</p>
</dd>
<dt><code>Width</code></dt><dd><p>the car's width (in mm).</p>
</dd>
<dt><code>Height</code></dt><dd><p>the car's height (in mm).</p>
</dd>
</dl>



<h3>Source</h3>

<p>The original data set is available in the package <code>robustHD</code>.
The data were scraped from http://www.topgear.com/uk/ on 2014-02-24.</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(topgear)
str(topgear)
head(topgear)
summary(topgear)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
