<!DOCTYPE html><html lang="en"><head><title>Help for package Morpho</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {Morpho}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#Morpho-package'><p>A toolbox providing methods for data-acquisition, visualisation and</p>
statistical methods related to Geometric Morphometrics and shape analysis</a></li>
<li><a href='#align2procSym'><p>align new data to an existing Procrustes registration</p></a></li>
<li><a href='#angle.calc'><p>calculate angle between two vectors</p></a></li>
<li><a href='#angleTest'><p>Test whether the direction of two vectors is similar</p></a></li>
<li><a href='#anonymize'><p>Replace ID-strings of data and associated files.</p></a></li>
<li><a href='#applyTransform'><p>apply affine transformation to data</p></a></li>
<li><a href='#areaSphere'><p>compute the area of an n-dimensional hypersphere</p></a></li>
<li><a href='#areaSpherePart'><p>compute the area of an n-dimensional hypersphere cap</p></a></li>
<li><a href='#armaGinv'><p>calculate Pseudo-inverse of a Matrix using RcppArmadillo</p></a></li>
<li><a href='#array2list'><p>reverts list2array, converting an array to a list of matrices</p></a></li>
<li><a href='#arrMean3'><p>calculate mean of an array</p></a></li>
<li><a href='#asymPermute'><p>Assess differences in amount and direction of asymmetric variation (only object symmetry)</p></a></li>
<li><a href='#barycenter'><p>calculates the barycenters for all faces of a triangular mesh</p></a></li>
<li><a href='#bindArr'><p>concatenate multiple arrays/matrices</p></a></li>
<li><a href='#boneData'><p>Landmarks and a triangular mesh</p></a></li>
<li><a href='#CAC'><p>calculate common allometric component</p></a></li>
<li><a href='#cExtract'><p>extract information about fixed landmarks, curves and patches from and atlas</p>
generated by &quot;landmark&quot;</a></li>
<li><a href='#checkLM'><p>Visually browse through a sample rendering its landmarks and corresponding</p>
surfaces.</a></li>
<li><a href='#checkNA'><p>check for NA values in a matrix (of landmarks)</p></a></li>
<li><a href='#classify'><p>classify specimen based on between-group PCA or CVA or typprobClass</p></a></li>
<li><a href='#closemeshKD'><p>Project coordinates onto a target triangular surface mesh.</p></a></li>
<li><a href='#colors'><p>predefined colors for bone and skin</p></a></li>
<li><a href='#computeArea'><p>Compute area enclosed within an irregular polygon</p></a></li>
<li><a href='#computeTransform'><p>calculate an affine transformation matrix</p></a></li>
<li><a href='#covDist'><p>calculates distances and PC-coordinates of covariance matrices</p></a></li>
<li><a href='#covW'><p>calculate the pooled within groups covariance matrix</p></a></li>
<li><a href='#createAtlas'><p>Create an atlas needed in placePatch</p></a></li>
<li><a href='#CreateL'><p>Create Matrices necessary for Thin-Plate Spline</p></a></li>
<li><a href='#createMissingList'><p>create a list with empty entries to be used as missingList in slider3d</p></a></li>
<li><a href='#crossProduct'><p>calculate the orthogonal complement of a 3D-vector</p></a></li>
<li><a href='#cSize'><p>calculate Centroid Size for a landmark configuration</p></a></li>
<li><a href='#cutMeshPlane'><p>cut a mesh by a hyperplane and remove parts above/below that plane</p></a></li>
<li><a href='#cutSpace'><p>separate a 3D-pointcloud by a hyperplane</p></a></li>
<li><a href='#CVA'><p>Canonical Variate Analysis</p></a></li>
<li><a href='#data2platonic'><p>creates 3D shapes from data to be saved as triangular meshes</p></a></li>
<li><a href='#deformGrid2d'><p>visualise differences between two superimposed sets of 2D landmarks</p></a></li>
<li><a href='#deformGrid3d'><p>visualise differences between two superimposed sets of 3D landmarks</p></a></li>
<li><a href='#deprecated'><p>deprecated functions of Morpho</p></a></li>
<li><a href='#equidistantCurve'><p>make a curve equidistant (optionally up/downsampling)</p></a></li>
<li><a href='#exVar'><p>calculate variance of a distribution stemming from prediction models</p></a></li>
<li><a href='#fastKmeans'><p>fast kmeans clustering for 2D or 3D point clouds</p></a></li>
<li><a href='#file2mesh'><p>Import 3D surface mesh files</p></a></li>
<li><a href='#find.outliers'><p>Graphical interface to find outliers and/or to switch mislabeld landmarks</p></a></li>
<li><a href='#fixLMmirror'><p>estimate missing landmarks from their bilateral counterparts</p></a></li>
<li><a href='#fixLMtps'><p>estimate missing landmarks</p></a></li>
<li><a href='#getFaces'><p>find indices of faces that contain specified vertices</p></a></li>
<li><a href='#getMeaningfulPCs'><p>get number of meaningful Principal components</p></a></li>
<li><a href='#getOuterViewpoints'><p>Get viewpoints on a sphere around a 3D mesh</p></a></li>
<li><a href='#getPCscores'><p>Obtain PC-scores for new landmark data</p></a></li>
<li><a href='#getPCtol'><p>determine the minimum ratio for two subsequent eigenvalues to be considered different</p></a></li>
<li><a href='#getPLSCommonShape'><p>Get the linear combinations associated with the common shape change in each latent dimension of a pls2B</p></a></li>
<li><a href='#getPLSfromScores'><p>compute changes associated with 2-Block PLS-scores</p></a></li>
<li><a href='#getPLSscores'><p>compute 2-Block PLS scores for new data</p></a></li>
<li><a href='#getPointAlongOutline'><p>Get a point along a line with a given distance from the start of the line</p></a></li>
<li><a href='#getSides'><p>try to identify bilateral landmarks and sort them by side</p></a></li>
<li><a href='#getTrafo4x4'><p>get 4x4 Transformation matrix</p></a></li>
<li><a href='#getTrafoRotaxis'><p>compute a 4x4 Transformation matrix for rotation around an arbitrary axis</p></a></li>
<li><a href='#getVisibleVertices'><p>find vertices visible from a given viewpoints</p></a></li>
<li><a href='#groupPCA'><p>Perform PCA based of the group means' covariance matrix</p></a></li>
<li><a href='#histGroup'><p>plot histogram for multiple groups.</p></a></li>
<li><a href='#icpmat'><p>match two landmark configurations using iteratively closest point search</p></a></li>
<li><a href='#invertFaces'><p>invert faces' orientation of triangular mesh</p></a></li>
<li><a href='#kendalldist'><p>Calculates the Riemannian distance between two superimposed landmark</p>
configs.</a></li>
<li><a href='#line2plane'><p>get intersection between a line and a plane</p></a></li>
<li><a href='#lineplot'><p>plot lines between landmarks</p></a></li>
<li><a href='#list2array'><p>converts a list of matrices to an array</p></a></li>
<li><a href='#LPS2RAS'><p>convert data from LPS to RAS space and back</p></a></li>
<li><a href='#mcNNindex'><p>find nearest neighbours for 2D and 3D point clouds</p></a></li>
<li><a href='#mergeMeshes'><p>merge multiple triangular meshes into a single one</p></a></li>
<li><a href='#mesh2grey'><p>convert a colored mesh to greyscale.</p></a></li>
<li><a href='#mesh2obj'><p>export mesh objects to disk</p></a></li>
<li><a href='#meshcube'><p>calculate the corners of a mesh's bouning box</p></a></li>
<li><a href='#meshDist'><p>calculates and visualises distances between surface meshes or 3D coordinates and a surface mesh.</p></a></li>
<li><a href='#meshPlaneIntersect'><p>get intersections between mesh and a plane</p></a></li>
<li><a href='#meshres'><p>calculate average edge length of a triangular mesh</p></a></li>
<li><a href='#mirror'><p>mirror landmarks or triangular mesh in place</p></a></li>
<li><a href='#mirror2plane'><p>mirror points or mesh on an arbitrary plane</p></a></li>
<li><a href='#name2factor'><p>extract data from array names</p></a></li>
<li><a href='#NNshapeReg'><p>Estimate the shape by averaging the shape of the nearest neighbours.</p></a></li>
<li><a href='#nose'><p>landmarks and a triangular mesh representing a human nose</p></a></li>
<li><a href='#pcAlign'><p>align two 3D-pointclouds/meshes by their principal axes</p></a></li>
<li><a href='#pcaplot3d'><p>visualization of shape variation</p></a></li>
<li><a href='#PCdist'><p>correlation between a reduced space and the original space</p></a></li>
<li><a href='#permudist'><p>performs permutation testing for group differences.</p></a></li>
<li><a href='#permuvec'><p>perfom permutation testing on angles and distances between subgroups of two</p>
major groups.</a></li>
<li><a href='#placePatch'><p>Project semi-landmarks from a predefined atlas onto all specimen in a sample</p></a></li>
<li><a href='#plot.slider3d'><p>plot the result of slider3d</p></a></li>
<li><a href='#plotAtlas'><p>visualize an atlas defined by createAtlas</p></a></li>
<li><a href='#plotNormals'><p>plots the normals of a triangular surface mesh.</p></a></li>
<li><a href='#pls2B'><p>Two-Block partial least square regression.</p></a></li>
<li><a href='#plsCoVar'><p>Get the shape changes from pls2B associated with each latent variable</p></a></li>
<li><a href='#plsCoVarCommonShape'><p>Compute the shape changes along the common axis of deformations</p></a></li>
<li><a href='#points2plane'><p>projects a 3D coordinate orthogonally onto a plane</p></a></li>
<li><a href='#prcompfast'><p>fast Principal Component Analysis (PCA)</p></a></li>
<li><a href='#predict.bgPCA'><p>Compute between-group-PC scores from new data</p></a></li>
<li><a href='#predict.CVA'><p>Compute CV-scores from new data</p></a></li>
<li><a href='#predictPLSfromData'><p>predict 2 Block-PLS from new data</p></a></li>
<li><a href='#predictPLSfromScores'><p>predict data from 2-Block PLS-scores</p></a></li>
<li><a href='#predictRelWarps'><p>predict relative warps for data not included in the training data set</p></a></li>
<li><a href='#predictShape.lm'><p>Predict shapes based on linear models calculated from PCscores</p></a></li>
<li><a href='#proc.weight'><p>calculate weights inverse to the distances from the specified observation.</p></a></li>
<li><a href='#procAOVsym'><p>Procrustes ANOVA for structures with object symmetry</p></a></li>
<li><a href='#ProcGPA'><p>Workhorse function for procSym, responsible for Procrustes registration</p></a></li>
<li><a href='#procSym'><p>Procrustes registration</p></a></li>
<li><a href='#projRead'><p>Project points onto the closest point on a mesh</p></a></li>
<li><a href='#qqmat'><p>Q-Q plot to assess normality of data</p></a></li>
<li><a href='#quad2trimesh'><p>converts a mesh containing quadrangular faces into one only consisting of triangles</p></a></li>
<li><a href='#r2morphoj'><p>Export data to MorphoJ and Morphologika</p></a></li>
<li><a href='#ray2mesh'><p>projects the vertices of a mesh along its normals onto the surface of another one.</p></a></li>
<li><a href='#read.csv.folder'><p>batch import data from files</p></a></li>
<li><a href='#read.fcsv'><p>read fiducials from slicer4</p></a></li>
<li><a href='#read.lmdta'><p>read dta files</p></a></li>
<li><a href='#read.mpp'><p>Read saved pick-points from meshlab</p></a></li>
<li><a href='#read.pts'><p>reads pts files</p></a></li>
<li><a href='#read.slicerjson'><p>read Landmarks from Slicer in Json format</p></a></li>
<li><a href='#readallTPS'><p>Import landmarks and outlines from TPS files</p></a></li>
<li><a href='#readLandmarks.csv'><p>import landmark data from csv files</p></a></li>
<li><a href='#regdist'><p>correlation between shape space and tangent space</p></a></li>
<li><a href='#RegScore'><p>calulate regression scores for linear model</p></a></li>
<li><a href='#relaxLM'><p>relax one specific landmark configuration against a reference</p></a></li>
<li><a href='#relWarps'><p>calculate relative Warp analysis</p></a></li>
<li><a href='#render'><p>plot or save the results of meshDist</p></a></li>
<li><a href='#resampleCurve'><p>Resample a curve equidistantly</p></a></li>
<li><a href='#restoreFromPCA'><p>restore original data from PCA</p></a></li>
<li><a href='#restoreShapes'><p>restore shapes from PC-Scores or similar projections</p></a></li>
<li><a href='#retroDeform3d'><p>symmetrize a bilateral landmark configuration</p></a></li>
<li><a href='#retroDeformMesh'><p>symmetrize a triangular mesh</p></a></li>
<li><a href='#rotaxis3d'><p>Rotate an object (matrix or mesh) around an arbitrary axis in 3D</p></a></li>
<li><a href='#rotaxisMat'><p>calculate a rotation matrix around an arbitrary axis through the origin in</p>
3D</a></li>
<li><a href='#rotmesh.onto'><p>rotate ,scale and translate a mesh based on landmark information.</p></a></li>
<li><a href='#rotonmat'><p>rotate matrix of landmarks</p></a></li>
<li><a href='#rotonto'><p>rotates, translates and scales one matrix onto an other using Procrustes</p>
fitting</a></li>
<li><a href='#scalemesh'><p>scale a mesh of class &quot;mesh3d&quot;</p></a></li>
<li><a href='#slider2d'><p>slides Semilandmarks along curves 2D by minimising bending</p>
energy of a thin-plate spline deformation.</a></li>
<li><a href='#slider3d'><p>slides Semilandmarks along curves and surfaces in 3D by minimising bending</p>
energy of a thin-plate spline deformation.</a></li>
<li><a href='#solutionSpace'><p>returns the solution space (basis and translation vector) for an equation system</p></a></li>
<li><a href='#sortCurve'><p>sort curvepoints by using the subsequent neighbours</p></a></li>
<li><a href='#symmetrize'><p>create a perfectly symmetric version of landmarks</p></a></li>
<li><a href='#tps3d'><p>thin plate spline mapping (2D and 3D) for coordinates and triangular meshes</p></a></li>
<li><a href='#typprob'><p>calculate typicality probabilities</p></a></li>
<li><a href='#unrefVertex'><p>some little helpers for vertex operations on triangular meshes</p></a></li>
<li><a href='#updateIndices'><p>update a vector of indices after removal of some referenced items</p></a></li>
<li><a href='#updateNormals'><p>Compute face or vertex normals of a triangular mesh</p></a></li>
<li><a href='#vecx'><p>convert an 3D array into a matrix and back</p></a></li>
<li><a href='#virtualMeshScan'><p>remove all parts of a triangular mesh, not visible from a set of viewpoints</p></a></li>
<li><a href='#warpmovie3d'><p>Creates a sequence of images showing predefined steps of warping two meshes or landmark configurations (2D and 3D) into each other</p></a></li>
<li><a href='#write.fcsv'><p>write fiducials in slicer4 format</p></a></li>
<li><a href='#write.pts'><p>exports a matrix containing landmarks into .pts format</p></a></li>
<li><a href='#write.slicerjson'><p>Export landmarks (or any 3D coordinates) to the new slicer json format</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Calculations and Visualisations Related to Geometric
Morphometrics</td>
</tr>
<tr>
<td>Version:</td>
<td>2.12</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-12-04</td>
</tr>
<tr>
<td>Description:</td>
<td>A toolset for Geometric Morphometrics and mesh processing. This
    includes (among other stuff) mesh deformations based on reference points,
    permutation tests, detection of outliers, processing of sliding
    semi-landmarks and semi-automated surface landmark placement.</td>
</tr>
<tr>
<td>Suggests:</td>
<td>car, lattice, shapes, testthat</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.2.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rvcg (&ge; 0.7), rgl (&ge; 0.100.18), foreach (&ge; 1.4.0), Matrix
(&ge; 1.0-1), MASS, parallel, doParallel (&ge; 1.0.6), colorRamps,
Rcpp, graphics, grDevices, methods, stats, utils, jsonlite, sf,
bezier</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo (&ge; 0.4)</td>
</tr>
<tr>
<td>Copyright:</td>
<td>see COPYRIGHTS file for details</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/zarquon42b/Morpho/issues">https://github.com/zarquon42b/Morpho/issues</a></td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/zarquon42b/Morpho">https://github.com/zarquon42b/Morpho</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-12-06 14:20:50 UTC; schlager</td>
</tr>
<tr>
<td>Author:</td>
<td>Stefan Schlager [aut, cre, cph],
  Gregory Jefferis [ctb],
  Dryden Ian [cph]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Stefan Schlager &lt;zarquon42@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-12-06 15:20:07 UTC</td>
</tr>
</table>
<hr>
<h2 id='Morpho-package'>A toolbox providing methods for data-acquisition, visualisation and
statistical methods related to Geometric Morphometrics and shape analysis</h2><span id='topic+Morpho-package'></span><span id='topic+Morpho'></span>

<h3>Description</h3>

<p>A toolbox for Morphometric calculations. Including sliding operations for
Semilandmarks, importing, exporting and manipulating of 3D-surface meshes
and semi-automated placement of surface landmarks.
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> Morpho</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 2.12</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2023-12-04</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL</td>
</tr>
<tr>
 <td style="text-align: left;">
LazyLoad: </td><td style="text-align: left;"> yes</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Note</h3>

<p>The pdf-version of Morpho-help can be obtained from CRAN on <a href="https://cran.r-project.org/package=Morpho">https://cran.r-project.org/package=Morpho</a>
</p>
<p>For more advanced operations on triangular surface meshes, check out my package Rvcg: <a href="https://cran.r-project.org/package=Rvcg">https://cran.r-project.org/package=Rvcg</a> or the code repository on github <a href="https://github.com/zarquon42b/Rvcg">https://github.com/zarquon42b/Rvcg</a>
</p>


<h3>Author(s)</h3>

<p>Stefan Schlager <a href="mailto:zarquon42@gmail.com">zarquon42@gmail.com</a>
</p>
<p>Maintainer: Stefan Schlager <a href="mailto:zarquon42@gmail.com">zarquon42@gmail.com</a>
</p>


<h3>References</h3>

<p>Schlager S. 2013. Soft-tissue reconstruction of the human nose:
population differences and sexual dimorphism. PhD thesis,
Universitätsbibliothek Freiburg. URL:
<a href="http://www.freidok.uni-freiburg.de/volltexte/9181/">http://www.freidok.uni-freiburg.de/volltexte/9181/</a>.
</p>

<hr>
<h2 id='align2procSym'>align new data to an existing Procrustes registration</h2><span id='topic+align2procSym'></span>

<h3>Description</h3>

<p>align new data to an existing Procrustes registration
</p>


<h3>Usage</h3>

<pre><code class='language-R'>align2procSym(x, newdata, orp = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="align2procSym_+3A_x">x</code></td>
<td>
<p>result of a <code>procSym</code> call</p>
</td></tr>
<tr><td><code id="align2procSym_+3A_newdata">newdata</code></td>
<td>
<p>matrix or array of with landmarks corresponding to the data aligned in x</p>
</td></tr>
<tr><td><code id="align2procSym_+3A_orp">orp</code></td>
<td>
<p>logical: allows to skip orthogonal projection, even if it was used in the <code>procSym</code> call.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an array with data aligned to the mean shape in x (and projected into tangent space)
</p>


<h3>Note</h3>

<p>this will never yield the same result as a pooled Procrustes analysis because the sample mean is iteratively updated and new data would change the mean.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(Morpho)
data(boneData)
# run procSym on entire data set
proc &lt;- procSym(boneLM)
# this is the training data
array1 &lt;- boneLM[,,1:60]
newdata &lt;- boneLM[,,61:80]
proc1 &lt;- procSym(array1)
newalign &lt;- align2procSym(proc1,newdata)
## compare alignment for one specimen to Proc. registration using all data
## Not run: 
deformGrid3d(newalign[,,1],proc$orpdata[,,61])

## End(Not run)
</code></pre>

<hr>
<h2 id='angle.calc'>calculate angle between two vectors</h2><span id='topic+angle.calc'></span>

<h3>Description</h3>

<p>calculates unsigned angle between two vectors
</p>


<h3>Usage</h3>

<pre><code class='language-R'>angle.calc(x, y)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="angle.calc_+3A_x">x</code></td>
<td>
<p>numeric vector (or matrix to be interpreted as vector)</p>
</td></tr>
<tr><td><code id="angle.calc_+3A_y">y</code></td>
<td>
<p>numeric vector (or matrix to be interpreted as vector) of same
length as <code>x</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>angle between x and y in radians.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#calculate angle between two centered and
# superimposed landmark configuration
data(boneData)
opa &lt;- rotonto(boneLM[,,1],boneLM[,,2])
angle.calc(opa$X, opa$Y)

</code></pre>

<hr>
<h2 id='angleTest'>Test whether the direction of two vectors is similar</h2><span id='topic+angleTest'></span>

<h3>Description</h3>

<p>Test whether the direction of two vectors is similar
</p>


<h3>Usage</h3>

<pre><code class='language-R'>angleTest(x, y)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="angleTest_+3A_x">x</code></td>
<td>
<p>vector</p>
</td></tr>
<tr><td><code id="angleTest_+3A_y">y</code></td>
<td>
<p>vector</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Under the assumption of all (normalized) n-vectors being represented by an n-dimensional hypersphere, the probability of the angle between two vectors is &lt;= the measured values can be estimated as the area of a cap defined by that angle and divided by the hypersphere's complete surface area.
</p>


<h3>Value</h3>

<p>a list with
</p>
<table role = "presentation">
<tr><td><code>angle</code></td>
<td>
<p>angle between vectors</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>p-value for the probability that the angle between two random vectors is smaller or equal to the one calculatted from x and y</p>
</td></tr>
</table>


<h3>References</h3>

<p>S. Li , 2011. Concise Formulas for the Area and Volume of a Hyperspherical Cap. Asian Journal of Mathematics &amp; Statistics, 4: 66-70.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- c(1,0); y &lt;- c(1,1) # for a circle this should give us p = 0.25 as the angle between vectors
##  is pi/4 and for any vector the segment +-pi/4 covers a quarter of the circle 
angleTest(x,y)
</code></pre>

<hr>
<h2 id='anonymize'>Replace ID-strings of data and associated files.</h2><span id='topic+anonymize'></span>

<h3>Description</h3>

<p>Replace ID-strings with for digits - e.g. for blind observer error testing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>anonymize(
  data,
  remove,
  path = NULL,
  dest.path = NULL,
  ext = ".ply",
  split = "_",
  levels = TRUE,
  prefix = NULL,
  suffix = NULL,
  sample = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="anonymize_+3A_data">data</code></td>
<td>
<p>Named array, matrix or vector containing data.</p>
</td></tr>
<tr><td><code id="anonymize_+3A_remove">remove</code></td>
<td>
<p>integer: which entry (separated by <code>split</code>) of the name
is to be removed</p>
</td></tr>
<tr><td><code id="anonymize_+3A_path">path</code></td>
<td>
<p>Path of associated files to be copied to renamed versions.</p>
</td></tr>
<tr><td><code id="anonymize_+3A_dest.path">dest.path</code></td>
<td>
<p>where to put renamed files.</p>
</td></tr>
<tr><td><code id="anonymize_+3A_ext">ext</code></td>
<td>
<p>file extension of files to be renamed.</p>
</td></tr>
<tr><td><code id="anonymize_+3A_split">split</code></td>
<td>
<p>character: by which to split specimen-ID</p>
</td></tr>
<tr><td><code id="anonymize_+3A_levels">levels</code></td>
<td>
<p>logical: if a removed entry is to be treated as a factor. E.g.
if one specimen has a double entry, the anonymized versions will be named
accordingly.</p>
</td></tr>
<tr><td><code id="anonymize_+3A_prefix">prefix</code></td>
<td>
<p>character: prefix before the alias string.</p>
</td></tr>
<tr><td><code id="anonymize_+3A_suffix">suffix</code></td>
<td>
<p>character: suffix after the alias ID-string.</p>
</td></tr>
<tr><td><code id="anonymize_+3A_sample">sample</code></td>
<td>
<p>logical: whether to randomize alias ID-string.</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>data</code></td>
<td>
<p>data with names replaced</p>
</td></tr>
<tr><td><code>anonymkey</code></td>
<td>
<p>map of original name and replaced name</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
anonymize(iris,remove=1)


</code></pre>

<hr>
<h2 id='applyTransform'>apply affine transformation to data</h2><span id='topic+applyTransform'></span><span id='topic+applyTransform.matrix'></span><span id='topic+applyTransform.mesh3d'></span><span id='topic+applyTransform.default'></span>

<h3>Description</h3>

<p>apply affine transformation to data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>applyTransform(x, trafo, ...)

## S3 method for class 'matrix'
applyTransform(x, trafo, inverse = FALSE, threads = 1, ...)

## S3 method for class 'mesh3d'
applyTransform(x, trafo, inverse = FALSE, threads = 1, ...)

## Default S3 method:
applyTransform(x, trafo, inverse = FALSE, threads = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="applyTransform_+3A_x">x</code></td>
<td>
<p>matrix or mesh3d</p>
</td></tr>
<tr><td><code id="applyTransform_+3A_trafo">trafo</code></td>
<td>
<p>4x4 transformation matrix or an object of class &quot;tpsCoeff&quot;</p>
</td></tr>
<tr><td><code id="applyTransform_+3A_...">...</code></td>
<td>
<p>additional arguments, currently not used.</p>
</td></tr>
<tr><td><code id="applyTransform_+3A_inverse">inverse</code></td>
<td>
<p>logical: if TRUE, the inverse of the transformation is applied (for TPS coefficients have to be recomputed)</p>
</td></tr>
<tr><td><code id="applyTransform_+3A_threads">threads</code></td>
<td>
<p>threads to be used for parallel execution in tps deformation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the transformed object
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rotonto">rotonto</a>, link{rotmesh.onto}, <a href="#topic+tps3d">tps3d</a>, <a href="#topic+computeTransform">computeTransform</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(boneData)
rot &lt;- rotonto(boneLM[,,1],boneLM[,,2])
trafo &lt;- getTrafo4x4(rot)
boneLM2trafo &lt;- applyTransform(boneLM[,,2],trafo)
</code></pre>

<hr>
<h2 id='areaSphere'>compute the area of an n-dimensional hypersphere</h2><span id='topic+areaSphere'></span>

<h3>Description</h3>

<p>compute the area of an n-dimensional hypersphere
</p>


<h3>Usage</h3>

<pre><code class='language-R'>areaSphere(n, r = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="areaSphere_+3A_n">n</code></td>
<td>
<p>dimensionality of space the hypersphere is embedded in (e.g.3 for a 3D-sphere)</p>
</td></tr>
<tr><td><code id="areaSphere_+3A_r">r</code></td>
<td>
<p>radius of the sphere</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns the area
</p>


<h3>Examples</h3>

<pre><code class='language-R'>areaSphere(2) #gives us the circumference of a circle of radius 1
</code></pre>

<hr>
<h2 id='areaSpherePart'>compute the area of an n-dimensional hypersphere cap</h2><span id='topic+areaSpherePart'></span>

<h3>Description</h3>

<p>compute the area of an n-dimensional hypersphere cap
</p>


<h3>Usage</h3>

<pre><code class='language-R'>areaSpherePart(n, phi, r = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="areaSpherePart_+3A_n">n</code></td>
<td>
<p>dimensionality of space the hypersphere is embedded in (e.g.3 for a 3D-sphere)</p>
</td></tr>
<tr><td><code id="areaSpherePart_+3A_phi">phi</code></td>
<td>
<p>angle between vectors defining the cone</p>
</td></tr>
<tr><td><code id="areaSpherePart_+3A_r">r</code></td>
<td>
<p>radius of the sphere</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns the area of the hypersphere cap
</p>


<h3>Examples</h3>

<pre><code class='language-R'>areaSpherePart(2,pi/2) # covers half the area of a circle
</code></pre>

<hr>
<h2 id='armaGinv'>calculate Pseudo-inverse of a Matrix using RcppArmadillo</h2><span id='topic+armaGinv'></span>

<h3>Description</h3>

<p>a simple wrapper to call Armadillo's pinv function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>armaGinv(x, tol = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="armaGinv_+3A_x">x</code></td>
<td>
<p>numeric matrix</p>
</td></tr>
<tr><td><code id="armaGinv_+3A_tol">tol</code></td>
<td>
<p>numeric: maximum singular value to be considered</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Pseudo-inverse
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mat &lt;- matrix(rnorm(12),3,4)
pinvmat &lt;- armaGinv(mat)
</code></pre>

<hr>
<h2 id='array2list'>reverts list2array, converting an array to a list of matrices</h2><span id='topic+array2list'></span>

<h3>Description</h3>

<p>reverts list2array, converting an array to a list of matrices
</p>


<h3>Usage</h3>

<pre><code class='language-R'>array2list(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="array2list_+3A_x">x</code></td>
<td>
<p>array</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns a list containing the matrices
</p>

<hr>
<h2 id='arrMean3'>calculate mean of an array</h2><span id='topic+arrMean3'></span>

<h3>Description</h3>

<p>calculate mean of a 3D-array (e.g. containing landmarks) (fast) using the Armadillo C++ Backend
</p>


<h3>Usage</h3>

<pre><code class='language-R'>arrMean3(arr)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="arrMean3_+3A_arr">arr</code></td>
<td>
<p><code>k x m x n</code> dimensional numeric array</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix of dimensions <code>k x m</code>.
</p>


<h3>Note</h3>

<p>this is the same as <code>apply(arr, 1:2, mean)</code>, only faster for large configurations.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(boneData)
proc &lt;- ProcGPA(boneLM, silent = TRUE)
mshape &lt;- arrMean3(proc$rotated)
</code></pre>

<hr>
<h2 id='asymPermute'>Assess differences in amount and direction of asymmetric variation (only object symmetry)</h2><span id='topic+asymPermute'></span>

<h3>Description</h3>

<p>Assess differences in amount and direction of asymmetric variation (only object symmetry)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>asymPermute(x, groups, rounds = 1000, which = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="asymPermute_+3A_x">x</code></td>
<td>
<p>object of class symproc result from calling <code><a href="#topic+procSym">procSym</a></code> with <code>pairedLM</code> specified</p>
</td></tr>
<tr><td><code id="asymPermute_+3A_groups">groups</code></td>
<td>
<p>factors determining grouping.</p>
</td></tr>
<tr><td><code id="asymPermute_+3A_rounds">rounds</code></td>
<td>
<p>number of permutations</p>
</td></tr>
<tr><td><code id="asymPermute_+3A_which">which</code></td>
<td>
<p>select which factorlevels to use, if NULL, all pairwise differences will be assessed after shuffling pooled data.</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>dist</code></td>
<td>
<p>difference between vector lengths of group means</p>
</td></tr>
<tr><td><code>angle</code></td>
<td>
<p>angle (in radians) between vectors of group specific asymmetric deviation</p>
</td></tr>
<tr><td><code>means</code></td>
<td>
<p>actual group averages</p>
</td></tr>
<tr><td><code>p.dist</code></td>
<td>
<p>p-value obtained by comparing the actual distance to randomly acquired distances</p>
</td></tr>
<tr><td><code>p.angle</code></td>
<td>
<p>p-value obtained by comparing the actual angle to randomly acquired angles</p>
</td></tr>
<tr><td><code>permudist</code></td>
<td>
<p>vector containing differences between random group means' vector lenghts</p>
</td></tr>
<tr><td><code>permuangle</code></td>
<td>
<p>vector containing angles between random group means' vectors</p>
</td></tr>
<tr><td><code>groupmeans</code></td>
<td>
<p> array with asymmetric displacement per group</p>
</td></tr>
<tr><td><code>levels</code></td>
<td>
<p> character vector containing the factors used</p>
</td></tr>
</table>


<h3>Note</h3>

<p>This test is only sensible if between-group differences concerning directional asymmetry have been established (e.g. by applying a MANOVA on the &quot;asymmetric&quot; PCscores (see also <code><a href="#topic+procSym">procSym</a></code>) and one wants to test whether these can be attributed to differences in amount and/or direction of asymmetric displacement. Careful interpretation for very small amounts of directional asymmetry is advised. The Null-Hypothesis is that we have the same directional asymmetry in both groups. If you want to test whether the angle between groups is similar, please use <code><a href="#topic+angleTest">angleTest</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+procSym">procSym</a></code>
</p>

<hr>
<h2 id='barycenter'>calculates the barycenters for all faces of a triangular mesh</h2><span id='topic+barycenter'></span>

<h3>Description</h3>

<p>calculates the barycenters for all faces of a triangular mesh
</p>


<h3>Usage</h3>

<pre><code class='language-R'>barycenter(mesh)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="barycenter_+3A_mesh">mesh</code></td>
<td>
<p>triangular mesh of class 'mesh3d'</p>
</td></tr>
</table>


<h3>Value</h3>

<p>k x 3 matrix of barycenters for all <code>k</code> faces of input mesh.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+closemeshKD">closemeshKD</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

data(nose)
bary &lt;- barycenter(shortnose.mesh)
## Not run: 
require(rgl)
##visualize mesh
wire3d(shortnose.mesh)
# visualize barycenters
points3d(bary, col=2)
## now each triangle is equipped with a point in its barycenter

## End(Not run)
</code></pre>

<hr>
<h2 id='bindArr'>concatenate multiple arrays/matrices</h2><span id='topic+bindArr'></span>

<h3>Description</h3>

<p>concatenate multiple 3-dimensional arrays and/or 2-dimensional matrices to
one big array
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bindArr(..., along = 1, collapse = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bindArr_+3A_...">...</code></td>
<td>
<p>matrices and/or arrays with appropriate dimensionality to
combine to one array, or a single list containing suitable matrices, or arrays).</p>
</td></tr>
<tr><td><code id="bindArr_+3A_along">along</code></td>
<td>
<p>dimension along which to concatenate.</p>
</td></tr>
<tr><td><code id="bindArr_+3A_collapse">collapse</code></td>
<td>
<p>logical: if the resulting array is shallow (only 1 dimension deep), it is converted to a matrix.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>dimnames, if present and if differing between entries, will be concatenated, separated by a &quot;_&quot;.
</p>


<h3>Value</h3>

<p>returns array of combined matrices/arrays
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+cbind">cbind</a></code>, <code><a href="base.html#topic+rbind">rbind</a></code>, <code><a href="base.html#topic+array">array</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
A &lt;- matrix(rnorm(18),6,3)
B &lt;- matrix(rnorm(18),6,3)
C &lt;- matrix(rnorm(18),6,3)

#combine to 3D-array
newArr &lt;- bindArr(A,B,C,along=3)
#combine along first dimension
newArr2 &lt;- bindArr(newArr,newArr,along=1)



</code></pre>

<hr>
<h2 id='boneData'>Landmarks and a triangular mesh</h2><span id='topic+boneData'></span><span id='topic+boneLM'></span><span id='topic+skull_0144_ch_fe.mesh'></span>

<h3>Description</h3>

<p>Landmarks on the osseous human nose and a triangular mesh representing this
structure.
</p>


<h3>Format</h3>

<p><code>boneLM</code>: A 10x3x80 array containing 80 sets of 3D-landmarks
placed on the human osseous nose.
</p>
<p><code>skull_0144_ch_fe.mesh</code>: The mesh representing the area of the first
individual of <code>boneLM</code>
</p>

<hr>
<h2 id='CAC'>calculate common allometric component</h2><span id='topic+CAC'></span>

<h3>Description</h3>

<p>calculate common allometric component
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CAC(x, size, groups = NULL, log = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CAC_+3A_x">x</code></td>
<td>
<p>datamatrix (e.g. with PC-scores) or 3D-array with landmark coordinates</p>
</td></tr>
<tr><td><code id="CAC_+3A_size">size</code></td>
<td>
<p>vector with Centroid sizes</p>
</td></tr>
<tr><td><code id="CAC_+3A_groups">groups</code></td>
<td>
<p>grouping variable</p>
</td></tr>
<tr><td><code id="CAC_+3A_log">log</code></td>
<td>
<p>logical: use <code>log(size)</code></p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>CACscores</code></td>
<td>
<p>common allometric component scores</p>
</td></tr>
<tr><td><code>CAC</code></td>
<td>
<p>common allometric component</p>
</td></tr>
<tr><td><code>x</code></td>
<td>
<p>(group-) centered data</p>
</td></tr>
<tr><td><code>sc</code></td>
<td>
<p>CAC reprojected into original space by applying <code>CAC %*% x</code></p>
</td></tr>
<tr><td><code>RSCscores</code></td>
<td>
<p>residual shape component scores</p>
</td></tr>
<tr><td><code>RSC</code></td>
<td>
<p>residual shape components</p>
</td></tr>
<tr><td><code>gmeans</code></td>
<td>
<p>groupmeans</p>
</td></tr>
<tr><td><code>CS</code></td>
<td>
<p>the centroid sizes (log transformed if <code>log = TRUE</code>)</p>
</td></tr>
</table>


<h3>References</h3>

<p>Mitteroecker P, Gunz P, Bernhard M, Schaefer K, Bookstein FL. 2004. Comparison of cranial ontogenetic trajectories among great apes and humans. Journal of Human Evolution 46(6):679-97.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(boneData)
proc &lt;- procSym(boneLM)
pop.sex &lt;- name2factor(boneLM,which=3:4)
cac &lt;- CAC(proc$rotated,proc$size,pop.sex)
plot(cac$CACscores,cac$size)#plot scores against Centroid size
cor.test(cac$CACscores,cac$size)#check for correlation
#visualize differences between large and small on the sample's consensus
## Not run: 
large &lt;- restoreShapes(max(cac$CACscores),cac$CAC,proc$mshape)
small &lt;- restoreShapes(min(cac$CACscores),cac$CAC,proc$mshape)
deformGrid3d(small,large,ngrid=0)

## End(Not run)
</code></pre>

<hr>
<h2 id='cExtract'>extract information about fixed landmarks, curves and patches from and atlas
generated by &quot;landmark&quot;</h2><span id='topic+cExtract'></span>

<h3>Description</h3>

<p>After exporting the pts file of the atlas from &quot;landmark&quot; and importing it
into R via &quot;read.pts&quot; cExtract gets information which rows of the landmark
datasets belong to curves or patches.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cExtract(pts.file)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cExtract_+3A_pts.file">pts.file</code></td>
<td>
<p>either a character naming the path to a pts.file or the name
of an object imported via read.pts.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns a list containing the vectors with the indices of matrix
rows belonging to the in &quot;landmark&quot; defined curves, patches and fix
landmarks and a matrix containing landmark coordinates.
</p>


<h3>Author(s)</h3>

<p>Stefan Schlager
</p>


<h3>See Also</h3>

<p><code><a href="#topic+read.lmdta">read.lmdta</a></code> ,<code><a href="#topic+read.pts">read.pts</a></code>
</p>

<hr>
<h2 id='checkLM'>Visually browse through a sample rendering its landmarks and corresponding
surfaces.</h2><span id='topic+checkLM'></span>

<h3>Description</h3>

<p>Browse through a sample rendering its landmarks and corresponding surfaces.
This is handy e.g. to check if the landmark projection using placePatch was
successful, and to mark specific specimen.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>checkLM(
  dat.array,
  path = NULL,
  prefix = "",
  suffix = ".ply",
  col = "white",
  pt.size = NULL,
  alpha = 1,
  begin = 1,
  render = c("w", "s"),
  point = c("s", "p"),
  add = FALSE,
  meshlist = NULL,
  Rdata = FALSE,
  atlas = NULL,
  text.lm = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="checkLM_+3A_dat.array">dat.array</code></td>
<td>
<p>array or list containing landmark coordinates.</p>
</td></tr>
<tr><td><code id="checkLM_+3A_path">path</code></td>
<td>
<p>optional character: path to files where surface meshes are
stored locally. If not specified only landmarks are displayed.</p>
</td></tr>
<tr><td><code id="checkLM_+3A_prefix">prefix</code></td>
<td>
<p>prefix to attach to the filenames extracted from
<code>dimnames(dat.array)[[3]]</code> (in case of an array), or
<code>names(dat.array)</code> (in case of a list)</p>
</td></tr>
<tr><td><code id="checkLM_+3A_suffix">suffix</code></td>
<td>
<p>suffix to attach to the filenames extracted from
<code>dimnames(dat.array)[[3]]</code> (in case of an array), or
<code>names(dat.array)</code> (in case of a list)</p>
</td></tr>
<tr><td><code id="checkLM_+3A_col">col</code></td>
<td>
<p>mesh color</p>
</td></tr>
<tr><td><code id="checkLM_+3A_pt.size">pt.size</code></td>
<td>
<p>size of plotted points/spheres. If <code>point="s"</code>.
<code>pt.size</code> defines the radius of the spheres. If <code>point="p"</code> it
sets the variable <code>size</code> used in <code>point3d</code>.</p>
</td></tr>
<tr><td><code id="checkLM_+3A_alpha">alpha</code></td>
<td>
<p>value between 0 and 1. Sets transparency of mesh 1=opaque 0=
fully transparent.</p>
</td></tr>
<tr><td><code id="checkLM_+3A_begin">begin</code></td>
<td>
<p>integer: select a specimen to start with.</p>
</td></tr>
<tr><td><code id="checkLM_+3A_render">render</code></td>
<td>
<p>if render=&quot;w&quot;, a wireframe will be drawn, else the meshes will
be shaded.</p>
</td></tr>
<tr><td><code id="checkLM_+3A_point">point</code></td>
<td>
<p>how to render landmarks. &quot;s&quot;=spheres, &quot;p&quot;=points.</p>
</td></tr>
<tr><td><code id="checkLM_+3A_add">add</code></td>
<td>
<p>logical: add to existing rgl window.</p>
</td></tr>
<tr><td><code id="checkLM_+3A_meshlist">meshlist</code></td>
<td>
<p>list holding meshes in the same order as <code>dat.array</code> (Overrides <code>path</code>).</p>
</td></tr>
<tr><td><code id="checkLM_+3A_rdata">Rdata</code></td>
<td>
<p>logical: if the meshes are previously stored as Rdata-files by
calling save(), these are simply loaded and rendered. Otherwise it is
assumed that the meshes are stored in standard file formats such as PLY, STL
or OBJ, that are then imported with the function <code><a href="#topic+file2mesh">file2mesh</a></code>.</p>
</td></tr>
<tr><td><code id="checkLM_+3A_atlas">atlas</code></td>
<td>
<p>provide object generated by <code><a href="#topic+createAtlas">createAtlas</a></code> to
specify coloring of surface patches, curves and landmarks</p>
</td></tr>
<tr><td><code id="checkLM_+3A_text.lm">text.lm</code></td>
<td>
<p>logical: number landmarks. Only applicable when
<code>atlas=NULL</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns an invisible vector of indices of marked specimen.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+placePatch">placePatch</a>, <a href="#topic+createAtlas">createAtlas</a>, <a href="#topic+plotAtlas">plotAtlas</a>,
<a href="#topic+file2mesh">file2mesh</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(nose)
###create mesh for longnose
longnose.mesh &lt;- tps3d(shortnose.mesh,shortnose.lm,longnose.lm,threads=1)
### write meshes to disk
save(shortnose.mesh, file="shortnose")
save(longnose.mesh, file="longnose")

## create landmark array
data &lt;- bindArr(shortnose.lm, longnose.lm, along=3)
dimnames(data)[[3]] &lt;- c("shortnose", "longnose")
## Not run: 
checkLM(data, path="./",Rdata=TRUE, suffix="")

## End(Not run)

## now visualize by using an atlas:
atlas &lt;- createAtlas(shortnose.mesh, landmarks =
           shortnose.lm[c(1:5,20:21),],
patch=shortnose.lm[-c(1:5,20:21),])
if (interactive()){
checkLM(data, path="./",Rdata=TRUE, suffix="", atlas=atlas)
}
## remove data from disk
unlink("shortnose")
unlink("longnose")

</code></pre>

<hr>
<h2 id='checkNA'>check for NA values in a matrix (of landmarks)</h2><span id='topic+checkNA'></span>

<h3>Description</h3>

<p>check for NA values in a matrix (of landmarks)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>checkNA(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="checkNA_+3A_x">x</code></td>
<td>
<p>matrix containing landmarks</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns a vector with missin landmarks and a vector of length=0 if none are missing
</p>

<hr>
<h2 id='classify'>classify specimen based on between-group PCA or CVA or typprobClass</h2><span id='topic+classify'></span><span id='topic+classify.bgPCA'></span><span id='topic+classify.CVA'></span><span id='topic+classify.typprob'></span>

<h3>Description</h3>

<p>classify specimen based on between-group PCA, CVA or typprobClass
</p>


<h3>Usage</h3>

<pre><code class='language-R'>classify(x, cv = TRUE, ...)

## S3 method for class 'bgPCA'
classify(x, cv = TRUE, newdata = NULL, ...)

## S3 method for class 'CVA'
classify(x, cv = T, newdata = NULL, prior = NULL, ...)

## S3 method for class 'typprob'
classify(x, cv = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="classify_+3A_x">x</code></td>
<td>
<p>result of groupPCA, CVA or typprobClass</p>
</td></tr>
<tr><td><code id="classify_+3A_cv">cv</code></td>
<td>
<p>logical: use cross-validated scores if available</p>
</td></tr>
<tr><td><code id="classify_+3A_...">...</code></td>
<td>
<p>currently not used</p>
</td></tr>
<tr><td><code id="classify_+3A_newdata">newdata</code></td>
<td>
<p>use new data to predict scores and evaluate group affinity</p>
</td></tr>
<tr><td><code id="classify_+3A_prior">prior</code></td>
<td>
<p>specify prior probability for CVA evaluation if NULL prior from CVA will be used. Be <code>m</code> your number of groups then to set the prior equally for all groups set <code>prior=rep(1,m)/m</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>class</code></td>
<td>
<p>classification result</p>
</td></tr>
<tr><td><code>groups</code></td>
<td>
<p>original grouping variable, only available if <code>newdata=NULL</code></p>
</td></tr>
<tr><td><code>posterior</code></td>
<td>
<p>only for object of CVA and typprob, also the posterior probabilities are returned</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+CVA">CVA</a>,<a href="#topic+groupPCA">groupPCA</a>,  <a href="#topic+typprobClass">typprobClass</a></code>
</p>

<hr>
<h2 id='closemeshKD'>Project coordinates onto a target triangular surface mesh.</h2><span id='topic+closemeshKD'></span>

<h3>Description</h3>

<p>For a set of 3D-coordinates the closest matches on a target surface are
determined and normals at as well as distances to that point are calculated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>closemeshKD(
  x,
  mesh,
  k = 50,
  sign = FALSE,
  barycoords = FALSE,
  cores = 1,
  method = 0,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="closemeshKD_+3A_x">x</code></td>
<td>
<p>k x 3 matrix containing 3D-coordinates or object of class
<code>mesh3d</code>.</p>
</td></tr>
<tr><td><code id="closemeshKD_+3A_mesh">mesh</code></td>
<td>
<p>triangular surface mesh stored as object of class <code>mesh3d</code>.</p>
</td></tr>
<tr><td><code id="closemeshKD_+3A_k">k</code></td>
<td>
<p>neighbourhood of kd-tree to search - the larger, the slower - but
the more likely the absolutely closest point is hit.</p>
</td></tr>
<tr><td><code id="closemeshKD_+3A_sign">sign</code></td>
<td>
<p>logical: if TRUE, signed distances are returned.</p>
</td></tr>
<tr><td><code id="closemeshKD_+3A_barycoords">barycoords</code></td>
<td>
<p>logical: if <code>TRUE</code>, barycentric coordinates of the
hit points are returned.</p>
</td></tr>
<tr><td><code id="closemeshKD_+3A_cores">cores</code></td>
<td>
<p>integer: how many cores to use for the search algorithm.</p>
</td></tr>
<tr><td><code id="closemeshKD_+3A_method">method</code></td>
<td>
<p>integer: either 0 or 1, if 0 ordinary Euclidean distance is
used, if 1, the distance suggested by Moshfeghi(1994) is calculated.</p>
</td></tr>
<tr><td><code id="closemeshKD_+3A_...">...</code></td>
<td>
<p>additional arguments. currently unavailable.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The search for the clostest point is designed as follows: Calculate the
barycenter of each target face. For each coordinate of x, determine the k
closest barycenters and calculate the distances to the closest point on
these faces.
</p>


<h3>Value</h3>

<p>returns an object of class <code>mesh3d</code>.  with:
</p>
<table role = "presentation">
<tr><td><code>vb</code></td>
<td>
<p>4xn matrix containing n vertices as homolougous coordinates</p>
</td></tr>
<tr><td><code>normals</code></td>
<td>
<p>4xn matrix containing vertex normals</p>
</td></tr>
<tr><td><code>quality</code></td>
<td>
<p>vector: containing distances to target. In case of <code>method=1</code>, this is not the Euclidean distance but the distance of the reference point to the faceplane (orthogonally projected) plus the distance to the closest point on one of the face's edges (the target point). See the literature cited below for details.</p>
</td></tr>
<tr><td><code>it</code></td>
<td>
<p>4xm matrix containing vertex indices forming triangular faces.Only available, when x is a mesh</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Stefan Schlager
</p>


<h3>References</h3>

<p>Baerentzen, Jakob Andreas. &amp; Aanaes, H., 2002. Generating Signed
Distance Fields From Triangle Meshes. Informatics and Mathematical
Modelling.
</p>
<p>Moshfeghi M, Ranganath S, Nawyn K. 1994. Three-dimensional elastic matching
of volumes IEEE Transactions on Image Processing: A Publication of the IEEE
Signal Processing Society 3:128-138.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ply2mesh">ply2mesh</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(nose)
out &lt;- closemeshKD(longnose.lm,shortnose.mesh,sign=TRUE)
### show distances - they are very small because
###longnose.lm is scaled to unit centroid size.
hist(out$quality)

</code></pre>

<hr>
<h2 id='colors'>predefined colors for bone and skin</h2><span id='topic+colors'></span><span id='topic+bone1'></span><span id='topic+bone2'></span><span id='topic+bone3'></span><span id='topic+skin1'></span><span id='topic+skin2'></span><span id='topic+skin3'></span><span id='topic+skin4'></span>

<h3>Description</h3>

<p>predefined colors for bone and skin
</p>


<h3>Details</h3>

<p>available colors are:
</p>
<p>bone1
</p>
<p>bone2
</p>
<p>bone3
</p>
<p>skin1
</p>
<p>skin2
</p>
<p>skin3
</p>
<p>skin4
</p>

<hr>
<h2 id='computeArea'>Compute area enclosed within an irregular polygon</h2><span id='topic+computeArea'></span>

<h3>Description</h3>

<p>Compute area enclosed within an irregular polygon - i.e. defined by curves
</p>


<h3>Usage</h3>

<pre><code class='language-R'>computeArea(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="computeArea_+3A_x">x</code></td>
<td>
<p>k x 2 or k x 3 matrix containing ordered coordinates forming the boundary of the area. For 3D-cases, the area should be closed to a 2D surface (see details below).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For 3D coordinates, a PCA is computed and only the first two PCs are used to compute the area. This is a projection of the coordinates onto a 2D plane spanned by those PCs.
</p>


<h3>Value</h3>

<p>returns a list containing
</p>
<table role = "presentation">
<tr><td><code>area</code></td>
<td>
<p>size of the enclosed area</p>
</td></tr>
<tr><td><code>xpro2D</code></td>
<td>
<p>projected coordinates of x in the 2D plane.</p>
</td></tr>
<tr><td><code>poly</code></td>
<td>
<p>object of class <code>sp</code> as defined by the <code>sp</code> package.</p>
</td></tr>
<tr><td><code>xpro3D</code></td>
<td>
<p>For 3D-cases, this contains the projected coordinates of x rotated back into the original coordinate system</p>
</td></tr>
</table>


<h3>Note</h3>

<p>in case custom planes are preferred, the data can first be projected onto such a custom defined plane via <code><a href="#topic+points2plane">points2plane</a></code> first.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(shapes)
require(sf)
myarea &lt;- computeArea(gorf.dat[c(1,6:8,2:5),,1])
myarea$area
plot(myarea$poly)


## 3D example
data(boneData)
myarea3D &lt;- computeArea(boneLM[c(4,2,3,7,5,6,8),,1])
plot(myarea3D$poly)
cent &lt;- colMeans(myarea3D$xpro2D)
text(cent[1],cent[2],labels=paste0("Area=",round(myarea3D$area,digits=2)))
</code></pre>

<hr>
<h2 id='computeTransform'>calculate an affine transformation matrix</h2><span id='topic+computeTransform'></span>

<h3>Description</h3>

<p>calculate an affine transformation matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>computeTransform(
  x,
  y,
  type = c("rigid", "similarity", "affine", "tps"),
  reflection = FALSE,
  lambda = 1e-08,
  weights = NULL,
  centerweight = FALSE,
  threads = 1
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="computeTransform_+3A_x">x</code></td>
<td>
<p>fix landmarks. Can be a k x m matrix or mesh3d.</p>
</td></tr>
<tr><td><code id="computeTransform_+3A_y">y</code></td>
<td>
<p>moving landmarks. Can be a k x m matrix or mesh3d.</p>
</td></tr>
<tr><td><code id="computeTransform_+3A_type">type</code></td>
<td>
<p>set type of affine transformation: options are  &quot;rigid&quot;, &quot;similarity&quot; (rigid + scale) and &quot;affine&quot;,</p>
</td></tr>
<tr><td><code id="computeTransform_+3A_reflection">reflection</code></td>
<td>
<p>logical: if TRUE &quot;rigid&quot; and &quot;similarity&quot; allow reflections.</p>
</td></tr>
<tr><td><code id="computeTransform_+3A_lambda">lambda</code></td>
<td>
<p>numeric: regularisation parameter of the TPS.</p>
</td></tr>
<tr><td><code id="computeTransform_+3A_weights">weights</code></td>
<td>
<p>vector of length k, containing weights for each landmark (only used in type=&quot;rigid&quot; or &quot;similarity&quot;).</p>
</td></tr>
<tr><td><code id="computeTransform_+3A_centerweight">centerweight</code></td>
<td>
<p>logical or vector of weights: if weights are defined and
centerweigths=TRUE, the matrix will be centered according to these weights instead of the
barycenter. If centerweight is a vector of length <code>nrow(x)</code>, the barycenter will be weighted accordingly.</p>
</td></tr>
<tr><td><code id="computeTransform_+3A_threads">threads</code></td>
<td>
<p>number of threads to use in TPS interpolation.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>x</code> and <code>y</code> can also be a pair of meshes with corresponding vertices.
</p>


<h3>Value</h3>

<p>returns a 4x4 (3x3 in 2D case)  transformation matrix or an object of class &quot;tpsCoeff&quot; in case of type=&quot;tps&quot;.
</p>


<h3>Note</h3>

<p>all lines containing NA, or NaN are ignored in computing the transformation.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rotonto">rotonto</a>, link{rotmesh.onto}, <a href="#topic+tps3d">tps3d</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(boneData)
trafo &lt;- computeTransform(boneLM[,,1],boneLM[,,2])
transLM &lt;- applyTransform(boneLM[,,2],trafo)
</code></pre>

<hr>
<h2 id='covDist'>calculates distances and PC-coordinates of covariance matrices</h2><span id='topic+covDist'></span><span id='topic+covPCA'></span>

<h3>Description</h3>

<p>calculates PC-coordinates of covariance matrices by using the Riemannian
metric in their respective space.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>covDist(s1, s2)

covPCA(
  data,
  groups,
  rounds = 1000,
  bootrounds = 0,
  lower.bound = 0.05,
  upper.bound = 0.95
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="covDist_+3A_s1">s1</code></td>
<td>
<p>m x m covariance matrix</p>
</td></tr>
<tr><td><code id="covDist_+3A_s2">s2</code></td>
<td>
<p>m x m covariance matrix</p>
</td></tr>
<tr><td><code id="covDist_+3A_data">data</code></td>
<td>
<p>matrix containing data with one row per observation</p>
</td></tr>
<tr><td><code id="covDist_+3A_groups">groups</code></td>
<td>
<p>factor: group assignment for each specimen</p>
</td></tr>
<tr><td><code id="covDist_+3A_rounds">rounds</code></td>
<td>
<p>integer: rounds to run permutation of distances by randomly assigning group membership</p>
</td></tr>
<tr><td><code id="covDist_+3A_bootrounds">bootrounds</code></td>
<td>
<p>integer: perform bootstrapping to generate confidence intervals  (lower boundary, median and upper boundary) for PC-scores.</p>
</td></tr>
<tr><td><code id="covDist_+3A_lower.bound">lower.bound</code></td>
<td>
<p>numeric: set probability (quantile) for lower boundary estimate from bootstrapping.</p>
</td></tr>
<tr><td><code id="covDist_+3A_upper.bound">upper.bound</code></td>
<td>
<p>numeric: set probability (quantile) for upper boundary estimate from bootstrapping.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>covDist</code> calculates the Distance between covariance matrices while <code>covPCA</code> uses a MDS (multidimensional scaling) approach to obtain PC-coordinates
from a  distance matrix derived from multiple groups. P-values for pairwise
distances can be computed by permuting group membership and comparing actual
distances to those obtained from random resampling. To calculate confidence intervals for PC-scores, within-group bootstrapping can be performed.
</p>


<h3>Value</h3>

<p><code>covDist</code> returns the distance between s1 and s2
</p>
<p><code>covPCA</code> returns a list containing:
</p>
<p>if <code>scores = TRUE</code>
</p>
<table role = "presentation">
<tr><td><code>PCscores</code></td>
<td>
<p>PCscores</p>
</td></tr>
<tr><td><code>eigen</code></td>
<td>
<p>eigen decomposition of the centered inner product</p>
</td></tr>
</table>
<p>if <code>rounds &gt; 0</code>
</p>
<table role = "presentation">
<tr><td><code>dist</code></td>
<td>
<p>distance matrix</p>
</td></tr>
<tr><td><code>p.matrix</code></td>
<td>
<p>p-values for pairwise distances from permutation testing</p>
</td></tr>
</table>
<p>if <code>bootrounds &gt; 0</code>
</p>
<table role = "presentation">
<tr><td><code>bootstrap</code></td>
<td>
<p>list containing the lower and upper bound of the confidence intervals of PC-scores as well as the median of bootstrapped values.</p>
</td></tr>
<tr><td><code>boot.data</code></td>
<td>
<p>array containing all results generated from bootstrapping.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Stefan Schlager
</p>


<h3>References</h3>

<p>Mitteroecker P, Bookstein F. 2009. The ontogenetic trajectory of
the phenotypic covariance matrix, with examples from craniofacial shape in
rats and humans. Evolution 63:727-737.
</p>
<p>Hastie T, Tibshirani R, Friedman JJH.  2013. The elements of statistical
learning. Springer New York.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+prcomp">prcomp</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

cpca &lt;- covPCA(iris[,1:4],iris[,5])
cpca$p.matrix #show pairwise p-values for equal covariance matrices
## Not run: 
require(car)
sp(cpca$PCscores[,1],cpca$PCscores[,2],groups=levels(iris[,5]),
   smooth=FALSE,xlim=range(cpca$PCscores),ylim=range(cpca$PCscores))

data(boneData)
proc &lt;- procSym(boneLM)
pop &lt;- name2factor(boneLM, which=3)
## compare covariance matrices for PCscores of Procrustes fitted data
cpca1 &lt;- covPCA(proc$PCscores, groups=pop, rounds = 1000)
## view p-values:
cpca1$p.matrix # differences between covariance matrices
# are significant
## visualize covariance ellipses of first 5 PCs of shape
spm(proc$PCscores[,1:5], groups=pop, smooth=FALSE,ellipse=TRUE, by.groups=TRUE)
## covariance seems to differ between 1st and 5th PC
## for demonstration purposes, try only first 4 PCs
cpca2 &lt;- covPCA(proc$PCscores[,1:4], groups=pop, rounds = 1000)
## view p-values:
cpca2$p.matrix # significance is gone

## End(Not run)

#do some bootstrapping 1000 rounds
cpca &lt;- covPCA(iris[,1:4],iris[,5],rounds=0, bootrounds=1000)
#plot bootstrapped data of PC1 and PC2 for first group
plot(t(cpca$boot.data[1,1:2,]),xlim=range(cpca$boot.data[,1,]),
                               ylim=range(cpca$boot.data[,2,]))
points(t(cpca$PCscores[1,]),col="white",pch=8,cex=1.5)##plot actual values
                      
for (i in 2:3) {
  points(t(cpca$boot.data[i,1:2,]),col=i)##plot other groups
  points(t(cpca$PCscores[i,]),col=1,pch=8,cex=1.5)##plot actual values
}


</code></pre>

<hr>
<h2 id='covW'>calculate the pooled within groups covariance matrix</h2><span id='topic+covW'></span>

<h3>Description</h3>

<p>calculate the pooled within groups covariance matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>covW(data, groups, robust = c("classical", "mve", "mcd"), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="covW_+3A_data">data</code></td>
<td>
<p>a matrix containing data</p>
</td></tr>
<tr><td><code id="covW_+3A_groups">groups</code></td>
<td>
<p>grouping variables</p>
</td></tr>
<tr><td><code id="covW_+3A_robust">robust</code></td>
<td>
<p>character: determines covariance estimation methods in case <code>sep=TRUE</code>, when covariance matrices and group means can be estimated robustly using <code>MASS::cov.rob</code>. Default is the standard product-moment covariance matrix.</p>
</td></tr>
<tr><td><code id="covW_+3A_...">...</code></td>
<td>
<p>additional parameters passed to <code>MASS::cov.rob</code> for robust covariance and mean estimations.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the pooled within group covariance matrix. The attributes contain the entry means, containing the respective group means.
</p>


<h3>Author(s)</h3>

<p>Stefan Schlager
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+cov">cov</a></code>, <code><a href="#topic+typprobClass">typprobClass</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(iris)
poolCov &lt;- covW(iris[,1:4],iris[,5])
</code></pre>

<hr>
<h2 id='createAtlas'>Create an atlas needed in placePatch</h2><span id='topic+createAtlas'></span>

<h3>Description</h3>

<p>Create an atlas needed in placePatch
</p>


<h3>Usage</h3>

<pre><code class='language-R'>createAtlas(
  mesh,
  landmarks,
  patch,
  corrCurves = NULL,
  patchCurves = NULL,
  keep.fix = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="createAtlas_+3A_mesh">mesh</code></td>
<td>
<p>triangular mesh representing the atlas' surface</p>
</td></tr>
<tr><td><code id="createAtlas_+3A_landmarks">landmarks</code></td>
<td>
<p>matrix containing landmarks defined on the atlas, as well
as on each specimen in the corresponding sample.</p>
</td></tr>
<tr><td><code id="createAtlas_+3A_patch">patch</code></td>
<td>
<p>matrix containing semi-landmarks to be projected onto each
specimen in the corresponding sample.</p>
</td></tr>
<tr><td><code id="createAtlas_+3A_corrcurves">corrCurves</code></td>
<td>
<p>a vector or a list containing vectors specifiyng the rowindices of
<code>landmarks</code> to be curves that are defined on the atlas AND each specimen.
e.g. if landmarks 2:4 and 5:10 are two distinct curves, one would specifiy <code>corrCurves = list(c(2:4), c(5:10))</code>.</p>
</td></tr>
<tr><td><code id="createAtlas_+3A_patchcurves">patchCurves</code></td>
<td>
<p>a vector or a list containing vectors specifiyng the
rowindices of <code>landmarks</code> to be curves that are defined ONLY on the
atlas. E.g. if coordinates 5:10 and 20:40 on the <code>patch</code> are two
distinct curves, one would specifiy <code>patchCurves = list(c(5:10),c(20:40))</code>.</p>
</td></tr>
<tr><td><code id="createAtlas_+3A_keep.fix">keep.fix</code></td>
<td>
<p>in case corrCurves are set, specify explicitly which landmarks are not allowed to slide during projection (with <code>placePatch</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list of class &quot;atlas&quot;.  Its content is corresponding to
argument names.
</p>


<h3>Note</h3>

<p>This is a helper function of <code><a href="#topic+placePatch">placePatch</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+placePatch">placePatch</a>, <a href="#topic+plotAtlas">plotAtlas</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(nose)
atlas &lt;- createAtlas(shortnose.mesh, landmarks =
            shortnose.lm[c(1:5,20:21),], patch=shortnose.lm[-c(1:5,20:21),])

</code></pre>

<hr>
<h2 id='CreateL'>Create Matrices necessary for Thin-Plate Spline</h2><span id='topic+CreateL'></span>

<h3>Description</h3>

<p>Create (Bending Engergy) Matrices necessary for Thin-Plate Spline, and
sliding of Semilandmarks
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CreateL(
  matrix,
  lambda = 1e-08,
  output = c("K", "L", "Linv", "Lsubk", "Lsubk3"),
  threads = 1
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CreateL_+3A_matrix">matrix</code></td>
<td>
<p>k x 3 or k x 2 matrix containing landmark coordinates.</p>
</td></tr>
<tr><td><code id="CreateL_+3A_lambda">lambda</code></td>
<td>
<p>numeric: regularization factor</p>
</td></tr>
<tr><td><code id="CreateL_+3A_output">output</code></td>
<td>
<p>character vector: select which matrices to create. Can be a vector containing any combination of the strings: <code>"K", "L","Linv","Lsubk", "Lsubk3"</code>.</p>
</td></tr>
<tr><td><code id="CreateL_+3A_threads">threads</code></td>
<td>
<p>threads to be used for parallel execution calculating K.
sliding of semilandmarks.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>depending on the choices in <code>output</code>:
</p>
<table role = "presentation">
<tr><td><code>L</code></td>
<td>
<p>Matrix K as specified in Bookstein (1989)</p>
</td></tr>
<tr><td><code>L</code></td>
<td>
<p>Matrix L as specified in Bookstein (1989)</p>
</td></tr>
<tr><td><code>Linv</code></td>
<td>
<p>Inverse of matrix L as specified in Bookstein (1989)</p>
</td></tr>
<tr><td><code>Lsubk</code></td>
<td>
<p>uper left k x k submatrix of <code>Linv</code></p>
</td></tr>
<tr><td><code>Lsubk3</code></td>
<td>
<p>Matrix used for sliding in <code><a href="#topic+slider3d">slider3d</a></code> and <code><a href="#topic+relaxLM">relaxLM</a></code></p>
</td></tr></table>
<p>.
</p>


<h3>Note</h3>

<p>This function is not intended to be called directly - except for
playing around to grasp the mechansims of the Thin-Plate Spline.
</p>


<h3>References</h3>

<p>Gunz, P., P. Mitteroecker, and F. L. Bookstein. 2005.
Semilandmarks in Three Dimensions, in Modern Morphometrics in Physical
Anthropology. Edited by D. E. Slice, pp. 73-98. New York: Kluwer
Academic/Plenum Publishers.
</p>
<p>Bookstein FL. 1989. Principal Warps: Thin-plate splines and the
decomposition of deformations. IEEE Transactions on pattern analysis and
machine intelligence 11(6).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+tps3d">tps3d</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(boneData)
L &lt;- CreateL(boneLM[,,1])
## calculate Bending energy between first and second specimen:
be &lt;- t(boneLM[,,2])%*%L$Lsubk%*%boneLM[,,2]
## calculate Frobenius norm 
sqrt(sum(be^2))
## the amount is dependant on on the squared scaling factor
# scale landmarks by factor 5 and compute bending energy matrix
be2 &lt;- t(boneLM[,,2]*5)%*%L$Lsubk%*%(boneLM[,,2]*5)
sqrt(sum(be2^2)) # exactly 25 times the result from above
## also this value is not symmetric:
L2 &lt;- CreateL(boneLM[,,2])
be3 &lt;- t(boneLM[,,1])%*%L2$Lsubk%*%boneLM[,,1]
sqrt(sum(be3^2))
</code></pre>

<hr>
<h2 id='createMissingList'>create a list with empty entries to be used as missingList in slider3d</h2><span id='topic+createMissingList'></span>

<h3>Description</h3>

<p>create a list with empty entries to be used as missingList in slider3d
</p>


<h3>Usage</h3>

<pre><code class='language-R'>createMissingList(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="createMissingList_+3A_x">x</code></td>
<td>
<p>length of the list to be created</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns a list of length <code>x</code> filled with numerics of length zero.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fixLMtps">fixLMtps</a>,<a href="#topic+fixLMmirror">fixLMmirror</a>, <a href="#topic+slider3d">slider3d</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Assume in a sample of 10, the 9th individual has (semi-)landmarks 10:50
#   hanging in thin air (e.g. estimated using fixLMtps)
#   while the others are complete.
## create empty list
missingList &lt;- createMissingList(10)
missingList[[9]] &lt;- 10:50
</code></pre>

<hr>
<h2 id='crossProduct'>calculate the orthogonal complement of a 3D-vector</h2><span id='topic+crossProduct'></span><span id='topic+tangentPlane'></span>

<h3>Description</h3>

<p>calculate the orthogonal complement of a 3D-vector
</p>


<h3>Usage</h3>

<pre><code class='language-R'>crossProduct(x, y, normalize = TRUE)

tangentPlane(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="crossProduct_+3A_x">x</code></td>
<td>
<p>vector of length 3.</p>
</td></tr>
<tr><td><code id="crossProduct_+3A_y">y</code></td>
<td>
<p>vector of length 3.</p>
</td></tr>
<tr><td><code id="crossProduct_+3A_normalize">normalize</code></td>
<td>
<p>logical: if TRUE, the resulting vector is normalized</p>
</td></tr>
</table>


<h3>Details</h3>

<p>calculate the orthogonal complement of a 3D-vector or the 3D-crossproduct,
finding an orthogonal vector to a plane in 3D.
</p>


<h3>Value</h3>

<p>tangentPlane:
</p>
<p>crossProduct: returns a vector of length 3.
</p>
<table role = "presentation">
<tr><td><code>y</code></td>
<td>
<p>vector orthogonal to x</p>
</td></tr>
<tr><td><code>z</code></td>
<td>
<p>vector orthogonal to x and y</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Stefan Schlager
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
require(rgl)

x &lt;- c(1,0,0)
y &lt;- c(0,1,0)

#example tangentPlane
z &lt;- tangentPlane(x)
#visualize result
## Not run: 
lines3d(rbind(0, x), col=2, lwd=2)
## show complement
lines3d(rbind(z$y, 0, z$z), col=3, lwd=2)

## End(Not run)
# example crossProduct
z &lt;- crossProduct(x, y)
# show x and y
## Not run: 
lines3d(rbind(x, 0, y), col=2, lwd=2)
# show z
lines3d(rbind(0, z), col=3, lwd=2)

## End(Not run)
</code></pre>

<hr>
<h2 id='cSize'>calculate Centroid Size for a landmark configuration</h2><span id='topic+cSize'></span>

<h3>Description</h3>

<p>calculate Centroid Size for a landmark configuration
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cSize(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cSize_+3A_x">x</code></td>
<td>
<p>k x 3 matrix containing landmark coordinates or mesh of class &quot;mesh3d&quot;</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns Centroid size
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(boneData)
cSize(boneLM[,,1])

</code></pre>

<hr>
<h2 id='cutMeshPlane'>cut a mesh by a hyperplane and remove parts above/below that plane</h2><span id='topic+cutMeshPlane'></span>

<h3>Description</h3>

<p>cut a mesh by a hyperplane and remove parts above/below that plane
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cutMeshPlane(mesh, v1, v2 = NULL, v3 = NULL, normal = NULL, keep.upper = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cutMeshPlane_+3A_mesh">mesh</code></td>
<td>
<p>triangular mesh of class &quot;mesh3d&quot;</p>
</td></tr>
<tr><td><code id="cutMeshPlane_+3A_v1">v1</code></td>
<td>
<p>numeric vector of length=3 specifying a point on the separating plane</p>
</td></tr>
<tr><td><code id="cutMeshPlane_+3A_v2">v2</code></td>
<td>
<p>numeric vector of length=3 specifying a point on the separating plane</p>
</td></tr>
<tr><td><code id="cutMeshPlane_+3A_v3">v3</code></td>
<td>
<p>numeric vector of length=3 specifying a point on the separating plane</p>
</td></tr>
<tr><td><code id="cutMeshPlane_+3A_normal">normal</code></td>
<td>
<p>plane normal (overrides specification by v2 and v3)</p>
</td></tr>
<tr><td><code id="cutMeshPlane_+3A_keep.upper">keep.upper</code></td>
<td>
<p>logical specify whether the points above or below the plane are should be kept</p>
</td></tr>
</table>


<h3>Details</h3>

<p>see <code><a href="#topic+cutSpace">cutSpace</a></code> for more details.
</p>


<h3>Value</h3>

<p>mesh with part above/below hyperplane removed
</p>

<hr>
<h2 id='cutSpace'>separate a 3D-pointcloud by a hyperplane</h2><span id='topic+cutSpace'></span>

<h3>Description</h3>

<p>separate a 3D-pointcloud by a hyperplane
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cutSpace(pointcloud, v1, v2 = NULL, v3 = NULL, normal = NULL, upper = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cutSpace_+3A_pointcloud">pointcloud</code></td>
<td>
<p>numeric n x 3 matrix</p>
</td></tr>
<tr><td><code id="cutSpace_+3A_v1">v1</code></td>
<td>
<p>numeric vector of length=3 specifying a point on the separating plane</p>
</td></tr>
<tr><td><code id="cutSpace_+3A_v2">v2</code></td>
<td>
<p>numeric vector of length=3 specifying a point on the separating plane</p>
</td></tr>
<tr><td><code id="cutSpace_+3A_v3">v3</code></td>
<td>
<p>numeric vector of length=3 specifying a point on the separating plane</p>
</td></tr>
<tr><td><code id="cutSpace_+3A_normal">normal</code></td>
<td>
<p>plane normal (overrides specification by v2 and v3)</p>
</td></tr>
<tr><td><code id="cutSpace_+3A_upper">upper</code></td>
<td>
<p>logical specify whether the points above or below the plane are to be reported as TRUE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>As above and below are specified by the normal calculated from <code class="reqn">(v2-v1) \times (v3-v1)</code>, where <code class="reqn">\times</code> denotes the vector crossproduct. This means the normal points &quot;upward&quot; when viewed from the positon where v1, v2 and v3 are arranged counter-clockwise. Thus, which side is &quot;up&quot; depends on the ordering of v1, v2 and v3.
</p>


<h3>Value</h3>

<p>logical vector of length n. Reporting for each point if it is above or below the hyperplane
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(nose)
v1 &lt;- shortnose.lm[1,]
v2 &lt;- shortnose.lm[2,]
v3 &lt;- shortnose.lm[3,]
pointcloud &lt;- vert2points(shortnose.mesh)
upper &lt;- cutSpace(pointcloud, v1, v2, v3)
## Not run: 
require(rgl)
normal &lt;- crossProduct(v2-v1,v3-v1)
zeroPro &lt;- points2plane(rep(0,3),v1,normal)
## get sign of normal displacement from zero
sig &lt;- sign(crossprod(-zeroPro,normal))
d &lt;- sig*norm(zeroPro,"2")
planes3d(normal[1],normal[2],normal[3],d=d)
points3d(pointcloud[upper,])

## End(Not run)
</code></pre>

<hr>
<h2 id='CVA'>Canonical Variate Analysis</h2><span id='topic+CVA'></span>

<h3>Description</h3>

<p>performs a Canonical Variate Analysis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CVA(
  dataarray,
  groups,
  weighting = TRUE,
  tolinv = 1e-10,
  plot = TRUE,
  rounds = 0,
  cv = FALSE,
  p.adjust.method = "none",
  robust = c("classical", "mve", "mcd"),
  prior = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CVA_+3A_dataarray">dataarray</code></td>
<td>
<p>Either a k x m x n real array, where k is the number of
points, m is the number of dimensions, and n is the sample size. Or
alternatively a n x m Matrix where n is the numeber of observations and m
the number of variables (this can be PC scores for example)</p>
</td></tr>
<tr><td><code id="CVA_+3A_groups">groups</code></td>
<td>
<p>a character/factor vector containgin grouping variable.</p>
</td></tr>
<tr><td><code id="CVA_+3A_weighting">weighting</code></td>
<td>
<p>Logical: Determines whether the between group covariance 
matrix and Grandmean is to be weighted according to group size.</p>
</td></tr>
<tr><td><code id="CVA_+3A_tolinv">tolinv</code></td>
<td>
<p>Threshold for the eigenvalues of the pooled
within-group-covariance matrix to be taken as zero - for calculating the
general inverse of the pooled withing groups covariance matrix.</p>
</td></tr>
<tr><td><code id="CVA_+3A_plot">plot</code></td>
<td>
<p>Logical: determins whether in the two-sample case a histogramm
ist to be plotted.</p>
</td></tr>
<tr><td><code id="CVA_+3A_rounds">rounds</code></td>
<td>
<p>integer: number of permutations if a permutation test of the
Mahalanobis distances (from the pooled within-group covariance matrix) and Euclidean distance between group means is requested
If rounds = 0, no test is performed.</p>
</td></tr>
<tr><td><code id="CVA_+3A_cv">cv</code></td>
<td>
<p>logical: requests a Jackknife Crossvalidation.</p>
</td></tr>
<tr><td><code id="CVA_+3A_p.adjust.method">p.adjust.method</code></td>
<td>
<p>method to adjust p-values for multiple comparisons see <code><a href="stats.html#topic+p.adjust.methods">p.adjust.methods</a></code> for options.</p>
</td></tr>
<tr><td><code id="CVA_+3A_robust">robust</code></td>
<td>
<p>character: determines covariance estimation methods, allowing for robust estimations using <code>MASS::cov.rob</code></p>
</td></tr>
<tr><td><code id="CVA_+3A_prior">prior</code></td>
<td>
<p>vector assigning each group a prior probability.</p>
</td></tr>
<tr><td><code id="CVA_+3A_...">...</code></td>
<td>
<p>additional parameters passed to <code>MASS::cov.rob</code> for robust covariance and mean estimations</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>CV</code></td>
<td>
<p>A matrix containing the Canonical Variates</p>
</td></tr>
<tr><td><code>CVscores</code></td>
<td>
<p>A matrix containing the individual Canonical Variate scores</p>
</td></tr>
<tr><td><code>Grandm</code></td>
<td>
<p>a vector or a matrix containing the Grand Mean (depending if the input is an array or a matrix)</p>
</td></tr>
<tr><td><code>groupmeans</code></td>
<td>
<p>a matrix or an array containing the group means (depending if the input is an array or a matrix)</p>
</td></tr>
<tr><td><code>Var</code></td>
<td>
<p>Variance explained by the Canonical Variates</p>
</td></tr>
<tr><td><code>CVvis</code></td>
<td>
<p>Canonical Variates projected back into the original space - to be used for visualization purposes, for details see example below</p>
</td></tr>
<tr><td><code>Dist</code></td>
<td>
<p>Mahalanobis Distances between group means - if requested
tested by permutation test if the input is an array it is assumed to be
superimposed Landmark Data and Procrustes Distance will be calculated</p>
</td></tr>
<tr><td><code>CVcv</code></td>
<td>
<p>A matrix containing crossvalidated CV scores</p>
</td></tr>
<tr><td><code>groups</code></td>
<td>
<p>factor containing the grouping variable</p>
</td></tr>
<tr><td><code>class</code></td>
<td>
<p>classification results based on posteriror probabilities. If cv=TRUE, this will be done by a leaving-one-out procedure</p>
</td></tr>
<tr><td><code>posterior</code></td>
<td>
<p>posterior probabilities</p>
</td></tr>
<tr><td><code>prior</code></td>
<td>
<p>prior probabilities</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Stefan Schlager
</p>


<h3>References</h3>

<p>Cambell, N. A. &amp; Atchley, W. R.. 1981 The Geometry of Canonical
Variate Analysis: Syst. Zool., 30(3), 268-280.
</p>
<p>Klingenberg, C. P. &amp; Monteiro, L. R. 2005 Distances and directions in
multidimensional shape spaces: implications for morphometric applications.
Systematic Biology 54, 678-688.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+groupPCA">groupPCA</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## all examples are kindly provided by Marta Rufino

if (require(shapes)) {
# perform procrustes fit on raw data
alldat&lt;-procSym(abind(gorf.dat,gorm.dat))
# create factors
groups&lt;-as.factor(c(rep("female",30),rep("male",29)))
# perform CVA and test Mahalanobis distance
# between groups with permutation test by 100 rounds)            
cvall&lt;-CVA(alldat$orpdata,groups,rounds=10000)     
## visualize a shape change from score -5 to 5:
cvvis5 &lt;- 5*matrix(cvall$CVvis[,1],nrow(cvall$Grandm),ncol(cvall$Grandm))+cvall$Grandm
cvvisNeg5 &lt;- -5*matrix(cvall$CVvis[,1],nrow(cvall$Grandm),ncol(cvall$Grandm))+cvall$Grandm
plot(cvvis5,asp=1)
points(cvvisNeg5,col=2)
for (i in 1:nrow(cvvisNeg5))
  lines(rbind(cvvis5[i,],cvvisNeg5[i,]))
}
### Morpho CVA
data(iris)
vari &lt;- iris[,1:4]
facto &lt;- iris[,5]

cva.1=CVA(vari, groups=facto)
## get the typicality probabilities and resulting classifications - tagging
## all specimens with a probability of &lt; 0.01 as outliers (assigned to no class)
typprobs &lt;- typprobClass(cva.1$CVscores,groups=facto)
print(typprobs)
## visualize the CV scores by their groups estimated from (cross-validated)
## typicality probabilities:
if (require(car)) {
scatterplot(cva.1$CVscores[,1],cva.1$CVscores[,2],groups=typprobs$groupaffinCV,
                  smooth=FALSE,reg.line=FALSE)
}
# plot the CVA
plot(cva.1$CVscores, col=facto, pch=as.numeric(facto), typ="n",asp=1,
   xlab=paste("1st canonical axis", paste(round(cva.1$Var[1,2],1),"%")),
   ylab=paste("2nd canonical axis", paste(round(cva.1$Var[2,2],1),"%")))
  
  text(cva.1$CVscores, as.character(facto), col=as.numeric(facto), cex=.7)

  # add chull (merge groups)
  for(jj in 1:length(levels(facto))){
        ii=levels(facto)[jj]
    kk=chull(cva.1$CVscores[facto==ii,1:2])
    lines(cva.1$CVscores[facto==ii,1][c(kk, kk[1])],
    cva.1$CVscores[facto==ii,2][c(kk, kk[1])], col=jj)
    }

  # add 80% ellipses
  if (require(car)) {
  for(ii in 1:length(levels(facto))){
    dataEllipse(cva.1$CVscores[facto==levels(facto)[ii],1],
    cva.1$CVscores[facto==levels(facto)[ii],2], 
                    add=TRUE,levels=.80, col=c(1:7)[ii])}
  }
  # histogram per group
  if (require(lattice)) {
  histogram(~cva.1$CVscores[,1]|facto,
  layout=c(1,length(levels(facto))),
          xlab=paste("1st canonical axis", paste(round(cva.1$Var[1,2],1),"%")))
  histogram(~cva.1$CVscores[,2]|facto, layout=c(1,length(levels(facto))),
          xlab=paste("2nd canonical axis", paste(round(cva.1$Var[2,2],1),"%")))
  } 
  # plot Mahalahobis
  dendroS=hclust(cva.1$Dist$GroupdistMaha)
  dendroS$labels=levels(facto)
  par(mar=c(4,4.5,1,1))
  dendroS=as.dendrogram(dendroS)
  plot(dendroS, main='',sub='', xlab="Geographic areas",
          ylab='Mahalahobis distance')

 
   # Variance explained by the canonical roots:
   cva.1$Var
   # or plot it:
   barplot(cva.1$Var[,2])

# another landmark based example in 3D: 
data(boneData)
groups &lt;- name2factor(boneLM,which=3:4)
proc &lt;- procSym(boneLM)
cvall&lt;-CVA(proc$orpdata,groups)    
#' ## visualize a shape change from score -5 to 5:
cvvis5 &lt;- 5*matrix(cvall$CVvis[,1],nrow(cvall$Grandm),ncol(cvall$Grandm))+cvall$Grandm
cvvisNeg5 &lt;- -5*matrix(cvall$CVvis[,1],nrow(cvall$Grandm),ncol(cvall$Grandm))+cvall$Grandm
## Not run: 
#visualize it
deformGrid3d(cvvis5,cvvisNeg5,ngrid = 0)

## End(Not run)

#for using (e.g. the first 5) PCscores, one will do:
cvall &lt;- CVA(proc$PCscores[,1:5],groups)    
#' ## visualize a shape change from score -5 to 5:
cvvis5 &lt;- 5*cvall$CVvis[,1]+cvall$Grandm
cvvisNeg5 &lt;- -5*cvall$CVvis[,1]+cvall$Grandm
cvvis5 &lt;- restoreShapes(cvvis5,proc$PCs[,1:5],proc$mshape)
cvvisNeg5 &lt;- restoreShapes(cvvisNeg5,proc$PCs[,1:5],proc$mshape)
## Not run: 
#visualize it
deformGrid3d(cvvis5,cvvisNeg5,ngrid = 0)

## End(Not run)
</code></pre>

<hr>
<h2 id='data2platonic'>creates 3D shapes from data to be saved as triangular meshes</h2><span id='topic+data2platonic'></span>

<h3>Description</h3>

<p>creates 3D shapes from 3-dimensional data that can be saved as triangular meshes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data2platonic(
  datamatrix,
  shape = Rvcg::vcgSphere(),
  col = "red",
  scale = FALSE,
  scalefactor = 1
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="data2platonic_+3A_datamatrix">datamatrix</code></td>
<td>
<p>k x 3 data matrix</p>
</td></tr>
<tr><td><code id="data2platonic_+3A_shape">shape</code></td>
<td>
<p>a 3D shape</p>
</td></tr>
<tr><td><code id="data2platonic_+3A_col">col</code></td>
<td>
<p>color value</p>
</td></tr>
<tr><td><code id="data2platonic_+3A_scale">scale</code></td>
<td>
<p>logical: whether to scale the data to unit sd.</p>
</td></tr>
<tr><td><code id="data2platonic_+3A_scalefactor">scalefactor</code></td>
<td>
<p>scale the resulting shapes.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns all shapes merged into a single mesh
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
mymesh &lt;- data2platonic(iris[iris$Species=="setosa",1:3],scalefactor=0.1)
mymesh &lt;- mergeMeshes(mymesh,data2platonic(iris[iris$Species=="versicolor",1:3],
                      shape=Rvcg::vcgIcosahedron(),scalefactor=0.1,col="green"))
mymesh &lt;- mergeMeshes(mymesh,data2platonic(iris[iris$Species=="virginica",1:3],
                      shape=Rvcg::vcgTetrahedron(),scalefactor=0.1,col="blue"))
## Not run: 
rgl::shade3d(mymesh)
## save to disk
Rvcg::vcgPlyWrite(mymesh,filename="3D_Data.ply")

## End(Not run)
</code></pre>

<hr>
<h2 id='deformGrid2d'>visualise differences between two superimposed sets of 2D landmarks</h2><span id='topic+deformGrid2d'></span>

<h3>Description</h3>

<p>visualise differences between two superimposed sets of 2D landmarks by
deforming a square grid based on a thin-plate spline interpolation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>deformGrid2d(
  matrix,
  tarmatrix,
  ngrid = 0,
  lwd = 1,
  show = c(1:2),
  lines = TRUE,
  lcol = 1,
  lty = 2,
  col1 = 2,
  col2 = 3,
  pcaxis = FALSE,
  add = FALSE,
  wireframe = NULL,
  margin = 0.2,
  gridcol = "grey",
  gridlty = 1,
  cex1 = 1,
  cex2 = 1,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="deformGrid2d_+3A_matrix">matrix</code></td>
<td>
<p>reference matrix containing 2D landmark coordinates or mesh of class &quot;mesh3d&quot;</p>
</td></tr>
<tr><td><code id="deformGrid2d_+3A_tarmatrix">tarmatrix</code></td>
<td>
<p>target matrix containing 2D landmark coordinates or mesh of class &quot;mesh3d&quot;</p>
</td></tr>
<tr><td><code id="deformGrid2d_+3A_ngrid">ngrid</code></td>
<td>
<p>number of grid lines to be plotted; ngrid=0 suppresses grid
creation.</p>
</td></tr>
<tr><td><code id="deformGrid2d_+3A_lwd">lwd</code></td>
<td>
<p>width of lines connecting landmarks.</p>
</td></tr>
<tr><td><code id="deformGrid2d_+3A_show">show</code></td>
<td>
<p>integer (vector): if c(1:2) both configs will be plotted, show = 1 only plots the reference and show = 2 the target.
plotted. Options are combinations of 1,2 and 3.</p>
</td></tr>
<tr><td><code id="deformGrid2d_+3A_lines">lines</code></td>
<td>
<p>logical: if TRUE, lines between landmarks will be plotted.</p>
</td></tr>
<tr><td><code id="deformGrid2d_+3A_lcol">lcol</code></td>
<td>
<p>color of lines</p>
</td></tr>
<tr><td><code id="deformGrid2d_+3A_lty">lty</code></td>
<td>
<p>line type</p>
</td></tr>
<tr><td><code id="deformGrid2d_+3A_col1">col1</code></td>
<td>
<p>color of &quot;matrix&quot;</p>
</td></tr>
<tr><td><code id="deformGrid2d_+3A_col2">col2</code></td>
<td>
<p>color of &quot;tarmat&quot;</p>
</td></tr>
<tr><td><code id="deformGrid2d_+3A_pcaxis">pcaxis</code></td>
<td>
<p>logical: align grid by shape's principal axes.</p>
</td></tr>
<tr><td><code id="deformGrid2d_+3A_add">add</code></td>
<td>
<p>logical: if TRUE, output will be drawn on existing plot.</p>
</td></tr>
<tr><td><code id="deformGrid2d_+3A_wireframe">wireframe</code></td>
<td>
<p>list/vector containing row indices to be plotted as wireframe (see <code><a href="#topic+lineplot">lineplot</a></code>.)</p>
</td></tr>
<tr><td><code id="deformGrid2d_+3A_margin">margin</code></td>
<td>
<p>margin around the bounding box to draw the grid</p>
</td></tr>
<tr><td><code id="deformGrid2d_+3A_gridcol">gridcol</code></td>
<td>
<p>color of the grid</p>
</td></tr>
<tr><td><code id="deformGrid2d_+3A_gridlty">gridlty</code></td>
<td>
<p>linetype for grid</p>
</td></tr>
<tr><td><code id="deformGrid2d_+3A_cex1">cex1</code></td>
<td>
<p>control size of points belonging to <code>matrix</code></p>
</td></tr>
<tr><td><code id="deformGrid2d_+3A_cex2">cex2</code></td>
<td>
<p>control size of points belonging to <code>tarmatrix</code></p>
</td></tr>
<tr><td><code id="deformGrid2d_+3A_...">...</code></td>
<td>
<p>additional parameters passed to plot</p>
</td></tr>
</table>


<h3>Value</h3>

<p>if <code>ngrid &gt; 1</code> the coordinates of the displaced grid knots are returned.
</p>


<h3>Author(s)</h3>

<p>Stefan Schlager
</p>


<h3>See Also</h3>

<p><code><a href="#topic+tps3d">tps3d</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (require(shapes)) {
proc &lt;- procSym(gorf.dat)
deformGrid2d(proc$mshape,proc$rotated[,,1],ngrid=5,pch=19)
}

</code></pre>

<hr>
<h2 id='deformGrid3d'>visualise differences between two superimposed sets of 3D landmarks</h2><span id='topic+deformGrid3d'></span>

<h3>Description</h3>

<p>visualise differences between two superimposed sets of 3D landmarks by
deforming a cubic grid based on a thin-plate spline interpolation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>deformGrid3d(
  matrix,
  tarmatrix,
  ngrid = 0,
  align = FALSE,
  lwd = 1,
  showaxis = c(1, 2),
  show = c(1, 2),
  lines = TRUE,
  lcol = 1,
  add = FALSE,
  col1 = 2,
  col2 = 3,
  type = c("s", "p"),
  size = NULL,
  pcaxis = FALSE,
  ask = TRUE,
  margin = 0.2,
  createMesh = FALSE,
  slice1 = NULL,
  slice2 = NULL,
  slice3 = NULL,
  gridcol = 1,
  gridwidth = 1,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="deformGrid3d_+3A_matrix">matrix</code></td>
<td>
<p>reference matrix containing 3D landmark coordinates or mesh of class &quot;mesh3d&quot;</p>
</td></tr>
<tr><td><code id="deformGrid3d_+3A_tarmatrix">tarmatrix</code></td>
<td>
<p>target matrix containing 3D landmark coordinates or mesh of class &quot;mesh3d&quot;</p>
</td></tr>
<tr><td><code id="deformGrid3d_+3A_ngrid">ngrid</code></td>
<td>
<p>number of grid lines to be plotted; ngrid=0 suppresses grid
creation.</p>
</td></tr>
<tr><td><code id="deformGrid3d_+3A_align">align</code></td>
<td>
<p>logical: if TRUE, <code>tarmatrix</code> will be aligned rigidly to <code>matrix</code></p>
</td></tr>
<tr><td><code id="deformGrid3d_+3A_lwd">lwd</code></td>
<td>
<p>width of lines connecting landmarks.</p>
</td></tr>
<tr><td><code id="deformGrid3d_+3A_showaxis">showaxis</code></td>
<td>
<p>integer (vector): which dimensions of the grid to be
plotted. Options are combinations of 1,2 and 3.</p>
</td></tr>
<tr><td><code id="deformGrid3d_+3A_show">show</code></td>
<td>
<p>integer (vector): if c(1:2) both configs will be plotted, show = 1 only plots the reference and show = 2 the target</p>
</td></tr>
<tr><td><code id="deformGrid3d_+3A_lines">lines</code></td>
<td>
<p>logical: if TRUE, lines between landmarks will be plotted.</p>
</td></tr>
<tr><td><code id="deformGrid3d_+3A_lcol">lcol</code></td>
<td>
<p>color of lines</p>
</td></tr>
<tr><td><code id="deformGrid3d_+3A_add">add</code></td>
<td>
<p>logical: add to existing rgl window.</p>
</td></tr>
<tr><td><code id="deformGrid3d_+3A_col1">col1</code></td>
<td>
<p>color of &quot;matrix&quot;</p>
</td></tr>
<tr><td><code id="deformGrid3d_+3A_col2">col2</code></td>
<td>
<p>color of &quot;tarmat&quot;</p>
</td></tr>
<tr><td><code id="deformGrid3d_+3A_type">type</code></td>
<td>
<p>&quot;s&quot; renders landmarks as spheres; &quot;p&quot; as points - much faster
for very large pointclouds.</p>
</td></tr>
<tr><td><code id="deformGrid3d_+3A_size">size</code></td>
<td>
<p>control size/radius of points/spheres</p>
</td></tr>
<tr><td><code id="deformGrid3d_+3A_pcaxis">pcaxis</code></td>
<td>
<p>logical: align grid by shape's principal axes.</p>
</td></tr>
<tr><td><code id="deformGrid3d_+3A_ask">ask</code></td>
<td>
<p>logical: if TRUE for &gt; 1000 coordinates the user will be asked to prefer points over spheres.</p>
</td></tr>
<tr><td><code id="deformGrid3d_+3A_margin">margin</code></td>
<td>
<p>margin around the bounding box to draw the grid</p>
</td></tr>
<tr><td><code id="deformGrid3d_+3A_createmesh">createMesh</code></td>
<td>
<p>logical: if TRUE, a triangular mesh of spheres and displacement vectors (can take some time depending on number of reference points and grid density).</p>
</td></tr>
<tr><td><code id="deformGrid3d_+3A_slice1">slice1</code></td>
<td>
<p>integer or vector of integers: select slice(s) for the dimensions</p>
</td></tr>
<tr><td><code id="deformGrid3d_+3A_slice2">slice2</code></td>
<td>
<p>integer or vector of integers: select slice(s) for the dimensions</p>
</td></tr>
<tr><td><code id="deformGrid3d_+3A_slice3">slice3</code></td>
<td>
<p>integer or vector of integers: select slice(s) for the dimensions</p>
</td></tr>
<tr><td><code id="deformGrid3d_+3A_gridcol">gridcol</code></td>
<td>
<p>define color of grid</p>
</td></tr>
<tr><td><code id="deformGrid3d_+3A_gridwidth">gridwidth</code></td>
<td>
<p>integer: define linewidth of grid</p>
</td></tr>
<tr><td><code id="deformGrid3d_+3A_...">...</code></td>
<td>
<p>additional parameters passed to <code><a href="#topic+rotonto">rotonto</a></code> in case <code>align=TRUE</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>if <code>createMesh=TRUE</code>, a mesh containing spheres of reference and target as well as the displacement vectors is returned. Otherwise the knots of the displaced grid is returned.
</p>


<h3>Author(s)</h3>

<p>Stefan Schlager
</p>


<h3>See Also</h3>

<p><code><a href="#topic+tps3d">tps3d</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (interactive()){
data(nose)
deformGrid3d(shortnose.lm,longnose.lm,ngrid=10)

## select some slices
deformGrid3d(shortnose.lm,longnose.lm,showaxis=1:3,ngrid=10,slice1=2,slice2=5,slice3=7)
}
</code></pre>

<hr>
<h2 id='deprecated'>deprecated functions of Morpho</h2><span id='topic+deprecated'></span><span id='topic+deform.grid'></span><span id='topic+showPC'></span><span id='topic+adnormals'></span><span id='topic+regdist.raw'></span><span id='topic+crossp'></span><span id='topic+tanplan'></span><span id='topic+conv2backf'></span><span id='topic+warp.mesh'></span>

<h3>Description</h3>

<p>document deprecated functions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>deform.grid(...)

showPC(scores, PC, mshape)

adnormals(...)

regdist.raw(
  dataarray,
  plot = TRUE,
  main = "",
  rho = "angle",
  dist.mat.out = FALSE,
  ...
)

crossp(...)

tanplan(...)

conv2backf(...)

warp.mesh(
  mesh,
  matr,
  matt,
  lambda = 1e-08,
  updateNormals = TRUE,
  silent = FALSE
)

showPC(scores, PC, mshape)
</code></pre>

<hr>
<h2 id='equidistantCurve'>make a curve equidistant (optionally up/downsampling)</h2><span id='topic+equidistantCurve'></span>

<h3>Description</h3>

<p>make a curve equidistant (optionally up/downsampling)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>equidistantCurve(
  x,
  n = NULL,
  open = TRUE,
  subsample = 0,
  increment = 2,
  smoothit = 0,
  mesh = NULL,
  iterations = 1
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="equidistantCurve_+3A_x">x</code></td>
<td>
<p>k x m matrix containing the 2D or 3D coordinates</p>
</td></tr>
<tr><td><code id="equidistantCurve_+3A_n">n</code></td>
<td>
<p>integer: number of coordinates to sample. If NULL, the existing curve will be made equidistant.</p>
</td></tr>
<tr><td><code id="equidistantCurve_+3A_open">open</code></td>
<td>
<p>logical: specifies whether the curve is open or closed.</p>
</td></tr>
<tr><td><code id="equidistantCurve_+3A_subsample">subsample</code></td>
<td>
<p>integer: number of subsamples to draw from curve for interpolation. For curves with &lt; 1000 points, no subsampling is required.</p>
</td></tr>
<tr><td><code id="equidistantCurve_+3A_increment">increment</code></td>
<td>
<p>integer: if &gt; 1, the curve is estimated iteratively by incrementing the original points by this factor. The closer this value to 1, the smoother the line but possibly farther away from the control points.</p>
</td></tr>
<tr><td><code id="equidistantCurve_+3A_smoothit">smoothit</code></td>
<td>
<p>integer: smoothing iterations after each step</p>
</td></tr>
<tr><td><code id="equidistantCurve_+3A_mesh">mesh</code></td>
<td>
<p>specify mesh to project point to</p>
</td></tr>
<tr><td><code id="equidistantCurve_+3A_iterations">iterations</code></td>
<td>
<p>integer: how many iterations to run equidistancing.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Equidistancy is reached by iteratively deforming (using TPS) a straight line with equidistantly placed points to the target using control points with the same spacing as the actual curve. To avoid singularity, the straight line containes a small amount of noise, which can (optionally) be accounted for by smoothing the line by its neighbours.
</p>


<h3>Value</h3>

<p>matrix containing equidistantly placed points
</p>


<h3>Note</h3>

<p>if n &gt;&gt; number of original points, the resulting curves can show unwanted distortions.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(nose)
x &lt;- shortnose.lm[c(304:323),]
xsample &lt;- equidistantCurve(x,n=50,iterations=10,increment=2)

require(rgl)
points3d(xsample,size=5)
spheres3d(x,col=2,radius=0.3,alpha=0.5)

## End(Not run)
</code></pre>

<hr>
<h2 id='exVar'>calculate variance of a distribution stemming from prediction models</h2><span id='topic+exVar'></span><span id='topic+exVar.lm'></span><span id='topic+exVar.mvr'></span>

<h3>Description</h3>

<p>calculates a quotient of the overall varriance within a predicted
distribution to that from the original one. This function calculates a naive extension of the univariate R^2-value by
dividing the variance in the predicted dat by the variance of the original
data. No additional adjustments are made!!
</p>


<h3>Usage</h3>

<pre><code class='language-R'>exVar(model, ...)

## S3 method for class 'lm'
exVar(model, ...)

## S3 method for class 'mvr'
exVar(model, ncomp, val = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="exVar_+3A_model">model</code></td>
<td>
<p>a model of classes &quot;lm&quot; or &quot;mvr&quot; (from the package &quot;pls&quot;)</p>
</td></tr>
<tr><td><code id="exVar_+3A_...">...</code></td>
<td>
<p>currently unused additional arguments.</p>
</td></tr>
<tr><td><code id="exVar_+3A_ncomp">ncomp</code></td>
<td>
<p>How many latent variables to use (only for mvr models)</p>
</td></tr>
<tr><td><code id="exVar_+3A_val">val</code></td>
<td>
<p>use cross-vaildated predictions (only for mvr models)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns the quotient.
</p>


<h3>Note</h3>

<p>The result is only!! a rough estimate of the variance explained by a
multivariate model. And the result can be misleading - especially when there
are many predictor variables involved. If one is interested in the value
each factor/covariate explains, we recommend a 50-50 MANOVA perfomed by the
R-package &quot;ffmanova&quot;, which reports this value factor-wise.
</p>


<h3>Author(s)</h3>

<p>Stefan Schlager
</p>


<h3>References</h3>

<p>Langsrud O, Juergensen K, Ofstad R, Naes T. 2007. Analyzing
Designed Experiments with Multiple Responses Journal of Applied Statistics
34:1275-1296.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
lm1 &lt;- lm(as.matrix(iris[,1:4]) ~ iris[,5])
exVar(lm1)
</code></pre>

<hr>
<h2 id='fastKmeans'>fast kmeans clustering for 2D or 3D point clouds</h2><span id='topic+fastKmeans'></span>

<h3>Description</h3>

<p>fast kmeans clustering for 2D or 3D point clouds - with the primary purpose to get a spatially equally distributed samples
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fastKmeans(x, k, iter.max = 10, project = TRUE, threads = 0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fastKmeans_+3A_x">x</code></td>
<td>
<p>matrix containing coordinates or mesh3d</p>
</td></tr>
<tr><td><code id="fastKmeans_+3A_k">k</code></td>
<td>
<p>number of clusters</p>
</td></tr>
<tr><td><code id="fastKmeans_+3A_iter.max">iter.max</code></td>
<td>
<p>maximum number of iterations</p>
</td></tr>
<tr><td><code id="fastKmeans_+3A_project">project</code></td>
<td>
<p>logical: if x is a triangular mesh, the centers will be projected onto the surface.</p>
</td></tr>
<tr><td><code id="fastKmeans_+3A_threads">threads</code></td>
<td>
<p>integer number of threads to use</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns a list containing
</p>
<table role = "presentation">
<tr><td><code>selected</code></td>
<td>
<p>coordinates closest to the final centers</p>
</td></tr>
<tr><td><code>centers</code></td>
<td>
<p>cluster center</p>
</td></tr>
<tr><td><code>class</code></td>
<td>
<p>vector with cluster association for each coordinate</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>require(Rvcg)
data(humface)
set.seed(42)
clust &lt;- fastKmeans(humface,k=1000,threads=1)
## Not run: 
require(rgl)

## plot the cluster centers
spheres3d(clust$centers)

## now look at the vertices closest to the centers
wire3d(humface)
spheres3d(vert2points(humface)[clust$selected,],col=2)

## End(Not run)


</code></pre>

<hr>
<h2 id='file2mesh'>Import 3D surface mesh files</h2><span id='topic+file2mesh'></span><span id='topic+obj2mesh'></span><span id='topic+ply2mesh'></span>

<h3>Description</h3>

<p>Import 3D surface mesh files
</p>


<h3>Usage</h3>

<pre><code class='language-R'>file2mesh(filename, clean = TRUE, readcol = FALSE)

obj2mesh(filename, adnormals = TRUE)

ply2mesh(
  filename,
  adnormals = TRUE,
  readnormals = FALSE,
  readcol = FALSE,
  silent = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="file2mesh_+3A_filename">filename</code></td>
<td>
<p>character: path to file</p>
</td></tr>
<tr><td><code id="file2mesh_+3A_clean">clean</code></td>
<td>
<p>Logical: Delete dumpfiles.</p>
</td></tr>
<tr><td><code id="file2mesh_+3A_readcol">readcol</code></td>
<td>
<p>Logical: Import vertex colors (if available).</p>
</td></tr>
<tr><td><code id="file2mesh_+3A_adnormals">adnormals</code></td>
<td>
<p>Logical: If the file does not contain normal information,
they will be calculated in R: Can take some time.</p>
</td></tr>
<tr><td><code id="file2mesh_+3A_readnormals">readnormals</code></td>
<td>
<p>Logical: Import vertex normals (if available), although
no face information is present.</p>
</td></tr>
<tr><td><code id="file2mesh_+3A_silent">silent</code></td>
<td>
<p>logical: suppress messages.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>imports 3D mesh files and store them as an R .object of class mesh3d
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>mesh</code></td>
<td>
<p>list of class mesh3d - see rgl manual for further details,
or a matrix containing vertex information or a list containing vertex and
normal information</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
data(nose)
mesh2ply(shortnose.mesh)
mesh &lt;- ply2mesh("shortnose.mesh.ply")

mesh2obj(shortnose.mesh)
mesh2 &lt;- obj2mesh("shortnose.mesh.obj")
## cleanup
unlink(c("shortnose.mesh.obj","shortnose.mesh.ply"))
</code></pre>

<hr>
<h2 id='find.outliers'>Graphical interface to find outliers and/or to switch mislabeld landmarks</h2><span id='topic+find.outliers'></span>

<h3>Description</h3>

<p>Graphical interface to find outliers and/or to switch mislabeld landmarks
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find.outliers(
  A,
  color = 4,
  lwd = 1,
  lcol = 2,
  mahalanobis = FALSE,
  PCuse = NULL,
  text = TRUE,
  reflection = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="find.outliers_+3A_a">A</code></td>
<td>
<p>Input k x m x n real array, where k is the number of points, m is
the number of dimensions, and n is the sample size.</p>
</td></tr>
<tr><td><code id="find.outliers_+3A_color">color</code></td>
<td>
<p>color of Landmarks points to be plotted</p>
</td></tr>
<tr><td><code id="find.outliers_+3A_lwd">lwd</code></td>
<td>
<p>linewidth visualizing distances of the individual landmarks from
mean.</p>
</td></tr>
<tr><td><code id="find.outliers_+3A_lcol">lcol</code></td>
<td>
<p>color of lines visualizing distances of the individual landmarks
from mean.</p>
</td></tr>
<tr><td><code id="find.outliers_+3A_mahalanobis">mahalanobis</code></td>
<td>
<p>logical: use mahalanobis distance to find outliers.</p>
</td></tr>
<tr><td><code id="find.outliers_+3A_pcuse">PCuse</code></td>
<td>
<p>integer: Restrict mahalanobis distance to the first n Principal
components.</p>
</td></tr>
<tr><td><code id="find.outliers_+3A_text">text</code></td>
<td>
<p>logical: if <code>TRUE</code>, landmark labels (rownumbers) are
displayed</p>
</td></tr>
<tr><td><code id="find.outliers_+3A_reflection">reflection</code></td>
<td>
<p>logical: specify whether reflections are allowed for superimpositioning.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function performs a procrustes fit and sorts all specimen according to
their distances (either Procrustes or Mahalanobis-distance) to the sample's
consensus. It provides visual help for rearranging landmarks and/or
excluding outliers.
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>data.cleaned</code></td>
<td>
<p>array (in original coordinate system) containing
the changes applied and outliers eliminated</p>
</td></tr>
<tr><td><code>outlier</code></td>
<td>
<p>vector with integers indicating the positions in the
original array that have been marked as outliers</p>
</td></tr>
<tr><td><code>dist.sort</code></td>
<td>
<p>table showing the distance to mean for each
observation - decreasing by distance</p>
</td></tr>
<tr><td><code>type</code></td>
<td>
<p>what kind of distance was used</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Stefan Schlager
</p>


<h3>See Also</h3>

<p><code><a href="#topic+typprob">typprob</a></code>,<code><a href="#topic+typprobClass">typprobClass</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(boneData)
## look for outliers using the mahalanobis distance based on the first
# 10 PCscores
# to perform the example below, you need,of course, uncomment the answers
if (interactive()){
outliers &lt;- find.outliers(boneLM, mahalanobis= TRUE, PCuse=10)
# n # everything is fine 
# n # proceed to next
# s # let's switch some landmarks (3 and 4)
# 3
# 4
# n # we are done
# y # yes, because now it is an outlier
# s #enough for now
}

</code></pre>

<hr>
<h2 id='fixLMmirror'>estimate missing landmarks from their bilateral counterparts</h2><span id='topic+fixLMmirror'></span><span id='topic+fixLMmirror.array'></span><span id='topic+fixLMmirror.matrix'></span>

<h3>Description</h3>

<p>estimate missing landmarks from their bilateral counterparts
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fixLMmirror(x, pairedLM, ...)

## S3 method for class 'array'
fixLMmirror(x, pairedLM, ...)

## S3 method for class 'matrix'
fixLMmirror(x, pairedLM, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fixLMmirror_+3A_x">x</code></td>
<td>
<p>a matrix or an array containing landmarks (3D or 2D)</p>
</td></tr>
<tr><td><code id="fixLMmirror_+3A_pairedlm">pairedLM</code></td>
<td>
<p>a k x 2 matrix containing the indices (rownumbers) of the
paired LM. E.g. the left column contains the lefthand landmarks, while the
right side contains the corresponding right hand landmarks.</p>
</td></tr>
<tr><td><code id="fixLMmirror_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>the configurations are mirrored and the relabled version is matched onto the original using a thin-plate spline deformation. The missing landmark is now estimated using its bilateral counterpart. If one side is completely missing, the landmarks will be mirrored and aligned by the unilateral landmarks.
</p>


<h3>Value</h3>

<p>a matrix or array with fixed missing bilateral landmarks.
</p>


<h3>Note</h3>

<p>in case both landmarks of a bilateral pair are missing a message will be issued. As well if there are missing landmarks on the midsaggital plane are detected.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(boneData)
left &lt;- c(4,6,8)
## determine corresponding Landmarks on the right side:
# important: keep same order
right &lt;- c(3,5,7)
pairedLM &lt;- cbind(left, right)
exampmat &lt;- boneLM[,,1]
exampmat[4,] &lt;- NA #set 4th landmark to be NA
fixed &lt;- fixLMmirror(exampmat, pairedLM=pairedLM)
## Not run: 
deformGrid3d(fixed, boneLM[,,1],ngrid=0)
## result is a bit off due to actual asymmetry

## End(Not run)
## example with one side completely missing
oneside &lt;- boneLM[,,1]
oneside[pairedLM[,1],] &lt;- NA
onesidefixed &lt;- fixLMmirror(oneside,pairedLM)
## Not run: 
deformGrid3d(onesidefixed, boneLM[,,1],ngrid=0)
## result is a bit off due to actual asymmetry

## End(Not run)
</code></pre>

<hr>
<h2 id='fixLMtps'>estimate missing landmarks</h2><span id='topic+fixLMtps'></span>

<h3>Description</h3>

<p>Missing landmarks are estimated by deforming a sample average or a weighted
estimate of the configurations most similar onto the deficient
configuration. The deformation is performed by a Thin-plate-spline
interpolation calculated by the available landmarks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fixLMtps(data, comp = 3, weight = TRUE, weightfun = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fixLMtps_+3A_data">data</code></td>
<td>
<p>array containing landmark data</p>
</td></tr>
<tr><td><code id="fixLMtps_+3A_comp">comp</code></td>
<td>
<p>integer: select how many of the closest observations are to be
taken to calculate an initial estimate.</p>
</td></tr>
<tr><td><code id="fixLMtps_+3A_weight">weight</code></td>
<td>
<p>logical: requests the calculation of an estimate based on the
procrustes distance. Otherwise the sample's consensus is used as reference.</p>
</td></tr>
<tr><td><code id="fixLMtps_+3A_weightfun">weightfun</code></td>
<td>
<p>custom function that operates on a vector of distances (see examples) and generates weights accordingly.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function tries to estimate missing landmark data by mapping weighted
averages from complete datasets onto the missing specimen. The weights are
the inverted Procrustes (see <code><a href="#topic+proc.weight">proc.weight</a></code>) distances between
the 'comp' closest specimen (using the available landmark configuration).
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>out</code></td>
<td>
<p>array containing all data, including fixed configurations - same order as input</p>
</td></tr>
<tr><td><code>mshape</code></td>
<td>
<p>meanshape - calculated from complete datasets</p>
</td></tr>
<tr><td><code>checklist</code></td>
<td>
<p>list containing information about missing landmarks</p>
</td></tr>
<tr><td><code>check</code></td>
<td>
<p>vector containing position of observations in data where at least one missing coordinate was found</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Be aware that these estimates might be grossly wrong when the missing
landmark is quite far off the rest of the landmarks (due to the radial basis
function used in the Thin-plate spline interpolation.
</p>


<h3>Author(s)</h3>

<p>Stefan Schlager
</p>


<h3>References</h3>

<p>Bookstein FL. 1989. Principal Warps: Thin-plate splines and the
decomposition of deformations IEEE Transactions on pattern analysis and
machine intelligence 11.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+proc.weight">proc.weight</a></code>, <code><a href="#topic+tps3d">tps3d</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (require(shapes)) {
data &lt;- gorf.dat
### set first landmark of first specimen to NA
data[1,,1] &lt;- NA
repair &lt;- fixLMtps(data,comp=5)
### view difference between estimated and actual landmark
plot(repair$out[,,1],asp=1,pch=21,cex=0.7,col=2)#estimated landmark
points(gorf.dat[,,1],col=3,pch=20)#actual landmark
}
## 3D-example:
data(boneData)
data &lt;- boneLM
### set first and 5th landmark of first specimen to NA
data[c(1,5),,1] &lt;- NA
repair &lt;- fixLMtps(data,comp=10)
##  view difference between estimated and actual landmark
## Not run: 
deformGrid3d(repair$out[,,1], boneLM[,,1],ngrid=0)

## End(Not run)

## Now use a gaussian kernel to compute the weights and use all other configs
gaussWeight &lt;- function(r,sigma=0.05) {
   sigma &lt;- 2*sigma^2
   return(exp(-r^2/ sigma))
}
repair &lt;- fixLMtps(data,comp=79,weightfun=gaussWeight)

</code></pre>

<hr>
<h2 id='getFaces'>find indices of faces that contain specified vertices</h2><span id='topic+getFaces'></span>

<h3>Description</h3>

<p>find indices of faces that contain specified vertices
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getFaces(mesh, index)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getFaces_+3A_mesh">mesh</code></td>
<td>
<p>triangular mesh of class &quot;mesh3d&quot;</p>
</td></tr>
<tr><td><code id="getFaces_+3A_index">index</code></td>
<td>
<p>vector containing indices of vertices</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector of face indices
</p>

<hr>
<h2 id='getMeaningfulPCs'>get number of meaningful Principal components</h2><span id='topic+getMeaningfulPCs'></span>

<h3>Description</h3>

<p>get number of meaningful Principal components
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getMeaningfulPCs(values, n, expect = 2, sdev = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getMeaningfulPCs_+3A_values">values</code></td>
<td>
<p>eigenvalues from a PCA</p>
</td></tr>
<tr><td><code id="getMeaningfulPCs_+3A_n">n</code></td>
<td>
<p>sample size</p>
</td></tr>
<tr><td><code id="getMeaningfulPCs_+3A_expect">expect</code></td>
<td>
<p>expectation value for chi-square distribution of df=2</p>
</td></tr>
<tr><td><code id="getMeaningfulPCs_+3A_sdev">sdev</code></td>
<td>
<p>logical: if TRUE, it is assumed that the values are square roots of eigenvalues.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This implements the method suggested by Bookstein (2014, pp. 324), to determine whether a PC is entitled to interpretation. I.e. a PC is regarded meaningful (its direction) if the ratio of this PC and its successor is above a threshold based on a log-likelihood ratio (and dependend on sample size).
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>tol</code></td>
<td>
<p>threshold of ratio specific for <code>n</code></p>
</td></tr>
<tr><td><code>good</code></td>
<td>
<p>integer vector specifying the meaningful Principal Components</p>
</td></tr>
</table>


<h3>References</h3>

<p>Bookstein, F. L. Measuring and reasoning: numerical inference in the sciences. Cambridge University Press, 2014
</p>


<h3>See Also</h3>

<p><code><a href="#topic+getPCtol">getPCtol</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(boneData)
proc &lt;- procSym(boneLM)
getMeaningfulPCs(proc$eigenvalues,n=nrow(proc$PCscores))
## the first 3 PCs are reported as meaningful
## show barplot that seem to fit the bill
barplot(proc$eigenvalues)
</code></pre>

<hr>
<h2 id='getOuterViewpoints'>Get viewpoints on a sphere around a 3D mesh</h2><span id='topic+getOuterViewpoints'></span>

<h3>Description</h3>

<p>Get viewpoints on a sphere around a 3D mesh to be used with virtualMeshScan
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getOuterViewpoints(
  x,
  n,
  inflate = 1.5,
  radius = NULL,
  subdivision = 3,
  PCA = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getOuterViewpoints_+3A_x">x</code></td>
<td>
<p>triangular mesh of class 'mesh3d'</p>
</td></tr>
<tr><td><code id="getOuterViewpoints_+3A_n">n</code></td>
<td>
<p>number of viewpoint to generate</p>
</td></tr>
<tr><td><code id="getOuterViewpoints_+3A_inflate">inflate</code></td>
<td>
<p>factor for the size of the sphere: <code>inflate=1</code> means that the sphere around the object just touches the point farthest away from the mesh's centroid.</p>
</td></tr>
<tr><td><code id="getOuterViewpoints_+3A_radius">radius</code></td>
<td>
<p>defines a fix radius for the sphere (overrides arg <code>inflate</code>).</p>
</td></tr>
<tr><td><code id="getOuterViewpoints_+3A_subdivision">subdivision</code></td>
<td>
<p>parameter passed to <code><a href="Rvcg.html#topic+vcgSphere">vcgSphere</a></code></p>
</td></tr>
<tr><td><code id="getOuterViewpoints_+3A_pca">PCA</code></td>
<td>
<p>logical: if TRUE, the sphere will be deformed to match the principle axes of the mesh. NOTE: this may result in the sphere not necessarily completely enclosing the mesh.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list containing
</p>
<table role = "presentation">
<tr><td><code>viewpoints</code></td>
<td>
<p>n x 3 matrix containing viewpoints.</p>
</td></tr>
<tr><td><code>sphere</code></td>
<td>
<p>sphere from which the points are sampled</p>
</td></tr>
<tr><td><code>radius</code></td>
<td>
<p>radius of the sphere</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(boneData)
vp &lt;- getOuterViewpoints(skull_0144_ch_fe.mesh,n=100)

require(rgl)
shade3d(skull_0144_ch_fe.mesh,col="white")
spheres3d(vp$viewpoints)
wire3d(vp$sphere)

### Fit to principal axes
vppca &lt;- getOuterViewpoints(skull_0144_ch_fe.mesh,n=100,PCA=TRUE,inflate=1.5)

require(rgl)
shade3d(skull_0144_ch_fe.mesh,col="white")
spheres3d(vppca$viewpoints)
wire3d(vppca$sphere)

## End(Not run)
</code></pre>

<hr>
<h2 id='getPCscores'>Obtain PC-scores for new landmark data</h2><span id='topic+getPCscores'></span>

<h3>Description</h3>

<p>Obtain PC-scores for new landmark data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getPCscores(x, PC, mshape)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getPCscores_+3A_x">x</code></td>
<td>
<p>landmarks aligned (e.g. using <code><a href="#topic+align2procSym">align2procSym</a></code> to the meanshape of data the PCs are derived from.</p>
</td></tr>
<tr><td><code id="getPCscores_+3A_pc">PC</code></td>
<td>
<p>Principal components (eigenvectors of the covariance matrix)</p>
</td></tr>
<tr><td><code id="getPCscores_+3A_mshape">mshape</code></td>
<td>
<p>matrix containing the meanshape's landmarks (used to center the data)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns a matrix containing the PC scores
</p>


<h3>See Also</h3>

<p><code><a href="#topic+restoreShapes">restoreShapes</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(boneData)
proc &lt;- procSym(boneLM[,,-c(1:2)])
newdata &lt;- boneLM[,,c(1:2)]
newdataAlign &lt;- align2procSym(proc,newdata)
scores &lt;- getPCscores(newdataAlign,proc$PCs,proc$mshape)

## End(Not run)
</code></pre>

<hr>
<h2 id='getPCtol'>determine the minimum ratio for two subsequent eigenvalues to be considered different</h2><span id='topic+getPCtol'></span>

<h3>Description</h3>

<p>determine the minimum ratio for two subsequent eigenvalues to be considered different
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getPCtol(n, expect = 2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getPCtol_+3A_n">n</code></td>
<td>
<p>sample size</p>
</td></tr>
<tr><td><code id="getPCtol_+3A_expect">expect</code></td>
<td>
<p>expectation value for chi-square distribution of df=2</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns the minimum ratio between two subsequent subsequent eigenvalues to be considered different.
</p>


<h3>References</h3>

<p>Bookstein, F. L. Measuring and reasoning: numerical inference in the sciences. Cambridge University Press, 2014
</p>


<h3>See Also</h3>

<p><code><a href="#topic+getMeaningfulPCs">getMeaningfulPCs</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## reproduce the graph from Bookstein (2014, p. 324)
## and then compare it to ratios for values to be considered
## statistically significant
myseq &lt;- seq(from=10,to = 50, by = 2)
myseq &lt;- c(myseq,seq(from=50,to=1000, by =20))
ratios &lt;- getPCtol(myseq)
plot(log(myseq),ratios,cex=0,xaxt = "n",ylim=c(1,5.2))
ticks &lt;- c(10,20,50,100,200,300,400,500,600,700,800,900,1000)
axis(1,at=log(ticks),labels=ticks)
lines(log(myseq),ratios)
abline(v=log(ticks), col="lightgray", lty="dotted")
abline(h=seq(from=1.2,to=5, by = 0.2), col="lightgray", lty="dotted")

## now we raise the bar and compute the ratios for values
## to be beyond the 95th percentile of
## the corresponding chi-square distribution:
ratiosSig &lt;- getPCtol(myseq,expect=qchisq(0.95,df=2))
lines(log(myseq),ratiosSig,col=2)


</code></pre>

<hr>
<h2 id='getPLSCommonShape'>Get the linear combinations associated with the common shape change in each latent dimension of a pls2B</h2><span id='topic+getPLSCommonShape'></span>

<h3>Description</h3>

<p>Get the linear combinations associated with the common shape change in each latent dimension of a pls2B
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getPLSCommonShape(pls)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getPLSCommonShape_+3A_pls">pls</code></td>
<td>
<p>object of class &quot;pls2B&quot;</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns a list containing
</p>
<table role = "presentation">
<tr><td><code>shapevectors</code></td>
<td>
<p>matrix with each containing the shapevectors (in column- major format) of common shape change associated with each latent dimension</p>
</td></tr>
<tr><td><code>XscoresScaled</code></td>
<td>
<p>Xscores scaled according to <code>shapevectors</code></p>
</td></tr>
<tr><td><code>YscoresScaled</code></td>
<td>
<p>Yscores scaled according to <code>shapevectors</code></p>
</td></tr>
<tr><td><code>commoncenter</code></td>
<td>
<p>Vector containing the common mean</p>
</td></tr>
<tr><td><code>lmdim</code></td>
<td>
<p>dimension of landmarks</p>
</td></tr>
</table>


<h3>References</h3>

<p>Mitteroecker P, Bookstein F. 2007. The conceptual and statistical relationship between modularity and morphological integration. Systematic Biology 56(5):818-836.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plsCoVarCommonShape">plsCoVarCommonShape</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(boneData)
proc &lt;- procSym(boneLM)
pls &lt;- pls2B(proc$orpdata[1:4,,],proc$orpdata[5:10,,])
commShape &lt;- getPLSCommonShape(pls)
## get common shape for first latent dimension at +-2 sd of the scores
## (you can do this much more convenient using \code{\link{plsCoVarCommonShape}}
scores &lt;- c(-2,2) * sd(c(commShape$XscoresScaled[,1],commShape$YscoresScaled[,1]))
pred &lt;- restoreShapes(scores,commShape$shapevectors[,1],matrix(commShape$commoncenter,10,3))
## Not run: 
deformGrid3d(pred[,,1],pred[,,2])

## End(Not run)
</code></pre>

<hr>
<h2 id='getPLSfromScores'>compute changes associated with 2-Block PLS-scores</h2><span id='topic+getPLSfromScores'></span>

<h3>Description</h3>

<p>compute changes associated with 2-Block PLS-scores
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getPLSfromScores(pls, x, y)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getPLSfromScores_+3A_pls">pls</code></td>
<td>
<p>output of pls2B</p>
</td></tr>
<tr><td><code id="getPLSfromScores_+3A_x">x</code></td>
<td>
<p>scores associated with dataset x in original pls2B</p>
</td></tr>
<tr><td><code id="getPLSfromScores_+3A_y">y</code></td>
<td>
<p>scores associated with dataset y in original pls2B</p>
</td></tr>
</table>


<h3>Details</h3>

<p>other than <code><a href="#topic+predictPLSfromScores">predictPLSfromScores</a></code>, providing Xscores will not compute predictions of y, but the changes in the original data <code>x</code> that is associated with the specific scores
</p>


<h3>Value</h3>

<p>returns data in the original space associated with the specified values.
</p>

<hr>
<h2 id='getPLSscores'>compute 2-Block PLS scores for new data</h2><span id='topic+getPLSscores'></span>

<h3>Description</h3>

<p>compute 2-Block PLS scores for new data from an existing pls2B
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getPLSscores(pls, x, y)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getPLSscores_+3A_pls">pls</code></td>
<td>
<p>output of pls2B</p>
</td></tr>
<tr><td><code id="getPLSscores_+3A_x">x</code></td>
<td>
<p>matrix or vector representing new dataset(s) -  same kind as in original pls2B</p>
</td></tr>
<tr><td><code id="getPLSscores_+3A_y">y</code></td>
<td>
<p>matrix or vector representing new dataset(s) - same kind as in original pls2B</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns a vector of pls-scores
</p>


<h3>Note</h3>

<p>either x or y must be missing
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pls2B">pls2B</a>, <a href="#topic+predictPLSfromScores">predictPLSfromScores</a>,<a href="#topic+predictPLSfromData">predictPLSfromData</a></code>
</p>

<hr>
<h2 id='getPointAlongOutline'>Get a point along a line with a given distance from the start of the line</h2><span id='topic+getPointAlongOutline'></span>

<h3>Description</h3>

<p>Get a point along a line with a given distance from the start of the line
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getPointAlongOutline(mat, dist = 15, reverse = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getPointAlongOutline_+3A_mat">mat</code></td>
<td>
<p>matrix with rows containing sequential coordinates</p>
</td></tr>
<tr><td><code id="getPointAlongOutline_+3A_dist">dist</code></td>
<td>
<p>numeric: distance from the first point on the line.</p>
</td></tr>
<tr><td><code id="getPointAlongOutline_+3A_reverse">reverse</code></td>
<td>
<p>logical: if TRUE start from the end of the line</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns a vector containing the resulting coordinate
</p>

<hr>
<h2 id='getSides'>try to identify bilateral landmarks and sort them by side</h2><span id='topic+getSides'></span>

<h3>Description</h3>

<p>try to identify bilateral landmarks and sort them by side
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getSides(x, tol = 3, pcAlign = TRUE, icpiter = 100, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getSides_+3A_x">x</code></td>
<td>
<p>matrix containing landmarks (see details)</p>
</td></tr>
<tr><td><code id="getSides_+3A_tol">tol</code></td>
<td>
<p>maximal distance allowed between original and mirrored set.</p>
</td></tr>
<tr><td><code id="getSides_+3A_pcalign">pcAlign</code></td>
<td>
<p>logical: if TRUE orginal and mirrored landmarks will be initally aligned by their PC-axes</p>
</td></tr>
<tr><td><code id="getSides_+3A_icpiter">icpiter</code></td>
<td>
<p>integer: number of iterations in ICP alignment.</p>
</td></tr>
<tr><td><code id="getSides_+3A_...">...</code></td>
<td>
<p>more arguments passed to <code><a href="#topic+mirror">mirror</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function mirrors the landmark set and aligns it to the original. Then it tries to find pairs. If you have a sample, run a Procrustes registration first (without scaling to unit centroid size, or you later have to adapt <code>tol</code> - see examples) and then use the mean as it is usually more symmetrical.
</p>


<h3>Value</h3>

<p>returns a list containing
</p>
<table role = "presentation">
<tr><td><code>side1</code></td>
<td>
<p>integer vector containing indices of landmarks on one side</p>
</td></tr>
<tr><td><code>side2</code></td>
<td>
<p>integer vector containing indices of landmarks on the other side</p>
</td></tr>
<tr><td><code>unilat</code></td>
<td>
<p>integer vector containing indices unilateral landmarks</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data(boneData)
proc &lt;- procSym(boneLM,CSinit=FALSE)
mysides &lt;- getSides(proc$mshape)
if (interactive()){
#visualize bilateral landmarks
deformGrid3d(boneLM[mysides$side1,,1],boneLM[mysides$side2,,1])
## visualize unilateral landmarks
rgl::spheres3d(boneLM[mysides$unilat,,1],radius=0.5)
}
</code></pre>

<hr>
<h2 id='getTrafo4x4'>get 4x4 Transformation matrix</h2><span id='topic+getTrafo4x4'></span><span id='topic+getTrafo4x4.rotonto'></span>

<h3>Description</h3>

<p>get 4x4 Transformation matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getTrafo4x4(x)

## S3 method for class 'rotonto'
getTrafo4x4(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getTrafo4x4_+3A_x">x</code></td>
<td>
<p>object of class &quot;rotonto&quot;</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns a 4x4 transformation matrix
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(boneData)
rot &lt;- rotonto(boneLM[,,1],boneLM[,,2])
trafo &lt;- getTrafo4x4(rot)
</code></pre>

<hr>
<h2 id='getTrafoRotaxis'>compute a 4x4 Transformation matrix for rotation around an arbitrary axis</h2><span id='topic+getTrafoRotaxis'></span>

<h3>Description</h3>

<p>compute a 4x4 Transformation matrix for rotation around an arbitrary axis
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getTrafoRotaxis(pt1, pt2, theta)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getTrafoRotaxis_+3A_pt1">pt1</code></td>
<td>
<p>numeric vector of length 3, defining first point on the rotation
axis.</p>
</td></tr>
<tr><td><code id="getTrafoRotaxis_+3A_pt2">pt2</code></td>
<td>
<p>numeric vector of length 3, defining second point on the rotation
axis.</p>
</td></tr>
<tr><td><code id="getTrafoRotaxis_+3A_theta">theta</code></td>
<td>
<p>angle to rotate in radians. With pt1 being the viewpoint, the
rotation is counterclockwise.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>the resulting matrix can be used in <code><a href="#topic+applyTransform">applyTransform</a></code>
</p>

<hr>
<h2 id='getVisibleVertices'>find vertices visible from a given viewpoints</h2><span id='topic+getVisibleVertices'></span>

<h3>Description</h3>

<p>find vertices visible from a given viewpoints
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getVisibleVertices(mesh, viewpoints, offset = 0.001, cores = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getVisibleVertices_+3A_mesh">mesh</code></td>
<td>
<p>triangular mesh of class 'mesh3d'</p>
</td></tr>
<tr><td><code id="getVisibleVertices_+3A_viewpoints">viewpoints</code></td>
<td>
<p>vector or k x 3  matrix containing a set of viewpoints</p>
</td></tr>
<tr><td><code id="getVisibleVertices_+3A_offset">offset</code></td>
<td>
<p>value to generate an offset at the meshes surface (see notes)</p>
</td></tr>
<tr><td><code id="getVisibleVertices_+3A_cores">cores</code></td>
<td>
<p>integer: number of cores to use (not working on windows)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector with (1-based) indices of points visible from at least one of the viewpoints
</p>


<h3>Note</h3>

<p>The function tries to filter out all vertices where the line connecting each vertex with the viewpoints intersects with the mesh itself. As, technically speaking this always occurs at a distance of value=0, a mesh with a tiny offset is generated to avoid these false hits.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>SCP1 &lt;- file2mesh(system.file("extdata","SCP1.ply",package="Morpho"))
viewpoints &lt;- read.fcsv(system.file("extdata","SCP1_Endo.fcsv",package="Morpho"))
visivert &lt;- getVisibleVertices(SCP1,viewpoints)
</code></pre>

<hr>
<h2 id='groupPCA'>Perform PCA based of the group means' covariance matrix</h2><span id='topic+groupPCA'></span>

<h3>Description</h3>

<p>Calculate covariance matrix of the groupmeans and project all observations
into the eigenspace of this covariance matrix. This displays a low
dimensional between group structure of a high dimensional problem.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>groupPCA(
  dataarray,
  groups,
  rounds = 10000,
  tol = 1e-10,
  cv = TRUE,
  mc.cores = parallel::detectCores(),
  weighting = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="groupPCA_+3A_dataarray">dataarray</code></td>
<td>
<p>Either a k x m x n real array, where k is the number of
points, m is the number of dimensions, and n is the sample size. Or
alternatively a n x m Matrix where n is the numeber of observations and m
the number of variables (this can be PC scores for example)</p>
</td></tr>
<tr><td><code id="groupPCA_+3A_groups">groups</code></td>
<td>
<p>a character/factor vector containgin grouping variable.</p>
</td></tr>
<tr><td><code id="groupPCA_+3A_rounds">rounds</code></td>
<td>
<p>integer: number of permutations if a permutation test of the
euclidean distance between group means is requested.If rounds = 0, no test
is performed.</p>
</td></tr>
<tr><td><code id="groupPCA_+3A_tol">tol</code></td>
<td>
<p>threshold to ignore eigenvalues of the covariance matrix.</p>
</td></tr>
<tr><td><code id="groupPCA_+3A_cv">cv</code></td>
<td>
<p>logical: requests leaving-one-out crossvalidation</p>
</td></tr>
<tr><td><code id="groupPCA_+3A_mc.cores">mc.cores</code></td>
<td>
<p>integer: how many cores of the Computer are allowed to be
used. Default is use autodetection by using detectCores() from the parallel
package. Parallel processing is disabled on Windows due to occasional
errors.</p>
</td></tr>
<tr><td><code id="groupPCA_+3A_weighting">weighting</code></td>
<td>
<p>logical:weight between groups covariance matrix according
to group sizes.</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>eigenvalues</code></td>
<td>
<p>Non-zero eigenvalues of the groupmean covariance
matrix</p>
</td></tr>
<tr><td><code>groupPCs</code></td>
<td>
<p>PC-axes - i.e. eigenvectors of the groupmean covariance
matrix</p>
</td></tr>
<tr><td><code>Variance</code></td>
<td>
<p>table displaying the between-group variance explained by each between group PC - this only reflects the variability of the group means and NOT the variability of the data projected into that space</p>
</td></tr>
<tr><td><code>Scores</code></td>
<td>
<p>Scores of all observation in the PC-space</p>
</td></tr>
<tr><td><code>probs</code></td>
<td>
<p>p-values of pairwise groupdifferences - based on
permuation testing</p>
</td></tr>
<tr><td><code>groupdists</code></td>
<td>
<p>Euclidean distances between groups' averages</p>
</td></tr>
<tr><td><code>groupmeans</code></td>
<td>
<p>matrix with rows containing the Groupmeans, or a k x m x groupsize array if the input is a k x m x n landmark array</p>
</td></tr>
<tr><td><code>Grandmean</code></td>
<td>
<p>vector containing the Grand mean, or a matrix if the input is a k x m x n landmark array</p>
</td></tr>
<tr><td><code>CV</code></td>
<td>
<p>Cross-validated scores</p>
</td></tr>
<tr><td><code>groups</code></td>
<td>
<p>grouping Variable</p>
</td></tr>
<tr><td><code>resPCs</code></td>
<td>
<p>PCs orthogonal to the between-group PCs</p>
</td></tr>
<tr><td><code>resPCscores</code></td>
<td>
<p>Scores of the residualPCs</p>
</td></tr>
<tr><td><code>resVar</code></td>
<td>
<p>table displaying the residual variance explained by each residual PC. </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Stefan Schlager
</p>


<h3>References</h3>

<p>Mitteroecker P, Bookstein F 2011. Linear Discrimination,
Ordination, and the Visualization of Selection Gradients in Modern
Morphometrics. Evolutionary Biology 38:100-114.
</p>
<p>Boulesteix, A. L. 2005: A note on between-group PCA, International Journal
of Pure and Applied Mathematics 19, 359-366.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+CVA">CVA</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(iris)
vari &lt;- iris[,1:4]
facto &lt;- iris[,5]
pca.1 &lt;-groupPCA(vari,groups=facto,rounds=100,mc.cores=1)

### plot scores
if (require(car)) {
scatterplotMatrix(pca.1$Scores,groups=facto, ellipse=TRUE,
        by.groups=TRUE,var.labels=c("PC1","PC2","PC3"))
}
## example with shape data
data(boneData)
proc &lt;- procSym(boneLM)
pop_sex &lt;- name2factor(boneLM, which=3:4)
gpca &lt;- groupPCA(proc$orpdata, groups=pop_sex, rounds=0, mc.cores=2)
## Not run: 
## visualize shape associated with first between group PC
dims &lt;- dim(proc$mshape)
## calculate matrix containing landmarks of grandmean
grandmean &lt;-gpca$Grandmean
## calculate landmarks from first between-group PC
#                   (+2 and -2 standard deviations)
gpcavis2sd&lt;- restoreShapes(c(-2,2)*sd(gpca$Scores[,1]), gpca$groupPCs[,1], grandmean)
deformGrid3d(gpcavis2sd[,,1], gpcavis2sd[,,2], ngrid = 0,size=0.01)
require(rgl)
## visualize grandmean mesh

grandm.mesh &lt;- tps3d(skull_0144_ch_fe.mesh, boneLM[,,1],grandmean,threads=1)
wire3d(grandm.mesh, col="white")
spheres3d(grandmean, radius=0.01)

## End(Not run)


</code></pre>

<hr>
<h2 id='histGroup'>plot histogram for multiple groups.</h2><span id='topic+histGroup'></span>

<h3>Description</h3>

<p>plot a histogram for multiple groups, each group colored individually
</p>


<h3>Usage</h3>

<pre><code class='language-R'>histGroup(
  data,
  groups,
  main = paste("Histogram of", dataname),
  xlab = dataname,
  ylab,
  col = NULL,
  alpha = 0.5,
  breaks = "Sturges",
  legend = TRUE,
  legend.x = 80,
  legend.y = 80,
  legend.pch = 15,
  freq = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="histGroup_+3A_data">data</code></td>
<td>
<p>vector containing data.</p>
</td></tr>
<tr><td><code id="histGroup_+3A_groups">groups</code></td>
<td>
<p>grouping factors</p>
</td></tr>
<tr><td><code id="histGroup_+3A_main">main</code>, <code id="histGroup_+3A_xlab">xlab</code>, <code id="histGroup_+3A_ylab">ylab</code></td>
<td>
<p>these arguments to title have useful defaults here.</p>
</td></tr>
<tr><td><code id="histGroup_+3A_col">col</code></td>
<td>
<p>vector containing color for each group. If NULL, the function
&quot;rainbow&quot; is called.</p>
</td></tr>
<tr><td><code id="histGroup_+3A_alpha">alpha</code></td>
<td>
<p>numeric between 0 and 1. Sets the transparency of the colors</p>
</td></tr>
<tr><td><code id="histGroup_+3A_breaks">breaks</code></td>
<td>
<p>one of: </p>

<ul>
<li><p> a vector giving the breakpoints between histogram cells,
</p>
</li>
<li><p> a single number giving the number of cells for the histogram,
</p>
</li>
<li><p> a character string naming an algorithm to compute the number of cells (see &lsquo;Details&rsquo;),
</p>
</li>
<li><p> a function to compute the number of cells.  </p>
</li></ul>
<p> In the last three cases the number is a suggestion only.</p>
</td></tr>
<tr><td><code id="histGroup_+3A_legend">legend</code></td>
<td>
<p>logical: if TRUE, a legend is plotted</p>
</td></tr>
<tr><td><code id="histGroup_+3A_legend.x">legend.x</code></td>
<td>
<p>x position of the legend from the upper left corner</p>
</td></tr>
<tr><td><code id="histGroup_+3A_legend.y">legend.y</code></td>
<td>
<p>y position of the legend from the upper left corners</p>
</td></tr>
<tr><td><code id="histGroup_+3A_legend.pch">legend.pch</code></td>
<td>
<p>integer: define the symbol to visualise group colors
(<code><a href="graphics.html#topic+points">points</a></code>)</p>
</td></tr>
<tr><td><code id="histGroup_+3A_freq">freq</code></td>
<td>
<p>logical: if TRUE, the histogram graphic is a representation of
frequencies, the counts component of the result; if FALSE, probability
densities are plotted for each group.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Just a wrapper for the function hist from the &quot;graphics&quot; package
</p>


<h3>Author(s)</h3>

<p>Stefan Schlager
</p>


<h3>See Also</h3>

<p><code><a href="graphics.html#topic+hist">hist</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(iris)
histGroup(iris$Petal.Length,iris$Species)


</code></pre>

<hr>
<h2 id='icpmat'>match two landmark configurations using iteratively closest point search</h2><span id='topic+icpmat'></span>

<h3>Description</h3>

<p>match two landmark configurations using iteratively closest point search
</p>


<h3>Usage</h3>

<pre><code class='language-R'>icpmat(
  x,
  y,
  iterations,
  mindist = 1e+15,
  subsample = NULL,
  type = c("rigid", "similarity", "affine"),
  weights = NULL,
  threads = 1,
  centerweight = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="icpmat_+3A_x">x</code></td>
<td>
<p>moving landmarks</p>
</td></tr>
<tr><td><code id="icpmat_+3A_y">y</code></td>
<td>
<p>target landmarks</p>
</td></tr>
<tr><td><code id="icpmat_+3A_iterations">iterations</code></td>
<td>
<p>integer: number of iterations</p>
</td></tr>
<tr><td><code id="icpmat_+3A_mindist">mindist</code></td>
<td>
<p>restrict valid points to be within this distance</p>
</td></tr>
<tr><td><code id="icpmat_+3A_subsample">subsample</code></td>
<td>
<p>use a subsample determined by kmean clusters to speed up computation</p>
</td></tr>
<tr><td><code id="icpmat_+3A_type">type</code></td>
<td>
<p>character: select the transform to be applied, can be &quot;rigid&quot;,&quot;similarity&quot; or &quot;affine&quot;</p>
</td></tr>
<tr><td><code id="icpmat_+3A_weights">weights</code></td>
<td>
<p>vector of length <code>nrow(x)</code> containing weights for each row in <code>x</code></p>
</td></tr>
<tr><td><code id="icpmat_+3A_threads">threads</code></td>
<td>
<p>integer: number of threads to use.</p>
</td></tr>
<tr><td><code id="icpmat_+3A_centerweight">centerweight</code></td>
<td>
<p>logical: if weights are defined and centerweigths=TRUE, the matrix will be centered according to these weights instead of the barycenter.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns the rotated landmarks
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(nose)
icp &lt;- icpmat(shortnose.lm,longnose.lm,iterations=10)

## example using weights
## we want to assign high weights to the first three cordinates
icpw &lt;- icpmat(shortnose.lm,longnose.lm,iterations=10,
               weights=c(rep(100,3),rep(1,620)),centerweight = TRUE)
## the RMSE between those four points and the target is now smaller:
require(Rvcg)
RMSE &lt;- sqrt(sum(vcgKDtree(longnose.lm,icp[1:3,],k=1)$distance^2))
RMSEW&lt;- sqrt(sum(vcgKDtree(longnose.lm,icpw[1:3,],k=1)$distance^2))
barplot(c(RMSE,RMSEW),names.arg=c("RMSE weighted","RMSE unweighted"))
## Not run: 
## plot the differences between unweighted and weighted icp
deformGrid3d(icp,icpw)
## plot the first four coordinates from the icps:
spheres3d(icp[1:3,],col="red",radius = 0.5)
spheres3d(icpw[1:3,],col="green",radius = 0.5)
## plot the target
spheres3d(longnose.lm,col="yellow",radius = 0.2)

## End(Not run)
##2D example  using icpmat to determine point correspondences
if (require(shapes)) {
## we scramble rows to show that this is independent of point order
moving &lt;- gorf.dat[sample(1:8),,1]
plot(moving,asp=1) ## starting config
icpgorf &lt;- icpmat(moving,gorf.dat[,,2],iterations = 20)
points(icpgorf,asp = 1,col=2)
points(gorf.dat[,,2],col=3)## target

## get correspondences using nearest neighbour search
index &lt;- mcNNindex(icpgorf,gorf.dat[,,2],k=1,cores=1)
icpsort &lt;- icpgorf[index,]
for (i in 1:8)
lines(rbind(icpsort[i,],gorf.dat[i,,2]))
}
</code></pre>

<hr>
<h2 id='invertFaces'>invert faces' orientation of triangular mesh</h2><span id='topic+invertFaces'></span>

<h3>Description</h3>

<p>inverts faces' orientation of triangular mesh and recomputes vertex normals
</p>


<h3>Usage</h3>

<pre><code class='language-R'>invertFaces(mesh)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="invertFaces_+3A_mesh">mesh</code></td>
<td>
<p>triangular mesh of class <code>mesh3d</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns resulting mesh
</p>


<h3>Author(s)</h3>

<p>Stefan Schlager
</p>


<h3>See Also</h3>

<p><code><a href="#topic+updateNormals">updateNormals</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

data(nose)
## Not run: 
rgl::shade3d(shortnose.mesh,col=3)

## End(Not run)
noseinvert &lt;- invertFaces(shortnose.mesh)
## show normals
## Not run: 
plotNormals(noseinvert,long=0.01)

## End(Not run)
</code></pre>

<hr>
<h2 id='kendalldist'>Calculates the Riemannian distance between two superimposed landmark
configs.</h2><span id='topic+kendalldist'></span>

<h3>Description</h3>

<p>Calculates the Riemannian distance between two superimposed landmark
configs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kendalldist(x, y)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="kendalldist_+3A_x">x</code></td>
<td>
<p>Matrix containing landmark coordinates.</p>
</td></tr>
<tr><td><code id="kendalldist_+3A_y">y</code></td>
<td>
<p>Matrix containing landmark coordinates.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns Riemannian distance
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(require(shapes)) {
OPA &lt;- rotonto(gorf.dat[,,1],gorf.dat[,,2])
kendalldist(OPA$X,OPA$Y)
}
</code></pre>

<hr>
<h2 id='line2plane'>get intersection between a line and a plane</h2><span id='topic+line2plane'></span>

<h3>Description</h3>

<p>get intersection between a line and a plane
</p>


<h3>Usage</h3>

<pre><code class='language-R'>line2plane(ptLine, ptDir, planePt, planeNorm)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="line2plane_+3A_ptline">ptLine</code></td>
<td>
<p>vector of length 3: point on line</p>
</td></tr>
<tr><td><code id="line2plane_+3A_ptdir">ptDir</code></td>
<td>
<p>vector of length 3: direction vector of line</p>
</td></tr>
<tr><td><code id="line2plane_+3A_planept">planePt</code></td>
<td>
<p>vector of length 3: point on plane</p>
</td></tr>
<tr><td><code id="line2plane_+3A_planenorm">planeNorm</code></td>
<td>
<p>vector of length 3: plane normal vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>hit point
</p>


<h3>Note</h3>

<p>in case you only have three points on a plane (named <code>pt1, pt2, pt3</code> you can get the plane's normal by calling <code>crossProduct(pt1-pt2,pt1-pt3)</code>.
</p>

<hr>
<h2 id='lineplot'>plot lines between landmarks</h2><span id='topic+lineplot'></span>

<h3>Description</h3>

<p>add lines connecting landmarks to visualise a sort of wireframe
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lineplot(
  x,
  point,
  col = 1,
  lwd = 1,
  line_antialias = FALSE,
  lty = 1,
  add = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lineplot_+3A_x">x</code></td>
<td>
<p>matrix containing 2D or 3D landmarks</p>
</td></tr>
<tr><td><code id="lineplot_+3A_point">point</code></td>
<td>
<p>vector or list of vectors containing rowindices of x,
determining which landmarks to connect.</p>
</td></tr>
<tr><td><code id="lineplot_+3A_col">col</code></td>
<td>
<p>color of lines</p>
</td></tr>
<tr><td><code id="lineplot_+3A_lwd">lwd</code></td>
<td>
<p>line width</p>
</td></tr>
<tr><td><code id="lineplot_+3A_line_antialias">line_antialias</code></td>
<td>
<p>logical: smooth lines</p>
</td></tr>
<tr><td><code id="lineplot_+3A_lty">lty</code></td>
<td>
<p>line type (only for 2D case)</p>
</td></tr>
<tr><td><code id="lineplot_+3A_add">add</code></td>
<td>
<p>logical: add to existing plot</p>
</td></tr>
</table>


<h3>Note</h3>

<p>works with 2D and 3D configurations
</p>


<h3>Author(s)</h3>

<p>Stefan Schlager
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pcaplot3d">pcaplot3d</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

if (require(shapes)) {
##2D example
plot(gorf.dat[,,1],asp=1)
lineplot(gorf.dat[,,1],point=c(1,5:2,8:6,1),col=2)
}
##3D example
## Not run: 
require(rgl)
data(nose)
points3d(shortnose.lm[1:9,])
lineplot(shortnose.lm[1:9,],point=list(c(1,3,2),c(3,4,5),c(8,6,5,7,9)),col=2)

## End(Not run)

</code></pre>

<hr>
<h2 id='list2array'>converts a list of matrices to an array</h2><span id='topic+list2array'></span>

<h3>Description</h3>

<p>converts a list of matrices to an array
</p>


<h3>Usage</h3>

<pre><code class='language-R'>list2array(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="list2array_+3A_x">x</code></td>
<td>
<p>a list containing matrices of the same dimensionality</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns an array concatenating all matrices
</p>

<hr>
<h2 id='LPS2RAS'>convert data from LPS to RAS space and back</h2><span id='topic+LPS2RAS'></span>

<h3>Description</h3>

<p>convert data from LPS to RAS space and back
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LPS2RAS(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="LPS2RAS_+3A_x">x</code></td>
<td>
<p>mesh of class <code>mesh3d</code> or a matrix with 3D Landmarks</p>
</td></tr>
</table>


<h3>Details</h3>

<p>As e.g. the Slicer versions &gt;= 4.11 are using LPS space, it might be needed to transform data like fiducials and surface models from and back to that space.
</p>


<h3>Value</h3>

<p>returns the rotated data
</p>

<hr>
<h2 id='mcNNindex'>find nearest neighbours for 2D and 3D point clouds</h2><span id='topic+mcNNindex'></span>

<h3>Description</h3>

<p>find nearest neighbours for point clouds using a kd-tree search. This is just a wrapper of the function vcgKDtree from
package Rvcg. Wwraps the function <code>vcgKDtree</code> from package 'Rvcg' (for backward compatibility )
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mcNNindex(target, query, cores = parallel::detectCores(), k = k, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mcNNindex_+3A_target">target</code></td>
<td>
<p><code>k x m</code> matrix containing data which to search.</p>
</td></tr>
<tr><td><code id="mcNNindex_+3A_query">query</code></td>
<td>
<p><code>l x m</code> matrix containing data for which to search.</p>
</td></tr>
<tr><td><code id="mcNNindex_+3A_cores">cores</code></td>
<td>
<p>integer: amount of CPU-cores to be used. Only available on systems with OpenMP support.</p>
</td></tr>
<tr><td><code id="mcNNindex_+3A_k">k</code></td>
<td>
<p>integer: how many closest points are sought.</p>
</td></tr>
<tr><td><code id="mcNNindex_+3A_...">...</code></td>
<td>
<p>additional arguments - currently unused.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>l x k </code> matrix containing indices of closest points.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+closemeshKD">closemeshKD</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
require(rgl)
data(nose)
# find closest vertex on surface for each landmark
clost &lt;- mcNNindex(vert2points(shortnose.mesh),shortnose.lm, k=1,
mc.cores=1)
## Not run: 
spheres3d(vert2points(shortnose.mesh)[clost,],col=2,radius=0.3)
spheres3d(shortnose.lm,radius=0.3)
wire3d(shortnose.mesh)

## End(Not run)
</code></pre>

<hr>
<h2 id='mergeMeshes'>merge multiple triangular meshes into a single one</h2><span id='topic+mergeMeshes'></span>

<h3>Description</h3>

<p>merge multiple triangular meshes into a single one, preserving color and
vertex normals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mergeMeshes(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mergeMeshes_+3A_...">...</code></td>
<td>
<p>triangular meshes of class <code>'mesh3d'</code> to merge or a list
of triangular meshes.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns the meshes merged into a single one.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mesh2ply">mesh2ply</a>, <a href="#topic+file2mesh">file2mesh</a>, <a href="#topic+ply2mesh">ply2mesh</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
require(rgl)
data(boneData)
data(nose)
mergedMesh &lt;- mergeMeshes(shortnose.mesh, skull_0144_ch_fe.mesh)
require(rgl)
shade3d(mergedMesh, col=3)

## End(Not run)

</code></pre>

<hr>
<h2 id='mesh2grey'>convert a colored mesh to greyscale.</h2><span id='topic+mesh2grey'></span>

<h3>Description</h3>

<p>convert the colors of a colored mesh to greyscale values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mesh2grey(mesh)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mesh2grey_+3A_mesh">mesh</code></td>
<td>
<p>Object of class mesh3d</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns a mesh with material$color replaced by greyscale rgb values.
</p>


<h3>Author(s)</h3>

<p>Stefan Schlager
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ply2mesh">ply2mesh</a></code>,<code><a href="#topic+file2mesh">file2mesh</a></code>
</p>

<hr>
<h2 id='mesh2obj'>export mesh objects to disk</h2><span id='topic+mesh2obj'></span><span id='topic+mesh2ply'></span>

<h3>Description</h3>

<p>export mesh objects to disk.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mesh2obj(x, filename = dataname, writeNormals = TRUE)

mesh2ply(x, filename = dataname, col = NULL, writeNormals = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mesh2obj_+3A_x">x</code></td>
<td>
<p>object of class <code>mesh3d</code> - see rgl documentation for further
details or a matrix containing vertices, this can either be a <code>k x 3</code>
or a <code>3 x k</code> matrix, with rows or columns containing vertex
coordinates.</p>
</td></tr>
<tr><td><code id="mesh2obj_+3A_filename">filename</code></td>
<td>
<p>character: Path/name of the requested output - extension
will be added atuomatically. If not specified, the file will be named as the
exported object.</p>
</td></tr>
<tr><td><code id="mesh2obj_+3A_writenormals">writeNormals</code></td>
<td>
<p>logical: if TRUE, existing normals of a mesh are written
to file - can slow things down for very large meshes.</p>
</td></tr>
<tr><td><code id="mesh2obj_+3A_col">col</code></td>
<td>
<p>Writes color information to ply file. Can be either a single
color value or a vector containing a color value for each vertex of the
mesh.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>export an object of class <code>mesh3d</code> or a set of coordinates to a common
mesh file.
</p>


<h3>Note</h3>

<p>meshes containing quadrangular faces will be converted to triangular meshes by splitting the faces.
Additionally, mesh2obj is now simply a wrapper of <code>Rvcg::vcgObjWrite</code>.
</p>


<h3>Author(s)</h3>

<p>Stefan Schlager
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ply2mesh">ply2mesh</a>, <a href="#topic+quad2trimesh">quad2trimesh</a> </code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
require(rgl)
vb &lt;- c(-1.8,-1.8,-1.8,1.0,1.8,-1.8,-1.8,1.0,-1.8,1.8,-1.8,1.0,1.8,
1.8,-1.8,1.0,-1.8,-1.8,1.8,1.0,1.8,
-1.8,1.8,1.0,-1.8,1.8,1.8,1.0,1.8,1.8,1.8,1.0)
it &lt;- c(2,1,3,3,4,2,3,1,5,5,7,3,5,1,2,2,6,5,6,8,7,7,5,6,7,8,4,4,3,7,4,8,6,6,2,4)
vb &lt;- matrix(vb,4,8) ##create vertex matrix
it &lt;- matrix(it,3,12) ## create face matrix
cube&lt;-list(vb=vb,it=it)
class(cube) &lt;- "mesh3d"
## Not run: 
shade3d(cube,col=3) ## view the green cube

## End(Not run)
mesh2ply(cube,filename="cube") # write cube to a file called cube.ply
unlink("cube.ply")
</code></pre>

<hr>
<h2 id='meshcube'>calculate the corners of a mesh's bouning box</h2><span id='topic+meshcube'></span>

<h3>Description</h3>

<p>calculate the corners of a mesh's bouning box
</p>


<h3>Usage</h3>

<pre><code class='language-R'>meshcube(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="meshcube_+3A_x">x</code></td>
<td>
<p>object of class 'mesh3d'</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns a 8 x 3 matrix with the coordinates of the corners of the
bounding box.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
require(rgl)
data(boneData)
mc &lt;- meshcube(skull_0144_ch_fe.mesh)
## Not run: 
spheres3d(mc)
wire3d(skull_0144_ch_fe.mesh)

## End(Not run)

</code></pre>

<hr>
<h2 id='meshDist'>calculates and visualises distances between surface meshes or 3D coordinates and a surface mesh.</h2><span id='topic+meshDist'></span><span id='topic+meshDist.mesh3d'></span><span id='topic+meshDist.matrix'></span>

<h3>Description</h3>

<p>calculates and visualises distances between surface meshes or 3D coordinates
and a surface mesh.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>meshDist(x, ...)

## S3 method for class 'mesh3d'
meshDist(
  x,
  mesh2 = NULL,
  distvec = NULL,
  from = NULL,
  to = NULL,
  steps = 20,
  ceiling = FALSE,
  rampcolors = colorRamps::blue2green2red(steps - 1),
  NAcol = "white",
  file = "default",
  imagedim = "100x800",
  uprange = 1,
  ray = FALSE,
  raytol = 50,
  raystrict = FALSE,
  save = FALSE,
  plot = TRUE,
  sign = TRUE,
  tol = NULL,
  tolcol = "green",
  displace = FALSE,
  shade = TRUE,
  method = c("vcglib", "morpho"),
  add = FALSE,
  scaleramp = TRUE,
  threads = 1,
  titleplot = "Distance in mm",
  ...
)

## S3 method for class 'matrix'
meshDist(
  x,
  mesh2 = NULL,
  distvec = NULL,
  from = NULL,
  to = NULL,
  steps = 20,
  ceiling = FALSE,
  rampcolors = colorRamps::blue2green2red(steps - 1),
  NAcol = "white",
  uprange = 1,
  plot = TRUE,
  sign = TRUE,
  tol = NULL,
  tolcol = "green",
  type = c("s", "p"),
  radius = NULL,
  displace = FALSE,
  add = FALSE,
  scaleramp = FALSE,
  titleplot = "Distance in mm",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="meshDist_+3A_x">x</code></td>
<td>
<p>reference mesh; object of class &quot;mesh3d&quot; or a n x 3 matrix
containing 3D coordinates.</p>
</td></tr>
<tr><td><code id="meshDist_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code><a href="rgl.html#topic+shade3d">shade3d</a></code>. See
<code><a href="rgl.html#topic+material3d">material3d</a></code> for details.</p>
</td></tr>
<tr><td><code id="meshDist_+3A_mesh2">mesh2</code></td>
<td>
<p>target mesh: either object of class &quot;mesh3d&quot; or a character
pointing to a surface mesh (ply, obj or stl file)</p>
</td></tr>
<tr><td><code id="meshDist_+3A_distvec">distvec</code></td>
<td>
<p>vector: optional, a vector containing distances for each
vertex/coordinate of <code>x</code>, if distvec != NULL, <code>mesh2</code> will be ignored.</p>
</td></tr>
<tr><td><code id="meshDist_+3A_from">from</code></td>
<td>
<p>numeric: minimum distance to be colorised; default is set to 0
mm</p>
</td></tr>
<tr><td><code id="meshDist_+3A_to">to</code></td>
<td>
<p>numeric: maximum distance to be colorised; default is set to the
maximum distance</p>
</td></tr>
<tr><td><code id="meshDist_+3A_steps">steps</code></td>
<td>
<p>integer: determines break points for color ramp: n steps will
produce n-1 colors.</p>
</td></tr>
<tr><td><code id="meshDist_+3A_ceiling">ceiling</code></td>
<td>
<p>logical: if TRUE, the next larger integer of &quot;to&quot; is used</p>
</td></tr>
<tr><td><code id="meshDist_+3A_rampcolors">rampcolors</code></td>
<td>
<p>character vector: specify the colors which are used to create a colorramp.</p>
</td></tr>
<tr><td><code id="meshDist_+3A_nacol">NAcol</code></td>
<td>
<p>character: specify color for values outside the range defined by <code>from</code> and <code>to</code>.</p>
</td></tr>
<tr><td><code id="meshDist_+3A_file">file</code></td>
<td>
<p>character: filename for mesh and image files produced. E.g.
&quot;mydist&quot; will produce the files mydist.ply and mydist.png</p>
</td></tr>
<tr><td><code id="meshDist_+3A_imagedim">imagedim</code></td>
<td>
<p>character of type 100x200 where 100 determines the width and
200 the height of the image.</p>
</td></tr>
<tr><td><code id="meshDist_+3A_uprange">uprange</code></td>
<td>
<p>numeric between 0 and 1: restricts &quot;to&quot; to a quantile of
&quot;to&quot;, if to is NULL.</p>
</td></tr>
<tr><td><code id="meshDist_+3A_ray">ray</code></td>
<td>
<p>logical: if TRUE, the search is along vertex normals.</p>
</td></tr>
<tr><td><code id="meshDist_+3A_raytol">raytol</code></td>
<td>
<p>maximum distance to follow a normal.</p>
</td></tr>
<tr><td><code id="meshDist_+3A_raystrict">raystrict</code></td>
<td>
<p>logical: if TRUE, only outward along normals will be sought for closest points.</p>
</td></tr>
<tr><td><code id="meshDist_+3A_save">save</code></td>
<td>
<p>logical: save a colored mesh.</p>
</td></tr>
<tr><td><code id="meshDist_+3A_plot">plot</code></td>
<td>
<p>logical: visualise result as 3D-plot and distance charts</p>
</td></tr>
<tr><td><code id="meshDist_+3A_sign">sign</code></td>
<td>
<p>logical: request signed distances. Only meaningful, if mesh2 is
specified or distvec contains signed distances.</p>
</td></tr>
<tr><td><code id="meshDist_+3A_tol">tol</code></td>
<td>
<p>numeric: threshold to color distances within this threshold
green.</p>
</td></tr>
<tr><td><code id="meshDist_+3A_tolcol">tolcol</code></td>
<td>
<p>a custom color to color vertices below a threshold defined by <code>tol</code>. Default is green.</p>
</td></tr>
<tr><td><code id="meshDist_+3A_displace">displace</code></td>
<td>
<p>logical: if TRUE, displacement vectors between original and
closest points are drawn colored according to the distance.</p>
</td></tr>
<tr><td><code id="meshDist_+3A_shade">shade</code></td>
<td>
<p>logical: if FALSE, the rendering of the colored surface will be
supressed.</p>
</td></tr>
<tr><td><code id="meshDist_+3A_method">method</code></td>
<td>
<p>accepts: &quot;vcglib&quot; and &quot;morpho&quot; (and any abbreviation). vcglib
uses a command line tool using vcglib headers, morpho uses fortran routines
based on a kd-tree search for closest triangles.</p>
</td></tr>
<tr><td><code id="meshDist_+3A_add">add</code></td>
<td>
<p>logical: if TRUE, visualization will be added to the rgl window currently in focus</p>
</td></tr>
<tr><td><code id="meshDist_+3A_scaleramp">scaleramp</code></td>
<td>
<p>logical: if TRUE, the colorramp will be symmetrical for signed distances: spanning from <code>-max(from,to)</code> to <code>max(from,to)</code>.</p>
</td></tr>
<tr><td><code id="meshDist_+3A_threads">threads</code></td>
<td>
<p>integer: number of threads to use. 0 = let system decide.</p>
</td></tr>
<tr><td><code id="meshDist_+3A_titleplot">titleplot</code></td>
<td>
<p>character: axis description of heatmap.</p>
</td></tr>
<tr><td><code id="meshDist_+3A_type">type</code></td>
<td>
<p>character: &quot;s&quot; shows coordinates as spheres, while &quot;p&quot; shows 3D
dots.</p>
</td></tr>
<tr><td><code id="meshDist_+3A_radius">radius</code></td>
<td>
<p>determines size of spheres; if not specified, optimal radius
size will be estimated by centroid size of the configuration.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>calculates the distances from a mesh or a set of 3D coordinates to another
at each vertex; either closest point or along the normals
</p>


<h3>Value</h3>

<p>Returns an object of class &quot;meshDist&quot; if the input is a surface mesh
and one of class &quot;matrixDist&quot; if input is a matrix containing 3D
coordinates.
</p>
<table role = "presentation">
<tr><td><code>colMesh</code></td>
<td>
<p>object of mesh3d with colors added</p>
</td></tr>
<tr><td><code>dists</code></td>
<td>
<p>vector with distances</p>
</td></tr>
<tr><td><code>cols</code></td>
<td>
<p>vector with color values</p>
</td></tr>
<tr><td><code>params</code></td>
<td>
<p>list of parameters used</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Stefan Schlager
</p>


<h3>References</h3>

<p>Detection of inside/outside uses the algorithm proposed in:
</p>
<p>Baerentzen, Jakob Andreas. &amp; Aanaes, H., 2002. Generating Signed Distance
Fields From Triangle Meshes. Informatics and Mathematical Modelling, .
</p>


<h3>See Also</h3>

<p><code><a href="#topic+render.meshDist">render.meshDist</a></code>, , <code><a href="#topic+export.meshDist">export.meshDist</a></code>,
<code><a href="rgl.html#topic+shade3d">shade3d</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(nose)##load data
##warp a mesh onto another landmark configuration:
longnose.mesh &lt;- tps3d(shortnose.mesh, shortnose.lm, longnose.lm,threads=1)
## Not run: 
mD &lt;- meshDist(longnose.mesh, shortnose.mesh)
##now change the color ramp
render(mD,rampcolors = c("white","red"))

## End(Not run)
#use unsigned distances and a ramp from blue to red
#color distances &lt; 0.01 green:
## Not run: 
meshDist(longnose.mesh, shortnose.mesh, rampcolors = c("blue", "red"),sign=FALSE, tol=0.5)

## End(Not run)
</code></pre>

<hr>
<h2 id='meshPlaneIntersect'>get intersections between mesh and a plane</h2><span id='topic+meshPlaneIntersect'></span>

<h3>Description</h3>

<p>get intersections between mesh and a plane
</p>


<h3>Usage</h3>

<pre><code class='language-R'>meshPlaneIntersect(mesh, v1, v2 = NULL, v3 = NULL, normal = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="meshPlaneIntersect_+3A_mesh">mesh</code></td>
<td>
<p>triangular mesh of class &quot;mesh3d&quot;</p>
</td></tr>
<tr><td><code id="meshPlaneIntersect_+3A_v1">v1</code></td>
<td>
<p>numeric vector of length=3 specifying a point on the separating plane</p>
</td></tr>
<tr><td><code id="meshPlaneIntersect_+3A_v2">v2</code></td>
<td>
<p>numeric vector of length=3 specifying a point on the separating plane</p>
</td></tr>
<tr><td><code id="meshPlaneIntersect_+3A_v3">v3</code></td>
<td>
<p>numeric vector of length=3 specifying a point on the separating plane</p>
</td></tr>
<tr><td><code id="meshPlaneIntersect_+3A_normal">normal</code></td>
<td>
<p>plane normal (overrides specification by v2 and v3)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns the intersections of edges and the plane
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(nose)
v1 &lt;- shortnose.lm[1,]
v2 &lt;- shortnose.lm[2,]
v3 &lt;- shortnose.lm[3,]
intersect &lt;- meshPlaneIntersect(shortnose.mesh,v1,v2,v3)
## Not run: 
require(rgl)
wire3d(shortnose.mesh)
spheres3d(shortnose.lm[1:3,],col=2)#the plane
spheres3d(intersect,col=3,radius = 0.2)#intersections

## End(Not run)
</code></pre>

<hr>
<h2 id='meshres'>calculate average edge length of a triangular mesh</h2><span id='topic+meshres'></span>

<h3>Description</h3>

<p>calculate average edge length of a triangular mesh, by iterating over all
faces.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>meshres(mesh)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="meshres_+3A_mesh">mesh</code></td>
<td>
<p>triangular mesh stored as object of class &quot;mesh3d&quot;</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns average edge length (a.k.a. mesh resolution)
</p>


<h3>Author(s)</h3>

<p>Stefan Schlager
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(boneData)
mres &lt;- meshres(skull_0144_ch_fe.mesh)


</code></pre>

<hr>
<h2 id='mirror'>mirror landmarks or triangular mesh in place</h2><span id='topic+mirror'></span><span id='topic+mirror.matrix'></span><span id='topic+mirror.mesh3d'></span>

<h3>Description</h3>

<p>mirror landmarks or triangular mesh in place
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mirror(
  x,
  icpiter = 50,
  subsample = NULL,
  pcAlign = FALSE,
  mirroraxis = 1,
  initPC = TRUE,
  initCenter = TRUE,
  v1 = NULL,
  v2 = NULL,
  v3 = NULL,
  normal = NULL,
  mc.cores = 2
)

## S3 method for class 'matrix'
mirror(
  x,
  icpiter = 50,
  subsample = NULL,
  pcAlign = FALSE,
  mirroraxis = 1,
  initPC = TRUE,
  initCenter = TRUE,
  v1 = NULL,
  v2 = NULL,
  v3 = NULL,
  normal = NULL,
  mc.cores = 2
)

## S3 method for class 'mesh3d'
mirror(
  x,
  icpiter = 50,
  subsample = NULL,
  pcAlign = FALSE,
  mirroraxis = 1,
  initPC = TRUE,
  initCenter = TRUE,
  v1 = NULL,
  v2 = NULL,
  v3 = NULL,
  normal = NULL,
  mc.cores = 2
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mirror_+3A_x">x</code></td>
<td>
<p>k x 3 matrix or mesh3d</p>
</td></tr>
<tr><td><code id="mirror_+3A_icpiter">icpiter</code></td>
<td>
<p>integer: number of iterations to match reflected configuration onto original one</p>
</td></tr>
<tr><td><code id="mirror_+3A_subsample">subsample</code></td>
<td>
<p>integer: use only a subset for icp matching</p>
</td></tr>
<tr><td><code id="mirror_+3A_pcalign">pcAlign</code></td>
<td>
<p>if TRUE, the icp will be preceeded by an alignment of the principal axis (only used if icpiter &gt; 0), currently only works for 3D data.</p>
</td></tr>
<tr><td><code id="mirror_+3A_mirroraxis">mirroraxis</code></td>
<td>
<p>integer: which axis to mirror at</p>
</td></tr>
<tr><td><code id="mirror_+3A_initpc">initPC</code></td>
<td>
<p>logical: if TRUE the data will be prealigned by its principal axes.</p>
</td></tr>
<tr><td><code id="mirror_+3A_initcenter">initCenter</code></td>
<td>
<p>logical: if TRUE and <code>initPC=FALSE</code>, <code>x</code> will be translated to its centroid before mirroring.</p>
</td></tr>
<tr><td><code id="mirror_+3A_v1">v1</code></td>
<td>
<p>point on plane</p>
</td></tr>
<tr><td><code id="mirror_+3A_v2">v2</code></td>
<td>
<p>if normal=NULL, the plane will be defined by three points <code>v1, v2, v3</code></p>
</td></tr>
<tr><td><code id="mirror_+3A_v3">v3</code></td>
<td>
<p>if normal=NULL, the plane will be defined by three points <code>v1, v2, v3</code></p>
</td></tr>
<tr><td><code id="mirror_+3A_normal">normal</code></td>
<td>
<p>plane normal (overrides specification by v2 and v3)</p>
</td></tr>
<tr><td><code id="mirror_+3A_mc.cores">mc.cores</code></td>
<td>
<p>use parallel processing to find best alignment to original shape.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>reflect a mesh configuration at the plane spanned by its first 2 principal axis, then try to rigidily register the reflected configuration onto the original one using iterative closest point search to establish correspondences.
Also, if a reflection plane is defined, <code>pcAlign</code>, <code>initPC</code>, <code>initCenter</code> and <code>mirroraxis</code> will be ignored and the object will be mirrored on the defined plane (and optionally aligned using an ICP approach).
</p>


<h3>Value</h3>

<p>returns the reflected object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(boneData)
boneMir &lt;- mirror(boneLM[,,1],icpiter=50,mc.cores=2,mirroraxis=3)

### mirror on 3 midsaggital landmarks and then optimize it with an ICP
boneMirPlane &lt;- mirror(boneLM[,,1],v1=boneLM[1,,1],v2=boneLM[2,,1],v3=boneLM[9,,1])

## 2D Example:
if (require(shapes)) {
gorfMir &lt;- mirror(gorf.dat[,,1],mirroraxis=2,pcAlign=TRUE,icpiter = 0)
plot(gorfMir,asp = 1)
points(gorf.dat[,,1],col=3)
}
## Not run: 
## now mirror a complete mesh
require(rgl)
skullMir &lt;- mirror(skull_0144_ch_fe.mesh,icpiter=10,subsample = 30,
                   mc.cores=2,mirroraxis=3,pcAlign=TRUE)
###compare result to original
wire3d(skull_0144_ch_fe.mesh,col=3)
wire3d(skullMir,col=2)

## End(Not run)
</code></pre>

<hr>
<h2 id='mirror2plane'>mirror points or mesh on an arbitrary plane</h2><span id='topic+mirror2plane'></span><span id='topic+mirror2plane.matrix'></span><span id='topic+mirror2plane.mesh3d'></span>

<h3>Description</h3>

<p>mirror points or mesh on an arbitrary plane
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mirror2plane(x, v1, normal = NULL, v2 = NULL, v3 = NULL)

## S3 method for class 'matrix'
mirror2plane(x, v1, normal = NULL, v2 = NULL, v3 = NULL)

## S3 method for class 'mesh3d'
mirror2plane(x, v1, normal = NULL, v2 = NULL, v3 = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mirror2plane_+3A_x">x</code></td>
<td>
<p>x 3D-vector or a k x 3 matrix with 3D vectors stored in rows. Or a triangular mesh of class mesh3d</p>
</td></tr>
<tr><td><code id="mirror2plane_+3A_v1">v1</code></td>
<td>
<p>point on plane</p>
</td></tr>
<tr><td><code id="mirror2plane_+3A_normal">normal</code></td>
<td>
<p>plane normal (overrides specification by v2 and v3)</p>
</td></tr>
<tr><td><code id="mirror2plane_+3A_v2">v2</code></td>
<td>
<p>if pNorm=NULL, the plane will be defined by three points <code>v1, v2, v3</code></p>
</td></tr>
<tr><td><code id="mirror2plane_+3A_v3">v3</code></td>
<td>
<p>if pNorm=NULL, the plane will be defined by three points <code>v1, v2, v3</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>mirrored coordinates mesh
</p>


<h3>Examples</h3>

<pre><code class='language-R'># mirror mesh on plane spanned by 3 midsagital landmarks
data(boneData)
mirrmesh &lt;- mirror2plane(skull_0144_ch_fe.mesh,v1=boneLM[1,,1],v2=boneLM[9,,1],v3=boneLM[10,,1])
</code></pre>

<hr>
<h2 id='name2factor'>extract data from array names</h2><span id='topic+name2factor'></span><span id='topic+name2num'></span>

<h3>Description</h3>

<p>extract data from array names
</p>


<h3>Usage</h3>

<pre><code class='language-R'>name2factor(x, sep = "_", which, collapse = sep, as.factor = TRUE)

name2num(x, sep = "_", which, collapse = sep, dif = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="name2factor_+3A_x">x</code></td>
<td>
<p>data, can be a three-dimensional array, a matrix, a named list or a
vector containing names to split</p>
</td></tr>
<tr><td><code id="name2factor_+3A_sep">sep</code></td>
<td>
<p>character by which to split the strings</p>
</td></tr>
<tr><td><code id="name2factor_+3A_which">which</code></td>
<td>
<p>integer or vector of integers, if more entries are selected,
they will be concatenated by the string specified with the option
'collapse'.</p>
</td></tr>
<tr><td><code id="name2factor_+3A_collapse">collapse</code></td>
<td>
<p>character by which to collapse data if two strings are to be
concatenated</p>
</td></tr>
<tr><td><code id="name2factor_+3A_as.factor">as.factor</code></td>
<td>
<p>logical: if TRUE, a factor vector will be returned, strings otherwise.</p>
</td></tr>
<tr><td><code id="name2factor_+3A_dif">dif</code></td>
<td>
<p>logical: calculate difference if two fields containing numbers
are selected.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>extract data from array names and convert to factors or numbers
</p>
<p>If an array is used as input, the data info is expected to be in the 3rd
dimension, for a matrix, rownames are used.
</p>


<h3>Value</h3>

<p>returns a vector containing factors or numbers
</p>


<h3>Author(s)</h3>

<p>Stefan Schlager
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

data &lt;- matrix(rnorm(200),100,2)
id &lt;- paste("id",1:100,sep="")
pop &lt;- c(rep("pop1",50),rep("pop2",50))
sex &lt;- c(rep("male",50),rep("female",50))
age &lt;- floor(rnorm(100,mean=50,sd=10))
rownames(data) &lt;- paste(id,pop,sex,age,sep="_")
infos &lt;- data.frame(pop=name2factor(data,which=2))
infos$age &lt;- name2num(data,which=4)
infos$pop.sex &lt;- name2factor(data,which=2:3)


</code></pre>

<hr>
<h2 id='NNshapeReg'>Estimate the shape by averaging the shape of the nearest neighbours.</h2><span id='topic+NNshapeReg'></span>

<h3>Description</h3>

<p>Estimate the shape of one set of landmarks by averaging the shape of the
nearest neighbours obtained by a second set of landmarks. Weights are
calculated either form Mahalanobis or Procrustes distances. This can be
useful for data with missing landmarks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NNshapeReg(
  x,
  y = NULL,
  n = 3,
  mahalanobis = FALSE,
  mc.cores = parallel::detectCores()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="NNshapeReg_+3A_x">x</code></td>
<td>
<p>an array or matrix (one row per specim) with data used for
estimating weights.</p>
</td></tr>
<tr><td><code id="NNshapeReg_+3A_y">y</code></td>
<td>
<p>an array or matrix (one row per specim) with landmark data on which
the weighted averaging is applied for prediction. If NULL, x will be used
for both tasks.</p>
</td></tr>
<tr><td><code id="NNshapeReg_+3A_n">n</code></td>
<td>
<p>amount of nearest neighbours to consider</p>
</td></tr>
<tr><td><code id="NNshapeReg_+3A_mahalanobis">mahalanobis</code></td>
<td>
<p>logical: use mahalanobis distance</p>
</td></tr>
<tr><td><code id="NNshapeReg_+3A_mc.cores">mc.cores</code></td>
<td>
<p>integer: amount of cores used for parallel processing.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function calculates weights from one set of shape data and then
estimates the shape of another (or same) set of landmarks.  CAUTION:
landmark data has to be registered beforehand.
</p>


<h3>Value</h3>

<p>matrix or array of estimates.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+proc.weight">proc.weight</a></code>, <code><a href="#topic+fixLMtps">fixLMtps</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (require(shapes)) {
proc &lt;- procSym(gorf.dat)
#use the closest 3 specimen based on the first 4 landmarks
#to estimate the shape
estim &lt;- NNshapeReg(proc$rotated[1:4,,],proc$rotated,n=3,mc.cores=1)
#compare estimation and true config
plot(proc$rotated[,,1],asp=1)
points(estim[,,1],col=2)
}

</code></pre>

<hr>
<h2 id='nose'>landmarks and a triangular mesh representing a human nose</h2><span id='topic+nose'></span><span id='topic+shortnose.mesh'></span><span id='topic+shortnose.lm'></span><span id='topic+longnose.lm'></span>

<h3>Description</h3>

<p>triangular mesh representing a human nose and two matrices containing
landmark data
</p>


<h3>Format</h3>

<p><code>shortnose.mesh</code>: A triangular mesh of class 'mesh3d'.
</p>
<p><code>shortnose.lm</code>: matrix containing example landmark data placed on
<code>shortnose.mesh</code>.
</p>
<p><code>longnose.lm</code>: matrix containing example landmark data representing a
caricaturesquely deformed human nose.
</p>

<hr>
<h2 id='pcAlign'>align two 3D-pointclouds/meshes by their principal axes</h2><span id='topic+pcAlign'></span><span id='topic+pcAlign.matrix'></span><span id='topic+pcAlign.mesh3d'></span>

<h3>Description</h3>

<p>align two 3D-pointclouds/meshes by their principal axes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pcAlign(x, y, optim = TRUE, subsample = NULL, iterations = 10, mc.cores = 2)

## S3 method for class 'matrix'
pcAlign(x, y, optim = TRUE, subsample = NULL, iterations = 10, mc.cores = 2)

## S3 method for class 'mesh3d'
pcAlign(x, y, optim = TRUE, subsample = NULL, iterations = 10, mc.cores = 2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pcAlign_+3A_x">x</code></td>
<td>
<p>matrix or mesh3d</p>
</td></tr>
<tr><td><code id="pcAlign_+3A_y">y</code></td>
<td>
<p>matrix or mesh3d, if missing, x will be centered by its centroid and aligned by its princial axis.</p>
</td></tr>
<tr><td><code id="pcAlign_+3A_optim">optim</code></td>
<td>
<p>logical if TRUE, the RMSE between reference and target will be minimized testing all possible axes alignments and (if iterations &gt; 0) followed by a rigid ICP procedure.</p>
</td></tr>
<tr><td><code id="pcAlign_+3A_subsample">subsample</code></td>
<td>
<p>integer: use subsampled points to decrease computation time of optimization.</p>
</td></tr>
<tr><td><code id="pcAlign_+3A_iterations">iterations</code></td>
<td>
<p>integer: number of iterations for optimization (the higher the more accurate but also more time consuming).</p>
</td></tr>
<tr><td><code id="pcAlign_+3A_mc.cores">mc.cores</code></td>
<td>
<p>use parallel processing to find best alignment to original shape.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>x</code> and <code>y</code> will first be centered and aligned by their PC-axes. If <code>optim=TRUE</code>,all possible 8 ordinations of PC-axes will be tested and the one with the smallest RMSE between the transformed version of <code>x</code> and the closest points on <code>y</code> will be used. Then the rotated version of <code>x</code> is translated to the original center of mass of <code>y</code>.
</p>


<h3>Value</h3>

<p>rotated and translated version of x to the center and principal axes of y.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(boneData)
blm1 &lt;- pcAlign(boneLM[,,1],boneLM[,,2])
## Not run: 
require(rgl)
spheres3d(boneLM[,,1])#original position
spheres3d(blm1,col=2)#aligned configuration
spheres3d(boneLM[,,2],col=3)#target

## End(Not run)
</code></pre>

<hr>
<h2 id='pcaplot3d'>visualization of shape variation</h2><span id='topic+pcaplot3d'></span><span id='topic+pcaplot3d.symproc'></span><span id='topic+pcaplot3d.nosymproc'></span>

<h3>Description</h3>

<p>visualization of shape change
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pcaplot3d(x, ...)

## S3 method for class 'symproc'
pcaplot3d(
  x,
  pcshow = c(1, 2, 3),
  mag = 3,
  color = 4,
  lwd = 1,
  sym = TRUE,
  legend = TRUE,
  type = c("spheres", "points"),
  ...
)

## S3 method for class 'nosymproc'
pcaplot3d(
  x,
  pcshow = c(1, 2, 3),
  mag = 3,
  color = 4,
  lwd = 1,
  legend = TRUE,
  type = c("spheres", "points"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pcaplot3d_+3A_x">x</code></td>
<td>
<p>a object derived from the function procSym calculated on 3D
coordinates.</p>
</td></tr>
<tr><td><code id="pcaplot3d_+3A_...">...</code></td>
<td>
<p>Additional parameters which will be passed to the methods.</p>
</td></tr>
<tr><td><code id="pcaplot3d_+3A_pcshow">pcshow</code></td>
<td>
<p>a vector containing the PCscores to be visualized.</p>
</td></tr>
<tr><td><code id="pcaplot3d_+3A_mag">mag</code></td>
<td>
<p>a vector or an integer containing which standard deviation of
which PC has to be visualized.</p>
</td></tr>
<tr><td><code id="pcaplot3d_+3A_color">color</code></td>
<td>
<p>color of the 3d points/spheres.</p>
</td></tr>
<tr><td><code id="pcaplot3d_+3A_lwd">lwd</code></td>
<td>
<p>width of the lines representing the shape change.</p>
</td></tr>
<tr><td><code id="pcaplot3d_+3A_sym">sym</code></td>
<td>
<p>logical: if TRUE the symmetric component of shape is displayed.
Otherwise the asymmetric one.</p>
</td></tr>
<tr><td><code id="pcaplot3d_+3A_legend">legend</code></td>
<td>
<p>logical: if TRUE a legend explaining the color coding of the PCs is plotted.</p>
</td></tr>
<tr><td><code id="pcaplot3d_+3A_type">type</code></td>
<td>
<p>character: for <code>type="spheres"</code>, the landmarks will be rendered using rgl's <code>spheres3d</code> function and for <code>type="points"</code> by  <code>points3d</code> respectivly.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>visualization of the shape changes explained by Principal components
</p>


<h3>Value</h3>

<p>returns an invisible array containing the shapes associated with the Principal components selected.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+procSym">procSym</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
data(boneData)
proc &lt;- procSym(boneLM)
pcaplot3d(proc,pcshow=1:3,mag=-3)#only one PC available

## End(Not run)
</code></pre>

<hr>
<h2 id='PCdist'>correlation between a reduced space and the original space</h2><span id='topic+PCdist'></span>

<h3>Description</h3>

<p>Calculates the correlation between distances in a reduced space and the
original space
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PCdist(PCs, PCscores, x = 5, plot.type = "b")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PCdist_+3A_pcs">PCs</code></td>
<td>
<p>m x k matrix of Principal Components where m is the k is the
number of PCs.</p>
</td></tr>
<tr><td><code id="PCdist_+3A_pcscores">PCscores</code></td>
<td>
<p>n x m matrix of Principal Component scores where n is the
number of observations.</p>
</td></tr>
<tr><td><code id="PCdist_+3A_x">x</code></td>
<td>
<p>integer: increment for every x-th PC the subspace to fullspace
correlation will be calculated.</p>
</td></tr>
<tr><td><code id="PCdist_+3A_plot.type">plot.type</code></td>
<td>
<p>&quot;b&quot;=barplot of correlation values, &quot;s&quot;=line between
correlation values.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of R-squared values between subspace and fullspace
distances and a barplot depicting the correlations belonging to the
subspace.
</p>


<h3>Author(s)</h3>

<p>Stefan Schlager
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (require(shapes)) {
a &lt;- procSym(gorf.dat)
PCdist(a$PCs, a$PCscores, x = 2)
}

</code></pre>

<hr>
<h2 id='permudist'>performs permutation testing for group differences.</h2><span id='topic+permudist'></span>

<h3>Description</h3>

<p>This function compares the distance between two groupmeans to the distances
obtained by random assignment of observations to this groups.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>permudist(
  data,
  groups,
  rounds = 1000,
  which = NULL,
  p.adjust.method = "none",
  median = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="permudist_+3A_data">data</code></td>
<td>
<p>array or matrix containing data</p>
</td></tr>
<tr><td><code id="permudist_+3A_groups">groups</code></td>
<td>
<p>factors determining grouping.</p>
</td></tr>
<tr><td><code id="permudist_+3A_rounds">rounds</code></td>
<td>
<p>number of permutations</p>
</td></tr>
<tr><td><code id="permudist_+3A_which">which</code></td>
<td>
<p>integer (optional): in case the factor levels are &gt; 2 this determins which factorlevels to use</p>
</td></tr>
<tr><td><code id="permudist_+3A_p.adjust.method">p.adjust.method</code></td>
<td>
<p>method to adjust p-values for multiple comparisons see <code><a href="stats.html#topic+p.adjust.methods">p.adjust.methods</a></code> for options.</p>
</td></tr>
<tr><td><code id="permudist_+3A_median">median</code></td>
<td>
<p>logical: if TRUE, comparison will be median instead of mean.</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>dist</code></td>
<td>
<p>distance matrix with distances between actual group means</p>
</td></tr>
<tr><td><code>p.adjust.method</code></td>
<td>
<p>method used for p-value adjustion</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>distance matrix containing pairwise p-values obtained by comparing the actual distance to randomly acquired distances</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
data(boneData)
proc &lt;- procSym(boneLM)
groups &lt;- name2factor(boneLM,which=3)
perm &lt;- permudist(proc$PCscores[,1:10], groups=groups, rounds=10000)

## now we concentrate only on sex dimorphism between Europeans
groups &lt;- name2factor(boneLM,which=3:4)
levels(groups)
perm1 &lt;- permudist(proc$PCscores, groups=groups,which=3:4, rounds=10000)


</code></pre>

<hr>
<h2 id='permuvec'>perfom permutation testing on angles and distances between subgroups of two
major groups.</h2><span id='topic+permuvec'></span>

<h3>Description</h3>

<p>perform permutation test on length and angle of the vectors connecting the
subgroup means of two groups: e.g. compare if length and angle between sex
related differences in two populations differ significantly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>permuvec(
  data,
  groups,
  subgroups = NULL,
  rounds = 9999,
  scale = TRUE,
  tol = 1e-10,
  mc.cores = parallel::detectCores()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="permuvec_+3A_data">data</code></td>
<td>
<p>array or matrix containing data.</p>
</td></tr>
<tr><td><code id="permuvec_+3A_groups">groups</code></td>
<td>
<p>factors of firs two grouping variables.</p>
</td></tr>
<tr><td><code id="permuvec_+3A_subgroups">subgroups</code></td>
<td>
<p>factors of the subgrouping.</p>
</td></tr>
<tr><td><code id="permuvec_+3A_rounds">rounds</code></td>
<td>
<p>number of requested permutation rounds</p>
</td></tr>
<tr><td><code id="permuvec_+3A_scale">scale</code></td>
<td>
<p>if TRUE: data will be scaled by pooled within group covarivance
matrix. Otherwise Euclidean distance will be used for calculating distances.</p>
</td></tr>
<tr><td><code id="permuvec_+3A_tol">tol</code></td>
<td>
<p>threshold for inverting covariance matrix.</p>
</td></tr>
<tr><td><code id="permuvec_+3A_mc.cores">mc.cores</code></td>
<td>
<p>integer: determines how many cores to use for the
computation. The default is autodetect. But in case, it doesn't work as
expected cores can be set manually.Parallel processing is disabled on
Windows due to occasional errors.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function calculates means of all four subgroups and compares the
residual vectors of the major grouping variables by angle and distance.
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>angle</code></td>
<td>
<p>angle between the vectors of the subgroups means</p>
</td></tr>
<tr><td><code>dist</code></td>
<td>
<p>distances between subgroups</p>
</td></tr>
<tr><td><code>meanvec</code></td>
<td>
<p>matrix containing the means of all four subgroups</p>
</td></tr>
<tr><td><code>permutangles</code></td>
<td>
<p>vector containing angles (in radians) from random permutation</p>
</td></tr>
<tr><td><code>permudists</code></td>
<td>
<p>vector containing distances from random permutation</p>
</td></tr>
<tr><td><code>p.angle</code></td>
<td>
<p>p-value of angle between residual vectors</p>
</td></tr>
<tr><td><code>p.dist</code></td>
<td>
<p>p-value of length difference between residual vectors</p>
</td></tr>
<tr><td><code>subdist</code></td>
<td>
<p>length of residual vectors connecting the subgroups</p>
</td></tr>
</table>
<p>means.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(boneData)
proc &lt;- procSym(boneLM)
pop &lt;- name2factor(boneLM,which=3)
sex &lt;- name2factor(boneLM,which=4)
## use non scaled distances by setting \code{scale = FALSE}
## and only use first 10 PCs
perm &lt;- permuvec(proc$PCscores[,1:10], groups=pop, subgroups=sex,
                 scale=FALSE, rounds=100, mc.cores=2)


## visualize if the amount of sexual dimorphism differs between
# (lenghts of vectors connecting population specific sex's averages)
# differs between European and Chines
hist(perm$permudist, xlim=c(0,0.1),main="measured vs. random distances",
     xlab="distances")
points(perm$dist,10,col=2,pch=19)#actual distance
text(perm$dist,15,label=paste("actual distance\n
     (p=",perm$p.dist,")"))
## not significant!!

## visualize if the direction of sexual dimorphism
# (angle between vectors connecting population specific sex's averages)
# differs between European and Chines
hist(perm$permutangles, main="measured vs. random angles",
     xlab="angles")
points(perm$angle,10,col=2,pch=19)#actual distance
text(perm$angle,15,label=paste("actual distance\n
    (p=",perm$p.angle,")"))
## also non-significant

</code></pre>

<hr>
<h2 id='placePatch'>Project semi-landmarks from a predefined atlas onto all specimen in a sample</h2><span id='topic+placePatch'></span>

<h3>Description</h3>

<p>Project semi-landmarks from a predefined atlas onto all specimen in a
sample. Various mechanisms are implemented to avoid errorneous placement on
the wrong surface layer (e.g. inside the bone).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>placePatch(
  atlas,
  dat.array,
  path,
  prefix = NULL,
  fileext = ".ply",
  ray = TRUE,
  inflate = NULL,
  tol = inflate,
  relax.patch = TRUE,
  keep.fix = NULL,
  rhotol = NULL,
  silent = FALSE,
  mc.cores = 1
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="placePatch_+3A_atlas">atlas</code></td>
<td>
<p>object of class &quot;atlas&quot; created by <code><a href="#topic+createAtlas">createAtlas</a></code></p>
</td></tr>
<tr><td><code id="placePatch_+3A_dat.array">dat.array</code></td>
<td>
<p>k x 3 x n array containing reference landmarks of the
sample or a matrix in case of only one target specimen.</p>
</td></tr>
<tr><td><code id="placePatch_+3A_path">path</code></td>
<td>
<p>character: specify the directory where the surface meshes of the
sample are stored.</p>
</td></tr>
<tr><td><code id="placePatch_+3A_prefix">prefix</code></td>
<td>
<p>character: prefix to the specimens names (stored in
<code>dimnames(dat.array)[[3]]</code>) to match the corresponding file names.
If <code>dat.array</code> has no dimnames (e.g. because it is a matrix - see example below),
this can also be a character vector
containing the filenames to which <code>fileext</code> will be appended.</p>
</td></tr>
<tr><td><code id="placePatch_+3A_fileext">fileext</code></td>
<td>
<p>character: file extension of the surface meshes.</p>
</td></tr>
<tr><td><code id="placePatch_+3A_ray">ray</code></td>
<td>
<p>logical: projection will be along surface normals instead of
simple closest point search.</p>
</td></tr>
<tr><td><code id="placePatch_+3A_inflate">inflate</code></td>
<td>
<p>inflate (or deflate - if negative sign) the semilandmarks
along the normals of the deformed atlas to make sure that they stay on the
outside (inside) of the target mesh.</p>
</td></tr>
<tr><td><code id="placePatch_+3A_tol">tol</code></td>
<td>
<p>numeric: threshold to follow the ray back after inflation. See
details below. If no surface is hit after <code>tol</code> mm, the simple closest
point will be used.</p>
</td></tr>
<tr><td><code id="placePatch_+3A_relax.patch">relax.patch</code></td>
<td>
<p>logical: request relaxation minimising bending energy
toward the atlas.</p>
</td></tr>
<tr><td><code id="placePatch_+3A_keep.fix">keep.fix</code></td>
<td>
<p>integer: rowindices of those landmarks that are not allowed
to be relaxed in case <code>relax.patch=TRUE</code>. If not specified, all
landmarks will be kept fix. This is preferably set during atlas creation with <code>createAtlas</code>:
In case you specified corrCurves on the atlas, you should define explicitly which landmarks
(also on the curves) are supposed to fix to prevent them from sliding.</p>
</td></tr>
<tr><td><code id="placePatch_+3A_rhotol">rhotol</code></td>
<td>
<p>numeric: maximum amount of deviation a hit point's normal is
allowed to deviate from the normal defined on the atlas. If
<code>relax.patch=TRUE</code>, those points exceeding this value will be relaxed
freely (i.e. not restricted to tangent plane).</p>
</td></tr>
<tr><td><code id="placePatch_+3A_silent">silent</code></td>
<td>
<p>logical: suppress messages.</p>
</td></tr>
<tr><td><code id="placePatch_+3A_mc.cores">mc.cores</code></td>
<td>
<p>run in parallel (experimental stuff now even available on Windows).
On windows this will only lead to a significant speed boost for many configurations,
as all required packages (Morpho and Rvcg) need to be loaded by each newly spawned process.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function allows the (relatively) easy projection of surface points
defined on an atlas onto all surface of a given sample by Thin-Plate Spline
deformation and additional mechanisms to avoid distortions. The algorithm
can be outlined as followed.  </p>

<ol>
<li><p> relax curves (if specified) against atlas.
</p>
</li>
<li><p> deform atlas onto targets by TPS based on predefined landmarks (and curves).
</p>
</li>
<li><p> project coordinates on deformed atlas onto target mesh
</p>
</li>
<li><p> 'inflate' or 'deflate' configuration along their normals to make sure
all coordinates are on the outside/inside
</p>
</li>
<li><p> Project inflated points back onto surface along these normals.
</p>
</li>
<li><p> Check if normals are roughly pointing into the same direction as those
on the (deformed) atlas.
</p>
</li>
<li><p> Relax all points against atlas.
</p>
</li>
<li><p> the predefined coordinates will note change afterwards!
</p>
</li></ol>



<h3>Value</h3>

<p>array containing the projected coordinates appended to the
data.array specified in the input. In case dat.array is a matrix only a
matrix is returned.
</p>


<h3>Author(s)</h3>

<p>Stefan Schlager
</p>


<h3>References</h3>

<p>Schlager S. 2013. Soft-tissue reconstruction of the human nose:
population differences and sexual dimorphism. PhD thesis,
Universitätsbibliothek Freiburg.  URL:
<a href="http://www.freidok.uni-freiburg.de/volltexte/9181/">http://www.freidok.uni-freiburg.de/volltexte/9181/</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+createAtlas">createAtlas</a>, <a href="#topic+relaxLM">relaxLM</a>, <a href="#topic+checkLM">checkLM</a>,
<a href="#topic+slider3d">slider3d</a>, <a href="#topic+tps3d">tps3d</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
data(nose)
require(rgl)
###create mesh for longnose
longnose.mesh &lt;- tps3d(shortnose.mesh,shortnose.lm,longnose.lm,threads=1)
## create atlas
fix &lt;- c(1:5,20:21)
atlas &lt;- createAtlas(shortnose.mesh, landmarks =
           shortnose.lm[fix,], patch=shortnose.lm[-c(1:5,20:21),])
## view atlas

plotAtlas(atlas)

## create landmark array with only fix landmarks
data &lt;- bindArr(shortnose.lm[fix,], longnose.lm[fix,], along=3)
dimnames(data)[[3]] &lt;- c("shortnose", "longnose")

### write meshes to disk
mesh2ply(shortnose.mesh, filename="shortnose")
mesh2ply(longnose.mesh, filename="longnose")

patched &lt;- placePatch(atlas, data, path="./", inflate=5)
## now browse through placed patches
checkLM(patched, path="./", atlas=atlas)

## same example with only one target specimen
data &lt;- longnose.lm[fix, ]

patched &lt;- placePatch(atlas, data, prefix="longnose", path="./", inflate=5)
wire3d(longnose.mesh,col=3)
spheres3d(patched)

## End(Not run)
</code></pre>

<hr>
<h2 id='plot.slider3d'>plot the result of slider3d</h2><span id='topic+plot.slider3d'></span>

<h3>Description</h3>

<p>plot the result of slider3d
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'slider3d'
plot(
  x,
  cols = 2:4,
  pt.size = NULL,
  point = c("sphere", "point"),
  specimen = 1,
  add = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.slider3d_+3A_x">x</code></td>
<td>
<p>result of <code>slider3d</code> call</p>
</td></tr>
<tr><td><code id="plot.slider3d_+3A_cols">cols</code></td>
<td>
<p>vector containing colors for each coordinate type cols[1]=landmarks, cols[2]=surface landmarks, cols[3]=outlines.</p>
</td></tr>
<tr><td><code id="plot.slider3d_+3A_pt.size">pt.size</code></td>
<td>
<p>size of plotted points/spheres. If <code>point="s"</code>.
<code>pt.size</code> defines the radius of the spheres. If <code>point="p"</code> it
sets the variable <code>size</code> used in <code>point3d</code>.</p>
</td></tr>
<tr><td><code id="plot.slider3d_+3A_point">point</code></td>
<td>
<p>how to render landmarks.</p>
</td></tr>
<tr><td><code id="plot.slider3d_+3A_specimen">specimen</code></td>
<td>
<p>integer: select the specimen to plot</p>
</td></tr>
<tr><td><code id="plot.slider3d_+3A_add">add</code></td>
<td>
<p>logical: if TRUE, a new rgl window is opened.</p>
</td></tr>
<tr><td><code id="plot.slider3d_+3A_...">...</code></td>
<td>
<p>additonal, currently unused parameters</p>
</td></tr>
</table>

<hr>
<h2 id='plotAtlas'>visualize an atlas defined by createAtlas</h2><span id='topic+plotAtlas'></span>

<h3>Description</h3>

<p>visualize an atlas defined by createAtlas
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotAtlas(
  atlas,
  pt.size = NULL,
  alpha = 1,
  render = c("w", "s"),
  point = c("s", "p"),
  meshcol = "white",
  add = TRUE,
  legend = TRUE,
  cols = 2:5
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plotAtlas_+3A_atlas">atlas</code></td>
<td>
<p>object of class atlas created by <code><a href="#topic+createAtlas">createAtlas</a></code>.</p>
</td></tr>
<tr><td><code id="plotAtlas_+3A_pt.size">pt.size</code></td>
<td>
<p>size of plotted points/spheres. If <code>point="s"</code>.
<code>pt.size</code> defines the radius of the spheres. If <code>point="p"</code> it
sets the variable <code>size</code> used in <code>point3d</code>.</p>
</td></tr>
<tr><td><code id="plotAtlas_+3A_alpha">alpha</code></td>
<td>
<p>value between 0 and 1. Sets transparency of mesh 1=opaque 0=
fully transparent.</p>
</td></tr>
<tr><td><code id="plotAtlas_+3A_render">render</code></td>
<td>
<p>if <code>render="w"</code>, a wireframe will be drawn, if
<code>render="s"</code>, the mesh will be shaded.</p>
</td></tr>
<tr><td><code id="plotAtlas_+3A_point">point</code></td>
<td>
<p>how to render landmarks. &quot;s&quot;=spheres, &quot;p&quot;=points.</p>
</td></tr>
<tr><td><code id="plotAtlas_+3A_meshcol">meshcol</code></td>
<td>
<p>color to render the atlas mesh</p>
</td></tr>
<tr><td><code id="plotAtlas_+3A_add">add</code></td>
<td>
<p>logical: if TRUE, a new rgl window is opened.</p>
</td></tr>
<tr><td><code id="plotAtlas_+3A_legend">legend</code></td>
<td>
<p>logical: request plot of legend specifying landmark coloring.</p>
</td></tr>
<tr><td><code id="plotAtlas_+3A_cols">cols</code></td>
<td>
<p>vector containing colors for each coordinate type cols[1]=landmarks, cols[2]=patch, cols[3]=corrCurves, cols[4]=patchCurves.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>legend=TRUE</code>, a plot with a legend will open where coloring of the
3D-spheres is specified.
</p>


<h3>Value</h3>

<p>returns invisible vector containing <code>rgl.id</code> of rendered
objects.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+placePatch">placePatch</a>, <a href="#topic+createAtlas">createAtlas</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(nose)
atlas &lt;- createAtlas(shortnose.mesh, landmarks =
           shortnose.lm[c(1:5,20:21),], patch=shortnose.lm[-c(1:5,20:21),])
## Not run: 
plotAtlas(atlas)

## End(Not run)
</code></pre>

<hr>
<h2 id='plotNormals'>plots the normals of a triangular surface mesh.</h2><span id='topic+plotNormals'></span>

<h3>Description</h3>

<p>visualises the vertex normals of a triangular surface mesh of class mesh3d.
If no normals are contained, they are computed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotNormals(x, length = 1, lwd = 1, col = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plotNormals_+3A_x">x</code></td>
<td>
<p>object of class &quot;mesh3d&quot;</p>
</td></tr>
<tr><td><code id="plotNormals_+3A_length">length</code></td>
<td>
<p>either a single numeric value or a numeric vector defining per-normals lenght (default is 1)</p>
</td></tr>
<tr><td><code id="plotNormals_+3A_lwd">lwd</code></td>
<td>
<p>width of the normals</p>
</td></tr>
<tr><td><code id="plotNormals_+3A_col">col</code></td>
<td>
<p>color of the normals</p>
</td></tr>
<tr><td><code id="plotNormals_+3A_...">...</code></td>
<td>
<p>addtional parameters, currently not in use.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Stefan Schlager
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
require(rgl)
data(nose)
plotNormals(shortnose.mesh,col=4,length=0.01)
shade3d(shortnose.mesh,col=3)

## End(Not run)

</code></pre>

<hr>
<h2 id='pls2B'>Two-Block partial least square regression.</h2><span id='topic+pls2B'></span>

<h3>Description</h3>

<p>Performs a Two-Block PLS on two sets of data and assesses the significance
of each score by permutation testing
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pls2B(
  x,
  y,
  tol = 1e-12,
  same.config = FALSE,
  rounds = 0,
  useCor = FALSE,
  cv = FALSE,
  cvlv = NULL,
  mc.cores = parallel::detectCores(),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pls2B_+3A_x">x</code></td>
<td>
<p>array containing superimposed landmark data second block.Matrices
are also allowed but the option 'same.config' will not work.</p>
</td></tr>
<tr><td><code id="pls2B_+3A_y">y</code></td>
<td>
<p>array containing superimposed landmark data of the first block.
Matrices are also allowed but the option 'same.config' will not work.</p>
</td></tr>
<tr><td><code id="pls2B_+3A_tol">tol</code></td>
<td>
<p>threshold for discarding singular values.</p>
</td></tr>
<tr><td><code id="pls2B_+3A_same.config">same.config</code></td>
<td>
<p>logical: if <code>TRUE</code> each permutation includes new
superimposition of permuted landmarks. This is necessary if both blocks
originate from landmarks that are superimposed together.</p>
</td></tr>
<tr><td><code id="pls2B_+3A_rounds">rounds</code></td>
<td>
<p>rounds of permutation testing.</p>
</td></tr>
<tr><td><code id="pls2B_+3A_usecor">useCor</code></td>
<td>
<p>if TRUE, the correlation matrix instead of the covariance matrix is used.</p>
</td></tr>
<tr><td><code id="pls2B_+3A_cv">cv</code></td>
<td>
<p>logical: if TRUE, a leave-one-out cross-validation is performed</p>
</td></tr>
<tr><td><code id="pls2B_+3A_cvlv">cvlv</code></td>
<td>
<p>integer: number of latent variables to test</p>
</td></tr>
<tr><td><code id="pls2B_+3A_mc.cores">mc.cores</code></td>
<td>
<p>integer: determines how many cores to use for the</p>
</td></tr>
<tr><td><code id="pls2B_+3A_...">...</code></td>
<td>
<p>arguments passed to <code><a href="#topic+ProcGPA">ProcGPA</a></code>
computation. The default is autodetect. But in case, it doesn't work as
expected cores can be set manually. Parallel processing is disabled on
Windows due to occasional errors.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Two-Block PLS tries to find those linear combinations in each block
maximising the covariance between blocks. The significance of each linear
combination is assessed by comparing the singular value to those obtained
from permuted blocks. If both blocks contain landmarks superimposed
TOGETHER, the option <code>same.config=TRUE</code> requests superimposition of the
permuted configurations (i.e. where the the landmarks of block <code>x</code> are
replaced by corresponding landmarks of other specimen.
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>svd</code></td>
<td>
<p>singular value decomposition (see <code><a href="base.html#topic+svd">svd</a></code>) of the
'common' covariance block</p>
</td></tr>
<tr><td><code>Xscores</code></td>
<td>
<p>PLS-scores of x</p>
</td></tr>
<tr><td><code>Yscores</code></td>
<td>
<p>PLS-scores of y</p>
</td></tr>
<tr><td><code>CoVar</code></td>
<td>
<p>Dataframe containing singular values, explained
covariation, correlation coeffictient between PLS-scores and p-values for singular values obtained from permutation testing</p>
</td></tr>
<tr><td><code>xlm</code></td>
<td>
<p>linear model: <code>lm(Xscores ~ Yscores - 1)</code></p>
</td></tr>
<tr><td><code>ylm</code></td>
<td>
<p>linear model: <code>lm(Yscores ~ Xscores - 1)</code></p>
</td></tr>
<tr><td><code>predicted.x</code></td>
<td>
<p>array containing matrices of cross-validated predictions for <code>x</code>(landmarks arrays will be vectorized using <code><a href="#topic+vecx">vecx</a></code>)</p>
</td></tr>
<tr><td><code>predicted.y</code></td>
<td>
<p>array containing matrices of cross-validated predictions for <code>y</code> (landmarks arrays will be vectorized using <code><a href="#topic+vecx">vecx</a></code>)</p>
</td></tr>
<tr><td><code>rv</code></td>
<td>
<p>RV-coefficient</p>
</td></tr>
<tr><td><code>p.value.RV</code></td>
<td>
<p>p-value for RV-coefficient determined by permutation testing</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Stefan Schlager
</p>


<h3>References</h3>

<p>Rohlf FJ, Corti M. 2000. Use of two-block partial least-squares
to study covariation in shape. Systematic Biology 49:740-753.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plsCoVar">plsCoVar</a>, <a href="#topic+getPLSfromScores">getPLSfromScores</a>, <a href="#topic+predictPLSfromScores">predictPLSfromScores</a>, <a href="#topic+getPLSscores">getPLSscores</a>, <a href="#topic+predictPLSfromData">predictPLSfromData</a>,<a href="base.html#topic+svd">svd</a> , <a href="#topic+plsCoVarCommonShape">plsCoVarCommonShape</a>, <a href="#topic+getPLSCommonShape">getPLSCommonShape</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (require(shapes)) {
### very arbitrary test:
### check if first 4 landmarks covaries with the second 4
proc &lt;- procSym(gorf.dat)
## we do only 50 rounds to minimize computation time
## Not run: #same.config takes too long for CRAN check
pls1 &lt;- pls2B(proc$rotated[1:4,,],proc$rotated[5:8,,],
              same.config=TRUE,rounds=50,mc.cores=2)

## End(Not run)
pls1 &lt;- pls2B(proc$rotated[1:4,,],proc$rotated[5:8,,],
              same.config=FALSE,rounds=50,mc.cores=1)
pls1
layout(matrix(1:4,2,2,byrow=TRUE))
for(i in 1:4)
 plot(pls1$Xscores[,i]~pls1$Yscores[,i])


## predict first 4 landmarks from second 4 for first config
layout(1)
predPLS &lt;- predictPLSfromData(pls1,y=proc$rotated[5:8,,1])
## show differences between prediction and original
deformGrid2d(predPLS,proc$rotated[1:4,,1],pch=19)
##plot the complete first config
points(proc$rotated[,,1])

##show effects of first latent variable
plsEffects &lt;- plsCoVar(pls1,i=1)
deformGrid2d(plsEffects$x[,,1],plsEffects$x[,,2])##show on x
deformGrid2d(plsEffects$y[,,1],plsEffects$y[,,2],add=TRUE,pch=19)##show on y

##show effects of 2nd latent variable
plsEffects2 &lt;- plsCoVar(pls1,i=2)
deformGrid2d(plsEffects2$x[,,1],plsEffects2$x[,,2])##show on x
deformGrid2d(plsEffects2$y[,,1],plsEffects2$y[,,2],add=TRUE,pch=19)##show on y
}
</code></pre>

<hr>
<h2 id='plsCoVar'>Get the shape changes from pls2B associated with each latent variable</h2><span id='topic+plsCoVar'></span>

<h3>Description</h3>

<p>Get the shape changes from pls2B associated with each latent variable
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plsCoVar(pls, i, sdx = 3, sdy = 3)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plsCoVar_+3A_pls">pls</code></td>
<td>
<p>output of pls2B</p>
</td></tr>
<tr><td><code id="plsCoVar_+3A_i">i</code></td>
<td>
<p>integer: which latent variable to show. E.g. i=3 will show the changes associated with the 3rd latent variable.</p>
</td></tr>
<tr><td><code id="plsCoVar_+3A_sdx">sdx</code></td>
<td>
<p>standard deviation on the xscores. sdx=3 will show the effecs of -3sd vs +3sd</p>
</td></tr>
<tr><td><code id="plsCoVar_+3A_sdy">sdy</code></td>
<td>
<p>standard deviation on the yscores. sdy=3 will show the effecs of -3sd vs +3sd</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>x</code></td>
<td>
<p>matrix/array with reconstructed x</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>matrix/array with reconstructed y, with each prediction named accordingly: e.g. neg_x_sd_3 means the prediction of x at a score of <code>-3*sd(Xscores)</code></p>
</td></tr></table>
<p>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pls2B">pls2B</a>, <a href="#topic+getPLSfromScores">getPLSfromScores</a>, <a href="#topic+predictPLSfromScores">predictPLSfromScores</a>, <a href="#topic+getPLSscores">getPLSscores</a>, <a href="#topic+predictPLSfromData">predictPLSfromData</a>,<a href="base.html#topic+svd">svd</a>,  <a href="#topic+plsCoVarCommonShape">plsCoVarCommonShape</a></code>
</p>

<hr>
<h2 id='plsCoVarCommonShape'>Compute the shape changes along the common axis of deformations</h2><span id='topic+plsCoVarCommonShape'></span>

<h3>Description</h3>

<p>Compute the shape changes between two blocks of 2D or 3D shape coordiantes along the common axis of deformations defined by each dimension of the latent space
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plsCoVarCommonShape(pls, i, sdcommon = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plsCoVarCommonShape_+3A_pls">pls</code></td>
<td>
<p>object of class &quot;pls2B&quot;</p>
</td></tr>
<tr><td><code id="plsCoVarCommonShape_+3A_i">i</code></td>
<td>
<p>integer: dimension of latent space to show shape changes for</p>
</td></tr>
<tr><td><code id="plsCoVarCommonShape_+3A_sdcommon">sdcommon</code></td>
<td>
<p>standard deviations derived from scores scaled to a consensus scale</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns an k x m x 2 array with the common shape changes associated with +-<code>sdcommon</code> SD of the <code>i-th</code> latent dimension
</p>


<h3>Note</h3>

<p>this give the same results as <code>plsCoVar</code>, however, using common shape vectors as suggested by Mitteroecker and Bookstein (2007)
</p>


<h3>References</h3>

<p>Mitteroecker P, Bookstein F. 2007. The conceptual and statistical relationship between modularity and morphological integration. Systematic Biology 56(5):818-836.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pls2B">pls2B</a>, <a href="#topic+getPLSfromScores">getPLSfromScores</a>, <a href="#topic+predictPLSfromScores">predictPLSfromScores</a>, <a href="#topic+getPLSscores">getPLSscores</a>, <a href="#topic+predictPLSfromData">predictPLSfromData</a>,<a href="base.html#topic+svd">svd</a>,  <a href="#topic+plsCoVar">plsCoVar</a>,  <a href="#topic+getPLSCommonShape">getPLSCommonShape</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(boneData)
proc &lt;- procSym(boneLM)
pls &lt;- pls2B(proc$orpdata[1:4,,],proc$orpdata[5:10,,])
commShape &lt;- getPLSCommonShape(pls)
## get common shape for first latent dimension at +-2 sd of the scores
pred &lt;- plsCoVarCommonShape(pls,1,2)
## Not run: 
deformGrid3d(pred[,,1],pred[,,2])

## End(Not run)
</code></pre>

<hr>
<h2 id='points2plane'>projects a 3D coordinate orthogonally onto a plane</h2><span id='topic+points2plane'></span>

<h3>Description</h3>

<p>projects a 3D coordinate orthogonally onto a plane
</p>


<h3>Usage</h3>

<pre><code class='language-R'>points2plane(x, v1, normal = NULL, v2 = NULL, v3 = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="points2plane_+3A_x">x</code></td>
<td>
<p>3D-vector or a k x 3 matrix with 3D vectors stored in rows</p>
</td></tr>
<tr><td><code id="points2plane_+3A_v1">v1</code></td>
<td>
<p>point on plane</p>
</td></tr>
<tr><td><code id="points2plane_+3A_normal">normal</code></td>
<td>
<p>plane normal (overrides specification by v2 and v3)</p>
</td></tr>
<tr><td><code id="points2plane_+3A_v2">v2</code></td>
<td>
<p>if pNorm=NULL, the plane will be defined by three points <code>v1, v2, v3</code></p>
</td></tr>
<tr><td><code id="points2plane_+3A_v3">v3</code></td>
<td>
<p>if pNorm=NULL, the plane will be defined by three points <code>v1, v2, v3</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>projected point
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(boneData)
##project rhinion onto plane spanned by Nasion and both Nariales
rpro &lt;- points2plane(boneLM[10,,1],v1=boneLM[9,,1],v2=boneLM[3,,1],v3=boneLM[4,,1])

## Not run: 
require(rgl)
#visualize
wire3d(skull_0144_ch_fe.mesh,col="white")
##get plane normal
normal &lt;- crossProduct(boneLM[3,,1]-boneLM[9,,1],boneLM[4,,1]-boneLM[9,,1])
#' ## get plane offset
d &lt;- norm(points2plane(c(0,0,0),v1=boneLM[9,,1],normal=normal),"2")
spheres3d(boneLM[,,1],radius=0.5)
spheres3d(boneLM[c(3,4,9),,1],radius=0.6,col=3)
##original position of Rhinion
spheres3d(boneLM[10,,1],radius=0.6,col=2)
##projected onto plane
spheres3d(rpro,radius=0.9,col=6)
lines3d(rbind(rpro,boneLM[10,,1]),lwd=3)
##plot plane
planes3d(normal[1],normal[2],normal[3],d=d,col=2,alpha=0.5)

##now we project all points onto that plane:
spheres3d(points2plane(boneLM[,,1],v1=boneLM[9,,1],v2=boneLM[3,,1],v3=boneLM[4,,1]),col=3)

## and finally project the vertices of the mesh onto the plane
meshpro &lt;- points2plane(vert2points(skull_0144_ch_fe.mesh),v1=boneLM[9,,1],normal=normal)
points3d(meshpro,col=2)

## End(Not run)
</code></pre>

<hr>
<h2 id='prcompfast'>fast Principal Component Analysis (PCA)</h2><span id='topic+prcompfast'></span>

<h3>Description</h3>

<p>fast Principal Component Analysis (PCA)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prcompfast(x, retx = TRUE, center = TRUE, scale. = FALSE, tol = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="prcompfast_+3A_x">x</code></td>
<td>
<p>a numeric or complex matrix (or data frame) which provides
the data for the principal components analysis.</p>
</td></tr>
<tr><td><code id="prcompfast_+3A_retx">retx</code></td>
<td>
<p>a logical value indicating whether the rotated variables should be returned</p>
</td></tr>
<tr><td><code id="prcompfast_+3A_center">center</code></td>
<td>
<p>a logical value indicating whether the variables should be shifted to be zero centered. Alternately, a vector of length</p>
</td></tr>
<tr><td><code id="prcompfast_+3A_scale.">scale.</code></td>
<td>
<p>a logical value indicating whether the variables should be scaled to have unit variance before the analysis takes place. The default is <code>FALSE</code> for consistency with S, but in general scaling is advisable.  Alternatively, a vector of length equal the number of columns of <code>x</code> can be supplied.  The          value is passed to <code>scale</code>. equal the number of columns of <code>x</code> can be supplied.  The value is passed to <code>scale</code>.</p>
</td></tr>
<tr><td><code id="prcompfast_+3A_tol">tol</code></td>
<td>
<p>a value indicating the magnitude below which components should be omitted. (Components are omitted if their standard deviations are less than or equal to <code>tol</code> times the standard deviation of the first component.)  With the default null setting, no components are omitted.  Other settings for tol could be <code>tol = 0</code> or <code>tol = sqrt(.Machine$double.eps)</code>, which would omit essentially constant components.</p>
</td></tr>
<tr><td><code id="prcompfast_+3A_...">...</code></td>
<td>
<p>arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>prcomp</code> returns a list with class <code>prcomp</code> containing the followin components:
</p>
<table role = "presentation">
<tr><td><code>sdev</code></td>
<td>
<p>the standard deviations of the principal components (i.e.,
the square roots of the eigenvalues of the
covariance/correlation matrix, though the calculation is
actually done with the singular values of the data matrix).</p>
</td></tr>
<tr><td><code>rotation:</code></td>
<td>
<p> the matrix of variable loadings (i.e., a matrix whose columns
contain the eigenvectors).  The function <code>princomp</code> returns
this in the element <code>loadings</code>.</p>
</td></tr>
<tr><td><code>x:</code></td>
<td>
<p> if <code>retx</code> is true the value of the rotated data (the centred
(and scaled if requested) data multiplied by the <code>rotation</code>
matrix) is returned.  Hence, <code>cov(x)</code> is the diagonal matrix
<code>diag(sdev^2)</code>.  For the formula method, <code>napredict()</code> is
applied to handle the treatment of values omitted by the
<code>na.action</code>.</p>
</td></tr>
<tr><td><code>center</code>, <code>scale:</code></td>
<td>
<p> the centering and scaling used, or <code>FALSE</code></p>
</td></tr></table>
<p>.
pcafast &lt;- prcompfast(iris[,1:4])
pcadefault &lt;- prcompfast(iris[,1:4])
## check if both results are idential (ignoring the sign)
all.equal(lapply(pcafast,abs),lapply(pcadefault,abs))
</p>


<h3>Note</h3>

<p>this function returns the same results as <code>prcomp</code> (apart from sign differences) but uses smarter matrix decompositions making it faster for nrow(x) &gt;&gt; ncol(x) and nrow(x) &lt;&lt; ncol(x).
</p>

<hr>
<h2 id='predict.bgPCA'>Compute between-group-PC scores from new data</h2><span id='topic+predict.bgPCA'></span>

<h3>Description</h3>

<p>Compute between-group-PC scores from new data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bgPCA'
predict(object, newdata, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict.bgPCA_+3A_object">object</code></td>
<td>
<p>object of class <code>bgPCA</code> returned from <code><a href="#topic+groupPCA">groupPCA</a></code></p>
</td></tr>
<tr><td><code id="predict.bgPCA_+3A_newdata">newdata</code></td>
<td>
<p>matrix or 3D array containing data in the same format as originally used to compute groupPCA</p>
</td></tr>
<tr><td><code id="predict.bgPCA_+3A_...">...</code></td>
<td>
<p>currently not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns the between-group-PC scores for new data
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(boneData)

boneLMPart &lt;- boneLM[,,-(1:2)]
procPart &lt;- procSym(boneLMPart)
pop_sex &lt;- name2factor(boneLMPart, which=3:4)
## compute group PCA without first 2 specimens
gpcaPart &lt;- groupPCA(procPart$orpdata, groups=pop_sex, rounds=0, mc.cores=2,cv=FALSE)
## align new data to Procrustes analysis
newdata &lt;- align2procSym(procPart,boneLM[,,1:2])
## get scores for new data
newscores &lt;- predict(gpcaPart,newdata)
</code></pre>

<hr>
<h2 id='predict.CVA'>Compute CV-scores from new data</h2><span id='topic+predict.CVA'></span>

<h3>Description</h3>

<p>Compute CV-scores from new data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'CVA'
predict(object, newdata, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict.CVA_+3A_object">object</code></td>
<td>
<p>object of class <code><a href="#topic+CVA">CVA</a></code></p>
</td></tr>
<tr><td><code id="predict.CVA_+3A_newdata">newdata</code></td>
<td>
<p>matrix or 3D array containing data in the same format as originally used to compute CVA</p>
</td></tr>
<tr><td><code id="predict.CVA_+3A_...">...</code></td>
<td>
<p>currently not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns the CV-scores for new data
</p>

<hr>
<h2 id='predictPLSfromData'>predict 2 Block-PLS from new data</h2><span id='topic+predictPLSfromData'></span>

<h3>Description</h3>

<p>predict 2 Block-PLS from new data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>predictPLSfromData(pls, x, y, ncomp = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predictPLSfromData_+3A_pls">pls</code></td>
<td>
<p>output of pls2B</p>
</td></tr>
<tr><td><code id="predictPLSfromData_+3A_x">x</code></td>
<td>
<p>data in the same format as in original pls2B (for landmarks this can be an array or a matrix and for other data a matrix of a vector)</p>
</td></tr>
<tr><td><code id="predictPLSfromData_+3A_y">y</code></td>
<td>
<p>data in the same format as in original pls2B (for landmarks this can be an array or a matrix and for other data a matrix of a vector)</p>
</td></tr>
<tr><td><code id="predictPLSfromData_+3A_ncomp">ncomp</code></td>
<td>
<p>number of (latent) components to use for prediction.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns an array/matrix/vector of predictions - depending on input for computing <code>pls</code>
</p>


<h3>Note</h3>

<p>either x or y must be missing
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pls2B">pls2B</a>, <a href="#topic+getPLSscores">getPLSscores</a>,<a href="#topic+predictPLSfromScores">predictPLSfromScores</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##see examples in pls2B
</code></pre>

<hr>
<h2 id='predictPLSfromScores'>predict data from 2-Block PLS-scores</h2><span id='topic+predictPLSfromScores'></span>

<h3>Description</h3>

<p>predict data from 2-Block PLS-scores
</p>


<h3>Usage</h3>

<pre><code class='language-R'>predictPLSfromScores(pls, x, y)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predictPLSfromScores_+3A_pls">pls</code></td>
<td>
<p>output of pls2B</p>
</td></tr>
<tr><td><code id="predictPLSfromScores_+3A_x">x</code></td>
<td>
<p>scores associated with dataset x in original pls2B</p>
</td></tr>
<tr><td><code id="predictPLSfromScores_+3A_y">y</code></td>
<td>
<p>scores associated with dataset y in original pls2B</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns an array/matrix of landmarks or original values, depending on input for computing <code>pls</code>
</p>


<h3>Note</h3>

<p>either x or y must be missing. If x-scores are provided, the yscores will be estimated and the predictions calculated.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pls2B">pls2B</a>, <a href="#topic+getPLSscores">getPLSscores</a>,<a href="#topic+predictPLSfromData">predictPLSfromData</a></code>
</p>

<hr>
<h2 id='predictRelWarps'>predict relative warps for data not included in the training data set</h2><span id='topic+predictRelWarps'></span>

<h3>Description</h3>

<p>predict relative warps for data not included in the training data set
</p>


<h3>Usage</h3>

<pre><code class='language-R'>predictRelWarps(x, newdata, noalign = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predictRelWarps_+3A_x">x</code></td>
<td>
<p>output from <code>relWarps</code></p>
</td></tr>
<tr><td><code id="predictRelWarps_+3A_newdata">newdata</code></td>
<td>
<p>k x m x n array holding new landmark data</p>
</td></tr>
<tr><td><code id="predictRelWarps_+3A_noalign">noalign</code></td>
<td>
<p>logical: if TRUE, data is assumed to be already aligned to training data and alignment is skipped.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function aligns the new data to the mean from <code>x</code> and transforms it into the relative warp space computed from the training data.
</p>


<h3>Value</h3>

<p>returns a list containing
</p>
<table role = "presentation">
<tr><td><code>bescores</code></td>
<td>
<p>relative warp scores (PC-scores if <code>alpha = 0</code>)</p>
</td></tr>
<tr><td><code>uniscores</code></td>
<td>
<p>uniform scores, NULL if  <code>alpha = 0</code></p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data(boneData)
set.seed(42)
training &lt;- sample(1:80,size=60)
rW1 &lt;- relWarps(boneLM[,,training], alpha = -1)
## predict scores for the entire sample
predAll &lt;- predictRelWarps(rW1,boneLM)

## now compare the scores predicted scores to the original ones
layout(matrix(1:4,2,2))
for (i in 1:2) {
  plot(rW1$bescores[,i],predAll$bescores[training,i],main=paste("RW",i))
  plot(rW1$uniscores[,i],predAll$uniscores[training,i],main=paste("UC",i))
}
</code></pre>

<hr>
<h2 id='predictShape.lm'>Predict shapes based on linear models calculated from PCscores</h2><span id='topic+predictShape.lm'></span>

<h3>Description</h3>

<p>Predict shapes based on linear models calculated from PCscores.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>predictShape.lm(fit, datamod, PC, mshape)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predictShape.lm_+3A_fit">fit</code></td>
<td>
<p>model of class <code>lm</code> where the PCscores are fitted onto</p>
</td></tr>
<tr><td><code id="predictShape.lm_+3A_datamod">datamod</code></td>
<td>
<p>a one-sided &quot;model&quot; formula, of the form <code>~ x1 + x2 +
... + xk</code>, corresponding to the right hand term in the model used in
<code>fit</code>. If omitted, the predicted shapes of all specimen are calculated
based on the fitted values.</p>
</td></tr>
<tr><td><code id="predictShape.lm_+3A_pc">PC</code></td>
<td>
<p>Matrix/vector containing Principal components (rotation matrix)
corresponding to PC-scores used in <code>fit</code>.</p>
</td></tr>
<tr><td><code id="predictShape.lm_+3A_mshape">mshape</code></td>
<td>
<p>matrix of the meanshape's landmarks by which the data was
centered before rotation in covariance eigenspace.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function predicts the landmarks based on models calculated from
PCscores.
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>predicted</code></td>
<td>
<p>array or matrix containing predicted landmark
coordinates</p>
</td></tr>
<tr><td><code>predictedPC</code></td>
<td>
<p>matrix containing predicted PC-scores</p>
</td></tr>
</table>


<h3>Warning</h3>

<p>Make sure that the levels of the variables used in
<code>datamod</code> correspond exactly to those used in <code>fit</code>. Otherwise
model matrix will be calculated erroneous.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+model.matrix">model.matrix</a>, <a href="stats.html#topic+lm">lm</a>, <a href="stats.html#topic+formula">formula</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(boneData)
proc &lt;- procSym(boneLM)
pop &lt;- name2factor(boneLM,which=3)
##easy model with only one factor based on the first four PCs
fit &lt;- lm(proc$PCscores[,1:4] ~ pop)
## get shape for Europeans only
datamod &lt;- ~as.factor(levels(pop))[2]
Eu &lt;- predictShape.lm(fit,datamod, proc$PCs[,1:4],proc$mshape)

## get shape for Europeans and Chinese
datamod &lt;- ~as.factor(levels(pop))
pred &lt;- predictShape.lm(fit,datamod, proc$PCs[,1:4],proc$mshape)
## Not run: 
deformGrid3d(pred$predicted[,,1], pred$predicted[,,2], ngrid = 0)

## End(Not run)

## more complicated model

sex &lt;- name2factor(boneLM,which=4)
fit &lt;- lm(proc$PCscores[,1:4] ~ pop*sex)
## predict female for chinese and European
datamod &lt;- ~(as.factor(levels(pop))*rep(as.factor(levels(sex))[1],2))
pred &lt;- predictShape.lm(fit,datamod, proc$PCs[,1:4],proc$mshape)

## predict female and malefor chinese and European
popmod &lt;- factor(c(rep("eu",2),rep("ch",2)))
sexmod &lt;- rep(as.factor(levels(sex)),2)
datamod &lt;- ~(popmod*sexmod)
pred &lt;- predictShape.lm(fit,datamod, proc$PCs[,1:4],proc$mshape)

## add some (randomly generated) numeric covariate
somevalue &lt;- rnorm(80,sd=10)
fit &lt;- lm(proc$PCscores[,1:4] ~ pop+somevalue)
probs &lt;- quantile(somevalue, probs=c(0.05, 0.95))
## make model for European at 5% and 95% quantile
popmod &lt;- rep(factor(levels(pop))[2],2)
datamod &lt;- ~(popmod+probs)
pred &lt;- predictShape.lm(fit,datamod, proc$PCs[,1:4],proc$mshape)


</code></pre>

<hr>
<h2 id='proc.weight'>calculate weights inverse to the distances from the specified observation.</h2><span id='topic+proc.weight'></span>

<h3>Description</h3>

<p>for calculation of a shape model by averaging the observations neighbouring
the configuration in question, it is necessary to calculate weights by
similarity.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>proc.weight(
  data,
  number,
  ref,
  report = TRUE,
  reg = 0,
  log = FALSE,
  mahalanobis = FALSE,
  weightfun = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="proc.weight_+3A_data">data</code></td>
<td>
<p>array containing landmark configurations</p>
</td></tr>
<tr><td><code id="proc.weight_+3A_number">number</code></td>
<td>
<p>integer: how many of the neighbours are to be involved.</p>
</td></tr>
<tr><td><code id="proc.weight_+3A_ref">ref</code></td>
<td>
<p>integer: position in the array that is used as reference.</p>
</td></tr>
<tr><td><code id="proc.weight_+3A_report">report</code></td>
<td>
<p>logical: require report about name of the reference.</p>
</td></tr>
<tr><td><code id="proc.weight_+3A_reg">reg</code></td>
<td>
<p>numeric: regularise mahalanobis distance by adding reg to the
diagonal of eigenvalues of the covariance matrix.</p>
</td></tr>
<tr><td><code id="proc.weight_+3A_log">log</code></td>
<td>
<p>logical: use the logarithm of the distances.</p>
</td></tr>
<tr><td><code id="proc.weight_+3A_mahalanobis">mahalanobis</code></td>
<td>
<p>logical: use mahalanobis distance.</p>
</td></tr>
<tr><td><code id="proc.weight_+3A_weightfun">weightfun</code></td>
<td>
<p>custom function that operates on a vector of distances (see examples) and generates weights accordingly.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>distances of zero will get a weight of 1e12 (this is scaled to all weights
summing to one), thus weights for observations further away are converging
to zero.
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>data</code></td>
<td>
<p>dataframe containing id, procrustes/mahalanobis distance
and weight according to the reference</p>
</td></tr>
<tr><td><code>reference</code></td>
<td>
<p>returns observations' names if available</p>
</td></tr>
<tr><td><code>rho.all</code></td>
<td>
<p>dataframe containing distances to references of all observations</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
if (require(shapes)) {
proc &lt;- procSym(gorf.dat)
##get weights for the the four specimen closest to the first observation.
weights &lt;- proc.weight(proc$rotated,4,1)

##estimate the first specimen by weighted neighbour shapes.
estim &lt;- proc$mshape*0;
for (i in 1:4)
{estim &lt;-estim+proc$rotated[,,weights$data$nr[i]]*weights$data$weight[i]}

### visualise
plot(estim,asp=1)## show estimation
points(proc$rotated[,,1],col=3)##show original

## use a gaussian smoother to compute weights using a bandwidth of 0.05
gaussWeight &lt;- function(r,sigma=0.05) {
   sigma &lt;- 2*sigma^2
   return(exp(-r^2/ sigma))
}
weights &lt;- proc.weight(proc$rotated,4,1,weightfun=gaussWeight)
}
</code></pre>

<hr>
<h2 id='procAOVsym'>Procrustes ANOVA for structures with object symmetry</h2><span id='topic+procAOVsym'></span>

<h3>Description</h3>

<p>Procrustes ANOVA for structures with object symmetry, currently only
supporting the factors 'specimen', 'side' and the interaction term.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>procAOVsym(symproc, indnames = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="procAOVsym_+3A_symproc">symproc</code></td>
<td>
<p>object returned by <code><a href="#topic+procSym">procSym</a></code>, where
<code>pairedLM</code> is specified</p>
</td></tr>
<tr><td><code id="procAOVsym_+3A_indnames">indnames</code></td>
<td>
<p>vector containing specimen identifiers. Only necessary, if
data does not contain dimnames containing identifiers</p>
</td></tr>
</table>


<h3>Details</h3>

<p>performs a Procrustes ANOVA for configurations with object symmetry (as
described in Klingenberg et al. 2002).
</p>


<h3>Value</h3>

<p>returns a dataframe containing Sums of Squares for each factor.
</p>


<h3>Note</h3>

<p>In future releases the implementation of support for bilateral
symmetry and more factors is intended.
</p>


<h3>Author(s)</h3>

<p>Stefan Schlager
</p>


<h3>References</h3>

<p>Klingenberg CP, Barluenga M, Meyer A. 2002. Shape analysis of
symmetric structures: quantifying variation among individuals and asymmetry.
Evolution 56:1909-20.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+procSym">procSym</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(boneData)
left &lt;- c(4,6,8)
## determine corresponding Landmarks on the right side:
# important: keep same order
right &lt;- c(3,5,7)
pairedLM &lt;- cbind(left,right)
symproc &lt;- procSym(boneLM, pairedLM=pairedLM)
procAOVsym(symproc)

</code></pre>

<hr>
<h2 id='ProcGPA'>Workhorse function for procSym, responsible for Procrustes registration</h2><span id='topic+ProcGPA'></span>

<h3>Description</h3>

<p>Workhorse function for procSym, responsible for Procrustes registration
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ProcGPA(
  dat.array,
  tol = 1e-05,
  scale = TRUE,
  CSinit = FALSE,
  silent = TRUE,
  weights = NULL,
  centerweight = FALSE,
  reflection = TRUE,
  pcAlign = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ProcGPA_+3A_dat.array">dat.array</code></td>
<td>
<p>Input k x m x n real array, where k is the number of
points, m is the number of dimensions, and n is the sample size.</p>
</td></tr>
<tr><td><code id="ProcGPA_+3A_tol">tol</code></td>
<td>
<p>numeric: Threshold for convergence during iterative
superimpositioning.</p>
</td></tr>
<tr><td><code id="ProcGPA_+3A_scale">scale</code></td>
<td>
<p>logical: indicating if scaling is requested</p>
</td></tr>
<tr><td><code id="ProcGPA_+3A_csinit">CSinit</code></td>
<td>
<p>logical: if TRUE, all configurations are initially scaled to
Unit Centroid Size.</p>
</td></tr>
<tr><td><code id="ProcGPA_+3A_silent">silent</code></td>
<td>
<p>logical: suppress output of elapsed time.</p>
</td></tr>
<tr><td><code id="ProcGPA_+3A_weights">weights</code></td>
<td>
<p>numeric vector: assign per landmark weights.</p>
</td></tr>
<tr><td><code id="ProcGPA_+3A_centerweight">centerweight</code></td>
<td>
<p>logical: if TRUE, the landmark configuration is scaled
according to weights during the rotation process, instead of being scaled to
the Centroid size.</p>
</td></tr>
<tr><td><code id="ProcGPA_+3A_reflection">reflection</code></td>
<td>
<p>logical: allow reflections.</p>
</td></tr>
<tr><td><code id="ProcGPA_+3A_pcalign">pcAlign</code></td>
<td>
<p>logical: if TRUE, the shapes are aligned by the principal axis of the first specimen, otherwise the orientation of the first specimen is used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns a list with
</p>
<table role = "presentation">
<tr><td><code>rotated</code></td>
<td>
<p>k x m x n array of the rotated configurations</p>
</td></tr>
<tr><td><code>mshape</code></td>
<td>
<p>sample meanshape</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Stefan Schlager
</p>


<h3>References</h3>

<p>Goodall C. 1991. Procrustes methods in the statistical analysis
of shape. Journal of the Royal Statistical Society. Series B. Statistical
Methodology 53:285-239.
</p>
<p>Dryden IL, Mardia KV.  1998. Statistical shape analysis. John Wiley and
sons, Chichester.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+procSym">procSym</a>, <a href="#topic+rotonto">rotonto</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(boneData)
proc &lt;- ProcGPA(boneLM, CSinit=TRUE, silent=TRUE)
#now we landmarks 5 - 9 double the weight as  the others
weights &lt;- c(rep(1,4),rep(2,5),1)
proc.wt &lt;- ProcGPA(boneLM, CSinit=TRUE, weights=weights, silent=TRUE)

</code></pre>

<hr>
<h2 id='procSym'>Procrustes registration</h2><span id='topic+procSym'></span>

<h3>Description</h3>

<p><code>procSym</code> performs Procrustes superimposition including sliding of
semi-landmarks on curves/outlines in 2D and 3D.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>procSym(
  dataarray,
  scale = TRUE,
  reflect = TRUE,
  CSinit = TRUE,
  orp = TRUE,
  proctol = 1e-05,
  tol = 1e-05,
  pairedLM = NULL,
  sizeshape = FALSE,
  use.lm = NULL,
  center.part = FALSE,
  weights = NULL,
  centerweight = FALSE,
  pcAlign = TRUE,
  distfun = c("angle", "riemann"),
  SMvector = NULL,
  outlines = NULL,
  deselect = FALSE,
  recursive = TRUE,
  iterations = 0,
  initproc = FALSE,
  bending = TRUE,
  stepsize = 1
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="procSym_+3A_dataarray">dataarray</code></td>
<td>
<p>Input k x m x n real array, where k is the number of
points, m is the number of dimensions, and n is the sample size.</p>
</td></tr>
<tr><td><code id="procSym_+3A_scale">scale</code></td>
<td>
<p>logical: indicating if scaling is requested to minimize the General Procrustes distance. To avoid all scaling, one has to set <code>CSinit=FALSE</code>, too.</p>
</td></tr>
<tr><td><code id="procSym_+3A_reflect">reflect</code></td>
<td>
<p>logical: allow reflections.</p>
</td></tr>
<tr><td><code id="procSym_+3A_csinit">CSinit</code></td>
<td>
<p>logical: if TRUE, all configurations are initially scaled to
Unit Centroid Size.</p>
</td></tr>
<tr><td><code id="procSym_+3A_orp">orp</code></td>
<td>
<p>logical: if TRUE, an orthogonal projection at the meanshape into
tangent space is performed.</p>
</td></tr>
<tr><td><code id="procSym_+3A_proctol">proctol</code></td>
<td>
<p>numeric:  Threshold for convergence in the alignment process</p>
</td></tr>
<tr><td><code id="procSym_+3A_tol">tol</code></td>
<td>
<p>numeric: Threshold for convergence in the sliding process</p>
</td></tr>
<tr><td><code id="procSym_+3A_pairedlm">pairedLM</code></td>
<td>
<p>A X x 2 matrix containing the indices (rownumbers) of the
paired LM. E.g. the left column contains the lefthand landmarks, while the
right side contains the corresponding right hand landmarks.</p>
</td></tr>
<tr><td><code id="procSym_+3A_sizeshape">sizeshape</code></td>
<td>
<p>Logical: if TRUE, a log transformed variable of Centroid
Size will be added to the shapedata as first variable before performing the
PCA.</p>
</td></tr>
<tr><td><code id="procSym_+3A_use.lm">use.lm</code></td>
<td>
<p>vector of integers to define a subset of landmarks to be used
for Procrustes registration.</p>
</td></tr>
<tr><td><code id="procSym_+3A_center.part">center.part</code></td>
<td>
<p>Logical: if TRUE, the data superimposed by the subset
defined by use.lm will be centered according to the centroid of the complete
configuration. Otherwise orp will be set to FALSE to avoid erroneous
projection into tangent space.</p>
</td></tr>
<tr><td><code id="procSym_+3A_weights">weights</code></td>
<td>
<p>numeric vector: assign per landmark weights.</p>
</td></tr>
<tr><td><code id="procSym_+3A_centerweight">centerweight</code></td>
<td>
<p>logical: if TRUE, the landmark configuration is scaled
according to weights during the rotation process, instead of being scaled to
the Centroid size.</p>
</td></tr>
<tr><td><code id="procSym_+3A_pcalign">pcAlign</code></td>
<td>
<p>logical: if TRUE, the shapes are aligned by the principal axis of the first specimen</p>
</td></tr>
<tr><td><code id="procSym_+3A_distfun">distfun</code></td>
<td>
<p>character: &quot;riemann&quot; requests a Riemannian distance for
calculating distances to mean, while &quot;angle&quot; uses an approximation by
calculating the angle between rotated shapes on the unit sphere.</p>
</td></tr>
<tr><td><code id="procSym_+3A_smvector">SMvector</code></td>
<td>
<p>A vector containing the landmarks on the curve(s) that are
allowed to slide</p>
</td></tr>
<tr><td><code id="procSym_+3A_outlines">outlines</code></td>
<td>
<p>A vector (or if threre are several curves) a list of vectors
(containing the rowindices) of the (Semi-)landmarks forming the curve(s) in
the successive position on the curve - including the beginning and end
points, that are not allowed to slide.</p>
</td></tr>
<tr><td><code id="procSym_+3A_deselect">deselect</code></td>
<td>
<p>Logical: if TRUE, the SMvector is interpreted as those
landmarks, that are not allowed to slide.</p>
</td></tr>
<tr><td><code id="procSym_+3A_recursive">recursive</code></td>
<td>
<p>Logical: if TRUE, during the iterations of the sliding
process, the outcome of the previous iteration will be used.  Otherwise the
original configuration will be used in all iterations.</p>
</td></tr>
<tr><td><code id="procSym_+3A_iterations">iterations</code></td>
<td>
<p>integer: select manually how many iterations will be
performed during the sliding process (usefull, when there is very slow
convergence).  0 means iteration until convergence.</p>
</td></tr>
<tr><td><code id="procSym_+3A_initproc">initproc</code></td>
<td>
<p>Logical: indicating if the first Relaxation step is
performed against the mean of an initial Procrustes superimposition.
Symmetric configurations will be relaxed against a perfectly symmetrical mean.</p>
</td></tr>
<tr><td><code id="procSym_+3A_bending">bending</code></td>
<td>
<p>if TRUE, bending energy will be minimized, Procrustes distance otherwise (not suggested with large shape differences)</p>
</td></tr>
<tr><td><code id="procSym_+3A_stepsize">stepsize</code></td>
<td>
<p>integer: dampening factor for the sliding.
Useful to keep semi-landmarks from sliding too far off the surface.
The displacement is calculated as <br />
<code>stepsize * displacement</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function performs Procrustes registration, allowing a variety of
options, including scaling, orthogonal projection into tangentspace and
relaxation of semi-landmarks on curves (without reprojection onto the
surface/actual outline). It also allows the superimpositioning to be
performed using only a subset of the available landmark.  For taking into
account object symmetry, <code>pairedLM</code> needs to be set. This generates an
object of class <code>"symproc"</code>. Otherwise an object of class
<code>"nosymproc"</code>.
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>size</code></td>
<td>
<p>a vector containing the Centroid Size of the configurations</p>
</td></tr>
<tr><td><code>rotated</code></td>
<td>
<p>k x m x n array of the rotated configurations</p>
</td></tr>
<tr><td><code>Sym</code></td>
<td>
<p>k x m x n array of the Symmetrical component - only
available for the &quot;Symmetry&quot;-Option (when pairedLM is defined)</p>
</td></tr>
<tr><td><code>Asym</code></td>
<td>
<p>k x m x n array of the Asymmetrical component. It contains the per-landmark asymmetric displacement for each specimen. Only
available for the &quot;Symmetry&quot;-Option (when pairedLM is defined)</p>
</td></tr>
<tr><td><code>asymmean</code></td>
<td>
<p>k x m matrix of mean asymmetric deviation from
symmetric mean</p>
</td></tr>
<tr><td><code>mshape</code></td>
<td>
<p>sample meanshape</p>
</td></tr>
<tr><td><code>symmean</code></td>
<td>
<p>meanshape of symmetrized configurations</p>
</td></tr>
<tr><td><code>tan</code></td>
<td>
<p>if orp=TRUE: Residuals in tangentspace else, Procrustes
residuals - only available without the &quot;Symmetrie&quot;-Option</p>
</td></tr>
<tr><td><code>PCs</code></td>
<td>
<p>Principal Components - if sizeshape=TRUE, the first variable
of the PCs is size information (as log transformed Centroid Size)</p>
</td></tr>
<tr><td><code>PCsym</code></td>
<td>
<p>Principal Components of the Symmetrical Component</p>
</td></tr>
<tr><td><code>PCasym</code></td>
<td>
<p>Principal Components of the Asymmetrical Component</p>
</td></tr>
<tr><td><code>PCscores</code></td>
<td>
<p>PC scores</p>
</td></tr>
<tr><td><code>PCscore_sym</code></td>
<td>
<p>PC scores of the Symmetrical Component</p>
</td></tr>
<tr><td><code>PCscore_asym</code></td>
<td>
<p>PC scores of the Asymmetrical Component</p>
</td></tr>
<tr><td><code>eigenvalues</code></td>
<td>
<p>eigenvalues of the Covariance matrix</p>
</td></tr>
<tr><td><code>eigensym</code></td>
<td>
<p>eigenvalues of the &quot;Symmetrical&quot; Covariance matrix</p>
</td></tr>
<tr><td><code>eigenasym</code></td>
<td>
<p>eigenvalues of the &quot;Asymmetrical&quot; Covariance matrix</p>
</td></tr>
<tr><td><code>Variance</code></td>
<td>
<p>Table of the explained Variance by the PCs</p>
</td></tr>
<tr><td><code>SymVar</code></td>
<td>
<p>Table of the explained &quot;Symmetrical&quot; Variance by the PCs</p>
</td></tr>
<tr><td><code>AsymVar</code></td>
<td>
<p>Table of the explained &quot;Asymmetrical&quot; Variance by the PCs</p>
</td></tr>
<tr><td><code>orpdata</code></td>
<td>
<p>k x m x n array of the rotated configurations projected
into tangent space</p>
</td></tr>
<tr><td><code>rho</code></td>
<td>
<p>vector of Riemannian distance from the mean</p>
</td></tr>
<tr><td><code>dataslide</code></td>
<td>
<p>array containing slidden Landmarks in the original
space - not yet processed by a Procrustes analysis. Only available if a
sliding process was requested</p>
</td></tr>
<tr><td><code>meanlogCS</code></td>
<td>
<p>mean log-transformed centroid size</p>
</td></tr>
</table>


<h3>Note</h3>

<p>For processing of surface landmarks or including the reprojection of
slid landmarks back onto 3D-surface representations, the usage of
<code><a href="#topic+slider3d">slider3d</a></code> is recommended.
</p>


<h3>Author(s)</h3>

<p>Stefan Schlager
</p>


<h3>References</h3>

<p>Dryden IL, and Mardia KV. 1998. Statistical shape analysis.
Chichester.
</p>
<p>Klingenberg CP, Barluenga M, and Meyer A. 2002. Shape analysis of symmetric
structures: quantifying variation among individuals and asymmetry. Evolution
56(10):1909-1920.
</p>
<p>Gunz, P., P. Mitteroecker, and F. L. Bookstein. 2005. Semilandmarks in Three
Dimensions, in Modern Morphometrics in Physical Anthropology. Edited by D.
E. Slice, pp. 73-98. New York: Kluwer Academic/Plenum Publishers.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+slider3d">slider3d</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
require(rgl)
data(boneData)

### do an analysis of symmetric landmarks
## visualize landmarks on surface
## Not run: 
 spheres3d(boneLM[,,1])
wire3d(skull_0144_ch_fe.mesh,col=3)
## get landmark numbers
text3d(boneLM[,,1],text=paste(1:10),adj = 1, cex=3)

## End(Not run)
## determine paired Landmarks left side:
left &lt;- c(4,6,8)
## determine corresponding Landmarks on the right side:
# important: keep same order
right &lt;- c(3,5,7)
pairedLM &lt;- cbind(left,right)
symproc &lt;- procSym(boneLM, pairedLM=pairedLM)
## Not run: 
## visualize first 3 PCs of symmetric shape
pcaplot3d(symproc, sym=TRUE)
## visualize first 3 PCs of asymmetric shape
pcaplot3d(symproc, sym=FALSE)

## visualze distribution of symmetric PCscores population
pop &lt;- name2factor(boneLM, which=3)
if (require(car)) {
spm(~symproc$PCscore_sym[,1:5], groups=pop)
## visualze distribution of asymmetric PCscores population
spm(~symproc$PCscore_asym[,1:5], groups=pop)
}

## End(Not run)


</code></pre>

<hr>
<h2 id='projRead'>Project points onto the closest point on a mesh</h2><span id='topic+projRead'></span>

<h3>Description</h3>

<p>project points onto a given surface and return projected points and normals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>projRead(lm, mesh, readnormals = TRUE, smooth = FALSE, sign = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="projRead_+3A_lm">lm</code></td>
<td>
<p>m x 3 matrix containing 3D coordinates.</p>
</td></tr>
<tr><td><code id="projRead_+3A_mesh">mesh</code></td>
<td>
<p>character: specify path to mesh file.</p>
</td></tr>
<tr><td><code id="projRead_+3A_readnormals">readnormals</code></td>
<td>
<p>logical: return normals of projected points.</p>
</td></tr>
<tr><td><code id="projRead_+3A_smooth">smooth</code></td>
<td>
<p>logical: rerturn smoothed normals.</p>
</td></tr>
<tr><td><code id="projRead_+3A_sign">sign</code></td>
<td>
<p>logical: request signed distances.</p>
</td></tr>
<tr><td><code id="projRead_+3A_...">...</code></td>
<td>
<p>additional arguments currently not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>if readnormals = FALSE, a m x 3 matrix containing projected points
is returned, otherwise a list, where
</p>
<table role = "presentation">
<tr><td><code>vb</code></td>
<td>
<p>3 x m matrix containing projected points</p>
</td></tr>
<tr><td><code>normals</code></td>
<td>
<p>3 x m matrix containing normals</p>
</td></tr> 
<tr><td><code>quality</code></td>
<td>
<p>vector containing distances </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Stefan Schlager
</p>


<h3>References</h3>

<p>Detection of inside/outside uses the algorithm proposed in:
</p>
<p>Baerentzen, Jakob Andreas. &amp; Aanaes, H., 2002. Generating Signed Distance
Fields From Triangle Meshes. Informatics and Mathematical Modelling.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+closemeshKD">closemeshKD</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

data(nose)
## Not run: 
repro &lt;- projRead(shortnose.lm,shortnose.mesh)

## End(Not run)

</code></pre>

<hr>
<h2 id='qqmat'>Q-Q plot to assess normality of data</h2><span id='topic+qqmat'></span>

<h3>Description</h3>

<p>qqmat plots Mahalanobisdistances of a given sample against those expected
from a Gaussian distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qqmat(x, output = FALSE, square = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="qqmat_+3A_x">x</code></td>
<td>
<p>sample data: matrix or vector</p>
</td></tr>
<tr><td><code id="qqmat_+3A_output">output</code></td>
<td>
<p>logical: if TRUE results are returned</p>
</td></tr>
<tr><td><code id="qqmat_+3A_square">square</code></td>
<td>
<p>plot in a square window - outliers might be cut off.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>if <code>output=TRUE</code>, the following values are returned
</p>
<table role = "presentation">
<tr><td><code>x</code></td>
<td>
<p>distances from an expected Gaussian distribution</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>observed distances - sorted</p>
</td></tr>
<tr><td><code>d</code></td>
<td>
<p>observed distances - unsorted</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Stefan Schlager
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+qqplot">qqplot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
require(MASS)
### create normally distributed data
data &lt;- mvrnorm(100,mu=rep(0,5),Sigma = diag(5:1))
qqmat(data)

###create non normally distributed data
data1 &lt;- rchisq(100,df=3)
qqmat(data1,square=FALSE)

</code></pre>

<hr>
<h2 id='quad2trimesh'>converts a mesh containing quadrangular faces into one only consisting of triangles</h2><span id='topic+quad2trimesh'></span>

<h3>Description</h3>

<p>converts a mesh containing quadrangular faces into one only consisting of triangles
</p>


<h3>Usage</h3>

<pre><code class='language-R'>quad2trimesh(mesh, updateNormals = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="quad2trimesh_+3A_mesh">mesh</code></td>
<td>
<p>object of class &quot;mesh3d&quot;</p>
</td></tr>
<tr><td><code id="quad2trimesh_+3A_updatenormals">updateNormals</code></td>
<td>
<p>logical: request recalculation of (angle weighted) vertex normals.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>triangular mesh with updated normals
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
Sigma &lt;- diag(3:1) #create a 3D-covariance matrix
require(rgl)
quadmesh &lt;- ellipse3d(Sigma)##create quadmesh
trimesh &lt;- quad2trimesh(quadmesh)# convert to trimesh


</code></pre>

<hr>
<h2 id='r2morphoj'>Export data to MorphoJ and Morphologika</h2><span id='topic+r2morphoj'></span><span id='topic+r2morphologika'></span>

<h3>Description</h3>

<p>Export data to MorphoJ and Morphologika
</p>


<h3>Usage</h3>

<pre><code class='language-R'>r2morphoj(x, file, id.string = NULL)

r2morphologika(x, file = file, labels = NULL, labelname = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="r2morphoj_+3A_x">x</code></td>
<td>
<p>3-dimensionla array containing landmark data. E.g. the input/output
from <code><a href="#topic+procSym">procSym</a></code>.</p>
</td></tr>
<tr><td><code id="r2morphoj_+3A_file">file</code></td>
<td>
<p>character: name the output file</p>
</td></tr>
<tr><td><code id="r2morphoj_+3A_id.string">id.string</code></td>
<td>
<p>a string with ids or factors to append</p>
</td></tr>
<tr><td><code id="r2morphoj_+3A_labels">labels</code></td>
<td>
<p>character vector specify labels to create for Morphologika</p>
</td></tr>
<tr><td><code id="r2morphoj_+3A_labelname">labelname</code></td>
<td>
<p>character: name the labels for Morphologika.</p>
</td></tr>
<tr><td><code id="r2morphoj_+3A_...">...</code></td>
<td>
<p>unused at the moment</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Export data to MorphoJ and Morphologika
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (require(shapes)) {
r2morphoj(gorf.dat,file="gorf.dat")

data &lt;- bindArr(gorf.dat, gorm.dat, along=3)
datalabels &lt;- c(rep("female",dim(gorf.dat)[3]),
rep("male",dim(gorm.dat)[3]))
labelname &lt;- "sex"
r2morphologika(data, labels=datalabels, labelname= labelname, file="data.dat")
## cleanup
unlink(c("gorf.dat","data.dat"))
}
</code></pre>

<hr>
<h2 id='ray2mesh'>projects the vertices of a mesh along its normals onto the surface of another one.</h2><span id='topic+ray2mesh'></span>

<h3>Description</h3>

<p>projects the vertices of a mesh onto the surface of another one by searching
for the closest point along vertex normals on the
target by for each vertex.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ray2mesh(mesh1, tarmesh, tol = 1e+12, inbound = FALSE, mindist = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ray2mesh_+3A_mesh1">mesh1</code></td>
<td>
<p>mesh to project. Can be an object of class &quot;mesh3d&quot; or path to
an external mesh file (ply, obj, stl).</p>
</td></tr>
<tr><td><code id="ray2mesh_+3A_tarmesh">tarmesh</code></td>
<td>
<p>mesh to project onto. Can be an object of class &quot;mesh3d&quot; or
path to an external mesh file (ply, obj, stl).</p>
</td></tr>
<tr><td><code id="ray2mesh_+3A_tol">tol</code></td>
<td>
<p>numeric: maximum distance to search along ray, closest Euclidean
distance will be used, if tol is exceeded.</p>
</td></tr>
<tr><td><code id="ray2mesh_+3A_inbound">inbound</code></td>
<td>
<p>inverse search direction along rays.</p>
</td></tr>
<tr><td><code id="ray2mesh_+3A_mindist">mindist</code></td>
<td>
<p>search both ways (ray and -ray) and select closest point.</p>
</td></tr>
<tr><td><code id="ray2mesh_+3A_...">...</code></td>
<td>
<p>additional arguments not used at the moment.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns projected mesh with additional list entries:
</p>
<table role = "presentation">
<tr><td><code>quality</code></td>
<td>
<p>integer vector containing a value for each vertex of <code>x</code>: 1 indicates that a ray has intersected 'tarmesh' within the given threshold, while 0 means not</p>
</td></tr>
<tr><td><code>distance</code></td>
<td>
<p>numeric vector: distances to intersection</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Stefan Schlager
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ply2mesh">ply2mesh</a></code>, <code><a href="#topic+closemeshKD">closemeshKD</a></code>
</p>

<hr>
<h2 id='read.csv.folder'>batch import data from files</h2><span id='topic+read.csv.folder'></span>

<h3>Description</h3>

<p>imports all data files contained in a specified folder.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.csv.folder(
  folder,
  x,
  y = 2:4,
  rownames = NULL,
  header = TRUE,
  dec = ".",
  sep = ";",
  pattern = "csv",
  addSpec = NULL,
  back = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="read.csv.folder_+3A_folder">folder</code></td>
<td>
<p>character: path to folder</p>
</td></tr>
<tr><td><code id="read.csv.folder_+3A_x">x</code></td>
<td>
<p>either a vector specifiing which rows are to be imported, or
character vector containing variable names to be sought for.</p>
</td></tr>
<tr><td><code id="read.csv.folder_+3A_y">y</code></td>
<td>
<p>a vector specifiing, which columns of the speradsheet ist to be
imported.</p>
</td></tr>
<tr><td><code id="read.csv.folder_+3A_rownames">rownames</code></td>
<td>
<p>integer: specifies columns, where variable names are stored.</p>
</td></tr>
<tr><td><code id="read.csv.folder_+3A_header">header</code></td>
<td>
<p>logical : if spreadsheet contains header-row.</p>
</td></tr>
<tr><td><code id="read.csv.folder_+3A_dec">dec</code></td>
<td>
<p>character: defines decimal sepearator.</p>
</td></tr>
<tr><td><code id="read.csv.folder_+3A_sep">sep</code></td>
<td>
<p>character: defines column seperator.</p>
</td></tr>
<tr><td><code id="read.csv.folder_+3A_pattern">pattern</code></td>
<td>
<p>character: specify file format (e.g. csv).</p>
</td></tr>
<tr><td><code id="read.csv.folder_+3A_addspec">addSpec</code></td>
<td>
<p>character: add a custom specifier to the dimnames of the
array.</p>
</td></tr>
<tr><td><code id="read.csv.folder_+3A_back">back</code></td>
<td>
<p>logical: where to place the specifier.</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>arr</code></td>
<td>
<p>array containing imported data</p>
</td></tr>
<tr><td><code>NAs</code></td>
<td>
<p>vector containing position of observations with NAs</p>
</td></tr>
<tr><td><code>NA.list</code></td>
<td>
<p>list: containing vectors containing information which
LMs are missing in which observation</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Stefan Schlager
</p>


<h3>See Also</h3>

<p><code><a href="utils.html#topic+read.table">read.table</a></code>
</p>

<hr>
<h2 id='read.fcsv'>read fiducials from slicer4</h2><span id='topic+read.fcsv'></span>

<h3>Description</h3>

<p>read fiducials from slicer4
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.fcsv(x, na = NULL, lps2ras = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="read.fcsv_+3A_x">x</code></td>
<td>
<p>filename</p>
</td></tr>
<tr><td><code id="read.fcsv_+3A_na">na</code></td>
<td>
<p>value to be replaced by NA</p>
</td></tr>
<tr><td><code id="read.fcsv_+3A_lps2ras">lps2ras</code></td>
<td>
<p>logical: if the coordinate system is LPS and <code>lps2ras=TRUE</code>, the data will be rotated into the RAS space by inverting the first two dimensions using <code><a href="#topic+LPS2RAS">LPS2RAS</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a k x 3 matrix with landmarks
</p>

<hr>
<h2 id='read.lmdta'>read dta files</h2><span id='topic+read.lmdta'></span>

<h3>Description</h3>

<p>reads .dta files created by the software Landmark
http://graphics.idav.ucdavis.edu/research/EvoMorph
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.lmdta(file = "x", na = 9999)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="read.lmdta_+3A_file">file</code></td>
<td>
<p>a dta file</p>
</td></tr>
<tr><td><code id="read.lmdta_+3A_na">na</code></td>
<td>
<p>specifies a value that indicates missing values</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>arr</code></td>
<td>
<p>array containing landmarks dimnames will be Information of
ID and landmark names specified in Landmark</p>
</td></tr>
<tr><td><code>info</code></td>
<td>
<p>Information extracted from the header of the dta file</p>
</td></tr>
<tr><td><code>idnames</code></td>
<td>
<p>character vector containing the names of the individuals
as specified in the dta file</p>
</td></tr>
</table>

<hr>
<h2 id='read.mpp'>Read saved pick-points from meshlab</h2><span id='topic+read.mpp'></span>

<h3>Description</h3>

<p>imports pick points selected with meshlab
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.mpp(file, info = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="read.mpp_+3A_file">file</code></td>
<td>
<p>file to import</p>
</td></tr>
<tr><td><code id="read.mpp_+3A_info">info</code></td>
<td>
<p>logical: if TRUE, addtional infos are returned</p>
</td></tr>
</table>


<h3>Value</h3>

<p>if <code>info=FALSE</code>:
</p>
<p>a matrix containing picked-points coordinates (only those tagged as active).
</p>
<p>if <code>info=TRUE</code>: a list containing
</p>
<table role = "presentation">
<tr><td><code>data</code></td>
<td>
<p>matrix containing coordinates - including points tagged as inactive</p>
</td></tr>
<tr><td><code>info</code></td>
<td>
<p>additional info contained in file.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Stefan Schlager
</p>


<h3>See Also</h3>

<p><code><a href="#topic+read.pts">read.pts</a></code>
</p>

<hr>
<h2 id='read.pts'>reads pts files</h2><span id='topic+read.pts'></span>

<h3>Description</h3>

<p>reads Landmark data exported from the software Landmark from
http://graphics.idav.ucdavis.edu/research/EvoMorph
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.pts(file = "x", na = 9999)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="read.pts_+3A_file">file</code></td>
<td>
<p>pts file</p>
</td></tr>
<tr><td><code id="read.pts_+3A_na">na</code></td>
<td>
<p>specifies a value that indicates missing values</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>matrix</code></td>
<td>
<p>matrix containing landmark information rownames will be
the names given to the landmarks in Landmark</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+read.pts">read.pts</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(nose)
write.pts(shortnose.lm, filename="shortnose")
data &lt;- read.pts("shortnose.pts")

</code></pre>

<hr>
<h2 id='read.slicerjson'>read Landmarks from Slicer in Json format</h2><span id='topic+read.slicerjson'></span>

<h3>Description</h3>

<p>read Landmarks from Slicer in Json format
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.slicerjson(x, lps2ras = FALSE, na = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="read.slicerjson_+3A_x">x</code></td>
<td>
<p>path to json file</p>
</td></tr>
<tr><td><code id="read.slicerjson_+3A_lps2ras">lps2ras</code></td>
<td>
<p>logical: if the coordinate system is LPS and <code>lps2ras=TRUE</code>, the data will be rotated into the RAS space by inverting the first two dimensions using <code><a href="#topic+LPS2RAS">LPS2RAS</a></code>.</p>
</td></tr>
<tr><td><code id="read.slicerjson_+3A_na">na</code></td>
<td>
<p>value to be replaced by NA</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns matrix or list of matrices with imported landmark coordinates
</p>

<hr>
<h2 id='readallTPS'>Import landmarks and outlines from TPS files</h2><span id='topic+readallTPS'></span>

<h3>Description</h3>

<p>Imports outlines and landmarks from files generated by tpsdig2
</p>


<h3>Usage</h3>

<pre><code class='language-R'>readallTPS(file, scale = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="readallTPS_+3A_file">file</code></td>
<td>
<p>A TPS-file generated by tpsdig2</p>
</td></tr>
<tr><td><code id="readallTPS_+3A_scale">scale</code></td>
<td>
<p>logical: if TRUE the data will be scaled according to the SCALE entry.</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>ID</code></td>
<td>
<p>Specimen IDs read from TPS file</p>
</td></tr>
<tr><td><code>LM</code></td>
<td>
<p>list of landmarks contained in the TPS-file</p>
</td></tr>
<tr><td><code>outlines</code></td>
<td>
<p>a list containing sublists for each specimen with all
the outlines read from TPS file</p>
</td></tr>
<tr><td><code>SCALE</code></td>
<td>
<p>vector containing the scale factors for each landmark config.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>currently only landmarks, ID and outlines are read from the TPS-file
</p>


<h3>Author(s)</h3>

<p>Stefan Schlager
</p>


<h3>References</h3>

<p>http://life.bio.sunysb.edu/ee/rohlf/software.html
</p>


<h3>See Also</h3>

<p><code><a href="#topic+read.lmdta">read.lmdta</a></code>, <code><a href="#topic+read.pts">read.pts</a></code>
</p>

<hr>
<h2 id='readLandmarks.csv'>import landmark data from csv files</h2><span id='topic+readLandmarks.csv'></span>

<h3>Description</h3>

<p>import landmark data from csv files
</p>


<h3>Usage</h3>

<pre><code class='language-R'>readLandmarks.csv(
  file,
  x,
  y = 2:4,
  rownames = NULL,
  header = TRUE,
  dec = ".",
  sep = ";"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="readLandmarks.csv_+3A_file">file</code></td>
<td>
<p>character: path to file containing landmark data.</p>
</td></tr>
<tr><td><code id="readLandmarks.csv_+3A_x">x</code></td>
<td>
<p>either a vector specifiing which rows are to be imported, or
character vector containing variable names to be sought for.</p>
</td></tr>
<tr><td><code id="readLandmarks.csv_+3A_y">y</code></td>
<td>
<p>a vector specifiing, which columns of the speradsheet ist to be
imported.</p>
</td></tr>
<tr><td><code id="readLandmarks.csv_+3A_rownames">rownames</code></td>
<td>
<p>integer: specifies columns, where variable names are stored.</p>
</td></tr>
<tr><td><code id="readLandmarks.csv_+3A_header">header</code></td>
<td>
<p>logical : if spreadsheet contains header-row.</p>
</td></tr>
<tr><td><code id="readLandmarks.csv_+3A_dec">dec</code></td>
<td>
<p>character: defines decimal sepearator.</p>
</td></tr>
<tr><td><code id="readLandmarks.csv_+3A_sep">sep</code></td>
<td>
<p>character: defines column seperator.</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>LM</code></td>
<td>
<p>matrix containing imported data</p>
</td></tr>
<tr><td><code>NAs</code></td>
<td>
<p>vector containing rows containing NAs</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Stefan Schlager
</p>


<h3>See Also</h3>

<p><code><a href="utils.html#topic+read.table">read.table</a></code>
</p>

<hr>
<h2 id='regdist'>correlation between shape space and tangent space</h2><span id='topic+regdist'></span>

<h3>Description</h3>

<p>performs a partial Procrustes superimposition of landmark data and
calculates the correlation between tangent and shape space.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>regdist(
  dataarray,
  plot = TRUE,
  main = "",
  rho = "angle",
  dist.mat.out = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="regdist_+3A_dataarray">dataarray</code></td>
<td>
<p>Input k x m x n real array, where k is the number of
points, m is the number of dimensions, and n is the sample size.</p>
</td></tr>
<tr><td><code id="regdist_+3A_plot">plot</code></td>
<td>
<p>Logical: whether to plot the distances between observations.</p>
</td></tr>
<tr><td><code id="regdist_+3A_main">main</code></td>
<td>
<p>character string: Title of the plot.</p>
</td></tr>
<tr><td><code id="regdist_+3A_rho">rho</code></td>
<td>
<p>chose how to calculate distances in shape space. Options:
&quot;riemdist&quot;=Riemannian distance (function from the shapes package-takes along
time to calculate), &quot;angle&quot;=calculates the angle between shape vectors,
&quot;sindist&quot;=sinus of length of residual vector between shape vectors.</p>
</td></tr>
<tr><td><code id="regdist_+3A_dist.mat.out">dist.mat.out</code></td>
<td>
<p>Logical: If TRUE, output will contain distance matrices.</p>
</td></tr>
<tr><td><code id="regdist_+3A_...">...</code></td>
<td>
<p>additional parameters passed to <code><a href="#topic+procSym">procSym</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>cor</code></td>
<td>
<p>correlation coefficient between distances in shape space and
tangent space</p>
</td></tr>
<tr><td><code>procSS</code></td>
<td>
<p>Procrustes Sums of Squares (of full procrustes distance)</p>
</td></tr>
<tr><td><code>tanSS</code></td>
<td>
<p>Tangent Sums of Squares</p>
</td></tr>
<tr><td><code>rhoSS</code></td>
<td>
<p>Procrustes Sums of Squares (of angle)</p>
</td></tr>
<tr><td><code>euc.dist</code></td>
<td>
<p>distance matrix of euclidean distance in Tangent space</p>
</td></tr>
<tr><td><code>proc.dist</code></td>
<td>
<p>distance matrix of Procrustes distance in Shape space</p>
</td></tr>
<tr><td><code>lm</code></td>
<td>
<p>linear model regressing tangent space distances onto Procrustes distances</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Stefan Schlager
</p>


<h3>See Also</h3>

<p><code><a href="#topic+regdist">regdist</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (require(shapes)) {
regdist(gorf.dat)
}
</code></pre>

<hr>
<h2 id='RegScore'>calulate regression scores for linear model</h2><span id='topic+RegScore'></span>

<h3>Description</h3>

<p>calulate regression scores for linear model as specified in Drake &amp; Klingenberg(2008)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RegScore(model, x = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="RegScore_+3A_model">model</code></td>
<td>
<p>linear model</p>
</td></tr>
<tr><td><code id="RegScore_+3A_x">x</code></td>
<td>
<p>optional: matrix containing fitted data to be projected onto the regression lines. If omitted the model's fitted values will be used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>the data are orthogonally projected onto the regression lines associated with each factor.
</p>


<h3>Value</h3>

<p>returns a n x m matrix containing the regression scores for each specimen.
</p>


<h3>Warning</h3>

<p>if <code>model</code> contains factors with more than 2 levels, R calculates one regression line per 2 factors. Check the <code>colnames</code> of the returned matrix to select the appropriate one. See examples for details.
</p>


<h3>References</h3>

<p>Drake, AG. &amp; Klingenberg, CP. The pace of morphological change: historical transformation of skull shape in St Bernard dogs. Proceedings of the Royal Society B: Biological Sciences, The Royal Society, 2008, 275, 71-76.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>model &lt;- lm(as.matrix(iris[,1:3]) ~ iris[,4])
rs &lt;- RegScore(model)
plot(rs,iris[,4])

##now use a random subsample for model fitting
rand &lt;- sample(nrow(iris))
x &lt;- iris[rand[1:100],4]
newmod &lt;- lm(as.matrix(iris[rand[1:100],1:3]) ~ x)
##predict the rest of data and get their regression scores
rsPred &lt;- RegScore(newmod,as.matrix(iris[rand[101:150],1:3]))
plot(rsPred,iris[rand[101:150],4])
## Not run: 
data(boneData)
proc &lt;- procSym(boneLM)
pop.sex &lt;- name2factor(boneLM,which=3:4) # generate a factor with 4 levels
lm.ps.size &lt;- lm(proc$PCscores ~ pop.sex+proc$size)
rs &lt;- RegScore(lm.ps.size)
colnames(rs) # in this case, the last column contains the regression
# scores associated with proc$size
## validate by using a subsample for fitting
rand &lt;- sample(dim(boneLM)[3])
lm.ps.size0 &lt;- lm(proc$PCscores[rand[1:50],] ~ proc$size[rand[1:50]])
rs0 &lt;- RegScore(lm.ps.size0,proc$PCscores[rand[-c(1:50)],] )
plot(rs0,proc$size[rand[-c(1:50)]])

## End(Not run)

</code></pre>

<hr>
<h2 id='relaxLM'>relax one specific landmark configuration against a reference</h2><span id='topic+relaxLM'></span><span id='topic+relaxLM.matrix'></span><span id='topic+relaxLM.mesh3d'></span>

<h3>Description</h3>

<p>relax one specific landmark configuration against a reference (e.g. a
sample mean)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>relaxLM(lm, ...)

## S3 method for class 'matrix'
relaxLM(
  lm,
  reference,
  SMvector,
  outlines = NULL,
  surp = NULL,
  sur.name = NULL,
  mesh = NULL,
  tol = 1e-05,
  deselect = FALSE,
  inc.check = TRUE,
  iterations = 0,
  fixRepro = TRUE,
  missing = NULL,
  bending = TRUE,
  stepsize = ifelse(bending, 1, 0.5),
  use.lm = NULL,
  silent = FALSE,
  ...
)

## S3 method for class 'mesh3d'
relaxLM(
  lm,
  reference,
  tol = 1e-05,
  deselect = FALSE,
  inc.check = TRUE,
  iterations = 0,
  fixRepro = TRUE,
  missing = NULL,
  bending = FALSE,
  stepsize = ifelse(bending, 1, 0.5),
  use.lm = NULL,
  silent = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="relaxLM_+3A_lm">lm</code></td>
<td>
<p>k x 3 or k x 2 matrix containing landmark data to be slidden - or a triangular mesh of class &quot;mesh3d&quot;. See details</p>
</td></tr>
<tr><td><code id="relaxLM_+3A_...">...</code></td>
<td>
<p>additonal arguments - currently unused</p>
</td></tr>
<tr><td><code id="relaxLM_+3A_reference">reference</code></td>
<td>
<p>k x 3 or k x 2 matrix containing landmark of the reference, or a mesh with the same amount of vertices as there are landmarks in <code>lm</code>.</p>
</td></tr>
<tr><td><code id="relaxLM_+3A_smvector">SMvector</code></td>
<td>
<p>A vector containing the row indices of (semi-) landmarks on the curve(s) that are
allowed to slide</p>
</td></tr>
<tr><td><code id="relaxLM_+3A_outlines">outlines</code></td>
<td>
<p>A vector (or if threre are several curves) a list of vectors
(containing the rowindices) of the (Semi-)landmarks forming the curve(s) in
the successive position on the curve - including the beginning and end
points, that are not allowed to slide.</p>
</td></tr>
<tr><td><code id="relaxLM_+3A_surp">surp</code></td>
<td>
<p>integer vector containing the row indices of semi-landmarks positioned on surfaces.</p>
</td></tr>
<tr><td><code id="relaxLM_+3A_sur.name">sur.name</code></td>
<td>
<p>character: containing the filename of the corresponding
surface.When specified, mesh has to be NULL. If <code>sur.name=NULL</code> and <code>mesh=NULL</code>, the tangent planes will be estimated from the point cloud.</p>
</td></tr>
<tr><td><code id="relaxLM_+3A_mesh">mesh</code></td>
<td>
<p>triangular mesh of class &quot;mesh3d&quot; loaded into the R workspace,
when specified, &quot;sur.name&quot; has to be NULL.</p>
</td></tr>
<tr><td><code id="relaxLM_+3A_tol">tol</code></td>
<td>
<p>numeric: Threshold for convergence in the sliding proces. Full
Procrustes distance between actual result and previous iteration.</p>
</td></tr>
<tr><td><code id="relaxLM_+3A_deselect">deselect</code></td>
<td>
<p>Logical: if TRUE, the SMvector is interpreted as those
landmarks, that are not allowed to slide.</p>
</td></tr>
<tr><td><code id="relaxLM_+3A_inc.check">inc.check</code></td>
<td>
<p>Logical: if TRUE, the program stops when convergence
criterion starts increasing and reports result from last iteration.</p>
</td></tr>
<tr><td><code id="relaxLM_+3A_iterations">iterations</code></td>
<td>
<p>integer: maximum amounts the algorithm runs - even when
'tol' is not reached. When iterations=0, the algorithm runs until
convergence.</p>
</td></tr>
<tr><td><code id="relaxLM_+3A_fixrepro">fixRepro</code></td>
<td>
<p>logical: if <code>TRUE</code>, fix landmarks will also be
projected onto the surface. If you have landmarks not on the surface, select
<code>fixRepro=FALSE</code></p>
</td></tr>
<tr><td><code id="relaxLM_+3A_missing">missing</code></td>
<td>
<p>vector of integers, specifying row indices of missing (semi-)landmarks. They will be relaxed freely in 3D and not projected onto the target (works only for 2D data).</p>
</td></tr>
<tr><td><code id="relaxLM_+3A_bending">bending</code></td>
<td>
<p>if TRUE, bending energy will be minimized, Procrustes distance otherwise (not suggested with large shape differences)</p>
</td></tr>
<tr><td><code id="relaxLM_+3A_stepsize">stepsize</code></td>
<td>
<p>integer: dampening factor for the amount of sliding.
Useful to keep semi-landmarks from sliding too far off the surface.
The displacement is calculated as  <code class="reqn">\Upsilon = \Upsilon^0 + stepsize * UT</code>.
Default is set to 1 for bending=TRUE and 0.5 for bending=FALSE.</p>
</td></tr>
<tr><td><code id="relaxLM_+3A_use.lm">use.lm</code></td>
<td>
<p>indices specifying a subset of (semi-)landmarks to be used in the rotation step - only used if <code>bending=FALSE</code>.</p>
</td></tr>
<tr><td><code id="relaxLM_+3A_silent">silent</code></td>
<td>
<p>logical: if TRUE, console output is suppressed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>if <code>lm</code> is a surface mesh, all vertices will be treated as semilandmarks and a allowed to freely slide along the surface.
</p>


<h3>Value</h3>

<p>returns kx3 matrix of slidden landmarks
</p>


<h3>Author(s)</h3>

<p>Stefan Schlager
</p>


<h3>References</h3>

<p>Gunz, P., P. Mitteroecker, and F. L. Bookstein. 2005.
Semilandmarks in Three Dimensions, in Modern Morphometrics in Physical
Anthropology. Edited by D. E. Slice, pp. 73-98. New York: Kluwer
Academic/Plenum Publishers.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+slider3d">slider3d</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
require(rgl)
data(nose)
### relax shornose against longnose

# define fix landmarks
fix &lt;- c(1:5,20:21)
# define surface patch by specifying row indices of matrices
# all except those defined as fix
surp &lt;- c(1:dim(shortnose.lm)[1])[-fix]
 
relax &lt;- relaxLM(shortnose.lm,
         longnose.lm, mesh=shortnose.mesh, iterations=1,
         SMvector=fix, deselect=TRUE, surp=surp)

## example minimizing Procrustes distance when displacement is not
## dampened by stepsize
relaxProcD &lt;- relaxLM(shortnose.lm,
         longnose.lm, mesh=shortnose.mesh, iterations=1,
         SMvector=fix, deselect=TRUE, surp=c(1:623)[-fix],bending=FALSE,stepsize=1)

## Not run: 
# visualize differences red=before and green=after sliding
deformGrid3d(shortnose.lm, relax, ngrid=0)

 
# visualize differences minimizing Procrusted distances red=before and green=after sliding

deformGrid3d(shortnose.lm, relaxProcD, ngrid=0)
## no smooth displacement, now let's check the distances:
rot2ref &lt;- rotonto(relaxProcD,longnose.lm)
angle.calc(rot2ref$X,rot2ref$Y)
# 0.2492027 Procrustes distance between reference and slided shape
# (minimizing Procrustes distance)
rot2refBend &lt;- rotonto(relax,longnose.lm)
angle.calc(rot2refBend$X,rot2refBend$Y)
# 0.2861322 Procrustes distance between reference and slided shape
# (minimizing bending energy)

rot2refOrig &lt;- rotonto(shortnose.lm,longnose.lm)
angle.calc(rot2refOrig$X,rot2refOrig$Y)
# 0.3014957 Procrustes distance between reference and original shape
##result: while minimizing Procrustes distance, displacement is not
##guaranteed to be smooth

# add surface
wire3d(shortnose.mesh, col="white")


## finally relax two meshes with corresponding vertices:

mediumnose.mesh &lt;- tps3d(shortnose.mesh,shortnose.lm, (shortnose.lm+longnose.lm)/2,threads=1)
## we use Procrustes distance as criterion as bending energy is pretty slow because
## of too many coordinates (more than 3000 is very unreasonable).
relaxMesh &lt;- relaxLM(shortnose.mesh,mediumnose.mesh,iterations=2,bending=FALSE,stepsize=0.05)

## End(Not run)
</code></pre>

<hr>
<h2 id='relWarps'>calculate relative Warp analysis</h2><span id='topic+relWarps'></span>

<h3>Description</h3>

<p>After Procrustes registration the data is scaled by the bending energy or
its inverse to emphasize global/local differences when exploring a sample's
shape.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>relWarps(
  data,
  scale = TRUE,
  CSinit = TRUE,
  alpha = 1,
  tol = 1e-10,
  orp = TRUE,
  pcAlign = TRUE,
  computeBasis = TRUE,
  noalign = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="relWarps_+3A_data">data</code></td>
<td>
<p>Input k x m x n real array, where k is the number of points, m
is the number of dimensions, and n is the sample size.</p>
</td></tr>
<tr><td><code id="relWarps_+3A_scale">scale</code></td>
<td>
<p>Logical: indicating if scaling is requested</p>
</td></tr>
<tr><td><code id="relWarps_+3A_csinit">CSinit</code></td>
<td>
<p>Logical: if TRUE, all configurations are initially scaled to
Unit Centroid Size.</p>
</td></tr>
<tr><td><code id="relWarps_+3A_alpha">alpha</code></td>
<td>
<p>integer: power of the bending energy matrix. If alpha = 0 then
standard Procrustes PCA is carried out. If alpha = 1 then large scale
differences are emphasized, if alpha = -1 then small scale variations are
emphasised.</p>
</td></tr>
<tr><td><code id="relWarps_+3A_tol">tol</code></td>
<td>
<p>tolerance for the eigenvalues of the bending energy matrix to be
zero</p>
</td></tr>
<tr><td><code id="relWarps_+3A_orp">orp</code></td>
<td>
<p>logical: request orthogonal projection into tangent space.</p>
</td></tr>
<tr><td><code id="relWarps_+3A_pcalign">pcAlign</code></td>
<td>
<p>logical: if TRUE, the shapes are aligned by the principal axis of the first specimen</p>
</td></tr>
<tr><td><code id="relWarps_+3A_computebasis">computeBasis</code></td>
<td>
<p>logical: whether to compute the basis of the resulting vector space (takes a lot of memory and time for configurations with &gt; 1000 coordinates.</p>
</td></tr>
<tr><td><code id="relWarps_+3A_noalign">noalign</code></td>
<td>
<p>logical: if TRUE, data is assumed to be already aligned and alignment and orthogonal projection are skipped.</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>bescores</code></td>
<td>
<p>relative warp scores (PC-scores if <code>alpha = 0</code>)</p>
</td></tr>
<tr><td><code>uniscores</code></td>
<td>
<p>uniform scores, NULL if  <code>alpha = 0</code></p>
</td></tr>
<tr><td><code>Var</code></td>
<td>
<p>non-affine variation explained by each relative warp</p>
</td></tr>
<tr><td><code>mshape</code></td>
<td>
<p>sample's conensus shape</p>
</td></tr>
<tr><td><code>rotated</code></td>
<td>
<p>Procrustes superimposed data</p>
</td></tr>
<tr><td><code>bePCs</code></td>
<td>
<p>vector basis of nonaffine shape variation- relative warps (plain PCs if  <code>alpha = 0</code>)</p>
</td></tr>
<tr><td><code>uniPCs</code></td>
<td>
<p>vector basis of affine shape variation - uniform
component. NULL if <code>alpha = 0</code></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Stefan Schlager
</p>


<h3>References</h3>

<p>Bookstein FL 1989. Principal Warps: Thin-plate splines and the
decomposition of deformations. IEEE Transactions on pattern analysis and
machine intelligence 11.
</p>
<p>Bookstein FL, 1991. Morphometric tools for landmark
data. Geometry and biology. Cambridge Univ. Press, Cambridge.
</p>
<p>Rohlf FJ, Bookstein FL 2003. Computing the Uniform Component of Shape
Variation. Systematic Biology 52:66-69.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(boneData)
pop &lt;- name2factor(boneLM,which=3)
rW &lt;- relWarps(boneLM, alpha = -1)
## Not run: 
if (require(car)) {
# plot first 5 relative warps scores grouped by population
spm(rW$bescores[,1:5],group=pop)
# plot uniform component scores grouped by population
spm(rW$uniscores[,1:5],group=pop)
}
##plot non-affine variance associated with each relative warp
barplot(rW$Var[,2], xlab="relative Warps")
## visualize first relative warp +-3 sd of the scores
rw1 &lt;- restoreShapes(as.matrix(c(-3,3)*sd(rW$bescores[,1])),rW$bePCs[,1,drop=FALSE],rW$mshape)
deformGrid3d(rw1[,,1],rw1[,,2],ngrid=5)

## 2D example:
if (require(shapes)) {
data &lt;- bindArr(gorf.dat, gorm.dat, along=3)
sex &lt;- factor(c(rep("fem", dim(gorf.dat)[3]), rep("male",dim(gorm.dat)[3])))
rW &lt;- relWarps(data, alpha = -1)
if (require(car)) {
# plot first 3 relative warps scores grouped by population
spm(rW$bescores[,1:3],group=sex)
# plot uniform component scores grouped by population
spm(rW$uniscores[,1:2],group=sex)
}
##plot non-affine variance associated with each relative warp
barplot(rW$Var[,2], xlab="relative Warps")
## visualize first relative warp +-3 sd of the scores
rw1 &lt;- restoreShapes(as.matrix(c(-3,3)*sd(rW$bescores[,1])),rW$bePCs[,1,drop=FALSE],rW$mshape)
deformGrid2d(rw1[,,1],rw1[,,2],ngrid=10)
}
## End(Not run)

</code></pre>

<hr>
<h2 id='render'>plot or save the results of meshDist</h2><span id='topic+render'></span><span id='topic+render.meshDist'></span><span id='topic+render.matrixDist'></span><span id='topic+export'></span><span id='topic+export.meshDist'></span>

<h3>Description</h3>

<p>plot or save the results of meshDist
</p>


<h3>Usage</h3>

<pre><code class='language-R'>render(x, ...)

## S3 method for class 'meshDist'
render(
  x,
  from = NULL,
  to = NULL,
  steps = NULL,
  ceiling = NULL,
  uprange = NULL,
  tol = NULL,
  tolcol = NULL,
  rampcolors = NULL,
  NAcol = NULL,
  displace = FALSE,
  shade = TRUE,
  sign = NULL,
  add = FALSE,
  scaleramp = NULL,
  titleplot = "Distance in mm",
  ...
)

## S3 method for class 'matrixDist'
render(
  x,
  from = NULL,
  to = NULL,
  steps = NULL,
  ceiling = NULL,
  uprange = NULL,
  tol = NULL,
  tolcol = NULL,
  type = c("s", "p"),
  radius = NULL,
  rampcolors = NULL,
  NAcol = NULL,
  displace = FALSE,
  sign = NULL,
  add = FALSE,
  scaleramp = FALSE,
  titleplot = "Distance in mm",
  ...
)

export(x, ...)

## S3 method for class 'meshDist'
export(
  x,
  file = "default",
  imagedim = "100x800",
  titleplot = "Distance in mm",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="render_+3A_x">x</code></td>
<td>
<p>object of class meshDist</p>
</td></tr>
<tr><td><code id="render_+3A_...">...</code></td>
<td>
<p>for render.meshDist: additional arguments passed to
<code><a href="rgl.html#topic+shade3d">shade3d</a></code>. See <code><a href="rgl.html#topic+material3d">material3d</a></code> for details.</p>
</td></tr>
<tr><td><code id="render_+3A_from">from</code></td>
<td>
<p>numeric: minimum distance to color; default is set to 0 mm</p>
</td></tr>
<tr><td><code id="render_+3A_to">to</code></td>
<td>
<p>numeric: maximum distance to color; default is set to the maximum
distance</p>
</td></tr>
<tr><td><code id="render_+3A_steps">steps</code></td>
<td>
<p>integer: determines how many intermediate colors the color ramp
has.</p>
</td></tr>
<tr><td><code id="render_+3A_ceiling">ceiling</code></td>
<td>
<p>logical: if TRUE, the next larger integer of &quot;to&quot; is used</p>
</td></tr>
<tr><td><code id="render_+3A_uprange">uprange</code></td>
<td>
<p>numeric between 0 and 1: restricts &quot;to&quot; to a quantile of
&quot;to&quot;, if to is NULL.</p>
</td></tr>
<tr><td><code id="render_+3A_tol">tol</code></td>
<td>
<p>numeric: threshold to color distances within this threshold
according to <code>tolcol</code>.</p>
</td></tr>
<tr><td><code id="render_+3A_tolcol">tolcol</code></td>
<td>
<p>a custom color to color vertices below a threshold defined by <code>tol</code>. Default is green.</p>
</td></tr>
<tr><td><code id="render_+3A_rampcolors">rampcolors</code></td>
<td>
<p>character vector: specify the colors which are used to create a colorramp.</p>
</td></tr>
<tr><td><code id="render_+3A_nacol">NAcol</code></td>
<td>
<p>character: specify color for values outside the range defined by <code>from</code> and <code>to</code>.</p>
</td></tr>
<tr><td><code id="render_+3A_displace">displace</code></td>
<td>
<p>logical: if TRUE, displacement vectors between original and
closest points are drawn colored according to the distance.</p>
</td></tr>
<tr><td><code id="render_+3A_shade">shade</code></td>
<td>
<p>logical: if FALSE, the rendering of the colored surface will be
supressed.</p>
</td></tr>
<tr><td><code id="render_+3A_sign">sign</code></td>
<td>
<p>logical: request signed distances to be visualised.</p>
</td></tr>
<tr><td><code id="render_+3A_add">add</code></td>
<td>
<p>logical: if TRUE, visualization will be added to the rgl window currently in focus</p>
</td></tr>
<tr><td><code id="render_+3A_scaleramp">scaleramp</code></td>
<td>
<p>if TRUE the ramp colors get scaled symmetrically into positive and negative direction.</p>
</td></tr>
<tr><td><code id="render_+3A_titleplot">titleplot</code></td>
<td>
<p>character: axis description of heatmap.</p>
</td></tr>
<tr><td><code id="render_+3A_type">type</code></td>
<td>
<p>character: &quot;s&quot; shows coordinates as spheres, while &quot;p&quot; shows 3D
dots.</p>
</td></tr>
<tr><td><code id="render_+3A_radius">radius</code></td>
<td>
<p>determines size of spheres; if not specified, optimal radius
size will be estimated by centroid size of the configuration.</p>
</td></tr>
<tr><td><code id="render_+3A_file">file</code></td>
<td>
<p>character: filename for mesh and image files produced. E.g.
&quot;mydist&quot; will produce the files mydist.ply and mydist.png</p>
</td></tr>
<tr><td><code id="render_+3A_imagedim">imagedim</code></td>
<td>
<p>character of pattern &quot;100x200&quot; where 100 determines the
width and 200 the height of the image.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Visualise or save the results of meshDist to disk.
</p>
<p>render.meshDist renders the colored mesh and displays the color ramp and
returns an object of class &quot;meshDist&quot;.  export.meshDist exports the colored
mesh as ply file and the color chart as png file.
</p>


<h3>Author(s)</h3>

<p>Stefan Schlager
</p>


<h3>See Also</h3>

<p><code><a href="#topic+meshDist">meshDist</a></code>, <code><a href="rgl.html#topic+shade3d">shade3d</a></code>
</p>

<hr>
<h2 id='resampleCurve'>Resample a curve equidistantly</h2><span id='topic+resampleCurve'></span>

<h3>Description</h3>

<p>Resample a curve equidistantly (optionally with smoothing)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>resampleCurve(x, n, smooth = FALSE, smoothn = n, open = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="resampleCurve_+3A_x">x</code></td>
<td>
<p>matrix containing coordinates</p>
</td></tr>
<tr><td><code id="resampleCurve_+3A_n">n</code></td>
<td>
<p>number of resulting points on the resampled curve</p>
</td></tr>
<tr><td><code id="resampleCurve_+3A_smooth">smooth</code></td>
<td>
<p>logical: if TRUE, the resulting curve will be smoothed by using bezier curves.</p>
</td></tr>
<tr><td><code id="resampleCurve_+3A_smoothn">smoothn</code></td>
<td>
<p>integer: define the refinement of the bezier curve. The higher this value, the closer the final curve will be to the original.</p>
</td></tr>
<tr><td><code id="resampleCurve_+3A_open">open</code></td>
<td>
<p>logical: define whether it is a closed curve or not.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns a matrix containing the resampled curve
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(nose)
x &lt;- shortnose.lm[c(304:323),]
xsample &lt;- resampleCurve(x,n=50)
</code></pre>

<hr>
<h2 id='restoreFromPCA'>restore original data from PCA</h2><span id='topic+restoreFromPCA'></span>

<h3>Description</h3>

<p>restore original data from PCA by reverting rotation and centering
</p>


<h3>Usage</h3>

<pre><code class='language-R'>restoreFromPCA(scores, rotation, center)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="restoreFromPCA_+3A_scores">scores</code></td>
<td>
<p>matrix containing the PC-scores</p>
</td></tr>
<tr><td><code id="restoreFromPCA_+3A_rotation">rotation</code></td>
<td>
<p>matrix containing the PCs</p>
</td></tr>
<tr><td><code id="restoreFromPCA_+3A_center">center</code></td>
<td>
<p>vector containing the center</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>myirispca &lt;- prcomp(iris[,1:4])
myirisRecovered &lt;- restoreFromPCA(myirispca$x,myirispca$rotation,myirispca$center)
all.equal(myirisRecovered,as.matrix(iris[,1:4]))
</code></pre>

<hr>
<h2 id='restoreShapes'>restore shapes from PC-Scores or similar projections</h2><span id='topic+restoreShapes'></span>

<h3>Description</h3>

<p>restore shapes from PC-Scores or similar projections
</p>


<h3>Usage</h3>

<pre><code class='language-R'>restoreShapes(
  scores,
  PC,
  mshape,
  sizeshape = FALSE,
  origsize = FALSE,
  meanlogCS
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="restoreShapes_+3A_scores">scores</code></td>
<td>
<p>vector of PC-scores, or matrix with rows containing PC-scores</p>
</td></tr>
<tr><td><code id="restoreShapes_+3A_pc">PC</code></td>
<td>
<p>Principal components (eigenvectors of the covariance matrix)
associated with 'scores'.</p>
</td></tr>
<tr><td><code id="restoreShapes_+3A_mshape">mshape</code></td>
<td>
<p>matrix containing the meanshape's landmarks (used to center
the data by the PCA)</p>
</td></tr>
<tr><td><code id="restoreShapes_+3A_sizeshape">sizeshape</code></td>
<td>
<p>logical: if TRUE, it is assumed that the data is the output of <code>procSym</code> run with <code>sizeshape=TRUE</code>.</p>
</td></tr>
<tr><td><code id="restoreShapes_+3A_origsize">origsize</code></td>
<td>
<p>logical: if <code>sizeshape = TRUE</code>, this will apply the scaling to the original size from the corresponding entry from the PC basis matrix.</p>
</td></tr>
<tr><td><code id="restoreShapes_+3A_meanlogcs">meanlogCS</code></td>
<td>
<p>numeric: provide the average log Centroid Size of the original sample (see examples below). Only needed if <code>sizeshape = TRUE</code> and <code>origsize = TRUE</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Rotates and translates PC-scores (or similar) derived from shape data back into
configuration space.
</p>


<h3>Value</h3>

<p>returns matrix or array containing landmarks
</p>


<h3>Author(s)</h3>

<p>Stefan Schlager
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+prcomp">prcomp</a></code>, <code><a href="#topic+procSym">procSym</a></code>
</p>
<p><code><a href="#topic+getPCscores">getPCscores</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (require(shapes)) {
## generate landmarks using
##the first PC-score of the first specimen

proc &lt;- procSym(gorf.dat)
lm &lt;- restoreShapes(proc$PCscores[1,1],proc$PCs[,1],proc$mshape)
plot(lm,asp=1)

##now the first 3 scores
lm2 &lt;- restoreShapes(proc$PCscores[1,1:3],proc$PCs[,1:3],proc$mshape)
points(lm2,col=2)

## Now restore some sizeshape data
procSize &lt;- procSym(gorf.dat,sizeshape=TRUE)
est1 &lt;- restoreShapes(range(procSize$PCscores[,1]),procSize$PCs[,1],procSize$mshape,
                      sizeshape=TRUE,origsize=TRUE,meanlogCS=procSize$meanlogCS)
}

</code></pre>

<hr>
<h2 id='retroDeform3d'>symmetrize a bilateral landmark configuration</h2><span id='topic+retroDeform3d'></span>

<h3>Description</h3>

<p>symmetrize a bilateral landmark configuration by removing bending and stretching
</p>


<h3>Usage</h3>

<pre><code class='language-R'>retroDeform3d(mat, pairedLM, hmult = 5, alpha = 0.01)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="retroDeform3d_+3A_mat">mat</code></td>
<td>
<p>matrix with bilateral landmarks</p>
</td></tr>
<tr><td><code id="retroDeform3d_+3A_pairedlm">pairedLM</code></td>
<td>
<p>2-column integer matrix with the 1st columns containing row indices of left side landmarks and 2nd column the right hand landmarks</p>
</td></tr>
<tr><td><code id="retroDeform3d_+3A_hmult">hmult</code></td>
<td>
<p>factor controlling the bandwidth for calculating local weights (which will be <code>hmult</code> * average distance between landmarks and their closest neighbour).</p>
</td></tr>
<tr><td><code id="retroDeform3d_+3A_alpha">alpha</code></td>
<td>
<p>factor controlling spacing along x-axis</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>deformed</code></td>
<td>
<p>matrix containing deformed landmarks</p>
</td></tr>
<tr><td><code>orig</code></td>
<td>
<p>matrix containing original landmarks</p>
</td></tr>
</table>


<h3>References</h3>

<p>Ghosh, D.; Amenta, N. &amp; Kazhdan, M. Closed-form Blending of Local Symmetries. Computer Graphics Forum, Wiley-Blackwell, 2010, 29, 1681-1688
</p>

<hr>
<h2 id='retroDeformMesh'>symmetrize a triangular mesh</h2><span id='topic+retroDeformMesh'></span>

<h3>Description</h3>

<p>symmetrize a triangular mesh
</p>


<h3>Usage</h3>

<pre><code class='language-R'>retroDeformMesh(
  mesh,
  mat,
  pairedLM,
  hmult = 5,
  alpha = 0.01,
  rot = TRUE,
  lambda = 1e-08,
  threads = 0
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="retroDeformMesh_+3A_mesh">mesh</code></td>
<td>
<p>triangular mesh of class mesh3d</p>
</td></tr>
<tr><td><code id="retroDeformMesh_+3A_mat">mat</code></td>
<td>
<p>matrix with bilateral landmarks</p>
</td></tr>
<tr><td><code id="retroDeformMesh_+3A_pairedlm">pairedLM</code></td>
<td>
<p>2-column integer matrix with the 1st columns containing row indices of left side landmarks and 2nd column the right hand landmarks</p>
</td></tr>
<tr><td><code id="retroDeformMesh_+3A_hmult">hmult</code></td>
<td>
<p>damping factor for calculating local weights which is calculated as <code>humult</code> times the average squared distance between a landmark and its closest neighbor (on each side).</p>
</td></tr>
<tr><td><code id="retroDeformMesh_+3A_alpha">alpha</code></td>
<td>
<p>factor controlling spacing along x-axis</p>
</td></tr>
<tr><td><code id="retroDeformMesh_+3A_rot">rot</code></td>
<td>
<p>logical: if TRUE the deformed landmarks are rotated back onto the original ones</p>
</td></tr>
<tr><td><code id="retroDeformMesh_+3A_lambda">lambda</code></td>
<td>
<p>control parameter passed to <code><a href="#topic+tps3d">tps3d</a></code></p>
</td></tr>
<tr><td><code id="retroDeformMesh_+3A_threads">threads</code></td>
<td>
<p>integer: number of threads to use for TPS deform</p>
</td></tr>
</table>


<h3>Details</h3>

<p>this function performs <code><a href="#topic+retroDeform3d">retroDeform3d</a></code> and deforms the mesh accordingly using the function <code><a href="#topic+tps3d">tps3d</a></code>.
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>mesh</code></td>
<td>
<p>symmetrized mesh</p>
</td></tr>
<tr><td><code>landmarks</code></td>
<td>
<p>a list containing the deformed and original landmarks</p>
</td></tr>
</table>

<hr>
<h2 id='rotaxis3d'>Rotate an object (matrix or mesh) around an arbitrary axis in 3D</h2><span id='topic+rotaxis3d'></span><span id='topic+rotaxis3d.matrix'></span><span id='topic+rotaxis3d.mesh3d'></span>

<h3>Description</h3>

<p>Rotate an object around an arbitrary axis in 3D
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rotaxis3d(x, pt1, pt2 = c(0, 0, 0), theta)

## S3 method for class 'matrix'
rotaxis3d(x, pt1, pt2 = c(0, 0, 0), theta)

## S3 method for class 'mesh3d'
rotaxis3d(x, pt1, pt2 = c(0, 0, 0), theta)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rotaxis3d_+3A_x">x</code></td>
<td>
<p>k x 3 matrix containing 3D-coordinates or a triangular mesh of
class &quot;mesh3d&quot;.</p>
</td></tr>
<tr><td><code id="rotaxis3d_+3A_pt1">pt1</code></td>
<td>
<p>numeric vector of length 3, defining first point on the rotation
axis.</p>
</td></tr>
<tr><td><code id="rotaxis3d_+3A_pt2">pt2</code></td>
<td>
<p>numeric vector of length 3, defining second point on the rotation
axis.</p>
</td></tr>
<tr><td><code id="rotaxis3d_+3A_theta">theta</code></td>
<td>
<p>angle to rotate in radians. With pt1 being the viewpoint, the
rotation is counterclockwise.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Rotate an object (matrix or triangular mesh) around an 3D-axis defined by
two points.
</p>


<h3>Value</h3>

<p>returns rotated object (including updated normals for mesh3d
objects)
</p>


<h3>Author(s)</h3>

<p>Stefan Schlager
</p>


<h3>References</h3>

<p>http://en.wikipedia.org/wiki/Rotation_matrix
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rotonto">rotonto</a></code>, <code><a href="#topic+rotmesh.onto">rotmesh.onto</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
require(rgl)
data(nose)
shrot.rot &lt;- rotaxis3d(shortnose.mesh,pt1=c(1,1,1),theta=pi)
## Not run: 
shade3d(shortnose.mesh,col=3,specular=1)
shade3d(shrot.rot,col=2)

###print rotation axis
#' lines3d(rbind(rep(-0.1,3),rep(0.1,3)))

## End(Not run)
</code></pre>

<hr>
<h2 id='rotaxisMat'>calculate a rotation matrix around an arbitrary axis through the origin in
3D</h2><span id='topic+rotaxisMat'></span>

<h3>Description</h3>

<p>calculate a rotation matrix around an arbitrary axis in 3D
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rotaxisMat(u, theta, homogeneous = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rotaxisMat_+3A_u">u</code></td>
<td>
<p>a vector around which to rotate</p>
</td></tr>
<tr><td><code id="rotaxisMat_+3A_theta">theta</code></td>
<td>
<p>angle in radians to rotate</p>
</td></tr>
<tr><td><code id="rotaxisMat_+3A_homogeneous">homogeneous</code></td>
<td>
<p>logical: if TRUE a 4x4 rotation matrix is returned</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns 3x3 rotation matrix
</p>


<h3>References</h3>

<p>http://en.wikipedia.org/wiki/Rotation_matrix
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rotaxis3d">rotaxis3d</a></code>
</p>

<hr>
<h2 id='rotmesh.onto'>rotate ,scale and translate a mesh based on landmark information.</h2><span id='topic+rotmesh.onto'></span>

<h3>Description</h3>

<p>rotates and reflects a mesh onto by calculating the transformation from two
sets of referenced landmarks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rotmesh.onto(
  mesh,
  refmat,
  tarmat,
  adnormals = FALSE,
  scale = FALSE,
  reflection = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rotmesh.onto_+3A_mesh">mesh</code></td>
<td>
<p>object of class mesh3d.</p>
</td></tr>
<tr><td><code id="rotmesh.onto_+3A_refmat">refmat</code></td>
<td>
<p>k x m matrix with landmarks on the mesh</p>
</td></tr>
<tr><td><code id="rotmesh.onto_+3A_tarmat">tarmat</code></td>
<td>
<p>k x m matrix as target configuration</p>
</td></tr>
<tr><td><code id="rotmesh.onto_+3A_adnormals">adnormals</code></td>
<td>
<p>logical - if TRUE, vertex normals will be recomputed after
rotation. If <code>mesh</code> has normals and adnormals=FALSE, the existing
normals are rotated by the same rotation matrix as the mesh's vertices.</p>
</td></tr>
<tr><td><code id="rotmesh.onto_+3A_scale">scale</code></td>
<td>
<p>logical: if TRUE the mesh will be scaled according to the size
of the target.</p>
</td></tr>
<tr><td><code id="rotmesh.onto_+3A_reflection">reflection</code></td>
<td>
<p>logical: allow reflection.</p>
</td></tr>
<tr><td><code id="rotmesh.onto_+3A_...">...</code></td>
<td>
<p>additional parameters passed on to <code><a href="#topic+rotonto">rotonto</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>mesh</code></td>
<td>
<p>rotated mesh</p>
</td></tr>
<tr><td><code>yrot</code></td>
<td>
<p>rotated refmat</p>
</td></tr>
<tr><td><code>trafo</code></td>
<td>
<p>4x4 transformation matrix</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Stefan Schlager
</p>


<h3>See Also</h3>

<p><code><a href="#topic+file2mesh">file2mesh</a></code>,<code><a href="#topic+tps3d">tps3d</a></code>
,<code><a href="#topic+rotonto">rotonto</a></code>,<code><a href="#topic+mesh2ply">mesh2ply</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
require(rgl)
data(boneData)
## rotate, translate and scale the mesh belonging to the first specimen
## onto the landmark configuration of the 10th specimen
rotmesh &lt;- rotmesh.onto(skull_0144_ch_fe.mesh,boneLM[,,1],
                        boneLM[,,10], scale=TRUE)
## Not run: 
## render rotated mesh and landmarks
shade3d(rotmesh$mesh, col=2, specular=1)
spheres3d(boneLM[,,1])
## render original mesh
shade3d(skull_0144_ch_fe.mesh, col=3, specular=1)
spheres3d(boneLM[,,10])

## End(Not run)

</code></pre>

<hr>
<h2 id='rotonmat'>rotate matrix of landmarks</h2><span id='topic+rotonmat'></span>

<h3>Description</h3>

<p>rotate matrix of landmarks by using a rotation determined by two matrices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rotonmat(
  X,
  refmat,
  tarmat,
  scale = TRUE,
  reflection = FALSE,
  weights = NULL,
  centerweight = FALSE,
  getTrafo = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rotonmat_+3A_x">X</code></td>
<td>
<p>Matrix to be rotated</p>
</td></tr>
<tr><td><code id="rotonmat_+3A_refmat">refmat</code></td>
<td>
<p>reference matrix used to estimate rotation parameters</p>
</td></tr>
<tr><td><code id="rotonmat_+3A_tarmat">tarmat</code></td>
<td>
<p>target matrix used to estimate rotation parameters</p>
</td></tr>
<tr><td><code id="rotonmat_+3A_scale">scale</code></td>
<td>
<p>logical: requests scaling to minimize sums of squared distances</p>
</td></tr>
<tr><td><code id="rotonmat_+3A_reflection">reflection</code></td>
<td>
<p>logical: if TRUE, reflections are allowed.</p>
</td></tr>
<tr><td><code id="rotonmat_+3A_weights">weights</code></td>
<td>
<p>vector of length k, containing weights for each landmark.</p>
</td></tr>
<tr><td><code id="rotonmat_+3A_centerweight">centerweight</code></td>
<td>
<p>logical: if weights are defined and centerweigths=TRUE,
the matrix will be centered according to these weights instead of the
barycenter.</p>
</td></tr>
<tr><td><code id="rotonmat_+3A_gettrafo">getTrafo</code></td>
<td>
<p>logical: if TRUE, a 4x4 transformation matrix will also be returned.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A matrix is rotated by rotation parameters determined by two different
matrices. This is usefull, if the rotation parameters are to be estimated by
a subset of landmark coordinates.
</p>


<h3>Value</h3>

<p>if <code>getTrafo=FALSE</code> the transformed X will be returned,
else alist containing:
</p>
<table role = "presentation">
<tr><td><code>Xrot</code></td>
<td>
<p>the transformed matrix X</p>
</td></tr>
<tr><td><code>trafo</code></td>
<td>
<p>a 4x4 transformation matrix</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Stefan Schlager
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rotonto">rotonto</a></code>,<code><a href="#topic+rotmesh.onto">rotmesh.onto</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

data(nose)
shortnose.rot &lt;-
rotonmat(shortnose.lm,shortnose.lm[1:9,],longnose.lm[1:9,])

##view result
## Not run: 
deformGrid3d(shortnose.rot,shortnose.lm,ngrid=0)

## End(Not run)
</code></pre>

<hr>
<h2 id='rotonto'>rotates, translates and scales one matrix onto an other using Procrustes
fitting</h2><span id='topic+rotonto'></span><span id='topic+rotreverse'></span><span id='topic+rotreverse.matrix'></span><span id='topic+rotreverse.mesh3d'></span>

<h3>Description</h3>

<p>rotates, translates and scales one matrix onto an other using Procrustes
fitting
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rotonto(
  x,
  y,
  scale = FALSE,
  signref = TRUE,
  reflection = TRUE,
  weights = NULL,
  centerweight = FALSE,
  ...
)

rotreverse(mat, rot)

## S3 method for class 'matrix'
rotreverse(mat, rot)

## S3 method for class 'mesh3d'
rotreverse(mat, rot)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rotonto_+3A_x">x</code></td>
<td>
<p>k x m matrix to be rotated onto (targetmatrix)</p>
</td></tr>
<tr><td><code id="rotonto_+3A_y">y</code></td>
<td>
<p>k x m matrix which will be rotated (reference matrix)</p>
</td></tr>
<tr><td><code id="rotonto_+3A_scale">scale</code></td>
<td>
<p>logical: scale matrix to minimize sums of squares</p>
</td></tr>
<tr><td><code id="rotonto_+3A_signref">signref</code></td>
<td>
<p>logical: report if reflections were involved in the rotation</p>
</td></tr>
<tr><td><code id="rotonto_+3A_reflection">reflection</code></td>
<td>
<p>allow reflections.</p>
</td></tr>
<tr><td><code id="rotonto_+3A_weights">weights</code></td>
<td>
<p>vector of length k, containing weights for each landmark.</p>
</td></tr>
<tr><td><code id="rotonto_+3A_centerweight">centerweight</code></td>
<td>
<p>logical or vector of weights: if weights are defined and centerweigths=TRUE,
the matrix will be centered according to these weights instead of the
barycenter. If centerweight is a vector of length <code>nrow(x)</code>, the barycenter will be weighted accordingly.</p>
</td></tr>
<tr><td><code id="rotonto_+3A_...">...</code></td>
<td>
<p>currently not used</p>
</td></tr>
<tr><td><code id="rotonto_+3A_mat">mat</code></td>
<td>
<p>matrix on which the reverse transformations have to be applied</p>
</td></tr>
<tr><td><code id="rotonto_+3A_rot">rot</code></td>
<td>
<p>an object resulting from the former application of rotonto</p>
</td></tr>
</table>


<h3>Details</h3>

<p>rotate a matrix onto an other without loosing information about the location
of the targetmatrix and reverse this transformations using rotreverse
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>yrot</code></td>
<td>
<p>rotated and translated matrix</p>
</td></tr>
<tr><td><code>Y</code></td>
<td>
<p>centred and rotated reference matrix</p>
</td></tr>
<tr><td><code>X</code></td>
<td>
<p>centred target matrix</p>
</td></tr>
<tr><td><code>trans</code></td>
<td>
<p>vector between original position of target and centered
reference (during rotation process)</p>
</td></tr>
<tr><td><code>transy</code></td>
<td>
<p>vector between original position of reference and
centered reference (during rotation process)</p>
</td></tr>
<tr><td><code>gamm</code></td>
<td>
<p>rotation matrix</p>
</td></tr>
<tr><td><code>bet</code></td>
<td>
<p>scaling factor applied</p>
</td></tr>
<tr><td><code>reflect</code></td>
<td>
<p>if <code>reflect = 1</code>, reflections are involved in the
superimposition. Else, reflect = 0</p>
</td></tr>
</table>


<h3>Note</h3>

<p>all lines containing NA, or NaN are ignored in computing the transformation.
</p>


<h3>Author(s)</h3>

<p>Stefan Schlager
</p>


<h3>References</h3>

<p>Lissitz, R. W., Schoenemann, P. H., &amp; Lingoes, J. C. (1976). A
solution to the weighted Procrustes problem in which the transformation is
in agreement with the loss function. Psychometrika, 41,547-550.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rotmesh.onto">rotmesh.onto</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (require(shapes)) {
lims &lt;- c(min(gorf.dat[,,1:2]),max(gorf.dat[,,1:2]))
rot &lt;- rotonto(gorf.dat[,,1],gorf.dat[,,2]) ### rotate the second onto the first config
plot(rot$yrot,pch=19,xlim=lims,ylim=lims) ## view result
points(gorf.dat [,,2],pch=19,col=2) ## view original config
rev1 &lt;- rotreverse(rot$yrot,rot)
points(rev1,cex=2) ### show inversion by larger circles around original configuration
}

</code></pre>

<hr>
<h2 id='scalemesh'>scale a mesh of class &quot;mesh3d&quot;</h2><span id='topic+scalemesh'></span>

<h3>Description</h3>

<p>scales (the vertices of a mesh by a scalar
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scalemesh(mesh, size, center = c("bbox", "mean", "none"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="scalemesh_+3A_mesh">mesh</code></td>
<td>
<p>object of class &quot;mesh3d&quot;</p>
</td></tr>
<tr><td><code id="scalemesh_+3A_size">size</code></td>
<td>
<p>numeric: scale factor</p>
</td></tr>
<tr><td><code id="scalemesh_+3A_center">center</code></td>
<td>
<p>character: method to position center of mesh after scaling:
values are &quot;bbox&quot;, and &quot;mean&quot;. See Details for more info.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The mesh's center is determined either as mean of the bounding box
(center=&quot;bbox&quot;) or mean of vertex coordinates (center=&quot;mean&quot;) and then
scaled according to the scaling factor. If center=&quot;none&quot;, vertex coordinates
will simply be multiplied by &quot;size&quot;.
</p>


<h3>Value</h3>

<p>returns a scaled mesh
</p>


<h3>Author(s)</h3>

<p>Stefan Schlager
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rotmesh.onto">rotmesh.onto</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(nose)
#inflate mesh by factor 4
largenose &lt;- scalemesh(shortnose.mesh,4)

</code></pre>

<hr>
<h2 id='slider2d'>slides Semilandmarks along curves 2D by minimising bending
energy of a thin-plate spline deformation.</h2><span id='topic+slider2d'></span>

<h3>Description</h3>

<p>slides Semilandmarks along curves 2D. The positions are sought by minimising bending energy (of a thin-plate spline
deformation) or Procrustes distance
</p>


<h3>Usage</h3>

<pre><code class='language-R'>slider2d(
  dataframe,
  SMvector,
  outlines,
  tol = 1e-05,
  deselect = FALSE,
  recursive = TRUE,
  iterations = 0,
  initproc = FALSE,
  pairedLM = NULL,
  bending = TRUE,
  stepsize = 1,
  silent = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="slider2d_+3A_dataframe">dataframe</code></td>
<td>
<p>Input k x 2 x n real array, where k is the number of
points and n is the sample size. Ideally the</p>
</td></tr>
<tr><td><code id="slider2d_+3A_smvector">SMvector</code></td>
<td>
<p>A vector containing the row indices of (semi-) landmarks on the curve(s) and
surfaces that are allowed to slide</p>
</td></tr>
<tr><td><code id="slider2d_+3A_outlines">outlines</code></td>
<td>
<p>A vector (or if threre are several curves) a list of vectors
(containing the rowindices) of the (Semi-)landmarks forming the curve(s) in
the successive position on the curve - including the beginning and end
points, that are not allowed to slide.</p>
</td></tr>
<tr><td><code id="slider2d_+3A_tol">tol</code></td>
<td>
<p>numeric: Threshold for convergence in the sliding process</p>
</td></tr>
<tr><td><code id="slider2d_+3A_deselect">deselect</code></td>
<td>
<p>Logical: if TRUE, the SMvector is interpreted as those
landmarks, that are not allowed to slide.</p>
</td></tr>
<tr><td><code id="slider2d_+3A_recursive">recursive</code></td>
<td>
<p>Logical: if TRUE, during the iterations of the sliding
process, the outcome of the previous iteration will be used.  Otherwise the
original configuration will be used in all iterations.</p>
</td></tr>
<tr><td><code id="slider2d_+3A_iterations">iterations</code></td>
<td>
<p>integer: select manually the max. number of iterations
that will be performed during the sliding process (usefull, when there is
very slow convergence).  0 means iteration until convergence.</p>
</td></tr>
<tr><td><code id="slider2d_+3A_initproc">initproc</code></td>
<td>
<p>requests initial Procrustes fit before sliding.</p>
</td></tr>
<tr><td><code id="slider2d_+3A_pairedlm">pairedLM</code></td>
<td>
<p>A X x 2 numeric matrix with the indices of the rows
containing paired Landmarks. E.g. the left column contains the lefthand
landmarks, while the right side contains the corresponding right hand
landmarks. - This will ideally create symmetric mean to get rid of
assymetry.</p>
</td></tr>
<tr><td><code id="slider2d_+3A_bending">bending</code></td>
<td>
<p>if TRUE, bending energy will be minimized, Procrustes distance otherwise.</p>
</td></tr>
<tr><td><code id="slider2d_+3A_stepsize">stepsize</code></td>
<td>
<p>integer: dampening factor for the amount of sliding.
Useful to keep semi-landmarks from sliding too far off the surface.
The displacement is calculated as  <code class="reqn">\Upsilon = \Upsilon^0 + stepsize * UT</code>.
Default is set to 1 for bending=TRUE and 0.5 for bending=FALSE.</p>
</td></tr>
<tr><td><code id="slider2d_+3A_silent">silent</code></td>
<td>
<p>logical: if TRUE, console output is suppressed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns an array containing slided coorndinates in the original
space - not yet processed by a Procrustes analysis.
</p>


<h3>Warning</h3>

<p>Depending on the amount of landmarks this can use an extensive amount of your PC's
resources, especially when running in parallel. As the computation time and
RAM usage of matrix algebra involved is quadratic to the amount of landmarks
used, doubling the amount of semi-landmarks will quadruple computation time
and system resource usage. You can easily stall you computer with this
function with inappropriate data.
</p>


<h3>Author(s)</h3>

<p>Stefan Schlager
</p>


<h3>See Also</h3>

<p><code><a href="#topic+relaxLM">relaxLM</a>, <a href="#topic+slider3d">slider3d</a></code>
</p>

<hr>
<h2 id='slider3d'>slides Semilandmarks along curves and surfaces in 3D by minimising bending
energy of a thin-plate spline deformation.</h2><span id='topic+slider3d'></span>

<h3>Description</h3>

<p>slides Semilandmarks along curves and surfaces in 3D. The positions on the
surface are sought which minimise bending energy (of a thin-plate spline
deformation)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>slider3d(
  dat.array,
  SMvector,
  outlines = NULL,
  surp = NULL,
  sur.path = NULL,
  sur.name = NULL,
  meshlist = NULL,
  ignore = NULL,
  sur.type = "ply",
  tol = 1e-05,
  deselect = FALSE,
  inc.check = TRUE,
  recursive = TRUE,
  iterations = 0,
  initproc = TRUE,
  fullGPA = FALSE,
  pairedLM = 0,
  bending = TRUE,
  stepsize = ifelse(bending, 1, 0.5),
  mc.cores = parallel::detectCores(),
  fixRepro = TRUE,
  missingList = NULL,
  use.lm = NULL,
  smoothnormals = FALSE,
  silent = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="slider3d_+3A_dat.array">dat.array</code></td>
<td>
<p>Input k x m x n real array, where k is the number of
points, m is the number of dimensions, and n is the sample size. Ideally the
dimnames[[3]] vector contains the names of the surface model (without file
extension) - e.g. if the model is named &quot;surface.ply&quot;, the name of the
corresponding matrix of the array would be &quot;surface&quot;</p>
</td></tr>
<tr><td><code id="slider3d_+3A_smvector">SMvector</code></td>
<td>
<p>A vector containing the row indices of (semi-) landmarks on the curve(s) and
surfaces that are allowed to slide</p>
</td></tr>
<tr><td><code id="slider3d_+3A_outlines">outlines</code></td>
<td>
<p>A vector (or if threre are several curves) a list of vectors
(containing the rowindices) of the (Semi-)landmarks forming the curve(s) in
the successive position on the curve - including the beginning and end
points, that are not allowed to slide.</p>
</td></tr>
<tr><td><code id="slider3d_+3A_surp">surp</code></td>
<td>
<p>integer vector containing the row indices of semi-landmarks positioned on surfaces.</p>
</td></tr>
<tr><td><code id="slider3d_+3A_sur.path">sur.path</code></td>
<td>
<p>Path to the surface models (e.g. ply, obj, stl files)</p>
</td></tr>
<tr><td><code id="slider3d_+3A_sur.name">sur.name</code></td>
<td>
<p>character vector: containing the filenames of the
corresponding surfaces - e.g. if the dat.array[,,i] belongs to
surface_i.ply, sur.name[i] would be surface_i.ply. Only necessary if
dat.array does not contain surface names.</p>
</td></tr>
<tr><td><code id="slider3d_+3A_meshlist">meshlist</code></td>
<td>
<p>list containing triangular meshes of class 'mesh3d', for
example imported with <code><a href="#topic+mesh2ply">mesh2ply</a></code> or <code><a href="#topic+file2mesh">file2mesh</a></code> in
the same order as the specimen in the array (see examples below).</p>
</td></tr>
<tr><td><code id="slider3d_+3A_ignore">ignore</code></td>
<td>
<p>vector containing indices of landmarks that are to be ignored.
Indices of outlines/surfaces etc will be updated automatically.</p>
</td></tr>
<tr><td><code id="slider3d_+3A_sur.type">sur.type</code></td>
<td>
<p>character:if all surfaces are of the same file format and
the names stored in dat.array, the file format will be specified here.</p>
</td></tr>
<tr><td><code id="slider3d_+3A_tol">tol</code></td>
<td>
<p>numeric: Threshold for convergence in the sliding process</p>
</td></tr>
<tr><td><code id="slider3d_+3A_deselect">deselect</code></td>
<td>
<p>Logical: if TRUE, the SMvector is interpreted as those
landmarks, that are not allowed to slide.</p>
</td></tr>
<tr><td><code id="slider3d_+3A_inc.check">inc.check</code></td>
<td>
<p>Logical: if TRUE, the program stops when convergence
criterion starts increasing and reports result from last iteration.</p>
</td></tr>
<tr><td><code id="slider3d_+3A_recursive">recursive</code></td>
<td>
<p>Logical: if TRUE, during the iterations of the sliding
process, the outcome of the previous iteration will be used.  Otherwise the
original configuration will be used in all iterations.</p>
</td></tr>
<tr><td><code id="slider3d_+3A_iterations">iterations</code></td>
<td>
<p>integer: select manually the max. number of iterations
that will be performed during the sliding process (usefull, when there is
very slow convergence).  0 means iteration until convergence.</p>
</td></tr>
<tr><td><code id="slider3d_+3A_initproc">initproc</code></td>
<td>
<p>requests initial Procrustes fit before sliding.</p>
</td></tr>
<tr><td><code id="slider3d_+3A_fullgpa">fullGPA</code></td>
<td>
<p>Logical: if FALSE, only a partial procrustes fit will be
performed.</p>
</td></tr>
<tr><td><code id="slider3d_+3A_pairedlm">pairedLM</code></td>
<td>
<p>A X x 2 numeric matrix with the indices of the rows
containing paired Landmarks. E.g. the left column contains the lefthand
landmarks, while the right side contains the corresponding right hand
landmarks. - This will ideally create symmetric mean to get rid of
assymetry.</p>
</td></tr>
<tr><td><code id="slider3d_+3A_bending">bending</code></td>
<td>
<p>if TRUE, bending energy will be minimized, Procrustes distance otherwise.</p>
</td></tr>
<tr><td><code id="slider3d_+3A_stepsize">stepsize</code></td>
<td>
<p>integer: dampening factor for the amount of sliding.
Useful to keep semi-landmarks from sliding too far off the surface.
The displacement is calculated as  <code class="reqn">\Upsilon = \Upsilon^0 + stepsize * UT</code>.
Default is set to 1 for bending=TRUE and 0.5 for bending=FALSE.</p>
</td></tr>
<tr><td><code id="slider3d_+3A_mc.cores">mc.cores</code></td>
<td>
<p>integer: determines how many cores to use for the
computation. The default is autodetect. But in case, it doesn't work as
expected cores can be set manually.</p>
</td></tr>
<tr><td><code id="slider3d_+3A_fixrepro">fixRepro</code></td>
<td>
<p>logical: if <code>TRUE</code>, fix landmarks will also be
projected onto the surface. If you have landmarks not on the surface, select
<code>fixRepro=FALSE</code></p>
</td></tr>
<tr><td><code id="slider3d_+3A_missinglist">missingList</code></td>
<td>
<p>a list of length samplesize containing integer vectors of row indices specifying missing landmars for each specimen. For specimens without missing landmarks enter <code>numeric(0)</code>.</p>
</td></tr>
<tr><td><code id="slider3d_+3A_use.lm">use.lm</code></td>
<td>
<p>indices specifying a subset of (semi-)landmarks to be used in the rotation step - only used if <code>bending=FALSE</code>.</p>
</td></tr>
<tr><td><code id="slider3d_+3A_smoothnormals">smoothnormals</code></td>
<td>
<p>logical: if TRUE, tangent planes will be computed from locally smoothed normals</p>
</td></tr>
<tr><td><code id="slider3d_+3A_silent">silent</code></td>
<td>
<p>logical: if TRUE, console output is suppressed.</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>dataslide</code></td>
<td>
<p>array containing slidden Landmarks in the original
space - not yet processed by a Procrustes analysis</p>
</td></tr>
<tr><td><code>vn.array</code></td>
<td>
<p>array containing landmark normals</p>
</td></tr>
</table>


<h3>Warning</h3>

<p>Depending on the size of the suface meshes and especially
the amount of landmarks this can use an extensive amount of your PC's
resources, especially when running in parallel. As the computation time and
RAM usage of matrix algebra involved is quadratic to the amount of landmarks
used, doubling the amount of semi-landmarks will quadruple computation time
and system resource usage. You can easily stall you computer with this
function with inappropriate data.
</p>


<h3>Note</h3>

<p>if <code>sur.path = NULL</code> and <code>meshlist = NULL</code>, surface landmarks
are relaxed based on a surface normals approximated by the pointcloud, this can lead to bad results for sparse sets of semilandmarks. Obviously, no projection onto the surfaces will be occur and landmarks will likely be off
the original surface.
</p>


<h3>Author(s)</h3>

<p>Stefan Schlager
</p>


<h3>References</h3>

<p>Klingenberg CP, Barluenga M, and Meyer A. 2002. Shape analysis
of symmetric structures: quantifying variation among individuals and
asymmetry. Evolution 56(10):1909-1920.
</p>
<p>Gunz, P., P. Mitteroecker, and F. L. Bookstein. 2005. Semilandmarks in Three
Dimensions, in Modern Morphometrics in Physical Anthropology. Edited by D.
E. Slice, pp. 73-98. New York: Kluwer Academic/Plenum Publishers.
</p>
<p>Schlager S. 2012. Sliding semi-landmarks on symmetric structures in three
dimensions. American Journal of Physical Anthropology, 147(S52):261. URL:
http://dx.doi.org/10.1002/ajpa.21502.
</p>
<p>Schlager S. 2013. Soft-tissue reconstruction of the human nose: population
differences and sexual dimorphism. PhD thesis,
Universitätsbibliothek Freiburg.  URL:
<a href="http://www.freidok.uni-freiburg.de/volltexte/9181/">http://www.freidok.uni-freiburg.de/volltexte/9181/</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+relaxLM">relaxLM</a>, <a href="#topic+createMissingList">createMissingList</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(nose)
###create mesh for longnose
longnose.mesh &lt;- tps3d(shortnose.mesh,shortnose.lm,longnose.lm,threads=1)
### write meshes to disk
mesh2ply(shortnose.mesh, filename="shortnose")
mesh2ply(longnose.mesh, filename="longnose")

## create landmark array
data &lt;- bindArr(shortnose.lm, longnose.lm, along=3)
dimnames(data)[[3]] &lt;- c("shortnose", "longnose")

# define fix landmarks
fix &lt;- c(1:5,20:21)
# define surface patch by specifying row indices of matrices
# all except those defined as fix
surp &lt;- c(1:nrow(shortnose.lm))[-fix]

slide &lt;- slider3d(data, SMvector=fix, deselect=TRUE, surp=surp,
                  sur.path=".",iterations=1,mc.cores=1)
                  # sur.path="." is the current working directory

# now one example with meshes in workspace

meshlist &lt;- list(shortnose.mesh,longnose.mesh)

slide &lt;- slider3d(data, SMvector=fix, deselect=TRUE, surp=surp,
                  iterations=1, meshlist=meshlist,
                  mc.cores=1,fixRepro=FALSE)
require(rgl)
## visualize sliding
deformGrid3d(slide$dataslide[,,1],shortnose.lm,ngrid = 0)
## these are fix
spheres3d(slide$dataslide[fix,,1],col=4,radius=0.7)

###finally an example with missing landmarks:
## we assume that coordinates 185:189, 205:209 and 225:229 are in the second config are missing
missingList &lt;- createMissingList(2)
missingList[[2]] &lt;- c(185:189,205:209,225:229)
slideMissing &lt;- slider3d(data, SMvector=fix, deselect=TRUE, surp=surp,
                  iterations=1, meshlist=meshlist,
                  mc.cores=1,fixRepro=FALSE,missingList=missingList)

## example with two curves
## Example with surface semilandmarks and two curves
fix &lt;- c(1:5,20:21)
outline1 &lt;- c(304:323)
outline2 &lt;- c(604:623)
outlines &lt;- list(outline1,outline2)
surp &lt;- c(1:623)[-c(fix,outline1,outline2)]
slideWithCurves &lt;- slider3d(data, SMvector=fix, deselect=TRUE, surp=surp,
                            meshlist=meshlist,iterations=1,mc.cores=1,outlines=outlines)
deformGrid3d(slideWithCurves$dataslide[,,1],shortnose.lm,ngrid = 0)
plot(slideWithCurves)

## finally an example with sliding without meshes by estimating the surface from the
## semi-landmarks

slideWithCurvesNoMeshes &lt;- slider3d(data, SMvector=fix, deselect=TRUE, surp=surp,
                            iterations=1,mc.cores=1,outlines=outlines)
## compare it to the data with surfaces
deformGrid3d(slideWithCurves$dataslide[,,1],slideWithCurvesNoMeshes$dataslide[,,1],ngrid = 0)
## not too bad, only lonely surface semi-landmarks are a bit off


## End(Not run)

</code></pre>

<hr>
<h2 id='solutionSpace'>returns the solution space (basis and translation vector) for an equation system</h2><span id='topic+solutionSpace'></span>

<h3>Description</h3>

<p>returns the solution space (basis and translation vector) for an equation system
</p>


<h3>Usage</h3>

<pre><code class='language-R'>solutionSpace(A, b)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="solutionSpace_+3A_a">A</code></td>
<td>
<p>numeric matrix</p>
</td></tr>
<tr><td><code id="solutionSpace_+3A_b">b</code></td>
<td>
<p>numeric vector</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For a linear equationsystem, <code class="reqn">Ax = b</code>, the solution space then is
</p>
<p style="text-align: center;"><code class="reqn">x = A^* b + (I - A^* A) y</code>
</p>

<p>where <code class="reqn">A^*</code> is the Moore-Penrose pseudoinverse of <code class="reqn">A</code>.
The QR decomposition of <code class="reqn">I - A^* A</code> determines the dimension of and basis of the solution space.
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>basis</code></td>
<td>
<p>matrix containing the basis of the solution space</p>
</td></tr>
<tr><td><code>translate</code></td>
<td>
<p>translation vector</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>A &lt;- matrix(rnorm(21),3,7)
b &lt;- c(1,2,3)
subspace &lt;- solutionSpace(A,b)
dims &lt;- ncol(subspace$basis) # we now have a 4D solution space
## now pick any vector from this space. E.g
y &lt;- 1:dims
solution &lt;- subspace$basis%*%y+subspace$translate # this is one solution for the equation above
A%*%solution ## pretty close
</code></pre>

<hr>
<h2 id='sortCurve'>sort curvepoints by using the subsequent neighbours</h2><span id='topic+sortCurve'></span>

<h3>Description</h3>

<p>sort curvepoints by using the subsequent neighbours
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sortCurve(x, k = 5, start = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sortCurve_+3A_x">x</code></td>
<td>
<p>k x m matrix containing the 2D or 3D coordinates</p>
</td></tr>
<tr><td><code id="sortCurve_+3A_k">k</code></td>
<td>
<p>number of nearest neighbours to look at. Set high for very irregularly clustered curves.</p>
</td></tr>
<tr><td><code id="sortCurve_+3A_start">start</code></td>
<td>
<p>integer: which row of x to use as a starting point. If NULL, it is assumed that the curve is open and the point where the angle between the two nearest neighbours is closest will be chosen.</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>xsorted</code></td>
<td>
<p>matrix with coordinates sorted along a curve</p>
</td></tr>
<tr><td><code>index</code></td>
<td>
<p>vector containing the sorting indices</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
## generate a curve from a polynome
x &lt;- c(32,64,96,118,126,144,152.5,158)
y &lt;- c(99.5,104.8,108.5,100,86,64,35.3,15)
fit &lt;- lm(y~poly(x,2,raw=TRUE))
xx &lt;- seq(30,160, length=50)
layout(matrix(1:3,3,1))
curve &lt;- cbind(xx,predict(fit, data.frame(x=xx)))
## permute order
set.seed(42)
plot(curve);lines(curve)
curveunsort &lt;- curve[sample(1:50),]
## now the curve is scrambled
plot(curveunsort);lines(curveunsort,col=2)
curvesort &lt;- sortCurve(curveunsort)
## after sorting lines are nice again
plot(curvesort$xsorted);lines(curvesort$xsorted,col=3)
</code></pre>

<hr>
<h2 id='symmetrize'>create a perfectly symmetric version of landmarks</h2><span id='topic+symmetrize'></span>

<h3>Description</h3>

<p>create a perfectly symmetric version of landmarks
</p>


<h3>Usage</h3>

<pre><code class='language-R'>symmetrize(x, pairedLM)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="symmetrize_+3A_x">x</code></td>
<td>
<p>k x m matrix or k x m x n array, with rows containing landmark coordinates</p>
</td></tr>
<tr><td><code id="symmetrize_+3A_pairedlm">pairedLM</code></td>
<td>
<p>A X x 2 matrix containing the indices (rownumbers) of the
paired LM. E.g. the left column contains the lefthand landmarks, while the
right side contains the corresponding right hand landmarks.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>the landmarks are reflected and relabled according to
<code>pairedLM</code> and then rotated and translated onto <code>x</code>.
Both configurations are then averaged to obtain a perfectly symmetric one.
</p>


<h3>Value</h3>

<p>a symmetrized version of <code>x</code>
</p>


<h3>References</h3>

<p>Klingenberg CP, Barluenga M, and Meyer A. 2002. Shape analysis of symmetric
structures: quantifying variation among individuals and asymmetry. Evolution
56(10):1909-1920.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(boneData)
left &lt;- c(4,6,8)
right &lt;- c(3,5,7)
pairedLM &lt;- cbind(left,right)
symx &lt;- symmetrize(boneLM[,,2],pairedLM)
## Not run: 
deformGrid3d(symx,boneLM[,,2])

## End(Not run)
</code></pre>

<hr>
<h2 id='tps3d'>thin plate spline mapping (2D and 3D) for coordinates and triangular meshes</h2><span id='topic+tps3d'></span><span id='topic+tps2d'></span>

<h3>Description</h3>

<p>maps landmarks or a triangular mesh via thin plate spline based on a reference and
a target configuration in 2D and 3D
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tps3d(x, refmat, tarmat, lambda = 1e-08, threads = 0, ...)

tps2d(x, refmat, tarmat, lambda = 1e-08, threads = 0, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tps3d_+3A_x">x</code></td>
<td>
<p>matrix - e.g. the matrix information of vertices of a given
surface or a triangular mesh of class &quot;mesh3d&quot;</p>
</td></tr>
<tr><td><code id="tps3d_+3A_refmat">refmat</code></td>
<td>
<p>reference matrix - e.g. landmark configuration on a surface</p>
</td></tr>
<tr><td><code id="tps3d_+3A_tarmat">tarmat</code></td>
<td>
<p>target matrix - e.g. landmark configuration on a target
surface</p>
</td></tr>
<tr><td><code id="tps3d_+3A_lambda">lambda</code></td>
<td>
<p>numeric: regularisation parameter of the TPS.</p>
</td></tr>
<tr><td><code id="tps3d_+3A_threads">threads</code></td>
<td>
<p>threads to be used for parallel execution in tps deformation.</p>
</td></tr>
<tr><td><code id="tps3d_+3A_...">...</code></td>
<td>
<p>additional arguments, currently not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns the deformed input
</p>


<h3>Note</h3>

<p><code>tps2d</code> is simply an alias for <code>tps3d</code> that can handle both cases.
</p>


<h3>Author(s)</h3>

<p>Stefan Schlager
</p>


<h3>References</h3>

<p>Bookstein FL. 1989. Principal Warps: Thin-plate splines and the
decomposition of deformations. IEEE Transactions on pattern analysis and
machine intelligence 11(6).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+computeTransform">computeTransform</a>, <a href="#topic+applyTransform">applyTransform</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(nose)
## define some landmarks
refind &lt;- c(1:3,4,19:20)
## use a subset of shortnose.lm as anchor points for a TPS-deformation
reflm &lt;- shortnose.lm[refind,]
tarlm &lt;- reflm
##replace the landmark at the tip of the nose with that of longnose.lm
tarlm[4,] &lt;- longnose.lm[4,]
##  deform a set of semilandmarks by applying a TPS-deformation
##  based on 5 reference points
deformed &lt;- tps3d(shortnose.lm, reflm, tarlm,threads=1)
## Not run: 
##visualize results by applying a deformation grid
deformGrid3d(shortnose.lm,deformed,ngrid = 5)


data(nose)##load data
##warp a mesh onto another landmark configuration:
longnose.mesh &lt;- tps3d(shortnose.mesh,shortnose.lm,longnose.lm,threads=1)


require(rgl)
shade3d(longnose.mesh,col=skin1)

## End(Not run)

data(boneData)
## deform mesh belonging to the first specimen
## onto the landmark configuration of the 10th specimen

## Not run: 
warpskull &lt;- tps3d(skull_0144_ch_fe.mesh,boneLM[,,1],
                     boneLM[,,10], threads=1)
## render deformed mesh and landmarks
shade3d(warpskull, col=2, specular=1)
spheres3d(boneLM[,,1])
## render original mesh
shade3d(skull_0144_ch_fe.mesh, col=3, specular=1)
spheres3d(boneLM[,,10])


## End(Not run)
</code></pre>

<hr>
<h2 id='typprob'>calculate typicality probabilities</h2><span id='topic+typprob'></span><span id='topic+typprobClass'></span>

<h3>Description</h3>

<p>calculate typicality probabilities
</p>


<h3>Usage</h3>

<pre><code class='language-R'>typprob(
  x,
  data,
  small = FALSE,
  method = c("chisquare", "wilson"),
  center = NULL,
  cova = NULL,
  robust = c("classical", "mve", "mcd"),
  ...
)

typprobClass(
  x,
  data,
  groups,
  small = FALSE,
  method = c("chisquare", "wilson"),
  outlier = 0.01,
  sep = FALSE,
  cv = TRUE,
  robust = c("classical", "mve", "mcd"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="typprob_+3A_x">x</code></td>
<td>
<p>vector or matrix of data the probability is to be calculated.</p>
</td></tr>
<tr><td><code id="typprob_+3A_data">data</code></td>
<td>
<p>Reference data set. If missing x will be used.</p>
</td></tr>
<tr><td><code id="typprob_+3A_small">small</code></td>
<td>
<p>adjustion of Mahalanobis D^2 for small sample sizes as
suggested by Wilson (1981), only takes effect when method=&quot;wilson&quot;.</p>
</td></tr>
<tr><td><code id="typprob_+3A_method">method</code></td>
<td>
<p>select method for probability estimation. Available options
are &quot;chisquare&quot; (or any abbreviation) or &quot;wilson&quot;. &quot;chisquare&quot; exploits
simply the chisquare distribution of the mahalanobisdistance, while &quot;wilson&quot;
uses the methods suggested by Wilson(1981). Results will be similar in
general.</p>
</td></tr>
<tr><td><code id="typprob_+3A_center">center</code></td>
<td>
<p>vector: specify custom vector to calculate distance to. If not
defined, group mean will be used.</p>
</td></tr>
<tr><td><code id="typprob_+3A_cova">cova</code></td>
<td>
<p>covariance matrix to calculate mahalanobis-distance: specify
custom covariance matrix to calculate distance.</p>
</td></tr>
<tr><td><code id="typprob_+3A_robust">robust</code></td>
<td>
<p>character: determines covariance estimation methods, allowing for robust estimations using <code>MASS::cov.rob</code>. Default is the standard product-moment covariance matrix.</p>
</td></tr>
<tr><td><code id="typprob_+3A_...">...</code></td>
<td>
<p>additional parameters passed to <code>MASS::cov.rob</code> for robust covariance and mean estimations.</p>
</td></tr>
<tr><td><code id="typprob_+3A_groups">groups</code></td>
<td>
<p>vector containing grouping information.</p>
</td></tr>
<tr><td><code id="typprob_+3A_outlier">outlier</code></td>
<td>
<p>probability threshold below which a specimen will not be
assigned to any group-</p>
</td></tr>
<tr><td><code id="typprob_+3A_sep">sep</code></td>
<td>
<p>logical: if TRUE, probability will be calculated from the pooled
within group covariance matrix.</p>
</td></tr>
<tr><td><code id="typprob_+3A_cv">cv</code></td>
<td>
<p>logical: if data is missing and <code>cv=TRUE</code>, the resulting classification will be validated by leaving-one-out crossvalidation.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>get the probability for an observation belonging to a given multivariate
nromal distribution
</p>


<h3>Value</h3>

<p>typprob: returns a vector of probabilities.
</p>
<p>typprobClass:
</p>
<table role = "presentation">
<tr><td><code>probs</code></td>
<td>
<p>matrix of probabilities for each group</p>
</td></tr>
<tr><td><code>groupaffin</code></td>
<td>
<p>vector of groups each specimen has been assigned to. Outliers are classified &quot;none&quot;</p>
</td></tr>
<tr><td><code>probsCV</code></td>
<td>
<p>cross-validated matrix of probabilities for each group</p>
</td></tr>
<tr><td><code>groupaffinCV</code></td>
<td>
<p>cross-validated vector of groups each specimen has been assigned to. Outliers are classified &quot;none&quot;</p>
</td></tr>
<tr><td><code>self</code></td>
<td>
<p>logical: if TRUE, the data has been classified by self-inference.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Stefan Schlager
</p>


<h3>References</h3>

<p>Albrecht G. 1992. Assessing the affinities of fossils using
canonical variates and generalized distances Human Evolution 7:49-69.
</p>
<p>Wilson S. 1981. On comparing fossil specimens with population samples
Journal of Human Evolution 10:207 - 214.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (require(shapes)) {
data &lt;- procSym(gorf.dat)$PCscores[,1:3]
probas &lt;- typprob(data,data,small=TRUE)### get probability for each specimen

### now we check how this behaves compared to the mahalanobis distance
maha &lt;- mahalanobis(data,colMeans(data),cov(data))
plot(probas,maha,xlab="Probability",ylab="Mahalanobis D^2")

data2 &lt;- procSym(abind(gorf.dat,gorm.dat))$PCscores[,1:3]
fac &lt;- as.factor(c(rep("female",dim(gorf.dat)[3]),rep("male",dim(gorm.dat)[3])))
typClass &lt;- typprobClass(data2,groups=fac,method="w",small=TRUE,cv=TRUE)
## only 59 specimen is rather small.
typClass2 &lt;- typprobClass(data2,groups=fac,method="c",cv=TRUE)## use default settings

### check results for first method:
typClass


### check results for second method:
typClass2
}

</code></pre>

<hr>
<h2 id='unrefVertex'>some little helpers for vertex operations on triangular meshes</h2><span id='topic+unrefVertex'></span><span id='topic+rmVertex'></span><span id='topic+vert2points'></span><span id='topic+rmUnrefVertex'></span>

<h3>Description</h3>

<p>some little helpers for vertex operations on triangular meshes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unrefVertex(mesh)

rmVertex(mesh, index, keep = FALSE)

vert2points(mesh)

rmUnrefVertex(mesh, silent = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="unrefVertex_+3A_mesh">mesh</code></td>
<td>
<p>triangular mesh of class <code>mesh3d</code>.</p>
</td></tr>
<tr><td><code id="unrefVertex_+3A_index">index</code></td>
<td>
<p>vector containing indices of vertices to be removed.</p>
</td></tr>
<tr><td><code id="unrefVertex_+3A_keep">keep</code></td>
<td>
<p>logical: if <code>TRUE</code>, the vertices specified by <code>index</code>
are kept and the rest is removed.</p>
</td></tr>
<tr><td><code id="unrefVertex_+3A_silent">silent</code></td>
<td>
<p>logical: suppress output about info on removed vertices.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>extract vertex coordinates from meshes, find and/or remove (unreferenced)
vertices from triangular meshes
</p>
<p><code>unrefVertex</code> finds unreferenced vertices in triangular meshes of class
<code>mesh3d</code> or <code>tmesh3d</code>.
</p>
<p><code>rmVertex</code> removes specified vertices from triangular meshes.
</p>
<p><code>vert2points</code> extacts vertex coordinates from triangular meshes.
</p>
<p><code>rmUnrefVertex</code> removes unreferenced vertices from triangular meshes.
</p>


<h3>Value</h3>

<p><code>unrefVertex</code>: vector with indices of unreferenced vertices.
</p>
<p><code>rmVertex</code>: returns mesh with specified vertices removed and faces and
normals updated.
</p>
<p><code>vert2points</code>: k x 3 matrix containing vertex coordinates.
</p>
<p><code>rmUnrefVertex</code>: mesh with unreferenced vertices removed.
</p>


<h3>Author(s)</h3>

<p>Stefan Schlager
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ply2mesh">ply2mesh</a></code>, <code><a href="#topic+file2mesh">file2mesh</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
require(rgl)
data(nose)
testmesh &lt;- rmVertex(shortnose.mesh,1:50) ## remove first 50 vertices
## Not run: 
shade3d(testmesh,col=3)### view result

## End(Not run)
testmesh$vb &lt;- cbind(testmesh$vb,shortnose.mesh$vb[,1:50]) ## add some unreferenced vertices
## Not run: 
points3d(vert2points(testmesh),col=2)## see the vertices in the holes?

## End(Not run)
cleanmesh &lt;- rmUnrefVertex(testmesh)## remove those lonely vertices!
## Not run: 
pop3d()
points3d(vert2points(cleanmesh),col=2) ### now the holes are empty!!

## End(Not run)

</code></pre>

<hr>
<h2 id='updateIndices'>update a vector of indices after removal of some referenced items</h2><span id='topic+updateIndices'></span>

<h3>Description</h3>

<p>update a vector of indices after removal of some referenced items
</p>


<h3>Usage</h3>

<pre><code class='language-R'>updateIndices(x, ignore, indexrange)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="updateIndices_+3A_x">x</code></td>
<td>
<p>vector containing indices (e.g. to matrix rows)</p>
</td></tr>
<tr><td><code id="updateIndices_+3A_ignore">ignore</code></td>
<td>
<p>integer vector: remove those items from the original structure</p>
</td></tr>
<tr><td><code id="updateIndices_+3A_indexrange">indexrange</code></td>
<td>
<p>maximum range of the index in the referenced item structure</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>refItem &lt;- matrix(1:10,5,2)
index &lt;- c(1,3,5) # this indexes some rows of the matrix we are interested in
## now we want to ignore row 2 and 5 and want to update the index so it will still fit
indexNew &lt;- updateIndices(index,c(2,5),indexrange=5)

## Here a more useful example:
data(boneData)
left &lt;- c(4,6,8)
  ## determine corresponding Landmarks on the right side:
    # important: keep same order
    right &lt;- c(3,5,7)
    pairedLM &lt;- cbind(left,right)
## now we want to remove some landmarks and need to updated the pairedLM indices
ignore &lt;- c(5,6)
mynewboneLM &lt;- boneLM[-ignore,,]
pairedLMnew &lt;- apply(pairedLM,2,updateIndices,ignore=ignore,indexrange=dim(boneLM)[1])
</code></pre>

<hr>
<h2 id='updateNormals'>Compute face or vertex normals of a triangular mesh</h2><span id='topic+updateNormals'></span><span id='topic+facenormals'></span>

<h3>Description</h3>

<p>Compute face or vertex normals of a triangular mesh of class &quot;mesh3d&quot;
</p>


<h3>Usage</h3>

<pre><code class='language-R'>updateNormals(x, angle = TRUE)

facenormals(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="updateNormals_+3A_x">x</code></td>
<td>
<p>triangular mesh of class &quot;mesh3d&quot;</p>
</td></tr>
<tr><td><code id="updateNormals_+3A_angle">angle</code></td>
<td>
<p>logical: if TRUE, angle weighted normals are used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>updateNormals</code> returns mesh with updated vertex normals.
</p>
<p><code>facenormals</code> returns an object of class &quot;mesh3d&quot; with
</p>
<table role = "presentation">
<tr><td><code>vb</code></td>
<td>
<p>faces' barycenters</p>
</td></tr>
<tr><td><code>normals</code></td>
<td>
<p>faces' normals</p>
</td></tr>
</table>


<h3>Note</h3>

<p>only supports triangular meshes
</p>


<h3>Author(s)</h3>

<p>Stefan Schlager
</p>


<h3>References</h3>

<p>Baerentzen, Jakob Andreas. &amp; Aanaes, H., 2002. Generating Signed
Distance Fields From Triangle Meshes. Informatics and Mathematical
Modelling, .
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ply2mesh">ply2mesh</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
require(rgl)
require(Morpho)
data(nose)
### calculate vertex normals
shortnose.mesh$normals &lt;- NULL ##remove normals
## Not run: 
shade3d(shortnose.mesh,col=3)##render

## End(Not run)
shortnose.mesh &lt;- updateNormals(shortnose.mesh)
## Not run: 
clear3d()
shade3d(shortnose.mesh,col=3)##smoothly rendered now

## End(Not run)
## calculate facenormals
facemesh &lt;- facenormals(shortnose.mesh)
## Not run: 
plotNormals(facemesh,long=0.01)
points3d(vert2points(facemesh),col=2)
wire3d(shortnose.mesh)

## End(Not run)
</code></pre>

<hr>
<h2 id='vecx'>convert an 3D array into a matrix and back</h2><span id='topic+vecx'></span>

<h3>Description</h3>

<p>converts a 3D-array (e.g. containing landmark coordinates) into a matrix,
one row per specimen or reverse this.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vecx(x, byrow = FALSE, revert = FALSE, lmdim)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vecx_+3A_x">x</code></td>
<td>
<p>array or matrix</p>
</td></tr>
<tr><td><code id="vecx_+3A_byrow">byrow</code></td>
<td>
<p>logical: if TRUE, the resulting vector for each specimen will
be <code>x1,y1,z1,x2,y2,z2,...,</code> and <code>x1,x2,...,y1,y2,...,z1,z2,...</code> otherwise
(default). The same is for reverting the process: if the matrix contains the coordinates as  rows like: <code>x1,y1,z1,x2,y2,z2,...</code> set <code>byrow=TRUE</code></p>
</td></tr>
<tr><td><code id="vecx_+3A_revert">revert</code></td>
<td>
<p>revert the process and convert a matrix with vectorized landmarks back into an array.</p>
</td></tr>
<tr><td><code id="vecx_+3A_lmdim">lmdim</code></td>
<td>
<p>number of columns for reverting</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns a matrix with one row per specimen
</p>


<h3>Author(s)</h3>

<p>Stefan Schlager
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (require(shapes)) {
data &lt;- vecx(gorf.dat) 
#revert the procedure
gdat.restored &lt;- vecx(data,revert=TRUE,lmdim=2)
range(gdat.restored-gorf.dat)
}
</code></pre>

<hr>
<h2 id='virtualMeshScan'>remove all parts of a triangular mesh, not visible from a set of viewpoints</h2><span id='topic+virtualMeshScan'></span>

<h3>Description</h3>

<p>remove all parts of a triangular mesh, not visible from a set of viewpoints
</p>


<h3>Usage</h3>

<pre><code class='language-R'>virtualMeshScan(x, viewpoints, offset = 0.001, cores = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="virtualMeshScan_+3A_x">x</code></td>
<td>
<p>triangular mesh of class 'mesh3d'</p>
</td></tr>
<tr><td><code id="virtualMeshScan_+3A_viewpoints">viewpoints</code></td>
<td>
<p>vector or k x 3  matrix containing a set of viewpoints</p>
</td></tr>
<tr><td><code id="virtualMeshScan_+3A_offset">offset</code></td>
<td>
<p>value to generate an offset at the meshes surface (see notes)</p>
</td></tr>
<tr><td><code id="virtualMeshScan_+3A_cores">cores</code></td>
<td>
<p>integer: number of cores to use (not working on windows)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns a list containing subsets of the original mesh
</p>
<table role = "presentation">
<tr><td><code>visible</code></td>
<td>
<p>the parts visible from at least one of the viewpoints</p>
</td></tr>
<tr><td><code>invisible</code></td>
<td>
<p>the parts not visible from the viewpoints</p>
</td></tr>
</table>


<h3>Note</h3>

<p>The function tries to filter out all vertices where the line connecting each vertex with the viewpoints intersects with the mesh itself. As, technically speaking this always occurs at a distance of value=0, a mesh with a tiny offset is generated to avoid these false hits.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>SCP1 &lt;- file2mesh(system.file("extdata","SCP1.ply",package="Morpho"))
viewpoints &lt;- read.fcsv(system.file("extdata","SCP1_Endo.fcsv",package="Morpho"))
## Create a quick endocast
quickEndo &lt;- virtualMeshScan(SCP1,viewpoints)
## Not run: 
rgl::shade3d(quickEndo$visible,col="orange")
rgl::shade3d(SCP1,col="white",alpha=0.5)

## End(Not run)
</code></pre>

<hr>
<h2 id='warpmovie3d'>Creates a sequence of images showing predefined steps of warping two meshes or landmark configurations (2D and 3D) into each other</h2><span id='topic+warpmovie3d'></span><span id='topic+warpmovie3d.matrix'></span><span id='topic+warpmovie2d'></span><span id='topic+warpmovie3d.mesh3d'></span>

<h3>Description</h3>

<p>Creates a sequence of images showing predefined steps of warping two meshes
or landmark configurations (2D and 3D) into each other
</p>


<h3>Usage</h3>

<pre><code class='language-R'>warpmovie3d(
  x,
  y,
  n,
  col = "green",
  palindrome = FALSE,
  folder = NULL,
  movie = "warpmovie",
  ...
)

## S3 method for class 'matrix'
warpmovie3d(
  x,
  y,
  n,
  col = "green",
  palindrome = FALSE,
  folder = NULL,
  movie = "warpmovie",
  add = FALSE,
  close = TRUE,
  countbegin = 0,
  ask = TRUE,
  radius = NULL,
  links = NULL,
  lwd = 1,
  ...
)

warpmovie2d(
  x,
  y,
  n,
  col = "green",
  palindrome = FALSE,
  folder = NULL,
  movie = "warpmovie",
  links = NULL,
  lwd = 1,
  imagedim = "800x800",
  par = list(xaxt = "n", yaxt = "n", bty = "n"),
  ...
)

## S3 method for class 'mesh3d'
warpmovie3d(
  x,
  y,
  n,
  col = NULL,
  palindrome = FALSE,
  folder = NULL,
  movie = "warpmovie",
  add = FALSE,
  close = TRUE,
  countbegin = 0,
  ask = TRUE,
  radius = NULL,
  xland = NULL,
  yland = NULL,
  lmcol = "black",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="warpmovie3d_+3A_x">x</code></td>
<td>
<p>mesh to start with (object of class mesh3d)</p>
</td></tr>
<tr><td><code id="warpmovie3d_+3A_y">y</code></td>
<td>
<p>resulting mesh (object of class mesh3d), having the same amount of
vertices and faces than the starting mesh</p>
</td></tr>
<tr><td><code id="warpmovie3d_+3A_n">n</code></td>
<td>
<p>integer: amount of intermediate steps.</p>
</td></tr>
<tr><td><code id="warpmovie3d_+3A_col">col</code></td>
<td>
<p>color of the mesh</p>
</td></tr>
<tr><td><code id="warpmovie3d_+3A_palindrome">palindrome</code></td>
<td>
<p>logical: if TRUE, the procedure will go forth and back.</p>
</td></tr>
<tr><td><code id="warpmovie3d_+3A_folder">folder</code></td>
<td>
<p>character: output folder for created images (optional)</p>
</td></tr>
<tr><td><code id="warpmovie3d_+3A_movie">movie</code></td>
<td>
<p>character: name of the output files</p>
</td></tr>
<tr><td><code id="warpmovie3d_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code><a href="rgl.html#topic+shade3d">shade3d</a></code> (3D) or
<code><a href="graphics.html#topic+points">points</a></code> (2D).</p>
</td></tr>
<tr><td><code id="warpmovie3d_+3A_add">add</code></td>
<td>
<p>logical: if TRUE, the movie will be added to the focussed
rgl-windows.</p>
</td></tr>
<tr><td><code id="warpmovie3d_+3A_close">close</code></td>
<td>
<p>logical: if TRUE, the rgl window will be closed when finished.
width and 200 the height of the image.</p>
</td></tr>
<tr><td><code id="warpmovie3d_+3A_countbegin">countbegin</code></td>
<td>
<p>integer: number to start image sequence.</p>
</td></tr>
<tr><td><code id="warpmovie3d_+3A_ask">ask</code></td>
<td>
<p>logical: if TRUE, the viewpoint can be selected manually.</p>
</td></tr>
<tr><td><code id="warpmovie3d_+3A_radius">radius</code></td>
<td>
<p>numeric: define size of spheres (overides atuomatic size
estimation).</p>
</td></tr>
<tr><td><code id="warpmovie3d_+3A_links">links</code></td>
<td>
<p>vector or list of vectors containing wireframe information to
connect landmarks (optional).</p>
</td></tr>
<tr><td><code id="warpmovie3d_+3A_lwd">lwd</code></td>
<td>
<p>numeric: controls width of lines defined by &quot;links&quot;.</p>
</td></tr>
<tr><td><code id="warpmovie3d_+3A_imagedim">imagedim</code></td>
<td>
<p>character of pattern &quot;100x200&quot; where 100 determines the
width and 200 the height of the image.</p>
</td></tr>
<tr><td><code id="warpmovie3d_+3A_par">par</code></td>
<td>
<p>list of graphial parameters: details can be found here:
<code><a href="graphics.html#topic+par">par</a></code>.</p>
</td></tr>
<tr><td><code id="warpmovie3d_+3A_xland">xland</code></td>
<td>
<p>optional argument: add landmarks on mesh x</p>
</td></tr>
<tr><td><code id="warpmovie3d_+3A_yland">yland</code></td>
<td>
<p>optional argument: add landmarks on mesh y</p>
</td></tr>
<tr><td><code id="warpmovie3d_+3A_lmcol">lmcol</code></td>
<td>
<p>optional argument: color of landmarks xland and yland</p>
</td></tr>
</table>


<h3>Details</h3>

<p>given two landmark configurations or two meshes with the same amount of
vertices and faces (e.g a mesh and its warped counterpart), the starting
configuration/mesh will be subsequently transformed into the final
configuration/mesh by splitting the differences into a predefined set of
steps.
</p>
<p>A series of png files will be saved to disk. These can be joined to animated
gifs by external programs such as imagemagick or used to create animations
in PDFs in a latex environment (e.g. latex package: aninmate).
</p>


<h3>Author(s)</h3>

<p>Stefan Schlager
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ply2mesh">ply2mesh</a>,<a href="#topic+file2mesh">file2mesh</a>,<a href="#topic+mesh2ply">mesh2ply</a>,<a href="#topic+tps3d">tps3d</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

###3D example
 data(nose)##load data
if (interactive()){
##warp a mesh onto another landmark configuration:
longnose.mesh &lt;- tps3d(shortnose.mesh,shortnose.lm,longnose.lm,threads=1)

warpmovie3d(shortnose.mesh,longnose.mesh,n=15)## create 15 images.

### ad some landmarks
warpmovie3d(shortnose.mesh,longnose.mesh,n=15,xland=shortnose.lm,
            yland=longnose.lm)## create 15 images.


### restrict to landmarks
warpmovie3d(shortnose.lm,longnose.lm,n=15,movie="matrixmovie")## create 15 images.

### the images are now stored in your current working directory and can
### be concatenated to a gif using an external program such as
### imagemagick.
}
### 2D example
if (require(shapes)) {
bb &lt;- procSym(gorf.dat)
### morph superimposed first specimen onto sample mean
warpmovie2d(bb$rotated[,,1],bb$mshape,n=20,links=c(1,5,4:2,8:6,1),imagedim="600x400")
## remove files
unlink("warpmovie00*")
}
</code></pre>

<hr>
<h2 id='write.fcsv'>write fiducials in slicer4 format</h2><span id='topic+write.fcsv'></span>

<h3>Description</h3>

<p>write fiducials in slicer4 format
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write.fcsv(x, filename = dataname, description = NULL, slicer4.11 = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="write.fcsv_+3A_x">x</code></td>
<td>
<p>matrix with row containing 2D or 3D coordinates</p>
</td></tr>
<tr><td><code id="write.fcsv_+3A_filename">filename</code></td>
<td>
<p>will be substituted with &quot;.fcsv&quot;</p>
</td></tr>
<tr><td><code id="write.fcsv_+3A_description">description</code></td>
<td>
<p>optional: character vector containing a description for each landmark</p>
</td></tr>
<tr><td><code id="write.fcsv_+3A_slicer4.11">slicer4.11</code></td>
<td>
<p>logical: Slicer changed their fiducial format in version &gt;= 4.11. Set TRUE if you use the latest Slicer version</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>require(Rvcg)
data(dummyhead)
write.fcsv(dummyhead.lm)
## remove file
unlink("dummyhead.lm.fcsv")
</code></pre>

<hr>
<h2 id='write.pts'>exports a matrix containing landmarks into .pts format</h2><span id='topic+write.pts'></span>

<h3>Description</h3>

<p>exports a matrix containing landmarks into .pts format that can be read by
IDAV Landmark.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write.pts(x, filename = dataname, rownames = NULL, NA.string = 9999)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="write.pts_+3A_x">x</code></td>
<td>
<p>k x m matrix containing landmark configuration</p>
</td></tr>
<tr><td><code id="write.pts_+3A_filename">filename</code></td>
<td>
<p>character: Path/name of the requested output - extension
will be added atuomatically. If not specified, the file will be named as the
exported object.</p>
</td></tr>
<tr><td><code id="write.pts_+3A_rownames">rownames</code></td>
<td>
<p>provide an optional character vector with rownames</p>
</td></tr>
<tr><td><code id="write.pts_+3A_na.string">NA.string</code></td>
<td>
<p>specify the string to use for encoding missing values</p>
</td></tr>
</table>


<h3>Details</h3>

<p>you can import the information into the program landmarks available at
http://graphics.idav.ucdavis.edu/research/EvoMorph
</p>


<h3>Author(s)</h3>

<p>Stefan Schlager
</p>


<h3>See Also</h3>

<p><code><a href="#topic+read.pts">read.pts</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(nose)
write.pts(shortnose.lm, filename="shortnose")
unlink("shortnose.pts")

</code></pre>

<hr>
<h2 id='write.slicerjson'>Export landmarks (or any 3D coordinates) to the new slicer json format</h2><span id='topic+write.slicerjson'></span>

<h3>Description</h3>

<p>Export landmarks (or any 3D coordinates) to the new slicer json format
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write.slicerjson(
  x,
  filename = dataname,
  type = c("Fiducial", "Curve", "ClosedCurve"),
  coordinateSystem = c("LPS", "RAS"),
  labels = dataname
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="write.slicerjson_+3A_x">x</code></td>
<td>
<p>k x 3 matrix containing 3D coordinates</p>
</td></tr>
<tr><td><code id="write.slicerjson_+3A_filename">filename</code></td>
<td>
<p>will be substituted with &quot;.mrk.json&quot;</p>
</td></tr>
<tr><td><code id="write.slicerjson_+3A_type">type</code></td>
<td>
<p>character: specify type of coordinates. Can be any of &quot;Fiducial&quot;, &quot;Curve&quot;, &quot;ClosedCurve&quot;.</p>
</td></tr>
<tr><td><code id="write.slicerjson_+3A_coordinatesystem">coordinateSystem</code></td>
<td>
<p>character: specify coordinate system the data are in. Can be &quot;LPS&quot; or &quot;RAS&quot;.</p>
</td></tr>
<tr><td><code id="write.slicerjson_+3A_labels">labels</code></td>
<td>
<p>character or character vector containing landmark labels.</p>
</td></tr>
</table>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
