<!DOCTYPE html><html><head><title>Help for package tidytable</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {tidytable}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#%&gt;%'><p>Pipe operator</p></a></li>
<li><a href='#%in%'><p>Fast <code>%in%</code> and <code style="white-space: pre;">&#8288;%notin%&#8288;</code> operators</p></a></li>
<li><a href='#across'><p>Apply a function across a selection of columns</p></a></li>
<li><a href='#add_count'><p>Add a count column to the data frame</p></a></li>
<li><a href='#arrange'><p>Arrange/reorder rows</p></a></li>
<li><a href='#as_tidytable'><p>Coerce an object to a data.table/tidytable</p></a></li>
<li><a href='#between'><p>Do the values from x fall between the left and right bounds?</p></a></li>
<li><a href='#bind_cols'><p>Bind data.tables by row and column</p></a></li>
<li><a href='#c_across'><p>Combine values from multiple columns</p></a></li>
<li><a href='#case'><p><code>data.table::fcase()</code> with vectorized default</p></a></li>
<li><a href='#case_match'><p>Vectorized <code>switch()</code></p></a></li>
<li><a href='#case_when'><p>Case when</p></a></li>
<li><a href='#coalesce'><p>Coalesce missing values</p></a></li>
<li><a href='#complete'><p>Complete a data.table with missing combinations of data</p></a></li>
<li><a href='#consecutive_id'><p>Generate a unique id for consecutive values</p></a></li>
<li><a href='#context'><p>Context functions</p></a></li>
<li><a href='#count'><p>Count observations by group</p></a></li>
<li><a href='#cross_join'><p>Cross join</p></a></li>
<li><a href='#crossing'><p>Create a data.table from all unique combinations of inputs</p></a></li>
<li><a href='#desc'><p>Descending order</p></a></li>
<li><a href='#distinct'><p>Select distinct/unique rows</p></a></li>
<li><a href='#drop_na'><p>Drop rows containing missing values</p></a></li>
<li><a href='#dt'><p>Pipeable data.table call</p></a></li>
<li><a href='#enframe'><p>Convert a vector to a data.table/tidytable</p></a></li>
<li><a href='#expand'><p>Expand a data.table to use all combinations of values</p></a></li>
<li><a href='#expand_grid'><p>Create a data.table from all combinations of inputs</p></a></li>
<li><a href='#extract'><p>Extract a character column into multiple columns using regex</p></a></li>
<li><a href='#fill'><p>Fill in missing values with previous or next value</p></a></li>
<li><a href='#filter'><p>Filter rows on one or more conditions</p></a></li>
<li><a href='#first'><p>Extract the first, last, or nth value from a vector</p></a></li>
<li><a href='#fread'><p>Read/write files</p></a></li>
<li><a href='#get_dummies'><p>Convert character and factor columns to dummy variables</p></a></li>
<li><a href='#group_by'><p>Grouping</p></a></li>
<li><a href='#group_cols'><p>Selection helper for grouping columns</p></a></li>
<li><a href='#group_split'><p>Split data frame by groups</p></a></li>
<li><a href='#group_vars'><p>Get the grouping variables</p></a></li>
<li><a href='#if_all'><p>Create conditions on a selection of columns</p></a></li>
<li><a href='#if_else'><p>Fast if_else</p></a></li>
<li><a href='#inv_gc'><p>Run invisible garbage collection</p></a></li>
<li><a href='#is_grouped_df'><p>Check if the tidytable is grouped</p></a></li>
<li><a href='#is_tidytable'><p>Test if the object is a tidytable</p></a></li>
<li><a href='#lag'><p>Get lagging or leading values</p></a></li>
<li><a href='#left_join'><p>Join two data.tables together</p></a></li>
<li><a href='#map'><p>Apply a function to each element of a vector or list</p></a></li>
<li><a href='#mutate'><p>Add/modify/delete columns</p></a></li>
<li><a href='#mutate_rowwise'><p>Add/modify columns by row</p></a></li>
<li><a href='#n'><p>Number of observations in each group</p></a></li>
<li><a href='#n_distinct'><p>Count the number of unique values in a vector</p></a></li>
<li><a href='#na_if'><p>Convert values to <code>NA</code></p></a></li>
<li><a href='#nest'><p>Nest columns into a list-column</p></a></li>
<li><a href='#nest_by'><p>Nest data.tables</p></a></li>
<li><a href='#nest_join'><p>Nest join</p></a></li>
<li><a href='#new_tidytable'><p>Create a tidytable from a list</p></a></li>
<li><a href='#pick'><p>Selection version of <code>across()</code></p></a></li>
<li><a href='#pivot_longer'><p>Pivot data from wide to long</p></a></li>
<li><a href='#pivot_wider'><p>Pivot data from long to wide</p></a></li>
<li><a href='#pull'><p>Pull out a single variable</p></a></li>
<li><a href='#recode'><p>Recode values</p></a></li>
<li><a href='#reexports'><p>Objects exported from other packages</p></a></li>
<li><a href='#reframe'><p>Reframe a data frame</p></a></li>
<li><a href='#relocate'><p>Relocate a column to a new position</p></a></li>
<li><a href='#rename'><p>Rename variables by name</p></a></li>
<li><a href='#rename_with'><p>Rename multiple columns</p></a></li>
<li><a href='#replace_na'><p>Replace missing values</p></a></li>
<li><a href='#row_number'><p>Ranking functions</p></a></li>
<li><a href='#rowwise'><p>Convert to a rowwise tidytable</p></a></li>
<li><a href='#select'><p>Select or drop columns</p></a></li>
<li><a href='#separate'><p>Separate a character column into multiple columns</p></a></li>
<li><a href='#separate_longer_delim'><p>Split a string into rows</p></a></li>
<li><a href='#separate_rows'><p>Separate a collapsed column into multiple rows</p></a></li>
<li><a href='#separate_wider_delim'><p>Separate a character column into multiple columns</p></a></li>
<li><a href='#separate_wider_regex'><p>Separate a character column into multiple columns using regex patterns</p></a></li>
<li><a href='#slice_head'><p>Choose rows in a data.table</p></a></li>
<li><a href='#summarize'><p>Aggregate data using summary statistics</p></a></li>
<li><a href='#tidytable'><p>Build a data.table/tidytable</p></a></li>
<li><a href='#tidytable-vctrs'><p>Internal vctrs methods</p></a></li>
<li><a href='#top_n'><p>Select top (or bottom) n rows (by value)</p></a></li>
<li><a href='#transmute'><p>Add new variables and drop all others</p></a></li>
<li><a href='#tribble'><p>Rowwise tidytable creation</p></a></li>
<li><a href='#uncount'><p>Uncount a data.table</p></a></li>
<li><a href='#unite'><p>Unite multiple columns by pasting strings together</p></a></li>
<li><a href='#unnest'><p>Unnest list-columns</p></a></li>
<li><a href='#unnest_longer'><p>Unnest a list-column of vectors into regular columns</p></a></li>
<li><a href='#unnest_wider'><p>Unnest a list-column of vectors into a wide data frame</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Tidy Interface to 'data.table'</td>
</tr>
<tr>
<td>Version:</td>
<td>0.11.0</td>
</tr>
<tr>
<td>Description:</td>
<td>A tidy interface to 'data.table',
  giving users the speed of 'data.table' while using tidyverse-like syntax.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Imports:</td>
<td>data.table (&ge; 1.14.0), glue (&ge; 1.4.0), lifecycle (&ge; 1.0.3),
magrittr (&ge; 2.0.3), pillar (&ge; 1.8.0), rlang (&ge; 1.1.0),
tidyselect (&ge; 1.2.0), vctrs (&ge; 0.6.0)</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://markfairbanks.github.io/tidytable/">https://markfairbanks.github.io/tidytable/</a>,
<a href="https://github.com/markfairbanks/tidytable">https://github.com/markfairbanks/tidytable</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/markfairbanks/tidytable/issues">https://github.com/markfairbanks/tidytable/issues</a></td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat (&ge; 2.1.0), bit64, knitr, rmarkdown, crayon</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-02-07 15:05:23 UTC; xmxf129</td>
</tr>
<tr>
<td>Author:</td>
<td>Mark Fairbanks [aut, cre],
  Abdessabour Moutik [ctb],
  Matt Carlson [ctb],
  Ivan Leung [ctb],
  Ross Kennedy [ctb],
  Robert On [ctb],
  Alexander Sevostianov [ctb],
  Koen ter Berg [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Mark Fairbanks &lt;mark.t.fairbanks@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-02-09 08:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='+25+26gt+3B+25'>Pipe operator</h2><span id='topic++25+3E+25'></span>

<h3>Description</h3>

<p>See <code>magrittr::<a href="magrittr.html#topic+pipe">%&gt;%</a></code> for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lhs %&gt;% rhs
</code></pre>

<hr>
<h2 id='+25in+25'>Fast <code>%in%</code> and <code style="white-space: pre;">&#8288;%notin%&#8288;</code> operators</h2><span id='topic++25in+25'></span><span id='topic++25notin+25'></span>

<h3>Description</h3>

<p>Check whether values in a vector are in or not in another vector.
</p>
<p>Built using <code>data.table::'%chin%'</code> and <code>vctrs::vec_in()</code> for performance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>x %in% y

x %notin% y
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B25in+2B25_+3A_x">x</code></td>
<td>
<p>A vector of values to check if they exist in y</p>
</td></tr>
<tr><td><code id="+2B25in+2B25_+3A_y">y</code></td>
<td>
<p>A vector of values to check if x values exist in</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Falls back to <code>base::'%in%'</code> when x and y don't share a common type.
This means that the behaviour of <code>base::'%in%'</code> is preserved (e.g. <code>"1" %in% c(1, 2)</code> is <code>TRUE</code>)
but loses the speedup provided by <code>vctrs::vec_in()</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>df &lt;- tidytable(x = 1:4, y = 1:4)

df %&gt;%
  filter(x %in% c(2, 4))

df %&gt;%
  filter(x %notin% c(2, 4))
</code></pre>

<hr>
<h2 id='across'>Apply a function across a selection of columns</h2><span id='topic+across'></span>

<h3>Description</h3>

<p>Apply a function across a selection of columns. For use in <code>arrange()</code>,
<code>mutate()</code>, and <code>summarize()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>across(.cols = everything(), .fns = NULL, ..., .names = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="across_+3A_.cols">.cols</code></td>
<td>
<p>vector <code>c()</code> of unquoted column names. <code>tidyselect</code> compatible.</p>
</td></tr>
<tr><td><code id="across_+3A_.fns">.fns</code></td>
<td>
<p>Function to apply. Can be a purrr-style lambda.
Can pass also list of functions.</p>
</td></tr>
<tr><td><code id="across_+3A_...">...</code></td>
<td>
<p>Other arguments for the passed function</p>
</td></tr>
<tr><td><code id="across_+3A_.names">.names</code></td>
<td>
<p>A glue specification that helps with renaming output columns.
<code>{.col}</code> stands for the selected column, and <code>{.fn}</code> stands for the name of the function being applied.
The default (<code>NULL</code>) is equivalent to <code>"{.col}"</code> for a single function case and <code>"{.col}_{.fn}"</code>
when a list is used for <code>.fns</code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>df &lt;- data.table(
  x = rep(1, 3),
  y = rep(2, 3),
  z = c("a", "a", "b")
)

df %&gt;%
  mutate(across(c(x, y), ~ .x * 2))

df %&gt;%
  summarize(across(where(is.numeric), ~ mean(.x)),
            .by = z)

df %&gt;%
  arrange(across(c(y, z)))
</code></pre>

<hr>
<h2 id='add_count'>Add a count column to the data frame</h2><span id='topic+add_count'></span><span id='topic+add_tally'></span>

<h3>Description</h3>

<p>Add a count column to the data frame.
</p>
<p><code>df %&gt;% add_count(a, b)</code> is equivalent to using <code>df %&gt;% mutate(n = n(), .by = c(a, b))</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_count(.df, ..., wt = NULL, sort = FALSE, name = NULL)

add_tally(.df, wt = NULL, sort = FALSE, name = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_count_+3A_.df">.df</code></td>
<td>
<p>A data.frame or data.table</p>
</td></tr>
<tr><td><code id="add_count_+3A_...">...</code></td>
<td>
<p>Columns to group by. <code>tidyselect</code> compatible.</p>
</td></tr>
<tr><td><code id="add_count_+3A_wt">wt</code></td>
<td>
<p>Frequency weights.
Can be <code>NULL</code> or a variable:
</p>

<ul>
<li><p> If <code>NULL</code> (the default), counts the number of rows in each group.
</p>
</li>
<li><p> If a variable, computes <code>sum(wt)</code> for each group.
</p>
</li></ul>
</td></tr>
<tr><td><code id="add_count_+3A_sort">sort</code></td>
<td>
<p>If <code>TRUE</code>, will show the largest groups at the top.</p>
</td></tr>
<tr><td><code id="add_count_+3A_name">name</code></td>
<td>
<p>The name of the new column in the output.
</p>
<p>If omitted, it will default to <code>n</code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>df &lt;- data.table(
  a = c("a", "a", "b"),
  b = 1:3
)

df %&gt;%
  add_count(a)
</code></pre>

<hr>
<h2 id='arrange'>Arrange/reorder rows</h2><span id='topic+arrange'></span>

<h3>Description</h3>

<p>Order rows in ascending or descending order.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>arrange(.df, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="arrange_+3A_.df">.df</code></td>
<td>
<p>A data.frame or data.table</p>
</td></tr>
<tr><td><code id="arrange_+3A_...">...</code></td>
<td>
<p>Variables to arrange by</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>df &lt;- data.table(
  a = 1:3,
  b = 4:6,
  c = c("a", "a", "b")
)

df %&gt;%
  arrange(c, -a)

df %&gt;%
  arrange(c, desc(a))
</code></pre>

<hr>
<h2 id='as_tidytable'>Coerce an object to a data.table/tidytable</h2><span id='topic+as_tidytable'></span>

<h3>Description</h3>

<p>A tidytable object is simply a data.table with nice printing features.
</p>
<p>Note that all tidytable functions automatically convert data.frames &amp; data.tables to tidytables in the background.
As such this function will rarely need to be used by the user.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_tidytable(x, ..., .name_repair = "unique", .keep_rownames = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as_tidytable_+3A_x">x</code></td>
<td>
<p>An R object</p>
</td></tr>
<tr><td><code id="as_tidytable_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to or from other methods.</p>
</td></tr>
<tr><td><code id="as_tidytable_+3A_.name_repair">.name_repair</code></td>
<td>
<p>Treatment of duplicate names. See <code>?vctrs::vec_as_names</code> for options/details.</p>
</td></tr>
<tr><td><code id="as_tidytable_+3A_.keep_rownames">.keep_rownames</code></td>
<td>
<p>Default is <code>FALSE</code>. If <code>TRUE</code>, adds the input object's names as a separate
column named <code>"rn"</code>. <code>.keep_rownames = "id"</code> names the column &quot;id&quot; instead.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>df &lt;- data.frame(x = -2:2, y = c(rep("a", 3), rep("b", 2)))

df %&gt;%
  as_tidytable()
</code></pre>

<hr>
<h2 id='between'>Do the values from x fall between the left and right bounds?</h2><span id='topic+between'></span>

<h3>Description</h3>

<p><code>between()</code> utilizes <code>data.table::between()</code> in the background
</p>


<h3>Usage</h3>

<pre><code class='language-R'>between(x, left, right)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="between_+3A_x">x</code></td>
<td>
<p>A numeric vector</p>
</td></tr>
<tr><td><code id="between_+3A_left">left</code>, <code id="between_+3A_right">right</code></td>
<td>
<p>Boundary values</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>df &lt;- data.table(
  x = 1:5,
  y = 1:5
)

# Typically used in a filter()
df %&gt;%
  filter(between(x, 2, 4))

df %&gt;%
  filter(x %&gt;% between(2, 4))

# Can also use the %between% operator
df %&gt;%
  filter(x %between% c(2, 4))
</code></pre>

<hr>
<h2 id='bind_cols'>Bind data.tables by row and column</h2><span id='topic+bind_cols'></span><span id='topic+bind_rows'></span>

<h3>Description</h3>

<p>Bind multiple data.tables into one row-wise or col-wise.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bind_cols(..., .name_repair = "unique")

bind_rows(..., .id = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bind_cols_+3A_...">...</code></td>
<td>
<p>data.tables or data.frames to bind</p>
</td></tr>
<tr><td><code id="bind_cols_+3A_.name_repair">.name_repair</code></td>
<td>
<p>Treatment of duplicate names. See <code>?vctrs::vec_as_names</code> for options/details.</p>
</td></tr>
<tr><td><code id="bind_cols_+3A_.id">.id</code></td>
<td>
<p>If TRUE, an integer column is made as a group id</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># Binding data together by row
df1 &lt;- data.table(x = 1:3, y = 10:12)
df2 &lt;- data.table(x = 4:6, y = 13:15)

df1 %&gt;%
  bind_rows(df2)

# Can pass a list of data.tables
df_list &lt;- list(df1, df2)

bind_rows(df_list)

# Binding data together by column
df1 &lt;- data.table(a = 1:3, b = 4:6)
df2 &lt;- data.table(c = 7:9)

df1 %&gt;%
  bind_cols(df2)

# Can pass a list of data frames
bind_cols(list(df1, df2))
</code></pre>

<hr>
<h2 id='c_across'>Combine values from multiple columns</h2><span id='topic+c_across'></span>

<h3>Description</h3>

<p><code>c_across()</code> works inside of <code>mutate_rowwise()</code>. It uses tidyselect so
you can easily select multiple variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>c_across(cols = everything())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="c_across_+3A_cols">cols</code></td>
<td>
<p>Columns to transform.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>df &lt;- data.table(x = runif(6), y = runif(6), z = runif(6))

df %&gt;%
  mutate_rowwise(row_mean = mean(c_across(x:z)))
</code></pre>

<hr>
<h2 id='case'><code>data.table::fcase()</code> with vectorized default</h2><span id='topic+case'></span>

<h3>Description</h3>

<p>This function allows you to use multiple if/else statements in one call.
</p>
<p>It is called like <code>data.table::fcase()</code>, but allows the user to use
a vector as the <code>default</code> argument.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>case(..., default = NA, ptype = NULL, size = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="case_+3A_...">...</code></td>
<td>
<p>Sequence of condition/value designations</p>
</td></tr>
<tr><td><code id="case_+3A_default">default</code></td>
<td>
<p>Default value. Set to NA by default.</p>
</td></tr>
<tr><td><code id="case_+3A_ptype">ptype</code></td>
<td>
<p>Optional ptype to specify the output type.</p>
</td></tr>
<tr><td><code id="case_+3A_size">size</code></td>
<td>
<p>Optional size to specify the output size.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>df &lt;- tidytable(x = 1:10)

df %&gt;%
  mutate(case_x = case(x &lt; 5, 1,
                       x &lt; 7, 2,
                       default = 3))
</code></pre>

<hr>
<h2 id='case_match'>Vectorized <code>switch()</code></h2><span id='topic+case_match'></span>

<h3>Description</h3>

<p>Allows the user to succinctly create a new vector based off conditions of a single vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>case_match(.x, ..., .default = NA, .ptype = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="case_match_+3A_.x">.x</code></td>
<td>
<p>A vector</p>
</td></tr>
<tr><td><code id="case_match_+3A_...">...</code></td>
<td>
<p>A sequence of two-sided formulas. The left hand side gives the old values,
the right hand side gives the new value.</p>
</td></tr>
<tr><td><code id="case_match_+3A_.default">.default</code></td>
<td>
<p>The default value if all conditions evaluate to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="case_match_+3A_.ptype">.ptype</code></td>
<td>
<p>Optional ptype to specify the output type.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>df &lt;- tidytable(x = c("a", "b", "c", "d"))

df %&gt;%
  mutate(
    case_x = case_match(x,
                        c("a", "b") ~ "new_1",
                        "c" ~ "new_2",
                        .default = x)
  )
</code></pre>

<hr>
<h2 id='case_when'>Case when</h2><span id='topic+case_when'></span>

<h3>Description</h3>

<p>This function allows you to use multiple if/else statements in one call.
</p>
<p>It is called like <code>dplyr::case_when()</code>, but utilizes <code>data.table::fifelse()</code>
in the background for improved performance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>case_when(..., .default = NA, .ptype = NULL, .size = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="case_when_+3A_...">...</code></td>
<td>
<p>A sequence of two-sided formulas. The left hand side gives the conditions,
the right hand side gives the values.</p>
</td></tr>
<tr><td><code id="case_when_+3A_.default">.default</code></td>
<td>
<p>The default value if all conditions evaluate to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="case_when_+3A_.ptype">.ptype</code></td>
<td>
<p>Optional ptype to specify the output type.</p>
</td></tr>
<tr><td><code id="case_when_+3A_.size">.size</code></td>
<td>
<p>Optional size to specify the output size.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>df &lt;- tidytable(x = 1:10)

df %&gt;%
  mutate(case_x = case_when(x &lt; 5 ~ 1,
                            x &lt; 7 ~ 2,
                            TRUE ~ 3))
</code></pre>

<hr>
<h2 id='coalesce'>Coalesce missing values</h2><span id='topic+coalesce'></span>

<h3>Description</h3>

<p>Fill in missing values in a vector by pulling successively from other vectors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coalesce(..., .ptype = NULL, .size = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coalesce_+3A_...">...</code></td>
<td>
<p>Input vectors. Supports dynamic dots.</p>
</td></tr>
<tr><td><code id="coalesce_+3A_.ptype">.ptype</code></td>
<td>
<p>Optional ptype to override output type</p>
</td></tr>
<tr><td><code id="coalesce_+3A_.size">.size</code></td>
<td>
<p>Optional size to override output size</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># Use a single value to replace all missing values
x &lt;- c(1:3, NA, NA)
coalesce(x, 0)

# Or match together a complete vector from missing pieces
y &lt;- c(1, 2, NA, NA, 5)
z &lt;- c(NA, NA, 3, 4, 5)
coalesce(y, z)

# Supply lists with dynamic dots
vecs &lt;- list(
  c(1, 2, NA, NA, 5),
  c(NA, NA, 3, 4, 5)
)
coalesce(!!!vecs)
</code></pre>

<hr>
<h2 id='complete'>Complete a data.table with missing combinations of data</h2><span id='topic+complete'></span>

<h3>Description</h3>

<p>Turns implicit missing values into explicit missing values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>complete(.df, ..., fill = list(), .by = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="complete_+3A_.df">.df</code></td>
<td>
<p>A data.frame or data.table</p>
</td></tr>
<tr><td><code id="complete_+3A_...">...</code></td>
<td>
<p>Columns to expand</p>
</td></tr>
<tr><td><code id="complete_+3A_fill">fill</code></td>
<td>
<p>A named list of values to fill NAs with.</p>
</td></tr>
<tr><td><code id="complete_+3A_.by">.by</code></td>
<td>
<p>Columns to group by</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>df &lt;- data.table(x = 1:2, y = 1:2, z = 3:4)

df %&gt;%
  complete(x, y)

df %&gt;%
  complete(x, y, fill = list(z = 10))
</code></pre>

<hr>
<h2 id='consecutive_id'>Generate a unique id for consecutive values</h2><span id='topic+consecutive_id'></span>

<h3>Description</h3>

<p>Generate a unique id for runs of consecutive values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>consecutive_id(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="consecutive_id_+3A_...">...</code></td>
<td>
<p>Vectors of values</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- c(1, 1, 2, 2, 1, 1)
consecutive_id(x)
</code></pre>

<hr>
<h2 id='context'>Context functions</h2><span id='topic+context'></span><span id='topic+cur_column'></span><span id='topic+cur_data'></span><span id='topic+cur_group_id'></span><span id='topic+cur_group_rows'></span>

<h3>Description</h3>

<p>These functions give information about the &quot;current&quot; group.
</p>

<ul>
<li> <p><code>cur_data()</code> gives the current data for the current group
</p>
</li>
<li> <p><code>cur_column()</code> gives the name of the current column (for use in <code>across()</code> only)
</p>
</li>
<li> <p><code>cur_group_id()</code> gives a group identification number
</p>
</li>
<li> <p><code>cur_group_rows()</code> gives the row indices for each group
</p>
</li></ul>

<p>Can be used inside <code>summarize()</code>, <code>mutate()</code>, &amp; <code>filter()</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cur_column()

cur_data()

cur_group_id()

cur_group_rows()
</code></pre>


<h3>Examples</h3>

<pre><code class='language-R'>df &lt;- data.table(
  x = 1:5,
  y = c("a", "a", "a", "b", "b")
)

df %&gt;%
  mutate(
    across(c(x, y), ~ paste(cur_column(), .x))
  )

df %&gt;%
  summarize(data = list(cur_data()),
            .by = y)

df %&gt;%
  mutate(group_id = cur_group_id(),
         .by = y)

df %&gt;%
  mutate(group_rows = cur_group_rows(),
         .by = y)
</code></pre>

<hr>
<h2 id='count'>Count observations by group</h2><span id='topic+count'></span><span id='topic+tally'></span>

<h3>Description</h3>

<p>Returns row counts of the dataset.
</p>
<p><code>tally()</code> returns counts by group on a grouped tidytable.
</p>
<p><code>count()</code> returns counts by group on a grouped tidytable, or column names can be specified
to return counts by group.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>count(.df, ..., wt = NULL, sort = FALSE, name = NULL)

tally(.df, wt = NULL, sort = FALSE, name = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="count_+3A_.df">.df</code></td>
<td>
<p>A data.frame or data.table</p>
</td></tr>
<tr><td><code id="count_+3A_...">...</code></td>
<td>
<p>Columns to group by in <code>count()</code>. <code>tidyselect</code> compatible.</p>
</td></tr>
<tr><td><code id="count_+3A_wt">wt</code></td>
<td>
<p>Frequency weights.  <code>tidyselect</code> compatible.
Can be <code>NULL</code> or a variable:
</p>

<ul>
<li><p> If <code>NULL</code> (the default), counts the number of rows in each group.
</p>
</li>
<li><p> If a variable, computes <code>sum(wt)</code> for each group.
</p>
</li></ul>
</td></tr>
<tr><td><code id="count_+3A_sort">sort</code></td>
<td>
<p>If <code>TRUE</code>, will show the largest groups at the top.</p>
</td></tr>
<tr><td><code id="count_+3A_name">name</code></td>
<td>
<p>The name of the new column in the output.
</p>
<p>If omitted, it will default to <code>n</code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>df &lt;- data.table(
  x = c("a", "a", "b"),
  y = c("a", "a", "b"),
  z = 1:3
)

df %&gt;%
  count()

df %&gt;%
  count(x)

df %&gt;%
  count(where(is.character))

df %&gt;%
  count(x, wt = z, name = "x_sum")

df %&gt;%
  count(x, sort = TRUE)

df %&gt;%
  tally()

df %&gt;%
  group_by(x) %&gt;%
  tally()
</code></pre>

<hr>
<h2 id='cross_join'>Cross join</h2><span id='topic+cross_join'></span>

<h3>Description</h3>

<p>Cross join each row of <code>x</code> to every row in <code>y</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cross_join(x, y, ..., suffix = c(".x", ".y"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cross_join_+3A_x">x</code></td>
<td>
<p>A data.frame or data.table</p>
</td></tr>
<tr><td><code id="cross_join_+3A_y">y</code></td>
<td>
<p>A data.frame or data.table</p>
</td></tr>
<tr><td><code id="cross_join_+3A_...">...</code></td>
<td>
<p>Other parameters passed on to methods</p>
</td></tr>
<tr><td><code id="cross_join_+3A_suffix">suffix</code></td>
<td>
<p>Append created for duplicated column names when using <code>full_join()</code></p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>df1 &lt;- tidytable(x = 1:3)
df2 &lt;- tidytable(y = 4:6)

cross_join(df1, df2)
</code></pre>

<hr>
<h2 id='crossing'>Create a data.table from all unique combinations of inputs</h2><span id='topic+crossing'></span>

<h3>Description</h3>

<p><code>crossing()</code> is similar to <code>expand_grid()</code> but de-duplicates and sorts its inputs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>crossing(..., .name_repair = "check_unique")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="crossing_+3A_...">...</code></td>
<td>
<p>Variables to get unique combinations of</p>
</td></tr>
<tr><td><code id="crossing_+3A_.name_repair">.name_repair</code></td>
<td>
<p>Treatment of problematic names. See <code>?vctrs::vec_as_names</code> for options/details</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- 1:2
y &lt;- 1:2

crossing(x, y)

crossing(stuff = x, y)
</code></pre>

<hr>
<h2 id='desc'>Descending order</h2><span id='topic+desc'></span>

<h3>Description</h3>

<p>Arrange in descending order. Can be used inside of <code>arrange()</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>desc(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="desc_+3A_x">x</code></td>
<td>
<p>Variable to arrange in descending order</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>df &lt;- data.table(
  a = 1:3,
  b = 4:6,
  c = c("a", "a", "b")
)

df %&gt;%
  arrange(c, desc(a))
</code></pre>

<hr>
<h2 id='distinct'>Select distinct/unique rows</h2><span id='topic+distinct'></span>

<h3>Description</h3>

<p>Retain only unique/distinct rows from an input df.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distinct(.df, ..., .keep_all = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="distinct_+3A_.df">.df</code></td>
<td>
<p>A data.frame or data.table</p>
</td></tr>
<tr><td><code id="distinct_+3A_...">...</code></td>
<td>
<p>Columns to select before determining uniqueness. If omitted, will use all columns.
<code>tidyselect</code> compatible.</p>
</td></tr>
<tr><td><code id="distinct_+3A_.keep_all">.keep_all</code></td>
<td>
<p>Only relevant if columns are provided to ... arg.
This keeps all columns, but only keeps the first row of each distinct
values of columns provided to ... arg.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>df &lt;- tidytable(
  x = 1:3,
  y = 4:6,
  z = c("a", "a", "b")
)

df %&gt;%
  distinct()

df %&gt;%
  distinct(z)
</code></pre>

<hr>
<h2 id='drop_na'>Drop rows containing missing values</h2><span id='topic+drop_na'></span>

<h3>Description</h3>

<p>Drop rows containing missing values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>drop_na(.df, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="drop_na_+3A_.df">.df</code></td>
<td>
<p>A data.frame or data.table</p>
</td></tr>
<tr><td><code id="drop_na_+3A_...">...</code></td>
<td>
<p>Optional: A selection of columns. If empty, all variables are selected.
<code>tidyselect</code> compatible.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>df &lt;- data.table(
  x = c(1, 2, NA),
  y = c("a", NA, "b")
)

df %&gt;%
  drop_na()

df %&gt;%
  drop_na(x)

df %&gt;%
  drop_na(where(is.numeric))
</code></pre>

<hr>
<h2 id='dt'>Pipeable data.table call</h2><span id='topic+dt'></span>

<h3>Description</h3>

<p>Pipeable data.table call.
</p>
<p>This function does not use data.table's modify-by-reference.
</p>
<p>Has experimental support for tidy evaluation for custom functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dt(.df, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dt_+3A_.df">.df</code></td>
<td>
<p>A data.frame or data.table</p>
</td></tr>
<tr><td><code id="dt_+3A_...">...</code></td>
<td>
<p>Arguments passed to data.table call. See <code>?data.table::`[.data.table` </code></p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>df &lt;- tidytable(
  x = 1:3,
  y = 4:6,
  z = c("a", "a", "b")
)

df %&gt;%
  dt(, double_x := x * 2) %&gt;%
  dt(order(-double_x))

# Experimental support for tidy evaluation for custom functions
add_one &lt;- function(data, col) {
  data %&gt;%
    dt(, new_col := {{ col }} + 1)
}

df %&gt;%
  add_one(x)
</code></pre>

<hr>
<h2 id='enframe'>Convert a vector to a data.table/tidytable</h2><span id='topic+enframe'></span>

<h3>Description</h3>

<p>Converts named and unnamed vectors to a data.table/tidytable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>enframe(x, name = "name", value = "value")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="enframe_+3A_x">x</code></td>
<td>
<p>A vector</p>
</td></tr>
<tr><td><code id="enframe_+3A_name">name</code></td>
<td>
<p>Name of the column that stores the names. If <code>name = NULL</code>,
a one-column tidytable will be returned.</p>
</td></tr>
<tr><td><code id="enframe_+3A_value">value</code></td>
<td>
<p>Name of the column that stores the values.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>vec &lt;- 1:3
names(vec) &lt;- letters[1:3]

enframe(vec)
</code></pre>

<hr>
<h2 id='expand'>Expand a data.table to use all combinations of values</h2><span id='topic+expand'></span><span id='topic+nesting'></span>

<h3>Description</h3>

<p>Generates all combinations of variables found in a dataset.
</p>
<p><code>expand()</code> is useful in conjunction with joins:
</p>

<ul>
<li><p> use with <code>right_join()</code> to convert implicit missing values to explicit missing values
</p>
</li>
<li><p> use with <code>anti_join()</code> to find out which combinations are missing
</p>
</li></ul>

<p><code>nesting()</code> is a helper that only finds combinations already present in the dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expand(.df, ..., .name_repair = "check_unique", .by = NULL)

nesting(..., .name_repair = "check_unique")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="expand_+3A_.df">.df</code></td>
<td>
<p>A data.frame or data.table</p>
</td></tr>
<tr><td><code id="expand_+3A_...">...</code></td>
<td>
<p>Columns to get combinations of</p>
</td></tr>
<tr><td><code id="expand_+3A_.name_repair">.name_repair</code></td>
<td>
<p>Treatment of duplicate names. See <code>?vctrs::vec_as_names</code> for options/details</p>
</td></tr>
<tr><td><code id="expand_+3A_.by">.by</code></td>
<td>
<p>Columns to group by</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>df &lt;- tidytable(x = c(1, 1, 2), y = c(1, 1, 2))

df %&gt;%
  expand(x, y)

df %&gt;%
  expand(nesting(x, y))
</code></pre>

<hr>
<h2 id='expand_grid'>Create a data.table from all combinations of inputs</h2><span id='topic+expand_grid'></span>

<h3>Description</h3>

<p>Create a data.table from all combinations of inputs
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expand_grid(..., .name_repair = "check_unique")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="expand_grid_+3A_...">...</code></td>
<td>
<p>Variables to get combinations of</p>
</td></tr>
<tr><td><code id="expand_grid_+3A_.name_repair">.name_repair</code></td>
<td>
<p>Treatment of problematic names. See <code>?vctrs::vec_as_names</code> for options/details</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- 1:2
y &lt;- 1:2

expand_grid(x, y)

expand_grid(stuff = x, y)
</code></pre>

<hr>
<h2 id='extract'>Extract a character column into multiple columns using regex</h2><span id='topic+extract'></span>

<h3>Description</h3>

<p><em>Superseded</em>
</p>
<p><code>extract()</code> has been superseded by <code>separate_wider_regex()</code>.
</p>
<p>Given a regular expression with capturing groups, <code>extract()</code> turns each group
into a new column. If the groups don't match, or the input is <code>NA</code>, the output
will be <code>NA</code>. When you pass same name in the <code>into</code> argument it will merge
the groups together. Whilst passing <code>NA</code> in the <code>into</code> arg will drop the group
from the resulting <code>tidytable</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract(
  .df,
  col,
  into,
  regex = "([[:alnum:]]+)",
  remove = TRUE,
  convert = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extract_+3A_.df">.df</code></td>
<td>
<p>A data.table or data.frame</p>
</td></tr>
<tr><td><code id="extract_+3A_col">col</code></td>
<td>
<p>Column to extract from</p>
</td></tr>
<tr><td><code id="extract_+3A_into">into</code></td>
<td>
<p>New column names to split into. A character vector.</p>
</td></tr>
<tr><td><code id="extract_+3A_regex">regex</code></td>
<td>
<p>A regular expression to extract the desired values. There
should be one group (defined by <code style="white-space: pre;">&#8288;()&#8288;</code>) for each element of <code>into</code></p>
</td></tr>
<tr><td><code id="extract_+3A_remove">remove</code></td>
<td>
<p>If TRUE, remove the input column from the output data.table</p>
</td></tr>
<tr><td><code id="extract_+3A_convert">convert</code></td>
<td>
<p>If TRUE, runs <code>type.convert()</code> on the resulting column.
Useful if the resulting column should be type integer/double.</p>
</td></tr>
<tr><td><code id="extract_+3A_...">...</code></td>
<td>
<p>Additional arguments passed on to methods.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>df &lt;- data.table(x = c(NA, "a-b-1", "a-d-3", "b-c-2", "d-e-7"))
df %&gt;% extract(x, "A")
df %&gt;% extract(x, c("A", "B"), "([[:alnum:]]+)-([[:alnum:]]+)")

# If no match, NA:
df %&gt;% extract(x, c("A", "B"), "([a-d]+)-([a-d]+)")
# drop columns by passing NA
df %&gt;% extract(x, c("A", NA, "B"), "([a-d]+)-([a-d]+)-(\\d+)")
# merge groups by passing same name
df %&gt;% extract(x, c("A", "B", "A"), "([a-d]+)-([a-d]+)-(\\d+)")
</code></pre>

<hr>
<h2 id='fill'>Fill in missing values with previous or next value</h2><span id='topic+fill'></span>

<h3>Description</h3>

<p>Fills missing values in the selected columns using the next or previous entry. Can be done by group.
</p>
<p>Supports tidyselect
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fill(.df, ..., .direction = c("down", "up", "downup", "updown"), .by = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fill_+3A_.df">.df</code></td>
<td>
<p>A data.frame or data.table</p>
</td></tr>
<tr><td><code id="fill_+3A_...">...</code></td>
<td>
<p>A selection of columns. <code>tidyselect</code> compatible.</p>
</td></tr>
<tr><td><code id="fill_+3A_.direction">.direction</code></td>
<td>
<p>Direction in which to fill missing values.
Currently &quot;down&quot; (the default), &quot;up&quot;, &quot;downup&quot; (first down then up), or &quot;updown&quot; (first up and then down)</p>
</td></tr>
<tr><td><code id="fill_+3A_.by">.by</code></td>
<td>
<p>Columns to group by when filling should be done by group</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>df &lt;- data.table(
  a = c(1, NA, 3, 4, 5),
  b = c(NA, 2, NA, NA, 5),
  groups = c("a", "a", "a", "b", "b")
)

df %&gt;%
  fill(a, b)

df %&gt;%
  fill(a, b, .by = groups)

df %&gt;%
  fill(a, b, .direction = "downup", .by = groups)
</code></pre>

<hr>
<h2 id='filter'>Filter rows on one or more conditions</h2><span id='topic+filter'></span>

<h3>Description</h3>

<p>Filters a dataset to choose rows where conditions are true.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>filter(.df, ..., .by = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="filter_+3A_.df">.df</code></td>
<td>
<p>A data.frame or data.table</p>
</td></tr>
<tr><td><code id="filter_+3A_...">...</code></td>
<td>
<p>Conditions to filter by</p>
</td></tr>
<tr><td><code id="filter_+3A_.by">.by</code></td>
<td>
<p>Columns to group by if filtering with a summary function</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>df &lt;- tidytable(
  a = 1:3,
  b = 4:6,
  c = c("a", "a", "b")
)

df %&gt;%
  filter(a &gt;= 2, b &gt;= 4)

df %&gt;%
  filter(b &lt;= mean(b), .by = c)
</code></pre>

<hr>
<h2 id='first'>Extract the first, last, or nth value from a vector</h2><span id='topic+first'></span><span id='topic+last'></span><span id='topic+nth'></span>

<h3>Description</h3>

<p>Extract the first, last, or nth value from a vector.
</p>
<p>Note: These are simple wrappers around <code>vctrs::vec_slice()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>first(x, default = NULL, na_rm = FALSE)

last(x, default = NULL, na_rm = FALSE)

nth(x, n, default = NULL, na_rm = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="first_+3A_x">x</code></td>
<td>
<p>A vector</p>
</td></tr>
<tr><td><code id="first_+3A_default">default</code></td>
<td>
<p>The default value if the value doesn't exist.</p>
</td></tr>
<tr><td><code id="first_+3A_na_rm">na_rm</code></td>
<td>
<p>If <code>TRUE</code> ignores missing values.</p>
</td></tr>
<tr><td><code id="first_+3A_n">n</code></td>
<td>
<p>For <code>nth()</code>, a number specifying the position to grab.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>vec &lt;- letters

first(vec)
last(vec)
nth(vec, 4)
</code></pre>

<hr>
<h2 id='fread'>Read/write files</h2><span id='topic+fread'></span>

<h3>Description</h3>

<p><code>fread()</code> is a simple wrapper around <code>data.table::fread()</code> that returns a tidytable
instead of a data.table.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fread(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fread_+3A_...">...</code></td>
<td>
<p>Arguments passed on to <code>data.table::fread</code></p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>fake_csv &lt;- "A,B
             1,2
             3,4"

fread(fake_csv)
</code></pre>

<hr>
<h2 id='get_dummies'>Convert character and factor columns to dummy variables</h2><span id='topic+get_dummies'></span>

<h3>Description</h3>

<p>Convert character and factor columns to dummy variables
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_dummies(
  .df,
  cols = where(~is.character(.x) | is.factor(.x)),
  prefix = TRUE,
  prefix_sep = "_",
  drop_first = FALSE,
  dummify_na = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_dummies_+3A_.df">.df</code></td>
<td>
<p>A data.frame or data.table</p>
</td></tr>
<tr><td><code id="get_dummies_+3A_cols">cols</code></td>
<td>
<p>A single column or a vector of unquoted columns to dummify.
Defaults to all character &amp; factor columns using <code>c(where(is.character), where(is.factor))</code>.
<code>tidyselect</code> compatible.</p>
</td></tr>
<tr><td><code id="get_dummies_+3A_prefix">prefix</code></td>
<td>
<p>TRUE/FALSE - If TRUE, a prefix will be added to new column names</p>
</td></tr>
<tr><td><code id="get_dummies_+3A_prefix_sep">prefix_sep</code></td>
<td>
<p>Separator for new column names</p>
</td></tr>
<tr><td><code id="get_dummies_+3A_drop_first">drop_first</code></td>
<td>
<p>TRUE/FALSE - If TRUE, the first dummy column will be dropped</p>
</td></tr>
<tr><td><code id="get_dummies_+3A_dummify_na">dummify_na</code></td>
<td>
<p>TRUE/FALSE - If TRUE, NAs will also get dummy columns</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>df &lt;- tidytable(
  chr = c("a", "b", NA),
  fct = as.factor(c("a", NA, "c")),
  num = 1:3
)

# Automatically does all character/factor columns
df %&gt;%
  get_dummies()

df %&gt;%
  get_dummies(cols = chr)

df %&gt;%
  get_dummies(cols = c(chr, fct), drop_first = TRUE)

df %&gt;%
  get_dummies(prefix_sep = ".", dummify_na = FALSE)
</code></pre>

<hr>
<h2 id='group_by'>Grouping</h2><span id='topic+group_by'></span><span id='topic+ungroup'></span>

<h3>Description</h3>


<ul>
<li> <p><code>group_by()</code> adds a grouping structure to a tidytable. Can use tidyselect syntax.
</p>
</li>
<li> <p><code>ungroup()</code> removes grouping.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>group_by(.df, ..., .add = FALSE)

ungroup(.df, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="group_by_+3A_.df">.df</code></td>
<td>
<p>A data.frame or data.table</p>
</td></tr>
<tr><td><code id="group_by_+3A_...">...</code></td>
<td>
<p>Columns to group by</p>
</td></tr>
<tr><td><code id="group_by_+3A_.add">.add</code></td>
<td>
<p>Should grouping cols specified be added to the current grouping</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>df &lt;- data.table(
  a = 1:3,
  b = 4:6,
  c = c("a", "a", "b"),
  d = c("a", "a", "b")
)

df %&gt;%
  group_by(c, d) %&gt;%
  summarize(mean_a = mean(a)) %&gt;%
  ungroup()

# Can also use tidyselect
df %&gt;%
  group_by(where(is.character)) %&gt;%
  summarize(mean_a = mean(a)) %&gt;%
  ungroup()
</code></pre>

<hr>
<h2 id='group_cols'>Selection helper for grouping columns</h2><span id='topic+group_cols'></span>

<h3>Description</h3>

<p>Selection helper for grouping columns
</p>


<h3>Usage</h3>

<pre><code class='language-R'>group_cols()
</code></pre>


<h3>Examples</h3>

<pre><code class='language-R'>df &lt;- tidytable(
  x = c("a", "b", "c"),
  y = 1:3,
  z = 1:3
)

df %&gt;%
  group_by(x) %&gt;%
  select(group_cols(), y)
</code></pre>

<hr>
<h2 id='group_split'>Split data frame by groups</h2><span id='topic+group_split'></span>

<h3>Description</h3>

<p>Split data frame by groups. Returns a list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>group_split(.df, ..., .keep = TRUE, .named = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="group_split_+3A_.df">.df</code></td>
<td>
<p>A data.frame or data.table</p>
</td></tr>
<tr><td><code id="group_split_+3A_...">...</code></td>
<td>
<p>Columns to group and split by. <code>tidyselect</code> compatible.</p>
</td></tr>
<tr><td><code id="group_split_+3A_.keep">.keep</code></td>
<td>
<p>Should the grouping columns be kept</p>
</td></tr>
<tr><td><code id="group_split_+3A_.named">.named</code></td>
<td>
<p><em>experimental</em>: Should the list be named with labels that identify the group</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>df &lt;- tidytable(
  a = 1:3,
  b = 1:3,
  c = c("a", "a", "b"),
  d = c("a", "a", "b")
)

df %&gt;%
  group_split(c, d)

df %&gt;%
  group_split(c, d, .keep = FALSE)

df %&gt;%
  group_split(c, d, .named = TRUE)
</code></pre>

<hr>
<h2 id='group_vars'>Get the grouping variables</h2><span id='topic+group_vars'></span>

<h3>Description</h3>

<p>Get the grouping variables
</p>


<h3>Usage</h3>

<pre><code class='language-R'>group_vars(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="group_vars_+3A_x">x</code></td>
<td>
<p>A grouped tidytable</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>df &lt;- data.table(
  a = 1:3,
  b = 4:6,
  c = c("a", "a", "b"),
  d = c("a", "a", "b")
)

df %&gt;%
  group_by(c, d) %&gt;%
  group_vars()
</code></pre>

<hr>
<h2 id='if_all'>Create conditions on a selection of columns</h2><span id='topic+if_all'></span><span id='topic+if_any'></span>

<h3>Description</h3>

<p>Helpers to apply a filter across a selection of columns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>if_all(.cols = everything(), .fns = NULL, ...)

if_any(.cols = everything(), .fns = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="if_all_+3A_.cols">.cols</code></td>
<td>
<p>Selection of columns</p>
</td></tr>
<tr><td><code id="if_all_+3A_.fns">.fns</code></td>
<td>
<p>Function to create filter conditions</p>
</td></tr>
<tr><td><code id="if_all_+3A_...">...</code></td>
<td>
<p>Other arguments passed to the function</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>iris %&gt;%
  filter(if_any(ends_with("Width"), ~ .x &gt; 4))

iris %&gt;%
  filter(if_all(ends_with("Width"), ~ .x &gt; 2))
</code></pre>

<hr>
<h2 id='if_else'>Fast if_else</h2><span id='topic+if_else'></span>

<h3>Description</h3>

<p>Fast version of <code>base::ifelse()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>if_else(condition, true, false, missing = NA, ..., ptype = NULL, size = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="if_else_+3A_condition">condition</code></td>
<td>
<p>Conditions to test on</p>
</td></tr>
<tr><td><code id="if_else_+3A_true">true</code></td>
<td>
<p>Values to return if conditions evaluate to <code>TRUE</code></p>
</td></tr>
<tr><td><code id="if_else_+3A_false">false</code></td>
<td>
<p>Values to return if conditions evaluate to <code>FALSE</code></p>
</td></tr>
<tr><td><code id="if_else_+3A_missing">missing</code></td>
<td>
<p>Value to return if an element of test is <code>NA</code></p>
</td></tr>
<tr><td><code id="if_else_+3A_...">...</code></td>
<td>
<p>These dots are for future extensions and must be empty.</p>
</td></tr>
<tr><td><code id="if_else_+3A_ptype">ptype</code></td>
<td>
<p>Optional ptype to override output type</p>
</td></tr>
<tr><td><code id="if_else_+3A_size">size</code></td>
<td>
<p>Optional size to override output size</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- 1:5
if_else(x &lt; 3, 1, 0)

# Can also be used inside of mutate()
df &lt;- data.table(x = x)

df %&gt;%
  mutate(new_col = if_else(x &lt; 3, 1, 0))
</code></pre>

<hr>
<h2 id='inv_gc'>Run invisible garbage collection</h2><span id='topic+inv_gc'></span>

<h3>Description</h3>

<p>Run garbage collection without the <code>gc()</code> output. Can also be run in the middle of a long pipe chain.
Useful for large datasets or when using parallel processing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inv_gc(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="inv_gc_+3A_x">x</code></td>
<td>
<p>Optional. If missing runs <code>gc()</code> silently. Else returns the same object unaltered.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># Can be run with no input
inv_gc()

df &lt;- tidytable(col1 = 1, col2 = 2)

# Or can be used in the middle of a pipe chain (object is unaltered)
df %&gt;%
  filter(col1 &lt; 2, col2 &lt; 4) %&gt;%
  inv_gc() %&gt;%
  select(col1)
</code></pre>

<hr>
<h2 id='is_grouped_df'>Check if the tidytable is grouped</h2><span id='topic+is_grouped_df'></span>

<h3>Description</h3>

<p>Check if the tidytable is grouped
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_grouped_df(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_grouped_df_+3A_x">x</code></td>
<td>
<p>An object</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>df &lt;- data.table(
  a = 1:3,
  b = c("a", "a", "b")
)

df %&gt;%
  group_by(b) %&gt;%
  is_grouped_df()
</code></pre>

<hr>
<h2 id='is_tidytable'>Test if the object is a tidytable</h2><span id='topic+is_tidytable'></span>

<h3>Description</h3>

<p>This function returns TRUE for tidytables or subclasses of tidytables, and FALSE for all other objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_tidytable(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_tidytable_+3A_x">x</code></td>
<td>
<p>An object</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>df &lt;- data.frame(x = 1:3, y = 1:3)

is_tidytable(df)

df &lt;- tidytable(x = 1:3, y = 1:3)

is_tidytable(df)
</code></pre>

<hr>
<h2 id='lag'>Get lagging or leading values</h2><span id='topic+lag'></span><span id='topic+lead'></span>

<h3>Description</h3>

<p>Find the &quot;previous&quot; or &quot;next&quot; values in a vector.
Useful for comparing values behind or ahead of the current values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lag(x, n = 1L, default = NA)

lead(x, n = 1L, default = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lag_+3A_x">x</code></td>
<td>
<p>a vector of values</p>
</td></tr>
<tr><td><code id="lag_+3A_n">n</code></td>
<td>
<p>a positive integer of length 1, giving the number of positions to lead or lag by</p>
</td></tr>
<tr><td><code id="lag_+3A_default">default</code></td>
<td>
<p>value used for non-existent rows. Defaults to NA.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- 1:5

lag(x, 1)
lead(x, 1)

# Also works inside of `mutate()`
df &lt;- tidytable(x = 1:5)

df %&gt;%
  mutate(lag_x = lag(x))

</code></pre>

<hr>
<h2 id='left_join'>Join two data.tables together</h2><span id='topic+left_join'></span><span id='topic+right_join'></span><span id='topic+inner_join'></span><span id='topic+full_join'></span><span id='topic+anti_join'></span><span id='topic+semi_join'></span>

<h3>Description</h3>

<p>Join two data.tables together
</p>


<h3>Usage</h3>

<pre><code class='language-R'>left_join(x, y, by = NULL, suffix = c(".x", ".y"), ..., keep = FALSE)

right_join(x, y, by = NULL, suffix = c(".x", ".y"), ..., keep = FALSE)

inner_join(x, y, by = NULL, suffix = c(".x", ".y"), ..., keep = FALSE)

full_join(x, y, by = NULL, suffix = c(".x", ".y"), ..., keep = FALSE)

anti_join(x, y, by = NULL)

semi_join(x, y, by = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="left_join_+3A_x">x</code></td>
<td>
<p>A data.frame or data.table</p>
</td></tr>
<tr><td><code id="left_join_+3A_y">y</code></td>
<td>
<p>A data.frame or data.table</p>
</td></tr>
<tr><td><code id="left_join_+3A_by">by</code></td>
<td>
<p>A character vector of variables to join by. If NULL, the default, the join will do a natural join, using all variables with common names across the two tables.</p>
</td></tr>
<tr><td><code id="left_join_+3A_suffix">suffix</code></td>
<td>
<p>Append created for duplicated column names when using <code>full_join()</code></p>
</td></tr>
<tr><td><code id="left_join_+3A_...">...</code></td>
<td>
<p>Other parameters passed on to methods</p>
</td></tr>
<tr><td><code id="left_join_+3A_keep">keep</code></td>
<td>
<p>Should the join keys from both <code>x</code> and <code>y</code> be preserved in the output?</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>df1 &lt;- data.table(x = c("a", "a", "b", "c"), y = 1:4)
df2 &lt;- data.table(x = c("a", "b"), z = 5:6)

df1 %&gt;% left_join(df2)
df1 %&gt;% inner_join(df2)
df1 %&gt;% right_join(df2)
df1 %&gt;% full_join(df2)
df1 %&gt;% anti_join(df2)
</code></pre>

<hr>
<h2 id='map'>Apply a function to each element of a vector or list</h2><span id='topic+map'></span><span id='topic+map_lgl'></span><span id='topic+map_int'></span><span id='topic+map_dbl'></span><span id='topic+map_chr'></span><span id='topic+map_dfc'></span><span id='topic+map_dfr'></span><span id='topic+map_df'></span><span id='topic+walk'></span><span id='topic+map_vec'></span><span id='topic+map2'></span><span id='topic+map2_lgl'></span><span id='topic+map2_int'></span><span id='topic+map2_dbl'></span><span id='topic+map2_chr'></span><span id='topic+map2_dfc'></span><span id='topic+map2_dfr'></span><span id='topic+map2_df'></span><span id='topic+map2_vec'></span><span id='topic+pmap'></span><span id='topic+pmap_lgl'></span><span id='topic+pmap_int'></span><span id='topic+pmap_dbl'></span><span id='topic+pmap_chr'></span><span id='topic+pmap_dfc'></span><span id='topic+pmap_dfr'></span><span id='topic+pmap_df'></span><span id='topic+pmap_vec'></span>

<h3>Description</h3>

<p>The map functions transform their input by applying a function to each element and returning
a list/vector/data.table.
</p>

<ul>
<li> <p><code>map()</code> returns a list
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;_lgl()&#8288;</code>, <code style="white-space: pre;">&#8288;_int&#8288;</code>, <code style="white-space: pre;">&#8288;_dbl&#8288;</code>,<code style="white-space: pre;">&#8288;_chr&#8288;</code>, <code style="white-space: pre;">&#8288;_df&#8288;</code> variants return their specified type
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;_dfr&#8288;</code> &amp; <code style="white-space: pre;">&#8288;_dfc&#8288;</code> Return all data frame results combined utilizing row or column binding
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>map(.x, .f, ...)

map_lgl(.x, .f, ...)

map_int(.x, .f, ...)

map_dbl(.x, .f, ...)

map_chr(.x, .f, ...)

map_dfc(.x, .f, ...)

map_dfr(.x, .f, ..., .id = NULL)

map_df(.x, .f, ..., .id = NULL)

walk(.x, .f, ...)

map_vec(.x, .f, ..., .ptype = NULL)

map2(.x, .y, .f, ...)

map2_lgl(.x, .y, .f, ...)

map2_int(.x, .y, .f, ...)

map2_dbl(.x, .y, .f, ...)

map2_chr(.x, .y, .f, ...)

map2_dfc(.x, .y, .f, ...)

map2_dfr(.x, .y, .f, ..., .id = NULL)

map2_df(.x, .y, .f, ..., .id = NULL)

map2_vec(.x, .y, .f, ..., .ptype = NULL)

pmap(.l, .f, ...)

pmap_lgl(.l, .f, ...)

pmap_int(.l, .f, ...)

pmap_dbl(.l, .f, ...)

pmap_chr(.l, .f, ...)

pmap_dfc(.l, .f, ...)

pmap_dfr(.l, .f, ..., .id = NULL)

pmap_df(.l, .f, ..., .id = NULL)

pmap_vec(.l, .f, ..., .ptype = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="map_+3A_.x">.x</code></td>
<td>
<p>A list or vector</p>
</td></tr>
<tr><td><code id="map_+3A_.f">.f</code></td>
<td>
<p>A function</p>
</td></tr>
<tr><td><code id="map_+3A_...">...</code></td>
<td>
<p>Other arguments to pass to a function</p>
</td></tr>
<tr><td><code id="map_+3A_.id">.id</code></td>
<td>
<p>Whether <code>map_dfr()</code> should add an id column to the finished dataset</p>
</td></tr>
<tr><td><code id="map_+3A_.ptype">.ptype</code></td>
<td>
<p>ptype for resulting vector in <code>map_vec()</code></p>
</td></tr>
<tr><td><code id="map_+3A_.y">.y</code></td>
<td>
<p>A list or vector</p>
</td></tr>
<tr><td><code id="map_+3A_.l">.l</code></td>
<td>
<p>A list to use in <code>pmap</code></p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>map(c(1,2,3), ~ .x + 1)

map_dbl(c(1,2,3), ~ .x + 1)

map_chr(c(1,2,3), as.character)
</code></pre>

<hr>
<h2 id='mutate'>Add/modify/delete columns</h2><span id='topic+mutate'></span>

<h3>Description</h3>

<p>With <code>mutate()</code> you can do 3 things:
</p>

<ul>
<li><p> Add new columns
</p>
</li>
<li><p> Modify existing columns
</p>
</li>
<li><p> Delete columns
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>mutate(
  .df,
  ...,
  .by = NULL,
  .keep = c("all", "used", "unused", "none"),
  .before = NULL,
  .after = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mutate_+3A_.df">.df</code></td>
<td>
<p>A data.frame or data.table</p>
</td></tr>
<tr><td><code id="mutate_+3A_...">...</code></td>
<td>
<p>Columns to add/modify</p>
</td></tr>
<tr><td><code id="mutate_+3A_.by">.by</code></td>
<td>
<p>Columns to group by</p>
</td></tr>
<tr><td><code id="mutate_+3A_.keep">.keep</code></td>
<td>
<p><em>experimental</em>:
This is an experimental argument that allows you to control which columns
from <code>.df</code> are retained in the output:
</p>

<ul>
<li> <p><code>"all"</code>, the default, retains all variables.
</p>
</li>
<li> <p><code>"used"</code> keeps any variables used to make new variables; it's useful
for checking your work as it displays inputs and outputs side-by-side.
</p>
</li>
<li> <p><code>"unused"</code> keeps only existing variables <strong>not</strong> used to make new
variables.
</p>
</li>
<li> <p><code>"none"</code>, only keeps grouping keys (like <code><a href="#topic+transmute">transmute()</a></code>).
</p>
</li></ul>
</td></tr>
<tr><td><code id="mutate_+3A_.before">.before</code>, <code id="mutate_+3A_.after">.after</code></td>
<td>
<p>Optionally indicate where new columns should be placed.
Defaults to the right side of the data frame.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>df &lt;- data.table(
  a = 1:3,
  b = 4:6,
  c = c("a", "a", "b")
)

df %&gt;%
  mutate(double_a = a * 2,
         a_plus_b = a + b)

df %&gt;%
  mutate(double_a = a * 2,
         avg_a = mean(a),
         .by = c)

df %&gt;%
  mutate(double_a = a * 2, .keep = "used")

df %&gt;%
  mutate(double_a = a * 2, .after = a)
</code></pre>

<hr>
<h2 id='mutate_rowwise'>Add/modify columns by row</h2><span id='topic+mutate_rowwise'></span>

<h3>Description</h3>

<p>Allows you to mutate &quot;by row&quot;. this is most useful when a vectorized function doesn't exist.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mutate_rowwise(
  .df,
  ...,
  .keep = c("all", "used", "unused", "none"),
  .before = NULL,
  .after = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mutate_rowwise_+3A_.df">.df</code></td>
<td>
<p>A data.table or data.frame</p>
</td></tr>
<tr><td><code id="mutate_rowwise_+3A_...">...</code></td>
<td>
<p>Columns to add/modify</p>
</td></tr>
<tr><td><code id="mutate_rowwise_+3A_.keep">.keep</code></td>
<td>
<p><em>experimental</em>:
This is an experimental argument that allows you to control which columns
from <code>.df</code> are retained in the output:
</p>

<ul>
<li> <p><code>"all"</code>, the default, retains all variables.
</p>
</li>
<li> <p><code>"used"</code> keeps any variables used to make new variables; it's useful
for checking your work as it displays inputs and outputs side-by-side.
</p>
</li>
<li> <p><code>"unused"</code> keeps only existing variables <em><strong>not</strong></em> used to make new
variables.
</p>
</li>
<li> <p><code>"none"</code>, only keeps grouping keys (like <code><a href="#topic+transmute">transmute()</a></code>).
</p>
</li></ul>
</td></tr>
<tr><td><code id="mutate_rowwise_+3A_.before">.before</code>, <code id="mutate_rowwise_+3A_.after">.after</code></td>
<td>
<p>Optionally indicate where new columns should be placed.
Defaults to the right side of the data frame.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>df &lt;- data.table(x = 1:3, y = 1:3 * 2, z = 1:3 * 3)

# Compute the mean of x, y, z in each row
df %&gt;%
  mutate_rowwise(row_mean = mean(c(x, y, z)))

# Use c_across() to more easily select many variables
df %&gt;%
  mutate_rowwise(row_mean = mean(c_across(x:z)))
</code></pre>

<hr>
<h2 id='n'>Number of observations in each group</h2><span id='topic+n'></span>

<h3>Description</h3>

<p>Helper function that can be used to find counts by group.
</p>
<p>Can be used inside <code>summarize()</code>, <code>mutate()</code>, &amp; <code>filter()</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>n()
</code></pre>


<h3>Examples</h3>

<pre><code class='language-R'>df &lt;- data.table(
  x = 1:3,
  y = 4:6,
  z = c("a","a","b")
 )

df %&gt;%
  summarize(count = n(), .by = z)
</code></pre>

<hr>
<h2 id='n_distinct'>Count the number of unique values in a vector</h2><span id='topic+n_distinct'></span>

<h3>Description</h3>

<p>This is a faster version of <code>length(unique(x))</code> that calls <code>data.table::uniqueN()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>n_distinct(..., na.rm = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="n_distinct_+3A_...">...</code></td>
<td>
<p>vectors of values</p>
</td></tr>
<tr><td><code id="n_distinct_+3A_na.rm">na.rm</code></td>
<td>
<p>If <code>TRUE</code> missing values don't count</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- sample(1:10, 1e5, rep = TRUE)
n_distinct(x)
</code></pre>

<hr>
<h2 id='na_if'>Convert values to <code>NA</code></h2><span id='topic+na_if'></span>

<h3>Description</h3>

<p>Convert values to <code>NA</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>na_if(x, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="na_if_+3A_x">x</code></td>
<td>
<p>A vector</p>
</td></tr>
<tr><td><code id="na_if_+3A_y">y</code></td>
<td>
<p>Value to replace with <code>NA</code></p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>vec &lt;- 1:3
na_if(vec, 3)
</code></pre>

<hr>
<h2 id='nest'>Nest columns into a list-column</h2><span id='topic+nest'></span>

<h3>Description</h3>

<p>Nest columns into a list-column
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nest(.df, ..., .by = NULL, .key = NULL, .names_sep = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nest_+3A_.df">.df</code></td>
<td>
<p>A data.table or data.frame</p>
</td></tr>
<tr><td><code id="nest_+3A_...">...</code></td>
<td>
<p>Columns to be nested.</p>
</td></tr>
<tr><td><code id="nest_+3A_.by">.by</code></td>
<td>
<p>Columns to nest by</p>
</td></tr>
<tr><td><code id="nest_+3A_.key">.key</code></td>
<td>
<p>New column name if <code>.by</code> is used</p>
</td></tr>
<tr><td><code id="nest_+3A_.names_sep">.names_sep</code></td>
<td>
<p>If NULL, the names will be left alone. If a string,
the names of the columns will be created by pasting together the inner
column names and the outer column names.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>df &lt;- data.table(
  a = 1:3,
  b = 1:3,
  c = c("a", "a", "b"),
  d = c("a", "a", "b")
)

df %&gt;%
  nest(data = c(a, b))

df %&gt;%
  nest(data = where(is.numeric))

df %&gt;%
  nest(.by = c(c, d))
</code></pre>

<hr>
<h2 id='nest_by'>Nest data.tables</h2><span id='topic+nest_by'></span>

<h3>Description</h3>

<p>Nest data.tables by group.
</p>
<p>Note: <code>nest_by()</code> <em>does not</em> return a rowwise tidytable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nest_by(.df, ..., .key = "data", .keep = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nest_by_+3A_.df">.df</code></td>
<td>
<p>A data.frame or data.table</p>
</td></tr>
<tr><td><code id="nest_by_+3A_...">...</code></td>
<td>
<p>Columns to group by. If empty nests the entire data.table.
<code>tidyselect</code> compatible.</p>
</td></tr>
<tr><td><code id="nest_by_+3A_.key">.key</code></td>
<td>
<p>Name of the new column created by nesting.</p>
</td></tr>
<tr><td><code id="nest_by_+3A_.keep">.keep</code></td>
<td>
<p>Should the grouping columns be kept in the list column.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>df &lt;- data.table(
  a = 1:5,
  b = 6:10,
  c = c(rep("a", 3), rep("b", 2)),
  d = c(rep("a", 3), rep("b", 2))
)

df %&gt;%
  nest_by()

df %&gt;%
  nest_by(c, d)

df %&gt;%
  nest_by(where(is.character))

df %&gt;%
  nest_by(c, d, .keep = TRUE)
</code></pre>

<hr>
<h2 id='nest_join'>Nest join</h2><span id='topic+nest_join'></span>

<h3>Description</h3>

<p>Join the data from y as a list column onto x.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nest_join(x, y, by = NULL, keep = FALSE, name = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nest_join_+3A_x">x</code></td>
<td>
<p>A data.frame or data.table</p>
</td></tr>
<tr><td><code id="nest_join_+3A_y">y</code></td>
<td>
<p>A data.frame or data.table</p>
</td></tr>
<tr><td><code id="nest_join_+3A_by">by</code></td>
<td>
<p>A character vector of variables to join by. If NULL, the default, the join will do a natural join, using all variables with common names across the two tables.</p>
</td></tr>
<tr><td><code id="nest_join_+3A_keep">keep</code></td>
<td>
<p>Should the join keys from both <code>x</code> and <code>y</code> be preserved in the output?</p>
</td></tr>
<tr><td><code id="nest_join_+3A_name">name</code></td>
<td>
<p>The name of the list-column created by the join. If <code>NULL</code> the name of <code>y</code> is used.</p>
</td></tr>
<tr><td><code id="nest_join_+3A_...">...</code></td>
<td>
<p>Other parameters passed on to methods</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>df1 &lt;- tidytable(x = 1:3)
df2 &lt;- tidytable(x = c(2, 3, 3), y = c("a", "b", "c"))

out &lt;- nest_join(df1, df2)
out
out$df2
</code></pre>

<hr>
<h2 id='new_tidytable'>Create a tidytable from a list</h2><span id='topic+new_tidytable'></span>

<h3>Description</h3>

<p>Create a tidytable from a list
</p>


<h3>Usage</h3>

<pre><code class='language-R'>new_tidytable(x = list())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="new_tidytable_+3A_x">x</code></td>
<td>
<p>A named list of equal-length vectors. The lengths are not checked; it is the responsibility
of the caller to make sure they are equal.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>l &lt;- list(x = 1:3, y = c("a", "a", "b"))

new_tidytable(l)
</code></pre>

<hr>
<h2 id='pick'>Selection version of <code>across()</code></h2><span id='topic+pick'></span>

<h3>Description</h3>

<p>Select a subset of columns from within functions like <code>mutate()</code>, <code>summarize()</code>, or <code>filter()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pick(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pick_+3A_...">...</code></td>
<td>
<p>Columns to select. Tidyselect compatible.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>df &lt;- tidytable(
  x = 1:3,
  y = 4:6,
  z = c("a", "a", "b")
)

df %&gt;%
  mutate(row_sum = rowSums(pick(x, y)))
</code></pre>

<hr>
<h2 id='pivot_longer'>Pivot data from wide to long</h2><span id='topic+pivot_longer'></span>

<h3>Description</h3>

<p><code>pivot_longer()</code> &quot;lengthens&quot; the data, increasing the number of rows and decreasing
the number of columns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pivot_longer(
  .df,
  cols = everything(),
  names_to = "name",
  values_to = "value",
  names_prefix = NULL,
  names_sep = NULL,
  names_pattern = NULL,
  names_ptypes = NULL,
  names_transform = NULL,
  names_repair = "check_unique",
  values_drop_na = FALSE,
  values_ptypes = NULL,
  values_transform = NULL,
  fast_pivot = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pivot_longer_+3A_.df">.df</code></td>
<td>
<p>A data.table or data.frame</p>
</td></tr>
<tr><td><code id="pivot_longer_+3A_cols">cols</code></td>
<td>
<p>Columns to pivot. <code>tidyselect</code> compatible.</p>
</td></tr>
<tr><td><code id="pivot_longer_+3A_names_to">names_to</code></td>
<td>
<p>Name of the new &quot;names&quot; column. Must be a string.</p>
</td></tr>
<tr><td><code id="pivot_longer_+3A_values_to">values_to</code></td>
<td>
<p>Name of the new &quot;values&quot; column. Must be a string.</p>
</td></tr>
<tr><td><code id="pivot_longer_+3A_names_prefix">names_prefix</code></td>
<td>
<p>Remove matching text from the start of selected columns using regex.</p>
</td></tr>
<tr><td><code id="pivot_longer_+3A_names_sep">names_sep</code></td>
<td>
<p>If <code>names_to</code> contains multiple values, <code>names_sep</code> takes
the same specification as <code>separate()</code>.</p>
</td></tr>
<tr><td><code id="pivot_longer_+3A_names_pattern">names_pattern</code></td>
<td>
<p>If <code>names_to</code> contains multiple values, <code>names_pattern</code> takes
the same specification as <code>extract()</code>, a regular expression containing matching groups.</p>
</td></tr>
<tr><td><code id="pivot_longer_+3A_names_ptypes">names_ptypes</code>, <code id="pivot_longer_+3A_values_ptypes">values_ptypes</code></td>
<td>
<p>A list of column name-prototype pairs. See &ldquo;?vctrs::'theory-faq-coercion&ldquo;'
for more info on vctrs coercion.</p>
</td></tr>
<tr><td><code id="pivot_longer_+3A_names_transform">names_transform</code>, <code id="pivot_longer_+3A_values_transform">values_transform</code></td>
<td>
<p>A list of column name-function pairs. Use these arguments
if you need to change the types of specific columns.</p>
</td></tr>
<tr><td><code id="pivot_longer_+3A_names_repair">names_repair</code></td>
<td>
<p>Treatment of duplicate names. See <code>?vctrs::vec_as_names</code> for options/details.</p>
</td></tr>
<tr><td><code id="pivot_longer_+3A_values_drop_na">values_drop_na</code></td>
<td>
<p>If TRUE, rows will be dropped that contain NAs.</p>
</td></tr>
<tr><td><code id="pivot_longer_+3A_fast_pivot">fast_pivot</code></td>
<td>
<p><em>experimental</em>: Fast pivoting. If <code>TRUE</code>, the <code>names_to</code> column will be returned as a <code>factor</code>,
otherwise it will be a <code>character</code> column. Defaults to <code>FALSE</code> to match tidyverse semantics.</p>
</td></tr>
<tr><td><code id="pivot_longer_+3A_...">...</code></td>
<td>
<p>Additional arguments to passed on to methods.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>df &lt;- data.table(
  x = 1:3,
  y = 4:6,
  z = c("a", "b", "c")
)

df %&gt;%
  pivot_longer(cols = c(x, y))

df %&gt;%
  pivot_longer(cols = -z, names_to = "stuff", values_to = "things")
</code></pre>

<hr>
<h2 id='pivot_wider'>Pivot data from long to wide</h2><span id='topic+pivot_wider'></span>

<h3>Description</h3>

<p>&quot;Widens&quot; data, increasing the number of columns and
decreasing the number of rows.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pivot_wider(
  .df,
  names_from = name,
  values_from = value,
  id_cols = NULL,
  names_sep = "_",
  names_prefix = "",
  names_glue = NULL,
  names_sort = FALSE,
  names_repair = "unique",
  values_fill = NULL,
  values_fn = NULL,
  unused_fn = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pivot_wider_+3A_.df">.df</code></td>
<td>
<p>A data.frame or data.table</p>
</td></tr>
<tr><td><code id="pivot_wider_+3A_names_from">names_from</code></td>
<td>
<p>A pair of arguments describing which column (or columns) to get the name of the output column <code>name_from</code>,
and which column (or columns) to get the cell values from <code>values_from</code>).
<code>tidyselect</code> compatible.</p>
</td></tr>
<tr><td><code id="pivot_wider_+3A_values_from">values_from</code></td>
<td>
<p>A pair of arguments describing which column (or columns) to get the name of the output column <code>name_from</code>,
and which column (or columns) to get the cell values from <code>values_from</code>.
<code>tidyselect</code> compatible.</p>
</td></tr>
<tr><td><code id="pivot_wider_+3A_id_cols">id_cols</code></td>
<td>
<p>A set of columns that uniquely identifies each observation.
Defaults to all columns in the data table except for the columns specified in <code>names_from</code> and <code>values_from</code>.
Typically used when you have additional variables that is directly related.
<code>tidyselect</code> compatible.</p>
</td></tr>
<tr><td><code id="pivot_wider_+3A_names_sep">names_sep</code></td>
<td>
<p>the separator between the names of the columns</p>
</td></tr>
<tr><td><code id="pivot_wider_+3A_names_prefix">names_prefix</code></td>
<td>
<p>prefix to add to the names of the new columns</p>
</td></tr>
<tr><td><code id="pivot_wider_+3A_names_glue">names_glue</code></td>
<td>
<p>Instead of using <code>names_sep</code> and <code>names_prefix</code>, you can supply a
glue specification that uses the <code>names_from</code> columns (and special <code>.value</code>) to create custom column names</p>
</td></tr>
<tr><td><code id="pivot_wider_+3A_names_sort">names_sort</code></td>
<td>
<p>Should the resulting new columns be sorted.</p>
</td></tr>
<tr><td><code id="pivot_wider_+3A_names_repair">names_repair</code></td>
<td>
<p>Treatment of duplicate names. See <code>?vctrs::vec_as_names</code> for options/details.</p>
</td></tr>
<tr><td><code id="pivot_wider_+3A_values_fill">values_fill</code></td>
<td>
<p>If values are missing, what value should be filled in</p>
</td></tr>
<tr><td><code id="pivot_wider_+3A_values_fn">values_fn</code></td>
<td>
<p>Should the data be aggregated before casting? If the formula doesn't identify a single observation for each cell, then aggregation defaults to length with a message.</p>
</td></tr>
<tr><td><code id="pivot_wider_+3A_unused_fn">unused_fn</code></td>
<td>
<p>Aggregation function to be applied to unused columns.
Default is to ignore unused columns.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>df &lt;- tidytable(
  id = 1,
  names = c("a", "b", "c"),
  vals = 1:3
)

df %&gt;%
  pivot_wider(names_from = names, values_from = vals)

df %&gt;%
  pivot_wider(
    names_from = names, values_from = vals, names_prefix = "new_"
  )
</code></pre>

<hr>
<h2 id='pull'>Pull out a single variable</h2><span id='topic+pull'></span>

<h3>Description</h3>

<p>Pull a single variable from a data.table as a vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pull(.df, var = -1, name = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pull_+3A_.df">.df</code></td>
<td>
<p>A data.frame or data.table</p>
</td></tr>
<tr><td><code id="pull_+3A_var">var</code></td>
<td>
<p>The column to pull from the data.table as:
</p>

<ul>
<li><p> a variable name
</p>
</li>
<li><p> a positive integer giving the column position
</p>
</li>
<li><p> a negative integer giving the column position counting from the right
</p>
</li></ul>
</td></tr>
<tr><td><code id="pull_+3A_name">name</code></td>
<td>
<p>Optional - specifies the column to be used as names for the vector.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>df &lt;- data.table(
  x = 1:3,
  y = 1:3
)

# Grab column by name
df %&gt;%
  pull(y)

# Grab column by position
df %&gt;%
  pull(1)

# Defaults to last column
df %&gt;%
  pull()
</code></pre>

<hr>
<h2 id='recode'>Recode values</h2><span id='topic+recode'></span>

<h3>Description</h3>

<p><em>superseded</em>
</p>
<p><code>recode()</code> has been superseded by <code>case_match()</code>.
</p>
<p>Replace old values of a vector with new values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>recode(.x, ..., .default = NULL, .missing = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="recode_+3A_.x">.x</code></td>
<td>
<p>A vector</p>
</td></tr>
<tr><td><code id="recode_+3A_...">...</code></td>
<td>
<p>A series of <code>old = new</code> pairs specifying the new values</p>
</td></tr>
<tr><td><code id="recode_+3A_.default">.default</code></td>
<td>
<p>The default value if all conditions evaluate to <code>FALSE</code></p>
</td></tr>
<tr><td><code id="recode_+3A_.missing">.missing</code></td>
<td>
<p>What missing values should be replaced with</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>char_vec &lt;- c("a", "b", "c")
recode(char_vec, a = "Apple", b = "Banana")

num_vec &lt;- 1:3
recode(num_vec, `1` = 10, `2` = 25, .default = 100)
</code></pre>

<hr>
<h2 id='reexports'>Objects exported from other packages</h2><span id='topic+reexports'></span><span id='topic+starts_with'></span><span id='topic+contains'></span><span id='topic+ends_with'></span><span id='topic+everything'></span><span id='topic+any_of'></span><span id='topic+all_of'></span><span id='topic+matches'></span><span id='topic+num_range'></span><span id='topic+last_col'></span><span id='topic+where'></span><span id='topic+data.table'></span><span id='topic+fwrite'></span><span id='topic+getDTthreads'></span><span id='topic+setDTthreads'></span><span id='topic++between+'></span><span id='topic++25like+25'></span><span id='topic++25chin+25'></span><span id='topic+enexpr'></span><span id='topic+enexprs'></span><span id='topic+enquo'></span><span id='topic+enquos'></span><span id='topic+expr'></span><span id='topic+exprs'></span><span id='topic+quo'></span><span id='topic+quos'></span><span id='topic+sym'></span><span id='topic+syms'></span><span id='topic+glimpse'></span>

<h3>Description</h3>

<p>These objects are imported from other packages. Follow the links
below to see their documentation.
</p>

<dl>
<dt>data.table</dt><dd><p><code><a href="data.table.html#topic+between">%between%</a></code>, <code><a href="data.table.html#topic+chmatch">%chin%</a></code>, <code><a href="data.table.html#topic+like">%like%</a></code>, <code><a href="data.table.html#topic+data.table">data.table</a></code>, <code><a href="data.table.html#topic+fwrite">fwrite</a></code>, <code><a href="data.table.html#topic+openmp-utils">getDTthreads</a></code>, <code><a href="data.table.html#topic+openmp-utils">setDTthreads</a></code></p>
</dd>
<dt>pillar</dt><dd><p><code><a href="pillar.html#topic+glimpse">glimpse</a></code></p>
</dd>
<dt>rlang</dt><dd><p><code><a href="rlang.html#topic+defusing-advanced">enexpr</a></code>, <code><a href="rlang.html#topic+defusing-advanced">enexprs</a></code>, <code><a href="rlang.html#topic+enquo">enquo</a></code>, <code><a href="rlang.html#topic+enquo">enquos</a></code>, <code><a href="rlang.html#topic+expr">expr</a></code>, <code><a href="rlang.html#topic+defusing-advanced">exprs</a></code>, <code><a href="rlang.html#topic+defusing-advanced">quo</a></code>, <code><a href="rlang.html#topic+defusing-advanced">quos</a></code>, <code><a href="rlang.html#topic+sym">sym</a></code>, <code><a href="rlang.html#topic+sym">syms</a></code></p>
</dd>
<dt>tidyselect</dt><dd><p><code><a href="tidyselect.html#topic+all_of">all_of</a></code>, <code><a href="tidyselect.html#topic+all_of">any_of</a></code>, <code><a href="tidyselect.html#topic+starts_with">contains</a></code>, <code><a href="tidyselect.html#topic+starts_with">ends_with</a></code>, <code><a href="tidyselect.html#topic+everything">everything</a></code>, <code><a href="tidyselect.html#topic+everything">last_col</a></code>, <code><a href="tidyselect.html#topic+starts_with">matches</a></code>, <code><a href="tidyselect.html#topic+starts_with">num_range</a></code>, <code><a href="tidyselect.html#topic+starts_with">starts_with</a></code>, <code><a href="tidyselect.html#topic+where">where</a></code></p>
</dd>
</dl>

<hr>
<h2 id='reframe'>Reframe a data frame</h2><span id='topic+reframe'></span>

<h3>Description</h3>

<p>Reframe a data frame. Note this is a simple alias for <code>summarize()</code>
that always returns an ungrouped tidytable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reframe(.df, ..., .by = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reframe_+3A_.df">.df</code></td>
<td>
<p>A data.frame or data.table</p>
</td></tr>
<tr><td><code id="reframe_+3A_...">...</code></td>
<td>
<p>Aggregations to perform</p>
</td></tr>
<tr><td><code id="reframe_+3A_.by">.by</code></td>
<td>
<p>Columns to group by</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>mtcars %&gt;%
  reframe(qs = quantile(disp, c(0.25, 0.75)),
          prob = c(0.25, 0.75),
          .by = cyl)
</code></pre>

<hr>
<h2 id='relocate'>Relocate a column to a new position</h2><span id='topic+relocate'></span>

<h3>Description</h3>

<p>Move a column or columns to a new position
</p>


<h3>Usage</h3>

<pre><code class='language-R'>relocate(.df, ..., .before = NULL, .after = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="relocate_+3A_.df">.df</code></td>
<td>
<p>A data.frame or data.table</p>
</td></tr>
<tr><td><code id="relocate_+3A_...">...</code></td>
<td>
<p>A selection of columns to move. <code>tidyselect</code> compatible.</p>
</td></tr>
<tr><td><code id="relocate_+3A_.before">.before</code></td>
<td>
<p>Column to move selection before</p>
</td></tr>
<tr><td><code id="relocate_+3A_.after">.after</code></td>
<td>
<p>Column to move selection after</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>df &lt;- data.table(
  a = 1:3,
  b = 1:3,
  c = c("a", "a", "b"),
  d = c("a", "a", "b")
)

df %&gt;%
  relocate(c, .before = b)

df %&gt;%
  relocate(a, b, .after = c)

df %&gt;%
  relocate(where(is.numeric), .after = c)
</code></pre>

<hr>
<h2 id='rename'>Rename variables by name</h2><span id='topic+rename'></span>

<h3>Description</h3>

<p>Rename variables from a data.table.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rename(.df, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rename_+3A_.df">.df</code></td>
<td>
<p>A data.frame or data.table</p>
</td></tr>
<tr><td><code id="rename_+3A_...">...</code></td>
<td>
<p><code>new_name = old_name</code> pairs to rename columns</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>df &lt;- data.table(x = 1:3, y = 4:6)

df %&gt;%
  rename(new_x = x,
         new_y = y)
</code></pre>

<hr>
<h2 id='rename_with'>Rename multiple columns</h2><span id='topic+rename_with'></span>

<h3>Description</h3>

<p>Rename multiple columns with the same transformation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rename_with(.df, .fn = NULL, .cols = everything(), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rename_with_+3A_.df">.df</code></td>
<td>
<p>A data.table or data.frame</p>
</td></tr>
<tr><td><code id="rename_with_+3A_.fn">.fn</code></td>
<td>
<p>Function to transform the names with.</p>
</td></tr>
<tr><td><code id="rename_with_+3A_.cols">.cols</code></td>
<td>
<p>Columns to rename. Defaults to all columns. <code>tidyselect</code> compatible.</p>
</td></tr>
<tr><td><code id="rename_with_+3A_...">...</code></td>
<td>
<p>Other parameters to pass to the function</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>df &lt;- data.table(
  x = 1,
  y = 2,
  double_x = 2,
  double_y = 4
)

df %&gt;%
  rename_with(toupper)

df %&gt;%
  rename_with(~ toupper(.x))

df %&gt;%
  rename_with(~ toupper(.x), .cols = c(x, double_x))
</code></pre>

<hr>
<h2 id='replace_na'>Replace missing values</h2><span id='topic+replace_na'></span>

<h3>Description</h3>

<p>Replace NAs with specified values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>replace_na(.x, replace)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="replace_na_+3A_.x">.x</code></td>
<td>
<p>A data.frame/data.table or a vector</p>
</td></tr>
<tr><td><code id="replace_na_+3A_replace">replace</code></td>
<td>
<p>If <code>.x</code> is a data frame, a <code>list()</code> of replacement values for specified columns.
If <code>.x</code> is a vector, a single replacement value.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>df &lt;- data.table(
  x = c(1, 2, NA),
  y = c(NA, 1, 2)
)

# Using replace_na() inside mutate()
df %&gt;%
  mutate(x = replace_na(x, 5))

# Using replace_na() on a data frame
df %&gt;%
  replace_na(list(x = 5, y = 0))
</code></pre>

<hr>
<h2 id='row_number'>Ranking functions</h2><span id='topic+row_number'></span><span id='topic+min_rank'></span><span id='topic+dense_rank'></span><span id='topic+percent_rank'></span><span id='topic+cume_dist'></span>

<h3>Description</h3>

<p>Ranking functions:
</p>

<ul>
<li> <p><code>row_number()</code>: Gives other row number if empty.
Equivalent to <code>frank(ties.method = "first")</code> if provided a vector.
</p>
</li>
<li> <p><code>min_rank()</code>: Equivalent to <code>frank(ties.method = "min")</code>
</p>
</li>
<li> <p><code>dense_rank()</code>: Equivalent to <code>frank(ties.method = "dense")</code>
</p>
</li>
<li> <p><code>percent_rank()</code>: Ranks by percentage from 0 to 1
</p>
</li>
<li> <p><code>cume_dist()</code>: Cumulative distribution
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>row_number(x)

min_rank(x)

dense_rank(x)

percent_rank(x)

cume_dist(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="row_number_+3A_x">x</code></td>
<td>
<p>A vector to rank</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>df &lt;- data.table(x = rep(1, 3), y = c("a", "a", "b"))

df %&gt;%
  mutate(row = row_number())
</code></pre>

<hr>
<h2 id='rowwise'>Convert to a rowwise tidytable</h2><span id='topic+rowwise'></span>

<h3>Description</h3>

<p>Convert to a rowwise tidytable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rowwise(.df)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rowwise_+3A_.df">.df</code></td>
<td>
<p>A data.frame or data.table</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>df &lt;- tidytable(x = 1:3, y = 1:3 * 2, z = 1:3 * 3)

# Compute the mean of x, y, z in each row
df %&gt;%
  rowwise() %&gt;%
  mutate(row_mean = mean(c(x, y, z)))

# Use c_across() to more easily select many variables
df %&gt;%
  rowwise() %&gt;%
  mutate(row_mean = mean(c_across(x:z))) %&gt;%
  ungroup()
</code></pre>

<hr>
<h2 id='select'>Select or drop columns</h2><span id='topic+select'></span>

<h3>Description</h3>

<p>Select or drop columns from a data.table
</p>


<h3>Usage</h3>

<pre><code class='language-R'>select(.df, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="select_+3A_.df">.df</code></td>
<td>
<p>A data.frame or data.table</p>
</td></tr>
<tr><td><code id="select_+3A_...">...</code></td>
<td>
<p>Columns to select or drop.
Use named arguments, e.g. new_name = old_name, to rename selected variables.
<code>tidyselect</code> compatible.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>df &lt;- data.table(
  x1 = 1:3,
  x2 = 1:3,
  y = c("a", "b", "c"),
  z = c("a", "b", "c")
)

df %&gt;%
  select(x1, y)

df %&gt;%
  select(x1:y)

df %&gt;%
  select(-y, -z)

df %&gt;%
  select(starts_with("x"), z)

df %&gt;%
  select(where(is.character), x1)

df %&gt;%
  select(new = x1, y)
</code></pre>

<hr>
<h2 id='separate'>Separate a character column into multiple columns</h2><span id='topic+separate'></span>

<h3>Description</h3>

<p><em>Superseded</em>
</p>
<p><code>separate()</code> has been superseded by <code>separate_wider_delim()</code>.
</p>
<p>Separates a single column into multiple columns using a user supplied separator or regex.
</p>
<p>If a separator is not supplied one will be automatically detected.
</p>
<p>Note: Using automatic detection or regex will be slower than simple separators
such as &quot;,&quot; or &quot;.&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>separate(
  .df,
  col,
  into,
  sep = "[^[:alnum:]]+",
  remove = TRUE,
  convert = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="separate_+3A_.df">.df</code></td>
<td>
<p>A data frame</p>
</td></tr>
<tr><td><code id="separate_+3A_col">col</code></td>
<td>
<p>The column to split into multiple columns</p>
</td></tr>
<tr><td><code id="separate_+3A_into">into</code></td>
<td>
<p>New column names to split into. A character vector.
Use <code>NA</code> to omit the variable in the output.</p>
</td></tr>
<tr><td><code id="separate_+3A_sep">sep</code></td>
<td>
<p>Separator to split on. Can be specified or detected automatically</p>
</td></tr>
<tr><td><code id="separate_+3A_remove">remove</code></td>
<td>
<p>If TRUE, remove the input column from the output data.table</p>
</td></tr>
<tr><td><code id="separate_+3A_convert">convert</code></td>
<td>
<p>TRUE calls <code>type.convert()</code> with <code>as.is = TRUE</code> on new columns</p>
</td></tr>
<tr><td><code id="separate_+3A_...">...</code></td>
<td>
<p>Arguments passed on to methods</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>df &lt;- data.table(x = c("a", "a.b", "a.b", NA))

# "sep" can be automatically detected (slower)
df %&gt;%
  separate(x, into = c("c1", "c2"))

# Faster if "sep" is provided
df %&gt;%
  separate(x, into = c("c1", "c2"), sep = ".")
</code></pre>

<hr>
<h2 id='separate_longer_delim'>Split a string into rows</h2><span id='topic+separate_longer_delim'></span>

<h3>Description</h3>

<p>If a column contains observations with multiple delimited values, separate
them each into their own row.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>separate_longer_delim(.df, cols, delim, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="separate_longer_delim_+3A_.df">.df</code></td>
<td>
<p>A data.frame or data.table</p>
</td></tr>
<tr><td><code id="separate_longer_delim_+3A_cols">cols</code></td>
<td>
<p>Columns to separate</p>
</td></tr>
<tr><td><code id="separate_longer_delim_+3A_delim">delim</code></td>
<td>
<p>Separator delimiting collapsed values</p>
</td></tr>
<tr><td><code id="separate_longer_delim_+3A_...">...</code></td>
<td>
<p>These dots are for future extensions and must be empty.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>df &lt;- data.table(
  x = 1:3,
  y = c("a", "d,e,f", "g,h"),
  z = c("1", "2,3,4", "5,6")
)

df %&gt;%
  separate_longer_delim(c(y, z), ",")
</code></pre>

<hr>
<h2 id='separate_rows'>Separate a collapsed column into multiple rows</h2><span id='topic+separate_rows'></span>

<h3>Description</h3>

<p><em>Superseded</em>
</p>
<p><code>separate_rows()</code> has been superseded by <code>separate_longer_delim()</code>.
</p>
<p>If a column contains observations with multiple delimited values,
separate them each into their own row.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>separate_rows(.df, ..., sep = "[^[:alnum:].]+", convert = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="separate_rows_+3A_.df">.df</code></td>
<td>
<p>A data.frame or data.table</p>
</td></tr>
<tr><td><code id="separate_rows_+3A_...">...</code></td>
<td>
<p>Columns to separate across multiple rows. <code>tidyselect</code> compatible</p>
</td></tr>
<tr><td><code id="separate_rows_+3A_sep">sep</code></td>
<td>
<p>Separator delimiting collapsed values</p>
</td></tr>
<tr><td><code id="separate_rows_+3A_convert">convert</code></td>
<td>
<p>If TRUE, runs <code>type.convert()</code> on the resulting column.
Useful if the resulting column should be type integer/double.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>df &lt;- data.table(
  x = 1:3,
  y = c("a", "d,e,f", "g,h"),
  z = c("1", "2,3,4", "5,6")
)

separate_rows(df, y, z)

separate_rows(df, y, z, convert = TRUE)
</code></pre>

<hr>
<h2 id='separate_wider_delim'>Separate a character column into multiple columns</h2><span id='topic+separate_wider_delim'></span>

<h3>Description</h3>

<p>Separates a single column into multiple columns
</p>


<h3>Usage</h3>

<pre><code class='language-R'>separate_wider_delim(
  .df,
  cols,
  delim,
  ...,
  names = NULL,
  names_sep = NULL,
  names_repair = "check_unique",
  too_few = c("align_start", "error"),
  too_many = c("drop", "error"),
  cols_remove = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="separate_wider_delim_+3A_.df">.df</code></td>
<td>
<p>A data frame</p>
</td></tr>
<tr><td><code id="separate_wider_delim_+3A_cols">cols</code></td>
<td>
<p>Columns to separate</p>
</td></tr>
<tr><td><code id="separate_wider_delim_+3A_delim">delim</code></td>
<td>
<p>Delimiter to separate on</p>
</td></tr>
<tr><td><code id="separate_wider_delim_+3A_...">...</code></td>
<td>
<p>These dots are for future extensions and must be empty.</p>
</td></tr>
<tr><td><code id="separate_wider_delim_+3A_names">names</code></td>
<td>
<p>New column names to separate into</p>
</td></tr>
<tr><td><code id="separate_wider_delim_+3A_names_sep">names_sep</code></td>
<td>
<p>Names separator</p>
</td></tr>
<tr><td><code id="separate_wider_delim_+3A_names_repair">names_repair</code></td>
<td>
<p>Treatment of duplicate names. See <code>?vctrs::vec_as_names</code> for options/details.</p>
</td></tr>
<tr><td><code id="separate_wider_delim_+3A_too_few">too_few</code></td>
<td>
<p>What to do when too few column names are supplied</p>
</td></tr>
<tr><td><code id="separate_wider_delim_+3A_too_many">too_many</code></td>
<td>
<p>What to do when too many column names are supplied</p>
</td></tr>
<tr><td><code id="separate_wider_delim_+3A_cols_remove">cols_remove</code></td>
<td>
<p>Should old columns be removed</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>df &lt;- tidytable(x = c("a", "a_b", "a_b", NA))

df %&gt;%
  separate_wider_delim(x, delim = "_", names = c("left", "right"))

df %&gt;%
  separate_wider_delim(x, delim = "_", names_sep = "")
</code></pre>

<hr>
<h2 id='separate_wider_regex'>Separate a character column into multiple columns using regex patterns</h2><span id='topic+separate_wider_regex'></span>

<h3>Description</h3>

<p>Separate a character column into multiple columns using regex patterns
</p>


<h3>Usage</h3>

<pre><code class='language-R'>separate_wider_regex(
  .df,
  cols,
  patterns,
  ...,
  names_sep = NULL,
  names_repair = "check_unique",
  too_few = "error",
  cols_remove = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="separate_wider_regex_+3A_.df">.df</code></td>
<td>
<p>A data frame</p>
</td></tr>
<tr><td><code id="separate_wider_regex_+3A_cols">cols</code></td>
<td>
<p>Columns to separate</p>
</td></tr>
<tr><td><code id="separate_wider_regex_+3A_patterns">patterns</code></td>
<td>
<p>patterns</p>
</td></tr>
<tr><td><code id="separate_wider_regex_+3A_...">...</code></td>
<td>
<p>These dots are for future extensions and must be empty.</p>
</td></tr>
<tr><td><code id="separate_wider_regex_+3A_names_sep">names_sep</code></td>
<td>
<p>Names separator</p>
</td></tr>
<tr><td><code id="separate_wider_regex_+3A_names_repair">names_repair</code></td>
<td>
<p>Treatment of duplicate names. See <code>?vctrs::vec_as_names</code> for options/details.</p>
</td></tr>
<tr><td><code id="separate_wider_regex_+3A_too_few">too_few</code></td>
<td>
<p>What to do when too few column names are supplied</p>
</td></tr>
<tr><td><code id="separate_wider_regex_+3A_cols_remove">cols_remove</code></td>
<td>
<p>Should old columns be removed</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>df &lt;- tidytable(id = 1:3, x = c("m-123", "f-455", "f-123"))

df %&gt;%
  separate_wider_regex(x, c(gender = ".", ".", unit = "\\d+"))
</code></pre>

<hr>
<h2 id='slice_head'>Choose rows in a data.table</h2><span id='topic+slice_head'></span><span id='topic+slice_tail'></span><span id='topic+slice_max'></span><span id='topic+slice_min'></span><span id='topic+slice'></span><span id='topic+slice_sample'></span>

<h3>Description</h3>

<p>Choose rows in a data.table.
Grouped data.tables grab rows within each group.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>slice_head(.df, n = 5, ..., .by = NULL, by = NULL)

slice_tail(.df, n = 5, ..., .by = NULL, by = NULL)

slice_max(.df, order_by, n = 1, ..., with_ties = TRUE, .by = NULL, by = NULL)

slice_min(.df, order_by, n = 1, ..., with_ties = TRUE, .by = NULL, by = NULL)

slice(.df, ..., .by = NULL)

slice_sample(
  .df,
  n,
  prop,
  weight_by = NULL,
  replace = FALSE,
  .by = NULL,
  by = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="slice_head_+3A_.df">.df</code></td>
<td>
<p>A data.frame or data.table</p>
</td></tr>
<tr><td><code id="slice_head_+3A_n">n</code></td>
<td>
<p>Number of rows to grab</p>
</td></tr>
<tr><td><code id="slice_head_+3A_...">...</code></td>
<td>
<p>Integer row values</p>
</td></tr>
<tr><td><code id="slice_head_+3A_.by">.by</code>, <code id="slice_head_+3A_by">by</code></td>
<td>
<p>Columns to group by</p>
</td></tr>
<tr><td><code id="slice_head_+3A_order_by">order_by</code></td>
<td>
<p>Variable to arrange by</p>
</td></tr>
<tr><td><code id="slice_head_+3A_with_ties">with_ties</code></td>
<td>
<p>Should ties be kept together. The default <code>TRUE</code> may return
can return multiple rows if they are equal. Use <code>FALSE</code> to ignore ties.</p>
</td></tr>
<tr><td><code id="slice_head_+3A_prop">prop</code></td>
<td>
<p>The proportion of rows to select</p>
</td></tr>
<tr><td><code id="slice_head_+3A_weight_by">weight_by</code></td>
<td>
<p>Sampling weights</p>
</td></tr>
<tr><td><code id="slice_head_+3A_replace">replace</code></td>
<td>
<p>Should sampling be performed with (<code>TRUE</code>) or without (<code>FALSE</code>, default) replacement</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>df &lt;- data.table(
  x = 1:4,
  y = 5:8,
  z = c("a", "a", "a", "b")
)

df %&gt;%
  slice(1:3)

df %&gt;%
  slice(1, 3)

df %&gt;%
  slice(1:2, .by = z)

df %&gt;%
  slice_head(1, .by = z)

df %&gt;%
  slice_tail(1, .by = z)

df %&gt;%
  slice_max(order_by = x, .by = z)

df %&gt;%
  slice_min(order_by = y, .by = z)
</code></pre>

<hr>
<h2 id='summarize'>Aggregate data using summary statistics</h2><span id='topic+summarize'></span><span id='topic+summarise'></span>

<h3>Description</h3>

<p>Aggregate data using summary statistics such as mean or median. Can be calculated by group.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>summarize(
  .df,
  ...,
  .by = NULL,
  .sort = TRUE,
  .groups = "drop_last",
  .unpack = FALSE
)

summarise(
  .df,
  ...,
  .by = NULL,
  .sort = TRUE,
  .groups = "drop_last",
  .unpack = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summarize_+3A_.df">.df</code></td>
<td>
<p>A data.frame or data.table</p>
</td></tr>
<tr><td><code id="summarize_+3A_...">...</code></td>
<td>
<p>Aggregations to perform</p>
</td></tr>
<tr><td><code id="summarize_+3A_.by">.by</code></td>
<td>
<p>Columns to group by.
</p>

<ul>
<li><p> A single column can be passed with <code>.by = d</code>.
</p>
</li>
<li><p> Multiple columns can be passed with <code>.by = c(c, d)</code>
</p>
</li>
<li> <p><code>tidyselect</code> can be used:
</p>

<ul>
<li><p> Single predicate: <code>.by = where(is.character)</code>
</p>
</li>
<li><p> Multiple predicates: <code>.by = c(where(is.character), where(is.factor))</code>
</p>
</li>
<li><p> A combination of predicates and column names: <code>.by = c(where(is.character), b)</code>
</p>
</li></ul>

</li></ul>
</td></tr>
<tr><td><code id="summarize_+3A_.sort">.sort</code></td>
<td>
<p><em>experimental</em>: Default <code>TRUE</code>.
If FALSE the original order of the grouping variables will be preserved.</p>
</td></tr>
<tr><td><code id="summarize_+3A_.groups">.groups</code></td>
<td>
<p>Grouping structure of the result
</p>

<ul>
<li><p> &quot;drop_last&quot;: Drop the last level of grouping
</p>
</li>
<li><p> &quot;drop&quot;: Drop all groups
</p>
</li>
<li><p> &quot;keep&quot;: Keep all groups
</p>
</li></ul>
</td></tr>
<tr><td><code id="summarize_+3A_.unpack">.unpack</code></td>
<td>
<p><em>experimental</em>: Default <code>FALSE</code>. Should unnamed data frame inputs be unpacked.
The user must opt in to this option as it can lead to a reduction in performance.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>df &lt;- data.table(
  a = 1:3,
  b = 4:6,
  c = c("a", "a", "b"),
  d = c("a", "a", "b")
)

df %&gt;%
  summarize(avg_a = mean(a),
            max_b = max(b),
            .by = c)

df %&gt;%
  summarize(avg_a = mean(a),
            .by = c(c, d))
</code></pre>

<hr>
<h2 id='tidytable'>Build a data.table/tidytable</h2><span id='topic+tidytable'></span>

<h3>Description</h3>

<p>Constructs a data.table, but one with nice printing features.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tidytable(..., .name_repair = "unique")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tidytable_+3A_...">...</code></td>
<td>
<p>A set of name-value pairs</p>
</td></tr>
<tr><td><code id="tidytable_+3A_.name_repair">.name_repair</code></td>
<td>
<p>Treatment of duplicate names. See <code>?vctrs::vec_as_names</code> for options/details.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>tidytable(x = 1:3, y = c("a", "a", "b"))
</code></pre>

<hr>
<h2 id='tidytable-vctrs'>Internal vctrs methods</h2><span id='topic+tidytable-vctrs'></span>

<h3>Description</h3>

<p>These methods are the extensions that allow tidytable objects to
work with vctrs.
</p>

<hr>
<h2 id='top_n'>Select top (or bottom) n rows (by value)</h2><span id='topic+top_n'></span>

<h3>Description</h3>

<p>Select the top or bottom entries in each group, ordered by <code>wt</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>top_n(.df, n = 5, wt = NULL, .by = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="top_n_+3A_.df">.df</code></td>
<td>
<p>A data.frame or data.table</p>
</td></tr>
<tr><td><code id="top_n_+3A_n">n</code></td>
<td>
<p>Number of rows to return</p>
</td></tr>
<tr><td><code id="top_n_+3A_wt">wt</code></td>
<td>
<p>Optional. The variable to use for ordering. If NULL uses the last column in the data.table.</p>
</td></tr>
<tr><td><code id="top_n_+3A_.by">.by</code></td>
<td>
<p>Columns to group by</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>df &lt;- data.table(
  x = 1:5,
  y = 6:10,
  z = c(rep("a", 3), rep("b", 2))
)

df %&gt;%
  top_n(2, wt = y)

df %&gt;%
  top_n(2, wt = y, .by = z)
</code></pre>

<hr>
<h2 id='transmute'>Add new variables and drop all others</h2><span id='topic+transmute'></span>

<h3>Description</h3>

<p>Unlike <code>mutate()</code>, <code>transmute()</code> keeps only the variables that you create
</p>


<h3>Usage</h3>

<pre><code class='language-R'>transmute(.df, ..., .by = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="transmute_+3A_.df">.df</code></td>
<td>
<p>A data.frame or data.table</p>
</td></tr>
<tr><td><code id="transmute_+3A_...">...</code></td>
<td>
<p>Columns to create/modify</p>
</td></tr>
<tr><td><code id="transmute_+3A_.by">.by</code></td>
<td>
<p>Columns to group by</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>df &lt;- data.table(
  a = 1:3,
  b = 4:6,
  c = c("a", "a", "b")
)

df %&gt;%
  transmute(double_a = a * 2)
</code></pre>

<hr>
<h2 id='tribble'>Rowwise tidytable creation</h2><span id='topic+tribble'></span>

<h3>Description</h3>

<p>Create a tidytable using a rowwise setup.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tribble(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tribble_+3A_...">...</code></td>
<td>
<p>Column names as formulas, values below. See example.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>tribble(
  ~ x, ~ y,
  "a", 1,
  "b", 2,
  "c", 3
)
</code></pre>

<hr>
<h2 id='uncount'>Uncount a data.table</h2><span id='topic+uncount'></span>

<h3>Description</h3>

<p>Uncount a data.table
</p>


<h3>Usage</h3>

<pre><code class='language-R'>uncount(.df, weights, .remove = TRUE, .id = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="uncount_+3A_.df">.df</code></td>
<td>
<p>A data.frame or data.table</p>
</td></tr>
<tr><td><code id="uncount_+3A_weights">weights</code></td>
<td>
<p>A column containing the weights to uncount by</p>
</td></tr>
<tr><td><code id="uncount_+3A_.remove">.remove</code></td>
<td>
<p>If TRUE removes the selected <code>weights</code> column</p>
</td></tr>
<tr><td><code id="uncount_+3A_.id">.id</code></td>
<td>
<p>A string name for a new column containing a unique identifier for the newly uncounted rows.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>df &lt;- data.table(x = c("a", "b"), n = c(1, 2))

uncount(df, n)

uncount(df, n, .id = "id")
</code></pre>

<hr>
<h2 id='unite'>Unite multiple columns by pasting strings together</h2><span id='topic+unite'></span>

<h3>Description</h3>

<p>Convenience function to paste together multiple columns into one.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unite(.df, col = ".united", ..., sep = "_", remove = TRUE, na.rm = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unite_+3A_.df">.df</code></td>
<td>
<p>A data.frame or data.table</p>
</td></tr>
<tr><td><code id="unite_+3A_col">col</code></td>
<td>
<p>Name of the new column, as a string.</p>
</td></tr>
<tr><td><code id="unite_+3A_...">...</code></td>
<td>
<p>Selection of columns. If empty all variables are selected.
<code>tidyselect</code> compatible.</p>
</td></tr>
<tr><td><code id="unite_+3A_sep">sep</code></td>
<td>
<p>Separator to use between values</p>
</td></tr>
<tr><td><code id="unite_+3A_remove">remove</code></td>
<td>
<p>If TRUE, removes input columns from the data.table.</p>
</td></tr>
<tr><td><code id="unite_+3A_na.rm">na.rm</code></td>
<td>
<p>If TRUE, NA values will be not be part of the concatenation</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>df &lt;- tidytable(
    a = c("a", "a", "a"),
    b = c("b", "b", "b"),
    c = c("c", "c", NA)
)

df %&gt;%
  unite("new_col", b, c)

df %&gt;%
  unite("new_col", where(is.character))

df %&gt;%
  unite("new_col", b, c, remove = FALSE)

df %&gt;%
  unite("new_col", b, c, na.rm = TRUE)

df %&gt;%
  unite()
</code></pre>

<hr>
<h2 id='unnest'>Unnest list-columns</h2><span id='topic+unnest'></span>

<h3>Description</h3>

<p>Unnest list-columns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unnest(
  .df,
  ...,
  keep_empty = FALSE,
  .drop = TRUE,
  names_sep = NULL,
  names_repair = "unique"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unnest_+3A_.df">.df</code></td>
<td>
<p>A data.table</p>
</td></tr>
<tr><td><code id="unnest_+3A_...">...</code></td>
<td>
<p>Columns to unnest If empty, unnests all list columns. <code>tidyselect</code> compatible.</p>
</td></tr>
<tr><td><code id="unnest_+3A_keep_empty">keep_empty</code></td>
<td>
<p>Return <code>NA</code> for any <code>NULL</code> elements of the list column</p>
</td></tr>
<tr><td><code id="unnest_+3A_.drop">.drop</code></td>
<td>
<p>Should list columns that were not unnested be dropped</p>
</td></tr>
<tr><td><code id="unnest_+3A_names_sep">names_sep</code></td>
<td>
<p>If NULL, the default, the inner column names will become the new outer column names.
</p>
<p>If a string, the name of the outer column will be appended to the beginning of the inner column names,
with <code>names_sep</code> used as a separator.</p>
</td></tr>
<tr><td><code id="unnest_+3A_names_repair">names_repair</code></td>
<td>
<p>Treatment of duplicate names. See <code>?vctrs::vec_as_names</code> for options/details.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>df1 &lt;- tidytable(x = 1:3, y = 1:3)
df2 &lt;- tidytable(x = 1:2, y = 1:2)
nested_df &lt;-
  data.table(
    a = c("a", "b"),
    frame_list = list(df1, df2),
    vec_list = list(4:6, 7:8)
  )

nested_df %&gt;%
  unnest(frame_list)

nested_df %&gt;%
  unnest(frame_list, names_sep = "_")

nested_df %&gt;%
  unnest(frame_list, vec_list)
</code></pre>

<hr>
<h2 id='unnest_longer'>Unnest a list-column of vectors into regular columns</h2><span id='topic+unnest_longer'></span>

<h3>Description</h3>

<p>Turns each element of a list-column into a row.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unnest_longer(
  .df,
  col,
  values_to = NULL,
  indices_to = NULL,
  indices_include = NULL,
  keep_empty = FALSE,
  names_repair = "check_unique",
  simplify = NULL,
  ptype = NULL,
  transform = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unnest_longer_+3A_.df">.df</code></td>
<td>
<p>A data.table or data.frame</p>
</td></tr>
<tr><td><code id="unnest_longer_+3A_col">col</code></td>
<td>
<p>Column to unnest</p>
</td></tr>
<tr><td><code id="unnest_longer_+3A_values_to">values_to</code></td>
<td>
<p>Name of column to store values</p>
</td></tr>
<tr><td><code id="unnest_longer_+3A_indices_to">indices_to</code></td>
<td>
<p>Name of column to store indices</p>
</td></tr>
<tr><td><code id="unnest_longer_+3A_indices_include">indices_include</code></td>
<td>
<p>Should an index column be included?
Defaults to <code>TRUE</code> when <code>col</code> has inner names.</p>
</td></tr>
<tr><td><code id="unnest_longer_+3A_keep_empty">keep_empty</code></td>
<td>
<p>Return <code>NA</code> for any <code>NULL</code> elements of the list column</p>
</td></tr>
<tr><td><code id="unnest_longer_+3A_names_repair">names_repair</code></td>
<td>
<p>Treatment of duplicate names. See <code>?vctrs::vec_as_names</code> for options/details.</p>
</td></tr>
<tr><td><code id="unnest_longer_+3A_simplify">simplify</code></td>
<td>
<p>Currently not supported. Errors if not <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="unnest_longer_+3A_ptype">ptype</code></td>
<td>
<p>Optionally a named list of ptypes declaring the desired output type of each component.</p>
</td></tr>
<tr><td><code id="unnest_longer_+3A_transform">transform</code></td>
<td>
<p>Optionally a named list of transformation functions applied to each component.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>df &lt;- tidytable(
  x = 1:3,
  y = list(0, 1:3, 4:5)
)

df %&gt;% unnest_longer(y)
</code></pre>

<hr>
<h2 id='unnest_wider'>Unnest a list-column of vectors into a wide data frame</h2><span id='topic+unnest_wider'></span>

<h3>Description</h3>

<p>Unnest a list-column of vectors into a wide data frame
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unnest_wider(
  .df,
  col,
  names_sep = NULL,
  simplify = NULL,
  names_repair = "check_unique",
  ptype = NULL,
  transform = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unnest_wider_+3A_.df">.df</code></td>
<td>
<p>A data.table or data.frame</p>
</td></tr>
<tr><td><code id="unnest_wider_+3A_col">col</code></td>
<td>
<p>Column to unnest</p>
</td></tr>
<tr><td><code id="unnest_wider_+3A_names_sep">names_sep</code></td>
<td>
<p>If <code>NULL</code>, the default, the names will be left as they are.
If a string, the inner and outer names will be pasted together with <code>names_sep</code>
as the separator.</p>
</td></tr>
<tr><td><code id="unnest_wider_+3A_simplify">simplify</code></td>
<td>
<p>Currently not supported. Errors if not <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="unnest_wider_+3A_names_repair">names_repair</code></td>
<td>
<p>Treatment of duplicate names. See <code>?vctrs::vec_as_names</code> for options/details.</p>
</td></tr>
<tr><td><code id="unnest_wider_+3A_ptype">ptype</code></td>
<td>
<p>Optionally a named list of ptypes declaring the desired output type of each component.</p>
</td></tr>
<tr><td><code id="unnest_wider_+3A_transform">transform</code></td>
<td>
<p>Optionally a named list of transformation functions applied to each component.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>df &lt;- tidytable(
  x = 1:3,
  y = list(0, 1:3, 4:5)
)

# Automatically creates names
df %&gt;% unnest_wider(y)

# But you can provide names_sep for increased naming control
df %&gt;% unnest_wider(y, names_sep = "_")
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
