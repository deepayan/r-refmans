<!DOCTYPE html><html lang="en"><head><title>Help for package apc</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {apc}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#apc-package'><p>Age-period-cohort analysis</p></a></li>
<li><a href='#apc-internal'><p>Internal apc Functions</p></a></li>
<li><a href='#apc.data.list'><p>Arrange data as an apc.data.list</p></a></li>
<li><a href='#apc.data.list.subset'><p>Cut age, period and cohort groups from data set.</p></a></li>
<li><a href='#apc.data.sums'><p>Computes age, period and cohort sums of a matrix</p></a></li>
<li><a href='#apc.fit.model'><p>Fits an age period cohort model</p></a></li>
<li><a href='#apc.forecast'><p>Forecasts from age-period-cohort models.</p></a></li>
<li><a href='#apc.forecast.ac'><p>Forecast for responses model with AC or CL structure.</p></a></li>
<li><a href='#apc.forecast.ap'><p>Forecast for Poisson response model with AP structure.</p></a></li>
<li><a href='#apc.forecast.apc'><p>Forecast models with APC structure.</p></a></li>
<li><a href='#apc.get.design'><p>Create design matrices</p></a></li>
<li><a href='#apc.get.index'><p>Get indices for mapping data into trapezoid formation</p></a></li>
<li><a href='#apc.hypothesis'><p>Imposing hypotheses on age-period-cohort models.</p></a></li>
<li><a href='#apc.identify'><p>Identification of time effects</p></a></li>
<li><a href='#apc.indiv.compare.direct'>
<p>Implements direct tests between APC models</p></a></li>
<li><a href='#apc.indiv.est.model'><p>Estimate a single APC model</p></a></li>
<li><a href='#apc.indiv.model.table'>
<p>Generate table to select APC submodel</p></a></li>
<li><a href='#apc.plot.data.all'><p>Make all descriptive plots.</p></a></li>
<li><a href='#apc.plot.data.level'><p>Level plot of data matrix.</p></a></li>
<li><a href='#apc.plot.data.sparsity'><p>This plot shows heat map of the sparsity of a data matrix.</p></a></li>
<li><a href='#apc.plot.data.sums'><p>This plot shows sums of data matrix by age, period or cohort.</p></a></li>
<li><a href='#apc.plot.data.within'><p>This plot shows time series of matrix within age, period or cohort.</p></a></li>
<li><a href='#apc.plot.fit'><p>Plots of apc estimates</p></a></li>
<li><a href='#apc.plot.fit.all'><p>Make all fit plots.</p></a></li>
<li><a href='#apc.plot.fit.pt'><p>Plot probability transform of responses given fitted values</p></a></li>
<li><a href='#apc.plot.fit.residuals'><p>Level plots of residuals / fitted values / linear predictors</p></a></li>
<li><a href='#apc.polygon'><p>Add connected line and standard deviation polygons to a plot</p></a></li>
<li><a href='#data.aids'><p>UK aids data</p></a></li>
<li><a href='#data.asbestos'><p>Asbestos data</p></a></li>
<li><a href='#data.Belgian.lung.cancer'><p>Belgian lung cancer data</p></a></li>
<li><a href='#data.Italian.bladder.cancer'><p>Italian bladder cancer data</p></a></li>
<li><a href='#data.Japanese.breast.cancer'><p>Japanese breast cancer data</p></a></li>
<li><a href='#data.loss.BZ'><p>Motor data</p></a></li>
<li><a href='#data.loss.TA'><p>Motor data</p></a></li>
<li><a href='#data.loss.VNJ'><p>Motor data</p></a></li>
<li><a href='#data.loss.XL'><p>US Casualty data, XL Group</p></a></li>
<li><a href='#data.RH.mortality'><p>2-sample mortality data.</p></a></li>
<li><a href='#data.US.prostate.cancer'><p>Japanese breast cancer data</p></a></li>
<li><a href='#new.apc.identify'><p>Identification of time effects</p></a></li>
<li><a href='#new.apc.plot.fit'><p>Plots of apc estimates</p></a></li>
<li><a href='#triangle'><p>Triangular matrices used in reserving</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Age-Period-Cohort Analysis</td>
</tr>
<tr>
<td>Version:</td>
<td>2.0.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2020-09-28</td>
</tr>
<tr>
<td>Author:</td>
<td>Zoe Fannon, Bent Nielsen</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Bent Nielsen &lt;bent.nielsen@nuffield.ox.ac.uk&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Functions for age-period-cohort analysis. Aggregate data can be organised in matrices indexed by age-cohort, age-period or cohort-period. The data can include dose and response or just doses. The statistical model is a generalized linear model (GLM) allowing for 3,2,1 or 0 of the age-period-cohort factors. Individual-level data should have a row for each individual and columns for each of age, period, and cohort. The statistical model for repeated cross-section is a generalized linear model. The statistical model for panel data is ordinary least squares. The canonical parametrisation of Kuang, Nielsen and Nielsen (2008) &lt;<a href="https://doi.org/10.1093%2Fbiomet%2Fasn026">doi:10.1093/biomet/asn026</a>&gt; is used. Thus, the analysis does not rely on ad hoc identification.</td>
</tr>
<tr>
<td>Imports:</td>
<td>lattice, plyr, reshape, plm, survey, lmtest, car, ISLR, AER,
ggplot2, ChainLadder</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2020-10-01 16:21:32 UTC; Nielsen</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2020-10-01 23:20:06 UTC</td>
</tr>
</table>
<hr>
<h2 id='apc-package'>Age-period-cohort analysis</h2><span id='topic+apc-package'></span><span id='topic+apc'></span>

<h3>Description</h3>

<p>The package includes functions for age-period-cohort analysis.  The statistical model is a generalized linear model (GLM)
allowing for age, period and cohort factors, or a sub-set of the factors.
The canonical parametrisation of Kuang, Nielsen and Nielsen (2008a) is used. 
The outline of an analysis is described below.
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
		Package: </td><td style="text-align: left;"> apc</td>
</tr>
<tr>
 <td style="text-align: left;">
		Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
		Version: </td><td style="text-align: left;"> 2.0.0</td>
</tr>
<tr>
 <td style="text-align: left;">
		Date: </td><td style="text-align: left;"> 2020-09-28</td>
</tr>
<tr>
 <td style="text-align: left;">
		License: </td><td style="text-align: left;"> GPL-3</td>
</tr>
<tr>
 <td style="text-align: left;">
	</td>
</tr>

</table>

<p>The apc package uses the canonical parameters suggested by
Kuang, Nielsen and Nielsen (2008a)
and generalized by
Nielsen (2014). 
These evolve around the second differences of age, period and cohort factors as well as an three parameters (level and two slopes)
for a linear plane.  The age, period and cohort factors themselves are not identifiable.  They could be ad hoc identified
by associating the levels and two slopes to the age, period and cohort factors in a particular way.  This should be done
with great care as such ad hoc identification easily masks which information is coming from the data and which information
is coming from the choice of ad hoc identification scheme. An illustration is given below.
A short description of the package can be found in
Nielsen (2015).
</p>
<p>A formal analysis of the identification of the age-period-cohort model can be found in
Nielsen and Nielsen (2014).
Forecasting is discussed in
Kuang, Nielsen and Nielsen (2008b, 2011)
and
Martinez Miranda, Nielsen and Nielsen (2015).
Methods for cross section data are introduced in
Fannon, Monden and Nielsen (2019).
Methods for panel data are introduced in
Fannon (2020).	
For a recent overview see
Fannon and Nielsen (2019).
</p>
<p>The package covers age-period-cohort models for three types of data.
</p>

<ol>
<li>
<p>Tables of aggregate data.
</p>
</li>
<li>
<p>Repeated cross sectional data.
</p>
</li>
<li>
<p>Panel data. 
</p>
</li></ol>
		
<p>The apc package can be used as follows.
</p>

<ol>
<li>
<p><strong>Aggregate data</strong>.
For a vignette with an introduction to analysis of aggregate data, see
see
<a href="../doc/IntroductionAggregateData.pdf"><code>IntroductionAggregateData.pdf</code></a>,
<a href="../doc/IntroductionAggregateData.R"><code>IntroductionAggregateData.R</code></a>			
on
<a href="../doc/index.html"><code>Vignettes</code></a>.		
</p>

<ol>
<li>
<p>Organize the data in as an <code><a href="#topic+apc.data.list">apc.data.list</a></code>.
Data are included in matrix format.  Information needs to be given about the original data format.
Optionally, information can be given about the labels for the time scales.
</p>
</li>
<li>
<p>Construct descriptive plots using <code><a href="#topic+apc.plot.data.all">apc.plot.data.all</a></code>.
This gives a series of descriptive plots.  The plots can be called individually through
</p>
		
<ol>
<li>
<p>Plot data sums using <code><a href="#topic+apc.plot.data.sums">apc.plot.data.sums</a></code>.
Numerical values can be obtained through <code><a href="#topic+apc.data.sums">apc.data.sums</a></code>.
</p>
</li>
<li>
<p>Sparsity plots of data using <code><a href="#topic+apc.plot.data.sparsity">apc.plot.data.sparsity</a></code>.
</p>
</li>
<li>	
<p>Plot data using all combinations of two time scales using <code><a href="#topic+apc.plot.data.within">apc.plot.data.within</a></code>.
</p>
</li></ol>

</li>
<li>
<p>Get an deviance table for the age-period-cohort model through
<code><a href="#topic+apc.fit.table">apc.fit.table</a></code>.
</p>
</li>
<li>
<p>Estimate a particular (sub-model of) age-period-cohort model through
<code><a href="#topic+apc.fit.model">apc.fit.model</a></code>.
</p>
</li>
<li>
<p>Plot probability transforms of observed responses given fit using
<code><a href="#topic+apc.plot.fit.pt">apc.plot.fit.pt</a></code>.
</p>
</li>
<li>
<p>Plot estimated parameters through
<code><a href="#topic+apc.plot.fit">apc.plot.fit</a></code>.
Numerical values of certain transformations of the canonical parameter can be obtained through
<code><a href="#topic+apc.identify">apc.identify</a></code>.
</p>
</li>
<li>
<p>Recursive analysis can be done by selecting a subset of the observations through
<code><a href="#topic+apc.data.list.subset">apc.data.list.subset</a></code> and then repeating analysis.  This will reveal how sensitive
the results are to particular age, period and cohort groups.
</p>
</li>
<li>
<p>Forecasting.  Some functions have been been added for forecasting in from a Poisson response-only model
with an age-cohort parametrization
<code><a href="#topic+apc.forecast.ac">apc.forecast.ac</a></code>
and with an age-period parametrization
<code><a href="#topic+apc.forecast.ap">apc.forecast.ap</a></code>.
See also the overview on
<code><a href="#topic+apc.forecast">apc.forecast</a></code>
</p>
</li></ol>

</li>
<li>
<p><strong>Repeated cross section</strong>
and 
<strong>Panel Data</strong>.			
For a vignette 
with an introduction to analysis of repeated cross section data and panel data,
see
<a href="../doc/IntroductionIndividualData.pdf"><code>IntroductionIndividualData.pdf</code></a>,
<a href="../doc/IntroductionIndividualData.R"><code>IntroductionIndividualData.R</code></a>			
on
<a href="../doc/index.html"><code>Vignettes</code></a>		
Further examples can be found in a second vignette, see 			
<a href="../doc/IntroductionIndividualDataFurtherExamples.pdf"><code>IntroductionIndividualDataFurtherExample.pdf</code></a>,
<a href="../doc/IntroductionIndividualDataFurtherExample.R"><code>IntroductionIndividualDataFurtherExample.R</code></a>.
</p>
</li></ol>

<p>Data examples include
</p>

<ol>
<li>
<p><strong>Aggregate data</strong>
</p>

<ol>
<li>
<p><code><a href="#topic+data.asbestos">data.asbestos</a></code>
includes counts of deaths from mesothelioma in the UK.
This dataset has no measure for exposure.
It can be analysed using a Poisson model with an &quot;APC&quot; or an &quot;AC&quot; design.
Source: Martinez Miranda, Nielsen and Nielsen (2015).
Also used in Nielsen (2015).
</p>
</li>
<li>	
<p><code><a href="#topic+data.Italian.bladder.cancer">data.Italian.bladder.cancer</a></code>
includes counts of deaths from bladder cancer in the Italy.
This dataset includes a measure for exposure.
It can be analysed using a Poisson model with an &quot;APC&quot; or an &quot;AC&quot; design.
Source: Clayton and Schifflers (1987a).
</p>
</li>
<li>	
<p><code><a href="#topic+data.Belgian.lung.cancer">data.Belgian.lung.cancer</a></code>
includes counts of deaths from lung cancer in the Belgium.
This dataset includes a measure for exposure.
It can be analysed using a Poisson model with an &quot;APC&quot;, &quot;AC&quot;, &quot;AP&quot; or &quot;Ad&quot; design.
Source: Clayton and Schifflers (1987a).
</p>
</li>
<li>	
<p><code><a href="#topic+data.Japanese.breast.cancer">data.Japanese.breast.cancer</a></code>
includes counts of deaths from breast cancer in the Japan.
This dataset includes a measure for exposure.
It can be analysed using a Poisson model with an &quot;APC&quot; design.
Source: Clayton and Schifflers (1987b).
</p>
</li></ol>

<p><strong>Repeated cross section data</strong>		
</p>

<ol>
<li>
<p><code><a href="ISLR.html#topic+Wage">Wage</a></code> data from the package ISLR
</p>
</li></ol>

<p><strong>Repeated cross section data</strong>		
</p>

<ol>
<li>
<p><code><a href="AER.html#topic+PSID7682">PSID7682</a></code> data from the package AER.
These are panel data on earnings for 595 individuals for the years 1976-1982.
</p>
</li></ol>

</li></ol>



<h3>Author(s)</h3>

<p>Bent Nielsen &lt;bent.nielsen@nuffield.ox.ac.uk&gt; 29 Jan 2015 updated 26 Aug 2020.</p>


<h3>References</h3>

<p>Clayton, D. and Schifflers, E. (1987a) Models for temperoral variation in cancer rates. I: age-period and age-cohort models. <em>Statistics in Medicine</em> 6, 449-467.
</p>
<p>Clayton, D. and Schifflers, E. (1987b) Models for temperoral variation in cancer rates. II: age-period-cohort models. <em>Statistics in Medicine</em> 6, 469-481.
</p>
<p>Fannon, Z. (2020). D.Phil. thesis. University of Oxford.
</p>
<p>Fannon, Z., Monden, C. and Nielsen, B. (2018) Age-period cohort modelling and covariates, with an application to obesity in England 2001-2014. <em>Download</em>: <a href="https://www.nuffield.ox.ac.uk/economics/Papers/2018/2018W05_obesity.pdf">Nuffield DP</a>. Supplement Code for replication: <a href="https://www.nuffield.ox.ac.uk/economics/Papers/2018/2018W05_obesityReplication.zip">Nuffield DP supplement</a>. 
</p>
<p>Fannon, Z. and Nielsen, B. (2019) Age-period-cohort models. <em>Oxford Research Encyclopedia of Economics and Finance</em>. Oxford University Press. <em>Download</em>: <code>doi.org/10.1093/acrefore/9780190625979.013.495</code>; Earlier version <a href="https://www.nuffield.ox.ac.uk/economics/Papers/2018/2018W04_age_period_cohort_models.pdf">Nuffield DP</a>. 
</p>
<p>Kuang, D., Nielsen, B. and Nielsen, J.P. (2008a) Identification of the age-period-cohort model and the extended chain ladder model. Biometrika 95, 979-986. <em>Download</em>: <a href="https://doi.org/10.1093/biomet/asn026">Article</a>; Earlier version <a href="http://www.nuffield.ox.ac.uk/economics/papers/2007/w5/KuangNielsenNielsen07.pdf">Nuffield DP</a>.
</p>
<p>Kuang, D., Nielsen, B. and Nielsen, J.P. (2008b) Forecasting with the age-period-cohort model and the extended chain-ladder model. Biometrika 95, 987-991. <em>Download</em>: <a href="https://doi.org/10.1093/biomet/asn038">Article</a>; Earlier version <a href="http://www.nuffield.ox.ac.uk/economics/papers/2008/w9/KuangNielsenNielsen_Forecast.pdf">Nuffield DP</a>.
</p>
<p>Kuang, D., Nielsen, B. and Nielsen, J.P. (2011) Forecasting in an extended chain-ladder-type model. Journal of Risk and Insurance 78, 345-359. <em>Download</em>: <a href="http://dx.doi.org/10.1111/j.1539-6975.2010.01395.x">Article</a>; Earlier version: <a href="http://www.nuffield.ox.ac.uk/economics/papers/2010/w5/Forecast24jun10.pdf">Nuffield DP</a>. 
</p>
<p>Martinez Miranda, M.D., Nielsen, B. and Nielsen, J.P. (2015) Inference and forecasting in the age-period-cohort model with unknown exposure with an application to mesothelioma mortality. <em>Journal of the Royal Statistical Society</em> A 178, 29-55. <em>Download</em>: <a href="https://doi.org/10.1111/rssa.12051">Article</a>, <a href="http://www.nuffield.ox.ac.uk/economics/papers/2013/Asbestos8mar13.pdf">Nuffield DP</a>. 
</p>
<p>Nielsen, B. (2015) apc: An R package for age-period-cohort analysis. <em>R Journal</em> 7, 52-64. <em>Download</em>: <a href="https://journal.r-project.org/archive/2015-2/nielsen.pdf">Open access</a>.
</p>
<p>Nielsen, B. (2014) Deviance analysis of age-period-cohort models. <em>Download</em>: <a href="http://www.nuffield.ox.ac.uk/economics/papers/2014/apc_deviance.pdf">Nuffield DP</a>.
</p>
<p>Nielsen, B. and Nielsen, J.P. (2014) Identification and forecasting in mortality models. The Scientific World Journal. vol. 2014, Article ID 347043, 24 pages. <em>Download</em>: <a href="http://www.hindawi.com/journals/tswj/2014/347043">Article</a>.
</p>


<h3>See Also</h3>

<p>Vignettes are available on
<a href="../doc/index.htm"><code>Vignettes</code></a>.
</p>
<p>Further information, including minor upgrades and a python version can be found on
<a href="http://users.ox.ac.uk/~nuff0078/apc/index.htm"><code>apc development web page</code></a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#	see vignettes
</code></pre>

<hr>
<h2 id='apc-internal'>Internal apc Functions</h2><span id='topic+apc.internal.function.date.2.character'></span><span id='topic+foo2'></span><span id='topic+foo3'></span><span id='topic+foo4'></span>

<h3>Description</h3>

<p>Internal apc functions
</p>


<h3>Details</h3>

<p>These are not to be called by the user.
</p>


<h3>Author(s)</h3>

<p>Bent Nielsen &lt;bent.nielsen@nuffield.ox.ac.uk&gt; 1 Feb 2016</p>

<hr>
<h2 id='apc.data.list'>Arrange data as an apc.data.list</h2><span id='topic+apc.data.list'></span>

<h3>Description</h3>

<p>This is step 1 of the apc analysis.
</p>
<p>The apc package is aimed at range of data types.  This analysis and labelling of parameters depends on
the choice data type.  In order to keep track of this choice the data first has to be arranged as an
apc.data.list.  The function purpose of this function is to aid the user in constructing a list with the right information.
</p>
<p>Age period cohort analysis is used in two situations.  A dose-response situation, where both doses (exposure, risk set, cases) and
responses (counts of deaths, outcomes) are available.  And a response situation where only a response is available.  If
the aim is to directly model mortality ratios (counts of death divided by exposure) this will be thought of a response
</p>
<p>The <code>apc.data.list</code> gives sufficient information for the further analysis. It is sufficient to store this information.
It has 2 obligatory arguments, which are a response matrix and a character indicating the data format.
It also has some further optional arguments, which have certain default values. 
Some times it may be convenient to add further arguments to the <code>apc.data.list</code>.  This will not affect the apc analysis.
</p>
<p><code>apc.data.list</code> generates default row and column names for the response and dose matrices when these are not
provided by the user.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>apc.data.list(response, data.format, dose=NULL,
					age1=NULL, per1=NULL, coh1=NULL, unit=NULL,
					per.zero=NULL, per.max=NULL,
					time.adjust=NULL, label=NULL,
					n.decimal=NULL)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="apc.data.list_+3A_response">response</code></td>
<td>
<p>matrix (or vector).  Numbers of responses.  It should have a format matching <code>data.format</code>.
Time should be increasing with the row/column index of the matrix.  For instance, consider a 10x5 matrix in &quot;AP&quot; format:
Then the row index is for age, and it should be increasing in age. Thus, higher ages are further down the rows of the matrix.
In the same way, the column index is for period.</p>
</td></tr>
<tr><td><code id="apc.data.list_+3A_data.format">data.format</code></td>
<td>
<p>character.  The following options are implemented:
</p>

<dl>
<dt>&quot;AC&quot;</dt><dd><p>has    age/cohort as increasing row/column index.</p>
</dd>
<dt>&quot;AP&quot;</dt><dd><p>has    age/period as increasing row/column index.</p>
</dd>
<dt>&quot;CA&quot;</dt><dd><p>has cohort/age    as increasing row/column index.</p>
</dd>
<dt>&quot;CL&quot;</dt><dd><p>has cohort/age 	  as increasing row/column index, triangular.</p>
</dd>
<dt>&quot;CP&quot;</dt><dd><p>has cohort/period as increasing row/column index.</p>
</dd>
<dt>&quot;PA&quot;</dt><dd><p>has period/age    as increasing row/column index.</p>
</dd>
<dt>&quot;PC&quot;</dt><dd><p>has period/cohort as increasing row/column index.</p>
</dd>
<dt>&quot;trapezoid&quot;</dt><dd><p>has    age/period as increasing row/column index, period-diagonals are NA for period &lt;= per.zero and &gt;per.zero+per.max.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="apc.data.list_+3A_dose">dose</code></td>
<td>
<p><em>Optional</em>. matrix or NULL.  Numbers of doses.  It should have same format as <code>response</code>.</p>
</td></tr>
<tr><td><code id="apc.data.list_+3A_age1">age1</code></td>
<td>
<p><em>Optional</em>. Numeric or NULL.  Time label for youngest age group.  Used if <code>data.format</code> is &quot;AC&quot;, &quot;AP&quot;, &quot;CA&quot;, &quot;CL&quot;, &quot;PA&quot;, &quot;trapezoid&quot;. If NULL default is unit.</p>
</td></tr>
<tr><td><code id="apc.data.list_+3A_per1">per1</code></td>
<td>
<p><em>Optional</em>. Numeric or NULL.  Time label for oldest period group.  Used if <code>data.format</code> is &quot;AP&quot;, &quot;CP&quot;, &quot;PA&quot;, &quot;PC&quot;. If NULL default is unit.</p>
</td></tr>
<tr><td><code id="apc.data.list_+3A_coh1">coh1</code></td>
<td>
<p><em>Optional</em>. Numeric or NULL.  Time label for youngest age group.  Used if <code>data.format</code> is &quot;AC&quot;, &quot;CA&quot;, &quot;CL&quot;, &quot;CL.vector.by.row&quot;, &quot;CP&quot;, &quot;PC&quot;, &quot;trapezoid&quot;. If NULL default is unit.</p>
</td></tr>
<tr><td><code id="apc.data.list_+3A_unit">unit</code></td>
<td>
<p><em>Optional</em>. Numeric or NULL.  Common time steps for age, period and cohort.  For quarterly data use <code>1/4</code>.  For monthly data use <code>1/12</code>. If NULL default is 1.</p>
</td></tr>
<tr><td><code id="apc.data.list_+3A_per.zero">per.zero</code></td>
<td>
<p><em>Optional</em>. Numeric or NULL.  Needed if data format is &quot;trapezoid&quot;.</p>
</td></tr>
<tr><td><code id="apc.data.list_+3A_per.max">per.max</code></td>
<td>
<p><em>Optional</em>. Numeric or NULL.  Needed if data format is &quot;trapezoid&quot;.</p>
</td></tr>
<tr><td><code id="apc.data.list_+3A_time.adjust">time.adjust</code></td>
<td>
<p><em>Optional</em>. Numeric.  Time labels are based on two of age1, per1 and coh1.  The third time label is computed according to the formula age1+coh1=per1+time.adjust.  Default is 0.  If age1=coh=1 it is natural to choose time.adjust=1.</p>
</td></tr>
<tr><td><code id="apc.data.list_+3A_label">label</code></td>
<td>
<p><em>Optional</em>. Character.  Useful when working with multiple data sets. Some internal functions use the first three characters of the label for identification of the two datasets.</p>
</td></tr>
<tr><td><code id="apc.data.list_+3A_n.decimal">n.decimal</code></td>
<td>
<p><em>Optional</em>.  Numeric or NULL.  The labels for parameters involves a date. This is found by converting a number into a character.  If the value is set to <code>d</code> package uses <code><a href="base.html#topic+sprintf">sprintf</a></code>. If the value is set to <code>NULL</code> and <code>unit==1/4</code> for quarterly data or <code>unit==1/12</code> for monthly data or <code>1/20&lt;=unit &amp;&amp; unit&lt;1</code> then package uses <code>sprintf</code>. If the value is set to <code>NULL</code>	and <code>1/20&gt;unit || unit&gt;=1</code>	then package uses <code><a href="base.html#topic+as.character">as.character</a></code>, which looks nice for integers, but can be messy otherwise.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the user does not set values for any of <code>age1</code>, <code>per1</code>, <code>coh1</code>, <code>unit</code> then the value is set to <code>unit</code>.
</p>
<p>The user can set values of  <code>age1</code>, <code>per1</code>, <code>coh1</code> that are incongruent.  The functions only use two these that are relevant for the chosen
<code>data.format</code>.  Example: the <code>data.format</code> may be <code>"AC"</code> and the user sets
<code>age1</code>, <code>per1</code>, but <code>age1</code>, <code>coh1</code> are relevant for this data format.
The <code>apc.data.list</code> then sets <code>coh1=unit</code>, by default, while ignoring the value for <code>per1</code>.  Other commands such as
<code><a href="#topic+apc.data.list.subset">apc.data.list.subset</a></code> or <code><a href="#topic+apc.fit.table">apc.fit.table</a></code>, 
will internally, as default option, call the function
<code><a href="#topic+apc.get.index">apc.get.index</a></code>. That function will, in this example, set <code>per1</code> according to the values of <code>age1</code> and <code>coh1</code>.  
</p>
<p>If the user does not set a value for <code>time.adjust</code> this is set equal to <code>unit</code> when the user does not specify at least two <code>age1</code>, <code>per1</code>, <code>coh1</code>.
Otherwise it is set to 0.
The former choice matches the values in the theory papers, where indices count 1,2,... to follow standard notation for row/column indices for matrices, so that age+coh=per+unit.
The latter choice seeks to match a real time scale the user sets according to age+coh=per.
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>response</code></td>
<td>
<p>matrix (or vector).  Numbers of responses.</p>
</td></tr>
<tr><td><code>dose</code></td>
<td>
<p>matrix (or NULL).  Numbers of doses.</p>
</td></tr>
<tr><td><code>data.format</code></td>
<td>
<p>character.</p>
</td></tr>
<tr><td><code>age1</code></td>
<td>
<p>Numeric. Default is NULL.</p>
</td></tr>		
<tr><td><code>per1</code></td>
<td>
<p>Numeric. Default is NULL.</p>
</td></tr>		
<tr><td><code>coh1</code></td>
<td>
<p>Numeric. Default is NULL.</p>
</td></tr>		
<tr><td><code>unit</code></td>
<td>
<p>Numeric.  Default is NULL. For monthly data one use <code>unit=1/12</code>.</p>
</td></tr>		
<tr><td><code>per.zero</code></td>
<td>
<p>Numeric.  If data.format is not &quot;trapezoid&quot; the value is NULL. If data.format is &quot;trapezoid&quot; the coordinate system is in age-cohort format and this value counts how many periods are cut off. The default is <code>per.zero=0</code>.</p>
</td></tr>
<tr><td><code>per.max</code></td>
<td>
<p>Numeric.  If data.format is not &quot;trapezoid&quot; the value is NULL. If data.format is &quot;trapezoid&quot; the coordinate system is in age-cohort format and this value counts how many periods are included in the data array.  The default is <code>per.max=nrow(response)+ncol(response)-1-per.zero</code>.</p>
</td></tr>
<tr><td><code>time.adjust</code></td>
<td>
<p>Numeric.  Default is NULL.</p>
</td></tr>
<tr><td><code>label</code></td>
<td>
<p>Character. Default of NULL.</p>
</td></tr>
<tr><td><code>n.decimal</code></td>
<td>
<p>Numeric or NULL.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Bent Nielsen &lt;bent.nielsen@nuffield.ox.ac.uk&gt; 17 Nov 2016</p>


<h3>References</h3>

<p>Kuang, D., Nielsen, B. and Nielsen, J.P. (2008a) Identification of the age-period-cohort model and the extended chain ladder model. Biometrika 95, 979-986. <em>Download</em>: <a href="https://doi.org/10.1093/biomet/asn026">Article</a>; Earlier version <a href="http://www.nuffield.ox.ac.uk/economics/papers/2007/w5/KuangNielsenNielsen07.pdf">Nuffield DP</a>.
</p>
<p>Nielsen, B. (2014) Deviance analysis of age-period-cohort models. <em>Download</em>: <a href="http://www.nuffield.ox.ac.uk/economics/papers/2014/apc_deviance.pdf">Nuffield DP</a>.
</p>
<p>Nielsen, B. (2015) apc: An R package for age-period-cohort analysis. <em>R Journal</em> 7, 52-64. <em>Download</em>: <a href="https://journal.r-project.org/archive/2015-2/nielsen.pdf">Open access</a>.
</p>


<h3>See Also</h3>

<p>The below example shows how the <code><a href="#topic+data.Japanese.breast.cancer">data.Japanese.breast.cancer</a></code> data.list was generated.
Other provided data sets include
<code><a href="#topic+data.asbestos">data.asbestos</a></code>
<code><a href="#topic+data.Belgian.lung.cancer">data.Belgian.lung.cancer</a></code>
<code><a href="#topic+data.Italian.bladder.cancer">data.Italian.bladder.cancer</a></code>.
</p>
<p>A subset of the data can be selected using <code><a href="#topic+apc.data.list.subset">apc.data.list.subset</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>###############
#	Artificial data
#	(1) Generate a 5x7 matrix and make arbitrary decisions for rest

response &lt;- matrix(data=seq(1:35),nrow=5,ncol=7)
data.list	&lt;- apc.data.list(response=response,data.format="AP",
					age1=25,per1=1955,coh1=NULL,unit=5,
					per.zero=NULL,per.max=NULL)
data.list

#	(2) Chain Ladder data

k			&lt;- 5
v.response 	&lt;- seq(1:(k*(k+1)/2))
data.list	&lt;- apc.data.list(response=vector.2.triangle(v.response,k),
							data.format="CL.vector.by.row",age1=2001)
data.list

###############
#	Japanese breast cancer
#	This is the code used to generate the data.Japanese.breast.cancer
v.rates		&lt;- c( 0.44, 0.38, 0.46, 0.55, 0.68,
			 	  1.69, 1.69, 1.75, 2.31, 2.52,
				  4.01, 3.90, 4.11, 4.44, 4.80,
				  6.59, 6.57, 6.81, 7.79, 8.27,
				  8.51, 9.61, 9.96,11.68,12.51,
				 10.49,10.80,12.36,14.59,16.56,
				 11.36,11.51,12.98,14.97,17.79,
				 12.03,10.67,12.67,14.46,16.42,
				 12.55,12.03,12.10,13.81,16.46,
				 15.81,13.87,12.65,14.00,15.60,
				 17.97,15.62,15.83,15.71,16.52)
v.cases		&lt;- c(   88,   78,  101,  127,  179,
				   299,  330,  363,  509,  588,
				   596,  680,  798,  923, 1056,
				   874,  962, 1171, 1497, 1716,
				  1022, 1247, 1429, 1987, 2398,
				  1035, 1258, 1560, 2079, 2794,
				   970, 1087, 1446, 1828, 2465,
				   820,  861, 1126, 1549, 1962,
				   678,  738,  878, 1140, 1683,
				   640,  628,  656,  900, 1162,
				   497,  463,  536,  644,  865)				 
#	see also example below for generating labels

rates	&lt;- matrix(data=v.rates,nrow=11, ncol=5,byrow=TRUE)
cases	&lt;- matrix(data=v.cases,nrow=11, ncol=5,byrow=TRUE)

# 	A data list is now constructed as follows
#	note that list entry rates is redundant,
#	but included since it represents original data

data.Japanese.breast.cancer	&lt;- apc.data.list(response=cases,
			dose=cases/rates,data.format="AP",
			age1=25,per1=1955,coh1=NULL,unit=5,
			per.zero=NULL,per.max=NULL,time.adjust=0,
			label="Japanese breast cancer")

#	or when exploiting the default values

data.Japanese.breast.cancer	&lt;- apc.data.list(response=cases,
			dose=cases/rates,data.format="AP",
			age1=25,per1=1955,unit=5,
			label="Japanese breast cancer")

###################################################
# 	Code for generating labels

row.names &lt;- paste(as.character(seq(25,75,by=5)),"-",as.character(seq(29,79,by=5)),sep="")
col.names &lt;- paste(as.character(seq(1955,1975,by=5)),"-",as.character(seq(1959,1979,by=5)),sep="")

</code></pre>

<hr>
<h2 id='apc.data.list.subset'>Cut age, period and cohort groups from data set.</h2><span id='topic+apc.data.list.subset'></span>

<h3>Description</h3>

<p>For a recursive analysis it is useful to be able to cut age, period and cohort groups from a data set.
Function returns an <code><a href="#topic+apc.data.list">apc.data.list</a></code> with data.format &quot;trapezoid&quot;.
</p>
<p>When used with default values the function turns an <code><a href="#topic+apc.data.list">apc.data.list</a></code> into a new <code><a href="#topic+apc.data.list">apc.data.list</a></code>
with data.format &quot;trapezoid&quot; without reducing dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>apc.data.list.subset(apc.data.list,
							age.cut.lower=0,age.cut.upper=0,
							per.cut.lower=0,per.cut.upper=0,
							coh.cut.lower=0,coh.cut.upper=0,
							apc.index=NULL,
							suppress.warning=FALSE)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="apc.data.list.subset_+3A_apc.data.list">apc.data.list</code></td>
<td>
<p>List. See <code><a href="#topic+apc.data.list">apc.data.list</a></code> for a description of the format.</p>
</td></tr>
<tr><td><code id="apc.data.list.subset_+3A_age.cut.lower">age.cut.lower</code></td>
<td>
<p><em>Optional</em>. Numeric. Specifies how many age    groups to cut at lower end. Default is zero.</p>
</td></tr>
<tr><td><code id="apc.data.list.subset_+3A_per.cut.lower">per.cut.lower</code></td>
<td>
<p><em>Optional</em>. Numeric. Specifies how many period groups to cut at lower end. Default is zero.</p>
</td></tr>
<tr><td><code id="apc.data.list.subset_+3A_coh.cut.lower">coh.cut.lower</code></td>
<td>
<p><em>Optional</em>. Numeric. Specifies how many cohort groups to cut at lower end. Default is zero.</p>
</td></tr>
<tr><td><code id="apc.data.list.subset_+3A_age.cut.upper">age.cut.upper</code></td>
<td>
<p><em>Optional</em>. Numeric. Specifies how many age    groups to cut at upper end. Default is zero.</p>
</td></tr>
<tr><td><code id="apc.data.list.subset_+3A_per.cut.upper">per.cut.upper</code></td>
<td>
<p><em>Optional</em>. Numeric. Specifies how many period groups to cut at upper end. Default is zero.</p>
</td></tr>
<tr><td><code id="apc.data.list.subset_+3A_coh.cut.upper">coh.cut.upper</code></td>
<td>
<p><em>Optional</em>. Numeric. Specifies how many cohort groups to cut at upper end. Default is zero.</p>
</td></tr>
<tr><td><code id="apc.data.list.subset_+3A_apc.index">apc.index</code></td>
<td>
<p><em>Optional</em>. List. See <code><a href="#topic+apc.get.index">apc.get.index</a></code> for a description of the format.  If not provided this is computed internally.</p>
</td></tr>
<tr><td><code id="apc.data.list.subset_+3A_suppress.warning">suppress.warning</code></td>
<td>
<p><em>Optional</em>. Logical. Suppresses warnings. This is useful when generating data sums using
<code><a href="#topic+apc.data.sums">apc.data.sums</a></code> but reducing the data set so much that models cannot be fitted.</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>response</code></td>
<td>
<p>matrix (or vector).  Numbers of responses.</p>
</td></tr>
<tr><td><code>dose</code></td>
<td>
<p>matrix (or NULL).  Numbers of doses.</p>
</td></tr>
<tr><td><code>data.format</code></td>
<td>
<p>&quot;trapezoid&quot;</p>
</td></tr>
<tr><td><code>age1</code></td>
<td>
<p>Numeric.</p>
</td></tr>		
<tr><td><code>per1</code></td>
<td>
<p>Numeric.</p>
</td></tr>		
<tr><td><code>coh1</code></td>
<td>
<p>Numeric.</p>
</td></tr>		
<tr><td><code>unit</code></td>
<td>
<p>Numeric.</p>
</td></tr>		
<tr><td><code>per.zero</code></td>
<td>
<p>Numeric.</p>
</td></tr>
<tr><td><code>per.max</code></td>
<td>
<p>Numeric.</p>
</td></tr>
</table>


<h3>Arguments: Notes</h3>

<p>If apc.index is supplied then the input can be simplified.
It suffices to write
<code>apc.data.list = list(response=response,data.format=data.format,dose=dose)</code>,
where dose could be <code>dose=NULL</code>.
Likewise <code>apc.index</code> does not need to be a full <code>apc.index list</code>. It suffices to construct a list with entries
<code>age.max</code>,                                                         
<code>per.max</code>,                                                         
<code>coh.max</code>,
<code>age1</code>,
<code>per1</code>,
<code>coh1</code>,
<code>unit</code>,
<code>per.zero</code>,                                                        
<code>index.trap</code>,                                                      
<code>index.data</code>.                                                      
</p>


<h3>Author(s)</h3>

<p>Bent Nielsen &lt;bent.nielsen@nuffield.ox.ac.uk&gt; 4 Dec 2013 recoded 26 Apr 2017</p>


<h3>See Also</h3>

<p>The below example uses artificial data.  For an example using
<code><a href="#topic+data.asbestos">data.asbestos</a></code>
see 
<code><a href="#topic+apc.plot.fit">apc.plot.fit</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>###############
#	Artificial data
#	Generate a 5x7 matrix and make arbitrary decisions for rest

response &lt;- matrix(data=seq(1:35),nrow=5,ncol=7)
data.list	&lt;- list(response=response,dose=NULL,data.format="AP",
					age1=25,per1=1955,coh1=NULL,unit=5,
					per.zero=NULL,per.max=NULL,time.adjust=0)
data.list

apc.data.list.subset(data.list,1,1,0,0,0,0)


</code></pre>

<hr>
<h2 id='apc.data.sums'>Computes age, period and cohort sums of a matrix</h2><span id='topic+apc.data.sums'></span>

<h3>Description</h3>

<p>Computes age, period and cohort sums of a matrix. This is the same as taking column, row and diagonal sums. The match between the age, period and cohort sums and column, row and diagonal sums depends on the data format</p>


<h3>Usage</h3>

<pre><code class='language-R'>apc.data.sums(apc.data.list,data.type="r",
			average=FALSE,keep.incomplete=TRUE,apc.index=NULL)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="apc.data.sums_+3A_apc.data.list">apc.data.list</code></td>
<td>
<p>List. See <code><a href="#topic+apc.data.list">apc.data.list</a></code> for a description of the format.</p>
</td></tr>
<tr><td><code id="apc.data.sums_+3A_data.type">data.type</code></td>
<td>
<p>Optional. Character. &quot;r&quot;,&quot;d&quot;,&quot;m&quot; if sums are computed for responses,dose,(mortality) rates.  Rates are computed as responses/doses. &quot;r&quot; is default.</p>
</td></tr> 
<tr><td><code id="apc.data.sums_+3A_average">average</code></td>
<td>
<p>Optional.  Logical. If TRUE/FALSE reports averages/sums. Default is FALSE.</p>
</td></tr>
<tr><td><code id="apc.data.sums_+3A_keep.incomplete">keep.incomplete</code></td>
<td>
<p>Optional. Logical. If true perform calculation for incomplete sequences by removing NA.
If false incomplete sequences are NA.  See example. Default=TRUE.</p>
</td></tr>
<tr><td><code id="apc.data.sums_+3A_apc.index">apc.index</code></td>
<td>
<p>Optional. List. See <code><a href="#topic+apc.get.index">apc.get.index</a></code> for a description of the format.  If not provided this is computed.</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>sums.age</code></td>
<td>
<p>Vector. Sums/Averages over data.matrix by age.</p>
</td></tr>
<tr><td><code>sums.per</code></td>
<td>
<p>Vector. Sums/Averages over data.matrix by period.</p>
</td></tr>
<tr><td><code>sums.coh</code></td>
<td>
<p>Vector. Sums/Averages over data.matrix by cohort.</p>
</td></tr>
</table>


<h3>Arguments: Notes</h3>

<p>If apc.index is supplied then the input can be simplified.
For instance if <code>data.type="r"</code> then, for the first argument, it suffices to write
<code>apc.data.list = list(response=response)</code>.
Likewise <code>apc.index</code> does not need to be a full <code>apc.index list</code>. It suffices to construct a list with entries
<code>age.max</code>,                                                         
<code>per.max</code>,                                                         
<code>coh.max</code>,                                                         
<code>index.trap</code>,                                                      
<code>index.data</code>,                                                      
<code>per.zero</code>.                                                        
</p>


<h3>Author(s)</h3>

<p>Bent Nielsen &lt;bent.nielsen@nuffield.ox.ac.uk&gt; 15 Aug 2018 (15 Dec 2013)</p>


<h3>See Also</h3>

<p>The example below uses Japanese breast cancer data, see <code><a href="#topic+data.Japanese.breast.cancer">data.Japanese.breast.cancer</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>#####################
#  EXAMPLE with artificial data
#  generate a 3x4 matrix in "AP" data.format with the numbers 1..12

m.data  	&lt;- matrix(data=seq(length.out=12),nrow=3,ncol=4)
m.data
data.list	&lt;- apc.data.list(m.data,"AP")
apc.data.sums(data.list)

#	$sums.age
#	 [1] 22 26 30
#	$sums.per
#	[1]  6 15 24 33
#	$sums.coh
#	[1]  3  8 15 24 18 10

apc.data.sums(data.list,average=TRUE)
#	$sums.age
#	[1] 5.5 6.5 7.5
#	$sums.per
#	[1]  2  5  8 11
#	$sums.coh
#	[1]  3  4  5  8  9 10

apc.data.sums(data.list,keep.incomplete=FALSE)
#	$sums.age
#	 [1] 22 26 30
#	$sums.per
#	[1]  6 15 24 33
#	$sums.coh
#	[1]  NA NA 15 24 NA NA

#####################
#	EXAMPLE with Japanese breast cancer data

data.list	&lt;- data.Japanese.breast.cancer()	#	function gives data list
apc.data.sums(data.list)

#	$sums.age
#	[1]  573 2089 4053 6220 8083 8726 7796 6318 5117 3986 3005
#	$sums.per
#	[1]  7519  8332 10064 13183 16868
#	$sums.coh
#	[1]  497 1103 1842 2858 4474 5550 6958 7471 7531 6931 5111 3080 1666  715  179

#	Compare with the response matrix

data.list$response

#	      1955-1959 1960-1964 1965-1969 1970-1974 1975-1979
#	25-29        88        78       101       127       179
#	30-34       299       330       363       509       588
#	35-39       596       680       798       923      1056
#	40-44       874       962      1171      1497      1716
#	45-49      1022      1247      1429      1987      2398
#	50-54      1035      1258      1560      2079      2794
#	55-59       970      1087      1446      1828      2465
#	60-64       820       861      1126      1549      1962
#	65-69       678       738       878      1140      1683
#	70-74       640       628       656       900      1162
#	75-79       497       463       536       644       865

</code></pre>

<hr>
<h2 id='apc.fit.model'>Fits an age period cohort model</h2><span id='topic+apc.fit.model'></span><span id='topic+apc.fit.table'></span>

<h3>Description</h3>

<p><code>apc.fit.model</code> fits the age period cohort model as a Generalized Linear Model using <code><a href="stats.html#topic+glm.fit">glm.fit</a></code>.
The model is parametrised in terms of the canonical parameter introduced by Kuang, Nielsen and Nielsen (2008),
see also the implementation in Martinez Miranda, Nielsen and Nielsen (2015).
This parametrisation has a number of advantages: it is freely varying, it is the canonical parameter of a
regular exponential family, and it is invariant to extentions of the data matrix.
Other parametrizations can be computed using <code>apc.identify</code>.
</p>
<p><code>apc.fit.model</code> can be be used for all three age period cohort factors, or for submodels with fewer of these factors. 
</p>
<p><code>apc.fit.model</code> can be used either for mortality rates through a dose-response model or for mortality counts through a pure response model without doses/exposures.  
</p>
<p>The GLM families include Poisson regressions (with log link) and Normal/Gaussian least squares regressions.  
</p>
<p>apc.fit.table produces a deviance table for 15 combinations of the three factors and linear trends:
&quot;APC&quot;, &quot;AP&quot;, &quot;AC&quot;, &quot;PC&quot;, &quot;Ad&quot;, &quot;Pd&quot;, &quot;Cd&quot;, &quot;A&quot;, &quot;P&quot;, &quot;C&quot;, &quot;t&quot;, &quot;tA&quot;, &quot;tP&quot;, &quot;tC&quot;, &quot;1&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>	apc.fit.model(apc.data.list,model.family,model.design,apc.index=NULL,
			replicate.version.1.3.1=FALSE)
		apc.fit.table(apc.data.list,model.family,model.design.reference="APC",
			apc.index=NULL)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="apc.fit.model_+3A_apc.data.list">apc.data.list</code></td>
<td>
<p>List. See <code><a href="#topic+apc.data.list">apc.data.list</a></code> for a description of the format.</p>
</td></tr>
<tr><td><code id="apc.fit.model_+3A_model.family">model.family</code></td>
<td>
<p>Character.  The following options are implemented.	These are used internally when
calling <code><a href="stats.html#topic+glm.fit">glm.fit</a></code>.		
</p>

<dl>
<dt>&quot;poisson.response&quot;</dt><dd><p>This sets family=poisson(link=&quot;log&quot;). Only responses are used.
Inference is done in a multinomial model, conditioning on the overall level
as documented in Martinez Miranda, Nielsen and Nielsen (2015).</p>
</dd>
<dt>&quot;od.poisson.response&quot;</dt><dd><p>This sets family=quasipoisson(link=&quot;log&quot;) in the estimation step,
but then reverts to family=poisson(link=&quot;log&quot;) when computing standard errors, which are then corrected.
Only responses are used.
Inference is done in an over-dispersed Poisson model
as documented in Harnau and Nielsen (2016).
Note that limit distributions are t and F not normal and chi2.</p>
</dd>
<dt>&quot;poisson.dose.response&quot;</dt><dd><p>This sets family=poisson(link=&quot;log&quot;). Doses are used as offset.</p>
</dd>
<dt>&quot;binomial.dose.response&quot;</dt><dd><p>This sets family=binomial(link=&quot;logit&quot;) and gives a logistic regression.</p>
</dd>
<dt>&quot;gaussian.rates&quot;</dt><dd><p>This sets family=gaussian(link=&quot;identity&quot;).
The dependent variable is the mortality rates, which are computed
as response/dose.</p>
</dd>
<dt>&quot;gaussian.response&quot;</dt><dd><p>This sets family=gaussian(link=&quot;identity&quot;).  Only responses are used.
The dependent variable is the responses.</p>
</dd>
<dt>&quot;log.normal.rates&quot;</dt><dd><p>Gaussian regression for log(rates) and with identity link (Least Squares).</p>
</dd>	
<dt>&quot;log.normal.response&quot;</dt><dd><p>Gaussian regression for log(response) and with identity link (Least Squares).</p>
</dd>	
</dl>
</td></tr>
<tr><td><code id="apc.fit.model_+3A_model.design">model.design</code></td>
<td>
<p>Character.  This indicates the design choice.  The following options are possible.
</p>

<dl>
<dt>&quot;APC&quot;</dt><dd><p>Age-period-cohort model.</p>
</dd>
<dt>&quot;AP&quot; </dt><dd><p>Age-period model. Nested in &quot;APC&quot;</p>
</dd>
<dt>&quot;AC&quot; </dt><dd><p>Age-cohort model. Nested in &quot;APC&quot;</p>
</dd>
<dt>&quot;PC&quot; </dt><dd><p>Period-cohort model. Nested in &quot;APC&quot;</p>
</dd>
<dt>&quot;Ad&quot; </dt><dd><p>Age-trend model, including age effect and two linear trends. Nested in &quot;AP&quot;, &quot;AC&quot;.</p>
</dd>
<dt>&quot;Pd&quot; </dt><dd><p>Period-trend model, including period effect and two linear trends. Nested in &quot;AP&quot;, &quot;PC&quot;.</p>
</dd>
<dt>&quot;Cd&quot; </dt><dd><p>Cohort-trend model, including cohort effect and two linear trends. Nested in &quot;AC&quot;, &quot;PC&quot;.</p>
</dd>
<dt>&quot;A&quot;  </dt><dd><p>Age model. Nested in &quot;Ad&quot;.</p>
</dd>      
<dt>&quot;P&quot;  </dt><dd><p>Period model. Nested in &quot;Pd&quot;.</p>
</dd>
<dt>&quot;C&quot;  </dt><dd><p>Cohort model. Nested in &quot;Cd&quot;.</p>
</dd>
<dt>&quot;t&quot;  </dt><dd><p>Trend model, with two linear trends. Nested in &quot;Ad&quot;, &quot;Pd&quot;, &quot;Cd&quot;.</p>
</dd>
<dt>&quot;tA&quot; </dt><dd><p>Single trend model in age index. Nested in &quot;A&quot;, &quot;t&quot;.</p>
</dd>
<dt>&quot;tP&quot; </dt><dd><p>Single trend model in period index. Nested in &quot;P&quot;, &quot;t&quot;.</p>
</dd>
<dt>&quot;tC&quot; </dt><dd><p>Single trend model in cohort index. Nested in &quot;C&quot;, &quot;t&quot;.</p>
</dd>
<dt>&quot;1&quot;  </dt><dd><p>Constant model. Nested in &quot;tA&quot;, &quot;tP&quot;, &quot;tC&quot;.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="apc.fit.model_+3A_model.design.reference">model.design.reference</code></td>
<td>
<p>Character.  This indicates the reference design choice for the deviance table. Choices are
&quot;APC&quot;,&quot;AP&quot;,&quot;AC&quot;,&quot;PC&quot;,&quot;Ad&quot;,&quot;Pd&quot;,&quot;Cd&quot;,&quot;A&quot;,&quot;P&quot;,&quot;C&quot;,&quot;t&quot;. Default is &quot;APC&quot;.</p>
</td></tr>	
<tr><td><code id="apc.fit.model_+3A_apc.index">apc.index</code></td>
<td>
<p><em>Optional</em>. List. See <code><a href="#topic+apc.get.index">apc.get.index</a></code> for a description of the format.
If not provided this is computed internally.
If <code>apc.fit.model</code> is used in a simulation study computational effort can be saved when
using this option.</p>
</td></tr>
<tr><td><code id="apc.fit.model_+3A_replicate.version.1.3.1">replicate.version.1.3.1</code></td>
<td>
<p><em>Optional</em>. Logical. Replicate error in covariance calculation for 
&quot;poisson.response&quot;,&quot;od.poisson.response&quot; in versions 1.2.3-1.3.1. Default=FALSE</p>
</td></tr>		
</table>


<h3>Value</h3>

<p><em>apc.fit.table</em>
produces a deviance table.  There are 15 rows corresponding to all possible design choices.
The columns are as follows.
</p>
<table role = "presentation">
<tr><td><code>"-2logL"</code></td>
<td>
<p>-2 log Likelihood up to some constant.
If the model family is Poisson or binomial (logistic)
this is the same as the <code><a href="stats.html#topic+glm">glm</a></code> deviance: That is the difference in -2 log likelihood value between estimated
model and the saturated model.
If the model family is Gaussian it is different from the traditional
<code><a href="stats.html#topic+glm">glm</a></code> deviance.  Here the -2 log likelihood value is measured in a model with unknown variance,
which is the standard in regression analysis, whereas in the <code><a href="stats.html#topic+glm">glm</a></code> package the deviance
is the residual sum of squares, which can be interpreted as the 
-2 log likelihood value in a model with variance set to one.</p>
</td></tr>
<tr><td><code>"df.residual"</code></td>
<td>
<p>Degrees of freedom of residual: nrow x ncol - dim(parameter).
If the model.family=&quot;poisson.response&quot; the degrees of freedom is one lower.</p>
</td></tr>
<tr><td><code>"prob(&gt;chi_sq)"</code></td>
<td>
<p>p-value of the deviance, -2logL. Left out in Gaussian case which has no saturated model</p>
</td></tr>
<tr><td><code>"LR vs APC"</code></td>
<td>
<p>the likelihood ratio statistic against the &quot;APC&quot; model.</p>
</td></tr>
<tr><td><code>"df"</code></td>
<td>
<p>Degrees of freedom against the &quot;APC&quot; model.</p>
</td></tr>
<tr><td><code>"prob(&gt;chi_sq)"</code></td>
<td>
<p>p-value of log likelihood ratio statistic.</p>
</td></tr>
<tr><td><code>"aic"</code></td>
<td>
<p>Akaike's &quot;An Information Criterion&quot;, minus twice the maximized log-likelihood plus twice the
number of parameters upto a constant.  It is take directly from the
<code><a href="stats.html#topic+glm">glm</a></code> function.  
For the &quot;poisson.dose.response&quot; and &quot;binomial.dose.response&quot; model families
the dispersion is fixed at one and the number of parameters is the number of coefficients.
The &quot;poisson.response&quot; model is conditional on the level.  The number of parameters should therefore be
adjusted by subtracting 2 to take this into account to get the proper AIC. However, in practice this does not matter,
since we are only interested in relative effects. 
For the &quot;gaussian.response&quot; and &quot;gaussian.dose.response&quot; model families the dispersion is estimated from
the residual deviance. </p>
</td></tr>
<tr><td><code>"F"</code></td>
<td>
<p>Only for &quot;od.poisson.response&quot;. F statistic: Ratio of deviance for submodel divided by degrees of freedom to deviance of apc model divided by degrees of freedom.</p>
</td></tr>
<tr><td><code>"prof(&gt;F)"</code></td>
<td>
<p>Only for &quot;od.poisson.response&quot;. F statistic: with degrees of freedom given by differences between sub-model and apc model and between apc model and saturated model.</p>
</td></tr>
</table>
<p><em>apc.fit.model</em>
returns a list. The entries are as follows.
</p>
<table role = "presentation">
<tr><td><code>fit</code></td>
<td>
<p>List. Values from <code><a href="stats.html#topic+glm.fit">glm.fit</a></code>.</p>
</td></tr>
<tr><td><code>apc.index</code></td>
<td>
<p>List. Values from <code><a href="#topic+apc.get.index">apc.get.index</a></code>.</p>
</td></tr>	  
<tr><td><code>coefficients.canonical</code></td>
<td>
<p>Matrix.  For each coordinate of the canonical parameters is reported coefficient, standard deviation, z-value, which is the ratio of those, and asymptotically normal p-values.
Note, for &quot;od.poisson.response&quot; the reported standard errors corrected by the deviance and p-values are asymptotically t distributed, see Harnau and Nielsen (2016).
Other parametrizations can be computed using <code>apc.identify</code>.</p>
</td></tr>
<tr><td><code>covariance.canonical</code></td>
<td>
<p>Matrix.  Estimated covariance matrix for canonical parameters.</p>
</td></tr>
<tr><td><code>slopes</code></td>
<td>
<p>Vector.  Length three.  The design matrix found by <code><a href="#topic+apc.get.design.collinear">apc.get.design.collinear</a></code> has age, period, and cohort linear trends. <code>slopes</code> indicates which of these are actually used in estimation.</p>
</td></tr>
<tr><td><code>difdif</code></td>
<td>
<p>Vector.  Length three.  The design matrix found by <code><a href="#topic+apc.get.design.collinear">apc.get.design.collinear</a></code> has age, period, and cohort double differences. <code>slopes</code> indicates which of these are actually used in estimation.</p>
</td></tr>
<tr><td><code>index.age</code></td>
<td>
<p>Vector.  Indices for age    double difference parameters within <code>coefficients.canonical</code>.  NULL if age    double differences are not estimated.</p>
</td></tr>
<tr><td><code>index.per</code></td>
<td>
<p>Vector.  Indices for period double difference parameters within <code>coefficients.canonical</code>.  NULL if period double differences are not estimated.</p>
</td></tr>
<tr><td><code>index.coh</code></td>
<td>
<p>Vector.  Indices for cohort double difference parameters within <code>coefficients.canonical</code>.  NULL if cohort double differences are not estimated.</p>
</td></tr>
<tr><td><code>dates</code></td>
<td>
<p>Vector.  Indicates the dates for the double difference parameters within <code>coefficients.canonical</code>.</p>
</td></tr>
<tr><td><code>model.family</code></td>
<td>
<p>Character. Argument.</p>
</td></tr>
<tr><td><code>model.design</code></td>
<td>
<p>Character. Argument.</p>
</td></tr>
<tr><td><code>RSS</code></td>
<td>
<p>Numeric.  Residual sum of squares.  NULL for non-gaussian families.</p>
</td></tr>
<tr><td><code>sigma2</code></td>
<td>
<p>Numeric.  Maximum likelihood estimator for variance: RSS/n.  NULL for non-gaussian families.</p>
</td></tr>
<tr><td><code>s2</code></td>
<td>
<p>Numeric.  Least squares estimator for variance: RSS/df.  NULL for non-gaussian families.</p>
</td></tr>
<tr><td><code>n.decimal</code></td>
<td>
<p>Numeric.  From <code><a href="#topic+apc.data.list">apc.data.list</a></code>.</p>
</td></tr>
<tr><td><code>predictors</code></td>
<td>
<p>Vector. Design*Estimates.                                          
Same as the <code><a href="stats.html#topic+glm.fit">glm.fit</a></code> value <code>linear.predictors</code> when there is no offset.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>For gaussian families <em>deviance</em> is defined differently in <code>apc</code> and <code><a href="stats.html#topic+glm">glm</a></code>.
Here it is -2 log likelihood.  In <code><a href="stats.html#topic+glm">glm</a></code> it is RSS.
</p>
<p>The values for <code>apc.fit.model</code> include the <code><a href="#topic+apc.data.list">apc.data.list</a></code> and the <code>apc.index</code> returned by
<code><a href="#topic+apc.get.index">apc.get.index</a></code>.
</p>
<p>For the <code>poisson.response</code> the inference is conditional on the level, see Martinez Miranda, Nielsen and Nielsen (2015).
The <code>coefficients.canonical</code> computed by <code>apc</code> are therefore different from the default <code>coefficients</code> computed by <code>glm</code>.
</p>
<p>For the <code>od.poisson.response</code> an asymptotic theory is used that mimics the conditioning for <code>poisson.response</code>.
The asymptotic distribution are, however, asymptotically t or F distributed, see Harnau and Nielsen (2017).
</p>
<p>For the <code>log.normal.response</code> standard normal theory applies for quantities on the log scale including estimators.
An asymptotic theory for quantities on the original scale is provided in Kuang and Nielsen (2018). 
</p>
<p>For <code>coefficients</code> the 3rd and 4th columns have headings <code>t value</code> and <code>Pr(&gt;|t|)</code> for <code>od.poisson.response</code>
to indicate an asymptotic t theory
and otherwise
<code>z value</code> and <code>Pr(&gt;|z|)</code> to indicate an asymptotic normal theory. The labels are inherited from <code><a href="stats.html#topic+glm.fit">glm.fit</a></code>.
</p>


<h3>Author(s)</h3>

<p>Bent Nielsen &lt;bent.nielsen@nuffield.ox.ac.uk&gt; 15 Aug 2018 (27 Aug 2014)</p>


<h3>References</h3>

<p>Harnau, J. and Nielsen (2016) Over-dispersed age-period-cohort models. To appear in <em>Journal of the American Statistical Association</em>. <em>Download</em>: <a href="https://www.nuffield.ox.ac.uk/economics/papers/2017/HarnauNielsen2017apcDP.pdf">Nuffield DP</a>
</p>
<p>Kuang, D, Nielsen B (2018) Generalized log-normal chain-ladder. mimeo Nuffield Collge.
</p>
<p>Kuang, D., Nielsen, B. and Nielsen, J.P. (2008a) Identification of the age-period-cohort model and the extended chain ladder model. Biometrika 95, 979-986. <em>Download</em>: <a href="https://doi.org/10.1093/biomet/asn026">Article</a>; Earlier version <a href="http://www.nuffield.ox.ac.uk/economics/papers/2007/w5/KuangNielsenNielsen07.pdf">Nuffield DP</a>.
</p>
<p>Martinez Miranda, M.D., Nielsen, B. and Nielsen, J.P. (2015) Inference and forecasting in the age-period-cohort model with unknown exposure with an application to mesothelioma mortality. <em>Journal of the Royal Statistical Society</em> A 178, 29-55. <em>Download</em>: <a href="https://doi.org/10.1111/rssa.12051">Article</a>, <a href="http://www.nuffield.ox.ac.uk/economics/papers/2013/Asbestos8mar13.pdf">Nuffield DP</a>. 
</p>


<h3>See Also</h3>

<p>The fit is done using <code><a href="stats.html#topic+glm.fit">glm.fit</a></code>.
</p>
<p>The examples below use Italian bladder cancer data, see <code><a href="#topic+data.Italian.bladder.cancer">data.Italian.bladder.cancer</a></code>
and
Belgian lung cancer data, see <code><a href="#topic+data.Belgian.lung.cancer">data.Belgian.lung.cancer</a></code>.
</p>
<p>In example 3 the design matrix is called is called using <code><a href="#topic+apc.get.design">apc.get.design</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#####################
#	EXAMPLE 1 with Italian bladder cancer data

data.list	&lt;- data.Italian.bladder.cancer()	#	function gives data list
apc.fit.table(data.list,"poisson.dose.response")

#	       -2logL df.residual prob(&gt;chi_sq) LR.vs.APC df.vs.APC prob(&gt;chi_sq)       aic
#	APC    33.179          27         0.191        NA        NA            NA   487.624
#	AP    512.514          40         0.000   479.335        13         0.000   940.958
#	AC     39.390          30         0.117     6.211         3         0.102   487.835
#	PC   1146.649          36         0.000  1113.470         9         0.000  1583.094
#	Ad    518.543          43         0.000   485.364        16         0.000   940.988
#	Pd   4041.373          49         0.000  4008.194        22         0.000  4451.818
#	Cd   1155.629          39         0.000  1122.450        12         0.000  1586.074
#	A    2223.800          44         0.000  2190.621        17         0.000  2644.245
#	P   84323.944          50         0.000 84290.765        23         0.000 84732.389
#	C   23794.205          40         0.000 23761.026        13         0.000 24222.650
#	t    4052.906          52         0.000  4019.727        25         0.000  4457.351
#	tA   5825.158          53         0.000  5791.979        26         0.000  6227.602
#	tP  84325.758          53         0.000 84292.579        26         0.000 84728.203
#	tC  33446.796          53         0.000 33413.617        26         0.000 33849.241
#	1   87313.678          54         0.000 87280.499        27         0.000 87714.123
#
#	Table suggests that "APC" and "AC" fit equally well.  Try both

fit.apc	&lt;- apc.fit.model(data.list,"poisson.dose.response","APC")
fit.ac	&lt;- apc.fit.model(data.list,"poisson.dose.response","AC")

#	Compare the estimates: They are very similar

fit.apc$coefficients.canonical
fit.ac$coefficients.canonical

#####################
#	EXAMPLE 2 with Belgian lung cancer data
#	This example illustrates how to find the linear predictors 

data.list	&lt;- data.Belgian.lung.cancer()

#	Get an APC fit

fit.apc	&lt;- apc.fit.model(data.list,"poisson.dose.response","APC")

#	The linear predictor of the fit is a vector.
#	But, we would like it in the same format as the data.
#	Thus create matrix of same dimension as response data
#	This can be done in two ways

m.lp	&lt;- data.list$response	#	using original information	
m.lp	&lt;- fit.apc$response		# 	using information copied when fitting

#	the fit object index.data is used to fill linear predictor in
#	vector format into matrix format

m.lp[fit.apc$index.data]	&lt;-fit.apc$linear.predictors
exp(m.lp)

#####################
#	EXAMPLE 3 with Belgian lung cancer data
#	This example illustrates how apc.fit.model works.

data.list	&lt;- data.Belgian.lung.cancer()

#	Vectorise data
index		&lt;- apc.get.index(data.list)
v.response	&lt;- data.list$response[index$index.data]
v.dose		&lt;- data.list$dose[index$index.data]

#	Get design
m.design	&lt;- apc.get.design(index,"APC")$design

#	Fit using glm.fit from stats package
fit.apc.glm	&lt;- glm.fit(m.design,v.response,family=poisson(link="log"),offset=log(v.dose))

#	Get canonical coefficients
v.cc		&lt;- fit.apc.glm$coefficients

#	Find linear predictors and express in matrix form
m.fit		&lt;- data.list$response			#	create matrix
m.fit[index$index.data]		&lt;- m.design 
m.fit.offset		&lt;- m.fit + log(data.list$dose)	#	add offset
exp(m.fit.offset)

#	Compare with linear.predictors from glm.fit
#	difference should be zero
sum(abs(m.fit.offset[index$index.data]-fit.apc.glm$linear.predictors))

#####################
#	EXAMPLE 4 with Taylor-Ashe loss data
#	This example illustrates the over-dispersed poisson response model.

data &lt;- data.loss.TA()
fit.apc.od &lt;- apc.fit.model(data,"od.poisson.response","APC")
fit.apc.od$coefficients.canonical[1:5,]
fit.apc.no.od &lt;- apc.fit.model(data,"poisson.response","APC")
fit.apc.no.od$coefficients.canonical[1:5,]
</code></pre>

<hr>
<h2 id='apc.forecast'>Forecasts from age-period-cohort models.</h2><span id='topic+apc.forecast'></span>

<h3>Description</h3>

<p>In general forecasts from age-period-cohort models require extrapolation of the estimated parameters.
This has to be done without introducing identifications problems, see
Kuang, Nielsen and Nielsen (2008b,2011).
There are many different possibilities for extrapolation for the different sub-models.
The extrapolation results in point forecasts.
Distribution forecasts should be build on top of these, see
Martinez Miranda, Nielsen and Nielsen (2015)
and
Harnau and Nielsen (2016).
At present three experimental functions
<code><a href="#topic+apc.forecast.ac">apc.forecast.ac</a></code>,
<code><a href="#topic+apc.forecast.apc">apc.forecast.apc</a></code>
and
<code><a href="#topic+apc.forecast.ap">apc.forecast.ap</a></code>
are available.
</p>


<h3>Author(s)</h3>

<p>Bent Nielsen &lt;bent.nielsen@nuffield.ox.ac.uk&gt; 10 Sep 2016 (1 Feb 2016)</p>


<h3>References</h3>

<p>Harnau, J. and Nielsen (2016) Over-dispersed age-period-cohort models. To appear in <em>Journal of the American Statistical Association</em>. <em>Download</em>: <a href="https://www.nuffield.ox.ac.uk/economics/papers/2017/HarnauNielsen2017apcDP.pdf">Nuffield DP</a>
</p>
<p>Kuang, D., Nielsen, B. and Nielsen, J.P. (2008b) Forecasting with the age-period-cohort model and the extended chain-ladder model. Biometrika 95, 987-991. <em>Download</em>: <a href="https://doi.org/10.1093/biomet/asn038">Article</a>; Earlier version <a href="http://www.nuffield.ox.ac.uk/economics/papers/2008/w9/KuangNielsenNielsen_Forecast.pdf">Nuffield DP</a>.
</p>
<p>Kuang, D., Nielsen B. and Nielsen J.P. (2011) Forecasting in an extended chain-ladder-type model. Journal of Risk and Insurance 78, 345-359. <em>Download</em>: <a href="http://dx.doi.org/10.1111/j.1539-6975.2010.01395.x">Article</a>; Earlier version: <a href="http://www.nuffield.ox.ac.uk/economics/papers/2010/w5/Forecast24jun10.pdf">Nuffield DP</a>. 
</p>
<p>Martinez Miranda, M.D., Nielsen, B. and Nielsen, J.P. (2015) Inference and forecasting in the age-period-cohort model with unknown exposure with an application to mesothelioma mortality. <em>Journal of the Royal Statistical Society</em> A 178, 29-55. <em>Download</em>: <a href="https://doi.org/10.1111/rssa.12051">Article</a>, <a href="http://www.nuffield.ox.ac.uk/economics/papers/2013/Asbestos8mar13.pdf">Nuffield DP</a>. 
</p>

<hr>
<h2 id='apc.forecast.ac'>Forecast for responses model with AC or CL structure.</h2><span id='topic+apc.forecast.ac'></span>

<h3>Description</h3>

<p>Computes forecasts for a model with AC or Chain Ladder structure.
Forecasts of the linear predictor are given for all models.
Distributions forecasts are provided for a Poisson response model (using Martinez Miranda, Nielsen and Nielsen, 2015),
for an over-dispersed Poisson response model (using Harnau and Nielsen, 2017)
and
for a log normal response model (using Kuang and Nielsen, 2018)
This is done for the triangle which shares age and cohort indices with the data.</p>


<h3>Usage</h3>

<pre><code class='language-R'>apc.forecast.ac(apc.fit,sum.per.by.age=NULL,
			sum.per.by.coh=NULL, quantiles=NULL, suppress.warning=TRUE)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="apc.forecast.ac_+3A_apc.fit">apc.fit</code></td>
<td>
<p>List. Output from <code><a href="#topic+apc.fit.model">apc.fit.model</a></code>.
Note: apc.fit.model should be run with AC structure so that 
<code>apc.fit$model.design=="AC"</code>.
Distribution forecasts are only provided for a Poisson response model where
<code>apc.fit$model.family=="poisson.response"</code>
for an over-disperse Poisson response model where
<code>apc.fit$model.family=="poisson.response"</code>
and
for a log normal response model where
<code>apc.fit$model.family=="log.normal.response"</code>.
For other models only point forecasts of the linear predictor are provided, that is
the first two values <code>linear.predictors.forecast</code> and <code>index.trap.J</code>.</p>
</td></tr>
<tr><td><code id="apc.forecast.ac_+3A_sum.per.by.age">sum.per.by.age</code></td>
<td>
<p><em>Optional</em>. Vector.  If not NULL it will generate forecasts by period,
where, for each period, the point forecasts are cummulated over certain age groups.
Indicates which age groups. If <code>sum.per.by.age</code> is a scalar or vector of length one it
represents a single age group. Point forecasts are made for the indicated age group.
If <code>sum.per.by.age</code> is a vector of length two it represents lower and upper values
of an range of age groups. Point forecasts are cummulated over the indicated age groups.</p>
</td></tr>
<tr><td><code id="apc.forecast.ac_+3A_sum.per.by.coh">sum.per.by.coh</code></td>
<td>
<p><em>Optional</em>. Vector.  Same as <code>sum.per.by.age</code>, but for cohort instead of age.</p>
</td></tr>
<tr><td><code id="apc.forecast.ac_+3A_quantiles">quantiles</code></td>
<td>
<p><em>Optional</em>. Vector.  Generates forecast quantiles for indicated quantiles.  Example:
<code>quantiles=c(0.05,0.50,0.95)</code>. Default is NULL.</p>
</td></tr>
<tr><td><code id="apc.forecast.ac_+3A_suppress.warning">suppress.warning</code></td>
<td>
<p>Logical. If true, suppresses warnings from <code><a href="#topic+apc.data.list.subset">apc.data.list.subset</a></code>, which is called internally. Default is &quot;TRUE&quot;.</p>
</td></tr>											
</table>


<h3>Details</h3>

<p>The default output only reports standard errors.
By setting the argument
<code>quantiles</code>
to, for instance,
<code>quantiles=c(0.05,0.50,0.95)</code>
forecast quantiles are reported.
</p>
<p><em>Poisson response forecast errors</em>.
The asymptotic theory for the Poisson forecast standard errors is presented in
Martinez Miranda, Nielsen and Nielsen (2015).
The sampling theory is based on multinomial model, conditional on the total number of outcomes.
Asymptotically this gives a normal theory.
There are two independent contributions to the forecast error:
a process error and an estimation error.
The empirical example of that paper uses the data
<code><a href="#topic+data.asbestos">data.asbestos</a></code>.
The results of that paper are reproduced in
the vignette 
<a href="../doc/ReproducingMMNN2015.pdf"><code>ReproducingMMNN2015.pdf</code></a>,
<a href="../doc/ReproducingMMNN2015.R"><code>ReproducingMMNN2015.R</code></a>
on
<a href="../doc/index.html"><code>Vignettes</code></a>.		
</p>
<p><em>Overdispersed Poisson response forecast errors</em>.
The asymptotic theory for the overdispersed Poission forecast standard errors is presented in
Harnau and Nielsen (2018).
The sampling theory is based on infinitely devisible distributions, with the
compound Poisson distribution as a special case.
This results in scale nuisance parameter, which is estimated by
the deviance of the AC model divided by the degrees of freedom.
Asymptotically this gives a t/F theory.
There are three independent contributions to the forecast error:
a process error, an estimation error and a sampling error for the overall mean.
</p>
<p><em>Generalized log normal forecast errors</em>.
Uses the asymptotic theory present in Kuang and Nielsen (2018).
The sampling theory is based on infinitely devisible distributions,
using small sigma asymptotics.
There are two independent contributions to the forecast error:
a process error and an estimation error.
</p>
<p>The examples below are based on the smaller data reserving sets
<code><a href="#topic+data.loss.VNJ">data.loss.VNJ</a></code>,
<code><a href="#topic+data.loss.TA">data.loss.TA</a></code>.
See also
<code><a href="#topic+data.loss.XL">data.loss.XL</a></code>.	
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>linear.predictors.forecast</code></td>
<td>
<p>Vector. Linear predictors for forecast area.</p>
</td></tr>
<tr><td><code>index.trap.J</code></td>
<td>
<p>Matrix. age-coh coordinates for vector. Similar structure to
<code>index.trap</code> in <code>apc.index</code>, see <code><a href="#topic+apc.get.index">apc.get.index</a></code>.</p>
</td></tr>
<tr><td><code>trap.response.forecast</code></td>
<td>
<p>Matrix. Includes data and point forecasts. Forecasts in lower right triangle. Trapezoid format.</p>
</td></tr>
<tr><td><code>response.forecast.cell</code></td>
<td>
<p>Matrix. 4 columns.
1: Point forecasts.
2: corresponding forecast standard errors
3: process standard errors
4: estimation standard errors
Note that the square of column 2 equals the sums of squares of columns 3 and 4
Note that <code>index.trap.J</code> gives the age-coh coordinates for each entry.</p>
</td></tr> 
<tr><td><code>response.forecast.age</code></td>
<td>
<p>Same as <code>response.forecast.cell</code>,
but point forecasts by <code>age</code> cumulated over period/cohort.</p>
</td></tr>
<tr><td><code>response.forecast.per</code></td>
<td>
<p>Same as <code>response.forecast.cell</code>,
but point forecasts by <code>per</code> cumulated over age/cohort.</p>
</td></tr>
<tr><td><code>response.forecast.per.ic</code></td>
<td>
<p>Same as response.forecast.cell,
but point forecasts cumulated by per and intercept corrected by
multiplying column 1 of <code>response.forecast.per</code> by <code>intercept.correction.per</code>.</p>
</td></tr>
<tr><td><code>response.forecast.coh</code></td>
<td>
<p>Same as <code>response.forecast.cell</code>,
but point forecasts by <code>coh</code> cumulated over age/period.</p>
</td></tr>
<tr><td><code>response.forecast.all</code></td>
<td>
<p>Same as <code>response.forecast.cell</code>,
but point forecasts cumulated by <code>age</code> and <code>coh</code>.</p>
</td></tr>
<tr><td><code>response.forecast.per.by.age</code></td>
<td>
<p>Only if <code>sum.per.by.age!=NULL</code>.
Same as <code>response.forecast.per</code>,
but point forecasts cumulated over ages indicated by <code>sum.per.by.age</code>.</p>
</td></tr>	
<tr><td><code>response.forecast.per.by.age.ic</code></td>
<td>
<p>Only if <code>sum.per.by.age!=NULL</code>.
Same as <code>response.forecast.per.by.age</code>,
but intercept corrected using <code>intercept.correction.per.by.age</code>.</p>
</td></tr>
<tr><td><code>response.forecast.per.by.coh</code></td>
<td>
<p>Only if <code>sum.per.by.coh!=NULL</code>.
Same as <code>response.forecast.per</code>,
but point forecasts cumulated over cohorts indicated by <code>sum.per.by.coh</code>.</p>
</td></tr>
<tr><td><code>response.forecast.per.by.coh.ic</code></td>
<td>
<p>Only if <code>sum.per.by.coh!=NULL</code>.
Same as <code>response.forecast.per.by.coh</code>,
but intercept corrected using <code>intercept.correction.per.by.coh</code>.</p>
</td></tr>
<tr><td><code>intercept.correction.per</code></td>
<td>
<p>Numeric.
The intercept correction is constructed as the ratio of
the sum of data entries for the last period and the sum of the corresponding fitted values.</p>
</td></tr>
<tr><td><code>intercept.correction.per.by.age</code></td>
<td>
<p>Numeric. Only if <code>sum.per.by.age!=NULL</code>.</p>
</td></tr>
<tr><td><code>intercept.correction.per.by.coh</code></td>
<td>
<p>Numeric. Only if <code>sum.per.by.coh!=NULL</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Bent Nielsen &lt;bent.nielsen@nuffield.ox.ac.uk&gt; 18 November 2019 (2 Mar 2016)</p>


<h3>References</h3>

<p>Harnau, J. and Nielsen (2018) Over-dispersed age-period-cohort models. <em>Journal of the American Statistical Association</em> 113, 1722-1732. <em>Download</em>: <a href="https://www.nuffield.ox.ac.uk/economics/papers/2017/HarnauNielsen2017apcDP.pdf">Nuffield DP</a>
</p>
<p>Martinez Miranda, M.D., Nielsen, B. and Nielsen, J.P. (2015) Inference and forecasting in the age-period-cohort model with unknown exposure with an application to mesothelioma mortality. <em>Journal of the Royal Statistical Society</em> A 178, 29-55. <em>Download</em>: <a href="https://doi.org/10.1111/rssa.12051">Article</a>, <a href="http://www.nuffield.ox.ac.uk/economics/papers/2013/Asbestos8mar13.pdf">Nuffield DP</a>. 
</p>
<p>Martinez Miranda, M.D., Nielsen, B., Nielsen, J.P. and Verrall, R. (2011) Cash flow simulation for a model of outstanding liabilities based on claim amounts and claim numbers. <em>ASTIN Bulletin</em> 41, 107-129.
</p>
<p>Kuang, D, Nielsen B (2018) Generalized log-normal chain-ladder. mimeo Nuffield Collge.
</p>


<h3>See Also</h3>

<p>The example below uses Japanese breast cancer data, see <code><a href="#topic+data.Japanese.breast.cancer">data.Japanese.breast.cancer</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>#####################
#  EXAMPLE with reserving data: data.loss.VNJ()
#  Data used in Martinez Miranda, Nielsen, Nielsen and Verrall (2011)
#  Point forecasts are the Chain-Ladder forecasts	
#  *NOTE* Data are over-dispersed,
#		so distribution forecast are *NOT* reliable
#  The same could be done data.asbestos(),
#		which are not over-dispersed
#		see vignette.

data	&lt;- data.loss.VNJ()
fit.ac	&lt;- apc.fit.model(data,"poisson.response","AC")
forecast	&lt;- apc.forecast.ac(fit.ac)

#	forecasts by "policy-year"
forecast$response.forecast.coh
#	          forecast         se    se.proc     se.est
#	coh_2     1684.763   57.69067   41.04586   40.53949
#	coh_3    29379.085  220.53214  171.40328  138.76362
#	coh_4    60637.929  313.33867  246.24770  193.76066
#	coh_5   101157.697  385.69930  318.05298  218.18857
#	coh_6   173801.522  501.42184  416.89510  278.60786
#	coh_7   249348.589  595.21937  499.34816  323.94060
#	coh_8   475991.739  864.06580  689.92155  520.20955
#	coh_9   763918.643 1182.70450  874.02440  796.78810
#	coh_10 1459859.526 2216.80272 1208.24647 1858.58945

#	forecasts of "cash-flow"
forecast$response.forecast.per
#	reproduces Table 6 of MMNNV (2011)
#	         forecast         se    se.proc   se.est
#	per_11 1353858.32 1456.92459 1163.55417 876.7958
#	per_12  754180.12 1017.37629  868.43544 529.9758
#	per_13  488612.42  816.62860  699.00817 422.2202
#	per_14  318043.00  664.36135  563.95302 351.1880
#	per_15  184610.86  508.97704  429.66366 272.8494
#	per_16  115022.56  414.64945  339.14976 238.5615
#	per_17   63145.15  320.93564  251.28700 199.6360
#	per_18   35812.79  255.08766  189.24267 171.0466
#	per_19    2494.27   78.10439   49.94266  60.0502

#	forecast  of "total reserve"
#	reproduces Table 6 of MMNNV (2011)
forecast$response.forecast.all
#	    forecast       se  se.proc   se.est
#	all  3315779 3182.737 1820.928 2610.371

#####################
#	Forecast of cashflows for 7th cohort (policy year)
#	Note a series of warnings are given because 
#		this is done by truncating the data
#		which generates the warnings associated
#		with apc.data.list.subset()
forecast&lt;- apc.forecast.ac(fit.ac,sum.per.by.coh=7)
forecast$response.forecast.per.by.coh
#	         forecast        se   se.proc    se.est
#	per_11 102975.337 355.97444 320.89771 154.08590
#	per_12  58061.306 267.24671 240.95914 115.58329
#	per_13  40466.866 226.40049 201.16378 103.87646
#	per_14  21615.765 170.90637 147.02301  87.13910
#	per_15  24410.927 194.70158 156.23997 116.17994
#	per_16   1818.389  61.09857  42.64257  43.75668
#
#	This can also be intercept corrected
#		Such intercept corrections are useful when
#		analysing data.asbestos().
#		Unclear if they are useful for
#		reserving.
forecast$intercept.correction.per.by.coh
#   &gt; [1] 1.241798
forecast$response.forecast.per.by.coh.ic
#	         forecast        se   se.proc    se.est
#	per_11 127874.573 355.97444 320.89771 154.08590
#	per_12  72100.417 267.24671 240.95914 115.58329
#	per_13  50251.675 226.40049 201.16378 103.87646
#	per_14  26842.415 170.90637 147.02301  87.13910
#	per_15  30313.441 194.70158 156.23997 116.17994
#	per_16   2258.071  61.09857  42.64257  43.75668

#####################
#	Forecast of cashflows cumulated for
#		6th and 7th cohort (policy year)
forecast&lt;- apc.forecast.ac(fit.ac,sum.per.by.coh=c(6,7))
forecast$response.forecast.per.by.coh.ic
#	         forecast        se   se.proc    se.est
#	per_11 226219.380 460.52781 414.62816 200.42295
#	per_12 139628.153 366.48699 325.74697 167.93339
#	per_13  87022.435 295.86605 257.16360 146.29970
#	per_14  66584.160 277.64858 224.94656 162.75067
#	per_15  34962.678 206.77289 163.00324 127.22018
#	per_16   2392.759  61.09857  42.64257  43.75668

#####################
#  EXAMPLE with reserving data: data.loss.TA()
#  Data used in Harnau and Nielsen (2016)
data	&lt;- data.loss.TA()
fit.ac	&lt;- apc.fit.model(data,"od.poisson.response","AC")
forecast	&lt;- apc.forecast.ac(fit.ac,quantiles=c(0.01,0.05,0.5,0.95,0.99))
forecast$response.forecast.all
#	    forecast      se se.proc  se.est  tau.est 
#	all 18680856 2675417 1007826 2474680 134561.2
#	...
#	 t-0.010  t-0.050  t-0.500  t-0.950  t-0.990 
#	12158931 14160544 18680856 23201167 25202781
#	...
#	 G-0.010  G-0.050  G-0.500  G-0.950  G-0.990 
#	12760202 14398564 18553290 23417098 25792423 
forecast$response.forecast.per

#####################
#  EXAMPLE with reserving data: data.loss.XL()
#  see helpfile for data.loss.XL 	


</code></pre>

<hr>
<h2 id='apc.forecast.ap'>Forecast for Poisson response model with AP structure.</h2><span id='topic+apc.forecast.ap'></span>

<h3>Description</h3>

<p>Computes forecasts for a model with AP structure.
The data can have any form allowed in, see <code><a href="#topic+apc.data.list">apc.data.list</a></code>. These are all special cases of
generalised trapezoids. If the &quot;lower triangle&quot; with the
largest (age,coh) values are not observed, they can be forecast using this function.
The function extrapolates the AP model to the lower triangle where
<code>per.zero+per.max &lt; per &lt;= age.max+coh.max-1</code>.
The estimates of the age parameters can be used for the lower triangle.
The estimates of the period parameters need to be extrapolated for the lower triangle.
Thus, the function extrapolates
<code>per.forecast.J=age.max+coh.max-1-per.zero-per.max</code>
period values. 
The extrapolation method has to chosen so as not to introduce an identification problem, see
Kuang, Nielsen and Nielsen (2008b,2011).
Two such extrapolation methods are implemented in this function: &quot;I0&quot; and &quot;I1&quot;.
The default is to report the linear predictor.
</p>
<p>If the <code>model.family="binominal.dose.response"</code>, that is a logistic model,
then forecasts of dose, response and survival probability are given for lower triangle.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>apc.forecast.ap(apc.fit,extrapolation.type="I0",suppress.warning=TRUE)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="apc.forecast.ap_+3A_apc.fit">apc.fit</code></td>
<td>
<p>List. Output from <code><a href="#topic+apc.fit.model">apc.fit.model</a></code>.
Note: apc.fit.model should be run with AP structure so that 
<code>apc.fit$model.design=="AP"</code>.
Only point forecasts of the linear predictor are provided.</p>
</td></tr>
<tr><td><code id="apc.forecast.ap_+3A_extrapolation.type">extrapolation.type</code></td>
<td>
<p>Character.  Choices for extrapolating the differenced period parameter (&quot;Delta.beta_per&quot;).
Default is &quot;I0&quot;.
</p>

<dl>
<dt>&quot;I0&quot;</dt><dd><p>extrapolates the first out-of-sample differenced period parameter by the average of
cumulated sums of the in-sample estimated differenced period parameters.
The subsequent out-of-sample differenced period parameters are zero.</p>
</dd>
<dt>&quot;I1&quot;</dt><dd><p>extrapolates all out-of-sample differenced period parameters by zero.</p>
</dd>
</dl>

<p>Both methods are invariant to ad hoc identification of the implied period time effect, by
following the ideas put forward in
Kuang, Nielsen and Nielsen (2008b).
Internally, the extrapolation is done as follows.
The estimated differenced period parameters are found from
&quot;apc.fit$coefficients.canonical&quot; using
<code><a href="#topic+apc.identify">apc.identify</a></code> with <code>type="dif"</code>.
These imply period time effects by ad hoc identification:
choose an arbitrary value for the first period time effect
and add partial sums of the differenced period parameter. Fit a time series model:
an intercept model with &quot;I0&quot; and a random walk model for &quot;I1&quot;.
Then extrapolate and take differences.  These extrapolation methods are invariant to the
actual choice of the arbitrary value for the first period time effect.</p>
</td></tr>
<tr><td><code id="apc.forecast.ap_+3A_suppress.warning">suppress.warning</code></td>
<td>
<p>Logical. If true, suppresses warnings from <code><a href="#topic+apc.data.list.subset">apc.data.list.subset</a></code>, which is called internally. Default is &quot;TRUE&quot;.</p>
</td></tr>							
</table>


<h3>Details</h3>

<p>When <code>model.family=binomial.dose.response</code> forecasts are made by the component method, see Cox (1976).
It is intended to be used for a population analysis situation where the response equals cohort-decrease of dose. 
For cell in forecast array with index <code>(age,cohort)</code> then:
Survival probability is <code>survival=1/(1+exp(predictor_(a,c)))</code>.
Dose is <code>dose_(a,c)=max(0,dose_(a-1,c)-response_(a-1,c))</code>.
Response is <code>response_(a,c)=dose_(a,c)*(1-survival_(a,c))</code>.	
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>trap.predictors.forecast</code></td>
<td>
<p>Matrix. Includes estimates and point forecasts of linear predictor. That is design*coefficient.
Same as the <code><a href="stats.html#topic+glm.fit">glm.fit</a></code> value <code>linear.predictors</code> when there is no offset.
Forecasts in lower right triangle. Trapezoid format.</p>
</td></tr>
<tr><td><code>index.trap.J</code></td>
<td>
<p>Matrix. age-coh coordinates for forecast area. Similar structure to
<code>index.trap</code> in <code>apc.index</code>, see <code><a href="#topic+apc.get.index">apc.get.index</a></code>.</p>
</td></tr>
<tr><td><code>D.xi.per.extrapolated</code></td>
<td>
<p>Matrix.  Extrapolated parameters.  Dimension <code>per.forecast.J=age.max+coh.max-1-per.zero-per.max</code> rows, 1 column.</p>
</td></tr> 					
<tr><td><code>trap.dose.forecast</code></td>
<td>
<p>Matrix. Includes data and point forecasts. Forecasts in lower right triangle.        
Dose in cell age,coh equal to dose in cell age-1,coh minus response in cell age-1,coh.
Only implemented for <code>model.family="binomial.dose.response"</code>. See details.</p>
</td></tr>
<tr><td><code>trap.response.forecast</code></td>
<td>
<p>Matrix. Includes data and point forecasts. Forecasts in lower right triangle.      
Response in cell age,coh equal to dose in cell age,coh times 1 minus probability of surviving in that cell.
Only implemented for <code>model.family="binomial.dose.response"</code>. See details.</p>
</td></tr>
<tr><td><code>trap.survival.forecast</code></td>
<td>
<p>Matrix. Point forecasts. Forecasts in lower right triangle 
Probability of surviving computed from <code>trap.predictors.forecast</code> using logistic link function.
Only implemented for <code>model.family="binomial.dose.response"</code>. See details.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Bent Nielsen &lt;bent.nielsen@nuffield.ox.ac.uk&gt; 2 May 2016 (2 Mar 2016)</p>


<h3>References</h3>

<p>Cox, P.R. (1976) Demography. 5th Edition. Cambridge: Cambridge University Press. (page 324).
</p>
<p>Kuang, D., Nielsen, B. and Nielsen, J.P. (2008b) Forecasting with the age-period-cohort model and the extended chain-ladder model. Biometrika 95, 987-991. <em>Download</em>: <a href="https://doi.org/10.1093/biomet/asn038">Article</a>; Earlier version <a href="http://www.nuffield.ox.ac.uk/economics/papers/2008/w9/KuangNielsenNielsen_Forecast.pdf">Nuffield DP</a>.
</p>
<p>Kuang, D., Nielsen B. and Nielsen J.P. (2011) Forecasting in an extended chain-ladder-type model. Journal of Risk and Insurance 78, 345-359. <em>Download</em>: <a href="http://dx.doi.org/10.1111/j.1539-6975.2010.01395.x">Article</a>; Earlier version: <a href="http://www.nuffield.ox.ac.uk/economics/papers/2010/w5/Forecast24jun10.pdf">Nuffield DP</a>. 
</p>

<hr>
<h2 id='apc.forecast.apc'>Forecast models with APC structure.</h2><span id='topic+apc.forecast.apc'></span>

<h3>Description</h3>

<p>Computes forecasts for a model with APC structure.
Forecasts of the linear predictor are given for all models.
This is done for the triangle which shares age and cohort indices with the data.</p>


<h3>Usage</h3>

<pre><code class='language-R'>apc.forecast.apc(apc.fit,extrapolation.type="I0",
suppress.warning=TRUE)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="apc.forecast.apc_+3A_apc.fit">apc.fit</code></td>
<td>
<p>List. Output from <code><a href="#topic+apc.fit.model">apc.fit.model</a></code>.
Note: apc.fit.model should be run with APC structure so that 
<code>apc.fit$model.design=="APC"</code>.
Point forecasts of the response are only provided for a Poisson response model where
<code>apc.fit$model.family=="poisson.response"</code>
and for an over-disperse Poisson response model where
<code>apc.fit$model.family=="od.poisson.response"</code>.
For other models only point forecasts of the linear predictor are provided, that is
the first two values <code>linear.predictors.forecast</code> and <code>index.trap.J</code>.</p>
</td></tr>
<tr><td><code id="apc.forecast.apc_+3A_extrapolation.type">extrapolation.type</code></td>
<td>
<p>Character.  Choices for extrapolating the differenced period parameter (&quot;Delta.beta_per&quot;).
Default is &quot;I0&quot;.
</p>

<dl>
<dt>&quot;I2&quot;</dt><dd><p>Extrapolates future DDbeta by 0.</p>
</dd>
<dt>&quot;I1&quot;</dt><dd><p>Extrapolates future DDbeta as follows.
Compute Dbeta=cumsum(DDbeta) for j=3,...,J.  
This determines Dbeta upto arbitrary level.   
Compute average mean(Dbeta).                  
Forecast DDbeta[J+1]=mean(Dbeta)-Dbeta[J].    
Forecast DDbeta[J+h]=0 for h&gt;1.
This forecast is invariant to arbitrary level.</p>
</dd>
<dt>&quot;I0&quot;</dt><dd><p>Extrapolates future DDbeta as follows.
Compute beta=cumsum(cumsum(DDbeta)) for j=3,...,J.                 
This determines beta upto arbitrary linear trend.                  
Regress on 1 and demeaned trend=j-(n+1)/2                          
giving estimates mu1 and mu2.                                      
Forecast beta[J+1]=mu1 + mu2*(n+1-(n+1)/2).                        
Forecast beta[J+2]=mu1 + mu2*(n+2-(n+1)/2).                        
Forecast DDbeta[J+h]=beta[J+h]-2*beta[J+h-1]+beta[J+h-2] for h=1,2.
Forecast DDbeta[J+h]=0 for h&gt;2.                                    
This forecast is invariant to arbitrary linear trend.</p>
</dd>             
</dl>

<p>All methods are invariant to ad hoc identification of the implied period time effect, by
following the ideas put forward in
Kuang, Nielsen and Nielsen (2008b).</p>
</td></tr>
<tr><td><code id="apc.forecast.apc_+3A_suppress.warning">suppress.warning</code></td>
<td>
<p>Logical. If true, suppresses warnings from <code><a href="#topic+apc.data.list.subset">apc.data.list.subset</a></code>, which is called internally. Default is &quot;TRUE&quot;.</p>
</td></tr>											
</table>


<h3>Details</h3>

<p>The example below is based on the smaller data reserving sets
<code><a href="#topic+data.loss.TA">data.loss.TA</a></code>.
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>linear.predictors.forecast</code></td>
<td>
<p>Vector. Linear predictors for forecast area.</p>
</td></tr>
<tr><td><code>index.trap.J</code></td>
<td>
<p>Matrix. age-coh coordinates for vector. Similar structure to
<code>index.trap</code> in <code>apc.index</code>, see <code><a href="#topic+apc.get.index">apc.get.index</a></code>.</p>
</td></tr>
<tr><td><code>trap.response.forecast</code></td>
<td>
<p>Matrix. Includes data and point forecasts. Forecasts in lower right triangle. Trapezoid format.</p>
</td></tr>
<tr><td><code>response.forecast.cell</code></td>
<td>
<p>Matrix. 4 columns.
1: Point forecasts.
2: corresponding forecast standard errors
3: process standard errors
4: estimation standard errors
Note that the square of column 2 equals the sums of squares of columns 3 and 4
Note that <code>index.trap.J</code> gives the age-coh coordinates for each entry.</p>
</td></tr> 
<tr><td><code>response.forecast.age</code></td>
<td>
<p>Same as <code>response.forecast.cell</code>,
but point forecasts by <code>age</code> cumulated over period/cohort.</p>
</td></tr>
<tr><td><code>response.forecast.per</code></td>
<td>
<p>Same as <code>response.forecast.cell</code>,
but point forecasts by <code>per</code> cumulated over age/cohort.</p>
</td></tr>
<tr><td><code>response.forecast.coh</code></td>
<td>
<p>Same as <code>response.forecast.cell</code>,
but point forecasts by <code>coh</code> cumulated over age/period.</p>
</td></tr>
<tr><td><code>response.forecast.all</code></td>
<td>
<p>Same as <code>response.forecast.cell</code>,
but point forecasts cumulated by <code>age</code> and <code>coh</code>.</p>
</td></tr>
<tr><td><code>xi.per.dd.extrapolated</code></td>
<td>
<p>The extrapolated double differences.</p>
</td></tr>					
<tr><td><code>xi.extrapolated</code></td>
<td>
<p>The extrapolated parameters.</p>
</td></tr>					
</table>


<h3>Author(s)</h3>

<p>Bent Nielsen &lt;bent.nielsen@nuffield.ox.ac.uk&gt; 10 Sep 2016</p>


<h3>References</h3>

<p>Kuang, D., Nielsen, B. and Nielsen, J.P. (2008b) Forecasting with the age-period-cohort model and the extended chain-ladder model. Biometrika 95, 987-991. <em>Download</em>: <a href="https://doi.org/10.1093/biomet/asn038">Article</a>; Earlier version <a href="http://www.nuffield.ox.ac.uk/economics/papers/2008/w9/KuangNielsenNielsen_Forecast.pdf">Nuffield DP</a>.
</p>


<h3>See Also</h3>

<p>The example below uses Taylor and Ashe reserving see <code><a href="#topic+data.loss.TA">data.loss.TA</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>#####################
#  EXAMPLE with reserving data: data.loss.TA()

data	&lt;- data.loss.TA()
fit.apc	&lt;- apc.fit.model(data,"poisson.response","APC")
forecast	&lt;- apc.forecast.apc(fit.apc)

#	forecasts by "policy-year"
forecast$response.forecast.coh
#	         forecast
#	coh_2    91718.82
#	coh_3   464661.38
#	coh_4   704591.94
#	coh_5  1025337.23
#	coh_6  1503253.81
#	coh_7  2330768.44
#	coh_8  4115906.56
#	coh_9  4257958.30
#	coh_10 4567231.84
#	forecasts of "cash-flow"
forecast$response.forecast.per
#	        forecast
#	per_11 5274762.58
#	per_12 4213526.23
#	per_13 3188451.80
#	per_14 2210649.45
#	per_15 1644203.06
#	per_16 1236495.32
#	per_17  764552.75
#	per_18  444205.71
#	per_19   84581.44
#	forecast  of "total reserve"
forecast$response.forecast.all
#	    forecast
#	all 19061428
</code></pre>

<hr>
<h2 id='apc.get.design'>Create design matrices</h2><span id='topic+apc.get.design'></span><span id='topic+apc.get.design.collinear'></span>

<h3>Description</h3>

<p>Functions to create the apc design matrix for the canonical parameters.
Based on Nielsen (2014b), which generalises introduced by Kuang, Nielsen and Nielsen (2008).
In normal use these function are needed for internal use by <code><a href="#topic+apc.fit.model">apc.fit.model</a></code>.
</p>
<p>The resulting function design matrix is collinear, so a sub-set of the columns have to be selected.
The columns are: intercept, age/period/cohort slopes, age/period/cohort double differences.
Thus, there are three slopes instead of two. Before use, one has to select which parameters are needed.
This should include at either one/two of age/cohort slopes or period slope or no slope.</p>


<h3>Usage</h3>

<pre><code class='language-R'>apc.get.design(apc.index,model.design)
apc.get.design.collinear(apc.index)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="apc.get.design_+3A_apc.index">apc.index</code></td>
<td>
<p>List. See <code><a href="#topic+apc.get.index">apc.get.index</a></code> for a description of the format.
Note, <code>apc.index</code> can be replace by an apc.fit list. This is extended version
of <code>apc.index</code> is the output from <code><a href="#topic+apc.fit.model">apc.fit.model</a></code>. </p>
</td></tr>
<tr><td><code id="apc.get.design_+3A_model.design">model.design</code></td>
<td>
<p>Character.  This indicates the design choice.  The following options are possible.
</p>

<dl>
<dt>&quot;APC&quot;</dt><dd><p>Age-period-cohort model.</p>
</dd>
<dt>&quot;AP&quot; </dt><dd><p>Age-period model. Nested in &quot;APC&quot;</p>
</dd>
<dt>&quot;AC&quot; </dt><dd><p>Age-cohort model. Nested in &quot;APC&quot;</p>
</dd>
<dt>&quot;PC&quot; </dt><dd><p>Period-cohort model. Nested in &quot;APC&quot;</p>
</dd>
<dt>&quot;Ad&quot; </dt><dd><p>Age-trend model, including age effect and two linear trends. Nested in &quot;AP&quot;, &quot;AC&quot;.</p>
</dd>
<dt>&quot;Pd&quot; </dt><dd><p>Period-trend model, including period effect and two linear trends. Nested in &quot;AP&quot;, &quot;PC&quot;.</p>
</dd>
<dt>&quot;Cd&quot; </dt><dd><p>Cohort-trend model, including cohort effect and two linear trends. Nested in &quot;AC&quot;, &quot;PC&quot;.</p>
</dd>
<dt>&quot;A&quot;  </dt><dd><p>Age model. Nested in &quot;Ad&quot;.</p>
</dd>      
<dt>&quot;P&quot;  </dt><dd><p>Period model. Nested in &quot;Pd&quot;.</p>
</dd>
<dt>&quot;C&quot;  </dt><dd><p>Cohort model. Nested in &quot;Cd&quot;.</p>
</dd>
<dt>&quot;t&quot;  </dt><dd><p>Trend model, with two linear trends. Nested in &quot;Ad&quot;, &quot;Pd&quot;, &quot;Cd&quot;.</p>
</dd>
<dt>&quot;tA&quot; </dt><dd><p>Single trend model in age index. Nested in &quot;A&quot;, &quot;t&quot;.</p>
</dd>
<dt>&quot;tP&quot; </dt><dd><p>Single trend model in period index. Nested in &quot;P&quot;, &quot;t&quot;.</p>
</dd>
<dt>&quot;tC&quot; </dt><dd><p>Single trend model in cohort index. Nested in &quot;C&quot;, &quot;t&quot;.</p>
</dd>
<dt>&quot;1&quot;  </dt><dd><p>Constant model. Nested in &quot;tA&quot;, &quot;tP&quot;, &quot;tC&quot;.</p>
</dd>
<dt>NULL</dt><dd><p>The function then looks for information on model design in the first argument.</p>
</dd>
</dl>

<p>The <code>model.design</code> argument is not needed if the first argument is of type
<code>apc.fit</code>.  If given, the <code>model.design</code> argument is used.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p><em>apc.get.design</em>
returns a list with
</p>
<table role = "presentation">
<tr><td><code>design</code></td>
<td>
<p>Matrix. The design matrix. The number of rows is the number of observations, that is <code>apc.index$n.data</code>.
The order of the observations corresponds to the internal choice made in <code><a href="#topic+apc.get.index">apc.get.index</a></code>.</p>
</td></tr>
<tr><td><code>slopes</code></td>
<td>
<p>Vector. For internal use. Length 3 of logicals,	indicate presence	of age/period/cohort linear slopes
at most two slopes can be present if neither age/cohort present then period may be presents,
which is the case for model.design &quot;P&quot;,&quot;tP&quot;</p>
</td></tr>
<tr><td><code>difdif</code></td>
<td>
<p>Vector. For internal use. Length 3 of logicals</p>
</td></tr>
</table>
<p><em>apc.get.design.collinear</em>
returns a collinear design matrix for the unrestricted &quot;APC&quot; model.
It has an extra column.  The columns 2-4 are linear trends in age, period and cohort directions.  At most
two of these should be used.  They are selected by <code>slopes</code>.
</p>


<h3>Author(s)</h3>

<p>Bent Nielsen &lt;bent.nielsen@nuffield.ox.ac.uk&gt; 1 Mar 2015</p>


<h3>References</h3>

<p>Kuang, D., Nielsen, B. and Nielsen, J.P. (2008a) Identification of the age-period-cohort model and the extended chain ladder model. Biometrika 95, 979-986. <em>Download</em>: <a href="https://doi.org/10.1093/biomet/asn026">Article</a>; Earlier version <a href="http://www.nuffield.ox.ac.uk/economics/papers/2007/w5/KuangNielsenNielsen07.pdf">Nuffield DP</a>.
</p>
<p>Nielsen, B. (2014b) Deviance analysis of age-period-cohort models.
</p>


<h3>See Also</h3>

<p>The vignette
<a href="../doc/NewDesign.pdf"><code>NewDesign.pdf</code></a>,
<a href="../doc/NewDesign.R"><code>NewDesign.R</code></a>
on
<a href="../doc/index.html"><code>Vignettes</code></a>.		
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#####################
#	EXAMPLE 1 with Belgian lung cancer data
#	This example illustrates how apc.fit.model works.

data.list	&lt;- data.Belgian.lung.cancer()

#	Vectorise data
index		&lt;- apc.get.index(data.list)
v.response	&lt;- data.list$response[index$index.data]
v.dose		&lt;- data.list$dose[index$index.data]

#	Get design
m.design.apc	&lt;- apc.get.design(index,"APC")$design

#	Fit using glm.fit from stats package
fit.apc.glm	&lt;- glm.fit(m.design.apc,v.response,family=poisson(link="log"),offset=log(v.dose))
fit.apc.glm$deviance

#	Compare with standard output from apc.fit.model
apc.fit.model(data.list,"poisson.dose.response","APC")$deviance

#####################
#	EXAMPLE 2 with Belgian lung cancer data
#	The age-drift model gives a good fit.
#	This fit can be refined to a cubic or quadratic age effect.
#	The latter is not precoded so one will have to work directly with the design matrix.
#	SEE ALSO VIGNETTE

data.list	&lt;- data.Belgian.lung.cancer()

#	Vectorise data
index		&lt;- apc.get.index(data.list)
v.response	&lt;- data.list$response[index$index.data]
v.dose		&lt;- data.list$dose[index$index.data]

#	Get design matrix for "Ad"
m.design.ad	&lt;- apc.get.design(index,"Ad")$design

#	Modify design matrix for cubic or quadratic age effect
#	Note this implies a linear or constant double difference
#	Quadractic age effect: restrict double differences to be equal
p	&lt;- ncol(m.design.ad)
m.rest.q	&lt;- matrix(data=0,nrow=p,ncol=4)
m.rest.q[1,1]	&lt;- 1
m.rest.q[2,2]	&lt;- 1
m.rest.q[3,3]	&lt;- 1
m.rest.q[4:p,4]	&lt;- 1
m.design.adq	&lt;- m.design.ad %*% m.rest.q
#	Cubic age effect: restrict double differences to be linear
m.rest.c	&lt;- matrix(data=0,nrow=p,ncol=5)
m.rest.c[1,1]	&lt;- 1
m.rest.c[2,2]	&lt;- 1
m.rest.c[3,3]	&lt;- 1
m.rest.c[4:p,4]	&lt;- 1
m.rest.c[4:p,5]	&lt;- seq(1,p-3)
m.design.adc	&lt;- m.design.ad %*% m.rest.c

#	Poisson regression for dose-response and with log link
fit.ad	&lt;- glm.fit(m.design.ad,v.response,family=poisson(link="log"),offset=log(v.dose))
fit.adc	&lt;- glm.fit(m.design.adc,v.response,family=poisson(link="log"),offset=log(v.dose))
fit.adq	&lt;- glm.fit(m.design.adq,v.response,family=poisson(link="log"),offset=log(v.dose))

#	Deviance tests
fit.adc$deviance - fit.ad$deviance 
fit.adq$deviance - fit.ad$deviance 
#	Degrees of freedom
ncol(m.design.ad) - ncol(m.design.adc)
ncol(m.design.ad) - ncol(m.design.adq)

</code></pre>

<hr>
<h2 id='apc.get.index'>Get indices for mapping data into trapezoid formation</h2><span id='topic+apc.get.index'></span>

<h3>Description</h3>

<p>This function does the internal book keeping between the original data format and the trapezoid format.
It creates index matrices to transform data between original format, trapezoid format and a vector,
as well as values to keep track of the labels for the time scales.
</p>
<p>The generalized trapezoids are introduced in Kuang, Nielsen and Nielsen (2008), see also Nielsen (2014).</p>


<h3>Usage</h3>

<pre><code class='language-R'>apc.get.index(apc.data.list)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="apc.get.index_+3A_apc.data.list">apc.data.list</code></td>
<td>
<p>See <code><a href="#topic+apc.data.list">apc.data.list</a></code> for a description of the format</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the following values.
</p>
<table role = "presentation">
<tr><td><code>response</code></td>
<td>
<p>Matrix.  An argument</p>
</td></tr>
<tr><td><code>dose</code></td>
<td>
<p>Matrix or NULL.  An argument</p>
</td></tr>
<tr><td><code>data.format</code></td>
<td>
<p>Character.  An argument</p>
</td></tr>
<tr><td><code>unit</code></td>
<td>
<p>Numeric. An argument.</p>
</td></tr>
<tr><td><code>data.xmax</code></td>
<td>
<p>Numeric.  Number of rows of response matrix.</p>
</td></tr>
<tr><td><code>data.ymax</code></td>
<td>
<p>Numeric.  Number of columns of response matrix.</p>
</td></tr>
<tr><td><code>data.xlab</code></td>
<td>
<p>Character. Label for row index of response  matrix. Derived from <code>data.format</code>.</p>
</td></tr>
<tr><td><code>data.ylab</code></td>
<td>
<p>Character. Label for column index of response  matrix. Derived from <code>data.format</code>.</p>
</td></tr>
<tr><td><code>data.xlab1</code></td>
<td>
<p>Numeric.  Year for smallest row index of response  matrix.    </p>
</td></tr>
<tr><td><code>data.ylab1</code></td>
<td>
<p>Numeric.  Year for smallest column index of response  matrix. </p>
</td></tr>
<tr><td><code>n.data</code></td>
<td>
<p>Numeric.  Number of observations. </p>
</td></tr>
<tr><td><code>index.data</code></td>
<td>
<p>Matrix of dimension <code>n.data</code>x2.  Index pairs for observations in the original coordinate system as given by <code>data.format</code>.  Same order as in <code>index.trap</code>.</p>
</td></tr>
<tr><td><code>index.trap</code></td>
<td>
<p>Matrix of dimension <code>n.data</code>x2.  Index pairs for observations in an age/cohort system.  Hence the coordinates of a trapezoid matrix.  Same order as in <code>index.data</code>.</p>
</td></tr>
<tr><td><code>age.max</code></td>
<td>
<p>Numeric.  Number of age groups.	 </p>
</td></tr>
<tr><td><code>per.max</code></td>
<td>
<p>Numeric.  Number of period groups.</p>
</td></tr>
<tr><td><code>coh.max</code></td>
<td>
<p>Numeric.  Number of cohort groups.</p>
</td></tr>
<tr><td><code>per.zero</code></td>
<td>
<p>Numeric.  Anchor for period index, so that period starts from <code>per.zero</code>+1.</p>
</td></tr>
<tr><td><code>per.odd</code></td>
<td>
<p>Logic.  TRUE if per.zero is odd.</p>
</td></tr>
<tr><td><code>U</code></td>
<td>
<p>Numeric.  Integer value of (per.zero+3)/2.</p>
</td></tr>
<tr><td><code>age1</code></td>
<td>
<p>Numeric.  Year for smallest age index. Derived for data.format=&quot;CP&quot;, &quot;PC&quot;, otherwise an argument.</p>
</td></tr>
<tr><td><code>per1</code></td>
<td>
<p>Numeric.  Year for smallest period index. Derived for data.format=&quot;AC&quot;,&quot;CA&quot;,&quot;CL&quot;,&quot;CL.vector.by.row&quot;,&quot;trapezoid&quot;, otherwise an argument.</p>
</td></tr>
<tr><td><code>coh1</code></td>
<td>
<p>Numeric.  Year for smallest cohort index. Derived for data.format=&quot;AP&quot;, &quot;PA&quot;, otherwise an argument.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Bent Nielsen &lt;bent.nielsen@nuffield.ox.ac.uk&gt; 31 Mar 2015</p>


<h3>References</h3>

<p>Kuang, D., Nielsen, B. and Nielsen, J.P. (2008a) Identification of the age-period-cohort model and the extended chain ladder model. Biometrika 95, 979-986. <em>Download</em>: <a href="https://doi.org/10.1093/biomet/asn026">Article</a>; Earlier version <a href="http://www.nuffield.ox.ac.uk/economics/papers/2007/w5/KuangNielsenNielsen07.pdf">Nuffield DP</a>.
</p>
<p>Nielsen, B. (2014) Deviance analysis of age-period-cohort models.  <a href="http://www.nuffield.ox.ac.uk/economics/papers/2014/apc_deviance.pdf">Nuffield DP</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>################
#	Artificial data

###############
#	Artificial data
#	Generate a 3x5 matrix and make arbitrary decisions for rest

response &lt;- matrix(data=seq(1:15),nrow=3,ncol=5)
data.list	&lt;- list(response=response,dose=NULL,data.format="AP",
					age1=25,per1=1955,coh1=NULL,
					unit=5,per.zero=NULL,per.max=NULL,time.adjust=0)
apc.get.index(data.list)

</code></pre>

<hr>
<h2 id='apc.hypothesis'>Imposing hypotheses on age-period-cohort models.</h2><span id='topic+apc.hypothesis'></span>

<h3>Description</h3>

<p><code>apc</code> has a set of standard hypotheses that can be imposed on the age-period-cohort model.
A deviance table can be found on 
<code><a href="#topic+apc.fit.table">apc.fit.table</a></code>,
while fits of restricted models can be found using 
<code><a href="#topic+apc.fit.model">apc.fit.model</a></code>.
</p>
<p>Other linear hypotheses can be imposed using a little bit of coding, see the vignette
<a href="../doc/NewDesign.pdf"><code>NewDesign.pdf</code></a>,
<a href="../doc/NewDesign.R"><code>NewDesign.R</code></a>
on
<a href="../doc/index.html"><code>Vignettes</code></a>.		
</p>
<p>For over-dispersed Poisson models for responses and no doses the theory is worked out in 
Harnau and Nielsen (2017).
</p>
<p>In general forecasts from age-period-cohort models require extrapolation of the estimated parameters.
This has to be done without introducing identifications problems, see
Kuang, Nielsen and Nielsen (2008b,2011).
There are many different possibilities for extrapolation for the different sub-models.
The extrapolation results in point forecasts.
Distribution forecasts should be build on top of these, see
Martinez Miranda, Nielsen and Nielsen (2015)
and
Harnau and Nielsen (2016).
At present three experimental functions
<code><a href="#topic+apc.forecast.ac">apc.forecast.ac</a></code>,
<code><a href="#topic+apc.forecast.apc">apc.forecast.apc</a></code>
and
<code><a href="#topic+apc.forecast.ap">apc.forecast.ap</a></code>
are available.
</p>


<h3>Author(s)</h3>

<p>Bent Nielsen &lt;bent.nielsen@nuffield.ox.ac.uk&gt; 10 Sep 2016 (1 Feb 2016)</p>


<h3>References</h3>

<p>Harnau, J. and Nielsen (2016) Over-dispersed age-period-cohort models. To appear in <em>Journal of the American Statistical Association</em>. <em>Download</em>: <a href="https://www.nuffield.ox.ac.uk/economics/papers/2017/HarnauNielsen2017apcDP.pdf">Nuffield DP</a>
</p>
<p>Kuang, D., Nielsen, B. and Nielsen, J.P. (2008b) Forecasting with the age-period-cohort model and the extended chain-ladder model. Biometrika 95, 987-991. <em>Download</em>: <a href="https://doi.org/10.1093/biomet/asn038">Article</a>; Earlier version <a href="http://www.nuffield.ox.ac.uk/economics/papers/2008/w9/KuangNielsenNielsen_Forecast.pdf">Nuffield DP</a>.
</p>
<p>Kuang, D., Nielsen B. and Nielsen J.P. (2011) Forecasting in an extended chain-ladder-type model. Journal of Risk and Insurance 78, 345-359. <em>Download</em>: <a href="http://dx.doi.org/10.1111/j.1539-6975.2010.01395.x">Article</a>; Earlier version: <a href="http://www.nuffield.ox.ac.uk/economics/papers/2010/w5/Forecast24jun10.pdf">Nuffield DP</a>. 
</p>
<p>Martinez Miranda, M.D., Nielsen, B. and Nielsen, J.P. (2015) Inference and forecasting in the age-period-cohort model with unknown exposure with an application to mesothelioma mortality. <em>Journal of the Royal Statistical Society</em> A 178, 29-55. <em>Download</em>: <a href="https://doi.org/10.1111/rssa.12051">Article</a>, <a href="http://www.nuffield.ox.ac.uk/economics/papers/2013/Asbestos8mar13.pdf">Nuffield DP</a>. 
</p>

<hr>
<h2 id='apc.identify'>Identification of time effects</h2><span id='topic+apc.identify'></span>

<h3>Description</h3>

<p>Computes ad hoc identified time effects.</p>


<h3>Usage</h3>

<pre><code class='language-R'>apc.identify(apc.fit.model)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="apc.identify_+3A_apc.fit.model">apc.fit.model</code></td>
<td>
<p>List. See <code><a href="#topic+apc.fit.model">apc.fit.model</a></code> for a description of the format.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Forms ad hoc identified time effects from the canonical parameter.
These are used either indirectly by <code><a href="#topic+apc.plot.fit">apc.plot.fit</a></code>
or they are computed directly with this command.
</p>
<p>The ad hoc identifications are based on	Nielsen (2014b). For details see also the vignette
<a href="../doc/Identification.pdf"><code>Identification.pdf</code></a>,
<a href="../doc/Identification.R"><code>Identification.R</code></a>
on
<a href="../doc/index.html"><code>Vignettes</code></a>		
or in the notes below.
</p>
<p>For model designs of any type two ad hoc identified time effects.
</p>
<p>(1)
The type &quot;sum.sum&quot; (same as &quot;ss.dd&quot;) gives double sums anchored in the middle of
the first period diagonal. 
</p>
<p>(2)
The type &quot;detrend&quot; gives double sums that start in zero and end in zero.
</p>
<p>For model designs with only two time effects, that is &quot;AC&quot;, &quot;AP&quot;, &quot;PC&quot; there is
a further ad hoc identification.
</p>
<p>(3)
The type &quot;demean&quot; gives single sums of single differences. Derived from &quot;detrend&quot; where the
linear trends are attributed to the double sums of double differences. Level unchanged.
</p>
<p>(4)
The type &quot;dif&quot; gives the single differences derived from &quot;demean&quot;.  Could also have been chosen
as canonical parametrisation for these models.
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>index.age.max</code></td>
<td>
<p>Vector.  Indices for age    parameters when using coefficients.ssdd or coefficients.detrend.  The length is two longer that that of <code>apc.model.fit$index.age</code> if <code>model.design</code> is &quot;APC.  NULL if age    double differences are not estimated.</p>
</td></tr>
<tr><td><code>index.per.max</code></td>
<td>
<p>Vector.  Indices for period parameters when using coefficients.ssdd or coefficients.detrend.  The length is two longer that that of <code>apc.model.fit$index.per</code> if <code>model.design</code> is &quot;APC.  NULL if age    double differences are not estimated.</p>
</td></tr>
<tr><td><code>index.coh.max</code></td>
<td>
<p>Vector.  Indices for cohort parameters when using coefficients.ssdd or coefficients.detrend.  The length is two longer that that of <code>apc.model.fit$index.coh</code> if <code>model.design</code> is &quot;APC.  NULL if age    double differences are not estimated.</p>
</td></tr>
<tr><td><code>dates.max</code></td>
<td>
<p>Vector.  Indicates the dates for the parameters when using coefficients.ssdd or coefficients.detrend.  The length is six longer that that of <code>apc.model.fit$index.coh</code> if <code>model.design</code> is &quot;APC.</p>
</td></tr>
<tr><td><code>index.age.sub</code></td>
<td>
<p>* Vector.  Indices for age    parameters when using coefficients.demean.  The length is two longer that that of <code>apc.model.fit$index.age</code> if <code>model.design</code> is &quot;APC.  NULL if age    double differences are not estimated.</p>
</td></tr>
<tr><td><code>index.per.sub</code></td>
<td>
<p>* Vector.  Indices for period parameters when using coefficients.demean.  The length is two longer that that of <code>apc.model.fit$index.per</code> if <code>model.design</code> is &quot;APC.  NULL if age    double differences are not estimated.</p>
</td></tr>
<tr><td><code>index.coh.sub</code></td>
<td>
<p>* Vector.  Indices for cohort parameters when using coefficients.demean.  The length is two longer that that of <code>apc.model.fit$index.coh</code> if <code>model.design</code> is &quot;APC.  NULL if age    double differences are not estimated.</p>
</td></tr>
<tr><td><code>dates.sub</code></td>
<td>
<p>* Vector.  Indicates the dates for the parameters when using coefficients.demean.  The length is six longer that that of <code>apc.model.fit$index.coh</code> if <code>model.design</code> is &quot;APC.</p>
</td></tr>
<tr><td><code>index.age.dif</code></td>
<td>
<p>* Vector.  Indices for age    parameters when using coefficients.dif.  The length is one longer that that of <code>apc.model.fit$index.age</code> if <code>model.design</code> is &quot;APC.  NULL if age    double differences are not estimated.</p>
</td></tr>
<tr><td><code>index.per.dif</code></td>
<td>
<p>* Vector.  Indices for period parameters when using coefficients.dif.  The length is one  longer that that of <code>apc.model.fit$index.per</code> if <code>model.design</code> is &quot;APC.  NULL if age    double differences are not estimated.</p>
</td></tr>
<tr><td><code>index.coh.dif</code></td>
<td>
<p>* Vector.  Indices for cohort parameters when using coefficients.dif.  The length is one  longer that that of <code>apc.model.fit$index.coh</code> if <code>model.design</code> is &quot;APC.  NULL if age    double differences are not estimated.</p>
</td></tr>
<tr><td><code>dates.dif</code></td>
<td>
<p>* Vector.  Indicates the dates for the parameters when using coefficients.dif.  The length is three longer that that of <code>apc.model.fit$index.coh</code> if <code>model.design</code> is &quot;APC.</p>
</td></tr>
<tr><td><code>coefficients.ssdd</code></td>
<td>
<p>Matrix.  Coefficients of the double sum of double differences.  Normalised to be zero at two values chosen so age=cohort and period is at the minimal value.  For each parameter is reported coefficient, standard deviation, z-value, which is the ratio of those, and p-value.</p>
</td></tr>
<tr><td><code>covariance.ssdd</code></td>
<td>
<p>Matrix.  Estimated covariance matrix for double sums.</p>
</td></tr>
<tr><td><code>coefficients.detrend</code></td>
<td>
<p>Matrix.  Coefficients of the double sum of double differences.  Normalised to be zero for first and last value.  For each parameter is reported coefficient, standard deviation, z-value, which is the ratio of those, and p-value.</p>
</td></tr>
<tr><td><code>covariance.detrend</code></td>
<td>
<p>Matrix.  Estimated covariance matrix for detrended double sums.</p>
</td></tr>
<tr><td><code>coefficients.demean</code></td>
<td>
<p>* Matrix.  Coefficients of the sum of differences.  Normalised to be zero for first value.  Does not apply is design is &quot;APC&quot; For each parameter is reported coefficient, standard deviation, z-value, which is the ratio of those, and p-value.</p>
</td></tr>
<tr><td><code>covariance.demean</code></td>
<td>
<p>* Matrix.  Estimated covariance matrix for demeaned sums.</p>
</td></tr>
<tr><td><code>coefficients.dif</code></td>
<td>
<p>* Matrix.  Coefficients of the differences.  Does not apply is design is &quot;APC&quot; For each parameter is reported coefficient, standard deviation, z-value, which is the ratio of those, and p-value.</p>
</td></tr>
<tr><td><code>covariance.dif</code></td>
<td>
<p>* Matrix.  Estimated covariance matrix for differences.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>* indicates that values only implemented for designs &quot;AC&quot;, &quot;AP&quot;, &quot;PC&quot;.
</p>
<p>The differences are not identified for design &quot;APC&quot;.  An arbitrary level can be moved between differences for
age, period and cohort.  
</p>
<p>The differences are not identified for designs &quot;Ad&quot;, &quot;Pd&quot;, &quot;Cd&quot;.  These models have two linear trends and one set of
double differences.  In the model &quot;Ad&quot;, as an example, one linear trend will be associated with age, but it is
arbitrary whether the second linear trend should be associated with period or cohort.  The slope of the age trend
will depend on that arbitrary choice.  In turn the level of the age differences will be arbitrary.  
</p>
<p>(1)
The type &quot;sum.sum&quot; (same as &quot;ss.dd&quot;) gives double sums anchored 
to be zero in the three points where
<code>age=cohort=U</code>,
<code>age=U+1,cohort=U</code>
<code>age=U,cohort=U+1</code>
with
<code>apc.fit.model$U</code>
and where
<code>U</code>
is the integer value of
<code>(per.zero+3)/2</code>
This corresponds to the representation in
Nielsen (2014b).
The linear plane is parametrised in terms of 
a level, which is the value of the predictor at
<code>age=cohort=U</code>;
an age slope, which is the difference of the values of the predictor at
<code>age=U+1,cohort=U</code>
and 
<code>age=cohort=U</code>;
an cohort slope, which is the difference of the values of the predictor at
<code>age=U,cohort=U+1</code>
and 
<code>age=cohort=U</code>.
</p>
<p>(2)
The type &quot;detrend&quot; gives double sums that start in zero and end in zero.
The linear plane is parametrised in terms of
a level, which is the value of the predictor at 
<code>age=cohort=1</code>, which is usually outside the index set for the data;
while age and cohort slopes are adjusted for the ad hoc identification of the time effects.
</p>
<p>(3)
Subsumes <code>var.apc.identify</code> from <code>apc.indiv</code> (25 Sep 2020)
</p>


<h3>Author(s)</h3>

<p>Bent Nielsen &lt;bent.nielsen@nuffield.ox.ac.uk&gt; &amp; Zoe Fannon 25 Sep 2020 (12 Apr 2015)</p>


<h3>References</h3>

<p>Kuang, D., Nielsen, B. and Nielsen, J.P. (2008a) Identification of the age-period-cohort model and the extended chain ladder model. Biometrika 95, 979-986. <em>Download</em>: <a href="https://doi.org/10.1093/biomet/asn026">Article</a>; Earlier version <a href="http://www.nuffield.ox.ac.uk/economics/papers/2007/w5/KuangNielsenNielsen07.pdf">Nuffield DP</a>.
</p>
<p>Nielsen, B. (2014b) Deviance analysis of age-period-cohort models. Work in progress.
</p>


<h3>See Also</h3>

<p>The <a href="http://users.ox.ac.uk/~nuff0078/apc/index.htm">vignette</a> <a href="http://users.ox.ac.uk/~nuff0078/apc/vignettes/Identification.pdf">Identification.pdf</a>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>########################
#	Belgian lung cancer
# 	first an example with APC design, note that demean and dif not defined.

data.list	&lt;- data.Belgian.lung.cancer()

fit.apc	&lt;- apc.fit.model(data.list,"poisson.dose.response","APC")
fit.apc$coefficients.canonical
id.apc	&lt;- apc.identify(fit.apc)
id.apc$coefficients.ssdd
id.apc$coefficients.detrend
id.apc$coefficients.demean
id.apc$coefficients.dif

fit.ap	&lt;- apc.fit.model(data.list,"poisson.dose.response","AP")
fit.ap$coefficients.canonical
id.ap	&lt;- apc.identify(fit.ap)
id.ap$coefficients.ssdd
id.ap$coefficients.detrend
id.ap$coefficients.demean
id.ap$coefficients.dif

</code></pre>

<hr>
<h2 id='apc.indiv.compare.direct'>
Implements direct tests between APC models</h2><span id='topic+apc.indiv.compare.direct'></span><span id='topic+apc.indiv.waldtest.fullapc'></span><span id='topic+apc.indiv.waldtest.TS'></span><span id='topic+apc.indiv.LRtest.fullapc'></span><span id='topic+apc.indiv.LRtest.TS'></span>

<h3>Description</h3>

<p>This function allows the user to directly compare any of the APC model, its
submodels, or the TS model to any smaller model. For example, the function
can be used to compare the TS to the Ad model or the Ad model to the A model. 
Comparisons are by likelihood ratio or Wald tests. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>	apc.indiv.compare.direct(data, big.model, small.model, unit=1,
        			dep.var, covariates=NULL, model.family,
                    n.coh.excl.start=0, n.coh.excl.end=0,
                    n.age.excl.start=0, n.age.excl.end=0,
                    n.per.excl.start=0, n.per.excl.end=0,
                    NR.controls=NULL, test, dist,
                    wt.var=NULL, plmmodel="notplm", id.var=NULL)
        apc.indiv.waldtest.fullapc(data, dist="F", big.model="APC", 
                    small.model, dep.var, covariates=NULL,
                    model.family="gaussian", unit=1, 
                    n.coh.excl.start=0, n.coh.excl.end=0,
                    n.age.excl.start=0, n.age.excl.end=0,
                    n.per.excl.start=0, n.per.excl.end=0,
                    existing.big.model.fit=NULL, 
                    existing.small.model.fit=NULL,
                    existing.collinear=NULL,
					plmmodel = "notplm", id.var=NULL, wt.var=NULL)
        apc.indiv.waldtest.TS(data, dist="F", small.model="APC",
                    dep.var, covariates=NULL,
                    model.family="gaussian", unit=1, 
                    n.coh.excl.start=0, n.coh.excl.end = 0,
                    n.age.excl.start=0, n.age.excl.end = 0,
                    n.per.excl.start=0, n.per.excl.end = 0,
                    existing.small.model.fit=NULL, 
                    existing.big.model.fit=NULL, 
                    existing.collinear=NULL)
        apc.indiv.LRtest.fullapc(data,  big.model="APC", 
                    small.model,
                    dep.var, covariates=NULL, 
                    model.family="binomial", unit=1,
                    n.coh.excl.start=0, n.coh.excl.end=0,
                    n.age.excl.start=0, n.age.excl.end=0,
                    n.per.excl.start=0, n.per.excl.end=0,
                    existing.big.model.fit=NULL,
                    existing.small.model.fit=NULL,
                    existing.collinear=NULL)
       apc.indiv.LRtest.TS(data, small.model="APC", dep.var, covariates=NULL,
                    model.family="binomial", unit=1, 
                    n.coh.excl.start=0, n.coh.excl.end=0,
                    n.age.excl.start=0, n.age.excl.end=0,
                    n.per.excl.start=0, n.per.excl.end=0,
                    existing.small.model.fit=NULL, 
                    existing.big.model.fit=NULL, 
                    existing.collinear=NULL,
                    NR.controls=NULL)                                      
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="apc.indiv.compare.direct_+3A_data">data</code></td>
<td>
<p>The data.frame in use.</p>
</td></tr>
<tr><td><code id="apc.indiv.compare.direct_+3A_big.model">big.model</code></td>
<td>
<p>The name of the larger of the two models to be tested.</p>
</td></tr>
<tr><td><code id="apc.indiv.compare.direct_+3A_small.model">small.model</code></td>
<td>
<p>The name of the smaller of the two models to be tested.</p>
</td></tr>
<tr><td><code id="apc.indiv.compare.direct_+3A_unit">unit</code></td>
<td>
<p>The interval at which age, period, and cohort are recorded 
(must be the same for each). Default 1.</p>
</td></tr>
<tr><td><code id="apc.indiv.compare.direct_+3A_dep.var">dep.var</code></td>
<td>
<p>The name of the dependent variable as it appears in the data</p>
</td></tr>
<tr><td><code id="apc.indiv.compare.direct_+3A_covariates">covariates</code></td>
<td>
<p>A vector of the names of covariates as they appear in the
data. Default NULL.</p>
</td></tr>
<tr><td><code id="apc.indiv.compare.direct_+3A_model.family">model.family</code></td>
<td>
<p>Either &quot;gaussian&quot; or &quot;binomial&quot;</p>
</td></tr>
<tr><td><code id="apc.indiv.compare.direct_+3A_n.coh.excl.start">n.coh.excl.start</code></td>
<td>
<p>If any cohorts have been censored (AP data only). 
Default 0.</p>
</td></tr>
<tr><td><code id="apc.indiv.compare.direct_+3A_n.coh.excl.end">n.coh.excl.end</code></td>
<td>
<p>If any cohorts have been censored (AP data only). 
Default 0.</p>
</td></tr>
<tr><td><code id="apc.indiv.compare.direct_+3A_n.per.excl.start">n.per.excl.start</code></td>
<td>
<p>If any periods have been censored (AC data only). 
Default 0.</p>
</td></tr>
<tr><td><code id="apc.indiv.compare.direct_+3A_n.per.excl.end">n.per.excl.end</code></td>
<td>
<p>If any periods have been censored (AC data only). 
Default 0.</p>
</td></tr>
<tr><td><code id="apc.indiv.compare.direct_+3A_n.age.excl.start">n.age.excl.start</code></td>
<td>
<p>If any ages have been censored (PC data only). 
Default 0.</p>
</td></tr>
<tr><td><code id="apc.indiv.compare.direct_+3A_n.age.excl.end">n.age.excl.end</code></td>
<td>
<p>If any ages have been censored (PC data only). 
Default 0.</p>
</td></tr>
<tr><td><code id="apc.indiv.compare.direct_+3A_nr.controls">NR.controls</code></td>
<td>
<p>Optional list to modify aspects of the Newton-Rhapson
iteration for binomial TS model. See details in <code><a href="#topic+apc.indiv.est.model">apc.indiv.est.model</a></code>.</p>
</td></tr>
<tr><td><code id="apc.indiv.compare.direct_+3A_test">test</code></td>
<td>
<p>The type of test. One of &quot;LR&quot;, &quot;Wald&quot;.</p>
</td></tr>
<tr><td><code id="apc.indiv.compare.direct_+3A_dist">dist</code></td>
<td>
<p>The distribution against which the test statistic is compared. One of &quot;F&quot;, &quot;Chisq&quot;.</p>
</td></tr>
<tr><td><code id="apc.indiv.compare.direct_+3A_wt.var">wt.var</code></td>
<td>
<p>Only if using survey weights. The name of the weights variable.</p>
</td></tr>
<tr><td><code id="apc.indiv.compare.direct_+3A_plmmodel">plmmodel</code></td>
<td>
<p>Used to indicate whether a panel data model is to be estimated and if so what type. Default is &quot;notplm&quot;, for not panel data. Other values are &quot;pooling&quot;, &quot;within&quot;, &quot;random&quot;. Further details in <code><a href="plm.html#topic+plm">plm</a></code>.</p>
</td></tr>
<tr><td><code id="apc.indiv.compare.direct_+3A_id.var">id.var</code></td>
<td>
<p>Only if using panel data. The name of the individual ID variable.</p>
</td></tr>
<tr><td><code id="apc.indiv.compare.direct_+3A_existing.big.model.fit">existing.big.model.fit</code></td>
<td>
<p>Optional specify the output of
apc.indiv.fit.model, if already run for the big model.</p>
</td></tr>
<tr><td><code id="apc.indiv.compare.direct_+3A_existing.small.model.fit">existing.small.model.fit</code></td>
<td>
<p>Optional specify the output of 
apc.indiv.fit.model, if already run for the small model.</p>
</td></tr>
<tr><td><code id="apc.indiv.compare.direct_+3A_existing.collinear">existing.collinear</code></td>
<td>
<p>Optional specify the output of 
apc.indiv.design.collinear, if already run.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions are designed to facilitate direct comparison between
sub-models. The functions are used to construct the rows of tables in 
<code>apc.indiv.model.table</code> but can also more helpfully be used to compare 
nested sub-models that gain similar levels of suport from such a table, e.g. 
PC to P. </p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>test.type</code></td>
<td>
<p>The type of test, one of &quot;LR&quot;, &quot;Wald&quot;.</p>
</td></tr>
<tr><td><code>dist.type</code></td>
<td>
<p>The distribution against which the test statistic is compared. One of &quot;F&quot;, &quot;Chisq&quot;.</p>
</td></tr>
<tr><td><code>test.stat</code></td>
<td>
<p>The value of the test statistic.</p>
</td></tr>
<tr><td><code>df</code></td>
<td>
<p>Degrees of freedom.</p>
</td></tr>
<tr><td><code>df.num</code></td>
<td>
<p>Gaussian models only. Degrees of freedom used in the numerator 
of the F-statistic.</p>
</td></tr>
<tr><td><code>df.denom</code></td>
<td>
<p>Gaussian models only. Degrees of freedom used in the 
denominator of the F-statistic.</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>P-value from testing against a chi-square or F distribution.</p>
</td></tr>
<tr><td><code>aic.big</code></td>
<td>
<p>AIC of the big model.</p>
</td></tr>
<tr><td><code>aic.small</code></td>
<td>
<p>AIC of the small model.</p>
</td></tr>
<tr><td><code>lik.big</code></td>
<td>
<p>Log-likelihood of the big model.</p>
</td></tr>
<tr><td><code>lik.small</code></td>
<td>
<p>Log-likelihood of the small model.</p>
</td></tr>
<tr><td><code>NR.report</code></td>
<td>
<p>Binomial TS model only. Report on the Newton-Rhapson 
algorithm. </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Zoe Fannon &lt;zoe.fannon@economics.ox.ac.uk&gt; 26 Jun 2020</p>


<h3>References</h3>

<p>Fannon, Z. (2018) <code>apc.indiv</code>: R tools to estimate age-period-cohort models with 
repeated cross section data. Mimeo. University of Oxford.
</p>
<p>Fannon, Z., Monden, C. and Nielsen, B. (2018) Age-period-cohort modelling and
covariates, with an application to obesity in England 2001-2014. Mimeo. 
University of Oxford.
</p>


<h3>See Also</h3>

<p>For model estimation: <code><a href="#topic+apc.indiv.est.model">apc.indiv.est.model</a></code>.
The data in these examples are the
<code><a href="ISLR.html#topic+Wage">Wage</a></code> data from the package ISLR
and the
<code><a href="AER.html#topic+PSID7682">PSID7682</a></code> data from the package AER.
</p>
<p>For examples, see the vignette
<a href="../doc/IntroductionIndividualData.pdf"><code>IntroductionIndividualData.pdf</code></a>,
<a href="../doc/IntroductionIndividualData.R"><code>IntroductionIndividualData.R</code></a>
on
<a href="../doc/index.html"><code>Vignettes</code></a>.
Further examples in the vignette
<a href="../doc/IntroductionIndividualDataFurtherExamples.pdf"><code>IntroductionIndividualDataFurtherExamples.pdf</code></a>,
<a href="../doc/IntroductionIndividualDataFurtherExamples.R"><code>IntroductionIndividualDataFurtherExamples.R</code></a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#### see vignettes
</code></pre>

<hr>
<h2 id='apc.indiv.est.model'>Estimate a single APC model</h2><span id='topic+apc.indiv.est.model'></span><span id='topic+apc.indiv.design.collinear'></span><span id='topic+apc.indiv.design.model'></span><span id='topic+apc.indiv.fit.model'></span><span id='topic+apc.indiv.estimate.TS'></span><span id='topic+apc.indiv.logit.TS'></span>

<h3>Description</h3>

<p>The function <code>apc.indiv.est.model</code> is used to estimate any of:
the APC model, any APC submodel, or the time-saturated model. To estimate
the APC model or a submodel, it calls <code>apc.indiv.design.collinear</code>,
<code>apc.indiv.design.model</code>, and <code>apc.indiv.fit.model</code> in that order.
To estimate the time-saturated (TS) model it calls either
<code>apc.indiv.estimate.TS</code> or <code>apc.indiv.logit.TS</code>, depending on the
selected <code>model.family</code>. These functions can also be called directly by
the user.</p>


<h3>Usage</h3>

<pre><code class='language-R'>  apc.indiv.est.model(data, unit = 1,
                      n.coh.excl.start=0, n.coh.excl.end=0,
                      n.per.excl.start=0, n.per.excl.end=0,
                      n.age.excl.start=0, n.age.excl.end=0,  
                      model.design = "APC", dep.var = NULL, 
                      covariates = NULL, model.family = "gaussian",
                      NR.controls = NULL, 
                      existing.collinear = NULL,
                      existing.design = NULL,
					  plmmodel = "notplm", id.var = NULL,
                      wt.var = NULL)					  
  apc.indiv.design.collinear(data, unit = 1,
                             n.coh.excl.start = 0, n.coh.excl.end = 0,
                             n.per.excl.start = 0, n.per.excl.end = 0,
                             n.age.excl.start = 0, n.age.excl.end = 0)
  apc.indiv.design.model(apc.indiv.design.collinear,
                         model.design = "APC", dep.var = NULL, 
                         covariates = NULL, plmmodel = "notplm",
                         wt.var = NULL, id.var = NULL)
  apc.indiv.fit.model(apc.indiv.design.model, model.family = "gaussian", DV = NULL)
  apc.indiv.estimate.TS(data, dep.var, covariates = NULL)
  apc.indiv.logit.TS(data, dep.var, covariates = NULL, NR.controls = NULL)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="apc.indiv.est.model_+3A_data">data</code></td>
<td>
<p>The data.frame in use</p>
</td></tr>
<tr><td><code id="apc.indiv.est.model_+3A_unit">unit</code></td>
<td>
<p>The interval at which age, period, and cohort are recorded 
(must be the same for each). Default 1.</p>
</td></tr>
<tr><td><code id="apc.indiv.est.model_+3A_n.coh.excl.start">n.coh.excl.start</code></td>
<td>
<p>If any cohorts have been censored (AP data only). 
Default 0.</p>
</td></tr>
<tr><td><code id="apc.indiv.est.model_+3A_n.coh.excl.end">n.coh.excl.end</code></td>
<td>
<p>If any cohorts have been censored (AP data only). 
Default 0.</p>
</td></tr>
<tr><td><code id="apc.indiv.est.model_+3A_n.per.excl.start">n.per.excl.start</code></td>
<td>
<p>If any periods have been censored (AC data only). 
Default 0.</p>
</td></tr>
<tr><td><code id="apc.indiv.est.model_+3A_n.per.excl.end">n.per.excl.end</code></td>
<td>
<p>If any periods have been censored (AC data only). 
Default 0.</p>
</td></tr>
<tr><td><code id="apc.indiv.est.model_+3A_n.age.excl.start">n.age.excl.start</code></td>
<td>
<p>If any ages have been censored (PC data only). 
Default 0.</p>
</td></tr>
<tr><td><code id="apc.indiv.est.model_+3A_n.age.excl.end">n.age.excl.end</code></td>
<td>
<p>If any ages have been censored (PC data only). 
Default 0.</p>
</td></tr>
<tr><td><code id="apc.indiv.est.model_+3A_model.design">model.design</code></td>
<td>
<p>The name of the model to be estimated. One of &quot;TS&quot;,
&quot;APC&quot;, &quot;AC&quot;, etc.</p>
</td></tr>
<tr><td><code id="apc.indiv.est.model_+3A_dep.var">dep.var</code></td>
<td>
<p>The name of the dependent variable as it appears in the data</p>
</td></tr>
<tr><td><code id="apc.indiv.est.model_+3A_dv">DV</code></td>
<td>
<p>apc.indiv.fit.model only. Optional. Vector containing dependent 
variable. </p>
</td></tr>
<tr><td><code id="apc.indiv.est.model_+3A_covariates">covariates</code></td>
<td>
<p>A vector of the names of covariates as they appear in the 
data. Default NULL.</p>
</td></tr>
<tr><td><code id="apc.indiv.est.model_+3A_plmmodel">plmmodel</code></td>
<td>
<p>Used to indicate whether a panel data model is to be estimated and if so what type. Default is &quot;notplm&quot;, for not panel data. Other values are &quot;pooling&quot;, &quot;within&quot;, &quot;random&quot;. Further details in <code><a href="plm.html#topic+plm">plm</a></code>.</p>
</td></tr>
<tr><td><code id="apc.indiv.est.model_+3A_id.var">id.var</code></td>
<td>
<p>Only if using panel data. The name of the individual ID variable.</p>
</td></tr>
<tr><td><code id="apc.indiv.est.model_+3A_wt.var">wt.var</code></td>
<td>
<p>Only if using survey weights. The name of the weights variable.</p>
</td></tr>
<tr><td><code id="apc.indiv.est.model_+3A_model.family">model.family</code></td>
<td>
<p>Either &quot;gaussian&quot; or &quot;binomial&quot;. Default &quot;gaussian&quot;.</p>
</td></tr>
<tr><td><code id="apc.indiv.est.model_+3A_nr.controls">NR.controls</code></td>
<td>
<p>Optional list to modify aspects of the Newton-Rhapson 
iteration for binomial TS model. Further information in &quot;Details&quot;, below.</p>
</td></tr>
<tr><td><code id="apc.indiv.est.model_+3A_existing.collinear">existing.collinear</code></td>
<td>
<p>Optional specify the output of 
apc.indiv.design.collinear, if already run.</p>
</td></tr>
<tr><td><code id="apc.indiv.est.model_+3A_existing.design">existing.design</code></td>
<td>
<p>Optional specify the output of apc.indiv.design.model,
if already run.</p>
</td></tr>
<tr><td><code id="apc.indiv.est.model_+3A_apc.indiv.design.collinear">apc.indiv.design.collinear</code></td>
<td>
<p>Output from the command 
<code>apc.indiv.design.collinear</code>.</p>
</td></tr>
<tr><td><code id="apc.indiv.est.model_+3A_apc.indiv.design.model">apc.indiv.design.model</code></td>
<td>
<p>Output from the command 
<code>apc.indiv.design.model</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The casual user should start with the general function 
<code>apc.indiv.est.model</code> for analysis. The underlying functions should be
employed if the user needs to run many models using the same relatively large
dataset, in which case time can be saved by running 
<code>apc.indiv.design.collinear</code> just once and using 
<code>apc.indiv.design.model</code> and <code>apc.indiv.fit.model</code> to estimate 
each of the models.
</p>
<p>The time-saturated (TS) binomial model is estimated by a customized
Newton-Rhapson iteration. Aspects of this iteration can be controlled by
specifying the <code>NR.controls</code> option of <code>apc.indiv.est.model</code> or of
<code>apc.indiv.logit.TS</code>.
<code>NR.controls</code> is a named list of length <code>8</code>.
In order, the elements are:
<code>maxit.loop</code>, <code>maxit.linesearch</code>, <code>tolerance</code>, <code>init</code>,
<code>inv.tol</code>, <code>d1.tol</code>, <code>custom.kappa</code>, <code>custom.zeta</code>.
<code>maxit.loop</code> sets the maximum number of Newton-Rhapson iterations, and has a default of 10.
<code>maxit.linesearch</code> sets the maximum number of linesearch iterations
within each Newton-Rhapson iteration, and has a default of 20.
<code>tolerance</code> sets the condition for convergence, i.e. the tolerated
difference between likelihoods from one Newton-Rhapson iteration to the
next; the default is <code>.002</code>.
<code>init</code> sets the starting values for the iteration. The default is
<code>"ols"</code>, meaning that estimates from the linear probability model are
the starting values; one can also use <code>"zero"</code> to set the starting
values to zero, or use <code>"custom"</code> and specify custom starting values
using <code>custom.kappa</code> and <code>custom.zeta</code>.
<code>inv.tol</code>sets the tolerance of small values when inverting a matrix
(using <code><a href="base.html#topic+solve">solve</a></code>), and the default is the machine precision.
<code>d1.tol</code> sets the magnitude of norm of first derivative to be tolerated
in Newton-Rhapson iteration, and has a default of <code>.002</code>.
<code>custom.kappa</code> is used to specify custom starting values for the TS
indicator parameters, while <code>custom.zeta</code> is used to specify custom
starting values for parameters on any covariates.
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>fit</code></td>
<td>
<p>The output of either <code><a href="stats.html#topic+glm">glm</a></code>, <code><a href="survey.html#topic+svyglm">svyglm</a></code>, or <code><a href="plm.html#topic+plm">plm</a></code> for repeated cross-section, repeated cross-section with survey weights, or panel models respectively. Can be used directly with follow-on functions like <code><a href="lmtest.html#topic+waldtest">waldtest</a></code></p>
</td></tr></table>
<p>.
</p>
<table role = "presentation">
<tr><td><code>coefficients.canonical</code></td>
<td>
<p>Matrix of estimates, standard error, t-statistic, and p-value of canonical parameter.</p>
</td></tr>
<tr><td><code>coefficients.covariates</code></td>
<td>
<p>Matrix of estimates, standard error, t-statistic, and p-value of covariates.</p>
</td></tr>
<tr><td><code>coefficients.TS</code></td>
<td>
<p>TS model only: matrix of estimates, standard error, t-statistic, and p-value of TS indicators. </p>
</td></tr>
<tr><td><code>aic</code></td>
<td>
<p>TS model only: Akaike Information Criterion.</p>
</td></tr>
<tr><td><code>likelihood</code></td>
<td>
<p>model likelihood.</p>
</td></tr>
<tr><td><code>model.design</code></td>
<td>
<p>which APC submodel has been estimated.</p>
</td></tr>
<tr><td><code>fixef</code></td>
<td>
<p>When plmmodel = &quot;within&quot;, estimated individual fixed effects. Otherwise NULL. </p>
</td></tr>
<tr><td><code>full.design.collinear</code></td>
<td>
<p>from apc.indiv.design.collinear only. The 
collinear design matrix.</p>
</td></tr>
<tr><td><code>full.design</code></td>
<td>
<p>from apc.indiv.design.model only. The design matrix used to estimate the model.</p>
</td></tr>
<tr><td><code>DV</code></td>
<td>
<p>from apc.indiv.design.model only, if dep.var specified. A vector of the outcome variable. </p>
</td></tr>
<tr><td><code>ID</code></td>
<td>
<p>from apc.indiv.design.model only, if panel model. A vector of the individual ID variable.</p>
</td></tr>
<tr><td><code>PER</code></td>
<td>
<p>from apc.indiv.design.model only, if panel model. A vector of the period variable.</p>
</td></tr>
<tr><td><code>WT</code></td>
<td>
<p>from apc.indiv.design.model only, if wt.var specified. A vector of the survey weight variable. </p>
</td></tr>
<tr><td><code>model.formula</code></td>
<td>
<p>from apc.indiv.design.model only, the implied model formula. NULL if dep.var not specified.</p>
</td></tr>
<tr><td><code>model.string</code></td>
<td>
<p>from apc.indiv.design.model only, the implied model formula as a character string. RHS only if dep.var not specified. </p>
</td></tr>  
</table>


<h3>Author(s)</h3>

<p>Zoe Fannon &lt;zoe.fannon@economics.ox.ac.uk&gt; 26 Jun 2020</p>


<h3>References</h3>

<p>Fannon, Z. (2018) <code>apc.indiv</code>: R tools to estimate age-period-cohort models with
repeated cross section data. Mimeo. University of Oxford.
</p>
<p>Fannon, Z., Monden, C. and Nielsen, B. (2018) Age-period-cohort modelling and
covariates, with an application to obesity in England 2001-2014. Mimeo. 
University of Oxford.
</p>


<h3>See Also</h3>

<p>For model estimation: <code><a href="stats.html#topic+glm">glm</a></code>, <code><a href="survey.html#topic+svyglm">svyglm</a></code>, <code><a href="plm.html#topic+plm">plm</a></code>
For model testing: <code><a href="#topic+apc.indiv.model.table">apc.indiv.model.table</a></code>, code<a href="#topic+apc.indiv.compare.direct">apc.indiv.compare.direct</a>, <code><a href="lmtest.html#topic+waldtest">waldtest</a></code>, <code><a href="car.html#topic+linearHypothesis">linearHypothesis</a></code>
For plotting: <code><a href="#topic+apc.plot.fit">apc.plot.fit</a></code>.
The data in these examples are the
<code><a href="ISLR.html#topic+Wage">Wage</a></code> data from the package ISLR
and the
<code><a href="AER.html#topic+PSID7682">PSID7682</a></code> data from the package AER.
</p>
<p>For examples, see the vignette
<a href="../doc/IntroductionIndividualData.pdf"><code>IntroductionIndividualData.pdf</code></a>,
<a href="../doc/IntroductionIndividualData.R"><code>IntroductionIndividualData.R</code></a>
on
<a href="../doc/index.html"><code>Vignettes</code></a>.
Further examples in the vignette
<a href="../doc/IntroductionIndividualDataFurtherExamples.pdf"><code>IntroductionIndividualDataFurtherExamples.pdf</code></a>,
<a href="../doc/IntroductionIndividualDataFurtherExamples.R"><code>IntroductionIndividualDataFurtherExamples.R</code></a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#### see vignettes
</code></pre>

<hr>
<h2 id='apc.indiv.model.table'>
Generate table to select APC submodel</h2><span id='topic+apc.indiv.model.table'></span><span id='topic+apc.indiv.waldtable'></span><span id='topic+apc.indiv.waldtable.TS'></span><span id='topic+apc.indiv.LRtable'></span><span id='topic+apc.indiv.LRtable.TS'></span>

<h3>Description</h3>

<p>These functions test, for a given choice of dependent variable and covariates, which of the TS, APC, and APC submodels provides the best fit to the data. Comparison is by Wald or likelihood ratio test and  where appropriate by Akaike Information Criterion. A table is generated with these statistics for each model considered. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>apc.indiv.model.table(data, dep.var, covariates = NULL,
			unit = 1, n.coh.excl.start = 0, n.coh.excl.end = 0,
			n.age.excl.start = 0, n.age.excl.end = 0,
			n.per.excl.start = 0, n.per.excl.end = 0,
			model.family, NR.controls = NULL,
			test, dist,
			TS=FALSE, wt.var=NULL, plmmodel="notplm",
			id.var=NULL)
	   apc.indiv.waldtable(data, dep.var, covariates = NULL, 
	   dist="F", unit = 1, model.family, 
	    	n.coh.excl.start = 0, n.coh.excl.end = 0,
			n.age.excl.start = 0, n.age.excl.end = 0,
			n.per.excl.start = 0, n.per.excl.end = 0,
			 wt.var=NULL, plmmodel="notplm",
			id.var=NULL)
			apc.indiv.waldtable.TS(data, dep.var, covariates=NULL, dist = "F",
                                unit=1, model.family = "gaussian",
                                n.coh.excl.start=0, n.coh.excl.end=0, 
                                n.age.excl.start=0, n.age.excl.end=0, 
                                n.per.excl.start=0, n.per.excl.end=0)
     apc.indiv.LRtable(data,  dep.var, covariates=NULL, 
                              model.family, unit=1, 
                              n.coh.excl.start=0, n.coh.excl.end=0, 
                              n.age.excl.start=0, n.age.excl.end=0,
                              n.per.excl.start=0, n.per.excl.end=0)
	   apc.indiv.LRtable.TS(data,  dep.var, covariates=NULL, 
                                 model.family, unit=1, 
                                 n.coh.excl.start=0, n.coh.excl.end=0, 
                                 n.age.excl.start=0, n.age.excl.end=0,
                                 n.per.excl.start=0, n.per.excl.end=0,
                                 NR.controls=NR.controls)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="apc.indiv.model.table_+3A_data">data</code></td>
<td>

<p>The data.frame in use</p>
</td></tr>
<tr><td><code id="apc.indiv.model.table_+3A_dep.var">dep.var</code></td>
<td>

<p>The name of the dependent variable as it appears in the data</p>
</td></tr>
<tr><td><code id="apc.indiv.model.table_+3A_covariates">covariates</code></td>
<td>

<p>A vector of the names of covariates as they appear in the data. Default NULL.</p>
</td></tr>
<tr><td><code id="apc.indiv.model.table_+3A_unit">unit</code></td>
<td>

<p>The interval at which age, period, and cohort are recorded (must be the same for each). Default 1.</p>
</td></tr>
<tr><td><code id="apc.indiv.model.table_+3A_n.coh.excl.start">n.coh.excl.start</code></td>
<td>

<p>If any cohorts have been censored (AP data only). Default 0.</p>
</td></tr>
<tr><td><code id="apc.indiv.model.table_+3A_n.coh.excl.end">n.coh.excl.end</code></td>
<td>

<p>If any cohorts have been censored (AP data only). Default 0.</p>
</td></tr>
<tr><td><code id="apc.indiv.model.table_+3A_n.age.excl.start">n.age.excl.start</code></td>
<td>

<p>If any ages have been censored (PC data only). Default 0.</p>
</td></tr>
<tr><td><code id="apc.indiv.model.table_+3A_n.age.excl.end">n.age.excl.end</code></td>
<td>

<p>If any ages have been censored (PC data only). Default 0.</p>
</td></tr>
<tr><td><code id="apc.indiv.model.table_+3A_n.per.excl.start">n.per.excl.start</code></td>
<td>

<p>If any periods have been censored (AC data only). Default 0.</p>
</td></tr>
<tr><td><code id="apc.indiv.model.table_+3A_n.per.excl.end">n.per.excl.end</code></td>
<td>

<p>If any periods have been censored (AC data only). Default 0.</p>
</td></tr>
<tr><td><code id="apc.indiv.model.table_+3A_model.family">model.family</code></td>
<td>

<p>Either &quot;gaussian&quot; or &quot;binomial&quot;</p>
</td></tr>
<tr><td><code id="apc.indiv.model.table_+3A_nr.controls">NR.controls</code></td>
<td>

<p>Optional list to modify aspects of the Newton-Rhapson iteration for binomial TS model.See details in <code><a href="#topic+apc.indiv.est.model">apc.indiv.est.model</a></code>.</p>
</td></tr>
<tr><td><code id="apc.indiv.model.table_+3A_test">test</code></td>
<td>
<p>The type of test. One of &quot;LR&quot;, &quot;Wald&quot;.</p>
</td></tr>
<tr><td><code id="apc.indiv.model.table_+3A_ts">TS</code></td>
<td>
<p>...</p>
</td></tr>
<tr><td><code id="apc.indiv.model.table_+3A_dist">dist</code></td>
<td>
<p>The distribution against which the test statistic is compared. One of &quot;F&quot;, &quot;Chisq&quot;.</p>
</td></tr>
<tr><td><code id="apc.indiv.model.table_+3A_wt.var">wt.var</code></td>
<td>
<p>Only if using survey weights. The name of the weights variable.</p>
</td></tr>
<tr><td><code id="apc.indiv.model.table_+3A_plmmodel">plmmodel</code></td>
<td>
<p>Used to indicate whether a panel data model is to be estimated and if so what type. Default is &quot;notplm&quot;, for not panel data. Other values are &quot;pooling&quot;, &quot;within&quot;, &quot;random&quot;. Further details in <code><a href="plm.html#topic+plm">plm</a></code>.</p>
</td></tr>
<tr><td><code id="apc.indiv.model.table_+3A_id.var">id.var</code></td>
<td>
<p>Only if using panel data. The name of the individual ID variable.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Each row of the table corresponds to a single sub-model of the APC model. The first three columns test the sub-model in question against the time-saturated model. The next three columns test the sub-model against the full APC model. The final two columns report the likelihood and AIC of the estimated sub-model. The model with the lowest AIC value which is also not rejected in tests against the APC and TS models should be selected.</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>table</code></td>
<td>
<p>contains the table of comparison statistics.</p>
</td></tr>
<tr><td><code>NR.report</code></td>
<td>
<p>for logit models only, a report on the Newton-Rhapson algorithm used to estimate the time-saturated model.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Zoe Fannon &lt;zoe.fannon@economics.ox.ac.uk&gt; 26 Jun 2020</p>


<h3>References</h3>

<p>Fannon, Z. (2018) <code>apc.indiv</code>: R tools to estimate age-period-cohort models with repeated cross section data. Mimeo. University of Oxford.
</p>
<p>Fannon, Z., Monden, C. and Nielsen, B. (2018) Age-period-cohort modelling and covariates, with an application to obesity in England 2001-2014. Mimeo. University of Oxford.
</p>


<h3>See Also</h3>

<p>For model estimation: <code><a href="#topic+apc.indiv.est.model">apc.indiv.est.model</a></code>
For pairwise model comparison: <code><a href="#topic+apc.indiv.model.table">apc.indiv.model.table</a></code>, <code><a href="lmtest.html#topic+waldtest">waldtest</a></code>, <code><a href="car.html#topic+linearHypothesis">linearHypothesis</a></code>.
The data in these examples are the
<code><a href="ISLR.html#topic+Wage">Wage</a></code> data from the package ISLR
and the
<code><a href="AER.html#topic+PSID7682">PSID7682</a></code> data from the package AER.
</p>
<p>For examples, see the vignette
<a href="../doc/IntroductionIndividualData.pdf"><code>IntroductionIndividualData.pdf</code></a>,
<a href="../doc/IntroductionIndividualData.R"><code>IntroductionIndividualData.R</code></a>
on
<a href="../doc/index.html"><code>Vignettes</code></a>.
Further examples in the vignette
<a href="../doc/IntroductionIndividualDataFurtherExamples.pdf"><code>IntroductionIndividualDataFurtherExamples.pdf</code></a>,
<a href="../doc/IntroductionIndividualDataFurtherExamples.R"><code>IntroductionIndividualDataFurtherExamples.R</code></a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#### see vignettes
</code></pre>

<hr>
<h2 id='apc.plot.data.all'>Make all descriptive plots.</h2><span id='topic+apc.plot.data.all'></span>

<h3>Description</h3>

<p>Plots data sums using <code><a href="#topic+apc.plot.data.sums">apc.plot.data.sums</a></code>.
Sparsity plots of data using <code><a href="#topic+apc.plot.data.sparsity">apc.plot.data.sparsity</a></code>.
Plots data using all combinations of two time scales using <code><a href="#topic+apc.plot.data.within">apc.plot.data.within</a></code>.
Level plots of data using <code><a href="#topic+apc.plot.data.level">apc.plot.data.level</a></code>.
The latter plot is done for responses and if applicable also for doses and mortality rates.</p>


<h3>Usage</h3>

<pre><code class='language-R'>apc.plot.data.all(apc.data.list,log ="",rotate=FALSE)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="apc.plot.data.all_+3A_apc.data.list">apc.data.list</code></td>
<td>
<p>List. See <code><a href="#topic+apc.data.list">apc.data.list</a></code> for a description of the format.</p>
</td></tr>
<tr><td><code id="apc.plot.data.all_+3A_log">log</code></td>
<td>
<p>Optional <code><a href="base.html#topic+plot">plot</a></code> argument. Character. &quot;y&quot; if y-scale is logarithmic, otherwise &quot;&quot;. Default is &quot;y&quot;.</p>
</td></tr>
<tr><td><code id="apc.plot.data.all_+3A_rotate">rotate</code></td>
<td>
<p>Optional. Logical. If TRUE rotates <code><a href="#topic+apc.plot.data.level">apc.plot.data.level</a></code> 90 degrees clockwise (or anti-clockwise if data.format is &quot;CL&quot;). Default is FALSE.</p>
</td></tr>
</table>


<h3>Warning</h3>

<p>A warning is produced if dimension is not divisible by thin, so that one group is smaller than other groups.</p>


<h3>Author(s)</h3>

<p>Bent Nielsen &lt;bent.nielsen@nuffield.ox.ac.uk&gt; 25 Apr 2015</p>


<h3>See Also</h3>

<p>The example below uses Italian bladder cancer data, see <code><a href="#topic+data.Italian.bladder.cancer">data.Italian.bladder.cancer</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>#####################
#  EXAMPLE with artificial data
#  generate a 3x4 matrix in "AP" data.format with the numbers 1..12

m.data  	&lt;- matrix(data=seq(length.out=12),nrow=3,ncol=4)
m.data
data.list	&lt;- apc.data.list(m.data,"AP")
apc.plot.data.all(data.list,log="")				

#####################
#	EXAMPLE with Italian bladder cancer data
#
#	get data list, then make all descriptive plots.
# 	Note that warnings are given in relation to the data chosen thinning
#	This can be avoided by working with the individual plots, and in particular
#	with apc.plot.data.within where the thinning happens.
#
#	data.list	&lt;- data.Italian.bladder.cancer()	
#	apc.plot.data.all(data.list)
</code></pre>

<hr>
<h2 id='apc.plot.data.level'>Level plot of data matrix.</h2><span id='topic+apc.plot.data.level'></span>

<h3>Description</h3>

<p>This plot shows level plot of data matrix based on
<code><a href="lattice.html#topic+levelplot">levelplot</a></code> in the package <code><a href="lattice.html#topic+lattice">lattice</a></code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>apc.plot.data.level(apc.data.list,data.type="r",
 						rotate=FALSE,apc.index=NULL,
						main=NULL,lab=NULL,
						contour=FALSE,colorkey=TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="apc.plot.data.level_+3A_apc.data.list">apc.data.list</code></td>
<td>
<p>List. See <code><a href="#topic+apc.data.list">apc.data.list</a></code> for a description of the format.</p>
</td></tr>
<tr><td><code id="apc.plot.data.level_+3A_data.type">data.type</code></td>
<td>
<p>Optional. Character.
&quot;r&quot;=&quot;response&quot; /
&quot;d&quot;=&quot;dose&quot; /
&quot;m&quot;=&quot;mortality&quot;=&quot;rates&quot; 
if sums are computed for responses/dose/rates,
where rates are found through division response/dose.
It also takes data types 						
&quot;residual&quot; /
&quot;fitted.values&quot; /
&quot;linear.predictors&quot;
when the argument <code>apc.data.list</code> is the output of	the fitting function
<code><a href="#topic+apc.fit.model">apc.fit.model</a></code>, which is an extended apc.data.list.
&quot;r&quot; is default.</p>
</td></tr>
<tr><td><code id="apc.plot.data.level_+3A_rotate">rotate</code></td>
<td>
<p>Optional. Logical. If TRUE rotates plot 90 degrees clockwise (or anti-clockwise if data.format is &quot;CL&quot;). Default is FALSE.</p>
</td></tr>
<tr><td><code id="apc.plot.data.level_+3A_apc.index">apc.index</code></td>
<td>
<p>Optional. List. See <code><a href="#topic+apc.get.index">apc.get.index</a></code> for a description of the format.  If not provided this is computed.</p>
</td></tr>
<tr><td><code id="apc.plot.data.level_+3A_main">main</code></td>
<td>
<p>Optional. Character. Main title.</p>
</td></tr>
<tr><td><code id="apc.plot.data.level_+3A_lab">lab</code></td>
<td>
<p>Optional <code><a href="base.html#topic+plot">plot</a></code> parameter.	A numerical vector of the form c(x, y, len)
which modifies the default way that axes are annotated.
The values of x and y give the (approximate) number of tickmarks on
the x and y axes. len is not implemented.</p>
</td></tr>
<tr><td><code id="apc.plot.data.level_+3A_contour">contour</code></td>
<td>
<p> Optional <code><a href="lattice.html#topic+levelplot">levelplot</a></code> (<code><a href="lattice.html#topic+lattice">lattice</a></code>) parameter.
Logical. Contour lines drawn if TRUE. Default FALSE.</p>
</td></tr>
<tr><td><code id="apc.plot.data.level_+3A_colorkey">colorkey</code></td>
<td>
<p>Optional <code><a href="lattice.html#topic+levelplot">levelplot</a></code> (<code><a href="lattice.html#topic+lattice">lattice</a></code>) parameter.
Logical or list. Determines color key. Default TRUE.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Bent Nielsen &lt;bent.nielsen@nuffield.ox.ac.uk&gt; 26 Apr 2015</p>


<h3>See Also</h3>

<p><code><a href="#topic+data.Japanese.breast.cancer">data.Japanese.breast.cancer</a></code>
for information on the data used in the example.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#####################
#	EXAMPLE with Japanese breast cancer data
#	Clayton and Shifflers (1987b) use APC design
#	Make a data list
#	Then plot data.
#	Note: No plot appears to have approximately parallel lines.

data.list	&lt;- data.Japanese.breast.cancer()
apc.plot.data.level(data.list,"r")
dev.new()
apc.plot.data.level(data.list,"d",contour=TRUE)
												
#	It also works with a single argument, but then a default log scale is used.
# 	Note that warnings are given in relation to the data chosen thinning

apc.plot.data.within(data.list)

#####################
#	EXAMPLE with Italian bladder cancer data
#	Clayton and Shifflers (1987a) use AC design
#	Note: plot of within cohort against age appears to have approximately parallel lines.
#		  This is Figure 2 in Clayton and Shifflers (1987a)
#	Note: plot of within age against cohort appears to have approximately parallel lines.
#		  Indicates that interpretation should be done carefully.

data.list	&lt;- data.Italian.bladder.cancer()	
apc.plot.data.within(data.list,"m",1,log="y")

#####################
#	EXAMPLE with asbestos data
#	Miranda Martinex, Nielsen and Nielsen (2014).
#	This is Figure 1d 

data.list	&lt;- data.asbestos()	
apc.plot.data.within(data.list,type="l",lty=1)
</code></pre>

<hr>
<h2 id='apc.plot.data.sparsity'>This plot shows heat map of the sparsity of a data matrix.</h2><span id='topic+apc.plot.data.sparsity'></span>

<h3>Description</h3>

<p>The plot shows where the data matrix is sparse.</p>


<h3>Usage</h3>

<pre><code class='language-R'>apc.plot.data.sparsity(apc.data.list,
						data.type="a",swap.axes=FALSE,
						apc.index=NULL,
						sparsity.limits=c(1,2),
						cex=NULL,pch=15,
						main.outer=NULL)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="apc.plot.data.sparsity_+3A_apc.data.list">apc.data.list</code></td>
<td>
<p>List. See <code><a href="#topic+apc.data.list">apc.data.list</a></code> for a description of the format.</p>
</td></tr>
<tr><td><code id="apc.plot.data.sparsity_+3A_data.type">data.type</code></td>
<td>
<p>Optional. Character. &quot;r&quot;/&quot;d&quot;/&quot;m&quot; if sums are computed for responses/dose/all. &quot;r&quot; is default.</p>
</td></tr>
<tr><td><code id="apc.plot.data.sparsity_+3A_swap.axes">swap.axes</code></td>
<td>
<p>Optional. Logical. If true swap axes in plot.  Default is FALSE unless data.format=&quot;CL&quot;</p>
</td></tr>
<tr><td><code id="apc.plot.data.sparsity_+3A_apc.index">apc.index</code></td>
<td>
<p>Optional. List. See <code><a href="#topic+apc.get.index">apc.get.index</a></code> for a description of the format.  If not provided this is computed.</p>
</td></tr>
<tr><td><code id="apc.plot.data.sparsity_+3A_sparsity.limits">sparsity.limits</code></td>
<td>
<p>Optional. vector with two values in increasing order.  Default is c(1,2). The sparsity plot is a heat map with three colours: black if the observation is smaller than first index (default 1), grey if the observation is smaller than the second index (default 2) and otherwise white.</p>
</td></tr>
<tr><td><code id="apc.plot.data.sparsity_+3A_cex">cex</code></td>
<td>
<p>Optional <code><a href="base.html#topic+plot">plot</a></code> argument. A numerical value giving the amount by which plotting text and symbols should be magnified. Default is NULL in which case program chooses.</p>
</td></tr>
<tr><td><code id="apc.plot.data.sparsity_+3A_pch">pch</code></td>
<td>
<p>Optional. vector with two values. Either integers specifying a symbol or characters.
See <code><a href="graphics.html#topic+points">points</a></code> for possible values and their interpretation. Default is c(15,15), which is filled square.</p>
</td></tr>
<tr><td><code id="apc.plot.data.sparsity_+3A_main.outer">main.outer</code></td>
<td>
<p>Optional. Character. Main title for plot, to be shown in outer margin.  Default is NULL, in which case a title is generated internally.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The default values is used to highlight where a matrix of counts has values of zero and one. Estimation can be very noise in those areas.</p>


<h3>Note</h3>

<p>Note that the axes for plots grow from bottom left while axes for matrices grow from top left. The exception is when data.format=&quot;CL&quot;, in which case both grow from top left.</p>


<h3>Author(s)</h3>

<p>Bent Nielsen &lt;bent.nielsen@nuffield.ox.ac.uk&gt; 25 Apr 2015 updated 27 Apr 2015</p>


<h3>See Also</h3>

<p>The example below uses asbestos data, see <code><a href="#topic+data.asbestos">data.asbestos</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>#####################
#  EXAMPLE with artificial data
#  generate a 3x4 matrix in "AP" data.format with the numbers 1..12

m.data  	&lt;- matrix(data=seq(length.out=12),nrow=3,ncol=4)
m.data
data.list	&lt;- apc.data.list(m.data,"AP")
apc.plot.data.sparsity(data.list)

#####################
#	EXAMPLE with Japanese breast cancer data
#	get data list, then make sparsity plots.

data.list	&lt;- data.asbestos()					
apc.plot.data.sparsity(data.list)

</code></pre>

<hr>
<h2 id='apc.plot.data.sums'>This plot shows sums of data matrix by age, period or cohort.</h2><span id='topic+apc.plot.data.sums'></span>

<h3>Description</h3>

<p>Produces plots showing age, period and cohort sums.
As a default this is done both for responses and dose, giving a total of six plots.</p>


<h3>Usage</h3>

<pre><code class='language-R'>apc.plot.data.sums(apc.data.list,data.type="a",
			average=FALSE,keep.incomplete=TRUE,apc.index=NULL,
			type="o",log="",main.outer=NULL,main.sub=NULL)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="apc.plot.data.sums_+3A_apc.data.list">apc.data.list</code></td>
<td>
<p>List. See <code><a href="#topic+apc.data.list">apc.data.list</a></code> for a description of the format.</p>
</td></tr>
<tr><td><code id="apc.plot.data.sums_+3A_data.type">data.type</code></td>
<td>
<p>Optional. Character. &quot;r&quot;,&quot;d&quot;,&quot;m&quot;,&quot;a&quot; if sums are computed for responses, dose, (mortality rates), all. Rates are computed as responses/doses. Default is &quot;a&quot;.</p>
</td></tr>
<tr><td><code id="apc.plot.data.sums_+3A_average">average</code></td>
<td>
<p>Optional. Logical. Sums are reported if FALSE, Averages are reported if TRUE. Default is FALSE.</p>
</td></tr>
<tr><td><code id="apc.plot.data.sums_+3A_keep.incomplete">keep.incomplete</code></td>
<td>
<p>Optional. Logical. If true perform calculation for incomplete sequences by removing NA.
If false incomplete sequences are NA.  See example in <code><a href="#topic+apc.data.sums">apc.data.sums</a></code>. Default=TRUE.</p>
</td></tr>
<tr><td><code id="apc.plot.data.sums_+3A_apc.index">apc.index</code></td>
<td>
<p>Optional. List. See <code><a href="#topic+apc.get.index">apc.get.index</a></code> for a description of the format.  If not provided this is computed.</p>
</td></tr>
<tr><td><code id="apc.plot.data.sums_+3A_type">type</code></td>
<td>
<p>Optional <code><a href="base.html#topic+plot">plot</a></code> argument. Character. &quot;o&quot; if overlaid points and lines. &quot;l&quot; if lines. &quot;p&quot; if points. Default is &quot;o&quot;.</p>
</td></tr>
<tr><td><code id="apc.plot.data.sums_+3A_log">log</code></td>
<td>
<p>Optional <code><a href="base.html#topic+plot">plot</a></code> argument. Character. &quot;y&quot; if y-scale is logarithmic, otherwise &quot;&quot;. Default is &quot;&quot;.</p>
</td></tr>
<tr><td><code id="apc.plot.data.sums_+3A_main.outer">main.outer</code></td>
<td>
<p>Optional. Character. Main title for plot, to be shown in outer margin.  Default is NULL, in which case a title is generated internally.</p>
</td></tr>
<tr><td><code id="apc.plot.data.sums_+3A_main.sub">main.sub</code></td>
<td>
<p>Optional. Titles for sub plots. Use with data.type &quot;r&quot;,&quot;d&quot;,&quot;m&quot;.  For data.type &quot;a&quot; use default.  Default is NULL, in which case a title is generated internally.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The data sums are computed using <code><a href="#topic+apc.data.sums">apc.data.sums</a></code>.  Then plotted as requested.</p>


<h3>Note</h3>

<p>Use <code><a href="#topic+apc.data.sums">apc.data.sums</a></code> if numerical values needed.</p>


<h3>Author(s)</h3>

<p>Bent Nielsen &lt;bent.nielsen@nuffield.ox.ac.uk&gt; 15 Aug 2018 (15 Dec 2013)</p>


<h3>References</h3>

<p>Martinez Miranda, M.D., Nielsen, B. and Nielsen, J.P. (2015) Inference and forecasting in the age-period-cohort model with unknown exposure with an application to mesothelioma mortality. <em>Journal of the Royal Statistical Society</em> A 178, 29-55. <em>Download</em>: <a href="https://doi.org/10.1111/rssa.12051">Article</a>, <a href="http://www.nuffield.ox.ac.uk/economics/papers/2013/Asbestos8mar13.pdf">Nuffield DP</a>. 
</p>


<h3>See Also</h3>

<p>The example below uses Japanese breast cancer data, see <code><a href="#topic+data.Japanese.breast.cancer">data.Japanese.breast.cancer</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>#####################
#  	EXAMPLE with artificial data
#  	Generate a 3x4 matrix in "AP" data.format with the numbers 1..12
#	Then make a data list
#	Then plot data sums.
#	Note only 3 plots are made as there are no doses

m.data  	&lt;- matrix(data=seq(length.out=12),nrow=3,ncol=4)
m.data
data.list	&lt;- apc.data.list(m.data,"AP")
apc.plot.data.sums(data.list)					 
apc.plot.data.sums(data.list,average=TRUE)
apc.plot.data.sums(data.list,keep.incomplete=FALSE)					 

#####################
#	EXAMPLE with Japanese breast cancer data
#	Make a data list
#	Then plot data sums for both responses and doses.

data.list	&lt;- data.Japanese.breast.cancer()	
apc.plot.data.sums(data.list)					

# 	Or plot data sums for responses only

apc.plot.data.sums(data.list,data.type="r")		

#####################
#	EXAMPLE with asbestos data
#	Miranda Martinex, Nielsen and Nielsen (2013).
#	This is Figure 1,a-c 

data.list	&lt;- data.asbestos()	
apc.plot.data.sums(data.list,type="l")
</code></pre>

<hr>
<h2 id='apc.plot.data.within'>This plot shows time series of matrix within age, period or cohort.</h2><span id='topic+apc.plot.data.within'></span><span id='topic+apc.plot.data.within.all.six'></span>

<h3>Description</h3>

<p><code>apc.plot.data.within</code> produces plot showing time series of matrix
within age, period or cohort against one of the other two indices.
<code>apc.plot.data.within.all.six</code> produces all six plots in one panel plot.
</p>
<p>These plots are sometimes used to gauge how many of the age, period, cohort factors are needed:
If lines are parallel when dropping one index the corresponding factor may not be needed.
In practice these plots should possibly be used with care, see Italian bladder cancer example below.</p>


<h3>Usage</h3>

<pre><code class='language-R'>apc.plot.data.within(apc.data.list,
					data.type="r",plot.type="awc",
					average=FALSE,
					thin=NULL,apc.index=NULL,
					ylab=NULL,type="o",log="",legend=TRUE,
					lty=1:5,col=1:6,bty="n",main=NULL,
					x="topleft",return=FALSE)
apc.plot.data.within.all.six(apc.data.list,
					data.type="r",
					average=FALSE,
					thin=NULL,apc.index=NULL,
					ylab=NULL,type="o",log="",legend=TRUE,
					lty=1:5,col=1:6,bty="n",main.outer=NULL,
					x="topleft")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="apc.plot.data.within_+3A_apc.data.list">apc.data.list</code></td>
<td>
<p>List. See <code><a href="#topic+apc.data.list">apc.data.list</a></code> for a description of the format.</p>
</td></tr>
<tr><td><code id="apc.plot.data.within_+3A_data.type">data.type</code></td>
<td>
<p>Optional. Character. &quot;r&quot;=&quot;response&quot; / &quot;d&quot;=&quot;dose&quot; / &quot;m&quot;=&quot;mortality&quot;=&quot;rates&quot;
if sums are computed for responses/dose/rates,
where rates are found through division response/dose. &quot;r&quot; is default.</p>
</td></tr>
<tr><td><code id="apc.plot.data.within_+3A_plot.type">plot.type</code></td>
<td>
<p>Optional. &quot;awp&quot;, &quot;pwa&quot; &quot;awc&quot;, &quot;cwa, &quot;cwp&quot;, &quot;pwc&quot;:
for example: &quot;awp&quot; gives time series in age within each period level:
for an AP data-array these are the column sums.</p>
</td></tr>					
<tr><td><code id="apc.plot.data.within_+3A_average">average</code></td>
<td>
<p>Optional.  Logical. If TRUE/FALSE reports averages/sums. Default is FALSE.</p>
</td></tr>
<tr><td><code id="apc.plot.data.within_+3A_thin">thin</code></td>
<td>
<p>Optional. Numerical.  age/periods/cohorts are grouped in groups of size thin.
Default is computed from dimensions of data.  A warning is produced if dimension is not divisible by thin, so that one group is smaller than other groups.</p>
</td></tr>
<tr><td><code id="apc.plot.data.within_+3A_apc.index">apc.index</code></td>
<td>
<p>Optional. List. See <code><a href="#topic+apc.get.index">apc.get.index</a></code> for a description of the format.  If not provided this is computed.</p>
</td></tr>
<tr><td><code id="apc.plot.data.within_+3A_ylab">ylab</code></td>
<td>
<p>Optional <code><a href="base.html#topic+plot">plot</a></code> argument.  Character.  Common label for y-axes. Default is &quot;&quot;.</p>
</td></tr>
<tr><td><code id="apc.plot.data.within_+3A_type">type</code></td>
<td>
<p>Optional <code><a href="base.html#topic+plot">plot</a></code> argument. Character. &quot;o&quot; if overlaid points and lines. &quot;l&quot; if lines. &quot;p&quot; if points. Default is &quot;o&quot;.</p>
</td></tr>
<tr><td><code id="apc.plot.data.within_+3A_log">log</code></td>
<td>
<p>Optional <code><a href="base.html#topic+plot">plot</a></code> argument. Character. &quot;y&quot; if y-scale is logarithmic, otherwise &quot;&quot;. Default is &quot;&quot;</p>
</td></tr>
<tr><td><code id="apc.plot.data.within_+3A_legend">legend</code></td>
<td>
<p>Optional <code><a href="base.html#topic+plot">plot</a></code> argument. Logical. Should legends be drawn? Default is TRUE.</p>
</td></tr>
<tr><td><code id="apc.plot.data.within_+3A_lty">lty</code></td>
<td>
<p>Optional <code><a href="base.html#topic+plot">plot</a></code> argument. Vector of line types.
The first element is for the first column, the second element for the second column, etc.,
even if lines are not plotted for all columns. Line types will be used cyclically
until all plots are drawn.  Default is 1:5</p>
</td></tr>
<tr><td><code id="apc.plot.data.within_+3A_col">col</code></td>
<td>
<p>Optional <code><a href="base.html#topic+plot">plot</a></code> argument. Vector of colors.
The first element is for the first column, the second element for the second column, etc.,
even if lines are not plotted for all columns. Colors will be used cyclically
until all plots are drawn.  Default is 1:6.</p>
</td></tr>
<tr><td><code id="apc.plot.data.within_+3A_bty">bty</code></td>
<td>
<p>Optional <code><a href="base.html#topic+plot">plot</a></code> argument. Character.
The type of box to be drawn around the legend.
The allowed values are &quot;n&quot; and &quot;o&quot;.	Default is &quot;n&quot;.</p>
</td></tr>
<tr><td><code id="apc.plot.data.within_+3A_main">main</code></td>
<td>
<p>Optional. Character. Main title for single plot.  Default is NULL, in which case a title is generated internally.</p>
</td></tr>
<tr><td><code id="apc.plot.data.within_+3A_main.outer">main.outer</code></td>
<td>
<p>Optional. Character. Main title for panel of six plots, to be shown in outer margin.  Default is NULL, in which case a title is generated internally.</p>
</td></tr>
<tr><td><code id="apc.plot.data.within_+3A_x">x</code></td>
<td>
<p>Optional <code><a href="graphics.html#topic+legend">legend</a></code> argument. Default is &quot;topleft&quot;.</p>
</td></tr>
<tr><td><code id="apc.plot.data.within_+3A_return">return</code></td>
<td>
<p>Optional. If TRUE return matrix that is plotted. Default is FALSE</p>
</td></tr>
</table>


<h3>Warning</h3>

<p>A warning is produced if dimension is not divisible by thin, so that one group is smaller than other groups.</p>


<h3>Author(s)</h3>

<p>Bent Nielsen &lt;bent.nielsen@nuffield.ox.ac.uk&gt; 17 Nov 2016 (25 Apr 2015)</p>


<h3>References</h3>

<p>Clayton, D. and Schifflers, E. (1987a)
Models for temperoral variation in cancer rates. I: age-period and age-cohort models. 
<em>Statistics in Medicine</em> 6, 449-467.
</p>
<p>Clayton, D. and Schifflers, E. (1987b) Models for temperoral variation in cancer rates. II: age-period-cohort models. <em>Statistics in Medicine</em> 6, 469-481.
</p>
<p>Martinez Miranda, M.D., Nielsen, B. and Nielsen, J.P. (2015) Inference and forecasting in the age-period-cohort model with unknown exposure with an application to mesothelioma mortality. <em>Journal of the Royal Statistical Society</em> A 178, 29-55. <em>Download</em>: <a href="https://doi.org/10.1111/rssa.12051">Article</a>, <a href="http://www.nuffield.ox.ac.uk/economics/papers/2013/Asbestos8mar13.pdf">Nuffield DP</a>. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+data.Japanese.breast.cancer">data.Japanese.breast.cancer</a></code>,
<code><a href="#topic+data.Italian.bladder.cancer">data.Italian.bladder.cancer</a></code> and
<code><a href="#topic+data.asbestos">data.asbestos</a></code> for information on the data used in the example.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#####################
#  	EXAMPLE with artificial data
#  	Generate a 3x4 matrix in "AP" data.format with the numbers 1..12
#	Then make a data list
#	Then plot data.
#  	Note: this deterministic matrix has neither age, period, or cohort factors,
#		 only linear trends.  Thus all 6 plots have parallel lines.	

m.data  	&lt;- matrix(data=seq(length.out=12),nrow=3,ncol=4)
m.data
data.list	&lt;- apc.data.list(m.data,"AP")
apc.plot.data.within(data.list,log="")

#	It also works with a single argument, but then a default log scale is used.

apc.plot.data.within(data.list)			

#####################
#	EXAMPLE with Japanese breast cancer data
#	Clayton and Shifflers (1987b) use APC design
#	Make a data list
#	Then plot data.
#	Note: No plot appears to have approximately parallel lines.

data.list	&lt;- data.Japanese.breast.cancer()	
apc.plot.data.within(data.list,"m",1,log="y")
												
#	It also works with a single argument, but then a default log scale is used.
# 	Note that warnings are given in relation to the data chosen thinning

apc.plot.data.within(data.list)

#####################
#	EXAMPLE with Italian bladder cancer data
#	Clayton and Shifflers (1987a) use AC design
#	Note: plot of within cohort against age appears to have approximately parallel lines.
#		  This is Figure 2 in Clayton and Shifflers (1987a)
#	Note: plot of within age against cohort appears to have approximately parallel lines.
#		  Indicates that interpretation should be done carefully.

data.list	&lt;- data.Italian.bladder.cancer()	
apc.plot.data.within(data.list,"m",1,log="y")

#####################
#	EXAMPLE with asbestos data
#	Miranda Martinex, Nielsen and Nielsen (2014).
#	This is Figure 1d 

data.list	&lt;- data.asbestos()	
apc.plot.data.within(data.list,type="l",lty=1)
</code></pre>

<hr>
<h2 id='apc.plot.fit'>Plots of apc estimates</h2><span id='topic+apc.plot.fit'></span>

<h3>Description</h3>

<p>Functions to plot the apc estimates found by <code><a href="#topic+apc.fit.model">apc.fit.model</a></code>.  The function apc.plot.fit detects the type of
<code>model.design</code> and <code>model.family</code> from the fit values and makes appropriate plots.
</p>
<p>Depending on the <code>model.design</code> the plot has up to 9 sub plots.
The type of these can be chosen using <code>type</code>
</p>
<p><b>Model designs of any type.</b>
If <code>type</code> is &quot;detrend&quot; or &quot;sum.sum&quot;
the canonical age period cohort parametrisation is used.  This involves double differences of the
time effects. 
The first row of plots are double differences of the time effects.
The next two rows of plots illustrate the representation theorem depending on the choice of <code>type</code>.
In both cases the sum of the plots add up to the predictor.	 
</p>

<dl>
<dt>&quot;detrend&quot;</dt><dd><p>The last row of plots are double sums of double differences detrend so that that each series starts in
zero and ends in zero.  The corresponding level and (up to) two linear trends are shown in the middle row of plots.
The linear trends are identified to be 0 for age, period or cohort equal to its smallest value.
See note 2 below.
</p>
</dd>
<dt>&quot;sum.sum&quot;</dt><dd><p>The last row of plots are double sums of double differences anchored as in the derivation of
Nielsen (2014b).
The corresponding level and (up to) two linear trends are shown in the middle row of plots.
The linear trends are identified to be 0 for the anchoring point U of age, period or cohort as
described in 
Nielsen (2014b).
See note 1 below.
</p>
</dd>
</dl>

<p><b>Model designs with 2 factors.</b>
If <code>type</code> is &quot;dif&quot; the canonical two factor parametrisation is used.
This involves single differences.
It is only implemented for <code>model.design</code> of &quot;AC&quot;, &quot;AP&quot;, &quot;PC&quot;.
It does not apply for <code>model.design</code> of &quot;APC&quot; because single differences are not identified.
It does not apply for the drift models where <code>model.design</code> is &quot;Ad&quot;, &quot;Pd&quot;, &quot;Cd&quot;, &quot;t&quot; because it is not clear which time scale the second linear trend should be attributed to.
It is not implemented for <code>model.design</code> of &quot;tA, &quot;tP&quot;, &quot;tC&quot;, &quot;1&quot;.
The first row of plots are single differences of the time effects.
The next two rows of plots illustrate the representation theorem.  In the second row the level is given and in
the third row plots of single sums of single differences are given, normalised to start in zero.
</p>
<p><b>Appearance may vary.</b>
Note, the plots &quot;detrend&quot; and &quot;dif&quot; can give very different appearance of the time effects. The &quot;dif&quot; plots are dominated by
linear trends.  They can therefore be more difficult to interpret than the &quot;detrend&quot; plots, where linear trends are set aside.
</p>
<p><b>Standard deviations.</b>
All plots include plots of 1 and 2 standard deviations.  The only exception is the intercept in the case 
<code>model.family</code> is &quot;poisson.response&quot; as this uses a multinomial sampling scheme, where the intercept is set to increase
in the asymptotic experiment.  The default is to plot standard deviations around zero, so that they represent
a test for zero values of the parameters.
Using the argument <code>sdv.at.zero</code> the standard deviations can be centered around the estimates. This can give a
very complicated appearance.
</p>
<p><b>Values of coefficients.</b>
These can be found using
<code><a href="#topic+apc.identify">apc.identify</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>apc.plot.fit(apc.fit.model,scale=FALSE,
					sdv.at.zero=TRUE,type="detrend",
					include.linear.plane=TRUE,
					include.double.differences=TRUE,
					sub.plot=NULL,main.outer=NULL,main.sub=NULL,
					cex=NULL,cex.axis=NULL,cex.lab=NULL,cex.main=NULL,
					cex.main.outer=1.2,
					line.main=0.5,line.main.outer=NULL,
					las=NULL,mar=NULL,oma=NULL,mgp=c(2,1,0),
					vec.xlab=NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="apc.plot.fit_+3A_apc.fit.model">apc.fit.model</code></td>
<td>
<p>List. See <code><a href="#topic+apc.fit.model">apc.fit.model</a></code> for a description of the format.</p>
</td></tr>
<tr><td><code id="apc.plot.fit_+3A_scale">scale</code></td>
<td>
<p>Optional. Logical. If (TRUE) FALSE use scale of (inverse) link function.  Default is FALSE.</p>
</td></tr>
<tr><td><code id="apc.plot.fit_+3A_sdv.at.zero">sdv.at.zero</code></td>
<td>
<p>Optional. Logical. If FALSE/TRUE standard deviations are plotted around estimates/zero.  Default is TRUE.</p>
</td></tr>
<tr><td><code id="apc.plot.fit_+3A_type">type</code></td>
<td>
<p>Optional.  Character.  If &quot;detrend&quot; double sums start and end in zero.  If &quot;sum.sum&quot; double sums anchored as discussed in Nielsen (??). Default is &quot;detrend&quot;.</p>
</td></tr>
<tr><td><code id="apc.plot.fit_+3A_include.linear.plane">include.linear.plane</code></td>
<td>
<p>Optional. Logical. If true include plots of linear plane. Default TRUE</p>
</td></tr>
<tr><td><code id="apc.plot.fit_+3A_include.double.differences">include.double.differences</code></td>
<td>
<p>Optional. Logical. If true include plots of double differences. Default TRUE</p>
</td></tr>
<tr><td><code id="apc.plot.fit_+3A_sub.plot">sub.plot</code></td>
<td>
<p>Optional.  Character: &quot;a&quot;,&quot;b&quot;,...,&quot;i&quot;.  Only the indicated sub plot is plotted. Default is NULL so all plots shown.</p>
</td></tr>
<tr><td><code id="apc.plot.fit_+3A_main.outer">main.outer</code></td>
<td>
<p>Optional.  Character.  Main title in outer margin.  Default is generated internally.</p>
</td></tr>
<tr><td><code id="apc.plot.fit_+3A_main.sub">main.sub</code></td>
<td>
<p>Optional.  Vector of 9 characters.  Main titles for individual plots. Default is generated internally, see note 3 below.</p>
</td></tr>
<tr><td><code id="apc.plot.fit_+3A_cex">cex</code></td>
<td>
<p>Optional.  Plot parameter, see <code><a href="graphics.html#topic+par">par</a></code>. Controls size of text. Default is NULL so that R default is used.</p>
</td></tr>
<tr><td><code id="apc.plot.fit_+3A_cex.axis">cex.axis</code></td>
<td>
<p>Optional.  Plot parameter, see <code><a href="graphics.html#topic+par">par</a></code>. Controls magnification of axis annotations. Default is NULL so that R default is used.</p>
</td></tr>
<tr><td><code id="apc.plot.fit_+3A_cex.lab">cex.lab</code></td>
<td>
<p>Optional.	Plot parameter, see <code><a href="graphics.html#topic+par">par</a></code>. Controls magnification of axis labels. Default is NULL so that R default is used.</p>
</td></tr>
<tr><td><code id="apc.plot.fit_+3A_cex.main">cex.main</code></td>
<td>
<p>Optional.  Plot parameter, see <code><a href="graphics.html#topic+par">par</a></code>. Controls magnification of main title. Default is NULL so that R default is used.</p>
</td></tr>
<tr><td><code id="apc.plot.fit_+3A_cex.main.outer">cex.main.outer</code></td>
<td>
<p>Optional.  Controls magnification of outer main title if an array of plots is shown. Default is 1.2 (same as cex.main).</p>
</td></tr>
<tr><td><code id="apc.plot.fit_+3A_line.main">line.main</code></td>
<td>
<p>Optional. Specifies the line position of main title in individual plots. Default is 0.5.</p>
</td></tr>
<tr><td><code id="apc.plot.fit_+3A_line.main.outer">line.main.outer</code></td>
<td>
<p>Optional. Specifies the line position of outer main title if an array of plots is shown. Default is NULL so that R default is used.</p>
</td></tr>
<tr><td><code id="apc.plot.fit_+3A_las">las</code></td>
<td>
<p>Optional. Plot parameter, see <code><a href="graphics.html#topic+par">par</a></code>. Numeric. The style of axis labels. Default is NULL so that R default is used.</p>
</td></tr>
<tr><td><code id="apc.plot.fit_+3A_mar">mar</code></td>
<td>
<p>Optional. Gives the number of lines of margin to be specified on the four sides of the plot. Default: <code>c(4,3,2,0)</code> for array of plots, <code>c(4,4,3,1)</code> for a single plot.</p>
</td></tr>
<tr><td><code id="apc.plot.fit_+3A_oma">oma</code></td>
<td>
<p>Optional. Gives the size of the outer margins in lines of text. Default: <code>c(0,0,5,1)</code> for array of plots, <code>c(0,0,0,0)</code> for a single plot.</p>
</td></tr>
<tr><td><code id="apc.plot.fit_+3A_mgp">mgp</code></td>
<td>
<p>Optional.  Plot parameter, see <code><a href="graphics.html#topic+par">par</a></code>. The margin line for the axis title, axis label and axis line. Defauls is <code>c(2,1,0)</code>, different from R default.</p>
</td></tr>
<tr><td><code id="apc.plot.fit_+3A_vec.xlab">vec.xlab</code></td>
<td>
<p>Optional.  Controls title for xaxis.  Should be a 9-vector of characters for an array of plots and a character for a single plot. As R recycles entries if a vector is too short, then <code>vec.xlab=""</code> will remove titles on x-axis. Default: NULL.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>(1)
The type &quot;sum.sum&quot; (same as &quot;ss.dd&quot;) gives double sums anchored 
to be zero in the three points where
<code>age=cohort=U</code>,
<code>age=U+1,cohort=U</code>
<code>age=U,cohort=U+1</code>
with
<code>apc.fit.model$U</code>
and where
<code>U</code>
is the integer value of
<code>(per.zero+3)/2</code>
This corresponds to the representation in
Nielsen (2014b).
The linear plane is parametrised in terms of 
a level, which is the value of the predictor at
<code>age=cohort=U</code>;
an age slope, which is the difference of the values of the predictor at
<code>age=U+1,cohort=U</code>
and 
<code>age=cohort=U</code>;
an cohort slope, which is the difference of the values of the predictor at
<code>age=U,cohort=U+1</code>
and 
<code>age=cohort=U</code>.
</p>
<p>(2)
The type &quot;detrend&quot; gives double sums that start in zero and end in zero.
The linear plane is parametrised in terms of
a level, which is the value of the predictor at 
<code>age=cohort=1</code>, which is usually outside the index set for the data;
while age and cohort slopes are adjusted for the ad hoc identification of the time effects.
</p>
<p>(3)
The default of the titles <code>main.sub</code> are generated internally depending on model specification.
In the case of <code>model.design="APC"</code> and a dose-response model family the default value is
<code>c(expression(paste("(a) ",Delta^2,alpha)), 
expression(paste("(b) ",Delta^2,beta)),  
expression(paste("(c) ",Delta^2,gamma)), 
"(d)  first linear trend",
"(e)  level",
"(f)  second linear trend",
expression(paste("(g) detrended ",Sigma^2,Delta^2,alpha)),
expression(paste("(h) detrended ",Sigma^2,Delta^2,beta)),
expression(paste("(i) detrended ",Sigma^2,Delta^2,gamma)))</code>
</p>
<p>(4)
Default values of parameters changed (28 Sep 2020).
The old appearance can be reproduced by	setting <code>cex.lab=1.5</code>. For example:
</p>
<p><code>data.list	&lt;- data.Italian.bladder.cancer()</code>
</p>
<p><code>fit.apc &lt;- apc.fit.model(data.list,"poisson.dose.response","APC")</code>
</p>
<p><code>apc.plot.fit(fit.apc,cex.lab=1.5)</code>
</p>
<p>The code subsumes <code>var.apc.plot.fit</code> by Zoe Fannon.
</p>


<h3>Author(s)</h3>

<p>Bent Nielsen &lt;bent.nielsen@nuffield.ox.ac.uk&gt; &amp; Zoe Fannon 28 September 2020 (12 Apr 2015).</p>


<h3>References</h3>

<p>Kuang, D., Nielsen, B. and Nielsen, J.P. (2008a) Identification of the age-period-cohort model and the extended chain ladder model. Biometrika 95, 979-986. <em>Download</em>: <a href="https://doi.org/10.1093/biomet/asn026">Article</a>; Earlier version <a href="http://www.nuffield.ox.ac.uk/economics/papers/2007/w5/KuangNielsenNielsen07.pdf">Nuffield DP</a>.
</p>
<p>Nielsen, B. (2014b) Deviance analysis of age-period-cohort models. Work in progress.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+data.asbestos">data.asbestos</a></code>
and
<code><a href="#topic+data.Italian.bladder.cancer">data.Italian.bladder.cancer</a></code> for information on the data used in the example.
</p>
<p>Values of coefficients can be found using <code><a href="#topic+apc.identify">apc.identify</a></code>.
</p>
<p>Further information on the identification in the vignette
<a href="../doc/Identification.pdf"><code>Identification.pdf</code></a>,
<a href="../doc/Identification.R"><code>Identification.R</code></a>
on
<a href="../doc/index.html"><code>Vignettes</code></a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#####################
#	Example with Italian bladder cancer data
#	Note that the model.design "AC" cannot be rejected against "APC"
#		so there is little difference between the two plots of those fits.

data.list	&lt;- data.Italian.bladder.cancer()
apc.fit.table(data.list,"poisson.dose.response")
fit.apc		&lt;- apc.fit.model(data.list,"poisson.dose.response","APC")
apc.plot.fit(fit.apc)
#	now try an AC model
#	can use dev.new() to see both
fit.ac		&lt;- apc.fit.model(data.list,"poisson.dose.response","AC")
apc.plot.fit(fit.ac)

#	to check the numerical values for the last two rows of plots use
apc.identify(fit.ac)$coefficients.detrend

#	to get only a sub plot and playing with titles
#	main.outer not used with individual plot
apc.plot.fit(fit.ac,sub.plot="a",main.outer="My outer title",main.sub="My sub title")
#	to play with
#		titles (main.outer/main.sub),
#		label orientation (las),
#		axis titles (vec.xlab)
apc.plot.fit(fit.ac,main.outer="My outer title",
				main.sub=c("1","2","3","4","5","6","7","8","9"),
				las=1,
				vec.xlab=c("a","b","c","d","e","f","g","h","i"))
</code></pre>

<hr>
<h2 id='apc.plot.fit.all'>Make all fit plots.</h2><span id='topic+apc.plot.fit.all'></span>

<h3>Description</h3>

<p>Plots estimates using <code><a href="#topic+apc.plot.fit">apc.plot.fit</a></code>.
Probability transform plot of residuals using <code><a href="#topic+apc.plot.fit.pt">apc.plot.fit.pt</a></code>.
Level plot of residuals using <code><a href="#topic+apc.plot.fit.residuals">apc.plot.fit.residuals</a></code>.
Level plot of fitted values using <code><a href="#topic+apc.plot.fit.fitted.values">apc.plot.fit.fitted.values</a></code>.
Level plot of linear predictors using <code><a href="#topic+apc.plot.fit.linear.predictors">apc.plot.fit.linear.predictors</a></code>.
Level plots of responses and rates (if dose is availble) using <code><a href="#topic+apc.plot.data.level">apc.plot.data.level</a></code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>apc.plot.fit.all(apc.fit.model,log ="",rotate=FALSE)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="apc.plot.fit.all_+3A_apc.fit.model">apc.fit.model</code></td>
<td>
<p>List. Output from <code><a href="#topic+apc.fit.model">apc.fit.model</a></code>. See there for a description of the format.</p>
</td></tr>
<tr><td><code id="apc.plot.fit.all_+3A_log">log</code></td>
<td>
<p>Optional <code><a href="base.html#topic+plot">plot</a></code> argument. Character. &quot;y&quot; if y-scale is logarithmic, otherwise &quot;&quot;. Default is &quot;&quot;.</p>
</td></tr>
<tr><td><code id="apc.plot.fit.all_+3A_rotate">rotate</code></td>
<td>
<p>Optional. Logical. If TRUE rotates level plots 90 degrees clockwise (or anti-clockwise if data.format is &quot;CL&quot;). Default is FALSE.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Bent Nielsen &lt;bent.nielsen@nuffield.ox.ac.uk&gt; 2t Apr 2015</p>


<h3>See Also</h3>

<p>The example below uses Italian bladder cancer data, see <code><a href="#topic+data.Italian.bladder.cancer">data.Italian.bladder.cancer</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>#####################
#	EXAMPLE with Italian bladder cancer data

#	get data list, then make all descriptive plots.
# 	Note that warnings are given in relation to the data chosen thinning
#	This can be avoided by working with the individual plots, and in particular
#	with apc.plot.data.within where the thinning happens.

data.list	&lt;- data.Italian.bladder.cancer()
fit			&lt;- apc.fit.model(data.list,"poisson.dose.response","APC")
apc.plot.fit.all(fit)
</code></pre>

<hr>
<h2 id='apc.plot.fit.pt'>Plot probability transform of responses given fitted values</h2><span id='topic+apc.plot.fit.pt'></span>

<h3>Description</h3>

<p>Constructs probability transforms of responses given fitted values from <code><a href="#topic+apc.fit.model">apc.fit.model</a></code>.
The plot is given in the original coordinate system. Colours and symbols are used to indicate
whether responses are central to the fitted distribution or in the tails of the fitted distribution.</p>


<h3>Usage</h3>

<pre><code class='language-R'>apc.plot.fit.pt(apc.fit.model,
					   do.plot=TRUE,do.value=FALSE,
					   pch=c(21,24,25),
					   col=c("black","green","blue","red"),
					   bg=NULL,cex=NULL,main=NULL)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="apc.plot.fit.pt_+3A_apc.fit.model">apc.fit.model</code></td>
<td>
<p>List. See <code><a href="#topic+apc.fit.model">apc.fit.model</a></code> for a description of the format.</p>
</td></tr>
<tr><td><code id="apc.plot.fit.pt_+3A_do.plot">do.plot</code></td>
<td>
<p>Optional. Logical.  If FALSE plot is not produced. Default is TRUE.</p>
</td></tr>
<tr><td><code id="apc.plot.fit.pt_+3A_do.value">do.value</code></td>
<td>
<p>Optional. Logical.  If TRUE value is produced. Default is FALSE.</p>
</td></tr>
<tr><td><code id="apc.plot.fit.pt_+3A_pch">pch</code></td>
<td>
<p>Optional <code><a href="graphics.html#topic+points">points</a></code> argument.  Numeric.  Default is 21/24/25.  21 is a circle used for the central 80% of distribution. 24/25 are triangle point up/down used for right tail and left tail.</p>
</td></tr> 
<tr><td><code id="apc.plot.fit.pt_+3A_col">col</code></td>
<td>
<p>Optional <code><a href="base.html#topic+plot">plot</a></code> argument.  Character or Numeric.  Default is &quot;black&quot;/&quot;green&quot;/&quot;blue&quot;/&quot;red&quot;.  Black is use for central 80%, Green is used for 90-95% and 5-10%, Blue is used for 95-99% and 1-5%, Red is used for tails.</p>
</td></tr>
<tr><td><code id="apc.plot.fit.pt_+3A_bg">bg</code></td>
<td>
<p>Optional <code><a href="base.html#topic+plot">plot</a></code> argument.  Character or Numeric.  Default is bg=col.</p>
</td></tr>
<tr><td><code id="apc.plot.fit.pt_+3A_cex">cex</code></td>
<td>
<p>Optional <code><a href="base.html#topic+plot">plot</a></code> argument.  Numeric.  Magnification.  Default is internally computed.</p>
</td></tr>
<tr><td><code id="apc.plot.fit.pt_+3A_main">main</code></td>
<td>
<p>Optional <code><a href="base.html#topic+plot">plot</a></code> argument.  Character.  Main title.  Default is internally computed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector of probability transforms.  Only produced if <code>do.value</code> is set to TRUE. See example below.
</p>


<h3>Author(s)</h3>

<p>Bent Nielsen &lt;bent.nielsen@nuffield.ox.ac.uk&gt; 2 Dec 2013</p>


<h3>See Also</h3>

<p><code><a href="#topic+data.Italian.bladder.cancer">data.Italian.bladder.cancer</a></code> for information on the data used in the example.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#####################
#	Example with Italian bladder cancer data
#	HOW TO USE VALUE

data.list	&lt;- data.Italian.bladder.cancer()
fit			&lt;- apc.fit.model(data.list,"poisson.dose.response","APC")
v.pt		&lt;- apc.plot.fit.pt(fit,do.value=TRUE)
m.pt		&lt;- matrix(data=NA,nrow=fit$data.xmax,ncol=fit$data.ymax)
m.pt[fit$index.data]	&lt;- v.pt
m.pt

#	            [,1]      [,2]       [,3]       [,4]      [,5]
#	 [1,] 0.63782311 0.5651585 0.33982477 0.91299734 0.5759652
#	 [2,] 0.82676269 0.8992667 0.26378120 0.28795884 0.3708787
#	 [3,] 0.54139571 0.2445995 0.51923747 0.63451773 0.7955547
#	 [4,] 0.87364488 0.8228499 0.07219437 0.38789788 0.5938305
#	 [5,] 0.86797473 0.3934085 0.34525271 0.38955656 0.5097203
#	 [6,] 0.65027598 0.8377994 0.29018594 0.03694977 0.7990229
#	 [7,] 0.43769468 0.1099946 0.50261364 0.56777485 0.8916552
#	 [8,] 0.67518708 0.5519831 0.67817803 0.19793887 0.5354669
#	 [9,] 0.02717016 0.2066092 0.77035122 0.89047749 0.5017919
#	[10,] 0.71037782 0.9464356 0.36897847 0.41790169 0.2080577
#	[11,] 0.50922468 0.3085978 0.55261186 0.77592343 0.3597815
</code></pre>

<hr>
<h2 id='apc.plot.fit.residuals'>Level plots of residuals / fitted values / linear predictors</h2><span id='topic+apc.plot.fit.residuals'></span><span id='topic+apc.plot.fit.fitted.values'></span><span id='topic+apc.plot.fit.linear.predictors'></span>

<h3>Description</h3>

<p>Level plots of residuals / fitted values / linear predictors.
Returns residuals / fitted values / linear predictors as matrices when requested.
The plots use <code><a href="#topic+apc.plot.data.level">apc.plot.data.level</a></code>.
They plot are given in the original coordinate system. </p>


<h3>Usage</h3>

<pre><code class='language-R'>apc.plot.fit.residuals(apc.fit.model,
					rotate=FALSE,main=NULL,lab=NULL,
					contour=FALSE,colorkey=TRUE,return=FALSE)
	   apc.plot.fit.fitted.values(apc.fit.model,
					rotate=FALSE,main=NULL,lab=NULL,
					contour=FALSE,colorkey=TRUE,return=FALSE)
	   apc.plot.fit.linear.predictors(apc.fit.model,
					rotate=FALSE,main=NULL,lab=NULL,
					contour=FALSE,colorkey=TRUE,return=FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="apc.plot.fit.residuals_+3A_apc.fit.model">apc.fit.model</code></td>
<td>
<p>List. Output from <code><a href="#topic+apc.fit.model">apc.fit.model</a></code>. See there for a description of the format.</p>
</td></tr>
<tr><td><code id="apc.plot.fit.residuals_+3A_rotate">rotate</code></td>
<td>
<p>Optional. Logical. If TRUE rotates plot 90 degrees clockwise (or anti-clockwise if data.format is &quot;CL&quot;). Default is FALSE.</p>
</td></tr>
<tr><td><code id="apc.plot.fit.residuals_+3A_main">main</code></td>
<td>
<p>Optional. Character. Main title.</p>
</td></tr>
<tr><td><code id="apc.plot.fit.residuals_+3A_lab">lab</code></td>
<td>
<p>Optional <code><a href="base.html#topic+plot">plot</a></code> parameter.	A numerical vector of the form c(x, y, len)
which modifies the default way that axes are annotated.
The values of x and y give the (approximate) number of tickmarks on
the x and y axes. len is not implemented.</p>
</td></tr>
<tr><td><code id="apc.plot.fit.residuals_+3A_contour">contour</code></td>
<td>
<p> Optional <code><a href="lattice.html#topic+levelplot">levelplot</a></code> (<code><a href="lattice.html#topic+lattice">lattice</a></code>) parameter.
Logical. Contour lines drawn if TRUE. Default FALSE.</p>
</td></tr>
<tr><td><code id="apc.plot.fit.residuals_+3A_colorkey">colorkey</code></td>
<td>
<p>Optional <code><a href="lattice.html#topic+levelplot">levelplot</a></code> (<code><a href="lattice.html#topic+lattice">lattice</a></code>) parameter.
Logical or list. Determines color key. Default TRUE.</p>
</td></tr>
<tr><td><code id="apc.plot.fit.residuals_+3A_return">return</code></td>
<td>
<p>Optional. Logical. If TRUE returns matrix with values.  Default is FALSE.</p>
</td></tr>						
</table>


<h3>Value</h3>

<p>Matrix of the original format with residuals / fitted values /linear predictors as entries.
Only produced if <code>return</code> is set to TRUE.
</p>


<h3>Author(s)</h3>

<p>Bent Nielsen &lt;bent.nielsen@nuffield.ox.ac.uk&gt; 26 Apr 2015</p>


<h3>See Also</h3>

<p><code><a href="#topic+data.Italian.bladder.cancer">data.Italian.bladder.cancer</a></code> for information on the data used in the example.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#####################
#	Example with Italian bladder cancer data

data.list	&lt;- data.Italian.bladder.cancer()
fit			&lt;- apc.fit.model(data.list,"poisson.dose.response","APC")
apc.plot.fit.fitted.values(fit,return=TRUE)

#       1955-1959   1960-1964   1965-1969   1970-1974   1975-1979
# 25-29   3.04200    3.368944    2.261518    2.327538   12.000000
# 30-34  13.11980   12.835733   13.955859   10.416142    9.672462
# 35-39  24.15536   33.591644   33.388355   37.542301   26.322340
# 40-44  69.89262   68.842728   96.652963   98.478793  113.132896
# 45-49 217.97285  189.375728  189.115063  272.281239  285.255119
# 50-54 450.44864  529.823519  462.504305  469.869189  701.354350
# 55-59 724.88451  904.298410 1069.452434  969.346982  966.017661
# 60-64 877.17820 1226.088350 1532.521380 1877.331703 1807.880364
# 65-69 950.36106 1296.011123 1798.196048 2336.012274 3028.419493
# 70-74 903.94495 1187.708772 1598.021907 2302.605072 3222.719298
# 75-79 831.00000  953.055049 1280.930166 1755.788768 2678.226017
</code></pre>

<hr>
<h2 id='apc.polygon'>Add connected line and standard deviation polygons to a plot</h2><span id='topic+apc.polygon'></span>

<h3>Description</h3>

<p>Draws a line for point forecasts and adds shaded region for forecast distribution around it. This is added to a plot in the same way as
<code><a href="graphics.html#topic+lines">lines</a></code> and <code><a href="graphics.html#topic+polygon">polygon</a></code> add lines and polygons to a plot.</p>


<h3>Usage</h3>

<pre><code class='language-R'>apc.polygon(m.forecast,x.origin=1,
	plot.se=TRUE,plot.se.proc=FALSE,plot.se.est=FALSE,
	unit=1,
	col.line=1,lty.line=1,lwd.line=1,
	q.se=c(2,2,2),
	angle.se=c(45,45,45),
	border.se=c(NA,NA,NA),
	col.se=gray(c(0.50,0.80,0.90)),
	density.se=c(NULL,NULL,NULL),
	lty.se=c(1,1,1))</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="apc.polygon_+3A_m.forecast">m.forecast</code></td>
<td>
<p>Matrix.  Up to 4 columns.
Column 1: point forecasts.
Column 2: forecast standard errors.
Column 3: process standard errors.
Column 4: estimation standard errors.</p>
</td></tr>
<tr><td><code id="apc.polygon_+3A_x.origin">x.origin</code></td>
<td>
<p><em>Optional.</em> Numerical. x-coordinate for last observation. The first point forecast is made at <code>x.origin+unit</code>, where <code>unit</code> (with default 1) is defined in <code><a href="#topic+apc.data.list">apc.data.list</a></code>. Default: 1.</p>
</td></tr>
<tr><td><code id="apc.polygon_+3A_plot.se">plot.se</code></td>
<td>
<p><em>Optional.</em> Logical. Should forecast   standard errors be plotted? Default: <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="apc.polygon_+3A_plot.se.proc">plot.se.proc</code></td>
<td>
<p><em>Optional.</em> Logical. Should process    standard errors be plotted? Default: <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="apc.polygon_+3A_plot.se.est">plot.se.est</code></td>
<td>
<p><em>Optional.</em> Logical. Should estimation standard errors be plotted? Default: <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="apc.polygon_+3A_unit">unit</code></td>
<td>
<p><em>Optional.</em> Numerical. step length for point forecasts. Default=1.</p>
</td></tr>
<tr><td><code id="apc.polygon_+3A_col.line">col.line</code></td>
<td>
<p><em>Optional.</em> Point forecasts: Colour of line. Same as <code>col</code> for <code><a href="graphics.html#topic+lines">lines</a></code>. Default: 1.</p>
</td></tr>
<tr><td><code id="apc.polygon_+3A_lty.line">lty.line</code></td>
<td>
<p><em>Optional.</em> Point forecasts: Type   of line. Same as <code>lty</code> for <code><a href="graphics.html#topic+lines">lines</a></code>. Default: 1.</p>
</td></tr>
<tr><td><code id="apc.polygon_+3A_lwd.line">lwd.line</code></td>
<td>
<p><em>Optional.</em> Point forecasts: Width  of line. Same as <code>lwd</code> for <code><a href="graphics.html#topic+lines">lines</a></code>. Default: 1.</p>
</td></tr>
<tr><td><code id="apc.polygon_+3A_q.se">q.se</code></td>
<td>
<p><em>Optional.</em> Vector of length 3. Multiplication factors for standard errors. Default: <code>c(2,2,2)</code>.</p>
</td></tr>
<tr><td><code id="apc.polygon_+3A_angle.se">angle.se</code></td>
<td>
<p><em>Optional.</em> Standard error polygon: 3-vector: Angle  of shading.  Same as <code>angle</code> 	for <code><a href="graphics.html#topic+polygon">polygon</a></code>. Default: <code>=c(45,45,45)</code>.</p>
</td></tr>
<tr><td><code id="apc.polygon_+3A_border.se">border.se</code></td>
<td>
<p><em>Optional.</em> Standard error polygon: 3-vector: Border of polygon.  Same as <code>border</code> 	for <code><a href="graphics.html#topic+polygon">polygon</a></code>. Default: <code>=c(NA,NA,NA)</code>.</p>
</td></tr>
<tr><td><code id="apc.polygon_+3A_col.se">col.se</code></td>
<td>
<p><em>Optional.</em> Standard error polygon: 3-vector: Colour of polygon.  Same as <code>col</code> 	for <code><a href="graphics.html#topic+polygon">polygon</a></code>. Default: <code>gray(c(0.50,0.80,0.90))</code>.</p>
</td></tr>
<tr><td><code id="apc.polygon_+3A_density.se">density.se</code></td>
<td>
<p><em>Optional.</em> Standard error polygon: 3-vector: Density of shading. Same as <code>density</code> for <code><a href="graphics.html#topic+polygon">polygon</a></code>. Default: <code>=c(NULL,NULL,NULL)</code>.</p>
</td></tr>
<tr><td><code id="apc.polygon_+3A_lty.se">lty.se</code></td>
<td>
<p><em>Optional.</em> Standard error polygon: 3-vector: Type of shading.    Same as <code>lty</code> 	for <code><a href="graphics.html#topic+polygon">polygon</a></code>. Default: <code>=c(1,1,1)</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The empirical example of
Martinez Miranda, Nielsen and Nielsen (2015)
uses the data
<code><a href="#topic+data.asbestos">data.asbestos</a></code>.
The results of that paper are reproduced in 
the vignette
<a href="../doc/ReproducingMMNN2015.pdf"><code>ReproducingMMNN2015.pdf</code></a>,
<a href="../doc/ReproducingMMNN2015.R"><code>ReproducingMMNN2015.R</code></a>
on
<a href="../doc/index.html"><code>Vignettes</code></a>.
The function is used there.
</p>


<h3>Author(s)</h3>

<p>Bent Nielsen &lt;bent.nielsen@nuffield.ox.ac.uk&gt; 6 Jan 2016</p>


<h3>References</h3>

<p>Martinez Miranda, M.D., Nielsen, B. and Nielsen, J.P. (2015) Inference and forecasting in the age-period-cohort model with unknown exposure with an application to mesothelioma mortality. <em>Journal of the Royal Statistical Society</em> A 178, 29-55. <em>Download</em>: <a href="https://doi.org/10.1111/rssa.12051">Article</a>, <a href="http://www.nuffield.ox.ac.uk/economics/papers/2013/Asbestos8mar13.pdf">Nuffield DP</a>. 
</p>

<hr>
<h2 id='data.aids'>UK aids data</h2><span id='topic+data.aids'></span>

<h3>Description</h3>

<p>Function that organises UK aids data in <code><a href="#topic+apc.data.list">apc.data.list</a></code> format.
</p>
<p>The data set is taken from table 1 of De Angelis and Gilks (1994). The data
are also analysed by Davison and Hinkley (1998, Example 7.4).
The data are reporting delays for AIDS counting	the number of cases by the
date of diagnosis and length of reporting delay, measured by quarter. 
</p>
<p>The data set is in &quot;trapezoid&quot;-format.
The original data set is unbalanced in various ways:
first column covers a reporting delay of less than one month (or should it be less than one quarter?);
last column covers a reporting delay of at least 14 quarters;
last diagonal include incomplete counts.
The default data set excludes the incomplete counts in the last diagonal, but
includes the unbalanced first and last columns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data.aids(all.age.groups = FALSE)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="data.aids_+3A_all.age.groups">all.age.groups</code></td>
<td>
<p>logical.  If FALSE (default), the last calendar year with incomplete counts is ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The value is a list in <code><a href="#topic+apc.data.list">apc.data.list</a></code> format.
</p>
<table role = "presentation">
<tr><td><code>response</code></td>
<td>
<p>matrix of cases</p>
</td></tr>
<tr><td><code>data.format</code></td>
<td>
<p>logical equal to &quot;trapezoid&quot;.</p>
</td></tr>
<tr><td><code>age1</code></td>
<td>
<p>numeric equal to 0.  This is the label for the reporting delay.</p>
</td></tr>
<tr><td><code>per1</code></td>
<td>
<p>NULL.  Not needed when data.format=&quot;trapezoid&quot;</p>
</td></tr>
<tr><td><code>coh1</code></td>
<td>
<p>numeric equal to 1983.5.  This is the label for the diagnosis quarter (1983, third quarter).</p>
</td></tr>
<tr><td><code>unit</code></td>
<td>
<p>numeric equal to 1/4.  This is the width of the age and period groups.</p>
</td></tr>
<tr><td><code>per.zero</code></td>
<td>
<p>numeric equal to 0.</p>
</td></tr> 
<tr><td><code>per.max</code></td>
<td>
<p>numeric equal to 38.</p>
</td></tr> 
<tr><td><code>time.adjust</code></td>
<td>
<p>numric equal to 0.</p>
</td></tr>
<tr><td><code>label</code></td>
<td>
<p>character.  Default data has &quot;UK AIDS - clean&quot;.</p>
</td></tr>						
</table>


<h3>Author(s)</h3>

<p>Bent Nielsen &lt;bent.nielsen@nuffield.ox.ac.uk&gt; 7 Feb 2016</p>


<h3>Source</h3>

<p>Table 1 of De Angelis and Gilks (1994).  Also analysed by Davison and Hinkley (1998, Example 7.4).</p>


<h3>References</h3>

<p>De Angelis, D. and Gilks, W.R. (1994) Estimating acquired immune deficiency syndrome incidence accounting for reporting delay. <em>Journal of the Royal Statistical Sociey</em> A 157, 31-40.
</p>
<p>Davison, A.C. and Hinkley, D.V. (1998) <em>Bootstrap methods and their application</em>. Cambridge: Cambridge University Press.
</p>


<h3>See Also</h3>

<p>General description of <code><a href="#topic+apc.data.list">apc.data.list</a></code> format.</p>


<h3>Examples</h3>

<pre><code class='language-R'>#########################
##	It is convient to construct a data variable
data	&lt;- data.Belgian.lung.cancer()
##	To see the content of the data
data

#########################
#	Forecast AIDS incidences by diagonsis year (cohort).
#	uses as poisson response model with an AC structure
#	although there is evidence of overdispersion and the
#	period effect appears significant.
#	The omission of the period effect follows
#	Davison and Hinkley and a parsimoneous model may be
#	advantageous when forecasting.
#
apc.fit.table(data.aids(),"poisson.response")
fit &lt;- apc.fit.model(data.aids(),"poisson.response","AC")
forecast &lt;- apc.forecast.ac(fit)
data.sums.coh &lt;- apc.data.sums(data.aids())$sums.coh
forecast.total &lt;- forecast$response.forecast.coh
forecast.total[,1]	&lt;- forecast.total[,1]+data.sums.coh[25:38]
x	&lt;- seq(1983.5,1992.75,by=1/4)
y	&lt;- data.sums.coh
xlab&lt;- "diagnosis year (cohort)"
ylab&lt;- "diagnoses"
main&lt;- "Davison and Hinkley, Fig 7.6, parametric version"
plot(x,y,xlim=c(1988,1993),ylim=c(200,600),xlab=xlab,ylab=ylab,main=main)
apc.polygon(forecast.total,x.origin=1989.25,unit=1/4)
</code></pre>

<hr>
<h2 id='data.asbestos'>Asbestos data</h2><span id='topic+data.asbestos'></span><span id='topic+data.asbestos.2013'></span><span id='topic+data.asbestos.2013.women'></span><span id='topic+data.asbestos.2013.men'></span>

<h3>Description</h3>

<p>Function that organises asbestos data in <code><a href="#topic+apc.data.list">apc.data.list</a></code> format.
</p>
<p>Counts of mesothelioma deaths in the UK by age and period.   Mesothelioma is most often caused by exposure to asbestos.
</p>
<p>The data set is in &quot;PA&quot;-format.
</p>
<p><code>data.asbestos</code> is for men 1967-2012
<code>data.asbestos.2013</code> is the same as <code>data.asbestos.2013.men</code> and is for men 1968-2013.
<code>data.asbestos.2013.women</code> and is for women 1968-2013.
</p>
<p>The primary data set includes ages 25-89, which is obtained when using the function without arguments or with argument <code>all.age.groups=FALSE</code>. The secondary data includes younger and older age groups, which is obtained when using the function with argument <code>all.age.groups=TRUE</code>. The <code>apc.package</code> is at present not aimed at such unbalanced data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data.asbestos(all.age.groups = FALSE)
data.asbestos.2013(all.age.groups = FALSE)
data.asbestos.2013.women(all.age.groups = FALSE)
data.asbestos.2013.men(all.age.groups = FALSE)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="data.asbestos_+3A_all.age.groups">all.age.groups</code></td>
<td>
<p>logical.  If FALSE (default), only age groups 25-89 are included.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The value is a list in <code><a href="#topic+apc.data.list">apc.data.list</a></code> format.
</p>
<table role = "presentation">
<tr><td><code>response</code></td>
<td>
<p>matrix of cases. Numbers of mesothelioma deaths by period and age. Period runs 1967-2007. Age runs 25-89 when <code>all.age.groups=FALSE</code>.  &quot;PA&quot;-format.</p>
</td></tr>
<tr><td><code>dose</code></td>
<td>
<p>NULL</p>
</td></tr>
<tr><td><code>data.format</code></td>
<td>
<p>logical equal to &quot;PA&quot;.  Data organised with period-groups in rows and age-groups in columns.</p>
</td></tr>
<tr><td><code>age1</code></td>
<td>
<p>numeric equal to 25.  This is the label for the first age group of 25.</p>
</td></tr>
<tr><td><code>per1</code></td>
<td>
<p>numeric equal to 1967.  This is the label for the first period group of 1967.</p>
</td></tr>
<tr><td><code>coh1</code></td>
<td>
<p>NULL.  Not needed when data.format=&quot;PA&quot;</p>
</td></tr>
<tr><td><code>unit</code></td>
<td>
<p>numeric equal to 1.  This is the width of the age and period groups.</p>
</td></tr>
<tr><td><code>per.zero</code></td>
<td>
<p>NULL.  Not needed when data.format=&quot;PA&quot;</p>
</td></tr> 
<tr><td><code>per.max</code></td>
<td>
<p>NULL.  Not needed when data.format=&quot;PA&quot;</p>
</td></tr>
<tr><td><code>time.adjust</code></td>
<td>
<p>0.  Thus age=89 in period=1967 corresponds to cohort=1967-89+0=1878.</p>
</td></tr>
<tr><td><code>label</code></td>
<td>
<p>character.  &quot;UK asbestos&quot;.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Bent Nielsen &lt;bent.nielsen@nuffield.ox.ac.uk&gt; 30 April 2016</p>


<h3>Source</h3>

<p>Data were prepared for the Asbestos Working Party by the UK Health and Safety Executive.
An APC analysis of these data can be found in
Martinez Miranda, Nielsen and Nielsen (2015).
The results of that paper are reproduced in 
the vignette
<a href="../doc/ReproducingMMNN2015.pdf"><code>ReproducingMMNN2015.pdf</code></a>,
<a href="../doc/ReproducingMMNN2015.R"><code>ReproducingMMNN2015.R</code></a>
on
<a href="../doc/index.html"><code>Vignettes</code></a>.
These data are also used in Nielsen (2015).
</p>
<p>The updated data set <code>data.asbestos.2013</code> is for 1968-2013 and has the same structure. This is analysed in
Martinez-Miranda, Nielsen and Nielsen (2016).
</p>


<h3>References</h3>

<p>Martinez Miranda, M.D., Nielsen, B. and Nielsen, J.P. (2015) Inference and forecasting in the age-period-cohort model with unknown exposure with an application to mesothelioma mortality. <em>Journal of the Royal Statistical Society</em> A 178, 29-55. <em>Download</em>: <a href="http://www.nuffield.ox.ac.uk/economics/papers/2013/Asbestos8mar13.pdf">Nuffield DP</a>.
</p>
<p>Martinez-Miranda, M.D., Nielsen, B. and Nielsen, J.P. (2016) A simple benchmark for mesothelioma projection for Great Britain. To appear in <em>Occupational and Environmental Medicine</em>. <em>Download</em>: <a href="https://www.nuffield.ox.ac.uk/economics/papers/2016/MartinezMirandaNielsenNielsen_AsbestosBenchmark.pdf">Nuffield DP</a>.
</p>
<p>Nielsen, B. (2015) apc: An R package for age-period-cohort analysis. R Journal 7, 52-64. <em>Download</em>: <a href="https://journal.r-project.org/archive/2015-2/nielsen.pdf">Open access</a>.
</p>


<h3>See Also</h3>

<p>General description of <code><a href="#topic+apc.data.list">apc.data.list</a></code> format.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#########################
#	apc data list

data.list	&lt;- data.asbestos()
objects(data.list)

#####################
#	Figure 1,a-c from
#	Miranda Martinex, Nielsen and Nielsen (2015).

data.list	&lt;- data.asbestos()	
apc.plot.data.sums(data.list,type="l")

#####################
#	Figure 1,d from
#	Miranda Martinex, Nielsen and Nielsen (2015).
data.list	&lt;- data.asbestos()	
apc.plot.data.within(data.list,type="l",lty=1)

</code></pre>

<hr>
<h2 id='data.Belgian.lung.cancer'>Belgian lung cancer data</h2><span id='topic+data.Belgian.lung.cancer'></span>

<h3>Description</h3>

<p>Function that organises Belgian lung cancer data in <code><a href="#topic+apc.data.list">apc.data.list</a></code> format.
</p>
<p>The data set is taken from table VIII of Clayton and Schifflers (1987a), which contains age-specific incidence rates (per 100,000 person-years observation) of lung cancer in Belgian females during the period 1955-1978. Numerators are also available. The original source was the WHO mortality database.  
</p>
<p>The data set is in &quot;AP&quot;-format. The original data set is unbalanced since the first four period groups cover 5 years, while the last covers 4 years.  The primary data set has 4 period groups, which is obtained when using the function without arguments or with argument <code>unbalanced=FALSE</code>. The secondary data set has 5 uneven sized period groups, wwhich is obtained when using the function with argument <code>unbalanced=TRUE</code>. The <code>apc.package</code> is at present not aimed at such unbalanced data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data.Belgian.lung.cancer(unbalanced = FALSE)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="data.Belgian.lung.cancer_+3A_unbalanced">unbalanced</code></td>
<td>
<p>logical.  If TRUE (default), the last 4-year group column of the data is ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The value is a list in <code><a href="#topic+apc.data.list">apc.data.list</a></code> format.
</p>
<table role = "presentation">
<tr><td><code>rates</code></td>
<td>
<p>matrix of mortality rates.  This is not needed for the <code><a href="#topic+apc.data.list">apc.data.list</a></code> format, but included as this is the original data formats</p>
</td></tr>
<tr><td><code>response</code></td>
<td>
<p>matrix of cases</p>
</td></tr>
<tr><td><code>dose</code></td>
<td>
<p>matrix of cases/rates</p>
</td></tr>
<tr><td><code>data.format</code></td>
<td>
<p>logical equal to &quot;AP&quot;.  Data organised with age-groups in rows and period-groups in columns.</p>
</td></tr>
<tr><td><code>age1</code></td>
<td>
<p>numeric equal to 25.  This is the label for the first age group covering ages 25-29.</p>
</td></tr>
<tr><td><code>per1</code></td>
<td>
<p>numeric equal to 1955.  This is the label for the first period group covering period 1955-1959.</p>
</td></tr>
<tr><td><code>coh1</code></td>
<td>
<p>NULL.  Not needed when data.format=&quot;AP&quot;</p>
</td></tr>
<tr><td><code>unit</code></td>
<td>
<p>numeric equal to 5.  This is the width of the age and period groups.</p>
</td></tr>
<tr><td><code>per.zero</code></td>
<td>
<p>NULL.  Not needed when data.format=&quot;AP&quot;</p>
</td></tr> 
<tr><td><code>per.max</code></td>
<td>
<p>NULL.  Not needed when data.format=&quot;AP&quot;</p>
</td></tr> 
<tr><td><code>time.adjust</code></td>
<td>
<p>0.  Thus age=25 in period=1955 corresponds to cohort=1955-25+0=1930, and indeed the
centers of the age and period groups, that is age=27 and period=1957
translate into cohort=1957-27+0=1930.</p>
</td></tr>
<tr><td><code>label</code></td>
<td>
<p>character.  &quot;Belgian lung cancer&quot;.</p>
</td></tr>						
</table>


<h3>Author(s)</h3>

<p>Bent Nielsen &lt;bent.nielsen@nuffield.ox.ac.uk&gt; 8 Sep 2015 (24 Oct 2013)</p>


<h3>Source</h3>

<p>Table VIII of Clayton and Schifflers (1987a).</p>


<h3>References</h3>

<p>Clayton, D. and Schifflers, E. (1987a) Models for temperoral variation in cancer rates. I: age-period and age-cohort models. <em>Statistics in Medicine</em> 6, 449-467.
</p>


<h3>See Also</h3>

<p>General description of <code><a href="#topic+apc.data.list">apc.data.list</a></code> format.</p>


<h3>Examples</h3>

<pre><code class='language-R'>#########################
##	It is convient to construct a data variable

data	&lt;- data.Belgian.lung.cancer()

##	To see the content of the data

data
</code></pre>

<hr>
<h2 id='data.Italian.bladder.cancer'>Italian bladder cancer data</h2><span id='topic+data.Italian.bladder.cancer'></span>

<h3>Description</h3>

<p>Function that organises Italian bladder data in <code><a href="#topic+apc.data.list">apc.data.list</a></code> format.
</p>
<p>The data set is taken from table IV of Clayton and Schifflers (1987a), which contains age-specific incidence rates (per 100,000 person-years observation) of bladder cancer in Italian males during the period 1955-1979. Numerators are also available. The original source was the WHO mortality database.  
</p>
<p>The data set is in &quot;AP&quot;-format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data.Italian.bladder.cancer()</code></pre>


<h3>Value</h3>

<p>The value is a list in <code><a href="#topic+apc.data.list">apc.data.list</a></code> format.
</p>
<table role = "presentation">
<tr><td><code>rates</code></td>
<td>
<p>matrix of mortality rates.  This is not needed for the <code><a href="#topic+apc.data.list">apc.data.list</a></code> format, but included as this is the original data formats</p>
</td></tr>
<tr><td><code>response</code></td>
<td>
<p>matrix of cases</p>
</td></tr>
<tr><td><code>dose</code></td>
<td>
<p>matrix of cases/rates</p>
</td></tr>
<tr><td><code>data.format</code></td>
<td>
<p>logical equal to &quot;AP&quot;.  Data organised with age-groups in rows and period-groups in columns.</p>
</td></tr>
<tr><td><code>age1</code></td>
<td>
<p>numeric equal to 25.  This is the label for the first age group covering ages 25-29.</p>
</td></tr>
<tr><td><code>per1</code></td>
<td>
<p>numeric equal to 1955.  This is the label for the first period group covering period 1955-1959.</p>
</td></tr>
<tr><td><code>coh1</code></td>
<td>
<p>NULL.  Not needed when data.format=&quot;AP&quot;</p>
</td></tr>
<tr><td><code>unit</code></td>
<td>
<p>numeric equal to 5.  This is the width of the age and period groups.</p>
</td></tr>
<tr><td><code>per.zero</code></td>
<td>
<p>NULL.  Not needed when data.format=&quot;AP&quot;</p>
</td></tr> 
<tr><td><code>per.max</code></td>
<td>
<p>NULL.  Not needed when data.format=&quot;AP&quot;</p>
</td></tr>
<tr><td><code>time.adjust</code></td>
<td>
<p>0.  Thus age=25 in period=1955 corresponds to cohort=1955-25+0=1930, and indeed the
centers of the age and period groups, that is age=27 and period=1957
translate into cohort=1957-27+0=1930.</p>
</td></tr>
<tr><td><code>label</code></td>
<td>
<p>character. &quot;Italian bladder cancer&quot;.</p>
</td></tr>													
</table>


<h3>Author(s)</h3>

<p>Bent Nielsen &lt;bent.nielsen@nuffield.ox.ac.uk&gt; 8 Sep 2015 (24 Oct 2013)</p>


<h3>Source</h3>

<p>Table IV of Clayton and Schifflers (1987a).</p>


<h3>References</h3>

<p>Clayton, D. and Schifflers, E. (1987a)
Models for temperoral variation in cancer rates. I: age-period and age-cohort models. 
<em>Statistics in Medicine</em> 6, 449-467.
</p>


<h3>See Also</h3>

<p>General description of <code><a href="#topic+apc.data.list">apc.data.list</a></code> format.</p>


<h3>Examples</h3>

<pre><code class='language-R'>#########################
##	It is convient to construct a data variable

data	&lt;- data.Italian.bladder.cancer()

##	To see the content of the data

data
</code></pre>

<hr>
<h2 id='data.Japanese.breast.cancer'>Japanese breast cancer data</h2><span id='topic+data.Japanese.breast.cancer'></span>

<h3>Description</h3>

<p>Function that organises Japanese breast data in <code><a href="#topic+apc.data.list">apc.data.list</a></code> format.
</p>
<p>The data set is taken from table I of Clayton and Schifflers (1987b), which contains age-specific mortality rates (per 100,000 person-years observation) of breast cancer in Japan, during the period 1955-1979. Reported in 5 year age groups and 5 year period groups.  Numbers of cases on which rates are based are also available.   The original source was WHO mortality data base.  
</p>
<p>The data set is in &quot;AP&quot;-format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data.Japanese.breast.cancer()</code></pre>


<h3>Value</h3>

<p>The value is a list in <code><a href="#topic+apc.data.list">apc.data.list</a></code> format.
</p>
<table role = "presentation">
<tr><td><code>rates</code></td>
<td>
<p>matrix of mortality rates.  This is not needed for the <code><a href="#topic+apc.data.list">apc.data.list</a></code> format, but included as this is the original data formats</p>
</td></tr>
<tr><td><code>response</code></td>
<td>
<p>matrix of cases</p>
</td></tr>
<tr><td><code>dose</code></td>
<td>
<p>matrix of cases/rates</p>
</td></tr>
<tr><td><code>data.format</code></td>
<td>
<p>logical equal to &quot;AP&quot;.  Data organised with age-groups in rows and period-groups in columns.</p>
</td></tr>
<tr><td><code>age1</code></td>
<td>
<p>numeric equal to 25.  This is the label for the first age group covering ages 25-29.</p>
</td></tr>
<tr><td><code>per1</code></td>
<td>
<p>numeric equal to 1955.  This is the label for the first period group covering period 1955-1959.</p>
</td></tr>
<tr><td><code>coh1</code></td>
<td>
<p>NULL.  Not needed when data.format=&quot;AP&quot;</p>
</td></tr>
<tr><td><code>unit</code></td>
<td>
<p>numeric equal to 5.  This is the width of the age and period groups.</p>
</td></tr>
<tr><td><code>per.zero</code></td>
<td>
<p>NULL.  Not needed when data.format=&quot;AP&quot;</p>
</td></tr> 
<tr><td><code>per.max</code></td>
<td>
<p>NULL.  Not needed when data.format=&quot;AP&quot;</p>
</td></tr> 
<tr><td><code>time.adjust</code></td>
<td>
<p>0.  Thus age=25 in period=1955 corresponds to cohort=1955-25+0=1930, and indeed the
centers of the age and period groups, that is age=27 and period=1957
translate into cohort=1957-27+0=1930.</p>
</td></tr>
<tr><td><code>label</code></td>
<td>
<p>character. &quot;Japanese breast cancer&quot;.</p>
</td></tr>						
</table>


<h3>Author(s)</h3>

<p>Bent Nielsen &lt;bent.nielsen@nuffield.ox.ac.uk&gt; 8 Sep 2015 (24 Oct 2013)</p>


<h3>Source</h3>

<p>Table I of Clayton and Schifflers (1987b)</p>


<h3>References</h3>

<p>Clayton, D. and Schifflers, E. (1987b) Models for temperoral variation in cancer rates. II: age-period-cohort models. <em>Statistics in Medicine</em> 6, 469-481.
</p>


<h3>See Also</h3>

<p>General description of <code><a href="#topic+apc.data.list">apc.data.list</a></code> format.</p>


<h3>Examples</h3>

<pre><code class='language-R'>#########################
##	It is convient to construct a data variable

data	&lt;- data.Japanese.breast.cancer()

##	To see the content of the data

data
</code></pre>

<hr>
<h2 id='data.loss.BZ'>Motor data</h2><span id='topic+data.loss.BZ'></span>

<h3>Description</h3>

<p>Function that organises loss data in <code><a href="#topic+apc.data.list">apc.data.list</a></code> format.
</p>
<p>The data set is taken from table 3.5 of Barnett &amp; Zehnwirth (2000).
Source of data unclear.
It includes a run-off triangle:
&quot;response&quot; (X) is paid amounts (units not reported)
along with measures of exposure.
</p>
<p>Data also analysed in e.g.
Kuang, Nielsen, Nielsen (2011).
</p>
<p>The data set is in &quot;CL&quot;-format.
</p>
<p>At present <code>apc.package</code> does not have functions for either forecasting or for exploiting the counts.
For this one can with advantage use the <code>DCL.package</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data.loss.BZ</code></pre>


<h3>Value</h3>

<p>The value is a list in <code><a href="#topic+apc.data.list">apc.data.list</a></code> format.
</p>
<table role = "presentation">
<tr><td><code>response</code></td>
<td>
<p>vector of paid amounts, X</p>
</td></tr>
<tr><td><code>counts</code></td>
<td>
<p>vector of number of reported claims, N</p>
</td></tr>
<tr><td><code>dose</code></td>
<td>
<p>NULL.</p>
</td></tr>
<tr><td><code>data.format</code></td>
<td>
<p>logical. Equal to &quot;CL.vector.by.row&quot;.  Data organised in vectors.</p>
</td></tr>
<tr><td><code>age1</code></td>
<td>
<p>numeric. Equal to 1.</p>
</td></tr>
<tr><td><code>per1</code></td>
<td>
<p>NULL. Not needed when data.format=&quot;CL&quot;</p>
</td></tr>
<tr><td><code>coh1</code></td>
<td>
<p>numeric. Equal to 1.</p>
</td></tr>
<tr><td><code>unit</code></td>
<td>
<p>numeric. Equal to 1.</p>
</td></tr>
<tr><td><code>per.zero</code></td>
<td>
<p>NULL.  Not needed when data.format=&quot;CL&quot;</p>
</td></tr> 
<tr><td><code>per.max</code></td>
<td>
<p>NULL.  Not needed when data.format=&quot;CL&quot;</p>
</td></tr> 
<tr><td><code>time.adjust</code></td>
<td>
<p>0.  Thus age=1 in cohort=1 corresponds to period=1+1-1+0=1.</p>
</td></tr>	
<tr><td><code>label</code></td>
<td>
<p>character. &quot;loss BZ&quot;.</p>
</td></tr>						
</table>


<h3>Author(s)</h3>

<p>Bent Nielsen &lt;bent.nielsen@nuffield.ox.ac.uk&gt; 8 Sep 2015 (18 Mar 2015)</p>


<h3>Source</h3>

<p>Tables 1,2 of Verrall, Nielsen and Jessen (2010).</p>


<h3>References</h3>

<p>Barnett G, Zehnwirth B (2000)
Best estimates for reserves.
Proc. Casualty Actuar. Soc. 87, 245&ndash;321.                         
</p>
<p>Kuang D, Nielsen B, Nielsen JP (2011)
Forecasting in an extended chain-ladder-type model
<em>Journal of Risk and Insurance</em> 78, 345-359         
</p>


<h3>See Also</h3>

<p>General description of <code><a href="#topic+apc.data.list">apc.data.list</a></code> format.</p>


<h3>Examples</h3>

<pre><code class='language-R'>#########################
##	It is convient to construct a data variable

data	&lt;- data.loss.BZ()

##	To see the content of the data

data

#########################
#	Fit geometric chain-ladder model

apc.fit.table(data,"log.normal.response")

</code></pre>

<hr>
<h2 id='data.loss.TA'>Motor data</h2><span id='topic+data.loss.TA'></span>

<h3>Description</h3>

<p>Function that organises loss data in <code><a href="#topic+apc.data.list">apc.data.list</a></code> format.
</p>
<p>The data set is taken from Table 1 of Verrall (1991), who 
attributes the data to Taylor and Ashe (1983).
It includes a run-off triangle:
&quot;response&quot; (X) is paid amounts (units not reported).
</p>
<p>Data also analysed in various papers, e.g.
England and Verrall (1999).
</p>
<p>The data set is in &quot;CL&quot;-format.
</p>
<p>At present <code>apc.package</code> does not have functions for either forecasting or for exploiting the counts.
For this one can with advantage use the <code>DCL.package</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data.loss.TA</code></pre>


<h3>Value</h3>

<p>The value is a list in <code><a href="#topic+apc.data.list">apc.data.list</a></code> format.
</p>
<table role = "presentation">
<tr><td><code>response</code></td>
<td>
<p>vector of paid amounts, X</p>
</td></tr>
<tr><td><code>dose</code></td>
<td>
<p>NULL.</p>
</td></tr>
<tr><td><code>data.format</code></td>
<td>
<p>logical. Equal to &quot;CL.vector.by.row&quot;.  Data organised in vectors.</p>
</td></tr>
<tr><td><code>age1</code></td>
<td>
<p>numeric. Equal to 1.</p>
</td></tr>
<tr><td><code>per1</code></td>
<td>
<p>NULL. Not needed when data.format=&quot;CL&quot;</p>
</td></tr>
<tr><td><code>coh1</code></td>
<td>
<p>numeric. Equal to 1.</p>
</td></tr>
<tr><td><code>unit</code></td>
<td>
<p>numeric. Equal to 1.</p>
</td></tr>
<tr><td><code>per.zero</code></td>
<td>
<p>NULL.  Not needed when data.format=&quot;CL&quot;</p>
</td></tr> 
<tr><td><code>per.max</code></td>
<td>
<p>NULL.  Not needed when data.format=&quot;CL&quot;</p>
</td></tr> 
<tr><td><code>time.adjust</code></td>
<td>
<p>0.  Thus age=1 in cohort=1 corresponds to period=1+1-1+0=1.</p>
</td></tr>	
<tr><td><code>label</code></td>
<td>
<p>character. &quot;loss TA&quot;.</p>
</td></tr>						
</table>


<h3>Author(s)</h3>

<p>Bent Nielsen &lt;bent.nielsen@nuffield.ox.ac.uk&gt; 8 Sep 2015 (18 Mar 2015)</p>


<h3>Source</h3>

<p>Tables 1 of Verrall (1991).</p>


<h3>References</h3>

                                                                         
<p>England, P., Verrall, R.J. (1999)                                        
Analytic and bootstrap estimates of prediction errors in claims reserving
Insurance: Mathematics and Economics 25, 281-293                         
</p>
<p>Taylor, G.C., Ashe, F.R. (1983)
Second moments of estimates of outstanding claims
Journal of Econometrics 23, 37-61
</p>
<p>Verrall, R.J. (1991)                                                     
On the estimation of reserves from loglinear models                      
Insurance: Mathematics and Economics 10, 75-80                           
</p>


<h3>See Also</h3>

<p>General description of <code><a href="#topic+apc.data.list">apc.data.list</a></code> format.</p>


<h3>Examples</h3>

<pre><code class='language-R'>#########################
##	It is convient to construct a data variable

data	&lt;- data.loss.TA()

##	To see the content of the data

data

#########################
#	Fit chain-ladder model

apc.fit.table(data,"poisson.response")

#	The overdispersed poisson model is experimental at the moment,
#	so not documented
apc.fit.table(data,"od.poisson.response")


</code></pre>

<hr>
<h2 id='data.loss.VNJ'>Motor data</h2><span id='topic+data.loss.VNJ'></span>

<h3>Description</h3>

<p>Function that organises motor data in <code><a href="#topic+apc.data.list">apc.data.list</a></code> format.
</p>
<p>The data set is taken from tables 1,2 of Verrall, Nielsen and Jessen (2010).
Data from Codan, Danish subsiduary of Royal &amp; Sun Alliance.
It is a portfolio of third party liability from motor policies. The time units are in years.
There are two run-off triangles:
&quot;response&quot; (X) is paid amounts (units not reported)
&quot;counts&quot; (N) is number of reported claims.
</p>
<p>Data also analysed in e.g.
Martinez Miranda, Nielsen, Nielsen and Verrall (2011)
and 
Kuang, Nielsen, Nielsen (2015).
</p>
<p>The data set is in &quot;CL&quot;-format.
</p>
<p>At present <code>apc.package</code> does not have functions for either forecasting or for exploiting the counts.
For this one can with advantage use the <code>DCL.package</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data.loss.VNJ</code></pre>


<h3>Value</h3>

<p>The value is a list in <code><a href="#topic+apc.data.list">apc.data.list</a></code> format.
</p>
<table role = "presentation">
<tr><td><code>response</code></td>
<td>
<p>vector of paid amounts, X</p>
</td></tr>
<tr><td><code>counts</code></td>
<td>
<p>vector of number of reported claims, N</p>
</td></tr>
<tr><td><code>dose</code></td>
<td>
<p>NULL.</p>
</td></tr>
<tr><td><code>data.format</code></td>
<td>
<p>logical. Equal to &quot;CL.vector.by.row&quot;.  Data organised in vectors.</p>
</td></tr>
<tr><td><code>age1</code></td>
<td>
<p>numeric. Equal to 1.</p>
</td></tr>
<tr><td><code>per1</code></td>
<td>
<p>NULL. Not needed when data.format=&quot;CL&quot;</p>
</td></tr>
<tr><td><code>coh1</code></td>
<td>
<p>numeric. Equal to 1.</p>
</td></tr>
<tr><td><code>unit</code></td>
<td>
<p>numeric. Equal to 1.</p>
</td></tr>
<tr><td><code>per.zero</code></td>
<td>
<p>NULL.  Not needed when data.format=&quot;CL&quot;</p>
</td></tr> 
<tr><td><code>per.max</code></td>
<td>
<p>NULL.  Not needed when data.format=&quot;CL&quot;</p>
</td></tr> 
<tr><td><code>time.adjust</code></td>
<td>
<p>0.  Thus age=1 in cohort=1 corresponds to period=1+1-1+0=1.</p>
</td></tr>	
<tr><td><code>label</code></td>
<td>
<p>character. &quot;loss VNJ&quot;.</p>
</td></tr>						
</table>


<h3>Author(s)</h3>

<p>Bent Nielsen &lt;bent.nielsen@nuffield.ox.ac.uk&gt; 18 Mar 2015 updated 4 Jan 2016</p>


<h3>Source</h3>

<p>Tables 1,2 of Verrall, Nielsen and Jessen (2010).</p>


<h3>References</h3>

<p>Verrall R, Nielsen JP, Jessen AH (2010)
Prediction of RBNS and IBNR claims using claim amounts and claim counts
<em>ASTIN Bulletin</em> 40, 871-887
</p>
<p>Martinez Miranda, M.D., Nielsen, B., Nielsen, J.P. and Verrall, R. (2011) Cash flow simulation for a model of outstanding liabilities based on claim amounts and claim numbers. <em>ASTIN Bulletin</em> 41, 107-129
</p>
<p>Kuang D, Nielsen B, Nielsen JP (2015) 
The geometric chain-ladder
<em>Scandinavian Acturial Journal</em> 2015, 278-300.
</p>


<h3>See Also</h3>

<p>General description of <code><a href="#topic+apc.data.list">apc.data.list</a></code> format.</p>


<h3>Examples</h3>

<pre><code class='language-R'>#########################
##	It is convient to construct a data variable

data	&lt;- data.loss.VNJ()

##	To see the content of the data

data

#########################
#	Fit chain-ladder model

fit.ac	&lt;- apc.fit.model(data,"poisson.response","AC")
fit.ac$coefficients.canonical
id.ac	&lt;- apc.identify(fit.ac)
id.ac$coefficients.dif

#########################
#	Compare output with	table 7.2 in
#	Kuang D, Nielsen B, Nielsen JP (2015)
#	               Estimate   Std. Error    z value      Pr(&gt;|z|)
#	level       13.07063963 0.0000000000        Inf  0.000000e+00
#	D_age_2     -0.06543495 0.0006018694 -108.71950  0.000000e+00
#	D_age_3     -0.80332424 0.0008757527 -917.29576  0.000000e+00
#	D_age_4     -0.41906516 0.0012294722 -340.84965  0.000000e+00
#	D_age_5     -0.29097802 0.0015627740 -186.19329  0.000000e+00
#	D_age_6     -0.57299006 0.0021628918 -264.91850  0.000000e+00
#	D_age_7     -0.36101594 0.0030016569 -120.27222  0.000000e+00
#	D_age_8     -0.62706059 0.0046139466 -135.90547  0.000000e+00
#	D_age_9      0.12160793 0.0061126021   19.89463  4.529830e-88
#	D_age_10    -2.59708012 0.0245028290 -105.99103  0.000000e+00
#	D_cohort_2  -0.02591843 0.0009037977  -28.67724 7.334840e-181
#	D_cohort_3   0.18973130 0.0011301184  167.88621  0.000000e+00
#	D_cohort_4   0.12354693 0.0010508785  117.56539  0.000000e+00
#	D_cohort_5  -0.10114701 0.0010566534  -95.72392  0.000000e+00
#	D_cohort_6   0.03594882 0.0010913718   32.93912 6.056847e-238
#	D_cohort_7  -0.17175409 0.0011676536 -147.09336  0.000000e+00
#	D_cohort_8   0.20671145 0.0012098255  170.86055  0.000000e+00
#	D_cohort_9   0.04056617 0.0012325163   32.91329 1.418555e-237
#	D_cohort_10  0.06876759 0.0015336998   44.83771  0.000000e+00

#########################
#	Get deviance table.
#	APC strongly rejected =&gt; overdispersion?
#   AC (Chain-ladder) rejected against APC (inference invalid anyway)
#   	=&gt; one should be careful with distribution forecasts

apc.fit.table(data,"poisson.response")

#########################
#	        -2logL df.residual prob(&gt;chi_sq)  LR.vs.APC df.vs.APC prob(&gt;chi_sq)        aic
#	APC   176030.0          28             0         NA        NA            NA   176841.7
#	AP    305784.6          36             0   129754.6         8             0   306580.3
#	AC    374155.2          36             0   198125.2         8             0   374950.9
#	PC    553555.1          36             0   377525.0         8             0   554350.7
#	Ad    486013.4          44             0   309983.4        16             0   486793.0
#	Pd    710009.6          44             0   533979.6        16             0   710789.3
#	Cd    780859.4          44             0   604829.4        16             0   781639.1
#	A     575389.6          45             0   399359.6        17             0   576167.3
#	P    9483688.1          45             0  9307658.0        17             0  9484465.7
#	C    7969034.0          45             0  7793004.0        17             0  7969811.7
#	t     898208.1          52             0   722178.1        24             0   898971.7
#	tA    987389.4          53             0   811359.4        25             0   988151.1
#	tP   9690623.4          53             0  9514593.4        25             0  9691385.1
#	tC   8079187.6          53             0  7903157.6        25             0  8079949.3
#	1   10815443.5          54             0 10639413.5        26             0 10816203.2


#########################
#	Fit geometric chain-ladder model

fit.ac	&lt;- apc.fit.model(data,"log.normal.response","AC")
fit.ac$coefficients.canonical
id.ac	&lt;- apc.identify(fit.ac)
id.ac$coefficients.dif

#########################
#	Compare output with	table 7.2 in
#	Kuang D, Nielsen B, Nielsen JP (2015)
#	                 Estimate Std. Error     t value     Pr(&gt;|t|)
#	level       13.0846325168  0.1322711 98.92285585 0.000000e+00
#	D_age_2     -0.0721758004  0.1291053 -0.55904595 5.761304e-01
#	D_age_3     -0.8180698189  0.1350216 -6.05880856 1.371335e-09
#	D_age_4     -0.3945325384  0.1433094 -2.75301253 5.904964e-03
#	D_age_5     -0.3354312554  0.1538274 -2.18056918 2.921530e-02
#	D_age_6     -0.6322104515  0.1673396 -3.77800844 1.580875e-04
#	D_age_7     -0.3020293471  0.1854134 -1.62895114 1.033234e-01
#	D_age_8     -0.5225495852  0.2112982 -2.47304367 1.339678e-02
#	D_age_9      0.0078494549  0.2531172  0.03101115 9.752607e-01
#	D_age_10    -2.5601846890  0.3415805 -7.49511273 6.624141e-14
#	D_cohort_2  -0.1025686798  0.1291053 -0.79445748 4.269292e-01
#	D_cohort_3   0.0820931043  0.1350216  0.60799994 5.431875e-01
#	D_cohort_4   0.3800465893  0.1433094  2.65193088 8.003292e-03
#	D_cohort_5  -0.0920821506  0.1538274 -0.59860701 5.494350e-01
#	D_cohort_6  -0.0530061052  0.1673396 -0.31675768 7.514275e-01
#	D_cohort_7  -0.2053813051  0.1854134 -1.10769405 2.679940e-01
#	D_cohort_8   0.2705853742  0.2112982  1.28058555 2.003393e-01
#	D_cohort_9  -0.0009224552  0.2531172 -0.00364438 9.970922e-01
#	D_cohort_10  0.0736954734  0.3415805  0.21574845 8.291838e-01

#########################
#	Get deviance table.
#	AC marginally rejected against APC

apc.fit.table(data,"log.normal.response")

#########################
#	     -2logL df.residual LR.vs.APC df.vs.APC prob(&gt;chi_sq)     aic
#	APC -28.528          28        NA        NA            NA  27.472
#	AP   -3.998          36    24.530         8         0.002  36.002
#	AC   -9.686          36    18.842         8         0.016  30.314
#	PC   31.722          36    60.250         8         0.000  71.722
#	Ad    6.251          44    34.779        16         0.004  30.251
#	Pd   41.338          44    69.866        16         0.000  65.338
#	Cd   38.919          44    67.447        16         0.000  62.919
#	A    12.765          45    41.292        17         0.001  34.765
#	P   171.283          45   199.811        17         0.000 193.283
#	C   162.451          45   190.979        17         0.000 184.451
#	t    46.300          52    74.827        24         0.000  54.300
#	tA   49.541          53    78.069        25         0.000  55.541
#	tP  171.770          53   200.298        25         0.000 177.770
#	tC  163.280          53   191.808        25         0.000 169.280
#	1   182.166          54   210.694        26         0.000 186.166

</code></pre>

<hr>
<h2 id='data.loss.XL'>US Casualty data, XL Group</h2><span id='topic+data.loss.XL'></span>

<h3>Description</h3>

<p>Function that organises US Casualty data from XL Group in <code><a href="#topic+apc.data.list">apc.data.list</a></code> format.
</p>
<p>The data set is taken from table 1.1 Kuang and Nielsen (2020).
Data are for US Casualty data from the XL Group.
They are gross paid and reported loss and allocated loss adjustment expense in 1000 USD.
</p>
<p>The data set is in &quot;CL&quot;-format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data.loss.XL</code></pre>


<h3>Value</h3>

<p>The value is a list in <code><a href="#topic+apc.data.list">apc.data.list</a></code> format.
</p>
<table role = "presentation">
<tr><td><code>response</code></td>
<td>
<p>matrix of paid amounts, incremental</p>
</td></tr>
<tr><td><code>dose</code></td>
<td>
<p>NULL.</p>
</td></tr>
<tr><td><code>data.format</code></td>
<td>
<p>logical. Equal to &quot;CL&quot;.</p>
</td></tr>
<tr><td><code>age1</code></td>
<td>
<p>numeric. Equal to 1.</p>
</td></tr>
<tr><td><code>per1</code></td>
<td>
<p>NULL. Not needed when data.format=&quot;CL&quot;</p>
</td></tr>
<tr><td><code>coh1</code></td>
<td>
<p>numeric. Equal to 1997.</p>
</td></tr>
<tr><td><code>unit</code></td>
<td>
<p>numeric. Equal to 1997.</p>
</td></tr>
<tr><td><code>per.zero</code></td>
<td>
<p>NULL.  Not needed when data.format=&quot;CL&quot;</p>
</td></tr> 
<tr><td><code>per.max</code></td>
<td>
<p>NULL.  Not needed when data.format=&quot;CL&quot;</p>
</td></tr> 
<tr><td><code>time.adjust</code></td>
<td>
<p>-1996.  Thus age=1 in cohort=1997 corresponds to period=1997+1997-1+(-1996)=1997.</p>
</td></tr>	
<tr><td><code>label</code></td>
<td>
<p>character. &quot;loss, US casualty, XL Group&quot;.</p>
</td></tr>						
</table>


<h3>Author(s)</h3>

<p>Bent Nielsen &lt;bent.nielsen@nuffield.ox.ac.uk&gt; 26 August 2020 (10 Mar 2018)</p>


<h3>Source</h3>

<p>Table 1.1 of Kuang and Nielsen (2020) and in turn
<em>download</em>:
<a href="http://xlgroupltd.gcs-web.com/static-files/0b180970-7117-42e9-bd6b-c3663af60097">xls file</a>
from
<a href="http://xlgroupltd.gcs-web.com/events-and-presentations/presentations?c=73041&amp;p=irol-financialreports">XL Group files</a>.
</p>


<h3>References</h3>

<p>Kuang, D. and Nielsen B. (2020) Generalized log-normal chain-ladder. <em>Scandinavian Actuarial Journal</em> 2020, 553-576. <em>Download</em>: <a href="https://www.tandfonline.com/doi/full/10.1080/03461238.2019.1696885">Open access</a>. Earlier version: <a href="https://www.nuffield.ox.ac.uk/economics/Papers/2018/2018W02_KuangNielsen2018GLNCL.pdf">Nuffield DP</a>.
</p>


<h3>See Also</h3>

<p>General description of <code><a href="#topic+apc.data.list">apc.data.list</a></code> format.
</p>
<p>For explanation for Chain Ladder forecast, see <code><a href="#topic+apc.forecast.ac">apc.forecast.ac</a></code>. 
</p>
<p>The analysis in Kuang and Nielsen (2020) is reproduced in the vignette
<a href="../doc/ReproducingKN2020.pdf"><code>ReproducingKN2020.pdf</code></a>,
<a href="../doc/ReproducingKN2020.R"><code>ReproducingKN2020.R</code></a>
on
<a href="../doc/index.html"><code>Vignettes</code></a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#########################
##	It is convenient to construct a data variable for paid data

data	&lt;- data.loss.XL()
##	To see the content of the data
data

#########################
#	Get deviance table.
#	reproduce Table 4.1 in Kuang and Nielsen (2018).

apc.fit.table(data,"log.normal.response")
apc.fit.table(data,"log.normal.response",model.design.reference="AC")

#########################
#	&gt; apc.fit.table(data,"log.normal.response")
#	     -2logL df.residual LR vs.APC df vs.APC prob(&gt;chi_sq) F vs.APC prob(&gt;F)     aic
#	APC 170.003         153       NaN       NaN           NaN      NaN      NaN 286.003
#	AP  243.531         171    73.527        18         0.000    3.564    0.000 323.531
#	AC  179.873         171     9.869        18         0.936    0.409    0.984 259.873
#	PC  633.432         171   463.428        18         0.000   68.736    0.000 713.432
#	Ad  258.570         189    88.567        36         0.000    2.230    0.000 302.570
#	Pd  643.892         189   473.888        36         0.000   36.340    0.000 687.892
#	Cd  649.142         189   479.139        36         0.000   37.368    0.000 693.142
#	A   357.359         190   187.355        37         0.000    5.956    0.000 399.359
#	P   644.176         190   474.172        37         0.000   35.412    0.000 686.176
#	C   672.392         190   502.388        37         0.000   41.099    0.000 714.392
#	t   664.488         207   494.484        54         0.000   27.015    0.000 672.488
#	tA  681.993         208   511.989        55         0.000   29.072    0.000 687.993
#	tP  664.746         208   494.742        55         0.000   26.560    0.000 670.746
#	tC  686.181         208   516.178        55         0.000   29.713    0.000 692.181
#	1   690.399         209   520.396        56         0.000   29.830    0.000 694.399
#
#	&gt; apc.fit.table(data,"log.normal.response",model.design.reference="AC")
#	    -2logL df.residual LR vs.AC df vs.AC prob(&gt;chi_sq) F vs.AC prob(&gt;F)     aic
#	AC 179.873         171      NaN      NaN           NaN     NaN      NaN 259.873
#	Ad 258.570         189   78.698       18             0   4.319        0 302.570
#	Cd 649.142         189  469.269       18             0  79.257        0 693.142
#	A  357.359         190  177.486       19             0  11.955        0 399.359
#	C  672.392         190  492.519       19             0  84.930        0 714.392
#	t  664.488         207  484.615       36             0  42.993        0 672.488
#	tA 681.993         208  502.120       37             0  45.869        0 687.993
#	tC 686.181         208  506.308       37             0  46.886        0 692.181
#	1  690.399         209  510.526       38             0  46.670        0 694.399
 	
 
#########################
#	Fit log normal chain-ladder model
#	reproduce Table 4.2 in Kuang and Nielsen (2018).

fit.ac	&lt;- apc.fit.model(data,"log.normal.response","AC")
id.ac	&lt;- apc.identify(fit.ac)
id.ac$coefficients.dif
fit.ac$s2		
fit.ac$RSS

#########################
#	&gt; id.ac$coefficients.dif
#	                  Estimate Std. Error     t value     Pr(&gt;|t|)
#	level          7.660055032  0.1377951 55.59016605 0.000000e+00
#	D_age_1998     2.272100342  0.1335080 17.01846386 5.992216e-65
#	D_age_1999     0.932530550  0.1362610  6.84370899 7.716860e-12
#	D_age_2000     0.235606356  0.1398301  1.68494782 9.199864e-02
#	D_age_2001     0.088886609  0.1438733  0.61781154 5.366996e-01
#	D_age_2002    -0.176044303  0.1483681 -1.18653717 2.354102e-01
#	D_age_2003    -0.144445459  0.1533567 -0.94189218 3.462478e-01
#	D_age_2004    -0.427608601  0.1589136 -2.69082462 7.127565e-03
#	D_age_2005    -0.300527594  0.1651428 -1.81980421 6.878883e-02
#	D_age_2006    -0.399729999  0.1721838 -2.32153023 2.025824e-02
#	D_age_2007    -0.189656058  0.1802245 -1.05233225 2.926471e-01
#	D_age_2008    -0.242063670  0.1895226 -1.27722853 2.015216e-01
#	D_age_2009    -0.260459607  0.2004421 -1.29942545 1.937980e-01
#	D_age_2010    -0.555317528  0.2135164 -2.60081872 9.300158e-03
#	D_age_2011    -0.303234088  0.2295651 -1.32090683 1.865324e-01
#	D_age_2012     0.405830766  0.2499291  1.62378389 1.044219e-01
#	D_age_2013    -0.895278068  0.2769988 -3.23206421 1.228994e-03
#	D_age_2014     0.116668873  0.3156054  0.36966685 7.116307e-01
#	D_age_2015    -0.383048241  0.3777268 -1.01408813 3.105407e-01
#	D_age_2016    -0.273419402  0.5083832 -0.53782152 5.907003e-01
#	D_cohort_1998  0.288755900  0.1335080  2.16283663 3.055375e-02
#	D_cohort_1999  0.163424236  0.1362610  1.19934721 2.303930e-01
#	D_cohort_2000 -0.264981486  0.1398301 -1.89502518 5.808907e-02
#	D_cohort_2001  0.149829430  0.1438733  1.04139815 2.976908e-01
#	D_cohort_2002 -0.374386828  0.1483681 -2.52336417 1.162380e-02
#	D_cohort_2003 -0.198735893  0.1533567 -1.29590632 1.950078e-01
#	D_cohort_2004 -0.008807130  0.1589136 -0.05542087 9.558032e-01
#	D_cohort_2005 -0.005337953  0.1651428 -0.03232325 9.742143e-01
#	D_cohort_2006 -0.132272851  0.1721838 -0.76820710 4.423642e-01
#	D_cohort_2007 -0.021862643  0.1802245 -0.12130783 9.034472e-01
#	D_cohort_2008 -0.472602270  0.1895226 -2.49364600 1.264386e-02
#	D_cohort_2009 -0.437572798  0.2004421 -2.18303804 2.903301e-02
#	D_cohort_2010  0.295511564  0.2135164  1.38402260 1.663515e-01
#	D_cohort_2011  0.310545832  0.2295651  1.35275725 1.761332e-01
#	D_cohort_2012 -0.268692406  0.2499291 -1.07507473 2.823413e-01
#	D_cohort_2013  0.142131410  0.2769988  0.51311192 6.078730e-01
#	D_cohort_2014  0.201777590  0.3156054  0.63933494 5.226051e-01
#	D_cohort_2015 -0.092672697  0.3777268 -0.24534320 8.061907e-01
#	D_cohort_2016  0.872997251  0.5083832  1.71720334 8.594203e-02	
#	&gt; fit.ac$s2	
#	[1] 0.1693316
#	&gt; fit.ac$RSS
#	[1] 28.9557
#	&gt; fit.ac$RSS

forecast &lt;- apc.forecast.ac(fit.ac,quantiles=c(0.995))
forecast$response.forecast.coh

#########################
#	&gt; forecast$response.forecast.coh
#			 forecast         se    se.proc      se.est     t-0.995
#	coh_2    1871.073   1026.463   707.4405    743.7428    4544.891
#	coh_3    5099.330   1874.681  1375.8435   1273.3744    9982.659
#	coh_4    7171.317   2123.128  1622.5220   1369.3412   12701.822
#	coh_5   11699.350   2984.949  2274.8292   1932.6338   19474.801
#	coh_6   13717.388   3345.138  2654.4080   2035.6984   22431.090
#	coh_7   14343.522   3188.410  2471.3130   2014.5886   22648.964
#	coh_8   18377.001   3834.057  2910.9751   2495.2390   28364.281
#	coh_9   25488.052   5241.618  3976.5389   3414.9225   39141.867
#	coh_10  30524.942   6213.652  4662.3320   4107.5694   46710.794
#	coh_11  40078.245   8115.990  5976.5789   5490.8835   61219.471
#	coh_12  32680.319   6603.511  4727.4210   4610.6241   49881.712
#	coh_13  28509.077   5895.265  4143.1332   4193.8760   43865.568
#	coh_14  51760.526  11013.030  7540.3989   8026.7807   80448.208
#	coh_15  98747.731  22063.641 14798.3216  16365.0210  156220.991
#	coh_16 100330.677  23254.845 14704.7084  18015.5316  160906.889
#	coh_17 149813.314  36629.836 21310.2885  29792.8931  245229.846
#	coh_18 221549.649  58610.037 29815.3239  50459.7158  374222.093
#	coh_19 229480.904  69931.745 29102.9866  63588.2473  411645.102
#	coh_20 575343.178 235016.967 70362.1087 224236.8135 1187535.497

</code></pre>

<hr>
<h2 id='data.RH.mortality'>2-sample mortality data.</h2><span id='topic+data.RH.mortality'></span><span id='topic+data.RH.mortality.dk'></span><span id='topic+data.RH.mortality.no'></span>

<h3>Description</h3>

<p>Function that organises mortality data from Riebler and Held (2010) in <code><a href="#topic+apc.data.list">apc.data.list</a></code> format.
</p>
<p>The data set is taken from the supplementary data of Riebler and Held (2010).
Mortality data for women in Denmark and Norway
</p>
<p>The original source was
Jacobsen et al. (2004).
</p>
<p>The data set is in &quot;AP&quot;-format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data.RH.mortality.dk()
data.RH.mortality.no()</code></pre>


<h3>Value</h3>

<p>The value is a list in <code><a href="#topic+apc.data.list">apc.data.list</a></code> format.
</p>
<table role = "presentation">
<tr><td><code>response</code></td>
<td>
<p>matrix of cases</p>
</td></tr>
<tr><td><code>dose</code></td>
<td>
<p>matrix of cases/rates</p>
</td></tr>
<tr><td><code>data.format</code></td>
<td>
<p>logical equal to &quot;AP&quot;.  Data organised with age-groups in rows and period-groups in columns.</p>
</td></tr>
<tr><td><code>age1</code></td>
<td>
<p>numeric equal to 0.</p>
</td></tr>
<tr><td><code>per1</code></td>
<td>
<p>numeric equal to 1960.</p>
</td></tr>
<tr><td><code>coh1</code></td>
<td>
<p>NULL.  Not needed when data.format=&quot;AP&quot;</p>
</td></tr>
<tr><td><code>unit</code></td>
<td>
<p>numeric equal to 5.  This is the width of the age and period groups.</p>
</td></tr>
<tr><td><code>per.zero</code></td>
<td>
<p>NULL.  Not needed when data.format=&quot;AP&quot;</p>
</td></tr> 
<tr><td><code>per.max</code></td>
<td>
<p>NULL.  Not needed when data.format=&quot;AP&quot;</p>
</td></tr> 
<tr><td><code>time.adjust</code></td>
<td>
<p>0.  Thus age=0 in period=1960 corresponds to cohort=1960-0+0=1960, and indeed the
centers of the age and period groups, that is age=2 and period=1962
translate into cohort=1962-2+0=1960.</p>
</td></tr>	
<tr><td><code>label</code></td>
<td>
<p>character. &quot;RH mortality Denmark&quot; or &quot;RH mortality Norway&quot;.</p>
</td></tr>						
</table>


<h3>Author(s)</h3>

<p>Bent Nielsen &lt;bent.nielsen@nuffield.ox.ac.uk&gt; 17 Sep 2016</p>


<h3>Source</h3>

<p>Riebler and Held (2010), supplementary material.</p>


<h3>References</h3>

<p>Jacobsen, R, von Euler, M, Osler, M, Lynge, E and Keiding, N (2004) Women's death in Scandinavia - what makes Denmark different? <em>European Journal of Epidemiology</em> 19, 117-121.
</p>
<p>Riebler, A and Held, L. (2010) The analysis of heterogeneous time trends in multivariate age-period-cohort models. <em>Biostatistics</em> 11, 57&ndash;59. <em>Download</em>: <a href="http://biostatistics.oxfordjournals.org/content/11/1/57.full.pdf+html">Open access</a>, <a href="http://biostatistics.oxfordjournals.org/content/11/1/57/suppl/DC1">Supplementary material</a>.
</p>


<h3>See Also</h3>

<p>General description of <code><a href="#topic+apc.data.list">apc.data.list</a></code> format.</p>


<h3>Examples</h3>

<pre><code class='language-R'>#########################
##	It is convient to construct a data variable

data	&lt;- data.US.prostate.cancer()

##	To see the content of the data

data
</code></pre>

<hr>
<h2 id='data.US.prostate.cancer'>Japanese breast cancer data</h2><span id='topic+data.US.prostate.cancer'></span>

<h3>Description</h3>

<p>Function that organises US prostate data in <code><a href="#topic+apc.data.list">apc.data.list</a></code> format.
</p>
<p>The data set is taken from table 2 of Holford (1983), which contains age-specific counts of deaths
and midperiod population measured in 1000s,
during the period 1935-1969.
Reported in 5 year age groups and 5 year period groups.
</p>
<p>The original source was
Cancer deaths: National Center for Health Statistics, 1937-1973
Population 1935-60: Grove and Hetzel, 1968
Population 1960-69: Bureau of the Census, 1974		
</p>
<p>The data set is in &quot;AP&quot;-format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data.US.prostate.cancer()</code></pre>


<h3>Value</h3>

<p>The value is a list in <code><a href="#topic+apc.data.list">apc.data.list</a></code> format.
</p>
<table role = "presentation">
<tr><td><code>response</code></td>
<td>
<p>matrix of cases</p>
</td></tr>
<tr><td><code>dose</code></td>
<td>
<p>matrix of cases/rates</p>
</td></tr>
<tr><td><code>data.format</code></td>
<td>
<p>logical equal to &quot;AP&quot;.  Data organised with age-groups in rows and period-groups in columns.</p>
</td></tr>
<tr><td><code>age1</code></td>
<td>
<p>numeric equal to 50.  This is the label for the first age group covering ages 25-29.</p>
</td></tr>
<tr><td><code>per1</code></td>
<td>
<p>numeric equal to 1935.  This is the label for the first period group covering period 1955-1959.</p>
</td></tr>
<tr><td><code>coh1</code></td>
<td>
<p>NULL.  Not needed when data.format=&quot;AP&quot;</p>
</td></tr>
<tr><td><code>unit</code></td>
<td>
<p>numeric equal to 5.  This is the width of the age and period groups.</p>
</td></tr>
<tr><td><code>per.zero</code></td>
<td>
<p>NULL.  Not needed when data.format=&quot;AP&quot;</p>
</td></tr> 
<tr><td><code>per.max</code></td>
<td>
<p>NULL.  Not needed when data.format=&quot;AP&quot;</p>
</td></tr> 
<tr><td><code>time.adjust</code></td>
<td>
<p>0.  Thus age=50 in period=1935 corresponds to cohort=1935-50+0=1885, and indeed the
centers of the age and period groups, that is age=52 and period=1937
translate into cohort=1937-52+0=1885.</p>
</td></tr>	
<tr><td><code>label</code></td>
<td>
<p>character. &quot;US prostate cancer&quot;.</p>
</td></tr>						
</table>


<h3>Author(s)</h3>

<p>Bent Nielsen &lt;bent.nielsen@nuffield.ox.ac.uk&gt; 8 Sep 2015 (28 Apr 2015)</p>


<h3>Source</h3>

<p>Table 2 of Holford (1983)</p>


<h3>References</h3>

<p>Holford, T.R. (1983) The estimation of age, period and cohort effects for vital rates. <em>Biometrics</em> 39, 311-324.                                             
</p>


<h3>See Also</h3>

<p>General description of <code><a href="#topic+apc.data.list">apc.data.list</a></code> format.</p>


<h3>Examples</h3>

<pre><code class='language-R'>#########################
##	It is convient to construct a data variable

data	&lt;- data.US.prostate.cancer()

##	To see the content of the data

data
</code></pre>

<hr>
<h2 id='new.apc.identify'>Identification of time effects</h2><span id='topic+new.apc.identify'></span>

<h3>Description</h3>

<p>Computes ad hoc identified time effects.</p>


<h3>Usage</h3>

<pre><code class='language-R'>new.apc.identify(apc.fit.model)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="new.apc.identify_+3A_apc.fit.model">apc.fit.model</code></td>
<td>
<p>List. See <code><a href="#topic+apc.fit.model">apc.fit.model</a></code> for a description of the format.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Forms ad hoc identified time effects from the canonical parameter.
These are used either indirectly by <code><a href="#topic+apc.plot.fit">apc.plot.fit</a></code>
or they are computed directly with this command.
</p>
<p>The ad hoc identifications are based on	Nielsen (2014b). For details see also the vignette
<a href="../doc/Identification.pdf"><code>Identification.pdf</code></a>,
<a href="../doc/Identification.R"><code>Identification.R</code></a>
on
<a href="../doc/index.html"><code>Vignettes</code></a>		
or in the notes below.
</p>
<p>For model designs of any type two ad hoc identified time effects.
</p>
<p>(1)
The type &quot;sum.sum&quot; (same as &quot;ss.dd&quot;) gives double sums anchored in the middle of
the first period diagonal. 
</p>
<p>(2)
The type &quot;detrend&quot; gives double sums that start in zero and end in zero.
</p>
<p>For model designs with only two time effects, that is &quot;AC&quot;, &quot;AP&quot;, &quot;PC&quot; there is
a further ad hoc identification.
</p>
<p>(3)
The type &quot;demean&quot; gives single sums of single differences. Derived from &quot;detrend&quot; where the
linear trends are attributed to the double sums of double differences. Level unchanged.
</p>
<p>(4)
The type &quot;dif&quot; gives the single differences derived from &quot;demean&quot;.  Could also have been chosen
as canonical parametrisation for these models.
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>index.age.max</code></td>
<td>
<p>Vector.  Indices for age    parameters when using coefficients.ssdd or coefficients.detrend.  The length is two longer that that of <code>apc.model.fit$index.age</code> if <code>model.design</code> is &quot;APC.  NULL if age    double differences are not estimated.</p>
</td></tr>
<tr><td><code>index.per.max</code></td>
<td>
<p>Vector.  Indices for period parameters when using coefficients.ssdd or coefficients.detrend.  The length is two longer that that of <code>apc.model.fit$index.per</code> if <code>model.design</code> is &quot;APC.  NULL if age    double differences are not estimated.</p>
</td></tr>
<tr><td><code>index.coh.max</code></td>
<td>
<p>Vector.  Indices for cohort parameters when using coefficients.ssdd or coefficients.detrend.  The length is two longer that that of <code>apc.model.fit$index.coh</code> if <code>model.design</code> is &quot;APC.  NULL if age    double differences are not estimated.</p>
</td></tr>
<tr><td><code>dates.max</code></td>
<td>
<p>Vector.  Indicates the dates for the parameters when using coefficients.ssdd or coefficients.detrend.  The length is six longer that that of <code>apc.model.fit$index.coh</code> if <code>model.design</code> is &quot;APC.</p>
</td></tr>
<tr><td><code>index.age.sub</code></td>
<td>
<p>* Vector.  Indices for age    parameters when using coefficients.demean.  The length is two longer that that of <code>apc.model.fit$index.age</code> if <code>model.design</code> is &quot;APC.  NULL if age    double differences are not estimated.</p>
</td></tr>
<tr><td><code>index.per.sub</code></td>
<td>
<p>* Vector.  Indices for period parameters when using coefficients.demean.  The length is two longer that that of <code>apc.model.fit$index.per</code> if <code>model.design</code> is &quot;APC.  NULL if age    double differences are not estimated.</p>
</td></tr>
<tr><td><code>index.coh.sub</code></td>
<td>
<p>* Vector.  Indices for cohort parameters when using coefficients.demean.  The length is two longer that that of <code>apc.model.fit$index.coh</code> if <code>model.design</code> is &quot;APC.  NULL if age    double differences are not estimated.</p>
</td></tr>
<tr><td><code>dates.sub</code></td>
<td>
<p>* Vector.  Indicates the dates for the parameters when using coefficients.demean.  The length is six longer that that of <code>apc.model.fit$index.coh</code> if <code>model.design</code> is &quot;APC.</p>
</td></tr>
<tr><td><code>index.age.dif</code></td>
<td>
<p>* Vector.  Indices for age    parameters when using coefficients.dif.  The length is one longer that that of <code>apc.model.fit$index.age</code> if <code>model.design</code> is &quot;APC.  NULL if age    double differences are not estimated.</p>
</td></tr>
<tr><td><code>index.per.dif</code></td>
<td>
<p>* Vector.  Indices for period parameters when using coefficients.dif.  The length is one  longer that that of <code>apc.model.fit$index.per</code> if <code>model.design</code> is &quot;APC.  NULL if age    double differences are not estimated.</p>
</td></tr>
<tr><td><code>index.coh.dif</code></td>
<td>
<p>* Vector.  Indices for cohort parameters when using coefficients.dif.  The length is one  longer that that of <code>apc.model.fit$index.coh</code> if <code>model.design</code> is &quot;APC.  NULL if age    double differences are not estimated.</p>
</td></tr>
<tr><td><code>dates.dif</code></td>
<td>
<p>* Vector.  Indicates the dates for the parameters when using coefficients.dif.  The length is three longer that that of <code>apc.model.fit$index.coh</code> if <code>model.design</code> is &quot;APC.</p>
</td></tr>
<tr><td><code>coefficients.ssdd</code></td>
<td>
<p>Matrix.  Coefficients of the double sum of double differences.  Normalised to be zero at two values chosen so age=cohort and period is at the minimal value.  For each parameter is reported coefficient, standard deviation, z-value, which is the ratio of those, and p-value.</p>
</td></tr>
<tr><td><code>covariance.ssdd</code></td>
<td>
<p>Matrix.  Estimated covariance matrix for double sums.</p>
</td></tr>
<tr><td><code>coefficients.detrend</code></td>
<td>
<p>Matrix.  Coefficients of the double sum of double differences.  Normalised to be zero for first and last value.  For each parameter is reported coefficient, standard deviation, z-value, which is the ratio of those, and p-value.</p>
</td></tr>
<tr><td><code>covariance.detrend</code></td>
<td>
<p>Matrix.  Estimated covariance matrix for detrended double sums.</p>
</td></tr>
<tr><td><code>coefficients.demean</code></td>
<td>
<p>* Matrix.  Coefficients of the sum of differences.  Normalised to be zero for first value.  Does not apply is design is &quot;APC&quot; For each parameter is reported coefficient, standard deviation, z-value, which is the ratio of those, and p-value.</p>
</td></tr>
<tr><td><code>covariance.demean</code></td>
<td>
<p>* Matrix.  Estimated covariance matrix for demeaned sums.</p>
</td></tr>
<tr><td><code>coefficients.dif</code></td>
<td>
<p>* Matrix.  Coefficients of the differences.  Does not apply is design is &quot;APC&quot; For each parameter is reported coefficient, standard deviation, z-value, which is the ratio of those, and p-value.</p>
</td></tr>
<tr><td><code>covariance.dif</code></td>
<td>
<p>* Matrix.  Estimated covariance matrix for differences.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>* indicates that values only implemented for designs &quot;AC&quot;, &quot;AP&quot;, &quot;PC&quot;.
</p>
<p>The differences are not identified for design &quot;APC&quot;.  An arbitrary level can be moved between differences for
age, period and cohort.  
</p>
<p>The differences are not identified for designs &quot;Ad&quot;, &quot;Pd&quot;, &quot;Cd&quot;.  These models have two linear trends and one set of
double differences.  In the model &quot;Ad&quot;, as an example, one linear trend will be associated with age, but it is
arbitrary whether the second linear trend should be associated with period or cohort.  The slope of the age trend
will depend on that arbitrary choice.  In turn the level of the age differences will be arbitrary.  
</p>
<p>(1)
The type &quot;sum.sum&quot; (same as &quot;ss.dd&quot;) gives double sums anchored 
to be zero in the three points where
<code>age=cohort=U</code>,
<code>age=U+1,cohort=U</code>
<code>age=U,cohort=U+1</code>
with
<code>apc.fit.model$U</code>
and where
<code>U</code>
is the integer value of
<code>(per.zero+3)/2</code>
This corresponds to the representation in
Nielsen (2014b).
The linear plane is parametrised in terms of 
a level, which is the value of the predictor at
<code>age=cohort=U</code>;
an age slope, which is the difference of the values of the predictor at
<code>age=U+1,cohort=U</code>
and 
<code>age=cohort=U</code>;
an cohort slope, which is the difference of the values of the predictor at
<code>age=U,cohort=U+1</code>
and 
<code>age=cohort=U</code>.
</p>
<p>(2)
The type &quot;detrend&quot; gives double sums that start in zero and end in zero.
The linear plane is parametrised in terms of
a level, which is the value of the predictor at 
<code>age=cohort=1</code>, which is usually outside the index set for the data;
while age and cohort slopes are adjusted for the ad hoc identification of the time effects.
</p>
<p>(3)
Subsumes <code>var.apc.identify</code> from <code>apc.indiv</code> (25 Sep 2020)
</p>


<h3>Author(s)</h3>

<p>Bent Nielsen &lt;bent.nielsen@nuffield.ox.ac.uk&gt; &amp; Zoe Fannon 25 Sep 2020 (12 Apr 2015)</p>


<h3>References</h3>

<p>Kuang, D., Nielsen, B. and Nielsen, J.P. (2008a) Identification of the age-period-cohort model and the extended chain ladder model. Biometrika 95, 979-986. <em>Download</em>: <a href="https://doi.org/10.1093/biomet/asn026">Article</a>; Earlier version <a href="http://www.nuffield.ox.ac.uk/economics/papers/2007/w5/KuangNielsenNielsen07.pdf">Nuffield DP</a>.
</p>
<p>Nielsen, B. (2014b) Deviance analysis of age-period-cohort models. Work in progress.
</p>


<h3>See Also</h3>

<p>The <a href="http://users.ox.ac.uk/~nuff0078/apc/index.htm">vignette</a> <a href="http://users.ox.ac.uk/~nuff0078/apc/vignettes/Identification.pdf">Identification.pdf</a>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>########################
#	Belgian lung cancer
# 	first an example with APC design, note that demean and dif not defined.

data.list	&lt;- data.Belgian.lung.cancer()

fit.apc	&lt;- apc.fit.model(data.list,"poisson.dose.response","APC")
fit.apc$coefficients.canonical
id.apc	&lt;- apc.identify(fit.apc)
id.apc$coefficients.ssdd
id.apc$coefficients.detrend
id.apc$coefficients.demean
id.apc$coefficients.dif

fit.ap	&lt;- apc.fit.model(data.list,"poisson.dose.response","AP")
fit.ap$coefficients.canonical
id.ap	&lt;- apc.identify(fit.ap)
id.ap$coefficients.ssdd
id.ap$coefficients.detrend
id.ap$coefficients.demean
id.ap$coefficients.dif

</code></pre>

<hr>
<h2 id='new.apc.plot.fit'>Plots of apc estimates</h2><span id='topic+new.apc.plot.fit'></span>

<h3>Description</h3>

<p>Functions to plot the apc estimates found by <code><a href="#topic+apc.fit.model">apc.fit.model</a></code>.  The function apc.plot.fit detects the type of
<code>model.design</code> and <code>model.family</code> from the fit values and makes appropriate plots.
</p>
<p>Depending on the <code>model.design</code> the plot has up to 9 sub plots.
The type of these can be chosen using <code>type</code>
</p>
<p><b>Model designs of any type.</b>
If <code>type</code> is &quot;detrend&quot; or &quot;sum.sum&quot;
the canonical age period cohort parametrisation is used.  This involves double differences of the
time effects. 
The first row of plots are double differences of the time effects.
The next two rows of plots illustrate the representation theorem depending on the choice of <code>type</code>.
In both cases the sum of the plots add up to the predictor.	 
</p>

<dl>
<dt>&quot;detrend&quot;</dt><dd><p>The last row of plots are double sums of double differences detrend so that that each series starts in
zero and ends in zero.  The corresponding level and (up to) two linear trends are shown in the middle row of plots.
The linear trends are identified to be 0 for age, period or cohort equal to its smallest value.
See note 2 below.
</p>
</dd>
<dt>&quot;sum.sum&quot;</dt><dd><p>The last row of plots are double sums of double differences anchored as in the derivation of
Nielsen (2014b).
The corresponding level and (up to) two linear trends are shown in the middle row of plots.
The linear trends are identified to be 0 for the anchoring point U of age, period or cohort as
described in 
Nielsen (2014b).
See note 1 below.
</p>
</dd>
</dl>

<p><b>Model designs with 2 factors.</b>
If <code>type</code> is &quot;dif&quot; the canonical two factor parametrisation is used.
This involves single differences.
It is only implemented for <code>model.design</code> of &quot;AC&quot;, &quot;AP&quot;, &quot;PC&quot;.
It does not apply for <code>model.design</code> of &quot;APC&quot; because single differences are not identified.
It does not apply for the drift models where <code>model.design</code> is &quot;Ad&quot;, &quot;Pd&quot;, &quot;Cd&quot;, &quot;t&quot; because it is not clear which time scale the second linear trend should be attributed to.
It is not implemented for <code>model.design</code> of &quot;tA, &quot;tP&quot;, &quot;tC&quot;, &quot;1&quot;.
The first row of plots are single differences of the time effects.
The next two rows of plots illustrate the representation theorem.  In the second row the level is given and in
the third row plots of single sums of single differences are given, normalised to start in zero.
</p>
<p><b>Appearance may vary.</b>
Note, the plots &quot;detrend&quot; and &quot;dif&quot; can give very different appearance of the time effects. The &quot;dif&quot; plots are dominated by
linear trends.  They can therefore be more difficult to interpret than the &quot;detrend&quot; plots, where linear trends are set aside.
</p>
<p><b>Standard deviations.</b>
All plots include plots of 1 and 2 standard deviations.  The only exception is the intercept in the case 
<code>model.family</code> is &quot;poisson.response&quot; as this uses a multinomial sampling scheme, where the intercept is set to increase
in the asymptotic experiment.  The default is to plot standard deviations around zero, so that they represent
a test for zero values of the parameters.
Using the argument <code>sdv.at.zero</code> the standard deviations can be centered around the estimates. This can give a
very complicated appearance.
</p>
<p><b>Values of coefficients.</b>
These can be found using
<code><a href="#topic+apc.identify">apc.identify</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>new.apc.plot.fit(apc.fit.model,scale=FALSE,
					sdv.at.zero=TRUE,type="detrend",
					include.linear.plane=TRUE,
					include.double.differences=TRUE,
					sub.plot=NULL,main.outer=NULL,main.sub=NULL,
					cex=NULL,cex.axis=NULL,cex.lab=NULL,cex.main=NULL,
					cex.main.outer=1.2,
					line.main=0.5,line.main.outer=NULL,
					mar=NULL,oma=NULL,mgp=c(2,1,0))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="new.apc.plot.fit_+3A_apc.fit.model">apc.fit.model</code></td>
<td>
<p>List. See <code><a href="#topic+apc.fit.model">apc.fit.model</a></code> for a description of the format.</p>
</td></tr>
<tr><td><code id="new.apc.plot.fit_+3A_scale">scale</code></td>
<td>
<p>Optional. Logical. If (TRUE) FALSE use scale of (inverse) link function.  Default is FALSE.</p>
</td></tr>
<tr><td><code id="new.apc.plot.fit_+3A_sdv.at.zero">sdv.at.zero</code></td>
<td>
<p>Optional. Logical. If FALSE/TRUE standard deviations are plotted around estimates/zero.  Default is TRUE.</p>
</td></tr>
<tr><td><code id="new.apc.plot.fit_+3A_type">type</code></td>
<td>
<p>Optional.  Character.  If &quot;detrend&quot; double sums start and end in zero.  If &quot;sum.sum&quot; double sums anchored as discussed in Nielsen (??). Default is &quot;detrend&quot;.</p>
</td></tr>
<tr><td><code id="new.apc.plot.fit_+3A_include.linear.plane">include.linear.plane</code></td>
<td>
<p>Optional. Logical. If true include plots of linear plane. Default TRUE</p>
</td></tr>
<tr><td><code id="new.apc.plot.fit_+3A_include.double.differences">include.double.differences</code></td>
<td>
<p>Optional. Logical. If true include plots of double differences. Default TRUE</p>
</td></tr>
<tr><td><code id="new.apc.plot.fit_+3A_sub.plot">sub.plot</code></td>
<td>
<p>Optional.  Character: &quot;a&quot;,&quot;b&quot;,...,&quot;i&quot;.  Only the indicated sub plot is plotted. Default is NULL so all plots shown.</p>
</td></tr>
<tr><td><code id="new.apc.plot.fit_+3A_main.outer">main.outer</code></td>
<td>
<p>Optional.  Character.  Main title in outer margin.  Default is generated internally.</p>
</td></tr>
<tr><td><code id="new.apc.plot.fit_+3A_main.sub">main.sub</code></td>
<td>
<p>Optional.  Vector of 9 characters.  Main titles for individual plots. Default is generated internally, see note 3 below.</p>
</td></tr>
<tr><td><code id="new.apc.plot.fit_+3A_cex">cex</code></td>
<td>
<p>Optional.  Plot parameter, see <code><a href="graphics.html#topic+par">par</a></code>. Controls size of text. Default is NULL so that R default is used.</p>
</td></tr>
<tr><td><code id="new.apc.plot.fit_+3A_cex.axis">cex.axis</code></td>
<td>
<p>Optional.  Plot parameter, see <code><a href="graphics.html#topic+par">par</a></code>. Controls magnification of axis annotations. Default is NULL so that R default is used.</p>
</td></tr>
<tr><td><code id="new.apc.plot.fit_+3A_cex.lab">cex.lab</code></td>
<td>
<p>Optional.	Plot parameter, see <code><a href="graphics.html#topic+par">par</a></code>. Controls magnification of axis labels. Default is NULL so that R default is used.</p>
</td></tr>
<tr><td><code id="new.apc.plot.fit_+3A_cex.main">cex.main</code></td>
<td>
<p>Optional.  Plot parameter, see <code><a href="graphics.html#topic+par">par</a></code>. Controls magnification of main title. Default is NULL so that R default is used.</p>
</td></tr>
<tr><td><code id="new.apc.plot.fit_+3A_cex.main.outer">cex.main.outer</code></td>
<td>
<p>Optional.  Controls magnification of outer main title if an array of plots is shown. Default is 1.2 (same as cex.main).</p>
</td></tr>
<tr><td><code id="new.apc.plot.fit_+3A_line.main">line.main</code></td>
<td>
<p>Optional. Specifies the line position of main title in individual plots. Default is 0.5.</p>
</td></tr>
<tr><td><code id="new.apc.plot.fit_+3A_line.main.outer">line.main.outer</code></td>
<td>
<p>Optional. Specifies the line position of outer main title if an array of plots is shown. Default is NULL so that R default is used.</p>
</td></tr>
<tr><td><code id="new.apc.plot.fit_+3A_mar">mar</code></td>
<td>
<p>Optional. Gives the number of lines of margin to be specified on the four sides of the plot. Default: <code>c(4,3,2,0)</code> for array of plots, <code>c(4,4,3,1)</code> for a single plot.</p>
</td></tr>
<tr><td><code id="new.apc.plot.fit_+3A_oma">oma</code></td>
<td>
<p>Optional. Gives the size of the outer margins in lines of text. Default: <code>c(0,0,5,1)</code> for array of plots, <code>c(0,0,0,0)</code> for a single plot.</p>
</td></tr>
<tr><td><code id="new.apc.plot.fit_+3A_mgp">mgp</code></td>
<td>
<p>Optional.  Plot parameter, see <code><a href="graphics.html#topic+par">par</a></code>. The margin line for the axis title, axis label and axis line. Defauls is <code>c(2,1,0)</code>, different from R default.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>(1)
The type &quot;sum.sum&quot; (same as &quot;ss.dd&quot;) gives double sums anchored 
to be zero in the three points where
<code>age=cohort=U</code>,
<code>age=U+1,cohort=U</code>
<code>age=U,cohort=U+1</code>
with
<code>apc.fit.model$U</code>
and where
<code>U</code>
is the integer value of
<code>(per.zero+3)/2</code>
This corresponds to the representation in
Nielsen (2014b).
The linear plane is parametrised in terms of 
a level, which is the value of the predictor at
<code>age=cohort=U</code>;
an age slope, which is the difference of the values of the predictor at
<code>age=U+1,cohort=U</code>
and 
<code>age=cohort=U</code>;
an cohort slope, which is the difference of the values of the predictor at
<code>age=U,cohort=U+1</code>
and 
<code>age=cohort=U</code>.
</p>
<p>(2)
The type &quot;detrend&quot; gives double sums that start in zero and end in zero.
The linear plane is parametrised in terms of
a level, which is the value of the predictor at 
<code>age=cohort=1</code>, which is usually outside the index set for the data;
while age and cohort slopes are adjusted for the ad hoc identification of the time effects.
</p>
<p>(3)
The default of the titles <code>main.sub</code> are generated internally depending on model specification.
In the case of <code>model.design="APC"</code> and a dose-response model family the default value is
<code>c(expression(paste("(a) ",Delta^2,alpha)), 
expression(paste("(b) ",Delta^2,beta)),  
expression(paste("(c) ",Delta^2,gamma)), 
"(d)  first linear trend",
"(e)  level",
"(f)  second linear trend",
expression(paste("(g) detrended ",Sigma^2,Delta^2,alpha)),
expression(paste("(h) detrended ",Sigma^2,Delta^2,beta)),
expression(paste("(i) detrended ",Sigma^2,Delta^2,gamma)))</code>
</p>
<p>(4)
Default values of parameters changed (25 Sep 2020).
The old appearance can be reproduced by	setting <code>cex.lab=1.5</code>. For example:
</p>
<p><code>data.list	&lt;- data.Italian.bladder.cancer()</code>
</p>
<p><code>fit.apc &lt;- apc.fit.model(data.list,"poisson.dose.response","APC")</code>
</p>
<p><code>apc.plot.fit(fit.apc,cex.lab=1.5)</code>
</p>


<h3>Author(s)</h3>

<p>Bent Nielsen &lt;bent.nielsen@nuffield.ox.ac.uk&gt; 12 Apr 2015 updated 24 September 2020 vs 2.0.0. Subsumes <code>var.apc.plot.fit</code> by Zoe Fannon.</p>


<h3>References</h3>

<p>Kuang, D., Nielsen, B. and Nielsen, J.P. (2008a) Identification of the age-period-cohort model and the extended chain ladder model. Biometrika 95, 979-986. <em>Download</em>: <a href="https://doi.org/10.1093/biomet/asn026">Article</a>; Earlier version <a href="http://www.nuffield.ox.ac.uk/economics/papers/2007/w5/KuangNielsenNielsen07.pdf">Nuffield DP</a>.
</p>
<p>Nielsen, B. (2014b) Deviance analysis of age-period-cohort models. Work in progress.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+data.asbestos">data.asbestos</a></code>
and
<code><a href="#topic+data.Italian.bladder.cancer">data.Italian.bladder.cancer</a></code> for information on the data used in the example.
</p>
<p>Values of coefficients can be found using <code><a href="#topic+apc.identify">apc.identify</a></code>.
</p>
<p>Further information on the identification in the vignette
<a href="../doc/Identification.pdf"><code>Identification.pdf</code></a>,
<a href="../doc/Identification.R"><code>Identification.R</code></a>
on
<a href="../doc/index.html"><code>Vignettes</code></a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#####################
#	Example with Italian bladder cancer data
#	Note that the model.design "AC" cannot be rejected against "APC"
#		so there is little difference between the two plots of those fits.

data.list	&lt;- data.Italian.bladder.cancer()
apc.fit.table(data.list,"poisson.dose.response")
fit.apc		&lt;- apc.fit.model(data.list,"poisson.dose.response","APC")
new.apc.plot.fit(fit.apc)
#	now try an AC model
#	can use dev.new() to see both
fit.ac		&lt;- apc.fit.model(data.list,"poisson.dose.response","AC")
new.apc.plot.fit(fit.ac)

#	to check the numerical values for the last two rows of plots use
new.apc.identify(fit.ac)$coefficients.detrend

#	to get only a sub plot and playing with titles
#	main.outer not used with individual plot
new.apc.plot.fit(fit.ac,sub.plot="a",main.outer="My outer title",main.sub="My sub title")
#	to get only a all plots and playing with titles
new.apc.plot.fit(fit.ac,main.outer="My outer title",main.sub=c("1","2","3","4","5","6","7","8","9"))
</code></pre>

<hr>
<h2 id='triangle'>Triangular matrices used in reserving</h2><span id='topic+is.triangle'></span><span id='topic+triangle.cumulative'></span><span id='topic+triangle.incremental'></span><span id='topic+vector.2.triangle'></span>

<h3>Description</h3>

<p>Triangular matrices are used for reserving in general insurance. 
A matrix is triangular if it is square and it has NAs in lower triangle where row+col&gt;dim.
The <code>apc</code> package uses incremental triangles. 
</p>
<p>The function <code>is.triangle</code> tests if an object is a triangular matrix.
</p>
<p>The function <code>triangle.cumulative</code> forms the cumulative version of an incremental matrix
by taking partial sums in each row.
</p>
<p>The function <code>triangle.incremental</code> forms the incremental version of an cumulative matrix
by taking differences in each row.
</p>
<p>The function <code>vector.2.triangle</code> turns a k*(k+1)/2 vector into a triangular matrix of
dimension k.</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.triangle(m)
triangle.cumulative(m)
triangle.incremental(m)
vector.2.triangle(v,k)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="triangle_+3A_v">v</code></td>
<td>
<p>vector. Length k*(k+1)/2</p>
</td></tr>
<tr><td><code id="triangle_+3A_k">k</code></td>
<td>
<p>integer. Dimension</p>
</td></tr>
<tr><td><code id="triangle_+3A_m">m</code></td>
<td>
<p>matrix.  Square matrix</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Bent Nielsen &lt;bent.nielsen@nuffield.ox.ac.uk&gt; 21 Nov 2019 (7 Feb 2015)</p>


<h3>Examples</h3>

<pre><code class='language-R'>#########################

m &lt;- vector.2.triangle(1:10,4)
m
is.triangle(m)
triangle.cumulative(m)
triangle.incremental(m)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
