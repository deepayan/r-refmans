<!DOCTYPE html><html><head><title>Help for package BVSNLP</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {BVSNLP}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#bvs'><p>High dimensional Bayesian variable selection using nonlocal priors</p></a></li>
<li><a href='#CoefEst'><p>Coefficient estimation for a specific set of covariates</p></a></li>
<li><a href='#cox_bvs'><p>Non-parallel version of Bayesian variable selector for survival data using</p>
nonlocal priors</a></li>
<li><a href='#HyperSelect'><p>Hyperparameter selection for iMOM prior density</p></a></li>
<li><a href='#logreg_bvs'><p>Non-parallel version of Bayesian variable selector for logistic regression</p>
data using nonlocal priors</a></li>
<li><a href='#ModProb'><p>Logarithm of unnormalized probability of a given model</p></a></li>
<li><a href='#predBMA'><p>Predictive accuracy measurement using Bayesian Model Averaging</p></a></li>
<li><a href='#PreProcess'><p>Preprocessing the design matrix, preparing it for variable selection</p>
procedure</a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Bayesian Variable Selection in High Dimensional Settings using
Nonlocal Priors</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1.9</td>
</tr>
<tr>
<td>Author:</td>
<td>Amir Nikooienejad [aut, cre], Valen E. Johnson [ths]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Amir Nikooienejad &lt;amir.nikooienejad@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Variable/Feature selection in high or ultra-high dimensional
    settings has gained a lot of attention recently specially in cancer genomic
    studies. This package provides a Bayesian approach to tackle this problem,
    where it exploits mixture of point masses at zero and nonlocal priors to
    improve the performance of variable selection and coefficient estimation.
    product moment (pMOM) and product inverse moment (piMOM) nonlocal priors
    are implemented and can be used for the analyses. This package performs
    variable selection for binary response and survival time response datasets
    which are widely used in biostatistic and bioinformatics community.
    Benefiting from parallel computing ability, it reports necessary outcomes
    of Bayesian variable selection such as Highest Posterior Probability Model
    (HPPM), Median Probability Model (MPM) and posterior inclusion probability
    for each of the covariates in the model. The option to use Bayesian Model
    Averaging (BMA) is also part of this package that can be exploited for
    predictive power measurements in real datasets.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.1.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp, doParallel, foreach, parallel</td>
</tr>
<tr>
<td>Suggests:</td>
<td>doMPI</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo, RcppEigen, RcppNumerical</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2020-08-28 03:03:10 UTC; AmirNik</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2020-08-28 17:00:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='bvs'>High dimensional Bayesian variable selection using nonlocal priors</h2><span id='topic+bvs'></span>

<h3>Description</h3>

<p>This function performs Bayesian variable selection for high
dimensional design matrix using iMOM prior for non-zero coefficients. It
also performs adaptive hyperparameter selection for iMOM prior. Cleaning
the data in a preprocessing step and before any data analysis is done by
user preference. This function is for binary and survival time response
datasets. In the former, MCMC is used to search in the model space while for
the latter a stochastic search does that job. This function has the option
to do all the mentioned tasks in a parallel fashion, exploiting hundreds of
CPUs. It is highly recommended to use a cluster for this purpose. This
function also supports fixing covariates in variable selection process,
thus making them included in the final selected model with probability 1.
Categorical variable are also supported by this function as input covariates
to the selection process. They need to be well defined factor variables as
part of the input data frame. For the output, this function reports
necessary measurements that is common in Bayesian variable selection
algorithms. They include Highest Posterior Probability model, median
probability model and posterior inclusion probability for each of the
covariates in the design matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bvs(
  X,
  resp,
  prep = TRUE,
  logT = FALSE,
  fixed_cols = NULL,
  eff_size = 0.5,
  family = c("logistic", "survival"),
  hselect = TRUE,
  nlptype = "piMOM",
  r = 1,
  tau = 0.25,
  niter = 30,
  mod_prior = c("unif", "beta"),
  inseed = NULL,
  cplng = FALSE,
  ncpu = 4,
  parallel.MPI = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bvs_+3A_x">X</code></td>
<td>
<p>The <code>n</code> times <code>p</code> input data frame containing the
covariates in the design matrix. The columns should represent genes and rows
represent the observed samples. The column names are used as gene names so
they should not be left as <code>NULL</code>. Moreover, the minimum number of
columns allowed is 3. The input data frame can also contain categorical
covariates that are appropriately defined as factor variables in R.</p>
</td></tr>
<tr><td><code id="bvs_+3A_resp">resp</code></td>
<td>
<p>For logistic regression models it is the binary response
vector which could be either numeric or factor variable in R. For the Cox
proportional hazard models this is a two column matrix where the first
column contains survival time vector and the second column is the censoring
status for each observation.</p>
</td></tr>
<tr><td><code id="bvs_+3A_prep">prep</code></td>
<td>
<p>A boolean variable determining if the preprocessing step should
be performed on the design matrix or not. That step contains removing
columns that have <code>NA</code>'s or all their elements are equal to 0, along
with standardizing non-binary columns. This step is recommended and thus the
default value is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="bvs_+3A_logt">logT</code></td>
<td>
<p>A boolean variable determining if log transform should be done
on continuous columns before scaling them in the preprocessing step.
Note that those columns should not contain any zeros or negative values.</p>
</td></tr>
<tr><td><code id="bvs_+3A_fixed_cols">fixed_cols</code></td>
<td>
<p>A vector of indices showing the columns in the input
data frame that are not subject to the the selection procedure. These
columns are always in the final selected model. Note that if any of these
columns contain <code>NA</code>, they will be removed. Moreover, if a categorical
variable with <code>k</code> levels is chosen to be fixed, all <code>k-1</code> dummy
variables associated with it will be selected in the final model.</p>
</td></tr>
<tr><td><code id="bvs_+3A_eff_size">eff_size</code></td>
<td>
<p>This is the expected effect size in the model for a
standardized design matrix, which is basically the coefficient value that is
expected to occur the most based on some prior knowledge.</p>
</td></tr>
<tr><td><code id="bvs_+3A_family">family</code></td>
<td>
<p>Determines the type of data analysis. <code>logistic</code> is for
binary outcome data where logistic regression modeling is used, whereas
<code>survival</code> is for survival outcome data using Cox proportional
hazard model.</p>
</td></tr>
<tr><td><code id="bvs_+3A_hselect">hselect</code></td>
<td>
<p>A boolean variable indicating whether the automatic procedure
for hyperparameter selection should be run or not. The default value is
<code>TRUE</code>. Note that in this setting, <code>r</code> is always chosen to be 1.</p>
</td></tr>
<tr><td><code id="bvs_+3A_nlptype">nlptype</code></td>
<td>
<p>Determines the type of nonlocal prior that is used in the
analyses. It can be &quot;piMOM&quot; for product inverse moment prior, or &quot;pMOM&quot; for
product moment prior. The default is set to piMOM prior.</p>
</td></tr>
<tr><td><code id="bvs_+3A_r">r</code></td>
<td>
<p>The paramter <code>r</code> of the iMOM prior, when no automatic
procedure for hyperparameter selection is done. As a result, this is
relevant only when <code>hselect = FALSE</code>, otherwise it is ignored.</p>
</td></tr>
<tr><td><code id="bvs_+3A_tau">tau</code></td>
<td>
<p>The paramter <code>tau</code> of the iMOM prior, when no automatic
procedure for hyperparameter selection is done. As a result, this is
relevant only when <code>hselect = FALSE</code>, otherwise it is ignored.</p>
</td></tr>
<tr><td><code id="bvs_+3A_niter">niter</code></td>
<td>
<p>Number of iterations. For binary response data, this
determines the number of MCMC iterations per CPU. For survival response data
this is the number of iterations per temperature schedule in the stochastic
search algorithm.</p>
</td></tr>
<tr><td><code id="bvs_+3A_mod_prior">mod_prior</code></td>
<td>
<p>Type of prior used for the model space. <code>unif</code> is
for a uniform binomial and <code>beta</code> is for a beta binomial prior. In the
former case, both hyper parameters in the beta prior are equal to <code>1</code>,
but in the latter case those two hyper parameters are chosen as explained in
the reference papers. The default choice for this variable is the uniform
prior.</p>
</td></tr>
<tr><td><code id="bvs_+3A_inseed">inseed</code></td>
<td>
<p>The input seed for making the parallel processing
reproducible. This parameter is ignored in logistic regression models when
<code>cplng = FALSE</code>. The default value is <code>NULL</code> which means that each
time the search for model space is started from different starting points.
In case it is set to a number, it initializes the RNG for the first task and
subsequent tasks to get separate substreams.</p>
</td></tr>
<tr><td><code id="bvs_+3A_cplng">cplng</code></td>
<td>
<p>This parameter is only used in logistic regression models, and
indicating if coupling algorithm for MCMC output should be performed or not.</p>
</td></tr>
<tr><td><code id="bvs_+3A_ncpu">ncpu</code></td>
<td>
<p>This is the number of cpus used in parallel processing. For
logistic regression models this is the number of parallel coupled chains
run at the same time. For survival outcome data this is the number of cpus
doing stochastic search at the same time to increase th enumber of visited
models.</p>
</td></tr>
<tr><td><code id="bvs_+3A_parallel.mpi">parallel.MPI</code></td>
<td>
<p>A boolean variable determining if MPI is used for
parallel processing or not. Note that in order to use this feature, your
system should support MPI and <code>Rmpi</code> and <code>doMPI</code> packages should
already be installed. The default is set to <code>FALSE</code> but in case your
system have the requirements, it is recommended to set this parameter to
<code>TRUE</code> as it is more efficient and results in faster run-time.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>It returns a list containing different objects that depend on the
family of the model and the coupling flag for logistic regression models.
The following describes the objects in the output list based on different
combinations of those two input arguments.<br /> <br />
<strong>1) </strong> <code>family = logistic &amp;&amp; cplng = FALSE</code>
</p>
<table>
<tr><td><code>num_vis_models</code></td>
<td>
<p>Number of unique models visited throughout the search
of the model space.</p>
</td></tr>
<tr><td><code>max_prob</code></td>
<td>
<p>Maximum unnormalized probability among all visited models</p>
</td></tr>
<tr><td><code>HPM</code></td>
<td>
<p>The indices of the model with highest posterior
probability among all visited models, with respect to the columns in
the output <code>des_mat</code>. This is not necessarily the same as the input
design matrix due to some changes to categorical variables. The names of
the selected columns can be checked using <code>gene_names</code>.
The corresponding design matrix is also one of the outputs that can be
checked in <code>des_mat</code>. If the output is <code>character[0]</code> it means
none of the variables of the design matrix is selected in the HPM and
HPM contains only the intercept.</p>
</td></tr>
<tr><td><code>beta_hat</code></td>
<td>
<p>The coefficient vector for the selected model. The first
component is always for the intercept.</p>
</td></tr>
<tr><td><code>MPM</code></td>
<td>
<p>The indices of median probability model. According to the paper
Barbieri et. al., this is defined to be the model consisting of those
variables whose posterior inclusion probability is at least 1/2. The order
of columns is similar to that is explained for <code>HPM</code>.</p>
</td></tr>
<tr><td><code>max_prob_vec</code></td>
<td>
<p>A <code>1000</code> by <code>1</code> vector of unnormalized
probabilities of the first 1000 models with highest posterior probability
among all visited models. If the total number of visited models is less than
1000, then the length of this vector would be equal to <code>num_vis_models</code>
. Note that the intercept is always used in calculating the probabilities
in this vector.</p>
</td></tr>
<tr><td><code>max_models</code></td>
<td>
<p>A list containing models corresponding to
<code>max_prob_vec</code> vector. Each entry of this list contains the indices of
covariates for the model with posterior probability reported in the
corresponding entry in <code>max_prob_vec</code>. The intercept column is not
shown in this list as it is present in all of the models.</p>
</td></tr>
<tr><td><code>inc_probs</code></td>
<td>
<p>A vector of length <code>p+1</code> containing the posterior
inclusion probability for each covariate in the design matrix. The order of
columns is with respect to processed design matrix, <code>des_mat</code>.</p>
</td></tr>
<tr><td><code>nlptype</code></td>
<td>
<p>The type of nonlocal prior used in the analyses.</p>
</td></tr>
<tr><td><code>des_mat</code></td>
<td>
<p>The design matrix used in the analysis where fixed columns
are moved to the beginning of the matrix and if <code>prep=TRUE</code>, the
columns containing <code>NA</code> are all removed. The reported indices in
selected models are all with respect to the columns of this matrix.</p>
</td></tr>
<tr><td><code>gene_names</code></td>
<td>
<p>Names of the genes extracted from the design matrix.</p>
</td></tr>
<tr><td><code>r</code></td>
<td>
<p>The hyperparameter for iMOM prior density function, calculated
using the proposed algorithm for the given dataset.</p>
</td></tr>
<tr><td><code>tau</code></td>
<td>
<p>The hyperparameter for iMOM prior density function, calculated
using the proposed algorithm for the given dataset.</p>
</td></tr>
</table>
<p><strong>2) </strong> <code>family = logistic &amp;&amp; cplng = TRUE</code>
</p>
<table>
<tr><td><code>cpl_percent</code></td>
<td>
<p>Shows what percentage of pairs of chains are coupled.</p>
</td></tr>
<tr><td><code>margin_probs</code></td>
<td>
<p>A <code>k</code> by <code>1</code> vector of marginal probabilities
where element <code>i</code> shows the maximum marginal probability of the
data under the maximum model for the <code class="reqn">i^{th}</code> pair of chains. <code>k</code>
is the number of paired chains which is the same as number of CPUs.</p>
</td></tr>
<tr><td><code>chains</code></td>
<td>
<p>A <code>k</code> by <code>p</code> binary matrix, where each row is the
model for the <code class="reqn">i^{th}</code> pair of chains. Note that the index of nonzero
elements are not necessarily in the same order as the input design matrix,
<code>X</code>, depending on existence of fixed columns in selection procedure.
As a result, always match the indices to the columns of the design matrix
that is reported as an output in <code>des_mat</code>.</p>
</td></tr>
<tr><td><code>nlptype</code></td>
<td>
<p>The type of nonlocal prior used in the analyses.</p>
</td></tr>
<tr><td><code>cpl_flags</code></td>
<td>
<p>A <code>k</code> by <code>1</code> binary vector, showing which pairs
are coupled, (=<code>1</code>) and which are not, (= <code>0</code>).</p>
</td></tr>
<tr><td><code>beta_hat</code></td>
<td>
<p>A <code>k</code> by <code>(p+1)</code> matrix where each row is the
estimated coefficient for each modelin the rows of <code>Chains</code> variable.</p>
</td></tr>
<tr><td><code>uniq_models</code></td>
<td>
<p>A list showing unique models with the indices of the
included covariates at each model.</p>
</td></tr>
<tr><td><code>freq</code></td>
<td>
<p>Frequency of each of the unique models. It is used to find
the highest frquency model.</p>
</td></tr>
<tr><td><code>probs</code></td>
<td>
<p>Unnormalized probability of each of the unique models.</p>
</td></tr>
<tr><td><code>des_mat</code></td>
<td>
<p>The design matrix used in the analysis where fixed columns
are moved to the beginning of the matrix and if <code>prep=TRUE</code>, the
columns containing <code>NA</code> are all removed. The reported indices in
selected models are all with respect to the columns of this matrix.</p>
</td></tr>
<tr><td><code>gene_names</code></td>
<td>
<p>Names of the genes extracted from the design matrix.</p>
</td></tr>
<tr><td><code>r</code></td>
<td>
<p>The hyperparameter for iMOM prior density function, calculated
using the proposed algorithm for the given dataset.</p>
</td></tr>
<tr><td><code>tau</code></td>
<td>
<p>The hyperparameter for iMOM prior density function, calculated
using the proposed algorithm for the given dataset.</p>
</td></tr>
</table>
<p><strong>3) </strong> <code>family = survival</code>
</p>
<table>
<tr><td><code>num_vis_models</code></td>
<td>
<p>Number of visited models during the whole process.</p>
</td></tr>
<tr><td><code>max_prob</code></td>
<td>
<p>The unnormalized probability of the maximum model among
all visited models.</p>
</td></tr>
<tr><td><code>HPM</code></td>
<td>
<p>The indices of the model with highest posterior
probability among all visited models, with respect to the columns in
<code>des_mat</code>. As a result, always look at the names of the selected
columns using <code>gene_names</code>. The corresponding design matrix is one of
the outputs that can be checked in <code>des_mat</code>.</p>
</td></tr>
<tr><td><code>MPM</code></td>
<td>
<p>The indices of median probability model. According to the paper
Barbieri et. al., this is defined to be the model consisting of those
variables whose posterior inclusion probability is at least 1/2. The order
of columns is similar to that is explained for <code>HPM</code>.</p>
</td></tr>
<tr><td><code>beta_hat</code></td>
<td>
<p>The coefficient vector for the selected model reported in
<code>HPM</code>.</p>
</td></tr>
<tr><td><code>max_prob_vec</code></td>
<td>
<p>A <code>1000</code> by <code>1</code> vector of unnormalized
probabilities of the first 1000 models with highest posterior probability
among all visited models. If the total number of visited models is less than
1000, then the length of this vector would be equal to <code>num_vis_models</code>
.</p>
</td></tr>
<tr><td><code>max_models</code></td>
<td>
<p>A list containing models corresponding to
<code>max_prob_vec</code> vector. Each entry of this list contains the indices of
covariates for the model with posterior probability reported in the
corresponding entry in <code>max_prob_vec</code>.</p>
</td></tr>
<tr><td><code>inc_probs</code></td>
<td>
<p>A <code>p</code> by <code>1</code> vector containing the posterior
inclusion probability for each covariate in the design matrix. The order of
columns is with respect to processed design matrix, <code>des_mat</code>.</p>
</td></tr>
<tr><td><code>nlptype</code></td>
<td>
<p>The type of nonlocal prior used in the analyses.</p>
</td></tr>
<tr><td><code>des_mat</code></td>
<td>
<p>The design matrix used in the analysis where fixed columns
are moved to the beginning of the matrix and if <code>prep=TRUE</code>, the
columns containing <code>NA</code> are all removed. The reported indices in
selected models are all with respect to the columns of this matrix.</p>
</td></tr>
<tr><td><code>start_models</code></td>
<td>
<p>A <code>k</code> by <code>3</code> matrix showing the starting model
for each worker CPU. Obviously <code>k</code> is equal to the number of CPUs.</p>
</td></tr>
<tr><td><code>gene_names</code></td>
<td>
<p>Names of the genes extracted from the design matrix.</p>
</td></tr>
<tr><td><code>r</code></td>
<td>
<p>The hyperparameter for iMOM prior density function, calculated
using the proposed algorithm for the given dataset.</p>
</td></tr>
<tr><td><code>tau</code></td>
<td>
<p>The hyperparameter for iMOM prior density function, calculated
using the proposed algorithm for the given dataset.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Amir Nikooienejad
</p>


<h3>References</h3>

<p>Nikooienejad, A., Wang, W., and Johnson, V. E. (2016). Bayesian
variable selection for binary outcomes in high dimensional genomic studies
using nonlocal priors. Bioinformatics, 32(9), 1338-1345.<br /><br />
Nikooienejad, A., Wang, W., &amp; Johnson, V. E. (2020). Bayesian variable
selection for survival data using inverse moment priors. Annals of Applied
Statistics, 14(2), 809-828. <br /><br />
Johnson, V. E. (1998). A coupling-regeneration scheme for
diagnosing convergence in Markov chain Monte Carlo algorithms. Journal of
the American Statistical Association, 93(441), 238-248.<br /><br />
Shin, M., Bhattacharya, A., and Johnson, V. E. (2017). Scalable Bayesian
variable selection using nonlocal prior densities in ultrahigh dimensional
settings. Statistica Sinica.<br /><br />
Johnson, V. E., and Rossell, D. (2010). On the use of non-local prior
densities in Bayesian hypothesis tests. Journal of the Royal Statistical
Society: Series B (Statistical Methodology), 72(2), 143-170.<br /><br />
Barbieri, M. M., and Berger, J. O. (2004). Optimal predictive model
selection. The annals of statistics, 32(3), 870-897.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ModProb">ModProb</a></code>, <code><a href="#topic+CoefEst">CoefEst</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### Simulating Logistic Regression Data
n &lt;- 200
p &lt;- 40
set.seed(123)
Sigma &lt;- diag(p)
full &lt;- matrix(c(rep(0.5, p*p)), ncol=p)
Sigma &lt;- full + 0.5*Sigma
cholS &lt;- chol(Sigma)
Beta &lt;- c(-1.9,1.3,2.2)
X &lt;- matrix(rnorm(n*p), ncol=p)
X &lt;- X%*%cholS
beta &lt;- numeric(p)
beta[c(1:length(Beta))] &lt;- Beta
XB &lt;- X%*%beta
probs &lt;- as.vector(exp(XB)/(1+exp(XB)))
y &lt;- rbinom(n,1,probs)
colnames(X) &lt;- paste("gene_",c(1:p),sep="")
X &lt;- as.data.frame(X)

### Running 'bvs' function without coupling and with hyperparamter selection
### procedure
bout &lt;- bvs(X, y, family = "logistic", nlptype = "piMOM",
            mod_prior = "beta", niter = 50)
            
### Highest Posterior Model
bout$HPM

### Estimated Coefficients:
bout$beta_hat

### Number of Visited Models:
bout$num_vis_models
</code></pre>

<hr>
<h2 id='CoefEst'>Coefficient estimation for a specific set of covariates</h2><span id='topic+CoefEst'></span>

<h3>Description</h3>

<p>This function estimates coefficient vector for a given set of
covariates in a logistic regression and Cox proportional hazard models. It
uses the inverse moment nonlocal prior (iMOM) for non zero coefficients.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CoefEst(
  X,
  resp,
  mod_cols,
  nlptype = "piMOM",
  tau,
  r,
  family = c("logistic", "survival")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CoefEst_+3A_x">X</code></td>
<td>
<p>The design matrix. It is assumed that the preprocessing steps have
been done on this matrix. It is recommended that to use the output of
<code><a href="#topic+PreProcess">PreProcess</a></code> function of the package. Also note that the
<code>X</code> should NOT have a vector of $1$'s as the first column. If the
coefficients of a selected model by <code><a href="#topic+bvs">bvs</a></code> is to be estimated, it
is highly recommended that the design matrix that is one of the outputs of
the <code>bvs</code> function and is reported as <code>des_mat</code> to be used here.</p>
</td></tr>
<tr><td><code id="CoefEst_+3A_resp">resp</code></td>
<td>
<p>For logistic regression models, this variable is the binary
response vector. For Cox proportional hazard models this is a two column
matrix where the first column contains the survival time vector and the
second column is the censoring status for each observation.</p>
</td></tr>
<tr><td><code id="CoefEst_+3A_mod_cols">mod_cols</code></td>
<td>
<p>A vector of column indices of the design matrix,
representing the selected model.</p>
</td></tr>
<tr><td><code id="CoefEst_+3A_nlptype">nlptype</code></td>
<td>
<p>Determines the type of nonlocal prior that is used in the
analyses. It can be &quot;piMOM&quot; for product inverse moment prior, or &quot;pMOM&quot; for
product moment prior. The default is set to piMOM prior.</p>
</td></tr>
<tr><td><code id="CoefEst_+3A_tau">tau</code></td>
<td>
<p>Hyperparameter <code>tau</code> of the iMOM prior.</p>
</td></tr>
<tr><td><code id="CoefEst_+3A_r">r</code></td>
<td>
<p>Hyperparameter <code>r</code> of the iMOM prior.</p>
</td></tr>
<tr><td><code id="CoefEst_+3A_family">family</code></td>
<td>
<p>Determines the type of data analysis. <code>logistic</code> is for
binary outcome and logistic regression model whereas,
<code>survival</code> represents survival outcomes and the Cox proportional
hazard model.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>It returns the vector of coefficients for the given model.
</p>


<h3>Author(s)</h3>

<p>Amir Nikooienejad
</p>


<h3>References</h3>

<p>Nikooienejad, A., Wang, W., and Johnson, V. E. (2016). Bayesian
variable selection for binary outcomes in high dimensional genomic studies
using non-local priors. Bioinformatics, 32(9), 1338-1345.<br /><br />
Nikooienejad, A., Wang, W., &amp; Johnson, V. E. (2020). Bayesian variable
selection for survival data using inverse moment priors. Annals of Applied
Statistics, 14(2), 809-828.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ModProb">ModProb</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### Simulating Survival Data
n &lt;- 400
p &lt;- 1000
lambda &lt;- 0.8
cens_rate &lt;- 0.27
set.seed(123)
Sigma &lt;- diag(p)
full &lt;- matrix(c(rep(0.5, p*p)), ncol=p)
Sigma &lt;- full + 0.5*Sigma
cholS &lt;- chol(Sigma)
Beta &lt;- c(-1.8, 1.2, -1.7, 1.4, -1.4, 1.3)
X = matrix(rnorm(n*p), ncol=p)
X = X%*%cholS
X &lt;- scale(X)
beta &lt;- numeric(p)
beta[c(1:length(Beta))] &lt;- Beta
XB &lt;- X%*%beta
uvector &lt;- -log(runif(n));
times &lt;- uvector/(lambda*exp(XB))
cens_time &lt;- quantile(times,1-cens_rate)
status &lt;- as.numeric(times &lt; cens_time)
TS &lt;- cbind(times,status)

### Estimating coeffcients of the true model and an arbitrary hyper
### parameter for the iMOM prior density
mod &lt;- c(1:6)
coef &lt;- CoefEst(X, TS, mod, tau = 1.8, r = 2, family = "survival")
coef

</code></pre>

<hr>
<h2 id='cox_bvs'>Non-parallel version of Bayesian variable selector for survival data using
nonlocal priors</h2><span id='topic+cox_bvs'></span>

<h3>Description</h3>

<p>This function performs Bayesian variable selection for
survival data in a non-parallel fashion. It runs modified S5 algorithm to
search the model space but since this is only on one CPU, the number of
visited models will not be large and therefore is NOT recommended for
high dimensional datasets. This function is called by <code><a href="#topic+bvs">bvs</a></code>
function in a parllel fashion and therefore that function is recommended
to be used.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cox_bvs(exmat, cur_cols, nf, tau, r, nlptype, a, b, d, L, J, temps)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cox_bvs_+3A_exmat">exmat</code></td>
<td>
<p>An extended matrix where the first two columns are survival
times and status, respectively and the rest is the design matrix which is
produced by <code>PreProcess</code> function.</p>
</td></tr>
<tr><td><code id="cox_bvs_+3A_cur_cols">cur_cols</code></td>
<td>
<p>A vector containing indices of the initial model for
variable selector to start the S5 algorithm from. Note that the first
<code>nf</code> indices are <code>1</code> to <code>nf</code> where <code>nf</code> is the number
of fixed covariates that do not enter the selection procedure.</p>
</td></tr>
<tr><td><code id="cox_bvs_+3A_nf">nf</code></td>
<td>
<p>The number of fixed covariates that do not enter the selection
procedure.</p>
</td></tr>
<tr><td><code id="cox_bvs_+3A_tau">tau</code></td>
<td>
<p>The paramter <code>tau</code> of the iMOM prior.</p>
</td></tr>
<tr><td><code id="cox_bvs_+3A_r">r</code></td>
<td>
<p>The paramter <code>r</code> of the iMOM prior.</p>
</td></tr>
<tr><td><code id="cox_bvs_+3A_nlptype">nlptype</code></td>
<td>
<p>Determines the type of nonlocal prior that is used in the
analyses. <code>0</code> is for piMOM and <code>1</code> is for pMOM.</p>
</td></tr>
<tr><td><code id="cox_bvs_+3A_a">a</code></td>
<td>
<p>The first parameter in beta distribution used as prior on model
size. This parameter is equal to 1 when uinform-binomial prior is used.</p>
</td></tr>
<tr><td><code id="cox_bvs_+3A_b">b</code></td>
<td>
<p>The second paramter in beta distribution used as prior on model
size. This parameter is equal to 1 when uinform-binomial prior is used.</p>
</td></tr>
<tr><td><code id="cox_bvs_+3A_d">d</code></td>
<td>
<p>This is the number of candidate covariates picked from top
variables with highest utility function value and used in S5 algorithm.</p>
</td></tr>
<tr><td><code id="cox_bvs_+3A_l">L</code></td>
<td>
<p>Number of temperatures in S5 algorithm.</p>
</td></tr>
<tr><td><code id="cox_bvs_+3A_j">J</code></td>
<td>
<p>Number of iterations at each temperature in S5 algorithm.</p>
</td></tr>
<tr><td><code id="cox_bvs_+3A_temps">temps</code></td>
<td>
<p>Vector of temperatuers used in S5 algorithm.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>It returns a list containing following objects:
</p>
<table>
<tr><td><code>max_model</code></td>
<td>
<p>A <code>1</code> by <code>p</code> binary vector showing the selected
model with maximum probability. <code>1</code> means a specific variable is
selected.</p>
</td></tr>
<tr><td><code>hash_key</code></td>
<td>
<p>A column vector indicating the generated key for each model
that is used to track visited models and growing dictionary.</p>
</td></tr>
<tr><td><code>max_prob</code></td>
<td>
<p>The unnormalized probability of the model with highest
posterior probability.</p>
</td></tr>
<tr><td><code>all_probs</code></td>
<td>
<p>A vector containing unnormalized probabilities of all
visited models.</p>
</td></tr>
<tr><td><code>vis_covs_list</code></td>
<td>
<p>A list containing the covariates in each visited model
in the stochastic search process.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Amir Nikooienejad
</p>


<h3>References</h3>

<p>Nikooienejad, A., Wang, W., and Johnson, V. E. (2017). Bayesian
Variable Selection in High Dimensional Survival Time Cancer Genomic
Datasets using Nonlocal Priors. arXiv preprint, arXiv:1712.02964.<br /><br />
Shin, M., Bhattacharya, A., and Johnson, V. E. (2017). Scalable
Bayesian variable selection using nonlocal prior densities in ultrahigh
dimensional settings. Statistica Sinica.<br /><br />
Johnson, V. E., and Rossell, D. (2010). On the use of non-local prior
densities in Bayesian hypothesis tests. Journal of the Royal Statistical
Society: Series B (Statistical Methodology), 72(2), 143-170.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bvs">bvs</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### Initializing the parameters
n &lt;- 100
p &lt;- 40
set.seed(123)
Sigma &lt;- diag(p)
full &lt;- matrix(c(rep(0.5, p*p)), ncol=p)
Sigma &lt;- full + 0.5*Sigma
cholS &lt;- chol(Sigma)
Beta &lt;- c(-1.8, 1.2, -1.7, 1.4, -1.4, 1.3)
X = matrix(rnorm(n*p), ncol=p)
X = X%*%cholS
X &lt;- scale(X)
beta &lt;- numeric(p)
beta[c(1:length(Beta))] &lt;- Beta
XB &lt;- X%*%beta
sur_times &lt;- rexp(n,exp(XB))
cens_times &lt;- rexp(n,0.2)
times &lt;- pmin(sur_times,cens_times)
status &lt;- as.numeric(sur_times &lt;= cens_times)
exmat &lt;- cbind(times,status,X)
L &lt;- 10; J &lt;- 10
d &lt;- 2 * ceiling(log(p))
temps &lt;- seq(3, 1, length.out = L)
tau &lt;- 0.5; r &lt;- 1; a &lt;- 6; b &lt;- p-a
nlptype &lt;- 0 ### PiMOM nonlocal prior
cur_cols &lt;- c(1,2,3) ### Starting model for the search algorithm
nf &lt;- 0 ### No fixed columns

### Running the Function
coxout &lt;- cox_bvs(exmat,cur_cols,nf,tau,r,nlptype,a,b,d,L,J,temps)

### The number of visited model for this specific run:
length(coxout$hash_key)


### The selected model:
which(coxout$max_model&gt;0)

### The unnormalized probability of the selected model:
coxout$max_prob

</code></pre>

<hr>
<h2 id='HyperSelect'>Hyperparameter selection for iMOM prior density</h2><span id='topic+HyperSelect'></span>

<h3>Description</h3>

<p>This function finds data specific hyperparameters for inverse
moment prior density so that the overlap between the iMOM prior and null
MLE density is <code class="reqn">1/\sqrt p</code>. In this algorithm <code>r</code> is always chosen
to be equal to 1 and <code>tau</code> is found based on the mentioned overlap.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>HyperSelect(
  X,
  resp,
  eff_size = 0.7,
  nlptype = "piMOM",
  iter = 10000,
  mod_prior = c("unif", "beta"),
  family = c("logistic", "survival")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="HyperSelect_+3A_x">X</code></td>
<td>
<p>The design matrix. <code>NA</code>'s should be removed and columns be
scaled. It is recommended that the <code>PreProcess</code> function is run first
and its output used for this argument. The columns are genes and rows
represent the observations. The column names are used as gene names.</p>
</td></tr>
<tr><td><code id="HyperSelect_+3A_resp">resp</code></td>
<td>
<p>For logistic regression models, it is the binary response
vector. For Cox proportional hazard model, this is a two column matrix
where the first column contains survival time vector and the second column
is the censoring status for each observation.</p>
</td></tr>
<tr><td><code id="HyperSelect_+3A_eff_size">eff_size</code></td>
<td>
<p>This is the expected effect size in the model for a
standardized design matrix, which is basically the coefficient value that is
expected to occur the most based on some prior knowledge.</p>
</td></tr>
<tr><td><code id="HyperSelect_+3A_nlptype">nlptype</code></td>
<td>
<p>Determines the type of nonlocal prior that is used in the
analyses. It can be &quot;piMOM&quot; for product inverse moment prior, or &quot;pMOM&quot; for
product moment prior. The default is set to piMOM prior.</p>
</td></tr>
<tr><td><code id="HyperSelect_+3A_iter">iter</code></td>
<td>
<p>The number of iteration needed to simulate from null model in
order to approximate the null MLE density.</p>
</td></tr>
<tr><td><code id="HyperSelect_+3A_mod_prior">mod_prior</code></td>
<td>
<p>Type of prior used for model space. <code>uniform</code> is for
uniform binomial and <code>beta</code> is for beta binomial prior. In the former
case, both hyper parameters in the beta prior are equal to <code>1</code> but in
the latter case those two hyper parameters are chosen as explained in the
reference papers.</p>
</td></tr>
<tr><td><code id="HyperSelect_+3A_family">family</code></td>
<td>
<p>Determines the type of data analysis. <code>logistic</code> is for
binary outcome data where logistic regression modeling is used whereas
<code>survival</code> is for survival outcome data using Cox proportional
hazard model.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>It returns a list having following object:
</p>
<table>
<tr><td><code>tau</code></td>
<td>
<p>The hyperparameter for iMOM prior density function, calculated
using the proposed algorithm for the given dataset.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Amir Nikooienejad
</p>


<h3>References</h3>

<p>Nikooienejad, A., Wang, W., and Johnson, V. E. (2016). Bayesian
variable selection for binary outcomes in high dimensional genomic studies
using nonlocal priors. Bioinformatics, 32(9), 1338-1345.<br /><br />
Johnson, V. E., and Rossell, D. (2010). On the use of nonlocal prior
densities in Bayesian hypothesis tests. Journal of the Royal Statistical
Society: Series B (Statistical Methodology), 72(2), 143-170.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### Simulating Logistic Regression Data
n &lt;- 20
p &lt;- 100
set.seed(321)
Sigma &lt;- diag(p)
full &lt;- matrix(c(rep(0.5, p * p)), ncol = p)
Sigma &lt;- full + 0.5 * Sigma
cholS &lt;- chol(Sigma)
Beta &lt;- c(1, 1.8, 2.5)
X = matrix(rnorm(n*p, 1, 2), ncol = p)
X = X%*%cholS
beta &lt;- numeric(p)
beta[c(1:length(Beta))] &lt;- Beta
XB &lt;- X%*%beta
probs &lt;- as.vector(exp(XB)/(1+exp(XB)))
y &lt;- rbinom(n,1,probs)
colnames(X) &lt;- paste("gene_",c(1:p),sep="")
Xout &lt;- PreProcess(X)
XX &lt;- Xout$X
hparam &lt;- HyperSelect(XX, y, iter = 1000, mod_prior = "beta",
                      family = "logistic")

hparam$tau
</code></pre>

<hr>
<h2 id='logreg_bvs'>Non-parallel version of Bayesian variable selector for logistic regression
data using nonlocal priors</h2><span id='topic+logreg_bvs'></span>

<h3>Description</h3>

<p>This function performs Bayesian variable selection for
logistic regression data in a non-parallel fashion. It does not contain any
pre-processing step or variable initialization. Moreover it does not have
the feature to be run in parallel for performing the coupling algorithm.
Therefore in general, it is NOT recommended to be used unless the user
knows how to initialize all the parameters. However, this function is
called by <code><a href="#topic+bvs">bvs</a></code> function, the recommended way to run Bayesian
variable selection for such datasets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>logreg_bvs(
  exmat,
  chain1,
  nf,
  tau,
  r,
  nlptype,
  a,
  b,
  in_cons,
  loopcnt,
  cplng,
  chain2
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logreg_bvs_+3A_exmat">exmat</code></td>
<td>
<p>An extended matrix where the first column is binary resonse
vector and the rest is the design matrix which has its first column all 1
to account for the intercept in the model and is the output of
<code>PreProcess</code> code where the fixed columns are moved to the beginning.</p>
</td></tr>
<tr><td><code id="logreg_bvs_+3A_chain1">chain1</code></td>
<td>
<p>The first chain or initial model where the MCMC algorithm
starts from. Note that the first <code>nf+1</code> elements are <code>1</code> where
<code>nf</code> is the number of fixed covariates that do not enter the selection
procedure and <code>1</code> is for the intercept.</p>
</td></tr>
<tr><td><code id="logreg_bvs_+3A_nf">nf</code></td>
<td>
<p>The number of fixed covariates that do not enter the selection
procedure.</p>
</td></tr>
<tr><td><code id="logreg_bvs_+3A_tau">tau</code></td>
<td>
<p>The paramter <code>tau</code> of the iMOM prior.</p>
</td></tr>
<tr><td><code id="logreg_bvs_+3A_r">r</code></td>
<td>
<p>The paramter <code>r</code> of the iMOM prior.</p>
</td></tr>
<tr><td><code id="logreg_bvs_+3A_nlptype">nlptype</code></td>
<td>
<p>Determines the type of nonlocal prior that is used in the
analyses. <code>0</code> is for piMOM and <code>1</code> is for pMOM.</p>
</td></tr>
<tr><td><code id="logreg_bvs_+3A_a">a</code></td>
<td>
<p>The first parameter in beta distribution used as prior on model
size. This parameter is equal to 1 when uinform-binomial prior is used.</p>
</td></tr>
<tr><td><code id="logreg_bvs_+3A_b">b</code></td>
<td>
<p>The second paramter in beta distribution used as prior on model
size. This parameter is equal to 1 when uinform-binomial prior is used.</p>
</td></tr>
<tr><td><code id="logreg_bvs_+3A_in_cons">in_cons</code></td>
<td>
<p>The average model size. This value under certain conditions
and when <code>p</code> is large, is equal to parameter <code>a</code> of the
beta-binomial prior.</p>
</td></tr>
<tr><td><code id="logreg_bvs_+3A_loopcnt">loopcnt</code></td>
<td>
<p>Number of iterations for MCMC procedure.</p>
</td></tr>
<tr><td><code id="logreg_bvs_+3A_cplng">cplng</code></td>
<td>
<p>A boolean variable indicating the coupling algorithm to be
performed or not.</p>
</td></tr>
<tr><td><code id="logreg_bvs_+3A_chain2">chain2</code></td>
<td>
<p>Second chain or model for starting the MCMC procedure. This
parameter is only used when <code>cplng=TRUE</code>. Thus, it could be simply
set to <code>chain1</code> when it is not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>It returns a list containing following objects:
</p>
<table>
<tr><td><code>max_chain</code></td>
<td>
<p>A <code>1</code> by <code>p+1</code> binary vector showing the selected
model with maximum probability. <code>1</code> means a specific variable is
selected. The first variable is always the intercept.</p>
</td></tr>
<tr><td><code>beta_hat</code></td>
<td>
<p>The coefficient vector for the selected model. The first one
is always for the intercept.</p>
</td></tr>
<tr><td><code>max_prop</code></td>
<td>
<p>The unnormalized probability of the model with highest
posterior probability.</p>
</td></tr>
<tr><td><code>num_iterations</code></td>
<td>
<p>The number of MCMC iterations that are executed.
This is used when <code>cplng=TRUE</code> to check whether the total designated
MCMC iterations were used or two chains are coupled sooner than that.</p>
</td></tr>
<tr><td><code>cplng_flag</code></td>
<td>
<p>This is used when <code>cplng=TRUE</code> and indicates whether
two chains are coupled or not.</p>
</td></tr>
<tr><td><code>num_vis_models</code></td>
<td>
<p>Number of visited models in search for the highest
probability model. This contains redundant models too and is not the number
of unique models.</p>
</td></tr>
<tr><td><code>hash_key</code></td>
<td>
<p>This is only used when <code>cplng = FALSE</code>. This is a
vector containing real numbers uniquely assigned to each model for
distinguishing them.</p>
</td></tr>
<tr><td><code>hash_prob</code></td>
<td>
<p>This is only used when <code>cplng = FALSE</code>. This is a
vector of probabilities for each visited model.</p>
</td></tr>
<tr><td><code>vis_covs</code></td>
<td>
<p>This is only used when <code>cplng = FALSE</code>. This is a
list where each element contains indices of covariates for each visited
model.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Amir Nikooienejad
</p>


<h3>References</h3>

<p>Nikooienejad, A., Wang, W., and Johnson, V. E. (2016). Bayesian
variable selection for binary outcomes in high dimensional genomic studies
using nonlocal priors. Bioinformatics, 32(9), 1338-1345.<br /><br />
Nikooienejad, A., Wang, W., and Johnson, V. E. (2017). Bayesian Variable
Selection in High Dimensional Survival Time Cancer Genomic Datasets using
Nonlocal Priors. arXiv preprint, arXiv:1712.02964.<br /><br />
Johnson, V. E., and Rossell, D. (2010). On the use of non-local prior
densities in Bayesian hypothesis tests. Journal of the Royal Statistical
Society: Series B (Statistical Methodology), 72(2), 143-170.<br /><br />
Johnson, V. E. (1998). A coupling-regeneration scheme for
diagnosing convergence in Markov chain Monte Carlo algorithms. Journal of
the American Statistical Association, 93(441), 238-248.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bvs">bvs</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### Initializing parameters
n &lt;- 200
p &lt;- 40
set.seed(123)
Sigma &lt;- diag(p)
full &lt;- matrix(c(rep(0.5, p*p)), ncol=p)
Sigma &lt;- full + 0.5*Sigma
cholS &lt;- chol(Sigma)
Beta &lt;- c(-1.7,1.8,2.5)
X &lt;- matrix(rnorm(n*p), ncol=p)
X &lt;- X%*%cholS
colnames(X) &lt;- paste("gene_",c(1:p),sep="")
beta &lt;- numeric(p)
beta[c(1:length(Beta))] &lt;- Beta
XB &lt;- X%*%beta
probs &lt;- as.vector(exp(XB)/(1+exp(XB)))
y &lt;- rbinom(n,1,probs)
exmat &lt;- cbind(y,X)
tau &lt;- 0.5; r &lt;- 1; a &lt;- 3; b &lt;- p-a; in_cons &lt;- a;
loopcnt &lt;- 100; cplng &lt;- FALSE;
initProb &lt;- in_cons/p

### Initializing Chains
schain &lt;- p
while (schain &gt; in_cons || schain == 0) {
chain1 &lt;- rbinom(p, 1, initProb)
 schain &lt;- sum(chain1)
}
chain1 &lt;- as.numeric(c(1, chain1))
chain2 &lt;- chain1
nlptype &lt;- 0 ## PiMOM nonlocal prior
nf &lt;- 0 ### No fixed columns

### Running the function
bvsout &lt;- logreg_bvs(exmat,chain1,nf,tau,r,nlptype,a,b,in_cons,loopcnt,cplng,chain2)

### Number of visited models for this specific run:
bvsout$num_vis_models

### The selected model:
which(bvsout$max_chain &gt; 0)

### Estimated coefficients:
bvsout$beta_hat

### The unnormalized probability of the selected model:
bvsout$max_prob
</code></pre>

<hr>
<h2 id='ModProb'>Logarithm of unnormalized probability of a given model</h2><span id='topic+ModProb'></span>

<h3>Description</h3>

<p>This function calculates the logarithm of unnormalized
probability of a given set of covariates for both survival and binary
response data. It uses the inverse moment nonlocal prior (iMOM) for
non zero coefficients and beta binomial prior for the model space.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ModProb(
  X,
  resp,
  mod_cols,
  nlptype = "piMOM",
  tau,
  r,
  a,
  b,
  family = c("logistic", "survival")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ModProb_+3A_x">X</code></td>
<td>
<p>The design matrix. It is assumed that the design matrix has
standardized columns. It is recommended that to use the output of
<code><a href="#topic+PreProcess">PreProcess</a></code> function of the package.</p>
</td></tr>
<tr><td><code id="ModProb_+3A_resp">resp</code></td>
<td>
<p>For logistic regression models, this variable is the binary
response vector. For Cox proportional hazard models this is a two column
matrix where the first column contains the survival time vector and the
second column is the censoring status for each observation.</p>
</td></tr>
<tr><td><code id="ModProb_+3A_mod_cols">mod_cols</code></td>
<td>
<p>A vector of column indices of the design matrix,
representing the model.</p>
</td></tr>
<tr><td><code id="ModProb_+3A_nlptype">nlptype</code></td>
<td>
<p>Determines the type of nonlocal prior that is used in the
analyses. It can be &quot;piMOM&quot; for product inverse moment prior, or &quot;pMOM&quot; for
product moment prior. The default is set to piMOM prior.</p>
</td></tr>
<tr><td><code id="ModProb_+3A_tau">tau</code></td>
<td>
<p>Hyperparameter <code>tau</code> of the iMOM prior.</p>
</td></tr>
<tr><td><code id="ModProb_+3A_r">r</code></td>
<td>
<p>Hyperparameter <code>r</code> of the iMOM prior.</p>
</td></tr>
<tr><td><code id="ModProb_+3A_a">a</code></td>
<td>
<p>First parameter in the beta binomial prior.</p>
</td></tr>
<tr><td><code id="ModProb_+3A_b">b</code></td>
<td>
<p>Second parameter in the beta binomial prior.</p>
</td></tr>
<tr><td><code id="ModProb_+3A_family">family</code></td>
<td>
<p>Determines the type of data analysis. <code>logistic</code> is for
binary outcome and logistic regression model whereas,
<code>survival</code> represents survival outcomes and the Cox proportional
hazard model.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>It returns the unnormalized probability for the selected model.
</p>


<h3>Author(s)</h3>

<p>Amir Nikooienejad
</p>


<h3>References</h3>

<p>Nikooienejad, A., Wang, W., and Johnson, V. E. (2016). Bayesian
variable selection for binary outcomes in high dimensional genomic studies
using nonlocal priors. Bioinformatics, 32(9), 1338-1345.<br /><br />
Nikooienejad, A., Wang, W., &amp; Johnson, V. E. (2020). Bayesian variable
selection for survival data using inverse moment priors. Annals of Applied
Statistics, 14(2), 809-828.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+CoefEst">CoefEst</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### Simulating Logistic Regression Data
n &lt;- 400
p &lt;- 1000
set.seed(123)
Sigma &lt;- diag(p)
full &lt;- matrix(c(rep(0.5, p*p)), ncol=p)
Sigma &lt;- full + 0.5*Sigma
cholS &lt;- chol(Sigma)
Beta &lt;- c(1,1.8,2.5)
X = matrix(rnorm(n*p), ncol=p)
X = X%*%cholS
beta &lt;- numeric(p)
beta[c(1:length(Beta))] &lt;- Beta
XB &lt;- X%*%beta
probs &lt;- as.vector(exp(XB)/(1+exp(XB)))
y &lt;- rbinom(n,1,probs)

### Calling the function for a subset of the true model, with an arbitrary
### parameters for prior densities
mod &lt;- c(1:3)
Mprob &lt;- ModProb(X, y, mod, tau = 0.7, r = 1, a = 7, b = 993,
                 family = "logistic")

Mprob
</code></pre>

<hr>
<h2 id='predBMA'>Predictive accuracy measurement using Bayesian Model Averaging</h2><span id='topic+predBMA'></span>

<h3>Description</h3>

<p>This function is used for predictive accuracy measurement of
the selected models using Bayesian Model Averaging methodology. The Occam's
window with cut out threshold of <code>thr</code> is used. That means only models
that have posterior probability of at least <code>thr</code> * posteior
probability of the highest posterior probability model are considered in
model averaging. For survival time response datasets, the predictive Area
Under Curve (AUC) at each given time point is computed as the output. In
this case, the predictive AUC is obtained using Uno's method for
observations in the test set. For binary outcome data, only one AUC is
reported which is from the ROC computed on the test set. The training set is
used to find the selected model and relevant probabilities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>predBMA(
  bvsobj,
  X,
  resp,
  prep,
  logT,
  nlptype = "piMOM",
  train_idx,
  test_idx,
  thr = 0.05,
  times = NULL,
  family = c("logistic", "survival")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predBMA_+3A_bvsobj">bvsobj</code></td>
<td>
<p>An object that is generated by <code><a href="#topic+bvs">bvs</a></code> function. It
is the output of the Bayesian variable selection procedure.</p>
</td></tr>
<tr><td><code id="predBMA_+3A_x">X</code></td>
<td>
<p>The same <code>n</code> times <code>p</code> data frame initially used in
<code>bvs</code> function. This is the full data frame containing all test and
train data.</p>
</td></tr>
<tr><td><code id="predBMA_+3A_resp">resp</code></td>
<td>
<p>For logistic regression models, this variable is the binary
response vector. For the Cox proportional hazard models this is a two column
matrix where the first column contains survival times and the second column
is the censoring status for each observation. Note that for survival times,
the time section of this variable should be in the same scale and unit
(year, days, etc.) as <code>times</code> variable for which the AUC has to be
computed.</p>
</td></tr>
<tr><td><code id="predBMA_+3A_prep">prep</code></td>
<td>
<p>A boolean variable determining if the preprocessing step has
been done on the original data frame in <code>bvs</code> function. This should
have the same value as <code>prep</code> variable in the <code>bvs</code> function.</p>
</td></tr>
<tr><td><code id="predBMA_+3A_logt">logT</code></td>
<td>
<p>A boolean variable determining if log transform should has been
done on continuous columns of the data frame in <code>bvs</code> function. This
should have the same value as <code>logT</code> variable in the <code>bvs</code>
function.</p>
</td></tr>
<tr><td><code id="predBMA_+3A_nlptype">nlptype</code></td>
<td>
<p>Determines the type of nonlocal prior that is used in the
analyses. It can be &quot;piMOM&quot; for product inverse moment prior, or &quot;pMOM&quot; for
product moment prior. The default is set to piMOM prior.</p>
</td></tr>
<tr><td><code id="predBMA_+3A_train_idx">train_idx</code></td>
<td>
<p>An integer vector containing the indices of the training
set.</p>
</td></tr>
<tr><td><code id="predBMA_+3A_test_idx">test_idx</code></td>
<td>
<p>An integer vector containing the indices of the test set.
The set of observations that prediction will be performed on.</p>
</td></tr>
<tr><td><code id="predBMA_+3A_thr">thr</code></td>
<td>
<p>The threshold used for Occam's window as explained in the
description. The default value for this variable is 0.05.</p>
</td></tr>
<tr><td><code id="predBMA_+3A_times">times</code></td>
<td>
<p>A vector of times at which predictive AUC is to be computed.
This input is only used for prediction in survival data analysis.</p>
</td></tr>
<tr><td><code id="predBMA_+3A_family">family</code></td>
<td>
<p>Determines the type of data analysis. <code>logistic</code> is for
binary outcome and logistic regression model whereas, <code>survival</code>
represents survival outcomes and the Cox proportional hazard model.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The output is different based on the family for the anlysis of data
<strong>1) </strong> <code>family = logistic</code>
The output is a list with the two following objects:
</p>
<table>
<tr><td><code>auc</code></td>
<td>
<p>This is the area under the ROC curve after Bayesian model
averaging is used to obtain ROC for the test data.</p>
</td></tr>
<tr><td><code>roc_curve</code></td>
<td>
<p>This is a two column matrix representing points on the ROC
curve and can be used to plot the curve. The first column is FPR and the
second column is TPR which represent x-axis and y-axis in the ROC curve,
respectively.</p>
</td></tr>
</table>
<p><strong>2) </strong> <code>family = survival</code>
</p>
<table>
<tr><td><code>auc</code></td>
<td>
<p>A vector with the same length as <code>times</code> variable showing
predictive area under the curve at each given time point using Bayesian
Model averaging.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Amir Nikooienejad
</p>


<h3>References</h3>

<p>Raftery, A. E., Madigan, D., &amp; Hoeting, J. A. (1997). Bayesian
model averaging for linear regression models. Journal of the American
Statistical Association, 92(437), 179-191.<br /><br />
Nikooienejad, A., Wang, W., &amp; Johnson, V. E. (2020). Bayesian variable
selection for survival data using inverse moment priors. Annals of Applied
Statistics, 14(2), 809-828. <br /><br />
Uno, H., Cai, T., Tian, L., &amp; Wei, L. J. (2007). Evaluating
prediction rules for t-year survivors with censored regression models.
Journal of the American Statistical Association, 102(478), 527-537.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### Simulating Logistic Regression Data
n &lt;- 200
p &lt;- 40
set.seed(123)
Sigma &lt;- diag(p)
full &lt;- matrix(c(rep(0.5, p*p)), ncol=p)
Sigma &lt;- full + 0.5*Sigma
cholS &lt;- chol(Sigma)
Beta &lt;- c(-1.7,1.8,2.5)
X &lt;- matrix(rnorm(n*p), ncol=p)
X &lt;- X%*%cholS
colnames(X) &lt;- c(paste("gene_",c(1:p),sep=""))
beta &lt;- numeric(p)
beta[c(1:length(Beta))] &lt;- Beta
Xout &lt;- PreProcess(X)
X &lt;- Xout$X
XB &lt;- X%*%beta
probs &lt;- as.vector(exp(XB)/(1+exp(XB)))
y &lt;- rbinom(n,1,probs)
X &lt;- as.data.frame(X)
train_idx &lt;- sample(1:n,0.8*n)
test_idx &lt;- setdiff(1:n,train_idx)
X_train &lt;- X[train_idx,]
y_train &lt;- y[train_idx]
bout &lt;- bvs(X_train, y_train, prep=FALSE, family = "logistic",
           mod_prior = "beta",niter = 50)
BMAout &lt;- predBMA(bout, X, y, prep = FALSE, logT = FALSE, 
                 train_idx = train_idx, test_idx = test_idx,
                 family="logistic")
### AUC for the prediction:
BMAout$auc

### Plotting ROC Curve
roc &lt;- BMAout$roc_curve
plot(roc,lwd=2,type='l',col='blue')
</code></pre>

<hr>
<h2 id='PreProcess'>Preprocessing the design matrix, preparing it for variable selection
procedure</h2><span id='topic+PreProcess'></span>

<h3>Description</h3>

<p>This function preprocesses the design matrix by removing
columns that contain <code>NA</code>'s or are all zero. It also standardizes
non-binary columns to have mean zero and variance one. The user has the
choice of log transforming continuous covariates before scaling them.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PreProcess(X, logT = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PreProcess_+3A_x">X</code></td>
<td>
<p>The <code>n</code> times <code>p</code> design matrix. The columns should
represent genes and rows represent the observations. The column names are
used as gene names so they should not be left as <code>NULL</code>. Note that the
input matrix <code>X</code> should NOT contain vector of <code>1</code>'s representing
the intercept.</p>
</td></tr>
<tr><td><code id="PreProcess_+3A_logt">logT</code></td>
<td>
<p>A boolean variable determining if log transform should be done
on continuous columns before scaling them. Note that those columns should
not contain any zeros or negative values.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>It returns a list having the following objects:
</p>
<table>
<tr><td><code>X</code></td>
<td>
<p>The filtered design matrix which can be used in variable selection
procedure. Binary columns are moved to the end of the design matrix.</p>
</td></tr>
<tr><td><code>gnames</code></td>
<td>
<p>Gene names read from the column names of the filtered design
matrix.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Amir Nikooienejad
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### Constructing a synthetic design matrix for the purpose of preprocessing
### imposing columns with different scales
n &lt;- 40
p1 &lt;- 50
p2 &lt;- 150
p &lt;- p1 + p2
X1 &lt;- matrix(rnorm(n*p1, 1, 2), ncol = p1)
X2 &lt;- matrix(rnorm(n*p2), ncol = p2)
X &lt;- cbind(X1, X2)

### putting NA elements in the matrix
X[3,85] &lt;- NA
X[25,85] &lt;- NA
X[35,43] &lt;- NA
X[15,128] &lt;- NA
colnames(X) &lt;- paste("gene_",c(1:p),sep="")

### Running the function. Note the intercept column that is added as the
### first column in the "logistic" family
Xout &lt;- PreProcess(X)
dim(Xout$X)[2] == (p + 1) ## 1 is added because intercept column is included
## This is FALSE because of the removal of columns with NA elements
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
