<!DOCTYPE html><html><head><title>Help for package PLSiMCpp</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {PLSiMCpp}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#plsim.bw'><p>select bandwidth</p></a></li>
<li><a href='#plsim.est'><p>Profile Least Squares Estimator</p></a></li>
<li><a href='#plsim.ini'><p>Initialize coefficients</p></a></li>
<li><a href='#plsim.lam'><p>Select lambda for Penalized Profile Least Squares Estimator</p></a></li>
<li><a href='#plsim.MAVE'><p>Minimum Average Variance Estimation</p></a></li>
<li><a href='#plsim.npTest'><p>Testing nonparametric component</p></a></li>
<li><a href='#plsim.pTest'><p>Testing Parametric Components</p></a></li>
<li><a href='#plsim.vs.hard'><p>Variable Selection for Partial Linear Single Index Models</p></a></li>
<li><a href='#plsim.vs.soft'><p>Penalized Profile Least Squares Estimator</p></a></li>
<li><a href='#predict.pls'><p>Predict according to the Estimated Parameters</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Methods for Partial Linear Single Index Model</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.4</td>
</tr>
<tr>
<td>Depends:</td>
<td>R(&gt; 4.2)</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-09-24</td>
</tr>
<tr>
<td>Author:</td>
<td>Shunyao Wu, Qi Zhang, Zhiruo Li, Hua Liang</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Shunyao Wu &lt;wushunyao@qdu.edu.cn&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Estimation, hypothesis tests, and variable selection in partially linear single-index models. Please see H. (2010) at &lt;<a href="https://doi.org/10.1214%2F10-AOS835">doi:10.1214/10-AOS835</a>&gt; for more details.</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.1</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 0.12.11), crayon, methods, stats, purrr</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp,RcppArmadillo</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-09-24 11:22:00 UTC; hp</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-09-24 11:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='plsim.bw'>select bandwidth</h2><span id='topic+plsim.bw'></span><span id='topic+plsim.bw.formula'></span><span id='topic+plsim.bw.default'></span><span id='topic+bwsel_Core'></span><span id='topic+bwsel_new.CrossValidation'></span><span id='topic+bwsel_new.default'></span><span id='topic+deal_formula'></span><span id='topic+summary.pls'></span>

<h3>Description</h3>

<p>Select bandwidth for methods, including MAVE, Profile Least Squares Estimator and 
Penalized Profile Least Squares Estimator by cross validation or simple validation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plsim.bw(...)

## S3 method for class 'formula'
plsim.bw(formula, data, ...)

## Default S3 method:
plsim.bw(xdat, zdat, ydat, zeta_i=NULL, bandwidthList=NULL, 
ParmaSelMethod="CrossValidation", K=5, TestRatio=0.1, TargetMethod='plsimest',
lambda=NULL, l1_ratio=NULL, VarSelMethod = "SCAD", MaxStep = 1L, 
verbose=FALSE, seed=0, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plsim.bw_+3A_...">...</code></td>
<td>
<p>additional arguments.</p>
</td></tr>
<tr><td><code id="plsim.bw_+3A_formula">formula</code></td>
<td>
<p>a symbolic description of the model to be fitted.</p>
</td></tr>
<tr><td><code id="plsim.bw_+3A_data">data</code></td>
<td>
<p>an optional data frame, list or environment containing the variables in the model.</p>
</td></tr>
<tr><td><code id="plsim.bw_+3A_xdat">xdat</code></td>
<td>
<p>input matrix (linear covariates). The model reduces to a single index model when <code>x</code> is NULL.</p>
</td></tr>
<tr><td><code id="plsim.bw_+3A_zdat">zdat</code></td>
<td>
<p>input matrix (nonlinear covariates). <code>z</code> should not be NULL.</p>
</td></tr>
<tr><td><code id="plsim.bw_+3A_ydat">ydat</code></td>
<td>
<p>input vector (response variable).</p>
</td></tr>
<tr><td><code id="plsim.bw_+3A_bandwidthlist">bandwidthList</code></td>
<td>
<p>vector, candidate bandwidths.</p>
</td></tr>
<tr><td><code id="plsim.bw_+3A_targetmethod">TargetMethod</code></td>
<td>
<p>string, optional (default: &quot;plsimest&quot;). 
target method to be selected bandwidth for, which could be &quot;MAVE&quot;, &quot;plsimest&quot; and &quot;plsim&quot;.</p>
</td></tr>
<tr><td><code id="plsim.bw_+3A_parmaselmethod">ParmaSelMethod</code></td>
<td>
<p>string, optional (default: &quot;CrossValidation&quot;). 
Method to select bandwidth, which could be Cross Validation (&quot;CrossValidation&quot;) 
and Simple Validation (&quot;SimpleValidation&quot;).</p>
</td></tr>
<tr><td><code id="plsim.bw_+3A_k">K</code></td>
<td>
<p>int, optional (default: 5). The number of folds for Cross Validation.</p>
</td></tr>
<tr><td><code id="plsim.bw_+3A_testratio">TestRatio</code></td>
<td>
<p>double, optional (default: 0.1). The ratio of test data for Simple Validation.</p>
</td></tr>
<tr><td><code id="plsim.bw_+3A_zeta_i">zeta_i</code></td>
<td>
<p>initial coefficients. It could be obtained by the function <code><a href="#topic+plsim.ini">plsim.ini</a></code>.
<code>zeta_i[1:ncol(z)]</code> is the initial coefficient vector <code class="reqn">\alpha_0</code>, 
and <code>zeta_i[(ncol(z)+1):(ncol(z)+ncol(x))]</code> is the initial coefficient vector <code class="reqn">\beta_0</code>.</p>
</td></tr>
<tr><td><code id="plsim.bw_+3A_lambda">lambda</code></td>
<td>
<p>the parameter for the function <a href="#topic+plsim.vs.soft">plsim.vs.soft</a>, default: NULL.</p>
</td></tr>
<tr><td><code id="plsim.bw_+3A_l1_ratio">l1_ratio</code></td>
<td>
<p>the parameter for the function <a href="#topic+plsim.vs.soft">plsim.vs.soft</a>, default: NULL.</p>
</td></tr>
<tr><td><code id="plsim.bw_+3A_varselmethod">VarSelMethod</code></td>
<td>
<p>the parameter for the function <a href="#topic+plsim.vs.soft">plsim.vs.soft</a>, default : &quot;SCAD&quot;.</p>
</td></tr>
<tr><td><code id="plsim.bw_+3A_maxstep">MaxStep</code></td>
<td>
<p>the parameter for the function <a href="#topic+plsim.vs.soft">plsim.vs.soft</a>, default: 1.</p>
</td></tr>
<tr><td><code id="plsim.bw_+3A_verbose">verbose</code></td>
<td>
<p>the parameter for the function <a href="#topic+plsim.vs.soft">plsim.vs.soft</a>, default: FALSE.</p>
</td></tr>
<tr><td><code id="plsim.bw_+3A_seed">seed</code></td>
<td>
<p>int, default: 0.</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>bandwidthBest</code></td>
<td>
<p>selected bandwidth</p>
</td></tr>
<tr><td><code>mse</code></td>
<td>
<p>mean square errors corresponding to the <code>bandwidthList</code> </p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
# EXAMPLE 1 (INTERFACE=FORMULA)
# To select bandwidth by cross validation and simple validation. 

n = 50
sigma = 0.1

alpha = matrix(1,2,1)
alpha = alpha/norm(alpha,"2")

beta = matrix(4,1,1)

x = matrix(1,n,1)
z = matrix(runif(n*2),n,2)
y = 4*((z%*%alpha-1/sqrt(2))^2) + x%*%beta + sigma*matrix(rnorm(n),n,1)

# Select bandwidth for profile least squares estimator by cross validation
res_plsimest_cross = plsim.bw(y~x|z,bandwidthList=c(0.02,0.04,0.06,0.08,0.10))

# Select bandwidth for profile least squares estimator by simple validation
res_plsimest_simple = plsim.bw(y~x|z,bandwidthList=c(0.02,0.04,0.06,0.08,0.10),
                            ParmaSelMethod="SimpleValidation")

# Select bandwidth for penalized profile least squares estimator by simple validation
res_plsim_simple = plsim.bw(y~x|z,bandwidthList=c(0.02,0.04,0.06,0.08,0.10),
                         ParmaSelMethod="SimpleValidation",TargetMethod="plsim",lambda=0.01)


# EXAMPLE 2 (INTERFACE=DATA FRAME)
# To select bandwidth by cross validation and simple validation. 

n = 50
sigma = 0.1

alpha = matrix(1,2,1)
alpha = alpha/norm(alpha,"2")

beta = matrix(4,1,1)

x = rep(1,n)
z1 = runif(n)
z2 = runif(n) 
X = data.frame(x)
Z = data.frame(z1,z2)

x = data.matrix(X)
z = data.matrix(Z)
y = 4*((z%*%alpha-1/sqrt(2))^2) + x%*%beta + sigma*matrix(rnorm(n),n,1)

# Select bandwidth for profile least squares estimator by cross validation
res_plsimest_cross = plsim.bw(xdat=X,zdat=Z,ydat=y,bandwidthList=c(0.02,0.04,0.06,0.08,0.10))

# Select bandwidth for profile least squares estimator by simple validation
res_plsimest_simple = plsim.bw(xdat=X,zdat=Z,ydat=y,bandwidthList=c(0.02,0.04,0.06,0.08,0.10),
                            ParmaSelMethod="SimpleValidation")

# Select bandwidth for penalized profile least squares estimator by simple validation
res_plsim_simple = plsim.bw(xdat=X,zdat=Z,ydat=y,bandwidthList=c(0.02,0.04,0.06,0.08,0.10),
                         ParmaSelMethod="SimpleValidation",TargetMethod="plsim",lambda=0.01)
                                 
</code></pre>

<hr>
<h2 id='plsim.est'>Profile Least Squares Estimator</h2><span id='topic+plsim.est'></span><span id='topic+plsim.est.formula'></span><span id='topic+plsim.est.default'></span>

<h3>Description</h3>

<p>PLS was proposed by Liang <em>et al.</em> (2010) 
to estimate parameters in PLSiM
</p>
<p style="text-align: center;"><code class="reqn">Y = \eta(Z^T\alpha) + X^T\beta + \epsilon.</code>
</p>



<h3>Usage</h3>

<pre><code class='language-R'>plsim.est(...)

## S3 method for class 'formula'
plsim.est(formula, data, ...)

## Default S3 method:
plsim.est(xdat=NULL, zdat, ydat, h=NULL, zetaini=NULL, MaxStep = 200L,
ParmaSelMethod="SimpleValidation", TestRatio=0.1, K = 3, seed=0, verbose=TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plsim.est_+3A_...">...</code></td>
<td>
<p>additional arguments.</p>
</td></tr>
<tr><td><code id="plsim.est_+3A_formula">formula</code></td>
<td>
<p>a symbolic description of the model to be fitted.</p>
</td></tr>
<tr><td><code id="plsim.est_+3A_data">data</code></td>
<td>
<p>an optional data frame, list or environment containing the variables in the model.</p>
</td></tr>
<tr><td><code id="plsim.est_+3A_xdat">xdat</code></td>
<td>
<p>input matrix (linear covariates). The model reduces to a single index model when <code>x</code> is NULL.</p>
</td></tr>
<tr><td><code id="plsim.est_+3A_zdat">zdat</code></td>
<td>
<p>input matrix (nonlinear covariates). <code>z</code> should not be NULL.</p>
</td></tr>
<tr><td><code id="plsim.est_+3A_ydat">ydat</code></td>
<td>
<p>input vector (response variable).</p>
</td></tr>
<tr><td><code id="plsim.est_+3A_h">h</code></td>
<td>
<p>a value or a vector for bandwidth. If <code>h</code> is NULL, a default vector c(0.01,0.02,0.05,0.1,0.5)
will be set for it. <a href="#topic+plsim.bw">plsim.bw</a> is employed to select the optimal bandwidth when h is a vector or NULL.</p>
</td></tr>
<tr><td><code id="plsim.est_+3A_zetaini">zetaini</code></td>
<td>
<p>initial coefficients, optional (default: NULL). It could be obtained by the function <code><a href="#topic+plsim.ini">plsim.ini</a></code>.
<code>zetaini[1:ncol(z)]</code> is the initial coefficient vector <code class="reqn">\alpha_0</code>,
and <code>zetaini[(ncol(z)+1):(ncol(z)+ncol(x))]</code> is the initial coefficient vector <code class="reqn">\beta_0</code>.</p>
</td></tr>
<tr><td><code id="plsim.est_+3A_maxstep">MaxStep</code></td>
<td>
<p>the maximum iterations, optional (default=200).</p>
</td></tr>
<tr><td><code id="plsim.est_+3A_parmaselmethod">ParmaSelMethod</code></td>
<td>
<p>the parameter for the function <a href="#topic+plsim.bw">plsim.bw</a>.</p>
</td></tr>
<tr><td><code id="plsim.est_+3A_testratio">TestRatio</code></td>
<td>
<p>the parameter for the function <a href="#topic+plsim.bw">plsim.bw</a>.</p>
</td></tr>
<tr><td><code id="plsim.est_+3A_k">K</code></td>
<td>
<p>the parameter for the function <a href="#topic+plsim.bw">plsim.bw</a>.</p>
</td></tr>
<tr><td><code id="plsim.est_+3A_seed">seed</code></td>
<td>
<p>int, default: 0.</p>
</td></tr>
<tr><td><code id="plsim.est_+3A_verbose">verbose</code></td>
<td>
<p>bool, default: TRUE. Enable verbose output.</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>eta</code></td>
<td>
<p>estimated non-parametric part <code class="reqn">\hat{\eta}(Z^T{\hat{\alpha} })</code>.</p>
</td></tr>
<tr><td><code>zeta</code></td>
<td>
<p>estimated coefficients. <code>zeta[1:ncol(z)]</code> is <code class="reqn">\hat{\alpha}</code>, 
and <code>zeta[(ncol(z)+1):(ncol(z)+ncol(x))]</code> is <code class="reqn">\hat{\beta}</code>.</p>
</td></tr>
<tr><td><code>y_hat</code></td>
<td>
 <p><code>y</code>'s estimates.</p>
</td></tr>
<tr><td><code>mse</code></td>
<td>
<p>mean squared errors between y and <code>y_hat</code>.</p>
</td></tr>
<tr><td><code>data</code></td>
<td>
<p>data information including <code>x</code>, <code>z</code>, <code>y</code>, bandwidth <code>h</code>, 
initial coefficients <code>zetaini</code>, iteration step <code>MaxStep</code> and flag <code>SiMflag</code>. 
<code>SiMflag</code> is TRUE when <code>x</code> is NULL, otherwise <code>SiMflag</code> is FALSE.</p>
</td></tr>
<tr><td><code>Z_alpha</code></td>
<td>
<p><code class="reqn">Z^T{\hat{\alpha}}</code>.</p>
</td></tr>
<tr><td><code>r_square</code></td>
<td>
<p>multiple correlation coefficient.</p>
</td></tr>
<tr><td><code>variance</code></td>
<td>
<p>variance of <code>y_hat</code>.</p>
</td></tr>
<tr><td><code>stdzeta</code></td>
<td>
<p>standard error of <code>zeta</code>.</p>
</td></tr>
</table>


<h3>References</h3>

<p>H. Liang, X. Liu, R. Li, C. L. Tsai. <em>Estimation and testing for partially linear single-index models</em>.
Annals of statistics, 2010, 38(6): 3811.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# EXAMPLE 1 (INTERFACE=FORMULA)
# To estimate parameters of partially linear single-index model (PLSiM). 

n = 50
sigma = 0.1

alpha = matrix(1,2,1)
alpha = alpha/norm(alpha,"2")

beta = matrix(4,1,1)

# Case 1: Matrix Input
x = matrix(1,n,1)
z = matrix(runif(n*2),n,2)
y = 4*((z%*%alpha-1/sqrt(2))^2) + x%*%beta + sigma*matrix(rnorm(n),n,1)

fit = plsim.est(y~x|z)
summary(fit)

# Case 2: Vector Input
x = rep(1,n)
z1 = runif(n)
z2 = runif(n) 
y = 4*((z%*%alpha-1/sqrt(2))^2) + x%*%beta + sigma*matrix(rnorm(n),n,1)

fit = plsim.est(y~x|z1+z2)
summary(fit)
print(fit)

# EXAMPLE 2 (INTERFACE=DATA FRAME) 
# To estimate parameters of partially linear single-index model (PLSiM).  

n = 50
sigma = 0.1

alpha = matrix(1,2,1)
alpha = alpha/norm(alpha,"2")

beta = matrix(4,1,1)

x = rep(1,n)
z1 = runif(n)
z2 = runif(n) 
X = data.frame(x)
Z = data.frame(z1,z2)

x = data.matrix(X)
z = data.matrix(Z)
y = 4*((z%*%alpha-1/sqrt(2))^2) + x%*%beta + sigma*matrix(rnorm(n),n,1)

fit = plsim.est(xdat=X,zdat=Z,ydat=y)
summary(fit)
print(fit)

</code></pre>

<hr>
<h2 id='plsim.ini'>Initialize coefficients</h2><span id='topic+plsim.ini'></span><span id='topic+plsim.ini.formula'></span><span id='topic+plsim.ini.default'></span>

<h3>Description</h3>

<p>Xia <em>et al.</em>'s MAVE method is used to obtain initialized 
coefficients <code class="reqn">\alpha_0</code> and <code class="reqn">\beta_0</code> for PLSiM 
</p>
<p style="text-align: center;"><code class="reqn">Y = \eta(Z^T\alpha) + X^T\beta + \epsilon</code>
</p>
<p>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plsim.ini(...)

## S3 method for class 'formula'
plsim.ini(formula, data, ...)

## Default S3 method:
plsim.ini(xdat, zdat, ydat, Method="MAVE_ini", verbose = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plsim.ini_+3A_...">...</code></td>
<td>
<p>additional arguments.</p>
</td></tr>
<tr><td><code id="plsim.ini_+3A_formula">formula</code></td>
<td>
<p>a symbolic description of the model to be fitted.</p>
</td></tr>
<tr><td><code id="plsim.ini_+3A_data">data</code></td>
<td>
<p>an optional data frame, list or environment containing the variables in the model.</p>
</td></tr>
<tr><td><code id="plsim.ini_+3A_xdat">xdat</code></td>
<td>
<p>input matrix (linear covariates). The model reduces to a single index model when <code>x</code> is NULL.</p>
</td></tr>
<tr><td><code id="plsim.ini_+3A_zdat">zdat</code></td>
<td>
<p>input matrix (nonlinear covariates). <code>z</code> should not be NULL.</p>
</td></tr>
<tr><td><code id="plsim.ini_+3A_ydat">ydat</code></td>
<td>
<p>input vector (response variable).</p>
</td></tr>
<tr><td><code id="plsim.ini_+3A_method">Method</code></td>
<td>
<p>string, optional (default=&quot;MAVE_ini&quot;).</p>
</td></tr>
<tr><td><code id="plsim.ini_+3A_verbose">verbose</code></td>
<td>
<p>bool, default: TRUE. Enable verbose output.</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>zeta_i</code></td>
<td>
<p>initial coefficients. <code>zeta_i[1:ncol(z)]</code> is the initial coefficient vector 
<code class="reqn">\alpha_0</code>, and <code>zeta_i[(ncol(z)+1):(ncol(z)+ncol(x))]</code> is the initial 
coefficient vector <code class="reqn">\beta_0</code>.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Y. Xia, W. Härdle. <em>Semi-parametric estimation of partially linear single-index models</em>.
Journal of Multivariate Analysis, 2006, 97(5): 1162-1184.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# EXAMPLE 1 (INTERFACE=FORMULA)
# To obtain initial values by using MAVE methods for partially
# linear single-index model.

n = 50
sigma = 0.1

alpha = matrix(1,2,1)
alpha = alpha/norm(alpha,"2")

beta = matrix(4,1,1)

# Case1: Matrix Input
x = matrix(1,n,1)
z = matrix(runif(n*2),n,2)
y = 4*((z%*%alpha-1/sqrt(2))^2) + x%*%beta + sigma*matrix(rnorm(n),n,1)

zeta_i = plsim.ini(y~x|z)

# Case 2: Vector Input
x = rep(1,n)
z1 = runif(n)
z2 = runif(n) 
y = 4*((z%*%alpha-1/sqrt(2))^2) + x%*%beta + sigma*matrix(rnorm(n),n,1)

zeta_i = plsim.ini(y~x|z1+z2)


# EXAMPLE 2 (INTERFACE=DATA FRAME)
# To obtain initial values by using MAVE methods for partially
# linear single-index model.

n = 50
sigma = 0.1

alpha = matrix(1,2,1)
alpha = alpha/norm(alpha,"2")
beta = matrix(4,1,1)

x = rep(1,n)
z1 = runif(n)
z2 = runif(n) 
X = data.frame(x)
Z = data.frame(z1,z2)

x = data.matrix(X)
z = data.matrix(Z)
y = 4*((z%*%alpha-1/sqrt(2))^2) + x%*%beta + sigma*matrix(rnorm(n),n,1)

zeta_i = plsim.ini(xdat=X, zdat=Z, ydat=y)

</code></pre>

<hr>
<h2 id='plsim.lam'>Select lambda for Penalized Profile Least Squares Estimator</h2><span id='topic+plsim.lam'></span><span id='topic+plsim.lam.formula'></span><span id='topic+plsim.lam.default'></span>

<h3>Description</h3>

<p>Use AIC or BIC to 
choose the regularization parameters for Penalized Profile least squares (PPLS) estimation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plsim.lam(...)

## S3 method for class 'formula'
plsim.lam(formula, data, ...)

## Default S3 method:
plsim.lam(xdat=NULL, ydat, zdat, h, zetaini=NULL, penalty="SCAD", 
lambdaList=NULL, l1_ratio_List=NULL, lambda_selector="BIC", verbose=TRUE, seed=0, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plsim.lam_+3A_...">...</code></td>
<td>
<p>additional arguments.</p>
</td></tr>
<tr><td><code id="plsim.lam_+3A_formula">formula</code></td>
<td>
<p>a symbolic description of the model to be fitted.</p>
</td></tr>
<tr><td><code id="plsim.lam_+3A_data">data</code></td>
<td>
<p>an optional data frame, list or environment containing the variables in the model.</p>
</td></tr>
<tr><td><code id="plsim.lam_+3A_xdat">xdat</code></td>
<td>
<p>input matrix (linear covariates). The model reduces to a single index model when <code>x</code> is NULL.</p>
</td></tr>
<tr><td><code id="plsim.lam_+3A_zdat">zdat</code></td>
<td>
<p>input matrix (nonlinear covariates). <code>z</code> should not be NULL.</p>
</td></tr>
<tr><td><code id="plsim.lam_+3A_ydat">ydat</code></td>
<td>
<p>input vector (response variable).</p>
</td></tr>
<tr><td><code id="plsim.lam_+3A_h">h</code></td>
<td>
<p>bandwidth.</p>
</td></tr>
<tr><td><code id="plsim.lam_+3A_zetaini">zetaini</code></td>
<td>
<p>initial coefficients, optional (default: NULL). It could be obtained by the function <code><a href="#topic+plsim.ini">plsim.ini</a></code>.
<code>zetaini[1:ncol(z)]</code> is the initial coefficient vector <code class="reqn">\alpha_0</code>,
and <code>zetaini[(ncol(z)+1):(ncol(z)+ncol(x))]</code> is the initial coefficient vector <code class="reqn">\beta_0</code>.</p>
</td></tr>
<tr><td><code id="plsim.lam_+3A_penalty">penalty</code></td>
<td>
<p>string, optional (default=&quot;SCAD&quot;). It could be &quot;SCAD&quot;, &quot;LASSO&quot; or &quot;ElasticNet&quot;.</p>
</td></tr>
<tr><td><code id="plsim.lam_+3A_lambdalist">lambdaList</code></td>
<td>
<p>candidates for lambda selection. <code>lambda</code> is a constant that multiplies the penalty term. 
If <code>lambdaList</code> is NULL, function <a href="#topic+plsim.lam">plsim.lam</a> will automatically set it.</p>
</td></tr>
<tr><td><code id="plsim.lam_+3A_l1_ratio_list">l1_ratio_List</code></td>
<td>
<p>candidates for l1_ratio selection. <code>l1_ratio</code> is a constant that balances the importances 
of L1 norm and L2 norm for &quot;ElasticNet&quot;. If <code>l1_ratio_List</code> is NULL, function <a href="#topic+plsim.lam">plsim.lam</a> ranges from 0 to 1 with 
an increment 0.1.</p>
</td></tr>
<tr><td><code id="plsim.lam_+3A_lambda_selector">lambda_selector</code></td>
<td>
<p>the criterion to select lambda (and l1_ratio), default: &quot;BIC&quot;.</p>
</td></tr>
<tr><td><code id="plsim.lam_+3A_verbose">verbose</code></td>
<td>
<p>bool, default: TRUE. Enable verbose output.</p>
</td></tr>
<tr><td><code id="plsim.lam_+3A_seed">seed</code></td>
<td>
<p>int, default: 0.</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>goodness_best</code></td>
<td>
<p>the AIC (or BIC) statistics with <code>lambda_best</code>.</p>
</td></tr>
<tr><td><code>lambda_best</code></td>
<td>
<p>lambda selected by AIC or BIC.</p>
</td></tr>
<tr><td><code>l1_ratio_best</code></td>
<td>
<p>l1_ratio selected by AIC or BIC.</p>
</td></tr>
<tr><td><code>lambdaList</code></td>
<td>
<p><code>lambdaList</code> automatically selected when inputting NULL.</p>
</td></tr>
</table>


<h3>References</h3>

<p>H. Liang, X. Liu, R. Li, C. L. Tsai. <em>Estimation and testing for partially linear single-index models</em>.
Annals of statistics, 2010, 38(6): 3811.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# EXAMPLE 1 (INTERFACE=FORMULA)
# To select the regularization parameters based on AIC.

n = 50
sigma = 0.1

alpha = matrix(1,2,1)
alpha = alpha/norm(alpha,"2")
beta = matrix(4,1,1)

x = matrix(1,n,1)
z = matrix(runif(n*2),n,2)
y = 4*((z%*%alpha-1/sqrt(2))^2) + x%*%beta + sigma*matrix(rnorm(n),n,1)


fit_plsimest = plsim.est(y~x|z)

# Select the regularization parameters by AIC
res = plsim.lam(y~x|z,h=fit_plsimest$data$h,zetaini = fit_plsimest$zeta,
             lambda_selector='AIC')


# EXAMPLE 2 (INTERFACE=DATA FRAME)
# To select the regularization parameters based on AIC.

n = 50
sigma = 0.1

alpha = matrix(1,2,1)
alpha = alpha/norm(alpha,"2")
beta = matrix(4,1,1)

x = rep(1,n)
z1 = runif(n)
z2 = runif(n) 
X = data.frame(x)
Z = data.frame(z1,z2)

x = data.matrix(X)
z = data.matrix(Z)
y = 4*((z%*%alpha-1/sqrt(2))^2) + x%*%beta + sigma*matrix(rnorm(n),n,1)

fit_plsimest = plsim.est(xdat=X,zdat=Z,ydat=y)

# Select the regularization parameters by AIC
res2 = plsim.lam(xdat=X,ydat=y,zdat=Z,h=fit_plsimest$data$h,
              zetaini = fit_plsimest$zeta, lambda_selector='AIC')

</code></pre>

<hr>
<h2 id='plsim.MAVE'>Minimum Average Variance Estimation</h2><span id='topic+plsim.MAVE'></span><span id='topic+plsim.MAVE.formula'></span><span id='topic+plsim.MAVE.default'></span>

<h3>Description</h3>

<p>MAVE (Minimum Average Variance Estimation), proposed by Xia <em>et al.</em> (2006)
to estimate parameters in PLSiM
</p>
<p style="text-align: center;"><code class="reqn">Y=\eta(Z^T\alpha)+X^T\beta+\epsilon.</code>
</p>



<h3>Usage</h3>

<pre><code class='language-R'>plsim.MAVE(...)

## S3 method for class 'formula'
plsim.MAVE(formula, data, ...)

## Default S3 method:
plsim.MAVE(xdat=NULL, zdat, ydat, h=NULL, zeta_i=NULL, maxStep=100,
tol=1e-8, iniMethods="MAVE_ini", ParmaSelMethod="SimpleValidation", TestRatio=0.1, 
K = 3, seed=0, verbose=TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plsim.MAVE_+3A_...">...</code></td>
<td>
<p>additional arguments.</p>
</td></tr>
<tr><td><code id="plsim.MAVE_+3A_formula">formula</code></td>
<td>
<p>a symbolic description of the model to be fitted.</p>
</td></tr>
<tr><td><code id="plsim.MAVE_+3A_data">data</code></td>
<td>
<p>an optional data frame, list or environment containing the variables in the model.</p>
</td></tr>
<tr><td><code id="plsim.MAVE_+3A_xdat">xdat</code></td>
<td>
<p>input matrix (linear covariates). The model reduces to a single index model when <code>x</code> is NULL.</p>
</td></tr>
<tr><td><code id="plsim.MAVE_+3A_zdat">zdat</code></td>
<td>
<p>input matrix (nonlinear covariates). <code>z</code> should not be NULL.</p>
</td></tr>
<tr><td><code id="plsim.MAVE_+3A_ydat">ydat</code></td>
<td>
<p>input vector (response variable).</p>
</td></tr>
<tr><td><code id="plsim.MAVE_+3A_h">h</code></td>
<td>
<p>a numerical value or a vector for bandwidth. If <code>h</code> is NULL, a default 
vector c(0.01,0.02,0.05,0.1,0.5) will be given. 
<a href="#topic+plsim.bw">plsim.bw</a> is employed to select the optimal bandwidth when <code>h</code> is a vector or NULL.</p>
</td></tr>
<tr><td><code id="plsim.MAVE_+3A_zeta_i">zeta_i</code></td>
<td>
<p>initial coefficients, optional (default: NULL). It could be obtained by the function <code><a href="#topic+plsim.ini">plsim.ini</a></code>.
<code>zeta_i[1:ncol(z)]</code> is the initial coefficient vector <code class="reqn">\alpha_0</code>,
and <code>zeta_i[(ncol(z)+1):(ncol(z)+ncol(x))]</code> is the initial coefficient vector <code class="reqn">\beta_0</code>.</p>
</td></tr>
<tr><td><code id="plsim.MAVE_+3A_maxstep">maxStep</code></td>
<td>
<p>the maximum iterations, default: 100.</p>
</td></tr>
<tr><td><code id="plsim.MAVE_+3A_tol">tol</code></td>
<td>
<p>convergence tolerance, default: 1e-8.</p>
</td></tr>
<tr><td><code id="plsim.MAVE_+3A_inimethods">iniMethods</code></td>
<td>
<p>string, optional (default: &quot;SimpleValidation&quot;).</p>
</td></tr>
<tr><td><code id="plsim.MAVE_+3A_parmaselmethod">ParmaSelMethod</code></td>
<td>
<p>the parameter for the function <a href="#topic+plsim.bw">plsim.bw</a>.</p>
</td></tr>
<tr><td><code id="plsim.MAVE_+3A_testratio">TestRatio</code></td>
<td>
<p>the parameter for the function <a href="#topic+plsim.bw">plsim.bw</a>.</p>
</td></tr>
<tr><td><code id="plsim.MAVE_+3A_k">K</code></td>
<td>
<p>the parameter for the function <a href="#topic+plsim.bw">plsim.bw</a>.</p>
</td></tr>
<tr><td><code id="plsim.MAVE_+3A_seed">seed</code></td>
<td>
<p>int, default: 0.</p>
</td></tr>
<tr><td><code id="plsim.MAVE_+3A_verbose">verbose</code></td>
<td>
<p>bool, default: TRUE. Enable verbose output.</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>eta</code></td>
<td>
<p>estimated non-parametric part <code class="reqn">\hat{\eta}(Z^T{\hat{\alpha} })</code>.</p>
</td></tr>
<tr><td><code>zeta</code></td>
<td>
<p>estimated coefficients. <code>zeta[1:ncol(z)]</code> is <code class="reqn">\hat{\alpha}</code>, 
and <code>zeta[(ncol(z)+1):(ncol(z)+ncol(x))]</code> is <code class="reqn">\hat{\beta}</code>.</p>
</td></tr>
<tr><td><code>data</code></td>
<td>
<p>data information including <code>x</code>, <code>z</code>, <code>y</code>, bandwidth <code>h</code>, 
initial coefficients <code>zetaini</code> and iteration step <code>MaxStep</code>.</p>
</td></tr>
<tr><td><code>y_hat</code></td>
<td>
 <p><code>y</code>'s estimates.</p>
</td></tr>
<tr><td><code>mse</code></td>
<td>
<p>mean squares erros between <code>y</code> and <code>y_hat</code>.</p>
</td></tr>
<tr><td><code>variance</code></td>
<td>
<p>variance of <code>y_hat</code>.</p>
</td></tr>
<tr><td><code>r_square</code></td>
<td>
<p>multiple correlation coefficient.</p>
</td></tr>
<tr><td><code>Z_alpha</code></td>
<td>
 <p><code class="reqn">Z^T{\hat{\alpha}}</code>.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Y. Xia, W. Härdle. <em>Semi-parametric estimation of partially linear single-index models</em>.
Journal of Multivariate Analysis, 2006, 97(5): 1162-1184.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# EXAMPLE 1 (INTERFACE=FORMULA)
# To estimate parameters in partially linear single-index model using MAVE.

n = 30
sigma = 0.1

alpha = matrix(1,2,1)
alpha = alpha/norm(alpha,"2")

beta = matrix(4,1,1)

x = matrix(1,n,1)
z = matrix(runif(n*2),n,2)
y = 4*((z%*%alpha-1/sqrt(2))^2) + x%*%beta + sigma*matrix(rnorm(n),n,1)

fit = plsim.MAVE(y~x|z, h=0.1)

# EXAMPLE 2 (INTERFACE=DATA FRAME)
# To estimate parameters in partially linear single-index model using MAVE.

n = 30
sigma = 0.1

alpha = matrix(1,2,1)
alpha = alpha/norm(alpha,"2")
beta = matrix(4,1,1)

x = rep(1,n)
z1 = runif(n)
z2 = runif(n) 
X = data.frame(x)
Z = data.frame(z1,z2)

x = data.matrix(X)
z = data.matrix(Z)
y = 4*((z%*%alpha-1/sqrt(2))^2) + x%*%beta + sigma*matrix(rnorm(n),n,1)

fit = plsim.MAVE(xdat=X, zdat=Z, ydat=y, h=0.1)

</code></pre>

<hr>
<h2 id='plsim.npTest'>Testing nonparametric component</h2><span id='topic+plsim.npTest'></span>

<h3>Description</h3>

<p>Study the hypothesis test:
</p>
<p style="text-align: center;"><code class="reqn">H_0:\eta(u) = \theta_0+\theta_1u \ \mbox{ versus }\quad H_1:\ \eta(u)\ne \theta_0 + 
\theta_1u \ \mbox{for \ some \ } u </code>
</p>

<p>where <code class="reqn">\theta_0</code> and <code class="reqn">\theta_1</code> are unknown constant parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plsim.npTest(fit)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plsim.npTest_+3A_fit">fit</code></td>
<td>
<p>the result of function <a href="#topic+plsim.est">plsim.est</a> or <a href="#topic+plsim.vs.soft">plsim.vs.soft</a>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with class &quot;htest&quot; containing the following components
</p>
<table>
<tr><td><code>statistic</code></td>
<td>
<p>the value of the test statistic.</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>the p-value for the test</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>a character string indicating what type of test was performed</p>
</td></tr>
<tr><td><code>data.name</code></td>
<td>
<p>a character string giving the name of input</p>
</td></tr>
</table>


<h3>References</h3>

<p>H. Liang, X. Liu, R. Li, C. L. Tsai. <em>Estimation and testing for partially linear single-index models</em>.
Annals of statistics, 2010, 38(6): 3811.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
n = 50
sigma = 0.1

alpha = matrix(1,2,1)
alpha = alpha/norm(alpha,"2")

beta = matrix(4,1,1)

x = matrix(1,n,1)

z = matrix(runif(n*2),n,2)

y = 4*((z%*%alpha-1/sqrt(2))^2) + x%*%beta + sigma*matrix(rnorm(n),n,1)

# Obtain parameters in PLSiM using Profile Least Squares Estimator
fit_plsimest = plsim.est(x, z, y)

res_npTest_plsimest = plsim.npTest(fit_plsimest)

# Obtain parameters in PLSiM using Penalized Profile Least Squares Estimator
# with lambda set as 0.01
fit_plsim = plsim.vs.soft(x,z,y,lambda = 0.01)

res_npTest_plsim = plsim.npTest(fit_plsim)

</code></pre>

<hr>
<h2 id='plsim.pTest'>Testing Parametric Components</h2><span id='topic+plsim.pTest'></span>

<h3>Description</h3>

<p>Test whether some elements of <code class="reqn">\alpha</code> and <code class="reqn">\beta</code> are zero, that is,
</p>
<p style="text-align: center;"><code class="reqn">H_0: \alpha_{i_1}=\cdots=\alpha_{i_k}=0 \ \mbox{ and } \beta_{j_1}=\cdots=\beta_{j_l}=0</code>
</p>

<p>versus
</p>
<p style="text-align: center;"><code class="reqn">H_1: \mbox{not \ all }\ \alpha_{i_1},\cdots,\alpha_{i_k}  \ \mbox{ and } \beta_{j_1}, \cdots,\beta_{j_l} \ \mbox{ are equal to }\ 0.</code>
</p>



<h3>Usage</h3>

<pre><code class='language-R'>plsim.pTest(fit, parameterSelected = NULL, TargetMethod = "plsimest")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plsim.pTest_+3A_fit">fit</code></td>
<td>
<p>the result of function <a href="#topic+plsim.est">plsim.est</a> or <a href="#topic+plsim.vs.soft">plsim.vs.soft</a>.</p>
</td></tr>
<tr><td><code id="plsim.pTest_+3A_parameterselected">parameterSelected</code></td>
<td>
<p>select some coefficients for testing, default: NULL.</p>
</td></tr>
<tr><td><code id="plsim.pTest_+3A_targetmethod">TargetMethod</code></td>
<td>
<p>default: &quot;plsim.est&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with class &quot;htest&quot; containing the following components
</p>
<table>
<tr><td><code>statistic</code></td>
<td>
<p>the value of the test statistic.</p>
</td></tr>
<tr><td><code>parameter</code></td>
<td>
<p>the degree of freedom for the test</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>the p-value for the test</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>a character string indicating what type of test was performed</p>
</td></tr>
<tr><td><code>data.name</code></td>
<td>
<p>a character string giving the name of input</p>
</td></tr>
</table>


<h3>References</h3>

<p>H. Liang, X. Liu, R. Li, C. L. Tsai. <em>Estimation and testing for partially linear single-index models</em>.
Annals of statistics, 2010, 38(6): 3811.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
n = 50
sigma = 0.1

alpha = matrix(1,2,1)
alpha = alpha/norm(alpha,"2")

beta = matrix(4,1,1)

x = matrix(1,n,1)
z = matrix(runif(n*2),n,2)
y = 4*((z%*%alpha-1/sqrt(2))^2) + x%*%beta + sigma*matrix(rnorm(n),n,1)

# Obtain parameters in PLSiM using Profile Least Squares Estimator
fit_plsimest = plsim.est(x, z, y)

# Test whether the parameters of parametric part estimated by plsimest
# are zero
res_pTest_plsimest = plsim.pTest(fit_plsimest)

# Test whether the second parameter of parametric part estimated by plsimest
# is zero
res_pTest_plsimest_ = plsim.pTest(fit_plsimest,parameterSelected = c(2))

# Obtain parameters in PLSiM using Penalized Profile Least Squares Estimator
# with lambda set as 0.01
fit_plsim = plsim.vs.soft(x,z,y,lambda = 0.01)

# Test whether the parameters of parametric part estimated by plsim are zero
res_pTest_plsim = plsim.pTest(fit_plsim,TargetMethod = "plsim")

# Test whether the second parameter of parametric part estimated by plsim is zero
res_pTest_plsim_ = plsim.pTest(fit_plsim,parameterSelected = c(2),TargetMethod = "plsim")

</code></pre>

<hr>
<h2 id='plsim.vs.hard'>Variable Selection for Partial Linear Single Index Models</h2><span id='topic+plsim.vs.hard'></span><span id='topic+plsim.vs.hard.formula'></span><span id='topic+plsim.vs.hard.default'></span><span id='topic+stepWise'></span><span id='topic+dropOneVar'></span><span id='topic+varSelCore'></span><span id='topic+varSelCore.PPLSE'></span><span id='topic+varSelCore.StepWise'></span>

<h3>Description</h3>

<p>Variable Selection based on AIC, BIC, SCAD, LASSO and 
Elastic Net. The methods based on SCAD, LASSO and Elastic Net are implemented with Penalized Profile 
Least Squares Estimator, while AIC and BIC are implemented with Stepwise Regression.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plsim.vs.hard(...)

## S3 method for class 'formula'
plsim.vs.hard(formula, data, ...)

## Default S3 method:
plsim.vs.hard(xdat=NULL, zdat, ydat, h=NULL, zeta_i=NULL, 
lambdaList=NULL, l1RatioList=NULL, lambda_selector="BIC", threshold=0.05,
Method="SCAD", verbose=TRUE, ParmaSelMethod="SimpleValidation", seed=0, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plsim.vs.hard_+3A_...">...</code></td>
<td>
<p>additional arguments.</p>
</td></tr>
<tr><td><code id="plsim.vs.hard_+3A_formula">formula</code></td>
<td>
<p>a symbolic description of the model to be fitted.</p>
</td></tr>
<tr><td><code id="plsim.vs.hard_+3A_data">data</code></td>
<td>
<p>an optional data frame, list or environment containing the variables in the model.</p>
</td></tr>
<tr><td><code id="plsim.vs.hard_+3A_xdat">xdat</code></td>
<td>
<p>input matrix (linear covariates). The model reduces to a single index model when <code>x</code> is NULL.</p>
</td></tr>
<tr><td><code id="plsim.vs.hard_+3A_zdat">zdat</code></td>
<td>
<p>input matrix (nonlinear covariates). <code>z</code> should not be NULL.</p>
</td></tr>
<tr><td><code id="plsim.vs.hard_+3A_ydat">ydat</code></td>
<td>
<p>input vector (response variable).</p>
</td></tr>
<tr><td><code id="plsim.vs.hard_+3A_h">h</code></td>
<td>
<p>a numerical value or a vector for bandwidth. If <code>h</code> is NULL, a default vector c(0.01,0.02,0.05,0.1,0.5)
will be set for it. <a href="#topic+plsim.bw">plsim.bw</a> is employed to select the optimal bandwidth when h is a vector or NULL.</p>
</td></tr>
<tr><td><code id="plsim.vs.hard_+3A_zeta_i">zeta_i</code></td>
<td>
<p>initial coefficients, optional (default: NULL). It could be obtained by the function <code><a href="#topic+plsim.ini">plsim.ini</a></code>.
<code>zeta_i[1:ncol(z)]</code> is the initial coefficient vector <code class="reqn">\alpha_0</code>,
and <code>zeta_i[(ncol(z)+1):(ncol(z)+ncol(x))]</code> is the initial coefficient vector <code class="reqn">\beta_0</code>.</p>
</td></tr>
<tr><td><code id="plsim.vs.hard_+3A_verbose">verbose</code></td>
<td>
<p>bool, default: TRUE. Enable verbose output.</p>
</td></tr>
<tr><td><code id="plsim.vs.hard_+3A_method">Method</code></td>
<td>
<p>variable selection method, default: &quot;SCAD&quot;. It could be &quot;SCAD&quot;, &quot;LASSO&quot;, &quot;ElasticNet&quot;, &quot;AIC&quot; or &quot;BIC&quot;.</p>
</td></tr>
<tr><td><code id="plsim.vs.hard_+3A_lambdalist">lambdaList</code></td>
<td>
<p>the parameter for the function <a href="#topic+plsim.lam">plsim.lam</a>, default: &quot;NULL&quot;.</p>
</td></tr>
<tr><td><code id="plsim.vs.hard_+3A_l1ratiolist">l1RatioList</code></td>
<td>
<p>the parameter for the function <a href="#topic+plsim.lam">plsim.lam</a>, default: &quot;NULL&quot;.</p>
</td></tr>
<tr><td><code id="plsim.vs.hard_+3A_lambda_selector">lambda_selector</code></td>
<td>
<p>the parameter for the function <a href="#topic+plsim.lam">plsim.lam</a>, default: &quot;BIC&quot;.</p>
</td></tr>
<tr><td><code id="plsim.vs.hard_+3A_threshold">threshold</code></td>
<td>
<p>the threshold to select important variable according to the estimated coefficients.</p>
</td></tr>
<tr><td><code id="plsim.vs.hard_+3A_parmaselmethod">ParmaSelMethod</code></td>
<td>
<p>the parameter for the function <a href="#topic+plsim.bw">plsim.bw</a>.</p>
</td></tr>
<tr><td><code id="plsim.vs.hard_+3A_seed">seed</code></td>
<td>
<p>int, default: 0.</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>alpha_varSel</code></td>
<td>
<p>selected variables in <code>z</code>.</p>
</td></tr>
<tr><td><code>beta_varSel</code></td>
<td>
<p>selected variables in <code>x</code>.</p>
</td></tr>
<tr><td><code>fit_plsimest</code></td>
<td>
<p><code>fit_plsimest</code> is not NULL when <code>h</code> is a vector or NULL. 
For each bandwidth, <a href="#topic+plsim.est">plsim.est</a> is employed to integrate selected variabels. Finally, the optimal
fitted model will be selected according to BIC.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
# EXAMPLE 1 (INTERFACE=FORMULA)
# To select variables with Penalized Profile Least Squares Estimation based on 
# the penalty LASSO.

n = 50
dx = 10
dz = 5
sigma = 0.2
alpha = matrix(c(1,3,1.5,0.5,0),dz,1)
alpha = alpha/norm(alpha,"2")
beta = matrix(c(3,2,0,0,0,1.5,0,0.2,0.3,0.15),dx,1)

A = sqrt(3)/2-1.645/sqrt(12)
B = sqrt(3)/2+1.645/sqrt(12)
z = matrix(runif(n*dz),n,dz)
x = matrix(runif(n*dx),n,dx)
y = sin( (z%*%alpha - A) * 3.1415926 * (B-A) ) + x%*%beta + sigma*matrix(rnorm(n),n,1)

# Variable Selectioin Based on LASSO
res_varSel_LASSO = plsim.vs.hard(y~x|z,h=0.1,Method="LASSO")


# EXAMPLE 2 (INTERFACE=DATA FRAME)
# To select variables with Penalized Profile Least Squares Estimation based on 
# the penalty LASSO.

n = 50
dx = 10
dz = 5
sigma = 0.2
alpha = matrix(c(1,3,1.5,0.5,0),dz,1)
alpha = alpha/norm(alpha,"2")
beta = matrix(c(3,2,0,0,0,1.5,0,0.2,0.3,0.15),dx,1)

A = sqrt(3)/2-1.645/sqrt(12)
B = sqrt(3)/2+1.645/sqrt(12)
z = matrix(runif(n*dz),n,dz)
x = matrix(runif(n*dx),n,dx)
y = sin( (z%*%alpha - A) * 3.1415926 * (B-A) ) + x%*%beta + sigma*matrix(rnorm(n),n,1)

Z = data.frame(z)
X = data.frame(x)

# Variable Selectioin Based on LASSO
res_varSel_LASSO = plsim.vs.hard(xdat=X,zdat=Z,ydat=y,h=0.1,Method="LASSO")

</code></pre>

<hr>
<h2 id='plsim.vs.soft'>Penalized Profile Least Squares Estimator</h2><span id='topic+plsim.vs.soft'></span><span id='topic+plsim.vs.soft.formula'></span><span id='topic+plsim.vs.soft.default'></span>

<h3>Description</h3>

<p>PPLS along with introducing penalty terms so as to simultaneously
estimate parameters and select important variables in PLSiM 
</p>
<p style="text-align: center;"><code class="reqn">Y = \eta(Z^T\alpha) + X^T\beta + \epsilon</code>
</p>
<p>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plsim.vs.soft(...)

## S3 method for class 'formula'
plsim.vs.soft(formula, data, ...)

## Default S3 method:
plsim.vs.soft(xdat=NULL, zdat, ydat, h=NULL, zetaini=NULL, 
lambda=0.01, l1_ratio=NULL, MaxStep = 1L, penalty = "SCAD", verbose=TRUE, 
ParmaSelMethod="SimpleValidation", TestRatio=0.1, K = 3, seed=0, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plsim.vs.soft_+3A_...">...</code></td>
<td>
<p>additional arguments.</p>
</td></tr>
<tr><td><code id="plsim.vs.soft_+3A_formula">formula</code></td>
<td>
<p>a symbolic description of the model to be fitted.</p>
</td></tr>
<tr><td><code id="plsim.vs.soft_+3A_data">data</code></td>
<td>
<p>an optional data frame, list or environment containing the variables in the model.</p>
</td></tr>
<tr><td><code id="plsim.vs.soft_+3A_xdat">xdat</code></td>
<td>
<p>input matrix (linear covariates). The model reduces to a single index model when <code>x</code> is NULL.</p>
</td></tr>
<tr><td><code id="plsim.vs.soft_+3A_zdat">zdat</code></td>
<td>
<p>input matrix (nonlinear covariates). <code>z</code> should not be NULL.</p>
</td></tr>
<tr><td><code id="plsim.vs.soft_+3A_ydat">ydat</code></td>
<td>
<p>input vector (response variable).</p>
</td></tr>
<tr><td><code id="plsim.vs.soft_+3A_h">h</code></td>
<td>
<p>a value or a vector for bandwidth. If <code>h</code> is NULL, a default vector c(0.01,0.02,0.05,0.1,0.5)
will be set for it. <a href="#topic+plsim.bw">plsim.bw</a> is employed to select the optimal bandwidth when <code>h</code> is a vector or NULL.</p>
</td></tr>
<tr><td><code id="plsim.vs.soft_+3A_zetaini">zetaini</code></td>
<td>
<p>initial coefficients, optional (default: NULL). It could be obtained by the function <code><a href="#topic+plsim.ini">plsim.ini</a></code>.
<code>zetaini[1:ncol(z)]</code> is the initial coefficient vector <code class="reqn">\alpha_0</code>,
and <code>zetaini[(ncol(z)+1):(ncol(z)+ncol(x))]</code> is the initial coefficient vector <code class="reqn">{\beta}_0</code>.</p>
</td></tr>
<tr><td><code id="plsim.vs.soft_+3A_maxstep">MaxStep</code></td>
<td>
<p>int, optional (default=1). Hard limit on iterations within solver.</p>
</td></tr>
<tr><td><code id="plsim.vs.soft_+3A_lambda">lambda</code></td>
<td>
<p>double. Constant that multiplies the penalty term.</p>
</td></tr>
<tr><td><code id="plsim.vs.soft_+3A_l1_ratio">l1_ratio</code></td>
<td>
<p>double, default=NULL. It should be set with a value from the range <code class="reqn">[0,1]</code>
when you choose &quot;ElasticNet&quot; for the parameter <code>penalty</code>.</p>
</td></tr>
<tr><td><code id="plsim.vs.soft_+3A_penalty">penalty</code></td>
<td>
<p>string, optional (default=&quot;SCAD&quot;). It could be &quot;SCAD&quot;, &quot;LASSO&quot; and &quot;ElasticNet&quot;.</p>
</td></tr>
<tr><td><code id="plsim.vs.soft_+3A_verbose">verbose</code></td>
<td>
<p>bool, default: TRUE. Enable verbose output.</p>
</td></tr>
<tr><td><code id="plsim.vs.soft_+3A_parmaselmethod">ParmaSelMethod</code></td>
<td>
<p>the parameter for the function <a href="#topic+plsim.bw">plsim.bw</a>.</p>
</td></tr>
<tr><td><code id="plsim.vs.soft_+3A_testratio">TestRatio</code></td>
<td>
<p>the parameter for the function <a href="#topic+plsim.bw">plsim.bw</a>.</p>
</td></tr>
<tr><td><code id="plsim.vs.soft_+3A_k">K</code></td>
<td>
<p>the parameter for the function <a href="#topic+plsim.vs.soft">plsim.vs.soft</a>.</p>
</td></tr>
<tr><td><code id="plsim.vs.soft_+3A_seed">seed</code></td>
<td>
<p>int, default: 0.</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>eta</code></td>
<td>
<p>estimated non-parametric part <code class="reqn">\hat{\eta}(Z^T{\hat{\alpha} })</code>.</p>
</td></tr>
<tr><td><code>zeta</code></td>
<td>
<p>estimated coefficients. <code>zeta[1:ncol(z)]</code> is <code class="reqn">\hat{\alpha}</code>, 
and <code>zeta[(ncol(z)+1):(ncol(z)+ncol(x))]</code> is <code class="reqn">\hat{\beta}</code>.</p>
</td></tr>
<tr><td><code>y_hat</code></td>
<td>
 <p><code>y</code>'s estimates.</p>
</td></tr>
<tr><td><code>mse</code></td>
<td>
<p>mean squared errors between y and <code>y_hat</code>.</p>
</td></tr>
<tr><td><code>data</code></td>
<td>
<p>data information including <code>x</code>, <code>z</code>, <code>y</code>, bandwidth <code>h</code>, 
initial coefficients <code>zetaini</code>, iteration step <code>MaxStep</code>, flag <code>SiMflag</code>, 
<code>penalty</code>, <code>lambda</code> and <code>l1_ratio</code>.
<code>SiMflag</code> is TRUE when <code>x</code> is NULL, otherwise <code>SiMflag</code> is FALSE.</p>
</td></tr>
<tr><td><code>Z_alpha</code></td>
<td>
<p><code class="reqn">Z^T{\hat{\alpha}}</code>.</p>
</td></tr>
<tr><td><code>r_square</code></td>
<td>
<p>multiple correlation coefficient.</p>
</td></tr>
<tr><td><code>variance</code></td>
<td>
<p>variance of <code>y_hat</code>.</p>
</td></tr>
<tr><td><code>stdzeta</code></td>
<td>
<p>standard error of <code>zeta</code>.</p>
</td></tr>
</table>


<h3>References</h3>

<p>H. Liang, X. Liu, R. Li, C. L. Tsai. <em>Estimation and testing for partially linear single-index models</em>.
Annals of statistics, 2010, 38(6): 3811.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> 
# EXAMPLE 1 (INTERFACE=FORMULA)
# To estimate parameters of partially linear single-index model and select 
# variables using different penalization methods such as SCAD, LASSO, ElasticNet.

n = 50
sigma = 0.1

alpha = matrix(1,2,1)
alpha = alpha/norm(alpha,"2")

beta = matrix(4,1,1)

# Case 1: Matrix Input
x = matrix(1,n,1)
z = matrix(runif(n*2),n,2)
y = 4*((z%*%alpha-1/sqrt(2))^2) + x%*%beta + sigma*matrix(rnorm(n),n,1)

# Compute the penalized profile least-squares estimator with the SCAD penalty
fit_scad = plsim.vs.soft(y~x|z,lambda = 0.01)
summary(fit_scad)

# Compute the penalized profile least-squares estimator with the LASSO penalty
fit_lasso = plsim.vs.soft(y~x|z,lambda = 1e-3, penalty = "LASSO")
summary(fit_lasso)

# Compute the penalized profile least-squares estimator with the ElasticNet penalty
fit_enet = plsim.vs.soft(y~x|z,lambda = 1e-3, penalty = "ElasticNet")
summary(fit_enet)

# Case 2: Vector Input
x = rep(1,n)
z1 = runif(n)
z2 = runif(n) 
y = 4*((z%*%alpha-1/sqrt(2))^2) + x%*%beta + sigma*matrix(rnorm(n),n,1)

# Compute the penalized profile least-squares estimator with the SCAD penalty
fit_scad = plsim.vs.soft(y~x|z1+z2,lambda = 0.01)
summary(fit_scad)

# Compute the penalized profile least-squares estimator with the LASSO penalty
fit_lasso = plsim.vs.soft(y~x|z1+z2,lambda = 1e-3, penalty = "LASSO")
summary(fit_lasso)

# Compute the penalized profile least-squares estimator with the ElasticNet penalty
fit_enet = plsim.vs.soft(y~x|z1+z2,lambda = 1e-3, penalty = "ElasticNet")
summary(fit_enet)

# EXAMPLE 2 (INTERFACE=DATA FRAME)
# To estimate parameters of partially linear single-index model and select 
# variables using different penalization methods such as SCAD, LASSO, ElasticNet.

n = 50
sigma = 0.1

alpha = matrix(1,2,1)
alpha = alpha/norm(alpha,"2")

beta = matrix(4,1,1)

x = rep(1,n)
z1 = runif(n)
z2 = runif(n) 
X = data.frame(x)
Z = data.frame(z1,z2)

x = data.matrix(X)
z = data.matrix(Z)
y = 4*((z%*%alpha-1/sqrt(2))^2) + x%*%beta + sigma*matrix(rnorm(n),n,1)

# Compute the penalized profile least-squares estimator with the SCAD penalty
fit_scad = plsim.vs.soft(xdat=X,zdat=Z,ydat=y,lambda = 0.01)
summary(fit_scad)

# Compute the penalized profile least-squares estimator with the LASSO penalty
fit_lasso = plsim.vs.soft(xdat=X,zdat=Z,ydat=y,lambda = 1e-3, penalty = "LASSO")
summary(fit_lasso)

# Compute the penalized profile least-squares estimator with the ElasticNet penalty
fit_enet = plsim.vs.soft(xdat=X,zdat=Z,ydat=y,lambda = 1e-3, penalty = "ElasticNet")
summary(fit_enet)

</code></pre>

<hr>
<h2 id='predict.pls'>Predict according to the Estimated Parameters</h2><span id='topic+predict.pls'></span>

<h3>Description</h3>

<p>Predict Y based on new observations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'pls'
predict(object, x_test = NULL, z_test, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.pls_+3A_object">object</code></td>
<td>
<p>fitted partially linear single-index model, which could be obtained by</p>
</td></tr>
<tr><td><code id="predict.pls_+3A_x_test">x_test</code></td>
<td>
<p>input matrix (linear covariates of test set).</p>
</td></tr>
<tr><td><code id="predict.pls_+3A_z_test">z_test</code></td>
<td>
<p>input matrix (nonlinear covariates of test set).</p>
</td></tr>
<tr><td><code id="predict.pls_+3A_...">...</code></td>
<td>
<p>additional arguments.
</p>
<p><a href="#topic+plsim.MAVE">plsim.MAVE</a>, or <a href="#topic+plsim.est">plsim.est</a>, or <a href="#topic+plsim.vs.soft">plsim.vs.soft</a>.</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>y_hat</code></td>
<td>
<p>prediction.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
n = 50
sigma = 0.1

alpha = matrix(1, 2, 1)
alpha = alpha/norm(alpha, "2")

beta = matrix(4, 1, 1)

x = matrix(1, n, 1)
x_test = matrix(1,n,1)

z = matrix(runif(n*2), n, 2)
z_test = matrix(runif(n*2), n, 2)

y = 4*((z%*%alpha-1/sqrt(2))^2) + x%*%beta + sigma*matrix(rnorm(n),n,1)
y_test = 4*((z_test%*%alpha-1/sqrt(2))^2) + x_test%*%beta + sigma*matrix(rnorm(n),n,1)


# Obtain parameters in PLSiM using Profile Least Squares Estimator
fit_plsimest = plsim.est(x, z, y)

preds_plsimest = predict(fit_plsimest, x_test, z_test)

# Print the MSE of the Profile Least Squares Estimator method
print( sum( (preds_plsimest-y_test)^2)/nrow(y_test) )

# Obtain parameters in PLSiM using Penalized Profile Least Squares Estimator
fit_plsim = plsim.vs.soft(x, z, y,lambda = 0.01)

preds_plsim = predict(fit_plsim, x_test, z_test)

# Print the MSE of the Penalized Profile Least Squares Estimator method
print( sum( (preds_plsim-y_test)^2)/nrow(y_test) )

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
