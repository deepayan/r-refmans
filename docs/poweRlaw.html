<!DOCTYPE html><html lang="en-GB"><head><title>Help for package poweRlaw</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {poweRlaw}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#poweRlaw-package'><p>The poweRlaw package</p></a></li>
<li><a href='#bootstrap_moby'><p>Example bootstrap results for the full Moby Dick data set</p></a></li>
<li><a href='#compare_distributions'><p>Vuong's test for non-nested models</p></a></li>
<li><a href='#conlnorm-class'><p>Heavy-tailed distributions</p></a></li>
<li><a href='#dist_all_cdf'><p>The data cumulative distribution function</p></a></li>
<li><a href='#dist_cdf'><p>The cumulative distribution function (cdf)</p></a></li>
<li><a href='#dist_ll'><p>The log-likelihood function</p></a></li>
<li><a href='#dist_pdf'><p>The probability density function (pdf)</p></a></li>
<li><a href='#dist_rand'><p>Random number generation for the distribution objects</p></a></li>
<li><a href='#dplcon'><p>The continuous power-law distribution</p></a></li>
<li><a href='#dpldis'><p>Discrete power-law distribution</p></a></li>
<li><a href='#estimate_pars'><p>Estimates the distributions using mle.</p></a></li>
<li><a href='#get_bootstrap_sims'><p>Estimating the lower bound (xmin)</p></a></li>
<li><a href='#get_KS_statistic'><p>Deprecated function</p></a></li>
<li><a href='#get_n'><p>Sample size</p></a></li>
<li><a href='#get_ntail'><p>Values greater than or equal to xmin</p></a></li>
<li><a href='#lines+2Cdistribution-method'><p>Generic plotting functions</p></a></li>
<li><a href='#moby'><p>Moby Dick word count</p></a></li>
<li><a href='#native_american'><p>Casualties in the American Indian Wars (1776 and 1890)</p></a></li>
<li><a href='#plot.bs_xmin'><p>Plot methods for bootstrap objects</p></a></li>
<li><a href='#population'><p>City boundaries and the universality of scaling laws</p></a></li>
<li><a href='#show+2Cdistribution-method'><p>Generic show method for distribution objects</p></a></li>
<li><a href='#swiss_prot'><p>Word frequency in the Swiss-Prot database</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Analysis of Heavy Tailed Distributions</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.0</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Colin Gillespie &lt;csgillespie@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>An implementation of maximum likelihood estimators for a
    variety of heavy tailed distributions, including both the discrete and
    continuous power law distributions. Additionally, a goodness-of-fit
    based approach is used to estimate the lower cut-off for the scaling
    region.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/csgillespie/poweRlaw">https://github.com/csgillespie/poweRlaw</a>,
<a href="http://csgillespie.github.io/poweRlaw/">http://csgillespie.github.io/poweRlaw/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/csgillespie/poweRlaw/issues">https://github.com/csgillespie/poweRlaw/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.4.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>methods, parallel, pracma, stats, utils</td>
</tr>
<tr>
<td>Suggests:</td>
<td>covr, knitr, testthat</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>ByteCompile:</td>
<td>true</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Language:</td>
<td>en-GB</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>Collate:</td>
<td>'aaa_all_classes.R' 'all_generics.R' 'bootstrap.R'
'bootstrap_p.R' 'checks.R' 'compare_distributions.R'
'conlnorm.R' 'data_help_files.R' 'def_conexp.R' 'def_conpl.R'
'def_conweibull.R' 'def_disexp.R' 'def_dislnorm.R'
'def_displ.R' 'def_dispois.R' 'def_template.R'
'dist_data_cdf_methods.R' 'estimate_pars.R' 'estimate_xmin.R'
'get_n.R' 'get_ntail.R' 'lines_methods.R' 'plcon.R' 'pldis.R'
'plot_methods.R' 'points_methods.R' 'powerlaw-package.R'
'show_methods.R' 'timer.R'</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-02-02 21:28:29 UTC; colin</td>
</tr>
<tr>
<td>Author:</td>
<td>Colin Gillespie <a href="https://orcid.org/0000-0003-1787-0275"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-02-03 09:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='poweRlaw-package'>The poweRlaw package</h2><span id='topic+poweRlaw-package'></span><span id='topic+poweRlaw'></span><span id='topic+powerlaw'></span><span id='topic+powerlaw-package'></span>

<h3>Description</h3>

<p>The poweRlaw package aims to make fitting power laws and other heavy-tailed distributions
straightforward. This package contains R functions for fitting, comparing and visualising heavy
tailed distributions. Overall, it provides a principled approach to fitting power laws to data.
</p>


<h3>Details</h3>

<p>The code developed in this package has
been heavily influenced  by the R code of Laurent Dubroca and Cosma Shalizi.
</p>


<h3>Author(s)</h3>

<p><a href="mailto:colin.gillespie@newcastle.ac.uk">colin.gillespie@newcastle.ac.uk</a>
</p>


<h3>References</h3>

<p>A. Clauset, C.R. Shalizi, and M.E.J. Newman,
&quot;Power-law distributions in empirical data&quot; SIAM Review 51(4), 661-703 (2009).
</p>


<h3>See Also</h3>

<p><a href="https://github.com/csgillespie/poweRlaw">https://github.com/csgillespie/poweRlaw</a>
</p>

<hr>
<h2 id='bootstrap_moby'>Example bootstrap results for the full Moby Dick data set</h2><span id='topic+bootstrap_moby'></span><span id='topic+bootstrap_p_moby'></span>

<h3>Description</h3>

<p>To explore the uncertainty in the model fit, this package provides a
<code>bootstrap</code> function.
</p>

<dl>
<dt>bootstrap_moby</dt><dd><p>The output from running 5000 bootstraps on the full
Moby Dick data set (for a discrete power law)
using the <code>bootstrap</code> function. </p>
</dd>
<dt>bootstrap_p_moby</dt><dd><p>The output from running 5000 bootstraps on the full
Moby Dick data set (for a discrete power law)
using the <code>bootstrap_p</code> function.</p>
</dd></dl>

<p>The <code>bootstrap_moby</code> values correspond to the first row of
table 6.1 in the Clauset et al paper:
</p>

<dl>
<dt><code>bootstrap_moby$gof</code></dt><dd><p>the K-S statistic</p>
</dd>
<dt><code>bootstrap_moby$bootstraps</code></dt><dd><p>a data frame for the optimal
values from the bootstrapping procedure.
Column 1: K-S, Column 2: xmin, Column 3: alpha.
So standard deviation of column 2 and 3 is 2.2 and 0.033 (the paper gives 2
and 0.02 respectively).</p>
</dd>
</dl>

<p>The <code>bootstrap_p_moby</code> gives the p-value for the hypothesis
test of whether the data follows a power-law. For this simulation study,
we get a value of 0.43 (the paper gives 0.49).
</p>


<h3>Format</h3>

<p>A list
</p>


<h3>Source</h3>

<p>M. E. J. Newman, &quot;Power laws, Pareto distributions and Zipf's law.&quot;
Contemporary Physics 46, 323 (2005).
</p>


<h3>See Also</h3>

<p><code>moby</code>, <code>bootstrap</code>, <code>bootstrap_p</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Generate the bootstrap_moby data set
## Not run: 
data(moby)
m = displ$new(moby)
bs = bootstrap(m, no_of_sims=5000, threads=4, seed=1)

## End(Not run)

#' ## Generate the bootstrap_p_moby data set
## Not run: 
bs_p = bootstrap_p(m, no_of_sims=5000, threads=4, seed=1)

## End(Not run)

</code></pre>

<hr>
<h2 id='compare_distributions'>Vuong's test for non-nested models</h2><span id='topic+compare_distributions'></span>

<h3>Description</h3>

<p>Since it is possible to fit power law models to any data set,
it is recommended that alternative distributions are considered.
A standard technique is to use Vuong's test.
This is a likelihood ratio test for model selection using the
Kullback-Leibler criteria.
The test statistic, <code>R</code>, is the ratio of the
log-likelihoods of the data between the two competing models.
The sign of <code>R</code> indicates which model is better.
Since the value of <code>R</code> is estimated,
we use the method proposed by Vuong, 1989 to select the model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compare_distributions(d1, d2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="compare_distributions_+3A_d1">d1</code></td>
<td>
<p>A distribution object</p>
</td></tr>
<tr><td><code id="compare_distributions_+3A_d2">d2</code></td>
<td>
<p>A distribution object</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function compares two models.
The null hypothesis is that both classes of distributions are
equally far from the true distribution.  If this is true, the
log-likelihood ratio should (asymptotically) have a Normal distribution
with mean zero. The test statistic is the sample average of the
log-likelihood ratio, standardized by a consistent estimate of its standard
deviation.
If the null hypothesis is false, and one class of distributions is
closer to the &quot;truth&quot;, the test statistic goes to +/-infinity
with probability 1, indicating the better-fitting class of distributions.
</p>


<h3>Value</h3>

<p>This function returns
</p>

<dl>
<dt><code>test_statistic</code></dt><dd><p>The test statistic.</p>
</dd>
<dt><code>p_one_sided</code></dt><dd><p>A one-sided p-value, which is an upper limit
on getting that small a log-likelihood ratio if the
first distribution, <code>d1</code>, is actually true.</p>
</dd>
<dt><code>p_two_sided</code></dt><dd><p>A two-sided p-value, which is the probability
of getting a log-likelihood ratio which deviates that much from zero
in either direction, if the two distributions are actually equally good.</p>
</dd>
<dt><code>ratio</code></dt><dd><p>A data frame with two columns. The first column is
the <code>x</code> value and second column is the difference in
log-likelihoods.</p>
</dd></dl>



<h3>Note</h3>

<p>Code initially based on R code developed by
Cosma Rohilla Shalizi (<a href="http://bactra.org/">http://bactra.org/</a>).
Also see Appendix C in Clauset et al, 2009.
</p>


<h3>References</h3>

<p>Vuong, Quang H. (1989):
&quot;Likelihood Ratio Tests for Model Selection and Non-Nested Hypotheses&quot;,
Econometrica 57: 307&ndash;333.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>########################################################
# Example data                                         #
########################################################
x = rpldis(100, xmin=2, alpha=3)

########################################################
##Continuous power law                                 #
########################################################
m1 = conpl$new(x)
m1$setXmin(estimate_xmin(m1))

########################################################
##Exponential
########################################################
m2 = conexp$new(x)
m2$setXmin(m1$getXmin())
est2 = estimate_pars(m2)
m2$setPars(est2$pars)

########################################################
##Vuong's test                                         #
########################################################
comp = compare_distributions(m1, m2)
plot(comp)
</code></pre>

<hr>
<h2 id='conlnorm-class'>Heavy-tailed distributions</h2><span id='topic+conlnorm-class'></span><span id='topic+conlnorm'></span><span id='topic+conexp-class'></span><span id='topic+conexp'></span><span id='topic+conpl-class'></span><span id='topic+conpl'></span><span id='topic+conweibull-class'></span><span id='topic+conweibull'></span><span id='topic+disexp-class'></span><span id='topic+disexp'></span><span id='topic+dislnorm-class'></span><span id='topic+dislnorm'></span><span id='topic+displ-class'></span><span id='topic+displ'></span><span id='topic+dispois-class'></span><span id='topic+dispois'></span>

<h3>Description</h3>

<p>The <span class="pkg">poweRlaw</span> package supports a number of distributions:
</p>

<dl>
<dt>displ</dt><dd><p>Discrete power-law</p>
</dd>
<dt>dislnorm</dt><dd><p>Discrete log-normal</p>
</dd>
<dt>dispois</dt><dd><p>Discrete Poisson</p>
</dd>
<dt>disexp</dt><dd><p>Discrete Exponential</p>
</dd>
<dt>conpl</dt><dd><p>Continuous power-law</p>
</dd>
<dt>conlnorm</dt><dd><p>Continuous log-normal</p>
</dd>
<dt>conexp</dt><dd><p>Continuous exponential</p>
</dd></dl>

<p>Each object inherits the <code>discrete_distribution</code> or the <code>ctn_distribution</code> class.
</p>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="conlnorm-class_+3A_...">...</code></td>
<td>
<p>The object is typically created by passing
data using the <code>dat</code> field.
Each field has standard setters and getters.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The log-normal parametrise matches the base set-up, <code>?rlnorm</code>
</p>


<h3>Value</h3>

<p>a reference object
</p>


<h3>Fields</h3>

<p>Each distribution object has four fields. However, the object
is typically created by passing
data, to the <code>dat</code> field. Each field has standard
setters and getters. See examples below
</p>

<dl>
<dt>dat</dt><dd><p>The data set.</p>
</dd>
<dt>xmin</dt><dd><p>The lower threshold, xmin. Typically set after initialisation.
For the continuous  power-law, xmin &gt;= 0 for the discrete
distributions, xmin &gt;0</p>
</dd>
<dt>pars</dt><dd><p>A parameter vector. Typically set after initialisation.
Note the lognormal distribution has two parameters.</p>
</dd>
<dt>internal</dt><dd><p>A list. This list differs between objects and shouldn't be altered.</p>
</dd></dl>



<h3>Copying objects</h3>

<p>Distribution objects are reference classes. This means that when we copy
objects, we need to use the <code>copy</code> method, i.e. <code>obj$copy()</code>.
See the examples below for further details.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##############################################################
#Load data and create distribution object                    #
##############################################################
data(moby)
m = displ$new(moby)

##############################################################
#Xmin is initially the smallest x value                      #
##############################################################
m$getXmin()
m$getPars()

##############################################################
#Set Xmin and parameter                                      #
##############################################################
m$setXmin(2)
m$setPars(2)


##############################################################
#Plot the data and fitted distribution                       #
##############################################################
plot(m)
lines(m)
##############################################################
#Copying                                                     #
##############################################################
## Shallow copy
m_cpy = m
m_cpy$setXmin(5)
m$getXmin()
## Instead
m_cpy = m$copy()
</code></pre>

<hr>
<h2 id='dist_all_cdf'>The data cumulative distribution function</h2><span id='topic+dist_all_cdf'></span><span id='topic+dist_data_cdf'></span><span id='topic+dist_data_all_cdf'></span><span id='topic+dist_data_cdf+2Cdiscrete_distribution-method'></span><span id='topic+dist_data_all_cdf+2Cdiscrete_distribution-method'></span><span id='topic+dist_data_cdf+2Cctn_distribution-method'></span>

<h3>Description</h3>

<p>This is generic function for distribution objects.
This function calculates the data or empirical cdf.
</p>
<p>The functions <code>dist_data_all_cdf</code> and <code>dist_all_cdf</code> are only
available for discrete distributions.
Their main purpose is to optimise the bootstrap procedure, where generating a
vector <code>xmin:xmax</code> is
very quick. Also, when bootstrapping very large values can be generated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dist_all_cdf(m, lower_tail = TRUE, xmax = 1e+05)

dist_data_cdf(m, lower_tail = TRUE, xmax = 1e+05)

dist_data_all_cdf(m, lower_tail = TRUE, xmax = 1e+05)

## S4 method for signature 'discrete_distribution'
dist_data_cdf(m, lower_tail = TRUE, xmax = 1e+05)

## S4 method for signature 'discrete_distribution'
dist_data_all_cdf(m, lower_tail = TRUE, xmax = 1e+05)

## S4 method for signature 'ctn_distribution'
dist_data_cdf(m, lower_tail = TRUE, xmax = 1e+05)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dist_all_cdf_+3A_m">m</code></td>
<td>
<p>a distribution object.</p>
</td></tr>
<tr><td><code id="dist_all_cdf_+3A_lower_tail">lower_tail</code></td>
<td>
<p>logical; if <code>TRUE</code> (default),
probabilities are <code class="reqn">P[X \le x]</code>, otherwise, <code class="reqn">P[X &gt; x]</code>.</p>
</td></tr>
<tr><td><code id="dist_all_cdf_+3A_xmax">xmax</code></td>
<td>
<p>default <code>1e5</code>. The maximum x value calculated when working out the CDF.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>This method does <em>not</em> alter the internal state of
the distribution objects.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##########################################
#Load data and create distribution object#
##########################################
data(moby_sample)
m = displ$new(moby_sample)
m$setXmin(7);m$setPars(2)

##########################################
# The data cdf                           #
##########################################
dist_data_cdf(m)
</code></pre>

<hr>
<h2 id='dist_cdf'>The cumulative distribution function (cdf)</h2><span id='topic+dist_cdf'></span><span id='topic+dist_cdf+2Cconlnorm-method'></span><span id='topic+dist_all_cdf+2Cconlnorm-method'></span><span id='topic+dist_cdf+2Cconexp-method'></span><span id='topic+dist_all_cdf+2Cconexp-method'></span><span id='topic+dist_all_cdf+2Cconexo-method'></span><span id='topic+dist_cdf+2Cconpl-method'></span><span id='topic+dist_all_cdf+2Cconpl-method'></span><span id='topic+dist_cdf+2Cconweibull-method'></span><span id='topic+dist_all_cdf+2Cconweibull-method'></span><span id='topic+dist_cdf+2Cdisexp-method'></span><span id='topic+dist_all_cdf+2Cdisexp-method'></span><span id='topic+dist_cdf+2Cdislnorm-method'></span><span id='topic+dist_all_cdf+2Cdislnorm-method'></span><span id='topic+dist_cdf+2Cdispl-method'></span><span id='topic+dist_all_cdf+2Cdispl-method'></span><span id='topic+dist_cdf+2Cdispois-method'></span><span id='topic+dist_all_cdf+2Cdispois-method'></span>

<h3>Description</h3>

<p>This is a generic function for calculating
the cumulative distribution function (cdf) of
distribution objects. This is similar to base R's <code>pnorm</code>
for the normal distribution.
The <code>dist_cdf</code> function calculates the
cumulative probability distribution for the
current parameters and xmin value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dist_cdf(m, q = NULL, lower_tail = FALSE)

## S4 method for signature 'conlnorm'
dist_cdf(m, q = NULL, lower_tail = TRUE)

## S4 method for signature 'conlnorm'
dist_all_cdf(m, lower_tail = TRUE, xmax = 1e+05)

## S4 method for signature 'conexp'
dist_cdf(m, q = NULL, lower_tail = TRUE)

## S4 method for signature 'conexp'
dist_all_cdf(m, lower_tail = TRUE, xmax = 1e+05)

## S4 method for signature 'conpl'
dist_cdf(m, q = NULL, lower_tail = TRUE)

## S4 method for signature 'conpl'
dist_all_cdf(m, lower_tail = TRUE, xmax = 1e+05)

## S4 method for signature 'conweibull'
dist_cdf(m, q = NULL, lower_tail = TRUE)

## S4 method for signature 'conweibull'
dist_all_cdf(m, lower_tail = TRUE, xmax = 1e+05)

## S4 method for signature 'disexp'
dist_cdf(m, q = NULL, lower_tail = TRUE)

## S4 method for signature 'disexp'
dist_all_cdf(m, lower_tail = TRUE, xmax = 1e+05)

## S4 method for signature 'dislnorm'
dist_cdf(m, q = NULL, lower_tail = TRUE)

## S4 method for signature 'dislnorm'
dist_all_cdf(m, lower_tail = TRUE, xmax = 1e+05)

## S4 method for signature 'displ'
dist_cdf(m, q = NULL, lower_tail = TRUE)

## S4 method for signature 'displ'
dist_all_cdf(m, lower_tail = TRUE, xmax = 1e+05)

## S4 method for signature 'dispois'
dist_cdf(m, q = NULL, lower_tail = TRUE)

## S4 method for signature 'dispois'
dist_all_cdf(m, lower_tail = TRUE, xmax = 1e+05)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dist_cdf_+3A_m">m</code></td>
<td>
<p>a distribution object.</p>
</td></tr>
<tr><td><code id="dist_cdf_+3A_q">q</code></td>
<td>
<p>a vector values where the function will be evaluated.
If <code>q</code> is <code>NULL</code> (default), then the data values
will be used.</p>
</td></tr>
<tr><td><code id="dist_cdf_+3A_lower_tail">lower_tail</code></td>
<td>
<p>logical; if <code>TRUE</code> (default),
probabilities are <code class="reqn">P[X \le x]</code>, otherwise, <code class="reqn">P[X &gt; x]</code>.</p>
</td></tr>
<tr><td><code id="dist_cdf_+3A_xmax">xmax</code></td>
<td>
<p>default <code>1e5</code>. The maximum x value calculated when working out the CDF.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>This method does <em>not</em> alter the internal state of
the distribution objects.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##########################################
#Load data and create distribution object#
##########################################
data(moby_sample)
m = displ$new(moby_sample)
m$setXmin(7); m$setPars(2)

##########################################
#Calculate the CDF at a particular values#
##########################################
dist_cdf(m, 10:15)

##########################################
#Calculate the CDF at the data values    #
##########################################
dist_cdf(m)
</code></pre>

<hr>
<h2 id='dist_ll'>The log-likelihood function</h2><span id='topic+dist_ll'></span><span id='topic+dist_ll+2Cconlnorm-method'></span><span id='topic+dist_ll+2Cconexp-method'></span><span id='topic+dist_ll+2Cconpl-method'></span><span id='topic+dist_ll+2Cconweibull-method'></span><span id='topic+dist_ll+2Cdisexp-method'></span><span id='topic+dist_ll+2Cdislnorm-method'></span><span id='topic+dist_ll+2Cdispl-method'></span><span id='topic+dist_ll+2Cdispois-method'></span>

<h3>Description</h3>

<p>This is generic function for distribution objects.
This function calculates the log-likelihood for the current
parameters and xmin value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dist_ll(m)

## S4 method for signature 'conlnorm'
dist_ll(m)

## S4 method for signature 'conexp'
dist_ll(m)

## S4 method for signature 'conpl'
dist_ll(m)

## S4 method for signature 'conweibull'
dist_ll(m)

## S4 method for signature 'disexp'
dist_ll(m)

## S4 method for signature 'dislnorm'
dist_ll(m)

## S4 method for signature 'displ'
dist_ll(m)

## S4 method for signature 'dispois'
dist_ll(m)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dist_ll_+3A_m">m</code></td>
<td>
<p>a distribution object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The log-likelihood
</p>


<h3>Note</h3>

<p>This method does <em>not</em> alter the internal state of
the distribution objects.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dist_cdf">dist_cdf()</a></code>,  <code><a href="#topic+dist_pdf">dist_pdf()</a></code>
and <code><a href="#topic+dist_rand">dist_rand()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##########################################
#Load data and create distribution object#
##########################################
data(moby_sample)
m = displ$new(moby_sample)
m$setXmin(7); m$setPars(2)

##########################################
#Calculate the log-likelihood            #
##########################################
dist_ll(m)
</code></pre>

<hr>
<h2 id='dist_pdf'>The probability density function (pdf)</h2><span id='topic+dist_pdf'></span><span id='topic+dist_pdf+2Cconlnorm-method'></span><span id='topic+dist_pdf+2Cconexp-method'></span><span id='topic+dist_pdf+2Cconpl-method'></span><span id='topic+dist_pdf+2Cconweibull-method'></span><span id='topic+dist_pdf+2Cdisexp-method'></span><span id='topic+dist_pdf+2Cdislnorm-method'></span><span id='topic+dist_pdf+2Cdispl-method'></span><span id='topic+dist_pdf+2Cdispois-method'></span>

<h3>Description</h3>

<p>This is generic function for distribution objects.
This function calculates the probability density function (pdf)
for the current parameters and xmin value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dist_pdf(m, q = NULL, log = FALSE)

## S4 method for signature 'conlnorm'
dist_pdf(m, q = NULL, log = FALSE)

## S4 method for signature 'conexp'
dist_pdf(m, q = NULL, log = FALSE)

## S4 method for signature 'conpl'
dist_pdf(m, q = NULL, log = FALSE)

## S4 method for signature 'conweibull'
dist_pdf(m, q = NULL, log = FALSE)

## S4 method for signature 'disexp'
dist_pdf(m, q = NULL, log = FALSE)

## S4 method for signature 'dislnorm'
dist_pdf(m, q = NULL, log = FALSE)

## S4 method for signature 'displ'
dist_pdf(m, q = NULL, log = FALSE)

## S4 method for signature 'dispois'
dist_pdf(m, q = NULL, log = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dist_pdf_+3A_m">m</code></td>
<td>
<p>a distribution object.</p>
</td></tr>
<tr><td><code id="dist_pdf_+3A_q">q</code></td>
<td>
<p>a vector values where the function will be evaluated.
If <code>q</code> is <code>NULL</code> (default), then the data values
will be used.</p>
</td></tr>
<tr><td><code id="dist_pdf_+3A_log">log</code></td>
<td>
<p>default <code>FALSE</code>. If <code>TRUE</code>, probabilities are given as log(p).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The probability density (or mass) function
</p>


<h3>Note</h3>

<p>This method does <em>not</em> alter the internal state of
the distribution objects.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dist_cdf">dist_cdf()</a></code>, <code><a href="#topic+dist_ll">dist_ll()</a></code>
and <code><a href="#topic+dist_rand">dist_rand()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##########################################
#Create distribution object              #
##########################################
m = displ$new()
m$setXmin(7); m$setPars(2)

##########################################
#Calculate the pdf at particular values  #
##########################################
dist_pdf(m, 7:10)
</code></pre>

<hr>
<h2 id='dist_rand'>Random number generation for the distribution objects</h2><span id='topic+dist_rand'></span><span id='topic+dist_rand+2Cconlnorm-method'></span><span id='topic+dist_rand+2Cconexp-method'></span><span id='topic+dist_rand+2Cconpl-method'></span><span id='topic+dist_rand+2Cconweibull-method'></span><span id='topic+dist_rand+2Cdisexp-method'></span><span id='topic+dist_rand+2Cdislnorm-method'></span><span id='topic+dist_rand+2Cdispl-method'></span><span id='topic+dist_rand+2Cdispois-method'></span>

<h3>Description</h3>

<p>This is generic function for generating random numbers
from the underlying distribution of the distribution reference objects.
This function generates <code>n</code> random numbers using the parameters
and xmin values found in the associated reference object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dist_rand(m, n)

## S4 method for signature 'conlnorm'
dist_rand(m, n = "numeric")

## S4 method for signature 'conexp'
dist_rand(m, n = "numeric")

## S4 method for signature 'conpl'
dist_rand(m, n = "numeric")

## S4 method for signature 'conweibull'
dist_rand(m, n = "numeric")

## S4 method for signature 'disexp'
dist_rand(m, n = "numeric")

## S4 method for signature 'dislnorm'
dist_rand(m, n = "numeric")

## S4 method for signature 'displ'
dist_rand(m, n = "numeric")

## S4 method for signature 'dispois'
dist_rand(m, n = "numeric")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dist_rand_+3A_m">m</code></td>
<td>
<p>a distribution object.</p>
</td></tr>
<tr><td><code id="dist_rand_+3A_n">n</code></td>
<td>
<p>number of observations to be generated.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>n random numbers
</p>


<h3>Note</h3>

<p>This method does <em>not</em> alter the internal state of
the distribution object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dist_cdf">dist_cdf()</a></code>, <code><a href="#topic+dist_pdf">dist_pdf()</a></code>
and <code><a href="#topic+dist_ll">dist_ll()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##########################################
#Create distribution object              #
##########################################
m = displ$new()
m$setXmin(7);m$setPars(2)

##########################################
#Generate five random numbers            #
##########################################
dist_rand(m, 5)
</code></pre>

<hr>
<h2 id='dplcon'>The continuous power-law distribution</h2><span id='topic+dplcon'></span><span id='topic+pplcon'></span><span id='topic+rplcon'></span>

<h3>Description</h3>

<p>Density and distribution function of the continuous power-law distribution, with
parameters xmin and alpha.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dplcon(x, xmin, alpha, log = FALSE)

pplcon(q, xmin, alpha, lower.tail = TRUE)

rplcon(n, xmin, alpha)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dplcon_+3A_x">x</code>, <code id="dplcon_+3A_q">q</code></td>
<td>
<p>vector of quantiles. The discrete
power-law distribution is defined for <code>x &gt; xmin</code></p>
</td></tr>
<tr><td><code id="dplcon_+3A_xmin">xmin</code></td>
<td>
<p>The lower bound of the power-law distribution.
For the continuous power-law, xmin &gt;= 0.
for the discrete distribution, xmin &gt; 0.</p>
</td></tr>
<tr><td><code id="dplcon_+3A_alpha">alpha</code></td>
<td>
<p>The scaling parameter: alpha &gt; 1.</p>
</td></tr>
<tr><td><code id="dplcon_+3A_log">log</code></td>
<td>
<p>logical (default FALSE) if TRUE, log values are returned.</p>
</td></tr>
<tr><td><code id="dplcon_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical;
if TRUE (default), probabilities are <code class="reqn">P[X \le x]</code>,
otherwise, <code class="reqn">P[X &gt; x]</code>.</p>
</td></tr>
<tr><td><code id="dplcon_+3A_n">n</code></td>
<td>
<p>Number of observations. If <code>length(n) &gt; 1</code>, the length is
taken to be the number required.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>dplcon</code> gives the density and <code>pplcon</code> gives the distribution function.
</p>


<h3>Note</h3>

<p>The discrete random number generator is very inefficient
</p>


<h3>Examples</h3>

<pre><code class='language-R'>xmin = 1; alpha = 1.5
x = seq(xmin, 10, length.out=1000)
plot(x, dplcon(x, xmin, alpha), type="l")
plot(x, pplcon(x, xmin, alpha), type="l", main="Distribution function")
n = 1000
con_rns = rplcon(n, xmin, alpha)
con_rns = sort(con_rns)
p = rep(1/n, n)
#Zipfs plot
plot(con_rns, rev(cumsum(p)), log="xy", type="l")
</code></pre>

<hr>
<h2 id='dpldis'>Discrete power-law distribution</h2><span id='topic+dpldis'></span><span id='topic+ppldis'></span><span id='topic+rpldis'></span>

<h3>Description</h3>

<p>Density, distribution function and random number generation
for the discrete power law distribution with parameters xmin and alpha.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dpldis(x, xmin, alpha, log = FALSE)

ppldis(q, xmin, alpha, lower.tail = TRUE)

rpldis(n, xmin, alpha, discrete_max = 10000)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dpldis_+3A_x">x</code>, <code id="dpldis_+3A_q">q</code></td>
<td>
<p>vector of quantiles. The discrete
power-law distribution is defined for x &gt; xmin.</p>
</td></tr>
<tr><td><code id="dpldis_+3A_xmin">xmin</code></td>
<td>
<p>The lower bound of the power-law distribution.
For the continuous power-law, xmin &gt;= 0.
for the discrete distribution, xmin &gt; 0.</p>
</td></tr>
<tr><td><code id="dpldis_+3A_alpha">alpha</code></td>
<td>
<p>The scaling parameter: alpha &gt; 1.</p>
</td></tr>
<tr><td><code id="dpldis_+3A_log">log</code></td>
<td>
<p>logical (default FALSE) if TRUE, log values are returned.</p>
</td></tr>
<tr><td><code id="dpldis_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical;
if TRUE (default), probabilities are <code class="reqn">P[X \le x]</code>,
otherwise, <code class="reqn">P[X &gt; x]</code>.</p>
</td></tr>
<tr><td><code id="dpldis_+3A_n">n</code></td>
<td>
<p>Number of observations. If <code>length(n) &gt; 1</code>, the length is
taken to be the number required.</p>
</td></tr>
<tr><td><code id="dpldis_+3A_discrete_max">discrete_max</code></td>
<td>
<p>The value when we switch from the discrete random
numbers to a CTN approximation.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Clauset, 2009 paper provides an algorithm for generating discrete random numbers.
However, if this algorithm is implemented in R, it gives terrible performance.
This is because the algorithm involves &quot;growing vectors&quot;.
Another problem is when alpha is close to 1, this can result in very large random
number being generated (which means we need
to calculate the discrete CDF for very large values).
</p>
<p>The algorithm provided in this package generates true
discrete random numbers up to 10,000 then switches to
using continuous random numbers. This switching point can altered by
changing the <code>discrete_max</code> argument.
</p>
<p>In order to get a efficient power-law discrete random number generator, the
algorithm needs to be implemented in C.
</p>


<h3>Value</h3>

<p>dpldis returns the density, ppldis returns the distribution function
and rpldis return random numbers.
</p>


<h3>Note</h3>

<p>The naming of these functions mirrors standard R functions, i.e. dnorm.
When alpha is close to one, generating random number can be very slow.
</p>


<h3>References</h3>

<p>Clauset, Aaron, Cosma Rohilla Shalizi, and Mark EJ Newman.
&quot;Power-law distributions in empirical data.&quot; SIAM review 51.4 (2009): 661-703.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>xmin = 1; alpha = 2
x = xmin:100

plot(x, dpldis(x, xmin, alpha), type="l")
plot(x, ppldis(x, xmin, alpha), type="l", main="Distribution function")
dpldis(1, xmin, alpha)

###############################################
## Random number generation                   #
###############################################
n = 1e5
x1 = rpldis(n, xmin, alpha)
## Compare with exact (dpldis(1, xmin, alpha))
sum(x1==1)/n
## Using only the approximation
x2 = rpldis(n, xmin, alpha, 0)
sum(x2==1)/n

</code></pre>

<hr>
<h2 id='estimate_pars'>Estimates the distributions using mle.</h2><span id='topic+estimate_pars'></span>

<h3>Description</h3>

<p><code>estimate_pars</code> estimates the distribution's
parameters using their maximum likelihood estimator. This estimate
is conditional on the current xmin value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimate_pars(m, pars = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="estimate_pars_+3A_m">m</code></td>
<td>
<p>A reference class object that contains the data.</p>
</td></tr>
<tr><td><code id="estimate_pars_+3A_pars">pars</code></td>
<td>
<p>default <code>NULL</code>. A vector or matrix (number of columns equal
to the number of parameters) of parameters used to #' optimise over.
Otherwise, for each value of <code>xmin</code>, the mle will be used, i.e. <code>estimate_pars(m)</code>.
For small samples, the mle may be biased.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns list.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(moby_sample)
m = displ$new(moby_sample)
estimate_xmin(m)
m$setXmin(7)
estimate_pars(m)
</code></pre>

<hr>
<h2 id='get_bootstrap_sims'>Estimating the lower bound (xmin)</h2><span id='topic+get_bootstrap_sims'></span><span id='topic+bootstrap'></span><span id='topic+get_bootstrap_p_sims'></span><span id='topic+bootstrap_p'></span><span id='topic+get_distance_statistic'></span><span id='topic+estimate_xmin'></span>

<h3>Description</h3>

<p>When fitting heavy tailed distributions, sometimes it
is necessary to estimate the lower threshold, xmin. The
lower bound is estimated by minimising the
Kolmogorov-Smirnoff statistic
(as described in Clauset, Shalizi, Newman (2009)).
</p>

<dl>
<dt><code>get_KS_statistic</code></dt><dd><p>Calculates the KS statistic for a particular value of xmin.</p>
</dd>
<dt><code>estimate_xmin</code></dt><dd><p>Estimates the optimal lower cutoff using a
goodness-of-fit based approach. This function may issue <code>warnings</code>
when fitting lognormal, Poisson or Exponential distributions. The
warnings occur for large values of <code>xmin</code>. Essentially, we are discarding
the bulk of the distribution and cannot calculate the tails to enough
accuracy.</p>
</dd>
<dt><code>bootstrap</code></dt><dd><p>Estimates the uncertainty in the xmin and parameter values
via bootstrapping.</p>
</dd>
<dt><code>bootstrap_p</code></dt><dd><p>Performs a bootstrapping hypothesis test to determine
whether a suggested
(typically power law) distribution is plausible. This is only available for distributions that
have <code>dist_rand</code> methods available.</p>
</dd></dl>



<h3>Usage</h3>

<pre><code class='language-R'>get_bootstrap_sims(m, no_of_sims, seed, threads = 1)

bootstrap(
  m,
  xmins = NULL,
  pars = NULL,
  xmax = 1e+05,
  no_of_sims = 100,
  threads = 1,
  seed = NULL,
  distance = "ks"
)

get_bootstrap_p_sims(m, no_of_sims, seed, threads = 1)

bootstrap_p(
  m,
  xmins = NULL,
  pars = NULL,
  xmax = 1e+05,
  no_of_sims = 100,
  threads = 1,
  seed = NULL,
  distance = "ks"
)

get_distance_statistic(m, xmax = 1e+05, distance = "ks")

estimate_xmin(m, xmins = NULL, pars = NULL, xmax = 1e+05, distance = "ks")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_bootstrap_sims_+3A_m">m</code></td>
<td>
<p>A reference class object that contains the data.</p>
</td></tr>
<tr><td><code id="get_bootstrap_sims_+3A_no_of_sims">no_of_sims</code></td>
<td>
<p>number of bootstrap simulations. When <code>no_of_sims</code> is large, this can
take a while to run.</p>
</td></tr>
<tr><td><code id="get_bootstrap_sims_+3A_seed">seed</code></td>
<td>
<p>default <code>NULL</code>. An integer to be supplied to <code>set.seed</code>, or <code>NULL</code>
not to set reproducible seeds. This argument is passed <code>clusterSetRNGStream</code>.</p>
</td></tr>
<tr><td><code id="get_bootstrap_sims_+3A_threads">threads</code></td>
<td>
<p>number of concurrent threads used during the bootstrap.</p>
</td></tr>
<tr><td><code id="get_bootstrap_sims_+3A_xmins">xmins</code></td>
<td>
<p>default <code>1e5</code>. A vector of possible values
of xmin to explore. When a single value is passed, this represents
the maximum value to search, i.e. by default we search from
(1, 1e5). See details for further information.</p>
</td></tr>
<tr><td><code id="get_bootstrap_sims_+3A_pars">pars</code></td>
<td>
<p>default <code>NULL</code>. A vector or matrix (number of columns equal
to the number of parameters) of parameters used to #' optimise over.
Otherwise, for each value of <code>xmin</code>, the mle will be used, i.e. <code>estimate_pars(m)</code>.
For small samples, the mle may be biased.</p>
</td></tr>
<tr><td><code id="get_bootstrap_sims_+3A_xmax">xmax</code></td>
<td>
<p>default <code>1e5</code>. The maximum x value calculated when working out the CDF.
See details for further
information.</p>
</td></tr>
<tr><td><code id="get_bootstrap_sims_+3A_distance">distance</code></td>
<td>
<p>A string containing the distance measure (or measures) to calculate.
Possible values are <code>ks</code> or <code>reweight</code>. See details for further information.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When estimating <code>xmin</code> for discrete distributions, the search space when
comparing the data-cdf (empirical cdf)
and the distribution_cdf runs from xmin to <code>max(x)</code>
where <code>x</code> is the data set. This <strong>can</strong> often be
computationally brutal. In particular, when bootstrapping
we generate random numbers from the power law distribution,
which has a long tail.
</p>
<p>To speed up computations for discrete distributions it is sensible to put an
upper bound, i.e. <code>xmax</code> and/or explicitly give values of where to search, i.e. <code>xmin</code>.
</p>
<p>Occasionally bootstrapping can generate strange situations. For example,
all values in the simulated data set are less then <code>xmin</code>. In this case,
the estimated distance measure will be <code>Inf</code> and the parameter values, <code>NA</code>.
</p>
<p>There are other possible distance measures that can be calculated. The default is the
Kolomogorov Smirnoff statistic (<code>KS</code>). This is equation 3.9 in the CSN paper. The
other measure currently available is <code>reweight</code>, which is equation 3.11.
</p>


<h3>Note</h3>

<p>Adapted from Laurent Dubroca's code
</p>


<h3>Examples</h3>

<pre><code class='language-R'>###################################################
# Load the data set and create distribution object#
###################################################
x = 1:10
m = displ$new(x)

###################################################
# Estimate xmin and pars                          #
###################################################
est = estimate_xmin(m)
m$setXmin(est)

###################################################
# Bootstrap examples                              #
###################################################
## Not run: 
bootstrap(m, no_of_sims=1, threads=1)
bootstrap_p(m, no_of_sims=1, threads=1)

## End(Not run)
</code></pre>

<hr>
<h2 id='get_KS_statistic'>Deprecated function</h2><span id='topic+get_KS_statistic'></span>

<h3>Description</h3>

<p>This function is now deprecated and may be removed in future
versions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_KS_statistic(m, xmax = 1e+05, distance = "ks")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_KS_statistic_+3A_m">m</code></td>
<td>
<p>A reference class object that contains the data.</p>
</td></tr>
<tr><td><code id="get_KS_statistic_+3A_xmax">xmax</code></td>
<td>
<p>default <code>1e5</code>. The maximum x value calculated when working out the CDF.
See details for further
information.</p>
</td></tr>
<tr><td><code id="get_KS_statistic_+3A_distance">distance</code></td>
<td>
<p>A string containing the distance measure (or measures) to calculate.
Possible values are <code>ks</code> or <code>reweight</code>. See details for further information.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>get_distance_statistic
</p>

<hr>
<h2 id='get_n'>Sample size</h2><span id='topic+get_n'></span>

<h3>Description</h3>

<p>Returns the sample size of the data set contained within the
distribution object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_n(m)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_n_+3A_m">m</code></td>
<td>
<p>a distribution object.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>################################################
# Load data and create example object
################################################
data(moby_sample)
m = displ$new(moby_sample)
################################################
# get_n and length should return the same value
################################################
get_n(m)
length(moby_sample)
</code></pre>

<hr>
<h2 id='get_ntail'>Values greater than or equal to xmin</h2><span id='topic+get_ntail'></span>

<h3>Description</h3>

<p>Returns the number of data points greater than or equal to
current value of xmin. In the Clauset et al, paper this is
called <code>ntail</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_ntail(m, prop = FALSE, lower = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_ntail_+3A_m">m</code></td>
<td>
<p>a distribution object.</p>
</td></tr>
<tr><td><code id="get_ntail_+3A_prop">prop</code></td>
<td>
<p>default <code>FALSE</code>. Return the value as a proportion of the total sample size</p>
</td></tr>
<tr><td><code id="get_ntail_+3A_lower">lower</code></td>
<td>
<p>default <code>FALSE</code>. If <code>TRUE</code> returns sample size  - ntail</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>################################################
# Load data and create example object
################################################
data(moby_sample)
m = displ$new(moby_sample)
m$setXmin(7)
################################################
# Get ntail
################################################
get_ntail(m)
sum(moby_sample &gt;= 7)
</code></pre>

<hr>
<h2 id='lines+2Cdistribution-method'>Generic plotting functions</h2><span id='topic+lines+2Cdistribution-method'></span><span id='topic+plot+2Cdistribution-method'></span><span id='topic+points+2Cdistribution-method'></span>

<h3>Description</h3>

<p>These are generic functions for distribution  reference
objects. Standard plotting functions, i.e. plot, points, and lines work
with all distribution objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'distribution'
lines(x, cut = FALSE, draw = TRUE, length.out = 100, ...)

## S4 method for signature 'distribution'
plot(x, cut = FALSE, draw = TRUE, ...)

## S4 method for signature 'distribution'
points(x, cut = FALSE, draw = TRUE, length.out = 100, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lines+2B2Cdistribution-method_+3A_x">x</code></td>
<td>
<p>a distribution reference object.</p>
</td></tr>
<tr><td><code id="lines+2B2Cdistribution-method_+3A_cut">cut</code></td>
<td>
<p>logical (default <code>FALSE</code>) -
Where should the plot begin. If <code>cut=FALSE</code>, then the
plot will start at the minimum data value. Otherwise, the plot
will start from <code>xmin</code></p>
</td></tr>
<tr><td><code id="lines+2B2Cdistribution-method_+3A_draw">draw</code></td>
<td>
<p>logical (default <code>TRUE</code>). Should the plot/lines/points function plot or
return the data (in a data frame object).</p>
</td></tr>
<tr><td><code id="lines+2B2Cdistribution-method_+3A_length.out">length.out</code></td>
<td>
<p>numeric, default 100. How many points should the
distribution be evaluated at. This argument is only
for plotting the fitted lines.</p>
</td></tr>
<tr><td><code id="lines+2B2Cdistribution-method_+3A_...">...</code></td>
<td>
<p>Further arguments passed to the <code>lines</code> functions.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>This method does <em>not</em> alter the internal state of
the distribution objects.
</p>

<hr>
<h2 id='moby'>Moby Dick word count</h2><span id='topic+moby'></span><span id='topic+moby_sample'></span>

<h3>Description</h3>

<p>The frequency of occurrence of unique words in the novel Moby Dick
by Herman Melville.
</p>
<p>The data set moby_sample is 2000 values
sampled from the moby data set.
</p>


<h3>Format</h3>

<p>A vector
</p>


<h3>Source</h3>

<p>M. E. J. Newman, &quot;Power laws, Pareto distributions and Zipf's law.&quot;
Contemporary Physics 46, 323 (2005).
</p>

<hr>
<h2 id='native_american'>Casualties in the American Indian Wars (1776 and 1890)</h2><span id='topic+native_american'></span><span id='topic+NativeAmerican'></span><span id='topic+USAmerican'></span><span id='topic+us_american'></span>

<h3>Description</h3>

<p>These data files contain the observed casualties in the American Indian Wars.
The data sets <code>native_american</code> and <code>us_american</code> contain the
casualties on the Native American and US American
sides respectively. Each data set is a data frame, with two columns:
the number of casualties and the conflict date.
</p>


<h3>Format</h3>

<p>Data frame
</p>


<h3>Source</h3>

<p>Friedman, Jeffrey A. &quot;Using Power Laws to Estimate Conflict Size.&quot;
The Journal of conflict resolution (2014).
</p>

<hr>
<h2 id='plot.bs_xmin'>Plot methods for bootstrap objects</h2><span id='topic+plot.bs_xmin'></span><span id='topic+plot.bs_p_xmin'></span><span id='topic+plot.compare_distributions'></span>

<h3>Description</h3>

<p>A simple wrapper around the plot function to aid with visualising the bootstrap results.
The values plotted are returned as an invisible object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bs_xmin'
plot(x, trim = 0.1, ...)

## S3 method for class 'bs_p_xmin'
plot(x, trim = 0.1, ...)

## S3 method for class 'compare_distributions'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.bs_xmin_+3A_x">x</code></td>
<td>
<p>an object of class <code>bs_xmin</code> or <code>bs_p_xmin</code></p>
</td></tr>
<tr><td><code id="plot.bs_xmin_+3A_trim">trim</code></td>
<td>
<p>When plotting the cumulative means and standard deviation,
the first trim percentage of values are not displayed. default <code>trim=0.1</code></p>
</td></tr>
<tr><td><code id="plot.bs_xmin_+3A_...">...</code></td>
<td>
<p>graphics parameters to be passed to the plotting routines.</p>
</td></tr>
</table>

<hr>
<h2 id='population'>City boundaries and the universality of scaling laws</h2><span id='topic+population'></span><span id='topic+Population'></span>

<h3>Description</h3>

<p>This data set contains the population size of cities and towns in England.
For further details on the algorithm used to determine city boundries, see the referenced paper.
</p>


<h3>Format</h3>

<p>vector
</p>


<h3>Source</h3>

<p>Arcaute, Elsa, et al. &quot;City boundaries and the universality of scaling laws.&quot;
arXiv preprint arXiv:1301.1674 (2013).
</p>

<hr>
<h2 id='show+2Cdistribution-method'>Generic show method for distribution objects</h2><span id='topic+show+2Cdistribution-method'></span>

<h3>Description</h3>

<p>The distribution objects have an internal structure that is used for caching purposes.
Using the default <code>show</code> method gives the illusion of duplicate values.
This show method aims to avoid this confusion.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'distribution'
show(object)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="show+2B2Cdistribution-method_+3A_object">object</code></td>
<td>
<p>A distribution object.</p>
</td></tr>
</table>

<hr>
<h2 id='swiss_prot'>Word frequency in the Swiss-Prot database</h2><span id='topic+swiss_prot'></span><span id='topic+Swiss_prot'></span>

<h3>Description</h3>

<p>This dataset contains all the words extracted from the
Swiss-Prot version 9 data (with the resulting frequency for each word).
Other datasets for other database versions can be obtained by contacting
Michael Bell
</p>
<p>Full details in http://arxiv.org/abs/arXiv:1208.2175v1
</p>


<h3>Format</h3>

<p>data frame
</p>


<h3>Source</h3>

<p>Bell, MJ, Gillespie, CS, Swan, D, Lord, P.
An approach to describing and analysing bulk biological annotation
quality: A case study using UniProtKB.
Bioinformatics 2012, 28, i562-i568.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
