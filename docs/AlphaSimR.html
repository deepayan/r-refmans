<!DOCTYPE html><html><head><title>Help for package AlphaSimR</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {AlphaSimR}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#AlphaSimR-package'><p>AlphaSimR: Breeding Program Simulations</p></a></li>
<li><a href='#.newPop'><p>Create new population (internal)</p></a></li>
<li><a href='#aa'><p>Additive-by-additive epistatic deviations</p></a></li>
<li><a href='#addSegSite'><p>Add segregating site to MapPop</p></a></li>
<li><a href='#attrition'><p>Lose individuals at random</p></a></li>
<li><a href='#bv'><p>Breeding value</p></a></li>
<li><a href='#calcGCA'><p>Calculate GCA</p></a></li>
<li><a href='#cChr'><p>Combine MapPop chromosomes</p></a></li>
<li><a href='#dd'><p>Dominance deviations</p></a></li>
<li><a href='#doubleGenome'><p>Double the ploidy of individuals</p></a></li>
<li><a href='#ebv'><p>Estimated breeding value</p></a></li>
<li><a href='#editGenome'><p>Edit genome</p></a></li>
<li><a href='#editGenomeTopQtl'><p>Edit genome - the top QTL</p></a></li>
<li><a href='#fastRRBLUP'><p>Fast RR-BLUP</p></a></li>
<li><a href='#genicVarA'><p>Additive genic variance</p></a></li>
<li><a href='#genicVarAA'><p>Additive-by-additive genic variance</p></a></li>
<li><a href='#genicVarD'><p>Dominance genic variance</p></a></li>
<li><a href='#genicVarG'><p>Total genic variance</p></a></li>
<li><a href='#genParam'><p>Sumarize genetic parameters</p></a></li>
<li><a href='#getGenMap'><p>Get genetic map</p></a></li>
<li><a href='#getMisc'><p>Get miscelaneous information in a population</p></a></li>
<li><a href='#getNumThreads'><p>Number of available threads</p></a></li>
<li><a href='#getPed'><p>Get pedigree</p></a></li>
<li><a href='#getQtlMap'><p>Get QTL genetic map</p></a></li>
<li><a href='#getSnpMap'><p>Get SNP genetic map</p></a></li>
<li><a href='#gv'><p>Genetic value</p></a></li>
<li><a href='#hybridCross'><p>Hybrid crossing</p></a></li>
<li><a href='#HybridPop-class'><p>Hybrid population</p></a></li>
<li><a href='#importGenMap'><p>Import genetic map</p></a></li>
<li><a href='#importHaplo'><p>Import haplotypes</p></a></li>
<li><a href='#importInbredGeno'><p>Import inbred, diploid genotypes</p></a></li>
<li><a href='#isFemale'><p>Test if individuals of a population are female or male</p></a></li>
<li><a href='#isPop'><p>Test if object is of a Population class</p></a></li>
<li><a href='#LociMap-class'><p>Loci metadata</p></a></li>
<li><a href='#makeCross'><p>Make designed crosses</p></a></li>
<li><a href='#makeCross2'><p>Make designed crosses</p></a></li>
<li><a href='#makeDH'><p>Generates DH lines</p></a></li>
<li><a href='#MapPop-class'><p>Raw population with genetic map</p></a></li>
<li><a href='#meanG'><p>Mean genetic values</p></a></li>
<li><a href='#meanP'><p>Mean phenotypic values</p></a></li>
<li><a href='#mergeGenome'><p>Combine genomes of individuals</p></a></li>
<li><a href='#mergePops'><p>Merge list of populations</p></a></li>
<li><a href='#MultiPop-class'><p>Multi-Population</p></a></li>
<li><a href='#mutate'><p>Add Random Mutations</p></a></li>
<li><a href='#NamedMapPop-class'><p>Raw population with genetic map and id</p></a></li>
<li><a href='#newEmptyPop'><p>Creates an empty population</p></a></li>
<li><a href='#newMapPop'><p>New MapPop</p></a></li>
<li><a href='#newMultiPop'><p>Create new Multi Population</p></a></li>
<li><a href='#newPop'><p>Create new population</p></a></li>
<li><a href='#nInd'><p>Number of individuals</p></a></li>
<li><a href='#pedigreeCross'><p>Pedigree cross</p></a></li>
<li><a href='#pheno'><p>Phenotype</p></a></li>
<li><a href='#Pop-class'><p>Population</p></a></li>
<li><a href='#popVar'><p>Population variance</p></a></li>
<li><a href='#pullIbdHaplo'><p>Pull IBD haplotypes</p></a></li>
<li><a href='#pullMarkerGeno'><p>Pull marker genotypes</p></a></li>
<li><a href='#pullMarkerHaplo'><p>Pull marker haplotypes</p></a></li>
<li><a href='#pullQtlGeno'><p>Pull QTL genotypes</p></a></li>
<li><a href='#pullQtlHaplo'><p>Pull QTL haplotypes</p></a></li>
<li><a href='#pullSegSiteGeno'><p>Pull segregating site genotypes</p></a></li>
<li><a href='#pullSegSiteHaplo'><p>Pull seg site haplotypes</p></a></li>
<li><a href='#pullSnpGeno'><p>Pull SNP genotypes</p></a></li>
<li><a href='#pullSnpHaplo'><p>Pull SNP haplotypes</p></a></li>
<li><a href='#quickHaplo'><p>Quick founder haplotype simulation</p></a></li>
<li><a href='#randCross'><p>Make random crosses</p></a></li>
<li><a href='#randCross2'><p>Make random crosses</p></a></li>
<li><a href='#RawPop-class'><p>Raw Population</p></a></li>
<li><a href='#reduceGenome'><p>Create individuals with reduced ploidy</p></a></li>
<li><a href='#resetPop'><p>Reset population</p></a></li>
<li><a href='#RRBLUP'><p>RR-BLUP Model</p></a></li>
<li><a href='#RRBLUP_D'><p>RR-BLUP Model with Dominance</p></a></li>
<li><a href='#RRBLUP_D2'><p>RR-BLUP with Dominance Model 2</p></a></li>
<li><a href='#RRBLUP_GCA'><p>RR-BLUP GCA Model</p></a></li>
<li><a href='#RRBLUP_GCA2'><p>RR-BLUP GCA Model 2</p></a></li>
<li><a href='#RRBLUP_SCA'><p>RR-BLUP SCA Model</p></a></li>
<li><a href='#RRBLUP_SCA2'><p>RR-BLUP SCA Model 2</p></a></li>
<li><a href='#RRBLUP2'><p>RR-BLUP Model 2</p></a></li>
<li><a href='#RRBLUPMemUse'><p>RRBLUP Memory Usage</p></a></li>
<li><a href='#RRsol-class'><p>RR-BLUP Solution</p></a></li>
<li><a href='#runMacs'><p>Create founder haplotypes using MaCS</p></a></li>
<li><a href='#runMacs2'><p>Alternative wrapper for MaCS</p></a></li>
<li><a href='#sampleHaplo'><p>Sample haplotypes from a MapPop</p></a></li>
<li><a href='#selectCross'><p>Select and randomly cross</p></a></li>
<li><a href='#selectFam'><p>Select families</p></a></li>
<li><a href='#selectInd'><p>Select individuals</p></a></li>
<li><a href='#selectOP'><p>Select open pollinating plants</p></a></li>
<li><a href='#selectWithinFam'><p>Select individuals within families</p></a></li>
<li><a href='#self'><p>Self individuals</p></a></li>
<li><a href='#selIndex'><p>Selection index</p></a></li>
<li><a href='#selInt'><p>Selection intensity</p></a></li>
<li><a href='#setEBV'><p>Set EBV</p></a></li>
<li><a href='#setMarkerHaplo'><p>Set marker haplotypes</p></a></li>
<li><a href='#setMisc'><p>Set miscelaneous information in a population</p></a></li>
<li><a href='#setPheno'><p>Set phenotypes</p></a></li>
<li><a href='#setPhenoGCA'><p>Set GCA as phenotype</p></a></li>
<li><a href='#setPhenoProgTest'><p>Set progeny test as phenotype</p></a></li>
<li><a href='#SimParam'><p>Simulation parameters</p></a></li>
<li><a href='#smithHazel'><p>Calculate Smith-Hazel weights</p></a></li>
<li><a href='#solveMKM'><p>Solve Multikernel Model</p></a></li>
<li><a href='#solveMVM'><p>Solve Multivariate Model</p></a></li>
<li><a href='#solveRRBLUP'><p>Solve RR-BLUP</p></a></li>
<li><a href='#solveRRBLUP_EM'><p>Solve RR-BLUP with EM</p></a></li>
<li><a href='#solveRRBLUP_EM2'><p>Solve RR-BLUP with EM and 2 random effects</p></a></li>
<li><a href='#solveRRBLUP_EM3'><p>Solve RR-BLUP with EM and 3 random effects</p></a></li>
<li><a href='#solveRRBLUPMK'><p>Solve Multikernel RR-BLUP</p></a></li>
<li><a href='#solveRRBLUPMV'><p>Solve Multivariate RR-BLUP</p></a></li>
<li><a href='#solveUVM'><p>Solve Univariate Model</p></a></li>
<li><a href='#TraitA-class'><p>Additive trait</p></a></li>
<li><a href='#TraitA2-class'><p>Sex specific additive trait</p></a></li>
<li><a href='#TraitA2D-class'><p>Sex specific additive and dominance trait</p></a></li>
<li><a href='#TraitAD-class'><p>Additive and dominance trait</p></a></li>
<li><a href='#TraitADE-class'><p>Additive, dominance, and epistatic trait</p></a></li>
<li><a href='#TraitADEG-class'><p>Additive, dominance, epistasis, and GxE trait</p></a></li>
<li><a href='#TraitADG-class'><p>Additive, dominance and GxE trait</p></a></li>
<li><a href='#TraitAE-class'><p>Additive and epistatic trait</p></a></li>
<li><a href='#TraitAEG-class'><p>Additive, epistasis and GxE trait</p></a></li>
<li><a href='#TraitAG-class'><p>Additive and GxE trait</p></a></li>
<li><a href='#transMat'><p>Linear transformation matrix</p></a></li>
<li><a href='#usefulness'><p>Usefulness criterion</p></a></li>
<li><a href='#varA'><p>Additive variance</p></a></li>
<li><a href='#varAA'><p>Additive-by-additive epistatic variance</p></a></li>
<li><a href='#varD'><p>Dominance variance</p></a></li>
<li><a href='#varG'><p>Total genetic variance</p></a></li>
<li><a href='#varP'><p>Phenotypic variance</p></a></li>
<li><a href='#writePlink'><p>Writes a Pop-class as PLINK files</p></a></li>
<li><a href='#writeRecords'><p>Write data records</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Breeding Program Simulations</td>
</tr>
<tr>
<td>Version:</td>
<td>1.5.3</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-11-30</td>
</tr>
<tr>
<td>Description:</td>
<td>The successor to the 'AlphaSim' software for breeding program 
  simulation [Faux et al. (2016) &lt;<a href="https://doi.org/10.3835%2Fplantgenome2016.02.0013">doi:10.3835/plantgenome2016.02.0013</a>&gt;]. 
  Used for stochastic simulations of breeding programs to the level of DNA 
  sequence for every individual. Contained is a wide range of functions for 
  modeling common tasks in a breeding program, such as selection and crossing. 
  These functions allow for constructing simulations of highly complex plant and 
  animal breeding programs via scripting in the R software environment. Such 
  simulations can be used to evaluate overall breeding program performance and 
  conduct research into breeding program design, such as implementation of 
  genomic selection. Included is the 'Markovian Coalescent Simulator' ('MaCS') 
  for fast simulation of biallelic sequences according to a population 
  demographic history [Chen et al. (2009) &lt;<a href="https://doi.org/10.1101%2Fgr.083634.108">doi:10.1101/gr.083634.108</a>&gt;].</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/gaynorr/AlphaSimR">https://github.com/gaynorr/AlphaSimR</a>,
<a href="https://gaynorr.github.io/AlphaSimR/">https://gaynorr.github.io/AlphaSimR/</a>,
<a href="https://www.edx.org/learn/animal-breeding/the-university-of-edinburgh-breeding-programme-modelling-with-alphasimr">https://www.edx.org/learn/animal-breeding/the-university-of-edinburgh-breeding-programme-modelling-with-alphasimr</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.0.0), methods, R6</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 0.12.7), Rdpack</td>
</tr>
<tr>
<td>RdMacros:</td>
<td>Rdpack</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo (&ge; 0.7.500.0.0), BH</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, testthat</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-11-30 23:05:29 UTC; gayno</td>
</tr>
<tr>
<td>Author:</td>
<td>Chris Gaynor <a href="https://orcid.org/0000-0003-0558-6656"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Gregor Gorjanc <a href="https://orcid.org/0000-0001-8008-2787"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb],
  John Hickey <a href="https://orcid.org/0000-0001-5675-3974"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [ctb],
  Daniel Money <a href="https://orcid.org/0000-0001-5151-3648"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb],
  David Wilson [ctb],
  Thiago Oliveira <a href="https://orcid.org/0000-0002-4555-2584"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb],
  Audrey Martin <a href="https://orcid.org/0000-0003-2235-0098"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb],
  Philip Greenspoon <a href="https://orcid.org/0000-0001-6284-7248"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Chris Gaynor &lt;gaynor.robert@hotmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-12-01 21:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='AlphaSimR-package'>AlphaSimR: Breeding Program Simulations</h2><span id='topic+AlphaSimR'></span><span id='topic+AlphaSimR-package'></span>

<h3>Description</h3>

<p>The successor to the 'AlphaSim' software for breeding program 
simulation [Faux et al. (2016) &lt;doi:10.3835/plantgenome2016.02.0013&gt;]. 
Used for stochastic simulations of breeding programs to the level of DNA 
sequence for every individual. Contained is a wide range of functions for 
modeling common tasks in a breeding program, such as selection and crossing. 
These functions allow for constructing simulations of highly complex plant and 
animal breeding programs via scripting in the R software environment. Such 
simulations can be used to evaluate overall breeding program performance and 
conduct research into breeding program design, such as implementation of 
genomic selection. Included is the 'Markovian Coalescent Simulator' ('MaCS') 
for fast simulation of biallelic sequences according to a population 
demographic history [Chen et al. (2009) &lt;doi:10.1101/gr.083634.108&gt;].
</p>
<p>Please see the introductory vignette for instructions for using this package. 
The vignette can be viewed using the following command: 
<code>vignette("intro",package="AlphaSimR")</code>
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Chris Gaynor <a href="mailto:gaynor.robert@hotmail.com">gaynor.robert@hotmail.com</a> (<a href="https://orcid.org/0000-0003-0558-6656">ORCID</a>)
</p>
<p>Other contributors:
</p>

<ul>
<li><p> Gregor Gorjanc (<a href="https://orcid.org/0000-0001-8008-2787">ORCID</a>) [contributor]
</p>
</li>
<li><p> John Hickey (<a href="https://orcid.org/0000-0001-5675-3974">ORCID</a>) [contributor]
</p>
</li>
<li><p> Daniel Money (<a href="https://orcid.org/0000-0001-5151-3648">ORCID</a>) [contributor]
</p>
</li>
<li><p> David Wilson [contributor]
</p>
</li>
<li><p> Thiago Oliveira (<a href="https://orcid.org/0000-0002-4555-2584">ORCID</a>) [contributor]
</p>
</li>
<li><p> Audrey Martin (<a href="https://orcid.org/0000-0003-2235-0098">ORCID</a>) [contributor]
</p>
</li>
<li><p> Philip Greenspoon (<a href="https://orcid.org/0000-0001-6284-7248">ORCID</a>) [contributor]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/gaynorr/AlphaSimR">https://github.com/gaynorr/AlphaSimR</a>
</p>
</li>
<li> <p><a href="https://gaynorr.github.io/AlphaSimR/">https://gaynorr.github.io/AlphaSimR/</a>
</p>
</li>
<li> <p><a href="https://www.edx.org/learn/animal-breeding/the-university-of-edinburgh-breeding-programme-modelling-with-alphasimr">https://www.edx.org/learn/animal-breeding/the-university-of-edinburgh-breeding-programme-modelling-with-alphasimr</a>
</p>
</li></ul>


<hr>
<h2 id='.newPop'>Create new population (internal)</h2><span id='topic+.newPop'></span>

<h3>Description</h3>

<p>Creates a new <code><a href="#topic+Pop-class">Pop-class</a></code> from an object of
of the Pop superclass.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.newPop(
  rawPop,
  id = NULL,
  mother = NULL,
  father = NULL,
  iMother = NULL,
  iFather = NULL,
  isDH = NULL,
  femaleParentPop = NULL,
  maleParentPop = NULL,
  hist = NULL,
  simParam = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".newPop_+3A_rawpop">rawPop</code></td>
<td>
<p>an object of the pop superclass</p>
</td></tr>
<tr><td><code id=".newPop_+3A_id">id</code></td>
<td>
<p>optional id for new individuals</p>
</td></tr>
<tr><td><code id=".newPop_+3A_mother">mother</code></td>
<td>
<p>optional id for mothers</p>
</td></tr>
<tr><td><code id=".newPop_+3A_father">father</code></td>
<td>
<p>optional id for fathers</p>
</td></tr>
<tr><td><code id=".newPop_+3A_imother">iMother</code></td>
<td>
<p>optional internal id for mothers</p>
</td></tr>
<tr><td><code id=".newPop_+3A_ifather">iFather</code></td>
<td>
<p>optional internal id for fathers</p>
</td></tr>
<tr><td><code id=".newPop_+3A_isdh">isDH</code></td>
<td>
<p>optional indicator for DH/inbred individuals</p>
</td></tr>
<tr><td><code id=".newPop_+3A_femaleparentpop">femaleParentPop</code></td>
<td>
<p>optional population of female parents</p>
</td></tr>
<tr><td><code id=".newPop_+3A_maleparentpop">maleParentPop</code></td>
<td>
<p>optional population of male parents</p>
</td></tr>
<tr><td><code id=".newPop_+3A_hist">hist</code></td>
<td>
<p>optional recombination history</p>
</td></tr>
<tr><td><code id=".newPop_+3A_simparam">simParam</code></td>
<td>
<p>an object of <code><a href="#topic+SimParam">SimParam</a></code></p>
</td></tr>
<tr><td><code id=".newPop_+3A_...">...</code></td>
<td>
<p>additional arguments passed to the finalizePop
function in simParam</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an object of <code><a href="#topic+Pop-class">Pop-class</a></code>
</p>

<hr>
<h2 id='aa'>Additive-by-additive epistatic deviations</h2><span id='topic+aa'></span>

<h3>Description</h3>

<p>Returns additive-by-additive epistatic
deviations for all traits
</p>


<h3>Usage</h3>

<pre><code class='language-R'>aa(pop, simParam = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="aa_+3A_pop">pop</code></td>
<td>
<p>an object of <code><a href="#topic+Pop-class">Pop-class</a></code></p>
</td></tr>
<tr><td><code id="aa_+3A_simparam">simParam</code></td>
<td>
<p>an object of <code><a href="#topic+SimParam">SimParam</a></code></p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>#Create founder haplotypes
founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)

#Set simulation parameters
SP = SimParam$new(founderPop)
SP$addTraitAD(10, meanDD=0.5)
SP$setVarE(h2=0.5)


#Create population
pop = newPop(founderPop, simParam=SP)
aa(pop, simParam=SP)

</code></pre>

<hr>
<h2 id='addSegSite'>Add segregating site to MapPop</h2><span id='topic+addSegSite'></span>

<h3>Description</h3>

<p>This function allows for adding a new 
segregating site with user supplied genotypes to a MapPop. 
The position of the site is set using a genetic map position.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>addSegSite(mapPop, siteName, chr, mapPos, haplo)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="addSegSite_+3A_mappop">mapPop</code></td>
<td>
<p>an object of <code><a href="#topic+MapPop-class">MapPop-class</a></code></p>
</td></tr>
<tr><td><code id="addSegSite_+3A_sitename">siteName</code></td>
<td>
<p>name to give the segregating site</p>
</td></tr>
<tr><td><code id="addSegSite_+3A_chr">chr</code></td>
<td>
<p>which chromosome to add the site</p>
</td></tr>
<tr><td><code id="addSegSite_+3A_mappos">mapPos</code></td>
<td>
<p>genetic map position of site in Morgans</p>
</td></tr>
<tr><td><code id="addSegSite_+3A_haplo">haplo</code></td>
<td>
<p>haplotypes for the site</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of <code><a href="#topic+MapPop-class">MapPop-class</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Creates a populations of 10 outbred individuals
# Their genome consists of 1 chromosome and 2 segregating sites
founderPop = quickHaplo(nInd=10,nChr=1,segSites=2)

# Add a locus a the 0.5 Morgan map position
haplo = matrix(sample(x=0:1, size=20, replace=TRUE), ncol=1)

founderPop2 = addSegSite(founderPop, siteName="x", chr=1, mapPos=0.5, haplo=haplo)

pullSegSiteHaplo(founderPop2)

</code></pre>

<hr>
<h2 id='attrition'>Lose individuals at random</h2><span id='topic+attrition'></span>

<h3>Description</h3>

<p>Samples individuals at random to remove from the population. 
The user supplies a probability for the individuals to be 
removed from the population.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>attrition(pop, p)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="attrition_+3A_pop">pop</code></td>
<td>
<p>an object of <code><a href="#topic+Pop-class">Pop-class</a></code></p>
</td></tr>
<tr><td><code id="attrition_+3A_p">p</code></td>
<td>
<p>the expected proportion of individuals that will
be lost to attrition.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of <code><a href="#topic+Pop-class">Pop-class</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Create founder haplotypes
founderPop = quickHaplo(nInd=100, nChr=1, segSites=10)

#Set simulation parameters
SP = SimParam$new(founderPop)


#Create population
pop = newPop(founderPop, simParam=SP)

#Lose an expected 5% of individuals
pop = attrition(pop, p=0.05)

</code></pre>

<hr>
<h2 id='bv'>Breeding value</h2><span id='topic+bv'></span>

<h3>Description</h3>

<p>Returns breeding values for all traits
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bv(pop, simParam = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bv_+3A_pop">pop</code></td>
<td>
<p>an object of <code><a href="#topic+Pop-class">Pop-class</a></code></p>
</td></tr>
<tr><td><code id="bv_+3A_simparam">simParam</code></td>
<td>
<p>an object of <code><a href="#topic+SimParam">SimParam</a></code></p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>#Create founder haplotypes
founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)

#Set simulation parameters
SP = SimParam$new(founderPop)
SP$addTraitAD(10, meanDD=0.5)
SP$setVarE(h2=0.5)


#Create population
pop = newPop(founderPop, simParam=SP)
bv(pop, simParam=SP)

</code></pre>

<hr>
<h2 id='calcGCA'>Calculate GCA</h2><span id='topic+calcGCA'></span>

<h3>Description</h3>

<p>Calculate general combining ability of test crosses. Intended for
output from hybridCross using the &quot;testcross&quot; option, but will work
for any population.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calcGCA(pop, use = "pheno")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calcGCA_+3A_pop">pop</code></td>
<td>
<p>an object of <code><a href="#topic+Pop-class">Pop-class</a></code> or
<code><a href="#topic+HybridPop-class">HybridPop-class</a></code></p>
</td></tr>
<tr><td><code id="calcGCA_+3A_use">use</code></td>
<td>
<p>tabulate either genetic values &quot;gv&quot;, estimated
breeding values &quot;ebv&quot;, or phenotypes &quot;pheno&quot;</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>#Create founder haplotypes
founderPop = quickHaplo(nInd=10, nChr=1, segSites=10, inbred=TRUE)

#Set simulation parameters
SP = SimParam$new(founderPop)

SP$addTraitA(10)

#Create population
pop = newPop(founderPop, simParam=SP)

#Make crosses for full diallele
pop2 = hybridCross(pop, pop, simParam=SP)
GCA = calcGCA(pop2, use="gv")

</code></pre>

<hr>
<h2 id='cChr'>Combine MapPop chromosomes</h2><span id='topic+cChr'></span>

<h3>Description</h3>

<p>Merges the chromosomes of multiple <code><a href="#topic+MapPop-class">MapPop-class</a></code> or
<code><a href="#topic+NamedMapPop-class">NamedMapPop-class</a></code> objects.
Each MapPop must have the same number of chromosomes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cChr(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cChr_+3A_...">...</code></td>
<td>
<p><code><a href="#topic+MapPop-class">MapPop-class</a></code> or <code><a href="#topic+NamedMapPop-class">NamedMapPop-class</a></code>
objects to be combined</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an object of <code><a href="#topic+MapPop-class">MapPop-class</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pop1 = quickHaplo(nInd=10, nChr=1, segSites=10)
pop2 = quickHaplo(nInd=10, nChr=1, segSites=10)

combinedPop = cChr(pop1, pop2)

</code></pre>

<hr>
<h2 id='dd'>Dominance deviations</h2><span id='topic+dd'></span>

<h3>Description</h3>

<p>Returns dominance deviations for all traits
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dd(pop, simParam = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dd_+3A_pop">pop</code></td>
<td>
<p>an object of <code><a href="#topic+Pop-class">Pop-class</a></code></p>
</td></tr>
<tr><td><code id="dd_+3A_simparam">simParam</code></td>
<td>
<p>an object of <code><a href="#topic+SimParam">SimParam</a></code></p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>#Create founder haplotypes
founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)

#Set simulation parameters
SP = SimParam$new(founderPop)
SP$addTraitAD(10, meanDD=0.5)
SP$setVarE(h2=0.5)


#Create population
pop = newPop(founderPop, simParam=SP)
dd(pop, simParam=SP)

</code></pre>

<hr>
<h2 id='doubleGenome'>Double the ploidy of individuals</h2><span id='topic+doubleGenome'></span>

<h3>Description</h3>

<p>Creates new individuals with twice the ploidy. 
This function was created to model the formation of tetraploid 
potatoes from diploid potatoes. This function will work on any 
population.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>doubleGenome(pop, keepParents = TRUE, simParam = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="doubleGenome_+3A_pop">pop</code></td>
<td>
<p>an object of 'Pop' superclass</p>
</td></tr>
<tr><td><code id="doubleGenome_+3A_keepparents">keepParents</code></td>
<td>
<p>should previous parents be used for mother and 
father.</p>
</td></tr>
<tr><td><code id="doubleGenome_+3A_simparam">simParam</code></td>
<td>
<p>an object of 'SimParam' class</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an object of <code><a href="#topic+Pop-class">Pop-class</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Create founder haplotypes
founderPop = quickHaplo(nInd=2, nChr=1, segSites=10)

#Set simulation parameters
SP = SimParam$new(founderPop)


#Create population
pop = newPop(founderPop, simParam=SP)

#Create individuals with doubled ploidy
pop2 = doubleGenome(pop, simParam=SP)

</code></pre>

<hr>
<h2 id='ebv'>Estimated breeding value</h2><span id='topic+ebv'></span>

<h3>Description</h3>

<p>A wrapper for accessing the ebv slot
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ebv(pop)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ebv_+3A_pop">pop</code></td>
<td>
<p>a <code><a href="#topic+Pop-class">Pop-class</a></code> or similar object</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>#Create founder haplotypes
founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)

#Set simulation parameters
SP = SimParam$new(founderPop)

SP$addTraitAD(10, meanDD=0.5)
SP$setVarE(h2=0.5)

#Create population
pop = newPop(founderPop, simParam=SP)
pop@ebv = matrix(rnorm(pop@nInd), nrow=pop@nInd, ncol=1)
ebv(pop)

</code></pre>

<hr>
<h2 id='editGenome'>Edit genome</h2><span id='topic+editGenome'></span>

<h3>Description</h3>

<p>Edits selected loci of selected individuals to a homozygous 
state for either the 1 or 0 allele. The gv slot is recalculated to 
reflect the any changes due to editing, but other slots remain the same.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>editGenome(pop, ind, chr, segSites, allele, simParam = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="editGenome_+3A_pop">pop</code></td>
<td>
<p>an object of <code><a href="#topic+Pop-class">Pop-class</a></code></p>
</td></tr>
<tr><td><code id="editGenome_+3A_ind">ind</code></td>
<td>
<p>a vector of individuals to edit</p>
</td></tr>
<tr><td><code id="editGenome_+3A_chr">chr</code></td>
<td>
<p>a vector of chromosomes to edit. 
Length must match length of segSites.</p>
</td></tr>
<tr><td><code id="editGenome_+3A_segsites">segSites</code></td>
<td>
<p>a vector of segregating sites to edit. Length must 
match length of chr.</p>
</td></tr>
<tr><td><code id="editGenome_+3A_allele">allele</code></td>
<td>
<p>either 0 or 1 for desired allele</p>
</td></tr>
<tr><td><code id="editGenome_+3A_simparam">simParam</code></td>
<td>
<p>an object of <code><a href="#topic+SimParam">SimParam</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an object of <code><a href="#topic+Pop-class">Pop-class</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Create founder haplotypes
founderPop = quickHaplo(nInd=2, nChr=1, segSites=10)

#Set simulation parameters
SP = SimParam$new(founderPop)

SP$addTraitA(10)

#Create population
pop = newPop(founderPop, simParam=SP)

#Change individual 1 to homozygous for the 1 allele 
#at locus 1, chromosome 1
pop2 = editGenome(pop, ind=1, chr=1, segSites=1, 
                  allele=1, simParam=SP)

</code></pre>

<hr>
<h2 id='editGenomeTopQtl'>Edit genome - the top QTL</h2><span id='topic+editGenomeTopQtl'></span>

<h3>Description</h3>

<p>Edits the top QTL (with the largest additive effect) to a homozygous 
state for the allele increasing. Only nonfixed QTL are edited The gv slot is
recalculated to reflect the any changes due to editing, but other slots remain the same.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>editGenomeTopQtl(pop, ind, nQtl, trait = 1, increase = TRUE, simParam = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="editGenomeTopQtl_+3A_pop">pop</code></td>
<td>
<p>an object of <code><a href="#topic+Pop-class">Pop-class</a></code></p>
</td></tr>
<tr><td><code id="editGenomeTopQtl_+3A_ind">ind</code></td>
<td>
<p>a vector of individuals to edit</p>
</td></tr>
<tr><td><code id="editGenomeTopQtl_+3A_nqtl">nQtl</code></td>
<td>
<p>number of QTL to edit</p>
</td></tr>
<tr><td><code id="editGenomeTopQtl_+3A_trait">trait</code></td>
<td>
<p>which trait effects should guide selection of the top QTL</p>
</td></tr>
<tr><td><code id="editGenomeTopQtl_+3A_increase">increase</code></td>
<td>
<p>should the trait value be increased or decreased</p>
</td></tr>
<tr><td><code id="editGenomeTopQtl_+3A_simparam">simParam</code></td>
<td>
<p>an object of <code><a href="#topic+SimParam">SimParam</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an object of <code><a href="#topic+Pop-class">Pop-class</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Create founder haplotypes
founderPop = quickHaplo(nInd=2, nChr=1, segSites=10)

#Set simulation parameters
SP = SimParam$new(founderPop)

SP$addTraitA(10)

#Create population
pop = newPop(founderPop, simParam=SP)

#Change up to 10 loci for individual 1 
pop2 = editGenomeTopQtl(pop, ind=1, nQtl=10, simParam=SP)
                  
</code></pre>

<hr>
<h2 id='fastRRBLUP'>Fast RR-BLUP</h2><span id='topic+fastRRBLUP'></span>

<h3>Description</h3>

<p>Solves an RR-BLUP model for genomic predictions given known variance 
components. This implementation is meant as a fast and low memory 
alternative to <code><a href="#topic+RRBLUP">RRBLUP</a></code> or <code><a href="#topic+RRBLUP2">RRBLUP2</a></code>. Unlike 
the those functions, the fastRRBLUP does not fit fixed effects (other 
than the intercept) or account for unequal replication.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fastRRBLUP(
  pop,
  traits = 1,
  use = "pheno",
  snpChip = 1,
  useQtl = FALSE,
  maxIter = 1000,
  Vu = NULL,
  Ve = NULL,
  simParam = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fastRRBLUP_+3A_pop">pop</code></td>
<td>
<p>a <code><a href="#topic+Pop-class">Pop-class</a></code> to serve as the training population</p>
</td></tr>
<tr><td><code id="fastRRBLUP_+3A_traits">traits</code></td>
<td>
<p>an integer indicating the trait to model, a trait name, 
or a function of the traits returning a single value. Only univariate models 
are supported.</p>
</td></tr>
<tr><td><code id="fastRRBLUP_+3A_use">use</code></td>
<td>
<p>train model using phenotypes &quot;pheno&quot;, genetic values &quot;gv&quot;, 
estimated breeding values &quot;ebv&quot;, breeding values &quot;bv&quot;, or randomly &quot;rand&quot;</p>
</td></tr>
<tr><td><code id="fastRRBLUP_+3A_snpchip">snpChip</code></td>
<td>
<p>an integer indicating which SNP chip genotype 
to use</p>
</td></tr>
<tr><td><code id="fastRRBLUP_+3A_useqtl">useQtl</code></td>
<td>
<p>should QTL genotypes be used instead of a SNP chip. 
If TRUE, snpChip specifies which trait's QTL to use, and thus these 
QTL may not match the QTL underlying the phenotype supplied in traits.</p>
</td></tr>
<tr><td><code id="fastRRBLUP_+3A_maxiter">maxIter</code></td>
<td>
<p>maximum number of iterations.</p>
</td></tr>
<tr><td><code id="fastRRBLUP_+3A_vu">Vu</code></td>
<td>
<p>marker effect variance. If value is NULL, a 
reasonable value is chosen automatically.</p>
</td></tr>
<tr><td><code id="fastRRBLUP_+3A_ve">Ve</code></td>
<td>
<p>error variance. If value is NULL, a 
reasonable value is chosen automatically.</p>
</td></tr>
<tr><td><code id="fastRRBLUP_+3A_simparam">simParam</code></td>
<td>
<p>an object of <code><a href="#topic+SimParam">SimParam</a></code></p>
</td></tr>
<tr><td><code id="fastRRBLUP_+3A_...">...</code></td>
<td>
<p>additional arguments if using a function for 
traits</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>#Create founder haplotypes
founderPop = quickHaplo(nInd=10, nChr=1, segSites=20)

#Set simulation parameters
SP = SimParam$new(founderPop)

SP$addTraitA(10)
SP$setVarE(h2=0.5)
SP$addSnpChip(10)

#Create population
pop = newPop(founderPop, simParam=SP)

#Run GS model and set EBV
ans = fastRRBLUP(pop, simParam=SP)
pop = setEBV(pop, ans, simParam=SP)

#Evaluate accuracy
cor(gv(pop), ebv(pop))

</code></pre>

<hr>
<h2 id='genicVarA'>Additive genic variance</h2><span id='topic+genicVarA'></span>

<h3>Description</h3>

<p>Returns additive genic variance for all traits
</p>


<h3>Usage</h3>

<pre><code class='language-R'>genicVarA(pop, simParam = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="genicVarA_+3A_pop">pop</code></td>
<td>
<p>an object of <code><a href="#topic+Pop-class">Pop-class</a></code></p>
</td></tr>
<tr><td><code id="genicVarA_+3A_simparam">simParam</code></td>
<td>
<p>an object of <code><a href="#topic+SimParam">SimParam</a></code></p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>#Create founder haplotypes
founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)

#Set simulation parameters
SP = SimParam$new(founderPop)
SP$addTraitAD(10, meanDD=0.5)
SP$setVarE(h2=0.5)


#Create population
pop = newPop(founderPop, simParam=SP)
genicVarA(pop, simParam=SP)

</code></pre>

<hr>
<h2 id='genicVarAA'>Additive-by-additive genic variance</h2><span id='topic+genicVarAA'></span>

<h3>Description</h3>

<p>Returns additive-by-additive epistatic
genic variance for all traits
</p>


<h3>Usage</h3>

<pre><code class='language-R'>genicVarAA(pop, simParam = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="genicVarAA_+3A_pop">pop</code></td>
<td>
<p>an object of <code><a href="#topic+Pop-class">Pop-class</a></code></p>
</td></tr>
<tr><td><code id="genicVarAA_+3A_simparam">simParam</code></td>
<td>
<p>an object of <code><a href="#topic+SimParam">SimParam</a></code></p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>#Create founder haplotypes
founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)

#Set simulation parameters
SP = SimParam$new(founderPop)
SP$addTraitAD(10, meanDD=0.5)
SP$setVarE(h2=0.5)


#Create population
pop = newPop(founderPop, simParam=SP)
genicVarAA(pop, simParam=SP)

</code></pre>

<hr>
<h2 id='genicVarD'>Dominance genic variance</h2><span id='topic+genicVarD'></span>

<h3>Description</h3>

<p>Returns dominance genic variance for all traits
</p>


<h3>Usage</h3>

<pre><code class='language-R'>genicVarD(pop, simParam = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="genicVarD_+3A_pop">pop</code></td>
<td>
<p>an object of <code><a href="#topic+Pop-class">Pop-class</a></code></p>
</td></tr>
<tr><td><code id="genicVarD_+3A_simparam">simParam</code></td>
<td>
<p>an object of <code><a href="#topic+SimParam">SimParam</a></code></p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>#Create founder haplotypes
founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)

#Set simulation parameters
SP = SimParam$new(founderPop)
SP$addTraitAD(10, meanDD=0.5)
SP$setVarE(h2=0.5)


#Create population
pop = newPop(founderPop, simParam=SP)
genicVarD(pop, simParam=SP)

</code></pre>

<hr>
<h2 id='genicVarG'>Total genic variance</h2><span id='topic+genicVarG'></span>

<h3>Description</h3>

<p>Returns total genic variance for all traits
</p>


<h3>Usage</h3>

<pre><code class='language-R'>genicVarG(pop, simParam = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="genicVarG_+3A_pop">pop</code></td>
<td>
<p>an object of <code><a href="#topic+Pop-class">Pop-class</a></code></p>
</td></tr>
<tr><td><code id="genicVarG_+3A_simparam">simParam</code></td>
<td>
<p>an object of <code><a href="#topic+SimParam">SimParam</a></code></p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>#Create founder haplotypes
founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)

#Set simulation parameters
SP = SimParam$new(founderPop)
SP$addTraitAD(10, meanDD=0.5)
SP$setVarE(h2=0.5)


#Create population
pop = newPop(founderPop, simParam=SP)
genicVarG(pop, simParam=SP)

</code></pre>

<hr>
<h2 id='genParam'>Sumarize genetic parameters</h2><span id='topic+genParam'></span>

<h3>Description</h3>

<p>Calculates genetic and genic additive and dominance variances
for an object of <code><a href="#topic+Pop-class">Pop-class</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>genParam(pop, simParam = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="genParam_+3A_pop">pop</code></td>
<td>
<p>an object of <code><a href="#topic+Pop-class">Pop-class</a></code></p>
</td></tr>
<tr><td><code id="genParam_+3A_simparam">simParam</code></td>
<td>
<p>an object of <code><a href="#topic+SimParam">SimParam</a></code></p>
</td></tr>
</table>


<h3>Value</h3>


<dl>
<dt>varA</dt><dd><p>an nTrait by nTrait matrix of additive genetic variances</p>
</dd>
<dt>varD</dt><dd><p>an nTrait by nTrait matrix of dominance genetic variances</p>
</dd>
<dt>varAA</dt><dd><p>an nTrait by nTrait matrix of additive-by-additive genetic variances</p>
</dd>
<dt>varG</dt><dd><p>an nTrait by nTrait matrix of total genetic variances</p>
</dd>
<dt>genicVarA</dt><dd><p>an nTrait vector of additive genic variances</p>
</dd>
<dt>genicVarD</dt><dd><p>an nTrait vector of dominance genic variances</p>
</dd>
<dt>genicVarAA</dt><dd><p>an nTrait vector of additive-by-additive genic variances</p>
</dd>
<dt>genicVarG</dt><dd><p>an nTrait vector of total genic variances</p>
</dd>
<dt>covA_HW</dt><dd><p>an nTrait vector of additive covariances due to non-random mating</p>
</dd>
<dt>covD_HW</dt><dd><p>an nTrait vector of dominance covariances due to non-random mating</p>
</dd>
<dt>covAA_HW</dt><dd><p>an nTrait vector of additive-by-additive covariances due to non-random mating</p>
</dd>
<dt>covG_HW</dt><dd><p>an nTrait vector of total genic covariances due to non-random mating</p>
</dd>
<dt>covA_L</dt><dd><p>an nTrait vector of additive covariances due to linkage disequilibrium</p>
</dd>
<dt>covD_L</dt><dd><p>an nTrait vector of dominance covariances due to linkage disequilibrium</p>
</dd>
<dt>covAA_L</dt><dd><p>an nTrait vector of additive-by-additive covariances due to linkage disequilibrium</p>
</dd>
<dt>covAD_L</dt><dd><p>an nTrait vector of additive by dominance covariances due to linkage disequilibrium</p>
</dd>
<dt>covAAA_L</dt><dd><p>an nTrait vector of additive by additive-by-additive covariances due to linkage disequilibrium</p>
</dd>
<dt>covDAA_L</dt><dd><p>an nTrait vector of dominance by additive-by-additive covariances due to linkage disequilibrium</p>
</dd>
<dt>covG_L</dt><dd><p>an nTrait vector of total genic covariances due to linkage disequilibrium</p>
</dd>
<dt>mu</dt><dd><p>an nTrait vector of trait means</p>
</dd>
<dt>mu_HW</dt><dd><p>an nTrait vector of expected trait means under random mating</p>
</dd>
<dt>gv</dt><dd><p>a matrix of genetic values with dimensions nInd by nTraits</p>
</dd>
<dt>bv</dt><dd><p>a matrix of breeding values with dimensions nInd by nTraits</p>
</dd>
<dt>dd</dt><dd><p>a matrix of dominance deviations with dimensions nInd by nTraits</p>
</dd>
<dt>aa</dt><dd><p>a matrix of additive-by-additive epistatic deviations with dimensions nInd by nTraits</p>
</dd>
<dt>gv_mu</dt><dd><p>an nTrait vector of intercepts with dimensions nInd by nTraits</p>
</dd>
<dt>gv_a</dt><dd><p>a matrix of additive genetic values with dimensions nInd by nTraits</p>
</dd>
<dt>gv_d</dt><dd><p>a matrix of dominance genetic values with dimensions nInd by nTraits</p>
</dd>
<dt>gv_aa</dt><dd><p>a matrix of additive-by-additive genetic values with dimensions nInd by nTraits</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>#Create founder haplotypes
founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)

#Set simulation parameters
SP = SimParam$new(founderPop)
SP$addTraitAD(10, meanDD=0.5)
SP$setVarE(h2=0.5)


#Create population
pop = newPop(founderPop, simParam=SP)
ans = genParam(pop, simParam=SP)

</code></pre>

<hr>
<h2 id='getGenMap'>Get genetic map</h2><span id='topic+getGenMap'></span>

<h3>Description</h3>

<p>Retrieves the genetic map for all loci.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getGenMap(object = NULL, sex = "A")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getGenMap_+3A_object">object</code></td>
<td>
<p>where to retrieve the genetic map. 
Can be an object of <code><a href="#topic+SimParam">SimParam</a></code> or 
<code><a href="#topic+MapPop-class">MapPop-class</a></code>. If NULL, the function will 
look for a SimParam object called &quot;SP&quot; in your 
global environment.</p>
</td></tr>
<tr><td><code id="getGenMap_+3A_sex">sex</code></td>
<td>
<p>determines which sex specific map 
is returned. Options are &quot;A&quot; for average map, &quot;F&quot; 
for female map, and &quot;M&quot; for male map. All options are 
equivalent if not using sex specific maps or using 
pulling from a MapPop.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a data.frame with:
</p>

<dl>
<dt>id</dt><dd><p>Unique identifier for locus</p>
</dd>
<dt>chr</dt><dd><p>Chromosome containing the locus</p>
</dd>
<dt>pos</dt><dd><p>Genetic map position</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>#Create founder haplotypes
founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)

#Set simulation parameters
getGenMap(founderPop)

</code></pre>

<hr>
<h2 id='getMisc'>Get miscelaneous information in a population</h2><span id='topic+getMisc'></span>

<h3>Description</h3>

<p>Get miscelaneous information in a population
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getMisc(x, node = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getMisc_+3A_x">x</code></td>
<td>
<p><code><a href="#topic+Pop-class">Pop-class</a></code></p>
</td></tr>
<tr><td><code id="getMisc_+3A_node">node</code></td>
<td>
<p>character, name of the node to get from the <code>x@misc</code> slot;
if <code>NULL</code> the whole <code>x@misc</code> slot is returned</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The <code>x@misc</code> slot or its nodes <code>x@misc[[*]][[node]]</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>founderGenomes &lt;- quickHaplo(nInd = 3, nChr = 1, segSites = 100)
SP &lt;- SimParam$new(founderGenomes)

basePop &lt;- newPop(founderGenomes)

basePop &lt;- setMisc(basePop, node = "info", value = 1)
basePop@misc
getMisc(x = basePop, node = "info")

basePop &lt;- setMisc(basePop, node = "info2", value = c("A", "B", "C"))
basePop@misc
getMisc(x = basePop, node = "info2")

n &lt;- nInd(basePop)
location &lt;- vector(mode = "list", length = n)
for (ind in seq_len(n)) {
  location[[ind]] &lt;- runif(n = 2, min = 0, max = 100)
}
location
basePop &lt;- setMisc(basePop, node = "location", value = location)
basePop@misc
getMisc(x = basePop, node = "location")

n &lt;- nInd(basePop)
location &lt;- vector(mode = "list", length = n)
for (ind in c(1, 3)) {
  location[[ind]] &lt;- runif(n = 2, min = 0, max = 100)
}
location
basePop &lt;- setMisc(basePop, node = "location", value = location)
basePop@misc
getMisc(x = basePop, node = "location")

getMisc(x = basePop)

</code></pre>

<hr>
<h2 id='getNumThreads'>Number of available threads</h2><span id='topic+getNumThreads'></span>

<h3>Description</h3>

<p>Gets the number of available threads by calling the OpenMP function
<code>omp_get_max_threads()</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getNumThreads()
</code></pre>


<h3>Value</h3>

<p>integer
</p>


<h3>Examples</h3>

<pre><code class='language-R'>getNumThreads()

</code></pre>

<hr>
<h2 id='getPed'>Get pedigree</h2><span id='topic+getPed'></span>

<h3>Description</h3>

<p>Returns the population's pedigree as stored in the 
id, mother and father slots. NULL is returned if the 
input population lacks the required.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getPed(pop)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getPed_+3A_pop">pop</code></td>
<td>
<p>a population</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># Create a founder population
founderPop = quickHaplo(2,1,2)

# Set simulation parameters
SP = SimParam$new(founderPop)

# Create a population
pop = newPop(founderPop, simParam=SP)

# Get the pedigree
getPed(pop)

# Returns NULL when a population lacks a pedigree
getPed(founderPop)

</code></pre>

<hr>
<h2 id='getQtlMap'>Get QTL genetic map</h2><span id='topic+getQtlMap'></span>

<h3>Description</h3>

<p>Retrieves the genetic map for the 
QTL of a given trait.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getQtlMap(trait = 1, sex = "A", simParam = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getQtlMap_+3A_trait">trait</code></td>
<td>
<p>an integer for the</p>
</td></tr>
<tr><td><code id="getQtlMap_+3A_sex">sex</code></td>
<td>
<p>determines which sex specific map 
is returned. Options are &quot;A&quot; for average map, &quot;F&quot; 
for female map, and &quot;M&quot; for male map. All options are 
equivalent if not using sex specific maps.</p>
</td></tr>
<tr><td><code id="getQtlMap_+3A_simparam">simParam</code></td>
<td>
<p>an object of <code><a href="#topic+SimParam">SimParam</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a data.frame with:
</p>

<dl>
<dt>id</dt><dd><p>Unique identifier for the QTL</p>
</dd>
<dt>chr</dt><dd><p>Chromosome containing the QTL</p>
</dd>
<dt>site</dt><dd><p>Segregating site on the chromosome</p>
</dd>
<dt>pos</dt><dd><p>Genetic map position</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>#Create founder haplotypes
founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)

#Set simulation parameters
SP = SimParam$new(founderPop)

SP$addTraitA(5)

#Pull SNP map
getQtlMap(trait=1, simParam=SP)

</code></pre>

<hr>
<h2 id='getSnpMap'>Get SNP genetic map</h2><span id='topic+getSnpMap'></span>

<h3>Description</h3>

<p>Retrieves the genetic map for a 
given SNP chip.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getSnpMap(snpChip = 1, sex = "A", simParam = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getSnpMap_+3A_snpchip">snpChip</code></td>
<td>
<p>an integer. Indicates which SNP
chip's map to retrieve.</p>
</td></tr>
<tr><td><code id="getSnpMap_+3A_sex">sex</code></td>
<td>
<p>determines which sex specific map 
is returned. Options are &quot;A&quot; for average map, &quot;F&quot; 
for female map, and &quot;M&quot; for male map. All options are 
equivalent if not using sex specific maps.</p>
</td></tr>
<tr><td><code id="getSnpMap_+3A_simparam">simParam</code></td>
<td>
<p>an object of <code><a href="#topic+SimParam">SimParam</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a data.frame with:
</p>

<dl>
<dt>id</dt><dd><p>Unique identifier for the SNP</p>
</dd>
<dt>chr</dt><dd><p>Chromosome containing the SNP</p>
</dd>
<dt>site</dt><dd><p>Segregating site on the chromosome</p>
</dd>
<dt>pos</dt><dd><p>Genetic map position</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>#Create founder haplotypes
founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)

#Set simulation parameters
SP = SimParam$new(founderPop)

SP$addSnpChip(5)

#Pull SNP map
getSnpMap(snpChip=1, simParam=SP)

</code></pre>

<hr>
<h2 id='gv'>Genetic value</h2><span id='topic+gv'></span>

<h3>Description</h3>

<p>A wrapper for accessing the gv slot
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gv(pop)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gv_+3A_pop">pop</code></td>
<td>
<p>a <code><a href="#topic+Pop-class">Pop-class</a></code> or similar object</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>#Create founder haplotypes
founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)

#Set simulation parameters
SP = SimParam$new(founderPop)
SP$addTraitAD(10, meanDD=0.5)
SP$setVarE(h2=0.5)


#Create population
pop = newPop(founderPop, simParam=SP)
gv(pop)

</code></pre>

<hr>
<h2 id='hybridCross'>Hybrid crossing</h2><span id='topic+hybridCross'></span>

<h3>Description</h3>

<p>A convience function for hybrid plant breeding simulations. Allows for
easy specification of a test cross scheme and/or creation of an object
of <code><a href="#topic+HybridPop-class">HybridPop-class</a></code>. Note that the <code><a href="#topic+HybridPop-class">HybridPop-class</a></code>
should only be used if the parents were created using the <code><a href="#topic+makeDH">makeDH</a></code>
function or <code><a href="#topic+newPop">newPop</a></code> using inbred founders. The id for
new individuals is [mother_id]_[father_id]
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hybridCross(
  females,
  males,
  crossPlan = "testcross",
  returnHybridPop = FALSE,
  simParam = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hybridCross_+3A_females">females</code></td>
<td>
<p>female population, an object of <code><a href="#topic+Pop-class">Pop-class</a></code></p>
</td></tr>
<tr><td><code id="hybridCross_+3A_males">males</code></td>
<td>
<p>male population, an object of <code><a href="#topic+Pop-class">Pop-class</a></code></p>
</td></tr>
<tr><td><code id="hybridCross_+3A_crossplan">crossPlan</code></td>
<td>
<p>either &quot;testcross&quot; for all possible combinantions
or a matrix with two columns for designed crosses</p>
</td></tr>
<tr><td><code id="hybridCross_+3A_returnhybridpop">returnHybridPop</code></td>
<td>
<p>should results be returned as
<code><a href="#topic+HybridPop-class">HybridPop-class</a></code>. If false returns results as
<code><a href="#topic+Pop-class">Pop-class</a></code>. Population must be fully inbred if TRUE.</p>
</td></tr>
<tr><td><code id="hybridCross_+3A_simparam">simParam</code></td>
<td>
<p>an object of <code><a href="#topic+SimParam">SimParam</a></code></p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>#Create founder haplotypes
founderPop = quickHaplo(nInd=2, nChr=1, segSites=10)

#Set simulation parameters
SP = SimParam$new(founderPop)


#Create population
pop = newPop(founderPop, simParam=SP)

#Make crosses for full diallele
pop2 = hybridCross(pop, pop, simParam=SP)

</code></pre>

<hr>
<h2 id='HybridPop-class'>Hybrid population</h2><span id='topic+HybridPop-class'></span><span id='topic++5B+2CHybridPop-method'></span><span id='topic+c+2CHybridPop-method'></span><span id='topic+isHybridPop'></span>

<h3>Description</h3>

<p>A lightweight version of <code><a href="#topic+Pop-class">Pop-class</a></code> for hybrid lines.
Memory is saved by not storing genotypic data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'HybridPop'
x[i]

## S4 method for signature 'HybridPop'
c(x, ...)

isHybridPop(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="HybridPop-class_+3A_x">x</code></td>
<td>
<p>a 'HybridPop'</p>
</td></tr>
<tr><td><code id="HybridPop-class_+3A_i">i</code></td>
<td>
<p>index of individuals</p>
</td></tr>
<tr><td><code id="HybridPop-class_+3A_...">...</code></td>
<td>
<p>additional 'HybridPop' objects</p>
</td></tr>
</table>


<h3>Methods (by generic)</h3>


<ul>
<li> <p><code>[</code>: Extract HybridPop using index or id
</p>
</li>
<li> <p><code>c(HybridPop)</code>: Combine multiple HybridPops
</p>
</li></ul>


<h3>Functions</h3>


<ul>
<li> <p><code>isHybridPop()</code>: Test if object is of a HybridPop class
</p>
</li></ul>


<h3>Slots</h3>


<dl>
<dt><code>nInd</code></dt><dd><p>number of individuals</p>
</dd>
<dt><code>id</code></dt><dd><p>an individual's identifier</p>
</dd>
<dt><code>mother</code></dt><dd><p>the identifier of the individual's mother</p>
</dd>
<dt><code>father</code></dt><dd><p>the identifier of the individual's father</p>
</dd>
<dt><code>nTraits</code></dt><dd><p>number of traits</p>
</dd>
<dt><code>gv</code></dt><dd><p>matrix of genetic values. When using GxE traits,
gv reflects gv when p=0.5. Dimensions are nInd by nTraits.</p>
</dd>
<dt><code>pheno</code></dt><dd><p>matrix of phenotypic values. Dimensions are
nInd by nTraits.</p>
</dd>
<dt><code>gxe</code></dt><dd><p>list containing GxE slopes for GxE traits</p>
</dd>
</dl>

<hr>
<h2 id='importGenMap'>Import genetic map</h2><span id='topic+importGenMap'></span>

<h3>Description</h3>

<p>Formats a genetic map stored in a data.frame to
AlphaSimR's internal format. Map positions must be 
in Morgans.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>importGenMap(genMap)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="importGenMap_+3A_genmap">genMap</code></td>
<td>
<p>genetic map as a data.frame. The first
three columns must be: marker name, chromosome, and 
map position (Morgans). Marker name and chromosome are 
coerced using as.character.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of named vectors
</p>


<h3>Examples</h3>

<pre><code class='language-R'>genMap = data.frame(markerName=letters[1:5],
                    chromosome=c(1,1,1,2,2),
                    position=c(0,0.5,1,0.15,0.4))

asrMap = importGenMap(genMap=genMap)

str(asrMap)

</code></pre>

<hr>
<h2 id='importHaplo'>Import haplotypes</h2><span id='topic+importHaplo'></span>

<h3>Description</h3>

<p>Formats haplotype in a matrix format to an 
AlphaSimR population that can be used to 
initialize a simulation. This function serves 
as wrapper for <code><a href="#topic+newMapPop">newMapPop</a></code> that 
utilizes a more user friendly input format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>importHaplo(haplo, genMap, ploidy = 2L, ped = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="importHaplo_+3A_haplo">haplo</code></td>
<td>
<p>a matrix of haplotypes</p>
</td></tr>
<tr><td><code id="importHaplo_+3A_genmap">genMap</code></td>
<td>
<p>genetic map as a data.frame. The first
three columns must be: marker name, chromosome, and 
map position (Morgans). Marker name and chromosome are 
coerced using as.character. See <code><a href="#topic+importGenMap">importGenMap</a></code></p>
</td></tr>
<tr><td><code id="importHaplo_+3A_ploidy">ploidy</code></td>
<td>
<p>ploidy level of the organism</p>
</td></tr>
<tr><td><code id="importHaplo_+3A_ped">ped</code></td>
<td>
<p>an optional pedigree for the supplied 
genotypes. See details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The optional pedigree can be a data.frame, matrix or a vector. 
If the object is a data.frame or matrix, the first three 
columns must include information in the following order: id, 
mother, and father. All values are coerced using 
as.character. If the object is a vector, it is assumed to only 
include the id. In this case, the mother and father will be set 
to &quot;0&quot; for all individuals.
</p>


<h3>Value</h3>

<p>a <code><a href="#topic+MapPop-class">MapPop-class</a></code> if ped is NULL,
otherwise a <code><a href="#topic+NamedMapPop-class">NamedMapPop-class</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>haplo = rbind(c(1,1,0,1,0),
              c(1,1,0,1,0),
              c(0,1,1,0,0),
              c(0,1,1,0,0))
colnames(haplo) = letters[1:5]

genMap = data.frame(markerName=letters[1:5],
                    chromosome=c(1,1,1,2,2),
                    position=c(0,0.5,1,0.15,0.4))

ped = data.frame(id=c("a","b"),
                 mother=c(0,0),
                 father=c(0,0))

founderPop = importHaplo(haplo=haplo, 
                         genMap=genMap,
                         ploidy=2L,
                         ped=ped)

</code></pre>

<hr>
<h2 id='importInbredGeno'>Import inbred, diploid genotypes</h2><span id='topic+importInbredGeno'></span>

<h3>Description</h3>

<p>Formats the genotypes from inbred, diploid lines 
to an AlphaSimR population that can be used to 
initialize a simulation. An attempt is made to 
automatically detect 0,1,2 or -1,0,1 genotype coding. 
Heterozygotes or probabilistic genotypes are allowed, 
but will be coerced to the nearest homozygote. Pedigree 
information is optional and when provided will be 
passed to the population for easier identification 
in the simulation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>importInbredGeno(geno, genMap, ped = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="importInbredGeno_+3A_geno">geno</code></td>
<td>
<p>a matrix of genotypes</p>
</td></tr>
<tr><td><code id="importInbredGeno_+3A_genmap">genMap</code></td>
<td>
<p>genetic map as a data.frame. The first
three columns must be: marker name, chromosome, and 
map position (Morgans). Marker name and chromosome are 
coerced using as.character. See <a href="#topic+importGenMap">importGenMap</a></p>
</td></tr>
<tr><td><code id="importInbredGeno_+3A_ped">ped</code></td>
<td>
<p>an optional pedigree for the supplied 
genotypes. See details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The optional pedigree can be a data.frame, matrix or a vector. 
If the object is a data.frame or matrix, the first three 
columns must include information in the following order: id, 
mother, and father. All values are coerced using 
as.character. If the object is a vector, it is assumed to only 
include the id. In this case, the mother and father will be set 
to &quot;0&quot; for all individuals.
</p>


<h3>Value</h3>

<p>a <code><a href="#topic+MapPop-class">MapPop-class</a></code> if ped is NULL,
otherwise a <code><a href="#topic+NamedMapPop-class">NamedMapPop-class</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>geno = rbind(c(2,2,0,2,0),
             c(0,2,2,0,0))
colnames(geno) = letters[1:5]

genMap = data.frame(markerName=letters[1:5],
                    chromosome=c(1,1,1,2,2),
                    position=c(0,0.5,1,0.15,0.4))

ped = data.frame(id=c("a","b"),
                 mother=c(0,0),
                 father=c(0,0))

founderPop = importInbredGeno(geno=geno,
                              genMap=genMap,
                              ped=ped)

</code></pre>

<hr>
<h2 id='isFemale'>Test if individuals of a population are female or male</h2><span id='topic+isFemale'></span><span id='topic+isMale'></span>

<h3>Description</h3>

<p>Test if individuals of a population are female or male
</p>


<h3>Usage</h3>

<pre><code class='language-R'>isFemale(x)

isMale(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="isFemale_+3A_x">x</code></td>
<td>
<p><code><a href="#topic+Pop-class">Pop-class</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>logical
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>isMale()</code>: Test if individuals of a population are female or male
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>founderGenomes &lt;- quickHaplo(nInd = 3, nChr = 1, segSites = 100)
SP &lt;- SimParam$new(founderGenomes)
SP$setSexes(sexes = "yes_sys")
pop &lt;- newPop(founderGenomes)

isFemale(pop)
isMale(pop)

pop[isFemale(pop)]
pop[isFemale(pop)]@sex

</code></pre>

<hr>
<h2 id='isPop'>Test if object is of a Population class</h2><span id='topic+isPop'></span>

<h3>Description</h3>

<p>Utilify function to test if object is of a Population class
</p>


<h3>Usage</h3>

<pre><code class='language-R'>isPop(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="isPop_+3A_x">x</code></td>
<td>
<p><code><a href="#topic+Pop-class">Pop-class</a></code></p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>#Create founder haplotypes
founderPop = quickHaplo(nInd=2, nChr=1, segSites=10)

#Set simulation parameters
SP = SimParam$new(founderPop)
SP$addTraitA(10)

#Create population
pop = newPop(founderPop, simParam=SP)
isPop(pop)
isPop(SP)

</code></pre>

<hr>
<h2 id='LociMap-class'>Loci metadata</h2><span id='topic+LociMap-class'></span>

<h3>Description</h3>

<p>used for both SNPs and QTLs
</p>


<h3>Slots</h3>


<dl>
<dt><code>nLoci</code></dt><dd><p>total number of loci</p>
</dd>
<dt><code>lociPerChr</code></dt><dd><p>number of loci per chromosome</p>
</dd>
<dt><code>lociLoc</code></dt><dd><p>physical position of loci</p>
</dd>
<dt><code>name</code></dt><dd><p>optional name for LociMap object</p>
</dd>
</dl>

<hr>
<h2 id='makeCross'>Make designed crosses</h2><span id='topic+makeCross'></span>

<h3>Description</h3>

<p>Makes crosses within a population using a user supplied
crossing plan.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeCross(pop, crossPlan, nProgeny = 1, simParam = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makeCross_+3A_pop">pop</code></td>
<td>
<p>an object of <code><a href="#topic+Pop-class">Pop-class</a></code></p>
</td></tr>
<tr><td><code id="makeCross_+3A_crossplan">crossPlan</code></td>
<td>
<p>a matrix with two column representing
female and male parents. Either integers for the position in
population or character strings for the IDs.</p>
</td></tr>
<tr><td><code id="makeCross_+3A_nprogeny">nProgeny</code></td>
<td>
<p>number of progeny per cross</p>
</td></tr>
<tr><td><code id="makeCross_+3A_simparam">simParam</code></td>
<td>
<p>an object of <code><a href="#topic+SimParam">SimParam</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an object of <code><a href="#topic+Pop-class">Pop-class</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Create founder haplotypes
founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)

#Set simulation parameters
SP = SimParam$new(founderPop)


#Create population
pop = newPop(founderPop, simParam=SP)

#Cross individual 1 with individual 10
crossPlan = matrix(c(1,10), nrow=1, ncol=2)
pop2 = makeCross(pop, crossPlan, simParam=SP)

</code></pre>

<hr>
<h2 id='makeCross2'>Make designed crosses</h2><span id='topic+makeCross2'></span>

<h3>Description</h3>

<p>Makes crosses between two populations using a user supplied
crossing plan.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeCross2(females, males, crossPlan, nProgeny = 1, simParam = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makeCross2_+3A_females">females</code></td>
<td>
<p>an object of <code><a href="#topic+Pop-class">Pop-class</a></code> for female parents.</p>
</td></tr>
<tr><td><code id="makeCross2_+3A_males">males</code></td>
<td>
<p>an object of <code><a href="#topic+Pop-class">Pop-class</a></code> for male parents.</p>
</td></tr>
<tr><td><code id="makeCross2_+3A_crossplan">crossPlan</code></td>
<td>
<p>a matrix with two column representing
female and male parents. Either integers for the position in
population or character strings for the IDs.</p>
</td></tr>
<tr><td><code id="makeCross2_+3A_nprogeny">nProgeny</code></td>
<td>
<p>number of progeny per cross</p>
</td></tr>
<tr><td><code id="makeCross2_+3A_simparam">simParam</code></td>
<td>
<p>an object of <code><a href="#topic+SimParam">SimParam</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an object of <code><a href="#topic+Pop-class">Pop-class</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Create founder haplotypes
founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)

#Set simulation parameters
SP = SimParam$new(founderPop)


#Create population
pop = newPop(founderPop, simParam=SP)

#Cross individual 1 with individual 10
crossPlan = matrix(c(1,10), nrow=1, ncol=2)
pop2 = makeCross2(pop, pop, crossPlan, simParam=SP)

</code></pre>

<hr>
<h2 id='makeDH'>Generates DH lines</h2><span id='topic+makeDH'></span>

<h3>Description</h3>

<p>Creates DH lines from each individual in a population.
Only works with diploid individuals. For polyploids, use
<code><a href="#topic+reduceGenome">reduceGenome</a></code> and <code><a href="#topic+doubleGenome">doubleGenome</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeDH(pop, nDH = 1, useFemale = TRUE, keepParents = TRUE, simParam = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makeDH_+3A_pop">pop</code></td>
<td>
<p>an object of 'Pop' superclass</p>
</td></tr>
<tr><td><code id="makeDH_+3A_ndh">nDH</code></td>
<td>
<p>total number of DH lines per individual</p>
</td></tr>
<tr><td><code id="makeDH_+3A_usefemale">useFemale</code></td>
<td>
<p>should female recombination rates be used.</p>
</td></tr>
<tr><td><code id="makeDH_+3A_keepparents">keepParents</code></td>
<td>
<p>should previous parents be used for mother and
father.</p>
</td></tr>
<tr><td><code id="makeDH_+3A_simparam">simParam</code></td>
<td>
<p>an object of 'SimParam' class</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an object of <code><a href="#topic+Pop-class">Pop-class</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Create founder haplotypes
founderPop = quickHaplo(nInd=2, nChr=1, segSites=10)

#Set simulation parameters
SP = SimParam$new(founderPop)


#Create population
pop = newPop(founderPop, simParam=SP)

#Create 1 DH for each individual
pop2 = makeDH(pop, simParam=SP)

</code></pre>

<hr>
<h2 id='MapPop-class'>Raw population with genetic map</h2><span id='topic+MapPop-class'></span><span id='topic++5B+2CMapPop-method'></span><span id='topic+c+2CMapPop-method'></span><span id='topic+isMapPop'></span>

<h3>Description</h3>

<p>Extends <code><a href="#topic+RawPop-class">RawPop-class</a></code> to add a genetic map.
This is the first object created in a simulation. It is used
for creating initial populations and setting traits in the
<code><a href="#topic+SimParam">SimParam</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'MapPop'
x[i]

## S4 method for signature 'MapPop'
c(x, ...)

isMapPop(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MapPop-class_+3A_x">x</code></td>
<td>
<p>a 'MapPop' object</p>
</td></tr>
<tr><td><code id="MapPop-class_+3A_i">i</code></td>
<td>
<p>index of individuals</p>
</td></tr>
<tr><td><code id="MapPop-class_+3A_...">...</code></td>
<td>
<p>additional 'MapPop' objects</p>
</td></tr>
</table>


<h3>Methods (by generic)</h3>


<ul>
<li> <p><code>[</code>: Extract MapPop by index
</p>
</li>
<li> <p><code>c(MapPop)</code>: Combine multiple MapPops
</p>
</li></ul>


<h3>Functions</h3>


<ul>
<li> <p><code>isMapPop()</code>: Test if object is of a MapPop class
</p>
</li></ul>


<h3>Slots</h3>


<dl>
<dt><code>genMap</code></dt><dd><p>list of chromosome genetic maps</p>
</dd>
<dt><code>centromere</code></dt><dd><p>vector of centromere positions</p>
</dd>
<dt><code>inbred</code></dt><dd><p>indicates whether the individuals are fully inbred</p>
</dd>
</dl>

<hr>
<h2 id='meanG'>Mean genetic values</h2><span id='topic+meanG'></span>

<h3>Description</h3>

<p>Returns the mean genetic values for all traits
</p>


<h3>Usage</h3>

<pre><code class='language-R'>meanG(pop)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="meanG_+3A_pop">pop</code></td>
<td>
<p>an object of <code><a href="#topic+Pop-class">Pop-class</a></code> or <code><a href="#topic+HybridPop-class">HybridPop-class</a></code></p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>#Create founder haplotypes
founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)

#Set simulation parameters
SP = SimParam$new(founderPop)
SP$addTraitA(10)
SP$setVarE(h2=0.5)


#Create population
pop = newPop(founderPop, simParam=SP)
meanG(pop)

</code></pre>

<hr>
<h2 id='meanP'>Mean phenotypic values</h2><span id='topic+meanP'></span>

<h3>Description</h3>

<p>Returns the mean phenotypic values for all traits
</p>


<h3>Usage</h3>

<pre><code class='language-R'>meanP(pop)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="meanP_+3A_pop">pop</code></td>
<td>
<p>an object of <code><a href="#topic+Pop-class">Pop-class</a></code> or <code><a href="#topic+HybridPop-class">HybridPop-class</a></code></p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>#Create founder haplotypes
founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)

#Set simulation parameters
SP = SimParam$new(founderPop)
SP$addTraitA(10)
SP$setVarE(h2=0.5)


#Create population
pop = newPop(founderPop, simParam=SP)
meanP(pop)

</code></pre>

<hr>
<h2 id='mergeGenome'>Combine genomes of individuals</h2><span id='topic+mergeGenome'></span>

<h3>Description</h3>

<p>This function is designed to model the pairing of gametes. The male
and female individuals are treated as gametes, so the ploidy of newly 
created individuals will be the sum of it parents.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mergeGenome(females, males, crossPlan, simParam = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mergeGenome_+3A_females">females</code></td>
<td>
<p>an object of <code><a href="#topic+Pop-class">Pop-class</a></code> for female parents.</p>
</td></tr>
<tr><td><code id="mergeGenome_+3A_males">males</code></td>
<td>
<p>an object of <code><a href="#topic+Pop-class">Pop-class</a></code> for male parents.</p>
</td></tr>
<tr><td><code id="mergeGenome_+3A_crossplan">crossPlan</code></td>
<td>
<p>a matrix with two column representing
female and male parents. Either integers for the position in
population or character strings for the IDs.</p>
</td></tr>
<tr><td><code id="mergeGenome_+3A_simparam">simParam</code></td>
<td>
<p>an object of <code><a href="#topic+SimParam">SimParam</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an object of <code><a href="#topic+Pop-class">Pop-class</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Create founder haplotypes
founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)

#Set simulation parameters
SP = SimParam$new(founderPop)


#Create population
pop = newPop(founderPop, simParam=SP)

#Cross individual 1 with individual 10
crossPlan = matrix(c(1,10), nrow=1, ncol=2)
pop2 = mergeGenome(pop, pop, crossPlan, simParam=SP)

</code></pre>

<hr>
<h2 id='mergePops'>Merge list of populations</h2><span id='topic+mergePops'></span>

<h3>Description</h3>

<p>Rapidly merges a list of populations into a
single population
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mergePops(popList)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mergePops_+3A_poplist">popList</code></td>
<td>
<p>a list containing <code><a href="#topic+Pop-class">Pop-class</a></code> elements
or a <code><a href="#topic+MultiPop-class">MultiPop-class</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a <code><a href="#topic+Pop-class">Pop-class</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Create founder haplotypes
founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)

#Set simulation parameters
SP = SimParam$new(founderPop)


#Create a list of populations and merge list
pop = newPop(founderPop, simParam=SP)
popList = list(pop, pop)
pop2 = mergePops(popList)

</code></pre>

<hr>
<h2 id='MultiPop-class'>Multi-Population</h2><span id='topic+MultiPop-class'></span><span id='topic++5B+2CMultiPop-method'></span><span id='topic++5B+5B+2CMultiPop-method'></span><span id='topic+c+2CMultiPop-method'></span><span id='topic+isMultiPop'></span>

<h3>Description</h3>

<p>The mega-population represents a population of populations.
It is designed to behave like a list of populations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'MultiPop'
x[i]

## S4 method for signature 'MultiPop'
x[[i]]

## S4 method for signature 'MultiPop'
c(x, ...)

isMultiPop(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MultiPop-class_+3A_x">x</code></td>
<td>
<p>a 'MultiPop' object</p>
</td></tr>
<tr><td><code id="MultiPop-class_+3A_i">i</code></td>
<td>
<p>index of populations or mega-populations</p>
</td></tr>
<tr><td><code id="MultiPop-class_+3A_...">...</code></td>
<td>
<p>additional 'MultiPop' or 'Pop' objects</p>
</td></tr>
</table>


<h3>Methods (by generic)</h3>


<ul>
<li> <p><code>[</code>: Extract MultiPop by index
</p>
</li>
<li> <p><code>[[</code>: Extract Pop by index
</p>
</li>
<li> <p><code>c(MultiPop)</code>: Combine multiple MultiPops
</p>
</li></ul>


<h3>Functions</h3>


<ul>
<li> <p><code>isMultiPop()</code>: Test if object is of a MultiPop class
</p>
</li></ul>


<h3>Slots</h3>


<dl>
<dt><code>pops</code></dt><dd><p>list of <code><a href="#topic+Pop-class">Pop-class</a></code> and/or
<code>MultiPop-class</code></p>
</dd>
</dl>

<hr>
<h2 id='mutate'>Add Random Mutations</h2><span id='topic+mutate'></span>

<h3>Description</h3>

<p>Adds random mutations to individuals in a 
population. Note that any existing phenotypes 
or EBVs are kept. Thus, the user will need to run 
<code><a href="#topic+setPheno">setPheno</a></code> and/or <code><a href="#topic+setEBV">setEBV</a></code> 
to generate new phenotypes or EBVs that reflect 
changes introduced by the new mutations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mutate(pop, mutRate = 2.5e-08, returnPos = FALSE, simParam = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mutate_+3A_pop">pop</code></td>
<td>
<p>an object of <code><a href="#topic+Pop-class">Pop-class</a></code></p>
</td></tr>
<tr><td><code id="mutate_+3A_mutrate">mutRate</code></td>
<td>
<p>rate of new mutations</p>
</td></tr>
<tr><td><code id="mutate_+3A_returnpos">returnPos</code></td>
<td>
<p>should the positions of mutations be returned</p>
</td></tr>
<tr><td><code id="mutate_+3A_simparam">simParam</code></td>
<td>
<p>an object of <code><a href="#topic+SimParam">SimParam</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of <code><a href="#topic+Pop-class">Pop-class</a></code> if 
returnPos=FALSE or a list containing a 
<code><a href="#topic+Pop-class">Pop-class</a></code> and a data.frame containing the 
postions of mutations if returnPos=TRUE
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Create founder haplotypes
founderPop = quickHaplo(nInd=2, nChr=1, segSites=10)

#Set simulation parameters
SP = SimParam$new(founderPop)

SP$addTraitA(10)

#Create population
pop = newPop(founderPop, simParam=SP)

#Introduce mutations
pop = mutate(pop, simParam=SP)

</code></pre>

<hr>
<h2 id='NamedMapPop-class'>Raw population with genetic map and id</h2><span id='topic+NamedMapPop-class'></span><span id='topic++5B+2CNamedMapPop-method'></span><span id='topic+c+2CNamedMapPop-method'></span><span id='topic+isNamedMapPop'></span>

<h3>Description</h3>

<p>Extends <code><a href="#topic+MapPop-class">MapPop-class</a></code> to add id, mother and father.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'NamedMapPop'
x[i]

## S4 method for signature 'NamedMapPop'
c(x, ...)

isNamedMapPop(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NamedMapPop-class_+3A_x">x</code></td>
<td>
<p>a 'NamedMapPop' object</p>
</td></tr>
<tr><td><code id="NamedMapPop-class_+3A_i">i</code></td>
<td>
<p>index of individuals</p>
</td></tr>
<tr><td><code id="NamedMapPop-class_+3A_...">...</code></td>
<td>
<p>additional 'NamedMapPop' objects</p>
</td></tr>
</table>


<h3>Methods (by generic)</h3>


<ul>
<li> <p><code>[</code>: Extract NamedMapPop by index
</p>
</li>
<li> <p><code>c(NamedMapPop)</code>: Combine multiple NamedMapPops
</p>
</li></ul>


<h3>Functions</h3>


<ul>
<li> <p><code>isNamedMapPop()</code>: Test if object is a NamedMapPop class
</p>
</li></ul>


<h3>Slots</h3>


<dl>
<dt><code>id</code></dt><dd><p>an individual's identifier</p>
</dd>
<dt><code>mother</code></dt><dd><p>the identifier of the individual's mother</p>
</dd>
<dt><code>father</code></dt><dd><p>the identifier of the individual's father</p>
</dd>
</dl>

<hr>
<h2 id='newEmptyPop'>Creates an empty population</h2><span id='topic+newEmptyPop'></span>

<h3>Description</h3>

<p>Creates an empty <code><a href="#topic+Pop-class">Pop-class</a></code> object with user
defined ploidy and other parameters taken from simParam.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>newEmptyPop(ploidy = 2L, simParam = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="newEmptyPop_+3A_ploidy">ploidy</code></td>
<td>
<p>the ploidy of the population</p>
</td></tr>
<tr><td><code id="newEmptyPop_+3A_simparam">simParam</code></td>
<td>
<p>an object of <code><a href="#topic+SimParam">SimParam</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an object of <code><a href="#topic+Pop-class">Pop-class</a></code> with
zero individuals
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Create founder haplotypes
founderPop = quickHaplo(nInd=2, nChr=1, segSites=10)

#Set simulation parameters
SP = SimParam$new(founderPop)
SP$addTraitA(10)

#Create empty population
pop = newEmptyPop(simParam=SP)
isPop(pop)

</code></pre>

<hr>
<h2 id='newMapPop'>New MapPop</h2><span id='topic+newMapPop'></span>

<h3>Description</h3>

<p>Creates a new <code><a href="#topic+MapPop-class">MapPop-class</a></code> from user supplied 
genetic maps and haplotypes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>newMapPop(genMap, haplotypes, inbred = FALSE, ploidy = 2L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="newMapPop_+3A_genmap">genMap</code></td>
<td>
<p>a list of genetic maps</p>
</td></tr>
<tr><td><code id="newMapPop_+3A_haplotypes">haplotypes</code></td>
<td>
<p>a list of matrices or data.frames that 
can be coerced to matrices. See details.</p>
</td></tr>
<tr><td><code id="newMapPop_+3A_inbred">inbred</code></td>
<td>
<p>are individuals fully inbred</p>
</td></tr>
<tr><td><code id="newMapPop_+3A_ploidy">ploidy</code></td>
<td>
<p>ploidy level of the organism</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Each item of genMap must be a vector of ordered genetic lengths in 
Morgans. The first value must be zero. The length of the vector 
determines the number of segregating sites on the chromosome.
</p>
<p>Each item of haplotypes must be coercible to a matrix. The columns 
of this matrix correspond to segregating sites. The number of rows 
must match the number of individuals times the ploidy if using 
inbred=FALSE. If using inbred=TRUE, the number of rows must equal 
the number of individuals. The haplotypes can be stored as numeric, 
integer or raw. The underlying C++ function will use raw.
</p>


<h3>Value</h3>

<p>an object of <code><a href="#topic+MapPop-class">MapPop-class</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create genetic map for two chromosomes, each 1 Morgan long
# Each chromosome contains 11 equally spaced segregating sites
genMap = list(seq(0,1,length.out=11),
               seq(0,1,length.out=11))
               
# Create haplotypes for 10 outbred individuals
chr1 = sample(x=0:1,size=20*11,replace=TRUE)
chr1 = matrix(chr1,nrow=20,ncol=11)
chr2 = sample(x=0:1,size=20*11,replace=TRUE)
chr2 = matrix(chr2,nrow=20,ncol=11)
haplotypes = list(chr1,chr2)

founderPop = newMapPop(genMap=genMap, haplotypes=haplotypes)

</code></pre>

<hr>
<h2 id='newMultiPop'>Create new Multi Population</h2><span id='topic+newMultiPop'></span>

<h3>Description</h3>

<p>Creates a new <code><a href="#topic+MultiPop-class">MultiPop-class</a></code> from one or more
<code><a href="#topic+Pop-class">Pop-class</a></code> and/or <code><a href="#topic+MultiPop-class">MultiPop-class</a></code>
objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>newMultiPop(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="newMultiPop_+3A_...">...</code></td>
<td>
<p>one or more <code><a href="#topic+Pop-class">Pop-class</a></code> and/or
<code><a href="#topic+MultiPop-class">MultiPop-class</a></code> objects.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an object of <code><a href="#topic+MultiPop-class">MultiPop-class</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Create founder haplotypes
founderPop = quickHaplo(nInd=2, nChr=1, segSites=10)

#Set simulation parameters
SP = SimParam$new(founderPop)
SP$addTraitA(10)

#Create population
pop = newPop(founderPop, simParam=SP)
megaPop = newMultiPop(pop=pop)
isMultiPop(megaPop)

</code></pre>

<hr>
<h2 id='newPop'>Create new population</h2><span id='topic+newPop'></span>

<h3>Description</h3>

<p>Creates an initial <code><a href="#topic+Pop-class">Pop-class</a></code> from an object of
<code><a href="#topic+MapPop-class">MapPop-class</a></code> or <code><a href="#topic+NamedMapPop-class">NamedMapPop-class</a></code>.
The function is intended for us with output from functions such
as <code><a href="#topic+runMacs">runMacs</a></code>, <code><a href="#topic+newMapPop">newMapPop</a></code>, or
<code><a href="#topic+quickHaplo">quickHaplo</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>newPop(rawPop, simParam = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="newPop_+3A_rawpop">rawPop</code></td>
<td>
<p>an object of <code><a href="#topic+MapPop-class">MapPop-class</a></code> or
<code><a href="#topic+NamedMapPop-class">NamedMapPop-class</a></code></p>
</td></tr>
<tr><td><code id="newPop_+3A_simparam">simParam</code></td>
<td>
<p>an object of <code><a href="#topic+SimParam">SimParam</a></code></p>
</td></tr>
<tr><td><code id="newPop_+3A_...">...</code></td>
<td>
<p>additional arguments used internally</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an object of <code><a href="#topic+Pop-class">Pop-class</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Create founder haplotypes
founderPop = quickHaplo(nInd=2, nChr=1, segSites=10)

#Set simulation parameters
SP = SimParam$new(founderPop)
SP$addTraitA(10)

#Create population
pop = newPop(founderPop, simParam=SP)
isPop(pop)

</code></pre>

<hr>
<h2 id='nInd'>Number of individuals</h2><span id='topic+nInd'></span>

<h3>Description</h3>

<p>A wrapper for accessing the nInd slot
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nInd(pop)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nInd_+3A_pop">pop</code></td>
<td>
<p>a <code><a href="#topic+Pop-class">Pop-class</a></code> or similar object</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>#Create founder haplotypes
founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)

#Set simulation parameters
SP = SimParam$new(founderPop)

SP$addTraitAD(10, meanDD=0.5)
SP$setVarE(h2=0.5)

#Create population
pop = newPop(founderPop, simParam=SP)
nInd(pop)

</code></pre>

<hr>
<h2 id='pedigreeCross'>Pedigree cross</h2><span id='topic+pedigreeCross'></span>

<h3>Description</h3>

<p>Creates a <code><a href="#topic+Pop-class">Pop-class</a></code> from a generic
pedigree and a set of founder individuals.
</p>
<p>The way in which the user supplied pedigree is used depends on
the value of matchID. If matchID is TRUE, the IDs in the user
supplied pedigree are matched against founderNames. If matchID
is FALSE, founder individuals in the user supplied pedigree are
randomly sampled from founderPop.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pedigreeCross(
  founderPop,
  id,
  mother,
  father,
  matchID = FALSE,
  maxCycle = 100,
  DH = NULL,
  nSelf = NULL,
  useFemale = TRUE,
  simParam = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pedigreeCross_+3A_founderpop">founderPop</code></td>
<td>
<p>a <code><a href="#topic+Pop-class">Pop-class</a></code></p>
</td></tr>
<tr><td><code id="pedigreeCross_+3A_id">id</code></td>
<td>
<p>a vector of unique identifiers for individuals
in the pedigree. The values of these IDs are seperate from
the IDs in the founderPop if matchID=FALSE.</p>
</td></tr>
<tr><td><code id="pedigreeCross_+3A_mother">mother</code></td>
<td>
<p>a vector of identifiers for the mothers
of individuals in the pedigree. Must match one of the
elements in the id vector or they will be treated as unknown.</p>
</td></tr>
<tr><td><code id="pedigreeCross_+3A_father">father</code></td>
<td>
<p>a vector of identifiers for the fathers
of individuals in the pedigree. Must match one of the
elements in the id vector or they will be treated as unknown.</p>
</td></tr>
<tr><td><code id="pedigreeCross_+3A_matchid">matchID</code></td>
<td>
<p>indicates if the IDs in founderPop should be
matched to the id argument. See details.</p>
</td></tr>
<tr><td><code id="pedigreeCross_+3A_maxcycle">maxCycle</code></td>
<td>
<p>the maximum number of loops to make over the pedigree
to sort it.</p>
</td></tr>
<tr><td><code id="pedigreeCross_+3A_dh">DH</code></td>
<td>
<p>an optional vector indicating if an individual
should be made a doubled haploid.</p>
</td></tr>
<tr><td><code id="pedigreeCross_+3A_nself">nSelf</code></td>
<td>
<p>an optional vector indicating how many generations an
individual should be selfed.</p>
</td></tr>
<tr><td><code id="pedigreeCross_+3A_usefemale">useFemale</code></td>
<td>
<p>If creating DH lines, should female recombination
rates be used. This parameter has no effect if, recombRatio=1.</p>
</td></tr>
<tr><td><code id="pedigreeCross_+3A_simparam">simParam</code></td>
<td>
<p>an object of 'SimParam' class</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>#Create founder haplotypes
founderPop = quickHaplo(nInd=2, nChr=1, segSites=10)

#Set simulation parameters
SP = SimParam$new(founderPop)


#Create population
pop = newPop(founderPop, simParam=SP)

#Pedigree for a biparental cross with 7 generations of selfing
id = 1:10
mother = c(0,0,1,3:9)
father = c(0,0,2,3:9)
pop2 = pedigreeCross(pop, id, mother, father, simParam=SP)


</code></pre>

<hr>
<h2 id='pheno'>Phenotype</h2><span id='topic+pheno'></span>

<h3>Description</h3>

<p>A wrapper for accessing the pheno slot
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pheno(pop)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pheno_+3A_pop">pop</code></td>
<td>
<p>a <code><a href="#topic+Pop-class">Pop-class</a></code> or similar object</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>#Create founder haplotypes
founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)

#Set simulation parameters
SP = SimParam$new(founderPop)
SP$addTraitAD(10, meanDD=0.5)
SP$setVarE(h2=0.5)


#Create population
pop = newPop(founderPop, simParam=SP)
pheno(pop)

</code></pre>

<hr>
<h2 id='Pop-class'>Population</h2><span id='topic+Pop-class'></span><span id='topic++5B+2CPop-method'></span><span id='topic+c+2CPop-method'></span><span id='topic+show+2CPop-method'></span>

<h3>Description</h3>

<p>Extends <code><a href="#topic+RawPop-class">RawPop-class</a></code> to add sex, genetic values,
phenotypes, and pedigrees.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Pop'
x[i]

## S4 method for signature 'Pop'
c(x, ...)

## S4 method for signature 'Pop'
show(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Pop-class_+3A_x">x</code></td>
<td>
<p>a 'Pop' object</p>
</td></tr>
<tr><td><code id="Pop-class_+3A_i">i</code></td>
<td>
<p>index of individuals</p>
</td></tr>
<tr><td><code id="Pop-class_+3A_...">...</code></td>
<td>
<p>additional 'Pop' objects</p>
</td></tr>
<tr><td><code id="Pop-class_+3A_object">object</code></td>
<td>
<p>a 'Pop' object</p>
</td></tr>
</table>


<h3>Methods (by generic)</h3>


<ul>
<li> <p><code>[</code>: Extract Pop by index or id
</p>
</li>
<li> <p><code>c(Pop)</code>: Combine multiple Pops
</p>
</li>
<li> <p><code>show(Pop)</code>: Show population summary
</p>
</li></ul>


<h3>Slots</h3>


<dl>
<dt><code>id</code></dt><dd><p>an individual's identifier</p>
</dd>
<dt><code>iid</code></dt><dd><p>an individual's internal identifier</p>
</dd>
<dt><code>mother</code></dt><dd><p>the identifier of the individual's mother</p>
</dd>
<dt><code>father</code></dt><dd><p>the identifier of the individual's father</p>
</dd>
<dt><code>sex</code></dt><dd><p>sex of individuals: &quot;M&quot; for males, &quot;F&quot; for females,
and &quot;H&quot; for hermaphrodites</p>
</dd>
<dt><code>nTraits</code></dt><dd><p>number of traits</p>
</dd>
<dt><code>gv</code></dt><dd><p>matrix of genetic values. When using GxE traits,
gv reflects gv when p=0.5. Dimensions are nInd by nTraits.</p>
</dd>
<dt><code>pheno</code></dt><dd><p>matrix of phenotypic values. Dimensions are
nInd by nTraits.</p>
</dd>
<dt><code>ebv</code></dt><dd><p>matrix of estimated breeding values. Dimensions
are nInd rows and a variable number of columns.</p>
</dd>
<dt><code>gxe</code></dt><dd><p>list containing GxE slopes for GxE traits</p>
</dd>
<dt><code>fixEff</code></dt><dd><p>a fixed effect relating to the phenotype.
Used by genomic selection models but otherwise ignored.</p>
</dd>
<dt><code>misc</code></dt><dd><p>a list whose elements correspond to individuals in the
population. This list is normally empty and exists solely as an
open slot available for uses to store extra information about
individuals.</p>
</dd>
<dt><code>miscPop</code></dt><dd><p>a list of any length containing optional meta data for the 
population. This list is empty unless information is supplied by the user.
Note that the list is emptied every time the population is subsetted.</p>
</dd>
</dl>

<hr>
<h2 id='popVar'>Population variance</h2><span id='topic+popVar'></span>

<h3>Description</h3>

<p>Calculates the population variance matrix as 
opposed to the sample variance matrix calculated 
by <code><a href="stats.html#topic+var">var</a></code>. i.e. divides by n instead 
of n-1
</p>


<h3>Usage</h3>

<pre><code class='language-R'>popVar(X)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="popVar_+3A_x">X</code></td>
<td>
<p>an n by m matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an m by m variance-covariance matrix
</p>

<hr>
<h2 id='pullIbdHaplo'>Pull IBD haplotypes</h2><span id='topic+pullIbdHaplo'></span>

<h3>Description</h3>

<p>Retrieves IBD haplotype data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pullIbdHaplo(pop, chr = NULL, snpChip = NULL, simParam = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pullIbdHaplo_+3A_pop">pop</code></td>
<td>
<p>an object of <code><a href="#topic+Pop-class">Pop-class</a></code></p>
</td></tr>
<tr><td><code id="pullIbdHaplo_+3A_chr">chr</code></td>
<td>
<p>a vector of chromosomes to retrieve. If NULL,
all chromosomes are retrieved.</p>
</td></tr>
<tr><td><code id="pullIbdHaplo_+3A_snpchip">snpChip</code></td>
<td>
<p>an integer indicating which SNP array loci 
are to be retrieved. If NULL, all sites are retrieved.</p>
</td></tr>
<tr><td><code id="pullIbdHaplo_+3A_simparam">simParam</code></td>
<td>
<p>an object of <code><a href="#topic+SimParam">SimParam</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a matrix of IBD haplotypes.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Create founder haplotypes
founderPop = quickHaplo(nInd=10, nChr=1, segSites=15)

#Set simulation parameters
SP = SimParam$new(founderPop)

SP$addTraitA(10)
SP$addSnpChip(5)
SP$setTrackRec(TRUE)

#Create population
pop = newPop(founderPop, simParam=SP)
pullIbdHaplo(pop, simParam=SP)

</code></pre>

<hr>
<h2 id='pullMarkerGeno'>Pull marker genotypes</h2><span id='topic+pullMarkerGeno'></span>

<h3>Description</h3>

<p>Retrieves genotype data for user
specified loci
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pullMarkerGeno(pop, markers, asRaw = FALSE, simParam = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pullMarkerGeno_+3A_pop">pop</code></td>
<td>
<p>an object of <code><a href="#topic+RawPop-class">RawPop-class</a></code> or
<code><a href="#topic+MapPop-class">MapPop-class</a></code></p>
</td></tr>
<tr><td><code id="pullMarkerGeno_+3A_markers">markers</code></td>
<td>
<p>a character vector. Indicates the
names of the loci to be retrieved.</p>
</td></tr>
<tr><td><code id="pullMarkerGeno_+3A_asraw">asRaw</code></td>
<td>
<p>return in raw (byte) format</p>
</td></tr>
<tr><td><code id="pullMarkerGeno_+3A_simparam">simParam</code></td>
<td>
<p>an object of <code><a href="#topic+SimParam">SimParam</a></code>, not 
used if pop is <code><a href="#topic+MapPop-class">MapPop-class</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a matrix of genotypes.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Create founder haplotypes
founderPop = quickHaplo(nInd=10, nChr=1, segSites=15)

#Set simulation parameters
SP = SimParam$new(founderPop)

SP$addTraitA(10)
SP$addSnpChip(5)

#Create population
pop = newPop(founderPop, simParam=SP)

#Pull genotype data for first two markers on chromosome one.
#Marker name is consistent with default naming in AlphaSimR.
pullMarkerGeno(pop, markers=c("1_1","1_2"), simParam=SP)

</code></pre>

<hr>
<h2 id='pullMarkerHaplo'>Pull marker haplotypes</h2><span id='topic+pullMarkerHaplo'></span>

<h3>Description</h3>

<p>Retrieves haplotype data for user
specified loci
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pullMarkerHaplo(pop, markers, haplo = "all", asRaw = FALSE, simParam = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pullMarkerHaplo_+3A_pop">pop</code></td>
<td>
<p>an object of <code><a href="#topic+RawPop-class">RawPop-class</a></code> or
<code><a href="#topic+MapPop-class">MapPop-class</a></code></p>
</td></tr>
<tr><td><code id="pullMarkerHaplo_+3A_markers">markers</code></td>
<td>
<p>a character vector. Indicates the
names of the loci to be retrieved</p>
</td></tr>
<tr><td><code id="pullMarkerHaplo_+3A_haplo">haplo</code></td>
<td>
<p>either &quot;all&quot; for all haplotypes or an integer
for a single set of haplotypes. Use a value of 1 for female
haplotypes and a value of 2 for male haplotypes in diploids.</p>
</td></tr>
<tr><td><code id="pullMarkerHaplo_+3A_asraw">asRaw</code></td>
<td>
<p>return in raw (byte) format</p>
</td></tr>
<tr><td><code id="pullMarkerHaplo_+3A_simparam">simParam</code></td>
<td>
<p>an object of <code><a href="#topic+SimParam">SimParam</a></code>, not 
used if pop is <code><a href="#topic+MapPop-class">MapPop-class</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a matrix of genotypes.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Create founder haplotypes
founderPop = quickHaplo(nInd=10, nChr=1, segSites=15)

#Set simulation parameters
SP = SimParam$new(founderPop)

SP$addTraitA(10)
SP$addSnpChip(5)
SP$setTrackRec(TRUE)

#Create population
pop = newPop(founderPop, simParam=SP)

#Pull haplotype data for first two markers on chromosome one.
#Marker name is consistent with default naming in AlphaSimR.
pullMarkerHaplo(pop, markers=c("1_1","1_2"), simParam=SP)

</code></pre>

<hr>
<h2 id='pullQtlGeno'>Pull QTL genotypes</h2><span id='topic+pullQtlGeno'></span>

<h3>Description</h3>

<p>Retrieves QTL genotype data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pullQtlGeno(pop, trait = 1, chr = NULL, asRaw = FALSE, simParam = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pullQtlGeno_+3A_pop">pop</code></td>
<td>
<p>an object of <code><a href="#topic+Pop-class">Pop-class</a></code></p>
</td></tr>
<tr><td><code id="pullQtlGeno_+3A_trait">trait</code></td>
<td>
<p>an integer. Indicates which trait's
QTL genotypes to retrieve.</p>
</td></tr>
<tr><td><code id="pullQtlGeno_+3A_chr">chr</code></td>
<td>
<p>a vector of chromosomes to retrieve. If NULL,
all chromosome are retrieved.</p>
</td></tr>
<tr><td><code id="pullQtlGeno_+3A_asraw">asRaw</code></td>
<td>
<p>return in raw (byte) format</p>
</td></tr>
<tr><td><code id="pullQtlGeno_+3A_simparam">simParam</code></td>
<td>
<p>an object of <code><a href="#topic+SimParam">SimParam</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a matrix of QTL genotypes.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Create founder haplotypes
founderPop = quickHaplo(nInd=10, nChr=1, segSites=15)

#Set simulation parameters
SP = SimParam$new(founderPop)

SP$addTraitA(10)
SP$addSnpChip(5)

#Create population
pop = newPop(founderPop, simParam=SP)
pullQtlGeno(pop, simParam=SP)

</code></pre>

<hr>
<h2 id='pullQtlHaplo'>Pull QTL haplotypes</h2><span id='topic+pullQtlHaplo'></span>

<h3>Description</h3>

<p>Retrieves QTL haplotype data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pullQtlHaplo(
  pop,
  trait = 1,
  haplo = "all",
  chr = NULL,
  asRaw = FALSE,
  simParam = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pullQtlHaplo_+3A_pop">pop</code></td>
<td>
<p>an object of <code><a href="#topic+Pop-class">Pop-class</a></code></p>
</td></tr>
<tr><td><code id="pullQtlHaplo_+3A_trait">trait</code></td>
<td>
<p>an integer. Indicates which trait's
QTL haplotypes to retrieve.</p>
</td></tr>
<tr><td><code id="pullQtlHaplo_+3A_haplo">haplo</code></td>
<td>
<p>either &quot;all&quot; for all haplotypes or an integer
for a single set of haplotypes. Use a value of 1 for female
haplotypes and a value of 2 for male haplotypes in diploids.</p>
</td></tr>
<tr><td><code id="pullQtlHaplo_+3A_chr">chr</code></td>
<td>
<p>a vector of chromosomes to retrieve. If NULL,
all chromosome are retrieved.</p>
</td></tr>
<tr><td><code id="pullQtlHaplo_+3A_asraw">asRaw</code></td>
<td>
<p>return in raw (byte) format</p>
</td></tr>
<tr><td><code id="pullQtlHaplo_+3A_simparam">simParam</code></td>
<td>
<p>an object of <code><a href="#topic+SimParam">SimParam</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a matrix of QTL haplotypes.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Create founder haplotypes
founderPop = quickHaplo(nInd=10, nChr=1, segSites=15)

#Set simulation parameters
SP = SimParam$new(founderPop)

SP$addTraitA(10)
SP$addSnpChip(5)

#Create population
pop = newPop(founderPop, simParam=SP)
pullQtlHaplo(pop, simParam=SP)

</code></pre>

<hr>
<h2 id='pullSegSiteGeno'>Pull segregating site genotypes</h2><span id='topic+pullSegSiteGeno'></span>

<h3>Description</h3>

<p>Retrieves genotype data for all segregating sites
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pullSegSiteGeno(pop, chr = NULL, asRaw = FALSE, simParam = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pullSegSiteGeno_+3A_pop">pop</code></td>
<td>
<p>an object of <code><a href="#topic+RawPop-class">RawPop-class</a></code> or
<code><a href="#topic+MapPop-class">MapPop-class</a></code></p>
</td></tr>
<tr><td><code id="pullSegSiteGeno_+3A_chr">chr</code></td>
<td>
<p>a vector of chromosomes to retrieve. If NULL,
all chromosome are retrieved.</p>
</td></tr>
<tr><td><code id="pullSegSiteGeno_+3A_asraw">asRaw</code></td>
<td>
<p>return in raw (byte) format</p>
</td></tr>
<tr><td><code id="pullSegSiteGeno_+3A_simparam">simParam</code></td>
<td>
<p>an object of <code><a href="#topic+SimParam">SimParam</a></code>, not 
used if pop is <code><a href="#topic+MapPop-class">MapPop-class</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a matrix of genotypes
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Create founder haplotypes
founderPop = quickHaplo(nInd=10, nChr=1, segSites=15)

#Set simulation parameters
SP = SimParam$new(founderPop)
SP$addTraitA(10)
SP$addSnpChip(5)

#Create population
pop = newPop(founderPop, simParam=SP)
pullSegSiteGeno(pop, simParam=SP)

</code></pre>

<hr>
<h2 id='pullSegSiteHaplo'>Pull seg site haplotypes</h2><span id='topic+pullSegSiteHaplo'></span>

<h3>Description</h3>

<p>Retrieves haplotype data for all segregating sites
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pullSegSiteHaplo(
  pop,
  haplo = "all",
  chr = NULL,
  asRaw = FALSE,
  simParam = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pullSegSiteHaplo_+3A_pop">pop</code></td>
<td>
<p>an object of <code><a href="#topic+RawPop-class">RawPop-class</a></code> or
<code><a href="#topic+MapPop-class">MapPop-class</a></code></p>
</td></tr>
<tr><td><code id="pullSegSiteHaplo_+3A_haplo">haplo</code></td>
<td>
<p>either &quot;all&quot; for all haplotypes or an integer
for a single set of haplotypes. Use a value of 1 for female
haplotypes and a value of 2 for male haplotypes in diploids.</p>
</td></tr>
<tr><td><code id="pullSegSiteHaplo_+3A_chr">chr</code></td>
<td>
<p>a vector of chromosomes to retrieve. If NULL,
all chromosome are retrieved.</p>
</td></tr>
<tr><td><code id="pullSegSiteHaplo_+3A_asraw">asRaw</code></td>
<td>
<p>return in raw (byte) format</p>
</td></tr>
<tr><td><code id="pullSegSiteHaplo_+3A_simparam">simParam</code></td>
<td>
<p>an object of <code><a href="#topic+SimParam">SimParam</a></code>, not 
used if pop is <code><a href="#topic+MapPop-class">MapPop-class</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a matrix of haplotypes
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Create founder haplotypes
founderPop = quickHaplo(nInd=10, nChr=1, segSites=15)

#Set simulation parameters
SP = SimParam$new(founderPop)

SP$addTraitA(10)
SP$addSnpChip(5)

#Create population
pop = newPop(founderPop, simParam=SP)
pullSegSiteHaplo(pop, simParam=SP)

</code></pre>

<hr>
<h2 id='pullSnpGeno'>Pull SNP genotypes</h2><span id='topic+pullSnpGeno'></span>

<h3>Description</h3>

<p>Retrieves SNP genotype data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pullSnpGeno(pop, snpChip = 1, chr = NULL, asRaw = FALSE, simParam = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pullSnpGeno_+3A_pop">pop</code></td>
<td>
<p>an object of <code><a href="#topic+Pop-class">Pop-class</a></code></p>
</td></tr>
<tr><td><code id="pullSnpGeno_+3A_snpchip">snpChip</code></td>
<td>
<p>an integer. Indicates which SNP
chip's genotypes to retrieve.</p>
</td></tr>
<tr><td><code id="pullSnpGeno_+3A_chr">chr</code></td>
<td>
<p>a vector of chromosomes to retrieve. If NULL,
all chromosome are retrieved.</p>
</td></tr>
<tr><td><code id="pullSnpGeno_+3A_asraw">asRaw</code></td>
<td>
<p>return in raw (byte) format</p>
</td></tr>
<tr><td><code id="pullSnpGeno_+3A_simparam">simParam</code></td>
<td>
<p>an object of <code><a href="#topic+SimParam">SimParam</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a matrix of SNP genotypes.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Create founder haplotypes
founderPop = quickHaplo(nInd=10, nChr=1, segSites=15)

#Set simulation parameters
SP = SimParam$new(founderPop)

SP$addTraitA(10)
SP$addSnpChip(5)

#Create population
pop = newPop(founderPop, simParam=SP)
pullSnpGeno(pop, simParam=SP)

</code></pre>

<hr>
<h2 id='pullSnpHaplo'>Pull SNP haplotypes</h2><span id='topic+pullSnpHaplo'></span>

<h3>Description</h3>

<p>Retrieves SNP haplotype data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pullSnpHaplo(
  pop,
  snpChip = 1,
  haplo = "all",
  chr = NULL,
  asRaw = FALSE,
  simParam = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pullSnpHaplo_+3A_pop">pop</code></td>
<td>
<p>an object of <code><a href="#topic+Pop-class">Pop-class</a></code></p>
</td></tr>
<tr><td><code id="pullSnpHaplo_+3A_snpchip">snpChip</code></td>
<td>
<p>an integer. Indicates which SNP
chip's haplotypes to retrieve.</p>
</td></tr>
<tr><td><code id="pullSnpHaplo_+3A_haplo">haplo</code></td>
<td>
<p>either &quot;all&quot; for all haplotypes or an integer
for a single set of haplotypes. Use a value of 1 for female
haplotypes and a value of 2 for male haplotypes in diploids.</p>
</td></tr>
<tr><td><code id="pullSnpHaplo_+3A_chr">chr</code></td>
<td>
<p>a vector of chromosomes to retrieve. If NULL,
all chromosome are retrieved.</p>
</td></tr>
<tr><td><code id="pullSnpHaplo_+3A_asraw">asRaw</code></td>
<td>
<p>return in raw (byte) format</p>
</td></tr>
<tr><td><code id="pullSnpHaplo_+3A_simparam">simParam</code></td>
<td>
<p>an object of <code><a href="#topic+SimParam">SimParam</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a matrix of SNP haplotypes.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Create founder haplotypes
founderPop = quickHaplo(nInd=10, nChr=1, segSites=15)

#Set simulation parameters
SP = SimParam$new(founderPop)

SP$addTraitA(10)
SP$addSnpChip(5)

#Create population
pop = newPop(founderPop, simParam=SP)
pullSnpHaplo(pop, simParam=SP)

</code></pre>

<hr>
<h2 id='quickHaplo'>Quick founder haplotype simulation</h2><span id='topic+quickHaplo'></span>

<h3>Description</h3>

<p>Rapidly simulates founder haplotypes by randomly 
sampling 0s and 1s. This is equivalent to having all loci with 
allele frequency 0.5 and being in linkage equilibrium.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>quickHaplo(nInd, nChr, segSites, genLen = 1, ploidy = 2L, inbred = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="quickHaplo_+3A_nind">nInd</code></td>
<td>
<p>number of individuals to simulate</p>
</td></tr>
<tr><td><code id="quickHaplo_+3A_nchr">nChr</code></td>
<td>
<p>number of chromosomes to simulate</p>
</td></tr>
<tr><td><code id="quickHaplo_+3A_segsites">segSites</code></td>
<td>
<p>number of segregating sites per chromosome</p>
</td></tr>
<tr><td><code id="quickHaplo_+3A_genlen">genLen</code></td>
<td>
<p>genetic length of chromosomes</p>
</td></tr>
<tr><td><code id="quickHaplo_+3A_ploidy">ploidy</code></td>
<td>
<p>ploidy level of organism</p>
</td></tr>
<tr><td><code id="quickHaplo_+3A_inbred">inbred</code></td>
<td>
<p>should founder individuals be inbred</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of <code><a href="#topic+MapPop-class">MapPop-class</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Creates a populations of 10 outbred individuals
# Their genome consists of 1 chromosome and 100 segregating sites
founderPop = quickHaplo(nInd=10,nChr=1,segSites=100)

</code></pre>

<hr>
<h2 id='randCross'>Make random crosses</h2><span id='topic+randCross'></span>

<h3>Description</h3>

<p>A wrapper for <code><a href="#topic+makeCross">makeCross</a></code> that randomly
selects parental combinations for all possible combinantions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>randCross(
  pop,
  nCrosses,
  nProgeny = 1,
  balance = TRUE,
  parents = NULL,
  ignoreSexes = FALSE,
  simParam = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="randCross_+3A_pop">pop</code></td>
<td>
<p>an object of <code><a href="#topic+Pop-class">Pop-class</a></code></p>
</td></tr>
<tr><td><code id="randCross_+3A_ncrosses">nCrosses</code></td>
<td>
<p>total number of crosses to make</p>
</td></tr>
<tr><td><code id="randCross_+3A_nprogeny">nProgeny</code></td>
<td>
<p>number of progeny per cross</p>
</td></tr>
<tr><td><code id="randCross_+3A_balance">balance</code></td>
<td>
<p>if using sexes, this option will balance the number
of progeny per parent</p>
</td></tr>
<tr><td><code id="randCross_+3A_parents">parents</code></td>
<td>
<p>an optional vector of indices for allowable parents</p>
</td></tr>
<tr><td><code id="randCross_+3A_ignoresexes">ignoreSexes</code></td>
<td>
<p>should sexes be ignored</p>
</td></tr>
<tr><td><code id="randCross_+3A_simparam">simParam</code></td>
<td>
<p>an object of <code><a href="#topic+SimParam">SimParam</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an object of <code><a href="#topic+Pop-class">Pop-class</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Create founder haplotypes
founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)

#Set simulation parameters
SP = SimParam$new(founderPop)


#Create population
pop = newPop(founderPop, simParam=SP)

#Make 10 crosses
pop2 = randCross(pop, 10, simParam=SP)

</code></pre>

<hr>
<h2 id='randCross2'>Make random crosses</h2><span id='topic+randCross2'></span>

<h3>Description</h3>

<p>A wrapper for <code><a href="#topic+makeCross2">makeCross2</a></code> that randomly
selects parental combinations for all possible combinantions between
two populations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>randCross2(
  females,
  males,
  nCrosses,
  nProgeny = 1,
  balance = TRUE,
  femaleParents = NULL,
  maleParents = NULL,
  ignoreSexes = FALSE,
  simParam = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="randCross2_+3A_females">females</code></td>
<td>
<p>an object of <code><a href="#topic+Pop-class">Pop-class</a></code> for female parents.</p>
</td></tr>
<tr><td><code id="randCross2_+3A_males">males</code></td>
<td>
<p>an object of <code><a href="#topic+Pop-class">Pop-class</a></code> for male parents.</p>
</td></tr>
<tr><td><code id="randCross2_+3A_ncrosses">nCrosses</code></td>
<td>
<p>total number of crosses to make</p>
</td></tr>
<tr><td><code id="randCross2_+3A_nprogeny">nProgeny</code></td>
<td>
<p>number of progeny per cross</p>
</td></tr>
<tr><td><code id="randCross2_+3A_balance">balance</code></td>
<td>
<p>this option will balance the number
of progeny per parent</p>
</td></tr>
<tr><td><code id="randCross2_+3A_femaleparents">femaleParents</code></td>
<td>
<p>an optional vector of indices for allowable
female parents</p>
</td></tr>
<tr><td><code id="randCross2_+3A_maleparents">maleParents</code></td>
<td>
<p>an optional vector of indices for allowable
male parents</p>
</td></tr>
<tr><td><code id="randCross2_+3A_ignoresexes">ignoreSexes</code></td>
<td>
<p>should sex be ignored</p>
</td></tr>
<tr><td><code id="randCross2_+3A_simparam">simParam</code></td>
<td>
<p>an object of <code><a href="#topic+SimParam">SimParam</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an object of <code><a href="#topic+Pop-class">Pop-class</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Create founder haplotypes
founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)

#Set simulation parameters
SP = SimParam$new(founderPop)


#Create population
pop = newPop(founderPop, simParam=SP)

#Make 10 crosses
pop2 = randCross2(pop, pop, 10, simParam=SP)

</code></pre>

<hr>
<h2 id='RawPop-class'>Raw Population</h2><span id='topic+RawPop-class'></span><span id='topic++5B+2CRawPop-method'></span><span id='topic+c+2CRawPop-method'></span><span id='topic+show+2CRawPop-method'></span><span id='topic+isRawPop'></span>

<h3>Description</h3>

<p>The raw population class contains only genotype data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'RawPop'
x[i]

## S4 method for signature 'RawPop'
c(x, ...)

## S4 method for signature 'RawPop'
show(object)

isRawPop(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RawPop-class_+3A_x">x</code></td>
<td>
<p>a 'RawPop' object</p>
</td></tr>
<tr><td><code id="RawPop-class_+3A_i">i</code></td>
<td>
<p>index of individuals</p>
</td></tr>
<tr><td><code id="RawPop-class_+3A_...">...</code></td>
<td>
<p>additional 'RawPop' objects</p>
</td></tr>
<tr><td><code id="RawPop-class_+3A_object">object</code></td>
<td>
<p>a 'RawPop' object</p>
</td></tr>
</table>


<h3>Methods (by generic)</h3>


<ul>
<li> <p><code>[</code>: Extract RawPop by index
</p>
</li>
<li> <p><code>c(RawPop)</code>: Combine multiple RawPops
</p>
</li>
<li> <p><code>show(RawPop)</code>: Show population summary
</p>
</li></ul>


<h3>Functions</h3>


<ul>
<li> <p><code>isRawPop()</code>: Test if object is of a RawPop class
</p>
</li></ul>


<h3>Slots</h3>


<dl>
<dt><code>nInd</code></dt><dd><p>number of individuals</p>
</dd>
<dt><code>nChr</code></dt><dd><p>number of chromosomes</p>
</dd>
<dt><code>ploidy</code></dt><dd><p>level of ploidy</p>
</dd>
<dt><code>nLoci</code></dt><dd><p>number of loci per chromosome</p>
</dd>
<dt><code>geno</code></dt><dd><p>list of nChr length containing chromosome genotypes.
Each element is a three dimensional array of raw values.
The array dimensions are nLoci by ploidy by nInd.</p>
</dd>
</dl>

<hr>
<h2 id='reduceGenome'>Create individuals with reduced ploidy</h2><span id='topic+reduceGenome'></span>

<h3>Description</h3>

<p>Creates new individuals from gametes. This function 
was created to model the creation of diploid potatoes from 
tetraploid potatoes. It can be used on any population with an 
even ploidy level. The newly created individuals will have half 
the ploidy level of the originals. The reduction can occur with 
or without genetic recombination.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reduceGenome(
  pop,
  nProgeny = 1,
  useFemale = TRUE,
  keepParents = TRUE,
  simRecomb = TRUE,
  simParam = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reduceGenome_+3A_pop">pop</code></td>
<td>
<p>an object of 'Pop' superclass</p>
</td></tr>
<tr><td><code id="reduceGenome_+3A_nprogeny">nProgeny</code></td>
<td>
<p>total number of progeny per individual</p>
</td></tr>
<tr><td><code id="reduceGenome_+3A_usefemale">useFemale</code></td>
<td>
<p>should female recombination rates be used.</p>
</td></tr>
<tr><td><code id="reduceGenome_+3A_keepparents">keepParents</code></td>
<td>
<p>should previous parents be used for mother and 
father.</p>
</td></tr>
<tr><td><code id="reduceGenome_+3A_simrecomb">simRecomb</code></td>
<td>
<p>should genetic recombination be modeled.</p>
</td></tr>
<tr><td><code id="reduceGenome_+3A_simparam">simParam</code></td>
<td>
<p>an object of 'SimParam' class</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an object of <code><a href="#topic+Pop-class">Pop-class</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Create founder haplotypes
founderPop = quickHaplo(nInd=2, nChr=1, segSites=10)

#Set simulation parameters
SP = SimParam$new(founderPop)


#Create population
pop = newPop(founderPop, simParam=SP)

#Create individuals with reduced ploidy
pop2 = reduceGenome(pop, simParam=SP)

</code></pre>

<hr>
<h2 id='resetPop'>Reset population</h2><span id='topic+resetPop'></span>

<h3>Description</h3>

<p>Recalculates a population's genetic values and
resets phenotypes and EBVs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>resetPop(pop, simParam = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="resetPop_+3A_pop">pop</code></td>
<td>
<p>an object of <code><a href="#topic+Pop-class">Pop-class</a></code></p>
</td></tr>
<tr><td><code id="resetPop_+3A_simparam">simParam</code></td>
<td>
<p>an object of <code><a href="#topic+SimParam">SimParam</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of <code><a href="#topic+Pop-class">Pop-class</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Create founder haplotypes
founderPop = quickHaplo(nInd=2, nChr=1, segSites=10)

#Set simulation parameters
SP = SimParam$new(founderPop)
SP$addTraitA(10)

#Create population
pop = newPop(founderPop, simParam=SP)

#Rescale to set mean to 1
SP$rescaleTraits(mean=1)
pop = resetPop(pop, simParam=SP)

</code></pre>

<hr>
<h2 id='RRBLUP'>RR-BLUP Model</h2><span id='topic+RRBLUP'></span>

<h3>Description</h3>

<p>Fits an RR-BLUP model for genomic predictions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RRBLUP(
  pop,
  traits = 1,
  use = "pheno",
  snpChip = 1,
  useQtl = FALSE,
  maxIter = 1000L,
  simParam = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RRBLUP_+3A_pop">pop</code></td>
<td>
<p>a <code><a href="#topic+Pop-class">Pop-class</a></code> to serve as the training population</p>
</td></tr>
<tr><td><code id="RRBLUP_+3A_traits">traits</code></td>
<td>
<p>an integer indicating the trait or traits to model, a vector of trait names, 
or a function of the traits returning a single value.</p>
</td></tr>
<tr><td><code id="RRBLUP_+3A_use">use</code></td>
<td>
<p>train model using phenotypes &quot;pheno&quot;, genetic values &quot;gv&quot;, 
estimated breeding values &quot;ebv&quot;, breeding values &quot;bv&quot;, or randomly &quot;rand&quot;</p>
</td></tr>
<tr><td><code id="RRBLUP_+3A_snpchip">snpChip</code></td>
<td>
<p>an integer indicating which SNP chip genotype 
to use</p>
</td></tr>
<tr><td><code id="RRBLUP_+3A_useqtl">useQtl</code></td>
<td>
<p>should QTL genotypes be used instead of a SNP chip. 
If TRUE, snpChip specifies which trait's QTL to use, and thus these 
QTL may not match the QTL underlying the phenotype supplied in traits.</p>
</td></tr>
<tr><td><code id="RRBLUP_+3A_maxiter">maxIter</code></td>
<td>
<p>maximum number of iterations. Only used 
when number of traits is greater than 1.</p>
</td></tr>
<tr><td><code id="RRBLUP_+3A_simparam">simParam</code></td>
<td>
<p>an object of <code><a href="#topic+SimParam">SimParam</a></code></p>
</td></tr>
<tr><td><code id="RRBLUP_+3A_...">...</code></td>
<td>
<p>additional arguments if using a function for 
traits</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>#Create founder haplotypes
founderPop = quickHaplo(nInd=10, nChr=1, segSites=20)

#Set simulation parameters
SP = SimParam$new(founderPop)

SP$addTraitA(10)
SP$setVarE(h2=0.5)
SP$addSnpChip(10)

#Create population
pop = newPop(founderPop, simParam=SP)

#Run GS model and set EBV
ans = RRBLUP(pop, simParam=SP)
pop = setEBV(pop, ans, simParam=SP)

#Evaluate accuracy
cor(gv(pop), ebv(pop))

</code></pre>

<hr>
<h2 id='RRBLUP_D'>RR-BLUP Model with Dominance</h2><span id='topic+RRBLUP_D'></span>

<h3>Description</h3>

<p>Fits an RR-BLUP model for genomic predictions that includes 
dominance effects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RRBLUP_D(
  pop,
  traits = 1,
  use = "pheno",
  snpChip = 1,
  useQtl = FALSE,
  maxIter = 40L,
  simParam = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RRBLUP_D_+3A_pop">pop</code></td>
<td>
<p>a <code><a href="#topic+Pop-class">Pop-class</a></code> to serve as the training population</p>
</td></tr>
<tr><td><code id="RRBLUP_D_+3A_traits">traits</code></td>
<td>
<p>an integer indicating the trait to model, a trait name, or a
function of the traits returning a single value.</p>
</td></tr>
<tr><td><code id="RRBLUP_D_+3A_use">use</code></td>
<td>
<p>train model using phenotypes &quot;pheno&quot;, genetic values &quot;gv&quot;, 
estimated breeding values &quot;ebv&quot;, breeding values &quot;bv&quot;, or randomly &quot;rand&quot;</p>
</td></tr>
<tr><td><code id="RRBLUP_D_+3A_snpchip">snpChip</code></td>
<td>
<p>an integer indicating which SNP chip genotype 
to use</p>
</td></tr>
<tr><td><code id="RRBLUP_D_+3A_useqtl">useQtl</code></td>
<td>
<p>should QTL genotypes be used instead of a SNP chip. 
If TRUE, snpChip specifies which trait's QTL to use, and thus these 
QTL may not match the QTL underlying the phenotype supplied in traits.</p>
</td></tr>
<tr><td><code id="RRBLUP_D_+3A_maxiter">maxIter</code></td>
<td>
<p>maximum number of iterations. Only used 
when number of traits is greater than 1.</p>
</td></tr>
<tr><td><code id="RRBLUP_D_+3A_simparam">simParam</code></td>
<td>
<p>an object of <code><a href="#topic+SimParam">SimParam</a></code></p>
</td></tr>
<tr><td><code id="RRBLUP_D_+3A_...">...</code></td>
<td>
<p>additional arguments if using a function for 
traits</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>#Create founder haplotypes
founderPop = quickHaplo(nInd=10, nChr=1, segSites=20)

#Set simulation parameters
SP = SimParam$new(founderPop)

SP$addTraitAD(10, meanDD=0.5)
SP$setVarE(h2=0.5)
SP$addSnpChip(10)

#Create population
pop = newPop(founderPop, simParam=SP)

#Run GS model and set EBV
ans = RRBLUP_D(pop, simParam=SP)
pop = setEBV(pop, ans, simParam=SP)

#Evaluate accuracy
cor(gv(pop), ebv(pop))

</code></pre>

<hr>
<h2 id='RRBLUP_D2'>RR-BLUP with Dominance Model 2</h2><span id='topic+RRBLUP_D2'></span>

<h3>Description</h3>

<p>Fits an RR-BLUP model for genomic predictions that includes 
dominance effects. This implementation is meant for situations where 
<code><a href="#topic+RRBLUP_D">RRBLUP_D</a></code> is too slow. Note that RRBLUP_D2 
is only faster in certain situations. Most users should use 
<code><a href="#topic+RRBLUP_D">RRBLUP_D</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RRBLUP_D2(
  pop,
  traits = 1,
  use = "pheno",
  snpChip = 1,
  useQtl = FALSE,
  maxIter = 10,
  Va = NULL,
  Vd = NULL,
  Ve = NULL,
  useEM = TRUE,
  tol = 1e-06,
  simParam = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RRBLUP_D2_+3A_pop">pop</code></td>
<td>
<p>a <code><a href="#topic+Pop-class">Pop-class</a></code> to serve as the training population</p>
</td></tr>
<tr><td><code id="RRBLUP_D2_+3A_traits">traits</code></td>
<td>
<p>an integer indicating the trait to model, a trait name, or a
function of the traits returning a single value.</p>
</td></tr>
<tr><td><code id="RRBLUP_D2_+3A_use">use</code></td>
<td>
<p>train model using phenotypes &quot;pheno&quot;, genetic values &quot;gv&quot;, 
estimated breeding values &quot;ebv&quot;, breeding values &quot;bv&quot;, or randomly &quot;rand&quot;</p>
</td></tr>
<tr><td><code id="RRBLUP_D2_+3A_snpchip">snpChip</code></td>
<td>
<p>an integer indicating which SNP chip genotype 
to use</p>
</td></tr>
<tr><td><code id="RRBLUP_D2_+3A_useqtl">useQtl</code></td>
<td>
<p>should QTL genotypes be used instead of a SNP chip. 
If TRUE, snpChip specifies which trait's QTL to use, and thus these 
QTL may not match the QTL underlying the phenotype supplied in traits.</p>
</td></tr>
<tr><td><code id="RRBLUP_D2_+3A_maxiter">maxIter</code></td>
<td>
<p>maximum number of iterations. Only used 
when number of traits is greater than 1.</p>
</td></tr>
<tr><td><code id="RRBLUP_D2_+3A_va">Va</code></td>
<td>
<p>marker effect variance for additive effects. If value is NULL, 
a reasonable starting point is chosen automatically.</p>
</td></tr>
<tr><td><code id="RRBLUP_D2_+3A_vd">Vd</code></td>
<td>
<p>marker effect variance for dominance effects. If value is NULL, 
a reasonable starting point is chosen automatically.</p>
</td></tr>
<tr><td><code id="RRBLUP_D2_+3A_ve">Ve</code></td>
<td>
<p>error variance. If value is NULL, a 
reasonable starting point is chosen automatically.</p>
</td></tr>
<tr><td><code id="RRBLUP_D2_+3A_useem">useEM</code></td>
<td>
<p>use EM to solve variance components. If false, 
the initial values are considered true.</p>
</td></tr>
<tr><td><code id="RRBLUP_D2_+3A_tol">tol</code></td>
<td>
<p>tolerance for EM algorithm convergence</p>
</td></tr>
<tr><td><code id="RRBLUP_D2_+3A_simparam">simParam</code></td>
<td>
<p>an object of <code><a href="#topic+SimParam">SimParam</a></code></p>
</td></tr>
<tr><td><code id="RRBLUP_D2_+3A_...">...</code></td>
<td>
<p>additional arguments if using a function for 
traits</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>#Create founder haplotypes
founderPop = quickHaplo(nInd=10, nChr=1, segSites=20)

#Set simulation parameters
SP = SimParam$new(founderPop)

SP$addTraitAD(10, meanDD=0.5)
SP$setVarE(h2=0.5)
SP$addSnpChip(10)

#Create population
pop = newPop(founderPop, simParam=SP)

#Run GS model and set EBV
ans = RRBLUP_D2(pop, simParam=SP)
pop = setEBV(pop, ans, simParam=SP)

#Evaluate accuracy
cor(gv(pop), ebv(pop))

</code></pre>

<hr>
<h2 id='RRBLUP_GCA'>RR-BLUP GCA Model</h2><span id='topic+RRBLUP_GCA'></span>

<h3>Description</h3>

<p>Fits an RR-BLUP model that estimates seperate marker effects for
females and males. Useful for predicting GCA of parents
in single cross hybrids. Can also predict performance of specific 
single cross hybrids.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RRBLUP_GCA(
  pop,
  traits = 1,
  use = "pheno",
  snpChip = 1,
  useQtl = FALSE,
  maxIter = 40L,
  simParam = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RRBLUP_GCA_+3A_pop">pop</code></td>
<td>
<p>a <code><a href="#topic+Pop-class">Pop-class</a></code> to serve as the training population</p>
</td></tr>
<tr><td><code id="RRBLUP_GCA_+3A_traits">traits</code></td>
<td>
<p>an integer indicating the trait to model, a trait name, or a
function of the traits returning a single value.</p>
</td></tr>
<tr><td><code id="RRBLUP_GCA_+3A_use">use</code></td>
<td>
<p>train model using phenotypes &quot;pheno&quot;, genetic values &quot;gv&quot;, 
estimated breeding values &quot;ebv&quot;, breeding values &quot;bv&quot;, or randomly &quot;rand&quot;</p>
</td></tr>
<tr><td><code id="RRBLUP_GCA_+3A_snpchip">snpChip</code></td>
<td>
<p>an integer indicating which SNP chip genotype 
to use</p>
</td></tr>
<tr><td><code id="RRBLUP_GCA_+3A_useqtl">useQtl</code></td>
<td>
<p>should QTL genotypes be used instead of a SNP chip. 
If TRUE, snpChip specifies which trait's QTL to use, and thus these 
QTL may not match the QTL underlying the phenotype supplied in traits.</p>
</td></tr>
<tr><td><code id="RRBLUP_GCA_+3A_maxiter">maxIter</code></td>
<td>
<p>maximum number of iterations for convergence.</p>
</td></tr>
<tr><td><code id="RRBLUP_GCA_+3A_simparam">simParam</code></td>
<td>
<p>an object of <code><a href="#topic+SimParam">SimParam</a></code></p>
</td></tr>
<tr><td><code id="RRBLUP_GCA_+3A_...">...</code></td>
<td>
<p>additional arguments if using a function for 
traits</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>#Create founder haplotypes
founderPop = quickHaplo(nInd=10, nChr=1, segSites=20)

#Set simulation parameters
SP = SimParam$new(founderPop)

SP$addTraitA(10)
SP$setVarE(h2=0.5)
SP$addSnpChip(10)

#Create population
pop = newPop(founderPop, simParam=SP)

#Run GS model and set EBV
ans = RRBLUP_GCA(pop, simParam=SP)
pop = setEBV(pop, ans, simParam=SP)

#Evaluate accuracy
cor(gv(pop), ebv(pop))

</code></pre>

<hr>
<h2 id='RRBLUP_GCA2'>RR-BLUP GCA Model 2</h2><span id='topic+RRBLUP_GCA2'></span>

<h3>Description</h3>

<p>Fits an RR-BLUP model that estimates seperate marker effects for
females and males. This implementation is meant for situations where 
<code><a href="#topic+RRBLUP_GCA">RRBLUP_GCA</a></code> is too slow. Note that RRBLUP_GCA2 
is only faster in certain situations. Most users should use 
<code><a href="#topic+RRBLUP_GCA">RRBLUP_GCA</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RRBLUP_GCA2(
  pop,
  traits = 1,
  use = "pheno",
  snpChip = 1,
  useQtl = FALSE,
  maxIter = 10,
  VuF = NULL,
  VuM = NULL,
  Ve = NULL,
  useEM = TRUE,
  tol = 1e-06,
  simParam = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RRBLUP_GCA2_+3A_pop">pop</code></td>
<td>
<p>a <code><a href="#topic+Pop-class">Pop-class</a></code> to serve as the training population</p>
</td></tr>
<tr><td><code id="RRBLUP_GCA2_+3A_traits">traits</code></td>
<td>
<p>an integer indicating the trait to model, a trait name, or a
function of the traits returning a single value.</p>
</td></tr>
<tr><td><code id="RRBLUP_GCA2_+3A_use">use</code></td>
<td>
<p>train model using phenotypes &quot;pheno&quot;, genetic values &quot;gv&quot;, 
estimated breeding values &quot;ebv&quot;, breeding values &quot;bv&quot;, or randomly &quot;rand&quot;</p>
</td></tr>
<tr><td><code id="RRBLUP_GCA2_+3A_snpchip">snpChip</code></td>
<td>
<p>an integer indicating which SNP chip genotype 
to use</p>
</td></tr>
<tr><td><code id="RRBLUP_GCA2_+3A_useqtl">useQtl</code></td>
<td>
<p>should QTL genotypes be used instead of a SNP chip. 
If TRUE, snpChip specifies which trait's QTL to use, and thus these 
QTL may not match the QTL underlying the phenotype supplied in traits.</p>
</td></tr>
<tr><td><code id="RRBLUP_GCA2_+3A_maxiter">maxIter</code></td>
<td>
<p>maximum number of iterations for convergence.</p>
</td></tr>
<tr><td><code id="RRBLUP_GCA2_+3A_vuf">VuF</code></td>
<td>
<p>marker effect variance for females. If value is NULL, a 
reasonable starting point is chosen automatically.</p>
</td></tr>
<tr><td><code id="RRBLUP_GCA2_+3A_vum">VuM</code></td>
<td>
<p>marker effect variance for males. If value is NULL, a 
reasonable starting point is chosen automatically.</p>
</td></tr>
<tr><td><code id="RRBLUP_GCA2_+3A_ve">Ve</code></td>
<td>
<p>error variance. If value is NULL, a 
reasonable starting point is chosen automatically.</p>
</td></tr>
<tr><td><code id="RRBLUP_GCA2_+3A_useem">useEM</code></td>
<td>
<p>use EM to solve variance components. If false, 
the initial values are considered true.</p>
</td></tr>
<tr><td><code id="RRBLUP_GCA2_+3A_tol">tol</code></td>
<td>
<p>tolerance for EM algorithm convergence</p>
</td></tr>
<tr><td><code id="RRBLUP_GCA2_+3A_simparam">simParam</code></td>
<td>
<p>an object of <code><a href="#topic+SimParam">SimParam</a></code></p>
</td></tr>
<tr><td><code id="RRBLUP_GCA2_+3A_...">...</code></td>
<td>
<p>additional arguments if using a function for 
traits</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>#Create founder haplotypes
founderPop = quickHaplo(nInd=10, nChr=1, segSites=20)

#Set simulation parameters
SP = SimParam$new(founderPop)

SP$addTraitA(10)
SP$setVarE(h2=0.5)
SP$addSnpChip(10)

#Create population
pop = newPop(founderPop, simParam=SP)

#Run GS model and set EBV
ans = RRBLUP_GCA2(pop, simParam=SP)
pop = setEBV(pop, ans, simParam=SP)

#Evaluate accuracy
cor(gv(pop), ebv(pop))

</code></pre>

<hr>
<h2 id='RRBLUP_SCA'>RR-BLUP SCA Model</h2><span id='topic+RRBLUP_SCA'></span>

<h3>Description</h3>

<p>An extention of <code><a href="#topic+RRBLUP_GCA">RRBLUP_GCA</a></code> that adds dominance effects. 
Note that we have not seen any consistent benefit of this model over 
<code><a href="#topic+RRBLUP_GCA">RRBLUP_GCA</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RRBLUP_SCA(
  pop,
  traits = 1,
  use = "pheno",
  snpChip = 1,
  useQtl = FALSE,
  maxIter = 40L,
  simParam = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RRBLUP_SCA_+3A_pop">pop</code></td>
<td>
<p>a <code><a href="#topic+Pop-class">Pop-class</a></code> to serve as the training population</p>
</td></tr>
<tr><td><code id="RRBLUP_SCA_+3A_traits">traits</code></td>
<td>
<p>an integer indicating the trait to model, a trait name, or a
function of the traits returning a single value.</p>
</td></tr>
<tr><td><code id="RRBLUP_SCA_+3A_use">use</code></td>
<td>
<p>train model using phenotypes &quot;pheno&quot;, genetic values &quot;gv&quot;, 
estimated breeding values &quot;ebv&quot;, breeding values &quot;bv&quot;, or randomly &quot;rand&quot;</p>
</td></tr>
<tr><td><code id="RRBLUP_SCA_+3A_snpchip">snpChip</code></td>
<td>
<p>an integer indicating which SNP chip genotype 
to use</p>
</td></tr>
<tr><td><code id="RRBLUP_SCA_+3A_useqtl">useQtl</code></td>
<td>
<p>should QTL genotypes be used instead of a SNP chip. 
If TRUE, snpChip specifies which trait's QTL to use, and thus these 
QTL may not match the QTL underlying the phenotype supplied in traits.</p>
</td></tr>
<tr><td><code id="RRBLUP_SCA_+3A_maxiter">maxIter</code></td>
<td>
<p>maximum number of iterations for convergence.</p>
</td></tr>
<tr><td><code id="RRBLUP_SCA_+3A_simparam">simParam</code></td>
<td>
<p>an object of <code><a href="#topic+SimParam">SimParam</a></code></p>
</td></tr>
<tr><td><code id="RRBLUP_SCA_+3A_...">...</code></td>
<td>
<p>additional arguments if using a function for 
traits</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>#Create founder haplotypes
founderPop = quickHaplo(nInd=2, nChr=1, segSites=20)

#Set simulation parameters
SP = SimParam$new(founderPop)

SP$addTraitA(10)
SP$setVarE(h2=0.5)
SP$addSnpChip(10)

#Create population
pop = newPop(founderPop, simParam=SP)

#Run GS model and set EBV
ans = RRBLUP_SCA(pop, simParam=SP)
pop = setEBV(pop, ans, simParam=SP)

#Evaluate accuracy
cor(gv(pop), ebv(pop))

</code></pre>

<hr>
<h2 id='RRBLUP_SCA2'>RR-BLUP SCA Model 2</h2><span id='topic+RRBLUP_SCA2'></span>

<h3>Description</h3>

<p>Fits an RR-BLUP model that estimates seperate additive effects for
females and males and a dominance effect. This implementation is meant 
for situations where <code><a href="#topic+RRBLUP_SCA">RRBLUP_SCA</a></code> is too slow. Note that 
RRBLUP_SCA2 is only faster in certain situations. Most users should use 
<code><a href="#topic+RRBLUP_SCA">RRBLUP_SCA</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RRBLUP_SCA2(
  pop,
  traits = 1,
  use = "pheno",
  snpChip = 1,
  useQtl = FALSE,
  maxIter = 10,
  VuF = NULL,
  VuM = NULL,
  VuD = NULL,
  Ve = NULL,
  useEM = TRUE,
  tol = 1e-06,
  simParam = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RRBLUP_SCA2_+3A_pop">pop</code></td>
<td>
<p>a <code><a href="#topic+Pop-class">Pop-class</a></code> to serve as the training population</p>
</td></tr>
<tr><td><code id="RRBLUP_SCA2_+3A_traits">traits</code></td>
<td>
<p>an integer indicating the trait to model, a trait name, or a
function of the traits returning a single value.</p>
</td></tr>
<tr><td><code id="RRBLUP_SCA2_+3A_use">use</code></td>
<td>
<p>train model using phenotypes &quot;pheno&quot;, genetic values &quot;gv&quot;, 
estimated breeding values &quot;ebv&quot;, breeding values &quot;bv&quot;, or randomly &quot;rand&quot;</p>
</td></tr>
<tr><td><code id="RRBLUP_SCA2_+3A_snpchip">snpChip</code></td>
<td>
<p>an integer indicating which SNP chip genotype 
to use</p>
</td></tr>
<tr><td><code id="RRBLUP_SCA2_+3A_useqtl">useQtl</code></td>
<td>
<p>should QTL genotypes be used instead of a SNP chip. 
If TRUE, snpChip specifies which trait's QTL to use, and thus these 
QTL may not match the QTL underlying the phenotype supplied in traits.</p>
</td></tr>
<tr><td><code id="RRBLUP_SCA2_+3A_maxiter">maxIter</code></td>
<td>
<p>maximum number of iterations for convergence.</p>
</td></tr>
<tr><td><code id="RRBLUP_SCA2_+3A_vuf">VuF</code></td>
<td>
<p>marker effect variance for females. If value is NULL, a 
reasonable starting point is chosen automatically.</p>
</td></tr>
<tr><td><code id="RRBLUP_SCA2_+3A_vum">VuM</code></td>
<td>
<p>marker effect variance for males. If value is NULL, a 
reasonable starting point is chosen automatically.</p>
</td></tr>
<tr><td><code id="RRBLUP_SCA2_+3A_vud">VuD</code></td>
<td>
<p>marker effect variance for dominance. If value is NULL, a 
reasonable starting point is chosen automatically.</p>
</td></tr>
<tr><td><code id="RRBLUP_SCA2_+3A_ve">Ve</code></td>
<td>
<p>error variance. If value is NULL, a 
reasonable starting point is chosen automatically.</p>
</td></tr>
<tr><td><code id="RRBLUP_SCA2_+3A_useem">useEM</code></td>
<td>
<p>use EM to solve variance components. If false, 
the initial values are considered true.</p>
</td></tr>
<tr><td><code id="RRBLUP_SCA2_+3A_tol">tol</code></td>
<td>
<p>tolerance for EM algorithm convergence</p>
</td></tr>
<tr><td><code id="RRBLUP_SCA2_+3A_simparam">simParam</code></td>
<td>
<p>an object of <code><a href="#topic+SimParam">SimParam</a></code></p>
</td></tr>
<tr><td><code id="RRBLUP_SCA2_+3A_...">...</code></td>
<td>
<p>additional arguments if using a function for 
traits</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>#Create founder haplotypes
founderPop = quickHaplo(nInd=10, nChr=1, segSites=20)

#Set simulation parameters
SP = SimParam$new(founderPop)

SP$addTraitA(10)
SP$setVarE(h2=0.5)
SP$addSnpChip(10)

#Create population
pop = newPop(founderPop, simParam=SP)

#Run GS model and set EBV
ans = RRBLUP_SCA2(pop, simParam=SP)
pop = setEBV(pop, ans, simParam=SP)

#Evaluate accuracy
cor(gv(pop), ebv(pop))

</code></pre>

<hr>
<h2 id='RRBLUP2'>RR-BLUP Model 2</h2><span id='topic+RRBLUP2'></span>

<h3>Description</h3>

<p>Fits an RR-BLUP model for genomic predictions. This implementation is 
meant for situations where <code><a href="#topic+RRBLUP">RRBLUP</a></code> is too slow. Note that 
RRBLUP2 is only faster in certain situations, see details below. Most 
users should use <code><a href="#topic+RRBLUP">RRBLUP</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RRBLUP2(
  pop,
  traits = 1,
  use = "pheno",
  snpChip = 1,
  useQtl = FALSE,
  maxIter = 10,
  Vu = NULL,
  Ve = NULL,
  useEM = TRUE,
  tol = 1e-06,
  simParam = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RRBLUP2_+3A_pop">pop</code></td>
<td>
<p>a <code><a href="#topic+Pop-class">Pop-class</a></code> to serve as the training population</p>
</td></tr>
<tr><td><code id="RRBLUP2_+3A_traits">traits</code></td>
<td>
<p>an integer indicating the trait to model, a trait name, or a
function of the traits returning a single value. Unlike <code><a href="#topic+RRBLUP">RRBLUP</a></code>, 
only univariate models are supported.</p>
</td></tr>
<tr><td><code id="RRBLUP2_+3A_use">use</code></td>
<td>
<p>train model using phenotypes &quot;pheno&quot;, genetic values &quot;gv&quot;, 
estimated breeding values &quot;ebv&quot;, breeding values &quot;bv&quot;, or randomly &quot;rand&quot;</p>
</td></tr>
<tr><td><code id="RRBLUP2_+3A_snpchip">snpChip</code></td>
<td>
<p>an integer indicating which SNP chip genotype 
to use</p>
</td></tr>
<tr><td><code id="RRBLUP2_+3A_useqtl">useQtl</code></td>
<td>
<p>should QTL genotypes be used instead of a SNP chip. 
If TRUE, snpChip specifies which trait's QTL to use, and thus these 
QTL may not match the QTL underlying the phenotype supplied in traits.</p>
</td></tr>
<tr><td><code id="RRBLUP2_+3A_maxiter">maxIter</code></td>
<td>
<p>maximum number of iterations.</p>
</td></tr>
<tr><td><code id="RRBLUP2_+3A_vu">Vu</code></td>
<td>
<p>marker effect variance. If value is NULL, a 
reasonable starting point is chosen automatically.</p>
</td></tr>
<tr><td><code id="RRBLUP2_+3A_ve">Ve</code></td>
<td>
<p>error variance. If value is NULL, a 
reasonable starting point is chosen automatically.</p>
</td></tr>
<tr><td><code id="RRBLUP2_+3A_useem">useEM</code></td>
<td>
<p>use EM to solve variance components. If false, 
the initial values are considered true.</p>
</td></tr>
<tr><td><code id="RRBLUP2_+3A_tol">tol</code></td>
<td>
<p>tolerance for EM algorithm convergence</p>
</td></tr>
<tr><td><code id="RRBLUP2_+3A_simparam">simParam</code></td>
<td>
<p>an object of <code><a href="#topic+SimParam">SimParam</a></code></p>
</td></tr>
<tr><td><code id="RRBLUP2_+3A_...">...</code></td>
<td>
<p>additional arguments if using a function for 
traits</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The RRBLUP2 function works best when the number of markers is not 
too large. This is because it solves the RR-BLUP problem by setting 
up and solving Henderson's mixed model equations. Solving these equations 
involves a square matrix with dimensions equal to the number of fixed 
effects plus the number of random effects (markers). Whereas the <code><a href="#topic+RRBLUP">RRBLUP</a></code> 
function solves the RR-BLUP problem using the EMMA approach. This approach involves 
a square matrix with dimensions equal to the number of phenotypic records. This means 
that the RRBLUP2 function uses less memory than RRBLUP when the number of markers 
is approximately equal to or smaller than the number of phenotypic records. 
</p>
<p>The RRBLUP2 function is not recommend for cases where the variance components are 
unknown. This is uses the EM algorithm to solve for unknown variance components, 
which is generally considerably slower than the EMMA approach of <code><a href="#topic+RRBLUP">RRBLUP</a></code>. 
The number of iterations for the EM algorithm is set by maxIter. The default value 
is typically too small for convergence. When the algorithm fails to converge a 
warning is displayed, but results are given for the last iteration. These results may 
be &quot;good enough&quot;. However we make no claim to this effect, because we can not generalize 
to all possible use cases.
</p>
<p>The RRBLUP2 function can quickly solve the mixed model equations without estimating variance 
components. The variance components are set by defining Vu and Ve. Estimation of components 
is suppressed by setting useEM to false. This may be useful if the model is being retrained 
multiple times during the simulation. You could run <code><a href="#topic+RRBLUP">RRBLUP</a></code> function the first 
time the model is trained, and then use the variance components from this output for all 
future runs with the RRBLUP2 functions. Again, we can make no claim to the general robustness 
of this approach.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Create founder haplotypes
founderPop = quickHaplo(nInd=10, nChr=1, segSites=20)

#Set simulation parameters
SP = SimParam$new(founderPop)

SP$addTraitA(10)
SP$setVarE(h2=0.5)
SP$addSnpChip(10)

#Create population
pop = newPop(founderPop, simParam=SP)

#Run GS model and set EBV
ans = RRBLUP2(pop, simParam=SP)
pop = setEBV(pop, ans, simParam=SP)

#Evaluate accuracy
cor(gv(pop), ebv(pop))

</code></pre>

<hr>
<h2 id='RRBLUPMemUse'>RRBLUP Memory Usage</h2><span id='topic+RRBLUPMemUse'></span>

<h3>Description</h3>

<p>Estimates the amount of RAM needed to run the <code><a href="#topic+RRBLUP">RRBLUP</a></code>
and its related functions for a given training population size. 
Note that this function may underestimate total usage.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RRBLUPMemUse(nInd, nMarker, model = "REG")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RRBLUPMemUse_+3A_nind">nInd</code></td>
<td>
<p>the number of individuals in the training population</p>
</td></tr>
<tr><td><code id="RRBLUPMemUse_+3A_nmarker">nMarker</code></td>
<td>
<p>the number of markers per individual</p>
</td></tr>
<tr><td><code id="RRBLUPMemUse_+3A_model">model</code></td>
<td>
<p>either &quot;REG&quot;, &quot;GCA&quot;, or &quot;SCA&quot; for <code><a href="#topic+RRBLUP">RRBLUP</a></code> 
<code><a href="#topic+RRBLUP_GCA">RRBLUP_GCA</a></code> and <code><a href="#topic+RRBLUP_SCA">RRBLUP_SCA</a></code> respectively.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an estimate for the required gigabytes of RAM
</p>


<h3>Examples</h3>

<pre><code class='language-R'>RRBLUPMemUse(nInd=1000, nMarker=5000)

</code></pre>

<hr>
<h2 id='RRsol-class'>RR-BLUP Solution</h2><span id='topic+RRsol-class'></span>

<h3>Description</h3>

<p>Contains output from AlphaSimR's genomic 
selection functions.
</p>


<h3>Slots</h3>


<dl>
<dt><code>gv</code></dt><dd><p>Trait(s) for estimating genetic values</p>
</dd>
<dt><code>bv</code></dt><dd><p>Trait(s) for estimating breeding values</p>
</dd>
<dt><code>female</code></dt><dd><p>Trait(s) for estimating GCA in the female pool</p>
</dd>
<dt><code>male</code></dt><dd><p>Trait(s) for estimating GCA in the male pool</p>
</dd>
<dt><code>Vu</code></dt><dd><p>Estimated marker variance(s)</p>
</dd>
<dt><code>Ve</code></dt><dd><p>Estimated error variance</p>
</dd>
</dl>

<hr>
<h2 id='runMacs'>Create founder haplotypes using MaCS</h2><span id='topic+runMacs'></span>

<h3>Description</h3>

<p>Uses the MaCS software to produce founder haplotypes 
(Chen et al. 2009).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>runMacs(
  nInd,
  nChr = 1,
  segSites = NULL,
  inbred = FALSE,
  species = "GENERIC",
  split = NULL,
  ploidy = 2L,
  manualCommand = NULL,
  manualGenLen = NULL,
  nThreads = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="runMacs_+3A_nind">nInd</code></td>
<td>
<p>number of individuals to simulate</p>
</td></tr>
<tr><td><code id="runMacs_+3A_nchr">nChr</code></td>
<td>
<p>number of chromosomes to simulate</p>
</td></tr>
<tr><td><code id="runMacs_+3A_segsites">segSites</code></td>
<td>
<p>number of segregating sites to keep per chromosome. A 
value of NULL results in all sites being retained.</p>
</td></tr>
<tr><td><code id="runMacs_+3A_inbred">inbred</code></td>
<td>
<p>should founder individuals be inbred</p>
</td></tr>
<tr><td><code id="runMacs_+3A_species">species</code></td>
<td>
<p>species history to simulate. See details.</p>
</td></tr>
<tr><td><code id="runMacs_+3A_split">split</code></td>
<td>
<p>an optional historic population split in terms of generations ago.</p>
</td></tr>
<tr><td><code id="runMacs_+3A_ploidy">ploidy</code></td>
<td>
<p>ploidy level of organism</p>
</td></tr>
<tr><td><code id="runMacs_+3A_manualcommand">manualCommand</code></td>
<td>
<p>user provided MaCS options. For advanced users only.</p>
</td></tr>
<tr><td><code id="runMacs_+3A_manualgenlen">manualGenLen</code></td>
<td>
<p>user provided genetic length. This must be supplied if using 
manualCommand. If not using manualCommand, this value will replace the predefined 
genetic length for the species. However, this the genetic length is only used by 
AlphaSimR and is not passed to MaCS, so MaCS still uses the predefined genetic length. 
For advanced users only.</p>
</td></tr>
<tr><td><code id="runMacs_+3A_nthreads">nThreads</code></td>
<td>
<p>if OpenMP is available, this will allow for simulating chromosomes in parallel. 
If the value is NULL, the number of threads is automatically detected.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>There are currently three species histories available: GENERIC, CATTLE, WHEAT, and MAIZE.
</p>
<p>The GENERIC history is meant to be a reasonable all-purpose choice. It runs quickly and 
models a population with an effective populations size that has gone through several historic 
bottlenecks. This species history is used as the default arguments in the <code><a href="#topic+runMacs2">runMacs2</a></code> 
function, so the user should examine this function for the details of how the species is modeled.
</p>
<p>The CATTLE history is based off of real genome sequence data (MacLeod et al. 2013).
</p>
<p>The WHEAT (Gaynor et al. 2017) and MAIZE (Hickey et al. 2014) 
histories have been included due to their use in previous simulations. However, it should 
be noted that neither faithfully simulates its respective species. This is apparent by 
the low number of segregating sites simulated by each history relative to their real-world 
analogs. Adjusting these histories to better represent their real-world analogs would result 
in a drastic increase to runtime.
</p>


<h3>Value</h3>

<p>an object of <code><a href="#topic+MapPop-class">MapPop-class</a></code>
</p>


<h3>References</h3>

<p>Chen GK, Marjoram P, Wall JD (2009).
&ldquo;Fast and Flexible Simulation of DNA Sequence Data.&rdquo;
<em>Genome Research</em>, <b>19</b>, 136-142.
<a href="https://genome.cshlp.org/content/19/1/136">https://genome.cshlp.org/content/19/1/136</a>.<br /><br /> Gaynor RC, Gorjanc G, Bentley AR, Ober ES, Howell P, Jackson R, Mackay IJ, Hickey JM (2017).
&ldquo;A Two-Part Strategy for Using Genomic Selection to Develop Inbred Lines.&rdquo;
<em>Crop Science</em>, <b>57</b>(5), 2372&ndash;2386.
ISSN 0011-183X, <a href="https://doi.org/10.2135/cropsci2016.09.0742">doi:10.2135/cropsci2016.09.0742</a>, <a href="https://acsess.onlinelibrary.wiley.com/doi/full/10.2135/cropsci2016.09.0742">https://acsess.onlinelibrary.wiley.com/doi/full/10.2135/cropsci2016.09.0742</a>.<br /><br /> Hickey JM, Dreisigacker S, Crossa J, Hearne S, Babu R, Prasanna BM, Grondona M, Zambelli A, Windhausen VS, Mathews K, Gorjanc G (2014).
&ldquo;Evaluation of Genomic Selection Training Population Designs and Genotyping Strategies in Plant Breeding Programs Using Simulation.&rdquo;
<em>Crop Science</em>, <b>54</b>(4), 1476-1488.
<a href="https://doi.org/10.2135/cropsci2013.03.0195">doi:10.2135/cropsci2013.03.0195</a>.<br /><br /> MacLeod IM, Larkin DM, Lewin HA, Hayes BJ, Goddard ME (2013).
&ldquo;Inferring Demography from Runs of Homozygosity in Whole-Genome Sequence, with Correction for Sequence Errors.&rdquo;
<em>Molecular Biology and Evolution</em>, <b>30</b>(9), 22092223.
<a href="https://doi.org/10.1093/molbev/mst125">doi:10.1093/molbev/mst125</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Creates a populations of 10 outbred individuals
# Their genome consists of 1 chromosome and 100 segregating sites
## Not run: 
founderPop = runMacs(nInd=10,nChr=1,segSites=100)

## End(Not run)
</code></pre>

<hr>
<h2 id='runMacs2'>Alternative wrapper for MaCS</h2><span id='topic+runMacs2'></span>

<h3>Description</h3>

<p>A wrapper function for <code><a href="#topic+runMacs">runMacs</a></code>. This wrapper is designed 
to provide a more intuitive interface for writing custom commands
in MaCS (Chen et al. 2009). It effectively automates the creation 
of an appropriate line for the manualCommand argument in <code><a href="#topic+runMacs">runMacs</a></code> 
using user supplied variables, but only allows for a subset of the functionality 
offered by this argument. The default arguments of this function were chosen to match 
species=&quot;GENERIC&quot; in <code><a href="#topic+runMacs">runMacs</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>runMacs2(
  nInd,
  nChr = 1,
  segSites = NULL,
  Ne = 100,
  bp = 1e+08,
  genLen = 1,
  mutRate = 2.5e-08,
  histNe = c(500, 1500, 6000, 12000, 1e+05),
  histGen = c(100, 1000, 10000, 1e+05, 1e+06),
  inbred = FALSE,
  split = NULL,
  ploidy = 2L,
  returnCommand = FALSE,
  nThreads = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="runMacs2_+3A_nind">nInd</code></td>
<td>
<p>number of individuals to simulate</p>
</td></tr>
<tr><td><code id="runMacs2_+3A_nchr">nChr</code></td>
<td>
<p>number of chromosomes to simulate</p>
</td></tr>
<tr><td><code id="runMacs2_+3A_segsites">segSites</code></td>
<td>
<p>number of segregating sites to keep per chromosome</p>
</td></tr>
<tr><td><code id="runMacs2_+3A_ne">Ne</code></td>
<td>
<p>effective population size</p>
</td></tr>
<tr><td><code id="runMacs2_+3A_bp">bp</code></td>
<td>
<p>base pair length of chromosome</p>
</td></tr>
<tr><td><code id="runMacs2_+3A_genlen">genLen</code></td>
<td>
<p>genetic length of chromosome in Morgans</p>
</td></tr>
<tr><td><code id="runMacs2_+3A_mutrate">mutRate</code></td>
<td>
<p>per base pair mutation rate</p>
</td></tr>
<tr><td><code id="runMacs2_+3A_histne">histNe</code></td>
<td>
<p>effective population size in previous 
generations</p>
</td></tr>
<tr><td><code id="runMacs2_+3A_histgen">histGen</code></td>
<td>
<p>number of generations ago for effective 
population sizes given in histNe</p>
</td></tr>
<tr><td><code id="runMacs2_+3A_inbred">inbred</code></td>
<td>
<p>should founder individuals be inbred</p>
</td></tr>
<tr><td><code id="runMacs2_+3A_split">split</code></td>
<td>
<p>an optional historic population split in terms of generations ago</p>
</td></tr>
<tr><td><code id="runMacs2_+3A_ploidy">ploidy</code></td>
<td>
<p>ploidy level of organism</p>
</td></tr>
<tr><td><code id="runMacs2_+3A_returncommand">returnCommand</code></td>
<td>
<p>should the command passed to manualCommand in 
<code><a href="#topic+runMacs">runMacs</a></code> be returned. If TRUE, MaCS will not be called and 
the command is returned instead.</p>
</td></tr>
<tr><td><code id="runMacs2_+3A_nthreads">nThreads</code></td>
<td>
<p>if OpenMP is available, this will allow for simulating chromosomes in parallel. 
If the value is NULL, the number of threads is automatically detected.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of <code><a href="#topic+MapPop-class">MapPop-class</a></code> or if 
returnCommand is true a string giving the MaCS command passed to  
the manualCommand argument of <code><a href="#topic+runMacs">runMacs</a></code>.
</p>


<h3>References</h3>

<p>Chen GK, Marjoram P, Wall JD (2009).
&ldquo;Fast and Flexible Simulation of DNA Sequence Data.&rdquo;
<em>Genome Research</em>, <b>19</b>, 136-142.
<a href="https://genome.cshlp.org/content/19/1/136">https://genome.cshlp.org/content/19/1/136</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Creates a populations of 10 outbred individuals
# Their genome consists of 1 chromosome and 100 segregating sites
# The command is equivalent to using species="GENERIC" in runMacs
## Not run: 
founderPop = runMacs2(nInd=10,nChr=1,segSites=100)

## End(Not run)
</code></pre>

<hr>
<h2 id='sampleHaplo'>Sample haplotypes from a MapPop</h2><span id='topic+sampleHaplo'></span>

<h3>Description</h3>

<p>Creates a new <code><a href="#topic+MapPop-class">MapPop-class</a></code> from an existing 
<code><a href="#topic+MapPop-class">MapPop-class</a></code> by randomly sampling haplotypes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sampleHaplo(mapPop, nInd, inbred = FALSE, ploidy = NULL, replace = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sampleHaplo_+3A_mappop">mapPop</code></td>
<td>
<p>the <code><a href="#topic+MapPop-class">MapPop-class</a></code> used to 
sample haplotypes</p>
</td></tr>
<tr><td><code id="sampleHaplo_+3A_nind">nInd</code></td>
<td>
<p>the number of individuals to create</p>
</td></tr>
<tr><td><code id="sampleHaplo_+3A_inbred">inbred</code></td>
<td>
<p>should new individuals be fully inbred</p>
</td></tr>
<tr><td><code id="sampleHaplo_+3A_ploidy">ploidy</code></td>
<td>
<p>new ploidy level for organism. If NULL, 
the ploidy level of the mapPop is used.</p>
</td></tr>
<tr><td><code id="sampleHaplo_+3A_replace">replace</code></td>
<td>
<p>should haplotypes be sampled with replacement</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of <code><a href="#topic+MapPop-class">MapPop-class</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>founderPop = quickHaplo(nInd=2,nChr=1,segSites=11,inbred=TRUE)
founderPop = sampleHaplo(mapPop=founderPop,nInd=20)

</code></pre>

<hr>
<h2 id='selectCross'>Select and randomly cross</h2><span id='topic+selectCross'></span>

<h3>Description</h3>

<p>This is a wrapper that combines the functionalities of
<code><a href="#topic+randCross">randCross</a></code> and <code><a href="#topic+selectInd">selectInd</a></code>. The
purpose of this wrapper is to combine both selection and
crossing in one function call that minimized the amount
of intermediate populations created. This reduces RAM usage
and simplifies code writing. Note that this wrapper does not
provide the full functionality of either function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>selectCross(
  pop,
  nInd = NULL,
  nFemale = NULL,
  nMale = NULL,
  nCrosses,
  nProgeny = 1,
  trait = 1,
  use = "pheno",
  selectTop = TRUE,
  simParam = NULL,
  ...,
  balance = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="selectCross_+3A_pop">pop</code></td>
<td>
<p>an object of <code><a href="#topic+Pop-class">Pop-class</a></code></p>
</td></tr>
<tr><td><code id="selectCross_+3A_nind">nInd</code></td>
<td>
<p>the number of individuals to select. These individuals
are selected without regards to sex and it supercedes values
for nFemale and nMale. Thus if the simulation uses sexes, it is
likely better to leave this value as NULL and use nFemale and nMale
instead.</p>
</td></tr>
<tr><td><code id="selectCross_+3A_nfemale">nFemale</code></td>
<td>
<p>the number of females to select. This value is ignored
if nInd is set.</p>
</td></tr>
<tr><td><code id="selectCross_+3A_nmale">nMale</code></td>
<td>
<p>the number of males to select. This value is ignored
if nInd is set.</p>
</td></tr>
<tr><td><code id="selectCross_+3A_ncrosses">nCrosses</code></td>
<td>
<p>total number of crosses to make</p>
</td></tr>
<tr><td><code id="selectCross_+3A_nprogeny">nProgeny</code></td>
<td>
<p>number of progeny per cross</p>
</td></tr>
<tr><td><code id="selectCross_+3A_trait">trait</code></td>
<td>
<p>the trait for selection. Either a number indicating
a single trait or a function returning a vector of length nInd.</p>
</td></tr>
<tr><td><code id="selectCross_+3A_use">use</code></td>
<td>
<p>select on genetic values &quot;gv&quot;, estimated
breeding values &quot;ebv&quot;, breeding values &quot;bv&quot;, phenotypes &quot;pheno&quot;,
or randomly &quot;rand&quot;</p>
</td></tr>
<tr><td><code id="selectCross_+3A_selecttop">selectTop</code></td>
<td>
<p>selects highest values if true.
Selects lowest values if false.</p>
</td></tr>
<tr><td><code id="selectCross_+3A_simparam">simParam</code></td>
<td>
<p>an object of <code><a href="#topic+SimParam">SimParam</a></code></p>
</td></tr>
<tr><td><code id="selectCross_+3A_...">...</code></td>
<td>
<p>additional arguments if using a function for
trait</p>
</td></tr>
<tr><td><code id="selectCross_+3A_balance">balance</code></td>
<td>
<p>if using sexes, this option will balance the number
of progeny per parent. This argument occurs after ..., so the argument
name must be matched exactly.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an object of <code><a href="#topic+Pop-class">Pop-class</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Create founder haplotypes
founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)

#Set simulation parameters
SP = SimParam$new(founderPop)

SP$addTraitA(10)
SP$setVarE(h2=0.5)

#Create population
pop = newPop(founderPop, simParam=SP)

#Select 4 individuals and make 8 crosses
pop2 = selectCross(pop, nInd=4, nCrosses=8, simParam=SP)

</code></pre>

<hr>
<h2 id='selectFam'>Select families</h2><span id='topic+selectFam'></span>

<h3>Description</h3>

<p>Selects a subset of full-sib families from a
population.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>selectFam(
  pop,
  nFam,
  trait = 1,
  use = "pheno",
  sex = "B",
  famType = "B",
  selectTop = TRUE,
  returnPop = TRUE,
  candidates = NULL,
  simParam = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="selectFam_+3A_pop">pop</code></td>
<td>
<p>and object of <code><a href="#topic+Pop-class">Pop-class</a></code>,
<code><a href="#topic+HybridPop-class">HybridPop-class</a></code> or <code><a href="#topic+MultiPop-class">MultiPop-class</a></code></p>
</td></tr>
<tr><td><code id="selectFam_+3A_nfam">nFam</code></td>
<td>
<p>the number of families to select</p>
</td></tr>
<tr><td><code id="selectFam_+3A_trait">trait</code></td>
<td>
<p>the trait for selection. Either a number indicating
a single trait or a function returning a vector of length nInd.
The function must work on a vector or matrix of <code>use</code> values.
See the examples in <code><a href="#topic+selectInd">selectInd</a></code> and <code><a href="#topic+selIndex">selIndex</a></code>.</p>
</td></tr>
<tr><td><code id="selectFam_+3A_use">use</code></td>
<td>
<p>select on genetic values &quot;gv&quot;, estimated
breeding values &quot;ebv&quot;, breeding values &quot;bv&quot;, phenotypes &quot;pheno&quot;,
or randomly &quot;rand&quot;</p>
</td></tr>
<tr><td><code id="selectFam_+3A_sex">sex</code></td>
<td>
<p>which sex to select. Use &quot;B&quot; for both, &quot;F&quot; for
females and &quot;M&quot; for males. If the simulation is not using sexes,
the argument is ignored.</p>
</td></tr>
<tr><td><code id="selectFam_+3A_famtype">famType</code></td>
<td>
<p>which type of family to select. Use &quot;B&quot; for
full-sib families, &quot;F&quot; for half-sib families on female side and &quot;M&quot;
for half-sib families on the male side.</p>
</td></tr>
<tr><td><code id="selectFam_+3A_selecttop">selectTop</code></td>
<td>
<p>selects highest values if true.
Selects lowest values if false.</p>
</td></tr>
<tr><td><code id="selectFam_+3A_returnpop">returnPop</code></td>
<td>
<p>should results be returned as a
<code><a href="#topic+Pop-class">Pop-class</a></code>. If FALSE, only the index of selected
individuals is returned.</p>
</td></tr>
<tr><td><code id="selectFam_+3A_candidates">candidates</code></td>
<td>
<p>an optional vector of eligible selection candidates.</p>
</td></tr>
<tr><td><code id="selectFam_+3A_simparam">simParam</code></td>
<td>
<p>an object of <code><a href="#topic+SimParam">SimParam</a></code></p>
</td></tr>
<tr><td><code id="selectFam_+3A_...">...</code></td>
<td>
<p>additional arguments if using a function for
trait</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an object of <code><a href="#topic+Pop-class">Pop-class</a></code>,
<code><a href="#topic+HybridPop-class">HybridPop-class</a></code> or <code><a href="#topic+MultiPop-class">MultiPop-class</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Create founder haplotypes
founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)

#Set simulation parameters
SP = SimParam$new(founderPop)

SP$addTraitA(10)
SP$setVarE(h2=0.5)

#Create population
pop = newPop(founderPop, simParam=SP)

#Create 3 biparental families with 10 progeny
pop2 = randCross(pop, nCrosses=3, nProgeny=10, simParam=SP)

#Select best 2 families
pop3 = selectFam(pop2, 2, simParam=SP)

</code></pre>

<hr>
<h2 id='selectInd'>Select individuals</h2><span id='topic+selectInd'></span>

<h3>Description</h3>

<p>Selects a subset of nInd individuals from a
population.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>selectInd(
  pop,
  nInd,
  trait = 1,
  use = "pheno",
  sex = "B",
  selectTop = TRUE,
  returnPop = TRUE,
  candidates = NULL,
  simParam = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="selectInd_+3A_pop">pop</code></td>
<td>
<p>and object of <code><a href="#topic+Pop-class">Pop-class</a></code>,
<code><a href="#topic+HybridPop-class">HybridPop-class</a></code> or <code><a href="#topic+MultiPop-class">MultiPop-class</a></code></p>
</td></tr>
<tr><td><code id="selectInd_+3A_nind">nInd</code></td>
<td>
<p>the number of individuals to select</p>
</td></tr>
<tr><td><code id="selectInd_+3A_trait">trait</code></td>
<td>
<p>the trait for selection. Either a number indicating
a single trait or a function returning a vector of length nInd.
The function must work on a vector or matrix of <code>use</code> values.
See the examples and <code><a href="#topic+selIndex">selIndex</a></code>.</p>
</td></tr>
<tr><td><code id="selectInd_+3A_use">use</code></td>
<td>
<p>select on genetic values &quot;gv&quot;, estimated
breeding values &quot;ebv&quot;, breeding values &quot;bv&quot;, phenotypes &quot;pheno&quot;,
or randomly &quot;rand&quot;</p>
</td></tr>
<tr><td><code id="selectInd_+3A_sex">sex</code></td>
<td>
<p>which sex to select. Use &quot;B&quot; for both, &quot;F&quot; for
females and &quot;M&quot; for males. If the simulation is not using sexes,
the argument is ignored.</p>
</td></tr>
<tr><td><code id="selectInd_+3A_selecttop">selectTop</code></td>
<td>
<p>selects highest values if true.
Selects lowest values if false.</p>
</td></tr>
<tr><td><code id="selectInd_+3A_returnpop">returnPop</code></td>
<td>
<p>should results be returned as a
<code><a href="#topic+Pop-class">Pop-class</a></code>. If FALSE, only the index of selected
individuals is returned.</p>
</td></tr>
<tr><td><code id="selectInd_+3A_candidates">candidates</code></td>
<td>
<p>an optional vector of eligible selection candidates.</p>
</td></tr>
<tr><td><code id="selectInd_+3A_simparam">simParam</code></td>
<td>
<p>an object of <code><a href="#topic+SimParam">SimParam</a></code></p>
</td></tr>
<tr><td><code id="selectInd_+3A_...">...</code></td>
<td>
<p>additional arguments if using a function for
trait</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an object of <code><a href="#topic+Pop-class">Pop-class</a></code>,
<code><a href="#topic+HybridPop-class">HybridPop-class</a></code> or <code><a href="#topic+MultiPop-class">MultiPop-class</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Create founder haplotypes
founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)

#Set simulation parameters
SP = SimParam$new(founderPop)

SP$addTraitA(10)
SP$setVarE(h2=0.5)

#Create population
pop = newPop(founderPop, simParam=SP)

#Select top 5 (directional selection)
pop2 = selectInd(pop, 5, simParam=SP)
hist(pop@pheno); abline(v = pop@pheno, lwd = 2)
abline(v = pop2@pheno, col = "red", lwd = 2)

#Select 5 most deviating from an optima (disruptive selection)
squaredDeviation = function(x, optima = 0) (x - optima)^2
pop3 = selectInd(pop, 5, simParam=SP, trait = squaredDeviation, selectTop = TRUE)
hist(pop@pheno); abline(v = pop@pheno, lwd = 2)
abline(v = pop3@pheno, col = "red", lwd = 2)

#Select 5 least deviating from an optima (stabilising selection)
pop4 = selectInd(pop, 5, simParam=SP, trait = squaredDeviation, selectTop = FALSE)
hist(pop@pheno); abline(v = pop@pheno, lwd = 2)
abline(v = pop4@pheno, col = "red", lwd = 2)

</code></pre>

<hr>
<h2 id='selectOP'>Select open pollinating plants</h2><span id='topic+selectOP'></span>

<h3>Description</h3>

<p>This function models selection in an open pollinating
plant population. It allows for varying the percentage of
selfing. The function also provides an option for modeling
selection as occuring before or after pollination.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>selectOP(
  pop,
  nInd,
  nSeeds,
  probSelf = 0,
  pollenControl = FALSE,
  trait = 1,
  use = "pheno",
  selectTop = TRUE,
  candidates = NULL,
  simParam = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="selectOP_+3A_pop">pop</code></td>
<td>
<p>and object of <code><a href="#topic+Pop-class">Pop-class</a></code>
or <code><a href="#topic+MultiPop-class">MultiPop-class</a></code></p>
</td></tr>
<tr><td><code id="selectOP_+3A_nind">nInd</code></td>
<td>
<p>the number of plants to select</p>
</td></tr>
<tr><td><code id="selectOP_+3A_nseeds">nSeeds</code></td>
<td>
<p>number of seeds per plant</p>
</td></tr>
<tr><td><code id="selectOP_+3A_probself">probSelf</code></td>
<td>
<p>percentage of seeds expected from selfing.
Value ranges from 0 to 1.</p>
</td></tr>
<tr><td><code id="selectOP_+3A_pollencontrol">pollenControl</code></td>
<td>
<p>are plants selected before pollination</p>
</td></tr>
<tr><td><code id="selectOP_+3A_trait">trait</code></td>
<td>
<p>the trait for selection. Either a number indicating
a single trait or a function returning a vector of length nInd.
The function must work on a vector or matrix of <code>use</code> values.
See the examples in <code><a href="#topic+selectInd">selectInd</a></code> and <code><a href="#topic+selIndex">selIndex</a></code>.</p>
</td></tr>
<tr><td><code id="selectOP_+3A_use">use</code></td>
<td>
<p>select on genetic values &quot;gv&quot;, estimated
breeding values &quot;ebv&quot;, breeding values &quot;bv&quot;, phenotypes &quot;pheno&quot;,
or randomly &quot;rand&quot;</p>
</td></tr>
<tr><td><code id="selectOP_+3A_selecttop">selectTop</code></td>
<td>
<p>selects highest values if true.
Selects lowest values if false.</p>
</td></tr>
<tr><td><code id="selectOP_+3A_candidates">candidates</code></td>
<td>
<p>an optional vector of eligible selection candidates.</p>
</td></tr>
<tr><td><code id="selectOP_+3A_simparam">simParam</code></td>
<td>
<p>an object of <code><a href="#topic+SimParam">SimParam</a></code></p>
</td></tr>
<tr><td><code id="selectOP_+3A_...">...</code></td>
<td>
<p>additional arguments if using a function for
trait</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an object of <code><a href="#topic+Pop-class">Pop-class</a></code>
or <code><a href="#topic+MultiPop-class">MultiPop-class</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Create founder haplotypes
founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)

#Set simulation parameters
SP = SimParam$new(founderPop)

SP$addTraitA(10)
SP$setVarE(h2=0.5)

#Create population
pop = newPop(founderPop, simParam=SP)

#Create new population by selecting the best 3 plant
#Assuming 50% selfing in plants and 10 seeds per plant
pop2 = selectOP(pop, nInd=3, nSeeds=10, probSelf=0.5, simParam=SP)

</code></pre>

<hr>
<h2 id='selectWithinFam'>Select individuals within families</h2><span id='topic+selectWithinFam'></span>

<h3>Description</h3>

<p>Selects a subset of nInd individuals from each
full-sib family within a population. Will return all individuals
from a full-sib family if it has less than or equal to nInd individuals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>selectWithinFam(
  pop,
  nInd,
  trait = 1,
  use = "pheno",
  sex = "B",
  famType = "B",
  selectTop = TRUE,
  returnPop = TRUE,
  candidates = NULL,
  simParam = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="selectWithinFam_+3A_pop">pop</code></td>
<td>
<p>and object of <code><a href="#topic+Pop-class">Pop-class</a></code>,
<code><a href="#topic+HybridPop-class">HybridPop-class</a></code> or <code><a href="#topic+MultiPop-class">MultiPop-class</a></code></p>
</td></tr>
<tr><td><code id="selectWithinFam_+3A_nind">nInd</code></td>
<td>
<p>the number of individuals to select within a family</p>
</td></tr>
<tr><td><code id="selectWithinFam_+3A_trait">trait</code></td>
<td>
<p>the trait for selection. Either a number indicating
a single trait or a function returning a vector of length nInd.
The function must work on a vector or matrix of <code>use</code> values.
See the examples in <code><a href="#topic+selectInd">selectInd</a></code> and <code><a href="#topic+selIndex">selIndex</a></code>.</p>
</td></tr>
<tr><td><code id="selectWithinFam_+3A_use">use</code></td>
<td>
<p>select on genetic values &quot;gv&quot;, estimated
breeding values &quot;ebv&quot;, breeding values &quot;bv&quot;, phenotypes &quot;pheno&quot;,
or randomly &quot;rand&quot;</p>
</td></tr>
<tr><td><code id="selectWithinFam_+3A_sex">sex</code></td>
<td>
<p>which sex to select. Use &quot;B&quot; for both, &quot;F&quot; for
females and &quot;M&quot; for males. If the simulation is not using sexes,
the argument is ignored.</p>
</td></tr>
<tr><td><code id="selectWithinFam_+3A_famtype">famType</code></td>
<td>
<p>which type of family to select. Use &quot;B&quot; for
full-sib families, &quot;F&quot; for half-sib families on female side and &quot;M&quot;
for half-sib families on the male side.</p>
</td></tr>
<tr><td><code id="selectWithinFam_+3A_selecttop">selectTop</code></td>
<td>
<p>selects highest values if true.
Selects lowest values if false.</p>
</td></tr>
<tr><td><code id="selectWithinFam_+3A_returnpop">returnPop</code></td>
<td>
<p>should results be returned as a
<code><a href="#topic+Pop-class">Pop-class</a></code>. If FALSE, only the index of selected
individuals is returned.</p>
</td></tr>
<tr><td><code id="selectWithinFam_+3A_candidates">candidates</code></td>
<td>
<p>an optional vector of eligible selection candidates.</p>
</td></tr>
<tr><td><code id="selectWithinFam_+3A_simparam">simParam</code></td>
<td>
<p>an object of <code><a href="#topic+SimParam">SimParam</a></code></p>
</td></tr>
<tr><td><code id="selectWithinFam_+3A_...">...</code></td>
<td>
<p>additional arguments if using a function for
trait</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an object of <code><a href="#topic+Pop-class">Pop-class</a></code>,
<code><a href="#topic+HybridPop-class">HybridPop-class</a></code> or <code><a href="#topic+MultiPop-class">MultiPop-class</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Create founder haplotypes
founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)

#Set simulation parameters
SP = SimParam$new(founderPop)

SP$addTraitA(10)
SP$setVarE(h2=0.5)

#Create population
pop = newPop(founderPop, simParam=SP)

#Create 3 biparental families with 10 progeny
pop2 = randCross(pop, nCrosses=3, nProgeny=10, simParam=SP)

#Select best individual per family
pop3 = selectWithinFam(pop2, 1, simParam=SP)

</code></pre>

<hr>
<h2 id='self'>Self individuals</h2><span id='topic+self'></span>

<h3>Description</h3>

<p>Creates selfed progeny from each individual in a
population. Only works when sexes is &quot;no&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>self(pop, nProgeny = 1, parents = NULL, keepParents = TRUE, simParam = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="self_+3A_pop">pop</code></td>
<td>
<p>an object of <code><a href="#topic+Pop-class">Pop-class</a></code></p>
</td></tr>
<tr><td><code id="self_+3A_nprogeny">nProgeny</code></td>
<td>
<p>total number of selfed progeny per individual</p>
</td></tr>
<tr><td><code id="self_+3A_parents">parents</code></td>
<td>
<p>an optional vector of indices for allowable parents</p>
</td></tr>
<tr><td><code id="self_+3A_keepparents">keepParents</code></td>
<td>
<p>should previous parents be used for mother and
father.</p>
</td></tr>
<tr><td><code id="self_+3A_simparam">simParam</code></td>
<td>
<p>an object of <code><a href="#topic+SimParam">SimParam</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an object of <code><a href="#topic+Pop-class">Pop-class</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Create founder haplotypes
founderPop = quickHaplo(nInd=2, nChr=1, segSites=10)

#Set simulation parameters
SP = SimParam$new(founderPop)


#Create population
pop = newPop(founderPop, simParam=SP)

#Self pollinate each individual
pop2 = self(pop, simParam=SP)

</code></pre>

<hr>
<h2 id='selIndex'>Selection index</h2><span id='topic+selIndex'></span>

<h3>Description</h3>

<p>Calculates values of a selection index given trait values and 
weights. This function is intended to be used in combination with 
selection functions working on populations such as 
<code><a href="#topic+selectInd">selectInd</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>selIndex(Y, b, scale = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="selIndex_+3A_y">Y</code></td>
<td>
<p>a matrix of trait values</p>
</td></tr>
<tr><td><code id="selIndex_+3A_b">b</code></td>
<td>
<p>a vector of weights</p>
</td></tr>
<tr><td><code id="selIndex_+3A_scale">scale</code></td>
<td>
<p>should Y be scaled and centered</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>#Create founder haplotypes
founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)

#Set simulation parameters
SP = SimParam$new(founderPop)

#Model two genetically correlated traits
G = 1.5*diag(2)-0.5 #Genetic correlation matrix
SP$addTraitA(10, mean=c(0,0), var=c(1,1), corA=G)
SP$setVarE(h2=c(0.5,0.5))

#Create population
pop = newPop(founderPop, simParam=SP)

#Calculate Smith-Hazel weights
econWt = c(1, 1)
b = smithHazel(econWt, varG(pop), varP(pop))

#Selection 2 best individuals using Smith-Hazel index
#selIndex is used as a trait
pop2 = selectInd(pop, nInd=2, trait=selIndex, 
                 simParam=SP, b=b)

</code></pre>

<hr>
<h2 id='selInt'>Selection intensity</h2><span id='topic+selInt'></span>

<h3>Description</h3>

<p>Calculates the standardized selection intensity
</p>


<h3>Usage</h3>

<pre><code class='language-R'>selInt(p)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="selInt_+3A_p">p</code></td>
<td>
<p>the proportion of individuals selected</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>selInt(0.1)

</code></pre>

<hr>
<h2 id='setEBV'>Set EBV</h2><span id='topic+setEBV'></span>

<h3>Description</h3>

<p>Adds genomic estimated values to a populations's EBV 
slot using output from a genomic selection functions. 
The genomic estimated values can be either estimated 
breeding values, estimated genetic values, or 
estimated general combining values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setEBV(
  pop,
  solution,
  value = "gv",
  targetPop = NULL,
  append = FALSE,
  simParam = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setEBV_+3A_pop">pop</code></td>
<td>
<p>an object of <code><a href="#topic+Pop-class">Pop-class</a></code></p>
</td></tr>
<tr><td><code id="setEBV_+3A_solution">solution</code></td>
<td>
<p>an object of <code><a href="#topic+RRsol-class">RRsol-class</a></code></p>
</td></tr>
<tr><td><code id="setEBV_+3A_value">value</code></td>
<td>
<p>the genomic value to be estimated. Can be 
either &quot;gv&quot;, &quot;bv&quot;, &quot;female&quot;, or &quot;male&quot;.</p>
</td></tr>
<tr><td><code id="setEBV_+3A_targetpop">targetPop</code></td>
<td>
<p>an optional target population that can 
be used when value is &quot;bv&quot;, &quot;female&quot;, or &quot;male&quot;. When 
supplied, the allele frequency in the targetPop is used 
to set these values.</p>
</td></tr>
<tr><td><code id="setEBV_+3A_append">append</code></td>
<td>
<p>should estimated values be appended to 
existing data in the EBV slot. If TRUE, a new column is 
added. If FALSE, existing data is replaced with the 
new estimates.</p>
</td></tr>
<tr><td><code id="setEBV_+3A_simparam">simParam</code></td>
<td>
<p>an object of <code><a href="#topic+SimParam">SimParam</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an object of <code><a href="#topic+Pop-class">Pop-class</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Create founder haplotypes
founderPop = quickHaplo(nInd=10, nChr=1, segSites=20)

#Set simulation parameters
SP = SimParam$new(founderPop)

SP$addTraitA(10)
SP$setVarE(h2=0.5)
SP$addSnpChip(10)

#Create population
pop = newPop(founderPop, simParam=SP)

#Run GS model and set EBV
ans = RRBLUP(pop, simParam=SP)
pop = setEBV(pop, ans, simParam=SP)

#Evaluate accuracy
cor(gv(pop), ebv(pop))

</code></pre>

<hr>
<h2 id='setMarkerHaplo'>Set marker haplotypes</h2><span id='topic+setMarkerHaplo'></span>

<h3>Description</h3>

<p>Manually sets the haplotypes in a population 
for all individuals at one or more loci.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setMarkerHaplo(pop, haplo, simParam = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setMarkerHaplo_+3A_pop">pop</code></td>
<td>
<p>an object of <code><a href="#topic+RawPop-class">RawPop-class</a></code> or
<code><a href="#topic+MapPop-class">MapPop-class</a></code></p>
</td></tr>
<tr><td><code id="setMarkerHaplo_+3A_haplo">haplo</code></td>
<td>
<p>a matrix of haplotypes, see details</p>
</td></tr>
<tr><td><code id="setMarkerHaplo_+3A_simparam">simParam</code></td>
<td>
<p>an object of <code><a href="#topic+SimParam">SimParam</a></code>, not 
used if pop is <code><a href="#topic+MapPop-class">MapPop-class</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The format of the haplotype matrix should match 
the format of the output from <code><a href="#topic+pullMarkerHaplo">pullMarkerHaplo</a></code>
with the option haplo=&quot;all&quot;. Thus, it is recommended that this 
function is first used to extract the haplotypes and that any 
desired changes be made to the output of pullMarkerHaplo before 
passing the matrix to setMarkerHaplo. Any changes made to QTL 
may potentially result in changes to an individuals genetic 
value. These changes will be reflected in the gv and/or gxe slot. 
All other slots will remain unchanged, so the ebv and pheno slots 
will not reflect the new genotypes.
</p>


<h3>Value</h3>

<p>an object of the same class as the &quot;pop&quot; input
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create founder haplotypes
founderPop = quickHaplo(nInd=10, nChr=1, segSites=15)

# Extract haplotypes for marker "1_1"
H = pullMarkerHaplo(founderPop, markers="1_1")

# Set the first haplotype to 1
H[1,1] = 1L

# Set marker haplotypes
founderPop = setMarkerHaplo(founderPop, haplo=H)

</code></pre>

<hr>
<h2 id='setMisc'>Set miscelaneous information in a population</h2><span id='topic+setMisc'></span>

<h3>Description</h3>

<p>Set miscelaneous information in a population
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setMisc(x, node = NULL, value = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setMisc_+3A_x">x</code></td>
<td>
<p><code><a href="#topic+Pop-class">Pop-class</a></code></p>
</td></tr>
<tr><td><code id="setMisc_+3A_node">node</code></td>
<td>
<p>character, name of the node to set within the <code>x@misc</code> slot</p>
</td></tr>
<tr><td><code id="setMisc_+3A_value">value</code></td>
<td>
<p>value to be saved into <code>x@misc[[*]][[node]]</code>; length of
<code>value</code> should be equal to <code>nInd(x)</code>; if its length is 1, then
it is repeated using <code>rep</code> (see examples)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A <code>NULL</code> in <code>value</code> is ignored
</p>


<h3>Value</h3>

<p><code><a href="#topic+Pop-class">Pop-class</a></code>
</p>

<hr>
<h2 id='setPheno'>Set phenotypes</h2><span id='topic+setPheno'></span>

<h3>Description</h3>

<p>Sets phenotypes for all traits by adding random error
from a multivariate normal distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setPheno(
  pop,
  h2 = NULL,
  H2 = NULL,
  varE = NULL,
  corE = NULL,
  reps = 1,
  fixEff = 1L,
  p = NULL,
  onlyPheno = FALSE,
  traits = NULL,
  simParam = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setPheno_+3A_pop">pop</code></td>
<td>
<p>an object of <code><a href="#topic+Pop-class">Pop-class</a></code> or
<code><a href="#topic+HybridPop-class">HybridPop-class</a></code></p>
</td></tr>
<tr><td><code id="setPheno_+3A_h2">h2</code></td>
<td>
<p>a vector of desired narrow-sense heritabilities for
each trait. See details.</p>
</td></tr>
<tr><td><code id="setPheno_+3A_h2">H2</code></td>
<td>
<p>a vector of desired broad-sense heritabilities for
each trait. See details.</p>
</td></tr>
<tr><td><code id="setPheno_+3A_vare">varE</code></td>
<td>
<p>error (co)variances for traits. See details.</p>
</td></tr>
<tr><td><code id="setPheno_+3A_core">corE</code></td>
<td>
<p>an optional matrix for correlations between errors.
See details.</p>
</td></tr>
<tr><td><code id="setPheno_+3A_reps">reps</code></td>
<td>
<p>number of replications for phenotype. See details.</p>
</td></tr>
<tr><td><code id="setPheno_+3A_fixeff">fixEff</code></td>
<td>
<p>fixed effect to assign to the population. Used
by genomic selection models only.</p>
</td></tr>
<tr><td><code id="setPheno_+3A_p">p</code></td>
<td>
<p>the p-value for the environmental covariate
used by GxE traits. If NULL, a value is
sampled at random.</p>
</td></tr>
<tr><td><code id="setPheno_+3A_onlypheno">onlyPheno</code></td>
<td>
<p>should only the phenotype be returned, see return</p>
</td></tr>
<tr><td><code id="setPheno_+3A_traits">traits</code></td>
<td>
<p>an integer vector indicate which traits to set. If NULL,
all traits will be set.</p>
</td></tr>
<tr><td><code id="setPheno_+3A_simparam">simParam</code></td>
<td>
<p>an object of <code><a href="#topic+SimParam">SimParam</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>There are three arguments for setting the error variance of a
phenotype: h2, H2, and varE. The user should only use one of these
arguments. If the user supplies values for more than one, only one
will be used according to order in which they are listed above.
</p>
<p>The h2 argument allows the user to specify the error variance
according to narrow-sense heritability. This calculation uses the
additive genetic variance and total genetic variance in the founder
population. Thus, the heritability relates to the founder population
and not the current population.
</p>
<p>The H2 argument allows the user to specify the error variance
according to broad-sense heritability. This calculation uses the
total genetic variance in the founder population. Thus, the heritability
relates to the founder population and not the current population.
</p>
<p>The varE argument allows the user to specify the error variance
directly. The user may supply a vector describing the error variance
for each trait or supply a matrix that specify the covariance of
the errors.
</p>
<p>The corE argument allows the user to specify correlations for the
error covariance matrix. These correlations are be supplied in addition
to the h2, H2, or varE arguments. These correlations will be used to
construct a covariance matrix from a vector of variances. If the user
supplied a covariance matrix to varE, these correlations will supercede
values provided in that matrix.
</p>
<p>The reps parameter is for convenient representation of replicated data.
It is intended to represent replicated yield trials in plant
breeding programs. In this case, varE is set to the plot error and
reps is set to the number of plots per entry. The resulting phenotype
represents the entry-means.
</p>


<h3>Value</h3>

<p>Returns an object of <code><a href="#topic+Pop-class">Pop-class</a></code> or
<code><a href="#topic+HybridPop-class">HybridPop-class</a></code> if onlyPheno=FALSE, if
onlyPheno=TRUE a matrix is returned
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Create founder haplotypes
founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)

#Set simulation parameters
SP = SimParam$new(founderPop)

SP$addTraitA(10)

#Create population
pop = newPop(founderPop, simParam=SP)

#Add phenotype with error variance of 1
pop = setPheno(pop, varE=1)

</code></pre>

<hr>
<h2 id='setPhenoGCA'>Set GCA as phenotype</h2><span id='topic+setPhenoGCA'></span>

<h3>Description</h3>

<p>Calculates general combining ability from a set of testers and
returns these values as phenotypes for a population.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setPhenoGCA(
  pop,
  testers,
  use = "pheno",
  h2 = NULL,
  H2 = NULL,
  varE = NULL,
  corE = NULL,
  reps = 1,
  fixEff = 1L,
  p = NULL,
  inbred = FALSE,
  onlyPheno = FALSE,
  simParam = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setPhenoGCA_+3A_pop">pop</code></td>
<td>
<p>an object of <code><a href="#topic+Pop-class">Pop-class</a></code></p>
</td></tr>
<tr><td><code id="setPhenoGCA_+3A_testers">testers</code></td>
<td>
<p>an object of <code><a href="#topic+Pop-class">Pop-class</a></code></p>
</td></tr>
<tr><td><code id="setPhenoGCA_+3A_use">use</code></td>
<td>
<p>true genetic value (<code>gv</code>) or phenotypes (<code>pheno</code>, default)</p>
</td></tr>
<tr><td><code id="setPhenoGCA_+3A_h2">h2</code></td>
<td>
<p>a vector of desired narrow-sense heritabilities for
each trait. See details in <code><a href="#topic+setPheno">setPheno</a></code>.</p>
</td></tr>
<tr><td><code id="setPhenoGCA_+3A_h2">H2</code></td>
<td>
<p>a vector of desired broad-sense heritabilities for
each trait. See details in <code><a href="#topic+setPheno">setPheno</a></code>.</p>
</td></tr>
<tr><td><code id="setPhenoGCA_+3A_vare">varE</code></td>
<td>
<p>error (co)variances for traits.
See details in <code><a href="#topic+setPheno">setPheno</a></code>.</p>
</td></tr>
<tr><td><code id="setPhenoGCA_+3A_core">corE</code></td>
<td>
<p>an optional matrix for correlations between errors.
See details in <code><a href="#topic+setPheno">setPheno</a></code>.</p>
</td></tr>
<tr><td><code id="setPhenoGCA_+3A_reps">reps</code></td>
<td>
<p>number of replications for phenotype.
See details in <code><a href="#topic+setPheno">setPheno</a></code>.</p>
</td></tr>
<tr><td><code id="setPhenoGCA_+3A_fixeff">fixEff</code></td>
<td>
<p>fixed effect to assign to the population. Used
by genomic selection models only.</p>
</td></tr>
<tr><td><code id="setPhenoGCA_+3A_p">p</code></td>
<td>
<p>the p-value for the environmental covariate
used by GxE traits. If NULL, a value is
sampled at random.</p>
</td></tr>
<tr><td><code id="setPhenoGCA_+3A_inbred">inbred</code></td>
<td>
<p>are both pop and testers fully inbred. They are only
fully inbred if created by <code><a href="#topic+newPop">newPop</a></code> using inbred founders
or by the <code><a href="#topic+makeDH">makeDH</a></code> function</p>
</td></tr>
<tr><td><code id="setPhenoGCA_+3A_onlypheno">onlyPheno</code></td>
<td>
<p>should only the phenotype be returned, see return</p>
</td></tr>
<tr><td><code id="setPhenoGCA_+3A_simparam">simParam</code></td>
<td>
<p>an object of <code><a href="#topic+SimParam">SimParam</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an object of <code><a href="#topic+Pop-class">Pop-class</a></code> or
a matrix if onlyPheno=TRUE
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Create founder haplotypes
founderPop = quickHaplo(nInd=10, nChr=1, segSites=10, inbred=TRUE)

#Set simulation parameters
SP = SimParam$new(founderPop)

SP$addTraitA(10)

#Create population
pop = newPop(founderPop, simParam=SP)

#Set phenotype to average per
pop2 = setPhenoGCA(pop, pop, use="gv", inbred=TRUE, simParam=SP)

</code></pre>

<hr>
<h2 id='setPhenoProgTest'>Set progeny test as phenotype</h2><span id='topic+setPhenoProgTest'></span>

<h3>Description</h3>

<p>Models a progeny test of individuals in 'pop'. Returns 'pop' with a phenotype
representing the average performance of their progeny. The phenotype is generated
by mating individuals in 'pop' to randomly chosen individuals in testPop a
number of times equal to 'nMatePerInd'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setPhenoProgTest(
  pop,
  testPop,
  nMatePerInd = 1L,
  use = "pheno",
  h2 = NULL,
  H2 = NULL,
  varE = NULL,
  corE = NULL,
  reps = 1,
  fixEff = 1L,
  p = NULL,
  onlyPheno = FALSE,
  simParam = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setPhenoProgTest_+3A_pop">pop</code></td>
<td>
<p>an object of <code><a href="#topic+Pop-class">Pop-class</a></code></p>
</td></tr>
<tr><td><code id="setPhenoProgTest_+3A_testpop">testPop</code></td>
<td>
<p>an object of <code><a href="#topic+Pop-class">Pop-class</a></code></p>
</td></tr>
<tr><td><code id="setPhenoProgTest_+3A_nmateperind">nMatePerInd</code></td>
<td>
<p>number of times an individual in 'pop' is mated to an
individual in testPop</p>
</td></tr>
<tr><td><code id="setPhenoProgTest_+3A_use">use</code></td>
<td>
<p>true genetic value (<code>gv</code>) or phenotypes (<code>pheno</code>, default)</p>
</td></tr>
<tr><td><code id="setPhenoProgTest_+3A_h2">h2</code></td>
<td>
<p>a vector of desired narrow-sense heritabilities for
each trait. See details in <code><a href="#topic+setPheno">setPheno</a></code>.</p>
</td></tr>
<tr><td><code id="setPhenoProgTest_+3A_h2">H2</code></td>
<td>
<p>a vector of desired broad-sense heritabilities for
each trait. See details in <code><a href="#topic+setPheno">setPheno</a></code>.</p>
</td></tr>
<tr><td><code id="setPhenoProgTest_+3A_vare">varE</code></td>
<td>
<p>error (co)variances for traits.
See details in <code><a href="#topic+setPheno">setPheno</a></code>.</p>
</td></tr>
<tr><td><code id="setPhenoProgTest_+3A_core">corE</code></td>
<td>
<p>an optional matrix for correlations between errors.
See details in <code><a href="#topic+setPheno">setPheno</a></code>.</p>
</td></tr>
<tr><td><code id="setPhenoProgTest_+3A_reps">reps</code></td>
<td>
<p>number of replications for phenotype.
See details in <code><a href="#topic+setPheno">setPheno</a></code>.</p>
</td></tr>
<tr><td><code id="setPhenoProgTest_+3A_fixeff">fixEff</code></td>
<td>
<p>fixed effect to assign to the population. Used
by genomic selection models only.</p>
</td></tr>
<tr><td><code id="setPhenoProgTest_+3A_p">p</code></td>
<td>
<p>the p-value for the environmental covariate
used by GxE traits. If NULL, a value is
sampled at random.</p>
</td></tr>
<tr><td><code id="setPhenoProgTest_+3A_onlypheno">onlyPheno</code></td>
<td>
<p>should only the phenotype be returned, see return</p>
</td></tr>
<tr><td><code id="setPhenoProgTest_+3A_simparam">simParam</code></td>
<td>
<p>an object of <code><a href="#topic+SimParam">SimParam</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The reps parameter is for convenient representation of replicated data.
It was intended for representation of replicated yield trials in plant
breeding programs. In this case, varE is set to the plot error and
reps is set to the number plots per entry. The resulting phenotype
would reflect the mean of all replications.
</p>


<h3>Value</h3>

<p>Returns an object of <code><a href="#topic+Pop-class">Pop-class</a></code> or
a matrix if onlyPheno=TRUE
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Create founder haplotypes
founderPop = quickHaplo(nInd=10, nChr=1, segSites=10, inbred=TRUE)

#Set simulation parameters
SP = SimParam$new(founderPop)

SP$addTraitA(10)

#Create two populations of 5 individuals
pop1 = newPop(founderPop[1:5], simParam=SP)
pop2 = newPop(founderPop[6:10], simParam=SP)

#Set phenotype according to a progeny test
pop3 = setPhenoProgTest(pop1, pop2, use="gv", simParam=SP)

</code></pre>

<hr>
<h2 id='SimParam'>Simulation parameters</h2><span id='topic+SimParam'></span>

<h3>Description</h3>

<p>Container for global simulation parameters. Saving this object
as SP will allow it to be accessed by function defaults.
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>nThreads</code></dt><dd><p>number of threads used on platforms with OpenMP support</p>
</dd>
<dt><code>snpChips</code></dt><dd><p>list of SNP chips</p>
</dd>
<dt><code>invalidQtl</code></dt><dd><p>list of segregating sites that aren't valid QTL</p>
</dd>
<dt><code>invalidSnp</code></dt><dd><p>list of segregating sites that aren't valid SNP</p>
</dd>
<dt><code>founderPop</code></dt><dd><p>founder population used for variance scaling</p>
</dd>
<dt><code>finalizePop</code></dt><dd><p>function applied to newly created populations.
Currently does nothing and should only be changed by expert users.</p>
</dd>
<dt><code>allowEmptyPop</code></dt><dd><p>if true, population arguments with nInd=0 will
return an empty population with a warning instead of an error.</p>
</dd>
<dt><code>v</code></dt><dd><p>the crossover interference parameter for a gamma model of
recombination. A value of 1 indicates no crossover interference
(e.g. Haldane mapping function). A value of 2.6 approximates the
degree of crossover interference implied by the Kosambi mapping
function. (default is 2.6)</p>
</dd>
<dt><code>p</code></dt><dd><p>the proportion of crossovers coming from a non-interfering
pathway. (default is 0)</p>
</dd>
<dt><code>quadProb</code></dt><dd><p>the probability of quadrivalent pairing in an
autopolyploid. (default is 0)</p>
</dd>
</dl>

</div>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>traitNames</code></dt><dd><p>vector of trait names</p>
</dd>
<dt><code>snpChipNames</code></dt><dd><p>vector of chip names</p>
</dd>
<dt><code>traits</code></dt><dd><p>list of traits</p>
</dd>
<dt><code>nChr</code></dt><dd><p>number of chromosomes</p>
</dd>
<dt><code>nTraits</code></dt><dd><p>number of traits</p>
</dd>
<dt><code>nSnpChips</code></dt><dd><p>number of SNP chips</p>
</dd>
<dt><code>segSites</code></dt><dd><p>segregating sites per chromosome</p>
</dd>
<dt><code>sexes</code></dt><dd><p>sexes used for mating</p>
</dd>
<dt><code>sepMap</code></dt><dd><p>are there seperate genetic maps for
males and females</p>
</dd>
<dt><code>genMap</code></dt><dd><p>&quot;matrix&quot; of chromosome genetic maps</p>
</dd>
<dt><code>femaleMap</code></dt><dd><p>&quot;matrix&quot; of chromosome genetic maps for
females</p>
</dd>
<dt><code>maleMap</code></dt><dd><p>&quot;matrix&quot; of chromosome genetic maps for
males</p>
</dd>
<dt><code>centromere</code></dt><dd><p>position of centromeres genetic map</p>
</dd>
<dt><code>femaleCentromere</code></dt><dd><p>position of centromeres on female
genetic map</p>
</dd>
<dt><code>maleCentromere</code></dt><dd><p>position of centromeres on male
genetic map</p>
</dd>
<dt><code>lastId</code></dt><dd><p>last ID number assigned</p>
</dd>
<dt><code>isTrackPed</code></dt><dd><p>is pedigree being tracked</p>
</dd>
<dt><code>pedigree</code></dt><dd><p>pedigree matrix for all individuals</p>
</dd>
<dt><code>isTrackRec</code></dt><dd><p>is recombination being tracked</p>
</dd>
<dt><code>recHist</code></dt><dd><p>list of historic recombination events</p>
</dd>
<dt><code>haplotypes</code></dt><dd><p>list of computed IBD haplotypes</p>
</dd>
<dt><code>varA</code></dt><dd><p>additive genetic variance in founderPop</p>
</dd>
<dt><code>varG</code></dt><dd><p>total genetic variance in founderPop</p>
</dd>
<dt><code>varE</code></dt><dd><p>default error variance</p>
</dd>
<dt><code>version</code></dt><dd><p>the version of AlphaSimR used to generate this object</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-SimParam-new"><code>SimParam$new()</code></a>
</p>
</li>
<li> <p><a href="#method-SimParam-setTrackPed"><code>SimParam$setTrackPed()</code></a>
</p>
</li>
<li> <p><a href="#method-SimParam-setTrackRec"><code>SimParam$setTrackRec()</code></a>
</p>
</li>
<li> <p><a href="#method-SimParam-resetPed"><code>SimParam$resetPed()</code></a>
</p>
</li>
<li> <p><a href="#method-SimParam-restrSegSites"><code>SimParam$restrSegSites()</code></a>
</p>
</li>
<li> <p><a href="#method-SimParam-setSexes"><code>SimParam$setSexes()</code></a>
</p>
</li>
<li> <p><a href="#method-SimParam-setFounderHap"><code>SimParam$setFounderHap()</code></a>
</p>
</li>
<li> <p><a href="#method-SimParam-addSnpChip"><code>SimParam$addSnpChip()</code></a>
</p>
</li>
<li> <p><a href="#method-SimParam-addSnpChipByName"><code>SimParam$addSnpChipByName()</code></a>
</p>
</li>
<li> <p><a href="#method-SimParam-addStructuredSnpChip"><code>SimParam$addStructuredSnpChip()</code></a>
</p>
</li>
<li> <p><a href="#method-SimParam-addTraitA"><code>SimParam$addTraitA()</code></a>
</p>
</li>
<li> <p><a href="#method-SimParam-addTraitAD"><code>SimParam$addTraitAD()</code></a>
</p>
</li>
<li> <p><a href="#method-SimParam-altAddTraitAD"><code>SimParam$altAddTraitAD()</code></a>
</p>
</li>
<li> <p><a href="#method-SimParam-addTraitAG"><code>SimParam$addTraitAG()</code></a>
</p>
</li>
<li> <p><a href="#method-SimParam-addTraitADG"><code>SimParam$addTraitADG()</code></a>
</p>
</li>
<li> <p><a href="#method-SimParam-addTraitAE"><code>SimParam$addTraitAE()</code></a>
</p>
</li>
<li> <p><a href="#method-SimParam-addTraitADE"><code>SimParam$addTraitADE()</code></a>
</p>
</li>
<li> <p><a href="#method-SimParam-addTraitAEG"><code>SimParam$addTraitAEG()</code></a>
</p>
</li>
<li> <p><a href="#method-SimParam-addTraitADEG"><code>SimParam$addTraitADEG()</code></a>
</p>
</li>
<li> <p><a href="#method-SimParam-manAddTrait"><code>SimParam$manAddTrait()</code></a>
</p>
</li>
<li> <p><a href="#method-SimParam-importTrait"><code>SimParam$importTrait()</code></a>
</p>
</li>
<li> <p><a href="#method-SimParam-switchTrait"><code>SimParam$switchTrait()</code></a>
</p>
</li>
<li> <p><a href="#method-SimParam-removeTrait"><code>SimParam$removeTrait()</code></a>
</p>
</li>
<li> <p><a href="#method-SimParam-setVarE"><code>SimParam$setVarE()</code></a>
</p>
</li>
<li> <p><a href="#method-SimParam-setCorE"><code>SimParam$setCorE()</code></a>
</p>
</li>
<li> <p><a href="#method-SimParam-rescaleTraits"><code>SimParam$rescaleTraits()</code></a>
</p>
</li>
<li> <p><a href="#method-SimParam-setRecombRatio"><code>SimParam$setRecombRatio()</code></a>
</p>
</li>
<li> <p><a href="#method-SimParam-switchGenMap"><code>SimParam$switchGenMap()</code></a>
</p>
</li>
<li> <p><a href="#method-SimParam-switchFemaleMap"><code>SimParam$switchFemaleMap()</code></a>
</p>
</li>
<li> <p><a href="#method-SimParam-switchMaleMap"><code>SimParam$switchMaleMap()</code></a>
</p>
</li>
<li> <p><a href="#method-SimParam-addToRec"><code>SimParam$addToRec()</code></a>
</p>
</li>
<li> <p><a href="#method-SimParam-ibdHaplo"><code>SimParam$ibdHaplo()</code></a>
</p>
</li>
<li> <p><a href="#method-SimParam-updateLastId"><code>SimParam$updateLastId()</code></a>
</p>
</li>
<li> <p><a href="#method-SimParam-addToPed"><code>SimParam$addToPed()</code></a>
</p>
</li>
<li> <p><a href="#method-SimParam-clone"><code>SimParam$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-SimParam-new"></a>



<h4>Method <code>new()</code></h4>

<p>Starts the process of building a new simulation
by creating a new SimParam object and assigning a founder
population to the class. It is recommended that you save the
object with the name &quot;SP&quot;, because subsequent functions will
check your global environment for an object of this name if
their simParam arguments are NULL. This allows you to call
these functions without explicitly supplying a simParam
argument with every call.
</p>


<h5>Usage</h5>

<div class="r"><pre>SimParam$new(founderPop)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>founderPop</code></dt><dd><p>an object of <code><a href="#topic+MapPop-class">MapPop-class</a></code></p>
</dd>
</dl>

</div>



<h5>Examples</h5>

<div class="r example copy">
<pre>#Create founder haplotypes
founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)

#Set simulation parameters
SP = SimParam$new(founderPop)
</pre>
</div>


<hr>
<a id="method-SimParam-setTrackPed"></a>



<h4>Method <code>setTrackPed()</code></h4>

<p>Sets pedigree tracking for the simulation.
By default pedigree tracking is turned off. When turned on,
the pedigree of all individuals created will be tracked,
except those created by <code><a href="#topic+hybridCross">hybridCross</a></code>. Turning
off pedigree tracking will turn off recombination tracking
if it is turned on.
</p>


<h5>Usage</h5>

<div class="r"><pre>SimParam$setTrackPed(isTrackPed, force = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>isTrackPed</code></dt><dd><p>should pedigree tracking be on.</p>
</dd>
<dt><code>force</code></dt><dd><p>should the check for a running simulation be
ignored. Only set to TRUE if you know what you are doing.</p>
</dd>
</dl>

</div>



<h5>Examples</h5>

<div class="r example copy">
<pre>#Create founder haplotypes
founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)

#Set simulation parameters
SP = SimParam$new(founderPop)
\dontshow{SP$nThreads = 1L}
SP$setTrackPed(TRUE)
</pre>
</div>


<hr>
<a id="method-SimParam-setTrackRec"></a>



<h4>Method <code>setTrackRec()</code></h4>

<p>Sets recombination tracking for the simulation.
By default recombination tracking is turned off. When turned
on recombination tracking will also turn on pedigree tracking.
Recombination tracking keeps records of all individuals created,
except those created by <code><a href="#topic+hybridCross">hybridCross</a></code>, because their
pedigree is not tracked.
</p>


<h5>Usage</h5>

<div class="r"><pre>SimParam$setTrackRec(isTrackRec, force = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>isTrackRec</code></dt><dd><p>should recombination tracking be on.</p>
</dd>
<dt><code>force</code></dt><dd><p>should the check for a running simulation be
ignored. Only set to TRUE if you know what you are doing.</p>
</dd>
</dl>

</div>



<h5>Examples</h5>

<div class="r example copy">
<pre>#Create founder haplotypes
founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)

#Set simulation parameters
SP = SimParam$new(founderPop)
\dontshow{SP$nThreads = 1L}
SP$setTrackRec(TRUE)
</pre>
</div>


<hr>
<a id="method-SimParam-resetPed"></a>



<h4>Method <code>resetPed()</code></h4>

<p>Resets the internal lastId, the pedigree
and recombination tracking (if in use) to the
supplied lastId. Be careful using this function because
it may introduce a bug if you use individuals from
the deleted portion of the pedigree.
</p>


<h5>Usage</h5>

<div class="r"><pre>SimParam$resetPed(lastId = 0L)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>lastId</code></dt><dd><p>last ID to include in pedigree</p>
</dd>
</dl>

</div>



<h5>Examples</h5>

<div class="r example copy">
<pre>#Create founder haplotypes
founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)

#Set simulation parameters
SP = SimParam$new(founderPop)
\dontshow{SP$nThreads = 1L}

#Create population
pop = newPop(founderPop, simParam=SP)
pop@id # 1:10

#Create another population after reseting pedigree
SP$resetPed()
pop2 = newPop(founderPop, simParam=SP)
pop2@id # 1:10
</pre>
</div>


<hr>
<a id="method-SimParam-restrSegSites"></a>



<h4>Method <code>restrSegSites()</code></h4>

<p>Sets restrictions on which segregating sites
can serve as a SNP and/or QTL.
</p>


<h5>Usage</h5>

<div class="r"><pre>SimParam$restrSegSites(
  minQtlPerChr = NULL,
  minSnpPerChr = NULL,
  excludeQtl = NULL,
  excludeSnp = NULL,
  overlap = FALSE,
  minSnpFreq = NULL
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>minQtlPerChr</code></dt><dd><p>the minimum number of segregating sites for 
QTLs. Can be a single value or a vector values for each chromosome.</p>
</dd>
<dt><code>minSnpPerChr</code></dt><dd><p>the minimum number of segregating sites for SNPs.
Can be a single value or a vector values for each chromosome.</p>
</dd>
<dt><code>excludeQtl</code></dt><dd><p>an optional vector of segregating site names to 
exclude from consideration as a viable QTL.</p>
</dd>
<dt><code>excludeSnp</code></dt><dd><p>an optional vector of segregating site names to 
exclude from consideration as a viable SNP.</p>
</dd>
<dt><code>overlap</code></dt><dd><p>should SNP and QTL sites be allowed to overlap.</p>
</dd>
<dt><code>minSnpFreq</code></dt><dd><p>minimum allowable frequency for SNP loci.
No minimum SNP frequency is used if value is NULL.</p>
</dd>
</dl>

</div>



<h5>Examples</h5>

<div class="r example copy">
<pre>#Create founder haplotypes
founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)

#Set simulation parameters
SP = SimParam$new(founderPop)
\dontshow{SP$nThreads = 1L}
SP$restrSegSites(minQtlPerChr=5, minSnpPerChr=5)
</pre>
</div>


<hr>
<a id="method-SimParam-setSexes"></a>



<h4>Method <code>setSexes()</code></h4>

<p>Changes how sexes are determined in the simulation.
The default sexes is &quot;no&quot;, indicating all individuals are hermaphrodites.
To add sexes to the simulation, run this function with &quot;yes_sys&quot; or
&quot;yes_rand&quot;. The value &quot;yes_sys&quot; will systematically assign
sexes to newly created individuals as first male and then female.
Populations with an odd number of individuals will have one more male than
female. The value &quot;yes_rand&quot; will randomly assign a sex to each
individual.
</p>


<h5>Usage</h5>

<div class="r"><pre>SimParam$setSexes(sexes, force = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>sexes</code></dt><dd><p>acceptable value are &quot;no&quot;, &quot;yes_sys&quot;, or
&quot;yes_rand&quot;</p>
</dd>
<dt><code>force</code></dt><dd><p>should the check for a running simulation be
ignored. Only set to TRUE if you know what you are doing.</p>
</dd>
</dl>

</div>



<h5>Examples</h5>

<div class="r example copy">
<pre>#Create founder haplotypes
founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)

#Set simulation parameters
SP = SimParam$new(founderPop)
\dontshow{SP$nThreads = 1L}
SP$setSexes("yes_sys")
</pre>
</div>


<hr>
<a id="method-SimParam-setFounderHap"></a>



<h4>Method <code>setFounderHap()</code></h4>

<p>Allows for the manual setting of founder haplotypes. This functionality 
is not fully documented, because it is still experimental.
</p>


<h5>Usage</h5>

<div class="r"><pre>SimParam$setFounderHap(hapMap)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>hapMap</code></dt><dd><p>a list of founder haplotypes</p>
</dd>
</dl>

</div>


<hr>
<a id="method-SimParam-addSnpChip"></a>



<h4>Method <code>addSnpChip()</code></h4>

<p>Randomly assigns eligible SNPs to a SNP chip
</p>


<h5>Usage</h5>

<div class="r"><pre>SimParam$addSnpChip(nSnpPerChr, minSnpFreq = NULL, refPop = NULL, name = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>nSnpPerChr</code></dt><dd><p>number of SNPs per chromosome.
Can be a single value or nChr values.</p>
</dd>
<dt><code>minSnpFreq</code></dt><dd><p>minimum allowable frequency for SNP loci.
If NULL, no minimum frequency is used.</p>
</dd>
<dt><code>refPop</code></dt><dd><p>reference population for calculating SNP
frequency. If NULL, the founder population is used.</p>
</dd>
<dt><code>name</code></dt><dd><p>optional name for chip</p>
</dd>
</dl>

</div>



<h5>Examples</h5>

<div class="r example copy">
<pre>#Create founder haplotypes
founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)

#Set simulation parameters
SP = SimParam$new(founderPop)
\dontshow{SP$nThreads = 1L}
SP$addSnpChip(10)
</pre>
</div>


<hr>
<a id="method-SimParam-addSnpChipByName"></a>



<h4>Method <code>addSnpChipByName()</code></h4>

<p>Assigns SNPs to a SNP chip by supplying marker names. This function does 
check against excluded SNPs and will not add the SNPs to the list of 
excluded QTL for the purpose of avoiding overlap between SNPs and QTL. 
Excluding these SNPs from being used as QTL can be accomplished using 
the excludeQtl argument in SimParam's restrSegSites function.
</p>


<h5>Usage</h5>

<div class="r"><pre>SimParam$addSnpChipByName(markers, name = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>markers</code></dt><dd><p>a vector of names for the markers</p>
</dd>
<dt><code>name</code></dt><dd><p>optional name for chip</p>
</dd>
</dl>

</div>



<h5>Examples</h5>

<div class="r example copy">
<pre>#Create founder haplotypes
founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)

#Set simulation parameters
SP = SimParam$new(founderPop)
SP$addSnpChipByName(c("1_1","1_3"))
</pre>
</div>


<hr>
<a id="method-SimParam-addStructuredSnpChip"></a>



<h4>Method <code>addStructuredSnpChip()</code></h4>

<p>Randomly selects the number of snps in structure and then
assigns them to chips based on structure
</p>


<h5>Usage</h5>

<div class="r"><pre>SimParam$addStructuredSnpChip(nSnpPerChr, structure, force = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>nSnpPerChr</code></dt><dd><p>number of SNPs per chromosome.
Can be a single value or nChr values.</p>
</dd>
<dt><code>structure</code></dt><dd><p>a matrix.  Rows are snp chips, columns are chips.
If value is true then that snp is on that chip.</p>
</dd>
<dt><code>force</code></dt><dd><p>should the check for a running simulation be
ignored. Only set to TRUE if you know what you are doing.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-SimParam-addTraitA"></a>



<h4>Method <code>addTraitA()</code></h4>

<p>Randomly assigns eligible QTLs for one or more additive traits.
If simulating more than one trait, all traits will be pleiotropic
with correlated additive effects.
</p>


<h5>Usage</h5>

<div class="r"><pre>SimParam$addTraitA(
  nQtlPerChr,
  mean = 0,
  var = 1,
  corA = NULL,
  gamma = FALSE,
  shape = 1,
  force = FALSE,
  name = NULL
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>nQtlPerChr</code></dt><dd><p>number of QTLs per chromosome. Can be a single value or nChr values.</p>
</dd>
<dt><code>mean</code></dt><dd><p>a vector of desired mean genetic values for one or more traits</p>
</dd>
<dt><code>var</code></dt><dd><p>a vector of desired genetic variances for one or more traits</p>
</dd>
<dt><code>corA</code></dt><dd><p>a matrix of correlations between additive effects</p>
</dd>
<dt><code>gamma</code></dt><dd><p>should a gamma distribution be used instead of normal</p>
</dd>
<dt><code>shape</code></dt><dd><p>the shape parameter for the gamma distribution
(the rate/scale parameter of the gamma distribution is accounted
for via the desired level of genetic variance, the var argument)</p>
</dd>
<dt><code>force</code></dt><dd><p>should the check for a running simulation be
ignored. Only set to TRUE if you know what you are doing.</p>
</dd>
<dt><code>name</code></dt><dd><p>optional name for trait(s)</p>
</dd>
</dl>

</div>



<h5>Examples</h5>

<div class="r example copy">
<pre>#Create founder haplotypes
founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)

#Set simulation parameters
SP = SimParam$new(founderPop)
\dontshow{SP$nThreads = 1L}
SP$addTraitA(10)
</pre>
</div>


<hr>
<a id="method-SimParam-addTraitAD"></a>



<h4>Method <code>addTraitAD()</code></h4>

<p>Randomly assigns eligible QTLs for one or more traits with dominance.
If simulating more than one trait, all traits will be pleiotropic
with correlated effects.
</p>


<h5>Usage</h5>

<div class="r"><pre>SimParam$addTraitAD(
  nQtlPerChr,
  mean = 0,
  var = 1,
  meanDD = 0,
  varDD = 0,
  corA = NULL,
  corDD = NULL,
  useVarA = TRUE,
  gamma = FALSE,
  shape = 1,
  force = FALSE,
  name = NULL
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>nQtlPerChr</code></dt><dd><p>number of QTLs per chromosome. Can be a single value or nChr values.</p>
</dd>
<dt><code>mean</code></dt><dd><p>a vector of desired mean genetic values for one or more traits</p>
</dd>
<dt><code>var</code></dt><dd><p>a vector of desired genetic variances for one or more traits</p>
</dd>
<dt><code>meanDD</code></dt><dd><p>mean dominance degree</p>
</dd>
<dt><code>varDD</code></dt><dd><p>variance of dominance degree</p>
</dd>
<dt><code>corA</code></dt><dd><p>a matrix of correlations between additive effects</p>
</dd>
<dt><code>corDD</code></dt><dd><p>a matrix of correlations between dominance degrees</p>
</dd>
<dt><code>useVarA</code></dt><dd><p>tune according to additive genetic variance if true. If
FALSE, tuning is performed according to total genetic variance.</p>
</dd>
<dt><code>gamma</code></dt><dd><p>should a gamma distribution be used instead of normal</p>
</dd>
<dt><code>shape</code></dt><dd><p>the shape parameter for the gamma distribution
(the rate/scale parameter of the gamma distribution is accounted
for via the desired level of genetic variance, the var argument)</p>
</dd>
<dt><code>force</code></dt><dd><p>should the check for a running simulation be
ignored. Only set to TRUE if you know what you are doing.</p>
</dd>
<dt><code>name</code></dt><dd><p>optional name for trait(s)</p>
</dd>
</dl>

</div>



<h5>Examples</h5>

<div class="r example copy">
<pre>#Create founder haplotypes
founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)

#Set simulation parameters
SP = SimParam$new(founderPop)
\dontshow{SP$nThreads = 1L}
SP$addTraitAD(10, meanDD=0.5)
</pre>
</div>


<hr>
<a id="method-SimParam-altAddTraitAD"></a>



<h4>Method <code>altAddTraitAD()</code></h4>

<p>An alternative method for adding a trait with additive  and dominance effects 
to an AlphaSimR simulation. The function attempts to create a trait matching 
user defined values for number of QTL, inbreeding depression, additive genetic 
variance and dominance genetic variance.
</p>


<h5>Usage</h5>

<div class="r"><pre>SimParam$altAddTraitAD(
  nQtlPerChr,
  mean = 0,
  varA = 1,
  varD = 0,
  inbrDepr = 0,
  limMeanDD = c(0, 1.5),
  limVarDD = c(0, 0.5),
  silent = FALSE,
  force = FALSE,
  name = NULL
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>nQtlPerChr</code></dt><dd><p>number of QTLs per chromosome. 
Can be a single value or nChr values.</p>
</dd>
<dt><code>mean</code></dt><dd><p>desired mean of the trait</p>
</dd>
<dt><code>varA</code></dt><dd><p>desired additive variance</p>
</dd>
<dt><code>varD</code></dt><dd><p>desired dominance variance</p>
</dd>
<dt><code>inbrDepr</code></dt><dd><p>desired inbreeding depression, see details</p>
</dd>
<dt><code>limMeanDD</code></dt><dd><p>limits for meanDD, see details</p>
</dd>
<dt><code>limVarDD</code></dt><dd><p>limits for varDD, see details</p>
</dd>
<dt><code>silent</code></dt><dd><p>should summary details be printed to the console</p>
</dd>
<dt><code>force</code></dt><dd><p>should the check for a running simulation be
ignored. Only set to TRUE if you know what you are doing.</p>
</dd>
<dt><code>name</code></dt><dd><p>optional name for trait</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p>This function will always add a trait to 'SimParam', unless an error occurs 
with picking QTLs. The resulting trait will always have the desired mean and 
additive genetic variance. However, it may not have the desired values for 
inbreeding depression and dominance variance. Thus, it is strongly recommended 
to check the output printed to the console to determine how close the trait's 
parameters came to these desired values.
</p>
<p>The mean and additive genetic variance will always be achieved exactly. The 
function attempts to achieve the desired dominance variance and inbreeding 
depression while staying within the user supplied constraints for the 
acceptable range of dominance degree mean and variance. If the desired values
are not being achieved, the acceptable range need to be increased and/or the 
number of QTL may need to be increased. There are not limits to setting the 
range for dominance degree mean and variance, but care should be taken to 
with regards to the biological feasibility of the limits that are supplied. 
The default limits were somewhat arbitrarily set, so I make not claim to 
how reasonable these limits are for routine use.
</p>
<p>Inbreeding depression in this function is defined as the difference in mean 
genetic value between a population with the same allele frequency as the 
reference population (population used to initialize SimParam) in 
Hardy-Weinberg equilibrium compared to a population with the same allele 
frequency that is fully inbred. This is equivalent to the amount the mean of 
a population increases when going from an inbreeding coefficient of 1 (fully 
inbred) to a population with an inbreeding coefficient of 0 (Hardy-Weinberg 
equilibrium). Note that the sign of the value should (usually) be positive. 
This corresponds to a detrimental effect of inbreeding when higher values of 
the trait are considered biologically beneficial.
</p>
<p>Summary information on this trait is printed to the console when silent=FALSE. 
The summary information reports the inbreeding depression and dominance 
variance for the population as well as the dominance degree mean and variance 
applied to the trait.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>#Create founder haplotypes
founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)

#Set simulation parameters
SP = SimParam$new(founderPop)
\dontshow{SP$nThreads = 1L}
SP$altAddTraitAD(nQtlPerChr=10, mean=0, varA=1, varD=0.05, inbrDepr=0.2)
</pre>
</div>


<hr>
<a id="method-SimParam-addTraitAG"></a>



<h4>Method <code>addTraitAG()</code></h4>

<p>Randomly assigns eligible QTLs for one or more additive GxE traits.
If simulating more than one trait, all traits will be pleiotropic
with correlated effects.
</p>


<h5>Usage</h5>

<div class="r"><pre>SimParam$addTraitAG(
  nQtlPerChr,
  mean = 0,
  var = 1,
  varGxE = 1e-06,
  varEnv = 0,
  corA = NULL,
  corGxE = NULL,
  gamma = FALSE,
  shape = 1,
  force = FALSE,
  name = NULL
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>nQtlPerChr</code></dt><dd><p>number of QTLs per chromosome. Can be a single value or nChr values.</p>
</dd>
<dt><code>mean</code></dt><dd><p>a vector of desired mean genetic values for one or more traits</p>
</dd>
<dt><code>var</code></dt><dd><p>a vector of desired genetic variances for one or more traits</p>
</dd>
<dt><code>varGxE</code></dt><dd><p>a vector of total genotype-by-environment variances for the traits</p>
</dd>
<dt><code>varEnv</code></dt><dd><p>a vector of environmental variances for one or more traits</p>
</dd>
<dt><code>corA</code></dt><dd><p>a matrix of correlations between additive effects</p>
</dd>
<dt><code>corGxE</code></dt><dd><p>a matrix of correlations between GxE effects</p>
</dd>
<dt><code>gamma</code></dt><dd><p>should a gamma distribution be used instead of normal</p>
</dd>
<dt><code>shape</code></dt><dd><p>the shape parameter for the gamma distribution
(the rate/scale parameter of the gamma distribution is accounted
for via the desired level of genetic variance, the var argument)</p>
</dd>
<dt><code>force</code></dt><dd><p>should the check for a running simulation be
ignored. Only set to TRUE if you know what you are doing.</p>
</dd>
<dt><code>name</code></dt><dd><p>optional name for trait(s)</p>
</dd>
</dl>

</div>



<h5>Examples</h5>

<div class="r example copy">
<pre>#Create founder haplotypes
founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)

#Set simulation parameters
SP = SimParam$new(founderPop)
\dontshow{SP$nThreads = 1L}
SP$addTraitAG(10, varGxE=2)
</pre>
</div>


<hr>
<a id="method-SimParam-addTraitADG"></a>



<h4>Method <code>addTraitADG()</code></h4>

<p>Randomly assigns eligible QTLs for a trait with dominance and GxE.
</p>


<h5>Usage</h5>

<div class="r"><pre>SimParam$addTraitADG(
  nQtlPerChr,
  mean = 0,
  var = 1,
  varEnv = 0,
  varGxE = 1e-06,
  meanDD = 0,
  varDD = 0,
  corA = NULL,
  corDD = NULL,
  corGxE = NULL,
  useVarA = TRUE,
  gamma = FALSE,
  shape = 1,
  force = FALSE,
  name = NULL
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>nQtlPerChr</code></dt><dd><p>number of QTLs per chromosome. Can be a single
value or nChr values.</p>
</dd>
<dt><code>mean</code></dt><dd><p>a vector of desired mean genetic values for one or more traits</p>
</dd>
<dt><code>var</code></dt><dd><p>a vector of desired genetic variances for one or more traits</p>
</dd>
<dt><code>varEnv</code></dt><dd><p>a vector of environmental variances for one or more traits</p>
</dd>
<dt><code>varGxE</code></dt><dd><p>a vector of total genotype-by-environment variances for the traits</p>
</dd>
<dt><code>meanDD</code></dt><dd><p>mean dominance degree</p>
</dd>
<dt><code>varDD</code></dt><dd><p>variance of dominance degree</p>
</dd>
<dt><code>corA</code></dt><dd><p>a matrix of correlations between additive effects</p>
</dd>
<dt><code>corDD</code></dt><dd><p>a matrix of correlations between dominance degrees</p>
</dd>
<dt><code>corGxE</code></dt><dd><p>a matrix of correlations between GxE effects</p>
</dd>
<dt><code>useVarA</code></dt><dd><p>tune according to additive genetic variance if true</p>
</dd>
<dt><code>gamma</code></dt><dd><p>should a gamma distribution be used instead of normal</p>
</dd>
<dt><code>shape</code></dt><dd><p>the shape parameter for the gamma distribution
(the rate/scale parameter of the gamma distribution is accounted
for via the desired level of genetic variance, the var argument)</p>
</dd>
<dt><code>force</code></dt><dd><p>should the check for a running simulation be
ignored. Only set to TRUE if you know what you are doing.</p>
</dd>
<dt><code>name</code></dt><dd><p>optional name for trait(s)</p>
</dd>
</dl>

</div>



<h5>Examples</h5>

<div class="r example copy">
<pre>#Create founder haplotypes
founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)

#Set simulation parameters
SP = SimParam$new(founderPop)
\dontshow{SP$nThreads = 1L}
SP$addTraitADG(10, meanDD=0.5, varGxE=2)
</pre>
</div>


<hr>
<a id="method-SimParam-addTraitAE"></a>



<h4>Method <code>addTraitAE()</code></h4>

<p>Randomly assigns eligible QTLs for one or more additive and epistasis
traits. If simulating more than one trait, all traits will be pleiotropic
with correlated additive effects.
</p>


<h5>Usage</h5>

<div class="r"><pre>SimParam$addTraitAE(
  nQtlPerChr,
  mean = 0,
  var = 1,
  relAA = 0,
  corA = NULL,
  corAA = NULL,
  useVarA = TRUE,
  gamma = FALSE,
  shape = 1,
  force = FALSE,
  name = NULL
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>nQtlPerChr</code></dt><dd><p>number of QTLs per chromosome. Can be a single value or nChr values.</p>
</dd>
<dt><code>mean</code></dt><dd><p>a vector of desired mean genetic values for one or more traits</p>
</dd>
<dt><code>var</code></dt><dd><p>a vector of desired genetic variances for one or more traits</p>
</dd>
<dt><code>relAA</code></dt><dd><p>the relative value of additive-by-additive variance compared
to additive variance in a diploid organism with allele frequency 0.5</p>
</dd>
<dt><code>corA</code></dt><dd><p>a matrix of correlations between additive effects</p>
</dd>
<dt><code>corAA</code></dt><dd><p>a matrix of correlations between additive-by-additive effects</p>
</dd>
<dt><code>useVarA</code></dt><dd><p>tune according to additive genetic variance if true. If
FALSE, tuning is performed according to total genetic variance.</p>
</dd>
<dt><code>gamma</code></dt><dd><p>should a gamma distribution be used instead of normal</p>
</dd>
<dt><code>shape</code></dt><dd><p>the shape parameter for the gamma distribution
(the rate/scale parameter of the gamma distribution is accounted
for via the desired level of genetic variance, the var argument)</p>
</dd>
<dt><code>force</code></dt><dd><p>should the check for a running simulation be
ignored. Only set to TRUE if you know what you are doing.</p>
</dd>
<dt><code>name</code></dt><dd><p>optional name for trait(s)</p>
</dd>
</dl>

</div>



<h5>Examples</h5>

<div class="r example copy">
<pre>#Create founder haplotypes
founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)

#Set simulation parameters
SP = SimParam$new(founderPop)
\dontshow{SP$nThreads = 1L}
SP$addTraitAE(10, relAA=0.1)
</pre>
</div>


<hr>
<a id="method-SimParam-addTraitADE"></a>



<h4>Method <code>addTraitADE()</code></h4>

<p>Randomly assigns eligible QTLs for one or more traits with dominance and
epistasis. If simulating more than one trait, all traits will be pleiotropic
with correlated effects.
</p>


<h5>Usage</h5>

<div class="r"><pre>SimParam$addTraitADE(
  nQtlPerChr,
  mean = 0,
  var = 1,
  meanDD = 0,
  varDD = 0,
  relAA = 0,
  corA = NULL,
  corDD = NULL,
  corAA = NULL,
  useVarA = TRUE,
  gamma = FALSE,
  shape = 1,
  force = FALSE,
  name = NULL
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>nQtlPerChr</code></dt><dd><p>number of QTLs per chromosome. Can be a single value or nChr values.</p>
</dd>
<dt><code>mean</code></dt><dd><p>a vector of desired mean genetic values for one or more traits</p>
</dd>
<dt><code>var</code></dt><dd><p>a vector of desired genetic variances for one or more traits</p>
</dd>
<dt><code>meanDD</code></dt><dd><p>mean dominance degree</p>
</dd>
<dt><code>varDD</code></dt><dd><p>variance of dominance degree</p>
</dd>
<dt><code>relAA</code></dt><dd><p>the relative value of additive-by-additive variance compared
to additive variance in a diploid organism with allele frequency 0.5</p>
</dd>
<dt><code>corA</code></dt><dd><p>a matrix of correlations between additive effects</p>
</dd>
<dt><code>corDD</code></dt><dd><p>a matrix of correlations between dominance degrees</p>
</dd>
<dt><code>corAA</code></dt><dd><p>a matrix of correlations between additive-by-additive effects</p>
</dd>
<dt><code>useVarA</code></dt><dd><p>tune according to additive genetic variance if true. If
FALSE, tuning is performed according to total genetic variance.</p>
</dd>
<dt><code>gamma</code></dt><dd><p>should a gamma distribution be used instead of normal</p>
</dd>
<dt><code>shape</code></dt><dd><p>the shape parameter for the gamma distribution
(the rate/scale parameter of the gamma distribution is accounted
for via the desired level of genetic variance, the var argument)</p>
</dd>
<dt><code>force</code></dt><dd><p>should the check for a running simulation be
ignored. Only set to TRUE if you know what you are doing.</p>
</dd>
<dt><code>name</code></dt><dd><p>optional name for trait(s)</p>
</dd>
</dl>

</div>



<h5>Examples</h5>

<div class="r example copy">
<pre>#Create founder haplotypes
founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)

#Set simulation parameters
SP = SimParam$new(founderPop)
\dontshow{SP$nThreads = 1L}
SP$addTraitADE(10)
</pre>
</div>


<hr>
<a id="method-SimParam-addTraitAEG"></a>



<h4>Method <code>addTraitAEG()</code></h4>

<p>Randomly assigns eligible QTLs for one or more additive and epistasis
GxE traits. If simulating more than one trait, all traits will be pleiotropic
with correlated effects.
</p>


<h5>Usage</h5>

<div class="r"><pre>SimParam$addTraitAEG(
  nQtlPerChr,
  mean = 0,
  var = 1,
  relAA = 0,
  varGxE = 1e-06,
  varEnv = 0,
  corA = NULL,
  corAA = NULL,
  corGxE = NULL,
  useVarA = TRUE,
  gamma = FALSE,
  shape = 1,
  force = FALSE,
  name = NULL
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>nQtlPerChr</code></dt><dd><p>number of QTLs per chromosome. Can be a single value or nChr values.</p>
</dd>
<dt><code>mean</code></dt><dd><p>a vector of desired mean genetic values for one or more traits</p>
</dd>
<dt><code>var</code></dt><dd><p>a vector of desired genetic variances for one or more traits</p>
</dd>
<dt><code>relAA</code></dt><dd><p>the relative value of additive-by-additive variance compared
to additive variance in a diploid organism with allele frequency 0.5</p>
</dd>
<dt><code>varGxE</code></dt><dd><p>a vector of total genotype-by-environment variances for the traits</p>
</dd>
<dt><code>varEnv</code></dt><dd><p>a vector of environmental variances for one or more traits</p>
</dd>
<dt><code>corA</code></dt><dd><p>a matrix of correlations between additive effects</p>
</dd>
<dt><code>corAA</code></dt><dd><p>a matrix of correlations between additive-by-additive effects</p>
</dd>
<dt><code>corGxE</code></dt><dd><p>a matrix of correlations between GxE effects</p>
</dd>
<dt><code>useVarA</code></dt><dd><p>tune according to additive genetic variance if true. If
FALSE, tuning is performed according to total genetic variance.</p>
</dd>
<dt><code>gamma</code></dt><dd><p>should a gamma distribution be used instead of normal</p>
</dd>
<dt><code>shape</code></dt><dd><p>the shape parameter for the gamma distribution
(the rate/scale parameter of the gamma distribution is accounted
for via the desired level of genetic variance, the var argument)</p>
</dd>
<dt><code>force</code></dt><dd><p>should the check for a running simulation be
ignored. Only set to TRUE if you know what you are doing.</p>
</dd>
<dt><code>name</code></dt><dd><p>optional name for trait(s)</p>
</dd>
</dl>

</div>



<h5>Examples</h5>

<div class="r example copy">
<pre>#Create founder haplotypes
founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)

#Set simulation parameters
SP = SimParam$new(founderPop)
\dontshow{SP$nThreads = 1L}
SP$addTraitAEG(10, varGxE=2)
</pre>
</div>


<hr>
<a id="method-SimParam-addTraitADEG"></a>



<h4>Method <code>addTraitADEG()</code></h4>

<p>Randomly assigns eligible QTLs for a trait with dominance,
epistasis and GxE.
</p>


<h5>Usage</h5>

<div class="r"><pre>SimParam$addTraitADEG(
  nQtlPerChr,
  mean = 0,
  var = 1,
  varEnv = 0,
  varGxE = 1e-06,
  meanDD = 0,
  varDD = 0,
  relAA = 0,
  corA = NULL,
  corDD = NULL,
  corAA = NULL,
  corGxE = NULL,
  useVarA = TRUE,
  gamma = FALSE,
  shape = 1,
  force = FALSE,
  name = NULL
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>nQtlPerChr</code></dt><dd><p>number of QTLs per chromosome. Can be a single
value or nChr values.</p>
</dd>
<dt><code>mean</code></dt><dd><p>a vector of desired mean genetic values for one or more traits</p>
</dd>
<dt><code>var</code></dt><dd><p>a vector of desired genetic variances for one or more traits</p>
</dd>
<dt><code>varEnv</code></dt><dd><p>a vector of environmental variances for one or more traits</p>
</dd>
<dt><code>varGxE</code></dt><dd><p>a vector of total genotype-by-environment variances for the traits</p>
</dd>
<dt><code>meanDD</code></dt><dd><p>mean dominance degree</p>
</dd>
<dt><code>varDD</code></dt><dd><p>variance of dominance degree</p>
</dd>
<dt><code>relAA</code></dt><dd><p>the relative value of additive-by-additive variance compared
to additive variance in a diploid organism with allele frequency 0.5</p>
</dd>
<dt><code>corA</code></dt><dd><p>a matrix of correlations between additive effects</p>
</dd>
<dt><code>corDD</code></dt><dd><p>a matrix of correlations between dominance degrees</p>
</dd>
<dt><code>corAA</code></dt><dd><p>a matrix of correlations between additive-by-additive effects</p>
</dd>
<dt><code>corGxE</code></dt><dd><p>a matrix of correlations between GxE effects</p>
</dd>
<dt><code>useVarA</code></dt><dd><p>tune according to additive genetic variance if true</p>
</dd>
<dt><code>gamma</code></dt><dd><p>should a gamma distribution be used instead of normal</p>
</dd>
<dt><code>shape</code></dt><dd><p>the shape parameter for the gamma distribution
(the rate/scale parameter of the gamma distribution is accounted
for via the desired level of genetic variance, the var argument)</p>
</dd>
<dt><code>force</code></dt><dd><p>should the check for a running simulation be
ignored. Only set to TRUE if you know what you are doing.</p>
</dd>
<dt><code>name</code></dt><dd><p>optional name for trait(s)</p>
</dd>
</dl>

</div>



<h5>Examples</h5>

<div class="r example copy">
<pre>#Create founder haplotypes
founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)

#Set simulation parameters
SP = SimParam$new(founderPop)
\dontshow{SP$nThreads = 1L}
SP$addTraitADEG(10, meanDD=0.5, varGxE=2)
</pre>
</div>


<hr>
<a id="method-SimParam-manAddTrait"></a>



<h4>Method <code>manAddTrait()</code></h4>

<p>Manually add a new trait to the simulation. Trait must
be formatted as a <code><a href="#topic+LociMap-class">LociMap-class</a></code>. If the
trait is not already formatted, consider using importTrait.
</p>


<h5>Usage</h5>

<div class="r"><pre>SimParam$manAddTrait(lociMap, varE = NA_real_, force = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>lociMap</code></dt><dd><p>a new object descended from
<code><a href="#topic+LociMap-class">LociMap-class</a></code></p>
</dd>
<dt><code>varE</code></dt><dd><p>default error variance for phenotype, optional</p>
</dd>
<dt><code>force</code></dt><dd><p>should the check for a running simulation be
ignored. Only set to TRUE if you know what you are doing</p>
</dd>
</dl>

</div>


<hr>
<a id="method-SimParam-importTrait"></a>



<h4>Method <code>importTrait()</code></h4>

<p>Manually add a new trait(s) to the simulation. Unlike the
manAddTrait function, this function does not require
formatting the trait as a <code><a href="#topic+LociMap-class">LociMap-class</a></code>.
The formatting is performed automatically for the user,
with more user friendly data.frames or matrices taken as
inputs. This function only works for A and AD trait types.
</p>


<h5>Usage</h5>

<div class="r"><pre>SimParam$importTrait(
  markerNames,
  addEff,
  domEff = NULL,
  intercept = NULL,
  name = NULL,
  varE = NULL,
  force = FALSE
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>markerNames</code></dt><dd><p>a vector of names for the QTL</p>
</dd>
<dt><code>addEff</code></dt><dd><p>a matrix of additive effects (nLoci x nTraits).
Alternatively, a vector of length nLoci can be supplied for
a single trait.</p>
</dd>
<dt><code>domEff</code></dt><dd><p>optional dominance effects for each locus</p>
</dd>
<dt><code>intercept</code></dt><dd><p>optional intercepts for each trait</p>
</dd>
<dt><code>name</code></dt><dd><p>optional name(s) for the trait(s)</p>
</dd>
<dt><code>varE</code></dt><dd><p>default error variance for phenotype, optional</p>
</dd>
<dt><code>force</code></dt><dd><p>should the check for a running simulation be
ignored. Only set to TRUE if you know what you are doing</p>
</dd>
</dl>

</div>


<hr>
<a id="method-SimParam-switchTrait"></a>



<h4>Method <code>switchTrait()</code></h4>

<p>Switch a trait in the simulation.
</p>


<h5>Usage</h5>

<div class="r"><pre>SimParam$switchTrait(traitPos, lociMap, varE = NA_real_, force = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>traitPos</code></dt><dd><p>an integer indicate which trait to switch</p>
</dd>
<dt><code>lociMap</code></dt><dd><p>a new object descended from
<code><a href="#topic+LociMap-class">LociMap-class</a></code></p>
</dd>
<dt><code>varE</code></dt><dd><p>default error variance for phenotype, optional</p>
</dd>
<dt><code>force</code></dt><dd><p>should the check for a running simulation be
ignored. Only set to TRUE if you know what you are doing</p>
</dd>
</dl>

</div>


<hr>
<a id="method-SimParam-removeTrait"></a>



<h4>Method <code>removeTrait()</code></h4>

<p>Remove a trait from the simulation
</p>


<h5>Usage</h5>

<div class="r"><pre>SimParam$removeTrait(traits, force = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>traits</code></dt><dd><p>an integer vector indicating which traits to remove</p>
</dd>
<dt><code>force</code></dt><dd><p>should the check for a running simulation be
ignored. Only set to TRUE if you know what you are doing</p>
</dd>
</dl>

</div>


<hr>
<a id="method-SimParam-setVarE"></a>



<h4>Method <code>setVarE()</code></h4>

<p>Defines a default values for error
variances used in <code><a href="#topic+setPheno">setPheno</a></code>. These defaults 
will be used to automatically generate phenotypes when new 
populations are created. See the details section of <code><a href="#topic+setPheno">setPheno</a></code>
for more information about each arguments and how they 
should be used.
</p>


<h5>Usage</h5>

<div class="r"><pre>SimParam$setVarE(h2 = NULL, H2 = NULL, varE = NULL, corE = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>h2</code></dt><dd><p>a vector of desired narrow-sense heritabilities</p>
</dd>
<dt><code>H2</code></dt><dd><p>a vector of desired broad-sense heritabilities</p>
</dd>
<dt><code>varE</code></dt><dd><p>a vector or matrix of error variances</p>
</dd>
<dt><code>corE</code></dt><dd><p>an optional matrix of error correlations</p>
</dd>
</dl>

</div>



<h5>Examples</h5>

<div class="r example copy">
<pre>#Create founder haplotypes
founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)

#Set simulation parameters
SP = SimParam$new(founderPop)
\dontshow{SP$nThreads = 1L}
SP$addTraitA(10)
SP$setVarE(h2=0.5)
</pre>
</div>


<hr>
<a id="method-SimParam-setCorE"></a>



<h4>Method <code>setCorE()</code></h4>

<p>Defines a correlation structure for default
error variances. You must call <code>setVarE</code> first to define
the default error variances.
</p>


<h5>Usage</h5>

<div class="r"><pre>SimParam$setCorE(corE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>corE</code></dt><dd><p>a correlation matrix for the error variances</p>
</dd>
</dl>

</div>



<h5>Examples</h5>

<div class="r example copy">
<pre>#Create founder haplotypes
founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)

#Set simulation parameters
SP = SimParam$new(founderPop)
\dontshow{SP$nThreads = 1L}
SP$addTraitA(10, mean=c(0,0), var=c(1,1), corA=diag(2))
SP$setVarE(varE=c(1,1))
E = 0.5*diag(2)+0.5 #Positively correlated error
SP$setCorE(E)
</pre>
</div>


<hr>
<a id="method-SimParam-rescaleTraits"></a>



<h4>Method <code>rescaleTraits()</code></h4>

<p>Linearly scales all traits to achieve desired
values of means and variances in the founder population.
</p>


<h5>Usage</h5>

<div class="r"><pre>SimParam$rescaleTraits(
  mean = 0,
  var = 1,
  varEnv = 0,
  varGxE = 1e-06,
  useVarA = TRUE
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>mean</code></dt><dd><p>a vector of new trait means</p>
</dd>
<dt><code>var</code></dt><dd><p>a vector of new trait variances</p>
</dd>
<dt><code>varEnv</code></dt><dd><p>a vector of new environmental variances</p>
</dd>
<dt><code>varGxE</code></dt><dd><p>a vector of new GxE variances</p>
</dd>
<dt><code>useVarA</code></dt><dd><p>tune according to additive genetic variance if true</p>
</dd>
</dl>

</div>



<h5>Examples</h5>

<div class="r example copy">
<pre>#Create founder haplotypes
founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)

#Set simulation parameters
SP = SimParam$new(founderPop)
SP$addTraitA(10)

#Create population
pop = newPop(founderPop, simParam=SP)
meanG(pop)

#Change mean to 1
SP$rescaleTraits(mean=1)
\dontshow{SP$nThreads = 1L}
#Run resetPop for change to take effect
pop = resetPop(pop, simParam=SP)
meanG(pop)
</pre>
</div>


<hr>
<a id="method-SimParam-setRecombRatio"></a>



<h4>Method <code>setRecombRatio()</code></h4>

<p>Set the relative recombination rates between males
and females. This allows for sex-specific recombination rates,
under the assumption of equivalent recombination landscapes.
</p>


<h5>Usage</h5>

<div class="r"><pre>SimParam$setRecombRatio(femaleRatio)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>femaleRatio</code></dt><dd><p>relative ratio of recombination in females compared to
males. A value of 2 indicate twice as much recombination in females. The
value must be greater than 0. (default is 1)</p>
</dd>
</dl>

</div>



<h5>Examples</h5>

<div class="r example copy">
<pre>#Create founder haplotypes
founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)

#Set simulation parameters
SP = SimParam$new(founderPop)
\dontshow{SP$nThreads = 1L}
SP$setRecombRatio(2) #Twice as much recombination in females
</pre>
</div>


<hr>
<a id="method-SimParam-switchGenMap"></a>



<h4>Method <code>switchGenMap()</code></h4>

<p>Replaces existing genetic map.
</p>


<h5>Usage</h5>

<div class="r"><pre>SimParam$switchGenMap(genMap, centromere = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>genMap</code></dt><dd><p>a list of length nChr containing
numeric vectors for the position of each segregating
site on a chromosome.</p>
</dd>
<dt><code>centromere</code></dt><dd><p>a numeric vector of centromere
positions. If NULL, the centromere are assumed to
be metacentric.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-SimParam-switchFemaleMap"></a>



<h4>Method <code>switchFemaleMap()</code></h4>

<p>Replaces existing female genetic map.
</p>


<h5>Usage</h5>

<div class="r"><pre>SimParam$switchFemaleMap(genMap, centromere = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>genMap</code></dt><dd><p>a list of length nChr containing
numeric vectors for the position of each segregating
site on a chromosome.</p>
</dd>
<dt><code>centromere</code></dt><dd><p>a numeric vector of centromere
positions. If NULL, the centromere are assumed to
be metacentric.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-SimParam-switchMaleMap"></a>



<h4>Method <code>switchMaleMap()</code></h4>

<p>Replaces existing male genetic map.
</p>


<h5>Usage</h5>

<div class="r"><pre>SimParam$switchMaleMap(genMap, centromere = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>genMap</code></dt><dd><p>a list of length nChr containing
numeric vectors for the position of each segregating
site on a chromosome.</p>
</dd>
<dt><code>centromere</code></dt><dd><p>a numeric vector of centromere
positions. If NULL, the centromere are assumed to
be metacentric.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-SimParam-addToRec"></a>



<h4>Method <code>addToRec()</code></h4>

<p>For internal use only.
</p>


<h5>Usage</h5>

<div class="r"><pre>SimParam$addToRec(lastId, id, mother, father, isDH, hist, ploidy)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>lastId</code></dt><dd><p>ID of last individual</p>
</dd>
<dt><code>id</code></dt><dd><p>the name of each individual</p>
</dd>
<dt><code>mother</code></dt><dd><p>vector of mother iids</p>
</dd>
<dt><code>father</code></dt><dd><p>vector of father iids</p>
</dd>
<dt><code>isDH</code></dt><dd><p>indicator for DH lines</p>
</dd>
<dt><code>hist</code></dt><dd><p>new recombination history</p>
</dd>
<dt><code>ploidy</code></dt><dd><p>ploidy level</p>
</dd>
</dl>

</div>


<hr>
<a id="method-SimParam-ibdHaplo"></a>



<h4>Method <code>ibdHaplo()</code></h4>

<p>For internal use only.
</p>


<h5>Usage</h5>

<div class="r"><pre>SimParam$ibdHaplo(iid)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>iid</code></dt><dd><p>internal ID</p>
</dd>
</dl>

</div>


<hr>
<a id="method-SimParam-updateLastId"></a>



<h4>Method <code>updateLastId()</code></h4>

<p>For internal use only.
</p>


<h5>Usage</h5>

<div class="r"><pre>SimParam$updateLastId(lastId)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>lastId</code></dt><dd><p>last ID assigned</p>
</dd>
</dl>

</div>


<hr>
<a id="method-SimParam-addToPed"></a>



<h4>Method <code>addToPed()</code></h4>

<p>For internal use only.
</p>


<h5>Usage</h5>

<div class="r"><pre>SimParam$addToPed(lastId, id, mother, father, isDH)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>lastId</code></dt><dd><p>ID of last individual</p>
</dd>
<dt><code>id</code></dt><dd><p>the name of each individual</p>
</dd>
<dt><code>mother</code></dt><dd><p>vector of mother iids</p>
</dd>
<dt><code>father</code></dt><dd><p>vector of father iids</p>
</dd>
<dt><code>isDH</code></dt><dd><p>indicator for DH lines</p>
</dd>
</dl>

</div>


<hr>
<a id="method-SimParam-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>SimParam$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Note</h3>

<p>By default the founder population is the population used to
initalize the SimParam object. This population can be changed by
replacing the population in the founderPop slot. You must run
<code><a href="#topic+resetPop">resetPop</a></code> on any existing populations to obtain the
new trait values.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## ------------------------------------------------
## Method `SimParam$new`
## ------------------------------------------------

#Create founder haplotypes
founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)

#Set simulation parameters
SP = SimParam$new(founderPop)

## ------------------------------------------------
## Method `SimParam$setTrackPed`
## ------------------------------------------------

#Create founder haplotypes
founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)

#Set simulation parameters
SP = SimParam$new(founderPop)

SP$setTrackPed(TRUE)

## ------------------------------------------------
## Method `SimParam$setTrackRec`
## ------------------------------------------------

#Create founder haplotypes
founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)

#Set simulation parameters
SP = SimParam$new(founderPop)

SP$setTrackRec(TRUE)

## ------------------------------------------------
## Method `SimParam$resetPed`
## ------------------------------------------------

#Create founder haplotypes
founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)

#Set simulation parameters
SP = SimParam$new(founderPop)


#Create population
pop = newPop(founderPop, simParam=SP)
pop@id # 1:10

#Create another population after reseting pedigree
SP$resetPed()
pop2 = newPop(founderPop, simParam=SP)
pop2@id # 1:10

## ------------------------------------------------
## Method `SimParam$restrSegSites`
## ------------------------------------------------

#Create founder haplotypes
founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)

#Set simulation parameters
SP = SimParam$new(founderPop)

SP$restrSegSites(minQtlPerChr=5, minSnpPerChr=5)

## ------------------------------------------------
## Method `SimParam$setSexes`
## ------------------------------------------------

#Create founder haplotypes
founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)

#Set simulation parameters
SP = SimParam$new(founderPop)

SP$setSexes("yes_sys")

## ------------------------------------------------
## Method `SimParam$addSnpChip`
## ------------------------------------------------

#Create founder haplotypes
founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)

#Set simulation parameters
SP = SimParam$new(founderPop)

SP$addSnpChip(10)

## ------------------------------------------------
## Method `SimParam$addSnpChipByName`
## ------------------------------------------------

#Create founder haplotypes
founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)

#Set simulation parameters
SP = SimParam$new(founderPop)
SP$addSnpChipByName(c("1_1","1_3"))

## ------------------------------------------------
## Method `SimParam$addTraitA`
## ------------------------------------------------

#Create founder haplotypes
founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)

#Set simulation parameters
SP = SimParam$new(founderPop)

SP$addTraitA(10)

## ------------------------------------------------
## Method `SimParam$addTraitAD`
## ------------------------------------------------

#Create founder haplotypes
founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)

#Set simulation parameters
SP = SimParam$new(founderPop)

SP$addTraitAD(10, meanDD=0.5)

## ------------------------------------------------
## Method `SimParam$altAddTraitAD`
## ------------------------------------------------

#Create founder haplotypes
founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)

#Set simulation parameters
SP = SimParam$new(founderPop)

SP$altAddTraitAD(nQtlPerChr=10, mean=0, varA=1, varD=0.05, inbrDepr=0.2)

## ------------------------------------------------
## Method `SimParam$addTraitAG`
## ------------------------------------------------

#Create founder haplotypes
founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)

#Set simulation parameters
SP = SimParam$new(founderPop)

SP$addTraitAG(10, varGxE=2)

## ------------------------------------------------
## Method `SimParam$addTraitADG`
## ------------------------------------------------

#Create founder haplotypes
founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)

#Set simulation parameters
SP = SimParam$new(founderPop)

SP$addTraitADG(10, meanDD=0.5, varGxE=2)

## ------------------------------------------------
## Method `SimParam$addTraitAE`
## ------------------------------------------------

#Create founder haplotypes
founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)

#Set simulation parameters
SP = SimParam$new(founderPop)

SP$addTraitAE(10, relAA=0.1)

## ------------------------------------------------
## Method `SimParam$addTraitADE`
## ------------------------------------------------

#Create founder haplotypes
founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)

#Set simulation parameters
SP = SimParam$new(founderPop)

SP$addTraitADE(10)

## ------------------------------------------------
## Method `SimParam$addTraitAEG`
## ------------------------------------------------

#Create founder haplotypes
founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)

#Set simulation parameters
SP = SimParam$new(founderPop)

SP$addTraitAEG(10, varGxE=2)

## ------------------------------------------------
## Method `SimParam$addTraitADEG`
## ------------------------------------------------

#Create founder haplotypes
founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)

#Set simulation parameters
SP = SimParam$new(founderPop)

SP$addTraitADEG(10, meanDD=0.5, varGxE=2)

## ------------------------------------------------
## Method `SimParam$setVarE`
## ------------------------------------------------

#Create founder haplotypes
founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)

#Set simulation parameters
SP = SimParam$new(founderPop)

SP$addTraitA(10)
SP$setVarE(h2=0.5)

## ------------------------------------------------
## Method `SimParam$setCorE`
## ------------------------------------------------

#Create founder haplotypes
founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)

#Set simulation parameters
SP = SimParam$new(founderPop)

SP$addTraitA(10, mean=c(0,0), var=c(1,1), corA=diag(2))
SP$setVarE(varE=c(1,1))
E = 0.5*diag(2)+0.5 #Positively correlated error
SP$setCorE(E)

## ------------------------------------------------
## Method `SimParam$rescaleTraits`
## ------------------------------------------------

#Create founder haplotypes
founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)

#Set simulation parameters
SP = SimParam$new(founderPop)
SP$addTraitA(10)

#Create population
pop = newPop(founderPop, simParam=SP)
meanG(pop)

#Change mean to 1
SP$rescaleTraits(mean=1)

#Run resetPop for change to take effect
pop = resetPop(pop, simParam=SP)
meanG(pop)

## ------------------------------------------------
## Method `SimParam$setRecombRatio`
## ------------------------------------------------

#Create founder haplotypes
founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)

#Set simulation parameters
SP = SimParam$new(founderPop)

SP$setRecombRatio(2) #Twice as much recombination in females
</code></pre>

<hr>
<h2 id='smithHazel'>Calculate Smith-Hazel weights</h2><span id='topic+smithHazel'></span>

<h3>Description</h3>

<p>Calculates weights for Smith-Hazel index given economice weights 
and phenotypic and genotypic variance-covariance matrices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>smithHazel(econWt, varG, varP)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="smithHazel_+3A_econwt">econWt</code></td>
<td>
<p>vector of economic weights</p>
</td></tr>
<tr><td><code id="smithHazel_+3A_varg">varG</code></td>
<td>
<p>the genetic variance-covariance matrix</p>
</td></tr>
<tr><td><code id="smithHazel_+3A_varp">varP</code></td>
<td>
<p>the phenotypic variance-covariance matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of weight for calculating index values
</p>


<h3>Examples</h3>

<pre><code class='language-R'>G = 1.5*diag(2)-0.5
E = diag(2)
P = G+E
wt = c(1,1)
smithHazel(wt, G, P)

</code></pre>

<hr>
<h2 id='solveMKM'>Solve Multikernel Model</h2><span id='topic+solveMKM'></span>

<h3>Description</h3>

<p>Solves a univariate mixed model with multiple random effects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>solveMKM(y, X, Zlist, Klist, maxIter = 40L, tol = 1e-04)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="solveMKM_+3A_y">y</code></td>
<td>
<p>a matrix with n rows and 1 column</p>
</td></tr>
<tr><td><code id="solveMKM_+3A_x">X</code></td>
<td>
<p>a matrix with n rows and x columns</p>
</td></tr>
<tr><td><code id="solveMKM_+3A_zlist">Zlist</code></td>
<td>
<p>a list of Z matrices</p>
</td></tr>
<tr><td><code id="solveMKM_+3A_klist">Klist</code></td>
<td>
<p>a list of K matrices</p>
</td></tr>
<tr><td><code id="solveMKM_+3A_maxiter">maxIter</code></td>
<td>
<p>maximum number of iteration</p>
</td></tr>
<tr><td><code id="solveMKM_+3A_tol">tol</code></td>
<td>
<p>tolerance for convergence</p>
</td></tr>
</table>

<hr>
<h2 id='solveMVM'>Solve Multivariate Model</h2><span id='topic+solveMVM'></span>

<h3>Description</h3>

<p>Solves a multivariate mixed model of form <code class="reqn">Y=X\beta+Zu+e</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>solveMVM(Y, X, Z, K, tol = 1e-06, maxIter = 1000L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="solveMVM_+3A_y">Y</code></td>
<td>
<p>a matrix with n rows and q columns</p>
</td></tr>
<tr><td><code id="solveMVM_+3A_x">X</code></td>
<td>
<p>a matrix with n rows and x columns</p>
</td></tr>
<tr><td><code id="solveMVM_+3A_z">Z</code></td>
<td>
<p>a matrix with n rows and m columns</p>
</td></tr>
<tr><td><code id="solveMVM_+3A_k">K</code></td>
<td>
<p>a matrix with m rows and m columns</p>
</td></tr>
<tr><td><code id="solveMVM_+3A_tol">tol</code></td>
<td>
<p>tolerance for convergence</p>
</td></tr>
<tr><td><code id="solveMVM_+3A_maxiter">maxIter</code></td>
<td>
<p>maximum number of iteration</p>
</td></tr>
</table>

<hr>
<h2 id='solveRRBLUP'>Solve RR-BLUP</h2><span id='topic+solveRRBLUP'></span>

<h3>Description</h3>

<p>Solves a univariate mixed model of form <code class="reqn">y=X\beta+Mu+e</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>solveRRBLUP(y, X, M)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="solveRRBLUP_+3A_y">y</code></td>
<td>
<p>a matrix with n rows and 1 column</p>
</td></tr>
<tr><td><code id="solveRRBLUP_+3A_x">X</code></td>
<td>
<p>a matrix with n rows and x columns</p>
</td></tr>
<tr><td><code id="solveRRBLUP_+3A_m">M</code></td>
<td>
<p>a matrix with n rows and m columns</p>
</td></tr>
</table>

<hr>
<h2 id='solveRRBLUP_EM'>Solve RR-BLUP with EM</h2><span id='topic+solveRRBLUP_EM'></span>

<h3>Description</h3>

<p>Solves a univariate mixed model of form <code class="reqn">y=X\beta+Mu+e</code> using
the Expectation-Maximization algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>solveRRBLUP_EM(Y, X, M, Vu, Ve, tol, maxIter, useEM)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="solveRRBLUP_EM_+3A_y">Y</code></td>
<td>
<p>a matrix with n rows and 1 column</p>
</td></tr>
<tr><td><code id="solveRRBLUP_EM_+3A_x">X</code></td>
<td>
<p>a matrix with n rows and x columns</p>
</td></tr>
<tr><td><code id="solveRRBLUP_EM_+3A_m">M</code></td>
<td>
<p>a matrix with n rows and m columns</p>
</td></tr>
<tr><td><code id="solveRRBLUP_EM_+3A_vu">Vu</code></td>
<td>
<p>initial guess for variance of marker effects</p>
</td></tr>
<tr><td><code id="solveRRBLUP_EM_+3A_ve">Ve</code></td>
<td>
<p>initial guess for error variance</p>
</td></tr>
<tr><td><code id="solveRRBLUP_EM_+3A_tol">tol</code></td>
<td>
<p>tolerance for declaring convergence</p>
</td></tr>
<tr><td><code id="solveRRBLUP_EM_+3A_maxiter">maxIter</code></td>
<td>
<p>maximum iteration for attempting convergence</p>
</td></tr>
<tr><td><code id="solveRRBLUP_EM_+3A_useem">useEM</code></td>
<td>
<p>should EM algorithm be used. If false, no estimation of
variance components is performed. The initial values are treated as true.</p>
</td></tr>
</table>

<hr>
<h2 id='solveRRBLUP_EM2'>Solve RR-BLUP with EM and 2 random effects</h2><span id='topic+solveRRBLUP_EM2'></span>

<h3>Description</h3>

<p>Solves a univariate mixed model of form <code class="reqn">y=X\beta+M_1u_1+M_2u_2+e</code> using
the Expectation-Maximization algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>solveRRBLUP_EM2(Y, X, M1, M2, Vu1, Vu2, Ve, tol, maxIter, useEM)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="solveRRBLUP_EM2_+3A_y">Y</code></td>
<td>
<p>a matrix with n rows and 1 column</p>
</td></tr>
<tr><td><code id="solveRRBLUP_EM2_+3A_x">X</code></td>
<td>
<p>a matrix with n rows and x columns</p>
</td></tr>
<tr><td><code id="solveRRBLUP_EM2_+3A_m1">M1</code></td>
<td>
<p>a matrix with n rows and m1 columns</p>
</td></tr>
<tr><td><code id="solveRRBLUP_EM2_+3A_m2">M2</code></td>
<td>
<p>a matrix with n rows and m2 columns</p>
</td></tr>
<tr><td><code id="solveRRBLUP_EM2_+3A_vu1">Vu1</code></td>
<td>
<p>initial guess for variance of the first marker effects</p>
</td></tr>
<tr><td><code id="solveRRBLUP_EM2_+3A_vu2">Vu2</code></td>
<td>
<p>initial guess for variance of the second marker effects</p>
</td></tr>
<tr><td><code id="solveRRBLUP_EM2_+3A_ve">Ve</code></td>
<td>
<p>initial guess for error variance</p>
</td></tr>
<tr><td><code id="solveRRBLUP_EM2_+3A_tol">tol</code></td>
<td>
<p>tolerance for declaring convergence</p>
</td></tr>
<tr><td><code id="solveRRBLUP_EM2_+3A_maxiter">maxIter</code></td>
<td>
<p>maximum iteration for attempting convergence</p>
</td></tr>
<tr><td><code id="solveRRBLUP_EM2_+3A_useem">useEM</code></td>
<td>
<p>should EM algorithm be used. If false, no estimation of
variance components is performed. The initial values are treated as true.</p>
</td></tr>
</table>

<hr>
<h2 id='solveRRBLUP_EM3'>Solve RR-BLUP with EM and 3 random effects</h2><span id='topic+solveRRBLUP_EM3'></span>

<h3>Description</h3>

<p>Solves a univariate mixed model of form <code class="reqn">y=X\beta+M_1u_1+M_2u_2+M_3u_3+e</code> using
the Expectation-Maximization algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>solveRRBLUP_EM3(Y, X, M1, M2, M3, Vu1, Vu2, Vu3, Ve, tol, maxIter, useEM)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="solveRRBLUP_EM3_+3A_y">Y</code></td>
<td>
<p>a matrix with n rows and 1 column</p>
</td></tr>
<tr><td><code id="solveRRBLUP_EM3_+3A_x">X</code></td>
<td>
<p>a matrix with n rows and x columns</p>
</td></tr>
<tr><td><code id="solveRRBLUP_EM3_+3A_m1">M1</code></td>
<td>
<p>a matrix with n rows and m1 columns</p>
</td></tr>
<tr><td><code id="solveRRBLUP_EM3_+3A_m2">M2</code></td>
<td>
<p>a matrix with n rows and m2 columns</p>
</td></tr>
<tr><td><code id="solveRRBLUP_EM3_+3A_m3">M3</code></td>
<td>
<p>a matrix with n rows and m3 columns</p>
</td></tr>
<tr><td><code id="solveRRBLUP_EM3_+3A_vu1">Vu1</code></td>
<td>
<p>initial guess for variance of the first marker effects</p>
</td></tr>
<tr><td><code id="solveRRBLUP_EM3_+3A_vu2">Vu2</code></td>
<td>
<p>initial guess for variance of the second marker effects</p>
</td></tr>
<tr><td><code id="solveRRBLUP_EM3_+3A_vu3">Vu3</code></td>
<td>
<p>initial guess for variance of the second marker effects</p>
</td></tr>
<tr><td><code id="solveRRBLUP_EM3_+3A_ve">Ve</code></td>
<td>
<p>initial guess for error variance</p>
</td></tr>
<tr><td><code id="solveRRBLUP_EM3_+3A_tol">tol</code></td>
<td>
<p>tolerance for declaring convergence</p>
</td></tr>
<tr><td><code id="solveRRBLUP_EM3_+3A_maxiter">maxIter</code></td>
<td>
<p>maximum iteration for attempting convergence</p>
</td></tr>
<tr><td><code id="solveRRBLUP_EM3_+3A_useem">useEM</code></td>
<td>
<p>should EM algorithm be used. If false, no estimation of
variance components is performed. The initial values are treated as true.</p>
</td></tr>
</table>

<hr>
<h2 id='solveRRBLUPMK'>Solve Multikernel RR-BLUP</h2><span id='topic+solveRRBLUPMK'></span>

<h3>Description</h3>

<p>Solves a univariate mixed model with multiple random effects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>solveRRBLUPMK(y, X, Mlist, maxIter = 40L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="solveRRBLUPMK_+3A_y">y</code></td>
<td>
<p>a matrix with n rows and 1 column</p>
</td></tr>
<tr><td><code id="solveRRBLUPMK_+3A_x">X</code></td>
<td>
<p>a matrix with n rows and x columns</p>
</td></tr>
<tr><td><code id="solveRRBLUPMK_+3A_mlist">Mlist</code></td>
<td>
<p>a list of M matrices</p>
</td></tr>
<tr><td><code id="solveRRBLUPMK_+3A_maxiter">maxIter</code></td>
<td>
<p>maximum number of iteration</p>
</td></tr>
</table>

<hr>
<h2 id='solveRRBLUPMV'>Solve Multivariate RR-BLUP</h2><span id='topic+solveRRBLUPMV'></span>

<h3>Description</h3>

<p>Solves a multivariate mixed model of form <code class="reqn">Y=X\beta+Mu+e</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>solveRRBLUPMV(Y, X, M, maxIter = 1000L, tol = 1e-06)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="solveRRBLUPMV_+3A_y">Y</code></td>
<td>
<p>a matrix with n rows and q columns</p>
</td></tr>
<tr><td><code id="solveRRBLUPMV_+3A_x">X</code></td>
<td>
<p>a matrix with n rows and x columns</p>
</td></tr>
<tr><td><code id="solveRRBLUPMV_+3A_m">M</code></td>
<td>
<p>a matrix with n rows and m columns</p>
</td></tr>
<tr><td><code id="solveRRBLUPMV_+3A_maxiter">maxIter</code></td>
<td>
<p>maximum number of iteration</p>
</td></tr>
<tr><td><code id="solveRRBLUPMV_+3A_tol">tol</code></td>
<td>
<p>tolerance for convergence</p>
</td></tr>
</table>

<hr>
<h2 id='solveUVM'>Solve Univariate Model</h2><span id='topic+solveUVM'></span>

<h3>Description</h3>

<p>Solves a univariate mixed model of form <code class="reqn">y=X\beta+Zu+e</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>solveUVM(y, X, Z, K)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="solveUVM_+3A_y">y</code></td>
<td>
<p>a matrix with n rows and 1 column</p>
</td></tr>
<tr><td><code id="solveUVM_+3A_x">X</code></td>
<td>
<p>a matrix with n rows and x columns</p>
</td></tr>
<tr><td><code id="solveUVM_+3A_z">Z</code></td>
<td>
<p>a matrix with n rows and m columns</p>
</td></tr>
<tr><td><code id="solveUVM_+3A_k">K</code></td>
<td>
<p>a matrix with m rows and m columns</p>
</td></tr>
</table>

<hr>
<h2 id='TraitA-class'>Additive trait</h2><span id='topic+TraitA-class'></span>

<h3>Description</h3>

<p>Extends <code><a href="#topic+LociMap-class">LociMap-class</a></code>
to model additive traits
</p>


<h3>Slots</h3>


<dl>
<dt><code>addEff</code></dt><dd><p>additive effects</p>
</dd>
<dt><code>intercept</code></dt><dd><p>adjustment factor for gv</p>
</dd>
</dl>

<hr>
<h2 id='TraitA2-class'>Sex specific additive trait</h2><span id='topic+TraitA2-class'></span>

<h3>Description</h3>

<p>Extends <code><a href="#topic+TraitA-class">TraitA-class</a></code>
to model seperate additive effects for parent of
origin. Used exclusively for genomic selection.
</p>


<h3>Slots</h3>


<dl>
<dt><code>addEffMale</code></dt><dd><p>additive effects</p>
</dd>
</dl>

<hr>
<h2 id='TraitA2D-class'>Sex specific additive and dominance trait</h2><span id='topic+TraitA2D-class'></span>

<h3>Description</h3>

<p>Extends <code><a href="#topic+TraitA2-class">TraitA2-class</a></code>
to add dominance
</p>


<h3>Slots</h3>


<dl>
<dt><code>domEff</code></dt><dd><p>dominance effects</p>
</dd>
</dl>

<hr>
<h2 id='TraitAD-class'>Additive and dominance trait</h2><span id='topic+TraitAD-class'></span>

<h3>Description</h3>

<p>Extends <code><a href="#topic+TraitA-class">TraitA-class</a></code>
to add dominance
</p>


<h3>Slots</h3>


<dl>
<dt><code>domEff</code></dt><dd><p>dominance effects</p>
</dd>
</dl>

<hr>
<h2 id='TraitADE-class'>Additive, dominance, and epistatic trait</h2><span id='topic+TraitADE-class'></span>

<h3>Description</h3>

<p>Extends <code><a href="#topic+TraitAD-class">TraitAD-class</a></code>
to add epistasis
</p>


<h3>Slots</h3>


<dl>
<dt><code>epiEff</code></dt><dd><p>epistatic effects</p>
</dd>
</dl>

<hr>
<h2 id='TraitADEG-class'>Additive, dominance, epistasis, and GxE trait</h2><span id='topic+TraitADEG-class'></span>

<h3>Description</h3>

<p>Extends <code><a href="#topic+TraitADE-class">TraitADE-class</a></code>
to add GxE effects
</p>


<h3>Slots</h3>


<dl>
<dt><code>gxeEff</code></dt><dd><p>GxE effects</p>
</dd>
<dt><code>gxeInt</code></dt><dd><p>GxE intercept</p>
</dd>
<dt><code>envVar</code></dt><dd><p>Environmental variance</p>
</dd>
</dl>

<hr>
<h2 id='TraitADG-class'>Additive, dominance and GxE trait</h2><span id='topic+TraitADG-class'></span>

<h3>Description</h3>

<p>Extends <code><a href="#topic+TraitAD-class">TraitAD-class</a></code>
to add GxE effects
</p>


<h3>Slots</h3>


<dl>
<dt><code>gxeEff</code></dt><dd><p>GxE effects</p>
</dd>
<dt><code>gxeInt</code></dt><dd><p>GxE intercept</p>
</dd>
<dt><code>envVar</code></dt><dd><p>Environmental variance</p>
</dd>
</dl>

<hr>
<h2 id='TraitAE-class'>Additive and epistatic trait</h2><span id='topic+TraitAE-class'></span>

<h3>Description</h3>

<p>Extends <code><a href="#topic+TraitA-class">TraitA-class</a></code>
to add epistasis
</p>


<h3>Slots</h3>


<dl>
<dt><code>epiEff</code></dt><dd><p>epistatic effects</p>
</dd>
</dl>

<hr>
<h2 id='TraitAEG-class'>Additive, epistasis and GxE trait</h2><span id='topic+TraitAEG-class'></span>

<h3>Description</h3>

<p>Extends <code><a href="#topic+TraitAE-class">TraitAE-class</a></code>
to add GxE effects
</p>


<h3>Slots</h3>


<dl>
<dt><code>gxeEff</code></dt><dd><p>GxE effects</p>
</dd>
<dt><code>gxeInt</code></dt><dd><p>GxE intercept</p>
</dd>
<dt><code>envVar</code></dt><dd><p>Environmental variance</p>
</dd>
</dl>

<hr>
<h2 id='TraitAG-class'>Additive and GxE trait</h2><span id='topic+TraitAG-class'></span>

<h3>Description</h3>

<p>Extends <code><a href="#topic+TraitA-class">TraitA-class</a></code>
to add GxE effects
</p>


<h3>Slots</h3>


<dl>
<dt><code>gxeEff</code></dt><dd><p>GxE effects</p>
</dd>
<dt><code>gxeInt</code></dt><dd><p>GxE intercept</p>
</dd>
<dt><code>envVar</code></dt><dd><p>Environmental variance</p>
</dd>
</dl>

<hr>
<h2 id='transMat'>Linear transformation matrix</h2><span id='topic+transMat'></span>

<h3>Description</h3>

<p>Creates an m by m linear transformation matrix that 
can be applied to n by m uncorrelated deviates 
sampled from a standard normal distribution to produce
correlated deviates with an arbitrary correlation 
of R. If R is not positive semi-definite, the function 
returns smoothing and returns a warning (see details).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>transMat(R)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="transMat_+3A_r">R</code></td>
<td>
<p>a correlation matrix</p>
</td></tr>
</table>


<h3>Details</h3>

<p>An eigendecomposition is applied to the correlation 
matrix and used to test if it is positive semi-definite. 
If the matrix is not positive semi-definite, it is not a 
valid correlation matrix. In this case, smoothing is 
applied to the matrix (as described in the 'cor.smooth' of 
the 'psych' library) to obtain a valid correlation matrix. 
The resulting deviates will thus not exactly match the 
desired correlation, but will hopefully be close if the 
input matrix wasn't too far removed from a valid 
correlation matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create an 2x2 correlation matrix
R = 0.5*diag(2) + 0.5

# Sample 1000 uncorrelated deviates from a 
# bivariate standard normal distribution
X = matrix(rnorm(2*1000), ncol=2)

# Compute the transformation matrix
T = transMat(R)

# Apply the transformation to the deviates
Y = X%*%T

# Measure the sample correlation
cor(Y)

</code></pre>

<hr>
<h2 id='usefulness'>Usefulness criterion</h2><span id='topic+usefulness'></span>

<h3>Description</h3>

<p>Calculates the usefulness criterion
</p>


<h3>Usage</h3>

<pre><code class='language-R'>usefulness(
  pop,
  trait = 1,
  use = "gv",
  p = 0.1,
  selectTop = TRUE,
  simParam = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="usefulness_+3A_pop">pop</code></td>
<td>
<p>and object of <code><a href="#topic+Pop-class">Pop-class</a></code> or 
<code><a href="#topic+HybridPop-class">HybridPop-class</a></code></p>
</td></tr>
<tr><td><code id="usefulness_+3A_trait">trait</code></td>
<td>
<p>the trait for selection. Either a number indicating 
a single trait or a function returning a vector of length nInd.</p>
</td></tr>
<tr><td><code id="usefulness_+3A_use">use</code></td>
<td>
<p>select on genetic values (<code>gv</code>, default), estimated
breeding values (<code>ebv</code>), breeding values (<code>bv</code>), 
or phenotypes (<code>pheno</code>)</p>
</td></tr>
<tr><td><code id="usefulness_+3A_p">p</code></td>
<td>
<p>the proportion of individuals selected</p>
</td></tr>
<tr><td><code id="usefulness_+3A_selecttop">selectTop</code></td>
<td>
<p>selects highest values if true. 
Selects lowest values if false.</p>
</td></tr>
<tr><td><code id="usefulness_+3A_simparam">simParam</code></td>
<td>
<p>an object of <code><a href="#topic+SimParam">SimParam</a></code></p>
</td></tr>
<tr><td><code id="usefulness_+3A_...">...</code></td>
<td>
<p>additional arguments if using a function for 
trait</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a numeric value
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Create founder haplotypes
founderPop = quickHaplo(nInd=2, nChr=1, segSites=10)

#Set simulation parameters
SP = SimParam$new(founderPop)

SP$addTraitA(10)

#Create population
pop = newPop(founderPop, simParam=SP)

#Determine usefulness of population 
usefulness(pop, simParam=SP)

#Should be equivalent to GV of best individual
max(gv(pop))

</code></pre>

<hr>
<h2 id='varA'>Additive variance</h2><span id='topic+varA'></span>

<h3>Description</h3>

<p>Returns additive variance for all traits
</p>


<h3>Usage</h3>

<pre><code class='language-R'>varA(pop, simParam = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="varA_+3A_pop">pop</code></td>
<td>
<p>an object of <code><a href="#topic+Pop-class">Pop-class</a></code></p>
</td></tr>
<tr><td><code id="varA_+3A_simparam">simParam</code></td>
<td>
<p>an object of <code><a href="#topic+SimParam">SimParam</a></code></p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>#Create founder haplotypes
founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)

#Set simulation parameters
SP = SimParam$new(founderPop)
SP$addTraitAD(10, meanDD=0.5)
SP$setVarE(h2=0.5)


#Create population
pop = newPop(founderPop, simParam=SP)
varA(pop, simParam=SP)

</code></pre>

<hr>
<h2 id='varAA'>Additive-by-additive epistatic variance</h2><span id='topic+varAA'></span>

<h3>Description</h3>

<p>Returns additive-by-additive epistatic
variance for all traits
</p>


<h3>Usage</h3>

<pre><code class='language-R'>varAA(pop, simParam = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="varAA_+3A_pop">pop</code></td>
<td>
<p>an object of <code><a href="#topic+Pop-class">Pop-class</a></code></p>
</td></tr>
<tr><td><code id="varAA_+3A_simparam">simParam</code></td>
<td>
<p>an object of <code><a href="#topic+SimParam">SimParam</a></code></p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>#Create founder haplotypes
founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)

#Set simulation parameters
SP = SimParam$new(founderPop)
SP$addTraitAD(10, meanDD=0.5)
SP$setVarE(h2=0.5)


#Create population
pop = newPop(founderPop, simParam=SP)
varAA(pop, simParam=SP)

</code></pre>

<hr>
<h2 id='varD'>Dominance variance</h2><span id='topic+varD'></span>

<h3>Description</h3>

<p>Returns dominance variance for all traits
</p>


<h3>Usage</h3>

<pre><code class='language-R'>varD(pop, simParam = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="varD_+3A_pop">pop</code></td>
<td>
<p>an object of <code><a href="#topic+Pop-class">Pop-class</a></code></p>
</td></tr>
<tr><td><code id="varD_+3A_simparam">simParam</code></td>
<td>
<p>an object of <code><a href="#topic+SimParam">SimParam</a></code></p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>#Create founder haplotypes
founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)

#Set simulation parameters
SP = SimParam$new(founderPop)
SP$addTraitAD(10, meanDD=0.5)
SP$setVarE(h2=0.5)


#Create population
pop = newPop(founderPop, simParam=SP)
varD(pop, simParam=SP)

</code></pre>

<hr>
<h2 id='varG'>Total genetic variance</h2><span id='topic+varG'></span>

<h3>Description</h3>

<p>Returns total genetic variance for all traits
</p>


<h3>Usage</h3>

<pre><code class='language-R'>varG(pop)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="varG_+3A_pop">pop</code></td>
<td>
<p>an object of <code><a href="#topic+Pop-class">Pop-class</a></code> or <code><a href="#topic+HybridPop-class">HybridPop-class</a></code></p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>#Create founder haplotypes
founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)

#Set simulation parameters
SP = SimParam$new(founderPop)
SP$addTraitA(10)
SP$setVarE(h2=0.5)


#Create population
pop = newPop(founderPop, simParam=SP)
varG(pop)

</code></pre>

<hr>
<h2 id='varP'>Phenotypic variance</h2><span id='topic+varP'></span>

<h3>Description</h3>

<p>Returns phenotypic variance for all traits
</p>


<h3>Usage</h3>

<pre><code class='language-R'>varP(pop)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="varP_+3A_pop">pop</code></td>
<td>
<p>an object of <code><a href="#topic+Pop-class">Pop-class</a></code> or <code><a href="#topic+HybridPop-class">HybridPop-class</a></code></p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>#Create founder haplotypes
founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)

#Set simulation parameters
SP = SimParam$new(founderPop)
SP$addTraitA(10)
SP$setVarE(h2=0.5)


#Create population
pop = newPop(founderPop, simParam=SP)
varP(pop)

</code></pre>

<hr>
<h2 id='writePlink'>Writes a Pop-class as PLINK files</h2><span id='topic+writePlink'></span>

<h3>Description</h3>

<p>Writes a Pop-class to PLINK PED and MAP files. The arguments 
for this function were chosen for consistency with 
<code><a href="#topic+RRBLUP2">RRBLUP2</a></code>. The base pair coordinate will the locus
position as stored in AlphaSimR and not an actual base pair 
position. This is because AlphaSimR doesn't track base pair 
positions, only relative positions for the loci used in the 
simulation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>writePlink(
  pop,
  baseName,
  traits = 1,
  use = "pheno",
  snpChip = 1,
  useQtl = FALSE,
  simParam = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="writePlink_+3A_pop">pop</code></td>
<td>
<p>an object of <code><a href="#topic+Pop-class">Pop-class</a></code></p>
</td></tr>
<tr><td><code id="writePlink_+3A_basename">baseName</code></td>
<td>
<p>basename for PED and MAP files.</p>
</td></tr>
<tr><td><code id="writePlink_+3A_traits">traits</code></td>
<td>
<p>an integer indicating the trait to write, a trait name, or a
function of the traits returning a single value.</p>
</td></tr>
<tr><td><code id="writePlink_+3A_use">use</code></td>
<td>
<p>what to use for PLINK's phenotype field. Either phenotypes &quot;pheno&quot;, 
genetic values &quot;gv&quot;, estimated breeding values &quot;ebv&quot;, breeding values &quot;bv&quot;, 
or random values &quot;rand&quot;.</p>
</td></tr>
<tr><td><code id="writePlink_+3A_snpchip">snpChip</code></td>
<td>
<p>an integer indicating which SNP chip genotype 
to use</p>
</td></tr>
<tr><td><code id="writePlink_+3A_useqtl">useQtl</code></td>
<td>
<p>should QTL genotypes be used instead of a SNP chip. 
If TRUE, snpChip specifies which trait's QTL to use, and thus these 
QTL may not match the QTL underlying the phenotype supplied in traits.</p>
</td></tr>
<tr><td><code id="writePlink_+3A_simparam">simParam</code></td>
<td>
<p>an object of <code><a href="#topic+SimParam">SimParam</a></code></p>
</td></tr>
<tr><td><code id="writePlink_+3A_...">...</code></td>
<td>
<p>additional arguments if using a function for 
traits</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#Create founder haplotypes
founderPop = quickHaplo(nInd=10, nChr=1, segSites=15)

#Set simulation parameters
SP = SimParam$new(founderPop)
\dontshow{SP$nThreads = 1L}
SP$setSexes(sex="yes_rand")
SP$addTraitA(nQtlPerChr=10)
SP$addSnpChip(nSnpPerChr=5)
SP$setVarE(h2=0.5)

#Create population
pop = newPop(rawPop = founderPop)

# Write out PLINK files
writePlink(pop, baseName="test")

## End(Not run)
</code></pre>

<hr>
<h2 id='writeRecords'>Write data records</h2><span id='topic+writeRecords'></span>

<h3>Description</h3>

<p>Saves a population's phenotypic and marker data to a directory.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>writeRecords(
  pop,
  dir,
  snpChip = 1,
  useQtl = FALSE,
  includeHaplo = FALSE,
  append = TRUE,
  simParam = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="writeRecords_+3A_pop">pop</code></td>
<td>
<p>an object of <code><a href="#topic+Pop-class">Pop-class</a></code></p>
</td></tr>
<tr><td><code id="writeRecords_+3A_dir">dir</code></td>
<td>
<p>path to a directory for saving output</p>
</td></tr>
<tr><td><code id="writeRecords_+3A_snpchip">snpChip</code></td>
<td>
<p>which SNP chip genotype to save. If useQtl=TRUE, this
value will indicate which trait's QTL genotype to save. A value of
0 will skip writing a snpChip.</p>
</td></tr>
<tr><td><code id="writeRecords_+3A_useqtl">useQtl</code></td>
<td>
<p>should QTL genotype be written instead of SNP chip
genotypes.</p>
</td></tr>
<tr><td><code id="writeRecords_+3A_includehaplo">includeHaplo</code></td>
<td>
<p>should markers be separated by female and male
haplotypes.</p>
</td></tr>
<tr><td><code id="writeRecords_+3A_append">append</code></td>
<td>
<p>if true, new records are added to any existing records.
If false, any existing records are deleted before writing new records.
Note that this will delete all files in the 'dir' directory.</p>
</td></tr>
<tr><td><code id="writeRecords_+3A_simparam">simParam</code></td>
<td>
<p>an object of <code><a href="#topic+SimParam">SimParam</a></code></p>
</td></tr>
</table>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
