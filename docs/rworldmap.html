<!DOCTYPE html><html><head><title>Help for package rworldmap</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {rworldmap}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#addMapLegend'><p>Add a legend to a map</p></a></li>
<li><a href='#addMapLegendBoxes'><p>Add a legend of coloured boxes to a map</p></a></li>
<li><a href='#aggregateHalfDegreeGridToCountries'><p>Aggregates global half degree gridded data to countries</p></a></li>
<li><a href='#barplotCountryData'><p>Barplot country-level data.</p></a></li>
<li><a href='#coastsCoarse'><p>A map of world coasts at coarse resolution.</p></a></li>
<li><a href='#countriesCoarse'><p>a coarse resolution world map, a vector map of 244 country</p>
boundaries,suitable for global maps</a></li>
<li><a href='#countriesCoarseLessIslands'><p>a coarse resolution world map, a vector map of 177 country boundaries,</p>
suitable for global maps</a></li>
<li><a href='#countriesLow'><p>a low resolution world map, a vector map of 244 country boundaries, suitable</p>
for zooming in on regions or large global maps</a></li>
<li><a href='#country2Region'><p>Produce regional data from country level data</p></a></li>
<li><a href='#countryExData'><p>Example dataset for country level data (2008 Environmental Performance</p>
Index)</a></li>
<li><a href='#countryRegions'><p>Regional Classification Table</p></a></li>
<li><a href='#countrySynonyms'><p>Synonyms of country names for each ISO 3 letter country code to enable</p>
conversion.</a></li>
<li><a href='#getMap'><p>A simple way to access maps stored in the package.</p></a></li>
<li><a href='#gridCountriesDegreesHalf'><p>A gloabl half degree grid specifying the country at each cell</p></a></li>
<li><a href='#gridCountriesNumeric'><p>A gloabl half degree grid specifying the country at each cell</p></a></li>
<li><a href='#gridExData'><p>Example half degree grid data : population estimates for 2000 from IIASA</p></a></li>
<li><a href='#identifyCountries'><p>a function that will print country name and attribute values when a user</p>
clicks on the map</a></li>
<li><a href='#isoToName'><p>Returns the country name corresponding to the passed iso code (3 letter, 2</p>
letter or numeric).</a></li>
<li><a href='#joinCountryData2Map'><p>Joins user country referenced data to a map</p></a></li>
<li><a href='#joinData2Map'><p>Joins user polygon attribute data to a map</p></a></li>
<li><a href='#labelCountries'><p>to print country labels on a world map</p></a></li>
<li><a href='#mapBars'><p>function to produce bar plots on a map</p></a></li>
<li><a href='#mapBubbles'><p>function to produce bubble plots on a map, size and colour determined by</p>
attribute data</a></li>
<li><a href='#mapByRegion'><p>Produce maps of regional level data from country level data</p></a></li>
<li><a href='#mapCountryData'><p>Map country-level data.</p></a></li>
<li><a href='#mapDevice'><p>Creates a plot device set up for maps</p></a></li>
<li><a href='#mapGriddedData'><p>Produce maps of global gridded data at half degree resolution</p></a></li>
<li><a href='#mapHalfDegreeGridToCountries'><p>Maps user half degree gridded data at country level by first aggregating.</p></a></li>
<li><a href='#mapPies'><p>function to produce pie charts on a map</p></a></li>
<li><a href='#mapPolys'><p>Map polygon data.</p></a></li>
<li><a href='#rwmCheckAndLoadInput'><p>internal function to check and load input data to mapping functions</p></a></li>
<li><a href='#rwmGetClassBreaks'><p>Internal function to set the numeric values for the breaks between data</p>
categories</a></li>
<li><a href='#rwmGetColours'><p>to choose map colours for classified data</p></a></li>
<li><a href='#rwmGetISO3'><p>Internal function for getting the ISO3 country code for a country name</p>
synonymn.</a></li>
<li><a href='#rwmNewMapPlot'><p>Internal function to set up an existing device for plotting maps</p></a></li>
<li><a href='#rworldmap-package'><p>For mapping global data.</p></a></li>
<li><a href='#rworldmapExamples'><p>Example code for plot creation</p></a></li>
<li><a href='#setMapExtents'><p>Internal function allowing map extents to be set from area names</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Mapping Global Data</td>
</tr>
<tr>
<td>Version:</td>
<td>1.3-8</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-10-15</td>
</tr>
<tr>
<td>Description:</td>
<td>Enables mapping of country level and gridded user datasets.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10.0), sp</td>
</tr>
<tr>
<td>Imports:</td>
<td>fields, methods, raster, terra</td>
</tr>
<tr>
<td>Suggests:</td>
<td>rworldxtra, RColorBrewer, classInt, sf</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/AndySouth/rworldmap/">https://github.com/AndySouth/rworldmap/</a>,
<a href="https://groups.google.com/forum/#!forum/rworldmap">https://groups.google.com/forum/#!forum/rworldmap</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/AndySouth/rworldmap/issues">https://github.com/AndySouth/rworldmap/issues</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-10-15 10:51:33 UTC; rsb</td>
</tr>
<tr>
<td>Author:</td>
<td>Andy South <a href="https://orcid.org/0000-0003-4051-6135"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut,
    cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Andy South &lt;southandy@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-10-16 09:40:38 UTC</td>
</tr>
</table>
<hr>
<h2 id='addMapLegend'>Add a legend to a map</h2><span id='topic+addMapLegend'></span>

<h3>Description</h3>

<p>Creates a colour bar legend, showing the range of colours and the values the
colours correspond to. Relies heavily on image.plot() from the package
fields. For simple use, simply use addLegend=TRUE in a rworldmap map
function. Or users can call addMapLegend seperately to fine tune the legend.
The user should insure that data, catMethod,numCats and colourPalette match
the values used in the plot.  The legend is designed to be useful for the
variety of classification methods that exist.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>addMapLegend(
  colourVector = "",
  cutVector = "",
  legendLabels = "limits",
  labelFontSize = 1,
  legendWidth = 1.2,
  legendShrink = 0.9,
  legendMar = 3,
  horizontal = TRUE,
  legendArgs = NULL,
  tcl = -0.5,
  mgp = c(3, 1, 0),
  sigFigs = 4,
  digits = 3,
  legendIntervals = "data",
  plottedData = "",
  catMethod = "pretty",
  colourPalette = "heat"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="addMapLegend_+3A_colourvector">colourVector</code></td>
<td>
<p>colours used in the map</p>
</td></tr>
<tr><td><code id="addMapLegend_+3A_cutvector">cutVector</code></td>
<td>
<p>the categories or breaks used in the map</p>
</td></tr>
<tr><td><code id="addMapLegend_+3A_legendlabels">legendLabels</code></td>
<td>
<p>Controls the style of the labels on the legend. Choose
&quot;none&quot; for no labels, &quot;limits&quot; for the two end values, and &quot;all&quot; to show all
the break values if they fit.</p>
</td></tr>
<tr><td><code id="addMapLegend_+3A_labelfontsize">labelFontSize</code></td>
<td>
<p>Controls font size of the labels. A multiplier, so use
2 to double the size, 0.5 to halve it, etc.</p>
</td></tr>
<tr><td><code id="addMapLegend_+3A_legendwidth">legendWidth</code></td>
<td>
<p>Controls the width of the colour bar.</p>
</td></tr>
<tr><td><code id="addMapLegend_+3A_legendshrink">legendShrink</code></td>
<td>
<p>Controls the length of the colour bar. 1 means full
width of the plot.</p>
</td></tr>
<tr><td><code id="addMapLegend_+3A_legendmar">legendMar</code></td>
<td>
<p>Moves the legend away from the side of the plot. Measured
in character widths.</p>
</td></tr>
<tr><td><code id="addMapLegend_+3A_horizontal">horizontal</code></td>
<td>
<p>If TRUE the legend is horizontal, if FALSE, vertical.</p>
</td></tr>
<tr><td><code id="addMapLegend_+3A_legendargs">legendArgs</code></td>
<td>
<p>For producing titles and labels. A list of arguments to be
passed to mtext.</p>
</td></tr>
<tr><td><code id="addMapLegend_+3A_tcl">tcl</code></td>
<td>
<p>Controls the length of the tick marks.Useful when labelFontSize
is changed.</p>
</td></tr>
<tr><td><code id="addMapLegend_+3A_mgp">mgp</code></td>
<td>
<p>Numeric vector length 3. The second element controls the distance
between labels and the axis. Useful when labelFontSize is changed.</p>
</td></tr>
<tr><td><code id="addMapLegend_+3A_sigfigs">sigFigs</code></td>
<td>
<p>The number of significant figures for legend labels.</p>
</td></tr>
<tr><td><code id="addMapLegend_+3A_digits">digits</code></td>
<td>
<p>An argument to the formatting of the labels</p>
</td></tr>
<tr><td><code id="addMapLegend_+3A_legendintervals">legendIntervals</code></td>
<td>
<p>&quot;page&quot; or &quot;data&quot;. Controls the division of the colour
bar, &quot;page&quot; sets the intervals equal on the page, &quot;data&quot; sets them to be
equal in the units of the data.</p>
</td></tr>
<tr><td><code id="addMapLegend_+3A_plotteddata">plottedData</code></td>
<td>
<p>unused but are passed with mapParams</p>
</td></tr>
<tr><td><code id="addMapLegend_+3A_catmethod">catMethod</code></td>
<td>
<p>unused but are passed with mapParams</p>
</td></tr>
<tr><td><code id="addMapLegend_+3A_colourpalette">colourPalette</code></td>
<td>
<p>unused but are passed with mapParams</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The default legend is a horizontal colour bar, with labels only at the
extremes.
</p>
<p>Can use a parameter list returned from mapping functions, e.g.
mapCountryData(). mapCountryData(addLegend=TRUE) produces same results as:
mapParams &lt;- mapCountryData(addLegend=FALSE) do.call(addMapLegend,
mapParams)
</p>
<p>Using the following allows the modification of the legend : mapParams &lt;-
mapCountryData(addLegend=FALSE) do.call(addMapLegend, c(mapParams,
legendLabels=&quot;all&quot;, legendWidth=0.5))
</p>


<h3>Value</h3>

<p>Adds a legend to a plot.
</p>


<h3>Note</h3>

<p>Can have the unintentional effect of modifying graphical parameters,
e.g. mfcol reverts to mfrow.
</p>


<h3>Author(s)</h3>

<p>Andy South
</p>


<h3>See Also</h3>

<p>mapCountryData, mapGriddedData, image.plot
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#Set up the plot so the world map uses the full width.
mapDevice() 
#join eaxmple data to a map  
data("countryExData",envir=environment())
sPDF &lt;- joinCountryData2Map(countryExData
              , joinCode = "ISO3"
              , nameJoinColumn = "ISO3V10"
              )
#map the data with no legend              
mapParams &lt;- mapCountryData( sPDF
              , nameColumnToPlot="BIODIVERSITY"
              , addLegend='FALSE' 
              )
              
#add a modified legend using the same initial parameters as mapCountryData               
do.call( addMapLegend, c( mapParams
                        , legendLabels="all"
                        , legendWidth=0.5
                        ))




</code></pre>

<hr>
<h2 id='addMapLegendBoxes'>Add a legend of coloured boxes to a map</h2><span id='topic+addMapLegendBoxes'></span>

<h3>Description</h3>

<p>Creates a colour box legend, showing the range of colours and the values the
colours correspond to. This works well for categorical data with relatively
few categories.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>addMapLegendBoxes(
  cutVector = "",
  colourVector = "",
  x = "bottomleft",
  horiz = FALSE,
  title = "category",
  cex = 1,
  pt.cex = 2,
  col = "gray",
  bg = "white",
  legendText = "",
  catMethod = "categorical",
  plottedData = "",
  colourPalette = "heat",
  sigFigs = 2,
  missingCountryCol = "white",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="addMapLegendBoxes_+3A_cutvector">cutVector</code></td>
<td>
<p>the categories or breaks used in the map</p>
</td></tr>
<tr><td><code id="addMapLegendBoxes_+3A_colourvector">colourVector</code></td>
<td>
<p>colours used in the map</p>
</td></tr>
<tr><td><code id="addMapLegendBoxes_+3A_x">x</code></td>
<td>
<p>positioning of legend e.g. 'bottomleft', 'topright'</p>
</td></tr>
<tr><td><code id="addMapLegendBoxes_+3A_horiz">horiz</code></td>
<td>
<p>if TRUE horizontal legend</p>
</td></tr>
<tr><td><code id="addMapLegendBoxes_+3A_title">title</code></td>
<td>
<p>title for Legend</p>
</td></tr>
<tr><td><code id="addMapLegendBoxes_+3A_cex">cex</code></td>
<td>
<p>controls the font size, default is 1</p>
</td></tr>
<tr><td><code id="addMapLegendBoxes_+3A_pt.cex">pt.cex</code></td>
<td>
<p>controls size of colour boxes relative to cex, default is 2</p>
</td></tr>
<tr><td><code id="addMapLegendBoxes_+3A_col">col</code></td>
<td>
<p>colour for boundary of colour boxes, default is &quot;gray&quot;</p>
</td></tr>
<tr><td><code id="addMapLegendBoxes_+3A_bg">bg</code></td>
<td>
<p>colour for legend background, default is &quot;white&quot;, NA makes the
legend background transparent</p>
</td></tr>
<tr><td><code id="addMapLegendBoxes_+3A_legendtext">legendText</code></td>
<td>
<p>the text to put against each legend box, if left blank
cutVector is used, needs to be a vector the same length as length cutVector</p>
</td></tr>
<tr><td><code id="addMapLegendBoxes_+3A_catmethod">catMethod</code></td>
<td>
<p>the categorisation method used influences what text added
to legend elements, for 'categorical' just the category names are used for
other options limits are used</p>
</td></tr>
<tr><td><code id="addMapLegendBoxes_+3A_plotteddata">plottedData</code></td>
<td>
<p>not used yet but maybe in future</p>
</td></tr>
<tr><td><code id="addMapLegendBoxes_+3A_colourpalette">colourPalette</code></td>
<td>
<p>not used yet but maybe in future</p>
</td></tr>
<tr><td><code id="addMapLegendBoxes_+3A_sigfigs">sigFigs</code></td>
<td>
<p>not used yet but maybe in future</p>
</td></tr>
<tr><td><code id="addMapLegendBoxes_+3A_missingcountrycol">missingCountryCol</code></td>
<td>
<p>not used yet but maybe in future</p>
</td></tr>
<tr><td><code id="addMapLegendBoxes_+3A_...">...</code></td>
<td>
<p>to allow other params to be set in legend</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This creates a legend with separate boxes of colour rather than
addMapLegend() which creates a colour bar. This method is used as the
default for categorical data.
</p>
<p>See the examples for how to use a parameter list returned from mapping
functions.
</p>


<h3>Value</h3>

<p>Adds a legend to a plot.
</p>


<h3>Author(s)</h3>

<p>Andy South
</p>


<h3>See Also</h3>

<p>addMapLegend, mapCountryData, mapGriddedData
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#Set up the plot so the world map uses the full width.
mapDevice() 
#map example categorical data with no legend              
mapParams &lt;- mapCountryData(nameColumnToPlot='GEO3major'
              , catMethod='categorical'
              , addLegend='FALSE' 
              )
              
#add default legend using the same parameters as mapCountryData               
do.call( addMapLegendBoxes, c( mapParams))

#adding a modified legend by specifying extra parameters               
do.call( addMapLegendBoxes, c(mapParams,x='bottom',horiz=TRUE,title="Region"))

#user defined map colour sceme              
mapParams &lt;- mapCountryData(nameColumnToPlot='GEO3major'
              , catMethod='categorical'
              , addLegend='FALSE'
              , colourPalette=c('white','green','red','yellow','blue','black') 
              )
#changing legendText
mapParams$legendText &lt;- c('antarctic','africa','oceania'
                         ,'americas','s.asia','eurasia')              
do.call( addMapLegendBoxes, c(mapParams,x='bottom',title="Region",horiz=TRUE))

#or this way
#do.call( addMapLegendBoxes
#        , c(mapParams
#           ,list(legendText=c('antarctic','africa','oceania'
#                              ,'americas','s.asia','eurasia')
#                ,x='bottom',title="Region",horiz=TRUE)))



</code></pre>

<hr>
<h2 id='aggregateHalfDegreeGridToCountries'>Aggregates global half degree gridded data to countries</h2><span id='topic+aggregateHalfDegreeGridToCountries'></span>

<h3>Description</h3>

<p>Aggregates global half degree gridded data to countries (options for sum,
mean, min, max ). Uses a very simple grid map defining a single country
identity for each half degree cell.  (other more sophisticated approaches
dividing cells between multiple countries will be investigated in future).
The country identity at each cell is specified in
data(gridCountriesDegreesHalf).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>aggregateHalfDegreeGridToCountries(inFile = "", aggregateOption = "sum")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="aggregateHalfDegreeGridToCountries_+3A_infile">inFile</code></td>
<td>
<p>either a gridascii filename or an sp SpatialGridDataFrame
object specifying a global half degree grid dataset</p>
</td></tr>
<tr><td><code id="aggregateHalfDegreeGridToCountries_+3A_aggregateoption">aggregateOption</code></td>
<td>
<p>how to aggregate the data ('sum','mean','min','max')</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a dataframe with 2 columns : numeric country codes and the
aggregated value for each country
</p>


<h3>Author(s)</h3>

<p>andy south
#@importFrom maptools readAsciiGrid
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mapHalfDegreeGridToCountries">mapHalfDegreeGridToCountries</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

data(gridExData,envir=environment(),package="rworldmap")
gridExData &lt;- get("gridExData")
#aggregating the gridded data to countries
dF &lt;- aggregateHalfDegreeGridToCountries(gridExData)
#joining the aggregated data to a country map
sPDF &lt;- joinCountryData2Map(dF, nameJoinColumn='UN', joinCode='UN')
#plotting the map
mapCountryData(sPDF,nameColumnToPlot='sum_pa2000.asc')


</code></pre>

<hr>
<h2 id='barplotCountryData'>Barplot country-level data.</h2><span id='topic+barplotCountryData'></span>

<h3>Description</h3>

<p>Draw a barplot of country-level data, ranking the countries to allow easy
comparison. 
One bar per country and to be able to read country names.
This is useful for comparing with maps created by
<code><a href="#topic+mapCountryData">mapCountryData</a></code> and accepts many of the same arguments for
categorising and colouring.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>barplotCountryData(
  dF = "",
  nameColumnToPlot = "",
  nameCountryColumn = "NAME",
  numPanels = 4,
  scaleSameInPanels = FALSE,
  main = nameColumnToPlot,
  numCats = 5,
  catMethod = "quantiles",
  colourPalette = "heat",
  addLegend = TRUE,
  toPDF = FALSE,
  outFile = "",
  decreasing = TRUE,
  na.last = TRUE,
  cex = 0.7,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="barplotCountryData_+3A_df">dF</code></td>
<td>
<p>a dataframe containing at least one column with numeric data and
one with country names or other labels</p>
</td></tr>
<tr><td><code id="barplotCountryData_+3A_namecolumntoplot">nameColumnToPlot</code></td>
<td>
<p>name of column containing the data you want to plot</p>
</td></tr>
<tr><td><code id="barplotCountryData_+3A_namecountrycolumn">nameCountryColumn</code></td>
<td>
<p>name of column containing country names (or other
labels to be used in plot)</p>
</td></tr>
<tr><td><code id="barplotCountryData_+3A_numpanels">numPanels</code></td>
<td>
<p>the number of layout panels in the plot</p>
</td></tr>
<tr><td><code id="barplotCountryData_+3A_scalesameinpanels">scaleSameInPanels</code></td>
<td>
<p>whether to set the scale the same in each panel
TRUE/FALSE, default=FALSE allowing more of the variability in the data to be
viewed</p>
</td></tr>
<tr><td><code id="barplotCountryData_+3A_main">main</code></td>
<td>
<p>title for the plot</p>
</td></tr>
<tr><td><code id="barplotCountryData_+3A_numcats">numCats</code></td>
<td>
<p>number of categories to put the data in, may be modified if
this number is incompatible with the catMethod chosen</p>
</td></tr>
<tr><td><code id="barplotCountryData_+3A_catmethod">catMethod</code></td>
<td>
<p>method for categorisation of data &quot;pretty&quot;, &quot;fixedWidth&quot;,
&quot;diverging&quot;, &quot;logFixedWidth&quot;,&quot;quantiles&quot;,&quot;categorical&quot;, or a numeric vector
defining breaks</p>
</td></tr>
<tr><td><code id="barplotCountryData_+3A_colourpalette">colourPalette</code></td>
<td>
<p>a string describing the colour palette to use, choice
of : </p>
 <ol>
<li><p>= &quot;palette&quot; for the current palette </p>
</li>
<li><p> a vector of
valid colours, e.g. =c('red','white','blue') or output from RColourBrewer
</p>
</li>
<li><p> = one of &quot;heat&quot;, &quot;diverging&quot;, &quot;white2Black&quot;, &quot;black2White&quot;, &quot;topo&quot;,
&quot;rainbow&quot;, &quot;terrain&quot;, &quot;negpos8&quot;, &quot;negpos9&quot; </p>
</li></ol>
</td></tr>
<tr><td><code id="barplotCountryData_+3A_addlegend">addLegend</code></td>
<td>
<p>NOT YET WORKING whether to add a legend or not, TRUE/FALSE</p>
</td></tr>
<tr><td><code id="barplotCountryData_+3A_topdf">toPDF</code></td>
<td>
<p>whether to output the plot to a pdf rather than the screen,
TRUE/FALSE</p>
</td></tr>
<tr><td><code id="barplotCountryData_+3A_outfile">outFile</code></td>
<td>
<p>output filename if toPDF=TRUE</p>
</td></tr>
<tr><td><code id="barplotCountryData_+3A_decreasing">decreasing</code></td>
<td>
<p>logical. Should the sort order be increasing or
decreasing?</p>
</td></tr>
<tr><td><code id="barplotCountryData_+3A_na.last">na.last</code></td>
<td>
<p>for controlling the treatment of NAs. If TRUE, missing values
in the data are put last; if FALSE, they are put first; if NA, they are
removed.</p>
</td></tr>
<tr><td><code id="barplotCountryData_+3A_cex">cex</code></td>
<td>
<p>sizing of labels, default = 0.7</p>
</td></tr>
<tr><td><code id="barplotCountryData_+3A_...">...</code></td>
<td>
<p>other arguments to pass to barplot</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Finer control can be achieved by <code><a href="#topic+addMapLegend">addMapLegend</a></code>.
</p>


<h3>Value</h3>

<p>invisibly returns a list containing the data and main options used
for the map, the list can be passed to <code><a href="#topic+addMapLegend">addMapLegend</a></code> or
<code><a href="#topic+addMapLegendBoxes">addMapLegendBoxes</a></code> along with additional options to allow
greater flexibility in legend creation.
</p>


<h3>Warning</h3>

<p>will generate unhelpful errors in data categorisation if
inappropriate options are chosen, e.g. with catMethod:Quantiles if numCats
too high so that unique breaks cannot be defined.
</p>


<h3>Author(s)</h3>

<p>andy south
</p>


<h3>See Also</h3>

<p>classInt, RColorBrewer
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#default uses popn data in the default map
barplotCountryData()


data("countryExData",envir=environment(),package="rworldmap")

barplotCountryData( countryExData
              , nameColumnToPlot="BIODIVERSITY" 
              , nameCountryColumn = "Country"
              )
              

              

</code></pre>

<hr>
<h2 id='coastsCoarse'>A map of world coasts at coarse resolution.</h2><span id='topic+coastsCoarse'></span>

<h3>Description</h3>

<p>A spatial lines dataframe containing world coasts at a coarse resolution.
</p>


<h3>Format</h3>

<p>The format is: Formal class 'SpatialLinesDataFrame' [package &quot;sp&quot;]
with 4 slots
</p>


<h3>Details</h3>

<p>Used in mapGriddedData(addBorders='coasts'). This is the 1:110m coasts data
from Natural Earth version 1.3.0.
</p>


<h3>Source</h3>

<p>http://www.naturalearthdata.com/downloads/110m-physical-vectors/
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(coastsCoarse)
mapGriddedData(addBorders='coasts')
plot(coastsCoarse,add=TRUE,col='blue')

</code></pre>

<hr>
<h2 id='countriesCoarse'>a coarse resolution world map, a vector map of 244 country
boundaries,suitable for global maps</h2><span id='topic+countriesCoarse'></span>

<h3>Description</h3>

<p>A 'SpatialPolygonsDataFrame' [package &quot;sp&quot;] object containing a simplified
world map.  Polygons are attributed with country codes. 244 countries. Based
on Natural Earth data.
</p>


<h3>Format</h3>

<p>The format is: Formal class 'SpatialPolygonsDataFrame' [package
&quot;sp&quot;] with 5 slots
</p>


<h3>Details</h3>

<p>Derived from version 1.4.0 of Natural Earth data 1:110 m data.  Missing
countries at this resolution are added in from the higher resolution 1:50 m
data so that these countries are included e.g. in <code><a href="#topic+mapBubbles">mapBubbles</a></code>.
</p>
<p>The different country boundaries in rworldmap are processed from Natural
Earth Data as follows : <br /> All : <br /> ~ rename any non-ASCII country names
that cause R trouble <br /> ~ rename Curacao which is particularly troublesome
!  <br /> ~ check polygon geometries using checkPolygonsHoles <br /> ~ set
projections, e.g. proj4string(countriesCoarse) &lt;- CRS(&quot;+proj=longlat
+ellps=WGS84 +datum=WGS84 +no_defs&quot;)<br /> ~ set polygon IDs to country names
(from ADMIN field) <br /> ~ copy ISO_A3 to ISO3 <br /> ~ replace missing ISO3
codes (6 in this version) with ADM0_A3 <br /> ~ check for duplicate ISO3 codes
(2 in this version) <br /> ~ set ISO3 for Gaza to Gaza and 'Ashmore and Cartier
Islands' to Ashm <br /> ~ replace POP_EST of -99 with NA <br /> ~ join on
countryRegions data <br />
</p>
<p>countriesCoarseLessIslands : ne_110 <br /> countriesCoarse : ne_110 plus extra
countries from ne_50 plus Tuvalu from ne_10 <br /> countriesLow : ne_50 plus
Tuvalu from ne_10 <br /> countriesHigh (in package rworldxtra) : ne_10 <br />
</p>


<h3>Source</h3>

<p>http://www.naturalearthdata.com/downloads/110m-cultural-vectors/110m-admin-0-countries/
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(countriesCoarse)

</code></pre>

<hr>
<h2 id='countriesCoarseLessIslands'>a coarse resolution world map, a vector map of 177 country boundaries,
suitable for global maps</h2><span id='topic+countriesCoarseLessIslands'></span>

<h3>Description</h3>

<p>A 'SpatialPolygonsDataFrame' [package &quot;sp&quot;] object containing a simplified
world map.  Polygons are attributed with country codes. 177 countries.
Derived fronm version 1.4.0 of Natural Earth data 1:110 m data.
</p>


<h3>Format</h3>

<p>The format is: Formal class 'SpatialPolygonsDataFrame' [package
&quot;sp&quot;] with 5 slots
</p>


<h3>Details</h3>

<p>The different country boundaries in rworldmap are processed from Natural
Earth Data as follows : <br /> All : <br /> ~ rename any non-ASCII country names
that cause R trouble <br /> ~ rename Curacao which is particularly troublesome
!  <br /> ~ check polygon geometries using checkPolygonsHoles <br /> ~ set
projections, e.g. proj4string(countriesCoarse) &lt;- CRS(&quot;+proj=longlat
+ellps=WGS84 +datum=WGS84 +no_defs&quot;)<br /> ~ set polygon IDs to country names
(from ADMIN field) <br /> ~ copy ISO_A3 to ISO3 <br /> ~ replace missing ISO3
codes (6 in this version) with ADM0_A3 <br /> ~ check for duplicate ISO3 codes
(2 in this version) <br /> ~ set ISO3 for Gaza to Gaza and 'Ashmore and Cartier
Islands' to Ashm <br /> ~ replace POP_EST of -99 with NA <br /> ~ join on
countryRegions data <br />
</p>
<p>countriesCoarseLessIslands : ne_110 <br /> countriesCoarse : ne_110 plus extra
countries from ne_50 plus Tuvalu from ne_10 <br /> countriesLow : ne_50 plus
Tuvalu from ne_10 <br /> countriesHigh (in package rworldxtra) : ne_10 <br />
</p>


<h3>Source</h3>

<p>http://www.naturalearthdata.com/downloads/110m-cultural-vectors/110m-admin-0-countries/
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(countriesCoarseLessIslands)

</code></pre>

<hr>
<h2 id='countriesLow'>a low resolution world map, a vector map of 244 country boundaries, suitable
for zooming in on regions or large global maps</h2><span id='topic+countriesLow'></span>

<h3>Description</h3>

<p>A 'SpatialPolygonsDataFrame' [package &quot;sp&quot;] object containing country
boundaries derived from Natural Earth data.  Polygons are attributed with
country codes. Derived from version 1.4.0 of Natural Earth data 1:50 m data.
</p>


<h3>Format</h3>

<p>The format is: Formal class 'SpatialPolygonsDataFrame' [package
&quot;sp&quot;] with 5 slots
</p>


<h3>Details</h3>

<p>The different country boundaries in rworldmap are processed from Natural
Earth Data as follows : <br /> All : <br /> ~ rename any non-ASCII country names
that cause R trouble <br /> ~ rename Curacao which is particularly troublesome
!  <br /> ~ check polygon geometries using checkPolygonsHoles <br /> ~ set
projections, e.g. proj4string(countriesCoarse) &lt;- CRS(&quot;+proj=longlat
+ellps=WGS84 +datum=WGS84 +no_defs&quot;)<br /> ~ set polygon IDs to country names
(from ADMIN field) <br /> ~ copy ISO_A3 to ISO3 <br /> ~ replace missing ISO3
codes (6 in this version) with ADM0_A3 <br /> ~ check for duplicate ISO3 codes
(2 in this version) <br /> ~ set ISO3 for Gaza to Gaza and 'Ashmore and Cartier
Islands' to Ashm <br /> ~ replace POP_EST of -99 with NA <br /> ~ join on
countryRegions data <br />
</p>
<p>countriesCoarseLessIslands : ne_110 <br /> countriesCoarse : ne_110 plus extra
countries from ne_50 plus Tuvalu from ne_10 <br /> countriesLow : ne_50 plus
Tuvalu from ne_10 <br /> countriesHigh (in package rworldxtra) : ne_10 <br />
</p>


<h3>Source</h3>

<p>http://www.naturalearthdata.com/downloads/50m-cultural-vectors/
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(countriesLow)

</code></pre>

<hr>
<h2 id='country2Region'>Produce regional data from country level data</h2><span id='topic+country2Region'></span>

<h3>Description</h3>

<p>A function to aggregate country level data into regional data. For example
finding the total population of Asia, Europe,etc, from country level
populations. As well as sums, other functions can be used, like mean,
median, min, max, etc. There are currently 8 choices of region and 4 choices
of country code.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>country2Region(
  regionType = "",
  inFile = "",
  nameDataColumn = "",
  joinCode = "",
  nameJoinColumn = "",
  FUN = mean,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="country2Region_+3A_regiontype">regionType</code></td>
<td>
<p>Must be one of: &quot;GEO3&quot;, &quot;GEO3major&quot;, &quot;IMAGE24&quot;, &quot;GLOCAF&quot;,
&quot;Stern&quot;, &quot;SRES&quot;, &quot;SRESmajor&quot; or &quot;GBD&quot;</p>
</td></tr>
<tr><td><code id="country2Region_+3A_infile">inFile</code></td>
<td>
<p>a data frame</p>
</td></tr>
<tr><td><code id="country2Region_+3A_namedatacolumn">nameDataColumn</code></td>
<td>
<p>The name of the data column to aggregate</p>
</td></tr>
<tr><td><code id="country2Region_+3A_joincode">joinCode</code></td>
<td>
<p>The type of code to join with. Must be one of: &quot;ISO2&quot;,
&quot;ISO3&quot;, &quot;Numeric&quot; or &quot;FIPS&quot;</p>
</td></tr>
<tr><td><code id="country2Region_+3A_namejoincolumn">nameJoinColumn</code></td>
<td>
<p>The name of a column of inFile. Contains joining
codes.</p>
</td></tr>
<tr><td><code id="country2Region_+3A_fun">FUN</code></td>
<td>
<p>A function to apply to each region, e.g. 'mean'</p>
</td></tr>
<tr><td><code id="country2Region_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to FUN, e.g. na.rm=TRUE</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The user must specify 'nameJoinColumn' from their data which contains
country codes, and joinCode which specifies the type of code. regionType
specifies which regions to aggregate the data to. Using FUN='identity' will
return the neames of the countries within each region.
</p>


<h3>Value</h3>

<p>If FUN returns a single value, country2Region returns a data frame,
with value of FUN for each region.
</p>
<p>If FUN returns more than one value, country2Region will return a list, with
one element for each region.
</p>


<h3>See Also</h3>

<p>For producing maps of regional data from aggregated country level
data, see <code><a href="#topic+mapByRegion">mapByRegion</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(countryExData)

#to report which countries make up regions
country2Region(regionType="Stern")

#Using country2Region to calculate mean Environmental Health index in Stern regions.
sternEnvHealth &lt;- country2Region(inFile=countryExData
		,nameDataColumn="ENVHEALTH"
		,joinCode="ISO3"
		,nameJoinColumn="ISO3V10"
		,regionType="Stern"
		,FUN='mean'
		)

print(sternEnvHealth)

#A simple plot of this data.
#dotchart(sort(sternEnvHealth))
dotchart(sort(sternEnvHealth[,1]))

#use FUN='identity' to see which countries in your data belong to which region.
country2Region(inFile=countryExData
		,nameDataColumn="Country"
		,joinCode="ISO3"
		,nameJoinColumn="ISO3V10"
		,regionType="Stern"
		,FUN='identity'
		)

#Change FUN to length, to count the number of countries in each region.
country2Region(inFile=countryExData
		,nameDataColumn="Country"
		,joinCode="ISO3"
		,nameJoinColumn="ISO3V10"
		,regionType="Stern"
		,FUN='length'
		)



</code></pre>

<hr>
<h2 id='countryExData'>Example dataset for country level data (2008 Environmental Performance
Index)</h2><span id='topic+countryExData'></span>

<h3>Description</h3>

<p>A dataframe containing example country level data for 149 countries.  This
is the 2008 Environmental Performance Index (EPI) downloaded from
http://epi.yale.edu/.  Used here with permission, further details on the
data can be found there.  The data are referenced by ISO 3 letter country
codes and country names.
</p>


<h3>Format</h3>

<p>A data frame with 149 observations on the following 80 variables.
</p>
 <dl>
<dt>ISO3V10</dt><dd><p>a character vector</p>
</dd>
<dt>Country</dt><dd><p>a character vector</p>
</dd> <dt>EPI_regions</dt><dd><p>a
character vector</p>
</dd> <dt>GEO_subregion</dt><dd><p>a character vector</p>
</dd>
<dt>Population2005</dt><dd><p>a numeric vector</p>
</dd>
<dt>GDP_capita.MRYA</dt><dd><p>a numeric vector</p>
</dd> <dt>landlock</dt><dd><p>a
numeric vector</p>
</dd> <dt>landarea</dt><dd><p>a numeric vector</p>
</dd>
<dt>density</dt><dd><p>a numeric vector</p>
</dd> <dt>EPI</dt><dd><p>a numeric
vector</p>
</dd> <dt>ENVHEALTH</dt><dd><p>a numeric vector</p>
</dd>
<dt>ECOSYSTEM</dt><dd><p>a numeric vector</p>
</dd> <dt>ENVHEALTH.1</dt><dd><p>a
numeric vector</p>
</dd> <dt>AIR_E</dt><dd><p>a numeric vector</p>
</dd>
<dt>WATER_E</dt><dd><p>a numeric vector</p>
</dd> <dt>BIODIVERSITY</dt><dd><p>a
numeric vector</p>
</dd> <dt>PRODUCTIVE_NATURAL_RESOURCES</dt><dd><p>a numeric
vector</p>
</dd> <dt>CLIMATE</dt><dd><p>a numeric vector</p>
</dd> <dt>DALY_SC</dt><dd><p>a
numeric vector</p>
</dd> <dt>WATER_H</dt><dd><p>a numeric vector</p>
</dd>
<dt>AIR_H</dt><dd><p>a numeric vector</p>
</dd> <dt>AIR_E.1</dt><dd><p>a numeric
vector</p>
</dd> <dt>WATER_E.1</dt><dd><p>a numeric vector</p>
</dd>
<dt>BIODIVERSITY.1</dt><dd><p>a numeric vector</p>
</dd> <dt>FOREST</dt><dd><p>a
numeric vector</p>
</dd> <dt>FISH</dt><dd><p>a numeric vector</p>
</dd>
<dt>AGRICULTURE</dt><dd><p>a numeric vector</p>
</dd> <dt>CLIMATE.1</dt><dd><p>a
numeric vector</p>
</dd> <dt>ACSAT_pt</dt><dd><p>a numeric vector</p>
</dd>
<dt>WATSUP_pt</dt><dd><p>a numeric vector</p>
</dd> <dt>DALY_pt</dt><dd><p>a numeric
vector</p>
</dd> <dt>INDOOR_pt</dt><dd><p>a numeric vector</p>
</dd> <dt>PM10_pt</dt><dd><p>a
numeric vector</p>
</dd> <dt>OZONE_H_pt</dt><dd><p>a numeric vector</p>
</dd>
<dt>SO2_pt</dt><dd><p>a numeric vector</p>
</dd> <dt>OZONE_E_pt</dt><dd><p>a numeric
vector</p>
</dd> <dt>WATQI_pt</dt><dd><p>a numeric vector</p>
</dd> <dt>WATSTR_pt</dt><dd><p>a
numeric vector</p>
</dd> <dt>WATQI_GEMS.station.data</dt><dd><p>a numeric vector</p>
</dd>
<dt>FORGRO_pt</dt><dd><p>a numeric vector</p>
</dd> <dt>CRI_pt</dt><dd><p>a numeric
vector</p>
</dd> <dt>EFFCON_pt</dt><dd><p>a numeric vector</p>
</dd> <dt>AZE_pt</dt><dd><p>a
numeric vector</p>
</dd> <dt>MPAEEZ_pt</dt><dd><p>a numeric vector</p>
</dd>
<dt>EEZTD_pt</dt><dd><p>a numeric vector</p>
</dd> <dt>MTI_pt</dt><dd><p>a numeric
vector</p>
</dd> <dt>IRRSTR_pt</dt><dd><p>a numeric vector</p>
</dd> <dt>AGINT_pt</dt><dd><p>a
numeric vector</p>
</dd> <dt>AGSUB_pt</dt><dd><p>a numeric vector</p>
</dd>
<dt>BURNED_pt</dt><dd><p>a numeric vector</p>
</dd> <dt>PEST_pt</dt><dd><p>a numeric
vector</p>
</dd> <dt>GHGCAP_pt</dt><dd><p>a numeric vector</p>
</dd>
<dt>CO2IND_pt</dt><dd><p>a numeric vector</p>
</dd> <dt>CO2KWH_pt</dt><dd><p>a
numeric vector</p>
</dd> <dt>ACSAT</dt><dd><p>a numeric vector</p>
</dd>
<dt>WATSUP</dt><dd><p>a numeric vector</p>
</dd> <dt>DALY</dt><dd><p>a numeric
vector</p>
</dd> <dt>INDOOR</dt><dd><p>a numeric vector</p>
</dd> <dt>PM10</dt><dd><p>a
numeric vector</p>
</dd> <dt>OZONE_H</dt><dd><p>a numeric vector</p>
</dd>
<dt>SO2</dt><dd><p>a numeric vector</p>
</dd> <dt>OZONE_E</dt><dd><p>a numeric
vector</p>
</dd> <dt>WATQI</dt><dd><p>a numeric vector</p>
</dd>
<dt>WATQI_GEMS.station.data.1</dt><dd><p>a numeric vector</p>
</dd>
<dt>WATSTR</dt><dd><p>a numeric vector</p>
</dd> <dt>FORGRO</dt><dd><p>a numeric
vector</p>
</dd> <dt>CRI</dt><dd><p>a numeric vector</p>
</dd> <dt>EFFCON</dt><dd><p>a numeric
vector</p>
</dd> <dt>AZE</dt><dd><p>a numeric vector</p>
</dd> <dt>MPAEEZ</dt><dd><p>a numeric
vector</p>
</dd> <dt>EEZTD</dt><dd><p>a numeric vector</p>
</dd> <dt>MTI</dt><dd><p>a numeric
vector</p>
</dd> <dt>IRRSTR</dt><dd><p>a numeric vector</p>
</dd> <dt>AGINT</dt><dd><p>a
numeric vector</p>
</dd> <dt>AGSUB</dt><dd><p>a numeric vector</p>
</dd>
<dt>BURNED</dt><dd><p>a numeric vector</p>
</dd> <dt>PEST</dt><dd><p>a numeric
vector</p>
</dd> <dt>GHGCAP</dt><dd><p>a numeric vector</p>
</dd> <dt>CO2IND</dt><dd><p>a
numeric vector</p>
</dd> <dt>CO2KWH</dt><dd><p>a numeric vector</p>
</dd> </dl>



<h3>Details</h3>

<p>2008 Environmental Performance Index (EPI) data downloaded from :
http://epi.yale.edu/Downloads
</p>
<p>Disclaimers This 2008 Environmental Performance Index (EPI) tracks national
environmental results on a quantitative basis, measuring proximity to an
established set of policy targets using the best data available. Data
constraints and limitations in methodology make this a work in progress.
Further refinements will be undertaken over the next few years.  Comments,
suggestions, feedback, and referrals to better data sources are welcome at:
http://epi.yale.edu or epi@yale.edu.
</p>


<h3>Source</h3>

<p>http://epi.yale.edu/Downloads
</p>


<h3>References</h3>

<p>Esty, Daniel C., M.A. Levy, C.H. Kim, A. de Sherbinin, T.
Srebotnjak, and V. Mara. 2008.  2008 Environmental Performance Index. New
Haven: Yale Center for Environmental Law and Policy.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(countryExData,envir=environment(),package="rworldmap")
str(countryExData)

</code></pre>

<hr>
<h2 id='countryRegions'>Regional Classification Table</h2><span id='topic+countryRegions'></span>

<h3>Description</h3>

<p>A number of regional classifications exist, e.g. SRES, Stern, etc. This
table can be used to find which grouping a country belongs to, given its
country code. A variety of different codes or groupings can be used.
</p>


<h3>Format</h3>

<p>A data frame with the following variables.  </p>

<dl>
<dt>ISO3</dt><dd><p>ISO 3 letter country code</p>
</dd> <dt>ADMIN</dt><dd><p>country
name</p>
</dd> <dt>REGION</dt><dd><p>7 region continent classification</p>
</dd>
<dt>continent</dt><dd><p>6 continents classification</p>
</dd>
<dt>GEO3major</dt><dd><p>Global Environment Outlook GEO3 major region names</p>
</dd>
<dt>GEO3</dt><dd><p>Global Environment Outlook GEO3 major region names</p>
</dd>
<dt>IMAGE24</dt><dd><p>Image24 region names</p>
</dd> <dt>GLOCAF</dt><dd><p>GLOCAF
region names</p>
</dd> <dt>Stern</dt><dd><p>Stern report region names</p>
</dd>
<dt>SRESmajor</dt><dd><p>SRES major region names</p>
</dd> <dt>SRES</dt><dd><p>SRES
region names</p>
</dd> <dt>GBD</dt><dd><p>Global Burden of Disease GBD region names</p>
</dd>
<dt>AVOIDnumeric</dt><dd><p>numeric codes for AVOID regions</p>
</dd>
<dt>AVOIDname</dt><dd><p>AVOID regions</p>
</dd> <dt>LDC</dt><dd><p>UN Least
Developed Countries</p>
</dd> <dt>SID</dt><dd><p>UN Small Island Developing states</p>
</dd>
<dt>LLDC</dt><dd><p>UN Landlocked Developing Countries</p>
</dd> </dl>



<h3>Details</h3>

<p>Joined onto vector country maps. Used by <code><a href="#topic+country2Region">country2Region</a></code> and
<code><a href="#topic+mapByRegion">mapByRegion</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(countryRegions,envir=environment(),package="rworldmap")
str(countryRegions)

#joining example data onto the regional classifications
data(countryExData,envir=environment(),package="rworldmap")
dF &lt;- merge(countryExData,countryRegions,by.x='ISO3V10',by.y='ISO3')
#plotting ENVHEALTH for Least Developed Countries (LDC) against others
#plot( dF$ENVHEALTH ~ dF$LDC)
#points( y=dF$ENVHEALTH, x=dF$LDC)


</code></pre>

<hr>
<h2 id='countrySynonyms'>Synonyms of country names for each ISO 3 letter country code to enable
conversion.</h2><span id='topic+countrySynonyms'></span>

<h3>Description</h3>

<p>contains a variable number of synonyms (mostly English language) for each
country
</p>


<h3>Format</h3>

<p>A data frame with 281 observations on the following 10 variables.
</p>
 <dl>
<dt>ID</dt><dd><p>a numeric vector</p>
</dd> <dt>ISO3</dt><dd><p>ISO 3
letter country code</p>
</dd> <dt>name1</dt><dd><p>country name - most common</p>
</dd>
<dt>name2</dt><dd><p>country name - alternative</p>
</dd>
<dt>name3</dt><dd><p>country name - alternative</p>
</dd>
<dt>name4</dt><dd><p>country name - alternative</p>
</dd>
<dt>name5</dt><dd><p>country name - alternative</p>
</dd>
<dt>name6</dt><dd><p>country name - alternative</p>
</dd>
<dt>name7</dt><dd><p>country name - alternative</p>
</dd>
<dt>name8</dt><dd><p>country name - alternative</p>
</dd> </dl>



<h3>Details</h3>

<p>This is used by joinCountryData2Map() when country names are used as the
joinCode. Note that using ISO codes is preferable if they are available.
</p>


<h3>Source</h3>

<p>This was derived and used with permission from the Perl Locale
package. <br /> Locale::Codes::Country_Codes.<br /> Thanks to Sullivan Beck for
pulling this together.<br /> Data sources are acknowledged here :<br />
http://search.cpan.org/~sbeck/Locale-Codes-3.23/lib/Locale/Codes/Country.pod
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(countrySynonyms)


</code></pre>

<hr>
<h2 id='getMap'>A simple way to access maps stored in the package.</h2><span id='topic+getMap'></span>

<h3>Description</h3>

<p>A simple way to access maps stored in the package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getMap(resolution = "coarse", projection = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getMap_+3A_resolution">resolution</code></td>
<td>
<p>options &quot;coarse&quot;,&quot;low&quot;,&quot;less islands&quot;,&quot;li&quot;,&quot;high&quot;. For
&quot;high&quot; you need to install the package rworldxtra</p>
</td></tr>
<tr><td><code id="getMap_+3A_projection">projection</code></td>
<td>
<p>DEPRECATED OCTOBER 2012 to reproject maps see spTransform
in rgdal</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A SpatialPolygonsDataFrame object.
</p>


<h3>Author(s)</h3>

<p>Barry Rowlingson &amp; Andy South
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
plot(getMap())

</code></pre>

<hr>
<h2 id='gridCountriesDegreesHalf'>A gloabl half degree grid specifying the country at each cell</h2><span id='topic+gridCountriesDegreesHalf'></span>

<h3>Description</h3>

<p>A grid covering the globe at half degree resolution, specifying the country
(UN numeric code) at each cell.
</p>


<h3>Format</h3>

<p>The format is: </p>
<pre> Formal class 'SpatialGridDataFrame'
[package "sp"] with 6 slots ..@ data :'data.frame': 259200 obs. of 1
variable: .. ..$ country.asc: num [1:259200] NA NA NA NA NA NA NA NA NA NA
...  ..@ grid :Formal class 'GridTopology' [package "sp"] with 3 slots .. ..
..@ cellcentre.offset: num [1:2] -179.8 -89.8 .. .. ..@ cellsize : num [1:2]
0.5 0.5 .. .. ..@ cells.dim : int [1:2] 720 360 ..@ grid.index : int(0) ..@
coords : num [1:2, 1:2] -179.8 179.8 -89.8 89.8 .. ..- attr(*,
"dimnames")=List of 2 .. .. ..$ : NULL .. .. ..$ : chr [1:2] "coords.x1"
"coords.x2" ..@ bbox : num [1:2, 1:2] -180 -90 180 90 .. ..- attr(*,
"dimnames")=List of 2 .. .. ..$ : chr [1:2] "coords.x1" "coords.x2" .. ..
..$ : chr [1:2] "min" "max" ..@ proj4string:Formal class 'CRS' [package
"sp"] with 1 slots .. .. ..@ projargs: chr " +proj=longlat +datum=WGS84
+ellps=WGS84 +towgs84=0,0,0" </pre>


<h3>Details</h3>

<p>Uses a simple grid map defining a single country identity for each half
degree cell.  (sp, SpatialGridDataFrame), used by the function
aggregateHalfDegreeGridToCountries()
</p>


<h3>Source</h3>

<p>created from getMap(resolution='low')
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(gridCountriesDegreesHalf)

</code></pre>

<hr>
<h2 id='gridCountriesNumeric'>A gloabl half degree grid specifying the country at each cell</h2><span id='topic+gridCountriesNumeric'></span>

<h3>Description</h3>

<p>A grid covering the globe at half degree resolution, specifying the country
(UN numeric code) at each cell.
</p>


<h3>Format</h3>

<p>The format is: </p>
<pre> Formal class 'SpatialGridDataFrame'
[package "sp"] with 6 slots ..@ data :'data.frame': 259200 obs. of 1
variable: .. ..$ country.asc: num [1:259200] NA NA NA NA NA NA NA NA NA NA
...  ..@ grid :Formal class 'GridTopology' [package "sp"] with 3 slots .. ..
..@ cellcentre.offset: num [1:2] -179.8 -89.8 .. .. ..@ cellsize : num [1:2]
0.5 0.5 .. .. ..@ cells.dim : int [1:2] 720 360 ..@ grid.index : int(0) ..@
coords : num [1:2, 1:2] -179.8 179.8 -89.8 89.8 .. ..- attr(*,
"dimnames")=List of 2 .. .. ..$ : NULL .. .. ..$ : chr [1:2] "coords.x1"
"coords.x2" ..@ bbox : num [1:2, 1:2] -180 -90 180 90 .. ..- attr(*,
"dimnames")=List of 2 .. .. ..$ : chr [1:2] "coords.x1" "coords.x2" .. ..
..$ : chr [1:2] "min" "max" ..@ proj4string:Formal class 'CRS' [package
"sp"] with 1 slots .. .. ..@ projargs: chr " +proj=longlat +datum=WGS84
+ellps=WGS84 +towgs84=0,0,0" </pre>


<h3>Details</h3>

<p>Uses a simple grid map defining a single country identity for each half
degree cell.  (sp, SpatialGridDataFrame), used by the function
aggregateHalfDegreeGridToCountries()
</p>


<h3>Source</h3>

<p>IIASA
</p>


<h3>References</h3>

<p>http://www.iiasa.ac.at/Research/GGI/DB/
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(gridCountriesNumeric)

</code></pre>

<hr>
<h2 id='gridExData'>Example half degree grid data : population estimates for 2000 from IIASA</h2><span id='topic+gridExData'></span>

<h3>Description</h3>

<p>Example half degree grid data : people per cell estimates for 2000 from
IIASA (International Institute for Applied System Analysis) (sp,
SpatialGridDataFrame).
</p>


<h3>Format</h3>

<p>The format is: </p>
<pre> Formal class 'SpatialGridDataFrame'
[package "sp"] with 6 slots ..@ data :'data.frame': 259200 obs. of 1
variable: .. ..$ pa2000.asc: num [1:259200] NA NA NA NA NA NA NA NA NA NA
...  ..@ grid :Formal class 'GridTopology' [package "sp"] with 3 slots .. ..
..@ cellcentre.offset: num [1:2] -179.8 -89.8 .. .. ..@ cellsize : num [1:2]
0.5 0.5 .. .. ..@ cells.dim : int [1:2] 720 360 ..@ grid.index : int(0) ..@
coords : num [1:2, 1:2] -179.8 179.8 -89.8 89.8 .. ..- attr(*,
"dimnames")=List of 2 .. .. ..$ : NULL .. .. ..$ : chr [1:2] "coords.x1"
"coords.x2" ..@ bbox : num [1:2, 1:2] -180 -90 180 90 .. ..- attr(*,
"dimnames")=List of 2 .. .. ..$ : chr [1:2] "coords.x1" "coords.x2" .. ..
..$ : chr [1:2] "min" "max" ..@ proj4string:Formal class 'CRS' [package
"sp"] with 1 slots .. .. ..@ projargs: chr " +proj=longlat +datum=WGS84
+ellps=WGS84 +towgs84=0,0,0" </pre>


<h3>Details</h3>

<p>From International Institute for Applied System Analysis (IIASA) GGI
Scenario Database, 2007 Available at:
http://www.iiasa.ac.at/Research/GGI/DB/ The data are made available for
individual, academic research purposes only and on a &quot;as is&quot; basis, subject
to revisions without further notice.  Commercial applications are not
permitted.
</p>
<p>The data is used as the default dataset in other functions, e.g.
mapGriddedData(), when no data file is given.
</p>


<h3>Source</h3>

<p>http://www.iiasa.ac.at/web-apps/ggi/GgiDb/dsd?Action=htmlpage&amp;page=about
</p>


<h3>References</h3>

<p>Grubler, A., O'Neill, B., Riahi, K., Chirkov, V., Goujon, A.,
Kolp, P., Prommer, I., Scherbov, S. &amp; Slentoe, E. (2006) Regional, national
and spatially explicit scenarios of demographic and economic change based on
SRES. Technological Forecasting and Social Change
doi:10.1016/j.techfore.2006.05.023
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(gridExData)

</code></pre>

<hr>
<h2 id='identifyCountries'>a function that will print country name and attribute values when a user
clicks on the map</h2><span id='topic+identifyCountries'></span>

<h3>Description</h3>

<p>An interactive function that will print on a map the nearest country name to
a user mouse click.  The user can specify nothing and the function will use
a map from the package. Alternatively the user can specifiy a data frame or
SpatialPolygonsDataFrame in which case they need to define the column
containing the country names (nameCountryColumn) and optionally a 2nd
attribute column to print (nameColumnToPlot).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>identifyCountries(
  dF = "",
  nameCountryColumn = "NAME",
  nameX = "LON",
  nameY = "LAT",
  nameColumnToPlot = "",
  plotSelected = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="identifyCountries_+3A_df">dF</code></td>
<td>
<p>data frame or SpatialPolygonsDataFrame</p>
</td></tr>
<tr><td><code id="identifyCountries_+3A_namecountrycolumn">nameCountryColumn</code></td>
<td>
<p>name of column containing country names to be
printed on the map (could also be set to any other attribute the user wants
to query)</p>
</td></tr>
<tr><td><code id="identifyCountries_+3A_namex">nameX</code></td>
<td>
<p>name of column containing the X variable (longitude), not
needed if dF is a SpatialPolygonsDataFrame</p>
</td></tr>
<tr><td><code id="identifyCountries_+3A_namey">nameY</code></td>
<td>
<p>name of column containing the Y variable (lattitude), not
needed if dF is a SpatialPolygonsDataFrame</p>
</td></tr>
<tr><td><code id="identifyCountries_+3A_namecolumntoplot">nameColumnToPlot</code></td>
<td>
<p>name of an attribute column in the data frame the
value of which will be appended to the country name when it is printed</p>
</td></tr>
<tr><td><code id="identifyCountries_+3A_plotselected">plotSelected</code></td>
<td>
<p>if set to TRUE a blue outline will be printed around the
countries selected when the selection process is finished</p>
</td></tr>
<tr><td><code id="identifyCountries_+3A_...">...</code></td>
<td>
<p>other parameters that can be passed to identify()</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Uses the identify() function, which waits for the user to click on the map,
and stops when the user right clicks and selects 'stop'.
</p>
<p>It uses country centroids, and will give a warning if one is too far away
(default value of 0.25 inches).
</p>


<h3>Value</h3>

<p>a vector of the indices of the countries selected
</p>


<h3>Author(s)</h3>

<p>andy south
</p>


<h3>See Also</h3>

<p>identify() <code><a href="#topic+labelCountries">labelCountries</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#mapCountryData()
#identifyCountries()

#identifyCountries(nameColumnToPlot = "POP_EST", plotSelected = TRUE)

</code></pre>

<hr>
<h2 id='isoToName'>Returns the country name corresponding to the passed iso code (3 letter, 2
letter or numeric).</h2><span id='topic+isoToName'></span>

<h3>Description</h3>

<p>Searches <code>getMap()@data</code> to find the iso code. By default it returns the
string in the ADMIN column. By modifying nameColumn you can also get it to
return values from any other columns in <code>getMap()@data</code> - see the examples.
Thus it can also be used to convert between ISO codes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>isoToName(iso = "", lookup = getMap()@data, nameColumn = "ADMIN")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="isoToName_+3A_iso">iso</code></td>
<td>
<p>iso code to convert to a country name</p>
</td></tr>
<tr><td><code id="isoToName_+3A_lookup">lookup</code></td>
<td>
<p>the dataframe containing iso codes and country names</p>
</td></tr>
<tr><td><code id="isoToName_+3A_namecolumn">nameColumn</code></td>
<td>
<p>which column to get the name from, see examples</p>
</td></tr>
</table>


<h3>Details</h3>

<p>You could optionally provide a dataframe containing alternate iso
conversions using lookup= . The passe dataframe would need to contain at
least one of the following columns containing 2 letter, 3 letter or numeric
iso codes respectively : ISO_A2, ISO_A3, ISO_N3.
</p>


<h3>Value</h3>

<p>The country name (or other field) associated with the ISO code
passed.  NA is returned if no matching code is found.
</p>


<h3>Author(s)</h3>

<p>Andy South
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
isoToName('gb')
isoToName('gbr')
isoToName(826)
isoToName('uk') #generates a warning and returns NA
#beware that using nameColumn may be vulnerable to future changes 
#in column names in Natural Earth data
isoToName('gb',nameColumn='ABBREV') #returns abbreviation
isoToName('gb',nameColumn='ISO_A3') #returns iso3 for this iso2
isoToName('gbr',nameColumn='continent') #returns continent for this iso3

</code></pre>

<hr>
<h2 id='joinCountryData2Map'>Joins user country referenced data to a map</h2><span id='topic+joinCountryData2Map'></span>

<h3>Description</h3>

<p>Joins user data referenced by country codes or names to an internal map,
ready for plotting using <code><a href="#topic+mapCountryData">mapCountryData</a></code>.  Reports join
successes and failures.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>joinCountryData2Map(
  dF,
  joinCode = "ISO3",
  nameJoinColumn = "ISO3V10",
  nameCountryColumn = "Country",
  suggestForFailedCodes = FALSE,
  mapResolution = "coarse",
  projection = NA,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="joinCountryData2Map_+3A_df">dF</code></td>
<td>
<p>R data frame with at least one column for country reference and
one column of data</p>
</td></tr>
<tr><td><code id="joinCountryData2Map_+3A_joincode">joinCode</code></td>
<td>
<p>how countries are referenced options
&quot;ISO2&quot;,&quot;ISO3&quot;,&quot;FIPS&quot;,&quot;NAME&quot;, &quot;UN&quot; = numeric codes</p>
</td></tr>
<tr><td><code id="joinCountryData2Map_+3A_namejoincolumn">nameJoinColumn</code></td>
<td>
<p>name of column containing country referencing</p>
</td></tr>
<tr><td><code id="joinCountryData2Map_+3A_namecountrycolumn">nameCountryColumn</code></td>
<td>
<p>optional name of column containing country names
(used in reporting of success/failure)</p>
</td></tr>
<tr><td><code id="joinCountryData2Map_+3A_suggestforfailedcodes">suggestForFailedCodes</code></td>
<td>
<p>NOT YET ENABLED T/F whether you want system to
suggest for failed codes</p>
</td></tr>
<tr><td><code id="joinCountryData2Map_+3A_mapresolution">mapResolution</code></td>
<td>
<p>resolution of the borders in the internal map, only for
projection='none' : options 'low', 'medium'</p>
</td></tr>
<tr><td><code id="joinCountryData2Map_+3A_projection">projection</code></td>
<td>
<p>DEPRECATED JUNE 2012</p>
</td></tr>
<tr><td><code id="joinCountryData2Map_+3A_verbose">verbose</code></td>
<td>
<p>if set to FALSE it doesn't print progress messages to console</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Joins data referenced by country codes to an internally stored map to enable
plotting.  The user specifies which country code their data are referenced
by, and the name of the column in their data containing that referencing
data. The user can choose from different map resolutions, using the function
<code><a href="#topic+getMap">getMap</a></code> to retrieve the map. The function reports on how many
countries successfully join to the map. Data can then be plotted using
<code><a href="#topic+mapCountryData">mapCountryData</a></code>. NEW to version 1.01 Oct 2012 : for
joinCode='NAME' alternative country names are matched using
<code><a href="#topic+countrySynonyms">countrySynonyms</a></code>.
</p>
<p>The projection argument has now been deprecated, you can project maps using
package rgdal as shown below and in the FAQ. <br /> library(rgdal) <br /> #first
get countries excluding Antarctica which crashes spTransform <br /> sPDF &lt;-
getMap()[-which(getMap()$ADMIN=='Antarctica'),] <br /> #transform to robin for
the Robinson projection <br /> sPDF &lt;- spTransform(sPDF, CRS=CRS(&quot;+proj=robin
+ellps=WGS84&quot;)) <br /> mapCountryData( sPDF, nameColumnToPlot=&quot;REGION&quot;)
</p>


<h3>Value</h3>

<p>An R 'SpatialPolygonsDataFrame' [package &quot;sp&quot;] object with the
passed data joined to it
</p>


<h3>Author(s)</h3>

<p>andy south
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mapCountryData">mapCountryData</a></code>, <code><a href="#topic+getMap">getMap</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data("countryExData",envir=environment(),package="rworldmap")

sPDF &lt;- joinCountryData2Map(countryExData
              , joinCode = "ISO3"
              , nameJoinColumn = "ISO3V10"
              )
mapCountryData( sPDF
              , nameColumnToPlot="BIODIVERSITY" 
              )


</code></pre>

<hr>
<h2 id='joinData2Map'>Joins user polygon attribute data to a map</h2><span id='topic+joinData2Map'></span>

<h3>Description</h3>

<p>Joins user polygon attribute data to a map of polygon boundaries.  The map
can either be one stored in the package or provided by the user.  Returns a
spatialPolygonsDataFrame ready for plotting using <code><a href="#topic+mapPolys">mapPolys</a></code>.
Reports join successes and failures.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>joinData2Map(
  dF = "",
  nameMap = "",
  nameJoinIDMap = "ISO3",
  nameJoinColumnData = "ISO3V10",
  nameNameColumnData = "Country",
  suggestForFailedCodes = FALSE,
  projection = NA,
  mapResolution = "coarse",
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="joinData2Map_+3A_df">dF</code></td>
<td>
<p>R data frame with at least one column of polygon IDs and one
column of data</p>
</td></tr>
<tr><td><code id="joinData2Map_+3A_namemap">nameMap</code></td>
<td>
<p>the map to join the attribute data too</p>
</td></tr>
<tr><td><code id="joinData2Map_+3A_namejoinidmap">nameJoinIDMap</code></td>
<td>
<p>the name of the joinIDs in the map</p>
</td></tr>
<tr><td><code id="joinData2Map_+3A_namejoincolumndata">nameJoinColumnData</code></td>
<td>
<p>name of column in the data containing country
referencing</p>
</td></tr>
<tr><td><code id="joinData2Map_+3A_namenamecolumndata">nameNameColumnData</code></td>
<td>
<p>optional name of column in the data containing
polygon names (used in reporting of success/failure)</p>
</td></tr>
<tr><td><code id="joinData2Map_+3A_suggestforfailedcodes">suggestForFailedCodes</code></td>
<td>
<p>NOT YET ENABLED T/F whether you want system to
suggest for failed codes</p>
</td></tr>
<tr><td><code id="joinData2Map_+3A_projection">projection</code></td>
<td>
<p>DEPRECATED JUNE 2012</p>
</td></tr>
<tr><td><code id="joinData2Map_+3A_mapresolution">mapResolution</code></td>
<td>
<p>resolution of the borders in the internal map: options
'coarse','low', 'less islands'</p>
</td></tr>
<tr><td><code id="joinData2Map_+3A_verbose">verbose</code></td>
<td>
<p>if set to FALSE progress messages to console are restricted</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Joins user polygon attribute data provided in a 'data frame' to a map of
polygon boundaries.  The map can either be one stored in the package or
provided by the user.  Returns a spatialPolygonsDataFrame ready for plotting
using <code><a href="#topic+mapPolys">mapPolys</a></code>.  Reports join successes and failures.
</p>
<p>The user specifies the name of the column in their data containing polygon
referencing.
</p>
<p>The user can choose from different internal map resolutions.  Uses the
function <code><a href="#topic+getMap">getMap</a></code> to retrieve the map.
</p>


<h3>Value</h3>

<p>An R 'SpatialPolygonsDataFrame' [package &quot;sp&quot;] object with the data
joined to it
</p>


<h3>Author(s)</h3>

<p>andy south
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mapPolys">mapPolys</a></code>, <code><a href="#topic+getMap">getMap</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

## this example uses downloaded files
## to run it download the files
## and remove the comment symbols '#' from all the lines starting with a single '#'

## US states map downloaded from :
## http://www2.census.gov/cgi-bin/shapefiles2009/national-files

#inFile &lt;- 'tl_2009_us_stateec.shp'
#sPDF &lt;- readShapePoly(inFile)

##################
## use mapPolys to map the sPDF
#mapPolys(sPDF,nameColumnToPlot = "ALANDEC")
#mapPolys(sPDF,nameColumnToPlot = "AWATEREC",mapRegion='North America')

##################
## join some other data to it
## education data downloaded from here as xls then saved as csv
## http://nces.ed.gov/ccd/drpcompstatelvl.asp

#dataFile &lt;- 'SDR071A_xls.csv'
#dF &lt;- read.csv(dataFile,as.is=TRUE)
#str(dF)
## STATENAME
## DRP912 Dropout Rate, Grades 9 through 12

## joining the data to the map
## based upon state names (column NAMEEC in map, and STATENAME in the data)
#sPDF2 &lt;- joinData2Map(dF
#        , nameMap = sPDF
#        , nameJoinIDMap = "NAMEEC"
#        , nameJoinColumnData = "STATENAME")

#################
## plot one of the attribute variables
#mapDevice()# to set nice shape map window
#mapPolys(sPDF2,nameColumnToPlot = "DRP912",mapRegion='North America')


</code></pre>

<hr>
<h2 id='labelCountries'>to print country labels on a world map</h2><span id='topic+labelCountries'></span>

<h3>Description</h3>

<p>Given no arguments it will print country names stored in the 'NAME' column
of <code><a href="#topic+getMap">getMap</a></code> onto an existing map at the centroids of each
country polygon, stored in the 'LAT' and 'LON' columns.  Alternatively the
user can specifiy a data frame or SpatialPolygonsDataFrame in which case
they need to define the column containing the country names
(nameCountryColumn) and optionally a 2nd attribute column to print
(nameColumnToPlot).  First you need to create a map plot, for example using
<code><a href="#topic+mapCountryData">mapCountryData</a></code> or <code><a href="#topic+mapBubbles">mapBubbles</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>labelCountries(
  dF = "",
  nameCountryColumn = "NAME",
  nameX = "LON",
  nameY = "LAT",
  nameColumnToPlot = "",
  col = "grey",
  cex = 0.8,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="labelCountries_+3A_df">dF</code></td>
<td>
<p>dataframe or SpatialPolygonsDataFrame</p>
</td></tr>
<tr><td><code id="labelCountries_+3A_namecountrycolumn">nameCountryColumn</code></td>
<td>
<p>name of column containing country names to be
printed on the map (could also be set to any other column in the dataframe)</p>
</td></tr>
<tr><td><code id="labelCountries_+3A_namex">nameX</code></td>
<td>
<p>name of column containing the X variable (longitude), not
needed if dF is a SpatialPolygonsDataFrame</p>
</td></tr>
<tr><td><code id="labelCountries_+3A_namey">nameY</code></td>
<td>
<p>name of column containing the Y variable (lattitude), not
needed if dF is a SpatialPolygonsDataFrame</p>
</td></tr>
<tr><td><code id="labelCountries_+3A_namecolumntoplot">nameColumnToPlot</code></td>
<td>
<p>name of an attribute column in the data frame the
value of which will be appended to the country names</p>
</td></tr>
<tr><td><code id="labelCountries_+3A_col">col</code></td>
<td>
<p>colour for labels, default 'grey', can be e.g.
rgb(1,1,0,alpha=0.5)</p>
</td></tr>
<tr><td><code id="labelCountries_+3A_cex">cex</code></td>
<td>
<p>sizing of labels, default = 0.8</p>
</td></tr>
<tr><td><code id="labelCountries_+3A_...">...</code></td>
<td>
<p>other parameters that can be passed to text(), e.g. pos=4 to
right, (1=below, 2=left, 3=above)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>nothing
</p>


<h3>Author(s)</h3>

<p>andy south
</p>


<h3>See Also</h3>

<p><code><a href="#topic+identifyCountries">identifyCountries</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
mapCountryData()
labelCountries()

labelCountries(nameColumnToPlot = "POP_EST")


</code></pre>

<hr>
<h2 id='mapBars'>function to produce bar plots on a map</h2><span id='topic+mapBars'></span>

<h3>Description</h3>

<p>The function will produce a map with bars centred on country centroids (or
other chosen points). The length of the bars is determined by the sum of the
attribute columns and each section is coloured.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mapBars(
  dF = "",
  nameX = "longitude",
  nameY = "latitude",
  nameZs = c(names(dF)[3], names(dF)[4]),
  zColours = c(1:length(nameZs)),
  barWidth = 1,
  barOrient = "vert",
  barRelative = TRUE,
  ratio = 1,
  addCatLegend = TRUE,
  addSizeLegend = TRUE,
  symbolSize = 1,
  maxZVal = NA,
  xlim = NA,
  ylim = NA,
  mapRegion = "world",
  borderCol = "grey",
  oceanCol = NA,
  landCol = NA,
  add = FALSE,
  main = "",
  lwd = 0.5,
  lwdSymbols = 1,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mapBars_+3A_df">dF</code></td>
<td>
<p>data frame or SpatialPolygonsDataFrame</p>
</td></tr>
<tr><td><code id="mapBars_+3A_namex">nameX</code></td>
<td>
<p>name of column containing the X variable (longitude), not
needed if dF is a SpatialPolygonsDataFrame</p>
</td></tr>
<tr><td><code id="mapBars_+3A_namey">nameY</code></td>
<td>
<p>name of column containing the Y variable (lattitude), not
needed if dF is a SpatialPolygonsDataFrame</p>
</td></tr>
<tr><td><code id="mapBars_+3A_namezs">nameZs</code></td>
<td>
<p>name of columns containing numeric variables to determine bar
sections</p>
</td></tr>
<tr><td><code id="mapBars_+3A_zcolours">zColours</code></td>
<td>
<p>colours to apply to the bar section for each attribute
column</p>
</td></tr>
<tr><td><code id="mapBars_+3A_barwidth">barWidth</code></td>
<td>
<p>multiple for the width of bar symbols, relative to barOrient
see below</p>
</td></tr>
<tr><td><code id="mapBars_+3A_barorient">barOrient</code></td>
<td>
<p>orientation of bars, options 'horiz' and 'vert'</p>
</td></tr>
<tr><td><code id="mapBars_+3A_barrelative">barRelative</code></td>
<td>
<p>default is TRUE, each variable (column) is scaled to it's
maximum value</p>
</td></tr>
<tr><td><code id="mapBars_+3A_ratio">ratio</code></td>
<td>
<p>the ratio of Y to N in the output map, set to 1 as default</p>
</td></tr>
<tr><td><code id="mapBars_+3A_addcatlegend">addCatLegend</code></td>
<td>
<p>whether to add a legend for categories</p>
</td></tr>
<tr><td><code id="mapBars_+3A_addsizelegend">addSizeLegend</code></td>
<td>
<p>whether to add a legend for symbol size</p>
</td></tr>
<tr><td><code id="mapBars_+3A_symbolsize">symbolSize</code></td>
<td>
<p>multiplier of default symbol size</p>
</td></tr>
<tr><td><code id="mapBars_+3A_maxzval">maxZVal</code></td>
<td>
<p>the attribute value corresponding to the maximum symbol size,
this can be used to set the scaling the same between multiple plots</p>
</td></tr>
<tr><td><code id="mapBars_+3A_xlim">xlim</code></td>
<td>
<p>map extents c(west,east), can be overidden by mapRegion</p>
</td></tr>
<tr><td><code id="mapBars_+3A_ylim">ylim</code></td>
<td>
<p>map extents c(south,north), can be overidden by mapRegion</p>
</td></tr>
<tr><td><code id="mapBars_+3A_mapregion">mapRegion</code></td>
<td>
<p>a country name from getMap()[['NAME']] or
'world','africa','oceania','eurasia','uk' sets map extents, overrides
xlim,ylim</p>
</td></tr>
<tr><td><code id="mapBars_+3A_bordercol">borderCol</code></td>
<td>
<p>the colour for country borders</p>
</td></tr>
<tr><td><code id="mapBars_+3A_oceancol">oceanCol</code></td>
<td>
<p>a colour for the ocean</p>
</td></tr>
<tr><td><code id="mapBars_+3A_landcol">landCol</code></td>
<td>
<p>a colour to fill countries</p>
</td></tr>
<tr><td><code id="mapBars_+3A_add">add</code></td>
<td>
<p>whether to add the symbols to an existing map, TRUE/FALSE</p>
</td></tr>
<tr><td><code id="mapBars_+3A_main">main</code></td>
<td>
<p>title for the map</p>
</td></tr>
<tr><td><code id="mapBars_+3A_lwd">lwd</code></td>
<td>
<p>line width for country borders</p>
</td></tr>
<tr><td><code id="mapBars_+3A_lwdsymbols">lwdSymbols</code></td>
<td>
<p>line width for symbols</p>
</td></tr>
<tr><td><code id="mapBars_+3A_...">...</code></td>
<td>
<p>any extra arguments to points()</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Horizontal or vertical bars can be achieved by using the barOrient argument
'horiz' or 'vert'.
</p>


<h3>Value</h3>

<p>currently doesn't return anything
</p>


<h3>Author(s)</h3>

<p>andy south
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

#getting example data
dF &lt;- getMap()@data 
   
mapBars( dF,nameX="LON", nameY="LAT",nameZs=c('POP_EST','GDP_MD_EST') )
mapBars( dF,nameX="LON", nameY="LAT",nameZs=c('POP_EST','GDP_MD_EST'), mapRegion='africa' )
mapBars( dF,nameX="LON", nameY="LAT",nameZs=c('POP_EST','GDP_MD_EST'), 
 mapRegion='africa', symbolSize=20 )
mapBars( dF,nameX="LON", nameY="LAT",nameZs=c('POP_EST','GDP_MD_EST'), mapRegion='africa', 
 symbolSize=20, barOrient = 'horiz' )


# this does work too
#mapBars( dF,nameX="LON", nameY="LAT" 
#       , nameZs=c('POP_EST','GDP_MD_EST')
#       , mapRegion='africa'
#       , symbolSize=4 )       

  


</code></pre>

<hr>
<h2 id='mapBubbles'>function to produce bubble plots on a map, size and colour determined by
attribute data</h2><span id='topic+mapBubbles'></span>

<h3>Description</h3>

<p>The function will produce a map with bubbles (circles) centred on country
centroids (or other chosen points). Bubbles can be sized and coloured
according to specified attribute values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mapBubbles(
  dF = "",
  nameX = "longitude",
  nameY = "latitude",
  nameZSize = "",
  nameZColour = "",
  fill = TRUE,
  pch = 21,
  symbolSize = 1,
  maxZVal = NA,
  main = nameZSize,
  numCats = 5,
  catMethod = "categorical",
  colourPalette = "heat",
  xlim = NA,
  ylim = NA,
  mapRegion = "world",
  borderCol = "grey",
  oceanCol = NA,
  landCol = NA,
  addLegend = TRUE,
  legendBg = "white",
  legendVals = "",
  legendPos = "bottomright",
  legendHoriz = FALSE,
  legendTitle = nameZSize,
  addColourLegend = TRUE,
  colourLegendPos = "bottomleft",
  colourLegendTitle = nameZColour,
  add = FALSE,
  plotZeroVals = TRUE,
  lwd = 0.5,
  lwdSymbols = 1,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mapBubbles_+3A_df">dF</code></td>
<td>
<p>data frame or SpatialPolygonsDataFrame</p>
</td></tr>
<tr><td><code id="mapBubbles_+3A_namex">nameX</code></td>
<td>
<p>name of column containing the X variable (longitude), not
needed if dF is a SpatialPolygonsDataFrame</p>
</td></tr>
<tr><td><code id="mapBubbles_+3A_namey">nameY</code></td>
<td>
<p>name of column containing the Y variable (lattitude), not
needed if dF is a SpatialPolygonsDataFrame</p>
</td></tr>
<tr><td><code id="mapBubbles_+3A_namezsize">nameZSize</code></td>
<td>
<p>name of column containing numeric variable to set symbol
size</p>
</td></tr>
<tr><td><code id="mapBubbles_+3A_namezcolour">nameZColour</code></td>
<td>
<p>name of column containing variable to set symbol colour</p>
</td></tr>
<tr><td><code id="mapBubbles_+3A_fill">fill</code></td>
<td>
<p>whether or not to fill symbols TRUE/FALSE</p>
</td></tr>
<tr><td><code id="mapBubbles_+3A_pch">pch</code></td>
<td>
<p>symbol type, default of 21 for circles, will work with other
filled symbol types e.g. 22=square, 23=diamond, 24=triangle</p>
</td></tr>
<tr><td><code id="mapBubbles_+3A_symbolsize">symbolSize</code></td>
<td>
<p>multiplier of default symbol size</p>
</td></tr>
<tr><td><code id="mapBubbles_+3A_maxzval">maxZVal</code></td>
<td>
<p>the attribute value corresponding to the maximum symbol size,
this can be used to set the scaling the same between multiple plots</p>
</td></tr>
<tr><td><code id="mapBubbles_+3A_main">main</code></td>
<td>
<p>title for the map, set to nameZSize by default</p>
</td></tr>
<tr><td><code id="mapBubbles_+3A_numcats">numCats</code></td>
<td>
<p>number of categories to put the data in, may be modified if
this number is incompatible with the catMethod chosen</p>
</td></tr>
<tr><td><code id="mapBubbles_+3A_catmethod">catMethod</code></td>
<td>
<p>method for categorisation of data &quot;pretty&quot;, &quot;fixedWidth&quot;,
&quot;diverging&quot;, &quot;logFixedWidth&quot;, &quot;quantiles&quot;, &quot;categorical&quot;, or a numeric
vector defining breaks</p>
</td></tr>
<tr><td><code id="mapBubbles_+3A_colourpalette">colourPalette</code></td>
<td>
<p>a string describing the colour palette to use, choice
of : </p>
 <ol>
<li><p> =&quot;palette&quot; for the current palette </p>
</li>
<li><p> a vector of
valid colours, e.g. =c('red','white','blue') or output from RColourBrewer
</p>
</li>
<li><p> = one of &quot;heat&quot;, &quot;diverging&quot;, &quot;white2Black&quot;, &quot;black2White&quot;, &quot;topo&quot;,
&quot;rainbow&quot;, &quot;terrain&quot;, &quot;negpos8&quot;, &quot;negpos9&quot; </p>
</li></ol>
</td></tr>
<tr><td><code id="mapBubbles_+3A_xlim">xlim</code></td>
<td>
<p>map extents c(west,east), can be overidden by mapRegion</p>
</td></tr>
<tr><td><code id="mapBubbles_+3A_ylim">ylim</code></td>
<td>
<p>map extents c(south,north), can be overidden by mapRegion</p>
</td></tr>
<tr><td><code id="mapBubbles_+3A_mapregion">mapRegion</code></td>
<td>
<p>a country name from getMap()$NAME or
'world','africa','oceania','eurasia','uk' sets map extents, overrides
xlim,ylim</p>
</td></tr>
<tr><td><code id="mapBubbles_+3A_bordercol">borderCol</code></td>
<td>
<p>the colour for country borders</p>
</td></tr>
<tr><td><code id="mapBubbles_+3A_oceancol">oceanCol</code></td>
<td>
<p>a colour for the ocean</p>
</td></tr>
<tr><td><code id="mapBubbles_+3A_landcol">landCol</code></td>
<td>
<p>a colour to fill countries</p>
</td></tr>
<tr><td><code id="mapBubbles_+3A_addlegend">addLegend</code></td>
<td>
<p>whether to add a legend for symbol sizes</p>
</td></tr>
<tr><td><code id="mapBubbles_+3A_legendbg">legendBg</code></td>
<td>
<p>background colour for the legend, NA=transparent</p>
</td></tr>
<tr><td><code id="mapBubbles_+3A_legendvals">legendVals</code></td>
<td>
<p>allows user to set values and hence symbol sizing in legend</p>
</td></tr>
<tr><td><code id="mapBubbles_+3A_legendpos">legendPos</code></td>
<td>
<p>positioning of legend e.g. 'bottomleft', 'topright'</p>
</td></tr>
<tr><td><code id="mapBubbles_+3A_legendhoriz">legendHoriz</code></td>
<td>
<p>whether to arrange legend elements horizontally
TRUE/FALSE</p>
</td></tr>
<tr><td><code id="mapBubbles_+3A_legendtitle">legendTitle</code></td>
<td>
<p>title for the symbol size legend</p>
</td></tr>
<tr><td><code id="mapBubbles_+3A_addcolourlegend">addColourLegend</code></td>
<td>
<p>whether to add a legend for symbol colour</p>
</td></tr>
<tr><td><code id="mapBubbles_+3A_colourlegendpos">colourLegendPos</code></td>
<td>
<p>positioning of colour legend e.g. 'bottomleft',
'topright'</p>
</td></tr>
<tr><td><code id="mapBubbles_+3A_colourlegendtitle">colourLegendTitle</code></td>
<td>
<p>title for the colour size legend</p>
</td></tr>
<tr><td><code id="mapBubbles_+3A_add">add</code></td>
<td>
<p>whether to add the symbols to an existing map, TRUE/FALSE</p>
</td></tr>
<tr><td><code id="mapBubbles_+3A_plotzerovals">plotZeroVals</code></td>
<td>
<p>whether to plot zero values as a cross, TRUE/FALSE</p>
</td></tr>
<tr><td><code id="mapBubbles_+3A_lwd">lwd</code></td>
<td>
<p>line width for country borders</p>
</td></tr>
<tr><td><code id="mapBubbles_+3A_lwdsymbols">lwdSymbols</code></td>
<td>
<p>line width for symbols</p>
</td></tr>
<tr><td><code id="mapBubbles_+3A_...">...</code></td>
<td>
<p>any extra arguments to points()</p>
</td></tr>
</table>


<h3>Details</h3>

<p>By default separate legends are added fro symbol size and colouring on
either side of the plot, these can be modified by altering legend
parameters.
</p>


<h3>Value</h3>

<p>currently doesn't return anything
</p>


<h3>Author(s)</h3>

<p>andy south
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
mapBubbles()
#square symbols
mapBubbles(pch=22)

mapBubbles(dF=getMap(), nameZSize="POP_EST", nameZColour="GEO3")

#change colour
mapBubbles(dF=getMap(), nameZSize="POP_EST", nameZColour="GEO3"
          ,colourPalette='rainbow', oceanCol='lightblue', landCol='wheat') 


data("countryExData",envir=environment(),package="rworldmap")
sPDF &lt;- joinCountryData2Map(countryExData,joinCode = "ISO3"
                           ,nameJoinColumn = "ISO3V10")
                           
mapBubbles(sPDF, nameZSize="POP_EST",nameZColour="BIODIVERSITY"
          ,colourPalette='topo',numCats=5,catMethod="quantiles")

#filled bubbles with set transparency
mapBubbles(fill=TRUE,colourPalette=adjustcolor(palette(), alpha.f = 0.5))
#add bubble edge of a single colour (also with option to set transparency
mapBubbles(nameZColour = adjustcolor('black', alpha.f = 0.7), fill=FALSE, add=TRUE)

</code></pre>

<hr>
<h2 id='mapByRegion'>Produce maps of regional level data from country level data</h2><span id='topic+mapByRegion'></span>

<h3>Description</h3>

<p>This function will produce maps of regional statistics by aggregating
country level data. For example mapping the total population of Asia,
Europe,etc, from country level population data. As well as sums, other
functions can be used, like mean, median, min, max, etc. There are currently
8 choices of region and 4 choices of country code.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mapByRegion(
  inFile,
  nameDataColumn,
  joinCode,
  nameJoinColumn,
  regionType = "",
  FUN = "mean",
  na.rm = TRUE,
  mapTitle = "",
  lwd = 0.5,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mapByRegion_+3A_infile">inFile</code></td>
<td>
<p>a data frame</p>
</td></tr>
<tr><td><code id="mapByRegion_+3A_namedatacolumn">nameDataColumn</code></td>
<td>
<p>The name of a column of inFile. This is data is
aggregated by FUN</p>
</td></tr>
<tr><td><code id="mapByRegion_+3A_joincode">joinCode</code></td>
<td>
<p>The type of code to join with. Must be one of: &quot;ISO2&quot;,
&quot;ISO3&quot;, &quot;Numeric&quot; or &quot;FIPS&quot;</p>
</td></tr>
<tr><td><code id="mapByRegion_+3A_namejoincolumn">nameJoinColumn</code></td>
<td>
<p>The name of a column of inFile. Contains joining
codes.</p>
</td></tr>
<tr><td><code id="mapByRegion_+3A_regiontype">regionType</code></td>
<td>
<p>Must be one of: &quot;GEO3&quot;, &quot;GEO3major&quot;, &quot;IMAGE24&quot;, &quot;GLOCAF&quot;,
&quot;Stern&quot;, &quot;SRES&quot;, &quot;SRESmajor&quot;,&quot;GBD&quot;,&quot;AVOIDname&quot;</p>
</td></tr>
<tr><td><code id="mapByRegion_+3A_fun">FUN</code></td>
<td>
<p>A function to apply to each region</p>
</td></tr>
<tr><td><code id="mapByRegion_+3A_na.rm">na.rm</code></td>
<td>
<p>Only used for certain values of FUN. See details section below.</p>
</td></tr>
<tr><td><code id="mapByRegion_+3A_maptitle">mapTitle</code></td>
<td>
<p>a title to be printed above the map</p>
</td></tr>
<tr><td><code id="mapByRegion_+3A_lwd">lwd</code></td>
<td>
<p>line width for country borders</p>
</td></tr>
<tr><td><code id="mapByRegion_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to <code><a href="#topic+mapCountryData">mapCountryData</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function is very similar to country2Region. The first difference is that
the output is a map, rather than statistics.  The second is the behaviour of
extra arguments. In country2Region the extra arguments go to FUN, here they
go to mapCountryData.
</p>
<p>The na.rm argument is used when FUN has one of the following values: &quot;mean&quot;,
&quot;min&quot;, &quot;max&quot;, &quot;median&quot;, &quot;range&quot;, &quot;var&quot;, &quot;sd&quot;, &quot;mad&quot; or &quot;IQR&quot;. This reduces
the problem of not being able to supply extra arguments to FUN.
</p>


<h3>Value</h3>

<p>invisibly returns a list containing the data and main options used
for the map, the list can be passed to <code><a href="#topic+addMapLegend">addMapLegend</a></code> along with
additional options to allow greater flexibility in legend creation.
</p>


<h3>See Also</h3>

<p>An alternative tool to <code><a href="#topic+country2Region">country2Region</a></code>. The plotting
is done by <code><a href="#topic+mapCountryData">mapCountryData</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(countryExData)

mapByRegion(inFile=countryExData
		        ,nameDataColumn="CLIMATE"
		        ,joinCode="ISO3"
		        ,nameJoinColumn="ISO3V10"
		        ,regionType="Stern"
	         	,FUN='mean'
	         	)


</code></pre>

<hr>
<h2 id='mapCountryData'>Map country-level data.</h2><span id='topic+mapCountryData'></span>

<h3>Description</h3>

<p>Draw a map of country-level data, allowing countries to be coloured, from an
object created in <code><a href="#topic+joinCountryData2Map">joinCountryData2Map</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mapCountryData(
  mapToPlot = "",
  nameColumnToPlot = "",
  numCats = 7,
  xlim = NA,
  ylim = NA,
  mapRegion = "world",
  catMethod = "quantiles",
  colourPalette = "heat",
  addLegend = TRUE,
  borderCol = "grey",
  mapTitle = "columnName",
  oceanCol = NA,
  aspect = 1,
  missingCountryCol = NA,
  add = FALSE,
  nameColumnToHatch = "",
  lwd = 0.5
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mapCountryData_+3A_maptoplot">mapToPlot</code></td>
<td>
<p>a spatial polygons dataframe from joinCountryData2Map()
containing country polygons and data, if none specified an internal example
data is used</p>
</td></tr>
<tr><td><code id="mapCountryData_+3A_namecolumntoplot">nameColumnToPlot</code></td>
<td>
<p>name of column containing the data you want to plot</p>
</td></tr>
<tr><td><code id="mapCountryData_+3A_numcats">numCats</code></td>
<td>
<p>number of categories to put the data in, may be modified if
this number is incompatible with the catMethod chosen</p>
</td></tr>
<tr><td><code id="mapCountryData_+3A_xlim">xlim</code></td>
<td>
<p>map extents c(west,east), can be overidden by mapRegion</p>
</td></tr>
<tr><td><code id="mapCountryData_+3A_ylim">ylim</code></td>
<td>
<p>map extents c(south,north), can be overidden by mapRegion</p>
</td></tr>
<tr><td><code id="mapCountryData_+3A_mapregion">mapRegion</code></td>
<td>
<p>a country name from getMap()[['NAME']] or
'world','africa','oceania','eurasia','uk' sets map extents, overrides
xlim,ylim</p>
</td></tr>
<tr><td><code id="mapCountryData_+3A_catmethod">catMethod</code></td>
<td>
<p>method for categorisation of data : </p>

<ol>
<li><p> &quot;categorical&quot; - each unique value is treated as a separate category
</p>
</li>
<li><p> for numeric data : &quot;pretty&quot;, &quot;fixedWidth&quot;, &quot;diverging&quot;,
&quot;logFixedWidth&quot;, &quot;quantiles&quot; </p>
</li>
<li><p> a numeric vector defining breaks e.g.
c(0:5), note that a value of 2 goes into 1-2 not 2-3, uses
cut(include.lowest=TRUE) </p>
</li></ol>
</td></tr>
<tr><td><code id="mapCountryData_+3A_colourpalette">colourPalette</code></td>
<td>
<p>string describing the colour palette to use, choice of:
</p>
 <ol>
<li><p> &quot;palette&quot; for the current palette </p>
</li>
<li><p> a vector of valid
colours, e.g. =c('red','white','blue') or output from RColourBrewer </p>
</li>
<li><p> one
of &quot;heat&quot;, &quot;diverging&quot;, &quot;white2Black&quot;, &quot;black2White&quot;, &quot;topo&quot;, &quot;rainbow&quot;,
&quot;terrain&quot;, &quot;negpos8&quot;, &quot;negpos9&quot; </p>
</li></ol>
</td></tr>
<tr><td><code id="mapCountryData_+3A_addlegend">addLegend</code></td>
<td>
<p>whether to add a legend or not</p>
</td></tr>
<tr><td><code id="mapCountryData_+3A_bordercol">borderCol</code></td>
<td>
<p>the colour for country borders</p>
</td></tr>
<tr><td><code id="mapCountryData_+3A_maptitle">mapTitle</code></td>
<td>
<p>title to add to the map, any string or 'columnName' to set
it to the name of the data column</p>
</td></tr>
<tr><td><code id="mapCountryData_+3A_oceancol">oceanCol</code></td>
<td>
<p>a colour for the ocean</p>
</td></tr>
<tr><td><code id="mapCountryData_+3A_aspect">aspect</code></td>
<td>
<p>aspect for the map, defaults to 1, if set to 'variable' uses
same method as plot.Spatial in sp</p>
</td></tr>
<tr><td><code id="mapCountryData_+3A_missingcountrycol">missingCountryCol</code></td>
<td>
<p>a colour for missing countries</p>
</td></tr>
<tr><td><code id="mapCountryData_+3A_add">add</code></td>
<td>
<p>whether to add this map on top of an existing map, TRUE/FALSE</p>
</td></tr>
<tr><td><code id="mapCountryData_+3A_namecolumntohatch">nameColumnToHatch</code></td>
<td>
<p>allows hatching of country fills (e.g. to represent
uncertainty) , specify a column containing numeric data , highest values
will be solid and lower values will have a decreasing density of hatching ,
new feature more documentation will be added soon</p>
</td></tr>
<tr><td><code id="mapCountryData_+3A_lwd">lwd</code></td>
<td>
<p>line width for country borders</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Certain catMethod and colourPalette options go well together. e.g.
&quot;diverging&quot; and &quot;diverging&quot;, &quot;categorical&quot; and &quot;rainbow&quot;
</p>
<p>There are two styles of legend available.  If catMethod='categorical' or the
packages fields and spam are not installed a simple legend with coloured
boxes is created. Otherwise a colour bar legend is created. Finer control
can be achieved by <code><a href="#topic+addMapLegendBoxes">addMapLegendBoxes</a></code> or
<code><a href="#topic+addMapLegend">addMapLegend</a></code> repectively.
</p>


<h3>Value</h3>

<p>invisibly returns a list containing the data and main options used
for the map, the list can be passed to <code><a href="#topic+addMapLegend">addMapLegend</a></code> or
<code><a href="#topic+addMapLegendBoxes">addMapLegendBoxes</a></code> along with additional options to allow
greater flexibility in legend creation.
</p>


<h3>Warning</h3>

<p>will generate unhelpful errors in data categorisation if
inappropriate options are chosen, e.g. with catMethod:Quantiles if numCats
too high so that unique breaks cannot be defined.
</p>


<h3>Author(s)</h3>

<p>andy south
</p>


<h3>See Also</h3>

<p>classInt, RColorBrewer
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
mapCountryData()
data("countryExData",envir=environment(),package="rworldmap")
sPDF &lt;- joinCountryData2Map(countryExData
              , joinCode = "ISO3"
              , nameJoinColumn = "ISO3V10"
              )
mapCountryData( sPDF
              , nameColumnToPlot="BIODIVERSITY" 
              )
              
#user defined map colour scheme for categorical data              
mapParams &lt;- mapCountryData(nameColumnToPlot='GEO3major'
              , catMethod='categorical'
              , addLegend='FALSE'
              , colourPalette=c('white','green','red','yellow','blue','black') 
              )
#changing legendText
mapParams$legendText &lt;- c('antarctic','africa','oceania'
                         ,'americas','s.asia','eurasia')              
do.call( addMapLegendBoxes, c(mapParams,x='bottom',title="Region",horiz=TRUE))

##showing how rworldmap can be used with the classInt and RColorBrewer packages
library(classInt)
library(RColorBrewer)
#getting example data and joining to a map
data("countryExData",envir=environment(),package="rworldmap")
sPDF &lt;- joinCountryData2Map(countryExData,joinCode = "ISO3"
                           ,nameJoinColumn = "ISO3V10")
#getting class intervals using a 'jenks' classification in classInt package
classInt &lt;- classIntervals( sPDF$EPI, n=5, style="jenks")
catMethod = classInt$brks
#getting a colour scheme from the RColorBrewer package
colourPalette &lt;- brewer.pal(5,'RdPu')
#calling mapCountryData with the parameters from classInt and RColorBrewer
mapParams &lt;- mapCountryData( sPDF, nameColumnToPlot="EPI", addLegend=FALSE
                           , catMethod = catMethod, colourPalette=colourPalette )
do.call(addMapLegend, c(mapParams
                       ,legendLabels="all"
                       ,legendWidth=0.5
                       ,legendIntervals="data"))

              


</code></pre>

<hr>
<h2 id='mapDevice'>Creates a plot device set up for maps</h2><span id='topic+mapDevice'></span>

<h3>Description</h3>

<p>Creates a plot device suited for rworldmap plotting functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mapDevice(
  device = "dev.new",
  rows = 1,
  columns = 1,
  plotOrder = "rows",
  width = NULL,
  height = NULL,
  titleSpace = NULL,
  mai = c(0, 0, 0.2, 0),
  mgp = c(0, 0, 0),
  xaxs = "i",
  yaxs = "i",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mapDevice_+3A_device">device</code></td>
<td>
<p>Character string which controls the type of plot default.  The
default uses your standard plot device. Giving the name of a plotting device
function will use that instead. e.g. &quot;pdf&quot;, &quot;png&quot;, etc.</p>
</td></tr>
<tr><td><code id="mapDevice_+3A_rows">rows</code></td>
<td>
<p>The number of rows. Default 1</p>
</td></tr>
<tr><td><code id="mapDevice_+3A_columns">columns</code></td>
<td>
<p>The number of columns. Default 1</p>
</td></tr>
<tr><td><code id="mapDevice_+3A_plotorder">plotOrder</code></td>
<td>
<p>Option of 'rows' or 'columns'. For multiple plots whether
to plot in row or column order. However, note that addMapLegend can have the
effect of reverting order to rows.</p>
</td></tr>
<tr><td><code id="mapDevice_+3A_width">width</code></td>
<td>
<p>The width of a single plot. This includes the margins. If you
do not specify both width and height, suitable values will be calculated</p>
</td></tr>
<tr><td><code id="mapDevice_+3A_height">height</code></td>
<td>
<p>The height of a single plot. This includes the margins. If you
do not specify both width and height, suitable values will be calculated</p>
</td></tr>
<tr><td><code id="mapDevice_+3A_titlespace">titleSpace</code></td>
<td>
<p>The height in inches of the gap at the plot.</p>
</td></tr>
<tr><td><code id="mapDevice_+3A_mai">mai</code></td>
<td>
<p>The margin sizes in inches. If titleSpace is given this overrides
mai[3].</p>
</td></tr>
<tr><td><code id="mapDevice_+3A_mgp">mgp</code></td>
<td>
<p>As per par(mgp) in the graphics package</p>
</td></tr>
<tr><td><code id="mapDevice_+3A_xaxs">xaxs</code></td>
<td>
<p>As per par(xaxs) in the graphics package</p>
</td></tr>
<tr><td><code id="mapDevice_+3A_yaxs">yaxs</code></td>
<td>
<p>As per par(yaxs) in the graphics package</p>
</td></tr>
<tr><td><code id="mapDevice_+3A_...">...</code></td>
<td>
<p>Further arguments to the device function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Used for the side effect of creating a plot device, and setting
graphical parameters for the device.
</p>


<h3>See Also</h3>

<p>mapCountryData,mapGridAscii
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
#Basic Usage
mapDevice()
mapCountryData()

#2 by 2 plot
mapDevice(rows=2,columns=2)
columns&lt;-c("BIODIVERSITY","EPI","ENVHEALTH","Population2005")
for(i in columns){
 mapCountryData(nameColumnToPlot=i)
}
#Creating a pdf that is 5 inches wide
mapDevice(device="pdf",width=5,file=tempfile())
mapCountryData()
dev.off()


## End(Not run)

</code></pre>

<hr>
<h2 id='mapGriddedData'>Produce maps of global gridded data at half degree resolution</h2><span id='topic+mapGriddedData'></span>

<h3>Description</h3>

<p>Produce maps of global gridded data at half degree resolution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mapGriddedData(
  dataset = "",
  nameColumnToPlot = "",
  numCats = 5,
  catMethod = "quantiles",
  colourPalette = "heat",
  xlim = c(-180, 180),
  ylim = c(-80, 90),
  mapRegion = "world",
  addLegend = TRUE,
  addBorders = "coarse",
  borderCol = "grey",
  oceanCol = NA,
  landCol = NA,
  plotData = TRUE,
  aspect = 1,
  lwd = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mapGriddedData_+3A_dataset">dataset</code></td>
<td>
<p>gridded data either as a : </p>
 <ol>
<li>
<p>SpatialGridDataFrame (R object defined in package sp) </p>
</li>
<li><p> file name of a
GridAscii file - this is an Esri format </p>
</li>
<li><p> 2D R matrix or array (rows by
columns) </p>
</li></ol>
</td></tr>
<tr><td><code id="mapGriddedData_+3A_namecolumntoplot">nameColumnToPlot</code></td>
<td>
<p>name of column containing the data to plot</p>
</td></tr>
<tr><td><code id="mapGriddedData_+3A_numcats">numCats</code></td>
<td>
<p>number of categories to put the data in, may be overidden if
catMethod ='pretty'</p>
</td></tr>
<tr><td><code id="mapGriddedData_+3A_catmethod">catMethod</code></td>
<td>
<p>method for categorisation of data &quot;pretty&quot;,
&quot;fixedWidth&quot;,&quot;diverging&quot;, &quot;logFixedWidth&quot;,&quot;quantiles&quot;,&quot;categorical&quot;, or a
numeric vector defining breaks</p>
</td></tr>
<tr><td><code id="mapGriddedData_+3A_colourpalette">colourPalette</code></td>
<td>
<p>a string describing the colour palette to use, choice
of : </p>
 <ol>
<li><p> &quot;palette&quot; for the current palette </p>
</li>
<li><p> a vector of
valid colours, e.g. =c('red','white','blue') or output from RColourBrewer
</p>
</li>
<li><p> one of &quot;heat&quot;, &quot;diverging&quot;, &quot;white2Black&quot;, &quot;black2White&quot;, &quot;topo&quot;,
&quot;rainbow&quot;, &quot;terrain&quot;, &quot;negpos8&quot;, &quot;negpos9&quot; </p>
</li></ol>
</td></tr>
<tr><td><code id="mapGriddedData_+3A_xlim">xlim</code></td>
<td>
<p>map extents c(west,east), can be overidden by mapRegion</p>
</td></tr>
<tr><td><code id="mapGriddedData_+3A_ylim">ylim</code></td>
<td>
<p>map extents c(south,north), can be overidden by mapRegion</p>
</td></tr>
<tr><td><code id="mapGriddedData_+3A_mapregion">mapRegion</code></td>
<td>
<p>a country name from getMap()[['NAME']] or
'world','africa','oceania','eurasia','uk' sets map extents, overrides
xlim,ylim</p>
</td></tr>
<tr><td><code id="mapGriddedData_+3A_addlegend">addLegend</code></td>
<td>
<p>whether to add a legend or not</p>
</td></tr>
<tr><td><code id="mapGriddedData_+3A_addborders">addBorders</code></td>
<td>
<p>options for country borders, 'low','coarse' = low or
coarse resolution, 'coasts' = coasts only, 'none' or NA for none</p>
</td></tr>
<tr><td><code id="mapGriddedData_+3A_bordercol">borderCol</code></td>
<td>
<p>the colour for country borders</p>
</td></tr>
<tr><td><code id="mapGriddedData_+3A_oceancol">oceanCol</code></td>
<td>
<p>a colour for the ocean if the grid values are NA</p>
</td></tr>
<tr><td><code id="mapGriddedData_+3A_landcol">landCol</code></td>
<td>
<p>a colour to fill countries if the grid values are NA over
land</p>
</td></tr>
<tr><td><code id="mapGriddedData_+3A_plotdata">plotData</code></td>
<td>
<p>whether to plotData, if FALSE a legend can be added on its
own</p>
</td></tr>
<tr><td><code id="mapGriddedData_+3A_aspect">aspect</code></td>
<td>
<p>aspect for the map, defaults to 1, if set to 'variable' uses
same method as plot.Spatial in sp</p>
</td></tr>
<tr><td><code id="mapGriddedData_+3A_lwd">lwd</code></td>
<td>
<p>line width for country borders</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Plots a map of global half degree gridded data, allowing classification,
colours and regions to be set.
</p>
<p>Certain catMethod and colourPalette options go well together. e.g.
&quot;diverging&quot; and &quot;diverging&quot;, &quot;categorical&quot; and &quot;rainbow&quot;
</p>


<h3>Value</h3>

<p>invisibly returns a list containing the data and main options used
for the map, the list can be passed to <code><a href="#topic+addMapLegend">addMapLegend</a></code> along with
additional options to allow greater flexibility in legend creation.
</p>


<h3>Author(s)</h3>

<p>andy south
#@importFrom maptools readAsciiGrid
</p>


<h3>See Also</h3>

<p>classInt, RColorBrewer
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## mapping continuous data
data(gridExData,envir=environment(),package="rworldmap")
gridExData &lt;- get("gridExData")
mapGriddedData(gridExData)

## reclassing continuous data to categorical &amp; mapping
data(gridExData,envir=environment(),package="rworldmap")
#find quartile breaks
cutVector &lt;- quantile(gridExData@data[,1],na.rm=TRUE)
#classify the data to a factor
gridExData@data$categories &lt;- cut( gridExData@data[,1]
                                      , cutVector, include.lowest=TRUE)
#rename the categories
levels(gridExData@data$categories) &lt;- c('low', 'med', 'high', 'vhigh')
#mapping
mapGriddedData( gridExData, nameColumnToPlot= 'categories'
              , catMethod='categorical')



</code></pre>

<hr>
<h2 id='mapHalfDegreeGridToCountries'>Maps user half degree gridded data at country level by first aggregating.</h2><span id='topic+mapHalfDegreeGridToCountries'></span>

<h3>Description</h3>

<p>Maps user half degree gridded data at country level by first aggregating.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mapHalfDegreeGridToCountries(
  inFile = "",
  aggregateOption = "sum",
  nameCountryColumn = "",
  suggestForFailedCodes = FALSE,
  projection = NA,
  mapResolution = "low",
  numCats = 7,
  xlim = c(-160, 160),
  ylim = c(-80, 90),
  mapRegion = "world",
  catMethod = "quantiles",
  colourPalette = "heat",
  addLegend = TRUE,
  lwd = 0.5
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mapHalfDegreeGridToCountries_+3A_infile">inFile</code></td>
<td>
<p>either a gridascii filename or an sp SpatialGridDataFrame
object specifying a global half degree grid dataset, if none specified an
internal example data is used</p>
</td></tr>
<tr><td><code id="mapHalfDegreeGridToCountries_+3A_aggregateoption">aggregateOption</code></td>
<td>
<p>how to aggregate the data ('sum','mean','min','max')</p>
</td></tr>
<tr><td><code id="mapHalfDegreeGridToCountries_+3A_namecountrycolumn">nameCountryColumn</code></td>
<td>
<p>optional name of column containing country names
(used in reporting of success/failure)</p>
</td></tr>
<tr><td><code id="mapHalfDegreeGridToCountries_+3A_suggestforfailedcodes">suggestForFailedCodes</code></td>
<td>
<p>T/F whether you want system to suggest for
failed codes NOT YET WORKING</p>
</td></tr>
<tr><td><code id="mapHalfDegreeGridToCountries_+3A_projection">projection</code></td>
<td>
<p>deprecated june 2012</p>
</td></tr>
<tr><td><code id="mapHalfDegreeGridToCountries_+3A_mapresolution">mapResolution</code></td>
<td>
<p>options low, medium, only for projection='none'
initially</p>
</td></tr>
<tr><td><code id="mapHalfDegreeGridToCountries_+3A_numcats">numCats</code></td>
<td>
<p>number of categories, may be overided e.g. if catMethod
='pretty'</p>
</td></tr>
<tr><td><code id="mapHalfDegreeGridToCountries_+3A_xlim">xlim</code></td>
<td>
<p>map extents c(west,east), can be overidden by mapRegion</p>
</td></tr>
<tr><td><code id="mapHalfDegreeGridToCountries_+3A_ylim">ylim</code></td>
<td>
<p>map extents c(south,north), can be overidden by mapRegion</p>
</td></tr>
<tr><td><code id="mapHalfDegreeGridToCountries_+3A_mapregion">mapRegion</code></td>
<td>
<p>'world','africa','oceania','eurasia','uk' sets map extents,
overrides we,ea etc.</p>
</td></tr>
<tr><td><code id="mapHalfDegreeGridToCountries_+3A_catmethod">catMethod</code></td>
<td>
<p>method for categorisation of data &quot;pretty&quot;, any vector
defining breaks, &quot;fixedWidth&quot;,&quot;quantiles&quot;</p>
</td></tr>
<tr><td><code id="mapHalfDegreeGridToCountries_+3A_colourpalette">colourPalette</code></td>
<td>
<p>&quot;heat&quot;,&quot;white2Black&quot;,&quot;palette&quot;:for current palette</p>
</td></tr>
<tr><td><code id="mapHalfDegreeGridToCountries_+3A_addlegend">addLegend</code></td>
<td>
<p>whether to add a legend or not T/F</p>
</td></tr>
<tr><td><code id="mapHalfDegreeGridToCountries_+3A_lwd">lwd</code></td>
<td>
<p>line width for country borders</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Aggregates half degree gridded data to countries using the option specified
in 'aggregateOption' then maps at a country level.
</p>


<h3>Value</h3>

<p>invisibly returns a list containing the data and main options used
for the map, the list can be passed to <code><a href="#topic+addMapLegend">addMapLegend</a></code> along with
additional options to allow greater flexibility in legend creation.
</p>


<h3>Author(s)</h3>

<p>andy south
#@importFrom maptools readAsciiGrid
</p>


<h3>See Also</h3>

<p><code><a href="#topic+aggregateHalfDegreeGridToCountries">aggregateHalfDegreeGridToCountries</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

data(gridExData,envir=environment(),package="rworldmap")
gridExData &lt;- get("gridExData")
mapHalfDegreeGridToCountries(gridExData)             

#different aggregate option
mapHalfDegreeGridToCountries( gridExData, aggregateOption="mean" )


</code></pre>

<hr>
<h2 id='mapPies'>function to produce pie charts on a map</h2><span id='topic+mapPies'></span>

<h3>Description</h3>

<p>The function will produce a map with pie charts centred on country centroids
(or other chosen points). The size of the circles is determined by the sum
of the attribute columns and each section is coloured.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mapPies(
  dF,
  nameX = "LON",
  nameY = "LAT",
  nameZs = c(names(dF)[3], names(dF)[4]),
  zColours = c(1:length(nameZs)),
  ratio = 1,
  addCatLegend = TRUE,
  symbolSize = 1,
  maxZVal = NA,
  xlim = NA,
  ylim = NA,
  mapRegion = "world",
  borderCol = "grey",
  oceanCol = NA,
  landCol = NA,
  add = FALSE,
  main = "",
  lwd = 0.5,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mapPies_+3A_df">dF</code></td>
<td>
<p>data frame or SpatialPolygonsDataFrame</p>
</td></tr>
<tr><td><code id="mapPies_+3A_namex">nameX</code></td>
<td>
<p>name of column containing the X variable (longitude), not
needed if dF is a SpatialPolygonsDataFrame</p>
</td></tr>
<tr><td><code id="mapPies_+3A_namey">nameY</code></td>
<td>
<p>name of column containing the Y variable (latitude), not needed
if dF is a SpatialPolygonsDataFrame</p>
</td></tr>
<tr><td><code id="mapPies_+3A_namezs">nameZs</code></td>
<td>
<p>name of columns containing numeric variables to determine pie
sections</p>
</td></tr>
<tr><td><code id="mapPies_+3A_zcolours">zColours</code></td>
<td>
<p>colours to apply to the pie section for each attribute
column</p>
</td></tr>
<tr><td><code id="mapPies_+3A_ratio">ratio</code></td>
<td>
<p>the ratio of Y to N in the output map, set to 1 as default</p>
</td></tr>
<tr><td><code id="mapPies_+3A_addcatlegend">addCatLegend</code></td>
<td>
<p>whether to add a legend for categories</p>
</td></tr>
<tr><td><code id="mapPies_+3A_symbolsize">symbolSize</code></td>
<td>
<p>multiplier of default symbol size</p>
</td></tr>
<tr><td><code id="mapPies_+3A_maxzval">maxZVal</code></td>
<td>
<p>the attribute value corresponding to the maximum symbol size,
this can be used to set the scaling the same between multiple plots</p>
</td></tr>
<tr><td><code id="mapPies_+3A_xlim">xlim</code></td>
<td>
<p>map extents c(west,east), can be overidden by mapRegion</p>
</td></tr>
<tr><td><code id="mapPies_+3A_ylim">ylim</code></td>
<td>
<p>map extents c(south,north), can be overidden by mapRegion</p>
</td></tr>
<tr><td><code id="mapPies_+3A_mapregion">mapRegion</code></td>
<td>
<p>a country name from getMap()[['NAME']] or
'world','africa','oceania','eurasia','uk' sets map extents, overrides
xlim,ylim</p>
</td></tr>
<tr><td><code id="mapPies_+3A_bordercol">borderCol</code></td>
<td>
<p>the colour for country borders</p>
</td></tr>
<tr><td><code id="mapPies_+3A_oceancol">oceanCol</code></td>
<td>
<p>a colour for the ocean</p>
</td></tr>
<tr><td><code id="mapPies_+3A_landcol">landCol</code></td>
<td>
<p>a colour to fill countries</p>
</td></tr>
<tr><td><code id="mapPies_+3A_add">add</code></td>
<td>
<p>whether to add the symbols to an existing map, TRUE/FALSE</p>
</td></tr>
<tr><td><code id="mapPies_+3A_main">main</code></td>
<td>
<p>title for the map</p>
</td></tr>
<tr><td><code id="mapPies_+3A_lwd">lwd</code></td>
<td>
<p>line width for country borders</p>
</td></tr>
<tr><td><code id="mapPies_+3A_...">...</code></td>
<td>
<p>any extra arguments to points()</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Beware of creating plots that are difficult for the reader to interpret.
More than 3 or 4 categories may be too many.
</p>


<h3>Value</h3>

<p>currently doesn't return anything
</p>


<h3>Author(s)</h3>

<p>andy south
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

#getting example data
dF &lt;- getMap()@data  

## these examples repeat the same column in 'nameZs' 
## to show that equal sized pies are created  

#mapPies( dF,nameX="LON", nameY="LAT",nameZs=c('AREA','AREA') )

#mapPies( dF,nameX="LON", nameY="LAT",nameZs=c('AREA','AREA')
#       , mapRegion='africa' )

mapPies( dF,nameX="LON", nameY="LAT"
       , nameZs=c('POP_EST','POP_EST','POP_EST','POP_EST'),mapRegion='africa' )
  


</code></pre>

<hr>
<h2 id='mapPolys'>Map polygon data.</h2><span id='topic+mapPolys'></span>

<h3>Description</h3>

<p>Plot a map of polygons, from a spatialPolygonsDataFrame, coloured according
to one a specified attribute column.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mapPolys(
  mapToPlot = "",
  nameColumnToPlot = "",
  numCats = 7,
  xlim = NA,
  ylim = NA,
  mapRegion = "world",
  catMethod = "quantiles",
  colourPalette = "heat",
  addLegend = TRUE,
  borderCol = "grey",
  mapTitle = "columnName",
  oceanCol = NA,
  aspect = 1,
  missingCountryCol = NA,
  add = FALSE,
  lwd = 0.5
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mapPolys_+3A_maptoplot">mapToPlot</code></td>
<td>
<p>a spatial polygons dataframe (e.g. from joinData2Map())
containing polygons and associated data, if none specified an internal
example data is used</p>
</td></tr>
<tr><td><code id="mapPolys_+3A_namecolumntoplot">nameColumnToPlot</code></td>
<td>
<p>name of column containing the data you want to plot</p>
</td></tr>
<tr><td><code id="mapPolys_+3A_numcats">numCats</code></td>
<td>
<p>number of categories to put the data in, may be modified if
this number is incompatible with the catMethod chosen</p>
</td></tr>
<tr><td><code id="mapPolys_+3A_xlim">xlim</code></td>
<td>
<p>map extents c(west,east), can be overidden by mapRegion</p>
</td></tr>
<tr><td><code id="mapPolys_+3A_ylim">ylim</code></td>
<td>
<p>map extents c(south,north), can be overidden by mapRegion</p>
</td></tr>
<tr><td><code id="mapPolys_+3A_mapregion">mapRegion</code></td>
<td>
<p>a country name from getMap()[['NAME']] or
'world','africa','oceania','eurasia','uk' sets map extents, overrides
xlim,ylim</p>
</td></tr>
<tr><td><code id="mapPolys_+3A_catmethod">catMethod</code></td>
<td>
<p>for categorisation of data &quot;pretty&quot;, &quot;fixedWidth&quot;,
&quot;diverging&quot;, &quot;logFixedWidth&quot;, &quot;quantiles&quot;, &quot;categorical&quot;, or a numeric
vector defining breaks</p>
</td></tr>
<tr><td><code id="mapPolys_+3A_colourpalette">colourPalette</code></td>
<td>
<p>string describing the colour palette to use, choice of:
</p>
 <ol>
<li><p> &quot;palette&quot; for the current palette </p>
</li>
<li><p> a vector of valid
colours, e.g. =c('red','white','blue') or output from RColourBrewer </p>
</li>
<li><p> one
of &quot;heat&quot;, &quot;diverging&quot;, &quot;white2Black&quot;, &quot;black2White&quot;, &quot;topo&quot;, &quot;rainbow&quot;,
&quot;terrain&quot;, &quot;negpos8&quot;, &quot;negpos9&quot; </p>
</li></ol>
</td></tr>
<tr><td><code id="mapPolys_+3A_addlegend">addLegend</code></td>
<td>
<p>whether to add a legend or not</p>
</td></tr>
<tr><td><code id="mapPolys_+3A_bordercol">borderCol</code></td>
<td>
<p>the colour for country borders</p>
</td></tr>
<tr><td><code id="mapPolys_+3A_maptitle">mapTitle</code></td>
<td>
<p>title to add to the map, any string or 'columnName' to set
it to the name of the data column</p>
</td></tr>
<tr><td><code id="mapPolys_+3A_oceancol">oceanCol</code></td>
<td>
<p>a colour for the ocean</p>
</td></tr>
<tr><td><code id="mapPolys_+3A_aspect">aspect</code></td>
<td>
<p>aspect for the map, defaults to 1, if set to 'variable' uses
same method as plot.Spatial in sp</p>
</td></tr>
<tr><td><code id="mapPolys_+3A_missingcountrycol">missingCountryCol</code></td>
<td>
<p>a colour for missing countries</p>
</td></tr>
<tr><td><code id="mapPolys_+3A_add">add</code></td>
<td>
<p>whether to add this map on top of an existing map, TRUE/FALSE</p>
</td></tr>
<tr><td><code id="mapPolys_+3A_lwd">lwd</code></td>
<td>
<p>line width for country borders</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Certain catMethod and colourPalette options go well together. e.g.
&quot;diverging&quot; and &quot;diverging&quot;, &quot;categorical&quot; and &quot;rainbow&quot;
</p>
<p>There are two styles of legend available.  If catMethod='categorical' or the
packages fields and spam are not installed a simple legend with coloured
boxes is created. Otherwise a colour bar legend is created. Finer control
can be achieved by <code><a href="#topic+addMapLegendBoxes">addMapLegendBoxes</a></code> or
<code><a href="#topic+addMapLegend">addMapLegend</a></code> repectively.
</p>


<h3>Value</h3>

<p>invisibly returns a list containing the data and main options used
for the map, the list can be passed to <code><a href="#topic+addMapLegend">addMapLegend</a></code> or
<code><a href="#topic+addMapLegendBoxes">addMapLegendBoxes</a></code> along with additional options to allow
greater flexibility in legend creation.
</p>


<h3>Author(s)</h3>

<p>andy south
</p>


<h3>See Also</h3>

<p>joinData2Map, classInt, RColorBrewer
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

## this example uses downloaded files
## to run it download the files
## and remove the comment symbols '#' from all the lines starting with a single '#'

## US states map downloaded from :
## http://www2.census.gov/cgi-bin/shapefiles2009/national-files

#inFile &lt;- 'tl_2009_us_stateec.shp'
#sPDF &lt;- readShapePoly(inFile)
#str(sPDF@data)

##################
## use mapPolys to map the sPDF
#mapPolys(sPDF,nameColumnToPlot = "ALANDEC")
#mapPolys(sPDF,nameColumnToPlot = "AWATEREC",mapRegion='North America')

##################
## join some other data to it
## education data downloaded from here as xls then saved as csv
## http://nces.ed.gov/ccd/drpcompstatelvl.asp

#dataFile &lt;- 'SDR071A_xls.csv'
#dF &lt;- read.csv(dataFile,as.is=TRUE)
#str(dF)
## STATENAME
## DRP912 Dropout Rate, Grades 9 through 12

## joining the data to the map
## based upon state names (column NAMEEC in map, and STATENAME in the data)
#sPDF2 &lt;- joinData2Map(dF
#        , nameMap = sPDF
#        , nameJoinIDMap = "NAMEEC"
#        , nameJoinColumnData = "STATENAME")

#################
## plot one of the attribute variables
#mapDevice()# to set nice shape map window
#mapPolys(sPDF2,nameColumnToPlot = "DRP912",mapRegion='North America')


#################
###to map US counties data (Tiger) downloaded from :
##http://www2.census.gov/cgi-bin/shapefiles2009/national-files

#inFile &lt;- 'tl_2009_us_county.shp'
#sPDF &lt;- readShapePoly(inFile)
#str(sPDF@data)
#mapPolys(sPDF,nameColumnToPlot='AWATER',xlim=c(-140,-65), ylim=c(25,45))



</code></pre>

<hr>
<h2 id='rwmCheckAndLoadInput'>internal function to check and load input data to mapping functions</h2><span id='topic+rwmCheckAndLoadInput'></span>

<h3>Description</h3>

<p>Internal function checking and loading dFs or sPDFs to
<code><a href="#topic+mapCountryData">mapCountryData</a></code>, <code><a href="#topic+mapPolys">mapPolys</a></code>, <code><a href="#topic+mapPies">mapPies</a></code>,
<code><a href="#topic+mapBubbles">mapBubbles</a></code>, <code><a href="#topic+mapBars">mapBars</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rwmCheckAndLoadInput(
  inputData = "",
  inputNeeded = "sPDF",
  callingFunction = ""
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rwmCheckAndLoadInput_+3A_inputdata">inputData</code></td>
<td>
<p>a dF, sPDF or &quot;&quot;, for latter an internal example data is
used</p>
</td></tr>
<tr><td><code id="rwmCheckAndLoadInput_+3A_inputneeded">inputNeeded</code></td>
<td>
<p>&quot;sPDF&quot;, &quot;sPDF or dF&quot;, &quot;dF&quot;</p>
</td></tr>
<tr><td><code id="rwmCheckAndLoadInput_+3A_callingfunction">callingFunction</code></td>
<td>
<p>optional : name of the calling function</p>
</td></tr>
</table>


<h3>Details</h3>

<p>a rworldmap internal function, unlikely to be of use to users
</p>


<h3>Value</h3>

<p>invisibly returns a dF or sPDF
</p>


<h3>Author(s)</h3>

<p>andy south
</p>

<hr>
<h2 id='rwmGetClassBreaks'>Internal function to set the numeric values for the breaks between data
categories</h2><span id='topic+rwmGetClassBreaks'></span>

<h3>Description</h3>

<p>Sets the values that determine how a vector of continuous data is classified
into categories. Called by mapCountryData() and mapGriddedData()
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rwmGetClassBreaks(dataColumn, catMethod, numCats, verbose = TRUE, midpoint = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rwmGetClassBreaks_+3A_datacolumn">dataColumn</code></td>
<td>
<p>the data vector to be classified, must be numeric</p>
</td></tr>
<tr><td><code id="rwmGetClassBreaks_+3A_catmethod">catMethod</code></td>
<td>
<p>the method to use to classify the data into categories,
choice of &quot;pretty&quot;, &quot;fixedWidth&quot;, &quot;diverging&quot;,
&quot;logFixedWidth&quot;,&quot;quantiles&quot;,&quot;categorical&quot; or a numeric vector defining
breaks</p>
</td></tr>
<tr><td><code id="rwmGetClassBreaks_+3A_numcats">numCats</code></td>
<td>
<p>number of categories to put the data in, may be overidden if
not possible under some classification methods</p>
</td></tr>
<tr><td><code id="rwmGetClassBreaks_+3A_verbose">verbose</code></td>
<td>
<p>whether to print information messages to console TRUE/FALSE</p>
</td></tr>
<tr><td><code id="rwmGetClassBreaks_+3A_midpoint">midpoint</code></td>
<td>
<p>the midpoint to use if catMethod='diverging', default=0</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector specifying the numeric breaks between data categories.
</p>


<h3>Author(s)</h3>

<p>andy south and matthew staines
</p>


<h3>See Also</h3>

<p>The classInt package
</p>

<hr>
<h2 id='rwmGetColours'>to choose map colours for classified data</h2><span id='topic+rwmGetColours'></span>

<h3>Description</h3>

<p>Returns a vector of colours based upon the palette specified and number of
colours specified.  If colourPalette specifies a number of colours and this
is different from numColours, numColours takes precedence and colours are
interpolated to make the number fit.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rwmGetColours(colourPalette, numColours)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rwmGetColours_+3A_colourpalette">colourPalette</code></td>
<td>
<p>string describing the colour palette to use, choice of:
</p>
 <ol>
<li><p> &quot;palette&quot; for the current palette </p>
</li>
<li><p> a vector of valid
colours, e.g. =c('red','white','blue') or output from RColourBrewer </p>
</li>
<li><p> one
of &quot;heat&quot;, &quot;diverging&quot;, &quot;white2Black&quot;, &quot;black2White&quot;, &quot;topo&quot;, &quot;rainbow&quot;,
&quot;terrain&quot;, &quot;negpos8&quot;, &quot;negpos9&quot; </p>
</li></ol>
</td></tr>
<tr><td><code id="rwmGetColours_+3A_numcolours">numColours</code></td>
<td>
<p>the number of colour categories desired</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector specifiying a number of colours.
</p>

<hr>
<h2 id='rwmGetISO3'>Internal function for getting the ISO3 country code for a country name
synonymn.</h2><span id='topic+rwmGetISO3'></span>

<h3>Description</h3>

<p>Searches countrySynonyms to get the ISO3 code. If the name is not found NA
is returned. Allows joining of imperfect names to other country data in
joinCountryData2Map( joinCode='NAME' )
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rwmGetISO3(oddName)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rwmGetISO3_+3A_oddname">oddName</code></td>
<td>
<p>country name that user wishes to find code for</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the ISO3 code (3 letters) corresponding to the country name passed,
or NA if one is not found
</p>


<h3>Author(s)</h3>

<p>Andy South
</p>


<h3>References</h3>

<p>This was derived and used with permission from the Perl Locale
package.  <br /> Locale::Codes::Country_Codes.  <br /> Thanks to Sullivan Beck for
pulling this together.  <br /> Data sources are acknowledged here : <br />
http://search.cpan.org/~sbeck/Locale-Codes-3.23/lib/Locale/Codes/Country.pod
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
rwmGetISO3("vietnam")

</code></pre>

<hr>
<h2 id='rwmNewMapPlot'>Internal function to set up an existing device for plotting maps</h2><span id='topic+rwmNewMapPlot'></span>

<h3>Description</h3>

<p>Sets the region, aspect and ocean colour for a new map plot
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rwmNewMapPlot(
  mapToPlot = getMap(),
  oceanCol = NA,
  mapRegion = "world",
  xlim = NA,
  ylim = NA,
  aspect = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rwmNewMapPlot_+3A_maptoplot">mapToPlot</code></td>
<td>
<p>the worldmap to be plotted</p>
</td></tr>
<tr><td><code id="rwmNewMapPlot_+3A_oceancol">oceanCol</code></td>
<td>
<p>a colour for the ocean</p>
</td></tr>
<tr><td><code id="rwmNewMapPlot_+3A_mapregion">mapRegion</code></td>
<td>
<p>a string specifying the map region, see setMapExtents()</p>
</td></tr>
<tr><td><code id="rwmNewMapPlot_+3A_xlim">xlim</code></td>
<td>
<p>map extents c(west,east), can be overidden by mapRegion</p>
</td></tr>
<tr><td><code id="rwmNewMapPlot_+3A_ylim">ylim</code></td>
<td>
<p>map extents c(south,north), can be overidden by mapRegion</p>
</td></tr>
<tr><td><code id="rwmNewMapPlot_+3A_aspect">aspect</code></td>
<td>
<p>aspect for the map, defaults to 1, if set to 'variable' uses
same default as plot.Spatial in sp</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Called by mapCountryData() and mapGriddedData()
</p>


<h3>Value</h3>

<p>a dataframe containing xlim and ylim
</p>


<h3>Author(s)</h3>

<p>andy south
</p>

<hr>
<h2 id='rworldmap-package'>For mapping global data.</h2><span id='topic+rworldmap-package'></span><span id='topic+rworldmap'></span>

<h3>Description</h3>

<p>Enables mapping of country level and gridded user datasets by facilitating
joining to modern world maps and offering visualisation options. Country
borders are derived from Natural Earth data v 1.4.0.
</p>
<p>Enables mapping of country level and gridded user datasets by facilitating
joining to modern world maps and offering visualisation options. Country
borders are derived from Natural Earth data v 1.4.0.
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;"> Package: </td><td style="text-align: left;"> rworldmap</td>
</tr>
<tr>
 <td style="text-align: left;"> Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;"> Version: </td><td style="text-align: left;">
1.3-4</td>
</tr>
<tr>
 <td style="text-align: left;"> Date: </td><td style="text-align: left;"> 2014-11-11</td>
</tr>
<tr>
 <td style="text-align: left;"> License: </td><td style="text-align: left;"> GPL (&gt;= 2)</td>
</tr>
<tr>
 <td style="text-align: left;"> </td>
</tr>

</table>

<p>Country Level Data can be joined to a map using
<code><a href="#topic+joinCountryData2Map">joinCountryData2Map</a></code>, then mapped using
<code><a href="#topic+mapCountryData">mapCountryData</a></code>. These functions can cope with a range of
country names and country codes.
</p>
<p>Country boundaries are derived from version 1.4.0 of Natural Earth data as
described in <code><a href="#topic+countriesCoarse">countriesCoarse</a></code>. Higher resolution boundaries are
provided in a companion package rworldxtra.
</p>
<p>More generic functions allow the user to provide their own polygon map using
<code><a href="#topic+joinData2Map">joinData2Map</a></code> and <code><a href="#topic+mapPolys">mapPolys</a></code>.
</p>
<p>Bubble, bar and pie charts can be added to maps using
<code><a href="#topic+mapBubbles">mapBubbles</a></code>, <code><a href="#topic+mapBars">mapBars</a></code> and <code><a href="#topic+mapPies">mapPies</a></code>.
</p>
<p>Try the new method <code><a href="#topic+barplotCountryData">barplotCountryData</a></code> for producing a ranked
bar plot of country data with country names that can provide a useful
companion to maps.
</p>
<p>Options are provided for categorising data, colouring maps and symbols, and
adding legends.
</p>
<p>Gridded data can be mapped using <code><a href="#topic+mapGriddedData">mapGriddedData</a></code>, but the
raster package is much more comprehensive.
</p>
<p>Type vignette('rworldmap') to access a short document showing a few examples
of the main rworldmap functions to get you started.
</p>
<p>Country Level Data can be joined to a map using
<code><a href="#topic+joinCountryData2Map">joinCountryData2Map</a></code>, then mapped using
<code><a href="#topic+mapCountryData">mapCountryData</a></code>. These functions can cope with a range of
country names and country codes.
</p>
<p>Country boundaries are derived from version 1.4.0 of Natural Earth data as
described in <code><a href="#topic+countriesCoarse">countriesCoarse</a></code>. Higher resolution boundaries are
provided in a companion package rworldxtra.
</p>
<p>More generic functions allow the user to provide their own polygon map using
<code><a href="#topic+joinData2Map">joinData2Map</a></code> and <code><a href="#topic+mapPolys">mapPolys</a></code>.
</p>
<p>Bubble, bar and pie charts can be added to maps using
<code><a href="#topic+mapBubbles">mapBubbles</a></code>, <code><a href="#topic+mapBars">mapBars</a></code> and <code><a href="#topic+mapPies">mapPies</a></code>.
</p>
<p>Try the new method <code><a href="#topic+barplotCountryData">barplotCountryData</a></code> for producing a ranked
bar plot of country data with country names that can provide a useful
companion to maps.
</p>
<p>Options are provided for categorising data, colouring maps and symbols, and
adding legends.
</p>
<p>Gridded data can be mapped using <code><a href="#topic+mapGriddedData">mapGriddedData</a></code>, but the
raster package is much more comprehensive.
</p>
<p>Type vignette('rworldmap') to access a short document showing a few examples
of the main rworldmap functions to get you started.
</p>


<h3>Author(s)</h3>

<p>Andy South
</p>
<p>with contributions from Joe Scutt-Phillips, Barry Rowlingson, Roger Bivand
and Pru Foster
</p>
<p>Maintainer: &lt;southandy@gmail.com&gt;
</p>


<h3>References</h3>

<p>Stable version :
http://cran.r-project.org/web/packages/rworldmap <br /> Development version :
https://r-forge.r-project.org/projects/rworldmap/
</p>
<p>Discussion group : http://groups.google.com/group/rworldmap
</p>
<p>Stable version :
http://cran.r-project.org/web/packages/rworldmap 
<br /> Development version :https://github.com/AndySouth/rworldmap
</p>
<p>Discussion group : http://groups.google.com/group/rworldmap
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

#mapping country level data, with no file specified it uses internal example data
mapCountryData()
#specifying region
mapCountryData(mapRegion="asia")
#mapping gridded data, with no file specified it uses internal example data
mapGriddedData()
#specifying region 
mapGriddedData(mapRegion="africa")  
#aggregating gridded data to country level 
#with no file specified it uses internal example data
mapHalfDegreeGridToCountries()              



</code></pre>

<hr>
<h2 id='rworldmapExamples'>Example code for plot creation</h2><span id='topic+rworldmapExamples'></span>

<h3>Description</h3>

<p>Example code to demonstrate creation of a series of plots
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rworldmapExamples()
</code></pre>


<h3>Author(s)</h3>

<p>andy south
</p>

<hr>
<h2 id='setMapExtents'>Internal function allowing map extents to be set from area names</h2><span id='topic+setMapExtents'></span>

<h3>Description</h3>

<p>Allows map extents to be set from country or area names (e.g. India, Africa
)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setMapExtents(mapRegion = "world")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setMapExtents_+3A_mapregion">mapRegion</code></td>
<td>
<p>a country name from getMap()[['NAME']] or one of
'eurasia','africa','latin america','uk','oceania','asia'</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Can be called by <code><a href="#topic+mapCountryData">mapCountryData</a></code> and
<code><a href="#topic+mapGriddedData">mapGriddedData</a></code>
</p>


<h3>Value</h3>

<p>a dataframe containing we,ea,so,no values in degrees between -180 &amp;
+180
</p>


<h3>Author(s)</h3>

<p>andy south
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
mapCountryData( mapRegion='Africa' )
mapCountryData( mapRegion='India' )

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
