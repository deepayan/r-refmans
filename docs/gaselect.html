<!DOCTYPE html><html><head><title>Help for package gaselect</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {gaselect}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#evaluate'><p>Evaluate the fitness of variable subsets</p></a></li>
<li><a href='#evaluatorFit'><p>Fit Evaluator</p></a></li>
<li><a href='#evaluatorLM'><p>LM Evaluator</p></a></li>
<li><a href='#evaluatorPLS'><p>PLS Evaluator</p></a></li>
<li><a href='#evaluatorUserFunction'><p>User Defined Evaluator</p></a></li>
<li><a href='#fitness'><p>Get the fitness of a variable subset</p></a></li>
<li><a href='#fitnessEvolution'><p>Get the evolution of the fitness</p></a></li>
<li><a href='#formatSegmentation'><p>Format the raw segmentation list returned from the C++ code into a usable list</p></a></li>
<li><a href='#genAlg'><p>Genetic algorithm for variable subset selection</p></a></li>
<li><a href='#GenAlg-class'><p>Result of a genetic algorithm run</p></a></li>
<li><a href='#genAlgControl'><p>Set control arguments for the genetic algorithm</p></a></li>
<li><a href='#GenAlgControl-class'><p>Control class for the genetic algorithm</p></a></li>
<li><a href='#GenAlgEvaluator-class'><p>Evaluator Base Class</p></a></li>
<li><a href='#GenAlgFitEvaluator-class'><p>Fit Evaluator</p></a></li>
<li><a href='#GenAlgLMEvaluator-class'><p>LM Evaluator</p></a></li>
<li><a href='#GenAlgPLSEvaluator-class'><p>PLS Evaluator</p></a></li>
<li><a href='#GenAlgUserEvaluator-class'><p>User Function Evaluator</p></a></li>
<li><a href='#getEvalFun'><p>Get the evaluation function from a GenAlgUserEvaluator</p></a></li>
<li><a href='#subsets'><p>Get the found variable subset(s)</p></a></li>
<li><a href='#toCControlList'><p>Transform the object to a list</p></a></li>
<li><a href='#trueFitnessVal'><p>Get the transformed fitness values</p></a></li>
<li><a href='#validData'><p>Check if the data is valid for the evaluator</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Genetic Algorithm (GA) for Variable Selection from
High-Dimensional Data</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.22</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-12-11</td>
</tr>
<tr>
<td>Author:</td>
<td>David Kepplinger</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>David Kepplinger &lt;david.kepplinger@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides a genetic algorithm for finding variable
    subsets in high dimensional data with high prediction performance. The
    genetic algorithm can use ordinary least squares (OLS) regression models or
    partial least squares (PLS) regression models to evaluate the prediction
    power of variable subsets. By supporting different cross-validation
    schemes, the user can fine-tune the tradeoff between speed and quality of
    the solution.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/dakep/gaselect">https://github.com/dakep/gaselect</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/dakep/gaselect/issues">https://github.com/dakep/gaselect/issues</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Biarch:</td>
<td>true</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0.2), methods (&ge; 2.10.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 0.10.5)</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp (&ge; 0.10.5), RcppArmadillo (&ge; 0.9.800.4)</td>
</tr>
<tr>
<td>Collate:</td>
<td>'Evaluator.R' 'GenAlgControl.R' 'formatSegmentation.R'
'evaluate.R' 'fitness.R' 'genAlg.R' 'getEvalFun.R' 'subsets.R'
'toCControlList.R' 'validData.R'</td>
</tr>
<tr>
<td>Suggests:</td>
<td>chemometrics</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-12-11 19:00:18 UTC; david</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-12-11 19:50:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='evaluate'>Evaluate the fitness of variable subsets</h2><span id='topic+evaluate'></span><span id='topic+evaluate+2CGenAlgEvaluator+2Cmatrix+2Cnumeric+2Cmatrix+2Cinteger+2Cinteger-method'></span><span id='topic+evaluate+2CGenAlgEvaluator+2Cmatrix+2Cnumeric+2Clogical+2Cinteger+2Cinteger-method'></span><span id='topic+evaluate+2CGenAlgEvaluator+2Cmatrix+2Cnumeric+2CANY+2Cmissing+2Cinteger-method'></span><span id='topic+evaluate+2CGenAlgEvaluator+2Cmatrix+2Cnumeric+2CANY+2Cinteger+2Cmissing-method'></span><span id='topic+evaluate+2CGenAlgEvaluator+2Cmatrix+2Cnumeric+2CANY+2Cmissing+2Cmissing-method'></span>

<h3>Description</h3>

<p>Evaluate the given variable subsets with the given Evaluator
</p>


<h3>Usage</h3>

<pre><code class='language-R'>evaluate(object, X, y, subsets, seed, verbosity)

## S4 method for signature 
## 'GenAlgEvaluator,matrix,numeric,matrix,integer,integer'
evaluate(object, X, y, subsets, seed, verbosity)

## S4 method for signature 
## 'GenAlgEvaluator,matrix,numeric,logical,integer,integer'
evaluate(object, X, y, subsets, seed, verbosity)

## S4 method for signature 'GenAlgEvaluator,matrix,numeric,ANY,missing,integer'
evaluate(object, X, y, subsets, seed, verbosity)

## S4 method for signature 'GenAlgEvaluator,matrix,numeric,ANY,integer,missing'
evaluate(object, X, y, subsets, seed, verbosity)

## S4 method for signature 'GenAlgEvaluator,matrix,numeric,ANY,missing,missing'
evaluate(object, X, y, subsets, seed, verbosity)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="evaluate_+3A_object">object</code></td>
<td>
<p>The GenAlgEvaluator object that is used to evaluate the variables</p>
</td></tr>
<tr><td><code id="evaluate_+3A_x">X</code></td>
<td>
<p>The data matrix used to for fitting the model</p>
</td></tr>
<tr><td><code id="evaluate_+3A_y">y</code></td>
<td>
<p>The response vector</p>
</td></tr>
<tr><td><code id="evaluate_+3A_subsets">subsets</code></td>
<td>
<p>The logical matrix where a column stands for one subset to evaluate</p>
</td></tr>
<tr><td><code id="evaluate_+3A_seed">seed</code></td>
<td>
<p>The value to seed the random number generator before evaluating</p>
</td></tr>
<tr><td><code id="evaluate_+3A_verbosity">verbosity</code></td>
<td>
<p>A value between 0 (no output at all) and 5 (maximum verbosity)</p>
</td></tr>
</table>

<hr>
<h2 id='evaluatorFit'>Fit Evaluator</h2><span id='topic+evaluatorFit'></span>

<h3>Description</h3>

<p>Creates the object that controls the evaluation step in the genetic algorithm
</p>


<h3>Usage</h3>

<pre><code class='language-R'>evaluatorFit(
  numSegments = 7L,
  statistic = c("BIC", "AIC", "adjusted.r.squared", "r.squared"),
  numThreads = NULL,
  maxNComp = NULL,
  sdfact = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="evaluatorFit_+3A_numsegments">numSegments</code></td>
<td>
<p>The number of CV segments used to estimate the optimal number of PLS components (between 2 and 2^16).</p>
</td></tr>
<tr><td><code id="evaluatorFit_+3A_statistic">statistic</code></td>
<td>
<p>The statistic used to evaluate the fitness (BIC, AIC, adjusted R^2, or R^2).</p>
</td></tr>
<tr><td><code id="evaluatorFit_+3A_numthreads">numThreads</code></td>
<td>
<p>The maximum number of threads the algorithm is allowed to spawn (a value less than
1 or NULL means no threads).</p>
</td></tr>
<tr><td><code id="evaluatorFit_+3A_maxncomp">maxNComp</code></td>
<td>
<p>The maximum number of components the PLS models should consider (if not specified,
the number of components is not constrained)</p>
</td></tr>
<tr><td><code id="evaluatorFit_+3A_sdfact">sdfact</code></td>
<td>
<p>The factor to scale the stand. dev. of the MSEP values when selecting the optimal number
of components. For the &quot;one standard error rule&quot;, <code>sdfact</code> is 1.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The fitness of a variable subset is assessed by how well a PLS model fits the data. To estimate
the optimal number of components for the PLS model, cross-validation is used.
</p>


<h3>Value</h3>

<p>Returns an S4 object of type <code><a href="#topic+GenAlgFitEvaluator">GenAlgFitEvaluator</a></code> to be used as argument to
a call of <code><a href="#topic+genAlg">genAlg</a></code>.
</p>


<h3>See Also</h3>

<p>Other GenAlg Evaluators: 
<code><a href="#topic+evaluatorLM">evaluatorLM</a>()</code>,
<code><a href="#topic+evaluatorPLS">evaluatorPLS</a>()</code>,
<code><a href="#topic+evaluatorUserFunction">evaluatorUserFunction</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ctrl &lt;- genAlgControl(populationSize = 200, numGenerations = 30, minVariables = 5,
    maxVariables = 12, verbosity = 1)
evaluator &lt;- evaluatorFit(statistic = "BIC", numThreads = 1)

# Generate demo-data
set.seed(12345)
X &lt;- matrix(rnorm(10000, sd = 1:5), ncol = 50, byrow = TRUE)
y &lt;- drop(-1.2 + rowSums(X[, seq(1, 43, length = 8)]) + rnorm(nrow(X), 1.5));

result &lt;- genAlg(y, X, control = ctrl, evaluator = evaluator, seed = 123)

subsets(result, 1:5)
</code></pre>

<hr>
<h2 id='evaluatorLM'>LM Evaluator</h2><span id='topic+evaluatorLM'></span>

<h3>Description</h3>

<p>Create an evaluator that uses a linear model to evaluate the fitness.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>evaluatorLM(
  statistic = c("BIC", "AIC", "adjusted.r.squared", "r.squared"),
  numThreads = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="evaluatorLM_+3A_statistic">statistic</code></td>
<td>
<p>The statistic used to evaluate the fitness</p>
</td></tr>
<tr><td><code id="evaluatorLM_+3A_numthreads">numThreads</code></td>
<td>
<p>The maximum number of threads the algorithm is allowed to spawn (a value less than 1 or NULL means no threads)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Different statistics to evaluate the fitness of the variable subset can be given. If a maximum
absolute correlation is given the algorithm will be very slow (as the C++ implementation can not
be used anymore) and multithreading is not available.
</p>


<h3>Value</h3>

<p>Returns an S4 object of type <code><a href="#topic+GenAlgLMEvaluator">GenAlgLMEvaluator</a></code>
</p>


<h3>See Also</h3>

<p>Other GenAlg Evaluators: 
<code><a href="#topic+evaluatorFit">evaluatorFit</a>()</code>,
<code><a href="#topic+evaluatorPLS">evaluatorPLS</a>()</code>,
<code><a href="#topic+evaluatorUserFunction">evaluatorUserFunction</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ctrl &lt;- genAlgControl(populationSize = 200, numGenerations = 30, minVariables = 5,
    maxVariables = 12, verbosity = 1)
evaluator &lt;- evaluatorLM(statistic = "BIC", numThreads = 1)

# Generate demo-data
set.seed(12345)
X &lt;- matrix(rnorm(10000, sd = 1:5), ncol = 50, byrow = TRUE)
y &lt;- drop(-1.2 + rowSums(X[, seq(1, 43, length = 8)]) + rnorm(nrow(X), 1.5));

result &lt;- genAlg(y, X, control = ctrl, evaluator = evaluator, seed = 123)

subsets(result, 1:5)
</code></pre>

<hr>
<h2 id='evaluatorPLS'>PLS Evaluator</h2><span id='topic+evaluatorPLS'></span>

<h3>Description</h3>

<p>Creates the object that controls the evaluation step in the genetic algorithm
</p>


<h3>Usage</h3>

<pre><code class='language-R'>evaluatorPLS(
  numReplications = 30L,
  innerSegments = 7L,
  outerSegments = 1L,
  testSetSize = NULL,
  numThreads = NULL,
  maxNComp = NULL,
  method = c("simpls"),
  sdfact = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="evaluatorPLS_+3A_numreplications">numReplications</code></td>
<td>
<p>The number of replications used to evaluate a variable subset (must be between 1 and 2^16)</p>
</td></tr>
<tr><td><code id="evaluatorPLS_+3A_innersegments">innerSegments</code></td>
<td>
<p>The number of CV segments used in one replication (must be between 2 and 2^16)</p>
</td></tr>
<tr><td><code id="evaluatorPLS_+3A_outersegments">outerSegments</code></td>
<td>
<p>The number of outer CV segments used in one replication (between 0 and 2^16). If this
is greater than 1, repeated double cross-validation strategy (rdCV) will be used instead of
simple repeated cross-validation (srCV) (see details)</p>
</td></tr>
<tr><td><code id="evaluatorPLS_+3A_testsetsize">testSetSize</code></td>
<td>
<p>The relative size of the test set used for simple repeated CV (between 0 and 1). This parameter
is ignored if outerSegments &gt; 1 and a warning will be issued.</p>
</td></tr>
<tr><td><code id="evaluatorPLS_+3A_numthreads">numThreads</code></td>
<td>
<p>The maximum number of threads the algorithm is allowed to spawn (a value less than
1 or NULL means no threads)</p>
</td></tr>
<tr><td><code id="evaluatorPLS_+3A_maxncomp">maxNComp</code></td>
<td>
<p>The maximum number of components the PLS models should consider (if not specified,
the number of components is not constrained)</p>
</td></tr>
<tr><td><code id="evaluatorPLS_+3A_method">method</code></td>
<td>
<p>The PLS method used to fit the PLS model (currently only SIMPLS is implemented)</p>
</td></tr>
<tr><td><code id="evaluatorPLS_+3A_sdfact">sdfact</code></td>
<td>
<p>The factor to scale the stand. dev. of the MSEP values when selecting the optimal number
of components. For the &quot;one standard error rule&quot;, <code>sdfact</code> is 1.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>With this method the genetic algorithm uses PLS regression models to assess the prediction power of
variable subsets. By default, simple repeated cross-validation (srCV) is used. The optimal number
of PLS components is estimated using cross-validation (with <code>innerSegments</code> segments) on a
training set. The prediction power is then evaluated by fitting a PLS regression model with this optimal
number of components to the training set and predicting the values of a test set (of either
<code>testSetSize</code> size or <code>1 / innerSegments</code>, if <code>testSetSize</code> is not specified).
</p>
<p>If the parameter <code>outerSegments</code> is given, repeated double cross-validation is used instead.
There, the data set is first split into <code>outerSegments</code> segments and one segment is used as
prediction set and the other segments as test set. This is repeated for each outer segment.
</p>
<p>The whole procedure is repeated <code>numReplications</code> times to get a more reliable estimate of the
prediction power.
</p>


<h3>Value</h3>

<p>Returns an S4 object of type <code><a href="#topic+GenAlgPLSEvaluator">GenAlgPLSEvaluator</a></code> to be used as argument to
a call of <code><a href="#topic+genAlg">genAlg</a></code>.
</p>


<h3>See Also</h3>

<p>Other GenAlg Evaluators: 
<code><a href="#topic+evaluatorFit">evaluatorFit</a>()</code>,
<code><a href="#topic+evaluatorLM">evaluatorLM</a>()</code>,
<code><a href="#topic+evaluatorUserFunction">evaluatorUserFunction</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ctrl &lt;- genAlgControl(populationSize = 100, numGenerations = 15, minVariables = 5,
    maxVariables = 12, verbosity = 1)

evaluatorSRCV &lt;- evaluatorPLS(numReplications = 2, innerSegments = 7, testSetSize = 0.4,
    numThreads = 1)

evaluatorRDCV &lt;- evaluatorPLS(numReplications = 2, innerSegments = 5, outerSegments = 3,
    numThreads = 1)

# Generate demo-data
set.seed(12345)
X &lt;- matrix(rnorm(10000, sd = 1:5), ncol = 50, byrow = TRUE)
y &lt;- drop(-1.2 + rowSums(X[, seq(1, 43, length = 8)]) + rnorm(nrow(X), 1.5));

resultSRCV &lt;- genAlg(y, X, control = ctrl, evaluator = evaluatorSRCV, seed = 123)
resultRDCV &lt;- genAlg(y, X, control = ctrl, evaluator = evaluatorRDCV, seed = 123)

subsets(resultSRCV, 1:5)
subsets(resultRDCV, 1:5)
</code></pre>

<hr>
<h2 id='evaluatorUserFunction'>User Defined Evaluator</h2><span id='topic+evaluatorUserFunction'></span>

<h3>Description</h3>

<p>Create an evaluator that uses a user defined function to evaluate the fitness
</p>


<h3>Usage</h3>

<pre><code class='language-R'>evaluatorUserFunction(FUN, sepFUN = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="evaluatorUserFunction_+3A_fun">FUN</code></td>
<td>
<p>Function used to evaluate the fitness</p>
</td></tr>
<tr><td><code id="evaluatorUserFunction_+3A_sepfun">sepFUN</code></td>
<td>
<p>Function to calculate the SEP of the variable subsets</p>
</td></tr>
<tr><td><code id="evaluatorUserFunction_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to FUN and sepFUN</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The user specified function must take a the response vector as first and the covariates matrix as second argument.
The function must return a number representing the fitness of the variable subset (the higher the value the fitter the subset)
Additionally the user can specify a function that takes a <code><a href="#topic+GenAlg">GenAlg</a></code> object and returns
the standard error of prediction of the found variable subsets.
</p>


<h3>Value</h3>

<p>Returns an S4 object of type <code><a href="#topic+GenAlgUserEvaluator">GenAlgUserEvaluator</a></code>
</p>


<h3>See Also</h3>

<p>Other GenAlg Evaluators: 
<code><a href="#topic+evaluatorFit">evaluatorFit</a>()</code>,
<code><a href="#topic+evaluatorLM">evaluatorLM</a>()</code>,
<code><a href="#topic+evaluatorPLS">evaluatorPLS</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ctrl &lt;- genAlgControl(populationSize = 100, numGenerations = 10, minVariables = 5,
    maxVariables = 12, verbosity = 1)

# Use the BIC of a linear model to evaluate the fitness of a variable subset
evalFUN &lt;- function(y, X) {
		return(BIC(lm(y ~ X)));
}

# Dummy function that returns the residuals standard deviation and not the SEP
sepFUN &lt;- function(genAlg) {
    return(apply(genAlg@subsets, 2, function(subset) {
		m &lt;- lm(genAlg@response ~ genAlg@covariates[, subset]);
		return(sd(m$residuals));
	}));
}

evaluator &lt;- evaluatorUserFunction(FUN = evalFUN, sepFUN = sepFUN)

# Generate demo-data
set.seed(12345)
X &lt;- matrix(rnorm(10000, sd = 1:5), ncol = 50, byrow = TRUE)
y &lt;- drop(-1.2 + rowSums(X[, seq(1, 43, length = 8)]) + rnorm(nrow(X), 1.5));

result &lt;- genAlg(y, X, control = ctrl, evaluator = evaluator, seed = 123)

subsets(result, 1:5)
</code></pre>

<hr>
<h2 id='fitness'>Get the fitness of a variable subset</h2><span id='topic+fitness'></span>

<h3>Description</h3>

<p>Get the internal fitness for all variable subsets
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fitness(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitness_+3A_object">object</code></td>
<td>
<p>The <code><a href="#topic+GenAlg">GenAlg</a></code> object returned by <code><a href="#topic+genAlg">genAlg</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>This method is used to get the fitness of all variable subsets
found by the genetic algorithm.
</p>


<h3>Value</h3>

<p>A vector with the estimated fitness for each solution
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ctrl &lt;- genAlgControl(populationSize = 100, numGenerations = 15, minVariables = 5,
    maxVariables = 12, verbosity = 1)

evaluator &lt;- evaluatorPLS(numReplications = 2, innerSegments = 7, testSetSize = 0.4,
    numThreads = 1)

# Generate demo-data
set.seed(12345)
X &lt;- matrix(rnorm(10000, sd = 1:5), ncol = 50, byrow = TRUE)
y &lt;- drop(-1.2 + rowSums(X[, seq(1, 43, length = 8)]) + rnorm(nrow(X), 1.5));

result &lt;- genAlg(y, X, control = ctrl, evaluator = evaluator, seed = 123)

fitness(result) # Get fitness of the found subsets

h &lt;- fitnessEvolution(result) # Get average fitness as well as the fitness of the
                              # best chromosome for each generation (at raw scale!)

plot(h[, "mean"], type = "l", col = 1, ylim = c(-7, -1))
lines(h[, "mean"] - h[, "std.dev"], type = "l", col = "gray30", lty = 2)
lines(h[, "mean"] + h[, "std.dev"], type = "l", col = "gray30", lty = 2)
lines(h[, "best"], type = "l", col = 2)
</code></pre>

<hr>
<h2 id='fitnessEvolution'>Get the evolution of the fitness</h2><span id='topic+fitnessEvolution'></span>

<h3>Description</h3>

<p>Get the fitness of the best / average chromosomes after each generation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fitnessEvolution(
  object,
  what = c("mean", "best", "std.dev"),
  type = c("true", "raw")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitnessEvolution_+3A_object">object</code></td>
<td>
<p>The <code><a href="#topic+GenAlg">GenAlg</a></code> object returned by <code><a href="#topic+genAlg">genAlg</a></code></p>
</td></tr>
<tr><td><code id="fitnessEvolution_+3A_what">what</code></td>
<td>
<p>can be one ore more of <code>"best"</code> (to return the fitness of the best chromosome for each generation),
<code>"mean"</code> (to return the arithmetic mean fitness during each generation), and <code>"std.dev"</code> (for
the standard deviation of the fitness values in each generation).</p>
</td></tr>
<tr><td><code id="fitnessEvolution_+3A_type">type</code></td>
<td>
<p>one of <code>"true"</code> or <code>"raw"</code>. <em>raw</em> means the raw fitness value used
within the GA, while <em>true</em> tries to convert it to the standard error of prediction (like
<code><a href="#topic+fitness">fitness</a></code>). If the standard deviation (<code>what = "std.dev"</code>) is requested, the
<code>type</code> will always be <em>raw</em>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Returns the progress of the fitness of the best or average chromosome.
</p>


<h3>Value</h3>

<p>A vector with the best or average fitness value after each generation
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ctrl &lt;- genAlgControl(populationSize = 100, numGenerations = 15, minVariables = 5,
    maxVariables = 12, verbosity = 1)

evaluator &lt;- evaluatorPLS(numReplications = 2, innerSegments = 7, testSetSize = 0.4,
    numThreads = 1)

# Generate demo-data
set.seed(12345)
X &lt;- matrix(rnorm(10000, sd = 1:5), ncol = 50, byrow = TRUE)
y &lt;- drop(-1.2 + rowSums(X[, seq(1, 43, length = 8)]) + rnorm(nrow(X), 1.5));

result &lt;- genAlg(y, X, control = ctrl, evaluator = evaluator, seed = 123)

fitness(result) # Get fitness of the found subsets

h &lt;- fitnessEvolution(result) # Get average fitness as well as the fitness of the
                              # best chromosome for each generation (at raw scale!)

plot(h[, "mean"], type = "l", col = 1, ylim = c(-7, -1))
lines(h[, "mean"] - h[, "std.dev"], type = "l", col = "gray30", lty = 2)
lines(h[, "mean"] + h[, "std.dev"], type = "l", col = "gray30", lty = 2)
lines(h[, "best"], type = "l", col = 2)
</code></pre>

<hr>
<h2 id='formatSegmentation'>Format the raw segmentation list returned from the C++ code into a usable list</h2><span id='topic+formatSegmentation'></span><span id='topic+formatSegmentation+2CGenAlgPLSEvaluator+2Clist-method'></span><span id='topic+formatSegmentation+2CGenAlgUserEvaluator+2Clist-method'></span><span id='topic+formatSegmentation+2CGenAlgLMEvaluator+2Clist-method'></span><span id='topic+formatSegmentation+2CGenAlgFitEvaluator+2Clist-method'></span>

<h3>Description</h3>

<p>Format the raw segmentation list returned from the C++ code into a usable list
</p>


<h3>Usage</h3>

<pre><code class='language-R'>formatSegmentation(object, segments)

## S4 method for signature 'GenAlgPLSEvaluator,list'
formatSegmentation(object, segments)

## S4 method for signature 'GenAlgUserEvaluator,list'
formatSegmentation(object, segments)

## S4 method for signature 'GenAlgLMEvaluator,list'
formatSegmentation(object, segments)

## S4 method for signature 'GenAlgFitEvaluator,list'
formatSegmentation(object, segments)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="formatSegmentation_+3A_object">object</code></td>
<td>
<p>The Evaluator object.</p>
</td></tr>
<tr><td><code id="formatSegmentation_+3A_segments">segments</code></td>
<td>
<p>The raw segmentation list.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of the form replication -&gt; outerSegment -&gt; (calibration, validation, inner -&gt; (test, train))
</p>

<hr>
<h2 id='genAlg'>Genetic algorithm for variable subset selection</h2><span id='topic+genAlg'></span>

<h3>Description</h3>

<p>A genetic algorithm to find &quot;good&quot; variable subsets based on internal PLS evaluation or a user specified
evaluation function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>genAlg(y, X, control, evaluator = evaluatorPLS(), seed)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="genAlg_+3A_y">y</code></td>
<td>
<p>The numeric response vector of length n</p>
</td></tr>
<tr><td><code id="genAlg_+3A_x">X</code></td>
<td>
<p>A n x p numeric matrix with all p covariates</p>
</td></tr>
<tr><td><code id="genAlg_+3A_control">control</code></td>
<td>
<p>Options for controlling the genetic algorithm. See <code><a href="#topic+genAlgControl">genAlgControl</a></code> for details.</p>
</td></tr>
<tr><td><code id="genAlg_+3A_evaluator">evaluator</code></td>
<td>
<p>The evaluator used to evaluate the fitness of a variable subset. See
<code><a href="#topic+evaluatorPLS">evaluatorPLS</a></code>, <code><a href="#topic+evaluatorLM">evaluatorLM</a></code> or <code><a href="#topic+evaluatorUserFunction">evaluatorUserFunction</a></code> for details.</p>
</td></tr>
<tr><td><code id="genAlg_+3A_seed">seed</code></td>
<td>
<p>Integer with the seed for the random number generator or NULL to automatically seed the RNG</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The GA generates an initial &quot;population&quot; of <code>populationSize</code> chromosomes where each initial
chromosome has a random number of randomly selected variables. The fitness of every chromosome is evaluated by
the specified evaluator. The default built-in PLS evaluator (see <code><a href="#topic+evaluatorPLS">evaluatorPLS</a></code>) is the preferred
evaluator.
Chromosomes with higher fitness have higher probability of mating with another chromosome. <code>populationSize / 2</code> couples each create
2 children. The children are created by randomly mixing the parents' variables. These children make up the new generation and are again
selected for mating based on their fitness. A total of <code>numGenerations</code> generations are built this way.
The algorithm returns the last generation as well as the best <code>elitism</code> chromosomes from all generations.
</p>


<h3>Value</h3>

<p>An object of type <code><a href="#topic+GenAlg">GenAlg</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ctrl &lt;- genAlgControl(populationSize = 100, numGenerations = 15, minVariables = 5,
    maxVariables = 12, verbosity = 1)

evaluatorSRCV &lt;- evaluatorPLS(numReplications = 2, innerSegments = 7, testSetSize = 0.4,
    numThreads = 1)

evaluatorRDCV &lt;- evaluatorPLS(numReplications = 2, innerSegments = 5, outerSegments = 3,
    numThreads = 1)

# Generate demo-data
set.seed(12345)
X &lt;- matrix(rnorm(10000, sd = 1:5), ncol = 50, byrow = TRUE)
y &lt;- drop(-1.2 + rowSums(X[, seq(1, 43, length = 8)]) + rnorm(nrow(X), 1.5));

resultSRCV &lt;- genAlg(y, X, control = ctrl, evaluator = evaluatorSRCV, seed = 123)
resultRDCV &lt;- genAlg(y, X, control = ctrl, evaluator = evaluatorRDCV, seed = 123)

subsets(resultSRCV, 1:5)
subsets(resultRDCV, 1:5)
</code></pre>

<hr>
<h2 id='GenAlg-class'>Result of a genetic algorithm run</h2><span id='topic+GenAlg-class'></span><span id='topic+GenAlg'></span>

<h3>Description</h3>

<p>Return object of a run of the genetic algorithm genAlg
</p>


<h3>Slots</h3>


<dl>
<dt><code>subsets</code></dt><dd><p>Logical matrix with one variable subset per column. The columns are ordered according to their fitness (first column contains the fittest variable-subset).</p>
</dd>
<dt><code>rawFitness</code></dt><dd><p>Numeric vector with the raw fitness of the corresponding variable subset returned by the evaluator.</p>
</dd>
<dt><code>response</code></dt><dd><p>The original response vector.</p>
</dd>
<dt><code>covariates</code></dt><dd><p>The original covariates matrix.</p>
</dd>
<dt><code>evaluator</code></dt><dd><p>The evaluator used in the genetic algorithm.</p>
</dd>
<dt><code>control</code></dt><dd><p>The control object.</p>
</dd>
<dt><code>segmentation</code></dt><dd><p>The segments used by the evaluator. Empty list if the evaluator doesn't use segmentation.</p>
</dd>
<dt><code>seed</code></dt><dd><p>The seed the algorithm is started with.</p>
</dd>
</dl>

<hr>
<h2 id='genAlgControl'>Set control arguments for the genetic algorithm</h2><span id='topic+genAlgControl'></span>

<h3>Description</h3>

<p>The population must be large enough to allow the algorithm to explore the whole solution space. If
the initial population is not diverse enough, the chance to find the global optimum is very small.
Thus the more variables to choose from, the larger the population has to be.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>genAlgControl(
  populationSize,
  numGenerations,
  minVariables,
  maxVariables,
  elitism = 10L,
  mutationProbability = 0.01,
  crossover = c("single", "random"),
  maxDuplicateEliminationTries = 0L,
  verbosity = 0L,
  badSolutionThreshold = 2,
  fitnessScaling = c("none", "exp")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="genAlgControl_+3A_populationsize">populationSize</code></td>
<td>
<p>The number of &quot;chromosomes&quot; in the population (between 1 and 2^16)</p>
</td></tr>
<tr><td><code id="genAlgControl_+3A_numgenerations">numGenerations</code></td>
<td>
<p>The number of generations to produce (between 1 and 2^16)</p>
</td></tr>
<tr><td><code id="genAlgControl_+3A_minvariables">minVariables</code></td>
<td>
<p>The minimum number of variables in the variable subset (between 0 and p - 1 where p is the total number of variables)</p>
</td></tr>
<tr><td><code id="genAlgControl_+3A_maxvariables">maxVariables</code></td>
<td>
<p>The maximum number of variables in the variable subset (between 1 and p, and greater than <code>minVariables</code>)</p>
</td></tr>
<tr><td><code id="genAlgControl_+3A_elitism">elitism</code></td>
<td>
<p>The number of absolute best chromosomes to keep across all generations (between 1 and min(<code>populationSize</code> * <code>numGenerations</code>, 2^16))</p>
</td></tr>
<tr><td><code id="genAlgControl_+3A_mutationprobability">mutationProbability</code></td>
<td>
<p>The probability of mutation (between 0 and 1)</p>
</td></tr>
<tr><td><code id="genAlgControl_+3A_crossover">crossover</code></td>
<td>
<p>The crossover type to use during mating (see details). Partial matching is performed</p>
</td></tr>
<tr><td><code id="genAlgControl_+3A_maxduplicateeliminationtries">maxDuplicateEliminationTries</code></td>
<td>
<p>The maximum number of tries to eliminate duplicates
(a value of <code>0</code> or <code>NULL</code> means that no checks for duplicates are done.</p>
</td></tr>
<tr><td><code id="genAlgControl_+3A_verbosity">verbosity</code></td>
<td>
<p>The level of verbosity. 0 means no output at all, 2 is very verbose.</p>
</td></tr>
<tr><td><code id="genAlgControl_+3A_badsolutionthreshold">badSolutionThreshold</code></td>
<td>
<p>The worst child must not be more than <code>badSolutionThreshold</code> times worse than the worse parent.
If less than 0, the child must be even better than the worst parent. If the algorithm can't find a better child
in a long time it issues a warning and uses the last found child to continue.</p>
</td></tr>
<tr><td><code id="genAlgControl_+3A_fitnessscaling">fitnessScaling</code></td>
<td>
<p>How the fitness values are internally scaled before the selection probabilities are assigned
to the chromosomes. See the details for possible values and their meaning.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The initial population is generated randomly. Every chromosome uses between <code>minVariables</code> and
<code>maxVariables</code> (uniformly distributed).
</p>
<p>If the mutation probability (<code>mutationProbability</code> is greater than 0, a random number of
variables is added/removed according to a truncated geometric distribution to each offspring-chromosome.
The resulting distribution of the total number of variables in the subset is not uniform anymore, but almost (the smaller the
mutation probability, the more &quot;uniform&quot; the distribution). This should not be a problem for most
applications.
</p>
<p>The user can choose between <code>single</code> and <code>random</code> crossover for the mating process. If single crossover
is used, a single position is randomly chosen that marks the position to split both parent chromosomes. The child
chromosomes are than the concatenated chromosomes from the 1st part of the 1st parent and the 2nd part of the
2nd parent resp. the 2nd part of the 1st parent and the 1st part of the 2nd parent.
Random crossover is that a random number of random positions are drawn and these positions are transferred
from one parent to the other in order to generate the children.
</p>
<p>Elitism is a method of enhancing the GA by keeping track of very good solutions. The parameter <code>elitism</code>
specifies how many &quot;very good&quot; solutions should be kept.
</p>
<p>Before the selection probabilities are determined, the fitness values <code class="reqn">f</code> of the chromosomes are
standardized to the z-scores (<code class="reqn">z = (f - mu) / sd</code>). Scaling the fitness values afterwards with
the exponential function can help the algorithm to faster find good solutions. When setting
<code>fitnessScaling</code> to <code>"exp"</code>, the (standardized) fitness <code class="reqn">z</code> will be scaled by <code class="reqn">exp(z)</code>.
This promotes good solutions to get an even higher selection probability, while bad solutions
will get an even lower selection probability.
</p>


<h3>Value</h3>

<p>An object of type <code><a href="#topic+GenAlgControl">GenAlgControl</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ctrl &lt;- genAlgControl(populationSize = 100, numGenerations = 15, minVariables = 5,
    maxVariables = 12, verbosity = 1)

evaluatorSRCV &lt;- evaluatorPLS(numReplications = 2, innerSegments = 7, testSetSize = 0.4,
    numThreads = 1)

evaluatorRDCV &lt;- evaluatorPLS(numReplications = 2, innerSegments = 5, outerSegments = 3,
    numThreads = 1)

# Generate demo-data
set.seed(12345)
X &lt;- matrix(rnorm(10000, sd = 1:5), ncol = 50, byrow = TRUE)
y &lt;- drop(-1.2 + rowSums(X[, seq(1, 43, length = 8)]) + rnorm(nrow(X), 1.5));

resultSRCV &lt;- genAlg(y, X, control = ctrl, evaluator = evaluatorSRCV, seed = 123)
resultRDCV &lt;- genAlg(y, X, control = ctrl, evaluator = evaluatorRDCV, seed = 123)

subsets(resultSRCV, 1:5)
subsets(resultRDCV, 1:5)
</code></pre>

<hr>
<h2 id='GenAlgControl-class'>Control class for the genetic algorithm</h2><span id='topic+GenAlgControl-class'></span><span id='topic+GenAlgControl'></span>

<h3>Description</h3>

<p>This class controls the general setup of the genetic algorithm
</p>


<h3>Slots</h3>


<dl>
<dt><code>populationSize</code></dt><dd><p>The number of &quot;chromosomes&quot; in the population (between 1 and 2^16).</p>
</dd>
<dt><code>numGenerations</code></dt><dd><p>The number of generations to produce (between 1 and 2^16).</p>
</dd>
<dt><code>minVariables</code></dt><dd><p>The minimum number of variables in the variable subset (between 0 and p - 1 where p is the total number of variables).</p>
</dd>
<dt><code>maxVariables</code></dt><dd><p>The maximum number of variables in the variable subset (between 1 and p, and greater than <code>minVariables</code>).</p>
</dd>
<dt><code>elitism</code></dt><dd><p>The number of absolute best chromosomes to keep across all generations (between 1 and min(<code>populationSize</code> * <code>numGenerations</code>, 2^16)).</p>
</dd>
<dt><code>mutationProbability</code></dt><dd><p>The probability of mutation (between 0 and 1).</p>
</dd>
<dt><code>badSolutionThreshold</code></dt><dd><p>The child must not be more than <code>badSolutionThreshold</code> percent worse than the worse parent. If less than 0, the child must be even better than the worst parent.</p>
</dd>
<dt><code>crossover</code></dt><dd><p>The crossover method to use</p>
</dd>
<dt><code>crossoverId</code></dt><dd><p>The numeric ID of the crossover method to use</p>
</dd>
<dt><code>maxDuplicateEliminationTries</code></dt><dd><p>The maximum number of tries to eliminate duplicates</p>
</dd>
<dt><code>verbosity</code></dt><dd><p>The level of verbosity. 0 means no output at all, 2 is very verbose.</p>
</dd>
</dl>

<hr>
<h2 id='GenAlgEvaluator-class'>Evaluator Base Class</h2><span id='topic+GenAlgEvaluator-class'></span><span id='topic+GenAlgEvaluator'></span>

<h3>Description</h3>

<p>Virtual base class of all available evaluators
</p>

<hr>
<h2 id='GenAlgFitEvaluator-class'>Fit Evaluator</h2><span id='topic+GenAlgFitEvaluator-class'></span><span id='topic+GenAlgFitEvaluator'></span>

<h3>Description</h3>

<p>Fit Evaluator
</p>


<h3>Slots</h3>


<dl>
<dt><code>numSegments</code></dt><dd><p>The number of CV segments used in one replication.</p>
</dd>
<dt><code>numThreads</code></dt><dd><p>The maximum number of threads the algorithm is allowed to spawn (a value less than 1 or NULL means no threads).</p>
</dd>
<dt><code>maxNComp</code></dt><dd><p>The maximum number of components to consider in the PLS model.</p>
</dd>
<dt><code>sdfact</code></dt><dd><p>The factor to scale the stand. dev. of the MSEP values when selecting the optimal number
of components. For the &quot;one standard error rule&quot;, <code>sdfact</code> is 1.</p>
</dd>
<dt><code>statistic</code></dt><dd><p>The statistic used to evaluate the fitness.</p>
</dd>
<dt><code>statisticId</code></dt><dd><p>The (internal) numeric ID of the statistic.</p>
</dd>
</dl>

<hr>
<h2 id='GenAlgLMEvaluator-class'>LM Evaluator</h2><span id='topic+GenAlgLMEvaluator-class'></span><span id='topic+GenAlgLMEvaluator'></span>

<h3>Description</h3>

<p>LM Evaluator
</p>


<h3>Slots</h3>


<dl>
<dt><code>statistic</code></dt><dd><p>The statistic used to evaluate the fitness.</p>
</dd>
<dt><code>statisticId</code></dt><dd><p>The (internal) numeric ID of the statistic.</p>
</dd>
<dt><code>numThreads</code></dt><dd><p>The maximum number of threads the algorithm is allowed to spawn (a value less than 1 or NULL means no threads).</p>
</dd>
</dl>

<hr>
<h2 id='GenAlgPLSEvaluator-class'>PLS Evaluator</h2><span id='topic+GenAlgPLSEvaluator-class'></span><span id='topic+GenAlgPLSEvaluator'></span>

<h3>Description</h3>

<p>PLS Evaluator
</p>


<h3>Slots</h3>


<dl>
<dt><code>numReplications</code></dt><dd><p>The number of replications used to evaluate a variable subset.</p>
</dd>
<dt><code>innerSegments</code></dt><dd><p>The number of inner RDCV segments used in one replication.</p>
</dd>
<dt><code>outerSegments</code></dt><dd><p>The number of outer RDCV segments used in one replication.</p>
</dd>
<dt><code>testSetSize</code></dt><dd><p>The relative size of the test set (between 0 and 1).</p>
</dd>
<dt><code>sdfact</code></dt><dd><p>The factor to scale the stand. dev. of the MSEP values when selecting the optimal number
of components. For the &quot;one standard error rule&quot;, <code>sdfact</code> is 1.</p>
</dd>
<dt><code>numThreads</code></dt><dd><p>The maximum number of threads the algorithm is allowed to spawn (a value less than 1 or NULL means no threads).</p>
</dd>
<dt><code>maxNComp</code></dt><dd><p>The maximum number of components to consider in the PLS model.</p>
</dd>
<dt><code>method</code></dt><dd><p>The PLS method used to fit the PLS model (currently only SIMPLS is implemented).</p>
</dd>
<dt><code>methodId</code></dt><dd><p>The ID of the PLS method used to fit the PLS model (see C++ code for allowed values).</p>
</dd>
</dl>

<hr>
<h2 id='GenAlgUserEvaluator-class'>User Function Evaluator</h2><span id='topic+GenAlgUserEvaluator-class'></span><span id='topic+GenAlgUserEvaluator'></span>

<h3>Description</h3>

<p>User Function Evaluator
</p>


<h3>Slots</h3>


<dl>
<dt><code>evalFunction</code></dt><dd><p>The function that is called to evaluate the variable subset.</p>
</dd>
<dt><code>sepFunction</code></dt><dd><p>The function that calculates the standard error of prediction for the found subsets.</p>
</dd>
</dl>

<hr>
<h2 id='getEvalFun'>Get the evaluation function from a GenAlgUserEvaluator</h2><span id='topic+getEvalFun'></span><span id='topic+getEvalFun+2CGenAlgUserEvaluator+2CGenAlg-method'></span><span id='topic+getEvalFun+2CGenAlgUserEvaluator+2Cmatrix-method'></span><span id='topic+getEvalFun+2CGenAlgEvaluator+2CGenAlg-method'></span><span id='topic+getEvalFun+2CGenAlgEvaluator+2Cmatrix-method'></span>

<h3>Description</h3>

<p>This method returns the correct evaluation function from a GenAlgUserEvaluator
that can be used by the C++-code as callback or NULL for any other evaluator
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getEvalFun(object, genAlg)

## S4 method for signature 'GenAlgUserEvaluator,GenAlg'
getEvalFun(object, genAlg)

## S4 method for signature 'GenAlgUserEvaluator,matrix'
getEvalFun(object, genAlg)

## S4 method for signature 'GenAlgEvaluator,GenAlg'
getEvalFun(object, genAlg)

## S4 method for signature 'GenAlgEvaluator,matrix'
getEvalFun(object, genAlg)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getEvalFun_+3A_object">object</code></td>
<td>
<p>The evaluator (an object of type <code><a href="#topic+GenAlgEvaluator">GenAlgEvaluator</a></code>)</p>
</td></tr>
<tr><td><code id="getEvalFun_+3A_genalg">genAlg</code></td>
<td>
<p>The <code><a href="#topic+GenAlg">GenAlg</a></code> object</p>
</td></tr>
</table>

<hr>
<h2 id='subsets'>Get the found variable subset(s)</h2><span id='topic+subsets'></span>

<h3>Description</h3>

<p>Get a list of variable indices/names of the found variable subsets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>subsets(object, indices, names = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="subsets_+3A_object">object</code></td>
<td>
<p>The GenAlg object returned by <code><a href="#topic+genAlg">genAlg</a></code>.</p>
</td></tr>
<tr><td><code id="subsets_+3A_indices">indices</code></td>
<td>
<p>The indices of the subsets or empty if all subsets should be returned.</p>
</td></tr>
<tr><td><code id="subsets_+3A_names">names</code></td>
<td>
<p>Should the names or the column numbers of the variables be returned.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This method is used to get the names or indices of the variables used in specified variable subsets.
</p>


<h3>Value</h3>

<p>A logical matrix where each column represents a variable subset
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ctrl &lt;- genAlgControl(populationSize = 200, numGenerations = 15, minVariables = 5,
    maxVariables = 12, verbosity = 1)

evaluator &lt;- evaluatorPLS(numReplications = 2, innerSegments = 7, testSetSize = 0.4,
    numThreads = 1)

# Generate demo-data
set.seed(12345)
X &lt;- matrix(rnorm(10000, sd = 1:5), ncol = 50, byrow = TRUE)
y &lt;- drop(-1.2 + rowSums(X[, seq(1, 43, length = 8)]) + rnorm(nrow(X), 1.5));

result &lt;- genAlg(y, X, control = ctrl, evaluator = evaluator, seed = 123)

subsets(result, names = TRUE, indices = 1:5) # best 5 variable subsets as a list of names
result@subsets[ , 1:5] # best 5 variable subsets as a logical matrix with the subsets in the columns
</code></pre>

<hr>
<h2 id='toCControlList'>Transform the object to a list</h2><span id='topic+toCControlList'></span><span id='topic+toCControlList+2CGenAlgPLSEvaluator-method'></span><span id='topic+toCControlList+2CGenAlgFitEvaluator-method'></span><span id='topic+toCControlList+2CGenAlgUserEvaluator-method'></span><span id='topic+toCControlList+2CGenAlgLMEvaluator-method'></span><span id='topic+toCControlList+2CGenAlgControl-method'></span>

<h3>Description</h3>

<p>Get the control list for the C++ procedure genAlgPLS from the object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>toCControlList(object)

## S4 method for signature 'GenAlgPLSEvaluator'
toCControlList(object)

## S4 method for signature 'GenAlgFitEvaluator'
toCControlList(object)

## S4 method for signature 'GenAlgUserEvaluator'
toCControlList(object)

## S4 method for signature 'GenAlgLMEvaluator'
toCControlList(object)

## S4 method for signature 'GenAlgControl'
toCControlList(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="toCControlList_+3A_object">object</code></td>
<td>
<p>The object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with all items expected by the C++ code
</p>

<hr>
<h2 id='trueFitnessVal'>Get the transformed fitness values</h2><span id='topic+trueFitnessVal'></span><span id='topic+trueFitnessVal+2CGenAlgPLSEvaluator+2Cnumeric-method'></span><span id='topic+trueFitnessVal+2CGenAlgUserEvaluator+2Cnumeric-method'></span><span id='topic+trueFitnessVal+2CGenAlgLMEvaluator+2Cnumeric-method'></span><span id='topic+trueFitnessVal+2CGenAlgFitEvaluator+2Cnumeric-method'></span>

<h3>Description</h3>

<p>Transform the given fitness values according tho the GenAlgEvaluator class
</p>


<h3>Usage</h3>

<pre><code class='language-R'>trueFitnessVal(object, fitness)

## S4 method for signature 'GenAlgPLSEvaluator,numeric'
trueFitnessVal(object, fitness)

## S4 method for signature 'GenAlgUserEvaluator,numeric'
trueFitnessVal(object, fitness)

## S4 method for signature 'GenAlgLMEvaluator,numeric'
trueFitnessVal(object, fitness)

## S4 method for signature 'GenAlgFitEvaluator,numeric'
trueFitnessVal(object, fitness)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="trueFitnessVal_+3A_object">object</code></td>
<td>
<p>The used evaluator, an object with type or with a subtype of <code><a href="#topic+GenAlgEvaluator">GenAlgEvaluator</a></code></p>
</td></tr>
<tr><td><code id="trueFitnessVal_+3A_fitness">fitness</code></td>
<td>
<p>A numeric vector of fitnesses</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This method is used to calculate the true fitness given the GenAlgEvaluator class (as they use
different internal fitness measures)
</p>


<h3>Value</h3>

<p>A vector with the true fitness values
</p>

<hr>
<h2 id='validData'>Check if the data is valid for the evaluator</h2><span id='topic+validData'></span><span id='topic+validData+2CGenAlgPLSEvaluator+2CGenAlg-method'></span><span id='topic+validData+2CGenAlgFitEvaluator+2CGenAlg-method'></span><span id='topic+validData+2CGenAlgLMEvaluator+2CGenAlg-method'></span><span id='topic+validData+2CGenAlgEvaluator+2CGenAlg-method'></span>

<h3>Description</h3>

<p>This method checks if the covariates matrix is valid for the evaluator
</p>


<h3>Usage</h3>

<pre><code class='language-R'>validData(object, genAlg)

## S4 method for signature 'GenAlgPLSEvaluator,GenAlg'
validData(object, genAlg)

## S4 method for signature 'GenAlgFitEvaluator,GenAlg'
validData(object, genAlg)

## S4 method for signature 'GenAlgLMEvaluator,GenAlg'
validData(object, genAlg)

## S4 method for signature 'GenAlgEvaluator,GenAlg'
validData(object, genAlg)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="validData_+3A_object">object</code></td>
<td>
<p>The evaluator</p>
</td></tr>
<tr><td><code id="validData_+3A_genalg">genAlg</code></td>
<td>
<p>The GenAlg object the evaluator is used in</p>
</td></tr>
</table>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
