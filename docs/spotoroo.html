<!DOCTYPE html><html><head><title>Help for package spotoroo</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {spotoroo}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#spotoroo-package'><p>spotoroo: Spatiotemporal Clustering of Satellite Hot Spot Data</p></a></li>
<li><a href='#dist_point_to_vector'><p>Calculation of the geodesic of a point to multiple points</p></a></li>
<li><a href='#extract_fire'><p>Extracting fires from the spatiotemporal clustering results</p></a></li>
<li><a href='#get_fire_mov'><p>Calculation of the fire movement</p></a></li>
<li><a href='#global_clustering'><p>Clustering hot spots spatially and temporally</p></a></li>
<li><a href='#handle_noise'><p>Handling noise in the clustering results</p></a></li>
<li><a href='#hotspot_cluster'><p>Spatiotemporal clustering of hot spot data</p></a></li>
<li><a href='#hotspots'><p>1070 observations of satellite hot spots</p></a></li>
<li><a href='#ignition_point'><p>Calculation of the ignition points</p></a></li>
<li><a href='#local_clustering'><p>Clustering hot spots spatially</p></a></li>
<li><a href='#plot_def'><p>Default method of plotting the clustering results</p></a></li>
<li><a href='#plot_fire_mov'><p>Plotting the fire movement</p></a></li>
<li><a href='#plot_spotoroo'><p>Plotting spatiotemporal clustering result</p></a></li>
<li><a href='#plot_timeline'><p>Plotting the timeline of the fire and the noise</p></a></li>
<li><a href='#plot_vic_map'><p>Plotting map of Victoria, Australia</p></a></li>
<li><a href='#plot.spotoroo'><p>Plotting spatiotemporal clustering result</p></a></li>
<li><a href='#print.spotoroo'><p>Printing spatiotemporal clustering result</p></a></li>
<li><a href='#summary_spotoroo'><p>Summarizing spatiotemporal clustering results</p></a></li>
<li><a href='#summary.spotoroo'><p>Summarizing spatiotemporal clustering result</p></a></li>
<li><a href='#transform_time_id'><p>Transforming a series of time or datetime to time indexes</p></a></li>
<li><a href='#vic_map'><p>simple features map of Victoria</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Spatiotemporal Clustering of Satellite Hot Spot Data</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.4</td>
</tr>
<tr>
<td>Description:</td>
<td>An algorithm to cluster satellite hot spot data spatially and temporally.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://tengmcing.github.io/spotoroo/">https://tengmcing.github.io/spotoroo/</a>,
<a href="https://github.com/TengMCing/spotoroo/">https://github.com/TengMCing/spotoroo/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/TengMCing/spotoroo/issues">https://github.com/TengMCing/spotoroo/issues</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.1</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.3.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>utils, geodist (&ge; 0.0.4), progress (&ge; 1.2.2), dplyr (&ge;
1.0.0), cli (&ge; 2.3.0), stats, patchwork, ggrepel, ggExtra (&ge;
0.9), ggbeeswarm (&ge; 0.7.2), ggplot2 (&ge; 3.0.0)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>sf (&ge; 0.7-3), testthat (&ge; 3.0.0), covr, knitr, rmarkdown,
markdown</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-08-21 05:29:13 UTC; patrickli</td>
</tr>
<tr>
<td>Author:</td>
<td>Weihao Li <a href="https://orcid.org/0000-0003-4959-106X"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut,
    cre],
  Di Cook <a href="https://orcid.org/0000-0002-3813-7155"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [ctb],
  Emily Dodwell [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Weihao Li &lt;llreczx@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-08-21 05:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='spotoroo-package'>spotoroo: Spatiotemporal Clustering of Satellite Hot Spot Data</h2><span id='topic+spotoroo'></span><span id='topic+spotoroo-package'></span>

<h3>Description</h3>

<p>An algorithm to cluster satellite hot spot data spatially and temporally.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Weihao Li <a href="mailto:llreczx@gmail.com">llreczx@gmail.com</a> (<a href="https://orcid.org/0000-0003-4959-106X">ORCID</a>)
</p>
<p>Other contributors:
</p>

<ul>
<li><p> Di Cook <a href="mailto:dicook@monash.edu">dicook@monash.edu</a> (<a href="https://orcid.org/0000-0002-3813-7155">ORCID</a>) [contributor]
</p>
</li>
<li><p> Emily Dodwell <a href="mailto:emdodwell@gmail.com">emdodwell@gmail.com</a> [contributor]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://tengmcing.github.io/spotoroo/">https://tengmcing.github.io/spotoroo/</a>
</p>
</li>
<li> <p><a href="https://github.com/TengMCing/spotoroo/">https://github.com/TengMCing/spotoroo/</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/TengMCing/spotoroo/issues">https://github.com/TengMCing/spotoroo/issues</a>
</p>
</li></ul>


<hr>
<h2 id='dist_point_to_vector'>Calculation of the geodesic of a point to multiple points</h2><span id='topic+dist_point_to_vector'></span>

<h3>Description</h3>

<p>This function calculates the geodesic of a point to multiple
points given the coordinate information. It is a wrapper of
<code><a href="geodist.html#topic+geodist_vec">geodist::geodist_vec()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dist_point_to_vector(plon, plat, vlon, vlat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dist_point_to_vector_+3A_plon">plon</code></td>
<td>
<p>Numeric. The longitude of a point.</p>
</td></tr>
<tr><td><code id="dist_point_to_vector_+3A_plat">plat</code></td>
<td>
<p>Numeric. The latitude of a point.</p>
</td></tr>
<tr><td><code id="dist_point_to_vector_+3A_vlon">vlon</code></td>
<td>
<p>Numeric. A vector of longitude values.</p>
</td></tr>
<tr><td><code id="dist_point_to_vector_+3A_vlat">vlat</code></td>
<td>
<p>Numeric. A vector of latitude values.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric. The geodesic of a point to multiple points in meters.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Define vlon and vlat
vlon &lt;- c(141.12, 141.13)
vlat &lt;- c(-37.1, -37.0)

# Calculate the geodesic
dist_point_to_vector(141.12, -37.1, vlon, vlat)

</code></pre>

<hr>
<h2 id='extract_fire'>Extracting fires from the spatiotemporal clustering results</h2><span id='topic+extract_fire'></span>

<h3>Description</h3>

<p>This function takes a <code>spotoroo</code> object to produce a data frame which
contains information about the fire.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract_fire(result, cluster = "all", noise = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extract_fire_+3A_result">result</code></td>
<td>
<p><code>spotoroo</code> object.
A result of a call to <code><a href="#topic+hotspot_cluster">hotspot_cluster()</a></code>.</p>
</td></tr>
<tr><td><code id="extract_fire_+3A_cluster">cluster</code></td>
<td>
<p>Character/Integer. If &quot;all&quot;, extract all clusters.
If an integer vector is given, extract corresponding
clusters.</p>
</td></tr>
<tr><td><code id="extract_fire_+3A_noise">noise</code></td>
<td>
<p>Logical. Whether or not to include noise.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame. The fire information
</p>

<ul>
<li> <p><code>lon</code> : Longitude.
</p>
</li>
<li> <p><code>lat</code> : Latitude.
</p>
</li>
<li> <p><code>obsTime</code> : Observed time.
</p>
</li>
<li> <p><code>timeID</code> : Time indexes.
</p>
</li>
<li> <p><code>membership</code> : Membership labels.
</p>
</li>
<li> <p><code>noise</code> : Whether it is a noise point.
</p>
</li>
<li> <p><code>distToIgnition</code> : Distance to the ignition location.
</p>
</li>
<li> <p><code>distToIgnitionUnit</code> : Unit of distance to the ignition
location.
</p>
</li>
<li> <p><code>timeFromIgnition</code> : Time from ignition.
</p>
</li>
<li> <p><code>timeFromIgnitionUnit</code> : Unit of time from ignition.
</p>
</li>
<li> <p><code>type</code> : Type of the entry, either &quot;hotspot&quot;, &quot;noise&quot; or
&quot;ignition&quot;
</p>
</li>
<li> <p><code>obsInCluster</code> : Number of observations in the cluster.
</p>
</li>
<li> <p><code>clusterTimeLen</code> : Length of time of the cluster.
</p>
</li>
<li> <p><code>clusterTimeLenUnit</code> : Unit of length of time of the
cluster.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>

  # Time consuming functions (&gt;5 seconds)


  # Get clustering results
  result &lt;- hotspot_cluster(hotspots,
                          lon = "lon",
                          lat = "lat",
                          obsTime = "obsTime",
                          activeTime = 24,
                          adjDist = 3000,
                          minPts = 4,
                          minTime = 3,
                          ignitionCenter = "mean",
                          timeUnit = "h",
                          timeStep = 1)


  # Extract all fires
  all_fires &lt;- extract_fire(result)
  head(all_fires, 3)

  # Extract cluster 4
  fire_4 &lt;- extract_fire(result, 4)
  head(fire_4, 3)


</code></pre>

<hr>
<h2 id='get_fire_mov'>Calculation of the fire movement</h2><span id='topic+get_fire_mov'></span>

<h3>Description</h3>

<p>This function calculates the movement of a single fire per <code>step</code> time
indexes. It collects hot spots per <code>step</code> time indexes, then
takes the mean or median of the longitude and latitude as the centre of the
fire.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_fire_mov(result, cluster, step = 1, method = "mean")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_fire_mov_+3A_result">result</code></td>
<td>
<p><code>spotoroo</code> object. A result of a call to <code><a href="#topic+hotspot_cluster">hotspot_cluster()</a></code>.</p>
</td></tr>
<tr><td><code id="get_fire_mov_+3A_cluster">cluster</code></td>
<td>
<p>Integer. The membership label of the cluster.</p>
</td></tr>
<tr><td><code id="get_fire_mov_+3A_step">step</code></td>
<td>
<p>Integer (&gt;0). Step size used in the calculation of the
fire movement.</p>
</td></tr>
<tr><td><code id="get_fire_mov_+3A_method">method</code></td>
<td>
<p>Character. Either &quot;mean&quot; or &quot;median&quot;,
method of the calculation of
the centre of the fire.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame. The fire movement.
</p>

<ul>
<li> <p><code>membership</code> : Membership labels.
</p>
</li>
<li> <p><code>lon</code> : Longitude of the centre of the fire.
</p>
</li>
<li> <p><code>lat</code> : Latitude of the centre of the fire.
</p>
</li>
<li> <p><code>timeID</code> : Time indexes.
</p>
</li>
<li> <p><code>obsTime</code> : Observed time (approximated).
</p>
</li>
<li> <p><code>ignition</code> : Whether or not it is a ignition point.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>


  # Time consuming functions (&gt;5 seconds)


  # Get clustering results
  result &lt;- hotspot_cluster(hotspots,
                          lon = "lon",
                          lat = "lat",
                          obsTime = "obsTime",
                          activeTime = 24,
                          adjDist = 3000,
                          minPts = 4,
                          minTime = 3,
                          ignitionCenter = "mean",
                          timeUnit = "h",
                          timeStep = 1)

  # Get fire movement of the first cluster
  mov1 &lt;- get_fire_mov(result, cluster = 1, step = 3, method = "mean")
  mov1

  # Get fire movement of the second cluster
  mov2 &lt;- get_fire_mov(result, cluster = 2, step = 6, method = "median")
  mov2



</code></pre>

<hr>
<h2 id='global_clustering'>Clustering hot spots spatially and temporally</h2><span id='topic+global_clustering'></span>

<h3>Description</h3>

<p>This function clusters hot spots spatially and temporally.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>global_clustering(lon, lat, timeID, activeTime, adjDist)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="global_clustering_+3A_lon">lon</code></td>
<td>
<p>Numeric. A vector of longitude values.</p>
</td></tr>
<tr><td><code id="global_clustering_+3A_lat">lat</code></td>
<td>
<p>Numeric. A vector of latitude values.</p>
</td></tr>
<tr><td><code id="global_clustering_+3A_timeid">timeID</code></td>
<td>
<p>Integer (&gt;=1). A vector of time indexes.</p>
</td></tr>
<tr><td><code id="global_clustering_+3A_activetime">activeTime</code></td>
<td>
<p>Numeric (&gt;=0). Time tolerance. Unit is time index.</p>
</td></tr>
<tr><td><code id="global_clustering_+3A_adjdist">adjDist</code></td>
<td>
<p>Numeric (&gt;0). Distance tolerance. Unit is metre.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For more details about the clustering algorithm and the arguments
<code>activeTime</code> and <code>adjDist</code>, please check the documentation
of <code><a href="#topic+hotspot_cluster">hotspot_cluster()</a></code>.
This function performs the <strong>first 3 steps</strong> of the clustering algorithm.
</p>


<h3>Value</h3>

<p>Integer. A vector of membership labels.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Define lon, lat and timeID for 10 observations
lon &lt;- c(141.1, 141.14, 141.12, 141.14, 141.16, 141.12, 141.14,
          141.16, 141.12, 141.14)
lat &lt;- c(-37.10, -37.10, -37.12, -37.12, -37.12, -37.14, -37.14,
         -37.14, -37.16, -37.16)
timeID &lt;- c(rep(1, 5), rep(26, 5))

# Cluster 10 hot spots with different values of activeTime and adjDist
global_clustering(lon, lat, timeID, 12, 1500)
global_clustering(lon, lat, timeID, 24, 3000)
global_clustering(lon, lat, timeID, 36, 6000)

</code></pre>

<hr>
<h2 id='handle_noise'>Handling noise in the clustering results</h2><span id='topic+handle_noise'></span>

<h3>Description</h3>

<p>This function finds noise from the clustering results and label it with
<code>-1</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>handle_noise(global_membership, timeID, minPts, minTime)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="handle_noise_+3A_global_membership">global_membership</code></td>
<td>
<p>Integer. A vector of membership labels.</p>
</td></tr>
<tr><td><code id="handle_noise_+3A_timeid">timeID</code></td>
<td>
<p>Integer. A vector of time indexes.</p>
</td></tr>
<tr><td><code id="handle_noise_+3A_minpts">minPts</code></td>
<td>
<p>Numeric (&gt;0). Minimum number of hot spots in a cluster.</p>
</td></tr>
<tr><td><code id="handle_noise_+3A_mintime">minTime</code></td>
<td>
<p>Numeric (&gt;=0). Minimum length of time of a cluster.
Unit is time index.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For more details about the clustering algorithm and the arguments
<code>minPts</code> and <code>minTime</code>, please check the documentation
of <code><a href="#topic+hotspot_cluster">hotspot_cluster()</a></code>.
This function performs the <strong>step 4</strong> of the clustering algorithm. It uses a
given threshold (minimum number of points and minimum length of time) to
find noise and label it with <code>-1</code>.
</p>


<h3>Value</h3>

<p>Integer. A vector of membership labels.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Define membership labels and timeID for 10 observations
global_membership &lt;- c(1,1,1,2,2,2,2,2,2,3,3,3,3,3,3)
timeID &lt;- c(1,2,3,2,3,3,4,5,6,3,3,3,3,3,3)

# Handle noise with different values of minPts and minTime
handle_noise(global_membership, timeID, 4, 0)
handle_noise(global_membership, timeID, 4, 1)
handle_noise(global_membership, timeID, 3, 3)

</code></pre>

<hr>
<h2 id='hotspot_cluster'>Spatiotemporal clustering of hot spot data</h2><span id='topic+hotspot_cluster'></span>

<h3>Description</h3>

<p>This is the main function of the package.
<br />
This function clusters hot spots into fires. It can be used to
reconstruct fire history and detect fire ignition points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hotspot_cluster(
  hotspots,
  lon = "lon",
  lat = "lat",
  obsTime = "obsTime",
  activeTime = 24,
  adjDist = 3000,
  minPts = 4,
  minTime = 3,
  ignitionCenter = "mean",
  timeUnit = "n",
  timeStep = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hotspot_cluster_+3A_hotspots">hotspots</code></td>
<td>
<p>List/Data frame. A list or a data frame which
contains information of hot spots.</p>
</td></tr>
<tr><td><code id="hotspot_cluster_+3A_lon">lon</code></td>
<td>
<p>Character. The name of the column of the list which contains
numeric longitude values.</p>
</td></tr>
<tr><td><code id="hotspot_cluster_+3A_lat">lat</code></td>
<td>
<p>Character. The name of the column of the list which contains
numeric latitude values.</p>
</td></tr>
<tr><td><code id="hotspot_cluster_+3A_obstime">obsTime</code></td>
<td>
<p>Character. The name of the column of the list which contains
the observed time of hot spots. The observed time
has to be in date, datetime or numeric.</p>
</td></tr>
<tr><td><code id="hotspot_cluster_+3A_activetime">activeTime</code></td>
<td>
<p>Numeric (&gt;=0). Time tolerance. Unit is time index.</p>
</td></tr>
<tr><td><code id="hotspot_cluster_+3A_adjdist">adjDist</code></td>
<td>
<p>Numeric (&gt;0). Distance tolerance. Unit is metre.</p>
</td></tr>
<tr><td><code id="hotspot_cluster_+3A_minpts">minPts</code></td>
<td>
<p>Numeric (&gt;0). Minimum number of hot spots in a cluster.</p>
</td></tr>
<tr><td><code id="hotspot_cluster_+3A_mintime">minTime</code></td>
<td>
<p>Numeric (&gt;=0). Minimum length of time of a cluster.
Unit is time index.</p>
</td></tr>
<tr><td><code id="hotspot_cluster_+3A_ignitioncenter">ignitionCenter</code></td>
<td>
<p>Character. Method to calculate ignition points,
either &quot;mean&quot; or &quot;median&quot;.</p>
</td></tr>
<tr><td><code id="hotspot_cluster_+3A_timeunit">timeUnit</code></td>
<td>
<p>Character. One of &quot;s&quot; (seconds),
&quot;m&quot; (minutes), &quot;h&quot; (hours),
&quot;d&quot; (days) and &quot;n&quot; (numeric).</p>
</td></tr>
<tr><td><code id="hotspot_cluster_+3A_timestep">timeStep</code></td>
<td>
<p>Numeric (&gt;0). Number of units of <code>timeUnit</code> in a time step.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Arguments <code>timeUnit</code> and <code>timeStep</code> need to be
specified to convert date/datetime/numeric to time index.
More details can be found in <code><a href="#topic+transform_time_id">transform_time_id()</a></code>.
<br /><br />
This clustering algorithm consisted of <strong>5 steps</strong>:
<br /><br />
In <strong>step 1</strong>, it defines <code class="reqn">T</code> intervals using the time index
</p>
<p style="text-align: center;"><code class="reqn">Interval(t) = [max(1, t - activeTime),t]</code>
</p>

<p>where <code class="reqn">t = 1, 2, ..., T</code>, and <code class="reqn">T</code> is the maximum time index.
<code>activeTime</code> is an argument that needs to be specified. It represents
the maximum time difference between two hot spots in the same local
cluster. Please notice that a local cluster is different with a cluster
in the final result. More details will be given in the next part.
<br /><br />
In <strong>step 2</strong>, the algorithm performs spatial clustering on each interval.
A local cluster is a cluster found in an interval. Argument <code>adjDist</code>
is used to control the spatial clustering. If the distance between two
hot spots is smaller or equal to <code>adjDist</code>, they are directly-connected. If
hot spot <code>A</code> is directly-connected with hot spot <code>B</code> and hot spot <code>B</code> is
directly-connected with hot spot <code>C</code>, hot spot <code>A</code>, <code>B</code> and <code>C</code> are
connected. All connected hot spots become a local cluster.
<br /><br />
In <strong>step 3</strong>, the algorithm starts from interval <code class="reqn">1</code>. It marks all
hot spots in this interval and records their membership labels.
Then it moves on to interval <code class="reqn">2</code>. Due to a hot spot could exist in
multiple intervals, it checks whether any hot spot in interval <code class="reqn">2</code>
has been marked. If there is any, their membership labels will be
carried over from the record. Unmarked hot spots in interval <code class="reqn">2</code>,
which share the same local cluster with marked hot spots, their
membership labels are carried over from marked hot spots. If a unmarked
hot spot shares the same local cluster with multiple marked hot spots, the
algorithm will carry over the membership label from the nearest one. All
other unmarked hot spots in interval <code class="reqn">2</code> that do not share the same
cluster with any marked hot spot, their membership labels will be adjusted
such that the clusters they belong to are considered to be new clusters.
Finally, all
hot spots in interval <code class="reqn">2</code> are marked and their membership labels are
recorded. This process continues for interval <code class="reqn">3</code>, <code class="reqn">4</code>, ...,
<code class="reqn">T</code>. After finishing step 3, all hot spots are marked and their
membership labels are recorded.
<br /><br />
In <strong>step 4</strong>, it checks each cluster. If there is any cluster contains less
than <code>minPts</code> hot spots, or lasts shorter than <code>minTime</code>, it will not be
considered to be a cluster any more, and their hot spots will be
assigned with <code>-1</code> as their membership labels. A hot spot with membership
label <code>-1</code> is noise.
Arguments <code>minPts</code> and <code>minTime</code> need to be specified.
<br /><br />
In <strong>step 5</strong>, the algorithm finds the earliest observed hot spots in each
cluster and records them as ignition points. If there are multiple
earliest observed hot spots in a cluster, the mean or median of the
longitude values and the latitude values will be used as the coordinate
of the ignition point. This needs to be specified in argument
<code>ignitionCenter</code>.
</p>


<h3>Value</h3>

<p>A <code>spotoroo</code> object. The clustering results. It is also a list:
</p>

<ul>
<li> <p><code>hotspots</code> : A data frame contains information of hot spots.
</p>

<ul>
<li> <p><code>lon</code> : Longitude.
</p>
</li>
<li> <p><code>lat</code> : Latitude.
</p>
</li>
<li> <p><code>obsTime</code> : Observed time.
</p>
</li>
<li> <p><code>timeID</code> : Time index.
</p>
</li>
<li> <p><code>membership</code> : Membership label.
</p>
</li>
<li> <p><code>noise</code> : Whether it is a noise point.
</p>
</li>
<li> <p><code>distToIgnition</code> : Distance to the ignition location.
</p>
</li>
<li> <p><code>distToIgnitionUnit</code> : Unit of distance to the ignition
location.
</p>
</li>
<li> <p><code>timeFromIgnition</code> : Time from ignition.
</p>
</li>
<li> <p><code>timeFromIgnitionUnit</code> : Unit of time from ignition.
</p>
</li></ul>

</li>
<li> <p><code>ignition</code> : A data frame contains information of ignition
points.
</p>

<ul>
<li> <p><code>lon</code> : Longitude.
</p>
</li>
<li> <p><code>lat</code> : Latitude.
</p>
</li>
<li> <p><code>obsTime</code> : Observed time.
</p>
</li>
<li> <p><code>timeID</code> : Time index.
</p>
</li>
<li> <p><code>obsInCluster</code> : Number of observations in the cluster.
</p>
</li>
<li> <p><code>clusterTimeLen</code> : Length of time of the cluster.
</p>
</li>
<li> <p><code>clusterTimeLenUnit</code> : Unit of length of time of the
cluster.
</p>
</li></ul>

</li>
<li> <p><code>setting</code> : A list contains the clustering settings.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>

  # Time consuming functions (&gt;5 seconds)


  # Get clustering results
  result &lt;- hotspot_cluster(hotspots,
                lon = "lon",
                lat = "lat",
                obsTime = "obsTime",
                activeTime = 24,
                adjDist = 3000,
                minPts = 4,
                minTime = 3,
                ignitionCenter = "mean",
                timeUnit = "h",
                timeStep = 1)

  # Make a summary of the clustering results
  summary(result)

  # Make a plot of the clustering results
  plot(result, bg = plot_vic_map())


</code></pre>

<hr>
<h2 id='hotspots'>1070 observations of satellite hot spots</h2><span id='topic+hotspots'></span>

<h3>Description</h3>

<p>A dataset containing the 1070 observations of satellite hot spots in
Victoria, Australia during the 2019-2020 Australian bushfire season.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hotspots
</code></pre>


<h3>Format</h3>

<p>A data frame with 1070 rows and 3 variables:
</p>

<dl>
<dt>lon</dt><dd><p>longitude</p>
</dd>
<dt>lat</dt><dd><p>latitude</p>
</dd>
<dt>obsTime</dt><dd><p>observed time</p>
</dd>
</dl>



<h3>Source</h3>

<p><a href="https://www.eorc.jaxa.jp/ptree/">https://www.eorc.jaxa.jp/ptree/</a>
</p>

<hr>
<h2 id='ignition_point'>Calculation of the ignition points</h2><span id='topic+ignition_point'></span>

<h3>Description</h3>

<p>This function calculates ignition points for all clusters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ignition_point(lon, lat, obsTime, timeUnit, timeID, membership, ignitionCenter)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ignition_point_+3A_lon">lon</code></td>
<td>
<p>Numeric. A vector of longitude values.</p>
</td></tr>
<tr><td><code id="ignition_point_+3A_lat">lat</code></td>
<td>
<p>Numeric. A vector of latitude values.</p>
</td></tr>
<tr><td><code id="ignition_point_+3A_obstime">obsTime</code></td>
<td>
<p>Date/Datetime/Numeric. A vector of observed time.</p>
</td></tr>
<tr><td><code id="ignition_point_+3A_timeunit">timeUnit</code></td>
<td>
<p>Character. One of &quot;s&quot; (seconds), &quot;m&quot;(minutes),
&quot;h&quot;(hours), &quot;d&quot;(days) and &quot;n&quot;(numeric).</p>
</td></tr>
<tr><td><code id="ignition_point_+3A_timeid">timeID</code></td>
<td>
<p>Integer (&gt;=1). A vector of time indexes.</p>
</td></tr>
<tr><td><code id="ignition_point_+3A_membership">membership</code></td>
<td>
<p>Integer. A vector of membership labels.</p>
</td></tr>
<tr><td><code id="ignition_point_+3A_ignitioncenter">ignitionCenter</code></td>
<td>
<p>Character. Method of calculating ignition points,
one of &quot;mean&quot; and &quot;median&quot;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For more details about the clustering algorithm and the argument
<code>timeUnit</code>, <code>timeID</code> and <code>ignitionCenter</code>,
please check the documentation of <code><a href="#topic+hotspot_cluster">hotspot_cluster()</a></code>.
This function performs the <strong>step 5</strong> of the clustering algorithm. It
calculates ignition points.
For a cluster, when there are multiple earliest hot spots, if
<code>ignitionCenter</code> is &quot;mean&quot;, the centroid of these hot spots will be used
as the ignition point. If <code>ignitionCenter</code> is &quot;median&quot;, median longitude
and median latitude of these hot spots will be used.
</p>


<h3>Value</h3>

<p>A data frame of ignition points
</p>

<ul>
<li> <p><code>membership</code> : Membership labels.
</p>
</li>
<li> <p><code>lon</code> : Longitude of ignition points.
</p>
</li>
<li> <p><code>lat</code> : Latitude of ignition points.
</p>
</li>
<li> <p><code>obsTime</code> : Observed time of ignition points.
</p>
</li>
<li> <p><code>timeID</code> : Time indexes.
</p>
</li>
<li> <p><code>obsInCluster</code> : Number of observations in the cluster.
</p>
</li>
<li> <p><code>clusterTimeLen</code> : Length of time of the cluster.
</p>
</li>
<li> <p><code>clusterTimeLenUnit</code> : Unit of length of time of the cluster.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
# Define lon, lat, obsTime, timeID and membership for 10 observations
lon &lt;- c(141.1, 141.14, 141.12, 141.14, 141.16, 141.12, 141.14,
          141.16, 141.12, 141.14)
lat &lt;- c(-37.10, -37.10, -37.12, -37.12, -37.12, -37.14, -37.14,
         -37.14, -37.16, -37.16)
obsTime &lt;- c(rep(1, 5), rep(26, 5))
timeUnit &lt;- "n"
timeID &lt;- c(rep(1, 5), rep(26, 5))
membership &lt;- c(1, 1, 1, 1, 1, 2, 2, 2, 2, 2)

# Calculate the ignition points using different methods
ignition_point(lon, lat, obsTime, timeUnit, timeID, membership, "mean")
ignition_point(lon, lat, obsTime, timeUnit, timeID, membership, "median")

</code></pre>

<hr>
<h2 id='local_clustering'>Clustering hot spots spatially</h2><span id='topic+local_clustering'></span>

<h3>Description</h3>

<p>This function clusters hot spots spatially.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>local_clustering(lon, lat, adjDist)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="local_clustering_+3A_lon">lon</code></td>
<td>
<p>Numeric. A vector of longitude values.</p>
</td></tr>
<tr><td><code id="local_clustering_+3A_lat">lat</code></td>
<td>
<p>Numeric. A vector of latitude values.</p>
</td></tr>
<tr><td><code id="local_clustering_+3A_adjdist">adjDist</code></td>
<td>
<p>Numeric (&gt;0). Distance tolerance. Unit is metre.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For more details about the clustering algorithm and the argument <code>adjDist</code>,
please check the documentation of <code><a href="#topic+hotspot_cluster">hotspot_cluster()</a></code>.
This function performs the <strong>step 2</strong> of the clustering algorithm. It
clusters hot spots in a given interval.
</p>


<h3>Value</h3>

<p>Integer. A vector of membership labels.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Define lon and lat for 10 observations
lon &lt;- c(141.1, 141.14, 141.12, 141.14, 141.16, 141.12, 141.14,
          141.16, 141.12, 141.14)
lat &lt;- c(-37.10, -37.10, -37.12, -37.12, -37.12, -37.14, -37.14,
         -37.14, -37.16, -37.16)

# Cluster 10 hot spots with different values of adjDist
local_clustering(lon, lat, 2000)
local_clustering(lon, lat, 3000)
local_clustering(lon, lat, 4000)

</code></pre>

<hr>
<h2 id='plot_def'>Default method of plotting the clustering results</h2><span id='topic+plot_def'></span>

<h3>Description</h3>

<p>This function plots the clustering result spatially as a scatter plot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_def(
  result,
  cluster = "all",
  hotspot = TRUE,
  noise = FALSE,
  ignition = TRUE,
  from = NULL,
  to = NULL,
  bg = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_def_+3A_result">result</code></td>
<td>
<p><code>spotoroo</code> object. A result of a call to <code><a href="#topic+hotspot_cluster">hotspot_cluster()</a></code>.</p>
</td></tr>
<tr><td><code id="plot_def_+3A_cluster">cluster</code></td>
<td>
<p>Character/Integer. If &quot;all&quot;, plot all clusters. If an integer
vector is given, plot corresponding clusters.</p>
</td></tr>
<tr><td><code id="plot_def_+3A_hotspot">hotspot</code></td>
<td>
<p>Logical. If <code>TRUE</code>, plot the hot spots.</p>
</td></tr>
<tr><td><code id="plot_def_+3A_noise">noise</code></td>
<td>
<p>Logical. If <code>TRUE</code>, plot the noise points.</p>
</td></tr>
<tr><td><code id="plot_def_+3A_ignition">ignition</code></td>
<td>
<p>Logical. If <code>TRUE</code>, plot the ignition points.</p>
</td></tr>
<tr><td><code id="plot_def_+3A_from">from</code></td>
<td>
<p><strong>OPTIONAL</strong>. Date/Datetime/Numeric. Start time. The data type
needs to be the same as the provided
observed time.</p>
</td></tr>
<tr><td><code id="plot_def_+3A_to">to</code></td>
<td>
<p><strong>OPTIONAL</strong>. Date/Datetime/Numeric. End time. The data type
needs to be the same as the provided observed time.</p>
</td></tr>
<tr><td><code id="plot_def_+3A_bg">bg</code></td>
<td>
<p><strong>OPTIONAL</strong>. <code>ggplot</code> object. If specified, plot onto
this object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>ggplot</code> object. The plot of the clustering results.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

  # Time consuming functions (&gt;5 seconds)


  # Get clustering results
  result &lt;- hotspot_cluster(hotspots,
                          lon = "lon",
                          lat = "lat",
                          obsTime = "obsTime",
                          activeTime = 24,
                          adjDist = 3000,
                          minPts = 4,
                          minTime = 3,
                          ignitionCenter = "mean",
                          timeUnit = "h",
                          timeStep = 1)

  # Plot a subset of clusters
  plot_def(result, cluster = 1:3)

  # Plot all clusters
  plot_def(result, cluster = "all")



</code></pre>

<hr>
<h2 id='plot_fire_mov'>Plotting the fire movement</h2><span id='topic+plot_fire_mov'></span>

<h3>Description</h3>

<p>This function plots the fire movement. The fire movement is calculated
from <code><a href="#topic+get_fire_mov">get_fire_mov()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_fire_mov(
  result,
  cluster = "all",
  hotspot = TRUE,
  from = NULL,
  to = NULL,
  step = 1,
  bg = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_fire_mov_+3A_result">result</code></td>
<td>
<p><code>spotoroo</code> object. A result of a call to <code><a href="#topic+hotspot_cluster">hotspot_cluster()</a></code>.</p>
</td></tr>
<tr><td><code id="plot_fire_mov_+3A_cluster">cluster</code></td>
<td>
<p>Character/Integer. If &quot;all&quot;, plot all clusters. If an integer
vector is given, plot corresponding clusters.</p>
</td></tr>
<tr><td><code id="plot_fire_mov_+3A_hotspot">hotspot</code></td>
<td>
<p>Logical. If <code>TRUE</code>, plot the hot spots.</p>
</td></tr>
<tr><td><code id="plot_fire_mov_+3A_from">from</code></td>
<td>
<p><strong>OPTIONAL</strong>. Date/Datetime/Numeric. Start time. The data type
needs to be the same as the provided observed time.</p>
</td></tr>
<tr><td><code id="plot_fire_mov_+3A_to">to</code></td>
<td>
<p><strong>OPTIONAL</strong>. Date/Datetime/Numeric. End time. The data type
needs to be the same as the provided observed time.</p>
</td></tr>
<tr><td><code id="plot_fire_mov_+3A_step">step</code></td>
<td>
<p>Integer (&gt;0). Step size used in the calculation of the
fire movement.</p>
</td></tr>
<tr><td><code id="plot_fire_mov_+3A_bg">bg</code></td>
<td>
<p><strong>OPTIONAL</strong>. <code>ggplot</code> object. If specified, plot onto this object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>ggplot</code> object. The plot of the fire movements.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

  # Time consuming functions (&gt;5 seconds)


  # Get clustering results
  result &lt;- hotspot_cluster(hotspots,
                          lon = "lon",
                          lat = "lat",
                          obsTime = "obsTime",
                          activeTime = 24,
                          adjDist = 3000,
                          minPts = 4,
                          minTime = 3,
                          ignitionCenter = "mean",
                          timeUnit = "h",
                          timeStep = 1)

  # Plot cluster 1 to 4
  plot_fire_mov(result, cluster = 1:4)

  # Plot cluster 1 to 4, set step = 6
  plot_fire_mov(result, cluster = 1:4, step = 6)


</code></pre>

<hr>
<h2 id='plot_spotoroo'>Plotting spatiotemporal clustering result</h2><span id='topic+plot_spotoroo'></span>

<h3>Description</h3>

<p>This function takes a <code>spotoroo</code> object to produce a plot of the
clustering results. It can be called by <code><a href="#topic+plot.spotoroo">plot.spotoroo()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_spotoroo(
  result,
  type = "def",
  cluster = "all",
  hotspot = TRUE,
  noise = FALSE,
  ignition = TRUE,
  from = NULL,
  to = NULL,
  step = 1,
  mainBreak = NULL,
  minorBreak = NULL,
  dateLabel = NULL,
  bg = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_spotoroo_+3A_result">result</code></td>
<td>
<p><code>spotoroo</code> object. A result of a call to <code><a href="#topic+hotspot_cluster">hotspot_cluster()</a></code>.</p>
</td></tr>
<tr><td><code id="plot_spotoroo_+3A_type">type</code></td>
<td>
<p>Character. Type of the plot. One of &quot;def&quot; (default),
&quot;timeline&quot; (timeline) and &quot;mov&quot; (fire movement).</p>
</td></tr>
<tr><td><code id="plot_spotoroo_+3A_cluster">cluster</code></td>
<td>
<p>Character/Integer. If &quot;all&quot;, plot all clusters. If an integer
vector is given, plot corresponding clusters. Unavailable in
<code><a href="#topic+plot_timeline">plot_timeline()</a></code>.</p>
</td></tr>
<tr><td><code id="plot_spotoroo_+3A_hotspot">hotspot</code></td>
<td>
<p>Logical. If <code>TRUE</code>, plot the hot spots. Unavailable in
<code><a href="#topic+plot_timeline">plot_timeline()</a></code>.</p>
</td></tr>
<tr><td><code id="plot_spotoroo_+3A_noise">noise</code></td>
<td>
<p>Logical. If <code>TRUE</code>, plot the noise. Only used in
<code><a href="#topic+plot_def">plot_def()</a></code>.</p>
</td></tr>
<tr><td><code id="plot_spotoroo_+3A_ignition">ignition</code></td>
<td>
<p>Logical. If <code>TRUE</code>, plot the ignition points. Only used in
<code><a href="#topic+plot_def">plot_def()</a></code>.</p>
</td></tr>
<tr><td><code id="plot_spotoroo_+3A_from">from</code></td>
<td>
<p><strong>OPTIONAL</strong>. Date/Datetime/Numeric. Start time. The data type
needs to be the same as the provided observed time.</p>
</td></tr>
<tr><td><code id="plot_spotoroo_+3A_to">to</code></td>
<td>
<p><strong>OPTIONAL</strong>. Date/Datetime/Numeric. End time. The data type
needs to be the same as the provided observed time.</p>
</td></tr>
<tr><td><code id="plot_spotoroo_+3A_step">step</code></td>
<td>
<p>Integer (&gt;=0). Step size used in the calculation of the
fire movement. Only used in <code><a href="#topic+plot_fire_mov">plot_fire_mov()</a></code>.</p>
</td></tr>
<tr><td><code id="plot_spotoroo_+3A_mainbreak">mainBreak</code></td>
<td>
<p><strong>OPTIONAL</strong>. Character/Numeric. A string/value giving the
difference between major breaks. If the
observed time is in date/datetime
format,
this value will be passed to
<code><a href="ggplot2.html#topic+scale_date">ggplot2::scale_x_date()</a></code> or
<code><a href="ggplot2.html#topic+scale_date">ggplot2::scale_x_datetime()</a></code> as
<code>date_breaks</code>. Only used in
<code><a href="#topic+plot_timeline">plot_timeline()</a></code>.</p>
</td></tr>
<tr><td><code id="plot_spotoroo_+3A_minorbreak">minorBreak</code></td>
<td>
<p><strong>OPTIONAL</strong>. Character/Numeric. A string/value giving the
difference between minor breaks. If the
observed time is in date/datetime
format,
this value will be passed to
<code><a href="ggplot2.html#topic+scale_date">ggplot2::scale_x_date()</a></code> or
<code><a href="ggplot2.html#topic+scale_date">ggplot2::scale_x_datetime()</a></code> as
<code>date_minor_breaks</code>. Only used in
<code><a href="#topic+plot_timeline">plot_timeline()</a></code>.</p>
</td></tr>
<tr><td><code id="plot_spotoroo_+3A_datelabel">dateLabel</code></td>
<td>
<p><strong>OPTIONAL</strong>. Character. A string giving the formatting
specification for the labels. If the
observed
time is in date/datetime format,
this value will be passed to
<code><a href="ggplot2.html#topic+scale_date">ggplot2::scale_x_date()</a></code> or
<code><a href="ggplot2.html#topic+scale_date">ggplot2::scale_x_datetime()</a></code> as
<code>date_labels</code>. Unavailable if the observed
time is in numeric format. Only used in
<code><a href="#topic+plot_timeline">plot_timeline()</a></code>.</p>
</td></tr>
<tr><td><code id="plot_spotoroo_+3A_bg">bg</code></td>
<td>
<p><strong>OPTIONAL</strong>. <code>ggplot</code> object. If specified, plot onto this object.
Unavailable in <code><a href="#topic+plot_timeline">plot_timeline()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>if <code>type</code> is &quot;def&quot;, the clustering results will be plotted spatially.
See also <code><a href="#topic+plot_def">plot_def()</a></code>. Available arguments:
</p>

<ul>
<li> <p><code>result</code>
</p>
</li>
<li> <p><code>type</code>
</p>
</li>
<li> <p><code>cluster</code>
</p>
</li>
<li> <p><code>ignition</code>
</p>
</li>
<li> <p><code>hotspot</code>
</p>
</li>
<li> <p><code>noise</code>
</p>
</li>
<li> <p><code>from</code> (<strong>OPTIONAL</strong>)
</p>
</li>
<li> <p><code>to</code> (<strong>OPTIONAL</strong>)
</p>
</li>
<li> <p><code>bg</code> (<strong>OPTIONAL</strong>)
</p>
</li></ul>

<p>if <code>type</code> is &quot;mov&quot;, plot of the fire movement will be made.
See also <code><a href="#topic+plot_fire_mov">plot_fire_mov()</a></code>. Available arguments:
</p>

<ul>
<li> <p><code>result</code>
</p>
</li>
<li> <p><code>type</code>
</p>
</li>
<li> <p><code>cluster</code>
</p>
</li>
<li> <p><code>hotspot</code>
</p>
</li>
<li> <p><code>from</code> (<strong>OPTIONAL</strong>)
</p>
</li>
<li> <p><code>to</code> (<strong>OPTIONAL</strong>)
</p>
</li>
<li> <p><code>step</code>
</p>
</li>
<li> <p><code>bg</code> (<strong>OPTIONAL</strong>)
</p>
</li></ul>

<p>if <code>type</code> is &quot;timeline&quot;, plot of the timeline will be made.
See also <code><a href="#topic+plot_timeline">plot_timeline()</a></code>. Available arguments:
</p>

<ul>
<li> <p><code>result</code>
</p>
</li>
<li> <p><code>type</code>
</p>
</li>
<li> <p><code>from</code> (<strong>OPTIONAL</strong>)
</p>
</li>
<li> <p><code>to</code> (<strong>OPTIONAL</strong>)
</p>
</li>
<li> <p><code>mainBreak</code> (<strong>OPTIONAL</strong>)
</p>
</li>
<li> <p><code>minorBreak</code> (<strong>OPTIONAL</strong>)
</p>
</li>
<li> <p><code>dateLabel</code> (<strong>OPTIONAL</strong>)
</p>
</li></ul>



<h3>Value</h3>

<p>A <code>ggplot</code> object. The plot of the clustering results.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

  # Time consuming functions (&gt;5 seconds)


  # Get clustering result
  result &lt;- hotspot_cluster(hotspots,
                          lon = "lon",
                          lat = "lat",
                          obsTime = "obsTime",
                          activeTime = 24,
                          adjDist = 3000,
                          minPts = 4,
                          minTime = 3,
                          ignitionCenter = "mean",
                          timeUnit = "h",
                          timeStep = 1)

  # Different types of plots

  # Default plot
  plot_spotoroo(result, "def", bg = plot_vic_map())


  # Fire movement plot
  plot_spotoroo(result, "mov", cluster = 1:3, step = 3,
                bg = plot_vic_map())



</code></pre>

<hr>
<h2 id='plot_timeline'>Plotting the timeline of the fire and the noise</h2><span id='topic+plot_timeline'></span>

<h3>Description</h3>

<p>This function plots the timeline of the fires and the noise points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_timeline(
  result,
  from = NULL,
  to = NULL,
  mainBreak = NULL,
  minorBreak = NULL,
  dateLabel = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_timeline_+3A_result">result</code></td>
<td>
<p><code>spotoroo</code> object. A result of a call to <code><a href="#topic+hotspot_cluster">hotspot_cluster()</a></code>.</p>
</td></tr>
<tr><td><code id="plot_timeline_+3A_from">from</code></td>
<td>
<p><strong>OPTIONAL</strong>. Date/Datetime/Numeric. Start time. The data type
needs to be the same as the provided observed time.</p>
</td></tr>
<tr><td><code id="plot_timeline_+3A_to">to</code></td>
<td>
<p><strong>OPTIONAL</strong>. Date/Datetime/Numeric. End time. The data type
needs to be the same as the provided observed time.</p>
</td></tr>
<tr><td><code id="plot_timeline_+3A_mainbreak">mainBreak</code></td>
<td>
<p><strong>OPTIONAL</strong>. Character/Numeric. A string/value giving the
difference between major breaks. If the
observed time is in date/datetime
format,
this value will be passed to
<code><a href="ggplot2.html#topic+scale_date">ggplot2::scale_x_date()</a></code> or
<code><a href="ggplot2.html#topic+scale_date">ggplot2::scale_x_datetime()</a></code> as
<code>date_breaks</code>.</p>
</td></tr>
<tr><td><code id="plot_timeline_+3A_minorbreak">minorBreak</code></td>
<td>
<p><strong>OPTIONAL</strong>. Character/Numeric. A string/value giving the
difference between minor breaks. If the
observed time is in date/datetime
format,
this value will be passed to
<code><a href="ggplot2.html#topic+scale_date">ggplot2::scale_x_date()</a></code> or
<code><a href="ggplot2.html#topic+scale_date">ggplot2::scale_x_datetime()</a></code> as
<code>date_minor_breaks</code>.</p>
</td></tr>
<tr><td><code id="plot_timeline_+3A_datelabel">dateLabel</code></td>
<td>
<p><strong>OPTIONAL</strong>. Character. A string giving the formatting
specification for the labels. If the
observed
time is in date/datetime format,
this value will be passed to
<code><a href="ggplot2.html#topic+scale_date">ggplot2::scale_x_date()</a></code> or
<code><a href="ggplot2.html#topic+scale_date">ggplot2::scale_x_datetime()</a></code> as
<code>date_labels</code>. Unavailable if the observed
time is in numeric format.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>ggplot</code> object. The plot of the timeline.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

  # Time consuming functions (&gt;5 seconds)


  # Get clustering results
  result &lt;- hotspot_cluster(hotspots,
                          lon = "lon",
                          lat = "lat",
                          obsTime = "obsTime",
                          activeTime = 24,
                          adjDist = 3000,
                          minPts = 4,
                          minTime = 3,
                          ignitionCenter = "mean",
                          timeUnit = "h",
                          timeStep = 1)

  # Plot timeline
  plot_timeline(result,
              mainBreak = "1 week",
              minorBreak = "1 day",
              dateLabel = "%b %d")



</code></pre>

<hr>
<h2 id='plot_vic_map'>Plotting map of Victoria, Australia</h2><span id='topic+plot_vic_map'></span>

<h3>Description</h3>

<p>This function plots the map of Victoria, Australia.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_vic_map(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_vic_map_+3A_...">...</code></td>
<td>
<p>All arguments will be ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Require package <code>sf</code> installed.
</p>


<h3>Value</h3>

<p>A <code>ggplot</code> object. The map of Victoria, Australia.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (requireNamespace("sf", quietly = TRUE)) {
  plot_vic_map()
}

</code></pre>

<hr>
<h2 id='plot.spotoroo'>Plotting spatiotemporal clustering result</h2><span id='topic+plot.spotoroo'></span>

<h3>Description</h3>

<p><code>plot.spotoroo()</code> is the <code>plot</code> method of the class <code>spotoroo</code>.
It is a simple wrapper of <code><a href="#topic+plot_spotoroo">plot_spotoroo()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'spotoroo'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.spotoroo_+3A_x">x</code></td>
<td>
<p><code>spotoroo</code> object.
A result of a call to <code><a href="#topic+hotspot_cluster">hotspot_cluster()</a></code>.</p>
</td></tr>
<tr><td><code id="plot.spotoroo_+3A_...">...</code></td>
<td>
<p>Additional arguments pass to <code><a href="#topic+plot_spotoroo">plot_spotoroo()</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>ggplot</code> object. The plot of the clustering results.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>


  # Time consuming functions (&gt;5 seconds)


  # Get clustering results
  result &lt;- hotspot_cluster(hotspots,
                           lon = "lon",
                           lat = "lat",
                           obsTime = "obsTime",
                           activeTime = 24,
                           adjDist = 3000,
                           minPts = 4,
                           minTime = 3,
                           ignitionCenter = "mean",
                           timeUnit = "h",
                           timeStep = 1)



  # Different types of plots

  # Default plot
  plot(result, "def", bg = plot_vic_map())

  # Fire movement plot
  plot(result, "mov", cluster = 1:3, step = 3, bg = plot_vic_map())


</code></pre>

<hr>
<h2 id='print.spotoroo'>Printing spatiotemporal clustering result</h2><span id='topic+print.spotoroo'></span>

<h3>Description</h3>

<p><code>print.spotoroo()</code> is the <code>print</code> method of the class <code>spotoroo</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'spotoroo'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.spotoroo_+3A_x">x</code></td>
<td>
<p><code>spotoroo</code> object.
A result of a call to <code><a href="#topic+hotspot_cluster">hotspot_cluster()</a></code>.</p>
</td></tr>
<tr><td><code id="print.spotoroo_+3A_...">...</code></td>
<td>
<p>Additional arguments will be ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, called for side effects
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

  # Time consuming functions (&gt;5 seconds)


  # Get clustering results
  result &lt;- hotspot_cluster(hotspots,
                           lon = "lon",
                           lat = "lat",
                           obsTime = "obsTime",
                           activeTime = 24,
                           adjDist = 3000,
                           minPts = 4,
                           minTime = 3,
                           ignitionCenter = "mean",
                           timeUnit = "h",
                           timeStep = 1)


  # print the results
  print(result)




</code></pre>

<hr>
<h2 id='summary_spotoroo'>Summarizing spatiotemporal clustering results</h2><span id='topic+summary_spotoroo'></span>

<h3>Description</h3>

<p>This function takes a <code>spotoroo</code> object to produce a summary of the
clustering results. It can be called by <code><a href="#topic+summary.spotoroo">summary.spotoroo()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>summary_spotoroo(result, cluster = "all")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary_spotoroo_+3A_result">result</code></td>
<td>
<p><code>spotoroo</code> object.
A result of a call to <code><a href="#topic+hotspot_cluster">hotspot_cluster()</a></code>.</p>
</td></tr>
<tr><td><code id="summary_spotoroo_+3A_cluster">cluster</code></td>
<td>
<p>Character/Integer. If &quot;all&quot;, summarize all clusters.
If an integer vector is given, summarize corresponding
clusters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, called for side effects
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

  # Time consuming functions (&gt;5 seconds)


  # Get clustering results
  result &lt;- hotspot_cluster(hotspots,
                           lon = "lon",
                           lat = "lat",
                           obsTime = "obsTime",
                           activeTime = 24,
                           adjDist = 3000,
                           minPts = 4,
                           minTime = 3,
                           ignitionCenter = "mean",
                           timeUnit = "h",
                           timeStep = 1)


  # Make a summary of all clusters
  summary_spotoroo(result)

  # Make a summary of cluster 1 to 3
  summary_spotoroo(result, 1:3)


</code></pre>

<hr>
<h2 id='summary.spotoroo'>Summarizing spatiotemporal clustering result</h2><span id='topic+summary.spotoroo'></span>

<h3>Description</h3>

<p><code>summary.spotoroo()</code> is the <code>summary</code> method of the class <code>spotoroo</code>.
It is a simple wrapper of <code><a href="#topic+summary_spotoroo">summary_spotoroo()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'spotoroo'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.spotoroo_+3A_object">object</code></td>
<td>
<p><code>spotoroo</code> object.
A result of a call to <code><a href="#topic+hotspot_cluster">hotspot_cluster()</a></code>.</p>
</td></tr>
<tr><td><code id="summary.spotoroo_+3A_...">...</code></td>
<td>
<p>Additional arguments pass to <code><a href="#topic+summary_spotoroo">summary_spotoroo()</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, called for side effects
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

  # Time consuming functions (&gt;5 seconds)


  # Get clustering results
  result &lt;- hotspot_cluster(hotspots,
                           lon = "lon",
                           lat = "lat",
                           obsTime = "obsTime",
                           activeTime = 24,
                           adjDist = 3000,
                           minPts = 4,
                           minTime = 3,
                           ignitionCenter = "mean",
                           timeUnit = "h",
                           timeStep = 1)


  # Make a summary
  summary(result)


</code></pre>

<hr>
<h2 id='transform_time_id'>Transforming a series of time or datetime to time indexes</h2><span id='topic+transform_time_id'></span>

<h3>Description</h3>

<p>This function transforms a series of time or datetime to
time indexes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>transform_time_id(obsTime, timeUnit, timeStep)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="transform_time_id_+3A_obstime">obsTime</code></td>
<td>
<p>Date/Datetime/Numeric. A vector of observed time of
hot spots.
If <code>timeUnit</code> is &quot;n&quot;, <code>obsTime</code>
needs to be a numeric vector,
otherwise, it needs to be in
date or datetime format.</p>
</td></tr>
<tr><td><code id="transform_time_id_+3A_timeunit">timeUnit</code></td>
<td>
<p>Character. The unit of time, one of &quot;s&quot; (seconds),
&quot;m&quot;(minutes),
&quot;h&quot;(hours), &quot;d&quot;(days) and &quot;n&quot;(numeric).</p>
</td></tr>
<tr><td><code id="transform_time_id_+3A_timestep">timeStep</code></td>
<td>
<p>Numeric (&gt;0). Number of units of <code>timeUnit</code> in a time step.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The earliest time is assigned with a time index <code>1</code>.
The difference between any other time to the earliest
time is transformed using the <code>timeUnit</code> and divided
by the <code>timeStep</code>. These differences are floored to integer and
used as the time indexes.
</p>


<h3>Value</h3>

<p>Integer. A vector of time indexes.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Define obsTime
obsTime &lt;- as.Date(c("2020-01-01",
                     "2020-01-02",
                     "2020-01-04"))

# Transform it to time index under different settings
transform_time_id(obsTime, "h", 1)
transform_time_id(obsTime, "m", 60)
transform_time_id(obsTime, "s", 3600)

# Define numeric obsTime
obsTime &lt;- c(1,
             1.5,
             4.5,
             6)

# Transform it to time index under different settings
transform_time_id(obsTime, "n", 1)
transform_time_id(obsTime, "n", 1.5)


</code></pre>

<hr>
<h2 id='vic_map'>simple features map of Victoria</h2><span id='topic+vic_map'></span>

<h3>Description</h3>

<p>A dataset containing the simple features of Victoria, Australia.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vic_map
</code></pre>


<h3>Format</h3>

<p>A &quot;<code>sf</code>&quot; object with 1 row.
</p>


<h3>Details</h3>

<p>The dataset is obtained via the following codes:<br />
<code>library(rnaturalearth)</code><br />
<code>au_map &lt;- ne_states(country = "Australia", returnclass = "sf")</code><br />
<code>vic_map &lt;- au_map[7,]$geometry</code>
</p>


<h3>Source</h3>

<p><a href="https://www.naturalearthdata.com/">https://www.naturalearthdata.com/</a>
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
