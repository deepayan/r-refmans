<!DOCTYPE html><html lang="en"><head><title>Help for package miic</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {miic}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#computeMutualInfo'><p>Compute (conditional) mutual information</p></a></li>
<li><a href='#computeThreePointInfo'><p>Compute (conditional) three-point information</p></a></li>
<li><a href='#cosmicCancer'><p>Genomic and ploidy alterations in breast tumors</p></a></li>
<li><a href='#cosmicCancer_stateOrder'><p>Genomic and ploidy alterations in breast tumors</p></a></li>
<li><a href='#covidCases'><p>Covid cases</p></a></li>
<li><a href='#discretizeMDL'><p>Discretize a real valued distribution</p></a></li>
<li><a href='#discretizeMutual'><p>Iterative dynamic programming for (conditional) mutual information through</p>
optimized discretization.</a></li>
<li><a href='#estimateTemporalDynamic'><p>Estimation of the temporal causal discovery parameters</p></a></li>
<li><a href='#export'><p>Export miic result for plotting (with igraph)</p></a></li>
<li><a href='#hematoData'><p>Early blood development: single cell binary gene expression data</p></a></li>
<li><a href='#miic'><p>MIIC, causal network learning algorithm including latent variables</p></a></li>
<li><a href='#plot.miic'><p>Basic plot function of a miic network inference result</p></a></li>
<li><a href='#plot.tmiic'><p>Basic plot function of a temporal miic (tmiic) network inference result</p></a></li>
<li><a href='#writeCytoscapeNetwork'><p>GraphML converting function for miic graph</p></a></li>
<li><a href='#writeCytoscapeStyle'><p>Style writing function for the miic network</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Learning Causal or Non-Causal Graphical Models Using Information
Theory</td>
</tr>
<tr>
<td>Version:</td>
<td>2.0.3</td>
</tr>
<tr>
<td>Description:</td>
<td>Multivariate Information-based Inductive Causation, better known 
    by its acronym MIIC, is a causal discovery method, based on information 
    theory principles, which learns a large class of causal or non-causal 
    graphical models from purely observational data, while including the effects 
    of unobserved latent variables. Starting from a complete graph, the method 
    iteratively removes dispensable edges, by uncovering significant information 
    contributions from indirect paths, and assesses edge-specific confidences 
    from randomization of available data. The remaining edges are then oriented 
    based on the signature of causality in observational data. The recent more 
    interpretable MIIC extension (iMIIC) further distinguishes genuine causes 
    from putative and latent causal effects, while scaling to very large 
    datasets (hundreds of thousands of samples). Since the version 2.0, MIIC 
    also includes a temporal mode (tMIIC) to learn temporal causal graphs from 
    stationary time series data. MIIC has been applied to a wide range of 
    biological and biomedical data, such as single cell gene expression data, 
    genomic alterations in tumors, live-cell time-lapse imaging data 
    (CausalXtract), as well as medical records of patients. MIIC brings unique 
    insights based on causal interpretation and could be used in a broad range 
    of other data science domains (technology, climatology, economy, ...). 
    For more information, you can refer to: 
    Simon et al., eLife 2024, &lt;<a href="https://doi.org/10.1101%2F2024.02.06.579177">doi:10.1101/2024.02.06.579177</a>&gt;, 
    Ribeiro-Dantas et al., iScience 2024, &lt;<a href="https://doi.org/10.1016%2Fj.isci.2024.109736">doi:10.1016/j.isci.2024.109736</a>&gt;, 
    Cabeli et al., NeurIPS 2021, <a href="https://why21.causalai.net/papers/WHY21_24.pdf">https://why21.causalai.net/papers/WHY21_24.pdf</a>, 
    Cabeli et al., Comput. Biol. 2020, &lt;<a href="https://doi.org/10.1371%2Fjournal.pcbi.1007866">doi:10.1371/journal.pcbi.1007866</a>&gt;, 
    Li et al., NeurIPS 2019, <a href="https://papers.nips.cc/paper/9573-constraint-based-causal-structure-learning-with-consistent-separating-sets">https://papers.nips.cc/paper/9573-constraint-based-causal-structure-learning-with-consistent-separating-sets</a>, 
    Verny et al., PLoS Comput. Biol. 2017, &lt;<a href="https://doi.org/10.1371%2Fjournal.pcbi.1005662">doi:10.1371/journal.pcbi.1005662</a>&gt;, 
    Affeldt et al., UAI 2015, <a href="https://auai.org/uai2015/proceedings/papers/293.pdf">https://auai.org/uai2015/proceedings/papers/293.pdf</a>. 
    Changes from the previous 1.5.3 release on CRAN are available at 
    <a href="https://github.com/miicTeam/miic_R_package/blob/master/NEWS.md">https://github.com/miicTeam/miic_R_package/blob/master/NEWS.md</a>.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/miicTeam/miic_R_package">https://github.com/miicTeam/miic_R_package</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/miicTeam/miic_R_package/issues">https://github.com/miicTeam/miic_R_package/issues</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>ppcor, Rcpp, scales, stats,</td>
</tr>
<tr>
<td>Suggests:</td>
<td>igraph, grDevices, ggplot2 (&ge; 3.3.0), gridExtra</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-09-17 15:35:57 UTC; Franck</td>
</tr>
<tr>
<td>Author:</td>
<td>Franck Simon [aut, cre],
  Tiziana Tocci [aut],
  Nikita Lagrange [aut],
  Orianne Debeaupuis [aut],
  Louise Dupuis [aut],
  Vincent Cabeli [aut],
  Honghao Li [aut],
  Marcel Ribeiro Dantas [aut],
  Nadir Sella [aut],
  Louis Verny [aut],
  Severine Affeldt [aut],
  Hervé Isambert [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Franck Simon &lt;franck.simon@curie.fr&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-09-17 22:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='computeMutualInfo'>Compute (conditional) mutual information</h2><span id='topic+computeMutualInfo'></span>

<h3>Description</h3>

<p>For discrete or categorical variables, the (conditional)
mutual information is computed using the empirical frequencies minus a
complexity cost (computed as BIC or with the Normalized Maximum Likelihood).
When continuous variables are present, each continuous variable is
discretized for each mutual information estimate so as to maximize the
mutual information minus the complexity cost (see Cabeli 2020).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>computeMutualInfo(
  x,
  y,
  df_conditioning = NULL,
  maxbins = NULL,
  cplx = c("nml", "bic"),
  n_eff = -1,
  sample_weights = NULL,
  is_continuous = NULL,
  plot = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="computeMutualInfo_+3A_x">x</code></td>
<td>
<p>[a vector]
The <code class="reqn">X</code> vector that contains the observational data of the first variable.</p>
</td></tr>
<tr><td><code id="computeMutualInfo_+3A_y">y</code></td>
<td>
<p>[a vector]
The <code class="reqn">Y</code> vector that contains the observational data of the second variable.</p>
</td></tr>
<tr><td><code id="computeMutualInfo_+3A_df_conditioning">df_conditioning</code></td>
<td>
<p>[a data frame]
The data frame of the observations of the conditioning variables.</p>
</td></tr>
<tr><td><code id="computeMutualInfo_+3A_maxbins">maxbins</code></td>
<td>
<p>[an integer]
When the data contain continuous variables, the maximum number of bins
allowed during the discretization. A smaller number makes the computation
faster, a larger number allows finer discretization.</p>
</td></tr>
<tr><td><code id="computeMutualInfo_+3A_cplx">cplx</code></td>
<td>
<p>[a string]
The complexity model:
</p>

<ul>
<li><p>[&quot;bic&quot;] Bayesian Information Criterion
</p>
</li>
<li><p>[&quot;nml&quot;] Normalized Maximum Likelihood, more accurate complexity cost
compared to BIC, especially on small sample size.
</p>
</li></ul>
</td></tr>
<tr><td><code id="computeMutualInfo_+3A_n_eff">n_eff</code></td>
<td>
<p>[an integer]
The effective number of samples. When there is significant autocorrelation
between successive samples, you may want to specify an effective number of
samples that is lower than the total number of samples.</p>
</td></tr>
<tr><td><code id="computeMutualInfo_+3A_sample_weights">sample_weights</code></td>
<td>
<p>[a vector of floats]
Individual weights for each sample, used for the same reason as the effective
number of samples but with individual weights.</p>
</td></tr>
<tr><td><code id="computeMutualInfo_+3A_is_continuous">is_continuous</code></td>
<td>
<p>[a vector of booleans]
Specify if each variable is to be treated as continuous (TRUE) or discrete
(FALSE), must be of length 'ncol(df_conditioning) + 2', in the order
<code class="reqn">X, Y, U1, U2, ...</code>. If not specified, factors and character vectors are
considered as discrete, and numerical vectors as continuous.</p>
</td></tr>
<tr><td><code id="computeMutualInfo_+3A_plot">plot</code></td>
<td>
<p>[a boolean]
Specify whether the resulting XY optimum discretization is to be plotted
(requires 'ggplot2' and 'gridExtra').</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For a pair of continuous variables <code class="reqn">X</code> and <code class="reqn">Y</code>, the mutual
information <code class="reqn">I(X;Y)</code> will be computed iteratively. In each iteration, the
algorithm optimizes the partitioning of <code class="reqn">X</code> and then of <code class="reqn">Y</code>,
in order to maximize
</p>
<p style="text-align: center;"><code class="reqn">Ik(X_{d};Y_{d}) = I(X_{d};Y_{d}) - cplx(X_{d};Y_{d})</code>
</p>

<p>where <code class="reqn">cplx(X_{d}; Y_{d})</code> is the complexity cost of the corresponding
partitioning (see Cabeli 2020).
Upon convergence, the information terms <code class="reqn">I(X_{d};Y_{d})</code>
and <code class="reqn">Ik(X_{d};Y_{d})</code>, as well as the partitioning of <code class="reqn">X_{d}</code>
and <code class="reqn">Y_{d}</code> in terms of cutpoints, are returned.
</p>
<p>For conditional mutual information with a conditioning set <code class="reqn">U</code>, the
computation is done based on
</p>
<p style="text-align: center;"><code class="reqn">
  Ik(X;Y|U) = 0.5*(Ik(X_{d};Y_{d},U_{d}) - Ik(X_{d};U_{d})
                 + Ik(Y_{d};X_{d},U_{d}) - Ik(Y_{d};U_{d})),
</code>
</p>

<p>where each of the four summands is estimated separately.
</p>


<h3>Value</h3>

<p>A list that contains :
</p>

<ul>
<li><p> cutpoints1: Only when <code class="reqn">X</code> is continuous, a vector containing
the cutpoints for the partitioning of <code class="reqn">X</code>.
</p>
</li>
<li><p> cutpoints2: Only when <code class="reqn">Y</code> is continuous, a vector containing
the cutpoints for the partitioning of <code class="reqn">Y</code>.
</p>
</li>
<li><p> n_iterations: Only when at least one of the input variables is
continuous, the number of iterations it takes to reach the convergence of
the estimated information.
</p>
</li>
<li><p> iteration1, iteration2, ... Only when at least one of the input
variables is continuous, the list of vectors of cutpoints of each
iteration.
</p>
</li>
<li><p> info: The estimation of (conditional) mutual information without the
complexity cost.
</p>
</li>
<li><p> infok: The estimation of (conditional) mutual information with the
complexity cost (<code class="reqn">Ik = I - cplx</code>).
</p>
</li>
<li><p> plot: Only when 'plot == TRUE', the plot object.
</p>
</li></ul>



<h3>References</h3>


<ul>
<li><p> Cabeli <em>et al.</em>, PLoS Comput. Biol. 2020, <a href="https://journals.plos.org/ploscompbiol/article?id=10.1371/journal.pcbi.1007866">Learning clinical networks from medical records based on information estimates in mixed-type data</a>
</p>
</li>
<li><p> Affeldt <em>et al.</em>, UAI 2015, <a href="https://auai.org/uai2015/proceedings/papers/293.pdf">Robust Reconstruction of Causal Graphical Models based on Conditional 2-point and 3-point Information</a>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>library(miic)
N &lt;- 1000
# Dependence, conditional independence : X &lt;- Z -&gt; Y
Z &lt;- runif(N)
X &lt;- Z * 2 + rnorm(N, sd = 0.2)
Y &lt;- Z * 2 + rnorm(N, sd = 0.2)
res &lt;- computeMutualInfo(X, Y, plot = FALSE)
message("I(X;Y) = ", res$info)
res &lt;- computeMutualInfo(X, Y, df_conditioning = matrix(Z, ncol = 1), plot = FALSE)
message("I(X;Y|Z) = ", res$info)


# Conditional independence with categorical conditioning variable : X &lt;- Z -&gt; Y
Z &lt;- sample(1:3, N, replace = TRUE)
X &lt;- -as.numeric(Z == 1) + as.numeric(Z == 2) + 0.2 * rnorm(N)
Y &lt;- as.numeric(Z == 1) + as.numeric(Z == 2) + 0.2 * rnorm(N)
res &lt;- miic::computeMutualInfo(X, Y, cplx = "nml")
message("I(X;Y) = ", res$info)
res &lt;- miic::computeMutualInfo(X, Y, matrix(Z, ncol = 1), is_continuous = c(TRUE, TRUE, FALSE))
message("I(X;Y|Z) = ", res$info)


# Independence, conditional dependence : X -&gt; Z &lt;- Y
X &lt;- runif(N)
Y &lt;- runif(N)
Z &lt;- X + Y + rnorm(N, sd = 0.1)
res &lt;- computeMutualInfo(X, Y, plot = TRUE)
message("I(X;Y) = ", res$info)
res &lt;- computeMutualInfo(X, Y, df_conditioning = matrix(Z, ncol = 1), plot = TRUE)
message("I(X;Y|Z) = ", res$info)

</code></pre>

<hr>
<h2 id='computeThreePointInfo'>Compute (conditional) three-point information</h2><span id='topic+computeThreePointInfo'></span>

<h3>Description</h3>

<p>Three point information is defined and computed as the
difference of mutual information and conditional mutual information, e.g.
</p>
<p style="text-align: center;"><code class="reqn">I(X;Y;Z|U) = I(X;Y|U) - Ik(X;Y|U,Z)</code>
</p>

<p>For discrete or categorical variables, the three-point information is
computed with the empirical frequencies minus a complexity cost
(computed as BIC or with the Normalized Maximum Likelihood).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>computeThreePointInfo(
  x,
  y,
  z,
  df_conditioning = NULL,
  maxbins = NULL,
  cplx = c("nml", "bic"),
  n_eff = -1,
  sample_weights = NULL,
  is_continuous = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="computeThreePointInfo_+3A_x">x</code></td>
<td>
<p>[a vector]
The <code class="reqn">X</code> vector that contains the observational data of the first variable.</p>
</td></tr>
<tr><td><code id="computeThreePointInfo_+3A_y">y</code></td>
<td>
<p>[a vector]
The <code class="reqn">Y</code> vector that contains the observational data of the second variable.</p>
</td></tr>
<tr><td><code id="computeThreePointInfo_+3A_z">z</code></td>
<td>
<p>[a vector]
The <code class="reqn">Z</code> vector that contains the observational data of the third variable.</p>
</td></tr>
<tr><td><code id="computeThreePointInfo_+3A_df_conditioning">df_conditioning</code></td>
<td>
<p>[a data frame]
The data frame of the observations of the set of conditioning variables
<code class="reqn">U</code>.</p>
</td></tr>
<tr><td><code id="computeThreePointInfo_+3A_maxbins">maxbins</code></td>
<td>
<p>[an integer]
When the data contain continuous variables, the maximum number of bins
allowed during the discretization. A smaller number makes the computation
faster, a larger number allows finer discretization.</p>
</td></tr>
<tr><td><code id="computeThreePointInfo_+3A_cplx">cplx</code></td>
<td>
<p>[a string]
The complexity model:
</p>

<ul>
<li><p>[&quot;bic&quot;] Bayesian Information Criterion
</p>
</li>
<li><p>[&quot;nml&quot;] Normalized Maximum Likelihood, more accurate complexity cost
compared to BIC, especially on small sample size.
</p>
</li></ul>
</td></tr>
<tr><td><code id="computeThreePointInfo_+3A_n_eff">n_eff</code></td>
<td>
<p>[an integer]
The effective number of samples. When there is significant autocorrelation
between successive samples, you may want to specify an effective number of
samples that is lower than the total number of samples.</p>
</td></tr>
<tr><td><code id="computeThreePointInfo_+3A_sample_weights">sample_weights</code></td>
<td>
<p>[a vector of floats]
Individual weights for each sample, used for the same reason as the effective
number of samples but with individual weights.</p>
</td></tr>
<tr><td><code id="computeThreePointInfo_+3A_is_continuous">is_continuous</code></td>
<td>
<p>[a vector of booleans]
Specify if each variable is to be treated as continuous (TRUE) or discrete
(FALSE), must be of length 'ncol(df_conditioning) + 3', in the order
<code class="reqn">X, Y, Z, U1, U2, ...</code>. If not specified, factors and character vectors
are considered as discrete, and numerical vectors as continuous.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For variables <code class="reqn">X</code>, <code class="reqn">Y</code>, <code class="reqn">Z</code> and a set of conditioning
variables <code class="reqn">U</code>, the conditional three point information is defined as
</p>
<p style="text-align: center;"><code class="reqn">Ik(X;Y;Z|U) = Ik(X;Y|U) - Ik(X;Y|U,Z)</code>
</p>

<p>where <code class="reqn">Ik</code> is the shifted or regularized conditional mutual information.
See <code><a href="#topic+computeMutualInfo">computeMutualInfo</a></code> for the definition of <code class="reqn">Ik</code>.
</p>


<h3>Value</h3>

<p>A list that contains :
</p>

<ul>
<li><p> i3: The estimation of (conditional) three-point information without the
complexity cost.
</p>
</li>
<li><p> i3k: The estimation of (conditional) three-point information with the
complexity cost (<em>i3k = i3 - cplx</em>).
</p>
</li>
<li><p> i2: For reference, the estimation of (conditional) mutual information
<code class="reqn">I(X;Y|U)</code> used in the estimation of <em>i3</em>.
</p>
</li>
<li><p> i2k: For reference, the estimation of regularized (conditional) mutual
information <code class="reqn">Ik(X;Y|U)</code> used in the estimation of <em>i3k</em>.
</p>
</li></ul>



<h3>References</h3>


<ul>
<li><p> Cabeli <em>et al.</em>, PLoS Comput. Biol. 2020, <a href="https://journals.plos.org/ploscompbiol/article?id=10.1371/journal.pcbi.1007866">Learning clinical networks from medical records based on information estimates in mixed-type data</a>
</p>
</li>
<li><p> Affeldt <em>et al.</em>, UAI 2015, <a href="https://auai.org/uai2015/proceedings/papers/293.pdf">Robust Reconstruction of Causal Graphical Models based on Conditional 2-point and 3-point Information</a>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>library(miic)
N &lt;- 1000
# Dependence, conditional independence : X &lt;- Z -&gt; Y
Z &lt;- runif(N)
X &lt;- Z * 2 + rnorm(N, sd = 0.2)
Y &lt;- Z * 2 + rnorm(N, sd = 0.2)
res &lt;- computeThreePointInfo(X, Y, Z)
message("I(X;Y;Z) = ", res$i3)
message("Ik(X;Y;Z) = ", res$i3k)


# Independence, conditional dependence : X -&gt; Z &lt;- Y
X &lt;- runif(N)
Y &lt;- runif(N)
Z &lt;- X + Y + rnorm(N, sd = 0.1)
res &lt;- computeThreePointInfo(X, Y, Z)
message("I(X;Y;Z) = ", res$i3)
message("Ik(X;Y;Z) = ", res$i3k)

</code></pre>

<hr>
<h2 id='cosmicCancer'>Genomic and ploidy alterations in breast tumors</h2><span id='topic+cosmicCancer'></span>

<h3>Description</h3>

<p>The dataset contains 807 samples without predisposing Brca1/2 germline mutations
and includes 204 somatic mutations (from whole exome sequencing) and expression
level information for 91 genes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(cosmicCancer)
</code></pre>


<h3>Format</h3>

<p>A data.frame object.
</p>


<h3>References</h3>

<p>Forbes SA, Beare D, Gunasekaran P, Leung K, Bindal N, et al. (2015)
Nucleic Acids Res 43:D805–D811. (<a href="https://pubmed.ncbi.nlm.nih.gov/25355519/">PubMed link</a>)
</p>

<hr>
<h2 id='cosmicCancer_stateOrder'>Genomic and ploidy alterations in breast tumors</h2><span id='topic+cosmicCancer_stateOrder'></span>

<h3>Description</h3>

<p>The dataset contains 807 samples without predisposing Brca1/2 germline mutations
and includes 204 somatic mutations (from whole exome sequencing) and expression
level information for 91 genes, category order file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(cosmicCancer_stateOrder)
</code></pre>


<h3>Format</h3>

<p>A data.frame object.
</p>


<h3>References</h3>

<p>Forbes SA, Beare D, Gunasekaran P, Leung K, Bindal N, et al. (2015)
Nucleic Acids Res 43:D805–D811. (<a href="https://pubmed.ncbi.nlm.nih.gov/25355519/">PubMed link</a>)
</p>

<hr>
<h2 id='covidCases'>Covid cases</h2><span id='topic+covidCases'></span>

<h3>Description</h3>

<p>Demo dataset of chronological series to be used in temporal mode of miic.
Evolution of Covid cases on a subset of EU countries from 12/31/2019 to 06/18/2020.
Source of the data : European Centre for Disease Prevention and Control.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(covidCases)
</code></pre>


<h3>Format</h3>

<p>A data.frame object.
</p>


<h3>References</h3>

<p>ECDC (<a href="https://www.ecdc.europa.eu/en/publications-data/download-todays-data-geographic-distribution-covid-19-cases-worldwide">ECDC link</a>)
</p>

<hr>
<h2 id='discretizeMDL'>Discretize a real valued distribution</h2><span id='topic+discretizeMDL'></span>

<h3>Description</h3>

<p>This function performs minimum description length (MDL)-optimal histogram density estimation
as described in Kontkanen and Myllymäki (2007) and returns the cutpoints found to give the best model
according to the MDL principle.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>discretizeMDL(x = NULL, max_bins = 20)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="discretizeMDL_+3A_x">x</code></td>
<td>
<p>[a vector]
A vector that contains the distribution to be discretized.</p>
</td></tr>
<tr><td><code id="discretizeMDL_+3A_max_bins">max_bins</code></td>
<td>
<p>[an int]
The maximum number of bins allowed by the algorithm.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the cutpoints of the best discretization.
</p>


<h3>References</h3>


<ul>
<li><p> Kontkanen P, Myllymäki P. MDL histogram density estimation. Artificial Intelligence and Statistics 2007 Mar 11 (pp. 219-226).
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>library(miic)
# Bimodal normal distribution
N &lt;- 300
modes &lt;- sample(1:2, size = N, replace = TRUE)
x &lt;- as.numeric(modes == 1) * rnorm(N, mean = 0, sd = 1) +
     as.numeric(modes == 2) * rnorm(N, mean = 5, sd = 2)
MDL_disc &lt;- discretizeMDL(x)
hist(x, breaks = MDL_disc$cutpoints)

N &lt;- 2000
modes &lt;- sample(1:2, size = N, replace = TRUE)
x &lt;- as.numeric(modes == 1) * rnorm(N, mean = 0, sd = 1) +
     as.numeric(modes == 2) * rnorm(N, mean = 5, sd = 2)
MDL_disc &lt;- discretizeMDL(x)
hist(x, breaks = MDL_disc$cutpoints)

</code></pre>

<hr>
<h2 id='discretizeMutual'>Iterative dynamic programming for (conditional) mutual information through
optimized discretization.</h2><span id='topic+discretizeMutual'></span>

<h3>Description</h3>

<p>This function chooses cutpoints in the input distributions by
maximizing the mutual information minus a complexity cost
(computed as BIC or with the Normalized Maximum Likelihood).
The (conditional) mutual information computed on the optimized discretized
distributions effectively estimates the mutual information of the original
continuous variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>discretizeMutual(
  x,
  y,
  matrix_u = NULL,
  maxbins = NULL,
  cplx = "nml",
  n_eff = NULL,
  sample_weights = NULL,
  is_continuous = NULL,
  plot = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="discretizeMutual_+3A_x">x</code></td>
<td>
<p>[a vector]
The <code class="reqn">X</code> vector that contains the observational data of the first variable.</p>
</td></tr>
<tr><td><code id="discretizeMutual_+3A_y">y</code></td>
<td>
<p>[a vector]
The <code class="reqn">Y</code> vector that contains the observational data of the second variable.</p>
</td></tr>
<tr><td><code id="discretizeMutual_+3A_matrix_u">matrix_u</code></td>
<td>
<p>[a numeric matrix]
The matrix with the observations of as many columns as conditioning variables.</p>
</td></tr>
<tr><td><code id="discretizeMutual_+3A_maxbins">maxbins</code></td>
<td>
<p>[an int]
The maximum number of bins desired in the discretization. A lower number makes the computation faster, a higher
number allows finer discretization (by default : 5 * cubic root of N).</p>
</td></tr>
<tr><td><code id="discretizeMutual_+3A_cplx">cplx</code></td>
<td>
<p>[a string]
The complexity used in the dynamic programming:
</p>

<ul>
<li><p>[&quot;bic&quot;] Bayesian Information Criterion
</p>
</li>
<li><p>[&quot;nml&quot;] Normalized Maximum Likelihood, more accurate complexity cost
compared to BIC, especially on small sample size.
</p>
</li></ul>
</td></tr>
<tr><td><code id="discretizeMutual_+3A_n_eff">n_eff</code></td>
<td>
<p>[an integer]
The effective number of samples. When there is significant autocorrelation
between successive samples, you may want to specify an effective number of
samples that is lower than the total number of samples.</p>
</td></tr>
<tr><td><code id="discretizeMutual_+3A_sample_weights">sample_weights</code></td>
<td>
<p>[a vector of floats]
Individual weights for each sample, used for the same reason as the effective
number of samples but with individual weights.</p>
</td></tr>
<tr><td><code id="discretizeMutual_+3A_is_continuous">is_continuous</code></td>
<td>
<p>[a vector of booleans]
Specify if each variable is to be treated as continuous (TRUE)
or discrete (FALSE) in a logical vector of length ncol(matrix_u) + 2,
in the order [X, Y, U1, U2...]. By default, factors and character vectors
are treated as discrete, and numerical vectors as continuous.</p>
</td></tr>
<tr><td><code id="discretizeMutual_+3A_plot">plot</code></td>
<td>
<p>[a boolean]
Specify whether the resulting XY optimum discretization is to be plotted
(requires 'ggplot2' and 'gridExtra').</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For a pair of continuous variables <code class="reqn">X</code> and <code class="reqn">Y</code>,
the algorithm will iteratively choose cutpoints on <code class="reqn">X</code> then on <code class="reqn">Y</code>,
maximizing <code class="reqn">I(X_{d};Y_{d}) - cplx(X_{d};Y_{d})</code> where
<code class="reqn">cplx(X_{d};Y_{d})</code> is the complexity cost of the considered
discretizations of <code class="reqn">X</code> and <code class="reqn">Y</code> (see Cabeli 2020).
Upon convergence, the discretization scheme of <code class="reqn">X_{d}</code> and <code class="reqn">Y_{d}</code>
is returned as well as <code class="reqn">I(X_{d};Y_{d})</code>
and <code class="reqn">I(X_{d};Y_{d})-cplx(X_{d};Y_{d})</code>.
</p>
<p>With a set of conditioning variables <code class="reqn">U</code>, the discretization scheme
maximizes each term of the sum
<code class="reqn">I(X;Y|U) \sim 0.5*(I(X_{d};Y_{d}, U_{d}) - I(X_{d};U_{d}) + I(Y_{d};X_{d}, U_{d}) - I(Y_{d};U_{d}))</code>.
</p>
<p>Discrete variables can be passed as factors and will be used &quot;as is&quot; to maximize each term.
</p>


<h3>Value</h3>

<p>A list that contains :
</p>

<ul>
<li><p>two vectors containing the cutpoints for each variable :
<em>cutpoints1</em> corresponds to <em>x</em>,
<em>cutpoints2</em> corresponds to <em>y</em>.
</p>
</li>
<li><p><em>n_iterations</em> is the number of iterations performed before
convergence of the (C)MI estimation.
</p>
</li>
<li><p><em>iteration1, iteration2, ...</em>, lists containing
the cutpoint vectors for each iteration.
</p>
</li>
<li><p><em>info</em> and <em>infok</em>, the estimated (C)MI value
and (C)MI minus the complexity cost.
</p>
</li>
<li><p>if <em>plot</em> == TRUE, a plot object (requires ggplot2 and gridExtra).
</p>
</li></ul>



<h3>References</h3>


<ul>
<li><p> Cabeli <em>et al.</em>, PLoS Comput. Biol. 2020, <a href="https://journals.plos.org/ploscompbiol/article?id=10.1371/journal.pcbi.1007866">Learning clinical networks from medical records based on information estimates in mixed-type data</a>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>library(miic)
N &lt;- 1000
# Dependence, conditional independence : X &lt;- Z -&gt; Y
Z &lt;- runif(N)
X &lt;- Z * 2 + rnorm(N, sd = 0.2)
Y &lt;- Z * 2 + rnorm(N, sd = 0.2)
res &lt;- discretizeMutual(X, Y, plot = FALSE)
message("I(X;Y) = ", res$info)
res &lt;- discretizeMutual(X, Y, matrix_u = matrix(Z, ncol = 1), plot = FALSE)
message("I(X;Y|Z) = ", res$info)


# Conditional independence with categorical conditioning variable : X &lt;- Z -&gt; Y
Z &lt;- sample(1:3, N, replace = TRUE)
X &lt;- -as.numeric(Z == 1) + as.numeric(Z == 2) + 0.2 * rnorm(N)
Y &lt;- as.numeric(Z == 1) + as.numeric(Z == 2) + 0.2 * rnorm(N)
res &lt;- miic::discretizeMutual(X, Y, cplx = "nml")
message("I(X;Y) = ", res$info)
res &lt;- miic::discretizeMutual(X, Y, matrix(Z, ncol = 1), is_continuous = c(TRUE, TRUE, FALSE))
message("I(X;Y|Z) = ", res$info)


# Independence, conditional dependence : X -&gt; Z &lt;- Y
X &lt;- runif(N)
Y &lt;- runif(N)
Z &lt;- X + Y + rnorm(N, sd = 0.1)
res &lt;- discretizeMutual(X, Y, plot = TRUE)
message("I(X;Y) = ", res$info)
res &lt;- discretizeMutual(X, Y, matrix_u = matrix(Z, ncol = 1), plot = TRUE)
message("I(X;Y|Z) = ", res$info)

</code></pre>

<hr>
<h2 id='estimateTemporalDynamic'>Estimation of the temporal causal discovery parameters</h2><span id='topic+estimateTemporalDynamic'></span>

<h3>Description</h3>

<p>This function estimates the number of layers and number of
time steps between each layer that are needed to cover the dynamic of a
temporal dataset when reconstructing a temporal causal graph.
Using autocorrelation decay, the function computes the average relaxation
time of the variables and, based on a maximum number of nodes, deduces
the number of layers and number of time steps between each layer to be used.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimateTemporalDynamic(
  input_data,
  state_order = NULL,
  mov_avg = NULL,
  max_nodes = 50,
  verbose_level = 1
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="estimateTemporalDynamic_+3A_input_data">input_data</code></td>
<td>
<p>[a data frame]
A data frame containing the observational data.<br />
The expected data frame layout is variables as columns and
time series/time steps as rows.
The time step information must be supplied in the first column and,
for each time series, be consecutive and in ascending order (increment of 1).
Multiple trajectories can be provided, the function will consider that a
new trajectory starts each time a smaller time step than the one of the
previous row is encountered.</p>
</td></tr>
<tr><td><code id="estimateTemporalDynamic_+3A_state_order">state_order</code></td>
<td>
<p>[a data frame] An optional data frame providing extra
information about variables. It must have d rows where d is the number of
input variables, excluding the time step one.<br />
For optional columns, if they are not provided or contain missing
values, default values suitable for <em>input_data</em> will be used.
</p>
<p>The following structure (named columns) is expected:<br />
</p>
<p>&quot;var_names&quot; (required) contains the name of each variable as specified
by colnames(input_data), excluding the time steps column.
</p>
<p>&quot;var_type&quot; (optional) contains a binary value that specifies if each
variable is to be considered as discrete (0) or continuous (1).
Discrete variables will be excluded from the temporal dynamic estimation.
</p>
<p>&quot;is_contextual&quot; (optional) contains a binary value that specifies if a
variable is to be considered as a contextual variable (1) or not (0).
Contextual variables will be excluded from the temporal dynamic estimation.
</p>
<p>&quot;mov_avg&quot; (optional) contains an integer value that specifies the size of
the moving average window to be applied to the variable.
Note that if &quot;mov_avg&quot; column is present in the <em>state_order</em>,
its values will overwrite the function parameter.</p>
</td></tr>
<tr><td><code id="estimateTemporalDynamic_+3A_mov_avg">mov_avg</code></td>
<td>
<p>[an integer] Optional, NULL by default.<br />
When an integer&gt;= 2 is supplied, a moving average operation is applied
to all the non discrete and not contextual variables. If no <em>state_order</em>
is provided, the discrete/continuous variables are deduced from the input
data. If you want to apply a moving average only on specific columns,
consider to use a <em>mov_avg</em> column in the <em>state_order</em> parameter.</p>
</td></tr>
<tr><td><code id="estimateTemporalDynamic_+3A_max_nodes">max_nodes</code></td>
<td>
<p>[a positive integer] The maximum number of nodes in the
final time-unfolded causal graph. The more nodes allowed in the temporal
causal discovery, the more precise will be the discovery but at the cost
of longer execution time. The default is set to 50 for fast causal
discovery. On recent computers, values up to 200 or 300 nodes are usually
possible (depending on the number of trajectories and time steps in the
input data).</p>
</td></tr>
<tr><td><code id="estimateTemporalDynamic_+3A_verbose_level">verbose_level</code></td>
<td>
<p>[an integer value in the range [0,2], 1 by default]
The level of verbosity: 0 = no display, 1 = summary display, 2 = full display.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named list with two items:
</p>

<ul>
<li><p><em>n_layers</em>: the number of layers
</p>
</li>
<li><p><em>delta_t</em>: the number of time steps between the layers
</p>
</li></ul>


<hr>
<h2 id='export'>Export miic result for plotting (with igraph)</h2><span id='topic+export'></span>

<h3>Description</h3>

<p>This function creates an object built from the result returned
by <code><a href="#topic+miic">miic</a></code> that is ready to be fed to the plotting method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>export(
  miic_obj,
  method = "igraph",
  pcor_palette = NULL,
  display = "compact",
  show_self_loops = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="export_+3A_miic_obj">miic_obj</code></td>
<td>
<p>[a miic object, required]
</p>
<p>The object returned by the <code><a href="#topic+miic">miic</a></code> execution.</p>
</td></tr>
<tr><td><code id="export_+3A_method">method</code></td>
<td>
<p>[a string, optional, default value &quot;igraph&quot;]
</p>
<p>The plotting method, currently only &quot;igraph&quot; is supported.</p>
</td></tr>
<tr><td><code id="export_+3A_pcor_palette">pcor_palette</code></td>
<td>
<p>[a color palette, optional, default value
grDevices::colorRampPalette(c(&quot;blue&quot;, &quot;darkgrey&quot;, &quot;red&quot;)]
</p>
<p>Used to represent the partial correlations (the color of the edges).
The palette must be able to handle 201 shades to cover the correlation range
from -100 to +100.</p>
</td></tr>
<tr><td><code id="export_+3A_display">display</code></td>
<td>
<p>[a string, optional, default value &quot;compact&quot;]
</p>
<p>Used only when exporting object returned by miic in temporal mode.
It allows different representations of the temporal graph.
Possible values are <em>&quot;raw&quot;</em>, <em>&quot;lagged&quot;</em>, <em>&quot;compact&quot;</em>,
<em>&quot;combine&quot;</em>, <em>&quot;unique&quot;</em>, <em>&quot;drop&quot;</em>:
</p>

<ul>
<li><p> When <em>display</em> = <em>&quot;raw&quot;</em>, the export function will
use the tmiic graph object as it, leading to the return of a lagged
graph.
</p>
</li>
<li><p> When <em>display</em> = <em>&quot;lagged&quot;</em>, the export function will
repeat the edges over history assuming stationarity and return a lagged
graph.
</p>
</li>
<li><p> When <em>display</em> = <em>&quot;compact&quot;</em>, the default, nodes
and edges are converted into a flattened version to produce a compact
view of the temporal network whilst still presenting all the information
in the export.<br />
e.g. X_lag1-&gt;Y_lag0, X_lag2&lt;-Y_lag0 become respectively X-&gt;Y lag=1,
X&lt;-Y lag=2.
</p>
</li>
<li><p> When <em>display</em> = <em>&quot;combine&quot;</em>, prior to the export,
a pre-processing will be applied to kept only one edge
per pair of nodes. The info_shifted will be the highest one
of the summarized edges whilst the lag and orientation of the
summarized edge will be an aggregation.<br />
e.g. X_lag2-&gt;Y_lag0, X_lag0&lt;-Y_lag1 will become X&lt;-&gt;Y lag=1-2 with
the info_shifted of X_lag2-&gt;Y_lag0 if info_shifted of
X_lag2-&gt;Y_lag0 &gt; X_lag0&lt;-Y_lag1.
</p>
</li>
<li><p> When <em>display</em> = <em>&quot;unique&quot;</em>, prior to the export,
a pre-processing will be applied to kept only the edges having the
highest info_shifted for a pair of nodes.
If several edges between the sames nodes have the same
info_shifted, then the edge kept is the one with the minimum lag.<br />
e.g. X_lag1-&gt;Y_lag0, X_lag0&lt;-Y_lag2 with info_shifted of
X_lag1-&gt;Y_lag0 &gt; X_lag0&lt;-Y_lag2 become X-&gt;Y lag=1.
</p>
</li>
<li><p> When <em>display</em> = <em>&quot;drop&quot;</em>, the same pre-processing
as <em>&quot;unique&quot;</em> will be applied, then the lag information will be
dropped before the export.
</p>
</li></ul>
</td></tr>
<tr><td><code id="export_+3A_show_self_loops">show_self_loops</code></td>
<td>
<p>[a boolean, optional, TRUE by default]
</p>
<p>Used only when exporting object returned by miic in temporal mode.
When TRUE, the lagged edges starting and ending on the same node
are included in the igraph  object.
When FALSE, only edges having different nodes are present in the igraph
object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The behavior depends on the method used for the export.
</p>
<p>For igraph, edge attributes are passed to the igraph graph
and can be accessed with e.g. <code>E(g)$partial_correlation</code>.
See <code><a href="#topic+miic">miic</a></code> for more details on edge parameters.
By default, edges are colored according to the partial correlation
between two nodes conditioned on the conditioning set
(negative is blue, null is gray and positive is red)
and their width is based on the conditional mutual information
minus the complexity cost.
</p>


<h3>Value</h3>

<p>A graph object adapted to the method.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(miic)
data(hematoData)

# execute MIIC (reconstruct graph)
miic_obj &lt;- miic(
  input_data = hematoData, latent = "yes",
  n_shuffles = 10, conf_threshold = 0.001
)

# Using igraph
if(require(igraph)) {
g = export(miic_obj, "igraph")
plot(g) # Default visualisation, calls igraph::plot.igraph()

# Specifying layout (see ?igraph::layout_)
l &lt;-layout_with_kk(g)
plot(g, layout=l)

# Override some graphical parameters
plot(g, edge.curved = .2)
plot(g, vertex.shape="none", edge.color="gray85", vertex.label.color="gray10")
}

# In temporal mode, execute MIIC
data(covidCases)
tmiic_obj &lt;- miic(input_data = covidCases, mode = "TS", n_layers = 3, delta_t = 1, mov_avg = 14)

# Plot by default the compact display of the temporal network using igraph
if(require(igraph)) {
g = export (tmiic_obj)
plot(g)

# Plot the raw temporal network using igraph
g = export(tmiic_obj, display="raw")
plot(g)

# Plot the complete temporal network using igraph (completed by stationarity)
g = export(tmiic_obj, display="lagged")
plot(g)

# Specifying layout (see ?igraph::layout_)
l &lt;- layout_on_grid(g, width = 5, height = 3, dim = 2)
plot(g, layout=l)

# For compact temporal display, please be aware that the rendering of
# igraph::plot.igraph() is not optimal when the graph contains
# multiple edges between the same nodes.
# So, the recommend way to plot a compact graph is to use tmiic plotting:
plot(tmiic_obj)
}


</code></pre>

<hr>
<h2 id='hematoData'>Early blood development: single cell binary gene expression data</h2><span id='topic+hematoData'></span>

<h3>Description</h3>

<p>Binarized expression data of 33 transcription factors involved
in early differentiation of primitive erythroid and endothelial
cells (3934 cells).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(hematoData)
</code></pre>


<h3>Format</h3>

<p>A data.frame object.
</p>


<h3>References</h3>

<p>Moignard et al. (2015) Nat Biotechnol 33(3):269-76
(<a href="https://pubmed.ncbi.nlm.nih.gov/25355519/">PubMed link</a>)
</p>

<hr>
<h2 id='miic'>MIIC, causal network learning algorithm including latent variables</h2><span id='topic+miic'></span>

<h3>Description</h3>

<p>MIIC (Multivariate Information-based Inductive Causation) combines
constraint-based and information-theoretic approaches to disentangle direct
from indirect effects amongst correlated variables, including cause-effect
relationships and the effect of unobserved latent causes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>miic(
  input_data,
  state_order = NULL,
  true_edges = NULL,
  black_box = NULL,
  n_threads = 1,
  cplx = "nml",
  orientation = TRUE,
  ort_proba_ratio = 1,
  ort_consensus_ratio = NULL,
  propagation = FALSE,
  latent = "orientation",
  n_eff = -1,
  n_shuffles = 0,
  conf_threshold = 0,
  sample_weights = NULL,
  test_mar = TRUE,
  consistent = "no",
  max_iteration = 100,
  consensus_threshold = 0.8,
  negative_info = FALSE,
  mode = "S",
  n_layers = NULL,
  delta_t = NULL,
  mov_avg = NULL,
  keep_max_data = FALSE,
  max_nodes = 50,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="miic_+3A_input_data">input_data</code></td>
<td>
<p>[a data frame, required]
</p>
<p>A n*d data frame (n samples, d variables) that contains the observational data.
</p>
<p>In standard mode, each column corresponds to one variable and each row is a
sample that gives the values for all the observed variables.
The column names correspond to the names of the observed variables.
Numeric columns with at least 5 distinct values will be treated as continuous
by default whilst numeric columns with less than 5 distinct values, factors
and characters will be considered as categorical.
</p>
<p>In temporal mode, the expected data frame layout is variables as columns
and time series/time steps as rows.
The time step information must be supplied in the first column and,
for each time series, be consecutive and in ascending order (increment of 1).
Multiple trajectories can be provided, miic will consider that a new trajectory
starts each time a smaller time step than the one of the previous row is encountered.</p>
</td></tr>
<tr><td><code id="miic_+3A_state_order">state_order</code></td>
<td>
<p>[a data frame, optional, NULL by default]
</p>
<p>A data frame providing extra information for variables. It must have d rows
where d is the number of input variables and possible columns are described
below. For optional columns, if they are not provided or contain missing
values, default values suitable for <em>input_data</em> will be used.
</p>
<p><em>&quot;var_names&quot;</em> (required) contains the name of each variable as specified
by colnames(input_data). In temporal mode, the time steps column should
not be mentioned in the variables list.
</p>
<p><em>&quot;var_type&quot;</em> (optional) contains a binary value that specifies if each
variable is to be considered as discrete (0) or continuous (1).
</p>
<p><em>&quot;levels_increasing_order&quot;</em> (optional) contains a single character string
with all of the unique levels of the ordinal variable in increasing order,
delimited by comma ','. It will be used during the post-processing to compute
the sign of an edge using Spearman's rank correlation. If a variable is
continuous or is categorical but not ordinal, this column should be NA.
</p>
<p><em>&quot;is_contextual&quot;</em> (optional) contains a binary value that specifies if a
variable is to be considered as a contextual variable (1) or not (0).
Contextual variables cannot be the child node of any other variable (cannot
have edge with arrowhead pointing to them).
</p>
<p><em>&quot;is_consequence&quot;</em> (optional) contains a binary value that specifies if a
variable is to be considered as a consequence variable (1) or not (0).
Edges between consequence variables are ignored, consequence variables
cannot be the parent node of any other variable and cannot be used as
contributors. Edges between a non consequence and consequence variables
are pre-oriented toward the consequence.
</p>
<p>Several other columns are possible in temporal mode:
</p>
<p><em>&quot;n_layers&quot;</em> (optional) contains an integer value that specifies the
number of layers to be considered for the variable.
Note that if a <em>&quot;n_layers&quot;</em> column is present in the <em>state_order</em>,
its values will overwrite the function parameter.
</p>
<p><em>&quot;delta_t&quot;</em> (optional) contains an integer value that specifies the number
of time steps between each layer for the variable.
Note that if a <em>&quot;delta_t&quot;</em> column is present in the <em>state_order</em>,
its values will overwrite the function parameter.
</p>
<p><em>&quot;mov_avg&quot;</em> (optional) contains an integer value that specifies the size
of the moving average window to be applied to the variable.
Note that if <em>&quot;mov_avg&quot;</em> column is present in the <em>state_order</em>,
its values will overwrite the function parameter.</p>
</td></tr>
<tr><td><code id="miic_+3A_true_edges">true_edges</code></td>
<td>
<p>[a data frame, optional, NULL by default]
</p>
<p>A data frame containing the edges of the true graph for
computing performance after the run.<br />
In standard mode, the expected layout is a two columns data frame, each row
representing a true edge with in each column, the variable names.
Variables names must exist in the <em>input_data</em> data frame.<br />
In temporal mode, the expected layout is a three columns data frame,
with the first two columns being variable names and the third the lag.
Variables names must exist in the <em>input_data</em> data frame and the lag
must be valid in the time unfolded graph. e.g. a row var1, var2, 3 is valid
with <em>n_layers</em> = 4 + <em>delta_t</em> = 1 or
<em>n_layers</em> = 2 + <em>delta_t</em> = 3
but not for <em>n_layers</em> = 2 + <em>delta_t</em> = 2 as there is no matching
edge in the time unfolded graph.<br />
Please note that the order is important: in standard mode, &quot;var1 var2&quot; will
be interpreted as var1 -&gt; var2 and in temporal mode, &quot;var1 var2 3&quot; is
interpreted as var1_lag3 -&gt; var2_lag0. Please note also that, in temporal
mode, for contextual variables that are not lagged, the expected value in the
third column for the time lag is NA.</p>
</td></tr>
<tr><td><code id="miic_+3A_black_box">black_box</code></td>
<td>
<p>[a data frame, optional, NULL by default]
</p>
<p>A data frame containing pairs of variables that will be considered
as independent during the network reconstruction. In practice, these edges
will not be included in the skeleton initialization and cannot be part of
the final result.<br />
In standard mode, the expected layout is a two columns data frame, each row
representing a forbidden edge with in each column, the variable names.
Variables names must exist in the <em>input_data</em> data frame.<br />
In temporal mode, the expected layout is a three columns data frame,
with the first two columns being variable names and the third the lag.
Variables names must exist in the <em>input_data</em> data frame and the lag
must be valid in the time unfolded graph. e.g. a row var1, var2, 3 is valid
with <em>n_layers</em> = 4 + <em>delta_t</em> = 1 or
<em>n_layers</em> = 2 + <em>delta_t</em> = 3
but not for <em>n_layers</em> = 2 + <em>delta_t</em> = 2 as there is no matching
edge in the time unfolded graph. Please note that the order is important:
var1, var2, 3 is interpreted as var1_lag3 - var2_lag0. Please note also that,
for contextual variables that are not lagged, the expected value in the
third column for the time lag is NA.</p>
</td></tr>
<tr><td><code id="miic_+3A_n_threads">n_threads</code></td>
<td>
<p>[a positive integer, optional, 1 by default]
</p>
<p>When set greater than 1, n_threads parallel threads will be used for computation. Make sure
your compiler is compatible with openmp if you wish to use multithreading.</p>
</td></tr>
<tr><td><code id="miic_+3A_cplx">cplx</code></td>
<td>
<p>[a string, optional, &quot;nml&quot; by default, possible values:
&quot;nml&quot;, &quot;bic&quot;]
</p>
<p>In practice, the finite size of the input  dataset requires that
the 2-point and 3-point information measures should be <em>shifted</em>
by a <em>complexity</em> term. The finite size corrections can be based on
the Bayesian Information Criterion (BIC).
However, the BIC complexity term tends to underestimate the
relevance of edges connecting variables with many different categories,
leading to the removal of false negative edges. To avoid such biases
with finite datasets, the (universal) Normalized Maximum Likelihood (NML)
criterion can be used (see Affeldt 2015).</p>
</td></tr>
<tr><td><code id="miic_+3A_orientation">orientation</code></td>
<td>
<p>[a boolean value, optional, TRUE by default]
</p>
<p>The miic network skeleton can be partially directed by orienting
edge directions, based on the sign and magnitude of the conditional
3-point information of unshielded triples and, in temporal mode, using time.
If set to FALSE, the orientation step is not performed.</p>
</td></tr>
<tr><td><code id="miic_+3A_ort_proba_ratio">ort_proba_ratio</code></td>
<td>
<p>[a floating point between 0 and 1, optional,
1 by default]
</p>
<p>The threshold when deducing the type of an edge tip (head/tail)
from the probability of orientation.
For a given edge tip, denote by p the probability of it being a head,
the orientation is accepted if (1 - p) / p &lt; <em>ort_proba_ratio</em>.
0 means reject all orientations, 1 means accept all orientations.</p>
</td></tr>
<tr><td><code id="miic_+3A_ort_consensus_ratio">ort_consensus_ratio</code></td>
<td>
<p>[a floating point between 0 and 1, optional,
NULL by default]
Used to determine if orientations correspond to genuine causal edges
and, when consistency is activated, to deduce the orientations in
the consensus graph.<br />
Oriented edges will be marked as genuine causal when:
<code class="reqn"> (1 - p_{head}) / p_{head} &lt; </code> <em>ort_consensus_ratio</em>
and  <code class="reqn"> p_{tail} / (1 - p_{tail}) &lt; </code> <em>ort_consensus_ratio</em>.<br />
When consistency is activated, <em>ort_consensus_ratio</em> is used as
threshold when deducing the type of an consensus edge tip (head/tail)
from the average probability of orientations over the cycle of graphs.
For a given edge tip, denote by p the average probability of it being a head,
the orientation is accepted if (1 - p) / p &lt; <em>ort_consensus_ratio</em>.<br />
If not supplied, the <em>ort_consensus_ratio</em> will be initialized with
the <em>ort_proba_ratio</em> value.</p>
</td></tr>
<tr><td><code id="miic_+3A_propagation">propagation</code></td>
<td>
<p>[a boolean value, optional, FALSE by default]
</p>
<p>If set to FALSE, the skeleton is partially oriented with only the
v-structure orientations. Otherwise, the v-structure orientations are
propagated to downstream un-directed edges in unshielded triples following
the propagation procedure, relying on probabilities (for more details,
see Verny 2017).</p>
</td></tr>
<tr><td><code id="miic_+3A_latent">latent</code></td>
<td>
<p>[a string, optional, &quot;orientation&quot; by default, possible
values: &quot;orientation&quot;, &quot;no&quot;, &quot;yes&quot;]
</p>
<p>When set to &quot;yes&quot;, the network reconstruction is taking into account hidden
(latent) variables. When set to &quot;orientation&quot;, latent variables are not
considered during the skeleton reconstruction but allows bi-directed edges
during the orientation.
Dependence between two observed variables due to a latent variable is
indicated with a '6' in the adjacency matrix and in the network
edges.summary and by a bi-directed edge in the (partially) oriented graph.</p>
</td></tr>
<tr><td><code id="miic_+3A_n_eff">n_eff</code></td>
<td>
<p>[a positive integer, optional, -1 by default]
</p>
<p>In standard mode, the n samples given in the <em>input_data</em> data frame are
expected to be independent. In case of correlated samples such as in
Monte Carlo sampling approaches, the effective number of independent samples
<em>n_eff</em> can be estimated using the decay of the autocorrelation function
(see Verny 2017). This effective number <em>n_eff</em> of independent samples
can be provided using this parameter.</p>
</td></tr>
<tr><td><code id="miic_+3A_n_shuffles">n_shuffles</code></td>
<td>
<p>[a positive integer, optional, 0 by default]
</p>
<p>The number of shufflings of the original dataset in order to evaluate
the edge specific confidence ratio of all retained edges.
Default is 0: no confidence cut is applied. If the number of shufflings
is set to an integer &gt; 0, the confidence threshold must also be &gt; 0
(e.g. <em>n_shuffles</em> = 100 and <em>conf_threshold</em> = 0.01).</p>
</td></tr>
<tr><td><code id="miic_+3A_conf_threshold">conf_threshold</code></td>
<td>
<p>[a positive floating point, optional, 0 by default]
</p>
<p>The threshold used to filter the less probable edges following the skeleton
step (see Verny 2017). Default is 0: no confidence cut is applied. If the
confidence threshold is set &gt; 0, the number of shufflings must also be &gt; 0
(e.g. <em>n_shuffles</em> = 100 and <em>conf_threshold</em> = 0.01).</p>
</td></tr>
<tr><td><code id="miic_+3A_sample_weights">sample_weights</code></td>
<td>
<p>[a numeric vector, optional, NULL by default]
</p>
<p>An vector containing the weight of each observation.  If defined, it must be
a vector of floats in the range [0,1] of size equal to the number of samples.</p>
</td></tr>
<tr><td><code id="miic_+3A_test_mar">test_mar</code></td>
<td>
<p>[a boolean value, optional, TRUE by default]
</p>
<p>If set to TRUE, distributions with missing values will be tested with
Kullback-Leibler divergence: conditioning variables for the given link
<code class="reqn">X - Y</code>, <code class="reqn">Z</code> will be considered only if the divergence
between the full distribution and the non-missing distribution
<code class="reqn">KL(P(X,Y) | P(X,Y)_{!NA})</code> is low enough (with <code class="reqn">P(X,Y)_{!NA}</code> as
the joint distribution of <code class="reqn">X</code> and <code class="reqn">Y</code> on samples which are
not missing on Z.
This is a way to ensure that data are missing at random for the considered
interaction and detect bias due to values not missing at random.</p>
</td></tr>
<tr><td><code id="miic_+3A_consistent">consistent</code></td>
<td>
<p>[a string, optional, &quot;no&quot; by default, possible values:
&quot;no&quot;, &quot;orientation&quot;, &quot;skeleton&quot;]
</p>
<p>If set to &quot;orientation&quot;: iterate over skeleton and orientation steps to
ensure consistency of the separating sets and all disconnected pairs in the
final network.
If set to &quot;skeleton&quot;: iterate over skeleton step to get a consistent
skeleton, then orient edges including inconsistent orientations
(see Li 2019 for details).</p>
</td></tr>
<tr><td><code id="miic_+3A_max_iteration">max_iteration</code></td>
<td>
<p>[a positive integer, optional, 100 by default]
</p>
<p>When the <em>consistent</em> parameter is set to &quot;skeleton&quot; or &quot;orientation&quot;,
the maximum number of iterations allowed when trying to find a consistent
graph.</p>
</td></tr>
<tr><td><code id="miic_+3A_consensus_threshold">consensus_threshold</code></td>
<td>
<p>[a floating point between 0.5 and 1.0, optional,
0.8 by default]
</p>
<p>When the <em>consistent</em> parameter is set to &quot;skeleton&quot; or &quot;orientation&quot;
and when the result graph is inconsistent or is a union of more than
one inconsistent graphs, a consensus graph will be produced based on
a pool of graphs.
If the result graph is inconsistent, then the pool is made of
<em>max_iteration</em> graphs from the iterations, otherwise it is made of
those graphs in the union.
In the consensus graph, an edge is present when the proportion of non-zero
status in the pool is above the threshold. For example, if the pool contains
[A, B, B, 0, 0], where &quot;A&quot;, &quot;B&quot; are different status of the edge and &quot;0&quot;
indicates the absence of the edge. Then the edge is set to connected (&quot;1&quot;)
if the proportion of non-zero status (0.6 in the example) is equal to
or higher than <em>consensus_threshold</em>. (When set to connected,
the orientation of the edge will be further determined by the average
probability of orientation.)</p>
</td></tr>
<tr><td><code id="miic_+3A_negative_info">negative_info</code></td>
<td>
<p>[a boolean value, optional, FALSE by default]
</p>
<p>If TRUE, negative shifted mutual information is allowed during the
computation when mutual information is inferior to the complexity term.
For small dataset with complicated structures, e.g. discrete variables with
many levels, allowing for negative shifted mutual information may help
identifying weak v-structures related to those discrete variables,
as the negative three-point information in those cases will come from
the difference between two negative shifted mutual information terms
(expected to be negative due to the small sample size).
However, under this setting, a v-structure (X -&gt; Z &lt;- Y) in the final graph
does not necessarily imply that X is dependent on Y conditioning on Z,
As a consequence, the reliability of certain orientations is not guaranteed.
By contrast, keeping this parameter as FALSE is more conservative and leads
to more reliable orientations (see Cabeli 2021 and Ribeiro-Dantas 2024).</p>
</td></tr>
<tr><td><code id="miic_+3A_mode">mode</code></td>
<td>
<p>[a string, optional, &quot;S&quot; by default, possible values are
&quot;S&quot;: Standard (non temporal data) or &quot;TS&quot;: Temporal Stationary data]
</p>
<p>When temporal mode is activated, the time information must be provided
in the first column of <em>input_data</em>. For more details about temporal
stationary mode (see Simon 2024).</p>
</td></tr>
<tr><td><code id="miic_+3A_n_layers">n_layers</code></td>
<td>
<p>[an integer, optional, NULL by default, must be &gt;= 2
if supplied]
</p>
<p>Used only in temporal mode, <em>n_layers</em> defines the number of layers
that will be considered for the variables in the time unfolded graph.
The layers will be distant of <em>delta_t</em> time steps.
If not supplied, the number of layers is estimated from the dynamic of the
dataset and the maximum number of nodes <em>max_nodes</em> allowed in the
final lagged graph.</p>
</td></tr>
<tr><td><code id="miic_+3A_delta_t">delta_t</code></td>
<td>
<p>[an integer, optional, NULL by default, must be &gt;= 1
if supplied]
</p>
<p>Used only in temporal mode, <em>delta_t</em> defines the number of time steps
between each layer.
i.e. on 1000 time steps with <em>n_layers</em> = 3 and <em>delta_t</em> = 7,
the time steps kept for the samples conversion will be 1, 8, 15
for the first sample, the next sample will use 2, 9, 16 and so on.
If not supplied, the number of time steps between layers is estimated
from the dynamic of the dataset and the number of layers.</p>
</td></tr>
<tr><td><code id="miic_+3A_mov_avg">mov_avg</code></td>
<td>
<p>[an integer, optional, NULL by default, must be &gt;= 2
if supplied]
</p>
<p>Used only in temporal mode. When supplied, a moving average operation is
applied to all integer and numeric variables that are not contextual
variables.</p>
</td></tr>
<tr><td><code id="miic_+3A_keep_max_data">keep_max_data</code></td>
<td>
<p>[a boolean value, optional, FALSE by default]
</p>
<p>Used only in temporal mode. If TRUE, rows where some NAs have been
introduced during the moving averages and lagging will be kept
whilst they will be dropped if FALSE.</p>
</td></tr>
<tr><td><code id="miic_+3A_max_nodes">max_nodes</code></td>
<td>
<p>[an integer, optional, 50 by default]
</p>
<p>Used only in temporal mode and if the <em>n_layers</em> or <em>delta_t</em>
parameters are not supplied. <em>max_nodes</em> is used as the maximum number
of nodes in the final time-unfolded graph to compute <em>n_layers</em> and/or <em>delta_t</em>.
The default is 50 to produce quick runs and can be increased up to 200
or 300 on recent computers to produce more precise results.</p>
</td></tr>
<tr><td><code id="miic_+3A_verbose">verbose</code></td>
<td>
<p>[a boolean value, optional, FALSE by default]
</p>
<p>If TRUE, debugging output is printed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Starting from a complete graph, the method iteratively removes
dispensable edges, by uncovering significant information contributions from
indirect paths, and assesses edge-specific confidences from randomization of
available data. The remaining edges are then oriented based on the signature
of causality in observational data. Miic distinguishes genuine causal edges
(with both reliable arrow heads and tails) from putative causal edges (with
one reliable arrow head only) and latent causal edges (with both reliable
arrow heads). (see Ribeiro-Dantas 2024)
</p>
<p>In temporal mode, miic reorganizes the dataset using the <em>n_layers</em> and
<em>delta_t</em> parameters to transform the time steps into lagged samples.
As starting point, a lagged graph is created with only edges having at
least one node laying on the last time step.
Then, miic standard algorithm is applied to remove dispensable edges.
The remaining edges are then duplicated to ensure time invariance
(stationary dynamic) and oriented using the temporality and the
signature of causality in observational data. The use of temporal mode
is presented in Simon 2024.
</p>
<p>The method relies on information theoretic principles which replace
(conditional) independence tests as described in Affeldt 2015, Cabeli 2020,
Cabeli 2021 and Ribeiro-Dantas 2024. It deals with both categorical and
continuous variables by performing optimal context-dependent discretization.
As such, the input data frame may contain both numerical columns which will
be treated as continuous, or character / factor columns which will be treated
as categorical. For further details on the optimal discretization method and
the conditional independence test, see the function discretizeMutual.
The user may also choose to run miic with scheme presented in Li 2019
and Ribeiro-Dantas 2024 to improve the end result's interpretability
by ensuring consistent separating sets.
</p>


<h3>Value</h3>

<p>A <em>miic-like</em> object that contains:
</p>

<ul>
<li><p><em>summary:</em> a data frame with information about the
relationship between relevant pair of variables.
</p>
<p>As returning the information on all possible pairs of variables could lead
to an huge data frame, by convention, the summary does not include pair of
variables not sharing information at all (<em>I'(x,y) &lt;= 0</em>).
However, as exception to this convention, when a ground truth is supplied
(using the <em>true_edges</em> parameter), the edges that are not retained
by MIIC because the variables does not share information at all
but are present in the true edges will be included in the summary
to report correctly all the false negative edges.
</p>
<p>So, the summary contains these categories of edges:
</p>

<ul>
<li><p> edges retained
</p>
</li>
<li><p> edges not retained after conditioning on some contributor(s)
</p>
</li>
<li><p> edges not retained without conditioning but present in true edges
</p>
</li></ul>

<p>while these edges are not considered as relevant and are not included:
</p>

<ul>
<li><p> edges not retained without conditioning and not in true edges
</p>
</li></ul>

<p>Information available in the summary are:
</p>

<ul>
<li> <p><em>x:</em> X node name
</p>
</li>
<li> <p><em>y:</em> Y node name
</p>
</li>
<li> <p><em>type:</em> contains 'N' if the edge has been removed or 'P' for
retained edges. If the true graph is supplied in the <em>true_edges</em>
parameter, 'P' becomes 'TP' (True Positive) or 'FP' (False Positive),
while 'N' becomes 'TN' (True Negative) or 'FN' (False Negative).
Note that, as the <em>summary</em> does not contain all the
removed edges, edges not present have to be considered as 'N'
and, if the true graph is supplied, as 'TN'.
</p>
</li>
<li> <p><em>ai:</em> the contributing nodes found by the method which
contribute to the mutual information between <em>x</em> and <em>y</em>,
and possibly separate them.
</p>
</li>
<li> <p><em>raw_contributions:</em> describes the share of total mutual
information between <em>x</em> and <em>y</em> explained by each contributor,
measured by I'(x;y;ai|{aj}) / I'(x;y),
where {aj} is the separating set before adding ai.
</p>
</li>
<li> <p><em>contributions:</em> describes the share of remaining mutual
information between <em>x</em> and <em>y</em> explained  by each successive
contributors, measured by I'(x;y;ai|{aj}) / I'(x;y|{aj}),
where {aj} is the separating set before adding ai. 
</p>
</li>
<li> <p><em>info:</em> the mutual information <em>I(x;y)</em> times <em>n_xy</em>,
the number of samples without missing or NA values for both <em>x</em>
and <em>y</em>. 
</p>
</li>
<li> <p><em>n_xy:</em> gives the number of samples on which the information
without conditioning has been computed. If the input dataset
has no missing value, the number of samples is the same for all pairs
and corresponds to the total number of samples.
</p>
</li>
<li> <p><em>info_cond:</em> the conditional mutual information <em>I(x;y|ai)</em>
times the number of samples without NA <em>n_xy_ai</em> used in the
computation.
<em>info_cond</em> is equal to <em>info</em> when <em>ai</em> is an empty set.
</p>
</li>
<li> <p><em>cplx:</em> the complexity term for the pair (<em>x</em>, <em>y</em>)
taking into account the contributing nodes <em>ai</em>.
</p>
</li>
<li> <p><em>n_xy_ai:</em> the number of samples without NA in
<em>x</em>, <em>y</em> and all nodes in <em>ai</em> on which the
information and the complexity terms are computed.
If the input dataset has no missing value, the number of samples is the
same for all pairs and corresponds to the total number of samples.
</p>
</li>
<li> <p><em>info_shifted:</em> value equal to <em>info_cond</em> - <em>cplx</em>.
Used to decide whether the edge is retained (when positive),
or removed (when zero or possibly negative when the parameter
<em>negative_info</em> is set to TRUE).
</p>
</li>
<li> <p><em>ort_inferred:</em> the orientation of the edge (<em>x</em>, <em>y</em>).
0: edge removed, 1: un-directed, 2: directed from X to Y, -2: directed
from Y to X, 6: bi-directed.<br />
When the <em>consistent</em> option is turned on and there is more than
one graph in the consistent cycle, this is the inferred orientation
of the edge in the last graph in the cycle. 
</p>
</li>
<li> <p><em>ort_ground_truth:</em> the orientation of the edge (<em>x</em>,
<em>y</em>) in the ground truth graph when true edges are provided.
</p>
</li>
<li> <p><em>is_inference_correct:</em> indicates if the inferred orientation
agrees with the provided ground truth. TRUE: agrees, FALSE: disagrees and
set to NA when no ground truth is supplied.
</p>
</li>
<li> <p><em>is_causal:</em> boolean value indicating the causal nature of the
arrow tips of an edge, based on the probabilities given in the columns
<em>p_y2x</em> and <em>p_x2y</em>. TRUE: when the edges is directed
and both the head and the tail are set with high confidence
(adjustable with the <em>ort_consensus_ratio</em> parameter),
FALSE otherwise or NA if the edge is not retained.
More formally, an oriented edge is marked as genuine causal when
<code class="reqn"> (1 - p_{head}) / p_{head} &lt; </code> <em>ort_consensus_ratio</em>
and  <code class="reqn"> p_{tail} / (1 - p_{tail}) &lt; </code> <em>ort_consensus_ratio</em>.<br />
A directed edge not marked as genuine causal indicates that only
the head is set with high confidence, while the tail remains uncertain.
This corresponds to a putative causal edge, which could either be
a genuine causal edge or a bi-directed edge from a latent confounder.<br />
Note that the genuine causality is deducible only when latent variables
are allowed and propagation is not allowed.
</p>
</li>
<li> <p><em>ort_consensus:</em> Not computed (NAs) when
consistency is not activated or, when consistency is on,
if there is only one graph returned (no cycle).
When computed, indicates the consensus orientation of the edge
determined from the consensus skeleton and the <em>ort_consensus_ratio</em>
threshold on averaged orientation probabilities over the cycle of graphs.
Possible values are 0: not connected, 1: un-directed, -2 or 2: directed
and 6: bi-directed (latent variable).
</p>
</li>
<li> <p><em>is_causal_consensus:</em> Not computed (NAs) when
consistency is not activated or, when consistency is on,
if there is only one graph returned (no cycle).
When computed, work in the same way as <em>is_causal</em>
but on the consensus graph.
</p>
</li>
<li> <p><em>edge_stats:</em> Not computed (NAs) when
consistency is not activated or, when consistency is on,
if there is only one graph returned (no cycle).
When computed, contains the frequencies of all <em>ort_inferred</em>
values present in the cycle of graphs for the edge (<em>x, y</em>),
in the format [percentage(orientation)], separated by &quot;;&quot;.
e.g. In a cycle of 4 graphs, if an edge is three times marked as 2
(directed) and one time marked as 1 (un-directed), edge_stats will
contain &quot;75%(2);25%(1)&quot;.
</p>
</li>
<li> <p><em>sign:</em> the sign of the partial correlation between variables
<em>x</em> and <em>y</em>, conditioned on the contributing nodes <em>ai</em>.
</p>
</li>
<li> <p><em>partial_correlation:</em> value of the partial correlation for the
edge (<em>x, y</em>) conditioned on the contributing nodes <em>ai</em>.
</p>
</li>
<li> <p><em>p_y2x:</em> probability of the arrowhead from <em>y</em> to <em>x</em>,
of the inferred orientation, derived from the three-point mutual information
(see Verny 2017 and Ribeiro-Dantas 2024). NA if the edge is removed.
</p>
</li>
<li> <p><em>p_x2y:</em> probability of the arrowhead from <em>x</em> to <em>y</em>,
of the inferred orientation, derived from the three-point mutual information
(see Verny 2017 and Ribeiro-Dantas 2024). NA if the edge is removed.
</p>
</li>
<li> <p><em>confidence:</em> computed only when the confidence cut is
activated, NA otherwise.
When computed, it corresponds to a measure of the strength of the retained
edges: it is the ratio between the probability to reject the edge
<em>exp(-info_shifted(x;y|ai))</em> in the original dataset and
the mean probability to do the same in <em>n_shuffles</em> number
of randomized datasets. Edges with <em>confidence</em> &gt; <em>conf_threshold</em>
will be filtered out from the graph.
(see parameters <em>n_shuffles</em> and <em>conf_threshold</em>)

</p>
</li></ul>


</li>
<li><p><em>edges:</em> a data frame with the raw edges output coming from
the C++ core function. This data frame is used internally by MIIC to
produce the summary and contains all pairs of variables (<em>x, y</em>). 
</p>
</li>
<li><p><em>triples:</em> this data frame lists the orientation
probabilities of the two edges of all unshielded triples of the
reconstructed network with the structure: node1 &ndash; mid-node &ndash; node2:
</p>

<ul>
<li> <p><em>node1:</em> node at the end of the unshielded triplet
</p>
</li>
<li> <p><em>p1:</em> probability of the arrowhead node1 &lt;- mid-node
</p>
</li>
<li> <p><em>p2:</em> probability of the arrowhead node1 -&gt; mid-node
</p>
</li>
<li> <p><em>mid-node:</em> node at the center of the unshielded triplet
</p>
</li>
<li> <p><em>p3:</em> probability of the arrowhead mid-node &lt;- node2
</p>
</li>
<li> <p><em>p4:</em> probability of the arrowhead mid-node -&gt; node2
</p>
</li>
<li> <p><em>node2:</em> node at the end of the unshielded triplet
</p>
</li>
<li> <p><em>ni3:</em> 3 point (conditional) mutual information * N
</p>
</li>
<li> <p><em>conflict:</em> indicates if there is a conflict between the
computed probabilities and the <em>ni3</em> value
</p>
</li></ul>


</li>
<li> <p><em>adj_matrix:</em> the adjacency matrix is a square matrix used to
represent the inferred graph. The entries of the matrix indicate whether
pairs of vertices are adjacent or not in the graph. The matrix can be read
as a (row, column) set of couples where the row represents the source node
and the column the target node. Since miic can reconstruct mixed networks
(including directed, un-directed and bi-directed edges), we will have a
different digit for each case:
</p>

<ul>
<li><p> 1: (<em>x</em>, <em>y</em>) edge is un-directed
</p>
</li>
<li><p> 2: (<em>x</em>, <em>y</em>) edge is directed as <em>x</em> -&gt; <em>y</em> 
</p>
</li>
<li><p> -2: (<em>x</em>, <em>y</em>) edge is directed as <em>x</em> &lt;- <em>y</em> 
</p>
</li>
<li><p> 6: (<em>x</em>, <em>y</em>) edge is bi-directed
</p>
</li></ul>


</li>
<li> <p><em>proba_adj_matrix:</em> the probability adjacency matrix is
a square matrix used to represent the orientation probabilities associated
to the edges tips. The value at (&quot;row&quot;, &quot;column&quot;) is the probability,
for the edge between &quot;row&quot; and &quot;column&quot; nodes, of the edge tip on the &quot;row&quot;
side. A probability less than 0.5 is an indication of a possible tail
(cause) and a probability greater than 0.5 a possible head (effect). 
</p>
</li>
<li> <p><em>adj_matrices:</em> present only when consistency is activated.
The list of the adjacency matrices, one for each graph
which is part of the resulting cycle of graphs.
Each item is a square matrix with the same layout as <em>adj_matrix</em>. 
</p>
</li>
<li> <p><em>proba_adj_matrices:</em> present only when consistency is activated.
The list of the probability adjacency matrices, one for each graph
which is part of the resulting cycle of graphs. Each item is a
square matrix with the same layout as <em>proba_adj_matrix</em>. 
</p>
</li>
<li> <p><em>proba_adj_average:</em> present only when consistency is activated.
The average probability adjacency matrix is a square matrix used to
represent the orientation probabilities associated to the edges tips
of the consensus graph. Its layout is the same as <em>proba_adj_matrix</em>
and it contains the averaged probability of edges tips over the resulting
cycle of graphs. 
</p>
</li>
<li> <p><em>is_consistent:</em> present only when consistency is activated.
TRUE if the returned graph is consistent, FALSE otherwise. 
</p>
</li>
<li> <p><em>time:</em> execution time of the different steps and total run-time
of the causal graph reconstruction by MIIC. 
</p>
</li>
<li> <p><em>interrupted:</em> TRUE if causal graph reconstruction has been
interrupted, FALSE otherwise. 
</p>
</li>
<li> <p><em>scores:</em> present only when true edges have been supplied.
Contains the scores of the returned graph in regard of the ground truth:
</p>

<ul>
<li> <p><em>tp</em>: number of edges marked as True Positive 
</p>
</li>
<li> <p><em>fp</em>: number of edges marked as False Positive 
</p>
</li>
<li> <p><em>fn</em>: number of edges marked as False Negative 
</p>
</li>
<li> <p><em>precision</em>: Precision 
</p>
</li>
<li> <p><em>recall</em>: Recall 
</p>
</li>
<li> <p><em>fscore</em>: F1-Score 
</p>
</li></ul>


</li>
<li> <p><em>params:</em> the list of parameters used for the network
reconstruction. The parameters not supplied are initialized to their default
values. Otherwise, the parameters are checked and corrected if necessary. 
</p>
</li>
<li> <p><em>state_order:</em> the state order used for the network
reconstruction. If no state order is supplied, it is generated by using
default values. Otherwise, it is the state order checked and corrected
if necessary.
</p>
</li>
<li> <p><em>black_box:</em> present only if a black box has been supplied,
the black box, checked and corrected if necessary, used for the network
reconstruction.
</p>
</li>
<li> <p><em>true_edges:</em> present only if the true edges have been supplied,
the true edges, checked and corrected if necessary, used for the network
evaluation.
</p>
</li>
<li> <p><em>tmiic:</em> present only in temporal mode.
Named list containing the full list of edges completed by stationarity,
the lagged state order and, if a black box or true edges have been supplied,
the lagged versions of these inputs.
</p>
</li></ul>



<h3>References</h3>


<ul>
<li><p> Simon <em>et al.</em>, eLife 2024, <a href="https://www.biorxiv.org/content/10.1101/2024.02.06.579177v1.abstract">CausalXtract: a flexible pipeline to extract causal effects from live-cell time-lapse imaging data</a>
</p>
</li>
<li><p> Ribeiro-Dantas <em>et al.</em>, iScience 2024, <a href="https://arxiv.org/pdf/2303.06423">Learning interpretable causal networks from very large datasets, application to 400,000 medical records of breast cancer patients</a>
</p>
</li>
<li><p> Cabeli <em>et al.</em>, NeurIPS 2021, <a href="https://why21.causalai.net/papers/WHY21_24.pdf">Reliable causal discovery based on mutual information supremum principle for finite dataset</a>
</p>
</li>
<li><p> Cabeli <em>et al.</em>, PLoS Comput. Biol. 2020, <a href="https://journals.plos.org/ploscompbiol/article?id=10.1371/journal.pcbi.1007866">Learning clinical networks from medical records based on information estimates in mixed-type data</a>
</p>
</li>
<li><p> Li <em>et al.</em>, NeurIPS 2019, <a href="http://papers.nips.cc/paper/9573-constraint-based-causal-structure-learning-with-consistent-separating-sets.pdf">Constraint-based causal structure learning with consistent separating sets</a>
</p>
</li>
<li><p> Verny <em>et al.</em>, PLoS Comput. Biol. 2017, <a href="https://journals.plos.org/ploscompbiol/article?id=10.1371/journal.pcbi.1005662">Learning causal networks with latent variables from multivariate information in genomic data</a>
</p>
</li>
<li><p> Affeldt <em>et al.</em>, UAI 2015, <a href="https://auai.org/uai2015/proceedings/papers/293.pdf">Robust Reconstruction of Causal Graphical Models based on Conditional 2-point and 3-point Information</a>
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+discretizeMutual">discretizeMutual</a></code> for optimal discretization and
(conditional) independence test.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(miic)

# EXAMPLE HEMATOPOIESIS
data(hematoData)

# execute MIIC (reconstruct graph)
miic_obj &lt;- miic(
  input_data = hematoData[1:1000,], latent = "yes",
  n_shuffles = 10, conf_threshold = 0.001
)

# plot graph
if(require(igraph)) {
 plot(miic_obj, method="igraph")
}


# write graph to graphml format. Note that to correctly visualize
# the network we created the miic style for Cytoscape (http://www.cytoscape.org/).

writeCytoscapeNetwork(miic_obj, file = file.path(tempdir(), "temp"))

# EXAMPLE CANCER
data(cosmicCancer)
data(cosmicCancer_stateOrder)
# execute MIIC (reconstruct graph)
miic_obj &lt;- miic(
  input_data = cosmicCancer, state_order = cosmicCancer_stateOrder, latent = "yes",
  n_shuffles = 100, conf_threshold = 0.001
)

# plot graph
if(require(igraph)) {
 plot(miic_obj)
}

# write graph to graphml format. Note that to correctly visualize
# the network we created the miic style for Cytoscape (http://www.cytoscape.org/).
writeCytoscapeNetwork(miic_obj, file = file.path(tempdir(), "temp"))

# EXAMPLE COVID CASES (time series demo)
data(covidCases)
# execute MIIC (reconstruct graph in temporal mode)
tmiic_obj &lt;- miic(input_data = covidCases, mode = "TS", n_layers = 3, delta_t = 1, mov_avg = 14)

# to plot the default graph (compact)
if(require(igraph)) {
 plot(tmiic_obj)
}

# to plot the raw temporal network
if(require(igraph)) {
  plot(tmiic_obj, display="raw")
}

# to plot the full temporal network
if(require(igraph)) {
  plot(tmiic_obj, display="lagged")
}



</code></pre>

<hr>
<h2 id='plot.miic'>Basic plot function of a miic network inference result</h2><span id='topic+plot.miic'></span>

<h3>Description</h3>

<p>This function calls <code><a href="#topic+export">export</a></code> to build a
plottable object from the result returned by <code><a href="#topic+miic">miic</a></code> and plot it.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'miic'
plot(x, method = "igraph", pcor_palette = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.miic_+3A_x">x</code></td>
<td>
<p>[a miic object, required]
</p>
<p>The object returned by <code><a href="#topic+miic">miic</a></code> execution.</p>
</td></tr>
<tr><td><code id="plot.miic_+3A_method">method</code></td>
<td>
<p>[a string, optional, default value &quot;igraph&quot;]
</p>
<p>The plotting method, currently only &quot;igraph&quot; is supported.</p>
</td></tr>
<tr><td><code id="plot.miic_+3A_pcor_palette">pcor_palette</code></td>
<td>
<p>[a color palette, optional, default value
grDevices::colorRampPalette(c(&quot;blue&quot;, &quot;darkgrey&quot;, &quot;red&quot;)]
</p>
<p>Used to represent the partial correlations (the color of the edges).
The palette must be able to handle 201 shades to cover the correlation range
from -100 to +100.</p>
</td></tr>
<tr><td><code id="plot.miic_+3A_...">...</code></td>
<td>
<p>Additional plotting parameters. See the corresponding plot
function for the complete list.
</p>
<p>For igraph, see <code><a href="igraph.html#topic+igraph.plotting">igraph.plotting</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See the documentation of <code><a href="#topic+export">export</a></code> for further
details.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+export">export</a></code> for graphical exports,
<code><a href="igraph.html#topic+igraph.plotting">igraph.plotting</a></code>
</p>

<hr>
<h2 id='plot.tmiic'>Basic plot function of a temporal miic (tmiic) network inference result</h2><span id='topic+plot.tmiic'></span>

<h3>Description</h3>

<p>This function calls <code><a href="#topic+export">export</a></code> to build a plottable
object from the result returned by <code><a href="#topic+miic">miic</a></code> in temporal mode
and plot it.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'tmiic'
plot(
  x,
  method = "igraph",
  pcor_palette = NULL,
  display = "compact",
  show_self_loops = TRUE,
  positioning_for_grid = "greedy",
  orientation_for_grid = "L",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.tmiic_+3A_x">x</code></td>
<td>
<p>[a tmiic object, required]
</p>
<p>The object returned by <code><a href="#topic+miic">miic</a></code> in temporal mode.</p>
</td></tr>
<tr><td><code id="plot.tmiic_+3A_method">method</code></td>
<td>
<p>[a string, optional, default value &quot;igraph&quot;]
</p>
<p>The plotting method, currently only &quot;igraph&quot; is supported.</p>
</td></tr>
<tr><td><code id="plot.tmiic_+3A_pcor_palette">pcor_palette</code></td>
<td>
<p>[a color palette, optional, default value
grDevices::colorRampPalette(c(&quot;blue&quot;, &quot;darkgrey&quot;, &quot;red&quot;)]
</p>
<p>Used to represent the partial correlations (the color of the edges).
The palette must be able to handle 201 shades to cover the correlation range
from -100 to +100.</p>
</td></tr>
<tr><td><code id="plot.tmiic_+3A_display">display</code></td>
<td>
<p>[a string, optional, default value &quot;compact&quot;]
</p>
<p>Possible values are <em>&quot;raw&quot;</em>, <em>&quot;lagged&quot;</em>, <em>&quot;compact&quot;</em>,
<em>&quot;combine&quot;</em>, <em>&quot;unique&quot;</em>, <em>&quot;drop&quot;</em>:
</p>

<ul>
<li><p> When <em>display</em> = <em>&quot;raw&quot;</em>, the plot function will
use the tmiic graph object as it, leading to the display of a lagged
graph. Unless a specific layout is specified, nodes will be positioned
on a grid.
</p>
</li>
<li><p> When <em>display</em> = <em>&quot;lagged&quot;</em>, the function will
repeat the edges over history assuming stationarity and plot a lagged
graph. Unless a specific layout is specified, nodes will be positioned
on a grid.
</p>
</li>
<li><p> When <em>display</em> = <em>&quot;compact&quot;</em>, the default, nodes
and edges are converted into a flattened version to produce a compact
view of the temporal network whilst still presenting all the information
in the plotting.<br />
e.g. X_lag1-&gt;Y_lag0, X_lag2&lt;-Y_lag0 become respectively X-&gt;Y lag=1,
X&lt;-Y lag=2.
</p>
</li>
<li><p> When <em>display</em> = <em>&quot;combine&quot;</em>, prior to the plotting,
a pre-processing will be applied to kept only one edge
per pair of nodes. The info_shifted will be the highest one
of the summarized edges whilst the lag and orientation of the
summarized edge will be an aggregation.<br />
e.g. X_lag1-&gt;Y_lag0, X_lag2&lt;-Y_lag0 will become X&lt;-&gt;Y lag=1,2 with
the info_shifted of X_lag1-&gt;Y_lag0 if info_shifted of
X_lag1-&gt;Y_lag0 &gt; X_lag2&lt;-Y_lag0.
</p>
</li>
<li><p> When <em>display</em> = <em>&quot;unique&quot;</em>, prior to the plotting,
a pre-processing will be applied to kept only the edges having the
highest info_shifted for a pair of nodes.
If several edges between the sames nodes have the same
info_shifted, then the edge kept is the one with the minimum lag.<br />
e.g. X_lag1-&gt;Y_lag0, X_lag2&lt;-Y_lag0 with info_shifted of
X_lag1-&gt;Y_lag0 &gt; X_lag2&lt;-Y_lag0 become X-&gt;Y lag=1.
</p>
</li>
<li><p> When <em>display</em> = <em>&quot;drop&quot;</em>, the same pre-processing
as <em>&quot;unique&quot;</em> will be applied, then the lag information will be
dropped and will not be displayed on the final plotting.
</p>
</li></ul>
</td></tr>
<tr><td><code id="plot.tmiic_+3A_show_self_loops">show_self_loops</code></td>
<td>
<p>[a boolean, optional, TRUE by default]
</p>
<p>When TRUE, the lagged edges starting and ending on the same node
are included in the igraph  object.
When FALSE, only edges having different nodes are present in the igraph
object.</p>
</td></tr>
<tr><td><code id="plot.tmiic_+3A_positioning_for_grid">positioning_for_grid</code></td>
<td>
<p>[a string, optional, &quot;greedy&quot; by default]
</p>
<p>Used only when the display is &quot;raw&quot; or &quot;lagged&quot; and no layout is supplied.
Possible values are <em>&quot;none&quot;</em>, <em>&quot;alphabetical&quot;</em>, <em>&quot;layers&quot;</em>,
<em>&quot;greedy&quot;</em> and <em>&quot;sugiyama&quot;</em>
</p>

<ul>
<li><p> When <em>positioning_for_grid</em> = <em>&quot;none&quot;</em>
The nodes are positioned as they appear in the miic result
</p>
</li>
<li><p> When <em>positioning_for_grid</em> = <em>&quot;alphabetical&quot;</em>
The nodes are positioned alphabetically in ascending order
</p>
</li>
<li><p> When <em>positioning_for_grid</em> = <em>&quot;layers&quot;</em>
The nodes with the less lags will be placed on the exteriors
while the nodes having the most lags are in the center
</p>
</li>
<li><p> When <em>positioning_for_grid</em> = <em>&quot;greedy&quot;</em>
A greedy algorithm will be used to placed the nodes in a way minimizing
the crossing edges
</p>
</li>
<li><p> When <em>positioning_for_grid</em> = <em>&quot;sugiyama&quot;</em>
The sugiyama algorithm will be used to placed the nodes in a way
minimizing the crossing edges
</p>
</li></ul>
</td></tr>
<tr><td><code id="plot.tmiic_+3A_orientation_for_grid">orientation_for_grid</code></td>
<td>
<p>[a string, optional, &quot;L&quot; by default]
</p>
<p>Used only when the display is &quot;raw&quot; or &quot;lagged and no layout is supplied.
Indicates the orientation of the draw, possible values are landscape: &quot;L&quot;
or portrait: &quot;P&quot;.</p>
</td></tr>
<tr><td><code id="plot.tmiic_+3A_...">...</code></td>
<td>
<p>Additional plotting parameters. See the corresponding plot
function for the complete list.
</p>
<p>For igraph, see <code><a href="igraph.html#topic+igraph.plotting">igraph.plotting</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See the documentation of <code><a href="#topic+export">export</a></code> for further
details.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+export">export</a></code> for graphical exports,
<code><a href="igraph.html#topic+igraph.plotting">igraph.plotting</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(miic)

#' # EXAMPLE COVID CASES (time series demo)
data(covidCases)
# execute MIIC (reconstruct graph in temporal mode)
tmiic_obj &lt;- miic(input_data = covidCases, mode = "TS", n_layers = 3, delta_t = 1, mov_avg = 14)

# to plot the default compact graph
if(require(igraph)) {
  plot(tmiic_obj)
}

# to plot the raw temporal network
if(require(igraph)) {
  plot(tmiic_obj, display="raw")
}

# to plot the full temporal network
if(require(igraph)) {
  plot(tmiic_obj, display="lagged")
}


</code></pre>

<hr>
<h2 id='writeCytoscapeNetwork'>GraphML converting function for miic graph</h2><span id='topic+writeCytoscapeNetwork'></span>

<h3>Description</h3>

<p>Convert miic graph to <a href="http://graphml.graphdrawing.org/">GraphML format</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>writeCytoscapeNetwork(miic_obj, file, layout = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="writeCytoscapeNetwork_+3A_miic_obj">miic_obj</code></td>
<td>
<p>A miic object. The object returned by the <code><a href="#topic+miic">miic</a></code> execution.</p>
</td></tr>
<tr><td><code id="writeCytoscapeNetwork_+3A_file">file</code></td>
<td>
<p>A string. Path to the output file containing file name without
extension (.graphml will be appended).</p>
</td></tr>
<tr><td><code id="writeCytoscapeNetwork_+3A_layout">layout</code></td>
<td>
<p>An optional data frame of 2 (or 3) columns containing the
coordinate <code>x</code> and <code>y</code> for each node. The optional first column can contain
node names. If node names is not given, the order of the input file will be
assigned to the list of positions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None
</p>

<hr>
<h2 id='writeCytoscapeStyle'>Style writing function for the miic network</h2><span id='topic+writeCytoscapeStyle'></span>

<h3>Description</h3>

<p>This function writes the  miic style for a correct
visualization using the cytoscape tool (http://www.cytoscape.org/).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>writeCytoscapeStyle(file)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="writeCytoscapeStyle_+3A_file">file</code></td>
<td>
<p>[a string] The file path of the output file (containing the
file name without extension).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The style is written in the xml file format.
</p>


<h3>Value</h3>

<p>None
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
