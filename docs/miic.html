<!DOCTYPE html><html><head><title>Help for package miic</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {miic}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#cosmicCancer'><p>Genomic and ploidy alterations in breast tumors</p></a></li>
<li><a href='#cosmicCancer_stateOrder'><p>Genomic and ploidy alterations in breast tumors</p></a></li>
<li><a href='#discretizeMDL'><p>Discretize a real valued distribution</p></a></li>
<li><a href='#discretizeMutual'><p>Iterative dynamic programming for (conditional) mutual information through optimized discretization.</p></a></li>
<li><a href='#getIgraph'><p>Igraph plotting function for miic</p></a></li>
<li><a href='#hematoData'><p>Early blood development: single cell binary gene expression data</p></a></li>
<li><a href='#miic'><p>MIIC, causal network learning algorithm including latent variables</p></a></li>
<li><a href='#miic.export'><p>Export miic result to different plotting methods</p></a></li>
<li><a href='#miic.write.network.cytoscape'><p>GraphML converting function for miic graph</p></a></li>
<li><a href='#miic.write.style.cytoscape'><p>Style writing function for the miic network</p></a></li>
<li><a href='#ohno'><p>Tetraploidization in vertebrate evolution</p></a></li>
<li><a href='#ohno_stateOrder'><p>Tetraploidization in vertebrate evolution</p></a></li>
<li><a href='#plot.miic'><p>Basic plot function of a miic network inference result</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Learning Causal or Non-Causal Graphical Models Using Information
Theory</td>
</tr>
<tr>
<td>Version:</td>
<td>1.5.3</td>
</tr>
<tr>
<td>Description:</td>
<td>We report an information-theoretic method which learns a large
    class of causal or non-causal graphical models from purely observational
    data, while including the effects of unobserved latent variables, commonly
    found in many datasets. Starting from a complete graph, the method
    iteratively removes dispensable edges, by uncovering significant information
    contributions from indirect paths, and assesses edge-specific confidences
    from randomization of available data. The remaining edges are then oriented
    based on the signature of causality in observational data. This approach can
    be applied on a wide range of datasets and provide new biological insights
    on regulatory networks from single cell expression data, genomic alterations
    during tumor development and co-evolving residues in protein structures.
    For more information you can refer to:
    Cabeli et al. PLoS Comp. Bio. 2020 &lt;<a href="https://doi.org/10.1371%2Fjournal.pcbi.1007866">doi:10.1371/journal.pcbi.1007866</a>&gt;,
    Verny et al. PLoS Comp. Bio. 2017 &lt;<a href="https://doi.org/10.1371%2Fjournal.pcbi.1005662">doi:10.1371/journal.pcbi.1005662</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/miicTeam/miic_R_package">https://github.com/miicTeam/miic_R_package</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/miicTeam/miic_R_package/issues">https://github.com/miicTeam/miic_R_package/issues</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>ppcor, Rcpp, scales, stats,</td>
</tr>
<tr>
<td>Suggests:</td>
<td>igraph, grDevices, ggplot2 (&ge; 3.3.0), gridExtra</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>C++14</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2020-10-09 13:30:22 UTC; vcabeli</td>
</tr>
<tr>
<td>Author:</td>
<td>Vincent Cabeli [aut, cre],
  Honghao Li [aut],
  Marcel Ribeiro Dantas [aut],
  Nadir Sella [aut],
  Louis Verny [aut],
  Severine Affeldt [aut],
  Hervé Isambert [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Vincent Cabeli &lt;vincent.cabeli@curie.fr&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2020-10-13 23:50:11 UTC</td>
</tr>
</table>
<hr>
<h2 id='cosmicCancer'>Genomic and ploidy alterations in breast tumors</h2><span id='topic+cosmicCancer'></span>

<h3>Description</h3>

<p>The dataset contains 807 samples without predisposing Brca1/2 germline mutations
and includes 204 somatic mutations (from whole exome sequencing) and expression
level information for 91 genes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(cosmicCancer)
</code></pre>


<h3>Format</h3>

<p>A data.frame object.
</p>


<h3>References</h3>

<p>Forbes SA, Beare D, Gunasekaran P, Leung K, Bindal N, et al. (2015)
Nucleic Acids Res 43:D805–D811. (<a href="https://pubmed.ncbi.nlm.nih.gov/25355519/">PubMed link</a>)
</p>

<hr>
<h2 id='cosmicCancer_stateOrder'>Genomic and ploidy alterations in breast tumors</h2><span id='topic+cosmicCancer_stateOrder'></span>

<h3>Description</h3>

<p>The dataset contains 807 samples without predisposing Brca1/2 germline mutations
and includes 204 somatic mutations (from whole exome sequencing) and expression
level information for 91 genes, category order file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(cosmicCancer_stateOrder)
</code></pre>


<h3>Format</h3>

<p>A data.frame object.
</p>


<h3>References</h3>

<p>Forbes SA, Beare D, Gunasekaran P, Leung K, Bindal N, et al. (2015)
Nucleic Acids Res 43:D805–D811. (<a href="https://pubmed.ncbi.nlm.nih.gov/25355519/">PubMed link</a>)
</p>

<hr>
<h2 id='discretizeMDL'>Discretize a real valued distribution</h2><span id='topic+discretizeMDL'></span>

<h3>Description</h3>

<p>This function performs minimum description length (MDL)-optimal histogram density estimation
as described in Kontkanen and Myllymäki (2007) and returns the cutpoints found to give the best model
according to the MDL principle.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>discretizeMDL(x = NULL, max_bins = 20)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="discretizeMDL_+3A_x">x</code></td>
<td>
<p>[a vector]
A vector that contains the distribution to be discretized.</p>
</td></tr>
<tr><td><code id="discretizeMDL_+3A_max_bins">max_bins</code></td>
<td>
<p>[an int]
The maximum number of bins allowed by the algorithm.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the cutpoints of the best discretization.
</p>


<h3>References</h3>


<ul>
<li><p> Kontkanen P, Myllymäki P. MDL histogram density estimation. Artificial Intelligence and Statistics 2007 Mar 11 (pp. 219-226).
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>library(miic)
# Bimodal normal distribution
N &lt;- 300
modes &lt;- sample(1:2, size = N, replace = TRUE)
x &lt;- as.numeric(modes == 1) * rnorm(N, mean = 0, sd = 1) +
     as.numeric(modes == 2) * rnorm(N, mean = 5, sd = 2)
MDL_disc &lt;- discretizeMDL(x)
hist(x, breaks = MDL_disc$cutpoints)

N &lt;- 2000
modes &lt;- sample(1:2, size = N, replace = TRUE)
x &lt;- as.numeric(modes == 1) * rnorm(N, mean = 0, sd = 1) +
     as.numeric(modes == 2) * rnorm(N, mean = 5, sd = 2)
MDL_disc &lt;- discretizeMDL(x)
hist(x, breaks = MDL_disc$cutpoints)

</code></pre>

<hr>
<h2 id='discretizeMutual'>Iterative dynamic programming for (conditional) mutual information through optimized discretization.</h2><span id='topic+discretizeMutual'></span>

<h3>Description</h3>

<p>This function chooses cutpoints in the input distributions by maximizing the mutual
information minus a complexity cost (computed as BIC or with the Normalized Maximum Likelihood ). The
(conditional) mutual information computed on the optimized discretized distributions effectively approaches
the mutual information computed on the original continuous variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>discretizeMutual(
  X,
  Y,
  matrix_u = NULL,
  maxbins = NULL,
  cplx = "nml",
  n_eff = NULL,
  sample_weights = NULL,
  is_discrete = NULL,
  plot = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="discretizeMutual_+3A_x">X</code></td>
<td>
<p>[a vector]
A vector that contains the observational data of the first variable.</p>
</td></tr>
<tr><td><code id="discretizeMutual_+3A_y">Y</code></td>
<td>
<p>[a vector]
A vector that contains the observational data of the second variable.</p>
</td></tr>
<tr><td><code id="discretizeMutual_+3A_matrix_u">matrix_u</code></td>
<td>
<p>[a numeric matrix]
The matrix with the observations of as many columns as conditioning variables.</p>
</td></tr>
<tr><td><code id="discretizeMutual_+3A_maxbins">maxbins</code></td>
<td>
<p>[an int]
The maximum number of bins desired in the discretization. A lower number makes the computation faster, a higher
number allows finer discretization (by default : 5 * cubic root of N).</p>
</td></tr>
<tr><td><code id="discretizeMutual_+3A_cplx">cplx</code></td>
<td>
<p>[a string]
The complexity used in the dynamic programming. Either &quot;mdl&quot; for Minimum description Length or
&quot;nml&quot; for Normalized Maximum Likelihood, which is less costly in the finite sample case and
will allow more bins than mdl.</p>
</td></tr>
<tr><td><code id="discretizeMutual_+3A_n_eff">n_eff</code></td>
<td>
<p>[an int]
The number of effective samples. When there is significant autocorrelation in the samples you may
want to specify a number of effective samples that is lower than the number of points in the distribution.</p>
</td></tr>
<tr><td><code id="discretizeMutual_+3A_sample_weights">sample_weights</code></td>
<td>
<p>[a vector of floats]
Individual weights for each sample, used for the same reason as the effective sample number but with individual
precision.</p>
</td></tr>
<tr><td><code id="discretizeMutual_+3A_is_discrete">is_discrete</code></td>
<td>
<p>[a vector of booleans]
Specify if each variable is to be treated as discrete (TRUE) or continuous (FALSE) in a
logical vector of length ncol(matrix_u) + 2, in the order [X, Y, U1, U2...]. By default,
factors and character vectors are treated as discrete, and numerical vectors as continuous.</p>
</td></tr>
<tr><td><code id="discretizeMutual_+3A_plot">plot</code></td>
<td>
<p>[a boolean]
Specify if the XY joint space with discretization scheme is to be plotted or not (requires
ggplot2 and gridExtra).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For a pair of variables <code class="reqn">X</code> and <code class="reqn">Y</code>, the algorithm will in turn choose cutpoints on <code class="reqn">X</code>
then on <code class="reqn">Y</code>, maximizing <code class="reqn">I(X_{d};Y_{d}) - cplx(X_{d};Y_{d})</code> where <code class="reqn">cplx(X_{d};Y_{d})</code> is the
complexity cost of the considered discretizations of <code class="reqn">X</code> and <code class="reqn">Y</code> (see Affeldt 2016 and Cabeli 2020).
When the value <code class="reqn">I(X_{d};Y_{d})</code> is stable between two iterations the discretization scheme of
<code class="reqn">X_{d}</code> and <code class="reqn">Y_{d}</code> is returned as well as <code class="reqn">I(X_{d};Y_{d})</code> and <code class="reqn">I(X_{d};Y_{d})-cplx(X_{d};Y_{d})</code>.
</p>
<p>With a set of conditioning variables <code class="reqn">U</code>, the discretization scheme maximizes each term of the sum
<code class="reqn">I(X;Y|U) \sim 0.5*(I(X_{d};Y_{d}, U_{d}) - I(X_{d};U_{d}) + I(Y_{d};X_{d}, U_{d}) - I(Y_{d};U_{d}))</code>.
</p>
<p>Discrete variables can be passed as factors and will be used &quot;as is&quot; to maximize each term.
</p>


<h3>Value</h3>

<p>A list that contains :
</p>

<ul>
<li><p>two vectors containing the cutpoints for each variable : <em>cutpoints1</em> corresponds to /emphmyDist1, /emphcutpoints2 corresponds to /emphmyDist2.
</p>
</li>
<li><p><em>niterations</em> is the number of iterations performed before convergence of the (C)MI estimation.
</p>
</li>
<li><p><em>iterationN</em>, lists contatining the cutpoint vectors for each iteration.
</p>
</li>
<li><p><em>info</em> and <em>infok</em>, the estimated (C)MI value and (C)MI minus the complexity cost.
</p>
</li>
<li><p>if $emphplot == TRUE, a plot object (requires ggplot2 and gridExtra).
</p>
</li></ul>



<h3>References</h3>


<ul>
<li><p> Verny et al., <em>PLoS Comp. Bio. 2017.</em>  https://doi.org/10.1371/journal.pcbi.1005662
</p>
</li>
<li><p> Cabeli et al., <em>PLoS Comp. Bio. 2020.</em>  https://doi.org/10.1371/journal.pcbi.1007866
</p>
</li>
<li><p> Affeldt et al., <em>Bioinformatics 2016</em>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>library(miic)
N &lt;- 1000
# Dependence, conditional independence : X &lt;- Z -&gt; Y
Z &lt;- runif(N)
X &lt;- Z * 2 + rnorm(N, sd = 0.2)
Y &lt;- Z * 2 + rnorm(N, sd = 0.2)
res &lt;- discretizeMutual(X, Y, plot = FALSE)
message("I(X;Y) = ", res$info)
res &lt;- discretizeMutual(X, Y, matrix_u = matrix(Z, ncol = 1), plot = FALSE)
message("I(X;Y|Z) = ", res$info)


# Conditional independence with categorical conditioning variable : X &lt;- Z -&gt; Y
Z &lt;- sample(1:3, N, replace = TRUE)
X &lt;- -as.numeric(Z == 1) + as.numeric(Z == 2) + 0.2 * rnorm(N)
Y &lt;- as.numeric(Z == 1) + as.numeric(Z == 2) + 0.2 * rnorm(N)
res &lt;- miic::discretizeMutual(X, Y, cplx = "nml")
message("I(X;Y) = ", res$info)
res &lt;- miic::discretizeMutual(X, Y, matrix(Z, ncol = 1), is_discrete = c(FALSE, FALSE, TRUE))
message("I(X;Y|Z) = ", res$info)


# Independence, conditional dependence : X -&gt; Z &lt;- Y
X &lt;- runif(N)
Y &lt;- runif(N)
Z &lt;- X + Y + rnorm(N, sd = 0.1)
res &lt;- discretizeMutual(X, Y, plot = TRUE)
message("I(X;Y) = ", res$info)
res &lt;- discretizeMutual(X, Y, matrix_u = matrix(Z, ncol = 1), plot = TRUE)
message("I(X;Y|Z) = ", res$info)


</code></pre>

<hr>
<h2 id='getIgraph'>Igraph plotting function for miic</h2><span id='topic+getIgraph'></span>

<h3>Description</h3>

<p>This functions returns an igraph object built from the result
returned by <code><a href="#topic+miic">miic</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getIgraph(miic.res)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getIgraph_+3A_miic.res">miic.res</code></td>
<td>
<p>[a miic graph object]
The graph object returned by the miic execution.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Edges attributes are passed to the igraph graph and can be accessed with
e.g. <code>E(g)$partial_correlation</code>. See <code><a href="#topic+miic">miic</a></code> for more
details on edge parameters. By default, edges are colored according to the
partial correlation between two nodes conditioned on the conditioning set
(negative is blue, null is gray and positive is red) and their width is
based on the conditional mutual information minus the complexity cost.
</p>


<h3>Value</h3>

<p>An igraph graph object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+miic">miic</a></code> for details on edge parameters in the returned object,
<code><a href="igraph.html#topic+igraph.plotting">igraph.plotting</a></code> for the detailed description of the
plotting parameters and <code><a href="igraph.html#topic+layout">layout</a></code> for different layouts.
</p>

<hr>
<h2 id='hematoData'>Early blood development: single cell binary gene expression data</h2><span id='topic+hematoData'></span>

<h3>Description</h3>

<p>Binarized expression data of 33 transcription factors involved
in early differentiation of primitive erythroid and endothelial
cells (3934 cells).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(hematoData)
</code></pre>


<h3>Format</h3>

<p>A data.frame object.
</p>


<h3>References</h3>

<p>Moignard et al. (2015) Nat Biotechnol 33(3):269-76
(<a href="https://pubmed.ncbi.nlm.nih.gov/25355519/">PubMed link</a>)
</p>

<hr>
<h2 id='miic'>MIIC, causal network learning algorithm including latent variables</h2><span id='topic+miic'></span>

<h3>Description</h3>

<p>MIIC (Multivariate Information based Inductive Causation) combines
constraint-based and information-theoretic approaches to disentangle direct
from indirect effects amongst correlated variables, including cause-effect
relationships and the effect of unobserved latent causes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>miic(
  input_data,
  state_order = NULL,
  true_edges = NULL,
  black_box = NULL,
  n_threads = 1,
  cplx = c("nml", "mdl"),
  orientation = TRUE,
  ori_proba_ratio = 1,
  propagation = TRUE,
  latent = c("no", "yes", "orientation"),
  n_eff = -1,
  n_shuffles = 0,
  conf_threshold = 0,
  sample_weights = NULL,
  test_mar = TRUE,
  consistent = c("no", "orientation", "skeleton"),
  max_iteration = 100,
  consensus_threshold = 0.8,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="miic_+3A_input_data">input_data</code></td>
<td>
<p>[a data frame]
A n*d data frame (n samples, d variables) that contains the observational data.
Each column corresponds to one variable and each row is a sample that gives the
values for all the observed variables. The column names correspond to the
names of the observed variables. Numeric columns will be treated as continuous
values, factors and character as categorical.</p>
</td></tr>
<tr><td><code id="miic_+3A_state_order">state_order</code></td>
<td>
<p>[a data frame]
An optional d*(2-3) data frame giving the order of the ordinal categorical variables.
It will be used during post-processing to compute the signs of the edges using partial
linear correlation. 
If specified, the data frame must have at least a &quot;var_names&quot; column, containing the
names of each variable as specified by colnames(input_data). A &quot;var_type&quot; column may
specify if each variable is to be considered as discrete (0) or continuous (1). And 
the &quot;levels_increasing_order&quot; column contains a single character string with all of
the unique levels of the ordinal variable in increasing order, delimited by a comma.
If the variable is categorical but not ordinal, the &quot;levels_increasing_order&quot; column
may instead contain NA.</p>
</td></tr>
<tr><td><code id="miic_+3A_true_edges">true_edges</code></td>
<td>
<p>[a data frame]
An optional E*2 data frame containing the E edges of the true graph for
computing performance after the run.</p>
</td></tr>
<tr><td><code id="miic_+3A_black_box">black_box</code></td>
<td>
<p>[a data frame]
An optional E*2 data frame containing E pairs of variables that will be considered
as independent during the network reconstruction. In practice, these edges will not
be included in the skeleton initialization and cannot be part of the final result. 
Variable names must correspond to the <em>input_data</em> data frame.</p>
</td></tr>
<tr><td><code id="miic_+3A_n_threads">n_threads</code></td>
<td>
<p>[a positive integer]
When set greater than 1, n_threads parallel threads will be used for computation. Make sure
your compiler is compatible with openmp if you wish to use multithreading.</p>
</td></tr>
<tr><td><code id="miic_+3A_cplx">cplx</code></td>
<td>
<p>[a string; <em>c(&quot;nml&quot;, &quot;mdl&quot;)</em>]
In practice, the finite size of the input
dataset requires that the 2-point and 3-point information measures should be
<em>shifted</em> by a <em>complexity</em> term. The finite size corrections can be
based on the Minimal Description Length (MDL) criterion (set the option with &quot;mdl&quot;).
In practice, the MDL complexity criterion tends to underestimate the relevance of
edges connecting variables with many different categories, leading to the removal of
false negative edges. To avoid such biases with finite datasets, the (universal)
Normalized Maximum Likelihood (NML) criterion can be used (set the option with &quot;nml&quot;).
The default is &quot;nml&quot; (see Affeldt <em>et al.</em>, UAI 2015).</p>
</td></tr>
<tr><td><code id="miic_+3A_orientation">orientation</code></td>
<td>
<p>[a boolean value]
The miic network skeleton can be partially directed
by orienting and propagating edge directions, based on the sign and magnitude
of the conditional 3-point information of unshielded triples. The propagation
procedure relyes on probabilities; for more details, see Verny <em>et al.</em>, PLoS Comp. Bio. 2017).
If set to FALSE the orientation step is not performed.</p>
</td></tr>
<tr><td><code id="miic_+3A_ori_proba_ratio">ori_proba_ratio</code></td>
<td>
<p>[a floating point between 0 and 1] When orienting an
edge according to the probability of orientation, the threshold to accept the
orientation. For a given edge, denote by p &gt; 0.5 the probability of
orientation, the orientation is accepted if (1 - p) / p &lt; ori_proba_ratio.
0 means reject all orientations, 1 means accept all orientations.</p>
</td></tr>
<tr><td><code id="miic_+3A_propagation">propagation</code></td>
<td>
<p>[a boolean value]
If set to FALSE, the skeleton is partially oriented with only the
v-structure orientations. Otherwise, the v-structure orientations are
propagated to downstream undirected edges in unshielded triples following
the orientation method</p>
</td></tr>
<tr><td><code id="miic_+3A_latent">latent</code></td>
<td>
<p>[a string; <em>c(&quot;no&quot;, &quot;yes&quot;, &quot;orientation&quot;)</em>]
When set to &quot;yes&quot;, the network reconstruction is taking into account hidden (latent)
variables. When set to &quot;orientation&quot;, latent variables are not considered during the skeleton
reconstruction but allows bi-directed edges during the orientation. Dependence
between two observed variables due to a latent variable is indicated with a '6' in
the adjacency matrix and in the network edges.summary and by a bi-directed edge
in the (partially) oriented graph.</p>
</td></tr>
<tr><td><code id="miic_+3A_n_eff">n_eff</code></td>
<td>
<p>[a positive integer]
The n samples given in the <em>input_data</em> data frame are expected
to be independent. In case of correlated samples such as in time series or
Monte Carlo sampling approaches, the effective number of independent samples
<em>n_eff</em> can be estimated using the decay of the autocorrelation function
(Verny <em>et al.</em>, PLoS Comp. Bio. 2017). This <em>effective</em> number <em>n_eff</em>
of <em>independent</em> samples can be provided using this parameter.</p>
</td></tr>
<tr><td><code id="miic_+3A_n_shuffles">n_shuffles</code></td>
<td>
<p>[a positive integer] The number of shufflings of
the original dataset in order to evaluate the edge specific confidence
ratio of all inferred edges.</p>
</td></tr>
<tr><td><code id="miic_+3A_conf_threshold">conf_threshold</code></td>
<td>
<p>[a positive floating point] The threshold used
to filter the less probable edges following the skeleton step. See Verny
<em>et al.</em>, PLoS Comp. Bio. 2017.</p>
</td></tr>
<tr><td><code id="miic_+3A_sample_weights">sample_weights</code></td>
<td>
<p>[a numeric vector]
An optional vector containing the weight of each observation.</p>
</td></tr>
<tr><td><code id="miic_+3A_test_mar">test_mar</code></td>
<td>
<p>[a boolean value]
If set to TRUE, distributions with missing values will be tested with Kullback-Leibler
divergence : conditioning variables for the given link <code class="reqn">X\rightarrow Y</code><code class="reqn">Z</code> will be
considered only if the divergence between the full distribution and the non-missing
distribution <code class="reqn">KL(P(X,Y) | P(X,Y)_{!NA})</code> is low enough (with <code class="reqn">P(X,Y)_{!NA}</code> as
the joint distribution of <code class="reqn">X</code> and <code class="reqn">Y</code> on samples which are not missing on Z.
This is a way to ensure that data are missing at random for the considered
interaction and to avoid selection bias. Set to TRUE by default</p>
</td></tr>
<tr><td><code id="miic_+3A_consistent">consistent</code></td>
<td>
<p>[a string; <em>c(&quot;no&quot;, &quot;orientation&quot;, &quot;skeleton&quot;)</em>]
if &quot;orientation&quot;: iterate over skeleton and orientation steps to ensure
consistency of the network;
if &quot;skeleton&quot;: iterate over skeleton step to get a consistent skeleton, then
orient edges and discard inconsistent orientations to ensure consistency of
the network. See (Li <em>et al.</em>, NeurIPS 2019) for details.</p>
</td></tr>
<tr><td><code id="miic_+3A_max_iteration">max_iteration</code></td>
<td>
<p>[a positive integer] When the <em>consistent</em> parameter
is set to &quot;skeleton&quot; or &quot;orientation&quot;, the maximum number of iterations
allowed when trying to find a consistent graph. Set to 100 by default.</p>
</td></tr>
<tr><td><code id="miic_+3A_consensus_threshold">consensus_threshold</code></td>
<td>
<p>[a floating point between 0.5 and 1.0]
When the <em>consistent</em> parameter is set to &quot;skeleton&quot; or &quot;orientation&quot;,
and when the result graph is inconsistent, or is a union of more than one
inconsistent graphs, a consensus graph will be produced based on a pool of
graphs. If the result graph is inconsistent, then the pool is made of
[max_iteration] graphs from the iterations, otherwise it is made of those
graphs in the union. In the consensus graph, the status of each edge is
determined as follows: Choose from the pool the most probable status. For
example, if the pool contains [A, B, B, B, C], then choose status B, if the
frequency of presence of B (0.6 in the example) is equal to or higher than
[consensus_threshold], then set B as the status of the edge in the consensus
graph, otherwise set undirected edge as the status. Set to 0.8 by default.</p>
</td></tr>
<tr><td><code id="miic_+3A_verbose">verbose</code></td>
<td>
<p>[a boolean value] If TRUE, debugging output is printed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Starting from a complete graph, the method iteratively removes
dispensable edges, by uncovering significant information contributions from
indirect paths, and assesses edge-specific confidences from randomization of
available data. The remaining edges are then oriented based on the signature
of causality in observational data.
</p>
<p>The method relies on an information theoretic based (conditional) independence
test which is described in (Verny <em>et al.</em>, PLoS Comp. Bio. 2017),
(Cabeli <em>et al.</em>, PLoS Comp. Bio. 2020). It deals with both categorical
and continuous variables by performing optimal context-dependent discretization.
As such, the input data frame may contain both numerical columns which will be
treated as continuous, or character / factor columns which will be treated
as categorical. For further details on the optimal discretization method and
the conditional independence test, see the function discretizeMutual.
The user may also choose to run miic with scheme presented in
(Li <em>et al.</em>, NeurIPS 2019) to improve the end result's interpretability
by ensuring consistent separating set during the skeleton iterations.
</p>


<h3>Value</h3>

<p>A <em>miic-like</em> object that contains:
</p>

<ul>
<li><p>all.edges.summary: a data frame with information about the relationship between
each pair of variables
</p>

<ul>
<li> <p><em>x:</em> X node
</p>
</li>
<li> <p><em>y:</em> Y node
</p>
</li>
<li> <p><em>type:</em> contains 'N' if the edge has
been removed or 'P' for retained edges. If a true edges file is given,
'P' becomes 'TP' (True Positive) or 'FP' (False Positive), while
'N' becomes 'TN' (True Negative) or 'FN' (False Negative).
</p>
</li>
<li> <p><em>ai:</em> the contributing nodes found by the method which participate in
the mutual information between <em>x</em> and <em>y</em>, and possibly separate them.
</p>
</li>
<li> <p><em>info:</em> provides the pairwise mutual information times <em>Nxyi</em> for
the pair (<em>x</em>, <em>y</em>).
</p>
</li>
<li> <p><em>info_cond:</em> provides the conditional mutual information times <em>Nxy_ai</em> for
the pair (<em>x</em>, <em>y</em>) when conditioned on the collected nodes <em>ai</em>. It is
equal to the <em>info</em> column when <em>ai</em> is an empty set.
</p>
</li>
<li> <p><em>cplx:</em> gives the computed complexity between the (<em>x</em>, <em>y</em>)
variables taking into account the contributing nodes <em>ai</em>. Edges that have
have more conditional information <em>info_cond</em> than <em>cplx</em> are retained in the
final graph.
</p>
</li>
<li> <p><em>Nxy_ai:</em> gives the number of complete samples on which the information and
the  complexity have been computed. If the input dataset has no missing value, the
number of samples is the same for all pairs and corresponds to the total
number of samples.
</p>
</li>
<li> <p><em>log_confidence:</em> represents the <em>info</em> - <em>cplx</em> value.
It is a way to quantify the strength of the edge (<em>x</em>, <em>y</em>).
</p>
</li>
<li> <p><em>confidenceRatio:</em> this column is present if the confidence cut
is &gt; 0 and it represents the ratio between the probability to reject
the edge (<em>x</em>, <em>y</em>) in the dataset versus the mean probability
to do the same in multiple (user defined) number of randomized datasets.
</p>
</li>
<li> <p><em>infOrt:</em> the orientation of the edge (<em>x</em>, <em>y</em>). It is
the same value as in the adjacency matrix at row <em>x</em> and column <em>y</em> : 1 for
unoriented, 2 for an edge from X to Y, -2 from Y to X and 6 for bidirectional.
</p>
</li>
<li> <p><em>trueOrt:</em> the orientation of the edge (<em>x</em>, <em>y</em>) present
in the true edges file if provided.
</p>
</li>
<li> <p><em>isOrtOk:</em> information about the consistency of the inferred graph’s
orientations with a reference graph is given (i.e. if true edges file is provided).
Y: the orientation is consistent; N: the orientation is not consistent with
the PAG (Partial Ancestor Graph) derived from the given true graph.
</p>
</li>
<li> <p><em>sign:</em> the sign of the partial correlation between variables
<em>x</em> and <em>y</em>, conditioned on the contributing nodes <em>ai</em>.
</p>
</li>
<li> <p><em>partial_correlation:</em> value of the partial correlation for the
edge (<em>x</em>, <em>y</em>) conditioned on the contributing nodes <em>ai</em>.
</p>
</li>
<li> <p><em>isCausal:</em> details about the nature of the arrow tip for a directed
edge. A directed edge in a causal graph does not necessarily imply causation but it
does imply that the cause-effect relationship is not the other way around. An arrow-tip
which is itself downstream of another directed edge suggests stronger causal sense and is
marked by a 'Y', or 'N' otherwise.
</p>
</li>
<li> <p><em>proba:</em> probabilities for the inferred orientation, derived from the three-point
mutual information (cf Affeldt &amp; Isambert, UAI 2015 proceedings) and noted as p(x-&gt;y);p(x&lt;-y).
</p>
</li></ul>


</li>
<li><p>retained.edges.summary: a data frame in the format of all.edges.summary containing only the inferred edges.
</p>
</li>
<li><p>orientations.prob: this data frame lists the orientation probabilities of the two edges of all unshielded triples
of the reconstructed network with the structure: node1 &ndash; mid-node &ndash; node2:
</p>

<ul>
<li><p> node1: node at the end of the unshielded triplet
</p>
</li>
<li><p> p1: probability of the arrowhead node1 &lt;- mid-node
</p>
</li>
<li><p> p2: probability of the arrowhead node1 -&gt; mid-node
</p>
</li>
<li><p> mid-node: node at the center of the unshielded triplet
</p>
</li>
<li><p> p3: probability of the arrowhead mid-node &lt;- node2
</p>
</li>
<li><p> p4: probability of the arrowhead mid-node -&gt; node2
</p>
</li>
<li><p> node2: node at the end of the unshielded triplet
</p>
</li>
<li><p> NI3: 3 point (conditional) mutual information * N
</p>
</li></ul>

</li>
<li> <p>AdjMatrix: the adjacency matrix is a square matrix used to represent
the inferred graph. The entries of the matrix indicate whether pairs of
vertices are adjacent or not in the graph. The matrix can be read as a
(row, column) set of couples where the row represents the source node and
the column the target node. Since miic can reconstruct mixed networks
(including directed, undirected and bidirected edges), we will have a
different digit for each case:
</p>

<ul>
<li><p> 1: (<em>x</em>, <em>y</em>) edge is undirected
</p>
</li>
<li><p> 2: (<em>x</em>, <em>y</em>) edge is directed as <em>x</em> -&gt; <em>y</em>
</p>
</li>
<li><p> -2: (<em>x</em>, <em>y</em>) edge is directed as <em>x</em> &lt;- <em>y</em>
</p>
</li>
<li><p> 6: (<em>x</em>, <em>y</em>) edge is bidirected
</p>
</li></ul>

</li></ul>



<h3>References</h3>


<ul>
<li><p> Verny et al., <em>PLoS Comp. Bio. 2017.</em>  https://doi.org/10.1371/journal.pcbi.1005662
</p>
</li>
<li><p> Cabeli et al., <em>PLoS Comp. Bio. 2020.</em>  https://doi.org/10.1371/journal.pcbi.1007866
</p>
</li>
<li><p> Li et al., <em>NeurIPS 2019</em> http://papers.nips.cc/paper/9573-constraint-based-causal-structure-learning-with-consistent-separating-sets.pdf
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+discretizeMutual">discretizeMutual</a></code> for optimal discretization and
(conditional) independence test.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(miic)

# EXAMPLE HEMATOPOIESIS
data(hematoData)

# execute MIIC (reconstruct graph)
miic.res &lt;- miic(
  input_data = hematoData[1:1000,], latent = "yes",
  n_shuffles = 10, conf_threshold = 0.001
)

# plot graph
if(require(igraph)) {
 plot(miic.res, method="igraph")
}


# write graph to graphml format. Note that to correctly visualize
# the network we created the miic style for Cytoscape (http://www.cytoscape.org/).

miic.write.network.cytoscape(g = miic.res, file = file.path(tempdir(), "temp"))

# EXAMPLE CANCER
data(cosmicCancer)
data(cosmicCancer_stateOrder)
# execute MIIC (reconstruct graph)
miic.res &lt;- miic(
  input_data = cosmicCancer, state_order = cosmicCancer_stateOrder, latent = "yes",
  n_shuffles = 100, conf_threshold = 0.001
)

# plot graph
if(require(igraph)) {
 plot(miic.res)
}

# write graph to graphml format. Note that to correctly visualize
# the network we created the miic style for Cytoscape (http://www.cytoscape.org/).
miic.write.network.cytoscape(g = miic.res, file = file.path(tempdir(), "temp"))

# EXAMPLE OHNOLOGS
data(ohno)
data(ohno_stateOrder)
# execute MIIC (reconstruct graph)
miic.res &lt;- miic(
  input_data = ohno, latent = "yes", state_order = ohno_stateOrder,
  n_shuffles = 100, conf_threshold = 0.001
)

# plot graph
if(require(igraph)) {
 plot(miic.res)
}

# write graph to graphml format. Note that to correctly visualize
# the network we created the miic style for Cytoscape (http://www.cytoscape.org/).
miic.write.network.cytoscape(g = miic.res, file = file.path(tempdir(), "temp"))


</code></pre>

<hr>
<h2 id='miic.export'>Export miic result to different plotting methods</h2><span id='topic+miic.export'></span>

<h3>Description</h3>

<p>This function creates an object built from the result returned
by <code><a href="#topic+miic">miic</a></code> that is ready to be fed to different plotting methods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>miic.export(miic.res, method = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="miic.export_+3A_miic.res">miic.res</code></td>
<td>
<p>[a miic graph object]
The graph object returned by the miic execution.</p>
</td></tr>
<tr><td><code id="miic.export_+3A_method">method</code></td>
<td>
<p>A string representing the plotting method.
Currently only &quot;igraph&quot; is supported.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See the details of specific function for each method.
For igraph, see <code><a href="#topic+getIgraph">getIgraph</a></code>.
</p>


<h3>Value</h3>

<p>A graph object adapted to the method.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+getIgraph">getIgraph</a></code> for details on the igraph exported object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(miic)
data(hematoData)

# execute MIIC (reconstruct graph)
miic.res &lt;- miic(
  input_data = hematoData, latent = "yes",
  n_shuffles = 10, conf_threshold = 0.001
)

# Using igraph
if(require(igraph)) {
g = miic.export(miic.res, "igraph")
plot(g) # Default visualisation, calls igraph::plot.igraph()

# Specifying layout (see ?igraph::layout_)
l &lt;-layout_with_kk(g)
plot(g, layout=l)

# Override some graphical parameters
plot(g, edge.curved = .2)
plot(g, vertex.shape="none", edge.color="gray85", vertex.label.color="gray10")
}



</code></pre>

<hr>
<h2 id='miic.write.network.cytoscape'>GraphML converting function for miic graph</h2><span id='topic+miic.write.network.cytoscape'></span>

<h3>Description</h3>

<p>Convert miic graph to <a href="http://graphml.graphdrawing.org/">GraphML format</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>miic.write.network.cytoscape(g, file, layout = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="miic.write.network.cytoscape_+3A_g">g</code></td>
<td>
<p>The graph object returned by <a href="#topic+miic">miic</a>.</p>
</td></tr>
<tr><td><code id="miic.write.network.cytoscape_+3A_file">file</code></td>
<td>
<p>A string. Path to the output file containing file name without
extension (.graphml will be appended).</p>
</td></tr>
<tr><td><code id="miic.write.network.cytoscape_+3A_layout">layout</code></td>
<td>
<p>An optional data frame of 2 (or 3) columns containing the
coordinate <code>x</code> and <code>y</code> for each node. The optional first column can contain
node names. If node names is not given, the order of the input file will be
assigned to the list of positions.</p>
</td></tr>
</table>

<hr>
<h2 id='miic.write.style.cytoscape'>Style writing function for the miic network</h2><span id='topic+miic.write.style.cytoscape'></span>

<h3>Description</h3>

<p>This function writes the  miic style for a correct visualization using the cytoscape tool (http://www.cytoscape.org/).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>miic.write.style.cytoscape(file)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="miic.write.style.cytoscape_+3A_file">file</code></td>
<td>
<p>[a string] The file path of the output file (containing the file name without extension).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The style is written in the xml file format.
</p>

<hr>
<h2 id='ohno'>Tetraploidization in vertebrate evolution</h2><span id='topic+ohno'></span>

<h3>Description</h3>

<p>20,415 protein-coding genes in the human genome from Ensembl (v70) and information on the
retention of duplicates originating either from the two whole genome duplications at
the onset of vertebrates (‘ohnolog’) or from subsequent small scale duplications (‘SSD’)
as well as copy number variants (‘CNV’).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(ohno)
</code></pre>


<h3>Format</h3>

<p>A data.frame object.
</p>


<h3>References</h3>

<p>Verny et al., PLoS Comp. Bio. 2017.
</p>

<hr>
<h2 id='ohno_stateOrder'>Tetraploidization in vertebrate evolution</h2><span id='topic+ohno_stateOrder'></span>

<h3>Description</h3>

<p>20,415 protein-coding genes in the human genome from Ensembl (v70) and information on the
retention of duplicates originating either from the two whole genome duplications at
the onset of vertebrates (‘ohnolog’) or from subsequent small scale duplications (‘SSD’)
as well as copy number variants (‘CNV’), category order.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(ohno_stateOrder)
</code></pre>


<h3>Format</h3>

<p>A data.frame object.
</p>


<h3>References</h3>

<p>Verny et al., PLoS Comp. Bio. 2017.
</p>

<hr>
<h2 id='plot.miic'>Basic plot function of a miic network inference result</h2><span id='topic+plot.miic'></span>

<h3>Description</h3>

<p>This function calls <code><a href="#topic+miic.export">miic.export</a></code> to build a
plottable object from the result returned by <code><a href="#topic+miic">miic</a></code> and plot it.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'miic'
plot(x, method = "igraph", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.miic_+3A_x">x</code></td>
<td>
<p>[a miic graph object]
The graph object returned by <code><a href="#topic+miic">miic</a></code>.</p>
</td></tr>
<tr><td><code id="plot.miic_+3A_method">method</code></td>
<td>
<p>A string representing the plotting method. Default to &quot;igraph&quot;.
Currently only &quot;igraph&quot; is supported.</p>
</td></tr>
<tr><td><code id="plot.miic_+3A_...">...</code></td>
<td>
<p>Additional plotting parameters. See the corresponding plot function
for the complete list.
For igraph, see <code><a href="igraph.html#topic+igraph.plotting">igraph.plotting</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See the documentation of <code><a href="#topic+miic.export">miic.export</a></code> for further
details.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+miic.export">miic.export</a></code> for generic exports,
<code><a href="#topic+getIgraph">getIgraph</a></code> for igraph export,
<code><a href="igraph.html#topic+igraph.plotting">igraph.plotting</a></code>
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
