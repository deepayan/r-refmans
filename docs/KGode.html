<!DOCTYPE html><html><head><title>Help for package KGode</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {KGode}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#bootstrap'><p>The 'bootstrap' function</p></a></li>
<li><a href='#crossv'><p>The 'crossv' function</p></a></li>
<li><a href='#diagnostic'><p>The 'diagnostic' function</p></a></li>
<li><a href='#Kernel'><p>The 'Kernel' class object</p></a></li>
<li><a href='#MLP'><p>The 'MLP' class object</p></a></li>
<li><a href='#ode'><p>The 'ode' class object</p></a></li>
<li><a href='#RBF'><p>The 'RBF' class object</p></a></li>
<li><a href='#rkg'><p>The 'rkg' function</p></a></li>
<li><a href='#rkg3'><p>The 'rkg3' class object</p></a></li>
<li><a href='#rkhs'><p>The 'rkhs' class object</p></a></li>
<li><a href='#third'><p>The 'third' function</p></a></li>
<li><a href='#Warp'><p>The 'Warp' class object</p></a></li>
<li><a href='#warpfun'><p>The 'warpfun' function</p></a></li>
<li><a href='#warpInitLen'><p>The 'warpInitLen' function</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Kernel Based Gradient Matching for Parameter Inference in
Ordinary Differential Equations</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.4</td>
</tr>
<tr>
<td>Author:</td>
<td>Mu Niu [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Mu Niu &lt;mu.niu@glasgow.ac.uk&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>The kernel ridge regression and the gradient matching algorithm proposed in Niu et al. (2016) <a href="https://proceedings.mlr.press/v48/niu16.html">https://proceedings.mlr.press/v48/niu16.html</a> and the warping algorithm proposed in Niu et al. (2017) &lt;<a href="https://doi.org/10.1007%2Fs00180-017-0753-z">doi:10.1007/s00180-017-0753-z</a>&gt; are implemented for parameter inference in differential equations. Four schemes are provided for improving parameter estimation in odes by using the odes regularisation and warping.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.2.0)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Imports:</td>
<td>R6,pracma,pspline,mvtnorm,graphics</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-08-19 13:39:13 UTC; muniu</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-08-19 14:00:08 UTC</td>
</tr>
</table>
<hr>
<h2 id='bootstrap'>The 'bootstrap' function</h2><span id='topic+bootstrap'></span>

<h3>Description</h3>

<p>This function is used to perform bootstrap procedure to estimate parameter uncertainty.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bootstrap(kkk, y_no, ktype, K, ode_par, intp_data, www = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bootstrap_+3A_kkk">kkk</code></td>
<td>
<p>ode class object.</p>
</td></tr>
<tr><td><code id="bootstrap_+3A_y_no">y_no</code></td>
<td>
<p>matrix(of size n_s*n_o) containing noisy observations. The row(of length n_s) represent the ode states and the column(of length n_o) represents the time points.</p>
</td></tr>
<tr><td><code id="bootstrap_+3A_ktype">ktype</code></td>
<td>
<p>character containing kernel type. User can choose 'rbf' or 'mlp' kernel.</p>
</td></tr>
<tr><td><code id="bootstrap_+3A_k">K</code></td>
<td>
<p>the number of bootstrap replicates to collect.</p>
</td></tr>
<tr><td><code id="bootstrap_+3A_ode_par">ode_par</code></td>
<td>
<p>a vector of ode parameters estimated using gradient matching.</p>
</td></tr>
<tr><td><code id="bootstrap_+3A_intp_data">intp_data</code></td>
<td>
<p>a list of interpolations produced by gradient matching for each ode state.</p>
</td></tr>
<tr><td><code id="bootstrap_+3A_www">www</code></td>
<td>
<p>an optional warping object (if warping has been performed using warpfun).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Arguments of the 'bootstrap' function are 'ode' class, noisy observation, kernel type, the set of parameters that have been estimated before using gradient matching, a list of interpolations for each of the ode state from gradient matching, and the warping object (if warping has been performed). It returns a vector of the median absolute standard deviations for each ode state, computed from the bootstrap replicates.
</p>


<h3>Value</h3>

<p>return a vector of the median absolute deviation (MAD) for each ode state.
</p>


<h3>Author(s)</h3>

<p>Mu Niu <a href="mailto:mu.niu@glasgow.ac.uk">mu.niu@glasgow.ac.uk</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
require(mvtnorm)
noise = 0.1  ## set the variance of noise
SEED = 19537
set.seed(SEED)
## Define ode function, we use lotka-volterra model in this example.
## we have two ode states x[1], x[2] and four ode parameters alpha, beta, gamma and delta.
LV_fun = function(t,x,par_ode){
  alpha=par_ode[1]
  beta=par_ode[2]
  gamma=par_ode[3]
  delta=par_ode[4]
  as.matrix( c( alpha*x[1]-beta*x[2]*x[1] , -gamma*x[2]+delta*x[1]*x[2] ) )
}
## Define the gradient of ode function against ode parameters
## df/dalpha,  df/dbeta, df/dgamma, df/ddelta where f is the differential equation.
LV_grlNODE= function(par,grad_ode,y_p,z_p) {
alpha = par[1]; beta= par[2]; gamma = par[3]; delta = par[4]
dres= c(0)
dres[1] = sum( -2*( z_p[1,]-grad_ode[1,])*y_p[1,]*alpha )
dres[2] = sum( 2*( z_p[1,]-grad_ode[1,])*y_p[2,]*y_p[1,]*beta)
dres[3] = sum( 2*( z_p[2,]-grad_ode[2,])*gamma*y_p[2,] )
dres[4] = sum( -2*( z_p[2,]-grad_ode[2,])*y_p[2,]*y_p[1,]*delta)
dres
}

## create a ode class object
kkk0 = ode$new(2,fun=LV_fun,grfun=LV_grlNODE)
## set the initial values for each state at time zero.
xinit = as.matrix(c(0.5,1))
## set the time interval for the ode numerical solver.
tinterv = c(0,6)
## solve the ode numerically using predefined ode parameters. alpha=1, beta=1, gamma=4, delta=1.
kkk0$solve_ode(c(1,1,4,1),xinit,tinterv)

## Add noise to the numerical solution of the ode model and use it as the noisy observation.
n_o = max( dim( kkk0$y_ode) )
t_no = kkk0$t
y_no =  t(kkk0$y_ode) + rmvnorm(n_o,c(0,0),noise*diag(2))

## Create a ode class object by using the simulation data we created from the ode numerical solver.
## If users have experiment data, they can replace the simulation data with the experiment data.
## Set initial value of ode parameters.
init_par = rep(c(0.1),4)
init_yode = t(y_no)
init_t = t_no
kkk = ode$new(1,fun=LV_fun,grfun=LV_grlNODE,t=init_t,ode_par= init_par, y_ode=init_yode )

## The following examples with CPU or elapsed time &gt; 10s

##Use function 'rkg' to estimate the ode parameters. The standard gradient matching method is coded
##in the the 'rkg' function. The parameter estimations are stored in the returned vector of 'rkg'.
## Choose a kernel type for 'rkhs' interpolation. Two options are provided 'rbf' and 'mlp'.
ktype ='rbf'
rkgres = rkg(kkk,y_no,ktype)
## show the results of ode parameter estimation using the standard gradient matching
kkk$ode_par

## Perform bootstrap procedure to estimate the median absolute deviations of ode parameters
# here we get the resulting interpolation from gradient matching using 'rkg' for each ode state
bbb = rkgres$bbb
nst = length(bbb)
intp_data = list()
for( i in 1:nst) {
    intp_data[[i]] = bbb[[i]]$predictT(bbb[[i]]$t)$pred
}
K = 12 # the number of bootstrap replicates
mads = bootstrap(kkk, y_no, ktype, K, ode_par, intp_data)

## show the results of ode parameter estimation and its uncertainty
## using the standard gradient matching
ode_par
mads

############# gradient matching + ODE regularisation
crtype='i'
lam=c(10,1,1e-1,1e-2,1e-4)
lamil1 = crossv(lam,kkk,bbb,crtype,y_no)
lambdai1=lamil1[[1]]
res = third(lambdai1,kkk,bbb,crtype)
oppar = res$oppar

### do bootstrap here for gradient matching + ODE regularisation
ode_par = oppar
K = 12
intp_data = list()
for( i in 1:nst) {
    intp_data[[i]] = res$rk3$rk[[i]]$predictT(bbb[[i]]$t)$pred
}
mads = bootstrap(kkk, y_no, ktype, K, ode_par, intp_data)
ode_par
mads

############# gradient matching + ODE regularisation + warping
###### warp state
peod = c(6,5.3) #8#9.7     ## the guessing period
eps= 1          ## the standard deviation of period
fixlens=warpInitLen(peod,eps,rkgres)
kkkrkg = kkk$clone()
www = warpfun(kkkrkg,bbb,peod,eps,fixlens,y_no,kkkrkg$t)

### do bootstrap here for gradient matching + ODE regularisation + warping
nst = length(bbb)
K = 12
ode_par = www$wkkk$ode_par
intp_data = list()
for( i in 1:nst) {
    intp_data[[i]] = www$bbbw[[i]]$predictT(www$wtime[i, ])$pred
}
mads = bootstrap(kkk, y_no, ktype, K, ode_par, intp_data,www)
ode_par
mads


## End(Not run)
</code></pre>

<hr>
<h2 id='crossv'>The 'crossv' function</h2><span id='topic+crossv'></span>

<h3>Description</h3>

<p>This function is used to estimate the weighting parameter for ode regularisation using cross validation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>crossv(lam, kkk, bbb, crtype, y_no, woption, resmtest, dtilda, fold)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="crossv_+3A_lam">lam</code></td>
<td>
<p>vector containing different choices of the weighting parameter of ode regularisation.</p>
</td></tr>
<tr><td><code id="crossv_+3A_kkk">kkk</code></td>
<td>
<p>'ode' class object containing all information about the odes.</p>
</td></tr>
<tr><td><code id="crossv_+3A_bbb">bbb</code></td>
<td>
<p>list of 'rkhs' class object containing the interpolation for all ode states.</p>
</td></tr>
<tr><td><code id="crossv_+3A_crtype">crtype</code></td>
<td>
<p>character containing the optimisation scheme type. User can choose 'i' or '3'. 'i' is for fast iterative scheme and '3' for optimising the ode parameters and interpolation coefficients simultaneously.</p>
</td></tr>
<tr><td><code id="crossv_+3A_y_no">y_no</code></td>
<td>
<p>matrix(of size n_s*n_o) containing noisy observations. The row(of length n_s) represent the ode states and the column(of length n_o) represents the time points.</p>
</td></tr>
<tr><td><code id="crossv_+3A_woption">woption</code></td>
<td>
<p>character containing the indication of using warping. If the warping scheme is done before using the ode regularisation, user can choose 'w' otherwise just leave this option empty.</p>
</td></tr>
<tr><td><code id="crossv_+3A_resmtest">resmtest</code></td>
<td>
<p>vector(of length n_o) containing the warped time points. This variable is only used if user want to combine warping and the ode regularisation.</p>
</td></tr>
<tr><td><code id="crossv_+3A_dtilda">dtilda</code></td>
<td>
<p>vector(of length n_o) containing the gradient of warping function. This variable is only used if user want to combine warping and the ode regularisation.</p>
</td></tr>
<tr><td><code id="crossv_+3A_fold">fold</code></td>
<td>
<p>scalar indicating the folds of cross validation.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Arguments of the 'crossv' function are list of weighting parameter for ode regularisation, 'ode' class objects, 'rkhs' class objects, noisy observation, type of regularisation scheme, option of warping and the gradient of warping function. It return the interpolation for each of the ode states. The ode parameters are estimated using gradient matching, and the results are stored in the 'ode' class as the ode_par attribute.
</p>


<h3>Value</h3>

<p>return list containing :
</p>
 
<ul>
<li><p> lam - scalar containing the optimised weighting parameter. 
</p>
</li>
<li><p> ress -vector containing the cross validation error for all choices of weighting parameter.</p>
</li></ul>



<h3>Author(s)</h3>

<p>Mu Niu <a href="mailto:mu.niu@glasgow.ac.uk">mu.niu@glasgow.ac.uk</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
require(mvtnorm)
noise = 0.1  
SEED = 19537
set.seed(SEED)
## Define ode function, we use lotka-volterra model in this example. 
## we have two ode states x[1], x[2] and four ode parameters alpha, beta, gamma and delta.
LV_fun = function(t,x,par_ode){
  alpha=par_ode[1]
  beta=par_ode[2]
  gamma=par_ode[3]
  delta=par_ode[4]
  as.matrix( c( alpha*x[1]-beta*x[2]*x[1] , -gamma*x[2]+delta*x[1]*x[2] ) )
}
## Define the gradient of ode function against ode parameters 
## df/dalpha,  df/dbeta, df/dgamma, df/ddelta where f is the differential equation.
LV_grlNODE= function(par,grad_ode,y_p,z_p) { 
alpha = par[1]; beta= par[2]; gamma = par[3]; delta = par[4]
dres= c(0)
dres[1] = sum( -2*( z_p[1,]-grad_ode[1,])*y_p[1,]*alpha ) 
dres[2] = sum( 2*( z_p[1,]-grad_ode[1,])*y_p[2,]*y_p[1,]*beta)
dres[3] = sum( 2*( z_p[2,]-grad_ode[2,])*gamma*y_p[2,] )
dres[4] = sum( -2*( z_p[2,]-grad_ode[2,])*y_p[2,]*y_p[1,]*delta)
dres
}

## create a ode class object
kkk0 = ode$new(2,fun=LV_fun,grfun=LV_grlNODE)
## set the initial values for each state at time zero.
xinit = as.matrix(c(0.5,1))
## set the time interval for the ode numerical solver.
tinterv = c(0,6)
## solve the ode numerically using predefined ode parameters. alpha=1, beta=1, gamma=4, delta=1.
kkk0$solve_ode(c(1,1,4,1),xinit,tinterv) 

## Add noise to the numerical solution of the ode model and use it as the noisy observation.
n_o = max( dim( kkk0$y_ode) )
t_no = kkk0$t
y_no =  t(kkk0$y_ode) + rmvnorm(n_o,c(0,0),noise*diag(2))

## create a ode class object by using the simulation data we created from the Ode numerical solver.
## If users have experiment data, they can replace the simulation data with the experiment data.
## set initial value of Ode parameters.
init_par = rep(c(0.1),4)
init_yode = t(y_no)
init_t = t_no
kkk = ode$new(1,fun=LV_fun,grfun=LV_grlNODE,t=init_t,ode_par= init_par, y_ode=init_yode )

## The following examples with CPU or elapsed time &gt; 10s

## Use function 'rkg' to estimate the Ode parameters.
ktype ='rbf'
rkgres = rkg(kkk,y_no,ktype)
bbb = rkgres$bbb

############# gradient matching + third step
crtype='i'
## using cross validation to estimate the weighting parameters of the ode regularisation 
lam=c(1e-4,1e-5)
lamil1 = crossv(lam,kkk,bbb,crtype,y_no)
lambdai1=lamil1[[1]]

## End(Not run)
</code></pre>

<hr>
<h2 id='diagnostic'>The 'diagnostic' function</h2><span id='topic+diagnostic'></span>

<h3>Description</h3>

<p>This function is used to perform diagnostic procedure to compute the residual and make diagnostic plots.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>diagnostic(infer_list, index, type, qq_plot)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="diagnostic_+3A_infer_list">infer_list</code></td>
<td>
<p>a list of inference results including ode objects and inference objects.</p>
</td></tr>
<tr><td><code id="diagnostic_+3A_index">index</code></td>
<td>
<p>the index of the ode states which the user want to do the diagnostic analysis.</p>
</td></tr>
<tr><td><code id="diagnostic_+3A_type">type</code></td>
<td>
<p>character containing the type of inference methods. User can choose 'rkg', 'third', or 'warp'.</p>
</td></tr>
<tr><td><code id="diagnostic_+3A_qq_plot">qq_plot</code></td>
<td>
<p>boolean variable, enable or disable the plotting function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Arguments of the 'diagnostic' function are inference list , inference type, a list of interpolations for each of the ode state from gradient matching, and . It returns a vector of the median absolute standard deviations for each ode state.
</p>


<h3>Value</h3>

<p>return list containing :
</p>
 
<ul>
<li><p> residual - vector containing residual.  
</p>
</li>
<li><p> interp - vector containing interpolation. </p>
</li></ul>



<h3>Author(s)</h3>

<p>Mu Niu <a href="mailto:mu.niu@glasgow.ac.uk">mu.niu@glasgow.ac.uk</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
require(mvtnorm)
set.seed(SEED);  SEED = 19537
FN_fun &lt;- function(t, x, par_ode) {
a = par_ode[1]
b = par_ode[2]
c = par_ode[3]
as.matrix(c(c*(x[1]-x[1]^3/3 + x[2]),-1/c*(x[1]-a+b*x[2])))
}

solveOde = ode$new(sample=2,fun=FN_fun)
xinit = as.matrix(c(-1,-1))
tinterv = c(0,10)
solveOde$solve_ode(par_ode=c(0.2,0.2,3),xinit,tinterv)

n_o = max(dim(solveOde$y_ode))
noise = 0.01 
y_no = t(solveOde$y_ode)+rmvnorm(n_o,c(0,0),noise*diag(2))
t_no = solveOde$t

odem = ode$new(fun=FN_fun,grfun=NULL,t=t_no,ode_par=rep(c(0.1),3),y_ode=t(y_no))
ktype = 'rbf'
rkgres = rkg(odem,y_no,ktype)
rkgdiag = diagnostic( rkgres,1,'rkg',qq_plot=FALSE )

## End(Not run)
</code></pre>

<hr>
<h2 id='Kernel'>The 'Kernel' class object</h2><span id='topic+Kernel'></span>

<h3>Description</h3>

<p>This a abstract class     provide the kernel function and the 1st order derivative of rbf kernel function.
</p>


<h3>Format</h3>

<p><code><a href="R6.html#topic+R6Class">R6Class</a></code> object.
</p>


<h3>Value</h3>

<p>an  <code><a href="R6.html#topic+R6Class">R6Class</a></code> object which can be used for the rkhs interpolation.
</p>


<h3>Methods</h3>


<dl>
<dt><code>kern(t1,t2)</code></dt><dd><p>This method is used to calculate the kernel function given two one dimensional real inputs.</p>
</dd>   
<dt><code>dkd_kpar(t1,t2)</code></dt><dd><p>This method is used to calculate the gradient of kernel function against the kernel hyper parameters given two one dimensional real inputs.</p>
</dd>   
<dt><code>dkdt(t1,t2)</code></dt><dd><p>This method is used to calculate the 1st order derivative of kernel function given two one dimensional real inputs.</p>
</dd> </dl>



<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>k_par</code></dt><dd><p>vector(of length n_hy) containing the hyper-parameter of kernel. n_hy is the length of kernel hyper parameters.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-Kernel-new"><code>Kernel$new()</code></a>
</p>
</li>
<li> <p><a href="#method-Kernel-greet"><code>Kernel$greet()</code></a>
</p>
</li>
<li> <p><a href="#method-Kernel-kern"><code>Kernel$kern()</code></a>
</p>
</li>
<li> <p><a href="#method-Kernel-dkd_kpar"><code>Kernel$dkd_kpar()</code></a>
</p>
</li>
<li> <p><a href="#method-Kernel-dkdt"><code>Kernel$dkdt()</code></a>
</p>
</li>
<li> <p><a href="#method-Kernel-clone"><code>Kernel$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-Kernel-new"></a>



<h4>Method <code>new()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>Kernel$new(k_par = NULL)</pre></div>


<hr>
<a id="method-Kernel-greet"></a>



<h4>Method <code>greet()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>Kernel$greet()</pre></div>


<hr>
<a id="method-Kernel-kern"></a>



<h4>Method <code>kern()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>Kernel$kern(t1, t2)</pre></div>


<hr>
<a id="method-Kernel-dkd_kpar"></a>



<h4>Method <code>dkd_kpar()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>Kernel$dkd_kpar(t1, t2)</pre></div>


<hr>
<a id="method-Kernel-dkdt"></a>



<h4>Method <code>dkdt()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>Kernel$dkdt(t1, t2)</pre></div>


<hr>
<a id="method-Kernel-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>Kernel$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Author(s)</h3>

<p>Mu Niu, <a href="mailto:mu.niu@glasgow.ac.uk">mu.niu@glasgow.ac.uk</a>
</p>

<hr>
<h2 id='MLP'>The 'MLP' class object</h2><span id='topic+MLP'></span>

<h3>Description</h3>

<p>This a R6 class. It inherits from 'kernel' class. It provides the mlp kernel function and the 1st order derivative of mlp kernel function.
</p>


<h3>Format</h3>

<p><code><a href="R6.html#topic+R6Class">R6Class</a></code> object.
</p>


<h3>Value</h3>

<p>an  <code><a href="R6.html#topic+R6Class">R6Class</a></code> object which can be used for the rkhs interpolation.
</p>


<h3>Super class</h3>

<p><code><a href="#topic+Kernel">KGode::Kernel</a></code> -&gt; <code>MLP</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-MLP-greet"><code>MLP$greet()</code></a>
</p>
</li>
<li> <p><a href="#method-MLP-set_k_par"><code>MLP$set_k_par()</code></a>
</p>
</li>
<li> <p><a href="#method-MLP-kern"><code>MLP$kern()</code></a>
</p>
</li>
<li> <p><a href="#method-MLP-dkd_kpar"><code>MLP$dkd_kpar()</code></a>
</p>
</li>
<li> <p><a href="#method-MLP-dkdt"><code>MLP$dkdt()</code></a>
</p>
</li>
<li> <p><a href="#method-MLP-clone"><code>MLP$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="KGode" data-topic="Kernel" data-id="initialize"><a href='../../KGode/html/Kernel.html#method-Kernel-initialize'><code>KGode::Kernel$initialize()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-MLP-greet"></a>



<h4>Method <code>greet()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>MLP$greet()</pre></div>


<hr>
<a id="method-MLP-set_k_par"></a>



<h4>Method <code>set_k_par()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>MLP$set_k_par(val)</pre></div>


<hr>
<a id="method-MLP-kern"></a>



<h4>Method <code>kern()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>MLP$kern(t1, t2)</pre></div>


<hr>
<a id="method-MLP-dkd_kpar"></a>



<h4>Method <code>dkd_kpar()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>MLP$dkd_kpar(t1, t2)</pre></div>


<hr>
<a id="method-MLP-dkdt"></a>



<h4>Method <code>dkdt()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>MLP$dkdt(t1, t2)</pre></div>


<hr>
<a id="method-MLP-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>MLP$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Author(s)</h3>

<p>Mu Niu, <a href="mailto:mu.niu@glasgow.ac.uk">mu.niu@glasgow.ac.uk</a>
</p>

<hr>
<h2 id='ode'>The 'ode' class object</h2><span id='topic+ode'></span>

<h3>Description</h3>

<p>This class provide all information about odes and methods for numerically solving odes.
</p>


<h3>Format</h3>

<p><code><a href="R6.html#topic+R6Class">R6Class</a></code> object.
</p>


<h3>Value</h3>

<p>an  <code><a href="R6.html#topic+R6Class">R6Class</a></code> object which can be used for gradient matching.
</p>


<h3>Methods</h3>


<dl>
<dt><code>solve_ode(par_ode,xinit,tinterv)</code></dt><dd><p>This method is used to solve ode numerically.</p>
</dd> 
<dt><code>optim_par(par,y_p,z_p)</code></dt><dd><p>This method is used to estimate ode parameters by standard gradient matching.</p>
</dd>
<dt><code>lossNODE(par,y_p,z_p)</code></dt><dd><p>This method is used to calculate the mismatching between gradient of interpolation and gradient from ode.</p>
</dd>
</dl>



<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>ode_par</code></dt><dd><p>vector(of length n_p) containing ode parameters. n_p is the number of ode parameters.</p>
</dd>
<dt><code>ode_fun</code></dt><dd><p>function containing the ode function.</p>
</dd>
<dt><code>t</code></dt><dd><p>vector(of length n_o) containing time points of observations. n_o is the length of time points.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-ode-new"><code>ode$new()</code></a>
</p>
</li>
<li> <p><a href="#method-ode-greet"><code>ode$greet()</code></a>
</p>
</li>
<li> <p><a href="#method-ode-solve_ode"><code>ode$solve_ode()</code></a>
</p>
</li>
<li> <p><a href="#method-ode-rmsfun"><code>ode$rmsfun()</code></a>
</p>
</li>
<li> <p><a href="#method-ode-gradient"><code>ode$gradient()</code></a>
</p>
</li>
<li> <p><a href="#method-ode-lossNODE"><code>ode$lossNODE()</code></a>
</p>
</li>
<li> <p><a href="#method-ode-grlNODE"><code>ode$grlNODE()</code></a>
</p>
</li>
<li> <p><a href="#method-ode-loss32NODE"><code>ode$loss32NODE()</code></a>
</p>
</li>
<li> <p><a href="#method-ode-grl32NODE"><code>ode$grl32NODE()</code></a>
</p>
</li>
<li> <p><a href="#method-ode-optim_par"><code>ode$optim_par()</code></a>
</p>
</li>
<li> <p><a href="#method-ode-clone"><code>ode$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-ode-new"></a>



<h4>Method <code>new()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>ode$new(
  sample = NULL,
  fun = NULL,
  grfun = NULL,
  t = NULL,
  ode_par = NULL,
  y_ode = NULL
)</pre></div>


<hr>
<a id="method-ode-greet"></a>



<h4>Method <code>greet()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>ode$greet()</pre></div>


<hr>
<a id="method-ode-solve_ode"></a>



<h4>Method <code>solve_ode()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>ode$solve_ode(par_ode, xinit, tinterv)</pre></div>


<hr>
<a id="method-ode-rmsfun"></a>



<h4>Method <code>rmsfun()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>ode$rmsfun(par_ode, state, M1, true_par)</pre></div>


<hr>
<a id="method-ode-gradient"></a>



<h4>Method <code>gradient()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>ode$gradient(y_p, par_ode)</pre></div>


<hr>
<a id="method-ode-lossNODE"></a>



<h4>Method <code>lossNODE()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>ode$lossNODE(par, y_p, z_p)</pre></div>


<hr>
<a id="method-ode-grlNODE"></a>



<h4>Method <code>grlNODE()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>ode$grlNODE(par, y_p, z_p)</pre></div>


<hr>
<a id="method-ode-loss32NODE"></a>



<h4>Method <code>loss32NODE()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>ode$loss32NODE(par, y_p, z_p)</pre></div>


<hr>
<a id="method-ode-grl32NODE"></a>



<h4>Method <code>grl32NODE()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>ode$grl32NODE(par, y_p, z_p)</pre></div>


<hr>
<a id="method-ode-optim_par"></a>



<h4>Method <code>optim_par()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>ode$optim_par(par, y_p, z_p)</pre></div>


<hr>
<a id="method-ode-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>ode$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Author(s)</h3>

<p>Mu Niu, <a href="mailto:mu.niu@glasgow.ac.uk">mu.niu@glasgow.ac.uk</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>noise = 0.1  ## set the variance of noise
SEED = 19537
set.seed(SEED)
## Define ode function, we use lotka-volterra model in this example. 
## we have two ode states x[1], x[2] and four ode parameters alpha, beta, gamma and delta.
LV_fun = function(t,x,par_ode){
  alpha=par_ode[1]
  beta=par_ode[2]
  gamma=par_ode[3]
  delta=par_ode[4]
  as.matrix( c( alpha*x[1]-beta*x[2]*x[1] , -gamma*x[2]+delta*x[1]*x[2] ) )
}
## Define the gradient of ode function against ode parameters 
## df/dalpha,  df/dbeta, df/dgamma, df/ddelta where f is the differential equation.
LV_grlNODE= function(par,grad_ode,y_p,z_p) { 
alpha = par[1]; beta= par[2]; gamma = par[3]; delta = par[4]
dres= c(0)
dres[1] = sum( -2*( z_p[1,]-grad_ode[1,])*y_p[1,]*alpha ) 
dres[2] = sum( 2*( z_p[1,]-grad_ode[1,])*y_p[2,]*y_p[1,]*beta)
dres[3] = sum( 2*( z_p[2,]-grad_ode[2,])*gamma*y_p[2,] )
dres[4] = sum( -2*( z_p[2,]-grad_ode[2,])*y_p[2,]*y_p[1,]*delta)
dres
}

## create a ode class object
kkk0 = ode$new(2,fun=LV_fun,grfun=LV_grlNODE)
## set the initial values for each state at time zero.
xinit = as.matrix(c(0.5,1))
## set the time interval for the ode numerical solver.
tinterv = c(0,6)
## solve the ode numerically using predefined ode parameters. alpha=1, beta=1, gamma=4, delta=1.
kkk0$solve_ode(c(1,1,4,1),xinit,tinterv) 

## Create another ode class object by using the simulation data from the ode numerical solver.
## If users have experiment data, they can replace the simulation data with the experiment data.
## set initial values for ode parameters.
init_par = rep(c(0.1),4)
init_yode = kkk0$y_ode
init_t = kkk0$t
kkk = ode$new(1,fun=LV_fun,grfun=LV_grlNODE,t=init_t,ode_par= init_par, y_ode=init_yode )

</code></pre>

<hr>
<h2 id='RBF'>The 'RBF' class object</h2><span id='topic+RBF'></span>

<h3>Description</h3>

<p>This a R6 class. It inherits from 'kernel' class. It provides the rbf kernel function and the 1st order derivative of rbf kernel function.
</p>


<h3>Format</h3>

<p><code><a href="R6.html#topic+R6Class">R6Class</a></code> object.
</p>


<h3>Value</h3>

<p>an  <code><a href="R6.html#topic+R6Class">R6Class</a></code> object which can be used for the rkhs interpolation.
</p>


<h3>Super class</h3>

<p><code><a href="#topic+Kernel">KGode::Kernel</a></code> -&gt; <code>RBF</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-RBF-greet"><code>RBF$greet()</code></a>
</p>
</li>
<li> <p><a href="#method-RBF-set_k_par"><code>RBF$set_k_par()</code></a>
</p>
</li>
<li> <p><a href="#method-RBF-kern"><code>RBF$kern()</code></a>
</p>
</li>
<li> <p><a href="#method-RBF-dkd_kpar"><code>RBF$dkd_kpar()</code></a>
</p>
</li>
<li> <p><a href="#method-RBF-dkdt"><code>RBF$dkdt()</code></a>
</p>
</li>
<li> <p><a href="#method-RBF-clone"><code>RBF$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="KGode" data-topic="Kernel" data-id="initialize"><a href='../../KGode/html/Kernel.html#method-Kernel-initialize'><code>KGode::Kernel$initialize()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-RBF-greet"></a>



<h4>Method <code>greet()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>RBF$greet()</pre></div>


<hr>
<a id="method-RBF-set_k_par"></a>



<h4>Method <code>set_k_par()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>RBF$set_k_par(val)</pre></div>


<hr>
<a id="method-RBF-kern"></a>



<h4>Method <code>kern()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>RBF$kern(t1, t2)</pre></div>


<hr>
<a id="method-RBF-dkd_kpar"></a>



<h4>Method <code>dkd_kpar()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>RBF$dkd_kpar(t1, t2)</pre></div>


<hr>
<a id="method-RBF-dkdt"></a>



<h4>Method <code>dkdt()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>RBF$dkdt(t1, t2)</pre></div>


<hr>
<a id="method-RBF-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>RBF$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Author(s)</h3>

<p>Mu Niu, <a href="mailto:mu.niu@glasgow.ac.uk">mu.niu@glasgow.ac.uk</a>
</p>

<hr>
<h2 id='rkg'>The 'rkg' function</h2><span id='topic+rkg'></span>

<h3>Description</h3>

<p>This function is used to create 'rkhs' class object and estimate ode parameters using standard gradient matching.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rkg(kkk, y_no, ktype)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rkg_+3A_kkk">kkk</code></td>
<td>
<p>ode class object.</p>
</td></tr>
<tr><td><code id="rkg_+3A_y_no">y_no</code></td>
<td>
<p>matrix(of size n_s*n_o) containing noisy observations. The row(of length n_s) represent the ode states and the column(of length n_o) represents the time points.</p>
</td></tr>
<tr><td><code id="rkg_+3A_ktype">ktype</code></td>
<td>
<p>character containing kernel type. User can choose 'rbf' or 'mlp' kernel.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Arguments of the 'rkg' function are 'ode' class, noisy observation, and kernel type. It return the interpolation for each of the ode states. The Ode parameters are estimated using gradient matching, and the results are stored in the 'ode' class as the ode_par attribute.
</p>


<h3>Value</h3>

<p>return list containing :
</p>
 
<ul>
<li><p> intp - list containing interpolation for each ode state.  
</p>
</li>
<li><p> bbb - rkhs class objects for each ode state. </p>
</li></ul>



<h3>Author(s)</h3>

<p>Mu Niu <a href="mailto:mu.niu@glasgow.ac.uk">mu.niu@glasgow.ac.uk</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
require(mvtnorm)
noise = 0.1  ## set the variance of noise
SEED = 19537
set.seed(SEED)
## Define ode function, we use lotka-volterra model in this example. 
## we have two ode states x[1], x[2] and four ode parameters alpha, beta, gamma and delta.
LV_fun = function(t,x,par_ode){
  alpha=par_ode[1]
  beta=par_ode[2]
  gamma=par_ode[3]
  delta=par_ode[4]
  as.matrix( c( alpha*x[1]-beta*x[2]*x[1] , -gamma*x[2]+delta*x[1]*x[2] ) )
}
## Define the gradient of ode function against ode parameters 
## df/dalpha,  df/dbeta, df/dgamma, df/ddelta where f is the differential equation.
LV_grlNODE= function(par,grad_ode,y_p,z_p) { 
alpha = par[1]; beta= par[2]; gamma = par[3]; delta = par[4]
dres= c(0)
dres[1] = sum( -2*( z_p[1,]-grad_ode[1,])*y_p[1,]*alpha ) 
dres[2] = sum( 2*( z_p[1,]-grad_ode[1,])*y_p[2,]*y_p[1,]*beta)
dres[3] = sum( 2*( z_p[2,]-grad_ode[2,])*gamma*y_p[2,] )
dres[4] = sum( -2*( z_p[2,]-grad_ode[2,])*y_p[2,]*y_p[1,]*delta)
dres
}

## create a ode class object
kkk0 = ode$new(2,fun=LV_fun,grfun=LV_grlNODE)
## set the initial values for each state at time zero.
xinit = as.matrix(c(0.5,1))
## set the time interval for the ode numerical solver.
tinterv = c(0,6)
## solve the ode numerically using predefined ode parameters. alpha=1, beta=1, gamma=4, delta=1.
kkk0$solve_ode(c(1,1,4,1),xinit,tinterv) 

## Add noise to the numerical solution of the ode model and use it as the noisy observation.
n_o = max( dim( kkk0$y_ode) )
t_no = kkk0$t
y_no =  t(kkk0$y_ode) + rmvnorm(n_o,c(0,0),noise*diag(2))

## Create a ode class object by using the simulation data we created from the ode numerical solver.
## If users have experiment data, they can replace the simulation data with the experiment data.
## Set initial value of ode parameters.
init_par = rep(c(0.1),4)
init_yode = t(y_no)
init_t = t_no
kkk = ode$new(1,fun=LV_fun,grfun=LV_grlNODE,t=init_t,ode_par= init_par, y_ode=init_yode )

## The following examples with CPU or elapsed time &gt; 10s

##Use function 'rkg' to estimate the ode parameters. The standard gradient matching method is coded
##in the the 'rkg' function. The parameter estimations are stored in the returned vector of 'rkg'.
## Choose a kernel type for 'rkhs' interpolation. Two options are provided 'rbf' and 'mlp'. 
ktype ='rbf'
rkgres = rkg(kkk,y_no,ktype)
## show the results of ode parameter estimation using the standard gradient matching
kkk$ode_par

## End(Not run)
</code></pre>

<hr>
<h2 id='rkg3'>The 'rkg3' class object</h2><span id='topic+rkg3'></span>

<h3>Description</h3>

<p>This class provides advanced gradient matching method by using the ode as a regularizer.
</p>


<h3>Format</h3>

<p><code><a href="R6.html#topic+R6Class">R6Class</a></code> object.
</p>


<h3>Value</h3>

<p>an  <code><a href="R6.html#topic+R6Class">R6Class</a></code> object which can be used for improving ode parameters estimation by using ode as a regularizer.
</p>


<h3>Methods</h3>


<dl>
<dt><code>iterate(iter,innerloop,lamb)</code></dt><dd><p>Iteratively updating ode parameters and interpolation regression coefficients.</p>
</dd> 
<dt><code>witerate(iter,innerloop,dtilda,lamb)</code></dt><dd><p>Iteratively updating ode parameters and the warped interpolation regression coefficients.</p>
</dd>  
<dt><code>full(par,lam)</code></dt><dd><p>Updating ode parameters and rkhs interpolation regression coefficients simultaneously. This method is slow but guarantee convergence.</p>
</dd> </dl>



<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>rk</code></dt><dd><p>the 'rkhs' class object containing the interpolation information for each state of the ode.</p>
</dd>
<dt><code>ode_m</code></dt><dd><p>the 'ode' class object containing the information about the odes.</p>
</dd>
</dl>

</div>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>ode_m</code></dt><dd><p>the 'ode' class object containing the information about the odes.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-rkg3-new"><code>rkg3$new()</code></a>
</p>
</li>
<li> <p><a href="#method-rkg3-greet"><code>rkg3$greet()</code></a>
</p>
</li>
<li> <p><a href="#method-rkg3-add"><code>rkg3$add()</code></a>
</p>
</li>
<li> <p><a href="#method-rkg3-iterate"><code>rkg3$iterate()</code></a>
</p>
</li>
<li> <p><a href="#method-rkg3-witerate"><code>rkg3$witerate()</code></a>
</p>
</li>
<li> <p><a href="#method-rkg3-full"><code>rkg3$full()</code></a>
</p>
</li>
<li> <p><a href="#method-rkg3-wfull"><code>rkg3$wfull()</code></a>
</p>
</li>
<li> <p><a href="#method-rkg3-opfull"><code>rkg3$opfull()</code></a>
</p>
</li>
<li> <p><a href="#method-rkg3-wopfull"><code>rkg3$wopfull()</code></a>
</p>
</li>
<li> <p><a href="#method-rkg3-cross"><code>rkg3$cross()</code></a>
</p>
</li>
<li> <p><a href="#method-rkg3-fullos"><code>rkg3$fullos()</code></a>
</p>
</li>
<li> <p><a href="#method-rkg3-clone"><code>rkg3$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-rkg3-new"></a>



<h4>Method <code>new()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>rkg3$new(rk = NULL, odem = NULL)</pre></div>


<hr>
<a id="method-rkg3-greet"></a>



<h4>Method <code>greet()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>rkg3$greet()</pre></div>


<hr>
<a id="method-rkg3-add"></a>



<h4>Method <code>add()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>rkg3$add(x)</pre></div>


<hr>
<a id="method-rkg3-iterate"></a>



<h4>Method <code>iterate()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>rkg3$iterate(iter, innerloop, lamb)</pre></div>


<hr>
<a id="method-rkg3-witerate"></a>



<h4>Method <code>witerate()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>rkg3$witerate(iter, innerloop, dtilda, lamb)</pre></div>


<hr>
<a id="method-rkg3-full"></a>



<h4>Method <code>full()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>rkg3$full(par, lam)</pre></div>


<hr>
<a id="method-rkg3-wfull"></a>



<h4>Method <code>wfull()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>rkg3$wfull(par, lam, dtilda)</pre></div>


<hr>
<a id="method-rkg3-opfull"></a>



<h4>Method <code>opfull()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>rkg3$opfull(lam)</pre></div>


<hr>
<a id="method-rkg3-wopfull"></a>



<h4>Method <code>wopfull()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>rkg3$wopfull(lam, dtilda)</pre></div>


<hr>
<a id="method-rkg3-cross"></a>



<h4>Method <code>cross()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>rkg3$cross(lam, testX, testY)</pre></div>


<hr>
<a id="method-rkg3-fullos"></a>



<h4>Method <code>fullos()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>rkg3$fullos(par)</pre></div>


<hr>
<a id="method-rkg3-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>rkg3$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Author(s)</h3>

<p>Mu Niu, <a href="mailto:mu.niu@glasgow.ac.uk">mu.niu@glasgow.ac.uk</a>
</p>

<hr>
<h2 id='rkhs'>The 'rkhs' class object</h2><span id='topic+rkhs'></span>

<h3>Description</h3>

<p>This class provide the interpolation methods using reproducing kernel Hilbert space.
</p>


<h3>Format</h3>

<p><code><a href="R6.html#topic+R6Class">R6Class</a></code> object.
</p>


<h3>Value</h3>

<p>an  <code><a href="R6.html#topic+R6Class">R6Class</a></code> object which can be used for doing interpolation using reproducing kernel Hilbert space.
</p>


<h3>Methods</h3>


<dl>
<dt><code>predict()</code></dt><dd><p>This method is used to make prediction on given time points</p>
</dd> 	
<dt><code>skcross()</code></dt><dd><p>This method is used to do cross-validation to estimate the weighting parameter lambda of L^2 norm.</p>
</dd> </dl>



<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>y</code></dt><dd><p>matrix(of size n_s*n_o) containing observation.</p>
</dd>
<dt><code>t</code></dt><dd><p>vector(of length n_o) containing time points for observation.</p>
</dd>
<dt><code>b</code></dt><dd><p>vector(of length n_o) containing coefficients of kernel or basis functions.</p>
</dd>
<dt><code>lambda</code></dt><dd><p>scalar containing the weighting parameter for L2 norm of the reproducing kernel Hilbert space.</p>
</dd>
<dt><code>ker</code></dt><dd><p>kernel class object containing kernel.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-rkhs-new"><code>rkhs$new()</code></a>
</p>
</li>
<li> <p><a href="#method-rkhs-greet"><code>rkhs$greet()</code></a>
</p>
</li>
<li> <p><a href="#method-rkhs-showker"><code>rkhs$showker()</code></a>
</p>
</li>
<li> <p><a href="#method-rkhs-predict"><code>rkhs$predict()</code></a>
</p>
</li>
<li> <p><a href="#method-rkhs-predictT"><code>rkhs$predictT()</code></a>
</p>
</li>
<li> <p><a href="#method-rkhs-lossRK"><code>rkhs$lossRK()</code></a>
</p>
</li>
<li> <p><a href="#method-rkhs-grlossRK"><code>rkhs$grlossRK()</code></a>
</p>
</li>
<li> <p><a href="#method-rkhs-numgrad"><code>rkhs$numgrad()</code></a>
</p>
</li>
<li> <p><a href="#method-rkhs-skcross"><code>rkhs$skcross()</code></a>
</p>
</li>
<li> <p><a href="#method-rkhs-mkcross"><code>rkhs$mkcross()</code></a>
</p>
</li>
<li> <p><a href="#method-rkhs-loss11"><code>rkhs$loss11()</code></a>
</p>
</li>
<li> <p><a href="#method-rkhs-grloss11"><code>rkhs$grloss11()</code></a>
</p>
</li>
<li> <p><a href="#method-rkhs-clone"><code>rkhs$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-rkhs-new"></a>



<h4>Method <code>new()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>rkhs$new(y = NULL, t = NULL, b = NULL, lambda = NULL, ker = NULL)</pre></div>


<hr>
<a id="method-rkhs-greet"></a>



<h4>Method <code>greet()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>rkhs$greet()</pre></div>


<hr>
<a id="method-rkhs-showker"></a>



<h4>Method <code>showker()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>rkhs$showker()</pre></div>


<hr>
<a id="method-rkhs-predict"></a>



<h4>Method <code>predict()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>rkhs$predict()</pre></div>


<hr>
<a id="method-rkhs-predictT"></a>



<h4>Method <code>predictT()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>rkhs$predictT(testT)</pre></div>


<hr>
<a id="method-rkhs-lossRK"></a>



<h4>Method <code>lossRK()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>rkhs$lossRK(par, tl1, y_d, jitter)</pre></div>


<hr>
<a id="method-rkhs-grlossRK"></a>



<h4>Method <code>grlossRK()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>rkhs$grlossRK(par, tl1, y_d, jitter)</pre></div>


<hr>
<a id="method-rkhs-numgrad"></a>



<h4>Method <code>numgrad()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>rkhs$numgrad(par, tl1, y_d, jitter)</pre></div>


<hr>
<a id="method-rkhs-skcross"></a>



<h4>Method <code>skcross()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>rkhs$skcross(init, bounded)</pre></div>


<hr>
<a id="method-rkhs-mkcross"></a>



<h4>Method <code>mkcross()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>rkhs$mkcross(init)</pre></div>


<hr>
<a id="method-rkhs-loss11"></a>



<h4>Method <code>loss11()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>rkhs$loss11(par, tl1, y_d, jitter)</pre></div>


<hr>
<a id="method-rkhs-grloss11"></a>



<h4>Method <code>grloss11()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>rkhs$grloss11(par, tl1, y_d, jitter)</pre></div>


<hr>
<a id="method-rkhs-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>rkhs$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Author(s)</h3>

<p>Mu Niu, <a href="mailto:mu.niu@glasgow.ac.uk">mu.niu@glasgow.ac.uk</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
require(mvtnorm)
noise = 0.1  ## set the variance of noise
SEED = 19537
set.seed(SEED)
## Define ode function, we use lotka-volterra model in this example. 
## we have two ode states x[1], x[2] and four ode parameters alpha, beta, gamma and delta.
LV_fun = function(t,x,par_ode){
  alpha=par_ode[1]
  beta=par_ode[2]
  gamma=par_ode[3]
  delta=par_ode[4]
  as.matrix( c( alpha*x[1]-beta*x[2]*x[1] , -gamma*x[2]+delta*x[1]*x[2] ) )
}
## Define the gradient of ode function against ode parameters 
## df/dalpha,  df/dbeta, df/dgamma, df/ddelta where f is the differential equation.
LV_grlNODE= function(par,grad_ode,y_p,z_p) { 
alpha = par[1]; beta= par[2]; gamma = par[3]; delta = par[4]
dres= c(0)
dres[1] = sum( -2*( z_p[1,]-grad_ode[1,])*y_p[1,]*alpha ) 
dres[2] = sum( 2*( z_p[1,]-grad_ode[1,])*y_p[2,]*y_p[1,]*beta)
dres[3] = sum( 2*( z_p[2,]-grad_ode[2,])*gamma*y_p[2,] )
dres[4] = sum( -2*( z_p[2,]-grad_ode[2,])*y_p[2,]*y_p[1,]*delta)
dres
}

## create a ode class object
kkk0 = ode$new(2,fun=LV_fun,grfun=LV_grlNODE)
## set the initial values for each state at time zero.
xinit = as.matrix(c(0.5,1))
## set the time interval for the ode numerical solver.
tinterv = c(0,6)
## solve the ode numerically using predefined ode parameters. alpha=1, beta=1, gamma=4, delta=1.
kkk0$solve_ode(c(1,1,4,1),xinit,tinterv) 

## Add noise to the numerical solution of the ode model and use it as the noisy observation.
n_o = max( dim( kkk0$y_ode) )
t_no = kkk0$t
y_no =  t(kkk0$y_ode) + rmvnorm(n_o,c(0,0),noise*diag(2))

## Create a ode class object by using the simulation data we created from the ode numerical solver.
## If users have experiment data, they can replace the simulation data with the experiment data.
## Set initial value of ode parameters.
init_par = rep(c(0.1),4)
init_yode = t(y_no)
init_t = t_no
kkk = ode$new(1,fun=LV_fun,grfun=LV_grlNODE,t=init_t,ode_par= init_par, y_ode=init_yode )

## The following examples with CPU or elapsed time &gt; 5s
####### rkhs interpolation for the 1st state of ode using 'rbf' kernel
### set initial value of length scale of rbf kernel
initlen = 1
aker = RBF$new(initlen)
bbb = rkhs$new(t(y_no)[1,],t_no,rep(1,n_o),1,aker)
## optimise lambda by cross-validation
## initial value of lambda
initlam = 2
bbb$skcross( initlam ) 

## make prediction using the 'predict()' method of 'rkhs' class and plot against the time.
plot(t_no,bbb$predict()$pred)

## End(Not run)
</code></pre>

<hr>
<h2 id='third'>The 'third' function</h2><span id='topic+third'></span>

<h3>Description</h3>

<p>This function is used to create 'rk3g' class objects and estimate ode parameters using ode regularised gradient matching.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>third(lam, kkk, bbb, crtype, woption, dtilda)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="third_+3A_lam">lam</code></td>
<td>
<p>scalar containing the weighting parameter of ode regularisation.</p>
</td></tr>
<tr><td><code id="third_+3A_kkk">kkk</code></td>
<td>
<p>'ode' class object containing all information about the odes.</p>
</td></tr>
<tr><td><code id="third_+3A_bbb">bbb</code></td>
<td>
<p>list of 'rkhs' class object containing the interpolation for all ode states.</p>
</td></tr>
<tr><td><code id="third_+3A_crtype">crtype</code></td>
<td>
<p>character containing the optimisation scheme type. User can choose 'i' or '3'. 'i' is for fast iterative scheme and '3' for optimising the ode parameters and interpolation coefficients simultaneously.</p>
</td></tr>
<tr><td><code id="third_+3A_woption">woption</code></td>
<td>
<p>character containing the indication of using warping. If the warping scheme is done before using the ode regularisation, user can choose 'w' otherwise just leave this option empty.</p>
</td></tr>
<tr><td><code id="third_+3A_dtilda">dtilda</code></td>
<td>
<p>vector(of length n_o) containing the gradient of warping function. This variable is only used if user want to combine warping and the ode regularisation.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Arguments of the 'third' function are ode regularisation weighting parameter, 'ode' class objects, 'rkhs' class objects, noisy observation, type of regularisation scheme, option of warping and the gradient of warping function. It return the interpolation for each of the ode states. The ode parameters are estimated using gradient matching, and the results are stored in the ode_par attribute of 'ode' class.
</p>


<h3>Value</h3>

<p>return list containing :
</p>
 
<ul>
<li><p> oppar - vector(of length n_p) containing the ode parameters estimation. n_p is the length of ode parameters. 
</p>
</li>
<li><p> rk3 - list of 'rkhs' class object containing the updated interpolation results.</p>
</li></ul>



<h3>Author(s)</h3>

<p>Mu Niu <a href="mailto:mu.niu@glasgow.ac.uk">mu.niu@glasgow.ac.uk</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
require(mvtnorm)
noise = 0.1  
SEED = 19537
set.seed(SEED)
## Define ode function, we use lotka-volterra model in this example. 
## we have two ode states x[1], x[2] and four ode parameters alpha, beta, gamma and delta.
LV_fun = function(t,x,par_ode){
  alpha=par_ode[1]
  beta=par_ode[2]
  gamma=par_ode[3]
  delta=par_ode[4]
  as.matrix( c( alpha*x[1]-beta*x[2]*x[1] , -gamma*x[2]+delta*x[1]*x[2] ) )
}
## Define the gradient of ode function against ode parameters 
## df/dalpha,  df/dbeta, df/dgamma, df/ddelta where f is the differential equation.
LV_grlNODE= function(par,grad_ode,y_p,z_p) { 
alpha = par[1]; beta= par[2]; gamma = par[3]; delta = par[4]
dres= c(0)
dres[1] = sum( -2*( z_p[1,]-grad_ode[1,])*y_p[1,]*alpha ) 
dres[2] = sum( 2*( z_p[1,]-grad_ode[1,])*y_p[2,]*y_p[1,]*beta)
dres[3] = sum( 2*( z_p[2,]-grad_ode[2,])*gamma*y_p[2,] )
dres[4] = sum( -2*( z_p[2,]-grad_ode[2,])*y_p[2,]*y_p[1,]*delta)
dres
}

## create a ode class object
kkk0 = ode$new(2,fun=LV_fun,grfun=LV_grlNODE)
## set the initial values for each state at time zero.
xinit = as.matrix(c(0.5,1))
## set the time interval for the ode numerical solver.
tinterv = c(0,6)
## solve the ode numerically using predefined ode parameters. alpha=1, beta=1, gamma=4, delta=1.
kkk0$solve_ode(c(1,1,4,1),xinit,tinterv) 

## Add noise to the numerical solution of the ode model and use it as the noisy observation.
n_o = max( dim( kkk0$y_ode) )
t_no = kkk0$t
y_no =  t(kkk0$y_ode) + rmvnorm(n_o,c(0,0),noise*diag(2))

## create a ode class object by using the simulation data we created from the ode numerical solver.
## If users have experiment data, they can replace the simulation data with the experiment data.
## set initial value of Ode parameters.
init_par = rep(c(0.1),4)
init_yode = t(y_no)
init_t = t_no
kkk = ode$new(1,fun=LV_fun,grfun=LV_grlNODE,t=init_t,ode_par= init_par, y_ode=init_yode )

## The following examples with CPU or elapsed time &gt; 10s

## Use function 'rkg' to estimate the ode parameters.
ktype ='rbf'
rkgres = rkg(kkk,y_no,ktype)
bbb = rkgres$bbb

############# gradient matching + ode regularisation
crtype='i'
## using cross validation to estimate the weighting parameters of the ode regularisation 
lam=c(1e-4,1e-5)
lamil1 = crossv(lam,kkk,bbb,crtype,y_no)
lambdai1=lamil1[[1]]

## estimate ode parameters using gradient matching and ode regularisation
res = third(lambdai1,kkk,bbb,crtype)
## display the ode parameter estimation.
res$oppar

## End(Not run)
</code></pre>

<hr>
<h2 id='Warp'>The 'Warp' class object</h2><span id='topic+Warp'></span>

<h3>Description</h3>

<p>This class provide the warping method which can be used to warp the original signal to sinusoidal like signal.
</p>


<h3>Format</h3>

<p><code><a href="R6.html#topic+R6Class">R6Class</a></code> object.
</p>


<h3>Value</h3>

<p>an  <code><a href="R6.html#topic+R6Class">R6Class</a></code> object which can be used for doing interpolation using reproducing kernel Hilbert space.
</p>


<h3>Methods</h3>


<dl>
<dt><code>warpsin(len ,lop,p0,eps)</code></dt><dd><p>This method is used to warp the initial interpolation into a sinusoidal shape.</p>
</dd>   
<dt><code>slowWarp(lens,peod,eps)</code></dt><dd><p>This method is used to find the optimised initial hyper parameters for the sigmoid basis function for each ode states.</p>
</dd>
<dt><code> warpLossLen(par,lam,p0,eps)</code></dt><dd><p>This method is used to implement the loss function for warping. It is called by the 'warpSin' function.</p>
</dd> </dl>



<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>y</code></dt><dd><p>matrix(of size n_s*n_o) containing observation.</p>
</dd>
<dt><code>t</code></dt><dd><p>vector(of length n_o) containing time points for observation.</p>
</dd>
<dt><code>b</code></dt><dd><p>vector(of length n_o) containing coefficients of kernel or basis functions.</p>
</dd>
<dt><code>lambda</code></dt><dd><p>scalar containing the weighting parameter for penalising the length of warped time span.</p>
</dd>
<dt><code>ker</code></dt><dd><p>kernel class object containing sigmoid basis function.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-Warp-new"><code>Warp$new()</code></a>
</p>
</li>
<li> <p><a href="#method-Warp-greet"><code>Warp$greet()</code></a>
</p>
</li>
<li> <p><a href="#method-Warp-showker"><code>Warp$showker()</code></a>
</p>
</li>
<li> <p><a href="#method-Warp-warpLoss"><code>Warp$warpLoss()</code></a>
</p>
</li>
<li> <p><a href="#method-Warp-warpLossLen"><code>Warp$warpLossLen()</code></a>
</p>
</li>
<li> <p><a href="#method-Warp-warpSin"><code>Warp$warpSin()</code></a>
</p>
</li>
<li> <p><a href="#method-Warp-slowWarp"><code>Warp$slowWarp()</code></a>
</p>
</li>
<li> <p><a href="#method-Warp-clone"><code>Warp$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-Warp-new"></a>



<h4>Method <code>new()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>Warp$new(y = NULL, t = NULL, b = NULL, lambda = NULL, ker = NULL)</pre></div>


<hr>
<a id="method-Warp-greet"></a>



<h4>Method <code>greet()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>Warp$greet()</pre></div>


<hr>
<a id="method-Warp-showker"></a>



<h4>Method <code>showker()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>Warp$showker()</pre></div>


<hr>
<a id="method-Warp-warpLoss"></a>



<h4>Method <code>warpLoss()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>Warp$warpLoss(par, len, p0, eps)</pre></div>


<hr>
<a id="method-Warp-warpLossLen"></a>



<h4>Method <code>warpLossLen()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>Warp$warpLossLen(par, lam, p0, eps)</pre></div>


<hr>
<a id="method-Warp-warpSin"></a>



<h4>Method <code>warpSin()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>Warp$warpSin(len, lop, p0, eps)</pre></div>


<hr>
<a id="method-Warp-slowWarp"></a>



<h4>Method <code>slowWarp()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>Warp$slowWarp(lens, p0, eps)</pre></div>


<hr>
<a id="method-Warp-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>Warp$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Author(s)</h3>

<p>Mu Niu, <a href="mailto:mu.niu@glasgow.ac.uk">mu.niu@glasgow.ac.uk</a>
</p>

<hr>
<h2 id='warpfun'>The 'warpfun' function</h2><span id='topic+warpfun'></span>

<h3>Description</h3>

<p>This function is used to produce the warping function and learning the interpolation in the warped time domain.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>warpfun(kkkrkg, bbb, peod, eps, fixlens, y_no, testData, witer)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="warpfun_+3A_kkkrkg">kkkrkg</code></td>
<td>
<p>'ode' class object.</p>
</td></tr>
<tr><td><code id="warpfun_+3A_bbb">bbb</code></td>
<td>
<p>list of 'rkhs' class object.</p>
</td></tr>
<tr><td><code id="warpfun_+3A_peod">peod</code></td>
<td>
<p>vector(of length n_s) containing the period of warped signal. n_s is the length of the ode states.</p>
</td></tr>
<tr><td><code id="warpfun_+3A_eps">eps</code></td>
<td>
<p>vector(of length n_s) containing the uncertainty level of the period. n_s is the length of the ode states.</p>
</td></tr>
<tr><td><code id="warpfun_+3A_fixlens">fixlens</code></td>
<td>
<p>vector(of length n_s) containing the initial values of the hyper parameters of sigmoid basis function.</p>
</td></tr>
<tr><td><code id="warpfun_+3A_y_no">y_no</code></td>
<td>
<p>matrix(of size n_s*n_o) containing noisy observations. The row(of length n_s) represent the ode states and the column(of length n_o) represents the time points.</p>
</td></tr>
<tr><td><code id="warpfun_+3A_testdata">testData</code></td>
<td>
<p>vector(of size n_x) containing user defined time points which will be warped by the warping function.</p>
</td></tr>
<tr><td><code id="warpfun_+3A_witer">witer</code></td>
<td>
<p>scale containing the number of iterations for optimising the hyper parameters of warping.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Arguments of the 'warpfun' function are 'ode' class, 'rkhs' class, period of warped signal, uncertainty level of the period, initial values of the hyper parameters for sigmoid basis function, noisy observations and the time points that user want to warped.
It return the interpolation for each of the ode states. The ode parameters are estimated using gradient matching, and the results are stored in the 'ode' class as the ode_par attribute.
</p>


<h3>Value</h3>

<p>return list containing :
</p>
 
<ul>
<li><p> dtilda - vector(of length n_x) containing the gradients of warping function at user defined time points.  
</p>
</li>
<li><p> bbbw - list of 'rkhs' class object containing the interpolation in warped time domain.
</p>
</li>
<li><p> wtime - vector(of length n_x) containing the warped time points.
</p>
</li>
<li><p> wfun - list of 'rkhs' class object containing information about warping function. 
</p>
</li>
<li><p> wkkk - 'ode' class object containing the result of parameter estimation using the warped signal and gradient matching.</p>
</li></ul>



<h3>Author(s)</h3>

<p>Mu Niu <a href="mailto:mu.niu@glasgow.ac.uk">mu.niu@glasgow.ac.uk</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
require(mvtnorm)
noise = 0.1  
SEED = 19537
set.seed(SEED)
## Define ode function, we use lotka-volterra model in this example. 
## we have two ode states x[1], x[2] and four ode parameters alpha, beta, gamma and delta.
LV_fun = function(t,x,par_ode){
  alpha=par_ode[1]
  beta=par_ode[2]
  gamma=par_ode[3]
  delta=par_ode[4]
  as.matrix( c( alpha*x[1]-beta*x[2]*x[1] , -gamma*x[2]+delta*x[1]*x[2] ) )
}
## Define the gradient of ode function against ode parameters 
## df/dalpha,  df/dbeta, df/dgamma, df/ddelta where f is the differential equation.
LV_grlNODE= function(par,grad_ode,y_p,z_p) { 
alpha = par[1]; beta= par[2]; gamma = par[3]; delta = par[4]
dres= c(0)
dres[1] = sum( -2*( z_p[1,]-grad_ode[1,])*y_p[1,]*alpha ) 
dres[2] = sum( 2*( z_p[1,]-grad_ode[1,])*y_p[2,]*y_p[1,]*beta)
dres[3] = sum( 2*( z_p[2,]-grad_ode[2,])*gamma*y_p[2,] )
dres[4] = sum( -2*( z_p[2,]-grad_ode[2,])*y_p[2,]*y_p[1,]*delta)
dres
}

## create a ode class object
kkk0 = ode$new(2,fun=LV_fun,grfun=LV_grlNODE)
## set the initial values for each state at time zero.
xinit = as.matrix(c(0.5,1))
## set the time interval for the ode numerical solver.
tinterv = c(0,6)
## solve the ode numerically using predefined ode parameters. alpha=1, beta=1, gamma=4, delta=1.
kkk0$solve_ode(c(1,1,4,1),xinit,tinterv) 

## Add noise to the numerical solution of the ode model and use it as the noisy observation.
n_o = max( dim( kkk0$y_ode) )
t_no = kkk0$t
y_no =  t(kkk0$y_ode) + rmvnorm(n_o,c(0,0),noise*diag(2))

## create a ode class object by using the simulation data we created from the Ode numerical solver.
## If users have experiment data, they can replace the simulation data with the experiment data.
## set initial value of Ode parameters.
init_par = rep(c(0.1),4)
init_yode = t(y_no)
init_t = t_no
kkk = ode$new(1,fun=LV_fun,grfun=LV_grlNODE,t=init_t,ode_par= init_par, y_ode=init_yode )

## The following examples with CPU or elapsed time &gt; 10s

## Use function 'rkg' to estimate the Ode parameters.
ktype ='rbf'
rkgres = rkg(kkk,y_no,ktype)
bbb = rkgres$bbb

###### warp all ode states
peod = c(6,5.3) ## the guessing period
eps= 1          ## the uncertainty level of period

###### learn the initial value of the hyper parameters of the warping basis function
fixlens=warpInitLen(peod,eps,rkgres)

kkkrkg = kkk$clone() ## make a copy of ode class objects
##learn the warping function, warp data points and do gradient matching in the warped time domain.
www = warpfun(kkkrkg,bbb,peod,eps,fixlens,y_no,kkkrkg$t)

dtilda= www$dtilda  ## gradient of warping function
bbbw = www$bbbw      ## interpolation in warped time domain
resmtest = www$wtime  ## warped time points
##display the results of parameter estimation using gradient matching in the warped time domain.
www$wkkk$ode_par       

## End(Not run)
</code></pre>

<hr>
<h2 id='warpInitLen'>The 'warpInitLen' function</h2><span id='topic+warpInitLen'></span>

<h3>Description</h3>

<p>This function is used to find the optmised initial value of the hyper parameter for the sigmoid basis function which is used for warping.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>warpInitLen(peod, eps, rkgres, lens)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="warpInitLen_+3A_peod">peod</code></td>
<td>
<p>vector(of length n_s) containing the period of warped signal. n_s is the length of the ode states.</p>
</td></tr>
<tr><td><code id="warpInitLen_+3A_eps">eps</code></td>
<td>
<p>vector(of length n_s) containing the uncertainty level of the period. n_s is the length of the ode states.</p>
</td></tr>
<tr><td><code id="warpInitLen_+3A_rkgres">rkgres</code></td>
<td>
<p>list containing interpolation and 'rkhs' class objects for all ode states.</p>
</td></tr>
<tr><td><code id="warpInitLen_+3A_lens">lens</code></td>
<td>
<p>vector(of length n_l) containing a list of hyper parameters of sigmoid basis function. n_l is the length of user defined hyper parameters of the sigmoid basis functino.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Arguments of the 'warpfun' function are 'ode' class, 'rkhs' class, period of warped signal, uncertainty level of the period, initial values of the hyper parameters for sigmoid basis function, noisy observations and the time points that user want to warped.
It return the interpolation for each of the ode states. The ode parameters are estimated using gradient matching, and the results are stored in the 'ode' class as the ode_par attribute.
</p>


<h3>Value</h3>

<p>return list containing :
</p>
 
<ul>
<li><p> wres- vector(of length n_s) contaning the optimised initial hyper parameters of sigmoid basis function for each ode states.</p>
</li></ul>



<h3>Author(s)</h3>

<p>Mu Niu <a href="mailto:mu.niu@glasgow.ac.uk">mu.niu@glasgow.ac.uk</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
require(mvtnorm)
noise = 0.1  
SEED = 19537
set.seed(SEED)
## Define ode function, we use lotka-volterra model in this example. 
## we have two ode states x[1], x[2] and four ode parameters alpha, beta, gamma and delta.
LV_fun = function(t,x,par_ode){
  alpha=par_ode[1]
  beta=par_ode[2]
  gamma=par_ode[3]
  delta=par_ode[4]
  as.matrix( c( alpha*x[1]-beta*x[2]*x[1] , -gamma*x[2]+delta*x[1]*x[2] ) )
}
## Define the gradient of ode function against ode parameters 
## df/dalpha,  df/dbeta, df/dgamma, df/ddelta where f is the differential equation.
LV_grlNODE= function(par,grad_ode,y_p,z_p) { 
alpha = par[1]; beta= par[2]; gamma = par[3]; delta = par[4]
dres= c(0)
dres[1] = sum( -2*( z_p[1,]-grad_ode[1,])*y_p[1,]*alpha ) 
dres[2] = sum( 2*( z_p[1,]-grad_ode[1,])*y_p[2,]*y_p[1,]*beta)
dres[3] = sum( 2*( z_p[2,]-grad_ode[2,])*gamma*y_p[2,] )
dres[4] = sum( -2*( z_p[2,]-grad_ode[2,])*y_p[2,]*y_p[1,]*delta)
dres
}

## create a ode class object
kkk0 = ode$new(2,fun=LV_fun,grfun=LV_grlNODE)
## set the initial values for each state at time zero.
xinit = as.matrix(c(0.5,1))
## set the time interval for the ode numerical solver.
tinterv = c(0,6)
## solve the ode numerically using predefined ode parameters. alpha=1, beta=1, gamma=4, delta=1.
kkk0$solve_ode(c(1,1,4,1),xinit,tinterv) 

## Add noise to the numerical solution of the ode model and use it as the noisy observation.
n_o = max( dim( kkk0$y_ode) )
t_no = kkk0$t
y_no =  t(kkk0$y_ode) + rmvnorm(n_o,c(0,0),noise*diag(2))

## create a ode class object by using the simulation data we created from the Ode numerical solver.
## If users have experiment data, they can replace the simulation data with the experiment data.
## set initial value of Ode parameters.
init_par = rep(c(0.1),4)
init_yode = t(y_no)
init_t = t_no
kkk = ode$new(1,fun=LV_fun,grfun=LV_grlNODE,t=init_t,ode_par= init_par, y_ode=init_yode )

## The following examples with CPU or elapsed time &gt; 10s

## Use function 'rkg' to estimate the Ode parameters.
ktype ='rbf'
rkgres = rkg(kkk,y_no,ktype)
bbb = rkgres$bbb

###### warp all ode states
peod = c(6,5.3) ## the guessing period
eps= 1          ## the uncertainty level of period

###### learn the initial value of the hyper parameters of the warping basis function
fixlens=warpInitLen(peod,eps,rkgres)

## End(Not run)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
