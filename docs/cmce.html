<!DOCTYPE html><html lang="en"><head><title>Help for package cmce</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {cmce}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#cmce-package'>
<p><code>cmce</code> is an open-source R package implementing Bayesian calibration for deterministic and stochastic simulation models.</p></a></li>
<li><a href='#calibrate'><p>Fit the calibration model.</p></a></li>
<li><a href='#getranges'><p>Get variable ranges from a design matrix.</p></a></li>
<li><a href='#gp.realize'><p>Draw an unconditional GP realization.</p></a></li>
<li><a href='#makedistlist'><p>Make list of distance matrices for calculating GP correlation matrices.</p></a></li>
<li><a href='#scaledesign'><p>Rescale a design matrix to the [0,1] hypercube.</p></a></li>
<li><a href='#unscalemat'><p>Unscale a matrix back to its original ranges.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Computer Model Calibration for Deterministic and Stochastic
Simulators</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2018-05-12</td>
</tr>
<tr>
<td>Author:</td>
<td>Matthew T. Pratola &lt;mpratola@stat.osu.edu&gt; [aut, cre, cph]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Matthew T. Pratola &lt;mpratola@stat.osu.edu&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Implements the Bayesian calibration model described
    in Pratola and Chkrebtii (2018) &lt;<a href="https://doi.org/10.5705%2Fss.202016.0403">doi:10.5705/ss.202016.0403</a>&gt; for stochastic 
    and deterministic simulators.  Additive and multiplicative discrepancy models 
    are currently supported. See <a href="http://www.matthewpratola.com/software">http://www.matthewpratola.com/software</a> for 
    more information and examples.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.2.3)</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/AGPL-3">AGPL-3</a></td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2018-05-14 14:51:54 UTC; mpratola</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2018-05-24 12:31:59 UTC</td>
</tr>
</table>
<hr>
<h2 id='cmce-package'>
<code>cmce</code> is an open-source R package implementing Bayesian calibration for deterministic and stochastic simulation models.
</h2><span id='topic+cmce-package'></span>

<h3>Description</h3>

<p><code>cmce</code> implements a Bayesian calibration model based on a dimension-reduction approach via empirical orthogonal functions.  The model generalizes the popular SVD-based approach (e.g. Higdon et al. (2008)) to a tensor-variate decomposition, enabling the calibration of both deterministic simulators and stochastic simulators.  Currently, <code>cmce</code> is a proof of concept implementation based entirely on <code>R</code> code, leaving open the possibility of future performance improvements if the codebase is moved to <code>C</code> at a later point.  It supports both the popular additive discrepancy as well as multiplicative discrepancy.  The model is fit using a Metropolis-within-Gibbs MCMC algorithm.
</p>


<h3>Details</h3>

<p>The main model fitting function in the package is <code>calibrate()</code>.  This function will return posterior samples of the calibration parameters as well as the predicted field process, predicted discrepancies and predicted calibrated simulator.  The model currently does not support predicting off the input grid and assumes that field data and simulator outputs are observed on the same input grid.  
</p>


<h3>Author(s)</h3>

<p>Matthew T. Pratola &lt;mpratola@stat.osu.edu&gt; [aut, cre, cph]
</p>


<h3>References</h3>

<p>Pratola, Matthew T. and Chrebtii, Oksana. (2018)
Bayesian Calibration of Multistate Stochastic Simulators. 
<em>Statistica Sinica</em>, <b>28</b>, 693&ndash;720.
<a href="http://doi.org/10.5705/ss.202016.0403">doi: 10.5705/ss.202016.0403</a>.
</p>
<p>Higdon, Dave, Gattiker, James, Williams, Brian and Rightley, Maria. (2008)
Computer model calibration using high-dimensional output. 
<em>Journal of the American Statistical Association</em>, <b>103</b>, 570&ndash;583.
<a href="http://doi.org/10.1198/016214507000000888">doi: 10.1198/016214507000000888</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+calibrate">calibrate</a></code>
</p>

<hr>
<h2 id='calibrate'>Fit the calibration model.</h2><span id='topic+calibrate'></span>

<h3>Description</h3>

<p><code>calibrate()</code> runs the MCMC algorithm to calibrate simulator outputs
to field observations while estimating unknown settings of calibration
parameters and quantifying model discrepancy.  Currently, two forms
of discrepancy are supported: additve stationary Gaussian Process discrepancy
and scalar multiplicative discrepancy (with a Normal prior).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calibrate(yf, phi, N, pinfo, mh, last = 1000)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calibrate_+3A_yf">yf</code></td>
<td>
<p>A vector of field observations.</p>
</td></tr>
<tr><td><code id="calibrate_+3A_phi">phi</code></td>
<td>
<p>A matrix or list of matrices representing simulator outputs</p>
</td></tr>
<tr><td><code id="calibrate_+3A_n">N</code></td>
<td>
<p>The number of MCMC iterations to run.</p>
</td></tr>
<tr><td><code id="calibrate_+3A_pinfo">pinfo</code></td>
<td>
<p>A list of prior parameter settings.  See details below.</p>
</td></tr>
<tr><td><code id="calibrate_+3A_mh">mh</code></td>
<td>
<p>A list of settings for Metropolis-Hastings proposals.  See details below.</p>
</td></tr>
<tr><td><code id="calibrate_+3A_last">last</code></td>
<td>
<p>The number of MCMC steps to report (default is 1000).  The first <code>(N-last)</code> steps are discarded as burn-in.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The method can calibrate both stochastic simulator outputs and deterministic
simulator outputs, and samples from the posterior distribution of unknowns
conditional on the observed field data and simulator outputs.  The method
makes use of empirical orthogonal functions to reduce the dimension of
the data to make computations feasible.  In addition, there is support for 
multi-state simulators, and calibration can be performed when all states
or only a subset of states are observed in the field.
</p>
<p>For more details on the model, see Pratola and Chkrebtii (2018).  Detailed
examples demonstrating the method are available at
<a href="http://www.matthewpratola.com/software">http://www.matthewpratola.com/software</a>.
</p>


<h3>Value</h3>

<p>A list with <code>last</code> samples drawn from the posterior.
</p>


<h3>References</h3>

<p>Pratola, Matthew T. and Chrebtii, Oksana. (2018)
Bayesian Calibration of Multistate Stochastic Simulators. 
<em>Statistica Sinica</em>, <b>28</b>, 693&ndash;720.
<a href="http://doi.org/10.5705/ss.202016.0403">doi: 10.5705/ss.202016.0403</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cmce-package">cmce-package</a></code>
<code><a href="#topic+getranges">getranges</a></code>
<code><a href="#topic+scaledesign">scaledesign</a></code>
<code><a href="#topic+unscalemat">unscalemat</a></code>
<code><a href="#topic+makedistlist">makedistlist</a></code>
<code><a href="#topic+gp.realize">gp.realize</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(cmce)

set.seed(7)

# n is the number of observation locations on the spatial-temporal grid
# m is the number of simulation model runs at parameter settings theta_1,...,theta_m
# ns is the number of simulator states.
# sd.field is the std. deviation of the iid normal measurement error for the field data yf.
n=20
m=5 
ns=1
sd.field=0.1

# Just a 1D example:
x=seq(0,1,length=n)

# the nxm model output matrix:
phi=matrix(0,nrow=n,ncol=m+1)
calisettings=matrix(runif(m+1)*5,ncol=1)
r=getranges(calisettings)
k=ncol(calisettings)

# Our "unknown" theta on original scale and transformed to [0,1]:
theta.orig=2.1
calisettings[m+1]=theta.orig
design=scaledesign(calisettings,r)
theta=design[m+1]

# Generate reality - bang!
X=expand.grid(x,design)
l.gen=makedistlist(X)
rho=c(0.2,0.01)
muv=rep(0,(m+1)*n)
lambdav=1/2
surface=gp.realize(l.gen,muv,lambdav,rho)


# phi matrix
phi=matrix(surface,ncol=m+1,nrow=n)

## Not run: 
# When phi is a matrix as above, the code performs deterministic calibration.
# To perform calibration for a stochastic simulator with, say, M available realizations,
# replace phi with a list of matrices:
phi=vector("list",M)
for(i in 1:M) phi[[i]]=matrix(realization[[i]],ncol=m+1,nrow=n)

## End(Not run)



# Do some plots:
plot(x,phi[,1],pch=20,ylim=c(-4,4),xlab="x",ylab="response")
for(i in 2:(m+1)) points(x,phi[,i],pch=20)
points(x,phi[,m+1],col="green",pch=20)


# setup
nc=2 # dimension reduction by only retaining nc components of the svd decomposition. 
     # Must have nc&gt;=2.
th.init=rep(0,k)
# matrix with all the calibration parameter settings and the last row will be filled 
# in with the estimate of theta during MCMC:
design.w=matrix(c(design[1:m],th.init),ncol=1)


# These matrices are (m+1)x(m+1).  The upper-left mxm matrix is the one used for 
# fitting gp's to the weights V.
l.v=makedistlist(design.w)


# we have the true theta stored, we no longer need it in calisettings
calisettings=calisettings[1:m,,drop=FALSE]


# Calibration parameter priors
thetaprior=NULL # use default uniform priors automatically constructed in cal.r


# Fake field data:
yf=phi[,m+1]+rnorm(n,sd=sd.field)


# For additive discrepancy:
l.d=makedistlist(x)
q=1
p=1
inidelta=rep(0,n)


# Specify Normal priors for the multiplicative discrepancies
inikap1=1
lamkap1=Inf


# State indices, since we only have 1 state this is trivial
is1=1:n


# setup pinfo and mh:
pinfo=list(l.v=l.v,l.d=l.d,n=n,m=m,q=k,p=p,nc=nc,ranges=r,thetaprior=thetaprior,
      ns=ns,six=list(is1=is1),inidelta=inidelta,
      lambdav=list(a=rep(10,nc),b=rep(0.1,nc)),
      lambdad=list(a=c(10),b=c(0.1)),
      mukap=c(inikap1),
      lambdakap=c(lamkap1),
      lambdaf=list(a=c(10),b=c(.5)),
      rho=list(a=5,b=1),
      psis=list(a=rep(2,p),b=rep(10,p)),
      delta.corrmodel="gaussian", eps=1e-10)
mh=list(rr=0.1, rp=0.1, rth=0.2)



# Run
N=2000   # Number of iterations, first 50% are used for adaptation
last=499 # Save these last draws as samples.  The N*50%-last are discarded burn-in.
fit=calibrate(yf,phi,N,pinfo,mh,last=last)



# Plot result
par(mfrow=c(1,2),pty="s")
# plot theta's
plot(density(unscalemat(fit$theta,r)),xlim=c(0,5),cex.lab=1.2,cex.axis=0.8,
    xlab=expression(theta),main="")
abline(v=theta.orig,lwd=2,lty=3)
# Next, the response and discrepancy:
plot(x,yf,col="pink",pch=20,xlim=c(0,1),ylim=c(-3,2),cex.lab=1.2,cex.axis=0.8,main="",
    ylab="response")
ix=seq(1,last,length=100)
for(i in 1:m) lines(x,phi[,i],col="grey",lwd=2)
for(i in ix) lines(x,fit$delta[i,],col="green")
for(i in ix) lines(x,fit$phi[[i]][,m+1])
for(i in ix) lines(x,fit$phi[[i]][,m+1]+fit$delta[i,],col="red",lty=3)
points(x,yf,col="pink",pch=20)
abline(h=0,lty=3)
legend(0.0,2,cex=.5,lwd=c(1,1,1,1),legend=c("emulator","discrepancy","predictive",
    "outputs"),col=c("black","green","red","grey"))

</code></pre>

<hr>
<h2 id='getranges'>Get variable ranges from a design matrix.</h2><span id='topic+getranges'></span>

<h3>Description</h3>

<p><code>getranges()</code> is a helper function to get the lower/upper bounds of variables in a design matrix, used for rescaling the inputs to the <code>[0,1])</code> hypercube.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getranges(design)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getranges_+3A_design">design</code></td>
<td>
<p>An <code>n x p</code> matrix of input settings</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>p x 2</code> matrix with the lower and upper bounds (rounded to nearest integer value) of all <code>p</code> variables in the design matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(cmce)

design=matrix(runif(10,1,5),ncol=2,nrow=5)
getranges(design)
</code></pre>

<hr>
<h2 id='gp.realize'>Draw an unconditional GP realization.</h2><span id='topic+gp.realize'></span>

<h3>Description</h3>

<p>The list <code>l.v</code> is created by <code>makedistlist()</code> from a n x p design matrix on which to generate the unconditional GP realization.  The correlation parameters take on values in <code>(0,1)</code> and use the Gaussian correlation model, calculated as <code>rho^d(xi,xj)^2</code>.  This helper function is used to create the demonstration data used in the example for <code>calibrate()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gp.realize(l.v,mu,lambda,rhos,lambdaf=Inf,eps=1e-10,from="")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gp.realize_+3A_l.v">l.v</code></td>
<td>
<p>A list of difference matrices for the design as calculated by <code>makedistlist()</code></p>
</td></tr>
<tr><td><code id="gp.realize_+3A_mu">mu</code></td>
<td>
<p>An <code>n x 1</code> mean vector for the realization</p>
</td></tr>
<tr><td><code id="gp.realize_+3A_lambda">lambda</code></td>
<td>
<p>A scalar quantity for the marginal precision of the drawn realization</p>
</td></tr>
<tr><td><code id="gp.realize_+3A_rhos">rhos</code></td>
<td>
<p>A <code>p x 1</code> vector of correlation parameters</p>
</td></tr>
<tr><td><code id="gp.realize_+3A_lambdaf">lambdaf</code></td>
<td>
<p>A scalar quantity denoting the precision of the error (i.i.d.) component of the realization</p>
</td></tr>
<tr><td><code id="gp.realize_+3A_eps">eps</code></td>
<td>
<p>A fudge factor to help with inverting large correlation matrices</p>
</td></tr>
<tr><td><code id="gp.realize_+3A_from">from</code></td>
<td>
<p>Internal use only</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code>n x 1</code> vector of the GP realization calculated over the finite locations of the original design matrix.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+getranges">getranges</a></code>
<code><a href="#topic+scaledesign">scaledesign</a></code>
<code><a href="#topic+makedistlist">makedistlist</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(cmce)

design=matrix(runif(10,1,5),ncol=2,nrow=5)
r=getranges(design)
design=scaledesign(design,r)
l.v=makedistlist(design)
rho=c(0.2,0.01)
muv=rep(0,nrow(design))
lambdav=1
surface=gp.realize(l.v,muv,lambdav,rho)

</code></pre>

<hr>
<h2 id='makedistlist'>Make list of distance matrices for calculating GP correlation matrices.</h2><span id='topic+makedistlist'></span>

<h3>Description</h3>

<p><code>makedistlist()</code> is a helper function used to setup the difference matrices that are used in <code>calibrate()</code>'s separable GP model. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makedistlist(design)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="makedistlist_+3A_design">design</code></td>
<td>
<p>An <code>n x p</code> matrix of input settings</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of <code>p</code> matrices, each of dimension <code>n x n</code> that contain the outer subtractions of each variable in the design matrix.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+getranges">getranges</a></code>
<code><a href="#topic+scaledesign">scaledesign</a></code>
<code><a href="#topic+gp.realize">gp.realize</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(cmce)

design=matrix(runif(10,1,5),ncol=2,nrow=5)
r=getranges(design)
design=scaledesign(design,r)
l.v=makedistlist(design)
</code></pre>

<hr>
<h2 id='scaledesign'>Rescale a design matrix to the [0,1] hypercube.</h2><span id='topic+scaledesign'></span>

<h3>Description</h3>

<p><code>scaledesign()</code> is a helper function to rescale a design to the <code>[0,1])</code> hypercube using variable ranges previously extracted by a call to <code>getranges()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scaledesign(design,r)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="scaledesign_+3A_design">design</code></td>
<td>
<p>An <code>n x p</code> matrix of input settings</p>
</td></tr>
<tr><td><code id="scaledesign_+3A_r">r</code></td>
<td>
<p>An <code>p x 2</code> matrix of variable ranges extracted from <code>getranges()</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>n x p</code> design matrix rescaled to the <code>[0,1]</code> hypercube.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+unscalemat">unscalemat</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(cmce)

design=matrix(runif(10,1,5),ncol=2,nrow=5)
r=getranges(design)
scaledesign(design,r)

</code></pre>

<hr>
<h2 id='unscalemat'>Unscale a matrix back to its original ranges.</h2><span id='topic+unscalemat'></span>

<h3>Description</h3>

<p><code>unscalemat()</code> is a helper function to rescale a matrix back to its original ranges.  Typically this is used to rescale the posterior samples of the parameters back to their original scale.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unscalemat(mat,r)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="unscalemat_+3A_mat">mat</code></td>
<td>
<p>An <code>n x p</code> matrix of numbers scaled to the <code>[0,1]</code> hypercube</p>
</td></tr>
<tr><td><code id="unscalemat_+3A_r">r</code></td>
<td>
<p>An <code>p x 2</code> matrix of the original ranges of the variables</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>n x p</code> matrix with variables rescaled back to their original ranges, as specified by <code>ranges</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+getranges">getranges</a></code>
<code><a href="#topic+scaledesign">scaledesign</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(cmce)

design=matrix(runif(10,1,5),ncol=2,nrow=5)
r=getranges(design)
design=scaledesign(design,r)
unscalemat(design,r)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
