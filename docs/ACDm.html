<!DOCTYPE html><html lang="en"><head><title>Help for package ACDm</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {ACDm}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#ACDm-package'>
<p>ACD Modelling</p></a></li>
<li><a href='#acdFit'>
<p>ACD (Autoregressive Conditional Duration) Model Fitting</p></a></li>
<li><a href='#acdFit-methods'>
<p>Methods for class acdFit</p></a></li>
<li><a href='#acf_acd'>
<p>Autocorrelation function plots for ACD models</p></a></li>
<li><a href='#BurrDist'>
<p>The Burr Distribution</p></a></li>
<li><a href='#computeDurations'>
<p>Durations computation</p></a></li>
<li><a href='#DataFiles'><p>Time Series Data Sets</p></a></li>
<li><a href='#dgenf'>
<p>The generalized F distribution</p></a></li>
<li><a href='#Discreetly+20mixed+20Q-Weibull+20and+20exponential'>
<p>Discreet mix of the q-Weibull and the exponential distributions</p></a></li>
<li><a href='#Discreetly+20mixed+20Q-Weibull+20and+20ordinary+20Weibull'>
<p>Discreet mix of the q-Weibull and the ordinary Weibull distributions</p></a></li>
<li><a href='#diurnalAdj'>
<p>Dirunal adjustment for durations</p></a></li>
<li><a href='#Finite+20mixture+20of+20inverse+20Gaussian+20Distributions'>
<p>Finite mixture of inverse Gaussian Distribution</p></a></li>
<li><a href='#GeneralizedGammaDist'>
<p>The generelized Gamma distribution</p></a></li>
<li><a href='#plotDescTrans'>
<p>Transactions plots</p></a></li>
<li><a href='#plotHazard'><p>Hazard function plot</p></a></li>
<li><a href='#plotHistAcd'>
<p>Mean duration plot</p></a></li>
<li><a href='#plotLL'>
<p>Plots the response surface of the log likelihood of a fitted model.</p></a></li>
<li><a href='#plotRollMeanAcd'>
<p>Plots rolling means of durations</p></a></li>
<li><a href='#plotScatterAcd'>
<p>Scatter plot for ACD models</p></a></li>
<li><a href='#qqplotAcd'>
<p>Quantile-Quantile plot of the residuals</p></a></li>
<li><a href='#qWeibullDist'>
<p>The q-Weibull distribution</p></a></li>
<li><a href='#resiDensityAcd'>
<p>Residual Density Histogram</p></a></li>
<li><a href='#sim_ACD'>
<p>ACD simulation</p></a></li>
<li><a href='#standardizeResi'>
<p>Residual standardization</p></a></li>
<li><a href='#testRmACD'>
<p>LM test of no Remaining ACD (Meitz and Terasvirta, 2006)</p></a></li>
<li><a href='#testSTACD'>
<p>LM test against Smooth Transition ACD models (Meitz and Terasvirta, 2006)</p></a></li>
<li><a href='#testTVACD'>
<p>LM test against Time-Varying ACD models (Meitz and Terasvirta, 2006)</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Version:</td>
<td>1.0.4.3</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-02-19</td>
</tr>
<tr>
<td>Title:</td>
<td>Tools for Autoregressive Conditional Duration Models</td>
</tr>
<tr>
<td>Author:</td>
<td>Markus Belfrage</td>
</tr>
<tr>
<td>Depends:</td>
<td>R(&ge; 2.10.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>plyr, dplyr, ggplot2, Rsolnp, zoo, graphics,</td>
</tr>
<tr>
<td>Suggests:</td>
<td>optimx, rgl,</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Markus Belfrage &lt;markus.belfrage@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Package for Autoregressive Conditional Duration (ACD, Engle and Russell, 1998) models. Creates trade, price or volume durations from transactions (tic) data, performs diurnal adjustments, fits various ACD models and tests them. </td>
</tr>
<tr>
<td>LazyData:</td>
<td>yes</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-02-19 19:36:59 UTC; Markus</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-02-20 05:22:43 UTC</td>
</tr>
</table>
<hr>
<h2 id='ACDm-package'>
ACD Modelling
</h2><span id='topic+ACDm-package'></span><span id='topic+ACDm'></span>

<h3>Description</h3>

<p>Package for Autoregressive Conditional Duration (ACD, Engle and Russell, 1998) models. Creates trade, price or volume durations from transactions (tic) data, performs diurnal adjustments, fits various ACD models and tests them.
</p>


<h3>Credit</h3>

<p>The author would like to thank the department of statistics at Hanken School of Economics, as the bulk of this work was done there while working as a research assistant.
</p>


<h3>Author(s)</h3>

<p>Markus Belfrage
</p>
<p>Maintainer: Markus Belfrage &lt;markus.belfrage@gmail.com&gt;
</p>


<h3>References</h3>

<p>Engle R.F, Russell J.R. (1998)
<em>Autoregressive Conditional Duration: A New Model for Irregularly Spaced Transaction Data</em>, Econometrica, 66(5): 1127-1162.
</p>

<hr>
<h2 id='acdFit'>
ACD (Autoregressive Conditional Duration) Model Fitting
</h2><span id='topic+acdFit'></span>

<h3>Description</h3>

<p>This function estimates various ACD models with various assumed error term distributions, using Maximum Likelihood Estimation.
</p>
<p>The currently available models (conditional mean specifications) are:
</p>
<p>Standard ACD, Log-ACD (two alternative specifications), AMACD, ABACD, SNIACD and LSNIACD.
</p>
<p>The currently available distributions are:
</p>
<p>Exponential (also used for QML), Weibull, Burr, generalized Gamma, and generalized F.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>acdFit(durations = NULL, model = "ACD", dist = "exponential", 
    order = NULL, startPara = NULL,  dailyRestart = 0, optimFnc = "optim",
    method = "Nelder-Mead", output = TRUE, bootstrapErrors = FALSE, 
    forceErrExpec = TRUE, fixedParamPos = NULL, bp = NULL, 
    exogenousVariables = NULL, control = list())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="acdFit_+3A_durations">durations</code></td>
<td>

<p>either (1) a data frame including, at least, a column named 'durations' or 'adjDur' (for adjusted durations), or (2) a vector of durations
</p>
</td></tr>
<tr><td><code id="acdFit_+3A_model">model</code></td>
<td>

<p>the conditional mean model specification. Must be one of <code>"ACD"</code>, <code>"LACD1"</code>, <code>"LACD2"</code>, <code>"AMACD"</code>, <code>"BACD"</code>, 
<code>"ABACD"</code>, <code>"SNIACD"</code> or <code>"LSNIACD"</code>. See 'Details' for detailed model specification. 
</p>
</td></tr>
<tr><td><code id="acdFit_+3A_dist">dist</code></td>
<td>

<p>the assumed error term distribution. Must be one of <code>"exponential"</code>, <code>"weibull"</code>, <code>"burr"</code>, <code>"gengamma"</code>, <code>"genf"</code>, <code>"qweibull"</code>, <code>"mixqwe"</code>, <code>"mixqww"</code>, or <code>"mixinvgauss"</code>. See 'Details' for detailed model specification. 
</p>
</td></tr>
<tr><td><code id="acdFit_+3A_order">order</code></td>
<td>

<p>a vector detailing the order of the particular ACD model. For example an ACD(p, q) specification should have <code>order = c(p, q)</code>.
</p>
</td></tr>
<tr><td><code id="acdFit_+3A_startpara">startPara</code></td>
<td>

<p>a vector with parameter values to start the maximization algorithm from. Must be in the correct order according to the model specification (see Details).
</p>
</td></tr>
<tr><td><code id="acdFit_+3A_dailyrestart">dailyRestart</code></td>
<td>

<p>if <code>TRUE</code> the conditional duration will start fresh every new trading day. Can only be used if the <code>durations</code> arguments included the clock time of the durations, or if the <code>time</code> argument was provided.
</p>
</td></tr>
<tr><td><code id="acdFit_+3A_optimfnc">optimFnc</code></td>
<td>

<p>Specifies which optimization function to use for the estimation. <code>"optim"</code>, <code>"nlminb"</code>, <code>"solnp"</code>, and <code>"optimx"</code> are available.
</p>
</td></tr>
<tr><td><code id="acdFit_+3A_method">method</code></td>
<td>

<p>Argument passed to the optimization function if <code>optimFnc = "optim"</code> or <code>optimFnc = "optimx"</code> were chosen. Specifies the optimization algorithm. See the help files for <a href="stats.html#topic+optim">optim</a>, <a href="stats.html#topic+nlminb">nlminb</a> or solnp.
</p>
</td></tr>
<tr><td><code id="acdFit_+3A_output">output</code></td>
<td>

<p>if <code>FALSE</code> the estimation results won't be printed.
</p>
</td></tr>
<tr><td><code id="acdFit_+3A_bootstraperrors">bootstrapErrors</code></td>
<td>

<p>if <code>TRUE</code> the standard errors will be computed by using bootstrap simulations. Currently only works with the standard ACD model.
</p>
</td></tr>
<tr><td><code id="acdFit_+3A_forceerrexpec">forceErrExpec</code></td>
<td>

<p>if <code>TRUE</code> the expectation of the error terms' distribution will be forced to be 1, otherwise the distribution parameter specifying the mean will be set to 1 to ensure identification.
</p>
</td></tr>
<tr><td><code id="acdFit_+3A_fixedparampos">fixedParamPos</code></td>
<td>

<p>a logical vector of <code>TRUE</code> and <code>FALSE</code>. Can only be used if the argument <code>startPara</code> were provided, and should be of the same length. Each element represents the respective start parameter and if <code>TRUE</code>, this parameter will be held fixed when estimating the other parameters.
</p>
</td></tr>
<tr><td><code id="acdFit_+3A_bp">bp</code></td>
<td>

<p>used only for the SNIACD or LSNIACD model. A vector of break points.
</p>
</td></tr>
<tr><td><code id="acdFit_+3A_exogenousvariables">exogenousVariables</code></td>
<td>

<p>specifies the columns in the <code>durations</code> data.frame that should be used as exogenous variables when fitting the model. Must be a vector, either with the column positions or the names of the columns. It is highly recommended to standardize the exogenous variables before running the estimation.
</p>
</td></tr>
<tr><td><code id="acdFit_+3A_control">control</code></td>
<td>

<p>a list of control values,
</p>

<dl>
<dt>maxit</dt><dd>
<p>maximum number of iterations performed by the numerical maximization algorithm.
</p>
</dd>
<dt>trace</dt><dd>
<p>an integer. If this is set to diffrent to 0, the values of the parameters each time the optimization function calls the log likelihood function. This search path of the MLE will then be plotted. Also passed on to the optimization function, see the help files for <a href="stats.html#topic+optim">optim</a>, <a href="stats.html#topic+nlminb">nlminb</a> or solnp.
</p>
</dd>
<dt>B</dt><dd>
<p>number of bootstrap samples
</p>
</dd>
</dl>

</td></tr>
</table>


<h3>Details</h3>

<p>The <code>startPara</code> argument is  a vector of the parameter values to start from. The length of the vector naturally depends on the <code>model</code> and <code>distribution</code>. The first elements represent the model parameters, and the last elements the distribution parameters. For example for an ACD(1,1) with Weibull errors the first 3 elements are <code class="reqn">\omega, \alpha_1, \beta_1</code> for the model, and the last is <code class="reqn">\gamma</code> for the Weibull distribution.
</p>
<p>The family of ACD models are
</p>
<p style="text-align: center;"><code class="reqn">x_i = \mu_i \epsilon_i,</code>
</p>

<p>where different specifications of the conditional mean duration <code class="reqn">\mu_i</code> and the error term <code class="reqn">\epsilon_i</code> give rise to different models as shown below. 
</p>
<p>When exogenous variables are used, they are added in the form of 
</p>
<p style="text-align: center;"><code class="reqn">\sum_{j=1}^{k} \xi_j z_j</code>
</p>
 
<p>to the right hand side of the equations, where <code class="reqn">z_j</code> are the exogenous variables.
</p>
<p><strong>Conditional mean duration <code class="reqn">\mu_i</code> specifications according to the <code>model</code> argument:</strong>
<br />
</p>
<p><b>ACD(p, q) specification:</b> (Engle and Russell,  1998)
</p>
<p style="text-align: center;"><code class="reqn">\mu_i = \omega + \sum_{j=1}^{p} \alpha_j x_{i-j} + \sum_{j=1}^{q} \beta_j \mu_{i-j}</code>
</p>

<p>The element order of the <code>startPara</code> vector is <code class="reqn">(\omega, \alpha_j...,\beta_j...)</code>.
<br />
</p>
<p><b>LACD1(p, q):</b> (Bauwens and Giot,  2000)
</p>
<p style="text-align: center;"><code class="reqn">\ln\mu_i = \omega + \sum_{j=1}^{p} \alpha_j \ln \epsilon_{i-j} + \sum_{j=1}^{q} \beta_j \ln \mu_{i-j}</code>
</p>

<p>The element order of the <code>startPara</code> vector is <code class="reqn">(\omega, \alpha_j...,\beta_j...)</code>.
<br />
</p>
<p><b>LACD2(p, q):</b> (Lunde,  1999)
</p>
<p style="text-align: center;"><code class="reqn">\ln\mu_i = \omega + \sum_{j=1}^{p} \alpha_j \epsilon_{i-j} + \sum_{j=1}^{q} \beta_j \ln \mu_{i-j}</code>
</p>

<p>The element order of the <code>startPara</code> vector is <code class="reqn">(\omega, \alpha_j...,\beta_j...)</code>.
<br />
</p>
<p><b>AMACD(p, r, q) (Additive and Multiplicative ACD):</b> (Hautsch , 2012)
</p>
<p style="text-align: center;"><code class="reqn">\mu_i = \omega + \sum_{j=1}^{p} \alpha_j x_{i-j} + \sum_{j=1}^{r} \nu_j \epsilon_{i-j} + \sum_{j=1}^{q} \beta_j \mu_{i-j}</code>
</p>

<p>The element order of the <code>startPara</code> vector is <code class="reqn">(\omega, \alpha_j...,\nu_j...,\beta_j...)</code>.
<br />
</p>
<p><b>ABACD(p, q) (Augmented Box-Cox ACD):</b> (Hautsch,  2012)
</p>
<p style="text-align: center;"><code class="reqn">\mu_i^{\delta_1} = \omega + \sum_{j=1}^{p} \alpha_j \left( |\epsilon_{i-j}-\nu|+c_j|\epsilon_{i-j}-b| \right)^{\delta_2} + \sum_{j=1}^{q} \beta_j \mu_{i-j}^{\delta_1}</code>
</p>

<p>The element order of the <code>startPara</code> vector is <code class="reqn">(\omega, \alpha_j..., c_j..., \beta_j..., \nu, \delta_1, \delta_2)</code>.
<br />
</p>
<p><b>BACD(p, q) (Box-Cox ACD):</b> (Hautsch,  2003)
</p>
<p style="text-align: center;"><code class="reqn">\mu_i^{\delta_1} = \omega + \sum_{j=1}^{p} \alpha_j \epsilon_{i-j}^{\delta_2} + \sum_{j=1}^{q} \beta_j \mu_{i-j}^{\delta_1}</code>
</p>

<p>The element order of the <code>startPara</code> vector is <code class="reqn">(\omega, \alpha_j..., \beta_j...)</code>.
<br />
</p>
<p><b>SNIACD(p,  q, M) (Spline News Impact ACD):</b> (Hautsch,  2012, with a slight difference)
</p>
<p style="text-align: center;"><code class="reqn">\mu_i = \omega + \sum_{j=1}^{p} (\alpha_{j-1}+c_0) \epsilon_{i-j} + \sum_{j=1}^{p} \sum_{k=M}^{r} (\alpha_{j-1}+c_k)1_{(\epsilon_{i-j} \le  \bar{\epsilon_k})}+\sum_{j=1}^{q} \beta_j \mu_{i-j},</code>
</p>

<p>where <code class="reqn">1_{()}</code> is an indicator function and <code class="reqn">\alpha_0=0</code>. <br />
The element order of the <code>startPara</code> vector is <code class="reqn">(\omega, c_k..., \alpha_j..., \beta_j...)</code> (The number of <code class="reqn">\alpha</code>-parameters are <code class="reqn">p-1]</code>).
<br />
</p>
<p><strong>The distribution of the error term <code class="reqn">\epsilon_i</code> specifications according to the <code>dist</code> argument:</strong>
<br /> <br />
<b>Exponential distribution, <code>dist = "exponential"</code>:</b>
</p>
<p style="text-align: center;"><code class="reqn">f(\epsilon)=\exp(-\epsilon)</code>
</p>

<p><b>Weibull distribution, <code>dist = "weibull"</code>:</b>
</p>
<p style="text-align: center;"><code class="reqn">f(\epsilon)=\theta \gamma \epsilon^{\gamma-1}e^{-\theta \epsilon^{\gamma}} ,</code>
</p>

<p>where <code class="reqn">\theta=[\Gamma(\gamma^{-1}+1)]^{\gamma}</code> if <code>forceErrExpec = TRUE</code>.
<br />
</p>
<p><b>Burr distribution, <code>dist = "burr"</code>:</b>
</p>
<p style="text-align: center;"><code class="reqn">f(\epsilon)= \frac{\theta \kappa \epsilon^{\kappa-1}}{(1+\sigma^2 \theta \epsilon^{\kappa})^{\frac{1}{\sigma^2}+1}},</code>
</p>

<p>where,
</p>
<p style="text-align: center;"><code class="reqn">\theta= \sigma^{2 \left(1+\frac{1}{\kappa}\right)} \frac{\Gamma \left(\frac{1}{\sigma^2}+1\right)}{\Gamma \left(\frac{1}{\kappa}+1\right) \Gamma \left(\frac{1}{\sigma^2}-\frac{1}{\kappa}\right)},</code>
</p>

<p>if <code>forceErrExpec = TRUE</code>. <br />
The element order of the <code>startPara</code> vector is <code class="reqn">(model parameters, \kappa, \sigma^2)</code>.
<br />
</p>
<p><b>Generalized Gamma distribution, <code>dist = "gengamma"</code>:</b>
</p>
<p style="text-align: center;"><code class="reqn">f(\epsilon)=\frac{\gamma \epsilon^{\kappa \gamma - 1}}{\lambda^{\kappa \gamma}\Gamma (\kappa)}\exp \left\{{-\left(\frac{\epsilon}{\lambda}\right)^{\gamma}}\right\}</code>
</p>

<p>where <code class="reqn">\lambda=\frac{\Gamma(\kappa)}{\Gamma(\kappa+\frac{1}{\gamma})}</code> if <code>forceErrExpec = TRUE</code>.
The element order of the <code>startPara</code> vector is <code class="reqn">(model parameters, \kappa, \gamma)</code>.
<br />
</p>
<p><b>Generalized F distribution, <code>dist = "genf"</code>:</b>
</p>
<p style="text-align: center;"><code class="reqn">f(\epsilon)= \frac{\gamma \epsilon^{\kappa \gamma -1}[\eta+(\epsilon/\lambda)^{\gamma}]^{-\eta-\kappa}\eta^{\eta}}{\lambda^{\kappa \gamma}B(\kappa,\eta)},</code>
</p>

<p>where <code class="reqn">B(\kappa,\eta)=\frac{\Gamma(\kappa)\Gamma(\eta)}{\Gamma(\kappa+\eta)}</code>, and if <code>forceErrExpec = TRUE</code>,
</p>
<p style="text-align: center;"><code class="reqn">\lambda=\frac{\Gamma(\kappa)\Gamma(\eta)}{\eta^{1/\gamma}\Gamma(\kappa+1/\gamma)\Gamma(\eta-1/\gamma)}.</code>
</p>

<p><br />
The element order of the <code>startPara</code> vector is <code class="reqn">(model parameters, \kappa,  \eta, \gamma)</code>.
<br />
</p>
<p><b>q-Weibull distribution, <code>dist = "qweibull"</code>:</b>
</p>
<p style="text-align: center;"><code class="reqn">f(\epsilon) = (2-q)\frac{a}{b^a} \epsilon^{a-1} \left[1-(1-q)\left(\frac{\epsilon}{b}\right)^a\right]^{\frac{1}{1-q}}</code>
</p>

<p>where if <code>forceErrExpec = TRUE</code>,
</p>
<p style="text-align: center;"><code class="reqn">b = \frac{(q-1)^{\frac{1+a}{a}}}{2-q}\frac{a\Gamma(\frac{1}{q-1})}{\Gamma(\frac{1}{a}) \Gamma(\frac{1}{q-1}-\frac{1}{a}-1)}.</code>
</p>

<p><br />
The element order of the <code>startPara</code> vector is <code class="reqn">(model parameters, a,  q)</code>.
<br />
</p>


<h3>Value</h3>

<p>a list of class <code>"acdFit"</code> with the following slots: 
</p>
<table role = "presentation">
<tr><td><code>durations</code></td>
<td>

<p>the durations object used to fit the model.
</p>
</td></tr>
<tr><td><code>muHats</code></td>
<td>

<p>a vector of the estimated conditional mean durations
</p>
</td></tr>
<tr><td><code>residuals</code></td>
<td>

<p>the residuals from the fitted model, calculated as durations/mu
</p>
</td></tr>
<tr><td><code>model</code></td>
<td>

<p>the model for the conditional mean durations
</p>
</td></tr>
<tr><td><code>order</code></td>
<td>

<p>the order of the model
</p>
</td></tr>
<tr><td><code>distribution</code></td>
<td>

<p>the assumed error term distribution
</p>
</td></tr>
<tr><td><code>distCode</code></td>
<td>

<p>the internal code used to represent the distribution
</p>
</td></tr>
<tr><td><code>mPara</code></td>
<td>

<p>a vector of the estimated conditional mean duration parameters
</p>
</td></tr>
<tr><td><code>dPara</code></td>
<td>

<p>a vector of the estimated error distribution parameters
</p>
</td></tr>
<tr><td><code>Npar</code></td>
<td>

<p>total number of parameters
</p>
</td></tr>
<tr><td><code>goodnessOfFit</code></td>
<td>

<p>a data.frame with the log likelihood, AIC, BIC, and MSE calculated as the mean squared deviation of the durations and the estimated conditional durations.
</p>
</td></tr>
<tr><td><code>parameterInference</code></td>
<td>

<p>a data.frame with the estimated coefficients and their standard errors and p-values
</p>
</td></tr>
<tr><td><code>forcedDistPara</code></td>
<td>

<p>the value of the unfree distribution parameter. If <code>forceErrExpec = TRUE</code> were used, this parameter is a function of the other distribution parameters, to force the mean of the distribution to be one. Otherwise the parameter was fixed at 1 to ensure identification.
</p>
</td></tr>
<tr><td><code>comments</code></td>
<td>

</td></tr>
<tr><td><code>hessian</code></td>
<td>

<p>the numerical hessian of the log likelihood evaluated at the estimate
</p>
</td></tr>
<tr><td><code>N</code></td>
<td>

<p>number of observations
</p>
</td></tr>
<tr><td><code>evals</code></td>
<td>

<p>number of log-likelihood evaluations needed for the maximization algorithm
</p>
</td></tr>
<tr><td><code>convergence</code></td>
<td>

<p>if the maximization algorithm converged, this value is zero. (see the help file <a href="stats.html#topic+optim">optim</a>, <a href="stats.html#topic+nlminb">nlminb</a> or solnp)
</p>
</td></tr>
<tr><td><code>estimationTime</code></td>
<td>

<p>time required for estimation
</p>
</td></tr>
<tr><td><code>description</code></td>
<td>

<p>who fitted the model and when 
</p>
</td></tr>
<tr><td><code>robustCorr</code></td>
<td>

<p>only available for QML estimation (choosing the exponential distribution) for the standard ACD(p, q) model. The robust correlation matrix of the parameter estimates. 
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Markus Belfrage
</p>


<h3>References</h3>

<p>Bauwens, L., and P. Giot (2000) 
<em>The logarithmic ACD model: an application to the bid-ask quote process of three NYSE stocks.</em> Annales d'Economie et de Statistique, 60, 117-149.
</p>
<p>Engle R.F, Russell J.R. (1998)
<em>Autoregressive Conditional Duration: A New Model for Irregularly Spaced Transaction Data</em>, Econometrica, 66(5): 1127-1162.
</p>
<p>Grammig, J., and Maurer, K.-O. (2000) 
<em>Non-monotonic hazard functions and the autoregressive conditional duration model.</em> Econometrics Journal 3: 16-38.
</p>
<p>Hautsch, N. (2003) 
<em>Assessing the Risk of Liquidity Suppliers on the Basis of Excess Demand Intensities.</em> Journal of Financial Econometrics (2003) 1 (2): 189-215
</p>
<p>Hautsch, N. (2012) 
<em>Econometrics of Financial High-Frequency Data.</em> Berlin, Heidelberg: Springer.
</p>
<p>Lunde, A. (1999): 
<em>A generalized gamma autoregressive conditional duration model,</em> Working paper, Aalborg University.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
fitModel &lt;- acdFit(durations = adjDurData, model = "ACD", 
            dist = "exponential", order = c(1,1), dailyRestart = 1)



</code></pre>

<hr>
<h2 id='acdFit-methods'>
Methods for class acdFit
</h2><span id='topic+acdFit-methods'></span><span id='topic+print.acdFit'></span><span id='topic+coef.acdFit'></span><span id='topic+residuals.acdFit'></span><span id='topic+predict.acdFit'></span>

<h3>Description</h3>

<p><code>residuals.acdFit()</code> returns the residuals and <code>coef.acdFit()</code> returns the coefficients of a fitted ACD model of class 'acdFit', while <code>print.acdFit()</code> prints the essential information. <code>predict.acdFit()</code> predicts the next <code>N</code> durations by thier expected value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'acdFit'
residuals(object, ...)
## S3 method for class 'acdFit'
coef(object, returnCoef = "all", ...)
## S3 method for class 'acdFit'
print(x, ...)
## S3 method for class 'acdFit'
predict(object, N = 10, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="acdFit-methods_+3A_object">object</code></td>
<td>

<p>the fitted ACD model of class 'acdFit' (as returned by the function <code>acdFit</code>).
</p>
</td></tr>
<tr><td><code id="acdFit-methods_+3A_x">x</code></td>
<td>

<p>same as <code>object</code>, ie. an object of class 'acdFit'.
</p>
</td></tr>
<tr><td><code id="acdFit-methods_+3A_returncoef">returnCoef</code></td>
<td>

<p>on of &quot;all&quot;, &quot;distribution&quot;, or &quot;model&quot;. Specifies whether all estimated parameters should be returned or only the distribution parameters or the model (for the conditional mean duration) parameters.
</p>
</td></tr>
<tr><td><code id="acdFit-methods_+3A_n">N</code></td>
<td>

<p>the number of the predictions in <code>predict</code>.
</p>
</td></tr>
<tr><td><code id="acdFit-methods_+3A_...">...</code></td>
<td>

<p>additional arguments to <code><a href="base.html#topic+print">print</a></code>.
</p>
</td></tr>
</table>

<hr>
<h2 id='acf_acd'>
Autocorrelation function plots for ACD models
</h2><span id='topic+acf_acd'></span>

<h3>Description</h3>

<p>plots the ACF (Auto Correlation Function) for the durations, diurnally adjusted durations, and residuals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>acf_acd(fitModel = NULL, conf_level = 0.95, max = 50, min = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="acf_acd_+3A_fitmodel">fitModel</code></td>
<td>

<p>a fitted model of class &quot;acdFit&quot;, or a data.frame containing at least one the columns &quot;durations&quot;, &quot;adjDur&quot;, or &quot;residuals&quot;. Can also be a vector of durations or residuals.
</p>
</td></tr>
<tr><td><code id="acf_acd_+3A_conf_level">conf_level</code></td>
<td>

<p>the confidence level of the confidence bands
</p>
</td></tr>
<tr><td><code id="acf_acd_+3A_max">max</code></td>
<td>

<p>the largest lag to plot
</p>
</td></tr>
<tr><td><code id="acf_acd_+3A_min">min</code></td>
<td>

<p>the smallest lag to plot
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns a data.frame with the values of the sample autocorrelations for each lag and variable.
</p>


<h3>Author(s)</h3>

<p>Markus Belfrage
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fitModel &lt;- acdFit(adjDurData)
acf_acd(fitModel, conf_level = 0.95, max = 50, min = 1)

f &lt;- acf_acd(durData)
f

</code></pre>

<hr>
<h2 id='BurrDist'>
The Burr Distribution
</h2><span id='topic+BurrDist'></span><span id='topic+dburr'></span><span id='topic+pburr'></span><span id='topic+qburr'></span><span id='topic+rburr'></span><span id='topic+burrExpectation'></span>

<h3>Description</h3>

<p>Density, distribution function, quantile function, random generation and calculation of the expected value for the Burr distribution with parameters theta, kappa and sig2.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dburr(x, theta = 1, kappa = 1.2, sig2 = 0.3, forceExpectation = F)
pburr(x, theta = 1, kappa = 1.2, sig2 = .3, forceExpectation = F)
qburr(p, theta = 1, kappa = 1.2, sig2 = .3, forceExpectation = F)
rburr(n = 1, theta = 1, kappa = 1.2, sig2 = .3, forceExpectation = F)
burrExpectation(theta = 1, kappa = 1.2, sig2 = .3)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="BurrDist_+3A_x">x</code></td>
<td>

<p>vector of quantiles.
</p>
</td></tr>
<tr><td><code id="BurrDist_+3A_p">p</code></td>
<td>

<p>vector of probabilities.
</p>
</td></tr>
<tr><td><code id="BurrDist_+3A_n">n</code></td>
<td>

<p>number of observations..
</p>
</td></tr>
<tr><td><code id="BurrDist_+3A_theta">theta</code>, <code id="BurrDist_+3A_kappa">kappa</code>, <code id="BurrDist_+3A_sig2">sig2</code></td>
<td>

<p>parameters, see 'Details'.
</p>
</td></tr>
<tr><td><code id="BurrDist_+3A_forceexpectation">forceExpectation</code></td>
<td>

<p>logical; if <code>TRUE</code>, the expectation of the distribution is forced to be 1 by letting <code>theta</code> be a function of the other parameters. 
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The PDF for the Burr distribution is (as in e.g. Grammig and Maurer, 2000):
</p>
<p style="text-align: center;"><code class="reqn">f(x)=\frac{\theta \kappa x^{\kappa - 1}}{(1 + \sigma^2 x^{\kappa)^{\frac{1}{\sigma^2}+1}}}</code>
</p>



<h3>Value</h3>

<p><code>dburr</code> gives the density (PDF), <code>qburr</code> the quantile function (inverted CDF), <code>rburr</code> generates random deviates, and <code>burrExpectation</code> returns the expected value of the distribution, given the parameters.
</p>


<h3>Author(s)</h3>

<p>Markus Belfrage
</p>


<h3>References</h3>

<p>Grammig, J., and Maurer, K.-O. (2000)
<em>Non-monotonic hazard functions and the autoregressive conditional duration model</em>.
Econometrics Journal 3: 16-38.
</p>

<hr>
<h2 id='computeDurations'>
Durations computation
</h2><span id='topic+computeDurations'></span>

<h3>Description</h3>

<p>Computes durations from a data.frame containing the time stamps of transactions. Trade durations, price durations and volume durations can be computed (if the appropriate data columns are given).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>computeDurations(transactions, open = "10:00:00", close = "18:25:00", 
rm0dur = TRUE, type = "trade", priceDiff = .1, cumVol = 10000)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="computeDurations_+3A_transactions">transactions</code></td>
<td>

<p>a data.frame with, at least, transaction time in a column named 'time' (see Details)
</p>
</td></tr>
<tr><td><code id="computeDurations_+3A_open">open</code></td>
<td>

<p>the opening time of the exchange. Transactions done outside the trading hours will be ignored. 
</p>
</td></tr>
<tr><td><code id="computeDurations_+3A_close">close</code></td>
<td>

<p>the closing time of the exchange.
</p>
</td></tr>
<tr><td><code id="computeDurations_+3A_rm0dur">rm0dur</code></td>
<td>

<p>if <code>TRUE</code> zero-durations will be removed and transactions done on the same second will be aggregated, e.g. price will then be the volume weighted avrage price of the aggregated transactions. 
</p>
</td></tr>
<tr><td><code id="computeDurations_+3A_type">type</code></td>
<td>

<p>the type of durations to be computed. Either &quot;trade&quot;, &quot;price&quot;, or &quot;volume&quot;.
</p>
</td></tr>
<tr><td><code id="computeDurations_+3A_pricediff">priceDiff</code></td>
<td>

<p>only if <code>type = "price"</code>. Price durtions are (here) defind as the duration until the price has changed by at least 'priceDiff' in absolute value.
</p>
</td></tr>
<tr><td><code id="computeDurations_+3A_cumvol">cumVol</code></td>
<td>

<p>only if <code>type = "cumVol"</code>. Volume durtions are (here) defind as the duration until the cumulative traded volume since the last duration has surpassed 'cumVol'.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The data.frame must include a column named 'time' with the time of each transaction, in a time format recognizable by <a href="base.html#topic+POSIXlt">POSIXlt</a> or strings in format &quot;yyyy-mm-dd hh:mm:ss&quot;. If the column 'price' or 'volume' is included its also possible to compute price- and volume durations (see arguments <code>priceDiff</code> and <code>cumVol</code>) 
</p>


<h3>Value</h3>

<p>a data.frame with columns:
</p>
<table role = "presentation">
<tr><td><code>time</code></td>
<td>

<p>the calander time of the start of each duration spell.
</p>
</td></tr>
<tr><td><code>price</code></td>
<td>

<p>the volume weighted avrage price of the shares traded during the spell of the duration.
</p>
</td></tr>
<tr><td><code>volume</code></td>
<td>

<p>the volume (total shares traded) during the duration spell.
</p>
</td></tr>
<tr><td><code>Ntrans</code></td>
<td>

<p>number of transactions done during the spell.
</p>
</td></tr>
<tr><td><code>durations</code></td>
<td>

<p>the computed duration.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Markus Belfrage
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#only the first 3 days of data:
durDataShort &lt;- computeDurations(transData[1:56700, ]) 
str(durDataShort)
head(durDataShort)
## End(Not run)
</code></pre>

<hr>
<h2 id='DataFiles'>Time Series Data Sets</h2><span id='topic+DataFiles'></span><span id='topic+transData'></span><span id='topic+durData'></span><span id='topic+adjDurData'></span><span id='topic+defaultSplineObj'></span>

<h3>Description</h3>

<p>The data file <code>transData</code> is the base data used in all of the examples. It is a data.frame with rows representing a single transaction and has the columns 'time', 'price', giving the trade price, and 'volume', giving the number of shares traded for the transaction. The data set is based on real transactions but has been obfuscated by transforming the dates, price and volume, for proprietary reasons. It covers two weeks of nearly 100 000 transactions, recorded with 1 second precision.    
</p>
<p>The <code>durData</code> data.frame is simply the trade durations formed from <code>transData</code> using the function <code>durData &lt;- computeDurations(transData)</code> 
</p>
<p>The <code>adjDurData</code> data object is in turn created by <code>adjDurData &lt;- diurnalAdj(durData, aggregation = "all")</code> to add diurnally adjusted durations.
</p>
<p><code>defaultSplineObj</code> is an estimated cubic spline of the diurnal component using the sample data. It is used when simulating from <code>sim_ACD()</code> with the argument <code>diurnalFactor</code> set to <code>TRUE</code>, when no user <code>splineObj</code> is provided.
</p>

<hr>
<h2 id='dgenf'>
The generalized F distribution
</h2><span id='topic+dgenf'></span><span id='topic+pgenf'></span><span id='topic+genfHazard'></span>

<h3>Description</h3>

<p>Density and distribution function for the generalized F distribution. Warning: the distribution function <code>pgenf</code> and <code>genfHazard</code> are computed numerically, and may not be precise!
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dgenf(x, kappa = 5, eta = 1.5, gamma = .8, lambda = 1, forceExpectation = F)
pgenf(q, kappa = 5, eta = 1.5, gamma = .8, lambda = 1, forceExpectation = F)
genfHazard(x, kappa = 5, eta = 1.5, gamma = .8, lambda = 1, forceExpectation = F)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dgenf_+3A_x">x</code>, <code id="dgenf_+3A_q">q</code></td>
<td>

<p>vector of quantiles.
</p>
</td></tr>
<tr><td><code id="dgenf_+3A_kappa">kappa</code>, <code id="dgenf_+3A_eta">eta</code>, <code id="dgenf_+3A_gamma">gamma</code>, <code id="dgenf_+3A_lambda">lambda</code></td>
<td>

<p>parameters, see 'Details'.
</p>
</td></tr>
<tr><td><code id="dgenf_+3A_forceexpectation">forceExpectation</code></td>
<td>

<p>logical; if <code>TRUE</code>, the expectation of the distribution is forced to be 1 by letting theta be a function of the other parameters.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The PDF for the generelized F distribution is:
</p>
<p style="text-align: center;"><code class="reqn">f(\epsilon)= \frac{\gamma \epsilon^{\kappa \gamma -1}[\eta+(\epsilon/\lambda)^{\gamma}]^{-\eta-\kappa}\eta^{\eta}}{\lambda^{\kappa \gamma}B(\kappa,\eta)},</code>
</p>

<p>where <code class="reqn">B(\kappa,\eta)=\frac{\Gamma(\kappa)\Gamma(\eta)}{\Gamma(\kappa+\eta)}</code> is the beta function.
</p>

<hr>
<h2 id='Discreetly+20mixed+20Q-Weibull+20and+20exponential'>
Discreet mix of the q-Weibull and the exponential distributions
</h2><span id='topic+Discreetly+20mixed+20Q-Weibull+20and+20exponential'></span><span id='topic+dmixqwe'></span><span id='topic+pmixqwe'></span><span id='topic+mixqweHazard'></span>

<h3>Description</h3>

<p>Density (PDF), distribution function (CDF), and hazard function for a discreetly mixed distribution of the q-Weibull and the exponential distributions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dmixqwe(x, pdist = .5, a = .8, qdist = 1.5, lambda = .8, b = 1, forceExpectation = F)
pmixqwe(q, pdist = .5, a = .8, qdist = 1.5, lambda = .8, b = 1, forceExpectation = F)
mixqweHazard(x, pdist = .5, a = .8, qdist = 1.5, lambda = .8, b = 1, forceExpectation = F)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Discreetly+2B20mixed+2B20Q-Weibull+2B20and+2B20exponential_+3A_x">x</code>, <code id="Discreetly+2B20mixed+2B20Q-Weibull+2B20and+2B20exponential_+3A_q">q</code></td>
<td>

<p>vector of quantiles.
</p>
</td></tr>
<tr><td><code id="Discreetly+2B20mixed+2B20Q-Weibull+2B20and+2B20exponential_+3A_pdist">pdist</code>, <code id="Discreetly+2B20mixed+2B20Q-Weibull+2B20and+2B20exponential_+3A_a">a</code>, <code id="Discreetly+2B20mixed+2B20Q-Weibull+2B20and+2B20exponential_+3A_qdist">qdist</code>, <code id="Discreetly+2B20mixed+2B20Q-Weibull+2B20and+2B20exponential_+3A_lambda">lambda</code>, <code id="Discreetly+2B20mixed+2B20Q-Weibull+2B20and+2B20exponential_+3A_b">b</code></td>
<td>

<p>parameters, see 'Details'.
</p>
</td></tr>
<tr><td><code id="Discreetly+2B20mixed+2B20Q-Weibull+2B20and+2B20exponential_+3A_forceexpectation">forceExpectation</code></td>
<td>

<p>logical; if <code>TRUE</code>, the expectation of the distribution is forced to be 1 by letting <code>b</code> be a function of the other parameters.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The PDF for the mixed distribution is:
</p>
<p style="text-align: center;"><code class="reqn">f(x) = p(2-q)\frac{a}{b^a} x^{a-1} \left[1-(1-q)\left(\frac{x}{b}\right)^a\right]^{\frac{1}{1-q}} + (1-p)\frac{1}{\lambda}exp(-\frac{x}{\lambda})</code>
</p>

<p>if <code>forceExpectation = TRUE</code> the <code>b</code> parameter is a function of the other parameters to force the expectation to be 1.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+qWeibullDist">qWeibullDist</a></code> for the Q-Weibull distribution and <code><a href="#topic+pmixqww">pmixqww</a></code> for Q-Weibull mixed with the ordinary Weibull.
</p>

<hr>
<h2 id='Discreetly+20mixed+20Q-Weibull+20and+20ordinary+20Weibull'>
Discreet mix of the q-Weibull and the ordinary Weibull distributions
</h2><span id='topic+Discreetly+20mixed+20Q-Weibull+20and+20ordinary+20Weibull'></span><span id='topic+dmixqww'></span><span id='topic+pmixqww'></span><span id='topic+mixqwwHazard'></span>

<h3>Description</h3>

<p>Density (PDF), distribution function (CDF), and hazard function for a discreetly mixed distribution of the q-Weibull and the ordinary Weibull distributions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dmixqww(x, pdist = .5, a = 1.2, qdist = 1.5, theta = .8, gamma = 1, b = 1,
  forceExpectation = F)
        
pmixqww(q, pdist = .5, a = 1.2, qdist = 1.5, theta = .8, gamma = 1, b = 1,
  forceExpectation = F)
        
mixqwwHazard(x, pdist = .5, a = 1.2, qdist = 1.5, theta = .8, gamma = 1, b = 1,
  forceExpectation = F)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Discreetly+2B20mixed+2B20Q-Weibull+2B20and+2B20ordinary+2B20Weibull_+3A_x">x</code>, <code id="Discreetly+2B20mixed+2B20Q-Weibull+2B20and+2B20ordinary+2B20Weibull_+3A_q">q</code></td>
<td>

<p>vector of quantiles.
</p>
</td></tr>
<tr><td><code id="Discreetly+2B20mixed+2B20Q-Weibull+2B20and+2B20ordinary+2B20Weibull_+3A_pdist">pdist</code>, <code id="Discreetly+2B20mixed+2B20Q-Weibull+2B20and+2B20ordinary+2B20Weibull_+3A_a">a</code>, <code id="Discreetly+2B20mixed+2B20Q-Weibull+2B20and+2B20ordinary+2B20Weibull_+3A_qdist">qdist</code>, <code id="Discreetly+2B20mixed+2B20Q-Weibull+2B20and+2B20ordinary+2B20Weibull_+3A_theta">theta</code>, <code id="Discreetly+2B20mixed+2B20Q-Weibull+2B20and+2B20ordinary+2B20Weibull_+3A_gamma">gamma</code>, <code id="Discreetly+2B20mixed+2B20Q-Weibull+2B20and+2B20ordinary+2B20Weibull_+3A_b">b</code></td>
<td>

<p>parameters, see 'Details'.
</p>
</td></tr>
<tr><td><code id="Discreetly+2B20mixed+2B20Q-Weibull+2B20and+2B20ordinary+2B20Weibull_+3A_forceexpectation">forceExpectation</code></td>
<td>

<p>logical; if <code>TRUE</code>, the expectation of the distribution is forced to be 1 by letting <code>b</code> be a function of the other parameters.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The PDF for the mixed distribution is:
</p>
<p style="text-align: center;"><code class="reqn">f(x) = p(2-q)\frac{a}{b^a} x^{a-1} \left[1-(1-q)\left(\frac{x}{b}\right)^a\right]^{\frac{1}{1-q}} + (1-p)\theta \gamma x^{-\theta x^{\gamma}}</code>
</p>

<p>if <code>forceExpectation = TRUE</code> the <code>b</code> parameter is a function of the other parameters to force the expectation to be 1.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+qWeibullDist">qWeibullDist</a></code> for the Q-Weibull distribution and <code><a href="#topic+pmixqwe">pmixqwe</a></code> for Q-Weibull mixed with the exponential distribution.
</p>

<hr>
<h2 id='diurnalAdj'>
Dirunal adjustment for durations
</h2><span id='topic+diurnalAdj'></span>

<h3>Description</h3>

<p>Performs a diurnal adjustment of the durations, i.e. removes a daily seasonal component. Four different methods of diurnal adjustment are available, namely &quot;cubicSpline&quot;, &quot;supsmu&quot; (Friedman's SuperSmoother), &quot;smoothSpline&quot; (smoothed version of the cubic spline), or &quot;FFF&quot; (Flexible Fourier Form).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>diurnalAdj(dur, method = "cubicSpline", nodes = c(seq(600, 1105, 60), 1105),
aggregation = "all", span = "cv", spar = 0, Q = 4, returnSplineFnc = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="diurnalAdj_+3A_dur">dur</code></td>
<td>

<p>a data.frame containing the columns <code>durations</code>, containing durations, and <code>time</code>, containing the time stamps.
</p>
</td></tr>
<tr><td><code id="diurnalAdj_+3A_method">method</code></td>
<td>

<p>the method used. One of &quot;cubicSpline&quot;, &quot;supsmu&quot;, &quot;smoothSpline&quot;, or &quot;FFF&quot;.
</p>
</td></tr>
<tr><td><code id="diurnalAdj_+3A_nodes">nodes</code></td>
<td>

<p>only for <code>method = "cubicSpline"</code> or <code>method = "smoothSpline"</code>. A vector of nodes to use for the spline function, in the unit minutes after midnight. The first and last element of the vector must be the start and end of the trading day. The nodes given are actually the limits of intervalls, of wich the midpoints will be set as the nodes using the means of the intervals. 
</p>
</td></tr>
<tr><td><code id="diurnalAdj_+3A_aggregation">aggregation</code></td>
<td>

<p>what type of aggregation to use. Either &quot;weekdays&quot;, &quot;all&quot;, or &quot;none&quot;. If for example &quot;weekdays&quot; is chosen, all Mondays will have the same daily seasonal component, and so on. 
</p>
</td></tr>
<tr><td><code id="diurnalAdj_+3A_span">span</code></td>
<td>

<p>argument passed to supsmu if <code>method = "supsmu"</code> were chosen. Affects the smoothness of the curve, see <a href="stats.html#topic+supsmu">supsmu</a>.
</p>
</td></tr>
<tr><td><code id="diurnalAdj_+3A_spar">spar</code></td>
<td>

<p>argument passed to smooth.spline if <code>method = "smooth.spline"</code> were chosen. Affects the smoothness of the curve, see <a href="stats.html#topic+smooth.spline">smooth.spline</a>.
</p>
</td></tr>
<tr><td><code id="diurnalAdj_+3A_q">Q</code></td>
<td>

<p>number of trigonometric function pairs for <code>method = "FFF"</code>. 
</p>
</td></tr>
<tr><td><code id="diurnalAdj_+3A_returnsplinefnc">returnSplineFnc</code></td>
<td>

<p>if <code>TRUE</code> instead or returning the adjusted durations a list of spline objects will be returned, containing the coefficents of the spline function. Only available for <code>method = "cubicSpline"</code>. 
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>returnSplineFnc</code> is <code>FALSE</code> (default): the input
data.frame <code>dur</code> with an added column of the diurnally adjusted
durations called 'adjDur'.
</p>
<p>Otherwise, a list of spline objects containing the coefficents of the
spline function. 
</p>


<h3>Author(s)</h3>

<p>Markus Belfrage
</p>


<h3>Examples</h3>

<pre><code class='language-R'>diurnalAdj(durData, aggregation = "none", method = "supsmu")

## Not run: 

head(durData)
f &lt;- diurnalAdj(durData, aggregation = "weekdays", method = "FFF", Q = 3)
head(f)

f &lt;- diurnalAdj(durData, aggregation = "all", returnSplineFnc = TRUE)
f

## End(Not run)
</code></pre>

<hr>
<h2 id='Finite+20mixture+20of+20inverse+20Gaussian+20Distributions'>
Finite mixture of inverse Gaussian Distribution
</h2><span id='topic+Finite+20mixture+20of+20inverse+20Gaussian+20Distributions'></span><span id='topic+pmixinvgauss'></span><span id='topic+dmixinvgauss'></span><span id='topic+mixinvgaussHazard'></span>

<h3>Description</h3>

<p>Density (PDF), distribution function (CDF), and hazard function for Finite mixture of inverse Gaussian Distributions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dmixinvgauss(x, theta = .2, lambda = .1, gamma = .05, forceExpectation = F)
pmixinvgauss(q, theta = .2, lambda = .1, gamma = .05, forceExpectation = F)
mixinvgaussHazard(x, theta = .2, lambda = .1, gamma = .05, forceExpectation = F)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Finite+2B20mixture+2B20of+2B20inverse+2B20Gaussian+2B20Distributions_+3A_x">x</code>, <code id="Finite+2B20mixture+2B20of+2B20inverse+2B20Gaussian+2B20Distributions_+3A_q">q</code></td>
<td>

<p>vector of quantiles.
</p>
</td></tr>
<tr><td><code id="Finite+2B20mixture+2B20of+2B20inverse+2B20Gaussian+2B20Distributions_+3A_theta">theta</code>, <code id="Finite+2B20mixture+2B20of+2B20inverse+2B20Gaussian+2B20Distributions_+3A_lambda">lambda</code>, <code id="Finite+2B20mixture+2B20of+2B20inverse+2B20Gaussian+2B20Distributions_+3A_gamma">gamma</code></td>
<td>

<p>parameters, see 'Details'.
</p>
</td></tr>
<tr><td><code id="Finite+2B20mixture+2B20of+2B20inverse+2B20Gaussian+2B20Distributions_+3A_forceexpectation">forceExpectation</code></td>
<td>

<p>logical; if <code>TRUE</code>, the expectation of the distribution is forced to be 1..
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The finite mixture of inverse Gaussian distributions was used by Gomes-Deniz and Perez-Rodrigues (201X) for ACD-models. Its PDF is:
</p>
<p style="text-align: center;"><code class="reqn">f(x) = \frac{\gamma + x}{\gamma + \theta} \sqrt{\frac{\lambda}{2 \pi x^3}} \exp \left[ - \frac{\lambda(x-\theta)^2}{2 x \theta^2}\right].</code>
</p>

<p>If <code>forceExpectation = TRUE</code> the distribution is transformed by dividing the random variable with its expectation and using the change of variable function.
</p>


<h3>References</h3>

<p>Gomez-Deniz Perez-Rodriguez (201X) 
<em>Non-exponential mixtures, non-monotonic financial hazard functions and the autoregressive conditional duration model.</em> Working paper. Retrieved June 16, 2015, from http://dea.uib.es/digitalAssets/254/254084_perez.pdf.
</p>

<hr>
<h2 id='GeneralizedGammaDist'>
The generelized Gamma distribution
</h2><span id='topic+GeneralizedGammaDist'></span><span id='topic+dgengamma'></span><span id='topic+pgengamma'></span><span id='topic+qgengamma'></span><span id='topic+rgengamma'></span><span id='topic+gengammaHazard'></span>

<h3>Description</h3>

<p>Density (PDF), distribution function (CDF), quantile function (inverted CDF), random generation and hazard function for the generelized Gamma distribution with parameters gamma, kappa and lambda.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dgengamma(x, gamma = 0.3, kappa = 1.2, lambda = 0.3, forceExpectation = F)
pgengamma(x, gamma = .3, kappa = 3, lambda = .3, forceExpectation = F)
qgengamma(p, gamma = .3, kappa = 3, lambda = .3, forceExpectation = F)
rgengamma(n = 1, gamma = .3, kappa = 3, lambda = .3, forceExpectation = F)
gengammaHazard(x, gamma = .3, kappa = 3, lambda = .3, forceExpectation = F)

</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="GeneralizedGammaDist_+3A_x">x</code></td>
<td>

<p>vector of quantiles.
</p>
</td></tr>
<tr><td><code id="GeneralizedGammaDist_+3A_p">p</code></td>
<td>

<p>vector of probabilities.
</p>
</td></tr>
<tr><td><code id="GeneralizedGammaDist_+3A_n">n</code></td>
<td>

<p>number of observations..
</p>
</td></tr>
<tr><td><code id="GeneralizedGammaDist_+3A_gamma">gamma</code>, <code id="GeneralizedGammaDist_+3A_kappa">kappa</code>, <code id="GeneralizedGammaDist_+3A_lambda">lambda</code></td>
<td>

<p>parameters, see 'Details'.
</p>
</td></tr>
<tr><td><code id="GeneralizedGammaDist_+3A_forceexpectation">forceExpectation</code></td>
<td>

<p>logical; if <code>TRUE</code>, the expectation of the distribution is forced to be 1 by letting <code>theta</code> be a function of the other parameters. 
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The PDF for the generelized Gamma distribution is:
</p>
<p style="text-align: center;"><code class="reqn">f(x)=\frac{\gamma x^{\kappa \gamma - 1}}{\lambda^{\kappa \gamma}\Gamma (\kappa)}\exp \left\{{-\left(\frac{x}{\lambda}\right)^{\gamma}}\right\}</code>
</p>



<h3>Value</h3>

<p><code>dgengamma</code> gives the density (PDF), <code>pgengamma</code> gives the distribution function (CDF), <code>qgengamma</code> gives the quantile function (inverted CDF), <code>rgenGamma</code> generates random deviates, and <code>genGammaHazard</code> gives the hazard function.
</p>


<h3>Author(s)</h3>

<p>Markus Belfrage
</p>

<hr>
<h2 id='plotDescTrans'>
Transactions plots 
</h2><span id='topic+plotDescTrans'></span>

<h3>Description</h3>

<p>Plots (1) the price over time, (2) volume traded over time for a given interval, and (3) number of transactions over time for a given interval. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotDescTrans(trans, windowunit = "hours", window = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plotDescTrans_+3A_trans">trans</code></td>
<td>

<p>a data.frame with the column 'time', 'price', and 'volume'. Currently only works if all of those are available.
</p>
</td></tr>
<tr><td><code id="plotDescTrans_+3A_windowunit">windowunit</code></td>
<td>

<p>the unit of the time interval. One of &quot;secs&quot;, &quot;mins&quot;, &quot;hours&quot;, or &quot;days&quot;.
</p>
</td></tr>
<tr><td><code id="plotDescTrans_+3A_window">window</code></td>
<td>

<p>a positive integer giving the length of the interval.
</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
plotDescTrans(transData, windowunit = "hours", window = 1)
## End(Not run)
</code></pre>

<hr>
<h2 id='plotHazard'>Hazard function plot</h2><span id='topic+plotHazard'></span>

<h3>Description</h3>

<p>Estimates and plots the hazard function from an estimatated ACD model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>    
plotHazard(fitModel, breaks = 20, implied = TRUE, xstop)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plotHazard_+3A_fitmodel">fitModel</code></td>
<td>

<p>an estimated model of class acdFit. Can also be a numerical vector.
</p>
</td></tr>
<tr><td><code id="plotHazard_+3A_breaks">breaks</code></td>
<td>

<p>the number of quantiles used to estimate the hazard.
</p>
</td></tr>
<tr><td><code id="plotHazard_+3A_implied">implied</code></td>
<td>

<p>a logical flag. If TRUE then the implied hazard function using the distribution parameter estimates will be plotted together with the nonparametric estimate of the error term hazard function.
</p>
</td></tr>
<tr><td><code id="plotHazard_+3A_xstop">xstop</code></td>
<td>

<p>where to stop plotting the implied hazard.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This estimator of the hazard function is based on the one used by Engle and Russell (1998). It is modified sligthly to decrease its bias and inconsistency. However, the estimator is still not fully consistent when using a fixed number of breaks (quantiles). 
</p>


<h3>Author(s)</h3>

<p>Markus Belfrage
</p>


<h3>References</h3>

<p>Engle, R.F and Russell, J.R. (1998) Autoregressive Conditional Duration: A New Model for Irregularly Spaced Transaction Data. <em>Econometrica</em>, 66(5): 1127-1162.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  
## Not run: 

fitModelWei &lt;- acdFit(adjDurData, dist = "wei")
plotHazard(fitModelWei)

## End(Not run)

</code></pre>

<hr>
<h2 id='plotHistAcd'>
Mean duration plot
</h2><span id='topic+plotHistAcd'></span>

<h3>Description</h3>

<p>Plots the mean duration over time at chosen interval length
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotHistAcd(durations, windowunit = "mins", window = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plotHistAcd_+3A_durations">durations</code></td>
<td>

<p>a data.frame containing the durations and their time stamps.
</p>
</td></tr>
<tr><td><code id="plotHistAcd_+3A_windowunit">windowunit</code></td>
<td>

<p>the unit of the time interval. One of &quot;secs&quot;, &quot;mins&quot;, &quot;hours&quot;, or &quot;days&quot;.
</p>
</td></tr>
<tr><td><code id="plotHistAcd_+3A_window">window</code></td>
<td>

<p>a positive integer giving the length of the interval.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Markus Belfrage
</p>


<h3>Examples</h3>

<pre><code class='language-R'>plotHistAcd(durData, windowunit = "days", window = 1)

## Not run: 

plotHistAcd(durData, windowunit = "mins", window = 30)

## End(Not run)
</code></pre>

<hr>
<h2 id='plotLL'>
Plots the response surface of the log likelihood of a fitted model.
</h2><span id='topic+plotLL'></span>

<h3>Description</h3>

<p>Plots the log likelihood for a fitted model against either one or two of the parameters at a time. This can help to find issues with for example poor identification of a model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotLL(fitModel, parameter1 = 1, parameter2 = NULL, 
param1sequence, param2sequence, startpoint = NULL, returnOutput = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plotLL_+3A_fitmodel">fitModel</code></td>
<td>

<p>a fitted model of class acdFit. 
</p>
</td></tr>
<tr><td><code id="plotLL_+3A_parameter1">parameter1</code></td>
<td>

<p>the first parameter for the log likelihood to be plotted against. Either the index of the parameter as an integer, or the name of the parameter.
</p>
</td></tr>
<tr><td><code id="plotLL_+3A_parameter2">parameter2</code></td>
<td>

<p>the second parameter for the log likelihood to be plotted against. Either the index of the parameter as an integer, or the name of the parameter. If left empty, a plot with only the <code>parameter1</code> will be drawn.
</p>
</td></tr>
<tr><td><code id="plotLL_+3A_param1sequence">param1sequence</code>, <code id="plotLL_+3A_param2sequence">param2sequence</code></td>
<td>

<p>the sequence of points from with the log likelihood is computed. If left empty, the log likelihood will be computed at 21 points spanning between MLE-3*SD and MLE+3*SD in the one dimensional case, and the 11x11 points for the same range in the two dimensional case.
</p>
</td></tr>
<tr><td><code id="plotLL_+3A_startpoint">startpoint</code></td>
<td>

<p>a vector of size equal to the number of parameters in the model. If this is supplied, the log likelihood will be evaluated at this point instead of the point of the MLE (for the parameters not in <code>parameter1</code> and <code>parameter2</code>).
</p>
</td></tr>
<tr><td><code id="plotLL_+3A_returnoutput">returnOutput</code></td>
<td>

<p>a logical flag. If set to <code>TRUE</code>, the values of the response surface will be returned. See 'value' below.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Only if <code>returnOutput = TRUE</code>
</p>
<p>1. For the one dimensional case: a data.frame with the columns 'logLikelihood', and 'param1sequence' for all the values of the <code>parameter1</code> witch the log likelihood was evaluated at
</p>
<p>2. For the two dimensional case: 
a list with the following items:
</p>
<table role = "presentation">
<tr><td><code>para1</code></td>
<td>

<p>a vector with the sequence of the <code>parameter1</code> values.
</p>
</td></tr>
<tr><td><code>para2</code></td>
<td>

<p>a vector with the sequence of the <code>parameter2</code> values.
</p>
</td></tr>
<tr><td><code>z</code></td>
<td>

<p>a matrix with the log likelihood values. The element at the ith row and jth column is evaluated at the ith <code>para1</code> value and jth <code>para2</code> value.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Markus Belfrage
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

#Indicates identification issues with the generelized gamma distibution:
#(Try a diffrent 'startPara' in acdFit() to get slightly a better fit)
fitModel2 &lt;- acdFit(durations = adjDurData[1:3000, ], dist = "gengamma")
seq1 &lt;- seq(500, 1000, 50)
seq2 &lt;- seq(.02, 0.045, 0.001)
plotLL(fitModel = fitModel2, parameter1 = "kappa", parameter2 = "gamma", 
       param1sequence = seq1, param2sequence = seq2)

## End(Not run)
</code></pre>

<hr>
<h2 id='plotRollMeanAcd'>
Plots rolling means of durations
</h2><span id='topic+plotRollMeanAcd'></span>

<h3>Description</h3>

<p>Plots rolling means of durations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotRollMeanAcd(durations, window = 500)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plotRollMeanAcd_+3A_durations">durations</code></td>
<td>

<p>a data.frame containing the column 'time' and 'durations'.
</p>
</td></tr>
<tr><td><code id="plotRollMeanAcd_+3A_window">window</code></td>
<td>

<p>the length of the rolling window.
</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>plotRollMeanAcd(durData, window = 500)

</code></pre>

<hr>
<h2 id='plotScatterAcd'>
Scatter plot for ACD models
</h2><span id='topic+plotScatterAcd'></span>

<h3>Description</h3>

<p>Function to help scatter plot different variables of a fitted ACD model and superimposes a smoothed conditional mean using ggplot2. Can be used to investigate the possible need for non-linear models and issues with the diurnal adjustment.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotScatterAcd(fitModel, x = "muHats", y = "residuals", xlag = 0, ylag = 0,
                           colour = NULL, xlim = NULL, ylim = NULL, alpha = 1/10,
                           smoothMethod = "auto")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plotScatterAcd_+3A_fitmodel">fitModel</code></td>
<td>

<p>a fitted model of class &quot;acdFit&quot;
</p>
</td></tr>
<tr><td><code id="plotScatterAcd_+3A_x">x</code></td>
<td>

<p>the variable used on the x-axis. One of &quot;muHats&quot;, &quot;residuals&quot;, &quot;durations&quot;, &quot;adjDur&quot;, &quot;dayTime&quot;, &quot;time&quot;, or &quot;index&quot;.
</p>
</td></tr>
<tr><td><code id="plotScatterAcd_+3A_y">y</code></td>
<td>

<p>the variable used on the y-axis. One of &quot;muHats&quot;, &quot;residuals&quot;, &quot;durations&quot;, &quot;adjDur&quot;, &quot;dayTime&quot;, &quot;time&quot;, or &quot;index&quot;.
</p>
</td></tr>
<tr><td><code id="plotScatterAcd_+3A_xlag">xlag</code></td>
<td>

<p>number of lags used for the variable shown on the x-axis.
</p>
</td></tr>
<tr><td><code id="plotScatterAcd_+3A_ylag">ylag</code></td>
<td>

<p>number of lags used for the variable shown on the y-axis.
</p>
</td></tr>
<tr><td><code id="plotScatterAcd_+3A_colour">colour</code></td>
<td>

<p>a possible third variable to be represented with a colour scale. One of &quot;muHats&quot;, &quot;residuals&quot;, &quot;durations&quot;, &quot;adjDur&quot;, &quot;dayTime&quot;, or &quot;time&quot;.
</p>
</td></tr>
<tr><td><code id="plotScatterAcd_+3A_xlim">xlim</code></td>
<td>

<p>a vector of the limits of the x-axis to possibly zoom in on a certain region.
</p>
</td></tr>
<tr><td><code id="plotScatterAcd_+3A_ylim">ylim</code></td>
<td>

<p>a vector of the limits of the y-axis to possibly zoom in on a certain region.
</p>
</td></tr>
<tr><td><code id="plotScatterAcd_+3A_alpha">alpha</code></td>
<td>

<p><code>alpha</code> parameter passed to ggplot2. For large data sets many data points will overlap. The alpha parameter can make the points transparent, making it easier to distinguish the density of different region. Takes the value between 1 (opaque) and 0 (completely transparent).
</p>
</td></tr>
<tr><td><code id="plotScatterAcd_+3A_smoothmethod">smoothMethod</code></td>
<td>

<p>value passed as <code>smooth</code> argument to ggplot2. See stat_smooth.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Markus Belfrage
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

# The mean residuals are too small for small values of the estimated conditional 
# mean, suggesting a need for a different conditional mean model specification:
fitModel &lt;- acdFit(adjDurData)
plotScatterAcd(fitModel, x = "muHats", y = "residuals")

## End(Not run)
</code></pre>

<hr>
<h2 id='qqplotAcd'>
Quantile-Quantile plot of the residuals
</h2><span id='topic+qqplotAcd'></span>

<h3>Description</h3>

<p>Plots a QQ-plot of the residuals and the theoretical quantiles implied by the model estimates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qqplotAcd(fitModel, xlim = NULL, ylim = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="qqplotAcd_+3A_fitmodel">fitModel</code></td>
<td>

<p>a fitted ACD model, i.e. an object of class &quot;acdFit&quot;
</p>
</td></tr>
<tr><td><code id="qqplotAcd_+3A_xlim">xlim</code></td>
<td>

<p>an optional vector of limits for the x-axis
</p>
</td></tr>
<tr><td><code id="qqplotAcd_+3A_ylim">ylim</code></td>
<td>

<p>an optional vector of limits for the y-axis
</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>fitModelExp &lt;- acdFit(adjDurData, dist = "exp")
qqplotAcd(fitModelExp)
</code></pre>

<hr>
<h2 id='qWeibullDist'>
The q-Weibull distribution
</h2><span id='topic+qWeibullDist'></span><span id='topic+dqweibull'></span><span id='topic+pqweibull'></span><span id='topic+qqweibull'></span><span id='topic+rqweibull'></span><span id='topic+qweibullExpectation'></span><span id='topic+qweibullHazard'></span>

<h3>Description</h3>

<p>Density (PDF), distribution function (CDF), quantile function (inverted CDF), random generation, exepcted value, and hazard function for the q-Weibull distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dqweibull(x, a = .8, qdist = 1.2, b = 1, forceExpectation = F)
pqweibull(q, a = .8, qdist = 1.2, b = 1, forceExpectation = F)
qqweibull(p, a = .8, qdist = 1.2, b = 1, forceExpectation = F)
rqweibull(n = 1, a = .8, qdist = 1.2, b = 1, forceExpectation = F)
qweibullExpectation(a = .8, qdist = 1.2, b = 1)
qweibullHazard(x, a = .8, qdist = 1.2, b = 1, forceExpectation = F)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="qWeibullDist_+3A_x">x</code>, <code id="qWeibullDist_+3A_q">q</code></td>
<td>

<p>vector of quantiles.
</p>
</td></tr>
<tr><td><code id="qWeibullDist_+3A_p">p</code></td>
<td>

<p>vector of probabilities.
</p>
</td></tr>
<tr><td><code id="qWeibullDist_+3A_n">n</code></td>
<td>

<p>number of observations.
</p>
</td></tr>
<tr><td><code id="qWeibullDist_+3A_a">a</code>, <code id="qWeibullDist_+3A_qdist">qdist</code>, <code id="qWeibullDist_+3A_b">b</code></td>
<td>

<p>parameters, see 'Details'.
</p>
</td></tr>
<tr><td><code id="qWeibullDist_+3A_forceexpectation">forceExpectation</code></td>
<td>

<p>logical; if <code>TRUE</code>, the expectation of the distribution is forced to be 1 by letting <code>b</code> be a function of the other parameters.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The PDF for the q-Weibull distribution is:
</p>
<p style="text-align: center;"><code class="reqn">f(\epsilon) = (2-q)\frac{a}{b^a} \epsilon^{a-1} \left[1-(1-q)\left(\frac{\epsilon}{b}\right)^a\right]^{\frac{1}{1-q}}</code>
</p>

<p>The distribution was used for ACD models by Vuorenmaa (2009).
</p>


<h3>References</h3>

<p>Vuorenmaa, T. (2009) 
<em>A q-Weibull Autoregressive Conditional Duration Model with an Application to NYSE and HSE data.</em> Available at SSRN: http://ssrn.com/abstract=1952550.
</p>

<hr>
<h2 id='resiDensityAcd'>
Residual Density Histogram
</h2><span id='topic+resiDensityAcd'></span>

<h3>Description</h3>

<p>Plots a density histogram of the residuals and superimposes the density implied by the model estimates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>resiDensityAcd(fitModel, xlim = NULL, binwidth = .1, density = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="resiDensityAcd_+3A_fitmodel">fitModel</code></td>
<td>

<p>a fitted ACD model, i.e. an object of class &quot;acdFit&quot;
</p>
</td></tr>
<tr><td><code id="resiDensityAcd_+3A_xlim">xlim</code></td>
<td>

<p>an optional vector of limits for the x-axis
</p>
</td></tr>
<tr><td><code id="resiDensityAcd_+3A_binwidth">binwidth</code></td>
<td>

<p>the width of the bins of the density histogram.
</p>
</td></tr>
<tr><td><code id="resiDensityAcd_+3A_density">density</code></td>
<td>

<p>if <code>TRUE</code> a kernel density estimate will be added
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Markus Belfrage
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
fitModelBurr &lt;- acdFit(adjDurData, dist = "burr")
resiDensityAcd(fitModelBurr)
## End(Not run)
</code></pre>

<hr>
<h2 id='sim_ACD'>
ACD simulation
</h2><span id='topic+sim_ACD'></span>

<h3>Description</h3>

<p>Simulates a sample from a specified ACD <code>model</code> and error term distribution <code>dist</code>. The error terms can also be sampled from residuals. The possibility of including a diurnal seasonal component in the simulated sample is included.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>    
sim_ACD(N = 1000, model = "ACD", dist = "exponential", param = NULL, order = NULL,
    Nburn = 50, startX = c(1), startMu = c(1), errors = NULL, sampleErrors = TRUE, 
    roundToSec = FALSE, rm0 = FALSE, diurnalFactor = FALSE, splineObj = NULL,
    open = NULL, close = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sim_ACD_+3A_n">N</code></td>
<td>

<p>sample size
</p>
</td></tr>
<tr><td><code id="sim_ACD_+3A_model">model</code></td>
<td>

<p>the class of conditional mean duration specification. One of <code>"ACD"</code>, <code>"LACD1"</code>, <code>"LACD2"</code>, <code>"AMACD"</code>,<code>"ABACD"</code>, <code>"SNIACD"</code> or <code>"LSNIACD"</code>.
</p>
</td></tr>
<tr><td><code id="sim_ACD_+3A_dist">dist</code></td>
<td>

<p>the distribution of the error terms (only if <code>errors</code> are left out). Must be one of <code>"exponential"</code>, <code>"weibull"</code>, <code>"burr"</code>, <code>"gengamma"</code> or <code>"genf"</code>.
</p>
</td></tr>
<tr><td><code id="sim_ACD_+3A_param">param</code></td>
<td>

<p>a vector of the parameters of the DGP (data generating process).
</p>
</td></tr>
<tr><td><code id="sim_ACD_+3A_order">order</code></td>
<td>

<p>a vector describing the order of the conditional mean duration specification, e.g. <code>order = c(1,1)</code> for an ACD(1,1) model.
</p>
</td></tr>
<tr><td><code id="sim_ACD_+3A_nburn">Nburn</code></td>
<td>

<p>the number of burned observations. Used to lower the effect of the start values of the simulated series. 
</p>
</td></tr>
<tr><td><code id="sim_ACD_+3A_startx">startX</code></td>
<td>

<p>a vector of values to start the simulation from.
</p>
</td></tr>
<tr><td><code id="sim_ACD_+3A_startmu">startMu</code></td>
<td>

<p>a vector of conditional mean values to start the simulation from.
</p>
</td></tr>
<tr><td><code id="sim_ACD_+3A_errors">errors</code></td>
<td>

<p>a vector of error terms. If provided and <code>sampleErrors = TRUE</code> the errors will be sampled from this vector (with replacement). If instead <code>sampleErrors = FALSE</code> the error terms will be matched by the <code>errors</code> vector non stochastic (must then be of the same length as <code>N + Nburn</code>)
</p>
</td></tr>
<tr><td><code id="sim_ACD_+3A_sampleerrors">sampleErrors</code></td>
<td>

<p>logical flag, see <code>errors</code> above. Default is <code>TRUE</code>.
</p>
</td></tr>
<tr><td><code id="sim_ACD_+3A_roundtosec">roundToSec</code></td>
<td>

<p>if <code>TRUE</code> the simulated sample will be discretized with 1 second(unit) precision.
</p>
</td></tr>
<tr><td><code id="sim_ACD_+3A_rm0">rm0</code></td>
<td>

<p>if <code>TRUE</code> zero durations will be removed. Will the result in a smaller sample than <code>N</code>.
</p>
</td></tr>
<tr><td><code id="sim_ACD_+3A_diurnalfactor">diurnalFactor</code></td>
<td>

<p>if <code>TRUE</code> the simulated data will include a diurnal factor. The diurnal factor is from a fitted cubic spline given as argument to <code>splineObj</code>. If the argument <code>splineObj</code> is empty, a default fitted cubic spline from <code>transData</code> using aggregation over weekdays will be used.
</p>
</td></tr>
<tr><td><code id="sim_ACD_+3A_splineobj">splineObj</code></td>
<td>

<p>a cubic spline return by <code>diurnalAdj()</code>. Currently only works with cubic splines fitted with weekday aggregation. Also see <code>diurnalFactor</code> above.
</p>
</td></tr>
<tr><td><code id="sim_ACD_+3A_open">open</code></td>
<td>

<p>only used if <code>diurnalFactor = TRUE</code> and a <code>splineObj</code> were provided. The time the exchange opens trading (as used in the fitted <code>splineObj</code>), for example <code>open = "10:00:00"</code>.
</p>
</td></tr>
<tr><td><code id="sim_ACD_+3A_close">close</code></td>
<td>

<p>only used if <code>diurnalFactor = TRUE</code> and a <code>splineObj</code> were provided. The time the exchange close trading (as used in the fitted <code>splineObj</code>), for example <code>close = "18:25:00"</code>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a numerical vector of simulated ACD durations
</p>


<h3>Author(s)</h3>

<p>Markus Belfrage
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- sim_ACD() #simulates 1000 observations from an ACD(1,1) with exp. errors as default
acdFit(x)


</code></pre>

<hr>
<h2 id='standardizeResi'>
Residual standardization
</h2><span id='topic+standardizeResi'></span>

<h3>Description</h3>

<p>Standardizes residuals from a fitted ACD model of class 'acdFit' by a probability integral transformation (taking the CDF, using the estimated distribution parameters, of the residuals) or by returning the Cox-Snell residuals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>standardizeResi(fitModel, transformation = "probIntegral")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="standardizeResi_+3A_fitmodel">fitModel</code></td>
<td>

<p>a fitted ACD model of class 'acdFit'.
</p>
</td></tr>
<tr><td><code id="standardizeResi_+3A_transformation">transformation</code></td>
<td>

<p>type of transformation done, either &quot;probIntegral&quot;, or &quot;cox-snell&quot;.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The probability integral transformation is done by taking the CDF of the residuals from the model estimation, using the estimated distribution parameters. Under correct specification the probability integral transformed residuals should be iid. uniform(0, 1). 
</p>
<p>The Cox-Snell residuals is the computed by taking the integrated hazard of the residuals from the model estimation, using the estimated distribution parameters. Under correct specification the probability integral transformed residuals should be iid. unit exponentially distributed. 
</p>

<hr>
<h2 id='testRmACD'>
LM test of no Remaining ACD (Meitz and Terasvirta, 2006)
</h2><span id='topic+testRmACD'></span>

<h3>Description</h3>

<p>Tests if there is any remaining ACD structure in the residuals
</p>


<h3>Usage</h3>

<pre><code class='language-R'>testRmACD(fitModel, pStar = 2, robust = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="testRmACD_+3A_fitmodel">fitModel</code></td>
<td>

<p>a fitted ACD model, i.e. an object of class &quot;acdFit&quot;.
</p>
</td></tr>
<tr><td><code id="testRmACD_+3A_pstar">pStar</code></td>
<td>

<p>the number of alpha parameters in the alternative hypothesis. See <code class="reqn">p*</code> under 'Details'.
</p>
</td></tr>
<tr><td><code id="testRmACD_+3A_robust">robust</code></td>
<td>

<p>if <code>TRUE</code> the LM statistic will be calculated using the &quot;robust&quot; version, making its asymptotic behavior unaffected by possible misspecification of the error term distribution (Meitz and Terasvirta, 2006).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For the model
</p>
<p style="text-align: center;"><code class="reqn">x_i = \mu_i \phi_i \epsilon_i,</code>
</p>

<p style="text-align: center;"><code class="reqn">\mu_i = \omega + \sum_{j=1}^{p} \alpha_j x_{i-j} + \sum_{j=1}^{q} \beta_j \mu_{i-j},</code>
</p>

<p style="text-align: center;"><code class="reqn">\phi_i = 1 + \sum_{j=1}^{p*} \frac{x_{i-j}}{\mu_{i-j}},</code>
</p>

<p>the function tests the null hypothesis
</p>
<p style="text-align: center;"><code class="reqn">H_0: \phi_i = 1.</code>
</p>



<h3>Value</h3>

<p>a list containing:
</p>
<table role = "presentation">
<tr><td><code>chi2</code></td>
<td>

<p>the value of the LM statistic.
</p>
</td></tr>
<tr><td><code>pv</code></td>
<td>

<p>the pvalue of the test statistic.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Markus Belfrage
</p>


<h3>References</h3>

<p>Meitz, M. and Terasvirta, T. (2006).
<em>Evaluating models of autoregressive conditional duration</em>. Journal of Business and Economic Statistics 24: 104-124. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+testTVACD">testTVACD</a></code>, <code><a href="#topic+testSTACD">testSTACD</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fitModel3000obs &lt;- acdFit(adjDurData[1:3000,])
testRmACD(fitModel3000obs, pStar = 2, robust = TRUE)
</code></pre>

<hr>
<h2 id='testSTACD'>
LM test against Smooth Transition ACD models (Meitz and Terasvirta, 2006)
</h2><span id='topic+testSTACD'></span>

<h3>Description</h3>

<p>Tests if the alpha parameters and the constant should be varying with the value of the lagged durations, according to a logistic transition function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>testSTACD(fitModel, K = 2, robust = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="testSTACD_+3A_fitmodel">fitModel</code></td>
<td>

<p>a fitted ACD model, i.e. an object of class &quot;acdFit&quot;.
</p>
</td></tr>
<tr><td><code id="testSTACD_+3A_k">K</code></td>
<td>

<p>the order of the logistic transition function used for the alternative hypothesis.
</p>
</td></tr>
<tr><td><code id="testSTACD_+3A_robust">robust</code></td>
<td>

<p>if <code>TRUE</code> the LM statistic will be calculated using the &quot;robust&quot; version, making its asymptotic behavior unaffected by possible misspecification of the error term distribution (Meitz and Terasvirta, 2006).
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of:
</p>
<table role = "presentation">
<tr><td><code>chi2</code></td>
<td>

<p>the value of the LM statistic.
</p>
</td></tr>
<tr><td><code>pv</code></td>
<td>

<p>the pvalue of the test statistic.
</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+testRmACD">testRmACD</a></code>, <code><a href="#topic+testTVACD">testTVACD</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fitModel3000obs &lt;- acdFit(adjDurData[1:3000,])
testSTACD(fitModel3000obs, K = 2, robust = TRUE)

</code></pre>

<hr>
<h2 id='testTVACD'>
LM test against Time-Varying ACD models (Meitz and Terasvirta, 2006)
</h2><span id='topic+testTVACD'></span>

<h3>Description</h3>

<p>Tests if the parameters are time-varying.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>testTVACD(fitModel, K = 2, type = "total", robust = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="testTVACD_+3A_fitmodel">fitModel</code></td>
<td>

<p>a fitted ACD model, i.e. an object of class &quot;acdFit&quot;.
</p>
</td></tr>
<tr><td><code id="testTVACD_+3A_k">K</code></td>
<td>

<p>the order of the logistic transition function used for the alternative hypothesis.
</p>
</td></tr>
<tr><td><code id="testTVACD_+3A_type">type</code></td>
<td>

<p>either &quot;total&quot; or &quot;intraday&quot;. If &quot;total&quot;, the possible time varying parameters under the alternative varies over the total time of the sample, whereas for &quot;intraday&quot;, the time variable is time of the day. See 'Details'
</p>
</td></tr>
<tr><td><code id="testTVACD_+3A_robust">robust</code></td>
<td>

<p>if <code>TRUE</code> the LM statistic will be calculated using the &quot;robust&quot; version, making its asymptotic behavior unaffected by possible misspecification of the error term distribution (Meitz and Terasvirta, 2006).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function tests the fitted standard ACD model against the TVACD model of Meitz and Terasvirta (2006). The TVACD model lets the ACD parameters vary over time by a logistic transition function.
</p>
<p>In one specification, the time variable is total time, and a test rejecting the null in favor of this alternative specification would indicate that the ACD parameters are changing over time over the total sample.
</p>
<p>The other specification lets the parameters be intraday varying, by letting the transition variable be the time of the day. Failing this test could indicate that the diurnal adjustment was inadequate at removing any diurnal component. 
</p>


<h3>Value</h3>

<p>a list of:
</p>
<table role = "presentation">
<tr><td><code>chi2</code></td>
<td>

<p>the value of the LM statistic.
</p>
</td></tr>
<tr><td><code>pv</code></td>
<td>

<p>the pvalue of the test statistic.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Markus Belfrage
</p>


<h3>References</h3>

<p>Meitz, M. and Terasvirta, T. (2006).
<em>Evaluating models of autoregressive conditional duration</em>. Journal of Business and Economic Statistics 24: 104-124. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+testRmACD">testRmACD</a></code>, <code><a href="#topic+testSTACD">testSTACD</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fitModel5000obs &lt;- acdFit(adjDurData[1:5000,])
testTVACD(fitModel5000obs, K = 2, type = "total", robust = TRUE)

testTVACD(fitModel5000obs, K = 2, type = "intraday", robust = TRUE)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
