<!DOCTYPE html><html><head><title>Help for package INLAspacetime</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {INLAspacetime}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#ar2cor'><p>Illustrative code to compute the auto-correlation for an AR2 model.</p></a></li>
<li><a href='#ar2precision'><p>Precision matrix for an AR2 model.</p></a></li>
<li><a href='#barrierModel.define'><p>Define a spacetime model object for the <code>f()</code> call.</p></a></li>
<li><a href='#bru_get_mapper.stModel_cgeneric'><p>Mapper object for automatic inlabru interface</p></a></li>
<li><a href='#cWhittleMatern'><p>Computes the Whittle-Matern correlation function.</p></a></li>
<li><a href='#downloadUtilFiles'><p>Donload the data files used</p></a></li>
<li><a href='#ghcndSelect'><p>Select data from the daily dataset</p></a></li>
<li><a href='#Heron'><p>Internal util functions</p></a></li>
<li><a href='#INLAspacetime'><p>Spatial and Spatio-Temporal Models using INLA</p></a></li>
<li><a href='#Jmatrices'><p>The 2nd order temporal matrices with boundary correction</p></a></li>
<li><a href='#mesh.dual'><p>Extracts the dual of a mesh object.</p></a></li>
<li><a href='#mesh2d'><p>Illustrative code for building a mesh in 2d domain.</p></a></li>
<li><a href='#mesh2fem'><p>Illustrative code for Finite Element matrices of a mesh in 2d domain.</p></a></li>
<li><a href='#mesh2projector'><p>Illustrative code to build the projector matrix for SPDE models.</p></a></li>
<li><a href='#outDetect'><p>Detect outliers in a time series considering the raw data</p>
and a smoothed version of it.</a></li>
<li><a href='#paramsUtils'><p>Funtions to help converting from/to user/internal parametrization.</p></a></li>
<li><a href='#spde2precision'><p>Illustrative code to build the precision matrix for SPDE kind models.</p></a></li>
<li><a href='#stats.inla'><p>To retrieve goodness of fit statistics.</p></a></li>
<li><a href='#stdSubs'><p>To check unusual low/high variance segments</p></a></li>
<li><a href='#stlines'><p>To visualize time series over space.</p></a></li>
<li><a href='#stModel.define'><p>Define a spacetime model object for the <code>f()</code> call.</p></a></li>
<li><a href='#stModel.matrices'><p>Define the spacetime model matrices.</p></a></li>
<li><a href='#stModel.precision'><p>Spacetime precision matrix.</p></a></li>
<li><a href='#upperPadding'><p>Prepare a matrix or a list of matrices</p>
for use in some cgeneric code.</a></li>
<li><a href='#worldMap'><p>Get the world map</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Spatial and Spatio-Temporal Models using 'INLA'</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.7</td>
</tr>
<tr>
<td>Description:</td>
<td>Prepare objects to implement models over spatial and 
  spacetime domains with the 'INLA' package (<a href="https://www.r-inla.org">https://www.r-inla.org</a>).
  These objects contain data to for the 'cgeneric' interface in
  'INLA', enabling fast parallel computations.
  We implemented the spatial barrier model, see Bakka et. al. (2019) 
  &lt;<a href="https://doi.org/10.1016%2Fj.spasta.2019.01.002">doi:10.1016/j.spasta.2019.01.002</a>&gt;, and some of the spatio-temporal 
  models in Lindgren et. al. (2023) &lt;<a href="https://arxiv.org/abs/2006.04917">arXiv:2006.04917</a>&gt;. 
  Details are provided in the available vignettes and from the URL bellow.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/eliaskrainski/INLAspacetime">https://github.com/eliaskrainski/INLAspacetime</a></td>
</tr>
<tr>
<td>Additional_repositories:</td>
<td><a href="https://inla.r-inla-download.org/R/testing">https://inla.r-inla-download.org/R/testing</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/eliaskrainski/INLAspacetime/issues">https://github.com/eliaskrainski/INLAspacetime/issues</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.6), Matrix, sp</td>
</tr>
<tr>
<td>Imports:</td>
<td>graphics, grDevices, methods, stats, utils, sf, fmesher</td>
</tr>
<tr>
<td>Suggests:</td>
<td>INLA (&ge; 23.03.26), inlabru (&ge; 2.8.0), knitr, ggplot2,
rmarkdown, parallel, data.table, rnaturalearth, splancs</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>BuildVignettes:</td>
<td>true</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-08-27 08:26:58 UTC; eliask</td>
</tr>
<tr>
<td>Author:</td>
<td>Elias Teixeira Krainski
    <a href="https://orcid.org/0000-0002-7063-2615"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [cre, aut,
    cph],
  Finn Lindgren <a href="https://orcid.org/0000-0002-5833-2011"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Haavard Rue <a href="https://orcid.org/0000-0002-0222-1881"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Elias Teixeira Krainski &lt;eliaskrainski@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-08-27 23:10:06 UTC</td>
</tr>
</table>
<hr>
<h2 id='ar2cor'>Illustrative code to compute the auto-correlation for an AR2 model.</h2><span id='topic+ar2cor'></span>

<h3>Description</h3>

<p>Computes the auto-correlation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ar2cor(a1, a2, k = 30)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ar2cor_+3A_a1">a1</code></td>
<td>
<p>the first auto-regression coefficient.</p>
</td></tr>
<tr><td><code id="ar2cor_+3A_a2">a2</code></td>
<td>
<p>the second auto-regression coefficient.</p>
</td></tr>
<tr><td><code id="ar2cor_+3A_k">k</code></td>
<td>
<p>maximun length for evaluating the auto-correlation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the autocorrelation as a vector or matrix, whenever <code>a1</code> or <code>a2</code> are
scalar or vector.
</p>


<h3>Details</h3>

<p>Let the second order auto-regression model defined as
<code style="white-space: pre;">&#8288;x_t + a_1 x_{t-1} + a_2 x_{t-2} = w_t&#8288;</code>
where <code>w_t ~ N(0, 1)</code>.
</p>


<h3>See Also</h3>

<p><a href="#topic+ar2precision">ar2precision</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>plot(ar2cor(-1.7, 0.963), type = "o")
</code></pre>

<hr>
<h2 id='ar2precision'>Precision matrix for an AR2 model.</h2><span id='topic+ar2precision'></span>

<h3>Description</h3>

<p>Creates a precision matrix as a sparse matrix object
considering the specification stated in details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ar2precision(n, a)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ar2precision_+3A_n">n</code></td>
<td>
<p>the size of the model.</p>
</td></tr>
<tr><td><code id="ar2precision_+3A_a">a</code></td>
<td>
<p>the length three vector with the coefficients. See details.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the precision matrix as a sparse matrix object with edge correction.
</p>


<h3>Details</h3>

<p>Let the second order auto-regression model be defined as
</p>
<p style="text-align: center;"><code class="reqn">a_0 x_t + a_1 x_{t-1} + a_2 x_{t-2} = w_t, w_t ~ N(0, 1).</code>
</p>

<p>The n times n symmetric precision matrix Q
for x_1, x_2, ..., x_n
has the following non-zero elements:
</p>
<p><code class="reqn">Q_{1,1} = Q_{n,n} = a_0^2</code>
</p>
<p><code class="reqn">Q_{2,2} = Q_{n-1,n-1} = a_0^2 + a_1^2</code>
</p>
<p><code class="reqn">Q_{1,2} = Q_{2,1} = Q_{n-1,n} = Q_{n,n-1} = a_0 a_1</code>
</p>
<p><code class="reqn">Q_{t,t} = q_0 = a_0^2 + a_1^2 + a_2^2, t = 3, 4, ..., n-2</code>
</p>
<p><code class="reqn">Q_{t,t-1} = Q_{t-1,t} = q_1 = a_1(a_0 + a_2), t = 3, 4, ..., n-1</code>
</p>
<p><code class="reqn">Q_{t,t-2} = Q_{t-2,t} = q_2 = a_2 a_0, t = 3, 4, ..., n</code>
</p>


<h3>See Also</h3>

<p><a href="#topic+ar2cor">ar2cor</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ar2precision(7, c(1, -1.5, 0.9))
</code></pre>

<hr>
<h2 id='barrierModel.define'>Define a spacetime model object for the <code>f()</code> call.</h2><span id='topic+barrierModel.define'></span>

<h3>Description</h3>

<p>Define a spacetime model object for the <code>f()</code> call.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>barrierModel.define(
  mesh,
  barrier.triangles,
  prior.range,
  prior.sigma,
  range.fraction = 0.2,
  constr = FALSE,
  debug = FALSE,
  verbose = FALSE,
  useINLAprecomp = TRUE,
  libpath = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="barrierModel.define_+3A_mesh">mesh</code></td>
<td>
<p>a spatial mesh</p>
</td></tr>
<tr><td><code id="barrierModel.define_+3A_barrier.triangles">barrier.triangles</code></td>
<td>
<p>a integer vector to specify which
triangles centers are in the barrier domain</p>
</td></tr>
<tr><td><code id="barrierModel.define_+3A_prior.range">prior.range</code></td>
<td>
<p>numeric vector containing U and a
to define the probability statements P(range &lt; U) = a
used to setup the PC-prior for range.
If a = 0 then U is taken to be the fixed value for the range.</p>
</td></tr>
<tr><td><code id="barrierModel.define_+3A_prior.sigma">prior.sigma</code></td>
<td>
<p>numeric vector containing U and a
to define the probability statements P(range &gt; U) = a
used to setup the PC-prior for sigma.
If a = 0 then U is taken to be the fixed value for sigma.</p>
</td></tr>
<tr><td><code id="barrierModel.define_+3A_range.fraction">range.fraction</code></td>
<td>
<p>numeric to specify the fraction of the range
for the barrier domain. Default value is 0.2.</p>
</td></tr>
<tr><td><code id="barrierModel.define_+3A_constr">constr</code></td>
<td>
<p>logical to indicate if the integral of the field
over the domain is to be constrained to zero. Default value is FALSE.</p>
</td></tr>
<tr><td><code id="barrierModel.define_+3A_debug">debug</code></td>
<td>
<p>logical indicating if to run in debug mode.</p>
</td></tr>
<tr><td><code id="barrierModel.define_+3A_verbose">verbose</code></td>
<td>
<p>logical indicating if to print parameter values.</p>
</td></tr>
<tr><td><code id="barrierModel.define_+3A_useinlaprecomp">useINLAprecomp</code></td>
<td>
<p>logical indicating if is to be used
shared object pre-compiled by INLA. Not considered if
libpath is provided.</p>
</td></tr>
<tr><td><code id="barrierModel.define_+3A_libpath">libpath</code></td>
<td>
<p>string to the shared object. Default is NULL.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See the paper.
</p>


<h3>Value</h3>

<p>objects to be used in the f() formula term in INLA.
</p>

<hr>
<h2 id='bru_get_mapper.stModel_cgeneric'>Mapper object for automatic inlabru interface</h2><span id='topic+bru_get_mapper.stModel_cgeneric'></span><span id='topic+bru_get_mapper'></span>

<h3>Description</h3>

<p>Return an <code>inlabru</code> <code>bru_mapper</code> object that can be used for computing
model matrices for the space-time model components.  The <code>bru_get_mapper()</code>
function is called by the <code>inlabru</code> methods to automatically obtain the
needed mapper object (from <code>inlabru</code> <code style="white-space: pre;">&#8288;2.7.0.9001&#8288;</code>; before that, use
<code>mapper = bru_get_mapper(model)</code> explicitly).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bru_get_mapper.stModel_cgeneric(model, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bru_get_mapper.stModel_cgeneric_+3A_model">model</code></td>
<td>
<p>The model object (of class <code>stModel_cgeneric</code>, from
<code>stModel.define</code> or <code>barrierModel_cgeneric</code>, from <code>barrierModel.define</code>)</p>
</td></tr>
<tr><td><code id="bru_get_mapper.stModel_cgeneric_+3A_...">...</code></td>
<td>
<p>Unused.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>bru_mapper</code> object of class <code>bru_mapper_multi</code> with
sub-mappers <code>space</code> and <code>time</code> based on the model <code>smesh</code> and <code>tmesh</code>
or <code>mesh</code> objects.
</p>


<h3>See Also</h3>

<p><code><a href="inlabru.html#topic+bru_get_mapper">inlabru::bru_get_mapper()</a></code>
</p>

<hr>
<h2 id='cWhittleMatern'>Computes the Whittle-Matern correlation function.</h2><span id='topic+cWhittleMatern'></span>

<h3>Description</h3>

<p>This computes the correlation function as derived in Matern model,
see Matern (1960) eq. (2.4.7).
For nu=1, see Whittle (1954) eq. (68).
For the limiting case of nu=0, see Besag (1981) eq. (14-15).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cWhittleMatern(x, range, nu, kappa = sqrt(8 * nu)/range)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cWhittleMatern_+3A_x">x</code></td>
<td>
<p>distance.</p>
</td></tr>
<tr><td><code id="cWhittleMatern_+3A_range">range</code></td>
<td>
<p>practical range (our prefered parametrization) given as
range = sqrt(8 * nu) / kappa,
where kappa is the scale parameter in the specialized references.</p>
</td></tr>
<tr><td><code id="cWhittleMatern_+3A_nu">nu</code></td>
<td>
<p>process smoothness parameter.</p>
</td></tr>
<tr><td><code id="cWhittleMatern_+3A_kappa">kappa</code></td>
<td>
<p>scale parameter, commonly considered in the specialized literature.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the correlation.
</p>


<h3>Details</h3>

<p>Whittle, P. (1954) On Stationary Processes in the Plane.
Biometrika, Vol. 41, No. 3/4, pp. 434-449.
http://www.jstor.org/stable/2332724
</p>
<p>Matern, B. (1960) Spatial Variation: Stochastic models and their application to
some problems in forest surveys and other sampling investigations. PhD Thesis.
</p>
<p>Besag, J. (1981) On a System of Two-Dimensional Recurrence Equations.
JRSS-B, Vol. 43 No. 3, pp. 302-309. https://www.jstor.org/stable/2984940
</p>


<h3>Examples</h3>

<pre><code class='language-R'>plot(function(x) cWhittleMatern(x, 1, 5),
  bty = "n", las = 1,
  xlab = "Distance", ylab = "Correlation"
)
plot(function(x) cWhittleMatern(x, 1, 1), add = TRUE, lty = 2)
plot(function(x) cWhittleMatern(x, 1, 0.5), add = TRUE, lty = 3)
abline(h = 0.139, lty = 3, col = gray(0.5, 0.5))
</code></pre>

<hr>
<h2 id='downloadUtilFiles'>Donload the data files used</h2><span id='topic+downloadUtilFiles'></span><span id='topic+donwloadUtilFiles'></span>

<h3>Description</h3>

<p>Donload the data files used
</p>


<h3>Usage</h3>

<pre><code class='language-R'>downloadUtilFiles(data.dir, year = 2022, force = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="downloadUtilFiles_+3A_data.dir">data.dir</code></td>
<td>
<p>the folder to store the files.</p>
</td></tr>
<tr><td><code id="downloadUtilFiles_+3A_year">year</code></td>
<td>
<p>the year of the daily weather data.</p>
</td></tr>
<tr><td><code id="downloadUtilFiles_+3A_force">force</code></td>
<td>
<p>logical indicating if it is to force
the download. If FALSE each file will be downloaded
if it does not exists locally yet.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a named character vector with the local file names:
daily.data, stations.all, elevation.
</p>

<hr>
<h2 id='ghcndSelect'>Select data from the daily dataset</h2><span id='topic+ghcndSelect'></span>

<h3>Description</h3>

<p>Select data from the daily dataset
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ghcndSelect(
  gzfile,
  variable = c("TMIN", "TAVG", "TMAX"),
  qflag = "",
  verbose = TRUE,
  astype = as.integer
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ghcndSelect_+3A_gzfile">gzfile</code></td>
<td>
<p>the local filename for
the daily data file file. E.g. 2023.csv.gz from
<a href="https://www.ncei.noaa.gov/pub/data/ghcn/daily/by_year/">https://www.ncei.noaa.gov/pub/data/ghcn/daily/by_year/</a>
see references bellow.</p>
</td></tr>
<tr><td><code id="ghcndSelect_+3A_variable">variable</code></td>
<td>
<p>string with the variable name(s) to be selected</p>
</td></tr>
<tr><td><code id="ghcndSelect_+3A_qflag">qflag</code></td>
<td>
<p>a string with quality control flag(s)</p>
</td></tr>
<tr><td><code id="ghcndSelect_+3A_verbose">verbose</code></td>
<td>
<p>logical indicating if progress is to be printed</p>
</td></tr>
<tr><td><code id="ghcndSelect_+3A_astype">astype</code></td>
<td>
<p>function to convert data to a class,
default is set to convert the data to integer.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>if more than one variable, it returns an array
whose dimentions are days, stations, variables.
If one variable, then it returns a matrix whose dimentions
are days, stations.
</p>


<h3>Details</h3>

<p>The default selects TMIN, TAVG and TMAX and
return it as integer because the original data is also integer
with units in 10 Celcius degrees.
</p>


<h3>Warning</h3>

<p>It can take time to execute if, for example,
the data.table package is not available.
</p>


<h3>References</h3>

<p>Menne, M., Durre, I., Vose, R., Gleason, B. and Houston, T. (2012)
An overview of the global historical climatology network-daily database.
Journal of Atmospheric and Oceanic Technology, 897–910.
</p>

<hr>
<h2 id='Heron'>Internal util functions</h2><span id='topic+Heron'></span><span id='topic+Area'></span><span id='topic+Stiffness'></span>

<h3>Description</h3>

<p>This computes the area of a triangle given its three coordinates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Heron(x, y)

Area(x, y)

Stiffness(x, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Heron_+3A_x">x</code>, <code id="Heron_+3A_y">y</code></td>
<td>
<p>coordinate vectors.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function used internally to compute the area of a triangle.
</p>


<h3>Value</h3>

<p>the area of a triangle
</p>
<p>the area of a general polygon
</p>
<p>the stiffness matrix for a triangle
</p>


<h3>Warning</h3>

<p>Internal functions, not exported.
</p>

<hr>
<h2 id='INLAspacetime'>Spatial and Spatio-Temporal Models using INLA</h2><span id='topic+INLAspacetime'></span>

<h3>Description</h3>

<p>This package main purpose is to provide user friendly functions
to fit temporal, spatial and spatio-temporal models using the
INLA software available at www.r-inla.org
</p>


<h3>Usage</h3>

<pre><code class='language-R'>INLAspacetime()
</code></pre>


<h3>Value</h3>

<p>opens the Vignettes directory on a browser
</p>

<hr>
<h2 id='Jmatrices'>The 2nd order temporal matrices with boundary correction</h2><span id='topic+Jmatrices'></span>

<h3>Description</h3>

<p>The 2nd order temporal matrices with boundary correction
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Jmatrices(tmesh)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Jmatrices_+3A_tmesh">tmesh</code></td>
<td>
<p>Temporal mesh</p>
</td></tr>
</table>


<h3>Value</h3>

<p>return a list of temporal finite element method matrices
for the supplied mesh.
</p>

<hr>
<h2 id='mesh.dual'>Extracts the dual of a mesh object.</h2><span id='topic+mesh.dual'></span>

<h3>Description</h3>

<p>Extracts the dual of a mesh object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mesh.dual(mesh, SP = TRUE, mc.cores = getOption("mc.cores", 2L))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mesh.dual_+3A_mesh">mesh</code></td>
<td>
<p>a 2d mesh object.</p>
</td></tr>
<tr><td><code id="mesh.dual_+3A_sp">SP</code></td>
<td>
<p>logical indicating if the output is to be returned
as a SpatialPolygons object. Default is TRUE.</p>
</td></tr>
<tr><td><code id="mesh.dual_+3A_mc.cores">mc.cores</code></td>
<td>
<p>number of threads to be used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of polygons or a SpatialPolygons object.
</p>

<hr>
<h2 id='mesh2d'>Illustrative code for building a mesh in 2d domain.</h2><span id='topic+mesh2d'></span>

<h3>Description</h3>

<p>Creates a mesh object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mesh2d(loc, domain, max.edge, offset, SP = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mesh2d_+3A_loc">loc</code></td>
<td>
<p>a two column matrix with location coordinates.</p>
</td></tr>
<tr><td><code id="mesh2d_+3A_domain">domain</code></td>
<td>
<p>a two column matrix defining the domain.</p>
</td></tr>
<tr><td><code id="mesh2d_+3A_max.edge">max.edge</code></td>
<td>
<p>the maximun edge length.</p>
</td></tr>
<tr><td><code id="mesh2d_+3A_offset">offset</code></td>
<td>
<p>the length of the outer extension.</p>
</td></tr>
<tr><td><code id="mesh2d_+3A_sp">SP</code></td>
<td>
<p>logical indicating if the output will include the SpatialPolygons.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a mesh object.
</p>


<h3>Warning</h3>

<p>This is just for illustration purpose and one should consider the
efficient function available a the INLA package.
</p>

<hr>
<h2 id='mesh2fem'>Illustrative code for Finite Element matrices of a mesh in 2d domain.</h2><span id='topic+mesh2fem'></span><span id='topic+mesh2fem.barrier'></span>

<h3>Description</h3>

<p>Illustrative code for Finite Element matrices of a mesh in 2d domain.
</p>
<p>Illustrative code for Finite Element matrices when some triangles are
in a barrier domain.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mesh2fem(mesh, order = 2, barrier.triangles = NULL)

mesh2fem.barrier(mesh, barrier.triangles = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mesh2fem_+3A_mesh">mesh</code></td>
<td>
<p>a 2d mesh object.</p>
</td></tr>
<tr><td><code id="mesh2fem_+3A_order">order</code></td>
<td>
<p>the desired order.</p>
</td></tr>
<tr><td><code id="mesh2fem_+3A_barrier.triangles">barrier.triangles</code></td>
<td>
<p>integer index to specify the
triangles in the barrier domain</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list object containing the FE matrices.
</p>
<p>a list object containing the FE matrices
for the barrier problem.
</p>

<hr>
<h2 id='mesh2projector'>Illustrative code to build the projector matrix for SPDE models.</h2><span id='topic+mesh2projector'></span>

<h3>Description</h3>

<p>Creates a projector matrix object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mesh2projector(
  mesh,
  loc = NULL,
  lattice = NULL,
  xlim = NULL,
  ylim = NULL,
  dims = c(100, 100)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mesh2projector_+3A_mesh">mesh</code></td>
<td>
<p>a 2d mesh object.</p>
</td></tr>
<tr><td><code id="mesh2projector_+3A_loc">loc</code></td>
<td>
<p>a two columns matrix with the locations to project for.</p>
</td></tr>
<tr><td><code id="mesh2projector_+3A_lattice">lattice</code></td>
<td>
<p>Unused; feature not supported by this illustration.</p>
</td></tr>
<tr><td><code id="mesh2projector_+3A_xlim">xlim</code>, <code id="mesh2projector_+3A_ylim">ylim</code></td>
<td>
<p>vector with the boundary limits.</p>
</td></tr>
<tr><td><code id="mesh2projector_+3A_dims">dims</code></td>
<td>
<p>the number of subdivisions over each boundary limits.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the projector matrix as a list with sparse matrix object at <code>x$proj$A</code>..
</p>


<h3>Warning</h3>

<p>This is just for illustration purpose and one should consider the
efficient functions available in the INLA and inlabru packages,
e.g. <code>inlabru::fm_evaluator</code>.
</p>

<hr>
<h2 id='outDetect'>Detect outliers in a time series considering the raw data
and a smoothed version of it.</h2><span id='topic+outDetect'></span>

<h3>Description</h3>

<p>Detect outliers in a time series considering the raw data
and a smoothed version of it.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>outDetect(x, weights = NULL, ff = c(7, 7))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="outDetect_+3A_x">x</code></td>
<td>
<p>numeric vector</p>
</td></tr>
<tr><td><code id="outDetect_+3A_weights">weights</code></td>
<td>
<p>non-increasing numeric vector used as weights for
computing a smoothed vector as a rooling window average.
Default is null and then <code class="reqn">w_j</code> is proportional to j
in the equation in the Details below.</p>
</td></tr>
<tr><td><code id="outDetect_+3A_ff">ff</code></td>
<td>
<p>numeric length two vector with the factors
used to consider how many times the standard deviation
one data point is out to be considered as an outlier.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>logical vector indicating if the data is an outlier
with attributes as detailed bellow.
</p>

<ul>
<li><p> attr(, 'm') is the mean of x.
</p>
</li>
<li><p> attr(, 's') is the standard devation of x.
</p>
</li>
<li><p> attr(, 'ss') is the standard deviation for
the smoothed data <code class="reqn">y_t</code> that is defined as
</p>
</li></ul>

<p><code class="reqn">y_t = \sum_{k=j}^h w_j * (x_{t-j}+x_{t+j})/2</code>
</p>
<p>Both <code>s</code> and <code>ss</code> are used to define outliers if
</p>
<p><code class="reqn">|x_t-m|/s&gt;ff_1</code> or <code class="reqn">|x_t-y_t|/ss&gt;ff_2</code>
</p>

<ul>
<li><p> attr(, 'xs') the smoothed time series <code class="reqn">y_t</code>
</p>
</li></ul>


<hr>
<h2 id='paramsUtils'>Funtions to help converting from/to user/internal parametrization.</h2><span id='topic+paramsUtils'></span><span id='topic+gsConstant'></span><span id='topic+gammas2params'></span><span id='topic+params2gammas'></span>

<h3>Description</h3>

<p>Funtions to help converting from/to user/internal parametrization.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gsConstant(lgammas, alpha, smanifold)

gammas2params(lgammas, alpha.t, alpha.s, alpha.e, smanifold = "R2")

params2gammas(lparams, alpha.t, alpha.s, alpha.e, smanifold = "R2")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="paramsUtils_+3A_lgammas">lgammas</code></td>
<td>
<p>the SPDE parameters log(gamma.s, gamma.t, gamma.e)</p>
</td></tr>
<tr><td><code id="paramsUtils_+3A_alpha">alpha</code></td>
<td>
<p>the resulting spatial order.
Values could be &quot;S1&quot;, &quot;S2&quot;, &quot;R1&quot;, &quot;R2&quot; and &quot;R3&quot;.</p>
</td></tr>
<tr><td><code id="paramsUtils_+3A_smanifold">smanifold</code></td>
<td>
<p>spatial domain manifold.</p>
</td></tr>
<tr><td><code id="paramsUtils_+3A_alpha.t">alpha.t</code></td>
<td>
<p>temporal order of the SPDE</p>
</td></tr>
<tr><td><code id="paramsUtils_+3A_alpha.s">alpha.s</code></td>
<td>
<p>spatial order of the spatial differential operator
in the non-separable part.</p>
</td></tr>
<tr><td><code id="paramsUtils_+3A_alpha.e">alpha.e</code></td>
<td>
<p>spatial order of the spatial differential operator
in the separable part.</p>
</td></tr>
<tr><td><code id="paramsUtils_+3A_lparams">lparams</code></td>
<td>
<p>log(spatial range, temporal range, sigma)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the part of sigma due to spatial constant and gamma.s
</p>
<p>log(spatial range, temporal range, sigma)
</p>
<p>log(gamma.s, gamma.t, gamma.e)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>gammas2params(log(c(0, 0, 0)), 1, 2, 1, "R2")
params2gammas(log(c(1, 1, 1)), 1, 2, 1, "R2")
</code></pre>

<hr>
<h2 id='spde2precision'>Illustrative code to build the precision matrix for SPDE kind models.</h2><span id='topic+spde2precision'></span>

<h3>Description</h3>

<p>Creates a precision matrix as a sparse matrix object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spde2precision(kappa, fem, alpha)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spde2precision_+3A_kappa">kappa</code></td>
<td>
<p>the scale parameter.</p>
</td></tr>
<tr><td><code id="spde2precision_+3A_fem">fem</code></td>
<td>
<p>a list containing the Finite Element matrices.</p>
</td></tr>
<tr><td><code id="spde2precision_+3A_alpha">alpha</code></td>
<td>
<p>the smoothness parameter.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the precision matrix as a sparse matrix object.
</p>


<h3>Warning</h3>

<p>This is just for illustration purpose and one should consider the
efficient function available a the INLA package.
</p>

<hr>
<h2 id='stats.inla'>To retrieve goodness of fit statistics.</h2><span id='topic+stats.inla'></span>

<h3>Description</h3>

<p>Extracts dic, waic and log-cpo from an output returned by the inla function
from the INLA package or by the bru function from the inlabru package,
and computes log-po, mse, mae, crps and scrps for a given input.
A summary is applied considering the user imputed function,
which by default is the mean.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stats.inla(m, i = NULL, y, fsummarize = mean)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stats.inla_+3A_m">m</code></td>
<td>
<p>an inla output object.</p>
</td></tr>
<tr><td><code id="stats.inla_+3A_i">i</code></td>
<td>
<p>an index to subset the estimated values.</p>
</td></tr>
<tr><td><code id="stats.inla_+3A_y">y</code></td>
<td>
<p>observed to compare against.</p>
</td></tr>
<tr><td><code id="stats.inla_+3A_fsummarize">fsummarize</code></td>
<td>
<p>the summary function,
the default is <code><a href="base.html#topic+mean">base::mean()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named numeric vector with the extracted statistics.
</p>


<h3>Details</h3>

<p>It assumes Gaussian posterior predictive distributions!
Considering the defaults, for n observations,
<code class="reqn">y_i, i = 1, 2, ..., n</code>, we have
</p>
<p>. dic </p>
<p style="text-align: center;"><code class="reqn">\sum_i d_i/n</code>
</p>

<p>where <code class="reqn">d_i</code> is the dic computed for observation i.
</p>
<p>. waic </p>
<p style="text-align: center;"><code class="reqn">\sum_i w_i/n</code>
</p>

<p>where <code class="reqn">w_i</code> is the waic computed for observation i.
</p>
<p>. lcpo </p>
<p style="text-align: center;"><code class="reqn">-\sum_i \log(p_i)/n</code>
</p>

<p>where <code class="reqn">p_i</code> is the cpo computed for observation i.
</p>
<p>For the log-po, crps, and scrps scores it assumes a
Gaussian predictive distribution for each observation
<code class="reqn">y_i</code> which the following definitions:
<code class="reqn">z_i = (y_i-\mu_i)/\sigma_i</code>,
<code class="reqn">\mu_i</code> is the posterior mean for the linear predictor,
<code class="reqn">\sigma_i = \sqrt{v_i + 1/\tau_y}</code>,
<code class="reqn">\tau_y</code> is the observation posterior mean,
<code class="reqn">v_i</code> is the posterior variance of the
linear predictor for <code class="reqn">y_i</code>.
</p>
<p>Then we consider <code class="reqn">\phi()</code> the density of a standard
Gaussian variable and <code class="reqn">\psi()</code> the corresponding
Cumulative Probability Distribution.
</p>
<p>. lpo </p>
<p style="text-align: center;"><code class="reqn">-\sum_i \log(\phi(z_i))/n</code>
</p>

<p>. crps </p>
<p style="text-align: center;"><code class="reqn">\sum_i r_i/n</code>
</p>

<p>where </p>
<p style="text-align: center;"><code class="reqn">r_i=\sigma_i/\sqrt{\pi} - 2\sigma_i\phi(z_i) + (y_i-\mu_i)(1-2\psi(z_i))</code>
</p>

<p>. scrps </p>
<p style="text-align: center;"><code class="reqn">\sum_i s_i/n</code>
</p>

<p>where </p>
<p style="text-align: center;"><code class="reqn">s_i=-\log(2\sigma_i/\sqrt{\pi})/2 -\sqrt{\pi}(\phi(z_i)-\sigma_iz_i/2+z_i\psi(z_i))</code>
</p>



<h3>Warning</h3>

<p>All the scores are negatively oriented which means
that smaller scores are better.
</p>


<h3>References</h3>

<p>Held, L. and Schrödle, B. and Rue, H. (2009).
Posterior and Cross-validatory Predictive Checks:
A Comparison of MCMC and INLA.
Statistical Modelling and Regression Structures pp 91–110.
<a href="https://link.springer.com/chapter/10.1007/978-3-7908-2413-1_6">https://link.springer.com/chapter/10.1007/978-3-7908-2413-1_6</a>.
</p>
<p>Bolin, D. and Wallin, J. (2022) Local scale invariance
and robustness of proper scoring rules. Statistical Science.
<a href="https://doi.org/10.1214/22-STS864">doi:10.1214/22-STS864</a>.
</p>

<hr>
<h2 id='stdSubs'>To check unusual low/high variance segments</h2><span id='topic+stdSubs'></span>

<h3>Description</h3>

<p>To check unusual low/high variance segments
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stdSubs(x, nsub = 12, fs = 15)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stdSubs_+3A_x">x</code></td>
<td>
<p>numeric vector</p>
</td></tr>
<tr><td><code id="stdSubs_+3A_nsub">nsub</code></td>
<td>
<p>number for the segments length</p>
</td></tr>
<tr><td><code id="stdSubs_+3A_fs">fs</code></td>
<td>
<p>numeric to use for detecting too
hight or too low local standard deviations.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>logical indicating if any of the
<code>st</code> are <code>fs</code> times lower/higher the average
of <code>st</code>, where is returned as an attribute:
</p>

<ul>
<li><p> attr(, 'st') numeric vector with the
standard deviation at each segment of the data.
</p>
</li></ul>


<hr>
<h2 id='stlines'>To visualize time series over space.</h2><span id='topic+stlines'></span><span id='topic+stpoints'></span>

<h3>Description</h3>

<p>To visualize time series over space.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stlines(
  stdata,
  spatial,
  group = NULL,
  nmax.group = NULL,
  xscale = 1,
  yscale = 1,
  colour = NULL,
  ...
)

stpoints(
  stdata,
  spatial,
  group = NULL,
  nmax.group = NULL,
  xscale = 1,
  yscale = 1,
  colour = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stlines_+3A_stdata">stdata</code></td>
<td>
<p>matrix with the data, each column is a location.</p>
</td></tr>
<tr><td><code id="stlines_+3A_spatial">spatial</code></td>
<td>
<p>an object with one of class defined in the sp package.</p>
</td></tr>
<tr><td><code id="stlines_+3A_group">group</code></td>
<td>
<p>an integer vector indicating to which spatial unit
each time series belongs to. Default is NULL and them it is assumed that
each time series belongs o each spatial unit.</p>
</td></tr>
<tr><td><code id="stlines_+3A_nmax.group">nmax.group</code></td>
<td>
<p>an integer indicating the maximum number of time series
to be plotted over each spatial unit. Default is NULL, so all will be drawn.</p>
</td></tr>
<tr><td><code id="stlines_+3A_xscale">xscale</code></td>
<td>
<p>numeric to define a scaling factor in the horizontal direction.</p>
</td></tr>
<tr><td><code id="stlines_+3A_yscale">yscale</code></td>
<td>
<p>numeric to define a scaling factor in the vertical direction.</p>
</td></tr>
<tr><td><code id="stlines_+3A_colour">colour</code></td>
<td>
<p>color (may be a vector, one for each time series).
Default is NULL and it will generate colors considering the
average of each time series.
These automatic colors are defined using the <code>rgb()</code> function with <code>alpha=0.5</code>.
It considers the relative rank of each time series mean, <code>r</code>.
<code>r</code> is then used for red,  <code>1-r</code> is used for blue and
a triangular function, <code style="white-space: pre;">&#8288;1-2*|1-r/2|&#8288;</code>, is considered for green.
That is, time series with mean among the lowest time series averages
are shown in blue and those among the highest temperatures are shown in red.
The transition from blue to red goes so that
the intermediate ones are shown in light green.</p>
</td></tr>
<tr><td><code id="stlines_+3A_...">...</code></td>
<td>
<p>further arguments to be passed for the lines function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Scaling the times series is needed before drawing it over the map.
The area of the bounding box for the spatial object
divided by the number of locations is the standard scaling factor.
This is further multiplied by the user given <code>xcale</code> and <code>yscale</code>.
</p>


<h3>Value</h3>

<p>add lines to an existing plot
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>stlines()</code>: each time series over the map centered at the location.
</p>
</li>
<li> <p><code>stpoints()</code>: each time series over the map centered at the location.
</p>
</li></ul>


<h3>Warning</h3>

<p>if there are too many geographical locations, it will not look good
</p>

<hr>
<h2 id='stModel.define'>Define a spacetime model object for the <code>f()</code> call.</h2><span id='topic+stModel.define'></span>

<h3>Description</h3>

<p>Define a spacetime model object for the <code>f()</code> call.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stModel.define(
  smesh,
  tmesh,
  model,
  control.priors,
  constr = FALSE,
  debug = FALSE,
  verbose = FALSE,
  useINLAprecomp = TRUE,
  libpath = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stModel.define_+3A_smesh">smesh</code></td>
<td>
<p>a spatial mesh</p>
</td></tr>
<tr><td><code id="stModel.define_+3A_tmesh">tmesh</code></td>
<td>
<p>a temporal mesh</p>
</td></tr>
<tr><td><code id="stModel.define_+3A_model">model</code></td>
<td>
<p>a three characters string to specify the
smoothness alpha (each one as integer) parameters.
Currently it considers the <code>102</code>, <code>121</code>, <code>202</code> and <code>220</code> models.</p>
</td></tr>
<tr><td><code id="stModel.define_+3A_control.priors">control.priors</code></td>
<td>
<p>a named list with parameter priors.
E.g. prior.rs, prior.rt and prior.sigma
as vectors with length two (U, a) to define the
corresponding PC-prior such that
P(r_s&lt;U)=a, P(r_t&lt;U)=a or P(sigma&gt;U)=a.
If a=0 then U is taken to be the fixed value of the parameter.</p>
</td></tr>
<tr><td><code id="stModel.define_+3A_constr">constr</code></td>
<td>
<p>logical to indicate if the integral of the field
over the domain is to be constrained to zero. Default value is FALSE.</p>
</td></tr>
<tr><td><code id="stModel.define_+3A_debug">debug</code></td>
<td>
<p>logical indicating if to run in debug mode.</p>
</td></tr>
<tr><td><code id="stModel.define_+3A_verbose">verbose</code></td>
<td>
<p>logical indicating if to print parameter values.</p>
</td></tr>
<tr><td><code id="stModel.define_+3A_useinlaprecomp">useINLAprecomp</code></td>
<td>
<p>logical indicating if is to be used
shared object pre-compiled by INLA. Not considered if
libpath is provided.</p>
</td></tr>
<tr><td><code id="stModel.define_+3A_libpath">libpath</code></td>
<td>
<p>string to the shared object. Default is NULL.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See the paper.
</p>


<h3>Value</h3>

<p>objects to be used in the f() formula term in INLA.
</p>

<hr>
<h2 id='stModel.matrices'>Define the spacetime model matrices.</h2><span id='topic+stModel.matrices'></span>

<h3>Description</h3>

<p>This function computes all the matrices needed to build
the precision matrix for spatio-temporal model,
as in Lindgren et. al. (2023)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stModel.matrices(smesh, tmesh, model, constr = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stModel.matrices_+3A_smesh">smesh</code></td>
<td>
<p>a mesh object over the spatial domain.</p>
</td></tr>
<tr><td><code id="stModel.matrices_+3A_tmesh">tmesh</code></td>
<td>
<p>a mesh object over the time domain.</p>
</td></tr>
<tr><td><code id="stModel.matrices_+3A_model">model</code></td>
<td>
<p>a string identifying the model.
So far we have the following models:
'102', '121', '202' and '220' models.</p>
</td></tr>
<tr><td><code id="stModel.matrices_+3A_constr">constr</code></td>
<td>
<p>logical to indicate if the integral of the field
over the domain is to be constrained to zero. Default value is FALSE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See the paper for details.
</p>


<h3>Value</h3>

<p>a list containing needed objects for model definition.
</p>

<ol>
<li><p> 'manifold' to spedify the a string with the model identification
</p>
</li>
<li><p> a length three vector with the constants <code>c1</code>, <code>c2</code> and <code>c3</code>
</p>
</li>
<li><p> the vector <code>d</code>
</p>
</li>
<li><p> the matrix <code>T</code>
</p>
</li>
<li><p> the model matrices <code>M_1</code>, ..., <code>M_m</code>
</p>
</li></ol>


<hr>
<h2 id='stModel.precision'>Spacetime precision matrix.</h2><span id='topic+stModel.precision'></span>

<h3>Description</h3>

<p>To build the the precision matrix for a spacetime model
given the temporal and the spatial meshes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stModel.precision(smesh, tmesh, model, theta, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stModel.precision_+3A_smesh">smesh</code></td>
<td>
<p>a mesh object over the spatial domain.</p>
</td></tr>
<tr><td><code id="stModel.precision_+3A_tmesh">tmesh</code></td>
<td>
<p>a mesh object over the time domain.</p>
</td></tr>
<tr><td><code id="stModel.precision_+3A_model">model</code></td>
<td>
<p>a string identifying the model.
So far we have the following models:
'102', '121', '202' and '220' models.</p>
</td></tr>
<tr><td><code id="stModel.precision_+3A_theta">theta</code></td>
<td>
<p>numeric vector of length three with
<code class="reqn">log(gamma_s, gamma_t, gamma_e)</code>.</p>
</td></tr>
<tr><td><code id="stModel.precision_+3A_verbose">verbose</code></td>
<td>
<p>logical to print intermediate objects.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a (sparse) precision matrix,
as in Lindgren et. al. (2023)
</p>

<hr>
<h2 id='upperPadding'>Prepare a matrix or a list of matrices
for use in some cgeneric code.</h2><span id='topic+upperPadding'></span>

<h3>Description</h3>

<p>Define a graph of the union of the supplied matrices
and return the row ordered diagonal plus upper triangle
after padding with zeroes each one so that
all the returned matrices have the same pattern.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>upperPadding(M, relative = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="upperPadding_+3A_m">M</code></td>
<td>
<p>a matrix or a list of matrices</p>
</td></tr>
<tr><td><code id="upperPadding_+3A_relative">relative</code></td>
<td>
<p>logical. If a list of matrices is supplied,
it indicates if it is to be returned a relative index
and the value for each matrix. See details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If relative=FALSE, each columns of 'xx' is the
elements of the corresponding matrix after being padded
to fill the pattern of the union graph.
If relative=TRUE, each element of 'xx' would be a list
with a relative index, 'r', for each non-zero elements of
each matrix is returned relative to the union graph,
the non-lower elements, 'x', of the corresponding matrix,
and a vector, 'o', with the number of non-zero elements
for each line of each resulting matrix.
</p>


<h3>Value</h3>

<p>If a unique matrix is given, return the
upper triangle considering the 'T' representation
in the Matrix package. If a list of matrices is given,
return a list of two elements: 'graph' and 'xx'.
The 'graph' is the union of the graph from each matrix.
If relative=FALSE, 'xx' is a matrix with number of column equals
the the number of matrices imputed.
If relative=TRUE, it is a list of length equal the number
of matrices imputed. See details.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>A &lt;- sparseMatrix(
  i = c(1, 1, 2, 3, 3, 5),
  j = c(2, 5, 3, 4, 5, 5),
  x = -(0:5), symmetric = TRUE
)
A
upperPadding(A)
B &lt;- Diagonal(nrow(A), -colSums(A))
list(a = A, a = B)
upperPadding(list(a = A, b = B))
upperPadding(list(a = A, b = B), relative = TRUE)
</code></pre>

<hr>
<h2 id='worldMap'>Get the world map</h2><span id='topic+worldMap'></span>

<h3>Description</h3>

<p>Consider the world map, fix the wrap around and convert to the
Mollweide projection in km distance (default, can be changed).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>worldMap(
  crs = sp::CRS("+proj=moll +units=km"),
  scale = "medium",
  returnclass = c("sp", "sf")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="worldMap_+3A_crs">crs</code></td>
<td>
<p>a CRS object for the target coordinates.
Default is the Mollweide projection with units in kilometers.</p>
</td></tr>
<tr><td><code id="worldMap_+3A_scale">scale</code></td>
<td>
<p>see the help from <code><a href="rnaturalearth.html#topic+ne_countries">rnaturalearth::ne_countries()</a></code></p>
</td></tr>
<tr><td><code id="worldMap_+3A_returnclass">returnclass</code></td>
<td>
<p>defined by the <a href="car.html#topic+sp">sp</a> if returnclass = &quot;sp&quot; or
by the <a href="sf.html#topic+sf">sf</a> package if returnclass = &quot;sf&quot;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Requires the <code>rnaturalearth</code> package
</p>


<h3>Value</h3>

<p>the world map
</p>


<h3>References</h3>

<p>the world map data is from the maps R package.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
