<!DOCTYPE html><html><head><title>Help for package ribd</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {ribd}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#ribd-package'><p>ribd: Pedigree-based Relatedness Coefficients</p></a></li>
<li><a href='#basicRelationships'><p>Basic relationships</p></a></li>
<li><a href='#coeffTable'><p>Table of pairwise relatedness coefficients</p></a></li>
<li><a href='#condensedIdentity'><p>Condensed identity coefficients</p></a></li>
<li><a href='#condensedIdentityX'><p>Identity coefficients on X</p></a></li>
<li><a href='#constructPedigree'><p>Pedigree construction</p></a></li>
<li><a href='#ELR'><p>Expected LR of a pairwise kinship test</p></a></li>
<li><a href='#external_coefs'><p>Relatedness coefficients by other programs</p></a></li>
<li><a href='#gKinship'><p>Generalised kinship coefficients</p></a></li>
<li><a href='#ibdDraw'><p>Colourised IBD plot</p></a></li>
<li><a href='#ibdTriangle'><p>IBD triangle plot</p></a></li>
<li><a href='#identityCoefs'><p>Omnibus function for identity coefficients</p></a></li>
<li><a href='#inbreeding'><p>Inbreeding coefficients</p></a></li>
<li><a href='#jicaque'><p>Jicaque pedigree</p></a></li>
<li><a href='#kappaIBD'><p>IBD (kappa) coefficients</p></a></li>
<li><a href='#kin2deg'><p>Degree of relationship</p></a></li>
<li><a href='#kinship'><p>Kinship coefficients</p></a></li>
<li><a href='#minimalPattern'><p>Minimal IBD pattern</p></a></li>
<li><a href='#multiPersonIBD'><p>Multi-person IBD coefficients</p></a></li>
<li><a href='#realisedIbdVariance'><p>Variance of realised relatedness coefficients</p></a></li>
<li><a href='#showInTriangle'><p>Add points to the IBD triangle</p></a></li>
<li><a href='#twoLocusIBD'><p>Two-locus IBD coefficients</p></a></li>
<li><a href='#twoLocusIdentity'><p>Two-locus identity coefficients</p></a></li>
<li><a href='#twoLocusInbreeding'><p>Two-locus inbreeding</p></a></li>
<li><a href='#twoLocusKinship'><p>Two-locus kinship coefficients</p></a></li>
<li><a href='#twoLocusPlot'><p>Two-locus coefficient plot</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Pedigree-based Relatedness Coefficients</td>
</tr>
<tr>
<td>Version:</td>
<td>1.7.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Recursive algorithms for computing various relatedness
    coefficients, including pairwise kinship, kappa and identity
    coefficients. Both autosomal and X-linked coefficients are computed.
    Founders are allowed to be inbred, which enables construction of any
    given kappa coefficients, as described in Vigeland (2020)
    &lt;<a href="https://doi.org/10.1007%2Fs00285-020-01505-x">doi:10.1007/s00285-020-01505-x</a>&gt;. In addition to the standard
    coefficients, 'ribd' also computes a range of lesser-known
    coefficients, including generalised kinship coefficients, multi-person
    coefficients and two-locus coefficients (Vigeland, 2023,
    &lt;<a href="https://doi.org/10.1093%2Fg3journal%2Fjkac326">doi:10.1093/g3journal/jkac326</a>&gt;). Many features of 'ribd' are
    available through the online app 'QuickPed' at
    <a href="https://magnusdv.shinyapps.io/quickped">https://magnusdv.shinyapps.io/quickped</a>; see Vigeland (2022)
    &lt;<a href="https://doi.org/10.1186%2Fs12859-022-04759-y">doi:10.1186/s12859-022-04759-y</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/magnusdv/ribd">https://github.com/magnusdv/ribd</a>,
<a href="https://magnusdv.github.io/pedsuite/">https://magnusdv.github.io/pedsuite/</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>pedtools (&ge; 2.2.0), R (&ge; 4.1.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>glue, kinship2, slam</td>
</tr>
<tr>
<td>Suggests:</td>
<td>ggplot2, ggrepel, plotly, spelling, testthat</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Language:</td>
<td>en-GB</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-03-26 18:10:30 UTC; magnu</td>
</tr>
<tr>
<td>Author:</td>
<td>Magnus Dehli Vigeland
    <a href="https://orcid.org/0000-0002-9134-4962"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Magnus Dehli Vigeland &lt;m.d.vigeland@medisin.uio.no&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-03-26 19:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='ribd-package'>ribd: Pedigree-based Relatedness Coefficients</h2><span id='topic+ribd'></span><span id='topic+ribd-package'></span>

<h3>Description</h3>

<p><img src="../help/figures/logo.png" style='float: right' alt='logo' width='120' />
</p>
<p>Recursive algorithms for computing various relatedness coefficients, including pairwise kinship, kappa and identity coefficients. Both autosomal and X-linked coefficients are computed. Founders are allowed to be inbred, which enables construction of any given kappa coefficients, as described in Vigeland (2020) <a href="https://doi.org/10.1007/s00285-020-01505-x">doi:10.1007/s00285-020-01505-x</a>. In addition to the standard coefficients, 'ribd' also computes a range of lesser-known coefficients, including generalised kinship coefficients, multi-person coefficients and two-locus coefficients (Vigeland, 2023, <a href="https://doi.org/10.1093/g3journal/jkac326">doi:10.1093/g3journal/jkac326</a>). Many features of 'ribd' are available through the online app 'QuickPed' at <a href="https://magnusdv.shinyapps.io/quickped">https://magnusdv.shinyapps.io/quickped</a>; see Vigeland (2022) <a href="https://doi.org/10.1186/s12859-022-04759-y">doi:10.1186/s12859-022-04759-y</a>.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Magnus Dehli Vigeland <a href="mailto:m.d.vigeland@medisin.uio.no">m.d.vigeland@medisin.uio.no</a> (<a href="https://orcid.org/0000-0002-9134-4962">ORCID</a>)
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/magnusdv/ribd">https://github.com/magnusdv/ribd</a>
</p>
</li>
<li> <p><a href="https://magnusdv.github.io/pedsuite/">https://magnusdv.github.io/pedsuite/</a>
</p>
</li></ul>


<hr>
<h2 id='basicRelationships'>Basic relationships</h2><span id='topic+basicRelationships'></span>

<h3>Description</h3>

<p>A data frame containing kinship and kappa coefficients for some commonly used
relationships.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>basicRelationships
</code></pre>


<h3>Format</h3>

<p>A data frame with 12 rows and 7 columns. The last column (<code>pos</code>) is
used internally for placing labels on triangle plots.
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
   label </td><td style="text-align: left;"> relationship </td><td style="text-align: right;"> phi </td><td style="text-align: right;"> kappa0 </td><td style="text-align: right;"> kappa1 </td><td style="text-align: right;"> kappa2 </td><td style="text-align: right;"> pos </td>
</tr>
<tr>
 <td style="text-align: left;">
   UN </td><td style="text-align: left;"> unrelated </td><td style="text-align: right;"> 0.000000 </td><td style="text-align: right;"> 1.00000 </td><td style="text-align: right;"> 0.0000 </td><td style="text-align: right;"> 0.00000 </td><td style="text-align: right;"> 1 </td>
</tr>
<tr>
 <td style="text-align: left;">
   PO </td><td style="text-align: left;"> parent-offspring </td><td style="text-align: right;"> 0.250000 </td><td style="text-align: right;"> 0.00000 </td><td style="text-align: right;"> 1.0000 </td><td style="text-align: right;"> 0.00000 </td><td style="text-align: right;"> 1 </td>
</tr>
<tr>
 <td style="text-align: left;">
   MZ </td><td style="text-align: left;"> monozygotic twins </td><td style="text-align: right;"> 0.500000 </td><td style="text-align: right;"> 0.00000 </td><td style="text-align: right;"> 0.0000 </td><td style="text-align: right;"> 1.00000 </td><td style="text-align: right;"> 4 </td>
</tr>
<tr>
 <td style="text-align: left;">
   S </td><td style="text-align: left;"> full siblings </td><td style="text-align: right;"> 0.250000 </td><td style="text-align: right;"> 0.25000 </td><td style="text-align: right;"> 0.5000 </td><td style="text-align: right;"> 0.25000 </td><td style="text-align: right;"> 4 </td>
</tr>
<tr>
 <td style="text-align: left;">
   H </td><td style="text-align: left;"> half siblings </td><td style="text-align: right;"> 0.125000 </td><td style="text-align: right;"> 0.50000 </td><td style="text-align: right;"> 0.5000 </td><td style="text-align: right;"> 0.00000 </td><td style="text-align: right;"> 1 </td>
</tr>
<tr>
 <td style="text-align: left;">
   A </td><td style="text-align: left;"> avuncular </td><td style="text-align: right;"> 0.125000 </td><td style="text-align: right;"> 0.50000 </td><td style="text-align: right;"> 0.5000 </td><td style="text-align: right;"> 0.00000 </td><td style="text-align: right;"> 1 </td>
</tr>
<tr>
 <td style="text-align: left;">
   G </td><td style="text-align: left;"> grandparent-grandchild </td><td style="text-align: right;"> 0.125000 </td><td style="text-align: right;"> 0.50000 </td><td style="text-align: right;"> 0.5000 </td><td style="text-align: right;"> 0.00000 </td><td style="text-align: right;"> 1 </td>
</tr>
<tr>
 <td style="text-align: left;">
   H,U,G </td><td style="text-align: left;"> halfsib/uncle/grandp </td><td style="text-align: right;"> 0.125000 </td><td style="text-align: right;"> 0.50000 </td><td style="text-align: right;"> 0.5000 </td><td style="text-align: right;"> 0.00000 </td><td style="text-align: right;"> 1 </td>
</tr>
<tr>
 <td style="text-align: left;">
   FC </td><td style="text-align: left;"> first cousins </td><td style="text-align: right;"> 0.062500 </td><td style="text-align: right;"> 0.75000 </td><td style="text-align: right;"> 0.2500 </td><td style="text-align: right;"> 0.00000 </td><td style="text-align: right;"> 1 </td>
</tr>
<tr>
 <td style="text-align: left;">
   SC </td><td style="text-align: left;"> second cousins </td><td style="text-align: right;"> 0.015625 </td><td style="text-align: right;"> 0.93750 </td><td style="text-align: right;"> 0.0625 </td><td style="text-align: right;"> 0.00000 </td><td style="text-align: right;"> 1 </td>
</tr>
<tr>
 <td style="text-align: left;">
   DFC </td><td style="text-align: left;"> double first cousins </td><td style="text-align: right;"> 0.125000 </td><td style="text-align: right;"> 0.56250 </td><td style="text-align: right;"> 0.3750 </td><td style="text-align: right;"> 0.06250 </td><td style="text-align: right;"> 3 </td>
</tr>
<tr>
 <td style="text-align: left;">
   Q </td><td style="text-align: left;"> quad half first cousins </td><td style="text-align: right;"> 0.125000 </td><td style="text-align: right;"> 0.53125 </td><td style="text-align: right;"> 0.4375 </td><td style="text-align: right;"> 0.03125 </td><td style="text-align: right;"> 4 </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>


<hr>
<h2 id='coeffTable'>Table of pairwise relatedness coefficients</h2><span id='topic+coeffTable'></span>

<h3>Description</h3>

<p>Creates a data frame containing various relatedness coefficients between all
pairs of individuals in a given pedigree.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coeffTable(
  x,
  ids = labels(x),
  coeff = c("f", "phi", "deg", "kappa", "identity", "detailed"),
  self = FALSE,
  Xchrom = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coeffTable_+3A_x">x</code></td>
<td>
<p>A pedigree in the form of a <code>pedtools::ped</code> object.</p>
</td></tr>
<tr><td><code id="coeffTable_+3A_ids">ids</code></td>
<td>
<p>A character (or coercible to character) containing ID labels of
two or more pedigree members.</p>
</td></tr>
<tr><td><code id="coeffTable_+3A_coeff">coeff</code></td>
<td>
<p>A character vector containing one or more of the keywords &quot;f&quot;,
&quot;phi&quot;, &quot;deg&quot;, &quot;kappa&quot;, &quot;identity&quot;, &quot;detailed&quot;.</p>
</td></tr>
<tr><td><code id="coeffTable_+3A_self">self</code></td>
<td>
<p>A logical indicating if self-relationships should be included.
Default: FALSE.</p>
</td></tr>
<tr><td><code id="coeffTable_+3A_xchrom">Xchrom</code></td>
<td>
<p>A logical indicating if the coefficients should be autosomal
(default) or X-chromosomal. If <code>Xchrom = NA</code>, both sets are included.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Available coefficients (indicated in <code>coeff</code>) include:
</p>

<ul>
<li> <p><code>f</code>: The inbreeding coefficient of each pair member. Columns: <code>f1</code> and
<code>f2</code>.
</p>
</li>
<li> <p><code>phi</code>: The kinship coefficient. Column: <code>phi</code>.
</p>
</li>
<li> <p><code>deg</code>: The degree of relationship, as computed by <a href="#topic+kin2deg">kin2deg</a>. Column: <code>deg</code>
</p>
</li>
<li> <p><code>kappa</code>: The IBD coefficients computed by <a href="#topic+kappaIBD">kappaIBD</a>. (These are NA for
pairs involving inbred individuals.) Columns: <code>k0</code>, <code>k1</code>, <code>k2</code>.
</p>
</li>
<li> <p><code>identity</code>: The 9 condensed identity coefficients of Jacquard, computed by
<code><a href="#topic+identityCoefs">identityCoefs()</a></code>. Columns: <code>D1</code>, ..., <code>D9</code>.
</p>
</li>
<li> <p><code>detailed</code>: The detailed identity coefficients of Jacquard, computed by
<code>identityCoefs(..., detailed = TRUE)</code>. Columns: <code>d1</code>, ..., <code>d15</code>.
</p>
</li></ul>



<h3>Value</h3>

<p>A data frame with one row for each pair of individuals. The first two
columns are characters named <code>id1</code> and <code>id2</code>, while remaining columns are
numeric. Columns containing X-chromosomal coefficients are suffixed with
&quot;.X&quot;.
</p>
<p>If &quot;f&quot; (inbreeding) is the only coefficient, the data frame has one row per
individual, and the first column is named <code>id</code>.
</p>
<p>Note: If <code>x</code> has members with unknown sex, all X-chromosomal coefficients
are NA.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Uncle-nephew pedigree
x = avuncularPed()

# Complete table
coeffTable(x)

# Only selected coefficients
coeffTable(x, coeff = c("phi", "deg", "kappa"))

# Only the uncle-nephew pair
coeffTable(x, ids = c(3, 6), coeff = c("phi", "deg", "kappa"))

# X-chromosomal coefficients
coeffTable(x, Xchrom = TRUE, coeff = "kappa")

# Both autosomal and X
coeffTable(x, Xchrom = NA, coeff = "phi")

</code></pre>

<hr>
<h2 id='condensedIdentity'>Condensed identity coefficients</h2><span id='topic+condensedIdentity'></span>

<h3>Description</h3>

<p>Computes the 9 condensed identity coefficients of pairwise relationships in a
pedigree. Founders of the pedigree may be inbred; use
<code><a href="pedtools.html#topic+founderInbreeding">pedtools::founderInbreeding()</a></code> to set this up.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>condensedIdentity(
  x,
  ids,
  sparse = NA,
  simplify = TRUE,
  self = FALSE,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="condensedIdentity_+3A_x">x</code></td>
<td>
<p>A pedigree in the form of a <code><a href="pedtools.html#topic+ped">pedtools::ped</a></code> object</p>
</td></tr>
<tr><td><code id="condensedIdentity_+3A_ids">ids</code></td>
<td>
<p>A character (or coercible to character) containing ID labels of
two or more pedigree members.</p>
</td></tr>
<tr><td><code id="condensedIdentity_+3A_sparse">sparse</code></td>
<td>
<p>A positive integer, indicating the pedigree size limit for
using sparse arrays (as implemented by the
<a href="https://CRAN.R-project.org/package=slam">slam</a> package) instead of
ordinary arrays.</p>
</td></tr>
<tr><td><code id="condensedIdentity_+3A_simplify">simplify</code></td>
<td>
<p>Simplify the output (to a numeric of length 9) if <code>ids</code> has
length 2. Default: TRUE.</p>
</td></tr>
<tr><td><code id="condensedIdentity_+3A_self">self</code></td>
<td>
<p>A logical indicating if self-relationships (i.e., between a
pedigree member and itself) should be included. FALSE by default.</p>
</td></tr>
<tr><td><code id="condensedIdentity_+3A_verbose">verbose</code></td>
<td>
<p>A logical</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The implementation is a modified version of Karigl's recursive algorithm
(1981).
</p>


<h3>Value</h3>

<p>If <code>ids</code> has length 2 and <code>simplify = TRUE</code>: A vector of length 9,
containing the condensed identity coefficients.
</p>
<p>Otherwise, a data frame with 11 columns and one row for each pair of
individuals. The first two columns contain the ID labels, and columns 3-11
contain the condensed identity coefficients.
</p>


<h3>References</h3>

<p>G. Karigl (1981). <em>A recursive algorithm for the calculation of
identity coefficients.</em> Annals of Human Genetics, vol. 45.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+kappa">kappa()</a></code>, <code><a href="#topic+identityCoefs">identityCoefs()</a></code>, <code><a href="pedtools.html#topic+founderInbreeding">pedtools::founderInbreeding()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># One generation of full sib mating.
# (One of the simplest examples with all 9 coefficients nonzero.)
x = fullSibMating(1)
j1 = condensedIdentity(x, ids = 5:6)

stopifnot(all.equal(j1, c(2, 1,4, 1, 4, 1, 7, 10, 2)/32))

# Recalculate the coefficients when the founders are 100% inbred
founderInbreeding(x, 1:2) = 1
condensedIdentity(x, ids = 5:6)

</code></pre>

<hr>
<h2 id='condensedIdentityX'>Identity coefficients on X</h2><span id='topic+condensedIdentityX'></span>

<h3>Description</h3>

<p>Computes the X chromosomal condensed identity coefficients of a pairwise
relationship.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>condensedIdentityX(x, ids, sparse = NA, simplify = TRUE, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="condensedIdentityX_+3A_x">x</code></td>
<td>
<p>A pedigree in the form of a <code><a href="pedtools.html#topic+ped">pedtools::ped</a></code> object</p>
</td></tr>
<tr><td><code id="condensedIdentityX_+3A_ids">ids</code></td>
<td>
<p>A character (or coercible to character) containing ID labels of
two or more pedigree members.</p>
</td></tr>
<tr><td><code id="condensedIdentityX_+3A_sparse">sparse</code></td>
<td>
<p>A positive integer, indicating the pedigree size limit for
using sparse arrays (as implemented by the
<a href="https://CRAN.R-project.org/package=slam">slam</a> package) instead of
ordinary arrays.</p>
</td></tr>
<tr><td><code id="condensedIdentityX_+3A_simplify">simplify</code></td>
<td>
<p>Simplify the output (to a numeric of length 9) if <code>ids</code> has
length 2. Default: TRUE.</p>
</td></tr>
<tr><td><code id="condensedIdentityX_+3A_verbose">verbose</code></td>
<td>
<p>A logical</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The implementation is inspired by Karigl's recursive algorithm (1981) for the
autosomal case, modified to account for X-linked inheritance.
</p>
<p>The X chromosomal pairwise identity states depend on the sexes of the two
individuals. If both are female, the states are the same as in the autosomal
case. When males are involved, the two individuals have less than 4 alleles,
hence the states differ from the autosomal ones. However, to avoid drawing
(and learning) new pictures we re-use the autosomal states by using the
following simple rule: <strong>Replace any hemizygous male allele with a pair of
autozygous alleles</strong>. In this way each X state corresponds to a unique
autosomal state.
</p>
<p>For simplicity the output always contains 9 coefficients, but with NA's in
the positions of undefined states (depending on the sex combination). The
README file on the GitHub home page of ribd has a table illustrating this.
</p>


<h3>Value</h3>

<p>If <code>ids</code> has length 2 and <code>simplify = TRUE</code>: A vector of length 9,
containing the condensed identity coefficients. If any of the individuals
are male, certain states are undefined, and the corresponding coefficients
are NA. (See Details.)
</p>
<p>Otherwise, a data frame with 11 columns and one row for each pair of
individuals. The first two columns contain the ID labels, and columns 3-11
contain the condensed identity coefficients.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+kinship">kinship()</a></code>, <code><a href="#topic+identityCoefs">identityCoefs()</a></code>, <code><a href="pedtools.html#topic+founderInbreeding">pedtools::founderInbreeding()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x = fullSibMating(1)
x_sisters = swapSex(x, 5)
x_brothers = swapSex(x, 6)

condensedIdentityX(x, ids = 5:6)
condensedIdentityX(x_sisters, ids = 5:6)
condensedIdentityX(x_brothers, ids = 5:6)

</code></pre>

<hr>
<h2 id='constructPedigree'>Pedigree construction</h2><span id='topic+constructPedigree'></span>

<h3>Description</h3>

<p>Construct a pedigree yielding a prescribed set of IBD coefficients.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>constructPedigree(kappa, describe = TRUE, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="constructPedigree_+3A_kappa">kappa</code></td>
<td>
<p>A probability vector of length 3; <code class="reqn">(kappa0, kappa1,
kappa2)</code>.</p>
</td></tr>
<tr><td><code id="constructPedigree_+3A_describe">describe</code></td>
<td>
<p>A logical. If TRUE, a textual description of the resulting
relationship is printed.</p>
</td></tr>
<tr><td><code id="constructPedigree_+3A_verbose">verbose</code></td>
<td>
<p>A logical. If TRUE, various details about the calculations are
printed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The construction follows the method and formulae given in Vigeland (2020).
</p>


<h3>Value</h3>

<p>A <code>ped</code> object containing a pair of double half cousins with inbred
founders. (In corner cases the relationship collapses into siblings.)
</p>


<h3>References</h3>

<p>M. D. Vigeland (2020). <em>Relatedness coefficients in pedigrees
with inbred founders</em>. Journal of mathematical biology.
<a href="https://doi.org/10.1007/s00285-020-01505-x">doi:10.1007/s00285-020-01505-x</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Full siblings
x = constructPedigree(kappa = c(0.25, 0.5, 0.25))
kappaIBD(x, leaves(x))

# A relationship halfway between parent-child and full sibs
kap = c(1/8, 6/8, 1/8)
showInTriangle(kap, label = " (1/8, 1/8)", pos = 4)

y = constructPedigree(kappa = kap)
plot(y)

stopifnot(all.equal(kappaIBD(y, leaves(y)), kap))

# kappa = (0,1,0) does not give a parent-child relationship,
# but half siblings whose shared parent is completely inbred.
z = constructPedigree(kappa = c(0,1,0))
plot(z)

</code></pre>

<hr>
<h2 id='ELR'>Expected LR of a pairwise kinship test</h2><span id='topic+ELR'></span>

<h3>Description</h3>

<p>Calculates the exact likelihood ratio of a pairwise kinship test,
implementing formulas of Egeland &amp; Slooten (2016).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ELR(x, true = x, ids = leaves(x), L1, L2 = NULL, rho = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ELR_+3A_x">x</code></td>
<td>
<p>An hypothesised pedigree connecting two individuals.</p>
</td></tr>
<tr><td><code id="ELR_+3A_true">true</code></td>
<td>
<p>The true relationship between the two individuals.</p>
</td></tr>
<tr><td><code id="ELR_+3A_ids">ids</code></td>
<td>
<p>A vector containing the names of the two individuals. Note: These
must occur in both <code>x</code> and <code>true</code>.</p>
</td></tr>
<tr><td><code id="ELR_+3A_l1">L1</code></td>
<td>
<p>The number of alleles at the first locus.</p>
</td></tr>
<tr><td><code id="ELR_+3A_l2">L2</code></td>
<td>
<p>The number of alleles at the second locus, or NULL (default).</p>
</td></tr>
<tr><td><code id="ELR_+3A_rho">rho</code></td>
<td>
<p>(If <code>L2</code> is not NULL.) A numeric vector of recombination
fractions. Values outside the interval <code class="reqn">[0, 0.5]</code> will raise an error.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A single number, the expected LR.
</p>


<h3>References</h3>

<p>Egeland, T. and Slooten, K. (2016). <em>The likelihood ratio as a
random variable for linked markers in kinship analysis</em>. Int J Legal Med.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#############################
# Fig. 2 of Egeland &amp; Slooten
#############################

rhos = seq(0, 0.5, length = 11)

dat = cbind(
  Grand = ELR(linearPed(2), ids = c(1,5), L1 = 10, L2 = 30, rho = rhos),
  Half = ELR(halfSibPed(), ids = c(4,5), L1 = 10, L2 = 30, rho = rhos),
  Uncle = ELR(avuncularPed(), ids = c(3,6), L1 = 10, L2 = 30, rho = rhos))

matplot(rhos, dat, type = "l",  lwd = 2, ylab = "E[LR]", ylim = c(0, 8))
legend("bottomleft", legend = colnames(dat), lty = 1:3, col = 1:3, lwd = 2)



</code></pre>

<hr>
<h2 id='external_coefs'>Relatedness coefficients by other programs</h2><span id='topic+external_coefs'></span><span id='topic+kinship2_kinship'></span><span id='topic+kinship2_inbreeding'></span>

<h3>Description</h3>

<p>Wrappers for functions in other packages or external programs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kinship2_kinship(x, ids = NULL, Xchrom = FALSE)

kinship2_inbreeding(x, Xchrom = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="external_coefs_+3A_x">x</code></td>
<td>
<p>A pedigree, in the form of a <code><a href="pedtools.html#topic+ped">pedtools::ped</a></code> object.</p>
</td></tr>
<tr><td><code id="external_coefs_+3A_ids">ids</code></td>
<td>
<p>A integer vector of length 2.</p>
</td></tr>
<tr><td><code id="external_coefs_+3A_xchrom">Xchrom</code></td>
<td>
<p>A logical, indicating if the autosomal (default) or
X-chromosomal coefficients should be computed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>kinship2_kinship()</code> and <code>kinship2_inbreeding()</code> both wrap
<code><a href="kinship2.html#topic+kinship">kinship2::kinship()</a></code>.
</p>


<h3>Value</h3>

<p>For <code>kinship2_inbreeding()</code>, a numerical vector with inbreeding coefficients,
named with ID labels.
</p>
<p>For <code>kinship2_kinship()</code>, either a single numeric (if <code>ids</code> is a pair of
pedigree members) or the whole kinship matrix, with the ID labels as
dimnames.
</p>


<h3>See Also</h3>

<p><code><a href="kinship2.html#topic+kinship">kinship2::kinship()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># A random pedigree with 7 individuals
p = randomPed(n = 7, seed = 123)

### Kinship matrix

# Autosomal: Check that ribd agrees with kinship2
stopifnot(identical(
  kinship(p),          # ribd
  kinship2_kinship(p)  # kinship2
))

# X chromosomal kinship
stopifnot(identical(
  kinship(p, Xchrom = TRUE),          # ribd
  kinship2_kinship(p, Xchrom = TRUE)  # kinship2
))


### Inbreeding coefficients

# Autosomal
stopifnot(identical(
  inbreeding(p),          # ribd
  kinship2_inbreeding(p)  # kinship2
))

# X chromosomal
stopifnot(identical(
  inbreeding(p, Xchrom = TRUE),          # ribd
  kinship2_inbreeding(p, Xchrom = TRUE)  # kinship2
))


</code></pre>

<hr>
<h2 id='gKinship'>Generalised kinship coefficients</h2><span id='topic+gKinship'></span><span id='topic+gip'></span>

<h3>Description</h3>

<p>Computes single-locus generalised kinship coefficients of various kinds.
These are fundamental for computing identity coefficients (see
<code><a href="#topic+identityCoefs">identityCoefs()</a></code>), but are also interesting in their own right. Each
generalised kinship coefficient is defined as the probability of observing a
corresponding <em>generalised IBD pattern</em>, as defined and discussed in the
Details section below.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gKinship(
  x,
  pattern,
  distinct = TRUE,
  Xchrom = FALSE,
  method = c("auto", "K", "WL", "LS", "GC"),
  verbose = FALSE,
  debug = FALSE,
  mem = NULL,
  ...
)

gip(x, pattern, distinct = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gKinship_+3A_x">x</code></td>
<td>
<p>A <code>ped</code> object.</p>
</td></tr>
<tr><td><code id="gKinship_+3A_pattern">pattern</code></td>
<td>
<p>A <code>gip</code> object, or a list of vectors to be passed onto
<code><a href="#topic+gip">gip()</a></code>. Each vector should contain members of <code>x</code> constituting an IBD
block. (See Details and Examples.)</p>
</td></tr>
<tr><td><code id="gKinship_+3A_distinct">distinct</code></td>
<td>
<p>A logical indicating if different blocks are required to be
non-IBD. Default: TRUE. (Irrelevant for single-block patterns.)</p>
</td></tr>
<tr><td><code id="gKinship_+3A_xchrom">Xchrom</code></td>
<td>
<p>A logical, by default FALSE.</p>
</td></tr>
<tr><td><code id="gKinship_+3A_method">method</code></td>
<td>
<p>Either &quot;auto&quot;, &quot;K&quot;, &quot;WL&quot;, &quot;LS&quot; or &quot;GC&quot;.</p>
</td></tr>
<tr><td><code id="gKinship_+3A_verbose">verbose</code></td>
<td>
<p>A logical, by default FALSE.</p>
</td></tr>
<tr><td><code id="gKinship_+3A_debug">debug</code></td>
<td>
<p>A logical, by default FALSE.</p>
</td></tr>
<tr><td><code id="gKinship_+3A_mem">mem</code></td>
<td>
<p>For internal use.</p>
</td></tr>
<tr><td><code id="gKinship_+3A_...">...</code></td>
<td>
<p>Further arguments.</p>
</td></tr>
</table>


<h3>Details</h3>



<h4>The starting point: standard kinship coefficients</h4>

<p>The classical kinship coefficient phi between two pedigree members A and B,
is the probability that two alleles sampled from A and B (one from each), at
a random autosomal locus, are identical by descent (IBD).
</p>
<p>In the language and notation to be introduced shortly, we would write <code style="white-space: pre;">&#8288;phi = Pr[(A,B)]&#8288;</code> where <code style="white-space: pre;">&#8288;(A,B)&#8288;</code> is an <em>IBD pattern</em>.
</p>



<h4>Generalised IBD patterns</h4>

<p>We define a <em>generalised IBD pattern</em> (GIP) to be a partition of a set of
alleles drawn from members of a pedigree, such that the alleles in each
subset are IBD. Each subset (also referred to as a <em>group</em> or a <em>block</em>) is
written as a collection of pedigree members (A, B, ...), with the
understanding that each member represents one of its alleles at the given
locus. A member may occur in multiple blocks, and also more than once within
a block.
</p>
<p>Additional requirements give rise to different flavours of GIPs (and their
corresponding coefficients):
</p>

<ul>
<li> <p><code>Distinct</code> (resp. <code>non-distinct</code>): alleles in different blocks are non-IBD
(resp. may be IBD)
</p>
</li>
<li> <p><code>Deterministic</code> (resp. <code>random</code>): the parental origin (paternal or
maternal) of each allele is fixed (resp. unknown).
</p>
</li></ul>

<p>We may say that a GIP is <em>partially</em> (rather than <em>fully</em>) deterministic if
the parental origin is fixed for some, but not all alleles involved.
</p>



<h4>Notational examples</h4>

<p>Our notation distinguishes the different types of patterns, as exemplified
below. Blocks are separated with &quot;/&quot; if they are distinct, and &quot;&amp;&quot; otherwise.
Deterministically sampled alleles are suffixed by either &quot;:p&quot; (paternal) or
&quot;:m&quot; (maternal).
</p>

<ul>
<li> <p><code style="white-space: pre;">&#8288;(A, B) &amp; (A, C)&#8288;</code>: 4 alleles are sampled randomly; two from A, one from B
and one from C. The first from A is IBD with that from B, and the second from
A is IBD with that from C. All four alleles may be IBD. [Random,
non-distinct]
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;(A, B) / (A, C)&#8288;</code>: Same as the previous, but the two allele pairs must be
non-IBD. [Random, distinct]
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;(A:p, C:p) / (C:m)&#8288;</code>: The paternal alleles of A and C are IBD, and
different from the maternal allele of C. [Deterministic, distinct]
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;(A, C:p) &amp; (B, C:m)&#8288;</code>: The paternal and maternal alleles of C are IBD with
random alleles of from A and B, respectively. The two pairs are not
necessarily different. [Partially deterministic, non-distinct]
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;(A:p, A, A)&#8288;</code>: Here we have just one group, specifying that the paternal
allele of A is IBD with two other alleles sampled randomly from A. (If A is
non-inbred, this must have probability 1/4.) [Partially deterministic,
single-block]
</p>
</li></ul>

<p>In the <code>gip()</code> constructor, deterministic sampling is indicated by naming
elements with &quot;p&quot; or &quot;m&quot;, e.g., <code>c(p = A)</code> produces <code>(A:p)</code>. See Examples for
how to create the example patterns listed above.
</p>



<h4>Internal structure of <code>gip</code> objects</h4>

<p>(Note: This section is included only for completeness; <code>gip</code> objects should
not be directly manipulated by end users.)
</p>
<p>Internally, a GIP is stored as a list of integer vectors, each vector giving
the indices of pedigree members constituting an IBD block. In addition, the
object has three attributes:
</p>

<ul>
<li> <p><code>labs</code>: A character vector containing the names of all pedigree members
</p>
</li>
<li> <p><code>deterministic</code>: A logical, which is TRUE if the pattern is (partially or
fully) deterministic
</p>
</li>
<li> <p><code>distinct</code>: A logical.
</p>
</li></ul>

<p>If <code>deterministic = TRUE</code>, the last digit of each integer encodes the
parental origin of the allele (0 = unknown; 1 = paternal; 2 = maternal). For
example:
</p>

<ul>
<li><p> 12 = the maternal origin of individual 1
</p>
</li>
<li><p> 231 = the paternal allele of individual 23
</p>
</li>
<li><p> 30 = a random allele of individual 3
</p>
</li></ul>




<h4>A brief history of generalised kinship coefficients</h4>

<p>The notion of generalised kinship coefficients originated with Karigl (1981)
who used a selection of random, non-distinct patterns (in our terminology) to
compute identity coefficients.
</p>
<p>Weeks &amp; Lange (1988), building on Karigl's work, defined random, distinct
patterns in full generality and gave an algorithm for computing the
corresponding coefficients.
</p>
<p>In a follow-up paper, Lange &amp; Sinsheimer (1992) introduced partially
deterministic (distinct) patterns, and used these to compute detailed
identity coefficients.
</p>
<p>In another follow-up, Weeks et al. (1995) extended the work on random,
distinct patterns by Weeks &amp; Lange (1988) to X-chromosomal loci.
</p>
<p>Garcia-Cortes (2015) gave an alternative algorithm for the detailed identity
coefficients, based on (in our terminology) fully deterministic, non-distinct
patterns.
</p>



<h4>Implemented algorithms</h4>

<p>The following are valid options for the <code>methods</code> parameters, and what they
implement.
</p>

<ul>
<li> <p><code>auto</code>: Chooses method automatically, based on the pattern type.
</p>
</li>
<li> <p><code>K</code>: Karigl's algorithm for random, non-distinct patterns. Only the cases
considered by Karigl are currently supported, namely single groups up to
length 4, and two groups of length two. The implementation in <strong>ribd</strong>
includes an X-chromosomal version, and allows inbred founders.
</p>
</li>
<li> <p><code>WL</code>: Weeks &amp; Lange's algorithm for random, distinct patterns of any size.
[TODO: Include the extension to X by Weeks et al. (1995).]
</p>
</li>
<li> <p><code>LS</code>: Lange &amp; Sinsheimer's algorithm for partially deterministic, distinct
patterns of any size. Does not support X, nor patterns involving inbred
founders.
</p>
</li>
<li> <p><code>GC</code>: Garcia-Cortes' algorithm for fully deterministic, non-distinct
patterns. The current implementation only covers the patterns needed to
compute identity coefficients, namely single blocks and two blocks of length
two. The original algorithm has been extended to an X-chromosomal version,
and to pedigrees with inbred founders.
</p>
</li></ul>




<h3>Value</h3>

<p><code>gKinship()</code> returns a single number, the probability of the given
IBD pattern.
</p>
<p><code>gip()</code> returns an object of class <code>gip</code>. This is internally a list
of integer vectors, with attributes <code>labs</code>, <code>deterministic</code> and <code>distinct</code>.
(See also Details.)
</p>


<h3>References</h3>


<ul>
<li><p> G. Karigl (1981). A recursive algorithm for the calculation of identity
coefficients. Ann. Hum. Genet.
</p>
</li>
<li><p> D.E. Weeks &amp; K. Lange (1988). The affected-pedigree-member method of
linkage analysis. Am. J. Hum. Genet
</p>
</li>
<li><p> K. Lange &amp; J.S. Sinsheimer (1992). Calculation of genetic identity
coefficients. Ann. Hum. Genet.
</p>
</li>
<li><p> D.E. Weeks, T.I. Valappil, M. Schroeder, D.L. Brown (1995) An X-linked
version of the affected-pedigree-member method of linkage analysis. Hum
Hered.
</p>
</li>
<li><p> L.A. García-Cortés (2015). A novel recursive algorithm for the calculation
of the detailed identity coefficients. Gen Sel Evol.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+kinship">kinship()</a></code>, <code><a href="#topic+identityCoefs">identityCoefs()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
### Trivial examples ###

x = nuclearPed(father = "A", mother = "B", children = "C")

# Random, distinct
patt1 = gip(x, list(c("A", "B"), c("A", "C")))
patt1

# Random, non-distinct
patt2 = gip(x, list(c("A", "B"), c("A", "C")), distinct = FALSE)
patt2

# Fully deterministic, distinct
patt3 = gip(x, list(c(p="A", p="C"), c(m="C")))
patt3

# Partially deterministic, non-distinct`
patt4 = gip(x, list(c("A", p="C"), c("B", m="C")), distinct = FALSE)
patt4

# Partially deterministic, single block
patt5 = gip(x, list(c(p="A", "A", "A")))
patt5

stopifnot(
  gKinship(x, patt1) == 0,      # (since A and B are unrelated)
  gKinship(x, patt2) == 0,      # (same as previous)
  gKinship(x, patt3) == 0.5,    # (only uncertainty is which allele A gave to C)
  gKinship(x, patt4) == 0.25,   # (distinct irrelevant)
  gKinship(x, patt5) == 0.25   # (both random must hit the paternal)
)



### Kappa coefficients via generalised kinship ###

# NB: Much less efficient than `kappaIBD()`; only for validation

kappa_from_gk = function(x, ids, method = "WL") {
  fa1 = father(x, ids[1])
  fa2 = father(x, ids[2])
  mo1 = mother(x, ids[1])
  mo2 = mother(x, ids[2])

  GK = function(...) gKinship(x, list(...), method = method)

  k0 = GK(fa1, fa2, mo1, mo2)
  k1 = GK(c(fa1, fa2), mo1, mo2) + GK(c(fa1, mo2), fa2, mo1) +
       GK(c(mo1, fa2), fa1, mo2) + GK(c(mo1, mo2), fa1, fa2)
  k2 = GK(c(fa1, fa2), c(mo1, mo2)) + GK(c(fa1, mo2), c(mo1, fa2))
  c(k0, k1, k2)
}

y1 = nuclearPed(2); ids = 3:4
stopifnot(kappa_from_gk(y1, ids) == kappaIBD(y1, ids))

y2 = quadHalfFirstCousins(); ids = 9:10
stopifnot(kappa_from_gk(y2, ids) == kappaIBD(y2, ids))


### Detailed outputs and debugging ###

x = fullSibMating(1)

# Probability of sampling IBD alleles from 1, 5 and 6
p1 = gip(x, list(c(1,5,6)))
p1
gKinship(x, p1, method = "K", verbose = TRUE, debug = TRUE)
gKinship(x, p1, method = "WL", verbose = TRUE, debug = TRUE)

# Probability that paternal of 5 is IBD with maternal of 6
p2 = gip(x, list(c(p=5, m=6)))
p2
gKinship(x, p2, method = "LS", verbose = TRUE, debug = TRUE)
gKinship(x, p2, method = "GC", verbose = TRUE, debug = TRUE)

# Probability that paternal of 5 is *not* IBD with maternal of 6
p3 = gip(x, list(c(p=5), c(m=6)), distinct = TRUE)
p3
gKinship(x, p3, method = "LS", verbose = TRUE, debug = TRUE)


</code></pre>

<hr>
<h2 id='ibdDraw'>Colourised IBD plot</h2><span id='topic+ibdDraw'></span>

<h3>Description</h3>

<p>This is a pedagogical tool for illustrating the concept of
identity-by-descent, by representing the alleles in a pedigree by coloured
points or letters. By default, the alleles are placed below each pedigree
symbol, but this may be modified. (See examples.)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ibdDraw(
  x,
  alleles,
  symbol = c("point", "text"),
  pos = 1,
  cols = NULL,
  cex = NA,
  sep = 1,
  dist = 1,
  labs = FALSE,
  checkFounders = TRUE,
  checkParents = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ibdDraw_+3A_x">x</code></td>
<td>
<p>A <code>ped</code> object.</p>
</td></tr>
<tr><td><code id="ibdDraw_+3A_alleles">alleles</code></td>
<td>
<p>A list of length <code>pedsize(x)</code>. Each element should consist of
one or two integers, representing different colours. Zeroes produce
&quot;greyed-out&quot; alleles.</p>
</td></tr>
<tr><td><code id="ibdDraw_+3A_symbol">symbol</code></td>
<td>
<p>Either &quot;point&quot; or &quot;text&quot;.</p>
</td></tr>
<tr><td><code id="ibdDraw_+3A_pos">pos</code></td>
<td>
<p>A vector recycled to the length of <code>labels(x)</code>, indicating allele
placement relative to the pedigree symbols: 0 = inside; 1 = below; 2 =
left; 3 = above; 4 = right. By default, all are placed below.</p>
</td></tr>
<tr><td><code id="ibdDraw_+3A_cols">cols</code></td>
<td>
<p>A colour vector corresponding to the integers occurring in
<code>alleles</code>.</p>
</td></tr>
<tr><td><code id="ibdDraw_+3A_cex">cex</code></td>
<td>
<p>An expansion factor for the allele points/letters. Default: 3 for
points and 2 for text.</p>
</td></tr>
<tr><td><code id="ibdDraw_+3A_sep">sep</code></td>
<td>
<p>The separation between alleles within a pair, given as a multiple
of the width of a pedigree symbol. Default is 1 when <code>pos &gt; 0</code> and 0.5 for
<code>pos = 0</code>.</p>
</td></tr>
<tr><td><code id="ibdDraw_+3A_dist">dist</code></td>
<td>
<p>The distance between pedigree symbols and the alleles, given as a
multiple of symbol size. Default: 1. Ignored when <code>pos = 0</code>.</p>
</td></tr>
<tr><td><code id="ibdDraw_+3A_labs">labs</code></td>
<td>
<p>A logical indicating if labels should be included.</p>
</td></tr>
<tr><td><code id="ibdDraw_+3A_checkfounders">checkFounders</code></td>
<td>
<p>A logical. If TRUE (default), a warning is issued if a
founder has two equal alleles other than 0.</p>
</td></tr>
<tr><td><code id="ibdDraw_+3A_checkparents">checkParents</code></td>
<td>
<p>A logical. If TRUE (default), a warning is issued if
someone's alleles don't match those of the parents. This a superficial test
and does not catch all Mendelian errors.</p>
</td></tr>
<tr><td><code id="ibdDraw_+3A_...">...</code></td>
<td>
<p>Further arguments passed on to <code>plot.ped()</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The plot structure is returned invisibly.
</p>


<h3>See Also</h3>

<p><code><a href="pedtools.html#topic+plot.ped">pedtools::plot.ped()</a></code>, <code>ibdsim2::haploDraw()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>op = par(no.readonly = TRUE)

###############################
# Example 1: A family quartet #
###############################

x = nuclearPed(2)
als = list(1:2, 3:4, c(1,3), c(2,3))

# Default options
ibdDraw(x, als)

# Nicer colors
cols = c(7, 3, 2, 4)
ibdDraw(x, als, cols = cols)

# Inside the pedigree symbols
ibdDraw(x, als, cols = cols, pos = 0, symbolsize = 2.5)

# Other placements
ibdDraw(x, als, cols = cols, pos = c(2, 3, 1, 4))

# Letters instead of points
ibdDraw(x, als, cols = cols, symbol = "text")

# Further arguments (note that `col` is an argument of `ped.plot()`)
ibdDraw(x, als, cols = cols, pos = 0, symbolsize = 2.5,
        labs = TRUE, fill = "lightgray")

# Mutations are warned about (unless `checkParents = FALSE`)
ibdDraw(x, alleles = list(1:2, 3:4, 5, 6))


##############################
# Example 2: Cousin pedigree #
##############################

x = cousinPed(1) |&gt; swapSex(3) |&gt; relabel()
als = list(1:2, 3:4, NULL, c(1,3), c(2,3), NULL, 3, 3)

cols = c(7, 3, 2, 4)
ibdDraw(x, als, cols = cols, dist = 0.8)
ibdDraw(x, als, cols = cols, dist = 0.8, symbol = "text")

# Alternative: 0's give greyed-out alleles
als2 = list(1:2, 3:4, c(0,0), c(1,3), c(2,3), c(0,0), c(0,3), c(3,0))

ibdDraw(x, als2, cols = cols, dist = 0.8)
ibdDraw(x, als2, cols = cols, dist = 0.8, symbol = "text")


############################
# Example 3: X inheritance #
############################

x = nuclearPed(2, sex = c(1, 2))
als = list(1, 2:3, 3, c(1, 3))
ibdDraw(x, als, cols = c(3, 7, 2))


#################################
# Example 4: mtDNA inheritance  #
#################################

x = linearPed(2, sex = 2)
als = list(1, 2, 3, 2, 2)
ibdDraw(x, als, cols = 2:4)


# Restore graphics parameters
par(op)

</code></pre>

<hr>
<h2 id='ibdTriangle'>IBD triangle plot</h2><span id='topic+ibdTriangle'></span>

<h3>Description</h3>

<p>A relationship triangle used to used to visualize the kappa coefficients of
between non-inbred individuals. Various annotations are available, including
points marking the most common relationships, contour lines for the kinship
coefficients, and shading of the unattainable region. The companion function
<code><a href="#topic+showInTriangle">showInTriangle()</a></code> (which plots user-specified points onto the triangle) is
probably the most useful for end users.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ibdTriangle(
  relationships = c("UN", "PO", "MZ", "S", "H,U,G", "FC"),
  plotType = c("base", "ggplot2", "plotly"),
  pch = 19,
  cexPoint = 1.2,
  cexText = 1.2,
  cexAxis = cexText,
  kinshipLines = numeric(),
  shortLines = FALSE,
  shading = "gray90",
  xlim = c(0, 1),
  ylim = c(0, 1),
  axes = FALSE,
  las = 1,
  xlab = expression(kappa[0]),
  ylab = expression(kappa[2]),
  title = NULL,
  mar = c(2.1, 2.1, 1, 1),
  xpd = TRUE,
  keep.par = TRUE,
  cexLab = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ibdTriangle_+3A_relationships">relationships</code></td>
<td>
<p>A character vector indicating the <em>fixed</em> relationships
points to be included in the plot. Valid entries are those in the <code>label</code>
column of <a href="#topic+basicRelationships">basicRelationships</a>.</p>
</td></tr>
<tr><td><code id="ibdTriangle_+3A_plottype">plotType</code></td>
<td>
<p>Either &quot;base&quot; (default), &quot;ggplot2&quot; or &quot;plotly&quot;. Abbreviations
are allowed.</p>
</td></tr>
<tr><td><code id="ibdTriangle_+3A_pch">pch</code></td>
<td>
<p>Symbol used for the relationship points (see <code><a href="graphics.html#topic+par">par()</a></code>).</p>
</td></tr>
<tr><td><code id="ibdTriangle_+3A_cexpoint">cexPoint</code></td>
<td>
<p>A number controlling the symbol size for the relationship
points.</p>
</td></tr>
<tr><td><code id="ibdTriangle_+3A_cextext">cexText</code></td>
<td>
<p>A number controlling the font size for the relationship
labels.</p>
</td></tr>
<tr><td><code id="ibdTriangle_+3A_cexaxis">cexAxis</code></td>
<td>
<p>A number controlling the font size for the axis labels.</p>
</td></tr>
<tr><td><code id="ibdTriangle_+3A_kinshiplines">kinshipLines</code></td>
<td>
<p>A numeric vector (see Details).</p>
</td></tr>
<tr><td><code id="ibdTriangle_+3A_shortlines">shortLines</code></td>
<td>
<p>A logical indicating if the kinship lines (if present)
should be restricted to the interior of the triangle.</p>
</td></tr>
<tr><td><code id="ibdTriangle_+3A_shading">shading</code></td>
<td>
<p>The shading colour for the unattainable region.</p>
</td></tr>
<tr><td><code id="ibdTriangle_+3A_xlim">xlim</code>, <code id="ibdTriangle_+3A_ylim">ylim</code>, <code id="ibdTriangle_+3A_xpd">xpd</code>, <code id="ibdTriangle_+3A_las">las</code></td>
<td>
<p>Graphical parameters; see <code><a href="graphics.html#topic+par">par()</a></code>. (Base plot only.)</p>
</td></tr>
<tr><td><code id="ibdTriangle_+3A_axes">axes</code></td>
<td>
<p>A logical: Draw surrounding axis box? Default: <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="ibdTriangle_+3A_xlab">xlab</code>, <code id="ibdTriangle_+3A_ylab">ylab</code></td>
<td>
<p>Axis labels.</p>
</td></tr>
<tr><td><code id="ibdTriangle_+3A_title">title</code></td>
<td>
<p>Main title (absent by default).</p>
</td></tr>
<tr><td><code id="ibdTriangle_+3A_mar">mar</code></td>
<td>
<p>Graphical parameter; see <code><a href="graphics.html#topic+par">par()</a></code>. For ggplot2, this is ignored
unless it is a ggplot2::margin() object.</p>
</td></tr>
<tr><td><code id="ibdTriangle_+3A_keep.par">keep.par</code></td>
<td>
<p>A logical. If TRUE, the graphical parameters are not reset
after plotting, which may be useful for adding additional annotation. (Base
plot only.)</p>
</td></tr>
<tr><td><code id="ibdTriangle_+3A_cexlab">cexLab</code></td>
<td>
<p>Deprecated; use <code>cexAxis</code> instead.</p>
</td></tr>
<tr><td><code id="ibdTriangle_+3A_...">...</code></td>
<td>
<p>Further arguments; currently not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For any pair of non-inbred individuals A and B, their genetic relationship
can be summarized by the IBD coefficients <code class="reqn">(\kappa_0, \kappa_1,
\kappa_2)</code>, where <code class="reqn">\kappa_i</code> = P(A and B
share i alleles IBD at random autosomal locus). Since <code class="reqn">\kappa_0 +
\kappa_1 + \kappa_2 = 1</code>, any relationship
corresponds to a point in the triangle in the <code class="reqn">(\kappa_0,
\kappa_2)</code>-plane defined by <code class="reqn">\kappa_0 \ge 0, \kappa_2
\ge 0, \kappa_0 + \kappa_2 \le 1</code>. The choice of <code class="reqn">\kappa_0</code> and
<code class="reqn">\kappa_2</code> as the axis variables is done for reasons of symmetry
and is not significant (other authors have used different views of the
triangle).
</p>
<p>As shown by Thompson (1976), points in the subset of the triangle defined by
<code class="reqn">4\kappa_0\kappa_2 &gt; \kappa_1^2</code> are
unattainable for pairwise relationships. By default this region in shaded in
a light grey colour, but this can be modified with the <code>shading</code> argument.
</p>
<p>The IBD coefficients are linearly related to the kinship coefficient
<code class="reqn">\varphi</code> by the formula <code class="reqn">\varphi = 0.25\kappa_1 + 0.5\kappa_2.</code> By indicating values for <code class="reqn">\varphi</code> in the
<code>kinshipLines</code> argument, the corresponding contour lines are shown in the
triangle plot. (Currently only when <code>plotType = "base"</code>.)
</p>


<h3>Value</h3>

<p><code>NULL</code> if <code>plotType = 'base'</code>; otherwise the plot object.
</p>


<h3>References</h3>


<ul>
<li><p> E. A. Thompson (1975). <em>The estimation of pairwise relationships.</em> Annals
of Human Genetics 39.
</p>
</li>
<li><p> E. A. Thompson (1976). <em>A restriction on the space of genetic
relationships.</em> Annals of Human Genetics 40.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+showInTriangle">showInTriangle()</a></code>, <code><a href="#topic+kappaIBD">kappaIBD()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>opar = par(no.readonly = TRUE) # store graphical parameters

ibdTriangle()
ibdTriangle(kinshipLines = c(0.25, 0.125), shading = NULL, cexText = 0.7)
ibdTriangle(kinshipLines = c(0.25, 0.125), shortLines = TRUE, pch = 15)
ibdTriangle(relationships = c("UN", "PO", "MZ", "S"),
            xlab = "k0", ylab = "k2", las = 0, axes = TRUE, cexAxis =1.6)

par(opar) # reset graphical parameters

</code></pre>

<hr>
<h2 id='identityCoefs'>Omnibus function for identity coefficients</h2><span id='topic+identityCoefs'></span><span id='topic+detailed2condensed'></span>

<h3>Description</h3>

<p>This function calculates the pairwise identity coefficients described by
Jacquard (1974). Unlike the previous <code><a href="#topic+condensedIdentity">condensedIdentity()</a></code> (which will
continue to exist), this function also computes the 15 <em>detailed</em> identity
coefficients. The implementation supports pedigrees with inbred founders, and
X-chromosomal coefficients.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>identityCoefs(
  x,
  ids = labels(x),
  detailed = FALSE,
  Xchrom = FALSE,
  self = FALSE,
  simplify = TRUE,
  method = c("auto", "K", "WL", "LS", "GC", "idcoefs", "identity", "merlin"),
  verbose = FALSE,
  ...
)

detailed2condensed(d)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="identityCoefs_+3A_x">x</code></td>
<td>
<p>A pedigree in the form of a <code><a href="pedtools.html#topic+ped">pedtools::ped</a></code> object.</p>
</td></tr>
<tr><td><code id="identityCoefs_+3A_ids">ids</code></td>
<td>
<p>A vector of two ID labels.</p>
</td></tr>
<tr><td><code id="identityCoefs_+3A_detailed">detailed</code></td>
<td>
<p>A logical. If FALSE (default), the 9 condensed coefficients
are computed; otherwise the 15 detailed identity coefficients.</p>
</td></tr>
<tr><td><code id="identityCoefs_+3A_xchrom">Xchrom</code></td>
<td>
<p>A logical, by default FALSE.</p>
</td></tr>
<tr><td><code id="identityCoefs_+3A_self">self</code></td>
<td>
<p>A logical indicating if self-relationships (i.e., between a
pedigree member and itself) should be included. FALSE by default.</p>
</td></tr>
<tr><td><code id="identityCoefs_+3A_simplify">simplify</code></td>
<td>
<p>Simplify the output (to a numeric of length 9) if <code>ids</code> has
length 2. Default: TRUE.</p>
</td></tr>
<tr><td><code id="identityCoefs_+3A_method">method</code></td>
<td>
<p>Either &quot;auto&quot;, &quot;K&quot;, &quot;WL&quot;, &quot;LS&quot;, &quot;GC&quot;, &quot;idcoefs&quot;, &quot;identity&quot; or
&quot;merlin&quot;. By default (&quot;auto&quot;) a suitable algorithm is chosen automatically.</p>
</td></tr>
<tr><td><code id="identityCoefs_+3A_verbose">verbose</code></td>
<td>
<p>A logical.</p>
</td></tr>
<tr><td><code id="identityCoefs_+3A_...">...</code></td>
<td>
<p>Further arguments.</p>
</td></tr>
<tr><td><code id="identityCoefs_+3A_d">d</code></td>
<td>
<p>Either a numeric vector of length 15, or a data frame with 17
columns.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Both the condensed and detailed coefficients are given in the orders used by
Jacquard (1974). The function <code>detailed2condensed()</code> converts from detailed
coefficients (d1, ..., d15) to condensed ones (D1, ..., D9) using the
following relations:
</p>

<ul>
<li><p> D1 = d1
</p>
</li>
<li><p> D2 = d6
</p>
</li>
<li><p> D3 = d2 + d3
</p>
</li>
<li><p> D4 = d7
</p>
</li>
<li><p> D5 = d4 + d5
</p>
</li>
<li><p> D6 = d8
</p>
</li>
<li><p> D7 = d9 + d12
</p>
</li>
<li><p> D8 = d10 + d11 + d13 + d14
</p>
</li>
<li><p> D9 = d15
</p>
</li></ul>



<h4>Algorithms for computing identity coefficients</h4>

<p>The following is a brief overview of various algorithms for computing
(single-locus) condensed and/or detailed identity coefficients. This topic is
closely linked to that of <em>generalised kinship coefficients</em>, which is
further described in the documentation of <code><a href="#topic+gKinship">gKinship()</a></code>.
</p>
<p>For each algorithm below, it is indicated in brackets how to enforce it in
<code>identityCoefs()</code>.
</p>

<ul>
<li><p> Karigl (1981) gave the first recursive algorithm for the 9 condensed
identity coefficients. [<code>method = "K"</code>]
</p>
</li>
<li><p> Weeks &amp; Lange (1988) suggested a broader and more natural generalisation of
kinship coefficients, leading to a slightly different algorithm for condensed
coefficients. [<code>method = "WL"</code>]
</p>
</li>
<li><p> Lange &amp; Sinsheimer (1992) described an even further generalisation of
kinship coefficients, allowing a mix of deterministic and random sampling of
alleles. They used this to give (i) an alternative algorithm for the 9
condensed identity coefficients, and (ii) an algorithm for the 15 detailed
coefficients. [<code>method = "LS"</code>]
</p>
</li>
<li><p> The C program <code>IdCoefs</code> (version 2.1.1) by Mark Abney (2009) uses a graph
model to obtain very fast computation of condensed identity coefficients.
This requires <code>IdCoefs</code> to be installed on the computer (see link under
References) and available on the system search path. The function then writes
the necessary files to disk and calls <code>IdCoefs</code> via <code><a href="base.html#topic+system">system()</a></code>. [<code>method = "idcoefs"</code>]
</p>
</li>
<li><p> The R package <code>identity</code> provides an R interface for <code>IdCoefs</code>, avoiding
calls to <code>system()</code>. [<code>method = "identity"</code>]
</p>
</li>
<li><p> The MERLIN software (Abecasis et al, 2002) offers an option &quot;&ndash;extended&quot;
for computing detailed identity coefficients. This option requires MERLIN to
be installed on the system. The function then writes the necessary files to
disk and calls MERLIN via <code><a href="base.html#topic+system">system()</a></code>. If <code>detailed = FALSE</code>, the coefficients
are transformed with <code>detailed2condensed()</code> before returning. Note: MERLIN
rounds all numbers to 3 decimal places. Since this rounding is done on the
detailed coefficients, rounding errors may happen when converting to the
condensed ones. [<code>method = "merlin"</code>]
</p>
</li></ul>




<h3>Value</h3>

<p>A data frame with L + 2 columns, where L is either 9 or 15 (if
<code>detailed = TRUE</code>).
</p>
<p>If <code>simplify = TRUE</code> and <code>length(ids) = 2</code>: A numeric vector of length <code>L</code>.
</p>


<h3>References</h3>


<ul>
<li><p> Jacquard, A. (1974). The Genetic Structure of Populations. Springer.
</p>
</li>
<li><p> Karigl, G. (1981). A recursive algorithm for the calculation of identity
coefficients. Ann. Hum. Genet.
</p>
</li>
<li><p> Weeks, D.E. &amp; Lange, K. (1988). The affected-pedigree-member method of
linkage analysis. Am. J. Hum. Genet
</p>
</li>
<li><p> Lange, K. &amp; Sinsheimer, J.s. (1992). Calculation of genetic identity
coefficients. Ann. Hum. Genet.
</p>
</li>
<li><p> Abney, M. (2009). A graphical algorithm for fast computation of identity
coefficients and generalized kinship coefficients. Bioinformatics, 25,
1561-1563. <a href="https://home.uchicago.edu/~abney/abney_web/Software.html">https://home.uchicago.edu/~abney/abney_web/Software.html</a>
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+condensedIdentity">condensedIdentity()</a></code>, <code><a href="#topic+gKinship">gKinship()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x = fullSibMating(1)

### Condensed coefficients
j1 = identityCoefs(x, method = "K")
j2 = identityCoefs(x, method = "WL")
j3 = identityCoefs(x, method = "LS")
j4 = identityCoefs(x, method = "GC")
j5 = condensedIdentity(x, ids = 1:6) # legacy version

stopifnot(all.equal(j1,j2), all.equal(j1,j3), all.equal(j1,j4), all.equal(j1,j5))

### Detailed coefficients
jdet1 = identityCoefs(x, detailed = TRUE, method = "LS")
jdet2 = identityCoefs(x, detailed = TRUE, method = "GC")

stopifnot(all.equal(jdet1,jdet2))

### X-chromosomal coefficients
jx1 = identityCoefs(x, Xchrom = TRUE, method = "K")
jx2 = identityCoefs(x, Xchrom = TRUE, method = "GC")
jx3 = condensedIdentityX(x, ids = 1:6)  # legacy version

stopifnot(all.equal(jx1,jx2), all.equal(jx1,jx3))

### Detailed X-chromosomal coefficients
jdx = identityCoefs(x, detailed = TRUE, Xchrom = TRUE, method = "GC")

stopifnot(all.equal(detailed2condensed(jdx), jx1))

</code></pre>

<hr>
<h2 id='inbreeding'>Inbreeding coefficients</h2><span id='topic+inbreeding'></span>

<h3>Description</h3>

<p>Compute the inbreeding coefficients of all members of a pedigree. Both
autosomal and X-chromosomal coefficients are supported. This function is a
simple wrapper of <code><a href="#topic+kinship">kinship()</a></code>. Note that pedigree founders are allowed to be
inbred; see <code><a href="pedtools.html#topic+founderInbreeding">pedtools::founderInbreeding()</a></code> for how to set this up, and see
Examples below.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inbreeding(x, ids = NULL, Xchrom = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="inbreeding_+3A_x">x</code></td>
<td>
<p>A pedigree in the form of a <code>ped</code> object, or a list of such.</p>
</td></tr>
<tr><td><code id="inbreeding_+3A_ids">ids</code></td>
<td>
<p>A vector of ID labels, or NULL (default).</p>
</td></tr>
<tr><td><code id="inbreeding_+3A_xchrom">Xchrom</code></td>
<td>
<p>A logical, indicating if the autosomal (default) or
X-chromosomal inbreeding coefficients should be computed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The autosomal inbreeding coefficient of a pedigree member is defined as the
probability that, at a random autosomal locus, the two alleles carried by the
member are identical by descent relative to the pedigree. It follows from the
definition that the inbreeding coefficient of a non-founder equals the
kinship coefficient of the parents.
</p>
<p>The implementation here uses <code><a href="#topic+kinship">kinship()</a></code> to compute the kinship matrix, and
computes the inbreeding coefficients from the diagonal, by the formula
</p>
<p style="text-align: center;"><code class="reqn">f_a = 2*\phi_{aa} - 1.</code>
</p>

<p>The X chromosomal inbreeding coefficient of females are defined (and
computed) similarly to the autosomal case above. For males is it always
defined as 1.
</p>


<h3>Value</h3>

<p>If <code>ids</code> has length 1, the inbreeding coefficient of this individual
is returned as a single unnamed number.
</p>
<p>Otherwise, the output is a named numeric vector containing the inbreeding
coefficients of the indicated pedigree members (if <code>ids = NULL</code>: all).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+kinship">kinship()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Child of half siblings: f = 1/8
x = halfCousinPed(0, child = TRUE)

# Inbreeding vector
inbreeding(x)

# Simpler output using the `ids` argument:
inbreeding(x, ids = 6)


### X-chromosomal inbreeding ###

# Males have inbreeding coefficient 1
stopifnot(inbreeding(x, ids = 6, Xchrom = TRUE) == 1)

y1 = swapSex(x, ids = 6)  # female child
stopifnot(inbreeding(y1, ids = 6, Xchrom = TRUE) == 0)

y2 = swapSex(y1, ids = 2) # female ancestor
stopifnot(inbreeding(y2, ids = 6, Xchrom = TRUE) == 0.25)


### Inbred founder ###

# Mother 100% inbred
founderInbreeding(x, ids = 2) = 1

inbreeding(x)


# Example with selfing and complete inbreeding
s = selfingPed(1)
founderInbreeding(s, 1) = 1
stopifnot(inbreeding(s, ids = 2) == 1)

</code></pre>

<hr>
<h2 id='jicaque'>Jicaque pedigree</h2><span id='topic+jicaque'></span>

<h3>Description</h3>

<p>A data frame describing a pedigree from the Jicaque tribe, studied by Chapman
and Jacquard (1971).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>jicaque
</code></pre>


<h3>Format</h3>

<p>A data frame with 22 rows and four columns:
</p>

<ul>
<li> <p><code>id</code>  : individual ID
</p>
</li>
<li> <p><code>fid</code> : father's ID (or 0 if not included)
</p>
</li>
<li> <p><code>mid</code> : mother's ID (or 0 if not included)
</p>
</li>
<li> <p><code>sex</code> : Gender codes, where 1 = male and 2 = female
</p>
</li></ul>



<h3>References</h3>

<p>Chapman, A.M and Jacquard, A. (1971). Un isolat d'Amerique
Centrale: les Indiens Jicaques de Honduras. In Genetique et Population.
Paris: Presses Universitaires de France.
</p>

<hr>
<h2 id='kappaIBD'>IBD (kappa) coefficients</h2><span id='topic+kappaIBD'></span>

<h3>Description</h3>

<p>Computes the three IBD coefficients summarising the relationship between two
non-inbred individuals. Both autosomal and X chromosomal versions are
implemented. The pedigree founders (other than the individuals in question)
are allowed to be inbred; see <code><a href="pedtools.html#topic+founderInbreeding">pedtools::founderInbreeding()</a></code> for how to set
this up, and see Examples below.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kappaIBD(x, ids = labels(x), inbredAction = 1, simplify = TRUE, Xchrom = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kappaIBD_+3A_x">x</code></td>
<td>
<p>A pedigree in the form of a <code>ped</code> object (or a list of such).</p>
</td></tr>
<tr><td><code id="kappaIBD_+3A_ids">ids</code></td>
<td>
<p>A character (or coercible to character) containing ID labels of
two or more pedigree members.</p>
</td></tr>
<tr><td><code id="kappaIBD_+3A_inbredaction">inbredAction</code></td>
<td>
<p>An integer telling the program what to do if either of
the <code>ids</code> individuals are inbred. Possible values are: 0 = do nothing; 1 =
print a warning message (default); 2 = raise an error. In the first two
cases the coefficients are reported as <code>NA</code>.</p>
</td></tr>
<tr><td><code id="kappaIBD_+3A_simplify">simplify</code></td>
<td>
<p>Simplify the output (to a numeric of length 3) if <code>ids</code> has
length 2. Default: TRUE.</p>
</td></tr>
<tr><td><code id="kappaIBD_+3A_xchrom">Xchrom</code></td>
<td>
<p>A logical, indicating if the autosomal (default) or
X-chromosomal kappa coefficients should be computed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For non-inbred individuals a and b, their autosomal IBD coefficients
<code class="reqn">(\kappa_0, \kappa_1, \kappa_2)</code> are defined as follows: </p>
<p style="text-align: center;"><code class="reqn">\kappa_i =
P(\text{a and b share exactly i alleles IBD at a random autosomal locus})</code>
</p>

<p>The autosomal kappa coefficients are computed from the kinship coefficients.
When a and b are both nonfounders, the following formulas hold:
</p>

<ul>
<li> <p><code class="reqn">\kappa_2 = \varphi_{MM} \cdot \varphi_{FF} + \varphi_{MF} \cdot\varphi_{FM}</code>
</p>
</li>
<li> <p><code class="reqn">\kappa_1 = 4 \varphi_{ab} - 2 \kappa_2</code>
</p>
</li>
<li> <p><code class="reqn">\kappa_0 = 1 - \kappa_1 - \kappa_2</code>
</p>
</li></ul>

<p>Here <code class="reqn">\varphi_{MF}</code> denotes the kinship coefficient between the
<strong>m</strong>other of a and the <strong>f</strong>ather of b, etc. If either a or b is a founder,
then <code class="reqn">\kappa_2 = 0</code>, while the other two formulas remain as before.
</p>
<p>The X-chromosomal IBD coefficients are defined similarly to the autosomal
case. Here <code class="reqn">\kappa_2</code> is undefined when one or both individuals are male,
which greatly simplifies the calculations when males are involved. The
formulas are (with <code class="reqn">\varphi_{ab}</code> now referring to the X-chromosomal
kinship coefficient):
</p>

<ul>
<li><p> Both male: <code class="reqn">(\kappa_0, \kappa_1, \kappa_2) = (1-\varphi_{ab}, \varphi_{ab}, \text{NA})</code>
</p>
</li>
<li><p> One male, one female: <code class="reqn">(\kappa_0, \kappa_1, \kappa_2) = (1-2 \varphi_{ab},
2 \varphi_{ab}, \text{NA})</code>
</p>
</li>
<li><p> Two females: Similar formulas as in the autosomal case.
</p>
</li></ul>



<h3>Value</h3>

<p>If <code>ids</code> has length 2 and <code>simplify = TRUE</code>: A numeric vector of
length 3: <code class="reqn">(\kappa_0, \kappa_1, \kappa_2)</code>.
</p>
<p>Otherwise: A data frame with one row for each pair of individuals, and 5
columns. The first two columns contain the ID labels, and columns 3-5
contain the IBD coefficients.
</p>
<p>Kappa coefficients of inbred individuals (meaning X-inbred females if
<code>Xchrom = T</code>) are reported as NA, unless <code>inbredAction = 2</code>.
</p>
<p>The X-chromosomal <code class="reqn">\kappa_2</code> is NA whenever at least one of the two
individuals is male.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+kinship">kinship()</a></code>, <code><a href="#topic+identityCoefs">identityCoefs()</a></code> for coefficients allowing inbreeding,
<code><a href="#topic+showInTriangle">showInTriangle()</a></code> for plotting kappa coefficients in the IBD triangle.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### Siblings
x = nuclearPed(2)
kappaIBD(x)

k = kappaIBD(x, 3:4)
stopifnot(identical(k, c(.25, .5, .25)))

### Quad half first cousins
x = quadHalfFirstCousins()
k = kappaIBD(x, ids = leaves(x))
stopifnot(identical(k, c(17/32, 14/32, 1/32)))

### Paternal half brothers with 100% inbred father
# Genetically indistinguishable from an (outbred) father-son relationship
x = halfSibPed() |&gt; setFounderInbreeding(ids = 2, value = 1)
plot(x, hatched = 4:5)

k = kappaIBD(x, 4:5)
stopifnot(identical(k, c(0, 1, 0)))

### X-chromosomal kappa
y = nuclearPed(2, sex = 2)
kappaIBD(y, Xchrom = TRUE)

</code></pre>

<hr>
<h2 id='kin2deg'>Degree of relationship</h2><span id='topic+kin2deg'></span>

<h3>Description</h3>

<p>Converts a vector of kinship coefficients to &quot;degrees of relationship&quot;, as
used by some software for relatedness inference (e.g. KING).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kin2deg(kin, unrelated = Inf)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kin2deg_+3A_kin">kin</code></td>
<td>
<p>A vector of kinship coefficients, i.e., numbers in <code style="white-space: pre;">&#8288;[0, 1]&#8288;</code>.</p>
</td></tr>
<tr><td><code id="kin2deg_+3A_unrelated">unrelated</code></td>
<td>
<p>The conversion of unrelated individuals (<code>kin = 0</code>).
Mathematically this corresponds to <code>degree = Inf</code>, but in some situations
<code>degree = NA</code> or something else might be preferable.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The implementation uses the conversion formula </p>
<p style="text-align: center;"><code class="reqn">deg = round(-log2(kin) -
1).</code>
</p>

<p>The first degrees correspond to the following approximate kinship ranges:
</p>

<ul>
<li> <p><code style="white-space: pre;">&#8288;[0.354, 1]&#8288;</code>: 0th degree (MZ twins or duplicates)
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;[0.177, 0.354)&#8288;</code>: 1st degree (parent-offspring, full siblings)
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;[0.0884, 0.177)&#8288;</code>: 2nd degree (half sibs, grandparent-grandchild, avuncular)
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;[0.0442, 0.0884)&#8288;</code> 3rd degree (half-avuncular, first cousins, great-grandparent etc)
</p>
</li></ul>



<h3>Value</h3>

<p>An integer vector of the same length as <code>kin</code>.
</p>


<h3>References</h3>

<p>KING manual with thresholds for relationship degrees:
<a href="https://www.kingrelatedness.com/manual.shtml">https://www.kingrelatedness.com/manual.shtml</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+kinship">kinship()</a></code>, <code><a href="#topic+coeffTable">coeffTable()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x = cousinPed(1)

# Kinship matrix
k = kinship(x)

# Degrees
deg = kin2deg(k)
deg

# First cousins are 3rd degree
stopifnot(deg['7', '8'] == 3)

</code></pre>

<hr>
<h2 id='kinship'>Kinship coefficients</h2><span id='topic+kinship'></span>

<h3>Description</h3>

<p>Compute the matrix of pairwise kinship coefficients in a pedigree. Both
autosomal and X-chromosomal versions are supported. The pedigree founders are
allowed to be inbred; see <code><a href="pedtools.html#topic+founderInbreeding">pedtools::founderInbreeding()</a></code> for how to set this
up, and see Examples below.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kinship(x, ids = NULL, simplify = TRUE, Xchrom = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kinship_+3A_x">x</code></td>
<td>
<p>A <code>ped</code> object or a list of such.</p>
</td></tr>
<tr><td><code id="kinship_+3A_ids">ids</code></td>
<td>
<p>Either NULL (default), or a vector of ID labels in <code>x</code>.</p>
</td></tr>
<tr><td><code id="kinship_+3A_simplify">simplify</code></td>
<td>
<p>A logical. by default TRUE. See Value.</p>
</td></tr>
<tr><td><code id="kinship_+3A_xchrom">Xchrom</code></td>
<td>
<p>A logical, indicating if the autosomal (default) or
X-chromosomal kinship coefficients should be computed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For two (possibly equal) members A, B of a pedigree, their autosomal (resp.
X-chromosomal) <em>kinship coefficient</em> is defined as the probability that a
random allele from A and a random allele from B, sampled at the same
autosomal (resp. X-chromosomal) locus, are identical by descent relative to
the pedigree.
</p>


<h3>Value</h3>

<p>A symmetric N * N matrix, where N is the number of pedigree members,
or <code>length(ids)</code> if this is given, containing the pairwise kinship
coefficients. If <code>ids</code> has length 2, and <code>simplify = TRUE</code>, the function
returns a single number.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+inbreeding">inbreeding()</a></code>, <code><a href="base.html#topic+kappa">kappa()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Kinship coefficients in a nuclear family with two children
x = nuclearPed(2)
kinship(x)

# X chromosomal kinship coefficients in the same family
kinship(x, Xchrom = TRUE)

# Autosomal kinships if the mother is 100% inbred
founderInbreeding(x, 2) = 1
kinship(x)

# Similar for X:
founderInbreeding(x, 2, chromType = "X") = 1
kinship(x, Xchrom = TRUE)
</code></pre>

<hr>
<h2 id='minimalPattern'>Minimal IBD pattern</h2><span id='topic+minimalPattern'></span>

<h3>Description</h3>

<p>Compute the minimal form of given multiperson IBD pattern.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>minimalPattern(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="minimalPattern_+3A_x">x</code></td>
<td>
<p>An integer vector of even length.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An integer vector of the same length as <code>x</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>v = c(1,2,2,3)
stopifnot(identical(minimalPattern(v), c(1,2,1,3)))

</code></pre>

<hr>
<h2 id='multiPersonIBD'>Multi-person IBD coefficients</h2><span id='topic+multiPersonIBD'></span>

<h3>Description</h3>

<p>Computes the probabilities (coefficients) of all possible patterns of
identity by descent (IBD) sharing at a single locus, among N&gt;1 non-inbred
members of a pedigree. The reported coefficients are &quot;condensed&quot; in the sense
that allele ordering within each individual is ignored. For N = 2, the result
should agree with the traditional &quot;kappa&quot; coefficients, as computed by
<code><a href="#topic+kappaIBD">kappaIBD()</a></code>. This function is under development, and should be regarded as
experimental. For now, the only cases handled are those with: N = 2 or 3,
autosomal locus.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>multiPersonIBD(x, ids, complete = FALSE, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="multiPersonIBD_+3A_x">x</code></td>
<td>
<p>A <code>ped</code> object.</p>
</td></tr>
<tr><td><code id="multiPersonIBD_+3A_ids">ids</code></td>
<td>
<p>A vector of ID labels.</p>
</td></tr>
<tr><td><code id="multiPersonIBD_+3A_complete">complete</code></td>
<td>
<p>A logical. If FALSE, only IBD patterns with nonzero
probability are included in the output.</p>
</td></tr>
<tr><td><code id="multiPersonIBD_+3A_verbose">verbose</code></td>
<td>
<p>A logical. If TRUE, some computational details are printed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Consider N members of a pedigree, i1, i2, ... iN.  A pattern of IBD sharing
between these individuals is a sequence of N ordered pairs of labels, (a1_1,
a1_2), (a2_1, a2_2), ... (aN_1, aN_2), where ai_1 and ai_2 represent the
paternal and maternal allele of individual i, respectively. Equality of
labels means that the corresponding alleles are IBD, and vice versa.
</p>
<p>We say that two IBD patterns are equivalent if one can be transformed into
the other by some combination of
</p>

<ul>
<li><p> renaming the labels (without changing the structure)
</p>
</li>
<li><p> swapping the paternal/maternal labels of some individuals
</p>
</li></ul>

<p>Each equivalence class has a &quot;minimal&quot; element, using integer labels, and
being minimal with respect to standard sorting. For example, the minimal
element equivalent to <code style="white-space: pre;">&#8288;(a,c),(d,c),(b,b)&#8288;</code> is <code style="white-space: pre;">&#8288;(1,2),(2,3),(4,4)&#8288;</code>.
</p>


<h3>Value</h3>

<p>A data frame in which each row corresponds to an equivalence class of
multi-person IBD patterns. The first column gives the calculated
probability, followed by one column for each <code>ids</code> individual, describing
the minimal element of the equivalence class. (See Details.) If <code>complete = FALSE</code> (the default) rows with probability 0 are removed.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### Trivial example: Trio ###
x = nuclearPed(1)
ids = 1:3
multiPersonIBD(x, ids, complete = TRUE)

### Example due to Peter Green ###
# Three (pairwise) cousins arranged in two different ways,
# with different 3-way IBD coefficients.

threeCousins1 = ped(
  id  = c('gf','gm','gf1','gf2','gf3','gm1','gm2','gm3',
          'f1','f2','f3','m1','m2','m3','c1','c2','c3'),
  fid = c(0,0,0,0,0,0,0,0,'gf1','gf2','gf3','gf','gf','gf',
          'f1','f2','f3'),
  mid = c(0,0,0,0,0,0,0,0,'gm1','gm2','gm3','gm','gm','gm',
          'm1','m2','m3'),
  sex = c(1,2,1,1,1,2,2,2,1,1,1,2,2,2,1,1,1))

threeCousins2 = ped(
  id  = c('gf1','gf2','gf3','gm1','gm2','gm3','f1','f2','f3',
          'm1','m2','m3','c1','c2','c3'),
  fid = c(0,0,0,0,0,0,'gf2','gf3','gf1','gf3','gf1','gf2',
          'f1','f2','f3'),
  mid = c(0,0,0,0,0,0,'gm2','gm3','gm1','gm3','gm1','gm2',
          'm1','m2','m3'),
  sex = c(1,1,1,2,2,2,1,1,1,2,2,2,1,1,1))

ids = c('c1','c2','c3')
multiPersonIBD(threeCousins1, ids)
multiPersonIBD(threeCousins2, ids)

</code></pre>

<hr>
<h2 id='realisedIbdVariance'>Variance of realised relatedness coefficients</h2><span id='topic+realisedIbdVariance'></span>

<h3>Description</h3>

<p>Compute the variance of realised relatedness coefficients, by doubly
integrating the corresponding two-locus coefficients.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>realisedIbdVariance(x, ids = leaves(x), coeff, L = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="realisedIbdVariance_+3A_x">x</code></td>
<td>
<p>A ped object.</p>
</td></tr>
<tr><td><code id="realisedIbdVariance_+3A_ids">ids</code></td>
<td>
<p>A vector naming two members of <code>x</code>.</p>
</td></tr>
<tr><td><code id="realisedIbdVariance_+3A_coeff">coeff</code></td>
<td>
<p>A string naming a coefficient for which the variance is to be
computed. See Details for legal values.</p>
</td></tr>
<tr><td><code id="realisedIbdVariance_+3A_l">L</code></td>
<td>
<p>A positive number; the chromosome length in Morgan.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The double integral method was used by Guo to compute the variation in
proportion of the genome shared IBD (Guo 1995, see also Thompson 2013). The
method extends directly to other coefficients. The implementation here
supports Cotterman's kappa coefficients (of noninbred individuals), and
Jacquard's condensed identity coefficients.
</p>
<p>This function is a bare-bones implementation of the double integral method,
based on <code>stats::integrate</code>, and can probably be optimised in various ways.
</p>
<p>The <code>coeff</code> parameter must be either a character naming the coefficient to
compute, or a function. If a character, it must be one of the following
names:
</p>

<ul>
<li><p> &quot;inb&quot; (inbreeding coefficient)
</p>
</li>
<li><p> &quot;kinship&quot;, &quot;phi&quot; (synonyms for the kinship coefficient)
</p>
</li>
<li><p> &quot;k0&quot;, &quot;k1&quot;, &quot;k2&quot; (kappa coefficients of noninbred individuals)
</p>
</li>
<li><p> &quot;D1&quot;, &quot;D2&quot;, ... &quot;D9&quot; (condensed identity coefficients)
</p>
</li></ul>



<h3>Value</h3>

<p>A positive number.
</p>


<h3>References</h3>


<ul>
<li><p> Guo (1995) <em>Proportion of genome shared identical by descent by relatives:
concept, computation, and applications</em>. Am J Hum Genet.
</p>
</li>
<li><p> Hill &amp; Weir (2011). <em>Variation in actual relationship as a consequence of
Mendelian sampling and linkage</em>. Genet Res.
</p>
</li>
<li><p> Thompson (2013). <em>Identity by Descent: Variation in Meiosis, Across
Genomes, and in Populations</em>. Genetics.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>###################################
### Box 1 of Hill &amp; Weir (2011) ###
###################################

# Eq. 4b of Hill &amp; Weir
phi = function(n, l) {
 1/(2*l^2) * (1/4)^n * sum(sapply(1:n, function(r)
   choose(n, r) * (2*r*l - 1 + exp(-2*r*l))/r^2))
}

# Chromosome of 1 Morgan
L = 1

### Full sibs ###

## Not run: 
x = nuclearPed(2)
realisedIbdVariance(x, ids = 3:4, coeff = "k2", L = L)

# Hill &amp; Weir (Box 1)
16*phi(4,L) - 16*phi(3,L) + 8*phi(2,L) - 2*phi(1,L)

## End(Not run)

### Double first cousins ###

## Not run: 
dfc = doubleFirstCousins()

# Runtime ~1 min
realisedIbdVariance(dfc, coeff = "k0", L = L)
realisedIbdVariance(dfc, coeff = "k1", L = L)
realisedIbdVariance(dfc, coeff = "k2", L = L)

# Hill &amp; Weir, Box 1
var_k2 = 64*phi(8,L) - 64*phi(7,L) + 40*phi(6,L) - 20*phi(5,L) +
  33/4*phi(4,L) - 5/2*phi(3,L) + 5/8*phi(2,L)-1/8*phi(1,L)
var_k1 = 4*var_k2
var_k0 = var_k2 + 2 * (4*phi(4,L) - 2*phi(3,L) + 3/4*phi(2,L) - 1/4*phi(1,L))

var_k0
var_k1
var_k2

## End(Not run)

</code></pre>

<hr>
<h2 id='showInTriangle'>Add points to the IBD triangle</h2><span id='topic+showInTriangle'></span>

<h3>Description</h3>

<p>Utility function for plotting kappa coefficients in the IBD triangle. This
was previously only implemented as a base R plot, but is now also available
in <code>ggplot2</code> and <code>plotly</code> formats, controlled by the argument <code>plotType</code>.
Labels are often easier to read in the two latter versions: The <code>ggplot2</code>
version uses <code>ggrepel</code> to separate labels, while <code>plotly</code> enables interactive
exploration of the plot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>showInTriangle(
  kappa,
  plotType = c("base", "ggplot2", "plotly"),
  new = TRUE,
  ped = NULL,
  pedBL = c(0.5, 0.5),
  pedArgs = NULL,
  col = 6,
  cex = 1,
  pch = 4,
  lwd = 2,
  jitter = NULL,
  labels = NULL,
  colLab = col,
  cexLab = 0.8,
  labSep = "-",
  pos = 1,
  adj = NULL,
  keep.par = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="showInTriangle_+3A_kappa">kappa</code></td>
<td>
<p>Coordinates of points to be plotted in the IBD triangle. Valid
input types are:
</p>

<ul>
<li><p> A numerical vector of length 2 (kappa0, kappa2) or 3 (kappa0, kappa1,
kappa2). In the latter case kappa1 is ignored.
</p>
</li>
<li><p> A matrix of data frame, whose column names must include either <code>k0</code> and
<code>k2</code>, <code>kappa0</code> and <code>kappa2</code>, or <code>ibd0</code> and <code>ibd2</code>.
</p>
</li>
<li><p> A list (and not a data frame), in which case an attempt is made to bind
the elements row-wise.
</p>
</li></ul>
</td></tr>
<tr><td><code id="showInTriangle_+3A_plottype">plotType</code></td>
<td>
<p>Either &quot;base&quot; (default), &quot;ggplot2&quot; or &quot;plotly&quot;. Abbreviations
are allowed.</p>
</td></tr>
<tr><td><code id="showInTriangle_+3A_new">new</code></td>
<td>
<p>A logical indicating if a new triangle should be drawn.</p>
</td></tr>
<tr><td><code id="showInTriangle_+3A_ped">ped</code></td>
<td>
<p>A pedigree to be drawn in the upper right corner of the plot.
Default: NULL. This only works when <code>plotType</code> is <code>base</code> or <code>ggplot2</code>.</p>
</td></tr>
<tr><td><code id="showInTriangle_+3A_pedbl">pedBL</code></td>
<td>
<p>A vector of length two, with entries in <code style="white-space: pre;">&#8288;[0,1]&#8288;</code>, indicating the
coordinates of the bottom left corner. Default: <code>c(0.5, 0.5)</code>.</p>
</td></tr>
<tr><td><code id="showInTriangle_+3A_pedargs">pedArgs</code></td>
<td>
<p>Plotting arguments for the inset pedigree. Default: NULL.</p>
</td></tr>
<tr><td><code id="showInTriangle_+3A_col">col</code>, <code id="showInTriangle_+3A_cex">cex</code>, <code id="showInTriangle_+3A_pch">pch</code>, <code id="showInTriangle_+3A_lwd">lwd</code></td>
<td>
<p>Parameters controlling the appearance of points.</p>
</td></tr>
<tr><td><code id="showInTriangle_+3A_jitter">jitter</code></td>
<td>
<p>A logical. If NULL (default), jittering is disabled for
<code>plotType</code>'s &quot;base&quot; or &quot;ggplot2&quot; and enabled for &quot;plotly&quot;.</p>
</td></tr>
<tr><td><code id="showInTriangle_+3A_labels">labels</code></td>
<td>
<p>A character of same length as the number of points, or a single
logical <code>TRUE</code> or <code>FALSE</code>. If <code>TRUE</code>, labels are created by pasting columns
<code>id1</code> and <code>id2</code> in <code>kappa</code> (if these exist) separated by <code>labSep</code>. By
default, labels are disabled when <code>plotType = "base"</code>, enabled if <code>plotType = "ggplot2"</code> and enabled (interactively) if <code>plotType = "plotly"</code>.</p>
</td></tr>
<tr><td><code id="showInTriangle_+3A_collab">colLab</code>, <code id="showInTriangle_+3A_cexlab">cexLab</code>, <code id="showInTriangle_+3A_pos">pos</code>, <code id="showInTriangle_+3A_adj">adj</code></td>
<td>
<p>Parameters controlling the appearance of labels.
Ignored when <code>plotType = "plotly"</code>.</p>
</td></tr>
<tr><td><code id="showInTriangle_+3A_labsep">labSep</code></td>
<td>
<p>A string, by default &quot;-&quot;.</p>
</td></tr>
<tr><td><code id="showInTriangle_+3A_keep.par">keep.par</code></td>
<td>
<p>A logical. If TRUE (and <code>plotType = "base"</code>), the graphical
parameters are not reset after plotting, which may be useful for adding
additional annotation.</p>
</td></tr>
<tr><td><code id="showInTriangle_+3A_...">...</code></td>
<td>
<p>Plot arguments passed on to <code>ibdTriangle()</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>plotType = 'base'</code>, the function returns NULL; otherwise the plot
object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ibdTriangle">ibdTriangle()</a></code>, <code><a href="#topic+kappaIBD">kappaIBD()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>showInTriangle(c(3/8, 1/8), label = "3/4 siblings", pos = 1)

# With inset pedigree
x = doubleCousins(1, 0, half2 = TRUE)
showInTriangle(c(3/8, 1/8), label = "3/4 siblings", pos = 1,
               ped = x, pedArgs = list(hatched = 6:7))

# All pairs
k = kappaIBD(x)
showInTriangle(k, labels = TRUE, pos = 1:4, ped = x)

# With jitter and variable colors
showInTriangle(k, labels = TRUE, pos = 1:4, jitter = TRUE, col = 1:7, ped = x)

# Separate labels (requires ggplot2 + ggrepel)
# showInTriangle(k, plot = "ggplot2", col = 2:8, ped = x)

# Interactive plot (requires plotly)
# showInTriangle(k, plot = "plotly", col = 2:8, pch = 0)

</code></pre>

<hr>
<h2 id='twoLocusIBD'>Two-locus IBD coefficients</h2><span id='topic+twoLocusIBD'></span>

<h3>Description</h3>

<p>Computes the 3*3 matrix of two-locus IBD coefficients of a pair of non-inbred
pedigree members, for a given recombination rate.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>twoLocusIBD(
  x,
  ids,
  rho,
  coefs = NULL,
  detailed = FALSE,
  uniMethod = 1,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="twoLocusIBD_+3A_x">x</code></td>
<td>
<p>A pedigree in the form of a <code><a href="pedtools.html#topic+ped">pedtools::ped</a></code> object.</p>
</td></tr>
<tr><td><code id="twoLocusIBD_+3A_ids">ids</code></td>
<td>
<p>A character (or coercible to character) containing ID labels of
two pedigree members.</p>
</td></tr>
<tr><td><code id="twoLocusIBD_+3A_rho">rho</code></td>
<td>
<p>A number in the interval <code class="reqn">[0, 0.5]</code>; the recombination rate
between the two loci.</p>
</td></tr>
<tr><td><code id="twoLocusIBD_+3A_coefs">coefs</code></td>
<td>
<p>A character indicating which coefficient(s) to compute. A subset
of <code>c('k00', 'k01', 'k02', 'k10', 'k11', 'k12', 'k20', 'k21', 'k22')</code>. By
default, all coefficients are computed.</p>
</td></tr>
<tr><td><code id="twoLocusIBD_+3A_detailed">detailed</code></td>
<td>
<p>A logical, indicating whether the condensed (default) or
detailed coefficients should be returned.</p>
</td></tr>
<tr><td><code id="twoLocusIBD_+3A_unimethod">uniMethod</code></td>
<td>
<p>Either 1 or 2 (for testing purposes)</p>
</td></tr>
<tr><td><code id="twoLocusIBD_+3A_verbose">verbose</code></td>
<td>
<p>A logical.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Let A, B be two pedigree members, and L1, L2 two loci with a given
recombination rate <code class="reqn">\rho</code>. The two-locus IBD coefficients
<code class="reqn">\kappa_{i,j}(\rho)</code>, for <code class="reqn">0 \le i,j \le 2</code> are
defined as the probability that A and B have <code>i</code> alleles IBD at L1 and <code>j</code>
alleles IBD at L2 simultaneously. Note that IBD alleles at the two loci are
not required to be <em>in cis</em> (or <em>in trans</em> for that matter).
</p>
<p>The method of computation depends on the (single-locus) IBD coefficient
<code class="reqn">\kappa_2</code>. If this is zero (e.g. if A is a direct ancestor of B, or vice
versa) the two-locus IBD coefficients are easily computable from the
two-locus kinship coefficients, as implemented in <code><a href="#topic+twoLocusKinship">twoLocusKinship()</a></code>. In the
general case, the computation is more involved, requiring <em>generalised
two-locus kinship</em> coefficients. This is implemented in the function
<code>twoLocusGeneralisedKinship()</code>, which is not exported yet.
</p>


<h3>Value</h3>

<p>By default, a symmetric 3*3 matrix containing the two-locus IBD
coefficients <code class="reqn">\kappa_{i,j}</code>.
</p>
<p>If either <code>coefs</code> is explicitly given (i.e., not NULL), or <code>detailed = TRUE</code>, the computed coefficients are returned as a named vector.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+twoLocusKinship">twoLocusKinship()</a></code>, <code><a href="#topic+twoLocusIdentity">twoLocusIdentity()</a></code>, <code><a href="#topic+twoLocusPlot">twoLocusPlot()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Plot title used in several examples below
main = expression(paste("Two-locus IBD:  ", kappa[`1,1`]))

###################################################################
# Example 1: A classic example of three relationships with the same
# one-locus IBD coefficients, but different two-locus coefficients.
# As a consequence, these relationships cannot be separated using
# unlinked markers, but are (theoretically) separable with linked
# markers.
###################################################################
peds = list(
    GrandParent = list(ped = linearPed(2),   ids = c(1, 5)),
    HalfSib     = list(ped = halfSibPed(),   ids = c(4, 5)),
    Uncle       = list(ped = avuncularPed(), ids = c(3, 6)))

twoLocusPlot(peds, coeff = "k11", main = main, lty = 1:3, col = 1)


############################################################
# Example 2: Inspired by Fig. 3 in Thompson (1988),
# and its erratum: https://doi.org/10.1093/imammb/6.1.1.
#
# These relationships are also analysed in ?twoLocusKinship,
# where we show that they have identical two-locus kinship
# coefficients. Here we demonstrate that they have different
# two-locus IBD coefficients.
############################################################

peds = list(
  GreatGrand = list(ped = linearPed(3),              ids = c(1, 7)),
  HalfUncle  = list(ped = avuncularPed(half = TRUE), ids = c(4, 7))
)

twoLocusPlot(peds, coeff = "k11", main = main, lty = 1:2, col = 1)


########################################################################
# Example 3: Fig. 15 of Vigeland (2021).
# Two-locus IBD of two half sisters whose mother have inbreeding
# coefficient 1/4. We compare two different realisations of this:
#   PO: the mother is the child of parent-offspring
#  SIB: the mother is the child of full siblings
#
# The fact that these relationships have different two-locus coefficients
# exemplifies that a single-locus inbreeding coefficient cannot replace
# the genealogy in analyses of linked loci.
########################################################################

po = addChildren(nuclearPed(1, sex = 2), 1, 3, nch = 1, sex = 2)
po = addDaughter(addDaughter(po, 4), 4)

sib = addChildren(nuclearPed(2, sex = 1:2), 3, 4, nch = 1)
sib = addDaughter(addDaughter(sib, 5), 5)

# plotPedList(list(po, sib), new = TRUE, title = c("PO", "SIB"))

# List of pedigrees and ID pairs
peds = list(PO =  list(ped = po,  ids = leaves(po)),
            SIB = list(ped = sib, ids = leaves(sib)))

twoLocusPlot(peds, coeff = "k11", main = main, lty = 1:2, col = 1)


### Check against exact formulas
rho = seq(0, 0.5, length = 11)  # recombination values

kvals = sapply(peds, function(x)
  sapply(rho, function(r) twoLocusIBD(x$ped, x$ids, r, coefs = "k11")))

k11.po = 1/8*(-4*rho^5 + 12*rho^4 - 16*rho^3 + 16*rho^2 - 9*rho + 5)
stopifnot(all.equal(kvals[, "PO"], k11.po, check.names = FALSE))

k11.s = 1/16*(8*rho^6 - 32*rho^5 + 58*rho^4 - 58*rho^3 + 43*rho^2 - 20*rho + 10)
stopifnot(all.equal(kvals[, "SIB"], k11.s, check.names = FALSE))


################################################
# Example 4:
# The complete two-locus IBD matrix of full sibs
################################################

x = nuclearPed(2)
k2_mat = twoLocusIBD(x, ids = 3:4, rho = 0.25)
k2_mat

### Compare with exact formulas
IBDSibs = function(rho) {
  R = rho^2 + (1-rho)^2
  nms = c("ibd0", "ibd1", "ibd2")
  m = matrix(0, nrow = 3, ncol = 3, dimnames = list(nms, nms))
  m[1,1] = m[3,3] = 0.25 *R^2
  m[2,1] = m[1,2] = 0.5 * R * (1-R)
  m[3,1] = m[1,3] = 0.25 * (1-R)^2
  m[2,2] = 0.5 * (1 - 2 * R * (1-R))
  m[3,2] = m[2,3] = 0.5 * R * (1-R)
  m
}

stopifnot(all.equal(k2_mat, IBDSibs(0.25)))


#####################################################
# Example 5: Two-locus IBD of quad half first cousins
#
# We use this to exemplify two simple properties of
# the two-locus IBD matrix.
#####################################################

x = quadHalfFirstCousins()
ids = leaves(x)

# First compute the one-locus IBD coefficients (= c(17, 14, 1)/32)
k1 = kappaIBD(x, ids)

### Case 1: Complete linkage (`rho = 0`).
# In this case the two-locus IBD matrix has `k1` on the diagonal,
# and 0's everywhere else.
k2_mat_0 = twoLocusIBD(x, ids = ids, rho = 0)

stopifnot(all.equal(k2_mat_0, diag(k1), check.attributes = FALSE))

#' ### Case 2: Unlinked loci (`rho = 0.5`).
# In this case the two-locus IBD matrix is the outer product of
# `k1` with itself.
k2_mat_0.5 = twoLocusIBD(x, ids = ids, rho = 0.5)
stopifnot(all.equal(k2_mat_0.5, k1 %o% k1, check.attributes = FALSE))


########################################################
# Example 6: By Donnelly (1983) these relationships are
# genetically indistinguishable
########################################################

x1 = halfCousinPed(1)
x2 = halfCousinPed(0, removal = 2)
stopifnot(identical(
  twoLocusIBD(x1, ids = leaves(x1), rho = 0.25),
  twoLocusIBD(x2, ids = leaves(x2), rho = 0.25)))


###########################################################
# Example 7: Detailed coefficients of double first cousins.
# Compare with exact formulas by Denniston (1975).
###########################################################

## Not run: 
x = doubleFirstCousins()
ids = leaves(x)
rho = 0.25

kapDetailed = twoLocusIBD(x, ids, rho, detailed = TRUE)

# Example 1 of Denniston (1975)
denn = function(rho) {
  F = (1-rho)^2 * (rho^2 + (1-rho)^2)/4 + rho^2/8
  U = 1 + 2*F
  V = 1 - 4*F

  # Note that some of Denniston's definitions differ slightly;
  # some coefficients must be multiplied with 2
  c(k00 = U^2/4,
    k01 = U*V/8  *2,
    k02 = V^2/16,
    k10 = U*V/8  *2,
    k11.cc = F*U/2  *2,
    k11.ct = 0,
    k11.tc = 0,
    k11.tt = V^2/16  *2,
    k12.h = F*V/4  *2,
    k12.r = 0,
    k20 = V^2/16,
    k21.h = F*V/4  *2,
    k21.r = 0,
    k22.h = F^2,
    k22.r = 0)
}

stopifnot(all.equal(kapDetailed, denn(rho)))

## End(Not run)

</code></pre>

<hr>
<h2 id='twoLocusIdentity'>Two-locus identity coefficients</h2><span id='topic+twoLocusIdentity'></span>

<h3>Description</h3>

<p>Computes the 9*9 matrix of two-locus condensed identity coefficients of a
pair of pedigree members, for a given recombination rate.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>twoLocusIdentity(x, ids, rho, coefs = NULL, detailed = FALSE, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="twoLocusIdentity_+3A_x">x</code></td>
<td>
<p>A pedigree in the form of a <code><a href="pedtools.html#topic+ped">pedtools::ped</a></code> object.</p>
</td></tr>
<tr><td><code id="twoLocusIdentity_+3A_ids">ids</code></td>
<td>
<p>A character (or coercible to character) containing ID labels of
two pedigree members.</p>
</td></tr>
<tr><td><code id="twoLocusIdentity_+3A_rho">rho</code></td>
<td>
<p>A number in the interval <code class="reqn">[0, 0.5]</code>; the recombination rate
between the two loci.</p>
</td></tr>
<tr><td><code id="twoLocusIdentity_+3A_coefs">coefs</code></td>
<td>
<p>A character indicating which coefficient(s) to compute. A subset
of <code>c('D00', 'D01', ..., 'D99')</code>. By default, all coefficients are
computed.</p>
</td></tr>
<tr><td><code id="twoLocusIdentity_+3A_detailed">detailed</code></td>
<td>
<p>A logical, indicating whether the condensed (default) or
detailed coefficients should be returned.</p>
</td></tr>
<tr><td><code id="twoLocusIdentity_+3A_verbose">verbose</code></td>
<td>
<p>A logical.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Let A, B be two pedigree members, and L1, L2 two loci with a given
recombination rate <code class="reqn">\rho</code>. The two-locus identity coefficient
<code class="reqn">\Delta_{i,j}(\rho)</code>, for <code class="reqn">1 \le i,j \le 9</code> is
defined as the probability that the identity state of the alleles of A and B
are <code class="reqn">\Sigma_i</code> at L1 and <code class="reqn">\Sigma_j</code> at L2 simultaneously. (The
ordering of the 9 states follows Jacquard (1974).)
</p>
<p>For details about the algorithm, see Vigeland (2022).
</p>


<h3>Value</h3>

<p>By default, a symmetric 9*9 matrix containing the two-locus condensed
identity coefficients <code class="reqn">\Delta_{i,j}</code>.
</p>
<p>If either <code>coefs</code> is explicitly given (i.e., not NULL), or <code>detailed = TRUE</code>, the computed coefficients are returned as a named vector.
</p>


<h3>References</h3>


<ul>
<li><p> Jacquard (1974). The Genetic Structure of Populations. Springer.
</p>
</li>
<li><p> Vigeland (2022) <em>Two-locus identity coefficients in pedigrees</em> (In progress)
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+twoLocusIBD">twoLocusIBD()</a></code>, <code><a href="#topic+identityCoefs">identityCoefs()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### Full sibs ###
x = nuclearPed(2)
kapp = twoLocusIBD(x, ids = 3:4, rho = 0.25)
jacq = twoLocusIdentity(x, ids = 3:4, rho = 0.25)

stopifnot(all.equal(jacq[9:7,9:7], kapp, check.attributes = FALSE))

### Parent-child ###
x = nuclearPed(1)
jacq = twoLocusIdentity(x, ids = c(1,3), rho = 0.25)

stopifnot(jacq[8,8] == 1)

### Full sib mating ###
x = fullSibMating(1)
j = condensedIdentity(x, ids = 5:6)
j2 = twoLocusIdentity(x, ids = 5:6, rho = 0.25)

stopifnot(identical(unname(rowSums(j2)), j))


</code></pre>

<hr>
<h2 id='twoLocusInbreeding'>Two-locus inbreeding</h2><span id='topic+twoLocusInbreeding'></span>

<h3>Description</h3>

<p>Computes the two-locus inbreeding coefficient of a pedigree member, for a
given recombination rate.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>twoLocusInbreeding(x, id, rho, verbose = FALSE, debug = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="twoLocusInbreeding_+3A_x">x</code></td>
<td>
<p>A pedigree in the form of a <code><a href="pedtools.html#topic+ped">pedtools::ped</a></code> object.</p>
</td></tr>
<tr><td><code id="twoLocusInbreeding_+3A_id">id</code></td>
<td>
<p>The ID label of a pedigree member.</p>
</td></tr>
<tr><td><code id="twoLocusInbreeding_+3A_rho">rho</code></td>
<td>
<p>A numeric vector of recombination rates; all entries must be in
the interval <code class="reqn">[0, 0.5]</code>.</p>
</td></tr>
<tr><td><code id="twoLocusInbreeding_+3A_verbose">verbose</code></td>
<td>
<p>A logical.</p>
</td></tr>
<tr><td><code id="twoLocusInbreeding_+3A_debug">debug</code></td>
<td>
<p>A logical. If TRUE, detailed messages are printed during the
recursion process.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Let A be a pedigree member, and L1, L2 two autosomal loci with recombination
rate <code class="reqn">\rho</code>. The two-locus inbreeding coefficient <code class="reqn">f_{11}(\rho)</code> is
defined as the probability that A is autozygous at both L1 and L2
simultaneously.
</p>
<p>As in the one-locus case, the two-locus inbreeding coefficient of A equals
the two-locus kinship coefficient of the parents.
</p>


<h3>References</h3>

<p>Weir &amp; Cockerham (1969). <em>Pedigree mating with two linked loci</em>.
Genetics, 61:923-940.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+twoLocusKinship">twoLocusKinship()</a></code>, <code><a href="#topic+twoLocusIBD">twoLocusIBD()</a></code>, <code><a href="#topic+twoLocusIdentity">twoLocusIdentity()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
###################################################
# Reproducing an example of Weir &amp; Cockerham (1969)
###################################################

# Pedigree
x = nuclearPed(2, sex = 1:2) |&gt;
  addDaughter(3:4) |&gt;
  addSon(c(3,5)) |&gt;
  addDaughter(5:6) |&gt;
  relabel(new = strsplit("GHDECBA","")[[1]])

plot(x)

# The two-locus inbreeding of A
twoLocusPlot(list(ped = x, ids = "A"), coeff = "inb")

# W&amp;C formula (expressed by linkage parameter a = 1-2*rho)
rho = seq(0, 0.5, length = 11)
a = 1 - 2*rho
WC = (128 + 10*a + 36*a^2 + 47*a^3 + 20*a^4 + 10*a^5 + 4*a^6 + a^7)/512

points(rho, WC, col = 2)

</code></pre>

<hr>
<h2 id='twoLocusKinship'>Two-locus kinship coefficients</h2><span id='topic+twoLocusKinship'></span>

<h3>Description</h3>

<p>Computes the two-locus kinship coefficient of a pair of pedigree members, at
a given recombination rate.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>twoLocusKinship(
  x,
  ids,
  rho,
  recombinants = NULL,
  verbose = FALSE,
  debug = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="twoLocusKinship_+3A_x">x</code></td>
<td>
<p>A pedigree in the form of a <code><a href="pedtools.html#topic+ped">pedtools::ped</a></code> object.</p>
</td></tr>
<tr><td><code id="twoLocusKinship_+3A_ids">ids</code></td>
<td>
<p>A character (or coercible to character) containing ID labels of
two or more pedigree members.</p>
</td></tr>
<tr><td><code id="twoLocusKinship_+3A_rho">rho</code></td>
<td>
<p>A numeric vector of recombination rates; all entries must be in
the interval <code class="reqn">[0, 0.5]</code>.</p>
</td></tr>
<tr><td><code id="twoLocusKinship_+3A_recombinants">recombinants</code></td>
<td>
<p>A logical of length 2, applicable only when <code>ids</code> has
length 2. When given, it indicates whether each of the two gametes is a
recombinant or non-recombinant. This parameter is mainly used by
<code><a href="#topic+twoLocusIBD">twoLocusIBD()</a></code>.</p>
</td></tr>
<tr><td><code id="twoLocusKinship_+3A_verbose">verbose</code></td>
<td>
<p>A logical.</p>
</td></tr>
<tr><td><code id="twoLocusKinship_+3A_debug">debug</code></td>
<td>
<p>A logical. If TRUE, detailed messages are printed during the
recursion process.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Let A, B be two pedigree members, and L1, L2 two loci with a given
recombination rate rho. The two-locus kinship coefficient
<code class="reqn">\phi_{AB}(rho)</code> is defined as the probability that random gametes
segregating from A and B has IBD alleles at both L1 and L2 simultaneously.
</p>
<p>The implementation is based on the recursive algorithm described by Thompson
(1988).
</p>


<h3>References</h3>

<p>E. A. Thompson (1988). <em>Two-locus and Three-locus Gene Identity
by Descent in Pedigrees</em>. IMA Journal of Mathematics Applied in Medicine &amp;
Biology, vol. 5.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>######################
# Example 1: Full sibs
######################
x = nuclearPed(2)

k_0 = twoLocusKinship(x, ids = 3:4, rho = 0)
k_0.5 = twoLocusKinship(x, ids = 3:4, rho = 0.5)

stopifnot(k_0 == 1/4, k_0.5 == 1/16)


##################################################
# Example 2: Reproducing Fig. 3 in Thompson (1988)
# Note that in the article, curve (a) is wrong.
# See Erratum: https://doi.org/10.1093/imammb/6.1.1
##################################################

# Pedigrees (a) - (d)
ped.a = linearPed(3)
ped.b = avuncularPed(half = TRUE)
ped.c = cousinPed(1)
ped.d = doubleCousins(1, 1, half1 = TRUE, half2 = TRUE)

peds = list(
  a = list(ped = ped.a, ids = c(1,7)),
  b = list(ped = ped.b, ids = leaves(ped.b)),
  c = list(ped = ped.c, ids = leaves(ped.c)),
  d = list(ped = ped.d, ids = leaves(ped.d))
)

twoLocusPlot(peds, coeff = "kinship", lty = 1:4)

</code></pre>

<hr>
<h2 id='twoLocusPlot'>Two-locus coefficient plot</h2><span id='topic+twoLocusPlot'></span>

<h3>Description</h3>

<p>Plot two-locus kinship or IBD coefficients as function of the recombination
rate.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>twoLocusPlot(
  peds,
  coeff = "k11",
  rseq = seq(0, 0.5, length = 11),
  xlab = "Recombination rate",
  ylab = NA,
  col = seq_along(peds),
  lty = 1,
  lwd = 1,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="twoLocusPlot_+3A_peds">peds</code></td>
<td>
<p>A list of lists. See details.</p>
</td></tr>
<tr><td><code id="twoLocusPlot_+3A_coeff">coeff</code></td>
<td>
<p>A string identifying which coefficient to compute. See Details
for legal values.</p>
</td></tr>
<tr><td><code id="twoLocusPlot_+3A_rseq">rseq</code></td>
<td>
<p>A numeric vector of recombination rates. By default <code>seq(from = 0, by = 0.5, length = 11)</code>.</p>
</td></tr>
<tr><td><code id="twoLocusPlot_+3A_xlab">xlab</code>, <code id="twoLocusPlot_+3A_ylab">ylab</code></td>
<td>
<p>Axis labels.</p>
</td></tr>
<tr><td><code id="twoLocusPlot_+3A_col">col</code>, <code id="twoLocusPlot_+3A_lty">lty</code>, <code id="twoLocusPlot_+3A_lwd">lwd</code></td>
<td>
<p>Plotting parameters.</p>
</td></tr>
<tr><td><code id="twoLocusPlot_+3A_...">...</code></td>
<td>
<p>Further parameters passed on to <code><a href="graphics.html#topic+matplot">matplot()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Each entry of <code>peds</code> must be a list with the following (named) entries:
</p>

<ul>
<li><p> ped: A ped object
</p>
</li>
<li><p> ids: A pair of labels identifying two members of <code>ped</code>
</p>
</li></ul>

<p>The <code>coeff</code> parameter must be either a character naming the coefficient to
compute, or a function. If a character, it must be one of the following
names: &quot;inb&quot;, &quot;kinship&quot;, &quot;phi&quot;, &quot;phi11&quot;, &quot;k00&quot;, &quot;k01&quot;, &quot;k02&quot;, &quot;k10&quot;, &quot;k11&quot;, &quot;k12&quot;,
&quot;k20&quot;, &quot;k21&quot; or &quot;k22&quot;.
</p>
<p>If <code>coeff</code> is a function, it must take three arguments named <code>ped</code>, <code>ids</code> and
<code>rho</code>, and produce a single number for each set of input data. See Examples.
</p>
<p>The first three are synonymous and indicate the two-locus kinship
coefficient. The remaining choices are two-locus IBD coefficients. (See
<code><a href="#topic+twoLocusIBD">twoLocusIBD()</a></code>.)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
###############################
# Classic example of three relationships with equal one-locus coeffs
peds = list(
    GrandParent = list(ped = linearPed(2),   ids = c(1, 5)),
    HalfSib     = list(ped = halfSibPed(),   ids = c(4, 5)),
    Uncle       = list(ped = avuncularPed(), ids = c(3, 6)))

twoLocusPlot(peds, coeff = "kinship")
twoLocusPlot(peds, coeff = "k11")

###############################

peds = list(
    PO = list(ped = nuclearPed(1), ids = c(1,3)),
    S  = list(ped = nuclearPed(2), ids = c(3,4)))

twoLocusPlot(peds, coeff = "kinship")
twoLocusPlot(peds, coeff = "k11")

###############################

ped1 = addChildren(halfSibPed(sex2 = 2), 4, 5, nch = 2)
ped2 = addChildren(linearPed(2, sex = 1:2), 1, 5, nch = 2)
ped3 = addChildren(avuncularPed("uncle", "niece"), 3, 6, nch = 2)

peds = list(
   `H-sibs` = list(ped = ped1, ids = leaves(ped1)),
   `G-sibs` = list(ped = ped2, ids = leaves(ped2)),
   `U-sibs` = list(ped = ped3, ids = leaves(ped3))
)
# plotPedList(peds)
twoLocusPlot(peds, coeff = "kinship")

################################

### Reproducing Fig 2 of Bishop &amp; Williamson (1990)
### This example illustrates `coeff` as a function.

# The coefficient d11(rho) is the conditional probability of IBD = 1
# in the first locus, given IBD = 1 in the second.

G = linearPed(2)
H = halfSibPed()
U = avuncularPed()
FC = cousinPed(1)
FC1R = cousinPed(1, removal = 1)
SC = cousinPed(2)

peds = list(
    GrandParent = list(ped = G,    ids = c(1, 5)),
    HalfSib     = list(ped = H,    ids = leaves(H)),
    Uncle       = list(ped = U,    ids = leaves(U)),
    FirstCous   = list(ped = FC,   ids = leaves(FC)),
    FirstCous1R = list(ped = FC1R, ids = leaves(FC1R)),
    SecondCous  = list(ped = SC,   ids = leaves(SC)))


d11 = function(ped, ids, rho) {
  twoLocusIBD(ped, ids, rho, coefs = "k11")/kappaIBD(ped, ids)[2]
}

twoLocusPlot(peds, coeff = d11)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
