<!DOCTYPE html><html><head><title>Help for package GLMMadaptive</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {GLMMadaptive}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#GLMMadaptive'>
<p>Generalized Linear Mixed Models using Adaptive Gaussian Quadrature</p></a></li>
<li><a href='#Continuation+20Ratio+20Set-Up'>
<p>Functions to Set-Up Data for a Continuation Ratio Mixed Model</p></a></li>
<li><a href='#effectPlotData'>
<p>Predicted Values for Effects Plots</p></a></li>
<li><a href='#Extra+20Family+20Objects'>
<p>Family functions for Student's-t, Beta, Zero-Inflated and Hurdle Poisson and Negative Binomial,</p>
Hurdle Log-Normal, Hurdle Beta, Gamma, and Censored Normal Mixed Models</a></li>
<li><a href='#marginal_coefs'>
<p>Marginal Coefficients from Generalized Linear Mixed Models</p></a></li>
<li><a href='#mixed_model'>
<p>Generalized Linear Mixed Effects Models</p></a></li>
<li><a href='#MixMod+20Methods'>
<p>Various Methods for Standard Generics</p></a></li>
<li><a href='#negative.binomial'>
<p>Family function for Negative Binomial Mixed Models</p></a></li>
<li><a href='#scoring_rules'>
<p>Proper Scoring Rules for Categorical Data</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Generalized Linear Mixed Models using Adaptive Gaussian
Quadrature</td>
</tr>
<tr>
<td>Version:</td>
<td>0.9-1</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-10-17</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Dimitris Rizopoulos &lt;d.rizopoulos@erasmusmc.nl&gt;</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/drizopoulos/GLMMadaptive/issues">https://github.com/drizopoulos/GLMMadaptive/issues</a></td>
</tr>
<tr>
<td>Description:</td>
<td>Fits generalized linear mixed models for a single grouping factor under
    maximum likelihood approximating the integrals over the random effects with an 
    adaptive Gaussian quadrature rule; Jose C. Pinheiro and Douglas M. Bates (1995) 
    &lt;<a href="https://doi.org/10.1080%2F10618600.1995.10474663">doi:10.1080/10618600.1995.10474663</a>&gt;.  </td>
</tr>
<tr>
<td>Imports:</td>
<td>MASS, nlme, parallel, matrixStats</td>
</tr>
<tr>
<td>Suggests:</td>
<td>lattice, knitr, rmarkdown, pkgdown, multcomp, emmeans,
estimability, effects, DHARMa, optimParallel</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://drizopoulos.github.io/GLMMadaptive/">https://drizopoulos.github.io/GLMMadaptive/</a>,
<a href="https://github.com/drizopoulos/GLMMadaptive">https://github.com/drizopoulos/GLMMadaptive</a></td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>6.1.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-10-17 07:55:44 UTC; drizo</td>
</tr>
<tr>
<td>Author:</td>
<td>Dimitris Rizopoulos
    <a href="https://orcid.org/0000-0001-9397-0900"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-10-17 08:40:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='GLMMadaptive'>
Generalized Linear Mixed Models using Adaptive Gaussian Quadrature
</h2><span id='topic+GLMMadaptive-package'></span><span id='topic+GLMMadaptive'></span>

<h3>Description</h3>

<p>This package fits generalized linear mixed models for a single grouping factor under 
maximum likelihood approximating the integrals over the random effects with an adaptive 
Gaussian quadrature rule.
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> GLMMadaptive</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 0.9-1</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2023-10-17</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL (&gt;=3)</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>This package fits mixed effects models for grouped / repeated measurements data for which
the integral over the random effects in the definition of the marginal likelihood cannot
be solved analytically. The package approximates these integrals using the adaptive 
Gauss-Hermite quadrature rule.
</p>
<p>Multiple random effects terms can be included for the grouping factor (e.g., random 
intercepts, random linear slopes, random quadratic slopes), but currently only a single
grouping factor is allowed.
</p>
<p>The package also offers several utility functions that can extract useful information from
fitted mixed effects models. The most important of those are included in the 
<b>See also</b> Section below.
</p>


<h3>Author(s)</h3>

<p>Dimitris Rizopoulos
</p>
<p>Maintainer: Dimitris Rizopoulos &lt;d.rizopoulos@erasmusmc.nl&gt;
</p>


<h3>References</h3>

<p>Fitzmaurice, G., Laird, N. and Ware J. (2011). <em>Applied Longitudinal Analysis</em>, 
2nd Ed. New York: John Wiley &amp; Sons. 
</p>
<p>Molenberghs, G. and Verbeke, G. (2005). <em>Models for Discrete Longitudinal Data</em>. 
New York: Springer-Verlag. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mixed_model">mixed_model</a></code>,
<code><a href="#topic+methods.MixMod">methods.MixMod</a></code>,
<code><a href="#topic+effectPlotData">effectPlotData</a></code>,
<code><a href="#topic+marginal_coefs">marginal_coefs</a></code>
</p>

<hr>
<h2 id='Continuation+20Ratio+20Set-Up'>
Functions to Set-Up Data for a Continuation Ratio Mixed Model
</h2><span id='topic+cr_setup'></span><span id='topic+cr_marg_probs'></span>

<h3>Description</h3>

<p>Data set-up and calculation of marginal probabilities from a continuation ratio model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cr_setup(y, direction = c("forward", "backward"))

cr_marg_probs(eta, direction = c("forward", "backward"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Continuation+2B20Ratio+2B20Set-Up_+3A_y">y</code></td>
<td>
<p>a numeric vector denoting the ordinal response variable.</p>
</td></tr>
<tr><td><code id="Continuation+2B20Ratio+2B20Set-Up_+3A_direction">direction</code></td>
<td>
<p>character string specifying the direction of the continuation ratio 
model; <code>"forward"</code> corresponds to a discrete hazard function.</p>
</td></tr>
<tr><td><code id="Continuation+2B20Ratio+2B20Set-Up_+3A_eta">eta</code></td>
<td>
<p>a numeric matrix of the linear predictor, with columns corresponding to the 
different levels of the ordinal response.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Function <code>cr_setup()</code> is based on the <code>cr.setup()</code> function from package 
<b>rms</b>.</p>


<h3>Author(s)</h3>

<p>Dimitris Rizopoulos <a href="mailto:d.rizopoulos@erasmusmc.nl">d.rizopoulos@erasmusmc.nl</a>
</p>
<p>Frank Harrell
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 300 # number of subjects
K &lt;- 8 # number of measurements per subject
t_max &lt;- 15 # maximum follow-up time

# we constuct a data frame with the design: 
# everyone has a baseline measurment, and then measurements at random follow-up times
DF &lt;- data.frame(id = rep(seq_len(n), each = K),
                 time = c(replicate(n, c(0, sort(runif(K - 1, 0, t_max))))),
                 sex = rep(gl(2, n/2, labels = c("male", "female")), each = K))

# design matrices for the fixed and random effects
X &lt;- model.matrix(~ sex * time, data = DF)[, -1]
Z &lt;- model.matrix(~ 1, data = DF)

thrs &lt;- c(-1.5, 0, 0.9) # thresholds for the different ordinal categories
betas &lt;- c(-0.25, 0.24, -0.05) # fixed effects coefficients
D11 &lt;- 0.48 # variance of random intercepts
D22 &lt;- 0.1 # variance of random slopes

# we simulate random effects
b &lt;- cbind(rnorm(n, sd = sqrt(D11)), rnorm(n, sd = sqrt(D22)))[, 1, drop = FALSE]
# linear predictor
eta_y &lt;- drop(X %*% betas + rowSums(Z * b[DF$id, , drop = FALSE]))
# linear predictor for each category
eta_y &lt;- outer(eta_y, thrs, "+")
# marginal probabilities per category
mprobs &lt;- cr_marg_probs(eta_y)
# we simulate ordinal longitudinal data
DF$y &lt;- unname(apply(mprobs, 1, sample, x = ncol(mprobs), size = 1, replace = TRUE))

# If you want to simulate from the backward formulation of the CR model, you need to
# change `eta_y &lt;- outer(eta_y, thrs, "+")` to `eta_y &lt;- outer(eta_y, rev(thrs), "+")`,
# and `mprobs &lt;- cr_marg_probs(eta_y)` to `mprobs &lt;- cr_marg_probs(eta_y, "backward")`

#################################################

# prepare the data
# If you want to fit the CR model under the backward formulation, you need to change
# `cr_vals &lt;- cr_setup(DF$y)` to `cr_vals &lt;- cr_setup(DF$y, "backward")`
cr_vals &lt;- cr_setup(DF$y)
cr_data &lt;- DF[cr_vals$subs, ]
cr_data$y_new &lt;- cr_vals$y
cr_data$cohort &lt;- cr_vals$cohort

# fit the model
fm &lt;- mixed_model(y_new ~ cohort + sex * time, random = ~ 1 | id, 
                  data = cr_data, family = binomial())

summary(fm)
</code></pre>

<hr>
<h2 id='effectPlotData'>
Predicted Values for Effects Plots
</h2><span id='topic+effectPlotData'></span><span id='topic+effectPlotData.MixMod'></span>

<h3>Description</h3>

<p>Creates predicted values and their corresponding confidence interval for constructing an
effects plot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
effectPlotData(object, newdata, level, ...)

## S3 method for class 'MixMod'
effectPlotData(object, newdata, 
   level = 0.95, marginal = FALSE, CR_cohort_varname = NULL,
   direction = NULL, K = 200, seed = 1, sandwich = FALSE, 
   ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="effectPlotData_+3A_object">object</code></td>
<td>
<p>an object inheriting from class <code>"MixMod"</code>.</p>
</td></tr>
<tr><td><code id="effectPlotData_+3A_newdata">newdata</code></td>
<td>
<p>a data frame base on which predictions will be calculated.</p>
</td></tr>
<tr><td><code id="effectPlotData_+3A_level">level</code></td>
<td>
<p>a numeric scalar denoting the level of the confidence interval.</p>
</td></tr>
<tr><td><code id="effectPlotData_+3A_marginal">marginal</code></td>
<td>
<p>logical; if <code>FALSE</code> predicted values are calculated for the &quot;mean&quot;
subject (i.e., the one with random effects values equal to 0). When <code>TRUE</code> 
marginal predicted values are calculated using function <code><a href="#topic+marginal_coefs">marginal_coefs</a></code>.</p>
</td></tr>
<tr><td><code id="effectPlotData_+3A_cr_cohort_varname">CR_cohort_varname</code></td>
<td>
<p>a character string denoting the name of the cohort variable when
a continuation ratio model is fitted.</p>
</td></tr>
<tr><td><code id="effectPlotData_+3A_direction">direction</code></td>
<td>
<p>the <code>direction</code> argument of <code><a href="#topic+cr_marg_probs">cr_marg_probs</a></code> needs to be
provided when <code>CR_cohort_varname</code> is not <code>NULL</code>. </p>
</td></tr>
<tr><td><code id="effectPlotData_+3A_k">K</code></td>
<td>
<p>numeric scalar denoting the number of Monte Carlo samples from the approximate
posterior of the parameters; applicable only for zero-inflated models.</p>
</td></tr>
<tr><td><code id="effectPlotData_+3A_seed">seed</code></td>
<td>
<p>numerical scalar giving the seed to be used in the Monte Carlo scheme.</p>
</td></tr>
<tr><td><code id="effectPlotData_+3A_sandwich">sandwich</code></td>
<td>
<p>logical; if <code>TRUE</code> robust/sandwich standard errors are used in the 
calculations.</p>
</td></tr>
<tr><td><code id="effectPlotData_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code><a href="#topic+marginal_coefs">marginal_coefs</a></code>, e.g., <code>cores</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The confidence interval is calculated based on a normal approximation.</p>


<h3>Value</h3>

<p>The data frame <code>newdata</code> with extra columns <code>pred</code>, <code>low</code> and <code>upp</code>.
</p>


<h3>Author(s)</h3>

<p>Dimitris Rizopoulos <a href="mailto:d.rizopoulos@erasmusmc.nl">d.rizopoulos@erasmusmc.nl</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mixed_model">mixed_model</a></code>,
<code><a href="#topic+marginal_coefs">marginal_coefs</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# simulate some data
set.seed(123L)
n &lt;- 500
K &lt;- 15
t.max &lt;- 25

betas &lt;- c(-2.13, -0.25, 0.24, -0.05)
D &lt;- matrix(0, 2, 2)
D[1:2, 1:2] &lt;- c(0.48, -0.08, -0.08, 0.18)

times &lt;- c(replicate(n, c(0, sort(runif(K-1, 0, t.max)))))
group &lt;- sample(rep(0:1, each = n/2))
DF &lt;- data.frame(year = times, group = factor(rep(group, each = K)))
X &lt;- model.matrix(~ group * year, data = DF)
Z &lt;- model.matrix(~ year, data = DF)

b &lt;- cbind(rnorm(n, sd = sqrt(D[1, 1])), rnorm(n, sd = sqrt(D[2, 2])))
id &lt;- rep(1:n, each = K)
eta.y &lt;- as.vector(X %*% betas + rowSums(Z * b[id, ]))
DF$y &lt;- rbinom(n * K, 1, plogis(eta.y))
DF$id &lt;- factor(id)

################################################

# Fit a model
fm1 &lt;- mixed_model(fixed = y ~ year * group, random = ~ year | id, data = DF,
                   family = binomial())

# An effects plot for the mean subject (i.e., with random effects equal to 0)
nDF &lt;- with(DF, expand.grid(year = seq(min(year), max(year), length.out = 15),
    group = levels(group)))
    
plot_data &lt;- effectPlotData(fm1, nDF)

require("lattice")
xyplot(pred + low + upp ~ year | group, data = plot_data,
       type = "l", lty = c(1, 2, 2), col = c(2, 1, 1), lwd = 2,
       xlab = "Follow-up time", ylab = "log odds")

expit &lt;- function (x) exp(x) / (1 + exp(x))
xyplot(expit(pred) + expit(low) + expit(upp) ~ year | group, data = plot_data,
       type = "l", lty = c(1, 2, 2), col = c(2, 1, 1), lwd = 2,
       xlab = "Follow-up time", ylab = "Probabilities")

# we put the two groups in the same panel
my.panel.bands &lt;- function(x, y, upper, lower, fill, col, subscripts, ..., font, 
                           fontface) {
    upper &lt;- upper[subscripts]
    lower &lt;- lower[subscripts]
    panel.polygon(c(x, rev(x)), c(upper, rev(lower)), col = fill, border = FALSE, ...)
}

xyplot(expit(pred) ~ year, group = group, data = plot_data, upper = expit(plot_data$upp),
       low = expit(plot_data$low), type = "l", col = c("blue", "red"), 
       fill = c("#0000FF80", "#FF000080"),
       panel = function (x, y, ...) {
           panel.superpose(x, y, panel.groups = my.panel.bands, ...)
           panel.xyplot(x, y, lwd = 2,  ...)
}, xlab = "Follow-up time", ylab = "Probabilities")

# An effects plots for the marginal probabilities
plot_data_m &lt;- effectPlotData(fm1, nDF, marginal = TRUE, cores = 1L)

expit &lt;- function (x) exp(x) / (1 + exp(x))
xyplot(expit(pred) + expit(low) + expit(upp) ~ year | group, data = plot_data_m,
       type = "l", lty = c(1, 2, 2), col = c(2, 1, 1), lwd = 2,
       xlab = "Follow-up time", ylab = "Probabilities")

</code></pre>

<hr>
<h2 id='Extra+20Family+20Objects'>
Family functions for Student's-t, Beta, Zero-Inflated and Hurdle Poisson and Negative Binomial,
Hurdle Log-Normal, Hurdle Beta, Gamma, and Censored Normal Mixed Models</h2><span id='topic+students.t'></span><span id='topic+beta.fam'></span><span id='topic+beta.binomial'></span><span id='topic+zi.poisson'></span><span id='topic+zi.binomial'></span><span id='topic+zi.negative.binomial'></span><span id='topic+hurdle.poisson'></span><span id='topic+hurdle.negative.binomial'></span><span id='topic+hurdle.lognormal'></span><span id='topic+hurdle.beta.fam'></span><span id='topic+unit.lindley'></span><span id='topic+Gamma.fam'></span><span id='topic+censored.normal'></span>

<h3>Description</h3>

<p>Specifies the information required to fit a Beta, zero-inflated and hurdle Poisson, 
zero-inflated and hurdle Negative Binomial, a hurdle normal and a hurdle Beta 
mixed-effects model, using 
<code>mixed_model()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>students.t(df = stop("'df' must be specified"), link = "identity")
beta.fam()
zi.poisson()
zi.binomial()
zi.negative.binomial()
hurdle.poisson()
hurdle.negative.binomial()
hurdle.lognormal()
hurdle.beta.fam()
unit.lindley()
beta.binomial(link = "logit")
Gamma.fam()
censored.normal()
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Extra+2B20Family+2B20Objects_+3A_link">link</code></td>
<td>
<p>name of the link function.</p>
</td></tr>
<tr><td><code id="Extra+2B20Family+2B20Objects_+3A_df">df</code></td>
<td>
<p>the degrees of freedom of the Student's t distribution.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Currently only the log-link is implemented for the Poisson, negative binomial 
and Gamma models, the logit link for the beta and hurdle beta models and the identity link for the 
log-normal model.</p>


<h3>Examples</h3>

<pre><code class='language-R'># simulate some data from a negative binomial model
set.seed(102)
dd &lt;- expand.grid(f1 = factor(1:3), f2 = LETTERS[1:2], g = 1:30, rep = 1:15,
                  KEEP.OUT.ATTRS = FALSE)
mu &lt;- 5*(-4 + with(dd, as.integer(f1) + 4 * as.numeric(f2)))
dd$y &lt;- rnbinom(nrow(dd), mu = mu, size = 0.5)

# Fit a zero-inflated Poisson model, with only fixed effects in the 
# zero-inflated part
fm1 &lt;- mixed_model(fixed = y ~ f1 * f2, random = ~ 1 | g, data = dd, 
                  family = zi.poisson(), zi_fixed = ~ 1)

summary(fm1)


# We extend the previous model allowing also for a random intercept in the
# zero-inflated part
fm2 &lt;- mixed_model(fixed = y ~ f1 * f2, random = ~ 1 | g, data = dd, 
                  family = zi.poisson(), zi_fixed = ~ 1, zi_random = ~ 1 | g)

# We do a likelihood ratio test between the two models
anova(fm1, fm2)

#############################################################################
#############################################################################

# The same as above but with a negative binomial model
gm1 &lt;- mixed_model(fixed = y ~ f1 * f2, random = ~ 1 | g, data = dd, 
                  family = zi.negative.binomial(), zi_fixed = ~ 1)

summary(gm1)

# We do a likelihood ratio test between the Poisson and negative binomial models
anova(fm1, gm1)

</code></pre>

<hr>
<h2 id='marginal_coefs'>
Marginal Coefficients from Generalized Linear Mixed Models
</h2><span id='topic+marginal_coefs'></span><span id='topic+marginal_coefs.MixMod'></span>

<h3>Description</h3>

<p>Calculates marginal coefficients and their standard errors from fitted generalized linear 
mixed models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>marginal_coefs(object, ...)

## S3 method for class 'MixMod'
marginal_coefs(object, std_errors = FALSE, 
   link_fun = NULL, M = 3000, K = 100, seed = 1, 
   cores = max(parallel::detectCores() - 1, 1), 
   sandwich = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="marginal_coefs_+3A_object">object</code></td>
<td>
<p>an object inheriting from class <code>"MixMod"</code>.</p>
</td></tr>
<tr><td><code id="marginal_coefs_+3A_std_errors">std_errors</code></td>
<td>
<p>logical indicating whether standard errors are to be computed.</p>
</td></tr>
<tr><td><code id="marginal_coefs_+3A_link_fun">link_fun</code></td>
<td>
<p>a function transforming the mean of the repeated measurements outcome to the
linear predictor scale. Typically, this derived from the <code>family</code> argument of
<code><a href="#topic+mixed_model">mixed_model</a></code>.</p>
</td></tr>
<tr><td><code id="marginal_coefs_+3A_m">M</code></td>
<td>
<p>numeric scalar denoting the number of Monte Carlo samples.</p>
</td></tr>
<tr><td><code id="marginal_coefs_+3A_k">K</code></td>
<td>
<p>numeric scalar denoting the number of samples from the sampling distribution of
the maximum likelihood estimates.</p>
</td></tr>
<tr><td><code id="marginal_coefs_+3A_seed">seed</code></td>
<td>
<p>integer denoting the seed for the random number generation.</p>
</td></tr>
<tr><td><code id="marginal_coefs_+3A_cores">cores</code></td>
<td>
<p>integer giving the number of cores to use; applicable only when 
<code>std_errors = TRUE</code>.</p>
</td></tr>
<tr><td><code id="marginal_coefs_+3A_sandwich">sandwich</code></td>
<td>
<p>logical; if <code>TRUE</code> robust/sandwich standard errors are used in the 
calculations.</p>
</td></tr>
<tr><td><code id="marginal_coefs_+3A_...">...</code></td>
<td>
<p>extra arguments; currently none is used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It uses the approach of Hedeker et al. (2017) to calculate marginal coefficients from
mixed models with nonlinear link functions. The marginal probabilities are calculated 
using Monte Carlo integration over the random effects with <code>M</code> samples, by sampling 
from the estimated prior distribution, i.e., a multivariate normal distribution with mean 
0 and covariance matrix <code class="reqn">\hat{D}</code>, where <code class="reqn">\hat{D}</code> denotes the estimated 
covariance matrix of the random effects.
</p>
<p>To calculate the standard errors, the Monte Carlo integration procedure is repeated 
<code>K</code> times, where each time instead of the maximum likelihood estimates of the fixed
effects and the covariance matrix of the random effects, a realization is used from the
sampling distribution of the maximum likelihood estimates. To speed-up this process, 
package <b>parallel</b> is used.
</p>


<h3>Value</h3>

<p>A list of class <code>"m_coefs"</code> with components <code>betas</code> the marginal coefficients, 
and when <code>std_errors = TRUE</code>, the extra components <code>var_betas</code> the estimated 
covariance matrix of the marginal coefficients, and <code>coef_table</code> a numeric matrix
with the estimated marginal coefficients, their standard errors and corresponding 
p-values using the normal approximation.
</p>


<h3>Author(s)</h3>

<p>Dimitris Rizopoulos <a href="mailto:d.rizopoulos@erasmusmc.nl">d.rizopoulos@erasmusmc.nl</a>
</p>


<h3>References</h3>

<p>Hedeker, D., du Toit, S. H., Demirtas, H. and Gibbons, R. D. (2018), A note on 
marginalization of regression parameters from mixed models of binary outcomes. 
<em>Biometrics</em> <b>74</b>, 354&ndash;361. doi:10.1111/biom.12707
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mixed_model">mixed_model</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# simulate some data
set.seed(123L)
n &lt;- 500
K &lt;- 15
t.max &lt;- 25

betas &lt;- c(-2.13, -0.25, 0.24, -0.05)
D &lt;- matrix(0, 2, 2)
D[1:2, 1:2] &lt;- c(0.48, -0.08, -0.08, 0.18)

times &lt;- c(replicate(n, c(0, sort(runif(K-1, 0, t.max)))))
group &lt;- sample(rep(0:1, each = n/2))
DF &lt;- data.frame(year = times, group = factor(rep(group, each = K)))
X &lt;- model.matrix(~ group * year, data = DF)
Z &lt;- model.matrix(~ year, data = DF)

b &lt;- cbind(rnorm(n, sd = sqrt(D[1, 1])), rnorm(n, sd = sqrt(D[2, 2])))
id &lt;- rep(1:n, each = K)
eta.y &lt;- as.vector(X %*% betas + rowSums(Z * b[id, ]))
DF$y &lt;- rbinom(n * K, 1, plogis(eta.y))
DF$id &lt;- factor(id)

################################################

fm1 &lt;- mixed_model(fixed = y ~ year * group, random = ~ 1 | id, data = DF,
                   family = binomial())

fixef(fm1)                   
marginal_coefs(fm1)
marginal_coefs(fm1, std_errors = TRUE, cores = 1L)

</code></pre>

<hr>
<h2 id='mixed_model'>
Generalized Linear Mixed Effects Models
</h2><span id='topic+mixed_model'></span>

<h3>Description</h3>

<p>Fits generalized linear mixed effects models under maximum likelihood using adaptive 
Gaussian quadrature.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mixed_model(fixed, random, data, family, weights = NULL,
  na.action = na.exclude, zi_fixed = NULL, zi_random = NULL, 
  penalized = FALSE, n_phis = NULL, initial_values = NULL, 
  control = list(), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mixed_model_+3A_fixed">fixed</code></td>
<td>
<p>a formula for the fixed-effects part of the model, including the outcome.</p>
</td></tr>
<tr><td><code id="mixed_model_+3A_random">random</code></td>
<td>
<p>a formula for the random-effects part of the model. This should only contain
the right-hand side part, e.g., <code>~ time | id</code>, where <code>time</code> is a variable,
and <code>id</code> the grouping factor. When the symbol <code>||</code> is used in the definition
of this argument (instead of <code>|</code>), then the covariance matrix of the random 
effects is assumed to be diagonal.</p>
</td></tr>
<tr><td><code id="mixed_model_+3A_data">data</code></td>
<td>
<p>a data.frame containing the variables required in <code>fixed</code> and 
<code>random</code>.</p>
</td></tr>
<tr><td><code id="mixed_model_+3A_family">family</code></td>
<td>
<p>a <code><a href="stats.html#topic+family">family</a></code> object specifying the type of the repeatedly measured response 
variable, e.g., <code>binomial()</code> or <code>poisson()</code>. The function also allows for 
user-defined family objects, but with specific extra components; see the example
is <code><a href="#topic+negative.binomial">negative.binomial</a></code> for more details. Contrary to the standard 
practice in model fitting R functions with a <code>family</code> argument 
(e.g., <code><a href="stats.html#topic+glm">glm</a></code>) in which the default
family is <code>gaussian()</code>, in <code>mixed_model()</code> no default is provided. If the
users wish to fit a mixed model for a Gaussian outcome, this could be done with 
function <code>lme()</code> from the <b>nlme</b> package or function <code>lmer()</code> from the
<b>lme4</b> package.</p>
</td></tr>
<tr><td><code id="mixed_model_+3A_weights">weights</code></td>
<td>
<p>a numeric vector of weights. These are simple multipliers on the 
log-likelihood contributions of each group/cluster, i.e., we presume that there are multiple 
replicates of each group/cluster denoted by the weights. The length of 'weights' need to
be equal to the number of independent groups/clusters in the data.</p>
</td></tr>
<tr><td><code id="mixed_model_+3A_na.action">na.action</code></td>
<td>
<p>what to do with missing values in <code>data</code>.</p>
</td></tr>
<tr><td><code id="mixed_model_+3A_zi_fixed">zi_fixed</code>, <code id="mixed_model_+3A_zi_random">zi_random</code></td>
<td>
<p>formulas for the fixed and random effects of the zero inflated 
part.</p>
</td></tr>
<tr><td><code id="mixed_model_+3A_penalized">penalized</code></td>
<td>
<p>logical or a list. If logical and equal to <code>FALSE</code>, then no penalty
is used. If logical and equal to <code>TRUE</code>, for the fixed effects a Student's-t 
penalty/prior with mean 0, scale equal to 1 and 3 degrees of freedom is used. If a
list, then it is expected to have the components <code>pen_mu</code>, <code>pen_sigma</code> and
<code>pen_df</code>, denoting the mean, scale and degrees of freedom of the Student's-t 
penalty/prior for the fixed effects.</p>
</td></tr>
<tr><td><code id="mixed_model_+3A_n_phis">n_phis</code></td>
<td>
<p>a numeric scalar; in case the family corresponds to a distribution that has extra 
(dispersion/shape) parameters, you need to specify how many extra parameters are needed.</p>
</td></tr>
<tr><td><code id="mixed_model_+3A_initial_values">initial_values</code></td>
<td>
<p>a list of initial values. This can have up to three components, 
namely,
</p>

<dl>
<dt>betas</dt><dd><p>a numeric vector of fixed effects. This can also be 
<code><a href="stats.html#topic+family">family</a></code> object. In this case initial values for the fixed effects 
will be calculated by using <code><a href="stats.html#topic+glm">glm</a></code> to the data ignoring the 
correlations in the repeated measurements. For example, for a negative binomial
response outcome, we could set <code>betas = poisson()</code>.</p>
</dd>
<dt>D</dt><dd><p>a numeric matrix denoting the covariance matrix of the random effects.</p>
</dd>
<dt>phis</dt><dd><p>a numeric vector for the extra (dispersion/shape) parameters.</p>
</dd>
</dl>

</td></tr>
<tr><td><code id="mixed_model_+3A_control">control</code></td>
<td>
<p>a list with the following components:
</p>

<dl>
<dt>iter_EM</dt><dd><p>numeric scalar denoting the number of EM iterations; default is 30.</p>
</dd>
<dt>iter_qN_outer</dt><dd><p>numeric scalar denoting the number of outer iterations during 
the quasi-Newton phase; default is 15. In each outer iteration the locations 
of the quadrature points are updated.</p>
</dd>
<dt>iter_qN</dt><dd><p>numeric scalar denoting the starting number of iterations for the 
quasi-Newton; default is 10.</p>
</dd>
<dt>iter_qN_incr</dt><dd><p>numeric scalar denoting the increment in <code>iter_qN</code> for
each outer iteration; default is 10.</p>
</dd>
<dt>optimizer</dt><dd><p>character string denoting the optimizer to be used; available 
options are <code>"optim"</code> (default), <code>"nlminb"</code> and 
<code>"optimParallel"</code>, the last option implemented in the 
<b>optimParallel</b> package.</p>
</dd>
<dt>optim_method</dt><dd><p>character string denoting the type of <code><a href="stats.html#topic+optim">optim</a></code> 
algorithm to be used when <code>optimizer = "optim"</code>; default is the BFGS 
algorithm.</p>
</dd>
<dt>parscale_betas</dt><dd><p>the control argument <code>parscale</code> of <code><a href="stats.html#topic+optim">optim</a></code> for
the fixed-effects; default is 0.1.</p>
</dd>
<dt>parscale_D</dt><dd><p>the control argument <code>parscale</code> of <code><a href="stats.html#topic+optim">optim</a></code> for
the unique element of the covariance matrix of the random effects; default is 
0.01.</p>
</dd>
<dt>parscale_phis</dt><dd><p>the control argument <code>parscale</code> of <code><a href="stats.html#topic+optim">optim</a></code> for
the extra (dispersion/shape) parameters; default is 0.01.</p>
</dd>
<dt>tol1, tol2, tol3</dt><dd><p>numeric scalars controlling tolerances for declaring 
convergence; <code>tol1</code> and <code>tol2</code> are for checking convergence in 
successive parameter values; <code>tol3</code> is similar to <code>reltop</code> of 
<code><a href="stats.html#topic+optim">optim</a></code>; default values are <code>1e-03</code>, <code>1e-04</code>, and 
<code>1e-08</code>, respectively.</p>
</dd>
<dt>numeric_deriv</dt><dd><p>character string denoting the type of numerical derivatives
to be used. Options are <code>"fd"</code> for forward differences, and <code>cd</code>
for central difference; default is <code>"fd"</code>.</p>
</dd>
<dt>nAGQ</dt><dd><p>numeric scalar denoting the number of quadrature points; default is 
11 when the number of random effects is one or two, and 7 otherwise.</p>
</dd>
<dt>update_GH_every</dt><dd><p>numeric scalar denoting every how many iterations to 
update the quadrature points during the EM-phase; default is 10.</p>
</dd>
<dt>max_coef_value</dt><dd><p>numeric scalar denoting the maximum allowable value for the
fixed effects coefficients during the optimization; default is 10.</p>
</dd>
<dt>max_phis_value</dt><dd><p>numeric scalar denoting the maximum allowable value for the
shape/dispersion parameter of the negative binomial distribution during the 
optimization; default is <code>exp(10)</code>.</p>
</dd>
<dt>verbose</dt><dd><p>logical; print information during the optimization phase; default 
is <code>FALSE</code>.</p>
</dd>
</dl>

</td></tr>
<tr><td><code id="mixed_model_+3A_...">...</code></td>
<td>
<p>arguments passed to <code>control</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><b>General:</b> The <code>mixed_model()</code> function fits mixed effects models in which the
integrals over the random effects in the definition of the marginal log-likelihood cannot
be solved analytically and need to be approximated. The function works under the 
assumption of normally distributed random effects with mean zero and variance-covariance
matrix <code class="reqn">D</code>. These integrals are approximated numerically using an adaptive 
Gauss-Hermite quadrature rule. Using the control argument <code>nAGQ</code>, the user can 
specify the number of quadrature points used in the approximation.
</p>
<p><b>User-defined family:</b> The user can define its own family object; for an example, 
see the help page of <code><a href="#topic+negative.binomial">negative.binomial</a></code>.
</p>
<p><b>Optimization:</b> A hybrid approach is used, starting with <code>iter_EM</code> iterations
and unless convergence was achieved it continuous with a direct optimization of the 
log-likelihood using function <code><a href="stats.html#topic+optim">optim</a></code> and the algorithm specified by 
<code>optim_method</code>. For stability and speed, the derivative of the log-likelihood with 
respect to the parameters are internally programmed.
</p>


<h3>Value</h3>

<p>An object of class <code>"MixMod"</code> with components:
</p>
<table>
<tr><td><code>coefficients</code></td>
<td>
<p>a numeric vector with the estimated fixed effects.</p>
</td></tr>
<tr><td><code>phis</code></td>
<td>
<p>a numeric vector with the estimated extra parameters.</p>
</td></tr>
<tr><td><code>D</code></td>
<td>
<p>a numeric matrix denoting the estimated covariance matrix of the random effects.</p>
</td></tr>
<tr><td><code>post_modes</code></td>
<td>
<p>a numeric matrix with the empirical Bayes estimates of the random effects.</p>
</td></tr>
<tr><td><code>post_vars</code></td>
<td>
<p>a list of numeric matrices with the posterior variances of the random effects.</p>
</td></tr>
<tr><td><code>logLik</code></td>
<td>
<p>a numeric scalar denoting the log-likelihood value at the end of the 
optimization procedure.</p>
</td></tr>
<tr><td><code>Hessian</code></td>
<td>
<p>a numeric matrix denoting the Hessian matrix at the end of the optimization 
procedure.</p>
</td></tr>
<tr><td><code>converged</code></td>
<td>
<p>a logical indicating whether convergence was attained.</p>
</td></tr>
<tr><td><code>data</code></td>
<td>
<p>a copy of the <code>data</code> argument.</p>
</td></tr>
<tr><td><code>id</code></td>
<td>
<p>a copy of the grouping variable from <code>data</code>.</p>
</td></tr>
<tr><td><code>id_name</code></td>
<td>
<p>a character string with the name of the grouping variable.</p>
</td></tr>
<tr><td><code>Terms</code></td>
<td>
<p>a list with two terms components, <code>termsX</code> derived from the <code>fixed</code>
argument, and <code>termsZ</code> derived from the <code>random</code> argument.</p>
</td></tr>
<tr><td><code>model_frames</code></td>
<td>
<p>a list with two model.frame components, <code>mfX</code> derived from the 
<code>fixed</code> argument, and <code>mfZ</code> derived from the <code>random</code> argument.</p>
</td></tr>
<tr><td><code>control</code></td>
<td>
<p>a copy of the (user-specific) <code>control</code> argument.</p>
</td></tr>
<tr><td><code>Funs</code></td>
<td>
<p>a list of functions used in the optimization procedure.</p>
</td></tr>
<tr><td><code>family</code></td>
<td>
<p>a copy of the <code>family</code> argument.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>the matched call.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Dimitris Rizopoulos <a href="mailto:d.rizopoulos@erasmusmc.nl">d.rizopoulos@erasmusmc.nl</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+methods.MixMod">methods.MixMod</a></code>,
<code><a href="#topic+effectPlotData">effectPlotData</a></code>,
<code><a href="#topic+marginal_coefs">marginal_coefs</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># simulate some data
set.seed(123L)
n &lt;- 200
K &lt;- 15
t.max &lt;- 25

betas &lt;- c(-2.13, -0.25, 0.24, -0.05)
D &lt;- matrix(0, 2, 2)
D[1:2, 1:2] &lt;- c(0.48, -0.08, -0.08, 0.18)

times &lt;- c(replicate(n, c(0, sort(runif(K-1, 0, t.max)))))
group &lt;- sample(rep(0:1, each = n/2))
DF &lt;- data.frame(year = times, group = factor(rep(group, each = K)))
X &lt;- model.matrix(~ group * year, data = DF)
Z &lt;- model.matrix(~ year, data = DF)

b &lt;- cbind(rnorm(n, sd = sqrt(D[1, 1])), rnorm(n, sd = sqrt(D[2, 2])))
id &lt;- rep(1:n, each = K)
eta.y &lt;- as.vector(X %*% betas + rowSums(Z * b[id, ]))
DF$y &lt;- rbinom(n * K, 1, plogis(eta.y))
DF$id &lt;- factor(id)

################################################

fm1 &lt;- mixed_model(fixed = y ~ year * group, random = ~ 1 | id, data = DF,
                   family = binomial())

# fixed effects
fixef(fm1)

# random effects
head(ranef(fm1))

# detailed output
summary(fm1)

# fitted values for the 'mean subject', i.e., with
# random effects values equal to 0
head(fitted(fm1, type = "mean_subject"))

# fitted values for the conditioning on the estimated random effects
head(fitted(fm1, type = "subject_specific"))

##############

fm2 &lt;- mixed_model(fixed = y ~ year, random = ~ 1 | id, data = DF,
                   family = binomial())

# likelihood ratio test between the two models
anova(fm2, fm1)

# the same hypothesis but with a Wald test
anova(fm1, L = rbind(c(0, 0, 1, 0), c(0, 0, 0, 1)))

##############

# An effects plot for the mean subject (i.e., with random effects equal to 0)
nDF &lt;- with(DF, expand.grid(year = seq(min(year), max(year), length.out = 15),
    group = levels(group)))
    
plot_data &lt;- effectPlotData(fm2, nDF)

require("lattice")
xyplot(pred + low + upp ~ year | group, data = plot_data,
       type = "l", lty = c(1, 2, 2), col = c(2, 1, 1), lwd = 2,
       xlab = "Follow-up time", ylab = "log odds")

expit &lt;- function (x) exp(x) / (1 + exp(x))
xyplot(expit(pred) + expit(low) + expit(upp) ~ year | group, data = plot_data,
       type = "l", lty = c(1, 2, 2), col = c(2, 1, 1), lwd = 2,
       xlab = "Follow-up time", ylab = "Probabilities")

# An effects plots for the marginal probabilities
plot_data_m &lt;- effectPlotData(fm2, nDF, marginal = TRUE, cores = 1L)

expit &lt;- function (x) exp(x) / (1 + exp(x))
xyplot(expit(pred) + expit(low) + expit(upp) ~ year | group, data = plot_data_m,
       type = "l", lty = c(1, 2, 2), col = c(2, 1, 1), lwd = 2,
       xlab = "Follow-up time", ylab = "Probabilities")

##############

# include random slopes
fm1_slp &lt;- update(fm1, random = ~ year | id)

# increase the number of quadrature points to 15
fm1_slp_q15 &lt;- update(fm1_slp, nAGQ = 15)

# a diagonal covariance matrix for the random effects
fm1_slp_diag &lt;- update(fm1, random = ~ year || id)

anova(fm1_slp_diag, fm1_slp)

</code></pre>

<hr>
<h2 id='MixMod+20Methods'>
Various Methods for Standard Generics
</h2><span id='topic+methods.MixMod'></span><span id='topic+coef'></span><span id='topic+coef.MixMod'></span><span id='topic+fixef'></span><span id='topic+fixef.MixMod'></span><span id='topic+ranef'></span><span id='topic+ranef.MixMod'></span><span id='topic+confint'></span><span id='topic+confint.MixMod'></span><span id='topic+anova'></span><span id='topic+anova.MixMod'></span><span id='topic+fitted'></span><span id='topic+fitted.MixMod'></span><span id='topic+residuals'></span><span id='topic+residuals.MixMod'></span><span id='topic+predict'></span><span id='topic+predict.MixMod'></span><span id='topic+simulate'></span><span id='topic+simulate.MixMod'></span><span id='topic+terms'></span><span id='topic+terms.MixMod'></span><span id='topic+formula'></span><span id='topic+formula.MixMod'></span><span id='topic+model.matrix'></span><span id='topic+model.matrix.MixMod'></span><span id='topic+model.frame'></span><span id='topic+model.frame.MixMod'></span><span id='topic+nobs'></span><span id='topic+nobs.MixMod'></span><span id='topic+VIF'></span><span id='topic+VIF.MixMod'></span><span id='topic+cooks.distance'></span><span id='topic+cooks.distance.MixMod'></span>

<h3>Description</h3>

<p>Methods for object of class <code>"MixMod"</code> for standard generic functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
coef(object, ...)

## S3 method for class 'MixMod'
coef(object, sub_model = c("main", "zero_part"), 
    ...)

fixef(object, ...)

## S3 method for class 'MixMod'
fixef(object, sub_model = c("main", "zero_part"), ...)

ranef(object, ...)

## S3 method for class 'MixMod'
ranef(object, post_vars = FALSE, ...)

confint(object, parm, level = 0.95, ...)

## S3 method for class 'MixMod'
confint(object, 
  parm = c("fixed-effects", "var-cov","extra", "zero_part"), 
  level = 0.95, sandwich = FALSE, ...)

anova(object, ...)

## S3 method for class 'MixMod'
anova(object, object2, test = TRUE, 
  L = NULL, sandwich = FALSE, ...)

fitted(object, ...)

## S3 method for class 'MixMod'
fitted(object, 
  type = c("mean_subject", "subject_specific", "marginal"),
  link_fun = NULL, ...)

residuals(object, ...)

## S3 method for class 'MixMod'
residuals(object, 
  type = c("mean_subject", "subject_specific", "marginal"), 
  link_fun = NULL, tasnf_y = function (x) x, ...)
  
predict(object, ...)

## S3 method for class 'MixMod'
predict(object, newdata, newdata2 = NULL, 
    type_pred = c("response", "link"),
    type = c("mean_subject", "subject_specific", "marginal", "zero_part"),
    se.fit = FALSE, M = 300, df = 10, scale = 0.3, level = 0.95, 
    seed = 1, return_newdata = FALSE, sandwich = FALSE, ...)
    
simulate(object, nsim = 1, seed = NULL, ...)

## S3 method for class 'MixMod'
simulate(object, nsim = 1, seed = NULL, 
    type = c("subject_specific", "mean_subject"), new_RE = FALSE,
    acount_MLEs_var = FALSE, sim_fun = NULL, 
    sandwich = FALSE, ...)
    
terms(x, ...)

## S3 method for class 'MixMod'
terms(x, type = c("fixed", "random", "zi_fixed", "zi_random"), ...)

formula(x, ...)

## S3 method for class 'MixMod'
formula(x, type = c("fixed", "random", "zi_fixed", "zi_random"), ...)


model.frame(formula, ...)

## S3 method for class 'MixMod'
model.frame(formula, type = c("fixed", "random", "zi_fixed", "zi_random"), ...)

model.matrix(object, ...)

## S3 method for class 'MixMod'
model.matrix(object, type = c("fixed", "random", "zi_fixed", "zi_random"), ...)

nobs(object, ...)

## S3 method for class 'MixMod'
nobs(object, level = 1, ...)

VIF(object, ...)

## S3 method for class 'MixMod'
VIF(object, type = c("fixed", "zi_fixed"), ...)

cooks.distance(model, ...)

## S3 method for class 'MixMod'
cooks.distance(model, cores = max(parallel::detectCores() - 1, 1), ...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MixMod+2B20Methods_+3A_object">object</code>, <code id="MixMod+2B20Methods_+3A_object2">object2</code>, <code id="MixMod+2B20Methods_+3A_x">x</code>, <code id="MixMod+2B20Methods_+3A_formula">formula</code>, <code id="MixMod+2B20Methods_+3A_model">model</code></td>
<td>
<p>objects inheriting from class <code>"MixMod"</code>. When <code>object2</code>
is also provided, then the model behind <code>object</code> must be nested within the model 
behind <code>object2</code>.</p>
</td></tr>
<tr><td><code id="MixMod+2B20Methods_+3A_sub_model">sub_model</code></td>
<td>
<p>character string indicating for which sub-model to extract the estimated
coefficients; it is only relevant for zero-inflated models.</p>
</td></tr>
<tr><td><code id="MixMod+2B20Methods_+3A_post_vars">post_vars</code></td>
<td>
<p>logical; if <code>TRUE</code> the posterior variances of the random effects
are returned as an extra attribute of the numeric matrix produced by <code>ranef()</code>.</p>
</td></tr>
<tr><td><code id="MixMod+2B20Methods_+3A_parm">parm</code></td>
<td>
<p>character string; for which type of parameters to calculate confidence 
intervals. Option <code>"var-cov"</code> corresponds to the variance-covariance matrix of the 
random effects. Option <code>extra</code> corresponds to extra (shape/dispersion) 
parameters in the distribution of the outcome (e.g., the <code class="reqn">\theta</code> parameter in
the negative binomial family). Option <code>zero_inflated</code> corresponds to the 
coefficients of the zero-inflated sub-model.</p>
</td></tr>
<tr><td><code id="MixMod+2B20Methods_+3A_level">level</code></td>
<td>
<p>numeric scalar between 0 and 1 denoting the level of the confidence interval.
In the <code>nobs()</code> method it denotes the level at which the number of observations is
counted. The value 0 corresponds to the number of independent sample units 
determined by the number of levels of the grouping variable. If set to a value greater
than zero, it returns the total number of observations.</p>
</td></tr>
<tr><td><code id="MixMod+2B20Methods_+3A_test">test</code></td>
<td>
<p>logical; should a p-value be calculated.</p>
</td></tr>
<tr><td><code id="MixMod+2B20Methods_+3A_l">L</code></td>
<td>
<p>a numeric matrix representing a contrasts matrix. This is only used when in 
<code>anova()</code> only <code>object</code> is provided, and it can only be specified for the fixed 
effects. When <code>L</code> is used, a Wald test is performed.</p>
</td></tr>
<tr><td><code id="MixMod+2B20Methods_+3A_sandwich">sandwich</code></td>
<td>
<p>logical; if <code>TRUE</code> the sandwich estimator is used in the calculation
of standard errors.</p>
</td></tr>
<tr><td><code id="MixMod+2B20Methods_+3A_type">type</code></td>
<td>
<p>character string indicating the type of fitted values / residuals / predictions 
/ variance inflation factors to calculate. Option <code>"mean_subject"</code> corresponds to only using the fixed-effects
part; option <code>"subject_specific"</code> corresponds to using both the fixed- and 
random-effects parts; option <code>"marginal"</code> is based in multiplying the fixed 
effects design matrix with the marginal coefficients obtained by 
<code><a href="#topic+marginal_coefs">marginal_coefs</a></code>.</p>
</td></tr>
<tr><td><code id="MixMod+2B20Methods_+3A_link_fun">link_fun</code></td>
<td>
<p>the <code>link_fun</code> of <code><a href="#topic+marginal_coefs">marginal_coefs</a></code>.</p>
</td></tr>
<tr><td><code id="MixMod+2B20Methods_+3A_tasnf_y">tasnf_y</code></td>
<td>
<p>a function to transform the grouped / repeated measurements outcome before
calculating the residuals; for example, relevant in two-part models for semi-continuous
data, in which it is assumed that the log outcome follows a normal distribution.</p>
</td></tr>
<tr><td><code id="MixMod+2B20Methods_+3A_newdata">newdata</code>, <code id="MixMod+2B20Methods_+3A_newdata2">newdata2</code></td>
<td>
<p>a data frame based on which predictions are to be calculated.
<code>newdata2</code> is only relevant when <code>level = "subject_specific"</code>; see 
<b>Details</b> for more information.</p>
</td></tr>
<tr><td><code id="MixMod+2B20Methods_+3A_type_pred">type_pred</code></td>
<td>
<p>character string indicating at which scale to calculate predictions. 
Options are <code>"link"</code> indicating to calculate predictions at the link function / 
linear predictor scale, and <code>"response"</code> indicating to calculate predictions at
the scale of the response variable.</p>
</td></tr>
<tr><td><code id="MixMod+2B20Methods_+3A_se.fit">se.fit</code></td>
<td>
<p>logical, if <code>TRUE</code> standard errors of predictions are returned.</p>
</td></tr>
<tr><td><code id="MixMod+2B20Methods_+3A_m">M</code></td>
<td>
<p>numeric scalar denoting the number of Monte Carlo samples; see 
<b>Details</b> for more information.</p>
</td></tr>
<tr><td><code id="MixMod+2B20Methods_+3A_df">df</code></td>
<td>
<p>numeric scalar denoting the degrees of freedom for the Student's t proposal
distribution; see <b>Details</b> for more information.</p>
</td></tr>
<tr><td><code id="MixMod+2B20Methods_+3A_scale">scale</code></td>
<td>
<p>numeric scalar or vector denoting the scaling applied to the subject-specific
covariance matrices of the random effects; see <b>Details</b> for more information.</p>
</td></tr>
<tr><td><code id="MixMod+2B20Methods_+3A_seed">seed</code></td>
<td>
<p>numerical scalar giving the seed to be used in the Monte Carlo scheme.</p>
</td></tr>
<tr><td><code id="MixMod+2B20Methods_+3A_return_newdata">return_newdata</code></td>
<td>
<p>logical; if <code>TRUE</code> the <code>predict()</code> method returns a copy
of the <code>newdata</code> and of <code>newdata2</code> if the corresponding argument was not 
<code>NULL</code>, with extra columns the predictions, and the lower and upper limits of
the cofidence intervals when <code>type = "subject_specific"</code>.</p>
</td></tr>
<tr><td><code id="MixMod+2B20Methods_+3A_nsim">nsim</code></td>
<td>
<p>numeric scalar giving the number of times to simulate the response variable.</p>
</td></tr>
<tr><td><code id="MixMod+2B20Methods_+3A_new_re">new_RE</code></td>
<td>
<p>logical; if <code>TRUE</code>, new random effects will be simulated, and new outcome
data will be simulated by <code>simulate()</code> using these new random effect. Otherwise,
the empirical Bayes estimates of the random effects from the fitted model will be used.</p>
</td></tr>
<tr><td><code id="MixMod+2B20Methods_+3A_acount_mles_var">acount_MLEs_var</code></td>
<td>
<p>logical; if <code>TRUE</code> it accounts for the variability of the 
maximum likelihood estimates (MLEs) by simulating a new value for the parameters from 
a multivariate normal distribution with mean the MLEs and covariance matrix the 
covariance matrix of the MLEs.</p>
</td></tr>
<tr><td><code id="MixMod+2B20Methods_+3A_sim_fun">sim_fun</code></td>
<td>
<p>a function based on which to simulate the response variable. This is 
relevant for non-standard models. The <code>simulate()</code> function also tries to extract 
this function from the <code>family</code> component of <code>object</code>. The function should 
have the following four arguments: <code>n</code> a numeric scalar denoting the number of
observations to simulate, <code>mu</code> a numeric vector of means, <code>phis</code> a numeric
vector of extra dispersion/scale parameters, and <code>eta_zi</code> a numeric vector for 
the zero-part of the model, if this is relevant.</p>
</td></tr>
<tr><td><code id="MixMod+2B20Methods_+3A_cores">cores</code></td>
<td>
<p>the number of cores to use in the computation.</p>
</td></tr>
<tr><td><code id="MixMod+2B20Methods_+3A_...">...</code></td>
<td>
<p>further arguments; currently none is used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In generic terms, we assume that the mean of the outcome <code class="reqn">y_i</code> (<code class="reqn">i = 1, ..., n</code> 
denotes the subjects) conditional on the random effects is given by the equation: 
</p>
<p style="text-align: center;"><code class="reqn">g{E(y_i | b_i)} = \eta_i = X_i \beta + Z_i b_i,</code>
</p>

<p>where <code class="reqn">g(.)</code> denotes the link function, <code class="reqn">b_i</code> the vector of random effects, 
<code class="reqn">\beta</code> the vector of fixed effects, and <code class="reqn">X_i</code> and <code class="reqn">Z_i</code> the design matrices
for the fixed and random effects, respectively.
</p>
<p>Argument <code>type_pred</code> of <code>predict()</code> specifies whether predictions will be 
calculated in the link / linear predictor scale, i.e., <code class="reqn">\eta_i</code> or in the response 
scale, i.e., <code class="reqn">g{E(y_i | b_i)}</code>.
</p>
<p>When <code>type = "mean_subject"</code>, predictions are calculated using only the fixed 
effects, i.e., the <code class="reqn">X_i \beta</code> part, where <code class="reqn">X_i</code> is evaluated in <code>newdata</code>. 
This corresponds to predictions for the 'mean' subjects, i.e., subjects who have 
random effects value equal to 0. Note, that in the case of nonlinear link functions this
does not correspond to the averaged over the population predictions (i.e., marginal 
predictions).
</p>
<p>When <code>type = "marginal"</code>, predictions are calculated using only the fixed 
effects, i.e., the <code class="reqn">X_i \beta</code> part, where <code class="reqn">X_i</code> is evaluated in <code>newdata</code>,
but with <code class="reqn">\beta</code> coefficients the marginalized coefficients obtain from 
<code><a href="#topic+marginal_coefs">marginal_coefs</a></code>. These predictions will be marginal / population averaged 
predictions.
</p>
<p>When <code>type = "zero_part"</code>, predictions are calculated for the logistic regression of
the extra zero-part of the model (i.e., applicable for zero-inflated and hurdle models).
</p>
<p>When <code>type = "subject_specific"</code>, predictions are calculated using both the fixed- 
and random-effects parts, i.e., <code class="reqn">X_i \beta + Z_i b_i</code>, where <code class="reqn">X_i</code> and <code class="reqn">Z_i</code> 
are evaluated in <code>newdata</code>. Estimates for the random effects of each subject are 
obtained as modes from the posterior distribution <code class="reqn">[b_i | y_i; \theta]</code> evaluated in 
<code>newdata</code> and with <code class="reqn">theta</code> (denoting the parameters of the model, fixed effects
and variance components) replaced by their maximum likelihood estimates. 
</p>
<p><b>Notes:</b> (i) When <code>se.fit = TRUE</code> and <code>type_pred = "response"</code>, the 
standard errors returned are on the linear predictor scale, not the response scale. 
(ii) When <code>se.fit = TRUE</code> and the model contains an extra zero-part, no standard 
errors are computed when <code>type = "mean_subject"</code>. (iii) When the model contains an 
extra zero-part, <code>type = "marginal"</code> predictions are not yet implemented.
</p>
<p>When <code>se.fit = TRUE</code> and <code>type = "subject_specific"</code>, standard errors and 
confidence intervals for the subject-specific predictions are obtained by a Monte Carlo 
scheme entailing three steps repeated <code>M</code> times, namely
</p>

<dl>
<dt>Step I</dt><dd><p>Account for the variability of maximum likelihood estimates (MLES) by 
simulating a new value <code class="reqn">\theta^*</code> for the parameters <code class="reqn">\theta</code> from a 
multivariate normal distribution with mean the MLEs and covariance matrix the 
covariance matrix of the MLEs.</p>
</dd>
<dt>Step II</dt><dd><p>Account for the variability in the random effects estimates by 
simulating a new value <code class="reqn">b_i^*</code> for the random effects <code class="reqn">b_i</code> from the posterior
distribution <code class="reqn">[b_i | y_i; \theta^*]</code>. Because the posterior distribution does not
have a closed-form, a Metropolis-Hastings algorithm is used to sample the new value 
<code class="reqn">b_i^*</code> using as proposal distribution a multivariate Student's-t distribution
with degrees of freedom <code>df</code>, centered at the mode of the posterior distribution
<code class="reqn">[b_i | y_i; \theta]</code> with <code class="reqn">\theta</code> the MLEs, and scale matrix the inverse
Hessian matrix of the log density of <code class="reqn">[b_i | y_i; \theta]</code> evaluated at the modes,
but multiplied by <code>scale</code>. The <code>scale</code> and <code>df</code> parameters can be used 
to adjust the acceptance rate.</p>
</dd>
<dt>Step III</dt><dd><p>The predictions are calculated using <code class="reqn">X_i \beta^* + Z_i b_i^*</code>.</p>
</dd>
</dl>

<p>Argument <code>newdata2</code> can be used to calculate dynamic subject-specific predictions. 
I.e., using the observed responses <code class="reqn">y_i</code> in <code>newdata</code>, estimates of the random
effects of each subject are obtained. For the same subjects we want to obtain predictions
in new covariates settings for which no response data are yet available. For example, 
in a longitudinal study, for a subject we have responses up to a follow-up <code class="reqn">t</code> 
(<code>newdata</code>) and we want the prediction at <code class="reqn">t + \Delta t</code> (<code>newdata2</code>).
</p>


<h3>Value</h3>

<p>The estimated fixed and random effects, coefficients (this is similar as in package 
<b>nlme</b>), confidence intervals fitted values (on the scale on the response) and 
residuals.
</p>


<h3>Author(s)</h3>

<p>Dimitris Rizopoulos <a href="mailto:d.rizopoulos@erasmusmc.nl">d.rizopoulos@erasmusmc.nl</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mixed_model">mixed_model</a></code>,
<code><a href="#topic+marginal_coefs">marginal_coefs</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# simulate some data
set.seed(123L)
n &lt;- 500
K &lt;- 15
t.max &lt;- 25

betas &lt;- c(-2.13, -0.25, 0.24, -0.05)
D &lt;- matrix(0, 2, 2)
D[1:2, 1:2] &lt;- c(0.48, -0.08, -0.08, 0.18)

times &lt;- c(replicate(n, c(0, sort(runif(K-1, 0, t.max)))))
group &lt;- sample(rep(0:1, each = n/2))
DF &lt;- data.frame(year = times, group = factor(rep(group, each = K)))
X &lt;- model.matrix(~ group * year, data = DF)
Z &lt;- model.matrix(~ year, data = DF)

b &lt;- cbind(rnorm(n, sd = sqrt(D[1, 1])), rnorm(n, sd = sqrt(D[2, 2])))
id &lt;- rep(1:n, each = K)
eta.y &lt;- as.vector(X %*% betas + rowSums(Z * b[id, ]))
DF$y &lt;- rbinom(n * K, 1, plogis(eta.y))
DF$id &lt;- factor(id)

################################################

fm1 &lt;- mixed_model(fixed = y ~ year + group, random = ~ year | id, data = DF,
                   family = binomial())

head(coef(fm1))
fixef(fm1)
head(ranef(fm1))


confint(fm1)
confint(fm1, "var-cov")

head(fitted(fm1, "subject_specific"))
head(residuals(fm1, "marginal"))

fm2 &lt;- mixed_model(fixed = y ~ year * group, random = ~ year | id, data = DF,
                   family = binomial())

# likelihood ratio test between fm1 and fm2
anova(fm1, fm2)

# the same but with a Wald test
anova(fm2, L = rbind(c(0, 0, 0, 1)))

</code></pre>

<hr>
<h2 id='negative.binomial'>
Family function for Negative Binomial Mixed Models
</h2><span id='topic+negative.binomial'></span>

<h3>Description</h3>

<p>Specifies the information required to fit a Negative Binomial generalized linear mixed 
model, using <code>mixed_model()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>negative.binomial()
</code></pre>


<h3>Note</h3>

<p>Currently only the log-link is implemented.</p>


<h3>Author(s)</h3>

<p>Dimitris Rizopoulos <a href="mailto:d.rizopoulos@erasmusmc.nl">d.rizopoulos@erasmusmc.nl</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# simulate some data
set.seed(102)
dd &lt;- expand.grid(f1 = factor(1:3), f2 = LETTERS[1:2], g = 1:30, rep = 1:15,
                  KEEP.OUT.ATTRS = FALSE)
mu &lt;- 5 * (-4 + with(dd, as.integer(f1) + 4 * as.numeric(f2)))
dd$y &lt;- rnbinom(nrow(dd), mu = mu, size = 0.5)

gm1 &lt;-  mixed_model(fixed = y ~ f1 * f2, random = ~ 1 | g, data = dd, 
                    family = negative.binomial())

summary(gm1)

# We do a likelihood ratio test with the Poisson mixed model
gm0 &lt;- mixed_model(fixed = y ~ f1 * f2, random = ~ 1 | g, data = dd, 
                    family = poisson())
                    
anova(gm0, gm1)

# Define a cutom-made family function to be used with mixed_model()
# the required components are 'family', 'link', 'linkfun', 'linkinv' and 'log_dens';
# the extra functions 'score_eta_fun' and 'score_phis_fun' can be skipped and will 
# internally approximated using numeric derivatives (though it is better that you provide
# them).
my_negBinom &lt;- function (link = "log") {
    stats &lt;- make.link(link)
    log_dens &lt;- function (y, eta, mu_fun, phis, eta_zi) {
        # the log density function
        phis &lt;- exp(phis)
        mu &lt;- mu_fun(eta)
        log_mu_phis &lt;- log(mu + phis)
        comp1 &lt;- lgamma(y + phis) - lgamma(phis) - lgamma(y + 1)
        comp2 &lt;- phis * log(phis) - phis * log_mu_phis
        comp3 &lt;- y * log(mu) - y * log_mu_phis
        out &lt;- comp1 + comp2 + comp3
        attr(out, "mu_y") &lt;- mu
        out
    }
    score_eta_fun &lt;- function (y, mu, phis, eta_zi) {
        # the derivative of the log density w.r.t. mu
        phis &lt;- exp(phis)
        mu_phis &lt;- mu + phis
        comp2 &lt;- - phis / mu_phis
        comp3 &lt;- y / mu - y / mu_phis
        # the derivative of mu w.r.t. eta (this depends on the chosen link function)
        mu.eta &lt;- mu
        (comp2 + comp3) * mu.eta
    }
    score_phis_fun &lt;- function (y, mu, phis, eta_zi) {
        # the derivative of the log density w.r.t. phis
        phis &lt;- exp(phis)
        mu_phis &lt;- mu + phis
        comp1 &lt;- digamma(y + phis) - digamma(phis)
        comp2 &lt;- log(phis) + 1 - log(mu_phis) - phis / mu_phis
        comp3 &lt;- - y / mu_phis
        comp1 + comp2 + comp3
    }
    structure(list(family = "user Neg Binom", link = stats$name, linkfun = stats$linkfun,
                   linkinv = stats$linkinv, log_dens = log_dens,
                   score_eta_fun = score_eta_fun,
                   score_phis_fun = score_phis_fun),
              class = "family")
}

fm &lt;-  mixed_model(fixed = y ~ f1 * f2, random = ~ 1 | g, data = dd, 
                   family = my_negBinom(), n_phis = 1, 
                   initial_values = list("betas" = poisson()))

summary(fm)

</code></pre>

<hr>
<h2 id='scoring_rules'>
Proper Scoring Rules for Categorical Data
</h2><span id='topic+scoring_rules'></span>

<h3>Description</h3>

<p>Calculates the logarithmic, quadratic/Brier and spherical based on a fitted mixed model
for categorical data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scoring_rules(object, newdata, newdata2 = NULL, max_count = 2000, 
    return_newdata = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scoring_rules_+3A_object">object</code></td>
<td>
<p>an object inheriting from class <code>"MixMod"</code>.</p>
</td></tr>
<tr><td><code id="scoring_rules_+3A_newdata">newdata</code></td>
<td>
<p>a data.frame based on which to estimate the random effect and calculate 
predictions. It should contain the response variable.</p>
</td></tr>
<tr><td><code id="scoring_rules_+3A_newdata2">newdata2</code></td>
<td>
<p>a data.frame based on which to estimate the random effect and calculate 
predictions. It should contain the response variable.</p>
</td></tr>
<tr><td><code id="scoring_rules_+3A_max_count">max_count</code></td>
<td>
<p>numeric scalar denoting the maximum count up to which to calculate 
probabilities; this is relevant for count response data.</p>
</td></tr>
<tr><td><code id="scoring_rules_+3A_return_newdata">return_newdata</code></td>
<td>
<p>logical; if <code>TRUE</code> the values of the scoring rules are 
ruturned as extra columns of the <code>newdata</code> or <code>newdata2</code> data.frame.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame with (extra) columns the values of the logarithmic, quadratic and spherical
scoring rules calculated based on the fitted model and the observed responses in 
<code>newdata</code> or <code>newdata2</code>.
</p>


<h3>Author(s)</h3>

<p>Dimitris Rizopoulos <a href="mailto:d.rizopoulos@erasmusmc.nl">d.rizopoulos@erasmusmc.nl</a>
</p>


<h3>References</h3>

<p>Carvalho, A. (2016). An overview of applications of proper scoring rules. 
<em>Decision Analysis</em> <b>13</b>, 223&ndash;242. doi:10.1287/deca.2016.0337
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mixed_model">mixed_model</a></code>,
<code><a href="#topic+predict.MixMod">predict.MixMod</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
NA
NA
NA

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
