<!DOCTYPE html><html><head><title>Help for package tidycensus</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {tidycensus}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#acs5_geography'><p>Dataset used to identify geography availability in the 5-year ACS Detailed Tables</p></a></li>
<li><a href='#as_dot_density'><p>Convert polygon geometry to dots for dot-density mapping</p></a></li>
<li><a href='#census_api_key'><p>Install a CENSUS API Key in Your <code>.Renviron</code> File for Repeated Use</p></a></li>
<li><a href='#check_ddhca_groups'><p>Check to see if a given geography / population group combination is available in the Detailed DHC-A file.</p></a></li>
<li><a href='#county_laea'><p>County geometry with Alaska and Hawaii shifted and re-scaled</p></a></li>
<li><a href='#fips_codes'><p>Dataset with FIPS codes for US states and counties</p></a></li>
<li><a href='#get_acs'><p>Obtain data and feature geometry for the American Community Survey</p></a></li>
<li><a href='#get_decennial'><p>Obtain data and feature geometry for the decennial US Census</p></a></li>
<li><a href='#get_estimates'><p>Get data from the US Census Bureau Population Estimates Program</p></a></li>
<li><a href='#get_flows'><p>Obtain data and feature geometry for American Community Survey Migration</p>
Flows</a></li>
<li><a href='#get_pop_groups'><p>Get available population groups for a given Decennial Census year and summary file</p></a></li>
<li><a href='#get_pums'><p>Load data from the American Community Survey Public Use Microdata Series API</p></a></li>
<li><a href='#interpolate_pw'><p>Use population-weighted interpolation to transfer information from one set of shapes to another</p></a></li>
<li><a href='#load_variables'><p>Load variables from a decennial Census or American Community Survey dataset to search in R</p></a></li>
<li><a href='#mig_recodes'><p>Dataset with Migration Flows characteristic recodes</p></a></li>
<li><a href='#moe_product'><p>Calculate the margin of error for a derived product</p></a></li>
<li><a href='#moe_prop'><p>Calculate the margin of error for a derived proportion</p></a></li>
<li><a href='#moe_ratio'><p>Calculate the margin of error for a derived ratio</p></a></li>
<li><a href='#moe_sum'><p>Calculate the margin of error for a derived sum</p></a></li>
<li><a href='#pums_variables'><p>Dataset with PUMS variables and codes</p></a></li>
<li><a href='#significance'><p>Evaluate whether the difference in two estimates is statistically significant.</p></a></li>
<li><a href='#state_laea'><p>State geometry with Alaska and Hawaii shifted and re-scaled</p></a></li>
<li><a href='#summary_files'><p>Identify summary files for a given decennial Census year</p></a></li>
<li><a href='#tidycensus'><p>Return tidy data frames from the US Census Bureau API</p></a></li>
<li><a href='#to_survey'><p>Convert a data frame returned by get_pums() to a survey object</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Load US Census Boundary and Attribute Data as 'tidyverse' and
'sf'-Ready Data Frames</td>
</tr>
<tr>
<td>Version:</td>
<td>1.6.3</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-03-20</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://walker-data.com/tidycensus/">https://walker-data.com/tidycensus/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/walkerke/tidycensus/issues">https://github.com/walkerke/tidycensus/issues</a></td>
</tr>
<tr>
<td>Description:</td>
<td>An integrated R interface to several United States Census Bureau 
    APIs (<a href="https://www.census.gov/data/developers/data-sets.html">https://www.census.gov/data/developers/data-sets.html</a>) and the US Census Bureau's 
    geographic boundary files. Allows R users to return Census and ACS data as 
    tidyverse-ready data frames, and optionally returns a list-column with feature geometry for mapping 
    and spatial analysis. </td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.3.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>httr, sf, dplyr (&ge; 1.0.0), tigris, stringr, jsonlite (&ge;
1.5.0), purrr, rvest, tidyr (&ge; 1.0.0), rappdirs, readr, xml2,
units, utils, rlang, crayon, tidyselect</td>
</tr>
<tr>
<td>Suggests:</td>
<td>ggplot2, survey, srvyr, terra</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-03-20 15:16:46 UTC; kylewalker</td>
</tr>
<tr>
<td>Author:</td>
<td>Kyle Walker [aut, cre],
  Matt Herman [aut],
  Kris Eberwein [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Kyle Walker &lt;kyle@walker-data.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-03-20 16:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='acs5_geography'>Dataset used to identify geography availability in the 5-year ACS Detailed Tables</h2><span id='topic+acs5_geography'></span>

<h3>Description</h3>

<p>Built-in dataset for use by <code>load_variables()</code> to identify the smallest
geography at which 5-year ACS data are available
</p>

<ul>
<li> <p><code>table</code>: The ACS Table ID
</p>
</li>
<li> <p><code>geography</code>: The smallest geography at which a given table is available
for a given year
</p>
</li>
<li> <p><code>year</code>: The endyear of the 5-year ACS dataset
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>data(acs5_geography)
</code></pre>


<h3>Format</h3>

<p>An object of class <code>tbl_df</code> (inherits from <code>tbl</code>, <code>data.frame</code>) with 12228 rows and 3 columns.
</p>


<h3>Details</h3>

<p>Dataset used to identify geography availability in the 5-year ACS Detailed Tables
</p>
<p>Built-in dataset that includes information on the smallest geography at which
5-year ACS Detailed Tables data are available, by table, since 2011. This dataset
is used internally by <code>load_variables()</code> to add a <code>geography</code> column
when variables are retrieved for a 5-year ACS Detailed Tables dataset.
</p>

<hr>
<h2 id='as_dot_density'>Convert polygon geometry to dots for dot-density mapping</h2><span id='topic+as_dot_density'></span>

<h3>Description</h3>

<p>Dot-density maps are a compelling alternative to choropleth maps for cartographic visualization of demographic data as they allow for representation of the internal heterogeneity of geographic units.  This function helps users generate dots from an input polygon dataset intended for dot-density mapping.  Dots are placed randomly within polygons according to a given data:dots ratio; for example, a ratio of 100:1 for an input population value column will place approximately 1 dot in the polygon for every 100 people in the geographic unit.  Users can then map the dots using tools like <code>ggplot2::geom_sf()</code> or <code>tmap::tm_dots()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_dot_density(
  input_data,
  value,
  values_per_dot,
  group = NULL,
  erase_water = FALSE,
  area_threshold = NULL,
  water_year = 2020
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as_dot_density_+3A_input_data">input_data</code></td>
<td>
<p>An input sf object of geometry type <code>POLYGON</code> or <code>MULTIPOLYGON</code> that includes some information that can be converted to dots.  While the function is designed for use with data acquired with the tidycensus package, it will work for arbitrary polygon datasets.</p>
</td></tr>
<tr><td><code id="as_dot_density_+3A_value">value</code></td>
<td>
<p>The value column to be used to determine the number of dots to generate. For tidycensus users, this will typically be the <code>"value"</code> column for decennial Census data or the <code>"estimate"</code> column for American Community Survey estimates.</p>
</td></tr>
<tr><td><code id="as_dot_density_+3A_values_per_dot">values_per_dot</code></td>
<td>
<p>The number of values per dot; used to determine the output data:dots ratio. A value of 100 means that each dot will represent approximately 100 values in the value column.</p>
</td></tr>
<tr><td><code id="as_dot_density_+3A_group">group</code></td>
<td>
<p>A column in the dataset that identifies salient groups within which dots should be generated.  For a long-form tidycensus dataset, this will typically be the <code>"variable"</code> column or some derivative of it. The output dataset will be randomly shuffled to prevent &quot;stacking&quot; of groups in downstream dot-density maps.</p>
</td></tr>
<tr><td><code id="as_dot_density_+3A_erase_water">erase_water</code></td>
<td>
<p>If <code>TRUE</code>, calls <code>tigris::erase_water()</code> to remove water areas from the polygons prior to generating dots, allowing for dasymetric dot placement. This option is recommended if your location includes significant water area. If using this option, it is recommended that you first transform your data to a projected coordinate reference system using <code>sf::st_transform()</code> to improve performance. This argument only works for data in the United States.</p>
</td></tr>
<tr><td><code id="as_dot_density_+3A_area_threshold">area_threshold</code></td>
<td>
<p>The area percentile threshold to be used when erasing water; ranges from 0 (all water area included) to 1 (no water area included)</p>
</td></tr>
<tr><td><code id="as_dot_density_+3A_water_year">water_year</code></td>
<td>
<p>The year of the TIGER/Line water area shapefiles to use if erasing water. Defaults to 2020; ignore if not using the <code>erase_water</code> feature.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>as_dot_density()</code> uses <code>terra::dots()</code> internally for fast creation of dots. As terra is not a hard dependency of the tidycensus package, users must first install terra before using this function.
</p>
<p>The <code>erase_water</code> parameter will internally call <code>tigris::erase_water()</code> to fetch water area for a given location in the United States and remove that water area from the polygons before placing dots in polygons. This will slow down performance of the function, but can improve cartographic accuracy in locations with significant water area. It is recommended that users transform their data into a projected coordinate reference system with <code>sf::st_transform()</code> prior to using this option in order to improve performance.
</p>


<h3>Value</h3>

<p>The original dataset but of geometry type <code>POINT</code>, with the number of point features corresponding to the given value:dot ratio for a given group.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

library(tidycensus)
library(ggplot2)

# Identify variables for mapping
race_vars &lt;- c(
  Hispanic = "P2_002N",
  White = "P2_005N",
  Black = "P2_006N",
  Asian = "P2_008N"
)

# Get data from tidycensus
baltimore_race &lt;- get_decennial(
  geography = "tract",
  variables = race_vars,
  state = "MD",
  county = "Baltimore city",
  geometry = TRUE,
  year = 2020
)

# Convert data to dots
baltimore_dots &lt;- as_dot_density(
  baltimore_race,
  value = "value",
  values_per_dot = 100,
  group = "variable"
)

# Use one set of polygon geometries as a base layer
baltimore_base &lt;- baltimore_race[baltimore_race$variable == "Hispanic", ]

# Map with ggplot2
ggplot() +
  geom_sf(data = baltimore_base,
          fill = "white",
          color = "grey") +
  geom_sf(data = baltimore_dots,
          aes(color = variable),
          size = 0.01) +
  theme_void()


## End(Not run)
</code></pre>

<hr>
<h2 id='census_api_key'>Install a CENSUS API Key in Your <code>.Renviron</code> File for Repeated Use</h2><span id='topic+census_api_key'></span>

<h3>Description</h3>

<p>This function will add your CENSUS API key to your <code>.Renviron</code> file so it can be called securely without being stored
in your code. After you have installed your key, it can be called any time by typing <code>Sys.getenv("CENSUS_API_KEY")</code> and can be
used in package functions by simply typing CENSUS_API_KEY If you do not have an <code>.Renviron</code> file, the function will create on for you.
If you already have an <code>.Renviron</code> file, the function will append the key to your existing file, while making a backup of your
original file for disaster recovery purposes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>census_api_key(key, overwrite = FALSE, install = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="census_api_key_+3A_key">key</code></td>
<td>
<p>The API key provided to you from the Census formated in quotes. A key can be acquired at <a href="http://api.census.gov/data/key_signup.html">http://api.census.gov/data/key_signup.html</a></p>
</td></tr>
<tr><td><code id="census_api_key_+3A_overwrite">overwrite</code></td>
<td>
<p>If this is set to TRUE, it will overwrite an existing CENSUS_API_KEY that you already have in your <code>.Renviron</code> file.</p>
</td></tr>
<tr><td><code id="census_api_key_+3A_install">install</code></td>
<td>
<p>if TRUE, will install the key in your <code>.Renviron</code> file for use in future sessions.  Defaults to FALSE.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
census_api_key("111111abc", install = TRUE)
# First time, reload your environment so you can use the key without restarting R.
readRenviron("~/.Renviron")
# You can check it with:
Sys.getenv("CENSUS_API_KEY")

## End(Not run)

## Not run: 
# If you need to overwrite an existing key:
census_api_key("111111abc", overwrite = TRUE, install = TRUE)
# First time, relead your environment so you can use the key without restarting R.
readRenviron("~/.Renviron")
# You can check it with:
Sys.getenv("CENSUS_API_KEY")

## End(Not run)
</code></pre>

<hr>
<h2 id='check_ddhca_groups'>Check to see if a given geography / population group combination is available in the Detailed DHC-A file.</h2><span id='topic+check_ddhca_groups'></span>

<h3>Description</h3>

<p>Check to see if a given geography / population group combination is available in the Detailed DHC-A file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_ddhca_groups(geography, pop_group, state = NULL, county = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_ddhca_groups_+3A_geography">geography</code></td>
<td>
<p>The requested geography.</p>
</td></tr>
<tr><td><code id="check_ddhca_groups_+3A_pop_group">pop_group</code></td>
<td>
<p>The code representing the population group you'd like to check.</p>
</td></tr>
<tr><td><code id="check_ddhca_groups_+3A_state">state</code></td>
<td>
<p>The state (optional)</p>
</td></tr>
<tr><td><code id="check_ddhca_groups_+3A_county">county</code></td>
<td>
<p>The county (optional)</p>
</td></tr>
</table>

<hr>
<h2 id='county_laea'>County geometry with Alaska and Hawaii shifted and re-scaled</h2><span id='topic+county_laea'></span>

<h3>Description</h3>

<p>Built-in dataset for use with <code>shift_geo = TRUE</code>
</p>
<p>Dataset of US counties with Alaska and Hawaii shifted and re-scaled
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(county_laea)

data(county_laea)
</code></pre>


<h3>Format</h3>

<p>An object of class <code>sf</code> (inherits from <code>data.frame</code>) with 3143 rows and 2 columns.
</p>


<h3>Details</h3>

<p>Dataset with county geometry for use when shifting Alaska and Hawaii
</p>
<p>Built-in dataset for use with the <code>shift_geo</code> parameter, with the continental United States in a
Lambert azimuthal equal area projection and Alaska and Hawaii counties and Census areas shifted and re-scaled.
The data were originally obtained from the albersusa R package (<a href="https://github.com/hrbrmstr/albersusa">https://github.com/hrbrmstr/albersusa</a>).
</p>

<hr>
<h2 id='fips_codes'>Dataset with FIPS codes for US states and counties</h2><span id='topic+fips_codes'></span>

<h3>Description</h3>

<p>Built-in dataset for smart state and county lookup.
To access the data directly, issue the command <code>data(fips_codes)</code>.
</p>

<ul>
<li> <p><code>county</code>: County name, title-case
</p>
</li>
<li> <p><code>county_code</code>: County code. (3-digit, 0-padded, character)
</p>
</li>
<li> <p><code>state</code>: Upper-case abbreviation of state
</p>
</li>
<li> <p><code>state_code</code>: State FIPS code (2-digit, 0-padded, character)
</p>
</li>
<li> <p><code>state_name</code>: Title-case name of state
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>data(fips_codes)
</code></pre>


<h3>Format</h3>

<p>An object of class <code>data.frame</code> with 3256 rows and 5 columns.
</p>


<h3>Details</h3>

<p>Dataset with FIPS codes for US states and counties
</p>
<p>Built-in dataset for use with the <code>lookup_code</code> function.
To access the data directly, issue the command <code>data(fips_codes)</code>.
</p>
<p>Note: this dataset includes FIPS codes for all counties that have appeared in
the decennial Census or American Community Survey from 2010 to the present.
This means that counties that have been renamed or absorbed into other
geographic entities since 2010 remain in this dataset along with newly added
or renamed counties.
</p>
<p>If you need the FIPS codes and names for counties for a particular Census
year, you can use the <a href="tigris.html#topic+counties">counties</a> function from the tigris
package and set the year parameter as required.
</p>

<hr>
<h2 id='get_acs'>Obtain data and feature geometry for the American Community Survey</h2><span id='topic+get_acs'></span>

<h3>Description</h3>

<p>Obtain data and feature geometry for the American Community Survey
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_acs(
  geography,
  variables = NULL,
  table = NULL,
  cache_table = FALSE,
  year = 2022,
  output = "tidy",
  state = NULL,
  county = NULL,
  zcta = NULL,
  geometry = FALSE,
  keep_geo_vars = FALSE,
  shift_geo = FALSE,
  summary_var = NULL,
  key = NULL,
  moe_level = 90,
  survey = "acs5",
  show_call = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_acs_+3A_geography">geography</code></td>
<td>
<p>The geography of your data.</p>
</td></tr>
<tr><td><code id="get_acs_+3A_variables">variables</code></td>
<td>
<p>Character string or vector of character strings of variable
IDs. tidycensus automatically returns the estimate and the margin of error
associated with the variable.</p>
</td></tr>
<tr><td><code id="get_acs_+3A_table">table</code></td>
<td>
<p>The ACS table for which you would like to request all
variables. Uses lookup tables to identify the variables; performs faster
when variable table already exists through <code>load_variables(cache =
TRUE)</code>. Only one table may be requested per call.</p>
</td></tr>
<tr><td><code id="get_acs_+3A_cache_table">cache_table</code></td>
<td>
<p>Whether or not to cache table names for faster future
access. Defaults to FALSE; if TRUE, only needs to be called once per
dataset.  If variables dataset is already cached via the
<code>load_variables</code> function, this can be bypassed.</p>
</td></tr>
<tr><td><code id="get_acs_+3A_year">year</code></td>
<td>
<p>The year, or endyear, of the ACS sample. 5-year ACS data is
available from 2009 through 2022; 1-year ACS data is available from 2005
through 2022, with the exception of 2020.  Defaults to 2022.</p>
</td></tr>
<tr><td><code id="get_acs_+3A_output">output</code></td>
<td>
<p>One of &quot;tidy&quot; (the default) in which each row represents an
enumeration unit-variable combination, or &quot;wide&quot; in which each row
represents an enumeration unit and the variables are in the columns.</p>
</td></tr>
<tr><td><code id="get_acs_+3A_state">state</code></td>
<td>
<p>An optional vector of states for which you are requesting data.
State names, postal codes, and FIPS codes are accepted. Defaults to NULL.</p>
</td></tr>
<tr><td><code id="get_acs_+3A_county">county</code></td>
<td>
<p>The county for which you are requesting data. County names and
FIPS codes are accepted. Must be combined with a value supplied to 'state'.
Defaults to NULL.</p>
</td></tr>
<tr><td><code id="get_acs_+3A_zcta">zcta</code></td>
<td>
<p>The zip code tabulation area(s) for which you are requesting
data. Specify a single value or a vector of values to get data for more
than one ZCTA. Numeric or character ZCTA GEOIDs are accepted. When
specifying ZCTAs, geography must be set to '&quot;zcta&quot;' and 'state' must be specified with
'county' left as 'NULL'. Defaults to NULL.</p>
</td></tr>
<tr><td><code id="get_acs_+3A_geometry">geometry</code></td>
<td>
<p>if FALSE (the default), return a regular tibble of ACS data.
if TRUE, uses the tigris package to return an sf tibble with simple feature
geometry in the 'geometry' column.</p>
</td></tr>
<tr><td><code id="get_acs_+3A_keep_geo_vars">keep_geo_vars</code></td>
<td>
<p>if TRUE, keeps all the variables from the Census
shapefile obtained by tigris.  Defaults to FALSE.</p>
</td></tr>
<tr><td><code id="get_acs_+3A_shift_geo">shift_geo</code></td>
<td>
<p>(deprecated) if TRUE, returns geometry with Alaska and Hawaii shifted for
thematic mapping of the entire US. Geometry was originally obtained from
the albersusa R package. As of May 2021, we recommend using <code>tigris::shift_geometry()</code>
instead.</p>
</td></tr>
<tr><td><code id="get_acs_+3A_summary_var">summary_var</code></td>
<td>
<p>Character string of a &quot;summary variable&quot; from the ACS to
be included in your output. Usually a variable (e.g. total population) that
you'll want to use as a denominator or comparison.</p>
</td></tr>
<tr><td><code id="get_acs_+3A_key">key</code></td>
<td>
<p>Your Census API key. Obtain one at
<a href="https://api.census.gov/data/key_signup.html">https://api.census.gov/data/key_signup.html</a></p>
</td></tr>
<tr><td><code id="get_acs_+3A_moe_level">moe_level</code></td>
<td>
<p>The confidence level of the returned margin of error.  One
of 90 (the default), 95, or 99.</p>
</td></tr>
<tr><td><code id="get_acs_+3A_survey">survey</code></td>
<td>
<p>The ACS contains one-year, three-year, and five-year surveys
expressed as &quot;acs1&quot;, &quot;acs3&quot;, and &quot;acs5&quot;. The default selection is &quot;acs5.&quot;</p>
</td></tr>
<tr><td><code id="get_acs_+3A_show_call">show_call</code></td>
<td>
<p>if TRUE, display call made to Census API. This can be very
useful in debugging and determining if error messages returned are due to
tidycensus or the Census API. Copy to the API call into a browser and see
what is returned by the API directly. Defaults to FALSE.</p>
</td></tr>
<tr><td><code id="get_acs_+3A_...">...</code></td>
<td>
<p>Other keyword arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tibble or sf tibble of ACS data
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(tidycensus)
library(tidyverse)
library(viridis)
census_api_key("YOUR KEY GOES HERE")

tarr &lt;- get_acs(geography = "tract", variables = "B19013_001",
                state = "TX", county = "Tarrant", geometry = TRUE, year = 2020)

ggplot(tarr, aes(fill = estimate, color = estimate)) +
  geom_sf() +
  coord_sf(crs = 26914) +
  scale_fill_viridis(option = "magma") +
  scale_color_viridis(option = "magma")


vt &lt;- get_acs(geography = "county", variables = "B19013_001", state = "VT", year = 2019)

vt %&gt;%
mutate(NAME = gsub(" County, Vermont", "", NAME)) %&gt;%
 ggplot(aes(x = estimate, y = reorder(NAME, estimate))) +
  geom_errorbar(aes(xmin = estimate - moe, xmax = estimate + moe), width = 0.3, size = 0.5) +
  geom_point(color = "red", size = 3) +
  labs(title = "Household income by county in Vermont",
       subtitle = "2015-2019 American Community Survey",
       y = "",
       x = "ACS estimate (bars represent margin of error)")


## End(Not run)
</code></pre>

<hr>
<h2 id='get_decennial'>Obtain data and feature geometry for the decennial US Census</h2><span id='topic+get_decennial'></span>

<h3>Description</h3>

<p>Obtain data and feature geometry for the decennial US Census
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_decennial(
  geography,
  variables = NULL,
  table = NULL,
  cache_table = FALSE,
  year = 2020,
  sumfile = NULL,
  state = NULL,
  county = NULL,
  geometry = FALSE,
  output = "tidy",
  keep_geo_vars = FALSE,
  shift_geo = FALSE,
  summary_var = NULL,
  pop_group = NULL,
  pop_group_label = FALSE,
  key = NULL,
  show_call = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_decennial_+3A_geography">geography</code></td>
<td>
<p>The geography of your data.</p>
</td></tr>
<tr><td><code id="get_decennial_+3A_variables">variables</code></td>
<td>
<p>Character string or vector of character strings of variable
IDs.</p>
</td></tr>
<tr><td><code id="get_decennial_+3A_table">table</code></td>
<td>
<p>The Census table for which you would like to request all variables. Uses
lookup tables to identify the variables; performs faster when variable
table already exists through <code>load_variables(cache = TRUE)</code>.
Only one table may be requested per call.</p>
</td></tr>
<tr><td><code id="get_decennial_+3A_cache_table">cache_table</code></td>
<td>
<p>Whether or not to cache table names for faster future access.
Defaults to FALSE; if TRUE, only needs to be called once per
dataset.  If variables dataset is already cached via the
<code>load_variables</code> function, this can be bypassed.</p>
</td></tr>
<tr><td><code id="get_decennial_+3A_year">year</code></td>
<td>
<p>The year for which you are requesting data. Defaults to 2020; 2000,
2010, and 2020 are available.</p>
</td></tr>
<tr><td><code id="get_decennial_+3A_sumfile">sumfile</code></td>
<td>
<p>The Census summary file; if <code>NULL</code>, defaults to <code>"pl"</code> when the year is 2020 and <code>"sf1"</code> for 2000 and 2010.  Not all summary files are available for each decennial Census year.  Make sure you are using the correct summary file for your requested variables, as variable IDs may be repeated across summary files and represent different topics.</p>
</td></tr>
<tr><td><code id="get_decennial_+3A_state">state</code></td>
<td>
<p>The state for which you are requesting data. State
names, postal codes, and FIPS codes are accepted.
Defaults to NULL.</p>
</td></tr>
<tr><td><code id="get_decennial_+3A_county">county</code></td>
<td>
<p>The county for which you are requesting data. County names and
FIPS codes are accepted. Must be combined with a value supplied
to 'state'.  Defaults to NULL.</p>
</td></tr>
<tr><td><code id="get_decennial_+3A_geometry">geometry</code></td>
<td>
<p>if FALSE (the default), return a regular tibble of ACS data.
if TRUE, uses the tigris package to return an sf tibble
with simple feature geometry in the 'geometry' column.</p>
</td></tr>
<tr><td><code id="get_decennial_+3A_output">output</code></td>
<td>
<p>One of &quot;tidy&quot; (the default) in which each row represents an
enumeration unit-variable combination, or &quot;wide&quot; in which each
row represents an enumeration unit and the variables are in the
columns.</p>
</td></tr>
<tr><td><code id="get_decennial_+3A_keep_geo_vars">keep_geo_vars</code></td>
<td>
<p>if TRUE, keeps all the variables from the Census
shapefile obtained by tigris.  Defaults to FALSE.</p>
</td></tr>
<tr><td><code id="get_decennial_+3A_shift_geo">shift_geo</code></td>
<td>
<p>(deprecated) if TRUE, returns geometry with Alaska and Hawaii
shifted for thematic mapping of the entire US.
Geometry was originally obtained from the albersusa R package.  As of May 2021,
we recommend using <code>tigris::shift_geometry()</code> instead.</p>
</td></tr>
<tr><td><code id="get_decennial_+3A_summary_var">summary_var</code></td>
<td>
<p>Character string of a &quot;summary variable&quot; from the decennial Census
to be included in your output. Usually a variable (e.g. total population)
that you'll want to use as a denominator or comparison.</p>
</td></tr>
<tr><td><code id="get_decennial_+3A_pop_group">pop_group</code></td>
<td>
<p>The population group code for which you'd like to request data.  Applies to summary files for which population group breakdowns are available like the Detailed DHC-A file.</p>
</td></tr>
<tr><td><code id="get_decennial_+3A_pop_group_label">pop_group_label</code></td>
<td>
<p>If <code>TRUE</code>, return a <code>"pop_group_label"</code> column that contains the label for the population group.  Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="get_decennial_+3A_key">key</code></td>
<td>
<p>Your Census API key.
Obtain one at <a href="https://api.census.gov/data/key_signup.html">https://api.census.gov/data/key_signup.html</a></p>
</td></tr>
<tr><td><code id="get_decennial_+3A_show_call">show_call</code></td>
<td>
<p>if TRUE, display call made to Census API. This can be very useful
in debugging and determining if error messages returned are
due to tidycensus or the Census API. Copy to the API call into
a browser and see what is returned by the API directly. Defaults to FALSE.</p>
</td></tr>
<tr><td><code id="get_decennial_+3A_...">...</code></td>
<td>
<p>Other keyword arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a tibble or sf tibble of decennial Census data
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Plot of race/ethnicity by county in Illinois for 2010
library(tidycensus)
library(tidyverse)
library(viridis)
census_api_key("YOUR KEY GOES HERE")
vars10 &lt;- c("P005003", "P005004", "P005006", "P004003")

il &lt;- get_decennial(geography = "county", variables = vars10, year = 2010,
                    summary_var = "P001001", state = "IL", geometry = TRUE) %&gt;%
  mutate(pct = 100 * (value / summary_value))

ggplot(il, aes(fill = pct, color = pct)) +
  geom_sf() +
  facet_wrap(~variable)



## End(Not run)
</code></pre>

<hr>
<h2 id='get_estimates'>Get data from the US Census Bureau Population Estimates Program</h2><span id='topic+get_estimates'></span>

<h3>Description</h3>

<p>The <code>get_estimates()</code> function requests data from the US Census Bureau's Population Estimates Program (PEP) datasets.  The PEP datasets are defined by the US Census Bureau as follows: &quot;The Census Bureau's Population Estimates Program (PEP) produces estimates of the population for the United States, its states, counties, cities, and towns, as well as for the Commonwealth of Puerto Rico and its municipios. Demographic components of population change (births, deaths, and migration) are produced at the national, state, and county levels of geography. Additionally, housing unit estimates are produced for the nation, states, and counties.  PEP annually utilizes current data on births, deaths, and migration to calculate population change since the most recent decennial census and produce a time series of estimates of population, demographic components of change, and housing units. The annual time series of estimates begins with the most recent decennial census data and extends to the vintage year. As each vintage of estimates includes all years since the most recent decennial census, the latest vintage of data available supersedes all previously-produced estimates for those dates.&quot;
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_estimates(
  geography = c("us", "region", "division", "state", "county", "county subdivision",
    "place/balance (or part)", "place", "consolidated city", "place (or part)",
    "metropolitan statistical area/micropolitan statistical area", "cbsa",
    "metropolitan division", "combined statistical area"),
  product = NULL,
  variables = NULL,
  breakdown = NULL,
  breakdown_labels = FALSE,
  vintage = 2022,
  year = vintage,
  state = NULL,
  county = NULL,
  time_series = FALSE,
  output = "tidy",
  geometry = FALSE,
  keep_geo_vars = FALSE,
  shift_geo = FALSE,
  key = NULL,
  show_call = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_estimates_+3A_geography">geography</code></td>
<td>
<p>The geography of your data. Available geographies for the most recent data vintage are listed
<a href="https://api.census.gov/data/2019/pep/population/geography.html">here</a>. <code>"cbsa"</code> may
be used an alias for <code>"metropolitan statistical area/micropolitan statistical area"</code>.</p>
</td></tr>
<tr><td><code id="get_estimates_+3A_product">product</code></td>
<td>
<p>The data product (optional). <code>"population"</code>, <code>"components"</code>
<code>"housing"</code>, and <code>"characteristics"</code> are supported.
</p>
<p>For 2020 and later, the only supported product is <code>"characteristics"</code>.</p>
</td></tr>
<tr><td><code id="get_estimates_+3A_variables">variables</code></td>
<td>
<p>A character string or vector of character strings of requested variables.  For years 2020 and later, use <code>variables = "all"</code> to request all available variables.</p>
</td></tr>
<tr><td><code id="get_estimates_+3A_breakdown">breakdown</code></td>
<td>
<p>The population breakdown used when <code>product = "characteristics"</code>.
Acceptable values are <code>"AGEGROUP"</code>, <code>"RACE"</code>, <code>"SEX"</code>, and
<code>"HISP"</code>, for Hispanic/Not Hispanic.  These values can be combined in
a vector, returning population estimates in the <code>value</code> column for all
combinations of these breakdowns.  For years 2020 and later, <code>"AGE"</code> is also available for single-year age when using <code>geography = "state"</code>.</p>
</td></tr>
<tr><td><code id="get_estimates_+3A_breakdown_labels">breakdown_labels</code></td>
<td>
<p>Whether or not to label breakdown elements returned when
<code>product = "characteristics"</code>. Defaults to FALSE.</p>
</td></tr>
<tr><td><code id="get_estimates_+3A_vintage">vintage</code></td>
<td>
<p>It is recommended to use the most recent vintage
available for a given decennial series (so, year = 2019 for the 2010s, and year = 2023 for the 2020s).  Will default to 2022 until the full PEP for 2023 is released.</p>
</td></tr>
<tr><td><code id="get_estimates_+3A_year">year</code></td>
<td>
<p>The data year (defaults to the vintage requested). Use <code>time_series = TRUE</code> to access time-series estimates.</p>
</td></tr>
<tr><td><code id="get_estimates_+3A_state">state</code></td>
<td>
<p>The state for which you are requesting data. State
names, postal codes, and FIPS codes are accepted.
Defaults to NULL.</p>
</td></tr>
<tr><td><code id="get_estimates_+3A_county">county</code></td>
<td>
<p>The county for which you are requesting data. County names and
FIPS codes are accepted. Must be combined with a value supplied
to 'state'.  Defaults to NULL.</p>
</td></tr>
<tr><td><code id="get_estimates_+3A_time_series">time_series</code></td>
<td>
<p>If <code>TRUE</code>, the function will return a time series of observations back to the decennial Census
of 2010. The returned column is either &quot;DATE&quot;, representing a particular estimate date, or &quot;PERIOD&quot;,
representing a time period (e.g. births between 2016 and 2017), and contains integers representing
those values.  Integer to date or period mapping is available at
<a href="https://www.census.gov/data/developers/data-sets/popest-popproj/popest/popest-vars/2019.html">https://www.census.gov/data/developers/data-sets/popest-popproj/popest/popest-vars/2019.html</a>.</p>
</td></tr>
<tr><td><code id="get_estimates_+3A_output">output</code></td>
<td>
<p>One of &quot;tidy&quot; (the default) in which each row represents an
enumeration unit-variable combination, or &quot;wide&quot; in which each
row represents an enumeration unit and the variables are in the
columns.</p>
</td></tr>
<tr><td><code id="get_estimates_+3A_geometry">geometry</code></td>
<td>
<p>if FALSE (the default), return a regular tibble of ACS data.
if TRUE, uses the tigris package to return an sf tibble
with simple feature geometry in the 'geometry' column.</p>
</td></tr>
<tr><td><code id="get_estimates_+3A_keep_geo_vars">keep_geo_vars</code></td>
<td>
<p>if TRUE, keeps all the variables from the Census
shapefile obtained by tigris.  Defaults to FALSE.</p>
</td></tr>
<tr><td><code id="get_estimates_+3A_shift_geo">shift_geo</code></td>
<td>
<p>(deprecated) if TRUE, returns geometry with Alaska and Hawaii shifted for thematic
mapping of the entire US.  As of May 2021, we recommend using <code>tigris::shift_geometry()</code>
instead.</p>
</td></tr>
<tr><td><code id="get_estimates_+3A_key">key</code></td>
<td>
<p>Your Census API key.
Obtain one at <a href="https://api.census.gov/data/key_signup.html">https://api.census.gov/data/key_signup.html</a>.  Can be stored
in your .Renviron with <code>census_api_key("YOUR KEY", install = TRUE)</code></p>
</td></tr>
<tr><td><code id="get_estimates_+3A_show_call">show_call</code></td>
<td>
<p>if TRUE, display call made to Census API. This can be very useful
in debugging and determining if error messages returned are
due to tidycensus or the Census API. Copy to the API call into
a browser and see what is returned by the API directly. Defaults to FALSE.</p>
</td></tr>
<tr><td><code id="get_estimates_+3A_...">...</code></td>
<td>
<p>other keyword arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>get_estimates()</code> requests data from the Population Estimates API for years 2019 and earlier; however the Population Estimates are no longer supported on the API as of 2020.  For recent years, <code>get_estimates()</code> reads a flat file from the Census website and parses it.  This means that arguments and output for 2020 and later datasets may differ slightly from datasets acquired for 2019 and earlier.
</p>
<p>As of April 2022, variables available for 2020 and later datasets are as follows: ESTIMATESBASE, POPESTIMATE, NPOPCHG, BIRTHS, DEATHS, NATURALCHG, INTERNATIONALMIG, DOMESTICMIG, NETMIG, RESIDUAL, GQESTIMATESBASE, GQESTIMATES, RBIRTH, RDEATH, RNATURALCHG, RINTERNATIONALMIG, RDOMESTICMIG, and RNETMIG.
</p>


<h3>Value</h3>

<p>A tibble, or sf tibble, of population estimates data
</p>


<h3>See Also</h3>

<p><a href="https://www.census.gov/programs-surveys/popest/about.html">https://www.census.gov/programs-surveys/popest/about.html</a>
</p>

<hr>
<h2 id='get_flows'>Obtain data and feature geometry for American Community Survey Migration
Flows</h2><span id='topic+get_flows'></span>

<h3>Description</h3>

<p>Obtain data and feature geometry for American Community Survey Migration
Flows
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_flows(
  geography,
  variables = NULL,
  breakdown = NULL,
  breakdown_labels = FALSE,
  year = 2018,
  output = "tidy",
  state = NULL,
  county = NULL,
  msa = NULL,
  geometry = FALSE,
  key = NULL,
  moe_level = 90,
  show_call = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_flows_+3A_geography">geography</code></td>
<td>
<p>The geography of your requested data. Possible values are
<code>"county"</code>, <code>"county subdivision"</code>, and <code>"metropolitan statistical area"</code>.
MSA data is only available beginning with the 2009-2013 5-year ACS.</p>
</td></tr>
<tr><td><code id="get_flows_+3A_variables">variables</code></td>
<td>
<p>Character string or vector of character strings of variable
names. By default, <code>get_flows()</code> returns the GEOID and names of the
geographies as well as the number of people who moved in, out, and net
movers of each geography (<code>"MOVEDIN"</code>, <code>"MOVEDOUT"</code>, <code>"MOVEDNET"</code>). If additional
variables are specified, they are pulled in addition to the default
variables. The names of additional variables can be found in the Census
Migration Flows API
documentation at <a href="https://api.census.gov/data/2018/acs/flows/variables.html">https://api.census.gov/data/2018/acs/flows/variables.html</a>.</p>
</td></tr>
<tr><td><code id="get_flows_+3A_breakdown">breakdown</code></td>
<td>
<p>A character vector of the population breakdown
characteristics to be crossed with migration flows data. For datasets
between 2006-2010 and 2011-2015, selected demographic characteristics such
as age, race, employment status, etc. are available. Possible values are
&quot;AGE&quot;, &quot;SEX&quot;, &quot;RACE&quot;, &quot;HSGP&quot;, &quot;REL&quot;, &quot;HHT&quot;, &quot;TEN&quot;, &quot;ENG&quot;,
&quot;POB&quot;, &quot;YEARS&quot;, &quot;ESR&quot;, &quot;OCC&quot;, &quot;WKS&quot;, &quot;SCHL&quot;, &quot;AHINC&quot;,
&quot;APINC&quot;, and &quot;HISP_ORIGIN&quot;. For more information and to see which
characteristics are available in each year, visit the Census Migration
Flows
documentation at <a href="https://www.census.gov/data/developers/data-sets/acs-migration-flows.html">https://www.census.gov/data/developers/data-sets/acs-migration-flows.html</a>.
Note: not all characteristics are available in all years.</p>
</td></tr>
<tr><td><code id="get_flows_+3A_breakdown_labels">breakdown_labels</code></td>
<td>
<p>Whether or not to add columns with labels for the
breakdown characteristic codes. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="get_flows_+3A_year">year</code></td>
<td>
<p>The year, or endyear, of the ACS sample. The Migration Flows API
is available for 5-year ACS samples from 2010 to 2018. Defaults to 2018.</p>
</td></tr>
<tr><td><code id="get_flows_+3A_output">output</code></td>
<td>
<p>One of &quot;tidy&quot; (the default) in which each row represents an
enumeration unit-variable combination, or &quot;wide&quot; in which each row
represents an enumeration unit and the variables are in the columns.</p>
</td></tr>
<tr><td><code id="get_flows_+3A_state">state</code></td>
<td>
<p>An optional vector of states for which you are requesting data.
State names, postal codes, and FIPS codes are accepted. When requesting
county subdivision data, you must specify at least one state.</p>
</td></tr>
<tr><td><code id="get_flows_+3A_county">county</code></td>
<td>
<p>The county for which you are requesting data. County names and
FIPS codes are accepted. Must be combined with a value supplied to 'state'.</p>
</td></tr>
<tr><td><code id="get_flows_+3A_msa">msa</code></td>
<td>
<p>The metropolitan statistical area for which you are requesting
data. Specify a single value or a vector of values to get data for more
than one MSA. Numeric or character MSA GEOIDs are accepted. When specifying
MSAs, geography must be set to <code>"metropolitan statistical area"</code> and
<code>state</code> and <code>county</code> must be <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="get_flows_+3A_geometry">geometry</code></td>
<td>
<p>if FALSE (the default), return a tibble of ACS Migration
Flows data. If TRUE, return an sf object with the centroids of both origin
and destination as <code>sfc_POINT</code> columns. The origin point feature is
returned in a column named <code>centroid1</code> and is the active geometry column in
the sf object. The destination point feature is returned in the <code>centroid2</code>
column.</p>
</td></tr>
<tr><td><code id="get_flows_+3A_key">key</code></td>
<td>
<p>Your Census API key. Obtain one at
<a href="https://api.census.gov/data/key_signup.html">https://api.census.gov/data/key_signup.html</a></p>
</td></tr>
<tr><td><code id="get_flows_+3A_moe_level">moe_level</code></td>
<td>
<p>The confidence level of the returned margin of error.  One
of 90 (the default), 95, or 99.</p>
</td></tr>
<tr><td><code id="get_flows_+3A_show_call">show_call</code></td>
<td>
<p>if TRUE, display call made to Census API. This can be very
useful in debugging and determining if error messages returned are due to
tidycensus or the Census API. Copy to the API call into a browser and see
what is returned by the API directly. Defaults to FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tibble or sf tibble of ACS Migration Flows data
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
get_flows(
  geography = "county",
  state = "VT",
  county = c("Washington", "Chittenden")
  )

get_flows(
  geography = "county subdivision",
  breakdown = "RACE",
  breakdown_labels = TRUE,
  state = "NY",
  county = "Westchester",
  output = "wide",
  year = 2015
  )

get_flows(
   geography = "metropolitan statistical area",
   variables = c("POP1YR", "POP1YRAGO"),
   geometry = TRUE,
   output = "wide",
   show_call = TRUE
  )

## End(Not run)
</code></pre>

<hr>
<h2 id='get_pop_groups'>Get available population groups for a given Decennial Census year and summary file</h2><span id='topic+get_pop_groups'></span>

<h3>Description</h3>

<p>Get available population groups for a given Decennial Census year and summary file
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_pop_groups(year, sumfile)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_pop_groups_+3A_year">year</code></td>
<td>
<p>The decennial Census year; one of 2000, 2010, or 2020.</p>
</td></tr>
<tr><td><code id="get_pop_groups_+3A_sumfile">sumfile</code></td>
<td>
<p>The summary file.  Available summary files are <code>"ddhca"</code>, <code>"sf2"</code>, and <code>"sf4"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tibble containing codes (to be used with the <code>pop_group</code> argument of <code>get_decennial()</code>) and descriptive names.
</p>

<hr>
<h2 id='get_pums'>Load data from the American Community Survey Public Use Microdata Series API</h2><span id='topic+get_pums'></span>

<h3>Description</h3>

<p>Load data from the American Community Survey Public Use Microdata Series API
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_pums(
  variables = NULL,
  state = NULL,
  puma = NULL,
  year = 2022,
  survey = "acs5",
  variables_filter = NULL,
  rep_weights = NULL,
  recode = FALSE,
  return_vacant = FALSE,
  show_call = FALSE,
  key = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_pums_+3A_variables">variables</code></td>
<td>
<p>A vector of variables from the PUMS API.
Use <code>View(pums_variables)</code> to browse variable options.</p>
</td></tr>
<tr><td><code id="get_pums_+3A_state">state</code></td>
<td>
<p>A state, or vector of states, for which you would like to
request data.  The entire US can be requested with <code>state = "all"</code> - though be patient with the data download!</p>
</td></tr>
<tr><td><code id="get_pums_+3A_puma">puma</code></td>
<td>
<p>A vector of PUMAs from a single state, for which you would like
to request data. To get data from PUMAs in more than one state, specify a
named vector of state/PUMA pairs and set <code>state = "multiple"</code>.</p>
</td></tr>
<tr><td><code id="get_pums_+3A_year">year</code></td>
<td>
<p>The data year of the 1-year ACS sample or the endyear of the
5-year sample. Defaults to 2022. Please note that 1-year data for 2020 is not available
in tidycensus, so users requesting 1-year data should supply a different year.</p>
</td></tr>
<tr><td><code id="get_pums_+3A_survey">survey</code></td>
<td>
<p>The ACS survey; one of either <code>"acs1"</code> or <code>"acs5"</code>
(the default).</p>
</td></tr>
<tr><td><code id="get_pums_+3A_variables_filter">variables_filter</code></td>
<td>
<p>A named list of filters you'd like to return from the
PUMS API.  For example, passing <code>list(AGE = 25:50, SEX = 1)</code> will return
only males aged 25 to 50 in your output dataset.  Defaults to <code>NULL</code>,
which returns all records. If a housing-only dataset is required,
use <code>list(SPORDER = 1)</code> to only return householder records (taking care
in your analysis to use the household weight <code>WGTP</code>).</p>
</td></tr>
<tr><td><code id="get_pums_+3A_rep_weights">rep_weights</code></td>
<td>
<p>Whether or not to return housing unit, person, or both
housing and person-level replicate weights for calculation of standard
errors; one of <code>"person"</code>, <code>"housing"</code>, or <code>"both"</code>.</p>
</td></tr>
<tr><td><code id="get_pums_+3A_recode">recode</code></td>
<td>
<p>If TRUE, recodes variable values using Census data dictionary
and creates a new <code>*_label</code> column for each variable that is recoded.
Available for 2017 - 2022 data. Defaults to FALSE.</p>
</td></tr>
<tr><td><code id="get_pums_+3A_return_vacant">return_vacant</code></td>
<td>
<p>If TRUE, makes a separate request to the Census API to
retrieve microdata for vacant housing units, which are handled differently
in the API as they do not have person-level characteristics.  All person-level
columns in the returned dataset will be populated with NA for vacant housing units.
Defaults to FALSE.</p>
</td></tr>
<tr><td><code id="get_pums_+3A_show_call">show_call</code></td>
<td>
<p>If TRUE, display call made to Census API. This can be very
useful in debugging and determining if error messages returned are due to
tidycensus or the Census API. Copy to the API call into a browser and see
what is returned by the API directly. Defaults to FALSE.</p>
</td></tr>
<tr><td><code id="get_pums_+3A_key">key</code></td>
<td>
<p>Your Census API key. Obtain one at
<a href="https://api.census.gov/data/key_signup.html">https://api.census.gov/data/key_signup.html</a></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tibble of microdata from the ACS PUMS API.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
get_pums(variables = "AGEP", state = "VT")
get_pums(variables = "AGEP", state = "multiple", puma = c("UT" = 35008, "NV" = 00403))
get_pums(variables = c("AGEP", "ANC1P"), state = "VT", recode = TRUE)
get_pums(variables = "AGEP", state = "VT", survey = "acs1", rep_weights = "person")

## End(Not run)

</code></pre>

<hr>
<h2 id='interpolate_pw'>Use population-weighted interpolation to transfer information from one set of shapes to another</h2><span id='topic+interpolate_pw'></span>

<h3>Description</h3>

<p>A common use-case when working with time-series small-area Census data is to transfer data from one set of shapes (e.g. 2010 Census tracts) to another set of shapes (e.g. 2020 Census tracts). Population-weighted interpolation is one such solution to this problem that takes into account the distribution of the population within a Census unit to intelligently transfer data between incongruent units.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>interpolate_pw(
  from,
  to,
  to_id = NULL,
  extensive,
  weights,
  weight_column = NULL,
  weight_placement = c("surface", "centroid"),
  crs = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="interpolate_pw_+3A_from">from</code></td>
<td>
<p>The spatial dataset from which numeric attributes will be interpolated to target zones. By default, all numeric columns in this dataset will be interpolated.</p>
</td></tr>
<tr><td><code id="interpolate_pw_+3A_to">to</code></td>
<td>
<p>The target geometries (zones) to which numeric attributes will be interpolated.</p>
</td></tr>
<tr><td><code id="interpolate_pw_+3A_to_id">to_id</code></td>
<td>
<p>(optional) An ID column in the target dataset to be retained in the output. For data obtained with tidycensus, this will be <code>"GEOID"</code> by convention.  If <code>NULL</code>, the output dataset will include a column <code>id</code> that uniquely identifies each row.</p>
</td></tr>
<tr><td><code id="interpolate_pw_+3A_extensive">extensive</code></td>
<td>
<p>if <code>TRUE</code>, return weighted sums; if <code>FALSE</code>, return weighted means.</p>
</td></tr>
<tr><td><code id="interpolate_pw_+3A_weights">weights</code></td>
<td>
<p>An input spatial dataset to be used as weights. If the dataset is not of geometry type <code>POINT</code>, it will be converted to points by the function with <code>sf::st_point_on_surface()</code>.  For US-based applications, this will commonly be a Census block dataset obtained with the tigris or tidycensus packages.</p>
</td></tr>
<tr><td><code id="interpolate_pw_+3A_weight_column">weight_column</code></td>
<td>
<p>(optional) a column in <code>weights</code> used for weighting in the interpolation process.  Typically this will be a column representing the population (or other weighting metric, like housing units) of the input weights dataset.  If <code>NULL</code> (the default), each feature in <code>weights</code> is given an equal weight of 1.</p>
</td></tr>
<tr><td><code id="interpolate_pw_+3A_weight_placement">weight_placement</code></td>
<td>
<p>(optional) One of <code>"surface"</code>, where weight polygons are converted to points on polygon surfaces with <code>sf::st_point_on_surface()</code>, or <code>"centroid"</code>, where polygon centroids are used instead with <code>sf::st_centroid()</code>.  Defaults to <code>"surface"</code>.  This argument is not necessary if weights are already of geometry type <code>POINT</code>.</p>
</td></tr>
<tr><td><code id="interpolate_pw_+3A_crs">crs</code></td>
<td>
<p>(optional) The EPSG code of the output projected coordinate reference system (CRS). Useful as all input layers (<code>from</code>, <code>to</code>, and <code>weights</code>) must share the same CRS for the function to run correctly.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The approach implemented here is based on Esri's data apportionment algorithm, in which an &quot;apportionment layer&quot; of points (referred to here as the <code>weights</code>) is used to determine how to weight areas of overlap between origin and target zones.  Users must supply a &quot;from&quot; dataset as an sf object (the dataset from which numeric columns will be interpolated) and a &quot;to&quot; dataset, also of class sf, that contains the target zones. A third sf object, the &quot;weights&quot;, may be an object of geometry type <code>POINT</code> or polygons from which points will be derived using <code>sf::st_point_on_surface()</code>.
</p>
<p>An intersection is computed between <code>from</code> and <code>to</code>, and a spatial join is computed between the intersection layer and the weights layer, represented as points.  A specified <code>weight_column</code> in <code>weights</code> will be used to determine the relative influence of each point on the allocation of values between <code>from</code> and <code>to</code>; if no weight column is specified, all points will be weighted equally.
</p>
<p>The <code>extensive</code> parameter (logical) should reflect the values being interpolated correctly.  If <code>TRUE</code>, the function returns a weighted sum for each zone.  If <code>FALSE</code>, a weighted mean will be returned.  For Census data, <code>extensive = TRUE</code> should be used for transferring counts / estimated counts between zones.  Derived metrics (e.g. population density, percentages, etc.) should use <code>extensive = FALSE</code>.  Margins of error in the ACS will not be transferred correctly with this function, so please use with caution.
</p>


<h3>Value</h3>

<p>A dataset of class sf with the geometries and an ID column from <code>to</code> (the target shapes) but with numeric attributes of <code>from</code> interpolated to those shapes.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Example: interpolating work-from-home from 2011-2015 ACS
# to 2020 shapes
library(tidycensus)
library(tidyverse)
library(tigris)
options(tigris_use_cache = TRUE)

wfh_15 &lt;- get_acs(
  geography = "tract",
  variables = "B08006_017",
  year = 2015,
  state = "AZ",
  county = "Maricopa",
  geometry = TRUE
) %&gt;%
select(estimate)

wfh_20 &lt;- get_acs(
  geography = "tract",
  variables = "B08006_017",
  year = 2020,
  state = "AZ",
  county = "Maricopa",
  geometry = TRUE
 )

maricopa_blocks &lt;- blocks(
  "AZ",
  "Maricopa",
  year = 2020
)

wfh_15_to_20 &lt;- interpolate_pw(
  from = wfh_15,
  to = wfh_20,
  to_id = "GEOID",
  weights = maricopa_blocks,
  weight_column = "POP20",
  crs = 26949,
  extensive = TRUE
)


## End(Not run)
</code></pre>

<hr>
<h2 id='load_variables'>Load variables from a decennial Census or American Community Survey dataset to search in R</h2><span id='topic+load_variables'></span>

<h3>Description</h3>

<p>Finding the right variables to use with <code>get_decennial()</code> or <code>get_acs()</code> can be challenging; <code>load_variables()</code> attempts to make this easier for you.  Choose a year and a dataset to search for variables; those variables will be loaded from the Census website as an R data frame.  It is recommended that RStudio users use the <code>View()</code> function to interactively browse and filter these variables to find the right variables to use.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>load_variables(
  year,
  dataset = c("sf1", "sf2", "sf3", "sf4", "pl", "dhc", "dp", "ddhca", "as", "gu", "mp",
    "vi", "acsse", "dpas", "dpgu", "dpmp", "dpvi", "dhcvi", "dhcgu", "dhcvi", "dhcas",
    "acs1", "acs3", "acs5", "acs1/profile", "acs3/profile", "acs5/profile",
    "acs1/subject", "acs3/subject", "acs5/subject", "acs1/cprofile", "acs5/cprofile",
    "sf2profile", "sf3profile", "sf4profile", "aian", "aianprofile", "cd110h", "cd110s",
    "cd110hprofile", "cd110sprofile", "sldh", "slds", "sldhprofile", "sldsprofile",
    "cqr", "cd113", "cd113profile", 
     "cd115", "cd115profile", "cd116", "plnat",
    "cd118"),
  cache = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="load_variables_+3A_year">year</code></td>
<td>
<p>The year for which you are requesting variables. Either the year
or endyear of the decennial Census or ACS sample. 5-year ACS data is
available from 2009 through 2020. 1-year ACS data is available from 2005
through 2021, with the exception of 2020.</p>
</td></tr>
<tr><td><code id="load_variables_+3A_dataset">dataset</code></td>
<td>
<p>The dataset name as used on the Census website.  See the Details in this documentation for a full list of dataset names.</p>
</td></tr>
<tr><td><code id="load_variables_+3A_cache">cache</code></td>
<td>
<p>Whether you would like to cache the dataset for future access,
or load the dataset from an existing cache. Defaults to FALSE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>load_variables()</code> returns three columns by default: <code>name</code>, which is the Census ID code to be supplied to the <code>variables</code> parameter in <code>get_decennial()</code> or <code>get_acs()</code>; <code>label</code>, which is a detailed description of the variable; and <code>concept</code>, which provides information about the table that a given variable belongs to.  For 5-year ACS detailed tables datasets, a fourth column, <code>geography</code>, tells you the smallest geography at which a given variable is available.
</p>
<p>Datasets available are as follows: &quot;sf1&quot;, &quot;sf2&quot;, &quot;sf3&quot;, &quot;sf4&quot;, &quot;pl&quot;, &quot;dhc&quot;, &quot;dp&quot;,
&quot;dhca&quot;, &quot;ddhca&quot;, &quot;as&quot;, &quot;gu&quot;, &quot;mp&quot;, &quot;vi&quot;, &quot;acsse&quot;,
&quot;dpas&quot;, &quot;dpgu&quot;, &quot;dpmp&quot;, &quot;dpvi&quot;,
&quot;dhcvi&quot;, &quot;dhcgu&quot;, &quot;dhcvi&quot;, &quot;dhcas&quot;,
&quot;acs1&quot;, &quot;acs3&quot;, &quot;acs5&quot;, &quot;acs1/profile&quot;,
&quot;acs3/profile&quot;, &quot;acs5/profile&quot;, &quot;acs1/subject&quot;, &quot;acs3/subject&quot;,
&quot;acs5/subject&quot;, &quot;acs1/cprofile&quot;, &quot;acs5/cprofile&quot;,
&quot;sf2profile&quot;, &quot;sf3profile&quot;,
&quot;sf4profile&quot;, &quot;aian&quot;, &quot;aianprofile&quot;,
&quot;cd110h&quot;, &quot;cd110s&quot;, &quot;cd110hprofile&quot;, &quot;cd110sprofile&quot;, &quot;sldh&quot;,
&quot;slds&quot;, &quot;sldhprofile&quot;, &quot;sldsprofile&quot;, &quot;cqr&quot;,
&quot;cd113&quot;, &quot;cd113profile&quot;, &quot;cd115&quot;, &quot;cd115profile&quot;, &quot;cd116&quot;, &quot;cd118&quot;, and
&quot;plnat&quot;.
</p>


<h3>Value</h3>

<p>A tibble of variables from the requested dataset.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
v15 &lt;- load_variables(2015, "acs5", cache = TRUE)
View(v15)

## End(Not run)
</code></pre>

<hr>
<h2 id='mig_recodes'>Dataset with Migration Flows characteristic recodes</h2><span id='topic+mig_recodes'></span>

<h3>Description</h3>

<p>Built-in dataset for Migration Flows code label lookup.
</p>

<ul>
<li> <p><code>characteristic</code>: Characteristic variable name
</p>
</li>
<li> <p><code>code</code>: Characteristic calue code
</p>
</li>
<li> <p><code>desc</code>: Characteristic calue label
</p>
</li>
<li> <p><code>ordered</code>: Whether or not recoded value should be ordered factor
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>data(mig_recodes)
</code></pre>


<h3>Format</h3>

<p>An object of class <code>spec_tbl_df</code> (inherits from <code>tbl_df</code>, <code>tbl</code>, <code>data.frame</code>) with 120 rows and 4 columns.
</p>


<h3>Details</h3>

<p>Dataset with Migration Flows characteristic recodes
</p>
<p>Built-in dataset that is created from the
<a href="https://www.census.gov/data/developers/data-sets/acs-migration-flows.html">Migration
Flows API documentation</a>. This dataset contains labels for the coded values
returned by the Census API and is used when <code>breakdown_labels = TRUE</code> in
<code><a href="#topic+get_flows">get_flows</a></code>.
</p>

<hr>
<h2 id='moe_product'>Calculate the margin of error for a derived product</h2><span id='topic+moe_product'></span>

<h3>Description</h3>

<p>Calculate the margin of error for a derived product
</p>


<h3>Usage</h3>

<pre><code class='language-R'>moe_product(est1, est2, moe1, moe2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="moe_product_+3A_est1">est1</code></td>
<td>
<p>The first factor in the multiplication equation (an estimate)</p>
</td></tr>
<tr><td><code id="moe_product_+3A_est2">est2</code></td>
<td>
<p>The second factor in the multiplication equation (an estimate)</p>
</td></tr>
<tr><td><code id="moe_product_+3A_moe1">moe1</code></td>
<td>
<p>The margin of error of the first factor</p>
</td></tr>
<tr><td><code id="moe_product_+3A_moe2">moe2</code></td>
<td>
<p>The margin of error of the second factor</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A margin of error for a derived product
</p>

<hr>
<h2 id='moe_prop'>Calculate the margin of error for a derived proportion</h2><span id='topic+moe_prop'></span>

<h3>Description</h3>

<p>Calculate the margin of error for a derived proportion
</p>


<h3>Usage</h3>

<pre><code class='language-R'>moe_prop(num, denom, moe_num, moe_denom)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="moe_prop_+3A_num">num</code></td>
<td>
<p>The numerator involved in the proportion calculation (an estimate)</p>
</td></tr>
<tr><td><code id="moe_prop_+3A_denom">denom</code></td>
<td>
<p>The denominator involved in the proportion calculation (an estimate)</p>
</td></tr>
<tr><td><code id="moe_prop_+3A_moe_num">moe_num</code></td>
<td>
<p>The margin of error of the numerator</p>
</td></tr>
<tr><td><code id="moe_prop_+3A_moe_denom">moe_denom</code></td>
<td>
<p>The margin of error of the denominator</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A margin of error for a derived proportion
</p>

<hr>
<h2 id='moe_ratio'>Calculate the margin of error for a derived ratio</h2><span id='topic+moe_ratio'></span>

<h3>Description</h3>

<p>Calculate the margin of error for a derived ratio
</p>


<h3>Usage</h3>

<pre><code class='language-R'>moe_ratio(num, denom, moe_num, moe_denom)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="moe_ratio_+3A_num">num</code></td>
<td>
<p>The numerator involved in the ratio calculation (an estimate)</p>
</td></tr>
<tr><td><code id="moe_ratio_+3A_denom">denom</code></td>
<td>
<p>The denominator involved in the ratio calculation (an estimate)</p>
</td></tr>
<tr><td><code id="moe_ratio_+3A_moe_num">moe_num</code></td>
<td>
<p>The margin of error of the numerator</p>
</td></tr>
<tr><td><code id="moe_ratio_+3A_moe_denom">moe_denom</code></td>
<td>
<p>The margin of error of the denominator</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A margin of error for a derived ratio
</p>

<hr>
<h2 id='moe_sum'>Calculate the margin of error for a derived sum</h2><span id='topic+moe_sum'></span>

<h3>Description</h3>

<p>Generates a margin of error for a derived sum.  The function requires a vector of margins of error involved in a sum calculation, and optionally a vector of estimates associated with the margins of error.  If the associated estimates are not specified, the user risks inflating the derived margin of error in the event of multiple zero estimates.  It is recommended to inspect your data for multiple zero estimates before using this function and setting the inputs accordingly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>moe_sum(moe, estimate = NULL, na.rm = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="moe_sum_+3A_moe">moe</code></td>
<td>
<p>A vector of margins of error involved in the sum calculation</p>
</td></tr>
<tr><td><code id="moe_sum_+3A_estimate">estimate</code></td>
<td>
<p>A vector of estimates, the same length as <code>moe</code>, associated with the margins of error</p>
</td></tr>
<tr><td><code id="moe_sum_+3A_na.rm">na.rm</code></td>
<td>
<p>A logical value indicating whether missing values (including NaN) should be removed</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A margin of error for a derived sum
</p>


<h3>See Also</h3>

<p><a href="https://www2.census.gov/programs-surveys/acs/tech_docs/accuracy/MultiyearACSAccuracyofData2015.pdf">https://www2.census.gov/programs-surveys/acs/tech_docs/accuracy/MultiyearACSAccuracyofData2015.pdf</a>
</p>

<hr>
<h2 id='pums_variables'>Dataset with PUMS variables and codes</h2><span id='topic+pums_variables'></span>

<h3>Description</h3>

<p>Built-in dataset for variable name and code label lookup.
To access the data directly, issue the command <code>data(pums_variables)</code>.
</p>

<ul>
<li> <p><code>survey</code>: acs1 or acs5
</p>
</li>
<li> <p><code>year</code>: Year of data. For 5-year data, last year in range.
</p>
</li>
<li> <p><code>var_code</code>: Variable name
</p>
</li>
<li> <p><code>var_label</code>: Variable label
</p>
</li>
<li> <p><code>data_type</code>: chr or num
</p>
</li>
<li> <p><code>level</code>: housing or person
</p>
</li>
<li> <p><code>val_min</code>: For numeric variables, the minimum value
</p>
</li>
<li> <p><code>val_max</code>: For numeric variables, the maximum value
</p>
</li>
<li> <p><code>val_label</code>: Value label
</p>
</li>
<li> <p><code>recode</code>: Use labels to recode values
</p>
</li>
<li> <p><code>val_length</code>: Length of value returned
</p>
</li>
<li> <p><code>val_na</code>: Value of NA value returned by API (if known)
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>data(pums_variables)
</code></pre>


<h3>Format</h3>

<p>An object of class <code>tbl_df</code> (inherits from <code>tbl</code>, <code>data.frame</code>) with 58580 rows and 12 columns.
</p>


<h3>Details</h3>

<p>Dataset with PUMS variables and codes
</p>
<p>Built-in dataset that is created from the
<a href="https://www.census.gov/programs-surveys/acs/microdata/documentation.html">Census
PUMS data dictionaries</a>. Use this dataset to lookup the names of variables to
use in <code><a href="#topic+get_pums">get_pums</a></code>. This dataset also contains labels for the
coded values returned by the Census API and is used when <code>recode = TRUE</code>
in <code><a href="#topic+get_pums">get_pums</a></code>.
</p>
<p>Because variable names and codes change from year to year, you should filter
this dataset for the survey and year of interest. NOTE: 2017 - 2019 and 2021 acs1 and
2017 - 2021 acs5 variables are available.
</p>

<hr>
<h2 id='significance'>Evaluate whether the difference in two estimates is statistically significant.</h2><span id='topic+significance'></span>

<h3>Description</h3>

<p>Evaluate whether the difference in two estimates is statistically significant.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>significance(est1, est2, moe1, moe2, clevel = 0.9)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="significance_+3A_est1">est1</code></td>
<td>
<p>The first estimate.</p>
</td></tr>
<tr><td><code id="significance_+3A_est2">est2</code></td>
<td>
<p>The second estimate</p>
</td></tr>
<tr><td><code id="significance_+3A_moe1">moe1</code></td>
<td>
<p>The margin of error of the first estimate</p>
</td></tr>
<tr><td><code id="significance_+3A_moe2">moe2</code></td>
<td>
<p>The margin of error of the second estimate</p>
</td></tr>
<tr><td><code id="significance_+3A_clevel">clevel</code></td>
<td>
<p>The confidence level. May by 0.9, 0.95, or 0.99</p>
</td></tr>
</table>


<h3>Value</h3>

<p>TRUE if the difference is statistically signifiant, FALSE otherwise.
</p>


<h3>See Also</h3>

<p>https://www.census.gov/content/dam/Census/library/publications/2018/acs/acs_general_handbook_2018_ch07.pdf
</p>

<hr>
<h2 id='state_laea'>State geometry with Alaska and Hawaii shifted and re-scaled</h2><span id='topic+state_laea'></span>

<h3>Description</h3>

<p>Built-in dataset for use with <code>shift_geo = TRUE</code>
</p>
<p>Dataset of US states with Alaska and Hawaii shifted and re-scaled
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(state_laea)

data(state_laea)
</code></pre>


<h3>Format</h3>

<p>An object of class <code>sf</code> (inherits from <code>data.frame</code>) with 51 rows and 2 columns.
</p>


<h3>Details</h3>

<p>Dataset with state geometry for use when shifting Alaska and Hawaii
</p>
<p>Built-in dataset for use with the <code>shift_geo</code> parameter, with the continental United States in a
Lambert azimuthal equal area projection and Alaska and Hawaii shifted and re-scaled.  The data were originally
obtained from the albersusa R package (<a href="https://github.com/hrbrmstr/albersusa">https://github.com/hrbrmstr/albersusa</a>).
</p>

<hr>
<h2 id='summary_files'>Identify summary files for a given decennial Census year</h2><span id='topic+summary_files'></span>

<h3>Description</h3>

<p>Identify summary files for a given decennial Census year
</p>


<h3>Usage</h3>

<pre><code class='language-R'>summary_files(year)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary_files_+3A_year">year</code></td>
<td>
<p>The year of the decennial Census</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of available summary files for a given decennial Census year. To access data for a given summary file, supply the desired value to the <code>sumfile</code> parameter in <code>get_decennial()</code>.
</p>

<hr>
<h2 id='tidycensus'>Return tidy data frames from the US Census Bureau API</h2><span id='topic+tidycensus'></span>

<h3>Description</h3>

<p>This packages uses US Census Bureau data but is neither endorsed nor supported by the US Census Bureau.
</p>


<h3>Author(s)</h3>

<p>Kyle Walker
</p>

<hr>
<h2 id='to_survey'>Convert a data frame returned by get_pums() to a survey object</h2><span id='topic+to_survey'></span>

<h3>Description</h3>

<p>This helper function takes a data frame returned by
<code><a href="#topic+get_pums">get_pums</a></code> and converts it to a tbl_svy from the srvyr
<code><a href="srvyr.html#topic+as_survey">as_survey</a></code> package or a svyrep.design object from the
<code><a href="survey.html#topic+svrepdesign">svrepdesign</a></code> package. You can then use functions from
the srvyr or survey to calculate weighted estimates with replicate weights
included to provide accurate standard errors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>to_survey(
  df,
  type = c("person", "housing"),
  class = c("srvyr", "survey"),
  design = "rep_weights"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="to_survey_+3A_df">df</code></td>
<td>
<p>A data frame with PUMS person or housing weight variables, most
likely returned by <code><a href="#topic+get_pums">get_pums</a></code>.</p>
</td></tr>
<tr><td><code id="to_survey_+3A_type">type</code></td>
<td>
<p>Whether to use person or housing-level weights; either
<code>"housing"</code> or <code>"person"</code> (the default).</p>
</td></tr>
<tr><td><code id="to_survey_+3A_class">class</code></td>
<td>
<p>Whether to convert to a srvyr or survey object; either
<code>"survey"</code> or <code>"srvyr"</code> (the default).</p>
</td></tr>
<tr><td><code id="to_survey_+3A_design">design</code></td>
<td>
<p>The survey design to use when creating a survey object.
Currently the only option is <code>"rep_weights"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tbl_svy or svyrep.design object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
pums &lt;- get_pums(variables = "AGEP", state = "VT", rep_weights = "person")
pums_design &lt;- to_survey(pums, type = "person", class = "srvyr")
survey::svymean(~AGEP, pums_design)

## End(Not run)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
