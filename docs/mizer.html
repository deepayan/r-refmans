<!DOCTYPE html><html><head><title>Help for package mizer</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {mizer}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#mizer-package'><p>mizer: Multi-species size-based modelling in R</p></a></li>
<li><a href='#addSpecies'><p>Add new species</p></a></li>
<li><a href='#age_mat'><p>Calculate age at maturity</p></a></li>
<li><a href='#age_mat_vB'><p>Calculate age at maturity from von Bertalanffy growth parameters</p></a></li>
<li><a href='#animateSpectra'><p>Animation of the abundance spectra</p></a></li>
<li><a href='#BevertonHoltRDD'><p>Beverton Holt function to calculate density-dependent reproduction rate</p></a></li>
<li><a href='#box_pred_kernel'><p>Box predation kernel</p></a></li>
<li><a href='#calibrateBiomass'><p>Calibrate the model scale to match total observed biomass</p></a></li>
<li><a href='#calibrateNumber'><p>Calibrate the model scale to match total observed number</p></a></li>
<li><a href='#calibrateYield'><p>Calibrate the model scale to match total observed yield</p></a></li>
<li><a href='#compareParams'><p>Compare two MizerParams objects and print out differences</p></a></li>
<li><a href='#completeSpeciesParams'><p>Complete species parameter data frame with default values</p></a></li>
<li><a href='#constant_other'><p>Helper function to keep other components constant</p></a></li>
<li><a href='#constantEggRDI'><p>Choose egg production to keep egg density constant</p></a></li>
<li><a href='#constantRDD'><p>Give constant reproduction rate</p></a></li>
<li><a href='#customFunction'><p>Replace a mizer function with a custom version</p></a></li>
<li><a href='#default_pred_kernel_params'><p>Set defaults for predation kernel parameters</p></a></li>
<li><a href='#defaults_edition'><p>Default editions</p></a></li>
<li><a href='#different'><p>Check whether two objects are different</p></a></li>
<li><a href='#distanceMaxRelRDI'><p>Measure distance between current and previous state in terms of RDI</p></a></li>
<li><a href='#distanceSSLogN'><p>Measure distance between current and previous state in terms of fish abundances</p></a></li>
<li><a href='#double_sigmoid_length'><p>Length based double-sigmoid selectivity function</p></a></li>
<li><a href='#emptyParams'><p>Create empty MizerParams object of the right size</p></a></li>
<li><a href='#finalN'><p>Size spectra at end of simulation</p></a></li>
<li><a href='#finalNOther'><p>Values of other ecosystem components at end of simulation</p></a></li>
<li><a href='#gear_params'><p>Gear parameters</p></a></li>
<li><a href='#get_f0_default'><p>Get default value for f0</p></a></li>
<li><a href='#get_gamma_default'><p>Get default value for gamma</p></a></li>
<li><a href='#get_h_default'><p>Get default value for h</p></a></li>
<li><a href='#get_initial_n'><p>Calculate initial population abundances</p></a></li>
<li><a href='#get_ks_default'><p>Get default value for <code>ks</code></p></a></li>
<li><a href='#get_phi'><p>Get values from feeding kernel function</p></a></li>
<li><a href='#get_required_reproduction'><p>Determine reproduction rate needed for initial egg abundance</p></a></li>
<li><a href='#get_size_range_array'><p>Get size range array</p></a></li>
<li><a href='#get_time_elements'><p>Get_time_elements</p></a></li>
<li><a href='#getBiomass'><p>Calculate the total biomass of each species within a size range at each time</p>
step.</a></li>
<li><a href='#getCommunitySlope'><p>Calculate the slope of the community abundance</p></a></li>
<li><a href='#getComponent'><p>Get information about other ecosystem components</p></a></li>
<li><a href='#getCriticalFeedingLevel'><p>Get critical feeding level</p></a></li>
<li><a href='#getDiet'><p>Get diet of predator at size, resolved by prey species</p></a></li>
<li><a href='#getEffort'><p>Fishing effort used in simulation</p></a></li>
<li><a href='#getEGrowth'><p>Get energy rate available for growth</p></a></li>
<li><a href='#getEncounter'><p>Get encounter rate</p></a></li>
<li><a href='#getERepro'><p>Get energy rate available for reproduction</p></a></li>
<li><a href='#getEReproAndGrowth'><p>Get energy rate available for reproduction and growth</p></a></li>
<li><a href='#getESpawning'><p>Alias for <code>getERepro()</code></p></a></li>
<li><a href='#getFeedingLevel'><p>Get feeding level</p></a></li>
<li><a href='#getFMort'><p>Get the total fishing mortality rate from all fishing gears by time, species</p>
and size.</a></li>
<li><a href='#getFMortGear'><p>Get the fishing mortality by time, gear, species and size</p></a></li>
<li><a href='#getGrowthCurves'><p>Get growth curves giving weight as a function of age</p></a></li>
<li><a href='#getInteraction'><p>Deprecated function to get interaction matrix</p></a></li>
<li><a href='#getM2'><p>Alias for <code>getPredMort()</code></p></a></li>
<li><a href='#getM2Background'><p>Alias for <code>getResourceMort()</code></p></a></li>
<li><a href='#getMeanMaxWeight'><p>Calculate the mean maximum weight of the community</p></a></li>
<li><a href='#getMeanWeight'><p>Calculate the mean weight of the community</p></a></li>
<li><a href='#getMort'><p>Get total mortality rate</p></a></li>
<li><a href='#getN'><p>Calculate the number of individuals within a size range</p></a></li>
<li><a href='#getParams'><p>Extract the parameter object underlying a simulation</p></a></li>
<li><a href='#getPhiPrey'><p>Get available energy</p></a></li>
<li><a href='#getPredMort'><p>Get total predation mortality rate</p></a></li>
<li><a href='#getPredRate'><p>Get predation rate</p></a></li>
<li><a href='#getProportionOfLargeFish'><p>Calculate the proportion of large fish</p></a></li>
<li><a href='#getRates'><p>Get all rates</p></a></li>
<li><a href='#getRDD'><p>Get density dependent reproduction rate</p></a></li>
<li><a href='#getRDI'><p>Get density independent rate of egg production</p></a></li>
<li><a href='#getReproductionLevel'><p>Get reproduction level</p></a></li>
<li><a href='#getResourceDynamics'><p>Deprecated functions for getting resource parameters</p></a></li>
<li><a href='#getResourceMort'><p>Get predation mortality rate for resource</p></a></li>
<li><a href='#getSSB'><p>Calculate the SSB of species</p></a></li>
<li><a href='#getTimes'><p>Times for which simulation results are available</p></a></li>
<li><a href='#getYield'><p>Calculate the rate at which biomass of each species is fished</p></a></li>
<li><a href='#getYieldGear'><p>Calculate the rate at which biomass of each species is fished by each gear</p></a></li>
<li><a href='#getZ'><p>Alias for <code>getMort()</code></p></a></li>
<li><a href='#idxFinalT'><p>Time index at end of simulation</p></a></li>
<li><a href='#indicator_functions'><p>Description of indicator functions</p></a></li>
<li><a href='#initial_effort'><p>Initial fishing effort</p></a></li>
<li><a href='#initialN&lt;-'><p>Initial values for fish spectra</p></a></li>
<li><a href='#initialNOther&lt;-'><p>Initial values for other ecosystem components</p></a></li>
<li><a href='#initialNResource&lt;-'><p>Initial value for resource spectrum</p></a></li>
<li><a href='#inter'><p>Alias for <code>NS_interaction</code></p></a></li>
<li><a href='#knife_edge'><p>Weight based knife-edge selectivity function</p></a></li>
<li><a href='#l2w'><p>Length-weight conversion</p></a></li>
<li><a href='#log_breaks'><p>Helper function to produce nice breaks on logarithmic axes</p></a></li>
<li><a href='#lognormal_pred_kernel'><p>Lognormal predation kernel</p></a></li>
<li><a href='#matchBiomasses'><p>Match biomasses to observations</p></a></li>
<li><a href='#matchGrowth'><p>Adjust model to produce observed growth</p></a></li>
<li><a href='#matchNumbers'><p>Match numbers to observations</p></a></li>
<li><a href='#matchYields'><p>Match yields to observations</p></a></li>
<li><a href='#mizerEGrowth'><p>Get energy rate available for growth needed to project standard mizer model</p></a></li>
<li><a href='#mizerEncounter'><p>Get encounter rate needed to project standard mizer model</p></a></li>
<li><a href='#mizerERepro'><p>Get energy rate available for reproduction needed to project standard mizer</p>
model</a></li>
<li><a href='#mizerEReproAndGrowth'><p>Get energy rate available for reproduction and growth  needed to project</p>
standard mizer model</a></li>
<li><a href='#mizerFeedingLevel'><p>Get feeding level needed to project standard mizer model</p></a></li>
<li><a href='#mizerFMort'><p>Get the total fishing mortality rate from all fishing gears</p></a></li>
<li><a href='#mizerFMortGear'><p>Get the fishing mortality needed to project</p>
standard mizer model</a></li>
<li><a href='#mizerMort'><p>Get total mortality rate needed to project standard mizer model</p></a></li>
<li><a href='#MizerParams'><p>Alias for <code>set_multispecies_model()</code></p></a></li>
<li><a href='#MizerParams-class'><p>A class to hold the parameters for a size based model.</p></a></li>
<li><a href='#mizerPredMort'><p>Get total predation mortality rate needed to project standard mizer model</p></a></li>
<li><a href='#mizerPredRate'><p>Get predation rate needed to project standard mizer model</p></a></li>
<li><a href='#mizerRates'><p>Get all rates needed to project standard mizer model</p></a></li>
<li><a href='#mizerRDI'><p>Get density-independent rate of reproduction needed to project standard</p>
mizer model</a></li>
<li><a href='#mizerResourceMort'><p>Get predation mortality rate for resource needed to project standard mizer</p>
model</a></li>
<li><a href='#MizerSim'><p>Constructor for the <code>MizerSim</code> class</p></a></li>
<li><a href='#MizerSim-class'><p>A class to hold the results of a simulation</p></a></li>
<li><a href='#N'><p>Time series of size spectra</p></a></li>
<li><a href='#needs_upgrading'><p>Determine whether a MizerParams or MizerSim object needs to be upgraded</p></a></li>
<li><a href='#newCommunityParams'><p>Set up parameters for a community-type model</p></a></li>
<li><a href='#newMultispeciesParams'><p>Set up parameters for a general multispecies model</p></a></li>
<li><a href='#newSingleSpeciesParams'><p>Set up parameters for a single species in a power-law background</p></a></li>
<li><a href='#newTraitParams'><p>Set up parameters for a trait-based multispecies model</p></a></li>
<li><a href='#noRDD'><p>Give density-independent reproduction rate</p></a></li>
<li><a href='#NOther'><p>Time series of other components</p></a></li>
<li><a href='#NS_interaction'><p>Example interaction matrix for the North Sea example</p></a></li>
<li><a href='#NS_params'><p>Example MizerParams object for the North Sea example</p></a></li>
<li><a href='#NS_sim'><p>Example MizerSim object for the North Sea example</p></a></li>
<li><a href='#NS_species_params'><p>Example species parameter set based on the North Sea</p></a></li>
<li><a href='#NS_species_params_gears'><p>Example species parameter set based on the North Sea with different gears</p></a></li>
<li><a href='#plot,MizerSim,missing-method'><p>Summary plot for <code>MizerSim</code> objects</p></a></li>
<li><a href='#plotBiomass'><p>Plot the biomass of species through time</p></a></li>
<li><a href='#plotBiomassObservedVsModel'><p>Plotting observed vs. model biomass data</p></a></li>
<li><a href='#plotDataFrame'><p>Make a plot from a data frame</p></a></li>
<li><a href='#plotDiet'><p>Plot diet, resolved by prey species, as function of predator at size.</p></a></li>
<li><a href='#plotFeedingLevel'><p>Plot the feeding level of species by size</p></a></li>
<li><a href='#plotFMort'><p>Plot total fishing mortality of each species by size</p></a></li>
<li><a href='#plotGrowthCurves'><p>Plot growth curves</p></a></li>
<li><a href='#plotM2'><p>Alias for <code>plotPredMort()</code></p></a></li>
<li><a href='#plotPredMort'><p>Plot predation mortality rate of each species against size</p></a></li>
<li><a href='#plotSpectra'><p>Plot the abundance spectra</p></a></li>
<li><a href='#plotting_functions'><p>Description of the plotting functions</p></a></li>
<li><a href='#plotYield'><p>Plot the total yield of species through time</p></a></li>
<li><a href='#plotYieldGear'><p>Plot the total yield of each species by gear through time</p></a></li>
<li><a href='#plotYieldObservedVsModel'><p>Plotting observed vs. model yields</p></a></li>
<li><a href='#power_law_pred_kernel'><p>Power-law predation kernel</p></a></li>
<li><a href='#project'><p>Project size spectrum forward in time</p></a></li>
<li><a href='#project_simple'><p>Project abundances by a given number of time steps into the future</p></a></li>
<li><a href='#projectToSteady'><p>Project to steady state</p></a></li>
<li><a href='#reexports'><p>Objects exported from other packages</p></a></li>
<li><a href='#removeSpecies'><p>Remove species</p></a></li>
<li><a href='#renameSpecies'><p>Rename species</p></a></li>
<li><a href='#resource_constant'><p>Keep resource abundance constant</p></a></li>
<li><a href='#resource_logistic'><p>Project resource using logistic model</p></a></li>
<li><a href='#resource_params'><p>Resource parameters</p></a></li>
<li><a href='#resource_semichemostat'><p>Project resource using semichemostat model</p></a></li>
<li><a href='#RickerRDD'><p>Ricker function to calculate density-dependent reproduction rate</p></a></li>
<li><a href='#saveParams'><p>Save a MizerParams object to file, and restore it</p></a></li>
<li><a href='#scaleModel'><p>Change scale of the model</p></a></li>
<li><a href='#set_community_model'><p>Deprecated function for setting up parameters for a community-type model</p></a></li>
<li><a href='#set_multispecies_model'><p>Deprecated obsolete function for setting up multispecies parameters</p></a></li>
<li><a href='#set_species_param_default'><p>Set a species parameter to a default value</p></a></li>
<li><a href='#set_trait_model'><p>Deprecated function for setting up parameters for a trait-based model</p></a></li>
<li><a href='#setBevertonHolt'><p>Set Beverton-Holt reproduction without changing the steady state</p></a></li>
<li><a href='#setColours'><p>Set line colours and line types to be used in mizer plots</p></a></li>
<li><a href='#setComponent'><p>Add a dynamical ecosystem component</p></a></li>
<li><a href='#setExtEncounter'><p>Set external encounter rate</p></a></li>
<li><a href='#setExtMort'><p>Set external mortality rate</p></a></li>
<li><a href='#setFishing'><p>Set fishing parameters</p></a></li>
<li><a href='#setInitialValues'><p>Set initial values to values from a simulation</p></a></li>
<li><a href='#setInteraction'><p>Set species interaction matrix</p></a></li>
<li><a href='#setMaxIntakeRate'><p>Set maximum intake rate</p></a></li>
<li><a href='#setMetabolicRate'><p>Set metabolic rate</p></a></li>
<li><a href='#setMetadata'><p>Set metadata for a model</p></a></li>
<li><a href='#setParams'><p>Set or change any model parameters</p></a></li>
<li><a href='#setPredKernel'><p>Set predation kernel</p></a></li>
<li><a href='#setRateFunction'><p>Set own rate function to replace mizer rate function</p></a></li>
<li><a href='#setReproduction'><p>Set reproduction parameters</p></a></li>
<li><a href='#setResource'><p>Set resource dynamics</p></a></li>
<li><a href='#setRmax'><p>Alias for <code>setBevertonHolt()</code></p></a></li>
<li><a href='#setSearchVolume'><p>Set search volume</p></a></li>
<li><a href='#SheperdRDD'><p>Sheperd function to calculate density-dependent reproduction rate</p></a></li>
<li><a href='#sigmoid_length'><p>Length based sigmoid selectivity function</p></a></li>
<li><a href='#sigmoid_weight'><p>Weight based sigmoidal selectivity function</p></a></li>
<li><a href='#species_params'><p>Species parameters</p></a></li>
<li><a href='#steady'><p>Set initial values to a steady state for the model</p></a></li>
<li><a href='#steadySingleSpecies'><p>Set initial abundances to single-species steady state abundances</p></a></li>
<li><a href='#summary_functions'><p>Description of summary functions</p></a></li>
<li><a href='#summary,MizerParams-method'><p>Summarize MizerParams object</p></a></li>
<li><a href='#summary,MizerSim-method'><p>Summarize MizerSim object</p></a></li>
<li><a href='#truncated_lognormal_pred_kernel'><p>Truncated lognormal predation kernel</p></a></li>
<li><a href='#upgradeParams'><p>Upgrade MizerParams object from earlier mizer versions</p></a></li>
<li><a href='#upgradeSim'><p>Upgrade MizerSim object from earlier mizer versions</p></a></li>
<li><a href='#valid_species_arg'><p>Helper function to assure validity of species argument</p></a></li>
<li><a href='#validGearParams'><p>Check validity of gear parameters and set defaults</p></a></li>
<li><a href='#validParams'><p>Validate MizerParams object and upgrade if necessary using <code>upgradeParams()</code>.</p></a></li>
<li><a href='#validSpeciesParams'><p>Validate species parameter data frame</p></a></li>
<li><a href='#w'><p>Size bins</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Dynamic Multi-Species Size Spectrum Modelling</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-03-08</td>
</tr>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Description:</td>
<td>A set of classes and methods to set up and run multi-species, trait
    based and community size spectrum ecological models, focused on the marine
    environment.</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Gustav Delius &lt;gustav.delius@york.ac.uk&gt;</td>
</tr>
<tr>
<td>Version:</td>
<td>2.5.1</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>assertthat, deSolve, dplyr, ggplot2 (&ge; 3.4.0), ggrepel, grid,
lubridate, methods, plotly, plyr, progress, Rcpp, reshape2,
rlang, lifecycle</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.1)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat (&ge; 2.1.0), vdiffr, roxygen2, knitr, rmarkdown,
pkgdown, covr, spelling</td>
</tr>
<tr>
<td>Collate:</td>
<td>'age_mat.R' 'helpers.R' 'MizerParams-class.R'
'MizerSim-class.R' 'reproduction.R' 'saveParams.R'
'species_params.R' 'setColours.R' 'setInteraction.R'
'setPredKernel.R' 'setSearchVolume.R' 'setMaxIntakeRate.R'
'setMetabolicRate.R' 'setMetadata.R' 'setExtMort.R'
'setExtEncounter.R' 'setReproduction.R' 'setResource.R'
'setFishing.R' 'setInitialValues.R' 'setBevertonHolt.R'
'upgrade.R' 'selectivity_funcs.R' 'pred_kernel_funcs.R'
'resource_dynamics.R' 'resource_semichemostat.R'
'resource_logistic.R' 'project.R' 'mizer-package.R'
'project_methods.R' 'rate_functions.R' 'summary_methods.R'
'plots.R' 'plotBiomassObservedVsModel.R'
'plotYieldObservedVsModel.R' 'animateSpectra.R'
'newMultispeciesParams.R' 'wrapper_functions.R'
'newSingleSpeciesParams.R' 'steady.R' 'extension.R' 'data.R'
'RcppExports.R' 'deprecated.R' 'get_initial_n.R'
'compareParams.R' 'customFunction.R' 'manipulate_species.R'
'calibrate.R' 'match.R' 'matchGrowth.R' 'steadySingleSpecies.R'
'defaults_edition.R'</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://sizespectrum.org/mizer/">https://sizespectrum.org/mizer/</a>,
<a href="https://github.com/sizespectrum/mizer">https://github.com/sizespectrum/mizer</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/sizespectrum/mizer/issues">https://github.com/sizespectrum/mizer/issues</a></td>
</tr>
<tr>
<td>Language:</td>
<td>en-GB</td>
</tr>
<tr>
<td>RdMacros:</td>
<td>lifecycle</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-03-08 22:50:24 UTC; gustav</td>
</tr>
<tr>
<td>Author:</td>
<td>Gustav Delius <a href="https://orcid.org/0000-0003-4092-8228"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [cre, aut, cph],
  Finlay Scott [aut, cph],
  Julia Blanchard <a href="https://orcid.org/0000-0003-0532-4824"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cph],
  Ken Andersen <a href="https://orcid.org/0000-0002-8478-3430"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cph],
  Richard Southwell [ctb, cph]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-03-08 23:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='mizer-package'>mizer: Multi-species size-based modelling in R</h2><span id='topic+mizer'></span><span id='topic+mizer-package'></span>

<h3>Description</h3>

<p>The mizer package implements multi-species size-based modelling in R. It has
been designed for modelling marine ecosystems.
</p>


<h3>Details</h3>

<p>Using <span class="pkg">mizer</span> is relatively simple.  There are three main stages:
</p>

<ol>
<li> <p><em>Setting the model parameters</em>. This is done by creating an object of
class <a href="#topic+MizerParams-class">MizerParams</a>. This includes model parameters such as the
life history parameters of each species, and the range of the size spectrum.
There are several setup functions that help to create a MizerParams objects
for particular types of models:
</p>

<ul>
<li> <p><code><a href="#topic+newSingleSpeciesParams">newSingleSpeciesParams()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+newCommunityParams">newCommunityParams()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+newTraitParams">newTraitParams()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+newMultispeciesParams">newMultispeciesParams()</a></code>
</p>
</li></ul>

</li>
<li> <p><em>Running a simulation</em>. This is done by calling the
<code><a href="#topic+project">project()</a></code> function with the model parameters. This produces an
object of <a href="#topic+MizerSim-class">MizerSim</a> that contains the results of the simulation.
</p>
</li>
<li> <p><em>Exploring results</em>. After a simulation has been run, the results can be
explored using a range of <a href="#topic+plotting_functions">plotting_functions</a>, <a href="#topic+summary_functions">summary_functions</a> and
<a href="#topic+indicator_functions">indicator_functions</a>.
</p>
</li></ol>

<p>See the <a href="https://sizespectrum.org/mizer/">mizer website</a> for full details of
the principles behind mizer and how the package can be used to perform
size-based modelling.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Gustav Delius <a href="mailto:gustav.delius@york.ac.uk">gustav.delius@york.ac.uk</a> (<a href="https://orcid.org/0000-0003-4092-8228">ORCID</a>) [copyright holder]
</p>
<p>Authors:
</p>

<ul>
<li><p> Finlay Scott <a href="mailto:drfinlayscott@gmail.com">drfinlayscott@gmail.com</a> [copyright holder]
</p>
</li>
<li><p> Julia Blanchard <a href="mailto:julia.blanchard@utas.edu.au">julia.blanchard@utas.edu.au</a> (<a href="https://orcid.org/0000-0003-0532-4824">ORCID</a>) [copyright holder]
</p>
</li>
<li><p> Ken Andersen <a href="mailto:kha@aqua.dtu.dk">kha@aqua.dtu.dk</a> (<a href="https://orcid.org/0000-0002-8478-3430">ORCID</a>) [copyright holder]
</p>
</li></ul>

<p>Other contributors:
</p>

<ul>
<li><p> Richard Southwell <a href="mailto:richard.southwell@york.ac.uk">richard.southwell@york.ac.uk</a> [contributor, copyright holder]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://sizespectrum.org/mizer/">https://sizespectrum.org/mizer/</a>
</p>
</li>
<li> <p><a href="https://github.com/sizespectrum/mizer">https://github.com/sizespectrum/mizer</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/sizespectrum/mizer/issues">https://github.com/sizespectrum/mizer/issues</a>
</p>
</li></ul>


<hr>
<h2 id='addSpecies'>Add new species</h2><span id='topic+addSpecies'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>
<p>Takes a <a href="#topic+MizerParams-class">MizerParams</a> object and adds additional species with
given parameters to the ecosystem. It sets the initial values for these new
species to their steady-state solution in the given initial state of the
existing ecosystem. This will be close to the true steady state if the
abundances of the new species are sufficiently low. Hence the abundances of
the new species are set so that they are at most 1/100th of the resource
power law. Their reproductive efficiencies are set so as to keep them at
that low level.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>addSpecies(
  params,
  species_params,
  gear_params = data.frame(),
  initial_effort,
  interaction
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="addSpecies_+3A_params">params</code></td>
<td>
<p>A mizer params object for the original system.</p>
</td></tr>
<tr><td><code id="addSpecies_+3A_species_params">species_params</code></td>
<td>
<p>Data frame with the species parameters of the new
species we want to add to the system.</p>
</td></tr>
<tr><td><code id="addSpecies_+3A_gear_params">gear_params</code></td>
<td>
<p>Data frame with the gear parameters for the new
species. If not provided then the new species will not be fished.</p>
</td></tr>
<tr><td><code id="addSpecies_+3A_initial_effort">initial_effort</code></td>
<td>
<p>A named vector with the effort for any new fishing gear
introduced in <code>gear_params</code>. Not needed if the added species are only
fished by already existing gear. Should not include effort values
for existing gear. New gear for which no effort is set via this
vector will have an initial effort of 0.</p>
</td></tr>
<tr><td><code id="addSpecies_+3A_interaction">interaction</code></td>
<td>
<p>Interaction matrix. A square matrix giving either the
interaction coefficients between all species or only those between the new
species. In the latter case all interaction between an old and a new
species are set to 1. If this argument is missing, all interactions
involving a new species are set to 1.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The resulting MizerParams object will use the same size grid where
possible, but if one of the new species needs a larger range of w (either
because a new species has an egg size smaller than those of existing
species or a maximum size larger than those of existing species) then the
grid will be expanded and all arrays will be enlarged accordingly.
</p>
<p>If any of the rate arrays of the existing species had been set by the user
to values other than those calculated as default from the species
parameters, then these will be preserved. Only the rates for the new
species will be calculated from their species parameters.
</p>
<p>After adding the new species, the background species are not retuned and
the system is not run to steady state. This could be done with <code><a href="#topic+steady">steady()</a></code>.
The new species will have a reproduction level of 1/4, this can then be
changed with <code><a href="#topic+setBevertonHolt">setBevertonHolt()</a></code>
</p>


<h3>Value</h3>

<p>An object of type <a href="#topic+MizerParams-class">MizerParams</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+removeSpecies">removeSpecies()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>params &lt;- newTraitParams()
species_params &lt;- data.frame(
    species = "Mullet",
    w_max = 173,
    w_mat = 15,
    beta = 283,
    sigma = 1.8,
    h = 30,
    a = 0.0085,
    b = 3.11
)
params &lt;- addSpecies(params, species_params)
plotSpectra(params)
</code></pre>

<hr>
<h2 id='age_mat'>Calculate age at maturity</h2><span id='topic+age_mat'></span>

<h3>Description</h3>

<p>Uses the growth rate and the size at maturity to calculate the age at
maturity
</p>


<h3>Usage</h3>

<pre><code class='language-R'>age_mat(params)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="age_mat_+3A_params">params</code></td>
<td>
<p>A MizerParams object</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Using that by definition of the growth rate <code class="reqn">g(w) = dw/dt</code> we have that
</p>
<p style="text-align: center;"><code class="reqn">\mathrm{age_{mat}} = \int_0^{w_{mat}.}\frac{dw}{g(w)}</code>
</p>



<h3>Value</h3>

<p>A named vector. The names are the species names and the values are
the ages at maturity.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>age_mat(NS_params)
</code></pre>

<hr>
<h2 id='age_mat_vB'>Calculate age at maturity from von Bertalanffy growth parameters</h2><span id='topic+age_mat_vB'></span>

<h3>Description</h3>

<p>This is not a good way to determine the age at maturity because the von
Bertalanffy growth curve is not reliable for larvae and juveniles. However
this was used in previous versions of mizer and is supplied for
backwards compatibility.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>age_mat_vB(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="age_mat_vB_+3A_object">object</code></td>
<td>
<p>A MizerParams object or a species_params data frame</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Uses the age at maturity that is implied by the von Bertalanffy growth curve
specified by the <code>w_inf</code>, <code>k_vb</code>, <code>t0</code>, <code>a</code> and <code>b</code> parameters in the
species_params data frame.
</p>
<p>If any of <code>k_vb</code> is missing for a species, the function returns NA for that
species. Default values of <code>b = 3</code> and <code>t0 = 0</code> are used if these are
missing. If <code>w_inf</code> is missing, <code>w_max</code> is used instead.
</p>


<h3>Value</h3>

<p>A named vector. The names are the species names and the values are
the ages at maturity.
</p>

<hr>
<h2 id='animateSpectra'>Animation of the abundance spectra</h2><span id='topic+animateSpectra'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>animateSpectra(
  sim,
  species = NULL,
  time_range,
  wlim = c(NA, NA),
  ylim = c(NA, NA),
  power = 1,
  total = FALSE,
  resource = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="animateSpectra_+3A_sim">sim</code></td>
<td>
<p>A MizerSim object</p>
</td></tr>
<tr><td><code id="animateSpectra_+3A_species">species</code></td>
<td>
<p>Name or vector of names of the species to be plotted. By
default all species are plotted.</p>
</td></tr>
<tr><td><code id="animateSpectra_+3A_time_range">time_range</code></td>
<td>
<p>The time range to animate over. Either a vector of values
or a vector of min and max time. Default is the entire time range of the
simulation.</p>
</td></tr>
<tr><td><code id="animateSpectra_+3A_wlim">wlim</code></td>
<td>
<p>A numeric vector of length two providing lower and upper limits
for the w axis. Use NA to refer to the existing minimum or maximum.</p>
</td></tr>
<tr><td><code id="animateSpectra_+3A_ylim">ylim</code></td>
<td>
<p>A numeric vector of length two providing lower and upper limits
for the y axis. Use NA to refer to the existing minimum or maximum. Any
values below 1e-20 are always cut off.</p>
</td></tr>
<tr><td><code id="animateSpectra_+3A_power">power</code></td>
<td>
<p>The abundance is plotted as the number density times the weight
raised to <code>power</code>. The default <code>power = 1</code> gives the biomass
density, whereas <code>power = 2</code> gives the biomass density with respect
to logarithmic size bins.</p>
</td></tr>
<tr><td><code id="animateSpectra_+3A_total">total</code></td>
<td>
<p>A boolean value that determines whether the total over all
species in the system is plotted as well. Default is FALSE.</p>
</td></tr>
<tr><td><code id="animateSpectra_+3A_resource">resource</code></td>
<td>
<p>A boolean value that determines whether resource is included.
Default is TRUE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plotly object
</p>


<h3>See Also</h3>

<p>Other plotting functions: 
<code><a href="#topic+plot+2CMizerSim+2Cmissing-method">plot,MizerSim,missing-method</a></code>,
<code><a href="#topic+plotBiomass">plotBiomass</a>()</code>,
<code><a href="#topic+plotDiet">plotDiet</a>()</code>,
<code><a href="#topic+plotFMort">plotFMort</a>()</code>,
<code><a href="#topic+plotFeedingLevel">plotFeedingLevel</a>()</code>,
<code><a href="#topic+plotGrowthCurves">plotGrowthCurves</a>()</code>,
<code><a href="#topic+plotPredMort">plotPredMort</a>()</code>,
<code><a href="#topic+plotSpectra">plotSpectra</a>()</code>,
<code><a href="#topic+plotYield">plotYield</a>()</code>,
<code><a href="#topic+plotYieldGear">plotYieldGear</a>()</code>,
<code><a href="#topic+plotting_functions">plotting_functions</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
animateSpectra(NS_sim, power = 2, wlim = c(0.1, NA), time_range = 1997:2007)

</code></pre>

<hr>
<h2 id='BevertonHoltRDD'>Beverton Holt function to calculate density-dependent reproduction rate</h2><span id='topic+BevertonHoltRDD'></span>

<h3>Description</h3>

<p>Takes the density-independent rates <code class="reqn">R_{di}</code> of egg production (as
calculated by <code><a href="#topic+getRDI">getRDI()</a></code>) and returns
reduced, density-dependent reproduction rates <code class="reqn">R_{dd}</code> given as
</p>
<p style="text-align: center;"><code class="reqn">R_{dd} = R_{di}
\frac{R_{max}}{R_{di} + R_{max}}</code>
</p>
<p> where
<code class="reqn">R_{max}</code> are the maximum possible reproduction rates that must be
specified in a column in the species parameter dataframe.
(All quantities in the above equation are species-specific but we dropped
the species index for simplicity.)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BevertonHoltRDD(rdi, species_params, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BevertonHoltRDD_+3A_rdi">rdi</code></td>
<td>
<p>Vector of density-independent reproduction rates
<code class="reqn">R_{di}</code> for all species.</p>
</td></tr>
<tr><td><code id="BevertonHoltRDD_+3A_species_params">species_params</code></td>
<td>
<p>A species parameter dataframe. Must contain a column
<code>R_max</code> holding the maximum reproduction rate <code class="reqn">R_{max}</code> for each
species.</p>
</td></tr>
<tr><td><code id="BevertonHoltRDD_+3A_...">...</code></td>
<td>
<p>Unused</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is only one example of a density-dependence. You can write your own
function based on this example, returning different density-dependent
reproduction rates. Three other examples provided are <code><a href="#topic+RickerRDD">RickerRDD()</a></code>,
<code><a href="#topic+SheperdRDD">SheperdRDD()</a></code>, <code><a href="#topic+noRDD">noRDD()</a></code> and <code><a href="#topic+constantRDD">constantRDD()</a></code>. For more explanation see
<code><a href="#topic+setReproduction">setReproduction()</a></code>.
</p>


<h3>Value</h3>

<p>Vector of density-dependent reproduction rates.
</p>


<h3>See Also</h3>

<p>Other functions calculating density-dependent reproduction rate: 
<code><a href="#topic+RickerRDD">RickerRDD</a>()</code>,
<code><a href="#topic+SheperdRDD">SheperdRDD</a>()</code>,
<code><a href="#topic+constantEggRDI">constantEggRDI</a>()</code>,
<code><a href="#topic+constantRDD">constantRDD</a>()</code>,
<code><a href="#topic+noRDD">noRDD</a>()</code>
</p>

<hr>
<h2 id='box_pred_kernel'>Box predation kernel</h2><span id='topic+box_pred_kernel'></span>

<h3>Description</h3>

<p>A predation kernel where the predator/prey mass ratio is uniformly
distributed on an interval.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>box_pred_kernel(ppmr, ppmr_min, ppmr_max)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="box_pred_kernel_+3A_ppmr">ppmr</code></td>
<td>
<p>A vector of predator/prey size ratios</p>
</td></tr>
<tr><td><code id="box_pred_kernel_+3A_ppmr_min">ppmr_min</code></td>
<td>
<p>Minimum predator/prey mass ratio</p>
</td></tr>
<tr><td><code id="box_pred_kernel_+3A_ppmr_max">ppmr_max</code></td>
<td>
<p>Maximum predator/prey mass ratio</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Writing the predator mass as <code class="reqn">w</code> and the prey mass as <code class="reqn">w_p</code>, the
feeding kernel is 1 if <code class="reqn">w/w_p</code> is between <code>ppmr_min</code> and
<code>ppmr_max</code> and zero otherwise. The parameters need to be given in the
species parameter dataframe in the columns <code>ppmr_min</code> and
<code>ppmr_max</code>.
</p>


<h3>Value</h3>

<p>A vector giving the value of the predation kernel at each of the
predator/prey mass ratios in the <code>ppmr</code> argument.
</p>


<h3>See Also</h3>

<p>Other predation kernel: 
<code><a href="#topic+lognormal_pred_kernel">lognormal_pred_kernel</a>()</code>,
<code><a href="#topic+power_law_pred_kernel">power_law_pred_kernel</a>()</code>,
<code><a href="#topic+truncated_lognormal_pred_kernel">truncated_lognormal_pred_kernel</a>()</code>
</p>

<hr>
<h2 id='calibrateBiomass'>Calibrate the model scale to match total observed biomass</h2><span id='topic+calibrateBiomass'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
Given a MizerParams object <code>params</code> for which biomass observations are
available for at least some species via the <code>biomass_observed</code> column in the
species_params data frame, this function returns an updated MizerParams
object which is rescaled with <code><a href="#topic+scaleModel">scaleModel()</a></code> so that the total biomass in
the model agrees with the total observed biomass.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calibrateBiomass(params)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calibrateBiomass_+3A_params">params</code></td>
<td>
<p>A MizerParams object</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Biomass observations usually only include individuals above a certain size.
This size should be specified in a biomass_cutoff column of the species
parameter data frame. If this is missing, it is assumed that all sizes are
included in the observed biomass, i.e., it includes larval biomass.
</p>
<p>After using this function the total biomass in the model will match the
total biomass, summed over all species. However the biomasses of the
individual species will not match observations yet, with some species
having biomasses that are too high and others too low. So after this
function you may want to use <code><a href="#topic+matchBiomasses">matchBiomasses()</a></code>. This is described in the
blog post at https://bit.ly/2YqXESV.
</p>
<p>If you have observations of the yearly yield instead of biomasses, you can
use <code><a href="#topic+calibrateYield">calibrateYield()</a></code> instead of this function.
</p>


<h3>Value</h3>

<p>A MizerParams object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>params &lt;- NS_params
species_params(params)$biomass_observed &lt;- 
    c(0.8, 61, 12, 35, 1.6, 20, 10, 7.6, 135, 60, 30, 78)
species_params(params)$biomass_cutoff &lt;- 10
params2 &lt;- calibrateBiomass(params)
plotBiomassObservedVsModel(params2)
</code></pre>

<hr>
<h2 id='calibrateNumber'>Calibrate the model scale to match total observed number</h2><span id='topic+calibrateNumber'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
Given a MizerParams object <code>params</code> for which number observations are
available for at least some species via the <code>number_observed</code> column in the
species_params data frame, this function returns an updated MizerParams
object which is rescaled with <code><a href="#topic+scaleModel">scaleModel()</a></code> so that the total number in
the model agrees with the total observed number.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calibrateNumber(params)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calibrateNumber_+3A_params">params</code></td>
<td>
<p>A MizerParams object</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Number observations usually only include individuals above a certain size.
This size should be specified in a number_cutoff column of the species
parameter data frame. If this is missing, it is assumed that all sizes are
included in the observed number, i.e., it includes larval number.
</p>
<p>After using this function the total number in the model will match the
total number, summed over all species. However the numbers of the
individual species will not match observations yet, with some species
having numbers that are too high and others too low. So after this
function you may want to use <code><a href="#topic+matchNumbers">matchNumbers()</a></code>. This is described in the
blog post at https://bit.ly/2YqXESV.
</p>
<p>If you have observations of the yearly yield instead of numbers, you can
use <code><a href="#topic+calibrateYield">calibrateYield()</a></code> instead of this function.
</p>


<h3>Value</h3>

<p>A MizerParams object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>params &lt;- NS_params
species_params(params)$number_observed &lt;-
    c(0.8, 61, 12, 35, 1.6, 20, 10, 7.6, 135, 60, 30, 78)
species_params(params)$number_cutoff &lt;- 10
params2 &lt;- calibrateNumber(params)
</code></pre>

<hr>
<h2 id='calibrateYield'>Calibrate the model scale to match total observed yield</h2><span id='topic+calibrateYield'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
Given a MizerParams object <code>params</code> for which yield observations are
available for at least some species via the <code>yield_observed</code> column in the
species_params data frame, this function returns an updated MizerParams
object which is rescaled with <code><a href="#topic+scaleModel">scaleModel()</a></code> so that the total yield in
the model agrees with the total observed yield.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calibrateYield(params)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calibrateYield_+3A_params">params</code></td>
<td>
<p>A MizerParams object</p>
</td></tr>
</table>


<h3>Details</h3>

<p>After using this function the total yield in the model will match the
total observed yield, summed over all species. However the yields of the
individual species will not match observations yet, with some species
having yields that are too high and others too low. So after this
function you may want to use <code><a href="#topic+matchYields">matchYields()</a></code>.
</p>
<p>If you have observations of species biomasses instead of yields, you can
use <code><a href="#topic+calibrateBiomass">calibrateBiomass()</a></code> instead of this function.
</p>


<h3>Value</h3>

<p>A MizerParams object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>params &lt;- NS_params
species_params(params)$yield_observed &lt;-
    c(0.8, 61, 12, 35, 1.6, 20, 10, 7.6, 135, 60, 30, 78)
gear_params(params)$catchability &lt;-
    c(1.3, 0.065, 0.31, 0.18, 0.98, 0.24, 0.37, 0.46, 0.18, 0.30, 0.27, 0.39)
params2 &lt;- calibrateYield(params)
plotYieldObservedVsModel(params2)
</code></pre>

<hr>
<h2 id='compareParams'>Compare two MizerParams objects and print out differences</h2><span id='topic+compareParams'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compareParams(params1, params2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compareParams_+3A_params1">params1</code></td>
<td>
<p>First MizerParams object</p>
</td></tr>
<tr><td><code id="compareParams_+3A_params2">params2</code></td>
<td>
<p>Second MizerParams object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>String describing the differences
</p>


<h3>Examples</h3>

<pre><code class='language-R'>params1 &lt;- NS_params
params2 &lt;- params1
species_params(params2)$w_mat[1] &lt;- 10
compareParams(params1, params2)
</code></pre>

<hr>
<h2 id='completeSpeciesParams'>Complete species parameter data frame with default values</h2><span id='topic+completeSpeciesParams'></span>

<h3>Description</h3>

<p>Sets defaults for missing but required species parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>completeSpeciesParams(species_params)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="completeSpeciesParams_+3A_species_params">species_params</code></td>
<td>
<p>The user-supplied species parameter data frame</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A completed species parameter data frame
</p>
<p>The function sets default values if any of the following species parameters
are missing or NA:
</p>

<ul>
<li> <p><code>w_mat</code> is set to <code>w_max/4</code>
</p>
</li>
<li> <p><code>w_min</code> is set to <code>0.001</code>
</p>
</li>
<li> <p><code>alpha</code> is set to <code>0.6</code>
</p>
</li>
<li> <p><code>interaction_resource</code> is set to <code>1</code>
</p>
</li>
<li> <p><code>n</code> is set to <code>3/4</code>
</p>
</li></ul>

<p>It calls <code><a href="#topic+validSpeciesParams">validSpeciesParams()</a></code> to check the validity of the species
parameters. Nevertheless the species parameters returned by this function are not guaranteed
to produce a viable model. More checks of the parameters are performed by the
individual rate-setting functions (see <code><a href="#topic+setParams">setParams()</a></code> for the list of these
functions).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+species_params">species_params()</a></code>, <code><a href="#topic+validSpeciesParams">validSpeciesParams()</a></code>
</p>

<hr>
<h2 id='constant_other'>Helper function to keep other components constant</h2><span id='topic+constant_other'></span>

<h3>Description</h3>

<p>Helper function to keep other components constant
</p>


<h3>Usage</h3>

<pre><code class='language-R'>constant_other(params, n_other, component, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="constant_other_+3A_params">params</code></td>
<td>
<p>MizerParams object</p>
</td></tr>
<tr><td><code id="constant_other_+3A_n_other">n_other</code></td>
<td>
<p>Abundances of other components</p>
</td></tr>
<tr><td><code id="constant_other_+3A_component">component</code></td>
<td>
<p>Name of the component that is being updated</p>
</td></tr>
<tr><td><code id="constant_other_+3A_...">...</code></td>
<td>
<p>Unused</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The current value of the component
</p>

<hr>
<h2 id='constantEggRDI'>Choose egg production to keep egg density constant</h2><span id='topic+constantEggRDI'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
The new egg production is set to compensate for the loss of individuals from
the smallest size class through growth and mortality. The result should not
be modified by density dependence, so this should be used together with
the <code>noRDD()</code> function, see example.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>constantEggRDI(params, n, e_growth, mort, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="constantEggRDI_+3A_params">params</code></td>
<td>
<p>A MizerParams object</p>
</td></tr>
<tr><td><code id="constantEggRDI_+3A_n">n</code></td>
<td>
<p>A matrix of species abundances (species x size).</p>
</td></tr>
<tr><td><code id="constantEggRDI_+3A_e_growth">e_growth</code></td>
<td>
<p>A two dimensional array (species x size) holding the energy
available for growth as calculated by <code><a href="#topic+mizerEGrowth">mizerEGrowth()</a></code>.</p>
</td></tr>
<tr><td><code id="constantEggRDI_+3A_mort">mort</code></td>
<td>
<p>A two dimensional array (species x size) holding the mortality
rate as calculated by <code><a href="#topic+mizerMort">mizerMort()</a></code>.</p>
</td></tr>
<tr><td><code id="constantEggRDI_+3A_...">...</code></td>
<td>
<p>Unused</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector with the value for each species
</p>


<h3>See Also</h3>

<p>Other functions calculating density-dependent reproduction rate: 
<code><a href="#topic+BevertonHoltRDD">BevertonHoltRDD</a>()</code>,
<code><a href="#topic+RickerRDD">RickerRDD</a>()</code>,
<code><a href="#topic+SheperdRDD">SheperdRDD</a>()</code>,
<code><a href="#topic+constantRDD">constantRDD</a>()</code>,
<code><a href="#topic+noRDD">noRDD</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# choose an example params object
params &lt;- NS_params
# We set the reproduction rate functions
params &lt;- setRateFunction(params, "RDI", "constantEggRDI")
params &lt;- setRateFunction(params, "RDD", "noRDD")
# Now the egg density should stay fixed no matter how we fish
sim &lt;- project(params, effort = 10, progress_bar = FALSE)
# To check that indeed the egg densities have not changed, we first construct
# the indices for addressing the egg densities
no_sp &lt;- nrow(params@species_params)
idx &lt;- (params@w_min_idx - 1) * no_sp + (1:no_sp)
# Now we can check equality between egg densities at the start and the end
all.equal(finalN(sim)[idx], initialN(params)[idx])

</code></pre>

<hr>
<h2 id='constantRDD'>Give constant reproduction rate</h2><span id='topic+constantRDD'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
Simply returns the value from <code>species_params$constant_reproduction</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>constantRDD(rdi, species_params, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="constantRDD_+3A_rdi">rdi</code></td>
<td>
<p>Vector of density-independent reproduction rates
<code class="reqn">R_{di}</code> for all species.</p>
</td></tr>
<tr><td><code id="constantRDD_+3A_species_params">species_params</code></td>
<td>
<p>A species parameter dataframe. Must contain a column
<code>constant_reproduction</code>.</p>
</td></tr>
<tr><td><code id="constantRDD_+3A_...">...</code></td>
<td>
<p>Unused</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector <code>species_params$constant_reproduction</code>
</p>


<h3>See Also</h3>

<p>Other functions calculating density-dependent reproduction rate: 
<code><a href="#topic+BevertonHoltRDD">BevertonHoltRDD</a>()</code>,
<code><a href="#topic+RickerRDD">RickerRDD</a>()</code>,
<code><a href="#topic+SheperdRDD">SheperdRDD</a>()</code>,
<code><a href="#topic+constantEggRDI">constantEggRDI</a>()</code>,
<code><a href="#topic+noRDD">noRDD</a>()</code>
</p>

<hr>
<h2 id='customFunction'>Replace a mizer function with a custom version</h2><span id='topic+customFunction'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
This function allows you to make arbitrary changes to how mizer works by
allowing you to replace any mizer function with your own version. You
should do this only as a last resort, when you find that you can not use
the standard mizer extension mechanism to achieve your goal.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>customFunction(name, fun)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="customFunction_+3A_name">name</code></td>
<td>
<p>Name of mizer function to replace</p>
</td></tr>
<tr><td><code id="customFunction_+3A_fun">fun</code></td>
<td>
<p>The custom function to use as replacement</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the function you need to overwrite is one of the mizer rate functions,
then you should use <code>setRateFunction()</code> instead of this function. Similarly
you should use <code style="white-space: pre;">&#8288;resource_dynamics()&lt;-&#8288;</code> to change the resource dynamics and
<code>setReproduction()</code> to change the density-dependence in reproduction.
You should also investigate whether you can achieve your goal by introducing
additional ecosystem components with <code>setComponent()</code>.
</p>
<p>If you find that your goal really does require you to overwrite a mizer
function, please also create an issue on the mizer issue tracker at
<a href="https://github.com/sizespectrum/mizer/issues">https://github.com/sizespectrum/mizer/issues</a> to
describe your goal, because it will be interesting to the mizer community
and may motivate future improvements to the mizer functionality.
</p>
<p>Note that <code>customFunction()</code> only overwrites the function used by the mizer
code. It does not overwrite the function that is exported by mizer. This
will become clear when you run the code in the Examples section.
</p>
<p>This function does not in any way check that your replacement function is
compatible with mizer. Calling this function can totally break mizer.
However you can always undo the effect by reloading mizer with
</p>
<div class="sourceCode"><pre>detach(package:mizer, unload = TRUE)
library(mizer)
</pre></div>


<h3>Value</h3>

<p>No return value, called for side effects
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
fake_project &lt;- function(...) "Fake"
customFunction("project", fake_project)
mizer::project(NS_params) # This will print "Fake"
project(NS_params) # This will still use the old project() function
# To undo the effect:
customFunction("project", project)
mizer::project(NS_params) # This will again use the old project()

## End(Not run)
</code></pre>

<hr>
<h2 id='default_pred_kernel_params'>Set defaults for predation kernel parameters</h2><span id='topic+default_pred_kernel_params'></span>

<h3>Description</h3>

<p>If the predation kernel type has not been specified for a species, then it
is set to &quot;lognormal&quot; and the default values are set for the parameters
<code>beta</code> and <code>sigma</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>default_pred_kernel_params(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="default_pred_kernel_params_+3A_object">object</code></td>
<td>
<p>Either a MizerParams object or a species parameter data frame</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The <code>object</code> with updated columns in the species params data frame.
</p>

<hr>
<h2 id='defaults_edition'>Default editions</h2><span id='topic+defaults_edition'></span>

<h3>Description</h3>

<p>Function to set and get which edition of default choices is being used.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>defaults_edition(edition = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="defaults_edition_+3A_edition">edition</code></td>
<td>
<p>NULL or a numerical value.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The mizer functions for creating new models make a lot of choices for default
values for parameters that are not provided by the user. Sometimes we find
better ways to choose the defaults and update mizer accordingly. When we do
this, we will increase the edition number.
</p>
<p>If you call <code>defaults_edition()</code> without an argument it returns the
currently active edition. Otherwise it sets the active edition to the
given value.
</p>
<p>Users who want their existing code for creating models not to change
behaviour when run with future versions of mizer should explicitly set the
desired defaults edition at the top of their code.
</p>
<p>The most recent edition is edition 2. It will become the default in the
next release. The current default is edition 1. The following defaults
are changed in edition 2:
</p>

<ul>
<li><p> catchability = 0.3 instead of 1
</p>
</li>
<li><p> initial effort = 1 instead of 0
</p>
</li></ul>



<h3>Value</h3>

<p>The current edition number.
</p>

<hr>
<h2 id='different'>Check whether two objects are different</h2><span id='topic+different'></span>

<h3>Description</h3>

<p>Check whether two objects are numerically different, ignoring all attributes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>different(a, b)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="different_+3A_a">a</code></td>
<td>
<p>First object</p>
</td></tr>
<tr><td><code id="different_+3A_b">b</code></td>
<td>
<p>Second object</p>
</td></tr>
</table>


<h3>Details</h3>

<p>We use this helper function in particular to see if a new value for a slot
in MizerParams is different from the existing value in order to give the
appropriate messages.
</p>


<h3>Value</h3>

<p>TRUE or FALSE
</p>

<hr>
<h2 id='distanceMaxRelRDI'>Measure distance between current and previous state in terms of RDI</h2><span id='topic+distanceMaxRelRDI'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>
<p>This function can be used in <code><a href="#topic+projectToSteady">projectToSteady()</a></code> to decide when sufficient
convergence to steady state has been achieved.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distanceMaxRelRDI(params, current, previous)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="distanceMaxRelRDI_+3A_params">params</code></td>
<td>
<p>MizerParams</p>
</td></tr>
<tr><td><code id="distanceMaxRelRDI_+3A_current">current</code></td>
<td>
<p>A named list with entries <code>n</code>, <code>n_pp</code> and <code>n_other</code>
describing the current state</p>
</td></tr>
<tr><td><code id="distanceMaxRelRDI_+3A_previous">previous</code></td>
<td>
<p>A named list with entries <code>n</code>, <code>n_pp</code> and <code>n_other</code>
describing the previous state</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The largest absolute relative change in rdi:
<code>max(abs((current_rdi - previous_rdi) / previous_rdi))</code>
</p>


<h3>See Also</h3>

<p>Other distance functions: 
<code><a href="#topic+distanceSSLogN">distanceSSLogN</a>()</code>
</p>

<hr>
<h2 id='distanceSSLogN'>Measure distance between current and previous state in terms of fish abundances</h2><span id='topic+distanceSSLogN'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>
<p>Calculates the sum squared difference between log(N) in current and previous
state. This function can be used in <code><a href="#topic+projectToSteady">projectToSteady()</a></code> to decide when
sufficient convergence to steady state has been achieved.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distanceSSLogN(params, current, previous)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="distanceSSLogN_+3A_params">params</code></td>
<td>
<p>MizerParams</p>
</td></tr>
<tr><td><code id="distanceSSLogN_+3A_current">current</code></td>
<td>
<p>A named list with entries <code>n</code>, <code>n_pp</code> and <code>n_other</code>
describing the current state</p>
</td></tr>
<tr><td><code id="distanceSSLogN_+3A_previous">previous</code></td>
<td>
<p>A named list with entries <code>n</code>, <code>n_pp</code> and <code>n_other</code>
describing the previous state</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The sum of squares of the difference in the logs of the (nonzero)
fish abundances n:
<code>sum((log(current$n) - log(previous$n))^2)</code>
</p>


<h3>See Also</h3>

<p>Other distance functions: 
<code><a href="#topic+distanceMaxRelRDI">distanceMaxRelRDI</a>()</code>
</p>

<hr>
<h2 id='double_sigmoid_length'>Length based double-sigmoid selectivity function</h2><span id='topic+double_sigmoid_length'></span>

<h3>Description</h3>

<p>A hump-shaped selectivity function with a sigmoidal rise and an independent
sigmoidal drop-off. This drop-off is what distinguishes this from the
function <code><a href="#topic+sigmoid_length">sigmoid_length()</a></code> and it is intended to model the escape
of large individuals from the fishing gear.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>double_sigmoid_length(w, l25, l50, l50_right, l25_right, species_params, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="double_sigmoid_length_+3A_w">w</code></td>
<td>
<p>Vector of sizes.</p>
</td></tr>
<tr><td><code id="double_sigmoid_length_+3A_l25">l25</code></td>
<td>
<p>the length which gives a selectivity of 25%.</p>
</td></tr>
<tr><td><code id="double_sigmoid_length_+3A_l50">l50</code></td>
<td>
<p>the length which gives a selectivity of 50%.</p>
</td></tr>
<tr><td><code id="double_sigmoid_length_+3A_l50_right">l50_right</code></td>
<td>
<p>the length which gives a selectivity of 50%.</p>
</td></tr>
<tr><td><code id="double_sigmoid_length_+3A_l25_right">l25_right</code></td>
<td>
<p>the length which gives a selectivity of 25%.</p>
</td></tr>
<tr><td><code id="double_sigmoid_length_+3A_species_params">species_params</code></td>
<td>
<p>A list with the species params for the current species.
Used to get at the length-weight parameters <code>a</code> and <code>b</code></p>
</td></tr>
<tr><td><code id="double_sigmoid_length_+3A_...">...</code></td>
<td>
<p>Unused</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The selectivity is obtained as the product of two sigmoidal curves, one
rising and one dropping. The sigmoidal rise is based on the two parameters
<code>l25</code> and <code>l50</code> which determine the length at which 25% and 50%
of the stock is selected respectively. The sigmoidal drop-off is based on the
two parameters <code>l50_right</code> and <code>l25_right</code> which determine the
length at which the selectivity curve has dropped back to 50% and 25%
respectively.
</p>
<p>As the size-based model is weight based, and this
selectivity function is length based, it uses the
length-weight parameters <code>a</code> and <code>b</code> to convert between length and weight.
</p>


<h3>Value</h3>

<p>Vector of selectivities at the given sizes.
</p>


<h3>See Also</h3>

<p>Other selectivity functions: 
<code><a href="#topic+knife_edge">knife_edge</a>()</code>,
<code><a href="#topic+sigmoid_length">sigmoid_length</a>()</code>,
<code><a href="#topic+sigmoid_weight">sigmoid_weight</a>()</code>
</p>

<hr>
<h2 id='emptyParams'>Create empty MizerParams object of the right size</h2><span id='topic+emptyParams'></span>

<h3>Description</h3>

<p>An internal function.
Sets up a valid <a href="#topic+MizerParams-class">MizerParams</a> object with all the slots
initialised and given dimension names, but with some slots left empty. This
function is to be used by other functions to set up full parameter objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>emptyParams(
  species_params,
  gear_params = data.frame(),
  no_w = 100,
  min_w = 0.001,
  max_w = NA,
  min_w_pp = 1e-12
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="emptyParams_+3A_species_params">species_params</code></td>
<td>
<p>A data frame of species-specific parameter values.</p>
</td></tr>
<tr><td><code id="emptyParams_+3A_gear_params">gear_params</code></td>
<td>
<p>A data frame with gear-specific parameter values.</p>
</td></tr>
<tr><td><code id="emptyParams_+3A_no_w">no_w</code></td>
<td>
<p>The number of size bins in the consumer spectrum.</p>
</td></tr>
<tr><td><code id="emptyParams_+3A_min_w">min_w</code></td>
<td>
<p>Sets the size of the eggs of all species for which this is not
given in the <code>w_min</code> column of the <code>species_params</code> dataframe.</p>
</td></tr>
<tr><td><code id="emptyParams_+3A_max_w">max_w</code></td>
<td>
<p>The largest size of the consumer spectrum. By default this is
set to the largest <code>w_max</code> specified in the <code>species_params</code> data
frame.</p>
</td></tr>
<tr><td><code id="emptyParams_+3A_min_w_pp">min_w_pp</code></td>
<td>
<p>The smallest size of the resource spectrum.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An empty but valid MizerParams object
</p>


<h3>Size grid</h3>

<p>A size grid is created so that
the log-sizes are equally spaced. The spacing is chosen so that there will be
<code>no_w</code> fish size bins, with the smallest starting at <code>min_w</code> and the largest
starting at <code>max_w</code>. For the resource spectrum there is a larger set of
bins containing additional bins below
<code>min_w</code>, with the same log size. The number of extra bins is such that
<code>min_w_pp</code> comes to lie within the smallest bin.
</p>


<h3>Changes to species params</h3>

<p>The <code>species_params</code> slot of the returned MizerParams object may differ
from the data frame supplied as argument to this function because
default values are set for missing parameters.
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+newMultispeciesParams">newMultispeciesParams()</a></code> for a function that fills
the slots left empty by this function.
</p>

<hr>
<h2 id='finalN'>Size spectra at end of simulation</h2><span id='topic+finalN'></span><span id='topic+finalNResource'></span>

<h3>Description</h3>

<p>Size spectra at end of simulation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>finalN(sim)

finalNResource(sim)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="finalN_+3A_sim">sim</code></td>
<td>
<p>A MizerSim object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For <code>finalN()</code>: An array (species x size) holding the consumer
number densities at the end of the simulation
</p>
<p>For <code>finalNResource()</code>: A vector holding the resource number
densities at the end of the simulation for all size classes
</p>


<h3>See Also</h3>

<p><code><a href="#topic+idxFinalT">idxFinalT()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>str(finalN(NS_sim))

# This could also be obtained using `N()` and `idxFinalT()`
identical(N(NS_sim)[idxFinalT(NS_sim), , ], finalN(NS_sim))
str(finalNResource(NS_sim))
</code></pre>

<hr>
<h2 id='finalNOther'>Values of other ecosystem components at end of simulation</h2><span id='topic+finalNOther'></span>

<h3>Description</h3>

<p>Values of other ecosystem components at end of simulation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>finalNOther(sim)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="finalNOther_+3A_sim">sim</code></td>
<td>
<p>A MizerSim object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named list holding the values of other ecosystem components at the
end of the simulation
</p>

<hr>
<h2 id='gear_params'>Gear parameters</h2><span id='topic+gear_params'></span><span id='topic+gear_params+3C-'></span>

<h3>Description</h3>

<p>These functions allow you to get or set the gear parameters stored in
a MizerParams object. These are used by <code><a href="#topic+setFishing">setFishing()</a></code> to set up the
selectivity and catchability and thus together with the fishing effort
determine the fishing mortality.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gear_params(params)

gear_params(params) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gear_params_+3A_params">params</code></td>
<td>
<p>A MizerParams object</p>
</td></tr>
<tr><td><code id="gear_params_+3A_value">value</code></td>
<td>
<p>A data frame with the gear parameters.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>gear_params</code> data has one row for each gear-species pair and one
column for each parameter that determines how that gear interacts with that
species. The columns are:
</p>

<ul>
<li> <p><code>species</code> The name of the species
</p>
</li>
<li> <p><code>gear</code> The name of the gear
</p>
</li>
<li> <p><code>catchability</code> A number specifying how strongly this gear selects this
species.
</p>
</li>
<li> <p><code>sel_func</code> The name of the function that calculates the selectivity curve.
</p>
</li>
<li><p> One column for each selectivity parameter needed by the selectivity
functions.
</p>
</li></ul>

<p>For the details see <code><a href="#topic+setFishing">setFishing()</a></code>.
</p>
<p>There can optionally also be a column <code>yield_observed</code> that allows you to
specify for each gear and species the total annual fisheries yield. This is
used by <code><a href="#topic+calibrateYield">calibrateYield()</a></code> and <code><a href="#topic+matchYields">matchYields()</a></code>.
</p>
<p>The fishing effort, which is also needed to determine the fishing mortality
exerted by a gear is not set via the <code>gear_params</code> data frame but is set
with <code>initial_effort()</code> or is specified when calling <code>project()</code>.
</p>
<p>If you change a gear parameter, this will be used to recalculate the
<code>selectivity</code> and <code>catchability</code> arrays by calling <code><a href="#topic+setFishing">setFishing()</a></code>,
unless you have previously set these by hand.
</p>
<p><code style="white-space: pre;">&#8288;gear_params&lt;-&#8288;</code> automatically sets the row names to contain the species name
and the gear name, separated by a comma and a space. The last example below
illustrates how this facilitates changing an individual gear parameter.
</p>


<h3>Value</h3>

<p>Data frame with gear parameters
</p>


<h3>See Also</h3>

<p><code><a href="#topic+validGearParams">validGearParams()</a></code>
</p>
<p>Other functions for setting parameters: 
<code><a href="#topic+setExtEncounter">setExtEncounter</a>()</code>,
<code><a href="#topic+setExtMort">setExtMort</a>()</code>,
<code><a href="#topic+setFishing">setFishing</a>()</code>,
<code><a href="#topic+setInitialValues">setInitialValues</a>()</code>,
<code><a href="#topic+setInteraction">setInteraction</a>()</code>,
<code><a href="#topic+setMaxIntakeRate">setMaxIntakeRate</a>()</code>,
<code><a href="#topic+setMetabolicRate">setMetabolicRate</a>()</code>,
<code><a href="#topic+setParams">setParams</a>()</code>,
<code><a href="#topic+setPredKernel">setPredKernel</a>()</code>,
<code><a href="#topic+setReproduction">setReproduction</a>()</code>,
<code><a href="#topic+setSearchVolume">setSearchVolume</a>()</code>,
<code><a href="#topic+species_params">species_params</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>params &lt;- NS_params

# gears set up in example
gear_params(params)

# setting totally different gears
gear_params(params) &lt;- data.frame(
    gear = c("gear1", "gear2", "gear1"),
    species = c("Cod", "Cod", "Haddock"),
    catchability = c(0.5, 2, 1),
    sel_fun = c("sigmoid_weight", "knife_edge", "sigmoid_weight"),
    sigmoidal_weight = c(1000, NA, 800),
    sigmoidal_sigma = c(100, NA, 100),
    knife_edge_size = c(NA, 1000, NA)
    )
gear_params(params)

# changing an individual entry
gear_params(params)["Cod, gear1", "catchability"] &lt;- 0.8
</code></pre>

<hr>
<h2 id='get_f0_default'>Get default value for f0</h2><span id='topic+get_f0_default'></span>

<h3>Description</h3>

<p>Fills in any missing values for f0 so that if the prey abundance was
described by the power law <code class="reqn">\kappa w^{-\lambda}</code> then the encounter rate
coming from the given <code>gamma</code> parameter would lead to the feeding level
<code class="reqn">f_0</code>. This is thus doing the inverse of <code><a href="#topic+get_gamma_default">get_gamma_default()</a></code>.
Only for internal use.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_f0_default(params)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_f0_default_+3A_params">params</code></td>
<td>
<p>A MizerParams object</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For species for which no value for <code>gamma</code> is specified in the species
parameter data frame, the <code>f0</code> values is kept as provided in the species
parameter data frame or it is set to 0.6 if it is not provided.
</p>


<h3>Value</h3>

<p>A vector with the values of f0 for all species
</p>


<h3>See Also</h3>

<p>Other functions calculating defaults: 
<code><a href="#topic+get_gamma_default">get_gamma_default</a>()</code>,
<code><a href="#topic+get_h_default">get_h_default</a>()</code>,
<code><a href="#topic+get_ks_default">get_ks_default</a>()</code>
</p>

<hr>
<h2 id='get_gamma_default'>Get default value for gamma</h2><span id='topic+get_gamma_default'></span>

<h3>Description</h3>

<p>Fills in any missing values for gamma so that fish feeding on a resource
spectrum described by the power law <code class="reqn">\kappa w^{-\lambda}</code> achieve a
feeding level <code class="reqn">f_0</code>. Only for internal use.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_gamma_default(params)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_gamma_default_+3A_params">params</code></td>
<td>
<p>A MizerParams object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector with the values of gamma for all species
</p>


<h3>See Also</h3>

<p>Other functions calculating defaults: 
<code><a href="#topic+get_f0_default">get_f0_default</a>()</code>,
<code><a href="#topic+get_h_default">get_h_default</a>()</code>,
<code><a href="#topic+get_ks_default">get_ks_default</a>()</code>
</p>

<hr>
<h2 id='get_h_default'>Get default value for h</h2><span id='topic+get_h_default'></span>

<h3>Description</h3>

<p>Sets <code>h</code> so that the species reaches maturity size <code>w_mat</code> at the maturity
age <code>age_mat</code> if it feeds at feeding level <code>f0</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_h_default(params)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_h_default_+3A_params">params</code></td>
<td>
<p>A MizerParams object or a species parameter data frame</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>age_mat</code> is missing in the species parameter data frame, then it is
calculated from the von Bertalanffy growth curve parameters <code>k_vb</code> and
(optionally <code>t0</code>) taken from the species parameter data frame. This is not
reliable and a warning is issued.
</p>
<p>If no growth information is given at all for a species, the default is set
to <code>h = 30</code>.
</p>


<h3>Value</h3>

<p>A vector with the values of h for all species
</p>


<h3>See Also</h3>

<p>Other functions calculating defaults: 
<code><a href="#topic+get_f0_default">get_f0_default</a>()</code>,
<code><a href="#topic+get_gamma_default">get_gamma_default</a>()</code>,
<code><a href="#topic+get_ks_default">get_ks_default</a>()</code>
</p>

<hr>
<h2 id='get_initial_n'>Calculate initial population abundances</h2><span id='topic+get_initial_n'></span>

<h3>Description</h3>

<p>This function uses the model parameters and other parameters to calculate
initial values for the species number densities. These initial
abundances are currently quite arbitrary and not close to the steady state.
We intend to improve this in the future.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_initial_n(params, n0_mult = NULL, a = 0.35)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_initial_n_+3A_params">params</code></td>
<td>
<p>The model parameters. An object of type
<a href="#topic+MizerParams-class">MizerParams</a>.</p>
</td></tr>
<tr><td><code id="get_initial_n_+3A_n0_mult">n0_mult</code></td>
<td>
<p>Multiplier for the abundance at size 0. Default value is
kappa/1000.</p>
</td></tr>
<tr><td><code id="get_initial_n_+3A_a">a</code></td>
<td>
<p>A parameter with a default value of 0.35.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix (species x size) of population abundances.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>init_n &lt;- get_initial_n(NS_params)
</code></pre>

<hr>
<h2 id='get_ks_default'>Get default value for <code>ks</code></h2><span id='topic+get_ks_default'></span>

<h3>Description</h3>

<p>Fills in any missing values for <code>ks</code> so that the critical feeding level needed
to sustain the species is as specified in the <code>fc</code> column in the species
parameter data frame. If that column is not provided the default critical
feeding level <code class="reqn">f_c = 0.2</code> is used.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_ks_default(params)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_ks_default_+3A_params">params</code></td>
<td>
<p>A MizerParams object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector with the values of ks for all species
</p>


<h3>See Also</h3>

<p>Other functions calculating defaults: 
<code><a href="#topic+get_f0_default">get_f0_default</a>()</code>,
<code><a href="#topic+get_gamma_default">get_gamma_default</a>()</code>,
<code><a href="#topic+get_h_default">get_h_default</a>()</code>
</p>

<hr>
<h2 id='get_phi'>Get values from feeding kernel function</h2><span id='topic+get_phi'></span>

<h3>Description</h3>

<p>This involves finding the feeding kernel function for each species, using the
pred_kernel_type parameter in the species_params data frame, checking that it
is valid and all its arguments are contained in the species_params data
frame, and then calling this function with the ppmr vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_phi(species_params, ppmr)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_phi_+3A_species_params">species_params</code></td>
<td>
<p>A species parameter data frame</p>
</td></tr>
<tr><td><code id="get_phi_+3A_ppmr">ppmr</code></td>
<td>
<p>Values of the predator/prey mass ratio at which to evaluate the
predation kernel function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An array (species x ppmr) with the values of the predation kernel
function
</p>

<hr>
<h2 id='get_required_reproduction'>Determine reproduction rate needed for initial egg abundance</h2><span id='topic+get_required_reproduction'></span>

<h3>Description</h3>

<p>Determine reproduction rate needed for initial egg abundance
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_required_reproduction(params)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_required_reproduction_+3A_params">params</code></td>
<td>
<p>A MizerParams object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of reproduction rates for all species
</p>

<hr>
<h2 id='get_size_range_array'>Get size range array</h2><span id='topic+get_size_range_array'></span>

<h3>Description</h3>

<p>Helper function that returns an array (species x size) of boolean values
indicating whether that size bin is within the size limits specified by the
arguments. Either the size limits can be the same for all species or they
can be specified as vectors with one value for each species in the model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_size_range_array(
  params,
  min_w = min(params@w),
  max_w = max(params@w),
  min_l = NULL,
  max_l = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_size_range_array_+3A_params">params</code></td>
<td>
<p>MizerParams object</p>
</td></tr>
<tr><td><code id="get_size_range_array_+3A_min_w">min_w</code></td>
<td>
<p>Smallest weight in size range. Defaults to smallest weight in
the model.</p>
</td></tr>
<tr><td><code id="get_size_range_array_+3A_max_w">max_w</code></td>
<td>
<p>Largest weight in size range. Defaults to largest weight in the
model.</p>
</td></tr>
<tr><td><code id="get_size_range_array_+3A_min_l">min_l</code></td>
<td>
<p>Smallest length in size range. If supplied, this takes
precedence over <code>min_w</code>.</p>
</td></tr>
<tr><td><code id="get_size_range_array_+3A_max_l">max_l</code></td>
<td>
<p>Largest length in size range. If supplied, this takes precedence
over <code>max_w</code>.</p>
</td></tr>
<tr><td><code id="get_size_range_array_+3A_...">...</code></td>
<td>
<p>Unused</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Boolean array (species x size)
</p>


<h3>Length to weight conversion</h3>

<p>If <code>min_l</code> is specified there is no need to specify <code>min_w</code> and so on.
However, if a length is specified (minimum or maximum) then it is necessary
for the species parameter data.frame to include the parameters <code>a</code> and <code>b</code>
that determine the relation between length <code class="reqn">l</code> and weight <code class="reqn">w</code> by
</p>
<p style="text-align: center;"><code class="reqn">w = a l^b.</code>
</p>

<p>It is possible to mix length and weight constraints, e.g. by supplying a
minimum weight and a maximum length, but this must be done the same for
all species. The default values are the minimum and
maximum weights of the spectrum, i.e., the full range of the size spectrum is
used.
</p>

<hr>
<h2 id='get_time_elements'>Get_time_elements</h2><span id='topic+get_time_elements'></span>

<h3>Description</h3>

<p>Internal function to get the array element references of the time dimension
for the time based slots of a MizerSim object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_time_elements(sim, time_range, slot_name = "n")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_time_elements_+3A_sim">sim</code></td>
<td>
<p>A MizerSim object</p>
</td></tr>
<tr><td><code id="get_time_elements_+3A_time_range">time_range</code></td>
<td>
<p>A vector of times. Only the range of times is relevant,
i.e., all times between the smallest and largest will be selected.
The time_range can be character or numeric.</p>
</td></tr>
<tr><td><code id="get_time_elements_+3A_slot_name">slot_name</code></td>
<td>
<p>Obsolete. Was only needed in early versions of mizer where
the effort slot could have different time dimension from the other slots.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Named boolean vector indicating for each time whether it is included
in the range or not.
</p>

<hr>
<h2 id='getBiomass'>Calculate the total biomass of each species within a size range at each time
step.</h2><span id='topic+getBiomass'></span>

<h3>Description</h3>

<p>Calculates the total biomass through time within user defined size limits.
The default option is to use the whole size range. You can specify minimum
and maximum weight or length range for the species. Lengths take precedence
over weights (i.e. if both min_l and min_w are supplied, only min_l will be
used).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getBiomass(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getBiomass_+3A_object">object</code></td>
<td>
<p>An object of class <code>MizerParams</code> or <code>MizerSim</code>.</p>
</td></tr>
<tr><td><code id="getBiomass_+3A_...">...</code></td>
<td>

<p>Arguments passed on to <code><a href="#topic+get_size_range_array">get_size_range_array</a></code>
</p>

<dl>
<dt><code>min_w</code></dt><dd><p>Smallest weight in size range. Defaults to smallest weight in
the model.</p>
</dd>
<dt><code>max_w</code></dt><dd><p>Largest weight in size range. Defaults to largest weight in the
model.</p>
</dd>
<dt><code>min_l</code></dt><dd><p>Smallest length in size range. If supplied, this takes
precedence over <code>min_w</code>.</p>
</dd>
<dt><code>max_l</code></dt><dd><p>Largest length in size range. If supplied, this takes precedence
over <code>max_w</code>.</p>
</dd>
</dl>
</td></tr>
</table>


<h3>Value</h3>

<p>If called with a MizerParams object, a vector with the biomass in
grams for each species in the model. If called with a MizerSim object, an
array (time x species) containing the biomass in grams at each time step
for all species.
</p>


<h3>See Also</h3>

<p>Other summary functions: 
<code><a href="#topic+getDiet">getDiet</a>()</code>,
<code><a href="#topic+getGrowthCurves">getGrowthCurves</a>()</code>,
<code><a href="#topic+getN">getN</a>()</code>,
<code><a href="#topic+getSSB">getSSB</a>()</code>,
<code><a href="#topic+getYield">getYield</a>()</code>,
<code><a href="#topic+getYieldGear">getYieldGear</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>biomass &lt;- getBiomass(NS_sim)
biomass["1972", "Herring"]
biomass &lt;- getBiomass(NS_sim, min_w = 10, max_w = 1000)
biomass["1972", "Herring"]
</code></pre>

<hr>
<h2 id='getCommunitySlope'>Calculate the slope of the community abundance</h2><span id='topic+getCommunitySlope'></span>

<h3>Description</h3>

<p>Calculates the slope of the community abundance through time by performing a
linear regression on the logged total numerical abundance at weight and
logged weights (natural logs, not log to base 10, are used). You can specify
minimum and maximum weight or length range for the species. Lengths take
precedence over weights (i.e. if both min_l and min_w are supplied, only
min_l will be used). You can also specify the species to be used in the
calculation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getCommunitySlope(sim, species = NULL, biomass = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getCommunitySlope_+3A_sim">sim</code></td>
<td>
<p>A <a href="#topic+MizerSim-class">MizerSim</a> object</p>
</td></tr>
<tr><td><code id="getCommunitySlope_+3A_species">species</code></td>
<td>
<p>The species to be selected. Optional. By default all target
species are selected. A vector of species names, or a
numeric vector with the species indices, or a logical vector indicating for
each species whether it is to be selected (TRUE) or not.</p>
</td></tr>
<tr><td><code id="getCommunitySlope_+3A_biomass">biomass</code></td>
<td>
<p>Boolean. If TRUE (default), the abundance is based on biomass,
if FALSE the abundance is based on numbers.</p>
</td></tr>
<tr><td><code id="getCommunitySlope_+3A_...">...</code></td>
<td>

<p>Arguments passed on to <code><a href="#topic+get_size_range_array">get_size_range_array</a></code>
</p>

<dl>
<dt><code>min_w</code></dt><dd><p>Smallest weight in size range. Defaults to smallest weight in
the model.</p>
</dd>
<dt><code>max_w</code></dt><dd><p>Largest weight in size range. Defaults to largest weight in the
model.</p>
</dd>
<dt><code>min_l</code></dt><dd><p>Smallest length in size range. If supplied, this takes
precedence over <code>min_w</code>.</p>
</dd>
<dt><code>max_l</code></dt><dd><p>Largest length in size range. If supplied, this takes precedence
over <code>max_w</code>.</p>
</dd>
</dl>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame with four columns: time step, slope, intercept and the
coefficient of determination R^2.
</p>


<h3>See Also</h3>

<p>Other functions for calculating indicators: 
<code><a href="#topic+getMeanMaxWeight">getMeanMaxWeight</a>()</code>,
<code><a href="#topic+getMeanWeight">getMeanWeight</a>()</code>,
<code><a href="#topic+getProportionOfLargeFish">getProportionOfLargeFish</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Slope based on biomass, using all species and sizes
slope_biomass &lt;- getCommunitySlope(NS_sim)
slope_biomass[1, ] # in 1976
slope_biomass[idxFinalT(NS_sim), ] # in 2010

# Slope based on numbers, using all species and sizes
slope_numbers &lt;- getCommunitySlope(NS_sim, biomass = FALSE)
slope_numbers[1, ] # in 1976

# Slope based on biomass, using all species and sizes between 10g and 1000g
slope_biomass &lt;- getCommunitySlope(NS_sim, min_w = 10, max_w = 1000)
slope_biomass[1, ] # in 1976

# Slope based on biomass, using only demersal species and 
# sizes between 10g and 1000g
dem_species &lt;- c("Dab","Whiting", "Sole", "Gurnard", "Plaice",
                 "Haddock", "Cod", "Saithe")
slope_biomass &lt;- getCommunitySlope(NS_sim, species = dem_species, 
                                   min_w = 10, max_w = 1000)
slope_biomass[1, ] # in 1976
</code></pre>

<hr>
<h2 id='getComponent'>Get information about other ecosystem components</h2><span id='topic+getComponent'></span>

<h3>Description</h3>

<p>Get information about other ecosystem components
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getComponent(params, component)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getComponent_+3A_params">params</code></td>
<td>
<p>A MizerParams object</p>
</td></tr>
<tr><td><code id="getComponent_+3A_component">component</code></td>
<td>
<p>Name of the component of interest. If missing, a list of
all components will be returned.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the entries <code>initial_value</code>, <code>dynamics_fun</code>,
<code>encounter_fun</code>, <code>mort_fun</code>, <code>component_params</code> for the requested
component. If the requested component does not exist, <code>NULL</code> is returned.
If no <code>component</code> argument is given, then a list of lists for all
components is returned.
</p>

<hr>
<h2 id='getCriticalFeedingLevel'>Get critical feeding level</h2><span id='topic+getCriticalFeedingLevel'></span>

<h3>Description</h3>

<p>The critical feeding level is the feeding level at which the food intake is
just high enough to cover the metabolic costs, with nothing left over for
growth or reproduction.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getCriticalFeedingLevel(params)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getCriticalFeedingLevel_+3A_params">params</code></td>
<td>
<p>A MizerParams object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix (species x size) with the critical feeding level
</p>

<hr>
<h2 id='getDiet'>Get diet of predator at size, resolved by prey species</h2><span id='topic+getDiet'></span>

<h3>Description</h3>

<p>Calculates the rate at which a predator of a particular species and size
consumes biomass of each prey species and resource.
The diet has units of grams/year.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getDiet(
  params,
  n = initialN(params),
  n_pp = initialNResource(params),
  n_other = initialNOther(params),
  proportion = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getDiet_+3A_params">params</code></td>
<td>
<p>A <a href="#topic+MizerParams-class">MizerParams</a> object</p>
</td></tr>
<tr><td><code id="getDiet_+3A_n">n</code></td>
<td>
<p>A matrix of species abundances (species x size).</p>
</td></tr>
<tr><td><code id="getDiet_+3A_n_pp">n_pp</code></td>
<td>
<p>A vector of the resource abundance by size</p>
</td></tr>
<tr><td><code id="getDiet_+3A_n_other">n_other</code></td>
<td>
<p>A list of abundances for other dynamical components of the
ecosystem</p>
</td></tr>
<tr><td><code id="getDiet_+3A_proportion">proportion</code></td>
<td>
<p>If TRUE (default) the function returns the diet as a
proportion of the total consumption rate. If FALSE it returns the
consumption rate in grams per year.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Returns the rates <code class="reqn">D_{ij}(w)</code> at which a predator of species <code class="reqn">i</code>
and size <code class="reqn">w</code> consumes biomass from prey species <code class="reqn">j</code>. This is
calculated from the predation kernel <code class="reqn">\phi_i(w, w_p)</code>,
the search volume <code class="reqn">\gamma_i(w)</code>, the feeding level <code class="reqn">f_i(w)</code>, the
species interaction matrix <code class="reqn">\theta_{ij}</code> and the prey abundance density
<code class="reqn">N_j(w_p)</code>:
</p>
<p style="text-align: center;"><code class="reqn">
D_{ij}(w, w_p) = (1-f_i(w)) \gamma_i(w) \theta_{ij}
\int N_j(w_p) \phi_i(w, w_p) w_p dw_p.
</code>
</p>

<p>The prey index <code class="reqn">j</code> runs over all species and the resource. It also runs
over any extra ecosystem components in your model for which you have
defined an encounter rate function. This encounter rate is multiplied by
<code class="reqn">1-f_i(w)</code> to give the rate of consumption of biomass from these extra
components.
</p>
<p>This function performs the same integration as
<code><a href="#topic+getEncounter">getEncounter()</a></code> but does not aggregate over prey species, and
multiplies by <code class="reqn">1-f_i(w)</code> to get the consumed biomass rather than the
available biomass. Outside the range of sizes for a predator species the
returned rate is zero.
</p>


<h3>Value</h3>

<p>An array (predator species  x predator size x
(prey species + resource + other components) )
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plotDiet">plotDiet()</a></code>
</p>
<p>Other summary functions: 
<code><a href="#topic+getBiomass">getBiomass</a>()</code>,
<code><a href="#topic+getGrowthCurves">getGrowthCurves</a>()</code>,
<code><a href="#topic+getN">getN</a>()</code>,
<code><a href="#topic+getSSB">getSSB</a>()</code>,
<code><a href="#topic+getYield">getYield</a>()</code>,
<code><a href="#topic+getYieldGear">getYieldGear</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>diet &lt;- getDiet(NS_params)
str(diet)
</code></pre>

<hr>
<h2 id='getEffort'>Fishing effort used in simulation</h2><span id='topic+getEffort'></span>

<h3>Description</h3>

<p>Note that the array returned may not be exactly the same as the <code>effort</code>
argument that was passed in to <code>project()</code>. This is because only the saved
effort is stored (the frequency of saving is determined by the argument
<code>t_save</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getEffort(sim)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getEffort_+3A_sim">sim</code></td>
<td>
<p>A MizerSim object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An array (time x gear) that contains the fishing effort by time and
gear.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>str(getEffort(NS_sim))
</code></pre>

<hr>
<h2 id='getEGrowth'>Get energy rate available for growth</h2><span id='topic+getEGrowth'></span>

<h3>Description</h3>

<p>Calculates the energy rate <code class="reqn">g_i(w)</code> (grams/year) available by species and
size for growth after metabolism, movement and reproduction have been
accounted for.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getEGrowth(
  params,
  n = initialN(params),
  n_pp = initialNResource(params),
  n_other = initialNOther(params),
  t = 0,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getEGrowth_+3A_params">params</code></td>
<td>
<p>A <a href="#topic+MizerParams-class">MizerParams</a> object</p>
</td></tr>
<tr><td><code id="getEGrowth_+3A_n">n</code></td>
<td>
<p>A matrix of species abundances (species x size).</p>
</td></tr>
<tr><td><code id="getEGrowth_+3A_n_pp">n_pp</code></td>
<td>
<p>A vector of the resource abundance by size</p>
</td></tr>
<tr><td><code id="getEGrowth_+3A_n_other">n_other</code></td>
<td>
<p>A list of abundances for other dynamical components of the
ecosystem</p>
</td></tr>
<tr><td><code id="getEGrowth_+3A_t">t</code></td>
<td>
<p>The time for which to do the calculation (Not used by standard
mizer rate functions but useful for extensions with time-dependent
parameters.)</p>
</td></tr>
<tr><td><code id="getEGrowth_+3A_...">...</code></td>
<td>
<p>Unused</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A two dimensional array (prey species x prey size)
</p>


<h3>Your own growth rate function</h3>

<p>By default <code><a href="#topic+getEGrowth">getEGrowth()</a></code> calls <code><a href="#topic+mizerEGrowth">mizerEGrowth()</a></code>. However you can
replace this with your own alternative growth rate function. If
your function is called <code>"myEGrowth"</code> then you register it in a MizerParams
object <code>params</code> with
</p>
<div class="sourceCode"><pre>params &lt;- setRateFunction(params, "EGrowth", "myEGrowth")
</pre></div>
<p>Your function will then be called instead of <code><a href="#topic+mizerEGrowth">mizerEGrowth()</a></code>, with the
same arguments.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+getERepro">getERepro()</a></code>, <code><a href="#topic+getEReproAndGrowth">getEReproAndGrowth()</a></code>
</p>
<p>Other rate functions: 
<code><a href="#topic+getERepro">getERepro</a>()</code>,
<code><a href="#topic+getEReproAndGrowth">getEReproAndGrowth</a>()</code>,
<code><a href="#topic+getEncounter">getEncounter</a>()</code>,
<code><a href="#topic+getFMort">getFMort</a>()</code>,
<code><a href="#topic+getFMortGear">getFMortGear</a>()</code>,
<code><a href="#topic+getFeedingLevel">getFeedingLevel</a>()</code>,
<code><a href="#topic+getMort">getMort</a>()</code>,
<code><a href="#topic+getPredMort">getPredMort</a>()</code>,
<code><a href="#topic+getPredRate">getPredRate</a>()</code>,
<code><a href="#topic+getRDD">getRDD</a>()</code>,
<code><a href="#topic+getRDI">getRDI</a>()</code>,
<code><a href="#topic+getRates">getRates</a>()</code>,
<code><a href="#topic+getResourceMort">getResourceMort</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
params &lt;- NS_params
# Project with constant fishing effort for all gears for 20 time steps
sim &lt;- project(params, t_max = 20, effort = 0.5)
# Get the energy at a particular time step
getEGrowth(params, n = N(sim)[15, , ], n_pp = NResource(sim)[15, ], t = 15)

</code></pre>

<hr>
<h2 id='getEncounter'>Get encounter rate</h2><span id='topic+getEncounter'></span>

<h3>Description</h3>

<p>Returns the rate at which a predator of species <code class="reqn">i</code> and
weight <code class="reqn">w</code> encounters food (grams/year).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getEncounter(
  params,
  n = initialN(params),
  n_pp = initialNResource(params),
  n_other = initialNOther(params),
  t = 0,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getEncounter_+3A_params">params</code></td>
<td>
<p>A <a href="#topic+MizerParams-class">MizerParams</a> object</p>
</td></tr>
<tr><td><code id="getEncounter_+3A_n">n</code></td>
<td>
<p>A matrix of species abundances (species x size).</p>
</td></tr>
<tr><td><code id="getEncounter_+3A_n_pp">n_pp</code></td>
<td>
<p>A vector of the resource abundance by size</p>
</td></tr>
<tr><td><code id="getEncounter_+3A_n_other">n_other</code></td>
<td>
<p>A list of abundances for other dynamical components of the
ecosystem</p>
</td></tr>
<tr><td><code id="getEncounter_+3A_t">t</code></td>
<td>
<p>The time for which to do the calculation (Not used by standard
mizer rate functions but useful for extensions with time-dependent
parameters.)</p>
</td></tr>
<tr><td><code id="getEncounter_+3A_...">...</code></td>
<td>
<p>Unused</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named two dimensional array (predator species x predator size) with
the encounter rates.
</p>


<h3>Predation encounter</h3>

<p>The encounter rate <code class="reqn">E_i(w)</code> at which a predator of species <code class="reqn">i</code>
and weight <code class="reqn">w</code> encounters food has contributions from the encounter of
fish prey and of resource. This is determined by summing over all prey
species and the resource spectrum and then integrating over all prey sizes
<code class="reqn">w_p</code>, weighted by predation kernel <code class="reqn">\phi(w,w_p)</code>:
</p>
<p style="text-align: center;"><code class="reqn">
E_i(w) = \gamma_i(w) \int 
\left( \theta_{ip} N_R(w_p) + \sum_{j} \theta_{ij} N_j(w_p) \right) 
\phi_i(w,w_p) w_p \, dw_p.
</code>
</p>

<p>Here <code class="reqn">N_j(w)</code> is the abundance density of species <code class="reqn">j</code> and
<code class="reqn">N_R(w)</code> is the abundance density of resource.
The overall prefactor <code class="reqn">\gamma_i(w)</code> determines the predation power of the
predator. It could be interpreted as a search volume and is set with the
<code><a href="#topic+setSearchVolume">setSearchVolume()</a></code> function. The predation kernel
<code class="reqn">\phi(w,w_p)</code> is set with the <code><a href="#topic+setPredKernel">setPredKernel()</a></code> function. The
species interaction matrix <code class="reqn">\theta_{ij}</code> is set with <code><a href="#topic+setInteraction">setInteraction()</a></code>
and the resource interaction vector <code class="reqn">\theta_{ip}</code> is taken from the
<code>interaction_resource</code> column in <code>params@species_params</code>.
</p>


<h3>Details</h3>

<p>The encounter rate is multiplied by <code class="reqn">1-f_0</code> to obtain the consumption
rate, where <code class="reqn">f_0</code> is the feeding level calculated with
<code><a href="#topic+getFeedingLevel">getFeedingLevel()</a></code>. This is used by the <code><a href="#topic+project">project()</a></code> function for performing
simulations.
</p>
<p>The function returns values also for sizes outside the size-range of the
species. These values should not be used, as they are meaningless.
</p>
<p>If your model contains additional components that you added with
<code><a href="#topic+setComponent">setComponent()</a></code> and for which you specified an <code>encounter_fun</code> function then
the encounters of these components will be included in the returned value.
</p>


<h3>Your own encounter function</h3>

<p>By default <code><a href="#topic+getEncounter">getEncounter()</a></code> calls <code><a href="#topic+mizerEncounter">mizerEncounter()</a></code>. However you can
replace this with your own alternative encounter function. If
your function is called <code>"myEncounter"</code> then you register it in a MizerParams
object <code>params</code> with
</p>
<div class="sourceCode"><pre>params &lt;- setRateFunction(params, "Encounter", "myEncounter")
</pre></div>
<p>Your function will then be called instead of <code><a href="#topic+mizerEncounter">mizerEncounter()</a></code>, with the
same arguments.
</p>


<h3>See Also</h3>

<p>Other rate functions: 
<code><a href="#topic+getEGrowth">getEGrowth</a>()</code>,
<code><a href="#topic+getERepro">getERepro</a>()</code>,
<code><a href="#topic+getEReproAndGrowth">getEReproAndGrowth</a>()</code>,
<code><a href="#topic+getFMort">getFMort</a>()</code>,
<code><a href="#topic+getFMortGear">getFMortGear</a>()</code>,
<code><a href="#topic+getFeedingLevel">getFeedingLevel</a>()</code>,
<code><a href="#topic+getMort">getMort</a>()</code>,
<code><a href="#topic+getPredMort">getPredMort</a>()</code>,
<code><a href="#topic+getPredRate">getPredRate</a>()</code>,
<code><a href="#topic+getRDD">getRDD</a>()</code>,
<code><a href="#topic+getRDI">getRDI</a>()</code>,
<code><a href="#topic+getRates">getRates</a>()</code>,
<code><a href="#topic+getResourceMort">getResourceMort</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>encounter &lt;- getEncounter(NS_params)
str(encounter)
</code></pre>

<hr>
<h2 id='getERepro'>Get energy rate available for reproduction</h2><span id='topic+getERepro'></span>

<h3>Description</h3>

<p>Calculates the energy rate (grams/year) available for reproduction after
growth and metabolism have been accounted for.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getERepro(
  params,
  n = initialN(params),
  n_pp = initialNResource(params),
  n_other = initialNOther(params),
  t = 0,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getERepro_+3A_params">params</code></td>
<td>
<p>A <a href="#topic+MizerParams-class">MizerParams</a> object</p>
</td></tr>
<tr><td><code id="getERepro_+3A_n">n</code></td>
<td>
<p>A matrix of species abundances (species x size).</p>
</td></tr>
<tr><td><code id="getERepro_+3A_n_pp">n_pp</code></td>
<td>
<p>A vector of the resource abundance by size</p>
</td></tr>
<tr><td><code id="getERepro_+3A_n_other">n_other</code></td>
<td>
<p>A list of abundances for other dynamical components of the
ecosystem</p>
</td></tr>
<tr><td><code id="getERepro_+3A_t">t</code></td>
<td>
<p>The time for which to do the calculation (Not used by standard
mizer rate functions but useful for extensions with time-dependent
parameters.)</p>
</td></tr>
<tr><td><code id="getERepro_+3A_...">...</code></td>
<td>
<p>Unused</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A two dimensional array (prey species x prey size) holding
</p>
<p style="text-align: center;"><code class="reqn">\psi_i(w)E_{r.i}(w)</code>
</p>

<p>where <code class="reqn">E_{r.i}(w)</code> is the rate at which energy becomes available for
growth and reproduction, calculated with <code><a href="#topic+getEReproAndGrowth">getEReproAndGrowth()</a></code>,
and <code class="reqn">\psi_i(w)</code> is the proportion of this energy that is used for
reproduction. This proportion is taken from the <code>params</code> object and is
set with <code><a href="#topic+setReproduction">setReproduction()</a></code>.
</p>


<h3>Your own reproduction rate function</h3>

<p>By default <code><a href="#topic+getERepro">getERepro()</a></code> calls <code><a href="#topic+mizerERepro">mizerERepro()</a></code>. However you can
replace this with your own alternative reproduction rate function. If
your function is called <code>"myERepro"</code> then you register it in a MizerParams
object <code>params</code> with
</p>
<div class="sourceCode"><pre>params &lt;- setRateFunction(params, "ERepro", "myERepro")
</pre></div>
<p>Your function will then be called instead of <code><a href="#topic+mizerERepro">mizerERepro()</a></code>, with the
same arguments.
</p>


<h3>See Also</h3>

<p>Other rate functions: 
<code><a href="#topic+getEGrowth">getEGrowth</a>()</code>,
<code><a href="#topic+getEReproAndGrowth">getEReproAndGrowth</a>()</code>,
<code><a href="#topic+getEncounter">getEncounter</a>()</code>,
<code><a href="#topic+getFMort">getFMort</a>()</code>,
<code><a href="#topic+getFMortGear">getFMortGear</a>()</code>,
<code><a href="#topic+getFeedingLevel">getFeedingLevel</a>()</code>,
<code><a href="#topic+getMort">getMort</a>()</code>,
<code><a href="#topic+getPredMort">getPredMort</a>()</code>,
<code><a href="#topic+getPredRate">getPredRate</a>()</code>,
<code><a href="#topic+getRDD">getRDD</a>()</code>,
<code><a href="#topic+getRDI">getRDI</a>()</code>,
<code><a href="#topic+getRates">getRates</a>()</code>,
<code><a href="#topic+getResourceMort">getResourceMort</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
params &lt;- NS_params
# Project with constant fishing effort for all gears for 20 time steps
sim &lt;- project(params, t_max = 20, effort = 0.5)
# Get the energy at a particular time step
getERepro(params, n = N(sim)[15, , ], n_pp = NResource(sim)[15, ], t = 15)

</code></pre>

<hr>
<h2 id='getEReproAndGrowth'>Get energy rate available for reproduction and growth</h2><span id='topic+getEReproAndGrowth'></span>

<h3>Description</h3>

<p>Calculates the energy rate <code class="reqn">E_{r.i}(w)</code> (grams/year) available for
reproduction and growth after metabolism and movement have been accounted
for.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getEReproAndGrowth(
  params,
  n = initialN(params),
  n_pp = initialNResource(params),
  n_other = initialNOther(params),
  t = 0,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getEReproAndGrowth_+3A_params">params</code></td>
<td>
<p>A <a href="#topic+MizerParams-class">MizerParams</a> object</p>
</td></tr>
<tr><td><code id="getEReproAndGrowth_+3A_n">n</code></td>
<td>
<p>A matrix of species abundances (species x size).</p>
</td></tr>
<tr><td><code id="getEReproAndGrowth_+3A_n_pp">n_pp</code></td>
<td>
<p>A vector of the resource abundance by size</p>
</td></tr>
<tr><td><code id="getEReproAndGrowth_+3A_n_other">n_other</code></td>
<td>
<p>A list of abundances for other dynamical components of the
ecosystem</p>
</td></tr>
<tr><td><code id="getEReproAndGrowth_+3A_t">t</code></td>
<td>
<p>The time for which to do the calculation (Not used by standard
mizer rate functions but useful for extensions with time-dependent
parameters.)</p>
</td></tr>
<tr><td><code id="getEReproAndGrowth_+3A_...">...</code></td>
<td>
<p>Unused</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A two dimensional array (species x size) holding
</p>
<p style="text-align: center;"><code class="reqn">E_{r.i}(w) = \max(0, \alpha_i\, (1 - {\tt feeding\_level}_i(w))\, 
                           {\tt encounter}_i(w) - {\tt metab}_i(w)).</code>
</p>

<p>Due to the form of the feeding level, calculated by
<code><a href="#topic+getFeedingLevel">getFeedingLevel()</a></code>, this can also be expressed as
</p>
<p style="text-align: center;"><code class="reqn">E_{r.i}(w) = \max(0, \alpha_i\, {\tt feeding\_level}_i(w)\, 
                           h_i(w) - {\tt metab}_i(w))</code>
</p>

<p>where <code class="reqn">h_i</code> is the maximum intake rate, set with
<code><a href="#topic+setMaxIntakeRate">setMaxIntakeRate()</a></code>.
The assimilation rate <code class="reqn">\alpha_i</code> is taken from the species parameter
data frame in <code>params</code>. The metabolic rate <code>metab</code> is taken from
<code>params</code> and set with <code><a href="#topic+setMetabolicRate">setMetabolicRate()</a></code>.
</p>
<p>The return value can be negative, which means that the energy intake does not
cover the cost of metabolism and movement.
</p>


<h3>Your own energy rate function</h3>

<p>By default <code><a href="#topic+getEReproAndGrowth">getEReproAndGrowth()</a></code> calls <code><a href="#topic+mizerEReproAndGrowth">mizerEReproAndGrowth()</a></code>. However you
can replace this with your own alternative energy rate function. If
your function is called <code>"myEReproAndGrowth"</code> then you register it in a
MizerParams object <code>params</code> with
</p>
<div class="sourceCode"><pre>params &lt;- setRateFunction(params, "EReproAndGrowth", "myEReproAndGrowth")
</pre></div>
<p>Your function will then be called instead of <code><a href="#topic+mizerEReproAndGrowth">mizerEReproAndGrowth()</a></code>, with
the same arguments.
</p>


<h3>See Also</h3>

<p>The part of this energy rate that is invested into growth is
calculated with <code><a href="#topic+getEGrowth">getEGrowth()</a></code> and the part that is invested into
reproduction is calculated with <code><a href="#topic+getERepro">getERepro()</a></code>.
</p>
<p>Other rate functions: 
<code><a href="#topic+getEGrowth">getEGrowth</a>()</code>,
<code><a href="#topic+getERepro">getERepro</a>()</code>,
<code><a href="#topic+getEncounter">getEncounter</a>()</code>,
<code><a href="#topic+getFMort">getFMort</a>()</code>,
<code><a href="#topic+getFMortGear">getFMortGear</a>()</code>,
<code><a href="#topic+getFeedingLevel">getFeedingLevel</a>()</code>,
<code><a href="#topic+getMort">getMort</a>()</code>,
<code><a href="#topic+getPredMort">getPredMort</a>()</code>,
<code><a href="#topic+getPredRate">getPredRate</a>()</code>,
<code><a href="#topic+getRDD">getRDD</a>()</code>,
<code><a href="#topic+getRDI">getRDI</a>()</code>,
<code><a href="#topic+getRates">getRates</a>()</code>,
<code><a href="#topic+getResourceMort">getResourceMort</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
params &lt;- NS_params
# Project with constant fishing effort for all gears for 20 time steps
sim &lt;- project(params, t_max = 20, effort = 0.5)
# Get the energy at a particular time step
getEReproAndGrowth(params, n = N(sim)[15, , ], 
                   n_pp = NResource(sim)[15, ], t = 15)

</code></pre>

<hr>
<h2 id='getESpawning'>Alias for <code>getERepro()</code></h2><span id='topic+getESpawning'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
An alias provided for backward compatibility with mizer version &lt;= 1.0
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getESpawning(
  params,
  n = initialN(params),
  n_pp = initialNResource(params),
  n_other = initialNOther(params),
  t = 0,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getESpawning_+3A_params">params</code></td>
<td>
<p>A <a href="#topic+MizerParams-class">MizerParams</a> object</p>
</td></tr>
<tr><td><code id="getESpawning_+3A_n">n</code></td>
<td>
<p>A matrix of species abundances (species x size).</p>
</td></tr>
<tr><td><code id="getESpawning_+3A_n_pp">n_pp</code></td>
<td>
<p>A vector of the resource abundance by size</p>
</td></tr>
<tr><td><code id="getESpawning_+3A_n_other">n_other</code></td>
<td>
<p>A list of abundances for other dynamical components of the
ecosystem</p>
</td></tr>
<tr><td><code id="getESpawning_+3A_t">t</code></td>
<td>
<p>The time for which to do the calculation (Not used by standard
mizer rate functions but useful for extensions with time-dependent
parameters.)</p>
</td></tr>
<tr><td><code id="getESpawning_+3A_...">...</code></td>
<td>
<p>Unused</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A two dimensional array (prey species x prey size) holding
</p>
<p style="text-align: center;"><code class="reqn">\psi_i(w)E_{r.i}(w)</code>
</p>

<p>where <code class="reqn">E_{r.i}(w)</code> is the rate at which energy becomes available for
growth and reproduction, calculated with <code><a href="#topic+getEReproAndGrowth">getEReproAndGrowth()</a></code>,
and <code class="reqn">\psi_i(w)</code> is the proportion of this energy that is used for
reproduction. This proportion is taken from the <code>params</code> object and is
set with <code><a href="#topic+setReproduction">setReproduction()</a></code>.
</p>


<h3>Your own reproduction rate function</h3>

<p>By default <code><a href="#topic+getERepro">getERepro()</a></code> calls <code><a href="#topic+mizerERepro">mizerERepro()</a></code>. However you can
replace this with your own alternative reproduction rate function. If
your function is called <code>"myERepro"</code> then you register it in a MizerParams
object <code>params</code> with
</p>
<div class="sourceCode"><pre>params &lt;- setRateFunction(params, "ERepro", "myERepro")
</pre></div>
<p>Your function will then be called instead of <code><a href="#topic+mizerERepro">mizerERepro()</a></code>, with the
same arguments.
</p>


<h3>See Also</h3>

<p>Other rate functions: 
<code><a href="#topic+getEGrowth">getEGrowth</a>()</code>,
<code><a href="#topic+getEReproAndGrowth">getEReproAndGrowth</a>()</code>,
<code><a href="#topic+getEncounter">getEncounter</a>()</code>,
<code><a href="#topic+getFMort">getFMort</a>()</code>,
<code><a href="#topic+getFMortGear">getFMortGear</a>()</code>,
<code><a href="#topic+getFeedingLevel">getFeedingLevel</a>()</code>,
<code><a href="#topic+getMort">getMort</a>()</code>,
<code><a href="#topic+getPredMort">getPredMort</a>()</code>,
<code><a href="#topic+getPredRate">getPredRate</a>()</code>,
<code><a href="#topic+getRDD">getRDD</a>()</code>,
<code><a href="#topic+getRDI">getRDI</a>()</code>,
<code><a href="#topic+getRates">getRates</a>()</code>,
<code><a href="#topic+getResourceMort">getResourceMort</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
params &lt;- NS_params
# Project with constant fishing effort for all gears for 20 time steps
sim &lt;- project(params, t_max = 20, effort = 0.5)
# Get the energy at a particular time step
getERepro(params, n = N(sim)[15, , ], n_pp = NResource(sim)[15, ], t = 15)

</code></pre>

<hr>
<h2 id='getFeedingLevel'>Get feeding level</h2><span id='topic+getFeedingLevel'></span>

<h3>Description</h3>

<p>Returns the feeding level.
By default this function uses <code><a href="#topic+mizerFeedingLevel">mizerFeedingLevel()</a></code> to calculate
the feeding level, but this can be overruled via <code><a href="#topic+setRateFunction">setRateFunction()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getFeedingLevel(object, n, n_pp, n_other, time_range, drop = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getFeedingLevel_+3A_object">object</code></td>
<td>
<p>A <code>MizerParams</code> object or a <code>MizerSim</code> object</p>
</td></tr>
<tr><td><code id="getFeedingLevel_+3A_n">n</code></td>
<td>
<p>A matrix of species abundances (species x size).</p>
</td></tr>
<tr><td><code id="getFeedingLevel_+3A_n_pp">n_pp</code></td>
<td>
<p>A vector of the resource abundance by size</p>
</td></tr>
<tr><td><code id="getFeedingLevel_+3A_n_other">n_other</code></td>
<td>
<p>A list of abundances for other dynamical components of the
ecosystem</p>
</td></tr>
<tr><td><code id="getFeedingLevel_+3A_time_range">time_range</code></td>
<td>
<p>A vector of times. Only the range of times is relevant,
i.e., all times between the smallest and largest will be selected.
The time_range can be character or numeric.</p>
</td></tr>
<tr><td><code id="getFeedingLevel_+3A_drop">drop</code></td>
<td>
<p>If <code>TRUE</code> then any dimension of length 1 will be removed
from the returned array.</p>
</td></tr>
<tr><td><code id="getFeedingLevel_+3A_...">...</code></td>
<td>
<p>Unused</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If a <code>MizerParams</code> object is passed in, the function returns a two
dimensional array (predator species x predator size) based on the
abundances also passed in.
If a <code>MizerSim</code> object is passed in, the function returns a three
dimensional array (time step x predator species x predator size) with the
feeding level calculated at every time step in the simulation.
If <code>drop = TRUE</code> then the dimension of length 1 will be removed from
the returned array.
</p>


<h3>Feeding level</h3>

<p>The feeding level <code class="reqn">f_i(w)</code> is the
proportion of its maximum intake rate at which the predator is actually
taking in fish. It is calculated from the encounter rate <code class="reqn">E_i</code> and the
maximum intake rate <code class="reqn">h_i(w)</code> as
</p>
<p style="text-align: center;"><code class="reqn">f_i(w) = \frac{E_i(w)}{E_i(w)+h_i(w)}.</code>
</p>

<p>The encounter rate <code class="reqn">E_i</code> is passed as an argument or calculated with
<code><a href="#topic+getEncounter">getEncounter()</a></code>. The maximum intake rate <code class="reqn">h_i(w)</code> is
taken from the <code>params</code> object, and is set with
<code><a href="#topic+setMaxIntakeRate">setMaxIntakeRate()</a></code>.
As a consequence of the above expression for the feeding level,
<code class="reqn">1-f_i(w)</code> is the proportion of the food available to it that the
predator actually consumes.
</p>


<h3>Your own feeding level function</h3>

<p>By default <code><a href="#topic+getFeedingLevel">getFeedingLevel()</a></code> calls <code><a href="#topic+mizerFeedingLevel">mizerFeedingLevel()</a></code>. However you can
replace this with your own alternative feeding level function. If
your function is called <code>"myFeedingLevel"</code> then you register it in a MizerParams
object <code>params</code> with
</p>
<div class="sourceCode"><pre>params &lt;- setRateFunction(params, "FeedingLevel", "myFeedingLevel")
</pre></div>
<p>Your function will then be called instead of <code><a href="#topic+mizerFeedingLevel">mizerFeedingLevel()</a></code>, with the
same arguments.
</p>


<h3>See Also</h3>

<p>Other rate functions: 
<code><a href="#topic+getEGrowth">getEGrowth</a>()</code>,
<code><a href="#topic+getERepro">getERepro</a>()</code>,
<code><a href="#topic+getEReproAndGrowth">getEReproAndGrowth</a>()</code>,
<code><a href="#topic+getEncounter">getEncounter</a>()</code>,
<code><a href="#topic+getFMort">getFMort</a>()</code>,
<code><a href="#topic+getFMortGear">getFMortGear</a>()</code>,
<code><a href="#topic+getMort">getMort</a>()</code>,
<code><a href="#topic+getPredMort">getPredMort</a>()</code>,
<code><a href="#topic+getPredRate">getPredRate</a>()</code>,
<code><a href="#topic+getRDD">getRDD</a>()</code>,
<code><a href="#topic+getRDI">getRDI</a>()</code>,
<code><a href="#topic+getRates">getRates</a>()</code>,
<code><a href="#topic+getResourceMort">getResourceMort</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
params &lt;- NS_params
# Get initial feeding level
fl &lt;- getFeedingLevel(params)
# Project with constant fishing effort for all gears for 20 time steps
sim &lt;- project(params, t_max = 20, effort = 0.5)
# Get the feeding level at all saved time steps
fl &lt;- getFeedingLevel(sim)
# Get the feeding level for years 15 - 20
fl &lt;- getFeedingLevel(sim, time_range = c(15, 20))

</code></pre>

<hr>
<h2 id='getFMort'>Get the total fishing mortality rate from all fishing gears by time, species
and size.</h2><span id='topic+getFMort'></span>

<h3>Description</h3>

<p>Calculates the total fishing mortality  (in units 1/year) from all gears by
species and size and possibly time. See <code>setFishing()</code> for details of
how fishing gears are set up.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getFMort(object, effort, time_range, drop = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getFMort_+3A_object">object</code></td>
<td>
<p>A <code>MizerParams</code> object or a <code>MizerSim</code> object</p>
</td></tr>
<tr><td><code id="getFMort_+3A_effort">effort</code></td>
<td>
<p>The effort of each fishing gear. Only used if the object
argument is of class <code>MizerParams</code>. See notes below.</p>
</td></tr>
<tr><td><code id="getFMort_+3A_time_range">time_range</code></td>
<td>
<p>Subset the returned fishing mortalities by time. The time
range is either a vector of values, a vector of min and max time, or a
single value. Default is the whole time range. Only used if the
<code>object</code> argument is of type <code>MizerSim</code>.</p>
</td></tr>
<tr><td><code id="getFMort_+3A_drop">drop</code></td>
<td>
<p>Only used when object is of type <code>MizerSim</code>. Should
dimensions of length 1 be dropped, e.g. if your community only has one
species it might make presentation of results easier. Default is TRUE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The total fishing mortality is just the sum of the fishing mortalities
imposed by each gear, <code class="reqn">\mu_{f.i}(w)=\sum_g F_{g,i,w}</code>.
The fishing mortality for each gear is obtained as catchability x
selectivity x effort.
</p>


<h3>Value</h3>

<p>An array. If the effort argument has a time dimension, or object is
of class <code>MizerSim</code>, the output array has three dimensions (time x
species x size). If the effort argument does not have a time dimension, the
output array has two dimensions (species x size).
</p>
<p>The <code>effort</code> argument is only used if a <code>MizerParams</code> object is
passed in. The <code>effort</code> argument can be a two dimensional array (time x
gear), a vector of length equal to the number of gears (each gear has a
different effort that is constant in time), or a single numeric value (each
gear has the same effort that is constant in time). The order of gears in the
<code>effort</code> argument must be the same as in the <code>MizerParams</code>
object.
</p>
<p>If the object argument is of class <code>MizerSim</code> then the effort slot of
the <code>MizerSim</code> object is used and the <code>effort</code> argument is not
used.
</p>


<h3>Your own fishing mortality function</h3>

<p>By default <code><a href="#topic+getFMort">getFMort()</a></code> calls <code><a href="#topic+mizerFMort">mizerFMort()</a></code>. However you can
replace this with your own alternative fishing mortality function. If
your function is called <code>"myFMort"</code> then you register it in a MizerParams
object <code>params</code> with
</p>
<div class="sourceCode"><pre>params &lt;- setRateFunction(params, "FMort", "myFMort")
</pre></div>
<p>Your function will then be called instead of <code><a href="#topic+mizerFMort">mizerFMort()</a></code>, with the
same arguments.
</p>


<h3>See Also</h3>

<p>Other rate functions: 
<code><a href="#topic+getEGrowth">getEGrowth</a>()</code>,
<code><a href="#topic+getERepro">getERepro</a>()</code>,
<code><a href="#topic+getEReproAndGrowth">getEReproAndGrowth</a>()</code>,
<code><a href="#topic+getEncounter">getEncounter</a>()</code>,
<code><a href="#topic+getFMortGear">getFMortGear</a>()</code>,
<code><a href="#topic+getFeedingLevel">getFeedingLevel</a>()</code>,
<code><a href="#topic+getMort">getMort</a>()</code>,
<code><a href="#topic+getPredMort">getPredMort</a>()</code>,
<code><a href="#topic+getPredRate">getPredRate</a>()</code>,
<code><a href="#topic+getRDD">getRDD</a>()</code>,
<code><a href="#topic+getRDI">getRDI</a>()</code>,
<code><a href="#topic+getRates">getRates</a>()</code>,
<code><a href="#topic+getResourceMort">getResourceMort</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
params &lt;- NS_params
# Get the total fishing mortality when effort is constant for all 
# gears and time:
getFMort(params, effort = 1)
# Get the total fishing mortality when effort is different
# between the four gears but constant in time:
getFMort(params, effort = c(0.5,1,1.5,0.75))
# Get the total fishing mortality when effort is different
# between the four gears and changes with time:
effort &lt;- array(NA, dim = c(20,4))
effort[, 1] &lt;- seq(from = 0, to = 1, length = 20)
effort[, 2] &lt;- seq(from = 1, to = 0.5, length = 20)
effort[, 3] &lt;- seq(from = 1, to = 2, length = 20)
effort[, 4] &lt;- seq(from = 2, to = 1, length = 20)
getFMort(params, effort = effort)
# Get the total fishing mortality using the effort already held in a 
# MizerSim object.
sim &lt;- project(params, t_max = 20, effort = 0.5)
getFMort(sim)
getFMort(sim, time_range = c(10, 20))

</code></pre>

<hr>
<h2 id='getFMortGear'>Get the fishing mortality by time, gear, species and size</h2><span id='topic+getFMortGear'></span>

<h3>Description</h3>

<p>Calculates the fishing mortality rate <code class="reqn">F_{g,i,w}</code> by gear, species and
size and possibly time (in units 1/year).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getFMortGear(object, effort, time_range)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getFMortGear_+3A_object">object</code></td>
<td>
<p>A <code>MizerParams</code> object or a <code>MizerSim</code> object.</p>
</td></tr>
<tr><td><code id="getFMortGear_+3A_effort">effort</code></td>
<td>
<p>The effort for each fishing gear. See notes below.</p>
</td></tr>
<tr><td><code id="getFMortGear_+3A_time_range">time_range</code></td>
<td>
<p>Subset the returned fishing mortalities by time. The time
range is either a vector of values, a vector of min and max time, or a
single value. Default is the whole time range. Only used if the
<code>object</code> argument is of type <code>MizerSim</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An array. If the effort argument has a time dimension, or a
<code>MizerSim</code> is passed in, the output array has four dimensions (time x
gear x species x size). If the effort argument does not have a time
dimension (i.e. it is a vector or a single numeric), the output array has
three dimensions (gear x species x size).
</p>


<h3>Note</h3>

<p>Here: fishing mortality = catchability x selectivity x effort.
</p>
<p>The <code>effort</code> argument is only used if a <code>MizerParams</code> object is
passed in. The <code>effort</code> argument can be a two dimensional array (time x
gear), a vector of length equal to the number of gears (each gear has a
different effort that is constant in time), or a single numeric value (each
gear has the same effort that is constant in time). The order of gears in the
<code>effort</code> argument must be the same the same as in the <code>MizerParams</code>
object. If the <code>effort</code> argument is not supplied, its value is taken
from the <code style="white-space: pre;">&#8288;@initial_effort&#8288;</code> slot in the params object.
</p>
<p>If the object argument is of class <code>MizerSim</code> then the effort slot of
the <code>MizerSim</code> object is used and the <code>effort</code> argument is not
used.
</p>


<h3>See Also</h3>

<p>Other rate functions: 
<code><a href="#topic+getEGrowth">getEGrowth</a>()</code>,
<code><a href="#topic+getERepro">getERepro</a>()</code>,
<code><a href="#topic+getEReproAndGrowth">getEReproAndGrowth</a>()</code>,
<code><a href="#topic+getEncounter">getEncounter</a>()</code>,
<code><a href="#topic+getFMort">getFMort</a>()</code>,
<code><a href="#topic+getFeedingLevel">getFeedingLevel</a>()</code>,
<code><a href="#topic+getMort">getMort</a>()</code>,
<code><a href="#topic+getPredMort">getPredMort</a>()</code>,
<code><a href="#topic+getPredRate">getPredRate</a>()</code>,
<code><a href="#topic+getRDD">getRDD</a>()</code>,
<code><a href="#topic+getRDI">getRDI</a>()</code>,
<code><a href="#topic+getRates">getRates</a>()</code>,
<code><a href="#topic+getResourceMort">getResourceMort</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
params &lt;-NS_params
# Get the fishing mortality when effort is constant
# for all gears and time:
getFMortGear(params, effort = 1)
# Get the fishing mortality when effort is different
# between the four gears but constant in time:
getFMortGear(params, effort = c(0.5, 1, 1.5, 0.75))
# Get the fishing mortality when effort is different
# between the four gears and changes with time:
effort &lt;- array(NA, dim = c(20, 4))
effort[, 1] &lt;- seq(from=0, to = 1, length = 20)
effort[, 2] &lt;- seq(from=1, to = 0.5, length = 20)
effort[, 3] &lt;- seq(from=1, to = 2, length = 20)
effort[, 4] &lt;- seq(from=2, to = 1, length = 20)
getFMortGear(params, effort = effort)
# Get the fishing mortality using the effort already held in a MizerSim object.
sim &lt;- project(params, t_max = 20, effort = 0.5)
getFMortGear(sim)
getFMortGear(sim, time_range = c(10, 20))


</code></pre>

<hr>
<h2 id='getGrowthCurves'>Get growth curves giving weight as a function of age</h2><span id='topic+getGrowthCurves'></span>

<h3>Description</h3>

<p>Get growth curves giving weight as a function of age
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getGrowthCurves(object, species = NULL, max_age = 20, percentage = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getGrowthCurves_+3A_object">object</code></td>
<td>
<p>MizerSim or MizerParams object. If given a
<a href="#topic+MizerSim-class">MizerSim</a> object, uses the growth rates at the final time of a
simulation to calculate the size at age. If given a
<a href="#topic+MizerParams-class">MizerParams</a> object, uses the initial growth rates instead.</p>
</td></tr>
<tr><td><code id="getGrowthCurves_+3A_species">species</code></td>
<td>
<p>The species to be selected. Optional. By default all target
species are selected. A vector of species names, or a
numeric vector with the species indices, or a logical vector indicating for
each species whether it is to be selected (TRUE) or not.</p>
</td></tr>
<tr><td><code id="getGrowthCurves_+3A_max_age">max_age</code></td>
<td>
<p>The age up to which to run the growth curve. Default is 20.</p>
</td></tr>
<tr><td><code id="getGrowthCurves_+3A_percentage">percentage</code></td>
<td>
<p>Boolean value. If TRUE, the size is given as a percentage
of the maximal size.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An array (species x age) containing the weight in grams.
</p>


<h3>See Also</h3>

<p>Other summary functions: 
<code><a href="#topic+getBiomass">getBiomass</a>()</code>,
<code><a href="#topic+getDiet">getDiet</a>()</code>,
<code><a href="#topic+getN">getN</a>()</code>,
<code><a href="#topic+getSSB">getSSB</a>()</code>,
<code><a href="#topic+getYield">getYield</a>()</code>,
<code><a href="#topic+getYieldGear">getYieldGear</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>growth_curves &lt;- getGrowthCurves(NS_params, species = c("Cod", "Haddock"))
str(growth_curves)

library(ggplot2)
ggplot(melt(growth_curves)) +
  geom_line(aes(Age, value)) +
  facet_wrap(~ Species, scales = "free") +
  ylab("Size[g]") + xlab("Age[years]")
</code></pre>

<hr>
<h2 id='getInteraction'>Deprecated function to get interaction matrix</h2><span id='topic+getInteraction'></span>

<h3>Description</h3>

<p>You should now use <code><a href="#topic+interaction_matrix">interaction_matrix()</a></code> instead.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getInteraction(params)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getInteraction_+3A_params">params</code></td>
<td>
<p>A MizerParams object</p>
</td></tr>
</table>

<hr>
<h2 id='getM2'>Alias for <code>getPredMort()</code></h2><span id='topic+getM2'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
An alias provided for backward compatibility with mizer version &lt;= 1.0
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getM2(object, n, n_pp, n_other, time_range, drop = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getM2_+3A_object">object</code></td>
<td>
<p>A <code>MizerParams</code> object or a <code>MizerSim</code> object</p>
</td></tr>
<tr><td><code id="getM2_+3A_n">n</code></td>
<td>
<p>A matrix of species abundances (species x size).</p>
</td></tr>
<tr><td><code id="getM2_+3A_n_pp">n_pp</code></td>
<td>
<p>A vector of the resource abundance by size</p>
</td></tr>
<tr><td><code id="getM2_+3A_n_other">n_other</code></td>
<td>
<p>A list of abundances for other dynamical components of the
ecosystem</p>
</td></tr>
<tr><td><code id="getM2_+3A_time_range">time_range</code></td>
<td>
<p>A vector of times. Only the range of times is relevant,
i.e., all times between the smallest and largest will be selected.
The time_range can be character or numeric.</p>
</td></tr>
<tr><td><code id="getM2_+3A_drop">drop</code></td>
<td>
<p>If <code>TRUE</code> then any dimension of length 1 will be removed
from the returned array.</p>
</td></tr>
<tr><td><code id="getM2_+3A_...">...</code></td>
<td>
<p>Unused</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If a <code>MizerParams</code> object is passed in, the function returns a two
dimensional array (prey species x prey size) based on the abundances also
passed in. If a <code>MizerSim</code> object is passed in, the function returns a
three dimensional array (time step x prey species x prey size) with the
predation mortality calculated at every time step in the simulation.
Dimensions may be dropped if they have length 1 unless <code>drop = FALSE</code>.
</p>


<h3>Your own predation mortality function</h3>

<p>By default <code><a href="#topic+getPredMort">getPredMort()</a></code> calls <code><a href="#topic+mizerPredMort">mizerPredMort()</a></code>. However you can
replace this with your own alternative predation mortality function. If
your function is called <code>"myPredMort"</code> then you register it in a MizerParams
object <code>params</code> with
</p>
<div class="sourceCode"><pre>params &lt;- setRateFunction(params, "PredMort", "myPredMort")
</pre></div>
<p>Your function will then be called instead of <code><a href="#topic+mizerPredMort">mizerPredMort()</a></code>, with the
same arguments.
</p>


<h3>See Also</h3>

<p>Other rate functions: 
<code><a href="#topic+getEGrowth">getEGrowth</a>()</code>,
<code><a href="#topic+getERepro">getERepro</a>()</code>,
<code><a href="#topic+getEReproAndGrowth">getEReproAndGrowth</a>()</code>,
<code><a href="#topic+getEncounter">getEncounter</a>()</code>,
<code><a href="#topic+getFMort">getFMort</a>()</code>,
<code><a href="#topic+getFMortGear">getFMortGear</a>()</code>,
<code><a href="#topic+getFeedingLevel">getFeedingLevel</a>()</code>,
<code><a href="#topic+getMort">getMort</a>()</code>,
<code><a href="#topic+getPredRate">getPredRate</a>()</code>,
<code><a href="#topic+getRDD">getRDD</a>()</code>,
<code><a href="#topic+getRDI">getRDI</a>()</code>,
<code><a href="#topic+getRates">getRates</a>()</code>,
<code><a href="#topic+getResourceMort">getResourceMort</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
params &lt;- NS_params
# With constant fishing effort for all gears for 20 time steps
sim &lt;- project(params, t_max = 20, effort = 0.5)
# Get predation mortality at one time step
getPredMort(params, n = N(sim)[15, , ], n_pp = NResource(sim)[15, ])
# Get predation mortality at all saved time steps
getPredMort(sim)
# Get predation mortality over the years 15 - 20
getPredMort(sim, time_range = c(15, 20))

</code></pre>

<hr>
<h2 id='getM2Background'>Alias for <code>getResourceMort()</code></h2><span id='topic+getM2Background'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
An alias provided for backward compatibility with mizer version &lt;= 1.0
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getM2Background(
  params,
  n = initialN(params),
  n_pp = initialNResource(params),
  n_other = initialNOther(params),
  t = 0,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getM2Background_+3A_params">params</code></td>
<td>
<p>A <a href="#topic+MizerParams-class">MizerParams</a> object</p>
</td></tr>
<tr><td><code id="getM2Background_+3A_n">n</code></td>
<td>
<p>A matrix of species abundances (species x size).</p>
</td></tr>
<tr><td><code id="getM2Background_+3A_n_pp">n_pp</code></td>
<td>
<p>A vector of the resource abundance by size</p>
</td></tr>
<tr><td><code id="getM2Background_+3A_n_other">n_other</code></td>
<td>
<p>A list of abundances for other dynamical components of the
ecosystem</p>
</td></tr>
<tr><td><code id="getM2Background_+3A_t">t</code></td>
<td>
<p>The time for which to do the calculation (Not used by standard
mizer rate functions but useful for extensions with time-dependent
parameters.)</p>
</td></tr>
<tr><td><code id="getM2Background_+3A_...">...</code></td>
<td>
<p>Unused</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of mortality rate by resource size.
</p>


<h3>Your own resource mortality function</h3>

<p>By default <code><a href="#topic+getResourceMort">getResourceMort()</a></code> calls <code><a href="#topic+mizerResourceMort">mizerResourceMort()</a></code>. However you can
replace this with your own alternative resource mortality function. If
your function is called <code>"myResourceMort"</code> then you register it in a MizerParams
object <code>params</code> with
</p>
<div class="sourceCode"><pre>params &lt;- setRateFunction(params, "ResourceMort", "myResourceMort")
</pre></div>
<p>Your function will then be called instead of <code><a href="#topic+mizerResourceMort">mizerResourceMort()</a></code>, with the
same arguments.
</p>


<h3>See Also</h3>

<p>Other rate functions: 
<code><a href="#topic+getEGrowth">getEGrowth</a>()</code>,
<code><a href="#topic+getERepro">getERepro</a>()</code>,
<code><a href="#topic+getEReproAndGrowth">getEReproAndGrowth</a>()</code>,
<code><a href="#topic+getEncounter">getEncounter</a>()</code>,
<code><a href="#topic+getFMort">getFMort</a>()</code>,
<code><a href="#topic+getFMortGear">getFMortGear</a>()</code>,
<code><a href="#topic+getFeedingLevel">getFeedingLevel</a>()</code>,
<code><a href="#topic+getMort">getMort</a>()</code>,
<code><a href="#topic+getPredMort">getPredMort</a>()</code>,
<code><a href="#topic+getPredRate">getPredRate</a>()</code>,
<code><a href="#topic+getRDD">getRDD</a>()</code>,
<code><a href="#topic+getRDI">getRDI</a>()</code>,
<code><a href="#topic+getRates">getRates</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
params &lt;- NS_params
# With constant fishing effort for all gears for 20 time steps
sim &lt;- project(params, t_max = 20, effort = 0.5)
# Get resource mortality at one time step
getResourceMort(params, n = N(sim)[15, , ], n_pp = NResource(sim)[15, ])

</code></pre>

<hr>
<h2 id='getMeanMaxWeight'>Calculate the mean maximum weight of the community</h2><span id='topic+getMeanMaxWeight'></span>

<h3>Description</h3>

<p>Calculates the mean maximum weight of the community through time. This can be
calculated by numbers or biomass. The calculation is the sum of the w_max *
abundance of each species, divided by the total abundance community, where
abundance is either in biomass or numbers. You can specify minimum and
maximum weight or length range for the species. Lengths take precedence over
weights (i.e. if both min_l and min_w are supplied, only min_l will be used).
You can also specify the species to be used in the calculation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getMeanMaxWeight(sim, species = NULL, measure = "both", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getMeanMaxWeight_+3A_sim">sim</code></td>
<td>
<p>A <a href="#topic+MizerSim-class">MizerSim</a> object</p>
</td></tr>
<tr><td><code id="getMeanMaxWeight_+3A_species">species</code></td>
<td>
<p>The species to be selected. Optional. By default all target
species are selected. A vector of species names, or a
numeric vector with the species indices, or a logical vector indicating for
each species whether it is to be selected (TRUE) or not.</p>
</td></tr>
<tr><td><code id="getMeanMaxWeight_+3A_measure">measure</code></td>
<td>
<p>The measure to return. Can be 'numbers', 'biomass' or 'both'</p>
</td></tr>
<tr><td><code id="getMeanMaxWeight_+3A_...">...</code></td>
<td>

<p>Arguments passed on to <code><a href="#topic+get_size_range_array">get_size_range_array</a></code>
</p>

<dl>
<dt><code>min_w</code></dt><dd><p>Smallest weight in size range. Defaults to smallest weight in
the model.</p>
</dd>
<dt><code>max_w</code></dt><dd><p>Largest weight in size range. Defaults to largest weight in the
model.</p>
</dd>
<dt><code>min_l</code></dt><dd><p>Smallest length in size range. If supplied, this takes
precedence over <code>min_w</code>.</p>
</dd>
<dt><code>max_l</code></dt><dd><p>Largest length in size range. If supplied, this takes precedence
over <code>max_w</code>.</p>
</dd>
</dl>
</td></tr>
</table>


<h3>Value</h3>

<p>Depends on the <code>measure</code> argument. If <code>measure = “both”</code>
then you get a matrix with two columns, one with values by numbers, the
other with values by biomass at each saved time step. If <code>measure =
  “numbers”</code> or <code>“biomass”</code> you get a vector of the respective values at
each saved time step.
</p>


<h3>See Also</h3>

<p>Other functions for calculating indicators: 
<code><a href="#topic+getCommunitySlope">getCommunitySlope</a>()</code>,
<code><a href="#topic+getMeanWeight">getMeanWeight</a>()</code>,
<code><a href="#topic+getProportionOfLargeFish">getProportionOfLargeFish</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mmw &lt;- getMeanMaxWeight(NS_sim)
years &lt;- c("1967", "2010")
mmw[years, ]
getMeanMaxWeight(NS_sim, species=c("Herring","Sprat","N.pout"))[years, ]
getMeanMaxWeight(NS_sim, min_w = 10, max_w = 5000)[years, ]
</code></pre>

<hr>
<h2 id='getMeanWeight'>Calculate the mean weight of the community</h2><span id='topic+getMeanWeight'></span>

<h3>Description</h3>

<p>Calculates the mean weight of the community through time. This is simply the
total biomass of the community divided by the abundance in numbers. You can
specify minimum and maximum weight or length range for the species. Lengths
take precedence over weights (i.e. if both min_l and min_w are supplied, only
min_l will be used). You can also specify the species to be used in the
calculation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getMeanWeight(sim, species = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getMeanWeight_+3A_sim">sim</code></td>
<td>
<p>A <a href="#topic+MizerSim-class">MizerSim</a> object</p>
</td></tr>
<tr><td><code id="getMeanWeight_+3A_species">species</code></td>
<td>
<p>The species to be selected. Optional. By default all target
species are selected. A vector of species names, or a
numeric vector with the species indices, or a logical vector indicating for
each species whether it is to be selected (TRUE) or not.</p>
</td></tr>
<tr><td><code id="getMeanWeight_+3A_...">...</code></td>
<td>

<p>Arguments passed on to <code><a href="#topic+get_size_range_array">get_size_range_array</a></code>
</p>

<dl>
<dt><code>min_w</code></dt><dd><p>Smallest weight in size range. Defaults to smallest weight in
the model.</p>
</dd>
<dt><code>max_w</code></dt><dd><p>Largest weight in size range. Defaults to largest weight in the
model.</p>
</dd>
<dt><code>min_l</code></dt><dd><p>Smallest length in size range. If supplied, this takes
precedence over <code>min_w</code>.</p>
</dd>
<dt><code>max_l</code></dt><dd><p>Largest length in size range. If supplied, this takes precedence
over <code>max_w</code>.</p>
</dd>
</dl>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector containing the mean weight of the community through time
</p>


<h3>See Also</h3>

<p>Other functions for calculating indicators: 
<code><a href="#topic+getCommunitySlope">getCommunitySlope</a>()</code>,
<code><a href="#topic+getMeanMaxWeight">getMeanMaxWeight</a>()</code>,
<code><a href="#topic+getProportionOfLargeFish">getProportionOfLargeFish</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mean_weight &lt;- getMeanWeight(NS_sim)
years &lt;- c("1967", "2010")
mean_weight[years]
getMeanWeight(NS_sim, species = c("Herring", "Sprat", "N.pout"))[years]
getMeanWeight(NS_sim, min_w = 10, max_w = 5000)[years]
</code></pre>

<hr>
<h2 id='getMort'>Get total mortality rate</h2><span id='topic+getMort'></span>

<h3>Description</h3>

<p>Calculates the total mortality rate <code class="reqn">\mu_i(w)</code>  (in units 1/year) on each
species by size from predation mortality, background mortality and fishing
mortality for a single time step.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getMort(
  params,
  n = initialN(params),
  n_pp = initialNResource(params),
  n_other = initialNOther(params),
  effort = getInitialEffort(params),
  t = 0,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getMort_+3A_params">params</code></td>
<td>
<p>A <a href="#topic+MizerParams-class">MizerParams</a> object</p>
</td></tr>
<tr><td><code id="getMort_+3A_n">n</code></td>
<td>
<p>A matrix of species abundances (species x size).</p>
</td></tr>
<tr><td><code id="getMort_+3A_n_pp">n_pp</code></td>
<td>
<p>A vector of the resource abundance by size</p>
</td></tr>
<tr><td><code id="getMort_+3A_n_other">n_other</code></td>
<td>
<p>A list of abundances for other dynamical components of the
ecosystem</p>
</td></tr>
<tr><td><code id="getMort_+3A_effort">effort</code></td>
<td>
<p>A numeric vector of the effort by gear or a single numeric
effort value which is used for all gears.</p>
</td></tr>
<tr><td><code id="getMort_+3A_t">t</code></td>
<td>
<p>The time for which to do the calculation (Not used by standard
mizer rate functions but useful for extensions with time-dependent
parameters.)</p>
</td></tr>
<tr><td><code id="getMort_+3A_...">...</code></td>
<td>
<p>Unused</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If your model contains additional components that you added with
<code><a href="#topic+setComponent">setComponent()</a></code> and for which you specified a <code>mort_fun</code> function then
the mortality inflicted by these components will be included in the returned
value.
</p>


<h3>Value</h3>

<p>A two dimensional array (prey species x prey size).
</p>


<h3>Your own mortality function</h3>

<p>By default <code><a href="#topic+getMort">getMort()</a></code> calls <code><a href="#topic+mizerMort">mizerMort()</a></code>. However you can
replace this with your own alternative mortality function. If
your function is called <code>"myMort"</code> then you register it in a MizerParams
object <code>params</code> with
</p>
<div class="sourceCode"><pre>params &lt;- setRateFunction(params, "Mort", "myMort")
</pre></div>
<p>Your function will then be called instead of <code><a href="#topic+mizerMort">mizerMort()</a></code>, with the
same arguments.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+getPredMort">getPredMort()</a></code>, <code><a href="#topic+getFMort">getFMort()</a></code>
</p>
<p>Other rate functions: 
<code><a href="#topic+getEGrowth">getEGrowth</a>()</code>,
<code><a href="#topic+getERepro">getERepro</a>()</code>,
<code><a href="#topic+getEReproAndGrowth">getEReproAndGrowth</a>()</code>,
<code><a href="#topic+getEncounter">getEncounter</a>()</code>,
<code><a href="#topic+getFMort">getFMort</a>()</code>,
<code><a href="#topic+getFMortGear">getFMortGear</a>()</code>,
<code><a href="#topic+getFeedingLevel">getFeedingLevel</a>()</code>,
<code><a href="#topic+getPredMort">getPredMort</a>()</code>,
<code><a href="#topic+getPredRate">getPredRate</a>()</code>,
<code><a href="#topic+getRDD">getRDD</a>()</code>,
<code><a href="#topic+getRDI">getRDI</a>()</code>,
<code><a href="#topic+getRates">getRates</a>()</code>,
<code><a href="#topic+getResourceMort">getResourceMort</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
params &lt;- NS_params
# Project with constant fishing effort for all gears for 20 time steps
sim &lt;- project(params, t_max = 20, effort = 0.5)
# Get the total mortality at a particular time step
getMort(params, n = N(sim)[15, , ], n_pp = NResource(sim)[15, ], 
        t = 15, effort = 0.5)

</code></pre>

<hr>
<h2 id='getN'>Calculate the number of individuals within a size range</h2><span id='topic+getN'></span>

<h3>Description</h3>

<p>Calculates the number of individuals within user-defined size limits. The
default option is to use the whole size range. You can specify minimum and
maximum weight or lengths for the species. Lengths take precedence over
weights (i.e. if both min_l and min_w are supplied, only min_l will be used)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getN(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getN_+3A_object">object</code></td>
<td>
<p>An object of class <code>MizerParams</code> or <code>MizerSim</code>.</p>
</td></tr>
<tr><td><code id="getN_+3A_...">...</code></td>
<td>

<p>Arguments passed on to <code><a href="#topic+get_size_range_array">get_size_range_array</a></code>
</p>

<dl>
<dt><code>min_w</code></dt><dd><p>Smallest weight in size range. Defaults to smallest weight in
the model.</p>
</dd>
<dt><code>max_w</code></dt><dd><p>Largest weight in size range. Defaults to largest weight in the
model.</p>
</dd>
<dt><code>min_l</code></dt><dd><p>Smallest length in size range. If supplied, this takes
precedence over <code>min_w</code>.</p>
</dd>
<dt><code>max_l</code></dt><dd><p>Largest length in size range. If supplied, this takes precedence
over <code>max_w</code>.</p>
</dd>
</dl>
</td></tr>
</table>


<h3>Value</h3>

<p>If called with a MizerParams object, a vector with the numbers for
each species in the model. If called with a MizerSim object, an array (time
x species) containing the numbers at each time step for all species.
</p>


<h3>See Also</h3>

<p>Other summary functions: 
<code><a href="#topic+getBiomass">getBiomass</a>()</code>,
<code><a href="#topic+getDiet">getDiet</a>()</code>,
<code><a href="#topic+getGrowthCurves">getGrowthCurves</a>()</code>,
<code><a href="#topic+getSSB">getSSB</a>()</code>,
<code><a href="#topic+getYield">getYield</a>()</code>,
<code><a href="#topic+getYieldGear">getYieldGear</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>numbers &lt;- getN(NS_sim)
numbers["1972", "Herring"]
# The above gave a huge number, because that included all the larvae.
# The number of Herrings between 10g and 1kg is much smaller.
numbers &lt;- getN(NS_sim, min_w = 10, max_w = 1000)
numbers["1972", "Herring"]
</code></pre>

<hr>
<h2 id='getParams'>Extract the parameter object underlying a simulation</h2><span id='topic+getParams'></span>

<h3>Description</h3>

<p>Extract the parameter object underlying a simulation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getParams(sim)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getParams_+3A_sim">sim</code></td>
<td>
<p>A MizerSim object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The MizerParams object that was used to run the simulation
</p>


<h3>Examples</h3>

<pre><code class='language-R'># This will be identical to the params object that was used to create the
# simulation
sim &lt;- project(NS_params, t_max = 1)
identical(getParams(sim), NS_params)
</code></pre>

<hr>
<h2 id='getPhiPrey'>Get available energy</h2><span id='topic+getPhiPrey'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p>This is deprecated and is no longer used by the mizer project() method.
Calculates the amount <code class="reqn">E_{a,i}(w)</code> of food exposed to each predator as
a function of predator size.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getPhiPrey(object, n, n_pp, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getPhiPrey_+3A_object">object</code></td>
<td>
<p>An <a href="#topic+MizerParams-class">MizerParams</a> object</p>
</td></tr>
<tr><td><code id="getPhiPrey_+3A_n">n</code></td>
<td>
<p>A matrix of species abundances (species x size)</p>
</td></tr>
<tr><td><code id="getPhiPrey_+3A_n_pp">n_pp</code></td>
<td>
<p>A vector of the background abundance by size</p>
</td></tr>
<tr><td><code id="getPhiPrey_+3A_...">...</code></td>
<td>
<p>Other arguments (currently unused)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A two dimensional array (predator species x predator size)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+project">project()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
params &lt;-  NS_params
sim &lt;- project(params, t_max = 20, effort = 0.5)
n &lt;- sim@n[21,,]
n_pp &lt;- sim@n_pp[21,]
getPhiPrey(params,n,n_pp)
# -&gt;
getEncounter(params) / getSearchVolume(params)

</code></pre>

<hr>
<h2 id='getPredMort'>Get total predation mortality rate</h2><span id='topic+getPredMort'></span>

<h3>Description</h3>

<p>Calculates the total predation mortality rate <code class="reqn">\mu_{p,i}(w_p)</code> (in units
of 1/year) on each prey species by prey size:
</p>
<p style="text-align: center;"><code class="reqn">\mu_{p.i}(w_p) = \sum_j {\tt pred\_rate}_j(w_p)\, \theta_{ji}.</code>
</p>

<p>The predation rate <code>pred_rate</code> is returned by <code><a href="#topic+getPredRate">getPredRate()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getPredMort(object, n, n_pp, n_other, time_range, drop = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getPredMort_+3A_object">object</code></td>
<td>
<p>A <code>MizerParams</code> object or a <code>MizerSim</code> object</p>
</td></tr>
<tr><td><code id="getPredMort_+3A_n">n</code></td>
<td>
<p>A matrix of species abundances (species x size).</p>
</td></tr>
<tr><td><code id="getPredMort_+3A_n_pp">n_pp</code></td>
<td>
<p>A vector of the resource abundance by size</p>
</td></tr>
<tr><td><code id="getPredMort_+3A_n_other">n_other</code></td>
<td>
<p>A list of abundances for other dynamical components of the
ecosystem</p>
</td></tr>
<tr><td><code id="getPredMort_+3A_time_range">time_range</code></td>
<td>
<p>A vector of times. Only the range of times is relevant,
i.e., all times between the smallest and largest will be selected.
The time_range can be character or numeric.</p>
</td></tr>
<tr><td><code id="getPredMort_+3A_drop">drop</code></td>
<td>
<p>If <code>TRUE</code> then any dimension of length 1 will be removed
from the returned array.</p>
</td></tr>
<tr><td><code id="getPredMort_+3A_...">...</code></td>
<td>
<p>Unused</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If a <code>MizerParams</code> object is passed in, the function returns a two
dimensional array (prey species x prey size) based on the abundances also
passed in. If a <code>MizerSim</code> object is passed in, the function returns a
three dimensional array (time step x prey species x prey size) with the
predation mortality calculated at every time step in the simulation.
Dimensions may be dropped if they have length 1 unless <code>drop = FALSE</code>.
</p>


<h3>Your own predation mortality function</h3>

<p>By default <code><a href="#topic+getPredMort">getPredMort()</a></code> calls <code><a href="#topic+mizerPredMort">mizerPredMort()</a></code>. However you can
replace this with your own alternative predation mortality function. If
your function is called <code>"myPredMort"</code> then you register it in a MizerParams
object <code>params</code> with
</p>
<div class="sourceCode"><pre>params &lt;- setRateFunction(params, "PredMort", "myPredMort")
</pre></div>
<p>Your function will then be called instead of <code><a href="#topic+mizerPredMort">mizerPredMort()</a></code>, with the
same arguments.
</p>


<h3>See Also</h3>

<p>Other rate functions: 
<code><a href="#topic+getEGrowth">getEGrowth</a>()</code>,
<code><a href="#topic+getERepro">getERepro</a>()</code>,
<code><a href="#topic+getEReproAndGrowth">getEReproAndGrowth</a>()</code>,
<code><a href="#topic+getEncounter">getEncounter</a>()</code>,
<code><a href="#topic+getFMort">getFMort</a>()</code>,
<code><a href="#topic+getFMortGear">getFMortGear</a>()</code>,
<code><a href="#topic+getFeedingLevel">getFeedingLevel</a>()</code>,
<code><a href="#topic+getMort">getMort</a>()</code>,
<code><a href="#topic+getPredRate">getPredRate</a>()</code>,
<code><a href="#topic+getRDD">getRDD</a>()</code>,
<code><a href="#topic+getRDI">getRDI</a>()</code>,
<code><a href="#topic+getRates">getRates</a>()</code>,
<code><a href="#topic+getResourceMort">getResourceMort</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
params &lt;- NS_params
# With constant fishing effort for all gears for 20 time steps
sim &lt;- project(params, t_max = 20, effort = 0.5)
# Get predation mortality at one time step
getPredMort(params, n = N(sim)[15, , ], n_pp = NResource(sim)[15, ])
# Get predation mortality at all saved time steps
getPredMort(sim)
# Get predation mortality over the years 15 - 20
getPredMort(sim, time_range = c(15, 20))

</code></pre>

<hr>
<h2 id='getPredRate'>Get predation rate</h2><span id='topic+getPredRate'></span>

<h3>Description</h3>

<p>Calculates the potential rate (in units 1/year) at which a prey individual of
a given size <code class="reqn">w</code> is killed by predators from species <code class="reqn">j</code>. In formulas
</p>
<p style="text-align: center;"><code class="reqn">{\tt pred\_rate}_j(w_p) = \int \phi_j(w,w_p) (1-f_j(w)) 
  \gamma_j(w) N_j(w) \, dw.</code>
</p>

<p>This potential rate is used in <code><a href="#topic+getPredMort">getPredMort()</a></code> to
calculate the realised predation mortality rate on the prey individual.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getPredRate(
  params,
  n = initialN(params),
  n_pp = initialNResource(params),
  n_other = initialNOther(params),
  t = 0,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getPredRate_+3A_params">params</code></td>
<td>
<p>A <a href="#topic+MizerParams-class">MizerParams</a> object</p>
</td></tr>
<tr><td><code id="getPredRate_+3A_n">n</code></td>
<td>
<p>A matrix of species abundances (species x size).</p>
</td></tr>
<tr><td><code id="getPredRate_+3A_n_pp">n_pp</code></td>
<td>
<p>A vector of the resource abundance by size</p>
</td></tr>
<tr><td><code id="getPredRate_+3A_n_other">n_other</code></td>
<td>
<p>A list of abundances for other dynamical components of the
ecosystem</p>
</td></tr>
<tr><td><code id="getPredRate_+3A_t">t</code></td>
<td>
<p>The time for which to do the calculation (Not used by standard
mizer rate functions but useful for extensions with time-dependent
parameters.)</p>
</td></tr>
<tr><td><code id="getPredRate_+3A_...">...</code></td>
<td>
<p>Unused</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A two dimensional array (predator species x prey size),
where the prey size runs over fish community plus resource spectrum.
</p>


<h3>Your own predation rate function</h3>

<p>By default <code><a href="#topic+getPredRate">getPredRate()</a></code> calls <code><a href="#topic+mizerPredRate">mizerPredRate()</a></code>. However you can
replace this with your own alternative predation rate function. If
your function is called <code>"myPredRate"</code> then you register it in a MizerParams
object <code>params</code> with
</p>
<div class="sourceCode"><pre>params &lt;- setRateFunction(params, "PredRate", "myPredRate")
</pre></div>
<p>Your function will then be called instead of <code><a href="#topic+mizerPredRate">mizerPredRate()</a></code>, with
the same arguments.
</p>


<h3>See Also</h3>

<p>Other rate functions: 
<code><a href="#topic+getEGrowth">getEGrowth</a>()</code>,
<code><a href="#topic+getERepro">getERepro</a>()</code>,
<code><a href="#topic+getEReproAndGrowth">getEReproAndGrowth</a>()</code>,
<code><a href="#topic+getEncounter">getEncounter</a>()</code>,
<code><a href="#topic+getFMort">getFMort</a>()</code>,
<code><a href="#topic+getFMortGear">getFMortGear</a>()</code>,
<code><a href="#topic+getFeedingLevel">getFeedingLevel</a>()</code>,
<code><a href="#topic+getMort">getMort</a>()</code>,
<code><a href="#topic+getPredMort">getPredMort</a>()</code>,
<code><a href="#topic+getRDD">getRDD</a>()</code>,
<code><a href="#topic+getRDI">getRDI</a>()</code>,
<code><a href="#topic+getRates">getRates</a>()</code>,
<code><a href="#topic+getResourceMort">getResourceMort</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
params &lt;- NS_params
# With constant fishing effort for all gears for 20 time steps
sim &lt;- project(params, t_max = 20, effort = 0.5)
# Get the feeding level at one time step
getPredRate(params, n = N(sim)[15, , ], n_pp = NResource(sim)[15, ])

</code></pre>

<hr>
<h2 id='getProportionOfLargeFish'>Calculate the proportion of large fish</h2><span id='topic+getProportionOfLargeFish'></span>

<h3>Description</h3>

<p>Calculates the proportion of large fish through time in the <code>MizerSim</code>
class within user defined size limits. The default option is to use the whole
size range. You can specify minimum and maximum size ranges for the species
and also the threshold size for large fish. Sizes can be expressed as weight
or size. Lengths take precedence over weights (i.e. if both min_l and min_w
are supplied, only min_l will be used). You can also specify the species to
be used in the calculation. This function can be used to calculate the Large
Fish Index. The proportion is based on either abundance or biomass.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getProportionOfLargeFish(
  sim,
  species = NULL,
  threshold_w = 100,
  threshold_l = NULL,
  biomass_proportion = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getProportionOfLargeFish_+3A_sim">sim</code></td>
<td>
<p>A <a href="#topic+MizerSim-class">MizerSim</a> object</p>
</td></tr>
<tr><td><code id="getProportionOfLargeFish_+3A_species">species</code></td>
<td>
<p>The species to be selected. Optional. By default all target
species are selected. A vector of species names, or a
numeric vector with the species indices, or a logical vector indicating for
each species whether it is to be selected (TRUE) or not.</p>
</td></tr>
<tr><td><code id="getProportionOfLargeFish_+3A_threshold_w">threshold_w</code></td>
<td>
<p>the size used as the cutoff between large and small fish.
Default value is 100.</p>
</td></tr>
<tr><td><code id="getProportionOfLargeFish_+3A_threshold_l">threshold_l</code></td>
<td>
<p>the size used as the cutoff between large and small fish.</p>
</td></tr>
<tr><td><code id="getProportionOfLargeFish_+3A_biomass_proportion">biomass_proportion</code></td>
<td>
<p>a boolean value. If TRUE the proportion calculated
is based on biomass, if FALSE it is based on numbers of individuals.
Default is TRUE.</p>
</td></tr>
<tr><td><code id="getProportionOfLargeFish_+3A_...">...</code></td>
<td>

<p>Arguments passed on to <code><a href="#topic+get_size_range_array">get_size_range_array</a></code>
</p>

<dl>
<dt><code>min_w</code></dt><dd><p>Smallest weight in size range. Defaults to smallest weight in
the model.</p>
</dd>
<dt><code>max_w</code></dt><dd><p>Largest weight in size range. Defaults to largest weight in the
model.</p>
</dd>
<dt><code>min_l</code></dt><dd><p>Smallest length in size range. If supplied, this takes
precedence over <code>min_w</code>.</p>
</dd>
<dt><code>max_l</code></dt><dd><p>Largest length in size range. If supplied, this takes precedence
over <code>max_w</code>.</p>
</dd>
</dl>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector containing the proportion of large fish through time
</p>


<h3>See Also</h3>

<p>Other functions for calculating indicators: 
<code><a href="#topic+getCommunitySlope">getCommunitySlope</a>()</code>,
<code><a href="#topic+getMeanMaxWeight">getMeanMaxWeight</a>()</code>,
<code><a href="#topic+getMeanWeight">getMeanWeight</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>lfi &lt;- getProportionOfLargeFish(NS_sim, min_w = 10, max_w = 5000, 
                                threshold_w = 500)
years &lt;- c("1972", "2010")
lfi[years]
getProportionOfLargeFish(NS_sim)[years]
getProportionOfLargeFish(NS_sim, species=c("Herring","Sprat","N.pout"))[years]
getProportionOfLargeFish(NS_sim, min_w = 10, max_w = 5000)[years]
getProportionOfLargeFish(NS_sim, min_w = 10, max_w = 5000,
    threshold_w = 500, biomass_proportion = FALSE)[years]
</code></pre>

<hr>
<h2 id='getRates'>Get all rates</h2><span id='topic+getRates'></span>

<h3>Description</h3>

<p>Calls other rate functions in sequence and collects the results in a list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getRates(
  params,
  n = initialN(params),
  n_pp = initialNResource(params),
  n_other = initialNOther(params),
  effort,
  t = 0,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getRates_+3A_params">params</code></td>
<td>
<p>A <a href="#topic+MizerParams-class">MizerParams</a> object</p>
</td></tr>
<tr><td><code id="getRates_+3A_n">n</code></td>
<td>
<p>A matrix of species abundances (species x size).</p>
</td></tr>
<tr><td><code id="getRates_+3A_n_pp">n_pp</code></td>
<td>
<p>A vector of the resource abundance by size</p>
</td></tr>
<tr><td><code id="getRates_+3A_n_other">n_other</code></td>
<td>
<p>A list of abundances for other dynamical components of the
ecosystem</p>
</td></tr>
<tr><td><code id="getRates_+3A_effort">effort</code></td>
<td>
<p>The effort for each fishing gear</p>
</td></tr>
<tr><td><code id="getRates_+3A_t">t</code></td>
<td>
<p>The time for which to do the calculation (Not used by standard
mizer rate functions but useful for extensions with time-dependent
parameters.)</p>
</td></tr>
<tr><td><code id="getRates_+3A_...">...</code></td>
<td>
<p>Unused</p>
</td></tr>
</table>


<h3>Details</h3>

<p>By default this function returns a list with the following components:
</p>

<ul>
<li><p> encounter from <code><a href="#topic+mizerEncounter">mizerEncounter()</a></code>
</p>
</li>
<li><p> feeding_level from <code><a href="#topic+mizerFeedingLevel">mizerFeedingLevel()</a></code>
</p>
</li>
<li><p> e from <code><a href="#topic+mizerEReproAndGrowth">mizerEReproAndGrowth()</a></code>
</p>
</li>
<li><p> e_repro from <code><a href="#topic+mizerERepro">mizerERepro()</a></code>
</p>
</li>
<li><p> e_growth from <code><a href="#topic+mizerEGrowth">mizerEGrowth()</a></code>
</p>
</li>
<li><p> pred_rate from <code><a href="#topic+mizerPredRate">mizerPredRate()</a></code>
</p>
</li>
<li><p> pred_mort from <code><a href="#topic+mizerPredMort">mizerPredMort()</a></code>
</p>
</li>
<li><p> f_mort from <code><a href="#topic+mizerFMort">mizerFMort()</a></code>
</p>
</li>
<li><p> mort from <code><a href="#topic+mizerMort">mizerMort()</a></code>
</p>
</li>
<li><p> rdi from <code><a href="#topic+mizerRDI">mizerRDI()</a></code>
</p>
</li>
<li><p> rdd from <code><a href="#topic+BevertonHoltRDD">BevertonHoltRDD()</a></code>
</p>
</li>
<li><p> resource_mort from <code><a href="#topic+mizerResourceMort">mizerResourceMort()</a></code>
</p>
</li></ul>

<p>However you can replace any of these rate functions by your own rate
function if you wish, see <code><a href="#topic+setRateFunction">setRateFunction()</a></code> for details.
</p>


<h3>Value</h3>

<p>List of rates.
</p>


<h3>See Also</h3>

<p>Other rate functions: 
<code><a href="#topic+getEGrowth">getEGrowth</a>()</code>,
<code><a href="#topic+getERepro">getERepro</a>()</code>,
<code><a href="#topic+getEReproAndGrowth">getEReproAndGrowth</a>()</code>,
<code><a href="#topic+getEncounter">getEncounter</a>()</code>,
<code><a href="#topic+getFMort">getFMort</a>()</code>,
<code><a href="#topic+getFMortGear">getFMortGear</a>()</code>,
<code><a href="#topic+getFeedingLevel">getFeedingLevel</a>()</code>,
<code><a href="#topic+getMort">getMort</a>()</code>,
<code><a href="#topic+getPredMort">getPredMort</a>()</code>,
<code><a href="#topic+getPredRate">getPredRate</a>()</code>,
<code><a href="#topic+getRDD">getRDD</a>()</code>,
<code><a href="#topic+getRDI">getRDI</a>()</code>,
<code><a href="#topic+getResourceMort">getResourceMort</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rates &lt;- getRates(NS_params)
names(rates)
identical(rates$encounter, getEncounter(NS_params))
</code></pre>

<hr>
<h2 id='getRDD'>Get density dependent reproduction rate</h2><span id='topic+getRDD'></span>

<h3>Description</h3>

<p>Calculates the density dependent rate of egg production <code class="reqn">R_i</code> (units
1/year) for each species. This is the flux entering the smallest size class
of each species. The density dependent rate is the density independent
rate obtained with <code><a href="#topic+getRDI">getRDI()</a></code> after it has been put through the
density dependence function. This is the Beverton-Holt function
<code><a href="#topic+BevertonHoltRDD">BevertonHoltRDD()</a></code> by default, but this can be changed. See
<code><a href="#topic+setReproduction">setReproduction()</a></code> for more details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getRDD(
  params,
  n = initialN(params),
  n_pp = initialNResource(params),
  n_other = initialNOther(params),
  t = 0,
  rdi = getRDI(params, n = n, n_pp = n_pp, n_other = n_other, t = t),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getRDD_+3A_params">params</code></td>
<td>
<p>A <a href="#topic+MizerParams-class">MizerParams</a> object</p>
</td></tr>
<tr><td><code id="getRDD_+3A_n">n</code></td>
<td>
<p>A matrix of species abundances (species x size).</p>
</td></tr>
<tr><td><code id="getRDD_+3A_n_pp">n_pp</code></td>
<td>
<p>A vector of the resource abundance by size</p>
</td></tr>
<tr><td><code id="getRDD_+3A_n_other">n_other</code></td>
<td>
<p>A list of abundances for other dynamical components of the
ecosystem</p>
</td></tr>
<tr><td><code id="getRDD_+3A_t">t</code></td>
<td>
<p>The time for which to do the calculation (Not used by standard
mizer rate functions but useful for extensions with time-dependent
parameters.)</p>
</td></tr>
<tr><td><code id="getRDD_+3A_rdi">rdi</code></td>
<td>
<p>A vector of density-independent reproduction rates for each
species. If not specified, rdi is calculated internally using
<code><a href="#topic+getRDI">getRDI()</a></code>.</p>
</td></tr>
<tr><td><code id="getRDD_+3A_...">...</code></td>
<td>
<p>Unused</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector the length of the number of species.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+getRDI">getRDI()</a></code>
</p>
<p>Other rate functions: 
<code><a href="#topic+getEGrowth">getEGrowth</a>()</code>,
<code><a href="#topic+getERepro">getERepro</a>()</code>,
<code><a href="#topic+getEReproAndGrowth">getEReproAndGrowth</a>()</code>,
<code><a href="#topic+getEncounter">getEncounter</a>()</code>,
<code><a href="#topic+getFMort">getFMort</a>()</code>,
<code><a href="#topic+getFMortGear">getFMortGear</a>()</code>,
<code><a href="#topic+getFeedingLevel">getFeedingLevel</a>()</code>,
<code><a href="#topic+getMort">getMort</a>()</code>,
<code><a href="#topic+getPredMort">getPredMort</a>()</code>,
<code><a href="#topic+getPredRate">getPredRate</a>()</code>,
<code><a href="#topic+getRDI">getRDI</a>()</code>,
<code><a href="#topic+getRates">getRates</a>()</code>,
<code><a href="#topic+getResourceMort">getResourceMort</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
params &lt;- NS_params
# Project with constant fishing effort for all gears for 20 time steps
sim &lt;- project(params, t_max = 20, effort = 0.5)
# Get the rate at a particular time step
getRDD(params, n = N(sim)[15, , ], n_pp = NResource(sim)[15, ], t = 15)

</code></pre>

<hr>
<h2 id='getRDI'>Get density independent rate of egg production</h2><span id='topic+getRDI'></span>

<h3>Description</h3>

<p>Calculates the density-independent rate of total egg production
<code class="reqn">R_{di}</code> (units 1/year) before density dependence, by species.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getRDI(
  params,
  n = initialN(params),
  n_pp = initialNResource(params),
  n_other = initialNOther(params),
  t = 0,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getRDI_+3A_params">params</code></td>
<td>
<p>A <a href="#topic+MizerParams-class">MizerParams</a> object</p>
</td></tr>
<tr><td><code id="getRDI_+3A_n">n</code></td>
<td>
<p>A matrix of species abundances (species x size).</p>
</td></tr>
<tr><td><code id="getRDI_+3A_n_pp">n_pp</code></td>
<td>
<p>A vector of the resource abundance by size</p>
</td></tr>
<tr><td><code id="getRDI_+3A_n_other">n_other</code></td>
<td>
<p>A list of abundances for other dynamical components of the
ecosystem</p>
</td></tr>
<tr><td><code id="getRDI_+3A_t">t</code></td>
<td>
<p>The time for which to do the calculation (Not used by standard
mizer rate functions but useful for extensions with time-dependent
parameters.)</p>
</td></tr>
<tr><td><code id="getRDI_+3A_...">...</code></td>
<td>
<p>Unused</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This rate is obtained by taking the per capita rate <code class="reqn">E_r(w)\psi(w)</code> at
which energy is invested in reproduction, as calculated by <code><a href="#topic+getERepro">getERepro()</a></code>,
multiplying it by the number of individuals<code class="reqn">N(w)</code> and integrating over
all sizes <code class="reqn">w</code> and then multiplying by the reproductive efficiency
<code class="reqn">\epsilon</code> and dividing by the egg size <code>w_min</code>, and by a factor of two
to account for the two sexes:
</p>
<p style="text-align: center;"><code class="reqn">R_{di} = \frac{\epsilon}{2 w_{min}} \int N(w)  E_r(w) \psi(w) \, dw</code>
</p>

<p>Used by <code><a href="#topic+getRDD">getRDD()</a></code> to calculate the actual, density dependent rate.
See <code><a href="#topic+setReproduction">setReproduction()</a></code> for more details.
</p>


<h3>Value</h3>

<p>A numeric vector the length of the number of species.
</p>


<h3>Your own reproduction function</h3>

<p>By default <code><a href="#topic+getRDI">getRDI()</a></code> calls <code><a href="#topic+mizerRDI">mizerRDI()</a></code>. However you can
replace this with your own alternative reproduction function. If
your function is called <code>"myRDI"</code> then you register it in a MizerParams
object <code>params</code> with
</p>
<div class="sourceCode"><pre>params &lt;- setRateFunction(params, "RDI", "myRDI")
</pre></div>
<p>Your function will then be called instead of <code><a href="#topic+mizerRDI">mizerRDI()</a></code>, with the
same arguments. For an example of an alternative reproduction function
see <code>constantEggRDI()</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+getRDD">getRDD()</a></code>
</p>
<p>Other rate functions: 
<code><a href="#topic+getEGrowth">getEGrowth</a>()</code>,
<code><a href="#topic+getERepro">getERepro</a>()</code>,
<code><a href="#topic+getEReproAndGrowth">getEReproAndGrowth</a>()</code>,
<code><a href="#topic+getEncounter">getEncounter</a>()</code>,
<code><a href="#topic+getFMort">getFMort</a>()</code>,
<code><a href="#topic+getFMortGear">getFMortGear</a>()</code>,
<code><a href="#topic+getFeedingLevel">getFeedingLevel</a>()</code>,
<code><a href="#topic+getMort">getMort</a>()</code>,
<code><a href="#topic+getPredMort">getPredMort</a>()</code>,
<code><a href="#topic+getPredRate">getPredRate</a>()</code>,
<code><a href="#topic+getRDD">getRDD</a>()</code>,
<code><a href="#topic+getRates">getRates</a>()</code>,
<code><a href="#topic+getResourceMort">getResourceMort</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
params &lt;- NS_params
# Project with constant fishing effort for all gears for 20 time steps
sim &lt;- project(params, t_max = 20, effort = 0.5)
# Get the density-independent reproduction rate at a particular time step
getRDI(params, n = N(sim)[15, , ], n_pp = NResource(sim)[15, ], t = 15)

</code></pre>

<hr>
<h2 id='getReproductionLevel'>Get reproduction level</h2><span id='topic+getReproductionLevel'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
The reproduction level is the ratio between the density-dependent
reproduction rate and the maximal reproduction rate.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getReproductionLevel(params)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getReproductionLevel_+3A_params">params</code></td>
<td>
<p>A MizerParams object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named vector with the reproduction level for each species.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>getReproductionLevel(NS_params)

# The reproduction level can be changed without changing the steady state:
params &lt;- setBevertonHolt(NS_params, reproduction_level = 0.9)
getReproductionLevel(params)

# The result is the ratio of RDD and R_max
identical(getRDD(params) / species_params(params)$R_max,
          getReproductionLevel(params))
</code></pre>

<hr>
<h2 id='getResourceDynamics'>Deprecated functions for getting resource parameters</h2><span id='topic+getResourceDynamics'></span><span id='topic+getResourceLevel'></span><span id='topic+getResourceRate'></span><span id='topic+getResourceCapacity'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a> Use <code><a href="#topic+resource_dynamics">resource_dynamics()</a></code>,
<code><a href="#topic+resource_level">resource_level()</a></code>, <code><a href="#topic+resource_rate">resource_rate()</a></code> and <code><a href="#topic+resource_capacity">resource_capacity()</a></code> instead.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getResourceDynamics(params)

getResourceLevel(params)

getResourceRate(params)

getResourceCapacity(params)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getResourceDynamics_+3A_params">params</code></td>
<td>
<p>A MizerParams object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Name of the function that determines the resource dynamics
</p>

<hr>
<h2 id='getResourceMort'>Get predation mortality rate for resource</h2><span id='topic+getResourceMort'></span>

<h3>Description</h3>

<p>Calculates the predation mortality rate <code class="reqn">\mu_p(w)</code> on the resource
spectrum by resource size (in units 1/year).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getResourceMort(
  params,
  n = initialN(params),
  n_pp = initialNResource(params),
  n_other = initialNOther(params),
  t = 0,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getResourceMort_+3A_params">params</code></td>
<td>
<p>A <a href="#topic+MizerParams-class">MizerParams</a> object</p>
</td></tr>
<tr><td><code id="getResourceMort_+3A_n">n</code></td>
<td>
<p>A matrix of species abundances (species x size).</p>
</td></tr>
<tr><td><code id="getResourceMort_+3A_n_pp">n_pp</code></td>
<td>
<p>A vector of the resource abundance by size</p>
</td></tr>
<tr><td><code id="getResourceMort_+3A_n_other">n_other</code></td>
<td>
<p>A list of abundances for other dynamical components of the
ecosystem</p>
</td></tr>
<tr><td><code id="getResourceMort_+3A_t">t</code></td>
<td>
<p>The time for which to do the calculation (Not used by standard
mizer rate functions but useful for extensions with time-dependent
parameters.)</p>
</td></tr>
<tr><td><code id="getResourceMort_+3A_...">...</code></td>
<td>
<p>Unused</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of mortality rate by resource size.
</p>


<h3>Your own resource mortality function</h3>

<p>By default <code><a href="#topic+getResourceMort">getResourceMort()</a></code> calls <code><a href="#topic+mizerResourceMort">mizerResourceMort()</a></code>. However you can
replace this with your own alternative resource mortality function. If
your function is called <code>"myResourceMort"</code> then you register it in a MizerParams
object <code>params</code> with
</p>
<div class="sourceCode"><pre>params &lt;- setRateFunction(params, "ResourceMort", "myResourceMort")
</pre></div>
<p>Your function will then be called instead of <code><a href="#topic+mizerResourceMort">mizerResourceMort()</a></code>, with the
same arguments.
</p>


<h3>See Also</h3>

<p>Other rate functions: 
<code><a href="#topic+getEGrowth">getEGrowth</a>()</code>,
<code><a href="#topic+getERepro">getERepro</a>()</code>,
<code><a href="#topic+getEReproAndGrowth">getEReproAndGrowth</a>()</code>,
<code><a href="#topic+getEncounter">getEncounter</a>()</code>,
<code><a href="#topic+getFMort">getFMort</a>()</code>,
<code><a href="#topic+getFMortGear">getFMortGear</a>()</code>,
<code><a href="#topic+getFeedingLevel">getFeedingLevel</a>()</code>,
<code><a href="#topic+getMort">getMort</a>()</code>,
<code><a href="#topic+getPredMort">getPredMort</a>()</code>,
<code><a href="#topic+getPredRate">getPredRate</a>()</code>,
<code><a href="#topic+getRDD">getRDD</a>()</code>,
<code><a href="#topic+getRDI">getRDI</a>()</code>,
<code><a href="#topic+getRates">getRates</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
params &lt;- NS_params
# With constant fishing effort for all gears for 20 time steps
sim &lt;- project(params, t_max = 20, effort = 0.5)
# Get resource mortality at one time step
getResourceMort(params, n = N(sim)[15, , ], n_pp = NResource(sim)[15, ])

</code></pre>

<hr>
<h2 id='getSSB'>Calculate the SSB of species</h2><span id='topic+getSSB'></span>

<h3>Description</h3>

<p>Calculates the spawning stock biomass (SSB) through time of the species in
the <code>MizerSim</code> class. SSB is calculated as the total mass of all mature
individuals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getSSB(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getSSB_+3A_object">object</code></td>
<td>
<p>An object of class <code>MizerParams</code> or MizerSim'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If called with a MizerParams object, a vector with the SSB in
grams for each species in the model. If called with a MizerSim object, an
array (time x species) containing the SSB in grams at each time step
for all species.
</p>


<h3>See Also</h3>

<p>Other summary functions: 
<code><a href="#topic+getBiomass">getBiomass</a>()</code>,
<code><a href="#topic+getDiet">getDiet</a>()</code>,
<code><a href="#topic+getGrowthCurves">getGrowthCurves</a>()</code>,
<code><a href="#topic+getN">getN</a>()</code>,
<code><a href="#topic+getYield">getYield</a>()</code>,
<code><a href="#topic+getYieldGear">getYieldGear</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ssb &lt;- getSSB(NS_sim)
ssb[c("1972", "2010"), c("Herring", "Cod")]
</code></pre>

<hr>
<h2 id='getTimes'>Times for which simulation results are available</h2><span id='topic+getTimes'></span>

<h3>Description</h3>

<p>Times for which simulation results are available
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getTimes(sim)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getTimes_+3A_sim">sim</code></td>
<td>
<p>A MizerSim object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vectors of the times (in years) at which simulation results
have been stored in the MizerSim object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>getTimes(NS_sim)
</code></pre>

<hr>
<h2 id='getYield'>Calculate the rate at which biomass of each species is fished</h2><span id='topic+getYield'></span>

<h3>Description</h3>

<p>This yield rate is given in grams per year. It is calculated at each time
step saved in the MizerSim object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getYield(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getYield_+3A_object">object</code></td>
<td>
<p>An object of class <code>MizerParams</code> or <code>MizerSim</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The yield rate <code class="reqn">y_i(t)</code> for species <code class="reqn">i</code> at time <code class="reqn">t</code> is defined as
</p>
<p style="text-align: center;"><code class="reqn">y_i(t)=\int\mu_{f.i}(w, t)N_i(w, t)w dw</code>
</p>

<p>where <code class="reqn">\mu_{f.i}(w, t)</code> is the fishing mortality of an individual of
species <code class="reqn">i</code> and weight <code class="reqn">w</code> at time <code class="reqn">t</code> and <code class="reqn">N_i(w, t)</code> is the
abundance density of such individuals.  The factor of <code class="reqn">w</code> converts the
abundance density into a biomass density and the integral aggregates the
contribution from all sizes.
</p>
<p>The total catch in a time period from <code class="reqn">t_1</code> to  <code class="reqn">t_2</code> is the integral
of the yield rate over that period:
</p>
<p style="text-align: center;"><code class="reqn">C = \int_{t_1}^{t2}y_i(t)dt</code>
</p>

<p>In practice, as the yield rate is only available
at the saved times, one can only approximate this integral by averaging over
the available yield rates during the time period and multiplying by the time
period. The less the yield changes between the saved values, the more
accurate this approximation is. So the approximation can be improved by
saving simulation results at smaller intervals, using the <code>t_save</code> argument
to <code><a href="#topic+project">project()</a></code>. But this is only a concern if abundances change quickly
during the time period of interest.
</p>


<h3>Value</h3>

<p>If called with a MizerParams object, a vector with the yield rate in
grams per year for each species in the model. If called with a MizerSim
object, an array (time x species) containing the yield rate at each time
step for all species.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+getYieldGear">getYieldGear()</a></code>
</p>
<p>Other summary functions: 
<code><a href="#topic+getBiomass">getBiomass</a>()</code>,
<code><a href="#topic+getDiet">getDiet</a>()</code>,
<code><a href="#topic+getGrowthCurves">getGrowthCurves</a>()</code>,
<code><a href="#topic+getN">getN</a>()</code>,
<code><a href="#topic+getSSB">getSSB</a>()</code>,
<code><a href="#topic+getYieldGear">getYieldGear</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>yield &lt;- getYield(NS_sim)
yield[c("1972", "2010"), c("Herring", "Cod")]

# Running simulation for another year, saving intermediate time steps
params &lt;- setInitialValues(getParams(NS_sim), NS_sim)
sim &lt;- project(params, t_save = 0.1, t_max = 1, 
               t_start = 2010, progress_bar = FALSE)
# The yield rate for Herring decreases during the year
getYield(sim)[, "Herring"]
# We get the total catch in the year by averaging over the year
sum(getYield(sim)[1:10, "Herring"] / 10)
</code></pre>

<hr>
<h2 id='getYieldGear'>Calculate the rate at which biomass of each species is fished by each gear</h2><span id='topic+getYieldGear'></span>

<h3>Description</h3>

<p>This yield rate is given in grams per year. It is calculated at each time
step saved in the MizerSim object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getYieldGear(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getYieldGear_+3A_object">object</code></td>
<td>
<p>An object of class <code>MizerParams</code> or <code>MizerSim</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For details of how the yield rate is defined see the help page of
<code><a href="#topic+getYield">getYield()</a></code>.
</p>


<h3>Value</h3>

<p>If called with a MizerParams object, an array (gear x species) with
the yield rate in grams per year from each gear for each species in the
model. If called with a MizerSim object, an array (time x gear x species)
containing the yield rate at each time step.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+getYield">getYield()</a></code>
</p>
<p>Other summary functions: 
<code><a href="#topic+getBiomass">getBiomass</a>()</code>,
<code><a href="#topic+getDiet">getDiet</a>()</code>,
<code><a href="#topic+getGrowthCurves">getGrowthCurves</a>()</code>,
<code><a href="#topic+getN">getN</a>()</code>,
<code><a href="#topic+getSSB">getSSB</a>()</code>,
<code><a href="#topic+getYield">getYield</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>yield &lt;- getYieldGear(NS_sim)
yield["1972", "Herring", "Herring"]
# (In this example MizerSim object each species was set up with its own gear)
</code></pre>

<hr>
<h2 id='getZ'>Alias for <code>getMort()</code></h2><span id='topic+getZ'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
An alias provided for backward compatibility with mizer version &lt;= 1.0
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getZ(
  params,
  n = initialN(params),
  n_pp = initialNResource(params),
  n_other = initialNOther(params),
  effort = getInitialEffort(params),
  t = 0,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getZ_+3A_params">params</code></td>
<td>
<p>A <a href="#topic+MizerParams-class">MizerParams</a> object</p>
</td></tr>
<tr><td><code id="getZ_+3A_n">n</code></td>
<td>
<p>A matrix of species abundances (species x size).</p>
</td></tr>
<tr><td><code id="getZ_+3A_n_pp">n_pp</code></td>
<td>
<p>A vector of the resource abundance by size</p>
</td></tr>
<tr><td><code id="getZ_+3A_n_other">n_other</code></td>
<td>
<p>A list of abundances for other dynamical components of the
ecosystem</p>
</td></tr>
<tr><td><code id="getZ_+3A_effort">effort</code></td>
<td>
<p>A numeric vector of the effort by gear or a single numeric
effort value which is used for all gears.</p>
</td></tr>
<tr><td><code id="getZ_+3A_t">t</code></td>
<td>
<p>The time for which to do the calculation (Not used by standard
mizer rate functions but useful for extensions with time-dependent
parameters.)</p>
</td></tr>
<tr><td><code id="getZ_+3A_...">...</code></td>
<td>
<p>Unused</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If your model contains additional components that you added with
<code><a href="#topic+setComponent">setComponent()</a></code> and for which you specified a <code>mort_fun</code> function then
the mortality inflicted by these components will be included in the returned
value.
</p>


<h3>Value</h3>

<p>A two dimensional array (prey species x prey size).
</p>


<h3>Your own mortality function</h3>

<p>By default <code><a href="#topic+getMort">getMort()</a></code> calls <code><a href="#topic+mizerMort">mizerMort()</a></code>. However you can
replace this with your own alternative mortality function. If
your function is called <code>"myMort"</code> then you register it in a MizerParams
object <code>params</code> with
</p>
<div class="sourceCode"><pre>params &lt;- setRateFunction(params, "Mort", "myMort")
</pre></div>
<p>Your function will then be called instead of <code><a href="#topic+mizerMort">mizerMort()</a></code>, with the
same arguments.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+getPredMort">getPredMort()</a></code>, <code><a href="#topic+getFMort">getFMort()</a></code>
</p>
<p>Other rate functions: 
<code><a href="#topic+getEGrowth">getEGrowth</a>()</code>,
<code><a href="#topic+getERepro">getERepro</a>()</code>,
<code><a href="#topic+getEReproAndGrowth">getEReproAndGrowth</a>()</code>,
<code><a href="#topic+getEncounter">getEncounter</a>()</code>,
<code><a href="#topic+getFMort">getFMort</a>()</code>,
<code><a href="#topic+getFMortGear">getFMortGear</a>()</code>,
<code><a href="#topic+getFeedingLevel">getFeedingLevel</a>()</code>,
<code><a href="#topic+getPredMort">getPredMort</a>()</code>,
<code><a href="#topic+getPredRate">getPredRate</a>()</code>,
<code><a href="#topic+getRDD">getRDD</a>()</code>,
<code><a href="#topic+getRDI">getRDI</a>()</code>,
<code><a href="#topic+getRates">getRates</a>()</code>,
<code><a href="#topic+getResourceMort">getResourceMort</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
params &lt;- NS_params
# Project with constant fishing effort for all gears for 20 time steps
sim &lt;- project(params, t_max = 20, effort = 0.5)
# Get the total mortality at a particular time step
getMort(params, n = N(sim)[15, , ], n_pp = NResource(sim)[15, ], 
        t = 15, effort = 0.5)

</code></pre>

<hr>
<h2 id='idxFinalT'>Time index at end of simulation</h2><span id='topic+idxFinalT'></span>

<h3>Description</h3>

<p>Time index at end of simulation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>idxFinalT(sim)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="idxFinalT_+3A_sim">sim</code></td>
<td>
<p>A MizerSim object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An integer giving the index for extracting the
results for the final time step
</p>


<h3>Examples</h3>

<pre><code class='language-R'>idx &lt;- idxFinalT(NS_sim)
idx
# This coincides with
length(getTimes(NS_sim))
# and corresponds to the final time
getTimes(NS_sim)[idx]
# We can use this index to extract the result at the final time
identical(N(NS_sim)[idx, , ], finalN(NS_sim))
identical(NResource(NS_sim)[idx, ], finalNResource(NS_sim))
</code></pre>

<hr>
<h2 id='indicator_functions'>Description of indicator functions</h2><span id='topic+indicator_functions'></span>

<h3>Description</h3>

<p>Mizer provides a range of functions to calculate indicators
from a MizerSim object.
</p>


<h3>Details</h3>

<p>A list of available indicator functions for MizerSim objects is given in the table below
</p>

<table>
<tr>
 <td style="text-align: left;">
Function </td><td style="text-align: left;"> Returns </td><td style="text-align: left;"> Description </td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+getProportionOfLargeFish">getProportionOfLargeFish()</a></code> </td><td style="text-align: left;"> A vector with values at each time step. </td><td style="text-align: left;"> Calculates the proportion of large fish through time. The threshold value can be specified. It is possible to calculation the proportion of large fish based on either length or weight. </td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+getMeanWeight">getMeanWeight()</a></code> </td><td style="text-align: left;"> A vector with values at each saved time step. </td><td style="text-align: left;"> The mean weight of the community through time. This is calculated as the total biomass of the community divided by the total abundance. </td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+getMeanMaxWeight">getMeanMaxWeight()</a></code> </td><td style="text-align: left;"> Depends on the measure argument. If measure = “both” then you get a matrix with two columns, one with values by numbers, the other with values by biomass at each saved time step. If measure = “numbers” or “biomass” you get a vector of the respective values at each saved time step </td><td style="text-align: left;"> The mean maximum weight of the community through time. This can be calculated by numbers or by biomass. See the help file for more details. </td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+getCommunitySlope">getCommunitySlope()</a></code> </td><td style="text-align: left;"> A data.frame with four columns: time step, slope, intercept and the coefficient of determination. </td><td style="text-align: left;"> Calculates the slope of the community abundance spectrum through time by performing a linear regression on the logged total numerical abundance and logged body size. </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>See Also</h3>

<p><a href="#topic+summary_functions">summary_functions</a>, <a href="#topic+plotting_functions">plotting_functions</a>
</p>

<hr>
<h2 id='initial_effort'>Initial fishing effort</h2><span id='topic+initial_effort'></span><span id='topic+initial_effort+3C-'></span><span id='topic+validEffortVector'></span>

<h3>Description</h3>

<p>The fishing effort is a named vector, specifying for each fishing gear the
effort invested into fishing with that gear. The effort value for each gear
is multiplied by the catchability and the selectivity to determine the
fishing mortality imposed by that gear, see <code><a href="#topic+setFishing">setFishing()</a></code> for more details.
</p>
<p>A valid effort vector is a named vector with one effort value for each gear.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>initial_effort(params)

initial_effort(params) &lt;- value

validEffortVector(effort, params)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="initial_effort_+3A_params">params</code></td>
<td>
<p>A MizerParams object</p>
</td></tr>
<tr><td><code id="initial_effort_+3A_value">value</code></td>
<td>
<p>The initial fishing effort</p>
</td></tr>
<tr><td><code id="initial_effort_+3A_effort">effort</code></td>
<td>
<p>A vector or scalar.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The initial effort you have set can be overruled when running a simulation
by providing an <code>effort</code> argument to <code><a href="#topic+project">project()</a></code> which allows you to
specify a time-varying effort.
</p>
<p>The function also accepts an <code>effort</code> that is not yet valid:
</p>

<ul>
<li><p> a scalar, which is then replicated for each gear
</p>
</li>
<li><p> an unnamed vector, which is then assumed to be in the same order as the
gears in the params object
</p>
</li>
<li><p> a named vector in which the gear names have a different order than in the
params object. This is then sorted correctly.
</p>
</li>
<li><p> a named vector which only supplies values for some of the gears.
The effort for the other gears is then set to zero.
</p>
</li></ul>

<p>An <code>effort</code> argument will lead to an error if it is either
</p>

<ul>
<li><p> unnamed and of the wrong length
</p>
</li>
<li><p> named but where some names do not match any of the gears
</p>
</li>
<li><p> not numeric
</p>
</li></ul>



<h3>Value</h3>

<p>Effort vector
</p>

<hr>
<h2 id='initialN+26lt+3B-'>Initial values for fish spectra</h2><span id='topic+initialN+3C-'></span><span id='topic+initialN'></span>

<h3>Description</h3>

<p>Values used as starting values for simulations with <code>project()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>initialN(params) &lt;- value

initialN(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="initialN+2B26lt+2B3B-_+3A_params">params</code></td>
<td>
<p>A MizerParams object</p>
</td></tr>
<tr><td><code id="initialN+2B26lt+2B3B-_+3A_value">value</code></td>
<td>
<p>A matrix with dimensions species x size holding the initial
number densities for the fish spectra.</p>
</td></tr>
<tr><td><code id="initialN+2B26lt+2B3B-_+3A_object">object</code></td>
<td>
<p>An object of class MizerParams or MizerSim</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with dimensions species x size holding the initial number
densities for the fish spectra.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Doubling abundance of Cod in the initial state of the North Sea model
params &lt;- NS_params
initialN(params)["Cod", ] &lt;- 2 * initialN(params)["Cod", ]
# Calculating the corresponding initial biomass
biomass &lt;- initialN(params)["Cod", ] * dw(NS_params) * w(NS_params)
# Of course this initial state will no longer be a steady state
params &lt;- steady(params)
</code></pre>

<hr>
<h2 id='initialNOther+26lt+3B-'>Initial values for other ecosystem components</h2><span id='topic+initialNOther+3C-'></span><span id='topic+initialNOther'></span>

<h3>Description</h3>

<p>Values used as starting values for simulations with <code>project()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>initialNOther(params) &lt;- value

initialNOther(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="initialNOther+2B26lt+2B3B-_+3A_params">params</code></td>
<td>
<p>A MizerParams object</p>
</td></tr>
<tr><td><code id="initialNOther+2B26lt+2B3B-_+3A_value">value</code></td>
<td>
<p>A named list with the initial values of other ecosystem
components</p>
</td></tr>
<tr><td><code id="initialNOther+2B26lt+2B3B-_+3A_object">object</code></td>
<td>
<p>An object of class MizerParams or MizerSim</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named list with the initial values of other ecosystem
components
</p>

<hr>
<h2 id='initialNResource+26lt+3B-'>Initial value for resource spectrum</h2><span id='topic+initialNResource+3C-'></span><span id='topic+initialNResource'></span>

<h3>Description</h3>

<p>Value used as starting value for simulations with <code>project()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>initialNResource(params) &lt;- value

initialNResource(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="initialNResource+2B26lt+2B3B-_+3A_params">params</code></td>
<td>
<p>A MizerParams object</p>
</td></tr>
<tr><td><code id="initialNResource+2B26lt+2B3B-_+3A_value">value</code></td>
<td>
<p>A vector with the initial number densities for the resource
spectrum</p>
</td></tr>
<tr><td><code id="initialNResource+2B26lt+2B3B-_+3A_object">object</code></td>
<td>
<p>An object of class MizerParams or MizerSim</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector with the initial number densities for the resource
spectrum
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Doubling resource abundance in the initial state of the North Sea model
params &lt;- NS_params
initialNResource(params) &lt;- 2 * initialNResource(params)
# Of course this initial state will no longer be a steady state
params &lt;- steady(params)
</code></pre>

<hr>
<h2 id='inter'>Alias for <code>NS_interaction</code></h2><span id='topic+inter'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
An alias provided for backward compatibility with mizer version &lt;= 2.3
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inter
</code></pre>


<h3>Format</h3>

<p>A 12 x 12 matrix.
</p>


<h3>Source</h3>

<p>Blanchard et al.
</p>

<hr>
<h2 id='knife_edge'>Weight based knife-edge selectivity function</h2><span id='topic+knife_edge'></span>

<h3>Description</h3>

<p>A knife-edge selectivity function where weights greater or equal to
<code>knife_edge_size</code> are selected.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>knife_edge(w, knife_edge_size, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="knife_edge_+3A_w">w</code></td>
<td>
<p>Vector of sizes.</p>
</td></tr>
<tr><td><code id="knife_edge_+3A_knife_edge_size">knife_edge_size</code></td>
<td>
<p>The weight at which the knife-edge operates.</p>
</td></tr>
<tr><td><code id="knife_edge_+3A_...">...</code></td>
<td>
<p>Unused</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector of selectivities at the given sizes.
</p>


<h3>See Also</h3>

<p>Other selectivity functions: 
<code><a href="#topic+double_sigmoid_length">double_sigmoid_length</a>()</code>,
<code><a href="#topic+sigmoid_length">sigmoid_length</a>()</code>,
<code><a href="#topic+sigmoid_weight">sigmoid_weight</a>()</code>
</p>

<hr>
<h2 id='l2w'>Length-weight conversion</h2><span id='topic+l2w'></span><span id='topic+w2l'></span>

<h3>Description</h3>

<p>Convert between length and weight using the relationship
</p>
<p style="text-align: center;"><code class="reqn">w = a l^b</code>
</p>

<p>where <code>a</code> and <code>b</code> are taken from the species parameter data frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>l2w(l, params)

w2l(w, params)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="l2w_+3A_l">l</code></td>
<td>
<p>Lengths in cm. Either a single number or a vector with one number
for each species.</p>
</td></tr>
<tr><td><code id="l2w_+3A_params">params</code></td>
<td>
<p>A species parameter data frame or a MizerParams object.</p>
</td></tr>
<tr><td><code id="l2w_+3A_w">w</code></td>
<td>
<p>Weights in grams. Either a single number or a vector with one number
for each species.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is useful for converting a length-based species parameter to a
weight-based species parameter.
</p>
<p>If any <code>a</code> or <code>b</code> parameters are missing the default values <code>a = 0.01</code> and
<code>b = 3</code> are used for the missing values.
</p>


<h3>Value</h3>

<p>A vector with one entry for each species. <code>l2w()</code> returns a vector
of weights in grams and <code>w2l()</code> returns a vector of lengths in cm.
</p>

<hr>
<h2 id='log_breaks'>Helper function to produce nice breaks on logarithmic axes</h2><span id='topic+log_breaks'></span>

<h3>Description</h3>

<p>This is needed when the logarithmic y-axis spans less than one order of
magnitude, in which case the ggplot2 default produces no ticks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>log_breaks(n = 6)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="log_breaks_+3A_n">n</code></td>
<td>
<p>Approximate number of ticks</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Thanks to Heather Turner at
https://stackoverflow.com/questions/14255533/pretty-ticks-for-log-normal-scale-using-ggplot2-dynamic-not-manual
</p>


<h3>Value</h3>

<p>A function that can be used as the break argument in calls to
scale_y_continuous() or scale_x_continuous()
</p>

<hr>
<h2 id='lognormal_pred_kernel'>Lognormal predation kernel</h2><span id='topic+lognormal_pred_kernel'></span>

<h3>Description</h3>

<p>This is the most commonly-used predation kernel. The log of the predator/prey
mass ratio is normally distributed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lognormal_pred_kernel(ppmr, beta, sigma)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lognormal_pred_kernel_+3A_ppmr">ppmr</code></td>
<td>
<p>A vector of predator/prey size ratios</p>
</td></tr>
<tr><td><code id="lognormal_pred_kernel_+3A_beta">beta</code></td>
<td>
<p>The preferred predator/prey size ratio</p>
</td></tr>
<tr><td><code id="lognormal_pred_kernel_+3A_sigma">sigma</code></td>
<td>
<p>The width parameter of the log-normal kernel</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Writing the predator mass as <code class="reqn">w</code> and the prey mass as <code class="reqn">w_p</code>,
the feeding kernel is given as
</p>
<p style="text-align: center;"><code class="reqn">\phi_i(w, w_p) = 
\exp \left[ \frac{-(\ln(w / w_p / \beta_i))^2}{2\sigma_i^2} \right]
</code>
</p>

<p>if <code class="reqn">w/w_p</code> is larger than 1 and zero otherwise. Here <code class="reqn">\beta_i</code> is the
preferred predator-prey mass ratio and <code class="reqn">\sigma_i</code> determines the width of
the kernel. These two parameters need to be given in the species parameter
dataframe in the columns <code>beta</code> and <code>sigma</code>.
</p>
<p>This function is called from <code><a href="#topic+setPredKernel">setPredKernel()</a></code> to set up the
predation kernel slots in a MizerParams object.
</p>


<h3>Value</h3>

<p>A vector giving the value of the predation kernel at each of the
predator/prey mass ratios in the <code>ppmr</code> argument.
</p>


<h3>See Also</h3>

<p>Other predation kernel: 
<code><a href="#topic+box_pred_kernel">box_pred_kernel</a>()</code>,
<code><a href="#topic+power_law_pred_kernel">power_law_pred_kernel</a>()</code>,
<code><a href="#topic+truncated_lognormal_pred_kernel">truncated_lognormal_pred_kernel</a>()</code>
</p>

<hr>
<h2 id='matchBiomasses'>Match biomasses to observations</h2><span id='topic+matchBiomasses'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
The function adjusts the abundances of the species in the model so that their
biomasses match with observations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>matchBiomasses(params, species = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="matchBiomasses_+3A_params">params</code></td>
<td>
<p>A MizerParams object</p>
</td></tr>
<tr><td><code id="matchBiomasses_+3A_species">species</code></td>
<td>
<p>The species to be affected. Optional. By default all observed
biomasses will be matched. A vector of species names, or a numeric vector
with the species indices, or a logical vector indicating for each species
whether it is to be affected (TRUE) or not.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function works by multiplying for each species the abundance density
at all sizes by the same factor. This will of course not give a steady
state solution, even if the initial abundance densities were at steady state.
So after using this function you may want to use <code>steady()</code> to run the model
to steady state, after which of course the biomasses will no longer match
exactly. You could then iterate this process. This is described in the
blog post at https://bit.ly/2YqXESV.
</p>
<p>Before you can use this function you will need to have added a
<code>biomass_observed</code> column to your model which gives the observed biomass in
grams.  For species for which you have no observed biomass, you should set
the value in the <code>biomass_observed</code> column to 0 or NA.
</p>
<p>Biomass observations usually only include individuals above a certain size.
This size should be specified in a <code>biomass_cutoff</code> column of the species
parameter data frame. If this is missing, it is assumed that all sizes are
included in the observed biomass, i.e., it includes larval biomass.
</p>


<h3>Value</h3>

<p>A MizerParams object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>params &lt;- NS_params
species_params(params)$biomass_observed &lt;- 
    c(0.8, 61, 12, 35, 1.6, 20, 10, 7.6, 135, 60, 30, 78)
species_params(params)$biomass_cutoff &lt;- 10
params &lt;- calibrateBiomass(params)
params &lt;- matchBiomasses(params)
plotBiomassObservedVsModel(params)
</code></pre>

<hr>
<h2 id='matchGrowth'>Adjust model to produce observed growth</h2><span id='topic+matchGrowth'></span>

<h3>Description</h3>

<p>Scales the search volume, the maximum consumption rate and the metabolic rate
all by the same factor in order to achieve a growth rate that allows
individuals to reach their maturity size by their maturity age while keeping
the feeding level and the critical feeding level unchanged. Then recalculates
the size spectra using <code><a href="#topic+steadySingleSpecies">steadySingleSpecies()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>matchGrowth(params, species = NULL, keep = c("egg", "biomass", "number"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="matchGrowth_+3A_params">params</code></td>
<td>
<p>A MizerParams object</p>
</td></tr>
<tr><td><code id="matchGrowth_+3A_species">species</code></td>
<td>
<p>The species to be affected. Optional. By default all species
for which growth information is available will be affected. A vector of
species names, or a numeric vector with the species indices, or a logical
vector indicating for each species whether it is to be affected (TRUE) or
not.</p>
</td></tr>
<tr><td><code id="matchGrowth_+3A_keep">keep</code></td>
<td>
<p>A string determining which quantity is to be kept constant. The
choices are &quot;egg&quot; which keeps the egg density constant, &quot;biomass&quot; which
keeps the total biomass of the species constant and &quot;number&quot; which keeps
the total number of individuals constant.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Maturity size and age are taken from the <code>w_mat</code> and <code>age_mat</code> columns in the
species_params data frame. If <code>age_mat</code> is missing, mizer calculates it from
the von Bertalanffy growth curve parameters using <code>age_mat_vB()</code>. If those
are not available either for a species, the growth rate for that species will
not be changed.
</p>


<h3>Value</h3>

<p>A modified MizerParams object with rescaled search volume, maximum
consumption rate and metabolic rate and rescaled species parameters
<code>gamma</code>,<code>h</code>, <code>ks</code> and <code>k</code>.
</p>

<hr>
<h2 id='matchNumbers'>Match numbers to observations</h2><span id='topic+matchNumbers'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
The function adjusts the numbers of the species in the model so that their
numbers match with observations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>matchNumbers(params, species = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="matchNumbers_+3A_params">params</code></td>
<td>
<p>A MizerParams object</p>
</td></tr>
<tr><td><code id="matchNumbers_+3A_species">species</code></td>
<td>
<p>The species to be affected. Optional. By default all observed
numbers will be matched. A vector of species names, or a numeric vector
with the species indices, or a logical vector indicating for each species
whether it is to be affected (TRUE) or not.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function works by multiplying for each species the number density
at all sizes by the same factor. This will of course not give a steady
state solution, even if the initial number densities were at steady state.
So after using this function you may want to use <code>steady()</code> to run the model
to steady state, after which of course the numbers will no longer match
exactly. You could then iterate this process. This is described in the
blog post at https://bit.ly/2YqXESV.
</p>
<p>Before you can use this function you will need to have added a
<code>number_observed</code> column to your model which gives the observed number in
grams.  For species for which you have no observed number, you should set
the value in the <code>number_observed</code> column to 0 or NA.
</p>
<p>Number observations usually only include individuals above a certain size.
This size should be specified in a <code>number_cutoff</code> column of the species
parameter data frame. If this is missing, it is assumed that all sizes are
included in the observed number, i.e., it includes larval number.
</p>


<h3>Value</h3>

<p>A MizerParams object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>params &lt;- NS_params
species_params(params)$number_observed &lt;-
    c(0.8, 61, 12, 35, 1.6, 20, 10, 7.6, 135, 60, 30, 78)
species_params(params)$number_cutoff &lt;- 10
params &lt;- calibrateNumber(params)
params &lt;- matchNumbers(params)
</code></pre>

<hr>
<h2 id='matchYields'>Match yields to observations</h2><span id='topic+matchYields'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
The function adjusts the abundances of the species in the model so that their
yearly yields under the given fishing mortalities match with observations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>matchYields(params, species = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="matchYields_+3A_params">params</code></td>
<td>
<p>A MizerParams object</p>
</td></tr>
<tr><td><code id="matchYields_+3A_species">species</code></td>
<td>
<p>The species to be affected. Optional. By default all observed
yields will be matched. A vector of species names, or a numeric vector
with the species indices, or a logical vector indicating for each species
whether it is to be affected (TRUE) or not.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function works by multiplying for each species the abundance density
at all sizes by the same factor. This will of course not give a steady
state solution, even if the initial abundance densities were at steady state.
So after using this function you may want to use <code>steady()</code> to run the model
to steady state, after which of course the yields will no longer match
exactly. You could then iterate this process. This is described in the
blog post at https://bit.ly/2YqXESV.
</p>
<p>Before you can use this function you will need to have added a
<code>yield_observed</code> column to your model which gives the observed yields in
grams per year.  For species for which you have no observed biomass, you
should set the value in the <code>yield_observed</code> column to 0 or NA.
</p>


<h3>Value</h3>

<p>A MizerParams object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>params &lt;- NS_params
species_params(params)$yield_observed &lt;- 
    c(0.8, 61, 12, 35, 1.6, 20, 10, 7.6, 135, 60, 30, 78)
gear_params(params)$catchability &lt;-
    c(1.3, 0.065, 0.31, 0.18, 0.98, 0.24, 0.37, 0.46, 0.18, 0.30, 0.27, 0.39)
params &lt;- calibrateYield(params)
params &lt;- matchYields(params)
plotYieldObservedVsModel(params)
</code></pre>

<hr>
<h2 id='mizerEGrowth'>Get energy rate available for growth needed to project standard mizer model</h2><span id='topic+mizerEGrowth'></span>

<h3>Description</h3>

<p>Calculates the energy rate <code class="reqn">g_i(w)</code> (grams/year) available by species and
size for growth after metabolism, movement and reproduction have been
accounted for. Used by <code><a href="#topic+project">project()</a></code> for performing simulations.
You would not usually call this
function directly but instead use <code><a href="#topic+getEGrowth">getEGrowth()</a></code>, which then calls this
function unless an alternative function has been registered, see below.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mizerEGrowth(params, n, n_pp, n_other, t, e_repro, e, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mizerEGrowth_+3A_params">params</code></td>
<td>
<p>A <a href="#topic+MizerParams-class">MizerParams</a> object</p>
</td></tr>
<tr><td><code id="mizerEGrowth_+3A_n">n</code></td>
<td>
<p>A matrix of species abundances (species x size).</p>
</td></tr>
<tr><td><code id="mizerEGrowth_+3A_n_pp">n_pp</code></td>
<td>
<p>A vector of the resource abundance by size</p>
</td></tr>
<tr><td><code id="mizerEGrowth_+3A_n_other">n_other</code></td>
<td>
<p>A list of abundances for other dynamical components of the
ecosystem</p>
</td></tr>
<tr><td><code id="mizerEGrowth_+3A_t">t</code></td>
<td>
<p>The time for which to do the calculation (Not used by standard
mizer rate functions but useful for extensions with time-dependent
parameters.)</p>
</td></tr>
<tr><td><code id="mizerEGrowth_+3A_e_repro">e_repro</code></td>
<td>
<p>The energy available for reproduction as calculated by
<code><a href="#topic+getERepro">getERepro()</a></code>.</p>
</td></tr>
<tr><td><code id="mizerEGrowth_+3A_e">e</code></td>
<td>
<p>The energy available for reproduction and growth as calculated by
<code><a href="#topic+getEReproAndGrowth">getEReproAndGrowth()</a></code>.</p>
</td></tr>
<tr><td><code id="mizerEGrowth_+3A_...">...</code></td>
<td>
<p>Unused</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A two dimensional array (species x size) with the growth rates.
</p>


<h3>Your own growth rate function</h3>

<p>By default <code><a href="#topic+getEGrowth">getEGrowth()</a></code> calls <code><a href="#topic+mizerEGrowth">mizerEGrowth()</a></code>. However you can
replace this with your own alternative growth rate function. If
your function is called <code>"myEGrowth"</code> then you register it in a MizerParams
object <code>params</code> with
</p>
<div class="sourceCode"><pre>params &lt;- setRateFunction(params, "EGrowth", "myEGrowth")
</pre></div>
<p>Your function will then be called instead of <code><a href="#topic+mizerEGrowth">mizerEGrowth()</a></code>, with the
same arguments.
</p>


<h3>See Also</h3>

<p>Other mizer rate functions: 
<code><a href="#topic+mizerERepro">mizerERepro</a>()</code>,
<code><a href="#topic+mizerEReproAndGrowth">mizerEReproAndGrowth</a>()</code>,
<code><a href="#topic+mizerEncounter">mizerEncounter</a>()</code>,
<code><a href="#topic+mizerFMort">mizerFMort</a>()</code>,
<code><a href="#topic+mizerFMortGear">mizerFMortGear</a>()</code>,
<code><a href="#topic+mizerFeedingLevel">mizerFeedingLevel</a>()</code>,
<code><a href="#topic+mizerMort">mizerMort</a>()</code>,
<code><a href="#topic+mizerPredMort">mizerPredMort</a>()</code>,
<code><a href="#topic+mizerPredRate">mizerPredRate</a>()</code>,
<code><a href="#topic+mizerRDI">mizerRDI</a>()</code>,
<code><a href="#topic+mizerRates">mizerRates</a>()</code>,
<code><a href="#topic+mizerResourceMort">mizerResourceMort</a>()</code>
</p>

<hr>
<h2 id='mizerEncounter'>Get encounter rate needed to project standard mizer model</h2><span id='topic+mizerEncounter'></span>

<h3>Description</h3>

<p>Calculates the rate <code class="reqn">E_i(w)</code> at which a predator of species <code class="reqn">i</code> and
weight <code class="reqn">w</code> encounters food (grams/year). You would not usually call this
function directly but instead use <code><a href="#topic+getEncounter">getEncounter()</a></code>, which then calls this
function unless an alternative function has been registered, see below.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mizerEncounter(params, n, n_pp, n_other, t, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mizerEncounter_+3A_params">params</code></td>
<td>
<p>A <a href="#topic+MizerParams-class">MizerParams</a> object</p>
</td></tr>
<tr><td><code id="mizerEncounter_+3A_n">n</code></td>
<td>
<p>A matrix of species abundances (species x size).</p>
</td></tr>
<tr><td><code id="mizerEncounter_+3A_n_pp">n_pp</code></td>
<td>
<p>A vector of the resource abundance by size</p>
</td></tr>
<tr><td><code id="mizerEncounter_+3A_n_other">n_other</code></td>
<td>
<p>A list of abundances for other dynamical components of the
ecosystem</p>
</td></tr>
<tr><td><code id="mizerEncounter_+3A_t">t</code></td>
<td>
<p>The time for which to do the calculation (Not used by standard
mizer rate functions but useful for extensions with time-dependent
parameters.)</p>
</td></tr>
<tr><td><code id="mizerEncounter_+3A_...">...</code></td>
<td>
<p>Unused</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named two dimensional array (predator species x predator size) with
the encounter rates.
</p>


<h3>Predation encounter</h3>

<p>The encounter rate <code class="reqn">E_i(w)</code> at which a predator of species <code class="reqn">i</code>
and weight <code class="reqn">w</code> encounters food has contributions from the encounter of
fish prey and of resource. This is determined by summing over all prey
species and the resource spectrum and then integrating over all prey sizes
<code class="reqn">w_p</code>, weighted by predation kernel <code class="reqn">\phi(w,w_p)</code>:
</p>
<p style="text-align: center;"><code class="reqn">
E_i(w) = \gamma_i(w) \int 
\left( \theta_{ip} N_R(w_p) + \sum_{j} \theta_{ij} N_j(w_p) \right) 
\phi_i(w,w_p) w_p \, dw_p.
</code>
</p>

<p>Here <code class="reqn">N_j(w)</code> is the abundance density of species <code class="reqn">j</code> and
<code class="reqn">N_R(w)</code> is the abundance density of resource.
The overall prefactor <code class="reqn">\gamma_i(w)</code> determines the predation power of the
predator. It could be interpreted as a search volume and is set with the
<code><a href="#topic+setSearchVolume">setSearchVolume()</a></code> function. The predation kernel
<code class="reqn">\phi(w,w_p)</code> is set with the <code><a href="#topic+setPredKernel">setPredKernel()</a></code> function. The
species interaction matrix <code class="reqn">\theta_{ij}</code> is set with <code><a href="#topic+setInteraction">setInteraction()</a></code>
and the resource interaction vector <code class="reqn">\theta_{ip}</code> is taken from the
<code>interaction_resource</code> column in <code>params@species_params</code>.
</p>


<h3>Details</h3>

<p>The encounter rate is multiplied by <code class="reqn">1-f_0</code> to obtain the consumption
rate, where <code class="reqn">f_0</code> is the feeding level calculated with
<code><a href="#topic+getFeedingLevel">getFeedingLevel()</a></code>. This is used by the <code><a href="#topic+project">project()</a></code> function for performing
simulations.
</p>
<p>The function returns values also for sizes outside the size-range of the
species. These values should not be used, as they are meaningless.
</p>
<p>If your model contains additional components that you added with
<code><a href="#topic+setComponent">setComponent()</a></code> and for which you specified an <code>encounter_fun</code> function then
the encounters of these components will be included in the returned value.
</p>


<h3>Your own encounter function</h3>

<p>By default <code><a href="#topic+getEncounter">getEncounter()</a></code> calls <code><a href="#topic+mizerEncounter">mizerEncounter()</a></code>. However you can
replace this with your own alternative encounter function. If
your function is called <code>"myEncounter"</code> then you register it in a MizerParams
object <code>params</code> with
</p>
<div class="sourceCode"><pre>params &lt;- setRateFunction(params, "Encounter", "myEncounter")
</pre></div>
<p>Your function will then be called instead of <code><a href="#topic+mizerEncounter">mizerEncounter()</a></code>, with the
same arguments.
</p>


<h3>See Also</h3>

<p>Other mizer rate functions: 
<code><a href="#topic+mizerEGrowth">mizerEGrowth</a>()</code>,
<code><a href="#topic+mizerERepro">mizerERepro</a>()</code>,
<code><a href="#topic+mizerEReproAndGrowth">mizerEReproAndGrowth</a>()</code>,
<code><a href="#topic+mizerFMort">mizerFMort</a>()</code>,
<code><a href="#topic+mizerFMortGear">mizerFMortGear</a>()</code>,
<code><a href="#topic+mizerFeedingLevel">mizerFeedingLevel</a>()</code>,
<code><a href="#topic+mizerMort">mizerMort</a>()</code>,
<code><a href="#topic+mizerPredMort">mizerPredMort</a>()</code>,
<code><a href="#topic+mizerPredRate">mizerPredRate</a>()</code>,
<code><a href="#topic+mizerRDI">mizerRDI</a>()</code>,
<code><a href="#topic+mizerRates">mizerRates</a>()</code>,
<code><a href="#topic+mizerResourceMort">mizerResourceMort</a>()</code>
</p>

<hr>
<h2 id='mizerERepro'>Get energy rate available for reproduction needed to project standard mizer
model</h2><span id='topic+mizerERepro'></span>

<h3>Description</h3>

<p>Calculates the energy rate (grams/year) available for reproduction after
growth and metabolism have been accounted for.
You would not usually call this
function directly but instead use <code><a href="#topic+getERepro">getERepro()</a></code>, which then calls this
function unless an alternative function has been registered, see below.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mizerERepro(params, n, n_pp, n_other, t, e, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mizerERepro_+3A_params">params</code></td>
<td>
<p>A <a href="#topic+MizerParams-class">MizerParams</a> object</p>
</td></tr>
<tr><td><code id="mizerERepro_+3A_n">n</code></td>
<td>
<p>A matrix of species abundances (species x size).</p>
</td></tr>
<tr><td><code id="mizerERepro_+3A_n_pp">n_pp</code></td>
<td>
<p>A vector of the resource abundance by size</p>
</td></tr>
<tr><td><code id="mizerERepro_+3A_n_other">n_other</code></td>
<td>
<p>A list of abundances for other dynamical components of the
ecosystem</p>
</td></tr>
<tr><td><code id="mizerERepro_+3A_t">t</code></td>
<td>
<p>The time for which to do the calculation (Not used by standard
mizer rate functions but useful for extensions with time-dependent
parameters.)</p>
</td></tr>
<tr><td><code id="mizerERepro_+3A_e">e</code></td>
<td>
<p>A two dimensional array (species x size) holding the energy available
for reproduction and growth as calculated by <code><a href="#topic+mizerEReproAndGrowth">mizerEReproAndGrowth()</a></code>.</p>
</td></tr>
<tr><td><code id="mizerERepro_+3A_...">...</code></td>
<td>
<p>Unused</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A two dimensional array (species x size) holding
</p>
<p style="text-align: center;"><code class="reqn">\psi_i(w)E_{r.i}(w)</code>
</p>

<p>where <code class="reqn">E_{r.i}(w)</code> is the rate at which energy becomes available for
growth and reproduction, calculated with <code><a href="#topic+mizerEReproAndGrowth">mizerEReproAndGrowth()</a></code>,
and <code class="reqn">\psi_i(w)</code> is the proportion of this energy that is used for
reproduction. This proportion is taken from the <code>params</code> object and is
set with <code><a href="#topic+setReproduction">setReproduction()</a></code>.
</p>


<h3>Your own reproduction rate function</h3>

<p>By default <code><a href="#topic+getERepro">getERepro()</a></code> calls <code><a href="#topic+mizerERepro">mizerERepro()</a></code>. However you can
replace this with your own alternative reproduction rate function. If
your function is called <code>"myERepro"</code> then you register it in a MizerParams
object <code>params</code> with
</p>
<div class="sourceCode"><pre>params &lt;- setRateFunction(params, "ERepro", "myERepro")
</pre></div>
<p>Your function will then be called instead of <code><a href="#topic+mizerERepro">mizerERepro()</a></code>, with the
same arguments.
</p>


<h3>See Also</h3>

<p>Other mizer rate functions: 
<code><a href="#topic+mizerEGrowth">mizerEGrowth</a>()</code>,
<code><a href="#topic+mizerEReproAndGrowth">mizerEReproAndGrowth</a>()</code>,
<code><a href="#topic+mizerEncounter">mizerEncounter</a>()</code>,
<code><a href="#topic+mizerFMort">mizerFMort</a>()</code>,
<code><a href="#topic+mizerFMortGear">mizerFMortGear</a>()</code>,
<code><a href="#topic+mizerFeedingLevel">mizerFeedingLevel</a>()</code>,
<code><a href="#topic+mizerMort">mizerMort</a>()</code>,
<code><a href="#topic+mizerPredMort">mizerPredMort</a>()</code>,
<code><a href="#topic+mizerPredRate">mizerPredRate</a>()</code>,
<code><a href="#topic+mizerRDI">mizerRDI</a>()</code>,
<code><a href="#topic+mizerRates">mizerRates</a>()</code>,
<code><a href="#topic+mizerResourceMort">mizerResourceMort</a>()</code>
</p>

<hr>
<h2 id='mizerEReproAndGrowth'>Get energy rate available for reproduction and growth  needed to project
standard mizer model</h2><span id='topic+mizerEReproAndGrowth'></span>

<h3>Description</h3>

<p>Calculates the energy rate
<code class="reqn">E_{r.i}(w)</code> (grams/year) available to an
individual of species i and size w for reproduction and growth after
metabolism and movement have been accounted for.
You would not usually call this function directly but instead use
<code><a href="#topic+getEReproAndGrowth">getEReproAndGrowth()</a></code>, which then calls this function unless an alternative
function has been registered, see below.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mizerEReproAndGrowth(
  params,
  n,
  n_pp,
  n_other,
  t,
  encounter,
  feeding_level,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mizerEReproAndGrowth_+3A_params">params</code></td>
<td>
<p>A <a href="#topic+MizerParams-class">MizerParams</a> object</p>
</td></tr>
<tr><td><code id="mizerEReproAndGrowth_+3A_n">n</code></td>
<td>
<p>A matrix of species abundances (species x size).</p>
</td></tr>
<tr><td><code id="mizerEReproAndGrowth_+3A_n_pp">n_pp</code></td>
<td>
<p>A vector of the resource abundance by size</p>
</td></tr>
<tr><td><code id="mizerEReproAndGrowth_+3A_n_other">n_other</code></td>
<td>
<p>A list of abundances for other dynamical components of the
ecosystem</p>
</td></tr>
<tr><td><code id="mizerEReproAndGrowth_+3A_t">t</code></td>
<td>
<p>The time for which to do the calculation (Not used by standard
mizer rate functions but useful for extensions with time-dependent
parameters.)</p>
</td></tr>
<tr><td><code id="mizerEReproAndGrowth_+3A_encounter">encounter</code></td>
<td>
<p>An array (species x size) with the encounter rate as
calculated by <code><a href="#topic+getEncounter">getEncounter()</a></code>.</p>
</td></tr>
<tr><td><code id="mizerEReproAndGrowth_+3A_feeding_level">feeding_level</code></td>
<td>
<p>An array (species x size) with the feeding level as
calculated by <code><a href="#topic+getFeedingLevel">getFeedingLevel()</a></code>.</p>
</td></tr>
<tr><td><code id="mizerEReproAndGrowth_+3A_...">...</code></td>
<td>
<p>Unused</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A two dimensional array (species x size) holding
</p>
<p style="text-align: center;"><code class="reqn">E_{r.i}(w) = \max(0, \alpha_i\, (1 - {\tt feeding\_level}_i(w))\, 
                           {\tt encounter}_i(w) - {\tt metab}_i(w)).</code>
</p>

<p>Due to the form of the feeding level, calculated by
<code><a href="#topic+getFeedingLevel">getFeedingLevel()</a></code>, this can also be expressed as
</p>
<p style="text-align: center;"><code class="reqn">E_{r.i}(w) = \max(0, \alpha_i\, {\tt feeding\_level}_i(w)\, 
                           h_i(w) - {\tt metab}_i(w))</code>
</p>

<p>where <code class="reqn">h_i</code> is the maximum intake rate, set with
<code><a href="#topic+setMaxIntakeRate">setMaxIntakeRate()</a></code>.
The assimilation rate <code class="reqn">\alpha_i</code> is taken from the species parameter
data frame in <code>params</code>. The metabolic rate <code>metab</code> is taken from
<code>params</code> and set with <code><a href="#topic+setMetabolicRate">setMetabolicRate()</a></code>.
</p>
<p>The return value can be negative, which means that the energy intake does not
cover the cost of metabolism and movement.
</p>


<h3>Your own energy rate function</h3>

<p>By default <code><a href="#topic+getEReproAndGrowth">getEReproAndGrowth()</a></code> calls <code><a href="#topic+mizerEReproAndGrowth">mizerEReproAndGrowth()</a></code>. However you
can replace this with your own alternative energy rate function. If
your function is called <code>"myEReproAndGrowth"</code> then you register it in a
MizerParams object <code>params</code> with
</p>
<div class="sourceCode"><pre>params &lt;- setRateFunction(params, "EReproAndGrowth", "myEReproAndGrowth")
</pre></div>
<p>Your function will then be called instead of <code><a href="#topic+mizerEReproAndGrowth">mizerEReproAndGrowth()</a></code>, with
the same arguments.
</p>


<h3>See Also</h3>

<p>Other mizer rate functions: 
<code><a href="#topic+mizerEGrowth">mizerEGrowth</a>()</code>,
<code><a href="#topic+mizerERepro">mizerERepro</a>()</code>,
<code><a href="#topic+mizerEncounter">mizerEncounter</a>()</code>,
<code><a href="#topic+mizerFMort">mizerFMort</a>()</code>,
<code><a href="#topic+mizerFMortGear">mizerFMortGear</a>()</code>,
<code><a href="#topic+mizerFeedingLevel">mizerFeedingLevel</a>()</code>,
<code><a href="#topic+mizerMort">mizerMort</a>()</code>,
<code><a href="#topic+mizerPredMort">mizerPredMort</a>()</code>,
<code><a href="#topic+mizerPredRate">mizerPredRate</a>()</code>,
<code><a href="#topic+mizerRDI">mizerRDI</a>()</code>,
<code><a href="#topic+mizerRates">mizerRates</a>()</code>,
<code><a href="#topic+mizerResourceMort">mizerResourceMort</a>()</code>
</p>

<hr>
<h2 id='mizerFeedingLevel'>Get feeding level needed to project standard mizer model</h2><span id='topic+mizerFeedingLevel'></span>

<h3>Description</h3>

<p>You would not usually call this function directly but instead use
<code><a href="#topic+getFeedingLevel">getFeedingLevel()</a></code>, which then calls this function unless an alternative
function has been registered, see below.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mizerFeedingLevel(params, n, n_pp, n_other, t, encounter, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mizerFeedingLevel_+3A_params">params</code></td>
<td>
<p>A <a href="#topic+MizerParams-class">MizerParams</a> object</p>
</td></tr>
<tr><td><code id="mizerFeedingLevel_+3A_n">n</code></td>
<td>
<p>A matrix of species abundances (species x size).</p>
</td></tr>
<tr><td><code id="mizerFeedingLevel_+3A_n_pp">n_pp</code></td>
<td>
<p>A vector of the resource abundance by size</p>
</td></tr>
<tr><td><code id="mizerFeedingLevel_+3A_n_other">n_other</code></td>
<td>
<p>A list of abundances for other dynamical components of the
ecosystem</p>
</td></tr>
<tr><td><code id="mizerFeedingLevel_+3A_t">t</code></td>
<td>
<p>The time for which to do the calculation (Not used by standard
mizer rate functions but useful for extensions with time-dependent
parameters.)</p>
</td></tr>
<tr><td><code id="mizerFeedingLevel_+3A_encounter">encounter</code></td>
<td>
<p>A two dimensional array (predator species x predator size)
with the encounter rate.</p>
</td></tr>
<tr><td><code id="mizerFeedingLevel_+3A_...">...</code></td>
<td>
<p>Unused</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A two dimensional array (predator species x predator size) with the
feeding level.
</p>


<h3>Feeding level</h3>

<p>The feeding level <code class="reqn">f_i(w)</code> is the
proportion of its maximum intake rate at which the predator is actually
taking in fish. It is calculated from the encounter rate <code class="reqn">E_i</code> and the
maximum intake rate <code class="reqn">h_i(w)</code> as
</p>
<p style="text-align: center;"><code class="reqn">f_i(w) = \frac{E_i(w)}{E_i(w)+h_i(w)}.</code>
</p>

<p>The encounter rate <code class="reqn">E_i</code> is passed as an argument or calculated with
<code><a href="#topic+getEncounter">getEncounter()</a></code>. The maximum intake rate <code class="reqn">h_i(w)</code> is
taken from the <code>params</code> object, and is set with
<code><a href="#topic+setMaxIntakeRate">setMaxIntakeRate()</a></code>.
As a consequence of the above expression for the feeding level,
<code class="reqn">1-f_i(w)</code> is the proportion of the food available to it that the
predator actually consumes.
</p>


<h3>Your own feeding level function</h3>

<p>By default <code><a href="#topic+getFeedingLevel">getFeedingLevel()</a></code> calls <code><a href="#topic+mizerFeedingLevel">mizerFeedingLevel()</a></code>. However you can
replace this with your own alternative feeding level function. If
your function is called <code>"myFeedingLevel"</code> then you register it in a MizerParams
object <code>params</code> with
</p>
<div class="sourceCode"><pre>params &lt;- setRateFunction(params, "FeedingLevel", "myFeedingLevel")
</pre></div>
<p>Your function will then be called instead of <code><a href="#topic+mizerFeedingLevel">mizerFeedingLevel()</a></code>, with the
same arguments.
</p>


<h3>See Also</h3>

<p>The feeding level is used in <code><a href="#topic+mizerEReproAndGrowth">mizerEReproAndGrowth()</a></code> and in
<code><a href="#topic+mizerPredRate">mizerPredRate()</a></code>.
</p>
<p>Other mizer rate functions: 
<code><a href="#topic+mizerEGrowth">mizerEGrowth</a>()</code>,
<code><a href="#topic+mizerERepro">mizerERepro</a>()</code>,
<code><a href="#topic+mizerEReproAndGrowth">mizerEReproAndGrowth</a>()</code>,
<code><a href="#topic+mizerEncounter">mizerEncounter</a>()</code>,
<code><a href="#topic+mizerFMort">mizerFMort</a>()</code>,
<code><a href="#topic+mizerFMortGear">mizerFMortGear</a>()</code>,
<code><a href="#topic+mizerMort">mizerMort</a>()</code>,
<code><a href="#topic+mizerPredMort">mizerPredMort</a>()</code>,
<code><a href="#topic+mizerPredRate">mizerPredRate</a>()</code>,
<code><a href="#topic+mizerRDI">mizerRDI</a>()</code>,
<code><a href="#topic+mizerRates">mizerRates</a>()</code>,
<code><a href="#topic+mizerResourceMort">mizerResourceMort</a>()</code>
</p>

<hr>
<h2 id='mizerFMort'>Get the total fishing mortality rate from all fishing gears</h2><span id='topic+mizerFMort'></span>

<h3>Description</h3>

<p>Calculates the total fishing mortality  (in units 1/year) from all gears by
species and size.
The total fishing mortality is just the sum of the fishing mortalities
imposed by each gear, <code class="reqn">\mu_{f.i}(w)=\sum_g F_{g,i,w}</code>.
You would not usually call this
function directly but instead use <code><a href="#topic+getFMort">getFMort()</a></code>, which then calls this
function unless an alternative function has been registered, see below.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mizerFMort(params, n, n_pp, n_other, t, effort, e_growth, pred_mort, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mizerFMort_+3A_params">params</code></td>
<td>
<p>A <a href="#topic+MizerParams-class">MizerParams</a> object</p>
</td></tr>
<tr><td><code id="mizerFMort_+3A_n">n</code></td>
<td>
<p>A matrix of species abundances (species x size).</p>
</td></tr>
<tr><td><code id="mizerFMort_+3A_n_pp">n_pp</code></td>
<td>
<p>A vector of the resource abundance by size</p>
</td></tr>
<tr><td><code id="mizerFMort_+3A_n_other">n_other</code></td>
<td>
<p>A list of abundances for other dynamical components of the
ecosystem</p>
</td></tr>
<tr><td><code id="mizerFMort_+3A_t">t</code></td>
<td>
<p>The time for which to do the calculation (Not used by standard
mizer rate functions but useful for extensions with time-dependent
parameters.)</p>
</td></tr>
<tr><td><code id="mizerFMort_+3A_effort">effort</code></td>
<td>
<p>A vector with the effort for each fishing gear.</p>
</td></tr>
<tr><td><code id="mizerFMort_+3A_e_growth">e_growth</code></td>
<td>
<p>An array (species x size) with the energy available for
growth as calculated by <code><a href="#topic+getEGrowth">getEGrowth()</a></code>. Unused.</p>
</td></tr>
<tr><td><code id="mizerFMort_+3A_pred_mort">pred_mort</code></td>
<td>
<p>A two dimensional array (species x size) with the predation
mortality as calculated by <code><a href="#topic+getPredMort">getPredMort()</a></code>. Unused.</p>
</td></tr>
<tr><td><code id="mizerFMort_+3A_...">...</code></td>
<td>
<p>Unused</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An array (species x size) with the fishing mortality.
</p>


<h3>Your own fishing mortality function</h3>

<p>By default <code><a href="#topic+getFMort">getFMort()</a></code> calls <code><a href="#topic+mizerFMort">mizerFMort()</a></code>. However you can
replace this with your own alternative fishing mortality function. If
your function is called <code>"myFMort"</code> then you register it in a MizerParams
object <code>params</code> with
</p>
<div class="sourceCode"><pre>params &lt;- setRateFunction(params, "FMort", "myFMort")
</pre></div>
<p>Your function will then be called instead of <code><a href="#topic+mizerFMort">mizerFMort()</a></code>, with the
same arguments.
</p>


<h3>Note</h3>

<p>Here: fishing mortality = catchability x selectivity x effort.
</p>


<h3>See Also</h3>

<p>Other mizer rate functions: 
<code><a href="#topic+mizerEGrowth">mizerEGrowth</a>()</code>,
<code><a href="#topic+mizerERepro">mizerERepro</a>()</code>,
<code><a href="#topic+mizerEReproAndGrowth">mizerEReproAndGrowth</a>()</code>,
<code><a href="#topic+mizerEncounter">mizerEncounter</a>()</code>,
<code><a href="#topic+mizerFMortGear">mizerFMortGear</a>()</code>,
<code><a href="#topic+mizerFeedingLevel">mizerFeedingLevel</a>()</code>,
<code><a href="#topic+mizerMort">mizerMort</a>()</code>,
<code><a href="#topic+mizerPredMort">mizerPredMort</a>()</code>,
<code><a href="#topic+mizerPredRate">mizerPredRate</a>()</code>,
<code><a href="#topic+mizerRDI">mizerRDI</a>()</code>,
<code><a href="#topic+mizerRates">mizerRates</a>()</code>,
<code><a href="#topic+mizerResourceMort">mizerResourceMort</a>()</code>
</p>

<hr>
<h2 id='mizerFMortGear'>Get the fishing mortality needed to project
standard mizer model</h2><span id='topic+mizerFMortGear'></span>

<h3>Description</h3>

<p>Calculates the fishing mortality rate <code class="reqn">F_{g,i,w}</code> by gear, species and
size.
This is a helper function for <code><a href="#topic+mizerFMort">mizerFMort()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mizerFMortGear(params, effort)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mizerFMortGear_+3A_params">params</code></td>
<td>
<p>A <a href="#topic+MizerParams-class">MizerParams</a> object</p>
</td></tr>
<tr><td><code id="mizerFMortGear_+3A_effort">effort</code></td>
<td>
<p>A vector with the effort for each fishing gear.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An three dimensional array (gear x species x size) with the
fishing mortality
</p>


<h3>Note</h3>

<p>Here: fishing mortality = catchability x selectivity x effort.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+setFishing">setFishing()</a></code>
</p>
<p>Other mizer rate functions: 
<code><a href="#topic+mizerEGrowth">mizerEGrowth</a>()</code>,
<code><a href="#topic+mizerERepro">mizerERepro</a>()</code>,
<code><a href="#topic+mizerEReproAndGrowth">mizerEReproAndGrowth</a>()</code>,
<code><a href="#topic+mizerEncounter">mizerEncounter</a>()</code>,
<code><a href="#topic+mizerFMort">mizerFMort</a>()</code>,
<code><a href="#topic+mizerFeedingLevel">mizerFeedingLevel</a>()</code>,
<code><a href="#topic+mizerMort">mizerMort</a>()</code>,
<code><a href="#topic+mizerPredMort">mizerPredMort</a>()</code>,
<code><a href="#topic+mizerPredRate">mizerPredRate</a>()</code>,
<code><a href="#topic+mizerRDI">mizerRDI</a>()</code>,
<code><a href="#topic+mizerRates">mizerRates</a>()</code>,
<code><a href="#topic+mizerResourceMort">mizerResourceMort</a>()</code>
</p>

<hr>
<h2 id='mizerMort'>Get total mortality rate needed to project standard mizer model</h2><span id='topic+mizerMort'></span>

<h3>Description</h3>

<p>Calculates the total mortality rate <code class="reqn">\mu_i(w)</code>  (in units 1/year) on each
species by size from predation mortality, background mortality and fishing
mortality.
You would not usually call this
function directly but instead use <code><a href="#topic+getMort">getMort()</a></code>, which then calls this
function unless an alternative function has been registered, see below.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mizerMort(params, n, n_pp, n_other, t, f_mort, pred_mort, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mizerMort_+3A_params">params</code></td>
<td>
<p>A <a href="#topic+MizerParams-class">MizerParams</a> object</p>
</td></tr>
<tr><td><code id="mizerMort_+3A_n">n</code></td>
<td>
<p>A matrix of species abundances (species x size).</p>
</td></tr>
<tr><td><code id="mizerMort_+3A_n_pp">n_pp</code></td>
<td>
<p>A vector of the resource abundance by size</p>
</td></tr>
<tr><td><code id="mizerMort_+3A_n_other">n_other</code></td>
<td>
<p>A list of abundances for other dynamical components of the
ecosystem</p>
</td></tr>
<tr><td><code id="mizerMort_+3A_t">t</code></td>
<td>
<p>The time for which to do the calculation (Not used by standard
mizer rate functions but useful for extensions with time-dependent
parameters.)</p>
</td></tr>
<tr><td><code id="mizerMort_+3A_f_mort">f_mort</code></td>
<td>
<p>A two dimensional array (species x size) with the fishing
mortality</p>
</td></tr>
<tr><td><code id="mizerMort_+3A_pred_mort">pred_mort</code></td>
<td>
<p>A two dimensional array (species x size) with the predation
mortality</p>
</td></tr>
<tr><td><code id="mizerMort_+3A_...">...</code></td>
<td>
<p>Unused</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If your model contains additional components that you added with
<code><a href="#topic+setComponent">setComponent()</a></code> and for which you specified a <code>mort_fun</code> function then
the mortality inflicted by these components will be included in the returned
value.
</p>


<h3>Value</h3>

<p>A named two dimensional array (species x size) with the total
mortality rates.
</p>


<h3>Your own mortality function</h3>

<p>By default <code><a href="#topic+getMort">getMort()</a></code> calls <code><a href="#topic+mizerMort">mizerMort()</a></code>. However you can
replace this with your own alternative mortality function. If
your function is called <code>"myMort"</code> then you register it in a MizerParams
object <code>params</code> with
</p>
<div class="sourceCode"><pre>params &lt;- setRateFunction(params, "Mort", "myMort")
</pre></div>
<p>Your function will then be called instead of <code><a href="#topic+mizerMort">mizerMort()</a></code>, with the
same arguments.
</p>


<h3>See Also</h3>

<p>Other mizer rate functions: 
<code><a href="#topic+mizerEGrowth">mizerEGrowth</a>()</code>,
<code><a href="#topic+mizerERepro">mizerERepro</a>()</code>,
<code><a href="#topic+mizerEReproAndGrowth">mizerEReproAndGrowth</a>()</code>,
<code><a href="#topic+mizerEncounter">mizerEncounter</a>()</code>,
<code><a href="#topic+mizerFMort">mizerFMort</a>()</code>,
<code><a href="#topic+mizerFMortGear">mizerFMortGear</a>()</code>,
<code><a href="#topic+mizerFeedingLevel">mizerFeedingLevel</a>()</code>,
<code><a href="#topic+mizerPredMort">mizerPredMort</a>()</code>,
<code><a href="#topic+mizerPredRate">mizerPredRate</a>()</code>,
<code><a href="#topic+mizerRDI">mizerRDI</a>()</code>,
<code><a href="#topic+mizerRates">mizerRates</a>()</code>,
<code><a href="#topic+mizerResourceMort">mizerResourceMort</a>()</code>
</p>

<hr>
<h2 id='MizerParams'>Alias for <code>set_multispecies_model()</code></h2><span id='topic+MizerParams'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
An alias provided for backward compatibility with mizer version &lt;= 1.0
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MizerParams(
  species_params,
  interaction = matrix(1, nrow = nrow(species_params), ncol = nrow(species_params)),
  min_w_pp = 1e-10,
  min_w = 0.001,
  max_w = NULL,
  no_w = 100,
  n = 2/3,
  q = 0.8,
  f0 = 0.6,
  kappa = 1e+11,
  lambda = 2 + q - n,
  r_pp = 10,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MizerParams_+3A_species_params">species_params</code></td>
<td>
<p>A data frame of species-specific parameter values.</p>
</td></tr>
<tr><td><code id="MizerParams_+3A_interaction">interaction</code></td>
<td>
<p>Optional interaction matrix of the species (predator
species x prey species). By default all entries are 1. See &quot;Setting
interaction matrix&quot; section below.</p>
</td></tr>
<tr><td><code id="MizerParams_+3A_min_w_pp">min_w_pp</code></td>
<td>
<p>The smallest size of the resource spectrum. By default this
is set to the smallest value at which any of the consumers can feed.</p>
</td></tr>
<tr><td><code id="MizerParams_+3A_min_w">min_w</code></td>
<td>
<p>Sets the size of the eggs of all species for which this is not
given in the <code>w_min</code> column of the <code>species_params</code> dataframe.</p>
</td></tr>
<tr><td><code id="MizerParams_+3A_max_w">max_w</code></td>
<td>
<p>The largest size of the consumer spectrum. By default this is
set to the largest <code>w_max</code> specified in the <code>species_params</code> data
frame.</p>
</td></tr>
<tr><td><code id="MizerParams_+3A_no_w">no_w</code></td>
<td>
<p>The number of size bins in the consumer spectrum.</p>
</td></tr>
<tr><td><code id="MizerParams_+3A_n">n</code></td>
<td>
<p>The allometric growth exponent. This can be overruled for individual
species by including a <code>n</code> column in the <code>species_params</code>.</p>
</td></tr>
<tr><td><code id="MizerParams_+3A_q">q</code></td>
<td>
<p>Allometric exponent of search volume</p>
</td></tr>
<tr><td><code id="MizerParams_+3A_f0">f0</code></td>
<td>
<p>Expected average feeding level. Used to set <code>gamma</code>, the
coefficient in the search rate. Ignored if <code>gamma</code> is given
explicitly.</p>
</td></tr>
<tr><td><code id="MizerParams_+3A_kappa">kappa</code></td>
<td>
<p>The coefficient of the initial resource abundance power-law.</p>
</td></tr>
<tr><td><code id="MizerParams_+3A_lambda">lambda</code></td>
<td>
<p>Used to set power-law exponent for resource capacity if the
<code>resource_capacity</code> argument is given as a single number.</p>
</td></tr>
<tr><td><code id="MizerParams_+3A_r_pp">r_pp</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>. Use <code>resource_rate</code> argument
instead.</p>
</td></tr>
<tr><td><code id="MizerParams_+3A_...">...</code></td>
<td>
<p>Unused</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A MizerParams object
</p>

<hr>
<h2 id='MizerParams-class'>A class to hold the parameters for a size based model.</h2><span id='topic+MizerParams-class'></span>

<h3>Description</h3>

<p>Although it is possible to build a <code>MizerParams</code> object by hand it is
not recommended and several constructors are available. Dynamic simulations
are performed using <code><a href="#topic+project">project()</a></code> function on objects of this class. As a
user you should never need to access the slots inside a <code>MizerParams</code> object
directly.
</p>


<h3>Details</h3>

<p>The <a href="#topic+MizerParams-class">MizerParams</a> class is fairly complex with a large number of
slots, many of which are multidimensional arrays. The dimensions of these
arrays is strictly enforced so that <code>MizerParams</code> objects are consistent
in terms of number of species and number of size classes.
</p>
<p>The <code>MizerParams</code> class does not hold any dynamic information, e.g.
abundances or harvest effort through time. These are held in
<a href="#topic+MizerSim-class">MizerSim</a> objects.
</p>


<h3>Slots</h3>


<dl>
<dt><code>metadata</code></dt><dd><p>A list with metadata information. See <code><a href="#topic+setMetadata">setMetadata()</a></code>.</p>
</dd>
<dt><code>mizer_version</code></dt><dd><p>The package version of mizer (as returned by
<code>packageVersion("mizer")</code>) that created or upgraded the model.</p>
</dd>
<dt><code>extensions</code></dt><dd><p>A named vector of strings where each name is the name of
and extension package needed to run the model and each value is a string
giving the information that the remotes package needs to install the
correct version of the extension package, see https://remotes.r-lib.org/.</p>
</dd>
<dt><code>time_created</code></dt><dd><p>A POSIXct date-time object with the creation time.</p>
</dd>
<dt><code>time_modified</code></dt><dd><p>A POSIXct date-time object with the last modified time.</p>
</dd>
<dt><code>w</code></dt><dd><p>The size grid for the fish part of the spectrum. An increasing
vector of weights (in grams) running from the smallest egg size to the
largest maximum size.</p>
</dd>
<dt><code>dw</code></dt><dd><p>The widths (in grams) of the size bins</p>
</dd>
<dt><code>w_full</code></dt><dd><p>The size grid for the full size range including the resource
spectrum. An increasing vector of weights (in grams) running from the
smallest resource size to the largest maximum size of fish. The
last entries of the vector have to be equal to the content of the w slot.</p>
</dd>
<dt><code>dw_full</code></dt><dd><p>The width of the size bins for the full spectrum. The last
entries have to be equal to the content of the dw slot.</p>
</dd>
<dt><code>w_min_idx</code></dt><dd><p>A vector holding the index of the weight of the egg size
of each species</p>
</dd>
<dt><code>maturity</code></dt><dd><p>An array (species x size) that holds the proportion of
individuals of each species at size that are mature. This enters in the
calculation of the spawning stock biomass with <code><a href="#topic+getSSB">getSSB()</a></code>. Set
with <code><a href="#topic+setReproduction">setReproduction()</a></code>.</p>
</dd>
<dt><code>psi</code></dt><dd><p>An array (species x size) that holds the allocation to reproduction
for each species at size, <code class="reqn">\psi_i(w)</code>. Changed with
<code><a href="#topic+setReproduction">setReproduction()</a></code>.</p>
</dd>
<dt><code>intake_max</code></dt><dd><p>An array (species x size) that holds the maximum intake for
each species at size. Changed with <code><a href="#topic+setMaxIntakeRate">setMaxIntakeRate()</a></code>.</p>
</dd>
<dt><code>search_vol</code></dt><dd><p>An array (species x size) that holds the search volume for
each species at size. Changed with <code><a href="#topic+setSearchVolume">setSearchVolume()</a></code>.</p>
</dd>
<dt><code>metab</code></dt><dd><p>An array (species x size) that holds the metabolism
for each species at size. Changed with <code><a href="#topic+setMetabolicRate">setMetabolicRate()</a></code>.</p>
</dd>
<dt><code>mu_b</code></dt><dd><p>An array (species x size) that holds the external mortality rate
<code class="reqn">\mu_{ext.i}(w)</code>. Changed with <code><a href="#topic+setExtMort">setExtMort()</a></code>.</p>
</dd>
<dt><code>ext_encounter</code></dt><dd><p>An array (species x size) that holds the external encounter rate
<code class="reqn">E_{ext.i}(w)</code>. Changed with <code><a href="#topic+setExtEncounter">setExtEncounter()</a></code>.</p>
</dd>
<dt><code>pred_kernel</code></dt><dd><p>An array (species x predator size x prey size) that holds
the predation coefficient of each predator at size on each prey size. If
this is NA then the following two slots will be used. Changed with
<code><a href="#topic+setPredKernel">setPredKernel()</a></code>.</p>
</dd>
<dt><code>ft_pred_kernel_e</code></dt><dd><p>An array (species x log of predator/prey size ratio)
that holds the Fourier transform of the feeding kernel in a form
appropriate for evaluating the encounter rate integral. If this is NA
then the <code>pred_kernel</code> will be used to calculate the available
energy integral. Changed with <code><a href="#topic+setPredKernel">setPredKernel()</a></code>.</p>
</dd>
<dt><code>ft_pred_kernel_p</code></dt><dd><p>An array (species x log of predator/prey size ratio)
that holds the Fourier transform of the feeding kernel in a form
appropriate for evaluating the predation mortality integral. If this is NA
then the <code>pred_kernel</code> will be used to calculate the integral.
Changed with <code><a href="#topic+setPredKernel">setPredKernel()</a></code>.</p>
</dd>
<dt><code>rr_pp</code></dt><dd><p>A vector the same length as the w_full slot. The size specific
growth rate of the resource spectrum.</p>
</dd>
<dt><code>cc_pp</code></dt><dd><p>A vector the same length as the w_full slot. The size specific
carrying capacity of the resource spectrum.</p>
</dd>
<dt><code>resource_dynamics</code></dt><dd><p>Name of the function for projecting the resource
abundance density by one timestep.</p>
</dd>
<dt><code>other_dynamics</code></dt><dd><p>A named list of functions for projecting the
values of other dynamical components of the ecosystem that may be modelled
by a mizer extensions you have installed. The names of the list entries
are the names of those components.</p>
</dd>
<dt><code>other_encounter</code></dt><dd><p>A named list of functions for calculating the
contribution to the encounter rate from each other dynamical component.</p>
</dd>
<dt><code>other_mort</code></dt><dd><p>A named list of functions for calculating the
contribution to the mortality rate from each other dynamical components.</p>
</dd>
<dt><code>other_params</code></dt><dd><p>A list containing the parameters needed by any mizer
extensions you may have installed to model other dynamical components of
the ecosystem.</p>
</dd>
<dt><code>rates_funcs</code></dt><dd><p>A named list with the names of the functions that should be
used to calculate the rates needed by <code>project()</code>. By default this will be
set to the names of the built-in rate functions.</p>
</dd>
<dt><code>sc</code></dt><dd><p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
The community abundance of the scaling community</p>
</dd>
<dt><code>species_params</code></dt><dd><p>A data.frame to hold the species specific parameters.
See <code><a href="#topic+species_params">species_params()</a></code> for details.</p>
</dd>
<dt><code>given_species_params</code></dt><dd><p>A data.frame to hold the species parameters that
were given explicitly rather than obtained by default calculations.</p>
</dd>
<dt><code>gear_params</code></dt><dd><p>Data frame with parameters for gear selectivity. See
<code><a href="#topic+setFishing">setFishing()</a></code> for details.</p>
</dd>
<dt><code>interaction</code></dt><dd><p>The species specific interaction matrix, <code class="reqn">\theta_{ij}</code>.
Changed with <code><a href="#topic+setInteraction">setInteraction()</a></code>.</p>
</dd>
<dt><code>selectivity</code></dt><dd><p>An array (gear x species x w) that holds the selectivity of
each gear for species and size, <code class="reqn">S_{g,i,w}</code>. Changed with
<code><a href="#topic+setFishing">setFishing()</a></code>.</p>
</dd>
<dt><code>catchability</code></dt><dd><p>An array (gear x species) that holds the catchability of
each species by each gear, <code class="reqn">Q_{g,i}</code>. Changed with
<code><a href="#topic+setFishing">setFishing()</a></code>.</p>
</dd>
<dt><code>initial_effort</code></dt><dd><p>A vector containing the initial fishing effort for each
gear. Changed with <code><a href="#topic+setFishing">setFishing()</a></code>.</p>
</dd>
<dt><code>initial_n</code></dt><dd><p>An array (species x size) that holds the initial abundance of
each species at each weight.</p>
</dd>
<dt><code>initial_n_pp</code></dt><dd><p>A vector the same length as the w_full slot that describes
the initial resource abundance at each weight.</p>
</dd>
<dt><code>initial_n_other</code></dt><dd><p>A list with the initial abundances of all other
ecosystem components. Has length zero if there are no other components.</p>
</dd>
<dt><code>resource_params</code></dt><dd><p>List with parameters for resource.</p>
</dd>
<dt><code>A</code></dt><dd><p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
Abundance multipliers.</p>
</dd>
<dt><code>linecolour</code></dt><dd><p>A named vector of colour values, named by species.
Used to give consistent colours in plots.</p>
</dd>
<dt><code>linetype</code></dt><dd><p>A named vector of linetypes, named by species.
Used to give consistent line types in plots.</p>
</dd>
<dt><code>ft_mask</code></dt><dd><p>An array (species x w_full) with zeros for weights larger than
the maximum weight of each species. Used to efficiently minimize
wrap-around errors in Fourier transform calculations.</p>
</dd>
</dl>


<h3>See Also</h3>

<p><code><a href="#topic+project">project()</a></code> <code><a href="#topic+MizerSim">MizerSim()</a></code>
<code><a href="#topic+emptyParams">emptyParams()</a></code> <code><a href="#topic+newMultispeciesParams">newMultispeciesParams()</a></code>
<code><a href="#topic+newCommunityParams">newCommunityParams()</a></code>
<code><a href="#topic+newTraitParams">newTraitParams()</a></code>
</p>

<hr>
<h2 id='mizerPredMort'>Get total predation mortality rate needed to project standard mizer model</h2><span id='topic+mizerPredMort'></span>

<h3>Description</h3>

<p>Calculates the total predation mortality rate <code class="reqn">\mu_{p,i}(w_p)</code> (in units
of 1/year) on each prey species by prey size:
</p>
<p style="text-align: center;"><code class="reqn">\mu_{p.i}(w_p) = \sum_j {\tt pred\_rate}_j(w_p)\, \theta_{ji}.</code>
</p>

<p>You would not usually call this
function directly but instead use <code><a href="#topic+getPredMort">getPredMort()</a></code>, which then calls this
function unless an alternative function has been registered, see below.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mizerPredMort(params, n, n_pp, n_other, t, pred_rate, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mizerPredMort_+3A_params">params</code></td>
<td>
<p>A <a href="#topic+MizerParams-class">MizerParams</a> object</p>
</td></tr>
<tr><td><code id="mizerPredMort_+3A_n">n</code></td>
<td>
<p>A matrix of species abundances (species x size).</p>
</td></tr>
<tr><td><code id="mizerPredMort_+3A_n_pp">n_pp</code></td>
<td>
<p>A vector of the resource abundance by size</p>
</td></tr>
<tr><td><code id="mizerPredMort_+3A_n_other">n_other</code></td>
<td>
<p>A list of abundances for other dynamical components of the
ecosystem</p>
</td></tr>
<tr><td><code id="mizerPredMort_+3A_t">t</code></td>
<td>
<p>The time for which to do the calculation (Not used by standard
mizer rate functions but useful for extensions with time-dependent
parameters.)</p>
</td></tr>
<tr><td><code id="mizerPredMort_+3A_pred_rate">pred_rate</code></td>
<td>
<p>A two dimensional array (predator species x predator size)
with the feeding level.</p>
</td></tr>
<tr><td><code id="mizerPredMort_+3A_...">...</code></td>
<td>
<p>Unused</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A two dimensional array (prey species x prey size) with the predation
mortality
</p>


<h3>Your own predation mortality function</h3>

<p>By default <code><a href="#topic+getPredMort">getPredMort()</a></code> calls <code><a href="#topic+mizerPredMort">mizerPredMort()</a></code>. However you can
replace this with your own alternative predation mortality function. If
your function is called <code>"myPredMort"</code> then you register it in a MizerParams
object <code>params</code> with
</p>
<div class="sourceCode"><pre>params &lt;- setRateFunction(params, "PredMort", "myPredMort")
</pre></div>
<p>Your function will then be called instead of <code><a href="#topic+mizerPredMort">mizerPredMort()</a></code>, with the
same arguments.
</p>


<h3>See Also</h3>

<p>Other mizer rate functions: 
<code><a href="#topic+mizerEGrowth">mizerEGrowth</a>()</code>,
<code><a href="#topic+mizerERepro">mizerERepro</a>()</code>,
<code><a href="#topic+mizerEReproAndGrowth">mizerEReproAndGrowth</a>()</code>,
<code><a href="#topic+mizerEncounter">mizerEncounter</a>()</code>,
<code><a href="#topic+mizerFMort">mizerFMort</a>()</code>,
<code><a href="#topic+mizerFMortGear">mizerFMortGear</a>()</code>,
<code><a href="#topic+mizerFeedingLevel">mizerFeedingLevel</a>()</code>,
<code><a href="#topic+mizerMort">mizerMort</a>()</code>,
<code><a href="#topic+mizerPredRate">mizerPredRate</a>()</code>,
<code><a href="#topic+mizerRDI">mizerRDI</a>()</code>,
<code><a href="#topic+mizerRates">mizerRates</a>()</code>,
<code><a href="#topic+mizerResourceMort">mizerResourceMort</a>()</code>
</p>

<hr>
<h2 id='mizerPredRate'>Get predation rate needed to project standard mizer model</h2><span id='topic+mizerPredRate'></span>

<h3>Description</h3>

<p>Calculates the potential rate (in units 1/year) at which a prey individual of
a given size <code class="reqn">w</code> is killed by predators from species <code class="reqn">j</code>. In formulas
</p>
<p style="text-align: center;"><code class="reqn">{\tt pred\_rate}_j(w_p) = \int \phi_j(w,w_p) (1-f_j(w)) 
  \gamma_j(w) N_j(w) \, dw.</code>
</p>

<p>This potential rate is used in the function <code><a href="#topic+mizerPredMort">mizerPredMort()</a></code> to
calculate the realised predation mortality rate on the prey individual.
You would not usually call this
function directly but instead use <code><a href="#topic+getPredRate">getPredRate()</a></code>, which then calls this
function unless an alternative function has been registered, see below.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mizerPredRate(params, n, n_pp, n_other, t, feeding_level, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mizerPredRate_+3A_params">params</code></td>
<td>
<p>A <a href="#topic+MizerParams-class">MizerParams</a> object</p>
</td></tr>
<tr><td><code id="mizerPredRate_+3A_n">n</code></td>
<td>
<p>A matrix of species abundances (species x size).</p>
</td></tr>
<tr><td><code id="mizerPredRate_+3A_n_pp">n_pp</code></td>
<td>
<p>A vector of the resource abundance by size</p>
</td></tr>
<tr><td><code id="mizerPredRate_+3A_n_other">n_other</code></td>
<td>
<p>A list of abundances for other dynamical components of the
ecosystem</p>
</td></tr>
<tr><td><code id="mizerPredRate_+3A_t">t</code></td>
<td>
<p>The time for which to do the calculation (Not used by standard
mizer rate functions but useful for extensions with time-dependent
parameters.)</p>
</td></tr>
<tr><td><code id="mizerPredRate_+3A_feeding_level">feeding_level</code></td>
<td>
<p>An array (species x size) with the feeding level as
calculated by <code><a href="#topic+getFeedingLevel">getFeedingLevel()</a></code>.</p>
</td></tr>
<tr><td><code id="mizerPredRate_+3A_...">...</code></td>
<td>
<p>Unused</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named two dimensional array (predator species x prey size) with the
predation rate, where the prey size runs over fish community plus resource
spectrum.
</p>


<h3>Your own predation rate function</h3>

<p>By default <code><a href="#topic+getPredRate">getPredRate()</a></code> calls <code><a href="#topic+mizerPredRate">mizerPredRate()</a></code>. However you can
replace this with your own alternative predation rate function. If
your function is called <code>"myPredRate"</code> then you register it in a MizerParams
object <code>params</code> with
</p>
<div class="sourceCode"><pre>params &lt;- setRateFunction(params, "PredRate", "myPredRate")
</pre></div>
<p>Your function will then be called instead of <code><a href="#topic+mizerPredRate">mizerPredRate()</a></code>, with
the same arguments.
</p>


<h3>See Also</h3>

<p>Other mizer rate functions: 
<code><a href="#topic+mizerEGrowth">mizerEGrowth</a>()</code>,
<code><a href="#topic+mizerERepro">mizerERepro</a>()</code>,
<code><a href="#topic+mizerEReproAndGrowth">mizerEReproAndGrowth</a>()</code>,
<code><a href="#topic+mizerEncounter">mizerEncounter</a>()</code>,
<code><a href="#topic+mizerFMort">mizerFMort</a>()</code>,
<code><a href="#topic+mizerFMortGear">mizerFMortGear</a>()</code>,
<code><a href="#topic+mizerFeedingLevel">mizerFeedingLevel</a>()</code>,
<code><a href="#topic+mizerMort">mizerMort</a>()</code>,
<code><a href="#topic+mizerPredMort">mizerPredMort</a>()</code>,
<code><a href="#topic+mizerRDI">mizerRDI</a>()</code>,
<code><a href="#topic+mizerRates">mizerRates</a>()</code>,
<code><a href="#topic+mizerResourceMort">mizerResourceMort</a>()</code>
</p>

<hr>
<h2 id='mizerRates'>Get all rates needed to project standard mizer model</h2><span id='topic+mizerRates'></span>

<h3>Description</h3>

<p>Calls other rate functions in sequence and collects the results in a list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mizerRates(params, n, n_pp, n_other, t = 0, effort, rates_fns, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mizerRates_+3A_params">params</code></td>
<td>
<p>A <a href="#topic+MizerParams-class">MizerParams</a> object</p>
</td></tr>
<tr><td><code id="mizerRates_+3A_n">n</code></td>
<td>
<p>A matrix of species abundances (species x size).</p>
</td></tr>
<tr><td><code id="mizerRates_+3A_n_pp">n_pp</code></td>
<td>
<p>A vector of the resource abundance by size</p>
</td></tr>
<tr><td><code id="mizerRates_+3A_n_other">n_other</code></td>
<td>
<p>A list of abundances for other dynamical components of the
ecosystem</p>
</td></tr>
<tr><td><code id="mizerRates_+3A_t">t</code></td>
<td>
<p>The time for which to do the calculation (Not used by standard
mizer rate functions but useful for extensions with time-dependent
parameters.)</p>
</td></tr>
<tr><td><code id="mizerRates_+3A_effort">effort</code></td>
<td>
<p>The effort for each fishing gear</p>
</td></tr>
<tr><td><code id="mizerRates_+3A_rates_fns">rates_fns</code></td>
<td>
<p>Named list of the functions to call to calculate the rates.
Note that this list holds the functions themselves, not their names.</p>
</td></tr>
<tr><td><code id="mizerRates_+3A_...">...</code></td>
<td>
<p>Unused</p>
</td></tr>
</table>


<h3>Details</h3>

<p>By default this function returns a list with the following components:
</p>

<ul>
<li><p> encounter from <code><a href="#topic+mizerEncounter">mizerEncounter()</a></code>
</p>
</li>
<li><p> feeding_level from <code><a href="#topic+mizerFeedingLevel">mizerFeedingLevel()</a></code>
</p>
</li>
<li><p> e from <code><a href="#topic+mizerEReproAndGrowth">mizerEReproAndGrowth()</a></code>
</p>
</li>
<li><p> e_repro from <code><a href="#topic+mizerERepro">mizerERepro()</a></code>
</p>
</li>
<li><p> e_growth from <code><a href="#topic+mizerEGrowth">mizerEGrowth()</a></code>
</p>
</li>
<li><p> pred_rate from <code><a href="#topic+mizerPredRate">mizerPredRate()</a></code>
</p>
</li>
<li><p> pred_mort from <code><a href="#topic+mizerPredMort">mizerPredMort()</a></code>
</p>
</li>
<li><p> f_mort from <code><a href="#topic+mizerFMort">mizerFMort()</a></code>
</p>
</li>
<li><p> mort from <code><a href="#topic+mizerMort">mizerMort()</a></code>
</p>
</li>
<li><p> rdi from <code><a href="#topic+mizerRDI">mizerRDI()</a></code>
</p>
</li>
<li><p> rdd from <code><a href="#topic+BevertonHoltRDD">BevertonHoltRDD()</a></code>
</p>
</li>
<li><p> resource_mort from <code><a href="#topic+mizerResourceMort">mizerResourceMort()</a></code>
</p>
</li></ul>

<p>However you can replace any of these rate functions by your own rate
function if you wish, see <code><a href="#topic+setRateFunction">setRateFunction()</a></code> for details.
</p>


<h3>Value</h3>

<p>List of rates.
</p>


<h3>See Also</h3>

<p>Other mizer rate functions: 
<code><a href="#topic+mizerEGrowth">mizerEGrowth</a>()</code>,
<code><a href="#topic+mizerERepro">mizerERepro</a>()</code>,
<code><a href="#topic+mizerEReproAndGrowth">mizerEReproAndGrowth</a>()</code>,
<code><a href="#topic+mizerEncounter">mizerEncounter</a>()</code>,
<code><a href="#topic+mizerFMort">mizerFMort</a>()</code>,
<code><a href="#topic+mizerFMortGear">mizerFMortGear</a>()</code>,
<code><a href="#topic+mizerFeedingLevel">mizerFeedingLevel</a>()</code>,
<code><a href="#topic+mizerMort">mizerMort</a>()</code>,
<code><a href="#topic+mizerPredMort">mizerPredMort</a>()</code>,
<code><a href="#topic+mizerPredRate">mizerPredRate</a>()</code>,
<code><a href="#topic+mizerRDI">mizerRDI</a>()</code>,
<code><a href="#topic+mizerResourceMort">mizerResourceMort</a>()</code>
</p>

<hr>
<h2 id='mizerRDI'>Get density-independent rate of reproduction needed to project standard
mizer model</h2><span id='topic+mizerRDI'></span>

<h3>Description</h3>

<p>Calculates the density-independent rate of total egg production
<code class="reqn">R_{di}</code> (units 1/year) before density dependence, by species.
You would not usually call this
function directly but instead use <code><a href="#topic+getRDI">getRDI()</a></code>, which then calls this
function unless an alternative function has been registered, see below.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mizerRDI(params, n, n_pp, n_other, t, e_growth, mort, e_repro, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mizerRDI_+3A_params">params</code></td>
<td>
<p>A <a href="#topic+MizerParams-class">MizerParams</a> object</p>
</td></tr>
<tr><td><code id="mizerRDI_+3A_n">n</code></td>
<td>
<p>A matrix of species abundances (species x size).</p>
</td></tr>
<tr><td><code id="mizerRDI_+3A_n_pp">n_pp</code></td>
<td>
<p>A vector of the resource abundance by size</p>
</td></tr>
<tr><td><code id="mizerRDI_+3A_n_other">n_other</code></td>
<td>
<p>A list of abundances for other dynamical components of the
ecosystem</p>
</td></tr>
<tr><td><code id="mizerRDI_+3A_t">t</code></td>
<td>
<p>The time for which to do the calculation (Not used by standard
mizer rate functions but useful for extensions with time-dependent
parameters.)</p>
</td></tr>
<tr><td><code id="mizerRDI_+3A_e_growth">e_growth</code></td>
<td>
<p>An array (species x size) with the energy available for
growth as calculated by <code><a href="#topic+getEGrowth">getEGrowth()</a></code>. Unused.</p>
</td></tr>
<tr><td><code id="mizerRDI_+3A_mort">mort</code></td>
<td>
<p>An array (species x size) with the mortality rate as calculated
by <code><a href="#topic+getMort">getMort()</a></code>. Unused.</p>
</td></tr>
<tr><td><code id="mizerRDI_+3A_e_repro">e_repro</code></td>
<td>
<p>An array (species x size) with the energy available for
reproduction as calculated by <code><a href="#topic+getERepro">getERepro()</a></code>.</p>
</td></tr>
<tr><td><code id="mizerRDI_+3A_...">...</code></td>
<td>
<p>Unused</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This rate is obtained by taking the per capita rate <code class="reqn">E_r(w)\psi(w)</code> at
which energy is invested in reproduction, as calculated by <code><a href="#topic+getERepro">getERepro()</a></code>,
multiplying it by the number of individuals<code class="reqn">N(w)</code> and integrating over
all sizes <code class="reqn">w</code> and then multiplying by the reproductive efficiency
<code class="reqn">\epsilon</code> and dividing by the egg size <code>w_min</code>, and by a factor of two
to account for the two sexes:
</p>
<p style="text-align: center;"><code class="reqn">R_{di} = \frac{\epsilon}{2 w_{min}} \int N(w)  E_r(w) \psi(w) \, dw</code>
</p>

<p>Used by <code><a href="#topic+getRDD">getRDD()</a></code> to calculate the actual, density dependent rate.
See <code><a href="#topic+setReproduction">setReproduction()</a></code> for more details.
</p>


<h3>Value</h3>

<p>A numeric vector with the rate of egg production for each species.
</p>


<h3>Your own reproduction function</h3>

<p>By default <code><a href="#topic+getRDI">getRDI()</a></code> calls <code><a href="#topic+mizerRDI">mizerRDI()</a></code>. However you can
replace this with your own alternative reproduction function. If
your function is called <code>"myRDI"</code> then you register it in a MizerParams
object <code>params</code> with
</p>
<div class="sourceCode"><pre>params &lt;- setRateFunction(params, "RDI", "myRDI")
</pre></div>
<p>Your function will then be called instead of <code><a href="#topic+mizerRDI">mizerRDI()</a></code>, with the
same arguments. For an example of an alternative reproduction function
see <code>constantEggRDI()</code>.
</p>


<h3>See Also</h3>

<p>Other mizer rate functions: 
<code><a href="#topic+mizerEGrowth">mizerEGrowth</a>()</code>,
<code><a href="#topic+mizerERepro">mizerERepro</a>()</code>,
<code><a href="#topic+mizerEReproAndGrowth">mizerEReproAndGrowth</a>()</code>,
<code><a href="#topic+mizerEncounter">mizerEncounter</a>()</code>,
<code><a href="#topic+mizerFMort">mizerFMort</a>()</code>,
<code><a href="#topic+mizerFMortGear">mizerFMortGear</a>()</code>,
<code><a href="#topic+mizerFeedingLevel">mizerFeedingLevel</a>()</code>,
<code><a href="#topic+mizerMort">mizerMort</a>()</code>,
<code><a href="#topic+mizerPredMort">mizerPredMort</a>()</code>,
<code><a href="#topic+mizerPredRate">mizerPredRate</a>()</code>,
<code><a href="#topic+mizerRates">mizerRates</a>()</code>,
<code><a href="#topic+mizerResourceMort">mizerResourceMort</a>()</code>
</p>

<hr>
<h2 id='mizerResourceMort'>Get predation mortality rate for resource needed to project standard mizer
model</h2><span id='topic+mizerResourceMort'></span>

<h3>Description</h3>

<p>Calculates the predation mortality rate <code class="reqn">\mu_p(w)</code> on the resource
spectrum by resource size (in units 1/year).
You would not usually call this
function directly but instead use <code><a href="#topic+getResourceMort">getResourceMort()</a></code>, which then calls this
function unless an alternative function has been registered, see below.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mizerResourceMort(params, n, n_pp, n_other, t, pred_rate, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mizerResourceMort_+3A_params">params</code></td>
<td>
<p>A <a href="#topic+MizerParams-class">MizerParams</a> object</p>
</td></tr>
<tr><td><code id="mizerResourceMort_+3A_n">n</code></td>
<td>
<p>A matrix of species abundances (species x size).</p>
</td></tr>
<tr><td><code id="mizerResourceMort_+3A_n_pp">n_pp</code></td>
<td>
<p>A vector of the resource abundance by size</p>
</td></tr>
<tr><td><code id="mizerResourceMort_+3A_n_other">n_other</code></td>
<td>
<p>A list of abundances for other dynamical components of the
ecosystem</p>
</td></tr>
<tr><td><code id="mizerResourceMort_+3A_t">t</code></td>
<td>
<p>The time for which to do the calculation (Not used by standard
mizer rate functions but useful for extensions with time-dependent
parameters.)</p>
</td></tr>
<tr><td><code id="mizerResourceMort_+3A_pred_rate">pred_rate</code></td>
<td>
<p>A two dimensional array (predator species x prey size) with
the predation rate, where the prey size runs over fish community plus
resource spectrum.</p>
</td></tr>
<tr><td><code id="mizerResourceMort_+3A_...">...</code></td>
<td>
<p>Unused</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of mortality rate by resource size.
</p>


<h3>Your own resource mortality function</h3>

<p>By default <code><a href="#topic+getResourceMort">getResourceMort()</a></code> calls <code><a href="#topic+mizerResourceMort">mizerResourceMort()</a></code>. However you can
replace this with your own alternative resource mortality function. If
your function is called <code>"myResourceMort"</code> then you register it in a MizerParams
object <code>params</code> with
</p>
<div class="sourceCode"><pre>params &lt;- setRateFunction(params, "ResourceMort", "myResourceMort")
</pre></div>
<p>Your function will then be called instead of <code><a href="#topic+mizerResourceMort">mizerResourceMort()</a></code>, with the
same arguments.
</p>


<h3>See Also</h3>

<p>Other mizer rate functions: 
<code><a href="#topic+mizerEGrowth">mizerEGrowth</a>()</code>,
<code><a href="#topic+mizerERepro">mizerERepro</a>()</code>,
<code><a href="#topic+mizerEReproAndGrowth">mizerEReproAndGrowth</a>()</code>,
<code><a href="#topic+mizerEncounter">mizerEncounter</a>()</code>,
<code><a href="#topic+mizerFMort">mizerFMort</a>()</code>,
<code><a href="#topic+mizerFMortGear">mizerFMortGear</a>()</code>,
<code><a href="#topic+mizerFeedingLevel">mizerFeedingLevel</a>()</code>,
<code><a href="#topic+mizerMort">mizerMort</a>()</code>,
<code><a href="#topic+mizerPredMort">mizerPredMort</a>()</code>,
<code><a href="#topic+mizerPredRate">mizerPredRate</a>()</code>,
<code><a href="#topic+mizerRDI">mizerRDI</a>()</code>,
<code><a href="#topic+mizerRates">mizerRates</a>()</code>
</p>

<hr>
<h2 id='MizerSim'>Constructor for the <code>MizerSim</code> class</h2><span id='topic+MizerSim'></span>

<h3>Description</h3>

<p>A constructor for the <code>MizerSim</code> class. This is used by
<code><a href="#topic+project">project()</a></code> to create <code>MizerSim</code> objects of the right
dimensions. It is not necessary for users to use this constructor.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MizerSim(params, t_dimnames = NA, t_max = 100, t_save = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MizerSim_+3A_params">params</code></td>
<td>
<p>a <a href="#topic+MizerParams-class">MizerParams</a> object</p>
</td></tr>
<tr><td><code id="MizerSim_+3A_t_dimnames">t_dimnames</code></td>
<td>
<p>Numeric vector that is used for the time dimensions of the
slots. Default = NA.</p>
</td></tr>
<tr><td><code id="MizerSim_+3A_t_max">t_max</code></td>
<td>
<p>The maximum time step of the simulation. Only used if t_dimnames
= NA. Default value = 100.</p>
</td></tr>
<tr><td><code id="MizerSim_+3A_t_save">t_save</code></td>
<td>
<p>How often should the results of the simulation be stored. Only
used if t_dimnames = NA. Default value = 1.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of type <a href="#topic+MizerSim-class">MizerSim</a>
</p>

<hr>
<h2 id='MizerSim-class'>A class to hold the results of a simulation</h2><span id='topic+MizerSim-class'></span>

<h3>Description</h3>

<p>A class that holds the results of projecting a <a href="#topic+MizerParams-class">MizerParams</a>
object through time using <code><a href="#topic+project">project()</a></code>.
</p>


<h3>Details</h3>

<p>A new <code>MizerSim</code> object can be created with the <code><a href="#topic+MizerSim">MizerSim()</a></code>
constructor, but you will never have to do that because the object is
created automatically by <code><a href="#topic+project">project()</a></code> when needed.
</p>
<p>As a user you should never have to access the slots of a MizerSim object
directly. Instead there are a range of functions to extract the information.
<code><a href="#topic+N">N()</a></code> and <code><a href="#topic+NResource">NResource()</a></code> return arrays with the saved abundances of
the species and the resource population at size respectively. <code><a href="#topic+getEffort">getEffort()</a></code>
returns the fishing effort of each gear through time.
<code><a href="#topic+getTimes">getTimes()</a></code> returns the vector of times at which simulation results
were stored and <code><a href="#topic+idxFinalT">idxFinalT()</a></code> returns the index with which to access
specifically the value at the final time in the arrays returned by the other
functions. <code><a href="#topic+getParams">getParams()</a></code> returns the <code>MizerParams</code> object that was
passed to <code>project()</code>. There are also several
<a href="#topic+summary_functions">summary_functions</a> and <a href="#topic+plotting_functions">plotting_functions</a>
available to explore the contents of a <code>MizerSim</code> object.
</p>
<p>The arrays all have named dimensions. The names of the <code>time</code> dimension
denote the time in years. The names of the <code>w</code> dimension are weights in grams
rounded to three significant figures. The names of the <code>sp</code> dimension are the
same as the species name in the order specified in the species_params data
frame. The names of the <code>gear</code> dimension are the names of the gears, in the
same order as specified when setting up the <code>MizerParams</code> object.
</p>
<p>Extensions of mizer can use the <code>n_other</code> slot to store the abundances of
other ecosystem components and these extensions should provide their own
functions for accessing that information.
</p>
<p>The <code>MizerSim</code> class has changed since previous versions of mizer. To use
a <code>MizerSim</code> object created by a previous version, you need to upgrade it
with <code><a href="#topic+upgradeSim">upgradeSim()</a></code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>params</code></dt><dd><p>An object of type <a href="#topic+MizerParams-class">MizerParams</a>.</p>
</dd>
<dt><code>n</code></dt><dd><p>Three-dimensional array (time x species x size) that stores the
projected community number densities.</p>
</dd>
<dt><code>n_pp</code></dt><dd><p>An array (time x size) that stores the projected resource number
densities.</p>
</dd>
<dt><code>n_other</code></dt><dd><p>A list array (time x component) that stores the projected
values for other ecosystem components.</p>
</dd>
<dt><code>effort</code></dt><dd><p>An array (time x gear) that stores the fishing effort by time
and gear.</p>
</dd>
</dl>

<hr>
<h2 id='N'>Time series of size spectra</h2><span id='topic+N'></span><span id='topic+NResource'></span>

<h3>Description</h3>

<p>Fetch the simulation results for the size spectra over time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>N(sim)

NResource(sim)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="N_+3A_sim">sim</code></td>
<td>
<p>A MizerSim object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For <code>N()</code>: A three-dimensional array (time x species x size) with the
number density of consumers
</p>
<p>For <code>NResource()</code>: An array (time x size) with the number density of resource
</p>


<h3>Examples</h3>

<pre><code class='language-R'>str(N(NS_sim))
str(NResource(NS_sim))
</code></pre>

<hr>
<h2 id='needs_upgrading'>Determine whether a MizerParams or MizerSim object needs to be upgraded</h2><span id='topic+needs_upgrading'></span>

<h3>Description</h3>

<p>Looks at the mizer version that was used to last update the object and
returns TRUE if changes since that version require an upgrade of the object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>needs_upgrading(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="needs_upgrading_+3A_object">object</code></td>
<td>
<p>A MizerParams or MizerSim object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>TRUE or FALSE
</p>

<hr>
<h2 id='newCommunityParams'>Set up parameters for a community-type model</h2><span id='topic+newCommunityParams'></span>

<h3>Description</h3>

<p>This functions creates a <code><a href="#topic+MizerParams-class">MizerParams</a></code> object describing a
community-type model.
The function has many arguments, all of which have default values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>newCommunityParams(
  max_w = 1e+06,
  min_w = 0.001,
  no_w = 100,
  min_w_pp = 1e-10,
  z0 = 0.1,
  alpha = 0.2,
  f0 = 0.7,
  h = 10,
  gamma = NA,
  beta = 100,
  sigma = 2,
  n = 2/3,
  kappa = 1000,
  lambda = 2.05,
  r_pp = 10,
  knife_edge_size = 1000,
  reproduction
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="newCommunityParams_+3A_max_w">max_w</code></td>
<td>
<p>The maximum size of the community. The <code>w_max</code> of the
species used to represent the community is set to this value.</p>
</td></tr>
<tr><td><code id="newCommunityParams_+3A_min_w">min_w</code></td>
<td>
<p>The minimum size of the community.</p>
</td></tr>
<tr><td><code id="newCommunityParams_+3A_no_w">no_w</code></td>
<td>
<p>The number of size bins in the consumer spectrum.</p>
</td></tr>
<tr><td><code id="newCommunityParams_+3A_min_w_pp">min_w_pp</code></td>
<td>
<p>The smallest size of the resource spectrum. By default this
is set to the smallest value at which any of the consumers can feed.</p>
</td></tr>
<tr><td><code id="newCommunityParams_+3A_z0">z0</code></td>
<td>
<p>The background mortality of the community.</p>
</td></tr>
<tr><td><code id="newCommunityParams_+3A_alpha">alpha</code></td>
<td>
<p>The assimilation efficiency of the community.</p>
</td></tr>
<tr><td><code id="newCommunityParams_+3A_f0">f0</code></td>
<td>
<p>The average feeding level of individuals who feed on a power-law
spectrum. This value is used to calculate the search rate parameter
<code>gamma</code>.</p>
</td></tr>
<tr><td><code id="newCommunityParams_+3A_h">h</code></td>
<td>
<p>The coefficient of the maximum food intake rate.</p>
</td></tr>
<tr><td><code id="newCommunityParams_+3A_gamma">gamma</code></td>
<td>
<p>Volumetric search rate. Estimated using <code>h</code>, <code>f0</code> and
<code>kappa</code> if not supplied.</p>
</td></tr>
<tr><td><code id="newCommunityParams_+3A_beta">beta</code></td>
<td>
<p>The preferred predator prey mass ratio.</p>
</td></tr>
<tr><td><code id="newCommunityParams_+3A_sigma">sigma</code></td>
<td>
<p>The width of the prey preference.</p>
</td></tr>
<tr><td><code id="newCommunityParams_+3A_n">n</code></td>
<td>
<p>The allometric growth exponent. Used as allometric exponent for
the maximum intake rate of the community as well as the intrinsic growth
rate of the resource.</p>
</td></tr>
<tr><td><code id="newCommunityParams_+3A_kappa">kappa</code></td>
<td>
<p>The coefficient of the initial resource abundance power-law.</p>
</td></tr>
<tr><td><code id="newCommunityParams_+3A_lambda">lambda</code></td>
<td>
<p>Used to set power-law exponent for resource capacity if the
<code>resource_capacity</code> argument is given as a single number.</p>
</td></tr>
<tr><td><code id="newCommunityParams_+3A_r_pp">r_pp</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>. Use <code>resource_rate</code> argument
instead.</p>
</td></tr>
<tr><td><code id="newCommunityParams_+3A_knife_edge_size">knife_edge_size</code></td>
<td>
<p>The size at the edge of the knife-edge-selectivity
function.</p>
</td></tr>
<tr><td><code id="newCommunityParams_+3A_reproduction">reproduction</code></td>
<td>
<p>The constant reproduction in the smallest size class of
the community spectrum. By default this is set so that the community
spectrum is continuous with the resource spectrum.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A community model has several features that distinguish it from a
multi-species model:
</p>

<ul>
<li><p> Species identities of individuals are ignored. All are aggregated into a
single community.
</p>
</li>
<li><p> The resource spectrum only extends to the start of the community spectrum.
</p>
</li>
<li><p> Reproductive rate is constant, independent of the energy invested in
reproduction, which is set to 0.
</p>
</li>
<li><p> Standard metabolism is turned off (the parameter <code>ks</code> is set to 0).
Consequently, the growth rate is now determined solely by the assimilated
food
</p>
</li></ul>

<p>Fishing selectivity is modelled as a knife-edge function with one parameter,
<code>knife_edge_size</code>, which determines the size at which species are
selected.
</p>
<p>The resulting <code>MizerParams</code> object can be projected forward using
<code>project()</code> like any other <code>MizerParams</code> object. When projecting
the community model it may be necessary to keep a small time step size
<code>dt</code> of around 0.1 to avoid any instabilities with the solver. You can
check for these numerical instabilities by plotting the biomass or abundance
through time after the projection.
</p>


<h3>Value</h3>

<p>An object of type <code><a href="#topic+MizerParams-class">MizerParams</a></code>
</p>


<h3>References</h3>

<p>K. H. Andersen,J. E. Beyer and P. Lundberg, 2009, Trophic and
individual efficiencies of size-structured communities, Proceedings of the
Royal Society, 276, 109-114
</p>


<h3>See Also</h3>

<p>Other functions for setting up models: 
<code><a href="#topic+newMultispeciesParams">newMultispeciesParams</a>()</code>,
<code><a href="#topic+newSingleSpeciesParams">newSingleSpeciesParams</a>()</code>,
<code><a href="#topic+newTraitParams">newTraitParams</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>params &lt;- newCommunityParams()
sim &lt;- project(params, t_max = 10)
plotBiomass(sim)
plotSpectra(sim, power = 2)

# More satiation. More mortality
params &lt;- newCommunityParams(f0 = 0.8, z0 = 0.4)
sim &lt;- project(params, t_max = 10)
plotBiomass(sim)
plotSpectra(sim, power = 2)
</code></pre>

<hr>
<h2 id='newMultispeciesParams'>Set up parameters for a general multispecies model</h2><span id='topic+newMultispeciesParams'></span>

<h3>Description</h3>

<p>Sets up a multi-species size spectrum model by filling all slots in the
<a href="#topic+MizerParams-class">MizerParams</a> object based on user-provided or default
parameters. There is a long list of arguments, but almost
all of them have sensible default values. The only required argument is
the <code>species_params</code> data frame. All arguments are described in more
details in the sections below the list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>newMultispeciesParams(
  species_params,
  interaction = NULL,
  no_w = 100,
  min_w = 0.001,
  max_w = NA,
  min_w_pp = NA,
  pred_kernel = NULL,
  search_vol = NULL,
  intake_max = NULL,
  metab = NULL,
  p = 0.7,
  ext_mort = NULL,
  z0pre = 0.6,
  z0exp = n - 1,
  ext_encounter = NULL,
  maturity = NULL,
  repro_prop = NULL,
  RDD = "BevertonHoltRDD",
  kappa = 1e+11,
  n = 2/3,
  resource_rate = 10,
  resource_capacity = kappa,
  lambda = 2.05,
  w_pp_cutoff = 10,
  resource_dynamics = "resource_semichemostat",
  gear_params = NULL,
  selectivity = NULL,
  catchability = NULL,
  initial_effort = NULL,
  info_level = 3,
  z0 = deprecated(),
  r_pp = deprecated()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="newMultispeciesParams_+3A_species_params">species_params</code></td>
<td>
<p>A data frame of species-specific parameter values.</p>
</td></tr>
<tr><td><code id="newMultispeciesParams_+3A_interaction">interaction</code></td>
<td>
<p>Optional interaction matrix of the species (predator
species x prey species). By default all entries are 1. See &quot;Setting
interaction matrix&quot; section below.</p>
</td></tr>
<tr><td><code id="newMultispeciesParams_+3A_no_w">no_w</code></td>
<td>
<p>The number of size bins in the consumer spectrum.</p>
</td></tr>
<tr><td><code id="newMultispeciesParams_+3A_min_w">min_w</code></td>
<td>
<p>Sets the size of the eggs of all species for which this is not
given in the <code>w_min</code> column of the <code>species_params</code> dataframe.</p>
</td></tr>
<tr><td><code id="newMultispeciesParams_+3A_max_w">max_w</code></td>
<td>
<p>The largest size of the consumer spectrum. By default this is
set to the largest <code>w_max</code> specified in the <code>species_params</code> data
frame.</p>
</td></tr>
<tr><td><code id="newMultispeciesParams_+3A_min_w_pp">min_w_pp</code></td>
<td>
<p>The smallest size of the resource spectrum. By default this
is set to the smallest value at which any of the consumers can feed.</p>
</td></tr>
<tr><td><code id="newMultispeciesParams_+3A_pred_kernel">pred_kernel</code></td>
<td>
<p>Optional. An array (species x predator size x prey size)
that holds the predation coefficient of each predator at size on each prey
size. If not supplied, a default is set as described in section &quot;Setting
predation kernel&quot;.</p>
</td></tr>
<tr><td><code id="newMultispeciesParams_+3A_search_vol">search_vol</code></td>
<td>
<p>Optional. An array (species x size) holding the search volume
for each species at size. If not supplied, a default is set as described in
the section &quot;Setting search volume&quot;.</p>
</td></tr>
<tr><td><code id="newMultispeciesParams_+3A_intake_max">intake_max</code></td>
<td>
<p>Optional. An array (species x size) holding the maximum
intake rate for each species at size. If not supplied, a default is set as
described in the section &quot;Setting maximum intake rate&quot;.</p>
</td></tr>
<tr><td><code id="newMultispeciesParams_+3A_metab">metab</code></td>
<td>
<p>Optional. An array (species x size) holding the metabolic rate
for each species at size. If not supplied, a default is set as described in
the section &quot;Setting metabolic rate&quot;.</p>
</td></tr>
<tr><td><code id="newMultispeciesParams_+3A_p">p</code></td>
<td>
<p>The allometric metabolic exponent. This is only used if <code>metab</code>
is not given explicitly and if the exponent is not specified in a <code>p</code>
column in the <code>species_params</code>.</p>
</td></tr>
<tr><td><code id="newMultispeciesParams_+3A_ext_mort">ext_mort</code></td>
<td>
<p>Optional. An array (species x size) holding the external
mortality rate.  If not supplied, a default is set as described in the
section &quot;Setting external mortality rate&quot;.</p>
</td></tr>
<tr><td><code id="newMultispeciesParams_+3A_z0pre">z0pre</code></td>
<td>
<p>If <code>z0</code>, the mortality from other sources, is not a column
in the species data frame, it is calculated as z0pre * w_max ^ z0exp.
Default value is 0.6.</p>
</td></tr>
<tr><td><code id="newMultispeciesParams_+3A_z0exp">z0exp</code></td>
<td>
<p>If <code>z0</code>, the mortality from other sources, is not a column in
the species data frame, it is calculated as <code>z0pre * w_max ^ z0exp</code>.
Default value is <code>n-1</code>.</p>
</td></tr>
<tr><td><code id="newMultispeciesParams_+3A_ext_encounter">ext_encounter</code></td>
<td>
<p>Optional. An array (species x size) holding the external
encounter rate.  If not supplied, a default of 0 is used.</p>
</td></tr>
<tr><td><code id="newMultispeciesParams_+3A_maturity">maturity</code></td>
<td>
<p>Optional. An array (species x size) that holds the proportion
of individuals of each species at size that are mature. If not supplied, a
default is set as described in the section &quot;Setting reproduction&quot;.</p>
</td></tr>
<tr><td><code id="newMultispeciesParams_+3A_repro_prop">repro_prop</code></td>
<td>
<p>Optional. An array (species x size) that holds the
proportion of consumed energy that a mature individual allocates to
reproduction for each species at size. If not supplied, a default is set as
described in the section &quot;Setting reproduction&quot;.</p>
</td></tr>
<tr><td><code id="newMultispeciesParams_+3A_rdd">RDD</code></td>
<td>
<p>The name of the function calculating the density-dependent
reproduction rate from the density-independent rate. Defaults to
&quot;<code><a href="#topic+BevertonHoltRDD">BevertonHoltRDD()</a></code>&quot;.</p>
</td></tr>
<tr><td><code id="newMultispeciesParams_+3A_kappa">kappa</code></td>
<td>
<p>The coefficient of the initial resource abundance power-law.</p>
</td></tr>
<tr><td><code id="newMultispeciesParams_+3A_n">n</code></td>
<td>
<p>The allometric growth exponent. This can be overruled for individual
species by including a <code>n</code> column in the <code>species_params</code>.</p>
</td></tr>
<tr><td><code id="newMultispeciesParams_+3A_resource_rate">resource_rate</code></td>
<td>
<p>Optional. Vector of resource intrinsic birth rates or
coefficient in the power-law for the birth rate, see Details. Must be
strictly positive.</p>
</td></tr>
<tr><td><code id="newMultispeciesParams_+3A_resource_capacity">resource_capacity</code></td>
<td>
<p>Optional. Vector of resource intrinsic carrying
capacities or coefficient in the power-law for the capacity, see Details.
The resource capacity must be larger than the resource abundance.</p>
</td></tr>
<tr><td><code id="newMultispeciesParams_+3A_lambda">lambda</code></td>
<td>
<p>Used to set power-law exponent for resource capacity if the
<code>resource_capacity</code> argument is given as a single number.</p>
</td></tr>
<tr><td><code id="newMultispeciesParams_+3A_w_pp_cutoff">w_pp_cutoff</code></td>
<td>
<p>The upper cut off size of the resource spectrum power law
used only if <code>resource_capacity</code> is given as a single number.</p>
</td></tr>
<tr><td><code id="newMultispeciesParams_+3A_resource_dynamics">resource_dynamics</code></td>
<td>
<p>Optional. Name of the function that determines the
resource dynamics by calculating the resource spectrum at the next time
step from the current state.</p>
</td></tr>
<tr><td><code id="newMultispeciesParams_+3A_gear_params">gear_params</code></td>
<td>
<p>A data frame with gear-specific parameter values.</p>
</td></tr>
<tr><td><code id="newMultispeciesParams_+3A_selectivity">selectivity</code></td>
<td>
<p>Optional. An array (gear x species x size) that holds the
selectivity of each gear for species and size, <code class="reqn">S_{g,i,w}</code>.</p>
</td></tr>
<tr><td><code id="newMultispeciesParams_+3A_catchability">catchability</code></td>
<td>
<p>Optional. An array (gear x species) that holds the catchability of
each species by each gear, <code class="reqn">Q_{g,i}</code>.</p>
</td></tr>
<tr><td><code id="newMultispeciesParams_+3A_initial_effort">initial_effort</code></td>
<td>
<p>Optional. A number or a named numeric vector specifying
the fishing effort. If a number, the same effort is used for all gears. If
a vector, must be named by gear.</p>
</td></tr>
<tr><td><code id="newMultispeciesParams_+3A_info_level">info_level</code></td>
<td>
<p>Controls the amount of information messages that are shown
when the function sets default values for parameters. Higher levels lead
to more messages.</p>
</td></tr>
<tr><td><code id="newMultispeciesParams_+3A_z0">z0</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a> Use <code>ext_mort</code> instead. Not to
be confused with the species_parameter <code>z0</code>.</p>
</td></tr>
<tr><td><code id="newMultispeciesParams_+3A_r_pp">r_pp</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>. Use <code>resource_rate</code> argument
instead.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of type <a href="#topic+MizerParams-class">MizerParams</a>
</p>


<h3>Species parameters</h3>

<p>The only essential argument is a data frame that contains the species
parameters. The data frame is arranged species by parameter, so each column
of the parameter data frame is a parameter and each row has the values of the
parameters for one of the species in the model.
</p>
<p>There are two essential columns that must be included in the species
parameter data.frame and that do not have default values: the
<code>species</code> column that should hold strings with the names of the
species and the <code>w_max</code> column with the maximum sizes of the species
in grams. (You could alternatively specify the maximum length in cm in an
<code>l_max</code> column.)
</p>
<p>The <code style="white-space: pre;">&#8288;species_params dataframe&#8288;</code> also needs to contain the parameters needed
by any predation kernel function (size selectivity function). This will
be mentioned in the appropriate sections below.
</p>
<p>For all other species parameters, mizer will calculate default values if they
are not included in the species parameter data frame. They will be
automatically added when the <code>MizerParams</code> object is created. For these
parameters you can also specify values for only some species and leave the
other entries as NA and the missing values will be set to the defaults.
So the <code>species_params</code> data frame saved in the returned MizerParams object
will differ from the one you supply because it will have the missing
species parameters filled in with default values.
</p>
<p>If you are not happy with any of the species parameter values used you can
always change them later with <code><a href="#topic+species_params+3C-">species_params&lt;-()</a></code>.
</p>
<p>All the parameters will be mentioned in the following sections.
</p>


<h3>Setting initial values</h3>

<p>The initial values for the species number densities are set using the
function <code>get_initial_n()</code>. These are quite arbitrary and not very close to
the steady state abundances. We intend to improve this in the future.
</p>
<p>The initial resource number density <code class="reqn">N_R(w)</code> is set to a power law with
coefficient <code>kappa</code> (<code class="reqn">\kappa</code>) and exponent <code>-lambda</code> (<code class="reqn">-\lambda</code>):
</p>
<p style="text-align: center;"><code class="reqn">N_R(w) = \kappa\, w^{-\lambda}</code>
</p>

<p>for all <code class="reqn">w</code> less than <code>w_pp_cutoff</code> and zero for larger sizes.
</p>


<h3>Size grid</h3>

<p>A size grid is created so that
the log-sizes are equally spaced. The spacing is chosen so that there will be
<code>no_w</code> fish size bins, with the smallest starting at <code>min_w</code> and the largest
starting at <code>max_w</code>. For the resource spectrum there is a larger set of
bins containing additional bins below
<code>min_w</code>, with the same log size. The number of extra bins is such that
<code>min_w_pp</code> comes to lie within the smallest bin.
</p>


<h3>Units in mizer</h3>

<p>Mizer uses grams to measure weight, centimetres to measure lengths, and
years to measure time.
</p>
<p>Mizer is agnostic about whether abundances are given as
</p>

<ol>
<li><p> numbers per area,
</p>
</li>
<li><p> numbers per volume or
</p>
</li>
<li><p> total numbers for the entire study area.
</p>
</li></ol>

<p>You should make the choice most convenient for your application and then
stick with it. If you make choice 1 or 2 you will also have to choose a unit
for area or volume. Your choice will then determine the units for some of
the parameters. This will be mentioned when the parameters are discussed in
the sections below.
</p>
<p>Your choice will also affect the units of the quantities you may want to
calculate with the model. For example, the yield will be in grams/year/m^2 in
case 1 if you choose m^2 as your measure of area, in grams/year/m^3 in case 2
if you choose m^3 as your unit of volume, or simply grams/year in case 3. The
same comment applies for other measures, like total biomass, which will be
grams/area in case 1, grams/volume in case 2 or simply grams in case 3. When
mizer puts units on axes in plots, it will choose the units appropriate for
case 3. So for example in <code><a href="#topic+plotBiomass">plotBiomass()</a></code> it gives the unit as grams.
</p>
<p>You can convert between these choices. For example, if you use case 1, you
need to multiply with the area of the ecosystem to get the total quantity.
If you work with case 2, you need to multiply by both area and the thickness
of the productive layer. In that respect, case 2 is a bit cumbersome. The
function <code><a href="#topic+scaleModel">scaleModel()</a></code> is useful to change the units you are using.
</p>


<h3>Setting interaction matrix</h3>

<p>You do not need to specify an interaction matrix. If you do not, then the
predator-prey interactions are purely determined by the size of predator
and prey and totally independent of the species of predator and prey.
</p>
<p>The interaction matrix <code class="reqn">\theta_{ij}</code> modifies the interaction of each
pair of species in the model. This can be used for example to allow for
different spatial overlap among the species.
The values in the interaction matrix are used to scale the encountered food
and predation mortality (see on the website <a href="https://sizespectrum.org/mizer/articles/model_description.html#sec:pref">the section on predator-prey encounter rate</a>
and on <a href="https://sizespectrum.org/mizer/articles/model_description.html#mortality">predation mortality</a>).
The first index refers to the predator species and the second to the prey
species.
</p>
<p>The interaction matrix is used when calculating the food encounter rate in
<code><a href="#topic+getEncounter">getEncounter()</a></code> and the predation mortality rate in <code><a href="#topic+getPredMort">getPredMort()</a></code>. Its
entries are dimensionless numbers. If all the values in the interaction
matrix are equal then predator-prey interactions are determined entirely by
size-preference.
</p>
<p>This function checks that the supplied interaction matrix is valid and then
stores it in the <code>interaction</code> slot of the <code>params</code> object.
</p>
<p>The order of the columns and rows of the <code>interaction</code> argument should be
the same as the order in the species params data frame in the <code>params</code>
object. If you supply a named array then the function will check the order
and warn if it is different. One way of creating your own interaction
matrix is to enter the data using a spreadsheet program and saving it as a
.csv file. The data can then be read into R using the command <code>read.csv()</code>.
</p>
<p>The interaction of the species with the resource are set via a column
<code>interaction_resource</code> in the <code>species_params</code> data frame. By default this
column is set to all 1s.
</p>


<h3>Setting predation kernel</h3>

<p><strong>Kernel dependent on predator to prey size ratio</strong>
</p>
<p>If the <code>pred_kernel</code> argument is not supplied, then this function sets a
predation kernel that depends only on the ratio of predator mass to prey
mass, not on the two masses independently. The shape of that kernel is then
determined by the <code>pred_kernel_type</code> column in species_params.
</p>
<p>The default for <code>pred_kernel_type</code> is &quot;lognormal&quot;. This will call the function
<code><a href="#topic+lognormal_pred_kernel">lognormal_pred_kernel()</a></code> to calculate the predation kernel.
An alternative pred_kernel type is &quot;box&quot;, implemented by the function
<code><a href="#topic+box_pred_kernel">box_pred_kernel()</a></code>, and &quot;power_law&quot;, implemented by the function
<code><a href="#topic+power_law_pred_kernel">power_law_pred_kernel()</a></code>. These functions require certain species
parameters in the species_params data frame. For the lognormal kernel these
are <code>beta</code> and <code>sigma</code>, for the box kernel they are <code>ppmr_min</code>
and <code>ppmr_max</code>. They are explained in the help pages for the kernel
functions. Except for <code>beta</code> and <code>sigma</code>, no defaults are set for
these parameters. If they are missing from the species_params data frame then
mizer will issue an error message.
</p>
<p>You can use any other string for <code>pred_kernel_type</code>. If for example you
choose &quot;my&quot; then you need to define a function <code>my_pred_kernel</code> that you can
model on the existing functions like <code><a href="#topic+lognormal_pred_kernel">lognormal_pred_kernel()</a></code>.
</p>
<p>When using a kernel that depends on the predator/prey size ratio only, mizer
does not need to store the entire three dimensional array in the MizerParams
object. Such an array can be very big when there is a large number of size
bins. Instead, mizer only needs to store two two-dimensional arrays that hold
Fourier transforms of the feeding kernel function that allow the encounter
rate and the predation rate to be calculated very efficiently. However, if
you need the full three-dimensional array you can calculate it with the
<code><a href="#topic+getPredKernel">getPredKernel()</a></code> function.
</p>
<p><strong>Kernel dependent on both predator and prey size</strong>
</p>
<p>If you want to work with a feeding kernel that depends on predator mass and
prey mass independently, you can specify the full feeding kernel as a
three-dimensional array (predator species x predator size x prey size).
</p>
<p>You should use this option only if a kernel dependent only on the
predator/prey mass ratio is not appropriate. Using a kernel dependent on
predator/prey mass ratio only allows mizer to use fast Fourier transform
methods to significantly reduce the running time of simulations.
</p>
<p>The order of the predator species in <code>pred_kernel</code> should be the same
as the order in the species params dataframe in the <code>params</code> object. If you
supply a named array then the function will check the order and warn if it is
different.
</p>


<h3>Setting search volume</h3>

<p>The search volume <code class="reqn">\gamma_i(w)</code> of an individual of species <code class="reqn">i</code>
and weight <code class="reqn">w</code> multiplies the predation kernel when
calculating the encounter rate in <code><a href="#topic+getEncounter">getEncounter()</a></code> and the
predation rate in <code><a href="#topic+getPredRate">getPredRate()</a></code>.
</p>
<p>The name &quot;search volume&quot; is a bit misleading, because <code class="reqn">\gamma_i(w)</code> does
not have units of volume. It is simply a parameter that determines the rate
of predation. Its units depend on your choice, see section &quot;Units in mizer&quot;.
If you have chosen to work with total abundances, then it is a rate with units
1/year. If you have chosen to work with abundances per m^2 then it has units
of m^2/year. If you have chosen to work with abundances per m^3 then it has
units of m^3/year.
</p>
<p>If the <code>search_vol</code> argument is not supplied, then the search volume is
set to
</p>
<p style="text-align: center;"><code class="reqn">\gamma_i(w) = \gamma_i w^q_i.</code>
</p>

<p>The values of <code class="reqn">\gamma_i</code> (the search volume at 1g) and <code class="reqn">q_i</code> (the
allometric exponent of the search volume) are taken from the <code>gamma</code> and
<code>q</code> columns in the species parameter dataframe. If the <code>gamma</code>
column is not supplied in the species parameter dataframe, a default is
calculated by the <code><a href="#topic+get_gamma_default">get_gamma_default()</a></code> function. Note that only
for predators of size <code class="reqn">w = 1</code> gram is the value of the species parameter
<code class="reqn">\gamma_i</code> the same as the value of the search volume <code class="reqn">\gamma_i(w)</code>.
</p>


<h3>Setting maximum intake rate</h3>

<p>The maximum intake rate <code class="reqn">h_i(w)</code> of an individual of species <code class="reqn">i</code> and
weight <code class="reqn">w</code> determines the feeding level, calculated with
<code><a href="#topic+getFeedingLevel">getFeedingLevel()</a></code>. It is measured in grams/year.
</p>
<p>If the <code>intake_max</code> argument is not supplied, then the maximum intake
rate is set to </p>
<p style="text-align: center;"><code class="reqn">h_i(w) = h_i w^{n_i}.</code>
</p>

<p>The values of <code class="reqn">h_i</code> (the maximum intake rate of an individual of size 1
gram) and <code class="reqn">n_i</code> (the allometric exponent for the intake rate) are taken
from the <code>h</code> and <code>n</code> columns in the species parameter dataframe. If
the <code>h</code> column is not supplied in the species parameter dataframe, it is
calculated by the <code><a href="#topic+get_h_default">get_h_default()</a></code> function.
</p>
<p>If <code class="reqn">h_i</code> is set to <code>Inf</code>, fish of species i will consume all encountered
food.
</p>


<h3>Setting metabolic rate</h3>

<p>The metabolic rate is subtracted from the energy income rate to calculate
the rate at which energy is available for growth and reproduction, see
<code><a href="#topic+getEReproAndGrowth">getEReproAndGrowth()</a></code>. It is measured in grams/year.
</p>
<p>If the <code>metab</code> argument is not supplied, then for each species the
metabolic rate <code class="reqn">k(w)</code> for an individual of size <code class="reqn">w</code> is set to
</p>
<p style="text-align: center;"><code class="reqn">k(w) = k_s w^p + k w,</code>
</p>

<p>where <code class="reqn">k_s w^p</code> represents the rate of standard metabolism and <code class="reqn">k w</code>
is the rate at which energy is expended on activity and movement. The values
of <code class="reqn">k_s</code>, <code class="reqn">p</code> and <code class="reqn">k</code> are taken from the <code>ks</code>, <code>p</code> and
<code>k</code> columns in the species parameter dataframe. If any of these
parameters are not supplied, the defaults are <code class="reqn">k = 0</code>, <code class="reqn">p = n</code> and
</p>
<p style="text-align: center;"><code class="reqn">k_s = f_c h \alpha w_{mat}^{n-p},</code>
</p>

<p>where <code class="reqn">f_c</code> is the critical feeding level taken from the <code>fc</code> column
in the species parameter data frame. If the critical feeding level is not
specified, a default of <code class="reqn">f_c = 0.2</code> is used.
</p>


<h3>Setting external mortality rate</h3>

<p>The external mortality is all the mortality that is not due to fishing or
predation by predators included in the model. The external mortality could be
due to predation by predators that are not explicitly included in the model
(e.g. mammals or seabirds) or due to other causes like illness. It is a rate
with units 1/year.
</p>
<p>The <code>ext_mort</code> argument allows you to specify an external mortality rate
that depends on species and body size. You can see an example of this in
the Examples section of the help page for <code><a href="#topic+setExtMort">setExtMort()</a></code>.
</p>
<p>If the <code>ext_mort</code> argument is not supplied, then the external mortality is
assumed to depend only on the species, not on the size of the individual:
<code class="reqn">\mu_{ext.i}(w) = z_{0.i}</code>. The value of the constant <code class="reqn">z_0</code> for each
species is taken from the <code>z0</code> column of the species parameter data frame, if
that column exists. Otherwise it is calculated as
</p>
<p style="text-align: center;"><code class="reqn">z_{0.i} = {\tt z0pre}_i\, w_{inf}^{\tt z0exp}.</code>
</p>



<h3>Setting external encounter rate</h3>

<p>The external encounter rate is the rate at which a predator encounters
food that is not explicitly modelled. It is a rate with units mass/year.
</p>
<p>The <code>ext_encounter</code> argument allows you to specify an external encounter rate
that depends on species and body size. You can see an example of this in
the Examples section of the help page for <code><a href="#topic+setExtEncounter">setExtEncounter()</a></code>.
</p>


<h3>Setting reproduction</h3>

<p>For each species and at each size, the proportion <code class="reqn">\psi</code> of the
available energy
that is invested into reproduction is the product of two factors: the
proportion <code>maturity</code> of individuals that are mature and the proportion
<code>repro_prop</code> of the energy available to a mature individual that is
invested into reproduction.
</p>


<h4>Maturity ogive</h4>

<p>If the the proportion of individuals that are mature is not supplied via
the <code>maturity</code> argument , then it is set to a sigmoidal
maturity ogive that changes from 0 to 1 at around the maturity size:
</p>
<p style="text-align: center;"><code class="reqn">{\tt maturity}(w) = \left[1+\left(\frac{w}{w_{mat}}\right)^{-U}\right]^{-1}.</code>
</p>

<p>(To avoid clutter, we are not showing the species index in the equations,
although each species has its own maturity ogive.)
The maturity weights are taken from the <code>w_mat</code> column of the
species_params data frame. Any missing maturity weights are set to 1/4 of the
maximum weight in the <code>w_max</code> column.
</p>
<p>The exponent <code class="reqn">U</code> determines the steepness of the maturity ogive. By
default it is chosen as <code class="reqn">U = 10</code>, however this can be overridden by
including a column <code>w_mat25</code> in the species parameter dataframe that
specifies the weight at which 25% of individuals are mature, which sets
<code class="reqn">U = \log(3) / \log(w_{mat} / w_{25}).</code>
</p>
<p>The sigmoidal function given above would strictly reach 1 only asymptotically.
Mizer instead sets the function equal to 1 already at the species'
maximum size, taken from the compulsory <code>w_max</code> column in the
species parameter data frame. Also, for computational simplicity, any
proportion smaller than <code>1e-8</code> is set to <code>0</code>.
</p>



<h4>Investment into reproduction</h4>

<p>If the the energy available to a mature individual that is
invested into reproduction is not supplied via the <code>repro_prop</code> argument,
it is set to the allometric form
</p>
<p style="text-align: center;"><code class="reqn">{\tt repro\_prop}(w) = \left(\frac{w}{w_{max}}\right)^{m-n}.</code>
</p>

<p>Here <code class="reqn">n</code> is the scaling exponent of the energy income rate. Hence
the exponent <code class="reqn">m</code> determines the scaling of the investment into
reproduction for mature individuals. By default it is chosen to be
<code class="reqn">m = 1</code> so that the rate at which energy is invested into reproduction
scales linearly with the size. This default can be overridden by including a
column <code>m</code> in the species parameter dataframe. The maximum sizes
are taken from the compulsory <code>w_max</code> column in the species parameter
data frame.
</p>
<p>The total proportion of energy invested into reproduction of an individual
of size <code class="reqn">w</code> is then
</p>
<p style="text-align: center;"><code class="reqn">\psi(w) = {\tt maturity}(w){\tt repro\_prop}(w)</code>
</p>




<h4>Reproductive efficiency</h4>

<p>The reproductive efficiency <code class="reqn">\epsilon</code>, i.e., the proportion of energy allocated to
reproduction that results in egg biomass, is set through the <code>erepro</code>
column in the species_params data frame. If that is not provided, the default
is set to 1 (which you will want to override). The offspring biomass divided
by the egg biomass gives the rate of egg production, returned by
<code><a href="#topic+getRDI">getRDI()</a></code>:
</p>
<p style="text-align: center;"><code class="reqn">R_{di} = \frac{\epsilon}{2 w_{min}} \int N(w)  E_r(w) \psi(w) \, dw</code>
</p>




<h4>Density dependence</h4>

<p>The stock-recruitment relationship is an emergent phenomenon in mizer, with
several sources of density dependence. Firstly, the amount of energy invested
into reproduction depends on the energy income of the spawners, which is
density-dependent due to competition for prey. Secondly, the proportion of
larvae that grow up to recruitment size depends on the larval mortality,
which depends on the density of predators, and on larval growth rate, which
depends on density of prey.
</p>
<p>Finally, to encode all the density dependence in the stock-recruitment
relationship that is not already included in the other two sources of density
dependence, mizer puts the the density-independent rate of egg production
through a density-dependence function. The result is returned by
<code><a href="#topic+getRDD">getRDD()</a></code>. The name of the density-dependence function is
specified by the <code>RDD</code> argument. The default is the Beverton-Holt
function <code><a href="#topic+BevertonHoltRDD">BevertonHoltRDD()</a></code>, which requires an <code>R_max</code> column
in the species_params data frame giving the maximum egg production rate. If
this column does not exist, it is initialised to <code>Inf</code>, leading to no
density-dependence. Other functions provided by mizer are
<code><a href="#topic+RickerRDD">RickerRDD()</a></code> and <code><a href="#topic+SheperdRDD">SheperdRDD()</a></code> and you can easily use
these as models for writing your own functions.
</p>



<h3>Setting fishing</h3>

<p><strong>Gears</strong>
</p>
<p>In <code>mizer</code>, fishing mortality is imposed on species by fishing gears. The
total per-capita fishing mortality (1/year) is obtained by summing over the
mortality from all gears,
</p>
<p style="text-align: center;"><code class="reqn">\mu_{f.i}(w) = \sum_g F_{g,i}(w),</code>
</p>

<p>where the fishing mortality <code class="reqn">F_{g,i}(w)</code> imposed by gear <code class="reqn">g</code> on
species <code class="reqn">i</code> at size <code class="reqn">w</code> is calculated as:
</p>
<p style="text-align: center;"><code class="reqn">F_{g,i}(w) = S_{g,i}(w) Q_{g,i} E_{g},</code>
</p>

<p>where <code class="reqn">S</code> is the selectivity by species, gear and size, <code class="reqn">Q</code> is the
catchability by species and gear and <code class="reqn">E</code> is the fishing effort by gear.
</p>
<p><strong>Selectivity</strong>
</p>
<p>The selectivity at size of each gear for each species is saved as a three
dimensional array (gear x species x size). Each entry has a range between 0
(that gear is not selecting that species at that size) to 1 (that gear is
selecting all individuals of that species of that size). This three
dimensional array can be specified explicitly via the <code>selectivity</code>
argument, but usually mizer calculates it from the <code>gear_params</code> slot of
the MizerParams object.
</p>
<p>To allow the calculation of the <code>selectivity</code> array, the <code>gear_params</code> slot
must be a data frame with one row for each gear-species combination. So if
for example a gear can select three species, then that gear contributes three
rows to the <code>gear_params</code> data frame, one for each species it can select. The
data frame must have columns <code>gear</code>, holding the name of the gear, <code>species</code>,
holding the name of the species, and <code>sel_func</code>, holding the name of the
function that calculates the selectivity curve. Some selectivity functions
are included in the package: <code>knife_edge()</code>, <code>sigmoid_length()</code>,
<code>double_sigmoid_length()</code>, and <code>sigmoid_weight()</code>.
Users are able to write their own size-based selectivity function. The first
argument to the function must be <code>w</code> and the function must return a vector of
the selectivity (between 0 and 1) at size.
</p>
<p>Each selectivity function may have parameters. Values for these
parameters must be included as columns in the gear parameters data.frame.
The names of the columns must exactly match the names of the corresponding
arguments of the selectivity function. For example, the default selectivity
function is <code>knife_edge()</code> that a has sudden change of selectivity from 0 to 1
at a certain size. In its help page you can see that the <code>knife_edge()</code>
function has arguments <code>w</code> and <code>knife_edge_size</code>. The first argument, <code>w</code>, is
size (the function calculates selectivity at size). All selectivity functions
must have <code>w</code> as the first argument. The values for the other arguments must
be found in the gear parameters data.frame. So for the <code>knife_edge()</code>
function there should be a <code>knife_edge_size</code> column. Because <code>knife_edge()</code>
is the default selectivity function, the <code>knife_edge_size</code> argument has a
default value = <code>w_mat</code>.
</p>
<p>In case each species is only selected by one gear, the columns of the
<code>gear_params</code> data frame can alternatively be provided as columns of the
<code>species_params</code> data frame, if this is more convenient for the user to set
up. Mizer will then copy these columns over to create the <code>gear_params</code> data
frame when it creates the MizerParams object. However changing these columns
in the species parameter data frame later will not update the <code>gear_params</code>
data frame.
</p>
<p><strong>Catchability</strong>
</p>
<p>Catchability is used as an additional factor to make the link between gear
selectivity, fishing effort and fishing mortality. For example, it can be set
so that an effort of 1 gives a desired fishing mortality. In this way effort
can then be specified relative to a 'base effort', e.g. the effort in a
particular year.
</p>
<p>Catchability is stored as a two dimensional array (gear x species). This can
either be provided explicitly via the <code>catchability</code> argument, or the
information can be provided via a <code>catchability</code> column in the <code>gear_params</code>
data frame.
</p>
<p>In the case where each species is selected by only a single gear, the
<code>catchability</code> column can also be provided in the <code>species_params</code> data
frame. Mizer will then copy this over to the <code>gear_params</code> data frame when
the MizerParams object is created.
</p>
<p><strong>Effort</strong>
</p>
<p>The initial fishing effort is stored in the <code>MizerParams</code> object. If it is
not supplied, it is set to zero. The initial effort can be overruled when
the simulation is run with <code>project()</code>, where it is also possible to specify
an effort that varies through time.
</p>


<h3>Setting resource dynamics</h3>

<p>You would usually set the resource dynamics only after having finished the
calibration of the steady state. Then setting the resource dynamics with
this function will preserve that steady state, unless you explicitly
choose to set <code>balance = FALSE</code>. Your choice of the resource dynamics only
affects the dynamics around the steady state. The higher the resource rate
or the lower the resource capacity the less sensitive the model will be to
changes in the competition for resource.
</p>
<p>The <code>resource_dynamics</code> argument allows you to choose the resource dynamics
function. By default, mizer uses a semichemostat model to describe the
resource dynamics in each size class independently. This semichemostat
dynamics is implemented by the function <code><a href="#topic+resource_semichemostat">resource_semichemostat()</a></code>. You can
change that to use a logistic model implemented by <code><a href="#topic+resource_logistic">resource_logistic()</a></code> or
you can use <code><a href="#topic+resource_constant">resource_constant()</a></code> which keeps the resource constant or you
can write your own function.
</p>
<p>Both the <code><a href="#topic+resource_semichemostat">resource_semichemostat()</a></code> and the <code><a href="#topic+resource_logistic">resource_logistic()</a></code> dynamics
are parametrised in terms of a size-dependent rate <code class="reqn">r_R(w)</code> and a
size-dependent capacity <code class="reqn">c_R</code>. The help pages of these functions give
the details.
</p>
<p>The <code>resource_rate</code> argument can be a vector (with the same length as
<code>w_full(params)</code>) specifying the intrinsic resource growth rate for each size
class. Alternatively it can be a single number, which is then used as the
coefficient in a power law: then the intrinsic growth rate <code class="reqn">r_R(w)</code> at
size <code class="reqn">w</code> is set to
</p>
<p style="text-align: center;"><code class="reqn">r_R(w) = r_R w^{n-1}.</code>
</p>

<p>The power-law exponent <code class="reqn">n</code> is taken from the <code>n</code> argument.
</p>
<p>The <code>resource_capacity</code> argument can be a vector specifying the intrinsic
resource carrying capacity for each size class. Alternatively it can be a
single number, which is then used as the coefficient in a truncated power
law: then the intrinsic growth rate <code class="reqn">c_R(w)</code> at size <code class="reqn">w</code> is set to
</p>
<p style="text-align: center;"><code class="reqn">c(w) = \kappa\, w^{-\lambda}</code>
</p>

<p>for all <code class="reqn">w</code> less than <code>w_pp_cutoff</code> and zero for larger sizes.
The power-law exponent <code class="reqn">\lambda</code> is taken from the <code>lambda</code> argument.
</p>
<p>The values for <code>lambda</code>, <code>n</code> and <code>w_pp_cutoff</code> are stored in a list in the
<code>resource_params</code> slot of the MizerParams object so that they can be re-used
automatically in the future. That list can be accessed with
<code><a href="#topic+resource_params">resource_params()</a></code>. It also holds the coefficient <code>kappa</code> that describes the
steady-state resource abundance.
</p>


<h3>See Also</h3>

<p>Other functions for setting up models: 
<code><a href="#topic+newCommunityParams">newCommunityParams</a>()</code>,
<code><a href="#topic+newSingleSpeciesParams">newSingleSpeciesParams</a>()</code>,
<code><a href="#topic+newTraitParams">newTraitParams</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>params &lt;- newMultispeciesParams(NS_species_params)
</code></pre>

<hr>
<h2 id='newSingleSpeciesParams'>Set up parameters for a single species in a power-law background</h2><span id='topic+newSingleSpeciesParams'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>
<p>This functions creates a <code>MizerParams</code> object with a single
species. This species is embedded in a fixed power-law community spectrum
</p>
<p style="text-align: center;"><code class="reqn">N_c(w) = \kappa w^{-\lambda}</code>
</p>

<p>This community provides the food income for the species. Cannibalism is
switched off. The predation mortality arises only from the predators in the
power-law community and it is assumed that the predators in the community
have the same feeding parameters as the foreground species. The function has
many arguments, all of which have default values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>newSingleSpeciesParams(
  species_name = "Target species",
  w_max = 100,
  w_min = 0.001,
  eta = 10^(-0.6),
  w_mat = w_max * eta,
  no_w = log10(w_max/w_min) * 20 + 1,
  n = 3/4,
  p = n,
  lambda = 2.05,
  kappa = 0.005,
  alpha = 0.4,
  h = 30,
  beta = 100,
  sigma = 1.3,
  f0 = 0.6,
  fc = 0.25,
  ks = NA,
  gamma = NA,
  ext_mort_prop = 0,
  reproduction_level = 0,
  R_factor = deprecated(),
  w_inf = deprecated(),
  k_vb = deprecated()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="newSingleSpeciesParams_+3A_species_name">species_name</code></td>
<td>
<p>A string with a name for the species. Will be used in
plot legends.</p>
</td></tr>
<tr><td><code id="newSingleSpeciesParams_+3A_w_max">w_max</code></td>
<td>
<p>Maximum size of species</p>
</td></tr>
<tr><td><code id="newSingleSpeciesParams_+3A_w_min">w_min</code></td>
<td>
<p>Egg size of species</p>
</td></tr>
<tr><td><code id="newSingleSpeciesParams_+3A_eta">eta</code></td>
<td>
<p>Ratio between maturity size <code>w_mat</code> and maximum size
<code>w_max</code>. Default is 10^(-0.6), approximately 1/4. Ignored if
<code>w_mat</code> is supplied explicitly.</p>
</td></tr>
<tr><td><code id="newSingleSpeciesParams_+3A_w_mat">w_mat</code></td>
<td>
<p>Maturity size of species. Default value is
<code>eta * w_max</code>.</p>
</td></tr>
<tr><td><code id="newSingleSpeciesParams_+3A_no_w">no_w</code></td>
<td>
<p>The number of size bins in the community spectrum. These bins
will be equally spaced on a logarithmic scale. Default value is such that
there are 20 bins for each factor of 10 in weight.</p>
</td></tr>
<tr><td><code id="newSingleSpeciesParams_+3A_n">n</code></td>
<td>
<p>Scaling exponent of the maximum intake rate.</p>
</td></tr>
<tr><td><code id="newSingleSpeciesParams_+3A_p">p</code></td>
<td>
<p>Scaling exponent of the standard metabolic rate. By default this is
equal to the exponent <code>n</code>.</p>
</td></tr>
<tr><td><code id="newSingleSpeciesParams_+3A_lambda">lambda</code></td>
<td>
<p>Exponent of the abundance power law.</p>
</td></tr>
<tr><td><code id="newSingleSpeciesParams_+3A_kappa">kappa</code></td>
<td>
<p>Coefficient in abundance power law.</p>
</td></tr>
<tr><td><code id="newSingleSpeciesParams_+3A_alpha">alpha</code></td>
<td>
<p>The assimilation efficiency.</p>
</td></tr>
<tr><td><code id="newSingleSpeciesParams_+3A_h">h</code></td>
<td>
<p>Maximum food intake rate.</p>
</td></tr>
<tr><td><code id="newSingleSpeciesParams_+3A_beta">beta</code></td>
<td>
<p>Preferred predator prey mass ratio.</p>
</td></tr>
<tr><td><code id="newSingleSpeciesParams_+3A_sigma">sigma</code></td>
<td>
<p>Width of prey size preference.</p>
</td></tr>
<tr><td><code id="newSingleSpeciesParams_+3A_f0">f0</code></td>
<td>
<p>Expected average feeding level. Used to set <code>gamma</code>, the
coefficient in the search rate. Ignored if <code>gamma</code> is given
explicitly.</p>
</td></tr>
<tr><td><code id="newSingleSpeciesParams_+3A_fc">fc</code></td>
<td>
<p>Critical feeding level. Used to determine <code>ks</code> if it is not given
explicitly.</p>
</td></tr>
<tr><td><code id="newSingleSpeciesParams_+3A_ks">ks</code></td>
<td>
<p>Standard metabolism coefficient. If not provided, default will be
calculated from critical feeding level argument <code>fc</code>.</p>
</td></tr>
<tr><td><code id="newSingleSpeciesParams_+3A_gamma">gamma</code></td>
<td>
<p>Volumetric search rate. If not provided, default is determined
by <code><a href="#topic+get_gamma_default">get_gamma_default()</a></code> using the value of <code>f0</code>.</p>
</td></tr>
<tr><td><code id="newSingleSpeciesParams_+3A_ext_mort_prop">ext_mort_prop</code></td>
<td>
<p>The proportion of the total mortality that comes from
external mortality, i.e., from sources not explicitly modelled. A number in
the interval [0, 1).</p>
</td></tr>
<tr><td><code id="newSingleSpeciesParams_+3A_reproduction_level">reproduction_level</code></td>
<td>
<p>A number between 0 an 1 that determines the
level of density dependence in reproduction, see <code><a href="#topic+setBevertonHolt">setBevertonHolt()</a></code>.</p>
</td></tr>
<tr><td><code id="newSingleSpeciesParams_+3A_r_factor">R_factor</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a> Use
<code>reproduction_level = 1 / R_factor</code> instead.</p>
</td></tr>
<tr><td><code id="newSingleSpeciesParams_+3A_w_inf">w_inf</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a> The argument has been
renamed to <code>w_max</code>.</p>
</td></tr>
<tr><td><code id="newSingleSpeciesParams_+3A_k_vb">k_vb</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a> The von Bertalanffy growth
parameter.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In addition to setting up the parameters, this function also sets up an
initial condition that is close to steady state, under the assumption of
no fishing.
</p>


<h3>Value</h3>

<p>An object of type <code>MizerParams</code>
</p>


<h3>See Also</h3>

<p>Other functions for setting up models: 
<code><a href="#topic+newCommunityParams">newCommunityParams</a>()</code>,
<code><a href="#topic+newMultispeciesParams">newMultispeciesParams</a>()</code>,
<code><a href="#topic+newTraitParams">newTraitParams</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>params &lt;- newSingleSpeciesParams()
sim &lt;- project(params, t_max = 5, effort = 0)
plotSpectra(sim)
</code></pre>

<hr>
<h2 id='newTraitParams'>Set up parameters for a trait-based multispecies model</h2><span id='topic+newTraitParams'></span>

<h3>Description</h3>

<p>This functions creates a <code>MizerParams</code> object describing a trait-based
model. This is a simplification of the general size-based model used in
<code>mizer</code> in which the species-specific parameters are the same for all
species, except for the maximum size, which is considered the most
important trait characterizing a species. Other parameters are related to the
maximum size. For example, the size at maturity is given by <code>w_max *
eta</code>, where <code>eta</code> is the same for all species. For the trait-based model
the number of species is not important. For applications of the trait-based
model see Andersen &amp; Pedersen (2010). See the <code>mizer</code> website for more
details and examples of the trait-based model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>newTraitParams(
  no_sp = 11,
  min_w_max = 10,
  max_w_max = 10^4,
  min_w = 10^(-3),
  max_w = max_w_max,
  eta = 10^(-0.6),
  min_w_mat = min_w_max * eta,
  no_w = round(log10(max_w_max/min_w) * 20 + 1),
  min_w_pp = 1e-10,
  w_pp_cutoff = min_w_mat,
  n = 2/3,
  p = n,
  lambda = 2.05,
  r_pp = 0.1,
  kappa = 0.005,
  alpha = 0.4,
  h = 40,
  beta = 100,
  sigma = 1.3,
  f0 = 0.6,
  fc = 0.25,
  ks = NA,
  gamma = NA,
  ext_mort_prop = 0,
  reproduction_level = 1/4,
  R_factor = deprecated(),
  gear_names = "knife_edge_gear",
  knife_edge_size = 1000,
  egg_size_scaling = FALSE,
  resource_scaling = FALSE,
  perfect_scaling = FALSE,
  min_w_inf = deprecated(),
  max_w_inf = deprecated()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="newTraitParams_+3A_no_sp">no_sp</code></td>
<td>
<p>The number of species in the model.</p>
</td></tr>
<tr><td><code id="newTraitParams_+3A_min_w_max">min_w_max</code></td>
<td>
<p>The maximum size of the smallest species in the
community. This will be rounded to lie on a grid point.</p>
</td></tr>
<tr><td><code id="newTraitParams_+3A_max_w_max">max_w_max</code></td>
<td>
<p>The maximum size of the largest species in the community.
This will be rounded to lie on a grid point.</p>
</td></tr>
<tr><td><code id="newTraitParams_+3A_min_w">min_w</code></td>
<td>
<p>The size of the the egg of the smallest species. This also
defines the start of the community size spectrum.</p>
</td></tr>
<tr><td><code id="newTraitParams_+3A_max_w">max_w</code></td>
<td>
<p>The largest size in the model. By default this is set to the
largest maximum size <code>max_w_max</code>. Setting it to something larger
only makes sense if you plan to add larger species to the model later.</p>
</td></tr>
<tr><td><code id="newTraitParams_+3A_eta">eta</code></td>
<td>
<p>Ratio between maturity size and maximum size of a species.
Ignored if <code>min_w_mat</code> is supplied. Default is 10^(-0.6),
approximately 1/4.</p>
</td></tr>
<tr><td><code id="newTraitParams_+3A_min_w_mat">min_w_mat</code></td>
<td>
<p>The maturity size of the smallest species. Default value is
<code>eta * min_w_max</code>. This will be rounded to lie on a grid point.</p>
</td></tr>
<tr><td><code id="newTraitParams_+3A_no_w">no_w</code></td>
<td>
<p>The number of size bins in the community spectrum. These bins
will be equally spaced on a logarithmic scale. Default value is such that
there are 20 bins for each factor of 10 in weight.</p>
</td></tr>
<tr><td><code id="newTraitParams_+3A_min_w_pp">min_w_pp</code></td>
<td>
<p>The smallest size of the resource spectrum. By default this
is set to the smallest value at which any of the consumers can feed.</p>
</td></tr>
<tr><td><code id="newTraitParams_+3A_w_pp_cutoff">w_pp_cutoff</code></td>
<td>
<p>The largest size of the resource spectrum. Default value
is min_w_max unless <code>perfect_scaling = TRUE</code> when it is Inf.</p>
</td></tr>
<tr><td><code id="newTraitParams_+3A_n">n</code></td>
<td>
<p>Scaling exponent of the maximum intake rate.</p>
</td></tr>
<tr><td><code id="newTraitParams_+3A_p">p</code></td>
<td>
<p>Scaling exponent of the standard metabolic rate. By default this is
equal to the exponent <code>n</code>.</p>
</td></tr>
<tr><td><code id="newTraitParams_+3A_lambda">lambda</code></td>
<td>
<p>Exponent of the abundance power law.</p>
</td></tr>
<tr><td><code id="newTraitParams_+3A_r_pp">r_pp</code></td>
<td>
<p>Growth rate parameter for the resource spectrum.</p>
</td></tr>
<tr><td><code id="newTraitParams_+3A_kappa">kappa</code></td>
<td>
<p>Coefficient in abundance power law.</p>
</td></tr>
<tr><td><code id="newTraitParams_+3A_alpha">alpha</code></td>
<td>
<p>The assimilation efficiency.</p>
</td></tr>
<tr><td><code id="newTraitParams_+3A_h">h</code></td>
<td>
<p>Maximum food intake rate.</p>
</td></tr>
<tr><td><code id="newTraitParams_+3A_beta">beta</code></td>
<td>
<p>Preferred predator prey mass ratio.</p>
</td></tr>
<tr><td><code id="newTraitParams_+3A_sigma">sigma</code></td>
<td>
<p>Width of prey size preference.</p>
</td></tr>
<tr><td><code id="newTraitParams_+3A_f0">f0</code></td>
<td>
<p>Expected average feeding level. Used to set <code>gamma</code>, the
coefficient in the search rate. Ignored if <code>gamma</code> is given
explicitly.</p>
</td></tr>
<tr><td><code id="newTraitParams_+3A_fc">fc</code></td>
<td>
<p>Critical feeding level. Used to determine <code>ks</code> if it is not given
explicitly.</p>
</td></tr>
<tr><td><code id="newTraitParams_+3A_ks">ks</code></td>
<td>
<p>Standard metabolism coefficient. If not provided, default will be
calculated from critical feeding level argument <code>fc</code>.</p>
</td></tr>
<tr><td><code id="newTraitParams_+3A_gamma">gamma</code></td>
<td>
<p>Volumetric search rate. If not provided, default is determined
by <code><a href="#topic+get_gamma_default">get_gamma_default()</a></code> using the value of <code>f0</code>.</p>
</td></tr>
<tr><td><code id="newTraitParams_+3A_ext_mort_prop">ext_mort_prop</code></td>
<td>
<p>The proportion of the total mortality that comes from
external mortality, i.e., from sources not explicitly modelled. A number in
the interval [0, 1).</p>
</td></tr>
<tr><td><code id="newTraitParams_+3A_reproduction_level">reproduction_level</code></td>
<td>
<p>A number between 0 an 1 that determines the
level of density dependence in reproduction, see <code><a href="#topic+setBevertonHolt">setBevertonHolt()</a></code>.</p>
</td></tr>
<tr><td><code id="newTraitParams_+3A_r_factor">R_factor</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a> Use
<code>reproduction_level = 1 / R_factor</code> instead.</p>
</td></tr>
<tr><td><code id="newTraitParams_+3A_gear_names">gear_names</code></td>
<td>
<p>The names of the fishing gears for each species. A
character vector, the same length as the number of species.</p>
</td></tr>
<tr><td><code id="newTraitParams_+3A_knife_edge_size">knife_edge_size</code></td>
<td>
<p>The minimum size at which the gear or gears select
fish. A single value for each gear or a vector with one value for each
gear.</p>
</td></tr>
<tr><td><code id="newTraitParams_+3A_egg_size_scaling">egg_size_scaling</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
If TRUE, the egg size is a constant fraction of the
maximum size of each species. This fraction is <code>min_w / min_w_max</code>. If
FALSE, all species have the egg size <code>w_min</code>.</p>
</td></tr>
<tr><td><code id="newTraitParams_+3A_resource_scaling">resource_scaling</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
If TRUE, the carrying capacity for larger resource
is reduced to compensate for the fact that fish eggs and larvae are
present in the same size range.</p>
</td></tr>
<tr><td><code id="newTraitParams_+3A_perfect_scaling">perfect_scaling</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
If TRUE then parameters are set so that the community
abundance, growth before reproduction and death are perfect power laws. In
particular all other scaling corrections are turned on.</p>
</td></tr>
<tr><td><code id="newTraitParams_+3A_min_w_inf">min_w_inf</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a> The argument has been
renamed to <code>min_w_max</code> to make it clearer that it refers to the maximum
size of a species not the von Bertalanffy asymptotic size parameter.</p>
</td></tr>
<tr><td><code id="newTraitParams_+3A_max_w_inf">max_w_inf</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a> The argument has been
renamed to <code>max_w_max</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function has many arguments, all of which have default values. Of
particular interest to the user are the number of species in the model and
the minimum and maximum sizes.
</p>
<p>The characteristic weights of the smallest species are defined by
<code>min_w</code> (egg size), <code>min_w_mat</code> (maturity size) and
<code>min_w_max</code> (maximum size). The maximum sizes of
the <code>no_sp</code> species
are logarithmically evenly spaced, ranging from <code>min_w_max</code> to
<code>max_w_max</code>.
Similarly the maturity sizes of the species are logarithmically evenly
spaced, so that the ratio <code>eta</code> between maturity size and maximum
size is the same for all species. If <code>egg_size_scaling = TRUE</code> then also
the ratio between maximum size and egg size is the same for all species.
Otherwise all species have the same egg size.
</p>
<p>In addition to setting up the parameters, this function also sets up an
initial condition that is close to steady state.
</p>
<p>The search rate coefficient <code>gamma</code> is calculated using the expected
feeding level, <code>f0</code>.
</p>
<p>The option of including fishing is given, but the steady state may loose its
natural stability if too much fishing is included. In such a case the user
may wish to include stabilising effects (like <code>reproduction_level</code>) to ensure
the steady state is stable. Fishing selectivity is modelled as a knife-edge
function with one parameter, <code>knife_edge_size</code>, which is the size at which
species are selected. Each species can either be fished by the same gear
(<code>knife_edge_size</code> has a length of 1) or by a different gear (the length of
<code>knife_edge_size</code> has the same length as the number of species and the order
of selectivity size is that of the maximum size).
</p>
<p>The resulting <code>MizerParams</code> object can be projected forward using
<code>project()</code> like any other <code>MizerParams</code> object. When projecting
the model it may be necessary to reduce <code>dt</code> below 0.1 to avoid any
instabilities with the solver. You can check this by plotting the biomass or
abundance through time after the projection.
</p>


<h3>Value</h3>

<p>An object of type <code>MizerParams</code>
</p>


<h3>See Also</h3>

<p>Other functions for setting up models: 
<code><a href="#topic+newCommunityParams">newCommunityParams</a>()</code>,
<code><a href="#topic+newMultispeciesParams">newMultispeciesParams</a>()</code>,
<code><a href="#topic+newSingleSpeciesParams">newSingleSpeciesParams</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>params &lt;- newTraitParams()
sim &lt;- project(params, t_max = 5, effort = 0)
plotSpectra(sim)
</code></pre>

<hr>
<h2 id='noRDD'>Give density-independent reproduction rate</h2><span id='topic+noRDD'></span>

<h3>Description</h3>

<p>Simply returns its <code>rdi</code> argument.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>noRDD(rdi, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="noRDD_+3A_rdi">rdi</code></td>
<td>
<p>Vector of density-independent reproduction rates
<code class="reqn">R_{di}</code> for all species.</p>
</td></tr>
<tr><td><code id="noRDD_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector of density-dependent reproduction rates.
</p>


<h3>See Also</h3>

<p>Other functions calculating density-dependent reproduction rate: 
<code><a href="#topic+BevertonHoltRDD">BevertonHoltRDD</a>()</code>,
<code><a href="#topic+RickerRDD">RickerRDD</a>()</code>,
<code><a href="#topic+SheperdRDD">SheperdRDD</a>()</code>,
<code><a href="#topic+constantEggRDI">constantEggRDI</a>()</code>,
<code><a href="#topic+constantRDD">constantRDD</a>()</code>
</p>

<hr>
<h2 id='NOther'>Time series of other components</h2><span id='topic+NOther'></span>

<h3>Description</h3>

<p>Fetch the simulation results for other components over time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NOther(sim)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NOther_+3A_sim">sim</code></td>
<td>
<p>A MizerSim object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list array (time x component) that stores the projected values for
other ecosystem components.
</p>

<hr>
<h2 id='NS_interaction'>Example interaction matrix for the North Sea example</h2><span id='topic+NS_interaction'></span>

<h3>Description</h3>

<p>The interaction coefficient between predator and prey species
in the North Sea.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NS_interaction
</code></pre>


<h3>Format</h3>

<p>A 12 x 12 matrix.
</p>


<h3>Source</h3>

<p>Blanchard et al.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>params &lt;- MizerParams(NS_species_params_gears,
                      interaction = NS_interaction)
</code></pre>

<hr>
<h2 id='NS_params'>Example MizerParams object for the North Sea example</h2><span id='topic+NS_params'></span>

<h3>Description</h3>

<p>A MizerParams object created from the <code>NS_species_params_gears</code> species
parameters and the <code>inter</code> interaction matrix together with an initial
condition corresponding to the steady state obtained from fishing with an
effort
<code>effort = c(Industrial = 0, Pelagic = 1, Beam = 0.5, Otter = 0.5)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NS_params
</code></pre>


<h3>Format</h3>

<p>A MizerParams object
</p>


<h3>Source</h3>

<p>Blanchard et al.
</p>


<h3>See Also</h3>

<p>Other example parameter objects: 
<code><a href="#topic+NS_sim">NS_sim</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
sim = project(NS_params, effort = c(Industrial = 0, Pelagic = 1, 
                                    Beam = 0.5, Otter = 0.5))
plot(sim)

</code></pre>

<hr>
<h2 id='NS_sim'>Example MizerSim object for the North Sea example</h2><span id='topic+NS_sim'></span>

<h3>Description</h3>

<p>A MizerSim object containing a simulation with historical fishing
mortalities from the North Sea, as created in the tutorial
&quot;A Multi-Species Model of the North Sea&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NS_sim
</code></pre>


<h3>Format</h3>

<p>A MizerSim object
</p>


<h3>Source</h3>

<p><a href="https://sizespectrum.org/mizer/articles/a_multispecies_model_of_the_north_sea.html">https://sizespectrum.org/mizer/articles/a_multispecies_model_of_the_north_sea.html</a>
</p>


<h3>See Also</h3>

<p>Other example parameter objects: 
<code><a href="#topic+NS_params">NS_params</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>plotBiomass(NS_sim)
</code></pre>

<hr>
<h2 id='NS_species_params'>Example species parameter set based on the North Sea</h2><span id='topic+NS_species_params'></span>

<h3>Description</h3>

<p>This data set is based on species in the North Sea (Blanchard et al.). It is
a data.frame that contains all the necessary information to be used by the
<code><a href="#topic+MizerParams">MizerParams()</a></code> constructor. As there is no gear column, each species is
assumed to be fished by a separate gear.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NS_species_params
</code></pre>


<h3>Format</h3>

<p>A data frame with 12 rows and 7 columns. Each row is a species.
</p>

<dl>
<dt>species</dt><dd><p>Name of the species</p>
</dd>
<dt>w_max</dt><dd><p>The size at which the population invests 100% of its income into
reproduction so that all growth stops.</p>
</dd>
<dt>w_mat</dt><dd><p>Size at maturity</p>
</dd>
<dt>beta</dt><dd><p>Size preference ratio</p>
</dd>
<dt>sigma</dt><dd><p>Width of the size-preference</p>
</dd>
<dt>R_max</dt><dd><p>Maximum reproduction rate</p>
</dd>
<dt>k_vb</dt><dd><p>The von Bertalanffy k parameter</p>
</dd>
<dt>w_inf</dt><dd><p>The von Bertalanffy asymptotic size</p>
</dd>
</dl>



<h3>Source</h3>

<p>Blanchard et al.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>params &lt;- MizerParams(NS_species_params)
</code></pre>

<hr>
<h2 id='NS_species_params_gears'>Example species parameter set based on the North Sea with different gears</h2><span id='topic+NS_species_params_gears'></span>

<h3>Description</h3>

<p>This data set is based on species in the North Sea (Blanchard et al.).
It is similar to the data set <code>NS_species_params</code> except that
this one has an additional column specifying the fishing gear that
operates on each species.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NS_species_params_gears
</code></pre>


<h3>Format</h3>

<p>A data frame with 12 rows and 8 columns. Each row is a species.
</p>

<dl>
<dt>species</dt><dd><p>Name of the species</p>
</dd>
<dt>w_max</dt><dd><p>The size at which the population invests 100% of its income into
reproduction so that all growth stops.</p>
</dd>
<dt>w_mat</dt><dd><p>Size at maturity</p>
</dd>
<dt>beta</dt><dd><p>Size preference ratio</p>
</dd>
<dt>sigma</dt><dd><p>Width of the size-preference</p>
</dd>
<dt>R_max</dt><dd><p>Maximum reproduction rate</p>
</dd>
<dt>k_vb</dt><dd><p>The von Bertalanffy k parameter</p>
</dd>
<dt>w_inf</dt><dd><p>The von Bertalanffy asymptotic size</p>
</dd>
<dt>gear</dt><dd><p>Name of the fishing gear</p>
</dd>
</dl>



<h3>Source</h3>

<p>Blanchard et al.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>params &lt;- MizerParams(NS_species_params_gears)
</code></pre>

<hr>
<h2 id='plot+2CMizerSim+2Cmissing-method'>Summary plot for <code>MizerSim</code> objects</h2><span id='topic+plot+2CMizerSim+2Cmissing-method'></span><span id='topic+plot+2CMizerParams+2Cmissing-method'></span>

<h3>Description</h3>

<p>After running a projection, produces 5 plots in the same window: feeding
level, abundance spectra, predation mortality and fishing mortality of each
species by size; and biomass of each species through time. This method just
uses the other plotting functions and puts them all in one window.
</p>
<p>Produces 3 plots in the same window: abundance spectra, feeding
level and predation mortality of each species through time. This method just
uses the other plotting functions and puts them all in one window.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'MizerSim,missing'
plot(x, y, ...)

## S4 method for signature 'MizerParams,missing'
plot(x, y, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot+2B2CMizerSim+2B2Cmissing-method_+3A_x">x</code></td>
<td>
<p>An object of class <a href="#topic+MizerSim-class">MizerSim</a></p>
</td></tr>
<tr><td><code id="plot+2B2CMizerSim+2B2Cmissing-method_+3A_y">y</code></td>
<td>
<p>Not used</p>
</td></tr>
<tr><td><code id="plot+2B2CMizerSim+2B2Cmissing-method_+3A_...">...</code></td>
<td>
<p>For additional arguments see the documentation for
<code><a href="#topic+plotBiomass">plotBiomass()</a></code>,
<code><a href="#topic+plotFeedingLevel">plotFeedingLevel()</a></code>,<code><a href="#topic+plotSpectra">plotSpectra()</a></code>,<code><a href="#topic+plotPredMort">plotPredMort()</a></code>
and <code><a href="#topic+plotFMort">plotFMort()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A viewport object
</p>
<p>A viewport object
</p>


<h3>See Also</h3>

<p><a href="#topic+plotting_functions">plotting_functions</a>
</p>
<p><a href="#topic+plotting_functions">plotting_functions</a>
</p>
<p>Other plotting functions: 
<code><a href="#topic+animateSpectra">animateSpectra</a>()</code>,
<code><a href="#topic+plotBiomass">plotBiomass</a>()</code>,
<code><a href="#topic+plotDiet">plotDiet</a>()</code>,
<code><a href="#topic+plotFMort">plotFMort</a>()</code>,
<code><a href="#topic+plotFeedingLevel">plotFeedingLevel</a>()</code>,
<code><a href="#topic+plotGrowthCurves">plotGrowthCurves</a>()</code>,
<code><a href="#topic+plotPredMort">plotPredMort</a>()</code>,
<code><a href="#topic+plotSpectra">plotSpectra</a>()</code>,
<code><a href="#topic+plotYield">plotYield</a>()</code>,
<code><a href="#topic+plotYieldGear">plotYieldGear</a>()</code>,
<code><a href="#topic+plotting_functions">plotting_functions</a></code>
</p>
<p>Other plotting functions: 
<code><a href="#topic+animateSpectra">animateSpectra</a>()</code>,
<code><a href="#topic+plotBiomass">plotBiomass</a>()</code>,
<code><a href="#topic+plotDiet">plotDiet</a>()</code>,
<code><a href="#topic+plotFMort">plotFMort</a>()</code>,
<code><a href="#topic+plotFeedingLevel">plotFeedingLevel</a>()</code>,
<code><a href="#topic+plotGrowthCurves">plotGrowthCurves</a>()</code>,
<code><a href="#topic+plotPredMort">plotPredMort</a>()</code>,
<code><a href="#topic+plotSpectra">plotSpectra</a>()</code>,
<code><a href="#topic+plotYield">plotYield</a>()</code>,
<code><a href="#topic+plotYieldGear">plotYieldGear</a>()</code>,
<code><a href="#topic+plotting_functions">plotting_functions</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
params &lt;-  NS_params
sim &lt;- project(params, effort=1, t_max=20, t_save = 2, progress_bar = FALSE)
plot(sim)
plot(sim, time_range = 10:20) # change time period for size-based plots
plot(sim, min_w = 10, max_w = 1000) # change size range for biomass plot


params &lt;-  NS_params
plot(params)
plot(params, min_w = 10, max_w = 1000) # change size range for biomass plot

</code></pre>

<hr>
<h2 id='plotBiomass'>Plot the biomass of species through time</h2><span id='topic+plotBiomass'></span><span id='topic+plotlyBiomass'></span>

<h3>Description</h3>

<p>After running a projection, the biomass of each species can be plotted
against time. The biomass is calculated within user defined size limits
(min_w, max_w, min_l, max_l, see <code><a href="#topic+getBiomass">getBiomass()</a></code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotBiomass(
  sim,
  species = NULL,
  start_time,
  end_time,
  y_ticks = 6,
  ylim = c(NA, NA),
  total = FALSE,
  background = TRUE,
  highlight = NULL,
  return_data = FALSE,
  ...
)

plotlyBiomass(
  sim,
  species = NULL,
  start_time,
  end_time,
  y_ticks = 6,
  ylim = c(NA, NA),
  total = FALSE,
  background = TRUE,
  highlight = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotBiomass_+3A_sim">sim</code></td>
<td>
<p>An object of class <a href="#topic+MizerSim-class">MizerSim</a></p>
</td></tr>
<tr><td><code id="plotBiomass_+3A_species">species</code></td>
<td>
<p>The species to be selected. Optional. By default all target
species are selected. A vector of species names, or a
numeric vector with the species indices, or a logical vector indicating for
each species whether it is to be selected (TRUE) or not.</p>
</td></tr>
<tr><td><code id="plotBiomass_+3A_start_time">start_time</code></td>
<td>
<p>The first time to be plotted. Default is the beginning
of the time series.</p>
</td></tr>
<tr><td><code id="plotBiomass_+3A_end_time">end_time</code></td>
<td>
<p>The last time to be plotted. Default is the end of the
time series.</p>
</td></tr>
<tr><td><code id="plotBiomass_+3A_y_ticks">y_ticks</code></td>
<td>
<p>The approximate number of ticks desired on the y axis</p>
</td></tr>
<tr><td><code id="plotBiomass_+3A_ylim">ylim</code></td>
<td>
<p>A numeric vector of length two providing lower and upper limits
for the y axis. Use NA to refer to the existing minimum or maximum. Any
values below 1e-20 are always cut off.</p>
</td></tr>
<tr><td><code id="plotBiomass_+3A_total">total</code></td>
<td>
<p>A boolean value that determines whether the total biomass from
all species is plotted as well. Default is FALSE.</p>
</td></tr>
<tr><td><code id="plotBiomass_+3A_background">background</code></td>
<td>
<p>A boolean value that determines whether background species
are included. Ignored if the model does not contain background species.
Default is TRUE.</p>
</td></tr>
<tr><td><code id="plotBiomass_+3A_highlight">highlight</code></td>
<td>
<p>Name or vector of names of the species to be highlighted.</p>
</td></tr>
<tr><td><code id="plotBiomass_+3A_return_data">return_data</code></td>
<td>
<p>A boolean value that determines whether the formatted data
used for the plot is returned instead of the plot itself. Default value is FALSE</p>
</td></tr>
<tr><td><code id="plotBiomass_+3A_...">...</code></td>
<td>

<p>Arguments passed on to <code><a href="#topic+get_size_range_array">get_size_range_array</a></code>
</p>

<dl>
<dt><code>min_w</code></dt><dd><p>Smallest weight in size range. Defaults to smallest weight in
the model.</p>
</dd>
<dt><code>max_w</code></dt><dd><p>Largest weight in size range. Defaults to largest weight in the
model.</p>
</dd>
<dt><code>min_l</code></dt><dd><p>Smallest length in size range. If supplied, this takes
precedence over <code>min_w</code>.</p>
</dd>
<dt><code>max_l</code></dt><dd><p>Largest length in size range. If supplied, this takes precedence
over <code>max_w</code>.</p>
</dd>
</dl>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot2 object, unless <code>return_data = TRUE</code>, in which case a data
frame with the four variables 'Year', 'Biomass', 'Species', 'Legend' is
returned.
</p>


<h3>See Also</h3>

<p><a href="#topic+plotting_functions">plotting_functions</a>, <code><a href="#topic+getBiomass">getBiomass()</a></code>
</p>
<p>Other plotting functions: 
<code><a href="#topic+animateSpectra">animateSpectra</a>()</code>,
<code><a href="#topic+plot+2CMizerSim+2Cmissing-method">plot,MizerSim,missing-method</a></code>,
<code><a href="#topic+plotDiet">plotDiet</a>()</code>,
<code><a href="#topic+plotFMort">plotFMort</a>()</code>,
<code><a href="#topic+plotFeedingLevel">plotFeedingLevel</a>()</code>,
<code><a href="#topic+plotGrowthCurves">plotGrowthCurves</a>()</code>,
<code><a href="#topic+plotPredMort">plotPredMort</a>()</code>,
<code><a href="#topic+plotSpectra">plotSpectra</a>()</code>,
<code><a href="#topic+plotYield">plotYield</a>()</code>,
<code><a href="#topic+plotYieldGear">plotYieldGear</a>()</code>,
<code><a href="#topic+plotting_functions">plotting_functions</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
plotBiomass(NS_sim)
plotBiomass(NS_sim, species = c("Sandeel", "Herring"), total = TRUE)
plotBiomass(NS_sim, start_time = 1980, end_time = 1990)

# Returning the data frame
fr &lt;- plotBiomass(NS_sim, return_data = TRUE)
str(fr)

</code></pre>

<hr>
<h2 id='plotBiomassObservedVsModel'>Plotting observed vs. model biomass data</h2><span id='topic+plotBiomassObservedVsModel'></span><span id='topic+plotlyBiomassObservedVsModel'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
If biomass observations are available for at least some species via the
<code>biomass_observed</code> column in the species parameter data frame, this function
plots the biomass of each species in the model against the observed
biomasses. When called with a MizerSim object, the plot will use the model
biomasses predicted for the final time step in the simulation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotBiomassObservedVsModel(
  object,
  species = NULL,
  ratio = FALSE,
  log_scale = TRUE,
  return_data = FALSE,
  labels = TRUE,
  show_unobserved = FALSE
)

plotlyBiomassObservedVsModel(
  object,
  species = NULL,
  ratio = FALSE,
  log_scale = TRUE,
  return_data = FALSE,
  show_unobserved = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotBiomassObservedVsModel_+3A_object">object</code></td>
<td>
<p>An object of class <a href="#topic+MizerParams-class">MizerParams</a> or
<a href="#topic+MizerSim-class">MizerSim</a>.</p>
</td></tr>
<tr><td><code id="plotBiomassObservedVsModel_+3A_species">species</code></td>
<td>
<p>The species to be included. Optional. By default all observed
biomasses will be included. A vector of species names, or a numeric vector
with the species indices, or a logical vector indicating for each species
whether it is to be included (TRUE) or not.</p>
</td></tr>
<tr><td><code id="plotBiomassObservedVsModel_+3A_ratio">ratio</code></td>
<td>
<p>Whether to plot model biomass vs. observed biomass (FALSE) or
the ratio of model : observed biomass (TRUE). Default is FALSE.</p>
</td></tr>
<tr><td><code id="plotBiomassObservedVsModel_+3A_log_scale">log_scale</code></td>
<td>
<p>Whether to plot on the log10 scale (TRUE) or not (FALSE).
For the non-ratio plot this applies for both axes, for the ratio plot only
the x-axis is on the log10 scale. Default is TRUE.</p>
</td></tr>
<tr><td><code id="plotBiomassObservedVsModel_+3A_return_data">return_data</code></td>
<td>
<p>Whether to return the data frame for the plot (TRUE) or
not (FALSE). Default is FALSE.</p>
</td></tr>
<tr><td><code id="plotBiomassObservedVsModel_+3A_labels">labels</code></td>
<td>
<p>Whether to show text labels for each species (TRUE) or not
(FALSE). Default is TRUE.</p>
</td></tr>
<tr><td><code id="plotBiomassObservedVsModel_+3A_show_unobserved">show_unobserved</code></td>
<td>
<p>Whether to include also species for which no
biomass observation is available. If TRUE, these species will be
shown as if their observed biomass was equal to the model biomass.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Before you can use this function you will need to have added a
<code>biomass_observed</code> column to your model which gives the observed biomass in
grams.  For species for which you have no observed biomass, you should set
the value in the <code>biomass_observed</code> column to 0 or NA.
</p>
<p>Biomass observations usually only include individuals above a certain size.
This size should be specified in a <code>biomass_cutoff</code> column of the species
parameter data frame. If this is missing, it is assumed that all sizes are
included in the observed biomass, i.e., it includes larval biomass.
</p>
<p>The total relative error is shown in the caption of the plot, calculated by
</p>
<p style="text-align: center;"><code class="reqn">TRE = \sum_i|1-\rm{ratio_i}|</code>
</p>
<p> where
<code class="reqn">\rm{ratio_i}</code> is the ratio of model biomass / observed
biomass for species i.
</p>


<h3>Value</h3>

<p>A ggplot2 object with the plot of model biomass by species compared
to observed biomass. If <code>return_data = TRUE</code>, the data frame used to
create the plot is returned instead of the plot.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create an example
params &lt;- NS_params
species_params(params)$biomass_observed &lt;-
    c(0.8, 61, 12, 35, 1.6, NA, 10, 7.6, 135, 60, 30, NA)
species_params(params)$biomass_cutoff &lt;- 10
params &lt;- calibrateBiomass(params)

# Plot with default options
plotBiomassObservedVsModel(params)

# Plot including also species without observations
plotBiomassObservedVsModel(params, show_unobserved = TRUE)

# Show the ratio instead
plotBiomassObservedVsModel(params, ratio = TRUE)
</code></pre>

<hr>
<h2 id='plotDataFrame'>Make a plot from a data frame</h2><span id='topic+plotDataFrame'></span>

<h3>Description</h3>

<p>This is used internally by most plotting functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotDataFrame(
  frame,
  params,
  style = "line",
  xlab = waiver(),
  ylab = waiver(),
  xtrans = "identity",
  ytrans = "identity",
  y_ticks = 6,
  highlight = NULL,
  legend_var = NULL,
  wrap_var = NULL,
  wrap_scale = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotDataFrame_+3A_frame">frame</code></td>
<td>
<p>A data frame with at least three variables.
The first three variables are used, in that order, as:
</p>

<ol>
<li><p> Variable to be plotted on x-axis
</p>
</li>
<li><p> Variable to be plotted on y-axis
</p>
</li>
<li><p> Grouping variable
</p>
</li></ol>
</td></tr>
<tr><td><code id="plotDataFrame_+3A_params">params</code></td>
<td>
<p>A MizerParams object, which is used for the line colours and
line types.</p>
</td></tr>
<tr><td><code id="plotDataFrame_+3A_style">style</code></td>
<td>
<p>The style of the plot. Available options are &quot;line' for geom_line
and &quot;area&quot; for geom_area. Default is &quot;line&quot;.</p>
</td></tr>
<tr><td><code id="plotDataFrame_+3A_xlab">xlab</code></td>
<td>
<p>Label for the x-axis</p>
</td></tr>
<tr><td><code id="plotDataFrame_+3A_ylab">ylab</code></td>
<td>
<p>Label for the y-axis</p>
</td></tr>
<tr><td><code id="plotDataFrame_+3A_xtrans">xtrans</code></td>
<td>
<p>Transformation for the x-axis. Often &quot;log10&quot; may be useful
instead of the default of &quot;identity&quot;.</p>
</td></tr>
<tr><td><code id="plotDataFrame_+3A_ytrans">ytrans</code></td>
<td>
<p>Transformation for the y-axis.</p>
</td></tr>
<tr><td><code id="plotDataFrame_+3A_y_ticks">y_ticks</code></td>
<td>
<p>The approximate number of ticks desired on the y axis</p>
</td></tr>
<tr><td><code id="plotDataFrame_+3A_highlight">highlight</code></td>
<td>
<p>Name or vector of names of the species to be highlighted.</p>
</td></tr>
<tr><td><code id="plotDataFrame_+3A_legend_var">legend_var</code></td>
<td>
<p>The name of the variable that should be used in the legend
and to determine the line style. If NULL then the grouping variable is
used for this purpose.</p>
</td></tr>
<tr><td><code id="plotDataFrame_+3A_wrap_var">wrap_var</code></td>
<td>
<p>Optional. The name of the variable that should be used for
creating wrapped facets.</p>
</td></tr>
<tr><td><code id="plotDataFrame_+3A_wrap_scale">wrap_scale</code></td>
<td>
<p>Optional. Used to pass the scales argument to facet_wrap().</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot2 object
</p>

<hr>
<h2 id='plotDiet'>Plot diet, resolved by prey species, as function of predator at size.</h2><span id='topic+plotDiet'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a> Plots the proportions with which each
prey species contributes to the total biomass consumed by the specified
predator species, as a function of the predator's size. These proportions are
obtained with <code>getDiet()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotDiet(object, species = NULL, return_data = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotDiet_+3A_object">object</code></td>
<td>
<p>An object of class <a href="#topic+MizerSim-class">MizerSim</a> or
<a href="#topic+MizerParams-class">MizerParams</a>.</p>
</td></tr>
<tr><td><code id="plotDiet_+3A_species">species</code></td>
<td>
<p>The species to be selected. Optional. By default all target
species are selected. A vector of species names, or a
numeric vector with the species indices, or a logical vector indicating for
each species whether it is to be selected (TRUE) or not.</p>
</td></tr>
<tr><td><code id="plotDiet_+3A_return_data">return_data</code></td>
<td>
<p>A boolean value that determines whether the formatted data
used for the plot is returned instead of the plot itself. Default value is FALSE</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Prey species that contribute less than 1 permille to the diet are suppressed
in the plot.
</p>
<p>If more than one predator species is selected, then the plot contains one
facet for each species.
</p>


<h3>Value</h3>

<p>A ggplot2 object, unless <code>return_data = TRUE</code>, in which case a data
frame with the four variables 'Predator', 'w', 'Proportion', 'Prey' is
returned.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+getDiet">getDiet()</a></code>
</p>
<p>Other plotting functions: 
<code><a href="#topic+animateSpectra">animateSpectra</a>()</code>,
<code><a href="#topic+plot+2CMizerSim+2Cmissing-method">plot,MizerSim,missing-method</a></code>,
<code><a href="#topic+plotBiomass">plotBiomass</a>()</code>,
<code><a href="#topic+plotFMort">plotFMort</a>()</code>,
<code><a href="#topic+plotFeedingLevel">plotFeedingLevel</a>()</code>,
<code><a href="#topic+plotGrowthCurves">plotGrowthCurves</a>()</code>,
<code><a href="#topic+plotPredMort">plotPredMort</a>()</code>,
<code><a href="#topic+plotSpectra">plotSpectra</a>()</code>,
<code><a href="#topic+plotYield">plotYield</a>()</code>,
<code><a href="#topic+plotYieldGear">plotYieldGear</a>()</code>,
<code><a href="#topic+plotting_functions">plotting_functions</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
plotDiet(NS_params, species = "Cod")
plotDiet(NS_params, species = 5:9)

# Returning the data frame
fr &lt;- plotDiet(NS_params, species = "Cod", return_data = TRUE)
str(fr)

</code></pre>

<hr>
<h2 id='plotFeedingLevel'>Plot the feeding level of species by size</h2><span id='topic+plotFeedingLevel'></span><span id='topic+plotlyFeedingLevel'></span>

<h3>Description</h3>

<p>After running a projection, plot the feeding level of each species by size.
The feeding level is averaged over the specified time range (a single value
for the time range can be used).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotFeedingLevel(
  object,
  species = NULL,
  time_range,
  highlight = NULL,
  all.sizes = FALSE,
  include_critical = FALSE,
  return_data = FALSE,
  ...
)

plotlyFeedingLevel(
  object,
  species = NULL,
  time_range,
  highlight = NULL,
  include_critical,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotFeedingLevel_+3A_object">object</code></td>
<td>
<p>An object of class <a href="#topic+MizerSim-class">MizerSim</a> or
<a href="#topic+MizerParams-class">MizerParams</a>.</p>
</td></tr>
<tr><td><code id="plotFeedingLevel_+3A_species">species</code></td>
<td>
<p>The species to be selected. Optional. By default all target
species are selected. A vector of species names, or a
numeric vector with the species indices, or a logical vector indicating for
each species whether it is to be selected (TRUE) or not.</p>
</td></tr>
<tr><td><code id="plotFeedingLevel_+3A_time_range">time_range</code></td>
<td>
<p>The time range (either a vector of values, a vector of min
and max time, or a single value) to average the abundances over. Default is
the final time step. Ignored when called with a <a href="#topic+MizerParams-class">MizerParams</a>
object.</p>
</td></tr>
<tr><td><code id="plotFeedingLevel_+3A_highlight">highlight</code></td>
<td>
<p>Name or vector of names of the species to be highlighted.</p>
</td></tr>
<tr><td><code id="plotFeedingLevel_+3A_all.sizes">all.sizes</code></td>
<td>
<p>If TRUE, then feeding level is plotted also for sizes
outside a species' size range. Default FALSE.</p>
</td></tr>
<tr><td><code id="plotFeedingLevel_+3A_include_critical">include_critical</code></td>
<td>
<p>If TRUE, then the critical feeding level is also
plotted. Default FALSE.</p>
</td></tr>
<tr><td><code id="plotFeedingLevel_+3A_return_data">return_data</code></td>
<td>
<p>A boolean value that determines whether the formatted data
used for the plot is returned instead of the plot itself. Default value is FALSE</p>
</td></tr>
<tr><td><code id="plotFeedingLevel_+3A_...">...</code></td>
<td>
<p>Other arguments (currently unused)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When called with a <a href="#topic+MizerSim-class">MizerSim</a> object, the feeding level is averaged
over the specified time range (a single value for the time range can be used
to plot a single time step). When called with a <a href="#topic+MizerParams-class">MizerParams</a>
object the initial feeding level is plotted.
</p>
<p>If <code>include_critical = TRUE</code> then the critical feeding level (the feeding
level at which the intake just covers the metabolic cost) is also plotted,
with a thinner line. This line should always stay below the line of the
actual feeding level, because the species would stop growing at any point
where the feeding level drops to the critical feeding level.
</p>


<h3>Value</h3>

<p>A ggplot2 object, unless <code>return_data = TRUE</code>, in which case a data
frame with the variables 'w', 'value' and 'Species' is returned. If also
<code>include_critical = TRUE</code> then the data frame contains a fourth variable
'Type' that distinguishes between 'actual' and 'critical' feeding level.
</p>


<h3>See Also</h3>

<p><a href="#topic+plotting_functions">plotting_functions</a>, <code><a href="#topic+getFeedingLevel">getFeedingLevel()</a></code>
</p>
<p>Other plotting functions: 
<code><a href="#topic+animateSpectra">animateSpectra</a>()</code>,
<code><a href="#topic+plot+2CMizerSim+2Cmissing-method">plot,MizerSim,missing-method</a></code>,
<code><a href="#topic+plotBiomass">plotBiomass</a>()</code>,
<code><a href="#topic+plotDiet">plotDiet</a>()</code>,
<code><a href="#topic+plotFMort">plotFMort</a>()</code>,
<code><a href="#topic+plotGrowthCurves">plotGrowthCurves</a>()</code>,
<code><a href="#topic+plotPredMort">plotPredMort</a>()</code>,
<code><a href="#topic+plotSpectra">plotSpectra</a>()</code>,
<code><a href="#topic+plotYield">plotYield</a>()</code>,
<code><a href="#topic+plotYieldGear">plotYieldGear</a>()</code>,
<code><a href="#topic+plotting_functions">plotting_functions</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
params &lt;-  NS_params
sim &lt;- project(params, effort=1, t_max=20, t_save = 2, progress_bar = FALSE)
plotFeedingLevel(sim)
plotFeedingLevel(sim, time_range = 10:20, species = c("Cod", "Herring"),
                 include_critical = TRUE)

# Returning the data frame
fr &lt;- plotFeedingLevel(sim, return_data = TRUE)
str(fr)

</code></pre>

<hr>
<h2 id='plotFMort'>Plot total fishing mortality of each species by size</h2><span id='topic+plotFMort'></span><span id='topic+plotlyFMort'></span>

<h3>Description</h3>

<p>After running a projection, plot the total fishing mortality of each species
by size. The total fishing mortality is averaged over the specified time
range (a single value for the time range can be used to plot a single time
step).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotFMort(
  object,
  species = NULL,
  time_range,
  all.sizes = FALSE,
  highlight = NULL,
  return_data = FALSE,
  ...
)

plotlyFMort(object, species = NULL, time_range, highlight = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotFMort_+3A_object">object</code></td>
<td>
<p>An object of class <a href="#topic+MizerSim-class">MizerSim</a> or
<a href="#topic+MizerParams-class">MizerParams</a>.</p>
</td></tr>
<tr><td><code id="plotFMort_+3A_species">species</code></td>
<td>
<p>The species to be selected. Optional. By default all target
species are selected. A vector of species names, or a
numeric vector with the species indices, or a logical vector indicating for
each species whether it is to be selected (TRUE) or not.</p>
</td></tr>
<tr><td><code id="plotFMort_+3A_time_range">time_range</code></td>
<td>
<p>The time range (either a vector of values, a vector of min
and max time, or a single value) to average the abundances over. Default is
the final time step. Ignored when called with a <a href="#topic+MizerParams-class">MizerParams</a>
object.</p>
</td></tr>
<tr><td><code id="plotFMort_+3A_all.sizes">all.sizes</code></td>
<td>
<p>If TRUE, then fishing mortality is plotted also for sizes
outside a species' size range. Default FALSE.</p>
</td></tr>
<tr><td><code id="plotFMort_+3A_highlight">highlight</code></td>
<td>
<p>Name or vector of names of the species to be highlighted.</p>
</td></tr>
<tr><td><code id="plotFMort_+3A_return_data">return_data</code></td>
<td>
<p>A boolean value that determines whether the formatted data
used for the plot is returned instead of the plot itself. Default value is FALSE</p>
</td></tr>
<tr><td><code id="plotFMort_+3A_...">...</code></td>
<td>
<p>Other arguments (currently unused)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot2 object, unless <code>return_data = TRUE</code>, in which case a data
frame with the three variables 'w', 'value', 'Species' is returned.
</p>


<h3>See Also</h3>

<p><a href="#topic+plotting_functions">plotting_functions</a>, <code><a href="#topic+getFMort">getFMort()</a></code>
</p>
<p>Other plotting functions: 
<code><a href="#topic+animateSpectra">animateSpectra</a>()</code>,
<code><a href="#topic+plot+2CMizerSim+2Cmissing-method">plot,MizerSim,missing-method</a></code>,
<code><a href="#topic+plotBiomass">plotBiomass</a>()</code>,
<code><a href="#topic+plotDiet">plotDiet</a>()</code>,
<code><a href="#topic+plotFeedingLevel">plotFeedingLevel</a>()</code>,
<code><a href="#topic+plotGrowthCurves">plotGrowthCurves</a>()</code>,
<code><a href="#topic+plotPredMort">plotPredMort</a>()</code>,
<code><a href="#topic+plotSpectra">plotSpectra</a>()</code>,
<code><a href="#topic+plotYield">plotYield</a>()</code>,
<code><a href="#topic+plotYieldGear">plotYieldGear</a>()</code>,
<code><a href="#topic+plotting_functions">plotting_functions</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
params &lt;-  NS_params
sim &lt;- project(params, effort=1, t_max=20, t_save = 2, progress_bar = FALSE)
plotFMort(sim)
plotFMort(sim, highlight = c("Cod", "Haddock"))
 
# Returning the data frame
fr &lt;- plotFMort(sim, return_data = TRUE)
str(fr)

</code></pre>

<hr>
<h2 id='plotGrowthCurves'>Plot growth curves</h2><span id='topic+plotGrowthCurves'></span><span id='topic+plotlyGrowthCurves'></span>

<h3>Description</h3>

<p>The growth curves represent the average age of all the living fish of a
species as a function of their size. So it would be natural to plot size
on the x-axis. But to follow the usual convention from age-based models, we
plot size on the y-axis and age on the x-axis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotGrowthCurves(
  object,
  species = NULL,
  max_age = 20,
  percentage = FALSE,
  species_panel = FALSE,
  highlight = NULL,
  size_at_age = NULL,
  return_data = FALSE,
  ...
)

plotlyGrowthCurves(
  object,
  species = NULL,
  max_age = 20,
  percentage = FALSE,
  species_panel = FALSE,
  highlight = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotGrowthCurves_+3A_object">object</code></td>
<td>
<p>MizerSim or MizerParams object. If given a
<a href="#topic+MizerSim-class">MizerSim</a> object, uses the growth rates at the final time of a
simulation to calculate the size at age. If given a
<a href="#topic+MizerParams-class">MizerParams</a> object, uses the initial growth rates instead.</p>
</td></tr>
<tr><td><code id="plotGrowthCurves_+3A_species">species</code></td>
<td>
<p>The species to be selected. Optional. By default all target
species are selected. A vector of species names, or a
numeric vector with the species indices, or a logical vector indicating for
each species whether it is to be selected (TRUE) or not.</p>
</td></tr>
<tr><td><code id="plotGrowthCurves_+3A_max_age">max_age</code></td>
<td>
<p>The age up to which to run the growth curve. Default is 20.</p>
</td></tr>
<tr><td><code id="plotGrowthCurves_+3A_percentage">percentage</code></td>
<td>
<p>Boolean value. If TRUE, the size is given as a percentage
of the maximal size.</p>
</td></tr>
<tr><td><code id="plotGrowthCurves_+3A_species_panel">species_panel</code></td>
<td>
<p>If TRUE (default), and <code>percentage = FALSE</code>, display all
species as facets. Otherwise puts all species into a single panel.</p>
</td></tr>
<tr><td><code id="plotGrowthCurves_+3A_highlight">highlight</code></td>
<td>
<p>Name or vector of names of the species to be highlighted.</p>
</td></tr>
<tr><td><code id="plotGrowthCurves_+3A_size_at_age">size_at_age</code></td>
<td>
<p>A data frame with observed size at age data to be plotted
on top of growth curve graphs. Should contain columns <code>species</code> (species
name as used in the model), <code>age</code> (in years) and either <code>weight</code> (in grams)
or <code>length</code> (in cm). If both <code>weight</code> and <code>length</code> are provided, only
<code>weight</code> is used.</p>
</td></tr>
<tr><td><code id="plotGrowthCurves_+3A_return_data">return_data</code></td>
<td>
<p>A boolean value that determines whether the formatted data
used for the plot is returned instead of the plot itself. Default value is FALSE</p>
</td></tr>
<tr><td><code id="plotGrowthCurves_+3A_...">...</code></td>
<td>
<p>Other arguments (currently unused)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When the growth curve for only a single species is plotted, horizontal lines
are included that indicate the maturity size and the maximum size for that
species, as well as a vertical line indicating the maturity age.
</p>
<p>If size at age data is passed via the <code>size_at_age</code> argument, this is plotted
on top of the growth curve. When comparing this to the growth curves, you
need to remember that the growth curves should only represent the average
age at each size. So a scatter in the x-direction around the curve is to be
expected.
</p>
<p>For legacy reasons, if the species parameters contain the variables <code>a</code> and
<code>b</code> for length to weight conversion and the von Bertalanffy parameter <code>k_vb</code>,
<code>w_inf</code> (and optionally <code>t0</code>), then the von Bertalanffy growth curve is
superimposed in black. This was implemented before we understood that the von
Bertalanffy curves (which approximates the average length at each age) should
not be compared to the mizer growth curves (which approximate the average age
at each length).
</p>


<h3>Value</h3>

<p>A ggplot2 object
</p>


<h3>See Also</h3>

<p><a href="#topic+plotting_functions">plotting_functions</a>
</p>
<p>Other plotting functions: 
<code><a href="#topic+animateSpectra">animateSpectra</a>()</code>,
<code><a href="#topic+plot+2CMizerSim+2Cmissing-method">plot,MizerSim,missing-method</a></code>,
<code><a href="#topic+plotBiomass">plotBiomass</a>()</code>,
<code><a href="#topic+plotDiet">plotDiet</a>()</code>,
<code><a href="#topic+plotFMort">plotFMort</a>()</code>,
<code><a href="#topic+plotFeedingLevel">plotFeedingLevel</a>()</code>,
<code><a href="#topic+plotPredMort">plotPredMort</a>()</code>,
<code><a href="#topic+plotSpectra">plotSpectra</a>()</code>,
<code><a href="#topic+plotYield">plotYield</a>()</code>,
<code><a href="#topic+plotYieldGear">plotYieldGear</a>()</code>,
<code><a href="#topic+plotting_functions">plotting_functions</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
params &lt;-  NS_params
sim &lt;- project(params, effort=1, t_max=20, t_save = 2, progress_bar = FALSE)
plotGrowthCurves(sim, percentage = TRUE)
plotGrowthCurves(sim, species = "Cod", max_age = 24)
plotGrowthCurves(sim, species_panel = TRUE)

# Returning the data frame
fr &lt;- plotGrowthCurves(sim, return_data = TRUE)
str(fr)

</code></pre>

<hr>
<h2 id='plotM2'>Alias for <code>plotPredMort()</code></h2><span id='topic+plotM2'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
An alias provided for backward compatibility with mizer version &lt;= 1.0
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotM2(
  object,
  species = NULL,
  time_range,
  all.sizes = FALSE,
  highlight = NULL,
  return_data = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotM2_+3A_object">object</code></td>
<td>
<p>An object of class <a href="#topic+MizerSim-class">MizerSim</a> or
<a href="#topic+MizerParams-class">MizerParams</a>.</p>
</td></tr>
<tr><td><code id="plotM2_+3A_species">species</code></td>
<td>
<p>The species to be selected. Optional. By default all target
species are selected. A vector of species names, or a
numeric vector with the species indices, or a logical vector indicating for
each species whether it is to be selected (TRUE) or not.</p>
</td></tr>
<tr><td><code id="plotM2_+3A_time_range">time_range</code></td>
<td>
<p>The time range (either a vector of values, a vector of min
and max time, or a single value) to average the abundances over. Default is
the final time step. Ignored when called with a <a href="#topic+MizerParams-class">MizerParams</a>
object.</p>
</td></tr>
<tr><td><code id="plotM2_+3A_all.sizes">all.sizes</code></td>
<td>
<p>If TRUE, then predation mortality is plotted also for sizes
outside a species' size range. Default FALSE.</p>
</td></tr>
<tr><td><code id="plotM2_+3A_highlight">highlight</code></td>
<td>
<p>Name or vector of names of the species to be highlighted.</p>
</td></tr>
<tr><td><code id="plotM2_+3A_return_data">return_data</code></td>
<td>
<p>A boolean value that determines whether the formatted data
used for the plot is returned instead of the plot itself. Default value is FALSE</p>
</td></tr>
<tr><td><code id="plotM2_+3A_...">...</code></td>
<td>
<p>Other arguments (currently unused)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot2 object, unless <code>return_data = TRUE</code>, in which case a data
frame with the three variables 'w', 'value', 'Species' is returned.
</p>


<h3>See Also</h3>

<p><a href="#topic+plotting_functions">plotting_functions</a>,  <code><a href="#topic+getPredMort">getPredMort()</a></code>
</p>
<p>Other plotting functions: 
<code><a href="#topic+animateSpectra">animateSpectra</a>()</code>,
<code><a href="#topic+plot+2CMizerSim+2Cmissing-method">plot,MizerSim,missing-method</a></code>,
<code><a href="#topic+plotBiomass">plotBiomass</a>()</code>,
<code><a href="#topic+plotDiet">plotDiet</a>()</code>,
<code><a href="#topic+plotFMort">plotFMort</a>()</code>,
<code><a href="#topic+plotFeedingLevel">plotFeedingLevel</a>()</code>,
<code><a href="#topic+plotGrowthCurves">plotGrowthCurves</a>()</code>,
<code><a href="#topic+plotSpectra">plotSpectra</a>()</code>,
<code><a href="#topic+plotYield">plotYield</a>()</code>,
<code><a href="#topic+plotYieldGear">plotYieldGear</a>()</code>,
<code><a href="#topic+plotting_functions">plotting_functions</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
params &lt;-  NS_params
sim &lt;- project(params, effort=1, t_max=20, t_save = 2, progress_bar = FALSE)
plotPredMort(sim)
plotPredMort(sim, time_range = 10:20)

# Returning the data frame
fr &lt;- plotPredMort(sim, return_data = TRUE)
str(fr)

</code></pre>

<hr>
<h2 id='plotPredMort'>Plot predation mortality rate of each species against size</h2><span id='topic+plotPredMort'></span><span id='topic+plotlyPredMort'></span>

<h3>Description</h3>

<p>After running a projection, plot the predation mortality rate of each species
by size. The mortality rate is averaged over the specified time range (a
single value for the time range can be used to plot a single time step).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotPredMort(
  object,
  species = NULL,
  time_range,
  all.sizes = FALSE,
  highlight = NULL,
  return_data = FALSE,
  ...
)

plotlyPredMort(object, species = NULL, time_range, highlight = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotPredMort_+3A_object">object</code></td>
<td>
<p>An object of class <a href="#topic+MizerSim-class">MizerSim</a> or
<a href="#topic+MizerParams-class">MizerParams</a>.</p>
</td></tr>
<tr><td><code id="plotPredMort_+3A_species">species</code></td>
<td>
<p>The species to be selected. Optional. By default all target
species are selected. A vector of species names, or a
numeric vector with the species indices, or a logical vector indicating for
each species whether it is to be selected (TRUE) or not.</p>
</td></tr>
<tr><td><code id="plotPredMort_+3A_time_range">time_range</code></td>
<td>
<p>The time range (either a vector of values, a vector of min
and max time, or a single value) to average the abundances over. Default is
the final time step. Ignored when called with a <a href="#topic+MizerParams-class">MizerParams</a>
object.</p>
</td></tr>
<tr><td><code id="plotPredMort_+3A_all.sizes">all.sizes</code></td>
<td>
<p>If TRUE, then predation mortality is plotted also for sizes
outside a species' size range. Default FALSE.</p>
</td></tr>
<tr><td><code id="plotPredMort_+3A_highlight">highlight</code></td>
<td>
<p>Name or vector of names of the species to be highlighted.</p>
</td></tr>
<tr><td><code id="plotPredMort_+3A_return_data">return_data</code></td>
<td>
<p>A boolean value that determines whether the formatted data
used for the plot is returned instead of the plot itself. Default value is FALSE</p>
</td></tr>
<tr><td><code id="plotPredMort_+3A_...">...</code></td>
<td>
<p>Other arguments (currently unused)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot2 object, unless <code>return_data = TRUE</code>, in which case a data
frame with the three variables 'w', 'value', 'Species' is returned.
</p>


<h3>See Also</h3>

<p><a href="#topic+plotting_functions">plotting_functions</a>,  <code><a href="#topic+getPredMort">getPredMort()</a></code>
</p>
<p>Other plotting functions: 
<code><a href="#topic+animateSpectra">animateSpectra</a>()</code>,
<code><a href="#topic+plot+2CMizerSim+2Cmissing-method">plot,MizerSim,missing-method</a></code>,
<code><a href="#topic+plotBiomass">plotBiomass</a>()</code>,
<code><a href="#topic+plotDiet">plotDiet</a>()</code>,
<code><a href="#topic+plotFMort">plotFMort</a>()</code>,
<code><a href="#topic+plotFeedingLevel">plotFeedingLevel</a>()</code>,
<code><a href="#topic+plotGrowthCurves">plotGrowthCurves</a>()</code>,
<code><a href="#topic+plotSpectra">plotSpectra</a>()</code>,
<code><a href="#topic+plotYield">plotYield</a>()</code>,
<code><a href="#topic+plotYieldGear">plotYieldGear</a>()</code>,
<code><a href="#topic+plotting_functions">plotting_functions</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
params &lt;-  NS_params
sim &lt;- project(params, effort=1, t_max=20, t_save = 2, progress_bar = FALSE)
plotPredMort(sim)
plotPredMort(sim, time_range = 10:20)

# Returning the data frame
fr &lt;- plotPredMort(sim, return_data = TRUE)
str(fr)

</code></pre>

<hr>
<h2 id='plotSpectra'>Plot the abundance spectra</h2><span id='topic+plotSpectra'></span><span id='topic+plotlySpectra'></span>

<h3>Description</h3>

<p>Plots the number density multiplied by a power of the weight, with the power
specified by the <code>power</code> argument.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotSpectra(
  object,
  species = NULL,
  time_range,
  geometric_mean = FALSE,
  wlim = c(NA, NA),
  ylim = c(NA, NA),
  power = 1,
  biomass = TRUE,
  total = FALSE,
  resource = TRUE,
  background = TRUE,
  highlight = NULL,
  return_data = FALSE,
  ...
)

plotlySpectra(
  object,
  species = NULL,
  time_range,
  geometric_mean = FALSE,
  wlim = c(NA, NA),
  ylim = c(NA, NA),
  power = 1,
  biomass = TRUE,
  total = FALSE,
  resource = TRUE,
  background = TRUE,
  highlight = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotSpectra_+3A_object">object</code></td>
<td>
<p>An object of class <a href="#topic+MizerSim-class">MizerSim</a> or
<a href="#topic+MizerParams-class">MizerParams</a>.</p>
</td></tr>
<tr><td><code id="plotSpectra_+3A_species">species</code></td>
<td>
<p>The species to be selected. Optional. By default all target
species are selected. A vector of species names, or a
numeric vector with the species indices, or a logical vector indicating for
each species whether it is to be selected (TRUE) or not.</p>
</td></tr>
<tr><td><code id="plotSpectra_+3A_time_range">time_range</code></td>
<td>
<p>The time range (either a vector of values, a vector of min
and max time, or a single value) to average the abundances over. Default is
the final time step. Ignored when called with a <a href="#topic+MizerParams-class">MizerParams</a>
object.</p>
</td></tr>
<tr><td><code id="plotSpectra_+3A_geometric_mean">geometric_mean</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
If TRUE then the average of the abundances over the
time range is a geometric mean instead of the default arithmetic mean.</p>
</td></tr>
<tr><td><code id="plotSpectra_+3A_wlim">wlim</code></td>
<td>
<p>A numeric vector of length two providing lower and upper limits
for the w axis. Use NA to refer to the existing minimum or maximum.</p>
</td></tr>
<tr><td><code id="plotSpectra_+3A_ylim">ylim</code></td>
<td>
<p>A numeric vector of length two providing lower and upper limits
for the y axis. Use NA to refer to the existing minimum or maximum. Any
values below 1e-20 are always cut off.</p>
</td></tr>
<tr><td><code id="plotSpectra_+3A_power">power</code></td>
<td>
<p>The abundance is plotted as the number density times the weight
raised to <code>power</code>. The default <code>power = 1</code> gives the biomass
density, whereas <code>power = 2</code> gives the biomass density with respect
to logarithmic size bins.</p>
</td></tr>
<tr><td><code id="plotSpectra_+3A_biomass">biomass</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
Only used if <code>power</code> argument is missing. Then
<code>biomass = TRUE</code> is equivalent to <code>power=1</code> and
<code>biomass = FALSE</code> is equivalent to <code>power=0</code></p>
</td></tr>
<tr><td><code id="plotSpectra_+3A_total">total</code></td>
<td>
<p>A boolean value that determines whether the total over all
species in the system is plotted as well. Note that even if the plot
only shows a selection of species, the total is including all species.
Default is FALSE.</p>
</td></tr>
<tr><td><code id="plotSpectra_+3A_resource">resource</code></td>
<td>
<p>A boolean value that determines whether resource is included.
Default is TRUE.</p>
</td></tr>
<tr><td><code id="plotSpectra_+3A_background">background</code></td>
<td>
<p>A boolean value that determines whether background species
are included. Ignored if the model does not contain background species.
Default is TRUE.</p>
</td></tr>
<tr><td><code id="plotSpectra_+3A_highlight">highlight</code></td>
<td>
<p>Name or vector of names of the species to be highlighted.</p>
</td></tr>
<tr><td><code id="plotSpectra_+3A_return_data">return_data</code></td>
<td>
<p>A boolean value that determines whether the formatted data
used for the plot is returned instead of the plot itself. Default value is FALSE</p>
</td></tr>
<tr><td><code id="plotSpectra_+3A_...">...</code></td>
<td>
<p>Other arguments (currently unused)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When called with a <a href="#topic+MizerSim-class">MizerSim</a> object, the abundance is averaged
over the specified time range (a single value for the time range can be used
to plot a single time step). When called with a <a href="#topic+MizerParams-class">MizerParams</a>
object the initial abundance is plotted.
</p>


<h3>Value</h3>

<p>A ggplot2 object, unless <code>return_data = TRUE</code>, in which case a data
frame with the four variables 'w', 'value', 'Species', 'Legend' is
returned.
</p>


<h3>See Also</h3>

<p><a href="#topic+plotting_functions">plotting_functions</a>
</p>
<p>Other plotting functions: 
<code><a href="#topic+animateSpectra">animateSpectra</a>()</code>,
<code><a href="#topic+plot+2CMizerSim+2Cmissing-method">plot,MizerSim,missing-method</a></code>,
<code><a href="#topic+plotBiomass">plotBiomass</a>()</code>,
<code><a href="#topic+plotDiet">plotDiet</a>()</code>,
<code><a href="#topic+plotFMort">plotFMort</a>()</code>,
<code><a href="#topic+plotFeedingLevel">plotFeedingLevel</a>()</code>,
<code><a href="#topic+plotGrowthCurves">plotGrowthCurves</a>()</code>,
<code><a href="#topic+plotPredMort">plotPredMort</a>()</code>,
<code><a href="#topic+plotYield">plotYield</a>()</code>,
<code><a href="#topic+plotYieldGear">plotYieldGear</a>()</code>,
<code><a href="#topic+plotting_functions">plotting_functions</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
params &lt;-  NS_params
sim &lt;- project(params, effort=1, t_max=20, t_save = 2, progress_bar = FALSE)
plotSpectra(sim)
plotSpectra(sim, wlim = c(1e-6, NA))
plotSpectra(sim, time_range = 10:20)
plotSpectra(sim, time_range = 10:20, power = 0)
plotSpectra(sim, species = c("Cod", "Herring"), power = 1)

# Returning the data frame
fr &lt;- plotSpectra(sim, return_data = TRUE)
str(fr)

</code></pre>

<hr>
<h2 id='plotting_functions'>Description of the plotting functions</h2><span id='topic+plotting_functions'></span>

<h3>Description</h3>

<p>Mizer provides a range of plotting functions for visualising the results
of running a simulation, stored in a MizerSim object, or the initial state
stored in a MizerParams object.
Every plotting function exists in two versions, <code>plotSomething</code> and
<code>plotlySomething</code>. The plotly version is more interactive but not
suitable for inclusion in documents.
</p>


<h3>Details</h3>

<p>This table shows the available plotting functions.
</p>

<table>
<tr>
 <td style="text-align: left;">
Plot </td><td style="text-align: left;"> Description </td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+plotBiomass">plotBiomass()</a></code> </td><td style="text-align: left;"> Plots the total biomass of each species through time. A time range to be plotted can be specified. The size range of the community can be specified in the same way as for <code><a href="#topic+getBiomass">getBiomass()</a></code>. </td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+plotSpectra">plotSpectra()</a></code> </td><td style="text-align: left;"> Plots the abundance (biomass or numbers) spectra of each species and the background community. It is possible to specify a minimum size which is useful for truncating the plot. </td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+plotFeedingLevel">plotFeedingLevel()</a></code> </td><td style="text-align: left;"> Plots the feeding level of each species against size. </td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+plotPredMort">plotPredMort()</a></code> </td><td style="text-align: left;"> Plots the predation mortality of each species against size. </td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+plotFMort">plotFMort()</a></code> </td><td style="text-align: left;"> Plots the total fishing mortality of each species against size. </td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+plotYield">plotYield()</a></code> </td><td style="text-align: left;"> Plots the total yield of each species across all fishing gears against time. </td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+plotYieldGear">plotYieldGear()</a></code> </td><td style="text-align: left;"> Plots the total yield of each species by gear against time. </td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+plotDiet">plotDiet()</a></code> </td><td style="text-align: left;"> Plots the diet composition at size for a given predator species. </td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+plotGrowthCurves">plotGrowthCurves()</a></code> </td><td style="text-align: left;"> Plots the size as a function of age. </td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="base.html#topic+plot">plot()</a></code> </td><td style="text-align: left;"> Produces 5 plots (<code><a href="#topic+plotFeedingLevel">plotFeedingLevel()</a></code>, <code><a href="#topic+plotBiomass">plotBiomass()</a></code>, <code><a href="#topic+plotPredMort">plotPredMort()</a></code>, <code><a href="#topic+plotFMort">plotFMort()</a></code> and <code><a href="#topic+plotSpectra">plotSpectra()</a></code>) in the same window. </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>These functions use the ggplot2 package and return the plot as a ggplot
object. This means that you can manipulate the plot further after its
creation using the ggplot grammar of graphics. The corresponding function
names with <code>plot</code> replaced by <code>plotly</code> produce interactive plots
with the help of the plotly package.
</p>
<p>While most plot functions take their data from a MizerSim object, some of
those that make plots representing data at a single time can also take their
data from the initial values in a MizerParams object.
</p>
<p>Where plots show results for species, the line colour and line type for each
species are specified by the <code>linecolour</code> and <code>linetype</code> slots in
the MizerParams object. These were either taken from a default palette
hard-coded into <code><a href="#topic+emptyParams">emptyParams()</a></code> or they were specified by the user
in the species parameters dataframe used to set up the MizerParams object.
The <code>linecolour</code> and <code>linetype</code> slots hold named vectors, named by
the species. They can be overwritten by the user at any time.
</p>
<p>Most plots allow the user to select to show only a subset of species,
specified as a vector in the <code>species</code> argument to the plot function.
</p>
<p>The ordering of the species in the legend is the same as the ordering in
the species parameter data frame.
</p>


<h3>See Also</h3>

<p><a href="#topic+summary_functions">summary_functions</a>, <a href="#topic+indicator_functions">indicator_functions</a>
</p>
<p>Other plotting functions: 
<code><a href="#topic+animateSpectra">animateSpectra</a>()</code>,
<code><a href="#topic+plot+2CMizerSim+2Cmissing-method">plot,MizerSim,missing-method</a></code>,
<code><a href="#topic+plotBiomass">plotBiomass</a>()</code>,
<code><a href="#topic+plotDiet">plotDiet</a>()</code>,
<code><a href="#topic+plotFMort">plotFMort</a>()</code>,
<code><a href="#topic+plotFeedingLevel">plotFeedingLevel</a>()</code>,
<code><a href="#topic+plotGrowthCurves">plotGrowthCurves</a>()</code>,
<code><a href="#topic+plotPredMort">plotPredMort</a>()</code>,
<code><a href="#topic+plotSpectra">plotSpectra</a>()</code>,
<code><a href="#topic+plotYield">plotYield</a>()</code>,
<code><a href="#topic+plotYieldGear">plotYieldGear</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
sim &lt;- NS_sim

# Some example plots
plotFeedingLevel(sim)

# Plotting only a subset of species
plotFeedingLevel(sim, species = c("Cod", "Herring"))

# Specifying new colours and linetypes for some species
sim@params@linetype["Cod"] &lt;- "dashed"
sim@params@linecolour["Cod"] &lt;- "red"
plotFeedingLevel(sim, species = c("Cod", "Herring"))

# Manipulating the plot
library(ggplot2)
p &lt;- plotFeedingLevel(sim)
p &lt;- p + geom_hline(aes(yintercept = 0.7))
p &lt;- p + theme_bw()
p

</code></pre>

<hr>
<h2 id='plotYield'>Plot the total yield of species through time</h2><span id='topic+plotYield'></span><span id='topic+plotlyYield'></span>

<h3>Description</h3>

<p>After running a projection, the total yield of each species across all
fishing gears can be plotted against time. The yield is obtained with
<code><a href="#topic+getYield">getYield()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotYield(
  sim,
  sim2,
  species = NULL,
  total = FALSE,
  log = TRUE,
  highlight = NULL,
  return_data = FALSE,
  ...
)

plotlyYield(
  sim,
  sim2,
  species = NULL,
  total = FALSE,
  log = TRUE,
  highlight = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotYield_+3A_sim">sim</code></td>
<td>
<p>An object of class <a href="#topic+MizerSim-class">MizerSim</a></p>
</td></tr>
<tr><td><code id="plotYield_+3A_sim2">sim2</code></td>
<td>
<p>An optional second object of class <a href="#topic+MizerSim-class">MizerSim</a>. If
this is provided its yields will be shown on the same plot in bolder lines.</p>
</td></tr>
<tr><td><code id="plotYield_+3A_species">species</code></td>
<td>
<p>The species to be selected. Optional. By default all target
species are selected. A vector of species names, or a
numeric vector with the species indices, or a logical vector indicating for
each species whether it is to be selected (TRUE) or not.</p>
</td></tr>
<tr><td><code id="plotYield_+3A_total">total</code></td>
<td>
<p>A boolean value that determines whether the total over all
species in the system is plotted as well. Note that even if the plot
only shows a selection of species, the total is including all species.
Default is FALSE.</p>
</td></tr>
<tr><td><code id="plotYield_+3A_log">log</code></td>
<td>
<p>Boolean whether yield should be plotted on a logarithmic axis.
Defaults to true.</p>
</td></tr>
<tr><td><code id="plotYield_+3A_highlight">highlight</code></td>
<td>
<p>Name or vector of names of the species to be highlighted.</p>
</td></tr>
<tr><td><code id="plotYield_+3A_return_data">return_data</code></td>
<td>
<p>A boolean value that determines whether the formatted data
used for the plot is returned instead of the plot itself. Default value is FALSE</p>
</td></tr>
<tr><td><code id="plotYield_+3A_...">...</code></td>
<td>
<p>Other arguments (currently unused)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot2 object, unless <code>return_data = TRUE</code>, in which case a data
frame with the three variables 'Year', 'Yield', 'Species' is returned.
</p>


<h3>See Also</h3>

<p><a href="#topic+plotting_functions">plotting_functions</a>,  <code><a href="#topic+getYield">getYield()</a></code>
</p>
<p>Other plotting functions: 
<code><a href="#topic+animateSpectra">animateSpectra</a>()</code>,
<code><a href="#topic+plot+2CMizerSim+2Cmissing-method">plot,MizerSim,missing-method</a></code>,
<code><a href="#topic+plotBiomass">plotBiomass</a>()</code>,
<code><a href="#topic+plotDiet">plotDiet</a>()</code>,
<code><a href="#topic+plotFMort">plotFMort</a>()</code>,
<code><a href="#topic+plotFeedingLevel">plotFeedingLevel</a>()</code>,
<code><a href="#topic+plotGrowthCurves">plotGrowthCurves</a>()</code>,
<code><a href="#topic+plotPredMort">plotPredMort</a>()</code>,
<code><a href="#topic+plotSpectra">plotSpectra</a>()</code>,
<code><a href="#topic+plotYieldGear">plotYieldGear</a>()</code>,
<code><a href="#topic+plotting_functions">plotting_functions</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
params &lt;- NS_params
sim &lt;- project(params, effort = 1, t_max = 20, t_save = 0.2, progress_bar = FALSE)
plotYield(sim)
plotYield(sim, species = c("Cod", "Herring"), total = TRUE)

# Comparing with yield from twice the effort
sim2 &lt;- project(params, effort=2, t_max=20, t_save = 0.2, progress_bar = FALSE)
plotYield(sim, sim2, species = c("Cod", "Herring"), log = FALSE)

# Returning the data frame
fr &lt;- plotYield(sim, return_data = TRUE)
str(fr)

</code></pre>

<hr>
<h2 id='plotYieldGear'>Plot the total yield of each species by gear through time</h2><span id='topic+plotYieldGear'></span><span id='topic+plotlyYieldGear'></span>

<h3>Description</h3>

<p>After running a projection, the total yield of each species by fishing gear
can be plotted against time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotYieldGear(
  sim,
  species = NULL,
  total = FALSE,
  highlight = NULL,
  return_data = FALSE,
  ...
)

plotlyYieldGear(sim, species = NULL, total = FALSE, highlight = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotYieldGear_+3A_sim">sim</code></td>
<td>
<p>An object of class <a href="#topic+MizerSim-class">MizerSim</a></p>
</td></tr>
<tr><td><code id="plotYieldGear_+3A_species">species</code></td>
<td>
<p>The species to be selected. Optional. By default all target
species are selected. A vector of species names, or a
numeric vector with the species indices, or a logical vector indicating for
each species whether it is to be selected (TRUE) or not.</p>
</td></tr>
<tr><td><code id="plotYieldGear_+3A_total">total</code></td>
<td>
<p>A boolean value that determines whether the total over all
species in the system is plotted as well. Note that even if the plot
only shows a selection of species, the total is including all species.
Default is FALSE.</p>
</td></tr>
<tr><td><code id="plotYieldGear_+3A_highlight">highlight</code></td>
<td>
<p>Name or vector of names of the species to be highlighted.</p>
</td></tr>
<tr><td><code id="plotYieldGear_+3A_return_data">return_data</code></td>
<td>
<p>A boolean value that determines whether the formatted data
used for the plot is returned instead of the plot itself. Default value is FALSE</p>
</td></tr>
<tr><td><code id="plotYieldGear_+3A_...">...</code></td>
<td>
<p>Other arguments (currently unused)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This plot is pretty easy to do by hand. It just
gets the biomass using the <code><a href="#topic+getYieldGear">getYieldGear()</a></code> method and plots using
the ggplot2 package. You can then fiddle about with colours and linetypes
etc. Just look at the source code for details.
</p>


<h3>Value</h3>

<p>A ggplot2 object, unless <code>return_data = TRUE</code>, in which case a data
frame with the four variables 'Year', 'Yield', 'Species' and 'Gear' is
returned.
</p>


<h3>See Also</h3>

<p><a href="#topic+plotting_functions">plotting_functions</a>,  <code><a href="#topic+getYieldGear">getYieldGear()</a></code>
</p>
<p>Other plotting functions: 
<code><a href="#topic+animateSpectra">animateSpectra</a>()</code>,
<code><a href="#topic+plot+2CMizerSim+2Cmissing-method">plot,MizerSim,missing-method</a></code>,
<code><a href="#topic+plotBiomass">plotBiomass</a>()</code>,
<code><a href="#topic+plotDiet">plotDiet</a>()</code>,
<code><a href="#topic+plotFMort">plotFMort</a>()</code>,
<code><a href="#topic+plotFeedingLevel">plotFeedingLevel</a>()</code>,
<code><a href="#topic+plotGrowthCurves">plotGrowthCurves</a>()</code>,
<code><a href="#topic+plotPredMort">plotPredMort</a>()</code>,
<code><a href="#topic+plotSpectra">plotSpectra</a>()</code>,
<code><a href="#topic+plotYield">plotYield</a>()</code>,
<code><a href="#topic+plotting_functions">plotting_functions</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
params &lt;-  NS_params
sim &lt;- project(params, effort=1, t_max=20, t_save = 0.2, progress_bar = FALSE)
plotYieldGear(sim)
plotYieldGear(sim, species = c("Cod", "Herring"), total = TRUE)

# Returning the data frame
fr &lt;- plotYieldGear(sim, return_data = TRUE)
str(fr)

</code></pre>

<hr>
<h2 id='plotYieldObservedVsModel'>Plotting observed vs. model yields</h2><span id='topic+plotYieldObservedVsModel'></span><span id='topic+plotlyYieldObservedVsModel'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
If yield observations are available for at least some species via the
<code>yield_observed</code> column in the species parameter data frame, this function
plots the yield of each species in the model against the observed
yields. When called with a MizerSim object, the plot will use the model
yields predicted for the final time step in the simulation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotYieldObservedVsModel(
  object,
  species = NULL,
  ratio = FALSE,
  log_scale = TRUE,
  return_data = FALSE,
  labels = TRUE,
  show_unobserved = FALSE
)

plotlyYieldObservedVsModel(
  object,
  species = NULL,
  ratio = FALSE,
  log_scale = TRUE,
  return_data = FALSE,
  show_unobserved = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotYieldObservedVsModel_+3A_object">object</code></td>
<td>
<p>An object of class <a href="#topic+MizerParams-class">MizerParams</a> or
<a href="#topic+MizerSim-class">MizerSim</a>.</p>
</td></tr>
<tr><td><code id="plotYieldObservedVsModel_+3A_species">species</code></td>
<td>
<p>The species to be included. Optional. By default all observed
yields will be included. A vector of species names, or a numeric vector
with the species indices, or a logical vector indicating for each species
whether it is to be included (TRUE) or not.</p>
</td></tr>
<tr><td><code id="plotYieldObservedVsModel_+3A_ratio">ratio</code></td>
<td>
<p>Whether to plot model yield vs. observed yield (FALSE) or
the ratio of model : observed yield (TRUE). Default is FALSE.</p>
</td></tr>
<tr><td><code id="plotYieldObservedVsModel_+3A_log_scale">log_scale</code></td>
<td>
<p>Whether to plot on the log10 scale (TRUE) or not (FALSE).
For the non-ratio plot this applies for both axes, for the ratio plot only
the x-axis is on the log10 scale. Default is TRUE.</p>
</td></tr>
<tr><td><code id="plotYieldObservedVsModel_+3A_return_data">return_data</code></td>
<td>
<p>Whether to return the data frame for the plot (TRUE) or
not (FALSE). Default is FALSE.</p>
</td></tr>
<tr><td><code id="plotYieldObservedVsModel_+3A_labels">labels</code></td>
<td>
<p>Whether to show text labels for each species (TRUE) or not
(FALSE). Default is TRUE.</p>
</td></tr>
<tr><td><code id="plotYieldObservedVsModel_+3A_show_unobserved">show_unobserved</code></td>
<td>
<p>Whether to include also species for which no
yield observation is available. If TRUE, these species will be
shown as if their observed yield was equal to the model yield.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Before you can use this function you will need to have added a
<code>yield_observed</code> column to your model which gives the observed yield in
grams per year.  For species for which you have no observed yield, you should set
the value in the <code>yield_observed</code> column to 0 or NA.
</p>
<p>The total relative error is shown in the caption of the plot, calculated by
</p>
<p style="text-align: center;"><code class="reqn">TRE = \sum_i|1-\rm{ratio_i}|</code>
</p>
<p> where
<code class="reqn">\rm{ratio_i}</code> is the ratio of model yield / observed
yield for species i.
</p>


<h3>Value</h3>

<p>A ggplot2 object with the plot of model yield by species compared
to observed yield. If <code>return_data = TRUE</code>, the data frame used to
create the plot is returned instead of the plot.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create an example
params &lt;- NS_params
species_params(params)$yield_observed &lt;-
    c(0.8, 61, 12, 35, 1.6, NA, 10, 7.6, 135, 60, 30, NA)
params &lt;- calibrateYield(params)

# Plot with default options
plotYieldObservedVsModel(params)

# Plot including also species without observations
plotYieldObservedVsModel(params, show_unobserved = TRUE)

# Show the ratio instead
plotYieldObservedVsModel(params, ratio = TRUE)
</code></pre>

<hr>
<h2 id='power_law_pred_kernel'>Power-law predation kernel</h2><span id='topic+power_law_pred_kernel'></span>

<h3>Description</h3>

<p>This predation kernel is a power-law, with sigmoidal cut-offs at large and
small predator/prey mass ratios.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>power_law_pred_kernel(
  ppmr,
  kernel_exp,
  kernel_l_l,
  kernel_u_l,
  kernel_l_r,
  kernel_u_r
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="power_law_pred_kernel_+3A_ppmr">ppmr</code></td>
<td>
<p>A vector of predator/prey size ratios at which to evaluate the
predation kernel.</p>
</td></tr>
<tr><td><code id="power_law_pred_kernel_+3A_kernel_exp">kernel_exp</code></td>
<td>
<p>The exponent of the power law</p>
</td></tr>
<tr><td><code id="power_law_pred_kernel_+3A_kernel_l_l">kernel_l_l</code></td>
<td>
<p>The location of the left, rising sigmoid</p>
</td></tr>
<tr><td><code id="power_law_pred_kernel_+3A_kernel_u_l">kernel_u_l</code></td>
<td>
<p>The shape of the left, rising sigmoid</p>
</td></tr>
<tr><td><code id="power_law_pred_kernel_+3A_kernel_l_r">kernel_l_r</code></td>
<td>
<p>The location of the right, falling sigmoid</p>
</td></tr>
<tr><td><code id="power_law_pred_kernel_+3A_kernel_u_r">kernel_u_r</code></td>
<td>
<p>The shape of the right, falling sigmoid</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The return value is calculated as
</p>
<p><code>
ppmr^kernel_exp /
  (1 + (exp(kernel_l_l) / ppmr)^kernel_u_l) /
  (1 + (ppmr / exp(kernel_l_r))^kernel_u_r) 
</code>
</p>
<p>The parameters need to be given as columns in the species parameter
dataframe.
</p>


<h3>Value</h3>

<p>A vector giving the value of the predation kernel at each of the
predator/prey mass ratios in the <code>ppmr</code> argument.
</p>


<h3>See Also</h3>

<p>Other predation kernel: 
<code><a href="#topic+box_pred_kernel">box_pred_kernel</a>()</code>,
<code><a href="#topic+lognormal_pred_kernel">lognormal_pred_kernel</a>()</code>,
<code><a href="#topic+truncated_lognormal_pred_kernel">truncated_lognormal_pred_kernel</a>()</code>
</p>

<hr>
<h2 id='project'>Project size spectrum forward in time</h2><span id='topic+project'></span>

<h3>Description</h3>

<p>Runs the size spectrum model simulation.
The function returns an object of type
<a href="#topic+MizerSim-class">MizerSim</a> that can then be explored with a range of
<a href="#topic+summary_functions">summary_functions</a>, <a href="#topic+indicator_functions">indicator_functions</a> and
<a href="#topic+plotting_functions">plotting_functions</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>project(
  object,
  effort,
  t_max = 100,
  dt = 0.1,
  t_save = 1,
  t_start = 0,
  initial_n,
  initial_n_pp,
  append = TRUE,
  progress_bar = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="project_+3A_object">object</code></td>
<td>
<p>Either a <a href="#topic+MizerParams-class">MizerParams</a> object or a
<a href="#topic+MizerSim-class">MizerSim</a> object (which contains a <code>MizerParams</code> object).</p>
</td></tr>
<tr><td><code id="project_+3A_effort">effort</code></td>
<td>
<p>The effort of each fishing gear through time. See notes below.</p>
</td></tr>
<tr><td><code id="project_+3A_t_max">t_max</code></td>
<td>
<p>The number of years the projection runs for. The default value
is 100. This argument is ignored if an array is used for the <code>effort</code>
argument. See notes below.</p>
</td></tr>
<tr><td><code id="project_+3A_dt">dt</code></td>
<td>
<p>Time step of the solver. The default value is 0.1.</p>
</td></tr>
<tr><td><code id="project_+3A_t_save">t_save</code></td>
<td>
<p>The frequency with which the output is stored. The default
value is 1. This argument is ignored if an array is used for the <code>effort</code>
argument. See notes below.</p>
</td></tr>
<tr><td><code id="project_+3A_t_start">t_start</code></td>
<td>
<p>The the year of the start of the simulation. The simulation
will cover the period from <code>t_start</code> to <code>t_start + t_max</code>.
Defaults to 0. Ignored if an array is used for the <code>effort</code>
argument or a <code>MizerSim</code> for the <code>object</code> argument.</p>
</td></tr>
<tr><td><code id="project_+3A_initial_n">initial_n</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a> The initial abundances of
species. Instead of using this argument you should set <code>initialN(params)</code>
to the desired value.</p>
</td></tr>
<tr><td><code id="project_+3A_initial_n_pp">initial_n_pp</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a> The initial abundances
of resource. Instead of using this argument you should set
<code>initialNResource(params)</code> to the desired value.</p>
</td></tr>
<tr><td><code id="project_+3A_append">append</code></td>
<td>
<p>A boolean that determines whether the new simulation results
are appended to the previous ones. Only relevant if <code>object</code> is a
<code>MizerSim</code> object. Default = TRUE.</p>
</td></tr>
<tr><td><code id="project_+3A_progress_bar">progress_bar</code></td>
<td>
<p>Either a boolean value to determine whether a progress
bar should be shown in the console, or a shiny Progress object to implement
a progress bar in a shiny app.</p>
</td></tr>
<tr><td><code id="project_+3A_...">...</code></td>
<td>
<p>Other arguments will be passed to rate functions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <a href="#topic+MizerSim-class">MizerSim</a>.
</p>


<h3>Note</h3>

<p>The <code>effort</code> argument specifies the level of fishing effort during the
simulation. If it is not supplied, the initial effort stored in the params
object is used. The effort can be specified in four different ways:
</p>

<ul>
<li><p> A single numeric value. This specifies the effort of all fishing gears
which is constant through time (i.e. all the gears have the same constant
effort).
</p>
</li>
<li><p> A named vector whose names match with existing gear names.
The values in the vector specify the constant fishing effort for those
fishing gears, i.e. the effort is constant through time. The
effort for gears that are not included in the effort vector is set to 0.
</p>
</li>
<li><p> A numerical vector which has the same length as the number of fishing
gears. The values in the vector specify the
constant fishing effort of each of the fishing gears, with the ordering
assumed to be the same as in the MizerParams object.
</p>
</li>
<li><p> A numerical array with dimensions time x gear. This specifies the
fishing effort of each gear at each time step.  The first dimension, time,
must be named numerically and increasing. The second dimension of the array
must be named and the names must correspond to the gear names in the
<code>MizerParams</code> object. The value for the effort for a particular time
is used during the interval from that time to the next time in the array.
</p>
</li></ul>

<p>If effort is specified as an array then the smallest time in the array is
used as the initial time for the simulation. Otherwise the initial time is
set to the final time of the previous simulation if <code>object</code> is a
<code>MizerSim</code> object or to <code>t_start</code> otherwise. Also, if the effort is
an array then the <code>t_max</code> and <code>t_save</code> arguments are ignored and the
simulation times will be taken from the effort array.
</p>
<p>If the <code>object</code> argument is of class <code>MizerSim</code> then the initial
values for the simulation are taken from the final values in the
<code>MizerSim</code> object and the corresponding arguments to this function will
be ignored.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
params &lt;-  NS_params
# With constant fishing effort for all gears for 20 time steps
sim &lt;- project(params, t_max = 20, effort = 0.5)
# With constant fishing effort which is different for each gear
effort &lt;- c(Industrial = 0, Pelagic = 1, Beam = 0.5, Otter = 0.5)
sim &lt;- project(params, t_max = 20, effort = effort)
# With fishing effort that varies through time for each gear
gear_names &lt;- c("Industrial","Pelagic","Beam","Otter")
times &lt;- seq(from = 1, to = 10, by = 1)
effort_array &lt;- array(NA, dim = c(length(times), length(gear_names)),
    dimnames = list(time = times, gear = gear_names))
effort_array[,"Industrial"] &lt;- 0.5
effort_array[,"Pelagic"] &lt;- seq(from = 1, to = 2, length = length(times))
effort_array[,"Beam"] &lt;- seq(from = 1, to = 0, length = length(times))
effort_array[,"Otter"] &lt;- seq(from = 1, to = 0.5, length = length(times))
sim &lt;- project(params, effort = effort_array)

</code></pre>

<hr>
<h2 id='project_simple'>Project abundances by a given number of time steps into the future</h2><span id='topic+project_simple'></span>

<h3>Description</h3>

<p>This is an internal function used by the user-facing <code>project()</code> function.
It is of potential interest only to mizer extension authors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>project_simple(
  params,
  n = params@initial_n,
  n_pp = params@initial_n_pp,
  n_other = params@initial_n_other,
  effort = params@initial_effort,
  t = 0,
  dt = 0.1,
  steps,
  resource_dynamics_fn = get(params@resource_dynamics),
  other_dynamics_fns = lapply(params@other_dynamics, get),
  rates_fns = lapply(params@rates_funcs, get),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="project_simple_+3A_params">params</code></td>
<td>
<p>A MizerParams object.</p>
</td></tr>
<tr><td><code id="project_simple_+3A_n">n</code></td>
<td>
<p>An array (species x size) with the number density at start of
simulation.</p>
</td></tr>
<tr><td><code id="project_simple_+3A_n_pp">n_pp</code></td>
<td>
<p>A vector (size) with the resource number density at start of
simulation.</p>
</td></tr>
<tr><td><code id="project_simple_+3A_n_other">n_other</code></td>
<td>
<p>A named list with the abundances of other components at start
of simulation.</p>
</td></tr>
<tr><td><code id="project_simple_+3A_effort">effort</code></td>
<td>
<p>The fishing effort to be used throughout the simulation. This
must be a vector or list with one named entry per fishing gear.</p>
</td></tr>
<tr><td><code id="project_simple_+3A_t">t</code></td>
<td>
<p>Time at the start of the simulation.</p>
</td></tr>
<tr><td><code id="project_simple_+3A_dt">dt</code></td>
<td>
<p>Size of time step.</p>
</td></tr>
<tr><td><code id="project_simple_+3A_steps">steps</code></td>
<td>
<p>The number of time steps by which to project.</p>
</td></tr>
<tr><td><code id="project_simple_+3A_resource_dynamics_fn">resource_dynamics_fn</code></td>
<td>
<p>The function for the resource
dynamics. See Details.</p>
</td></tr>
<tr><td><code id="project_simple_+3A_other_dynamics_fns">other_dynamics_fns</code></td>
<td>
<p>List with the functions for the
dynamics of the other components. See Details.</p>
</td></tr>
<tr><td><code id="project_simple_+3A_rates_fns">rates_fns</code></td>
<td>
<p>List with the functions for calculating
the rates. See Details.</p>
</td></tr>
<tr><td><code id="project_simple_+3A_...">...</code></td>
<td>
<p>Other arguments that are passed on to the rate functions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function does not check its arguments because it is meant to be as fast
as possible to allow it to be used in a loop. For example, it is called in
<code>project()</code> once for every saved value. The function also does not save its
intermediate results but only returns the result at time <code>t + dt * steps</code>.
During this time it uses the constant fishing effort <code>effort</code>.
</p>
<p>The functional arguments can be calculated from slots in the <code>params</code> object
with
</p>
<div class="sourceCode"><pre>resource_dynamics_fn &lt;- get(params@resource_dynamics)
other_dynamics_fns &lt;- lapply(params@other_dynamics, get)
rates_fns &lt;- lapply(params@rates_funcs, get)
</pre></div>
<p>The reason the function does not do that itself is to shave 20 microseconds
of its running time, which pays when the function is called hundreds of
times in a row.
</p>
<p>This function is also used in <code>steady()</code>. In between calls to
<code>project_simple()</code> the <code>steady()</code> function checks whether the values are
still changing significantly, so that it can stop when a steady state has
been approached. Mizer extension packages might have a similar need to run
a simulation repeatedly for short periods to run some other code in
between. Because this code may want to use the values of the rates at the
final time step, these too are included in the returned list.
</p>


<h3>Value</h3>

<p>List with the final values of <code>n</code>, <code>n_pp</code> and <code>n_other</code>, <code>rates</code>.
</p>

<hr>
<h2 id='projectToSteady'>Project to steady state</h2><span id='topic+projectToSteady'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>
<p>Run the full dynamics, as in <code><a href="#topic+project">project()</a></code>, but stop once the change has slowed
down sufficiently, in the sense that the distance between states at
successive time steps is less than <code>tol</code>. You determine how the distance is
calculated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>projectToSteady(
  params,
  effort = params@initial_effort,
  distance_func = distanceSSLogN,
  t_per = 1.5,
  t_max = 100,
  dt = 0.1,
  tol = 0.1 * t_per,
  return_sim = FALSE,
  progress_bar = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="projectToSteady_+3A_params">params</code></td>
<td>
<p>A <a href="#topic+MizerParams-class">MizerParams</a> object</p>
</td></tr>
<tr><td><code id="projectToSteady_+3A_effort">effort</code></td>
<td>
<p>The fishing effort to be used throughout the simulation.
This must be a vector or list with one named entry per fishing gear.</p>
</td></tr>
<tr><td><code id="projectToSteady_+3A_distance_func">distance_func</code></td>
<td>
<p>A function that will be called after every <code>t_per</code> years
with both the previous and the new state and that should return a number
that in some sense measures the distance between the states. By default
this uses the function <code><a href="#topic+distanceSSLogN">distanceSSLogN()</a></code> that you can use as a model for your
own distance function.</p>
</td></tr>
<tr><td><code id="projectToSteady_+3A_t_per">t_per</code></td>
<td>
<p>The simulation is broken up into shorter runs of <code>t_per</code> years,
after each of which we check for convergence. Default value is 1.5. This
should be chosen as an odd multiple of the timestep <code>dt</code> in order to be
able to detect period 2 cycles.</p>
</td></tr>
<tr><td><code id="projectToSteady_+3A_t_max">t_max</code></td>
<td>
<p>The maximum number of years to run the simulation. Default is 100.</p>
</td></tr>
<tr><td><code id="projectToSteady_+3A_dt">dt</code></td>
<td>
<p>The time step to use in <code>project()</code>.</p>
</td></tr>
<tr><td><code id="projectToSteady_+3A_tol">tol</code></td>
<td>
<p>The simulation stops when the relative change in the egg
production RDI over <code>t_per</code> years is less than <code>tol</code> for every species.</p>
</td></tr>
<tr><td><code id="projectToSteady_+3A_return_sim">return_sim</code></td>
<td>
<p>If TRUE, the function returns the MizerSim object holding
the result of the simulation run, saved at intervals of <code>t_per</code>. If FALSE (default) the function returns
a MizerParams object with the &quot;initial&quot; slots set to the steady state.</p>
</td></tr>
<tr><td><code id="projectToSteady_+3A_progress_bar">progress_bar</code></td>
<td>
<p>A shiny progress object to implement a progress bar in a
shiny app. Default FALSE.</p>
</td></tr>
<tr><td><code id="projectToSteady_+3A_...">...</code></td>
<td>
<p>Further arguments will be passed on to your distance function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A MizerParams or a MizerSim object
</p>


<h3>See Also</h3>

<p><code><a href="#topic+distanceSSLogN">distanceSSLogN()</a></code>, <code><a href="#topic+distanceMaxRelRDI">distanceMaxRelRDI()</a></code>
</p>

<hr>
<h2 id='reexports'>Objects exported from other packages</h2><span id='topic+reexports'></span><span id='topic+melt'></span>

<h3>Description</h3>

<p>These objects are imported from other packages. Follow the links
below to see their documentation.
</p>

<dl>
<dt>reshape2</dt><dd><p><code><a href="reshape2.html#topic+melt">melt</a></code></p>
</dd>
</dl>

<hr>
<h2 id='removeSpecies'>Remove species</h2><span id='topic+removeSpecies'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>
<p>This function simply removes all entries from the MizerParams object that
refer to the selected species. It does not recalculate the steady state for
the remaining species or retune their reproductive efficiency.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>removeSpecies(params, species)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="removeSpecies_+3A_params">params</code></td>
<td>
<p>A mizer params object for the original system.</p>
</td></tr>
<tr><td><code id="removeSpecies_+3A_species">species</code></td>
<td>
<p>The species to be removed. A vector of species names, or a
numeric vector of species indices, or a logical vector indicating for
each species whether it is to be removed (TRUE) or not.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of type <a href="#topic+MizerParams-class">MizerParams</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>params &lt;- NS_params
species_params(params)$species
params &lt;- removeSpecies(params, c("Cod", "Haddock"))
species_params(params)$species
</code></pre>

<hr>
<h2 id='renameSpecies'>Rename species</h2><span id='topic+renameSpecies'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>
<p>Changes the names of species in a MizerParams object. This involves for
example changing the species dimension names of rate arrays appropriately.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>renameSpecies(params, replace)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="renameSpecies_+3A_params">params</code></td>
<td>
<p>A mizer params object</p>
</td></tr>
<tr><td><code id="renameSpecies_+3A_replace">replace</code></td>
<td>
<p>A named character vector, with new names as values, and old
names as names.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of type <a href="#topic+MizerParams-class">MizerParams</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>replace &lt;- c(Cod = "Kabeljau", Haddock = "Schellfisch")
params &lt;- renameSpecies(NS_params, replace)
species_params(params)$species
</code></pre>

<hr>
<h2 id='resource_constant'>Keep resource abundance constant</h2><span id='topic+resource_constant'></span>

<h3>Description</h3>

<p>If you set your resource dynamics to use this function then the resource
abundances are kept constant over time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>resource_constant(params, n_pp, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="resource_constant_+3A_params">params</code></td>
<td>
<p>A <a href="#topic+MizerParams">MizerParams</a> object</p>
</td></tr>
<tr><td><code id="resource_constant_+3A_n_pp">n_pp</code></td>
<td>
<p>A vector of the resource abundance by size</p>
</td></tr>
<tr><td><code id="resource_constant_+3A_...">...</code></td>
<td>
<p>Unused</p>
</td></tr>
</table>


<h3>Details</h3>

<p>To set your model to keep the resource constant over time you do
</p>
<div class="sourceCode"><pre>resource_dynamics(params) &lt;- "resource_constant"
</pre></div>
<p>where you should replace <code>params</code> with the name of the variable holding your
MizerParams object.
</p>


<h3>Value</h3>

<p>Vector containing resource spectrum at next timestep
</p>


<h3>See Also</h3>

<p>Other resource dynamics: 
<code><a href="#topic+resource_logistic">resource_logistic</a>()</code>,
<code><a href="#topic+resource_semichemostat">resource_semichemostat</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>params &lt;- NS_params
resource_dynamics(params) &lt;- "resource_constant"
</code></pre>

<hr>
<h2 id='resource_logistic'>Project resource using logistic model</h2><span id='topic+resource_logistic'></span><span id='topic+balance_resource_logistic'></span>

<h3>Description</h3>

<p>If you set your resource dynamics to use this function then the time
evolution of the resource spectrum is described by a logistic equation
</p>
<p style="text-align: center;"><code class="reqn">\frac{\partial N_R(w,t)}{\partial t} = r_R(w) N_R(w)\Big[ 1 - \frac{N_R(w,t)}{c_R (w)} \Big] - \mu_R(w, t) N_R(w,t)</code>
</p>



<h3>Usage</h3>

<pre><code class='language-R'>resource_logistic(
  params,
  n,
  n_pp,
  n_other,
  rates,
  t,
  dt,
  resource_rate,
  resource_capacity,
  ...
)

balance_resource_logistic(params, resource_rate, resource_capacity)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="resource_logistic_+3A_params">params</code></td>
<td>
<p>A <a href="#topic+MizerParams">MizerParams</a> object</p>
</td></tr>
<tr><td><code id="resource_logistic_+3A_n">n</code></td>
<td>
<p>A matrix of species abundances (species x size)</p>
</td></tr>
<tr><td><code id="resource_logistic_+3A_n_pp">n_pp</code></td>
<td>
<p>A vector of the resource abundance by size</p>
</td></tr>
<tr><td><code id="resource_logistic_+3A_n_other">n_other</code></td>
<td>
<p>A list with the abundances of other components</p>
</td></tr>
<tr><td><code id="resource_logistic_+3A_rates">rates</code></td>
<td>
<p>A list of rates as returned by <code><a href="#topic+mizerRates">mizerRates()</a></code></p>
</td></tr>
<tr><td><code id="resource_logistic_+3A_t">t</code></td>
<td>
<p>The current time</p>
</td></tr>
<tr><td><code id="resource_logistic_+3A_dt">dt</code></td>
<td>
<p>Time step</p>
</td></tr>
<tr><td><code id="resource_logistic_+3A_resource_rate">resource_rate</code></td>
<td>
<p>Resource replenishment rate</p>
</td></tr>
<tr><td><code id="resource_logistic_+3A_resource_capacity">resource_capacity</code></td>
<td>
<p>Resource carrying capacity</p>
</td></tr>
<tr><td><code id="resource_logistic_+3A_...">...</code></td>
<td>
<p>Unused</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Here <code class="reqn">r_R(w)</code> is the resource regeneration rate and <code class="reqn">c_R(w)</code> is the
carrying capacity in the absence of predation. These parameters are changed
with <code><a href="#topic+setResource">setResource()</a></code>. The mortality <code class="reqn">\mu_R(w, t)</code> is
due to predation by consumers and is calculate with <code><a href="#topic+getResourceMort">getResourceMort()</a></code>.
</p>
<p>This function uses the analytic solution of the above equation to calculate
the resource abundance at time <code>t + dt</code> from all abundances and rates at time
<code>t</code>, keeping the mortality fixed during the timestep.
</p>
<p>To set your model to use logistic dynamics for the resource you do
</p>
<div class="sourceCode"><pre>params &lt;- setResource(params, 
                      resource_dynamics = "resource_logistic", 
                      resource_level = 0.5)
</pre></div>
<p>where you should replace <code>params</code> with the name of the variable holding your
MizerParams object. You can of course choose any value between 0 and 1 for
the resource level.
</p>
<p>The <code><a href="#topic+balance_resource_logistic">balance_resource_logistic()</a></code> function is called by <code><a href="#topic+setResource">setResource()</a></code> to
determine the values of the resource parameters that are needed to make the
replenishment rate at each size equal the consumption rate at that size, as
calculated by <code><a href="#topic+getResourceMort">getResourceMort()</a></code>. It should be called with only one of
<code>resource_rate</code> or <code>resource_capacity</code> should and will return a named list
with the values for both.
</p>


<h3>Value</h3>

<p>Vector containing resource spectrum at next timestep
</p>


<h3>See Also</h3>

<p>Other resource dynamics: 
<code><a href="#topic+resource_constant">resource_constant</a>()</code>,
<code><a href="#topic+resource_semichemostat">resource_semichemostat</a>()</code>
</p>

<hr>
<h2 id='resource_params'>Resource parameters</h2><span id='topic+resource_params'></span><span id='topic+resource_params+3C-'></span>

<h3>Description</h3>

<p>The recommended way to change the resource dynamics parameters is to use
<code><a href="#topic+setResource">setResource()</a></code>. The <code>resource_params</code> list contains values that are helpful
in setting up the actual size-dependent parameters with <code><a href="#topic+setResource">setResource()</a></code>. If
you have specified a custom resource dynamics function that requires
additional parameters, then these should also be added to the
<code>resource_params</code> list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>resource_params(params)

resource_params(params) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="resource_params_+3A_params">params</code></td>
<td>
<p>A MizerParams object</p>
</td></tr>
<tr><td><code id="resource_params_+3A_value">value</code></td>
<td>
<p>A named list of resource parameters.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>resource_params</code> list will at least contain the slots <code>kappa</code>, <code>lambda</code>,
<code>w_pp_cutoff</code> and <code>n</code>.
</p>
<p>The resource parameter <code>n</code> is the exponent for the power-law form for the
replenishment rate <code class="reqn">r_R(w)</code>: </p>
<p style="text-align: center;"><code class="reqn">r_R(w) = r_R\, w^{n-1}.</code>
</p>

<p>The resource parameter <code>lambda</code> (<code class="reqn">\lambda</code>) is the exponent for the
power-law form for the carrying capacity <code class="reqn">c_R(w)</code> and <code>w_pp_cutoff</code> is
its cutoff value: </p>
<p style="text-align: center;"><code class="reqn">c_R(w) = c_R w^{-\lambda}</code>
</p>
<p> for all <code class="reqn">w</code> less than
<code>w_pp_cutoff</code> and zero for larger sizes.
</p>
<p>The resource parameter <code>kappa</code> (<code class="reqn">\kappa</code>) determines the initial resource
abundance: </p>
<p style="text-align: center;"><code class="reqn">N_R(w) = \kappa\, w^{-\lambda}</code>
</p>
<p> for all <code class="reqn">w</code> less than <code>w_pp_cutoff</code> and zero for larger
sizes.
</p>


<h3>Value</h3>

<p>A named list of resource parameters.
</p>

<hr>
<h2 id='resource_semichemostat'>Project resource using semichemostat model</h2><span id='topic+resource_semichemostat'></span><span id='topic+balance_resource_semichemostat'></span>

<h3>Description</h3>

<p>If you set your resource dynamics to use this function then the time
evolution of the resource spectrum is described by a semi-chemostat equation
</p>
<p style="text-align: center;"><code class="reqn">\frac{\partial N_R(w,t)}{\partial t} = r_R(w) \Big[ c_R (w) - N_R(w,t) \Big] - \mu_R(w, t) N_R(w,t)</code>
</p>



<h3>Usage</h3>

<pre><code class='language-R'>resource_semichemostat(
  params,
  n,
  n_pp,
  n_other,
  rates,
  t,
  dt,
  resource_rate,
  resource_capacity,
  ...
)

balance_resource_semichemostat(params, resource_rate, resource_capacity)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="resource_semichemostat_+3A_params">params</code></td>
<td>
<p>A <a href="#topic+MizerParams">MizerParams</a> object</p>
</td></tr>
<tr><td><code id="resource_semichemostat_+3A_n">n</code></td>
<td>
<p>A matrix of species abundances (species x size)</p>
</td></tr>
<tr><td><code id="resource_semichemostat_+3A_n_pp">n_pp</code></td>
<td>
<p>A vector of the resource abundance by size</p>
</td></tr>
<tr><td><code id="resource_semichemostat_+3A_n_other">n_other</code></td>
<td>
<p>A list with the abundances of other components</p>
</td></tr>
<tr><td><code id="resource_semichemostat_+3A_rates">rates</code></td>
<td>
<p>A list of rates as returned by <code><a href="#topic+mizerRates">mizerRates()</a></code></p>
</td></tr>
<tr><td><code id="resource_semichemostat_+3A_t">t</code></td>
<td>
<p>The current time</p>
</td></tr>
<tr><td><code id="resource_semichemostat_+3A_dt">dt</code></td>
<td>
<p>Time step</p>
</td></tr>
<tr><td><code id="resource_semichemostat_+3A_resource_rate">resource_rate</code></td>
<td>
<p>Resource replenishment rate</p>
</td></tr>
<tr><td><code id="resource_semichemostat_+3A_resource_capacity">resource_capacity</code></td>
<td>
<p>Resource carrying capacity</p>
</td></tr>
<tr><td><code id="resource_semichemostat_+3A_...">...</code></td>
<td>
<p>Unused</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Here <code class="reqn">r_R(w)</code> is the resource regeneration rate and <code class="reqn">c_R(w)</code> is the
carrying capacity in the absence of predation. These parameters are changed
with <code><a href="#topic+setResource">setResource()</a></code>. The mortality <code class="reqn">\mu_R(w, t)</code> is
due to predation by consumers and is calculate with <code><a href="#topic+getResourceMort">getResourceMort()</a></code>.
</p>
<p>This function uses the analytic solution of the above equation to calculate
the resource abundance at time <code>t + dt</code> from all abundances and rates at time
<code>t</code>, keeping the mortality fixed during the timestep.
</p>
<p>To set your model to use semichemostat dynamics for the resource you do
</p>
<div class="sourceCode"><pre>params &lt;- setResource(params, 
                      resource_dynamics = "resource_semichemostat", 
                      resource_level = 0.5)
</pre></div>
<p>where you should replace <code>params</code> with the name of the variable holding your
MizerParams object. You can of course choose any value between 0 and 1 for
the resource level.
</p>
<p>The <code><a href="#topic+balance_resource_semichemostat">balance_resource_semichemostat()</a></code> function is called by <code><a href="#topic+setResource">setResource()</a></code>
to determine the values of the resource parameters that are needed to make
the replenishment rate at each size equal the consumption rate at that size,
as calculated by <code><a href="#topic+getResourceMort">getResourceMort()</a></code>. It should be called with only one of
<code>resource_rate</code> or <code>resource_capacity</code> should and will return a named list
with the values for both.
</p>


<h3>Value</h3>

<p>Vector containing resource spectrum at next timestep
</p>


<h3>See Also</h3>

<p>Other resource dynamics: 
<code><a href="#topic+resource_constant">resource_constant</a>()</code>,
<code><a href="#topic+resource_logistic">resource_logistic</a>()</code>
</p>

<hr>
<h2 id='RickerRDD'>Ricker function to calculate density-dependent reproduction rate</h2><span id='topic+RickerRDD'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
Takes the density-independent rates <code class="reqn">R_{di}</code> of egg production and
returns reduced, density-dependent rates <code class="reqn">R_{dd}</code> given as
</p>
<p style="text-align: center;"><code class="reqn">R_{dd} = R_{di} \exp(- b R_{di})</code>
</p>



<h3>Usage</h3>

<pre><code class='language-R'>RickerRDD(rdi, species_params, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RickerRDD_+3A_rdi">rdi</code></td>
<td>
<p>Vector of density-independent reproduction rates
<code class="reqn">R_{di}</code> for all species.</p>
</td></tr>
<tr><td><code id="RickerRDD_+3A_species_params">species_params</code></td>
<td>
<p>A species parameter dataframe. Must contain a column
<code>ricker_b</code> holding the coefficient b.</p>
</td></tr>
<tr><td><code id="RickerRDD_+3A_...">...</code></td>
<td>
<p>Unused</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector of density-dependent reproduction rates.
</p>


<h3>See Also</h3>

<p>Other functions calculating density-dependent reproduction rate: 
<code><a href="#topic+BevertonHoltRDD">BevertonHoltRDD</a>()</code>,
<code><a href="#topic+SheperdRDD">SheperdRDD</a>()</code>,
<code><a href="#topic+constantEggRDI">constantEggRDI</a>()</code>,
<code><a href="#topic+constantRDD">constantRDD</a>()</code>,
<code><a href="#topic+noRDD">noRDD</a>()</code>
</p>

<hr>
<h2 id='saveParams'>Save a MizerParams object to file, and restore it</h2><span id='topic+saveParams'></span><span id='topic+readParams'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
<code>saveParams()</code> saves a MizerParams object to a file. This can then be
restored with <code>readParams()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>saveParams(params, file)

readParams(file)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="saveParams_+3A_params">params</code></td>
<td>
<p>A MizerParams object</p>
</td></tr>
<tr><td><code id="saveParams_+3A_file">file</code></td>
<td>
<p>The name of the file or a connection where the MizerParams object
is saved to or read from.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Issues a warning if the model you are saving relies on some custom functions.
Before saving a model you may want to set its metadata with
<code><a href="#topic+setMetadata">setMetadata()</a></code>.
</p>


<h3>Value</h3>

<p>NULL invisibly
</p>

<hr>
<h2 id='scaleModel'>Change scale of the model</h2><span id='topic+scaleModel'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>
<p>The abundances in mizer and some rates depend on the size of the area to
which they refer. So they could be given per square meter or per square
kilometer or for an entire study area or any other choice of yours. This
function allows you to change the scale of the model by automatically
changing the abundances and rates accordingly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scaleModel(params, factor)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scaleModel_+3A_params">params</code></td>
<td>
<p>A MizerParams object</p>
</td></tr>
<tr><td><code id="scaleModel_+3A_factor">factor</code></td>
<td>
<p>The factor by which the scale is multiplied</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If you rescale the model by a factor <code class="reqn">c</code> then this function makes the
following rescalings in the params object:
</p>

<ul>
<li><p> The initial abundances are rescaled by <code class="reqn">c</code>.
</p>
</li>
<li><p> The search volume is rescaled by <code class="reqn">1/c</code>.
</p>
</li>
<li><p> The resource carrying capacity is rescaled by <code class="reqn">c</code>
</p>
</li>
<li><p> The maximum reproduction rate <code class="reqn">R_{max}</code> is rescaled by
<code class="reqn">c</code>.
</p>
</li></ul>

<p>The effect of this is that the dynamics of the rescaled model are identical
to those of the unscaled model, in the sense that it does not matter whether
one first calls <code><a href="#topic+scaleModel">scaleModel()</a></code> and then runs a simulation with
<code><a href="#topic+project">project()</a></code> or whether one first runs a simulation and then rescales the
resulting abundances.
</p>
<p>Note that if you use non-standard resource dynamics or other components then
you may need to rescale additional parameters that appear in those dynamics.
</p>
<p>In practice you will need to use some observations to set the scale for your
model. If you have biomass observations you can use <code><a href="#topic+calibrateBiomass">calibrateBiomass()</a></code>,
if you have yearly yields you can use <code><a href="#topic+calibrateYield">calibrateYield()</a></code>.
</p>


<h3>Value</h3>

<p>The rescaled MizerParams object
</p>

<hr>
<h2 id='set_community_model'>Deprecated function for setting up parameters for a community-type model</h2><span id='topic+set_community_model'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p>This function has been deprecated in favour of the function
<code><a href="#topic+newCommunityParams">newCommunityParams()</a></code> that sets better default values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_community_model(
  max_w = 1e+06,
  min_w = 0.001,
  min_w_pp = 1e-10,
  z0 = 0.1,
  alpha = 0.2,
  h = 10,
  beta = 100,
  sigma = 2,
  q = 0.8,
  n = 2/3,
  kappa = 1000,
  lambda = 2 + q - n,
  f0 = 0.7,
  r_pp = 10,
  gamma = NA,
  knife_edge_size = 1000,
  knife_is_min = TRUE,
  recruitment = kappa * min_w^-lambda,
  rec_mult = 1,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="set_community_model_+3A_max_w">max_w</code></td>
<td>
<p>The maximum size of the community. The <code>w_inf</code> of the
species used to represent the community is set to this value. The
default value is 1e6.</p>
</td></tr>
<tr><td><code id="set_community_model_+3A_min_w">min_w</code></td>
<td>
<p>The minimum size of the community. Default value is 1e-3.</p>
</td></tr>
<tr><td><code id="set_community_model_+3A_min_w_pp">min_w_pp</code></td>
<td>
<p>The smallest size of the resource spectrum.</p>
</td></tr>
<tr><td><code id="set_community_model_+3A_z0">z0</code></td>
<td>
<p>The background mortality of the community. Default value is 0.1.</p>
</td></tr>
<tr><td><code id="set_community_model_+3A_alpha">alpha</code></td>
<td>
<p>The assimilation efficiency of the community. Default value 0.2</p>
</td></tr>
<tr><td><code id="set_community_model_+3A_h">h</code></td>
<td>
<p>The maximum food intake rate. Default value is 10.</p>
</td></tr>
<tr><td><code id="set_community_model_+3A_beta">beta</code></td>
<td>
<p>The preferred predator prey mass ratio. Default value is 100.</p>
</td></tr>
<tr><td><code id="set_community_model_+3A_sigma">sigma</code></td>
<td>
<p>The width of the prey preference. Default value is 2.0.</p>
</td></tr>
<tr><td><code id="set_community_model_+3A_q">q</code></td>
<td>
<p>The search volume exponent. Default value is 0.8.</p>
</td></tr>
<tr><td><code id="set_community_model_+3A_n">n</code></td>
<td>
<p>The scaling of the intake. Default value is 2/3.</p>
</td></tr>
<tr><td><code id="set_community_model_+3A_kappa">kappa</code></td>
<td>
<p>The carrying capacity of the resource spectrum. Default value
is 1000.</p>
</td></tr>
<tr><td><code id="set_community_model_+3A_lambda">lambda</code></td>
<td>
<p>The exponent of the resource spectrum. Default value is 2 + q - n.</p>
</td></tr>
<tr><td><code id="set_community_model_+3A_f0">f0</code></td>
<td>
<p>The average feeding level of individuals who feed on a power-law
spectrum. This value is used to calculate the search rate parameter
<code>gamma</code> (see the package vignette). Default value is 0.7.</p>
</td></tr>
<tr><td><code id="set_community_model_+3A_r_pp">r_pp</code></td>
<td>
<p>Growth rate parameter for the resource spectrum. Default value is 10.</p>
</td></tr>
<tr><td><code id="set_community_model_+3A_gamma">gamma</code></td>
<td>
<p>Volumetric search rate. Estimated using <code>h</code>, <code>f0</code> and
<code>kappa</code> if not supplied.</p>
</td></tr>
<tr><td><code id="set_community_model_+3A_knife_edge_size">knife_edge_size</code></td>
<td>
<p>The size at the edge of the knife-selectivity
function. Default value is 1000.</p>
</td></tr>
<tr><td><code id="set_community_model_+3A_knife_is_min">knife_is_min</code></td>
<td>
<p>Is the knife-edge selectivity function selecting above
(TRUE) or below (FALSE) the edge. Default is TRUE.</p>
</td></tr>
<tr><td><code id="set_community_model_+3A_recruitment">recruitment</code></td>
<td>
<p>The constant recruitment in the smallest size class of the
community spectrum. This should be set so that the community spectrum
continues the resource spectrum. Default value = <code>kappa</code> *
<code>min_w</code>^-<code>lambda</code>.</p>
</td></tr>
<tr><td><code id="set_community_model_+3A_rec_mult">rec_mult</code></td>
<td>
<p>Additional multiplier for the constant recruitment. Default
value is 1.</p>
</td></tr>
<tr><td><code id="set_community_model_+3A_...">...</code></td>
<td>
<p>Other arguments to pass to the <code>MizerParams</code> constructor.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This functions creates a <code><a href="#topic+MizerParams-class">MizerParams</a></code> object so that
community-type models can be easily set up and run. A community model has
several features that distinguish it from the food-web type models. Only one
'species' is resolved, i.e. one 'species' is used to represent the whole
community. The resource spectrum only extends to the start of the community
spectrum. Recruitment to the smallest size in the community spectrum is
constant and set by the user. As recruitment is constant, the proportion of
energy invested in reproduction (the slot <code>psi</code> of the returned
<code>MizerParams</code> object) is set to 0. Standard metabolism has been turned
off (the parameter <code>ks</code> is set to 0). Consequently, the growth rate is
now determined solely by the assimilated food (see the package vignette for
more details).
</p>
<p>The function has many arguments, all of which have default values. The main
arguments that the users should be concerned with are <code>z0</code>,
<code>recruitment</code>, <code>alpha</code> and <code>f0</code> as these determine the average
growth rate of the community.
</p>
<p>Fishing selectivity is modelled as a knife-edge function with one parameter,
<code>knife_edge_size</code>, which determines the size at which species are
selected.
</p>
<p>The resulting <code>MizerParams</code> object can be projected forward using
<code>project()</code> like any other <code>MizerParams</code> object. When projecting
the community model it may be necessary to keep a small time step size
<code>dt</code> of around 0.1 to avoid any instabilities with the solver. You can
check for these numerical instabilities by plotting the biomass or abundance
through time after the projection.
</p>


<h3>Value</h3>

<p>An object of type <code><a href="#topic+MizerParams-class">MizerParams</a></code>
</p>


<h3>References</h3>

<p>K. H. Andersen,J. E. Beyer and P. Lundberg, 2009, Trophic and
individual efficiencies of size-structured communities, Proceedings of the
Royal Society, 276, 109-114
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
params &lt;- set_community_model(f0=0.7, z0=0.2, recruitment=3e7)
# This is now achieved with
params &lt;- newCommunityParams(f0 = 0.7, z0 = 0.2)
sim &lt;- project(params, effort = 0, t_max = 100, dt=0.1)
plotBiomass(sim)
plotSpectra(sim)

</code></pre>

<hr>
<h2 id='set_multispecies_model'>Deprecated obsolete function for setting up multispecies parameters</h2><span id='topic+set_multispecies_model'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p>This function has been deprecated in favour of the function
<code><a href="#topic+newMultispeciesParams">newMultispeciesParams()</a></code> that sets better default values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_multispecies_model(
  species_params,
  interaction = matrix(1, nrow = nrow(species_params), ncol = nrow(species_params)),
  min_w_pp = 1e-10,
  min_w = 0.001,
  max_w = NULL,
  no_w = 100,
  n = 2/3,
  q = 0.8,
  f0 = 0.6,
  kappa = 1e+11,
  lambda = 2 + q - n,
  r_pp = 10,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="set_multispecies_model_+3A_species_params">species_params</code></td>
<td>
<p>A data frame of species-specific parameter values.</p>
</td></tr>
<tr><td><code id="set_multispecies_model_+3A_interaction">interaction</code></td>
<td>
<p>Optional interaction matrix of the species (predator
species x prey species). By default all entries are 1. See &quot;Setting
interaction matrix&quot; section below.</p>
</td></tr>
<tr><td><code id="set_multispecies_model_+3A_min_w_pp">min_w_pp</code></td>
<td>
<p>The smallest size of the resource spectrum. By default this
is set to the smallest value at which any of the consumers can feed.</p>
</td></tr>
<tr><td><code id="set_multispecies_model_+3A_min_w">min_w</code></td>
<td>
<p>Sets the size of the eggs of all species for which this is not
given in the <code>w_min</code> column of the <code>species_params</code> dataframe.</p>
</td></tr>
<tr><td><code id="set_multispecies_model_+3A_max_w">max_w</code></td>
<td>
<p>The largest size of the consumer spectrum. By default this is
set to the largest <code>w_max</code> specified in the <code>species_params</code> data
frame.</p>
</td></tr>
<tr><td><code id="set_multispecies_model_+3A_no_w">no_w</code></td>
<td>
<p>The number of size bins in the consumer spectrum.</p>
</td></tr>
<tr><td><code id="set_multispecies_model_+3A_n">n</code></td>
<td>
<p>The allometric growth exponent. This can be overruled for individual
species by including a <code>n</code> column in the <code>species_params</code>.</p>
</td></tr>
<tr><td><code id="set_multispecies_model_+3A_q">q</code></td>
<td>
<p>Allometric exponent of search volume</p>
</td></tr>
<tr><td><code id="set_multispecies_model_+3A_f0">f0</code></td>
<td>
<p>Expected average feeding level. Used to set <code>gamma</code>, the
coefficient in the search rate. Ignored if <code>gamma</code> is given
explicitly.</p>
</td></tr>
<tr><td><code id="set_multispecies_model_+3A_kappa">kappa</code></td>
<td>
<p>The coefficient of the initial resource abundance power-law.</p>
</td></tr>
<tr><td><code id="set_multispecies_model_+3A_lambda">lambda</code></td>
<td>
<p>Used to set power-law exponent for resource capacity if the
<code>resource_capacity</code> argument is given as a single number.</p>
</td></tr>
<tr><td><code id="set_multispecies_model_+3A_r_pp">r_pp</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>. Use <code>resource_rate</code> argument
instead.</p>
</td></tr>
<tr><td><code id="set_multispecies_model_+3A_...">...</code></td>
<td>
<p>Unused</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A MizerParams object
</p>

<hr>
<h2 id='set_species_param_default'>Set a species parameter to a default value</h2><span id='topic+set_species_param_default'></span>

<h3>Description</h3>

<p>If the species parameter does not yet exist in the species parameter data
frame, then create it and fill it with the default. Otherwise use the default
only to fill in any NAs. Optionally gives a message if the parameter
did not already exist.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_species_param_default(object, parname, default, message = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="set_species_param_default_+3A_object">object</code></td>
<td>
<p>Either a MizerParams object or a species parameter data frame</p>
</td></tr>
<tr><td><code id="set_species_param_default_+3A_parname">parname</code></td>
<td>
<p>A string with the name of the species parameter to set</p>
</td></tr>
<tr><td><code id="set_species_param_default_+3A_default">default</code></td>
<td>
<p>A single default value or a vector with one default value for
each species</p>
</td></tr>
<tr><td><code id="set_species_param_default_+3A_message">message</code></td>
<td>
<p>A string with a message to be issued when the parameter did
not already exist</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The <code>object</code> with an updated column in the species params data frame.
</p>

<hr>
<h2 id='set_trait_model'>Deprecated function for setting up parameters for a trait-based model</h2><span id='topic+set_trait_model'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p>This function has been deprecated in favour of the function
<code><a href="#topic+newTraitParams">newTraitParams()</a></code> that sets better default values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_trait_model(
  no_sp = 10,
  min_w_inf = 10,
  max_w_inf = 1e+05,
  no_w = 100,
  min_w = 0.001,
  max_w = max_w_inf * 1.1,
  min_w_pp = 1e-10,
  w_pp_cutoff = 1,
  k0 = 50,
  n = 2/3,
  p = 0.75,
  q = 0.9,
  eta = 0.25,
  r_pp = 4,
  kappa = 0.005,
  lambda = 2 + q - n,
  alpha = 0.6,
  ks = 4,
  z0pre = 0.6,
  h = 30,
  beta = 100,
  sigma = 1.3,
  f0 = 0.5,
  gamma = NA,
  knife_edge_size = 1000,
  gear_names = "knife_edge_gear",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="set_trait_model_+3A_no_sp">no_sp</code></td>
<td>
<p>The number of species in the model. The default value is 10. The
more species, the longer takes to run.</p>
</td></tr>
<tr><td><code id="set_trait_model_+3A_min_w_inf">min_w_inf</code></td>
<td>
<p>The asymptotic size of the smallest species in the
community.</p>
</td></tr>
<tr><td><code id="set_trait_model_+3A_max_w_inf">max_w_inf</code></td>
<td>
<p>The asymptotic size of the largest species in the community.</p>
</td></tr>
<tr><td><code id="set_trait_model_+3A_no_w">no_w</code></td>
<td>
<p>The number of size bins in the community spectrum.</p>
</td></tr>
<tr><td><code id="set_trait_model_+3A_min_w">min_w</code></td>
<td>
<p>The smallest size of the community spectrum.</p>
</td></tr>
<tr><td><code id="set_trait_model_+3A_max_w">max_w</code></td>
<td>
<p>Obsolete argument because the maximum size of the consumer
spectrum is set to max_w_inf.</p>
</td></tr>
<tr><td><code id="set_trait_model_+3A_min_w_pp">min_w_pp</code></td>
<td>
<p>Obsolete argument because the smallest resource size is set
to the smallest size at which the consumers feed.</p>
</td></tr>
<tr><td><code id="set_trait_model_+3A_w_pp_cutoff">w_pp_cutoff</code></td>
<td>
<p>The cut off size of the resource spectrum. Default value
is 1.</p>
</td></tr>
<tr><td><code id="set_trait_model_+3A_k0">k0</code></td>
<td>
<p>Multiplier for the maximum recruitment. Default value is 50.</p>
</td></tr>
<tr><td><code id="set_trait_model_+3A_n">n</code></td>
<td>
<p>Scaling of the intake. Default value is 2/3.</p>
</td></tr>
<tr><td><code id="set_trait_model_+3A_p">p</code></td>
<td>
<p>Scaling of the standard metabolism. Default value is 0.75.</p>
</td></tr>
<tr><td><code id="set_trait_model_+3A_q">q</code></td>
<td>
<p>Exponent of the search volume. Default value is 0.9.</p>
</td></tr>
<tr><td><code id="set_trait_model_+3A_eta">eta</code></td>
<td>
<p>Factor to calculate <code>w_mat</code> from asymptotic size.</p>
</td></tr>
<tr><td><code id="set_trait_model_+3A_r_pp">r_pp</code></td>
<td>
<p>Growth rate parameter for the resource spectrum. Default value is 4.</p>
</td></tr>
<tr><td><code id="set_trait_model_+3A_kappa">kappa</code></td>
<td>
<p>Coefficient in abundance power law. Default value is
0.005.</p>
</td></tr>
<tr><td><code id="set_trait_model_+3A_lambda">lambda</code></td>
<td>
<p>Exponent of the abundance power law. Default value is (2+q-n).</p>
</td></tr>
<tr><td><code id="set_trait_model_+3A_alpha">alpha</code></td>
<td>
<p>The assimilation efficiency of the community. The default value
is 0.6</p>
</td></tr>
<tr><td><code id="set_trait_model_+3A_ks">ks</code></td>
<td>
<p>Standard metabolism coefficient. Default value is 4.</p>
</td></tr>
<tr><td><code id="set_trait_model_+3A_z0pre">z0pre</code></td>
<td>
<p>The coefficient of the background mortality of the community. z0
= z0pre * w_inf ^ (n-1). The default value is 0.6.</p>
</td></tr>
<tr><td><code id="set_trait_model_+3A_h">h</code></td>
<td>
<p>Maximum food intake rate. Default value is 30.</p>
</td></tr>
<tr><td><code id="set_trait_model_+3A_beta">beta</code></td>
<td>
<p>Preferred predator prey mass ratio. Default value is 100.</p>
</td></tr>
<tr><td><code id="set_trait_model_+3A_sigma">sigma</code></td>
<td>
<p>Width of prey size preference. Default value is 1.3.</p>
</td></tr>
<tr><td><code id="set_trait_model_+3A_f0">f0</code></td>
<td>
<p>Expected average feeding level. Used to set <code>gamma</code>, the
factor for the search volume. The default value is 0.5.</p>
</td></tr>
<tr><td><code id="set_trait_model_+3A_gamma">gamma</code></td>
<td>
<p>Volumetric search rate. Estimated using <code>h</code>, <code>f0</code> and
<code>kappa</code> if not supplied.</p>
</td></tr>
<tr><td><code id="set_trait_model_+3A_knife_edge_size">knife_edge_size</code></td>
<td>
<p>The minimum size at which the gear or gears select
species. Must be of length 1 or no_sp.</p>
</td></tr>
<tr><td><code id="set_trait_model_+3A_gear_names">gear_names</code></td>
<td>
<p>The names of the fishing gears. A character vector, the
same length as the number of species. Default is 1 - no_sp.</p>
</td></tr>
<tr><td><code id="set_trait_model_+3A_...">...</code></td>
<td>
<p>Other arguments to pass to the <code>MizerParams</code> constructor.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This functions creates a <code>MizerParams</code> object so that trait-based-type
models can be easily set up and run. The trait-based size spectrum model can
be derived as a simplification of the general size-based model used in
<code>mizer</code>. The species-specific parameters are the same for all species,
except for
the asymptotic size, which is considered the most important trait
characterizing a species. Other parameters are related to the asymptotic
size. For example, the size at maturity is given by <code>w_max * eta</code>,
where <code>eta</code> is
the same for all species. For the trait-based model the number of species is
not important. For applications of the trait-based model see Andersen &amp;
Pedersen (2010). See the <code>mizer</code> vignette for more details and examples
of the trait-based model.
</p>
<p>The function has many arguments, all of which have default values. Of
particular interest to the user are the number of species in the model and
the minimum and maximum asymptotic sizes. The asymptotic sizes of the species
are spread evenly on a logarithmic scale within this range.
</p>
<p>The stock recruitment relationship is the default Beverton-Holt style. The
maximum recruitment is calculated using equilibrium theory (see Andersen &amp;
Pedersen, 2010) and a multiplier, <code>k0</code>. Users should adjust <code>k0</code> to
get the spectra they want.
</p>
<p>The factor for the search volume, <code>gamma</code>, is calculated using the
expected feeding level, <code>f0</code>.
</p>
<p>Fishing selectivity is modelled as a knife-edge function with one parameter,
<code>knife_edge_size</code>, which is the size at which species are selected. Each
species can either be fished by the same gear (<code>knife_edge_size</code> has a
length of 1) or by a different gear (the length of <code>knife_edge_size</code> has
the same length as the number of species and the order of selectivity size is
that of the asymptotic size).
</p>
<p>The resulting <code>MizerParams</code> object can be projected forward using
<code>project</code> like any other <code>MizerParams</code> object. When projecting
the community model it may be necessary to reduce <code>dt</code> to 0.1 to avoid
any instabilities with the solver. You can check this by plotting the biomass
or abundance through time after the projection.
</p>


<h3>Value</h3>

<p>An object of type <code>MizerParams</code>
</p>


<h3>References</h3>

<p>K. H. Andersen and M. Pedersen, 2010, Damped trophic cascades
driven by fishing in model marine ecosystems. Proceedings of the Royal
Society V, Biological Sciences, 1682, 795-802.
</p>

<hr>
<h2 id='setBevertonHolt'>Set Beverton-Holt reproduction without changing the steady state</h2><span id='topic+setBevertonHolt'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
Takes a MizerParams object <code>params</code> with arbitrary density dependence in
reproduction and
returns a MizerParams object with Beverton-Holt density-dependence in such a
way that the energy invested into reproduction by the mature individuals
leads to the reproduction rate that is required to maintain the given egg
abundance. Hence if you have tuned your <code>params</code> object to describe a
particular steady state, then setting the Beverton-Holt density dependence
with this function will leave you with the exact same steady state. By
specifying one of the parameters <code>erepro</code>, <code>R_max</code> or <code>reproduction_level</code>
you pick the desired reproduction curve. More details of these parameters are
provided below.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setBevertonHolt(
  params,
  R_factor = deprecated(),
  erepro,
  R_max,
  reproduction_level
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setBevertonHolt_+3A_params">params</code></td>
<td>
<p>A MizerParams object</p>
</td></tr>
<tr><td><code id="setBevertonHolt_+3A_r_factor">R_factor</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a> Use
<code>reproduction_level = 1 / R_factor</code> instead.</p>
</td></tr>
<tr><td><code id="setBevertonHolt_+3A_erepro">erepro</code></td>
<td>
<p>Reproductive efficiency for each species. See details.</p>
</td></tr>
<tr><td><code id="setBevertonHolt_+3A_r_max">R_max</code></td>
<td>
<p>Maximum reproduction rate. See details.</p>
</td></tr>
<tr><td><code id="setBevertonHolt_+3A_reproduction_level">reproduction_level</code></td>
<td>
<p>Sets <code>R_max</code> so that the reproduction rate at
the initial state is <code>R_max * reproduction_level</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>With Beverton-Holt density dependence the relation between the energy
invested into reproduction and the number of eggs hatched is determined
by two parameters: the reproductive efficiency <code>erepro</code> and the maximum
reproduction rate <code>R_max</code>.
</p>
<p>If no maximum is imposed on the reproduction rate
(<code class="reqn">R_{max} = \infty</code>) then the resulting density-independent
reproduction rate <code class="reqn">R_{di}</code> is proportional
to the total rate <code class="reqn">E_R</code> at which energy is invested into reproduction,
</p>
<p style="text-align: center;"><code class="reqn">R_{di} = \frac{\rm{erepro}}{2 w_{min}} E_R,</code>
</p>

<p>where the proportionality factor is given by the reproductive efficiency
<code>erepro</code> divided by the egg size <code>w_min</code> to convert energy to egg number and
divided by 2 to account for the two sexes.
</p>
<p>Imposing a finite maximum reproduction rate <code class="reqn">R_{max}</code> leads to a
non-linear relationship between energy invested and eggs hatched. This
density-dependent reproduction rate <code class="reqn">R_{dd}</code> is given as
</p>
<p style="text-align: center;"><code class="reqn">R_{dd} = R_{di}
\frac{R_{max}}{R_{di} + R_{max}}.</code>
</p>

<p>(All quantities in the above equations are species-specific but we dropped
the species index for simplicity.)
</p>
<p>The following plot illustrates the Beverton-Holt density dependence in the
reproduction rate for two different choices of parameters.
<img src="../help/figures/Beverton-Holt-plot-1.png" alt="Beverton-Holt-plot-1.png" />
</p>
<p>This plot shows that a given energy <code class="reqn">E_R</code> invested into reproduction can
lead to the same reproduction rate <code class="reqn">R_{dd}</code> with different choices
of the parameters <code>R_max</code> and <code>erepro</code>. <code>R_max</code> determines the asymptote of
the curve and <code>erepro</code> its initial slope. A higher <code>R_max</code> coupled with a
lower <code>erepro</code> (black curves) can give the same value as a lower <code>R_max</code>
coupled with a higher <code>erepro</code> (blue curves).
</p>
<p>For the given initial state in the MizerParams object <code>params</code> one can
calculate the energy <code class="reqn">E_R</code> that is invested into reproduction by the
mature individuals and the reproduction rate <code class="reqn">R_{dd}</code> that is
required to keep the egg abundance constant. These two values determine the
location of the black dot in the above graph. You then only need one
parameter to select one curve from the family of Beverton-Holt curves going
through that point. This parameter can be <code>erepro</code> or <code>R_max</code>. Instead of
<code>R_max</code> you can alternatively specify the <code>reproduction_level</code> which is the
ratio between the density-dependent reproduction rate <code class="reqn">R_{dd}</code> and
the maximal reproduction rate  <code class="reqn">R_{max}</code>.
</p>
<p>If you do not provide a value for any of the reproduction parameter
arguments, then <code>erepro</code> will be set to the value it has in the current
species parameter data frame. If you do provide one of the reproduction
parameters, this can be either a vector with one value for each
species, or a named vector where the names determine which species are
affected, or a single unnamed value that is then used for all species. Any
species for which the given value is <code>NA</code> will remain unaffected.
</p>
<p>The values for <code>R_max</code> must be larger than <code class="reqn">R_{dd}</code> and can range
up to <code>Inf</code>. If a smaller value is requested a warning is issued and the
value is increased to the value required for a reproduction level of 0.99.
</p>
<p>The values for the <code>reproduction_level</code> must be positive and
less than 1. The values for <code>erepro</code> must be large enough to allow the
required reproduction rate. If a smaller value is requested a warning is
issued and the value is increased to the smallest possible value. The values
for <code>erepro</code> should also be smaller than 1 to be physiologically sensible,
but this is not enforced by the function.
</p>
<p>As can be seen in the graph above, choosing a lower value for <code>R_max</code> or a
higher value for <code>erepro</code> means that near the steady state the reproduction
will be less sensitive to a change in the energy invested into reproduction
and hence less sensitive to changes in the spawning stock biomass or its
energy income. As a result the species will also be less sensitive to
fishing, leading to a higher F_MSY.
</p>


<h3>Value</h3>

<p>A MizerParams object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>params &lt;- NS_params
species_params(params)$erepro
# Attempting to set the same erepro for all species
params &lt;- setBevertonHolt(params, erepro = 0.1)
t(species_params(params)[, c("erepro", "R_max")])
# Setting erepro for some species
params &lt;- setBevertonHolt(params, erepro = c("Gurnard" = 0.6, "Plaice" = 0.95))
t(species_params(params)[, c("erepro", "R_max")])
# Setting R_max
R_max &lt;- 1e17 * species_params(params)$w_max^-1
params &lt;- setBevertonHolt(NS_params, R_max = R_max)
t(species_params(params)[, c("erepro", "R_max")])
# Setting reproduction_level
params &lt;- setBevertonHolt(params, reproduction_level = 0.3)
t(species_params(params)[, c("erepro", "R_max")])
</code></pre>

<hr>
<h2 id='setColours'>Set line colours and line types to be used in mizer plots</h2><span id='topic+setColours'></span><span id='topic+getColours'></span><span id='topic+setLinetypes'></span><span id='topic+getLinetypes'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
Used for setting the colour and type of lines representing &quot;Total&quot;,
&quot;Resource&quot;, &quot;Fishing&quot;, &quot;Background&quot;, &quot;External&quot; and possibly other categories
in plots.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setColours(params, colours)

getColours(params)

setLinetypes(params, linetypes)

getLinetypes(params)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setColours_+3A_params">params</code></td>
<td>
<p>A MizerParams object</p>
</td></tr>
<tr><td><code id="setColours_+3A_colours">colours</code></td>
<td>
<p>A named list or named vector of line colours.</p>
</td></tr>
<tr><td><code id="setColours_+3A_linetypes">linetypes</code></td>
<td>
<p>A named list or named vector of linetypes.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Colours for names that already had a colour set for them will be overwritten
by the colour you specify. Colours for names that did not yet have a colour
will be appended to the list of colours.
</p>
<p>Do not use this for setting the colours or linetypes of species, because
those are determined by setting the <code>linecolour</code> and <code>linetype</code> variables in
the species parameter data frame.
</p>
<p>You can use the same colours in your own ggplot2 plots by adding
<code>scale_colour_manual(values = getColours(params))</code> to your plot. Similarly
you can use the linetypes with
<code>scale_linetype_manual(values = getLinetypes(params))</code>.
</p>


<h3>Value</h3>

<p><code>setColours</code>: The MizerParams object with updated line colours
</p>
<p><code>getColours()</code>: A named vector of colours
</p>
<p><code>setLinetypes()</code>: The MizerParams object with updated linetypes
</p>
<p><code>getLinetypes()</code>: A named vector of linetypes
</p>


<h3>Examples</h3>

<pre><code class='language-R'>params &lt;- setColours(NS_params, list("Resource" = "red","Total" = "#0000ff"))
params &lt;- setLinetypes(NS_params, list("Total" = "dotted"))
# Set colours and linetypes for species
species_params(params)["Cod", "linecolour"] &lt;- "black"
species_params(params)["Cod", "linetype"] &lt;- "dashed"
plotSpectra(params, total = TRUE)
getColours(params)
getLinetypes(params)
</code></pre>

<hr>
<h2 id='setComponent'>Add a dynamical ecosystem component</h2><span id='topic+setComponent'></span><span id='topic+removeComponent'></span>

<h3>Description</h3>

<p>By default, mizer models any number of size-resolved consumer species
and a single size-resolved resource spectrum. Your model may require
additional components, like for example detritus or carrion or multiple
resources or .... This function allows you to set up such components.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setComponent(
  params,
  component,
  initial_value,
  dynamics_fun,
  encounter_fun,
  mort_fun,
  component_params
)

removeComponent(params, component)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setComponent_+3A_params">params</code></td>
<td>
<p>A MizerParams object</p>
</td></tr>
<tr><td><code id="setComponent_+3A_component">component</code></td>
<td>
<p>Name of the component</p>
</td></tr>
<tr><td><code id="setComponent_+3A_initial_value">initial_value</code></td>
<td>
<p>Initial value of the component</p>
</td></tr>
<tr><td><code id="setComponent_+3A_dynamics_fun">dynamics_fun</code></td>
<td>
<p>Name of function to calculate value at the next time step</p>
</td></tr>
<tr><td><code id="setComponent_+3A_encounter_fun">encounter_fun</code></td>
<td>
<p>Name of function to calculate contribution to encounter
rate. Optional.</p>
</td></tr>
<tr><td><code id="setComponent_+3A_mort_fun">mort_fun</code></td>
<td>
<p>Name of function to calculate contribution to the
mortality rate. Optional.</p>
</td></tr>
<tr><td><code id="setComponent_+3A_component_params">component_params</code></td>
<td>
<p>Object holding the parameters needed by the component
functions. This could for example be a named list of parameters. Optional.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The component can be a number, a vector, an array, a list, or any other
data structure you like.
</p>
<p>If you set a component with a new name, the new component will be added
to the existing components. If you set a component with an existing name,
that component will be overwritten. You can remove a component with
<code>removeComponent()</code>.
</p>


<h3>Value</h3>

<p>The updated MizerParams object
</p>

<hr>
<h2 id='setExtEncounter'>Set external encounter rate</h2><span id='topic+setExtEncounter'></span><span id='topic+getExtEncounter'></span><span id='topic+ext_encounter'></span><span id='topic+ext_encounter+3C-'></span>

<h3>Description</h3>

<p>Set external encounter rate
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setExtEncounter(params, ext_encounter = NULL, ...)

getExtEncounter(params)

ext_encounter(params)

ext_encounter(params) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setExtEncounter_+3A_params">params</code></td>
<td>
<p>MizerParams</p>
</td></tr>
<tr><td><code id="setExtEncounter_+3A_ext_encounter">ext_encounter</code></td>
<td>
<p>Optional. An array (species x size) holding the external
encounter rate.  If not supplied, a default of 0 is used.</p>
</td></tr>
<tr><td><code id="setExtEncounter_+3A_...">...</code></td>
<td>
<p>Unused</p>
</td></tr>
<tr><td><code id="setExtEncounter_+3A_value">value</code></td>
<td>
<p>ext_encounter</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>setExtEncounter()</code>: A MizerParams object with updated external encounter
rate.
</p>
<p><code>getExtEncounter()</code> or equivalently <code>ext_encounter()</code>: An array
(species x size) with the external encounter rate.
</p>


<h3>Setting external encounter rate</h3>

<p>The external encounter rate is the rate at which a predator encounters
food that is not explicitly modelled. It is a rate with units mass/year.
</p>
<p>The <code>ext_encounter</code> argument allows you to specify an external encounter rate
that depends on species and body size. You can see an example of this in
the Examples section of the help page for <code><a href="#topic+setExtEncounter">setExtEncounter()</a></code>.
</p>


<h3>See Also</h3>

<p>Other functions for setting parameters: 
<code><a href="#topic+gear_params">gear_params</a>()</code>,
<code><a href="#topic+setExtMort">setExtMort</a>()</code>,
<code><a href="#topic+setFishing">setFishing</a>()</code>,
<code><a href="#topic+setInitialValues">setInitialValues</a>()</code>,
<code><a href="#topic+setInteraction">setInteraction</a>()</code>,
<code><a href="#topic+setMaxIntakeRate">setMaxIntakeRate</a>()</code>,
<code><a href="#topic+setMetabolicRate">setMetabolicRate</a>()</code>,
<code><a href="#topic+setParams">setParams</a>()</code>,
<code><a href="#topic+setPredKernel">setPredKernel</a>()</code>,
<code><a href="#topic+setReproduction">setReproduction</a>()</code>,
<code><a href="#topic+setSearchVolume">setSearchVolume</a>()</code>,
<code><a href="#topic+species_params">species_params</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>params &lt;- newMultispeciesParams(NS_species_params)

#### Setting allometric encounter rate #######################

# Set coefficient for each species. Here we choose 0.1 for each species
encounter_pre &lt;- rep(0.1, nrow(species_params(params)))

# Multiply by power of size with exponent, here chosen to be 3/4
# The outer() function makes it an array species x size
allo_encounter &lt;- outer(encounter_pre, w(params)^(3/4))

# Change the external encounter rate in the params object
ext_encounter(params) &lt;- allo_encounter
</code></pre>

<hr>
<h2 id='setExtMort'>Set external mortality rate</h2><span id='topic+setExtMort'></span><span id='topic+getExtMort'></span><span id='topic+ext_mort'></span><span id='topic+ext_mort+3C-'></span>

<h3>Description</h3>

<p>Set external mortality rate
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setExtMort(
  params,
  ext_mort = NULL,
  z0pre = 0.6,
  z0exp = -1/4,
  reset = FALSE,
  z0 = deprecated(),
  ...
)

getExtMort(params)

ext_mort(params)

ext_mort(params) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setExtMort_+3A_params">params</code></td>
<td>
<p>MizerParams</p>
</td></tr>
<tr><td><code id="setExtMort_+3A_ext_mort">ext_mort</code></td>
<td>
<p>Optional. An array (species x size) holding the external
mortality rate.  If not supplied, a default is set as described in the
section &quot;Setting external mortality rate&quot;.</p>
</td></tr>
<tr><td><code id="setExtMort_+3A_z0pre">z0pre</code></td>
<td>
<p>If <code>z0</code>, the mortality from other sources, is not a column
in the species data frame, it is calculated as z0pre * w_max ^ z0exp.
Default value is 0.6.</p>
</td></tr>
<tr><td><code id="setExtMort_+3A_z0exp">z0exp</code></td>
<td>
<p>If <code>z0</code>, the mortality from other sources, is not a column in
the species data frame, it is calculated as <code>z0pre * w_max ^ z0exp</code>.
Default value is <code>n-1</code>.</p>
</td></tr>
<tr><td><code id="setExtMort_+3A_reset">reset</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
If set to TRUE, then the external mortality rate will be reset
to the value calculated from the <code>z0</code> parameters, even if it was
previously overwritten with a custom value. If set to FALSE (default) then
a recalculation from the species parameters will take place only if no
custom value has been set.</p>
</td></tr>
<tr><td><code id="setExtMort_+3A_z0">z0</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a> Use <code>ext_mort</code> instead. Not to
be confused with the species_parameter <code>z0</code>.</p>
</td></tr>
<tr><td><code id="setExtMort_+3A_...">...</code></td>
<td>
<p>Unused</p>
</td></tr>
<tr><td><code id="setExtMort_+3A_value">value</code></td>
<td>
<p>ext_mort</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>setExtMort()</code>: A MizerParams object with updated external mortality
rate.
</p>
<p><code>getExtMort()</code> or equivalently <code>ext_mort()</code>: An array (species x
size) with the external mortality.
</p>


<h3>Setting external mortality rate</h3>

<p>The external mortality is all the mortality that is not due to fishing or
predation by predators included in the model. The external mortality could be
due to predation by predators that are not explicitly included in the model
(e.g. mammals or seabirds) or due to other causes like illness. It is a rate
with units 1/year.
</p>
<p>The <code>ext_mort</code> argument allows you to specify an external mortality rate
that depends on species and body size. You can see an example of this in
the Examples section of the help page for <code><a href="#topic+setExtMort">setExtMort()</a></code>.
</p>
<p>If the <code>ext_mort</code> argument is not supplied, then the external mortality is
assumed to depend only on the species, not on the size of the individual:
<code class="reqn">\mu_{ext.i}(w) = z_{0.i}</code>. The value of the constant <code class="reqn">z_0</code> for each
species is taken from the <code>z0</code> column of the species parameter data frame, if
that column exists. Otherwise it is calculated as
</p>
<p style="text-align: center;"><code class="reqn">z_{0.i} = {\tt z0pre}_i\, w_{inf}^{\tt z0exp}.</code>
</p>



<h3>See Also</h3>

<p>Other functions for setting parameters: 
<code><a href="#topic+gear_params">gear_params</a>()</code>,
<code><a href="#topic+setExtEncounter">setExtEncounter</a>()</code>,
<code><a href="#topic+setFishing">setFishing</a>()</code>,
<code><a href="#topic+setInitialValues">setInitialValues</a>()</code>,
<code><a href="#topic+setInteraction">setInteraction</a>()</code>,
<code><a href="#topic+setMaxIntakeRate">setMaxIntakeRate</a>()</code>,
<code><a href="#topic+setMetabolicRate">setMetabolicRate</a>()</code>,
<code><a href="#topic+setParams">setParams</a>()</code>,
<code><a href="#topic+setPredKernel">setPredKernel</a>()</code>,
<code><a href="#topic+setReproduction">setReproduction</a>()</code>,
<code><a href="#topic+setSearchVolume">setSearchVolume</a>()</code>,
<code><a href="#topic+species_params">species_params</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>params &lt;- newMultispeciesParams(NS_species_params)

#### Setting allometric death rate #######################

# Set coefficient for each species. Here we choose 0.1 for each species
z0pre &lt;- rep(0.1, nrow(species_params(params)))

# Multiply by power of size with exponent, here chosen to be -1/4
# The outer() function makes it an array species x size
allo_mort &lt;- outer(z0pre, w(params)^(-1/4))

# Change the external mortality rate in the params object
ext_mort(params) &lt;- allo_mort
</code></pre>

<hr>
<h2 id='setFishing'>Set fishing parameters</h2><span id='topic+setFishing'></span><span id='topic+getCatchability'></span><span id='topic+catchability'></span><span id='topic+catchability+3C-'></span><span id='topic+getSelectivity'></span><span id='topic+selectivity'></span><span id='topic+selectivity+3C-'></span><span id='topic+getInitialEffort'></span>

<h3>Description</h3>

<p>Set fishing parameters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setFishing(
  params,
  selectivity = NULL,
  catchability = NULL,
  reset = FALSE,
  initial_effort = NULL,
  ...
)

getCatchability(params)

catchability(params)

catchability(params) &lt;- value

getSelectivity(params)

selectivity(params)

selectivity(params) &lt;- value

getInitialEffort(params)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setFishing_+3A_params">params</code></td>
<td>
<p>A MizerParams object</p>
</td></tr>
<tr><td><code id="setFishing_+3A_selectivity">selectivity</code></td>
<td>
<p>Optional. An array (gear x species x size) that holds the
selectivity of each gear for species and size, <code class="reqn">S_{g,i,w}</code>.</p>
</td></tr>
<tr><td><code id="setFishing_+3A_catchability">catchability</code></td>
<td>
<p>Optional. An array (gear x species) that holds the catchability of
each species by each gear, <code class="reqn">Q_{g,i}</code>.</p>
</td></tr>
<tr><td><code id="setFishing_+3A_reset">reset</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
If set to TRUE, then both <code>catchability</code> and <code>selectivity</code> will
be reset to the values calculated from the gear parameters, even if it was
previously overwritten with a custom value. If set to FALSE (default) then
a recalculation from the gear parameters will take place only if no custom
value has been set.</p>
</td></tr>
<tr><td><code id="setFishing_+3A_initial_effort">initial_effort</code></td>
<td>
<p>Optional. A number or a named numeric vector specifying
the fishing effort. If a number, the same effort is used for all gears. If
a vector, must be named by gear.</p>
</td></tr>
<tr><td><code id="setFishing_+3A_...">...</code></td>
<td>
<p>Unused</p>
</td></tr>
<tr><td><code id="setFishing_+3A_value">value</code></td>
<td>
<p>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>setFishing()</code>: A MizerParams object with updated fishing
parameters.
</p>
<p><code>getCatchability()</code> or equivalently <code>catchability()</code>: An array (gear
x species) that holds the catchability of each species by each gear,
<code class="reqn">Q_{g,i}</code>. The names of the dimensions are &quot;gear, &quot;sp&quot;.
</p>
<p><code>getSelectivity()</code> or equivalently <code>selectivity()</code>: An array (gear x
species x size) that holds the selectivity of each gear for species and
size, <code class="reqn">S_{g,i,w}</code>. The names of the dimensions are &quot;gear, &quot;sp&quot;, &quot;w&quot;.
</p>
<p><code>getInitialEffort()</code> or equivalently <code>initial_effort()</code>: A named
vector with the initial fishing effort for each gear.
</p>


<h3>Setting fishing</h3>

<p><strong>Gears</strong>
</p>
<p>In <code>mizer</code>, fishing mortality is imposed on species by fishing gears. The
total per-capita fishing mortality (1/year) is obtained by summing over the
mortality from all gears,
</p>
<p style="text-align: center;"><code class="reqn">\mu_{f.i}(w) = \sum_g F_{g,i}(w),</code>
</p>

<p>where the fishing mortality <code class="reqn">F_{g,i}(w)</code> imposed by gear <code class="reqn">g</code> on
species <code class="reqn">i</code> at size <code class="reqn">w</code> is calculated as:
</p>
<p style="text-align: center;"><code class="reqn">F_{g,i}(w) = S_{g,i}(w) Q_{g,i} E_{g},</code>
</p>

<p>where <code class="reqn">S</code> is the selectivity by species, gear and size, <code class="reqn">Q</code> is the
catchability by species and gear and <code class="reqn">E</code> is the fishing effort by gear.
</p>
<p><strong>Selectivity</strong>
</p>
<p>The selectivity at size of each gear for each species is saved as a three
dimensional array (gear x species x size). Each entry has a range between 0
(that gear is not selecting that species at that size) to 1 (that gear is
selecting all individuals of that species of that size). This three
dimensional array can be specified explicitly via the <code>selectivity</code>
argument, but usually mizer calculates it from the <code>gear_params</code> slot of
the MizerParams object.
</p>
<p>To allow the calculation of the <code>selectivity</code> array, the <code>gear_params</code> slot
must be a data frame with one row for each gear-species combination. So if
for example a gear can select three species, then that gear contributes three
rows to the <code>gear_params</code> data frame, one for each species it can select. The
data frame must have columns <code>gear</code>, holding the name of the gear, <code>species</code>,
holding the name of the species, and <code>sel_func</code>, holding the name of the
function that calculates the selectivity curve. Some selectivity functions
are included in the package: <code>knife_edge()</code>, <code>sigmoid_length()</code>,
<code>double_sigmoid_length()</code>, and <code>sigmoid_weight()</code>.
Users are able to write their own size-based selectivity function. The first
argument to the function must be <code>w</code> and the function must return a vector of
the selectivity (between 0 and 1) at size.
</p>
<p>Each selectivity function may have parameters. Values for these
parameters must be included as columns in the gear parameters data.frame.
The names of the columns must exactly match the names of the corresponding
arguments of the selectivity function. For example, the default selectivity
function is <code>knife_edge()</code> that a has sudden change of selectivity from 0 to 1
at a certain size. In its help page you can see that the <code>knife_edge()</code>
function has arguments <code>w</code> and <code>knife_edge_size</code>. The first argument, <code>w</code>, is
size (the function calculates selectivity at size). All selectivity functions
must have <code>w</code> as the first argument. The values for the other arguments must
be found in the gear parameters data.frame. So for the <code>knife_edge()</code>
function there should be a <code>knife_edge_size</code> column. Because <code>knife_edge()</code>
is the default selectivity function, the <code>knife_edge_size</code> argument has a
default value = <code>w_mat</code>.
</p>
<p>In case each species is only selected by one gear, the columns of the
<code>gear_params</code> data frame can alternatively be provided as columns of the
<code>species_params</code> data frame, if this is more convenient for the user to set
up. Mizer will then copy these columns over to create the <code>gear_params</code> data
frame when it creates the MizerParams object. However changing these columns
in the species parameter data frame later will not update the <code>gear_params</code>
data frame.
</p>
<p><strong>Catchability</strong>
</p>
<p>Catchability is used as an additional factor to make the link between gear
selectivity, fishing effort and fishing mortality. For example, it can be set
so that an effort of 1 gives a desired fishing mortality. In this way effort
can then be specified relative to a 'base effort', e.g. the effort in a
particular year.
</p>
<p>Catchability is stored as a two dimensional array (gear x species). This can
either be provided explicitly via the <code>catchability</code> argument, or the
information can be provided via a <code>catchability</code> column in the <code>gear_params</code>
data frame.
</p>
<p>In the case where each species is selected by only a single gear, the
<code>catchability</code> column can also be provided in the <code>species_params</code> data
frame. Mizer will then copy this over to the <code>gear_params</code> data frame when
the MizerParams object is created.
</p>
<p><strong>Effort</strong>
</p>
<p>The initial fishing effort is stored in the <code>MizerParams</code> object. If it is
not supplied, it is set to zero. The initial effort can be overruled when
the simulation is run with <code>project()</code>, where it is also possible to specify
an effort that varies through time.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gear_params">gear_params()</a></code>
</p>
<p>Other functions for setting parameters: 
<code><a href="#topic+gear_params">gear_params</a>()</code>,
<code><a href="#topic+setExtEncounter">setExtEncounter</a>()</code>,
<code><a href="#topic+setExtMort">setExtMort</a>()</code>,
<code><a href="#topic+setInitialValues">setInitialValues</a>()</code>,
<code><a href="#topic+setInteraction">setInteraction</a>()</code>,
<code><a href="#topic+setMaxIntakeRate">setMaxIntakeRate</a>()</code>,
<code><a href="#topic+setMetabolicRate">setMetabolicRate</a>()</code>,
<code><a href="#topic+setParams">setParams</a>()</code>,
<code><a href="#topic+setPredKernel">setPredKernel</a>()</code>,
<code><a href="#topic+setReproduction">setReproduction</a>()</code>,
<code><a href="#topic+setSearchVolume">setSearchVolume</a>()</code>,
<code><a href="#topic+species_params">species_params</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>str(getCatchability(NS_params))
str(getSelectivity(NS_params))
str(getInitialEffort(NS_params))
</code></pre>

<hr>
<h2 id='setInitialValues'>Set initial values to values from a simulation</h2><span id='topic+setInitialValues'></span>

<h3>Description</h3>

<p>This is used to use the results from one simulation as the starting values
for another simulation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setInitialValues(params, sim, time_range, geometric_mean = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setInitialValues_+3A_params">params</code></td>
<td>
<p>A <code>MizerParams</code> object in which to set the initial values</p>
</td></tr>
<tr><td><code id="setInitialValues_+3A_sim">sim</code></td>
<td>
<p>A <code>MizerSim</code> object from which to take the values.</p>
</td></tr>
<tr><td><code id="setInitialValues_+3A_time_range">time_range</code></td>
<td>
<p>The time range to average the abundances over. Can be a
vector of values, a vector of min and max time, or a single value. Only the
range of times is relevant, i.e., all times between the smallest and
largest will be selected.  Default is the final time step.</p>
</td></tr>
<tr><td><code id="setInitialValues_+3A_geometric_mean">geometric_mean</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
If TRUE then the average of the abundances over the
time range is a geometric mean instead of the default arithmetic mean. This
does not affect the average of the effort or of other components, which is
always arithmetic.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The initial abundances (for both species and resource) in the <code>params</code>
object are set to the abundances in a MizerSim object, averaged over
a range of times. Similarly, the initial effort in the <code>params</code> object is
set to the effort in the MizerSim object, again averaged over that range
of times.
When no time range is specified, the initial values are taken from the final
time step of the simulation.
</p>
<p>If the model described by <code>sim</code> and <code>params</code> has additional components
created with <code><a href="#topic+setComponent">setComponent()</a></code> then the values of these components are also
averaged and copied to <code>params</code>.
</p>
<p>The MizerSim object must come from a model with the same set of species and
gears and other components and the same size bins as the MizerParams object.
Otherwise an error is raised.
</p>


<h3>Value</h3>

<p>The <code>params</code> object with updated initial values and initial effort.
Because of the way the
R language works, <code>setInitialValues()</code> does not make the changes to the
params object that you pass to it but instead returns a new params object.
So to affect the change you call the function in the form
<code>params &lt;- setInitialValues(params, sim)</code>.
</p>


<h3>See Also</h3>

<p>Other functions for setting parameters: 
<code><a href="#topic+gear_params">gear_params</a>()</code>,
<code><a href="#topic+setExtEncounter">setExtEncounter</a>()</code>,
<code><a href="#topic+setExtMort">setExtMort</a>()</code>,
<code><a href="#topic+setFishing">setFishing</a>()</code>,
<code><a href="#topic+setInteraction">setInteraction</a>()</code>,
<code><a href="#topic+setMaxIntakeRate">setMaxIntakeRate</a>()</code>,
<code><a href="#topic+setMetabolicRate">setMetabolicRate</a>()</code>,
<code><a href="#topic+setParams">setParams</a>()</code>,
<code><a href="#topic+setPredKernel">setPredKernel</a>()</code>,
<code><a href="#topic+setReproduction">setReproduction</a>()</code>,
<code><a href="#topic+setSearchVolume">setSearchVolume</a>()</code>,
<code><a href="#topic+species_params">species_params</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
params &lt;- NS_params
sim &lt;- project(params, t_max = 20, effort = 0.5)
params &lt;- setInitialValues(params, sim)

</code></pre>

<hr>
<h2 id='setInteraction'>Set species interaction matrix</h2><span id='topic+setInteraction'></span><span id='topic+interaction_matrix'></span><span id='topic+interaction_matrix+3C-'></span>

<h3>Description</h3>

<p>Set species interaction matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setInteraction(params, interaction = NULL)

interaction_matrix(params)

interaction_matrix(params) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setInteraction_+3A_params">params</code></td>
<td>
<p>MizerParams object</p>
</td></tr>
<tr><td><code id="setInteraction_+3A_interaction">interaction</code></td>
<td>
<p>Optional interaction matrix of the species (predator
species x prey species). By default all entries are 1. See &quot;Setting
interaction matrix&quot; section below.</p>
</td></tr>
<tr><td><code id="setInteraction_+3A_value">value</code></td>
<td>
<p>An interaction matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>setInteraction</code>: A MizerParams object with updated interaction
matrix
</p>
<p><code>interaction_matrix()</code>: The interaction matrix (predator species x
prey species)
</p>


<h3>Setting interaction matrix</h3>

<p>You do not need to specify an interaction matrix. If you do not, then the
predator-prey interactions are purely determined by the size of predator
and prey and totally independent of the species of predator and prey.
</p>
<p>The interaction matrix <code class="reqn">\theta_{ij}</code> modifies the interaction of each
pair of species in the model. This can be used for example to allow for
different spatial overlap among the species.
The values in the interaction matrix are used to scale the encountered food
and predation mortality (see on the website <a href="https://sizespectrum.org/mizer/articles/model_description.html#sec:pref">the section on predator-prey encounter rate</a>
and on <a href="https://sizespectrum.org/mizer/articles/model_description.html#mortality">predation mortality</a>).
The first index refers to the predator species and the second to the prey
species.
</p>
<p>The interaction matrix is used when calculating the food encounter rate in
<code><a href="#topic+getEncounter">getEncounter()</a></code> and the predation mortality rate in <code><a href="#topic+getPredMort">getPredMort()</a></code>. Its
entries are dimensionless numbers. If all the values in the interaction
matrix are equal then predator-prey interactions are determined entirely by
size-preference.
</p>
<p>This function checks that the supplied interaction matrix is valid and then
stores it in the <code>interaction</code> slot of the <code>params</code> object.
</p>
<p>The order of the columns and rows of the <code>interaction</code> argument should be
the same as the order in the species params data frame in the <code>params</code>
object. If you supply a named array then the function will check the order
and warn if it is different. One way of creating your own interaction
matrix is to enter the data using a spreadsheet program and saving it as a
.csv file. The data can then be read into R using the command <code>read.csv()</code>.
</p>
<p>The interaction of the species with the resource are set via a column
<code>interaction_resource</code> in the <code>species_params</code> data frame. By default this
column is set to all 1s.
</p>


<h3>See Also</h3>

<p>Other functions for setting parameters: 
<code><a href="#topic+gear_params">gear_params</a>()</code>,
<code><a href="#topic+setExtEncounter">setExtEncounter</a>()</code>,
<code><a href="#topic+setExtMort">setExtMort</a>()</code>,
<code><a href="#topic+setFishing">setFishing</a>()</code>,
<code><a href="#topic+setInitialValues">setInitialValues</a>()</code>,
<code><a href="#topic+setMaxIntakeRate">setMaxIntakeRate</a>()</code>,
<code><a href="#topic+setMetabolicRate">setMetabolicRate</a>()</code>,
<code><a href="#topic+setParams">setParams</a>()</code>,
<code><a href="#topic+setPredKernel">setPredKernel</a>()</code>,
<code><a href="#topic+setReproduction">setReproduction</a>()</code>,
<code><a href="#topic+setSearchVolume">setSearchVolume</a>()</code>,
<code><a href="#topic+species_params">species_params</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>params &lt;- newTraitParams(no_sp = 3)
inter &lt;- getInteraction(params)
inter[1, 2:3] &lt;- 0
params &lt;- setInteraction(params, interaction = inter)
getInteraction(params)
</code></pre>

<hr>
<h2 id='setMaxIntakeRate'>Set maximum intake rate</h2><span id='topic+setMaxIntakeRate'></span><span id='topic+getMaxIntakeRate'></span><span id='topic+intake_max'></span><span id='topic+intake_max+3C-'></span>

<h3>Description</h3>

<p>Set maximum intake rate
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setMaxIntakeRate(params, intake_max = NULL, reset = FALSE, ...)

getMaxIntakeRate(params)

intake_max(params)

intake_max(params) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setMaxIntakeRate_+3A_params">params</code></td>
<td>
<p>MizerParams</p>
</td></tr>
<tr><td><code id="setMaxIntakeRate_+3A_intake_max">intake_max</code></td>
<td>
<p>Optional. An array (species x size) holding the maximum
intake rate for each species at size. If not supplied, a default is set as
described in the section &quot;Setting maximum intake rate&quot;.</p>
</td></tr>
<tr><td><code id="setMaxIntakeRate_+3A_reset">reset</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
If set to TRUE, then the intake rate will be reset to the value
calculated from the species parameters, even if it was previously
overwritten with a custom value. If set to FALSE (default) then a
recalculation from the species parameters will take place only if no
custom value has been set.</p>
</td></tr>
<tr><td><code id="setMaxIntakeRate_+3A_...">...</code></td>
<td>
<p>Unused</p>
</td></tr>
<tr><td><code id="setMaxIntakeRate_+3A_value">value</code></td>
<td>
<p>intake_max</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>setReproduction()</code>: A MizerParams object with updated maximum
intake rate.
</p>
<p><code>getMaxIntakeRate()</code> or equivalently <code>intake_max()</code>: An array
(species x size) with the maximum intake rate.
</p>


<h3>Setting maximum intake rate</h3>

<p>The maximum intake rate <code class="reqn">h_i(w)</code> of an individual of species <code class="reqn">i</code> and
weight <code class="reqn">w</code> determines the feeding level, calculated with
<code><a href="#topic+getFeedingLevel">getFeedingLevel()</a></code>. It is measured in grams/year.
</p>
<p>If the <code>intake_max</code> argument is not supplied, then the maximum intake
rate is set to </p>
<p style="text-align: center;"><code class="reqn">h_i(w) = h_i w^{n_i}.</code>
</p>

<p>The values of <code class="reqn">h_i</code> (the maximum intake rate of an individual of size 1
gram) and <code class="reqn">n_i</code> (the allometric exponent for the intake rate) are taken
from the <code>h</code> and <code>n</code> columns in the species parameter dataframe. If
the <code>h</code> column is not supplied in the species parameter dataframe, it is
calculated by the <code><a href="#topic+get_h_default">get_h_default()</a></code> function.
</p>
<p>If <code class="reqn">h_i</code> is set to <code>Inf</code>, fish of species i will consume all encountered
food.
</p>


<h3>See Also</h3>

<p>Other functions for setting parameters: 
<code><a href="#topic+gear_params">gear_params</a>()</code>,
<code><a href="#topic+setExtEncounter">setExtEncounter</a>()</code>,
<code><a href="#topic+setExtMort">setExtMort</a>()</code>,
<code><a href="#topic+setFishing">setFishing</a>()</code>,
<code><a href="#topic+setInitialValues">setInitialValues</a>()</code>,
<code><a href="#topic+setInteraction">setInteraction</a>()</code>,
<code><a href="#topic+setMetabolicRate">setMetabolicRate</a>()</code>,
<code><a href="#topic+setParams">setParams</a>()</code>,
<code><a href="#topic+setPredKernel">setPredKernel</a>()</code>,
<code><a href="#topic+setReproduction">setReproduction</a>()</code>,
<code><a href="#topic+setSearchVolume">setSearchVolume</a>()</code>,
<code><a href="#topic+species_params">species_params</a>()</code>
</p>

<hr>
<h2 id='setMetabolicRate'>Set metabolic rate</h2><span id='topic+setMetabolicRate'></span><span id='topic+getMetabolicRate'></span><span id='topic+metab'></span><span id='topic+metab+3C-'></span>

<h3>Description</h3>

<p>Sets the rate at which energy is used for metabolism and activity
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setMetabolicRate(params, metab = NULL, p = NULL, reset = FALSE, ...)

getMetabolicRate(params)

metab(params)

metab(params) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setMetabolicRate_+3A_params">params</code></td>
<td>
<p>MizerParams</p>
</td></tr>
<tr><td><code id="setMetabolicRate_+3A_metab">metab</code></td>
<td>
<p>Optional. An array (species x size) holding the metabolic rate
for each species at size. If not supplied, a default is set as described in
the section &quot;Setting metabolic rate&quot;.</p>
</td></tr>
<tr><td><code id="setMetabolicRate_+3A_p">p</code></td>
<td>
<p>The allometric metabolic exponent. This is only used if <code>metab</code>
is not given explicitly and if the exponent is not specified in a <code>p</code>
column in the <code>species_params</code>.</p>
</td></tr>
<tr><td><code id="setMetabolicRate_+3A_reset">reset</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
If set to TRUE, then the metabolic rate will be reset to the
value calculated from the species parameters, even if it was previously
overwritten with a custom value. If set to FALSE (default) then a
recalculation from the species parameters will take place only if no
custom value has been set.</p>
</td></tr>
<tr><td><code id="setMetabolicRate_+3A_...">...</code></td>
<td>
<p>Unused</p>
</td></tr>
<tr><td><code id="setMetabolicRate_+3A_value">value</code></td>
<td>
<p>metab</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>setMetabolicRate()</code>: A MizerParams object with updated metabolic rate.
</p>
<p><code>getMetabolicRate()</code> or equivalently <code>metab()</code>: An array
(species x size) with the metabolic rate.
</p>


<h3>Setting metabolic rate</h3>

<p>The metabolic rate is subtracted from the energy income rate to calculate
the rate at which energy is available for growth and reproduction, see
<code><a href="#topic+getEReproAndGrowth">getEReproAndGrowth()</a></code>. It is measured in grams/year.
</p>
<p>If the <code>metab</code> argument is not supplied, then for each species the
metabolic rate <code class="reqn">k(w)</code> for an individual of size <code class="reqn">w</code> is set to
</p>
<p style="text-align: center;"><code class="reqn">k(w) = k_s w^p + k w,</code>
</p>

<p>where <code class="reqn">k_s w^p</code> represents the rate of standard metabolism and <code class="reqn">k w</code>
is the rate at which energy is expended on activity and movement. The values
of <code class="reqn">k_s</code>, <code class="reqn">p</code> and <code class="reqn">k</code> are taken from the <code>ks</code>, <code>p</code> and
<code>k</code> columns in the species parameter dataframe. If any of these
parameters are not supplied, the defaults are <code class="reqn">k = 0</code>, <code class="reqn">p = n</code> and
</p>
<p style="text-align: center;"><code class="reqn">k_s = f_c h \alpha w_{mat}^{n-p},</code>
</p>

<p>where <code class="reqn">f_c</code> is the critical feeding level taken from the <code>fc</code> column
in the species parameter data frame. If the critical feeding level is not
specified, a default of <code class="reqn">f_c = 0.2</code> is used.
</p>


<h3>See Also</h3>

<p>Other functions for setting parameters: 
<code><a href="#topic+gear_params">gear_params</a>()</code>,
<code><a href="#topic+setExtEncounter">setExtEncounter</a>()</code>,
<code><a href="#topic+setExtMort">setExtMort</a>()</code>,
<code><a href="#topic+setFishing">setFishing</a>()</code>,
<code><a href="#topic+setInitialValues">setInitialValues</a>()</code>,
<code><a href="#topic+setInteraction">setInteraction</a>()</code>,
<code><a href="#topic+setMaxIntakeRate">setMaxIntakeRate</a>()</code>,
<code><a href="#topic+setParams">setParams</a>()</code>,
<code><a href="#topic+setPredKernel">setPredKernel</a>()</code>,
<code><a href="#topic+setReproduction">setReproduction</a>()</code>,
<code><a href="#topic+setSearchVolume">setSearchVolume</a>()</code>,
<code><a href="#topic+species_params">species_params</a>()</code>
</p>

<hr>
<h2 id='setMetadata'>Set metadata for a model</h2><span id='topic+setMetadata'></span><span id='topic+getMetadata'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
Setting metadata is particularly important for sharing your model with
others. All metadata fields are optional and you can also add other fields
of your own choosing. If you set a value
for a field that already existed, the old value will be overwritten.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setMetadata(params, title, description, authors, url, doi, ...)

getMetadata(params)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setMetadata_+3A_params">params</code></td>
<td>
<p>The MizerParams object for the model</p>
</td></tr>
<tr><td><code id="setMetadata_+3A_title">title</code></td>
<td>
<p>A string with the title for the model</p>
</td></tr>
<tr><td><code id="setMetadata_+3A_description">description</code></td>
<td>
<p>A string with a description of the model. This could for
example contain information about any publications using the model.</p>
</td></tr>
<tr><td><code id="setMetadata_+3A_authors">authors</code></td>
<td>
<p>An author entry or a list of author entries, where each author
entry could either be just a name or could itself be a list with fields
like <code>name</code>, <code>orcid</code>, possibly <code>email</code>.</p>
</td></tr>
<tr><td><code id="setMetadata_+3A_url">url</code></td>
<td>
<p>A URL where more information about the model can be found. This
could be a blog post on the mizer blog, for example.</p>
</td></tr>
<tr><td><code id="setMetadata_+3A_doi">doi</code></td>
<td>
<p>The digital object identifier for your model. To create a doi you
can use online services like https://zenodo.org/ or https://figshare.com.</p>
</td></tr>
<tr><td><code id="setMetadata_+3A_...">...</code></td>
<td>
<p>Additional metadata fields that you would like to add</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In addition to the metadata fields you can set by hand, there are four fields
that are set automatically by mizer:
</p>

<ul>
<li> <p><code>mizer_version</code> The version string of the mizer version under which the
model was created or last upgraded. Can be compared to the current version
which is obtained with <code>packageVersion("mizer")</code>. The purpose of this field
is that if the model is not working as expected in the current version of
mizer, you can go back to the older version under which presumably it was
working.
</p>
</li>
<li> <p><code>extensions</code> A named vector of strings where each name is the name of and
extension package needed to run the model and each value is a string giving
the information that the remotes package needs to install the correct version
of the extension package, see https://remotes.r-lib.org/. This field is
set by the extension packages.
</p>
</li>
<li> <p><code>time_created</code> A POSIXct date-time object with the creation time.
</p>
</li>
<li> <p><code>time_modified</code> A POSIXct date-time object with the last modified time.
</p>
</li></ul>



<h3>Value</h3>

<p><code>setMetadata()</code>: The MizerParams object with updated metadata
</p>
<p><code>getMetadata()</code>: A list with all metadata entries that have been set,
including at least
<code>mizer_version</code>, <code>extensions</code>, <code>time_created</code> and <code>time_modified</code>.
</p>

<hr>
<h2 id='setParams'>Set or change any model parameters</h2><span id='topic+setParams'></span>

<h3>Description</h3>

<p>This is a convenient wrapper function calling each of the following
functions
</p>

<ul>
<li> <p><code><a href="#topic+setPredKernel">setPredKernel()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+setSearchVolume">setSearchVolume()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+setInteraction">setInteraction()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+setMaxIntakeRate">setMaxIntakeRate()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+setMetabolicRate">setMetabolicRate()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+setExtMort">setExtMort()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+setReproduction">setReproduction()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+setFishing">setFishing()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+setResource">setResource()</a></code>
</p>
</li></ul>

<p>See the Details section below for a discussion of how to use this function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setParams(params, interaction = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setParams_+3A_params">params</code></td>
<td>
<p>A <a href="#topic+MizerParams-class">MizerParams</a> object</p>
</td></tr>
<tr><td><code id="setParams_+3A_interaction">interaction</code></td>
<td>
<p>Optional interaction matrix of the species (predator
species x prey species). By default all entries are 1. See &quot;Setting
interaction matrix&quot; section below.</p>
</td></tr>
<tr><td><code id="setParams_+3A_...">...</code></td>
<td>

<p>Arguments passed on to <code><a href="#topic+setPredKernel">setPredKernel</a></code>, <code><a href="#topic+setSearchVolume">setSearchVolume</a></code>, <code><a href="#topic+setMaxIntakeRate">setMaxIntakeRate</a></code>, <code><a href="#topic+setMetabolicRate">setMetabolicRate</a></code>, <code><a href="#topic+setExtMort">setExtMort</a></code>, <code><a href="#topic+setReproduction">setReproduction</a></code>, <code><a href="#topic+setFishing">setFishing</a></code>
</p>

<dl>
<dt><code>pred_kernel</code></dt><dd><p>Optional. An array (species x predator size x prey size)
that holds the predation coefficient of each predator at size on each prey
size. If not supplied, a default is set as described in section &quot;Setting
predation kernel&quot;.</p>
</dd>
<dt><code>search_vol</code></dt><dd><p>Optional. An array (species x size) holding the search volume
for each species at size. If not supplied, a default is set as described in
the section &quot;Setting search volume&quot;.</p>
</dd>
<dt><code>intake_max</code></dt><dd><p>Optional. An array (species x size) holding the maximum
intake rate for each species at size. If not supplied, a default is set as
described in the section &quot;Setting maximum intake rate&quot;.</p>
</dd>
<dt><code>metab</code></dt><dd><p>Optional. An array (species x size) holding the metabolic rate
for each species at size. If not supplied, a default is set as described in
the section &quot;Setting metabolic rate&quot;.</p>
</dd>
<dt><code>p</code></dt><dd><p>The allometric metabolic exponent. This is only used if <code>metab</code>
is not given explicitly and if the exponent is not specified in a <code>p</code>
column in the <code>species_params</code>.</p>
</dd>
<dt><code>ext_mort</code></dt><dd><p>Optional. An array (species x size) holding the external
mortality rate.  If not supplied, a default is set as described in the
section &quot;Setting external mortality rate&quot;.</p>
</dd>
<dt><code>z0pre</code></dt><dd><p>If <code>z0</code>, the mortality from other sources, is not a column
in the species data frame, it is calculated as z0pre * w_max ^ z0exp.
Default value is 0.6.</p>
</dd>
<dt><code>z0exp</code></dt><dd><p>If <code>z0</code>, the mortality from other sources, is not a column in
the species data frame, it is calculated as <code>z0pre * w_max ^ z0exp</code>.
Default value is <code>n-1</code>.</p>
</dd>
<dt><code>z0</code></dt><dd><p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a> Use <code>ext_mort</code> instead. Not to
be confused with the species_parameter <code>z0</code>.</p>
</dd>
<dt><code>maturity</code></dt><dd><p>Optional. An array (species x size) that holds the proportion
of individuals of each species at size that are mature. If not supplied, a
default is set as described in the section &quot;Setting reproduction&quot;.</p>
</dd>
<dt><code>repro_prop</code></dt><dd><p>Optional. An array (species x size) that holds the
proportion of consumed energy that a mature individual allocates to
reproduction for each species at size. If not supplied, a default is set as
described in the section &quot;Setting reproduction&quot;.</p>
</dd>
<dt><code>RDD</code></dt><dd><p>The name of the function calculating the density-dependent
reproduction rate from the density-independent rate. Defaults to
&quot;<code><a href="#topic+BevertonHoltRDD">BevertonHoltRDD()</a></code>&quot;.</p>
</dd>
<dt><code>selectivity</code></dt><dd><p>Optional. An array (gear x species x size) that holds the
selectivity of each gear for species and size, <code class="reqn">S_{g,i,w}</code>.</p>
</dd>
<dt><code>catchability</code></dt><dd><p>Optional. An array (gear x species) that holds the catchability of
each species by each gear, <code class="reqn">Q_{g,i}</code>.</p>
</dd>
<dt><code>initial_effort</code></dt><dd><p>Optional. A number or a named numeric vector specifying
the fishing effort. If a number, the same effort is used for all gears. If
a vector, must be named by gear.</p>
</dd>
</dl>
</td></tr>
</table>


<h3>Details</h3>

<p>If you are not happy with the assumptions that mizer makes by default about
the shape of the model functions, for example if you want to change one of
the allometric scaling assumptions, you can do this by providing your
choice as an array in the appropriate argument to <code>setParams()</code>. The
sections below discuss all the model functions that you can change this way.
</p>
<p>Because of the way the R language works, <code>setParams</code> does not make the
changes to the <code>params</code> object that you pass to it but instead returns a new
params object. So to affect the change you call the function in the form
<code>params &lt;- setParams(params, ...)</code>.
</p>
<p>Usually, if you are happy with the way mizer calculates its model functions
from the species parameters and only want to change the values of some
species parameters, you would make those changes in the <code>species_params</code> data
frame contained in the <code>params</code> object using <code><a href="#topic+species_params+3C-">species_params&lt;-()</a></code>.
Here is an example which assumes that
you have have a MizerParams object <code>params</code> in which you just want to change
the <code>gamma</code> parameter of the third species:
</p>
<div class="sourceCode"><pre>species_params(params)$gamma[[3]] &lt;- 1000
</pre></div>
<p>Internally that will actually call <code>setParams()</code> to recalculate any of the
other parameters that are affected by the change in the species parameter.
</p>
<p><code>setParams()</code> will use the species parameters in the <code>params</code> object to
recalculate the values of all the model functions except those for which you
have set custom values.
</p>


<h3>Value</h3>

<p>A <a href="#topic+MizerParams-class">MizerParams</a> object
</p>


<h3>Units in mizer</h3>

<p>Mizer uses grams to measure weight, centimetres to measure lengths, and
years to measure time.
</p>
<p>Mizer is agnostic about whether abundances are given as
</p>

<ol>
<li><p> numbers per area,
</p>
</li>
<li><p> numbers per volume or
</p>
</li>
<li><p> total numbers for the entire study area.
</p>
</li></ol>

<p>You should make the choice most convenient for your application and then
stick with it. If you make choice 1 or 2 you will also have to choose a unit
for area or volume. Your choice will then determine the units for some of
the parameters. This will be mentioned when the parameters are discussed in
the sections below.
</p>
<p>Your choice will also affect the units of the quantities you may want to
calculate with the model. For example, the yield will be in grams/year/m^2 in
case 1 if you choose m^2 as your measure of area, in grams/year/m^3 in case 2
if you choose m^3 as your unit of volume, or simply grams/year in case 3. The
same comment applies for other measures, like total biomass, which will be
grams/area in case 1, grams/volume in case 2 or simply grams in case 3. When
mizer puts units on axes in plots, it will choose the units appropriate for
case 3. So for example in <code><a href="#topic+plotBiomass">plotBiomass()</a></code> it gives the unit as grams.
</p>
<p>You can convert between these choices. For example, if you use case 1, you
need to multiply with the area of the ecosystem to get the total quantity.
If you work with case 2, you need to multiply by both area and the thickness
of the productive layer. In that respect, case 2 is a bit cumbersome. The
function <code><a href="#topic+scaleModel">scaleModel()</a></code> is useful to change the units you are using.
</p>


<h3>Setting interaction matrix</h3>

<p>You do not need to specify an interaction matrix. If you do not, then the
predator-prey interactions are purely determined by the size of predator
and prey and totally independent of the species of predator and prey.
</p>
<p>The interaction matrix <code class="reqn">\theta_{ij}</code> modifies the interaction of each
pair of species in the model. This can be used for example to allow for
different spatial overlap among the species.
The values in the interaction matrix are used to scale the encountered food
and predation mortality (see on the website <a href="https://sizespectrum.org/mizer/articles/model_description.html#sec:pref">the section on predator-prey encounter rate</a>
and on <a href="https://sizespectrum.org/mizer/articles/model_description.html#mortality">predation mortality</a>).
The first index refers to the predator species and the second to the prey
species.
</p>
<p>The interaction matrix is used when calculating the food encounter rate in
<code><a href="#topic+getEncounter">getEncounter()</a></code> and the predation mortality rate in <code><a href="#topic+getPredMort">getPredMort()</a></code>. Its
entries are dimensionless numbers. If all the values in the interaction
matrix are equal then predator-prey interactions are determined entirely by
size-preference.
</p>
<p>This function checks that the supplied interaction matrix is valid and then
stores it in the <code>interaction</code> slot of the <code>params</code> object.
</p>
<p>The order of the columns and rows of the <code>interaction</code> argument should be
the same as the order in the species params data frame in the <code>params</code>
object. If you supply a named array then the function will check the order
and warn if it is different. One way of creating your own interaction
matrix is to enter the data using a spreadsheet program and saving it as a
.csv file. The data can then be read into R using the command <code>read.csv()</code>.
</p>
<p>The interaction of the species with the resource are set via a column
<code>interaction_resource</code> in the <code>species_params</code> data frame. By default this
column is set to all 1s.
</p>


<h3>Setting predation kernel</h3>

<p><strong>Kernel dependent on predator to prey size ratio</strong>
</p>
<p>If the <code>pred_kernel</code> argument is not supplied, then this function sets a
predation kernel that depends only on the ratio of predator mass to prey
mass, not on the two masses independently. The shape of that kernel is then
determined by the <code>pred_kernel_type</code> column in species_params.
</p>
<p>The default for <code>pred_kernel_type</code> is &quot;lognormal&quot;. This will call the function
<code><a href="#topic+lognormal_pred_kernel">lognormal_pred_kernel()</a></code> to calculate the predation kernel.
An alternative pred_kernel type is &quot;box&quot;, implemented by the function
<code><a href="#topic+box_pred_kernel">box_pred_kernel()</a></code>, and &quot;power_law&quot;, implemented by the function
<code><a href="#topic+power_law_pred_kernel">power_law_pred_kernel()</a></code>. These functions require certain species
parameters in the species_params data frame. For the lognormal kernel these
are <code>beta</code> and <code>sigma</code>, for the box kernel they are <code>ppmr_min</code>
and <code>ppmr_max</code>. They are explained in the help pages for the kernel
functions. Except for <code>beta</code> and <code>sigma</code>, no defaults are set for
these parameters. If they are missing from the species_params data frame then
mizer will issue an error message.
</p>
<p>You can use any other string for <code>pred_kernel_type</code>. If for example you
choose &quot;my&quot; then you need to define a function <code>my_pred_kernel</code> that you can
model on the existing functions like <code><a href="#topic+lognormal_pred_kernel">lognormal_pred_kernel()</a></code>.
</p>
<p>When using a kernel that depends on the predator/prey size ratio only, mizer
does not need to store the entire three dimensional array in the MizerParams
object. Such an array can be very big when there is a large number of size
bins. Instead, mizer only needs to store two two-dimensional arrays that hold
Fourier transforms of the feeding kernel function that allow the encounter
rate and the predation rate to be calculated very efficiently. However, if
you need the full three-dimensional array you can calculate it with the
<code><a href="#topic+getPredKernel">getPredKernel()</a></code> function.
</p>
<p><strong>Kernel dependent on both predator and prey size</strong>
</p>
<p>If you want to work with a feeding kernel that depends on predator mass and
prey mass independently, you can specify the full feeding kernel as a
three-dimensional array (predator species x predator size x prey size).
</p>
<p>You should use this option only if a kernel dependent only on the
predator/prey mass ratio is not appropriate. Using a kernel dependent on
predator/prey mass ratio only allows mizer to use fast Fourier transform
methods to significantly reduce the running time of simulations.
</p>
<p>The order of the predator species in <code>pred_kernel</code> should be the same
as the order in the species params dataframe in the <code>params</code> object. If you
supply a named array then the function will check the order and warn if it is
different.
</p>


<h3>Setting search volume</h3>

<p>The search volume <code class="reqn">\gamma_i(w)</code> of an individual of species <code class="reqn">i</code>
and weight <code class="reqn">w</code> multiplies the predation kernel when
calculating the encounter rate in <code><a href="#topic+getEncounter">getEncounter()</a></code> and the
predation rate in <code><a href="#topic+getPredRate">getPredRate()</a></code>.
</p>
<p>The name &quot;search volume&quot; is a bit misleading, because <code class="reqn">\gamma_i(w)</code> does
not have units of volume. It is simply a parameter that determines the rate
of predation. Its units depend on your choice, see section &quot;Units in mizer&quot;.
If you have chosen to work with total abundances, then it is a rate with units
1/year. If you have chosen to work with abundances per m^2 then it has units
of m^2/year. If you have chosen to work with abundances per m^3 then it has
units of m^3/year.
</p>
<p>If the <code>search_vol</code> argument is not supplied, then the search volume is
set to
</p>
<p style="text-align: center;"><code class="reqn">\gamma_i(w) = \gamma_i w^q_i.</code>
</p>

<p>The values of <code class="reqn">\gamma_i</code> (the search volume at 1g) and <code class="reqn">q_i</code> (the
allometric exponent of the search volume) are taken from the <code>gamma</code> and
<code>q</code> columns in the species parameter dataframe. If the <code>gamma</code>
column is not supplied in the species parameter dataframe, a default is
calculated by the <code><a href="#topic+get_gamma_default">get_gamma_default()</a></code> function. Note that only
for predators of size <code class="reqn">w = 1</code> gram is the value of the species parameter
<code class="reqn">\gamma_i</code> the same as the value of the search volume <code class="reqn">\gamma_i(w)</code>.
</p>


<h3>Setting maximum intake rate</h3>

<p>The maximum intake rate <code class="reqn">h_i(w)</code> of an individual of species <code class="reqn">i</code> and
weight <code class="reqn">w</code> determines the feeding level, calculated with
<code><a href="#topic+getFeedingLevel">getFeedingLevel()</a></code>. It is measured in grams/year.
</p>
<p>If the <code>intake_max</code> argument is not supplied, then the maximum intake
rate is set to </p>
<p style="text-align: center;"><code class="reqn">h_i(w) = h_i w^{n_i}.</code>
</p>

<p>The values of <code class="reqn">h_i</code> (the maximum intake rate of an individual of size 1
gram) and <code class="reqn">n_i</code> (the allometric exponent for the intake rate) are taken
from the <code>h</code> and <code>n</code> columns in the species parameter dataframe. If
the <code>h</code> column is not supplied in the species parameter dataframe, it is
calculated by the <code><a href="#topic+get_h_default">get_h_default()</a></code> function.
</p>
<p>If <code class="reqn">h_i</code> is set to <code>Inf</code>, fish of species i will consume all encountered
food.
</p>


<h3>Setting metabolic rate</h3>

<p>The metabolic rate is subtracted from the energy income rate to calculate
the rate at which energy is available for growth and reproduction, see
<code><a href="#topic+getEReproAndGrowth">getEReproAndGrowth()</a></code>. It is measured in grams/year.
</p>
<p>If the <code>metab</code> argument is not supplied, then for each species the
metabolic rate <code class="reqn">k(w)</code> for an individual of size <code class="reqn">w</code> is set to
</p>
<p style="text-align: center;"><code class="reqn">k(w) = k_s w^p + k w,</code>
</p>

<p>where <code class="reqn">k_s w^p</code> represents the rate of standard metabolism and <code class="reqn">k w</code>
is the rate at which energy is expended on activity and movement. The values
of <code class="reqn">k_s</code>, <code class="reqn">p</code> and <code class="reqn">k</code> are taken from the <code>ks</code>, <code>p</code> and
<code>k</code> columns in the species parameter dataframe. If any of these
parameters are not supplied, the defaults are <code class="reqn">k = 0</code>, <code class="reqn">p = n</code> and
</p>
<p style="text-align: center;"><code class="reqn">k_s = f_c h \alpha w_{mat}^{n-p},</code>
</p>

<p>where <code class="reqn">f_c</code> is the critical feeding level taken from the <code>fc</code> column
in the species parameter data frame. If the critical feeding level is not
specified, a default of <code class="reqn">f_c = 0.2</code> is used.
</p>


<h3>Setting external mortality rate</h3>

<p>The external mortality is all the mortality that is not due to fishing or
predation by predators included in the model. The external mortality could be
due to predation by predators that are not explicitly included in the model
(e.g. mammals or seabirds) or due to other causes like illness. It is a rate
with units 1/year.
</p>
<p>The <code>ext_mort</code> argument allows you to specify an external mortality rate
that depends on species and body size. You can see an example of this in
the Examples section of the help page for <code><a href="#topic+setExtMort">setExtMort()</a></code>.
</p>
<p>If the <code>ext_mort</code> argument is not supplied, then the external mortality is
assumed to depend only on the species, not on the size of the individual:
<code class="reqn">\mu_{ext.i}(w) = z_{0.i}</code>. The value of the constant <code class="reqn">z_0</code> for each
species is taken from the <code>z0</code> column of the species parameter data frame, if
that column exists. Otherwise it is calculated as
</p>
<p style="text-align: center;"><code class="reqn">z_{0.i} = {\tt z0pre}_i\, w_{inf}^{\tt z0exp}.</code>
</p>



<h3>Setting external encounter rate</h3>

<p>The external encounter rate is the rate at which a predator encounters
food that is not explicitly modelled. It is a rate with units mass/year.
</p>
<p>The <code>ext_encounter</code> argument allows you to specify an external encounter rate
that depends on species and body size. You can see an example of this in
the Examples section of the help page for <code><a href="#topic+setExtEncounter">setExtEncounter()</a></code>.
</p>


<h3>Setting reproduction</h3>

<p>For each species and at each size, the proportion <code class="reqn">\psi</code> of the
available energy
that is invested into reproduction is the product of two factors: the
proportion <code>maturity</code> of individuals that are mature and the proportion
<code>repro_prop</code> of the energy available to a mature individual that is
invested into reproduction.
</p>


<h4>Maturity ogive</h4>

<p>If the the proportion of individuals that are mature is not supplied via
the <code>maturity</code> argument , then it is set to a sigmoidal
maturity ogive that changes from 0 to 1 at around the maturity size:
</p>
<p style="text-align: center;"><code class="reqn">{\tt maturity}(w) = \left[1+\left(\frac{w}{w_{mat}}\right)^{-U}\right]^{-1}.</code>
</p>

<p>(To avoid clutter, we are not showing the species index in the equations,
although each species has its own maturity ogive.)
The maturity weights are taken from the <code>w_mat</code> column of the
species_params data frame. Any missing maturity weights are set to 1/4 of the
maximum weight in the <code>w_max</code> column.
</p>
<p>The exponent <code class="reqn">U</code> determines the steepness of the maturity ogive. By
default it is chosen as <code class="reqn">U = 10</code>, however this can be overridden by
including a column <code>w_mat25</code> in the species parameter dataframe that
specifies the weight at which 25% of individuals are mature, which sets
<code class="reqn">U = \log(3) / \log(w_{mat} / w_{25}).</code>
</p>
<p>The sigmoidal function given above would strictly reach 1 only asymptotically.
Mizer instead sets the function equal to 1 already at the species'
maximum size, taken from the compulsory <code>w_max</code> column in the
species parameter data frame. Also, for computational simplicity, any
proportion smaller than <code>1e-8</code> is set to <code>0</code>.
</p>



<h4>Investment into reproduction</h4>

<p>If the the energy available to a mature individual that is
invested into reproduction is not supplied via the <code>repro_prop</code> argument,
it is set to the allometric form
</p>
<p style="text-align: center;"><code class="reqn">{\tt repro\_prop}(w) = \left(\frac{w}{w_{max}}\right)^{m-n}.</code>
</p>

<p>Here <code class="reqn">n</code> is the scaling exponent of the energy income rate. Hence
the exponent <code class="reqn">m</code> determines the scaling of the investment into
reproduction for mature individuals. By default it is chosen to be
<code class="reqn">m = 1</code> so that the rate at which energy is invested into reproduction
scales linearly with the size. This default can be overridden by including a
column <code>m</code> in the species parameter dataframe. The maximum sizes
are taken from the compulsory <code>w_max</code> column in the species parameter
data frame.
</p>
<p>The total proportion of energy invested into reproduction of an individual
of size <code class="reqn">w</code> is then
</p>
<p style="text-align: center;"><code class="reqn">\psi(w) = {\tt maturity}(w){\tt repro\_prop}(w)</code>
</p>




<h4>Reproductive efficiency</h4>

<p>The reproductive efficiency <code class="reqn">\epsilon</code>, i.e., the proportion of energy allocated to
reproduction that results in egg biomass, is set through the <code>erepro</code>
column in the species_params data frame. If that is not provided, the default
is set to 1 (which you will want to override). The offspring biomass divided
by the egg biomass gives the rate of egg production, returned by
<code><a href="#topic+getRDI">getRDI()</a></code>:
</p>
<p style="text-align: center;"><code class="reqn">R_{di} = \frac{\epsilon}{2 w_{min}} \int N(w)  E_r(w) \psi(w) \, dw</code>
</p>




<h4>Density dependence</h4>

<p>The stock-recruitment relationship is an emergent phenomenon in mizer, with
several sources of density dependence. Firstly, the amount of energy invested
into reproduction depends on the energy income of the spawners, which is
density-dependent due to competition for prey. Secondly, the proportion of
larvae that grow up to recruitment size depends on the larval mortality,
which depends on the density of predators, and on larval growth rate, which
depends on density of prey.
</p>
<p>Finally, to encode all the density dependence in the stock-recruitment
relationship that is not already included in the other two sources of density
dependence, mizer puts the the density-independent rate of egg production
through a density-dependence function. The result is returned by
<code><a href="#topic+getRDD">getRDD()</a></code>. The name of the density-dependence function is
specified by the <code>RDD</code> argument. The default is the Beverton-Holt
function <code><a href="#topic+BevertonHoltRDD">BevertonHoltRDD()</a></code>, which requires an <code>R_max</code> column
in the species_params data frame giving the maximum egg production rate. If
this column does not exist, it is initialised to <code>Inf</code>, leading to no
density-dependence. Other functions provided by mizer are
<code><a href="#topic+RickerRDD">RickerRDD()</a></code> and <code><a href="#topic+SheperdRDD">SheperdRDD()</a></code> and you can easily use
these as models for writing your own functions.
</p>



<h3>Setting fishing</h3>

<p><strong>Gears</strong>
</p>
<p>In <code>mizer</code>, fishing mortality is imposed on species by fishing gears. The
total per-capita fishing mortality (1/year) is obtained by summing over the
mortality from all gears,
</p>
<p style="text-align: center;"><code class="reqn">\mu_{f.i}(w) = \sum_g F_{g,i}(w),</code>
</p>

<p>where the fishing mortality <code class="reqn">F_{g,i}(w)</code> imposed by gear <code class="reqn">g</code> on
species <code class="reqn">i</code> at size <code class="reqn">w</code> is calculated as:
</p>
<p style="text-align: center;"><code class="reqn">F_{g,i}(w) = S_{g,i}(w) Q_{g,i} E_{g},</code>
</p>

<p>where <code class="reqn">S</code> is the selectivity by species, gear and size, <code class="reqn">Q</code> is the
catchability by species and gear and <code class="reqn">E</code> is the fishing effort by gear.
</p>
<p><strong>Selectivity</strong>
</p>
<p>The selectivity at size of each gear for each species is saved as a three
dimensional array (gear x species x size). Each entry has a range between 0
(that gear is not selecting that species at that size) to 1 (that gear is
selecting all individuals of that species of that size). This three
dimensional array can be specified explicitly via the <code>selectivity</code>
argument, but usually mizer calculates it from the <code>gear_params</code> slot of
the MizerParams object.
</p>
<p>To allow the calculation of the <code>selectivity</code> array, the <code>gear_params</code> slot
must be a data frame with one row for each gear-species combination. So if
for example a gear can select three species, then that gear contributes three
rows to the <code>gear_params</code> data frame, one for each species it can select. The
data frame must have columns <code>gear</code>, holding the name of the gear, <code>species</code>,
holding the name of the species, and <code>sel_func</code>, holding the name of the
function that calculates the selectivity curve. Some selectivity functions
are included in the package: <code>knife_edge()</code>, <code>sigmoid_length()</code>,
<code>double_sigmoid_length()</code>, and <code>sigmoid_weight()</code>.
Users are able to write their own size-based selectivity function. The first
argument to the function must be <code>w</code> and the function must return a vector of
the selectivity (between 0 and 1) at size.
</p>
<p>Each selectivity function may have parameters. Values for these
parameters must be included as columns in the gear parameters data.frame.
The names of the columns must exactly match the names of the corresponding
arguments of the selectivity function. For example, the default selectivity
function is <code>knife_edge()</code> that a has sudden change of selectivity from 0 to 1
at a certain size. In its help page you can see that the <code>knife_edge()</code>
function has arguments <code>w</code> and <code>knife_edge_size</code>. The first argument, <code>w</code>, is
size (the function calculates selectivity at size). All selectivity functions
must have <code>w</code> as the first argument. The values for the other arguments must
be found in the gear parameters data.frame. So for the <code>knife_edge()</code>
function there should be a <code>knife_edge_size</code> column. Because <code>knife_edge()</code>
is the default selectivity function, the <code>knife_edge_size</code> argument has a
default value = <code>w_mat</code>.
</p>
<p>In case each species is only selected by one gear, the columns of the
<code>gear_params</code> data frame can alternatively be provided as columns of the
<code>species_params</code> data frame, if this is more convenient for the user to set
up. Mizer will then copy these columns over to create the <code>gear_params</code> data
frame when it creates the MizerParams object. However changing these columns
in the species parameter data frame later will not update the <code>gear_params</code>
data frame.
</p>
<p><strong>Catchability</strong>
</p>
<p>Catchability is used as an additional factor to make the link between gear
selectivity, fishing effort and fishing mortality. For example, it can be set
so that an effort of 1 gives a desired fishing mortality. In this way effort
can then be specified relative to a 'base effort', e.g. the effort in a
particular year.
</p>
<p>Catchability is stored as a two dimensional array (gear x species). This can
either be provided explicitly via the <code>catchability</code> argument, or the
information can be provided via a <code>catchability</code> column in the <code>gear_params</code>
data frame.
</p>
<p>In the case where each species is selected by only a single gear, the
<code>catchability</code> column can also be provided in the <code>species_params</code> data
frame. Mizer will then copy this over to the <code>gear_params</code> data frame when
the MizerParams object is created.
</p>
<p><strong>Effort</strong>
</p>
<p>The initial fishing effort is stored in the <code>MizerParams</code> object. If it is
not supplied, it is set to zero. The initial effort can be overruled when
the simulation is run with <code>project()</code>, where it is also possible to specify
an effort that varies through time.
</p>


<h3>See Also</h3>

<p>Other functions for setting parameters: 
<code><a href="#topic+gear_params">gear_params</a>()</code>,
<code><a href="#topic+setExtEncounter">setExtEncounter</a>()</code>,
<code><a href="#topic+setExtMort">setExtMort</a>()</code>,
<code><a href="#topic+setFishing">setFishing</a>()</code>,
<code><a href="#topic+setInitialValues">setInitialValues</a>()</code>,
<code><a href="#topic+setInteraction">setInteraction</a>()</code>,
<code><a href="#topic+setMaxIntakeRate">setMaxIntakeRate</a>()</code>,
<code><a href="#topic+setMetabolicRate">setMetabolicRate</a>()</code>,
<code><a href="#topic+setPredKernel">setPredKernel</a>()</code>,
<code><a href="#topic+setReproduction">setReproduction</a>()</code>,
<code><a href="#topic+setSearchVolume">setSearchVolume</a>()</code>,
<code><a href="#topic+species_params">species_params</a>()</code>
</p>

<hr>
<h2 id='setPredKernel'>Set predation kernel</h2><span id='topic+setPredKernel'></span><span id='topic+getPredKernel'></span><span id='topic+pred_kernel'></span><span id='topic+pred_kernel+3C-'></span>

<h3>Description</h3>

<p>The predation kernel determines the distribution of prey sizes that a
predator feeds on. It is used in <code><a href="#topic+getEncounter">getEncounter()</a></code> when calculating
the rate at which food is encountered and in <code><a href="#topic+getPredRate">getPredRate()</a></code> when
calculating the rate at which a prey is predated upon. The predation kernel
can be a function of the predator/prey size ratio or it can be a function of
the predator size and the prey size separately. Both types can be set up with
this function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setPredKernel(params, pred_kernel = NULL, reset = FALSE, ...)

getPredKernel(params)

pred_kernel(params)

pred_kernel(params) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setPredKernel_+3A_params">params</code></td>
<td>
<p>A MizerParams object</p>
</td></tr>
<tr><td><code id="setPredKernel_+3A_pred_kernel">pred_kernel</code></td>
<td>
<p>Optional. An array (species x predator size x prey size)
that holds the predation coefficient of each predator at size on each prey
size. If not supplied, a default is set as described in section &quot;Setting
predation kernel&quot;.</p>
</td></tr>
<tr><td><code id="setPredKernel_+3A_reset">reset</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
If set to TRUE, then the predation kernel will be reset to the
value calculated from the species parameters, even if it was previously
overwritten with a custom value. If set to FALSE (default) then a
recalculation from the species parameters will take place only if no custom
value has been set.</p>
</td></tr>
<tr><td><code id="setPredKernel_+3A_...">...</code></td>
<td>
<p>Unused</p>
</td></tr>
<tr><td><code id="setPredKernel_+3A_value">value</code></td>
<td>
<p>pred_kernel</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>setPredKernel()</code>: A MizerParams object with updated predation kernel.
</p>
<p><code>getPredKernel()</code> or equivalently <code>pred_kernel()</code>: An array (predator
species x predator_size x prey_size)
</p>


<h3>Setting predation kernel</h3>

<p><strong>Kernel dependent on predator to prey size ratio</strong>
</p>
<p>If the <code>pred_kernel</code> argument is not supplied, then this function sets a
predation kernel that depends only on the ratio of predator mass to prey
mass, not on the two masses independently. The shape of that kernel is then
determined by the <code>pred_kernel_type</code> column in species_params.
</p>
<p>The default for <code>pred_kernel_type</code> is &quot;lognormal&quot;. This will call the function
<code><a href="#topic+lognormal_pred_kernel">lognormal_pred_kernel()</a></code> to calculate the predation kernel.
An alternative pred_kernel type is &quot;box&quot;, implemented by the function
<code><a href="#topic+box_pred_kernel">box_pred_kernel()</a></code>, and &quot;power_law&quot;, implemented by the function
<code><a href="#topic+power_law_pred_kernel">power_law_pred_kernel()</a></code>. These functions require certain species
parameters in the species_params data frame. For the lognormal kernel these
are <code>beta</code> and <code>sigma</code>, for the box kernel they are <code>ppmr_min</code>
and <code>ppmr_max</code>. They are explained in the help pages for the kernel
functions. Except for <code>beta</code> and <code>sigma</code>, no defaults are set for
these parameters. If they are missing from the species_params data frame then
mizer will issue an error message.
</p>
<p>You can use any other string for <code>pred_kernel_type</code>. If for example you
choose &quot;my&quot; then you need to define a function <code>my_pred_kernel</code> that you can
model on the existing functions like <code><a href="#topic+lognormal_pred_kernel">lognormal_pred_kernel()</a></code>.
</p>
<p>When using a kernel that depends on the predator/prey size ratio only, mizer
does not need to store the entire three dimensional array in the MizerParams
object. Such an array can be very big when there is a large number of size
bins. Instead, mizer only needs to store two two-dimensional arrays that hold
Fourier transforms of the feeding kernel function that allow the encounter
rate and the predation rate to be calculated very efficiently. However, if
you need the full three-dimensional array you can calculate it with the
<code><a href="#topic+getPredKernel">getPredKernel()</a></code> function.
</p>
<p><strong>Kernel dependent on both predator and prey size</strong>
</p>
<p>If you want to work with a feeding kernel that depends on predator mass and
prey mass independently, you can specify the full feeding kernel as a
three-dimensional array (predator species x predator size x prey size).
</p>
<p>You should use this option only if a kernel dependent only on the
predator/prey mass ratio is not appropriate. Using a kernel dependent on
predator/prey mass ratio only allows mizer to use fast Fourier transform
methods to significantly reduce the running time of simulations.
</p>
<p>The order of the predator species in <code>pred_kernel</code> should be the same
as the order in the species params dataframe in the <code>params</code> object. If you
supply a named array then the function will check the order and warn if it is
different.
</p>


<h3>See Also</h3>

<p>Other functions for setting parameters: 
<code><a href="#topic+gear_params">gear_params</a>()</code>,
<code><a href="#topic+setExtEncounter">setExtEncounter</a>()</code>,
<code><a href="#topic+setExtMort">setExtMort</a>()</code>,
<code><a href="#topic+setFishing">setFishing</a>()</code>,
<code><a href="#topic+setInitialValues">setInitialValues</a>()</code>,
<code><a href="#topic+setInteraction">setInteraction</a>()</code>,
<code><a href="#topic+setMaxIntakeRate">setMaxIntakeRate</a>()</code>,
<code><a href="#topic+setMetabolicRate">setMetabolicRate</a>()</code>,
<code><a href="#topic+setParams">setParams</a>()</code>,
<code><a href="#topic+setReproduction">setReproduction</a>()</code>,
<code><a href="#topic+setSearchVolume">setSearchVolume</a>()</code>,
<code><a href="#topic+species_params">species_params</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Set up a MizerParams object
params &lt;-  NS_params

## If you change predation kernel parameters after setting up a model, 
#  this will be used to recalculate the kernel
species_params(params)["Cod", "beta"] &lt;- 200

## You can change to a different predation kernel type
species_params(params)$ppmr_max &lt;- 4000
species_params(params)$ppmr_min &lt;- 200
species_params(params)$pred_kernel_type &lt;- "box"
plot(w_full(params), getPredKernel(params)["Cod", 100, ], type="l", log="x")

## If you need a kernel that depends also on prey size you need to define
# it yourself.
pred_kernel &lt;- getPredKernel(params)
pred_kernel["Herring", , ] &lt;- sweep(pred_kernel["Herring", , ], 2, 
                                    params@w_full, "*")
params&lt;- setPredKernel(params, pred_kernel = pred_kernel)
</code></pre>

<hr>
<h2 id='setRateFunction'>Set own rate function to replace mizer rate function</h2><span id='topic+setRateFunction'></span><span id='topic+getRateFunction'></span><span id='topic+other_params'></span><span id='topic+other_params+3C-'></span>

<h3>Description</h3>

<p>If the way mizer calculates a fundamental rate entering the model is
not flexible enough for you (for example if you need to introduce time
dependence) then you can write your own functions for calculating that
rate and use <code>setRateFunction()</code> to register it with mizer.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setRateFunction(params, rate, fun)

getRateFunction(params, rate)

other_params(params)

other_params(params) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setRateFunction_+3A_params">params</code></td>
<td>
<p>A MizerParams object</p>
</td></tr>
<tr><td><code id="setRateFunction_+3A_rate">rate</code></td>
<td>
<p>Name of the rate for which a new function is to be set.</p>
</td></tr>
<tr><td><code id="setRateFunction_+3A_fun">fun</code></td>
<td>
<p>Name of the function to use to calculate the rate.</p>
</td></tr>
<tr><td><code id="setRateFunction_+3A_value">value</code></td>
<td>
<p>Values for other parameters</p>
</td></tr>
</table>


<h3>Details</h3>

<p>At each time step during a simulation with the <code><a href="#topic+project">project()</a></code> function, mizer
needs to calculate the instantaneous values of the various rates. By
default it calls the <code><a href="#topic+mizerRates">mizerRates()</a></code> function which creates a list with the
following components:
</p>

<ul>
<li> <p><code>encounter</code> from <code><a href="#topic+mizerEncounter">mizerEncounter()</a></code>
</p>
</li>
<li> <p><code>feeding_level</code> from <code><a href="#topic+mizerFeedingLevel">mizerFeedingLevel()</a></code>
</p>
</li>
<li> <p><code>pred_rate</code> from <code><a href="#topic+mizerPredRate">mizerPredRate()</a></code>
</p>
</li>
<li> <p><code>pred_mort</code> from <code><a href="#topic+mizerPredMort">mizerPredMort()</a></code>
</p>
</li>
<li> <p><code>f_mort</code> from <code><a href="#topic+mizerFMort">mizerFMort()</a></code>
</p>
</li>
<li> <p><code>mort</code> from <code><a href="#topic+mizerMort">mizerMort()</a></code>
</p>
</li>
<li> <p><code>resource_mort</code> from <code><a href="#topic+mizerResourceMort">mizerResourceMort()</a></code>
</p>
</li>
<li> <p><code>e</code> from <code><a href="#topic+mizerEReproAndGrowth">mizerEReproAndGrowth()</a></code>
</p>
</li>
<li> <p><code>e_repro</code> from <code><a href="#topic+mizerERepro">mizerERepro()</a></code>
</p>
</li>
<li> <p><code>e_growth</code> from <code><a href="#topic+mizerEGrowth">mizerEGrowth()</a></code>
</p>
</li>
<li> <p><code>rdi</code> from <code><a href="#topic+mizerRDI">mizerRDI()</a></code>
</p>
</li>
<li> <p><code>rdd</code> from <code><a href="#topic+BevertonHoltRDD">BevertonHoltRDD()</a></code>
</p>
</li></ul>

<p>For each of these you can substitute your own function. So for example if
you have written your own function for calculating the total mortality
rate and have called it <code>myMort</code> and have a mizer model stored in a
MizerParams object called <code>params</code> that you want to run with your new
mortality rate, then you would call
</p>
<div class="sourceCode"><pre>params &lt;- setRateFunction(params, "Mort", "myMort")
</pre></div>
<p>In general if you want to replace a function <code>mizerSomeRateFunc()</code> with
a function <code>myVersionOfThis()</code> you would call
</p>
<div class="sourceCode"><pre>params &lt;- setRateFunction(params, "SomeRateFunc", "myVersionOfThis")
</pre></div>
<p>In some extreme cases you may need to swap out the entire <code>mizerRates()</code>
function for your own function called <code>myRates()</code>. That you can do with
</p>
<div class="sourceCode"><pre>params &lt;- setRateFunction(params, "Rates", "myRates")
</pre></div>
<p>Your new rate functions may need their own model parameters. These you
can store in <code>other_params(params)</code>. For example
</p>
<div class="sourceCode"><pre>other_params(params)$my_param &lt;- 42
</pre></div>
<p>Note that your own rate functions need to be defined in the global
environment or in a package. If they are defined within a function then
mizer will not find them.
</p>


<h3>Value</h3>

<p>For <code>setRateFunction()</code>: An updated MizerParams object
</p>
<p>For <code>getRateFunction()</code>: The name of the registered rate function for
the requested <code>rate</code>, or the list of all rate functions if called without
<code>rate</code> argument.
</p>
<p>For <code>other_params()</code>: A named list with all the parameters for which
you have set values.
</p>

<hr>
<h2 id='setReproduction'>Set reproduction parameters</h2><span id='topic+setReproduction'></span><span id='topic+getMaturityProportion'></span><span id='topic+maturity'></span><span id='topic+maturity+3C-'></span><span id='topic+getReproductionProportion'></span><span id='topic+repro_prop'></span><span id='topic+repro_prop+3C-'></span>

<h3>Description</h3>

<p>Sets the proportion of the total energy available for reproduction and growth
that is invested into reproduction as a function of the size of the
individual and sets additional density dependence.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setReproduction(
  params,
  maturity = NULL,
  repro_prop = NULL,
  reset = FALSE,
  RDD = NULL,
  ...
)

getMaturityProportion(params)

maturity(params)

maturity(params) &lt;- value

getReproductionProportion(params)

repro_prop(params)

repro_prop(params) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setReproduction_+3A_params">params</code></td>
<td>
<p>A MizerParams object</p>
</td></tr>
<tr><td><code id="setReproduction_+3A_maturity">maturity</code></td>
<td>
<p>Optional. An array (species x size) that holds the proportion
of individuals of each species at size that are mature. If not supplied, a
default is set as described in the section &quot;Setting reproduction&quot;.</p>
</td></tr>
<tr><td><code id="setReproduction_+3A_repro_prop">repro_prop</code></td>
<td>
<p>Optional. An array (species x size) that holds the
proportion of consumed energy that a mature individual allocates to
reproduction for each species at size. If not supplied, a default is set as
described in the section &quot;Setting reproduction&quot;.</p>
</td></tr>
<tr><td><code id="setReproduction_+3A_reset">reset</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
If set to TRUE, then both <code>maturity</code> and <code>repro_prop</code> will be
reset to the value calculated from the species parameters, even if they
were previously overwritten with custom values. If set to FALSE (default)
then a recalculation from the species parameters will take place only if no
custom values have been set.</p>
</td></tr>
<tr><td><code id="setReproduction_+3A_rdd">RDD</code></td>
<td>
<p>The name of the function calculating the density-dependent
reproduction rate from the density-independent rate. Defaults to
&quot;<code><a href="#topic+BevertonHoltRDD">BevertonHoltRDD()</a></code>&quot;.</p>
</td></tr>
<tr><td><code id="setReproduction_+3A_...">...</code></td>
<td>
<p>Unused</p>
</td></tr>
<tr><td><code id="setReproduction_+3A_value">value</code></td>
<td>
<p>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>setReproduction()</code>: A MizerParams object with updated reproduction
parameters.
</p>
<p><code>getMaturityProportion()</code> or equivalently 'maturity():
An array (species x size) that holds the proportion
of individuals of each species at size that are mature.
</p>
<p><code>getReproductionProportion()</code> or equivalently <code>repro_prop()</code>:
An array (species x size) that holds the
proportion of consumed energy that a mature individual allocates to
reproduction for each species at size. For sizes where the maturity
proportion is zero, also the reproduction proportion is returned as zero.
</p>


<h3>Setting reproduction</h3>

<p>For each species and at each size, the proportion <code class="reqn">\psi</code> of the
available energy
that is invested into reproduction is the product of two factors: the
proportion <code>maturity</code> of individuals that are mature and the proportion
<code>repro_prop</code> of the energy available to a mature individual that is
invested into reproduction.
</p>


<h4>Maturity ogive</h4>

<p>If the the proportion of individuals that are mature is not supplied via
the <code>maturity</code> argument , then it is set to a sigmoidal
maturity ogive that changes from 0 to 1 at around the maturity size:
</p>
<p style="text-align: center;"><code class="reqn">{\tt maturity}(w) = \left[1+\left(\frac{w}{w_{mat}}\right)^{-U}\right]^{-1}.</code>
</p>

<p>(To avoid clutter, we are not showing the species index in the equations,
although each species has its own maturity ogive.)
The maturity weights are taken from the <code>w_mat</code> column of the
species_params data frame. Any missing maturity weights are set to 1/4 of the
maximum weight in the <code>w_max</code> column.
</p>
<p>The exponent <code class="reqn">U</code> determines the steepness of the maturity ogive. By
default it is chosen as <code class="reqn">U = 10</code>, however this can be overridden by
including a column <code>w_mat25</code> in the species parameter dataframe that
specifies the weight at which 25% of individuals are mature, which sets
<code class="reqn">U = \log(3) / \log(w_{mat} / w_{25}).</code>
</p>
<p>The sigmoidal function given above would strictly reach 1 only asymptotically.
Mizer instead sets the function equal to 1 already at the species'
maximum size, taken from the compulsory <code>w_max</code> column in the
species parameter data frame. Also, for computational simplicity, any
proportion smaller than <code>1e-8</code> is set to <code>0</code>.
</p>



<h4>Investment into reproduction</h4>

<p>If the the energy available to a mature individual that is
invested into reproduction is not supplied via the <code>repro_prop</code> argument,
it is set to the allometric form
</p>
<p style="text-align: center;"><code class="reqn">{\tt repro\_prop}(w) = \left(\frac{w}{w_{max}}\right)^{m-n}.</code>
</p>

<p>Here <code class="reqn">n</code> is the scaling exponent of the energy income rate. Hence
the exponent <code class="reqn">m</code> determines the scaling of the investment into
reproduction for mature individuals. By default it is chosen to be
<code class="reqn">m = 1</code> so that the rate at which energy is invested into reproduction
scales linearly with the size. This default can be overridden by including a
column <code>m</code> in the species parameter dataframe. The maximum sizes
are taken from the compulsory <code>w_max</code> column in the species parameter
data frame.
</p>
<p>The total proportion of energy invested into reproduction of an individual
of size <code class="reqn">w</code> is then
</p>
<p style="text-align: center;"><code class="reqn">\psi(w) = {\tt maturity}(w){\tt repro\_prop}(w)</code>
</p>




<h4>Reproductive efficiency</h4>

<p>The reproductive efficiency <code class="reqn">\epsilon</code>, i.e., the proportion of energy allocated to
reproduction that results in egg biomass, is set through the <code>erepro</code>
column in the species_params data frame. If that is not provided, the default
is set to 1 (which you will want to override). The offspring biomass divided
by the egg biomass gives the rate of egg production, returned by
<code><a href="#topic+getRDI">getRDI()</a></code>:
</p>
<p style="text-align: center;"><code class="reqn">R_{di} = \frac{\epsilon}{2 w_{min}} \int N(w)  E_r(w) \psi(w) \, dw</code>
</p>




<h4>Density dependence</h4>

<p>The stock-recruitment relationship is an emergent phenomenon in mizer, with
several sources of density dependence. Firstly, the amount of energy invested
into reproduction depends on the energy income of the spawners, which is
density-dependent due to competition for prey. Secondly, the proportion of
larvae that grow up to recruitment size depends on the larval mortality,
which depends on the density of predators, and on larval growth rate, which
depends on density of prey.
</p>
<p>Finally, to encode all the density dependence in the stock-recruitment
relationship that is not already included in the other two sources of density
dependence, mizer puts the the density-independent rate of egg production
through a density-dependence function. The result is returned by
<code><a href="#topic+getRDD">getRDD()</a></code>. The name of the density-dependence function is
specified by the <code>RDD</code> argument. The default is the Beverton-Holt
function <code><a href="#topic+BevertonHoltRDD">BevertonHoltRDD()</a></code>, which requires an <code>R_max</code> column
in the species_params data frame giving the maximum egg production rate. If
this column does not exist, it is initialised to <code>Inf</code>, leading to no
density-dependence. Other functions provided by mizer are
<code><a href="#topic+RickerRDD">RickerRDD()</a></code> and <code><a href="#topic+SheperdRDD">SheperdRDD()</a></code> and you can easily use
these as models for writing your own functions.
</p>



<h3>See Also</h3>

<p>Other functions for setting parameters: 
<code><a href="#topic+gear_params">gear_params</a>()</code>,
<code><a href="#topic+setExtEncounter">setExtEncounter</a>()</code>,
<code><a href="#topic+setExtMort">setExtMort</a>()</code>,
<code><a href="#topic+setFishing">setFishing</a>()</code>,
<code><a href="#topic+setInitialValues">setInitialValues</a>()</code>,
<code><a href="#topic+setInteraction">setInteraction</a>()</code>,
<code><a href="#topic+setMaxIntakeRate">setMaxIntakeRate</a>()</code>,
<code><a href="#topic+setMetabolicRate">setMetabolicRate</a>()</code>,
<code><a href="#topic+setParams">setParams</a>()</code>,
<code><a href="#topic+setPredKernel">setPredKernel</a>()</code>,
<code><a href="#topic+setSearchVolume">setSearchVolume</a>()</code>,
<code><a href="#topic+species_params">species_params</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Plot maturity and reproduction ogives for Cod in North Sea model
maturity &lt;- getMaturityProportion(NS_params)["Cod", ]
repro_prop &lt;- getReproductionProportion(NS_params)["Cod", ]
df &lt;- data.frame(Size = w(NS_params), 
                 Reproduction = repro_prop, 
                 Maturity = maturity, 
                 Total = maturity * repro_prop)
dff &lt;- melt(df, id.vars = "Size", 
            variable.name = "Type", 
            value.name = "Proportion")
library(ggplot2)
ggplot(dff) + geom_line(aes(x = Size, y = Proportion, colour = Type))

</code></pre>

<hr>
<h2 id='setResource'>Set resource dynamics</h2><span id='topic+setResource'></span><span id='topic+resource_rate'></span><span id='topic+resource_rate+3C-'></span><span id='topic+resource_capacity'></span><span id='topic+resource_capacity+3C-'></span><span id='topic+resource_level'></span><span id='topic+resource_level+3C-'></span><span id='topic+resource_dynamics'></span><span id='topic+resource_dynamics+3C-'></span>

<h3>Description</h3>

<p>Sets the intrinsic resource growth rate and the intrinsic resource carrying
capacity as well as the name of the function used to simulate the resource
dynamics. By default this function changes both the rate and the capacity
together in such a way that the resource replenishes at the same rate at
which it is consumed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setResource(
  params,
  resource_rate = NULL,
  resource_capacity = NULL,
  resource_level = NULL,
  resource_dynamics = NULL,
  balance = NULL,
  lambda = resource_params(params)[["lambda"]],
  n = resource_params(params)[["n"]],
  w_pp_cutoff = resource_params(params)[["w_pp_cutoff"]],
  r_pp = deprecated(),
  kappa = deprecated(),
  ...
)

resource_rate(params)

resource_rate(params) &lt;- value

resource_capacity(params)

resource_capacity(params) &lt;- value

resource_level(params)

resource_level(params) &lt;- value

resource_dynamics(params)

resource_dynamics(params) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setResource_+3A_params">params</code></td>
<td>
<p>A MizerParams object</p>
</td></tr>
<tr><td><code id="setResource_+3A_resource_rate">resource_rate</code></td>
<td>
<p>Optional. Vector of resource intrinsic birth rates or
coefficient in the power-law for the birth rate, see Details. Must be
strictly positive.</p>
</td></tr>
<tr><td><code id="setResource_+3A_resource_capacity">resource_capacity</code></td>
<td>
<p>Optional. Vector of resource intrinsic carrying
capacities or coefficient in the power-law for the capacity, see Details.
The resource capacity must be larger than the resource abundance.</p>
</td></tr>
<tr><td><code id="setResource_+3A_resource_level">resource_level</code></td>
<td>
<p>Optional. The ratio between the current resource number
density and the resource capacity. Either a number used at all sizes or a
vector specifying a value for each size. Must be strictly between 0 and 1,
except at sizes where the resource is zero, where it can be <code>NaN</code>. This
determines the resource capacity, so do not specify both this and
<code>resource_capacity</code>.</p>
</td></tr>
<tr><td><code id="setResource_+3A_resource_dynamics">resource_dynamics</code></td>
<td>
<p>Optional. Name of the function that determines the
resource dynamics by calculating the resource spectrum at the next time
step from the current state.</p>
</td></tr>
<tr><td><code id="setResource_+3A_balance">balance</code></td>
<td>
<p>By default, if possible, the resource parameters are
set so that the resource replenishes at the same rate at which it is
consumed. In this case you should only specify either the resource rate
or the resource capacity (or resource level) because the other is then
determined automatically. Set to FALSE if you do not want the balancing.</p>
</td></tr>
<tr><td><code id="setResource_+3A_lambda">lambda</code></td>
<td>
<p>Used to set power-law exponent for resource capacity if the
<code>resource_capacity</code> argument is given as a single number.</p>
</td></tr>
<tr><td><code id="setResource_+3A_n">n</code></td>
<td>
<p>Used to set power-law exponent for resource rate if the
<code>resource_rate</code> argument is given as a single number.</p>
</td></tr>
<tr><td><code id="setResource_+3A_w_pp_cutoff">w_pp_cutoff</code></td>
<td>
<p>The upper cut off size of the resource spectrum power law
used only if <code>resource_capacity</code> is given as a single number.</p>
</td></tr>
<tr><td><code id="setResource_+3A_r_pp">r_pp</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>. Use <code>resource_rate</code> argument
instead.</p>
</td></tr>
<tr><td><code id="setResource_+3A_kappa">kappa</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>. Use <code>resource_capacity</code>
argument instead.</p>
</td></tr>
<tr><td><code id="setResource_+3A_...">...</code></td>
<td>
<p>Unused</p>
</td></tr>
<tr><td><code id="setResource_+3A_value">value</code></td>
<td>
<p>The desired new value for the respective parameter.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>setResource</code>: A MizerParams object with updated resource parameters
</p>


<h3>Setting resource dynamics</h3>

<p>You would usually set the resource dynamics only after having finished the
calibration of the steady state. Then setting the resource dynamics with
this function will preserve that steady state, unless you explicitly
choose to set <code>balance = FALSE</code>. Your choice of the resource dynamics only
affects the dynamics around the steady state. The higher the resource rate
or the lower the resource capacity the less sensitive the model will be to
changes in the competition for resource.
</p>
<p>The <code>resource_dynamics</code> argument allows you to choose the resource dynamics
function. By default, mizer uses a semichemostat model to describe the
resource dynamics in each size class independently. This semichemostat
dynamics is implemented by the function <code><a href="#topic+resource_semichemostat">resource_semichemostat()</a></code>. You can
change that to use a logistic model implemented by <code><a href="#topic+resource_logistic">resource_logistic()</a></code> or
you can use <code><a href="#topic+resource_constant">resource_constant()</a></code> which keeps the resource constant or you
can write your own function.
</p>
<p>Both the <code><a href="#topic+resource_semichemostat">resource_semichemostat()</a></code> and the <code><a href="#topic+resource_logistic">resource_logistic()</a></code> dynamics
are parametrised in terms of a size-dependent rate <code class="reqn">r_R(w)</code> and a
size-dependent capacity <code class="reqn">c_R</code>. The help pages of these functions give
the details.
</p>
<p>The <code>resource_rate</code> argument can be a vector (with the same length as
<code>w_full(params)</code>) specifying the intrinsic resource growth rate for each size
class. Alternatively it can be a single number, which is then used as the
coefficient in a power law: then the intrinsic growth rate <code class="reqn">r_R(w)</code> at
size <code class="reqn">w</code> is set to
</p>
<p style="text-align: center;"><code class="reqn">r_R(w) = r_R w^{n-1}.</code>
</p>

<p>The power-law exponent <code class="reqn">n</code> is taken from the <code>n</code> argument.
</p>
<p>The <code>resource_capacity</code> argument can be a vector specifying the intrinsic
resource carrying capacity for each size class. Alternatively it can be a
single number, which is then used as the coefficient in a truncated power
law: then the intrinsic growth rate <code class="reqn">c_R(w)</code> at size <code class="reqn">w</code> is set to
</p>
<p style="text-align: center;"><code class="reqn">c(w) = \kappa\, w^{-\lambda}</code>
</p>

<p>for all <code class="reqn">w</code> less than <code>w_pp_cutoff</code> and zero for larger sizes.
The power-law exponent <code class="reqn">\lambda</code> is taken from the <code>lambda</code> argument.
</p>
<p>The values for <code>lambda</code>, <code>n</code> and <code>w_pp_cutoff</code> are stored in a list in the
<code>resource_params</code> slot of the MizerParams object so that they can be re-used
automatically in the future. That list can be accessed with
<code><a href="#topic+resource_params">resource_params()</a></code>. It also holds the coefficient <code>kappa</code> that describes the
steady-state resource abundance.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>params &lt;- NS_params
resource_dynamics(params)
resource_dynamics(params) &lt;- "resource_constant"
</code></pre>

<hr>
<h2 id='setRmax'>Alias for <code>setBevertonHolt()</code></h2><span id='topic+setRmax'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p>An alias provided for backward compatibility with mizer version &lt;= 2.0.4
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setRmax(params, R_factor = deprecated(), erepro, R_max, reproduction_level)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setRmax_+3A_params">params</code></td>
<td>
<p>A MizerParams object</p>
</td></tr>
<tr><td><code id="setRmax_+3A_r_factor">R_factor</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a> Use
<code>reproduction_level = 1 / R_factor</code> instead.</p>
</td></tr>
<tr><td><code id="setRmax_+3A_erepro">erepro</code></td>
<td>
<p>Reproductive efficiency for each species. See details.</p>
</td></tr>
<tr><td><code id="setRmax_+3A_r_max">R_max</code></td>
<td>
<p>Maximum reproduction rate. See details.</p>
</td></tr>
<tr><td><code id="setRmax_+3A_reproduction_level">reproduction_level</code></td>
<td>
<p>Sets <code>R_max</code> so that the reproduction rate at
the initial state is <code>R_max * reproduction_level</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>With Beverton-Holt density dependence the relation between the energy
invested into reproduction and the number of eggs hatched is determined
by two parameters: the reproductive efficiency <code>erepro</code> and the maximum
reproduction rate <code>R_max</code>.
</p>
<p>If no maximum is imposed on the reproduction rate
(<code class="reqn">R_{max} = \infty</code>) then the resulting density-independent
reproduction rate <code class="reqn">R_{di}</code> is proportional
to the total rate <code class="reqn">E_R</code> at which energy is invested into reproduction,
</p>
<p style="text-align: center;"><code class="reqn">R_{di} = \frac{\rm{erepro}}{2 w_{min}} E_R,</code>
</p>

<p>where the proportionality factor is given by the reproductive efficiency
<code>erepro</code> divided by the egg size <code>w_min</code> to convert energy to egg number and
divided by 2 to account for the two sexes.
</p>
<p>Imposing a finite maximum reproduction rate <code class="reqn">R_{max}</code> leads to a
non-linear relationship between energy invested and eggs hatched. This
density-dependent reproduction rate <code class="reqn">R_{dd}</code> is given as
</p>
<p style="text-align: center;"><code class="reqn">R_{dd} = R_{di}
\frac{R_{max}}{R_{di} + R_{max}}.</code>
</p>

<p>(All quantities in the above equations are species-specific but we dropped
the species index for simplicity.)
</p>
<p>The following plot illustrates the Beverton-Holt density dependence in the
reproduction rate for two different choices of parameters.
<img src="../help/figures/Beverton-Holt-plot-1.png" alt="Beverton-Holt-plot-1.png" />
</p>
<p>This plot shows that a given energy <code class="reqn">E_R</code> invested into reproduction can
lead to the same reproduction rate <code class="reqn">R_{dd}</code> with different choices
of the parameters <code>R_max</code> and <code>erepro</code>. <code>R_max</code> determines the asymptote of
the curve and <code>erepro</code> its initial slope. A higher <code>R_max</code> coupled with a
lower <code>erepro</code> (black curves) can give the same value as a lower <code>R_max</code>
coupled with a higher <code>erepro</code> (blue curves).
</p>
<p>For the given initial state in the MizerParams object <code>params</code> one can
calculate the energy <code class="reqn">E_R</code> that is invested into reproduction by the
mature individuals and the reproduction rate <code class="reqn">R_{dd}</code> that is
required to keep the egg abundance constant. These two values determine the
location of the black dot in the above graph. You then only need one
parameter to select one curve from the family of Beverton-Holt curves going
through that point. This parameter can be <code>erepro</code> or <code>R_max</code>. Instead of
<code>R_max</code> you can alternatively specify the <code>reproduction_level</code> which is the
ratio between the density-dependent reproduction rate <code class="reqn">R_{dd}</code> and
the maximal reproduction rate  <code class="reqn">R_{max}</code>.
</p>
<p>If you do not provide a value for any of the reproduction parameter
arguments, then <code>erepro</code> will be set to the value it has in the current
species parameter data frame. If you do provide one of the reproduction
parameters, this can be either a vector with one value for each
species, or a named vector where the names determine which species are
affected, or a single unnamed value that is then used for all species. Any
species for which the given value is <code>NA</code> will remain unaffected.
</p>
<p>The values for <code>R_max</code> must be larger than <code class="reqn">R_{dd}</code> and can range
up to <code>Inf</code>. If a smaller value is requested a warning is issued and the
value is increased to the value required for a reproduction level of 0.99.
</p>
<p>The values for the <code>reproduction_level</code> must be positive and
less than 1. The values for <code>erepro</code> must be large enough to allow the
required reproduction rate. If a smaller value is requested a warning is
issued and the value is increased to the smallest possible value. The values
for <code>erepro</code> should also be smaller than 1 to be physiologically sensible,
but this is not enforced by the function.
</p>
<p>As can be seen in the graph above, choosing a lower value for <code>R_max</code> or a
higher value for <code>erepro</code> means that near the steady state the reproduction
will be less sensitive to a change in the energy invested into reproduction
and hence less sensitive to changes in the spawning stock biomass or its
energy income. As a result the species will also be less sensitive to
fishing, leading to a higher F_MSY.
</p>


<h3>Value</h3>

<p>A MizerParams object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>params &lt;- NS_params
species_params(params)$erepro
# Attempting to set the same erepro for all species
params &lt;- setBevertonHolt(params, erepro = 0.1)
t(species_params(params)[, c("erepro", "R_max")])
# Setting erepro for some species
params &lt;- setBevertonHolt(params, erepro = c("Gurnard" = 0.6, "Plaice" = 0.95))
t(species_params(params)[, c("erepro", "R_max")])
# Setting R_max
R_max &lt;- 1e17 * species_params(params)$w_max^-1
params &lt;- setBevertonHolt(NS_params, R_max = R_max)
t(species_params(params)[, c("erepro", "R_max")])
# Setting reproduction_level
params &lt;- setBevertonHolt(params, reproduction_level = 0.3)
t(species_params(params)[, c("erepro", "R_max")])
</code></pre>

<hr>
<h2 id='setSearchVolume'>Set search volume</h2><span id='topic+setSearchVolume'></span><span id='topic+getSearchVolume'></span><span id='topic+search_vol'></span><span id='topic+search_vol+3C-'></span>

<h3>Description</h3>

<p>Set search volume
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setSearchVolume(params, search_vol = NULL, reset = FALSE, ...)

getSearchVolume(params)

search_vol(params)

search_vol(params) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setSearchVolume_+3A_params">params</code></td>
<td>
<p>MizerParams</p>
</td></tr>
<tr><td><code id="setSearchVolume_+3A_search_vol">search_vol</code></td>
<td>
<p>Optional. An array (species x size) holding the search volume
for each species at size. If not supplied, a default is set as described in
the section &quot;Setting search volume&quot;.</p>
</td></tr>
<tr><td><code id="setSearchVolume_+3A_reset">reset</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
If set to TRUE, then the search volume will be reset to the
value calculated from the species parameters, even if it was previously
overwritten with a custom value. If set to FALSE (default) then a
recalculation from the species parameters will take place only if no custom
value has been set.</p>
</td></tr>
<tr><td><code id="setSearchVolume_+3A_...">...</code></td>
<td>
<p>Unused</p>
</td></tr>
<tr><td><code id="setSearchVolume_+3A_value">value</code></td>
<td>
<p>search_vol</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>setSearchVolume()</code>: A MizerParams object with updated search volume.
</p>
<p><code>getSearchVolume()</code> or equivalently <code>search_vol()</code>: An array (species
x size) holding the search volume
</p>


<h3>Setting search volume</h3>

<p>The search volume <code class="reqn">\gamma_i(w)</code> of an individual of species <code class="reqn">i</code>
and weight <code class="reqn">w</code> multiplies the predation kernel when
calculating the encounter rate in <code><a href="#topic+getEncounter">getEncounter()</a></code> and the
predation rate in <code><a href="#topic+getPredRate">getPredRate()</a></code>.
</p>
<p>The name &quot;search volume&quot; is a bit misleading, because <code class="reqn">\gamma_i(w)</code> does
not have units of volume. It is simply a parameter that determines the rate
of predation. Its units depend on your choice, see section &quot;Units in mizer&quot;.
If you have chosen to work with total abundances, then it is a rate with units
1/year. If you have chosen to work with abundances per m^2 then it has units
of m^2/year. If you have chosen to work with abundances per m^3 then it has
units of m^3/year.
</p>
<p>If the <code>search_vol</code> argument is not supplied, then the search volume is
set to
</p>
<p style="text-align: center;"><code class="reqn">\gamma_i(w) = \gamma_i w^q_i.</code>
</p>

<p>The values of <code class="reqn">\gamma_i</code> (the search volume at 1g) and <code class="reqn">q_i</code> (the
allometric exponent of the search volume) are taken from the <code>gamma</code> and
<code>q</code> columns in the species parameter dataframe. If the <code>gamma</code>
column is not supplied in the species parameter dataframe, a default is
calculated by the <code><a href="#topic+get_gamma_default">get_gamma_default()</a></code> function. Note that only
for predators of size <code class="reqn">w = 1</code> gram is the value of the species parameter
<code class="reqn">\gamma_i</code> the same as the value of the search volume <code class="reqn">\gamma_i(w)</code>.
</p>


<h3>See Also</h3>

<p>Other functions for setting parameters: 
<code><a href="#topic+gear_params">gear_params</a>()</code>,
<code><a href="#topic+setExtEncounter">setExtEncounter</a>()</code>,
<code><a href="#topic+setExtMort">setExtMort</a>()</code>,
<code><a href="#topic+setFishing">setFishing</a>()</code>,
<code><a href="#topic+setInitialValues">setInitialValues</a>()</code>,
<code><a href="#topic+setInteraction">setInteraction</a>()</code>,
<code><a href="#topic+setMaxIntakeRate">setMaxIntakeRate</a>()</code>,
<code><a href="#topic+setMetabolicRate">setMetabolicRate</a>()</code>,
<code><a href="#topic+setParams">setParams</a>()</code>,
<code><a href="#topic+setPredKernel">setPredKernel</a>()</code>,
<code><a href="#topic+setReproduction">setReproduction</a>()</code>,
<code><a href="#topic+species_params">species_params</a>()</code>
</p>

<hr>
<h2 id='SheperdRDD'>Sheperd function to calculate density-dependent reproduction rate</h2><span id='topic+SheperdRDD'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
Takes the density-independent rates <code class="reqn">R_{di}</code> of egg production and returns
reduced, density-dependent rates <code class="reqn">R_{dd}</code> given as
</p>
<p style="text-align: center;"><code class="reqn">R_{dd} = \frac{R_{di}}{1+(b\ R_{di})^c}</code>
</p>



<h3>Usage</h3>

<pre><code class='language-R'>SheperdRDD(rdi, species_params, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SheperdRDD_+3A_rdi">rdi</code></td>
<td>
<p>Vector of density-independent reproduction rates
<code class="reqn">R_{di}</code> for all species.</p>
</td></tr>
<tr><td><code id="SheperdRDD_+3A_species_params">species_params</code></td>
<td>
<p>A species parameter dataframe. Must contain columns
<code>sheperd_b</code> and <code>sheperd_c</code> with the parameters b and c.</p>
</td></tr>
<tr><td><code id="SheperdRDD_+3A_...">...</code></td>
<td>
<p>Unused</p>
</td></tr>
</table>


<h3>Details</h3>

<p>With <code class="reqn">b = 1/R_{max}</code> and <code class="reqn">c = 1</code> this reduces to the Beverton-Holt
reproduction rate, see <code><a href="#topic+BevertonHoltRDD">BevertonHoltRDD()</a></code>.
</p>


<h3>Value</h3>

<p>Vector of density-dependent reproduction rates.
</p>


<h3>See Also</h3>

<p>Other functions calculating density-dependent reproduction rate: 
<code><a href="#topic+BevertonHoltRDD">BevertonHoltRDD</a>()</code>,
<code><a href="#topic+RickerRDD">RickerRDD</a>()</code>,
<code><a href="#topic+constantEggRDI">constantEggRDI</a>()</code>,
<code><a href="#topic+constantRDD">constantRDD</a>()</code>,
<code><a href="#topic+noRDD">noRDD</a>()</code>
</p>

<hr>
<h2 id='sigmoid_length'>Length based sigmoid selectivity function</h2><span id='topic+sigmoid_length'></span>

<h3>Description</h3>

<p>A sigmoid shaped selectivity function. Based on two parameters <code>l25</code> and
<code>l50</code> which determine the length at which 25% and 50% of the stock is
selected respectively. As the size-based model is weight based, and this
selectivity function is length based, it uses the
length-weight parameters <code>a</code> and <code>b</code> to convert between length and weight.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sigmoid_length(w, l25, l50, species_params, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sigmoid_length_+3A_w">w</code></td>
<td>
<p>Vector of sizes.</p>
</td></tr>
<tr><td><code id="sigmoid_length_+3A_l25">l25</code></td>
<td>
<p>the length which gives a selectivity of 25%.</p>
</td></tr>
<tr><td><code id="sigmoid_length_+3A_l50">l50</code></td>
<td>
<p>the length which gives a selectivity of 50%.</p>
</td></tr>
<tr><td><code id="sigmoid_length_+3A_species_params">species_params</code></td>
<td>
<p>A list with the species params for the current species.
Used to get at the length-weight parameters <code>a</code> and <code>b</code>.</p>
</td></tr>
<tr><td><code id="sigmoid_length_+3A_...">...</code></td>
<td>
<p>Unused</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector of selectivities at the given sizes.
</p>


<h3>See Also</h3>

<p>Other selectivity functions: 
<code><a href="#topic+double_sigmoid_length">double_sigmoid_length</a>()</code>,
<code><a href="#topic+knife_edge">knife_edge</a>()</code>,
<code><a href="#topic+sigmoid_weight">sigmoid_weight</a>()</code>
</p>

<hr>
<h2 id='sigmoid_weight'>Weight based sigmoidal selectivity function</h2><span id='topic+sigmoid_weight'></span>

<h3>Description</h3>

<p>A sigmoidal selectivity function with 50% selectivity at
weight <code>sigmoidal_weight</code> and width <code>sigmoidal_sigma</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sigmoid_weight(w, sigmoidal_weight, sigmoidal_sigma, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sigmoid_weight_+3A_w">w</code></td>
<td>
<p>Vector of sizes.</p>
</td></tr>
<tr><td><code id="sigmoid_weight_+3A_sigmoidal_weight">sigmoidal_weight</code></td>
<td>
<p>The weight at which the knife-edge operates.</p>
</td></tr>
<tr><td><code id="sigmoid_weight_+3A_sigmoidal_sigma">sigmoidal_sigma</code></td>
<td>
<p>The width of the selection function.</p>
</td></tr>
<tr><td><code id="sigmoid_weight_+3A_...">...</code></td>
<td>
<p>Unused</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector of selectivities at the given sizes.
</p>


<h3>See Also</h3>

<p>Other selectivity functions: 
<code><a href="#topic+double_sigmoid_length">double_sigmoid_length</a>()</code>,
<code><a href="#topic+knife_edge">knife_edge</a>()</code>,
<code><a href="#topic+sigmoid_length">sigmoid_length</a>()</code>
</p>

<hr>
<h2 id='species_params'>Species parameters</h2><span id='topic+species_params'></span><span id='topic+species_params+3C-'></span><span id='topic+given_species_params'></span><span id='topic+given_species_params+3C-'></span><span id='topic+calculated_species_params'></span>

<h3>Description</h3>

<p>These functions allow you to get or set the species-specific parameters
stored in a MizerParams object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>species_params(params)

species_params(params) &lt;- value

given_species_params(params)

given_species_params(params) &lt;- value

calculated_species_params(params)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="species_params_+3A_params">params</code></td>
<td>
<p>A MizerParams object</p>
</td></tr>
<tr><td><code id="species_params_+3A_value">value</code></td>
<td>
<p>A data frame with the species parameters</p>
</td></tr>
</table>


<h3>Details</h3>

<p>There are a lot of species parameters and we will list them all below, but
most of them have sensible default values. The only required columns are
<code>species</code> for the species name and <code>w_max</code> for its maximum size. However
if you have information about the values of other parameters then you should
provide them.
</p>
<p>Mizer distinguishes between the species parameters that you have given
explicitly and the species parameters that have been calculated by mizer or
set to default values. You can retrieve the given species parameters with
<code>given_species_params()</code> and the calculated ones with
<code>calculated_species_params()</code>. You get all species_params with
<code>species_params()</code>.
</p>
<p>If you change given species parameters with <code style="white-space: pre;">&#8288;given_species_params&lt;-()&#8288;</code> this
will trigger a re-calculation of the calculated species parameters, where
necessary. However if you change species parameters with <code style="white-space: pre;">&#8288;species_params&lt;-()&#8288;</code>
no recalculation will take place and furthermore your values could be
overwritten by a future recalculation triggered by a call to
<code style="white-space: pre;">&#8288;given_species_params&lt;-()&#8288;</code> . So in most use cases you will only want to use
<code style="white-space: pre;">&#8288;given_species_params&lt;-()&#8288;</code>.
</p>
<p>There are some species parameters that are used to set up the
size-dependent parameters that are used in the mizer model:
</p>

<ul>
<li> <p><code>gamma</code> and <code>q</code> are used to set the search volume, see <code><a href="#topic+setSearchVolume">setSearchVolume()</a></code>.
</p>
</li>
<li> <p><code>h</code> and <code>n</code> are used to set the maximum intake rate, see <code><a href="#topic+setMaxIntakeRate">setMaxIntakeRate()</a></code>.
</p>
</li>
<li> <p><code>k</code>, <code>ks</code> and <code>p</code> are used to set activity and basic metabolic rate,
see <code><a href="#topic+setMetabolicRate">setMetabolicRate()</a></code>.
</p>
</li>
<li> <p><code>z0</code> is used to set the external mortality rate, see <code><a href="#topic+setExtMort">setExtMort()</a></code>.
</p>
</li>
<li> <p><code>w_mat</code>, <code>w_mat25</code>, <code>w_max</code> and <code>m</code> are used to set the allocation to
reproduction, see <code><a href="#topic+setReproduction">setReproduction()</a></code>.
</p>
</li>
<li> <p><code>pred_kernel_type</code> specifies the shape of the predation kernel. The default
is a &quot;lognormal&quot;, for other options see the &quot;Setting predation kernel&quot;
section in the help for <code><a href="#topic+setPredKernel">setPredKernel()</a></code>.
</p>
</li>
<li> <p><code>beta</code> and <code>sigma</code> are parameters of the lognormal predation kernel, see
<code><a href="#topic+lognormal_pred_kernel">lognormal_pred_kernel()</a></code>. There will be other parameters if you are
using other predation kernel functions.
</p>
</li></ul>

<p>When you change one of the above species parameters using
<code style="white-space: pre;">&#8288;given_species_params&lt;-()&#8288;</code> or <code style="white-space: pre;">&#8288;species_params&lt;-()&#8288;</code>, the new value will be
used to update the corresponding size-dependent rates automatically, unless
you have set those size-dependent rates manually, in which case the
corresponding species parameters will be ignored.
</p>
<p>There are some species parameters that are used directly in the model
rather than being used for setting up size-dependent parameters:
</p>

<ul>
<li> <p><code>alpha</code> is the assimilation efficiency, the proportion of the consumed
biomass that can be used for growth, metabolism and reproduction, see
the help for <code><a href="#topic+getEReproAndGrowth">getEReproAndGrowth()</a></code>.
</p>
</li>
<li> <p><code>w_min</code> is the egg size.
</p>
</li>
<li> <p><code>interaction_resource</code> sets the interaction strength with the resource,
see &quot;Predation encounter&quot; section in the help for <code><a href="#topic+getEncounter">getEncounter()</a></code>.
</p>
</li>
<li> <p><code>erepro</code> is the reproductive efficiency, the proportion of the energy
invested into reproduction that is converted to egg biomass, see
<code><a href="#topic+getRDI">getRDI()</a></code>.
</p>
</li>
<li> <p><code>Rmax</code> is the parameter in the Beverton-Holt density dependence added to
the reproduction, see <code><a href="#topic+setBevertonHolt">setBevertonHolt()</a></code>. There will be other such
parameters if you use other density dependence functions, see the
&quot;Density dependence&quot; section in the help for <code><a href="#topic+setReproduction">setReproduction()</a></code>.
</p>
</li></ul>

<p>Two parameters are used only by functions that need to convert between
weight and length:
</p>

<ul>
<li> <p><code>a</code> and <code>b</code> are the parameters in the allometric weight-length
relationship <code class="reqn">w = a l ^ b</code>.
</p>
</li></ul>

<p>If you have supplied the <code>a</code> and <code>b</code> parameters, then you can replace weight
parameters like <code>w_max</code>, <code>w_mat</code>, <code>w_mat25</code> and <code>w_min</code> by their
corresponding length parameters <code>l_max</code>, <code>l_mat</code>, <code>l_mat25</code> and <code>l_min</code>.
</p>
<p>The parameters that are only used to calculate default values for other
parameters are:
</p>

<ul>
<li> <p><code>f0</code> is the feeding level and is used to get a default value for the
coefficient of the search volume <code>gamma</code>, see <code><a href="#topic+get_gamma_default">get_gamma_default()</a></code>.
</p>
</li>
<li> <p><code>fc</code> is the critical feeding level below which the species can not
maintain itself. This is used to get a default value for the coefficient
<code>ks</code> of the metabolic rate, see <code><a href="#topic+get_ks_default">get_ks_default()</a></code>.
</p>
</li>
<li> <p><code>age_mat</code> is the age at maturity and is used to get a default value for
the coefficient <code>h</code> of the maximum intake rate, see <code><a href="#topic+get_h_default">get_h_default()</a></code>.
</p>
</li></ul>

<p>Note that setting these parameters with <code style="white-space: pre;">&#8288;species_params&lt;-()&#8288;</code> will have no
effect. You need to set them with <code style="white-space: pre;">&#8288;given_species_params&lt;-()&#8288;</code> in order to
trigger a re-calculation of the other species parameters.
</p>
<p>In the past mizer also used the von Bertalanffy parameters <code>k_vb</code>, <code>w_inf</code>
and <code>t0</code> to determine a default for <code>h</code>. This is unreliable and is therefore
now deprecated.
</p>
<p>There are other species parameters that are used in tuning the model to
observations:
</p>

<ul>
<li> <p><code>biomass_observed</code> and <code>biomass_cutoff</code> allow you to specify for each
species the total observed biomass above some cutoff size. This is
used by <code><a href="#topic+calibrateBiomass">calibrateBiomass()</a></code> and <code><a href="#topic+matchBiomasses">matchBiomasses()</a></code>.
</p>
</li>
<li> <p><code>yield_observed</code> allows you to specify for each
species the total annual fisheries yield. This is
used by <code><a href="#topic+calibrateYield">calibrateYield()</a></code> and <code><a href="#topic+matchYields">matchYields()</a></code>.
</p>
</li></ul>

<p>Finally there are two species parameters that control the way the species are
represented in plots:
</p>

<ul>
<li> <p><code>linecolour</code> specifies the colour and can be any valid R colour value.
</p>
</li>
<li> <p><code>linetype</code> specifies the line type (&quot;solid&quot;, &quot;dashed&quot;, &quot;dotted&quot;, &quot;dotdash&quot;,
&quot;longdash&quot;, &quot;twodash&quot; or &quot;blank&quot;)
</p>
</li></ul>

<p>Other species-specific information that is related to how the species is
fished is specified in a gear parameter data frame, see <code><a href="#topic+gear_params">gear_params()</a></code>.
However in the case where each species is caught by only a single gear,
this information can also optionally be provided as species parameters and
<code><a href="#topic+newMultispeciesParams">newMultispeciesParams()</a></code> will transfer them to the <code>gear_params</code> data frame.
However changing these parameters later in the species parameter data frames
will have no effect.
</p>
<p>You are allowed to include additional columns in the species parameter
data frames. They will simply be ignored by mizer but will be stored in the
MizerParams object, in case your own code makes use of them.
</p>


<h3>Value</h3>

<p>Data frame of species parameters
</p>


<h3>See Also</h3>

<p><code><a href="#topic+validSpeciesParams">validSpeciesParams()</a></code>, <code><a href="#topic+completeSpeciesParams">completeSpeciesParams()</a></code>
</p>
<p>Other functions for setting parameters: 
<code><a href="#topic+gear_params">gear_params</a>()</code>,
<code><a href="#topic+setExtEncounter">setExtEncounter</a>()</code>,
<code><a href="#topic+setExtMort">setExtMort</a>()</code>,
<code><a href="#topic+setFishing">setFishing</a>()</code>,
<code><a href="#topic+setInitialValues">setInitialValues</a>()</code>,
<code><a href="#topic+setInteraction">setInteraction</a>()</code>,
<code><a href="#topic+setMaxIntakeRate">setMaxIntakeRate</a>()</code>,
<code><a href="#topic+setMetabolicRate">setMetabolicRate</a>()</code>,
<code><a href="#topic+setParams">setParams</a>()</code>,
<code><a href="#topic+setPredKernel">setPredKernel</a>()</code>,
<code><a href="#topic+setReproduction">setReproduction</a>()</code>,
<code><a href="#topic+setSearchVolume">setSearchVolume</a>()</code>
</p>

<hr>
<h2 id='steady'>Set initial values to a steady state for the model</h2><span id='topic+steady'></span>

<h3>Description</h3>

<p>The steady state is found by running the dynamics while keeping reproduction,
resource and other components constant until the size spectra no longer
change much (or until time <code>t_max</code> is reached, if earlier).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>steady(
  params,
  t_max = 100,
  t_per = 1.5,
  dt = 0.1,
  tol = 0.1 * dt,
  return_sim = FALSE,
  preserve = c("reproduction_level", "erepro", "R_max"),
  progress_bar = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="steady_+3A_params">params</code></td>
<td>
<p>A <a href="#topic+MizerParams-class">MizerParams</a> object</p>
</td></tr>
<tr><td><code id="steady_+3A_t_max">t_max</code></td>
<td>
<p>The maximum number of years to run the simulation. Default is 100.</p>
</td></tr>
<tr><td><code id="steady_+3A_t_per">t_per</code></td>
<td>
<p>The simulation is broken up into shorter runs of <code>t_per</code> years,
after each of which we check for convergence. Default value is 1.5. This
should be chosen as an odd multiple of the timestep <code>dt</code> in order to be
able to detect period 2 cycles.</p>
</td></tr>
<tr><td><code id="steady_+3A_dt">dt</code></td>
<td>
<p>The time step to use in <code>project()</code>.</p>
</td></tr>
<tr><td><code id="steady_+3A_tol">tol</code></td>
<td>
<p>The simulation stops when the relative change in the egg
production RDI over <code>t_per</code> years is less than <code>tol</code> for every species.</p>
</td></tr>
<tr><td><code id="steady_+3A_return_sim">return_sim</code></td>
<td>
<p>If TRUE, the function returns the MizerSim object holding
the result of the simulation run, saved at intervals of <code>t_per</code>. If FALSE (default) the function returns
a MizerParams object with the &quot;initial&quot; slots set to the steady state.</p>
</td></tr>
<tr><td><code id="steady_+3A_preserve">preserve</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
Specifies whether the <code>reproduction_level</code> should be preserved (default)
or the maximum reproduction rate <code>R_max</code> or the reproductive
efficiency <code>erepro</code>. See <code><a href="#topic+setBevertonHolt">setBevertonHolt()</a></code> for an explanation
of the <code>reproduction_level</code>.</p>
</td></tr>
<tr><td><code id="steady_+3A_progress_bar">progress_bar</code></td>
<td>
<p>A shiny progress object to implement a progress bar in a
shiny app. Default FALSE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the model use Beverton-Holt reproduction then the reproduction parameters
are set to values that give the level of reproduction observed in that
steady state. The <code>preserve</code> argument can be used to specify which of the
reproduction parameters should be preserved.
</p>


<h3>Value</h3>

<p>A MizerParams or a MizerSim object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
params &lt;- newTraitParams()
species_params(params)$gamma[5] &lt;- 3000
params &lt;- steady(params)
plotSpectra(params)

</code></pre>

<hr>
<h2 id='steadySingleSpecies'>Set initial abundances to single-species steady state abundances</h2><span id='topic+steadySingleSpecies'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
This first calculates growth and death rates that arise from the current
initial abundances. Then it uses these growth and death rates to
determine the steady-state abundances of the selected species.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>steadySingleSpecies(
  params,
  species = NULL,
  keep = c("egg", "biomass", "number")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="steadySingleSpecies_+3A_params">params</code></td>
<td>
<p>A MizerParams object</p>
</td></tr>
<tr><td><code id="steadySingleSpecies_+3A_species">species</code></td>
<td>
<p>The species to be selected. Optional. By default all target
species are selected. A vector of species names, or a numeric vector with
the species indices, or a logical vector indicating for each species
whether it is to be selected (TRUE) or not.</p>
</td></tr>
<tr><td><code id="steadySingleSpecies_+3A_keep">keep</code></td>
<td>
<p>A string determining which quantity is to be kept constant. The
choices are &quot;egg&quot; which keeps the egg density constant, &quot;biomass&quot; which
keeps the total biomass of the species constant and &quot;number&quot; which keeps
the total number of individuals constant.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The result of applying this function is of course not a multi-species steady
state, because after changing the abundances of the selected species the
growth and death rates will have changed.
</p>


<h3>Value</h3>

<p>A MizerParams object in which the initial abundances of the selected
species are changed to their single-species steady state abundances.
</p>

<hr>
<h2 id='summary_functions'>Description of summary functions</h2><span id='topic+summary_functions'></span>

<h3>Description</h3>

<p>Mizer provides a range of functions to summarise the results of a simulation.
</p>


<h3>Details</h3>

<p>A list of available summary functions is given in the table below.
</p>

<table>
<tr>
 <td style="text-align: left;">
Function </td><td style="text-align: left;"> Returns </td><td style="text-align: left;"> Description </td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+getDiet">getDiet()</a></code> </td><td style="text-align: left;"> Three dimensional array (predator x size x prey) </td><td style="text-align: left;"> Diet of predator at size, resolved by prey species </td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+getSSB">getSSB()</a></code> </td><td style="text-align: left;"> Two dimensional array (time x species) </td><td style="text-align: left;"> Total Spawning Stock Biomass (SSB) of each species through time where SSB is calculated as the sum of weight of all mature individuals. </td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+getBiomass">getBiomass()</a></code> </td><td style="text-align: left;"> Two dimensional array (time x species) </td><td style="text-align: left;"> Total biomass of each species through time. </td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+getN">getN()</a></code> </td><td style="text-align: left;"> Two dimensional array (time x species) </td><td style="text-align: left;"> Total abundance of each species through time. </td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+getFeedingLevel">getFeedingLevel()</a></code> </td><td style="text-align: left;"> Three dimensional array (time x species x size) </td><td style="text-align: left;"> Feeding level of each species by size through time. </td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+getM2">getM2</a></code> </td><td style="text-align: left;"> Three dimensional array (time x species x size) </td><td style="text-align: left;"> The predation mortality imposed on each species by size through time. </td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+getFMort">getFMort()</a></code> </td><td style="text-align: left;"> Three dimensional array (time x species x size) </td><td style="text-align: left;"> Total fishing mortality on each species by size through time. </td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+getFMortGear">getFMortGear()</a></code> </td><td style="text-align: left;"> Four dimensional array (time x gear x species x size) </td><td style="text-align: left;"> Fishing mortality on each species by each gear at size through time. </td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+getYieldGear">getYieldGear()</a></code> </td><td style="text-align: left;"> Three dimensional array (time x gear x species) </td><td style="text-align: left;"> Total yield by gear and species through time. </td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+getYield">getYield()</a></code> </td><td style="text-align: left;"> Two dimensional array (time x species) </td><td style="text-align: left;"> Total yield of each species across all gears through time. </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>See Also</h3>

<p><a href="#topic+indicator_functions">indicator_functions</a>, <a href="#topic+plotting_functions">plotting_functions</a>
</p>

<hr>
<h2 id='summary+2CMizerParams-method'>Summarize MizerParams object</h2><span id='topic+summary+2CMizerParams-method'></span>

<h3>Description</h3>

<p>Outputs a general summary of the structure and content of the object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'MizerParams'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary+2B2CMizerParams-method_+3A_object">object</code></td>
<td>
<p>A <code>MizerParams</code> object.</p>
</td></tr>
<tr><td><code id="summary+2B2CMizerParams-method_+3A_...">...</code></td>
<td>
<p>Other arguments (currently not used).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The MizerParams object, invisibly
</p>


<h3>Examples</h3>

<pre><code class='language-R'>summary(NS_params)
</code></pre>

<hr>
<h2 id='summary+2CMizerSim-method'>Summarize MizerSim object</h2><span id='topic+summary+2CMizerSim-method'></span>

<h3>Description</h3>

<p>Outputs a general summary of the structure and content of the object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'MizerSim'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary+2B2CMizerSim-method_+3A_object">object</code></td>
<td>
<p>A <code>MizerSim</code> object.</p>
</td></tr>
<tr><td><code id="summary+2B2CMizerSim-method_+3A_...">...</code></td>
<td>
<p>Other arguments (currently not used).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The MizerSim object, invisibly
</p>


<h3>Examples</h3>

<pre><code class='language-R'>summary(NS_sim)
</code></pre>

<hr>
<h2 id='truncated_lognormal_pred_kernel'>Truncated lognormal predation kernel</h2><span id='topic+truncated_lognormal_pred_kernel'></span>

<h3>Description</h3>

<p>This is like the <code><a href="#topic+lognormal_pred_kernel">lognormal_pred_kernel()</a></code> but with an imposed maximum
predator/prey mass ratio
</p>


<h3>Usage</h3>

<pre><code class='language-R'>truncated_lognormal_pred_kernel(ppmr, beta, sigma)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="truncated_lognormal_pred_kernel_+3A_ppmr">ppmr</code></td>
<td>
<p>A vector of predator/prey size ratios</p>
</td></tr>
<tr><td><code id="truncated_lognormal_pred_kernel_+3A_beta">beta</code></td>
<td>
<p>The preferred predator/prey size ratio</p>
</td></tr>
<tr><td><code id="truncated_lognormal_pred_kernel_+3A_sigma">sigma</code></td>
<td>
<p>The width parameter of the log-normal kernel</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Writing the predator mass as <code class="reqn">w</code> and the prey mass as <code class="reqn">w_p</code>,
the feeding kernel is given as
</p>
<p style="text-align: center;"><code class="reqn">\phi_i(w, w_p) = 
\exp \left[ \frac{-(\ln(w / w_p / \beta_i))^2}{2\sigma_i^2} \right]
</code>
</p>

<p>if <code class="reqn">w/w_p</code> is between 1 and
<code class="reqn">\beta_i\exp(3\sigma_i)</code>
and zero otherwise. Here <code class="reqn">\beta_i</code> is the preferred predator-prey mass
ratio and <code class="reqn">\sigma_i</code> determines the width of the kernel. These two
parameters need to be given in the species parameter dataframe in the columns
<code>beta</code> and <code>sigma</code>.
</p>
<p>This function is called from <code><a href="#topic+setPredKernel">setPredKernel()</a></code> to set up the
predation kernel slots in a MizerParams object.
</p>


<h3>Value</h3>

<p>A vector giving the value of the predation kernel at each of the
predator/prey mass ratios in the <code>ppmr</code> argument.
</p>


<h3>See Also</h3>

<p>Other predation kernel: 
<code><a href="#topic+box_pred_kernel">box_pred_kernel</a>()</code>,
<code><a href="#topic+lognormal_pred_kernel">lognormal_pred_kernel</a>()</code>,
<code><a href="#topic+power_law_pred_kernel">power_law_pred_kernel</a>()</code>
</p>

<hr>
<h2 id='upgradeParams'>Upgrade MizerParams object from earlier mizer versions</h2><span id='topic+upgradeParams'></span>

<h3>Description</h3>

<p>Occasionally during the development of new features for mizer, the
<a href="#topic+MizerParams-class">MizerParams</a> object gains extra slots. MizerParams objects
created in older versions of mizer are then no longer valid in the new
version because of the missing slots. You need to upgrade them with
</p>
<div class="sourceCode"><pre>params &lt;- upgradeParams(params)
</pre></div>
<p>where <code>params</code> should be replaced by the name of your MizerParams object.
This function adds the missing slots and fills them with default values. Any
object from version 0.4 onwards can be upgraded. Any old
<a href="#topic+MizerSim-class">MizerSim</a> objects should be similarly updated with
<code><a href="#topic+upgradeSim">upgradeSim()</a></code>. This function uses <code><a href="#topic+newMultispeciesParams">newMultispeciesParams()</a></code> to create a new
MizerParams object using the parameters extracted from the old MizerParams
object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>upgradeParams(params)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="upgradeParams_+3A_params">params</code></td>
<td>
<p>An old MizerParams object to be upgraded</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The upgraded MizerParams object
</p>


<h3>Backwards compatibility</h3>

<p>The internal numerics in mizer have changed over time, so there may be small
discrepancies between the results obtained with the upgraded object
in the new version and the original object in the old version. If it
is important for you to reproduce the exact results then you should install
the version of mizer with which you obtained the results. You can do this
with
</p>
<div class="sourceCode"><pre>remotes::install_github("sizespectrum/mizer", ref = "v0.2")
</pre></div>
<p>where you should replace &quot;v0.2&quot; with the version number you require. You can
see the list of available releases at
<a href="https://github.com/sizespectrum/mizer/tags">https://github.com/sizespectrum/mizer/tags</a>.
</p>
<p>If you only have a serialised version of the old object, for example
created via <code><a href="base.html#topic+saveRDS">saveRDS()</a></code>, and you get an error when trying to read it in
with <code><a href="base.html#topic+readRDS">readRDS()</a></code> then unfortunately you will need to install the old version
of mizer first to read the params object into your workspace, then switch
to the current version and then call <code><a href="#topic+upgradeParams">upgradeParams()</a></code>. You can then save
the new version again with <code><a href="base.html#topic+saveRDS">saveRDS()</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+validParams">validParams()</a></code>
</p>

<hr>
<h2 id='upgradeSim'>Upgrade MizerSim object from earlier mizer versions</h2><span id='topic+upgradeSim'></span>

<h3>Description</h3>

<p>Occasionally, during the development of new features for mizer, the
<a href="#topic+MizerSim-class">MizerSim</a> class or the <a href="#topic+MizerParams-class">MizerParams</a> class gains
extra slots. MizerSim objects created in older versions of mizer are then no
longer valid in the new version because of the missing slots. You need to
upgrade them with
</p>
<div class="sourceCode"><pre>sim &lt;- upgradeSim(sim)
</pre></div>
<p>where <code>sim</code> should be replaced by the name of your MizerSim object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>upgradeSim(sim)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="upgradeSim_+3A_sim">sim</code></td>
<td>
<p>An old MizerSim object to be upgraded</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function adds the missing slots and fills them with default values. It
calls <code><a href="#topic+upgradeParams">upgradeParams()</a></code> to upgrade the MizerParams object inside the MizerSim
object. Any object from version 0.4 onwards can be upgraded.
</p>


<h3>Value</h3>

<p>The upgraded MizerSim object
</p>


<h3>Backwards compatibility</h3>

<p>The internal numerics in mizer have changed over time, so there may be small
discrepancies between the results obtained with the upgraded object
in the new version and the original object in the old version. If it
is important for you to reproduce the exact results then you should install
the version of mizer with which you obtained the results. You can do this
with
</p>
<div class="sourceCode"><pre>remotes::install_github("sizespectrum/mizer", ref = "v0.2")
</pre></div>
<p>where you should replace &quot;v0.2&quot; with the version number you require. You can
see the list of available releases at
<a href="https://github.com/sizespectrum/mizer/tags">https://github.com/sizespectrum/mizer/tags</a>.
</p>
<p>If you only have a serialised version of the old object, for example
created via <code><a href="base.html#topic+saveRDS">saveRDS()</a></code>, and you get an error when trying to read it in
with <code><a href="base.html#topic+readRDS">readRDS()</a></code> then unfortunately you will need to install the old version
of mizer first to read the params object into your workspace, then switch
to the current version and then call <code><a href="#topic+upgradeParams">upgradeParams()</a></code>. You can then save
the new version again with <code><a href="base.html#topic+saveRDS">saveRDS()</a></code>.
</p>

<hr>
<h2 id='valid_species_arg'>Helper function to assure validity of species argument</h2><span id='topic+valid_species_arg'></span>

<h3>Description</h3>

<p>If the species argument contains invalid species, then these are
ignored but a warning is issued.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>valid_species_arg(
  object,
  species = NULL,
  return.logical = FALSE,
  error_on_empty = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="valid_species_arg_+3A_object">object</code></td>
<td>
<p>A MizerSim or MizerParams object from which the species
should be selected.</p>
</td></tr>
<tr><td><code id="valid_species_arg_+3A_species">species</code></td>
<td>
<p>The species to be selected. Optional. By default all target
species are selected. A vector of species names, or a
numeric vector with the species indices, or a logical vector indicating for
each species whether it is to be selected (TRUE) or not.</p>
</td></tr>
<tr><td><code id="valid_species_arg_+3A_return.logical">return.logical</code></td>
<td>
<p>Whether the return value should be a logical vector.
Default FALSE.</p>
</td></tr>
<tr><td><code id="valid_species_arg_+3A_error_on_empty">error_on_empty</code></td>
<td>
<p>Whether to throw an error if there are zero valid
species. Default FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of species names, in the same order as specified in the
'species' argument. If 'return.logical = TRUE' then a logical vector is
returned instead, with length equal to the number of species, with
TRUE entry for each selected species.
</p>

<hr>
<h2 id='validGearParams'>Check validity of gear parameters and set defaults</h2><span id='topic+validGearParams'></span>

<h3>Description</h3>

<p>The function returns a valid gear parameter data frame that can be used
by <code>setFishing()</code> or it gives an error message.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>validGearParams(gear_params, species_params)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="validGearParams_+3A_gear_params">gear_params</code></td>
<td>
<p>Gear parameter data frame</p>
</td></tr>
<tr><td><code id="validGearParams_+3A_species_params">species_params</code></td>
<td>
<p>Species parameter data frame</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The gear_params data frame is allowed to have zero rows, but if it has
rows, then the following requirements apply:
</p>

<ul>
<li><p> There must be columns <code>species</code> and <code>gear</code> and any species - gear pair is
allowed to appear at most once. Any species that appears must also appear
in the <code>species_params</code> data frame.
</p>
</li>
<li><p> There must be a <code>sel_func</code> column. If a selectivity function is not
supplied, it will be set to &quot;knife_edge&quot;.
</p>
</li>
<li><p> There must be a <code>catchability</code> column. If a catchability is not supplied,
it will be set to 1.
</p>
</li>
<li><p> All the parameters required by the selectivity functions must be provided.
</p>
</li></ul>

<p>If gear_params is empty, then this function tries to find the necessary
information in the species_params data frame. This restricts each species
to be fished by only one gear. Defaults are used for information that can
not be found in the species_params dataframe, as follows:
</p>

<ul>
<li><p> If there is no <code>gear</code> column or it is NA then a new gear named after the
species is introduced.
</p>
</li>
<li><p> If there is no <code>sel_func</code> column or it is NA then <code>knife_edge</code> is used.
</p>
</li>
<li><p> If there is no <code>catchability</code> column or it is NA then this is set to 1.
</p>
</li>
<li><p> If the selectivity function is <code>knife_edge</code> and no <code>knife_edge_size</code> is
provided, it is set to <code>w_mat</code>.
</p>
</li></ul>

<p>The row names of the returned data frame are of the form
&quot;species, gear&quot;.
</p>
<p>When <code>gear_params</code> is <code>NULL</code> and there is no gear information in
<code>species_params</code>, then a gear called <code>knife_edge_gear</code> is set up with a
<code>knife_edge</code> selectivity for each species and a <code>knive_edge_size</code> equal to
<code>w_mat</code>. Catchability is set to 0.3 for all species.
</p>


<h3>Value</h3>

<p>A valid gear parameter data frame
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gear_params">gear_params()</a></code>
</p>

<hr>
<h2 id='validParams'>Validate MizerParams object and upgrade if necessary using <code><a href="#topic+upgradeParams">upgradeParams()</a></code>.</h2><span id='topic+validParams'></span>

<h3>Description</h3>

<p>Validate MizerParams object and upgrade if necessary using <code><a href="#topic+upgradeParams">upgradeParams()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>validParams(params)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="validParams_+3A_params">params</code></td>
<td>
<p>The MizerParams object to validate</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A valid MizerParams object
</p>

<hr>
<h2 id='validSpeciesParams'>Validate species parameter data frame</h2><span id='topic+validSpeciesParams'></span>

<h3>Description</h3>

<p>Check validity of species parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>validSpeciesParams(species_params)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="validSpeciesParams_+3A_species_params">species_params</code></td>
<td>
<p>The user-supplied species parameter data frame</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A valid species parameter data frame
</p>
<p>This function throws an error if
</p>

<ul>
<li><p> the <code>species</code> column does not exist or contains duplicates
</p>
</li>
<li><p> the maximum size is not specified for all species
</p>
</li></ul>

<p>If a weight-based parameter is missing but the corresponding length-based
parameter is given, as well as the <code>a</code> and <code>b</code> parameters for length-weight
conversion, then the weight-based parameters are added. If both length and
weight are given, then weight is used and a warning is issued if the two are
inconsistent.
</p>
<p>If a <code>w_inf</code> column is given but no <code>w_max</code> then the value from <code>w_inf</code> is
used. This is for backwards compatibility.
</p>
<p>Some inconsistencies in the size parameters are resolved as follows:
</p>

<ul>
<li><p> Any <code>w_mat</code> that is not smaller than <code>w_max</code> is set to <code>w_max / 4</code>.
</p>
</li>
<li><p> Any <code>w_mat25</code> that is not smaller than <code>w_mat</code> is set to NA.
</p>
</li>
<li><p> Any <code>w_min</code> that is not smaller than <code>w_mat</code> is set to <code>0.001</code> or
<code>w_mat /10</code>, whichever is smaller.
</p>
</li></ul>

<p>The row names of the returned data frame will be the species names.
If <code>species_params</code> was provided as a tibble it is converted back to an
ordinary data frame.
</p>
<p>The function tests for some typical misspellings of parameter names, like
wrong capitalisation or missing underscores and issues a warning if it
detects such a name.
</p>
<p>Note that the species parameters returned by this function are not guaranteed
to produce a viable model. More checks of the parameters are performed by the
individual rate-setting functions (see <code><a href="#topic+setParams">setParams()</a></code> for the list of these
functions).
</p>


<h3>See Also</h3>

<p>species_params()
</p>

<hr>
<h2 id='w'>Size bins</h2><span id='topic+w'></span><span id='topic+w_full'></span><span id='topic+dw'></span><span id='topic+dw_full'></span>

<h3>Description</h3>

<p>Functions to fetch information about the size bins used in the model
described by <code>params</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>w(params)

w_full(params)

dw(params)

dw_full(params)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="w_+3A_params">params</code></td>
<td>
<p>A MizerParams object</p>
</td></tr>
</table>


<h3>Details</h3>

<p>To represent the continuous size spectrum in the computer, the size
variable is discretized into a vector <code>w</code> of discrete weights,
providing a grid of sizes spanning the range from the smallest egg size
to the largest maximum size. These grid values divide the full size
range into a finite number of size bins. The size bins should be chosen
small enough to avoid the discretisation errors from becoming too big.
You can fetch this vector with <code>w()</code> and the vector of bin widths with
<code>dw()</code>.
</p>
<p>The weight grid is set up to be logarithmically spaced, so that
<code>w[j]=w[1]*10^(j*dx)</code> for some fixed <code>dx</code>. This means that the bin widths
increase with size: <code>dw[j] = w[j] * (10^dx - 1)</code>.
This grid is set up automatically when creating a MizerParams object.
</p>
<p>Because the resource spectrum spans a larger range of sizes, these sizes
are discretized into a different vector of weights <code>w_full</code>. This usually
starts at a much smaller size than <code>w</code>, but also runs up to the same
largest size, so that the last entries of <code>w_full</code> have to coincide with the
entries of <code>w</code>. The logarithmic spacing for <code>w_full</code> is the same as that for
<code>w</code>, so that again <code>w_full[j]=w_full[1]*10^(j*dx)</code>. The function <code>w_full()</code>
gives the vector of sizes and <code>dw_full()</code> gives the vector of bin widths.
</p>
<p>You will need these vectors when converting number densities to numbers.
For example the size spectrum of a species is stored as a vector of
values that represent the <em>density</em> of fish in each size bin rather than
the <em>number</em> of fish. The number of fish in the size bin between <code>w[j]</code> and
<code>w[j+1]=w[j]+dw[j]</code> is obtained as <code>N[j]*dw[j]</code>.
</p>
<p>The vector <code>w</code> can be used for example to convert the number of individuals
in a size bin into the biomass in the size bin. The biomass in the
<code>j</code>th bin is <code>biomass[j] = N[j] * dw[j] * w[j]</code>.
</p>
<p>Of course all these calculations with discrete sizes and size bins are
only giving approximations to the continuous values, and these approximations
get better the smaller the size bins are, i.e., the more size bins are
used. However using more size bins also slows down the calculations, so
there is a trade-off. This is why the functions setting up MizerParams
objects allow you to choose the number of size bins <code>no_w</code>.
</p>


<h3>Value</h3>

<p><code>w()</code> returns a vector with the sizes at the start of each size bin
of the consumer spectrum.
</p>
<p><code>w_full()</code> returns a vector with the sizes at the start of each size
bin of the resource spectrum, which typically starts at smaller sizes than
the consumer spectrum.
</p>
<p><code>dw()</code> returns a vector with the widths of the size bins of the
consumer spectrum.
</p>
<p><code>dw_full()</code> returns a vector with the widths of the size bins of the
resource spectrum.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>str(w(NS_params))
str(dw(NS_params))
str(w_full(NS_params))
str(dw_full(NS_params))

# Calculating the biomass of Cod in each bin in the North Sea model
biomass &lt;- initialN(NS_params)["Cod", ] * dw(NS_params) * w(NS_params)
# Summing to get total biomass
sum(biomass)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
