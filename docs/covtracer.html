<!DOCTYPE html><html lang="en"><head><title>Help for package covtracer</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {covtracer}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#as_list_of_srcref'><p>Create an S3 list of srcref objects</p></a></li>
<li><a href='#as_test_desc'><p>Wrap object in test description derivation data</p></a></li>
<li><a href='#as.data.frame.list_of_srcref'><p>Coerce a list_of_srcref object to a data.frame</p></a></li>
<li><a href='#as.package'><p>A simple alternative to <code>devtools::as.package</code></p></a></li>
<li><a href='#coverage_check_has_recorded_tests'><p>Check that the coverage object retains testing information</p></a></li>
<li><a href='#coverage_get_tests'><p>Retrieve test traces from a coverage object</p></a></li>
<li><a href='#coverage_has_recorded_tests'><p>Test that the coverage object retains testing information</p></a></li>
<li><a href='#expr_str'><p>Convert an expression, call or symbol to a single-line string</p></a></li>
<li><a href='#flat_map_srcrefs'><p>Map <code>srcrefs</code> over an iterable object, Filtering non-srcref results</p></a></li>
<li><a href='#format.list_of_srcref'><p>Format a list_of_srcref object</p></a></li>
<li><a href='#get_namespace_object_names'><p>Get namespace exports, filtering methods tables and definitions</p></a></li>
<li><a href='#getSrcFilepath'><p>Get the full path to the srcref file</p></a></li>
<li><a href='#is_srcref'><p>Test whether an object is a <code>srcref</code> object</p></a></li>
<li><a href='#join_on_containing_srcrefs'><p>Join srcref data.frames by intersection of srcref spans</p></a></li>
<li><a href='#match_containing_srcrefs'><p>Match srcrefs against srcrefs that contain them</p></a></li>
<li><a href='#new_empty_test_trace_tally'><p>Build an empty covr-style test trace mapping</p></a></li>
<li><a href='#obj_namespace_name'><p>Get namespace export namespace name</p></a></li>
<li><a href='#package_check_has_keep_source'><p>Verify that the package collection contains srcref information</p></a></li>
<li><a href='#pkg_srcrefs'><p>Extract all the srcref objects of objects within a package namespace</p></a></li>
<li><a href='#pkg_srcrefs_df'><p>Create a data.frame of package srcref objects</p></a></li>
<li><a href='#Rd_df'><p>Create a tabular representation of man file information</p></a></li>
<li><a href='#srcref_expr'><p>Parse the expression associated with a srcref</p></a></li>
<li><a href='#srcref_str'><p>Convert a srcref into a string</p></a></li>
<li><a href='#srcrefs'><p>Retrieve <code>srcref</code>s</p></a></li>
<li><a href='#test_description'><p>Parse a test description from the calling expression</p></a></li>
<li><a href='#test_description_test_that'><p>Parse the test description from a <code>test_that</code> call</p></a></li>
<li><a href='#test_description_test_that_describe'><p>Parse the test description from a <code>describe</code> call</p></a></li>
<li><a href='#test_description_test_that_describe_it'><p>Parse the test description from a <code>it</code> call</p></a></li>
<li><a href='#test_srcrefs'><p>Extract test srcref objects</p></a></li>
<li><a href='#test_srcrefs_df'><p>Create a data.frame of coverage test srcref objects</p></a></li>
<li><a href='#test_trace_df'><p>Build a traceability matrix that links documented behaviors to unit tests</p></a></li>
<li><a href='#test_trace_mapping'><p>Create a data.frame mapping tests to coverage traces</p></a></li>
<li><a href='#trace_srcrefs'><p>Extract srcref objects from coverage object traces</p></a></li>
<li><a href='#trace_srcrefs_df'><p>Create a data.frame of coverage trace srcref objects</p></a></li>
<li><a href='#with_pseudo_srcref'><p>For consistency, stub calls with srcref-like attributes</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Contextualizing Tests</td>
</tr>
<tr>
<td>Version:</td>
<td>0.0.1</td>
</tr>
<tr>
<td>Description:</td>
<td>
    Dissects a package environment or 'covr' coverage object in order to cross
    reference tested code with the lines that are evaluated, as well as linking
    those evaluated lines to the documentation that they are described within.
    Connecting these three pieces of information provides a mechanism of 
	linking tests to documented behaviors.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/genentech/covtracer">https://github.com/genentech/covtracer</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/genentech/covtracer/issues">https://github.com/genentech/covtracer/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.2.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>tools, stats, methods</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, covr (&ge; 3.5.2), withr, R6, cli, dplyr, igraph,
knitr, rmarkdown</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-07-04 17:10:53 UTC; root</td>
</tr>
<tr>
<td>Author:</td>
<td>Doug Kelkhoff <a href="https://orcid.org/0009-0003-7845-4061"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [cre, aut],
  Szymon Maksymiuk <a href="https://orcid.org/0000-0002-3120-1601"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Andrew McNeil [aut],
  F. Hoffmann-La Roche AG [cph, fnd]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Doug Kelkhoff &lt;doug.kelkhoff@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-07-08 05:00:07 UTC</td>
</tr>
</table>
<hr>
<h2 id='as_list_of_srcref'>Create an S3 list of srcref objects</h2><span id='topic+as_list_of_srcref'></span><span id='topic+as_list_of_srcref.environment'></span><span id='topic+as_list_of_srcref.list'></span>

<h3>Description</h3>

<p>Create an S3 list of srcref objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_list_of_srcref(x)

## S3 method for class 'environment'
as_list_of_srcref(x)

## S3 method for class 'list'
as_list_of_srcref(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as_list_of_srcref_+3A_x">x</code></td>
<td>
<p>A list or single srcref to coerce to a <code>list_of_srcref</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list_of_srcref</code> class object
</p>

<hr>
<h2 id='as_test_desc'>Wrap object in test description derivation data</h2><span id='topic+as_test_desc'></span><span id='topic+as_testthat_desc'></span>

<h3>Description</h3>

<p>Wrap object in test description derivation data
</p>
<p>Adds &quot;testthat&quot; style
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_test_desc(x, type = "call")

as_testthat_desc(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as_test_desc_+3A_x">x</code></td>
<td>
<p>A test description string to bind style data to</p>
</td></tr>
<tr><td><code id="as_test_desc_+3A_type">type</code></td>
<td>
<p>A type class to attribute to the test description. Defaults to
<code>"call"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>test_description</code> subclass object with additional
<code>style</code> attribute indicating how the test description was derived.
</p>

<hr>
<h2 id='as.data.frame.list_of_srcref'>Coerce a list_of_srcref object to a data.frame</h2><span id='topic+as.data.frame.list_of_srcref'></span>

<h3>Description</h3>

<p>Coerce a list_of_srcref object to a data.frame
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'list_of_srcref'
as.data.frame(
  x,
  ...,
  use.names = TRUE,
  expand.srcref = FALSE,
  row.names = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as.data.frame.list_of_srcref_+3A_x">x</code></td>
<td>
<p>A <code>list_of_srcref</code> object</p>
</td></tr>
<tr><td><code id="as.data.frame.list_of_srcref_+3A_...">...</code></td>
<td>
<p>Additional arguments unused</p>
</td></tr>
<tr><td><code id="as.data.frame.list_of_srcref_+3A_use.names">use.names</code></td>
<td>
<p>A <code>logical</code> indicating whether the names of <code>x</code>
should be used to create a <code>name</code> column.</p>
</td></tr>
<tr><td><code id="as.data.frame.list_of_srcref_+3A_expand.srcref">expand.srcref</code></td>
<td>
<p>A <code>logical</code> indicating whether to expand the
components of <code>srcref</code> objects into separate columns.</p>
</td></tr>
<tr><td><code id="as.data.frame.list_of_srcref_+3A_row.names">row.names</code></td>
<td>
<p><code>NULL</code> or a single integer or character string
specifying a column to be used as row names, or a character or
integer vector giving the row names for the data frame.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code> with one record per <code>srcref</code> and variables:
</p>

<dl>
<dt>name</dt><dd><p>Names of the <code>srcref</code> objects, passed using the names of
<code>x</code> if <code>use.names = TRUE</code></p>
</dd>
<dt>srcref</dt><dd><p><code>srcref</code> objects if <code>expand.srcrefs = FALSE</code></p>
</dd>
<dt>srcfile, line1, byte1, line2, col1, col2, parsed1, parsed2</dt><dd><p>The
<code>srcref</code> file location if it can be determined. If an absolute path
can't be found, only the base file name provided in the <code>srcref</code> object and
the numeric components of the <code>srcref</code> objects if <code>expand.srcrefs
  = TRUE</code></p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>pkg &lt;- system.file("examplepkg", package = "covtracer")
install.packages(
  pkg,
  type = "source",
  repos = NULL,
  quiet = TRUE,
  INSTALL_opts = "--with-keep.source"
)
as.data.frame(pkg_srcrefs("examplepkg"))
</code></pre>

<hr>
<h2 id='as.package'>A simple alternative to <code>devtools::as.package</code></h2><span id='topic+as.package'></span>

<h3>Description</h3>

<p>Functionally identical to <code>devtools</code>' <code>as.package</code>, but without interactive
options for package creation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.package(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as.package_+3A_x">x</code></td>
<td>
<p>A package object to coerce</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>package</code> object
</p>


<h3>Note</h3>

<p>Code inspired by <code>devtools</code> <code>load_pkg_description</code> with very minor
edits to further reduce <code>devtools</code> dependencies.
</p>

<hr>
<h2 id='coverage_check_has_recorded_tests'>Check that the coverage object retains testing information</h2><span id='topic+coverage_check_has_recorded_tests'></span>

<h3>Description</h3>

<p>Check whether the coverage object has expected fields produced when coverage
was captured with <code>option(covr.record_tests = TRUE)</code>, throwing an error
if it was not.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coverage_check_has_recorded_tests(coverage, warn = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="coverage_check_has_recorded_tests_+3A_coverage">coverage</code></td>
<td>
<p>a <code><a href="covr.html#topic+covr">covr</a></code> coverage object</p>
</td></tr>
<tr><td><code id="coverage_check_has_recorded_tests_+3A_warn">warn</code></td>
<td>
<p>Whether to warn when it is uncertain whether the tests were
recorded. It may be uncertain if tests were recorded if there are no tested
R code traces.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Used for side-effects of emitting an error when a coverage object
does not contain recorded traces, or a warning when a coverage object
appears to have no tests.
</p>


<h3>See Also</h3>

<p>Other coverage_tests: 
<code><a href="#topic+coverage_get_tests">coverage_get_tests</a>()</code>,
<code><a href="#topic+coverage_has_recorded_tests">coverage_has_recorded_tests</a>()</code>
</p>

<hr>
<h2 id='coverage_get_tests'>Retrieve test traces from a coverage object</h2><span id='topic+coverage_get_tests'></span>

<h3>Description</h3>

<p>Assumes the coverage object was produced while
<code>option(covr.record_tests = TRUE)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coverage_get_tests(coverage)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="coverage_get_tests_+3A_coverage">coverage</code></td>
<td>
<p>a <code><a href="covr.html#topic+covr">covr</a></code> coverage object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> of tests evaluated when using <code>covr</code>
</p>


<h3>See Also</h3>

<p>Other coverage_tests: 
<code><a href="#topic+coverage_check_has_recorded_tests">coverage_check_has_recorded_tests</a>()</code>,
<code><a href="#topic+coverage_has_recorded_tests">coverage_has_recorded_tests</a>()</code>
</p>

<hr>
<h2 id='coverage_has_recorded_tests'>Test that the coverage object retains testing information</h2><span id='topic+coverage_has_recorded_tests'></span>

<h3>Description</h3>

<p>Test whether the coverage object has expected fields produced when coverage
was captured with <code>option(covr.record_tests = TRUE)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coverage_has_recorded_tests(coverage)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="coverage_has_recorded_tests_+3A_coverage">coverage</code></td>
<td>
<p>a <code><a href="covr.html#topic+covr">covr</a></code> coverage object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>logical</code> value, indicating whether the coverage object has
recorded tests, or <code>NA</code> when it does not appear to have traced any test
code.
</p>


<h3>See Also</h3>

<p>Other coverage_tests: 
<code><a href="#topic+coverage_check_has_recorded_tests">coverage_check_has_recorded_tests</a>()</code>,
<code><a href="#topic+coverage_get_tests">coverage_get_tests</a>()</code>
</p>

<hr>
<h2 id='expr_str'>Convert an expression, call or symbol to a single-line string</h2><span id='topic+expr_str'></span>

<h3>Description</h3>

<p>Convert an expression, call or symbol to a single-line string
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expr_str(ref)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="expr_str_+3A_ref">ref</code></td>
<td>
<p>a <code>srcref</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>The given expression, formatted as a string with prefixes for
symbols and generics.
</p>

<hr>
<h2 id='flat_map_srcrefs'>Map <code>srcrefs</code> over an iterable object, Filtering non-srcref results</h2><span id='topic+flat_map_srcrefs'></span>

<h3>Description</h3>

<p>Map <code>srcrefs</code> over an iterable object, Filtering non-srcref results
</p>


<h3>Usage</h3>

<pre><code class='language-R'>flat_map_srcrefs(xs, ns = NULL, breadcrumbs = character())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="flat_map_srcrefs_+3A_xs">xs</code></td>
<td>
<p>Any iterable object</p>
</td></tr>
<tr><td><code id="flat_map_srcrefs_+3A_ns">ns</code></td>
<td>
<p>A <code>character</code> namespace name to attribute to objects in <code>xs</code>. If
<code>xs</code> objects themselves have namespaces attributed already to them, the
namespace will not be replaced.</p>
</td></tr>
<tr><td><code id="flat_map_srcrefs_+3A_breadcrumbs">breadcrumbs</code></td>
<td>
<p>Recursive methods are expected to propegate a vector of
&quot;breadcrumbs&quot; (a character vector of namespace names encountered while
traversing the namespace used as a memory of what we've seen already),
which is used for short-circuiting recursive environment traversal.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> of <code>srcref</code>s
</p>

<hr>
<h2 id='format.list_of_srcref'>Format a list_of_srcref object</h2><span id='topic+format.list_of_srcref'></span>

<h3>Description</h3>

<p>Format list_of_srcref as character
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'list_of_srcref'
format(x, ..., full.names = FALSE, full.num = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="format.list_of_srcref_+3A_x">x</code></td>
<td>
<p>A <code>list_of_srcref</code> object</p>
</td></tr>
<tr><td><code id="format.list_of_srcref_+3A_...">...</code></td>
<td>
<p>Additional arguments unused</p>
</td></tr>
<tr><td><code id="format.list_of_srcref_+3A_full.names">full.names</code></td>
<td>
<p>A <code>logical</code> value indicating whether to use full file
paths when formatting <code>srcref</code>s.</p>
</td></tr>
<tr><td><code id="format.list_of_srcref_+3A_full.num">full.num</code></td>
<td>
<p>A <code>logical</code> value indicating whether to use all numeric
<code>srcref</code> components when formatting <code>srcref</code>s.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>character</code> vector of formatted strings
</p>

<hr>
<h2 id='get_namespace_object_names'>Get namespace exports, filtering methods tables and definitions</h2><span id='topic+get_namespace_object_names'></span>

<h3>Description</h3>

<p>Get namespace exports, filtering methods tables and definitions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_namespace_object_names(ns)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_namespace_object_names_+3A_ns">ns</code></td>
<td>
<p>A namespace object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The names of exported objects, filtering internal method tables and
metadata.
</p>

<hr>
<h2 id='getSrcFilepath'>Get the full path to the srcref file</h2><span id='topic+getSrcFilepath'></span>

<h3>Description</h3>

<p>Get the full path to the srcref file
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getSrcFilepath(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getSrcFilepath_+3A_x">x</code></td>
<td>
<p>A <code>srcref</code> or <code>list_of_srcref</code> object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>character</code> vector of source file paths.
</p>

<hr>
<h2 id='is_srcref'>Test whether an object is a <code>srcref</code> object</h2><span id='topic+is_srcref'></span>

<h3>Description</h3>

<p>Test whether an object is a <code>srcref</code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_srcref(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is_srcref_+3A_x">x</code></td>
<td>
<p>Any object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>logical</code> indicating whether object is a <code>srcref</code>
</p>

<hr>
<h2 id='join_on_containing_srcrefs'>Join srcref data.frames by intersection of srcref spans</h2><span id='topic+join_on_containing_srcrefs'></span>

<h3>Description</h3>

<p>References to source code are defined by the source code line and column span
of the relevant source code. This function takes data frames containing that
information to pair source code in one data frame to source code from
another. In this case, source code from the left hand data frame is paired if
it is entirely contained within a record of source code in the right hand
data frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>join_on_containing_srcrefs(x, y, by = c(srcref = "srcref"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="join_on_containing_srcrefs_+3A_x">x</code></td>
<td>
<p>A <code>data.frame</code>, as produced by <code>as.data.frame</code> applied to a
<code>list_of_srcref</code>, against which <code>y</code> should be joined.</p>
</td></tr>
<tr><td><code id="join_on_containing_srcrefs_+3A_y">y</code></td>
<td>
<p>A <code>data.frame</code>, as produced by <code>as.data.frame</code> applied to a
<code>list_of_srcref</code>, joining data from srcrefs data which encompasses srcrefs
from <code>x</code>.</p>
</td></tr>
<tr><td><code id="join_on_containing_srcrefs_+3A_by">by</code></td>
<td>
<p>A named <code>character</code> <code>vector</code> of column names to use for the merge.
The name should be the name of the column from the left <code>data.frame</code>
containing a <code>list_of_srcref</code> column, and the value should be the name of a
column from the right <code>data.frame</code> containing a <code>list_of_srcref</code> column.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code> of <code>x</code> joined on <code>y</code> by spanning <code>srcref</code>
</p>

<hr>
<h2 id='match_containing_srcrefs'>Match srcrefs against srcrefs that contain them</h2><span id='topic+match_containing_srcrefs'></span>

<h3>Description</h3>

<p>Provided two lists of <code>srcref</code> objects, find the first <code>srcrefs</code> in <code>r</code> that
entirely encapsulate each respective <code>srcref</code> in <code>l</code>, returning a list of
indices of <code>srcref</code>s in <code>r</code> for each <code>srcref</code> in <code>l</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>match_containing_srcrefs(l, r)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="match_containing_srcrefs_+3A_l">l</code></td>
<td>
<p>A <code>list_of_srcref</code> object</p>
</td></tr>
<tr><td><code id="match_containing_srcrefs_+3A_r">r</code></td>
<td>
<p>A <code>list_of_srcref</code> object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>integer</code> vector of the first index in <code>r</code> that fully encapsulate
the respective element in <code>l</code>
</p>

<hr>
<h2 id='new_empty_test_trace_tally'>Build an empty covr-style test trace mapping</h2><span id='topic+new_empty_test_trace_tally'></span>

<h3>Description</h3>

<p>Build an empty covr-style test trace mapping
</p>


<h3>Usage</h3>

<pre><code class='language-R'>new_empty_test_trace_tally()
</code></pre>


<h3>Value</h3>

<p>An empty test-trace matrix, as provided by <code>covr</code>
</p>

<hr>
<h2 id='obj_namespace_name'>Get namespace export namespace name</h2><span id='topic+obj_namespace_name'></span>

<h3>Description</h3>

<p>For most objects, this will be identical to the namespace name provided, but
reexports will retain their originating package's namespace name. This helper
function helps to expose this name to determine which exports are reexports.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>obj_namespace_name(x, ns)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="obj_namespace_name_+3A_x">x</code></td>
<td>
<p>A value to find within namespace <code>ns</code></p>
</td></tr>
<tr><td><code id="obj_namespace_name_+3A_ns">ns</code></td>
<td>
<p>A package namespace</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>character</code> string representing a namespace or similar
</p>

<hr>
<h2 id='package_check_has_keep_source'>Verify that the package collection contains srcref information</h2><span id='topic+package_check_has_keep_source'></span>

<h3>Description</h3>

<p>Test whether the package object collection contains srcref attributes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>package_check_has_keep_source(env)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="package_check_has_keep_source_+3A_env">env</code></td>
<td>
<p>A package namespace environment or iterable collection of package
objects</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Used for side effect of throwing an error when a package was not
installed with <code>srcref</code>s.
</p>

<hr>
<h2 id='pkg_srcrefs'>Extract all the srcref objects of objects within a package namespace</h2><span id='topic+pkg_srcrefs'></span><span id='topic+pkg_srcrefs.environment'></span><span id='topic+pkg_srcrefs.character'></span><span id='topic+pkg_srcrefs.coverage'></span>

<h3>Description</h3>

<p>Extract all the srcref objects of objects within a package namespace
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pkg_srcrefs(x)

## S3 method for class 'environment'
pkg_srcrefs(x)

## S3 method for class 'character'
pkg_srcrefs(x)

## S3 method for class 'coverage'
pkg_srcrefs(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pkg_srcrefs_+3A_x">x</code></td>
<td>
<p>A <code><a href="covr.html#topic+package_coverage">package_coverage</a></code> coverage object, from which
the name of the package used is extracted.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list_of_srcref</code>
</p>


<h3>See Also</h3>

<p>as.data.frame.list_of_srcref
</p>
<p>Other srcrefs: 
<code><a href="#topic+test_srcrefs">test_srcrefs</a>()</code>,
<code><a href="#topic+trace_srcrefs">trace_srcrefs</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pkg &lt;- system.file("examplepkg", package = "covtracer")
install.packages(
  pkg,
  type = "source",
  repos = NULL,
  quiet = TRUE,
  INSTALL_opts = "--with-keep.source"
)
pkg_srcrefs("examplepkg")

</code></pre>

<hr>
<h2 id='pkg_srcrefs_df'>Create a data.frame of package srcref objects</h2><span id='topic+pkg_srcrefs_df'></span>

<h3>Description</h3>

<p>Create a data.frame of package srcref objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pkg_srcrefs_df(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pkg_srcrefs_df_+3A_x">x</code></td>
<td>
<p>A <code><a href="covr.html#topic+package_coverage">package_coverage</a></code> coverage object, from which
the name of the package used is extracted.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code> with a record for each source code block with
variables:
</p>

<dl>
<dt>name</dt><dd><p>A <code>character</code> Rd alias for the package object</p>
</dd>
<dt>srcref</dt><dd><p>The <code>srcref</code> of the associated package source code</p>
</dd>
</dl>



<h3>See Also</h3>

<p>srcrefs test_trace_mapping
</p>
<p>Other srcrefs_df: 
<code><a href="#topic+test_srcrefs_df">test_srcrefs_df</a>()</code>,
<code><a href="#topic+trace_srcrefs_df">trace_srcrefs_df</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pkg &lt;- system.file("examplepkg", package = "covtracer")
install.packages(
  pkg,
  type = "source",
  repos = NULL,
  quiet = TRUE,
  INSTALL_opts = "--with-keep.source"
)
pkg_srcrefs_df("examplepkg")

</code></pre>

<hr>
<h2 id='Rd_df'>Create a tabular representation of man file information</h2><span id='topic+Rd_df'></span>

<h3>Description</h3>

<p>Provides Rd index info with a few additional columns of information about
each exported object. Returns one record per documented object, even if
multiple objects alias to the same documentation file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Rd_df(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Rd_df_+3A_x">x</code></td>
<td>
<p>A package object to coerce</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code> of documented object information with variables:
</p>

<dl>
<dt>index</dt><dd><p>A <code>numeric</code> index of documentation files associated with
documentation objects</p>
</dd>
<dt>file</dt><dd><p>A <code>character</code> filename of the Rd file in the &quot;man&quot; directory</p>
</dd>
<dt>filepath</dt><dd><p>A <code>character</code> file path of the Rd file in the &quot;man&quot;
directory</p>
</dd>
<dt>alias</dt><dd><p><code>character</code> object names which are aliases for the
documentation in <code>filepath</code></p>
</dd>
<dt>is_exported</dt><dd><p>A <code>logical</code> indicator of whether the aliased object
is exported from the package namespace</p>
</dd>
<dt>doctype</dt><dd><p>A <code>character</code> representing the Rd docType field.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>package_source_dir &lt;- system.file("examplepkg", package = "covtracer")
Rd_df(package_source_dir)

</code></pre>

<hr>
<h2 id='srcref_expr'>Parse the expression associated with a srcref</h2><span id='topic+srcref_expr'></span>

<h3>Description</h3>

<p>Parse the expression associated with a srcref
</p>


<h3>Usage</h3>

<pre><code class='language-R'>srcref_expr(ref)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="srcref_expr_+3A_ref">ref</code></td>
<td>
<p>a <code>srcref</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A parsed <code>srcref</code> object
</p>

<hr>
<h2 id='srcref_str'>Convert a srcref into a string</h2><span id='topic+srcref_str'></span>

<h3>Description</h3>

<p>Convert a srcref into a string
</p>


<h3>Usage</h3>

<pre><code class='language-R'>srcref_str(ref)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="srcref_str_+3A_ref">ref</code></td>
<td>
<p>a <code>srcref</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A string representing the <code>srcref</code>
</p>

<hr>
<h2 id='srcrefs'>Retrieve <code>srcref</code>s</h2><span id='topic+srcrefs'></span><span id='topic+srcrefs.default'></span><span id='topic+srcrefs.list'></span><span id='topic+srcrefs.namespace'></span><span id='topic+srcrefs.environment'></span><span id='topic+srcrefs.R6ClassGenerator'></span><span id='topic+srcrefs.standardGeneric'></span><span id='topic+srcrefs.nonstandardGenericFunction'></span><span id='topic+srcrefs.MethodDefinition'></span>

<h3>Description</h3>

<p>This function takes a code collection and returns a <code>list</code> of related
<code>srcref</code> objects with <code>list</code> names that associate the <code>srcref</code> with a name or
alias that could be used to find documentation. Code collections include
structures such as package namespaces, environments, function definitions,
methods tables or class generators - any object which enapsulates a single or
set of <code>srcref</code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>srcrefs(x, ...)

## Default S3 method:
srcrefs(x, ..., srcref_names = NULL, breadcrumbs = character())

## S3 method for class 'list'
srcrefs(x, ..., srcref_names = NULL, breadcrumbs = character())

## S3 method for class 'namespace'
srcrefs(x, ..., breadcrumbs = character())

## S3 method for class 'environment'
srcrefs(x, ..., breadcrumbs = character())

## S3 method for class 'R6ClassGenerator'
srcrefs(x, ..., srcref_names = NULL, breadcrumbs = character())

## S3 method for class 'standardGeneric'
srcrefs(x, ..., srcref_names = NULL)

## S3 method for class 'nonstandardGenericFunction'
srcrefs(x, ..., srcref_names = NULL)

## S3 method for class 'MethodDefinition'
srcrefs(x, ..., srcref_names = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="srcrefs_+3A_x">x</code></td>
<td>
<p>An object to source srcrefs from</p>
</td></tr>
<tr><td><code id="srcrefs_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to methods</p>
</td></tr>
<tr><td><code id="srcrefs_+3A_srcref_names">srcref_names</code></td>
<td>
<p>An optional field used to supercede any discovered object
names when choosing which names to provide in the returned list.</p>
</td></tr>
<tr><td><code id="srcrefs_+3A_breadcrumbs">breadcrumbs</code></td>
<td>
<p>Recursive methods are expected to propegate a vector of
&quot;breadcrumbs&quot; (a character vector of namespace names encountered while
traversing the namespace used as a memory of what we've seen already),
which is used for short-circuiting recursive environment traversal.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For most objects, this is a one-to-one mapping of exported object names to
their <code>srcref</code>, just like you would get using <code>getNamespace()</code>. However, for
classes and methods, this can be a one-to-many mapping of related
documentation to the multiple <code>srcref</code>s that are described there. This is the
case for S3 generics, S4 objects and R6 objects.
</p>
<p>Objects without any related <code>srcref</code>s, such as any datasets or objects
created at package build time will be omitted from the results.
</p>


<h3>Value</h3>

<p>A <code>list</code> of <code>srcref</code> objects. Often, has a length of 1, but can be
larger for things like environments, namespaces or generic methods. The
names of the list reflect the name of the Rd name or alias that could be
used to find information related to each <code>srcref</code>. Elements of the <code>list</code>
will have attribute <code>"namespace"</code> denoting the source environment namespace
if one can be determined for the srcref object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># examples use `with` to execute within namespace as function isn't exported
ns &lt;- getNamespace("covtracer")

# load and extract srcrefs for a package
with(ns, srcrefs(getNamespace("covtracer")))

# extract srcrefs for functions
with(ns, srcrefs(srcrefs))

</code></pre>

<hr>
<h2 id='test_description'>Parse a test description from the calling expression</h2><span id='topic+test_description'></span>

<h3>Description</h3>

<p>In the general case, a simple indicator of the source file and line number is
used as a test description. There are some special cases where more
descriptive information can be extracted:
</p>


<h3>Usage</h3>

<pre><code class='language-R'>test_description(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="test_description_+3A_x">x</code></td>
<td>
<p>a unit test call stack or expression.</p>
</td></tr>
</table>


<h3>Details</h3>


<dl>
<dt><code>testthat</code></dt><dd><p>If the test used <code><a href="testthat.html#topic+test_that">test_that</a></code>,
then the description (<code>desc</code> parameter) is extracted and evaluated if
need be to produce a descriptive string. Nested calls to
<code><a href="testthat.html#topic+test_that">test_that</a></code> currently return the outermost test
description, although this behavior is subject to change.
</p>
</dd>
</dl>



<h3>Value</h3>

<p>A string that describes the test. If possible, this will be a written
description of the test, but will fall back to the test call as a string in
cases where no written description can be determined.
</p>

<hr>
<h2 id='test_description_test_that'>Parse the test description from a <code>test_that</code> call</h2><span id='topic+test_description_test_that'></span>

<h3>Description</h3>

<p>Parse the test description from a <code>test_that</code> call
</p>


<h3>Usage</h3>

<pre><code class='language-R'>test_description_test_that(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="test_description_test_that_+3A_x">x</code></td>
<td>
<p>A test_that call object</p>
</td></tr>
<tr><td><code id="test_description_test_that_+3A_...">...</code></td>
<td>
<p>Additional arguments unused</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>character</code> description, parsed from a <code>test_that::test_that</code> call
</p>

<hr>
<h2 id='test_description_test_that_describe'>Parse the test description from a <code>describe</code> call</h2><span id='topic+test_description_test_that_describe'></span>

<h3>Description</h3>

<p>Parse the test description from a <code>describe</code> call
</p>


<h3>Usage</h3>

<pre><code class='language-R'>test_description_test_that_describe(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="test_description_test_that_describe_+3A_x">x</code></td>
<td>
<p>A <code>test_that::describe</code> call object</p>
</td></tr>
<tr><td><code id="test_description_test_that_describe_+3A_...">...</code></td>
<td>
<p>Additional arguments unused</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>character</code> description, parsed from a <code>test_that::describe</code> call
</p>

<hr>
<h2 id='test_description_test_that_describe_it'>Parse the test description from a <code>it</code> call</h2><span id='topic+test_description_test_that_describe_it'></span>

<h3>Description</h3>

<p>Parse the test description from a <code>it</code> call
</p>


<h3>Usage</h3>

<pre><code class='language-R'>test_description_test_that_describe_it(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="test_description_test_that_describe_it_+3A_x">x</code></td>
<td>
<p>A <code>test_that::it</code> call object</p>
</td></tr>
<tr><td><code id="test_description_test_that_describe_it_+3A_...">...</code></td>
<td>
<p>Additional arguments unused</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>character</code> description, parsed from a <code>test_that::it</code> call
</p>

<hr>
<h2 id='test_srcrefs'>Extract test srcref objects</h2><span id='topic+test_srcrefs'></span><span id='topic+test_srcrefs.coverage'></span>

<h3>Description</h3>

<p>Extract test srcref objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>test_srcrefs(x)

## S3 method for class 'coverage'
test_srcrefs(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="test_srcrefs_+3A_x">x</code></td>
<td>
<p>A <code><a href="covr.html#topic+package_coverage">package_coverage</a></code> coverage object, from which
the test <code>srcref</code>s are extracted.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list_of_srcref</code>
</p>


<h3>See Also</h3>

<p>as.data.frame.list_of_srcref
</p>
<p>Other srcrefs: 
<code><a href="#topic+pkg_srcrefs">pkg_srcrefs</a>()</code>,
<code><a href="#topic+trace_srcrefs">trace_srcrefs</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>options(covr.record_tests = TRUE)
pkg_path &lt;- system.file("examplepkg", package = "covtracer")
cov &lt;- covr::package_coverage(pkg_path)
test_srcrefs(cov)

</code></pre>

<hr>
<h2 id='test_srcrefs_df'>Create a data.frame of coverage test srcref objects</h2><span id='topic+test_srcrefs_df'></span>

<h3>Description</h3>

<p>Extract unit test <code>srcref</code>s from a
<code><a href="covr.html#topic+package_coverage">coverage</a></code> object. A test name will be
derived from the test source code, preferrably from a written annotation, but
otherwise falling back to using a code snippet. <code>srcrefs</code> are unique for
each expression executed within a testing suite.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>test_srcrefs_df(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="test_srcrefs_df_+3A_x">x</code></td>
<td>
<p>A <code><a href="covr.html#topic+package_coverage">package_coverage</a></code> coverage object, from which
the name of the package used is extracted.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code> of test <code>srcrefs</code> extracted from a
<code>coverage</code> object. Contains one record for each <code>srcref</code> with
variables:
</p>

<dl>
<dt>name</dt><dd>
<p>A <code>character</code> test description. For <code>testthat</code> tests, the
<code>desc</code> parameter will be used, otherwise a snippet of code will be
used for the test name
</p>
</dd>
<dt>srcref</dt><dd>
<p>A <code>srcref</code> object describing the location of the test
</p>
</dd>
<dt>test_type</dt><dd>
<p>A <code>character</code> indicating the structure of the test.  One of
<code>"testthat"</code>, <code>"call"</code> or <code>NULL</code>
</p>
</dd>
</dl>



<h3>See Also</h3>

<p>srcrefs test_trace_mapping
</p>
<p>Other srcrefs_df: 
<code><a href="#topic+pkg_srcrefs_df">pkg_srcrefs_df</a>()</code>,
<code><a href="#topic+trace_srcrefs_df">trace_srcrefs_df</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>options(covr.record_tests = TRUE)
pkg_path &lt;- system.file("examplepkg", package = "covtracer")
cov &lt;- covr::package_coverage(pkg_path)
test_srcrefs_df(cov)

</code></pre>

<hr>
<h2 id='test_trace_df'>Build a traceability matrix that links documented behaviors to unit tests</h2><span id='topic+test_trace_df'></span><span id='topic+test_trace_df.coverage'></span>

<h3>Description</h3>

<p>Intercept unit test coverage reports and process results to link evaluated
functions to the unit tests which trigger their evaluation. In doing so,
we can then link the associated function documentation of each object to
the tests that triggered their evaluation as a way of reusing existing
documentation to generate specifications.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>test_trace_df(x, ...)

## S3 method for class 'coverage'
test_trace_df(
  x,
  ...,
  pkg = as.package(attr(x, "package")$path),
  aggregate_by = sum
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="test_trace_df_+3A_x">x</code></td>
<td>
<p>A package object, name, source code path or coverage result to use
as the bases of tracing tests. Coverage results must have been produced
using <code>options(covr.record_tests = TRUE)</code>.</p>
</td></tr>
<tr><td><code id="test_trace_df_+3A_...">...</code></td>
<td>
<p>Additional arguments unused</p>
</td></tr>
<tr><td><code id="test_trace_df_+3A_pkg">pkg</code></td>
<td>
<p>A <code>package</code> object as produced by <code>as.package</code>, if a specific
package object is to be used for inspecting the package namespace.</p>
</td></tr>
<tr><td><code id="test_trace_df_+3A_aggregate_by">aggregate_by</code></td>
<td>
<p><code>NULL</code> or a function by which to aggregate recurring hits
<code>counts</code> and <code>direct</code> columns from a test to a trace. If <code>NULL</code>, no
aggregation will be applied. (Default <code>sum</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code> of tests and corresponding traces
</p>

<hr>
<h2 id='test_trace_mapping'>Create a data.frame mapping tests to coverage traces</h2><span id='topic+test_trace_mapping'></span>

<h3>Description</h3>

<p>Extract a matrix used to relate test code to the traces that each test
evaluates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>test_trace_mapping(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="test_trace_mapping_+3A_x">x</code></td>
<td>
<p>A <code>coverage</code> object produced with
<code>options(covr.record_tests = TRUE)</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code> with one record for each line of code executed, with
variables:
</p>

<dl>
<dt>test</dt><dd><p>The index of the test that was executed, reflecting the order
in which tests are executed</p>
</dd>
<dt>depth</dt><dd><p>The call stack depth when the coverage trace was evaluated</p>
</dd>
<dt>i</dt><dd><p>The index of the expression evaluated by each test. This can be
used to recover an order of trace execution for a given test index</p>
</dd>
<dt>trace</dt><dd><p>The index of the coverage trace that was evaluated</p>
</dd>
</dl>



<h3>See Also</h3>

<p>srcrefs_df srcrefs
</p>


<h3>Examples</h3>

<pre><code class='language-R'>options(covr.record_tests = TRUE)
pkg_path &lt;- system.file("examplepkg", package = "covtracer")
cov &lt;- covr::package_coverage(pkg_path)
test_trace_mapping(cov)

</code></pre>

<hr>
<h2 id='trace_srcrefs'>Extract srcref objects from coverage object traces</h2><span id='topic+trace_srcrefs'></span><span id='topic+trace_srcrefs.coverage'></span>

<h3>Description</h3>

<p>Extract srcref objects from coverage object traces
</p>


<h3>Usage</h3>

<pre><code class='language-R'>trace_srcrefs(x)

## S3 method for class 'coverage'
trace_srcrefs(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="trace_srcrefs_+3A_x">x</code></td>
<td>
<p>(<code>link[covr]{package_coverage}</code>) A <code><a href="covr.html#topic+covr">covr</a></code>
coverage object produced with <code>options(covr.record_tests = TRUE)</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list_of_srcref</code>
</p>


<h3>See Also</h3>

<p>as.data.frame.list_of_srcref
</p>
<p>Other srcrefs: 
<code><a href="#topic+pkg_srcrefs">pkg_srcrefs</a>()</code>,
<code><a href="#topic+test_srcrefs">test_srcrefs</a>()</code>
</p>

<hr>
<h2 id='trace_srcrefs_df'>Create a data.frame of coverage trace srcref objects</h2><span id='topic+trace_srcrefs_df'></span>

<h3>Description</h3>

<p>Extract <code><a href="covr.html#topic+package_coverage">coverage</a></code> traces. Traces are the
traced lines of code counted when evaluating code coverage, which are used
for counting expression evaluation. Each traced is a unique expression within
a package's source code.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>trace_srcrefs_df(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="trace_srcrefs_df_+3A_x">x</code></td>
<td>
<p>A <code><a href="covr.html#topic+package_coverage">package_coverage</a></code> coverage object, from which
the name of the package used is extracted.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code>, where each record it a trace <code>srcref</code> with
variables:
</p>

<dl>
<dt>name</dt><dd><p>A <code>character</code> identifier. This will use the names of the
elements of a <code><a href="covr.html#topic+package_coverage">coverage</a></code> object,
which are <code>srcref</code> &quot;keys&quot;.</p>
</dd>
<dt>srcref</dt><dd><p>A <code>srcref</code> object of the trace source code location</p>
</dd>
</dl>



<h3>See Also</h3>

<p>srcrefs test_trace_mapping
</p>
<p>Other srcrefs_df: 
<code><a href="#topic+pkg_srcrefs_df">pkg_srcrefs_df</a>()</code>,
<code><a href="#topic+test_srcrefs_df">test_srcrefs_df</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>options(covr.record_tests = TRUE)
pkg_path &lt;- system.file("examplepkg", package = "covtracer")
cov &lt;- covr::package_coverage(pkg_path)
trace_srcrefs_df(cov)

</code></pre>

<hr>
<h2 id='with_pseudo_srcref'>For consistency, stub calls with srcref-like attributes</h2><span id='topic+with_pseudo_srcref'></span>

<h3>Description</h3>

<p>Most relevant data can be traced to an existing srcref. However, some data,
such as test traces from coverage objects, are likely cleaned up and their
srcfiles deleted, causing a barrage of warnings any time these objects are
printed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>with_pseudo_srcref(call, file, lloc)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="with_pseudo_srcref_+3A_call">call</code></td>
<td>
<p>Any code object, most often a <code>call</code> object</p>
</td></tr>
<tr><td><code id="with_pseudo_srcref_+3A_file">file</code></td>
<td>
<p>A filepath to bind as a <code>srcfile</code> object</p>
</td></tr>
<tr><td><code id="with_pseudo_srcref_+3A_lloc">lloc</code></td>
<td>
<p>A <code>srcef</code>-like <code>lloc</code> numeric vector</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A <code>pseudo_srcref</code> adds in the <code>srcref</code> data but continues to preserve the
expression content. This allows these expression objects to be pretty-printed
like <code>srcref</code>s when included as a <code>list_of_srcref</code> <code>data.frame</code> column.
</p>


<h3>Value</h3>

<p>A <code>with_pseudo_srcref</code> object, mimicking the structure of <code>srcref</code>
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
