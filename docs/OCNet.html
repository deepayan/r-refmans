<!DOCTYPE html><html><head><title>Help for package OCNet</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {OCNet}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#OCNet-package'><p>Create and analyze Optimal Channel Networks.</p></a></li>
<li><a href='#aggregate_OCN'><p>Aggregate an Optimal Channel Network</p></a></li>
<li><a href='#continue_OCN'><p>Perform OCN Search Algorithm on an Existing OCN</p></a></li>
<li><a href='#create_general_contour_OCN'><p>Create an Optimal Channel Network on a general contour</p></a></li>
<li><a href='#create_OCN'><p>Create an Optimal Channel Network</p></a></li>
<li><a href='#create_peano'><p>Create Peano network</p></a></li>
<li><a href='#draw_contour_OCN'><p>Draw Optimal Channel Network with catchment contours</p></a></li>
<li><a href='#draw_elev2D_OCN'><p>Plot 2D map of elevation generated by an OCN</p></a></li>
<li><a href='#draw_elev3D_OCN'><p>Plot 3D map of elevation generated by an OCN</p></a></li>
<li><a href='#draw_elev3Drgl_OCN'><p>Plot 3D map of elevation generated by an OCN via rgl rendering</p></a></li>
<li><a href='#draw_simple_OCN'><p>Draw an Optimal Channel Network</p></a></li>
<li><a href='#draw_subcatchments_OCN'><p>Draw subcatchment map from an Optimal Channel Network</p></a></li>
<li><a href='#draw_thematic_OCN'><p>Draw thematic map on an Optimal Channel Network</p></a></li>
<li><a href='#find_area_threshold_OCN'><p>Find relationship between number of nodes and threshold area in an OCN</p></a></li>
<li><a href='#flowDir'><p>Example of initial flow direction matrix to be used as input in <code>create_general_contour_OCN</code>.</p></a></li>
<li><a href='#landscape_OCN'><p>Generate 3D landscape from an Optimal Channel Network</p></a></li>
<li><a href='#OCN_20'><p>Example of small OCN</p></a></li>
<li><a href='#OCN_250_PB'><p>Example of single-outlet OCN with periodic boundaries</p></a></li>
<li><a href='#OCN_250_T'><p>Example of single-outlet OCN</p></a></li>
<li><a href='#OCN_300_4out'><p>Example of multiple-outlet OCN</p></a></li>
<li><a href='#OCN_300_4out_PB_hot'><p>Example of multiple-outlet OCN with periodic boundaries</p></a></li>
<li><a href='#OCN_4'><p>Example of small OCN</p></a></li>
<li><a href='#OCN_400_Allout'><p>Example of OCN with all perimetric pixels as outlets</p></a></li>
<li><a href='#OCN_to_AEM'><p>Construct asymmetric eigenvector maps (AEM) from an OCN</p></a></li>
<li><a href='#OCN_to_igraph'><p>Transform OCN into igraph object</p></a></li>
<li><a href='#OCN_to_SSN'><p>Transform OCN into SSN object (disabled)</p></a></li>
<li><a href='#paths_OCN'><p>Calculate paths between nodes in an Optimal Channel Network</p></a></li>
<li><a href='#plot'><p>Plot a river</p></a></li>
<li><a href='#river-class'><p>river class</p></a></li>
<li><a href='#rivergeometry_OCN'><p>River geometry of an Optimal Channel Network</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Optimal Channel Networks</td>
</tr>
<tr>
<td>Version:</td>
<td>1.2.1</td>
</tr>
<tr>
<td>Description:</td>
<td>Generate and analyze Optimal Channel Networks (OCNs): 
	oriented spanning trees reproducing all scaling features characteristic 
	of real, natural river networks. As such, they can be used in a variety 
	of numerical experiments in the fields of hydrology, ecology and 
	epidemiology. See Carraro et al. (2020) &lt;<a href="https://doi.org/10.1002%2Fece3.6479">doi:10.1002/ece3.6479</a>&gt; 
	for a presentation of the package; Rinaldo et al. (2014) 
	&lt;<a href="https://doi.org/10.1073%2Fpnas.1322700111">doi:10.1073/pnas.1322700111</a>&gt; for a theoretical overview on the OCN 
	concept; Furrer and Sain (2010) &lt;<a href="https://doi.org/10.18637%2Fjss.v036.i10">doi:10.18637/jss.v036.i10</a>&gt; for the 
	construct used.</td>
</tr>
<tr>
<td>Imports:</td>
<td>fields, spam, rgl, methods, igraph, Rcpp (&ge; 1.0.10),
adespatial, spdep, terra</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.6)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, bookdown</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://lucarraro.github.io/OCNet/">https://lucarraro.github.io/OCNet/</a></td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-11-23 14:54:54 UTC; lucac</td>
</tr>
<tr>
<td>Author:</td>
<td>Luca Carraro [aut, cre],
  Florian Altermatt [ctb],
  Emanuel A. Fronhofer [ctb],
  Reinhard Furrer [ctb],
  Isabelle Gounand [ctb],
  Andrea Rinaldo [ctb],
  Enrico Bertuzzo [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Luca Carraro &lt;luca.carraro@hotmail.it&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-11-23 17:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='OCNet-package'>Create and analyze Optimal Channel Networks.</h2><span id='topic+OCNet-package'></span><span id='topic+OCNet'></span>

<h3>Description</h3>

<p>A package that allows the generation and analysis of synthetic river network analogues, called Optimal Channel Networks (OCNs).
</p>


<h3>References</h3>

<p>Rinaldo, A., Rigon, R., Banavar, J. R., Maritan, A., &amp; Rodriguez-Iturbe, I. (2014). Evolution and selection of river networks: Statics, dynamics, and complexity. Proceedings of the National Academy of Sciences of the United States of America, 111(7), 2417-2424. doi:10.1073/pnas.1322700111
</p>
<p>Carraro, L., Bertuzzo, E., Fronhofer, E. A., Furrer, R., Gounand, I., Rinaldo, A., &amp; Altermatt, F. (2020). Generation and application of river network analogues for use in ecology and evolution. Ecology and Evolution, 10(14), 7537-7550. doi:10.1002/ece3.6479
</p>
<p>Carraro, L., &amp; Altermatt, F. (2022). Optimal channel networks accurately model ecologically-relevant geomorphological features of branching river networks. Communications Earth and Environment, 3(1) doi:10.1038/s43247-022-00454-1
</p>


<h3>Author(s)</h3>

<p>Luca Carraro (<a href="mailto:luca.carraro@hotmail.it">luca.carraro@hotmail.it</a>), Florian Altermatt, Emanuel A. Fronhofer, Reinhard Furrer, Isabelle Gounand, Andrea Rinaldo, Enrico Bertuzzo
</p>


<h3>See Also</h3>

<p><a href="../doc/OCNet.html"><code>vignette("OCNet")</code></a>
</p>

<hr>
<h2 id='aggregate_OCN'>Aggregate an Optimal Channel Network</h2><span id='topic+aggregate_OCN'></span>

<h3>Description</h3>

<p>Function that, given an OCN, builds the network at the river network (RN), aggregated (AG), subcatchment (SC), and catchment (CM) levels.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>aggregate_OCN(OCN, thrA = 0.002 * OCN$FD$nNodes *
  OCN$cellsize^2, streamOrderType = "Strahler", maxReachLength = Inf,
  equalizeLengths = FALSE, breakpoints = NULL, displayUpdates = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="aggregate_OCN_+3A_ocn">OCN</code></td>
<td>
<p>A <code>river</code> object as produced by <code><a href="#topic+landscape_OCN">landscape_OCN</a></code>.</p>
</td></tr>
<tr><td><code id="aggregate_OCN_+3A_thra">thrA</code></td>
<td>
<p>Threshold value on drainage area used to derive the aggregated network. If <code>thrA = 0</code>, no aggregation is performed: 
every FD node is also a node at the RN and AG levels. In this case, the function <code>aggregate_OCN</code> can still be used to compute statistics 
such as <code>OCN$AG$streamOrder</code>.</p>
</td></tr>
<tr><td><code id="aggregate_OCN_+3A_streamordertype">streamOrderType</code></td>
<td>
<p>If <code>"Strahler"</code>, Strahler stream order is computed; if <code>"Shreve"</code>, Shreve stream order is computed.</p>
</td></tr>
<tr><td><code id="aggregate_OCN_+3A_maxreachlength">maxReachLength</code></td>
<td>
<p>Maximum reach length allowed (in planar units). If the path length between a channel head and the downstream confluence 
is higher than <code>maxReachLength</code>, the reach starting from the channel head will have a length up to <code>maxReachLength</code>, while the next downstream 
pixel is considered as a new channel head, from which a new reach departs. Values lower than <code>OCN$cellsize*sqrt(2)</code> are not allowed. If 
<code>maxReachLength &lt; 2*OCN$cellsize</code>, every RN node is also an AG node.</p>
</td></tr>
<tr><td><code id="aggregate_OCN_+3A_equalizelengths">equalizeLengths</code></td>
<td>
<p>Logical. Only effective when <code>maxReachLength &lt; Inf</code>. If <code>TRUE</code>, reaches longer than <code>maxReachLength</code> are 
split in portions of similar length. If <code>FALSE</code> (default), a split is made whenever adding one more pixel to a reach would violate the <code>maxReachLength</code>
constrain, which could result in the creation of very short reaches. Note that setting <code>equalizeLengths = TRUE</code> might increase the number of AG nodes 
with respect to the default case (see example 2).</p>
</td></tr>
<tr><td><code id="aggregate_OCN_+3A_breakpoints">breakpoints</code></td>
<td>
<p>Indices of additional nodes at the RN level that should be also nodes at the AG level (beyond source, confluence, outlet nodes 
and AG nodes determined via <code>maxReachLength</code>). To determine such indices, a preliminary run of <code>aggregate_OCN</code> with the same <code>thrA</code> 
would be required (see example 3).</p>
</td></tr>
<tr><td><code id="aggregate_OCN_+3A_displayupdates">displayUpdates</code></td>
<td>
<p>Logical. State if updates are printed on the console while <code>aggregate_OCN</code> runs.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that each node (and the corresponding edge exiting from it, in the case of non-outlet nodes) at the AG level corresponds to 
a subcatchment at the SC level that shares the same index: for instance, <code>SC$toFD[i]</code> contains all elements of 
<code>AG$toFD[i]</code> (that is, the indices of pixels at FD level that constitute the edge departing from node <code>i</code> 
are also part of subcatchment <code>i</code>).
</p>


<h3>Value</h3>

<p>A <code>river</code> object that contains all objects contained in <code>OCN</code>, in addition to the objects listed below. 
New sublists <code>RN</code>, <code>AG</code>, <code>SC</code>, containing variables at the corresponding aggregation levels, are created.
Refer to section 4.2 of the <a href="../doc/OCNet.html">vignette</a> for a more detailed explanation on values <code>OCN$XX$toYY</code>, where <code>XX</code> and <code>YY</code> are two random aggregation levels.
</p>
<table>
<tr><td><code>FD$toRN</code></td>
<td>
<p>Vector (of length <code>OCN$FD$nNodes</code>) whose values are equal to 0 if the FD node is not a node at the RN level. 
If <code>FD$toRN[i] != 0</code>, then <code>FD$toRN[i]</code> is the index at the RN level of the node whose index at the FD level is <code>i</code>. Thereby, 
<code>FD$toRN[i] = j</code> implies <code>RN$toFD[j] = i</code>.</p>
</td></tr>
<tr><td><code>FD$toSC</code></td>
<td>
<p>Vector (of length <code>OCN$FD$nNodes</code>) of SC indices for all nodes at the FD level. 
If <code>OCN$FD$toSC[i] = j</code>, then <code>i %in% OCN$SC$toFD[[j]] = TRUE</code>.</p>
</td></tr>
<tr><td><code>RN$A</code></td>
<td>
<p>Vector (of length <code>RN$nNodes</code>) containing drainage area values for all RN nodes (in square planar units).</p>
</td></tr>
<tr><td><code>RN$W</code></td>
<td>
<p>Adjacency matrix (<code>RN$nNodes</code> by <code>RN$nNodes</code>) at the RN level. It is a <code><a href="spam.html#topic+spam">spam</a></code> 
object.</p>
</td></tr>
<tr><td><code>RN$downNode</code></td>
<td>
<p>Vector (of length <code>RN$nNodes</code>) representing the adjacency matrix at RN level in a vector form: 
if <code>RN$downNode[i] = j</code> then <code>RN$W[i,j] = 1</code>. If <code>o</code> is the outlet node, then <code>RN$downNode[o] = 0</code>.</p>
</td></tr>
<tr><td><code>RN$drainageDensity</code></td>
<td>
<p>Drainage density of the river network, calculated as total length of the river network divided by area of the lattice. It is expressed in planar units^(-1).</p>
</td></tr> 
<tr><td><code>RN$leng</code></td>
<td>
<p>Vector (of length <code>RN$nNodes</code>) of lengths of edges departing from nodes at the RN level. Its values are equal to either <code>0</code> (if the corresponding
node is an outlet), <code>OCN$cellsize</code> (if the corresponding flow direction is horizontal/vertical), or <code>sqrt(2)*OCN$cellsize</code> (diagonal flow).</p>
</td></tr>
<tr><td><code>RN$nNodes</code></td>
<td>
<p>Number of nodes at the RN level.</p>
</td></tr>
<tr><td><code>RN$nUpstream</code></td>
<td>
<p>Vector (of length <code>RN$nNodes</code>) providing the number of nodes upstream of each node (the node itself is included).</p>
</td></tr>
<tr><td><code>RN$outlet</code></td>
<td>
<p>Vector (of length <code>OCN$FD$nOutlet</code>) indices of nodes at RN level corresponding to outlets.</p>
</td></tr>
<tr><td><code>RN$Slope</code></td>
<td>
<p>Vector (of length <code>RN$nNodes</code>) of pixel slopes at RN level.</p>
</td></tr>
<tr><td><code>RN$toAG</code></td>
<td>
<p>Vector (of length <code>RN$nNodes</code>) whose values are equal to 0 if the RN node is not a node at the AG level. 
If <code>RN$toAG[i] != 0</code>, then <code>RN$toAG[i]</code> is the index at the AG level of the node whose index at the RN level is <code>i</code>. Thereby, 
<code>RN$toAG[i] = j</code> implies <code>AG$toRN[j] = i</code>.</p>
</td></tr>
<tr><td><code>RN$toAGReach</code></td>
<td>
<p>Vector (of length <code>RN$nNodes</code>) identifying to which edge (reach) the RN nodes belong. If <code>RN$toAGReach[i] = j</code>, 
the RN node <code>i</code> belongs to the edge departing from from the AG node <code>j</code> (which implies that it may correspond to the AG node <code>j</code> itself.)</p>
</td></tr>
<tr><td><code>RN$toFD</code></td>
<td>
<p>Vector (of length <code>RN$nNodes</code>) with indices at FD level of nodes belonging to RN level. <code>RN$toFD[i] = j</code> implies <code>OCN$FD$toRN[j] = i</code>.</p>
</td></tr>
<tr><td><code>RN$toCM</code></td>
<td>
<p>Vector (of length <code>RN$nNodes</code>) with catchment index values for each RN node. Example: <code>RN$toCM[i] = j</code> if node
<code>i</code> drains into the outlet whose location is defined by <code>outletSide[j]</code>, <code>outletPos[j]</code>.</p>
</td></tr>
<tr><td><code>RN$upstream</code></td>
<td>
<p>List (of length <code>RN$nNodes</code>) whose object <code>i</code> is a vector (of length <code>RN$nUpstream[i]</code>) containing 
the indices of nodes upstream of a node <code>i</code> (including <code>i</code>).</p>
</td></tr>
<tr><td><code>RN$X</code>, <code>RN$Y</code></td>
<td>
<p>Vectors (of length <code>RN$nNodes</code>) of X, Y coordinates of nodes at RN level.</p>
</td></tr>
<tr><td><code>RN$Z</code></td>
<td>
<p>Vector (of length <code>RN$nNodes</code>) of Z coordinates of nodes at RN level.</p>
</td></tr>
<tr><td><code>AG$A</code></td>
<td>
<p>Vector (of length <code>AG$nNodes</code>) containing drainage area values for all nodes at AG level. 
If <code>i</code> is a channel head, then <code>AG$A[RN$toAG[i]] = RN$A[i]</code>.</p>
</td></tr> 
<tr><td><code>AG$AReach</code></td>
<td>
<p>Vector (of length <code>AG$nNodes</code>) containing drainage area values computed by accounting for the areas drained by edges departing from AG nodes. 
In other words, <code>AG$AReach[i]</code> is equal to the drainage area of the last downstream node belonging to the reach that departs from <code>i</code> 
(namely <code>AG$AReach[i] = max(RN$A[RN$toAG == i])</code>).</p>
</td></tr>
<tr><td><code>AG$W</code></td>
<td>
<p>Adjacency matrix (<code>AG$nNodes</code> by <code>AG$nNodes</code>) at the AG level. It is a <code><a href="spam.html#topic+spam">spam</a></code> object.</p>
</td></tr>
<tr><td><code>AG$downNode</code></td>
<td>
<p>Vector (of length <code>AG$nNodes</code>) representing the adjacency matrix at AG level in a vector form: 
if <code>AG$downNode[i] = j</code> then <code>AG$W[i,j] = 1</code>. If <code>o</code> is the outlet node, then <code>AG$downNode[o] = 0</code>.</p>
</td></tr>
<tr><td><code>AG$leng</code></td>
<td>
<p>Vector (of length <code>AG$nNodes</code>) of lengths of edges departing from nodes at AG level. Note that <code>AG$leng[i] = sum(RN$leng[RN$toAG == i])</code>.
If <code>o</code> is an outlet node (i.e. (<code>o %in% AG$outlet) = TRUE</code>), then <code>AG$leng[i] = 0</code>.</p>
</td></tr>
<tr><td><code>AG$nNodes</code></td>
<td>
<p>Number of nodes resulting from the aggregation process.</p>
</td></tr>
<tr><td><code>AG$nUpstream</code></td>
<td>
<p>Vector (of length <code>AG$nNodes</code>) providing the number of nodes (at the AG level) upstream of each node (the node itself is included).</p>
</td></tr>
<tr><td><code>AG$outlet</code></td>
<td>
<p>Vector (of length <code>OCN$FD$nOutlet</code>) with indices of outlet nodes, i.e. nodes whose <code>AG$downNode</code> value is 0.</p>
</td></tr> 
<tr><td><code>AG$slope</code></td>
<td>
<p>Vector (of length <code>AG$nNodes</code>) of slopes at AG level. It represents the (weighted) average slope of edges departing from nodes. 
If <code>i</code> is an outlet node (i.e. (<code>i %in% AG$outlet) = TRUE</code>), then <code>AG$slope[i] = NaN</code>.</p>
</td></tr>
<tr><td><code>AG$streamOrder</code></td>
<td>
<p>Vector (of length <code>AG$nNodes</code>) of stream order values for each node. If <code>streamOrderType = "Strahler"</code>, 
Strahler stream order is computed. If <code>streamOrderType = "Shreve"</code>, Shreve stream order is computed.</p>
</td></tr>
<tr><td><code>AG$upstream</code></td>
<td>
<p>List (of length <code>AG$nNodes</code>) whose object <code>i</code> is a vector (of length <code>AG$nUpstream[i]</code>) containing 
the indices of nodes (at the AG level) upstream of a node <code>i</code> (including <code>i</code>).</p>
</td></tr>
<tr><td><code>AG$toFD</code></td>
<td>
<p>Vector of length <code>AG$nNodes</code>) with with indices at FD level of nodes belonging to AG level. <code>AG$toFD[i] = j</code> implies <code>OCN$FD$toAG[j] = i</code>. </p>
</td></tr>
<tr><td><code>AG$ReachToFD</code></td>
<td>
<p>List (of length <code>AG$nNodes</code>) whose object <code>i</code> is a vector of indices of FD nodes constituting the edge 
departing from node <code>i</code>.</p>
</td></tr>
<tr><td><code>AG$toRN</code></td>
<td>
<p>Vector of length <code>AG$nNodes</code>) with with indices at RN level of nodes belonging to AG level. <code>AG$toRN[i] = j</code> implies <code>OCN$FD$toRN[j] = i</code>. </p>
</td></tr>
<tr><td><code>AG$ReachToRN</code></td>
<td>
<p>List (of length <code>AG$nNodes</code>) whose object <code>i</code> is a vector of indices of RN nodes constituting the edge 
departing from node <code>i</code>.</p>
</td></tr>
<tr><td><code>AG$toCM</code></td>
<td>
<p>Vector (of length <code>AG$nNodes</code>) with catchment index values for each AG node. Example: <code>AG$toCM[i] = j</code> if node
<code>i</code> drains into the outlet whose location is defined by <code>outletSide[j]</code>, <code>outletPos[j]</code>.</p>
</td></tr>
<tr><td><code>AG$X</code>, <code>AG$Y</code></td>
<td>
<p>Vectors (of length <code>AG$nNodes</code>) of X, Y coordinates (in planar units) of nodes at the AG level. 
These correspond to the X, Y coordinates of the nodes constituting the upstream tips of the reaches. 
If <code>i</code> and <code>j</code> are such that <code>AG$X[i] == RN$X[j]</code> and <code>AG$Y[i] == RN$Y[j]</code>, then <code>AG$A[i] = RN$A[j]</code>.</p>
</td></tr>
<tr><td><code>AG$XReach</code>, <code>AG$YReach</code></td>
<td>
<p>Vector (of length <code>AG$nNodes</code>) of X, Y coordinates (in planar units) of the downstream tips of the reaches. 
If <code>i</code> and <code>j</code> are such that <code>AG$XReach[i] == RN$X[j]</code> and <code>AG$YReach[i] == RN$Y[j]</code>, then <code>AG$AReach[i] = RN$A[j]</code>. 
If <code>o</code> is an outlet node, then <code>AG$XReach = NaN</code>, <code>AG$YReach = NaN</code>.</p>
</td></tr>
<tr><td><code>AG$Z</code></td>
<td>
<p>Vector (of length <code>AG$nNodes</code>) of elevation values (in elevational units) of nodes at the AG level. 
These correspond to the elevations of the nodes constituting the upstream tips of the reaches.</p>
</td></tr>
<tr><td><code>AG$ZReach</code></td>
<td>
<p>Vector (of length <code>AG$nNodes</code>) of Z coordinates (in elevational units) of the downstream tips of the reaches.
If <code>o</code> is an outlet node, then <code>AG$ZReach = NaN</code>.</p>
</td></tr>
<tr><td><code>SC$ALocal</code></td>
<td>
<p>Vector (of length <code>SC$nNodes</code>) with values of subcatchment area, that is the number of FD pixels 
(multiplied by <code>OCN$FD$cellsize^2</code>) that constitutes a subcatchment. If <code>o</code> is an outlet node, then <code>ALocal[o] = 0</code>.</p>
</td></tr>
<tr><td><code>SC$W</code></td>
<td>
<p>Adjacency matrix (<code>SC$nNodes</code> by <code>SC$nNodes</code>) at the subcatchment level. Two subcatchments are connected if they share a border. 
Note that this is not a flow connection. Unlike the adjacency matrices at levels FD, RN, AG, this matrix is symmetric. It is a <code><a href="spam.html#topic+spam">spam</a></code> object.
If <code>o</code> is an outlet node, then <code>SC$W[o,]</code> and <code>SC$W[,o]</code> only contain zeros (i.e., <code>o</code> is unconnected to the other nodes).</p>
</td></tr>
<tr><td><code>SC$nNodes</code></td>
<td>
<p>Number of subcatchments into which the lattice is partitioned. If <code>nOutlet = 1</code>, then <code>SC$nNodes = AG$nNodes</code>. 
If multiple outlets are present, <code>SC$nNodes</code> might be greater than <code>AG$nNodes</code> in the case when some catchments have drainage area lower than <code>thrA</code>. 
In this case, the indices from <code>AG$nNodes + 1</code> to <code>SC$nNodes</code> identify subcatchment that do not have a corresponding AG node.</p>
</td></tr>
<tr><td><code>SC$toFD</code></td>
<td>
<p>List (of length <code>SC$nNodes</code>) whose object <code>i</code> is a vector of indices of FD pixels constituting the subcatchment <code>i</code>.</p>
</td></tr>
<tr><td><code>SC$X</code>, <code>SC$Y</code></td>
<td>
<p>Vectors (of length <code>SC$nNodes</code>) of X, Y coordinates (in planar units) of subcatchment centroids.</p>
</td></tr>
<tr><td><code>SC$Z</code></td>
<td>
<p>Vector (of length <code>SC$nNodes</code>) of average subcatchment elevation (in elevational units).</p>
</td></tr>
</table>
<p>Finally, <code>thrA</code> is added to the <code>river</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># 1a) aggregate a 20x20 OCN by imposing thrA = 4. 
OCN &lt;- aggregate_OCN(landscape_OCN(OCN_20), thrA = 4)
draw_thematic_OCN(OCN, drawNodes = TRUE)


# 1b) same as above, but identify all RN nodes as AG nodes
mrl &lt;- 1.5*OCN_20$cellsize
OCN2 &lt;- aggregate_OCN(landscape_OCN(OCN_20), thrA = 4, maxReachLength = mrl)
draw_thematic_OCN(OCN2, drawNodes = TRUE)



# 2) explore the effects of thrA, maxReachLength and equalizeLengths on a large OCN
OCN &lt;- landscape_OCN(OCN_250_T) # it takes some seconds
OCN_a &lt;- aggregate_OCN(OCN, thrA = 200) # it takes some seconds
OCN_b &lt;- aggregate_OCN(OCN, thrA = 1000) # it takes some seconds
OCN_c &lt;- aggregate_OCN(OCN, thrA = 1000, maxReachLength = 20) # it takes some seconds
OCN_d &lt;- aggregate_OCN(OCN, thrA = 1000, maxReachLength = 20, 
equalizeLengths = TRUE) # it takes some seconds

old.par &lt;- par(no.readonly = TRUE)
par(mfrow = c(2,2))
draw_subcatchments_OCN(OCN_a)
points(OCN_a$AG$X, OCN_a$AG$Y, pch = 19, col = "#0044bb") 
title(paste("No. AG nodes = ", as.character(OCN_a$AG$nNodes),
		sep=""))
draw_subcatchments_OCN(OCN_b)
points(OCN_b$AG$X, OCN_b$AG$Y, pch = 19, col = "#0044bb") 
title(paste("No. AG nodes = ", as.character(OCN_b$AG$nNodes),
		sep=""))
draw_subcatchments_OCN(OCN_c)
points(OCN_c$AG$X, OCN_c$AG$Y, pch = 19, col = "#0044bb") 
title(paste("No. AG nodes = ", as.character(OCN_c$AG$nNodes),
		sep=""))
		draw_subcatchments_OCN(OCN_d)
points(OCN_d$AG$X, OCN_d$AG$Y, pch = 19, col = "#0044bb") 
title(paste("No. AG nodes = ", as.character(OCN_d$AG$nNodes),
		sep=""))
par(old.par)
# note the difference between OCN_c and OCN_d at the bottom right corner of the lattice


# 3) use of breakpoints
OCN &lt;- aggregate_OCN(landscape_OCN(OCN_20), thrA = 5)
draw_thematic_OCN(OCN, drawNodes=TRUE)
# add an AG node downstream of node 1 at AG level
new_node_RN &lt;- OCN$RN$downNode[OCN$AG$toRN[1]]
OCN2 &lt;- aggregate_OCN(landscape_OCN(OCN_20), thrA = 5, breakpoints = new_node_RN)
draw_thematic_OCN(OCN2, drawNodes = TRUE)
points(OCN$RN$X[new_node_RN], OCN$RN$Y[new_node_RN], 
	pch = 19, col = "red") # this node has been added
</code></pre>

<hr>
<h2 id='continue_OCN'>Perform OCN Search Algorithm on an Existing OCN</h2><span id='topic+continue_OCN'></span>

<h3>Description</h3>

<p>Function that performs the OCN search algorithm on an existing OCN.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>continue_OCN(OCN,nNewIter, coolingRate=NULL, initialNoCoolingPhase=0,
 displayUpdates=1, showIntermediatePlots=FALSE, thrADraw=NULL,
 easyDraw=NULL, nUpdates=50)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="continue_OCN_+3A_ocn">OCN</code></td>
<td>
<p>A <code>river</code> object (as generated by <code><a href="#topic+create_OCN">create_OCN</a></code>).</p>
</td></tr>
<tr><td><code id="continue_OCN_+3A_nnewiter">nNewIter</code></td>
<td>
<p>Number of iterations that the OCN search algorithm performs.</p>
</td></tr>
<tr><td><code id="continue_OCN_+3A_coolingrate">coolingRate</code></td>
<td>
<p>Parameter of the function used to describe the temperature of the simulated annealing algorithm. See <code><a href="#topic+create_OCN">create_OCN</a></code>. If <code>NULL</code>, it is set equal to the last element of <code>OCN$coolingRate</code>.</p>
</td></tr>
<tr><td><code id="continue_OCN_+3A_initialnocoolingphase">initialNoCoolingPhase</code></td>
<td>
<p>Parameter of the function used to describe the temperature of the simulated annealing algorithm. See <code><a href="#topic+create_OCN">create_OCN</a></code>.</p>
</td></tr>
<tr><td><code id="continue_OCN_+3A_nupdates">nUpdates</code></td>
<td>
<p>Number of updates given during the OCN search process (only effective if <code>any(displayUpdates,showIntermediatePlots)=TRUE</code>.).</p>
</td></tr>
<tr><td><code id="continue_OCN_+3A_showintermediateplots">showIntermediatePlots</code></td>
<td>
<p>If <code>TRUE</code>, the OCN plot is updated <code>nUpdates</code> times during the OCN search process.
Note that, for large lattices, <code>showIntermediatePlots = TRUE</code> might slow down the search process considerably (especially when <code>easyDraw = FALSE</code>).</p>
</td></tr>
<tr><td><code id="continue_OCN_+3A_thradraw">thrADraw</code></td>
<td>
<p>Threshold drainage area value used to display the network (only effective when <code>showIntermediatePlots = TRUE</code>).</p>
</td></tr>
<tr><td><code id="continue_OCN_+3A_easydraw">easyDraw</code></td>
<td>
<p>Logical. If <code>TRUE</code>, the whole network is displayed (when <code>showIntermediatePlots = TRUE</code>), and pixels with drainage area lower than <code>thrADraw</code> are displayed in light gray. If <code>FALSE</code>, only pixels with drainage area greater or equal to <code>thrADraw</code> are displayed. Default is <code>FALSE</code> if <code>dimX*dimY &lt;= 40000</code>, and <code>TRUE</code> otherwise. Note that setting <code>easyDraw = FALSE</code> for large networks might slow down the process considerably.</p>
</td></tr>
<tr><td><code id="continue_OCN_+3A_displayupdates">displayUpdates</code></td>
<td>
<p>State if updates are printed on the console while the OCN search algorithm runs.
</p>

<dl>
<dt><code>0</code></dt><dd><p>No update is given.</p>
</dd>
<dt><code>1</code></dt><dd><p>An estimate of duration is given (only if <code>dimX*dimY &gt; 1000</code>, otherwise no update is given).</p>
</dd>
<dt><code>2</code></dt><dd><p>Progress updates are given. The number of these is controlled by <code>nUpdates</code></p>
</dd>
</dl>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>river</code> object analogous to the input <code>OCN</code>. Note that, unlike in <code><a href="#topic+create_OCN">create_OCN</a></code>, <code>OCN$coolingRate</code> and <code>OCN$initialNoCoolingPhase</code> are now vectors (of length equal to the number of times <code><a href="#topic+continue_OCN">continue_OCN</a></code> has been performed on the same OCN, plus one) that store the full sequence of <code>coolingRate</code>, <code>initialNoCoolingPhase</code> used to generate the OCN. Additionally, the vector <code>OCN$nIterSequence</code> is provided, with entries equal to the number of iterations performed by each successive application of <code><a href="#topic+create_OCN">create_OCN</a></code> or <code><a href="#topic+continue_OCN">continue_OCN</a></code>. It is <code>OCN$nIter = sum(OCN$nIterSequence)</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
OCN_a &lt;- create_OCN(20, 20, nIter = 10000)
set.seed(1)
OCN_b &lt;- create_OCN(20, 20, nIter = 5000)
OCN_b &lt;- continue_OCN(OCN_b, nNewIter = 5000)

old.par &lt;- par(no.readonly = TRUE)
par(mfrow=c(1,2))
draw_simple_OCN(OCN_a)
draw_simple_OCN(OCN_b) # the two OCNs are equal
par(old.par)
</code></pre>

<hr>
<h2 id='create_general_contour_OCN'>Create an Optimal Channel Network on a general contour</h2><span id='topic+create_general_contour_OCN'></span>

<h3>Description</h3>

<p>Function that performs the OCN search algorithm on a general contour and creates OCN at the flow direction (FD) level.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_general_contour_OCN(flowDirStart, expEnergy = 0.5,
  cellsize = 1, xllcorner = 0.5 * cellsize, yllcorner = 0.5 *
  cellsize, nIter = NULL, nUpdates = 50,
  initialNoCoolingPhase = 0, coolingRate = 1,
  showIntermediatePlots = FALSE, thrADraw = NULL, 
  easyDraw = NULL, saveEnergy = FALSE, saveExitFlag = FALSE,
  displayUpdates = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="create_general_contour_OCN_+3A_flowdirstart">flowDirStart</code></td>
<td>
<p>Matrix with custom initial flow directions. Cells outside the catchment must have value equal to <code>NaN</code>. 
Cells within the catchment have natural numbers between 0 and 8. Key is as follows:
</p>

<dl>
<dt><code>0</code></dt><dd><p>Outlet</p>
</dd>
<dt><code>1</code></dt><dd><p>+1 column</p>
</dd>
<dt><code>2</code></dt><dd><p>-1 row, +1 column</p>
</dd>
<dt><code>3</code></dt><dd><p>-1 row</p>
</dd>
<dt><code>4</code></dt><dd><p>-1 row, -1 column</p>
</dd>
<dt><code>5</code></dt><dd><p>-1 column</p>
</dd>
<dt><code>6</code></dt><dd><p>+1 row, -1 column</p>
</dd>
<dt><code>7</code></dt><dd><p>+1 row</p>
</dd>
<dt><code>8</code></dt><dd><p>+1 row, +1 column</p>
</dd>
</dl>

<p>Note that <code>flowDirStart</code> must have at least one outlet, that is one cell with value 0. The position of outlet(s) will not be altered by the OCN search algorithm. 
</p>
</td></tr>
<tr><td><code id="create_general_contour_OCN_+3A_expenergy">expEnergy</code></td>
<td>
<p>Exponent of the functional <code>sum(A^expEnergy)</code> that is minimized during the OCN search algorithm.</p>
</td></tr>
<tr><td><code id="create_general_contour_OCN_+3A_cellsize">cellsize</code></td>
<td>
<p>Size of a pixel in planar units.</p>
</td></tr>
<tr><td><code id="create_general_contour_OCN_+3A_xllcorner">xllcorner</code></td>
<td>
<p>Longitudinal (column-wise) coordinate of the lower-left pixel of <code>flowDirStart</code>.</p>
</td></tr>
<tr><td><code id="create_general_contour_OCN_+3A_yllcorner">yllcorner</code></td>
<td>
<p>Latitudinal (row-wise) coordinate of the lower-left pixel of <code>flowDirStart</code>.</p>
</td></tr>
<tr><td><code id="create_general_contour_OCN_+3A_niter">nIter</code></td>
<td>
<p>Number of iterations for the OCN search algorithm. Default is 40 times the number of non-<code>NaN</code> pixels of <code>flowDirStart</code>.</p>
</td></tr>
<tr><td><code id="create_general_contour_OCN_+3A_nupdates">nUpdates</code></td>
<td>
<p>Number of updates given during the OCN search process (only effective if <code>any(displayUpdates,showIntermediatePlots)=TRUE</code>.).</p>
</td></tr>
<tr><td><code id="create_general_contour_OCN_+3A_initialnocoolingphase">initialNoCoolingPhase</code>, <code id="create_general_contour_OCN_+3A_coolingrate">coolingRate</code></td>
<td>
<p>Parameters of the function used to describe the temperature of the simulated annealing algorithm. See details.</p>
</td></tr>
<tr><td><code id="create_general_contour_OCN_+3A_showintermediateplots">showIntermediatePlots</code></td>
<td>
<p>If <code>TRUE</code>, the OCN plot is updated <code>nUpdates</code> times during the OCN search process.
Note that, for large lattices, <code>showIntermediatePlots = TRUE</code> might slow down the search process considerably (especially when <code>easyDraw = FALSE</code>).</p>
</td></tr>
<tr><td><code id="create_general_contour_OCN_+3A_thradraw">thrADraw</code></td>
<td>
<p>Threshold drainage area value used to display the network (only effective when <code>showIntermediatePlots = TRUE</code>). Default value is <code>0.002*cellsize^2*nNodes</code>, where <code>nNodes</code> is the number of non-<code>NaN</code> pixels of <code>flowDirStart</code>.</p>
</td></tr>
<tr><td><code id="create_general_contour_OCN_+3A_easydraw">easyDraw</code></td>
<td>
<p>Logical. If <code>TRUE</code>, the whole network is displayed (when <code>showIntermediatePlots = TRUE</code>), and pixels with drainage area lower than <code>thrADraw</code> are displayed in light gray. If <code>FALSE</code>, only pixels with drainage area greater or equal to <code>thrADraw</code> are displayed. Default is <code>FALSE</code> if <code>dimX*dimY &lt;= 40000</code>, and <code>TRUE</code> otherwise. Note that setting <code>easyDraw = FALSE</code> for large networks might slow down the process considerably.</p>
</td></tr>
<tr><td><code id="create_general_contour_OCN_+3A_saveenergy">saveEnergy</code></td>
<td>
<p>If <code>TRUE</code>, <code>energy</code> is saved (see Value for its definition).</p>
</td></tr>
<tr><td><code id="create_general_contour_OCN_+3A_saveexitflag">saveExitFlag</code></td>
<td>
<p>If <code>TRUE</code>, <code>exitFlag</code> is saved (see Value for its definition).</p>
</td></tr>
<tr><td><code id="create_general_contour_OCN_+3A_displayupdates">displayUpdates</code></td>
<td>
<p>State if updates are printed on the console while the OCN search algorithm runs.
</p>

<dl>
<dt><code>0</code></dt><dd><p>No update is given.</p>
</dd>
<dt><code>1</code></dt><dd><p>An estimate of duration is given (only if <code>dimX*dimY &gt; 1000</code>, otherwise no update is given).</p>
</dd>
<dt><code>2</code></dt><dd><p>Progress updates are given. The number of these is controlled by <code>nUpdates</code></p>
</dd>
</dl>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>river</code> object as in <code><a href="#topic+create_OCN">create_OCN</a></code>, to which the reader is referred for detailed documentation.
However, note that in this case <code>dimX</code> and <code>dimY</code> are equal to the number of columns and rows of <code>flowDirStart</code>, respectively, 
while <code>nNodes</code> is the number of non-<code>NaN</code> pixels in <code>flowDirStart</code>. Hence, <code>nNodes</code> is generally lower than
<code>dimX*dimY</code>. The additionally exported vector <code>FD$toDEM</code> identifies the indices of the pixels of the landscape/flow direction matrix
that belong to the catchment (i.e., they are not <code>NaN</code>).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>OCN1 &lt;- create_general_contour_OCN(flowDir, nIter=0) # initial flow directions
OCN2 &lt;- create_general_contour_OCN(flowDir) # perform OCN algorithm
draw_simple_OCN(OCN1)
draw_simple_OCN(OCN2)
</code></pre>

<hr>
<h2 id='create_OCN'>Create an Optimal Channel Network</h2><span id='topic+create_OCN'></span>

<h3>Description</h3>

<p>Function that performs the OCN search algorithm on a rectangular lattice and creates OCN at the flow direction (FD) level.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_OCN(dimX, dimY, nOutlet = 1, outletSide = "S",
  outletPos = round(dimX/3), periodicBoundaries = FALSE,
  typeInitialState = NULL, flowDirStart = NULL, expEnergy = 0.5,
  cellsize = 1, xllcorner = 0.5 * cellsize, yllcorner = 0.5 *
  cellsize, nIter = 40 * dimX * dimY, nUpdates = 50,
  initialNoCoolingPhase = 0, coolingRate = 1,
  showIntermediatePlots = FALSE, thrADraw = 0.002 * dimX * dimY *
  cellsize^2, easyDraw = NULL, saveEnergy = FALSE, saveExitFlag = FALSE,
  saveN8 = FALSE, saveN4 = FALSE, displayUpdates = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="create_OCN_+3A_dimx">dimX</code></td>
<td>
<p>Longitudinal dimension of the lattice (in number of pixels).</p>
</td></tr>
<tr><td><code id="create_OCN_+3A_dimy">dimY</code></td>
<td>
<p>Latitudinal dimension of the lattice (in number of pixels).</p>
</td></tr>
<tr><td><code id="create_OCN_+3A_noutlet">nOutlet</code></td>
<td>
<p>Number of outlets. If <code>nOutlet = "All"</code>, all border pixels are set as outlets.</p>
</td></tr>
<tr><td><code id="create_OCN_+3A_outletside">outletSide</code></td>
<td>
<p>Side of the lattice where the outlet(s) is/are placed. 
It is a vector of characters, whose allowed values are <code>"N"</code> (northern side), <code>"E"</code>, <code>"S"</code>, <code>"W"</code>.
Its length must be equal to <code>nOutlet</code>.</p>
</td></tr>
<tr><td><code id="create_OCN_+3A_outletpos">outletPos</code></td>
<td>
<p>Vector of positions of outlets within the sides specified by <code>outletSide</code>. 
If <code>outletSide[i] = "N"</code> or <code>"S"</code>, then <code>outletPos[i]</code> must be a natural number in the interval <code>1:dimX</code>; 
if <code>outletSide[i] = "W"</code> or <code>"E"</code>, then <code>outletPos[i]</code> must be a natural number in the interval <code>1:dimY</code>. 
If <code>nOutlet &gt; 1</code> is specified by the user and <code>outletSide</code>, <code>outletPos</code> are not, a number of outlets equal to 
<code>nOutlet</code> is randomly drawn among the border pixels. Its length must be equal to <code>nOutlet</code>.</p>
</td></tr>
<tr><td><code id="create_OCN_+3A_periodicboundaries">periodicBoundaries</code></td>
<td>
<p>If <code>TRUE</code>, periodic boundaries are applied. In this case, the lattice is the planar equivalent of a torus.</p>
</td></tr>
<tr><td><code id="create_OCN_+3A_typeinitialstate">typeInitialState</code></td>
<td>
<p>Configuration of the initial state of the network. Possible values: <code>"I"</code> (representing a valley); 
<code>"T"</code> (T-shaped drainage pattern); <code>"V"</code> (V-shaped drainage pattern); <code>"H"</code> (hip roof). Default value is set to <code>"I"</code>, unless when <code>nOutlet = "All"</code>, where default is <code>"H"</code>. 
See Details for explanation on initial network state in the multiple outlet case.</p>
</td></tr>
<tr><td><code id="create_OCN_+3A_flowdirstart">flowDirStart</code></td>
<td>
<p>Matrix (<code>dimY</code> by <code>dimX</code>) with custom initial flow directions. 
Possible entries to <code>flowDirStart</code> are natural numbers between 1 and 8, indicating direction of flow from one cell to the neighbouring one. 
Key is as follows:
</p>

<dl>
<dt><code>1</code></dt><dd><p>+1 column</p>
</dd>
<dt><code>2</code></dt><dd><p>-1 row, +1 column</p>
</dd>
<dt><code>3</code></dt><dd><p>-1 row</p>
</dd>
<dt><code>4</code></dt><dd><p>-1 row, -1 column</p>
</dd>
<dt><code>5</code></dt><dd><p>-1 column</p>
</dd>
<dt><code>6</code></dt><dd><p>+1 row, -1 column</p>
</dd>
<dt><code>7</code></dt><dd><p>+1 row</p>
</dd>
<dt><code>8</code></dt><dd><p>+1 row, +1 column</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="create_OCN_+3A_expenergy">expEnergy</code></td>
<td>
<p>Exponent of the functional <code>sum(A^expEnergy)</code> that is minimized during the OCN search algorithm.</p>
</td></tr>
<tr><td><code id="create_OCN_+3A_cellsize">cellsize</code></td>
<td>
<p>Size of a pixel in planar units.</p>
</td></tr>
<tr><td><code id="create_OCN_+3A_xllcorner">xllcorner</code></td>
<td>
<p>Longitudinal coordinate of the lower-left pixel.</p>
</td></tr>
<tr><td><code id="create_OCN_+3A_yllcorner">yllcorner</code></td>
<td>
<p>Latitudinal coordinate of the lower-left pixel.</p>
</td></tr>
<tr><td><code id="create_OCN_+3A_niter">nIter</code></td>
<td>
<p>Number of iterations for the OCN search algorithm.</p>
</td></tr>
<tr><td><code id="create_OCN_+3A_nupdates">nUpdates</code></td>
<td>
<p>Number of updates given during the OCN search process (only effective if <code>any(displayUpdates,showIntermediatePlots)=TRUE</code>.).</p>
</td></tr>
<tr><td><code id="create_OCN_+3A_initialnocoolingphase">initialNoCoolingPhase</code>, <code id="create_OCN_+3A_coolingrate">coolingRate</code></td>
<td>
<p>Parameters of the function used to describe the temperature of the simulated annealing algorithm. See details.</p>
</td></tr>
<tr><td><code id="create_OCN_+3A_showintermediateplots">showIntermediatePlots</code></td>
<td>
<p>If <code>TRUE</code>, the OCN plot is updated <code>nUpdates</code> times during the OCN search process.
Note that, for large lattices, <code>showIntermediatePlots = TRUE</code> might slow down the search process considerably (especially when <code>easyDraw = FALSE</code>).</p>
</td></tr>
<tr><td><code id="create_OCN_+3A_thradraw">thrADraw</code></td>
<td>
<p>Threshold drainage area value used to display the network (only effective when <code>showIntermediatePlots = TRUE</code>).</p>
</td></tr>
<tr><td><code id="create_OCN_+3A_easydraw">easyDraw</code></td>
<td>
<p>Logical. If <code>TRUE</code>, the whole network is displayed (when <code>showIntermediatePlots = TRUE</code>), and pixels with drainage area lower than <code>thrADraw</code> are displayed in light gray. If <code>FALSE</code>, only pixels with drainage area greater or equal to <code>thrADraw</code> are displayed. Default is <code>FALSE</code> if <code>dimX*dimY &lt;= 40000</code>, and <code>TRUE</code> otherwise. Note that setting <code>easyDraw = FALSE</code> for large networks might slow down the process considerably.</p>
</td></tr>
<tr><td><code id="create_OCN_+3A_saveenergy">saveEnergy</code></td>
<td>
<p>If <code>TRUE</code>, <code>energy</code> is saved (see Value for its definition).</p>
</td></tr>
<tr><td><code id="create_OCN_+3A_saveexitflag">saveExitFlag</code></td>
<td>
<p>If <code>TRUE</code>, <code>exitFlag</code> is saved (see Value for its definition).</p>
</td></tr>
<tr><td><code id="create_OCN_+3A_saven8">saveN8</code></td>
<td>
<p>If <code>TRUE</code>, the adjacency matrix relative to 8-nearest-neighbours connectivity is saved.</p>
</td></tr>
<tr><td><code id="create_OCN_+3A_saven4">saveN4</code></td>
<td>
<p>If <code>TRUE</code>, the adjacency matrix relative to 4-nearest-neighbours connectivity is saved.</p>
</td></tr>
<tr><td><code id="create_OCN_+3A_displayupdates">displayUpdates</code></td>
<td>
<p>State if updates are printed on the console while the OCN search algorithm runs.
</p>

<dl>
<dt><code>0</code></dt><dd><p>No update is given.</p>
</dd>
<dt><code>1</code></dt><dd><p>An estimate of duration is given (only if <code>dimX*dimY &gt; 1000</code>, otherwise no update is given).</p>
</dd>
<dt><code>2</code></dt><dd><p>Progress updates are given. The number of these is controlled by <code>nUpdates</code></p>
</dd>
</dl>
</td></tr>
</table>


<h3>Details</h3>

<p><em>Simulated annealing temperature.</em> 
The function that expresses the temperature of the simulated annealing process is as follows: 
</p>

<dl>
<dt>if <code>i &lt;= initialNoCoolingPhase*nIter</code>:</dt><dd><p><code>Temperature[i] = Energy[1]</code></p>
</dd>
<dt>if <code>initialNoCoolingPhase*nIter &lt; i &lt;= nIter</code>:</dt><dd><p><code>Temperature[i] = Energy[1]*(-coolingRate*(i - InitialNocoolingPhase*nIter)/nNodes)</code></p>
</dd>
</dl>

<p>where <code>i</code> is the index of the current iteration and <code>Energy[1] = sum(A^expEnergy)</code>, with <code>A</code> denoting 
the vector of drainage areas corresponding to the initial state of the network. According to the simulated annealing 
principle, a new network configuration obtained at iteration <code>i</code> is accepted with probability equal to 
<code>exp((Energy[i] - Energy[i-1])/Temperature[i])</code> if <code>Energy[i] &lt; Energy[i-1]</code>. 
To ensure convergence, it is recommended to use <code>coolingRate</code> values between 0.5 and 10 and <code>initialNoCoolingPhase &lt;= 0.3</code>. 
Low <code>coolingRate</code> and high <code>initialNoCoolingPhase</code> values cause the network configuration to depart more significantly from the initial state.
If <code>coolingRate &lt; 0.5</code> and <code>initialNoCoolingPhase &gt; 0.1</code> are used, it is suggested to increase <code>nIter</code> with respect to the default value in order to guarantee convergence.
</p>
<p><em>Initial network state.</em> 
If <code>nOutlet &gt; 1</code>, the initial state is applied with regards to the outlet located at <code>outletSide[1]</code>, <code>outletPos[1]</code>. 
Subsequently, for each of the other outlets, the drainage pattern is altered within a region of maximum size <code>0.5*dimX</code> by <code>0.25*dimY</code> for outlets located at the eastern and western borders of the lattice, 
and <code>0.25*dimX</code> by <code>0.5*dimY</code> for outlets located at the southern and northern borders of the lattice. The midpoint of the long size of the regions coincides with the outlet at stake.
Within these regions, an <code>"I"</code>-type drainage pattern is produced if <code>typeInitialState = "I"</code> or <code>"T"</code>; a <code>"V"</code>-type drainage pattern is produced if <code>typeInitialState = "V"</code>; 
no action is performed if <code>typeInitialState = "H"</code>. Note that <code>typeInitialState = "H"</code> is the recommended choice only for large <code>nOutlet</code>.
</p>
<p><em>Suggestions for creating &quot;fancy&quot; OCNs.</em> 
In order to generate networks spanning a realistic, non-rectangular catchment domain (in the &quot;real-shape&quot; view provided by <code><a href="#topic+draw_contour_OCN">draw_contour_OCN</a></code>), it is convenient 
to use the option <code>periodicBoundaries = TRUE</code> and impose at least a couple of diagonally adjacent outlets on two opposite sides, for example <code>nOutlet = 2</code>, <code>outletSide = c("S", "N")</code>, <code>outletPos = c(1, 2)</code>. 
See also <code><a href="#topic+OCN_300_4out_PB_hot">OCN_300_4out_PB_hot</a></code>. Note that, because the OCN search algorithm is a stochastic process, the successful generation of a &quot;fancy&quot; OCN is not guaranteed: indeed, it is possible that the final outcome is a 
network where most (if not all) pixels drain towards one of the two outlets, and hence such outlet is surrounded (in the &quot;real-shape&quot; view) by the pixels that it drains. Note that, in order to hinder such occurrence, the two pixels along the lattice perimeter next to each outlet are bound to drain towards such outlet.
</p>
<p>In order to create a network spanning a &quot;pear-shaped&quot; catchment (namely where the width of the area spanned in the direction orthogonal to the main stem diminishes downstream, until it coincides with the river width at the outlet),
it is convenient to use the option <code>nOutlet = "All"</code> (here the value of <code>periodicBoundaries</code> is irrelevant) and then pick a single catchment (presumably one with rather large catchment area, see value <code>OCN$CM$A</code> generated by <code><a href="#topic+landscape_OCN">landscape_OCN</a></code>) among the many generated. Note that it is not possible to predict the area spanned by such catchment <em>a priori</em>. To obtain a catchment whose size is rather large compared to the size of the lattice where the 
OCN was generated, it is convenient to set <code>typeInitialState = "I"</code> and then pick the catchment with largest area (<code><a href="#topic+landscape_OCN">landscape_OCN</a></code> must be run).
</p>
<p>The default temperature schedule for the simulated annealing process is generally adequate for generating an OCN that does not resemble the initial network state if the size of the lattice is not too large (say, until <code>dimX*dimY &lt;= 40000</code>). When <code>dimX*dimY &gt; 40000</code>, it might be convenient to make use of a &quot;warmer&quot; temperature schedule (for example, by setting <code>coolingRate = 0.5</code> and <code>initialNoCoolingPhase = 0.1</code>; see also the package vignette) and/or increase <code>nIter</code> with respect to its default value. Note that these suggestions only pertain to the aesthetics of the final OCN; the default temperature schedule and <code>nIter</code> are calibrated to ensure convergence of the OCN (i.e. achievement of a local minimum of <code>Energy</code>, save for a reasonable threshold) also for lattices larger than <code>dimX*dimY = 40000</code>.
</p>


<h3>Value</h3>

<p>A <code><a href="#topic+river">river</a></code> object. It is de facto a list, whose objects are listed below. Variables that define the network at the FD level are wrapped in the sublist <code>FD</code>.
Adjacency matrices describing 4- or 8- nearest-neighbours connectivity among pixels are contained in lists <code>N4</code> and <code>N8</code>, respectively. 
</p>
<table>
<tr><td><code>FD$A</code></td>
<td>
<p>Vector (of length <code>dimX*dimY</code>) containing drainage area values for all FD pixels (in square planar units).</p>
</td></tr>
<tr><td><code>FD$W</code></td>
<td>
<p>Adjacency matrix (<code>dimX*dimY</code> by <code>dimX*dimY</code>) at the FD level. 
It is a <code><a href="spam.html#topic+spam">spam</a></code> object.</p>
</td></tr>
<tr><td><code>FD$downNode</code></td>
<td>
<p>Vector (of length <code>dimX*dimY</code>) representing the adjacency matrix at FD level in a vector form: 
if <code>FD$downNode[i] = j</code> then <code>FD$W[i,j] = 1</code>. If <code>o</code> is the outlet pixel, 
then <code>FD$downNode[o] = 0</code>.</p>
</td></tr>
<tr><td><code>FD$X (FD$Y)</code></td>
<td>
<p>Vector (of length <code>dimX*dimY</code>) containing X (Y) coordinate values for all FD pixels.</p>
</td></tr>
<tr><td><code>FD$nNodes</code></td>
<td>
<p>Number of nodes at FD level (equal to <code>dimX*dimY</code>).</p>
</td></tr>
<tr><td><code>FD$outlet</code></td>
<td>
<p>Vector (of length <code>nOutlet</code>) indices of pixels at FD level corresponding to outlets.</p>
</td></tr>
<tr><td><code>FD$perm</code></td>
<td>
<p>Vector (of length <code>dimX*dimY</code>) representing a permutation of the FD pixels: <code>perm[(which(perm==i) - FD$A[i] + 1):which(perm==i)]</code> gives the indices of the pixels that drain into pixel <code>i</code>.</p>
</td></tr>
<tr><td><code>energyInit</code></td>
<td>
<p>Initial energy value.</p>
</td></tr>
<tr><td><code>energy</code></td>
<td>
<p>Vector (of length <code>nIter</code>) of energy values for each stage of the OCN during the search algorithm (only present if <code>saveEnergy = TRUE</code>).</p>
</td></tr>
<tr><td><code>exitFlag</code></td>
<td>
<p>Vector (of length <code>nIter</code>) showing the outcome of the rewiring process (only present if <code>saveExitFlag = TRUE</code>). Its entries can assume one of the following values:
</p>

<dl>
<dt><code>0</code></dt><dd><p>Rewiring is accepted.</p>
</dd>
<dt><code>1</code></dt><dd><p>Rewiring is not accepted (because it does not lower <code>energy</code> or according to the acceptance probability of the simulated annealing algorithm).</p>
</dd>
<dt><code>2</code></dt><dd><p>Rewiring is invalid  because a loop in the graph was generated, therefore the network is no longer a direct acyclic graph.</p>
</dd>
<dt><code>3</code></dt><dd><p>Rewiring is invalid because of cross-flow. This means that, for example, in a 2x2 cluster of pixel, the southwestern (SW) corner drains into the NE one, and SE drains into NW.
Although this circumstance does not imply the presence of a loop in the graph, it has no physical meaning and is thereby forbidden.</p>
</dd>
</dl>
</td></tr>
<tr><td><code>N4$W</code></td>
<td>
<p>Adjacency matrix (<code>dimX*dimY</code> by <code>dimX*dimY</code>) that describes 4-nearest-neighbours connectivity 
between pixels: <code>N4$W[i,j] = 1</code> if pixel <code>j</code> shares an edge with <code>i</code>, and is null otherwise. 
It is saved only if <code>saveN4 = TRUE</code>.</p>
</td></tr> 
<tr><td><code>N8$W</code></td>
<td>
<p>Adjacency matrix (<code>dimX*dimY</code> by <code>dimX*dimY</code>) that describes 8-nearest-neighbours connectivity 
between pixels: <code>N8$W[i,j] = 1</code> if pixel <code>j</code> shares an edge or a vertex with <code>i</code>, and is null otherwise. 
It is saved only if <code>saveN8 = TRUE</code>.</p>
</td></tr>  
</table>
<p>Finally, <code>dimX</code>, <code>dimY</code>, <code>cellsize</code>, <code>nOutlet</code>, <code>periodicBoundaries</code>, <code>expEnergy</code>, 
<code>coolingRate</code>, <code>typeInitialState</code>, <code>nIter</code>, <code>xllcorner</code>, <code>yllcorner</code> are passed to the <code>river</code> object as they were included in the input 
(except <code>nOutlet = "All"</code> which is converted to <code>2*(dimX + dimY - 2))</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># 1) creates and displays a single outlet 20x20 OCN with default options
set.seed(1)
OCN_a &lt;- create_OCN(20, 20)
draw_simple_OCN(OCN_a)


# 2) creates and displays a 2-outlet OCNs with manually set outlet location, 
# and a 4-outlet OCNs with random outlet position.
set.seed(1)
old.par &lt;- par(no.readonly = TRUE)
par(mfrow=c(1,2))
OCN_b1 &lt;- create_OCN(30, 30, nOutlet = 2, outletSide = c("N", "W"), outletPos = c(15, 12))
OCN_b2 &lt;- create_OCN(30, 30, nOutlet = 4)
draw_simple_OCN(OCN_b1)
title("2-outlet OCN")
draw_simple_OCN(OCN_b2)
title("4-outlet OCN")
par(old.par)


## Not run: 
# 3) generate 3 single-outlet OCNs on the same (100x100) domain starting from different 
# initial states, and show 20 intermediate plots and console updates.
set.seed(1)
OCN_V &lt;- create_OCN(100, 100, typeInitialState = "V", showIntermediatePlots = TRUE, 
		nUpdates = 20, displayUpdates = 2)
OCN_T &lt;- create_OCN(100, 100, typeInitialState = "T", showIntermediatePlots = TRUE, 
		nUpdates = 20, displayUpdates = 2)
OCN_I &lt;- create_OCN(100, 100, typeInitialState = "I", showIntermediatePlots = TRUE, 
		nUpdates = 20, displayUpdates = 2)

## End(Not run)

## Not run: 
# 4) generate a 2-outlet OCN and show intermediate plots. Note that different colors are used 
# to identify the two networks  (all pixels are colored because thrADraw = 0).
set.seed(1)
OCN &lt;- create_OCN(150, 70, nOutlet = 2, outletPos = c(1, 150), outletSide = c("S", "N"),
		typeInitialState = "V", periodicBoundaries = TRUE, 
		showIntermediatePlots = TRUE, thrADraw = 0)
# The resulting networks have an irregular contour, and their outlets are located on the contour:
draw_contour_OCN(landscape_OCN(OCN))

## End(Not run)
</code></pre>

<hr>
<h2 id='create_peano'>Create Peano network</h2><span id='topic+create_peano'></span>

<h3>Description</h3>

<p>Function that creates Peano networks on a square lattice.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_peano(nIterPeano, outletPos = "NE", xllcorner = 1,
  yllcorner = 1, cellsize = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="create_peano_+3A_niterpeano">nIterPeano</code></td>
<td>
<p>Number of iteration of the Peano scheme. The resulting network will span a domain 
of size <code>2^(nIterPeano + 1)</code> by <code>2^(nIterPeano + 1)</code>.</p>
</td></tr>
<tr><td><code id="create_peano_+3A_outletpos">outletPos</code></td>
<td>
<p>Corner where the outlet is located, expressed as intercardinal direction. 
Possible values are <code>"NE"</code>, <code>"SE"</code>, <code>"SW"</code>, <code>"NW"</code>.</p>
</td></tr>
<tr><td><code id="create_peano_+3A_xllcorner">xllcorner</code></td>
<td>
<p>X coordinate of the lower-left pixel (expressed in planar units).</p>
</td></tr>
<tr><td><code id="create_peano_+3A_yllcorner">yllcorner</code></td>
<td>
<p>Y coordinate of the lower-left pixel (expressed in planar units).</p>
</td></tr>
<tr><td><code id="create_peano_+3A_cellsize">cellsize</code></td>
<td>
<p>Size of a pixel (expressed in planar units).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>river</code> object that contains the same objects as those produced by <code><a href="#topic+create_OCN">create_OCN</a></code>. 
As such, it can be used as input for all other complementary functions of the package.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># 1) create a peano network in a 32x32 square,
# use landscape_OCN, aggregate_OCN functions,
# and display subcatchment map and map of drainage area
peano &lt;- create_peano(4)
peano &lt;- aggregate_OCN(landscape_OCN(peano), thrA = 4)
old.par &lt;- par(no.readonly = TRUE)
par(mfrow=c(1,3))
draw_simple_OCN(peano)
title("Peano network")
draw_subcatchments_OCN(peano)
title("Subcatchments")
draw_thematic_OCN(peano$RN$A, peano)
title("Drainage area at RN level")
par(old.par)
</code></pre>

<hr>
<h2 id='draw_contour_OCN'>Draw Optimal Channel Network with catchment contours</h2><span id='topic+draw_contour_OCN'></span>

<h3>Description</h3>

<p>Function that plots real-shaped OCN and catchment contours.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>draw_contour_OCN(OCN, thrADraw = 0.002 * OCN$FD$nNodes *
  OCN$cellsize^2, exactDraw = TRUE, drawContours = TRUE, colPalRiver = NULL, 
  colPalCont = "#000000", drawOutlets = 0, pch = 15, colPalOut = "#000000",
  min_lwd = 0.5, max_lwd = 5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="draw_contour_OCN_+3A_ocn">OCN</code></td>
<td>
<p>A <code>river</code> object as produced by <code><a href="#topic+landscape_OCN">landscape_OCN</a></code>.</p>
</td></tr>
<tr><td><code id="draw_contour_OCN_+3A_thradraw">thrADraw</code></td>
<td>
<p>Threshold drainage area value used to display the network.</p>
</td></tr>
<tr><td><code id="draw_contour_OCN_+3A_exactdraw">exactDraw</code></td>
<td>
<p>If <code>TRUE</code>, the real shape of OCNs is plotted. If flow crosses a boundary, 
the pixel that is not contiguous to its outlet is flipped. It is only effective if <code>OCN$PeriodicBoundaries = TRUE</code></p>
</td></tr>
<tr><td><code id="draw_contour_OCN_+3A_drawcontours">drawContours</code></td>
<td>
<p>If <code>TRUE</code>, plot catchment(s) contours.</p>
</td></tr>
<tr><td><code id="draw_contour_OCN_+3A_colpalriver">colPalRiver</code></td>
<td>
<p>Color palette used to plot the river network(s). Default is a rearranged version of theme <code>"Dark 3"</code> (see <code><a href="grDevices.html#topic+hcl.pals">hcl.pals</a></code>). <code>colPalRiver</code> accepts both functions creating color palettes and vectors of colors (of which the first <code>OCN$nOutlet</code> elements are used). If a single color value is provided and <code>OCN$nOutlet &gt; 1</code>, all river networks are drawn with the same color.</p>
</td></tr>
<tr><td><code id="draw_contour_OCN_+3A_colpalcont">colPalCont</code></td>
<td>
<p>Color palette used to plot the catchment contour(s). Details as in <code>colPalRiver</code>. Additionally, if <code>colPalCont = 0</code>, the palette specified in <code>colPalRiver</code> is copied. </p>
</td></tr>
<tr><td><code id="draw_contour_OCN_+3A_drawoutlets">drawOutlets</code></td>
<td>
<p>If equal to <code>1</code>, black squares are drawn at the outlets' locations behind the river; if <code>2</code> they are plotted on top of the river.</p>
</td></tr>
<tr><td><code id="draw_contour_OCN_+3A_pch">pch</code></td>
<td>
<p>Shape of the outlet points (if <code>drawOutlets = TRUE</code>). See <code><a href="graphics.html#topic+points">points</a></code> for legend.</p>
</td></tr>
<tr><td><code id="draw_contour_OCN_+3A_colpalout">colPalOut</code></td>
<td>
<p>Color palette used to plot the outlet points (if <code>drawOutlets = TRUE</code>). Details as in <code>colPalRiver</code>. Additionally, if <code>colPalOut = 0</code>, the palette specified in <code>colPalRiver</code> is copied. </p>
</td></tr>
<tr><td><code id="draw_contour_OCN_+3A_min_lwd">min_lwd</code>, <code id="draw_contour_OCN_+3A_max_lwd">max_lwd</code></td>
<td>
<p>Minimum and maximum values of line width used to display the OCN (actual line width is proportional to the square root of drainage area).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For not too large networks (i.e. if <code>OCN$FD$nNodes &lt;= 40000</code>, corresponding to a 200x200 lattice), 
pixels whose drainage area <code>OCN$FD$A</code> is lower than <code>thrADraw</code> are drawn with a light grey stroke.
If <code>OCN$FD$nNodes &gt; 40000</code>, in order to speed up the execution of this function, only the network constituted 
by pixels such that <code>OCN$FD$A &gt; thrADraw</code> is drawn.
</p>


<h3>Value</h3>

<p>No output is returned.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># 1) draw contour of a 20x20 single-outlet OCN
# (for single-outlet OCNs without periodic boundaries, the output
# of draw_contour_OCN is very similar to that of draw_simple_OCN)
draw_contour_OCN(landscape_OCN(OCN_20), thrADraw = 4)

## Not run: 
# 2a) plot real shape of multiple-outlet OCN created with periodic boundaries
# add outlets on top of the rivers
OCN &lt;- landscape_OCN(OCN_300_4out_PB_hot, displayUpdates = 2) # it takes around one minute
draw_contour_OCN(OCN, drawOutlets = 2)

# 2b) same as before, but use same color palette for rivers and contours
draw_contour_OCN(OCN, colPalCont = 0)

# 2c) draw contours of catchments obtained from an OCN with nOutlet = "All"
OCN &lt;- landscape_OCN(OCN_400_Allout, displayUpdates = 2) # it takes some minutes
draw_contour_OCN(OCN)

# 2d) same as above, but do not plot contours, and plot outlets 
# with same color palette as rivers
draw_contour_OCN(OCN, drawContours = FALSE, drawOutlets = TRUE,
		colPalOut = 0)


## End(Not run)
</code></pre>

<hr>
<h2 id='draw_elev2D_OCN'>Plot 2D map of elevation generated by an OCN</h2><span id='topic+draw_elev2D_OCN'></span>

<h3>Description</h3>

<p>Function that plots the 2D elevation map generated by an OCN.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>draw_elev2D_OCN(OCN, colPalette = terrain.colors(1000, alpha = 1),
addLegend = TRUE, drawRiver = FALSE, thrADraw = 0.002*OCN$FD$nNodes*OCN$cellsize^2,
riverColor = "#00BFFF", min_lwd = 0.5, max_lwd = 5, args_imagePlot = list())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="draw_elev2D_OCN_+3A_ocn">OCN</code></td>
<td>
<p>A <code>river</code> object as produced by <code><a href="#topic+landscape_OCN">landscape_OCN</a></code>.</p>
</td></tr>
<tr><td><code id="draw_elev2D_OCN_+3A_colpalette">colPalette</code></td>
<td>
<p>Color palette used for the plot.</p>
</td></tr>
<tr><td><code id="draw_elev2D_OCN_+3A_addlegend">addLegend</code></td>
<td>
<p>Logical. If <code>TRUE</code>, <code><a href="fields.html#topic+image.plot">image.plot</a></code> is used to display the legend; as a result, elements (e.g. node coordinates) subsequently plotted of on top of the 2D elevation map might be wrongly positioned.</p>
</td></tr>
<tr><td><code id="draw_elev2D_OCN_+3A_drawriver">drawRiver</code></td>
<td>
<p>Logical. If <code>TRUE</code>, draw the OCN on top of the elevation map.</p>
</td></tr>
<tr><td><code id="draw_elev2D_OCN_+3A_thradraw">thrADraw</code></td>
<td>
<p>Threshold drainage area value used to display the network.</p>
</td></tr>
<tr><td><code id="draw_elev2D_OCN_+3A_rivercolor">riverColor</code></td>
<td>
<p>Color used to display the OCN (only effective if <code>drawRiver = TRUE</code>). </p>
</td></tr>
<tr><td><code id="draw_elev2D_OCN_+3A_min_lwd">min_lwd</code>, <code id="draw_elev2D_OCN_+3A_max_lwd">max_lwd</code></td>
<td>
<p>Minimum and maximum values of line width used to display the OCN (actual line width is proportional to the square root of drainage area).</p>
</td></tr>
<tr><td><code id="draw_elev2D_OCN_+3A_args_imageplot">args_imagePlot</code></td>
<td>
<p>List of arguments passed to <code><a href="fields.html#topic+imagePlot">imagePlot</a></code> (or to <code><a href="Matrix.html#topic+image">image</a></code> if <code>addLegend = FALSE</code>). For example, argument <code>smallplot</code> can be used to specify the plot coordinates for the legend.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No output is returned.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># 1) draw 2D map of a 20x20 OCN with default settings
draw_elev2D_OCN(landscape_OCN(OCN_20))
</code></pre>

<hr>
<h2 id='draw_elev3D_OCN'>Plot 3D map of elevation generated by an OCN</h2><span id='topic+draw_elev3D_OCN'></span>

<h3>Description</h3>

<p>Function that plots the 3D elevation map generated by an OCN.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>draw_elev3D_OCN(OCN, coarseGrain = c(1,1), colPalette = terrain.colors(1000, alpha = 1),
  addColorbar = TRUE, drawRiver = TRUE, thrADraw = 0.002 *
  OCN$FD$nNodes * OCN$cellsize^2, riverColor = "#00CCFF",
  theta = -20, phi = 30, expand = 0.05, shade = 0.5, min_lwd = 0.5, max_lwd = 5, 
  args_imagePlot = list())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="draw_elev3D_OCN_+3A_ocn">OCN</code></td>
<td>
<p>A <code>river</code> object as produced by <code><a href="#topic+landscape_OCN">landscape_OCN</a></code>.</p>
</td></tr>
<tr><td><code id="draw_elev3D_OCN_+3A_coarsegrain">coarseGrain</code></td>
<td>
<p>2x1 vector (only effective if <code>chooseCM = FALSE</code>). For aesthetic purposes, the elevation map can be coarse-grained into a <code>OCN$dimX/coarseGrain[1]</code>-by-<code>OCN$dimX/coarseGrain[2]</code> 
domain, where each cell's elevation is the average of elevations of the corresponding <code>coarseGrain[1]</code>-by-<code>coarseGrain[2]</code> cells of the original elevation field. 
<code>coarseGrain[1]</code> and <code>coarseGrain[2]</code> must be divisors of <code>OCN$dimX</code> and <code>OCN$dimY</code>, respectively. <code>coarseGrain = c(2,2)</code> is often sufficient to achieve a good graphical results for large 
(i.e. at least 100x100 nodes) OCNs.</p>
</td></tr>
<tr><td><code id="draw_elev3D_OCN_+3A_colpalette">colPalette</code></td>
<td>
<p>Color palette used for the plot.</p>
</td></tr>
<tr><td><code id="draw_elev3D_OCN_+3A_addcolorbar">addColorbar</code></td>
<td>
<p>If <code>TRUE</code>, add colorbar to the plot.</p>
</td></tr>
<tr><td><code id="draw_elev3D_OCN_+3A_drawriver">drawRiver</code></td>
<td>
<p>If <code>TRUE</code>, draw the OCN on top of the elevation field.</p>
</td></tr>
<tr><td><code id="draw_elev3D_OCN_+3A_thradraw">thrADraw</code></td>
<td>
<p>Threshold drainage area value used to display the network.</p>
</td></tr>
<tr><td><code id="draw_elev3D_OCN_+3A_rivercolor">riverColor</code></td>
<td>
<p>Color used to plot the river.</p>
</td></tr>
<tr><td><code id="draw_elev3D_OCN_+3A_theta">theta</code>, <code id="draw_elev3D_OCN_+3A_phi">phi</code>, <code id="draw_elev3D_OCN_+3A_expand">expand</code>, <code id="draw_elev3D_OCN_+3A_shade">shade</code></td>
<td>
<p>Additional parameters passed to the perspective plotting 
function <code><a href="graphics.html#topic+persp">persp</a></code>. <code>theta</code> expresses azimuthal direction; <code>phi</code> gives 
colatitude; <code>expand</code> is the expansion factor for the Z coordinates; <code>shade</code> controls
the shade at a surface facet.</p>
</td></tr>
<tr><td><code id="draw_elev3D_OCN_+3A_min_lwd">min_lwd</code>, <code id="draw_elev3D_OCN_+3A_max_lwd">max_lwd</code></td>
<td>
<p>Minimum and maximum values of line width used to display the OCN (actual line width is proportional to the square root of drainage area).</p>
</td></tr>
<tr><td><code id="draw_elev3D_OCN_+3A_args_imageplot">args_imagePlot</code></td>
<td>
<p>Only effective if <code>addColorbar = TRUE</code>. List of arguments passed to <code><a href="fields.html#topic+imagePlot">imagePlot</a></code> for drawing a continuous legend. For example, argument <code>smallplot</code> can be used to specify the plot coordinates for the legend.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No output is returned.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># draw 3D representation of a 20x20 OCN with default options
draw_elev3D_OCN(landscape_OCN(OCN_20))

## Not run: 
# 1a) draw the 3D representation of the OCN (without displaying the river  
# and the colorbar) and enhance the aspect ratio of Z coordinates 
# with respect to the default value (the final result will be ugly):
OCN &lt;- landscape_OCN(OCN_400_Allout, displayUpdates = 2) # this takes some minutes  
draw_elev3D_OCN(OCN, expand = 0.2, addColorbar = FALSE, drawRiver = FALSE)

# 1b) same as above, but operate coarse graining  and modify shade for better aesthetics: 
draw_elev3D_OCN(OCN, coarseGrain = c(5,5), expand = 0.2, 
		shade = 0.25, addColorbar = FALSE, drawRiver = FALSE)

## End(Not run)
</code></pre>

<hr>
<h2 id='draw_elev3Drgl_OCN'>Plot 3D map of elevation generated by an OCN via rgl rendering</h2><span id='topic+draw_elev3Drgl_OCN'></span>

<h3>Description</h3>

<p>Function that plots the 3D elevation map generated by an OCN.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>draw_elev3Drgl_OCN(OCN, coarseGrain = c(1, 1), chooseCM = FALSE,
  addColorbar = FALSE, drawRiver = FALSE, thrADraw = 0.002 *
  OCN$FD$nNodes* OCN$cellsize^2, riverColor = "#00CCFF", 
  min_lwd = 1, max_lwd = 8, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="draw_elev3Drgl_OCN_+3A_ocn">OCN</code></td>
<td>
<p>A <code>river</code> object as produced by <code><a href="#topic+landscape_OCN">landscape_OCN</a></code>.</p>
</td></tr>
<tr><td><code id="draw_elev3Drgl_OCN_+3A_coarsegrain">coarseGrain</code></td>
<td>
<p>2x1 vector (only effective if <code>chooseCM = FALSE</code>). For aesthetic purposes, the elevation map can be coarse-grained into a <code>OCN$dimX/coarseGrain[1]</code>-by-<code>OCN$dimX/coarseGrain[2]</code> 
domain, where each cell's elevation is the average of elevations of the corresponding <code>coarseGrain[1]</code>-by-<code>coarseGrain[2]</code> cells of the original elevation field. 
<code>coarseGrain[1]</code> and <code>coarseGrain[2]</code> must be divisors of <code>OCN$dimX</code> and <code>OCN$dimY</code>, respectively. <code>coarseGrain = c(2,2)</code> is often sufficient to achieve a good graphical results for large 
(i.e. at least 100x100 nodes) OCNs.</p>
</td></tr>
<tr><td><code id="draw_elev3Drgl_OCN_+3A_choosecm">chooseCM</code></td>
<td>
<p>Index of catchment to display (only effective if <code>OCN$nOutlet &gt; 1</code>). It can be a logical, or a scalar within <code>1:length(OCN$nOutlet)</code>. 
If <code>TRUE</code>, the catchment with largest area is displayed. Note that, if the size of the chosen catchment is too small (e.g. <code>OCN$CM$A[chooseCM] &lt; 5*OCN$cellsize^2</code>), an error might occur due to failure in triangulation.</p>
</td></tr>
<tr><td><code id="draw_elev3Drgl_OCN_+3A_addcolorbar">addColorbar</code></td>
<td>
<p>If <code>TRUE</code>, add colorbar to the plot.</p>
</td></tr>
<tr><td><code id="draw_elev3Drgl_OCN_+3A_drawriver">drawRiver</code></td>
<td>
<p>If <code>TRUE</code>, draw the OCN on top of the elevation field.</p>
</td></tr>
<tr><td><code id="draw_elev3Drgl_OCN_+3A_thradraw">thrADraw</code></td>
<td>
<p>Threshold drainage area value used to display the network.</p>
</td></tr>
<tr><td><code id="draw_elev3Drgl_OCN_+3A_rivercolor">riverColor</code></td>
<td>
<p>Color used to plot the river.</p>
</td></tr>
<tr><td><code id="draw_elev3Drgl_OCN_+3A_min_lwd">min_lwd</code>, <code id="draw_elev3Drgl_OCN_+3A_max_lwd">max_lwd</code></td>
<td>
<p>Minimum and maximum values of line width used to display the OCN (actual line width is proportional to the square root of drainage area).</p>
</td></tr>
<tr><td><code id="draw_elev3Drgl_OCN_+3A_...">...</code></td>
<td>
<p>Further parameters passed to function <code><a href="rgl.html#topic+persp3d">persp3d</a></code>. The default value for <code>aspect</code> is <code>c(OCN$dimX/sqrt(OCN$dimX*OCN$dimY, OCN$dimY/sqrt(OCN$dimX*OCN$dimY, 1))</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function makes use of the <code><a href="rgl.html#topic+rgl">rgl</a></code> rendering system. To export the figure in raster format, use <code><a href="rgl.html#topic+rgl.snapshot">rgl.snapshot</a></code>. 
To export in vectorial format, use <code><a href="rgl.html#topic+rgl.postscript">rgl.postscript</a></code> (but note that this might produce rendering issues, see <code><a href="rgl.html#topic+rgl">rgl</a></code> for details).
The function will attempt at drawing a contour of the plotted entity (i.e. the lattice or a catchment, depending on <code>chooseCM</code>) at null elevation, and drawing polygons connecting this contour with the lattice/catchment contour at the real elevation. If <code>chooseCM != FALSE</code>, this might result in errors owing to failure of <code><a href="rgl.html#topic+polygon3d">polygon3d</a></code> in triangulating the polygons.  
</p>


<h3>Value</h3>

<p>No output is returned.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
draw_elev3Drgl_OCN(landscape_OCN(OCN_20))

## End(Not run)

## Not run: 
# 1a) draw the 3D representation of a single catchment within an OCN 
# generated with nOutlet = "All" and add draw the river on top of it
OCN &lt;- landscape_OCN(OCN_400_Allout, displayUpdates = 2) # this takes some minutes
draw_elev3Drgl_OCN(OCN, chooseCM = 983, drawRiver = TRUE)

# 1b) draw the 3D representation of the largest catchment within the OCN 
# (here polygon3d may fail at plotting the polygon at zero elevation)   
draw_elev3Drgl_OCN(OCN, chooseCM = TRUE) 

# 1c) draw the 3D representation of the whole OCN
# and enhance the aspect ratio of Z coordinates 
# with respect to the default value (the final result will be ugly):  
draw_elev3Drgl_OCN(OCN, aspect = c(1, 1, 0.2))

# 1d) same as above, but operate coarse graining for better aesthetics: 
draw_elev3Drgl_OCN(OCN, coarseGrain = c(5,5), aspect = c(1, 1, 0.2))

# 2) draw the 3D representation of a single catchment of an OCN generated
# with periodicBoundaries = TRUE
# (note that the real shape of the catchment is drawn)
OCN &lt;- landscape_OCN(OCN_300_4out_PB, displayUpdates = 2) # this takes some minutes
draw_elev3Drgl_OCN(OCN, chooseCM = TRUE) 

## End(Not run)
</code></pre>

<hr>
<h2 id='draw_simple_OCN'>Draw an Optimal Channel Network</h2><span id='topic+draw_simple_OCN'></span>

<h3>Description</h3>

<p>Function that plots the non-aggregated OCN as calculated by <code>create_OCN</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>draw_simple_OCN(OCN, thrADraw = 0.002 * OCN$FD$nNodes *
  OCN$cellsize^2, riverColor = "#0066FF", easyDraw = NULL, 
  min_lwd = 0.5,  max_lwd = 5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="draw_simple_OCN_+3A_ocn">OCN</code></td>
<td>
<p>A <code>river</code> object as produced by <code><a href="#topic+create_OCN">create_OCN</a></code>.</p>
</td></tr>
<tr><td><code id="draw_simple_OCN_+3A_thradraw">thrADraw</code></td>
<td>
<p>Threshold drainage area value used to display the network.</p>
</td></tr>
<tr><td><code id="draw_simple_OCN_+3A_rivercolor">riverColor</code></td>
<td>
<p>Color used to plot the river.</p>
</td></tr>
<tr><td><code id="draw_simple_OCN_+3A_easydraw">easyDraw</code></td>
<td>
<p>Logical. If <code>TRUE</code>, the whole network is displayed, and pixels with drainage area lower than <code>thrADraw</code> are displayed in light gray. If <code>FALSE</code>, only pixels with drainage area greater or equal to <code>thrADraw</code> are displayed. Default is <code>FALSE</code> if <code>OCN$nNodes &lt;= 40000</code>, and <code>TRUE</code> otherwise. Note that setting <code>easyDraw = FALSE</code> for large networks might slow down the process considerably.</p>
</td></tr>
<tr><td><code id="draw_simple_OCN_+3A_min_lwd">min_lwd</code>, <code id="draw_simple_OCN_+3A_max_lwd">max_lwd</code></td>
<td>
<p>Minimum and maximum values of line width used to display the OCN (actual line width is proportional to the square root of drainage area).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No output is returned.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># 1a) draw OCN with default settings
draw_simple_OCN(OCN_250_T)

# 1b) same as above, but with decreased thrADraw
draw_simple_OCN(OCN_250_T, thrADraw = 0.001 * OCN_250_T$dimX * OCN_250_T$dimY)
# 1c) same as the first example, but include the portion of network  
# with drainage area lower than thrADraw 
draw_simple_OCN(OCN_250_T, easyDraw = FALSE) # this will take some seconds

</code></pre>

<hr>
<h2 id='draw_subcatchments_OCN'>Draw subcatchment map from an Optimal Channel Network</h2><span id='topic+draw_subcatchments_OCN'></span>

<h3>Description</h3>

<p>Function that draws a map of subcatchments generated by the aggregation process on the OCN. If <code>theme</code> is <code>NULL</code>, colormap is such that neighbouring subcatchments have distinguished colors. If <code>theme</code> is specified, colors reflect the values of <code>theme</code> across subcatchments, in analogy with <code>draw_thematic_OCN</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>draw_subcatchments_OCN(OCN, theme = NULL, drawRiver = TRUE,
 colPalette = NULL, colLevels = NULL, riverColor = NULL, addLegend = NULL, 
 min_lwd = 0.5, max_lwd = 5, add = FALSE, args_imagePlot = list(), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="draw_subcatchments_OCN_+3A_ocn">OCN</code></td>
<td>
<p>A <code>river</code> object as produced by <code><a href="#topic+aggregate_OCN">aggregate_OCN</a></code>.</p>
</td></tr>
<tr><td><code id="draw_subcatchments_OCN_+3A_theme">theme</code></td>
<td>
<p>Vector (of length <code>OCN$SC$Nnodes</code> expressing the spatial field of interest. </p>
</td></tr>
<tr><td><code id="draw_subcatchments_OCN_+3A_drawriver">drawRiver</code></td>
<td>
<p>Logical. If <code>TRUE</code>, draw the OCN on top of the subcatchment map.</p>
</td></tr>
<tr><td><code id="draw_subcatchments_OCN_+3A_colpalette">colPalette</code></td>
<td>
<p>Color palette used. <code>colPalette</code> accepts both functions creating color palettes and vectors of colors. In the latter case, <code>length(colPalette)</code> must be greater than the number of color levels. If <code>theme = NULL</code>, default is <code>c("#009900", "#FFFF00",  "#FF9900", "#FF0000", "#FF00FF",  "#9900CC", "#555555", "#BBBBBB")</code>. Only the first <code>n</code> colors are used, where <code>n</code> is the number of different colors needed (calculated via a greedy coloring algorithm). <code>colPalette</code> accepts both functions creating color palettes and vectors of colors (see examples); in the latter case, the length of the vector cannot be lower than <code>n</code> (<code>n</code> cannot be predicted a priori, but generally 6 colors should suffice). If <code>theme != NULL</code>, default is <code>colorRampPalette(c("yellow","red","black"))</code>. </p>
</td></tr>
<tr><td><code id="draw_subcatchments_OCN_+3A_collevels">colLevels</code></td>
<td>
<p>Number of colors in the palette (only effective if <code>theme</code> is not null). <code>colLevels</code> must be a vector of the form <code>c(minval, maxval)</code> or <code>c(minval, maxval, N_levels)</code>. The vector of breakpoints used to attribute <code>theme</code> values to a given color is then defined as <code>seq(minval, maxval, N_levels)</code>. Default is <code>minval = min(theme[!(is.nan(theme))])</code>, <code>maxval = max(theme[!(is.nan(theme))])</code>, <code>N_levels = 1000</code>.</p>
</td></tr> 
<tr><td><code id="draw_subcatchments_OCN_+3A_rivercolor">riverColor</code></td>
<td>
<p>Color used to display the OCN (only effective if <code>drawRiver = TRUE</code>). </p>
</td></tr>
<tr><td><code id="draw_subcatchments_OCN_+3A_addlegend">addLegend</code></td>
<td>
<p>Logical. State if a legend should be displayed (only active if <code>theme</code> is not null.</p>
</td></tr>
<tr><td><code id="draw_subcatchments_OCN_+3A_min_lwd">min_lwd</code>, <code id="draw_subcatchments_OCN_+3A_max_lwd">max_lwd</code></td>
<td>
<p>Minimum and maximum values of line width used to display the OCN (actual line width is proportional to the square root of drainage area).</p>
</td></tr>
<tr><td><code id="draw_subcatchments_OCN_+3A_add">add</code></td>
<td>
<p>Logical. If <code>TRUE</code>, add to an already existing plot. Taken as <code>FALSE</code> (with a warning if a different value is supplied) if no graphics device is open.</p>
</td></tr>
<tr><td><code id="draw_subcatchments_OCN_+3A_args_imageplot">args_imagePlot</code></td>
<td>
<p>Only effective if <code>addLegend = TRUE</code>. List of arguments passed to <code><a href="fields.html#topic+imagePlot">imagePlot</a></code> for drawing a continuous legend. For example, argument <code>smallplot</code> can be used to specify the plot coordinates for the legend.</p>
</td></tr>
<tr><td><code id="draw_subcatchments_OCN_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed to <code>image</code>. Default plot options are as in <code>draw_thematic_OCN</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No output is returned.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+draw_thematic_OCN">draw_thematic_OCN</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># 1a) aggregate a 20x20 OCN , use thrA = 5 pixels
# and draw subcatchments with default color palette
OCN &lt;- aggregate_OCN(landscape_OCN(OCN_20), thrA = 5)
draw_subcatchments_OCN(OCN, drawRiver = TRUE)

# 1b) same as above, but define color palette with a function
draw_subcatchments_OCN(OCN, drawRiver = TRUE, colPalette = rainbow)

# 1c) same as above, but define color palette with a vector of colors
draw_subcatchments_OCN(OCN, drawRiver = TRUE, colPalette = hcl.colors(6, "Dark 3"))

# 2) Display theme at subcatchment level
draw_subcatchments_OCN(OCN, theme = OCN$AG$A)
</code></pre>

<hr>
<h2 id='draw_thematic_OCN'>Draw thematic map on an Optimal Channel Network</h2><span id='topic+draw_thematic_OCN'></span>

<h3>Description</h3>

<p>Function that draws OCNs with color of RN or AG nodes depending on an arbitrary theme.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>draw_thematic_OCN(OCN,theme=NA*numeric(OCN$AG$nNodes),
  chooseAggregation = NULL,
  discreteLevels = FALSE, 
  colLevels = NULL, cutoff = FALSE,
  colPalette = colorRampPalette(c("yellow","red","black")),
  exactDraw = FALSE, chooseCM = FALSE, drawNodes = FALSE,  
  nodeType = "upstream",  nanColor = "#00BFFF",
  riverColor = "#00BFFF", backgroundColor = "#999999", 
  addLegend = TRUE, min_lwd = 0.5, max_lwd = 5, 
  add = FALSE, args_imagePlot = list(), args_legend = list(), 
  ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="draw_thematic_OCN_+3A_ocn">OCN</code></td>
<td>
<p>A <code>river</code> object as produced by <code><a href="#topic+aggregate_OCN">aggregate_OCN</a></code>. The order of arguments between <code>OCN</code> and <code>theme</code> can be swapped freely.</p>
</td></tr>
<tr><td><code id="draw_thematic_OCN_+3A_theme">theme</code></td>
<td>
<p>Vector (of length <code>OCN$AG$Nnodes</code> or <code>OCN$RN$Nnodes</code>) expressing the spatial field of interest. 
The vector can contain <code>NA</code> and <code>NaN</code> values to identify RN or AG nodes where the theme is not defined. The order of arguments between <code>OCN</code> and <code>theme</code> can be swapped freely. </p>
</td></tr>
<tr><td><code id="draw_thematic_OCN_+3A_chooseaggregation">chooseAggregation</code></td>
<td>
<p>Only effective if <code>OCN$RN$nNodes == OCN$AG$nNodes</code>. In such case, it must be equal to either <code>"RN"</code> or <code>"AG"</code>; as a result, <code>theme</code> will be interpreted as a spatial field in the corresponding aggregation level. Default is <code>"AG"</code>.</p>
</td></tr>
<tr><td><code id="draw_thematic_OCN_+3A_discretelevels">discreteLevels</code></td>
<td>
<p>Logical. If <code>FALSE</code>, a continuous color scheme is used. If <code>TRUE</code>, discrete color levels are applied. See also <code>colLevels</code> and examples.</p>
</td></tr>
<tr><td><code id="draw_thematic_OCN_+3A_collevels">colLevels</code></td>
<td>
<p>Number of colors in the palette. If <code>discreteLevels == FALSE</code>, <code>colLevels</code> must be a vector of the form <code>c(minval, maxval)</code> or <code>c(minval, maxval, N_levels)</code>. The vector of breakpoints used to attribute <code>theme</code> values to a given color is then defined as <code>seq(minval, maxval, N_levels)</code>. Default is <code>minval = min(theme[!(is.nan(theme))])</code>, <code>maxval = max(theme[!(is.nan(theme))])</code>, <code>N_levels = 1000</code>. If <code>discreteLevels == TRUE</code> and <code>is.null(colLevels) == TRUE</code>, each unique value of <code>theme</code> is attributed a different color. If <code>discreteLevels == TRUE</code> and <code>colLevels</code> is a vector, <code>colLevels</code> is used as vector of breakpoints. In this case, the number of discrete colors is equal to <code>length(colLevels) - 1</code>.</p>
</td></tr> 
<tr><td><code id="draw_thematic_OCN_+3A_cutoff">cutoff</code></td>
<td>
<p>Logical. If <code>FALSE</code>, nodes whose <code>theme</code> value is beyond the range established by the vector of breakpoints are attributed the color corresponding to the lowest (or highest) value in the color scheme. If <code>TRUE</code>, such nodes are attributed the color <code>NaNcolor</code>.</p>
</td></tr>
<tr><td><code id="draw_thematic_OCN_+3A_colpalette">colPalette</code></td>
<td>
<p>Color palette used to display theme values. <code>colPalette</code> accepts both functions creating color palettes and vectors of colors. In the latter case, <code>length(colPalette)</code> must be greater than the number of color levels. See examples below and <code><a href="grDevices.html#topic+hcl.colors">hcl.colors</a></code>.</p>
</td></tr>
<tr><td><code id="draw_thematic_OCN_+3A_choosecm">chooseCM</code></td>
<td>
<p>Index of catchment to display (only effective if <code>OCN$nOutlet &gt; 1</code>). It can be a logical or a numeric vector. If <code>FALSE</code>, all catchments are displayed. If <code>TRUE</code>, the catchment with largest area is displayed. If <code>chooseCM</code> is a subset of vector <code>1:length(OCN$nOutlet)</code>, only the catchment(s) identified by the indices in <code>chooseCM</code> are displayed.</p>
</td></tr>
<tr><td><code id="draw_thematic_OCN_+3A_exactdraw">exactDraw</code></td>
<td>
<p>Logical. If <code>TRUE</code>, the real shape of OCNs is plotted. If flow crosses a boundary, the pixel that is not contiguous to its outlet is flipped.</p>
</td></tr>
<tr><td><code id="draw_thematic_OCN_+3A_drawnodes">drawNodes</code></td>
<td>
<p>Logical. If <code>FALSE</code>, the theme is directly displayed on the river network. In this case, the edge departing from a given node is displayed with the color attributed to the node. If <code>TRUE</code>, the theme is displayed via markers at the locations of the nodes at the RN or AG level (depending on the length of <code>theme</code>).
In this case, <code>nanColor</code> can be used to define the color of the river network.</p>
</td></tr>
<tr><td><code id="draw_thematic_OCN_+3A_nodetype">nodeType</code></td>
<td>
<p>Only effective if <code>drawNodes == TRUE</code> and <code>length(theme) == OCN$RN$nNodes</code>. Can assume values <code>"upstream"</code> or <code>"downstream"</code>. If <code>"upstream"</code>, nodes are drawn at the upstream ends of the corresponding edges (i.e. at the coordinates defined by <code>OCN$AG$X</code>, <code>OCN$AG$Y</code>). If <code>"downstream"</code>, nodes are drawn at the downstream ends of the corresponding edges (i.e. at the coordinates defined by <code>OCN$AG$XReach</code>, <code>OCN$AG$YReach</code>).</p>
</td></tr>
<tr><td><code id="draw_thematic_OCN_+3A_nancolor">nanColor</code></td>
<td>
<p>Color attributed to RN or AG nodes whose theme value is <code>NA</code> or <code>NaN</code>.</p>
</td></tr>
<tr><td><code id="draw_thematic_OCN_+3A_rivercolor">riverColor</code></td>
<td>
<p>Only effective if <code>drawNodes == TRUE</code>. Color used to display the OCN below the nodes.</p>
</td></tr>
<tr><td><code id="draw_thematic_OCN_+3A_backgroundcolor">backgroundColor</code></td>
<td>
<p>Color used in the background of the figure. It can be either a single value, or a vector with number of components 
equal to <code>length(chooseCM)</code>. If <code>length(backgroundColor) == length(chooseCM)</code>, each color is used to identify a different catchment selected in <code>chooseCM</code>
(corresponding to the respective outlet). If instead <code>length(chooseCM) &gt; 1</code> and <code>length(backgroundColor) == 1</code>, all catchments are colored with the same 
<code>backgroundColor</code>.</p>
</td></tr>
<tr><td><code id="draw_thematic_OCN_+3A_addlegend">addLegend</code></td>
<td>
<p>Logical. If <code>TRUE</code>, add legend to the plot. If also <code>discreteLevels = FALSE</code>, <code><a href="fields.html#topic+image.plot">image.plot</a></code> is used to display the legend, which appears as a colorbar; as a result, elements (e.g. node coordinates) subsequently plotted of on top of the 2D elevation map might be wrongly positioned. </p>
</td></tr>
<tr><td><code id="draw_thematic_OCN_+3A_min_lwd">min_lwd</code>, <code id="draw_thematic_OCN_+3A_max_lwd">max_lwd</code></td>
<td>
<p>Minimum and maximum values of line width used to display the OCN (actual line width is proportional to the square root of drainage area).</p>
</td></tr>
<tr><td><code id="draw_thematic_OCN_+3A_add">add</code></td>
<td>
<p>Logical. If <code>TRUE</code>, add to an already existing plot. Taken as <code>FALSE</code> (with a warning if a different value is supplied) if no graphics device is open.</p>
</td></tr>
<tr><td><code id="draw_thematic_OCN_+3A_args_imageplot">args_imagePlot</code></td>
<td>
<p>Only effective if <code>addLegend = TRUE</code> and <code>discreteLevels = FALSE</code>. List of arguments passed to <code><a href="fields.html#topic+imagePlot">imagePlot</a></code> for drawing a continuous legend. For example, argument <code>smallplot</code> can be used to specify the plot coordinates for the legend.</p>
</td></tr>
<tr><td><code id="draw_thematic_OCN_+3A_args_legend">args_legend</code></td>
<td>
<p>Only effective if <code>addLegend = TRUE</code> and <code>discreteLevels = TRUE</code>. List of arguments passed to <code><a href="graphics.html#topic+legend">legend</a></code> for drawing a discrete legend.</p>
</td></tr>
<tr><td><code id="draw_thematic_OCN_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed to <code>plot</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function can be used to show how a certain spatial field varies along the river network.
</p>
<p><em>Default plot options.</em> By default, it is set <code>asp = 1</code>, <code>xlab = ""</code>, <code>ylab = ""</code>. If at least one between <code>xlim</code> and <code>ylim</code> is specified by the user, the default for <code>axes</code> is <code>TRUE</code>, and is <code>FALSE</code> if not. Specifying <code>xlim</code> and <code>ylim</code> helps zoom into a portion of the river network; however, due to the default <code>asp = 1</code>, the displayed region might be larger than what is expected if the ranges of <code>xlim</code> and <code>ylim</code> are different. To avoid this, set <code>asp = NA</code> (at the cost of producing a deformed river network).
</p>
<p><em>Adding scale bar and north arrow.</em> Scale bar and north arrow can be added via <code>terra</code>'s functions <code><a href="terra.html#topic+sbar">sbar</a></code> and <code><a href="terra.html#topic+north">north</a></code>, respectively. However, note that arguments <code>d</code> and <code>xy</code> must be specified by the user (because no <code>rast</code> object is plotted). See example 5.
</p>


<h3>Value</h3>

<p>No output is returned.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># 1a) Six different ways to display contributing area at the AG level
OCN &lt;- aggregate_OCN(landscape_OCN(OCN_20), thrA = 4)
old.par &lt;- par(no.readonly = TRUE)
par(mfrow=c(2,3), oma = c(0, 0, 3, 0))
draw_thematic_OCN(OCN$AG$A, OCN, colPalette = hcl.colors) 
title("Continuous levels \n Colors on edges")
draw_thematic_OCN(OCN$AG$A, OCN, discreteLevels = TRUE,
		colPalette = hcl.colors) 
title("Discrete, unique levels \n Colors on edges")
draw_thematic_OCN(OCN$AG$A, OCN, discreteLevels = TRUE, 
		colLevels = c(1, 10, 50, 100, 500), 
		colPalette = hcl.colors) 
title("Discrete, user-defined levels \n Colors on edges")
draw_thematic_OCN(OCN$AG$A, OCN, drawNodes = TRUE, 
		colPalette = hcl.colors)
title("Continuous levels \n Colors on edges")
draw_thematic_OCN(OCN$AG$A, OCN,  discreteLevels = TRUE, 
		drawNodes = TRUE, colPalette = hcl.colors)
title("Discrete, unique levels \n Colors on nodes")
draw_thematic_OCN(OCN$AG$A, OCN, discreteLevels = TRUE, 
		drawNodes = TRUE, colLevels = c(1, 10, 50, 100, 500), 
		colPalette = hcl.colors)
title("Discrete, user-defined levels \n Colors on nodes")
mtext("Six different ways to display contributing area [no. pixels]", outer = TRUE, cex = 1.5)
par(old.par)

# 1b) Same as above, but use different colLevels, cutoff combinations
# with DiscreteLevels = FALSE
old.par &lt;- par(no.readonly = TRUE)
par(mfrow=c(1,2))
draw_thematic_OCN(OCN$AG$A, OCN, drawNodes = TRUE,
		 colLevels = c(0, 200, 1000), colPalette = hcl.colors)
title("All nodes with A &gt; 200 pixels \n are displayed in yellow")
draw_thematic_OCN(OCN$AG$A, OCN, drawNodes = TRUE, 
		nanColor = "#00000000", colLevels = c(0, 200, 1000),
		cutoff = TRUE, colPalette = hcl.colors)
title("All nodes with A &gt; 200 pixels \n are treated as NaN")		
par(old.par)

## Not run: 
# 2) Display distance to outlet (at the RN level) along the main stem
# of an OCN
OCN &lt;- aggregate_OCN(landscape_OCN(OCN_250_T)) # this takes some seconds
OCN &lt;- paths_OCN(OCN, includePaths = TRUE) # this takes some seconds

distanceToOutlet &lt;- OCN$RN$downstreamPathLength[,OCN$RN$outlet]
farthestNode &lt;- which(distanceToOutlet == max(distanceToOutlet))
mainStem &lt;- OCN$RN$downstreamPath[[farthestNode]][[OCN$RN$outlet]]
theme &lt;- rep(NaN, OCN$RN$nNodes)
theme[mainStem] &lt;- distanceToOutlet[mainStem]

draw_thematic_OCN(theme, OCN)
title("Distance to outlet along the main stem [pixel units]")

## End(Not run)

# 3) Show an OCN without a theme
OCN &lt;- aggregate_OCN(landscape_OCN(OCN_20), thrA = 4)
draw_thematic_OCN(OCN)
draw_thematic_OCN(OCN, xlim=c(3,8), ylim=c(0,5)) # zoom closer at the outlet

# 4) Adjust legend location
draw_thematic_OCN(OCN, OCN$AG$A, 
	args_imagePlot = list(smallplot = c(0.1, 0.11, 0.1, 0.3)))
draw_thematic_OCN(OCN, OCN$AG$streamOrder, 
	discreteLevels = TRUE, args_legend = list(x = -2, y = 1))

# 5) add thematic OCN on top of map and show scale bar and north arrow
draw_elev2D_OCN(OCN)
draw_thematic_OCN(OCN, OCN$AG$slope, backgroundColor = NULL, 
add = TRUE, colPalette = hcl.colors(1000, "Grays", rev = TRUE),
args_imagePlot = list(smallplot=c(0.05,0.07,0.1,0.9)))
# now add scale bar and north arrow
library(terra)
# sbar() # this would throw an error
# north()# this would throw an error
sbar(d=1, xy=c(min(OCN$FD$X), min(OCN$FD$Y)-1)) # this works
north(d=1, xy=c(max(OCN$FD$X)+1, max(OCN$FD$Y))) # this works
</code></pre>

<hr>
<h2 id='find_area_threshold_OCN'>Find relationship between number of nodes and threshold area in an OCN</h2><span id='topic+find_area_threshold_OCN'></span>

<h3>Description</h3>

<p>Function that calculates relationship between threshold area and number of nodes at RN and AG level for a given OCN. 
It can be used prior to application of <code><a href="#topic+aggregate_OCN">aggregate_OCN</a></code> in order to derive the drainage area threshold 
that corresponds to the desired number of nodes of the aggregated network.
It is intended for use with single outlet OCNs, although its use with multiple outlet OCNs is allowed (provided that <code>max(thrValues) &lt;= min(OCN$CM$A)</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find_area_threshold_OCN(OCN, thrValues = seq(OCN$cellsize^2,
  min(OCN$CM$A), OCN$cellsize^2), maxReachLength = Inf,
  streamOrderType = "Strahler", displayUpdates = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="find_area_threshold_OCN_+3A_ocn">OCN</code></td>
<td>
<p>A <code>river</code> object as produced by <code><a href="#topic+landscape_OCN">landscape_OCN</a></code></p>
</td></tr>
<tr><td><code id="find_area_threshold_OCN_+3A_thrvalues">thrValues</code></td>
<td>
<p>Vector of values of threshold drainage area (in squared planar units) for which the respective number of nodes at the RN and AG levels are computed. 
Note that it must be <code>max(thrValues) &lt;= min(OCN$CM$A)</code>, otherwise the catchment(s) with area lower than <code>max(thrValues)</code> degenerate to a network with zero nodes at the RN/AG level.</p>
</td></tr>
<tr><td><code id="find_area_threshold_OCN_+3A_maxreachlength">maxReachLength</code></td>
<td>
<p>Maximum reach length allowed (in planar units). If the path length between a channel head and the downstream confluence 
is higher than <code>maxReachLength</code>, the reach starting from the channel head will have a length up to <code>maxReachLength</code>, while the next downstream 
pixel is considered as a new channel head, from which a new reach departs.</p>
</td></tr>
<tr><td><code id="find_area_threshold_OCN_+3A_streamordertype">streamOrderType</code></td>
<td>
<p>If <code>"Strahler"</code>, Strahler stream order is computed; if <code>"Shreve"</code>, Shreve stream order is computed.</p>
</td></tr>
<tr><td><code id="find_area_threshold_OCN_+3A_displayupdates">displayUpdates</code></td>
<td>
<p>If <code>1</code>, progress updates are printed in the console while the function is running. If <code>0</code>, no updates are printed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list whose objects are listed below.
</p>
<table>
<tr><td><code>thrValues</code></td>
<td>
<p>Copy of the input vector with the same name.</p>
</td></tr>
<tr><td><code>nNodesRN</code></td>
<td>
<p>Vector (of the same length as <code>thrValues</code>) of number of nodes at the RN level resulting from the aggregation process 
with a threshold area values specified by <code>thrValues</code>.</p>
</td></tr>
<tr><td><code>nNodesAG</code></td>
<td>
<p>Vector (of the same length as <code>thrValues</code>) of number of nodes at the AG level resulting from the aggregation process 
with a threshold area values specified by <code>thrValues</code>.</p>
</td></tr>
<tr><td><code>drainageDensity</code></td>
<td>
<p>Vector (of the same length as <code>thrValues</code>) of values of drainage density of the river network 
resulting from the aggregation process with a threshold area values specified by <code>thrValues</code>. Drainage density is calculated 
as total length of the river network divided by area of the lattice. It is expressed in planar units^(-1).</p>
</td></tr>
<tr><td><code>streamOrder</code></td>
<td>
<p>Vector (of the same length as <code>thrValues</code>) of values of maximum stream order attained by the river network, 
resulting from the aggregation process with a threshold area values specified by <code>thrValues</code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># 1) derive relationship between threshold area and number of nodes
OCN &lt;- landscape_OCN(OCN_20)
thr &lt;- find_area_threshold_OCN(OCN)
# log-log plot of number of nodes at the AG level versus 
# relative threshold area (as fraction of total drainage area) 
old.par &lt;- par(no.readonly = TRUE)
par(mai = c(1,1,1,1))  
plot(thr$thrValues[thr$nNodesAG &gt; 0]/OCN$CM$A,
		thr$nNodesAG[thr$nNodesAG &gt; 0], log = "xy",
		xlab = "Relative area threshold", ylab = "Number of AG nodes")
par(old.par)
</code></pre>

<hr>
<h2 id='flowDir'>Example of initial flow direction matrix to be used as input in <code>create_general_contour_OCN</code>.</h2><span id='topic+flowDir'></span>

<h3>Description</h3>

<p>An arbitrary initial flow direction matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(flowDir)
</code></pre>


<h3>Format</h3>

<p>A matrix. See <code><a href="#topic+create_general_contour_OCN">create_general_contour_OCN</a></code> documentation for details.</p>

<hr>
<h2 id='landscape_OCN'>Generate 3D landscape from an Optimal Channel Network</h2><span id='topic+landscape_OCN'></span>

<h3>Description</h3>

<p>Function that calculates the elevation field generated by the OCN and the partition of the domain into different catchments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>landscape_OCN(OCN, slope0 = 1, zMin = 0, optimizeDZ = FALSE,
  optimMethod = "BFGS", optimControl = list(maxit = 100 *
  length(OCN$FD$outlet), trace = 1), displayUpdates = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="landscape_OCN_+3A_ocn">OCN</code></td>
<td>
<p>A <code>river</code> object as produced by <code><a href="#topic+create_OCN">create_OCN</a></code>.</p>
</td></tr>
<tr><td><code id="landscape_OCN_+3A_slope0">slope0</code></td>
<td>
<p>slope of the outlet pixel (in elevation units/planar units).</p>
</td></tr>
<tr><td><code id="landscape_OCN_+3A_zmin">zMin</code></td>
<td>
<p>Elevation of the lowest pixel (in elevation units).</p>
</td></tr>
<tr><td><code id="landscape_OCN_+3A_optimizedz">optimizeDZ</code></td>
<td>
<p>If <code>TRUE</code>, when there are multiple catchments, minimize differences in elevation at the catchment borders 
by lifting catchments, while respecting <code>zMin</code>. If <code>FALSE</code>, all outlet pixels have elevation equal to <code>zMin</code>. 
This option is not effective for OCNs generated via <code><a href="#topic+create_general_contour_OCN">create_general_contour_OCN</a></code>.</p>
</td></tr>
<tr><td><code id="landscape_OCN_+3A_optimmethod">optimMethod</code></td>
<td>
<p>Optimization method used by function <code><a href="stats.html#topic+optim">optim</a></code> (only used if <code>optimizeDZ = TRUE</code>).</p>
</td></tr>
<tr><td><code id="landscape_OCN_+3A_optimcontrol">optimControl</code></td>
<td>
<p>List of control parameters used by function <code><a href="stats.html#topic+optim">optim</a></code> (only used if <code>optimizeDZ = TRUE</code>).</p>
</td></tr>
<tr><td><code id="landscape_OCN_+3A_displayupdates">displayUpdates</code></td>
<td>
<p>State if updates are printed on the console while <code>landscape_OCN</code> runs.
</p>

<dl>
<dt><code>0</code></dt><dd><p>No update is given.</p>
</dd>
<dt><code>1</code></dt><dd><p>Concise updates are given.</p>
</dd>
<dt><code>2</code></dt><dd><p>More extensive updates are given (this might slow down the total function runtime).</p>
</dd>
</dl>

<p>Note that the display of updates during optimization of elevations (when <code>optimizeDZ = TRUE</code>) is controlled by parameter <code>optimControl$trace</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function features an algorithm (which can be activated via the optional input <code>optimizeDZ</code>) that, given the network 
configuration and a <code>slope0</code> value, finds the elevation of <code>OCN$nOutlet - 1</code> outlets relative to the elevation of the first 
outlet in vectors <code>outletSide</code>, <code>outletPos</code> such that the sum of the absolute differences elevation of neighboring pixels
belonging to different catchments is minimized. Such objective function is minimized by means of function <code><a href="stats.html#topic+optim">optim</a></code>. 
The absolute elevation of the outlet pixels (and, consequently, of the whole lattice) is finally attributed by imposing 
<code>OCN$FD$Z &gt;= zMin</code>. Note that, due to the high dimensionality of the problem, convergence of the 
optimization algorithm is not guaranteed for large <code>OCN$nOutlet</code> (say, <code>OCN$nOutlet &gt; 10</code>).
</p>


<h3>Value</h3>

<p>A <code>river</code> object that contains all objects contained in <code>OCN</code>, in addition to the objects listed below. 
A new sublist <code>CM</code>, containing variables at the catchment aggregation levels, is created.
</p>
<table>
<tr><td><code>FD$slope</code></td>
<td>
<p>Vector (of length <code>OCN$FD$nNodes</code>) of slope values (in elevation units/planar units) 
for each FD pixel, as derived by the slope/area relationship.</p>
</td></tr>
<tr><td><code>FD$leng</code></td>
<td>
<p>Vector (of length <code>OCN$FD$nNodes</code>) of pixel lengths. <code>OCN$FD$leng[i] = OCN$FD$cellsize</code> 
if flow direction in <code>i</code> is horizontal or vertical; <code>OCN$FD$leng[i] = OCN$FD$cellsize*sqrt(2)</code> if flow direction in <code>i</code> is diagonal.</p>
</td></tr>  
<tr><td><code>FD$toCM</code></td>
<td>
<p>Vector (of length <code>OCN$FD$nNodes</code>) with catchment index values for each FD pixel. 
Example: <code>OCN$FD$toCM[i] = j</code> if pixel <code>i</code> drains into the outlet whose location is defined by 
<code>outletSide[j]</code>, <code>outletPos[j]</code>.</p>
</td></tr> 
<tr><td><code>FD$XDraw</code></td>
<td>
<p>When <code>periodicBoundaries = TRUE</code>, it is a vector (of length <code>OCN$FD$nNodes</code>) with real X coordinate of FD pixels. 
If <code>periodicBoundaries = FALSE</code>, it is equal to <code>OCN$FD$X</code>.</p>
</td></tr>
<tr><td><code>FD$YDraw</code></td>
<td>
<p>When <code>periodicBoundaries = TRUE</code>, it is a vector (of length <code>OCN$FD$nNodes</code>) with real Y coordinate of FD pixels. 
If <code>periodicBoundaries = FALSE</code>, it is equal to <code>OCN$FD$Y</code>.</p>
</td></tr>
<tr><td><code>FD$Z</code></td>
<td>
<p>Vector (of length <code>OCN$FD$nNodes</code>) of elevation values for each FD pixel. Values are calculated by consecutive implementation 
of the slope/area relationship along upstream paths.</p>
</td></tr>
<tr><td><code>CM$A</code></td>
<td>
<p>Vector (of length <code>OCN$nOutlet</code>) with values of drainage area (in square planar units) for each of the catchments 
identified by the corresponding <code>OCN$FD$outlet</code>.</p>
</td></tr>
<tr><td><code>CM$W</code></td>
<td>
<p>Adjacency matrix (<code>OCN$nOutlet</code> by <code>OCN$nOutlet</code>) at the catchment level. Two catchments are connected 
if they share a border. Note that this is not a flow connection. Unlike the adjacency matrices at levels FD, RN, AG, this matrix is symmetric. 
It is a <code><a href="spam.html#topic+spam">spam</a></code> object.</p>
</td></tr>
<tr><td><code>CM$XContour (CM$Y_contour)</code></td>
<td>
<p>List with number of objects equal to <code>OCN$FD$nOutlet</code>. Each object <code>i</code> is a list 
with X (Y) coordinates of the contour of catchment <code>i</code> for use in plots with <code>exactDraw = FALSE</code> (see functions <code><a href="#topic+draw_contour_OCN">draw_contour_OCN</a></code>, 
<code><a href="#topic+draw_thematic_OCN">draw_thematic_OCN</a></code>). If catchment <code>i</code> is constituted by regions that are only connected through a diagonal flow direction, 
<code>CM$XContour[[i]]</code> (<code>CM$Y_contour[[i]]</code>) contains as many objects as the number of regions into which catchment <code>i</code> is split.</p>
</td></tr> 
<tr><td><code>CM$XContourDraw (CM$YContourDraw)</code></td>
<td>
<p>List with number of objects equal to <code>OCN$FD$nOutlet</code>. Each object <code>i</code> is a list 
with X (Y) coordinates of the contour of catchment <code>i</code> for use in plots with <code>exactDraw = TRUE</code> (see functions <code><a href="#topic+draw_contour_OCN">draw_contour_OCN</a></code>, 
<code><a href="#topic+draw_thematic_OCN">draw_thematic_OCN</a></code>). If catchment <code>i</code> is constituted by regions that are only connected through a diagonal flow direction, 
<code>CM$XContourDraw[[i]]</code> (<code>CM$YContourDraw[[i]]</code>) contains as many objects as the number of regions into which catchment <code>i</code> is split.</p>
</td></tr>
<tr><td><code>OptList</code></td>
<td>
<p>List of output parameters produced by the optimization function <code><a href="stats.html#topic+optim">optim</a></code> (only present if <code>optimizeDZ = TRUE</code>).</p>
</td></tr>
</table>
<p>Finally, <code>slope0</code> and <code>zMin</code> are passed to the <code>river</code> as they were included in the input.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># 1) draw 2D elevation map of a 20x20 OCN with default options
OCN2 &lt;- landscape_OCN(OCN_20)

## Not run: 
# 2) generate a 100x50 OCN; assume that the pixel resolution is 200 m
# (the total catchment area is 20 km2)
set.seed(1)
OCN &lt;- create_OCN(100, 50, cellsize = 200, 
		displayUpdates = 0) # this takes about 40 s
# use landscape_OCN to derive the 3D landscape subsumed by the OCN
# by assuming that the elevation and slope at the outlet are 200 m 
# and 0.0075, respectively
OCN &lt;- landscape_OCN(OCN, zMin = 200, slope0 = 0.0075)
# draw 2D and 3D representations of the landscape
draw_elev2D_OCN(OCN)
draw_elev3D_OCN(OCN)
draw_elev3Drgl_OCN(OCN)

## End(Not run)

## Not run: 
# 3) generate a 100x50 OCN with 4 outlets
set.seed(1)
OCN &lt;- create_OCN(100, 50, cellsize = 200, 
		nOutlet = 4, displayUpdates = 0) # this takes about 40 s
# use landscape_OCN and optimize elevation of outlets	
OCN &lt;- landscape_OCN(OCN, slope0 = 0.0075, 
		optimizeDZ = TRUE)
# display elevation of outlets and 2D elevation map
OCN$FD$Z[OCN$FD$outlet]	
draw_elev2D_OCN(OCN)	

## End(Not run)
</code></pre>

<hr>
<h2 id='OCN_20'>Example of small OCN</h2><span id='topic+OCN_20'></span>

<h3>Description</h3>

<p>A network built on a 20x20 lattice obtained by executing <code>set.seed(1); create_OCN(20,20)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(OCN_20)
</code></pre>


<h3>Format</h3>

<p>A <code>river</code> object. See <code><a href="#topic+create_OCN">create_OCN</a></code> documentation for details.</p>

<hr>
<h2 id='OCN_250_PB'>Example of single-outlet OCN with periodic boundaries</h2><span id='topic+OCN_250_PB'></span>

<h3>Description</h3>

<p>A network built on a 250x250 lattice obtained by executing <code>set.seed(2); create_OCN(250, 250, periodicBoundaries = TRUE)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(OCN_250_PB)
</code></pre>


<h3>Format</h3>

<p>A <code>river</code> object. See <code><a href="#topic+create_OCN">create_OCN</a></code> documentation for details.</p>

<hr>
<h2 id='OCN_250_T'>Example of single-outlet OCN</h2><span id='topic+OCN_250_T'></span>

<h3>Description</h3>

<p>A network built on a 250x250 lattice obtained by executing <code>set.seed(2); create_OCN(250, 250, typeInitialState = "T")</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(OCN_250_T)
</code></pre>


<h3>Format</h3>

<p>A <code>river</code> object. See <code><a href="#topic+create_OCN">create_OCN</a></code> documentation for details.</p>

<hr>
<h2 id='OCN_300_4out'>Example of multiple-outlet OCN</h2><span id='topic+OCN_300_4out'></span>

<h3>Description</h3>

<p>A network built on a 300x300 lattice obtained by executing <code>set.seed(5); create_OCN(300, 300, nOutlet = 4, outletSide = c("S", "N", "W", "E"), outletPos = c(1, 300, 149, 150), typeInitialState = "V", cellsize = 50)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(OCN_300_4out)
</code></pre>


<h3>Format</h3>

<p>A <code>river</code> object. See <code><a href="#topic+create_OCN">create_OCN</a></code> documentation for details.</p>

<hr>
<h2 id='OCN_300_4out_PB_hot'>Example of multiple-outlet OCN with periodic boundaries</h2><span id='topic+OCN_300_4out_PB_hot'></span>

<h3>Description</h3>

<p>A network built on a 300x300 lattice obtained by executing <code>set.seed(5); create_OCN(300, 300, nOutlet = 4, outletSide = c("S", "N", "W", "E"), outletPos = c(1, 300, 149, 150), typeInitialState = "V", periodicBoundaries = TRUE, cellsize = 50, coolingRate = 0.5, initialNoCoolingPhase = 0.1)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(OCN_300_4out_PB_hot)
</code></pre>


<h3>Format</h3>

<p>A <code>river</code> object. See <code><a href="#topic+create_OCN">create_OCN</a></code> documentation for details.</p>

<hr>
<h2 id='OCN_4'>Example of small OCN</h2><span id='topic+OCN_4'></span>

<h3>Description</h3>

<p>A network built on a 4x4 lattice for illustrative purposes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(OCN_4)
</code></pre>


<h3>Format</h3>

<p>A <code>river</code> object. See <code><a href="#topic+create_OCN">create_OCN</a></code> documentation for details.</p>


<h3>Details</h3>

<p>Despite its name, this network is not an OCN: indeed, it has been generated manually and not via <code><a href="#topic+create_OCN">create_OCN</a></code>.
</p>

<hr>
<h2 id='OCN_400_Allout'>Example of OCN with all perimetric pixels as outlets</h2><span id='topic+OCN_400_Allout'></span>

<h3>Description</h3>

<p>A network built on a 400x400 lattice obtained by executing <code>set.seed(8); create_OCN(400, 400, nOutlet = "All", cellsize = 50)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(OCN_400_Allout)
</code></pre>


<h3>Format</h3>

<p>A <code>river</code> object. See <code><a href="#topic+create_OCN">create_OCN</a></code> documentation for details.</p>

<hr>
<h2 id='OCN_to_AEM'>Construct asymmetric eigenvector maps (AEM) from an OCN</h2><span id='topic+OCN_to_AEM'></span>

<h3>Description</h3>

<p>Function that computes asymmetric eigenvector maps from an OCN. These can be used as spatial variables
to assess spatial gradients in environmental or ecological data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>OCN_to_AEM(OCN, level = "AG", weight = NULL, resistance = "length", moranI = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="OCN_to_AEM_+3A_ocn">OCN</code></td>
<td>
<p>A <code>river</code> object as produced by <code><a href="#topic+aggregate_OCN">aggregate_OCN</a></code>.</p>
</td></tr>
<tr><td><code id="OCN_to_AEM_+3A_level">level</code></td>
<td>
<p>Aggregation level at which AEMs are to be calculated. It 
must be equal to either <code>"RN"</code> or <code>"AG"</code>.</p>
</td></tr>
<tr><td><code id="OCN_to_AEM_+3A_weight">weight</code></td>
<td>
<p>Determines how and if weights should be used to compute the AEMs.
Defaults to <code>NULL</code>, which applies equal weights to all links of the OCN. It can
be one of <code>"gravity"</code>, <code>"exponential"</code>, <code>"linear"</code>, <code>"parabolic"</code>
or a user-specified function. See details.</p>
</td></tr> 
<tr><td><code id="OCN_to_AEM_+3A_resistance">resistance</code></td>
<td>
<p>Identifies how resisitance (i.e., the variable negatively related to 
the link weight) is calculated. Defaults to <code>"length"</code> (i.e., resistance equal to link length).
Alternatively, <code>resistance = "time"</code> uses water travel time to weigh the links.
In such a case, water velocities must be contained in the <code>OCN</code> (e.g. via 
<code><a href="#topic+rivergeometry_OCN">rivergeometry_OCN</a></code>).</p>
</td></tr>
<tr><td><code id="OCN_to_AEM_+3A_morani">moranI</code></td>
<td>
<p>Logical. Should Moran's I statistics be computed and random tests be performed via 
<code><a href="adespatial.html#topic+moran.randtest">moran.randtest</a></code>? 
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Possible character strings for <code>weight</code> are:
</p>

<dl>
<dt><code>"gravity"</code></dt><dd><p><code class="reqn">w(r) = r_{max}/r</code></p>
</dd>
<dt><code>"exponential"</code></dt><dd><p><code class="reqn">w(r) = \exp(-r/r_{max})</code></p>
</dd>
<dt><code>"linear"</code></dt><dd><p><code class="reqn">w(r) = 1 - r/r_{max}</code></p>
</dd>
<dt><code>"parabolic"</code></dt><dd><p><code class="reqn">w(r) = 1 - (r/r_{max})^2</code></p>
</dd>
</dl>
<p>where <code class="reqn">w</code> is the weight value for a given link, <code class="reqn">r</code> its resistance value and <code class="reqn">r_{max}</code> the maximum resistance value across all links.

</p>


<h3>Value</h3>

<p>A list as produced by a call to <code><a href="adespatial.html#topic+aem">aem</a></code>. If <code>moranI = TRUE</code>, a <code>krandtest</code> resulting from
the call to <code>moran.randtest</code> is appended to the output list.
</p>


<h3>See Also</h3>

<p><code><a href="adespatial.html#topic+aem">aem</a></code>, <code><a href="adespatial.html#topic+moran.randtest">moran.randtest</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>OCN &lt;- aggregate_OCN(landscape_OCN(OCN_20), thrA = 5)

res &lt;- OCN_to_AEM(OCN) # unweighted AEMs
res$values # eigenvectors associates with the AEMs
plot(OCN, res$vectors[,1], drawNodes = TRUE, 
colLevels = c(-max(abs(res$vectors[,1])), max(abs(res$vectors[,1])), 100), 
	colPalette = hcl.colors(100,"Blue-Red 2")) # plot first eigenvector

res_g &lt;- OCN_to_AEM(OCN, weight = "gravity") # weighted AEMs based on gravity model

fn &lt;- function(r) {1 - r^0.5} 
res_f &lt;- OCN_to_AEM(OCN, weight = fn) # weighted AEMs based on user-specified weight function

# compute Moran's I and perform permutation test to assess which eigenfunctions should be retained

res_g &lt;- OCN_to_AEM(OCN, weight = "gravity", moranI = TRUE)
selectedAEM &lt;- which(res_g$moranI$pvalue &lt; 0.05) 
# selected eigenfunctions are those with significantly positive spatial autocorrelation

# plot selected eigenfunctions 
# (these could be e.g. used as spatial covariates in a species distribution model)
par(mfrow=c(3,4))
for (i in selectedAEM){
plot(OCN, res$vectors[,i], drawNodes = TRUE, 
	colLevels = c(-max(abs(res$vectors[,i])), max(abs(res$vectors[,i])), 100), 
	colPalette = hcl.colors(100,"Blue-Red 2"))
	title(paste0("AEM",i))
	}

</code></pre>

<hr>
<h2 id='OCN_to_igraph'>Transform OCN into igraph object</h2><span id='topic+OCN_to_igraph'></span>

<h3>Description</h3>

<p>Function that transforms an OCN into an igraph object. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>OCN_to_igraph(OCN, level)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="OCN_to_igraph_+3A_ocn">OCN</code></td>
<td>
<p>A <code>river</code> object as produced by <code><a href="#topic+aggregate_OCN">aggregate_OCN</a></code>.</p>
</td></tr>
<tr><td><code id="OCN_to_igraph_+3A_level">level</code></td>
<td>
<p>Aggregation level at which the OCN is converted into an igraph object. It 
must be equal to either <code>"FD"</code>, <code>"RN"</code> or <code>"AG"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code>igraph</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># 1) transform a 20x20 OCN, at the AG level, into a graph object 
OCN &lt;- aggregate_OCN(landscape_OCN(OCN_20), thrA = 4)
g &lt;- OCN_to_igraph(OCN, level = "AG")
plot(g, layout = matrix(c(OCN$AG$X,OCN$AG$Y), ncol = 2, nrow = OCN$AG$nNodes))
</code></pre>

<hr>
<h2 id='OCN_to_SSN'>Transform OCN into SSN object (disabled)</h2><span id='topic+OCN_to_SSN'></span>

<h3>Description</h3>

<p>In <code>OCNet</code> v1.2.0, this function is disabled following the archiving 
of the <code>SSN</code> package from CRAN (due to the retirement of <code>rgdal</code>). 
A new <code>OCN_to_SSN</code> function will be included in the next release of <code>OCNet</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>OCN_to_SSN(OCN, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="OCN_to_SSN_+3A_ocn">OCN</code></td>
<td>
<p>A <code>river</code> object.</p>
</td></tr>
<tr><td><code id="OCN_to_SSN_+3A_...">...</code></td>
<td>
<p>Further arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No output is produced.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>OCN_to_SSN(OCN)
</code></pre>

<hr>
<h2 id='paths_OCN'>Calculate paths between nodes in an Optimal Channel Network</h2><span id='topic+paths_OCN'></span>

<h3>Description</h3>

<p>Function that determines upstream and downstream paths and path lengths between any nodes of the network at the aggregated level.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>paths_OCN(OCN, level = c("RN","AG"), whichNodes = NULL, includePaths = FALSE, 
includeDownstreamNode = FALSE, includeUnconnectedPaths = FALSE, displayUpdates = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="paths_OCN_+3A_ocn">OCN</code></td>
<td>
<p>A <code>river</code> object as produced by <code><a href="#topic+aggregate_OCN">aggregate_OCN</a></code>.</p>
</td></tr>
<tr><td><code id="paths_OCN_+3A_level">level</code></td>
<td>
<p>Character vector. At which level should paths be calculated? Possible values are <code>"RN"</code>, <code>"AG"</code>, or both.</p>
</td></tr>
<tr><td><code id="paths_OCN_+3A_whichnodes">whichNodes</code></td>
<td>
<p>List. It allows specifying a subset of nodes for which paths are computed. In the case of large rivers, this could 
speed up the function execution substantially. It must contain objects named <code>RN</code> and/or <code>AG</code>. Each of these objects is a 
vector with the indices of the nodes for which paths are to be calculated. Default is <code>NULL</code>, which leads to calculation of paths 
between all nodes at the level(s) specified in <code>level</code>. If <code>whichNodes</code> contains a single object (<code>RN</code> or <code>AG</code>), 
this is taken as the level at which paths are calculated (i.e., <code>level</code> is overwritten). If not present, the outlet node is 
automatically added. See example.</p>
</td></tr>
<tr><td><code id="paths_OCN_+3A_includepaths">includePaths</code></td>
<td>
<p>Logical. If <code>TRUE</code>, <code>RN$downstreamPath</code> and <code>AG$downstreamPath</code> are included to the output object. Note that this might slow down the function execution considerably, and create RAM issues for very large OCNs.</p>
</td></tr>
<tr><td><code id="paths_OCN_+3A_includedownstreamnode">includeDownstreamNode</code></td>
<td>
<p>Logical. If <code>TRUE</code>, path lengths include the length of the edge departing from the last downstream node of the path.</p>
</td></tr>
<tr><td><code id="paths_OCN_+3A_includeunconnectedpaths">includeUnconnectedPaths</code></td>
<td>
<p>Logical. If <code>TRUE</code>, calculate path lengths between unconnected nodes (<code>RN$downstreamLengthUnconnected</code> and <code>AG$downstreamLengthUnconnected</code>). Note that this might slow down the function execution considerably, and create RAM issues for very large OCNs.</p>
</td></tr>
<tr><td><code id="paths_OCN_+3A_displayupdates">displayUpdates</code></td>
<td>
<p>Logical. State if updates are printed on the console while <code>paths_OCN</code> runs.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>river</code> object that contains all objects contained in <code>OCN</code>, in addition to the objects listed below. 
</p>
<table>
<tr><td><code>RN$downstreamPath</code></td>
<td>
<p>List (of length <code>OCN$RN$nNodes</code>) whose object <code>i</code> is a list (of length <code>OCN$RN$nNodes</code>). 
If nodes <code>i</code> and <code>j</code> are connected by a downstream path, then <code>RN$downstreamPath[[i]][[j]]</code> is a vector 
containing the indices of the nodes constituting such path (<code>i</code> and <code>j</code> are included). If <code>i</code> and <code>j</code> are not connected 
by a downstream path, then <code>RN$downstreamPath[[i]][[j]] = NULL</code>. Only present if <code>includePaths = TRUE</code>.</p>
</td></tr>
<tr><td><code>RN$downstreamPathLength</code></td>
<td>
<p>Sparse matrix (<code>OCN$RN$nNodes</code> by <code>OCN$RN$nNodes</code>) containing length of paths between nodes 
that are connected by a downstream path; if <code>i</code> and <code>j</code> are not connected by a downstream path, then <code>RN$downstreamPathLength[i,j] = 0</code>. 
Note that <code>RN$downstreamPathLength[i,i] = 0</code> if <code>includeDownstreamNode = FALSE</code>; alternatively, it is <code>RN$downstreamPathLength[i,i] = OCN$RN$leng[i]</code>. 
It is a <code><a href="spam.html#topic+spam">spam</a></code> object.</p>
</td></tr>
<tr><td><code>RN$downstreamLengthUnconnected</code></td>
<td>
<p>Matrix (<code>OCN$RN$nNodes</code> by <code>OCN$RN$nNodes</code>). <code>RN$downstreamLengthUnconnected[i,j]</code> is 
the length of the downstream portion of a path joining node <code>i</code> to <code>j</code> if <code>i</code> and <code>j</code> are not connected by a downstream path.
Specifically, <code>RN$downstreamLengthUnconnected[i,j] = RN$downstreamPathLength[i,k]</code>, where <code>k</code> is a node such that there exist a downstream 
path from <code>i</code> to <code>k</code> and from <code>j</code> to <code>k</code>, and these paths are the shortest possible. Note that the length of the upstream portion 
of the path joining <code>i</code> to <code>j</code> is given by <code>RN$downstreamLengthUnconnected[j,i]</code>. If instead <code>i</code> and <code>j</code> are joined by a 
downstream path, then <code>RN$downstreamLengthUnconnected[i,j] = 0</code>. Only present if <code>includeUnconnectedPaths = TRUE</code>.</p>
</td></tr>
<tr><td><code>AG$downstreamPath</code></td>
<td>
<p>List (of length <code>OCN$AG$nNodes</code>) whose object <code>i</code> is a list (of length <code>OCN$AG$nNodes</code>). 
If nodes <code>i</code> and <code>j</code> are connected by a downstream path, then <code>AG$downstreamPath[[i]][[j]]</code> is a vector 
containing the indices of the nodes constituting such path (<code>i</code> and <code>j</code> are included). If <code>i</code> and <code>j</code> are not connected 
by a downstream path, then <code>AG$downstreamPath[[i]][[j]] = NULL</code>. Only present if <code>includePaths = TRUE</code>.</p>
</td></tr>
<tr><td><code>AG$downstreamPathLength</code></td>
<td>
<p>Sparse matrix (<code>OCN$AG$nNodes</code> by <code>OCN$AG$nNodes</code>) containing length of paths between nodes 
that are connected by a downstream path; if <code>i</code> and <code>j</code> are not connected by a downstream path, then <code>AG$downstreamPathLength[i,j] = 0</code>. 
Note that <code>AG$downstreamPathLength[i,i] = 0</code> if <code>includeDownstreamNode = FALSE</code>; alternatively, it is <code>AG$downstreamPathLength[i,i] = OCN$AG$leng[i]</code>. 
It is a <code><a href="spam.html#topic+spam">spam</a></code> object.</p>
</td></tr>
<tr><td><code>AG$downstreamLengthUnconnected</code></td>
<td>
<p>Matrix (<code>OCN$AG$nNodes</code> by <code>OCN$AG$nNodes</code>). <code>AG$downstreamLengthUnconnected[i,j]</code> is 
the length of the downstream portion of a path joining node <code>i</code> to <code>j</code> if <code>i</code> and <code>j</code> are not connected by a downstream path.
Specifically, <code>AG$downstreamLengthUnconnected[i,j] = AG$downstreamPathLength[i,k]</code>, where <code>k</code> is a node such that there exist a downstream 
path from <code>i</code> to <code>k</code> and from <code>j</code> to <code>k</code>, and these paths are the shortest possible. Note that the length of the upstream portion 
of the path joining <code>i</code> to <code>j</code> is given by <code>AG$downstreamLengthUnconnected[j,i]</code>. If instead <code>i</code> and <code>j</code> are joined by a 
downstream path, then <code>AG$downstreamLengthUnconnected[i,j] = 0</code>. Only present if <code>includeUnconnectedPaths = TRUE</code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># 1) Calculate paths between nodes of an OCN
OCN &lt;- paths_OCN(aggregate_OCN(landscape_OCN(OCN_20), thrA = 4))

# 2) Display distance to outlet (at the RN level) along the main stem
# of an OCN
OCN &lt;- aggregate_OCN(landscape_OCN(OCN_250_T)) # this takes some seconds
OCN &lt;- paths_OCN(OCN, includePaths = TRUE) # this takes some seconds

distanceToOutlet &lt;- OCN$RN$downstreamPathLength[,OCN$RN$outlet]
farthestNode &lt;- which(distanceToOutlet == max(distanceToOutlet))
mainStem &lt;- OCN$RN$downstreamPath[[farthestNode]][[OCN$RN$outlet]]
theme &lt;- rep(NaN, OCN$RN$nNodes)
theme[mainStem] &lt;- distanceToOutlet[mainStem]

draw_thematic_OCN(theme, OCN)
title("Distance to outlet along the main stem [pixel units]")

# 3) use whichNodes to compute distance between two non flow-connected nodes 
OCN &lt;- aggregate_OCN(landscape_OCN(OCN_250_T)) # this takes some seconds
RNnodes &lt;- c(483, 516)
plot(OCN)
points(OCN$RN$X[RNnodes], OCN$RN$Y[RNnodes], pch = 19) # nodes 483 and 516 are not flow-connected
OCN &lt;- paths_OCN(OCN, whichNodes = list(RN=RNnodes), includePaths = TRUE,
				 includeUnconnectedPaths = TRUE)
OCN$RN$downstreamPath[[RNnodes[1]]][[OCN$RN$outlet]] 
# the outlet node has been added to whichNodes$RN
OCN$RN$downstreamLengthUnconnected[RNnodes[1], RNnodes[2]] 
# distance from node 1 to the common downstream confluence
OCN$RN$downstreamLengthUnconnected[RNnodes[2], RNnodes[1]] 
# distance from node 2 to the common downstream confluence



</code></pre>

<hr>
<h2 id='plot'>Plot a river</h2><span id='topic+plot'></span><span id='topic+plot+2Criver+2Cnumeric-method'></span><span id='topic+plot+2Cnumeric+2Criver-method'></span><span id='topic+plot+2Criver+2Cmissing-method'></span>

<h3>Description</h3>

<p>Plots a <code>river</code> object</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'river,numeric'
plot(x, y, type, ...)
## S4 method for signature 'numeric,river'
plot(x, y, type, ...)
## S4 method for signature 'river,missing'
plot(x, type, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_+3A_x">x</code></td>
<td>
<p>A <code>river</code> object (or a numeric vector if <code>y</code> is a <code>river</code>).</p>
</td></tr>
<tr><td><code id="plot_+3A_y">y</code></td>
<td>
<p>A numeric vector to be displayed (or a river if <code>x</code> is a numeric vector). 
It is equivalent to <code>theme</code> in <code>draw_subcatchments_OCN</code> and <code>draw_thematic_OCN</code>. If <code>y</code> is specified, the river must 
have been aggregated. See details.</p>
</td></tr>
<tr><td><code id="plot_+3A_type">type</code></td>
<td>
<p>Optional argument. If <code>type = "SC"</code> or <code>type = "subcatchments"</code>, <code>draw_subcatchments_OCN</code> is used (provided that 
the <code>river</code> object is aggregated); if  <code>type = "elev2D"</code>, <code>draw_elev2D_OCN</code> is used; alternatively,
<code>draw_thematic_OCN</code> is used.</p>
</td></tr>
<tr><td><code id="plot_+3A_...">...</code></td>
<td>
<p>Arguments passed to the plotting functions <code>draw_simple_OCN</code>, <code>draw_contour_OCN</code>, 
<code>draw_thematic_OCN</code>. See details.</p>
</td></tr> 
</table>


<h3>Details</h3>

<p>This is an interface to the plotting functions <code>draw_simple_OCN</code>, <code><a href="#topic+draw_elev2D_OCN">draw_elev2D_OCN</a></code>, <code>draw_contour_OCN</code>, <code>draw_subcatchments_OCN</code>,
<code>draw_thematic_OCN</code>. If the <code>river</code> object does not have an elevation field (i.e., it has been generated
by <code>create_OCN</code> or <code>create_general_contour_OCN</code>, but <code>landscape_OCN</code> has not 
been run), the plotting function used is <code>draw_simple_OCN</code>. If the elevation field is present, but the river 
has not been aggregated (via <code>aggregate_OCN</code> or <code>aggregate_river</code>), the default plotting function used is 
<code>draw_contour_OCN</code>. If the river has been aggregated, <code>draw_subcatchments_OCN</code> or <code>draw_thematic_OCN</code> are used depending on <code>type</code>.
Elevation maps can be produced with <code>type = "elev2D"</code>, regardless of whether the river has been aggregated.
</p>
<p><em>Adding scale bar and north arrow.</em> Scale bar and north arrow can be added via <code>terra</code>'s functions <code><a href="terra.html#topic+sbar">sbar</a></code> and <code><a href="terra.html#topic+north">north</a></code>, respectively. 
However, note that arguments <code>d</code> and <code>xy</code> must be specified by the user (because no <code>rast</code> object is plotted). See example.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+draw_simple_OCN">draw_simple_OCN</a></code>, <code><a href="#topic+draw_elev2D_OCN">draw_elev2D_OCN</a></code>, <code><a href="#topic+draw_contour_OCN">draw_contour_OCN</a></code>, <code><a href="#topic+draw_subcatchments_OCN">draw_subcatchments_OCN</a></code>, <code><a href="#topic+draw_thematic_OCN">draw_thematic_OCN</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
OCN &lt;- OCN_20
plot(OCN) # equivalent to draw_simple_OCN

OCN &lt;- landscape_OCN(OCN)
plot(OCN) # equivalent to draw_contour_OCN
plot(OCN, type = "elev2D") # equivalent to draw_elev2D_OCN

OCN &lt;- aggregate_OCN(OCN, thrA = 4)
plot(OCN) # equivalent to draw_thematic_OCN (with no theme specified)
plot(OCN, OCN$AG$A) # equivalent to draw_thematic_OCN (with theme specified)

plot(OCN, type = "SC") # equivalent to draw_subcatchments_OCN (with no theme specified)
plot(OCN, OCN$AG$A, type = "SC") # equivalent to draw_subcatchments_OCN (with theme specified)
# now add scale bar and north arrow
library(terra)
# sbar() # this would throw an error
# north()# this would throw an error
sbar(d=1, xy=c(min(OCN$FD$X), min(OCN$FD$Y)-1)) # this works
north(d=1, xy=c(max(OCN$FD$X)+1, max(OCN$FD$Y))) # this works
</code></pre>

<hr>
<h2 id='river-class'>river class</h2><span id='topic+river'></span><span id='topic+river-class'></span><span id='topic+show+2Criver-method'></span><span id='topic++24+2Criver-method'></span><span id='topic++24+3C-+2Criver-method'></span><span id='topic+names+2Criver-method'></span><span id='topic++5B+5B+2Criver+2Ccharacter+2Cmissing-method'></span><span id='topic++5B+5B+3C-+2Criver+2Ccharacter+2Cmissing-method'></span><span id='topic++5B+5B+3C-+2Criver+2Ccharacter+2Cmissing+2CANY-method'></span>

<h3>Description</h3>

<p>A <code>river</code> object contains information on river attributes at different aggregation levels. It can represent a real river network 
(obtained via <code>rivnet::extract_river</code>) or an optimal channel network (obtained via <code><a href="#topic+create_OCN">create_OCN</a></code>).
</p>
<p>The content of a <code>river</code> object can be treated as a list, hence its objects and sublists can be accessed with both the <code>$</code> and <code>@</code> operators. 
</p>
<p>For information on the aggregation levels and on the content of a 
<code>river</code> object, see <code><a href="#topic+OCNet-package">OCNet-package</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>show(OCN_20)
names(OCN_20)

# extract or replace parts of a river object
OCN_20$dimX
OCN_20@dimX
dim &lt;- OCN_20[["dimX"]]
OCN_20$dimX &lt;- 1
OCN_20[["dimX"]]
OCN_20[["dimX"]] &lt;- dim
</code></pre>

<hr>
<h2 id='rivergeometry_OCN'>River geometry of an Optimal Channel Network</h2><span id='topic+rivergeometry_OCN'></span>

<h3>Description</h3>

<p>Function that calculates river width, depth and water velocity by applying Leopold's scaling relationships to nodes at the RN and AG levels.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rivergeometry_OCN(OCN, widthMax = 1, depthMax = 1,
  velocityMax = 1, expWidth = NaN, expDepth = NaN,
  expVelocity = NaN)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rivergeometry_OCN_+3A_ocn">OCN</code></td>
<td>
<p>A <code>river</code> object as produced by <code><a href="#topic+aggregate_OCN">aggregate_OCN</a></code>.</p>
</td></tr>
<tr><td><code id="rivergeometry_OCN_+3A_widthmax">widthMax</code></td>
<td>
<p>Maximum river width allowed. If <code>nOutlet = 1</code>, it corresponds to the width at the outlet node.</p>
</td></tr>
<tr><td><code id="rivergeometry_OCN_+3A_depthmax">depthMax</code></td>
<td>
<p>Maximum river depth allowed. If <code>nOutlet = 1</code>, it corresponds to the depth at the outlet node.</p>
</td></tr>
<tr><td><code id="rivergeometry_OCN_+3A_velocitymax">velocityMax</code></td>
<td>
<p>Maximum water velocity allowed. If <code>nOutlet = 1</code>, it corresponds to the water velocity at the outlet node.</p>
</td></tr>
<tr><td><code id="rivergeometry_OCN_+3A_expwidth">expWidth</code>, <code id="rivergeometry_OCN_+3A_expdepth">expDepth</code>, <code id="rivergeometry_OCN_+3A_expvelocity">expVelocity</code></td>
<td>
<p>Exponents for the power law relationship between river width, depth, water velocity 
and contributing area. If none of <code>expWidth</code>, <code>expDepth</code>, <code>expVelocity</code> is specified by the user, the values 
<code>expWidth = 0.5</code>, <code>expDepth = 0.4</code>, <code>expDepth = 0.1</code> proposed by Leopold and Maddock [1953] are used. 
It is possible to specify two out of these three exponents, provided that each of them lies in the range (0; 1) and their sum is lower than one. 
In this case, the missing exponent is calculated as the complement to one of the sum of the two values provided. 
If all three exponents are specified by the user, their sum must be equal to one.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The values of contributing area used to evaluate river geometry at the AG level are equal to <code>0.5*(OCN$AG$A + OCN$AG$AReach)</code>. See also <code><a href="#topic+aggregate_OCN">aggregate_OCN</a></code>.
</p>
<p>See also Leopold, L. B., &amp; Maddock, T. (1953). <em>The hydraulic geometry of stream channels and some physiographic implications</em>
(Vol. 252). US Government Printing Office.
</p>


<h3>Value</h3>

<p>AA <code>river</code> object that contains all objects contained in <code>OCN</code>, in addition to the objects listed below. 
</p>
<table>
<tr><td><code>RN$width</code></td>
<td>
<p>Vector (of length <code>OCN$RN$nNodes</code>) of river width values for every RN node.</p>
</td></tr>
<tr><td><code>RN$depth</code></td>
<td>
<p>Vector (of length <code>OCN$RN$nNodes</code>) of river depth values for every RN node.</p>
</td></tr>
<tr><td><code>RN$velocity</code></td>
<td>
<p>Vector (of length <code>OCN$RN$nNodes</code>) of water velocity values for every RN node.</p>
</td></tr>
<tr><td><code>AG$width</code></td>
<td>
<p>Vector (of length <code>OCN$AG$nNodes</code>) of river width values for every AG node.</p>
</td></tr>
<tr><td><code>AG$depth</code></td>
<td>
<p>Vector (of length <code>OCN$AG$nNodes</code>) of river depth values for every AG node.</p>
</td></tr>
<tr><td><code>AG$velocity</code></td>
<td>
<p>Vector (of length <code>OCN$AG$nNodes</code>) of water velocity values for every AG node.</p>
</td></tr>
</table>
<p>Finally, <code>widthMax</code>, <code>depthMax</code>, <code>velocityMax</code>, <code>expWidth</code>, <code>expDepth</code>, <code>expVelocity</code> are added to the list.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># 1) Compute river geometry of a 20x20 OCN with default options
# and display river width at the RN level
OCN &lt;- rivergeometry_OCN(aggregate_OCN(landscape_OCN(OCN_20)))
draw_thematic_OCN(OCN$RN$width,OCN)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
