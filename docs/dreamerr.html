<!DOCTYPE html><html lang="en"><head><title>Help for package dreamerr</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {dreamerr}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#dreamerr-package'><p>Error Handling Made Easy</p></a></li>
<li><a href='#check_arg'><p>Checks arguments and informs the user appropriately</p></a></li>
<li><a href='#check_expr'><p>Checks the evaluation of an expression</p></a></li>
<li><a href='#enumerate_items'><p>Enumerates the elements of a vector</p></a></li>
<li><a href='#fit_screen'><p>Nicely fits a message in the current R console</p></a></li>
<li><a href='#fsignif'><p>Formatting numbers with display of significant digits</p></a></li>
<li><a href='#generate_set_hook'><p>Error displaying a call located at a hook location</p></a></li>
<li><a href='#ifsingle'><p>Conditional element selection</p></a></li>
<li><a href='#n_times'><p>Numbers in letters</p></a></li>
<li><a href='#package_stats'><p>Provides package statistics</p></a></li>
<li><a href='#plural'><p>Adds an s and/or a singular/plural verb depending on the argument's length</p></a></li>
<li><a href='#set_check'><p>Sets argument checking on/off &quot;semi-globally&quot;</p></a></li>
<li><a href='#set_up'><p>Sets &quot;semi-globally&quot; the 'up' argument of dreamerr's functions</p></a></li>
<li><a href='#setDreamerr_check'><p>Sets dreamerr argument checking functions on or off</p></a></li>
<li><a href='#setDreamerr_dev.mode'><p>Sets the developer mode to help form check_arg calls</p></a></li>
<li><a href='#setDreamerr_show_stack'><p>Settings telling whether or not to display the full call stack on errors</p></a></li>
<li><a href='#sfill'><p>Fills a string vector with a symbol</p></a></li>
<li><a href='#stop_up'><p>Stops (or warns in) sub-function execution</p></a></li>
<li><a href='#suggest_item'><p>Suggest the the closest elements from a string vector</p></a></li>
<li><a href='#validate_dots'><p>Checks the arguments in dots from methods</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Error Handling Made Easy</td>
</tr>
<tr>
<td>Version:</td>
<td>1.4.0</td>
</tr>
<tr>
<td>Imports:</td>
<td>Formula, utils, stringmagic</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, stats, graphics</td>
</tr>
<tr>
<td>Description:</td>
<td>Set of tools to facilitate package development and make R a more user-friendly place. Mostly for developers (or anyone who writes/shares functions). Provides a simple, powerful and flexible way to check the arguments passed to functions. 
    The developer can easily describe the type of argument needed. If the user provides a wrong argument, then an informative error message is prompted with the requested type and the problem clearly stated&ndash;saving the user a lot of time in debugging. </td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/lrberge/dreamerr/issues">https://github.com/lrberge/dreamerr/issues</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-12-21 13:31:32 UTC; lrberge</td>
</tr>
<tr>
<td>Author:</td>
<td>Laurent Berge [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Laurent Berge &lt;laurent.berge@u-bordeaux.fr&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-12-21 14:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='dreamerr-package'>Error Handling Made Easy</h2><span id='topic+dreamerr'></span><span id='topic+dreamerr-package'></span>

<h3>Description</h3>

<p>The main purpose of this package is twofold: i) to facilitate the developer's life, and ii) to provide to the users meaningful, useful error messages. These objectives are accomplished with a single function: <code><a href="#topic+check_arg">check_arg</a></code>. That function checks the arguments given by the user: it offers a compact syntax such that complex arguments can be simply stated by the developer. In turn, if the user provides an argument of the wrong type then an informative error message will be buit, stating the expected type and where the error comes from&ndash;saving the user quite some time in debugging.
</p>


<h3>Details</h3>

<p>Thus you can very easily make your package look professional with <code><a href="#topic+check_arg">check_arg</a></code> (checking arguments properly <em>is</em> professional).
</p>
<p>It also offers a set of small tools to provide informative messages to the users. See <code><a href="#topic+stop_up">stop_up</a></code> and <code><a href="#topic+stop_up">warn_up</a></code> to throw errors and warnings in the appropriate location. There are many tools to form messages: <code><a href="#topic+enumerate_items">enumerate_items</a></code> to form textual list of elements (with many options including conjugating verbs, etc...), <code><a href="#topic+plural">plural</a></code> to conjugate verbs depending on the argument, and <code><a href="#topic+n_times">n_letter</a></code>, <code><a href="#topic+n_times">n_th</a></code>, <code><a href="#topic+n_times">n_times</a></code> to write integers in words (which usually looks nicer).
</p>
<p>To sum up in a few words, this package was created to enhance the user experience and facilitate package development.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Laurent Berge <a href="mailto:laurent.berge@u-bordeaux.fr">laurent.berge@u-bordeaux.fr</a>
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li><p> Report bugs at <a href="https://github.com/lrberge/dreamerr/issues">https://github.com/lrberge/dreamerr/issues</a>
</p>
</li></ul>


<hr>
<h2 id='check_arg'>Checks arguments and informs the user appropriately</h2><span id='topic+check_arg'></span><span id='topic+check_set_arg'></span><span id='topic+check_value'></span><span id='topic+check_set_value'></span><span id='topic+check_arg_plus'></span><span id='topic+check_value_plus'></span>

<h3>Description</h3>

<p>Full-fledged argument checking. Checks that the user provides arguments of the requested type (even complex) in a very simple way for the developer. Provides detailed and informative error messages for the user.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_arg(
  .x,
  .type,
  .x1,
  .x2,
  .x3,
  .x4,
  .x5,
  .x6,
  .x7,
  .x8,
  .x9,
  ...,
  .message,
  .choices = NULL,
  .data = list(),
  .value,
  .env,
  .up = 0
)

check_set_arg(
  .x,
  .type,
  .x1,
  .x2,
  .x3,
  .x4,
  .x5,
  .x6,
  .x7,
  .x8,
  .x9,
  ...,
  .message,
  .choices = NULL,
  .data = list(),
  .value,
  .env,
  .up = 0
)

check_value(
  .x,
  .type,
  .message,
  .arg_name,
  .prefix,
  .choices = NULL,
  .data = list(),
  .value,
  .env,
  .up = 0
)

check_set_value(
  .x,
  .type,
  .message,
  .arg_name,
  .prefix,
  .choices = NULL,
  .data = list(),
  .value,
  .env,
  .up = 0
)

check_arg_plus

check_value_plus
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="check_arg_+3A_.x">.x</code></td>
<td>
<p>An argument to be checked. Must be an argument name. Can also be the type, see details/examples.</p>
</td></tr>
<tr><td><code id="check_arg_+3A_.type">.type</code></td>
<td>
<p>A character string representing the requested type(s) of the arguments.
This is a bit long so please look at the details section or the vignette for explanations.
Each type is composed of one main class and restrictions (optional).
Types can be separated with pipes (<code>|</code>).
The main classes are: i) <code>"scalar"</code> for scalars, i.e. vectors of length one,
ii) <code>"vector"</code>, iii) <code>"matrix"</code>, iv) <code>"data.frame"</code>,
v) <code>"list"</code>, vi) <code>formula</code>, vii) <code>function</code>, viii) <code>charin</code>,
i.e. a character string in a set of choices, ix) <code>"match"</code>,
i.e. a character scalar that should partially match a vector of choices,
x) <code>path</code>, a character scalar pointing to a file or directory,
xi) <code>"class(my_class1, my_class2)"</code>, i.e. an object whose class is any
of the ones in parentheses, xii) <code>"NA"</code>, something identical to <code>NA</code>.
You can then add optional restrictions: 1) <code>len(a, b)</code>, i.e. the object
should be of length between <code>a</code> and <code>b</code> (you can leave <code>a</code>
or <code>b</code> missing, <code>len(a)</code> means length <em>equal</em> to <code>a</code>),
<code>len(data)</code> and <code>len(value)</code> are also possible (see details),
2) <code>nrow(a,b)</code> or <code>ncol(a,b)</code> to specify the expected number of
rows or columns, 3) <code>arg(a,b)</code>, only for functions, to retrict the number
of arguments, 4) <code>"na ok"</code> to allow the object to have NAs (for &quot;scalar&quot; types),
or <code>"no na"</code> to restrict the object to have no NA (for &quot;data.frame&quot;, &quot;vector&quot;,
and &quot;matrix&quot; types), 5) <code>GE</code>, <code>GT</code>, <code>LE</code> and <code>LT</code>:
for numeric scalars/vectors/matrices, <code>GE{expr}</code> restrics the object
to have only values striclty greater than (greater or equal/strictly lower
than/lower or equal) the value in curly brackets, 6) e.g. <code>scalar(type1, type2)</code>,
for scalars/vectors/matrices you can restrict the type of the object by
adding the expected type in parentheses: should it be numeric, logical, etc.</p>
</td></tr>
<tr><td><code id="check_arg_+3A_.x1">.x1</code></td>
<td>
<p>An argument to be checked. Must be an argument name. Can also be the type, see details/examples.</p>
</td></tr>
<tr><td><code id="check_arg_+3A_.x2">.x2</code></td>
<td>
<p>An argument to be checked. Must be an argument name. Can also be the type, see details/examples.</p>
</td></tr>
<tr><td><code id="check_arg_+3A_.x3">.x3</code></td>
<td>
<p>An argument to be checked. Must be an argument name. Can also be the type, see details/examples.</p>
</td></tr>
<tr><td><code id="check_arg_+3A_.x4">.x4</code></td>
<td>
<p>An argument to be checked. Must be an argument name. Can also be the type, see details/examples.</p>
</td></tr>
<tr><td><code id="check_arg_+3A_.x5">.x5</code></td>
<td>
<p>An argument to be checked. Must be an argument name. Can also be the type, see details/examples.</p>
</td></tr>
<tr><td><code id="check_arg_+3A_.x6">.x6</code></td>
<td>
<p>An argument to be checked. Must be an argument name. Can also be the type, see details/examples.</p>
</td></tr>
<tr><td><code id="check_arg_+3A_.x7">.x7</code></td>
<td>
<p>An argument to be checked. Must be an argument name. Can also be the type, see details/examples.</p>
</td></tr>
<tr><td><code id="check_arg_+3A_.x8">.x8</code></td>
<td>
<p>An argument to be checked. Must be an argument name. Can also be the type, see details/examples.</p>
</td></tr>
<tr><td><code id="check_arg_+3A_.x9">.x9</code></td>
<td>
<p>An argument to be checked. Must be an argument name. Can also be the type, see details/examples.</p>
</td></tr>
<tr><td><code id="check_arg_+3A_...">...</code></td>
<td>
<p>Only used to check <code>'...'</code> (dot-dot-dot) arguments.</p>
</td></tr>
<tr><td><code id="check_arg_+3A_.message">.message</code></td>
<td>
<p>A character string, optional. By default, if the user provides a
wrong argument, the error message stating what type of argument is required is
automatically formed. You can alternatively provide your own error message,
maybe more tailored to your function. The reason of why there is a problem is
appended in the end of the message. You can use the special character
<code>__ARG__</code> in the message. If found, <code>__ARG__</code> will be
replaced by the appropriate argument name.</p>
</td></tr>
<tr><td><code id="check_arg_+3A_.choices">.choices</code></td>
<td>
<p>Only if one of the types (in argument <code>type</code>) is <code>"match"</code>. The values the argument can take. Note that even if the <code>type</code> is <code>"match"</code>, this argument is optional since you have other ways to declare the choices.</p>
</td></tr>
<tr><td><code id="check_arg_+3A_.data">.data</code></td>
<td>
<p>Must be a data.frame, a list or a vector. Used in three situations. 1) if the global keywords <code>eval</code> or <code>evalset</code> are present: the argument will also be evaluated in the data (i.e. the argument can be a variable name of the data set). 2) if the argument is expected to be a formula and <code>var(data)</code> is included in the type: then the formula will be expected to contain variables from <code>.data</code>. 3) if the keywords <code>len(data)</code>, <code>nrow(data)</code> or <code>ncol(data)</code> are requested, then the required length, number of rows/columns, will be based on the data provided in <code>.data</code>.</p>
</td></tr>
<tr><td><code id="check_arg_+3A_.value">.value</code></td>
<td>
<p>An integer scalar or a named list of integers scalars. Used when the keyword <code>value</code> is present (like for instance in <code>len(value)</code>). If several values are to be provided, then it must be a named list with names equal to the codes: for instance if <code>nrow(value)</code> and <code>ncol(value)</code> are both present in the type, you can use (numbers are an example) <code>.value = list(nrow = 5, ncol = 6)</code>. See Section IV) in the examples.</p>
</td></tr>
<tr><td><code id="check_arg_+3A_.env">.env</code></td>
<td>
<p>An environment defaults to the frame where the user called the original function. Only used in two situations. 1) if the global keywords <code>eval</code> or <code>evalset</code> are present: the argument will also be evaluated in this environment. 2) if the argument is expected to be a formula and <code>var(env)</code> is included in the type: then the formula will be expected to contain variables existing in <code>.env</code>.</p>
</td></tr>
<tr><td><code id="check_arg_+3A_.up">.up</code></td>
<td>
<p>Integer, default is 0. If the user provides a wrong argument, the error message will integrate the call of the function from which <code>check_arg</code> has been called. If <code>check_arg</code> is  called in a non-user level sub function of a main user-level function, then use <code>.up = 1</code> to make the error message look like it occured in the main function (and not in the sub function). Of course you can have values higher than 1.</p>
</td></tr>
<tr><td><code id="check_arg_+3A_.arg_name">.arg_name</code></td>
<td>
<p>A character scalar. If <code>.message</code> is not provided, an automatic error message will be generated using <code>.arg_name</code> as the argument name. The structure of the message will be <code>"Argument '[.arg_name]' must be [requested type]. Problem: [detail of the problem]"</code>.</p>
</td></tr>
<tr><td><code id="check_arg_+3A_.prefix">.prefix</code></td>
<td>
<p>A character scalar. If <code>.message</code> is not provided, an automatic error message will be generated. The structure of the message will be <code>"[.prefix] must be [requested type]. Problem: [detail of the problem]"</code>.</p>
</td></tr>
</table>


<h3>Format</h3>

<p>An object of class <code>function</code> of length 1.
</p>
<p>An object of class <code>function</code> of length 1.
</p>


<h3>Value</h3>

<p>In case the <code>type</code> is <code>"match"</code>, it returns the matched value. In any other case, <code>NULL</code> is returned.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>check_set_arg()</code>: Same as <code>check_arg</code>, but includes in addition: i) default setting, ii) type conversion, iii) partial matching, and iv) checking list elements. (Small drawback: cannot be turned off.)
</p>
</li>
<li> <p><code>check_value()</code>: Checks if a (single) value is of the appropriate type
</p>
</li>
<li> <p><code>check_set_value()</code>: Same as <code>check_value</code>, but includes in addition: i) default setting, ii) type conversion, iii) partial matching, and iv) checking list elements. (Small drawback: cannot be turned off.)
</p>
</li></ul>


<h3>How to form a type</h3>

<p>To write the expected type of an argument, you need to write the main class in combination with the class's options and restrictions (if any).
</p>
<p>The syntax is: <code>"main_class option(s) restriction(s)"</code>
</p>
<p>A type MUST have at least one main class. For example: in the type <code>"logical vector len(,2) no na"</code>, <code>vector</code> is the main class, <code>no na</code> is the option, and <code>logical</code> and <code>len(,2)</code> are restrictions
</p>
<p>There are 14 main classes that can be checked. On the left the keyword, on the right what is expected from the argument, and in square brackets the related section in the examples:
</p>

<ul>
<li> <p><code>scalar</code>: an atomic vector of length 1 [Section I)]
</p>
</li>
<li> <p><code>vector</code>: an atomic vector [Section IV)]
</p>
</li>
<li> <p><code>matrix</code>: a matrix [Section IV)]
</p>
</li>
<li> <p><code>vmatrix</code>: a matrix or vector [Section IV)]
</p>
</li>
<li> <p><code>data.frame</code>: a data.frame [Section VI)]
</p>
</li>
<li> <p><code>vdata.frame</code>: a data.frame or vector [Section VI)]
</p>
</li>
<li> <p><code>list</code>: a list [Section V)]
</p>
</li>
<li> <p><code>formula</code>: a formula [Section VIII)]
</p>
</li>
<li> <p><code>function</code>: a function [Section V)]
</p>
</li>
<li> <p><code>charin</code>: a character vector with values in a vector of choices [Section III)]
</p>
</li>
<li> <p><code>match</code>: a character vector with values in a vector of choices, partial matching enabled and only available in <code>check_set_arg</code> [Section III)]
</p>
</li>
<li> <p><code>path</code>: a character scalar pointing to a file or a directory
</p>
</li>
<li> <p><code>class</code>: a custom class [Section VI)]
</p>
</li>
<li> <p><code>NA</code>: a vector of length 1 equal to NA&ndash;does not support options nor restrictions, usually combined with other main classes (see Section on combining multiple types) [Section VI)]
</p>
</li></ul>

<p>There are eight type options, they are not available for each types. Here what they do and the types to which they are associated:
</p>

<ul>
<li> <p><code>NA OK</code> (or <code>NAOK</code>): Tolerates the presence of NA values. Available for <code>scalar</code>.
</p>
</li>
<li> <p><code>NO NA</code> (or <code>NONA</code>): Throws an error if NAs are present. Available for <code>vector</code>, <code>matrix</code>, <code>vmatrix</code>, <code>data.frame</code>, and <code>vdata.frame</code>.
</p>
</li>
<li> <p><code>square</code>: Enforces the matrix to be square. Available for <code>matrix</code>, <code>vmatrix</code>.
</p>
</li>
<li> <p><code>named</code>: Enforces the object to have names. Available for <code>vector</code>, <code>list</code>.
</p>
</li>
<li> <p><code>multi</code>: Allows multiple matches. Available for <code>charin</code>, <code>match</code>.
</p>
</li>
<li> <p><code>strict</code>: Makes the matching case-sensitive. Available for <code>match</code>.
</p>
</li>
<li> <p><code>os</code> and <code>ts</code>: Available for <code>formula</code>. Option <code>os</code> (resp. <code>ts</code>) enforces that the formula is one-sided (resp. two-sided).
</p>
</li>
<li> <p><code>dir</code>, <code>read</code> and <code>create</code>: Available for <code>path</code>. Option <code>dir</code> checks whether the path points to a directory and not a file. Option <code>read</code> checks whether the file actually exists and has read permission. Option <code>create</code> creates up to the grand-parent folder if it was not yet existing.
</p>
</li></ul>

<p>You can further add restrictions. There are roughly six types of restrictions. Here what they do and the types to which they are associated:
</p>

<ul>
<li><p> sub-type restriction: For atomic types (<code>scalar</code>, <code>vector</code>, <code>matrix</code> or <code>vmatrix</code>), you can restrict the underlying data to be of a specific sub-type. The simple sub-types are: i) <code>integer</code> (numeric without decimals and logicals), i') <code>strict integer</code> (numeric that can be converted to integer with <code>as.integer</code>, and not logicals), ii) <code>numeric</code>, iii) <code>factor</code>, iv) <code>logical</code> and iv') <code>loose logical</code> (0/1 are also OK). Simply add the sub-type in the type string (e.g. <code>"integer scalar"</code>), or if you allow multiple types, put them in parentheses rigth after the main class: e.g. <code>"scalar(character, integer)"</code>. See Section XI) in the examples. See also the section below for more information on the sub-types. Some types (<code>character</code>, <code>integer</code>, <code>numeric</code>, <code>logical</code> and <code>factor</code>) also support the keyword <code>"conv"</code> in <code>check_set_arg</code>.
</p>
</li>
<li> <p><code>GE</code>/<code>GT</code>/<code>LE</code>/<code>LT</code>: For atomic types with numeric data, you can check the values in the object. The GE/GT/LE/LT mean respectively greater or equal/greater than/lower or equal/lower than. The syntax is <code>GE{expr}</code>, with expr any expression. See Section IV) in the examples.
</p>
</li>
<li> <p><code>len(a, b)</code>: You can restrict the length of objects with <code>len(a, b)</code> (with <code>a</code> and <code>b</code> integers). Available for <code>vector</code> and <code>list</code>. Then the length must be in between <code>a</code> and <code>b</code>. Either <code>a</code> or <code>b</code> can be missing which means absence of restriction. If <code>len(a)</code>, this means must be equal to <code>a</code>. You can also use the keywords len(data) which ensures that the length is the same as the length of the object given in the argument <code>.data</code>, or <code>len(value)</code> which ensures the length is equal to the value given in <code>.value</code>. See Section IV) in the examples.
</p>
</li>
<li> <p><code>nrow(a, b)</code>, <code>ncol(a, b)</code>: To restrict the number of rows and columns. Available for <code>matrix</code>, <code>vmatrix</code>, <code>data.frame</code>, <code>vdata.frame</code>. Tolerates the <code>data</code> and <code>value</code> keywords (see in <code>len</code>). See Section IV) in the examples.
</p>
</li>
<li><p> var(data, env): Available only for <code>formula</code>. <code>var(data)</code> ensures that the variables in the formula are present in the data set given by the extra argument <code>.data</code>. <code>var(env)</code> ensures they are present in the environment, and <code>var(data, env)</code> in either the environment or the data set. See Section VIII) in the examples.
</p>
</li>
<li> <p><code>arg(a, b)</code>: Available only for <code>function</code>. Ensures that the function has a number of arguments between <code>a</code> and <code>b</code>, both integers (possibly missing). Tolerates the <code>value</code> keyword (see in <code>len</code>). See Section V) in the examples.
</p>
</li>
<li> <p><code>left(a, b)</code> and <code>right(a, b)</code>: Only available for <code>formula</code>. Restricts the number of parts in the left-hand-side or in the right-hand-side of the formula. Tolerates the <code>value</code> keyword (see in <code>len</code>). See Section VIII) in the examples.
</p>
</li></ul>

<p>[Section I)]: R:Section%20I)
[Section IV)]: R:Section%20IV)
[Section IV)]: R:Section%20IV)
[Section IV)]: R:Section%20IV)
[Section VI)]: R:Section%20VI)
[Section VI)]: R:Section%20VI)
[Section V)]: R:Section%20V)
[Section VIII)]: R:Section%20VIII)
[Section V)]: R:Section%20V)
[Section III)]: R:Section%20III)
[Section III)]: R:Section%20III)
[Section VI)]: R:Section%20VI)
[Section VI)]: R:Section%20VI)
</p>


<h3>Global keywords</h3>

<p>There are eight global keywords that can be placed anywhere in the type. They are described in Section II) in the examples.
</p>

<ul>
<li> <p><code>NULL</code>: allows the argument to be equal to <code>NULL</code>.
</p>
</li>
<li> <p><code>safe NULL</code>: allows the argument to be equal to <code>NULL</code>, but an error is thrown if the argument is of the type <code>base$variable</code> or <code>base[["variable"]]</code>. This is to prevent oversights from the user, especially useful when the main class is a vector.
</p>
</li>
<li> <p><code>NULL{expr}</code>: allows the argument to be equal to <code>NULL</code>, if the argument is <code>NULL</code>, then it assigns the value of expr to the argument.
</p>
</li>
<li> <p><code>MBT</code>: (means &quot;must be there&quot;) an error is thrown if the argument is not provided by the user.
</p>
</li>
<li> <p><code>L0</code>: allows 0-length vectors&ndash;overrides the default which requires that any argument should have a positive length
</p>
</li>
<li> <p><code>eval</code>: used in combination with the extra argument <code>.data</code>. Evaluates the value of the argument both in the data set and in the environment (this means the argument can be a variable name).
</p>
</li>
<li> <p><code>evalset</code>: like <code>eval</code>, but after evaluation, assigns the obtained value to the argument. Only available in <code>check_set_arg</code>.
</p>
</li>
<li> <p><code>dotnames</code>: only when checking <code>'...'</code> argument (see the related section below). Enforces that each object in <code>'...'</code> has a name.
</p>
</li></ul>



<h3>The <code>match</code> and <code>charin</code> types</h3>

<p>The main classes <code>match</code> and <code>charin</code> are similar to <code><a href="base.html#topic+match.arg">match.arg</a></code>. These two types are detailed in the examples Section III).
</p>
<p>By default, the main class <code>match</code> expects a single character string whose value is in a set of choices. By default, there is no case sensitity (which can be turned on with the option <code>strict</code>) and there is always partial matching. It can expect a vector (instead of a single element) if the option <code>multi</code> is present.
</p>
<p>You have three different ways to set the choices:
</p>

<ul>
<li><p> by setting the argument default: e.g. <code>fun = function(x = c("Tom", "John")) check_arg(x, "match")</code>
</p>
</li>
<li><p> by providing the argument <code>.choices</code>: e.g. <code>fun = function(x) check_arg(x, "match", .choices = c("Tom", "John"))</code>
</p>
</li>
<li><p> by writing the choices in parentheses: e.g. <code>fun = function(x) check_arg(x, "match(Tom, John)")</code>
</p>
</li></ul>

<p>When the user doesn't provide the argument, the default is set to the first choice.
Since the main class <code>match</code> performs a re-assignment of the variable, it is only available in <code>check_set_arg</code>.
</p>
<p>The main class <code>charin</code> is similar to <code>match</code> in that it expects a single character string in a set of choices. The main differences are: i) there is no partial matching, ii) the choices cannot be set by setting the argument default, and iii) its checking can be turned off with setDreamer_check(FALSE) (that's the main difference between <code>check_arg</code> and <code>check_set_arg</code>).
</p>


<h3>Combining multiple types</h3>

<p>You can combine multiple types with a pipe: '|'. The syntax is as follows:
</p>
<p><code>"main_type option(x) restriction(s) | main_type option(x) restriction(s) | main_type option(x) restriction(s)"</code>
</p>
<p>You can combine as many types as you want. The behavior is as follows: if the argument matches any of the types, then that's fine.
</p>
<p>For example, say you require an argument to be either a logical scalar, either a data.frame, then you can write: <code>check_arg(x, "logical scalar | data.frame")</code>. See Section X) in the examples for a more complex example.
</p>


<h3>Tips on the type</h3>

<p>The type MUST be a character string of length 1. Two main classes must be separated by a pipe. Otherwise the order of the keywords, the spaces, or the case don't matter. Further the global keywords can be placed anywhere and need not be separated by a pipe.
</p>
<p>Note that a rare but problematic situation is when you set a default with the global <code>NULL{default}</code> and that default contains a keyword. For example in the type <code>"NULL{list()} numeric matrix"</code> <code>list</code> should not be considered as a main class, but only <code>matrix</code>. To be on the safe side, then just separate them with a pipe: <code>"NULL{list()} | numeric matrix"</code> would work appropriately.
</p>


<h3>Checking multiple arguments</h3>

<p>You can check multiple arguments at once provided they are of the same type. Say variables <code>x1</code> to <code>x5</code> should be logical scalars. Just use: <code>check_arg(x1, x2, x3, x4, x5, "logical scalar")</code>. It is always more efficient to check multiple arguments of the same type <em>at once</em>.
</p>
<p>It is important to note that in case of multiple arguments, you can place the type anywhere you want provided it is a character literal (and not in a variable!). This means that <code>check_arg("logical scalar", x1, x2, x3, x4, x5)</code> would also work.
</p>
<p>If your type is in a variable, then you must explicitly provide the argument <code>.type</code> (like in <code>check_arg(x, .type = my_type)</code>).
</p>


<h3>Nesting argument checking (<code>.up</code>)</h3>

<p>When you develop several functions that share common features, it is usually good practice to pool the common computations into an internal function (to avoid code duplication).
</p>
<p>When you do so, you can do all the argument checking in the internal function. Then use the argument <code>.up = 1</code> so that if the user provdes a wrong argument, the error message will refer to the user-level function and NOT to the internal function, making it much clearer for the user.
</p>
<p>This is detailed in Section XII) in the examples.
</p>


<h3>Checking the <code>...</code> (dot-dot-dot) argument</h3>

<p><code>check_arg</code> offers the possibility to check the <code>...</code>, provided each expected object in <code>...</code> should be of the same type. To do that, just add <code>...</code> as the first argument in <code>check_arg</code>, that's it! For example, you want all elements of <code>...</code> to be numeric vectors, then use <code>check_arg(..., "numeric vector")</code>.
</p>
<p>When checking <code>...</code>, you have the special global argument <code>dotnames</code> which enforces that each element in <code>...</code> has a name. Further, the other global <code>MBT</code> (must be there) now means that at least one element in <code>...</code> must be provided.
</p>
<p>This is detailed in Section XIV) in the examples.
</p>


<h3>What's the difference between <code>check_arg</code> and <code>check_set_arg</code>?</h3>

<p>The function <code>check_set_arg</code> extends <code>check_arg</code> in several ways. First it offers new keywords:
</p>

<ul>
<li> <p><code>evalset</code>: evaluates the argument in a data set (i.e. the argument can be variables names of a data set), then re-assigns back its value.
</p>
</li>
<li> <p><code>NULL{default}</code>: if the argument is <code>NULL</code>, then the value in curly brackets is assigned to the argument.
</p>
</li>
<li> <p><code>match</code>: if the argument partially matches the choices, then the matches are assigned to the argument.
</p>
</li>
<li> <p><code>conv</code>: in atomic main classes (<code>scalar</code>, <code>vector</code> and <code>matrix</code>), the data can be converted to a given sub-type (currently <code>integer</code>, <code>numeric</code>, <code>logical</code>, <code>character</code> and <code>factor</code>), then assigned back to the argument.
</p>
</li></ul>

<p>As you can see, it's all about assignment: these special keywords of <code>check_set_arg</code> will modify the arguments <em>in place</em>. You have such examples in Section II), III) and XI) of the examples.
</p>
<p>Second, it allows to check arguments that are themselves list of arguments (note that <code>conv</code> also works in that case). For example, one argument of your function is <code>plot.opts</code>, a list of arguments to be passed to plot. You can check the elements of <code>plot.opts</code> (e.g. <code>plot.opts$main</code>) with <code>check_set_arg</code>. It also re-assigns the values of the list given the special keywords just described. List element checking is described in Section XIII) of the examples.
</p>
<p>Then why creating two functions? If the user runs a function in which the arguments were checked with <code>check_arg</code> and it works, then argument checking can be safely disabled, and it would also work. On the other hand, since <code>check_set_arg</code> does value re-assignment, it cannot be safely turned-off&ndash;therefore cannot be disabled with <code><a href="#topic+setDreamerr_check">setDreamerr_check</a></code>. Distinguishing between the two allows the user to disable argument checking and gain (although very modest) perfomance in large loops. Therefore, when you create functions, I suggest to use always <code>check_arg</code>, unless you need the extra features of <code>check_set_arg</code>.
</p>


<h3><code>check_value</code></h3>

<p>The functions <code>check_value</code> and <code>check_set_value</code> are almost identical to the respective functions <code>check_arg</code> and <code>check_set_arg</code>. The key differences are as follows:
</p>

<ul>
<li><p> They can check values instead of arguments. Indeed, if you try to check a value with <code>check_arg</code>, nothing will happen (provided the name of the value is not an argument). Why? Because it will consider it as a missing argument. Therefore, you are can check anything with <code>check_value</code>.
</p>
</li>
<li><p> You can check only one item at a time (whereas you can check up to 10 arguments in <code>check_arg</code>).
</p>
</li></ul>

<p>The main reason for using <code>check_value</code> is that sometimes you only know if an argument is valid after having perfomed some modifications on it. For instance, the argument may be a formula, but you also require that the variables in the formula are numeric. You cannot check all that at once with <code>check_arg</code>, but you can first check the formula with it, then extract the values from the formula and use <code>check_value</code> to ensure that the variables from the formula are numeric.
</p>
<p><code>check_value</code> is detailed in Section XVI) in the examples.
</p>


<h3>Disabling argument checking</h3>

<p>Although the argument checking offered by <code>check_arg</code> is highly optimized and fast (it depends on the type (and your computer), but it is roughly of the order of 80 micro seconds for non-missing arguments, 20 micro seconds for missing arguments), you may want to disable it for small functions in large loops (&gt;100K iterations although this practice is not really common in R). If so, just use the function <code><a href="#topic+setDreamerr_check">setDreamerr_check</a></code>, by typing <code>setDreamerr_check(FALSE)</code>. This will disable any call to <code>check_arg</code>.
</p>
<p>Note that the argument checking of <code>check_set_arg</code> cannot be disabled because the special types it allows perform reassignment in the upper frame. That's the main difference with <code>check_arg</code>.
</p>


<h3>The developer mode</h3>

<p>If you're new to check_arg, given the many types available, it's very common to make mistakes when creating check_arg calls. But no worry, the developer mode is here to help!
</p>
<p>The developer mode ensures that any problematic call is spotted and the problem is clearly stated. It also refers to the related section in the examples if appropriate. To turn the developer mode on, use <code>setDreamerr_dev.mode(TRUE)</code>.
</p>
<p>Note that since this mode ensures a detailed cheking of the call it is thus a strain on performance and should be always turned off otherwise needed. See Section XV) in the examples.
</p>


<h3>Author(s)</h3>

<p>Laurent Berge
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# check_arg is only used within functions

#
# I) Example for the main class "scalar"
#

test_scalar = function(xlog, xnum, xint, xnumlt, xdate){
  # when forming the type: you can see that case, order and spaces don't matter
  check_arg(xlog, "scalarLogical")
  check_arg(xnum, "numeric scalar")
  check_arg(xint, "  scalar Integer GE{0}  ")
  check_arg(xnumlt, "numeric scalar lt{0.15}")

  # Below it is critical that there's no space between scalar and the parenthesis
  check_arg(xdate, "scalar(Date)")
  invisible(NULL)
}

# Following is OK
test_scalar()
test_scalar(xlog = FALSE, xnum = 55, xint = 5, xnumlt = 0.11, xdate = Sys.Date())

#
# Now errors, all the following are wrong arguments, leading to errors
# Please note the details in the error messages.

# logical
try(test_scalar(xlog = NA))
try(test_scalar(xlog = 2))
try(test_scalar(xlog = sum))
try(test_scalar(xlog = faefeaf5))
try(test_scalar(xlog = c(TRUE, FALSE)))
try(test_scalar(xlog = c()))

# numeric
try(test_scalar(xnum = NA))
try(test_scalar(xnum = 1:5))
try(test_scalar(xnum = Sys.Date()))

# integer
try(test_scalar(xint = 5.5))
try(test_scalar(xint = -1))

# num &lt; 0.15
try(test_scalar(xnumlt = 0.15))
try(test_scalar(xnumlt = 0.16))
try(test_scalar(xnumlt = Sys.Date()))

# Date
try(test_scalar(xdate = 0.15))


#
# II) Examples for the globals: NULL, L0, MBT, eval, evalset
#

test_globals = function(xnum, xlog = TRUE, xint){

  # Default setting with NULL is only available in check_set_arg
  # MBT (must be there) throws an error if the user doesn't provide the argument
  check_set_arg(xnum, "numeric vector NULL{1} MBT")

  # NULL allows NULL values
  check_arg(xlog, "logical scalar safe NULL")

  # use L0 to accept length-0 objects
  check_arg(xint, "integer vector L0")

  list(xnum = xnum, xlog = xlog)
}

# xnum is required because of MBT option
try(test_globals())

# NULL{expr} sets the value of xnum to expr if xnum = NULL
# Here NULL{1} sets xnum to 1
test_globals(xnum = NULL)

# NULL (not NULL{expr}) does not reassign: xlog remains NULL
test_globals(xnum = NULL, xlog = NULL)

# safe NULL: doesn't accept NULL from data.frame (DF) subselection
# ex: the variable 'log' does not exist in the iris DF
try(test_globals(5, xlog = iris$log))
# but xnum accepts it
test_globals(iris$log)

# L0 means not NULL, 0-length vectors are OK
# 0-length is OK for xint:
test_globals(xnum = 2, xint = integer(0))
# L0 still checks the type:
try(test_globals(2, xint = numeric(0)))

#
# eval and evalset
#

test_eval = function(x1, x2, data = list(), i = c()){
  check_arg(x1, "eval numeric vector", .data = data)

  # evalset is in check_set_arg
  check_set_arg(x2, "evalset numeric vector", .data = data)

 # We show the variables
 if(1 %in% i){
   cat("x1:\n")
   print(as.character(try(x1, silent = TRUE)))
 }

 if(2 %in% i){
   cat("x2:\n")
   print(as.character(try(x2, silent = TRUE)))
 }

}

# eval: evaluates the argument both in the environment and the data
test_eval(x1 = Sepal.Length, data = iris) # OK
# if we use a variable not in the environment nor in the data =&gt; error
try(test_eval(x1 = Sopal.Length, data = iris))

# but eval doesn't reassign back the value of the argument:
test_eval(x1 = Sepal.Length, data = iris, i = 1)

# evaset does the same as eval, but also reasssigns the value obtained:
test_eval(x2 = Sepal.Length, data = iris, i = 2)


#
# III) Match and charin
#

# match  =&gt; does partial matching, only available in check_set_arg
# charin =&gt; no partial matching, exact values required, but in check_arg

#
# match
#

# Note the three different ways to provide the choices
#
# If the argument has no default, it is kept that way (see x2)
# If the argument is not provided by the user,
#  it is left untouched (see x3)

test_match = function(x1 = c("bonjour", "Au revoir"), x2, x3 = "test"){
  # 1) choices set thanks to the argument default (like in match.arg)
  check_set_arg(x1, "strict match")

  # 2) choices set with the argument .choices
  check_set_arg(x2, "match", .choices = c("Sarah", "Santa", "Santa Fe", "SANTA"))

  # 3) choices set with the parentheses
  check_set_arg(x3, "multi match(Orange, Juice, Good)")

  cat("x1:", x1, "\nx2:", tryCatch(x2, error = function(e) "[missing]"), "\nx3:", x3, "\n")
}

# Everything below is OK
test_match()
test_match(x1 = "Au", x2 = "sar", x3 = c("GOOD", "or"))
test_match(x2 = "Santa")

# Errors caught:
try(test_match(x1 = c("Au", "revoir")))
try(test_match(x1 = "au"))
try(test_match(x1 = sum))
try(test_match(x1 = list(a = 1:5)))

try(test_match(x2 = "san"))
try(test_match(x2 = "santa"))

# Same value as x3's default, but now provided by the user
try(test_match(x3 = "test"))
try(test_match(x3 = c("or", "ju", "bad")))

# You can check multiple arguments at once
# [see details for multiple arguments in Section X)]
# Note that now the choices must be set in the argument
#  and they must have the same options (ie multi, strict)

test_match_multi = function(x1 = c("bonjour", "Au revoir"), x2 = c("Sarah", "Santa"),
                            x3 = c("Orange", "Juice", "Good")){

  # multiple arguments at once
  check_set_arg(x1, x2, x3, "match")

  cat("x1:", x1, "\nx2:", x2, "\nx3:", x3, "\n")
}

test_match_multi()

#
# charin
#

# charin is similar to match but requires the user to provide the exact value
# only the multi option is available

test_charin = function(x1 = "bonjour", x2  = "Sarah"){

  # 1) set the choices with .choices
  check_arg(x1, "charin", .choices = c("bonjour", "au revoir"))

  # 2) set the choices with the parentheses
  check_arg(x2, "multi charin(Sarah, Santa, Santa Fe)")

  cat("x1:", x1, "\nx2:", x2, "\n")
}

# Now we need the exact values
test_charin("au revoir", c("Santa", "Santa Fe"))

# Errors when partial matching tried
try(test_charin("au re"))


#
# IV) Vectors and marices, equalities, dimensions and lengths
#

# You can restrict the length of objects with len(a, b)
#    - if len(a, b) length must be in between a and b
#    - if len(a, ) length must be at least a
#    - if len(, b) length must be at most b
#    - if len(a) length must be equal to a
# You can also use the special keywords len(data) or len(value),
#  but then the argument .data or .value must also be provided.
#  (the related example comes later)
#
# You can restrict the number of rows/columns with nrow(a, b) and ncol(a, b)
#
# You can restrict a matrix to be square with the 'square' keyword
#
# You can restrict the values an element can take with GE/GT/LE/LT,
# respectively greater or equal/greater than/lower or equal/lower than
# The syntax is GE{expr}, with expr any expression
# Of course, it only works for numeric values
#
# By default NAs are tolerated in vector, matrix and data.frame.
# You can refuse NAs using the keyword: 'no na' or 'nona'
#

test_vmat = function(xvec, xmat, xvmat, xstmat, xnamed){
  # vector of integers with values between 5 and exp(3)
  check_arg(xvec, "integer Vector GE{5} LT{exp(3)}")

  # logical matrix with at least two rows and with 3 columns
  check_arg(xmat, "logicalMatrix NROW(2,) NCOL(3)")

  # vector or matrix (vmatrix) of integers or character strings
  # with at most 3 observations
  # NAs are not allowed
  check_arg(xvmat, "vmatrix(character, integer) nrow(,3) no na")

  # square matrix of integers, logicals reports errors
  check_arg(xstmat, "strict integer square Matrix")

  # A vector with names of length 2
  check_arg(xnamed, "named Vector len(2)")
  invisible(NULL)
}

# OK
test_vmat(xvec = 5:20, xmat = matrix(TRUE, 3, 3), xvmat = c("abc", 4, 3),
          xstmat = matrix(1:4, 2, 2), xnamed = c(bon=1, jour=2))

# Vector checks:
try(test_vmat(xvec = 2))
try(test_vmat(xvec = 21))
try(test_vmat(xvec = 5.5))

# Matrix checks:
try(test_vmat(xmat = matrix(TRUE, 3, 4)))
try(test_vmat(xmat = matrix(2, 3, 3)))
try(test_vmat(xmat = matrix(FALSE, 1, 3)))
try(test_vmat(xmat = iris))

try(test_vmat(xvmat = iris))
try(test_vmat(xvmat = c(NA, 5)))

try(test_vmat(xstmat = matrix(1, 1, 3)))
try(test_vmat(xstmat = matrix(c(TRUE, FALSE, NA), 3, 3)))

# Named vector checks:
try(test_vmat(xnamed = 1:3))
try(test_vmat(xnamed = c(bon=1, jour=2, les=3)))

#
# Illustration of the keywords 'data', 'value'
#

# 'value'
# Matrix multiplication X * Y * Z
test_dynamic_restriction = function(x, y, z){
  check_arg(x, "mbt numeric matrix")
  check_arg(y, "mbt numeric matrix nrow(value)", .value = ncol(x))
  check_arg(z, "mbt numeric matrix nrow(value)", .value = ncol(y))

  # An alternative to the previous two lines:
  # check_arg(z, "mbt numeric matrix")
  # check_arg(y, "mbt numeric matrix nrow(value) ncol(value)",
  #           .value = list(nrow = ncol(x), ncol = nrow(z)))

  x %*% y %*% z
}

x = matrix(1, 2, 3)
y = matrix(2, 3, 5)
z = matrix(rnorm(10), 5,  2)

test_dynamic_restriction(x, y, z)

# Now error
try(test_dynamic_restriction(x, matrix(5, 1, 2), z))

# 'data'
# Computing maximum difference between two matrices
test_dynamic_bis = function(x, y){
  check_arg(x, "mbt numeric matrix")
  # we require y to be of the same dimension as x
  check_arg(y, "mbt numeric matrix nrow(data) ncol(data)", .data = x)

  max(abs(x - y))
}

test_dynamic_bis(x, x)

# Now error
try(test_dynamic_bis(x, y))


#
# V) Functions and lists
#

# You can restrict the number of arguments of a
# function with arg(a, b) [see Section IV) for details]

test_funlist = function(xfun, xlist){
  check_arg(xfun, "function arg(1,2)")
  check_arg(xlist, "list len(,3)")
  invisible(NULL)
}

# OK
test_funlist(xfun = sum, xlist = iris[c(1,2)])

# function checks:
try(test_funlist(xfun = function(x, y, z) x + y + z))

# list checks:
try(test_funlist(xlist = iris[1:4]))
try(test_funlist(xlist = list()))


#
# VI) Data.frame and custom class
#

test_df = function(xdf, xvdf, xcustom){
  # data.frame with at least 100 observations
  check_arg(xdf, "data.frame nrow(100,)")

  # data.frame or vector (vdata.frame)
  check_arg(xvdf, "vdata.frame")

  # Either: i) object of class glm or lm
  # ii) NA
  # iii) NULL
  check_arg(xcustom, "class(lm, glm)|NA|null")
  invisible(NULL)
}

# OK
m = lm(Sepal.Length~Species, iris)
test_df(xdf = iris, xcustom = m)
test_df(xvdf = iris$Sepal.Length)
test_df(xcustom = NULL)

# data.frame checks:
try(test_df(xdf = iris[1:50,]))
try(test_df(xdf = iris[integer(0)]))
try(test_df(xdf = iris$Sepal.Length))
# Note that the following works:
test_df(xvdf = iris$Sepal.Length)

# Custom class checks:
try(test_df(xcustom = iris))

#
# VIII) Formulas
#

# The keyword is 'formula'
# You can restrict the formula to be:
# - one sided with 'os'
# - two sided with 'ts'
#
# You can restrict that the variables of a forumula must be in
# a data set or in the environment with var(data, env)
# - var(data) =&gt; variables must be in the data set
# - var(env) =&gt; variables must be in the environment
# - var(data, env) =&gt; variables must be in the data set or in the environment
# Of course, if var(data), you must provide a data set
#
# Checking multipart formulas is included. You can use left(a, b)
#  and right(a, b) to put restrictions in the number of parts allowed
#  in the left and right-hand-sides
#

test_formulas = function(fml1, fml2, fml3, fml4, data = iris){
  # Regular formula, variables must be in the data set
  check_arg(fml1, "formula var(data)", .data = data)

  # One sided formula, variables in the environment
  check_arg(fml2, "os formula var(env)")

  # Two sided formula, variables in the data set or in the env.
  check_arg(fml3, "ts formula var(data, env)", .data = data)

  # One or two sided, at most two parts in the RHS, at most 1 in the LHS
  check_arg(fml4, "formula left(,1) right(,2)")

  invisible(NULL)
}

# We set x1 in the environment
x1 = 5

# Works
test_formulas(~Sepal.Length, ~x1, Sepal.Length~x1, a ~ b, data = iris)

# Now let's see errors
try(test_formulas(Sepal.Length~x1, data = iris))

try(test_formulas(fml2 = ~Sepal.Length, data = iris))
try(test_formulas(fml2 = Sepal.Length~x1, data = iris))

try(test_formulas(fml3 = ~x1, data = iris))
try(test_formulas(fml3 = x1~x555, data = iris))

try(test_formulas(fml4 = a ~ b | c | d))
try(test_formulas(fml4 = a | b ~ c | d))



#
# IX) Multiple types
#

# You can check multiple types using a pipe: '|'
# Note that global keywords (like NULL, eval, l0, etc) need not be
# separated by pipes. They can be anywhere, the following are identical:
#  - "character scalar | data.frame NULL"
#  - "NULL character scalar | data.frame"
#  - "character scalar NULL | data.frame"
#  - "character scalar | data.frame | NULL"
#

test_mult = function(x){
  # x must be either:
  # i) a numeric vector of length at least 2
  # ii) a square character matrix
  # iii) an integer scalar (vector of length 1)
  check_arg(x, "numeric vector len(2,) | square character matrix | integer scalar")
  invisible(NULL)
}

# OK
test_mult(1)
test_mult(1:2)
test_mult(matrix("ok", 1, 1))

# Not OK, notice the very detailed error messages
try(test_mult(matrix("bonjour", 1, 2)))
try(test_mult(1.1))


#
# X) Multiple arguments
#

# You can check multiple arguments at once if they have the same type.
# You can add the type where you want but it must be a character literal.
# You can check up to 10 arguments with the same type.

test_multiarg = function(xlog1, xlog2, xnum1, xnum2, xnum3){
  # checking the logicals
  check_arg(xlog1, xlog2, "logical scalar")

  # checking the numerics
  # =&gt; Alternatively, you can add the type first
  check_arg("numeric vector", xnum1, xnum2, xnum3)

  invisible(NULL)
}

# Let's throw some errors
try(test_multiarg(xlog2 = 4))
try(test_multiarg(xnum3 = "test"))


#
# XI) Multiple sub-stypes
#

# For atomic arguments (like vector or matrices),
# you can check the type of underlying data: is it integer, numeric, etc?
# There are five simple sub-types:
# - integer
# - numeric
# - factor
# - logical
# - loose logical: either TRUE/FALSE, either 0/1
#
# If you require that the data is of one sub-type only:
# - a) if it's one of the simple sub-types: add the keyword directly in the type
# - b) otherwise: add the sub-type in parentheses
#
# Note that the parentheses MUST follow the main class directly.
#
# Example:
# - a) "integer scalar"
# - b) "scalar(Date)"
#
# If you want to check multiple sub-types: you must add them in parentheses.
# Again, the parentheses MUST follow the main class directly.
# Examples:
# "vector(character, factor)"
# "scalar(integer, logical)"
# "matrix(Date, integer, logical)"
#
# In check_set_arg, you can use the keyword "conv" to convert to the
# desired type
#

test_multi_subtypes = function(x, y){
  check_arg(x, "scalar(integer, logical)")
  check_arg(y, "vector(character, factor, Date)")
  invisible(NULL)
}

# What follows doesn't work
try(test_multi_subtypes(x = 5.5))

# Note that it works if x = 5
#  (for check_arg 5 is integer although is.integer(5) returns FALSE)
test_multi_subtypes(x = 5)

try(test_multi_subtypes(y = 5.5))

# Testing the "conv" keyword:

test_conv = function(x, type){
  check_set_arg(x, .type = type)
  x
}

class(test_conv(5L, "numeric scalar conv"))
class(test_conv(5, "integer scalar conv"))
class(test_conv(5, "integer scalar"))

# You can use the "conv" keyword in multi-types
# Remember that types are checked in ORDER! (see the behavior)
test_conv(5:1, "vector(logical, character conv)")
test_conv(c(TRUE, FALSE), "vector(logical, character conv)")


#
# XII) Nested checking: using .up
#

# Say you have two user level functions
# But you do all the computation in an internal function.
# The error message should be at the level of the user-level function
# You can use the argument .up to do that
#

sum_fun = function(x, y){
  my_internal(x, y, sum = TRUE)
}

diff_fun = function(x, y){
  my_internal(x, y, sum = FALSE)
}

my_internal = function(x, y, sum){
  # The error messages will be at the level of the user-level functions
  # which are 1 up the stack
  check_arg(x, y, "numeric scalar mbt", .up = 1)

  if(sum) return(x + y)
  return(x - y)
}

# we check it works
sum_fun(5, 6)
diff_fun(5, 6)

# Let's throw some errors
try(sum_fun(5))
try(diff_fun(5, 1:5))

# The errors are at the level of sum_fun/diff_fun although
# the arguments have been checked in my_internal.
# =&gt; much easier for the user to understand the problem


#
# XIII) Using check_set_arg to check and set list defaults
#

# Sometimes it is useful to have arguments that are themselves
# list of arguments.
# Witch check_set_arg you can check the arguments nested in lists
# and easily set default values at the same time.
#
# When you check a list element, you MUST use the syntax argument$element
#

# Function that performs a regression then plots it
plot_cor = function(x, y, lm.opts = list(), plot.opts = list(), line.opts = list()){

  check_arg(x, y, "numeric vector")

  # First we ensure the arguments are lists (even of 0-length)
  check_arg(lm.opts, plot.opts, line.opts, "named list L0")

  # The linear regression
  lm.opts$formula = y ~ x
  reg = do.call("lm", lm.opts)

  # plotting the correlation, with defaults
  check_set_arg(plot.opts$main, "character scalar NULL{'Correlation between x and y'}")

  # you can use variables created in the function when setting the default
  x_name = deparse(substitute(x))
  check_set_arg(plot.opts$xlab, "character scalar NULL{x_name}")
  check_set_arg(plot.opts$ylab, "character scalar NULL{'y'}")

  # we restrict to only two plotting types: p or h
  check_set_arg(plot.opts$type, "NULL{'p'} match(p, h)")

  plot.opts$x = x
  plot.opts$y = y
  do.call("plot", plot.opts)

  # with the fit
  check_set_arg(line.opts$col, "NULL{'firebrick'}") # no checking but default setting
  check_set_arg(line.opts$lwd, "integer scalar GE{0} NULL{2}") # check + default
  line.opts$a = reg
  do.call("abline", line.opts)
}

sepal_length = iris$Sepal.Length ; y = iris$Sepal.Width
plot_cor(sepal_length, y)

plot_cor(sepal_length, y, plot.opts = list(col = iris$Species, main = "Another title"))

# Now throwing errors
try(plot_cor(sepal_length, y, plot.opts = list(type = "l")))
try(plot_cor(sepal_length, y, line.opts = list(lwd = -50)))


#
# XIV) Checking '...' (dot-dot-dot)
#

# You can also check the '...' argument if you expect all objects
# to be of the same type.
#
# To do so, you MUST place the ... in the first argument of check_arg
#

sum_check = function(...){
  # we want each element of ... to be numeric vectors without NAs
  # we want at least one element to be there (mbt)
  check_arg(..., "numeric vector mbt")

  # once the check is done, we apply sum
  sum(...)
}

sum_check(1:5, 5:20)

# Now let's compare the behavior of sum_check() with that of sum()
# in the presence of errors
x = 1:5 ; y = pt
try(sum_check(x, y))
try(sum(x, y))

# As you can see, in the first call, it's very easy to spot and debug the problem
# while in the second call it's almost impossible



#
# XV) Developer mode
#

# If you're new to check_arg, given the many types available,
# it's very common to make mistakes when creating check_arg calls.
# The developer mode ensures that any problematic call is spotted
# and the problem is clearly stated
#
# Note that since this mode ensures a detailed cheking of the call
# it is thus a strain on performance and should be always turned off
# otherwise needed.
#

# Setting the developer mode on:
setDreamerr_dev.mode(TRUE)

# Creating some 'wrong' calls =&gt; the problem is pinpointed

test_err1 = function(x) check_arg(x, "integer scalar", "numeric vector")
try(test_err1())

test_err2 = function(...) check_arg("numeric vector", ...)
try(test_err2())

test_err3 = function(x) check_arg(x$a, "numeric vector")
try(test_err3())

test_err4 = function(x) check_arg(x, "numeric vector integer")
try(test_err4())

# Setting the developer mode off:
setDreamerr_dev.mode(FALSE)


#
# XVI) Using check_value
#

# The main function for checking arguments is check_arg.
# But sometimes you only know if an argument is valid after
#  having perfomed some modifications on it.
# =&gt; that's when check_value kicks in.
#
# It's better with an example.
#
# In this example we'll construct a plotting function
# using a formula, with a rock-solid argument checking.
#

# Plotting function, but using a formula
# You want to plot only numeric values
plot_fml = function(fml, data, ...){
  # We first check the arguments
  check_arg(data, "data.frame mbt")
  check_arg(fml, "ts formula mbt var(data)", .data = data)

  # We extract the values of the formula
  y = fml[[2]]
  x = fml[[3]]

  # Now we check that x and y are valid =&gt; with check_value
  # We also use the possibility to assign the value of y and x directly
  # We add a custom message because y/x are NOT arguments
  check_set_value(y, "evalset numeric vector", .data = data,
                   .message = "In the argument 'fml', the LHS must be numeric.")
  check_set_value(x, "evalset numeric vector", .data = data,
                   .message = "In the argument 'fml', the RHS must be numeric.")

  # The dots =&gt; only arguments to plot are valid
  args_ok = c(formalArgs(plot.default), names(par()))
  validate_dots(valid_args = args_ok, stop = TRUE)

  # We also set the xlab/ylab
  dots = list(...) # dots has a special meaning in check_value (no need to pass .message)
  check_set_value(dots$ylab, "NULL{deparse(fml[[2]])} character vector conv len(,3)")
  check_set_value(dots$xlab, "NULL{deparse(fml[[3]])} character vector conv len(,3)")

  dots$y = y
  dots$x = x

  do.call("plot", dots)

}

# Let's check it works
plot_fml(Sepal.Length ~ Petal.Length + Sepal.Width, iris)
plot_fml(Sepal.Length ~ Petal.Length + Sepal.Width, iris, xlab = "Not the default xlab")

# Now let's throw some errors
try(plot_fml(Sepal.Length ~ Species, iris))
try(plot_fml(Sepal.Length ~ Petal.Length, iris, xlab = iris))
try(plot_fml(Sepal.Length ~ Petal.Length, iris, xlab = iris$Species))



</code></pre>

<hr>
<h2 id='check_expr'>Checks the evaluation of an expression</h2><span id='topic+check_expr'></span><span id='topic+check_expr_hook'></span><span id='topic+generate_check_expr_hook'></span>

<h3>Description</h3>

<p>This functions checks the evaluation of an expression and, if an error is thrown,
captures it and integrates the captured message after a custom error message.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_expr(expr, ..., clean, up = 0, arg_name, verbatim = FALSE)

check_expr_hook(expr, ..., clean, arg_name, verbatim = FALSE)

generate_check_expr_hook(namespace)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="check_expr_+3A_expr">expr</code></td>
<td>
<p>An expression to be evaluated.</p>
</td></tr>
<tr><td><code id="check_expr_+3A_...">...</code></td>
<td>
<p>Character scalars. The values of <code>...</code> will be coerced with the function
<a href="https://lrberge.github.io/stringmagic/articles/guide_string_magic.html">string_magic</a>.
This means that string interpolation is allowed. Ex: <code>"Arg. {arg} should be positive"</code>
leads to <code>"Arg. power should be positive"</code> if <code>arg</code> is equal to &quot;power&quot;.
</p>
<p>If argument <code>verbatim</code> is <code>TRUE</code>, the values are instead coereced with <code>paste0</code>.</p>
</td></tr>
<tr><td><code id="check_expr_+3A_clean">clean</code></td>
<td>
<p>Character vector, default is missing. If provided, the function
<a href="https://lrberge.github.io/stringmagic/reference/string_clean.html"><code>string_clean</code></a>
is applied to the <em>captured error message</em> to clean it when necessary. Each element
of the vector should be of the form <code>"pat =&gt; rep"</code> with pat a regular expression
to be replace and <code>rep</code> the replacement.</p>
</td></tr>
<tr><td><code id="check_expr_+3A_up">up</code></td>
<td>
<p>Integer, default is 0. It is used to construct the call in the error message.
By default the call reported is the function containing <code>check_expr</code>. If you want to
report a function higher in the stack, use <code>up = 1</code>, or higher.</p>
</td></tr>
<tr><td><code id="check_expr_+3A_arg_name">arg_name</code></td>
<td>
<p>Character scalar, default is missing. Used when the expression in
<code>expr</code> leads to an error and the custom message is missing (i.e. no element is
provided in <code>...</code>). In that case, the default message is: &quot;The argument <code style="white-space: pre;">&#8288;{&#8288;</code>arg_name<code style="white-space: pre;">&#8288;}&#8288;</code> could not be evaluated.&quot;.
The default value for <code>arg_name</code> is <code>deparse(substitute(expr))</code>, if this guess is wrong,
use <code>arg_name</code>.</p>
</td></tr>
<tr><td><code id="check_expr_+3A_verbatim">verbatim</code></td>
<td>
<p>Logical scalar, default is <code>FALSE</code>. By default the elements of <code>...</code>
allow string interpolation with &quot;<code>{}</code>&quot; using <a href="https://github.com/lrberge/stringmagic">stringmagic</a>.
If <code>TRUE</code>, no interpolation is performed.</p>
</td></tr>
<tr><td><code id="check_expr_+3A_namespace">namespace</code></td>
<td>
<p>Character scalar giving the namespace for which the hooks are valid. Only useful
when hook functions are used in a package.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The purpose of this functions is to provide useful error messages to the user.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>check_expr_hook()</code>: As <code>check_expr</code> but sets the error call at the level of the hooked function
</p>
</li>
<li> <p><code>generate_check_expr_hook()</code>: Generates a package specific <code>check_expr_hook</code> function
</p>
</li></ul>


<h3>Author(s)</h3>

<p>Laurent Berge
</p>


<h3>See Also</h3>

<p>For general argument checking, see <code><a href="#topic+check_arg">check_arg()</a></code> and <code><a href="#topic+check_set_arg">check_set_arg()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
test = function(x, y){
  check_expr(mean(x, y), "Computing the mean didn't work:")
}


</code></pre>

<hr>
<h2 id='enumerate_items'>Enumerates the elements of a vector</h2><span id='topic+enumerate_items'></span>

<h3>Description</h3>

<p>Transforms a vector into a single character string enumerating the values of the vector. Many options exist to customize the result. The main purpose of this function is to ease the creation of user-level messages.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>enumerate_items(
  x,
  type,
  verb = FALSE,
  s = FALSE,
  past = FALSE,
  or = FALSE,
  start_verb = FALSE,
  quote = FALSE,
  enum = FALSE,
  other = "",
  nmax = 7
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="enumerate_items_+3A_x">x</code></td>
<td>
<p>A vector.</p>
</td></tr>
<tr><td><code id="enumerate_items_+3A_type">type</code></td>
<td>
<p>A single character string, optional. If this argument is used, it supersedes all other arguments. It compactly provides the arguments of the function: it must be like <code>"arg1.arg2.arg3"</code>, i.e. a list of arguments separated by a point. The arguments are: &quot;s&quot; (to add a starting s if <code>length(x)&gt;1</code>), &quot;or&quot; (to have &quot;or&quot; instead of &quot;and&quot;), &quot;start&quot; (to place the verb at the start instead of in the end), &quot;quote&quot; (to quote the elements of the vector), &quot;enum&quot; (to make an enumeration), &quot;past&quot; (to put the verb in past tense), a verb (i.e. anything different from the previous codes is a verb). Use <code>other(XX)</code> to set the argument <code>other</code> to <code>XX</code>. See details and examples.</p>
</td></tr>
<tr><td><code id="enumerate_items_+3A_verb">verb</code></td>
<td>
<p>Default is <code>FALSE</code>. If provided, a verb is added at the end of the string, at the appropriate form. You add the verb at the start of the string using the argument <code>start_verb</code>. Valid verbs are: &quot;be&quot;, &quot;is&quot;, &quot;has&quot;, &quot;have&quot;, and any other verb with a regular form.</p>
</td></tr>
<tr><td><code id="enumerate_items_+3A_s">s</code></td>
<td>
<p>Logical, default is <code>FALSE</code>. If <code>TRUE</code> a <code>s</code> is added at the beginning of the string if the length of <code>x</code> is greater than one.</p>
</td></tr>
<tr><td><code id="enumerate_items_+3A_past">past</code></td>
<td>
<p>Logical, default is <code>FALSE</code>. If <code>TRUE</code> the verb is put at the past tense.</p>
</td></tr>
<tr><td><code id="enumerate_items_+3A_or">or</code></td>
<td>
<p>Logical, default is <code>FALSE</code>. If <code>TRUE</code> the two last items of the vector are separated by &quot;or&quot; instead of &quot;and&quot;.</p>
</td></tr>
<tr><td><code id="enumerate_items_+3A_start_verb">start_verb</code></td>
<td>
<p>Logical, default is <code>FALSE</code>. If <code>TRUE</code> the verb is placed at the beginning of the string instead of the end.</p>
</td></tr>
<tr><td><code id="enumerate_items_+3A_quote">quote</code></td>
<td>
<p>Logical, default is <code>FALSE</code>. If <code>TRUE</code> all items are put in between single quotes.</p>
</td></tr>
<tr><td><code id="enumerate_items_+3A_enum">enum</code></td>
<td>
<p>Logical, default is <code>FALSE</code>. If provided, an enumeration of the items of <code>x</code> is created. The possible values are &quot;i&quot;, &quot;I&quot;, &quot;1&quot;, &quot;a&quot; and &quot;A&quot;. Example: <code>x = c(5, 3, 12)</code>, <code>enum = "i"</code> will lead to &quot;i) 5, ii) 3, and iii) 12&quot;.</p>
</td></tr>
<tr><td><code id="enumerate_items_+3A_other">other</code></td>
<td>
<p>Character scalar, defaults to the empty string: <code>""</code>. If there are more than <code>nmax</code> elements, then the character string will end with <code>"and XX others"</code> with <code>XX</code> the number of remaining items. Use this argument to change what is between the <code>and</code> and the <code>XX</code>. E.g. if <code>other = "any of"</code>, then you would get <code>"... and any of 15 others"</code> instead of <code>"... and 15 others"</code>.</p>
</td></tr>
<tr><td><code id="enumerate_items_+3A_nmax">nmax</code></td>
<td>
<p>Integer, default is 7. If <code>x</code> contains more than <code>nmax</code> items, then these items are grouped into an &quot;other&quot; group.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>It returns a character string of lentgh one.
</p>


<h3>The argument <code>type</code></h3>

<p>The argument <code>type</code> is a &quot;super argument&quot;. When provided, it supersedes all other arguments. It offers a compact way to give the arguments to the function.
</p>
<p>Its sytax is as follows: <code>"arg1.arg2.arg2"</code>, where <code>argX</code> is an argument code. The codes are &quot;s&quot;, &quot;past&quot;, &quot;or&quot;, &quot;start&quot;, &quot;quote&quot;, &quot;enum&quot; &ndash; they refer to the function arguments. If you want to add a verb, since it can have a free-form, it is deduced as the argument not equal to the previous codes. For example, if you have <code>type = "s.contain"</code>, this is identical to calling the function with <code>s = TRUE</code> and <code>verb = "contain"</code>.
</p>
<p>A note on <code>enum</code>. The argument <code>enum</code> can be equal to &quot;i&quot;, &quot;I&quot;, &quot;a&quot;, &quot;A&quot; or &quot;1&quot;. When you include it in <code>type</code>, by default &quot;i&quot; is used. If you want another one, add it in the code. For example <code>type = "is.enum a.past"</code> is identical to calling the function with <code>verb = "is"</code>, <code>past = TRUE</code> and <code>enum = "a"</code>.
</p>


<h3>Author(s)</h3>

<p>Laurent Berge
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Let's say you write an error/information message to the user
# I just use the "type" argument but you can obtain the
#  same results by using regular arguments

x = c("x1", "height", "width")
message("The variable", enumerate_items(x, "s.is"), " not in the data set.")
# Now just the first item
message("The variable", enumerate_items(x[1], "s.is"), " not in the data set.")

# Past
message("The variable", enumerate_items(x, "s.is.past"), " not found.")
message("The variable", enumerate_items(x[1], "s.is.past"), " not found.")

# Verb first
message("The problematic variable", enumerate_items(x, "s.is.start.quote"), ".")
message("The problematic variable", enumerate_items(x[1], "s.is.start.quote"), ".")

# covid times
todo = c("wash your hands", "stay home", "code")
message("You should: ", enumerate_items(todo[c(1, 1, 2, 3)], "enum 1"), "!")
message("You should: ", enumerate_items(todo, "enum.or"), "?")


</code></pre>

<hr>
<h2 id='fit_screen'>Nicely fits a message in the current R console</h2><span id='topic+fit_screen'></span>

<h3>Description</h3>

<p>Utility to display long messages with nice formatting. This function cuts the message to fit the current screen width of the R console. Words are never cut in the middle.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit_screen(msg, width = NULL, leading_ws = TRUE, leader = "")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fit_screen_+3A_msg">msg</code></td>
<td>
<p>Text message: character vector.</p>
</td></tr>
<tr><td><code id="fit_screen_+3A_width">width</code></td>
<td>
<p>A number between 0 and 1, or an integer. The maximum width of the screen the message should take.
Numbers between 0 and 1 represent a fraction of the screen. You can also refer to the
screen width with the special variable <code>.sw</code>. Integers represent the number of characters
and cannot be lower than 15. Default is <code>min(120, 0.95*.sw)</code> (the min between 120 characters and
90% of the screen width).</p>
</td></tr>
<tr><td><code id="fit_screen_+3A_leading_ws">leading_ws</code></td>
<td>
<p>Logical, default is <code>TRUE</code>. Whether to keep the leading
white spaces when the line is cut.</p>
</td></tr>
<tr><td><code id="fit_screen_+3A_leader">leader</code></td>
<td>
<p>Character scalar, default is the empty string. If provided, this
value will be placed in front of every line.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function does not handle tabulations.
</p>


<h3>Value</h3>

<p>It returns a single character vector with line breaks at the appropriate width.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# A long message of two lines with a few leading spaces
msg = enumerate_items(state.name, nmax = Inf)
msg = paste0("     ", gsub("Michigan, ", "\n", msg))

# by default the message takes 95% of the screen
cat(fit_screen(msg))

# Now we reduce it to 50%
cat(fit_screen(msg, 0.5))

# we add leading_ws = FALSE to avoid the continuation of leading WS
cat(fit_screen(msg, 0.5, FALSE))

# We add "#&gt; " in front of each line
cat(fit_screen(msg, 0.5, leader = "#&gt; "))


</code></pre>

<hr>
<h2 id='fsignif'>Formatting numbers with display of significant digits</h2><span id='topic+fsignif'></span><span id='topic+signif_plus'></span>

<h3>Description</h3>

<p>Formatting of numbers, when they are to appear in messages. Displays only significant digits in a &quot;nice way&quot; and adds commas to separate thousands. It does much less than the <code><a href="base.html#topic+format">format</a></code> function, but also a bit more though.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fsignif(x, s = 2, r = 0, commas = TRUE)

signif_plus
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fsignif_+3A_x">x</code></td>
<td>
<p>A numeric vector.</p>
</td></tr>
<tr><td><code id="fsignif_+3A_s">s</code></td>
<td>
<p>The number of significant digits to be displayed. Defaults to 2. All digits not in the decimal are always shown.</p>
</td></tr>
<tr><td><code id="fsignif_+3A_r">r</code></td>
<td>
<p>For large values, the number of digits after the decimals to be displayed (beyond the number of significant digits). Defaults to 0. It is useful to suggest that a number is not an integer.</p>
</td></tr>
<tr><td><code id="fsignif_+3A_commas">commas</code></td>
<td>
<p>Whether or not to add commas to separate thousands. Defaults to <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Format</h3>

<p>An object of class <code>function</code> of length 1.
</p>


<h3>Value</h3>

<p>It returns a character vector of the same length as the input.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x = rnorm(1e5)
x[sample(1e5, 1e4, TRUE)] = NA

# Dumb function telling the number of NA values
tell_na = function(x) message("x contains ", fsignif(sum(is.na(x))), " NA values.")

tell_na(x)

# Some differences with signif:
show_diff = function(x, d = 2) cat("signif(x, ", d, ") -&gt; ", signif(x, d),
                                   " vs fsignif(x, ", d, ") -&gt; ",
                                   fsignif(x, d), "\n", sep = "")

# Main difference is for large numbers
show_diff(95123.125)
show_diff(95123.125, 7)

# Identical for small numbers
show_diff(pi / 500)


</code></pre>

<hr>
<h2 id='generate_set_hook'>Error displaying a call located at a hook location</h2><span id='topic+generate_set_hook'></span><span id='topic+generate_stop_hook'></span><span id='topic+generate_warn_hook'></span><span id='topic+set_hook'></span><span id='topic+generate_get_hook'></span><span id='topic+stop_hook'></span><span id='topic+warn_hook'></span>

<h3>Description</h3>

<p>When devising complex functions, errors or warnings can be deeply nested in internal
function calls while the user-relevant call is way up the stack. In such cases, these &quot;hook&quot;
functions facilitate the creation of error/warnings informative for the user.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate_set_hook(namespace)

generate_stop_hook(namespace)

generate_warn_hook(namespace)

set_hook()

generate_get_hook(namespace)

stop_hook(..., msg = NULL, envir = parent.frame(), verbatim = FALSE)

warn_hook(..., envir = parent.frame(), immediate. = FALSE, verbatim = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="generate_set_hook_+3A_namespace">namespace</code></td>
<td>
<p>Character scalar giving the namespace for which the hooks are valid. Only useful
when hook functions are used in a package.</p>
</td></tr>
<tr><td><code id="generate_set_hook_+3A_...">...</code></td>
<td>
<p>Objects that will be coerced to character and will compose the error message.</p>
</td></tr>
<tr><td><code id="generate_set_hook_+3A_msg">msg</code></td>
<td>
<p>A character vector, default is <code>NULL</code>. If provided, this message will be displayed right under the error message. This is mostly useful when the text contains formatting because the function <code><a href="base.html#topic+stop">stop</a></code> used to send the error message erases any formatting.</p>
</td></tr>
<tr><td><code id="generate_set_hook_+3A_envir">envir</code></td>
<td>
<p>An environment, default is <code>parent.frame()</code>. Only relevant if the error/warning message contains
interpolation (interpolation is performed with <a href="https://github.com/lrberge/stringmagic">stringmagic</a>). It tells
where the variables to be interpolated should be found. In general you should not worry about this argument.</p>
</td></tr>
<tr><td><code id="generate_set_hook_+3A_verbatim">verbatim</code></td>
<td>
<p>Logical scalar, default is <code>FALSE</code>. By default the error/warning message allows variable
interpolation with <a href="https://github.com/lrberge/stringmagic">stringmagic</a>. To disable interpolation,
use <code>verbatim = TRUE</code>.</p>
</td></tr>
<tr><td><code id="generate_set_hook_+3A_immediate.">immediate.</code></td>
<td>
<p>Whether the warning message should be prompted directly. Defaults to <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions are useful when developing complex functions relying on nested internal functions.
It is important for the user to know where the errors/warnings come from for quick debugging.
This &quot;_hook&quot; family of functions write the call of the user-level function even if the errors
happen at the level of the internal functions.
</p>
<p>If you need these functions within a package, you need to generate the <code>set_hook</code>, <code>stop_hook</code> and
<code>warn_hook</code> functions so that they set, and look up for, hooks speficic to your function. This ensures that
if other functions outside your package also use hooks, there will be no conflict. The only thing to do
is to write this somewhere in the package files:
</p>
<div class="sourceCode R"><pre>set_hook = generate_set_hook("pkg_name")
stop_hook = generate_stop_hook("pkg_name")
warn_hook = generate_warn_hook("pkg_name")
</pre></div>


<h3>Functions</h3>


<ul>
<li> <p><code>generate_set_hook()</code>: Generates a package specific <code>set_hook</code> function
</p>
</li>
<li> <p><code>generate_stop_hook()</code>: Generates a package specific <code>stop_hook</code> function
</p>
</li>
<li> <p><code>generate_warn_hook()</code>: Generates a package specific <code>warn_hook</code> function
</p>
</li>
<li> <p><code>set_hook()</code>: Marks the function as the hook
</p>
</li>
<li> <p><code>generate_get_hook()</code>: Generates the function giving the number of frames we
need to go up the call stack to find the hooked function
</p>
</li>
<li> <p><code>warn_hook()</code>: Warning with a call located at a hook location
</p>
</li></ul>


<h3>Author(s)</h3>

<p>Laurent Berge
</p>


<h3>See Also</h3>

<p>Regular stop functions with interpolation: <code><a href="#topic+stop_up">stop_up()</a></code>. Regular argument checking
with <code><a href="#topic+check_arg">check_arg()</a></code> and <code><a href="#topic+check_set_arg">check_set_arg()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# The example needs to be complex since it's about nested functions, sorry
# Let's say you have an internal function that is dispatched into several 
# user-level functions

my_mean = function(x, drop_na = FALSE){
  set_hook()
  my_mean_internal(x = x, drop_na = drop_na)
}

my_mean_skip_na = function(x){
  set_hook()
  my_mean_internal(x = x, drop_na = TRUE)
}

my_mean_internal = function(x, drop_na){
  # simple check
  if(!is.numeric(x)){
    # note that we use string interpolation with stringmagic.
    stop_hook("The argument `x` must be numeric. PROBLEM: it is of class {enum.bq ? class(x)}.")
  }

  if(drop_na){
    return(mean(x, na.rm = TRUE))
  } else {
    return(mean(x, na.rm = FALSE))
  }
}

# Let's run the function with a wrong argument
x = "five"
try(my_mean(x))

# =&gt; the error message reports that the error comes from my_mean 
#    and *not* my_mean_internal
 

</code></pre>

<hr>
<h2 id='ifsingle'>Conditional element selection</h2><span id='topic+ifsingle'></span><span id='topic+ifunit'></span>

<h3>Description</h3>

<p>Tiny functions shorter, and hopefully more explicit, than <code>ifelse</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ifsingle(x, yes, no)

ifunit(x, yes, no)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ifsingle_+3A_x">x</code></td>
<td>
<p>A vector (<code>ifsingle</code>) or a numeric of length 1 (<code>ifunit</code>).</p>
</td></tr>
<tr><td><code id="ifsingle_+3A_yes">yes</code></td>
<td>
<p>Something of length 1. Result if the condition is fulfilled.</p>
</td></tr>
<tr><td><code id="ifsingle_+3A_no">no</code></td>
<td>
<p>Something of length 1. Result if the condition is not fulfilled.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Yes, <code>ifunit</code> is identical to <code>ifelse(test == 1, yes, no)</code>. And regarding <code>ifsingle</code>, it is identical to <code>ifelse(length(test) == 1, yes, no)</code>.
</p>
<p>Why writing these functions then? Actually, I've found that they make the code more explicit, and this helps!
</p>


<h3>Value</h3>

<p>Returns something of length 1.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>ifunit()</code>: Conditional element selection depending on whether <code>x</code> is equal to unity or not.
</p>
</li></ul>


<h3>Author(s)</h3>

<p>Laurent Berge
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Let's create an error message when NAs are present
my_crossprod = function(mat){
 if(anyNA(mat)){
   row_na = which(rowSums(is.na(mat)) &gt; 0)
   n_na = length(row_na)
   stop("In argument 'mat': ", n_letter(n_na), " row", plural(n_na, "s.contain"),
        " NA values (", ifelse(n_na&lt;=3, "", "e.g. "), "row",
        enumerate_items(head(row_na, 3), "s"), ").
        Please remove ", ifunit(n_na, "it", "them"), " first.")
 }
 crossprod(mat)
}

mat = matrix(rnorm(30), 10, 3)
mat4 = mat1 = mat
mat4[c(1, 7, 13, 28)] = NA
mat1[7] = NA

# Error raised because of NA: informative (and nice) messages
try(my_crossprod(mat4))
try(my_crossprod(mat1))


</code></pre>

<hr>
<h2 id='n_times'>Numbers in letters</h2><span id='topic+n_times'></span><span id='topic+n_th'></span><span id='topic+n_letter'></span>

<h3>Description</h3>

<p>Set of (tiny) functions that convert integers into words.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>n_times(n)

n_th(n)

n_letter(n)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="n_times_+3A_n">n</code></td>
<td>
<p>An integer vector.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>It returns a character vector of length one.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>n_th()</code>: Transforms the integer <code>n</code> to <code>nth</code> appropiately.
</p>
</li>
<li> <p><code>n_letter()</code>: Transforms small integers to words.
</p>
</li></ul>


<h3>Author(s)</h3>

<p>Laurent Berge
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
find = function(v, x){
  if(x %in% v){
    message("The number ", n_letter(x), " appears ", n_times(sum(v == x)),
            ", the first occurrence is the ", n_th(which(v==x)[1]), " element.")
  } else message("The number ", n_letter(x), " was not found.")
}

v = sample(100, 500, TRUE)
find(v, 6)



</code></pre>

<hr>
<h2 id='package_stats'>Provides package statistics</h2><span id='topic+package_stats'></span>

<h3>Description</h3>

<p>Summary statistics of a packages: number of lines, number of functions, etc...
</p>


<h3>Usage</h3>

<pre><code class='language-R'>package_stats()
</code></pre>


<h3>Details</h3>

<p>This function looks for files in the <code>R/</code> and <code>src/</code> folders and gives some stats. If there is no <code>R/</code> folder directly accessible from the working directory, there will be no stats displayed.
</p>
<p>Why this function? Well, it's just some goodies for package developers trying to be user-friendly!
</p>
<p>The number of documentation lines (and number of words) corresponds to the number of non-empty roxygen documentation lines. So if you don't document your code with roxygen, well, this stat won't prompt.
</p>
<p>Code lines correspond to non-commented, non-empty lines (by non empty: at least one letter must appear).
</p>
<p>Comment lines are non-empty comments.
</p>


<h3>Value</h3>

<p>Doesn't return anything, just a prompt in the console.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
package_stats()

</code></pre>

<hr>
<h2 id='plural'>Adds an s and/or a singular/plural verb depending on the argument's length</h2><span id='topic+plural'></span><span id='topic+plural_len'></span>

<h3>Description</h3>

<p>Utilities to write user-level messages. These functions add an &lsquo;s&rsquo; or a verb at the appropriate form depending on whether the argument is equal to unity (<code>plural</code>) or of length one (<code>plural_len</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plural(x, type, s, verb = FALSE, past = FALSE)

plural_len(x, type, s, verb = FALSE, past = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plural_+3A_x">x</code></td>
<td>
<p>An integer of length one (<code>plural</code>) or a vector <code>plural_len</code>.</p>
</td></tr>
<tr><td><code id="plural_+3A_type">type</code></td>
<td>
<p>Character string, default is missing. If <code>type = "s.is.past"</code> it means that an &quot;s&quot; will be added if <code>x</code> is greater than 1 (or of length greater than one for <code>plural_len</code>); it will be followed by the verb &quot;to be&quot; in past tense in singular or plural form depending on <code>x</code>. This argument must be made of keywords separated by points without space, the keywords are &quot;s&quot;, &quot;past&quot; and a verb (i.e. any thing different than &quot;s&quot; and &quot;past&quot;). Missing keywords mean their value is equal to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="plural_+3A_s">s</code></td>
<td>
<p>Logical, used only if the argument type is missing. Whether to add an &quot;s&quot; if the form of <code>x</code> is plural. Default is missing: equals to <code>TRUE</code> if no other argument is provided, <code>FALSE</code> otherwise.</p>
</td></tr>
<tr><td><code id="plural_+3A_verb">verb</code></td>
<td>
<p>Character string or <code>FALSE</code>, used only if the argument type is missing. The verb to be inserted in singular or plural depending on the value of <code>x</code>. default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="plural_+3A_past">past</code></td>
<td>
<p>Logical, used only if the argument type is missing. Whether the verb should be in past tense. Default is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a character string of length one.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>plural_len()</code>: Adds an s and conjugate a verb depending on the length of <code>x</code>
</p>
</li></ul>


<h3>Author(s)</h3>

<p>Laurent Berge
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Let's create an error message when NAs are present
my_crossprod = function(mat){
 if(anyNA(mat)){
   row_na = which(rowSums(is.na(mat)) &gt; 0)
   n_na = length(row_na)
   stop("In argument 'mat': ", n_letter(n_na), " row", plural(n_na, "s.contain"),
        " NA values (", ifelse(n_na&lt;=3, "", "e.g. "), "row",
        enumerate_items(head(row_na, 3), "s"),
        "). Please remove ", ifunit(n_na, "it", "them"), " first.")
 }
 crossprod(mat)
}

mat = matrix(rnorm(30), 10, 3)
mat4 = mat1 = mat
mat4[c(1, 7, 13, 28)] = NA
mat1[7] = NA

# Error raised because of NA: informative (and nice) messages
try(my_crossprod(mat4))
try(my_crossprod(mat1))

</code></pre>

<hr>
<h2 id='set_check'>Sets argument checking on/off &quot;semi-globally&quot;</h2><span id='topic+set_check'></span>

<h3>Description</h3>

<p>You can allow your users to turn off argument checking within your function by using <code>set_check</code>. Only the functions <code><a href="#topic+check_arg">check_arg</a></code> nd <code><a href="#topic+check_arg">check_value</a></code> can be turned off that way.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_check(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="set_check_+3A_x">x</code></td>
<td>
<p>A logical scalar, no default.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function can be useful if you develop a function that may be used in large range loops (&gt;100K). In such situations, it may be good to still check all arguments, but to offer the user to turn this checking off with an extra argument (named <code>arg.check</code> for instance). Doing so you would achieve the feat of i) having a user-friendly function thanks to argument checking and, ii) still achieve high performance in large loops (although the computational footprint of argument checking is quite low (around 30 micro seconds for missing arguments to 80 micro seconds for non-missing arguments of simple type)).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Let's give an example
test_check = function(x, y, arg.check = TRUE){
  set_check(arg.check)
  check_arg(x, y, "numeric scalar")
  x + y
}

# Works: argument checking on
test_check(1, 2)

# If mistake, nice error msg
try(test_check(1, "a"))

# Now argument checking turned off
test_check(1, 2, FALSE)
# But if mistake: "not nice" error message
try(test_check(1, "a", FALSE))



</code></pre>

<hr>
<h2 id='set_up'>Sets &quot;semi-globally&quot; the 'up' argument of dreamerr's functions</h2><span id='topic+set_up'></span>

<h3>Description</h3>

<p>When <code><a href="#topic+check_arg">check_arg</a></code> (or <code><a href="#topic+stop_up">stop_up</a></code>) is used in non user-level functions, the argument <code>.up</code> is used to provide an appropriate error message referencing the right function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_up(.up = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="set_up_+3A_.up">.up</code></td>
<td>
<p>An integer greater or equal to 0.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>To avoid repeating the argument <code>.up</code> in each <code>check_arg</code> call, you can set it (kind of) &quot;globally&quot; with <code>set_up</code>.
</p>
<p>The function <code>set_up</code> does not set the argument <code>up</code> globally, but only for all calls to <code>check_arg</code> and <code>check_value</code> within the same function.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Example with computation being made within a non user-level function

sum_fun = function(x, y){
  my_internal(x, y, sum = TRUE)
}

diff_fun = function(x, y){
  my_internal(x, y, sum = FALSE)
}

my_internal = function(x, y, sum){
  set_up(1) # =&gt; errors will be at the user-level function
  check_arg(x, y, "numeric scalar mbt")

  # Identical to calling
  # check_arg(x, y, "numeric scalar mbt", .up = 1)

  if(sum) return(x + y)
  return(x - y)
}

# we check it works
sum_fun(5, 6)
diff_fun(5, 6)

# Let's throw some errors
try(sum_fun(5))
try(sum_fun(5, 1:5))

</code></pre>

<hr>
<h2 id='setDreamerr_check'>Sets dreamerr argument checking functions on or off</h2><span id='topic+setDreamerr_check'></span>

<h3>Description</h3>

<p>This function allows to disable, or re-enable, all calls to <code><a href="#topic+check_arg">check_arg</a></code> within any function. Useful only when running (very) large loops (&gt;100K iter.) over small functions that use dreamerr's <code><a href="#topic+check_arg">check_arg</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setDreamerr_check(check = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="setDreamerr_check_+3A_check">check</code></td>
<td>
<p>Strict logical: either <code>TRUE</code> of <code>FALSE</code>. Default is <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Laurent Berge
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Let's create a small function that returns the argument
#  if it is a single character string, and throws an error
#  otherwise:

test = function(x){
  check_arg(x, "scalar character")
  x
}

# works:
test("hey")
# error:
try(test(55))

# Now we disable argument checking
setDreamerr_check(FALSE)
# works (although it shouldn't!):
test(55)

# re-setting argument checking on:
setDreamerr_check(TRUE)


</code></pre>

<hr>
<h2 id='setDreamerr_dev.mode'>Sets the developer mode to help form check_arg calls</h2><span id='topic+setDreamerr_dev.mode'></span>

<h3>Description</h3>

<p>Turns on/off a full fledged checking of calls to <code><a href="#topic+check_arg">check_arg</a></code>. If on, it enables the developer mode which checks extensively calls to check_arg, allowing to find any problem. If a problem is found, it is pinpointed and the associated help is referred to.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setDreamerr_dev.mode(dev.mode = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="setDreamerr_dev.mode_+3A_dev.mode">dev.mode</code></td>
<td>
<p>A logical, default is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Since this mode ensures a detailed cheking of all <code><a href="#topic+check_arg">check_arg</a></code> calls, it is thus a strain on performance and should be always turned off otherwise needed.
</p>


<h3>Author(s)</h3>

<p>Laurent Berge
</p>


<h3>See Also</h3>

<p><code><a href="#topic+check_arg">check_arg</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# If you're new to check_arg, given the many types available,
# it's very common to make mistakes when creating check_arg calls.
# The developer mode ensures that any problematic call is spotted
# and the problem is clearly stated
#
# Note that since this mode ensures a detailed cheking of the call
# it is thus a strain on performance and should be always turned off
# otherwise needed.
#

# Setting the developer mode on:
setDreamerr_dev.mode(TRUE)

# Creating some 'wrong' calls =&gt; the problem is pinpointed

test = function(x) check_arg(x, "integer scalar", "numeric vector")
try(test())

test = function(...) check_arg("numeric vector", ...)
try(test())

test = function(x) check_arg(x$a, "numeric vector")
try(test())

test = function(x) check_arg(x, "numeric vector integer")
try(test())

test = function(x) check_arg(x, "vector len(,)")
try(test())

# etc...

# Setting the developer mode off:
setDreamerr_dev.mode(FALSE)


</code></pre>

<hr>
<h2 id='setDreamerr_show_stack'>Settings telling whether or not to display the full call stack on errors</h2><span id='topic+setDreamerr_show_stack'></span>

<h3>Description</h3>

<p>Errors generated with dreamerr functions only shows the call to which
the error should point to. If <code>setDreamerr_show_stack</code> is set to TRUE,
error will display the full call stack instead.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setDreamerr_show_stack(show_full_stack = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="setDreamerr_show_stack_+3A_show_full_stack">show_full_stack</code></td>
<td>
<p>Logical scalar, default is <code>FALSE</code>. If <code>TRUE</code>, then
errors generated by dreamerr functions (like <code><a href="#topic+stop_up">stop_up()</a></code>/<code><a href="#topic+stopi">stopi()</a></code>) will display
the full call stack.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Laurent Berge
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Let's create a toy example of a function relying on an internal function
# for the heavy lifting (although here it's pretty light!)
make_sum = function(a, b){
  make_sum_internal(a, b)
}

make_sum_internal = function(a, b){
  if(!is.numeric(a)) stop_up("arg. 'a' must be numeric!")
  a + b
}

# By default if you feed stg non numeric, the call shown is 
# make_sum, and not make_sum_internal, since the user could not
# care less of the internal structure of your functions

try(make_sum("five", 55))

# Now with setDreamerr_show_stack(TRUE), you would get the full call stack
setDreamerr_show_stack(TRUE)
try(make_sum("five", 55))



</code></pre>

<hr>
<h2 id='sfill'>Fills a string vector with a symbol</h2><span id='topic+sfill'></span>

<h3>Description</h3>

<p>Fills a string vector with a user-provided symbol, up to the required length.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sfill(x = "", n = NULL, symbol = " ", right = FALSE, anchor, na = "NA")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sfill_+3A_x">x</code></td>
<td>
<p>A character vector.</p>
</td></tr>
<tr><td><code id="sfill_+3A_n">n</code></td>
<td>
<p>A positive integer giving the total expected length of each character string. Can be NULL (default). If <code>NULL</code>, then <code>n</code> is set to the maximum number of characters in <code>x</code> (i.e. <code>max(nchar(x))</code>).</p>
</td></tr>
<tr><td><code id="sfill_+3A_symbol">symbol</code></td>
<td>
<p>Character scalar, default to <code>" "</code>. The symbol used to fill.</p>
</td></tr>
<tr><td><code id="sfill_+3A_right">right</code></td>
<td>
<p>Logical, default is <code>FALSE</code>. Whether the character vector should be filled on the left( default) or on the right.</p>
</td></tr>
<tr><td><code id="sfill_+3A_anchor">anchor</code></td>
<td>
<p>Character scalar, can be missing. If provided, the filling is done up to this anchor. See examples.</p>
</td></tr>
<tr><td><code id="sfill_+3A_na">na</code></td>
<td>
<p>Character that will replace any NA value in input. Default is &quot;NA&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a character vector of the same length as <code>x</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Some self-explaining examples
x = c("hello", "I", "am", "No-one")
cat(sep = "\n", sfill(x))
cat(sep = "\n", sfill(x, symbol = "."))
cat(sep = "\n", sfill(x, symbol = ".", n = 15))
cat(sep = "\n", sfill(x, symbol = ".", right = TRUE))

cat(sep = "\n", paste(sfill(x, symbol = ".", right = TRUE), ":", 1:4))

# Argument 'anchor' can be useful when using numeric vectors
x = c(-15.5, 1253, 32.52, 665.542)
cat(sep = "\n", sfill(x))
cat(sep = "\n", sfill(x, anchor = "."))

</code></pre>

<hr>
<h2 id='stop_up'>Stops (or warns in) sub-function execution</h2><span id='topic+stop_up'></span><span id='topic+stopi'></span><span id='topic+warni'></span><span id='topic+warn_up'></span>

<h3>Description</h3>

<p>Useful if you employ non-user level sub-functions within user-level functions or
if you want string interpolation in error messages. When an error is thrown in the sub
function, the error message will integrate the call of the user-level function, which
is more informative and appropriate for the user. It offers a similar functionality for <code>warning</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stop_up(..., up = 1, msg = NULL, envir = parent.frame(), verbatim = FALSE)

stopi(..., envir = parent.frame())

warni(..., envir = parent.frame(), immediate. = FALSE)

warn_up(
  ...,
  up = 1,
  immediate. = FALSE,
  envir = parent.frame(),
  verbatim = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="stop_up_+3A_...">...</code></td>
<td>
<p>Objects that will be coerced to character and will compose the error message.</p>
</td></tr>
<tr><td><code id="stop_up_+3A_up">up</code></td>
<td>
<p>The number of frames up, default is 1. The call in the error message will be based on the function <code>up</code> frames up the stack. See examples. If you have many calls to <code>stop_up</code>/<code>warn_up</code> with a value of <code>up</code> different than one, you can use <code><a href="#topic+set_up">set_up</a></code> to change the default value of <code>up</code> within the function.</p>
</td></tr>
<tr><td><code id="stop_up_+3A_msg">msg</code></td>
<td>
<p>A character vector, default is <code>NULL</code>. If provided, this message will be displayed right under the error message. This is mostly useful when the text contains formatting because the function <code><a href="base.html#topic+stop">stop</a></code> used to send the error message erases any formatting.</p>
</td></tr>
<tr><td><code id="stop_up_+3A_envir">envir</code></td>
<td>
<p>An environment, default is <code>parent.frame()</code>. Only relevant if the error/warning message contains
interpolation (interpolation is performed with <a href="https://github.com/lrberge/stringmagic">stringmagic</a>). It tells
where the variables to be interpolated should be found. In general you should not worry about this argument.</p>
</td></tr>
<tr><td><code id="stop_up_+3A_verbatim">verbatim</code></td>
<td>
<p>Logical scalar, default is <code>FALSE</code>. By default the error/warning message allows variable
interpolation with <a href="https://github.com/lrberge/stringmagic">stringmagic</a>. To disable interpolation,
use <code>verbatim = TRUE</code>.</p>
</td></tr>
<tr><td><code id="stop_up_+3A_immediate.">immediate.</code></td>
<td>
<p>Whether the warning message should be prompted directly. Defaults to <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions are really made for package developers to facilitate the good practice of providing informative user-level error/warning messages.
</p>
<p>The error/warning messages allow variable interpolation by making use of <a href="https://github.com/lrberge/stringmagic">stringmagic</a>'s interpolation.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>stopi()</code>: Error messages with string interpolation
</p>
</li>
<li> <p><code>warni()</code>: Warnings with string interpolation
</p>
</li>
<li> <p><code>warn_up()</code>: Warnings at the level of user-level functions
</p>
</li></ul>


<h3>Author(s)</h3>

<p>Laurent Berge
</p>


<h3>See Also</h3>

<p>For general argument checking, see <code><a href="#topic+check_arg">check_arg()</a></code> and <code><a href="#topic+check_set_arg">check_set_arg()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# We create a main user-level function
# The computation is done by an internal function
# Here we compare stop_up with a regular stop

main_function = function(x = 1, y = 2){
  my_internal_function(x, y)
}

my_internal_function = function(x, y){
  if(!is.numeric(x)){
    stop_up("Argument 'x' must be numeric but currently isn't.")
  }

  # Now regular stop
  if(!is.numeric(y)){
    stop("Argument 'y' must be numeric but currently isn't.")
  }

  nx = length(x)
  ny = length(y)
  if(nx != ny){
    # Note that we use string interpolation with {}
    warn_up("The lengths of x and y don't match: {nx} vs {ny}.")
  }

  x + y
}

# Let's compare the two error messages
# stop_up:
try(main_function(x = "a"))
# =&gt; the user understands that the problem is with x

# Now compare with the regular stop:
try(main_function(y = "a"))
# Since the user has no clue of what my_internal_function is,
#  s/he will be puzzled of what to do to sort this out

# Same with the warning =&gt; much clearer with warn_up
main_function(1, 1:2)


</code></pre>

<hr>
<h2 id='suggest_item'>Suggest the the closest elements from a string vector</h2><span id='topic+suggest_item'></span>

<h3>Description</h3>

<p>Compares a character scalar to the elements from a character vector and
returns the elements that are the closest to the input.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>suggest_item(
  x,
  items,
  msg.write = FALSE,
  msg.newline = TRUE,
  msg.item = "variable"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="suggest_item_+3A_x">x</code></td>
<td>
<p>Character scalar, must be provided. This reference will be compared
to the elements of the string vector in the argument <code>items</code>.</p>
</td></tr>
<tr><td><code id="suggest_item_+3A_items">items</code></td>
<td>
<p>Character vector, must be provided. Elements to which the value in
argument <code>x</code> will be compared.</p>
</td></tr>
<tr><td><code id="suggest_item_+3A_msg.write">msg.write</code></td>
<td>
<p>Logical scalar, default is <code>FALSE</code>. If <code>TRUE</code>, a message is returned,
equal to <code>"Maybe you meant {enum.bq.or ? matches}?"</code> (see <a href="https://lrberge.github.io/stringmagic/articles/guide_string_magic.html">stringmagic</a>
for information on the interpolation) if there were matches. If no matches were found,
the message is <code>"FYI the {msg.item}{$s, are, enum.bq ? items}."</code>.</p>
</td></tr>
<tr><td><code id="suggest_item_+3A_msg.newline">msg.newline</code></td>
<td>
<p>Logical scalar, default is <code>TRUE</code>. Only used if <code>msg.write = TRUE</code>.
Whether to add a new line just before the message.</p>
</td></tr>
<tr><td><code id="suggest_item_+3A_msg.item">msg.item</code></td>
<td>
<p>Character scalar, default is <code>"variable"</code>. Only used if <code>msg.write = TRUE</code>.
What does the <code>items</code> represent?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is useful when used internally to guide the user to relevant choices.
</p>
<p>The choices to which the user is guided are in decreasing quality. First light mispells
are checked. Then more important mispells. Finally very important mispells. Completely
off potential matches are not reported.
</p>
<p>If the argument <code>msg.write</code> is <code>TRUE</code>, then a character scalar is returned containing
a message suggesting the matches.
</p>


<h3>Value</h3>

<p>It returns a vector of matches. If no matches were found
</p>


<h3>Author(s)</h3>

<p>Laurent Berge
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# function reporting the sum of a variable
sum_var = function(data, var){
  # var: a variable name, should be part of data
  if(!var %in% names(data)){
    suggestion = suggest_item(var, names(data), msg.write = TRUE)
    stopi("The variable `{var}` is not in the data set. {suggestion}")
  }

  sum(data[[var]])
}

# The error message guides us to a suggestion
try(sum_var(iris, "Petal.Le"))

</code></pre>

<hr>
<h2 id='validate_dots'>Checks the arguments in dots from methods</h2><span id='topic+validate_dots'></span>

<h3>Description</h3>

<p>This function informs the user of arguments passed to a method but which are not used by the method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>validate_dots(
  valid_args = c(),
  suggest_args = c(),
  message,
  warn,
  stop,
  call. = FALSE,
  immediate. = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="validate_dots_+3A_valid_args">valid_args</code></td>
<td>
<p>A character vector, default is missing. Arguments that are not in the definition of the function but which are considered as valid. Typically internal arguments that should not be directly accessed by the user.</p>
</td></tr>
<tr><td><code id="validate_dots_+3A_suggest_args">suggest_args</code></td>
<td>
<p>A character vector, default is missing. If the user provides invalid arguments, he might not be aware of the main arguments of the function. Use this argument to inform the user of these main arguments.</p>
</td></tr>
<tr><td><code id="validate_dots_+3A_message">message</code></td>
<td>
<p>Logical, default is <code>FALSE</code>. If <code>TRUE</code>, a standard message is prompted to the user (instead of a warning).</p>
</td></tr>
<tr><td><code id="validate_dots_+3A_warn">warn</code></td>
<td>
<p>Logical, default is <code>TRUE</code>. If <code>TRUE</code>, when the user provides invalid arguments, the function will call <code><a href="base.html#topic+warning">warning</a></code> (default). If <code>FALSE</code> (and so are the other arguments <code>stop</code> and <code>message</code>), then no message is prompted to the user, rather it is the only output of the function.</p>
</td></tr>
<tr><td><code id="validate_dots_+3A_stop">stop</code></td>
<td>
<p>Logical, default is <code>FALSE</code>. If <code>TRUE</code>, when the user provides invalid arguments, the function will call <code><a href="base.html#topic+stop">stop</a></code> instead of prompting a warning (default).</p>
</td></tr>
<tr><td><code id="validate_dots_+3A_call.">call.</code></td>
<td>
<p>Logical, default is <code>FALSE</code>. If <code>TRUE</code>, when the user provides invalid arguments, then the message will also contain the call to the initial function (by default, only the function name is shown).</p>
</td></tr>
<tr><td><code id="validate_dots_+3A_immediate.">immediate.</code></td>
<td>
<p>Logical, default is <code>FALSE</code>. Can be only used with the argument <code>warn = TRUE</code>: whether the warning is immediately displayed or not.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns the message to be displayed. If no message is to be displayed because all the arguments are valid, then <code>NULL</code> is returned.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# The typical use of this function is within methods

# Let's create a 'my_class' object and a summary method
my_obj = list()
class(my_obj) = "my_class"

# In the summary method, we add validate_dots
# to inform the user of invalid arguments

summary.my_class = function(object, arg_one, arg_two, ...){

  validate_dots()
  # CODE of summary.my_class
  invisible(NULL)
}

# Now let's test it, we add invalid arguments
summary(my_obj, wrong = 3)
summary(my_obj, wrong = 3, info = 5)

# Now let's :
#   i) inform the user that argument arg_one is the main argument
#  ii) consider 'info' as a valid argument (but not shown to the user)
# iii) show a message instead of a warning

summary.my_class = function(object, arg_one, arg_two, ...){

  validate_dots(valid_args = "info", suggest_args = "arg_one", message = TRUE)
  # CODE of summary.my_class
  invisible(NULL)
}

# Let's retest it
summary(my_obj, wrong = 3) # not OK =&gt; suggestions
summary(my_obj, info = 5)  # OK



</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
